target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.ImGuiContext = type { i8, i8, %struct.ImGuiIO, %struct.ImGuiStyle, ptr, float, float, %struct.ImDrawListSharedData, double, i32, i32, i32, i8, i8, i8, i8, i8, ptr, %struct.ImVector.1, %struct.ImVector.1, i32, i32, %struct.ImVector.2, %struct.ImVector.2, %struct.ImVector.2, %struct.ImVector.3, %struct.ImGuiStorage, i32, %struct.ImVec2, ptr, ptr, ptr, ptr, ptr, %struct.ImVec2, i32, i32, float, %struct.ImVec2, %struct.ImVec2, i32, i32, i32, i8, i8, float, float, i32, i32, float, i8, i8, i8, i8, i8, i8, %struct.ImVec2, ptr, i32, i32, i32, i8, i8, ptr, i32, float, [154 x %struct.ImGuiKeyOwnerData], %struct.ImGuiKeyRoutingTable, i32, i8, i32, i32, i32, i32, %struct.ImGuiNextItemData, %struct.ImGuiLastItemData, [4 x i8], %struct.ImGuiNextWindowData, i8, i32, %struct.ImVector.6, %struct.ImVector.7, %struct.ImVector.8, %struct.ImVector.9, %struct.ImVector.10, %struct.ImVector.11, %struct.ImVector.12, %struct.ImVector.12, %struct.ImVector.13, i32, %struct.ImVector.14, ptr, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i64, i8, i8, i8, i8, i8, i8, i8, i8, %struct.ImGuiNavItemData, i8, i8, i8, i32, i32, i32, i32, i32, i32, %struct.ImRect, %struct.ImRect, i32, i32, i32, %struct.ImGuiNavItemData, %struct.ImGuiNavItemData, %struct.ImGuiNavItemData, %struct.ImGuiNavItemData, i32, i32, ptr, ptr, ptr, float, float, i8, %struct.ImVec2, %struct.ImVec2, float, i8, i8, i8, i32, i32, i32, %struct.ImGuiPayload, %struct.ImRect, %struct.ImRect, i32, i32, float, i32, i32, i32, i32, %struct.ImVector.15, [16 x i8], i32, %struct.ImVector.16, ptr, i32, %struct.ImVector.17, %struct.ImPool, %struct.ImVector.19, %struct.ImVector.20, ptr, %struct.ImPool.21, %struct.ImVector.23, %struct.ImVector.24, i32, i32, float, float, i32, i32, i32, float, %struct.ImVec2, %struct.ImGuiInputTextState, %struct.ImGuiInputTextDeactivatedState, %struct.ImFont, i32, i32, i32, i32, float, float, i32, %struct.ImVec4, %struct.ImGuiComboPreviewData, %struct.ImRect, i8, float, float, i8, i8, float, float, float, float, i16, i16, i16, %struct.ImVector.25, %struct.ImVector.9, %struct.ImGuiTypingSelectState, %struct.ImGuiPlatformImeData, %struct.ImGuiPlatformImeData, i8, float, %struct.ImGuiTextBuffer, %struct.ImVector.27, %struct.ImChunkStream, %struct.ImChunkStream.28, %struct.ImVector.29, i32, [8 x ptr], i8, i32, ptr, %struct.ImGuiTextBuffer, ptr, ptr, float, i8, i32, i32, i32, i32, %struct.ImGuiTextBuffer, %struct.ImGuiTextIndex, i8, i8, i8, i8, i8, i32, float, %struct.ImVec4, %struct.ImGuiMetricsConfig, %struct.ImGuiIDStackTool, %struct.ImGuiDebugAllocInfo, [60 x float], i32, i32, float, i32, i32, i32, %struct.ImVector.25 }
%struct.ImGuiIO = type { i32, i32, %struct.ImVec2, float, float, ptr, ptr, ptr, ptr, float, i8, ptr, %struct.ImVec2, i8, i8, i8, i8, i8, i8, i8, i8, float, float, float, float, float, float, i8, i8, i8, i8, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i16, i8, i8, i8, i8, i8, i8, i8, float, i32, i32, i32, i32, %struct.ImVec2, [666 x i32], [666 x i8], [16 x float], ptr, ptr, %struct.ImVec2, [5 x i8], float, float, i32, i8, i8, i8, i8, i32, [666 x %struct.ImGuiKeyData], i8, %struct.ImVec2, [5 x %struct.ImVec2], [5 x double], [5 x i8], [5 x i8], [5 x i16], [5 x i16], [5 x i8], [5 x i8], [5 x i8], i8, [5 x float], [5 x float], [5 x float], float, i8, i8, i8, i8, i16, %struct.ImVector }
%struct.ImGuiKeyData = type { i8, float, float, float }
%struct.ImVector = type { i32, i32, ptr }
%struct.ImGuiStyle = type { float, float, %struct.ImVec2, float, float, %struct.ImVec2, %struct.ImVec2, i32, float, float, float, float, %struct.ImVec2, float, float, %struct.ImVec2, %struct.ImVec2, %struct.ImVec2, %struct.ImVec2, float, float, float, float, float, float, float, float, float, float, float, float, i32, %struct.ImVec2, %struct.ImVec2, float, %struct.ImVec2, %struct.ImVec2, %struct.ImVec2, %struct.ImVec2, float, i8, i8, i8, float, float, [53 x %struct.ImVec4], float, float, float, i32, i32 }
%struct.ImDrawListSharedData = type { %struct.ImVec2, ptr, float, float, float, %struct.ImVec4, i32, %struct.ImVector.0, [48 x %struct.ImVec2], float, [64 x i8], ptr }
%struct.ImVector.0 = type { i32, i32, ptr }
%struct.ImVector.1 = type { i32, i32, ptr }
%struct.ImVector.2 = type { i32, i32, ptr }
%struct.ImVector.3 = type { i32, i32, ptr }
%struct.ImGuiStorage = type { %struct.ImVector.4 }
%struct.ImVector.4 = type { i32, i32, ptr }
%struct.ImGuiKeyOwnerData = type <{ i32, i32, i8, i8, [2 x i8] }>
%struct.ImGuiKeyRoutingTable = type { [154 x i16], %struct.ImVector.5, %struct.ImVector.5 }
%struct.ImVector.5 = type { i32, i32, ptr }
%struct.ImGuiNextItemData = type <{ i32, i32, float, [4 x i8], i64, i32, i8, [3 x i8] }>
%struct.ImGuiLastItemData = type { i32, i32, i32, %struct.ImRect, %struct.ImRect, %struct.ImRect, %struct.ImRect }
%struct.ImGuiNextWindowData = type <{ i32, i32, i32, i32, %struct.ImVec2, %struct.ImVec2, %struct.ImVec2, %struct.ImVec2, %struct.ImVec2, i32, i8, [3 x i8], %struct.ImRect, ptr, ptr, float, %struct.ImVec2, [4 x i8] }>
%struct.ImVector.6 = type { i32, i32, ptr }
%struct.ImVector.7 = type { i32, i32, ptr }
%struct.ImVector.8 = type { i32, i32, ptr }
%struct.ImVector.10 = type { i32, i32, ptr }
%struct.ImVector.11 = type { i32, i32, ptr }
%struct.ImVector.12 = type { i32, i32, ptr }
%struct.ImVector.13 = type { i32, i32, ptr }
%struct.ImVector.14 = type { i32, i32, ptr }
%struct.ImGuiNavItemData = type <{ ptr, i32, i32, %struct.ImRect, i32, [4 x i8], i64, float, float, float, [4 x i8] }>
%struct.ImGuiPayload = type <{ ptr, i32, i32, i32, i32, [33 x i8], i8, i8, [5 x i8] }>
%struct.ImVector.15 = type { i32, i32, ptr }
%struct.ImVector.16 = type { i32, i32, ptr }
%struct.ImVector.17 = type { i32, i32, ptr }
%struct.ImPool = type { %struct.ImVector.18, %struct.ImGuiStorage, i32, i32 }
%struct.ImVector.18 = type { i32, i32, ptr }
%struct.ImVector.19 = type { i32, i32, ptr }
%struct.ImVector.20 = type { i32, i32, ptr }
%struct.ImPool.21 = type { %struct.ImVector.22, %struct.ImGuiStorage, i32, i32 }
%struct.ImVector.22 = type { i32, i32, ptr }
%struct.ImVector.23 = type { i32, i32, ptr }
%struct.ImVector.24 = type { i32, i32, ptr }
%struct.ImVec2 = type { float, float }
%struct.ImGuiInputTextState = type <{ ptr, i32, i32, i32, [4 x i8], %struct.ImVector, %struct.ImVector.25, %struct.ImVector.25, i8, [3 x i8], i32, float, %"struct.ImStb::STB_TexteditState", float, i8, i8, i8, i8, i32, [4 x i8] }>
%"struct.ImStb::STB_TexteditState" = type { i32, i32, i32, i8, i32, i8, i8, i8, i8, i8, i8, i8, float, %"struct.ImStb::StbUndoState" }
%"struct.ImStb::StbUndoState" = type { [99 x %"struct.ImStb::StbUndoRecord"], [999 x i16], i16, i16, i32, i32 }
%"struct.ImStb::StbUndoRecord" = type { i32, i32, i32, i32 }
%struct.ImGuiInputTextDeactivatedState = type { i32, %struct.ImVector.25 }
%struct.ImFont = type <{ %struct.ImVector.19, float, float, %struct.ImVector, %struct.ImVector.26, ptr, ptr, ptr, i16, i16, i16, i16, float, float, i8, [3 x i8], float, float, float, i32, [2 x i8], [2 x i8] }>
%struct.ImVector.26 = type { i32, i32, ptr }
%struct.ImGuiComboPreviewData = type { %struct.ImRect, %struct.ImVec2, %struct.ImVec2, %struct.ImVec2, float, i32 }
%struct.ImRect = type { %struct.ImVec2, %struct.ImVec2 }
%struct.ImVector.9 = type { i32, i32, ptr }
%struct.ImGuiTypingSelectState = type <{ %struct.ImGuiTypingSelectRequest, [64 x i8], i32, i32, float, i8, [3 x i8] }>
%struct.ImGuiTypingSelectRequest = type { i32, i32, ptr, i8, i8, i8 }
%struct.ImGuiPlatformImeData = type { i8, %struct.ImVec2, float }
%struct.ImVector.27 = type { i32, i32, ptr }
%struct.ImChunkStream = type { %struct.ImVector.25 }
%struct.ImChunkStream.28 = type { %struct.ImVector.25 }
%struct.ImVector.29 = type { i32, i32, ptr }
%struct.ImGuiTextBuffer = type { %struct.ImVector.25 }
%struct.ImGuiTextIndex = type <{ %struct.ImVector.10, i32, [4 x i8] }>
%struct.ImVec4 = type { float, float, float, float }
%struct.ImGuiMetricsConfig = type { i8, i8, i8, i8, i8, i8, i8, i8, i32, i32 }
%struct.ImGuiIDStackTool = type { i32, i32, i32, %struct.ImVector.30, i8, float }
%struct.ImVector.30 = type { i32, i32, ptr }
%struct.ImGuiDebugAllocInfo = type { i32, i32, i16, [6 x %struct.ImGuiDebugAllocEntry] }
%struct.ImGuiDebugAllocEntry = type { i32, i16, i16 }
%struct.ImVector.25 = type { i32, i32, ptr }
%struct.ImGuiTableTempData = type <{ i32, float, float, %struct.ImVec2, [4 x i8], %struct.ImDrawListSplitter, %struct.ImRect, %struct.ImRect, %struct.ImVec2, %struct.ImVec2, %struct.ImVec2, %struct.ImVec1, float, i32, [4 x i8] }>
%struct.ImDrawListSplitter = type { i32, i32, %struct.ImVector.20 }
%struct.ImVec1 = type { float }
%struct.ImGuiTableInstanceData = type { i32, float, float, float, i32, i32 }
%struct.ImGuiTableColumn = type <{ i32, float, float, float, float, float, float, float, %struct.ImRect, i32, float, float, float, float, float, float, float, i16, i16, i16, i16, i16, i16, i16, i16, i16, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8 }>
%struct.ImGuiWindow = type <{ ptr, ptr, i32, i32, i32, [4 x i8], ptr, %struct.ImVec2, %struct.ImVec2, %struct.ImVec2, %struct.ImVec2, %struct.ImVec2, %struct.ImVec2, %struct.ImVec2, float, float, float, float, float, float, float, float, i32, i32, i32, %struct.ImVec2, %struct.ImVec2, %struct.ImVec2, %struct.ImVec2, %struct.ImVec2, %struct.ImVec2, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16, i16, i16, [2 x i8], i32, i8, i8, i8, i8, i32, i8, i8, i8, i8, i24, %struct.ImVec2, %struct.ImVec2, [4 x i8], %struct.ImVector.9, %struct.ImGuiWindowTempData, %struct.ImRect, %struct.ImRect, %struct.ImRect, %struct.ImRect, %struct.ImRect, %struct.ImRect, %struct.ImRect, %struct.ImVec2ih, %struct.ImVec2ih, i32, float, float, [4 x i8], %struct.ImGuiStorage, %struct.ImVector.31, float, i32, ptr, %struct.ImDrawList, ptr, ptr, ptr, ptr, ptr, ptr, ptr, [2 x i32], [2 x %struct.ImRect], [2 x %struct.ImVec2], i32, i32, i32, i8, [3 x i8] }>
%struct.ImGuiWindowTempData = type { %struct.ImVec2, %struct.ImVec2, %struct.ImVec2, %struct.ImVec2, %struct.ImVec2, %struct.ImVec2, %struct.ImVec2, float, float, i8, i8, %struct.ImVec1, %struct.ImVec1, %struct.ImVec1, %struct.ImVec2, i32, i16, i16, i8, i8, i8, i8, %struct.ImVec2, %struct.ImGuiMenuColumns, i32, i32, %struct.ImVector.2, ptr, ptr, i32, i32, i32, float, float, %struct.ImVector.19, %struct.ImVector.19 }
%struct.ImGuiMenuColumns = type <{ i32, i32, i16, i16, i16, i16, i16, [4 x i16], [2 x i8] }>
%struct.ImVec2ih = type { i16, i16 }
%struct.ImVector.31 = type { i32, i32, ptr }
%struct.ImDrawList = type <{ %struct.ImVector.32, %struct.ImVector, %struct.ImVector.33, i32, i32, ptr, ptr, ptr, ptr, %struct.ImVector.34, %struct.ImVector.35, %struct.ImVector.0, %struct.ImDrawCmdHeader, %struct.ImDrawListSplitter, float, [4 x i8] }>
%struct.ImVector.32 = type { i32, i32, ptr }
%struct.ImVector.33 = type { i32, i32, ptr }
%struct.ImVector.34 = type { i32, i32, ptr }
%struct.ImVector.35 = type { i32, i32, ptr }
%struct.ImDrawCmdHeader = type <{ %struct.ImVec4, ptr, i32, [4 x i8] }>
%struct.ImGuiTable = type <{ i32, i32, ptr, ptr, %struct.ImSpan, %struct.ImSpan.36, %struct.ImSpan.37, ptr, ptr, ptr, i32, i32, i32, i32, i32, i32, i16, i16, float, float, float, float, float, float, i32, i32, [2 x i32], i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, %struct.ImRect, %struct.ImRect, %struct.ImRect, %struct.ImRect, %struct.ImRect, %struct.ImRect, %struct.ImRect, %struct.ImRect, %struct.ImRect, ptr, ptr, %struct.ImGuiTextBuffer, ptr, %struct.ImGuiTableInstanceData, %struct.ImVector.38, %struct.ImGuiTableColumnSortSpecs, [4 x i8], %struct.ImVector.39, %struct.ImGuiTableSortSpecs, i16, i16, i16, i16, i16, i16, i16, i16, i16, i16, i16, i16, i16, i16, i16, i16, i16, i16, i16, i16, i16, i16, i16, i16, i16, i16, i16, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, [6 x i8] }>
%struct.ImSpan = type { ptr, ptr }
%struct.ImSpan.36 = type { ptr, ptr }
%struct.ImSpan.37 = type { ptr, ptr }
%struct.ImVector.38 = type { i32, i32, ptr }
%struct.ImGuiTableColumnSortSpecs = type <{ i32, i16, i16, i8, [3 x i8] }>
%struct.ImVector.39 = type { i32, i32, ptr }
%struct.ImGuiTableSortSpecs = type <{ ptr, i32, i8, [3 x i8] }>
%struct.ImSpanAllocator = type { ptr, i32, i32, [6 x i32], [6 x i32] }
%struct.ImGuiTableSettings = type <{ i32, i32, float, i16, i16, i8, [3 x i8] }>
%struct.ImGuiTableColumnSettings = type <{ float, i32, i16, i16, i16, i8, i8 }>
%struct.ImGuiTableCellData = type { i32, i16 }
%struct.MergeGroup = type { %struct.ImRect, i32, ptr }
%struct.ImDrawChannel = type { %struct.ImVector.32, %struct.ImVector }
%struct.ImDrawCmd = type { %struct.ImVec4, ptr, i32, i32, i32, ptr, ptr }
%struct.ImGuiSettingsHandler = type { ptr, i32, ptr, ptr, ptr, ptr, ptr, ptr, ptr }
%struct.ImGuiOldColumns = type { i32, i32, i8, i8, i32, i32, float, float, float, float, float, float, %struct.ImRect, %struct.ImRect, %struct.ImRect, %struct.ImVector.40, %struct.ImDrawListSplitter }
%struct.ImVector.40 = type { i32, i32, ptr }
%struct.ImGuiOldColumnData = type { float, float, i32, %struct.ImRect }
%"struct.ImGuiStorage::ImGuiStoragePair" = type { i32, %union.anon }
%union.anon = type { ptr }

$_ZN6ImPoolI10ImGuiTableE8GetByKeyEj = comdat any

$_ZN5ImGui16GetCurrentWindowEv = comdat any

$_ZN6ImRectC2ERK6ImVec2S2_ = comdat any

$_ZN5ImGui8ItemSizeERK6ImRectf = comdat any

$_ZN6ImPoolI10ImGuiTableE13GetOrAddByKeyEj = comdat any

$_ZNK6ImPoolI10ImGuiTableE8GetIndexEPKS0_ = comdat any

$_ZN8ImVectorI18ImGuiTableTempDataE6resizeEiRKS0_ = comdat any

$_ZN18ImGuiTableTempDataC2Ev = comdat any

$_ZN18ImGuiTableTempDataD2Ev = comdat any

$_ZN8ImVectorI18ImGuiTableTempDataEixEi = comdat any

$_ZN18ImDrawListSplitter5ClearEv = comdat any

$_Z13TableFixFlagsiP11ImGuiWindow = comdat any

$_ZN8ImVectorI22ImGuiTableInstanceDataE9push_backERKS0_ = comdat any

$_ZN22ImGuiTableInstanceDataC2Ev = comdat any

$_ZN5ImGui20TableGetInstanceDataEP10ImGuiTablei = comdat any

$_ZN6ImVec2C2Eff = comdat any

$_ZNK6ImRect7GetSizeEv = comdat any

$_ZNK11ImGuiWindow4RectEv = comdat any

$_ZN6ImRect8ClipWithERKS_ = comdat any

$_ZN6ImRect12ClipWithFullERKS_ = comdat any

$_ZN8ImVectorIfE6resizeEiRKf = comdat any

$_ZN8ImVectorIfEixEi = comdat any

$_ZNK6ImSpanI16ImGuiTableColumnE4sizeEv = comdat any

$_ZN6ImSpanI16ImGuiTableColumnEixEi = comdat any

$_ZN16ImGuiTableColumnC2Ev = comdat any

$_ZN6ImSpanIsEixEi = comdat any

$_ZN8ImVectorIcE6resizeEi = comdat any

$_Z31ImBitArrayGetStorageSizeInBytesi = comdat any

$_ZN15ImSpanAllocatorILi6EEC2Ev = comdat any

$_ZN15ImSpanAllocatorILi6EE7ReserveEimi = comdat any

$_ZN15ImSpanAllocatorILi6EE19GetArenaSizeInBytesEv = comdat any

$_ZN15ImSpanAllocatorILi6EE15SetArenaBasePtrEPv = comdat any

$_ZN15ImSpanAllocatorILi6EE7GetSpanI16ImGuiTableColumnEEviP6ImSpanIT_E = comdat any

$_ZN15ImSpanAllocatorILi6EE7GetSpanIsEEviP6ImSpanIT_E = comdat any

$_ZN15ImSpanAllocatorILi6EE7GetSpanI18ImGuiTableCellDataEEviP6ImSpanIT_E = comdat any

$_ZN15ImSpanAllocatorILi6EE15GetSpanPtrBeginEi = comdat any

$_Z22ImBitArrayClearAllBitsPji = comdat any

$_Z16ImBitArraySetBitPji = comdat any

$_ZNK6ImRect8GetWidthEv = comdat any

$_ZN6ImRectC2Effff = comdat any

$_ZNK6ImRect9GetHeightEv = comdat any

$_ZN8ImVectorI6ImVec4E4backEv = comdat any

$_ZN6ImRectC2ERK6ImVec4 = comdat any

$_ZN6ImPoolI10ImGuiTableE10GetByIndexEi = comdat any

$_ZNK15ImGuiTextBuffer4sizeEv = comdat any

$_ZNK6ImSpanI16ImGuiTableColumnEixEi = comdat any

$_ZNK8ImVectorIcEixEi = comdat any

$_ZN5ImGui18TableGetInstanceIDEP10ImGuiTablei = comdat any

$_ZN6ImSpanI18ImGuiTableCellDataEixEi = comdat any

$_ZNK6ImRect6ToVec4Ev = comdat any

$_ZN8ImVectorIcE7reserveEi = comdat any

$_ZN8ImVectorI13ImDrawChannelEixEi = comdat any

$_ZN8ImVectorI9ImDrawCmdE4backEv = comdat any

$_ZN8ImVectorI9ImDrawCmdE8pop_backEv = comdat any

$_ZN6ImRect3AddERKS_ = comdat any

$_ZN8ImVectorI9ImDrawCmdEixEi = comdat any

$_ZN8ImVectorI13ImDrawChannelE6resizeEi = comdat any

$_Z21ImBitArraySetBitRangePjii = comdat any

$_Z18ImBitArrayClearBitPji = comdat any

$_ZNK6ImRect8OverlapsERKS_ = comdat any

$_ZN8ImVectorI25ImGuiTableColumnSortSpecsE6resizeEi = comdat any

$_ZN6ImVec2C2Ev = comdat any

$_ZNK6ImRect5GetBLEv = comdat any

$_ZN5ImGui14LocalizeGetMsgE11ImGuiLocKey = comdat any

$_ZN13ImChunkStreamI18ImGuiTableSettingsE11alloc_chunkEm = comdat any

$_ZN13ImChunkStreamI18ImGuiTableSettingsE5beginEv = comdat any

$_ZN13ImChunkStreamI18ImGuiTableSettingsE10next_chunkEPS0_ = comdat any

$_ZN13ImChunkStreamI18ImGuiTableSettingsE15ptr_from_offsetEi = comdat any

$_ZN13ImChunkStreamI18ImGuiTableSettingsE15offset_from_ptrEPKS0_ = comdat any

$_ZN18ImGuiTableSettings17GetColumnSettingsEv = comdat any

$_ZN20ImGuiSettingsHandlerC2Ev = comdat any

$_ZN6ImPoolI10ImGuiTableE6RemoveEjPKS0_ = comdat any

$_ZN8ImVectorI25ImGuiTableColumnSortSpecsE5clearEv = comdat any

$_ZN15ImGuiTextBuffer5clearEv = comdat any

$_ZN13ImChunkStreamI18ImGuiTableSettingsEC2Ev = comdat any

$_ZN13ImChunkStreamI18ImGuiTableSettingsE4swapERS1_ = comdat any

$_ZN13ImChunkStreamI18ImGuiTableSettingsED2Ev = comdat any

$_ZN5ImGui20GetCurrentWindowReadEv = comdat any

$_ZN8ImVectorI18ImGuiOldColumnDataEixEi = comdat any

$_ZN8ImVectorI15ImGuiOldColumnsEixEi = comdat any

$_ZN8ImVectorI15ImGuiOldColumnsE9push_backERKS0_ = comdat any

$_ZN15ImGuiOldColumnsC2Ev = comdat any

$_ZN15ImGuiOldColumnsD2Ev = comdat any

$_ZN8ImVectorI15ImGuiOldColumnsE4backEv = comdat any

$_ZN8ImVectorI18ImGuiOldColumnDataE6resizeEi = comdat any

$_ZN8ImVectorI18ImGuiOldColumnDataE7reserveEi = comdat any

$_ZN18ImGuiOldColumnDataC2Ev = comdat any

$_ZN8ImVectorI18ImGuiOldColumnDataE9push_backERKS0_ = comdat any

$_ZN18ImDrawListSplitterC2Ev = comdat any

$_ZN6ImRectC2Ev = comdat any

$_ZN6ImVec1C2Ev = comdat any

$_ZN18ImDrawListSplitterD2Ev = comdat any

$_ZN8ImVectorI13ImDrawChannelEC2Ev = comdat any

$__clang_call_terminate = comdat any

$_ZN8ImVectorI13ImDrawChannelED2Ev = comdat any

$_ZN8ImVectorI22ImGuiTableInstanceDataEixEi = comdat any

$_ZNK6ImSpanI16ImGuiTableColumnE14index_from_ptrEPKS0_ = comdat any

$_ZN6ImVec4C2Effff = comdat any

$_Znwm12ImNewWrapperPv = comdat any

$_ZN18ImGuiTableSettingsC2Ev = comdat any

$_ZdlPv12ImNewWrapperS_ = comdat any

$_ZN24ImGuiTableColumnSettingsC2Ev = comdat any

$_ZNK6ImPoolI10ImGuiTableE10GetMapSizeEv = comdat any

$_ZN6ImPoolI10ImGuiTableE13TryGetMapDataEi = comdat any

$_ZN13ImChunkStreamI18ImGuiTableSettingsE5clearEv = comdat any

$_ZN8ImVectorIN12ImGuiStorage16ImGuiStoragePairEEixEi = comdat any

$_ZN8ImVectorIcE5clearEv = comdat any

$_ZN15ImGuiTextBuffer7reserveEi = comdat any

$_ZN8ImVectorIcEC2Ev = comdat any

$_ZN8ImVectorIcED2Ev = comdat any

$_ZN8ImVectorI18ImGuiOldColumnDataEC2Ev = comdat any

$_ZN8ImVectorI18ImGuiOldColumnDataED2Ev = comdat any

$_ZN8ImVectorI10ImGuiTableEixEi = comdat any

$_ZN6ImPoolI10ImGuiTableE3AddEv = comdat any

$_ZN8ImVectorI10ImGuiTableE6resizeEi = comdat any

$_ZN10ImGuiTableC2Ev = comdat any

$_ZN8ImVectorI10ImGuiTableE7reserveEi = comdat any

$_ZNK8ImVectorI10ImGuiTableE14_grow_capacityEi = comdat any

$_ZN6ImSpanI16ImGuiTableColumnEC2Ev = comdat any

$_ZN6ImSpanIsEC2Ev = comdat any

$_ZN6ImSpanI18ImGuiTableCellDataEC2Ev = comdat any

$_ZN15ImGuiTextBufferC2Ev = comdat any

$_ZN8ImVectorI22ImGuiTableInstanceDataEC2Ev = comdat any

$_ZN25ImGuiTableColumnSortSpecsC2Ev = comdat any

$_ZN8ImVectorI25ImGuiTableColumnSortSpecsEC2Ev = comdat any

$_ZN19ImGuiTableSortSpecsC2Ev = comdat any

$_ZN8ImVectorI25ImGuiTableColumnSortSpecsED2Ev = comdat any

$_ZN8ImVectorI22ImGuiTableInstanceDataED2Ev = comdat any

$_ZN15ImGuiTextBufferD2Ev = comdat any

$_ZN8ImVectorI18ImGuiTableTempDataE7reserveEi = comdat any

$_ZNK8ImVectorI18ImGuiTableTempDataE14_grow_capacityEi = comdat any

$_ZN8ImVectorI22ImGuiTableInstanceDataE7reserveEi = comdat any

$_ZNK8ImVectorI22ImGuiTableInstanceDataE14_grow_capacityEi = comdat any

$_ZN8ImVectorIfE7reserveEi = comdat any

$_ZNK8ImVectorIfE14_grow_capacityEi = comdat any

$_ZNK8ImVectorIcE14_grow_capacityEi = comdat any

$_ZN6ImSpanI16ImGuiTableColumnE3setEPS0_S2_ = comdat any

$_ZN15ImSpanAllocatorILi6EE13GetSpanPtrEndEi = comdat any

$_ZN6ImSpanIsE3setEPsS1_ = comdat any

$_ZN6ImSpanI18ImGuiTableCellDataE3setEPS0_S2_ = comdat any

$_ZN8ImVectorI13ImDrawChannelE7reserveEi = comdat any

$_ZNK8ImVectorI13ImDrawChannelE14_grow_capacityEi = comdat any

$_ZN8ImVectorI25ImGuiTableColumnSortSpecsE7reserveEi = comdat any

$_ZNK8ImVectorI25ImGuiTableColumnSortSpecsE14_grow_capacityEi = comdat any

$_ZN13ImChunkStreamI18ImGuiTableSettingsE10chunk_sizeEPKS0_ = comdat any

$_ZN13ImChunkStreamI18ImGuiTableSettingsE3endEv = comdat any

$_ZN6ImPoolI10ImGuiTableE6RemoveEji = comdat any

$_ZN10ImGuiTableD2Ev = comdat any

$_ZN8ImVectorIcE4swapERS0_ = comdat any

$_ZN8ImVectorI15ImGuiOldColumnsE7reserveEi = comdat any

$_ZNK8ImVectorI15ImGuiOldColumnsE14_grow_capacityEi = comdat any

$_ZNK8ImVectorI18ImGuiOldColumnDataE14_grow_capacityEi = comdat any

@GImGui = external global ptr, align 8
@.str = private unnamed_addr constant [12 x i8] c"##Instances\00", align 1
@.str.1 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.2 = private unnamed_addr constant [2 x i8] c"|\00", align 1
@.str.3 = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str.4 = private unnamed_addr constant [5 x i8] c"%.*s\00", align 1
@.str.5 = private unnamed_addr constant [16 x i8] c"##AngledHeaders\00", align 1
@.str.6 = private unnamed_addr constant [14 x i8] c"##ContextMenu\00", align 1
@.str.7 = private unnamed_addr constant [10 x i8] c"<Unknown>\00", align 1
@.str.8 = private unnamed_addr constant [6 x i8] c"Table\00", align 1
@.str.9 = private unnamed_addr constant [37 x i8] c"Table 0x%08X (%d columns, in '%s')%s\00", align 1
@.str.10 = private unnamed_addr constant [12 x i8] c" *Inactive*\00", align 1
@.str.11 = private unnamed_addr constant [76 x i8] c"** %d instances of same table! Some data below will refer to last instance.\00", align 1
@.str.12 = private unnamed_addr constant [15 x i8] c"Clear settings\00", align 1
@.str.13 = private unnamed_addr constant [59 x i8] c"OuterRect: Pos: (%.1f,%.1f) Size: (%.1f,%.1f) Sizing: '%s'\00", align 1
@.str.14 = private unnamed_addr constant [71 x i8] c"ColumnsGivenWidth: %.1f, ColumnsAutoFitWidth: %.1f, InnerWidth: %.1f%s\00", align 1
@.str.15 = private unnamed_addr constant [8 x i8] c" (auto)\00", align 1
@.str.16 = private unnamed_addr constant [65 x i8] c"CellPaddingX: %.1f, CellSpacingX: %.1f/%.1f, OuterPaddingX: %.1f\00", align 1
@.str.17 = private unnamed_addr constant [47 x i8] c"HoveredColumnBody: %d, HoveredColumnBorder: %d\00", align 1
@.str.18 = private unnamed_addr constant [59 x i8] c"ResizedColumn: %d, ReorderColumn: %d, HeldHeaderColumn: %d\00", align 1
@.str.19 = private unnamed_addr constant [51 x i8] c"Instance %d: HoveredRow: %d, LastOuterHeight: %.2f\00", align 1
@.str.20 = private unnamed_addr constant [375 x i8] c"Column %d order %d '%s': offset %+.2f to %+.2f%s\0AEnabled: %d, VisibleX/Y: %d/%d, RequestOutput: %d, SkipItems: %d, DrawChannels: %d,%d\0AWidthGiven: %.1f, Request/Auto: %.1f/%.1f, StretchWeight: %.3f (%.1f%%)\0AMinX: %.1f, MaxX: %.1f (%+.1f), ClipRect: %.1f to %.1f (+%.1f)\0AContentWidth: %.1f,%.1f, HeadersUsed/Ideal %.1f/%.1f\0ASort: %d%s, UserID: 0x%08X, Flags: 0x%04X: %s%s%s..\00", align 1
@.str.21 = private unnamed_addr constant [10 x i8] c" (Frozen)\00", align 1
@.str.22 = private unnamed_addr constant [7 x i8] c" (Asc)\00", align 1
@.str.23 = private unnamed_addr constant [7 x i8] c" (Des)\00", align 1
@.str.24 = private unnamed_addr constant [14 x i8] c"WidthStretch \00", align 1
@.str.25 = private unnamed_addr constant [12 x i8] c"WidthFixed \00", align 1
@.str.26 = private unnamed_addr constant [10 x i8] c"NoResize \00", align 1
@.str.27 = private unnamed_addr constant [29 x i8] c"Settings 0x%08X (%d columns)\00", align 1
@.str.28 = private unnamed_addr constant [18 x i8] c"SaveFlags: 0x%08X\00", align 1
@.str.29 = private unnamed_addr constant [26 x i8] c"ColumnsCount: %d (max %d)\00", align 1
@.str.30 = private unnamed_addr constant [65 x i8] c"Column %d Order %d SortOrder %d %s Vis %d %s %7.3f UserID 0x%08X\00", align 1
@.str.31 = private unnamed_addr constant [4 x i8] c"Asc\00", align 1
@.str.32 = private unnamed_addr constant [4 x i8] c"Des\00", align 1
@.str.33 = private unnamed_addr constant [4 x i8] c"---\00", align 1
@.str.34 = private unnamed_addr constant [7 x i8] c"Weight\00", align 1
@.str.35 = private unnamed_addr constant [7 x i8] c"Width \00", align 1
@.str.36 = private unnamed_addr constant [8 x i8] c"columns\00", align 1
@.str.37 = private unnamed_addr constant [15 x i8] c"*Missing Text*\00", align 1
@.str.38 = private unnamed_addr constant [10 x i8] c"0x%08X,%d\00", align 1
@.str.39 = private unnamed_addr constant [12 x i8] c"RefScale=%f\00", align 1
@.str.40 = private unnamed_addr constant [12 x i8] c"Column %d%n\00", align 1
@.str.41 = private unnamed_addr constant [16 x i8] c"UserID=0x%08X%n\00", align 1
@.str.42 = private unnamed_addr constant [11 x i8] c"Width=%d%n\00", align 1
@.str.43 = private unnamed_addr constant [12 x i8] c"Weight=%f%n\00", align 1
@.str.44 = private unnamed_addr constant [13 x i8] c"Visible=%d%n\00", align 1
@.str.45 = private unnamed_addr constant [11 x i8] c"Order=%d%n\00", align 1
@.str.46 = private unnamed_addr constant [12 x i8] c"Sort=%d%c%n\00", align 1
@.str.47 = private unnamed_addr constant [17 x i8] c"[%s][0x%08X,%d]\0A\00", align 1
@.str.48 = private unnamed_addr constant [13 x i8] c"RefScale=%g\0A\00", align 1
@.str.49 = private unnamed_addr constant [12 x i8] c"Column %-2d\00", align 1
@.str.50 = private unnamed_addr constant [13 x i8] c" UserID=%08X\00", align 1
@.str.51 = private unnamed_addr constant [13 x i8] c" Weight=%.4f\00", align 1
@.str.52 = private unnamed_addr constant [10 x i8] c" Width=%d\00", align 1
@.str.53 = private unnamed_addr constant [12 x i8] c" Visible=%d\00", align 1
@.str.54 = private unnamed_addr constant [10 x i8] c" Order=%d\00", align 1
@.str.55 = private unnamed_addr constant [11 x i8] c" Sort=%d%c\00", align 1
@.str.56 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.57 = private unnamed_addr constant [9 x i8] c"FixedFit\00", align 1
@.str.58 = private unnamed_addr constant [10 x i8] c"FixedSame\00", align 1
@.str.59 = private unnamed_addr constant [12 x i8] c"StretchProp\00", align 1
@.str.60 = private unnamed_addr constant [12 x i8] c"StretchSame\00", align 1
@.str.61 = private unnamed_addr constant [4 x i8] c"N/A\00", align 1

; Function Attrs: mustprogress uwtable
define noundef ptr @_ZN5ImGui13TableFindByIDEj(i32 noundef %id) #0 {
entry:
  %id.addr = alloca i32, align 4
  %g = alloca ptr, align 8
  store i32 %id, ptr %id.addr, align 4
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %g, align 8
  %Tables = getelementptr inbounds %struct.ImGuiContext, ptr %1, i32 0, i32 167
  %2 = load i32, ptr %id.addr, align 4
  %call = call noundef ptr @_ZN6ImPoolI10ImGuiTableE8GetByKeyEj(ptr noundef nonnull align 8 dereferenceable(40) %Tables, i32 noundef %2)
  ret ptr %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr noundef ptr @_ZN6ImPoolI10ImGuiTableE8GetByKeyEj(ptr noundef nonnull align 8 dereferenceable(40) %this, i32 noundef %key) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %key.addr = alloca i32, align 4
  %idx = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %key, ptr %key.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Map = getelementptr inbounds %struct.ImPool, ptr %this1, i32 0, i32 1
  %0 = load i32, ptr %key.addr, align 4
  %call = call noundef i32 @_ZNK12ImGuiStorage6GetIntEji(ptr noundef nonnull align 8 dereferenceable(16) %Map, i32 noundef %0, i32 noundef -1)
  store i32 %call, ptr %idx, align 4
  %1 = load i32, ptr %idx, align 4
  %cmp = icmp ne i32 %1, -1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %Buf = getelementptr inbounds %struct.ImPool, ptr %this1, i32 0, i32 0
  %2 = load i32, ptr %idx, align 4
  %call2 = call noundef nonnull align 8 dereferenceable(586) ptr @_ZN8ImVectorI10ImGuiTableEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Buf, i32 noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call2, %cond.true ], [ null, %cond.false ]
  ret ptr %cond
}

; Function Attrs: mustprogress uwtable
define noundef zeroext i1 @_ZN5ImGui10BeginTableEPKciiRK6ImVec2f(ptr noundef %str_id, i32 noundef %columns_count, i32 noundef %flags, ptr noundef nonnull align 4 dereferenceable(8) %outer_size, float noundef %inner_width) #0 {
entry:
  %str_id.addr = alloca ptr, align 8
  %columns_count.addr = alloca i32, align 4
  %flags.addr = alloca i32, align 4
  %outer_size.addr = alloca ptr, align 8
  %inner_width.addr = alloca float, align 4
  %id = alloca i32, align 4
  store ptr %str_id, ptr %str_id.addr, align 8
  store i32 %columns_count, ptr %columns_count.addr, align 4
  store i32 %flags, ptr %flags.addr, align 4
  store ptr %outer_size, ptr %outer_size.addr, align 8
  store float %inner_width, ptr %inner_width.addr, align 4
  %0 = load ptr, ptr %str_id.addr, align 8
  %call = call noundef i32 @_ZN5ImGui5GetIDEPKc(ptr noundef %0)
  store i32 %call, ptr %id, align 4
  %1 = load ptr, ptr %str_id.addr, align 8
  %2 = load i32, ptr %id, align 4
  %3 = load i32, ptr %columns_count.addr, align 4
  %4 = load i32, ptr %flags.addr, align 4
  %5 = load ptr, ptr %outer_size.addr, align 8
  %6 = load float, ptr %inner_width.addr, align 4
  %call1 = call noundef zeroext i1 @_ZN5ImGui12BeginTableExEPKcjiiRK6ImVec2f(ptr noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, ptr noundef nonnull align 4 dereferenceable(8) %5, float noundef %6)
  ret i1 %call1
}

declare noundef i32 @_ZN5ImGui5GetIDEPKc(ptr noundef) #1

; Function Attrs: mustprogress uwtable
define noundef zeroext i1 @_ZN5ImGui12BeginTableExEPKcjiiRK6ImVec2f(ptr noundef %name, i32 noundef %id, i32 noundef %columns_count, i32 noundef %flags, ptr noundef nonnull align 4 dereferenceable(8) %outer_size, float noundef %inner_width) #2 personality ptr @__gxx_personality_v0 {
entry:
  %retval = alloca i1, align 1
  %name.addr = alloca ptr, align 8
  %id.addr = alloca i32, align 4
  %columns_count.addr = alloca i32, align 4
  %flags.addr = alloca i32, align 4
  %outer_size.addr = alloca ptr, align 8
  %inner_width.addr = alloca float, align 4
  %g = alloca ptr, align 8
  %outer_window = alloca ptr, align 8
  %use_child_window = alloca i8, align 1
  %avail_size = alloca %struct.ImVec2, align 4
  %actual_outer_size = alloca %struct.ImVec2, align 4
  %agg.tmp = alloca %struct.ImVec2, align 4
  %outer_rect = alloca %struct.ImRect, align 4
  %ref.tmp = alloca %struct.ImVec2, align 4
  %outer_window_is_measuring_size = alloca i8, align 1
  %table = alloca ptr, align 8
  %table_last_flags = alloca i32, align 4
  %table_idx = alloca i32, align 4
  %ref.tmp30 = alloca %struct.ImGuiTableTempData, align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  %temp_data = alloca ptr, align 8
  %previous_frame_active = alloca i32, align 4
  %instance_no = alloca i32, align 4
  %instance_id = alloca i32, align 4
  %ref.tmp59 = alloca %struct.ImGuiTableInstanceData, align 4
  %table_instance = alloca ptr, align 8
  %override_content_size = alloca %struct.ImVec2, align 4
  %ref.tmp89 = alloca %struct.ImVec2, align 4
  %ref.tmp108 = alloca %struct.ImVec2, align 4
  %child_flags = alloca i32, align 4
  %ref.tmp113 = alloca %struct.ImVec2, align 4
  %ref.tmp119 = alloca %struct.ImRect, align 4
  %inner_window = alloca ptr, align 8
  %ref.tmp169 = alloca %struct.ImVec2, align 4
  %pad_outer_x = alloca i8, align 1
  %pad_inner_x = alloca i8, align 1
  %inner_spacing_for_border = alloca float, align 4
  %inner_spacing_explicit = alloca float, align 4
  %inner_padding_explicit = alloca float, align 4
  %outer_padding_for_border = alloca float, align 4
  %outer_padding_explicit = alloca float, align 4
  %ref.tmp320 = alloca float, align 4
  %old_columns_to_preserve = alloca ptr, align 8
  %old_columns_raw_data = alloca ptr, align 8
  %old_columns_count = alloca i32, align 4
  %n = alloca i32, align 4
  %column = alloca ptr, align 8
  %width_auto = alloca float, align 4
  %ref.tmp353 = alloca %struct.ImGuiTableColumn, align 4
  %new_ref_scale_unit = alloca float, align 4
  %scale_factor = alloca float, align 4
  %n373 = alloca i32, align 4
  store ptr %name, ptr %name.addr, align 8
  store i32 %id, ptr %id.addr, align 4
  store i32 %columns_count, ptr %columns_count.addr, align 4
  store i32 %flags, ptr %flags.addr, align 4
  store ptr %outer_size, ptr %outer_size.addr, align 8
  store float %inner_width, ptr %inner_width.addr, align 4
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %call = call noundef ptr @_ZN5ImGui16GetCurrentWindowEv()
  store ptr %call, ptr %outer_window, align 8
  %1 = load ptr, ptr %outer_window, align 8
  %SkipItems = getelementptr inbounds %struct.ImGuiWindow, ptr %1, i32 0, i32 38
  %2 = load i8, ptr %SkipItems, align 1
  %tobool = trunc i8 %2 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %3 = load i32, ptr %flags.addr, align 4
  %and = and i32 %3, 16777216
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end
  %4 = load i32, ptr %flags.addr, align 4
  %and4 = and i32 %4, 50331648
  %cmp = icmp ne i32 %and4, 0
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, ptr %use_child_window, align 1
  %call5 = call <2 x float> @_ZN5ImGui21GetContentRegionAvailEv()
  store <2 x float> %call5, ptr %avail_size, align 4
  %5 = load ptr, ptr %outer_size.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp, ptr align 4 %5, i64 8, i1 false)
  %x = getelementptr inbounds %struct.ImVec2, ptr %avail_size, i32 0, i32 0
  %6 = load float, ptr %x, align 4
  %call6 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %6, float noundef 1.000000e+00)
  %7 = load i8, ptr %use_child_window, align 1
  %tobool7 = trunc i8 %7 to i1
  br i1 %tobool7, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end3
  %y = getelementptr inbounds %struct.ImVec2, ptr %avail_size, i32 0, i32 1
  %8 = load float, ptr %y, align 4
  %call8 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %8, float noundef 1.000000e+00)
  br label %cond.end

cond.false:                                       ; preds = %if.end3
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi float [ %call8, %cond.true ], [ 0.000000e+00, %cond.false ]
  %9 = load <2 x float>, ptr %agg.tmp, align 4
  %call9 = call <2 x float> @_ZN5ImGui12CalcItemSizeE6ImVec2ff(<2 x float> %9, float noundef %call6, float noundef %cond)
  store <2 x float> %call9, ptr %actual_outer_size, align 4
  %10 = load ptr, ptr %outer_window, align 8
  %DC = getelementptr inbounds %struct.ImGuiWindow, ptr %10, i32 0, i32 68
  %CursorPos = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC, i32 0, i32 0
  %11 = load ptr, ptr %outer_window, align 8
  %DC10 = getelementptr inbounds %struct.ImGuiWindow, ptr %11, i32 0, i32 68
  %CursorPos11 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC10, i32 0, i32 0
  %call12 = call <2 x float> @_ZplRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %CursorPos11, ptr noundef nonnull align 4 dereferenceable(8) %actual_outer_size)
  store <2 x float> %call12, ptr %ref.tmp, align 4
  call void @_ZN6ImRectC2ERK6ImVec2S2_(ptr noundef nonnull align 4 dereferenceable(16) %outer_rect, ptr noundef nonnull align 4 dereferenceable(8) %CursorPos, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp)
  %12 = load ptr, ptr %outer_window, align 8
  %AutoFitFramesX = getelementptr inbounds %struct.ImGuiWindow, ptr %12, i32 0, i32 54
  %13 = load i8, ptr %AutoFitFramesX, align 4
  %conv = sext i8 %13 to i32
  %cmp13 = icmp sgt i32 %conv, 0
  br i1 %cmp13, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %cond.end
  %14 = load ptr, ptr %outer_window, align 8
  %AutoFitFramesY = getelementptr inbounds %struct.ImGuiWindow, ptr %14, i32 0, i32 55
  %15 = load i8, ptr %AutoFitFramesY, align 1
  %conv14 = sext i8 %15 to i32
  %cmp15 = icmp sgt i32 %conv14, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %cond.end
  %16 = phi i1 [ true, %cond.end ], [ %cmp15, %lor.rhs ]
  %frombool16 = zext i1 %16 to i8
  store i8 %frombool16, ptr %outer_window_is_measuring_size, align 1
  %17 = load i8, ptr %use_child_window, align 1
  %tobool17 = trunc i8 %17 to i1
  br i1 %tobool17, label %land.lhs.true, label %if.end22

land.lhs.true:                                    ; preds = %lor.end
  %call18 = call noundef zeroext i1 @_ZN5ImGui11IsClippedExERK6ImRectj(ptr noundef nonnull align 4 dereferenceable(16) %outer_rect, i32 noundef 0)
  br i1 %call18, label %land.lhs.true19, label %if.end22

land.lhs.true19:                                  ; preds = %land.lhs.true
  %18 = load i8, ptr %outer_window_is_measuring_size, align 1
  %tobool20 = trunc i8 %18 to i1
  br i1 %tobool20, label %if.end22, label %if.then21

if.then21:                                        ; preds = %land.lhs.true19
  call void @_ZN5ImGui8ItemSizeERK6ImRectf(ptr noundef nonnull align 4 dereferenceable(16) %outer_rect, float noundef -1.000000e+00)
  store i1 false, ptr %retval, align 1
  br label %return

if.end22:                                         ; preds = %land.lhs.true19, %land.lhs.true, %lor.end
  %19 = load ptr, ptr %g, align 8
  %Tables = getelementptr inbounds %struct.ImGuiContext, ptr %19, i32 0, i32 167
  %20 = load i32, ptr %id.addr, align 4
  %call23 = call noundef ptr @_ZN6ImPoolI10ImGuiTableE13GetOrAddByKeyEj(ptr noundef nonnull align 8 dereferenceable(40) %Tables, i32 noundef %20)
  store ptr %call23, ptr %table, align 8
  %21 = load ptr, ptr %table, align 8
  %Flags = getelementptr inbounds %struct.ImGuiTable, ptr %21, i32 0, i32 1
  %22 = load i32, ptr %Flags, align 4
  store i32 %22, ptr %table_last_flags, align 4
  %23 = load ptr, ptr %g, align 8
  %Tables24 = getelementptr inbounds %struct.ImGuiContext, ptr %23, i32 0, i32 167
  %24 = load ptr, ptr %table, align 8
  %call25 = call noundef i32 @_ZNK6ImPoolI10ImGuiTableE8GetIndexEPKS0_(ptr noundef nonnull align 8 dereferenceable(40) %Tables24, ptr noundef %24)
  store i32 %call25, ptr %table_idx, align 4
  %25 = load ptr, ptr %g, align 8
  %TablesTempDataStacked = getelementptr inbounds %struct.ImGuiContext, ptr %25, i32 0, i32 165
  %26 = load i32, ptr %TablesTempDataStacked, align 8
  %inc = add nsw i32 %26, 1
  store i32 %inc, ptr %TablesTempDataStacked, align 8
  %27 = load ptr, ptr %g, align 8
  %TablesTempData = getelementptr inbounds %struct.ImGuiContext, ptr %27, i32 0, i32 166
  %Size = getelementptr inbounds %struct.ImVector.17, ptr %TablesTempData, i32 0, i32 0
  %28 = load i32, ptr %Size, align 8
  %cmp26 = icmp sgt i32 %inc, %28
  br i1 %cmp26, label %if.then27, label %if.end31

if.then27:                                        ; preds = %if.end22
  %29 = load ptr, ptr %g, align 8
  %TablesTempData28 = getelementptr inbounds %struct.ImGuiContext, ptr %29, i32 0, i32 166
  %30 = load ptr, ptr %g, align 8
  %TablesTempDataStacked29 = getelementptr inbounds %struct.ImGuiContext, ptr %30, i32 0, i32 165
  %31 = load i32, ptr %TablesTempDataStacked29, align 8
  call void @_ZN18ImGuiTableTempDataC2Ev(ptr noundef nonnull align 8 dereferenceable(116) %ref.tmp30)
  invoke void @_ZN8ImVectorI18ImGuiTableTempDataE6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(16) %TablesTempData28, i32 noundef %31, ptr noundef nonnull align 8 dereferenceable(116) %ref.tmp30)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %if.then27
  call void @_ZN18ImGuiTableTempDataD2Ev(ptr noundef nonnull align 8 dereferenceable(116) %ref.tmp30) #10
  br label %if.end31

lpad:                                             ; preds = %if.then27
  %32 = landingpad { ptr, i32 }
          cleanup
  %33 = extractvalue { ptr, i32 } %32, 0
  store ptr %33, ptr %exn.slot, align 8
  %34 = extractvalue { ptr, i32 } %32, 1
  store i32 %34, ptr %ehselector.slot, align 4
  call void @_ZN18ImGuiTableTempDataD2Ev(ptr noundef nonnull align 8 dereferenceable(116) %ref.tmp30) #10
  br label %eh.resume

if.end31:                                         ; preds = %invoke.cont, %if.end22
  %35 = load ptr, ptr %g, align 8
  %TablesTempData32 = getelementptr inbounds %struct.ImGuiContext, ptr %35, i32 0, i32 166
  %36 = load ptr, ptr %g, align 8
  %TablesTempDataStacked33 = getelementptr inbounds %struct.ImGuiContext, ptr %36, i32 0, i32 165
  %37 = load i32, ptr %TablesTempDataStacked33, align 8
  %sub = sub nsw i32 %37, 1
  %call34 = call noundef nonnull align 8 dereferenceable(116) ptr @_ZN8ImVectorI18ImGuiTableTempDataEixEi(ptr noundef nonnull align 8 dereferenceable(16) %TablesTempData32, i32 noundef %sub)
  %38 = load ptr, ptr %table, align 8
  %TempData = getelementptr inbounds %struct.ImGuiTable, ptr %38, i32 0, i32 3
  store ptr %call34, ptr %TempData, align 8
  store ptr %call34, ptr %temp_data, align 8
  %39 = load i32, ptr %table_idx, align 4
  %40 = load ptr, ptr %temp_data, align 8
  %TableIndex = getelementptr inbounds %struct.ImGuiTableTempData, ptr %40, i32 0, i32 0
  store i32 %39, ptr %TableIndex, align 8
  %41 = load ptr, ptr %table, align 8
  %TempData35 = getelementptr inbounds %struct.ImGuiTable, ptr %41, i32 0, i32 3
  %42 = load ptr, ptr %TempData35, align 8
  %DrawSplitter = getelementptr inbounds %struct.ImGuiTableTempData, ptr %42, i32 0, i32 5
  %43 = load ptr, ptr %table, align 8
  %DrawSplitter36 = getelementptr inbounds %struct.ImGuiTable, ptr %43, i32 0, i32 58
  store ptr %DrawSplitter, ptr %DrawSplitter36, align 8
  %44 = load ptr, ptr %table, align 8
  %DrawSplitter37 = getelementptr inbounds %struct.ImGuiTable, ptr %44, i32 0, i32 58
  %45 = load ptr, ptr %DrawSplitter37, align 8
  call void @_ZN18ImDrawListSplitter5ClearEv(ptr noundef nonnull align 8 dereferenceable(24) %45)
  %46 = load i32, ptr %flags.addr, align 4
  %and38 = and i32 %46, 57344
  %cmp39 = icmp eq i32 %and38, 0
  %47 = load ptr, ptr %table, align 8
  %IsDefaultSizingPolicy = getelementptr inbounds %struct.ImGuiTable, ptr %47, i32 0, i32 105
  %frombool40 = zext i1 %cmp39 to i8
  store i8 %frombool40, ptr %IsDefaultSizingPolicy, align 1
  %48 = load i32, ptr %flags.addr, align 4
  %49 = load ptr, ptr %outer_window, align 8
  %call41 = call noundef i32 @_Z13TableFixFlagsiP11ImGuiWindow(i32 noundef %48, ptr noundef %49)
  store i32 %call41, ptr %flags.addr, align 4
  %50 = load ptr, ptr %table, align 8
  %LastFrameActive = getelementptr inbounds %struct.ImGuiTable, ptr %50, i32 0, i32 12
  %51 = load i32, ptr %LastFrameActive, align 8
  store i32 %51, ptr %previous_frame_active, align 4
  %52 = load i32, ptr %previous_frame_active, align 4
  %53 = load ptr, ptr %g, align 8
  %FrameCount = getelementptr inbounds %struct.ImGuiContext, ptr %53, i32 0, i32 9
  %54 = load i32, ptr %FrameCount, align 8
  %cmp42 = icmp ne i32 %52, %54
  br i1 %cmp42, label %cond.true43, label %cond.false44

cond.true43:                                      ; preds = %if.end31
  br label %cond.end46

cond.false44:                                     ; preds = %if.end31
  %55 = load ptr, ptr %table, align 8
  %InstanceCurrent = getelementptr inbounds %struct.ImGuiTable, ptr %55, i32 0, i32 16
  %56 = load i16, ptr %InstanceCurrent, align 8
  %conv45 = sext i16 %56 to i32
  %add = add nsw i32 %conv45, 1
  br label %cond.end46

cond.end46:                                       ; preds = %cond.false44, %cond.true43
  %cond47 = phi i32 [ 0, %cond.true43 ], [ %add, %cond.false44 ]
  store i32 %cond47, ptr %instance_no, align 4
  %57 = load i32, ptr %id.addr, align 4
  %58 = load ptr, ptr %table, align 8
  %ID = getelementptr inbounds %struct.ImGuiTable, ptr %58, i32 0, i32 0
  store i32 %57, ptr %ID, align 8
  %59 = load i32, ptr %flags.addr, align 4
  %60 = load ptr, ptr %table, align 8
  %Flags48 = getelementptr inbounds %struct.ImGuiTable, ptr %60, i32 0, i32 1
  store i32 %59, ptr %Flags48, align 4
  %61 = load ptr, ptr %g, align 8
  %FrameCount49 = getelementptr inbounds %struct.ImGuiContext, ptr %61, i32 0, i32 9
  %62 = load i32, ptr %FrameCount49, align 8
  %63 = load ptr, ptr %table, align 8
  %LastFrameActive50 = getelementptr inbounds %struct.ImGuiTable, ptr %63, i32 0, i32 12
  store i32 %62, ptr %LastFrameActive50, align 8
  %64 = load ptr, ptr %outer_window, align 8
  %65 = load ptr, ptr %table, align 8
  %InnerWindow = getelementptr inbounds %struct.ImGuiTable, ptr %65, i32 0, i32 56
  store ptr %64, ptr %InnerWindow, align 8
  %66 = load ptr, ptr %table, align 8
  %OuterWindow = getelementptr inbounds %struct.ImGuiTable, ptr %66, i32 0, i32 55
  store ptr %64, ptr %OuterWindow, align 8
  %67 = load i32, ptr %columns_count.addr, align 4
  %68 = load ptr, ptr %table, align 8
  %ColumnsCount = getelementptr inbounds %struct.ImGuiTable, ptr %68, i32 0, i32 13
  store i32 %67, ptr %ColumnsCount, align 4
  %69 = load ptr, ptr %table, align 8
  %IsLayoutLocked = getelementptr inbounds %struct.ImGuiTable, ptr %69, i32 0, i32 92
  store i8 0, ptr %IsLayoutLocked, align 2
  %70 = load float, ptr %inner_width.addr, align 4
  %71 = load ptr, ptr %table, align 8
  %InnerWidth = getelementptr inbounds %struct.ImGuiTable, ptr %71, i32 0, i32 37
  store float %70, ptr %InnerWidth, align 4
  %72 = load ptr, ptr %outer_size.addr, align 8
  %73 = load ptr, ptr %temp_data, align 8
  %UserOuterSize = getelementptr inbounds %struct.ImGuiTableTempData, ptr %73, i32 0, i32 3
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %UserOuterSize, ptr align 4 %72, i64 8, i1 false)
  %74 = load i32, ptr %instance_no, align 4
  %conv51 = trunc i32 %74 to i16
  %75 = load ptr, ptr %table, align 8
  %InstanceCurrent52 = getelementptr inbounds %struct.ImGuiTable, ptr %75, i32 0, i32 16
  store i16 %conv51, ptr %InstanceCurrent52, align 8
  %76 = load i32, ptr %instance_no, align 4
  %cmp53 = icmp sgt i32 %76, 0
  br i1 %cmp53, label %if.then54, label %if.else

if.then54:                                        ; preds = %cond.end46
  %77 = load ptr, ptr %table, align 8
  %InstanceDataExtra = getelementptr inbounds %struct.ImGuiTable, ptr %77, i32 0, i32 60
  %Size55 = getelementptr inbounds %struct.ImVector.38, ptr %InstanceDataExtra, i32 0, i32 0
  %78 = load i32, ptr %Size55, align 8
  %79 = load i32, ptr %instance_no, align 4
  %cmp56 = icmp slt i32 %78, %79
  br i1 %cmp56, label %if.then57, label %if.end60

if.then57:                                        ; preds = %if.then54
  %80 = load ptr, ptr %table, align 8
  %InstanceDataExtra58 = getelementptr inbounds %struct.ImGuiTable, ptr %80, i32 0, i32 60
  call void @_ZN22ImGuiTableInstanceDataC2Ev(ptr noundef nonnull align 4 dereferenceable(24) %ref.tmp59)
  call void @_ZN8ImVectorI22ImGuiTableInstanceDataE9push_backERKS0_(ptr noundef nonnull align 8 dereferenceable(16) %InstanceDataExtra58, ptr noundef nonnull align 4 dereferenceable(24) %ref.tmp59)
  br label %if.end60

if.end60:                                         ; preds = %if.then57, %if.then54
  %81 = load i32, ptr %instance_no, align 4
  %82 = load i32, ptr %id.addr, align 4
  %call61 = call noundef i32 @_ZN5ImGui13GetIDWithSeedEPKcS1_j(ptr noundef @.str, ptr noundef null, i32 noundef %82)
  %call62 = call noundef i32 @_ZN5ImGui13GetIDWithSeedEij(i32 noundef %81, i32 noundef %call61)
  store i32 %call62, ptr %instance_id, align 4
  br label %if.end63

if.else:                                          ; preds = %cond.end46
  %83 = load i32, ptr %id.addr, align 4
  store i32 %83, ptr %instance_id, align 4
  br label %if.end63

if.end63:                                         ; preds = %if.else, %if.end60
  %84 = load ptr, ptr %table, align 8
  %85 = load ptr, ptr %table, align 8
  %InstanceCurrent64 = getelementptr inbounds %struct.ImGuiTable, ptr %85, i32 0, i32 16
  %86 = load i16, ptr %InstanceCurrent64, align 8
  %conv65 = sext i16 %86 to i32
  %call66 = call noundef ptr @_ZN5ImGui20TableGetInstanceDataEP10ImGuiTablei(ptr noundef %84, i32 noundef %conv65)
  store ptr %call66, ptr %table_instance, align 8
  %87 = load i32, ptr %instance_id, align 4
  %88 = load ptr, ptr %table_instance, align 8
  %TableInstanceID = getelementptr inbounds %struct.ImGuiTableInstanceData, ptr %88, i32 0, i32 0
  store i32 %87, ptr %TableInstanceID, align 4
  %89 = load i8, ptr %use_child_window, align 1
  %tobool67 = trunc i8 %89 to i1
  br i1 %tobool67, label %if.then68, label %if.else147

if.then68:                                        ; preds = %if.end63
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %override_content_size, float noundef 0x47EFFFFFE0000000, float noundef 0x47EFFFFFE0000000)
  %90 = load i32, ptr %flags.addr, align 4
  %and69 = and i32 %90, 16777216
  %tobool70 = icmp ne i32 %and69, 0
  br i1 %tobool70, label %land.lhs.true71, label %if.end76

land.lhs.true71:                                  ; preds = %if.then68
  %91 = load i32, ptr %flags.addr, align 4
  %and72 = and i32 %91, 33554432
  %tobool73 = icmp ne i32 %and72, 0
  br i1 %tobool73, label %if.end76, label %if.then74

if.then74:                                        ; preds = %land.lhs.true71
  %y75 = getelementptr inbounds %struct.ImVec2, ptr %override_content_size, i32 0, i32 1
  store float 0x3810000000000000, ptr %y75, align 4
  br label %if.end76

if.end76:                                         ; preds = %if.then74, %land.lhs.true71, %if.then68
  %92 = load i32, ptr %flags.addr, align 4
  %and77 = and i32 %92, 16777216
  %tobool78 = icmp ne i32 %and77, 0
  br i1 %tobool78, label %land.lhs.true79, label %if.end83

land.lhs.true79:                                  ; preds = %if.end76
  %93 = load float, ptr %inner_width.addr, align 4
  %cmp80 = fcmp ogt float %93, 0.000000e+00
  br i1 %cmp80, label %if.then81, label %if.end83

if.then81:                                        ; preds = %land.lhs.true79
  %94 = load float, ptr %inner_width.addr, align 4
  %x82 = getelementptr inbounds %struct.ImVec2, ptr %override_content_size, i32 0, i32 0
  store float %94, ptr %x82, align 4
  br label %if.end83

if.end83:                                         ; preds = %if.then81, %land.lhs.true79, %if.end76
  %x84 = getelementptr inbounds %struct.ImVec2, ptr %override_content_size, i32 0, i32 0
  %95 = load float, ptr %x84, align 4
  %cmp85 = fcmp une float %95, 0x47EFFFFFE0000000
  br i1 %cmp85, label %if.then88, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end83
  %y86 = getelementptr inbounds %struct.ImVec2, ptr %override_content_size, i32 0, i32 1
  %96 = load float, ptr %y86, align 4
  %cmp87 = fcmp une float %96, 0x47EFFFFFE0000000
  br i1 %cmp87, label %if.then88, label %if.end104

if.then88:                                        ; preds = %lor.lhs.false, %if.end83
  %x90 = getelementptr inbounds %struct.ImVec2, ptr %override_content_size, i32 0, i32 0
  %97 = load float, ptr %x90, align 4
  %cmp91 = fcmp une float %97, 0x47EFFFFFE0000000
  br i1 %cmp91, label %cond.true92, label %cond.false94

cond.true92:                                      ; preds = %if.then88
  %x93 = getelementptr inbounds %struct.ImVec2, ptr %override_content_size, i32 0, i32 0
  %98 = load float, ptr %x93, align 4
  br label %cond.end95

cond.false94:                                     ; preds = %if.then88
  br label %cond.end95

cond.end95:                                       ; preds = %cond.false94, %cond.true92
  %cond96 = phi float [ %98, %cond.true92 ], [ 0.000000e+00, %cond.false94 ]
  %y97 = getelementptr inbounds %struct.ImVec2, ptr %override_content_size, i32 0, i32 1
  %99 = load float, ptr %y97, align 4
  %cmp98 = fcmp une float %99, 0x47EFFFFFE0000000
  br i1 %cmp98, label %cond.true99, label %cond.false101

cond.true99:                                      ; preds = %cond.end95
  %y100 = getelementptr inbounds %struct.ImVec2, ptr %override_content_size, i32 0, i32 1
  %100 = load float, ptr %y100, align 4
  br label %cond.end102

cond.false101:                                    ; preds = %cond.end95
  br label %cond.end102

cond.end102:                                      ; preds = %cond.false101, %cond.true99
  %cond103 = phi float [ %100, %cond.true99 ], [ 0.000000e+00, %cond.false101 ]
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp89, float noundef %cond96, float noundef %cond103)
  call void @_ZN5ImGui24SetNextWindowContentSizeERK6ImVec2(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp89)
  br label %if.end104

if.end104:                                        ; preds = %cond.end102, %lor.lhs.false
  %101 = load i32, ptr %table_last_flags, align 4
  %and105 = and i32 %101, 50331648
  %cmp106 = icmp eq i32 %and105, 0
  br i1 %cmp106, label %if.then107, label %if.end109

if.then107:                                       ; preds = %if.end104
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp108, float noundef 0.000000e+00, float noundef 0.000000e+00)
  call void @_ZN5ImGui19SetNextWindowScrollERK6ImVec2(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp108)
  br label %if.end109

if.end109:                                        ; preds = %if.then107, %if.end104
  %102 = load i32, ptr %flags.addr, align 4
  %and110 = and i32 %102, 16777216
  %tobool111 = icmp ne i32 %and110, 0
  %cond112 = select i1 %tobool111, i32 2048, i32 0
  store i32 %cond112, ptr %child_flags, align 4
  %103 = load ptr, ptr %name.addr, align 8
  %104 = load i32, ptr %instance_id, align 4
  %call114 = call <2 x float> @_ZNK6ImRect7GetSizeEv(ptr noundef nonnull align 4 dereferenceable(16) %outer_rect)
  store <2 x float> %call114, ptr %ref.tmp113, align 4
  %105 = load i32, ptr %child_flags, align 4
  %call115 = call noundef zeroext i1 @_ZN5ImGui12BeginChildExEPKcjRK6ImVec2ii(ptr noundef %103, i32 noundef %104, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp113, i32 noundef 0, i32 noundef %105)
  %106 = load ptr, ptr %g, align 8
  %CurrentWindow = getelementptr inbounds %struct.ImGuiContext, ptr %106, i32 0, i32 29
  %107 = load ptr, ptr %CurrentWindow, align 8
  %108 = load ptr, ptr %table, align 8
  %InnerWindow116 = getelementptr inbounds %struct.ImGuiTable, ptr %108, i32 0, i32 56
  store ptr %107, ptr %InnerWindow116, align 8
  %109 = load ptr, ptr %table, align 8
  %InnerWindow117 = getelementptr inbounds %struct.ImGuiTable, ptr %109, i32 0, i32 56
  %110 = load ptr, ptr %InnerWindow117, align 8
  %WorkRect = getelementptr inbounds %struct.ImGuiWindow, ptr %110, i32 0, i32 72
  %111 = load ptr, ptr %table, align 8
  %WorkRect118 = getelementptr inbounds %struct.ImGuiTable, ptr %111, i32 0, i32 48
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %WorkRect118, ptr align 8 %WorkRect, i64 16, i1 false)
  %112 = load ptr, ptr %table, align 8
  %InnerWindow120 = getelementptr inbounds %struct.ImGuiTable, ptr %112, i32 0, i32 56
  %113 = load ptr, ptr %InnerWindow120, align 8
  %call121 = call { <2 x float>, <2 x float> } @_ZNK11ImGuiWindow4RectEv(ptr noundef nonnull align 8 dereferenceable(1013) %113)
  %114 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %ref.tmp119, i32 0, i32 0
  %115 = extractvalue { <2 x float>, <2 x float> } %call121, 0
  store <2 x float> %115, ptr %114, align 4
  %116 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %ref.tmp119, i32 0, i32 1
  %117 = extractvalue { <2 x float>, <2 x float> } %call121, 1
  store <2 x float> %117, ptr %116, align 4
  %118 = load ptr, ptr %table, align 8
  %OuterRect = getelementptr inbounds %struct.ImGuiTable, ptr %118, i32 0, i32 46
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %OuterRect, ptr align 4 %ref.tmp119, i64 16, i1 false)
  %119 = load ptr, ptr %table, align 8
  %InnerWindow122 = getelementptr inbounds %struct.ImGuiTable, ptr %119, i32 0, i32 56
  %120 = load ptr, ptr %InnerWindow122, align 8
  %InnerRect = getelementptr inbounds %struct.ImGuiWindow, ptr %120, i32 0, i32 70
  %121 = load ptr, ptr %table, align 8
  %InnerRect123 = getelementptr inbounds %struct.ImGuiTable, ptr %121, i32 0, i32 47
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %InnerRect123, ptr align 8 %InnerRect, i64 16, i1 false)
  %122 = load ptr, ptr %table, align 8
  %InnerWindow124 = getelementptr inbounds %struct.ImGuiTable, ptr %122, i32 0, i32 56
  %123 = load ptr, ptr %InnerWindow124, align 8
  %SkipItems125 = getelementptr inbounds %struct.ImGuiWindow, ptr %123, i32 0, i32 38
  %124 = load i8, ptr %SkipItems125, align 1
  %tobool126 = trunc i8 %124 to i1
  br i1 %tobool126, label %land.lhs.true127, label %if.end132

land.lhs.true127:                                 ; preds = %if.end109
  %125 = load i8, ptr %outer_window_is_measuring_size, align 1
  %tobool128 = trunc i8 %125 to i1
  br i1 %tobool128, label %if.then129, label %if.end132

if.then129:                                       ; preds = %land.lhs.true127
  %126 = load ptr, ptr %table, align 8
  %InnerWindow130 = getelementptr inbounds %struct.ImGuiTable, ptr %126, i32 0, i32 56
  %127 = load ptr, ptr %InnerWindow130, align 8
  %SkipItems131 = getelementptr inbounds %struct.ImGuiWindow, ptr %127, i32 0, i32 38
  store i8 0, ptr %SkipItems131, align 1
  br label %if.end132

if.end132:                                        ; preds = %if.then129, %land.lhs.true127, %if.end109
  %128 = load i32, ptr %instance_no, align 4
  %cmp133 = icmp eq i32 %128, 0
  br i1 %cmp133, label %if.then134, label %if.end138

if.then134:                                       ; preds = %if.end132
  %129 = load ptr, ptr %table, align 8
  %HasScrollbarYCurr = getelementptr inbounds %struct.ImGuiTable, ptr %129, i32 0, i32 108
  %130 = load i8, ptr %HasScrollbarYCurr, align 2
  %tobool135 = trunc i8 %130 to i1
  %131 = load ptr, ptr %table, align 8
  %HasScrollbarYPrev = getelementptr inbounds %struct.ImGuiTable, ptr %131, i32 0, i32 109
  %frombool136 = zext i1 %tobool135 to i8
  store i8 %frombool136, ptr %HasScrollbarYPrev, align 1
  %132 = load ptr, ptr %table, align 8
  %HasScrollbarYCurr137 = getelementptr inbounds %struct.ImGuiTable, ptr %132, i32 0, i32 108
  store i8 0, ptr %HasScrollbarYCurr137, align 2
  br label %if.end138

if.end138:                                        ; preds = %if.then134, %if.end132
  %133 = load ptr, ptr %table, align 8
  %InnerWindow139 = getelementptr inbounds %struct.ImGuiTable, ptr %133, i32 0, i32 56
  %134 = load ptr, ptr %InnerWindow139, align 8
  %ScrollbarY = getelementptr inbounds %struct.ImGuiWindow, ptr %134, i32 0, i32 32
  %135 = load i8, ptr %ScrollbarY, align 1
  %tobool140 = trunc i8 %135 to i1
  %conv141 = zext i1 %tobool140 to i32
  %136 = load ptr, ptr %table, align 8
  %HasScrollbarYCurr142 = getelementptr inbounds %struct.ImGuiTable, ptr %136, i32 0, i32 108
  %137 = load i8, ptr %HasScrollbarYCurr142, align 2
  %tobool143 = trunc i8 %137 to i1
  %conv144 = zext i1 %tobool143 to i32
  %or = or i32 %conv144, %conv141
  %tobool145 = icmp ne i32 %or, 0
  %frombool146 = zext i1 %tobool145 to i8
  store i8 %frombool146, ptr %HasScrollbarYCurr142, align 2
  br label %if.end151

if.else147:                                       ; preds = %if.end63
  %138 = load ptr, ptr %table, align 8
  %InnerRect148 = getelementptr inbounds %struct.ImGuiTable, ptr %138, i32 0, i32 47
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %InnerRect148, ptr align 4 %outer_rect, i64 16, i1 false)
  %139 = load ptr, ptr %table, align 8
  %OuterRect149 = getelementptr inbounds %struct.ImGuiTable, ptr %139, i32 0, i32 46
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %OuterRect149, ptr align 4 %InnerRect148, i64 16, i1 false)
  %140 = load ptr, ptr %table, align 8
  %WorkRect150 = getelementptr inbounds %struct.ImGuiTable, ptr %140, i32 0, i32 48
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %WorkRect150, ptr align 4 %OuterRect149, i64 16, i1 false)
  br label %if.end151

if.end151:                                        ; preds = %if.else147, %if.end138
  %141 = load i32, ptr %id.addr, align 4
  call void @_ZN5ImGui14PushOverrideIDEj(i32 noundef %141)
  %142 = load i32, ptr %instance_no, align 4
  %cmp152 = icmp sgt i32 %142, 0
  br i1 %cmp152, label %if.then153, label %if.end154

if.then153:                                       ; preds = %if.end151
  %143 = load i32, ptr %instance_id, align 4
  call void @_ZN5ImGui14PushOverrideIDEj(i32 noundef %143)
  br label %if.end154

if.end154:                                        ; preds = %if.then153, %if.end151
  %144 = load ptr, ptr %table, align 8
  %InnerWindow155 = getelementptr inbounds %struct.ImGuiTable, ptr %144, i32 0, i32 56
  %145 = load ptr, ptr %InnerWindow155, align 8
  store ptr %145, ptr %inner_window, align 8
  %146 = load ptr, ptr %inner_window, align 8
  %DC156 = getelementptr inbounds %struct.ImGuiWindow, ptr %146, i32 0, i32 68
  %Indent = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC156, i32 0, i32 11
  %x157 = getelementptr inbounds %struct.ImVec1, ptr %Indent, i32 0, i32 0
  %147 = load float, ptr %x157, align 4
  %148 = load ptr, ptr %table, align 8
  %HostIndentX = getelementptr inbounds %struct.ImGuiTable, ptr %148, i32 0, i32 31
  store float %147, ptr %HostIndentX, align 4
  %149 = load ptr, ptr %inner_window, align 8
  %ClipRect = getelementptr inbounds %struct.ImGuiWindow, ptr %149, i32 0, i32 74
  %150 = load ptr, ptr %table, align 8
  %HostClipRect = getelementptr inbounds %struct.ImGuiTable, ptr %150, i32 0, i32 53
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %HostClipRect, ptr align 8 %ClipRect, i64 16, i1 false)
  %151 = load ptr, ptr %inner_window, align 8
  %SkipItems158 = getelementptr inbounds %struct.ImGuiWindow, ptr %151, i32 0, i32 38
  %152 = load i8, ptr %SkipItems158, align 1
  %tobool159 = trunc i8 %152 to i1
  %153 = load ptr, ptr %table, align 8
  %HostSkipItems = getelementptr inbounds %struct.ImGuiTable, ptr %153, i32 0, i32 111
  %frombool160 = zext i1 %tobool159 to i8
  store i8 %frombool160, ptr %HostSkipItems, align 1
  %154 = load ptr, ptr %inner_window, align 8
  %WorkRect161 = getelementptr inbounds %struct.ImGuiWindow, ptr %154, i32 0, i32 72
  %155 = load ptr, ptr %temp_data, align 8
  %HostBackupWorkRect = getelementptr inbounds %struct.ImGuiTableTempData, ptr %155, i32 0, i32 6
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %HostBackupWorkRect, ptr align 8 %WorkRect161, i64 16, i1 false)
  %156 = load ptr, ptr %inner_window, align 8
  %ParentWorkRect = getelementptr inbounds %struct.ImGuiWindow, ptr %156, i32 0, i32 73
  %157 = load ptr, ptr %temp_data, align 8
  %HostBackupParentWorkRect = getelementptr inbounds %struct.ImGuiTableTempData, ptr %157, i32 0, i32 7
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %HostBackupParentWorkRect, ptr align 8 %ParentWorkRect, i64 16, i1 false)
  %158 = load ptr, ptr %outer_window, align 8
  %DC162 = getelementptr inbounds %struct.ImGuiWindow, ptr %158, i32 0, i32 68
  %ColumnsOffset = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC162, i32 0, i32 12
  %159 = load ptr, ptr %temp_data, align 8
  %HostBackupColumnsOffset = getelementptr inbounds %struct.ImGuiTableTempData, ptr %159, i32 0, i32 11
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %HostBackupColumnsOffset, ptr align 8 %ColumnsOffset, i64 4, i1 false)
  %160 = load ptr, ptr %inner_window, align 8
  %DC163 = getelementptr inbounds %struct.ImGuiWindow, ptr %160, i32 0, i32 68
  %PrevLineSize = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC163, i32 0, i32 6
  %161 = load ptr, ptr %temp_data, align 8
  %HostBackupPrevLineSize = getelementptr inbounds %struct.ImGuiTableTempData, ptr %161, i32 0, i32 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %HostBackupPrevLineSize, ptr align 8 %PrevLineSize, i64 8, i1 false)
  %162 = load ptr, ptr %inner_window, align 8
  %DC164 = getelementptr inbounds %struct.ImGuiWindow, ptr %162, i32 0, i32 68
  %CurrLineSize = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC164, i32 0, i32 5
  %163 = load ptr, ptr %temp_data, align 8
  %HostBackupCurrLineSize = getelementptr inbounds %struct.ImGuiTableTempData, ptr %163, i32 0, i32 9
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %HostBackupCurrLineSize, ptr align 8 %CurrLineSize, i64 8, i1 false)
  %164 = load ptr, ptr %inner_window, align 8
  %DC165 = getelementptr inbounds %struct.ImGuiWindow, ptr %164, i32 0, i32 68
  %CursorMaxPos = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC165, i32 0, i32 3
  %165 = load ptr, ptr %temp_data, align 8
  %HostBackupCursorMaxPos = getelementptr inbounds %struct.ImGuiTableTempData, ptr %165, i32 0, i32 10
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %HostBackupCursorMaxPos, ptr align 8 %CursorMaxPos, i64 8, i1 false)
  %166 = load ptr, ptr %outer_window, align 8
  %DC166 = getelementptr inbounds %struct.ImGuiWindow, ptr %166, i32 0, i32 68
  %ItemWidth = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC166, i32 0, i32 32
  %167 = load float, ptr %ItemWidth, align 4
  %168 = load ptr, ptr %temp_data, align 8
  %HostBackupItemWidth = getelementptr inbounds %struct.ImGuiTableTempData, ptr %168, i32 0, i32 12
  store float %167, ptr %HostBackupItemWidth, align 4
  %169 = load ptr, ptr %outer_window, align 8
  %DC167 = getelementptr inbounds %struct.ImGuiWindow, ptr %169, i32 0, i32 68
  %ItemWidthStack = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC167, i32 0, i32 34
  %Size168 = getelementptr inbounds %struct.ImVector.19, ptr %ItemWidthStack, i32 0, i32 0
  %170 = load i32, ptr %Size168, align 8
  %171 = load ptr, ptr %temp_data, align 8
  %HostBackupItemWidthStackSize = getelementptr inbounds %struct.ImGuiTableTempData, ptr %171, i32 0, i32 13
  store i32 %170, ptr %HostBackupItemWidthStackSize, align 8
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp169, float noundef 0.000000e+00, float noundef 0.000000e+00)
  %172 = load ptr, ptr %inner_window, align 8
  %DC170 = getelementptr inbounds %struct.ImGuiWindow, ptr %172, i32 0, i32 68
  %CurrLineSize171 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC170, i32 0, i32 5
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %CurrLineSize171, ptr align 4 %ref.tmp169, i64 8, i1 false)
  %173 = load ptr, ptr %inner_window, align 8
  %DC172 = getelementptr inbounds %struct.ImGuiWindow, ptr %173, i32 0, i32 68
  %PrevLineSize173 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC172, i32 0, i32 6
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %PrevLineSize173, ptr align 4 %CurrLineSize171, i64 8, i1 false)
  %174 = load ptr, ptr %inner_window, align 8
  %175 = load ptr, ptr %outer_window, align 8
  %cmp174 = icmp ne ptr %174, %175
  br i1 %cmp174, label %if.then175, label %if.end204

if.then175:                                       ; preds = %if.end154
  %176 = load i32, ptr %flags.addr, align 4
  %and176 = and i32 %176, 1024
  %tobool177 = icmp ne i32 %and176, 0
  br i1 %tobool177, label %if.then178, label %if.end188

if.then178:                                       ; preds = %if.then175
  %177 = load ptr, ptr %table, align 8
  %HostClipRect179 = getelementptr inbounds %struct.ImGuiTable, ptr %177, i32 0, i32 53
  %Min = getelementptr inbounds %struct.ImRect, ptr %HostClipRect179, i32 0, i32 0
  %x180 = getelementptr inbounds %struct.ImVec2, ptr %Min, i32 0, i32 0
  %178 = load float, ptr %x180, align 8
  %add181 = fadd float %178, 1.000000e+00
  %179 = load ptr, ptr %table, align 8
  %HostClipRect182 = getelementptr inbounds %struct.ImGuiTable, ptr %179, i32 0, i32 53
  %Max = getelementptr inbounds %struct.ImRect, ptr %HostClipRect182, i32 0, i32 1
  %x183 = getelementptr inbounds %struct.ImVec2, ptr %Max, i32 0, i32 0
  %180 = load float, ptr %x183, align 8
  %call184 = call noundef float @_ZL5ImMinIfET_S0_S0_(float noundef %add181, float noundef %180)
  %181 = load ptr, ptr %table, align 8
  %HostClipRect185 = getelementptr inbounds %struct.ImGuiTable, ptr %181, i32 0, i32 53
  %Min186 = getelementptr inbounds %struct.ImRect, ptr %HostClipRect185, i32 0, i32 0
  %x187 = getelementptr inbounds %struct.ImVec2, ptr %Min186, i32 0, i32 0
  store float %call184, ptr %x187, align 8
  br label %if.end188

if.end188:                                        ; preds = %if.then178, %if.then175
  %182 = load i32, ptr %flags.addr, align 4
  %and189 = and i32 %182, 256
  %tobool190 = icmp ne i32 %and189, 0
  br i1 %tobool190, label %if.then191, label %if.end203

if.then191:                                       ; preds = %if.end188
  %183 = load ptr, ptr %table, align 8
  %HostClipRect192 = getelementptr inbounds %struct.ImGuiTable, ptr %183, i32 0, i32 53
  %Min193 = getelementptr inbounds %struct.ImRect, ptr %HostClipRect192, i32 0, i32 0
  %y194 = getelementptr inbounds %struct.ImVec2, ptr %Min193, i32 0, i32 1
  %184 = load float, ptr %y194, align 4
  %add195 = fadd float %184, 1.000000e+00
  %185 = load ptr, ptr %table, align 8
  %HostClipRect196 = getelementptr inbounds %struct.ImGuiTable, ptr %185, i32 0, i32 53
  %Max197 = getelementptr inbounds %struct.ImRect, ptr %HostClipRect196, i32 0, i32 1
  %y198 = getelementptr inbounds %struct.ImVec2, ptr %Max197, i32 0, i32 1
  %186 = load float, ptr %y198, align 4
  %call199 = call noundef float @_ZL5ImMinIfET_S0_S0_(float noundef %add195, float noundef %186)
  %187 = load ptr, ptr %table, align 8
  %HostClipRect200 = getelementptr inbounds %struct.ImGuiTable, ptr %187, i32 0, i32 53
  %Min201 = getelementptr inbounds %struct.ImRect, ptr %HostClipRect200, i32 0, i32 0
  %y202 = getelementptr inbounds %struct.ImVec2, ptr %Min201, i32 0, i32 1
  store float %call199, ptr %y202, align 4
  br label %if.end203

if.end203:                                        ; preds = %if.then191, %if.end188
  br label %if.end204

if.end204:                                        ; preds = %if.end203, %if.end154
  %188 = load i32, ptr %flags.addr, align 4
  %and205 = and i32 %188, 4194304
  %tobool206 = icmp ne i32 %and205, 0
  br i1 %tobool206, label %cond.true207, label %cond.false208

cond.true207:                                     ; preds = %if.end204
  br label %cond.end217

cond.false208:                                    ; preds = %if.end204
  %189 = load i32, ptr %flags.addr, align 4
  %and209 = and i32 %189, 2097152
  %tobool210 = icmp ne i32 %and209, 0
  br i1 %tobool210, label %cond.true211, label %cond.false212

cond.true211:                                     ; preds = %cond.false208
  br label %cond.end215

cond.false212:                                    ; preds = %cond.false208
  %190 = load i32, ptr %flags.addr, align 4
  %and213 = and i32 %190, 1024
  %cmp214 = icmp ne i32 %and213, 0
  br label %cond.end215

cond.end215:                                      ; preds = %cond.false212, %cond.true211
  %cond216 = phi i1 [ true, %cond.true211 ], [ %cmp214, %cond.false212 ]
  br label %cond.end217

cond.end217:                                      ; preds = %cond.end215, %cond.true207
  %cond218 = phi i1 [ false, %cond.true207 ], [ %cond216, %cond.end215 ]
  %frombool219 = zext i1 %cond218 to i8
  store i8 %frombool219, ptr %pad_outer_x, align 1
  %191 = load i32, ptr %flags.addr, align 4
  %and220 = and i32 %191, 8388608
  %tobool221 = icmp ne i32 %and220, 0
  %cond222 = select i1 %tobool221, i1 false, i1 true
  %frombool223 = zext i1 %cond222 to i8
  store i8 %frombool223, ptr %pad_inner_x, align 1
  %192 = load i32, ptr %flags.addr, align 4
  %and224 = and i32 %192, 512
  %tobool225 = icmp ne i32 %and224, 0
  %cond226 = select i1 %tobool225, float 1.000000e+00, float 0.000000e+00
  store float %cond226, ptr %inner_spacing_for_border, align 4
  %193 = load i8, ptr %pad_inner_x, align 1
  %tobool227 = trunc i8 %193 to i1
  br i1 %tobool227, label %land.lhs.true228, label %cond.false233

land.lhs.true228:                                 ; preds = %cond.end217
  %194 = load i32, ptr %flags.addr, align 4
  %and229 = and i32 %194, 512
  %cmp230 = icmp eq i32 %and229, 0
  br i1 %cmp230, label %cond.true231, label %cond.false233

cond.true231:                                     ; preds = %land.lhs.true228
  %195 = load ptr, ptr %g, align 8
  %Style = getelementptr inbounds %struct.ImGuiContext, ptr %195, i32 0, i32 3
  %CellPadding = getelementptr inbounds %struct.ImGuiStyle, ptr %Style, i32 0, i32 17
  %x232 = getelementptr inbounds %struct.ImVec2, ptr %CellPadding, i32 0, i32 0
  %196 = load float, ptr %x232, align 4
  br label %cond.end234

cond.false233:                                    ; preds = %land.lhs.true228, %cond.end217
  br label %cond.end234

cond.end234:                                      ; preds = %cond.false233, %cond.true231
  %cond235 = phi float [ %196, %cond.true231 ], [ 0.000000e+00, %cond.false233 ]
  store float %cond235, ptr %inner_spacing_explicit, align 4
  %197 = load i8, ptr %pad_inner_x, align 1
  %tobool236 = trunc i8 %197 to i1
  br i1 %tobool236, label %land.lhs.true237, label %cond.false244

land.lhs.true237:                                 ; preds = %cond.end234
  %198 = load i32, ptr %flags.addr, align 4
  %and238 = and i32 %198, 512
  %cmp239 = icmp ne i32 %and238, 0
  br i1 %cmp239, label %cond.true240, label %cond.false244

cond.true240:                                     ; preds = %land.lhs.true237
  %199 = load ptr, ptr %g, align 8
  %Style241 = getelementptr inbounds %struct.ImGuiContext, ptr %199, i32 0, i32 3
  %CellPadding242 = getelementptr inbounds %struct.ImGuiStyle, ptr %Style241, i32 0, i32 17
  %x243 = getelementptr inbounds %struct.ImVec2, ptr %CellPadding242, i32 0, i32 0
  %200 = load float, ptr %x243, align 4
  br label %cond.end245

cond.false244:                                    ; preds = %land.lhs.true237, %cond.end234
  br label %cond.end245

cond.end245:                                      ; preds = %cond.false244, %cond.true240
  %cond246 = phi float [ %200, %cond.true240 ], [ 0.000000e+00, %cond.false244 ]
  store float %cond246, ptr %inner_padding_explicit, align 4
  %201 = load float, ptr %inner_spacing_explicit, align 4
  %202 = load float, ptr %inner_spacing_for_border, align 4
  %add247 = fadd float %201, %202
  %203 = load ptr, ptr %table, align 8
  %CellSpacingX1 = getelementptr inbounds %struct.ImGuiTable, ptr %203, i32 0, i32 35
  store float %add247, ptr %CellSpacingX1, align 4
  %204 = load float, ptr %inner_spacing_explicit, align 4
  %205 = load ptr, ptr %table, align 8
  %CellSpacingX2 = getelementptr inbounds %struct.ImGuiTable, ptr %205, i32 0, i32 36
  store float %204, ptr %CellSpacingX2, align 8
  %206 = load float, ptr %inner_padding_explicit, align 4
  %207 = load ptr, ptr %table, align 8
  %CellPaddingX = getelementptr inbounds %struct.ImGuiTable, ptr %207, i32 0, i32 34
  store float %206, ptr %CellPaddingX, align 8
  %208 = load i32, ptr %flags.addr, align 4
  %and248 = and i32 %208, 1024
  %tobool249 = icmp ne i32 %and248, 0
  %cond250 = select i1 %tobool249, float 1.000000e+00, float 0.000000e+00
  store float %cond250, ptr %outer_padding_for_border, align 4
  %209 = load i8, ptr %pad_outer_x, align 1
  %tobool251 = trunc i8 %209 to i1
  br i1 %tobool251, label %cond.true252, label %cond.false256

cond.true252:                                     ; preds = %cond.end245
  %210 = load ptr, ptr %g, align 8
  %Style253 = getelementptr inbounds %struct.ImGuiContext, ptr %210, i32 0, i32 3
  %CellPadding254 = getelementptr inbounds %struct.ImGuiStyle, ptr %Style253, i32 0, i32 17
  %x255 = getelementptr inbounds %struct.ImVec2, ptr %CellPadding254, i32 0, i32 0
  %211 = load float, ptr %x255, align 4
  br label %cond.end257

cond.false256:                                    ; preds = %cond.end245
  br label %cond.end257

cond.end257:                                      ; preds = %cond.false256, %cond.true252
  %cond258 = phi float [ %211, %cond.true252 ], [ 0.000000e+00, %cond.false256 ]
  store float %cond258, ptr %outer_padding_explicit, align 4
  %212 = load float, ptr %outer_padding_for_border, align 4
  %213 = load float, ptr %outer_padding_explicit, align 4
  %add259 = fadd float %212, %213
  %214 = load ptr, ptr %table, align 8
  %CellPaddingX260 = getelementptr inbounds %struct.ImGuiTable, ptr %214, i32 0, i32 34
  %215 = load float, ptr %CellPaddingX260, align 8
  %sub261 = fsub float %add259, %215
  %216 = load ptr, ptr %table, align 8
  %OuterPaddingX = getelementptr inbounds %struct.ImGuiTable, ptr %216, i32 0, i32 33
  store float %sub261, ptr %OuterPaddingX, align 4
  %217 = load ptr, ptr %table, align 8
  %CurrentColumn = getelementptr inbounds %struct.ImGuiTable, ptr %217, i32 0, i32 15
  store i32 -1, ptr %CurrentColumn, align 4
  %218 = load ptr, ptr %table, align 8
  %CurrentRow = getelementptr inbounds %struct.ImGuiTable, ptr %218, i32 0, i32 14
  store i32 -1, ptr %CurrentRow, align 8
  %219 = load ptr, ptr %table, align 8
  %RowBgColorCounter = getelementptr inbounds %struct.ImGuiTable, ptr %219, i32 0, i32 25
  store i32 0, ptr %RowBgColorCounter, align 8
  %220 = load ptr, ptr %table, align 8
  %LastRowFlags = getelementptr inbounds %struct.ImGuiTable, ptr %220, i32 0, i32 24
  %bf.load = load i32, ptr %LastRowFlags, align 4
  %bf.clear = and i32 %bf.load, 65535
  %bf.set = or i32 %bf.clear, 0
  store i32 %bf.set, ptr %LastRowFlags, align 4
  %221 = load ptr, ptr %inner_window, align 8
  %222 = load ptr, ptr %outer_window, align 8
  %cmp262 = icmp eq ptr %221, %222
  br i1 %cmp262, label %cond.true263, label %cond.false265

cond.true263:                                     ; preds = %cond.end257
  %223 = load ptr, ptr %table, align 8
  %WorkRect264 = getelementptr inbounds %struct.ImGuiTable, ptr %223, i32 0, i32 48
  br label %cond.end267

cond.false265:                                    ; preds = %cond.end257
  %224 = load ptr, ptr %inner_window, align 8
  %ClipRect266 = getelementptr inbounds %struct.ImGuiWindow, ptr %224, i32 0, i32 74
  br label %cond.end267

cond.end267:                                      ; preds = %cond.false265, %cond.true263
  %cond-lvalue = phi ptr [ %WorkRect264, %cond.true263 ], [ %ClipRect266, %cond.false265 ]
  %225 = load ptr, ptr %table, align 8
  %InnerClipRect = getelementptr inbounds %struct.ImGuiTable, ptr %225, i32 0, i32 49
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %InnerClipRect, ptr align 8 %cond-lvalue, i64 16, i1 false)
  %226 = load ptr, ptr %table, align 8
  %InnerClipRect268 = getelementptr inbounds %struct.ImGuiTable, ptr %226, i32 0, i32 49
  %227 = load ptr, ptr %table, align 8
  %WorkRect269 = getelementptr inbounds %struct.ImGuiTable, ptr %227, i32 0, i32 48
  call void @_ZN6ImRect8ClipWithERKS_(ptr noundef nonnull align 4 dereferenceable(16) %InnerClipRect268, ptr noundef nonnull align 4 dereferenceable(16) %WorkRect269)
  %228 = load ptr, ptr %table, align 8
  %InnerClipRect270 = getelementptr inbounds %struct.ImGuiTable, ptr %228, i32 0, i32 49
  %229 = load ptr, ptr %table, align 8
  %HostClipRect271 = getelementptr inbounds %struct.ImGuiTable, ptr %229, i32 0, i32 53
  call void @_ZN6ImRect12ClipWithFullERKS_(ptr noundef nonnull align 4 dereferenceable(16) %InnerClipRect270, ptr noundef nonnull align 4 dereferenceable(16) %HostClipRect271)
  %230 = load i32, ptr %flags.addr, align 4
  %and272 = and i32 %230, 131072
  %tobool273 = icmp ne i32 %and272, 0
  br i1 %tobool273, label %cond.true274, label %cond.false282

cond.true274:                                     ; preds = %cond.end267
  %231 = load ptr, ptr %table, align 8
  %InnerClipRect275 = getelementptr inbounds %struct.ImGuiTable, ptr %231, i32 0, i32 49
  %Max276 = getelementptr inbounds %struct.ImRect, ptr %InnerClipRect275, i32 0, i32 1
  %y277 = getelementptr inbounds %struct.ImVec2, ptr %Max276, i32 0, i32 1
  %232 = load float, ptr %y277, align 4
  %233 = load ptr, ptr %inner_window, align 8
  %WorkRect278 = getelementptr inbounds %struct.ImGuiWindow, ptr %233, i32 0, i32 72
  %Max279 = getelementptr inbounds %struct.ImRect, ptr %WorkRect278, i32 0, i32 1
  %y280 = getelementptr inbounds %struct.ImVec2, ptr %Max279, i32 0, i32 1
  %234 = load float, ptr %y280, align 4
  %call281 = call noundef float @_ZL5ImMinIfET_S0_S0_(float noundef %232, float noundef %234)
  br label %cond.end286

cond.false282:                                    ; preds = %cond.end267
  %235 = load ptr, ptr %inner_window, align 8
  %ClipRect283 = getelementptr inbounds %struct.ImGuiWindow, ptr %235, i32 0, i32 74
  %Max284 = getelementptr inbounds %struct.ImRect, ptr %ClipRect283, i32 0, i32 1
  %y285 = getelementptr inbounds %struct.ImVec2, ptr %Max284, i32 0, i32 1
  %236 = load float, ptr %y285, align 4
  br label %cond.end286

cond.end286:                                      ; preds = %cond.false282, %cond.true274
  %cond287 = phi float [ %call281, %cond.true274 ], [ %236, %cond.false282 ]
  %237 = load ptr, ptr %table, align 8
  %InnerClipRect288 = getelementptr inbounds %struct.ImGuiTable, ptr %237, i32 0, i32 49
  %Max289 = getelementptr inbounds %struct.ImRect, ptr %InnerClipRect288, i32 0, i32 1
  %y290 = getelementptr inbounds %struct.ImVec2, ptr %Max289, i32 0, i32 1
  store float %cond287, ptr %y290, align 4
  %238 = load ptr, ptr %table, align 8
  %WorkRect291 = getelementptr inbounds %struct.ImGuiTable, ptr %238, i32 0, i32 48
  %Min292 = getelementptr inbounds %struct.ImRect, ptr %WorkRect291, i32 0, i32 0
  %y293 = getelementptr inbounds %struct.ImVec2, ptr %Min292, i32 0, i32 1
  %239 = load float, ptr %y293, align 4
  %240 = load ptr, ptr %table, align 8
  %RowPosY2 = getelementptr inbounds %struct.ImGuiTable, ptr %240, i32 0, i32 19
  store float %239, ptr %RowPosY2, align 8
  %241 = load ptr, ptr %table, align 8
  %RowPosY1 = getelementptr inbounds %struct.ImGuiTable, ptr %241, i32 0, i32 18
  store float %239, ptr %RowPosY1, align 4
  %242 = load ptr, ptr %table, align 8
  %RowTextBaseline = getelementptr inbounds %struct.ImGuiTable, ptr %242, i32 0, i32 22
  store float 0.000000e+00, ptr %RowTextBaseline, align 4
  %243 = load ptr, ptr %table, align 8
  %RowCellPaddingY = getelementptr inbounds %struct.ImGuiTable, ptr %243, i32 0, i32 21
  store float 0.000000e+00, ptr %RowCellPaddingY, align 8
  %244 = load ptr, ptr %table, align 8
  %FreezeRowsCount = getelementptr inbounds %struct.ImGuiTable, ptr %244, i32 0, i32 85
  store i16 0, ptr %FreezeRowsCount, align 8
  %245 = load ptr, ptr %table, align 8
  %FreezeRowsRequest = getelementptr inbounds %struct.ImGuiTable, ptr %245, i32 0, i32 84
  store i16 0, ptr %FreezeRowsRequest, align 2
  %246 = load ptr, ptr %table, align 8
  %FreezeColumnsCount = getelementptr inbounds %struct.ImGuiTable, ptr %246, i32 0, i32 87
  store i16 0, ptr %FreezeColumnsCount, align 4
  %247 = load ptr, ptr %table, align 8
  %FreezeColumnsRequest = getelementptr inbounds %struct.ImGuiTable, ptr %247, i32 0, i32 86
  store i16 0, ptr %FreezeColumnsRequest, align 2
  %248 = load ptr, ptr %table, align 8
  %IsUnfrozenRows = getelementptr inbounds %struct.ImGuiTable, ptr %248, i32 0, i32 104
  store i8 1, ptr %IsUnfrozenRows, align 2
  %249 = load ptr, ptr %table, align 8
  %AngledHeadersCount = getelementptr inbounds %struct.ImGuiTable, ptr %249, i32 0, i32 69
  store i16 0, ptr %AngledHeadersCount, align 8
  %250 = load ptr, ptr %table, align 8
  %DeclColumnsCount = getelementptr inbounds %struct.ImGuiTable, ptr %250, i32 0, i32 68
  store i16 0, ptr %DeclColumnsCount, align 2
  %251 = load i32, ptr %previous_frame_active, align 4
  %add294 = add nsw i32 %251, 1
  %252 = load ptr, ptr %g, align 8
  %FrameCount295 = getelementptr inbounds %struct.ImGuiContext, ptr %252, i32 0, i32 9
  %253 = load i32, ptr %FrameCount295, align 8
  %cmp296 = icmp slt i32 %add294, %253
  br i1 %cmp296, label %if.then297, label %if.end298

if.then297:                                       ; preds = %cond.end286
  %254 = load ptr, ptr %table, align 8
  %IsActiveIdInTable = getelementptr inbounds %struct.ImGuiTable, ptr %254, i32 0, i32 107
  store i8 0, ptr %IsActiveIdInTable, align 1
  br label %if.end298

if.end298:                                        ; preds = %if.then297, %cond.end286
  %255 = load ptr, ptr %temp_data, align 8
  %AngledheadersExtraWidth = getelementptr inbounds %struct.ImGuiTableTempData, ptr %255, i32 0, i32 2
  store float 0.000000e+00, ptr %AngledheadersExtraWidth, align 8
  %call299 = call noundef i32 @_ZN5ImGui11GetColorU32Eif(i32 noundef 43, float noundef 1.000000e+00)
  %256 = load ptr, ptr %table, align 8
  %BorderColorStrong = getelementptr inbounds %struct.ImGuiTable, ptr %256, i32 0, i32 27
  store i32 %call299, ptr %BorderColorStrong, align 4
  %call300 = call noundef i32 @_ZN5ImGui11GetColorU32Eif(i32 noundef 44, float noundef 1.000000e+00)
  %257 = load ptr, ptr %table, align 8
  %BorderColorLight = getelementptr inbounds %struct.ImGuiTable, ptr %257, i32 0, i32 28
  store i32 %call300, ptr %BorderColorLight, align 8
  %258 = load ptr, ptr %table, align 8
  %259 = load ptr, ptr %g, align 8
  %CurrentTable = getelementptr inbounds %struct.ImGuiContext, ptr %259, i32 0, i32 164
  store ptr %258, ptr %CurrentTable, align 8
  %260 = load ptr, ptr %outer_window, align 8
  %DC301 = getelementptr inbounds %struct.ImGuiWindow, ptr %260, i32 0, i32 68
  %NavIsScrollPushableX = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC301, i32 0, i32 18
  store i8 0, ptr %NavIsScrollPushableX, align 8
  %261 = load i32, ptr %table_idx, align 4
  %262 = load ptr, ptr %outer_window, align 8
  %DC302 = getelementptr inbounds %struct.ImGuiWindow, ptr %262, i32 0, i32 68
  %CurrentTableIdx = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC302, i32 0, i32 29
  store i32 %261, ptr %CurrentTableIdx, align 8
  %263 = load ptr, ptr %inner_window, align 8
  %264 = load ptr, ptr %outer_window, align 8
  %cmp303 = icmp ne ptr %263, %264
  br i1 %cmp303, label %if.then304, label %if.end307

if.then304:                                       ; preds = %if.end298
  %265 = load i32, ptr %table_idx, align 4
  %266 = load ptr, ptr %inner_window, align 8
  %DC305 = getelementptr inbounds %struct.ImGuiWindow, ptr %266, i32 0, i32 68
  %CurrentTableIdx306 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC305, i32 0, i32 29
  store i32 %265, ptr %CurrentTableIdx306, align 8
  br label %if.end307

if.end307:                                        ; preds = %if.then304, %if.end298
  %267 = load i32, ptr %table_last_flags, align 4
  %and308 = and i32 %267, 2
  %tobool309 = icmp ne i32 %and308, 0
  br i1 %tobool309, label %land.lhs.true310, label %if.end314

land.lhs.true310:                                 ; preds = %if.end307
  %268 = load i32, ptr %flags.addr, align 4
  %and311 = and i32 %268, 2
  %cmp312 = icmp eq i32 %and311, 0
  br i1 %cmp312, label %if.then313, label %if.end314

if.then313:                                       ; preds = %land.lhs.true310
  %269 = load ptr, ptr %table, align 8
  %IsResetDisplayOrderRequest = getelementptr inbounds %struct.ImGuiTable, ptr %269, i32 0, i32 103
  store i8 1, ptr %IsResetDisplayOrderRequest, align 1
  br label %if.end314

if.end314:                                        ; preds = %if.then313, %land.lhs.true310, %if.end307
  %270 = load i32, ptr %table_idx, align 4
  %271 = load ptr, ptr %g, align 8
  %TablesLastTimeActive = getelementptr inbounds %struct.ImGuiContext, ptr %271, i32 0, i32 168
  %Size315 = getelementptr inbounds %struct.ImVector.19, ptr %TablesLastTimeActive, i32 0, i32 0
  %272 = load i32, ptr %Size315, align 8
  %cmp316 = icmp sge i32 %270, %272
  br i1 %cmp316, label %if.then317, label %if.end321

if.then317:                                       ; preds = %if.end314
  %273 = load ptr, ptr %g, align 8
  %TablesLastTimeActive318 = getelementptr inbounds %struct.ImGuiContext, ptr %273, i32 0, i32 168
  %274 = load i32, ptr %table_idx, align 4
  %add319 = add nsw i32 %274, 1
  store float -1.000000e+00, ptr %ref.tmp320, align 4
  call void @_ZN8ImVectorIfE6resizeEiRKf(ptr noundef nonnull align 8 dereferenceable(16) %TablesLastTimeActive318, i32 noundef %add319, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp320)
  br label %if.end321

if.end321:                                        ; preds = %if.then317, %if.end314
  %275 = load ptr, ptr %g, align 8
  %Time = getelementptr inbounds %struct.ImGuiContext, ptr %275, i32 0, i32 8
  %276 = load double, ptr %Time, align 8
  %conv322 = fptrunc double %276 to float
  %277 = load ptr, ptr %g, align 8
  %TablesLastTimeActive323 = getelementptr inbounds %struct.ImGuiContext, ptr %277, i32 0, i32 168
  %278 = load i32, ptr %table_idx, align 4
  %call324 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZN8ImVectorIfEixEi(ptr noundef nonnull align 8 dereferenceable(16) %TablesLastTimeActive323, i32 noundef %278)
  store float %conv322, ptr %call324, align 4
  %279 = load ptr, ptr %g, align 8
  %Time325 = getelementptr inbounds %struct.ImGuiContext, ptr %279, i32 0, i32 8
  %280 = load double, ptr %Time325, align 8
  %conv326 = fptrunc double %280 to float
  %281 = load ptr, ptr %temp_data, align 8
  %LastTimeActive = getelementptr inbounds %struct.ImGuiTableTempData, ptr %281, i32 0, i32 1
  store float %conv326, ptr %LastTimeActive, align 4
  %282 = load ptr, ptr %table, align 8
  %MemoryCompacted = getelementptr inbounds %struct.ImGuiTable, ptr %282, i32 0, i32 110
  store i8 0, ptr %MemoryCompacted, align 8
  store ptr null, ptr %old_columns_to_preserve, align 8
  store ptr null, ptr %old_columns_raw_data, align 8
  %283 = load ptr, ptr %table, align 8
  %Columns = getelementptr inbounds %struct.ImGuiTable, ptr %283, i32 0, i32 4
  %call327 = call noundef i32 @_ZNK6ImSpanI16ImGuiTableColumnE4sizeEv(ptr noundef nonnull align 8 dereferenceable(16) %Columns)
  store i32 %call327, ptr %old_columns_count, align 4
  %284 = load i32, ptr %old_columns_count, align 4
  %cmp328 = icmp ne i32 %284, 0
  br i1 %cmp328, label %land.lhs.true329, label %if.end334

land.lhs.true329:                                 ; preds = %if.end321
  %285 = load i32, ptr %old_columns_count, align 4
  %286 = load i32, ptr %columns_count.addr, align 4
  %cmp330 = icmp ne i32 %285, %286
  br i1 %cmp330, label %if.then331, label %if.end334

if.then331:                                       ; preds = %land.lhs.true329
  %287 = load ptr, ptr %table, align 8
  %Columns332 = getelementptr inbounds %struct.ImGuiTable, ptr %287, i32 0, i32 4
  %Data = getelementptr inbounds %struct.ImSpan, ptr %Columns332, i32 0, i32 0
  %288 = load ptr, ptr %Data, align 8
  store ptr %288, ptr %old_columns_to_preserve, align 8
  %289 = load ptr, ptr %table, align 8
  %RawData = getelementptr inbounds %struct.ImGuiTable, ptr %289, i32 0, i32 2
  %290 = load ptr, ptr %RawData, align 8
  store ptr %290, ptr %old_columns_raw_data, align 8
  %291 = load ptr, ptr %table, align 8
  %RawData333 = getelementptr inbounds %struct.ImGuiTable, ptr %291, i32 0, i32 2
  store ptr null, ptr %RawData333, align 8
  br label %if.end334

if.end334:                                        ; preds = %if.then331, %land.lhs.true329, %if.end321
  %292 = load ptr, ptr %table, align 8
  %RawData335 = getelementptr inbounds %struct.ImGuiTable, ptr %292, i32 0, i32 2
  %293 = load ptr, ptr %RawData335, align 8
  %cmp336 = icmp eq ptr %293, null
  br i1 %cmp336, label %if.then337, label %if.end338

if.then337:                                       ; preds = %if.end334
  %294 = load ptr, ptr %table, align 8
  %295 = load i32, ptr %columns_count.addr, align 4
  call void @_ZN5ImGui20TableBeginInitMemoryEP10ImGuiTablei(ptr noundef %294, i32 noundef %295)
  %296 = load ptr, ptr %table, align 8
  %IsSettingsRequestLoad = getelementptr inbounds %struct.ImGuiTable, ptr %296, i32 0, i32 99
  store i8 1, ptr %IsSettingsRequestLoad, align 1
  %297 = load ptr, ptr %table, align 8
  %IsInitializing = getelementptr inbounds %struct.ImGuiTable, ptr %297, i32 0, i32 94
  store i8 1, ptr %IsInitializing, align 8
  br label %if.end338

if.end338:                                        ; preds = %if.then337, %if.end334
  %298 = load ptr, ptr %table, align 8
  %IsResetAllRequest = getelementptr inbounds %struct.ImGuiTable, ptr %298, i32 0, i32 102
  %299 = load i8, ptr %IsResetAllRequest, align 8
  %tobool339 = trunc i8 %299 to i1
  br i1 %tobool339, label %if.then340, label %if.end341

if.then340:                                       ; preds = %if.end338
  %300 = load ptr, ptr %table, align 8
  call void @_ZN5ImGui18TableResetSettingsEP10ImGuiTable(ptr noundef %300)
  br label %if.end341

if.end341:                                        ; preds = %if.then340, %if.end338
  %301 = load ptr, ptr %table, align 8
  %IsInitializing342 = getelementptr inbounds %struct.ImGuiTable, ptr %301, i32 0, i32 94
  %302 = load i8, ptr %IsInitializing342, align 8
  %tobool343 = trunc i8 %302 to i1
  br i1 %tobool343, label %if.then344, label %if.end359

if.then344:                                       ; preds = %if.end341
  %303 = load ptr, ptr %table, align 8
  %SettingsOffset = getelementptr inbounds %struct.ImGuiTable, ptr %303, i32 0, i32 11
  store i32 -1, ptr %SettingsOffset, align 4
  %304 = load ptr, ptr %table, align 8
  %IsSortSpecsDirty = getelementptr inbounds %struct.ImGuiTable, ptr %304, i32 0, i32 95
  store i8 1, ptr %IsSortSpecsDirty, align 1
  %305 = load ptr, ptr %table, align 8
  %InstanceInteracted = getelementptr inbounds %struct.ImGuiTable, ptr %305, i32 0, i32 17
  store i16 -1, ptr %InstanceInteracted, align 2
  %306 = load ptr, ptr %table, align 8
  %ContextPopupColumn = getelementptr inbounds %struct.ImGuiTable, ptr %306, i32 0, i32 83
  store i16 -1, ptr %ContextPopupColumn, align 4
  %307 = load ptr, ptr %table, align 8
  %LastResizedColumn = getelementptr inbounds %struct.ImGuiTable, ptr %307, i32 0, i32 75
  store i16 -1, ptr %LastResizedColumn, align 4
  %308 = load ptr, ptr %table, align 8
  %ResizedColumn = getelementptr inbounds %struct.ImGuiTable, ptr %308, i32 0, i32 74
  store i16 -1, ptr %ResizedColumn, align 2
  %309 = load ptr, ptr %table, align 8
  %ReorderColumn = getelementptr inbounds %struct.ImGuiTable, ptr %309, i32 0, i32 77
  store i16 -1, ptr %ReorderColumn, align 8
  %310 = load ptr, ptr %table, align 8
  %AutoFitSingleColumn = getelementptr inbounds %struct.ImGuiTable, ptr %310, i32 0, i32 73
  store i16 -1, ptr %AutoFitSingleColumn, align 8
  %311 = load ptr, ptr %table, align 8
  %HoveredColumnBorder = getelementptr inbounds %struct.ImGuiTable, ptr %311, i32 0, i32 71
  store i16 -1, ptr %HoveredColumnBorder, align 4
  %312 = load ptr, ptr %table, align 8
  %HoveredColumnBody = getelementptr inbounds %struct.ImGuiTable, ptr %312, i32 0, i32 70
  store i16 -1, ptr %HoveredColumnBody, align 2
  store i32 0, ptr %n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then344
  %313 = load i32, ptr %n, align 4
  %314 = load i32, ptr %columns_count.addr, align 4
  %cmp345 = icmp slt i32 %313, %314
  br i1 %cmp345, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %315 = load ptr, ptr %table, align 8
  %Columns346 = getelementptr inbounds %struct.ImGuiTable, ptr %315, i32 0, i32 4
  %316 = load i32, ptr %n, align 4
  %call347 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns346, i32 noundef %316)
  store ptr %call347, ptr %column, align 8
  %317 = load ptr, ptr %old_columns_to_preserve, align 8
  %tobool348 = icmp ne ptr %317, null
  br i1 %tobool348, label %land.lhs.true349, label %if.else352

land.lhs.true349:                                 ; preds = %for.body
  %318 = load i32, ptr %n, align 4
  %319 = load i32, ptr %old_columns_count, align 4
  %cmp350 = icmp slt i32 %318, %319
  br i1 %cmp350, label %if.then351, label %if.else352

if.then351:                                       ; preds = %land.lhs.true349
  %320 = load ptr, ptr %old_columns_to_preserve, align 8
  %321 = load i32, ptr %n, align 4
  %idxprom = sext i32 %321 to i64
  %arrayidx = getelementptr inbounds %struct.ImGuiTableColumn, ptr %320, i64 %idxprom
  %322 = load ptr, ptr %column, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %322, ptr align 4 %arrayidx, i64 111, i1 false)
  br label %if.end355

if.else352:                                       ; preds = %land.lhs.true349, %for.body
  %323 = load ptr, ptr %column, align 8
  %WidthAuto = getelementptr inbounds %struct.ImGuiTableColumn, ptr %323, i32 0, i32 5
  %324 = load float, ptr %WidthAuto, align 4
  store float %324, ptr %width_auto, align 4
  call void @_ZN16ImGuiTableColumnC2Ev(ptr noundef nonnull align 4 dereferenceable(111) %ref.tmp353)
  %325 = load ptr, ptr %column, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %325, ptr align 4 %ref.tmp353, i64 111, i1 false)
  %326 = load float, ptr %width_auto, align 4
  %327 = load ptr, ptr %column, align 8
  %WidthAuto354 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %327, i32 0, i32 5
  store float %326, ptr %WidthAuto354, align 4
  %328 = load ptr, ptr %column, align 8
  %IsPreserveWidthAuto = getelementptr inbounds %struct.ImGuiTableColumn, ptr %328, i32 0, i32 33
  store i8 1, ptr %IsPreserveWidthAuto, align 1
  %329 = load ptr, ptr %column, align 8
  %IsUserEnabledNextFrame = getelementptr inbounds %struct.ImGuiTableColumn, ptr %329, i32 0, i32 28
  store i8 1, ptr %IsUserEnabledNextFrame, align 4
  %330 = load ptr, ptr %column, align 8
  %IsUserEnabled = getelementptr inbounds %struct.ImGuiTableColumn, ptr %330, i32 0, i32 27
  store i8 1, ptr %IsUserEnabled, align 1
  %331 = load ptr, ptr %column, align 8
  %IsEnabled = getelementptr inbounds %struct.ImGuiTableColumn, ptr %331, i32 0, i32 26
  store i8 1, ptr %IsEnabled, align 2
  br label %if.end355

if.end355:                                        ; preds = %if.else352, %if.then351
  %332 = load i32, ptr %n, align 4
  %conv356 = trunc i32 %332 to i16
  %333 = load ptr, ptr %table, align 8
  %DisplayOrderToIndex = getelementptr inbounds %struct.ImGuiTable, ptr %333, i32 0, i32 5
  %334 = load i32, ptr %n, align 4
  %call357 = call noundef nonnull align 2 dereferenceable(2) ptr @_ZN6ImSpanIsEixEi(ptr noundef nonnull align 8 dereferenceable(16) %DisplayOrderToIndex, i32 noundef %334)
  store i16 %conv356, ptr %call357, align 2
  %335 = load ptr, ptr %column, align 8
  %DisplayOrder = getelementptr inbounds %struct.ImGuiTableColumn, ptr %335, i32 0, i32 18
  store i16 %conv356, ptr %DisplayOrder, align 2
  br label %for.inc

for.inc:                                          ; preds = %if.end355
  %336 = load i32, ptr %n, align 4
  %inc358 = add nsw i32 %336, 1
  store i32 %inc358, ptr %n, align 4
  br label %for.cond, !llvm.loop !4

for.end:                                          ; preds = %for.cond
  br label %if.end359

if.end359:                                        ; preds = %for.end, %if.end341
  %337 = load ptr, ptr %old_columns_raw_data, align 8
  %tobool360 = icmp ne ptr %337, null
  br i1 %tobool360, label %if.then361, label %if.end362

if.then361:                                       ; preds = %if.end359
  %338 = load ptr, ptr %old_columns_raw_data, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %338)
  br label %if.end362

if.end362:                                        ; preds = %if.then361, %if.end359
  %339 = load ptr, ptr %table, align 8
  %IsSettingsRequestLoad363 = getelementptr inbounds %struct.ImGuiTable, ptr %339, i32 0, i32 99
  %340 = load i8, ptr %IsSettingsRequestLoad363, align 1
  %tobool364 = trunc i8 %340 to i1
  br i1 %tobool364, label %if.then365, label %if.end366

if.then365:                                       ; preds = %if.end362
  %341 = load ptr, ptr %table, align 8
  call void @_ZN5ImGui17TableLoadSettingsEP10ImGuiTable(ptr noundef %341)
  br label %if.end366

if.end366:                                        ; preds = %if.then365, %if.end362
  %342 = load ptr, ptr %g, align 8
  %FontSize = getelementptr inbounds %struct.ImGuiContext, ptr %342, i32 0, i32 5
  %343 = load float, ptr %FontSize, align 8
  store float %343, ptr %new_ref_scale_unit, align 4
  %344 = load ptr, ptr %table, align 8
  %RefScale = getelementptr inbounds %struct.ImGuiTable, ptr %344, i32 0, i32 43
  %345 = load float, ptr %RefScale, align 4
  %cmp367 = fcmp une float %345, 0.000000e+00
  br i1 %cmp367, label %land.lhs.true368, label %if.end385

land.lhs.true368:                                 ; preds = %if.end366
  %346 = load ptr, ptr %table, align 8
  %RefScale369 = getelementptr inbounds %struct.ImGuiTable, ptr %346, i32 0, i32 43
  %347 = load float, ptr %RefScale369, align 4
  %348 = load float, ptr %new_ref_scale_unit, align 4
  %cmp370 = fcmp une float %347, %348
  br i1 %cmp370, label %if.then371, label %if.end385

if.then371:                                       ; preds = %land.lhs.true368
  %349 = load float, ptr %new_ref_scale_unit, align 4
  %350 = load ptr, ptr %table, align 8
  %RefScale372 = getelementptr inbounds %struct.ImGuiTable, ptr %350, i32 0, i32 43
  %351 = load float, ptr %RefScale372, align 4
  %div = fdiv float %349, %351
  store float %div, ptr %scale_factor, align 4
  store i32 0, ptr %n373, align 4
  br label %for.cond374

for.cond374:                                      ; preds = %for.inc382, %if.then371
  %352 = load i32, ptr %n373, align 4
  %353 = load i32, ptr %columns_count.addr, align 4
  %cmp375 = icmp slt i32 %352, %353
  br i1 %cmp375, label %for.body376, label %for.end384

for.body376:                                      ; preds = %for.cond374
  %354 = load ptr, ptr %table, align 8
  %Columns377 = getelementptr inbounds %struct.ImGuiTable, ptr %354, i32 0, i32 4
  %355 = load i32, ptr %n373, align 4
  %call378 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns377, i32 noundef %355)
  %WidthRequest = getelementptr inbounds %struct.ImGuiTableColumn, ptr %call378, i32 0, i32 4
  %356 = load float, ptr %WidthRequest, align 4
  %357 = load float, ptr %scale_factor, align 4
  %mul = fmul float %356, %357
  %358 = load ptr, ptr %table, align 8
  %Columns379 = getelementptr inbounds %struct.ImGuiTable, ptr %358, i32 0, i32 4
  %359 = load i32, ptr %n373, align 4
  %call380 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns379, i32 noundef %359)
  %WidthRequest381 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %call380, i32 0, i32 4
  store float %mul, ptr %WidthRequest381, align 4
  br label %for.inc382

for.inc382:                                       ; preds = %for.body376
  %360 = load i32, ptr %n373, align 4
  %inc383 = add nsw i32 %360, 1
  store i32 %inc383, ptr %n373, align 4
  br label %for.cond374, !llvm.loop !6

for.end384:                                       ; preds = %for.cond374
  br label %if.end385

if.end385:                                        ; preds = %for.end384, %land.lhs.true368, %if.end366
  %361 = load float, ptr %new_ref_scale_unit, align 4
  %362 = load ptr, ptr %table, align 8
  %RefScale386 = getelementptr inbounds %struct.ImGuiTable, ptr %362, i32 0, i32 43
  store float %361, ptr %RefScale386, align 4
  %363 = load ptr, ptr %inner_window, align 8
  %SkipItems387 = getelementptr inbounds %struct.ImGuiWindow, ptr %363, i32 0, i32 38
  store i8 1, ptr %SkipItems387, align 1
  %364 = load ptr, ptr %table, align 8
  %ColumnsNames = getelementptr inbounds %struct.ImGuiTable, ptr %364, i32 0, i32 57
  %Buf = getelementptr inbounds %struct.ImGuiTextBuffer, ptr %ColumnsNames, i32 0, i32 0
  %Size388 = getelementptr inbounds %struct.ImVector.25, ptr %Buf, i32 0, i32 0
  %365 = load i32, ptr %Size388, align 8
  %cmp389 = icmp sgt i32 %365, 0
  br i1 %cmp389, label %if.then390, label %if.end393

if.then390:                                       ; preds = %if.end385
  %366 = load ptr, ptr %table, align 8
  %ColumnsNames391 = getelementptr inbounds %struct.ImGuiTable, ptr %366, i32 0, i32 57
  %Buf392 = getelementptr inbounds %struct.ImGuiTextBuffer, ptr %ColumnsNames391, i32 0, i32 0
  call void @_ZN8ImVectorIcE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %Buf392, i32 noundef 0)
  br label %if.end393

if.end393:                                        ; preds = %if.then390, %if.end385
  %367 = load ptr, ptr %table, align 8
  call void @_ZN5ImGui23TableBeginApplyRequestsEP10ImGuiTable(ptr noundef %367)
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end393, %if.then21, %if.then
  %368 = load i1, ptr %retval, align 1
  ret i1 %368

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val394 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val394
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef ptr @_ZN5ImGui16GetCurrentWindowEv() #3 comdat {
entry:
  %g = alloca ptr, align 8
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %g, align 8
  %CurrentWindow = getelementptr inbounds %struct.ImGuiContext, ptr %1, i32 0, i32 29
  %2 = load ptr, ptr %CurrentWindow, align 8
  %WriteAccessed = getelementptr inbounds %struct.ImGuiWindow, ptr %2, i32 0, i32 35
  store i8 1, ptr %WriteAccessed, align 8
  %3 = load ptr, ptr %g, align 8
  %CurrentWindow1 = getelementptr inbounds %struct.ImGuiContext, ptr %3, i32 0, i32 29
  %4 = load ptr, ptr %CurrentWindow1, align 8
  ret ptr %4
}

declare <2 x float> @_ZN5ImGui21GetContentRegionAvailEv() #1

declare <2 x float> @_ZN5ImGui12CalcItemSizeE6ImVec2ff(<2 x float>, float noundef, float noundef) #1

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #4

; Function Attrs: mustprogress nounwind uwtable
define internal noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %lhs, float noundef %rhs) #3 {
entry:
  %lhs.addr = alloca float, align 4
  %rhs.addr = alloca float, align 4
  store float %lhs, ptr %lhs.addr, align 4
  store float %rhs, ptr %rhs.addr, align 4
  %0 = load float, ptr %lhs.addr, align 4
  %1 = load float, ptr %rhs.addr, align 4
  %cmp = fcmp oge float %0, %1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load float, ptr %lhs.addr, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %3 = load float, ptr %rhs.addr, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi float [ %2, %cond.true ], [ %3, %cond.false ]
  ret float %cond
}

; Function Attrs: mustprogress uwtable
define internal <2 x float> @_ZplRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %lhs, ptr noundef nonnull align 4 dereferenceable(8) %rhs) #2 {
entry:
  %retval = alloca %struct.ImVec2, align 4
  %lhs.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %lhs, ptr %lhs.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %0 = load ptr, ptr %lhs.addr, align 8
  %x = getelementptr inbounds %struct.ImVec2, ptr %0, i32 0, i32 0
  %1 = load float, ptr %x, align 4
  %2 = load ptr, ptr %rhs.addr, align 8
  %x1 = getelementptr inbounds %struct.ImVec2, ptr %2, i32 0, i32 0
  %3 = load float, ptr %x1, align 4
  %add = fadd float %1, %3
  %4 = load ptr, ptr %lhs.addr, align 8
  %y = getelementptr inbounds %struct.ImVec2, ptr %4, i32 0, i32 1
  %5 = load float, ptr %y, align 4
  %6 = load ptr, ptr %rhs.addr, align 8
  %y2 = getelementptr inbounds %struct.ImVec2, ptr %6, i32 0, i32 1
  %7 = load float, ptr %y2, align 4
  %add3 = fadd float %5, %7
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %retval, float noundef %add, float noundef %add3)
  %8 = load <2 x float>, ptr %retval, align 4
  ret <2 x float> %8
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN6ImRectC2ERK6ImVec2S2_(ptr noundef nonnull align 4 dereferenceable(16) %this, ptr noundef nonnull align 4 dereferenceable(8) %min, ptr noundef nonnull align 4 dereferenceable(8) %max) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %min.addr = alloca ptr, align 8
  %max.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %min, ptr %min.addr, align 8
  store ptr %max, ptr %max.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Min = getelementptr inbounds %struct.ImRect, ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %min.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %Min, ptr align 4 %0, i64 8, i1 false)
  %Max = getelementptr inbounds %struct.ImRect, ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %max.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %Max, ptr align 4 %1, i64 8, i1 false)
  ret void
}

declare noundef zeroext i1 @_ZN5ImGui11IsClippedExERK6ImRectj(ptr noundef nonnull align 4 dereferenceable(16), i32 noundef) #1

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN5ImGui8ItemSizeERK6ImRectf(ptr noundef nonnull align 4 dereferenceable(16) %bb, float noundef %text_baseline_y) #2 comdat {
entry:
  %bb.addr = alloca ptr, align 8
  %text_baseline_y.addr = alloca float, align 4
  %ref.tmp = alloca %struct.ImVec2, align 4
  store ptr %bb, ptr %bb.addr, align 8
  store float %text_baseline_y, ptr %text_baseline_y.addr, align 4
  %0 = load ptr, ptr %bb.addr, align 8
  %call = call <2 x float> @_ZNK6ImRect7GetSizeEv(ptr noundef nonnull align 4 dereferenceable(16) %0)
  store <2 x float> %call, ptr %ref.tmp, align 4
  %1 = load float, ptr %text_baseline_y.addr, align 4
  call void @_ZN5ImGui8ItemSizeERK6ImVec2f(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp, float noundef %1)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr noundef ptr @_ZN6ImPoolI10ImGuiTableE13GetOrAddByKeyEj(ptr noundef nonnull align 8 dereferenceable(40) %this, i32 noundef %key) #0 comdat align 2 {
entry:
  %retval = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %key.addr = alloca i32, align 4
  %p_idx = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %key, ptr %key.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Map = getelementptr inbounds %struct.ImPool, ptr %this1, i32 0, i32 1
  %0 = load i32, ptr %key.addr, align 4
  %call = call noundef ptr @_ZN12ImGuiStorage9GetIntRefEji(ptr noundef nonnull align 8 dereferenceable(16) %Map, i32 noundef %0, i32 noundef -1)
  store ptr %call, ptr %p_idx, align 8
  %1 = load ptr, ptr %p_idx, align 8
  %2 = load i32, ptr %1, align 4
  %cmp = icmp ne i32 %2, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Buf = getelementptr inbounds %struct.ImPool, ptr %this1, i32 0, i32 0
  %3 = load ptr, ptr %p_idx, align 8
  %4 = load i32, ptr %3, align 4
  %call2 = call noundef nonnull align 8 dereferenceable(586) ptr @_ZN8ImVectorI10ImGuiTableEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Buf, i32 noundef %4)
  store ptr %call2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %FreeIdx = getelementptr inbounds %struct.ImPool, ptr %this1, i32 0, i32 2
  %5 = load i32, ptr %FreeIdx, align 8
  %6 = load ptr, ptr %p_idx, align 8
  store i32 %5, ptr %6, align 4
  %call3 = call noundef ptr @_ZN6ImPoolI10ImGuiTableE3AddEv(ptr noundef nonnull align 8 dereferenceable(40) %this1)
  store ptr %call3, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load ptr, ptr %retval, align 8
  ret ptr %7
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i32 @_ZNK6ImPoolI10ImGuiTableE8GetIndexEPKS0_(ptr noundef nonnull align 8 dereferenceable(40) %this, ptr noundef %p) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %Buf = getelementptr inbounds %struct.ImPool, ptr %this1, i32 0, i32 0
  %Data = getelementptr inbounds %struct.ImVector.18, ptr %Buf, i32 0, i32 2
  %1 = load ptr, ptr %Data, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 592
  %conv = trunc i64 %sub.ptr.div to i32
  ret i32 %conv
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI18ImGuiTableTempDataE6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_size, ptr noundef nonnull align 8 dereferenceable(116) %v) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_size.addr = alloca i32, align 4
  %v.addr = alloca ptr, align 8
  %n = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_size, ptr %new_size.addr, align 4
  store ptr %v, ptr %v.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_size.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.17, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sgt i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %new_size.addr, align 4
  %call = call noundef i32 @_ZNK8ImVectorI18ImGuiTableTempDataE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %2)
  call void @_ZN8ImVectorI18ImGuiTableTempDataE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %call)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32, ptr %new_size.addr, align 4
  %Size = getelementptr inbounds %struct.ImVector.17, ptr %this1, i32 0, i32 0
  %4 = load i32, ptr %Size, align 8
  %cmp2 = icmp sgt i32 %3, %4
  br i1 %cmp2, label %if.then3, label %if.end6

if.then3:                                         ; preds = %if.end
  %Size4 = getelementptr inbounds %struct.ImVector.17, ptr %this1, i32 0, i32 0
  %5 = load i32, ptr %Size4, align 8
  store i32 %5, ptr %n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then3
  %6 = load i32, ptr %n, align 4
  %7 = load i32, ptr %new_size.addr, align 4
  %cmp5 = icmp slt i32 %6, %7
  br i1 %cmp5, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %Data = getelementptr inbounds %struct.ImVector.17, ptr %this1, i32 0, i32 2
  %8 = load ptr, ptr %Data, align 8
  %9 = load i32, ptr %n, align 4
  %idxprom = sext i32 %9 to i64
  %arrayidx = getelementptr inbounds %struct.ImGuiTableTempData, ptr %8, i64 %idxprom
  %10 = load ptr, ptr %v.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arrayidx, ptr align 8 %10, i64 120, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %11 = load i32, ptr %n, align 4
  %inc = add nsw i32 %11, 1
  store i32 %inc, ptr %n, align 4
  br label %for.cond, !llvm.loop !7

for.end:                                          ; preds = %for.cond
  br label %if.end6

if.end6:                                          ; preds = %for.end, %if.end
  %12 = load i32, ptr %new_size.addr, align 4
  %Size7 = getelementptr inbounds %struct.ImVector.17, ptr %this1, i32 0, i32 0
  store i32 %12, ptr %Size7, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN18ImGuiTableTempDataC2Ev(ptr noundef nonnull align 8 dereferenceable(116) %this) unnamed_addr #0 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %UserOuterSize = getelementptr inbounds %struct.ImGuiTableTempData, ptr %this1, i32 0, i32 3
  call void @_ZN6ImVec2C2Ev(ptr noundef nonnull align 4 dereferenceable(8) %UserOuterSize)
  %DrawSplitter = getelementptr inbounds %struct.ImGuiTableTempData, ptr %this1, i32 0, i32 5
  call void @_ZN18ImDrawListSplitterC2Ev(ptr noundef nonnull align 8 dereferenceable(24) %DrawSplitter)
  %HostBackupWorkRect = getelementptr inbounds %struct.ImGuiTableTempData, ptr %this1, i32 0, i32 6
  invoke void @_ZN6ImRectC2Ev(ptr noundef nonnull align 4 dereferenceable(16) %HostBackupWorkRect)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  %HostBackupParentWorkRect = getelementptr inbounds %struct.ImGuiTableTempData, ptr %this1, i32 0, i32 7
  invoke void @_ZN6ImRectC2Ev(ptr noundef nonnull align 4 dereferenceable(16) %HostBackupParentWorkRect)
          to label %invoke.cont2 unwind label %lpad

invoke.cont2:                                     ; preds = %invoke.cont
  %HostBackupPrevLineSize = getelementptr inbounds %struct.ImGuiTableTempData, ptr %this1, i32 0, i32 8
  invoke void @_ZN6ImVec2C2Ev(ptr noundef nonnull align 4 dereferenceable(8) %HostBackupPrevLineSize)
          to label %invoke.cont3 unwind label %lpad

invoke.cont3:                                     ; preds = %invoke.cont2
  %HostBackupCurrLineSize = getelementptr inbounds %struct.ImGuiTableTempData, ptr %this1, i32 0, i32 9
  invoke void @_ZN6ImVec2C2Ev(ptr noundef nonnull align 4 dereferenceable(8) %HostBackupCurrLineSize)
          to label %invoke.cont4 unwind label %lpad

invoke.cont4:                                     ; preds = %invoke.cont3
  %HostBackupCursorMaxPos = getelementptr inbounds %struct.ImGuiTableTempData, ptr %this1, i32 0, i32 10
  invoke void @_ZN6ImVec2C2Ev(ptr noundef nonnull align 4 dereferenceable(8) %HostBackupCursorMaxPos)
          to label %invoke.cont5 unwind label %lpad

invoke.cont5:                                     ; preds = %invoke.cont4
  %HostBackupColumnsOffset = getelementptr inbounds %struct.ImGuiTableTempData, ptr %this1, i32 0, i32 11
  invoke void @_ZN6ImVec1C2Ev(ptr noundef nonnull align 4 dereferenceable(4) %HostBackupColumnsOffset)
          to label %invoke.cont6 unwind label %lpad

invoke.cont6:                                     ; preds = %invoke.cont5
  call void @llvm.memset.p0.i64(ptr align 8 %this1, i8 0, i64 120, i1 false)
  %LastTimeActive = getelementptr inbounds %struct.ImGuiTableTempData, ptr %this1, i32 0, i32 1
  store float -1.000000e+00, ptr %LastTimeActive, align 4
  ret void

lpad:                                             ; preds = %invoke.cont5, %invoke.cont4, %invoke.cont3, %invoke.cont2, %invoke.cont, %entry
  %0 = landingpad { ptr, i32 }
          cleanup
  %1 = extractvalue { ptr, i32 } %0, 0
  store ptr %1, ptr %exn.slot, align 8
  %2 = extractvalue { ptr, i32 } %0, 1
  store i32 %2, ptr %ehselector.slot, align 4
  call void @_ZN18ImDrawListSplitterD2Ev(ptr noundef nonnull align 8 dereferenceable(24) %DrawSplitter) #10
  br label %eh.resume

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val7 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val7
}

declare i32 @__gxx_personality_v0(...)

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN18ImGuiTableTempDataD2Ev(ptr noundef nonnull align 8 dereferenceable(116) %this) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %DrawSplitter = getelementptr inbounds %struct.ImGuiTableTempData, ptr %this1, i32 0, i32 5
  call void @_ZN18ImDrawListSplitterD2Ev(ptr noundef nonnull align 8 dereferenceable(24) %DrawSplitter) #10
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef nonnull align 8 dereferenceable(116) ptr @_ZN8ImVectorI18ImGuiTableTempDataEixEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %i) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.17, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.ImGuiTableTempData, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN18ImDrawListSplitter5ClearEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %_Current = getelementptr inbounds %struct.ImDrawListSplitter, ptr %this1, i32 0, i32 0
  store i32 0, ptr %_Current, align 8
  %_Count = getelementptr inbounds %struct.ImDrawListSplitter, ptr %this1, i32 0, i32 1
  store i32 1, ptr %_Count, align 4
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i32 @_Z13TableFixFlagsiP11ImGuiWindow(i32 noundef %flags, ptr noundef %outer_window) #3 comdat {
entry:
  %flags.addr = alloca i32, align 4
  %outer_window.addr = alloca ptr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  store ptr %outer_window, ptr %outer_window.addr, align 8
  %0 = load i32, ptr %flags.addr, align 4
  %and = and i32 %0, 57344
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i32, ptr %flags.addr, align 4
  %and1 = and i32 %1, 16777216
  %tobool = icmp ne i32 %and1, 0
  br i1 %tobool, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.then
  %2 = load ptr, ptr %outer_window.addr, align 8
  %Flags = getelementptr inbounds %struct.ImGuiWindow, ptr %2, i32 0, i32 3
  %3 = load i32, ptr %Flags, align 4
  %and2 = and i32 %3, 64
  %tobool3 = icmp ne i32 %and2, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.then
  %4 = phi i1 [ true, %if.then ], [ %tobool3, %lor.rhs ]
  %cond = select i1 %4, i32 8192, i32 32768
  %5 = load i32, ptr %flags.addr, align 4
  %or = or i32 %5, %cond
  store i32 %or, ptr %flags.addr, align 4
  br label %if.end

if.end:                                           ; preds = %lor.end, %entry
  %6 = load i32, ptr %flags.addr, align 4
  %and4 = and i32 %6, 57344
  %cmp5 = icmp eq i32 %and4, 16384
  br i1 %cmp5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end
  %7 = load i32, ptr %flags.addr, align 4
  %or7 = or i32 %7, 262144
  store i32 %or7, ptr %flags.addr, align 4
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %if.end
  %8 = load i32, ptr %flags.addr, align 4
  %and9 = and i32 %8, 1
  %tobool10 = icmp ne i32 %and9, 0
  br i1 %tobool10, label %if.then11, label %if.end13

if.then11:                                        ; preds = %if.end8
  %9 = load i32, ptr %flags.addr, align 4
  %or12 = or i32 %9, 512
  store i32 %or12, ptr %flags.addr, align 4
  br label %if.end13

if.end13:                                         ; preds = %if.then11, %if.end8
  %10 = load i32, ptr %flags.addr, align 4
  %and14 = and i32 %10, 50331648
  %tobool15 = icmp ne i32 %and14, 0
  br i1 %tobool15, label %if.then16, label %if.end18

if.then16:                                        ; preds = %if.end13
  %11 = load i32, ptr %flags.addr, align 4
  %and17 = and i32 %11, -196609
  store i32 %and17, ptr %flags.addr, align 4
  br label %if.end18

if.end18:                                         ; preds = %if.then16, %if.end13
  %12 = load i32, ptr %flags.addr, align 4
  %and19 = and i32 %12, 4096
  %tobool20 = icmp ne i32 %and19, 0
  br i1 %tobool20, label %if.then21, label %if.end23

if.then21:                                        ; preds = %if.end18
  %13 = load i32, ptr %flags.addr, align 4
  %and22 = and i32 %13, -2049
  store i32 %and22, ptr %flags.addr, align 4
  br label %if.end23

if.end23:                                         ; preds = %if.then21, %if.end18
  %14 = load i32, ptr %flags.addr, align 4
  %and24 = and i32 %14, 15
  %cmp25 = icmp eq i32 %and24, 0
  br i1 %cmp25, label %if.then26, label %if.end28

if.then26:                                        ; preds = %if.end23
  %15 = load i32, ptr %flags.addr, align 4
  %or27 = or i32 %15, 16
  store i32 %or27, ptr %flags.addr, align 4
  br label %if.end28

if.end28:                                         ; preds = %if.then26, %if.end23
  %16 = load ptr, ptr %outer_window.addr, align 8
  %RootWindow = getelementptr inbounds %struct.ImGuiWindow, ptr %16, i32 0, i32 90
  %17 = load ptr, ptr %RootWindow, align 8
  %Flags29 = getelementptr inbounds %struct.ImGuiWindow, ptr %17, i32 0, i32 3
  %18 = load i32, ptr %Flags29, align 4
  %and30 = and i32 %18, 256
  %tobool31 = icmp ne i32 %and30, 0
  br i1 %tobool31, label %if.then32, label %if.end34

if.then32:                                        ; preds = %if.end28
  %19 = load i32, ptr %flags.addr, align 4
  %or33 = or i32 %19, 16
  store i32 %or33, ptr %flags.addr, align 4
  br label %if.end34

if.end34:                                         ; preds = %if.then32, %if.end28
  %20 = load i32, ptr %flags.addr, align 4
  ret i32 %20
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI22ImGuiTableInstanceDataE9push_backERKS0_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 4 dereferenceable(24) %v) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %v.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %v, ptr %v.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Size = getelementptr inbounds %struct.ImVector.38, ptr %this1, i32 0, i32 0
  %0 = load i32, ptr %Size, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.38, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp eq i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Size2 = getelementptr inbounds %struct.ImVector.38, ptr %this1, i32 0, i32 0
  %2 = load i32, ptr %Size2, align 8
  %add = add nsw i32 %2, 1
  %call = call noundef i32 @_ZNK8ImVectorI22ImGuiTableInstanceDataE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %add)
  call void @_ZN8ImVectorI22ImGuiTableInstanceDataE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %call)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %Data = getelementptr inbounds %struct.ImVector.38, ptr %this1, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %Size3 = getelementptr inbounds %struct.ImVector.38, ptr %this1, i32 0, i32 0
  %4 = load i32, ptr %Size3, align 8
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds %struct.ImGuiTableInstanceData, ptr %3, i64 %idxprom
  %5 = load ptr, ptr %v.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx, ptr align 4 %5, i64 24, i1 false)
  %Size4 = getelementptr inbounds %struct.ImVector.38, ptr %this1, i32 0, i32 0
  %6 = load i32, ptr %Size4, align 8
  %inc = add nsw i32 %6, 1
  store i32 %inc, ptr %Size4, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN22ImGuiTableInstanceDataC2Ev(ptr noundef nonnull align 4 dereferenceable(24) %this) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %TableInstanceID = getelementptr inbounds %struct.ImGuiTableInstanceData, ptr %this1, i32 0, i32 0
  store i32 0, ptr %TableInstanceID, align 4
  %LastFrozenHeight = getelementptr inbounds %struct.ImGuiTableInstanceData, ptr %this1, i32 0, i32 3
  store float 0.000000e+00, ptr %LastFrozenHeight, align 4
  %LastTopHeadersRowHeight = getelementptr inbounds %struct.ImGuiTableInstanceData, ptr %this1, i32 0, i32 2
  store float 0.000000e+00, ptr %LastTopHeadersRowHeight, align 4
  %LastOuterHeight = getelementptr inbounds %struct.ImGuiTableInstanceData, ptr %this1, i32 0, i32 1
  store float 0.000000e+00, ptr %LastOuterHeight, align 4
  %HoveredRowNext = getelementptr inbounds %struct.ImGuiTableInstanceData, ptr %this1, i32 0, i32 5
  store i32 -1, ptr %HoveredRowNext, align 4
  %HoveredRowLast = getelementptr inbounds %struct.ImGuiTableInstanceData, ptr %this1, i32 0, i32 4
  store i32 -1, ptr %HoveredRowLast, align 4
  ret void
}

declare noundef i32 @_ZN5ImGui13GetIDWithSeedEij(i32 noundef, i32 noundef) #1

declare noundef i32 @_ZN5ImGui13GetIDWithSeedEPKcS1_j(ptr noundef, ptr noundef, i32 noundef) #1

; Function Attrs: mustprogress uwtable
define linkonce_odr noundef ptr @_ZN5ImGui20TableGetInstanceDataEP10ImGuiTablei(ptr noundef %table, i32 noundef %instance_no) #0 comdat {
entry:
  %retval = alloca ptr, align 8
  %table.addr = alloca ptr, align 8
  %instance_no.addr = alloca i32, align 4
  store ptr %table, ptr %table.addr, align 8
  store i32 %instance_no, ptr %instance_no.addr, align 4
  %0 = load i32, ptr %instance_no.addr, align 4
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %table.addr, align 8
  %InstanceDataFirst = getelementptr inbounds %struct.ImGuiTable, ptr %1, i32 0, i32 59
  store ptr %InstanceDataFirst, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %table.addr, align 8
  %InstanceDataExtra = getelementptr inbounds %struct.ImGuiTable, ptr %2, i32 0, i32 60
  %3 = load i32, ptr %instance_no.addr, align 4
  %sub = sub nsw i32 %3, 1
  %call = call noundef nonnull align 4 dereferenceable(24) ptr @_ZN8ImVectorI22ImGuiTableInstanceDataEixEi(ptr noundef nonnull align 8 dereferenceable(16) %InstanceDataExtra, i32 noundef %sub)
  store ptr %call, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load ptr, ptr %retval, align 8
  ret ptr %4
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %this, float noundef %_x, float noundef %_y) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %_x.addr = alloca float, align 4
  %_y.addr = alloca float, align 4
  store ptr %this, ptr %this.addr, align 8
  store float %_x, ptr %_x.addr, align 4
  store float %_y, ptr %_y.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %x = getelementptr inbounds %struct.ImVec2, ptr %this1, i32 0, i32 0
  %0 = load float, ptr %_x.addr, align 4
  store float %0, ptr %x, align 4
  %y = getelementptr inbounds %struct.ImVec2, ptr %this1, i32 0, i32 1
  %1 = load float, ptr %_y.addr, align 4
  store float %1, ptr %y, align 4
  ret void
}

declare void @_ZN5ImGui24SetNextWindowContentSizeERK6ImVec2(ptr noundef nonnull align 4 dereferenceable(8)) #1

declare void @_ZN5ImGui19SetNextWindowScrollERK6ImVec2(ptr noundef nonnull align 4 dereferenceable(8)) #1

declare noundef zeroext i1 @_ZN5ImGui12BeginChildExEPKcjRK6ImVec2ii(ptr noundef, i32 noundef, ptr noundef nonnull align 4 dereferenceable(8), i32 noundef, i32 noundef) #1

; Function Attrs: mustprogress uwtable
define linkonce_odr <2 x float> @_ZNK6ImRect7GetSizeEv(ptr noundef nonnull align 4 dereferenceable(16) %this) #2 comdat align 2 {
entry:
  %retval = alloca %struct.ImVec2, align 4
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Max = getelementptr inbounds %struct.ImRect, ptr %this1, i32 0, i32 1
  %x = getelementptr inbounds %struct.ImVec2, ptr %Max, i32 0, i32 0
  %0 = load float, ptr %x, align 4
  %Min = getelementptr inbounds %struct.ImRect, ptr %this1, i32 0, i32 0
  %x2 = getelementptr inbounds %struct.ImVec2, ptr %Min, i32 0, i32 0
  %1 = load float, ptr %x2, align 4
  %sub = fsub float %0, %1
  %Max3 = getelementptr inbounds %struct.ImRect, ptr %this1, i32 0, i32 1
  %y = getelementptr inbounds %struct.ImVec2, ptr %Max3, i32 0, i32 1
  %2 = load float, ptr %y, align 4
  %Min4 = getelementptr inbounds %struct.ImRect, ptr %this1, i32 0, i32 0
  %y5 = getelementptr inbounds %struct.ImVec2, ptr %Min4, i32 0, i32 1
  %3 = load float, ptr %y5, align 4
  %sub6 = fsub float %2, %3
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %retval, float noundef %sub, float noundef %sub6)
  %4 = load <2 x float>, ptr %retval, align 4
  ret <2 x float> %4
}

; Function Attrs: mustprogress uwtable
define linkonce_odr { <2 x float>, <2 x float> } @_ZNK11ImGuiWindow4RectEv(ptr noundef nonnull align 8 dereferenceable(1013) %this) #0 comdat align 2 {
entry:
  %retval = alloca %struct.ImRect, align 4
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Pos = getelementptr inbounds %struct.ImGuiWindow, ptr %this1, i32 0, i32 7
  %x = getelementptr inbounds %struct.ImVec2, ptr %Pos, i32 0, i32 0
  %0 = load float, ptr %x, align 8
  %Pos2 = getelementptr inbounds %struct.ImGuiWindow, ptr %this1, i32 0, i32 7
  %y = getelementptr inbounds %struct.ImVec2, ptr %Pos2, i32 0, i32 1
  %1 = load float, ptr %y, align 4
  %Pos3 = getelementptr inbounds %struct.ImGuiWindow, ptr %this1, i32 0, i32 7
  %x4 = getelementptr inbounds %struct.ImVec2, ptr %Pos3, i32 0, i32 0
  %2 = load float, ptr %x4, align 8
  %Size = getelementptr inbounds %struct.ImGuiWindow, ptr %this1, i32 0, i32 8
  %x5 = getelementptr inbounds %struct.ImVec2, ptr %Size, i32 0, i32 0
  %3 = load float, ptr %x5, align 8
  %add = fadd float %2, %3
  %Pos6 = getelementptr inbounds %struct.ImGuiWindow, ptr %this1, i32 0, i32 7
  %y7 = getelementptr inbounds %struct.ImVec2, ptr %Pos6, i32 0, i32 1
  %4 = load float, ptr %y7, align 4
  %Size8 = getelementptr inbounds %struct.ImGuiWindow, ptr %this1, i32 0, i32 8
  %y9 = getelementptr inbounds %struct.ImVec2, ptr %Size8, i32 0, i32 1
  %5 = load float, ptr %y9, align 4
  %add10 = fadd float %4, %5
  call void @_ZN6ImRectC2Effff(ptr noundef nonnull align 4 dereferenceable(16) %retval, float noundef %0, float noundef %1, float noundef %add, float noundef %add10)
  %6 = load { <2 x float>, <2 x float> }, ptr %retval, align 4
  ret { <2 x float>, <2 x float> } %6
}

declare void @_ZN5ImGui14PushOverrideIDEj(i32 noundef) #1

; Function Attrs: mustprogress nounwind uwtable
define internal noundef float @_ZL5ImMinIfET_S0_S0_(float noundef %lhs, float noundef %rhs) #3 {
entry:
  %lhs.addr = alloca float, align 4
  %rhs.addr = alloca float, align 4
  store float %lhs, ptr %lhs.addr, align 4
  store float %rhs, ptr %rhs.addr, align 4
  %0 = load float, ptr %lhs.addr, align 4
  %1 = load float, ptr %rhs.addr, align 4
  %cmp = fcmp olt float %0, %1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load float, ptr %lhs.addr, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %3 = load float, ptr %rhs.addr, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi float [ %2, %cond.true ], [ %3, %cond.false ]
  ret float %cond
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN6ImRect8ClipWithERKS_(ptr noundef nonnull align 4 dereferenceable(16) %this, ptr noundef nonnull align 4 dereferenceable(16) %r) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %r.addr = alloca ptr, align 8
  %ref.tmp = alloca %struct.ImVec2, align 4
  %ref.tmp4 = alloca %struct.ImVec2, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %r, ptr %r.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Min = getelementptr inbounds %struct.ImRect, ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %r.addr, align 8
  %Min2 = getelementptr inbounds %struct.ImRect, ptr %0, i32 0, i32 0
  %call = call <2 x float> @_ZL5ImMaxRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %Min, ptr noundef nonnull align 4 dereferenceable(8) %Min2)
  store <2 x float> %call, ptr %ref.tmp, align 4
  %Min3 = getelementptr inbounds %struct.ImRect, ptr %this1, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %Min3, ptr align 4 %ref.tmp, i64 8, i1 false)
  %Max = getelementptr inbounds %struct.ImRect, ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %r.addr, align 8
  %Max5 = getelementptr inbounds %struct.ImRect, ptr %1, i32 0, i32 1
  %call6 = call <2 x float> @_ZL5ImMinRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %Max, ptr noundef nonnull align 4 dereferenceable(8) %Max5)
  store <2 x float> %call6, ptr %ref.tmp4, align 4
  %Max7 = getelementptr inbounds %struct.ImRect, ptr %this1, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %Max7, ptr align 4 %ref.tmp4, i64 8, i1 false)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN6ImRect12ClipWithFullERKS_(ptr noundef nonnull align 4 dereferenceable(16) %this, ptr noundef nonnull align 4 dereferenceable(16) %r) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %r.addr = alloca ptr, align 8
  %ref.tmp = alloca %struct.ImVec2, align 4
  %agg.tmp = alloca %struct.ImVec2, align 4
  %ref.tmp4 = alloca %struct.ImVec2, align 4
  %agg.tmp7 = alloca %struct.ImVec2, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %r, ptr %r.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Min = getelementptr inbounds %struct.ImRect, ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %r.addr, align 8
  %Min2 = getelementptr inbounds %struct.ImRect, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %r.addr, align 8
  %Max = getelementptr inbounds %struct.ImRect, ptr %1, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp, ptr align 4 %Max, i64 8, i1 false)
  %2 = load <2 x float>, ptr %agg.tmp, align 4
  %call = call <2 x float> @_ZL7ImClampRK6ImVec2S1_S_(ptr noundef nonnull align 4 dereferenceable(8) %Min, ptr noundef nonnull align 4 dereferenceable(8) %Min2, <2 x float> %2)
  store <2 x float> %call, ptr %ref.tmp, align 4
  %Min3 = getelementptr inbounds %struct.ImRect, ptr %this1, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %Min3, ptr align 4 %ref.tmp, i64 8, i1 false)
  %Max5 = getelementptr inbounds %struct.ImRect, ptr %this1, i32 0, i32 1
  %3 = load ptr, ptr %r.addr, align 8
  %Min6 = getelementptr inbounds %struct.ImRect, ptr %3, i32 0, i32 0
  %4 = load ptr, ptr %r.addr, align 8
  %Max8 = getelementptr inbounds %struct.ImRect, ptr %4, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp7, ptr align 4 %Max8, i64 8, i1 false)
  %5 = load <2 x float>, ptr %agg.tmp7, align 4
  %call9 = call <2 x float> @_ZL7ImClampRK6ImVec2S1_S_(ptr noundef nonnull align 4 dereferenceable(8) %Max5, ptr noundef nonnull align 4 dereferenceable(8) %Min6, <2 x float> %5)
  store <2 x float> %call9, ptr %ref.tmp4, align 4
  %Max10 = getelementptr inbounds %struct.ImRect, ptr %this1, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %Max10, ptr align 4 %ref.tmp4, i64 8, i1 false)
  ret void
}

declare noundef i32 @_ZN5ImGui11GetColorU32Eif(i32 noundef, float noundef) #1

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorIfE6resizeEiRKf(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_size, ptr noundef nonnull align 4 dereferenceable(4) %v) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_size.addr = alloca i32, align 4
  %v.addr = alloca ptr, align 8
  %n = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_size, ptr %new_size.addr, align 4
  store ptr %v, ptr %v.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_size.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.19, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sgt i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %new_size.addr, align 4
  %call = call noundef i32 @_ZNK8ImVectorIfE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %2)
  call void @_ZN8ImVectorIfE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %call)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32, ptr %new_size.addr, align 4
  %Size = getelementptr inbounds %struct.ImVector.19, ptr %this1, i32 0, i32 0
  %4 = load i32, ptr %Size, align 8
  %cmp2 = icmp sgt i32 %3, %4
  br i1 %cmp2, label %if.then3, label %if.end6

if.then3:                                         ; preds = %if.end
  %Size4 = getelementptr inbounds %struct.ImVector.19, ptr %this1, i32 0, i32 0
  %5 = load i32, ptr %Size4, align 8
  store i32 %5, ptr %n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then3
  %6 = load i32, ptr %n, align 4
  %7 = load i32, ptr %new_size.addr, align 4
  %cmp5 = icmp slt i32 %6, %7
  br i1 %cmp5, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %Data = getelementptr inbounds %struct.ImVector.19, ptr %this1, i32 0, i32 2
  %8 = load ptr, ptr %Data, align 8
  %9 = load i32, ptr %n, align 4
  %idxprom = sext i32 %9 to i64
  %arrayidx = getelementptr inbounds float, ptr %8, i64 %idxprom
  %10 = load ptr, ptr %v.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx, ptr align 4 %10, i64 4, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %11 = load i32, ptr %n, align 4
  %inc = add nsw i32 %11, 1
  store i32 %inc, ptr %n, align 4
  br label %for.cond, !llvm.loop !8

for.end:                                          ; preds = %for.cond
  br label %if.end6

if.end6:                                          ; preds = %for.end, %if.end
  %12 = load i32, ptr %new_size.addr, align 4
  %Size7 = getelementptr inbounds %struct.ImVector.19, ptr %this1, i32 0, i32 0
  store i32 %12, ptr %Size7, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef nonnull align 4 dereferenceable(4) ptr @_ZN8ImVectorIfEixEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %i) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.19, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds float, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i32 @_ZNK6ImSpanI16ImGuiTableColumnE4sizeEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %DataEnd = getelementptr inbounds %struct.ImSpan, ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %DataEnd, align 8
  %Data = getelementptr inbounds %struct.ImSpan, ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %Data, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 112
  %conv = trunc i64 %sub.ptr.div to i32
  ret i32 %conv
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui20TableBeginInitMemoryEP10ImGuiTablei(ptr noundef %table, i32 noundef %columns_count) #0 {
entry:
  %table.addr = alloca ptr, align 8
  %columns_count.addr = alloca i32, align 4
  %columns_bit_array_size = alloca i32, align 4
  %span_allocator = alloca %struct.ImSpanAllocator, align 8
  %n = alloca i32, align 4
  store ptr %table, ptr %table.addr, align 8
  store i32 %columns_count, ptr %columns_count.addr, align 4
  %0 = load i32, ptr %columns_count.addr, align 4
  %call = call noundef i64 @_Z31ImBitArrayGetStorageSizeInBytesi(i32 noundef %0)
  %conv = trunc i64 %call to i32
  store i32 %conv, ptr %columns_bit_array_size, align 4
  call void @_ZN15ImSpanAllocatorILi6EEC2Ev(ptr noundef nonnull align 8 dereferenceable(64) %span_allocator)
  %1 = load i32, ptr %columns_count.addr, align 4
  %conv1 = sext i32 %1 to i64
  %mul = mul i64 %conv1, 112
  call void @_ZN15ImSpanAllocatorILi6EE7ReserveEimi(ptr noundef nonnull align 8 dereferenceable(64) %span_allocator, i32 noundef 0, i64 noundef %mul, i32 noundef 4)
  %2 = load i32, ptr %columns_count.addr, align 4
  %conv2 = sext i32 %2 to i64
  %mul3 = mul i64 %conv2, 2
  call void @_ZN15ImSpanAllocatorILi6EE7ReserveEimi(ptr noundef nonnull align 8 dereferenceable(64) %span_allocator, i32 noundef 1, i64 noundef %mul3, i32 noundef 4)
  %3 = load i32, ptr %columns_count.addr, align 4
  %conv4 = sext i32 %3 to i64
  %mul5 = mul i64 %conv4, 8
  call void @_ZN15ImSpanAllocatorILi6EE7ReserveEimi(ptr noundef nonnull align 8 dereferenceable(64) %span_allocator, i32 noundef 2, i64 noundef %mul5, i32 noundef 4)
  store i32 3, ptr %n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %4 = load i32, ptr %n, align 4
  %cmp = icmp slt i32 %4, 6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load i32, ptr %n, align 4
  %6 = load i32, ptr %columns_bit_array_size, align 4
  %conv6 = sext i32 %6 to i64
  call void @_ZN15ImSpanAllocatorILi6EE7ReserveEimi(ptr noundef nonnull align 8 dereferenceable(64) %span_allocator, i32 noundef %5, i64 noundef %conv6, i32 noundef 4)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %7 = load i32, ptr %n, align 4
  %inc = add nsw i32 %7, 1
  store i32 %inc, ptr %n, align 4
  br label %for.cond, !llvm.loop !9

for.end:                                          ; preds = %for.cond
  %call7 = call noundef i32 @_ZN15ImSpanAllocatorILi6EE19GetArenaSizeInBytesEv(ptr noundef nonnull align 8 dereferenceable(64) %span_allocator)
  %conv8 = sext i32 %call7 to i64
  %call9 = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef %conv8)
  %8 = load ptr, ptr %table.addr, align 8
  %RawData = getelementptr inbounds %struct.ImGuiTable, ptr %8, i32 0, i32 2
  store ptr %call9, ptr %RawData, align 8
  %9 = load ptr, ptr %table.addr, align 8
  %RawData10 = getelementptr inbounds %struct.ImGuiTable, ptr %9, i32 0, i32 2
  %10 = load ptr, ptr %RawData10, align 8
  %call11 = call noundef i32 @_ZN15ImSpanAllocatorILi6EE19GetArenaSizeInBytesEv(ptr noundef nonnull align 8 dereferenceable(64) %span_allocator)
  %conv12 = sext i32 %call11 to i64
  call void @llvm.memset.p0.i64(ptr align 1 %10, i8 0, i64 %conv12, i1 false)
  %11 = load ptr, ptr %table.addr, align 8
  %RawData13 = getelementptr inbounds %struct.ImGuiTable, ptr %11, i32 0, i32 2
  %12 = load ptr, ptr %RawData13, align 8
  call void @_ZN15ImSpanAllocatorILi6EE15SetArenaBasePtrEPv(ptr noundef nonnull align 8 dereferenceable(64) %span_allocator, ptr noundef %12)
  %13 = load ptr, ptr %table.addr, align 8
  %Columns = getelementptr inbounds %struct.ImGuiTable, ptr %13, i32 0, i32 4
  call void @_ZN15ImSpanAllocatorILi6EE7GetSpanI16ImGuiTableColumnEEviP6ImSpanIT_E(ptr noundef nonnull align 8 dereferenceable(64) %span_allocator, i32 noundef 0, ptr noundef %Columns)
  %14 = load ptr, ptr %table.addr, align 8
  %DisplayOrderToIndex = getelementptr inbounds %struct.ImGuiTable, ptr %14, i32 0, i32 5
  call void @_ZN15ImSpanAllocatorILi6EE7GetSpanIsEEviP6ImSpanIT_E(ptr noundef nonnull align 8 dereferenceable(64) %span_allocator, i32 noundef 1, ptr noundef %DisplayOrderToIndex)
  %15 = load ptr, ptr %table.addr, align 8
  %RowCellData = getelementptr inbounds %struct.ImGuiTable, ptr %15, i32 0, i32 6
  call void @_ZN15ImSpanAllocatorILi6EE7GetSpanI18ImGuiTableCellDataEEviP6ImSpanIT_E(ptr noundef nonnull align 8 dereferenceable(64) %span_allocator, i32 noundef 2, ptr noundef %RowCellData)
  %call14 = call noundef ptr @_ZN15ImSpanAllocatorILi6EE15GetSpanPtrBeginEi(ptr noundef nonnull align 8 dereferenceable(64) %span_allocator, i32 noundef 3)
  %16 = load ptr, ptr %table.addr, align 8
  %EnabledMaskByDisplayOrder = getelementptr inbounds %struct.ImGuiTable, ptr %16, i32 0, i32 7
  store ptr %call14, ptr %EnabledMaskByDisplayOrder, align 8
  %call15 = call noundef ptr @_ZN15ImSpanAllocatorILi6EE15GetSpanPtrBeginEi(ptr noundef nonnull align 8 dereferenceable(64) %span_allocator, i32 noundef 4)
  %17 = load ptr, ptr %table.addr, align 8
  %EnabledMaskByIndex = getelementptr inbounds %struct.ImGuiTable, ptr %17, i32 0, i32 8
  store ptr %call15, ptr %EnabledMaskByIndex, align 8
  %call16 = call noundef ptr @_ZN15ImSpanAllocatorILi6EE15GetSpanPtrBeginEi(ptr noundef nonnull align 8 dereferenceable(64) %span_allocator, i32 noundef 5)
  %18 = load ptr, ptr %table.addr, align 8
  %VisibleMaskByIndex = getelementptr inbounds %struct.ImGuiTable, ptr %18, i32 0, i32 9
  store ptr %call16, ptr %VisibleMaskByIndex, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define void @_ZN5ImGui18TableResetSettingsEP10ImGuiTable(ptr noundef %table) #3 {
entry:
  %table.addr = alloca ptr, align 8
  store ptr %table, ptr %table.addr, align 8
  %0 = load ptr, ptr %table.addr, align 8
  %IsSettingsDirty = getelementptr inbounds %struct.ImGuiTable, ptr %0, i32 0, i32 100
  store i8 1, ptr %IsSettingsDirty, align 2
  %1 = load ptr, ptr %table.addr, align 8
  %IsInitializing = getelementptr inbounds %struct.ImGuiTable, ptr %1, i32 0, i32 94
  store i8 1, ptr %IsInitializing, align 8
  %2 = load ptr, ptr %table.addr, align 8
  %IsResetAllRequest = getelementptr inbounds %struct.ImGuiTable, ptr %2, i32 0, i32 102
  store i8 0, ptr %IsResetAllRequest, align 8
  %3 = load ptr, ptr %table.addr, align 8
  %IsSettingsRequestLoad = getelementptr inbounds %struct.ImGuiTable, ptr %3, i32 0, i32 99
  store i8 0, ptr %IsSettingsRequestLoad, align 1
  %4 = load ptr, ptr %table.addr, align 8
  %SettingsLoadedFlags = getelementptr inbounds %struct.ImGuiTable, ptr %4, i32 0, i32 10
  store i32 0, ptr %SettingsLoadedFlags, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %i) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %p = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImSpan, ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %Data, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr inbounds %struct.ImGuiTableColumn, ptr %0, i64 %idx.ext
  store ptr %add.ptr, ptr %p, align 8
  %2 = load ptr, ptr %p, align 8
  ret ptr %2
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN16ImGuiTableColumnC2Ev(ptr noundef nonnull align 4 dereferenceable(111) %this) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %ClipRect = getelementptr inbounds %struct.ImGuiTableColumn, ptr %this1, i32 0, i32 8
  call void @_ZN6ImRectC2Ev(ptr noundef nonnull align 4 dereferenceable(16) %ClipRect)
  call void @llvm.memset.p0.i64(ptr align 4 %this1, i8 0, i64 112, i1 false)
  %WidthRequest = getelementptr inbounds %struct.ImGuiTableColumn, ptr %this1, i32 0, i32 4
  store float -1.000000e+00, ptr %WidthRequest, align 4
  %StretchWeight = getelementptr inbounds %struct.ImGuiTableColumn, ptr %this1, i32 0, i32 6
  store float -1.000000e+00, ptr %StretchWeight, align 4
  %NameOffset = getelementptr inbounds %struct.ImGuiTableColumn, ptr %this1, i32 0, i32 17
  store i16 -1, ptr %NameOffset, align 4
  %IndexWithinEnabledSet = getelementptr inbounds %struct.ImGuiTableColumn, ptr %this1, i32 0, i32 19
  store i16 -1, ptr %IndexWithinEnabledSet, align 4
  %DisplayOrder = getelementptr inbounds %struct.ImGuiTableColumn, ptr %this1, i32 0, i32 18
  store i16 -1, ptr %DisplayOrder, align 2
  %NextEnabledColumn = getelementptr inbounds %struct.ImGuiTableColumn, ptr %this1, i32 0, i32 21
  store i16 -1, ptr %NextEnabledColumn, align 4
  %PrevEnabledColumn = getelementptr inbounds %struct.ImGuiTableColumn, ptr %this1, i32 0, i32 20
  store i16 -1, ptr %PrevEnabledColumn, align 2
  %SortOrder = getelementptr inbounds %struct.ImGuiTableColumn, ptr %this1, i32 0, i32 22
  store i16 -1, ptr %SortOrder, align 2
  %SortDirection = getelementptr inbounds %struct.ImGuiTableColumn, ptr %this1, i32 0, i32 37
  %bf.load = load i8, ptr %SortDirection, align 1
  %bf.clear = and i8 %bf.load, -4
  %bf.set = or i8 %bf.clear, 0
  store i8 %bf.set, ptr %SortDirection, align 1
  %DrawChannelUnfrozen = getelementptr inbounds %struct.ImGuiTableColumn, ptr %this1, i32 0, i32 25
  store i16 255, ptr %DrawChannelUnfrozen, align 4
  %DrawChannelFrozen = getelementptr inbounds %struct.ImGuiTableColumn, ptr %this1, i32 0, i32 24
  store i16 255, ptr %DrawChannelFrozen, align 2
  %DrawChannelCurrent = getelementptr inbounds %struct.ImGuiTableColumn, ptr %this1, i32 0, i32 23
  store i16 255, ptr %DrawChannelCurrent, align 4
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef nonnull align 2 dereferenceable(2) ptr @_ZN6ImSpanIsEixEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %i) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %p = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImSpan.36, ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %Data, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr inbounds i16, ptr %0, i64 %idx.ext
  store ptr %add.ptr, ptr %p, align 8
  %2 = load ptr, ptr %p, align 8
  ret ptr %2
}

declare void @_ZN5ImGui7MemFreeEPv(ptr noundef) #1

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui17TableLoadSettingsEP10ImGuiTable(ptr noundef %table) #0 {
entry:
  %table.addr = alloca ptr, align 8
  %g = alloca ptr, align 8
  %settings = alloca ptr, align 8
  %column_settings = alloca ptr, align 8
  %display_order_mask = alloca i64, align 8
  %data_n = alloca i32, align 4
  %column_n = alloca i32, align 4
  %column = alloca ptr, align 8
  %expected_display_order_mask = alloca i64, align 8
  %column_n66 = alloca i32, align 4
  %column_n79 = alloca i32, align 4
  store ptr %table, ptr %table.addr, align 8
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %table.addr, align 8
  %IsSettingsRequestLoad = getelementptr inbounds %struct.ImGuiTable, ptr %1, i32 0, i32 99
  store i8 0, ptr %IsSettingsRequestLoad, align 1
  %2 = load ptr, ptr %table.addr, align 8
  %Flags = getelementptr inbounds %struct.ImGuiTable, ptr %2, i32 0, i32 1
  %3 = load i32, ptr %Flags, align 4
  %and = and i32 %3, 16
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %for.end92

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %table.addr, align 8
  %SettingsOffset = getelementptr inbounds %struct.ImGuiTable, ptr %4, i32 0, i32 11
  %5 = load i32, ptr %SettingsOffset, align 4
  %cmp = icmp eq i32 %5, -1
  br i1 %cmp, label %if.then1, label %if.else

if.then1:                                         ; preds = %if.end
  %6 = load ptr, ptr %table.addr, align 8
  %ID = getelementptr inbounds %struct.ImGuiTable, ptr %6, i32 0, i32 0
  %7 = load i32, ptr %ID, align 8
  %call = call noundef ptr @_ZN5ImGui21TableSettingsFindByIDEj(i32 noundef %7)
  store ptr %call, ptr %settings, align 8
  %8 = load ptr, ptr %settings, align 8
  %cmp2 = icmp eq ptr %8, null
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.then1
  br label %for.end92

if.end4:                                          ; preds = %if.then1
  %9 = load ptr, ptr %settings, align 8
  %ColumnsCount = getelementptr inbounds %struct.ImGuiTableSettings, ptr %9, i32 0, i32 3
  %10 = load i16, ptr %ColumnsCount, align 4
  %conv = sext i16 %10 to i32
  %11 = load ptr, ptr %table.addr, align 8
  %ColumnsCount5 = getelementptr inbounds %struct.ImGuiTable, ptr %11, i32 0, i32 13
  %12 = load i32, ptr %ColumnsCount5, align 4
  %cmp6 = icmp ne i32 %conv, %12
  br i1 %cmp6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end4
  %13 = load ptr, ptr %table.addr, align 8
  %IsSettingsDirty = getelementptr inbounds %struct.ImGuiTable, ptr %13, i32 0, i32 100
  store i8 1, ptr %IsSettingsDirty, align 2
  br label %if.end8

if.end8:                                          ; preds = %if.then7, %if.end4
  %14 = load ptr, ptr %g, align 8
  %SettingsTables = getelementptr inbounds %struct.ImGuiContext, ptr %14, i32 0, i32 218
  %15 = load ptr, ptr %settings, align 8
  %call9 = call noundef i32 @_ZN13ImChunkStreamI18ImGuiTableSettingsE15offset_from_ptrEPKS0_(ptr noundef nonnull align 8 dereferenceable(16) %SettingsTables, ptr noundef %15)
  %16 = load ptr, ptr %table.addr, align 8
  %SettingsOffset10 = getelementptr inbounds %struct.ImGuiTable, ptr %16, i32 0, i32 11
  store i32 %call9, ptr %SettingsOffset10, align 4
  br label %if.end12

if.else:                                          ; preds = %if.end
  %17 = load ptr, ptr %table.addr, align 8
  %call11 = call noundef ptr @_ZN5ImGui21TableGetBoundSettingsEP10ImGuiTable(ptr noundef %17)
  store ptr %call11, ptr %settings, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.else, %if.end8
  %18 = load ptr, ptr %settings, align 8
  %SaveFlags = getelementptr inbounds %struct.ImGuiTableSettings, ptr %18, i32 0, i32 1
  %19 = load i32, ptr %SaveFlags, align 4
  %20 = load ptr, ptr %table.addr, align 8
  %SettingsLoadedFlags = getelementptr inbounds %struct.ImGuiTable, ptr %20, i32 0, i32 10
  store i32 %19, ptr %SettingsLoadedFlags, align 8
  %21 = load ptr, ptr %settings, align 8
  %RefScale = getelementptr inbounds %struct.ImGuiTableSettings, ptr %21, i32 0, i32 2
  %22 = load float, ptr %RefScale, align 4
  %23 = load ptr, ptr %table.addr, align 8
  %RefScale13 = getelementptr inbounds %struct.ImGuiTable, ptr %23, i32 0, i32 43
  store float %22, ptr %RefScale13, align 4
  %24 = load ptr, ptr %settings, align 8
  %call14 = call noundef ptr @_ZN18ImGuiTableSettings17GetColumnSettingsEv(ptr noundef nonnull align 4 dereferenceable(17) %24)
  store ptr %call14, ptr %column_settings, align 8
  store i64 0, ptr %display_order_mask, align 8
  store i32 0, ptr %data_n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end12
  %25 = load i32, ptr %data_n, align 4
  %26 = load ptr, ptr %settings, align 8
  %ColumnsCount15 = getelementptr inbounds %struct.ImGuiTableSettings, ptr %26, i32 0, i32 3
  %27 = load i16, ptr %ColumnsCount15, align 4
  %conv16 = sext i16 %27 to i32
  %cmp17 = icmp slt i32 %25, %conv16
  br i1 %cmp17, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %28 = load ptr, ptr %column_settings, align 8
  %Index = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %28, i32 0, i32 2
  %29 = load i16, ptr %Index, align 4
  %conv18 = sext i16 %29 to i32
  store i32 %conv18, ptr %column_n, align 4
  %30 = load i32, ptr %column_n, align 4
  %cmp19 = icmp slt i32 %30, 0
  br i1 %cmp19, label %if.then22, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %31 = load i32, ptr %column_n, align 4
  %32 = load ptr, ptr %table.addr, align 8
  %ColumnsCount20 = getelementptr inbounds %struct.ImGuiTable, ptr %32, i32 0, i32 13
  %33 = load i32, ptr %ColumnsCount20, align 4
  %cmp21 = icmp sge i32 %31, %33
  br i1 %cmp21, label %if.then22, label %if.end23

if.then22:                                        ; preds = %lor.lhs.false, %for.body
  br label %for.inc

if.end23:                                         ; preds = %lor.lhs.false
  %34 = load ptr, ptr %table.addr, align 8
  %Columns = getelementptr inbounds %struct.ImGuiTable, ptr %34, i32 0, i32 4
  %35 = load i32, ptr %column_n, align 4
  %call24 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns, i32 noundef %35)
  store ptr %call24, ptr %column, align 8
  %36 = load ptr, ptr %settings, align 8
  %SaveFlags25 = getelementptr inbounds %struct.ImGuiTableSettings, ptr %36, i32 0, i32 1
  %37 = load i32, ptr %SaveFlags25, align 4
  %and26 = and i32 %37, 1
  %tobool27 = icmp ne i32 %and26, 0
  br i1 %tobool27, label %if.then28, label %if.end34

if.then28:                                        ; preds = %if.end23
  %38 = load ptr, ptr %column_settings, align 8
  %IsStretch = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %38, i32 0, i32 5
  %bf.load = load i8, ptr %IsStretch, align 2
  %bf.lshr = lshr i8 %bf.load, 3
  %bf.clear = and i8 %bf.lshr, 1
  %tobool29 = icmp ne i8 %bf.clear, 0
  br i1 %tobool29, label %if.then30, label %if.else31

if.then30:                                        ; preds = %if.then28
  %39 = load ptr, ptr %column_settings, align 8
  %WidthOrWeight = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %39, i32 0, i32 0
  %40 = load float, ptr %WidthOrWeight, align 4
  %41 = load ptr, ptr %column, align 8
  %StretchWeight = getelementptr inbounds %struct.ImGuiTableColumn, ptr %41, i32 0, i32 6
  store float %40, ptr %StretchWeight, align 4
  br label %if.end33

if.else31:                                        ; preds = %if.then28
  %42 = load ptr, ptr %column_settings, align 8
  %WidthOrWeight32 = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %42, i32 0, i32 0
  %43 = load float, ptr %WidthOrWeight32, align 4
  %44 = load ptr, ptr %column, align 8
  %WidthRequest = getelementptr inbounds %struct.ImGuiTableColumn, ptr %44, i32 0, i32 4
  store float %43, ptr %WidthRequest, align 4
  br label %if.end33

if.end33:                                         ; preds = %if.else31, %if.then30
  %45 = load ptr, ptr %column, align 8
  %AutoFitQueue = getelementptr inbounds %struct.ImGuiTableColumn, ptr %45, i32 0, i32 35
  store i8 0, ptr %AutoFitQueue, align 1
  br label %if.end34

if.end34:                                         ; preds = %if.end33, %if.end23
  %46 = load ptr, ptr %settings, align 8
  %SaveFlags35 = getelementptr inbounds %struct.ImGuiTableSettings, ptr %46, i32 0, i32 1
  %47 = load i32, ptr %SaveFlags35, align 4
  %and36 = and i32 %47, 2
  %tobool37 = icmp ne i32 %and36, 0
  br i1 %tobool37, label %if.then38, label %if.else40

if.then38:                                        ; preds = %if.end34
  %48 = load ptr, ptr %column_settings, align 8
  %DisplayOrder = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %48, i32 0, i32 3
  %49 = load i16, ptr %DisplayOrder, align 2
  %50 = load ptr, ptr %column, align 8
  %DisplayOrder39 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %50, i32 0, i32 18
  store i16 %49, ptr %DisplayOrder39, align 2
  br label %if.end43

if.else40:                                        ; preds = %if.end34
  %51 = load i32, ptr %column_n, align 4
  %conv41 = trunc i32 %51 to i16
  %52 = load ptr, ptr %column, align 8
  %DisplayOrder42 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %52, i32 0, i32 18
  store i16 %conv41, ptr %DisplayOrder42, align 2
  br label %if.end43

if.end43:                                         ; preds = %if.else40, %if.then38
  %53 = load ptr, ptr %column, align 8
  %DisplayOrder44 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %53, i32 0, i32 18
  %54 = load i16, ptr %DisplayOrder44, align 2
  %conv45 = sext i16 %54 to i32
  %sh_prom = zext i32 %conv45 to i64
  %shl = shl i64 1, %sh_prom
  %55 = load i64, ptr %display_order_mask, align 8
  %or = or i64 %55, %shl
  store i64 %or, ptr %display_order_mask, align 8
  %56 = load ptr, ptr %column_settings, align 8
  %IsEnabled = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %56, i32 0, i32 5
  %bf.load46 = load i8, ptr %IsEnabled, align 2
  %bf.lshr47 = lshr i8 %bf.load46, 2
  %bf.clear48 = and i8 %bf.lshr47, 1
  %tobool49 = icmp ne i8 %bf.clear48, 0
  %57 = load ptr, ptr %column, align 8
  %IsUserEnabledNextFrame = getelementptr inbounds %struct.ImGuiTableColumn, ptr %57, i32 0, i32 28
  %frombool = zext i1 %tobool49 to i8
  store i8 %frombool, ptr %IsUserEnabledNextFrame, align 4
  %58 = load ptr, ptr %column, align 8
  %IsUserEnabled = getelementptr inbounds %struct.ImGuiTableColumn, ptr %58, i32 0, i32 27
  %frombool50 = zext i1 %tobool49 to i8
  store i8 %frombool50, ptr %IsUserEnabled, align 1
  %59 = load ptr, ptr %column_settings, align 8
  %SortOrder = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %59, i32 0, i32 4
  %60 = load i16, ptr %SortOrder, align 4
  %61 = load ptr, ptr %column, align 8
  %SortOrder51 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %61, i32 0, i32 22
  store i16 %60, ptr %SortOrder51, align 2
  %62 = load ptr, ptr %column_settings, align 8
  %SortDirection = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %62, i32 0, i32 5
  %bf.load52 = load i8, ptr %SortDirection, align 2
  %bf.clear53 = and i8 %bf.load52, 3
  %63 = load ptr, ptr %column, align 8
  %SortDirection54 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %63, i32 0, i32 37
  %bf.load55 = load i8, ptr %SortDirection54, align 1
  %bf.value = and i8 %bf.clear53, 3
  %bf.clear56 = and i8 %bf.load55, -4
  %bf.set = or i8 %bf.clear56, %bf.value
  store i8 %bf.set, ptr %SortDirection54, align 1
  br label %for.inc

for.inc:                                          ; preds = %if.end43, %if.then22
  %64 = load i32, ptr %data_n, align 4
  %inc = add nsw i32 %64, 1
  store i32 %inc, ptr %data_n, align 4
  %65 = load ptr, ptr %column_settings, align 8
  %incdec.ptr = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %65, i32 1
  store ptr %incdec.ptr, ptr %column_settings, align 8
  br label %for.cond, !llvm.loop !10

for.end:                                          ; preds = %for.cond
  %66 = load ptr, ptr %settings, align 8
  %ColumnsCount57 = getelementptr inbounds %struct.ImGuiTableSettings, ptr %66, i32 0, i32 3
  %67 = load i16, ptr %ColumnsCount57, align 4
  %conv58 = sext i16 %67 to i32
  %cmp59 = icmp eq i32 %conv58, 64
  br i1 %cmp59, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.end
  br label %cond.end

cond.false:                                       ; preds = %for.end
  %68 = load ptr, ptr %settings, align 8
  %ColumnsCount60 = getelementptr inbounds %struct.ImGuiTableSettings, ptr %68, i32 0, i32 3
  %69 = load i16, ptr %ColumnsCount60, align 4
  %conv61 = sext i16 %69 to i32
  %sh_prom62 = zext i32 %conv61 to i64
  %shl63 = shl i64 1, %sh_prom62
  %sub = sub i64 %shl63, 1
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ -1, %cond.true ], [ %sub, %cond.false ]
  store i64 %cond, ptr %expected_display_order_mask, align 8
  %70 = load i64, ptr %display_order_mask, align 8
  %71 = load i64, ptr %expected_display_order_mask, align 8
  %cmp64 = icmp ne i64 %70, %71
  br i1 %cmp64, label %if.then65, label %if.end78

if.then65:                                        ; preds = %cond.end
  store i32 0, ptr %column_n66, align 4
  br label %for.cond67

for.cond67:                                       ; preds = %for.inc75, %if.then65
  %72 = load i32, ptr %column_n66, align 4
  %73 = load ptr, ptr %table.addr, align 8
  %ColumnsCount68 = getelementptr inbounds %struct.ImGuiTable, ptr %73, i32 0, i32 13
  %74 = load i32, ptr %ColumnsCount68, align 4
  %cmp69 = icmp slt i32 %72, %74
  br i1 %cmp69, label %for.body70, label %for.end77

for.body70:                                       ; preds = %for.cond67
  %75 = load i32, ptr %column_n66, align 4
  %conv71 = trunc i32 %75 to i16
  %76 = load ptr, ptr %table.addr, align 8
  %Columns72 = getelementptr inbounds %struct.ImGuiTable, ptr %76, i32 0, i32 4
  %77 = load i32, ptr %column_n66, align 4
  %call73 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns72, i32 noundef %77)
  %DisplayOrder74 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %call73, i32 0, i32 18
  store i16 %conv71, ptr %DisplayOrder74, align 2
  br label %for.inc75

for.inc75:                                        ; preds = %for.body70
  %78 = load i32, ptr %column_n66, align 4
  %inc76 = add nsw i32 %78, 1
  store i32 %inc76, ptr %column_n66, align 4
  br label %for.cond67, !llvm.loop !11

for.end77:                                        ; preds = %for.cond67
  br label %if.end78

if.end78:                                         ; preds = %for.end77, %cond.end
  store i32 0, ptr %column_n79, align 4
  br label %for.cond80

for.cond80:                                       ; preds = %for.inc90, %if.end78
  %79 = load i32, ptr %column_n79, align 4
  %80 = load ptr, ptr %table.addr, align 8
  %ColumnsCount81 = getelementptr inbounds %struct.ImGuiTable, ptr %80, i32 0, i32 13
  %81 = load i32, ptr %ColumnsCount81, align 4
  %cmp82 = icmp slt i32 %79, %81
  br i1 %cmp82, label %for.body83, label %for.end92

for.body83:                                       ; preds = %for.cond80
  %82 = load i32, ptr %column_n79, align 4
  %conv84 = trunc i32 %82 to i16
  %83 = load ptr, ptr %table.addr, align 8
  %DisplayOrderToIndex = getelementptr inbounds %struct.ImGuiTable, ptr %83, i32 0, i32 5
  %84 = load ptr, ptr %table.addr, align 8
  %Columns85 = getelementptr inbounds %struct.ImGuiTable, ptr %84, i32 0, i32 4
  %85 = load i32, ptr %column_n79, align 4
  %call86 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns85, i32 noundef %85)
  %DisplayOrder87 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %call86, i32 0, i32 18
  %86 = load i16, ptr %DisplayOrder87, align 2
  %conv88 = sext i16 %86 to i32
  %call89 = call noundef nonnull align 2 dereferenceable(2) ptr @_ZN6ImSpanIsEixEi(ptr noundef nonnull align 8 dereferenceable(16) %DisplayOrderToIndex, i32 noundef %conv88)
  store i16 %conv84, ptr %call89, align 2
  br label %for.inc90

for.inc90:                                        ; preds = %for.body83
  %87 = load i32, ptr %column_n79, align 4
  %inc91 = add nsw i32 %87, 1
  store i32 %inc91, ptr %column_n79, align 4
  br label %for.cond80, !llvm.loop !12

for.end92:                                        ; preds = %for.cond80, %if.then3, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorIcE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_size) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_size.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_size, ptr %new_size.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_size.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.25, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sgt i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %new_size.addr, align 4
  %call = call noundef i32 @_ZNK8ImVectorIcE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %2)
  call void @_ZN8ImVectorIcE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %call)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32, ptr %new_size.addr, align 4
  %Size = getelementptr inbounds %struct.ImVector.25, ptr %this1, i32 0, i32 0
  store i32 %3, ptr %Size, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui23TableBeginApplyRequestsEP10ImGuiTable(ptr noundef %table) #0 {
entry:
  %table.addr = alloca ptr, align 8
  %reorder_dir = alloca i32, align 4
  %src_column = alloca ptr, align 8
  %dst_column = alloca ptr, align 8
  %src_order = alloca i32, align 4
  %dst_order = alloca i32, align 4
  %order_n = alloca i32, align 4
  %column_n = alloca i32, align 4
  %n = alloca i32, align 4
  store ptr %table, ptr %table.addr, align 8
  %0 = load ptr, ptr %table.addr, align 8
  %InstanceCurrent = getelementptr inbounds %struct.ImGuiTable, ptr %0, i32 0, i32 16
  %1 = load i16, ptr %InstanceCurrent, align 8
  %conv = sext i16 %1 to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.end20

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %table.addr, align 8
  %ResizedColumn = getelementptr inbounds %struct.ImGuiTable, ptr %2, i32 0, i32 74
  %3 = load i16, ptr %ResizedColumn, align 2
  %conv1 = sext i16 %3 to i32
  %cmp2 = icmp ne i32 %conv1, -1
  br i1 %cmp2, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then
  %4 = load ptr, ptr %table.addr, align 8
  %ResizedColumnNextWidth = getelementptr inbounds %struct.ImGuiTable, ptr %4, i32 0, i32 41
  %5 = load float, ptr %ResizedColumnNextWidth, align 4
  %cmp3 = fcmp une float %5, 0x47EFFFFFE0000000
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %land.lhs.true
  %6 = load ptr, ptr %table.addr, align 8
  %ResizedColumn5 = getelementptr inbounds %struct.ImGuiTable, ptr %6, i32 0, i32 74
  %7 = load i16, ptr %ResizedColumn5, align 2
  %conv6 = sext i16 %7 to i32
  %8 = load ptr, ptr %table.addr, align 8
  %ResizedColumnNextWidth7 = getelementptr inbounds %struct.ImGuiTable, ptr %8, i32 0, i32 41
  %9 = load float, ptr %ResizedColumnNextWidth7, align 4
  call void @_ZN5ImGui19TableSetColumnWidthEif(i32 noundef %conv6, float noundef %9)
  br label %if.end

if.end:                                           ; preds = %if.then4, %land.lhs.true, %if.then
  %10 = load ptr, ptr %table.addr, align 8
  %ResizedColumn8 = getelementptr inbounds %struct.ImGuiTable, ptr %10, i32 0, i32 74
  %11 = load i16, ptr %ResizedColumn8, align 2
  %12 = load ptr, ptr %table.addr, align 8
  %LastResizedColumn = getelementptr inbounds %struct.ImGuiTable, ptr %12, i32 0, i32 75
  store i16 %11, ptr %LastResizedColumn, align 4
  %13 = load ptr, ptr %table.addr, align 8
  %ResizedColumnNextWidth9 = getelementptr inbounds %struct.ImGuiTable, ptr %13, i32 0, i32 41
  store float 0x47EFFFFFE0000000, ptr %ResizedColumnNextWidth9, align 4
  %14 = load ptr, ptr %table.addr, align 8
  %ResizedColumn10 = getelementptr inbounds %struct.ImGuiTable, ptr %14, i32 0, i32 74
  store i16 -1, ptr %ResizedColumn10, align 2
  %15 = load ptr, ptr %table.addr, align 8
  %AutoFitSingleColumn = getelementptr inbounds %struct.ImGuiTable, ptr %15, i32 0, i32 73
  %16 = load i16, ptr %AutoFitSingleColumn, align 8
  %conv11 = sext i16 %16 to i32
  %cmp12 = icmp ne i32 %conv11, -1
  br i1 %cmp12, label %if.then13, label %if.end19

if.then13:                                        ; preds = %if.end
  %17 = load ptr, ptr %table.addr, align 8
  %AutoFitSingleColumn14 = getelementptr inbounds %struct.ImGuiTable, ptr %17, i32 0, i32 73
  %18 = load i16, ptr %AutoFitSingleColumn14, align 8
  %conv15 = sext i16 %18 to i32
  %19 = load ptr, ptr %table.addr, align 8
  %Columns = getelementptr inbounds %struct.ImGuiTable, ptr %19, i32 0, i32 4
  %20 = load ptr, ptr %table.addr, align 8
  %AutoFitSingleColumn16 = getelementptr inbounds %struct.ImGuiTable, ptr %20, i32 0, i32 73
  %21 = load i16, ptr %AutoFitSingleColumn16, align 8
  %conv17 = sext i16 %21 to i32
  %call = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns, i32 noundef %conv17)
  %WidthAuto = getelementptr inbounds %struct.ImGuiTableColumn, ptr %call, i32 0, i32 5
  %22 = load float, ptr %WidthAuto, align 4
  call void @_ZN5ImGui19TableSetColumnWidthEif(i32 noundef %conv15, float noundef %22)
  %23 = load ptr, ptr %table.addr, align 8
  %AutoFitSingleColumn18 = getelementptr inbounds %struct.ImGuiTable, ptr %23, i32 0, i32 73
  store i16 -1, ptr %AutoFitSingleColumn18, align 8
  br label %if.end19

if.end19:                                         ; preds = %if.then13, %if.end
  br label %if.end20

if.end20:                                         ; preds = %if.end19, %entry
  %24 = load ptr, ptr %table.addr, align 8
  %InstanceCurrent21 = getelementptr inbounds %struct.ImGuiTable, ptr %24, i32 0, i32 16
  %25 = load i16, ptr %InstanceCurrent21, align 8
  %conv22 = sext i16 %25 to i32
  %cmp23 = icmp eq i32 %conv22, 0
  br i1 %cmp23, label %if.then24, label %if.end82

if.then24:                                        ; preds = %if.end20
  %26 = load ptr, ptr %table.addr, align 8
  %HeldHeaderColumn = getelementptr inbounds %struct.ImGuiTable, ptr %26, i32 0, i32 76
  %27 = load i16, ptr %HeldHeaderColumn, align 2
  %conv25 = sext i16 %27 to i32
  %cmp26 = icmp eq i32 %conv25, -1
  br i1 %cmp26, label %land.lhs.true27, label %if.end32

land.lhs.true27:                                  ; preds = %if.then24
  %28 = load ptr, ptr %table.addr, align 8
  %ReorderColumn = getelementptr inbounds %struct.ImGuiTable, ptr %28, i32 0, i32 77
  %29 = load i16, ptr %ReorderColumn, align 8
  %conv28 = sext i16 %29 to i32
  %cmp29 = icmp ne i32 %conv28, -1
  br i1 %cmp29, label %if.then30, label %if.end32

if.then30:                                        ; preds = %land.lhs.true27
  %30 = load ptr, ptr %table.addr, align 8
  %ReorderColumn31 = getelementptr inbounds %struct.ImGuiTable, ptr %30, i32 0, i32 77
  store i16 -1, ptr %ReorderColumn31, align 8
  br label %if.end32

if.end32:                                         ; preds = %if.then30, %land.lhs.true27, %if.then24
  %31 = load ptr, ptr %table.addr, align 8
  %HeldHeaderColumn33 = getelementptr inbounds %struct.ImGuiTable, ptr %31, i32 0, i32 76
  store i16 -1, ptr %HeldHeaderColumn33, align 2
  %32 = load ptr, ptr %table.addr, align 8
  %ReorderColumn34 = getelementptr inbounds %struct.ImGuiTable, ptr %32, i32 0, i32 77
  %33 = load i16, ptr %ReorderColumn34, align 8
  %conv35 = sext i16 %33 to i32
  %cmp36 = icmp ne i32 %conv35, -1
  br i1 %cmp36, label %land.lhs.true37, label %if.end81

land.lhs.true37:                                  ; preds = %if.end32
  %34 = load ptr, ptr %table.addr, align 8
  %ReorderColumnDir = getelementptr inbounds %struct.ImGuiTable, ptr %34, i32 0, i32 78
  %35 = load i16, ptr %ReorderColumnDir, align 2
  %conv38 = sext i16 %35 to i32
  %cmp39 = icmp ne i32 %conv38, 0
  br i1 %cmp39, label %if.then40, label %if.end81

if.then40:                                        ; preds = %land.lhs.true37
  %36 = load ptr, ptr %table.addr, align 8
  %ReorderColumnDir41 = getelementptr inbounds %struct.ImGuiTable, ptr %36, i32 0, i32 78
  %37 = load i16, ptr %ReorderColumnDir41, align 2
  %conv42 = sext i16 %37 to i32
  store i32 %conv42, ptr %reorder_dir, align 4
  %38 = load ptr, ptr %table.addr, align 8
  %Columns43 = getelementptr inbounds %struct.ImGuiTable, ptr %38, i32 0, i32 4
  %39 = load ptr, ptr %table.addr, align 8
  %ReorderColumn44 = getelementptr inbounds %struct.ImGuiTable, ptr %39, i32 0, i32 77
  %40 = load i16, ptr %ReorderColumn44, align 8
  %conv45 = sext i16 %40 to i32
  %call46 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns43, i32 noundef %conv45)
  store ptr %call46, ptr %src_column, align 8
  %41 = load ptr, ptr %table.addr, align 8
  %Columns47 = getelementptr inbounds %struct.ImGuiTable, ptr %41, i32 0, i32 4
  %42 = load i32, ptr %reorder_dir, align 4
  %cmp48 = icmp eq i32 %42, -1
  br i1 %cmp48, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then40
  %43 = load ptr, ptr %src_column, align 8
  %PrevEnabledColumn = getelementptr inbounds %struct.ImGuiTableColumn, ptr %43, i32 0, i32 20
  %44 = load i16, ptr %PrevEnabledColumn, align 2
  br label %cond.end

cond.false:                                       ; preds = %if.then40
  %45 = load ptr, ptr %src_column, align 8
  %NextEnabledColumn = getelementptr inbounds %struct.ImGuiTableColumn, ptr %45, i32 0, i32 21
  %46 = load i16, ptr %NextEnabledColumn, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i16 [ %44, %cond.true ], [ %46, %cond.false ]
  %conv49 = sext i16 %cond to i32
  %call50 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns47, i32 noundef %conv49)
  store ptr %call50, ptr %dst_column, align 8
  %47 = load ptr, ptr %src_column, align 8
  %DisplayOrder = getelementptr inbounds %struct.ImGuiTableColumn, ptr %47, i32 0, i32 18
  %48 = load i16, ptr %DisplayOrder, align 2
  %conv51 = sext i16 %48 to i32
  store i32 %conv51, ptr %src_order, align 4
  %49 = load ptr, ptr %dst_column, align 8
  %DisplayOrder52 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %49, i32 0, i32 18
  %50 = load i16, ptr %DisplayOrder52, align 2
  %conv53 = sext i16 %50 to i32
  store i32 %conv53, ptr %dst_order, align 4
  %51 = load i32, ptr %dst_order, align 4
  %conv54 = trunc i32 %51 to i16
  %52 = load ptr, ptr %src_column, align 8
  %DisplayOrder55 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %52, i32 0, i32 18
  store i16 %conv54, ptr %DisplayOrder55, align 2
  %53 = load i32, ptr %src_order, align 4
  %54 = load i32, ptr %reorder_dir, align 4
  %add = add nsw i32 %53, %54
  store i32 %add, ptr %order_n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %55 = load i32, ptr %order_n, align 4
  %56 = load i32, ptr %dst_order, align 4
  %57 = load i32, ptr %reorder_dir, align 4
  %add56 = add nsw i32 %56, %57
  %cmp57 = icmp ne i32 %55, %add56
  br i1 %cmp57, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %58 = load i32, ptr %reorder_dir, align 4
  %conv58 = trunc i32 %58 to i16
  %conv59 = sext i16 %conv58 to i32
  %59 = load ptr, ptr %table.addr, align 8
  %Columns60 = getelementptr inbounds %struct.ImGuiTable, ptr %59, i32 0, i32 4
  %60 = load ptr, ptr %table.addr, align 8
  %DisplayOrderToIndex = getelementptr inbounds %struct.ImGuiTable, ptr %60, i32 0, i32 5
  %61 = load i32, ptr %order_n, align 4
  %call61 = call noundef nonnull align 2 dereferenceable(2) ptr @_ZN6ImSpanIsEixEi(ptr noundef nonnull align 8 dereferenceable(16) %DisplayOrderToIndex, i32 noundef %61)
  %62 = load i16, ptr %call61, align 2
  %conv62 = sext i16 %62 to i32
  %call63 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns60, i32 noundef %conv62)
  %DisplayOrder64 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %call63, i32 0, i32 18
  %63 = load i16, ptr %DisplayOrder64, align 2
  %conv65 = sext i16 %63 to i32
  %sub = sub nsw i32 %conv65, %conv59
  %conv66 = trunc i32 %sub to i16
  store i16 %conv66, ptr %DisplayOrder64, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %64 = load i32, ptr %reorder_dir, align 4
  %65 = load i32, ptr %order_n, align 4
  %add67 = add nsw i32 %65, %64
  store i32 %add67, ptr %order_n, align 4
  br label %for.cond, !llvm.loop !13

for.end:                                          ; preds = %for.cond
  store i32 0, ptr %column_n, align 4
  br label %for.cond68

for.cond68:                                       ; preds = %for.inc78, %for.end
  %66 = load i32, ptr %column_n, align 4
  %67 = load ptr, ptr %table.addr, align 8
  %ColumnsCount = getelementptr inbounds %struct.ImGuiTable, ptr %67, i32 0, i32 13
  %68 = load i32, ptr %ColumnsCount, align 4
  %cmp69 = icmp slt i32 %66, %68
  br i1 %cmp69, label %for.body70, label %for.end79

for.body70:                                       ; preds = %for.cond68
  %69 = load i32, ptr %column_n, align 4
  %conv71 = trunc i32 %69 to i16
  %70 = load ptr, ptr %table.addr, align 8
  %DisplayOrderToIndex72 = getelementptr inbounds %struct.ImGuiTable, ptr %70, i32 0, i32 5
  %71 = load ptr, ptr %table.addr, align 8
  %Columns73 = getelementptr inbounds %struct.ImGuiTable, ptr %71, i32 0, i32 4
  %72 = load i32, ptr %column_n, align 4
  %call74 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns73, i32 noundef %72)
  %DisplayOrder75 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %call74, i32 0, i32 18
  %73 = load i16, ptr %DisplayOrder75, align 2
  %conv76 = sext i16 %73 to i32
  %call77 = call noundef nonnull align 2 dereferenceable(2) ptr @_ZN6ImSpanIsEixEi(ptr noundef nonnull align 8 dereferenceable(16) %DisplayOrderToIndex72, i32 noundef %conv76)
  store i16 %conv71, ptr %call77, align 2
  br label %for.inc78

for.inc78:                                        ; preds = %for.body70
  %74 = load i32, ptr %column_n, align 4
  %inc = add nsw i32 %74, 1
  store i32 %inc, ptr %column_n, align 4
  br label %for.cond68, !llvm.loop !14

for.end79:                                        ; preds = %for.cond68
  %75 = load ptr, ptr %table.addr, align 8
  %ReorderColumnDir80 = getelementptr inbounds %struct.ImGuiTable, ptr %75, i32 0, i32 78
  store i16 0, ptr %ReorderColumnDir80, align 2
  %76 = load ptr, ptr %table.addr, align 8
  %IsSettingsDirty = getelementptr inbounds %struct.ImGuiTable, ptr %76, i32 0, i32 100
  store i8 1, ptr %IsSettingsDirty, align 2
  br label %if.end81

if.end81:                                         ; preds = %for.end79, %land.lhs.true37, %if.end32
  br label %if.end82

if.end82:                                         ; preds = %if.end81, %if.end20
  %77 = load ptr, ptr %table.addr, align 8
  %IsResetDisplayOrderRequest = getelementptr inbounds %struct.ImGuiTable, ptr %77, i32 0, i32 103
  %78 = load i8, ptr %IsResetDisplayOrderRequest, align 1
  %tobool = trunc i8 %78 to i1
  br i1 %tobool, label %if.then83, label %if.end99

if.then83:                                        ; preds = %if.end82
  store i32 0, ptr %n, align 4
  br label %for.cond84

for.cond84:                                       ; preds = %for.inc94, %if.then83
  %79 = load i32, ptr %n, align 4
  %80 = load ptr, ptr %table.addr, align 8
  %ColumnsCount85 = getelementptr inbounds %struct.ImGuiTable, ptr %80, i32 0, i32 13
  %81 = load i32, ptr %ColumnsCount85, align 4
  %cmp86 = icmp slt i32 %79, %81
  br i1 %cmp86, label %for.body87, label %for.end96

for.body87:                                       ; preds = %for.cond84
  %82 = load i32, ptr %n, align 4
  %conv88 = trunc i32 %82 to i16
  %83 = load ptr, ptr %table.addr, align 8
  %Columns89 = getelementptr inbounds %struct.ImGuiTable, ptr %83, i32 0, i32 4
  %84 = load i32, ptr %n, align 4
  %call90 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns89, i32 noundef %84)
  %DisplayOrder91 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %call90, i32 0, i32 18
  store i16 %conv88, ptr %DisplayOrder91, align 2
  %85 = load ptr, ptr %table.addr, align 8
  %DisplayOrderToIndex92 = getelementptr inbounds %struct.ImGuiTable, ptr %85, i32 0, i32 5
  %86 = load i32, ptr %n, align 4
  %call93 = call noundef nonnull align 2 dereferenceable(2) ptr @_ZN6ImSpanIsEixEi(ptr noundef nonnull align 8 dereferenceable(16) %DisplayOrderToIndex92, i32 noundef %86)
  store i16 %conv88, ptr %call93, align 2
  br label %for.inc94

for.inc94:                                        ; preds = %for.body87
  %87 = load i32, ptr %n, align 4
  %inc95 = add nsw i32 %87, 1
  store i32 %inc95, ptr %n, align 4
  br label %for.cond84, !llvm.loop !15

for.end96:                                        ; preds = %for.cond84
  %88 = load ptr, ptr %table.addr, align 8
  %IsResetDisplayOrderRequest97 = getelementptr inbounds %struct.ImGuiTable, ptr %88, i32 0, i32 103
  store i8 0, ptr %IsResetDisplayOrderRequest97, align 1
  %89 = load ptr, ptr %table.addr, align 8
  %IsSettingsDirty98 = getelementptr inbounds %struct.ImGuiTable, ptr %89, i32 0, i32 100
  store i8 1, ptr %IsSettingsDirty98, align 2
  br label %if.end99

if.end99:                                         ; preds = %for.end96, %if.end82
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i64 @_Z31ImBitArrayGetStorageSizeInBytesi(i32 noundef %bitcount) #3 comdat {
entry:
  %bitcount.addr = alloca i32, align 4
  store i32 %bitcount, ptr %bitcount.addr, align 4
  %0 = load i32, ptr %bitcount.addr, align 4
  %add = add nsw i32 %0, 31
  %shr = ashr i32 %add, 5
  %conv = sext i32 %shr to i64
  %shl = shl i64 %conv, 2
  ret i64 %shl
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN15ImSpanAllocatorILi6EEC2Ev(ptr noundef nonnull align 8 dereferenceable(64) %this) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %this1, i8 0, i64 64, i1 false)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN15ImSpanAllocatorILi6EE7ReserveEimi(ptr noundef nonnull align 8 dereferenceable(64) %this, i32 noundef %n, i64 noundef %sz, i32 noundef %a) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  %sz.addr = alloca i64, align 8
  %a.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  store i64 %sz, ptr %sz.addr, align 8
  store i32 %a, ptr %a.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %CurrOff = getelementptr inbounds %struct.ImSpanAllocator, ptr %this1, i32 0, i32 1
  %0 = load i32, ptr %CurrOff, align 8
  %1 = load i32, ptr %a.addr, align 4
  %sub = sub nsw i32 %1, 1
  %add = add nsw i32 %0, %sub
  %2 = load i32, ptr %a.addr, align 4
  %sub2 = sub nsw i32 %2, 1
  %not = xor i32 %sub2, -1
  %and = and i32 %add, %not
  %CurrOff3 = getelementptr inbounds %struct.ImSpanAllocator, ptr %this1, i32 0, i32 1
  store i32 %and, ptr %CurrOff3, align 8
  %CurrOff4 = getelementptr inbounds %struct.ImSpanAllocator, ptr %this1, i32 0, i32 1
  %3 = load i32, ptr %CurrOff4, align 8
  %Offsets = getelementptr inbounds %struct.ImSpanAllocator, ptr %this1, i32 0, i32 3
  %4 = load i32, ptr %n.addr, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds [6 x i32], ptr %Offsets, i64 0, i64 %idxprom
  store i32 %3, ptr %arrayidx, align 4
  %5 = load i64, ptr %sz.addr, align 8
  %conv = trunc i64 %5 to i32
  %Sizes = getelementptr inbounds %struct.ImSpanAllocator, ptr %this1, i32 0, i32 4
  %6 = load i32, ptr %n.addr, align 4
  %idxprom5 = sext i32 %6 to i64
  %arrayidx6 = getelementptr inbounds [6 x i32], ptr %Sizes, i64 0, i64 %idxprom5
  store i32 %conv, ptr %arrayidx6, align 4
  %CurrIdx = getelementptr inbounds %struct.ImSpanAllocator, ptr %this1, i32 0, i32 2
  %7 = load i32, ptr %CurrIdx, align 4
  %inc = add nsw i32 %7, 1
  store i32 %inc, ptr %CurrIdx, align 4
  %8 = load i64, ptr %sz.addr, align 8
  %conv7 = trunc i64 %8 to i32
  %CurrOff8 = getelementptr inbounds %struct.ImSpanAllocator, ptr %this1, i32 0, i32 1
  %9 = load i32, ptr %CurrOff8, align 8
  %add9 = add nsw i32 %9, %conv7
  store i32 %add9, ptr %CurrOff8, align 8
  ret void
}

declare noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef) #1

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i32 @_ZN15ImSpanAllocatorILi6EE19GetArenaSizeInBytesEv(ptr noundef nonnull align 8 dereferenceable(64) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %CurrOff = getelementptr inbounds %struct.ImSpanAllocator, ptr %this1, i32 0, i32 1
  %0 = load i32, ptr %CurrOff, align 8
  ret i32 %0
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #5

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN15ImSpanAllocatorILi6EE15SetArenaBasePtrEPv(ptr noundef nonnull align 8 dereferenceable(64) %this, ptr noundef %base_ptr) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %base_ptr.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %base_ptr, ptr %base_ptr.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %base_ptr.addr, align 8
  %BasePtr = getelementptr inbounds %struct.ImSpanAllocator, ptr %this1, i32 0, i32 0
  store ptr %0, ptr %BasePtr, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN15ImSpanAllocatorILi6EE7GetSpanI16ImGuiTableColumnEEviP6ImSpanIT_E(ptr noundef nonnull align 8 dereferenceable(64) %this, i32 noundef %n, ptr noundef %span) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  %span.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  store ptr %span, ptr %span.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %span.addr, align 8
  %1 = load i32, ptr %n.addr, align 4
  %call = call noundef ptr @_ZN15ImSpanAllocatorILi6EE15GetSpanPtrBeginEi(ptr noundef nonnull align 8 dereferenceable(64) %this1, i32 noundef %1)
  %2 = load i32, ptr %n.addr, align 4
  %call2 = call noundef ptr @_ZN15ImSpanAllocatorILi6EE13GetSpanPtrEndEi(ptr noundef nonnull align 8 dereferenceable(64) %this1, i32 noundef %2)
  call void @_ZN6ImSpanI16ImGuiTableColumnE3setEPS0_S2_(ptr noundef nonnull align 8 dereferenceable(16) %0, ptr noundef %call, ptr noundef %call2)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN15ImSpanAllocatorILi6EE7GetSpanIsEEviP6ImSpanIT_E(ptr noundef nonnull align 8 dereferenceable(64) %this, i32 noundef %n, ptr noundef %span) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  %span.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  store ptr %span, ptr %span.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %span.addr, align 8
  %1 = load i32, ptr %n.addr, align 4
  %call = call noundef ptr @_ZN15ImSpanAllocatorILi6EE15GetSpanPtrBeginEi(ptr noundef nonnull align 8 dereferenceable(64) %this1, i32 noundef %1)
  %2 = load i32, ptr %n.addr, align 4
  %call2 = call noundef ptr @_ZN15ImSpanAllocatorILi6EE13GetSpanPtrEndEi(ptr noundef nonnull align 8 dereferenceable(64) %this1, i32 noundef %2)
  call void @_ZN6ImSpanIsE3setEPsS1_(ptr noundef nonnull align 8 dereferenceable(16) %0, ptr noundef %call, ptr noundef %call2)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN15ImSpanAllocatorILi6EE7GetSpanI18ImGuiTableCellDataEEviP6ImSpanIT_E(ptr noundef nonnull align 8 dereferenceable(64) %this, i32 noundef %n, ptr noundef %span) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  %span.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  store ptr %span, ptr %span.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %span.addr, align 8
  %1 = load i32, ptr %n.addr, align 4
  %call = call noundef ptr @_ZN15ImSpanAllocatorILi6EE15GetSpanPtrBeginEi(ptr noundef nonnull align 8 dereferenceable(64) %this1, i32 noundef %1)
  %2 = load i32, ptr %n.addr, align 4
  %call2 = call noundef ptr @_ZN15ImSpanAllocatorILi6EE13GetSpanPtrEndEi(ptr noundef nonnull align 8 dereferenceable(64) %this1, i32 noundef %2)
  call void @_ZN6ImSpanI18ImGuiTableCellDataE3setEPS0_S2_(ptr noundef nonnull align 8 dereferenceable(16) %0, ptr noundef %call, ptr noundef %call2)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef ptr @_ZN15ImSpanAllocatorILi6EE15GetSpanPtrBeginEi(ptr noundef nonnull align 8 dereferenceable(64) %this, i32 noundef %n) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %BasePtr = getelementptr inbounds %struct.ImSpanAllocator, ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %BasePtr, align 8
  %Offsets = getelementptr inbounds %struct.ImSpanAllocator, ptr %this1, i32 0, i32 3
  %1 = load i32, ptr %n.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds [6 x i32], ptr %Offsets, i64 0, i64 %idxprom
  %2 = load i32, ptr %arrayidx, align 4
  %idx.ext = sext i32 %2 to i64
  %add.ptr = getelementptr inbounds i8, ptr %0, i64 %idx.ext
  ret ptr %add.ptr
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui19TableSetColumnWidthEif(i32 noundef %column_n, float noundef %width) #0 {
entry:
  %column_n.addr = alloca i32, align 4
  %width.addr = alloca float, align 4
  %g = alloca ptr, align 8
  %table = alloca ptr, align 8
  %column_0 = alloca ptr, align 8
  %column_0_width = alloca float, align 4
  %min_width = alloca float, align 4
  %max_width = alloca float, align 4
  %column_1 = alloca ptr, align 8
  %column_1_width = alloca float, align 4
  store i32 %column_n, ptr %column_n.addr, align 4
  store float %width, ptr %width.addr, align 4
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %g, align 8
  %CurrentTable = getelementptr inbounds %struct.ImGuiContext, ptr %1, i32 0, i32 164
  %2 = load ptr, ptr %CurrentTable, align 8
  store ptr %2, ptr %table, align 8
  %3 = load ptr, ptr %table, align 8
  %Columns = getelementptr inbounds %struct.ImGuiTable, ptr %3, i32 0, i32 4
  %4 = load i32, ptr %column_n.addr, align 4
  %call = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns, i32 noundef %4)
  store ptr %call, ptr %column_0, align 8
  %5 = load float, ptr %width.addr, align 4
  store float %5, ptr %column_0_width, align 4
  %6 = load ptr, ptr %table, align 8
  %MinColumnWidth = getelementptr inbounds %struct.ImGuiTable, ptr %6, i32 0, i32 32
  %7 = load float, ptr %MinColumnWidth, align 8
  store float %7, ptr %min_width, align 4
  %8 = load float, ptr %min_width, align 4
  %9 = load ptr, ptr %table, align 8
  %10 = load i32, ptr %column_n.addr, align 4
  %call1 = call noundef float @_ZN5ImGui22TableGetMaxColumnWidthEPK10ImGuiTablei(ptr noundef %9, i32 noundef %10)
  %call2 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %8, float noundef %call1)
  store float %call2, ptr %max_width, align 4
  %11 = load float, ptr %column_0_width, align 4
  %12 = load float, ptr %min_width, align 4
  %13 = load float, ptr %max_width, align 4
  %call3 = call noundef float @_ZL7ImClampIfET_S0_S0_S0_(float noundef %11, float noundef %12, float noundef %13)
  store float %call3, ptr %column_0_width, align 4
  %14 = load ptr, ptr %column_0, align 8
  %WidthGiven = getelementptr inbounds %struct.ImGuiTableColumn, ptr %14, i32 0, i32 1
  %15 = load float, ptr %WidthGiven, align 4
  %16 = load float, ptr %column_0_width, align 4
  %cmp = fcmp oeq float %15, %16
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %17 = load ptr, ptr %column_0, align 8
  %WidthRequest = getelementptr inbounds %struct.ImGuiTableColumn, ptr %17, i32 0, i32 4
  %18 = load float, ptr %WidthRequest, align 4
  %19 = load float, ptr %column_0_width, align 4
  %cmp4 = fcmp oeq float %18, %19
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %20 = load ptr, ptr %column_0, align 8
  %NextEnabledColumn = getelementptr inbounds %struct.ImGuiTableColumn, ptr %20, i32 0, i32 21
  %21 = load i16, ptr %NextEnabledColumn, align 4
  %conv = sext i16 %21 to i32
  %cmp5 = icmp ne i32 %conv, -1
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %22 = load ptr, ptr %table, align 8
  %Columns6 = getelementptr inbounds %struct.ImGuiTable, ptr %22, i32 0, i32 4
  %23 = load ptr, ptr %column_0, align 8
  %NextEnabledColumn7 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %23, i32 0, i32 21
  %24 = load i16, ptr %NextEnabledColumn7, align 4
  %conv8 = sext i16 %24 to i32
  %call9 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns6, i32 noundef %conv8)
  br label %cond.end

cond.false:                                       ; preds = %if.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call9, %cond.true ], [ null, %cond.false ]
  store ptr %cond, ptr %column_1, align 8
  %25 = load ptr, ptr %column_0, align 8
  %Flags = getelementptr inbounds %struct.ImGuiTableColumn, ptr %25, i32 0, i32 0
  %26 = load i32, ptr %Flags, align 4
  %and = and i32 %26, 16
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then10, label %if.end27

if.then10:                                        ; preds = %cond.end
  %27 = load ptr, ptr %column_1, align 8
  %tobool11 = icmp ne ptr %27, null
  br i1 %tobool11, label %lor.lhs.false12, label %if.then24

lor.lhs.false12:                                  ; preds = %if.then10
  %28 = load ptr, ptr %table, align 8
  %LeftMostStretchedColumn = getelementptr inbounds %struct.ImGuiTable, ptr %28, i32 0, i32 81
  %29 = load i16, ptr %LeftMostStretchedColumn, align 8
  %conv13 = sext i16 %29 to i32
  %cmp14 = icmp eq i32 %conv13, -1
  br i1 %cmp14, label %if.then24, label %lor.lhs.false15

lor.lhs.false15:                                  ; preds = %lor.lhs.false12
  %30 = load ptr, ptr %table, align 8
  %Columns16 = getelementptr inbounds %struct.ImGuiTable, ptr %30, i32 0, i32 4
  %31 = load ptr, ptr %table, align 8
  %LeftMostStretchedColumn17 = getelementptr inbounds %struct.ImGuiTable, ptr %31, i32 0, i32 81
  %32 = load i16, ptr %LeftMostStretchedColumn17, align 8
  %conv18 = sext i16 %32 to i32
  %call19 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns16, i32 noundef %conv18)
  %DisplayOrder = getelementptr inbounds %struct.ImGuiTableColumn, ptr %call19, i32 0, i32 18
  %33 = load i16, ptr %DisplayOrder, align 2
  %conv20 = sext i16 %33 to i32
  %34 = load ptr, ptr %column_0, align 8
  %DisplayOrder21 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %34, i32 0, i32 18
  %35 = load i16, ptr %DisplayOrder21, align 2
  %conv22 = sext i16 %35 to i32
  %cmp23 = icmp sge i32 %conv20, %conv22
  br i1 %cmp23, label %if.then24, label %if.end26

if.then24:                                        ; preds = %lor.lhs.false15, %lor.lhs.false12, %if.then10
  %36 = load float, ptr %column_0_width, align 4
  %37 = load ptr, ptr %column_0, align 8
  %WidthRequest25 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %37, i32 0, i32 4
  store float %36, ptr %WidthRequest25, align 4
  %38 = load ptr, ptr %table, align 8
  %IsSettingsDirty = getelementptr inbounds %struct.ImGuiTable, ptr %38, i32 0, i32 100
  store i8 1, ptr %IsSettingsDirty, align 2
  br label %return

if.end26:                                         ; preds = %lor.lhs.false15
  br label %if.end27

if.end27:                                         ; preds = %if.end26, %cond.end
  %39 = load ptr, ptr %column_1, align 8
  %cmp28 = icmp eq ptr %39, null
  br i1 %cmp28, label %if.then29, label %if.end40

if.then29:                                        ; preds = %if.end27
  %40 = load ptr, ptr %column_0, align 8
  %PrevEnabledColumn = getelementptr inbounds %struct.ImGuiTableColumn, ptr %40, i32 0, i32 20
  %41 = load i16, ptr %PrevEnabledColumn, align 2
  %conv30 = sext i16 %41 to i32
  %cmp31 = icmp ne i32 %conv30, -1
  br i1 %cmp31, label %cond.true32, label %cond.false37

cond.true32:                                      ; preds = %if.then29
  %42 = load ptr, ptr %table, align 8
  %Columns33 = getelementptr inbounds %struct.ImGuiTable, ptr %42, i32 0, i32 4
  %43 = load ptr, ptr %column_0, align 8
  %PrevEnabledColumn34 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %43, i32 0, i32 20
  %44 = load i16, ptr %PrevEnabledColumn34, align 2
  %conv35 = sext i16 %44 to i32
  %call36 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns33, i32 noundef %conv35)
  br label %cond.end38

cond.false37:                                     ; preds = %if.then29
  br label %cond.end38

cond.end38:                                       ; preds = %cond.false37, %cond.true32
  %cond39 = phi ptr [ %call36, %cond.true32 ], [ null, %cond.false37 ]
  store ptr %cond39, ptr %column_1, align 8
  br label %if.end40

if.end40:                                         ; preds = %cond.end38, %if.end27
  %45 = load ptr, ptr %column_1, align 8
  %cmp41 = icmp eq ptr %45, null
  br i1 %cmp41, label %if.then42, label %if.end43

if.then42:                                        ; preds = %if.end40
  br label %return

if.end43:                                         ; preds = %if.end40
  %46 = load ptr, ptr %column_1, align 8
  %WidthRequest44 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %46, i32 0, i32 4
  %47 = load float, ptr %WidthRequest44, align 4
  %48 = load float, ptr %column_0_width, align 4
  %49 = load ptr, ptr %column_0, align 8
  %WidthRequest45 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %49, i32 0, i32 4
  %50 = load float, ptr %WidthRequest45, align 4
  %sub = fsub float %48, %50
  %sub46 = fsub float %47, %sub
  %51 = load float, ptr %min_width, align 4
  %call47 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %sub46, float noundef %51)
  store float %call47, ptr %column_1_width, align 4
  %52 = load ptr, ptr %column_0, align 8
  %WidthRequest48 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %52, i32 0, i32 4
  %53 = load float, ptr %WidthRequest48, align 4
  %54 = load ptr, ptr %column_1, align 8
  %WidthRequest49 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %54, i32 0, i32 4
  %55 = load float, ptr %WidthRequest49, align 4
  %add = fadd float %53, %55
  %56 = load float, ptr %column_1_width, align 4
  %sub50 = fsub float %add, %56
  store float %sub50, ptr %column_0_width, align 4
  %57 = load float, ptr %column_0_width, align 4
  %58 = load ptr, ptr %column_0, align 8
  %WidthRequest51 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %58, i32 0, i32 4
  store float %57, ptr %WidthRequest51, align 4
  %59 = load float, ptr %column_1_width, align 4
  %60 = load ptr, ptr %column_1, align 8
  %WidthRequest52 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %60, i32 0, i32 4
  store float %59, ptr %WidthRequest52, align 4
  %61 = load ptr, ptr %column_0, align 8
  %Flags53 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %61, i32 0, i32 0
  %62 = load i32, ptr %Flags53, align 4
  %63 = load ptr, ptr %column_1, align 8
  %Flags54 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %63, i32 0, i32 0
  %64 = load i32, ptr %Flags54, align 4
  %or = or i32 %62, %64
  %and55 = and i32 %or, 8
  %tobool56 = icmp ne i32 %and55, 0
  br i1 %tobool56, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.end43
  %65 = load ptr, ptr %table, align 8
  call void @_ZN5ImGui33TableUpdateColumnsWeightFromWidthEP10ImGuiTable(ptr noundef %65)
  br label %if.end58

if.end58:                                         ; preds = %if.then57, %if.end43
  %66 = load ptr, ptr %table, align 8
  %IsSettingsDirty59 = getelementptr inbounds %struct.ImGuiTable, ptr %66, i32 0, i32 100
  store i8 1, ptr %IsSettingsDirty59, align 2
  br label %return

return:                                           ; preds = %if.end58, %if.then42, %if.then24, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui17TableUpdateLayoutEP10ImGuiTable(ptr noundef %table) #0 {
entry:
  %table.addr = alloca ptr, align 8
  %g = alloca ptr, align 8
  %table_sizing_policy = alloca i32, align 4
  %count_fixed = alloca i32, align 4
  %count_stretch = alloca i32, align 4
  %prev_visible_column_idx = alloca i32, align 4
  %has_auto_fit_request = alloca i8, align 1
  %has_resizable = alloca i8, align 1
  %stretch_sum_width_auto = alloca float, align 4
  %fixed_max_width_auto = alloca float, align 4
  %order_n = alloca i32, align 4
  %column_n = alloca i32, align 4
  %column = alloca ptr, align 8
  %start_auto_fit = alloca i8, align 1
  %column_is_resizable = alloca i8, align 1
  %sum_width_requests = alloca float, align 4
  %stretch_sum_weights = alloca float, align 4
  %column_n143 = alloca i32, align 4
  %column154 = alloca ptr, align 8
  %column_is_resizable157 = alloca i8, align 1
  %width_auto = alloca float, align 4
  %work_rect = alloca %struct.ImRect, align 4
  %width_spacings = alloca float, align 4
  %width_removed = alloca float, align 4
  %width_avail = alloca float, align 4
  %width_avail_for_stretched_columns = alloca float, align 4
  %width_remaining_for_stretched_columns = alloca float, align 4
  %column_n316 = alloca i32, align 4
  %column331 = alloca ptr, align 8
  %weight_ratio = alloca float, align 4
  %order_n376 = alloca i32, align 4
  %column397 = alloca ptr, align 8
  %table_instance = alloca ptr, align 8
  %mouse_hit_rect = alloca %struct.ImRect, align 4
  %backup_active_id = alloca i32, align 4
  %is_hovering_table = alloca i8, align 1
  %mouse_skewed_x = alloca float, align 4
  %visible_n = alloca i32, align 4
  %has_at_least_one_column_requesting_output = alloca i8, align 1
  %offset_x_frozen = alloca i8, align 1
  %offset_x = alloca float, align 4
  %host_clip_rect = alloca %struct.ImRect, align 4
  %order_n492 = alloca i32, align 4
  %column_n497 = alloca i32, align 4
  %column501 = alloca ptr, align 8
  %max_width = alloca float, align 4
  %is_visible = alloca i8, align 1
  %unused_x1 = alloca float, align 4
  %window_content_max_y = alloca float, align 4
  %inner_window = alloca ptr, align 8
  store ptr %table, ptr %table.addr, align 8
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %table.addr, align 8
  %Flags = getelementptr inbounds %struct.ImGuiTable, ptr %1, i32 0, i32 1
  %2 = load i32, ptr %Flags, align 4
  %and = and i32 %2, 57344
  store i32 %and, ptr %table_sizing_policy, align 4
  %3 = load ptr, ptr %table.addr, align 8
  %IsDefaultDisplayOrder = getelementptr inbounds %struct.ImGuiTable, ptr %3, i32 0, i32 101
  store i8 1, ptr %IsDefaultDisplayOrder, align 1
  %4 = load ptr, ptr %table.addr, align 8
  %ColumnsEnabledCount = getelementptr inbounds %struct.ImGuiTable, ptr %4, i32 0, i32 66
  store i16 0, ptr %ColumnsEnabledCount, align 2
  %5 = load ptr, ptr %table.addr, align 8
  %EnabledMaskByIndex = getelementptr inbounds %struct.ImGuiTable, ptr %5, i32 0, i32 8
  %6 = load ptr, ptr %EnabledMaskByIndex, align 8
  %7 = load ptr, ptr %table.addr, align 8
  %ColumnsCount = getelementptr inbounds %struct.ImGuiTable, ptr %7, i32 0, i32 13
  %8 = load i32, ptr %ColumnsCount, align 4
  call void @_Z22ImBitArrayClearAllBitsPji(ptr noundef %6, i32 noundef %8)
  %9 = load ptr, ptr %table.addr, align 8
  %EnabledMaskByDisplayOrder = getelementptr inbounds %struct.ImGuiTable, ptr %9, i32 0, i32 7
  %10 = load ptr, ptr %EnabledMaskByDisplayOrder, align 8
  %11 = load ptr, ptr %table.addr, align 8
  %ColumnsCount1 = getelementptr inbounds %struct.ImGuiTable, ptr %11, i32 0, i32 13
  %12 = load i32, ptr %ColumnsCount1, align 4
  call void @_Z22ImBitArrayClearAllBitsPji(ptr noundef %10, i32 noundef %12)
  %13 = load ptr, ptr %table.addr, align 8
  %LeftMostEnabledColumn = getelementptr inbounds %struct.ImGuiTable, ptr %13, i32 0, i32 79
  store i16 -1, ptr %LeftMostEnabledColumn, align 4
  %14 = load ptr, ptr %g, align 8
  %Style = getelementptr inbounds %struct.ImGuiContext, ptr %14, i32 0, i32 3
  %FramePadding = getelementptr inbounds %struct.ImGuiStyle, ptr %Style, i32 0, i32 12
  %x = getelementptr inbounds %struct.ImVec2, ptr %FramePadding, i32 0, i32 0
  %15 = load float, ptr %x, align 4
  %mul = fmul float %15, 1.000000e+00
  %call = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef 1.000000e+00, float noundef %mul)
  %16 = load ptr, ptr %table.addr, align 8
  %MinColumnWidth = getelementptr inbounds %struct.ImGuiTable, ptr %16, i32 0, i32 32
  store float %call, ptr %MinColumnWidth, align 8
  store i32 0, ptr %count_fixed, align 4
  store i32 0, ptr %count_stretch, align 4
  store i32 -1, ptr %prev_visible_column_idx, align 4
  store i8 0, ptr %has_auto_fit_request, align 1
  store i8 0, ptr %has_resizable, align 1
  store float 0.000000e+00, ptr %stretch_sum_width_auto, align 4
  store float 0.000000e+00, ptr %fixed_max_width_auto, align 4
  store i32 0, ptr %order_n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %17 = load i32, ptr %order_n, align 4
  %18 = load ptr, ptr %table.addr, align 8
  %ColumnsCount2 = getelementptr inbounds %struct.ImGuiTable, ptr %18, i32 0, i32 13
  %19 = load i32, ptr %ColumnsCount2, align 4
  %cmp = icmp slt i32 %17, %19
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %20 = load ptr, ptr %table.addr, align 8
  %DisplayOrderToIndex = getelementptr inbounds %struct.ImGuiTable, ptr %20, i32 0, i32 5
  %21 = load i32, ptr %order_n, align 4
  %call3 = call noundef nonnull align 2 dereferenceable(2) ptr @_ZN6ImSpanIsEixEi(ptr noundef nonnull align 8 dereferenceable(16) %DisplayOrderToIndex, i32 noundef %21)
  %22 = load i16, ptr %call3, align 2
  %conv = sext i16 %22 to i32
  store i32 %conv, ptr %column_n, align 4
  %23 = load i32, ptr %column_n, align 4
  %24 = load i32, ptr %order_n, align 4
  %cmp4 = icmp ne i32 %23, %24
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %25 = load ptr, ptr %table.addr, align 8
  %IsDefaultDisplayOrder5 = getelementptr inbounds %struct.ImGuiTable, ptr %25, i32 0, i32 101
  store i8 0, ptr %IsDefaultDisplayOrder5, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  %26 = load ptr, ptr %table.addr, align 8
  %Columns = getelementptr inbounds %struct.ImGuiTable, ptr %26, i32 0, i32 4
  %27 = load i32, ptr %column_n, align 4
  %call6 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns, i32 noundef %27)
  store ptr %call6, ptr %column, align 8
  %28 = load ptr, ptr %table.addr, align 8
  %DeclColumnsCount = getelementptr inbounds %struct.ImGuiTable, ptr %28, i32 0, i32 68
  %29 = load i16, ptr %DeclColumnsCount, align 2
  %conv7 = sext i16 %29 to i32
  %30 = load i32, ptr %column_n, align 4
  %cmp8 = icmp sle i32 %conv7, %30
  br i1 %cmp8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end
  %31 = load ptr, ptr %table.addr, align 8
  %32 = load ptr, ptr %column, align 8
  call void @_ZL21TableSetupColumnFlagsP10ImGuiTableP16ImGuiTableColumni(ptr noundef %31, ptr noundef %32, i32 noundef 0)
  %33 = load ptr, ptr %column, align 8
  %NameOffset = getelementptr inbounds %struct.ImGuiTableColumn, ptr %33, i32 0, i32 17
  store i16 -1, ptr %NameOffset, align 4
  %34 = load ptr, ptr %column, align 8
  %UserID = getelementptr inbounds %struct.ImGuiTableColumn, ptr %34, i32 0, i32 9
  store i32 0, ptr %UserID, align 4
  %35 = load ptr, ptr %column, align 8
  %InitStretchWeightOrWidth = getelementptr inbounds %struct.ImGuiTableColumn, ptr %35, i32 0, i32 7
  store float -1.000000e+00, ptr %InitStretchWeightOrWidth, align 4
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %if.end
  %36 = load ptr, ptr %table.addr, align 8
  %Flags11 = getelementptr inbounds %struct.ImGuiTable, ptr %36, i32 0, i32 1
  %37 = load i32, ptr %Flags11, align 4
  %and12 = and i32 %37, 4
  %tobool = icmp ne i32 %and12, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then16

lor.lhs.false:                                    ; preds = %if.end10
  %38 = load ptr, ptr %column, align 8
  %Flags13 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %38, i32 0, i32 0
  %39 = load i32, ptr %Flags13, align 4
  %and14 = and i32 %39, 128
  %tobool15 = icmp ne i32 %and14, 0
  br i1 %tobool15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %lor.lhs.false, %if.end10
  %40 = load ptr, ptr %column, align 8
  %IsUserEnabledNextFrame = getelementptr inbounds %struct.ImGuiTableColumn, ptr %40, i32 0, i32 28
  store i8 1, ptr %IsUserEnabledNextFrame, align 4
  br label %if.end17

if.end17:                                         ; preds = %if.then16, %lor.lhs.false
  %41 = load ptr, ptr %column, align 8
  %IsUserEnabled = getelementptr inbounds %struct.ImGuiTableColumn, ptr %41, i32 0, i32 27
  %42 = load i8, ptr %IsUserEnabled, align 1
  %tobool18 = trunc i8 %42 to i1
  %conv19 = zext i1 %tobool18 to i32
  %43 = load ptr, ptr %column, align 8
  %IsUserEnabledNextFrame20 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %43, i32 0, i32 28
  %44 = load i8, ptr %IsUserEnabledNextFrame20, align 4
  %tobool21 = trunc i8 %44 to i1
  %conv22 = zext i1 %tobool21 to i32
  %cmp23 = icmp ne i32 %conv19, %conv22
  br i1 %cmp23, label %if.then24, label %if.end28

if.then24:                                        ; preds = %if.end17
  %45 = load ptr, ptr %column, align 8
  %IsUserEnabledNextFrame25 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %45, i32 0, i32 28
  %46 = load i8, ptr %IsUserEnabledNextFrame25, align 4
  %tobool26 = trunc i8 %46 to i1
  %47 = load ptr, ptr %column, align 8
  %IsUserEnabled27 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %47, i32 0, i32 27
  %frombool = zext i1 %tobool26 to i8
  store i8 %frombool, ptr %IsUserEnabled27, align 1
  %48 = load ptr, ptr %table.addr, align 8
  %IsSettingsDirty = getelementptr inbounds %struct.ImGuiTable, ptr %48, i32 0, i32 100
  store i8 1, ptr %IsSettingsDirty, align 2
  br label %if.end28

if.end28:                                         ; preds = %if.then24, %if.end17
  %49 = load ptr, ptr %column, align 8
  %IsUserEnabled29 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %49, i32 0, i32 27
  %50 = load i8, ptr %IsUserEnabled29, align 1
  %tobool30 = trunc i8 %50 to i1
  br i1 %tobool30, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end28
  %51 = load ptr, ptr %column, align 8
  %Flags31 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %51, i32 0, i32 0
  %52 = load i32, ptr %Flags31, align 4
  %and32 = and i32 %52, 1
  %cmp33 = icmp eq i32 %and32, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end28
  %53 = phi i1 [ false, %if.end28 ], [ %cmp33, %land.rhs ]
  %54 = load ptr, ptr %column, align 8
  %IsEnabled = getelementptr inbounds %struct.ImGuiTableColumn, ptr %54, i32 0, i32 26
  %frombool34 = zext i1 %53 to i8
  store i8 %frombool34, ptr %IsEnabled, align 2
  %55 = load ptr, ptr %column, align 8
  %SortOrder = getelementptr inbounds %struct.ImGuiTableColumn, ptr %55, i32 0, i32 22
  %56 = load i16, ptr %SortOrder, align 2
  %conv35 = sext i16 %56 to i32
  %cmp36 = icmp ne i32 %conv35, -1
  br i1 %cmp36, label %land.lhs.true, label %if.end40

land.lhs.true:                                    ; preds = %land.end
  %57 = load ptr, ptr %column, align 8
  %IsEnabled37 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %57, i32 0, i32 26
  %58 = load i8, ptr %IsEnabled37, align 2
  %tobool38 = trunc i8 %58 to i1
  br i1 %tobool38, label %if.end40, label %if.then39

if.then39:                                        ; preds = %land.lhs.true
  %59 = load ptr, ptr %table.addr, align 8
  %IsSortSpecsDirty = getelementptr inbounds %struct.ImGuiTable, ptr %59, i32 0, i32 95
  store i8 1, ptr %IsSortSpecsDirty, align 1
  br label %if.end40

if.end40:                                         ; preds = %if.then39, %land.lhs.true, %land.end
  %60 = load ptr, ptr %column, align 8
  %SortOrder41 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %60, i32 0, i32 22
  %61 = load i16, ptr %SortOrder41, align 2
  %conv42 = sext i16 %61 to i32
  %cmp43 = icmp sgt i32 %conv42, 0
  br i1 %cmp43, label %land.lhs.true44, label %if.end50

land.lhs.true44:                                  ; preds = %if.end40
  %62 = load ptr, ptr %table.addr, align 8
  %Flags45 = getelementptr inbounds %struct.ImGuiTable, ptr %62, i32 0, i32 1
  %63 = load i32, ptr %Flags45, align 4
  %and46 = and i32 %63, 67108864
  %tobool47 = icmp ne i32 %and46, 0
  br i1 %tobool47, label %if.end50, label %if.then48

if.then48:                                        ; preds = %land.lhs.true44
  %64 = load ptr, ptr %table.addr, align 8
  %IsSortSpecsDirty49 = getelementptr inbounds %struct.ImGuiTable, ptr %64, i32 0, i32 95
  store i8 1, ptr %IsSortSpecsDirty49, align 1
  br label %if.end50

if.end50:                                         ; preds = %if.then48, %land.lhs.true44, %if.end40
  %65 = load ptr, ptr %column, align 8
  %Flags51 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %65, i32 0, i32 0
  %66 = load i32, ptr %Flags51, align 4
  %and52 = and i32 %66, 16
  %tobool53 = icmp ne i32 %and52, 0
  br i1 %tobool53, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end50
  %67 = load ptr, ptr %column, align 8
  %WidthRequest = getelementptr inbounds %struct.ImGuiTableColumn, ptr %67, i32 0, i32 4
  %68 = load float, ptr %WidthRequest, align 4
  %cmp54 = fcmp olt float %68, 0.000000e+00
  br label %cond.end

cond.false:                                       ; preds = %if.end50
  %69 = load ptr, ptr %column, align 8
  %StretchWeight = getelementptr inbounds %struct.ImGuiTableColumn, ptr %69, i32 0, i32 6
  %70 = load float, ptr %StretchWeight, align 4
  %cmp55 = fcmp olt float %70, 0.000000e+00
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i1 [ %cmp54, %cond.true ], [ %cmp55, %cond.false ]
  %frombool56 = zext i1 %cond to i8
  store i8 %frombool56, ptr %start_auto_fit, align 1
  %71 = load i8, ptr %start_auto_fit, align 1
  %tobool57 = trunc i8 %71 to i1
  br i1 %tobool57, label %if.then58, label %if.end59

if.then58:                                        ; preds = %cond.end
  %72 = load ptr, ptr %column, align 8
  %CannotSkipItemsQueue = getelementptr inbounds %struct.ImGuiTableColumn, ptr %72, i32 0, i32 36
  store i8 7, ptr %CannotSkipItemsQueue, align 4
  %73 = load ptr, ptr %column, align 8
  %AutoFitQueue = getelementptr inbounds %struct.ImGuiTableColumn, ptr %73, i32 0, i32 35
  store i8 7, ptr %AutoFitQueue, align 1
  br label %if.end59

if.end59:                                         ; preds = %if.then58, %cond.end
  %74 = load ptr, ptr %column, align 8
  %IsEnabled60 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %74, i32 0, i32 26
  %75 = load i8, ptr %IsEnabled60, align 2
  %tobool61 = trunc i8 %75 to i1
  br i1 %tobool61, label %if.end63, label %if.then62

if.then62:                                        ; preds = %if.end59
  %76 = load ptr, ptr %column, align 8
  %IndexWithinEnabledSet = getelementptr inbounds %struct.ImGuiTableColumn, ptr %76, i32 0, i32 19
  store i16 -1, ptr %IndexWithinEnabledSet, align 4
  br label %for.inc

if.end63:                                         ; preds = %if.end59
  %77 = load i32, ptr %prev_visible_column_idx, align 4
  %conv64 = trunc i32 %77 to i16
  %78 = load ptr, ptr %column, align 8
  %PrevEnabledColumn = getelementptr inbounds %struct.ImGuiTableColumn, ptr %78, i32 0, i32 20
  store i16 %conv64, ptr %PrevEnabledColumn, align 2
  %79 = load ptr, ptr %column, align 8
  %NextEnabledColumn = getelementptr inbounds %struct.ImGuiTableColumn, ptr %79, i32 0, i32 21
  store i16 -1, ptr %NextEnabledColumn, align 4
  %80 = load i32, ptr %prev_visible_column_idx, align 4
  %cmp65 = icmp ne i32 %80, -1
  br i1 %cmp65, label %if.then66, label %if.else

if.then66:                                        ; preds = %if.end63
  %81 = load i32, ptr %column_n, align 4
  %conv67 = trunc i32 %81 to i16
  %82 = load ptr, ptr %table.addr, align 8
  %Columns68 = getelementptr inbounds %struct.ImGuiTable, ptr %82, i32 0, i32 4
  %83 = load i32, ptr %prev_visible_column_idx, align 4
  %call69 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns68, i32 noundef %83)
  %NextEnabledColumn70 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %call69, i32 0, i32 21
  store i16 %conv67, ptr %NextEnabledColumn70, align 4
  br label %if.end73

if.else:                                          ; preds = %if.end63
  %84 = load i32, ptr %column_n, align 4
  %conv71 = trunc i32 %84 to i16
  %85 = load ptr, ptr %table.addr, align 8
  %LeftMostEnabledColumn72 = getelementptr inbounds %struct.ImGuiTable, ptr %85, i32 0, i32 79
  store i16 %conv71, ptr %LeftMostEnabledColumn72, align 4
  br label %if.end73

if.end73:                                         ; preds = %if.else, %if.then66
  %86 = load ptr, ptr %table.addr, align 8
  %ColumnsEnabledCount74 = getelementptr inbounds %struct.ImGuiTable, ptr %86, i32 0, i32 66
  %87 = load i16, ptr %ColumnsEnabledCount74, align 2
  %inc = add i16 %87, 1
  store i16 %inc, ptr %ColumnsEnabledCount74, align 2
  %88 = load ptr, ptr %column, align 8
  %IndexWithinEnabledSet75 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %88, i32 0, i32 19
  store i16 %87, ptr %IndexWithinEnabledSet75, align 4
  %89 = load ptr, ptr %table.addr, align 8
  %EnabledMaskByIndex76 = getelementptr inbounds %struct.ImGuiTable, ptr %89, i32 0, i32 8
  %90 = load ptr, ptr %EnabledMaskByIndex76, align 8
  %91 = load i32, ptr %column_n, align 4
  call void @_Z16ImBitArraySetBitPji(ptr noundef %90, i32 noundef %91)
  %92 = load ptr, ptr %table.addr, align 8
  %EnabledMaskByDisplayOrder77 = getelementptr inbounds %struct.ImGuiTable, ptr %92, i32 0, i32 7
  %93 = load ptr, ptr %EnabledMaskByDisplayOrder77, align 8
  %94 = load ptr, ptr %column, align 8
  %DisplayOrder = getelementptr inbounds %struct.ImGuiTableColumn, ptr %94, i32 0, i32 18
  %95 = load i16, ptr %DisplayOrder, align 2
  %conv78 = sext i16 %95 to i32
  call void @_Z16ImBitArraySetBitPji(ptr noundef %93, i32 noundef %conv78)
  %96 = load i32, ptr %column_n, align 4
  store i32 %96, ptr %prev_visible_column_idx, align 4
  %97 = load ptr, ptr %column, align 8
  %IsPreserveWidthAuto = getelementptr inbounds %struct.ImGuiTableColumn, ptr %97, i32 0, i32 33
  %98 = load i8, ptr %IsPreserveWidthAuto, align 1
  %tobool79 = trunc i8 %98 to i1
  br i1 %tobool79, label %if.end82, label %if.then80

if.then80:                                        ; preds = %if.end73
  %99 = load ptr, ptr %table.addr, align 8
  %100 = load ptr, ptr %column, align 8
  %call81 = call noundef float @_ZN5ImGui23TableGetColumnWidthAutoEP10ImGuiTableP16ImGuiTableColumn(ptr noundef %99, ptr noundef %100)
  %101 = load ptr, ptr %column, align 8
  %WidthAuto = getelementptr inbounds %struct.ImGuiTableColumn, ptr %101, i32 0, i32 5
  store float %call81, ptr %WidthAuto, align 4
  br label %if.end82

if.end82:                                         ; preds = %if.then80, %if.end73
  %102 = load ptr, ptr %column, align 8
  %Flags83 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %102, i32 0, i32 0
  %103 = load i32, ptr %Flags83, align 4
  %and84 = and i32 %103, 32
  %cmp85 = icmp eq i32 %and84, 0
  %frombool86 = zext i1 %cmp85 to i8
  store i8 %frombool86, ptr %column_is_resizable, align 1
  %104 = load i8, ptr %column_is_resizable, align 1
  %tobool87 = trunc i8 %104 to i1
  br i1 %tobool87, label %if.then88, label %if.end89

if.then88:                                        ; preds = %if.end82
  store i8 1, ptr %has_resizable, align 1
  br label %if.end89

if.end89:                                         ; preds = %if.then88, %if.end82
  %105 = load ptr, ptr %column, align 8
  %Flags90 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %105, i32 0, i32 0
  %106 = load i32, ptr %Flags90, align 4
  %and91 = and i32 %106, 16
  %tobool92 = icmp ne i32 %and91, 0
  br i1 %tobool92, label %land.lhs.true93, label %if.end101

land.lhs.true93:                                  ; preds = %if.end89
  %107 = load ptr, ptr %column, align 8
  %InitStretchWeightOrWidth94 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %107, i32 0, i32 7
  %108 = load float, ptr %InitStretchWeightOrWidth94, align 4
  %cmp95 = fcmp ogt float %108, 0.000000e+00
  br i1 %cmp95, label %land.lhs.true96, label %if.end101

land.lhs.true96:                                  ; preds = %land.lhs.true93
  %109 = load i8, ptr %column_is_resizable, align 1
  %tobool97 = trunc i8 %109 to i1
  br i1 %tobool97, label %if.end101, label %if.then98

if.then98:                                        ; preds = %land.lhs.true96
  %110 = load ptr, ptr %column, align 8
  %InitStretchWeightOrWidth99 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %110, i32 0, i32 7
  %111 = load float, ptr %InitStretchWeightOrWidth99, align 4
  %112 = load ptr, ptr %column, align 8
  %WidthAuto100 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %112, i32 0, i32 5
  store float %111, ptr %WidthAuto100, align 4
  br label %if.end101

if.end101:                                        ; preds = %if.then98, %land.lhs.true96, %land.lhs.true93, %if.end89
  %113 = load ptr, ptr %column, align 8
  %AutoFitQueue102 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %113, i32 0, i32 35
  %114 = load i8, ptr %AutoFitQueue102, align 1
  %conv103 = zext i8 %114 to i32
  %cmp104 = icmp ne i32 %conv103, 0
  br i1 %cmp104, label %if.then105, label %if.end106

if.then105:                                       ; preds = %if.end101
  store i8 1, ptr %has_auto_fit_request, align 1
  br label %if.end106

if.end106:                                        ; preds = %if.then105, %if.end101
  %115 = load ptr, ptr %column, align 8
  %Flags107 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %115, i32 0, i32 0
  %116 = load i32, ptr %Flags107, align 4
  %and108 = and i32 %116, 8
  %tobool109 = icmp ne i32 %and108, 0
  br i1 %tobool109, label %if.then110, label %if.else113

if.then110:                                       ; preds = %if.end106
  %117 = load ptr, ptr %column, align 8
  %WidthAuto111 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %117, i32 0, i32 5
  %118 = load float, ptr %WidthAuto111, align 4
  %119 = load float, ptr %stretch_sum_width_auto, align 4
  %add = fadd float %119, %118
  store float %add, ptr %stretch_sum_width_auto, align 4
  %120 = load i32, ptr %count_stretch, align 4
  %inc112 = add nsw i32 %120, 1
  store i32 %inc112, ptr %count_stretch, align 4
  br label %if.end117

if.else113:                                       ; preds = %if.end106
  %121 = load float, ptr %fixed_max_width_auto, align 4
  %122 = load ptr, ptr %column, align 8
  %WidthAuto114 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %122, i32 0, i32 5
  %123 = load float, ptr %WidthAuto114, align 4
  %call115 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %121, float noundef %123)
  store float %call115, ptr %fixed_max_width_auto, align 4
  %124 = load i32, ptr %count_fixed, align 4
  %inc116 = add nsw i32 %124, 1
  store i32 %inc116, ptr %count_fixed, align 4
  br label %if.end117

if.end117:                                        ; preds = %if.else113, %if.then110
  br label %for.inc

for.inc:                                          ; preds = %if.end117, %if.then62
  %125 = load i32, ptr %order_n, align 4
  %inc118 = add nsw i32 %125, 1
  store i32 %inc118, ptr %order_n, align 4
  br label %for.cond, !llvm.loop !16

for.end:                                          ; preds = %for.cond
  %126 = load ptr, ptr %table.addr, align 8
  %Flags119 = getelementptr inbounds %struct.ImGuiTable, ptr %126, i32 0, i32 1
  %127 = load i32, ptr %Flags119, align 4
  %and120 = and i32 %127, 8
  %tobool121 = icmp ne i32 %and120, 0
  br i1 %tobool121, label %land.lhs.true122, label %if.end131

land.lhs.true122:                                 ; preds = %for.end
  %128 = load ptr, ptr %table.addr, align 8
  %SortSpecsCount = getelementptr inbounds %struct.ImGuiTable, ptr %128, i32 0, i32 65
  %129 = load i16, ptr %SortSpecsCount, align 8
  %conv123 = sext i16 %129 to i32
  %cmp124 = icmp eq i32 %conv123, 0
  br i1 %cmp124, label %land.lhs.true125, label %if.end131

land.lhs.true125:                                 ; preds = %land.lhs.true122
  %130 = load ptr, ptr %table.addr, align 8
  %Flags126 = getelementptr inbounds %struct.ImGuiTable, ptr %130, i32 0, i32 1
  %131 = load i32, ptr %Flags126, align 4
  %and127 = and i32 %131, 134217728
  %tobool128 = icmp ne i32 %and127, 0
  br i1 %tobool128, label %if.end131, label %if.then129

if.then129:                                       ; preds = %land.lhs.true125
  %132 = load ptr, ptr %table.addr, align 8
  %IsSortSpecsDirty130 = getelementptr inbounds %struct.ImGuiTable, ptr %132, i32 0, i32 95
  store i8 1, ptr %IsSortSpecsDirty130, align 1
  br label %if.end131

if.end131:                                        ; preds = %if.then129, %land.lhs.true125, %land.lhs.true122, %for.end
  %133 = load i32, ptr %prev_visible_column_idx, align 4
  %conv132 = trunc i32 %133 to i16
  %134 = load ptr, ptr %table.addr, align 8
  %RightMostEnabledColumn = getelementptr inbounds %struct.ImGuiTable, ptr %134, i32 0, i32 80
  store i16 %conv132, ptr %RightMostEnabledColumn, align 2
  %135 = load i8, ptr %has_auto_fit_request, align 1
  %tobool133 = trunc i8 %135 to i1
  br i1 %tobool133, label %land.lhs.true134, label %if.end138

land.lhs.true134:                                 ; preds = %if.end131
  %136 = load ptr, ptr %table.addr, align 8
  %OuterWindow = getelementptr inbounds %struct.ImGuiTable, ptr %136, i32 0, i32 55
  %137 = load ptr, ptr %OuterWindow, align 8
  %138 = load ptr, ptr %table.addr, align 8
  %InnerWindow = getelementptr inbounds %struct.ImGuiTable, ptr %138, i32 0, i32 56
  %139 = load ptr, ptr %InnerWindow, align 8
  %cmp135 = icmp ne ptr %137, %139
  br i1 %cmp135, label %if.then136, label %if.end138

if.then136:                                       ; preds = %land.lhs.true134
  %140 = load ptr, ptr %table.addr, align 8
  %InnerWindow137 = getelementptr inbounds %struct.ImGuiTable, ptr %140, i32 0, i32 56
  %141 = load ptr, ptr %InnerWindow137, align 8
  %SkipItems = getelementptr inbounds %struct.ImGuiWindow, ptr %141, i32 0, i32 38
  store i8 0, ptr %SkipItems, align 1
  br label %if.end138

if.end138:                                        ; preds = %if.then136, %land.lhs.true134, %if.end131
  %142 = load i8, ptr %has_auto_fit_request, align 1
  %tobool139 = trunc i8 %142 to i1
  br i1 %tobool139, label %if.then140, label %if.end142

if.then140:                                       ; preds = %if.end138
  %143 = load ptr, ptr %table.addr, align 8
  %IsSettingsDirty141 = getelementptr inbounds %struct.ImGuiTable, ptr %143, i32 0, i32 100
  store i8 1, ptr %IsSettingsDirty141, align 2
  br label %if.end142

if.end142:                                        ; preds = %if.then140, %if.end138
  store float 0.000000e+00, ptr %sum_width_requests, align 4
  store float 0.000000e+00, ptr %stretch_sum_weights, align 4
  %144 = load ptr, ptr %table.addr, align 8
  %RightMostStretchedColumn = getelementptr inbounds %struct.ImGuiTable, ptr %144, i32 0, i32 82
  store i16 -1, ptr %RightMostStretchedColumn, align 2
  %145 = load ptr, ptr %table.addr, align 8
  %LeftMostStretchedColumn = getelementptr inbounds %struct.ImGuiTable, ptr %145, i32 0, i32 81
  store i16 -1, ptr %LeftMostStretchedColumn, align 8
  store i32 0, ptr %column_n143, align 4
  br label %for.cond144

for.cond144:                                      ; preds = %for.inc276, %if.end142
  %146 = load i32, ptr %column_n143, align 4
  %147 = load ptr, ptr %table.addr, align 8
  %ColumnsCount145 = getelementptr inbounds %struct.ImGuiTable, ptr %147, i32 0, i32 13
  %148 = load i32, ptr %ColumnsCount145, align 4
  %cmp146 = icmp slt i32 %146, %148
  br i1 %cmp146, label %for.body147, label %for.end278

for.body147:                                      ; preds = %for.cond144
  %149 = load ptr, ptr %table.addr, align 8
  %EnabledMaskByIndex148 = getelementptr inbounds %struct.ImGuiTable, ptr %149, i32 0, i32 8
  %150 = load ptr, ptr %EnabledMaskByIndex148, align 8
  %151 = load i32, ptr %column_n143, align 4
  %shr = ashr i32 %151, 5
  %idxprom = sext i32 %shr to i64
  %arrayidx = getelementptr inbounds i32, ptr %150, i64 %idxprom
  %152 = load i32, ptr %arrayidx, align 4
  %153 = load i32, ptr %column_n143, align 4
  %and149 = and i32 %153, 31
  %shl = shl i32 1, %and149
  %and150 = and i32 %152, %shl
  %cmp151 = icmp ne i32 %and150, 0
  br i1 %cmp151, label %if.end153, label %if.then152

if.then152:                                       ; preds = %for.body147
  br label %for.inc276

if.end153:                                        ; preds = %for.body147
  %154 = load ptr, ptr %table.addr, align 8
  %Columns155 = getelementptr inbounds %struct.ImGuiTable, ptr %154, i32 0, i32 4
  %155 = load i32, ptr %column_n143, align 4
  %call156 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns155, i32 noundef %155)
  store ptr %call156, ptr %column154, align 8
  %156 = load ptr, ptr %column154, align 8
  %Flags158 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %156, i32 0, i32 0
  %157 = load i32, ptr %Flags158, align 4
  %and159 = and i32 %157, 32
  %cmp160 = icmp eq i32 %and159, 0
  %frombool161 = zext i1 %cmp160 to i8
  store i8 %frombool161, ptr %column_is_resizable157, align 1
  %158 = load ptr, ptr %column154, align 8
  %Flags162 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %158, i32 0, i32 0
  %159 = load i32, ptr %Flags162, align 4
  %and163 = and i32 %159, 16
  %tobool164 = icmp ne i32 %and163, 0
  br i1 %tobool164, label %if.then165, label %if.else210

if.then165:                                       ; preds = %if.end153
  %160 = load ptr, ptr %column154, align 8
  %WidthAuto166 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %160, i32 0, i32 5
  %161 = load float, ptr %WidthAuto166, align 4
  store float %161, ptr %width_auto, align 4
  %162 = load i32, ptr %table_sizing_policy, align 4
  %cmp167 = icmp eq i32 %162, 16384
  br i1 %cmp167, label %land.lhs.true168, label %if.end175

land.lhs.true168:                                 ; preds = %if.then165
  %163 = load ptr, ptr %column154, align 8
  %AutoFitQueue169 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %163, i32 0, i32 35
  %164 = load i8, ptr %AutoFitQueue169, align 1
  %conv170 = zext i8 %164 to i32
  %cmp171 = icmp ne i32 %conv170, 0
  br i1 %cmp171, label %if.then174, label %lor.lhs.false172

lor.lhs.false172:                                 ; preds = %land.lhs.true168
  %165 = load i8, ptr %column_is_resizable157, align 1
  %tobool173 = trunc i8 %165 to i1
  br i1 %tobool173, label %if.end175, label %if.then174

if.then174:                                       ; preds = %lor.lhs.false172, %land.lhs.true168
  %166 = load float, ptr %fixed_max_width_auto, align 4
  store float %166, ptr %width_auto, align 4
  br label %if.end175

if.end175:                                        ; preds = %if.then174, %lor.lhs.false172, %if.then165
  %167 = load ptr, ptr %column154, align 8
  %AutoFitQueue176 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %167, i32 0, i32 35
  %168 = load i8, ptr %AutoFitQueue176, align 1
  %conv177 = zext i8 %168 to i32
  %cmp178 = icmp ne i32 %conv177, 0
  br i1 %cmp178, label %if.then179, label %if.else181

if.then179:                                       ; preds = %if.end175
  %169 = load float, ptr %width_auto, align 4
  %170 = load ptr, ptr %column154, align 8
  %WidthRequest180 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %170, i32 0, i32 4
  store float %169, ptr %WidthRequest180, align 4
  br label %if.end192

if.else181:                                       ; preds = %if.end175
  %171 = load ptr, ptr %column154, align 8
  %Flags182 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %171, i32 0, i32 0
  %172 = load i32, ptr %Flags182, align 4
  %and183 = and i32 %172, 16
  %tobool184 = icmp ne i32 %and183, 0
  br i1 %tobool184, label %land.lhs.true185, label %if.end191

land.lhs.true185:                                 ; preds = %if.else181
  %173 = load i8, ptr %column_is_resizable157, align 1
  %tobool186 = trunc i8 %173 to i1
  br i1 %tobool186, label %if.end191, label %land.lhs.true187

land.lhs.true187:                                 ; preds = %land.lhs.true185
  %174 = load ptr, ptr %column154, align 8
  %IsRequestOutput = getelementptr inbounds %struct.ImGuiTableColumn, ptr %174, i32 0, i32 31
  %175 = load i8, ptr %IsRequestOutput, align 1
  %tobool188 = trunc i8 %175 to i1
  br i1 %tobool188, label %if.then189, label %if.end191

if.then189:                                       ; preds = %land.lhs.true187
  %176 = load float, ptr %width_auto, align 4
  %177 = load ptr, ptr %column154, align 8
  %WidthRequest190 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %177, i32 0, i32 4
  store float %176, ptr %WidthRequest190, align 4
  br label %if.end191

if.end191:                                        ; preds = %if.then189, %land.lhs.true187, %land.lhs.true185, %if.else181
  br label %if.end192

if.end192:                                        ; preds = %if.end191, %if.then179
  %178 = load ptr, ptr %column154, align 8
  %AutoFitQueue193 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %178, i32 0, i32 35
  %179 = load i8, ptr %AutoFitQueue193, align 1
  %conv194 = zext i8 %179 to i32
  %cmp195 = icmp sgt i32 %conv194, 1
  br i1 %cmp195, label %land.lhs.true196, label %if.end207

land.lhs.true196:                                 ; preds = %if.end192
  %180 = load ptr, ptr %table.addr, align 8
  %IsInitializing = getelementptr inbounds %struct.ImGuiTable, ptr %180, i32 0, i32 94
  %181 = load i8, ptr %IsInitializing, align 8
  %tobool197 = trunc i8 %181 to i1
  br i1 %tobool197, label %land.lhs.true198, label %if.end207

land.lhs.true198:                                 ; preds = %land.lhs.true196
  %182 = load ptr, ptr %column154, align 8
  %IsPreserveWidthAuto199 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %182, i32 0, i32 33
  %183 = load i8, ptr %IsPreserveWidthAuto199, align 1
  %tobool200 = trunc i8 %183 to i1
  br i1 %tobool200, label %if.end207, label %if.then201

if.then201:                                       ; preds = %land.lhs.true198
  %184 = load ptr, ptr %column154, align 8
  %WidthRequest202 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %184, i32 0, i32 4
  %185 = load float, ptr %WidthRequest202, align 4
  %186 = load ptr, ptr %table.addr, align 8
  %MinColumnWidth203 = getelementptr inbounds %struct.ImGuiTable, ptr %186, i32 0, i32 32
  %187 = load float, ptr %MinColumnWidth203, align 8
  %mul204 = fmul float %187, 4.000000e+00
  %call205 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %185, float noundef %mul204)
  %188 = load ptr, ptr %column154, align 8
  %WidthRequest206 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %188, i32 0, i32 4
  store float %call205, ptr %WidthRequest206, align 4
  br label %if.end207

if.end207:                                        ; preds = %if.then201, %land.lhs.true198, %land.lhs.true196, %if.end192
  %189 = load ptr, ptr %column154, align 8
  %WidthRequest208 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %189, i32 0, i32 4
  %190 = load float, ptr %WidthRequest208, align 4
  %191 = load float, ptr %sum_width_requests, align 4
  %add209 = fadd float %191, %190
  store float %add209, ptr %sum_width_requests, align 4
  br label %if.end273

if.else210:                                       ; preds = %if.end153
  %192 = load ptr, ptr %column154, align 8
  %AutoFitQueue211 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %192, i32 0, i32 35
  %193 = load i8, ptr %AutoFitQueue211, align 1
  %conv212 = zext i8 %193 to i32
  %cmp213 = icmp ne i32 %conv212, 0
  br i1 %cmp213, label %if.then219, label %lor.lhs.false214

lor.lhs.false214:                                 ; preds = %if.else210
  %194 = load ptr, ptr %column154, align 8
  %StretchWeight215 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %194, i32 0, i32 6
  %195 = load float, ptr %StretchWeight215, align 4
  %cmp216 = fcmp olt float %195, 0.000000e+00
  br i1 %cmp216, label %if.then219, label %lor.lhs.false217

lor.lhs.false217:                                 ; preds = %lor.lhs.false214
  %196 = load i8, ptr %column_is_resizable157, align 1
  %tobool218 = trunc i8 %196 to i1
  br i1 %tobool218, label %if.end236, label %if.then219

if.then219:                                       ; preds = %lor.lhs.false217, %lor.lhs.false214, %if.else210
  %197 = load ptr, ptr %column154, align 8
  %InitStretchWeightOrWidth220 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %197, i32 0, i32 7
  %198 = load float, ptr %InitStretchWeightOrWidth220, align 4
  %cmp221 = fcmp ogt float %198, 0.000000e+00
  br i1 %cmp221, label %if.then222, label %if.else225

if.then222:                                       ; preds = %if.then219
  %199 = load ptr, ptr %column154, align 8
  %InitStretchWeightOrWidth223 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %199, i32 0, i32 7
  %200 = load float, ptr %InitStretchWeightOrWidth223, align 4
  %201 = load ptr, ptr %column154, align 8
  %StretchWeight224 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %201, i32 0, i32 6
  store float %200, ptr %StretchWeight224, align 4
  br label %if.end235

if.else225:                                       ; preds = %if.then219
  %202 = load i32, ptr %table_sizing_policy, align 4
  %cmp226 = icmp eq i32 %202, 24576
  br i1 %cmp226, label %if.then227, label %if.else232

if.then227:                                       ; preds = %if.else225
  %203 = load ptr, ptr %column154, align 8
  %WidthAuto228 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %203, i32 0, i32 5
  %204 = load float, ptr %WidthAuto228, align 4
  %205 = load float, ptr %stretch_sum_width_auto, align 4
  %div = fdiv float %204, %205
  %206 = load i32, ptr %count_stretch, align 4
  %conv229 = sitofp i32 %206 to float
  %mul230 = fmul float %div, %conv229
  %207 = load ptr, ptr %column154, align 8
  %StretchWeight231 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %207, i32 0, i32 6
  store float %mul230, ptr %StretchWeight231, align 4
  br label %if.end234

if.else232:                                       ; preds = %if.else225
  %208 = load ptr, ptr %column154, align 8
  %StretchWeight233 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %208, i32 0, i32 6
  store float 1.000000e+00, ptr %StretchWeight233, align 4
  br label %if.end234

if.end234:                                        ; preds = %if.else232, %if.then227
  br label %if.end235

if.end235:                                        ; preds = %if.end234, %if.then222
  br label %if.end236

if.end236:                                        ; preds = %if.end235, %lor.lhs.false217
  %209 = load ptr, ptr %column154, align 8
  %StretchWeight237 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %209, i32 0, i32 6
  %210 = load float, ptr %StretchWeight237, align 4
  %211 = load float, ptr %stretch_sum_weights, align 4
  %add238 = fadd float %211, %210
  store float %add238, ptr %stretch_sum_weights, align 4
  %212 = load ptr, ptr %table.addr, align 8
  %LeftMostStretchedColumn239 = getelementptr inbounds %struct.ImGuiTable, ptr %212, i32 0, i32 81
  %213 = load i16, ptr %LeftMostStretchedColumn239, align 8
  %conv240 = sext i16 %213 to i32
  %cmp241 = icmp eq i32 %conv240, -1
  br i1 %cmp241, label %if.then252, label %lor.lhs.false242

lor.lhs.false242:                                 ; preds = %if.end236
  %214 = load ptr, ptr %table.addr, align 8
  %Columns243 = getelementptr inbounds %struct.ImGuiTable, ptr %214, i32 0, i32 4
  %215 = load ptr, ptr %table.addr, align 8
  %LeftMostStretchedColumn244 = getelementptr inbounds %struct.ImGuiTable, ptr %215, i32 0, i32 81
  %216 = load i16, ptr %LeftMostStretchedColumn244, align 8
  %conv245 = sext i16 %216 to i32
  %call246 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns243, i32 noundef %conv245)
  %DisplayOrder247 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %call246, i32 0, i32 18
  %217 = load i16, ptr %DisplayOrder247, align 2
  %conv248 = sext i16 %217 to i32
  %218 = load ptr, ptr %column154, align 8
  %DisplayOrder249 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %218, i32 0, i32 18
  %219 = load i16, ptr %DisplayOrder249, align 2
  %conv250 = sext i16 %219 to i32
  %cmp251 = icmp sgt i32 %conv248, %conv250
  br i1 %cmp251, label %if.then252, label %if.end255

if.then252:                                       ; preds = %lor.lhs.false242, %if.end236
  %220 = load i32, ptr %column_n143, align 4
  %conv253 = trunc i32 %220 to i16
  %221 = load ptr, ptr %table.addr, align 8
  %LeftMostStretchedColumn254 = getelementptr inbounds %struct.ImGuiTable, ptr %221, i32 0, i32 81
  store i16 %conv253, ptr %LeftMostStretchedColumn254, align 8
  br label %if.end255

if.end255:                                        ; preds = %if.then252, %lor.lhs.false242
  %222 = load ptr, ptr %table.addr, align 8
  %RightMostStretchedColumn256 = getelementptr inbounds %struct.ImGuiTable, ptr %222, i32 0, i32 82
  %223 = load i16, ptr %RightMostStretchedColumn256, align 2
  %conv257 = sext i16 %223 to i32
  %cmp258 = icmp eq i32 %conv257, -1
  br i1 %cmp258, label %if.then269, label %lor.lhs.false259

lor.lhs.false259:                                 ; preds = %if.end255
  %224 = load ptr, ptr %table.addr, align 8
  %Columns260 = getelementptr inbounds %struct.ImGuiTable, ptr %224, i32 0, i32 4
  %225 = load ptr, ptr %table.addr, align 8
  %RightMostStretchedColumn261 = getelementptr inbounds %struct.ImGuiTable, ptr %225, i32 0, i32 82
  %226 = load i16, ptr %RightMostStretchedColumn261, align 2
  %conv262 = sext i16 %226 to i32
  %call263 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns260, i32 noundef %conv262)
  %DisplayOrder264 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %call263, i32 0, i32 18
  %227 = load i16, ptr %DisplayOrder264, align 2
  %conv265 = sext i16 %227 to i32
  %228 = load ptr, ptr %column154, align 8
  %DisplayOrder266 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %228, i32 0, i32 18
  %229 = load i16, ptr %DisplayOrder266, align 2
  %conv267 = sext i16 %229 to i32
  %cmp268 = icmp slt i32 %conv265, %conv267
  br i1 %cmp268, label %if.then269, label %if.end272

if.then269:                                       ; preds = %lor.lhs.false259, %if.end255
  %230 = load i32, ptr %column_n143, align 4
  %conv270 = trunc i32 %230 to i16
  %231 = load ptr, ptr %table.addr, align 8
  %RightMostStretchedColumn271 = getelementptr inbounds %struct.ImGuiTable, ptr %231, i32 0, i32 82
  store i16 %conv270, ptr %RightMostStretchedColumn271, align 2
  br label %if.end272

if.end272:                                        ; preds = %if.then269, %lor.lhs.false259
  br label %if.end273

if.end273:                                        ; preds = %if.end272, %if.end207
  %232 = load ptr, ptr %column154, align 8
  %IsPreserveWidthAuto274 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %232, i32 0, i32 33
  store i8 0, ptr %IsPreserveWidthAuto274, align 1
  %233 = load ptr, ptr %table.addr, align 8
  %CellPaddingX = getelementptr inbounds %struct.ImGuiTable, ptr %233, i32 0, i32 34
  %234 = load float, ptr %CellPaddingX, align 8
  %235 = load float, ptr %sum_width_requests, align 4
  %236 = call float @llvm.fmuladd.f32(float %234, float 2.000000e+00, float %235)
  store float %236, ptr %sum_width_requests, align 4
  br label %for.inc276

for.inc276:                                       ; preds = %if.end273, %if.then152
  %237 = load i32, ptr %column_n143, align 4
  %inc277 = add nsw i32 %237, 1
  store i32 %inc277, ptr %column_n143, align 4
  br label %for.cond144, !llvm.loop !17

for.end278:                                       ; preds = %for.cond144
  %238 = load i32, ptr %count_fixed, align 4
  %conv279 = trunc i32 %238 to i16
  %239 = load ptr, ptr %table.addr, align 8
  %ColumnsEnabledFixedCount = getelementptr inbounds %struct.ImGuiTable, ptr %239, i32 0, i32 67
  store i16 %conv279, ptr %ColumnsEnabledFixedCount, align 4
  %240 = load float, ptr %stretch_sum_weights, align 4
  %241 = load ptr, ptr %table.addr, align 8
  %ColumnsStretchSumWeights = getelementptr inbounds %struct.ImGuiTable, ptr %241, i32 0, i32 40
  store float %240, ptr %ColumnsStretchSumWeights, align 8
  %242 = load ptr, ptr %table.addr, align 8
  %WorkRect = getelementptr inbounds %struct.ImGuiTable, ptr %242, i32 0, i32 48
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %work_rect, ptr align 8 %WorkRect, i64 16, i1 false)
  %243 = load ptr, ptr %table.addr, align 8
  %OuterPaddingX = getelementptr inbounds %struct.ImGuiTable, ptr %243, i32 0, i32 33
  %244 = load float, ptr %OuterPaddingX, align 4
  %245 = load ptr, ptr %table.addr, align 8
  %CellSpacingX1 = getelementptr inbounds %struct.ImGuiTable, ptr %245, i32 0, i32 35
  %246 = load float, ptr %CellSpacingX1, align 4
  %247 = load ptr, ptr %table.addr, align 8
  %CellSpacingX2 = getelementptr inbounds %struct.ImGuiTable, ptr %247, i32 0, i32 36
  %248 = load float, ptr %CellSpacingX2, align 8
  %add281 = fadd float %246, %248
  %249 = load ptr, ptr %table.addr, align 8
  %ColumnsEnabledCount282 = getelementptr inbounds %struct.ImGuiTable, ptr %249, i32 0, i32 66
  %250 = load i16, ptr %ColumnsEnabledCount282, align 2
  %conv283 = sext i16 %250 to i32
  %sub = sub nsw i32 %conv283, 1
  %conv284 = sitofp i32 %sub to float
  %mul285 = fmul float %add281, %conv284
  %251 = call float @llvm.fmuladd.f32(float %244, float 2.000000e+00, float %mul285)
  store float %251, ptr %width_spacings, align 4
  %252 = load ptr, ptr %table.addr, align 8
  %HasScrollbarYPrev = getelementptr inbounds %struct.ImGuiTable, ptr %252, i32 0, i32 109
  %253 = load i8, ptr %HasScrollbarYPrev, align 1
  %tobool286 = trunc i8 %253 to i1
  br i1 %tobool286, label %land.lhs.true287, label %cond.false292

land.lhs.true287:                                 ; preds = %for.end278
  %254 = load ptr, ptr %table.addr, align 8
  %InnerWindow288 = getelementptr inbounds %struct.ImGuiTable, ptr %254, i32 0, i32 56
  %255 = load ptr, ptr %InnerWindow288, align 8
  %ScrollbarY = getelementptr inbounds %struct.ImGuiWindow, ptr %255, i32 0, i32 32
  %256 = load i8, ptr %ScrollbarY, align 1
  %tobool289 = trunc i8 %256 to i1
  br i1 %tobool289, label %cond.false292, label %cond.true290

cond.true290:                                     ; preds = %land.lhs.true287
  %257 = load ptr, ptr %g, align 8
  %Style291 = getelementptr inbounds %struct.ImGuiContext, ptr %257, i32 0, i32 3
  %ScrollbarSize = getelementptr inbounds %struct.ImGuiStyle, ptr %Style291, i32 0, i32 21
  %258 = load float, ptr %ScrollbarSize, align 4
  br label %cond.end293

cond.false292:                                    ; preds = %land.lhs.true287, %for.end278
  br label %cond.end293

cond.end293:                                      ; preds = %cond.false292, %cond.true290
  %cond294 = phi float [ %258, %cond.true290 ], [ 0.000000e+00, %cond.false292 ]
  store float %cond294, ptr %width_removed, align 4
  %259 = load ptr, ptr %table.addr, align 8
  %Flags295 = getelementptr inbounds %struct.ImGuiTable, ptr %259, i32 0, i32 1
  %260 = load i32, ptr %Flags295, align 4
  %and296 = and i32 %260, 16777216
  %tobool297 = icmp ne i32 %and296, 0
  br i1 %tobool297, label %land.lhs.true298, label %cond.false302

land.lhs.true298:                                 ; preds = %cond.end293
  %261 = load ptr, ptr %table.addr, align 8
  %InnerWidth = getelementptr inbounds %struct.ImGuiTable, ptr %261, i32 0, i32 37
  %262 = load float, ptr %InnerWidth, align 4
  %cmp299 = fcmp oeq float %262, 0.000000e+00
  br i1 %cmp299, label %cond.true300, label %cond.false302

cond.true300:                                     ; preds = %land.lhs.true298
  %263 = load ptr, ptr %table.addr, align 8
  %InnerClipRect = getelementptr inbounds %struct.ImGuiTable, ptr %263, i32 0, i32 49
  %call301 = call noundef float @_ZNK6ImRect8GetWidthEv(ptr noundef nonnull align 4 dereferenceable(16) %InnerClipRect)
  br label %cond.end304

cond.false302:                                    ; preds = %land.lhs.true298, %cond.end293
  %call303 = call noundef float @_ZNK6ImRect8GetWidthEv(ptr noundef nonnull align 4 dereferenceable(16) %work_rect)
  br label %cond.end304

cond.end304:                                      ; preds = %cond.false302, %cond.true300
  %cond305 = phi float [ %call301, %cond.true300 ], [ %call303, %cond.false302 ]
  %264 = load float, ptr %width_removed, align 4
  %sub306 = fsub float %cond305, %264
  %call307 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef 1.000000e+00, float noundef %sub306)
  store float %call307, ptr %width_avail, align 4
  %265 = load float, ptr %width_avail, align 4
  %266 = load float, ptr %width_spacings, align 4
  %sub308 = fsub float %265, %266
  %267 = load float, ptr %sum_width_requests, align 4
  %sub309 = fsub float %sub308, %267
  store float %sub309, ptr %width_avail_for_stretched_columns, align 4
  %268 = load float, ptr %width_avail_for_stretched_columns, align 4
  store float %268, ptr %width_remaining_for_stretched_columns, align 4
  %269 = load float, ptr %width_spacings, align 4
  %270 = load ptr, ptr %table.addr, align 8
  %CellPaddingX310 = getelementptr inbounds %struct.ImGuiTable, ptr %270, i32 0, i32 34
  %271 = load float, ptr %CellPaddingX310, align 8
  %mul311 = fmul float %271, 2.000000e+00
  %272 = load ptr, ptr %table.addr, align 8
  %ColumnsEnabledCount312 = getelementptr inbounds %struct.ImGuiTable, ptr %272, i32 0, i32 66
  %273 = load i16, ptr %ColumnsEnabledCount312, align 2
  %conv313 = sext i16 %273 to i32
  %conv314 = sitofp i32 %conv313 to float
  %274 = call float @llvm.fmuladd.f32(float %mul311, float %conv314, float %269)
  %275 = load ptr, ptr %table.addr, align 8
  %ColumnsGivenWidth = getelementptr inbounds %struct.ImGuiTable, ptr %275, i32 0, i32 38
  store float %274, ptr %ColumnsGivenWidth, align 8
  store i32 0, ptr %column_n316, align 4
  br label %for.cond317

for.cond317:                                      ; preds = %for.inc367, %cond.end304
  %276 = load i32, ptr %column_n316, align 4
  %277 = load ptr, ptr %table.addr, align 8
  %ColumnsCount318 = getelementptr inbounds %struct.ImGuiTable, ptr %277, i32 0, i32 13
  %278 = load i32, ptr %ColumnsCount318, align 4
  %cmp319 = icmp slt i32 %276, %278
  br i1 %cmp319, label %for.body320, label %for.end369

for.body320:                                      ; preds = %for.cond317
  %279 = load ptr, ptr %table.addr, align 8
  %EnabledMaskByIndex321 = getelementptr inbounds %struct.ImGuiTable, ptr %279, i32 0, i32 8
  %280 = load ptr, ptr %EnabledMaskByIndex321, align 8
  %281 = load i32, ptr %column_n316, align 4
  %shr322 = ashr i32 %281, 5
  %idxprom323 = sext i32 %shr322 to i64
  %arrayidx324 = getelementptr inbounds i32, ptr %280, i64 %idxprom323
  %282 = load i32, ptr %arrayidx324, align 4
  %283 = load i32, ptr %column_n316, align 4
  %and325 = and i32 %283, 31
  %shl326 = shl i32 1, %and325
  %and327 = and i32 %282, %shl326
  %cmp328 = icmp ne i32 %and327, 0
  br i1 %cmp328, label %if.end330, label %if.then329

if.then329:                                       ; preds = %for.body320
  br label %for.inc367

if.end330:                                        ; preds = %for.body320
  %284 = load ptr, ptr %table.addr, align 8
  %Columns332 = getelementptr inbounds %struct.ImGuiTable, ptr %284, i32 0, i32 4
  %285 = load i32, ptr %column_n316, align 4
  %call333 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns332, i32 noundef %285)
  store ptr %call333, ptr %column331, align 8
  %286 = load ptr, ptr %column331, align 8
  %Flags334 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %286, i32 0, i32 0
  %287 = load i32, ptr %Flags334, align 4
  %and335 = and i32 %287, 8
  %tobool336 = icmp ne i32 %and335, 0
  br i1 %tobool336, label %if.then337, label %if.end349

if.then337:                                       ; preds = %if.end330
  %288 = load ptr, ptr %column331, align 8
  %StretchWeight338 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %288, i32 0, i32 6
  %289 = load float, ptr %StretchWeight338, align 4
  %290 = load float, ptr %stretch_sum_weights, align 4
  %div339 = fdiv float %289, %290
  store float %div339, ptr %weight_ratio, align 4
  %291 = load float, ptr %width_avail_for_stretched_columns, align 4
  %292 = load float, ptr %weight_ratio, align 4
  %mul340 = fmul float %291, %292
  %293 = load ptr, ptr %table.addr, align 8
  %MinColumnWidth341 = getelementptr inbounds %struct.ImGuiTable, ptr %293, i32 0, i32 32
  %294 = load float, ptr %MinColumnWidth341, align 8
  %call342 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %mul340, float noundef %294)
  %add343 = fadd float %call342, 0x3F847AE140000000
  %conv344 = fptosi float %add343 to i32
  %conv345 = sitofp i32 %conv344 to float
  %295 = load ptr, ptr %column331, align 8
  %WidthRequest346 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %295, i32 0, i32 4
  store float %conv345, ptr %WidthRequest346, align 4
  %296 = load ptr, ptr %column331, align 8
  %WidthRequest347 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %296, i32 0, i32 4
  %297 = load float, ptr %WidthRequest347, align 4
  %298 = load float, ptr %width_remaining_for_stretched_columns, align 4
  %sub348 = fsub float %298, %297
  store float %sub348, ptr %width_remaining_for_stretched_columns, align 4
  br label %if.end349

if.end349:                                        ; preds = %if.then337, %if.end330
  %299 = load ptr, ptr %column331, align 8
  %NextEnabledColumn350 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %299, i32 0, i32 21
  %300 = load i16, ptr %NextEnabledColumn350, align 4
  %conv351 = sext i16 %300 to i32
  %cmp352 = icmp eq i32 %conv351, -1
  br i1 %cmp352, label %land.lhs.true353, label %if.end359

land.lhs.true353:                                 ; preds = %if.end349
  %301 = load ptr, ptr %table.addr, align 8
  %LeftMostStretchedColumn354 = getelementptr inbounds %struct.ImGuiTable, ptr %301, i32 0, i32 81
  %302 = load i16, ptr %LeftMostStretchedColumn354, align 8
  %conv355 = sext i16 %302 to i32
  %cmp356 = icmp ne i32 %conv355, -1
  br i1 %cmp356, label %if.then357, label %if.end359

if.then357:                                       ; preds = %land.lhs.true353
  %303 = load ptr, ptr %column331, align 8
  %Flags358 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %303, i32 0, i32 0
  %304 = load i32, ptr %Flags358, align 4
  %or = or i32 %304, 1073741824
  store i32 %or, ptr %Flags358, align 4
  br label %if.end359

if.end359:                                        ; preds = %if.then357, %land.lhs.true353, %if.end349
  %305 = load ptr, ptr %column331, align 8
  %WidthRequest360 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %305, i32 0, i32 4
  %306 = load float, ptr %WidthRequest360, align 4
  %307 = load ptr, ptr %table.addr, align 8
  %MinColumnWidth361 = getelementptr inbounds %struct.ImGuiTable, ptr %307, i32 0, i32 32
  %308 = load float, ptr %MinColumnWidth361, align 8
  %call362 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %306, float noundef %308)
  %call363 = call noundef float @_ZL7ImTruncf(float noundef %call362)
  %309 = load ptr, ptr %column331, align 8
  %WidthGiven = getelementptr inbounds %struct.ImGuiTableColumn, ptr %309, i32 0, i32 1
  store float %call363, ptr %WidthGiven, align 4
  %310 = load ptr, ptr %column331, align 8
  %WidthGiven364 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %310, i32 0, i32 1
  %311 = load float, ptr %WidthGiven364, align 4
  %312 = load ptr, ptr %table.addr, align 8
  %ColumnsGivenWidth365 = getelementptr inbounds %struct.ImGuiTable, ptr %312, i32 0, i32 38
  %313 = load float, ptr %ColumnsGivenWidth365, align 8
  %add366 = fadd float %313, %311
  store float %add366, ptr %ColumnsGivenWidth365, align 8
  br label %for.inc367

for.inc367:                                       ; preds = %if.end359, %if.then329
  %314 = load i32, ptr %column_n316, align 4
  %inc368 = add nsw i32 %314, 1
  store i32 %inc368, ptr %column_n316, align 4
  br label %for.cond317, !llvm.loop !18

for.end369:                                       ; preds = %for.cond317
  %315 = load float, ptr %width_remaining_for_stretched_columns, align 4
  %cmp370 = fcmp oge float %315, 1.000000e+00
  br i1 %cmp370, label %land.lhs.true371, label %if.end415

land.lhs.true371:                                 ; preds = %for.end369
  %316 = load ptr, ptr %table.addr, align 8
  %Flags372 = getelementptr inbounds %struct.ImGuiTable, ptr %316, i32 0, i32 1
  %317 = load i32, ptr %Flags372, align 4
  %and373 = and i32 %317, 524288
  %tobool374 = icmp ne i32 %and373, 0
  br i1 %tobool374, label %if.end415, label %if.then375

if.then375:                                       ; preds = %land.lhs.true371
  %318 = load ptr, ptr %table.addr, align 8
  %ColumnsCount377 = getelementptr inbounds %struct.ImGuiTable, ptr %318, i32 0, i32 13
  %319 = load i32, ptr %ColumnsCount377, align 4
  %sub378 = sub nsw i32 %319, 1
  store i32 %sub378, ptr %order_n376, align 4
  br label %for.cond379

for.cond379:                                      ; preds = %for.inc413, %if.then375
  %320 = load float, ptr %stretch_sum_weights, align 4
  %cmp380 = fcmp ogt float %320, 0.000000e+00
  br i1 %cmp380, label %land.lhs.true381, label %land.end385

land.lhs.true381:                                 ; preds = %for.cond379
  %321 = load float, ptr %width_remaining_for_stretched_columns, align 4
  %cmp382 = fcmp oge float %321, 1.000000e+00
  br i1 %cmp382, label %land.rhs383, label %land.end385

land.rhs383:                                      ; preds = %land.lhs.true381
  %322 = load i32, ptr %order_n376, align 4
  %cmp384 = icmp sge i32 %322, 0
  br label %land.end385

land.end385:                                      ; preds = %land.rhs383, %land.lhs.true381, %for.cond379
  %323 = phi i1 [ false, %land.lhs.true381 ], [ false, %for.cond379 ], [ %cmp384, %land.rhs383 ]
  br i1 %323, label %for.body386, label %for.end414

for.body386:                                      ; preds = %land.end385
  %324 = load ptr, ptr %table.addr, align 8
  %EnabledMaskByDisplayOrder387 = getelementptr inbounds %struct.ImGuiTable, ptr %324, i32 0, i32 7
  %325 = load ptr, ptr %EnabledMaskByDisplayOrder387, align 8
  %326 = load i32, ptr %order_n376, align 4
  %shr388 = ashr i32 %326, 5
  %idxprom389 = sext i32 %shr388 to i64
  %arrayidx390 = getelementptr inbounds i32, ptr %325, i64 %idxprom389
  %327 = load i32, ptr %arrayidx390, align 4
  %328 = load i32, ptr %order_n376, align 4
  %and391 = and i32 %328, 31
  %shl392 = shl i32 1, %and391
  %and393 = and i32 %327, %shl392
  %cmp394 = icmp ne i32 %and393, 0
  br i1 %cmp394, label %if.end396, label %if.then395

if.then395:                                       ; preds = %for.body386
  br label %for.inc413

if.end396:                                        ; preds = %for.body386
  %329 = load ptr, ptr %table.addr, align 8
  %Columns398 = getelementptr inbounds %struct.ImGuiTable, ptr %329, i32 0, i32 4
  %330 = load ptr, ptr %table.addr, align 8
  %DisplayOrderToIndex399 = getelementptr inbounds %struct.ImGuiTable, ptr %330, i32 0, i32 5
  %331 = load i32, ptr %order_n376, align 4
  %call400 = call noundef nonnull align 2 dereferenceable(2) ptr @_ZN6ImSpanIsEixEi(ptr noundef nonnull align 8 dereferenceable(16) %DisplayOrderToIndex399, i32 noundef %331)
  %332 = load i16, ptr %call400, align 2
  %conv401 = sext i16 %332 to i32
  %call402 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns398, i32 noundef %conv401)
  store ptr %call402, ptr %column397, align 8
  %333 = load ptr, ptr %column397, align 8
  %Flags403 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %333, i32 0, i32 0
  %334 = load i32, ptr %Flags403, align 4
  %and404 = and i32 %334, 8
  %tobool405 = icmp ne i32 %and404, 0
  br i1 %tobool405, label %if.end407, label %if.then406

if.then406:                                       ; preds = %if.end396
  br label %for.inc413

if.end407:                                        ; preds = %if.end396
  %335 = load ptr, ptr %column397, align 8
  %WidthRequest408 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %335, i32 0, i32 4
  %336 = load float, ptr %WidthRequest408, align 4
  %add409 = fadd float %336, 1.000000e+00
  store float %add409, ptr %WidthRequest408, align 4
  %337 = load ptr, ptr %column397, align 8
  %WidthGiven410 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %337, i32 0, i32 1
  %338 = load float, ptr %WidthGiven410, align 4
  %add411 = fadd float %338, 1.000000e+00
  store float %add411, ptr %WidthGiven410, align 4
  %339 = load float, ptr %width_remaining_for_stretched_columns, align 4
  %sub412 = fsub float %339, 1.000000e+00
  store float %sub412, ptr %width_remaining_for_stretched_columns, align 4
  br label %for.inc413

for.inc413:                                       ; preds = %if.end407, %if.then406, %if.then395
  %340 = load i32, ptr %order_n376, align 4
  %dec = add nsw i32 %340, -1
  store i32 %dec, ptr %order_n376, align 4
  br label %for.cond379, !llvm.loop !19

for.end414:                                       ; preds = %land.end385
  br label %if.end415

if.end415:                                        ; preds = %for.end414, %land.lhs.true371, %for.end369
  %341 = load ptr, ptr %table.addr, align 8
  %342 = load ptr, ptr %table.addr, align 8
  %InstanceCurrent = getelementptr inbounds %struct.ImGuiTable, ptr %342, i32 0, i32 16
  %343 = load i16, ptr %InstanceCurrent, align 8
  %conv416 = sext i16 %343 to i32
  %call417 = call noundef ptr @_ZN5ImGui20TableGetInstanceDataEP10ImGuiTablei(ptr noundef %341, i32 noundef %conv416)
  store ptr %call417, ptr %table_instance, align 8
  %344 = load ptr, ptr %table_instance, align 8
  %HoveredRowNext = getelementptr inbounds %struct.ImGuiTableInstanceData, ptr %344, i32 0, i32 5
  %345 = load i32, ptr %HoveredRowNext, align 4
  %346 = load ptr, ptr %table_instance, align 8
  %HoveredRowLast = getelementptr inbounds %struct.ImGuiTableInstanceData, ptr %346, i32 0, i32 4
  store i32 %345, ptr %HoveredRowLast, align 4
  %347 = load ptr, ptr %table_instance, align 8
  %HoveredRowNext418 = getelementptr inbounds %struct.ImGuiTableInstanceData, ptr %347, i32 0, i32 5
  store i32 -1, ptr %HoveredRowNext418, align 4
  %348 = load ptr, ptr %table.addr, align 8
  %HoveredColumnBorder = getelementptr inbounds %struct.ImGuiTable, ptr %348, i32 0, i32 71
  store i16 -1, ptr %HoveredColumnBorder, align 4
  %349 = load ptr, ptr %table.addr, align 8
  %HoveredColumnBody = getelementptr inbounds %struct.ImGuiTable, ptr %349, i32 0, i32 70
  store i16 -1, ptr %HoveredColumnBody, align 2
  %350 = load ptr, ptr %table.addr, align 8
  %OuterRect = getelementptr inbounds %struct.ImGuiTable, ptr %350, i32 0, i32 46
  %Min = getelementptr inbounds %struct.ImRect, ptr %OuterRect, i32 0, i32 0
  %x419 = getelementptr inbounds %struct.ImVec2, ptr %Min, i32 0, i32 0
  %351 = load float, ptr %x419, align 8
  %352 = load ptr, ptr %table.addr, align 8
  %OuterRect420 = getelementptr inbounds %struct.ImGuiTable, ptr %352, i32 0, i32 46
  %Min421 = getelementptr inbounds %struct.ImRect, ptr %OuterRect420, i32 0, i32 0
  %y = getelementptr inbounds %struct.ImVec2, ptr %Min421, i32 0, i32 1
  %353 = load float, ptr %y, align 4
  %354 = load ptr, ptr %table.addr, align 8
  %OuterRect422 = getelementptr inbounds %struct.ImGuiTable, ptr %354, i32 0, i32 46
  %Max = getelementptr inbounds %struct.ImRect, ptr %OuterRect422, i32 0, i32 1
  %x423 = getelementptr inbounds %struct.ImVec2, ptr %Max, i32 0, i32 0
  %355 = load float, ptr %x423, align 8
  %356 = load ptr, ptr %table.addr, align 8
  %OuterRect424 = getelementptr inbounds %struct.ImGuiTable, ptr %356, i32 0, i32 46
  %Max425 = getelementptr inbounds %struct.ImRect, ptr %OuterRect424, i32 0, i32 1
  %y426 = getelementptr inbounds %struct.ImVec2, ptr %Max425, i32 0, i32 1
  %357 = load float, ptr %y426, align 4
  %358 = load ptr, ptr %table.addr, align 8
  %OuterRect427 = getelementptr inbounds %struct.ImGuiTable, ptr %358, i32 0, i32 46
  %Min428 = getelementptr inbounds %struct.ImRect, ptr %OuterRect427, i32 0, i32 0
  %y429 = getelementptr inbounds %struct.ImVec2, ptr %Min428, i32 0, i32 1
  %359 = load float, ptr %y429, align 4
  %360 = load ptr, ptr %table_instance, align 8
  %LastOuterHeight = getelementptr inbounds %struct.ImGuiTableInstanceData, ptr %360, i32 0, i32 1
  %361 = load float, ptr %LastOuterHeight, align 4
  %add430 = fadd float %359, %361
  %call431 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %357, float noundef %add430)
  call void @_ZN6ImRectC2Effff(ptr noundef nonnull align 4 dereferenceable(16) %mouse_hit_rect, float noundef %351, float noundef %353, float noundef %355, float noundef %call431)
  %362 = load ptr, ptr %g, align 8
  %ActiveId = getelementptr inbounds %struct.ImGuiContext, ptr %362, i32 0, i32 47
  %363 = load i32, ptr %ActiveId, align 4
  store i32 %363, ptr %backup_active_id, align 4
  %364 = load ptr, ptr %g, align 8
  %ActiveId432 = getelementptr inbounds %struct.ImGuiContext, ptr %364, i32 0, i32 47
  store i32 0, ptr %ActiveId432, align 4
  %call433 = call noundef zeroext i1 @_ZN5ImGui13ItemHoverableERK6ImRectji(ptr noundef nonnull align 4 dereferenceable(16) %mouse_hit_rect, i32 noundef 0, i32 noundef 0)
  %frombool434 = zext i1 %call433 to i8
  store i8 %frombool434, ptr %is_hovering_table, align 1
  %365 = load i32, ptr %backup_active_id, align 4
  %366 = load ptr, ptr %g, align 8
  %ActiveId435 = getelementptr inbounds %struct.ImGuiContext, ptr %366, i32 0, i32 47
  store i32 %365, ptr %ActiveId435, align 4
  %367 = load ptr, ptr %g, align 8
  %IO = getelementptr inbounds %struct.ImGuiContext, ptr %367, i32 0, i32 2
  %MousePos = getelementptr inbounds %struct.ImGuiIO, ptr %IO, i32 0, i32 59
  %x436 = getelementptr inbounds %struct.ImVec2, ptr %MousePos, i32 0, i32 0
  %368 = load float, ptr %x436, align 8
  store float %368, ptr %mouse_skewed_x, align 4
  %369 = load ptr, ptr %table.addr, align 8
  %AngledHeadersHeight = getelementptr inbounds %struct.ImGuiTable, ptr %369, i32 0, i32 44
  %370 = load float, ptr %AngledHeadersHeight, align 8
  %cmp437 = fcmp ogt float %370, 0.000000e+00
  br i1 %cmp437, label %if.then438, label %if.end470

if.then438:                                       ; preds = %if.end415
  %371 = load ptr, ptr %g, align 8
  %IO439 = getelementptr inbounds %struct.ImGuiContext, ptr %371, i32 0, i32 2
  %MousePos440 = getelementptr inbounds %struct.ImGuiIO, ptr %IO439, i32 0, i32 59
  %y441 = getelementptr inbounds %struct.ImVec2, ptr %MousePos440, i32 0, i32 1
  %372 = load float, ptr %y441, align 4
  %373 = load ptr, ptr %table.addr, align 8
  %OuterRect442 = getelementptr inbounds %struct.ImGuiTable, ptr %373, i32 0, i32 46
  %Min443 = getelementptr inbounds %struct.ImRect, ptr %OuterRect442, i32 0, i32 0
  %y444 = getelementptr inbounds %struct.ImVec2, ptr %Min443, i32 0, i32 1
  %374 = load float, ptr %y444, align 4
  %cmp445 = fcmp oge float %372, %374
  br i1 %cmp445, label %land.lhs.true446, label %if.end469

land.lhs.true446:                                 ; preds = %if.then438
  %375 = load ptr, ptr %g, align 8
  %IO447 = getelementptr inbounds %struct.ImGuiContext, ptr %375, i32 0, i32 2
  %MousePos448 = getelementptr inbounds %struct.ImGuiIO, ptr %IO447, i32 0, i32 59
  %y449 = getelementptr inbounds %struct.ImVec2, ptr %MousePos448, i32 0, i32 1
  %376 = load float, ptr %y449, align 4
  %377 = load ptr, ptr %table.addr, align 8
  %OuterRect450 = getelementptr inbounds %struct.ImGuiTable, ptr %377, i32 0, i32 46
  %Min451 = getelementptr inbounds %struct.ImRect, ptr %OuterRect450, i32 0, i32 0
  %y452 = getelementptr inbounds %struct.ImVec2, ptr %Min451, i32 0, i32 1
  %378 = load float, ptr %y452, align 4
  %379 = load ptr, ptr %table.addr, align 8
  %AngledHeadersHeight453 = getelementptr inbounds %struct.ImGuiTable, ptr %379, i32 0, i32 44
  %380 = load float, ptr %AngledHeadersHeight453, align 8
  %add454 = fadd float %378, %380
  %cmp455 = fcmp ole float %376, %add454
  br i1 %cmp455, label %if.then456, label %if.end469

if.then456:                                       ; preds = %land.lhs.true446
  %381 = load ptr, ptr %table.addr, align 8
  %OuterRect457 = getelementptr inbounds %struct.ImGuiTable, ptr %381, i32 0, i32 46
  %Min458 = getelementptr inbounds %struct.ImRect, ptr %OuterRect457, i32 0, i32 0
  %y459 = getelementptr inbounds %struct.ImVec2, ptr %Min458, i32 0, i32 1
  %382 = load float, ptr %y459, align 4
  %383 = load ptr, ptr %table.addr, align 8
  %AngledHeadersHeight460 = getelementptr inbounds %struct.ImGuiTable, ptr %383, i32 0, i32 44
  %384 = load float, ptr %AngledHeadersHeight460, align 8
  %add461 = fadd float %382, %384
  %385 = load ptr, ptr %g, align 8
  %IO462 = getelementptr inbounds %struct.ImGuiContext, ptr %385, i32 0, i32 2
  %MousePos463 = getelementptr inbounds %struct.ImGuiIO, ptr %IO462, i32 0, i32 59
  %y464 = getelementptr inbounds %struct.ImVec2, ptr %MousePos463, i32 0, i32 1
  %386 = load float, ptr %y464, align 4
  %sub465 = fsub float %add461, %386
  %387 = load ptr, ptr %table.addr, align 8
  %AngledHeadersSlope = getelementptr inbounds %struct.ImGuiTable, ptr %387, i32 0, i32 45
  %388 = load float, ptr %AngledHeadersSlope, align 4
  %mul466 = fmul float %sub465, %388
  %call467 = call noundef float @_ZL7ImTruncf(float noundef %mul466)
  %389 = load float, ptr %mouse_skewed_x, align 4
  %add468 = fadd float %389, %call467
  store float %add468, ptr %mouse_skewed_x, align 4
  br label %if.end469

if.end469:                                        ; preds = %if.then456, %land.lhs.true446, %if.then438
  br label %if.end470

if.end470:                                        ; preds = %if.end469, %if.end415
  store i32 0, ptr %visible_n, align 4
  store i8 0, ptr %has_at_least_one_column_requesting_output, align 1
  %390 = load ptr, ptr %table.addr, align 8
  %FreezeColumnsCount = getelementptr inbounds %struct.ImGuiTable, ptr %390, i32 0, i32 87
  %391 = load i16, ptr %FreezeColumnsCount, align 4
  %conv471 = sext i16 %391 to i32
  %cmp472 = icmp sgt i32 %conv471, 0
  %frombool473 = zext i1 %cmp472 to i8
  store i8 %frombool473, ptr %offset_x_frozen, align 1
  %392 = load ptr, ptr %table.addr, align 8
  %FreezeColumnsCount474 = getelementptr inbounds %struct.ImGuiTable, ptr %392, i32 0, i32 87
  %393 = load i16, ptr %FreezeColumnsCount474, align 4
  %conv475 = sext i16 %393 to i32
  %cmp476 = icmp sgt i32 %conv475, 0
  br i1 %cmp476, label %cond.true477, label %cond.false481

cond.true477:                                     ; preds = %if.end470
  %394 = load ptr, ptr %table.addr, align 8
  %OuterRect478 = getelementptr inbounds %struct.ImGuiTable, ptr %394, i32 0, i32 46
  %Min479 = getelementptr inbounds %struct.ImRect, ptr %OuterRect478, i32 0, i32 0
  %x480 = getelementptr inbounds %struct.ImVec2, ptr %Min479, i32 0, i32 0
  %395 = load float, ptr %x480, align 8
  br label %cond.end484

cond.false481:                                    ; preds = %if.end470
  %Min482 = getelementptr inbounds %struct.ImRect, ptr %work_rect, i32 0, i32 0
  %x483 = getelementptr inbounds %struct.ImVec2, ptr %Min482, i32 0, i32 0
  %396 = load float, ptr %x483, align 4
  br label %cond.end484

cond.end484:                                      ; preds = %cond.false481, %cond.true477
  %cond485 = phi float [ %395, %cond.true477 ], [ %396, %cond.false481 ]
  %397 = load ptr, ptr %table.addr, align 8
  %OuterPaddingX486 = getelementptr inbounds %struct.ImGuiTable, ptr %397, i32 0, i32 33
  %398 = load float, ptr %OuterPaddingX486, align 4
  %add487 = fadd float %cond485, %398
  %399 = load ptr, ptr %table.addr, align 8
  %CellSpacingX1488 = getelementptr inbounds %struct.ImGuiTable, ptr %399, i32 0, i32 35
  %400 = load float, ptr %CellSpacingX1488, align 4
  %sub489 = fsub float %add487, %400
  store float %sub489, ptr %offset_x, align 4
  %401 = load ptr, ptr %table.addr, align 8
  %InnerClipRect490 = getelementptr inbounds %struct.ImGuiTable, ptr %401, i32 0, i32 49
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %host_clip_rect, ptr align 8 %InnerClipRect490, i64 16, i1 false)
  %402 = load ptr, ptr %table.addr, align 8
  %VisibleMaskByIndex = getelementptr inbounds %struct.ImGuiTable, ptr %402, i32 0, i32 9
  %403 = load ptr, ptr %VisibleMaskByIndex, align 8
  %404 = load ptr, ptr %table.addr, align 8
  %ColumnsCount491 = getelementptr inbounds %struct.ImGuiTable, ptr %404, i32 0, i32 13
  %405 = load i32, ptr %ColumnsCount491, align 4
  call void @_Z22ImBitArrayClearAllBitsPji(ptr noundef %403, i32 noundef %405)
  store i32 0, ptr %order_n492, align 4
  br label %for.cond493

for.cond493:                                      ; preds = %for.inc722, %cond.end484
  %406 = load i32, ptr %order_n492, align 4
  %407 = load ptr, ptr %table.addr, align 8
  %ColumnsCount494 = getelementptr inbounds %struct.ImGuiTable, ptr %407, i32 0, i32 13
  %408 = load i32, ptr %ColumnsCount494, align 4
  %cmp495 = icmp slt i32 %406, %408
  br i1 %cmp495, label %for.body496, label %for.end724

for.body496:                                      ; preds = %for.cond493
  %409 = load ptr, ptr %table.addr, align 8
  %DisplayOrderToIndex498 = getelementptr inbounds %struct.ImGuiTable, ptr %409, i32 0, i32 5
  %410 = load i32, ptr %order_n492, align 4
  %call499 = call noundef nonnull align 2 dereferenceable(2) ptr @_ZN6ImSpanIsEixEi(ptr noundef nonnull align 8 dereferenceable(16) %DisplayOrderToIndex498, i32 noundef %410)
  %411 = load i16, ptr %call499, align 2
  %conv500 = sext i16 %411 to i32
  store i32 %conv500, ptr %column_n497, align 4
  %412 = load ptr, ptr %table.addr, align 8
  %Columns502 = getelementptr inbounds %struct.ImGuiTable, ptr %412, i32 0, i32 4
  %413 = load i32, ptr %column_n497, align 4
  %call503 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns502, i32 noundef %413)
  store ptr %call503, ptr %column501, align 8
  %414 = load ptr, ptr %table.addr, align 8
  %FreezeRowsCount = getelementptr inbounds %struct.ImGuiTable, ptr %414, i32 0, i32 85
  %415 = load i16, ptr %FreezeRowsCount, align 8
  %conv504 = sext i16 %415 to i32
  %cmp505 = icmp sgt i32 %conv504, 0
  %cond506 = select i1 %cmp505, i32 1, i32 0
  %conv507 = trunc i32 %cond506 to i8
  %416 = load ptr, ptr %column501, align 8
  %NavLayerCurrent = getelementptr inbounds %struct.ImGuiTableColumn, ptr %416, i32 0, i32 34
  store i8 %conv507, ptr %NavLayerCurrent, align 2
  %417 = load i8, ptr %offset_x_frozen, align 1
  %tobool508 = trunc i8 %417 to i1
  br i1 %tobool508, label %land.lhs.true509, label %if.end521

land.lhs.true509:                                 ; preds = %for.body496
  %418 = load ptr, ptr %table.addr, align 8
  %FreezeColumnsCount510 = getelementptr inbounds %struct.ImGuiTable, ptr %418, i32 0, i32 87
  %419 = load i16, ptr %FreezeColumnsCount510, align 4
  %conv511 = sext i16 %419 to i32
  %420 = load i32, ptr %visible_n, align 4
  %cmp512 = icmp eq i32 %conv511, %420
  br i1 %cmp512, label %if.then513, label %if.end521

if.then513:                                       ; preds = %land.lhs.true509
  %Min514 = getelementptr inbounds %struct.ImRect, ptr %work_rect, i32 0, i32 0
  %x515 = getelementptr inbounds %struct.ImVec2, ptr %Min514, i32 0, i32 0
  %421 = load float, ptr %x515, align 4
  %422 = load ptr, ptr %table.addr, align 8
  %OuterRect516 = getelementptr inbounds %struct.ImGuiTable, ptr %422, i32 0, i32 46
  %Min517 = getelementptr inbounds %struct.ImRect, ptr %OuterRect516, i32 0, i32 0
  %x518 = getelementptr inbounds %struct.ImVec2, ptr %Min517, i32 0, i32 0
  %423 = load float, ptr %x518, align 8
  %sub519 = fsub float %421, %423
  %424 = load float, ptr %offset_x, align 4
  %add520 = fadd float %424, %sub519
  store float %add520, ptr %offset_x, align 4
  store i8 0, ptr %offset_x_frozen, align 1
  br label %if.end521

if.end521:                                        ; preds = %if.then513, %land.lhs.true509, %for.body496
  %425 = load ptr, ptr %column501, align 8
  %Flags522 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %425, i32 0, i32 0
  %426 = load i32, ptr %Flags522, align 4
  %and523 = and i32 %426, -251658241
  store i32 %and523, ptr %Flags522, align 4
  %427 = load ptr, ptr %table.addr, align 8
  %EnabledMaskByDisplayOrder524 = getelementptr inbounds %struct.ImGuiTable, ptr %427, i32 0, i32 7
  %428 = load ptr, ptr %EnabledMaskByDisplayOrder524, align 8
  %429 = load i32, ptr %order_n492, align 4
  %shr525 = ashr i32 %429, 5
  %idxprom526 = sext i32 %shr525 to i64
  %arrayidx527 = getelementptr inbounds i32, ptr %428, i64 %idxprom526
  %430 = load i32, ptr %arrayidx527, align 4
  %431 = load i32, ptr %order_n492, align 4
  %and528 = and i32 %431, 31
  %shl529 = shl i32 1, %and528
  %and530 = and i32 %430, %shl529
  %cmp531 = icmp ne i32 %and530, 0
  br i1 %cmp531, label %if.end549, label %if.then532

if.then532:                                       ; preds = %if.end521
  %432 = load float, ptr %offset_x, align 4
  %433 = load ptr, ptr %column501, align 8
  %ClipRect = getelementptr inbounds %struct.ImGuiTableColumn, ptr %433, i32 0, i32 8
  %Max533 = getelementptr inbounds %struct.ImRect, ptr %ClipRect, i32 0, i32 1
  %x534 = getelementptr inbounds %struct.ImVec2, ptr %Max533, i32 0, i32 0
  store float %432, ptr %x534, align 4
  %434 = load ptr, ptr %column501, align 8
  %ClipRect535 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %434, i32 0, i32 8
  %Min536 = getelementptr inbounds %struct.ImRect, ptr %ClipRect535, i32 0, i32 0
  %x537 = getelementptr inbounds %struct.ImVec2, ptr %Min536, i32 0, i32 0
  store float %432, ptr %x537, align 4
  %435 = load ptr, ptr %column501, align 8
  %WorkMinX = getelementptr inbounds %struct.ImGuiTableColumn, ptr %435, i32 0, i32 10
  store float %432, ptr %WorkMinX, align 4
  %436 = load ptr, ptr %column501, align 8
  %MaxX = getelementptr inbounds %struct.ImGuiTableColumn, ptr %436, i32 0, i32 3
  store float %432, ptr %MaxX, align 4
  %437 = load ptr, ptr %column501, align 8
  %MinX = getelementptr inbounds %struct.ImGuiTableColumn, ptr %437, i32 0, i32 2
  store float %432, ptr %MinX, align 4
  %438 = load ptr, ptr %column501, align 8
  %WidthGiven538 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %438, i32 0, i32 1
  store float 0.000000e+00, ptr %WidthGiven538, align 4
  %Min539 = getelementptr inbounds %struct.ImRect, ptr %work_rect, i32 0, i32 0
  %y540 = getelementptr inbounds %struct.ImVec2, ptr %Min539, i32 0, i32 1
  %439 = load float, ptr %y540, align 4
  %440 = load ptr, ptr %column501, align 8
  %ClipRect541 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %440, i32 0, i32 8
  %Min542 = getelementptr inbounds %struct.ImRect, ptr %ClipRect541, i32 0, i32 0
  %y543 = getelementptr inbounds %struct.ImVec2, ptr %Min542, i32 0, i32 1
  store float %439, ptr %y543, align 4
  %441 = load ptr, ptr %column501, align 8
  %ClipRect544 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %441, i32 0, i32 8
  %Max545 = getelementptr inbounds %struct.ImRect, ptr %ClipRect544, i32 0, i32 1
  %y546 = getelementptr inbounds %struct.ImVec2, ptr %Max545, i32 0, i32 1
  store float 0x47EFFFFFE0000000, ptr %y546, align 4
  %442 = load ptr, ptr %column501, align 8
  %ClipRect547 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %442, i32 0, i32 8
  call void @_ZN6ImRect12ClipWithFullERKS_(ptr noundef nonnull align 4 dereferenceable(16) %ClipRect547, ptr noundef nonnull align 4 dereferenceable(16) %host_clip_rect)
  %443 = load ptr, ptr %column501, align 8
  %IsRequestOutput548 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %443, i32 0, i32 31
  store i8 0, ptr %IsRequestOutput548, align 1
  %444 = load ptr, ptr %column501, align 8
  %IsVisibleY = getelementptr inbounds %struct.ImGuiTableColumn, ptr %444, i32 0, i32 30
  store i8 0, ptr %IsVisibleY, align 2
  %445 = load ptr, ptr %column501, align 8
  %IsVisibleX = getelementptr inbounds %struct.ImGuiTableColumn, ptr %445, i32 0, i32 29
  store i8 0, ptr %IsVisibleX, align 1
  %446 = load ptr, ptr %column501, align 8
  %IsSkipItems = getelementptr inbounds %struct.ImGuiTableColumn, ptr %446, i32 0, i32 32
  store i8 1, ptr %IsSkipItems, align 4
  %447 = load ptr, ptr %column501, align 8
  %ItemWidth = getelementptr inbounds %struct.ImGuiTableColumn, ptr %447, i32 0, i32 12
  store float 1.000000e+00, ptr %ItemWidth, align 4
  br label %for.inc722

if.end549:                                        ; preds = %if.end521
  %448 = load i8, ptr %is_hovering_table, align 1
  %tobool550 = trunc i8 %448 to i1
  br i1 %tobool550, label %land.lhs.true551, label %if.end564

land.lhs.true551:                                 ; preds = %if.end549
  %449 = load float, ptr %mouse_skewed_x, align 4
  %450 = load ptr, ptr %column501, align 8
  %ClipRect552 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %450, i32 0, i32 8
  %Min553 = getelementptr inbounds %struct.ImRect, ptr %ClipRect552, i32 0, i32 0
  %x554 = getelementptr inbounds %struct.ImVec2, ptr %Min553, i32 0, i32 0
  %451 = load float, ptr %x554, align 4
  %cmp555 = fcmp oge float %449, %451
  br i1 %cmp555, label %land.lhs.true556, label %if.end564

land.lhs.true556:                                 ; preds = %land.lhs.true551
  %452 = load float, ptr %mouse_skewed_x, align 4
  %453 = load ptr, ptr %column501, align 8
  %ClipRect557 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %453, i32 0, i32 8
  %Max558 = getelementptr inbounds %struct.ImRect, ptr %ClipRect557, i32 0, i32 1
  %x559 = getelementptr inbounds %struct.ImVec2, ptr %Max558, i32 0, i32 0
  %454 = load float, ptr %x559, align 4
  %cmp560 = fcmp olt float %452, %454
  br i1 %cmp560, label %if.then561, label %if.end564

if.then561:                                       ; preds = %land.lhs.true556
  %455 = load i32, ptr %column_n497, align 4
  %conv562 = trunc i32 %455 to i16
  %456 = load ptr, ptr %table.addr, align 8
  %HoveredColumnBody563 = getelementptr inbounds %struct.ImGuiTable, ptr %456, i32 0, i32 70
  store i16 %conv562, ptr %HoveredColumnBody563, align 2
  br label %if.end564

if.end564:                                        ; preds = %if.then561, %land.lhs.true556, %land.lhs.true551, %if.end549
  %457 = load float, ptr %offset_x, align 4
  %458 = load ptr, ptr %column501, align 8
  %MinX565 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %458, i32 0, i32 2
  store float %457, ptr %MinX565, align 4
  %459 = load ptr, ptr %table.addr, align 8
  %460 = load i32, ptr %column_n497, align 4
  %call566 = call noundef float @_ZN5ImGui22TableGetMaxColumnWidthEPK10ImGuiTablei(ptr noundef %459, i32 noundef %460)
  store float %call566, ptr %max_width, align 4
  %461 = load ptr, ptr %column501, align 8
  %WidthGiven567 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %461, i32 0, i32 1
  %462 = load float, ptr %WidthGiven567, align 4
  %463 = load float, ptr %max_width, align 4
  %call568 = call noundef float @_ZL5ImMinIfET_S0_S0_(float noundef %462, float noundef %463)
  %464 = load ptr, ptr %column501, align 8
  %WidthGiven569 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %464, i32 0, i32 1
  store float %call568, ptr %WidthGiven569, align 4
  %465 = load ptr, ptr %column501, align 8
  %WidthGiven570 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %465, i32 0, i32 1
  %466 = load float, ptr %WidthGiven570, align 4
  %467 = load ptr, ptr %column501, align 8
  %WidthRequest571 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %467, i32 0, i32 4
  %468 = load float, ptr %WidthRequest571, align 4
  %469 = load ptr, ptr %table.addr, align 8
  %MinColumnWidth572 = getelementptr inbounds %struct.ImGuiTable, ptr %469, i32 0, i32 32
  %470 = load float, ptr %MinColumnWidth572, align 8
  %call573 = call noundef float @_ZL5ImMinIfET_S0_S0_(float noundef %468, float noundef %470)
  %call574 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %466, float noundef %call573)
  %471 = load ptr, ptr %column501, align 8
  %WidthGiven575 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %471, i32 0, i32 1
  store float %call574, ptr %WidthGiven575, align 4
  %472 = load float, ptr %offset_x, align 4
  %473 = load ptr, ptr %column501, align 8
  %WidthGiven576 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %473, i32 0, i32 1
  %474 = load float, ptr %WidthGiven576, align 4
  %add577 = fadd float %472, %474
  %475 = load ptr, ptr %table.addr, align 8
  %CellSpacingX1578 = getelementptr inbounds %struct.ImGuiTable, ptr %475, i32 0, i32 35
  %476 = load float, ptr %CellSpacingX1578, align 4
  %add579 = fadd float %add577, %476
  %477 = load ptr, ptr %table.addr, align 8
  %CellSpacingX2580 = getelementptr inbounds %struct.ImGuiTable, ptr %477, i32 0, i32 36
  %478 = load float, ptr %CellSpacingX2580, align 8
  %add581 = fadd float %add579, %478
  %479 = load ptr, ptr %table.addr, align 8
  %CellPaddingX582 = getelementptr inbounds %struct.ImGuiTable, ptr %479, i32 0, i32 34
  %480 = load float, ptr %CellPaddingX582, align 8
  %481 = call float @llvm.fmuladd.f32(float %480, float 2.000000e+00, float %add581)
  %482 = load ptr, ptr %column501, align 8
  %MaxX584 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %482, i32 0, i32 3
  store float %481, ptr %MaxX584, align 4
  %483 = load ptr, ptr %column501, align 8
  %MinX585 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %483, i32 0, i32 2
  %484 = load float, ptr %MinX585, align 4
  %485 = load ptr, ptr %table.addr, align 8
  %CellPaddingX586 = getelementptr inbounds %struct.ImGuiTable, ptr %485, i32 0, i32 34
  %486 = load float, ptr %CellPaddingX586, align 8
  %add587 = fadd float %484, %486
  %487 = load ptr, ptr %table.addr, align 8
  %CellSpacingX1588 = getelementptr inbounds %struct.ImGuiTable, ptr %487, i32 0, i32 35
  %488 = load float, ptr %CellSpacingX1588, align 4
  %add589 = fadd float %add587, %488
  %489 = load ptr, ptr %column501, align 8
  %WorkMinX590 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %489, i32 0, i32 10
  store float %add589, ptr %WorkMinX590, align 4
  %490 = load ptr, ptr %column501, align 8
  %MaxX591 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %490, i32 0, i32 3
  %491 = load float, ptr %MaxX591, align 4
  %492 = load ptr, ptr %table.addr, align 8
  %CellPaddingX592 = getelementptr inbounds %struct.ImGuiTable, ptr %492, i32 0, i32 34
  %493 = load float, ptr %CellPaddingX592, align 8
  %sub593 = fsub float %491, %493
  %494 = load ptr, ptr %table.addr, align 8
  %CellSpacingX2594 = getelementptr inbounds %struct.ImGuiTable, ptr %494, i32 0, i32 36
  %495 = load float, ptr %CellSpacingX2594, align 8
  %sub595 = fsub float %sub593, %495
  %496 = load ptr, ptr %column501, align 8
  %WorkMaxX = getelementptr inbounds %struct.ImGuiTableColumn, ptr %496, i32 0, i32 11
  store float %sub595, ptr %WorkMaxX, align 4
  %497 = load ptr, ptr %column501, align 8
  %WidthGiven596 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %497, i32 0, i32 1
  %498 = load float, ptr %WidthGiven596, align 4
  %mul597 = fmul float %498, 0x3FE4CCCCC0000000
  %call598 = call noundef float @_ZL7ImTruncf(float noundef %mul597)
  %499 = load ptr, ptr %column501, align 8
  %ItemWidth599 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %499, i32 0, i32 12
  store float %call598, ptr %ItemWidth599, align 4
  %500 = load ptr, ptr %column501, align 8
  %MinX600 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %500, i32 0, i32 2
  %501 = load float, ptr %MinX600, align 4
  %502 = load ptr, ptr %column501, align 8
  %ClipRect601 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %502, i32 0, i32 8
  %Min602 = getelementptr inbounds %struct.ImRect, ptr %ClipRect601, i32 0, i32 0
  %x603 = getelementptr inbounds %struct.ImVec2, ptr %Min602, i32 0, i32 0
  store float %501, ptr %x603, align 4
  %Min604 = getelementptr inbounds %struct.ImRect, ptr %work_rect, i32 0, i32 0
  %y605 = getelementptr inbounds %struct.ImVec2, ptr %Min604, i32 0, i32 1
  %503 = load float, ptr %y605, align 4
  %504 = load ptr, ptr %column501, align 8
  %ClipRect606 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %504, i32 0, i32 8
  %Min607 = getelementptr inbounds %struct.ImRect, ptr %ClipRect606, i32 0, i32 0
  %y608 = getelementptr inbounds %struct.ImVec2, ptr %Min607, i32 0, i32 1
  store float %503, ptr %y608, align 4
  %505 = load ptr, ptr %column501, align 8
  %MaxX609 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %505, i32 0, i32 3
  %506 = load float, ptr %MaxX609, align 4
  %507 = load ptr, ptr %column501, align 8
  %ClipRect610 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %507, i32 0, i32 8
  %Max611 = getelementptr inbounds %struct.ImRect, ptr %ClipRect610, i32 0, i32 1
  %x612 = getelementptr inbounds %struct.ImVec2, ptr %Max611, i32 0, i32 0
  store float %506, ptr %x612, align 4
  %508 = load ptr, ptr %column501, align 8
  %ClipRect613 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %508, i32 0, i32 8
  %Max614 = getelementptr inbounds %struct.ImRect, ptr %ClipRect613, i32 0, i32 1
  %y615 = getelementptr inbounds %struct.ImVec2, ptr %Max614, i32 0, i32 1
  store float 0x47EFFFFFE0000000, ptr %y615, align 4
  %509 = load ptr, ptr %column501, align 8
  %ClipRect616 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %509, i32 0, i32 8
  call void @_ZN6ImRect12ClipWithFullERKS_(ptr noundef nonnull align 4 dereferenceable(16) %ClipRect616, ptr noundef nonnull align 4 dereferenceable(16) %host_clip_rect)
  %510 = load ptr, ptr %column501, align 8
  %ClipRect617 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %510, i32 0, i32 8
  %Max618 = getelementptr inbounds %struct.ImRect, ptr %ClipRect617, i32 0, i32 1
  %x619 = getelementptr inbounds %struct.ImVec2, ptr %Max618, i32 0, i32 0
  %511 = load float, ptr %x619, align 4
  %512 = load ptr, ptr %column501, align 8
  %ClipRect620 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %512, i32 0, i32 8
  %Min621 = getelementptr inbounds %struct.ImRect, ptr %ClipRect620, i32 0, i32 0
  %x622 = getelementptr inbounds %struct.ImVec2, ptr %Min621, i32 0, i32 0
  %513 = load float, ptr %x622, align 4
  %cmp623 = fcmp ogt float %511, %513
  %514 = load ptr, ptr %column501, align 8
  %IsVisibleX624 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %514, i32 0, i32 29
  %frombool625 = zext i1 %cmp623 to i8
  store i8 %frombool625, ptr %IsVisibleX624, align 1
  %515 = load ptr, ptr %column501, align 8
  %IsVisibleY626 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %515, i32 0, i32 30
  store i8 1, ptr %IsVisibleY626, align 2
  %516 = load ptr, ptr %column501, align 8
  %IsVisibleX627 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %516, i32 0, i32 29
  %517 = load i8, ptr %IsVisibleX627, align 1
  %tobool628 = trunc i8 %517 to i1
  %frombool629 = zext i1 %tobool628 to i8
  store i8 %frombool629, ptr %is_visible, align 1
  %518 = load i8, ptr %is_visible, align 1
  %tobool630 = trunc i8 %518 to i1
  br i1 %tobool630, label %if.then631, label %if.end633

if.then631:                                       ; preds = %if.end564
  %519 = load ptr, ptr %table.addr, align 8
  %VisibleMaskByIndex632 = getelementptr inbounds %struct.ImGuiTable, ptr %519, i32 0, i32 9
  %520 = load ptr, ptr %VisibleMaskByIndex632, align 8
  %521 = load i32, ptr %column_n497, align 4
  call void @_Z16ImBitArraySetBitPji(ptr noundef %520, i32 noundef %521)
  br label %if.end633

if.end633:                                        ; preds = %if.then631, %if.end564
  %522 = load i8, ptr %is_visible, align 1
  %tobool634 = trunc i8 %522 to i1
  br i1 %tobool634, label %lor.end, label %lor.lhs.false635

lor.lhs.false635:                                 ; preds = %if.end633
  %523 = load ptr, ptr %column501, align 8
  %AutoFitQueue636 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %523, i32 0, i32 35
  %524 = load i8, ptr %AutoFitQueue636, align 1
  %conv637 = zext i8 %524 to i32
  %cmp638 = icmp ne i32 %conv637, 0
  br i1 %cmp638, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false635
  %525 = load ptr, ptr %column501, align 8
  %CannotSkipItemsQueue639 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %525, i32 0, i32 36
  %526 = load i8, ptr %CannotSkipItemsQueue639, align 4
  %conv640 = zext i8 %526 to i32
  %cmp641 = icmp ne i32 %conv640, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false635, %if.end633
  %527 = phi i1 [ true, %lor.lhs.false635 ], [ true, %if.end633 ], [ %cmp641, %lor.rhs ]
  %528 = load ptr, ptr %column501, align 8
  %IsRequestOutput642 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %528, i32 0, i32 31
  %frombool643 = zext i1 %527 to i8
  store i8 %frombool643, ptr %IsRequestOutput642, align 1
  %529 = load ptr, ptr %column501, align 8
  %IsEnabled644 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %529, i32 0, i32 26
  %530 = load i8, ptr %IsEnabled644, align 2
  %tobool645 = trunc i8 %530 to i1
  br i1 %tobool645, label %lor.rhs646, label %lor.end648

lor.rhs646:                                       ; preds = %lor.end
  %531 = load ptr, ptr %table.addr, align 8
  %HostSkipItems = getelementptr inbounds %struct.ImGuiTable, ptr %531, i32 0, i32 111
  %532 = load i8, ptr %HostSkipItems, align 1
  %tobool647 = trunc i8 %532 to i1
  br label %lor.end648

lor.end648:                                       ; preds = %lor.rhs646, %lor.end
  %533 = phi i1 [ true, %lor.end ], [ %tobool647, %lor.rhs646 ]
  %534 = load ptr, ptr %column501, align 8
  %IsSkipItems649 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %534, i32 0, i32 32
  %frombool650 = zext i1 %533 to i8
  store i8 %frombool650, ptr %IsSkipItems649, align 4
  %535 = load ptr, ptr %column501, align 8
  %IsSkipItems651 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %535, i32 0, i32 32
  %536 = load i8, ptr %IsSkipItems651, align 4
  %tobool652 = trunc i8 %536 to i1
  br i1 %tobool652, label %if.then653, label %if.end654

if.then653:                                       ; preds = %lor.end648
  br label %if.end654

if.end654:                                        ; preds = %if.then653, %lor.end648
  %537 = load ptr, ptr %column501, align 8
  %IsRequestOutput655 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %537, i32 0, i32 31
  %538 = load i8, ptr %IsRequestOutput655, align 1
  %tobool656 = trunc i8 %538 to i1
  br i1 %tobool656, label %land.lhs.true657, label %if.end661

land.lhs.true657:                                 ; preds = %if.end654
  %539 = load ptr, ptr %column501, align 8
  %IsSkipItems658 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %539, i32 0, i32 32
  %540 = load i8, ptr %IsSkipItems658, align 4
  %tobool659 = trunc i8 %540 to i1
  br i1 %tobool659, label %if.end661, label %if.then660

if.then660:                                       ; preds = %land.lhs.true657
  store i8 1, ptr %has_at_least_one_column_requesting_output, align 1
  br label %if.end661

if.end661:                                        ; preds = %if.then660, %land.lhs.true657, %if.end654
  %541 = load ptr, ptr %column501, align 8
  %Flags662 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %541, i32 0, i32 0
  %542 = load i32, ptr %Flags662, align 4
  %or663 = or i32 %542, 16777216
  store i32 %or663, ptr %Flags662, align 4
  %543 = load i8, ptr %is_visible, align 1
  %tobool664 = trunc i8 %543 to i1
  br i1 %tobool664, label %if.then665, label %if.end668

if.then665:                                       ; preds = %if.end661
  %544 = load ptr, ptr %column501, align 8
  %Flags666 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %544, i32 0, i32 0
  %545 = load i32, ptr %Flags666, align 4
  %or667 = or i32 %545, 33554432
  store i32 %or667, ptr %Flags666, align 4
  br label %if.end668

if.end668:                                        ; preds = %if.then665, %if.end661
  %546 = load ptr, ptr %column501, align 8
  %SortOrder669 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %546, i32 0, i32 22
  %547 = load i16, ptr %SortOrder669, align 2
  %conv670 = sext i16 %547 to i32
  %cmp671 = icmp ne i32 %conv670, -1
  br i1 %cmp671, label %if.then672, label %if.end675

if.then672:                                       ; preds = %if.end668
  %548 = load ptr, ptr %column501, align 8
  %Flags673 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %548, i32 0, i32 0
  %549 = load i32, ptr %Flags673, align 4
  %or674 = or i32 %549, 67108864
  store i32 %or674, ptr %Flags673, align 4
  br label %if.end675

if.end675:                                        ; preds = %if.then672, %if.end668
  %550 = load ptr, ptr %table.addr, align 8
  %HoveredColumnBody676 = getelementptr inbounds %struct.ImGuiTable, ptr %550, i32 0, i32 70
  %551 = load i16, ptr %HoveredColumnBody676, align 2
  %conv677 = sext i16 %551 to i32
  %552 = load i32, ptr %column_n497, align 4
  %cmp678 = icmp eq i32 %conv677, %552
  br i1 %cmp678, label %if.then679, label %if.end682

if.then679:                                       ; preds = %if.end675
  %553 = load ptr, ptr %column501, align 8
  %Flags680 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %553, i32 0, i32 0
  %554 = load i32, ptr %Flags680, align 4
  %or681 = or i32 %554, 134217728
  store i32 %or681, ptr %Flags680, align 4
  br label %if.end682

if.end682:                                        ; preds = %if.then679, %if.end675
  %555 = load ptr, ptr %column501, align 8
  %WorkMinX683 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %555, i32 0, i32 10
  %556 = load float, ptr %WorkMinX683, align 4
  %557 = load ptr, ptr %column501, align 8
  %ContentMaxXUnfrozen = getelementptr inbounds %struct.ImGuiTableColumn, ptr %557, i32 0, i32 14
  store float %556, ptr %ContentMaxXUnfrozen, align 4
  %558 = load ptr, ptr %column501, align 8
  %ContentMaxXFrozen = getelementptr inbounds %struct.ImGuiTableColumn, ptr %558, i32 0, i32 13
  store float %556, ptr %ContentMaxXFrozen, align 4
  %559 = load ptr, ptr %column501, align 8
  %WorkMinX684 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %559, i32 0, i32 10
  %560 = load float, ptr %WorkMinX684, align 4
  %561 = load ptr, ptr %column501, align 8
  %ContentMaxXHeadersIdeal = getelementptr inbounds %struct.ImGuiTableColumn, ptr %561, i32 0, i32 16
  store float %560, ptr %ContentMaxXHeadersIdeal, align 4
  %562 = load ptr, ptr %column501, align 8
  %ContentMaxXHeadersUsed = getelementptr inbounds %struct.ImGuiTableColumn, ptr %562, i32 0, i32 15
  store float %560, ptr %ContentMaxXHeadersUsed, align 4
  %563 = load ptr, ptr %table.addr, align 8
  %HostSkipItems685 = getelementptr inbounds %struct.ImGuiTable, ptr %563, i32 0, i32 111
  %564 = load i8, ptr %HostSkipItems685, align 1
  %tobool686 = trunc i8 %564 to i1
  %conv687 = zext i1 %tobool686 to i32
  %cmp688 = icmp eq i32 %conv687, 0
  br i1 %cmp688, label %if.then689, label %if.end698

if.then689:                                       ; preds = %if.end682
  %565 = load ptr, ptr %column501, align 8
  %AutoFitQueue690 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %565, i32 0, i32 35
  %566 = load i8, ptr %AutoFitQueue690, align 1
  %conv691 = zext i8 %566 to i32
  %shr692 = ashr i32 %conv691, 1
  %conv693 = trunc i32 %shr692 to i8
  store i8 %conv693, ptr %AutoFitQueue690, align 1
  %567 = load ptr, ptr %column501, align 8
  %CannotSkipItemsQueue694 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %567, i32 0, i32 36
  %568 = load i8, ptr %CannotSkipItemsQueue694, align 4
  %conv695 = zext i8 %568 to i32
  %shr696 = ashr i32 %conv695, 1
  %conv697 = trunc i32 %shr696 to i8
  store i8 %conv697, ptr %CannotSkipItemsQueue694, align 4
  br label %if.end698

if.end698:                                        ; preds = %if.then689, %if.end682
  %569 = load i32, ptr %visible_n, align 4
  %570 = load ptr, ptr %table.addr, align 8
  %FreezeColumnsCount699 = getelementptr inbounds %struct.ImGuiTable, ptr %570, i32 0, i32 87
  %571 = load i16, ptr %FreezeColumnsCount699, align 4
  %conv700 = sext i16 %571 to i32
  %cmp701 = icmp slt i32 %569, %conv700
  br i1 %cmp701, label %if.then702, label %if.end712

if.then702:                                       ; preds = %if.end698
  %572 = load ptr, ptr %column501, align 8
  %MaxX703 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %572, i32 0, i32 3
  %573 = load float, ptr %MaxX703, align 4
  %add704 = fadd float %573, 1.000000e+00
  %Min705 = getelementptr inbounds %struct.ImRect, ptr %host_clip_rect, i32 0, i32 0
  %x706 = getelementptr inbounds %struct.ImVec2, ptr %Min705, i32 0, i32 0
  %574 = load float, ptr %x706, align 4
  %Max707 = getelementptr inbounds %struct.ImRect, ptr %host_clip_rect, i32 0, i32 1
  %x708 = getelementptr inbounds %struct.ImVec2, ptr %Max707, i32 0, i32 0
  %575 = load float, ptr %x708, align 4
  %call709 = call noundef float @_ZL7ImClampIfET_S0_S0_S0_(float noundef %add704, float noundef %574, float noundef %575)
  %Min710 = getelementptr inbounds %struct.ImRect, ptr %host_clip_rect, i32 0, i32 0
  %x711 = getelementptr inbounds %struct.ImVec2, ptr %Min710, i32 0, i32 0
  store float %call709, ptr %x711, align 4
  br label %if.end712

if.end712:                                        ; preds = %if.then702, %if.end698
  %576 = load ptr, ptr %column501, align 8
  %WidthGiven713 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %576, i32 0, i32 1
  %577 = load float, ptr %WidthGiven713, align 4
  %578 = load ptr, ptr %table.addr, align 8
  %CellSpacingX1714 = getelementptr inbounds %struct.ImGuiTable, ptr %578, i32 0, i32 35
  %579 = load float, ptr %CellSpacingX1714, align 4
  %add715 = fadd float %577, %579
  %580 = load ptr, ptr %table.addr, align 8
  %CellSpacingX2716 = getelementptr inbounds %struct.ImGuiTable, ptr %580, i32 0, i32 36
  %581 = load float, ptr %CellSpacingX2716, align 8
  %add717 = fadd float %add715, %581
  %582 = load ptr, ptr %table.addr, align 8
  %CellPaddingX718 = getelementptr inbounds %struct.ImGuiTable, ptr %582, i32 0, i32 34
  %583 = load float, ptr %CellPaddingX718, align 8
  %584 = call float @llvm.fmuladd.f32(float %583, float 2.000000e+00, float %add717)
  %585 = load float, ptr %offset_x, align 4
  %add720 = fadd float %585, %584
  store float %add720, ptr %offset_x, align 4
  %586 = load i32, ptr %visible_n, align 4
  %inc721 = add nsw i32 %586, 1
  store i32 %inc721, ptr %visible_n, align 4
  br label %for.inc722

for.inc722:                                       ; preds = %if.end712, %if.then532
  %587 = load i32, ptr %order_n492, align 4
  %inc723 = add nsw i32 %587, 1
  store i32 %inc723, ptr %order_n492, align 4
  br label %for.cond493, !llvm.loop !20

for.end724:                                       ; preds = %for.cond493
  %588 = load i8, ptr %has_at_least_one_column_requesting_output, align 1
  %tobool725 = trunc i8 %588 to i1
  %conv726 = zext i1 %tobool725 to i32
  %cmp727 = icmp eq i32 %conv726, 0
  br i1 %cmp727, label %if.then728, label %if.end739

if.then728:                                       ; preds = %for.end724
  %589 = load ptr, ptr %table.addr, align 8
  %Columns729 = getelementptr inbounds %struct.ImGuiTable, ptr %589, i32 0, i32 4
  %590 = load ptr, ptr %table.addr, align 8
  %LeftMostEnabledColumn730 = getelementptr inbounds %struct.ImGuiTable, ptr %590, i32 0, i32 79
  %591 = load i16, ptr %LeftMostEnabledColumn730, align 4
  %conv731 = sext i16 %591 to i32
  %call732 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns729, i32 noundef %conv731)
  %IsRequestOutput733 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %call732, i32 0, i32 31
  store i8 1, ptr %IsRequestOutput733, align 1
  %592 = load ptr, ptr %table.addr, align 8
  %Columns734 = getelementptr inbounds %struct.ImGuiTable, ptr %592, i32 0, i32 4
  %593 = load ptr, ptr %table.addr, align 8
  %LeftMostEnabledColumn735 = getelementptr inbounds %struct.ImGuiTable, ptr %593, i32 0, i32 79
  %594 = load i16, ptr %LeftMostEnabledColumn735, align 4
  %conv736 = sext i16 %594 to i32
  %call737 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns734, i32 noundef %conv736)
  %IsSkipItems738 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %call737, i32 0, i32 32
  store i8 0, ptr %IsSkipItems738, align 4
  br label %if.end739

if.end739:                                        ; preds = %if.then728, %for.end724
  %595 = load ptr, ptr %table.addr, align 8
  %WorkRect740 = getelementptr inbounds %struct.ImGuiTable, ptr %595, i32 0, i32 48
  %Min741 = getelementptr inbounds %struct.ImRect, ptr %WorkRect740, i32 0, i32 0
  %x742 = getelementptr inbounds %struct.ImVec2, ptr %Min741, i32 0, i32 0
  %596 = load float, ptr %x742, align 8
  %597 = load ptr, ptr %table.addr, align 8
  %Columns743 = getelementptr inbounds %struct.ImGuiTable, ptr %597, i32 0, i32 4
  %598 = load ptr, ptr %table.addr, align 8
  %RightMostEnabledColumn744 = getelementptr inbounds %struct.ImGuiTable, ptr %598, i32 0, i32 80
  %599 = load i16, ptr %RightMostEnabledColumn744, align 2
  %conv745 = sext i16 %599 to i32
  %call746 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns743, i32 noundef %conv745)
  %ClipRect747 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %call746, i32 0, i32 8
  %Max748 = getelementptr inbounds %struct.ImRect, ptr %ClipRect747, i32 0, i32 1
  %x749 = getelementptr inbounds %struct.ImVec2, ptr %Max748, i32 0, i32 0
  %600 = load float, ptr %x749, align 4
  %call750 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %596, float noundef %600)
  store float %call750, ptr %unused_x1, align 4
  %601 = load i8, ptr %is_hovering_table, align 1
  %tobool751 = trunc i8 %601 to i1
  br i1 %tobool751, label %land.lhs.true752, label %if.end763

land.lhs.true752:                                 ; preds = %if.end739
  %602 = load ptr, ptr %table.addr, align 8
  %HoveredColumnBody753 = getelementptr inbounds %struct.ImGuiTable, ptr %602, i32 0, i32 70
  %603 = load i16, ptr %HoveredColumnBody753, align 2
  %conv754 = sext i16 %603 to i32
  %cmp755 = icmp eq i32 %conv754, -1
  br i1 %cmp755, label %if.then756, label %if.end763

if.then756:                                       ; preds = %land.lhs.true752
  %604 = load float, ptr %mouse_skewed_x, align 4
  %605 = load float, ptr %unused_x1, align 4
  %cmp757 = fcmp oge float %604, %605
  br i1 %cmp757, label %if.then758, label %if.end762

if.then758:                                       ; preds = %if.then756
  %606 = load ptr, ptr %table.addr, align 8
  %ColumnsCount759 = getelementptr inbounds %struct.ImGuiTable, ptr %606, i32 0, i32 13
  %607 = load i32, ptr %ColumnsCount759, align 4
  %conv760 = trunc i32 %607 to i16
  %608 = load ptr, ptr %table.addr, align 8
  %HoveredColumnBody761 = getelementptr inbounds %struct.ImGuiTable, ptr %608, i32 0, i32 70
  store i16 %conv760, ptr %HoveredColumnBody761, align 2
  br label %if.end762

if.end762:                                        ; preds = %if.then758, %if.then756
  br label %if.end763

if.end763:                                        ; preds = %if.end762, %land.lhs.true752, %if.end739
  %609 = load i8, ptr %has_resizable, align 1
  %tobool764 = trunc i8 %609 to i1
  %conv765 = zext i1 %tobool764 to i32
  %cmp766 = icmp eq i32 %conv765, 0
  br i1 %cmp766, label %land.lhs.true767, label %if.end774

land.lhs.true767:                                 ; preds = %if.end763
  %610 = load ptr, ptr %table.addr, align 8
  %Flags768 = getelementptr inbounds %struct.ImGuiTable, ptr %610, i32 0, i32 1
  %611 = load i32, ptr %Flags768, align 4
  %and769 = and i32 %611, 1
  %tobool770 = icmp ne i32 %and769, 0
  br i1 %tobool770, label %if.then771, label %if.end774

if.then771:                                       ; preds = %land.lhs.true767
  %612 = load ptr, ptr %table.addr, align 8
  %Flags772 = getelementptr inbounds %struct.ImGuiTable, ptr %612, i32 0, i32 1
  %613 = load i32, ptr %Flags772, align 4
  %and773 = and i32 %613, -2
  store i32 %and773, ptr %Flags772, align 4
  br label %if.end774

if.end774:                                        ; preds = %if.then771, %land.lhs.true767, %if.end763
  %614 = load ptr, ptr %g, align 8
  %ActiveIdIsAlive = getelementptr inbounds %struct.ImGuiContext, ptr %614, i32 0, i32 48
  %615 = load i32, ptr %ActiveIdIsAlive, align 8
  %cmp775 = icmp ne i32 %615, 0
  %616 = load ptr, ptr %table.addr, align 8
  %IsActiveIdAliveBeforeTable = getelementptr inbounds %struct.ImGuiTable, ptr %616, i32 0, i32 106
  %frombool776 = zext i1 %cmp775 to i8
  store i8 %frombool776, ptr %IsActiveIdAliveBeforeTable, align 4
  %617 = load ptr, ptr %table.addr, align 8
  %RightMostStretchedColumn777 = getelementptr inbounds %struct.ImGuiTable, ptr %617, i32 0, i32 82
  %618 = load i16, ptr %RightMostStretchedColumn777, align 2
  %conv778 = sext i16 %618 to i32
  %cmp779 = icmp ne i32 %conv778, -1
  br i1 %cmp779, label %if.then780, label %if.end783

if.then780:                                       ; preds = %if.end774
  %619 = load ptr, ptr %table.addr, align 8
  %Flags781 = getelementptr inbounds %struct.ImGuiTable, ptr %619, i32 0, i32 1
  %620 = load i32, ptr %Flags781, align 4
  %and782 = and i32 %620, -65537
  store i32 %and782, ptr %Flags781, align 4
  br label %if.end783

if.end783:                                        ; preds = %if.then780, %if.end774
  %621 = load ptr, ptr %table.addr, align 8
  %Flags784 = getelementptr inbounds %struct.ImGuiTable, ptr %621, i32 0, i32 1
  %622 = load i32, ptr %Flags784, align 4
  %and785 = and i32 %622, 65536
  %tobool786 = icmp ne i32 %and785, 0
  br i1 %tobool786, label %if.then787, label %if.end801

if.then787:                                       ; preds = %if.end783
  %623 = load float, ptr %unused_x1, align 4
  %624 = load ptr, ptr %table.addr, align 8
  %WorkRect788 = getelementptr inbounds %struct.ImGuiTable, ptr %624, i32 0, i32 48
  %Max789 = getelementptr inbounds %struct.ImRect, ptr %WorkRect788, i32 0, i32 1
  %x790 = getelementptr inbounds %struct.ImVec2, ptr %Max789, i32 0, i32 0
  store float %623, ptr %x790, align 8
  %625 = load ptr, ptr %table.addr, align 8
  %OuterRect791 = getelementptr inbounds %struct.ImGuiTable, ptr %625, i32 0, i32 46
  %Max792 = getelementptr inbounds %struct.ImRect, ptr %OuterRect791, i32 0, i32 1
  %x793 = getelementptr inbounds %struct.ImVec2, ptr %Max792, i32 0, i32 0
  store float %623, ptr %x793, align 8
  %626 = load ptr, ptr %table.addr, align 8
  %InnerClipRect794 = getelementptr inbounds %struct.ImGuiTable, ptr %626, i32 0, i32 49
  %Max795 = getelementptr inbounds %struct.ImRect, ptr %InnerClipRect794, i32 0, i32 1
  %x796 = getelementptr inbounds %struct.ImVec2, ptr %Max795, i32 0, i32 0
  %627 = load float, ptr %x796, align 8
  %628 = load float, ptr %unused_x1, align 4
  %call797 = call noundef float @_ZL5ImMinIfET_S0_S0_(float noundef %627, float noundef %628)
  %629 = load ptr, ptr %table.addr, align 8
  %InnerClipRect798 = getelementptr inbounds %struct.ImGuiTable, ptr %629, i32 0, i32 49
  %Max799 = getelementptr inbounds %struct.ImRect, ptr %InnerClipRect798, i32 0, i32 1
  %x800 = getelementptr inbounds %struct.ImVec2, ptr %Max799, i32 0, i32 0
  store float %call797, ptr %x800, align 8
  br label %if.end801

if.end801:                                        ; preds = %if.then787, %if.end783
  %630 = load ptr, ptr %table.addr, align 8
  %WorkRect802 = getelementptr inbounds %struct.ImGuiTable, ptr %630, i32 0, i32 48
  %631 = load ptr, ptr %table.addr, align 8
  %InnerWindow803 = getelementptr inbounds %struct.ImGuiTable, ptr %631, i32 0, i32 56
  %632 = load ptr, ptr %InnerWindow803, align 8
  %ParentWorkRect = getelementptr inbounds %struct.ImGuiWindow, ptr %632, i32 0, i32 73
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %ParentWorkRect, ptr align 8 %WorkRect802, i64 16, i1 false)
  %633 = load ptr, ptr %table.addr, align 8
  %InnerClipRect804 = getelementptr inbounds %struct.ImGuiTable, ptr %633, i32 0, i32 49
  %Min805 = getelementptr inbounds %struct.ImRect, ptr %InnerClipRect804, i32 0, i32 0
  %x806 = getelementptr inbounds %struct.ImVec2, ptr %Min805, i32 0, i32 0
  %634 = load float, ptr %x806, align 8
  %635 = load ptr, ptr %table.addr, align 8
  %BorderX1 = getelementptr inbounds %struct.ImGuiTable, ptr %635, i32 0, i32 29
  store float %634, ptr %BorderX1, align 4
  %636 = load ptr, ptr %table.addr, align 8
  %InnerClipRect807 = getelementptr inbounds %struct.ImGuiTable, ptr %636, i32 0, i32 49
  %Max808 = getelementptr inbounds %struct.ImRect, ptr %InnerClipRect807, i32 0, i32 1
  %x809 = getelementptr inbounds %struct.ImVec2, ptr %Max808, i32 0, i32 0
  %637 = load float, ptr %x809, align 8
  %638 = load ptr, ptr %table.addr, align 8
  %BorderX2 = getelementptr inbounds %struct.ImGuiTable, ptr %638, i32 0, i32 30
  store float %637, ptr %BorderX2, align 8
  %639 = load ptr, ptr %table.addr, align 8
  %Flags810 = getelementptr inbounds %struct.ImGuiTable, ptr %639, i32 0, i32 1
  %640 = load i32, ptr %Flags810, align 4
  %and811 = and i32 %640, 131072
  %tobool812 = icmp ne i32 %and811, 0
  br i1 %tobool812, label %if.then813, label %if.else817

if.then813:                                       ; preds = %if.end801
  %641 = load ptr, ptr %table.addr, align 8
  %OuterRect814 = getelementptr inbounds %struct.ImGuiTable, ptr %641, i32 0, i32 46
  %Max815 = getelementptr inbounds %struct.ImRect, ptr %OuterRect814, i32 0, i32 1
  %y816 = getelementptr inbounds %struct.ImVec2, ptr %Max815, i32 0, i32 1
  %642 = load float, ptr %y816, align 4
  store float %642, ptr %window_content_max_y, align 4
  br label %if.end832

if.else817:                                       ; preds = %if.end801
  %643 = load ptr, ptr %table.addr, align 8
  %InnerWindow818 = getelementptr inbounds %struct.ImGuiTable, ptr %643, i32 0, i32 56
  %644 = load ptr, ptr %InnerWindow818, align 8
  %ContentRegionRect = getelementptr inbounds %struct.ImGuiWindow, ptr %644, i32 0, i32 75
  %Max819 = getelementptr inbounds %struct.ImRect, ptr %ContentRegionRect, i32 0, i32 1
  %y820 = getelementptr inbounds %struct.ImVec2, ptr %Max819, i32 0, i32 1
  %645 = load float, ptr %y820, align 4
  %646 = load ptr, ptr %table.addr, align 8
  %Flags821 = getelementptr inbounds %struct.ImGuiTable, ptr %646, i32 0, i32 1
  %647 = load i32, ptr %Flags821, align 4
  %and822 = and i32 %647, 33554432
  %tobool823 = icmp ne i32 %and822, 0
  br i1 %tobool823, label %cond.true824, label %cond.false825

cond.true824:                                     ; preds = %if.else817
  br label %cond.end829

cond.false825:                                    ; preds = %if.else817
  %648 = load ptr, ptr %table.addr, align 8
  %OuterRect826 = getelementptr inbounds %struct.ImGuiTable, ptr %648, i32 0, i32 46
  %Max827 = getelementptr inbounds %struct.ImRect, ptr %OuterRect826, i32 0, i32 1
  %y828 = getelementptr inbounds %struct.ImVec2, ptr %Max827, i32 0, i32 1
  %649 = load float, ptr %y828, align 4
  br label %cond.end829

cond.end829:                                      ; preds = %cond.false825, %cond.true824
  %cond830 = phi float [ 0.000000e+00, %cond.true824 ], [ %649, %cond.false825 ]
  %call831 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %645, float noundef %cond830)
  store float %call831, ptr %window_content_max_y, align 4
  br label %if.end832

if.end832:                                        ; preds = %cond.end829, %if.then813
  %650 = load float, ptr %window_content_max_y, align 4
  %651 = load ptr, ptr %g, align 8
  %Style833 = getelementptr inbounds %struct.ImGuiContext, ptr %651, i32 0, i32 3
  %CellPadding = getelementptr inbounds %struct.ImGuiStyle, ptr %Style833, i32 0, i32 17
  %y834 = getelementptr inbounds %struct.ImVec2, ptr %CellPadding, i32 0, i32 1
  %652 = load float, ptr %y834, align 4
  %sub835 = fsub float %650, %652
  %653 = load ptr, ptr %table.addr, align 8
  %InnerWindow836 = getelementptr inbounds %struct.ImGuiTable, ptr %653, i32 0, i32 56
  %654 = load ptr, ptr %InnerWindow836, align 8
  %WorkRect837 = getelementptr inbounds %struct.ImGuiWindow, ptr %654, i32 0, i32 72
  %Min838 = getelementptr inbounds %struct.ImRect, ptr %WorkRect837, i32 0, i32 0
  %y839 = getelementptr inbounds %struct.ImVec2, ptr %Min838, i32 0, i32 1
  %655 = load float, ptr %y839, align 4
  %656 = load ptr, ptr %table.addr, align 8
  %InnerWindow840 = getelementptr inbounds %struct.ImGuiTable, ptr %656, i32 0, i32 56
  %657 = load ptr, ptr %InnerWindow840, align 8
  %WorkRect841 = getelementptr inbounds %struct.ImGuiWindow, ptr %657, i32 0, i32 72
  %Max842 = getelementptr inbounds %struct.ImRect, ptr %WorkRect841, i32 0, i32 1
  %y843 = getelementptr inbounds %struct.ImVec2, ptr %Max842, i32 0, i32 1
  %658 = load float, ptr %y843, align 4
  %call844 = call noundef float @_ZL7ImClampIfET_S0_S0_S0_(float noundef %sub835, float noundef %655, float noundef %658)
  %659 = load ptr, ptr %table.addr, align 8
  %InnerWindow845 = getelementptr inbounds %struct.ImGuiTable, ptr %659, i32 0, i32 56
  %660 = load ptr, ptr %InnerWindow845, align 8
  %WorkRect846 = getelementptr inbounds %struct.ImGuiWindow, ptr %660, i32 0, i32 72
  %Max847 = getelementptr inbounds %struct.ImRect, ptr %WorkRect846, i32 0, i32 1
  %y848 = getelementptr inbounds %struct.ImVec2, ptr %Max847, i32 0, i32 1
  store float %call844, ptr %y848, align 4
  %661 = load ptr, ptr %table.addr, align 8
  call void @_ZN5ImGui22TableSetupDrawChannelsEP10ImGuiTable(ptr noundef %661)
  %662 = load ptr, ptr %table.addr, align 8
  %Flags849 = getelementptr inbounds %struct.ImGuiTable, ptr %662, i32 0, i32 1
  %663 = load i32, ptr %Flags849, align 4
  %and850 = and i32 %663, 1
  %tobool851 = icmp ne i32 %and850, 0
  br i1 %tobool851, label %if.then852, label %if.end853

if.then852:                                       ; preds = %if.end832
  %664 = load ptr, ptr %table.addr, align 8
  call void @_ZN5ImGui18TableUpdateBordersEP10ImGuiTable(ptr noundef %664)
  br label %if.end853

if.end853:                                        ; preds = %if.then852, %if.end832
  %665 = load ptr, ptr %table_instance, align 8
  %LastTopHeadersRowHeight = getelementptr inbounds %struct.ImGuiTableInstanceData, ptr %665, i32 0, i32 2
  store float 0.000000e+00, ptr %LastTopHeadersRowHeight, align 4
  %666 = load ptr, ptr %table.addr, align 8
  %IsLayoutLocked = getelementptr inbounds %struct.ImGuiTable, ptr %666, i32 0, i32 92
  store i8 1, ptr %IsLayoutLocked, align 2
  %667 = load ptr, ptr %table.addr, align 8
  %IsUsingHeaders = getelementptr inbounds %struct.ImGuiTable, ptr %667, i32 0, i32 96
  store i8 0, ptr %IsUsingHeaders, align 2
  %668 = load ptr, ptr %table.addr, align 8
  %HighlightColumnHeader = getelementptr inbounds %struct.ImGuiTable, ptr %668, i32 0, i32 72
  store i16 -1, ptr %HighlightColumnHeader, align 2
  %669 = load ptr, ptr %table.addr, align 8
  %IsContextPopupOpen = getelementptr inbounds %struct.ImGuiTable, ptr %669, i32 0, i32 97
  %670 = load i8, ptr %IsContextPopupOpen, align 1
  %tobool854 = trunc i8 %670 to i1
  br i1 %tobool854, label %land.lhs.true855, label %if.else866

land.lhs.true855:                                 ; preds = %if.end853
  %671 = load ptr, ptr %table.addr, align 8
  %ContextPopupColumn = getelementptr inbounds %struct.ImGuiTable, ptr %671, i32 0, i32 83
  %672 = load i16, ptr %ContextPopupColumn, align 4
  %conv856 = sext i16 %672 to i32
  %cmp857 = icmp ne i32 %conv856, -1
  br i1 %cmp857, label %land.lhs.true858, label %if.else866

land.lhs.true858:                                 ; preds = %land.lhs.true855
  %673 = load ptr, ptr %table.addr, align 8
  %InstanceInteracted = getelementptr inbounds %struct.ImGuiTable, ptr %673, i32 0, i32 17
  %674 = load i16, ptr %InstanceInteracted, align 2
  %conv859 = sext i16 %674 to i32
  %675 = load ptr, ptr %table.addr, align 8
  %InstanceCurrent860 = getelementptr inbounds %struct.ImGuiTable, ptr %675, i32 0, i32 16
  %676 = load i16, ptr %InstanceCurrent860, align 8
  %conv861 = sext i16 %676 to i32
  %cmp862 = icmp eq i32 %conv859, %conv861
  br i1 %cmp862, label %if.then863, label %if.else866

if.then863:                                       ; preds = %land.lhs.true858
  %677 = load ptr, ptr %table.addr, align 8
  %ContextPopupColumn864 = getelementptr inbounds %struct.ImGuiTable, ptr %677, i32 0, i32 83
  %678 = load i16, ptr %ContextPopupColumn864, align 4
  %679 = load ptr, ptr %table.addr, align 8
  %HighlightColumnHeader865 = getelementptr inbounds %struct.ImGuiTable, ptr %679, i32 0, i32 72
  store i16 %678, ptr %HighlightColumnHeader865, align 2
  br label %if.end895

if.else866:                                       ; preds = %land.lhs.true858, %land.lhs.true855, %if.end853
  %680 = load ptr, ptr %table.addr, align 8
  %Flags867 = getelementptr inbounds %struct.ImGuiTable, ptr %680, i32 0, i32 1
  %681 = load i32, ptr %Flags867, align 4
  %and868 = and i32 %681, 268435456
  %tobool869 = icmp ne i32 %and868, 0
  br i1 %tobool869, label %land.lhs.true870, label %if.end894

land.lhs.true870:                                 ; preds = %if.else866
  %682 = load ptr, ptr %table.addr, align 8
  %HoveredColumnBody871 = getelementptr inbounds %struct.ImGuiTable, ptr %682, i32 0, i32 70
  %683 = load i16, ptr %HoveredColumnBody871, align 2
  %conv872 = sext i16 %683 to i32
  %cmp873 = icmp ne i32 %conv872, -1
  br i1 %cmp873, label %land.lhs.true874, label %if.end894

land.lhs.true874:                                 ; preds = %land.lhs.true870
  %684 = load ptr, ptr %table.addr, align 8
  %HoveredColumnBody875 = getelementptr inbounds %struct.ImGuiTable, ptr %684, i32 0, i32 70
  %685 = load i16, ptr %HoveredColumnBody875, align 2
  %conv876 = sext i16 %685 to i32
  %686 = load ptr, ptr %table.addr, align 8
  %ColumnsCount877 = getelementptr inbounds %struct.ImGuiTable, ptr %686, i32 0, i32 13
  %687 = load i32, ptr %ColumnsCount877, align 4
  %cmp878 = icmp ne i32 %conv876, %687
  br i1 %cmp878, label %land.lhs.true879, label %if.end894

land.lhs.true879:                                 ; preds = %land.lhs.true874
  %688 = load ptr, ptr %table.addr, align 8
  %HoveredColumnBorder880 = getelementptr inbounds %struct.ImGuiTable, ptr %688, i32 0, i32 71
  %689 = load i16, ptr %HoveredColumnBorder880, align 4
  %conv881 = sext i16 %689 to i32
  %cmp882 = icmp eq i32 %conv881, -1
  br i1 %cmp882, label %if.then883, label %if.end894

if.then883:                                       ; preds = %land.lhs.true879
  %690 = load ptr, ptr %g, align 8
  %ActiveId884 = getelementptr inbounds %struct.ImGuiContext, ptr %690, i32 0, i32 47
  %691 = load i32, ptr %ActiveId884, align 4
  %cmp885 = icmp eq i32 %691, 0
  br i1 %cmp885, label %if.then890, label %lor.lhs.false886

lor.lhs.false886:                                 ; preds = %if.then883
  %692 = load ptr, ptr %table.addr, align 8
  %IsActiveIdInTable = getelementptr inbounds %struct.ImGuiTable, ptr %692, i32 0, i32 107
  %693 = load i8, ptr %IsActiveIdInTable, align 1
  %tobool887 = trunc i8 %693 to i1
  br i1 %tobool887, label %if.then890, label %lor.lhs.false888

lor.lhs.false888:                                 ; preds = %lor.lhs.false886
  %694 = load ptr, ptr %g, align 8
  %DragDropActive = getelementptr inbounds %struct.ImGuiContext, ptr %694, i32 0, i32 144
  %695 = load i8, ptr %DragDropActive, align 8
  %tobool889 = trunc i8 %695 to i1
  br i1 %tobool889, label %if.then890, label %if.end893

if.then890:                                       ; preds = %lor.lhs.false888, %lor.lhs.false886, %if.then883
  %696 = load ptr, ptr %table.addr, align 8
  %HoveredColumnBody891 = getelementptr inbounds %struct.ImGuiTable, ptr %696, i32 0, i32 70
  %697 = load i16, ptr %HoveredColumnBody891, align 2
  %698 = load ptr, ptr %table.addr, align 8
  %HighlightColumnHeader892 = getelementptr inbounds %struct.ImGuiTable, ptr %698, i32 0, i32 72
  store i16 %697, ptr %HighlightColumnHeader892, align 2
  br label %if.end893

if.end893:                                        ; preds = %if.then890, %lor.lhs.false888
  br label %if.end894

if.end894:                                        ; preds = %if.end893, %land.lhs.true879, %land.lhs.true874, %land.lhs.true870, %if.else866
  br label %if.end895

if.end895:                                        ; preds = %if.end894, %if.then863
  %699 = load ptr, ptr %table.addr, align 8
  %DisableDefaultContextMenu = getelementptr inbounds %struct.ImGuiTable, ptr %699, i32 0, i32 98
  %700 = load i8, ptr %DisableDefaultContextMenu, align 4
  %tobool896 = trunc i8 %700 to i1
  %conv897 = zext i1 %tobool896 to i32
  %cmp898 = icmp eq i32 %conv897, 0
  br i1 %cmp898, label %land.lhs.true899, label %if.end903

land.lhs.true899:                                 ; preds = %if.end895
  %701 = load ptr, ptr %table.addr, align 8
  %call900 = call noundef zeroext i1 @_ZN5ImGui26TableBeginContextMenuPopupEP10ImGuiTable(ptr noundef %701)
  br i1 %call900, label %if.then901, label %if.end903

if.then901:                                       ; preds = %land.lhs.true899
  %702 = load ptr, ptr %table.addr, align 8
  %703 = load ptr, ptr %table.addr, align 8
  %Flags902 = getelementptr inbounds %struct.ImGuiTable, ptr %703, i32 0, i32 1
  %704 = load i32, ptr %Flags902, align 4
  call void @_ZN5ImGui27TableDrawDefaultContextMenuEP10ImGuiTablei(ptr noundef %702, i32 noundef %704)
  call void @_ZN5ImGui8EndPopupEv()
  br label %if.end903

if.end903:                                        ; preds = %if.then901, %land.lhs.true899, %if.end895
  %705 = load ptr, ptr %table.addr, align 8
  %IsSortSpecsDirty904 = getelementptr inbounds %struct.ImGuiTable, ptr %705, i32 0, i32 95
  %706 = load i8, ptr %IsSortSpecsDirty904, align 1
  %tobool905 = trunc i8 %706 to i1
  br i1 %tobool905, label %land.lhs.true906, label %if.end911

land.lhs.true906:                                 ; preds = %if.end903
  %707 = load ptr, ptr %table.addr, align 8
  %Flags907 = getelementptr inbounds %struct.ImGuiTable, ptr %707, i32 0, i32 1
  %708 = load i32, ptr %Flags907, align 4
  %and908 = and i32 %708, 8
  %tobool909 = icmp ne i32 %and908, 0
  br i1 %tobool909, label %if.then910, label %if.end911

if.then910:                                       ; preds = %land.lhs.true906
  %709 = load ptr, ptr %table.addr, align 8
  call void @_ZN5ImGui19TableSortSpecsBuildEP10ImGuiTable(ptr noundef %709)
  br label %if.end911

if.end911:                                        ; preds = %if.then910, %land.lhs.true906, %if.end903
  %710 = load ptr, ptr %table.addr, align 8
  %FreezeColumnsRequest = getelementptr inbounds %struct.ImGuiTable, ptr %710, i32 0, i32 86
  %711 = load i16, ptr %FreezeColumnsRequest, align 2
  %conv912 = sext i16 %711 to i32
  %cmp913 = icmp sgt i32 %conv912, 0
  br i1 %cmp913, label %if.then914, label %if.end929

if.then914:                                       ; preds = %if.end911
  %712 = load ptr, ptr %table.addr, align 8
  %Columns915 = getelementptr inbounds %struct.ImGuiTable, ptr %712, i32 0, i32 4
  %713 = load ptr, ptr %table.addr, align 8
  %DisplayOrderToIndex916 = getelementptr inbounds %struct.ImGuiTable, ptr %713, i32 0, i32 5
  %714 = load ptr, ptr %table.addr, align 8
  %FreezeColumnsRequest917 = getelementptr inbounds %struct.ImGuiTable, ptr %714, i32 0, i32 86
  %715 = load i16, ptr %FreezeColumnsRequest917, align 2
  %conv918 = sext i16 %715 to i32
  %sub919 = sub nsw i32 %conv918, 1
  %call920 = call noundef nonnull align 2 dereferenceable(2) ptr @_ZN6ImSpanIsEixEi(ptr noundef nonnull align 8 dereferenceable(16) %DisplayOrderToIndex916, i32 noundef %sub919)
  %716 = load i16, ptr %call920, align 2
  %conv921 = sext i16 %716 to i32
  %call922 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns915, i32 noundef %conv921)
  %MaxX923 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %call922, i32 0, i32 3
  %717 = load float, ptr %MaxX923, align 4
  %718 = load ptr, ptr %table.addr, align 8
  %OuterRect924 = getelementptr inbounds %struct.ImGuiTable, ptr %718, i32 0, i32 46
  %Min925 = getelementptr inbounds %struct.ImRect, ptr %OuterRect924, i32 0, i32 0
  %x926 = getelementptr inbounds %struct.ImVec2, ptr %Min925, i32 0, i32 0
  %719 = load float, ptr %x926, align 8
  %sub927 = fsub float %717, %719
  %720 = load ptr, ptr %table.addr, align 8
  %InnerWindow928 = getelementptr inbounds %struct.ImGuiTable, ptr %720, i32 0, i32 56
  %721 = load ptr, ptr %InnerWindow928, align 8
  %DecoInnerSizeX1 = getelementptr inbounds %struct.ImGuiWindow, ptr %721, i32 0, i32 20
  store float %sub927, ptr %DecoInnerSizeX1, align 8
  br label %if.end929

if.end929:                                        ; preds = %if.then914, %if.end911
  %722 = load ptr, ptr %table.addr, align 8
  %FreezeRowsRequest = getelementptr inbounds %struct.ImGuiTable, ptr %722, i32 0, i32 84
  %723 = load i16, ptr %FreezeRowsRequest, align 2
  %conv930 = sext i16 %723 to i32
  %cmp931 = icmp sgt i32 %conv930, 0
  br i1 %cmp931, label %if.then932, label %if.end934

if.then932:                                       ; preds = %if.end929
  %724 = load ptr, ptr %table_instance, align 8
  %LastFrozenHeight = getelementptr inbounds %struct.ImGuiTableInstanceData, ptr %724, i32 0, i32 3
  %725 = load float, ptr %LastFrozenHeight, align 4
  %726 = load ptr, ptr %table.addr, align 8
  %InnerWindow933 = getelementptr inbounds %struct.ImGuiTable, ptr %726, i32 0, i32 56
  %727 = load ptr, ptr %InnerWindow933, align 8
  %DecoInnerSizeY1 = getelementptr inbounds %struct.ImGuiWindow, ptr %727, i32 0, i32 21
  store float %725, ptr %DecoInnerSizeY1, align 4
  br label %if.end934

if.end934:                                        ; preds = %if.then932, %if.end929
  %728 = load ptr, ptr %table_instance, align 8
  %LastFrozenHeight935 = getelementptr inbounds %struct.ImGuiTableInstanceData, ptr %728, i32 0, i32 3
  store float 0.000000e+00, ptr %LastFrozenHeight935, align 4
  %729 = load ptr, ptr %table.addr, align 8
  %InnerWindow936 = getelementptr inbounds %struct.ImGuiTable, ptr %729, i32 0, i32 56
  %730 = load ptr, ptr %InnerWindow936, align 8
  store ptr %730, ptr %inner_window, align 8
  %731 = load ptr, ptr %table.addr, align 8
  %Flags937 = getelementptr inbounds %struct.ImGuiTable, ptr %731, i32 0, i32 1
  %732 = load i32, ptr %Flags937, align 4
  %and938 = and i32 %732, 1048576
  %tobool939 = icmp ne i32 %and938, 0
  br i1 %tobool939, label %if.then940, label %if.else941

if.then940:                                       ; preds = %if.end934
  %733 = load ptr, ptr %table.addr, align 8
  %DrawSplitter = getelementptr inbounds %struct.ImGuiTable, ptr %733, i32 0, i32 58
  %734 = load ptr, ptr %DrawSplitter, align 8
  %735 = load ptr, ptr %inner_window, align 8
  %DrawList = getelementptr inbounds %struct.ImGuiWindow, ptr %735, i32 0, i32 86
  %736 = load ptr, ptr %DrawList, align 8
  call void @_ZN18ImDrawListSplitter17SetCurrentChannelEP10ImDrawListi(ptr noundef nonnull align 8 dereferenceable(24) %734, ptr noundef %736, i32 noundef 2)
  br label %if.end947

if.else941:                                       ; preds = %if.end934
  %737 = load ptr, ptr %inner_window, align 8
  %DrawList942 = getelementptr inbounds %struct.ImGuiWindow, ptr %737, i32 0, i32 86
  %738 = load ptr, ptr %DrawList942, align 8
  %739 = load ptr, ptr %inner_window, align 8
  %ClipRect943 = getelementptr inbounds %struct.ImGuiWindow, ptr %739, i32 0, i32 74
  %Min944 = getelementptr inbounds %struct.ImRect, ptr %ClipRect943, i32 0, i32 0
  %740 = load ptr, ptr %inner_window, align 8
  %ClipRect945 = getelementptr inbounds %struct.ImGuiWindow, ptr %740, i32 0, i32 74
  %Max946 = getelementptr inbounds %struct.ImRect, ptr %ClipRect945, i32 0, i32 1
  call void @_ZN10ImDrawList12PushClipRectERK6ImVec2S2_b(ptr noundef nonnull align 8 dereferenceable(196) %738, ptr noundef nonnull align 4 dereferenceable(8) %Min944, ptr noundef nonnull align 4 dereferenceable(8) %Max946, i1 noundef zeroext false)
  br label %if.end947

if.end947:                                        ; preds = %if.else941, %if.then940
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_Z22ImBitArrayClearAllBitsPji(ptr noundef %arr, i32 noundef %bitcount) #3 comdat {
entry:
  %arr.addr = alloca ptr, align 8
  %bitcount.addr = alloca i32, align 4
  store ptr %arr, ptr %arr.addr, align 8
  store i32 %bitcount, ptr %bitcount.addr, align 4
  %0 = load ptr, ptr %arr.addr, align 8
  %1 = load i32, ptr %bitcount.addr, align 4
  %call = call noundef i64 @_Z31ImBitArrayGetStorageSizeInBytesi(i32 noundef %1)
  call void @llvm.memset.p0.i64(ptr align 4 %0, i8 0, i64 %call, i1 false)
  ret void
}

; Function Attrs: mustprogress uwtable
define internal void @_ZL21TableSetupColumnFlagsP10ImGuiTableP16ImGuiTableColumni(ptr noundef %table, ptr noundef %column, i32 noundef %flags_in) #0 {
entry:
  %table.addr = alloca ptr, align 8
  %column.addr = alloca ptr, align 8
  %flags_in.addr = alloca i32, align 4
  %flags = alloca i32, align 4
  %table_sizing_policy = alloca i32, align 4
  %count = alloca i32, align 4
  %mask = alloca i32, align 4
  %list = alloca i32, align 4
  store ptr %table, ptr %table.addr, align 8
  store ptr %column, ptr %column.addr, align 8
  store i32 %flags_in, ptr %flags_in.addr, align 4
  %0 = load i32, ptr %flags_in.addr, align 4
  store i32 %0, ptr %flags, align 4
  %1 = load i32, ptr %flags, align 4
  %and = and i32 %1, 24
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %if.then, label %if.else6

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %table.addr, align 8
  %Flags = getelementptr inbounds %struct.ImGuiTable, ptr %2, i32 0, i32 1
  %3 = load i32, ptr %Flags, align 4
  %and1 = and i32 %3, 57344
  store i32 %and1, ptr %table_sizing_policy, align 4
  %4 = load i32, ptr %table_sizing_policy, align 4
  %cmp2 = icmp eq i32 %4, 8192
  br i1 %cmp2, label %if.then4, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %5 = load i32, ptr %table_sizing_policy, align 4
  %cmp3 = icmp eq i32 %5, 16384
  br i1 %cmp3, label %if.then4, label %if.else

if.then4:                                         ; preds = %lor.lhs.false, %if.then
  %6 = load i32, ptr %flags, align 4
  %or = or i32 %6, 16
  store i32 %or, ptr %flags, align 4
  br label %if.end

if.else:                                          ; preds = %lor.lhs.false
  %7 = load i32, ptr %flags, align 4
  %or5 = or i32 %7, 8
  store i32 %or5, ptr %flags, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then4
  br label %if.end7

if.else6:                                         ; preds = %entry
  br label %if.end7

if.end7:                                          ; preds = %if.else6, %if.end
  %8 = load ptr, ptr %table.addr, align 8
  %Flags8 = getelementptr inbounds %struct.ImGuiTable, ptr %8, i32 0, i32 1
  %9 = load i32, ptr %Flags8, align 4
  %and9 = and i32 %9, 1
  %cmp10 = icmp eq i32 %and9, 0
  br i1 %cmp10, label %if.then11, label %if.end13

if.then11:                                        ; preds = %if.end7
  %10 = load i32, ptr %flags, align 4
  %or12 = or i32 %10, 32
  store i32 %or12, ptr %flags, align 4
  br label %if.end13

if.end13:                                         ; preds = %if.then11, %if.end7
  %11 = load i32, ptr %flags, align 4
  %and14 = and i32 %11, 1024
  %tobool = icmp ne i32 %and14, 0
  br i1 %tobool, label %land.lhs.true, label %if.end19

land.lhs.true:                                    ; preds = %if.end13
  %12 = load i32, ptr %flags, align 4
  %and15 = and i32 %12, 2048
  %tobool16 = icmp ne i32 %and15, 0
  br i1 %tobool16, label %if.then17, label %if.end19

if.then17:                                        ; preds = %land.lhs.true
  %13 = load i32, ptr %flags, align 4
  %or18 = or i32 %13, 512
  store i32 %or18, ptr %flags, align 4
  br label %if.end19

if.end19:                                         ; preds = %if.then17, %land.lhs.true, %if.end13
  %14 = load i32, ptr %flags, align 4
  %and20 = and i32 %14, 196608
  %cmp21 = icmp eq i32 %and20, 0
  br i1 %cmp21, label %if.then22, label %if.end25

if.then22:                                        ; preds = %if.end19
  %15 = load ptr, ptr %table.addr, align 8
  %Columns = getelementptr inbounds %struct.ImGuiTable, ptr %15, i32 0, i32 4
  %16 = load ptr, ptr %column.addr, align 8
  %call = call noundef i32 @_ZNK6ImSpanI16ImGuiTableColumnE14index_from_ptrEPKS0_(ptr noundef nonnull align 8 dereferenceable(16) %Columns, ptr noundef %16)
  %cmp23 = icmp eq i32 %call, 0
  %cond = select i1 %cmp23, i32 65536, i32 131072
  %17 = load i32, ptr %flags, align 4
  %or24 = or i32 %17, %cond
  store i32 %or24, ptr %flags, align 4
  br label %if.end25

if.end25:                                         ; preds = %if.then22, %if.end19
  %18 = load i32, ptr %flags, align 4
  %19 = load ptr, ptr %column.addr, align 8
  %Flags26 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %19, i32 0, i32 0
  %20 = load i32, ptr %Flags26, align 4
  %and27 = and i32 %20, 251658240
  %or28 = or i32 %18, %and27
  %21 = load ptr, ptr %column.addr, align 8
  %Flags29 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %21, i32 0, i32 0
  store i32 %or28, ptr %Flags29, align 4
  %22 = load ptr, ptr %column.addr, align 8
  %SortDirectionsAvailList = getelementptr inbounds %struct.ImGuiTableColumn, ptr %22, i32 0, i32 38
  store i8 0, ptr %SortDirectionsAvailList, align 2
  %23 = load ptr, ptr %column.addr, align 8
  %SortDirectionsAvailMask = getelementptr inbounds %struct.ImGuiTableColumn, ptr %23, i32 0, i32 37
  %bf.load = load i8, ptr %SortDirectionsAvailMask, align 1
  %bf.clear = and i8 %bf.load, 15
  %bf.set = or i8 %bf.clear, 0
  store i8 %bf.set, ptr %SortDirectionsAvailMask, align 1
  %24 = load ptr, ptr %column.addr, align 8
  %SortDirectionsAvailCount = getelementptr inbounds %struct.ImGuiTableColumn, ptr %24, i32 0, i32 37
  %bf.load30 = load i8, ptr %SortDirectionsAvailCount, align 1
  %bf.clear31 = and i8 %bf.load30, -13
  %bf.set32 = or i8 %bf.clear31, 0
  store i8 %bf.set32, ptr %SortDirectionsAvailCount, align 1
  %25 = load ptr, ptr %table.addr, align 8
  %Flags33 = getelementptr inbounds %struct.ImGuiTable, ptr %25, i32 0, i32 1
  %26 = load i32, ptr %Flags33, align 4
  %and34 = and i32 %26, 8
  %tobool35 = icmp ne i32 %and34, 0
  br i1 %tobool35, label %if.then36, label %if.end105

if.then36:                                        ; preds = %if.end25
  store i32 0, ptr %count, align 4
  store i32 0, ptr %mask, align 4
  store i32 0, ptr %list, align 4
  %27 = load i32, ptr %flags, align 4
  %and37 = and i32 %27, 16384
  %cmp38 = icmp ne i32 %and37, 0
  br i1 %cmp38, label %land.lhs.true39, label %if.end46

land.lhs.true39:                                  ; preds = %if.then36
  %28 = load i32, ptr %flags, align 4
  %and40 = and i32 %28, 1024
  %cmp41 = icmp eq i32 %and40, 0
  br i1 %cmp41, label %if.then42, label %if.end46

if.then42:                                        ; preds = %land.lhs.true39
  %29 = load i32, ptr %mask, align 4
  %or43 = or i32 %29, 2
  store i32 %or43, ptr %mask, align 4
  %30 = load i32, ptr %count, align 4
  %shl = shl i32 %30, 1
  %shl44 = shl i32 1, %shl
  %31 = load i32, ptr %list, align 4
  %or45 = or i32 %31, %shl44
  store i32 %or45, ptr %list, align 4
  %32 = load i32, ptr %count, align 4
  %inc = add nsw i32 %32, 1
  store i32 %inc, ptr %count, align 4
  br label %if.end46

if.end46:                                         ; preds = %if.then42, %land.lhs.true39, %if.then36
  %33 = load i32, ptr %flags, align 4
  %and47 = and i32 %33, 32768
  %cmp48 = icmp ne i32 %and47, 0
  br i1 %cmp48, label %land.lhs.true49, label %if.end58

land.lhs.true49:                                  ; preds = %if.end46
  %34 = load i32, ptr %flags, align 4
  %and50 = and i32 %34, 2048
  %cmp51 = icmp eq i32 %and50, 0
  br i1 %cmp51, label %if.then52, label %if.end58

if.then52:                                        ; preds = %land.lhs.true49
  %35 = load i32, ptr %mask, align 4
  %or53 = or i32 %35, 4
  store i32 %or53, ptr %mask, align 4
  %36 = load i32, ptr %count, align 4
  %shl54 = shl i32 %36, 1
  %shl55 = shl i32 2, %shl54
  %37 = load i32, ptr %list, align 4
  %or56 = or i32 %37, %shl55
  store i32 %or56, ptr %list, align 4
  %38 = load i32, ptr %count, align 4
  %inc57 = add nsw i32 %38, 1
  store i32 %inc57, ptr %count, align 4
  br label %if.end58

if.end58:                                         ; preds = %if.then52, %land.lhs.true49, %if.end46
  %39 = load i32, ptr %flags, align 4
  %and59 = and i32 %39, 16384
  %cmp60 = icmp eq i32 %and59, 0
  br i1 %cmp60, label %land.lhs.true61, label %if.end70

land.lhs.true61:                                  ; preds = %if.end58
  %40 = load i32, ptr %flags, align 4
  %and62 = and i32 %40, 1024
  %cmp63 = icmp eq i32 %and62, 0
  br i1 %cmp63, label %if.then64, label %if.end70

if.then64:                                        ; preds = %land.lhs.true61
  %41 = load i32, ptr %mask, align 4
  %or65 = or i32 %41, 2
  store i32 %or65, ptr %mask, align 4
  %42 = load i32, ptr %count, align 4
  %shl66 = shl i32 %42, 1
  %shl67 = shl i32 1, %shl66
  %43 = load i32, ptr %list, align 4
  %or68 = or i32 %43, %shl67
  store i32 %or68, ptr %list, align 4
  %44 = load i32, ptr %count, align 4
  %inc69 = add nsw i32 %44, 1
  store i32 %inc69, ptr %count, align 4
  br label %if.end70

if.end70:                                         ; preds = %if.then64, %land.lhs.true61, %if.end58
  %45 = load i32, ptr %flags, align 4
  %and71 = and i32 %45, 32768
  %cmp72 = icmp eq i32 %and71, 0
  br i1 %cmp72, label %land.lhs.true73, label %if.end82

land.lhs.true73:                                  ; preds = %if.end70
  %46 = load i32, ptr %flags, align 4
  %and74 = and i32 %46, 2048
  %cmp75 = icmp eq i32 %and74, 0
  br i1 %cmp75, label %if.then76, label %if.end82

if.then76:                                        ; preds = %land.lhs.true73
  %47 = load i32, ptr %mask, align 4
  %or77 = or i32 %47, 4
  store i32 %or77, ptr %mask, align 4
  %48 = load i32, ptr %count, align 4
  %shl78 = shl i32 %48, 1
  %shl79 = shl i32 2, %shl78
  %49 = load i32, ptr %list, align 4
  %or80 = or i32 %49, %shl79
  store i32 %or80, ptr %list, align 4
  %50 = load i32, ptr %count, align 4
  %inc81 = add nsw i32 %50, 1
  store i32 %inc81, ptr %count, align 4
  br label %if.end82

if.end82:                                         ; preds = %if.then76, %land.lhs.true73, %if.end70
  %51 = load ptr, ptr %table.addr, align 8
  %Flags83 = getelementptr inbounds %struct.ImGuiTable, ptr %51, i32 0, i32 1
  %52 = load i32, ptr %Flags83, align 4
  %and84 = and i32 %52, 134217728
  %tobool85 = icmp ne i32 %and84, 0
  br i1 %tobool85, label %if.then88, label %lor.lhs.false86

lor.lhs.false86:                                  ; preds = %if.end82
  %53 = load i32, ptr %count, align 4
  %cmp87 = icmp eq i32 %53, 0
  br i1 %cmp87, label %if.then88, label %if.end91

if.then88:                                        ; preds = %lor.lhs.false86, %if.end82
  %54 = load i32, ptr %mask, align 4
  %or89 = or i32 %54, 1
  store i32 %or89, ptr %mask, align 4
  %55 = load i32, ptr %count, align 4
  %inc90 = add nsw i32 %55, 1
  store i32 %inc90, ptr %count, align 4
  br label %if.end91

if.end91:                                         ; preds = %if.then88, %lor.lhs.false86
  %56 = load i32, ptr %list, align 4
  %conv = trunc i32 %56 to i8
  %57 = load ptr, ptr %column.addr, align 8
  %SortDirectionsAvailList92 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %57, i32 0, i32 38
  store i8 %conv, ptr %SortDirectionsAvailList92, align 2
  %58 = load i32, ptr %mask, align 4
  %conv93 = trunc i32 %58 to i8
  %59 = load ptr, ptr %column.addr, align 8
  %SortDirectionsAvailMask94 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %59, i32 0, i32 37
  %bf.load95 = load i8, ptr %SortDirectionsAvailMask94, align 1
  %bf.value = and i8 %conv93, 15
  %bf.shl = shl i8 %bf.value, 4
  %bf.clear96 = and i8 %bf.load95, 15
  %bf.set97 = or i8 %bf.clear96, %bf.shl
  store i8 %bf.set97, ptr %SortDirectionsAvailMask94, align 1
  %60 = load i32, ptr %count, align 4
  %conv98 = trunc i32 %60 to i8
  %61 = load ptr, ptr %column.addr, align 8
  %SortDirectionsAvailCount99 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %61, i32 0, i32 37
  %bf.load100 = load i8, ptr %SortDirectionsAvailCount99, align 1
  %bf.value101 = and i8 %conv98, 3
  %bf.shl102 = shl i8 %bf.value101, 2
  %bf.clear103 = and i8 %bf.load100, -13
  %bf.set104 = or i8 %bf.clear103, %bf.shl102
  store i8 %bf.set104, ptr %SortDirectionsAvailCount99, align 1
  %62 = load ptr, ptr %table.addr, align 8
  %63 = load ptr, ptr %column.addr, align 8
  call void @_ZN5ImGui27TableFixColumnSortDirectionEP10ImGuiTableP16ImGuiTableColumn(ptr noundef %62, ptr noundef %63)
  br label %if.end105

if.end105:                                        ; preds = %if.end91, %if.end25
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_Z16ImBitArraySetBitPji(ptr noundef %arr, i32 noundef %n) #3 comdat {
entry:
  %arr.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  %mask = alloca i32, align 4
  store ptr %arr, ptr %arr.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %0 = load i32, ptr %n.addr, align 4
  %and = and i32 %0, 31
  %shl = shl i32 1, %and
  store i32 %shl, ptr %mask, align 4
  %1 = load i32, ptr %mask, align 4
  %2 = load ptr, ptr %arr.addr, align 8
  %3 = load i32, ptr %n.addr, align 4
  %shr = ashr i32 %3, 5
  %idxprom = sext i32 %shr to i64
  %arrayidx = getelementptr inbounds i32, ptr %2, i64 %idxprom
  %4 = load i32, ptr %arrayidx, align 4
  %or = or i32 %4, %1
  store i32 %or, ptr %arrayidx, align 4
  ret void
}

; Function Attrs: mustprogress uwtable
define noundef float @_ZN5ImGui23TableGetColumnWidthAutoEP10ImGuiTableP16ImGuiTableColumn(ptr noundef %table, ptr noundef %column) #0 {
entry:
  %table.addr = alloca ptr, align 8
  %column.addr = alloca ptr, align 8
  %content_width_body = alloca float, align 4
  %content_width_headers = alloca float, align 4
  %width_auto = alloca float, align 4
  store ptr %table, ptr %table.addr, align 8
  store ptr %column, ptr %column.addr, align 8
  %0 = load ptr, ptr %column.addr, align 8
  %ContentMaxXFrozen = getelementptr inbounds %struct.ImGuiTableColumn, ptr %0, i32 0, i32 13
  %1 = load float, ptr %ContentMaxXFrozen, align 4
  %2 = load ptr, ptr %column.addr, align 8
  %ContentMaxXUnfrozen = getelementptr inbounds %struct.ImGuiTableColumn, ptr %2, i32 0, i32 14
  %3 = load float, ptr %ContentMaxXUnfrozen, align 4
  %call = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %1, float noundef %3)
  %4 = load ptr, ptr %column.addr, align 8
  %WorkMinX = getelementptr inbounds %struct.ImGuiTableColumn, ptr %4, i32 0, i32 10
  %5 = load float, ptr %WorkMinX, align 4
  %sub = fsub float %call, %5
  store float %sub, ptr %content_width_body, align 4
  %6 = load ptr, ptr %column.addr, align 8
  %ContentMaxXHeadersIdeal = getelementptr inbounds %struct.ImGuiTableColumn, ptr %6, i32 0, i32 16
  %7 = load float, ptr %ContentMaxXHeadersIdeal, align 4
  %8 = load ptr, ptr %column.addr, align 8
  %WorkMinX1 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %8, i32 0, i32 10
  %9 = load float, ptr %WorkMinX1, align 4
  %sub2 = fsub float %7, %9
  store float %sub2, ptr %content_width_headers, align 4
  %10 = load float, ptr %content_width_body, align 4
  store float %10, ptr %width_auto, align 4
  %11 = load ptr, ptr %column.addr, align 8
  %Flags = getelementptr inbounds %struct.ImGuiTableColumn, ptr %11, i32 0, i32 0
  %12 = load i32, ptr %Flags, align 4
  %and = and i32 %12, 8192
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %13 = load float, ptr %width_auto, align 4
  %14 = load float, ptr %content_width_headers, align 4
  %call3 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %13, float noundef %14)
  store float %call3, ptr %width_auto, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %15 = load ptr, ptr %column.addr, align 8
  %Flags4 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %15, i32 0, i32 0
  %16 = load i32, ptr %Flags4, align 4
  %and5 = and i32 %16, 16
  %tobool6 = icmp ne i32 %and5, 0
  br i1 %tobool6, label %land.lhs.true, label %if.end17

land.lhs.true:                                    ; preds = %if.end
  %17 = load ptr, ptr %column.addr, align 8
  %InitStretchWeightOrWidth = getelementptr inbounds %struct.ImGuiTableColumn, ptr %17, i32 0, i32 7
  %18 = load float, ptr %InitStretchWeightOrWidth, align 4
  %cmp = fcmp ogt float %18, 0.000000e+00
  br i1 %cmp, label %if.then7, label %if.end17

if.then7:                                         ; preds = %land.lhs.true
  %19 = load ptr, ptr %table.addr, align 8
  %Flags8 = getelementptr inbounds %struct.ImGuiTable, ptr %19, i32 0, i32 1
  %20 = load i32, ptr %Flags8, align 4
  %and9 = and i32 %20, 1
  %tobool10 = icmp ne i32 %and9, 0
  br i1 %tobool10, label %lor.lhs.false, label %if.then14

lor.lhs.false:                                    ; preds = %if.then7
  %21 = load ptr, ptr %column.addr, align 8
  %Flags11 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %21, i32 0, i32 0
  %22 = load i32, ptr %Flags11, align 4
  %and12 = and i32 %22, 32
  %tobool13 = icmp ne i32 %and12, 0
  br i1 %tobool13, label %if.then14, label %if.end16

if.then14:                                        ; preds = %lor.lhs.false, %if.then7
  %23 = load ptr, ptr %column.addr, align 8
  %InitStretchWeightOrWidth15 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %23, i32 0, i32 7
  %24 = load float, ptr %InitStretchWeightOrWidth15, align 4
  store float %24, ptr %width_auto, align 4
  br label %if.end16

if.end16:                                         ; preds = %if.then14, %lor.lhs.false
  br label %if.end17

if.end17:                                         ; preds = %if.end16, %land.lhs.true, %if.end
  %25 = load float, ptr %width_auto, align 4
  %26 = load ptr, ptr %table.addr, align 8
  %MinColumnWidth = getelementptr inbounds %struct.ImGuiTable, ptr %26, i32 0, i32 32
  %27 = load float, ptr %MinColumnWidth, align 8
  %call18 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %25, float noundef %27)
  ret float %call18
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.fmuladd.f32(float, float, float) #6

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef float @_ZNK6ImRect8GetWidthEv(ptr noundef nonnull align 4 dereferenceable(16) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Max = getelementptr inbounds %struct.ImRect, ptr %this1, i32 0, i32 1
  %x = getelementptr inbounds %struct.ImVec2, ptr %Max, i32 0, i32 0
  %0 = load float, ptr %x, align 4
  %Min = getelementptr inbounds %struct.ImRect, ptr %this1, i32 0, i32 0
  %x2 = getelementptr inbounds %struct.ImVec2, ptr %Min, i32 0, i32 0
  %1 = load float, ptr %x2, align 4
  %sub = fsub float %0, %1
  ret float %sub
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef float @_ZL7ImTruncf(float noundef %f) #3 {
entry:
  %f.addr = alloca float, align 4
  store float %f, ptr %f.addr, align 4
  %0 = load float, ptr %f.addr, align 4
  %conv = fptosi float %0 to i32
  %conv1 = sitofp i32 %conv to float
  ret float %conv1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN6ImRectC2Effff(ptr noundef nonnull align 4 dereferenceable(16) %this, float noundef %x1, float noundef %y1, float noundef %x2, float noundef %y2) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %x1.addr = alloca float, align 4
  %y1.addr = alloca float, align 4
  %x2.addr = alloca float, align 4
  %y2.addr = alloca float, align 4
  store ptr %this, ptr %this.addr, align 8
  store float %x1, ptr %x1.addr, align 4
  store float %y1, ptr %y1.addr, align 4
  store float %x2, ptr %x2.addr, align 4
  store float %y2, ptr %y2.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Min = getelementptr inbounds %struct.ImRect, ptr %this1, i32 0, i32 0
  %0 = load float, ptr %x1.addr, align 4
  %1 = load float, ptr %y1.addr, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %Min, float noundef %0, float noundef %1)
  %Max = getelementptr inbounds %struct.ImRect, ptr %this1, i32 0, i32 1
  %2 = load float, ptr %x2.addr, align 4
  %3 = load float, ptr %y2.addr, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %Max, float noundef %2, float noundef %3)
  ret void
}

declare noundef zeroext i1 @_ZN5ImGui13ItemHoverableERK6ImRectji(ptr noundef nonnull align 4 dereferenceable(16), i32 noundef, i32 noundef) #1

; Function Attrs: mustprogress uwtable
define noundef float @_ZN5ImGui22TableGetMaxColumnWidthEPK10ImGuiTablei(ptr noundef %table, i32 noundef %column_n) #0 {
entry:
  %table.addr = alloca ptr, align 8
  %column_n.addr = alloca i32, align 4
  %column = alloca ptr, align 8
  %max_width = alloca float, align 4
  %min_column_distance = alloca float, align 4
  store ptr %table, ptr %table.addr, align 8
  store i32 %column_n, ptr %column_n.addr, align 4
  %0 = load ptr, ptr %table.addr, align 8
  %Columns = getelementptr inbounds %struct.ImGuiTable, ptr %0, i32 0, i32 4
  %1 = load i32, ptr %column_n.addr, align 4
  %call = call noundef nonnull align 4 dereferenceable(111) ptr @_ZNK6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns, i32 noundef %1)
  store ptr %call, ptr %column, align 8
  store float 0x47EFFFFFE0000000, ptr %max_width, align 4
  %2 = load ptr, ptr %table.addr, align 8
  %MinColumnWidth = getelementptr inbounds %struct.ImGuiTable, ptr %2, i32 0, i32 32
  %3 = load float, ptr %MinColumnWidth, align 8
  %4 = load ptr, ptr %table.addr, align 8
  %CellPaddingX = getelementptr inbounds %struct.ImGuiTable, ptr %4, i32 0, i32 34
  %5 = load float, ptr %CellPaddingX, align 8
  %6 = call float @llvm.fmuladd.f32(float %5, float 2.000000e+00, float %3)
  %7 = load ptr, ptr %table.addr, align 8
  %CellSpacingX1 = getelementptr inbounds %struct.ImGuiTable, ptr %7, i32 0, i32 35
  %8 = load float, ptr %CellSpacingX1, align 4
  %add = fadd float %6, %8
  %9 = load ptr, ptr %table.addr, align 8
  %CellSpacingX2 = getelementptr inbounds %struct.ImGuiTable, ptr %9, i32 0, i32 36
  %10 = load float, ptr %CellSpacingX2, align 8
  %add1 = fadd float %add, %10
  store float %add1, ptr %min_column_distance, align 4
  %11 = load ptr, ptr %table.addr, align 8
  %Flags = getelementptr inbounds %struct.ImGuiTable, ptr %11, i32 0, i32 1
  %12 = load i32, ptr %Flags, align 4
  %and = and i32 %12, 16777216
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %13 = load ptr, ptr %column, align 8
  %DisplayOrder = getelementptr inbounds %struct.ImGuiTableColumn, ptr %13, i32 0, i32 18
  %14 = load i16, ptr %DisplayOrder, align 2
  %conv = sext i16 %14 to i32
  %15 = load ptr, ptr %table.addr, align 8
  %FreezeColumnsRequest = getelementptr inbounds %struct.ImGuiTable, ptr %15, i32 0, i32 86
  %16 = load i16, ptr %FreezeColumnsRequest, align 2
  %conv2 = sext i16 %16 to i32
  %cmp = icmp slt i32 %conv, %conv2
  br i1 %cmp, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %17 = load ptr, ptr %table.addr, align 8
  %InnerClipRect = getelementptr inbounds %struct.ImGuiTable, ptr %17, i32 0, i32 49
  %Max = getelementptr inbounds %struct.ImRect, ptr %InnerClipRect, i32 0, i32 1
  %x = getelementptr inbounds %struct.ImVec2, ptr %Max, i32 0, i32 0
  %18 = load float, ptr %x, align 8
  %19 = load ptr, ptr %table.addr, align 8
  %FreezeColumnsRequest4 = getelementptr inbounds %struct.ImGuiTable, ptr %19, i32 0, i32 86
  %20 = load i16, ptr %FreezeColumnsRequest4, align 2
  %conv5 = sext i16 %20 to i32
  %21 = load ptr, ptr %column, align 8
  %DisplayOrder6 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %21, i32 0, i32 18
  %22 = load i16, ptr %DisplayOrder6, align 2
  %conv7 = sext i16 %22 to i32
  %sub = sub nsw i32 %conv5, %conv7
  %conv8 = sitofp i32 %sub to float
  %23 = load float, ptr %min_column_distance, align 4
  %neg = fneg float %conv8
  %24 = call float @llvm.fmuladd.f32(float %neg, float %23, float %18)
  %25 = load ptr, ptr %column, align 8
  %MinX = getelementptr inbounds %struct.ImGuiTableColumn, ptr %25, i32 0, i32 2
  %26 = load float, ptr %MinX, align 4
  %sub9 = fsub float %24, %26
  store float %sub9, ptr %max_width, align 4
  %27 = load float, ptr %max_width, align 4
  %28 = load ptr, ptr %table.addr, align 8
  %OuterPaddingX = getelementptr inbounds %struct.ImGuiTable, ptr %28, i32 0, i32 33
  %29 = load float, ptr %OuterPaddingX, align 4
  %sub10 = fsub float %27, %29
  %30 = load ptr, ptr %table.addr, align 8
  %CellPaddingX11 = getelementptr inbounds %struct.ImGuiTable, ptr %30, i32 0, i32 34
  %31 = load float, ptr %CellPaddingX11, align 8
  %sub12 = fsub float %sub10, %31
  %32 = load ptr, ptr %table.addr, align 8
  %CellSpacingX213 = getelementptr inbounds %struct.ImGuiTable, ptr %32, i32 0, i32 36
  %33 = load float, ptr %CellSpacingX213, align 8
  %sub14 = fsub float %sub12, %33
  store float %sub14, ptr %max_width, align 4
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.then
  br label %if.end36

if.else:                                          ; preds = %entry
  %34 = load ptr, ptr %table.addr, align 8
  %Flags15 = getelementptr inbounds %struct.ImGuiTable, ptr %34, i32 0, i32 1
  %35 = load i32, ptr %Flags15, align 4
  %and16 = and i32 %35, 262144
  %cmp17 = icmp eq i32 %and16, 0
  br i1 %cmp17, label %if.then18, label %if.end35

if.then18:                                        ; preds = %if.else
  %36 = load ptr, ptr %table.addr, align 8
  %WorkRect = getelementptr inbounds %struct.ImGuiTable, ptr %36, i32 0, i32 48
  %Max19 = getelementptr inbounds %struct.ImRect, ptr %WorkRect, i32 0, i32 1
  %x20 = getelementptr inbounds %struct.ImVec2, ptr %Max19, i32 0, i32 0
  %37 = load float, ptr %x20, align 8
  %38 = load ptr, ptr %table.addr, align 8
  %ColumnsEnabledCount = getelementptr inbounds %struct.ImGuiTable, ptr %38, i32 0, i32 66
  %39 = load i16, ptr %ColumnsEnabledCount, align 2
  %conv21 = sext i16 %39 to i32
  %40 = load ptr, ptr %column, align 8
  %IndexWithinEnabledSet = getelementptr inbounds %struct.ImGuiTableColumn, ptr %40, i32 0, i32 19
  %41 = load i16, ptr %IndexWithinEnabledSet, align 4
  %conv22 = sext i16 %41 to i32
  %sub23 = sub nsw i32 %conv21, %conv22
  %sub24 = sub nsw i32 %sub23, 1
  %conv25 = sitofp i32 %sub24 to float
  %42 = load float, ptr %min_column_distance, align 4
  %neg26 = fneg float %conv25
  %43 = call float @llvm.fmuladd.f32(float %neg26, float %42, float %37)
  %44 = load ptr, ptr %column, align 8
  %MinX27 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %44, i32 0, i32 2
  %45 = load float, ptr %MinX27, align 4
  %sub28 = fsub float %43, %45
  store float %sub28, ptr %max_width, align 4
  %46 = load ptr, ptr %table.addr, align 8
  %CellSpacingX229 = getelementptr inbounds %struct.ImGuiTable, ptr %46, i32 0, i32 36
  %47 = load float, ptr %CellSpacingX229, align 8
  %48 = load float, ptr %max_width, align 4
  %sub30 = fsub float %48, %47
  store float %sub30, ptr %max_width, align 4
  %49 = load ptr, ptr %table.addr, align 8
  %CellPaddingX31 = getelementptr inbounds %struct.ImGuiTable, ptr %49, i32 0, i32 34
  %50 = load float, ptr %CellPaddingX31, align 8
  %51 = load float, ptr %max_width, align 4
  %neg32 = fneg float %50
  %52 = call float @llvm.fmuladd.f32(float %neg32, float 2.000000e+00, float %51)
  store float %52, ptr %max_width, align 4
  %53 = load ptr, ptr %table.addr, align 8
  %OuterPaddingX33 = getelementptr inbounds %struct.ImGuiTable, ptr %53, i32 0, i32 33
  %54 = load float, ptr %OuterPaddingX33, align 4
  %55 = load float, ptr %max_width, align 4
  %sub34 = fsub float %55, %54
  store float %sub34, ptr %max_width, align 4
  br label %if.end35

if.end35:                                         ; preds = %if.then18, %if.else
  br label %if.end36

if.end36:                                         ; preds = %if.end35, %if.end
  %56 = load float, ptr %max_width, align 4
  ret float %56
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef float @_ZL7ImClampIfET_S0_S0_S0_(float noundef %v, float noundef %mn, float noundef %mx) #3 {
entry:
  %v.addr = alloca float, align 4
  %mn.addr = alloca float, align 4
  %mx.addr = alloca float, align 4
  store float %v, ptr %v.addr, align 4
  store float %mn, ptr %mn.addr, align 4
  store float %mx, ptr %mx.addr, align 4
  %0 = load float, ptr %v.addr, align 4
  %1 = load float, ptr %mn.addr, align 4
  %cmp = fcmp olt float %0, %1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load float, ptr %mn.addr, align 4
  br label %cond.end4

cond.false:                                       ; preds = %entry
  %3 = load float, ptr %v.addr, align 4
  %4 = load float, ptr %mx.addr, align 4
  %cmp1 = fcmp ogt float %3, %4
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %5 = load float, ptr %mx.addr, align 4
  br label %cond.end

cond.false3:                                      ; preds = %cond.false
  %6 = load float, ptr %v.addr, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false3, %cond.true2
  %cond = phi float [ %5, %cond.true2 ], [ %6, %cond.false3 ]
  br label %cond.end4

cond.end4:                                        ; preds = %cond.end, %cond.true
  %cond5 = phi float [ %2, %cond.true ], [ %cond, %cond.end ]
  ret float %cond5
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui22TableSetupDrawChannelsEP10ImGuiTable(ptr noundef %table) #0 {
entry:
  %table.addr = alloca ptr, align 8
  %freeze_row_multiplier = alloca i32, align 4
  %channels_for_row = alloca i32, align 4
  %channels_for_bg = alloca i32, align 4
  %channels_for_dummy = alloca i32, align 4
  %channels_total = alloca i32, align 4
  %draw_channel_current = alloca i32, align 4
  %column_n = alloca i32, align 4
  %column = alloca ptr, align 8
  store ptr %table, ptr %table.addr, align 8
  %0 = load ptr, ptr %table.addr, align 8
  %FreezeRowsCount = getelementptr inbounds %struct.ImGuiTable, ptr %0, i32 0, i32 85
  %1 = load i16, ptr %FreezeRowsCount, align 8
  %conv = sext i16 %1 to i32
  %cmp = icmp sgt i32 %conv, 0
  %cond = select i1 %cmp, i32 2, i32 1
  store i32 %cond, ptr %freeze_row_multiplier, align 4
  %2 = load ptr, ptr %table.addr, align 8
  %Flags = getelementptr inbounds %struct.ImGuiTable, ptr %2, i32 0, i32 1
  %3 = load i32, ptr %Flags, align 4
  %and = and i32 %3, 1048576
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %4 = load ptr, ptr %table.addr, align 8
  %ColumnsEnabledCount = getelementptr inbounds %struct.ImGuiTable, ptr %4, i32 0, i32 66
  %5 = load i16, ptr %ColumnsEnabledCount, align 2
  %conv1 = sext i16 %5 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond2 = phi i32 [ 1, %cond.true ], [ %conv1, %cond.false ]
  store i32 %cond2, ptr %channels_for_row, align 4
  %6 = load i32, ptr %freeze_row_multiplier, align 4
  %mul = mul nsw i32 1, %6
  %add = add nsw i32 1, %mul
  store i32 %add, ptr %channels_for_bg, align 4
  %7 = load ptr, ptr %table.addr, align 8
  %ColumnsEnabledCount3 = getelementptr inbounds %struct.ImGuiTable, ptr %7, i32 0, i32 66
  %8 = load i16, ptr %ColumnsEnabledCount3, align 2
  %conv4 = sext i16 %8 to i32
  %9 = load ptr, ptr %table.addr, align 8
  %ColumnsCount = getelementptr inbounds %struct.ImGuiTable, ptr %9, i32 0, i32 13
  %10 = load i32, ptr %ColumnsCount, align 4
  %cmp5 = icmp slt i32 %conv4, %10
  br i1 %cmp5, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %cond.end
  %11 = load ptr, ptr %table.addr, align 8
  %VisibleMaskByIndex = getelementptr inbounds %struct.ImGuiTable, ptr %11, i32 0, i32 9
  %12 = load ptr, ptr %VisibleMaskByIndex, align 8
  %13 = load ptr, ptr %table.addr, align 8
  %EnabledMaskByIndex = getelementptr inbounds %struct.ImGuiTable, ptr %13, i32 0, i32 8
  %14 = load ptr, ptr %EnabledMaskByIndex, align 8
  %15 = load ptr, ptr %table.addr, align 8
  %ColumnsCount6 = getelementptr inbounds %struct.ImGuiTable, ptr %15, i32 0, i32 13
  %16 = load i32, ptr %ColumnsCount6, align 4
  %call = call noundef i64 @_Z31ImBitArrayGetStorageSizeInBytesi(i32 noundef %16)
  %call7 = call i32 @memcmp(ptr noundef %12, ptr noundef %14, i64 noundef %call) #11
  %cmp8 = icmp ne i32 %call7, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %cond.end
  %17 = phi i1 [ true, %cond.end ], [ %cmp8, %lor.rhs ]
  %cond9 = select i1 %17, i32 1, i32 0
  store i32 %cond9, ptr %channels_for_dummy, align 4
  %18 = load i32, ptr %channels_for_bg, align 4
  %19 = load i32, ptr %channels_for_row, align 4
  %20 = load i32, ptr %freeze_row_multiplier, align 4
  %mul10 = mul nsw i32 %19, %20
  %add11 = add nsw i32 %18, %mul10
  %21 = load i32, ptr %channels_for_dummy, align 4
  %add12 = add nsw i32 %add11, %21
  store i32 %add12, ptr %channels_total, align 4
  %22 = load ptr, ptr %table.addr, align 8
  %DrawSplitter = getelementptr inbounds %struct.ImGuiTable, ptr %22, i32 0, i32 58
  %23 = load ptr, ptr %DrawSplitter, align 8
  %24 = load ptr, ptr %table.addr, align 8
  %InnerWindow = getelementptr inbounds %struct.ImGuiTable, ptr %24, i32 0, i32 56
  %25 = load ptr, ptr %InnerWindow, align 8
  %DrawList = getelementptr inbounds %struct.ImGuiWindow, ptr %25, i32 0, i32 86
  %26 = load ptr, ptr %DrawList, align 8
  %27 = load i32, ptr %channels_total, align 4
  call void @_ZN18ImDrawListSplitter5SplitEP10ImDrawListi(ptr noundef nonnull align 8 dereferenceable(24) %23, ptr noundef %26, i32 noundef %27)
  %28 = load i32, ptr %channels_for_dummy, align 4
  %cmp13 = icmp sgt i32 %28, 0
  br i1 %cmp13, label %cond.true14, label %cond.false15

cond.true14:                                      ; preds = %lor.end
  %29 = load i32, ptr %channels_total, align 4
  %sub = sub nsw i32 %29, 1
  br label %cond.end16

cond.false15:                                     ; preds = %lor.end
  br label %cond.end16

cond.end16:                                       ; preds = %cond.false15, %cond.true14
  %cond17 = phi i32 [ %sub, %cond.true14 ], [ -1, %cond.false15 ]
  %conv18 = trunc i32 %cond17 to i16
  %30 = load ptr, ptr %table.addr, align 8
  %DummyDrawChannel = getelementptr inbounds %struct.ImGuiTable, ptr %30, i32 0, i32 89
  store i16 %conv18, ptr %DummyDrawChannel, align 8
  %31 = load ptr, ptr %table.addr, align 8
  %Bg2DrawChannelCurrent = getelementptr inbounds %struct.ImGuiTable, ptr %31, i32 0, i32 90
  store i16 1, ptr %Bg2DrawChannelCurrent, align 2
  %32 = load ptr, ptr %table.addr, align 8
  %FreezeRowsCount19 = getelementptr inbounds %struct.ImGuiTable, ptr %32, i32 0, i32 85
  %33 = load i16, ptr %FreezeRowsCount19, align 8
  %conv20 = sext i16 %33 to i32
  %cmp21 = icmp sgt i32 %conv20, 0
  br i1 %cmp21, label %cond.true22, label %cond.false24

cond.true22:                                      ; preds = %cond.end16
  %34 = load i32, ptr %channels_for_row, align 4
  %add23 = add nsw i32 2, %34
  br label %cond.end25

cond.false24:                                     ; preds = %cond.end16
  br label %cond.end25

cond.end25:                                       ; preds = %cond.false24, %cond.true22
  %cond26 = phi i32 [ %add23, %cond.true22 ], [ 1, %cond.false24 ]
  %conv27 = trunc i32 %cond26 to i16
  %35 = load ptr, ptr %table.addr, align 8
  %Bg2DrawChannelUnfrozen = getelementptr inbounds %struct.ImGuiTable, ptr %35, i32 0, i32 91
  store i16 %conv27, ptr %Bg2DrawChannelUnfrozen, align 4
  store i32 2, ptr %draw_channel_current, align 4
  store i32 0, ptr %column_n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end25
  %36 = load i32, ptr %column_n, align 4
  %37 = load ptr, ptr %table.addr, align 8
  %ColumnsCount28 = getelementptr inbounds %struct.ImGuiTable, ptr %37, i32 0, i32 13
  %38 = load i32, ptr %ColumnsCount28, align 4
  %cmp29 = icmp slt i32 %36, %38
  br i1 %cmp29, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %39 = load ptr, ptr %table.addr, align 8
  %Columns = getelementptr inbounds %struct.ImGuiTable, ptr %39, i32 0, i32 4
  %40 = load i32, ptr %column_n, align 4
  %call30 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns, i32 noundef %40)
  store ptr %call30, ptr %column, align 8
  %41 = load ptr, ptr %column, align 8
  %IsVisibleX = getelementptr inbounds %struct.ImGuiTableColumn, ptr %41, i32 0, i32 29
  %42 = load i8, ptr %IsVisibleX, align 1
  %tobool31 = trunc i8 %42 to i1
  br i1 %tobool31, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %for.body
  %43 = load ptr, ptr %column, align 8
  %IsVisibleY = getelementptr inbounds %struct.ImGuiTableColumn, ptr %43, i32 0, i32 30
  %44 = load i8, ptr %IsVisibleY, align 2
  %tobool32 = trunc i8 %44 to i1
  br i1 %tobool32, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %45 = load i32, ptr %draw_channel_current, align 4
  %conv33 = trunc i32 %45 to i16
  %46 = load ptr, ptr %column, align 8
  %DrawChannelFrozen = getelementptr inbounds %struct.ImGuiTableColumn, ptr %46, i32 0, i32 24
  store i16 %conv33, ptr %DrawChannelFrozen, align 2
  %47 = load i32, ptr %draw_channel_current, align 4
  %48 = load ptr, ptr %table.addr, align 8
  %FreezeRowsCount34 = getelementptr inbounds %struct.ImGuiTable, ptr %48, i32 0, i32 85
  %49 = load i16, ptr %FreezeRowsCount34, align 8
  %conv35 = sext i16 %49 to i32
  %cmp36 = icmp sgt i32 %conv35, 0
  br i1 %cmp36, label %cond.true37, label %cond.false39

cond.true37:                                      ; preds = %if.then
  %50 = load i32, ptr %channels_for_row, align 4
  %add38 = add nsw i32 %50, 1
  br label %cond.end40

cond.false39:                                     ; preds = %if.then
  br label %cond.end40

cond.end40:                                       ; preds = %cond.false39, %cond.true37
  %cond41 = phi i32 [ %add38, %cond.true37 ], [ 0, %cond.false39 ]
  %add42 = add nsw i32 %47, %cond41
  %conv43 = trunc i32 %add42 to i16
  %51 = load ptr, ptr %column, align 8
  %DrawChannelUnfrozen = getelementptr inbounds %struct.ImGuiTableColumn, ptr %51, i32 0, i32 25
  store i16 %conv43, ptr %DrawChannelUnfrozen, align 4
  %52 = load ptr, ptr %table.addr, align 8
  %Flags44 = getelementptr inbounds %struct.ImGuiTable, ptr %52, i32 0, i32 1
  %53 = load i32, ptr %Flags44, align 4
  %and45 = and i32 %53, 1048576
  %tobool46 = icmp ne i32 %and45, 0
  br i1 %tobool46, label %if.end, label %if.then47

if.then47:                                        ; preds = %cond.end40
  %54 = load i32, ptr %draw_channel_current, align 4
  %inc = add nsw i32 %54, 1
  store i32 %inc, ptr %draw_channel_current, align 4
  br label %if.end

if.end:                                           ; preds = %if.then47, %cond.end40
  br label %if.end51

if.else:                                          ; preds = %land.lhs.true, %for.body
  %55 = load ptr, ptr %table.addr, align 8
  %DummyDrawChannel48 = getelementptr inbounds %struct.ImGuiTable, ptr %55, i32 0, i32 89
  %56 = load i16, ptr %DummyDrawChannel48, align 8
  %57 = load ptr, ptr %column, align 8
  %DrawChannelUnfrozen49 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %57, i32 0, i32 25
  store i16 %56, ptr %DrawChannelUnfrozen49, align 4
  %58 = load ptr, ptr %column, align 8
  %DrawChannelFrozen50 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %58, i32 0, i32 24
  store i16 %56, ptr %DrawChannelFrozen50, align 2
  br label %if.end51

if.end51:                                         ; preds = %if.else, %if.end
  %59 = load ptr, ptr %column, align 8
  %DrawChannelFrozen52 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %59, i32 0, i32 24
  %60 = load i16, ptr %DrawChannelFrozen52, align 2
  %61 = load ptr, ptr %column, align 8
  %DrawChannelCurrent = getelementptr inbounds %struct.ImGuiTableColumn, ptr %61, i32 0, i32 23
  store i16 %60, ptr %DrawChannelCurrent, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end51
  %62 = load i32, ptr %column_n, align 4
  %inc53 = add nsw i32 %62, 1
  store i32 %inc53, ptr %column_n, align 4
  br label %for.cond, !llvm.loop !21

for.end:                                          ; preds = %for.cond
  %63 = load ptr, ptr %table.addr, align 8
  %InnerClipRect = getelementptr inbounds %struct.ImGuiTable, ptr %63, i32 0, i32 49
  %64 = load ptr, ptr %table.addr, align 8
  %BgClipRect = getelementptr inbounds %struct.ImGuiTable, ptr %64, i32 0, i32 50
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %BgClipRect, ptr align 8 %InnerClipRect, i64 16, i1 false)
  %65 = load ptr, ptr %table.addr, align 8
  %OuterWindow = getelementptr inbounds %struct.ImGuiTable, ptr %65, i32 0, i32 55
  %66 = load ptr, ptr %OuterWindow, align 8
  %ClipRect = getelementptr inbounds %struct.ImGuiWindow, ptr %66, i32 0, i32 74
  %67 = load ptr, ptr %table.addr, align 8
  %Bg0ClipRectForDrawCmd = getelementptr inbounds %struct.ImGuiTable, ptr %67, i32 0, i32 51
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %Bg0ClipRectForDrawCmd, ptr align 8 %ClipRect, i64 16, i1 false)
  %68 = load ptr, ptr %table.addr, align 8
  %HostClipRect = getelementptr inbounds %struct.ImGuiTable, ptr %68, i32 0, i32 53
  %69 = load ptr, ptr %table.addr, align 8
  %Bg2ClipRectForDrawCmd = getelementptr inbounds %struct.ImGuiTable, ptr %69, i32 0, i32 52
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %Bg2ClipRectForDrawCmd, ptr align 8 %HostClipRect, i64 16, i1 false)
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui18TableUpdateBordersEP10ImGuiTable(ptr noundef %table) #0 {
entry:
  %table.addr = alloca ptr, align 8
  %g = alloca ptr, align 8
  %table_instance = alloca ptr, align 8
  %hit_half_width = alloca float, align 4
  %hit_y1 = alloca float, align 4
  %hit_y2_body = alloca float, align 4
  %hit_y2_head = alloca float, align 4
  %order_n = alloca i32, align 4
  %column_n = alloca i32, align 4
  %column = alloca ptr, align 8
  %border_y2_hit = alloca float, align 4
  %column_id = alloca i32, align 4
  %hit_rect = alloca %struct.ImRect, align 4
  %hovered = alloca i8, align 1
  %held = alloca i8, align 1
  %pressed = alloca i8, align 1
  store ptr %table, ptr %table.addr, align 8
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %table.addr, align 8
  %2 = load ptr, ptr %table.addr, align 8
  %InstanceCurrent = getelementptr inbounds %struct.ImGuiTable, ptr %2, i32 0, i32 16
  %3 = load i16, ptr %InstanceCurrent, align 8
  %conv = sext i16 %3 to i32
  %call = call noundef ptr @_ZN5ImGui20TableGetInstanceDataEP10ImGuiTablei(ptr noundef %1, i32 noundef %conv)
  store ptr %call, ptr %table_instance, align 8
  store float 4.000000e+00, ptr %hit_half_width, align 4
  %4 = load ptr, ptr %table.addr, align 8
  %FreezeRowsCount = getelementptr inbounds %struct.ImGuiTable, ptr %4, i32 0, i32 85
  %5 = load i16, ptr %FreezeRowsCount, align 8
  %conv1 = sext i16 %5 to i32
  %cmp = icmp sge i32 %conv1, 1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %6 = load ptr, ptr %table.addr, align 8
  %OuterRect = getelementptr inbounds %struct.ImGuiTable, ptr %6, i32 0, i32 46
  %Min = getelementptr inbounds %struct.ImRect, ptr %OuterRect, i32 0, i32 0
  %y = getelementptr inbounds %struct.ImVec2, ptr %Min, i32 0, i32 1
  %7 = load float, ptr %y, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %8 = load ptr, ptr %table.addr, align 8
  %WorkRect = getelementptr inbounds %struct.ImGuiTable, ptr %8, i32 0, i32 48
  %Min2 = getelementptr inbounds %struct.ImRect, ptr %WorkRect, i32 0, i32 0
  %y3 = getelementptr inbounds %struct.ImVec2, ptr %Min2, i32 0, i32 1
  %9 = load float, ptr %y3, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi float [ %7, %cond.true ], [ %9, %cond.false ]
  %10 = load ptr, ptr %table.addr, align 8
  %AngledHeadersHeight = getelementptr inbounds %struct.ImGuiTable, ptr %10, i32 0, i32 44
  %11 = load float, ptr %AngledHeadersHeight, align 8
  %add = fadd float %cond, %11
  store float %add, ptr %hit_y1, align 4
  %12 = load ptr, ptr %table.addr, align 8
  %OuterRect4 = getelementptr inbounds %struct.ImGuiTable, ptr %12, i32 0, i32 46
  %Max = getelementptr inbounds %struct.ImRect, ptr %OuterRect4, i32 0, i32 1
  %y5 = getelementptr inbounds %struct.ImVec2, ptr %Max, i32 0, i32 1
  %13 = load float, ptr %y5, align 4
  %14 = load float, ptr %hit_y1, align 4
  %15 = load ptr, ptr %table_instance, align 8
  %LastOuterHeight = getelementptr inbounds %struct.ImGuiTableInstanceData, ptr %15, i32 0, i32 1
  %16 = load float, ptr %LastOuterHeight, align 4
  %add6 = fadd float %14, %16
  %call7 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %13, float noundef %add6)
  store float %call7, ptr %hit_y2_body, align 4
  %17 = load float, ptr %hit_y1, align 4
  %18 = load ptr, ptr %table_instance, align 8
  %LastTopHeadersRowHeight = getelementptr inbounds %struct.ImGuiTableInstanceData, ptr %18, i32 0, i32 2
  %19 = load float, ptr %LastTopHeadersRowHeight, align 4
  %add8 = fadd float %17, %19
  store float %add8, ptr %hit_y2_head, align 4
  store i32 0, ptr %order_n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %20 = load i32, ptr %order_n, align 4
  %21 = load ptr, ptr %table.addr, align 8
  %ColumnsCount = getelementptr inbounds %struct.ImGuiTable, ptr %21, i32 0, i32 13
  %22 = load i32, ptr %ColumnsCount, align 4
  %cmp9 = icmp slt i32 %20, %22
  br i1 %cmp9, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %23 = load ptr, ptr %table.addr, align 8
  %EnabledMaskByDisplayOrder = getelementptr inbounds %struct.ImGuiTable, ptr %23, i32 0, i32 7
  %24 = load ptr, ptr %EnabledMaskByDisplayOrder, align 8
  %25 = load i32, ptr %order_n, align 4
  %shr = ashr i32 %25, 5
  %idxprom = sext i32 %shr to i64
  %arrayidx = getelementptr inbounds i32, ptr %24, i64 %idxprom
  %26 = load i32, ptr %arrayidx, align 4
  %27 = load i32, ptr %order_n, align 4
  %and = and i32 %27, 31
  %shl = shl i32 1, %and
  %and10 = and i32 %26, %shl
  %cmp11 = icmp ne i32 %and10, 0
  br i1 %cmp11, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  br label %for.inc

if.end:                                           ; preds = %for.body
  %28 = load ptr, ptr %table.addr, align 8
  %DisplayOrderToIndex = getelementptr inbounds %struct.ImGuiTable, ptr %28, i32 0, i32 5
  %29 = load i32, ptr %order_n, align 4
  %call12 = call noundef nonnull align 2 dereferenceable(2) ptr @_ZN6ImSpanIsEixEi(ptr noundef nonnull align 8 dereferenceable(16) %DisplayOrderToIndex, i32 noundef %29)
  %30 = load i16, ptr %call12, align 2
  %conv13 = sext i16 %30 to i32
  store i32 %conv13, ptr %column_n, align 4
  %31 = load ptr, ptr %table.addr, align 8
  %Columns = getelementptr inbounds %struct.ImGuiTable, ptr %31, i32 0, i32 4
  %32 = load i32, ptr %column_n, align 4
  %call14 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns, i32 noundef %32)
  store ptr %call14, ptr %column, align 8
  %33 = load ptr, ptr %column, align 8
  %Flags = getelementptr inbounds %struct.ImGuiTableColumn, ptr %33, i32 0, i32 0
  %34 = load i32, ptr %Flags, align 4
  %and15 = and i32 %34, 1073741856
  %tobool = icmp ne i32 %and15, 0
  br i1 %tobool, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.end
  br label %for.inc

if.end17:                                         ; preds = %if.end
  %35 = load ptr, ptr %table.addr, align 8
  %Flags18 = getelementptr inbounds %struct.ImGuiTable, ptr %35, i32 0, i32 1
  %36 = load i32, ptr %Flags18, align 4
  %and19 = and i32 %36, 2048
  %tobool20 = icmp ne i32 %and19, 0
  br i1 %tobool20, label %cond.true21, label %cond.false22

cond.true21:                                      ; preds = %if.end17
  %37 = load float, ptr %hit_y2_head, align 4
  br label %cond.end23

cond.false22:                                     ; preds = %if.end17
  %38 = load float, ptr %hit_y2_body, align 4
  br label %cond.end23

cond.end23:                                       ; preds = %cond.false22, %cond.true21
  %cond24 = phi float [ %37, %cond.true21 ], [ %38, %cond.false22 ]
  store float %cond24, ptr %border_y2_hit, align 4
  %39 = load ptr, ptr %table.addr, align 8
  %Flags25 = getelementptr inbounds %struct.ImGuiTable, ptr %39, i32 0, i32 1
  %40 = load i32, ptr %Flags25, align 4
  %and26 = and i32 %40, 2048
  %tobool27 = icmp ne i32 %and26, 0
  br i1 %tobool27, label %land.lhs.true, label %if.end32

land.lhs.true:                                    ; preds = %cond.end23
  %41 = load ptr, ptr %table.addr, align 8
  %IsUsingHeaders = getelementptr inbounds %struct.ImGuiTable, ptr %41, i32 0, i32 96
  %42 = load i8, ptr %IsUsingHeaders, align 2
  %tobool28 = trunc i8 %42 to i1
  %conv29 = zext i1 %tobool28 to i32
  %cmp30 = icmp eq i32 %conv29, 0
  br i1 %cmp30, label %if.then31, label %if.end32

if.then31:                                        ; preds = %land.lhs.true
  br label %for.inc

if.end32:                                         ; preds = %land.lhs.true, %cond.end23
  %43 = load ptr, ptr %column, align 8
  %IsVisibleX = getelementptr inbounds %struct.ImGuiTableColumn, ptr %43, i32 0, i32 29
  %44 = load i8, ptr %IsVisibleX, align 1
  %tobool33 = trunc i8 %44 to i1
  br i1 %tobool33, label %if.end38, label %land.lhs.true34

land.lhs.true34:                                  ; preds = %if.end32
  %45 = load ptr, ptr %table.addr, align 8
  %LastResizedColumn = getelementptr inbounds %struct.ImGuiTable, ptr %45, i32 0, i32 75
  %46 = load i16, ptr %LastResizedColumn, align 4
  %conv35 = sext i16 %46 to i32
  %47 = load i32, ptr %column_n, align 4
  %cmp36 = icmp ne i32 %conv35, %47
  br i1 %cmp36, label %if.then37, label %if.end38

if.then37:                                        ; preds = %land.lhs.true34
  br label %for.inc

if.end38:                                         ; preds = %land.lhs.true34, %if.end32
  %48 = load ptr, ptr %table.addr, align 8
  %49 = load i32, ptr %column_n, align 4
  %50 = load ptr, ptr %table.addr, align 8
  %InstanceCurrent39 = getelementptr inbounds %struct.ImGuiTable, ptr %50, i32 0, i32 16
  %51 = load i16, ptr %InstanceCurrent39, align 8
  %conv40 = sext i16 %51 to i32
  %call41 = call noundef i32 @_ZN5ImGui22TableGetColumnResizeIDEP10ImGuiTableii(ptr noundef %48, i32 noundef %49, i32 noundef %conv40)
  store i32 %call41, ptr %column_id, align 4
  %52 = load ptr, ptr %column, align 8
  %MaxX = getelementptr inbounds %struct.ImGuiTableColumn, ptr %52, i32 0, i32 3
  %53 = load float, ptr %MaxX, align 4
  %sub = fsub float %53, 4.000000e+00
  %54 = load float, ptr %hit_y1, align 4
  %55 = load ptr, ptr %column, align 8
  %MaxX42 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %55, i32 0, i32 3
  %56 = load float, ptr %MaxX42, align 4
  %add43 = fadd float %56, 4.000000e+00
  %57 = load float, ptr %border_y2_hit, align 4
  call void @_ZN6ImRectC2Effff(ptr noundef nonnull align 4 dereferenceable(16) %hit_rect, float noundef %sub, float noundef %54, float noundef %add43, float noundef %57)
  %58 = load i32, ptr %column_id, align 4
  %call44 = call noundef zeroext i1 @_ZN5ImGui7ItemAddERK6ImRectjPS1_i(ptr noundef nonnull align 4 dereferenceable(16) %hit_rect, i32 noundef %58, ptr noundef null, i32 noundef 8)
  store i8 0, ptr %hovered, align 1
  store i8 0, ptr %held, align 1
  %59 = load i32, ptr %column_id, align 4
  %call45 = call noundef zeroext i1 @_ZN5ImGui14ButtonBehaviorERK6ImRectjPbS3_i(ptr noundef nonnull align 4 dereferenceable(16) %hit_rect, i32 noundef %59, ptr noundef %hovered, ptr noundef %held, i32 noundef 264464)
  %frombool = zext i1 %call45 to i8
  store i8 %frombool, ptr %pressed, align 1
  %60 = load i8, ptr %pressed, align 1
  %tobool46 = trunc i8 %60 to i1
  br i1 %tobool46, label %land.lhs.true47, label %if.end50

land.lhs.true47:                                  ; preds = %if.end38
  %call48 = call noundef zeroext i1 @_ZN5ImGui20IsMouseDoubleClickedEi(i32 noundef 0)
  br i1 %call48, label %if.then49, label %if.end50

if.then49:                                        ; preds = %land.lhs.true47
  %61 = load ptr, ptr %table.addr, align 8
  %62 = load i32, ptr %column_n, align 4
  call void @_ZN5ImGui29TableSetColumnWidthAutoSingleEP10ImGuiTablei(ptr noundef %61, i32 noundef %62)
  call void @_ZN5ImGui13ClearActiveIDEv()
  store i8 0, ptr %held, align 1
  br label %if.end50

if.end50:                                         ; preds = %if.then49, %land.lhs.true47, %if.end38
  %63 = load i8, ptr %held, align 1
  %tobool51 = trunc i8 %63 to i1
  br i1 %tobool51, label %if.then52, label %if.end71

if.then52:                                        ; preds = %if.end50
  %64 = load ptr, ptr %table.addr, align 8
  %LastResizedColumn53 = getelementptr inbounds %struct.ImGuiTable, ptr %64, i32 0, i32 75
  %65 = load i16, ptr %LastResizedColumn53, align 4
  %conv54 = sext i16 %65 to i32
  %cmp55 = icmp eq i32 %conv54, -1
  br i1 %cmp55, label %if.then56, label %if.end68

if.then56:                                        ; preds = %if.then52
  %66 = load ptr, ptr %table.addr, align 8
  %RightMostEnabledColumn = getelementptr inbounds %struct.ImGuiTable, ptr %66, i32 0, i32 80
  %67 = load i16, ptr %RightMostEnabledColumn, align 2
  %conv57 = sext i16 %67 to i32
  %cmp58 = icmp ne i32 %conv57, -1
  br i1 %cmp58, label %cond.true59, label %cond.false65

cond.true59:                                      ; preds = %if.then56
  %68 = load ptr, ptr %table.addr, align 8
  %Columns60 = getelementptr inbounds %struct.ImGuiTable, ptr %68, i32 0, i32 4
  %69 = load ptr, ptr %table.addr, align 8
  %RightMostEnabledColumn61 = getelementptr inbounds %struct.ImGuiTable, ptr %69, i32 0, i32 80
  %70 = load i16, ptr %RightMostEnabledColumn61, align 2
  %conv62 = sext i16 %70 to i32
  %call63 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns60, i32 noundef %conv62)
  %MaxX64 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %call63, i32 0, i32 3
  %71 = load float, ptr %MaxX64, align 4
  br label %cond.end66

cond.false65:                                     ; preds = %if.then56
  br label %cond.end66

cond.end66:                                       ; preds = %cond.false65, %cond.true59
  %cond67 = phi float [ %71, %cond.true59 ], [ 0xC7EFFFFFE0000000, %cond.false65 ]
  %72 = load ptr, ptr %table.addr, align 8
  %ResizeLockMinContentsX2 = getelementptr inbounds %struct.ImGuiTable, ptr %72, i32 0, i32 42
  store float %cond67, ptr %ResizeLockMinContentsX2, align 8
  br label %if.end68

if.end68:                                         ; preds = %cond.end66, %if.then52
  %73 = load i32, ptr %column_n, align 4
  %conv69 = trunc i32 %73 to i16
  %74 = load ptr, ptr %table.addr, align 8
  %ResizedColumn = getelementptr inbounds %struct.ImGuiTable, ptr %74, i32 0, i32 74
  store i16 %conv69, ptr %ResizedColumn, align 2
  %75 = load ptr, ptr %table.addr, align 8
  %InstanceCurrent70 = getelementptr inbounds %struct.ImGuiTable, ptr %75, i32 0, i32 16
  %76 = load i16, ptr %InstanceCurrent70, align 8
  %77 = load ptr, ptr %table.addr, align 8
  %InstanceInteracted = getelementptr inbounds %struct.ImGuiTable, ptr %77, i32 0, i32 17
  store i16 %76, ptr %InstanceInteracted, align 2
  br label %if.end71

if.end71:                                         ; preds = %if.end68, %if.end50
  %78 = load i8, ptr %hovered, align 1
  %tobool72 = trunc i8 %78 to i1
  br i1 %tobool72, label %land.lhs.true73, label %lor.lhs.false

land.lhs.true73:                                  ; preds = %if.end71
  %79 = load ptr, ptr %g, align 8
  %HoveredIdTimer = getelementptr inbounds %struct.ImGuiContext, ptr %79, i32 0, i32 45
  %80 = load float, ptr %HoveredIdTimer, align 4
  %cmp74 = fcmp ogt float %80, 0x3FAEB851E0000000
  br i1 %cmp74, label %if.then76, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true73, %if.end71
  %81 = load i8, ptr %held, align 1
  %tobool75 = trunc i8 %81 to i1
  br i1 %tobool75, label %if.then76, label %if.end78

if.then76:                                        ; preds = %lor.lhs.false, %land.lhs.true73
  %82 = load i32, ptr %column_n, align 4
  %conv77 = trunc i32 %82 to i16
  %83 = load ptr, ptr %table.addr, align 8
  %HoveredColumnBorder = getelementptr inbounds %struct.ImGuiTable, ptr %83, i32 0, i32 71
  store i16 %conv77, ptr %HoveredColumnBorder, align 4
  call void @_ZN5ImGui14SetMouseCursorEi(i32 noundef 4)
  br label %if.end78

if.end78:                                         ; preds = %if.then76, %lor.lhs.false
  br label %for.inc

for.inc:                                          ; preds = %if.end78, %if.then37, %if.then31, %if.then16, %if.then
  %84 = load i32, ptr %order_n, align 4
  %inc = add nsw i32 %84, 1
  store i32 %inc, ptr %order_n, align 4
  br label %for.cond, !llvm.loop !22

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress uwtable
define noundef zeroext i1 @_ZN5ImGui26TableBeginContextMenuPopupEP10ImGuiTable(ptr noundef %table) #0 {
entry:
  %retval = alloca i1, align 1
  %table.addr = alloca ptr, align 8
  %context_menu_id = alloca i32, align 4
  store ptr %table, ptr %table.addr, align 8
  %0 = load ptr, ptr %table.addr, align 8
  %IsContextPopupOpen = getelementptr inbounds %struct.ImGuiTable, ptr %0, i32 0, i32 97
  %1 = load i8, ptr %IsContextPopupOpen, align 1
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %2 = load ptr, ptr %table.addr, align 8
  %InstanceCurrent = getelementptr inbounds %struct.ImGuiTable, ptr %2, i32 0, i32 16
  %3 = load i16, ptr %InstanceCurrent, align 8
  %conv = sext i16 %3 to i32
  %4 = load ptr, ptr %table.addr, align 8
  %InstanceInteracted = getelementptr inbounds %struct.ImGuiTable, ptr %4, i32 0, i32 17
  %5 = load i16, ptr %InstanceInteracted, align 2
  %conv1 = sext i16 %5 to i32
  %cmp = icmp ne i32 %conv, %conv1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %6 = load ptr, ptr %table.addr, align 8
  %ID = getelementptr inbounds %struct.ImGuiTable, ptr %6, i32 0, i32 0
  %7 = load i32, ptr %ID, align 8
  %call = call noundef i32 @_Z9ImHashStrPKcmj(ptr noundef @.str.6, i64 noundef 0, i32 noundef %7)
  store i32 %call, ptr %context_menu_id, align 4
  %8 = load i32, ptr %context_menu_id, align 4
  %call2 = call noundef zeroext i1 @_ZN5ImGui12BeginPopupExEji(i32 noundef %8, i32 noundef 321)
  br i1 %call2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store i1 true, ptr %retval, align 1
  br label %return

if.end4:                                          ; preds = %if.end
  %9 = load ptr, ptr %table.addr, align 8
  %IsContextPopupOpen5 = getelementptr inbounds %struct.ImGuiTable, ptr %9, i32 0, i32 97
  store i8 0, ptr %IsContextPopupOpen5, align 1
  store i1 false, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end4, %if.then3, %if.then
  %10 = load i1, ptr %retval, align 1
  ret i1 %10
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui27TableDrawDefaultContextMenuEP10ImGuiTablei(ptr noundef %table, i32 noundef %flags_for_section_to_display) #0 {
entry:
  %table.addr = alloca ptr, align 8
  %flags_for_section_to_display.addr = alloca i32, align 4
  %g = alloca ptr, align 8
  %window = alloca ptr, align 8
  %want_separator = alloca i8, align 1
  %column_n = alloca i32, align 4
  %column = alloca ptr, align 8
  %can_resize = alloca i8, align 1
  %size_all_desc = alloca ptr, align 8
  %other_column_n = alloca i32, align 4
  %other_column = alloca ptr, align 8
  %name = alloca ptr, align 8
  %menu_item_active = alloca i8, align 1
  store ptr %table, ptr %table.addr, align 8
  store i32 %flags_for_section_to_display, ptr %flags_for_section_to_display.addr, align 4
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %g, align 8
  %CurrentWindow = getelementptr inbounds %struct.ImGuiContext, ptr %1, i32 0, i32 29
  %2 = load ptr, ptr %CurrentWindow, align 8
  store ptr %2, ptr %window, align 8
  %3 = load ptr, ptr %window, align 8
  %SkipItems = getelementptr inbounds %struct.ImGuiWindow, ptr %3, i32 0, i32 38
  %4 = load i8, ptr %SkipItems, align 1
  %tobool = trunc i8 %4 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end91

if.end:                                           ; preds = %entry
  store i8 0, ptr %want_separator, align 1
  %5 = load ptr, ptr %table.addr, align 8
  %ContextPopupColumn = getelementptr inbounds %struct.ImGuiTable, ptr %5, i32 0, i32 83
  %6 = load i16, ptr %ContextPopupColumn, align 4
  %conv = sext i16 %6 to i32
  %cmp = icmp sge i32 %conv, 0
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %if.end
  %7 = load ptr, ptr %table.addr, align 8
  %ContextPopupColumn1 = getelementptr inbounds %struct.ImGuiTable, ptr %7, i32 0, i32 83
  %8 = load i16, ptr %ContextPopupColumn1, align 4
  %conv2 = sext i16 %8 to i32
  %9 = load ptr, ptr %table.addr, align 8
  %ColumnsCount = getelementptr inbounds %struct.ImGuiTable, ptr %9, i32 0, i32 13
  %10 = load i32, ptr %ColumnsCount, align 4
  %cmp3 = icmp slt i32 %conv2, %10
  br i1 %cmp3, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  %11 = load ptr, ptr %table.addr, align 8
  %ContextPopupColumn4 = getelementptr inbounds %struct.ImGuiTable, ptr %11, i32 0, i32 83
  %12 = load i16, ptr %ContextPopupColumn4, align 4
  %conv5 = sext i16 %12 to i32
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %if.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv5, %cond.true ], [ -1, %cond.false ]
  store i32 %cond, ptr %column_n, align 4
  %13 = load i32, ptr %column_n, align 4
  %cmp6 = icmp ne i32 %13, -1
  br i1 %cmp6, label %cond.true7, label %cond.false8

cond.true7:                                       ; preds = %cond.end
  %14 = load ptr, ptr %table.addr, align 8
  %Columns = getelementptr inbounds %struct.ImGuiTable, ptr %14, i32 0, i32 4
  %15 = load i32, ptr %column_n, align 4
  %call = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns, i32 noundef %15)
  br label %cond.end9

cond.false8:                                      ; preds = %cond.end
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false8, %cond.true7
  %cond10 = phi ptr [ %call, %cond.true7 ], [ null, %cond.false8 ]
  store ptr %cond10, ptr %column, align 8
  %16 = load i32, ptr %flags_for_section_to_display.addr, align 4
  %and = and i32 %16, 1
  %tobool11 = icmp ne i32 %and, 0
  br i1 %tobool11, label %if.then12, label %if.end38

if.then12:                                        ; preds = %cond.end9
  %17 = load ptr, ptr %column, align 8
  %cmp13 = icmp ne ptr %17, null
  br i1 %cmp13, label %if.then14, label %if.end23

if.then14:                                        ; preds = %if.then12
  %18 = load ptr, ptr %column, align 8
  %Flags = getelementptr inbounds %struct.ImGuiTableColumn, ptr %18, i32 0, i32 0
  %19 = load i32, ptr %Flags, align 4
  %and15 = and i32 %19, 32
  %tobool16 = icmp ne i32 %and15, 0
  br i1 %tobool16, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %if.then14
  %20 = load ptr, ptr %column, align 8
  %IsEnabled = getelementptr inbounds %struct.ImGuiTableColumn, ptr %20, i32 0, i32 26
  %21 = load i8, ptr %IsEnabled, align 2
  %tobool17 = trunc i8 %21 to i1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then14
  %22 = phi i1 [ false, %if.then14 ], [ %tobool17, %land.rhs ]
  %frombool = zext i1 %22 to i8
  store i8 %frombool, ptr %can_resize, align 1
  %call18 = call noundef ptr @_ZN5ImGui14LocalizeGetMsgE11ImGuiLocKey(i32 noundef 1)
  %23 = load i8, ptr %can_resize, align 1
  %tobool19 = trunc i8 %23 to i1
  %call20 = call noundef zeroext i1 @_ZN5ImGui8MenuItemEPKcS1_bb(ptr noundef %call18, ptr noundef null, i1 noundef zeroext false, i1 noundef zeroext %tobool19)
  br i1 %call20, label %if.then21, label %if.end22

if.then21:                                        ; preds = %land.end
  %24 = load ptr, ptr %table.addr, align 8
  %25 = load i32, ptr %column_n, align 4
  call void @_ZN5ImGui29TableSetColumnWidthAutoSingleEP10ImGuiTablei(ptr noundef %24, i32 noundef %25)
  br label %if.end22

if.end22:                                         ; preds = %if.then21, %land.end
  br label %if.end23

if.end23:                                         ; preds = %if.end22, %if.then12
  %26 = load ptr, ptr %table.addr, align 8
  %ColumnsEnabledFixedCount = getelementptr inbounds %struct.ImGuiTable, ptr %26, i32 0, i32 67
  %27 = load i16, ptr %ColumnsEnabledFixedCount, align 4
  %conv24 = sext i16 %27 to i32
  %28 = load ptr, ptr %table.addr, align 8
  %ColumnsEnabledCount = getelementptr inbounds %struct.ImGuiTable, ptr %28, i32 0, i32 66
  %29 = load i16, ptr %ColumnsEnabledCount, align 2
  %conv25 = sext i16 %29 to i32
  %cmp26 = icmp eq i32 %conv24, %conv25
  br i1 %cmp26, label %land.lhs.true27, label %if.else

land.lhs.true27:                                  ; preds = %if.end23
  %30 = load ptr, ptr %table.addr, align 8
  %Flags28 = getelementptr inbounds %struct.ImGuiTable, ptr %30, i32 0, i32 1
  %31 = load i32, ptr %Flags28, align 4
  %and29 = and i32 %31, 57344
  %cmp30 = icmp ne i32 %and29, 16384
  br i1 %cmp30, label %if.then31, label %if.else

if.then31:                                        ; preds = %land.lhs.true27
  %call32 = call noundef ptr @_ZN5ImGui14LocalizeGetMsgE11ImGuiLocKey(i32 noundef 2)
  store ptr %call32, ptr %size_all_desc, align 8
  br label %if.end34

if.else:                                          ; preds = %land.lhs.true27, %if.end23
  %call33 = call noundef ptr @_ZN5ImGui14LocalizeGetMsgE11ImGuiLocKey(i32 noundef 3)
  store ptr %call33, ptr %size_all_desc, align 8
  br label %if.end34

if.end34:                                         ; preds = %if.else, %if.then31
  %32 = load ptr, ptr %size_all_desc, align 8
  %call35 = call noundef zeroext i1 @_ZN5ImGui8MenuItemEPKcS1_bb(ptr noundef %32, ptr noundef null, i1 noundef zeroext false, i1 noundef zeroext true)
  br i1 %call35, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.end34
  %33 = load ptr, ptr %table.addr, align 8
  call void @_ZN5ImGui26TableSetColumnWidthAutoAllEP10ImGuiTable(ptr noundef %33)
  br label %if.end37

if.end37:                                         ; preds = %if.then36, %if.end34
  store i8 1, ptr %want_separator, align 1
  br label %if.end38

if.end38:                                         ; preds = %if.end37, %cond.end9
  %34 = load i32, ptr %flags_for_section_to_display.addr, align 4
  %and39 = and i32 %34, 2
  %tobool40 = icmp ne i32 %and39, 0
  br i1 %tobool40, label %if.then41, label %if.end47

if.then41:                                        ; preds = %if.end38
  %call42 = call noundef ptr @_ZN5ImGui14LocalizeGetMsgE11ImGuiLocKey(i32 noundef 4)
  %35 = load ptr, ptr %table.addr, align 8
  %IsDefaultDisplayOrder = getelementptr inbounds %struct.ImGuiTable, ptr %35, i32 0, i32 101
  %36 = load i8, ptr %IsDefaultDisplayOrder, align 1
  %tobool43 = trunc i8 %36 to i1
  %lnot = xor i1 %tobool43, true
  %call44 = call noundef zeroext i1 @_ZN5ImGui8MenuItemEPKcS1_bb(ptr noundef %call42, ptr noundef null, i1 noundef zeroext false, i1 noundef zeroext %lnot)
  br i1 %call44, label %if.then45, label %if.end46

if.then45:                                        ; preds = %if.then41
  %37 = load ptr, ptr %table.addr, align 8
  %IsResetDisplayOrderRequest = getelementptr inbounds %struct.ImGuiTable, ptr %37, i32 0, i32 103
  store i8 1, ptr %IsResetDisplayOrderRequest, align 1
  br label %if.end46

if.end46:                                         ; preds = %if.then45, %if.then41
  store i8 1, ptr %want_separator, align 1
  br label %if.end47

if.end47:                                         ; preds = %if.end46, %if.end38
  %38 = load i32, ptr %flags_for_section_to_display.addr, align 4
  %and48 = and i32 %38, 4
  %tobool49 = icmp ne i32 %and48, 0
  br i1 %tobool49, label %if.then50, label %if.end91

if.then50:                                        ; preds = %if.end47
  %39 = load i8, ptr %want_separator, align 1
  %tobool51 = trunc i8 %39 to i1
  br i1 %tobool51, label %if.then52, label %if.end53

if.then52:                                        ; preds = %if.then50
  call void @_ZN5ImGui9SeparatorEv()
  br label %if.end53

if.end53:                                         ; preds = %if.then52, %if.then50
  store i8 1, ptr %want_separator, align 1
  call void @_ZN5ImGui12PushItemFlagEib(i32 noundef 32, i1 noundef zeroext true)
  store i32 0, ptr %other_column_n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end53
  %40 = load i32, ptr %other_column_n, align 4
  %41 = load ptr, ptr %table.addr, align 8
  %ColumnsCount54 = getelementptr inbounds %struct.ImGuiTable, ptr %41, i32 0, i32 13
  %42 = load i32, ptr %ColumnsCount54, align 4
  %cmp55 = icmp slt i32 %40, %42
  br i1 %cmp55, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %43 = load ptr, ptr %table.addr, align 8
  %Columns56 = getelementptr inbounds %struct.ImGuiTable, ptr %43, i32 0, i32 4
  %44 = load i32, ptr %other_column_n, align 4
  %call57 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns56, i32 noundef %44)
  store ptr %call57, ptr %other_column, align 8
  %45 = load ptr, ptr %other_column, align 8
  %Flags58 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %45, i32 0, i32 0
  %46 = load i32, ptr %Flags58, align 4
  %and59 = and i32 %46, 1
  %tobool60 = icmp ne i32 %and59, 0
  br i1 %tobool60, label %if.then61, label %if.end62

if.then61:                                        ; preds = %for.body
  br label %for.inc

if.end62:                                         ; preds = %for.body
  %47 = load ptr, ptr %table.addr, align 8
  %48 = load i32, ptr %other_column_n, align 4
  %call63 = call noundef ptr @_ZN5ImGui18TableGetColumnNameEPK10ImGuiTablei(ptr noundef %47, i32 noundef %48)
  store ptr %call63, ptr %name, align 8
  %49 = load ptr, ptr %name, align 8
  %cmp64 = icmp eq ptr %49, null
  br i1 %cmp64, label %if.then67, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end62
  %50 = load ptr, ptr %name, align 8
  %arrayidx = getelementptr inbounds i8, ptr %50, i64 0
  %51 = load i8, ptr %arrayidx, align 1
  %conv65 = sext i8 %51 to i32
  %cmp66 = icmp eq i32 %conv65, 0
  br i1 %cmp66, label %if.then67, label %if.end68

if.then67:                                        ; preds = %lor.lhs.false, %if.end62
  store ptr @.str.7, ptr %name, align 8
  br label %if.end68

if.end68:                                         ; preds = %if.then67, %lor.lhs.false
  %52 = load ptr, ptr %other_column, align 8
  %Flags69 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %52, i32 0, i32 0
  %53 = load i32, ptr %Flags69, align 4
  %and70 = and i32 %53, 128
  %tobool71 = icmp ne i32 %and70, 0
  %cond72 = select i1 %tobool71, i1 false, i1 true
  %frombool73 = zext i1 %cond72 to i8
  store i8 %frombool73, ptr %menu_item_active, align 1
  %54 = load ptr, ptr %other_column, align 8
  %IsUserEnabled = getelementptr inbounds %struct.ImGuiTableColumn, ptr %54, i32 0, i32 27
  %55 = load i8, ptr %IsUserEnabled, align 1
  %tobool74 = trunc i8 %55 to i1
  br i1 %tobool74, label %land.lhs.true75, label %if.end80

land.lhs.true75:                                  ; preds = %if.end68
  %56 = load ptr, ptr %table.addr, align 8
  %ColumnsEnabledCount76 = getelementptr inbounds %struct.ImGuiTable, ptr %56, i32 0, i32 66
  %57 = load i16, ptr %ColumnsEnabledCount76, align 2
  %conv77 = sext i16 %57 to i32
  %cmp78 = icmp sle i32 %conv77, 1
  br i1 %cmp78, label %if.then79, label %if.end80

if.then79:                                        ; preds = %land.lhs.true75
  store i8 0, ptr %menu_item_active, align 1
  br label %if.end80

if.end80:                                         ; preds = %if.then79, %land.lhs.true75, %if.end68
  %58 = load ptr, ptr %name, align 8
  %59 = load ptr, ptr %other_column, align 8
  %IsUserEnabled81 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %59, i32 0, i32 27
  %60 = load i8, ptr %IsUserEnabled81, align 1
  %tobool82 = trunc i8 %60 to i1
  %61 = load i8, ptr %menu_item_active, align 1
  %tobool83 = trunc i8 %61 to i1
  %call84 = call noundef zeroext i1 @_ZN5ImGui8MenuItemEPKcS1_bb(ptr noundef %58, ptr noundef null, i1 noundef zeroext %tobool82, i1 noundef zeroext %tobool83)
  br i1 %call84, label %if.then85, label %if.end90

if.then85:                                        ; preds = %if.end80
  %62 = load ptr, ptr %other_column, align 8
  %IsUserEnabled86 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %62, i32 0, i32 27
  %63 = load i8, ptr %IsUserEnabled86, align 1
  %tobool87 = trunc i8 %63 to i1
  %lnot88 = xor i1 %tobool87, true
  %64 = load ptr, ptr %other_column, align 8
  %IsUserEnabledNextFrame = getelementptr inbounds %struct.ImGuiTableColumn, ptr %64, i32 0, i32 28
  %frombool89 = zext i1 %lnot88 to i8
  store i8 %frombool89, ptr %IsUserEnabledNextFrame, align 4
  br label %if.end90

if.end90:                                         ; preds = %if.then85, %if.end80
  br label %for.inc

for.inc:                                          ; preds = %if.end90, %if.then61
  %65 = load i32, ptr %other_column_n, align 4
  %inc = add nsw i32 %65, 1
  store i32 %inc, ptr %other_column_n, align 4
  br label %for.cond, !llvm.loop !23

for.end:                                          ; preds = %for.cond
  call void @_ZN5ImGui11PopItemFlagEv()
  br label %if.end91

if.end91:                                         ; preds = %for.end, %if.end47, %if.then
  ret void
}

declare void @_ZN5ImGui8EndPopupEv() #1

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui19TableSortSpecsBuildEP10ImGuiTable(ptr noundef %table) #0 {
entry:
  %table.addr = alloca ptr, align 8
  %dirty = alloca i8, align 1
  %sort_specs = alloca ptr, align 8
  %column_n = alloca i32, align 4
  %column = alloca ptr, align 8
  %sort_spec = alloca ptr, align 8
  store ptr %table, ptr %table.addr, align 8
  %0 = load ptr, ptr %table.addr, align 8
  %IsSortSpecsDirty = getelementptr inbounds %struct.ImGuiTable, ptr %0, i32 0, i32 95
  %1 = load i8, ptr %IsSortSpecsDirty, align 1
  %tobool = trunc i8 %1 to i1
  %frombool = zext i1 %tobool to i8
  store i8 %frombool, ptr %dirty, align 1
  %2 = load i8, ptr %dirty, align 1
  %tobool1 = trunc i8 %2 to i1
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %table.addr, align 8
  call void @_ZN5ImGui22TableSortSpecsSanitizeEP10ImGuiTable(ptr noundef %3)
  %4 = load ptr, ptr %table.addr, align 8
  %SortSpecsMulti = getelementptr inbounds %struct.ImGuiTable, ptr %4, i32 0, i32 63
  %5 = load ptr, ptr %table.addr, align 8
  %SortSpecsCount = getelementptr inbounds %struct.ImGuiTable, ptr %5, i32 0, i32 65
  %6 = load i16, ptr %SortSpecsCount, align 8
  %conv = sext i16 %6 to i32
  %cmp = icmp sle i32 %conv, 1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  br label %cond.end

cond.false:                                       ; preds = %if.then
  %7 = load ptr, ptr %table.addr, align 8
  %SortSpecsCount2 = getelementptr inbounds %struct.ImGuiTable, ptr %7, i32 0, i32 65
  %8 = load i16, ptr %SortSpecsCount2, align 8
  %conv3 = sext i16 %8 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 0, %cond.true ], [ %conv3, %cond.false ]
  call void @_ZN8ImVectorI25ImGuiTableColumnSortSpecsE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %SortSpecsMulti, i32 noundef %cond)
  %9 = load ptr, ptr %table.addr, align 8
  %SortSpecs = getelementptr inbounds %struct.ImGuiTable, ptr %9, i32 0, i32 64
  %SpecsDirty = getelementptr inbounds %struct.ImGuiTableSortSpecs, ptr %SortSpecs, i32 0, i32 2
  store i8 1, ptr %SpecsDirty, align 4
  %10 = load ptr, ptr %table.addr, align 8
  %IsSortSpecsDirty4 = getelementptr inbounds %struct.ImGuiTable, ptr %10, i32 0, i32 95
  store i8 0, ptr %IsSortSpecsDirty4, align 1
  br label %if.end

if.end:                                           ; preds = %cond.end, %entry
  %11 = load ptr, ptr %table.addr, align 8
  %SortSpecsCount5 = getelementptr inbounds %struct.ImGuiTable, ptr %11, i32 0, i32 65
  %12 = load i16, ptr %SortSpecsCount5, align 8
  %conv6 = sext i16 %12 to i32
  %cmp7 = icmp eq i32 %conv6, 0
  br i1 %cmp7, label %cond.true8, label %cond.false9

cond.true8:                                       ; preds = %if.end
  br label %cond.end18

cond.false9:                                      ; preds = %if.end
  %13 = load ptr, ptr %table.addr, align 8
  %SortSpecsCount10 = getelementptr inbounds %struct.ImGuiTable, ptr %13, i32 0, i32 65
  %14 = load i16, ptr %SortSpecsCount10, align 8
  %conv11 = sext i16 %14 to i32
  %cmp12 = icmp eq i32 %conv11, 1
  br i1 %cmp12, label %cond.true13, label %cond.false14

cond.true13:                                      ; preds = %cond.false9
  %15 = load ptr, ptr %table.addr, align 8
  %SortSpecsSingle = getelementptr inbounds %struct.ImGuiTable, ptr %15, i32 0, i32 61
  br label %cond.end16

cond.false14:                                     ; preds = %cond.false9
  %16 = load ptr, ptr %table.addr, align 8
  %SortSpecsMulti15 = getelementptr inbounds %struct.ImGuiTable, ptr %16, i32 0, i32 63
  %Data = getelementptr inbounds %struct.ImVector.39, ptr %SortSpecsMulti15, i32 0, i32 2
  %17 = load ptr, ptr %Data, align 8
  br label %cond.end16

cond.end16:                                       ; preds = %cond.false14, %cond.true13
  %cond17 = phi ptr [ %SortSpecsSingle, %cond.true13 ], [ %17, %cond.false14 ]
  br label %cond.end18

cond.end18:                                       ; preds = %cond.end16, %cond.true8
  %cond19 = phi ptr [ null, %cond.true8 ], [ %cond17, %cond.end16 ]
  store ptr %cond19, ptr %sort_specs, align 8
  %18 = load i8, ptr %dirty, align 1
  %tobool20 = trunc i8 %18 to i1
  br i1 %tobool20, label %land.lhs.true, label %if.end34

land.lhs.true:                                    ; preds = %cond.end18
  %19 = load ptr, ptr %sort_specs, align 8
  %cmp21 = icmp ne ptr %19, null
  br i1 %cmp21, label %if.then22, label %if.end34

if.then22:                                        ; preds = %land.lhs.true
  store i32 0, ptr %column_n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then22
  %20 = load i32, ptr %column_n, align 4
  %21 = load ptr, ptr %table.addr, align 8
  %ColumnsCount = getelementptr inbounds %struct.ImGuiTable, ptr %21, i32 0, i32 13
  %22 = load i32, ptr %ColumnsCount, align 4
  %cmp23 = icmp slt i32 %20, %22
  br i1 %cmp23, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %23 = load ptr, ptr %table.addr, align 8
  %Columns = getelementptr inbounds %struct.ImGuiTable, ptr %23, i32 0, i32 4
  %24 = load i32, ptr %column_n, align 4
  %call = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns, i32 noundef %24)
  store ptr %call, ptr %column, align 8
  %25 = load ptr, ptr %column, align 8
  %SortOrder = getelementptr inbounds %struct.ImGuiTableColumn, ptr %25, i32 0, i32 22
  %26 = load i16, ptr %SortOrder, align 2
  %conv24 = sext i16 %26 to i32
  %cmp25 = icmp eq i32 %conv24, -1
  br i1 %cmp25, label %if.then26, label %if.end27

if.then26:                                        ; preds = %for.body
  br label %for.inc

if.end27:                                         ; preds = %for.body
  %27 = load ptr, ptr %sort_specs, align 8
  %28 = load ptr, ptr %column, align 8
  %SortOrder28 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %28, i32 0, i32 22
  %29 = load i16, ptr %SortOrder28, align 2
  %idxprom = sext i16 %29 to i64
  %arrayidx = getelementptr inbounds %struct.ImGuiTableColumnSortSpecs, ptr %27, i64 %idxprom
  store ptr %arrayidx, ptr %sort_spec, align 8
  %30 = load ptr, ptr %column, align 8
  %UserID = getelementptr inbounds %struct.ImGuiTableColumn, ptr %30, i32 0, i32 9
  %31 = load i32, ptr %UserID, align 4
  %32 = load ptr, ptr %sort_spec, align 8
  %ColumnUserID = getelementptr inbounds %struct.ImGuiTableColumnSortSpecs, ptr %32, i32 0, i32 0
  store i32 %31, ptr %ColumnUserID, align 4
  %33 = load i32, ptr %column_n, align 4
  %conv29 = trunc i32 %33 to i16
  %34 = load ptr, ptr %sort_spec, align 8
  %ColumnIndex = getelementptr inbounds %struct.ImGuiTableColumnSortSpecs, ptr %34, i32 0, i32 1
  store i16 %conv29, ptr %ColumnIndex, align 4
  %35 = load ptr, ptr %column, align 8
  %SortOrder30 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %35, i32 0, i32 22
  %36 = load i16, ptr %SortOrder30, align 2
  %37 = load ptr, ptr %sort_spec, align 8
  %SortOrder31 = getelementptr inbounds %struct.ImGuiTableColumnSortSpecs, ptr %37, i32 0, i32 2
  store i16 %36, ptr %SortOrder31, align 2
  %38 = load ptr, ptr %column, align 8
  %SortDirection = getelementptr inbounds %struct.ImGuiTableColumn, ptr %38, i32 0, i32 37
  %bf.load = load i8, ptr %SortDirection, align 1
  %bf.clear = and i8 %bf.load, 3
  %conv32 = zext i8 %bf.clear to i32
  %39 = load ptr, ptr %sort_spec, align 8
  %SortDirection33 = getelementptr inbounds %struct.ImGuiTableColumnSortSpecs, ptr %39, i32 0, i32 3
  %40 = trunc i32 %conv32 to i8
  store i8 %40, ptr %SortDirection33, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end27, %if.then26
  %41 = load i32, ptr %column_n, align 4
  %inc = add nsw i32 %41, 1
  store i32 %inc, ptr %column_n, align 4
  br label %for.cond, !llvm.loop !24

for.end:                                          ; preds = %for.cond
  br label %if.end34

if.end34:                                         ; preds = %for.end, %land.lhs.true, %cond.end18
  %42 = load ptr, ptr %sort_specs, align 8
  %43 = load ptr, ptr %table.addr, align 8
  %SortSpecs35 = getelementptr inbounds %struct.ImGuiTable, ptr %43, i32 0, i32 64
  %Specs = getelementptr inbounds %struct.ImGuiTableSortSpecs, ptr %SortSpecs35, i32 0, i32 0
  store ptr %42, ptr %Specs, align 8
  %44 = load ptr, ptr %table.addr, align 8
  %SortSpecsCount36 = getelementptr inbounds %struct.ImGuiTable, ptr %44, i32 0, i32 65
  %45 = load i16, ptr %SortSpecsCount36, align 8
  %conv37 = sext i16 %45 to i32
  %46 = load ptr, ptr %table.addr, align 8
  %SortSpecs38 = getelementptr inbounds %struct.ImGuiTable, ptr %46, i32 0, i32 64
  %SpecsCount = getelementptr inbounds %struct.ImGuiTableSortSpecs, ptr %SortSpecs38, i32 0, i32 1
  store i32 %conv37, ptr %SpecsCount, align 8
  ret void
}

declare void @_ZN18ImDrawListSplitter17SetCurrentChannelEP10ImDrawListi(ptr noundef nonnull align 8 dereferenceable(24), ptr noundef, i32 noundef) #1

declare void @_ZN10ImDrawList12PushClipRectERK6ImVec2S2_b(ptr noundef nonnull align 8 dereferenceable(196), ptr noundef nonnull align 4 dereferenceable(8), ptr noundef nonnull align 4 dereferenceable(8), i1 noundef zeroext) #1

; Function Attrs: mustprogress uwtable
define noundef i32 @_ZN5ImGui22TableGetColumnResizeIDEP10ImGuiTableii(ptr noundef %table, i32 noundef %column_n, i32 noundef %instance_no) #0 {
entry:
  %table.addr = alloca ptr, align 8
  %column_n.addr = alloca i32, align 4
  %instance_no.addr = alloca i32, align 4
  %instance_id = alloca i32, align 4
  store ptr %table, ptr %table.addr, align 8
  store i32 %column_n, ptr %column_n.addr, align 4
  store i32 %instance_no, ptr %instance_no.addr, align 4
  %0 = load ptr, ptr %table.addr, align 8
  %1 = load i32, ptr %instance_no.addr, align 4
  %call = call noundef i32 @_ZN5ImGui18TableGetInstanceIDEP10ImGuiTablei(ptr noundef %0, i32 noundef %1)
  store i32 %call, ptr %instance_id, align 4
  %2 = load i32, ptr %instance_id, align 4
  %add = add i32 %2, 1
  %3 = load i32, ptr %column_n.addr, align 4
  %add1 = add i32 %add, %3
  ret i32 %add1
}

declare noundef zeroext i1 @_ZN5ImGui7ItemAddERK6ImRectjPS1_i(ptr noundef nonnull align 4 dereferenceable(16), i32 noundef, ptr noundef, i32 noundef) #1

declare noundef zeroext i1 @_ZN5ImGui14ButtonBehaviorERK6ImRectjPbS3_i(ptr noundef nonnull align 4 dereferenceable(16), i32 noundef, ptr noundef, ptr noundef, i32 noundef) #1

declare noundef zeroext i1 @_ZN5ImGui20IsMouseDoubleClickedEi(i32 noundef) #1

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui29TableSetColumnWidthAutoSingleEP10ImGuiTablei(ptr noundef %table, i32 noundef %column_n) #0 {
entry:
  %table.addr = alloca ptr, align 8
  %column_n.addr = alloca i32, align 4
  %column = alloca ptr, align 8
  store ptr %table, ptr %table.addr, align 8
  store i32 %column_n, ptr %column_n.addr, align 4
  %0 = load ptr, ptr %table.addr, align 8
  %Columns = getelementptr inbounds %struct.ImGuiTable, ptr %0, i32 0, i32 4
  %1 = load i32, ptr %column_n.addr, align 4
  %call = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns, i32 noundef %1)
  store ptr %call, ptr %column, align 8
  %2 = load ptr, ptr %column, align 8
  %IsEnabled = getelementptr inbounds %struct.ImGuiTableColumn, ptr %2, i32 0, i32 26
  %3 = load i8, ptr %IsEnabled, align 2
  %tobool = trunc i8 %3 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %column, align 8
  %CannotSkipItemsQueue = getelementptr inbounds %struct.ImGuiTableColumn, ptr %4, i32 0, i32 36
  store i8 1, ptr %CannotSkipItemsQueue, align 4
  %5 = load i32, ptr %column_n.addr, align 4
  %conv = trunc i32 %5 to i16
  %6 = load ptr, ptr %table.addr, align 8
  %AutoFitSingleColumn = getelementptr inbounds %struct.ImGuiTable, ptr %6, i32 0, i32 73
  store i16 %conv, ptr %AutoFitSingleColumn, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

declare void @_ZN5ImGui13ClearActiveIDEv() #1

declare void @_ZN5ImGui14SetMouseCursorEi(i32 noundef) #1

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui8EndTableEv() #2 {
entry:
  %g = alloca ptr, align 8
  %table = alloca ptr, align 8
  %flags = alloca i32, align 4
  %inner_window = alloca ptr, align 8
  %outer_window = alloca ptr, align 8
  %temp_data = alloca ptr, align 8
  %table_instance = alloca ptr, align 8
  %inner_content_max_y = alloca float, align 4
  %outer_padding_for_border = alloca float, align 4
  %max_pos_x = alloca float, align 4
  %ref.tmp = alloca %struct.ImRect, align 4
  %splitter = alloca ptr, align 8
  %auto_fit_width_for_fixed = alloca float, align 4
  %auto_fit_width_for_stretched = alloca float, align 4
  %auto_fit_width_for_stretched_min = alloca float, align 4
  %column_n = alloca i32, align 4
  %column = alloca ptr, align 8
  %column_width_request = alloca float, align 4
  %width_spacings = alloca float, align 4
  %neighbor_width_to_keep_visible = alloca float, align 4
  %column166 = alloca ptr, align 8
  %column204 = alloca ptr, align 8
  %new_x2 = alloca float, align 4
  %new_width = alloca float, align 4
  %backup_outer_max_pos = alloca %struct.ImVec2, align 4
  %ref.tmp243 = alloca %struct.ImVec2, align 4
  %decoration_size = alloca float, align 4
  %decoration_size322 = alloca float, align 4
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %g, align 8
  %CurrentTable = getelementptr inbounds %struct.ImGuiContext, ptr %1, i32 0, i32 164
  %2 = load ptr, ptr %CurrentTable, align 8
  store ptr %2, ptr %table, align 8
  %3 = load ptr, ptr %table, align 8
  %IsLayoutLocked = getelementptr inbounds %struct.ImGuiTable, ptr %3, i32 0, i32 92
  %4 = load i8, ptr %IsLayoutLocked, align 2
  %tobool = trunc i8 %4 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load ptr, ptr %table, align 8
  call void @_ZN5ImGui17TableUpdateLayoutEP10ImGuiTable(ptr noundef %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load ptr, ptr %table, align 8
  %Flags = getelementptr inbounds %struct.ImGuiTable, ptr %6, i32 0, i32 1
  %7 = load i32, ptr %Flags, align 4
  store i32 %7, ptr %flags, align 4
  %8 = load ptr, ptr %table, align 8
  %InnerWindow = getelementptr inbounds %struct.ImGuiTable, ptr %8, i32 0, i32 56
  %9 = load ptr, ptr %InnerWindow, align 8
  store ptr %9, ptr %inner_window, align 8
  %10 = load ptr, ptr %table, align 8
  %OuterWindow = getelementptr inbounds %struct.ImGuiTable, ptr %10, i32 0, i32 55
  %11 = load ptr, ptr %OuterWindow, align 8
  store ptr %11, ptr %outer_window, align 8
  %12 = load ptr, ptr %table, align 8
  %TempData = getelementptr inbounds %struct.ImGuiTable, ptr %12, i32 0, i32 3
  %13 = load ptr, ptr %TempData, align 8
  store ptr %13, ptr %temp_data, align 8
  %14 = load ptr, ptr %table, align 8
  %IsInsideRow = getelementptr inbounds %struct.ImGuiTable, ptr %14, i32 0, i32 93
  %15 = load i8, ptr %IsInsideRow, align 1
  %tobool1 = trunc i8 %15 to i1
  br i1 %tobool1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %16 = load ptr, ptr %table, align 8
  call void @_ZN5ImGui11TableEndRowEP10ImGuiTable(ptr noundef %16)
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end
  %17 = load i32, ptr %flags, align 4
  %and = and i32 %17, 32
  %tobool4 = icmp ne i32 %and, 0
  br i1 %tobool4, label %if.then5, label %if.end12

if.then5:                                         ; preds = %if.end3
  %18 = load ptr, ptr %table, align 8
  %HoveredColumnBody = getelementptr inbounds %struct.ImGuiTable, ptr %18, i32 0, i32 70
  %19 = load i16, ptr %HoveredColumnBody, align 2
  %conv = sext i16 %19 to i32
  %cmp = icmp ne i32 %conv, -1
  br i1 %cmp, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %if.then5
  %call = call noundef zeroext i1 @_ZN5ImGui16IsAnyItemHoveredEv()
  br i1 %call, label %if.end11, label %land.lhs.true6

land.lhs.true6:                                   ; preds = %land.lhs.true
  %call7 = call noundef zeroext i1 @_ZN5ImGui15IsMouseReleasedEi(i32 noundef 1)
  br i1 %call7, label %if.then8, label %if.end11

if.then8:                                         ; preds = %land.lhs.true6
  %20 = load ptr, ptr %table, align 8
  %HoveredColumnBody9 = getelementptr inbounds %struct.ImGuiTable, ptr %20, i32 0, i32 70
  %21 = load i16, ptr %HoveredColumnBody9, align 2
  %conv10 = sext i16 %21 to i32
  call void @_ZN5ImGui20TableOpenContextMenuEi(i32 noundef %conv10)
  br label %if.end11

if.end11:                                         ; preds = %if.then8, %land.lhs.true6, %land.lhs.true, %if.then5
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %if.end3
  %22 = load ptr, ptr %table, align 8
  %23 = load ptr, ptr %table, align 8
  %InstanceCurrent = getelementptr inbounds %struct.ImGuiTable, ptr %23, i32 0, i32 16
  %24 = load i16, ptr %InstanceCurrent, align 8
  %conv13 = sext i16 %24 to i32
  %call14 = call noundef ptr @_ZN5ImGui20TableGetInstanceDataEP10ImGuiTablei(ptr noundef %22, i32 noundef %conv13)
  store ptr %call14, ptr %table_instance, align 8
  %25 = load ptr, ptr %temp_data, align 8
  %HostBackupPrevLineSize = getelementptr inbounds %struct.ImGuiTableTempData, ptr %25, i32 0, i32 8
  %26 = load ptr, ptr %inner_window, align 8
  %DC = getelementptr inbounds %struct.ImGuiWindow, ptr %26, i32 0, i32 68
  %PrevLineSize = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC, i32 0, i32 6
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %PrevLineSize, ptr align 8 %HostBackupPrevLineSize, i64 8, i1 false)
  %27 = load ptr, ptr %temp_data, align 8
  %HostBackupCurrLineSize = getelementptr inbounds %struct.ImGuiTableTempData, ptr %27, i32 0, i32 9
  %28 = load ptr, ptr %inner_window, align 8
  %DC15 = getelementptr inbounds %struct.ImGuiWindow, ptr %28, i32 0, i32 68
  %CurrLineSize = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC15, i32 0, i32 5
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %CurrLineSize, ptr align 8 %HostBackupCurrLineSize, i64 8, i1 false)
  %29 = load ptr, ptr %temp_data, align 8
  %HostBackupCursorMaxPos = getelementptr inbounds %struct.ImGuiTableTempData, ptr %29, i32 0, i32 10
  %30 = load ptr, ptr %inner_window, align 8
  %DC16 = getelementptr inbounds %struct.ImGuiWindow, ptr %30, i32 0, i32 68
  %CursorMaxPos = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC16, i32 0, i32 3
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %CursorMaxPos, ptr align 8 %HostBackupCursorMaxPos, i64 8, i1 false)
  %31 = load ptr, ptr %table, align 8
  %RowPosY2 = getelementptr inbounds %struct.ImGuiTable, ptr %31, i32 0, i32 19
  %32 = load float, ptr %RowPosY2, align 8
  store float %32, ptr %inner_content_max_y, align 4
  %33 = load ptr, ptr %inner_window, align 8
  %34 = load ptr, ptr %outer_window, align 8
  %cmp17 = icmp ne ptr %33, %34
  br i1 %cmp17, label %if.then18, label %if.else

if.then18:                                        ; preds = %if.end12
  %35 = load float, ptr %inner_content_max_y, align 4
  %36 = load ptr, ptr %inner_window, align 8
  %DC19 = getelementptr inbounds %struct.ImGuiWindow, ptr %36, i32 0, i32 68
  %CursorMaxPos20 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC19, i32 0, i32 3
  %y = getelementptr inbounds %struct.ImVec2, ptr %CursorMaxPos20, i32 0, i32 1
  store float %35, ptr %y, align 4
  br label %if.end32

if.else:                                          ; preds = %if.end12
  %37 = load i32, ptr %flags, align 4
  %and21 = and i32 %37, 131072
  %tobool22 = icmp ne i32 %and21, 0
  br i1 %tobool22, label %if.end31, label %if.then23

if.then23:                                        ; preds = %if.else
  %38 = load ptr, ptr %table, align 8
  %OuterRect = getelementptr inbounds %struct.ImGuiTable, ptr %38, i32 0, i32 46
  %Max = getelementptr inbounds %struct.ImRect, ptr %OuterRect, i32 0, i32 1
  %y24 = getelementptr inbounds %struct.ImVec2, ptr %Max, i32 0, i32 1
  %39 = load float, ptr %y24, align 4
  %40 = load float, ptr %inner_content_max_y, align 4
  %call25 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %39, float noundef %40)
  %41 = load ptr, ptr %table, align 8
  %InnerRect = getelementptr inbounds %struct.ImGuiTable, ptr %41, i32 0, i32 47
  %Max26 = getelementptr inbounds %struct.ImRect, ptr %InnerRect, i32 0, i32 1
  %y27 = getelementptr inbounds %struct.ImVec2, ptr %Max26, i32 0, i32 1
  store float %call25, ptr %y27, align 4
  %42 = load ptr, ptr %table, align 8
  %OuterRect28 = getelementptr inbounds %struct.ImGuiTable, ptr %42, i32 0, i32 46
  %Max29 = getelementptr inbounds %struct.ImRect, ptr %OuterRect28, i32 0, i32 1
  %y30 = getelementptr inbounds %struct.ImVec2, ptr %Max29, i32 0, i32 1
  store float %call25, ptr %y30, align 4
  br label %if.end31

if.end31:                                         ; preds = %if.then23, %if.else
  br label %if.end32

if.end32:                                         ; preds = %if.end31, %if.then18
  %43 = load ptr, ptr %table, align 8
  %WorkRect = getelementptr inbounds %struct.ImGuiTable, ptr %43, i32 0, i32 48
  %Max33 = getelementptr inbounds %struct.ImRect, ptr %WorkRect, i32 0, i32 1
  %y34 = getelementptr inbounds %struct.ImVec2, ptr %Max33, i32 0, i32 1
  %44 = load float, ptr %y34, align 4
  %45 = load ptr, ptr %table, align 8
  %OuterRect35 = getelementptr inbounds %struct.ImGuiTable, ptr %45, i32 0, i32 46
  %Max36 = getelementptr inbounds %struct.ImRect, ptr %OuterRect35, i32 0, i32 1
  %y37 = getelementptr inbounds %struct.ImVec2, ptr %Max36, i32 0, i32 1
  %46 = load float, ptr %y37, align 4
  %call38 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %44, float noundef %46)
  %47 = load ptr, ptr %table, align 8
  %WorkRect39 = getelementptr inbounds %struct.ImGuiTable, ptr %47, i32 0, i32 48
  %Max40 = getelementptr inbounds %struct.ImRect, ptr %WorkRect39, i32 0, i32 1
  %y41 = getelementptr inbounds %struct.ImVec2, ptr %Max40, i32 0, i32 1
  store float %call38, ptr %y41, align 4
  %48 = load ptr, ptr %table, align 8
  %OuterRect42 = getelementptr inbounds %struct.ImGuiTable, ptr %48, i32 0, i32 46
  %call43 = call noundef float @_ZNK6ImRect9GetHeightEv(ptr noundef nonnull align 4 dereferenceable(16) %OuterRect42)
  %49 = load ptr, ptr %table_instance, align 8
  %LastOuterHeight = getelementptr inbounds %struct.ImGuiTableInstanceData, ptr %49, i32 0, i32 1
  store float %call43, ptr %LastOuterHeight, align 4
  %50 = load ptr, ptr %table, align 8
  %Flags44 = getelementptr inbounds %struct.ImGuiTable, ptr %50, i32 0, i32 1
  %51 = load i32, ptr %Flags44, align 4
  %and45 = and i32 %51, 16777216
  %tobool46 = icmp ne i32 %and45, 0
  br i1 %tobool46, label %if.then47, label %if.end74

if.then47:                                        ; preds = %if.end32
  %52 = load ptr, ptr %table, align 8
  %Flags48 = getelementptr inbounds %struct.ImGuiTable, ptr %52, i32 0, i32 1
  %53 = load i32, ptr %Flags48, align 4
  %and49 = and i32 %53, 1024
  %tobool50 = icmp ne i32 %and49, 0
  %cond = select i1 %tobool50, float 1.000000e+00, float 0.000000e+00
  store float %cond, ptr %outer_padding_for_border, align 4
  %54 = load ptr, ptr %table, align 8
  %InnerWindow51 = getelementptr inbounds %struct.ImGuiTable, ptr %54, i32 0, i32 56
  %55 = load ptr, ptr %InnerWindow51, align 8
  %DC52 = getelementptr inbounds %struct.ImGuiWindow, ptr %55, i32 0, i32 68
  %CursorMaxPos53 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC52, i32 0, i32 3
  %x = getelementptr inbounds %struct.ImVec2, ptr %CursorMaxPos53, i32 0, i32 0
  %56 = load float, ptr %x, align 8
  store float %56, ptr %max_pos_x, align 4
  %57 = load ptr, ptr %table, align 8
  %RightMostEnabledColumn = getelementptr inbounds %struct.ImGuiTable, ptr %57, i32 0, i32 80
  %58 = load i16, ptr %RightMostEnabledColumn, align 2
  %conv54 = sext i16 %58 to i32
  %cmp55 = icmp ne i32 %conv54, -1
  br i1 %cmp55, label %if.then56, label %if.end62

if.then56:                                        ; preds = %if.then47
  %59 = load float, ptr %max_pos_x, align 4
  %60 = load ptr, ptr %table, align 8
  %Columns = getelementptr inbounds %struct.ImGuiTable, ptr %60, i32 0, i32 4
  %61 = load ptr, ptr %table, align 8
  %RightMostEnabledColumn57 = getelementptr inbounds %struct.ImGuiTable, ptr %61, i32 0, i32 80
  %62 = load i16, ptr %RightMostEnabledColumn57, align 2
  %conv58 = sext i16 %62 to i32
  %call59 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns, i32 noundef %conv58)
  %WorkMaxX = getelementptr inbounds %struct.ImGuiTableColumn, ptr %call59, i32 0, i32 11
  %63 = load float, ptr %WorkMaxX, align 4
  %64 = load ptr, ptr %table, align 8
  %CellPaddingX = getelementptr inbounds %struct.ImGuiTable, ptr %64, i32 0, i32 34
  %65 = load float, ptr %CellPaddingX, align 8
  %add = fadd float %63, %65
  %66 = load ptr, ptr %table, align 8
  %OuterPaddingX = getelementptr inbounds %struct.ImGuiTable, ptr %66, i32 0, i32 33
  %67 = load float, ptr %OuterPaddingX, align 4
  %add60 = fadd float %add, %67
  %68 = load float, ptr %outer_padding_for_border, align 4
  %sub = fsub float %add60, %68
  %call61 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %59, float noundef %sub)
  store float %call61, ptr %max_pos_x, align 4
  br label %if.end62

if.end62:                                         ; preds = %if.then56, %if.then47
  %69 = load ptr, ptr %table, align 8
  %ResizedColumn = getelementptr inbounds %struct.ImGuiTable, ptr %69, i32 0, i32 74
  %70 = load i16, ptr %ResizedColumn, align 2
  %conv63 = sext i16 %70 to i32
  %cmp64 = icmp ne i32 %conv63, -1
  br i1 %cmp64, label %if.then65, label %if.end67

if.then65:                                        ; preds = %if.end62
  %71 = load float, ptr %max_pos_x, align 4
  %72 = load ptr, ptr %table, align 8
  %ResizeLockMinContentsX2 = getelementptr inbounds %struct.ImGuiTable, ptr %72, i32 0, i32 42
  %73 = load float, ptr %ResizeLockMinContentsX2, align 8
  %call66 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %71, float noundef %73)
  store float %call66, ptr %max_pos_x, align 4
  br label %if.end67

if.end67:                                         ; preds = %if.then65, %if.end62
  %74 = load float, ptr %max_pos_x, align 4
  %75 = load ptr, ptr %table, align 8
  %TempData68 = getelementptr inbounds %struct.ImGuiTable, ptr %75, i32 0, i32 3
  %76 = load ptr, ptr %TempData68, align 8
  %AngledheadersExtraWidth = getelementptr inbounds %struct.ImGuiTableTempData, ptr %76, i32 0, i32 2
  %77 = load float, ptr %AngledheadersExtraWidth, align 8
  %add69 = fadd float %74, %77
  %78 = load ptr, ptr %table, align 8
  %InnerWindow70 = getelementptr inbounds %struct.ImGuiTable, ptr %78, i32 0, i32 56
  %79 = load ptr, ptr %InnerWindow70, align 8
  %DC71 = getelementptr inbounds %struct.ImGuiWindow, ptr %79, i32 0, i32 68
  %CursorMaxPos72 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC71, i32 0, i32 3
  %x73 = getelementptr inbounds %struct.ImVec2, ptr %CursorMaxPos72, i32 0, i32 0
  store float %add69, ptr %x73, align 8
  br label %if.end74

if.end74:                                         ; preds = %if.end67, %if.end32
  %80 = load i32, ptr %flags, align 4
  %and75 = and i32 %80, 1048576
  %tobool76 = icmp ne i32 %and75, 0
  br i1 %tobool76, label %if.end78, label %if.then77

if.then77:                                        ; preds = %if.end74
  %81 = load ptr, ptr %inner_window, align 8
  %DrawList = getelementptr inbounds %struct.ImGuiWindow, ptr %81, i32 0, i32 86
  %82 = load ptr, ptr %DrawList, align 8
  call void @_ZN10ImDrawList11PopClipRectEv(ptr noundef nonnull align 8 dereferenceable(196) %82)
  br label %if.end78

if.end78:                                         ; preds = %if.then77, %if.end74
  %83 = load ptr, ptr %inner_window, align 8
  %DrawList79 = getelementptr inbounds %struct.ImGuiWindow, ptr %83, i32 0, i32 86
  %84 = load ptr, ptr %DrawList79, align 8
  %_ClipRectStack = getelementptr inbounds %struct.ImDrawList, ptr %84, i32 0, i32 9
  %call80 = call noundef nonnull align 4 dereferenceable(16) ptr @_ZN8ImVectorI6ImVec4E4backEv(ptr noundef nonnull align 8 dereferenceable(16) %_ClipRectStack)
  call void @_ZN6ImRectC2ERK6ImVec4(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp, ptr noundef nonnull align 4 dereferenceable(16) %call80)
  %85 = load ptr, ptr %inner_window, align 8
  %ClipRect = getelementptr inbounds %struct.ImGuiWindow, ptr %85, i32 0, i32 74
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %ClipRect, ptr align 4 %ref.tmp, i64 16, i1 false)
  %86 = load i32, ptr %flags, align 4
  %and81 = and i32 %86, 1920
  %cmp82 = icmp ne i32 %and81, 0
  br i1 %cmp82, label %if.then83, label %if.end84

if.then83:                                        ; preds = %if.end78
  %87 = load ptr, ptr %table, align 8
  call void @_ZN5ImGui16TableDrawBordersEP10ImGuiTable(ptr noundef %87)
  br label %if.end84

if.end84:                                         ; preds = %if.then83, %if.end78
  %88 = load ptr, ptr %table, align 8
  %DrawSplitter = getelementptr inbounds %struct.ImGuiTable, ptr %88, i32 0, i32 58
  %89 = load ptr, ptr %DrawSplitter, align 8
  store ptr %89, ptr %splitter, align 8
  %90 = load ptr, ptr %splitter, align 8
  %91 = load ptr, ptr %inner_window, align 8
  %DrawList85 = getelementptr inbounds %struct.ImGuiWindow, ptr %91, i32 0, i32 86
  %92 = load ptr, ptr %DrawList85, align 8
  call void @_ZN18ImDrawListSplitter17SetCurrentChannelEP10ImDrawListi(ptr noundef nonnull align 8 dereferenceable(24) %90, ptr noundef %92, i32 noundef 0)
  %93 = load ptr, ptr %table, align 8
  %Flags86 = getelementptr inbounds %struct.ImGuiTable, ptr %93, i32 0, i32 1
  %94 = load i32, ptr %Flags86, align 4
  %and87 = and i32 %94, 1048576
  %cmp88 = icmp eq i32 %and87, 0
  br i1 %cmp88, label %if.then89, label %if.end90

if.then89:                                        ; preds = %if.end84
  %95 = load ptr, ptr %table, align 8
  call void @_ZN5ImGui22TableMergeDrawChannelsEP10ImGuiTable(ptr noundef %95)
  br label %if.end90

if.end90:                                         ; preds = %if.then89, %if.end84
  %96 = load ptr, ptr %splitter, align 8
  %97 = load ptr, ptr %inner_window, align 8
  %DrawList91 = getelementptr inbounds %struct.ImGuiWindow, ptr %97, i32 0, i32 86
  %98 = load ptr, ptr %DrawList91, align 8
  call void @_ZN18ImDrawListSplitter5MergeEP10ImDrawList(ptr noundef nonnull align 8 dereferenceable(24) %96, ptr noundef %98)
  store float 0.000000e+00, ptr %auto_fit_width_for_fixed, align 4
  store float 0.000000e+00, ptr %auto_fit_width_for_stretched, align 4
  store float 0.000000e+00, ptr %auto_fit_width_for_stretched_min, align 4
  store i32 0, ptr %column_n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end90
  %99 = load i32, ptr %column_n, align 4
  %100 = load ptr, ptr %table, align 8
  %ColumnsCount = getelementptr inbounds %struct.ImGuiTable, ptr %100, i32 0, i32 13
  %101 = load i32, ptr %ColumnsCount, align 4
  %cmp92 = icmp slt i32 %99, %101
  br i1 %cmp92, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %102 = load ptr, ptr %table, align 8
  %EnabledMaskByIndex = getelementptr inbounds %struct.ImGuiTable, ptr %102, i32 0, i32 8
  %103 = load ptr, ptr %EnabledMaskByIndex, align 8
  %104 = load i32, ptr %column_n, align 4
  %shr = ashr i32 %104, 5
  %idxprom = sext i32 %shr to i64
  %arrayidx = getelementptr inbounds i32, ptr %103, i64 %idxprom
  %105 = load i32, ptr %arrayidx, align 4
  %106 = load i32, ptr %column_n, align 4
  %and93 = and i32 %106, 31
  %shl = shl i32 1, %and93
  %and94 = and i32 %105, %shl
  %cmp95 = icmp ne i32 %and94, 0
  br i1 %cmp95, label %if.then96, label %if.end127

if.then96:                                        ; preds = %for.body
  %107 = load ptr, ptr %table, align 8
  %Columns97 = getelementptr inbounds %struct.ImGuiTable, ptr %107, i32 0, i32 4
  %108 = load i32, ptr %column_n, align 4
  %call98 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns97, i32 noundef %108)
  store ptr %call98, ptr %column, align 8
  %109 = load ptr, ptr %column, align 8
  %Flags99 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %109, i32 0, i32 0
  %110 = load i32, ptr %Flags99, align 4
  %and100 = and i32 %110, 16
  %tobool101 = icmp ne i32 %and100, 0
  br i1 %tobool101, label %land.lhs.true102, label %cond.false

land.lhs.true102:                                 ; preds = %if.then96
  %111 = load ptr, ptr %column, align 8
  %Flags103 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %111, i32 0, i32 0
  %112 = load i32, ptr %Flags103, align 4
  %and104 = and i32 %112, 32
  %tobool105 = icmp ne i32 %and104, 0
  br i1 %tobool105, label %cond.false, label %cond.true

cond.true:                                        ; preds = %land.lhs.true102
  %113 = load ptr, ptr %column, align 8
  %WidthRequest = getelementptr inbounds %struct.ImGuiTableColumn, ptr %113, i32 0, i32 4
  %114 = load float, ptr %WidthRequest, align 4
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true102, %if.then96
  %115 = load ptr, ptr %table, align 8
  %116 = load ptr, ptr %column, align 8
  %call106 = call noundef float @_ZN5ImGui23TableGetColumnWidthAutoEP10ImGuiTableP16ImGuiTableColumn(ptr noundef %115, ptr noundef %116)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond107 = phi float [ %114, %cond.true ], [ %call106, %cond.false ]
  store float %cond107, ptr %column_width_request, align 4
  %117 = load ptr, ptr %column, align 8
  %Flags108 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %117, i32 0, i32 0
  %118 = load i32, ptr %Flags108, align 4
  %and109 = and i32 %118, 16
  %tobool110 = icmp ne i32 %and109, 0
  br i1 %tobool110, label %if.then111, label %if.else113

if.then111:                                       ; preds = %cond.end
  %119 = load float, ptr %column_width_request, align 4
  %120 = load float, ptr %auto_fit_width_for_fixed, align 4
  %add112 = fadd float %120, %119
  store float %add112, ptr %auto_fit_width_for_fixed, align 4
  br label %if.end115

if.else113:                                       ; preds = %cond.end
  %121 = load float, ptr %column_width_request, align 4
  %122 = load float, ptr %auto_fit_width_for_stretched, align 4
  %add114 = fadd float %122, %121
  store float %add114, ptr %auto_fit_width_for_stretched, align 4
  br label %if.end115

if.end115:                                        ; preds = %if.else113, %if.then111
  %123 = load ptr, ptr %column, align 8
  %Flags116 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %123, i32 0, i32 0
  %124 = load i32, ptr %Flags116, align 4
  %and117 = and i32 %124, 8
  %tobool118 = icmp ne i32 %and117, 0
  br i1 %tobool118, label %land.lhs.true119, label %if.end126

land.lhs.true119:                                 ; preds = %if.end115
  %125 = load ptr, ptr %column, align 8
  %Flags120 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %125, i32 0, i32 0
  %126 = load i32, ptr %Flags120, align 4
  %and121 = and i32 %126, 32
  %cmp122 = icmp ne i32 %and121, 0
  br i1 %cmp122, label %if.then123, label %if.end126

if.then123:                                       ; preds = %land.lhs.true119
  %127 = load float, ptr %auto_fit_width_for_stretched_min, align 4
  %128 = load float, ptr %column_width_request, align 4
  %129 = load ptr, ptr %column, align 8
  %StretchWeight = getelementptr inbounds %struct.ImGuiTableColumn, ptr %129, i32 0, i32 6
  %130 = load float, ptr %StretchWeight, align 4
  %131 = load ptr, ptr %table, align 8
  %ColumnsStretchSumWeights = getelementptr inbounds %struct.ImGuiTable, ptr %131, i32 0, i32 40
  %132 = load float, ptr %ColumnsStretchSumWeights, align 8
  %div = fdiv float %130, %132
  %div124 = fdiv float %128, %div
  %call125 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %127, float noundef %div124)
  store float %call125, ptr %auto_fit_width_for_stretched_min, align 4
  br label %if.end126

if.end126:                                        ; preds = %if.then123, %land.lhs.true119, %if.end115
  br label %if.end127

if.end127:                                        ; preds = %if.end126, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end127
  %133 = load i32, ptr %column_n, align 4
  %inc = add nsw i32 %133, 1
  store i32 %inc, ptr %column_n, align 4
  br label %for.cond, !llvm.loop !25

for.end:                                          ; preds = %for.cond
  %134 = load ptr, ptr %table, align 8
  %OuterPaddingX128 = getelementptr inbounds %struct.ImGuiTable, ptr %134, i32 0, i32 33
  %135 = load float, ptr %OuterPaddingX128, align 4
  %136 = load ptr, ptr %table, align 8
  %CellSpacingX1 = getelementptr inbounds %struct.ImGuiTable, ptr %136, i32 0, i32 35
  %137 = load float, ptr %CellSpacingX1, align 4
  %138 = load ptr, ptr %table, align 8
  %CellSpacingX2 = getelementptr inbounds %struct.ImGuiTable, ptr %138, i32 0, i32 36
  %139 = load float, ptr %CellSpacingX2, align 8
  %add129 = fadd float %137, %139
  %140 = load ptr, ptr %table, align 8
  %ColumnsEnabledCount = getelementptr inbounds %struct.ImGuiTable, ptr %140, i32 0, i32 66
  %141 = load i16, ptr %ColumnsEnabledCount, align 2
  %conv130 = sext i16 %141 to i32
  %sub131 = sub nsw i32 %conv130, 1
  %conv132 = sitofp i32 %sub131 to float
  %mul133 = fmul float %add129, %conv132
  %142 = call float @llvm.fmuladd.f32(float %135, float 2.000000e+00, float %mul133)
  store float %142, ptr %width_spacings, align 4
  %143 = load float, ptr %width_spacings, align 4
  %144 = load ptr, ptr %table, align 8
  %CellPaddingX134 = getelementptr inbounds %struct.ImGuiTable, ptr %144, i32 0, i32 34
  %145 = load float, ptr %CellPaddingX134, align 8
  %mul = fmul float %145, 2.000000e+00
  %146 = load ptr, ptr %table, align 8
  %ColumnsEnabledCount135 = getelementptr inbounds %struct.ImGuiTable, ptr %146, i32 0, i32 66
  %147 = load i16, ptr %ColumnsEnabledCount135, align 2
  %conv136 = sext i16 %147 to i32
  %conv137 = sitofp i32 %conv136 to float
  %148 = call float @llvm.fmuladd.f32(float %mul, float %conv137, float %143)
  %149 = load float, ptr %auto_fit_width_for_fixed, align 4
  %add139 = fadd float %148, %149
  %150 = load float, ptr %auto_fit_width_for_stretched, align 4
  %151 = load float, ptr %auto_fit_width_for_stretched_min, align 4
  %call140 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %150, float noundef %151)
  %add141 = fadd float %add139, %call140
  %152 = load ptr, ptr %table, align 8
  %ColumnsAutoFitWidth = getelementptr inbounds %struct.ImGuiTable, ptr %152, i32 0, i32 39
  store float %add141, ptr %ColumnsAutoFitWidth, align 4
  %153 = load ptr, ptr %table, align 8
  %Flags142 = getelementptr inbounds %struct.ImGuiTable, ptr %153, i32 0, i32 1
  %154 = load i32, ptr %Flags142, align 4
  %and143 = and i32 %154, 16777216
  %cmp144 = icmp eq i32 %and143, 0
  br i1 %cmp144, label %land.lhs.true145, label %if.else149

land.lhs.true145:                                 ; preds = %for.end
  %155 = load ptr, ptr %inner_window, align 8
  %156 = load ptr, ptr %outer_window, align 8
  %cmp146 = icmp ne ptr %155, %156
  br i1 %cmp146, label %if.then147, label %if.else149

if.then147:                                       ; preds = %land.lhs.true145
  %157 = load ptr, ptr %inner_window, align 8
  %Scroll = getelementptr inbounds %struct.ImGuiWindow, ptr %157, i32 0, i32 25
  %x148 = getelementptr inbounds %struct.ImVec2, ptr %Scroll, i32 0, i32 0
  store float 0.000000e+00, ptr %x148, align 4
  br label %if.end193

if.else149:                                       ; preds = %land.lhs.true145, %for.end
  %158 = load ptr, ptr %table, align 8
  %LastResizedColumn = getelementptr inbounds %struct.ImGuiTable, ptr %158, i32 0, i32 75
  %159 = load i16, ptr %LastResizedColumn, align 4
  %conv150 = sext i16 %159 to i32
  %cmp151 = icmp ne i32 %conv150, -1
  br i1 %cmp151, label %land.lhs.true152, label %if.end192

land.lhs.true152:                                 ; preds = %if.else149
  %160 = load ptr, ptr %table, align 8
  %ResizedColumn153 = getelementptr inbounds %struct.ImGuiTable, ptr %160, i32 0, i32 74
  %161 = load i16, ptr %ResizedColumn153, align 2
  %conv154 = sext i16 %161 to i32
  %cmp155 = icmp eq i32 %conv154, -1
  br i1 %cmp155, label %land.lhs.true156, label %if.end192

land.lhs.true156:                                 ; preds = %land.lhs.true152
  %162 = load ptr, ptr %inner_window, align 8
  %ScrollbarX = getelementptr inbounds %struct.ImGuiWindow, ptr %162, i32 0, i32 31
  %163 = load i8, ptr %ScrollbarX, align 4
  %tobool157 = trunc i8 %163 to i1
  br i1 %tobool157, label %land.lhs.true158, label %if.end192

land.lhs.true158:                                 ; preds = %land.lhs.true156
  %164 = load ptr, ptr %table, align 8
  %InstanceInteracted = getelementptr inbounds %struct.ImGuiTable, ptr %164, i32 0, i32 17
  %165 = load i16, ptr %InstanceInteracted, align 2
  %conv159 = sext i16 %165 to i32
  %166 = load ptr, ptr %table, align 8
  %InstanceCurrent160 = getelementptr inbounds %struct.ImGuiTable, ptr %166, i32 0, i32 16
  %167 = load i16, ptr %InstanceCurrent160, align 8
  %conv161 = sext i16 %167 to i32
  %cmp162 = icmp eq i32 %conv159, %conv161
  br i1 %cmp162, label %if.then163, label %if.end192

if.then163:                                       ; preds = %land.lhs.true158
  %168 = load ptr, ptr %table, align 8
  %MinColumnWidth = getelementptr inbounds %struct.ImGuiTable, ptr %168, i32 0, i32 32
  %169 = load float, ptr %MinColumnWidth, align 8
  %170 = load ptr, ptr %table, align 8
  %CellPaddingX164 = getelementptr inbounds %struct.ImGuiTable, ptr %170, i32 0, i32 34
  %171 = load float, ptr %CellPaddingX164, align 8
  %172 = call float @llvm.fmuladd.f32(float %171, float 2.000000e+00, float %169)
  store float %172, ptr %neighbor_width_to_keep_visible, align 4
  %173 = load ptr, ptr %table, align 8
  %Columns167 = getelementptr inbounds %struct.ImGuiTable, ptr %173, i32 0, i32 4
  %174 = load ptr, ptr %table, align 8
  %LastResizedColumn168 = getelementptr inbounds %struct.ImGuiTable, ptr %174, i32 0, i32 75
  %175 = load i16, ptr %LastResizedColumn168, align 4
  %conv169 = sext i16 %175 to i32
  %call170 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns167, i32 noundef %conv169)
  store ptr %call170, ptr %column166, align 8
  %176 = load ptr, ptr %column166, align 8
  %MaxX = getelementptr inbounds %struct.ImGuiTableColumn, ptr %176, i32 0, i32 3
  %177 = load float, ptr %MaxX, align 4
  %178 = load ptr, ptr %table, align 8
  %InnerClipRect = getelementptr inbounds %struct.ImGuiTable, ptr %178, i32 0, i32 49
  %Min = getelementptr inbounds %struct.ImRect, ptr %InnerClipRect, i32 0, i32 0
  %x171 = getelementptr inbounds %struct.ImVec2, ptr %Min, i32 0, i32 0
  %179 = load float, ptr %x171, align 8
  %cmp172 = fcmp olt float %177, %179
  br i1 %cmp172, label %if.then173, label %if.else178

if.then173:                                       ; preds = %if.then163
  %180 = load ptr, ptr %inner_window, align 8
  %181 = load ptr, ptr %column166, align 8
  %MaxX174 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %181, i32 0, i32 3
  %182 = load float, ptr %MaxX174, align 4
  %183 = load ptr, ptr %inner_window, align 8
  %Pos = getelementptr inbounds %struct.ImGuiWindow, ptr %183, i32 0, i32 7
  %x175 = getelementptr inbounds %struct.ImVec2, ptr %Pos, i32 0, i32 0
  %184 = load float, ptr %x175, align 8
  %sub176 = fsub float %182, %184
  %185 = load float, ptr %neighbor_width_to_keep_visible, align 4
  %sub177 = fsub float %sub176, %185
  call void @_ZN5ImGui17SetScrollFromPosXEP11ImGuiWindowff(ptr noundef %180, float noundef %sub177, float noundef 1.000000e+00)
  br label %if.end191

if.else178:                                       ; preds = %if.then163
  %186 = load ptr, ptr %column166, align 8
  %MaxX179 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %186, i32 0, i32 3
  %187 = load float, ptr %MaxX179, align 4
  %188 = load ptr, ptr %table, align 8
  %InnerClipRect180 = getelementptr inbounds %struct.ImGuiTable, ptr %188, i32 0, i32 49
  %Max181 = getelementptr inbounds %struct.ImRect, ptr %InnerClipRect180, i32 0, i32 1
  %x182 = getelementptr inbounds %struct.ImVec2, ptr %Max181, i32 0, i32 0
  %189 = load float, ptr %x182, align 8
  %cmp183 = fcmp ogt float %187, %189
  br i1 %cmp183, label %if.then184, label %if.end190

if.then184:                                       ; preds = %if.else178
  %190 = load ptr, ptr %inner_window, align 8
  %191 = load ptr, ptr %column166, align 8
  %MaxX185 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %191, i32 0, i32 3
  %192 = load float, ptr %MaxX185, align 4
  %193 = load ptr, ptr %inner_window, align 8
  %Pos186 = getelementptr inbounds %struct.ImGuiWindow, ptr %193, i32 0, i32 7
  %x187 = getelementptr inbounds %struct.ImVec2, ptr %Pos186, i32 0, i32 0
  %194 = load float, ptr %x187, align 8
  %sub188 = fsub float %192, %194
  %195 = load float, ptr %neighbor_width_to_keep_visible, align 4
  %add189 = fadd float %sub188, %195
  call void @_ZN5ImGui17SetScrollFromPosXEP11ImGuiWindowff(ptr noundef %190, float noundef %add189, float noundef 1.000000e+00)
  br label %if.end190

if.end190:                                        ; preds = %if.then184, %if.else178
  br label %if.end191

if.end191:                                        ; preds = %if.end190, %if.then173
  br label %if.end192

if.end192:                                        ; preds = %if.end191, %land.lhs.true158, %land.lhs.true156, %land.lhs.true152, %if.else149
  br label %if.end193

if.end193:                                        ; preds = %if.end192, %if.then147
  %196 = load ptr, ptr %table, align 8
  %ResizedColumn194 = getelementptr inbounds %struct.ImGuiTable, ptr %196, i32 0, i32 74
  %197 = load i16, ptr %ResizedColumn194, align 2
  %conv195 = sext i16 %197 to i32
  %cmp196 = icmp ne i32 %conv195, -1
  br i1 %cmp196, label %land.lhs.true197, label %if.end219

land.lhs.true197:                                 ; preds = %if.end193
  %198 = load ptr, ptr %table, align 8
  %InstanceCurrent198 = getelementptr inbounds %struct.ImGuiTable, ptr %198, i32 0, i32 16
  %199 = load i16, ptr %InstanceCurrent198, align 8
  %conv199 = sext i16 %199 to i32
  %200 = load ptr, ptr %table, align 8
  %InstanceInteracted200 = getelementptr inbounds %struct.ImGuiTable, ptr %200, i32 0, i32 17
  %201 = load i16, ptr %InstanceInteracted200, align 2
  %conv201 = sext i16 %201 to i32
  %cmp202 = icmp eq i32 %conv199, %conv201
  br i1 %cmp202, label %if.then203, label %if.end219

if.then203:                                       ; preds = %land.lhs.true197
  %202 = load ptr, ptr %table, align 8
  %Columns205 = getelementptr inbounds %struct.ImGuiTable, ptr %202, i32 0, i32 4
  %203 = load ptr, ptr %table, align 8
  %ResizedColumn206 = getelementptr inbounds %struct.ImGuiTable, ptr %203, i32 0, i32 74
  %204 = load i16, ptr %ResizedColumn206, align 2
  %conv207 = sext i16 %204 to i32
  %call208 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns205, i32 noundef %conv207)
  store ptr %call208, ptr %column204, align 8
  %205 = load ptr, ptr %g, align 8
  %IO = getelementptr inbounds %struct.ImGuiContext, ptr %205, i32 0, i32 2
  %MousePos = getelementptr inbounds %struct.ImGuiIO, ptr %IO, i32 0, i32 59
  %x209 = getelementptr inbounds %struct.ImVec2, ptr %MousePos, i32 0, i32 0
  %206 = load float, ptr %x209, align 8
  %207 = load ptr, ptr %g, align 8
  %ActiveIdClickOffset = getelementptr inbounds %struct.ImGuiContext, ptr %207, i32 0, i32 56
  %x210 = getelementptr inbounds %struct.ImVec2, ptr %ActiveIdClickOffset, i32 0, i32 0
  %208 = load float, ptr %x210, align 8
  %sub211 = fsub float %206, %208
  %add212 = fadd float %sub211, 4.000000e+00
  store float %add212, ptr %new_x2, align 4
  %209 = load float, ptr %new_x2, align 4
  %210 = load ptr, ptr %column204, align 8
  %MinX = getelementptr inbounds %struct.ImGuiTableColumn, ptr %210, i32 0, i32 2
  %211 = load float, ptr %MinX, align 4
  %sub213 = fsub float %209, %211
  %212 = load ptr, ptr %table, align 8
  %CellSpacingX1214 = getelementptr inbounds %struct.ImGuiTable, ptr %212, i32 0, i32 35
  %213 = load float, ptr %CellSpacingX1214, align 4
  %sub215 = fsub float %sub213, %213
  %214 = load ptr, ptr %table, align 8
  %CellPaddingX216 = getelementptr inbounds %struct.ImGuiTable, ptr %214, i32 0, i32 34
  %215 = load float, ptr %CellPaddingX216, align 8
  %neg = fneg float %215
  %216 = call float @llvm.fmuladd.f32(float %neg, float 2.000000e+00, float %sub215)
  %call218 = call noundef float @_ZL7ImTruncf(float noundef %216)
  store float %call218, ptr %new_width, align 4
  %217 = load float, ptr %new_width, align 4
  %218 = load ptr, ptr %table, align 8
  %ResizedColumnNextWidth = getelementptr inbounds %struct.ImGuiTable, ptr %218, i32 0, i32 41
  store float %217, ptr %ResizedColumnNextWidth, align 4
  br label %if.end219

if.end219:                                        ; preds = %if.then203, %land.lhs.true197, %if.end193
  %219 = load ptr, ptr %g, align 8
  %ActiveIdIsAlive = getelementptr inbounds %struct.ImGuiContext, ptr %219, i32 0, i32 48
  %220 = load i32, ptr %ActiveIdIsAlive, align 8
  %cmp220 = icmp ne i32 %220, 0
  br i1 %cmp220, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end219
  %221 = load ptr, ptr %table, align 8
  %IsActiveIdAliveBeforeTable = getelementptr inbounds %struct.ImGuiTable, ptr %221, i32 0, i32 106
  %222 = load i8, ptr %IsActiveIdAliveBeforeTable, align 4
  %tobool221 = trunc i8 %222 to i1
  %conv222 = zext i1 %tobool221 to i32
  %cmp223 = icmp eq i32 %conv222, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end219
  %223 = phi i1 [ false, %if.end219 ], [ %cmp223, %land.rhs ]
  %224 = load ptr, ptr %table, align 8
  %IsActiveIdInTable = getelementptr inbounds %struct.ImGuiTable, ptr %224, i32 0, i32 107
  %frombool = zext i1 %223 to i8
  store i8 %frombool, ptr %IsActiveIdInTable, align 1
  %225 = load ptr, ptr %table, align 8
  %InstanceCurrent224 = getelementptr inbounds %struct.ImGuiTable, ptr %225, i32 0, i32 16
  %226 = load i16, ptr %InstanceCurrent224, align 8
  %conv225 = sext i16 %226 to i32
  %cmp226 = icmp sgt i32 %conv225, 0
  br i1 %cmp226, label %if.then227, label %if.end228

if.then227:                                       ; preds = %land.end
  call void @_ZN5ImGui5PopIDEv()
  br label %if.end228

if.end228:                                        ; preds = %if.then227, %land.end
  call void @_ZN5ImGui5PopIDEv()
  %227 = load ptr, ptr %outer_window, align 8
  %DC229 = getelementptr inbounds %struct.ImGuiWindow, ptr %227, i32 0, i32 68
  %CursorMaxPos230 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC229, i32 0, i32 3
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %backup_outer_max_pos, ptr align 8 %CursorMaxPos230, i64 8, i1 false)
  %228 = load ptr, ptr %temp_data, align 8
  %HostBackupWorkRect = getelementptr inbounds %struct.ImGuiTableTempData, ptr %228, i32 0, i32 6
  %229 = load ptr, ptr %inner_window, align 8
  %WorkRect231 = getelementptr inbounds %struct.ImGuiWindow, ptr %229, i32 0, i32 72
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %WorkRect231, ptr align 8 %HostBackupWorkRect, i64 16, i1 false)
  %230 = load ptr, ptr %temp_data, align 8
  %HostBackupParentWorkRect = getelementptr inbounds %struct.ImGuiTableTempData, ptr %230, i32 0, i32 7
  %231 = load ptr, ptr %inner_window, align 8
  %ParentWorkRect = getelementptr inbounds %struct.ImGuiWindow, ptr %231, i32 0, i32 73
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %ParentWorkRect, ptr align 8 %HostBackupParentWorkRect, i64 16, i1 false)
  %232 = load ptr, ptr %table, align 8
  %HostSkipItems = getelementptr inbounds %struct.ImGuiTable, ptr %232, i32 0, i32 111
  %233 = load i8, ptr %HostSkipItems, align 1
  %tobool232 = trunc i8 %233 to i1
  %234 = load ptr, ptr %inner_window, align 8
  %SkipItems = getelementptr inbounds %struct.ImGuiWindow, ptr %234, i32 0, i32 38
  %frombool233 = zext i1 %tobool232 to i8
  store i8 %frombool233, ptr %SkipItems, align 1
  %235 = load ptr, ptr %table, align 8
  %OuterRect234 = getelementptr inbounds %struct.ImGuiTable, ptr %235, i32 0, i32 46
  %Min235 = getelementptr inbounds %struct.ImRect, ptr %OuterRect234, i32 0, i32 0
  %236 = load ptr, ptr %outer_window, align 8
  %DC236 = getelementptr inbounds %struct.ImGuiWindow, ptr %236, i32 0, i32 68
  %CursorPos = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC236, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %CursorPos, ptr align 8 %Min235, i64 8, i1 false)
  %237 = load ptr, ptr %temp_data, align 8
  %HostBackupItemWidth = getelementptr inbounds %struct.ImGuiTableTempData, ptr %237, i32 0, i32 12
  %238 = load float, ptr %HostBackupItemWidth, align 4
  %239 = load ptr, ptr %outer_window, align 8
  %DC237 = getelementptr inbounds %struct.ImGuiWindow, ptr %239, i32 0, i32 68
  %ItemWidth = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC237, i32 0, i32 32
  store float %238, ptr %ItemWidth, align 4
  %240 = load ptr, ptr %temp_data, align 8
  %HostBackupItemWidthStackSize = getelementptr inbounds %struct.ImGuiTableTempData, ptr %240, i32 0, i32 13
  %241 = load i32, ptr %HostBackupItemWidthStackSize, align 8
  %242 = load ptr, ptr %outer_window, align 8
  %DC238 = getelementptr inbounds %struct.ImGuiWindow, ptr %242, i32 0, i32 68
  %ItemWidthStack = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC238, i32 0, i32 34
  %Size = getelementptr inbounds %struct.ImVector.19, ptr %ItemWidthStack, i32 0, i32 0
  store i32 %241, ptr %Size, align 8
  %243 = load ptr, ptr %temp_data, align 8
  %HostBackupColumnsOffset = getelementptr inbounds %struct.ImGuiTableTempData, ptr %243, i32 0, i32 11
  %244 = load ptr, ptr %outer_window, align 8
  %DC239 = getelementptr inbounds %struct.ImGuiWindow, ptr %244, i32 0, i32 68
  %ColumnsOffset = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC239, i32 0, i32 12
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %ColumnsOffset, ptr align 8 %HostBackupColumnsOffset, i64 4, i1 false)
  %245 = load ptr, ptr %inner_window, align 8
  %246 = load ptr, ptr %outer_window, align 8
  %cmp240 = icmp ne ptr %245, %246
  br i1 %cmp240, label %if.then241, label %if.else242

if.then241:                                       ; preds = %if.end228
  call void @_ZN5ImGui8EndChildEv()
  br label %if.end248

if.else242:                                       ; preds = %if.end228
  %247 = load ptr, ptr %table, align 8
  %OuterRect244 = getelementptr inbounds %struct.ImGuiTable, ptr %247, i32 0, i32 46
  %call245 = call <2 x float> @_ZNK6ImRect7GetSizeEv(ptr noundef nonnull align 4 dereferenceable(16) %OuterRect244)
  store <2 x float> %call245, ptr %ref.tmp243, align 4
  call void @_ZN5ImGui8ItemSizeERK6ImVec2f(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp243, float noundef -1.000000e+00)
  %248 = load ptr, ptr %table, align 8
  %OuterRect246 = getelementptr inbounds %struct.ImGuiTable, ptr %248, i32 0, i32 46
  %call247 = call noundef zeroext i1 @_ZN5ImGui7ItemAddERK6ImRectjPS1_i(ptr noundef nonnull align 4 dereferenceable(16) %OuterRect246, i32 noundef 0, ptr noundef null, i32 noundef 0)
  br label %if.end248

if.end248:                                        ; preds = %if.else242, %if.then241
  %249 = load ptr, ptr %table, align 8
  %Flags249 = getelementptr inbounds %struct.ImGuiTable, ptr %249, i32 0, i32 1
  %250 = load i32, ptr %Flags249, align 4
  %and250 = and i32 %250, 65536
  %tobool251 = icmp ne i32 %and250, 0
  br i1 %tobool251, label %if.then252, label %if.else263

if.then252:                                       ; preds = %if.end248
  %x253 = getelementptr inbounds %struct.ImVec2, ptr %backup_outer_max_pos, i32 0, i32 0
  %251 = load float, ptr %x253, align 4
  %252 = load ptr, ptr %table, align 8
  %OuterRect254 = getelementptr inbounds %struct.ImGuiTable, ptr %252, i32 0, i32 46
  %Min255 = getelementptr inbounds %struct.ImRect, ptr %OuterRect254, i32 0, i32 0
  %x256 = getelementptr inbounds %struct.ImVec2, ptr %Min255, i32 0, i32 0
  %253 = load float, ptr %x256, align 8
  %254 = load ptr, ptr %table, align 8
  %ColumnsAutoFitWidth257 = getelementptr inbounds %struct.ImGuiTable, ptr %254, i32 0, i32 39
  %255 = load float, ptr %ColumnsAutoFitWidth257, align 4
  %add258 = fadd float %253, %255
  %call259 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %251, float noundef %add258)
  %256 = load ptr, ptr %outer_window, align 8
  %DC260 = getelementptr inbounds %struct.ImGuiWindow, ptr %256, i32 0, i32 68
  %CursorMaxPos261 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC260, i32 0, i32 3
  %x262 = getelementptr inbounds %struct.ImVec2, ptr %CursorMaxPos261, i32 0, i32 0
  store float %call259, ptr %x262, align 8
  br label %if.end317

if.else263:                                       ; preds = %if.end248
  %257 = load ptr, ptr %temp_data, align 8
  %UserOuterSize = getelementptr inbounds %struct.ImGuiTableTempData, ptr %257, i32 0, i32 3
  %x264 = getelementptr inbounds %struct.ImVec2, ptr %UserOuterSize, i32 0, i32 0
  %258 = load float, ptr %x264, align 4
  %cmp265 = fcmp ole float %258, 0.000000e+00
  br i1 %cmp265, label %if.then266, label %if.else307

if.then266:                                       ; preds = %if.else263
  %259 = load ptr, ptr %table, align 8
  %TempData267 = getelementptr inbounds %struct.ImGuiTable, ptr %259, i32 0, i32 3
  %260 = load ptr, ptr %TempData267, align 8
  %AngledheadersExtraWidth268 = getelementptr inbounds %struct.ImGuiTableTempData, ptr %260, i32 0, i32 2
  %261 = load float, ptr %AngledheadersExtraWidth268, align 8
  %262 = load ptr, ptr %table, align 8
  %Flags269 = getelementptr inbounds %struct.ImGuiTable, ptr %262, i32 0, i32 1
  %263 = load i32, ptr %Flags269, align 4
  %and270 = and i32 %263, 16777216
  %tobool271 = icmp ne i32 %and270, 0
  br i1 %tobool271, label %cond.true272, label %cond.false274

cond.true272:                                     ; preds = %if.then266
  %264 = load ptr, ptr %inner_window, align 8
  %ScrollbarSizes = getelementptr inbounds %struct.ImGuiWindow, ptr %264, i32 0, i32 30
  %x273 = getelementptr inbounds %struct.ImVec2, ptr %ScrollbarSizes, i32 0, i32 0
  %265 = load float, ptr %x273, align 4
  br label %cond.end275

cond.false274:                                    ; preds = %if.then266
  br label %cond.end275

cond.end275:                                      ; preds = %cond.false274, %cond.true272
  %cond276 = phi float [ %265, %cond.true272 ], [ 0.000000e+00, %cond.false274 ]
  %add277 = fadd float %261, %cond276
  store float %add277, ptr %decoration_size, align 4
  %266 = load ptr, ptr %outer_window, align 8
  %DC278 = getelementptr inbounds %struct.ImGuiWindow, ptr %266, i32 0, i32 68
  %IdealMaxPos = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC278, i32 0, i32 4
  %x279 = getelementptr inbounds %struct.ImVec2, ptr %IdealMaxPos, i32 0, i32 0
  %267 = load float, ptr %x279, align 8
  %268 = load ptr, ptr %table, align 8
  %OuterRect280 = getelementptr inbounds %struct.ImGuiTable, ptr %268, i32 0, i32 46
  %Min281 = getelementptr inbounds %struct.ImRect, ptr %OuterRect280, i32 0, i32 0
  %x282 = getelementptr inbounds %struct.ImVec2, ptr %Min281, i32 0, i32 0
  %269 = load float, ptr %x282, align 8
  %270 = load ptr, ptr %table, align 8
  %ColumnsAutoFitWidth283 = getelementptr inbounds %struct.ImGuiTable, ptr %270, i32 0, i32 39
  %271 = load float, ptr %ColumnsAutoFitWidth283, align 4
  %add284 = fadd float %269, %271
  %272 = load float, ptr %decoration_size, align 4
  %add285 = fadd float %add284, %272
  %273 = load ptr, ptr %temp_data, align 8
  %UserOuterSize286 = getelementptr inbounds %struct.ImGuiTableTempData, ptr %273, i32 0, i32 3
  %x287 = getelementptr inbounds %struct.ImVec2, ptr %UserOuterSize286, i32 0, i32 0
  %274 = load float, ptr %x287, align 4
  %sub288 = fsub float %add285, %274
  %call289 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %267, float noundef %sub288)
  %275 = load ptr, ptr %outer_window, align 8
  %DC290 = getelementptr inbounds %struct.ImGuiWindow, ptr %275, i32 0, i32 68
  %IdealMaxPos291 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC290, i32 0, i32 4
  %x292 = getelementptr inbounds %struct.ImVec2, ptr %IdealMaxPos291, i32 0, i32 0
  store float %call289, ptr %x292, align 8
  %x293 = getelementptr inbounds %struct.ImVec2, ptr %backup_outer_max_pos, i32 0, i32 0
  %276 = load float, ptr %x293, align 4
  %277 = load ptr, ptr %table, align 8
  %OuterRect294 = getelementptr inbounds %struct.ImGuiTable, ptr %277, i32 0, i32 46
  %Max295 = getelementptr inbounds %struct.ImRect, ptr %OuterRect294, i32 0, i32 1
  %x296 = getelementptr inbounds %struct.ImVec2, ptr %Max295, i32 0, i32 0
  %278 = load float, ptr %x296, align 8
  %279 = load ptr, ptr %table, align 8
  %OuterRect297 = getelementptr inbounds %struct.ImGuiTable, ptr %279, i32 0, i32 46
  %Min298 = getelementptr inbounds %struct.ImRect, ptr %OuterRect297, i32 0, i32 0
  %x299 = getelementptr inbounds %struct.ImVec2, ptr %Min298, i32 0, i32 0
  %280 = load float, ptr %x299, align 8
  %281 = load ptr, ptr %table, align 8
  %ColumnsAutoFitWidth300 = getelementptr inbounds %struct.ImGuiTable, ptr %281, i32 0, i32 39
  %282 = load float, ptr %ColumnsAutoFitWidth300, align 4
  %add301 = fadd float %280, %282
  %call302 = call noundef float @_ZL5ImMinIfET_S0_S0_(float noundef %278, float noundef %add301)
  %call303 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %276, float noundef %call302)
  %283 = load ptr, ptr %outer_window, align 8
  %DC304 = getelementptr inbounds %struct.ImGuiWindow, ptr %283, i32 0, i32 68
  %CursorMaxPos305 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC304, i32 0, i32 3
  %x306 = getelementptr inbounds %struct.ImVec2, ptr %CursorMaxPos305, i32 0, i32 0
  store float %call303, ptr %x306, align 8
  br label %if.end316

if.else307:                                       ; preds = %if.else263
  %x308 = getelementptr inbounds %struct.ImVec2, ptr %backup_outer_max_pos, i32 0, i32 0
  %284 = load float, ptr %x308, align 4
  %285 = load ptr, ptr %table, align 8
  %OuterRect309 = getelementptr inbounds %struct.ImGuiTable, ptr %285, i32 0, i32 46
  %Max310 = getelementptr inbounds %struct.ImRect, ptr %OuterRect309, i32 0, i32 1
  %x311 = getelementptr inbounds %struct.ImVec2, ptr %Max310, i32 0, i32 0
  %286 = load float, ptr %x311, align 8
  %call312 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %284, float noundef %286)
  %287 = load ptr, ptr %outer_window, align 8
  %DC313 = getelementptr inbounds %struct.ImGuiWindow, ptr %287, i32 0, i32 68
  %CursorMaxPos314 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC313, i32 0, i32 3
  %x315 = getelementptr inbounds %struct.ImVec2, ptr %CursorMaxPos314, i32 0, i32 0
  store float %call312, ptr %x315, align 8
  br label %if.end316

if.end316:                                        ; preds = %if.else307, %cond.end275
  br label %if.end317

if.end317:                                        ; preds = %if.end316, %if.then252
  %288 = load ptr, ptr %temp_data, align 8
  %UserOuterSize318 = getelementptr inbounds %struct.ImGuiTableTempData, ptr %288, i32 0, i32 3
  %y319 = getelementptr inbounds %struct.ImVec2, ptr %UserOuterSize318, i32 0, i32 1
  %289 = load float, ptr %y319, align 4
  %cmp320 = fcmp ole float %289, 0.000000e+00
  br i1 %cmp320, label %if.then321, label %if.else352

if.then321:                                       ; preds = %if.end317
  %290 = load ptr, ptr %table, align 8
  %Flags323 = getelementptr inbounds %struct.ImGuiTable, ptr %290, i32 0, i32 1
  %291 = load i32, ptr %Flags323, align 4
  %and324 = and i32 %291, 33554432
  %tobool325 = icmp ne i32 %and324, 0
  br i1 %tobool325, label %cond.true326, label %cond.false329

cond.true326:                                     ; preds = %if.then321
  %292 = load ptr, ptr %inner_window, align 8
  %ScrollbarSizes327 = getelementptr inbounds %struct.ImGuiWindow, ptr %292, i32 0, i32 30
  %y328 = getelementptr inbounds %struct.ImVec2, ptr %ScrollbarSizes327, i32 0, i32 1
  %293 = load float, ptr %y328, align 4
  br label %cond.end330

cond.false329:                                    ; preds = %if.then321
  br label %cond.end330

cond.end330:                                      ; preds = %cond.false329, %cond.true326
  %cond331 = phi float [ %293, %cond.true326 ], [ 0.000000e+00, %cond.false329 ]
  store float %cond331, ptr %decoration_size322, align 4
  %294 = load ptr, ptr %outer_window, align 8
  %DC332 = getelementptr inbounds %struct.ImGuiWindow, ptr %294, i32 0, i32 68
  %IdealMaxPos333 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC332, i32 0, i32 4
  %y334 = getelementptr inbounds %struct.ImVec2, ptr %IdealMaxPos333, i32 0, i32 1
  %295 = load float, ptr %y334, align 4
  %296 = load float, ptr %inner_content_max_y, align 4
  %297 = load float, ptr %decoration_size322, align 4
  %add335 = fadd float %296, %297
  %298 = load ptr, ptr %temp_data, align 8
  %UserOuterSize336 = getelementptr inbounds %struct.ImGuiTableTempData, ptr %298, i32 0, i32 3
  %y337 = getelementptr inbounds %struct.ImVec2, ptr %UserOuterSize336, i32 0, i32 1
  %299 = load float, ptr %y337, align 4
  %sub338 = fsub float %add335, %299
  %call339 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %295, float noundef %sub338)
  %300 = load ptr, ptr %outer_window, align 8
  %DC340 = getelementptr inbounds %struct.ImGuiWindow, ptr %300, i32 0, i32 68
  %IdealMaxPos341 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC340, i32 0, i32 4
  %y342 = getelementptr inbounds %struct.ImVec2, ptr %IdealMaxPos341, i32 0, i32 1
  store float %call339, ptr %y342, align 4
  %y343 = getelementptr inbounds %struct.ImVec2, ptr %backup_outer_max_pos, i32 0, i32 1
  %301 = load float, ptr %y343, align 4
  %302 = load ptr, ptr %table, align 8
  %OuterRect344 = getelementptr inbounds %struct.ImGuiTable, ptr %302, i32 0, i32 46
  %Max345 = getelementptr inbounds %struct.ImRect, ptr %OuterRect344, i32 0, i32 1
  %y346 = getelementptr inbounds %struct.ImVec2, ptr %Max345, i32 0, i32 1
  %303 = load float, ptr %y346, align 4
  %304 = load float, ptr %inner_content_max_y, align 4
  %call347 = call noundef float @_ZL5ImMinIfET_S0_S0_(float noundef %303, float noundef %304)
  %call348 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %301, float noundef %call347)
  %305 = load ptr, ptr %outer_window, align 8
  %DC349 = getelementptr inbounds %struct.ImGuiWindow, ptr %305, i32 0, i32 68
  %CursorMaxPos350 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC349, i32 0, i32 3
  %y351 = getelementptr inbounds %struct.ImVec2, ptr %CursorMaxPos350, i32 0, i32 1
  store float %call348, ptr %y351, align 4
  br label %if.end361

if.else352:                                       ; preds = %if.end317
  %y353 = getelementptr inbounds %struct.ImVec2, ptr %backup_outer_max_pos, i32 0, i32 1
  %306 = load float, ptr %y353, align 4
  %307 = load ptr, ptr %table, align 8
  %OuterRect354 = getelementptr inbounds %struct.ImGuiTable, ptr %307, i32 0, i32 46
  %Max355 = getelementptr inbounds %struct.ImRect, ptr %OuterRect354, i32 0, i32 1
  %y356 = getelementptr inbounds %struct.ImVec2, ptr %Max355, i32 0, i32 1
  %308 = load float, ptr %y356, align 4
  %call357 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %306, float noundef %308)
  %309 = load ptr, ptr %outer_window, align 8
  %DC358 = getelementptr inbounds %struct.ImGuiWindow, ptr %309, i32 0, i32 68
  %CursorMaxPos359 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC358, i32 0, i32 3
  %y360 = getelementptr inbounds %struct.ImVec2, ptr %CursorMaxPos359, i32 0, i32 1
  store float %call357, ptr %y360, align 4
  br label %if.end361

if.end361:                                        ; preds = %if.else352, %cond.end330
  %310 = load ptr, ptr %table, align 8
  %IsSettingsDirty = getelementptr inbounds %struct.ImGuiTable, ptr %310, i32 0, i32 100
  %311 = load i8, ptr %IsSettingsDirty, align 2
  %tobool362 = trunc i8 %311 to i1
  br i1 %tobool362, label %if.then363, label %if.end364

if.then363:                                       ; preds = %if.end361
  %312 = load ptr, ptr %table, align 8
  call void @_ZN5ImGui17TableSaveSettingsEP10ImGuiTable(ptr noundef %312)
  br label %if.end364

if.end364:                                        ; preds = %if.then363, %if.end361
  %313 = load ptr, ptr %table, align 8
  %IsInitializing = getelementptr inbounds %struct.ImGuiTable, ptr %313, i32 0, i32 94
  store i8 0, ptr %IsInitializing, align 8
  %314 = load ptr, ptr %g, align 8
  %TablesTempDataStacked = getelementptr inbounds %struct.ImGuiContext, ptr %314, i32 0, i32 165
  %315 = load i32, ptr %TablesTempDataStacked, align 8
  %dec = add nsw i32 %315, -1
  store i32 %dec, ptr %TablesTempDataStacked, align 8
  %cmp365 = icmp sgt i32 %dec, 0
  br i1 %cmp365, label %cond.true366, label %cond.false370

cond.true366:                                     ; preds = %if.end364
  %316 = load ptr, ptr %g, align 8
  %TablesTempData = getelementptr inbounds %struct.ImGuiContext, ptr %316, i32 0, i32 166
  %317 = load ptr, ptr %g, align 8
  %TablesTempDataStacked367 = getelementptr inbounds %struct.ImGuiContext, ptr %317, i32 0, i32 165
  %318 = load i32, ptr %TablesTempDataStacked367, align 8
  %sub368 = sub nsw i32 %318, 1
  %call369 = call noundef nonnull align 8 dereferenceable(116) ptr @_ZN8ImVectorI18ImGuiTableTempDataEixEi(ptr noundef nonnull align 8 dereferenceable(16) %TablesTempData, i32 noundef %sub368)
  br label %cond.end371

cond.false370:                                    ; preds = %if.end364
  br label %cond.end371

cond.end371:                                      ; preds = %cond.false370, %cond.true366
  %cond372 = phi ptr [ %call369, %cond.true366 ], [ null, %cond.false370 ]
  store ptr %cond372, ptr %temp_data, align 8
  %319 = load ptr, ptr %temp_data, align 8
  %tobool373 = icmp ne ptr %319, null
  br i1 %tobool373, label %cond.true374, label %cond.false376

cond.true374:                                     ; preds = %cond.end371
  %320 = load ptr, ptr %g, align 8
  %Tables = getelementptr inbounds %struct.ImGuiContext, ptr %320, i32 0, i32 167
  %321 = load ptr, ptr %temp_data, align 8
  %TableIndex = getelementptr inbounds %struct.ImGuiTableTempData, ptr %321, i32 0, i32 0
  %322 = load i32, ptr %TableIndex, align 8
  %call375 = call noundef ptr @_ZN6ImPoolI10ImGuiTableE10GetByIndexEi(ptr noundef nonnull align 8 dereferenceable(40) %Tables, i32 noundef %322)
  br label %cond.end377

cond.false376:                                    ; preds = %cond.end371
  br label %cond.end377

cond.end377:                                      ; preds = %cond.false376, %cond.true374
  %cond378 = phi ptr [ %call375, %cond.true374 ], [ null, %cond.false376 ]
  %323 = load ptr, ptr %g, align 8
  %CurrentTable379 = getelementptr inbounds %struct.ImGuiContext, ptr %323, i32 0, i32 164
  store ptr %cond378, ptr %CurrentTable379, align 8
  %324 = load ptr, ptr %g, align 8
  %CurrentTable380 = getelementptr inbounds %struct.ImGuiContext, ptr %324, i32 0, i32 164
  %325 = load ptr, ptr %CurrentTable380, align 8
  %tobool381 = icmp ne ptr %325, null
  br i1 %tobool381, label %if.then382, label %if.end388

if.then382:                                       ; preds = %cond.end377
  %326 = load ptr, ptr %temp_data, align 8
  %327 = load ptr, ptr %g, align 8
  %CurrentTable383 = getelementptr inbounds %struct.ImGuiContext, ptr %327, i32 0, i32 164
  %328 = load ptr, ptr %CurrentTable383, align 8
  %TempData384 = getelementptr inbounds %struct.ImGuiTable, ptr %328, i32 0, i32 3
  store ptr %326, ptr %TempData384, align 8
  %329 = load ptr, ptr %temp_data, align 8
  %DrawSplitter385 = getelementptr inbounds %struct.ImGuiTableTempData, ptr %329, i32 0, i32 5
  %330 = load ptr, ptr %g, align 8
  %CurrentTable386 = getelementptr inbounds %struct.ImGuiContext, ptr %330, i32 0, i32 164
  %331 = load ptr, ptr %CurrentTable386, align 8
  %DrawSplitter387 = getelementptr inbounds %struct.ImGuiTable, ptr %331, i32 0, i32 58
  store ptr %DrawSplitter385, ptr %DrawSplitter387, align 8
  br label %if.end388

if.end388:                                        ; preds = %if.then382, %cond.end377
  %332 = load ptr, ptr %g, align 8
  %CurrentTable389 = getelementptr inbounds %struct.ImGuiContext, ptr %332, i32 0, i32 164
  %333 = load ptr, ptr %CurrentTable389, align 8
  %tobool390 = icmp ne ptr %333, null
  br i1 %tobool390, label %cond.true391, label %cond.false395

cond.true391:                                     ; preds = %if.end388
  %334 = load ptr, ptr %g, align 8
  %Tables392 = getelementptr inbounds %struct.ImGuiContext, ptr %334, i32 0, i32 167
  %335 = load ptr, ptr %g, align 8
  %CurrentTable393 = getelementptr inbounds %struct.ImGuiContext, ptr %335, i32 0, i32 164
  %336 = load ptr, ptr %CurrentTable393, align 8
  %call394 = call noundef i32 @_ZNK6ImPoolI10ImGuiTableE8GetIndexEPKS0_(ptr noundef nonnull align 8 dereferenceable(40) %Tables392, ptr noundef %336)
  br label %cond.end396

cond.false395:                                    ; preds = %if.end388
  br label %cond.end396

cond.end396:                                      ; preds = %cond.false395, %cond.true391
  %cond397 = phi i32 [ %call394, %cond.true391 ], [ -1, %cond.false395 ]
  %337 = load ptr, ptr %outer_window, align 8
  %DC398 = getelementptr inbounds %struct.ImGuiWindow, ptr %337, i32 0, i32 68
  %CurrentTableIdx = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC398, i32 0, i32 29
  store i32 %cond397, ptr %CurrentTableIdx, align 8
  call void @_ZN5ImGui39NavUpdateCurrentWindowIsScrollPushableXEv()
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui11TableEndRowEP10ImGuiTable(ptr noundef %table) #2 {
entry:
  %table.addr = alloca ptr, align 8
  %g = alloca ptr, align 8
  %window = alloca ptr, align 8
  %bg_y1 = alloca float, align 4
  %bg_y2 = alloca float, align 4
  %unfreeze_rows_actual = alloca i8, align 1
  %unfreeze_rows_request = alloca i8, align 1
  %table_instance = alloca ptr, align 8
  %is_visible = alloca i8, align 1
  %bg_col0 = alloca i32, align 4
  %bg_col1 = alloca i32, align 4
  %top_border_col = alloca i32, align 4
  %border_size = alloca float, align 4
  %draw_cell_bg_color = alloca i8, align 1
  %draw_strong_bottom_border = alloca i8, align 1
  %ref.tmp = alloca %struct.ImVec4, align 4
  %row_rect = alloca %struct.ImRect, align 4
  %cell_data_end = alloca ptr, align 8
  %cell_data = alloca ptr, align 8
  %column = alloca ptr, align 8
  %cell_bg_rect = alloca %struct.ImRect, align 4
  %ref.tmp172 = alloca %struct.ImVec2, align 4
  %ref.tmp173 = alloca %struct.ImVec2, align 4
  %ref.tmp188 = alloca %struct.ImVec2, align 4
  %ref.tmp190 = alloca %struct.ImVec2, align 4
  %column_n = alloca i32, align 4
  %y0 = alloca float, align 4
  %row_height = alloca float, align 4
  %column_n253 = alloca i32, align 4
  %column258 = alloca ptr, align 8
  store ptr %table, ptr %table.addr, align 8
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %g, align 8
  %CurrentWindow = getelementptr inbounds %struct.ImGuiContext, ptr %1, i32 0, i32 29
  %2 = load ptr, ptr %CurrentWindow, align 8
  store ptr %2, ptr %window, align 8
  %3 = load ptr, ptr %table.addr, align 8
  %CurrentColumn = getelementptr inbounds %struct.ImGuiTable, ptr %3, i32 0, i32 15
  %4 = load i32, ptr %CurrentColumn, align 4
  %cmp = icmp ne i32 %4, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load ptr, ptr %table.addr, align 8
  call void @_ZN5ImGui12TableEndCellEP10ImGuiTable(ptr noundef %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load ptr, ptr %g, align 8
  %LogEnabled = getelementptr inbounds %struct.ImGuiContext, ptr %6, i32 0, i32 222
  %7 = load i8, ptr %LogEnabled, align 8
  %tobool = trunc i8 %7 to i1
  br i1 %tobool, label %if.then1, label %if.end2

if.then1:                                         ; preds = %if.end
  call void @_ZN5ImGui15LogRenderedTextEPK6ImVec2PKcS4_(ptr noundef null, ptr noundef @.str.2, ptr noundef null)
  br label %if.end2

if.end2:                                          ; preds = %if.then1, %if.end
  %8 = load ptr, ptr %table.addr, align 8
  %RowPosY2 = getelementptr inbounds %struct.ImGuiTable, ptr %8, i32 0, i32 19
  %9 = load float, ptr %RowPosY2, align 8
  %10 = load ptr, ptr %window, align 8
  %DC = getelementptr inbounds %struct.ImGuiWindow, ptr %10, i32 0, i32 68
  %CursorPos = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC, i32 0, i32 0
  %y = getelementptr inbounds %struct.ImVec2, ptr %CursorPos, i32 0, i32 1
  store float %9, ptr %y, align 4
  %11 = load ptr, ptr %table.addr, align 8
  %RowPosY1 = getelementptr inbounds %struct.ImGuiTable, ptr %11, i32 0, i32 18
  %12 = load float, ptr %RowPosY1, align 4
  store float %12, ptr %bg_y1, align 4
  %13 = load ptr, ptr %table.addr, align 8
  %RowPosY23 = getelementptr inbounds %struct.ImGuiTable, ptr %13, i32 0, i32 19
  %14 = load float, ptr %RowPosY23, align 8
  store float %14, ptr %bg_y2, align 4
  %15 = load ptr, ptr %table.addr, align 8
  %CurrentRow = getelementptr inbounds %struct.ImGuiTable, ptr %15, i32 0, i32 14
  %16 = load i32, ptr %CurrentRow, align 8
  %add = add nsw i32 %16, 1
  %17 = load ptr, ptr %table.addr, align 8
  %FreezeRowsCount = getelementptr inbounds %struct.ImGuiTable, ptr %17, i32 0, i32 85
  %18 = load i16, ptr %FreezeRowsCount, align 8
  %conv = sext i16 %18 to i32
  %cmp4 = icmp eq i32 %add, %conv
  %frombool = zext i1 %cmp4 to i8
  store i8 %frombool, ptr %unfreeze_rows_actual, align 1
  %19 = load ptr, ptr %table.addr, align 8
  %CurrentRow5 = getelementptr inbounds %struct.ImGuiTable, ptr %19, i32 0, i32 14
  %20 = load i32, ptr %CurrentRow5, align 8
  %add6 = add nsw i32 %20, 1
  %21 = load ptr, ptr %table.addr, align 8
  %FreezeRowsRequest = getelementptr inbounds %struct.ImGuiTable, ptr %21, i32 0, i32 84
  %22 = load i16, ptr %FreezeRowsRequest, align 2
  %conv7 = sext i16 %22 to i32
  %cmp8 = icmp eq i32 %add6, %conv7
  %frombool9 = zext i1 %cmp8 to i8
  store i8 %frombool9, ptr %unfreeze_rows_request, align 1
  %23 = load ptr, ptr %table.addr, align 8
  %24 = load ptr, ptr %table.addr, align 8
  %InstanceCurrent = getelementptr inbounds %struct.ImGuiTable, ptr %24, i32 0, i32 16
  %25 = load i16, ptr %InstanceCurrent, align 8
  %conv10 = sext i16 %25 to i32
  %call = call noundef ptr @_ZN5ImGui20TableGetInstanceDataEP10ImGuiTablei(ptr noundef %23, i32 noundef %conv10)
  store ptr %call, ptr %table_instance, align 8
  %26 = load ptr, ptr %table.addr, align 8
  %RowFlags = getelementptr inbounds %struct.ImGuiTable, ptr %26, i32 0, i32 24
  %bf.load = load i32, ptr %RowFlags, align 4
  %bf.shl = shl i32 %bf.load, 16
  %bf.ashr = ashr i32 %bf.shl, 16
  %and = and i32 %bf.ashr, 1
  %tobool11 = icmp ne i32 %and, 0
  br i1 %tobool11, label %land.lhs.true, label %if.end20

land.lhs.true:                                    ; preds = %if.end2
  %27 = load ptr, ptr %table.addr, align 8
  %CurrentRow12 = getelementptr inbounds %struct.ImGuiTable, ptr %27, i32 0, i32 14
  %28 = load i32, ptr %CurrentRow12, align 8
  %cmp13 = icmp eq i32 %28, 0
  br i1 %cmp13, label %if.then18, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %29 = load ptr, ptr %table.addr, align 8
  %LastRowFlags = getelementptr inbounds %struct.ImGuiTable, ptr %29, i32 0, i32 24
  %bf.load14 = load i32, ptr %LastRowFlags, align 4
  %bf.ashr15 = ashr i32 %bf.load14, 16
  %and16 = and i32 %bf.ashr15, 1
  %tobool17 = icmp ne i32 %and16, 0
  br i1 %tobool17, label %if.then18, label %if.end20

if.then18:                                        ; preds = %lor.lhs.false, %land.lhs.true
  %30 = load float, ptr %bg_y2, align 4
  %31 = load float, ptr %bg_y1, align 4
  %sub = fsub float %30, %31
  %32 = load ptr, ptr %table_instance, align 8
  %LastTopHeadersRowHeight = getelementptr inbounds %struct.ImGuiTableInstanceData, ptr %32, i32 0, i32 2
  %33 = load float, ptr %LastTopHeadersRowHeight, align 4
  %add19 = fadd float %33, %sub
  store float %add19, ptr %LastTopHeadersRowHeight, align 4
  br label %if.end20

if.end20:                                         ; preds = %if.then18, %lor.lhs.false, %if.end2
  %34 = load float, ptr %bg_y2, align 4
  %35 = load ptr, ptr %table.addr, align 8
  %InnerClipRect = getelementptr inbounds %struct.ImGuiTable, ptr %35, i32 0, i32 49
  %Min = getelementptr inbounds %struct.ImRect, ptr %InnerClipRect, i32 0, i32 0
  %y21 = getelementptr inbounds %struct.ImVec2, ptr %Min, i32 0, i32 1
  %36 = load float, ptr %y21, align 4
  %cmp22 = fcmp oge float %34, %36
  br i1 %cmp22, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end20
  %37 = load float, ptr %bg_y1, align 4
  %38 = load ptr, ptr %table.addr, align 8
  %InnerClipRect23 = getelementptr inbounds %struct.ImGuiTable, ptr %38, i32 0, i32 49
  %Max = getelementptr inbounds %struct.ImRect, ptr %InnerClipRect23, i32 0, i32 1
  %y24 = getelementptr inbounds %struct.ImVec2, ptr %Max, i32 0, i32 1
  %39 = load float, ptr %y24, align 4
  %cmp25 = fcmp ole float %37, %39
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end20
  %40 = phi i1 [ false, %if.end20 ], [ %cmp25, %land.rhs ]
  %frombool26 = zext i1 %40 to i8
  store i8 %frombool26, ptr %is_visible, align 1
  %41 = load i8, ptr %is_visible, align 1
  %tobool27 = trunc i8 %41 to i1
  br i1 %tobool27, label %if.then28, label %if.end194

if.then28:                                        ; preds = %land.end
  %42 = load ptr, ptr %table.addr, align 8
  %HoveredColumnBody = getelementptr inbounds %struct.ImGuiTable, ptr %42, i32 0, i32 70
  %43 = load i16, ptr %HoveredColumnBody, align 2
  %conv29 = sext i16 %43 to i32
  %cmp30 = icmp ne i32 %conv29, -1
  br i1 %cmp30, label %land.lhs.true31, label %if.end41

land.lhs.true31:                                  ; preds = %if.then28
  %44 = load ptr, ptr %g, align 8
  %IO = getelementptr inbounds %struct.ImGuiContext, ptr %44, i32 0, i32 2
  %MousePos = getelementptr inbounds %struct.ImGuiIO, ptr %IO, i32 0, i32 59
  %y32 = getelementptr inbounds %struct.ImVec2, ptr %MousePos, i32 0, i32 1
  %45 = load float, ptr %y32, align 4
  %46 = load float, ptr %bg_y1, align 4
  %cmp33 = fcmp oge float %45, %46
  br i1 %cmp33, label %land.lhs.true34, label %if.end41

land.lhs.true34:                                  ; preds = %land.lhs.true31
  %47 = load ptr, ptr %g, align 8
  %IO35 = getelementptr inbounds %struct.ImGuiContext, ptr %47, i32 0, i32 2
  %MousePos36 = getelementptr inbounds %struct.ImGuiIO, ptr %IO35, i32 0, i32 59
  %y37 = getelementptr inbounds %struct.ImVec2, ptr %MousePos36, i32 0, i32 1
  %48 = load float, ptr %y37, align 4
  %49 = load float, ptr %bg_y2, align 4
  %cmp38 = fcmp olt float %48, %49
  br i1 %cmp38, label %if.then39, label %if.end41

if.then39:                                        ; preds = %land.lhs.true34
  %50 = load ptr, ptr %table.addr, align 8
  %CurrentRow40 = getelementptr inbounds %struct.ImGuiTable, ptr %50, i32 0, i32 14
  %51 = load i32, ptr %CurrentRow40, align 8
  %52 = load ptr, ptr %table_instance, align 8
  %HoveredRowNext = getelementptr inbounds %struct.ImGuiTableInstanceData, ptr %52, i32 0, i32 5
  store i32 %51, ptr %HoveredRowNext, align 4
  br label %if.end41

if.end41:                                         ; preds = %if.then39, %land.lhs.true34, %land.lhs.true31, %if.then28
  store i32 0, ptr %bg_col0, align 4
  store i32 0, ptr %bg_col1, align 4
  %53 = load ptr, ptr %table.addr, align 8
  %RowBgColor = getelementptr inbounds %struct.ImGuiTable, ptr %53, i32 0, i32 26
  %arrayidx = getelementptr inbounds [2 x i32], ptr %RowBgColor, i64 0, i64 0
  %54 = load i32, ptr %arrayidx, align 4
  %cmp42 = icmp ne i32 %54, 16777216
  br i1 %cmp42, label %if.then43, label %if.else

if.then43:                                        ; preds = %if.end41
  %55 = load ptr, ptr %table.addr, align 8
  %RowBgColor44 = getelementptr inbounds %struct.ImGuiTable, ptr %55, i32 0, i32 26
  %arrayidx45 = getelementptr inbounds [2 x i32], ptr %RowBgColor44, i64 0, i64 0
  %56 = load i32, ptr %arrayidx45, align 4
  store i32 %56, ptr %bg_col0, align 4
  br label %if.end53

if.else:                                          ; preds = %if.end41
  %57 = load ptr, ptr %table.addr, align 8
  %Flags = getelementptr inbounds %struct.ImGuiTable, ptr %57, i32 0, i32 1
  %58 = load i32, ptr %Flags, align 4
  %and46 = and i32 %58, 64
  %tobool47 = icmp ne i32 %and46, 0
  br i1 %tobool47, label %if.then48, label %if.end52

if.then48:                                        ; preds = %if.else
  %59 = load ptr, ptr %table.addr, align 8
  %RowBgColorCounter = getelementptr inbounds %struct.ImGuiTable, ptr %59, i32 0, i32 25
  %60 = load i32, ptr %RowBgColorCounter, align 8
  %and49 = and i32 %60, 1
  %tobool50 = icmp ne i32 %and49, 0
  %cond = select i1 %tobool50, i32 46, i32 45
  %call51 = call noundef i32 @_ZN5ImGui11GetColorU32Eif(i32 noundef %cond, float noundef 1.000000e+00)
  store i32 %call51, ptr %bg_col0, align 4
  br label %if.end52

if.end52:                                         ; preds = %if.then48, %if.else
  br label %if.end53

if.end53:                                         ; preds = %if.end52, %if.then43
  %61 = load ptr, ptr %table.addr, align 8
  %RowBgColor54 = getelementptr inbounds %struct.ImGuiTable, ptr %61, i32 0, i32 26
  %arrayidx55 = getelementptr inbounds [2 x i32], ptr %RowBgColor54, i64 0, i64 1
  %62 = load i32, ptr %arrayidx55, align 4
  %cmp56 = icmp ne i32 %62, 16777216
  br i1 %cmp56, label %if.then57, label %if.end60

if.then57:                                        ; preds = %if.end53
  %63 = load ptr, ptr %table.addr, align 8
  %RowBgColor58 = getelementptr inbounds %struct.ImGuiTable, ptr %63, i32 0, i32 26
  %arrayidx59 = getelementptr inbounds [2 x i32], ptr %RowBgColor58, i64 0, i64 1
  %64 = load i32, ptr %arrayidx59, align 4
  store i32 %64, ptr %bg_col1, align 4
  br label %if.end60

if.end60:                                         ; preds = %if.then57, %if.end53
  store i32 0, ptr %top_border_col, align 4
  store float 1.000000e+00, ptr %border_size, align 4
  %65 = load ptr, ptr %table.addr, align 8
  %CurrentRow61 = getelementptr inbounds %struct.ImGuiTable, ptr %65, i32 0, i32 14
  %66 = load i32, ptr %CurrentRow61, align 8
  %cmp62 = icmp sgt i32 %66, 0
  br i1 %cmp62, label %land.lhs.true63, label %if.end74

land.lhs.true63:                                  ; preds = %if.end60
  %67 = load ptr, ptr %table.addr, align 8
  %Flags64 = getelementptr inbounds %struct.ImGuiTable, ptr %67, i32 0, i32 1
  %68 = load i32, ptr %Flags64, align 4
  %and65 = and i32 %68, 128
  %tobool66 = icmp ne i32 %and65, 0
  br i1 %tobool66, label %if.then67, label %if.end74

if.then67:                                        ; preds = %land.lhs.true63
  %69 = load ptr, ptr %table.addr, align 8
  %LastRowFlags68 = getelementptr inbounds %struct.ImGuiTable, ptr %69, i32 0, i32 24
  %bf.load69 = load i32, ptr %LastRowFlags68, align 4
  %bf.ashr70 = ashr i32 %bf.load69, 16
  %and71 = and i32 %bf.ashr70, 1
  %tobool72 = icmp ne i32 %and71, 0
  br i1 %tobool72, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then67
  %70 = load ptr, ptr %table.addr, align 8
  %BorderColorStrong = getelementptr inbounds %struct.ImGuiTable, ptr %70, i32 0, i32 27
  %71 = load i32, ptr %BorderColorStrong, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.then67
  %72 = load ptr, ptr %table.addr, align 8
  %BorderColorLight = getelementptr inbounds %struct.ImGuiTable, ptr %72, i32 0, i32 28
  %73 = load i32, ptr %BorderColorLight, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond73 = phi i32 [ %71, %cond.true ], [ %73, %cond.false ]
  store i32 %cond73, ptr %top_border_col, align 4
  br label %if.end74

if.end74:                                         ; preds = %cond.end, %land.lhs.true63, %if.end60
  %74 = load ptr, ptr %table.addr, align 8
  %RowCellDataCurrent = getelementptr inbounds %struct.ImGuiTable, ptr %74, i32 0, i32 88
  %75 = load i16, ptr %RowCellDataCurrent, align 2
  %conv75 = sext i16 %75 to i32
  %cmp76 = icmp sge i32 %conv75, 0
  %frombool77 = zext i1 %cmp76 to i8
  store i8 %frombool77, ptr %draw_cell_bg_color, align 1
  %76 = load i8, ptr %unfreeze_rows_actual, align 1
  %tobool78 = trunc i8 %76 to i1
  %frombool79 = zext i1 %tobool78 to i8
  store i8 %frombool79, ptr %draw_strong_bottom_border, align 1
  %77 = load i32, ptr %bg_col0, align 4
  %78 = load i32, ptr %bg_col1, align 4
  %or = or i32 %77, %78
  %79 = load i32, ptr %top_border_col, align 4
  %or80 = or i32 %or, %79
  %cmp81 = icmp ne i32 %or80, 0
  br i1 %cmp81, label %if.then86, label %lor.lhs.false82

lor.lhs.false82:                                  ; preds = %if.end74
  %80 = load i8, ptr %draw_strong_bottom_border, align 1
  %tobool83 = trunc i8 %80 to i1
  br i1 %tobool83, label %if.then86, label %lor.lhs.false84

lor.lhs.false84:                                  ; preds = %lor.lhs.false82
  %81 = load i8, ptr %draw_cell_bg_color, align 1
  %tobool85 = trunc i8 %81 to i1
  br i1 %tobool85, label %if.then86, label %if.end94

if.then86:                                        ; preds = %lor.lhs.false84, %lor.lhs.false82, %if.end74
  %82 = load ptr, ptr %table.addr, align 8
  %Flags87 = getelementptr inbounds %struct.ImGuiTable, ptr %82, i32 0, i32 1
  %83 = load i32, ptr %Flags87, align 4
  %and88 = and i32 %83, 1048576
  %cmp89 = icmp eq i32 %and88, 0
  br i1 %cmp89, label %if.then90, label %if.end92

if.then90:                                        ; preds = %if.then86
  %84 = load ptr, ptr %table.addr, align 8
  %Bg0ClipRectForDrawCmd = getelementptr inbounds %struct.ImGuiTable, ptr %84, i32 0, i32 51
  %call91 = call { <2 x float>, <2 x float> } @_ZNK6ImRect6ToVec4Ev(ptr noundef nonnull align 4 dereferenceable(16) %Bg0ClipRectForDrawCmd)
  %85 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %ref.tmp, i32 0, i32 0
  %86 = extractvalue { <2 x float>, <2 x float> } %call91, 0
  store <2 x float> %86, ptr %85, align 4
  %87 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %ref.tmp, i32 0, i32 1
  %88 = extractvalue { <2 x float>, <2 x float> } %call91, 1
  store <2 x float> %88, ptr %87, align 4
  %89 = load ptr, ptr %window, align 8
  %DrawList = getelementptr inbounds %struct.ImGuiWindow, ptr %89, i32 0, i32 86
  %90 = load ptr, ptr %DrawList, align 8
  %_CmdHeader = getelementptr inbounds %struct.ImDrawList, ptr %90, i32 0, i32 12
  %ClipRect = getelementptr inbounds %struct.ImDrawCmdHeader, ptr %_CmdHeader, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %ClipRect, ptr align 4 %ref.tmp, i64 16, i1 false)
  br label %if.end92

if.end92:                                         ; preds = %if.then90, %if.then86
  %91 = load ptr, ptr %table.addr, align 8
  %DrawSplitter = getelementptr inbounds %struct.ImGuiTable, ptr %91, i32 0, i32 58
  %92 = load ptr, ptr %DrawSplitter, align 8
  %93 = load ptr, ptr %window, align 8
  %DrawList93 = getelementptr inbounds %struct.ImGuiWindow, ptr %93, i32 0, i32 86
  %94 = load ptr, ptr %DrawList93, align 8
  call void @_ZN18ImDrawListSplitter17SetCurrentChannelEP10ImDrawListi(ptr noundef nonnull align 8 dereferenceable(24) %92, ptr noundef %94, i32 noundef 0)
  br label %if.end94

if.end94:                                         ; preds = %if.end92, %lor.lhs.false84
  %95 = load i32, ptr %bg_col0, align 4
  %tobool95 = icmp ne i32 %95, 0
  br i1 %tobool95, label %if.then98, label %lor.lhs.false96

lor.lhs.false96:                                  ; preds = %if.end94
  %96 = load i32, ptr %bg_col1, align 4
  %tobool97 = icmp ne i32 %96, 0
  br i1 %tobool97, label %if.then98, label %if.end127

if.then98:                                        ; preds = %lor.lhs.false96, %if.end94
  %97 = load ptr, ptr %table.addr, align 8
  %WorkRect = getelementptr inbounds %struct.ImGuiTable, ptr %97, i32 0, i32 48
  %Min99 = getelementptr inbounds %struct.ImRect, ptr %WorkRect, i32 0, i32 0
  %x = getelementptr inbounds %struct.ImVec2, ptr %Min99, i32 0, i32 0
  %98 = load float, ptr %x, align 8
  %99 = load float, ptr %bg_y1, align 4
  %100 = load ptr, ptr %table.addr, align 8
  %WorkRect100 = getelementptr inbounds %struct.ImGuiTable, ptr %100, i32 0, i32 48
  %Max101 = getelementptr inbounds %struct.ImRect, ptr %WorkRect100, i32 0, i32 1
  %x102 = getelementptr inbounds %struct.ImVec2, ptr %Max101, i32 0, i32 0
  %101 = load float, ptr %x102, align 8
  %102 = load float, ptr %bg_y2, align 4
  call void @_ZN6ImRectC2Effff(ptr noundef nonnull align 4 dereferenceable(16) %row_rect, float noundef %98, float noundef %99, float noundef %101, float noundef %102)
  %103 = load ptr, ptr %table.addr, align 8
  %BgClipRect = getelementptr inbounds %struct.ImGuiTable, ptr %103, i32 0, i32 50
  call void @_ZN6ImRect8ClipWithERKS_(ptr noundef nonnull align 4 dereferenceable(16) %row_rect, ptr noundef nonnull align 4 dereferenceable(16) %BgClipRect)
  %104 = load i32, ptr %bg_col0, align 4
  %cmp103 = icmp ne i32 %104, 0
  br i1 %cmp103, label %land.lhs.true104, label %if.end114

land.lhs.true104:                                 ; preds = %if.then98
  %Min105 = getelementptr inbounds %struct.ImRect, ptr %row_rect, i32 0, i32 0
  %y106 = getelementptr inbounds %struct.ImVec2, ptr %Min105, i32 0, i32 1
  %105 = load float, ptr %y106, align 4
  %Max107 = getelementptr inbounds %struct.ImRect, ptr %row_rect, i32 0, i32 1
  %y108 = getelementptr inbounds %struct.ImVec2, ptr %Max107, i32 0, i32 1
  %106 = load float, ptr %y108, align 4
  %cmp109 = fcmp olt float %105, %106
  br i1 %cmp109, label %if.then110, label %if.end114

if.then110:                                       ; preds = %land.lhs.true104
  %107 = load ptr, ptr %window, align 8
  %DrawList111 = getelementptr inbounds %struct.ImGuiWindow, ptr %107, i32 0, i32 86
  %108 = load ptr, ptr %DrawList111, align 8
  %Min112 = getelementptr inbounds %struct.ImRect, ptr %row_rect, i32 0, i32 0
  %Max113 = getelementptr inbounds %struct.ImRect, ptr %row_rect, i32 0, i32 1
  %109 = load i32, ptr %bg_col0, align 4
  call void @_ZN10ImDrawList13AddRectFilledERK6ImVec2S2_jfi(ptr noundef nonnull align 8 dereferenceable(196) %108, ptr noundef nonnull align 4 dereferenceable(8) %Min112, ptr noundef nonnull align 4 dereferenceable(8) %Max113, i32 noundef %109, float noundef 0.000000e+00, i32 noundef 0)
  br label %if.end114

if.end114:                                        ; preds = %if.then110, %land.lhs.true104, %if.then98
  %110 = load i32, ptr %bg_col1, align 4
  %cmp115 = icmp ne i32 %110, 0
  br i1 %cmp115, label %land.lhs.true116, label %if.end126

land.lhs.true116:                                 ; preds = %if.end114
  %Min117 = getelementptr inbounds %struct.ImRect, ptr %row_rect, i32 0, i32 0
  %y118 = getelementptr inbounds %struct.ImVec2, ptr %Min117, i32 0, i32 1
  %111 = load float, ptr %y118, align 4
  %Max119 = getelementptr inbounds %struct.ImRect, ptr %row_rect, i32 0, i32 1
  %y120 = getelementptr inbounds %struct.ImVec2, ptr %Max119, i32 0, i32 1
  %112 = load float, ptr %y120, align 4
  %cmp121 = fcmp olt float %111, %112
  br i1 %cmp121, label %if.then122, label %if.end126

if.then122:                                       ; preds = %land.lhs.true116
  %113 = load ptr, ptr %window, align 8
  %DrawList123 = getelementptr inbounds %struct.ImGuiWindow, ptr %113, i32 0, i32 86
  %114 = load ptr, ptr %DrawList123, align 8
  %Min124 = getelementptr inbounds %struct.ImRect, ptr %row_rect, i32 0, i32 0
  %Max125 = getelementptr inbounds %struct.ImRect, ptr %row_rect, i32 0, i32 1
  %115 = load i32, ptr %bg_col1, align 4
  call void @_ZN10ImDrawList13AddRectFilledERK6ImVec2S2_jfi(ptr noundef nonnull align 8 dereferenceable(196) %114, ptr noundef nonnull align 4 dereferenceable(8) %Min124, ptr noundef nonnull align 4 dereferenceable(8) %Max125, i32 noundef %115, float noundef 0.000000e+00, i32 noundef 0)
  br label %if.end126

if.end126:                                        ; preds = %if.then122, %land.lhs.true116, %if.end114
  br label %if.end127

if.end127:                                        ; preds = %if.end126, %lor.lhs.false96
  %116 = load i8, ptr %draw_cell_bg_color, align 1
  %tobool128 = trunc i8 %116 to i1
  br i1 %tobool128, label %if.then129, label %if.end158

if.then129:                                       ; preds = %if.end127
  %117 = load ptr, ptr %table.addr, align 8
  %RowCellData = getelementptr inbounds %struct.ImGuiTable, ptr %117, i32 0, i32 6
  %118 = load ptr, ptr %table.addr, align 8
  %RowCellDataCurrent130 = getelementptr inbounds %struct.ImGuiTable, ptr %118, i32 0, i32 88
  %119 = load i16, ptr %RowCellDataCurrent130, align 2
  %conv131 = sext i16 %119 to i32
  %call132 = call noundef nonnull align 4 dereferenceable(8) ptr @_ZN6ImSpanI18ImGuiTableCellDataEixEi(ptr noundef nonnull align 8 dereferenceable(16) %RowCellData, i32 noundef %conv131)
  store ptr %call132, ptr %cell_data_end, align 8
  %120 = load ptr, ptr %table.addr, align 8
  %RowCellData133 = getelementptr inbounds %struct.ImGuiTable, ptr %120, i32 0, i32 6
  %call134 = call noundef nonnull align 4 dereferenceable(8) ptr @_ZN6ImSpanI18ImGuiTableCellDataEixEi(ptr noundef nonnull align 8 dereferenceable(16) %RowCellData133, i32 noundef 0)
  store ptr %call134, ptr %cell_data, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then129
  %121 = load ptr, ptr %cell_data, align 8
  %122 = load ptr, ptr %cell_data_end, align 8
  %cmp135 = icmp ule ptr %121, %122
  br i1 %cmp135, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %123 = load ptr, ptr %table.addr, align 8
  %Columns = getelementptr inbounds %struct.ImGuiTable, ptr %123, i32 0, i32 4
  %124 = load ptr, ptr %cell_data, align 8
  %Column = getelementptr inbounds %struct.ImGuiTableCellData, ptr %124, i32 0, i32 1
  %125 = load i16, ptr %Column, align 4
  %conv136 = sext i16 %125 to i32
  %call137 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns, i32 noundef %conv136)
  store ptr %call137, ptr %column, align 8
  %126 = load ptr, ptr %table.addr, align 8
  %127 = load ptr, ptr %cell_data, align 8
  %Column138 = getelementptr inbounds %struct.ImGuiTableCellData, ptr %127, i32 0, i32 1
  %128 = load i16, ptr %Column138, align 4
  %conv139 = sext i16 %128 to i32
  %call140 = call { <2 x float>, <2 x float> } @_ZN5ImGui18TableGetCellBgRectEPK10ImGuiTablei(ptr noundef %126, i32 noundef %conv139)
  %129 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %cell_bg_rect, i32 0, i32 0
  %130 = extractvalue { <2 x float>, <2 x float> } %call140, 0
  store <2 x float> %130, ptr %129, align 4
  %131 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %cell_bg_rect, i32 0, i32 1
  %132 = extractvalue { <2 x float>, <2 x float> } %call140, 1
  store <2 x float> %132, ptr %131, align 4
  %133 = load ptr, ptr %table.addr, align 8
  %BgClipRect141 = getelementptr inbounds %struct.ImGuiTable, ptr %133, i32 0, i32 50
  call void @_ZN6ImRect8ClipWithERKS_(ptr noundef nonnull align 4 dereferenceable(16) %cell_bg_rect, ptr noundef nonnull align 4 dereferenceable(16) %BgClipRect141)
  %Min142 = getelementptr inbounds %struct.ImRect, ptr %cell_bg_rect, i32 0, i32 0
  %x143 = getelementptr inbounds %struct.ImVec2, ptr %Min142, i32 0, i32 0
  %134 = load float, ptr %x143, align 4
  %135 = load ptr, ptr %column, align 8
  %ClipRect144 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %135, i32 0, i32 8
  %Min145 = getelementptr inbounds %struct.ImRect, ptr %ClipRect144, i32 0, i32 0
  %x146 = getelementptr inbounds %struct.ImVec2, ptr %Min145, i32 0, i32 0
  %136 = load float, ptr %x146, align 4
  %call147 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %134, float noundef %136)
  %Min148 = getelementptr inbounds %struct.ImRect, ptr %cell_bg_rect, i32 0, i32 0
  %x149 = getelementptr inbounds %struct.ImVec2, ptr %Min148, i32 0, i32 0
  store float %call147, ptr %x149, align 4
  %Max150 = getelementptr inbounds %struct.ImRect, ptr %cell_bg_rect, i32 0, i32 1
  %x151 = getelementptr inbounds %struct.ImVec2, ptr %Max150, i32 0, i32 0
  %137 = load float, ptr %x151, align 4
  %138 = load ptr, ptr %column, align 8
  %MaxX = getelementptr inbounds %struct.ImGuiTableColumn, ptr %138, i32 0, i32 3
  %139 = load float, ptr %MaxX, align 4
  %call152 = call noundef float @_ZL5ImMinIfET_S0_S0_(float noundef %137, float noundef %139)
  %Max153 = getelementptr inbounds %struct.ImRect, ptr %cell_bg_rect, i32 0, i32 1
  %x154 = getelementptr inbounds %struct.ImVec2, ptr %Max153, i32 0, i32 0
  store float %call152, ptr %x154, align 4
  %140 = load ptr, ptr %window, align 8
  %DrawList155 = getelementptr inbounds %struct.ImGuiWindow, ptr %140, i32 0, i32 86
  %141 = load ptr, ptr %DrawList155, align 8
  %Min156 = getelementptr inbounds %struct.ImRect, ptr %cell_bg_rect, i32 0, i32 0
  %Max157 = getelementptr inbounds %struct.ImRect, ptr %cell_bg_rect, i32 0, i32 1
  %142 = load ptr, ptr %cell_data, align 8
  %BgColor = getelementptr inbounds %struct.ImGuiTableCellData, ptr %142, i32 0, i32 0
  %143 = load i32, ptr %BgColor, align 4
  call void @_ZN10ImDrawList13AddRectFilledERK6ImVec2S2_jfi(ptr noundef nonnull align 8 dereferenceable(196) %141, ptr noundef nonnull align 4 dereferenceable(8) %Min156, ptr noundef nonnull align 4 dereferenceable(8) %Max157, i32 noundef %143, float noundef 0.000000e+00, i32 noundef 0)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %144 = load ptr, ptr %cell_data, align 8
  %incdec.ptr = getelementptr inbounds %struct.ImGuiTableCellData, ptr %144, i32 1
  store ptr %incdec.ptr, ptr %cell_data, align 8
  br label %for.cond, !llvm.loop !26

for.end:                                          ; preds = %for.cond
  br label %if.end158

if.end158:                                        ; preds = %for.end, %if.end127
  %145 = load i32, ptr %top_border_col, align 4
  %tobool159 = icmp ne i32 %145, 0
  br i1 %tobool159, label %land.lhs.true160, label %if.end174

land.lhs.true160:                                 ; preds = %if.end158
  %146 = load float, ptr %bg_y1, align 4
  %147 = load ptr, ptr %table.addr, align 8
  %BgClipRect161 = getelementptr inbounds %struct.ImGuiTable, ptr %147, i32 0, i32 50
  %Min162 = getelementptr inbounds %struct.ImRect, ptr %BgClipRect161, i32 0, i32 0
  %y163 = getelementptr inbounds %struct.ImVec2, ptr %Min162, i32 0, i32 1
  %148 = load float, ptr %y163, align 4
  %cmp164 = fcmp oge float %146, %148
  br i1 %cmp164, label %land.lhs.true165, label %if.end174

land.lhs.true165:                                 ; preds = %land.lhs.true160
  %149 = load float, ptr %bg_y1, align 4
  %150 = load ptr, ptr %table.addr, align 8
  %BgClipRect166 = getelementptr inbounds %struct.ImGuiTable, ptr %150, i32 0, i32 50
  %Max167 = getelementptr inbounds %struct.ImRect, ptr %BgClipRect166, i32 0, i32 1
  %y168 = getelementptr inbounds %struct.ImVec2, ptr %Max167, i32 0, i32 1
  %151 = load float, ptr %y168, align 4
  %cmp169 = fcmp olt float %149, %151
  br i1 %cmp169, label %if.then170, label %if.end174

if.then170:                                       ; preds = %land.lhs.true165
  %152 = load ptr, ptr %window, align 8
  %DrawList171 = getelementptr inbounds %struct.ImGuiWindow, ptr %152, i32 0, i32 86
  %153 = load ptr, ptr %DrawList171, align 8
  %154 = load ptr, ptr %table.addr, align 8
  %BorderX1 = getelementptr inbounds %struct.ImGuiTable, ptr %154, i32 0, i32 29
  %155 = load float, ptr %BorderX1, align 4
  %156 = load float, ptr %bg_y1, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp172, float noundef %155, float noundef %156)
  %157 = load ptr, ptr %table.addr, align 8
  %BorderX2 = getelementptr inbounds %struct.ImGuiTable, ptr %157, i32 0, i32 30
  %158 = load float, ptr %BorderX2, align 8
  %159 = load float, ptr %bg_y1, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp173, float noundef %158, float noundef %159)
  %160 = load i32, ptr %top_border_col, align 4
  call void @_ZN10ImDrawList7AddLineERK6ImVec2S2_jf(ptr noundef nonnull align 8 dereferenceable(196) %153, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp172, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp173, i32 noundef %160, float noundef 1.000000e+00)
  br label %if.end174

if.end174:                                        ; preds = %if.then170, %land.lhs.true165, %land.lhs.true160, %if.end158
  %161 = load i8, ptr %draw_strong_bottom_border, align 1
  %tobool175 = trunc i8 %161 to i1
  br i1 %tobool175, label %land.lhs.true176, label %if.end193

land.lhs.true176:                                 ; preds = %if.end174
  %162 = load float, ptr %bg_y2, align 4
  %163 = load ptr, ptr %table.addr, align 8
  %BgClipRect177 = getelementptr inbounds %struct.ImGuiTable, ptr %163, i32 0, i32 50
  %Min178 = getelementptr inbounds %struct.ImRect, ptr %BgClipRect177, i32 0, i32 0
  %y179 = getelementptr inbounds %struct.ImVec2, ptr %Min178, i32 0, i32 1
  %164 = load float, ptr %y179, align 4
  %cmp180 = fcmp oge float %162, %164
  br i1 %cmp180, label %land.lhs.true181, label %if.end193

land.lhs.true181:                                 ; preds = %land.lhs.true176
  %165 = load float, ptr %bg_y2, align 4
  %166 = load ptr, ptr %table.addr, align 8
  %BgClipRect182 = getelementptr inbounds %struct.ImGuiTable, ptr %166, i32 0, i32 50
  %Max183 = getelementptr inbounds %struct.ImRect, ptr %BgClipRect182, i32 0, i32 1
  %y184 = getelementptr inbounds %struct.ImVec2, ptr %Max183, i32 0, i32 1
  %167 = load float, ptr %y184, align 4
  %cmp185 = fcmp olt float %165, %167
  br i1 %cmp185, label %if.then186, label %if.end193

if.then186:                                       ; preds = %land.lhs.true181
  %168 = load ptr, ptr %window, align 8
  %DrawList187 = getelementptr inbounds %struct.ImGuiWindow, ptr %168, i32 0, i32 86
  %169 = load ptr, ptr %DrawList187, align 8
  %170 = load ptr, ptr %table.addr, align 8
  %BorderX1189 = getelementptr inbounds %struct.ImGuiTable, ptr %170, i32 0, i32 29
  %171 = load float, ptr %BorderX1189, align 4
  %172 = load float, ptr %bg_y2, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp188, float noundef %171, float noundef %172)
  %173 = load ptr, ptr %table.addr, align 8
  %BorderX2191 = getelementptr inbounds %struct.ImGuiTable, ptr %173, i32 0, i32 30
  %174 = load float, ptr %BorderX2191, align 8
  %175 = load float, ptr %bg_y2, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp190, float noundef %174, float noundef %175)
  %176 = load ptr, ptr %table.addr, align 8
  %BorderColorStrong192 = getelementptr inbounds %struct.ImGuiTable, ptr %176, i32 0, i32 27
  %177 = load i32, ptr %BorderColorStrong192, align 4
  call void @_ZN10ImDrawList7AddLineERK6ImVec2S2_jf(ptr noundef nonnull align 8 dereferenceable(196) %169, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp188, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp190, i32 noundef %177, float noundef 1.000000e+00)
  br label %if.end193

if.end193:                                        ; preds = %if.then186, %land.lhs.true181, %land.lhs.true176, %if.end174
  br label %if.end194

if.end194:                                        ; preds = %if.end193, %land.end
  %178 = load i8, ptr %unfreeze_rows_request, align 1
  %tobool195 = trunc i8 %178 to i1
  br i1 %tobool195, label %if.then196, label %if.end204

if.then196:                                       ; preds = %if.end194
  store i32 0, ptr %column_n, align 4
  br label %for.cond197

for.cond197:                                      ; preds = %for.inc202, %if.then196
  %179 = load i32, ptr %column_n, align 4
  %180 = load ptr, ptr %table.addr, align 8
  %ColumnsCount = getelementptr inbounds %struct.ImGuiTable, ptr %180, i32 0, i32 13
  %181 = load i32, ptr %ColumnsCount, align 4
  %cmp198 = icmp slt i32 %179, %181
  br i1 %cmp198, label %for.body199, label %for.end203

for.body199:                                      ; preds = %for.cond197
  %182 = load ptr, ptr %table.addr, align 8
  %Columns200 = getelementptr inbounds %struct.ImGuiTable, ptr %182, i32 0, i32 4
  %183 = load i32, ptr %column_n, align 4
  %call201 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns200, i32 noundef %183)
  %NavLayerCurrent = getelementptr inbounds %struct.ImGuiTableColumn, ptr %call201, i32 0, i32 34
  store i8 0, ptr %NavLayerCurrent, align 2
  br label %for.inc202

for.inc202:                                       ; preds = %for.body199
  %184 = load i32, ptr %column_n, align 4
  %inc = add nsw i32 %184, 1
  store i32 %inc, ptr %column_n, align 4
  br label %for.cond197, !llvm.loop !27

for.end203:                                       ; preds = %for.cond197
  br label %if.end204

if.end204:                                        ; preds = %for.end203, %if.end194
  %185 = load i8, ptr %unfreeze_rows_actual, align 1
  %tobool205 = trunc i8 %185 to i1
  br i1 %tobool205, label %if.then206, label %if.end279

if.then206:                                       ; preds = %if.end204
  %186 = load ptr, ptr %table.addr, align 8
  %RowPosY2207 = getelementptr inbounds %struct.ImGuiTable, ptr %186, i32 0, i32 19
  %187 = load float, ptr %RowPosY2207, align 8
  %add208 = fadd float %187, 1.000000e+00
  %188 = load ptr, ptr %window, align 8
  %InnerClipRect209 = getelementptr inbounds %struct.ImGuiWindow, ptr %188, i32 0, i32 71
  %Min210 = getelementptr inbounds %struct.ImRect, ptr %InnerClipRect209, i32 0, i32 0
  %y211 = getelementptr inbounds %struct.ImVec2, ptr %Min210, i32 0, i32 1
  %189 = load float, ptr %y211, align 4
  %call212 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %add208, float noundef %189)
  store float %call212, ptr %y0, align 4
  %190 = load ptr, ptr %table.addr, align 8
  %IsUnfrozenRows = getelementptr inbounds %struct.ImGuiTable, ptr %190, i32 0, i32 104
  store i8 1, ptr %IsUnfrozenRows, align 2
  %191 = load float, ptr %y0, align 4
  %192 = load ptr, ptr %table.addr, align 8
  %OuterRect = getelementptr inbounds %struct.ImGuiTable, ptr %192, i32 0, i32 46
  %Min213 = getelementptr inbounds %struct.ImRect, ptr %OuterRect, i32 0, i32 0
  %y214 = getelementptr inbounds %struct.ImVec2, ptr %Min213, i32 0, i32 1
  %193 = load float, ptr %y214, align 4
  %sub215 = fsub float %191, %193
  %194 = load ptr, ptr %table_instance, align 8
  %LastFrozenHeight = getelementptr inbounds %struct.ImGuiTableInstanceData, ptr %194, i32 0, i32 3
  store float %sub215, ptr %LastFrozenHeight, align 4
  %195 = load float, ptr %y0, align 4
  %196 = load ptr, ptr %window, align 8
  %InnerClipRect216 = getelementptr inbounds %struct.ImGuiWindow, ptr %196, i32 0, i32 71
  %Max217 = getelementptr inbounds %struct.ImRect, ptr %InnerClipRect216, i32 0, i32 1
  %y218 = getelementptr inbounds %struct.ImVec2, ptr %Max217, i32 0, i32 1
  %197 = load float, ptr %y218, align 4
  %call219 = call noundef float @_ZL5ImMinIfET_S0_S0_(float noundef %195, float noundef %197)
  %198 = load ptr, ptr %table.addr, align 8
  %Bg2ClipRectForDrawCmd = getelementptr inbounds %struct.ImGuiTable, ptr %198, i32 0, i32 52
  %Min220 = getelementptr inbounds %struct.ImRect, ptr %Bg2ClipRectForDrawCmd, i32 0, i32 0
  %y221 = getelementptr inbounds %struct.ImVec2, ptr %Min220, i32 0, i32 1
  store float %call219, ptr %y221, align 4
  %199 = load ptr, ptr %table.addr, align 8
  %BgClipRect222 = getelementptr inbounds %struct.ImGuiTable, ptr %199, i32 0, i32 50
  %Min223 = getelementptr inbounds %struct.ImRect, ptr %BgClipRect222, i32 0, i32 0
  %y224 = getelementptr inbounds %struct.ImVec2, ptr %Min223, i32 0, i32 1
  store float %call219, ptr %y224, align 4
  %200 = load ptr, ptr %window, align 8
  %InnerClipRect225 = getelementptr inbounds %struct.ImGuiWindow, ptr %200, i32 0, i32 71
  %Max226 = getelementptr inbounds %struct.ImRect, ptr %InnerClipRect225, i32 0, i32 1
  %y227 = getelementptr inbounds %struct.ImVec2, ptr %Max226, i32 0, i32 1
  %201 = load float, ptr %y227, align 4
  %202 = load ptr, ptr %table.addr, align 8
  %Bg2ClipRectForDrawCmd228 = getelementptr inbounds %struct.ImGuiTable, ptr %202, i32 0, i32 52
  %Max229 = getelementptr inbounds %struct.ImRect, ptr %Bg2ClipRectForDrawCmd228, i32 0, i32 1
  %y230 = getelementptr inbounds %struct.ImVec2, ptr %Max229, i32 0, i32 1
  store float %201, ptr %y230, align 4
  %203 = load ptr, ptr %table.addr, align 8
  %BgClipRect231 = getelementptr inbounds %struct.ImGuiTable, ptr %203, i32 0, i32 50
  %Max232 = getelementptr inbounds %struct.ImRect, ptr %BgClipRect231, i32 0, i32 1
  %y233 = getelementptr inbounds %struct.ImVec2, ptr %Max232, i32 0, i32 1
  store float %201, ptr %y233, align 4
  %204 = load ptr, ptr %table.addr, align 8
  %Bg2DrawChannelUnfrozen = getelementptr inbounds %struct.ImGuiTable, ptr %204, i32 0, i32 91
  %205 = load i16, ptr %Bg2DrawChannelUnfrozen, align 4
  %206 = load ptr, ptr %table.addr, align 8
  %Bg2DrawChannelCurrent = getelementptr inbounds %struct.ImGuiTable, ptr %206, i32 0, i32 90
  store i16 %205, ptr %Bg2DrawChannelCurrent, align 2
  %207 = load ptr, ptr %table.addr, align 8
  %RowPosY2234 = getelementptr inbounds %struct.ImGuiTable, ptr %207, i32 0, i32 19
  %208 = load float, ptr %RowPosY2234, align 8
  %209 = load ptr, ptr %table.addr, align 8
  %RowPosY1235 = getelementptr inbounds %struct.ImGuiTable, ptr %209, i32 0, i32 18
  %210 = load float, ptr %RowPosY1235, align 4
  %sub236 = fsub float %208, %210
  store float %sub236, ptr %row_height, align 4
  %211 = load ptr, ptr %table.addr, align 8
  %WorkRect237 = getelementptr inbounds %struct.ImGuiTable, ptr %211, i32 0, i32 48
  %Min238 = getelementptr inbounds %struct.ImRect, ptr %WorkRect237, i32 0, i32 0
  %y239 = getelementptr inbounds %struct.ImVec2, ptr %Min238, i32 0, i32 1
  %212 = load float, ptr %y239, align 4
  %213 = load ptr, ptr %table.addr, align 8
  %RowPosY2240 = getelementptr inbounds %struct.ImGuiTable, ptr %213, i32 0, i32 19
  %214 = load float, ptr %RowPosY2240, align 8
  %add241 = fadd float %212, %214
  %215 = load ptr, ptr %table.addr, align 8
  %OuterRect242 = getelementptr inbounds %struct.ImGuiTable, ptr %215, i32 0, i32 46
  %Min243 = getelementptr inbounds %struct.ImRect, ptr %OuterRect242, i32 0, i32 0
  %y244 = getelementptr inbounds %struct.ImVec2, ptr %Min243, i32 0, i32 1
  %216 = load float, ptr %y244, align 4
  %sub245 = fsub float %add241, %216
  %217 = load ptr, ptr %window, align 8
  %DC246 = getelementptr inbounds %struct.ImGuiWindow, ptr %217, i32 0, i32 68
  %CursorPos247 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC246, i32 0, i32 0
  %y248 = getelementptr inbounds %struct.ImVec2, ptr %CursorPos247, i32 0, i32 1
  store float %sub245, ptr %y248, align 4
  %218 = load ptr, ptr %table.addr, align 8
  %RowPosY2249 = getelementptr inbounds %struct.ImGuiTable, ptr %218, i32 0, i32 19
  store float %sub245, ptr %RowPosY2249, align 8
  %219 = load ptr, ptr %table.addr, align 8
  %RowPosY2250 = getelementptr inbounds %struct.ImGuiTable, ptr %219, i32 0, i32 19
  %220 = load float, ptr %RowPosY2250, align 8
  %221 = load float, ptr %row_height, align 4
  %sub251 = fsub float %220, %221
  %222 = load ptr, ptr %table.addr, align 8
  %RowPosY1252 = getelementptr inbounds %struct.ImGuiTable, ptr %222, i32 0, i32 18
  store float %sub251, ptr %RowPosY1252, align 4
  store i32 0, ptr %column_n253, align 4
  br label %for.cond254

for.cond254:                                      ; preds = %for.inc267, %if.then206
  %223 = load i32, ptr %column_n253, align 4
  %224 = load ptr, ptr %table.addr, align 8
  %ColumnsCount255 = getelementptr inbounds %struct.ImGuiTable, ptr %224, i32 0, i32 13
  %225 = load i32, ptr %ColumnsCount255, align 4
  %cmp256 = icmp slt i32 %223, %225
  br i1 %cmp256, label %for.body257, label %for.end269

for.body257:                                      ; preds = %for.cond254
  %226 = load ptr, ptr %table.addr, align 8
  %Columns259 = getelementptr inbounds %struct.ImGuiTable, ptr %226, i32 0, i32 4
  %227 = load i32, ptr %column_n253, align 4
  %call260 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns259, i32 noundef %227)
  store ptr %call260, ptr %column258, align 8
  %228 = load ptr, ptr %column258, align 8
  %DrawChannelUnfrozen = getelementptr inbounds %struct.ImGuiTableColumn, ptr %228, i32 0, i32 25
  %229 = load i16, ptr %DrawChannelUnfrozen, align 4
  %230 = load ptr, ptr %column258, align 8
  %DrawChannelCurrent = getelementptr inbounds %struct.ImGuiTableColumn, ptr %230, i32 0, i32 23
  store i16 %229, ptr %DrawChannelCurrent, align 4
  %231 = load ptr, ptr %table.addr, align 8
  %Bg2ClipRectForDrawCmd261 = getelementptr inbounds %struct.ImGuiTable, ptr %231, i32 0, i32 52
  %Min262 = getelementptr inbounds %struct.ImRect, ptr %Bg2ClipRectForDrawCmd261, i32 0, i32 0
  %y263 = getelementptr inbounds %struct.ImVec2, ptr %Min262, i32 0, i32 1
  %232 = load float, ptr %y263, align 4
  %233 = load ptr, ptr %column258, align 8
  %ClipRect264 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %233, i32 0, i32 8
  %Min265 = getelementptr inbounds %struct.ImRect, ptr %ClipRect264, i32 0, i32 0
  %y266 = getelementptr inbounds %struct.ImVec2, ptr %Min265, i32 0, i32 1
  store float %232, ptr %y266, align 4
  br label %for.inc267

for.inc267:                                       ; preds = %for.body257
  %234 = load i32, ptr %column_n253, align 4
  %inc268 = add nsw i32 %234, 1
  store i32 %inc268, ptr %column_n253, align 4
  br label %for.cond254, !llvm.loop !28

for.end269:                                       ; preds = %for.cond254
  %235 = load ptr, ptr %window, align 8
  %236 = load ptr, ptr %table.addr, align 8
  %Columns270 = getelementptr inbounds %struct.ImGuiTable, ptr %236, i32 0, i32 4
  %call271 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns270, i32 noundef 0)
  %ClipRect272 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %call271, i32 0, i32 8
  call void @_ZN5ImGui33SetWindowClipRectBeforeSetChannelEP11ImGuiWindowRK6ImRect(ptr noundef %235, ptr noundef nonnull align 4 dereferenceable(16) %ClipRect272)
  %237 = load ptr, ptr %table.addr, align 8
  %DrawSplitter273 = getelementptr inbounds %struct.ImGuiTable, ptr %237, i32 0, i32 58
  %238 = load ptr, ptr %DrawSplitter273, align 8
  %239 = load ptr, ptr %window, align 8
  %DrawList274 = getelementptr inbounds %struct.ImGuiWindow, ptr %239, i32 0, i32 86
  %240 = load ptr, ptr %DrawList274, align 8
  %241 = load ptr, ptr %table.addr, align 8
  %Columns275 = getelementptr inbounds %struct.ImGuiTable, ptr %241, i32 0, i32 4
  %call276 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns275, i32 noundef 0)
  %DrawChannelCurrent277 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %call276, i32 0, i32 23
  %242 = load i16, ptr %DrawChannelCurrent277, align 4
  %conv278 = zext i16 %242 to i32
  call void @_ZN18ImDrawListSplitter17SetCurrentChannelEP10ImDrawListi(ptr noundef nonnull align 8 dereferenceable(24) %238, ptr noundef %240, i32 noundef %conv278)
  br label %if.end279

if.end279:                                        ; preds = %for.end269, %if.end204
  %243 = load ptr, ptr %table.addr, align 8
  %RowFlags280 = getelementptr inbounds %struct.ImGuiTable, ptr %243, i32 0, i32 24
  %bf.load281 = load i32, ptr %RowFlags280, align 4
  %bf.shl282 = shl i32 %bf.load281, 16
  %bf.ashr283 = ashr i32 %bf.shl282, 16
  %and284 = and i32 %bf.ashr283, 1
  %tobool285 = icmp ne i32 %and284, 0
  br i1 %tobool285, label %if.end289, label %if.then286

if.then286:                                       ; preds = %if.end279
  %244 = load ptr, ptr %table.addr, align 8
  %RowBgColorCounter287 = getelementptr inbounds %struct.ImGuiTable, ptr %244, i32 0, i32 25
  %245 = load i32, ptr %RowBgColorCounter287, align 8
  %inc288 = add nsw i32 %245, 1
  store i32 %inc288, ptr %RowBgColorCounter287, align 8
  br label %if.end289

if.end289:                                        ; preds = %if.then286, %if.end279
  %246 = load ptr, ptr %table.addr, align 8
  %IsInsideRow = getelementptr inbounds %struct.ImGuiTable, ptr %246, i32 0, i32 93
  store i8 0, ptr %IsInsideRow, align 1
  ret void
}

declare noundef zeroext i1 @_ZN5ImGui16IsAnyItemHoveredEv() #1

declare noundef zeroext i1 @_ZN5ImGui15IsMouseReleasedEi(i32 noundef) #1

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui20TableOpenContextMenuEi(i32 noundef %column_n) #0 {
entry:
  %column_n.addr = alloca i32, align 4
  %g = alloca ptr, align 8
  %table = alloca ptr, align 8
  %context_menu_id = alloca i32, align 4
  store i32 %column_n, ptr %column_n.addr, align 4
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %g, align 8
  %CurrentTable = getelementptr inbounds %struct.ImGuiContext, ptr %1, i32 0, i32 164
  %2 = load ptr, ptr %CurrentTable, align 8
  store ptr %2, ptr %table, align 8
  %3 = load i32, ptr %column_n.addr, align 4
  %cmp = icmp eq i32 %3, -1
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %4 = load ptr, ptr %table, align 8
  %CurrentColumn = getelementptr inbounds %struct.ImGuiTable, ptr %4, i32 0, i32 15
  %5 = load i32, ptr %CurrentColumn, align 4
  %cmp1 = icmp ne i32 %5, -1
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %6 = load ptr, ptr %table, align 8
  %CurrentColumn2 = getelementptr inbounds %struct.ImGuiTable, ptr %6, i32 0, i32 15
  %7 = load i32, ptr %CurrentColumn2, align 4
  store i32 %7, ptr %column_n.addr, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %8 = load i32, ptr %column_n.addr, align 4
  %9 = load ptr, ptr %table, align 8
  %ColumnsCount = getelementptr inbounds %struct.ImGuiTable, ptr %9, i32 0, i32 13
  %10 = load i32, ptr %ColumnsCount, align 4
  %cmp3 = icmp eq i32 %8, %10
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  store i32 -1, ptr %column_n.addr, align 4
  br label %if.end5

if.end5:                                          ; preds = %if.then4, %if.end
  %11 = load ptr, ptr %table, align 8
  %Flags = getelementptr inbounds %struct.ImGuiTable, ptr %11, i32 0, i32 1
  %12 = load i32, ptr %Flags, align 4
  %and = and i32 %12, 7
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end5
  %13 = load ptr, ptr %table, align 8
  %IsContextPopupOpen = getelementptr inbounds %struct.ImGuiTable, ptr %13, i32 0, i32 97
  store i8 1, ptr %IsContextPopupOpen, align 1
  %14 = load i32, ptr %column_n.addr, align 4
  %conv = trunc i32 %14 to i16
  %15 = load ptr, ptr %table, align 8
  %ContextPopupColumn = getelementptr inbounds %struct.ImGuiTable, ptr %15, i32 0, i32 83
  store i16 %conv, ptr %ContextPopupColumn, align 4
  %16 = load ptr, ptr %table, align 8
  %InstanceCurrent = getelementptr inbounds %struct.ImGuiTable, ptr %16, i32 0, i32 16
  %17 = load i16, ptr %InstanceCurrent, align 8
  %18 = load ptr, ptr %table, align 8
  %InstanceInteracted = getelementptr inbounds %struct.ImGuiTable, ptr %18, i32 0, i32 17
  store i16 %17, ptr %InstanceInteracted, align 2
  %19 = load ptr, ptr %table, align 8
  %ID = getelementptr inbounds %struct.ImGuiTable, ptr %19, i32 0, i32 0
  %20 = load i32, ptr %ID, align 8
  %call = call noundef i32 @_Z9ImHashStrPKcmj(ptr noundef @.str.6, i64 noundef 0, i32 noundef %20)
  store i32 %call, ptr %context_menu_id, align 4
  %21 = load i32, ptr %context_menu_id, align 4
  call void @_ZN5ImGui11OpenPopupExEji(i32 noundef %21, i32 noundef 0)
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %if.end5
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef float @_ZNK6ImRect9GetHeightEv(ptr noundef nonnull align 4 dereferenceable(16) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Max = getelementptr inbounds %struct.ImRect, ptr %this1, i32 0, i32 1
  %y = getelementptr inbounds %struct.ImVec2, ptr %Max, i32 0, i32 1
  %0 = load float, ptr %y, align 4
  %Min = getelementptr inbounds %struct.ImRect, ptr %this1, i32 0, i32 0
  %y2 = getelementptr inbounds %struct.ImVec2, ptr %Min, i32 0, i32 1
  %1 = load float, ptr %y2, align 4
  %sub = fsub float %0, %1
  ret float %sub
}

declare void @_ZN10ImDrawList11PopClipRectEv(ptr noundef nonnull align 8 dereferenceable(196)) #1

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef nonnull align 4 dereferenceable(16) ptr @_ZN8ImVectorI6ImVec4E4backEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.34, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %Size = getelementptr inbounds %struct.ImVector.34, ptr %this1, i32 0, i32 0
  %1 = load i32, ptr %Size, align 8
  %sub = sub nsw i32 %1, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.ImVec4, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN6ImRectC2ERK6ImVec4(ptr noundef nonnull align 4 dereferenceable(16) %this, ptr noundef nonnull align 4 dereferenceable(16) %v) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %v.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %v, ptr %v.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Min = getelementptr inbounds %struct.ImRect, ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %v.addr, align 8
  %x = getelementptr inbounds %struct.ImVec4, ptr %0, i32 0, i32 0
  %1 = load float, ptr %x, align 4
  %2 = load ptr, ptr %v.addr, align 8
  %y = getelementptr inbounds %struct.ImVec4, ptr %2, i32 0, i32 1
  %3 = load float, ptr %y, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %Min, float noundef %1, float noundef %3)
  %Max = getelementptr inbounds %struct.ImRect, ptr %this1, i32 0, i32 1
  %4 = load ptr, ptr %v.addr, align 8
  %z = getelementptr inbounds %struct.ImVec4, ptr %4, i32 0, i32 2
  %5 = load float, ptr %z, align 4
  %6 = load ptr, ptr %v.addr, align 8
  %w = getelementptr inbounds %struct.ImVec4, ptr %6, i32 0, i32 3
  %7 = load float, ptr %w, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %Max, float noundef %5, float noundef %7)
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui16TableDrawBordersEP10ImGuiTable(ptr noundef %table) #2 {
entry:
  %table.addr = alloca ptr, align 8
  %inner_window = alloca ptr, align 8
  %inner_drawlist = alloca ptr, align 8
  %table_instance = alloca ptr, align 8
  %border_size = alloca float, align 4
  %draw_y1 = alloca float, align 4
  %draw_y2_body = alloca float, align 4
  %draw_y2_head = alloca float, align 4
  %order_n = alloca i32, align 4
  %column_n = alloca i32, align 4
  %column = alloca ptr, align 8
  %is_hovered = alloca i8, align 1
  %is_resized = alloca i8, align 1
  %is_resizable = alloca i8, align 1
  %is_frozen_separator = alloca i8, align 1
  %draw_y2 = alloca float, align 4
  %ref.tmp = alloca %struct.ImVec2, align 4
  %ref.tmp111 = alloca %struct.ImVec2, align 4
  %outer_border = alloca %struct.ImRect, align 4
  %outer_col = alloca i32, align 4
  %ref.tmp126 = alloca %struct.ImVec2, align 4
  %ref.tmp128 = alloca %struct.ImVec2, align 4
  %ref.tmp135 = alloca %struct.ImVec2, align 4
  %ref.tmp140 = alloca %struct.ImVec2, align 4
  %ref.tmp152 = alloca %struct.ImVec2, align 4
  %ref.tmp157 = alloca %struct.ImVec2, align 4
  %border_y = alloca float, align 4
  %ref.tmp186 = alloca %struct.ImVec2, align 4
  %ref.tmp187 = alloca %struct.ImVec2, align 4
  store ptr %table, ptr %table.addr, align 8
  %0 = load ptr, ptr %table.addr, align 8
  %InnerWindow = getelementptr inbounds %struct.ImGuiTable, ptr %0, i32 0, i32 56
  %1 = load ptr, ptr %InnerWindow, align 8
  store ptr %1, ptr %inner_window, align 8
  %2 = load ptr, ptr %table.addr, align 8
  %OuterWindow = getelementptr inbounds %struct.ImGuiTable, ptr %2, i32 0, i32 55
  %3 = load ptr, ptr %OuterWindow, align 8
  %ClipRect = getelementptr inbounds %struct.ImGuiWindow, ptr %3, i32 0, i32 74
  %4 = load ptr, ptr %table.addr, align 8
  %OuterRect = getelementptr inbounds %struct.ImGuiTable, ptr %4, i32 0, i32 46
  %call = call noundef zeroext i1 @_ZNK6ImRect8OverlapsERKS_(ptr noundef nonnull align 4 dereferenceable(16) %ClipRect, ptr noundef nonnull align 4 dereferenceable(16) %OuterRect)
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %5 = load ptr, ptr %inner_window, align 8
  %DrawList = getelementptr inbounds %struct.ImGuiWindow, ptr %5, i32 0, i32 86
  %6 = load ptr, ptr %DrawList, align 8
  store ptr %6, ptr %inner_drawlist, align 8
  %7 = load ptr, ptr %table.addr, align 8
  %DrawSplitter = getelementptr inbounds %struct.ImGuiTable, ptr %7, i32 0, i32 58
  %8 = load ptr, ptr %DrawSplitter, align 8
  %9 = load ptr, ptr %inner_drawlist, align 8
  call void @_ZN18ImDrawListSplitter17SetCurrentChannelEP10ImDrawListi(ptr noundef nonnull align 8 dereferenceable(24) %8, ptr noundef %9, i32 noundef 0)
  %10 = load ptr, ptr %inner_drawlist, align 8
  %11 = load ptr, ptr %table.addr, align 8
  %Bg0ClipRectForDrawCmd = getelementptr inbounds %struct.ImGuiTable, ptr %11, i32 0, i32 51
  %Min = getelementptr inbounds %struct.ImRect, ptr %Bg0ClipRectForDrawCmd, i32 0, i32 0
  %12 = load ptr, ptr %table.addr, align 8
  %Bg0ClipRectForDrawCmd1 = getelementptr inbounds %struct.ImGuiTable, ptr %12, i32 0, i32 51
  %Max = getelementptr inbounds %struct.ImRect, ptr %Bg0ClipRectForDrawCmd1, i32 0, i32 1
  call void @_ZN10ImDrawList12PushClipRectERK6ImVec2S2_b(ptr noundef nonnull align 8 dereferenceable(196) %10, ptr noundef nonnull align 4 dereferenceable(8) %Min, ptr noundef nonnull align 4 dereferenceable(8) %Max, i1 noundef zeroext false)
  %13 = load ptr, ptr %table.addr, align 8
  %14 = load ptr, ptr %table.addr, align 8
  %InstanceCurrent = getelementptr inbounds %struct.ImGuiTable, ptr %14, i32 0, i32 16
  %15 = load i16, ptr %InstanceCurrent, align 8
  %conv = sext i16 %15 to i32
  %call2 = call noundef ptr @_ZN5ImGui20TableGetInstanceDataEP10ImGuiTablei(ptr noundef %13, i32 noundef %conv)
  store ptr %call2, ptr %table_instance, align 8
  store float 1.000000e+00, ptr %border_size, align 4
  %16 = load ptr, ptr %table.addr, align 8
  %InnerRect = getelementptr inbounds %struct.ImGuiTable, ptr %16, i32 0, i32 47
  %Min3 = getelementptr inbounds %struct.ImRect, ptr %InnerRect, i32 0, i32 0
  %y = getelementptr inbounds %struct.ImVec2, ptr %Min3, i32 0, i32 1
  %17 = load float, ptr %y, align 4
  %18 = load ptr, ptr %table.addr, align 8
  %FreezeRowsCount = getelementptr inbounds %struct.ImGuiTable, ptr %18, i32 0, i32 85
  %19 = load i16, ptr %FreezeRowsCount, align 8
  %conv4 = sext i16 %19 to i32
  %cmp = icmp sge i32 %conv4, 1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %20 = load ptr, ptr %table.addr, align 8
  %InnerRect5 = getelementptr inbounds %struct.ImGuiTable, ptr %20, i32 0, i32 47
  %Min6 = getelementptr inbounds %struct.ImRect, ptr %InnerRect5, i32 0, i32 0
  %y7 = getelementptr inbounds %struct.ImVec2, ptr %Min6, i32 0, i32 1
  %21 = load float, ptr %y7, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %22 = load ptr, ptr %table.addr, align 8
  %WorkRect = getelementptr inbounds %struct.ImGuiTable, ptr %22, i32 0, i32 48
  %Min8 = getelementptr inbounds %struct.ImRect, ptr %WorkRect, i32 0, i32 0
  %y9 = getelementptr inbounds %struct.ImVec2, ptr %Min8, i32 0, i32 1
  %23 = load float, ptr %y9, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi float [ %21, %cond.true ], [ %23, %cond.false ]
  %24 = load ptr, ptr %table.addr, align 8
  %AngledHeadersHeight = getelementptr inbounds %struct.ImGuiTable, ptr %24, i32 0, i32 44
  %25 = load float, ptr %AngledHeadersHeight, align 8
  %add = fadd float %cond, %25
  %call10 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %17, float noundef %add)
  %26 = load ptr, ptr %table.addr, align 8
  %Flags = getelementptr inbounds %struct.ImGuiTable, ptr %26, i32 0, i32 1
  %27 = load i32, ptr %Flags, align 4
  %and = and i32 %27, 256
  %tobool = icmp ne i32 %and, 0
  %cond11 = select i1 %tobool, float 1.000000e+00, float 0.000000e+00
  %add12 = fadd float %call10, %cond11
  store float %add12, ptr %draw_y1, align 4
  %28 = load ptr, ptr %table.addr, align 8
  %InnerRect13 = getelementptr inbounds %struct.ImGuiTable, ptr %28, i32 0, i32 47
  %Max14 = getelementptr inbounds %struct.ImRect, ptr %InnerRect13, i32 0, i32 1
  %y15 = getelementptr inbounds %struct.ImVec2, ptr %Max14, i32 0, i32 1
  %29 = load float, ptr %y15, align 4
  store float %29, ptr %draw_y2_body, align 4
  %30 = load ptr, ptr %table.addr, align 8
  %IsUsingHeaders = getelementptr inbounds %struct.ImGuiTable, ptr %30, i32 0, i32 96
  %31 = load i8, ptr %IsUsingHeaders, align 2
  %tobool16 = trunc i8 %31 to i1
  br i1 %tobool16, label %cond.true17, label %cond.false36

cond.true17:                                      ; preds = %cond.end
  %32 = load ptr, ptr %table.addr, align 8
  %InnerRect18 = getelementptr inbounds %struct.ImGuiTable, ptr %32, i32 0, i32 47
  %Max19 = getelementptr inbounds %struct.ImRect, ptr %InnerRect18, i32 0, i32 1
  %y20 = getelementptr inbounds %struct.ImVec2, ptr %Max19, i32 0, i32 1
  %33 = load float, ptr %y20, align 4
  %34 = load ptr, ptr %table.addr, align 8
  %FreezeRowsCount21 = getelementptr inbounds %struct.ImGuiTable, ptr %34, i32 0, i32 85
  %35 = load i16, ptr %FreezeRowsCount21, align 8
  %conv22 = sext i16 %35 to i32
  %cmp23 = icmp sge i32 %conv22, 1
  br i1 %cmp23, label %cond.true24, label %cond.false28

cond.true24:                                      ; preds = %cond.true17
  %36 = load ptr, ptr %table.addr, align 8
  %InnerRect25 = getelementptr inbounds %struct.ImGuiTable, ptr %36, i32 0, i32 47
  %Min26 = getelementptr inbounds %struct.ImRect, ptr %InnerRect25, i32 0, i32 0
  %y27 = getelementptr inbounds %struct.ImVec2, ptr %Min26, i32 0, i32 1
  %37 = load float, ptr %y27, align 4
  br label %cond.end32

cond.false28:                                     ; preds = %cond.true17
  %38 = load ptr, ptr %table.addr, align 8
  %WorkRect29 = getelementptr inbounds %struct.ImGuiTable, ptr %38, i32 0, i32 48
  %Min30 = getelementptr inbounds %struct.ImRect, ptr %WorkRect29, i32 0, i32 0
  %y31 = getelementptr inbounds %struct.ImVec2, ptr %Min30, i32 0, i32 1
  %39 = load float, ptr %y31, align 4
  br label %cond.end32

cond.end32:                                       ; preds = %cond.false28, %cond.true24
  %cond33 = phi float [ %37, %cond.true24 ], [ %39, %cond.false28 ]
  %40 = load ptr, ptr %table_instance, align 8
  %LastTopHeadersRowHeight = getelementptr inbounds %struct.ImGuiTableInstanceData, ptr %40, i32 0, i32 2
  %41 = load float, ptr %LastTopHeadersRowHeight, align 4
  %add34 = fadd float %cond33, %41
  %call35 = call noundef float @_ZL5ImMinIfET_S0_S0_(float noundef %33, float noundef %add34)
  br label %cond.end37

cond.false36:                                     ; preds = %cond.end
  %42 = load float, ptr %draw_y1, align 4
  br label %cond.end37

cond.end37:                                       ; preds = %cond.false36, %cond.end32
  %cond38 = phi float [ %call35, %cond.end32 ], [ %42, %cond.false36 ]
  store float %cond38, ptr %draw_y2_head, align 4
  %43 = load ptr, ptr %table.addr, align 8
  %Flags39 = getelementptr inbounds %struct.ImGuiTable, ptr %43, i32 0, i32 1
  %44 = load i32, ptr %Flags39, align 4
  %and40 = and i32 %44, 512
  %tobool41 = icmp ne i32 %and40, 0
  br i1 %tobool41, label %if.then42, label %if.end115

if.then42:                                        ; preds = %cond.end37
  store i32 0, ptr %order_n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then42
  %45 = load i32, ptr %order_n, align 4
  %46 = load ptr, ptr %table.addr, align 8
  %ColumnsCount = getelementptr inbounds %struct.ImGuiTable, ptr %46, i32 0, i32 13
  %47 = load i32, ptr %ColumnsCount, align 4
  %cmp43 = icmp slt i32 %45, %47
  br i1 %cmp43, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %48 = load ptr, ptr %table.addr, align 8
  %EnabledMaskByDisplayOrder = getelementptr inbounds %struct.ImGuiTable, ptr %48, i32 0, i32 7
  %49 = load ptr, ptr %EnabledMaskByDisplayOrder, align 8
  %50 = load i32, ptr %order_n, align 4
  %shr = ashr i32 %50, 5
  %idxprom = sext i32 %shr to i64
  %arrayidx = getelementptr inbounds i32, ptr %49, i64 %idxprom
  %51 = load i32, ptr %arrayidx, align 4
  %52 = load i32, ptr %order_n, align 4
  %and44 = and i32 %52, 31
  %shl = shl i32 1, %and44
  %and45 = and i32 %51, %shl
  %cmp46 = icmp ne i32 %and45, 0
  br i1 %cmp46, label %if.end48, label %if.then47

if.then47:                                        ; preds = %for.body
  br label %for.inc

if.end48:                                         ; preds = %for.body
  %53 = load ptr, ptr %table.addr, align 8
  %DisplayOrderToIndex = getelementptr inbounds %struct.ImGuiTable, ptr %53, i32 0, i32 5
  %54 = load i32, ptr %order_n, align 4
  %call49 = call noundef nonnull align 2 dereferenceable(2) ptr @_ZN6ImSpanIsEixEi(ptr noundef nonnull align 8 dereferenceable(16) %DisplayOrderToIndex, i32 noundef %54)
  %55 = load i16, ptr %call49, align 2
  %conv50 = sext i16 %55 to i32
  store i32 %conv50, ptr %column_n, align 4
  %56 = load ptr, ptr %table.addr, align 8
  %Columns = getelementptr inbounds %struct.ImGuiTable, ptr %56, i32 0, i32 4
  %57 = load i32, ptr %column_n, align 4
  %call51 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns, i32 noundef %57)
  store ptr %call51, ptr %column, align 8
  %58 = load ptr, ptr %table.addr, align 8
  %HoveredColumnBorder = getelementptr inbounds %struct.ImGuiTable, ptr %58, i32 0, i32 71
  %59 = load i16, ptr %HoveredColumnBorder, align 4
  %conv52 = sext i16 %59 to i32
  %60 = load i32, ptr %column_n, align 4
  %cmp53 = icmp eq i32 %conv52, %60
  %frombool = zext i1 %cmp53 to i8
  store i8 %frombool, ptr %is_hovered, align 1
  %61 = load ptr, ptr %table.addr, align 8
  %ResizedColumn = getelementptr inbounds %struct.ImGuiTable, ptr %61, i32 0, i32 74
  %62 = load i16, ptr %ResizedColumn, align 2
  %conv54 = sext i16 %62 to i32
  %63 = load i32, ptr %column_n, align 4
  %cmp55 = icmp eq i32 %conv54, %63
  br i1 %cmp55, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end48
  %64 = load ptr, ptr %table.addr, align 8
  %InstanceInteracted = getelementptr inbounds %struct.ImGuiTable, ptr %64, i32 0, i32 17
  %65 = load i16, ptr %InstanceInteracted, align 2
  %conv56 = sext i16 %65 to i32
  %66 = load ptr, ptr %table.addr, align 8
  %InstanceCurrent57 = getelementptr inbounds %struct.ImGuiTable, ptr %66, i32 0, i32 16
  %67 = load i16, ptr %InstanceCurrent57, align 8
  %conv58 = sext i16 %67 to i32
  %cmp59 = icmp eq i32 %conv56, %conv58
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end48
  %68 = phi i1 [ false, %if.end48 ], [ %cmp59, %land.rhs ]
  %frombool60 = zext i1 %68 to i8
  store i8 %frombool60, ptr %is_resized, align 1
  %69 = load ptr, ptr %column, align 8
  %Flags61 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %69, i32 0, i32 0
  %70 = load i32, ptr %Flags61, align 4
  %and62 = and i32 %70, 1073741856
  %cmp63 = icmp eq i32 %and62, 0
  %frombool64 = zext i1 %cmp63 to i8
  store i8 %frombool64, ptr %is_resizable, align 1
  %71 = load ptr, ptr %table.addr, align 8
  %FreezeColumnsCount = getelementptr inbounds %struct.ImGuiTable, ptr %71, i32 0, i32 87
  %72 = load i16, ptr %FreezeColumnsCount, align 4
  %conv65 = sext i16 %72 to i32
  %73 = load i32, ptr %order_n, align 4
  %add66 = add nsw i32 %73, 1
  %cmp67 = icmp eq i32 %conv65, %add66
  %frombool68 = zext i1 %cmp67 to i8
  store i8 %frombool68, ptr %is_frozen_separator, align 1
  %74 = load ptr, ptr %column, align 8
  %MaxX = getelementptr inbounds %struct.ImGuiTableColumn, ptr %74, i32 0, i32 3
  %75 = load float, ptr %MaxX, align 4
  %76 = load ptr, ptr %table.addr, align 8
  %InnerClipRect = getelementptr inbounds %struct.ImGuiTable, ptr %76, i32 0, i32 49
  %Max69 = getelementptr inbounds %struct.ImRect, ptr %InnerClipRect, i32 0, i32 1
  %x = getelementptr inbounds %struct.ImVec2, ptr %Max69, i32 0, i32 0
  %77 = load float, ptr %x, align 8
  %cmp70 = fcmp ogt float %75, %77
  br i1 %cmp70, label %land.lhs.true, label %if.end73

land.lhs.true:                                    ; preds = %land.end
  %78 = load i8, ptr %is_resized, align 1
  %tobool71 = trunc i8 %78 to i1
  br i1 %tobool71, label %if.end73, label %if.then72

if.then72:                                        ; preds = %land.lhs.true
  br label %for.inc

if.end73:                                         ; preds = %land.lhs.true, %land.end
  %79 = load ptr, ptr %column, align 8
  %NextEnabledColumn = getelementptr inbounds %struct.ImGuiTableColumn, ptr %79, i32 0, i32 21
  %80 = load i16, ptr %NextEnabledColumn, align 4
  %conv74 = sext i16 %80 to i32
  %cmp75 = icmp eq i32 %conv74, -1
  br i1 %cmp75, label %land.lhs.true76, label %if.end87

land.lhs.true76:                                  ; preds = %if.end73
  %81 = load i8, ptr %is_resizable, align 1
  %tobool77 = trunc i8 %81 to i1
  br i1 %tobool77, label %if.end87, label %if.then78

if.then78:                                        ; preds = %land.lhs.true76
  %82 = load ptr, ptr %table.addr, align 8
  %Flags79 = getelementptr inbounds %struct.ImGuiTable, ptr %82, i32 0, i32 1
  %83 = load i32, ptr %Flags79, align 4
  %and80 = and i32 %83, 57344
  %cmp81 = icmp ne i32 %and80, 16384
  br i1 %cmp81, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then78
  %84 = load ptr, ptr %table.addr, align 8
  %Flags82 = getelementptr inbounds %struct.ImGuiTable, ptr %84, i32 0, i32 1
  %85 = load i32, ptr %Flags82, align 4
  %and83 = and i32 %85, 65536
  %tobool84 = icmp ne i32 %and83, 0
  br i1 %tobool84, label %if.then85, label %if.end86

if.then85:                                        ; preds = %lor.lhs.false, %if.then78
  br label %for.inc

if.end86:                                         ; preds = %lor.lhs.false
  br label %if.end87

if.end87:                                         ; preds = %if.end86, %land.lhs.true76, %if.end73
  %86 = load ptr, ptr %column, align 8
  %MaxX88 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %86, i32 0, i32 3
  %87 = load float, ptr %MaxX88, align 4
  %88 = load ptr, ptr %column, align 8
  %ClipRect89 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %88, i32 0, i32 8
  %Min90 = getelementptr inbounds %struct.ImRect, ptr %ClipRect89, i32 0, i32 0
  %x91 = getelementptr inbounds %struct.ImVec2, ptr %Min90, i32 0, i32 0
  %89 = load float, ptr %x91, align 4
  %cmp92 = fcmp ole float %87, %89
  br i1 %cmp92, label %if.then93, label %if.end94

if.then93:                                        ; preds = %if.end87
  br label %for.inc

if.end94:                                         ; preds = %if.end87
  %90 = load i8, ptr %is_hovered, align 1
  %tobool95 = trunc i8 %90 to i1
  br i1 %tobool95, label %cond.true104, label %lor.lhs.false96

lor.lhs.false96:                                  ; preds = %if.end94
  %91 = load i8, ptr %is_resized, align 1
  %tobool97 = trunc i8 %91 to i1
  br i1 %tobool97, label %cond.true104, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %lor.lhs.false96
  %92 = load i8, ptr %is_frozen_separator, align 1
  %tobool99 = trunc i8 %92 to i1
  br i1 %tobool99, label %cond.true104, label %lor.lhs.false100

lor.lhs.false100:                                 ; preds = %lor.lhs.false98
  %93 = load ptr, ptr %table.addr, align 8
  %Flags101 = getelementptr inbounds %struct.ImGuiTable, ptr %93, i32 0, i32 1
  %94 = load i32, ptr %Flags101, align 4
  %and102 = and i32 %94, 6144
  %cmp103 = icmp eq i32 %and102, 0
  br i1 %cmp103, label %cond.true104, label %cond.false105

cond.true104:                                     ; preds = %lor.lhs.false100, %lor.lhs.false98, %lor.lhs.false96, %if.end94
  %95 = load float, ptr %draw_y2_body, align 4
  br label %cond.end106

cond.false105:                                    ; preds = %lor.lhs.false100
  %96 = load float, ptr %draw_y2_head, align 4
  br label %cond.end106

cond.end106:                                      ; preds = %cond.false105, %cond.true104
  %cond107 = phi float [ %95, %cond.true104 ], [ %96, %cond.false105 ]
  store float %cond107, ptr %draw_y2, align 4
  %97 = load float, ptr %draw_y2, align 4
  %98 = load float, ptr %draw_y1, align 4
  %cmp108 = fcmp ogt float %97, %98
  br i1 %cmp108, label %if.then109, label %if.end114

if.then109:                                       ; preds = %cond.end106
  %99 = load ptr, ptr %inner_drawlist, align 8
  %100 = load ptr, ptr %column, align 8
  %MaxX110 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %100, i32 0, i32 3
  %101 = load float, ptr %MaxX110, align 4
  %102 = load float, ptr %draw_y1, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp, float noundef %101, float noundef %102)
  %103 = load ptr, ptr %column, align 8
  %MaxX112 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %103, i32 0, i32 3
  %104 = load float, ptr %MaxX112, align 4
  %105 = load float, ptr %draw_y2, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp111, float noundef %104, float noundef %105)
  %106 = load ptr, ptr %table.addr, align 8
  %107 = load i32, ptr %order_n, align 4
  %108 = load i32, ptr %column_n, align 4
  %call113 = call noundef i32 @_ZL23TableGetColumnBorderColP10ImGuiTableii(ptr noundef %106, i32 noundef %107, i32 noundef %108)
  call void @_ZN10ImDrawList7AddLineERK6ImVec2S2_jf(ptr noundef nonnull align 8 dereferenceable(196) %99, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp111, i32 noundef %call113, float noundef 1.000000e+00)
  br label %if.end114

if.end114:                                        ; preds = %if.then109, %cond.end106
  br label %for.inc

for.inc:                                          ; preds = %if.end114, %if.then93, %if.then85, %if.then72, %if.then47
  %109 = load i32, ptr %order_n, align 4
  %inc = add nsw i32 %109, 1
  store i32 %inc, ptr %order_n, align 4
  br label %for.cond, !llvm.loop !29

for.end:                                          ; preds = %for.cond
  br label %if.end115

if.end115:                                        ; preds = %for.end, %cond.end37
  %110 = load ptr, ptr %table.addr, align 8
  %Flags116 = getelementptr inbounds %struct.ImGuiTable, ptr %110, i32 0, i32 1
  %111 = load i32, ptr %Flags116, align 4
  %and117 = and i32 %111, 1280
  %tobool118 = icmp ne i32 %and117, 0
  br i1 %tobool118, label %if.then119, label %if.end166

if.then119:                                       ; preds = %if.end115
  %112 = load ptr, ptr %table.addr, align 8
  %OuterRect120 = getelementptr inbounds %struct.ImGuiTable, ptr %112, i32 0, i32 46
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %outer_border, ptr align 8 %OuterRect120, i64 16, i1 false)
  %113 = load ptr, ptr %table.addr, align 8
  %BorderColorStrong = getelementptr inbounds %struct.ImGuiTable, ptr %113, i32 0, i32 27
  %114 = load i32, ptr %BorderColorStrong, align 4
  store i32 %114, ptr %outer_col, align 4
  %115 = load ptr, ptr %table.addr, align 8
  %Flags121 = getelementptr inbounds %struct.ImGuiTable, ptr %115, i32 0, i32 1
  %116 = load i32, ptr %Flags121, align 4
  %and122 = and i32 %116, 1280
  %cmp123 = icmp eq i32 %and122, 1280
  br i1 %cmp123, label %if.then124, label %if.else

if.then124:                                       ; preds = %if.then119
  %117 = load ptr, ptr %inner_drawlist, align 8
  %Min125 = getelementptr inbounds %struct.ImRect, ptr %outer_border, i32 0, i32 0
  %Max127 = getelementptr inbounds %struct.ImRect, ptr %outer_border, i32 0, i32 1
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp128, float noundef 1.000000e+00, float noundef 1.000000e+00)
  %call129 = call <2 x float> @_ZplRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %Max127, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp128)
  store <2 x float> %call129, ptr %ref.tmp126, align 4
  %118 = load i32, ptr %outer_col, align 4
  call void @_ZN10ImDrawList7AddRectERK6ImVec2S2_jfif(ptr noundef nonnull align 8 dereferenceable(196) %117, ptr noundef nonnull align 4 dereferenceable(8) %Min125, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp126, i32 noundef %118, float noundef 0.000000e+00, i32 noundef 0, float noundef 1.000000e+00)
  br label %if.end165

if.else:                                          ; preds = %if.then119
  %119 = load ptr, ptr %table.addr, align 8
  %Flags130 = getelementptr inbounds %struct.ImGuiTable, ptr %119, i32 0, i32 1
  %120 = load i32, ptr %Flags130, align 4
  %and131 = and i32 %120, 1024
  %tobool132 = icmp ne i32 %and131, 0
  br i1 %tobool132, label %if.then133, label %if.else146

if.then133:                                       ; preds = %if.else
  %121 = load ptr, ptr %inner_drawlist, align 8
  %Min134 = getelementptr inbounds %struct.ImRect, ptr %outer_border, i32 0, i32 0
  %Min136 = getelementptr inbounds %struct.ImRect, ptr %outer_border, i32 0, i32 0
  %x137 = getelementptr inbounds %struct.ImVec2, ptr %Min136, i32 0, i32 0
  %122 = load float, ptr %x137, align 4
  %Max138 = getelementptr inbounds %struct.ImRect, ptr %outer_border, i32 0, i32 1
  %y139 = getelementptr inbounds %struct.ImVec2, ptr %Max138, i32 0, i32 1
  %123 = load float, ptr %y139, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp135, float noundef %122, float noundef %123)
  %124 = load i32, ptr %outer_col, align 4
  call void @_ZN10ImDrawList7AddLineERK6ImVec2S2_jf(ptr noundef nonnull align 8 dereferenceable(196) %121, ptr noundef nonnull align 4 dereferenceable(8) %Min134, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp135, i32 noundef %124, float noundef 1.000000e+00)
  %125 = load ptr, ptr %inner_drawlist, align 8
  %Max141 = getelementptr inbounds %struct.ImRect, ptr %outer_border, i32 0, i32 1
  %x142 = getelementptr inbounds %struct.ImVec2, ptr %Max141, i32 0, i32 0
  %126 = load float, ptr %x142, align 4
  %Min143 = getelementptr inbounds %struct.ImRect, ptr %outer_border, i32 0, i32 0
  %y144 = getelementptr inbounds %struct.ImVec2, ptr %Min143, i32 0, i32 1
  %127 = load float, ptr %y144, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp140, float noundef %126, float noundef %127)
  %Max145 = getelementptr inbounds %struct.ImRect, ptr %outer_border, i32 0, i32 1
  %128 = load i32, ptr %outer_col, align 4
  call void @_ZN10ImDrawList7AddLineERK6ImVec2S2_jf(ptr noundef nonnull align 8 dereferenceable(196) %125, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp140, ptr noundef nonnull align 4 dereferenceable(8) %Max145, i32 noundef %128, float noundef 1.000000e+00)
  br label %if.end164

if.else146:                                       ; preds = %if.else
  %129 = load ptr, ptr %table.addr, align 8
  %Flags147 = getelementptr inbounds %struct.ImGuiTable, ptr %129, i32 0, i32 1
  %130 = load i32, ptr %Flags147, align 4
  %and148 = and i32 %130, 256
  %tobool149 = icmp ne i32 %and148, 0
  br i1 %tobool149, label %if.then150, label %if.end163

if.then150:                                       ; preds = %if.else146
  %131 = load ptr, ptr %inner_drawlist, align 8
  %Min151 = getelementptr inbounds %struct.ImRect, ptr %outer_border, i32 0, i32 0
  %Max153 = getelementptr inbounds %struct.ImRect, ptr %outer_border, i32 0, i32 1
  %x154 = getelementptr inbounds %struct.ImVec2, ptr %Max153, i32 0, i32 0
  %132 = load float, ptr %x154, align 4
  %Min155 = getelementptr inbounds %struct.ImRect, ptr %outer_border, i32 0, i32 0
  %y156 = getelementptr inbounds %struct.ImVec2, ptr %Min155, i32 0, i32 1
  %133 = load float, ptr %y156, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp152, float noundef %132, float noundef %133)
  %134 = load i32, ptr %outer_col, align 4
  call void @_ZN10ImDrawList7AddLineERK6ImVec2S2_jf(ptr noundef nonnull align 8 dereferenceable(196) %131, ptr noundef nonnull align 4 dereferenceable(8) %Min151, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp152, i32 noundef %134, float noundef 1.000000e+00)
  %135 = load ptr, ptr %inner_drawlist, align 8
  %Min158 = getelementptr inbounds %struct.ImRect, ptr %outer_border, i32 0, i32 0
  %x159 = getelementptr inbounds %struct.ImVec2, ptr %Min158, i32 0, i32 0
  %136 = load float, ptr %x159, align 4
  %Max160 = getelementptr inbounds %struct.ImRect, ptr %outer_border, i32 0, i32 1
  %y161 = getelementptr inbounds %struct.ImVec2, ptr %Max160, i32 0, i32 1
  %137 = load float, ptr %y161, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp157, float noundef %136, float noundef %137)
  %Max162 = getelementptr inbounds %struct.ImRect, ptr %outer_border, i32 0, i32 1
  %138 = load i32, ptr %outer_col, align 4
  call void @_ZN10ImDrawList7AddLineERK6ImVec2S2_jf(ptr noundef nonnull align 8 dereferenceable(196) %135, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp157, ptr noundef nonnull align 4 dereferenceable(8) %Max162, i32 noundef %138, float noundef 1.000000e+00)
  br label %if.end163

if.end163:                                        ; preds = %if.then150, %if.else146
  br label %if.end164

if.end164:                                        ; preds = %if.end163, %if.then133
  br label %if.end165

if.end165:                                        ; preds = %if.end164, %if.then124
  br label %if.end166

if.end166:                                        ; preds = %if.end165, %if.end115
  %139 = load ptr, ptr %table.addr, align 8
  %Flags167 = getelementptr inbounds %struct.ImGuiTable, ptr %139, i32 0, i32 1
  %140 = load i32, ptr %Flags167, align 4
  %and168 = and i32 %140, 128
  %tobool169 = icmp ne i32 %and168, 0
  br i1 %tobool169, label %land.lhs.true170, label %if.end189

land.lhs.true170:                                 ; preds = %if.end166
  %141 = load ptr, ptr %table.addr, align 8
  %RowPosY2 = getelementptr inbounds %struct.ImGuiTable, ptr %141, i32 0, i32 19
  %142 = load float, ptr %RowPosY2, align 8
  %143 = load ptr, ptr %table.addr, align 8
  %OuterRect171 = getelementptr inbounds %struct.ImGuiTable, ptr %143, i32 0, i32 46
  %Max172 = getelementptr inbounds %struct.ImRect, ptr %OuterRect171, i32 0, i32 1
  %y173 = getelementptr inbounds %struct.ImVec2, ptr %Max172, i32 0, i32 1
  %144 = load float, ptr %y173, align 4
  %cmp174 = fcmp olt float %142, %144
  br i1 %cmp174, label %if.then175, label %if.end189

if.then175:                                       ; preds = %land.lhs.true170
  %145 = load ptr, ptr %table.addr, align 8
  %RowPosY2176 = getelementptr inbounds %struct.ImGuiTable, ptr %145, i32 0, i32 19
  %146 = load float, ptr %RowPosY2176, align 8
  store float %146, ptr %border_y, align 4
  %147 = load float, ptr %border_y, align 4
  %148 = load ptr, ptr %table.addr, align 8
  %BgClipRect = getelementptr inbounds %struct.ImGuiTable, ptr %148, i32 0, i32 50
  %Min177 = getelementptr inbounds %struct.ImRect, ptr %BgClipRect, i32 0, i32 0
  %y178 = getelementptr inbounds %struct.ImVec2, ptr %Min177, i32 0, i32 1
  %149 = load float, ptr %y178, align 4
  %cmp179 = fcmp oge float %147, %149
  br i1 %cmp179, label %land.lhs.true180, label %if.end188

land.lhs.true180:                                 ; preds = %if.then175
  %150 = load float, ptr %border_y, align 4
  %151 = load ptr, ptr %table.addr, align 8
  %BgClipRect181 = getelementptr inbounds %struct.ImGuiTable, ptr %151, i32 0, i32 50
  %Max182 = getelementptr inbounds %struct.ImRect, ptr %BgClipRect181, i32 0, i32 1
  %y183 = getelementptr inbounds %struct.ImVec2, ptr %Max182, i32 0, i32 1
  %152 = load float, ptr %y183, align 4
  %cmp184 = fcmp olt float %150, %152
  br i1 %cmp184, label %if.then185, label %if.end188

if.then185:                                       ; preds = %land.lhs.true180
  %153 = load ptr, ptr %inner_drawlist, align 8
  %154 = load ptr, ptr %table.addr, align 8
  %BorderX1 = getelementptr inbounds %struct.ImGuiTable, ptr %154, i32 0, i32 29
  %155 = load float, ptr %BorderX1, align 4
  %156 = load float, ptr %border_y, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp186, float noundef %155, float noundef %156)
  %157 = load ptr, ptr %table.addr, align 8
  %BorderX2 = getelementptr inbounds %struct.ImGuiTable, ptr %157, i32 0, i32 30
  %158 = load float, ptr %BorderX2, align 8
  %159 = load float, ptr %border_y, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp187, float noundef %158, float noundef %159)
  %160 = load ptr, ptr %table.addr, align 8
  %BorderColorLight = getelementptr inbounds %struct.ImGuiTable, ptr %160, i32 0, i32 28
  %161 = load i32, ptr %BorderColorLight, align 8
  call void @_ZN10ImDrawList7AddLineERK6ImVec2S2_jf(ptr noundef nonnull align 8 dereferenceable(196) %153, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp186, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp187, i32 noundef %161, float noundef 1.000000e+00)
  br label %if.end188

if.end188:                                        ; preds = %if.then185, %land.lhs.true180, %if.then175
  br label %if.end189

if.end189:                                        ; preds = %if.end188, %land.lhs.true170, %if.end166
  %162 = load ptr, ptr %inner_drawlist, align 8
  call void @_ZN10ImDrawList11PopClipRectEv(ptr noundef nonnull align 8 dereferenceable(196) %162)
  br label %return

return:                                           ; preds = %if.end189, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui22TableMergeDrawChannelsEP10ImGuiTable(ptr noundef %table) #2 {
entry:
  %table.addr = alloca ptr, align 8
  %g = alloca ptr, align 8
  %splitter = alloca ptr, align 8
  %has_freeze_v = alloca i8, align 1
  %has_freeze_h = alloca i8, align 1
  %merge_group_mask = alloca i32, align 4
  %merge_groups = alloca [4 x %struct.MergeGroup], align 16
  %max_draw_channels = alloca i32, align 4
  %size_for_masks_bitarrays_one = alloca i32, align 4
  %n = alloca i32, align 4
  %remaining_mask = alloca ptr, align 8
  %column_n = alloca i32, align 4
  %column = alloca ptr, align 8
  %merge_group_sub_count = alloca i32, align 4
  %merge_group_sub_n = alloca i32, align 4
  %channel_no = alloca i32, align 4
  %src_channel = alloca ptr, align 8
  %content_max_x = alloca float, align 4
  %merge_group_n = alloca i32, align 4
  %merge_group = alloca ptr, align 8
  %ref.tmp = alloca %struct.ImRect, align 4
  %ref.tmp89 = alloca %struct.ImRect, align 4
  %LEADING_DRAW_CHANNELS = alloca i32, align 4
  %dst_tmp = alloca ptr, align 8
  %remaining_count = alloca i32, align 4
  %host_rect = alloca %struct.ImRect, align 4
  %merge_group_n110 = alloca i32, align 4
  %merge_channels_count = alloca i32, align 4
  %merge_group119 = alloca ptr, align 8
  %merge_clip_rect = alloca %struct.ImRect, align 4
  %n174 = alloca i32, align 4
  %n188 = alloca i32, align 4
  %channel = alloca ptr, align 8
  %ref.tmp216 = alloca %struct.ImVec4, align 4
  %n238 = alloca i32, align 4
  %channel255 = alloca ptr, align 8
  store ptr %table, ptr %table.addr, align 8
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %table.addr, align 8
  %DrawSplitter = getelementptr inbounds %struct.ImGuiTable, ptr %1, i32 0, i32 58
  %2 = load ptr, ptr %DrawSplitter, align 8
  store ptr %2, ptr %splitter, align 8
  %3 = load ptr, ptr %table.addr, align 8
  %FreezeRowsCount = getelementptr inbounds %struct.ImGuiTable, ptr %3, i32 0, i32 85
  %4 = load i16, ptr %FreezeRowsCount, align 8
  %conv = sext i16 %4 to i32
  %cmp = icmp sgt i32 %conv, 0
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, ptr %has_freeze_v, align 1
  %5 = load ptr, ptr %table.addr, align 8
  %FreezeColumnsCount = getelementptr inbounds %struct.ImGuiTable, ptr %5, i32 0, i32 87
  %6 = load i16, ptr %FreezeColumnsCount, align 4
  %conv1 = sext i16 %6 to i32
  %cmp2 = icmp sgt i32 %conv1, 0
  %frombool3 = zext i1 %cmp2 to i8
  store i8 %frombool3, ptr %has_freeze_h, align 1
  store i32 0, ptr %merge_group_mask, align 4
  %array.begin = getelementptr inbounds [4 x %struct.MergeGroup], ptr %merge_groups, i32 0, i32 0
  %arrayctor.end = getelementptr inbounds %struct.MergeGroup, ptr %array.begin, i64 4
  br label %arrayctor.loop

arrayctor.loop:                                   ; preds = %arrayctor.loop, %entry
  %arrayctor.cur = phi ptr [ %array.begin, %entry ], [ %arrayctor.next, %arrayctor.loop ]
  call void @_ZZN5ImGui22TableMergeDrawChannelsEP10ImGuiTableEN10MergeGroupC2Ev(ptr noundef nonnull align 8 dereferenceable(32) %arrayctor.cur)
  %arrayctor.next = getelementptr inbounds %struct.MergeGroup, ptr %arrayctor.cur, i64 1
  %arrayctor.done = icmp eq ptr %arrayctor.next, %arrayctor.end
  br i1 %arrayctor.done, label %arrayctor.cont, label %arrayctor.loop

arrayctor.cont:                                   ; preds = %arrayctor.loop
  %7 = load ptr, ptr %table.addr, align 8
  %ColumnsCount = getelementptr inbounds %struct.ImGuiTable, ptr %7, i32 0, i32 13
  %8 = load i32, ptr %ColumnsCount, align 4
  %mul = mul nsw i32 %8, 2
  %add = add nsw i32 4, %mul
  store i32 %add, ptr %max_draw_channels, align 4
  %9 = load i32, ptr %max_draw_channels, align 4
  %call = call noundef i64 @_Z31ImBitArrayGetStorageSizeInBytesi(i32 noundef %9)
  %conv4 = trunc i64 %call to i32
  store i32 %conv4, ptr %size_for_masks_bitarrays_one, align 4
  %10 = load ptr, ptr %g, align 8
  %TempBuffer = getelementptr inbounds %struct.ImGuiContext, ptr %10, i32 0, i32 254
  %11 = load i32, ptr %size_for_masks_bitarrays_one, align 4
  %mul5 = mul nsw i32 %11, 5
  call void @_ZN8ImVectorIcE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %TempBuffer, i32 noundef %mul5)
  %12 = load ptr, ptr %g, align 8
  %TempBuffer6 = getelementptr inbounds %struct.ImGuiContext, ptr %12, i32 0, i32 254
  %Data = getelementptr inbounds %struct.ImVector.25, ptr %TempBuffer6, i32 0, i32 2
  %13 = load ptr, ptr %Data, align 8
  %14 = load i32, ptr %size_for_masks_bitarrays_one, align 4
  %mul7 = mul nsw i32 %14, 5
  %conv8 = sext i32 %mul7 to i64
  call void @llvm.memset.p0.i64(ptr align 1 %13, i8 0, i64 %conv8, i1 false)
  store i32 0, ptr %n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %arrayctor.cont
  %15 = load i32, ptr %n, align 4
  %cmp9 = icmp slt i32 %15, 4
  br i1 %cmp9, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %16 = load ptr, ptr %g, align 8
  %TempBuffer10 = getelementptr inbounds %struct.ImGuiContext, ptr %16, i32 0, i32 254
  %Data11 = getelementptr inbounds %struct.ImVector.25, ptr %TempBuffer10, i32 0, i32 2
  %17 = load ptr, ptr %Data11, align 8
  %18 = load i32, ptr %size_for_masks_bitarrays_one, align 4
  %19 = load i32, ptr %n, align 4
  %mul12 = mul nsw i32 %18, %19
  %idx.ext = sext i32 %mul12 to i64
  %add.ptr = getelementptr inbounds i8, ptr %17, i64 %idx.ext
  %20 = load i32, ptr %n, align 4
  %idxprom = sext i32 %20 to i64
  %arrayidx = getelementptr inbounds [4 x %struct.MergeGroup], ptr %merge_groups, i64 0, i64 %idxprom
  %ChannelsMask = getelementptr inbounds %struct.MergeGroup, ptr %arrayidx, i32 0, i32 2
  store ptr %add.ptr, ptr %ChannelsMask, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %21 = load i32, ptr %n, align 4
  %inc = add nsw i32 %21, 1
  store i32 %inc, ptr %n, align 4
  br label %for.cond, !llvm.loop !30

for.end:                                          ; preds = %for.cond
  %22 = load ptr, ptr %g, align 8
  %TempBuffer13 = getelementptr inbounds %struct.ImGuiContext, ptr %22, i32 0, i32 254
  %Data14 = getelementptr inbounds %struct.ImVector.25, ptr %TempBuffer13, i32 0, i32 2
  %23 = load ptr, ptr %Data14, align 8
  %24 = load i32, ptr %size_for_masks_bitarrays_one, align 4
  %mul15 = mul nsw i32 %24, 4
  %idx.ext16 = sext i32 %mul15 to i64
  %add.ptr17 = getelementptr inbounds i8, ptr %23, i64 %idx.ext16
  store ptr %add.ptr17, ptr %remaining_mask, align 8
  store i32 0, ptr %column_n, align 4
  br label %for.cond18

for.cond18:                                       ; preds = %for.inc97, %for.end
  %25 = load i32, ptr %column_n, align 4
  %26 = load ptr, ptr %table.addr, align 8
  %ColumnsCount19 = getelementptr inbounds %struct.ImGuiTable, ptr %26, i32 0, i32 13
  %27 = load i32, ptr %ColumnsCount19, align 4
  %cmp20 = icmp slt i32 %25, %27
  br i1 %cmp20, label %for.body21, label %for.end99

for.body21:                                       ; preds = %for.cond18
  %28 = load ptr, ptr %table.addr, align 8
  %VisibleMaskByIndex = getelementptr inbounds %struct.ImGuiTable, ptr %28, i32 0, i32 9
  %29 = load ptr, ptr %VisibleMaskByIndex, align 8
  %30 = load i32, ptr %column_n, align 4
  %shr = ashr i32 %30, 5
  %idxprom22 = sext i32 %shr to i64
  %arrayidx23 = getelementptr inbounds i32, ptr %29, i64 %idxprom22
  %31 = load i32, ptr %arrayidx23, align 4
  %32 = load i32, ptr %column_n, align 4
  %and = and i32 %32, 31
  %shl = shl i32 1, %and
  %and24 = and i32 %31, %shl
  %cmp25 = icmp ne i32 %and24, 0
  br i1 %cmp25, label %if.end, label %if.then

if.then:                                          ; preds = %for.body21
  br label %for.inc97

if.end:                                           ; preds = %for.body21
  %33 = load ptr, ptr %table.addr, align 8
  %Columns = getelementptr inbounds %struct.ImGuiTable, ptr %33, i32 0, i32 4
  %34 = load i32, ptr %column_n, align 4
  %call26 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns, i32 noundef %34)
  store ptr %call26, ptr %column, align 8
  %35 = load i8, ptr %has_freeze_v, align 1
  %tobool = trunc i8 %35 to i1
  %cond = select i1 %tobool, i32 2, i32 1
  store i32 %cond, ptr %merge_group_sub_count, align 4
  store i32 0, ptr %merge_group_sub_n, align 4
  br label %for.cond27

for.cond27:                                       ; preds = %for.inc94, %if.end
  %36 = load i32, ptr %merge_group_sub_n, align 4
  %37 = load i32, ptr %merge_group_sub_count, align 4
  %cmp28 = icmp slt i32 %36, %37
  br i1 %cmp28, label %for.body29, label %for.end96

for.body29:                                       ; preds = %for.cond27
  %38 = load i32, ptr %merge_group_sub_n, align 4
  %cmp30 = icmp eq i32 %38, 0
  br i1 %cmp30, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body29
  %39 = load ptr, ptr %column, align 8
  %DrawChannelFrozen = getelementptr inbounds %struct.ImGuiTableColumn, ptr %39, i32 0, i32 24
  %40 = load i16, ptr %DrawChannelFrozen, align 2
  br label %cond.end

cond.false:                                       ; preds = %for.body29
  %41 = load ptr, ptr %column, align 8
  %DrawChannelUnfrozen = getelementptr inbounds %struct.ImGuiTableColumn, ptr %41, i32 0, i32 25
  %42 = load i16, ptr %DrawChannelUnfrozen, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond31 = phi i16 [ %40, %cond.true ], [ %42, %cond.false ]
  %conv32 = zext i16 %cond31 to i32
  store i32 %conv32, ptr %channel_no, align 4
  %43 = load ptr, ptr %splitter, align 8
  %_Channels = getelementptr inbounds %struct.ImDrawListSplitter, ptr %43, i32 0, i32 2
  %44 = load i32, ptr %channel_no, align 4
  %call33 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZN8ImVectorI13ImDrawChannelEixEi(ptr noundef nonnull align 8 dereferenceable(16) %_Channels, i32 noundef %44)
  store ptr %call33, ptr %src_channel, align 8
  %45 = load ptr, ptr %src_channel, align 8
  %_CmdBuffer = getelementptr inbounds %struct.ImDrawChannel, ptr %45, i32 0, i32 0
  %Size = getelementptr inbounds %struct.ImVector.32, ptr %_CmdBuffer, i32 0, i32 0
  %46 = load i32, ptr %Size, align 8
  %cmp34 = icmp sgt i32 %46, 0
  br i1 %cmp34, label %land.lhs.true, label %if.end44

land.lhs.true:                                    ; preds = %cond.end
  %47 = load ptr, ptr %src_channel, align 8
  %_CmdBuffer35 = getelementptr inbounds %struct.ImDrawChannel, ptr %47, i32 0, i32 0
  %call36 = call noundef nonnull align 8 dereferenceable(56) ptr @_ZN8ImVectorI9ImDrawCmdE4backEv(ptr noundef nonnull align 8 dereferenceable(16) %_CmdBuffer35)
  %ElemCount = getelementptr inbounds %struct.ImDrawCmd, ptr %call36, i32 0, i32 4
  %48 = load i32, ptr %ElemCount, align 8
  %cmp37 = icmp eq i32 %48, 0
  br i1 %cmp37, label %land.lhs.true38, label %if.end44

land.lhs.true38:                                  ; preds = %land.lhs.true
  %49 = load ptr, ptr %src_channel, align 8
  %_CmdBuffer39 = getelementptr inbounds %struct.ImDrawChannel, ptr %49, i32 0, i32 0
  %call40 = call noundef nonnull align 8 dereferenceable(56) ptr @_ZN8ImVectorI9ImDrawCmdE4backEv(ptr noundef nonnull align 8 dereferenceable(16) %_CmdBuffer39)
  %UserCallback = getelementptr inbounds %struct.ImDrawCmd, ptr %call40, i32 0, i32 5
  %50 = load ptr, ptr %UserCallback, align 8
  %cmp41 = icmp eq ptr %50, null
  br i1 %cmp41, label %if.then42, label %if.end44

if.then42:                                        ; preds = %land.lhs.true38
  %51 = load ptr, ptr %src_channel, align 8
  %_CmdBuffer43 = getelementptr inbounds %struct.ImDrawChannel, ptr %51, i32 0, i32 0
  call void @_ZN8ImVectorI9ImDrawCmdE8pop_backEv(ptr noundef nonnull align 8 dereferenceable(16) %_CmdBuffer43)
  br label %if.end44

if.end44:                                         ; preds = %if.then42, %land.lhs.true38, %land.lhs.true, %cond.end
  %52 = load ptr, ptr %src_channel, align 8
  %_CmdBuffer45 = getelementptr inbounds %struct.ImDrawChannel, ptr %52, i32 0, i32 0
  %Size46 = getelementptr inbounds %struct.ImVector.32, ptr %_CmdBuffer45, i32 0, i32 0
  %53 = load i32, ptr %Size46, align 8
  %cmp47 = icmp ne i32 %53, 1
  br i1 %cmp47, label %if.then48, label %if.end49

if.then48:                                        ; preds = %if.end44
  br label %for.inc94

if.end49:                                         ; preds = %if.end44
  %54 = load ptr, ptr %column, align 8
  %Flags = getelementptr inbounds %struct.ImGuiTableColumn, ptr %54, i32 0, i32 0
  %55 = load i32, ptr %Flags, align 4
  %and50 = and i32 %55, 256
  %tobool51 = icmp ne i32 %and50, 0
  br i1 %tobool51, label %if.end67, label %if.then52

if.then52:                                        ; preds = %if.end49
  %56 = load i8, ptr %has_freeze_v, align 1
  %tobool53 = trunc i8 %56 to i1
  br i1 %tobool53, label %if.else, label %if.then54

if.then54:                                        ; preds = %if.then52
  %57 = load ptr, ptr %column, align 8
  %ContentMaxXUnfrozen = getelementptr inbounds %struct.ImGuiTableColumn, ptr %57, i32 0, i32 14
  %58 = load float, ptr %ContentMaxXUnfrozen, align 4
  %59 = load ptr, ptr %column, align 8
  %ContentMaxXHeadersUsed = getelementptr inbounds %struct.ImGuiTableColumn, ptr %59, i32 0, i32 15
  %60 = load float, ptr %ContentMaxXHeadersUsed, align 4
  %call55 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %58, float noundef %60)
  store float %call55, ptr %content_max_x, align 4
  br label %if.end63

if.else:                                          ; preds = %if.then52
  %61 = load i32, ptr %merge_group_sub_n, align 4
  %cmp56 = icmp eq i32 %61, 0
  br i1 %cmp56, label %if.then57, label %if.else60

if.then57:                                        ; preds = %if.else
  %62 = load ptr, ptr %column, align 8
  %ContentMaxXFrozen = getelementptr inbounds %struct.ImGuiTableColumn, ptr %62, i32 0, i32 13
  %63 = load float, ptr %ContentMaxXFrozen, align 4
  %64 = load ptr, ptr %column, align 8
  %ContentMaxXHeadersUsed58 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %64, i32 0, i32 15
  %65 = load float, ptr %ContentMaxXHeadersUsed58, align 4
  %call59 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %63, float noundef %65)
  store float %call59, ptr %content_max_x, align 4
  br label %if.end62

if.else60:                                        ; preds = %if.else
  %66 = load ptr, ptr %column, align 8
  %ContentMaxXUnfrozen61 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %66, i32 0, i32 14
  %67 = load float, ptr %ContentMaxXUnfrozen61, align 4
  store float %67, ptr %content_max_x, align 4
  br label %if.end62

if.end62:                                         ; preds = %if.else60, %if.then57
  br label %if.end63

if.end63:                                         ; preds = %if.end62, %if.then54
  %68 = load float, ptr %content_max_x, align 4
  %69 = load ptr, ptr %column, align 8
  %ClipRect = getelementptr inbounds %struct.ImGuiTableColumn, ptr %69, i32 0, i32 8
  %Max = getelementptr inbounds %struct.ImRect, ptr %ClipRect, i32 0, i32 1
  %x = getelementptr inbounds %struct.ImVec2, ptr %Max, i32 0, i32 0
  %70 = load float, ptr %x, align 4
  %cmp64 = fcmp ogt float %68, %70
  br i1 %cmp64, label %if.then65, label %if.end66

if.then65:                                        ; preds = %if.end63
  br label %for.inc94

if.end66:                                         ; preds = %if.end63
  br label %if.end67

if.end67:                                         ; preds = %if.end66, %if.end49
  %71 = load i8, ptr %has_freeze_h, align 1
  %tobool68 = trunc i8 %71 to i1
  br i1 %tobool68, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end67
  %72 = load i32, ptr %column_n, align 4
  %73 = load ptr, ptr %table.addr, align 8
  %FreezeColumnsCount69 = getelementptr inbounds %struct.ImGuiTable, ptr %73, i32 0, i32 87
  %74 = load i16, ptr %FreezeColumnsCount69, align 4
  %conv70 = sext i16 %74 to i32
  %cmp71 = icmp slt i32 %72, %conv70
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end67
  %75 = phi i1 [ false, %if.end67 ], [ %cmp71, %land.rhs ]
  %cond72 = select i1 %75, i32 0, i32 1
  %76 = load i8, ptr %has_freeze_v, align 1
  %tobool73 = trunc i8 %76 to i1
  br i1 %tobool73, label %land.rhs74, label %land.end76

land.rhs74:                                       ; preds = %land.end
  %77 = load i32, ptr %merge_group_sub_n, align 4
  %cmp75 = icmp eq i32 %77, 0
  br label %land.end76

land.end76:                                       ; preds = %land.rhs74, %land.end
  %78 = phi i1 [ false, %land.end ], [ %cmp75, %land.rhs74 ]
  %cond77 = select i1 %78, i32 0, i32 2
  %add78 = add nsw i32 %cond72, %cond77
  store i32 %add78, ptr %merge_group_n, align 4
  %79 = load i32, ptr %merge_group_n, align 4
  %idxprom79 = sext i32 %79 to i64
  %arrayidx80 = getelementptr inbounds [4 x %struct.MergeGroup], ptr %merge_groups, i64 0, i64 %idxprom79
  store ptr %arrayidx80, ptr %merge_group, align 8
  %80 = load ptr, ptr %merge_group, align 8
  %ChannelsCount = getelementptr inbounds %struct.MergeGroup, ptr %80, i32 0, i32 1
  %81 = load i32, ptr %ChannelsCount, align 8
  %cmp81 = icmp eq i32 %81, 0
  br i1 %cmp81, label %if.then82, label %if.end84

if.then82:                                        ; preds = %land.end76
  call void @_ZN6ImRectC2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp, float noundef 0x47EFFFFFE0000000, float noundef 0x47EFFFFFE0000000, float noundef 0xC7EFFFFFE0000000, float noundef 0xC7EFFFFFE0000000)
  %82 = load ptr, ptr %merge_group, align 8
  %ClipRect83 = getelementptr inbounds %struct.MergeGroup, ptr %82, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %ClipRect83, ptr align 4 %ref.tmp, i64 16, i1 false)
  br label %if.end84

if.end84:                                         ; preds = %if.then82, %land.end76
  %83 = load ptr, ptr %merge_group, align 8
  %ChannelsMask85 = getelementptr inbounds %struct.MergeGroup, ptr %83, i32 0, i32 2
  %84 = load ptr, ptr %ChannelsMask85, align 8
  %85 = load i32, ptr %channel_no, align 4
  call void @_Z16ImBitArraySetBitPji(ptr noundef %84, i32 noundef %85)
  %86 = load ptr, ptr %merge_group, align 8
  %ChannelsCount86 = getelementptr inbounds %struct.MergeGroup, ptr %86, i32 0, i32 1
  %87 = load i32, ptr %ChannelsCount86, align 8
  %inc87 = add nsw i32 %87, 1
  store i32 %inc87, ptr %ChannelsCount86, align 8
  %88 = load ptr, ptr %merge_group, align 8
  %ClipRect88 = getelementptr inbounds %struct.MergeGroup, ptr %88, i32 0, i32 0
  %89 = load ptr, ptr %src_channel, align 8
  %_CmdBuffer90 = getelementptr inbounds %struct.ImDrawChannel, ptr %89, i32 0, i32 0
  %call91 = call noundef nonnull align 8 dereferenceable(56) ptr @_ZN8ImVectorI9ImDrawCmdEixEi(ptr noundef nonnull align 8 dereferenceable(16) %_CmdBuffer90, i32 noundef 0)
  %ClipRect92 = getelementptr inbounds %struct.ImDrawCmd, ptr %call91, i32 0, i32 0
  call void @_ZN6ImRectC2ERK6ImVec4(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp89, ptr noundef nonnull align 4 dereferenceable(16) %ClipRect92)
  call void @_ZN6ImRect3AddERKS_(ptr noundef nonnull align 4 dereferenceable(16) %ClipRect88, ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp89)
  %90 = load i32, ptr %merge_group_n, align 4
  %shl93 = shl i32 1, %90
  %91 = load i32, ptr %merge_group_mask, align 4
  %or = or i32 %91, %shl93
  store i32 %or, ptr %merge_group_mask, align 4
  br label %for.inc94

for.inc94:                                        ; preds = %if.end84, %if.then65, %if.then48
  %92 = load i32, ptr %merge_group_sub_n, align 4
  %inc95 = add nsw i32 %92, 1
  store i32 %inc95, ptr %merge_group_sub_n, align 4
  br label %for.cond27, !llvm.loop !31

for.end96:                                        ; preds = %for.cond27
  %93 = load ptr, ptr %column, align 8
  %DrawChannelCurrent = getelementptr inbounds %struct.ImGuiTableColumn, ptr %93, i32 0, i32 23
  store i16 -1, ptr %DrawChannelCurrent, align 4
  br label %for.inc97

for.inc97:                                        ; preds = %for.end96, %if.then
  %94 = load i32, ptr %column_n, align 4
  %inc98 = add nsw i32 %94, 1
  store i32 %inc98, ptr %column_n, align 4
  br label %for.cond18, !llvm.loop !32

for.end99:                                        ; preds = %for.cond18
  %95 = load i32, ptr %merge_group_mask, align 4
  %cmp100 = icmp ne i32 %95, 0
  br i1 %cmp100, label %if.then101, label %if.end272

if.then101:                                       ; preds = %for.end99
  store i32 2, ptr %LEADING_DRAW_CHANNELS, align 4
  %96 = load ptr, ptr %g, align 8
  %DrawChannelsTempMergeBuffer = getelementptr inbounds %struct.ImGuiContext, ptr %96, i32 0, i32 169
  %97 = load ptr, ptr %splitter, align 8
  %_Count = getelementptr inbounds %struct.ImDrawListSplitter, ptr %97, i32 0, i32 1
  %98 = load i32, ptr %_Count, align 4
  %sub = sub nsw i32 %98, 2
  call void @_ZN8ImVectorI13ImDrawChannelE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %DrawChannelsTempMergeBuffer, i32 noundef %sub)
  %99 = load ptr, ptr %g, align 8
  %DrawChannelsTempMergeBuffer102 = getelementptr inbounds %struct.ImGuiContext, ptr %99, i32 0, i32 169
  %Data103 = getelementptr inbounds %struct.ImVector.20, ptr %DrawChannelsTempMergeBuffer102, i32 0, i32 2
  %100 = load ptr, ptr %Data103, align 8
  store ptr %100, ptr %dst_tmp, align 8
  %101 = load ptr, ptr %remaining_mask, align 8
  %102 = load ptr, ptr %splitter, align 8
  %_Count104 = getelementptr inbounds %struct.ImDrawListSplitter, ptr %102, i32 0, i32 1
  %103 = load i32, ptr %_Count104, align 4
  call void @_Z21ImBitArraySetBitRangePjii(ptr noundef %101, i32 noundef 2, i32 noundef %103)
  %104 = load ptr, ptr %remaining_mask, align 8
  %105 = load ptr, ptr %table.addr, align 8
  %Bg2DrawChannelUnfrozen = getelementptr inbounds %struct.ImGuiTable, ptr %105, i32 0, i32 91
  %106 = load i16, ptr %Bg2DrawChannelUnfrozen, align 4
  %conv105 = zext i16 %106 to i32
  call void @_Z18ImBitArrayClearBitPji(ptr noundef %104, i32 noundef %conv105)
  %107 = load ptr, ptr %splitter, align 8
  %_Count106 = getelementptr inbounds %struct.ImDrawListSplitter, ptr %107, i32 0, i32 1
  %108 = load i32, ptr %_Count106, align 4
  %109 = load i8, ptr %has_freeze_v, align 1
  %tobool107 = trunc i8 %109 to i1
  %cond108 = select i1 %tobool107, i32 3, i32 2
  %sub109 = sub nsw i32 %108, %cond108
  store i32 %sub109, ptr %remaining_count, align 4
  %110 = load ptr, ptr %table.addr, align 8
  %HostClipRect = getelementptr inbounds %struct.ImGuiTable, ptr %110, i32 0, i32 53
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %host_rect, ptr align 8 %HostClipRect, i64 16, i1 false)
  store i32 0, ptr %merge_group_n110, align 4
  br label %for.cond111

for.cond111:                                      ; preds = %for.inc235, %if.then101
  %111 = load i32, ptr %merge_group_n110, align 4
  %cmp112 = icmp slt i32 %111, 4
  br i1 %cmp112, label %for.body113, label %for.end237

for.body113:                                      ; preds = %for.cond111
  %112 = load i32, ptr %merge_group_n110, align 4
  %idxprom114 = sext i32 %112 to i64
  %arrayidx115 = getelementptr inbounds [4 x %struct.MergeGroup], ptr %merge_groups, i64 0, i64 %idxprom114
  %ChannelsCount116 = getelementptr inbounds %struct.MergeGroup, ptr %arrayidx115, i32 0, i32 1
  %113 = load i32, ptr %ChannelsCount116, align 16
  store i32 %113, ptr %merge_channels_count, align 4
  %114 = load i32, ptr %merge_channels_count, align 4
  %tobool117 = icmp ne i32 %114, 0
  br i1 %tobool117, label %if.then118, label %if.end224

if.then118:                                       ; preds = %for.body113
  %115 = load i32, ptr %merge_group_n110, align 4
  %idxprom120 = sext i32 %115 to i64
  %arrayidx121 = getelementptr inbounds [4 x %struct.MergeGroup], ptr %merge_groups, i64 0, i64 %idxprom120
  store ptr %arrayidx121, ptr %merge_group119, align 8
  %116 = load ptr, ptr %merge_group119, align 8
  %ClipRect122 = getelementptr inbounds %struct.MergeGroup, ptr %116, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %merge_clip_rect, ptr align 8 %ClipRect122, i64 16, i1 false)
  %117 = load i32, ptr %merge_group_n110, align 4
  %and123 = and i32 %117, 1
  %cmp124 = icmp eq i32 %and123, 0
  br i1 %cmp124, label %if.then126, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then118
  %118 = load i8, ptr %has_freeze_h, align 1
  %tobool125 = trunc i8 %118 to i1
  br i1 %tobool125, label %if.end133, label %if.then126

if.then126:                                       ; preds = %lor.lhs.false, %if.then118
  %Min = getelementptr inbounds %struct.ImRect, ptr %merge_clip_rect, i32 0, i32 0
  %x127 = getelementptr inbounds %struct.ImVec2, ptr %Min, i32 0, i32 0
  %119 = load float, ptr %x127, align 4
  %Min128 = getelementptr inbounds %struct.ImRect, ptr %host_rect, i32 0, i32 0
  %x129 = getelementptr inbounds %struct.ImVec2, ptr %Min128, i32 0, i32 0
  %120 = load float, ptr %x129, align 4
  %call130 = call noundef float @_ZL5ImMinIfET_S0_S0_(float noundef %119, float noundef %120)
  %Min131 = getelementptr inbounds %struct.ImRect, ptr %merge_clip_rect, i32 0, i32 0
  %x132 = getelementptr inbounds %struct.ImVec2, ptr %Min131, i32 0, i32 0
  store float %call130, ptr %x132, align 4
  br label %if.end133

if.end133:                                        ; preds = %if.then126, %lor.lhs.false
  %121 = load i32, ptr %merge_group_n110, align 4
  %and134 = and i32 %121, 2
  %cmp135 = icmp eq i32 %and134, 0
  br i1 %cmp135, label %if.then138, label %lor.lhs.false136

lor.lhs.false136:                                 ; preds = %if.end133
  %122 = load i8, ptr %has_freeze_v, align 1
  %tobool137 = trunc i8 %122 to i1
  br i1 %tobool137, label %if.end145, label %if.then138

if.then138:                                       ; preds = %lor.lhs.false136, %if.end133
  %Min139 = getelementptr inbounds %struct.ImRect, ptr %merge_clip_rect, i32 0, i32 0
  %y = getelementptr inbounds %struct.ImVec2, ptr %Min139, i32 0, i32 1
  %123 = load float, ptr %y, align 4
  %Min140 = getelementptr inbounds %struct.ImRect, ptr %host_rect, i32 0, i32 0
  %y141 = getelementptr inbounds %struct.ImVec2, ptr %Min140, i32 0, i32 1
  %124 = load float, ptr %y141, align 4
  %call142 = call noundef float @_ZL5ImMinIfET_S0_S0_(float noundef %123, float noundef %124)
  %Min143 = getelementptr inbounds %struct.ImRect, ptr %merge_clip_rect, i32 0, i32 0
  %y144 = getelementptr inbounds %struct.ImVec2, ptr %Min143, i32 0, i32 1
  store float %call142, ptr %y144, align 4
  br label %if.end145

if.end145:                                        ; preds = %if.then138, %lor.lhs.false136
  %125 = load i32, ptr %merge_group_n110, align 4
  %and146 = and i32 %125, 1
  %cmp147 = icmp ne i32 %and146, 0
  br i1 %cmp147, label %if.then148, label %if.end156

if.then148:                                       ; preds = %if.end145
  %Max149 = getelementptr inbounds %struct.ImRect, ptr %merge_clip_rect, i32 0, i32 1
  %x150 = getelementptr inbounds %struct.ImVec2, ptr %Max149, i32 0, i32 0
  %126 = load float, ptr %x150, align 4
  %Max151 = getelementptr inbounds %struct.ImRect, ptr %host_rect, i32 0, i32 1
  %x152 = getelementptr inbounds %struct.ImVec2, ptr %Max151, i32 0, i32 0
  %127 = load float, ptr %x152, align 4
  %call153 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %126, float noundef %127)
  %Max154 = getelementptr inbounds %struct.ImRect, ptr %merge_clip_rect, i32 0, i32 1
  %x155 = getelementptr inbounds %struct.ImVec2, ptr %Max154, i32 0, i32 0
  store float %call153, ptr %x155, align 4
  br label %if.end156

if.end156:                                        ; preds = %if.then148, %if.end145
  %128 = load i32, ptr %merge_group_n110, align 4
  %and157 = and i32 %128, 2
  %cmp158 = icmp ne i32 %and157, 0
  br i1 %cmp158, label %land.lhs.true159, label %if.end171

land.lhs.true159:                                 ; preds = %if.end156
  %129 = load ptr, ptr %table.addr, align 8
  %Flags160 = getelementptr inbounds %struct.ImGuiTable, ptr %129, i32 0, i32 1
  %130 = load i32, ptr %Flags160, align 4
  %and161 = and i32 %130, 131072
  %cmp162 = icmp eq i32 %and161, 0
  br i1 %cmp162, label %if.then163, label %if.end171

if.then163:                                       ; preds = %land.lhs.true159
  %Max164 = getelementptr inbounds %struct.ImRect, ptr %merge_clip_rect, i32 0, i32 1
  %y165 = getelementptr inbounds %struct.ImVec2, ptr %Max164, i32 0, i32 1
  %131 = load float, ptr %y165, align 4
  %Max166 = getelementptr inbounds %struct.ImRect, ptr %host_rect, i32 0, i32 1
  %y167 = getelementptr inbounds %struct.ImVec2, ptr %Max166, i32 0, i32 1
  %132 = load float, ptr %y167, align 4
  %call168 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %131, float noundef %132)
  %Max169 = getelementptr inbounds %struct.ImRect, ptr %merge_clip_rect, i32 0, i32 1
  %y170 = getelementptr inbounds %struct.ImVec2, ptr %Max169, i32 0, i32 1
  store float %call168, ptr %y170, align 4
  br label %if.end171

if.end171:                                        ; preds = %if.then163, %land.lhs.true159, %if.end156
  %133 = load ptr, ptr %merge_group119, align 8
  %ChannelsCount172 = getelementptr inbounds %struct.MergeGroup, ptr %133, i32 0, i32 1
  %134 = load i32, ptr %ChannelsCount172, align 8
  %135 = load i32, ptr %remaining_count, align 4
  %sub173 = sub nsw i32 %135, %134
  store i32 %sub173, ptr %remaining_count, align 4
  store i32 0, ptr %n174, align 4
  br label %for.cond175

for.cond175:                                      ; preds = %for.inc185, %if.end171
  %136 = load i32, ptr %n174, align 4
  %137 = load i32, ptr %size_for_masks_bitarrays_one, align 4
  %shr176 = ashr i32 %137, 2
  %cmp177 = icmp slt i32 %136, %shr176
  br i1 %cmp177, label %for.body178, label %for.end187

for.body178:                                      ; preds = %for.cond175
  %138 = load ptr, ptr %merge_group119, align 8
  %ChannelsMask179 = getelementptr inbounds %struct.MergeGroup, ptr %138, i32 0, i32 2
  %139 = load ptr, ptr %ChannelsMask179, align 8
  %140 = load i32, ptr %n174, align 4
  %idxprom180 = sext i32 %140 to i64
  %arrayidx181 = getelementptr inbounds i32, ptr %139, i64 %idxprom180
  %141 = load i32, ptr %arrayidx181, align 4
  %not = xor i32 %141, -1
  %142 = load ptr, ptr %remaining_mask, align 8
  %143 = load i32, ptr %n174, align 4
  %idxprom182 = sext i32 %143 to i64
  %arrayidx183 = getelementptr inbounds i32, ptr %142, i64 %idxprom182
  %144 = load i32, ptr %arrayidx183, align 4
  %and184 = and i32 %144, %not
  store i32 %and184, ptr %arrayidx183, align 4
  br label %for.inc185

for.inc185:                                       ; preds = %for.body178
  %145 = load i32, ptr %n174, align 4
  %inc186 = add nsw i32 %145, 1
  store i32 %inc186, ptr %n174, align 4
  br label %for.cond175, !llvm.loop !33

for.end187:                                       ; preds = %for.cond175
  store i32 0, ptr %n188, align 4
  br label %for.cond189

for.cond189:                                      ; preds = %for.inc221, %for.end187
  %146 = load i32, ptr %n188, align 4
  %147 = load ptr, ptr %splitter, align 8
  %_Count190 = getelementptr inbounds %struct.ImDrawListSplitter, ptr %147, i32 0, i32 1
  %148 = load i32, ptr %_Count190, align 4
  %cmp191 = icmp slt i32 %146, %148
  br i1 %cmp191, label %land.rhs192, label %land.end194

land.rhs192:                                      ; preds = %for.cond189
  %149 = load i32, ptr %merge_channels_count, align 4
  %cmp193 = icmp ne i32 %149, 0
  br label %land.end194

land.end194:                                      ; preds = %land.rhs192, %for.cond189
  %150 = phi i1 [ false, %for.cond189 ], [ %cmp193, %land.rhs192 ]
  br i1 %150, label %for.body195, label %for.end223

for.body195:                                      ; preds = %land.end194
  %151 = load ptr, ptr %merge_group119, align 8
  %ChannelsMask196 = getelementptr inbounds %struct.MergeGroup, ptr %151, i32 0, i32 2
  %152 = load ptr, ptr %ChannelsMask196, align 8
  %153 = load i32, ptr %n188, align 4
  %shr197 = ashr i32 %153, 5
  %idxprom198 = sext i32 %shr197 to i64
  %arrayidx199 = getelementptr inbounds i32, ptr %152, i64 %idxprom198
  %154 = load i32, ptr %arrayidx199, align 4
  %155 = load i32, ptr %n188, align 4
  %and200 = and i32 %155, 31
  %shl201 = shl i32 1, %and200
  %and202 = and i32 %154, %shl201
  %cmp203 = icmp ne i32 %and202, 0
  br i1 %cmp203, label %if.end205, label %if.then204

if.then204:                                       ; preds = %for.body195
  br label %for.inc221

if.end205:                                        ; preds = %for.body195
  %156 = load i32, ptr %n188, align 4
  %and206 = and i32 %156, 31
  %shl207 = shl i32 1, %and206
  %not208 = xor i32 %shl207, -1
  %157 = load ptr, ptr %merge_group119, align 8
  %ChannelsMask209 = getelementptr inbounds %struct.MergeGroup, ptr %157, i32 0, i32 2
  %158 = load ptr, ptr %ChannelsMask209, align 8
  %159 = load i32, ptr %n188, align 4
  %shr210 = ashr i32 %159, 5
  %idxprom211 = sext i32 %shr210 to i64
  %arrayidx212 = getelementptr inbounds i32, ptr %158, i64 %idxprom211
  %160 = load i32, ptr %arrayidx212, align 4
  %and213 = and i32 %160, %not208
  store i32 %and213, ptr %arrayidx212, align 4
  %161 = load i32, ptr %merge_channels_count, align 4
  %dec = add nsw i32 %161, -1
  store i32 %dec, ptr %merge_channels_count, align 4
  %162 = load ptr, ptr %splitter, align 8
  %_Channels214 = getelementptr inbounds %struct.ImDrawListSplitter, ptr %162, i32 0, i32 2
  %163 = load i32, ptr %n188, align 4
  %call215 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZN8ImVectorI13ImDrawChannelEixEi(ptr noundef nonnull align 8 dereferenceable(16) %_Channels214, i32 noundef %163)
  store ptr %call215, ptr %channel, align 8
  %call217 = call { <2 x float>, <2 x float> } @_ZNK6ImRect6ToVec4Ev(ptr noundef nonnull align 4 dereferenceable(16) %merge_clip_rect)
  %164 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %ref.tmp216, i32 0, i32 0
  %165 = extractvalue { <2 x float>, <2 x float> } %call217, 0
  store <2 x float> %165, ptr %164, align 4
  %166 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %ref.tmp216, i32 0, i32 1
  %167 = extractvalue { <2 x float>, <2 x float> } %call217, 1
  store <2 x float> %167, ptr %166, align 4
  %168 = load ptr, ptr %channel, align 8
  %_CmdBuffer218 = getelementptr inbounds %struct.ImDrawChannel, ptr %168, i32 0, i32 0
  %call219 = call noundef nonnull align 8 dereferenceable(56) ptr @_ZN8ImVectorI9ImDrawCmdEixEi(ptr noundef nonnull align 8 dereferenceable(16) %_CmdBuffer218, i32 noundef 0)
  %ClipRect220 = getelementptr inbounds %struct.ImDrawCmd, ptr %call219, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %ClipRect220, ptr align 4 %ref.tmp216, i64 16, i1 false)
  %169 = load ptr, ptr %dst_tmp, align 8
  %incdec.ptr = getelementptr inbounds %struct.ImDrawChannel, ptr %169, i32 1
  store ptr %incdec.ptr, ptr %dst_tmp, align 8
  %170 = load ptr, ptr %channel, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %169, ptr align 8 %170, i64 32, i1 false)
  br label %for.inc221

for.inc221:                                       ; preds = %if.end205, %if.then204
  %171 = load i32, ptr %n188, align 4
  %inc222 = add nsw i32 %171, 1
  store i32 %inc222, ptr %n188, align 4
  br label %for.cond189, !llvm.loop !34

for.end223:                                       ; preds = %land.end194
  br label %if.end224

if.end224:                                        ; preds = %for.end223, %for.body113
  %172 = load i32, ptr %merge_group_n110, align 4
  %cmp225 = icmp eq i32 %172, 1
  br i1 %cmp225, label %land.lhs.true226, label %if.end234

land.lhs.true226:                                 ; preds = %if.end224
  %173 = load i8, ptr %has_freeze_v, align 1
  %tobool227 = trunc i8 %173 to i1
  br i1 %tobool227, label %if.then228, label %if.end234

if.then228:                                       ; preds = %land.lhs.true226
  %174 = load ptr, ptr %dst_tmp, align 8
  %incdec.ptr229 = getelementptr inbounds %struct.ImDrawChannel, ptr %174, i32 1
  store ptr %incdec.ptr229, ptr %dst_tmp, align 8
  %175 = load ptr, ptr %splitter, align 8
  %_Channels230 = getelementptr inbounds %struct.ImDrawListSplitter, ptr %175, i32 0, i32 2
  %176 = load ptr, ptr %table.addr, align 8
  %Bg2DrawChannelUnfrozen231 = getelementptr inbounds %struct.ImGuiTable, ptr %176, i32 0, i32 91
  %177 = load i16, ptr %Bg2DrawChannelUnfrozen231, align 4
  %conv232 = zext i16 %177 to i32
  %call233 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZN8ImVectorI13ImDrawChannelEixEi(ptr noundef nonnull align 8 dereferenceable(16) %_Channels230, i32 noundef %conv232)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %174, ptr align 8 %call233, i64 32, i1 false)
  br label %if.end234

if.end234:                                        ; preds = %if.then228, %land.lhs.true226, %if.end224
  br label %for.inc235

for.inc235:                                       ; preds = %if.end234
  %178 = load i32, ptr %merge_group_n110, align 4
  %inc236 = add nsw i32 %178, 1
  store i32 %inc236, ptr %merge_group_n110, align 4
  br label %for.cond111, !llvm.loop !35

for.end237:                                       ; preds = %for.cond111
  store i32 0, ptr %n238, align 4
  br label %for.cond239

for.cond239:                                      ; preds = %for.inc260, %for.end237
  %179 = load i32, ptr %n238, align 4
  %180 = load ptr, ptr %splitter, align 8
  %_Count240 = getelementptr inbounds %struct.ImDrawListSplitter, ptr %180, i32 0, i32 1
  %181 = load i32, ptr %_Count240, align 4
  %cmp241 = icmp slt i32 %179, %181
  br i1 %cmp241, label %land.rhs242, label %land.end244

land.rhs242:                                      ; preds = %for.cond239
  %182 = load i32, ptr %remaining_count, align 4
  %cmp243 = icmp ne i32 %182, 0
  br label %land.end244

land.end244:                                      ; preds = %land.rhs242, %for.cond239
  %183 = phi i1 [ false, %for.cond239 ], [ %cmp243, %land.rhs242 ]
  br i1 %183, label %for.body245, label %for.end262

for.body245:                                      ; preds = %land.end244
  %184 = load ptr, ptr %remaining_mask, align 8
  %185 = load i32, ptr %n238, align 4
  %shr246 = ashr i32 %185, 5
  %idxprom247 = sext i32 %shr246 to i64
  %arrayidx248 = getelementptr inbounds i32, ptr %184, i64 %idxprom247
  %186 = load i32, ptr %arrayidx248, align 4
  %187 = load i32, ptr %n238, align 4
  %and249 = and i32 %187, 31
  %shl250 = shl i32 1, %and249
  %and251 = and i32 %186, %shl250
  %cmp252 = icmp ne i32 %and251, 0
  br i1 %cmp252, label %if.end254, label %if.then253

if.then253:                                       ; preds = %for.body245
  br label %for.inc260

if.end254:                                        ; preds = %for.body245
  %188 = load ptr, ptr %splitter, align 8
  %_Channels256 = getelementptr inbounds %struct.ImDrawListSplitter, ptr %188, i32 0, i32 2
  %189 = load i32, ptr %n238, align 4
  %call257 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZN8ImVectorI13ImDrawChannelEixEi(ptr noundef nonnull align 8 dereferenceable(16) %_Channels256, i32 noundef %189)
  store ptr %call257, ptr %channel255, align 8
  %190 = load ptr, ptr %dst_tmp, align 8
  %incdec.ptr258 = getelementptr inbounds %struct.ImDrawChannel, ptr %190, i32 1
  store ptr %incdec.ptr258, ptr %dst_tmp, align 8
  %191 = load ptr, ptr %channel255, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %190, ptr align 8 %191, i64 32, i1 false)
  %192 = load i32, ptr %remaining_count, align 4
  %dec259 = add nsw i32 %192, -1
  store i32 %dec259, ptr %remaining_count, align 4
  br label %for.inc260

for.inc260:                                       ; preds = %if.end254, %if.then253
  %193 = load i32, ptr %n238, align 4
  %inc261 = add nsw i32 %193, 1
  store i32 %inc261, ptr %n238, align 4
  br label %for.cond239, !llvm.loop !36

for.end262:                                       ; preds = %land.end244
  %194 = load ptr, ptr %splitter, align 8
  %_Channels263 = getelementptr inbounds %struct.ImDrawListSplitter, ptr %194, i32 0, i32 2
  %Data264 = getelementptr inbounds %struct.ImVector.20, ptr %_Channels263, i32 0, i32 2
  %195 = load ptr, ptr %Data264, align 8
  %add.ptr265 = getelementptr inbounds %struct.ImDrawChannel, ptr %195, i64 2
  %196 = load ptr, ptr %g, align 8
  %DrawChannelsTempMergeBuffer266 = getelementptr inbounds %struct.ImGuiContext, ptr %196, i32 0, i32 169
  %Data267 = getelementptr inbounds %struct.ImVector.20, ptr %DrawChannelsTempMergeBuffer266, i32 0, i32 2
  %197 = load ptr, ptr %Data267, align 8
  %198 = load ptr, ptr %splitter, align 8
  %_Count268 = getelementptr inbounds %struct.ImDrawListSplitter, ptr %198, i32 0, i32 1
  %199 = load i32, ptr %_Count268, align 4
  %sub269 = sub nsw i32 %199, 2
  %conv270 = sext i32 %sub269 to i64
  %mul271 = mul i64 %conv270, 32
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %add.ptr265, ptr align 8 %197, i64 %mul271, i1 false)
  br label %if.end272

if.end272:                                        ; preds = %for.end262, %for.end99
  ret void
}

declare void @_ZN18ImDrawListSplitter5MergeEP10ImDrawList(ptr noundef nonnull align 8 dereferenceable(24), ptr noundef) #1

declare void @_ZN5ImGui17SetScrollFromPosXEP11ImGuiWindowff(ptr noundef, float noundef, float noundef) #1

declare void @_ZN5ImGui5PopIDEv() #1

declare void @_ZN5ImGui8EndChildEv() #1

declare void @_ZN5ImGui8ItemSizeERK6ImVec2f(ptr noundef nonnull align 4 dereferenceable(8), float noundef) #1

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui17TableSaveSettingsEP10ImGuiTable(ptr noundef %table) #0 {
entry:
  %table.addr = alloca ptr, align 8
  %g = alloca ptr, align 8
  %settings = alloca ptr, align 8
  %column = alloca ptr, align 8
  %column_settings = alloca ptr, align 8
  %save_ref_scale = alloca i8, align 1
  %n = alloca i32, align 4
  %width_or_weight = alloca float, align 4
  store ptr %table, ptr %table.addr, align 8
  %0 = load ptr, ptr %table.addr, align 8
  %IsSettingsDirty = getelementptr inbounds %struct.ImGuiTable, ptr %0, i32 0, i32 100
  store i8 0, ptr %IsSettingsDirty, align 2
  %1 = load ptr, ptr %table.addr, align 8
  %Flags = getelementptr inbounds %struct.ImGuiTable, ptr %1, i32 0, i32 1
  %2 = load i32, ptr %Flags, align 4
  %and = and i32 %2, 16
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr @GImGui, align 8
  store ptr %3, ptr %g, align 8
  %4 = load ptr, ptr %table.addr, align 8
  %call = call noundef ptr @_ZN5ImGui21TableGetBoundSettingsEP10ImGuiTable(ptr noundef %4)
  store ptr %call, ptr %settings, align 8
  %5 = load ptr, ptr %settings, align 8
  %cmp = icmp eq ptr %5, null
  br i1 %cmp, label %if.then1, label %if.end4

if.then1:                                         ; preds = %if.end
  %6 = load ptr, ptr %table.addr, align 8
  %ID = getelementptr inbounds %struct.ImGuiTable, ptr %6, i32 0, i32 0
  %7 = load i32, ptr %ID, align 8
  %8 = load ptr, ptr %table.addr, align 8
  %ColumnsCount = getelementptr inbounds %struct.ImGuiTable, ptr %8, i32 0, i32 13
  %9 = load i32, ptr %ColumnsCount, align 4
  %call2 = call noundef ptr @_ZN5ImGui19TableSettingsCreateEji(i32 noundef %7, i32 noundef %9)
  store ptr %call2, ptr %settings, align 8
  %10 = load ptr, ptr %g, align 8
  %SettingsTables = getelementptr inbounds %struct.ImGuiContext, ptr %10, i32 0, i32 218
  %11 = load ptr, ptr %settings, align 8
  %call3 = call noundef i32 @_ZN13ImChunkStreamI18ImGuiTableSettingsE15offset_from_ptrEPKS0_(ptr noundef nonnull align 8 dereferenceable(16) %SettingsTables, ptr noundef %11)
  %12 = load ptr, ptr %table.addr, align 8
  %SettingsOffset = getelementptr inbounds %struct.ImGuiTable, ptr %12, i32 0, i32 11
  store i32 %call3, ptr %SettingsOffset, align 4
  br label %if.end4

if.end4:                                          ; preds = %if.then1, %if.end
  %13 = load ptr, ptr %table.addr, align 8
  %ColumnsCount5 = getelementptr inbounds %struct.ImGuiTable, ptr %13, i32 0, i32 13
  %14 = load i32, ptr %ColumnsCount5, align 4
  %conv = trunc i32 %14 to i16
  %15 = load ptr, ptr %settings, align 8
  %ColumnsCount6 = getelementptr inbounds %struct.ImGuiTableSettings, ptr %15, i32 0, i32 3
  store i16 %conv, ptr %ColumnsCount6, align 4
  %16 = load ptr, ptr %table.addr, align 8
  %Columns = getelementptr inbounds %struct.ImGuiTable, ptr %16, i32 0, i32 4
  %Data = getelementptr inbounds %struct.ImSpan, ptr %Columns, i32 0, i32 0
  %17 = load ptr, ptr %Data, align 8
  store ptr %17, ptr %column, align 8
  %18 = load ptr, ptr %settings, align 8
  %call7 = call noundef ptr @_ZN18ImGuiTableSettings17GetColumnSettingsEv(ptr noundef nonnull align 4 dereferenceable(17) %18)
  store ptr %call7, ptr %column_settings, align 8
  store i8 0, ptr %save_ref_scale, align 1
  %19 = load ptr, ptr %settings, align 8
  %SaveFlags = getelementptr inbounds %struct.ImGuiTableSettings, ptr %19, i32 0, i32 1
  store i32 0, ptr %SaveFlags, align 4
  store i32 0, ptr %n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end4
  %20 = load i32, ptr %n, align 4
  %21 = load ptr, ptr %table.addr, align 8
  %ColumnsCount8 = getelementptr inbounds %struct.ImGuiTable, ptr %21, i32 0, i32 13
  %22 = load i32, ptr %ColumnsCount8, align 4
  %cmp9 = icmp slt i32 %20, %22
  br i1 %cmp9, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %23 = load ptr, ptr %column, align 8
  %Flags10 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %23, i32 0, i32 0
  %24 = load i32, ptr %Flags10, align 4
  %and11 = and i32 %24, 8
  %tobool12 = icmp ne i32 %and11, 0
  br i1 %tobool12, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  %25 = load ptr, ptr %column, align 8
  %StretchWeight = getelementptr inbounds %struct.ImGuiTableColumn, ptr %25, i32 0, i32 6
  %26 = load float, ptr %StretchWeight, align 4
  br label %cond.end

cond.false:                                       ; preds = %for.body
  %27 = load ptr, ptr %column, align 8
  %WidthRequest = getelementptr inbounds %struct.ImGuiTableColumn, ptr %27, i32 0, i32 4
  %28 = load float, ptr %WidthRequest, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi float [ %26, %cond.true ], [ %28, %cond.false ]
  store float %cond, ptr %width_or_weight, align 4
  %29 = load float, ptr %width_or_weight, align 4
  %30 = load ptr, ptr %column_settings, align 8
  %WidthOrWeight = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %30, i32 0, i32 0
  store float %29, ptr %WidthOrWeight, align 4
  %31 = load i32, ptr %n, align 4
  %conv13 = trunc i32 %31 to i16
  %32 = load ptr, ptr %column_settings, align 8
  %Index = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %32, i32 0, i32 2
  store i16 %conv13, ptr %Index, align 4
  %33 = load ptr, ptr %column, align 8
  %DisplayOrder = getelementptr inbounds %struct.ImGuiTableColumn, ptr %33, i32 0, i32 18
  %34 = load i16, ptr %DisplayOrder, align 2
  %35 = load ptr, ptr %column_settings, align 8
  %DisplayOrder14 = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %35, i32 0, i32 3
  store i16 %34, ptr %DisplayOrder14, align 2
  %36 = load ptr, ptr %column, align 8
  %SortOrder = getelementptr inbounds %struct.ImGuiTableColumn, ptr %36, i32 0, i32 22
  %37 = load i16, ptr %SortOrder, align 2
  %38 = load ptr, ptr %column_settings, align 8
  %SortOrder15 = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %38, i32 0, i32 4
  store i16 %37, ptr %SortOrder15, align 4
  %39 = load ptr, ptr %column, align 8
  %SortDirection = getelementptr inbounds %struct.ImGuiTableColumn, ptr %39, i32 0, i32 37
  %bf.load = load i8, ptr %SortDirection, align 1
  %bf.clear = and i8 %bf.load, 3
  %40 = load ptr, ptr %column_settings, align 8
  %SortDirection16 = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %40, i32 0, i32 5
  %bf.load17 = load i8, ptr %SortDirection16, align 2
  %bf.value = and i8 %bf.clear, 3
  %bf.clear18 = and i8 %bf.load17, -4
  %bf.set = or i8 %bf.clear18, %bf.value
  store i8 %bf.set, ptr %SortDirection16, align 2
  %41 = load ptr, ptr %column, align 8
  %IsUserEnabled = getelementptr inbounds %struct.ImGuiTableColumn, ptr %41, i32 0, i32 27
  %42 = load i8, ptr %IsUserEnabled, align 1
  %tobool19 = trunc i8 %42 to i1
  %conv20 = zext i1 %tobool19 to i8
  %43 = load ptr, ptr %column_settings, align 8
  %IsEnabled = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %43, i32 0, i32 5
  %bf.load21 = load i8, ptr %IsEnabled, align 2
  %bf.value22 = and i8 %conv20, 1
  %bf.shl = shl i8 %bf.value22, 2
  %bf.clear23 = and i8 %bf.load21, -5
  %bf.set24 = or i8 %bf.clear23, %bf.shl
  store i8 %bf.set24, ptr %IsEnabled, align 2
  %44 = load ptr, ptr %column, align 8
  %Flags25 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %44, i32 0, i32 0
  %45 = load i32, ptr %Flags25, align 4
  %and26 = and i32 %45, 8
  %tobool27 = icmp ne i32 %and26, 0
  %cond28 = select i1 %tobool27, i32 1, i32 0
  %conv29 = trunc i32 %cond28 to i8
  %46 = load ptr, ptr %column_settings, align 8
  %IsStretch = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %46, i32 0, i32 5
  %bf.load30 = load i8, ptr %IsStretch, align 2
  %bf.value31 = and i8 %conv29, 1
  %bf.shl32 = shl i8 %bf.value31, 3
  %bf.clear33 = and i8 %bf.load30, -9
  %bf.set34 = or i8 %bf.clear33, %bf.shl32
  store i8 %bf.set34, ptr %IsStretch, align 2
  %47 = load ptr, ptr %column, align 8
  %Flags35 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %47, i32 0, i32 0
  %48 = load i32, ptr %Flags35, align 4
  %and36 = and i32 %48, 8
  %cmp37 = icmp eq i32 %and36, 0
  br i1 %cmp37, label %if.then38, label %if.end39

if.then38:                                        ; preds = %cond.end
  store i8 1, ptr %save_ref_scale, align 1
  br label %if.end39

if.end39:                                         ; preds = %if.then38, %cond.end
  %49 = load float, ptr %width_or_weight, align 4
  %50 = load ptr, ptr %column, align 8
  %InitStretchWeightOrWidth = getelementptr inbounds %struct.ImGuiTableColumn, ptr %50, i32 0, i32 7
  %51 = load float, ptr %InitStretchWeightOrWidth, align 4
  %cmp40 = fcmp une float %49, %51
  br i1 %cmp40, label %if.then41, label %if.end43

if.then41:                                        ; preds = %if.end39
  %52 = load ptr, ptr %settings, align 8
  %SaveFlags42 = getelementptr inbounds %struct.ImGuiTableSettings, ptr %52, i32 0, i32 1
  %53 = load i32, ptr %SaveFlags42, align 4
  %or = or i32 %53, 1
  store i32 %or, ptr %SaveFlags42, align 4
  br label %if.end43

if.end43:                                         ; preds = %if.then41, %if.end39
  %54 = load ptr, ptr %column, align 8
  %DisplayOrder44 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %54, i32 0, i32 18
  %55 = load i16, ptr %DisplayOrder44, align 2
  %conv45 = sext i16 %55 to i32
  %56 = load i32, ptr %n, align 4
  %cmp46 = icmp ne i32 %conv45, %56
  br i1 %cmp46, label %if.then47, label %if.end50

if.then47:                                        ; preds = %if.end43
  %57 = load ptr, ptr %settings, align 8
  %SaveFlags48 = getelementptr inbounds %struct.ImGuiTableSettings, ptr %57, i32 0, i32 1
  %58 = load i32, ptr %SaveFlags48, align 4
  %or49 = or i32 %58, 2
  store i32 %or49, ptr %SaveFlags48, align 4
  br label %if.end50

if.end50:                                         ; preds = %if.then47, %if.end43
  %59 = load ptr, ptr %column, align 8
  %SortOrder51 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %59, i32 0, i32 22
  %60 = load i16, ptr %SortOrder51, align 2
  %conv52 = sext i16 %60 to i32
  %cmp53 = icmp ne i32 %conv52, -1
  br i1 %cmp53, label %if.then54, label %if.end57

if.then54:                                        ; preds = %if.end50
  %61 = load ptr, ptr %settings, align 8
  %SaveFlags55 = getelementptr inbounds %struct.ImGuiTableSettings, ptr %61, i32 0, i32 1
  %62 = load i32, ptr %SaveFlags55, align 4
  %or56 = or i32 %62, 8
  store i32 %or56, ptr %SaveFlags55, align 4
  br label %if.end57

if.end57:                                         ; preds = %if.then54, %if.end50
  %63 = load ptr, ptr %column, align 8
  %IsUserEnabled58 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %63, i32 0, i32 27
  %64 = load i8, ptr %IsUserEnabled58, align 1
  %tobool59 = trunc i8 %64 to i1
  %conv60 = zext i1 %tobool59 to i32
  %65 = load ptr, ptr %column, align 8
  %Flags61 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %65, i32 0, i32 0
  %66 = load i32, ptr %Flags61, align 4
  %and62 = and i32 %66, 2
  %cmp63 = icmp eq i32 %and62, 0
  %conv64 = zext i1 %cmp63 to i32
  %cmp65 = icmp ne i32 %conv60, %conv64
  br i1 %cmp65, label %if.then66, label %if.end69

if.then66:                                        ; preds = %if.end57
  %67 = load ptr, ptr %settings, align 8
  %SaveFlags67 = getelementptr inbounds %struct.ImGuiTableSettings, ptr %67, i32 0, i32 1
  %68 = load i32, ptr %SaveFlags67, align 4
  %or68 = or i32 %68, 4
  store i32 %or68, ptr %SaveFlags67, align 4
  br label %if.end69

if.end69:                                         ; preds = %if.then66, %if.end57
  br label %for.inc

for.inc:                                          ; preds = %if.end69
  %69 = load i32, ptr %n, align 4
  %inc = add nsw i32 %69, 1
  store i32 %inc, ptr %n, align 4
  %70 = load ptr, ptr %column, align 8
  %incdec.ptr = getelementptr inbounds %struct.ImGuiTableColumn, ptr %70, i32 1
  store ptr %incdec.ptr, ptr %column, align 8
  %71 = load ptr, ptr %column_settings, align 8
  %incdec.ptr70 = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %71, i32 1
  store ptr %incdec.ptr70, ptr %column_settings, align 8
  br label %for.cond, !llvm.loop !37

for.end:                                          ; preds = %for.cond
  %72 = load ptr, ptr %table.addr, align 8
  %Flags71 = getelementptr inbounds %struct.ImGuiTable, ptr %72, i32 0, i32 1
  %73 = load i32, ptr %Flags71, align 4
  %74 = load ptr, ptr %settings, align 8
  %SaveFlags72 = getelementptr inbounds %struct.ImGuiTableSettings, ptr %74, i32 0, i32 1
  %75 = load i32, ptr %SaveFlags72, align 4
  %and73 = and i32 %75, %73
  store i32 %and73, ptr %SaveFlags72, align 4
  %76 = load i8, ptr %save_ref_scale, align 1
  %tobool74 = trunc i8 %76 to i1
  br i1 %tobool74, label %cond.true75, label %cond.false76

cond.true75:                                      ; preds = %for.end
  %77 = load ptr, ptr %table.addr, align 8
  %RefScale = getelementptr inbounds %struct.ImGuiTable, ptr %77, i32 0, i32 43
  %78 = load float, ptr %RefScale, align 4
  br label %cond.end77

cond.false76:                                     ; preds = %for.end
  br label %cond.end77

cond.end77:                                       ; preds = %cond.false76, %cond.true75
  %cond78 = phi float [ %78, %cond.true75 ], [ 0.000000e+00, %cond.false76 ]
  %79 = load ptr, ptr %settings, align 8
  %RefScale79 = getelementptr inbounds %struct.ImGuiTableSettings, ptr %79, i32 0, i32 2
  store float %cond78, ptr %RefScale79, align 4
  call void @_ZN5ImGui20MarkIniSettingsDirtyEv()
  br label %return

return:                                           ; preds = %cond.end77, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef ptr @_ZN6ImPoolI10ImGuiTableE10GetByIndexEi(ptr noundef nonnull align 8 dereferenceable(40) %this, i32 noundef %n) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Buf = getelementptr inbounds %struct.ImPool, ptr %this1, i32 0, i32 0
  %0 = load i32, ptr %n.addr, align 4
  %call = call noundef nonnull align 8 dereferenceable(586) ptr @_ZN8ImVectorI10ImGuiTableEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Buf, i32 noundef %0)
  ret ptr %call
}

declare void @_ZN5ImGui39NavUpdateCurrentWindowIsScrollPushableXEv() #1

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui16TableSetupColumnEPKcifj(ptr noundef %label, i32 noundef %flags, float noundef %init_width_or_weight, i32 noundef %user_id) #0 {
entry:
  %label.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %init_width_or_weight.addr = alloca float, align 4
  %user_id.addr = alloca i32, align 4
  %g = alloca ptr, align 8
  %table = alloca ptr, align 8
  %column = alloca ptr, align 8
  store ptr %label, ptr %label.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  store float %init_width_or_weight, ptr %init_width_or_weight.addr, align 4
  store i32 %user_id, ptr %user_id.addr, align 4
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %g, align 8
  %CurrentTable = getelementptr inbounds %struct.ImGuiContext, ptr %1, i32 0, i32 164
  %2 = load ptr, ptr %CurrentTable, align 8
  store ptr %2, ptr %table, align 8
  %3 = load ptr, ptr %table, align 8
  %DeclColumnsCount = getelementptr inbounds %struct.ImGuiTable, ptr %3, i32 0, i32 68
  %4 = load i16, ptr %DeclColumnsCount, align 2
  %conv = sext i16 %4 to i32
  %5 = load ptr, ptr %table, align 8
  %ColumnsCount = getelementptr inbounds %struct.ImGuiTable, ptr %5, i32 0, i32 13
  %6 = load i32, ptr %ColumnsCount, align 4
  %cmp = icmp sge i32 %conv, %6
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end85

if.end:                                           ; preds = %entry
  %7 = load ptr, ptr %table, align 8
  %Columns = getelementptr inbounds %struct.ImGuiTable, ptr %7, i32 0, i32 4
  %8 = load ptr, ptr %table, align 8
  %DeclColumnsCount1 = getelementptr inbounds %struct.ImGuiTable, ptr %8, i32 0, i32 68
  %9 = load i16, ptr %DeclColumnsCount1, align 2
  %conv2 = sext i16 %9 to i32
  %call = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns, i32 noundef %conv2)
  store ptr %call, ptr %column, align 8
  %10 = load ptr, ptr %table, align 8
  %DeclColumnsCount3 = getelementptr inbounds %struct.ImGuiTable, ptr %10, i32 0, i32 68
  %11 = load i16, ptr %DeclColumnsCount3, align 2
  %inc = add i16 %11, 1
  store i16 %inc, ptr %DeclColumnsCount3, align 2
  %12 = load ptr, ptr %table, align 8
  %IsDefaultSizingPolicy = getelementptr inbounds %struct.ImGuiTable, ptr %12, i32 0, i32 105
  %13 = load i8, ptr %IsDefaultSizingPolicy, align 1
  %tobool = trunc i8 %13 to i1
  br i1 %tobool, label %land.lhs.true, label %if.end9

land.lhs.true:                                    ; preds = %if.end
  %14 = load i32, ptr %flags.addr, align 4
  %and = and i32 %14, 24
  %cmp4 = icmp eq i32 %and, 0
  br i1 %cmp4, label %land.lhs.true5, label %if.end9

land.lhs.true5:                                   ; preds = %land.lhs.true
  %15 = load i32, ptr %flags.addr, align 4
  %and6 = and i32 %15, 16777216
  %cmp7 = icmp eq i32 %and6, 0
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %land.lhs.true5
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %land.lhs.true5, %land.lhs.true, %if.end
  %16 = load i32, ptr %flags.addr, align 4
  %and10 = and i32 %16, 24
  %cmp11 = icmp eq i32 %and10, 0
  br i1 %cmp11, label %land.lhs.true12, label %if.end22

land.lhs.true12:                                  ; preds = %if.end9
  %17 = load float, ptr %init_width_or_weight.addr, align 4
  %cmp13 = fcmp ogt float %17, 0.000000e+00
  br i1 %cmp13, label %if.then14, label %if.end22

if.then14:                                        ; preds = %land.lhs.true12
  %18 = load ptr, ptr %table, align 8
  %Flags = getelementptr inbounds %struct.ImGuiTable, ptr %18, i32 0, i32 1
  %19 = load i32, ptr %Flags, align 4
  %and15 = and i32 %19, 57344
  %cmp16 = icmp eq i32 %and15, 8192
  br i1 %cmp16, label %if.then20, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then14
  %20 = load ptr, ptr %table, align 8
  %Flags17 = getelementptr inbounds %struct.ImGuiTable, ptr %20, i32 0, i32 1
  %21 = load i32, ptr %Flags17, align 4
  %and18 = and i32 %21, 57344
  %cmp19 = icmp eq i32 %and18, 16384
  br i1 %cmp19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %lor.lhs.false, %if.then14
  %22 = load i32, ptr %flags.addr, align 4
  %or = or i32 %22, 16
  store i32 %or, ptr %flags.addr, align 4
  br label %if.end21

if.end21:                                         ; preds = %if.then20, %lor.lhs.false
  br label %if.end22

if.end22:                                         ; preds = %if.end21, %land.lhs.true12, %if.end9
  %23 = load i32, ptr %flags.addr, align 4
  %and23 = and i32 %23, 262144
  %tobool24 = icmp ne i32 %and23, 0
  br i1 %tobool24, label %if.then25, label %if.end28

if.then25:                                        ; preds = %if.end22
  %24 = load i32, ptr %flags.addr, align 4
  %or26 = or i32 %24, 4096
  store i32 %or26, ptr %flags.addr, align 4
  %25 = load ptr, ptr %table, align 8
  %AngledHeadersCount = getelementptr inbounds %struct.ImGuiTable, ptr %25, i32 0, i32 69
  %26 = load i16, ptr %AngledHeadersCount, align 8
  %inc27 = add i16 %26, 1
  store i16 %inc27, ptr %AngledHeadersCount, align 8
  br label %if.end28

if.end28:                                         ; preds = %if.then25, %if.end22
  %27 = load ptr, ptr %table, align 8
  %28 = load ptr, ptr %column, align 8
  %29 = load i32, ptr %flags.addr, align 4
  call void @_ZL21TableSetupColumnFlagsP10ImGuiTableP16ImGuiTableColumni(ptr noundef %27, ptr noundef %28, i32 noundef %29)
  %30 = load i32, ptr %user_id.addr, align 4
  %31 = load ptr, ptr %column, align 8
  %UserID = getelementptr inbounds %struct.ImGuiTableColumn, ptr %31, i32 0, i32 9
  store i32 %30, ptr %UserID, align 4
  %32 = load ptr, ptr %column, align 8
  %Flags29 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %32, i32 0, i32 0
  %33 = load i32, ptr %Flags29, align 4
  store i32 %33, ptr %flags.addr, align 4
  %34 = load float, ptr %init_width_or_weight.addr, align 4
  %35 = load ptr, ptr %column, align 8
  %InitStretchWeightOrWidth = getelementptr inbounds %struct.ImGuiTableColumn, ptr %35, i32 0, i32 7
  store float %34, ptr %InitStretchWeightOrWidth, align 4
  %36 = load ptr, ptr %table, align 8
  %IsInitializing = getelementptr inbounds %struct.ImGuiTable, ptr %36, i32 0, i32 94
  %37 = load i8, ptr %IsInitializing, align 8
  %tobool30 = trunc i8 %37 to i1
  br i1 %tobool30, label %if.then31, label %if.end73

if.then31:                                        ; preds = %if.end28
  %38 = load ptr, ptr %column, align 8
  %WidthRequest = getelementptr inbounds %struct.ImGuiTableColumn, ptr %38, i32 0, i32 4
  %39 = load float, ptr %WidthRequest, align 4
  %cmp32 = fcmp olt float %39, 0.000000e+00
  br i1 %cmp32, label %land.lhs.true33, label %if.end52

land.lhs.true33:                                  ; preds = %if.then31
  %40 = load ptr, ptr %column, align 8
  %StretchWeight = getelementptr inbounds %struct.ImGuiTableColumn, ptr %40, i32 0, i32 6
  %41 = load float, ptr %StretchWeight, align 4
  %cmp34 = fcmp olt float %41, 0.000000e+00
  br i1 %cmp34, label %if.then35, label %if.end52

if.then35:                                        ; preds = %land.lhs.true33
  %42 = load i32, ptr %flags.addr, align 4
  %and36 = and i32 %42, 16
  %tobool37 = icmp ne i32 %and36, 0
  br i1 %tobool37, label %land.lhs.true38, label %if.end42

land.lhs.true38:                                  ; preds = %if.then35
  %43 = load float, ptr %init_width_or_weight.addr, align 4
  %cmp39 = fcmp ogt float %43, 0.000000e+00
  br i1 %cmp39, label %if.then40, label %if.end42

if.then40:                                        ; preds = %land.lhs.true38
  %44 = load float, ptr %init_width_or_weight.addr, align 4
  %45 = load ptr, ptr %column, align 8
  %WidthRequest41 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %45, i32 0, i32 4
  store float %44, ptr %WidthRequest41, align 4
  br label %if.end42

if.end42:                                         ; preds = %if.then40, %land.lhs.true38, %if.then35
  %46 = load i32, ptr %flags.addr, align 4
  %and43 = and i32 %46, 8
  %tobool44 = icmp ne i32 %and43, 0
  br i1 %tobool44, label %if.then45, label %if.end48

if.then45:                                        ; preds = %if.end42
  %47 = load float, ptr %init_width_or_weight.addr, align 4
  %cmp46 = fcmp ogt float %47, 0.000000e+00
  br i1 %cmp46, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then45
  %48 = load float, ptr %init_width_or_weight.addr, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.then45
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi float [ %48, %cond.true ], [ -1.000000e+00, %cond.false ]
  %49 = load ptr, ptr %column, align 8
  %StretchWeight47 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %49, i32 0, i32 6
  store float %cond, ptr %StretchWeight47, align 4
  br label %if.end48

if.end48:                                         ; preds = %cond.end, %if.end42
  %50 = load float, ptr %init_width_or_weight.addr, align 4
  %cmp49 = fcmp ogt float %50, 0.000000e+00
  br i1 %cmp49, label %if.then50, label %if.end51

if.then50:                                        ; preds = %if.end48
  %51 = load ptr, ptr %column, align 8
  %AutoFitQueue = getelementptr inbounds %struct.ImGuiTableColumn, ptr %51, i32 0, i32 35
  store i8 0, ptr %AutoFitQueue, align 1
  br label %if.end51

if.end51:                                         ; preds = %if.then50, %if.end48
  br label %if.end52

if.end52:                                         ; preds = %if.end51, %land.lhs.true33, %if.then31
  %52 = load i32, ptr %flags.addr, align 4
  %and53 = and i32 %52, 2
  %tobool54 = icmp ne i32 %and53, 0
  br i1 %tobool54, label %land.lhs.true55, label %if.end59

land.lhs.true55:                                  ; preds = %if.end52
  %53 = load ptr, ptr %table, align 8
  %SettingsLoadedFlags = getelementptr inbounds %struct.ImGuiTable, ptr %53, i32 0, i32 10
  %54 = load i32, ptr %SettingsLoadedFlags, align 8
  %and56 = and i32 %54, 4
  %cmp57 = icmp eq i32 %and56, 0
  br i1 %cmp57, label %if.then58, label %if.end59

if.then58:                                        ; preds = %land.lhs.true55
  %55 = load ptr, ptr %column, align 8
  %IsUserEnabledNextFrame = getelementptr inbounds %struct.ImGuiTableColumn, ptr %55, i32 0, i32 28
  store i8 0, ptr %IsUserEnabledNextFrame, align 4
  %56 = load ptr, ptr %column, align 8
  %IsUserEnabled = getelementptr inbounds %struct.ImGuiTableColumn, ptr %56, i32 0, i32 27
  store i8 0, ptr %IsUserEnabled, align 1
  br label %if.end59

if.end59:                                         ; preds = %if.then58, %land.lhs.true55, %if.end52
  %57 = load i32, ptr %flags.addr, align 4
  %and60 = and i32 %57, 4
  %tobool61 = icmp ne i32 %and60, 0
  br i1 %tobool61, label %land.lhs.true62, label %if.end72

land.lhs.true62:                                  ; preds = %if.end59
  %58 = load ptr, ptr %table, align 8
  %SettingsLoadedFlags63 = getelementptr inbounds %struct.ImGuiTable, ptr %58, i32 0, i32 10
  %59 = load i32, ptr %SettingsLoadedFlags63, align 8
  %and64 = and i32 %59, 8
  %cmp65 = icmp eq i32 %and64, 0
  br i1 %cmp65, label %if.then66, label %if.end72

if.then66:                                        ; preds = %land.lhs.true62
  %60 = load ptr, ptr %column, align 8
  %SortOrder = getelementptr inbounds %struct.ImGuiTableColumn, ptr %60, i32 0, i32 22
  store i16 0, ptr %SortOrder, align 2
  %61 = load ptr, ptr %column, align 8
  %Flags67 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %61, i32 0, i32 0
  %62 = load i32, ptr %Flags67, align 4
  %and68 = and i32 %62, 32768
  %tobool69 = icmp ne i32 %and68, 0
  %cond70 = select i1 %tobool69, i32 2, i32 1
  %conv71 = trunc i32 %cond70 to i8
  %63 = load ptr, ptr %column, align 8
  %SortDirection = getelementptr inbounds %struct.ImGuiTableColumn, ptr %63, i32 0, i32 37
  %bf.load = load i8, ptr %SortDirection, align 1
  %bf.value = and i8 %conv71, 3
  %bf.clear = and i8 %bf.load, -4
  %bf.set = or i8 %bf.clear, %bf.value
  store i8 %bf.set, ptr %SortDirection, align 1
  br label %if.end72

if.end72:                                         ; preds = %if.then66, %land.lhs.true62, %if.end59
  br label %if.end73

if.end73:                                         ; preds = %if.end72, %if.end28
  %64 = load ptr, ptr %column, align 8
  %NameOffset = getelementptr inbounds %struct.ImGuiTableColumn, ptr %64, i32 0, i32 17
  store i16 -1, ptr %NameOffset, align 4
  %65 = load ptr, ptr %label.addr, align 8
  %cmp74 = icmp ne ptr %65, null
  br i1 %cmp74, label %land.lhs.true75, label %if.end85

land.lhs.true75:                                  ; preds = %if.end73
  %66 = load ptr, ptr %label.addr, align 8
  %arrayidx = getelementptr inbounds i8, ptr %66, i64 0
  %67 = load i8, ptr %arrayidx, align 1
  %conv76 = sext i8 %67 to i32
  %cmp77 = icmp ne i32 %conv76, 0
  br i1 %cmp77, label %if.then78, label %if.end85

if.then78:                                        ; preds = %land.lhs.true75
  %68 = load ptr, ptr %table, align 8
  %ColumnsNames = getelementptr inbounds %struct.ImGuiTable, ptr %68, i32 0, i32 57
  %call79 = call noundef i32 @_ZNK15ImGuiTextBuffer4sizeEv(ptr noundef nonnull align 8 dereferenceable(16) %ColumnsNames)
  %conv80 = trunc i32 %call79 to i16
  %69 = load ptr, ptr %column, align 8
  %NameOffset81 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %69, i32 0, i32 17
  store i16 %conv80, ptr %NameOffset81, align 4
  %70 = load ptr, ptr %table, align 8
  %ColumnsNames82 = getelementptr inbounds %struct.ImGuiTable, ptr %70, i32 0, i32 57
  %71 = load ptr, ptr %label.addr, align 8
  %72 = load ptr, ptr %label.addr, align 8
  %73 = load ptr, ptr %label.addr, align 8
  %call83 = call i64 @strlen(ptr noundef %73) #11
  %add.ptr = getelementptr inbounds i8, ptr %72, i64 %call83
  %add.ptr84 = getelementptr inbounds i8, ptr %add.ptr, i64 1
  call void @_ZN15ImGuiTextBuffer6appendEPKcS1_(ptr noundef nonnull align 8 dereferenceable(16) %ColumnsNames82, ptr noundef %71, ptr noundef %add.ptr84)
  br label %if.end85

if.end85:                                         ; preds = %if.then78, %land.lhs.true75, %if.end73, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i32 @_ZNK15ImGuiTextBuffer4sizeEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Buf = getelementptr inbounds %struct.ImGuiTextBuffer, ptr %this1, i32 0, i32 0
  %Size = getelementptr inbounds %struct.ImVector.25, ptr %Buf, i32 0, i32 0
  %0 = load i32, ptr %Size, align 8
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %Buf2 = getelementptr inbounds %struct.ImGuiTextBuffer, ptr %this1, i32 0, i32 0
  %Size3 = getelementptr inbounds %struct.ImVector.25, ptr %Buf2, i32 0, i32 0
  %1 = load i32, ptr %Size3, align 8
  %sub = sub nsw i32 %1, 1
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %sub, %cond.true ], [ 0, %cond.false ]
  ret i32 %cond
}

declare void @_ZN15ImGuiTextBuffer6appendEPKcS1_(ptr noundef nonnull align 8 dereferenceable(16), ptr noundef, ptr noundef) #1

; Function Attrs: nounwind willreturn memory(read)
declare i64 @strlen(ptr noundef) #7

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui22TableSetupScrollFreezeEii(i32 noundef %columns, i32 noundef %rows) #0 {
entry:
  %columns.addr = alloca i32, align 4
  %rows.addr = alloca i32, align 4
  %g = alloca ptr, align 8
  %table = alloca ptr, align 8
  %column_n = alloca i32, align 4
  %order_n = alloca i32, align 4
  store i32 %columns, ptr %columns.addr, align 4
  store i32 %rows, ptr %rows.addr, align 4
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %g, align 8
  %CurrentTable = getelementptr inbounds %struct.ImGuiContext, ptr %1, i32 0, i32 164
  %2 = load ptr, ptr %CurrentTable, align 8
  store ptr %2, ptr %table, align 8
  %3 = load ptr, ptr %table, align 8
  %Flags = getelementptr inbounds %struct.ImGuiTable, ptr %3, i32 0, i32 1
  %4 = load i32, ptr %Flags, align 4
  %and = and i32 %4, 16777216
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %5 = load i32, ptr %columns.addr, align 4
  %6 = load ptr, ptr %table, align 8
  %ColumnsCount = getelementptr inbounds %struct.ImGuiTable, ptr %6, i32 0, i32 13
  %7 = load i32, ptr %ColumnsCount, align 4
  %call = call noundef i32 @_ZL5ImMinIiET_S0_S0_(i32 noundef %5, i32 noundef %7)
  %conv = trunc i32 %call to i16
  %conv1 = sext i16 %conv to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv1, %cond.true ], [ 0, %cond.false ]
  %conv2 = trunc i32 %cond to i16
  %8 = load ptr, ptr %table, align 8
  %FreezeColumnsRequest = getelementptr inbounds %struct.ImGuiTable, ptr %8, i32 0, i32 86
  store i16 %conv2, ptr %FreezeColumnsRequest, align 2
  %9 = load ptr, ptr %table, align 8
  %InnerWindow = getelementptr inbounds %struct.ImGuiTable, ptr %9, i32 0, i32 56
  %10 = load ptr, ptr %InnerWindow, align 8
  %Scroll = getelementptr inbounds %struct.ImGuiWindow, ptr %10, i32 0, i32 25
  %x = getelementptr inbounds %struct.ImVec2, ptr %Scroll, i32 0, i32 0
  %11 = load float, ptr %x, align 4
  %cmp = fcmp une float %11, 0.000000e+00
  br i1 %cmp, label %cond.true3, label %cond.false6

cond.true3:                                       ; preds = %cond.end
  %12 = load ptr, ptr %table, align 8
  %FreezeColumnsRequest4 = getelementptr inbounds %struct.ImGuiTable, ptr %12, i32 0, i32 86
  %13 = load i16, ptr %FreezeColumnsRequest4, align 2
  %conv5 = sext i16 %13 to i32
  br label %cond.end7

cond.false6:                                      ; preds = %cond.end
  br label %cond.end7

cond.end7:                                        ; preds = %cond.false6, %cond.true3
  %cond8 = phi i32 [ %conv5, %cond.true3 ], [ 0, %cond.false6 ]
  %conv9 = trunc i32 %cond8 to i16
  %14 = load ptr, ptr %table, align 8
  %FreezeColumnsCount = getelementptr inbounds %struct.ImGuiTable, ptr %14, i32 0, i32 87
  store i16 %conv9, ptr %FreezeColumnsCount, align 4
  %15 = load ptr, ptr %table, align 8
  %Flags10 = getelementptr inbounds %struct.ImGuiTable, ptr %15, i32 0, i32 1
  %16 = load i32, ptr %Flags10, align 4
  %and11 = and i32 %16, 33554432
  %tobool12 = icmp ne i32 %and11, 0
  br i1 %tobool12, label %cond.true13, label %cond.false16

cond.true13:                                      ; preds = %cond.end7
  %17 = load i32, ptr %rows.addr, align 4
  %conv14 = trunc i32 %17 to i16
  %conv15 = sext i16 %conv14 to i32
  br label %cond.end17

cond.false16:                                     ; preds = %cond.end7
  br label %cond.end17

cond.end17:                                       ; preds = %cond.false16, %cond.true13
  %cond18 = phi i32 [ %conv15, %cond.true13 ], [ 0, %cond.false16 ]
  %conv19 = trunc i32 %cond18 to i16
  %18 = load ptr, ptr %table, align 8
  %FreezeRowsRequest = getelementptr inbounds %struct.ImGuiTable, ptr %18, i32 0, i32 84
  store i16 %conv19, ptr %FreezeRowsRequest, align 2
  %19 = load ptr, ptr %table, align 8
  %InnerWindow20 = getelementptr inbounds %struct.ImGuiTable, ptr %19, i32 0, i32 56
  %20 = load ptr, ptr %InnerWindow20, align 8
  %Scroll21 = getelementptr inbounds %struct.ImGuiWindow, ptr %20, i32 0, i32 25
  %y = getelementptr inbounds %struct.ImVec2, ptr %Scroll21, i32 0, i32 1
  %21 = load float, ptr %y, align 4
  %cmp22 = fcmp une float %21, 0.000000e+00
  br i1 %cmp22, label %cond.true23, label %cond.false26

cond.true23:                                      ; preds = %cond.end17
  %22 = load ptr, ptr %table, align 8
  %FreezeRowsRequest24 = getelementptr inbounds %struct.ImGuiTable, ptr %22, i32 0, i32 84
  %23 = load i16, ptr %FreezeRowsRequest24, align 2
  %conv25 = sext i16 %23 to i32
  br label %cond.end27

cond.false26:                                     ; preds = %cond.end17
  br label %cond.end27

cond.end27:                                       ; preds = %cond.false26, %cond.true23
  %cond28 = phi i32 [ %conv25, %cond.true23 ], [ 0, %cond.false26 ]
  %conv29 = trunc i32 %cond28 to i16
  %24 = load ptr, ptr %table, align 8
  %FreezeRowsCount = getelementptr inbounds %struct.ImGuiTable, ptr %24, i32 0, i32 85
  store i16 %conv29, ptr %FreezeRowsCount, align 8
  %25 = load ptr, ptr %table, align 8
  %FreezeRowsCount30 = getelementptr inbounds %struct.ImGuiTable, ptr %25, i32 0, i32 85
  %26 = load i16, ptr %FreezeRowsCount30, align 8
  %conv31 = sext i16 %26 to i32
  %cmp32 = icmp eq i32 %conv31, 0
  %27 = load ptr, ptr %table, align 8
  %IsUnfrozenRows = getelementptr inbounds %struct.ImGuiTable, ptr %27, i32 0, i32 104
  %frombool = zext i1 %cmp32 to i8
  store i8 %frombool, ptr %IsUnfrozenRows, align 2
  store i32 0, ptr %column_n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end27
  %28 = load i32, ptr %column_n, align 4
  %29 = load ptr, ptr %table, align 8
  %FreezeColumnsRequest33 = getelementptr inbounds %struct.ImGuiTable, ptr %29, i32 0, i32 86
  %30 = load i16, ptr %FreezeColumnsRequest33, align 2
  %conv34 = sext i16 %30 to i32
  %cmp35 = icmp slt i32 %28, %conv34
  br i1 %cmp35, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %31 = load ptr, ptr %table, align 8
  %DisplayOrderToIndex = getelementptr inbounds %struct.ImGuiTable, ptr %31, i32 0, i32 5
  %32 = load i32, ptr %column_n, align 4
  %call36 = call noundef nonnull align 2 dereferenceable(2) ptr @_ZN6ImSpanIsEixEi(ptr noundef nonnull align 8 dereferenceable(16) %DisplayOrderToIndex, i32 noundef %32)
  %33 = load i16, ptr %call36, align 2
  %conv37 = sext i16 %33 to i32
  store i32 %conv37, ptr %order_n, align 4
  %34 = load i32, ptr %order_n, align 4
  %35 = load i32, ptr %column_n, align 4
  %cmp38 = icmp ne i32 %34, %35
  br i1 %cmp38, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.body
  %36 = load i32, ptr %order_n, align 4
  %37 = load ptr, ptr %table, align 8
  %FreezeColumnsRequest39 = getelementptr inbounds %struct.ImGuiTable, ptr %37, i32 0, i32 86
  %38 = load i16, ptr %FreezeColumnsRequest39, align 2
  %conv40 = sext i16 %38 to i32
  %cmp41 = icmp sge i32 %36, %conv40
  br i1 %cmp41, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %39 = load ptr, ptr %table, align 8
  %Columns = getelementptr inbounds %struct.ImGuiTable, ptr %39, i32 0, i32 4
  %40 = load ptr, ptr %table, align 8
  %DisplayOrderToIndex42 = getelementptr inbounds %struct.ImGuiTable, ptr %40, i32 0, i32 5
  %41 = load i32, ptr %order_n, align 4
  %call43 = call noundef nonnull align 2 dereferenceable(2) ptr @_ZN6ImSpanIsEixEi(ptr noundef nonnull align 8 dereferenceable(16) %DisplayOrderToIndex42, i32 noundef %41)
  %42 = load i16, ptr %call43, align 2
  %conv44 = sext i16 %42 to i32
  %call45 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns, i32 noundef %conv44)
  %DisplayOrder = getelementptr inbounds %struct.ImGuiTableColumn, ptr %call45, i32 0, i32 18
  %43 = load ptr, ptr %table, align 8
  %Columns46 = getelementptr inbounds %struct.ImGuiTable, ptr %43, i32 0, i32 4
  %44 = load ptr, ptr %table, align 8
  %DisplayOrderToIndex47 = getelementptr inbounds %struct.ImGuiTable, ptr %44, i32 0, i32 5
  %45 = load i32, ptr %column_n, align 4
  %call48 = call noundef nonnull align 2 dereferenceable(2) ptr @_ZN6ImSpanIsEixEi(ptr noundef nonnull align 8 dereferenceable(16) %DisplayOrderToIndex47, i32 noundef %45)
  %46 = load i16, ptr %call48, align 2
  %conv49 = sext i16 %46 to i32
  %call50 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns46, i32 noundef %conv49)
  %DisplayOrder51 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %call50, i32 0, i32 18
  call void @_ZL6ImSwapIsEvRT_S1_(ptr noundef nonnull align 2 dereferenceable(2) %DisplayOrder, ptr noundef nonnull align 2 dereferenceable(2) %DisplayOrder51)
  %47 = load ptr, ptr %table, align 8
  %DisplayOrderToIndex52 = getelementptr inbounds %struct.ImGuiTable, ptr %47, i32 0, i32 5
  %48 = load i32, ptr %order_n, align 4
  %call53 = call noundef nonnull align 2 dereferenceable(2) ptr @_ZN6ImSpanIsEixEi(ptr noundef nonnull align 8 dereferenceable(16) %DisplayOrderToIndex52, i32 noundef %48)
  %49 = load ptr, ptr %table, align 8
  %DisplayOrderToIndex54 = getelementptr inbounds %struct.ImGuiTable, ptr %49, i32 0, i32 5
  %50 = load i32, ptr %column_n, align 4
  %call55 = call noundef nonnull align 2 dereferenceable(2) ptr @_ZN6ImSpanIsEixEi(ptr noundef nonnull align 8 dereferenceable(16) %DisplayOrderToIndex54, i32 noundef %50)
  call void @_ZL6ImSwapIsEvRT_S1_(ptr noundef nonnull align 2 dereferenceable(2) %call53, ptr noundef nonnull align 2 dereferenceable(2) %call55)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %51 = load i32, ptr %column_n, align 4
  %inc = add nsw i32 %51, 1
  store i32 %inc, ptr %column_n, align 4
  br label %for.cond, !llvm.loop !38

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef i32 @_ZL5ImMinIiET_S0_S0_(i32 noundef %lhs, i32 noundef %rhs) #3 {
entry:
  %lhs.addr = alloca i32, align 4
  %rhs.addr = alloca i32, align 4
  store i32 %lhs, ptr %lhs.addr, align 4
  store i32 %rhs, ptr %rhs.addr, align 4
  %0 = load i32, ptr %lhs.addr, align 4
  %1 = load i32, ptr %rhs.addr, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load i32, ptr %lhs.addr, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %3 = load i32, ptr %rhs.addr, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %2, %cond.true ], [ %3, %cond.false ]
  ret i32 %cond
}

; Function Attrs: mustprogress nounwind uwtable
define internal void @_ZL6ImSwapIsEvRT_S1_(ptr noundef nonnull align 2 dereferenceable(2) %a, ptr noundef nonnull align 2 dereferenceable(2) %b) #3 {
entry:
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  %tmp = alloca i16, align 2
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %1 = load i16, ptr %0, align 2
  store i16 %1, ptr %tmp, align 2
  %2 = load ptr, ptr %b.addr, align 8
  %3 = load i16, ptr %2, align 2
  %4 = load ptr, ptr %a.addr, align 8
  store i16 %3, ptr %4, align 2
  %5 = load i16, ptr %tmp, align 2
  %6 = load ptr, ptr %b.addr, align 8
  store i16 %5, ptr %6, align 2
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define noundef i32 @_ZN5ImGui19TableGetColumnCountEv() #3 {
entry:
  %g = alloca ptr, align 8
  %table = alloca ptr, align 8
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %g, align 8
  %CurrentTable = getelementptr inbounds %struct.ImGuiContext, ptr %1, i32 0, i32 164
  %2 = load ptr, ptr %CurrentTable, align 8
  store ptr %2, ptr %table, align 8
  %3 = load ptr, ptr %table, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %4 = load ptr, ptr %table, align 8
  %ColumnsCount = getelementptr inbounds %struct.ImGuiTable, ptr %4, i32 0, i32 13
  %5 = load i32, ptr %ColumnsCount, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %5, %cond.true ], [ 0, %cond.false ]
  ret i32 %cond
}

; Function Attrs: mustprogress uwtable
define noundef ptr @_ZN5ImGui18TableGetColumnNameEi(i32 noundef %column_n) #0 {
entry:
  %retval = alloca ptr, align 8
  %column_n.addr = alloca i32, align 4
  %g = alloca ptr, align 8
  %table = alloca ptr, align 8
  store i32 %column_n, ptr %column_n.addr, align 4
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %g, align 8
  %CurrentTable = getelementptr inbounds %struct.ImGuiContext, ptr %1, i32 0, i32 164
  %2 = load ptr, ptr %CurrentTable, align 8
  store ptr %2, ptr %table, align 8
  %3 = load ptr, ptr %table, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %4 = load i32, ptr %column_n.addr, align 4
  %cmp = icmp slt i32 %4, 0
  br i1 %cmp, label %if.then1, label %if.end2

if.then1:                                         ; preds = %if.end
  %5 = load ptr, ptr %table, align 8
  %CurrentColumn = getelementptr inbounds %struct.ImGuiTable, ptr %5, i32 0, i32 15
  %6 = load i32, ptr %CurrentColumn, align 4
  store i32 %6, ptr %column_n.addr, align 4
  br label %if.end2

if.end2:                                          ; preds = %if.then1, %if.end
  %7 = load ptr, ptr %table, align 8
  %8 = load i32, ptr %column_n.addr, align 4
  %call = call noundef ptr @_ZN5ImGui18TableGetColumnNameEPK10ImGuiTablei(ptr noundef %7, i32 noundef %8)
  store ptr %call, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end2, %if.then
  %9 = load ptr, ptr %retval, align 8
  ret ptr %9
}

; Function Attrs: mustprogress uwtable
define noundef ptr @_ZN5ImGui18TableGetColumnNameEPK10ImGuiTablei(ptr noundef %table, i32 noundef %column_n) #0 {
entry:
  %retval = alloca ptr, align 8
  %table.addr = alloca ptr, align 8
  %column_n.addr = alloca i32, align 4
  %column = alloca ptr, align 8
  store ptr %table, ptr %table.addr, align 8
  store i32 %column_n, ptr %column_n.addr, align 4
  %0 = load ptr, ptr %table.addr, align 8
  %IsLayoutLocked = getelementptr inbounds %struct.ImGuiTable, ptr %0, i32 0, i32 92
  %1 = load i8, ptr %IsLayoutLocked, align 2
  %tobool = trunc i8 %1 to i1
  %conv = zext i1 %tobool to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %2 = load i32, ptr %column_n.addr, align 4
  %3 = load ptr, ptr %table.addr, align 8
  %DeclColumnsCount = getelementptr inbounds %struct.ImGuiTable, ptr %3, i32 0, i32 68
  %4 = load i16, ptr %DeclColumnsCount, align 2
  %conv1 = sext i16 %4 to i32
  %cmp2 = icmp sge i32 %2, %conv1
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store ptr @.str.1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %5 = load ptr, ptr %table.addr, align 8
  %Columns = getelementptr inbounds %struct.ImGuiTable, ptr %5, i32 0, i32 4
  %6 = load i32, ptr %column_n.addr, align 4
  %call = call noundef nonnull align 4 dereferenceable(111) ptr @_ZNK6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns, i32 noundef %6)
  store ptr %call, ptr %column, align 8
  %7 = load ptr, ptr %column, align 8
  %NameOffset = getelementptr inbounds %struct.ImGuiTableColumn, ptr %7, i32 0, i32 17
  %8 = load i16, ptr %NameOffset, align 4
  %conv3 = sext i16 %8 to i32
  %cmp4 = icmp eq i32 %conv3, -1
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end
  store ptr @.str.1, ptr %retval, align 8
  br label %return

if.end6:                                          ; preds = %if.end
  %9 = load ptr, ptr %table.addr, align 8
  %ColumnsNames = getelementptr inbounds %struct.ImGuiTable, ptr %9, i32 0, i32 57
  %Buf = getelementptr inbounds %struct.ImGuiTextBuffer, ptr %ColumnsNames, i32 0, i32 0
  %10 = load ptr, ptr %column, align 8
  %NameOffset7 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %10, i32 0, i32 17
  %11 = load i16, ptr %NameOffset7, align 4
  %conv8 = sext i16 %11 to i32
  %call9 = call noundef nonnull align 1 dereferenceable(1) ptr @_ZNK8ImVectorIcEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Buf, i32 noundef %conv8)
  store ptr %call9, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end6, %if.then5, %if.then
  %12 = load ptr, ptr %retval, align 8
  ret ptr %12
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef nonnull align 4 dereferenceable(111) ptr @_ZNK6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %i) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %p = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImSpan, ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %Data, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr inbounds %struct.ImGuiTableColumn, ptr %0, i64 %idx.ext
  store ptr %add.ptr, ptr %p, align 8
  %2 = load ptr, ptr %p, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef nonnull align 1 dereferenceable(1) ptr @_ZNK8ImVectorIcEixEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %i) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.25, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds i8, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui21TableSetColumnEnabledEib(i32 noundef %column_n, i1 noundef zeroext %enabled) #0 {
entry:
  %column_n.addr = alloca i32, align 4
  %enabled.addr = alloca i8, align 1
  %g = alloca ptr, align 8
  %table = alloca ptr, align 8
  %column = alloca ptr, align 8
  store i32 %column_n, ptr %column_n.addr, align 4
  %frombool = zext i1 %enabled to i8
  store i8 %frombool, ptr %enabled.addr, align 1
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %g, align 8
  %CurrentTable = getelementptr inbounds %struct.ImGuiContext, ptr %1, i32 0, i32 164
  %2 = load ptr, ptr %CurrentTable, align 8
  store ptr %2, ptr %table, align 8
  %3 = load ptr, ptr %table, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %4 = load i32, ptr %column_n.addr, align 4
  %cmp = icmp slt i32 %4, 0
  br i1 %cmp, label %if.then1, label %if.end2

if.then1:                                         ; preds = %if.end
  %5 = load ptr, ptr %table, align 8
  %CurrentColumn = getelementptr inbounds %struct.ImGuiTable, ptr %5, i32 0, i32 15
  %6 = load i32, ptr %CurrentColumn, align 4
  store i32 %6, ptr %column_n.addr, align 4
  br label %if.end2

if.end2:                                          ; preds = %if.then1, %if.end
  %7 = load ptr, ptr %table, align 8
  %Columns = getelementptr inbounds %struct.ImGuiTable, ptr %7, i32 0, i32 4
  %8 = load i32, ptr %column_n.addr, align 4
  %call = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns, i32 noundef %8)
  store ptr %call, ptr %column, align 8
  %9 = load i8, ptr %enabled.addr, align 1
  %tobool3 = trunc i8 %9 to i1
  %10 = load ptr, ptr %column, align 8
  %IsUserEnabledNextFrame = getelementptr inbounds %struct.ImGuiTableColumn, ptr %10, i32 0, i32 28
  %frombool4 = zext i1 %tobool3 to i8
  store i8 %frombool4, ptr %IsUserEnabledNextFrame, align 4
  br label %return

return:                                           ; preds = %if.end2, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define noundef i32 @_ZN5ImGui19TableGetColumnFlagsEi(i32 noundef %column_n) #0 {
entry:
  %retval = alloca i32, align 4
  %column_n.addr = alloca i32, align 4
  %g = alloca ptr, align 8
  %table = alloca ptr, align 8
  store i32 %column_n, ptr %column_n.addr, align 4
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %g, align 8
  %CurrentTable = getelementptr inbounds %struct.ImGuiContext, ptr %1, i32 0, i32 164
  %2 = load ptr, ptr %CurrentTable, align 8
  store ptr %2, ptr %table, align 8
  %3 = load ptr, ptr %table, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %4 = load i32, ptr %column_n.addr, align 4
  %cmp = icmp slt i32 %4, 0
  br i1 %cmp, label %if.then1, label %if.end2

if.then1:                                         ; preds = %if.end
  %5 = load ptr, ptr %table, align 8
  %CurrentColumn = getelementptr inbounds %struct.ImGuiTable, ptr %5, i32 0, i32 15
  %6 = load i32, ptr %CurrentColumn, align 4
  store i32 %6, ptr %column_n.addr, align 4
  br label %if.end2

if.end2:                                          ; preds = %if.then1, %if.end
  %7 = load i32, ptr %column_n.addr, align 4
  %8 = load ptr, ptr %table, align 8
  %ColumnsCount = getelementptr inbounds %struct.ImGuiTable, ptr %8, i32 0, i32 13
  %9 = load i32, ptr %ColumnsCount, align 4
  %cmp3 = icmp eq i32 %7, %9
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end2
  %10 = load ptr, ptr %table, align 8
  %HoveredColumnBody = getelementptr inbounds %struct.ImGuiTable, ptr %10, i32 0, i32 70
  %11 = load i16, ptr %HoveredColumnBody, align 2
  %conv = sext i16 %11 to i32
  %12 = load i32, ptr %column_n.addr, align 4
  %cmp5 = icmp eq i32 %conv, %12
  %cond = select i1 %cmp5, i32 134217728, i32 0
  store i32 %cond, ptr %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.end2
  %13 = load ptr, ptr %table, align 8
  %Columns = getelementptr inbounds %struct.ImGuiTable, ptr %13, i32 0, i32 4
  %14 = load i32, ptr %column_n.addr, align 4
  %call = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns, i32 noundef %14)
  %Flags = getelementptr inbounds %struct.ImGuiTableColumn, ptr %call, i32 0, i32 0
  %15 = load i32, ptr %Flags, align 4
  store i32 %15, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end6, %if.then4, %if.then
  %16 = load i32, ptr %retval, align 4
  ret i32 %16
}

; Function Attrs: mustprogress uwtable
define { <2 x float>, <2 x float> } @_ZN5ImGui18TableGetCellBgRectEPK10ImGuiTablei(ptr noundef %table, i32 noundef %column_n) #0 {
entry:
  %retval = alloca %struct.ImRect, align 4
  %table.addr = alloca ptr, align 8
  %column_n.addr = alloca i32, align 4
  %column = alloca ptr, align 8
  %x1 = alloca float, align 4
  %x2 = alloca float, align 4
  store ptr %table, ptr %table.addr, align 8
  store i32 %column_n, ptr %column_n.addr, align 4
  %0 = load ptr, ptr %table.addr, align 8
  %Columns = getelementptr inbounds %struct.ImGuiTable, ptr %0, i32 0, i32 4
  %1 = load i32, ptr %column_n.addr, align 4
  %call = call noundef nonnull align 4 dereferenceable(111) ptr @_ZNK6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns, i32 noundef %1)
  store ptr %call, ptr %column, align 8
  %2 = load ptr, ptr %column, align 8
  %MinX = getelementptr inbounds %struct.ImGuiTableColumn, ptr %2, i32 0, i32 2
  %3 = load float, ptr %MinX, align 4
  store float %3, ptr %x1, align 4
  %4 = load ptr, ptr %column, align 8
  %MaxX = getelementptr inbounds %struct.ImGuiTableColumn, ptr %4, i32 0, i32 3
  %5 = load float, ptr %MaxX, align 4
  store float %5, ptr %x2, align 4
  %6 = load float, ptr %x1, align 4
  %7 = load ptr, ptr %table.addr, align 8
  %WorkRect = getelementptr inbounds %struct.ImGuiTable, ptr %7, i32 0, i32 48
  %Min = getelementptr inbounds %struct.ImRect, ptr %WorkRect, i32 0, i32 0
  %x = getelementptr inbounds %struct.ImVec2, ptr %Min, i32 0, i32 0
  %8 = load float, ptr %x, align 8
  %call1 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %6, float noundef %8)
  store float %call1, ptr %x1, align 4
  %9 = load float, ptr %x2, align 4
  %10 = load ptr, ptr %table.addr, align 8
  %WorkRect2 = getelementptr inbounds %struct.ImGuiTable, ptr %10, i32 0, i32 48
  %Max = getelementptr inbounds %struct.ImRect, ptr %WorkRect2, i32 0, i32 1
  %x3 = getelementptr inbounds %struct.ImVec2, ptr %Max, i32 0, i32 0
  %11 = load float, ptr %x3, align 8
  %call4 = call noundef float @_ZL5ImMinIfET_S0_S0_(float noundef %9, float noundef %11)
  store float %call4, ptr %x2, align 4
  %12 = load float, ptr %x1, align 4
  %13 = load ptr, ptr %table.addr, align 8
  %RowPosY1 = getelementptr inbounds %struct.ImGuiTable, ptr %13, i32 0, i32 18
  %14 = load float, ptr %RowPosY1, align 4
  %15 = load float, ptr %x2, align 4
  %16 = load ptr, ptr %table.addr, align 8
  %RowPosY2 = getelementptr inbounds %struct.ImGuiTable, ptr %16, i32 0, i32 19
  %17 = load float, ptr %RowPosY2, align 8
  call void @_ZN6ImRectC2Effff(ptr noundef nonnull align 4 dereferenceable(16) %retval, float noundef %12, float noundef %14, float noundef %15, float noundef %17)
  %18 = load { <2 x float>, <2 x float> }, ptr %retval, align 4
  ret { <2 x float>, <2 x float> } %18
}

; Function Attrs: mustprogress uwtable
define linkonce_odr noundef i32 @_ZN5ImGui18TableGetInstanceIDEP10ImGuiTablei(ptr noundef %table, i32 noundef %instance_no) #0 comdat {
entry:
  %table.addr = alloca ptr, align 8
  %instance_no.addr = alloca i32, align 4
  store ptr %table, ptr %table.addr, align 8
  store i32 %instance_no, ptr %instance_no.addr, align 4
  %0 = load ptr, ptr %table.addr, align 8
  %1 = load i32, ptr %instance_no.addr, align 4
  %call = call noundef ptr @_ZN5ImGui20TableGetInstanceDataEP10ImGuiTablei(ptr noundef %0, i32 noundef %1)
  %TableInstanceID = getelementptr inbounds %struct.ImGuiTableInstanceData, ptr %call, i32 0, i32 0
  %2 = load i32, ptr %TableInstanceID, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nounwind uwtable
define noundef i32 @_ZN5ImGui21TableGetHoveredColumnEv() #3 {
entry:
  %retval = alloca i32, align 4
  %g = alloca ptr, align 8
  %table = alloca ptr, align 8
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %g, align 8
  %CurrentTable = getelementptr inbounds %struct.ImGuiContext, ptr %1, i32 0, i32 164
  %2 = load ptr, ptr %CurrentTable, align 8
  store ptr %2, ptr %table, align 8
  %3 = load ptr, ptr %table, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %table, align 8
  %HoveredColumnBody = getelementptr inbounds %struct.ImGuiTable, ptr %4, i32 0, i32 70
  %5 = load i16, ptr %HoveredColumnBody, align 2
  %conv = sext i16 %5 to i32
  store i32 %conv, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i32, ptr %retval, align 4
  ret i32 %6
}

; Function Attrs: mustprogress uwtable
define noundef i32 @_ZN5ImGui18TableGetHoveredRowEv() #0 {
entry:
  %retval = alloca i32, align 4
  %g = alloca ptr, align 8
  %table = alloca ptr, align 8
  %table_instance = alloca ptr, align 8
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %g, align 8
  %CurrentTable = getelementptr inbounds %struct.ImGuiContext, ptr %1, i32 0, i32 164
  %2 = load ptr, ptr %CurrentTable, align 8
  store ptr %2, ptr %table, align 8
  %3 = load ptr, ptr %table, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %table, align 8
  %5 = load ptr, ptr %table, align 8
  %InstanceCurrent = getelementptr inbounds %struct.ImGuiTable, ptr %5, i32 0, i32 16
  %6 = load i16, ptr %InstanceCurrent, align 8
  %conv = sext i16 %6 to i32
  %call = call noundef ptr @_ZN5ImGui20TableGetInstanceDataEP10ImGuiTablei(ptr noundef %4, i32 noundef %conv)
  store ptr %call, ptr %table_instance, align 8
  %7 = load ptr, ptr %table_instance, align 8
  %HoveredRowLast = getelementptr inbounds %struct.ImGuiTableInstanceData, ptr %7, i32 0, i32 4
  %8 = load i32, ptr %HoveredRowLast, align 4
  store i32 %8, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %9 = load i32, ptr %retval, align 4
  ret i32 %9
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui15TableSetBgColorEiji(i32 noundef %target, i32 noundef %color, i32 noundef %column_n) #0 {
entry:
  %target.addr = alloca i32, align 4
  %color.addr = alloca i32, align 4
  %column_n.addr = alloca i32, align 4
  %g = alloca ptr, align 8
  %table = alloca ptr, align 8
  %cell_data = alloca ptr, align 8
  %bg_idx = alloca i32, align 4
  store i32 %target, ptr %target.addr, align 4
  store i32 %color, ptr %color.addr, align 4
  store i32 %column_n, ptr %column_n.addr, align 4
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %g, align 8
  %CurrentTable = getelementptr inbounds %struct.ImGuiContext, ptr %1, i32 0, i32 164
  %2 = load ptr, ptr %CurrentTable, align 8
  store ptr %2, ptr %table, align 8
  %3 = load i32, ptr %color.addr, align 4
  %cmp = icmp eq i32 %3, 16777216
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %color.addr, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load i32, ptr %target.addr, align 4
  switch i32 %4, label %sw.default [
    i32 3, label %sw.bb
    i32 1, label %sw.bb25
    i32 2, label %sw.bb25
  ]

sw.bb:                                            ; preds = %if.end
  %5 = load ptr, ptr %table, align 8
  %RowPosY1 = getelementptr inbounds %struct.ImGuiTable, ptr %5, i32 0, i32 18
  %6 = load float, ptr %RowPosY1, align 4
  %7 = load ptr, ptr %table, align 8
  %InnerClipRect = getelementptr inbounds %struct.ImGuiTable, ptr %7, i32 0, i32 49
  %Max = getelementptr inbounds %struct.ImRect, ptr %InnerClipRect, i32 0, i32 1
  %y = getelementptr inbounds %struct.ImVec2, ptr %Max, i32 0, i32 1
  %8 = load float, ptr %y, align 4
  %cmp1 = fcmp ogt float %6, %8
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %sw.bb
  br label %sw.epilog

if.end3:                                          ; preds = %sw.bb
  %9 = load i32, ptr %column_n.addr, align 4
  %cmp4 = icmp eq i32 %9, -1
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end3
  %10 = load ptr, ptr %table, align 8
  %CurrentColumn = getelementptr inbounds %struct.ImGuiTable, ptr %10, i32 0, i32 15
  %11 = load i32, ptr %CurrentColumn, align 4
  store i32 %11, ptr %column_n.addr, align 4
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %if.end3
  %12 = load ptr, ptr %table, align 8
  %VisibleMaskByIndex = getelementptr inbounds %struct.ImGuiTable, ptr %12, i32 0, i32 9
  %13 = load ptr, ptr %VisibleMaskByIndex, align 8
  %14 = load i32, ptr %column_n.addr, align 4
  %shr = ashr i32 %14, 5
  %idxprom = sext i32 %shr to i64
  %arrayidx = getelementptr inbounds i32, ptr %13, i64 %idxprom
  %15 = load i32, ptr %arrayidx, align 4
  %16 = load i32, ptr %column_n.addr, align 4
  %and = and i32 %16, 31
  %shl = shl i32 1, %and
  %and7 = and i32 %15, %shl
  %cmp8 = icmp ne i32 %and7, 0
  br i1 %cmp8, label %if.end10, label %if.then9

if.then9:                                         ; preds = %if.end6
  br label %sw.epilog

if.end10:                                         ; preds = %if.end6
  %17 = load ptr, ptr %table, align 8
  %RowCellDataCurrent = getelementptr inbounds %struct.ImGuiTable, ptr %17, i32 0, i32 88
  %18 = load i16, ptr %RowCellDataCurrent, align 2
  %conv = sext i16 %18 to i32
  %cmp11 = icmp slt i32 %conv, 0
  br i1 %cmp11, label %if.then16, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end10
  %19 = load ptr, ptr %table, align 8
  %RowCellData = getelementptr inbounds %struct.ImGuiTable, ptr %19, i32 0, i32 6
  %20 = load ptr, ptr %table, align 8
  %RowCellDataCurrent12 = getelementptr inbounds %struct.ImGuiTable, ptr %20, i32 0, i32 88
  %21 = load i16, ptr %RowCellDataCurrent12, align 2
  %conv13 = sext i16 %21 to i32
  %call = call noundef nonnull align 4 dereferenceable(8) ptr @_ZN6ImSpanI18ImGuiTableCellDataEixEi(ptr noundef nonnull align 8 dereferenceable(16) %RowCellData, i32 noundef %conv13)
  %Column = getelementptr inbounds %struct.ImGuiTableCellData, ptr %call, i32 0, i32 1
  %22 = load i16, ptr %Column, align 4
  %conv14 = sext i16 %22 to i32
  %23 = load i32, ptr %column_n.addr, align 4
  %cmp15 = icmp ne i32 %conv14, %23
  br i1 %cmp15, label %if.then16, label %if.end18

if.then16:                                        ; preds = %lor.lhs.false, %if.end10
  %24 = load ptr, ptr %table, align 8
  %RowCellDataCurrent17 = getelementptr inbounds %struct.ImGuiTable, ptr %24, i32 0, i32 88
  %25 = load i16, ptr %RowCellDataCurrent17, align 2
  %inc = add i16 %25, 1
  store i16 %inc, ptr %RowCellDataCurrent17, align 2
  br label %if.end18

if.end18:                                         ; preds = %if.then16, %lor.lhs.false
  %26 = load ptr, ptr %table, align 8
  %RowCellData19 = getelementptr inbounds %struct.ImGuiTable, ptr %26, i32 0, i32 6
  %27 = load ptr, ptr %table, align 8
  %RowCellDataCurrent20 = getelementptr inbounds %struct.ImGuiTable, ptr %27, i32 0, i32 88
  %28 = load i16, ptr %RowCellDataCurrent20, align 2
  %conv21 = sext i16 %28 to i32
  %call22 = call noundef nonnull align 4 dereferenceable(8) ptr @_ZN6ImSpanI18ImGuiTableCellDataEixEi(ptr noundef nonnull align 8 dereferenceable(16) %RowCellData19, i32 noundef %conv21)
  store ptr %call22, ptr %cell_data, align 8
  %29 = load i32, ptr %color.addr, align 4
  %30 = load ptr, ptr %cell_data, align 8
  %BgColor = getelementptr inbounds %struct.ImGuiTableCellData, ptr %30, i32 0, i32 0
  store i32 %29, ptr %BgColor, align 4
  %31 = load i32, ptr %column_n.addr, align 4
  %conv23 = trunc i32 %31 to i16
  %32 = load ptr, ptr %cell_data, align 8
  %Column24 = getelementptr inbounds %struct.ImGuiTableCellData, ptr %32, i32 0, i32 1
  store i16 %conv23, ptr %Column24, align 4
  br label %sw.epilog

sw.bb25:                                          ; preds = %if.end, %if.end
  %33 = load ptr, ptr %table, align 8
  %RowPosY126 = getelementptr inbounds %struct.ImGuiTable, ptr %33, i32 0, i32 18
  %34 = load float, ptr %RowPosY126, align 4
  %35 = load ptr, ptr %table, align 8
  %InnerClipRect27 = getelementptr inbounds %struct.ImGuiTable, ptr %35, i32 0, i32 49
  %Max28 = getelementptr inbounds %struct.ImRect, ptr %InnerClipRect27, i32 0, i32 1
  %y29 = getelementptr inbounds %struct.ImVec2, ptr %Max28, i32 0, i32 1
  %36 = load float, ptr %y29, align 4
  %cmp30 = fcmp ogt float %34, %36
  br i1 %cmp30, label %if.then31, label %if.end32

if.then31:                                        ; preds = %sw.bb25
  br label %sw.epilog

if.end32:                                         ; preds = %sw.bb25
  %37 = load i32, ptr %target.addr, align 4
  %cmp33 = icmp eq i32 %37, 2
  %cond = select i1 %cmp33, i32 1, i32 0
  store i32 %cond, ptr %bg_idx, align 4
  %38 = load i32, ptr %color.addr, align 4
  %39 = load ptr, ptr %table, align 8
  %RowBgColor = getelementptr inbounds %struct.ImGuiTable, ptr %39, i32 0, i32 26
  %40 = load i32, ptr %bg_idx, align 4
  %idxprom34 = sext i32 %40 to i64
  %arrayidx35 = getelementptr inbounds [2 x i32], ptr %RowBgColor, i64 0, i64 %idxprom34
  store i32 %38, ptr %arrayidx35, align 4
  br label %sw.epilog

sw.default:                                       ; preds = %if.end
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.end32, %if.then31, %if.end18, %if.then9, %if.then2
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef nonnull align 4 dereferenceable(8) ptr @_ZN6ImSpanI18ImGuiTableCellDataEixEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %i) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %p = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImSpan.37, ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %Data, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr inbounds %struct.ImGuiTableCellData, ptr %0, i64 %idx.ext
  store ptr %add.ptr, ptr %p, align 8
  %2 = load ptr, ptr %p, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nounwind uwtable
define noundef i32 @_ZN5ImGui16TableGetRowIndexEv() #3 {
entry:
  %retval = alloca i32, align 4
  %g = alloca ptr, align 8
  %table = alloca ptr, align 8
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %g, align 8
  %CurrentTable = getelementptr inbounds %struct.ImGuiContext, ptr %1, i32 0, i32 164
  %2 = load ptr, ptr %CurrentTable, align 8
  store ptr %2, ptr %table, align 8
  %3 = load ptr, ptr %table, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %table, align 8
  %CurrentRow = getelementptr inbounds %struct.ImGuiTable, ptr %4, i32 0, i32 14
  %5 = load i32, ptr %CurrentRow, align 8
  store i32 %5, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i32, ptr %retval, align 4
  ret i32 %6
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui12TableNextRowEif(i32 noundef %row_flags, float noundef %row_min_height) #0 {
entry:
  %row_flags.addr = alloca i32, align 4
  %row_min_height.addr = alloca float, align 4
  %g = alloca ptr, align 8
  %table = alloca ptr, align 8
  store i32 %row_flags, ptr %row_flags.addr, align 4
  store float %row_min_height, ptr %row_min_height.addr, align 4
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %g, align 8
  %CurrentTable = getelementptr inbounds %struct.ImGuiContext, ptr %1, i32 0, i32 164
  %2 = load ptr, ptr %CurrentTable, align 8
  store ptr %2, ptr %table, align 8
  %3 = load ptr, ptr %table, align 8
  %IsLayoutLocked = getelementptr inbounds %struct.ImGuiTable, ptr %3, i32 0, i32 92
  %4 = load i8, ptr %IsLayoutLocked, align 2
  %tobool = trunc i8 %4 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load ptr, ptr %table, align 8
  call void @_ZN5ImGui17TableUpdateLayoutEP10ImGuiTable(ptr noundef %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load ptr, ptr %table, align 8
  %IsInsideRow = getelementptr inbounds %struct.ImGuiTable, ptr %6, i32 0, i32 93
  %7 = load i8, ptr %IsInsideRow, align 1
  %tobool1 = trunc i8 %7 to i1
  br i1 %tobool1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %8 = load ptr, ptr %table, align 8
  call void @_ZN5ImGui11TableEndRowEP10ImGuiTable(ptr noundef %8)
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end
  %9 = load ptr, ptr %table, align 8
  %RowFlags = getelementptr inbounds %struct.ImGuiTable, ptr %9, i32 0, i32 24
  %bf.load = load i32, ptr %RowFlags, align 4
  %bf.shl = shl i32 %bf.load, 16
  %bf.ashr = ashr i32 %bf.shl, 16
  %10 = load ptr, ptr %table, align 8
  %LastRowFlags = getelementptr inbounds %struct.ImGuiTable, ptr %10, i32 0, i32 24
  %bf.load4 = load i32, ptr %LastRowFlags, align 4
  %bf.value = and i32 %bf.ashr, 65535
  %bf.shl5 = shl i32 %bf.value, 16
  %bf.clear = and i32 %bf.load4, 65535
  %bf.set = or i32 %bf.clear, %bf.shl5
  store i32 %bf.set, ptr %LastRowFlags, align 4
  %11 = load i32, ptr %row_flags.addr, align 4
  %12 = load ptr, ptr %table, align 8
  %RowFlags6 = getelementptr inbounds %struct.ImGuiTable, ptr %12, i32 0, i32 24
  %bf.load7 = load i32, ptr %RowFlags6, align 4
  %bf.value8 = and i32 %11, 65535
  %bf.clear9 = and i32 %bf.load7, -65536
  %bf.set10 = or i32 %bf.clear9, %bf.value8
  store i32 %bf.set10, ptr %RowFlags6, align 4
  %13 = load ptr, ptr %g, align 8
  %Style = getelementptr inbounds %struct.ImGuiContext, ptr %13, i32 0, i32 3
  %CellPadding = getelementptr inbounds %struct.ImGuiStyle, ptr %Style, i32 0, i32 17
  %y = getelementptr inbounds %struct.ImVec2, ptr %CellPadding, i32 0, i32 1
  %14 = load float, ptr %y, align 4
  %15 = load ptr, ptr %table, align 8
  %RowCellPaddingY = getelementptr inbounds %struct.ImGuiTable, ptr %15, i32 0, i32 21
  store float %14, ptr %RowCellPaddingY, align 8
  %16 = load float, ptr %row_min_height.addr, align 4
  %17 = load ptr, ptr %table, align 8
  %RowMinHeight = getelementptr inbounds %struct.ImGuiTable, ptr %17, i32 0, i32 20
  store float %16, ptr %RowMinHeight, align 4
  %18 = load ptr, ptr %table, align 8
  call void @_ZN5ImGui13TableBeginRowEP10ImGuiTable(ptr noundef %18)
  %19 = load ptr, ptr %table, align 8
  %RowCellPaddingY11 = getelementptr inbounds %struct.ImGuiTable, ptr %19, i32 0, i32 21
  %20 = load float, ptr %RowCellPaddingY11, align 8
  %21 = load ptr, ptr %table, align 8
  %RowPosY2 = getelementptr inbounds %struct.ImGuiTable, ptr %21, i32 0, i32 19
  %22 = load float, ptr %RowPosY2, align 8
  %23 = call float @llvm.fmuladd.f32(float %20, float 2.000000e+00, float %22)
  store float %23, ptr %RowPosY2, align 8
  %24 = load ptr, ptr %table, align 8
  %RowPosY212 = getelementptr inbounds %struct.ImGuiTable, ptr %24, i32 0, i32 19
  %25 = load float, ptr %RowPosY212, align 8
  %26 = load ptr, ptr %table, align 8
  %RowPosY1 = getelementptr inbounds %struct.ImGuiTable, ptr %26, i32 0, i32 18
  %27 = load float, ptr %RowPosY1, align 4
  %28 = load float, ptr %row_min_height.addr, align 4
  %add = fadd float %27, %28
  %call = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %25, float noundef %add)
  %29 = load ptr, ptr %table, align 8
  %RowPosY213 = getelementptr inbounds %struct.ImGuiTable, ptr %29, i32 0, i32 19
  store float %call, ptr %RowPosY213, align 8
  %30 = load ptr, ptr %table, align 8
  %InnerWindow = getelementptr inbounds %struct.ImGuiTable, ptr %30, i32 0, i32 56
  %31 = load ptr, ptr %InnerWindow, align 8
  %SkipItems = getelementptr inbounds %struct.ImGuiWindow, ptr %31, i32 0, i32 38
  store i8 1, ptr %SkipItems, align 1
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui13TableBeginRowEP10ImGuiTable(ptr noundef %table) #0 {
entry:
  %table.addr = alloca ptr, align 8
  %window = alloca ptr, align 8
  %next_y1 = alloca float, align 4
  %ref.tmp = alloca %struct.ImVec2, align 4
  %ref.tmp16 = alloca %struct.ImVec2, align 4
  store ptr %table, ptr %table.addr, align 8
  %0 = load ptr, ptr %table.addr, align 8
  %InnerWindow = getelementptr inbounds %struct.ImGuiTable, ptr %0, i32 0, i32 56
  %1 = load ptr, ptr %InnerWindow, align 8
  store ptr %1, ptr %window, align 8
  %2 = load ptr, ptr %table.addr, align 8
  %CurrentRow = getelementptr inbounds %struct.ImGuiTable, ptr %2, i32 0, i32 14
  %3 = load i32, ptr %CurrentRow, align 8
  %inc = add nsw i32 %3, 1
  store i32 %inc, ptr %CurrentRow, align 8
  %4 = load ptr, ptr %table.addr, align 8
  %CurrentColumn = getelementptr inbounds %struct.ImGuiTable, ptr %4, i32 0, i32 15
  store i32 -1, ptr %CurrentColumn, align 4
  %5 = load ptr, ptr %table.addr, align 8
  %RowBgColor = getelementptr inbounds %struct.ImGuiTable, ptr %5, i32 0, i32 26
  %arrayidx = getelementptr inbounds [2 x i32], ptr %RowBgColor, i64 0, i64 1
  store i32 16777216, ptr %arrayidx, align 4
  %6 = load ptr, ptr %table.addr, align 8
  %RowBgColor1 = getelementptr inbounds %struct.ImGuiTable, ptr %6, i32 0, i32 26
  %arrayidx2 = getelementptr inbounds [2 x i32], ptr %RowBgColor1, i64 0, i64 0
  store i32 16777216, ptr %arrayidx2, align 4
  %7 = load ptr, ptr %table.addr, align 8
  %RowCellDataCurrent = getelementptr inbounds %struct.ImGuiTable, ptr %7, i32 0, i32 88
  store i16 -1, ptr %RowCellDataCurrent, align 2
  %8 = load ptr, ptr %table.addr, align 8
  %IsInsideRow = getelementptr inbounds %struct.ImGuiTable, ptr %8, i32 0, i32 93
  store i8 1, ptr %IsInsideRow, align 1
  %9 = load ptr, ptr %table.addr, align 8
  %RowPosY2 = getelementptr inbounds %struct.ImGuiTable, ptr %9, i32 0, i32 19
  %10 = load float, ptr %RowPosY2, align 8
  store float %10, ptr %next_y1, align 4
  %11 = load ptr, ptr %table.addr, align 8
  %CurrentRow3 = getelementptr inbounds %struct.ImGuiTable, ptr %11, i32 0, i32 14
  %12 = load i32, ptr %CurrentRow3, align 8
  %cmp = icmp eq i32 %12, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %13 = load ptr, ptr %table.addr, align 8
  %FreezeRowsCount = getelementptr inbounds %struct.ImGuiTable, ptr %13, i32 0, i32 85
  %14 = load i16, ptr %FreezeRowsCount, align 8
  %conv = sext i16 %14 to i32
  %cmp4 = icmp sgt i32 %conv, 0
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %table.addr, align 8
  %OuterRect = getelementptr inbounds %struct.ImGuiTable, ptr %15, i32 0, i32 46
  %Min = getelementptr inbounds %struct.ImRect, ptr %OuterRect, i32 0, i32 0
  %y = getelementptr inbounds %struct.ImVec2, ptr %Min, i32 0, i32 1
  %16 = load float, ptr %y, align 4
  %17 = load ptr, ptr %window, align 8
  %DC = getelementptr inbounds %struct.ImGuiWindow, ptr %17, i32 0, i32 68
  %CursorPos = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC, i32 0, i32 0
  %y5 = getelementptr inbounds %struct.ImVec2, ptr %CursorPos, i32 0, i32 1
  store float %16, ptr %y5, align 4
  store float %16, ptr %next_y1, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %18 = load float, ptr %next_y1, align 4
  %19 = load ptr, ptr %table.addr, align 8
  %RowPosY26 = getelementptr inbounds %struct.ImGuiTable, ptr %19, i32 0, i32 19
  store float %18, ptr %RowPosY26, align 8
  %20 = load ptr, ptr %table.addr, align 8
  %RowPosY1 = getelementptr inbounds %struct.ImGuiTable, ptr %20, i32 0, i32 18
  store float %18, ptr %RowPosY1, align 4
  %21 = load ptr, ptr %table.addr, align 8
  %RowTextBaseline = getelementptr inbounds %struct.ImGuiTable, ptr %21, i32 0, i32 22
  store float 0.000000e+00, ptr %RowTextBaseline, align 4
  %22 = load ptr, ptr %window, align 8
  %DC7 = getelementptr inbounds %struct.ImGuiWindow, ptr %22, i32 0, i32 68
  %Indent = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC7, i32 0, i32 11
  %x = getelementptr inbounds %struct.ImVec1, ptr %Indent, i32 0, i32 0
  %23 = load float, ptr %x, align 4
  %24 = load ptr, ptr %table.addr, align 8
  %HostIndentX = getelementptr inbounds %struct.ImGuiTable, ptr %24, i32 0, i32 31
  %25 = load float, ptr %HostIndentX, align 4
  %sub = fsub float %23, %25
  %26 = load ptr, ptr %table.addr, align 8
  %RowIndentOffsetX = getelementptr inbounds %struct.ImGuiTable, ptr %26, i32 0, i32 23
  store float %sub, ptr %RowIndentOffsetX, align 8
  %27 = load ptr, ptr %window, align 8
  %DC8 = getelementptr inbounds %struct.ImGuiWindow, ptr %27, i32 0, i32 68
  %PrevLineTextBaseOffset = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC8, i32 0, i32 8
  store float 0.000000e+00, ptr %PrevLineTextBaseOffset, align 4
  %28 = load ptr, ptr %window, align 8
  %DC9 = getelementptr inbounds %struct.ImGuiWindow, ptr %28, i32 0, i32 68
  %CursorPos10 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC9, i32 0, i32 0
  %x11 = getelementptr inbounds %struct.ImVec2, ptr %CursorPos10, i32 0, i32 0
  %29 = load float, ptr %x11, align 8
  %30 = load ptr, ptr %window, align 8
  %DC12 = getelementptr inbounds %struct.ImGuiWindow, ptr %30, i32 0, i32 68
  %CursorPos13 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC12, i32 0, i32 0
  %y14 = getelementptr inbounds %struct.ImVec2, ptr %CursorPos13, i32 0, i32 1
  %31 = load float, ptr %y14, align 4
  %32 = load ptr, ptr %table.addr, align 8
  %RowCellPaddingY = getelementptr inbounds %struct.ImGuiTable, ptr %32, i32 0, i32 21
  %33 = load float, ptr %RowCellPaddingY, align 8
  %add = fadd float %31, %33
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp, float noundef %29, float noundef %add)
  %34 = load ptr, ptr %window, align 8
  %DC15 = getelementptr inbounds %struct.ImGuiWindow, ptr %34, i32 0, i32 68
  %CursorPosPrevLine = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC15, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %CursorPosPrevLine, ptr align 4 %ref.tmp, i64 8, i1 false)
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp16, float noundef 0.000000e+00, float noundef 0.000000e+00)
  %35 = load ptr, ptr %window, align 8
  %DC17 = getelementptr inbounds %struct.ImGuiWindow, ptr %35, i32 0, i32 68
  %CurrLineSize = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC17, i32 0, i32 5
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %CurrLineSize, ptr align 4 %ref.tmp16, i64 8, i1 false)
  %36 = load ptr, ptr %window, align 8
  %DC18 = getelementptr inbounds %struct.ImGuiWindow, ptr %36, i32 0, i32 68
  %PrevLineSize = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC18, i32 0, i32 6
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %PrevLineSize, ptr align 4 %CurrLineSize, i64 8, i1 false)
  %37 = load ptr, ptr %window, align 8
  %DC19 = getelementptr inbounds %struct.ImGuiWindow, ptr %37, i32 0, i32 68
  %IsSetPos = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC19, i32 0, i32 10
  store i8 0, ptr %IsSetPos, align 1
  %38 = load ptr, ptr %window, align 8
  %DC20 = getelementptr inbounds %struct.ImGuiWindow, ptr %38, i32 0, i32 68
  %IsSameLine = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC20, i32 0, i32 9
  store i8 0, ptr %IsSameLine, align 8
  %39 = load float, ptr %next_y1, align 4
  %40 = load ptr, ptr %window, align 8
  %DC21 = getelementptr inbounds %struct.ImGuiWindow, ptr %40, i32 0, i32 68
  %CursorMaxPos = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC21, i32 0, i32 3
  %y22 = getelementptr inbounds %struct.ImVec2, ptr %CursorMaxPos, i32 0, i32 1
  store float %39, ptr %y22, align 4
  %41 = load ptr, ptr %table.addr, align 8
  %RowFlags = getelementptr inbounds %struct.ImGuiTable, ptr %41, i32 0, i32 24
  %bf.load = load i32, ptr %RowFlags, align 4
  %bf.shl = shl i32 %bf.load, 16
  %bf.ashr = ashr i32 %bf.shl, 16
  %and = and i32 %bf.ashr, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then23, label %if.end28

if.then23:                                        ; preds = %if.end
  %call = call noundef i32 @_ZN5ImGui11GetColorU32Eif(i32 noundef 42, float noundef 1.000000e+00)
  call void @_ZN5ImGui15TableSetBgColorEiji(i32 noundef 1, i32 noundef %call, i32 noundef -1)
  %42 = load ptr, ptr %table.addr, align 8
  %CurrentRow24 = getelementptr inbounds %struct.ImGuiTable, ptr %42, i32 0, i32 14
  %43 = load i32, ptr %CurrentRow24, align 8
  %cmp25 = icmp eq i32 %43, 0
  br i1 %cmp25, label %if.then26, label %if.end27

if.then26:                                        ; preds = %if.then23
  %44 = load ptr, ptr %table.addr, align 8
  %IsUsingHeaders = getelementptr inbounds %struct.ImGuiTable, ptr %44, i32 0, i32 96
  store i8 1, ptr %IsUsingHeaders, align 2
  br label %if.end27

if.end27:                                         ; preds = %if.then26, %if.then23
  br label %if.end28

if.end28:                                         ; preds = %if.end27, %if.end
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui12TableEndCellEP10ImGuiTable(ptr noundef %table) #0 {
entry:
  %table.addr = alloca ptr, align 8
  %column = alloca ptr, align 8
  %window = alloca ptr, align 8
  %p_max_pos_x = alloca ptr, align 8
  store ptr %table, ptr %table.addr, align 8
  %0 = load ptr, ptr %table.addr, align 8
  %Columns = getelementptr inbounds %struct.ImGuiTable, ptr %0, i32 0, i32 4
  %1 = load ptr, ptr %table.addr, align 8
  %CurrentColumn = getelementptr inbounds %struct.ImGuiTable, ptr %1, i32 0, i32 15
  %2 = load i32, ptr %CurrentColumn, align 4
  %call = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns, i32 noundef %2)
  store ptr %call, ptr %column, align 8
  %3 = load ptr, ptr %table.addr, align 8
  %InnerWindow = getelementptr inbounds %struct.ImGuiTable, ptr %3, i32 0, i32 56
  %4 = load ptr, ptr %InnerWindow, align 8
  store ptr %4, ptr %window, align 8
  %5 = load ptr, ptr %window, align 8
  %DC = getelementptr inbounds %struct.ImGuiWindow, ptr %5, i32 0, i32 68
  %IsSetPos = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC, i32 0, i32 10
  %6 = load i8, ptr %IsSetPos, align 1
  %tobool = trunc i8 %6 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @_ZN5ImGui51ErrorCheckUsingSetCursorPosToExtendParentBoundariesEv()
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %7 = load ptr, ptr %table.addr, align 8
  %RowFlags = getelementptr inbounds %struct.ImGuiTable, ptr %7, i32 0, i32 24
  %bf.load = load i32, ptr %RowFlags, align 4
  %bf.shl = shl i32 %bf.load, 16
  %bf.ashr = ashr i32 %bf.shl, 16
  %and = and i32 %bf.ashr, 1
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.end
  %8 = load ptr, ptr %column, align 8
  %ContentMaxXHeadersUsed = getelementptr inbounds %struct.ImGuiTableColumn, ptr %8, i32 0, i32 15
  store ptr %ContentMaxXHeadersUsed, ptr %p_max_pos_x, align 8
  br label %if.end4

if.else:                                          ; preds = %if.end
  %9 = load ptr, ptr %table.addr, align 8
  %IsUnfrozenRows = getelementptr inbounds %struct.ImGuiTable, ptr %9, i32 0, i32 104
  %10 = load i8, ptr %IsUnfrozenRows, align 2
  %tobool3 = trunc i8 %10 to i1
  br i1 %tobool3, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.else
  %11 = load ptr, ptr %column, align 8
  %ContentMaxXUnfrozen = getelementptr inbounds %struct.ImGuiTableColumn, ptr %11, i32 0, i32 14
  br label %cond.end

cond.false:                                       ; preds = %if.else
  %12 = load ptr, ptr %column, align 8
  %ContentMaxXFrozen = getelementptr inbounds %struct.ImGuiTableColumn, ptr %12, i32 0, i32 13
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %ContentMaxXUnfrozen, %cond.true ], [ %ContentMaxXFrozen, %cond.false ]
  store ptr %cond, ptr %p_max_pos_x, align 8
  br label %if.end4

if.end4:                                          ; preds = %cond.end, %if.then2
  %13 = load ptr, ptr %p_max_pos_x, align 8
  %14 = load float, ptr %13, align 4
  %15 = load ptr, ptr %window, align 8
  %DC5 = getelementptr inbounds %struct.ImGuiWindow, ptr %15, i32 0, i32 68
  %CursorMaxPos = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC5, i32 0, i32 3
  %x = getelementptr inbounds %struct.ImVec2, ptr %CursorMaxPos, i32 0, i32 0
  %16 = load float, ptr %x, align 8
  %call6 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %14, float noundef %16)
  %17 = load ptr, ptr %p_max_pos_x, align 8
  store float %call6, ptr %17, align 4
  %18 = load ptr, ptr %column, align 8
  %IsEnabled = getelementptr inbounds %struct.ImGuiTableColumn, ptr %18, i32 0, i32 26
  %19 = load i8, ptr %IsEnabled, align 2
  %tobool7 = trunc i8 %19 to i1
  br i1 %tobool7, label %if.then8, label %if.end13

if.then8:                                         ; preds = %if.end4
  %20 = load ptr, ptr %table.addr, align 8
  %RowPosY2 = getelementptr inbounds %struct.ImGuiTable, ptr %20, i32 0, i32 19
  %21 = load float, ptr %RowPosY2, align 8
  %22 = load ptr, ptr %window, align 8
  %DC9 = getelementptr inbounds %struct.ImGuiWindow, ptr %22, i32 0, i32 68
  %CursorMaxPos10 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC9, i32 0, i32 3
  %y = getelementptr inbounds %struct.ImVec2, ptr %CursorMaxPos10, i32 0, i32 1
  %23 = load float, ptr %y, align 4
  %24 = load ptr, ptr %table.addr, align 8
  %RowCellPaddingY = getelementptr inbounds %struct.ImGuiTable, ptr %24, i32 0, i32 21
  %25 = load float, ptr %RowCellPaddingY, align 8
  %add = fadd float %23, %25
  %call11 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %21, float noundef %add)
  %26 = load ptr, ptr %table.addr, align 8
  %RowPosY212 = getelementptr inbounds %struct.ImGuiTable, ptr %26, i32 0, i32 19
  store float %call11, ptr %RowPosY212, align 8
  br label %if.end13

if.end13:                                         ; preds = %if.then8, %if.end4
  %27 = load ptr, ptr %window, align 8
  %DC14 = getelementptr inbounds %struct.ImGuiWindow, ptr %27, i32 0, i32 68
  %ItemWidth = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC14, i32 0, i32 32
  %28 = load float, ptr %ItemWidth, align 4
  %29 = load ptr, ptr %column, align 8
  %ItemWidth15 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %29, i32 0, i32 12
  store float %28, ptr %ItemWidth15, align 4
  %30 = load ptr, ptr %table.addr, align 8
  %RowTextBaseline = getelementptr inbounds %struct.ImGuiTable, ptr %30, i32 0, i32 22
  %31 = load float, ptr %RowTextBaseline, align 4
  %32 = load ptr, ptr %window, align 8
  %DC16 = getelementptr inbounds %struct.ImGuiWindow, ptr %32, i32 0, i32 68
  %PrevLineTextBaseOffset = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC16, i32 0, i32 8
  %33 = load float, ptr %PrevLineTextBaseOffset, align 4
  %call17 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %31, float noundef %33)
  %34 = load ptr, ptr %table.addr, align 8
  %RowTextBaseline18 = getelementptr inbounds %struct.ImGuiTable, ptr %34, i32 0, i32 22
  store float %call17, ptr %RowTextBaseline18, align 4
  ret void
}

declare void @_ZN5ImGui15LogRenderedTextEPK6ImVec2PKcS4_(ptr noundef, ptr noundef, ptr noundef) #1

; Function Attrs: mustprogress uwtable
define linkonce_odr { <2 x float>, <2 x float> } @_ZNK6ImRect6ToVec4Ev(ptr noundef nonnull align 4 dereferenceable(16) %this) #0 comdat align 2 {
entry:
  %retval = alloca %struct.ImVec4, align 4
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Min = getelementptr inbounds %struct.ImRect, ptr %this1, i32 0, i32 0
  %x = getelementptr inbounds %struct.ImVec2, ptr %Min, i32 0, i32 0
  %0 = load float, ptr %x, align 4
  %Min2 = getelementptr inbounds %struct.ImRect, ptr %this1, i32 0, i32 0
  %y = getelementptr inbounds %struct.ImVec2, ptr %Min2, i32 0, i32 1
  %1 = load float, ptr %y, align 4
  %Max = getelementptr inbounds %struct.ImRect, ptr %this1, i32 0, i32 1
  %x3 = getelementptr inbounds %struct.ImVec2, ptr %Max, i32 0, i32 0
  %2 = load float, ptr %x3, align 4
  %Max4 = getelementptr inbounds %struct.ImRect, ptr %this1, i32 0, i32 1
  %y5 = getelementptr inbounds %struct.ImVec2, ptr %Max4, i32 0, i32 1
  %3 = load float, ptr %y5, align 4
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %retval, float noundef %0, float noundef %1, float noundef %2, float noundef %3)
  %4 = load { <2 x float>, <2 x float> }, ptr %retval, align 4
  ret { <2 x float>, <2 x float> } %4
}

declare void @_ZN10ImDrawList13AddRectFilledERK6ImVec2S2_jfi(ptr noundef nonnull align 8 dereferenceable(196), ptr noundef nonnull align 4 dereferenceable(8), ptr noundef nonnull align 4 dereferenceable(8), i32 noundef, float noundef, i32 noundef) #1

declare void @_ZN10ImDrawList7AddLineERK6ImVec2S2_jf(ptr noundef nonnull align 8 dereferenceable(196), ptr noundef nonnull align 4 dereferenceable(8), ptr noundef nonnull align 4 dereferenceable(8), i32 noundef, float noundef) #1

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui33SetWindowClipRectBeforeSetChannelEP11ImGuiWindowRK6ImRect(ptr noundef %window, ptr noundef nonnull align 4 dereferenceable(16) %clip_rect) #2 {
entry:
  %window.addr = alloca ptr, align 8
  %clip_rect.addr = alloca ptr, align 8
  %clip_rect_vec4 = alloca %struct.ImVec4, align 4
  store ptr %window, ptr %window.addr, align 8
  store ptr %clip_rect, ptr %clip_rect.addr, align 8
  %0 = load ptr, ptr %clip_rect.addr, align 8
  %call = call { <2 x float>, <2 x float> } @_ZNK6ImRect6ToVec4Ev(ptr noundef nonnull align 4 dereferenceable(16) %0)
  %1 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %clip_rect_vec4, i32 0, i32 0
  %2 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %2, ptr %1, align 4
  %3 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %clip_rect_vec4, i32 0, i32 1
  %4 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %4, ptr %3, align 4
  %5 = load ptr, ptr %clip_rect.addr, align 8
  %6 = load ptr, ptr %window.addr, align 8
  %ClipRect = getelementptr inbounds %struct.ImGuiWindow, ptr %6, i32 0, i32 74
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %ClipRect, ptr align 4 %5, i64 16, i1 false)
  %7 = load ptr, ptr %window.addr, align 8
  %DrawList = getelementptr inbounds %struct.ImGuiWindow, ptr %7, i32 0, i32 86
  %8 = load ptr, ptr %DrawList, align 8
  %_CmdHeader = getelementptr inbounds %struct.ImDrawList, ptr %8, i32 0, i32 12
  %ClipRect1 = getelementptr inbounds %struct.ImDrawCmdHeader, ptr %_CmdHeader, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %ClipRect1, ptr align 4 %clip_rect_vec4, i64 16, i1 false)
  %9 = load ptr, ptr %window.addr, align 8
  %DrawList2 = getelementptr inbounds %struct.ImGuiWindow, ptr %9, i32 0, i32 86
  %10 = load ptr, ptr %DrawList2, align 8
  %_ClipRectStack = getelementptr inbounds %struct.ImDrawList, ptr %10, i32 0, i32 9
  %Data = getelementptr inbounds %struct.ImVector.34, ptr %_ClipRectStack, i32 0, i32 2
  %11 = load ptr, ptr %Data, align 8
  %12 = load ptr, ptr %window.addr, align 8
  %DrawList3 = getelementptr inbounds %struct.ImGuiWindow, ptr %12, i32 0, i32 86
  %13 = load ptr, ptr %DrawList3, align 8
  %_ClipRectStack4 = getelementptr inbounds %struct.ImDrawList, ptr %13, i32 0, i32 9
  %Size = getelementptr inbounds %struct.ImVector.34, ptr %_ClipRectStack4, i32 0, i32 0
  %14 = load i32, ptr %Size, align 8
  %sub = sub nsw i32 %14, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.ImVec4, ptr %11, i64 %idxprom
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx, ptr align 4 %clip_rect_vec4, i64 16, i1 false)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define noundef i32 @_ZN5ImGui19TableGetColumnIndexEv() #3 {
entry:
  %retval = alloca i32, align 4
  %g = alloca ptr, align 8
  %table = alloca ptr, align 8
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %g, align 8
  %CurrentTable = getelementptr inbounds %struct.ImGuiContext, ptr %1, i32 0, i32 164
  %2 = load ptr, ptr %CurrentTable, align 8
  store ptr %2, ptr %table, align 8
  %3 = load ptr, ptr %table, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %table, align 8
  %CurrentColumn = getelementptr inbounds %struct.ImGuiTable, ptr %4, i32 0, i32 15
  %5 = load i32, ptr %CurrentColumn, align 4
  store i32 %5, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i32, ptr %retval, align 4
  ret i32 %6
}

; Function Attrs: mustprogress uwtable
define noundef zeroext i1 @_ZN5ImGui19TableSetColumnIndexEi(i32 noundef %column_n) #0 {
entry:
  %retval = alloca i1, align 1
  %column_n.addr = alloca i32, align 4
  %g = alloca ptr, align 8
  %table = alloca ptr, align 8
  store i32 %column_n, ptr %column_n.addr, align 4
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %g, align 8
  %CurrentTable = getelementptr inbounds %struct.ImGuiContext, ptr %1, i32 0, i32 164
  %2 = load ptr, ptr %CurrentTable, align 8
  store ptr %2, ptr %table, align 8
  %3 = load ptr, ptr %table, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %table, align 8
  %CurrentColumn = getelementptr inbounds %struct.ImGuiTable, ptr %4, i32 0, i32 15
  %5 = load i32, ptr %CurrentColumn, align 4
  %6 = load i32, ptr %column_n.addr, align 4
  %cmp = icmp ne i32 %5, %6
  br i1 %cmp, label %if.then1, label %if.end6

if.then1:                                         ; preds = %if.end
  %7 = load ptr, ptr %table, align 8
  %CurrentColumn2 = getelementptr inbounds %struct.ImGuiTable, ptr %7, i32 0, i32 15
  %8 = load i32, ptr %CurrentColumn2, align 4
  %cmp3 = icmp ne i32 %8, -1
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.then1
  %9 = load ptr, ptr %table, align 8
  call void @_ZN5ImGui12TableEndCellEP10ImGuiTable(ptr noundef %9)
  br label %if.end5

if.end5:                                          ; preds = %if.then4, %if.then1
  %10 = load ptr, ptr %table, align 8
  %11 = load i32, ptr %column_n.addr, align 4
  call void @_ZN5ImGui14TableBeginCellEP10ImGuiTablei(ptr noundef %10, i32 noundef %11)
  br label %if.end6

if.end6:                                          ; preds = %if.end5, %if.end
  %12 = load ptr, ptr %table, align 8
  %Columns = getelementptr inbounds %struct.ImGuiTable, ptr %12, i32 0, i32 4
  %13 = load i32, ptr %column_n.addr, align 4
  %call = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns, i32 noundef %13)
  %IsRequestOutput = getelementptr inbounds %struct.ImGuiTableColumn, ptr %call, i32 0, i32 31
  %14 = load i8, ptr %IsRequestOutput, align 1
  %tobool7 = trunc i8 %14 to i1
  store i1 %tobool7, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end6, %if.then
  %15 = load i1, ptr %retval, align 1
  ret i1 %15
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui14TableBeginCellEP10ImGuiTablei(ptr noundef %table, i32 noundef %column_n) #0 {
entry:
  %table.addr = alloca ptr, align 8
  %column_n.addr = alloca i32, align 4
  %g = alloca ptr, align 8
  %column = alloca ptr, align 8
  %window = alloca ptr, align 8
  %start_x = alloca float, align 4
  store ptr %table, ptr %table.addr, align 8
  store i32 %column_n, ptr %column_n.addr, align 4
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %table.addr, align 8
  %Columns = getelementptr inbounds %struct.ImGuiTable, ptr %1, i32 0, i32 4
  %2 = load i32, ptr %column_n.addr, align 4
  %call = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns, i32 noundef %2)
  store ptr %call, ptr %column, align 8
  %3 = load ptr, ptr %table.addr, align 8
  %InnerWindow = getelementptr inbounds %struct.ImGuiTable, ptr %3, i32 0, i32 56
  %4 = load ptr, ptr %InnerWindow, align 8
  store ptr %4, ptr %window, align 8
  %5 = load i32, ptr %column_n.addr, align 4
  %6 = load ptr, ptr %table.addr, align 8
  %CurrentColumn = getelementptr inbounds %struct.ImGuiTable, ptr %6, i32 0, i32 15
  store i32 %5, ptr %CurrentColumn, align 4
  %7 = load ptr, ptr %column, align 8
  %WorkMinX = getelementptr inbounds %struct.ImGuiTableColumn, ptr %7, i32 0, i32 10
  %8 = load float, ptr %WorkMinX, align 4
  store float %8, ptr %start_x, align 4
  %9 = load ptr, ptr %column, align 8
  %Flags = getelementptr inbounds %struct.ImGuiTableColumn, ptr %9, i32 0, i32 0
  %10 = load i32, ptr %Flags, align 4
  %and = and i32 %10, 65536
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %11 = load ptr, ptr %table.addr, align 8
  %RowIndentOffsetX = getelementptr inbounds %struct.ImGuiTable, ptr %11, i32 0, i32 23
  %12 = load float, ptr %RowIndentOffsetX, align 8
  %13 = load float, ptr %start_x, align 4
  %add = fadd float %13, %12
  store float %add, ptr %start_x, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %14 = load float, ptr %start_x, align 4
  %15 = load ptr, ptr %window, align 8
  %DC = getelementptr inbounds %struct.ImGuiWindow, ptr %15, i32 0, i32 68
  %CursorPos = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC, i32 0, i32 0
  %x = getelementptr inbounds %struct.ImVec2, ptr %CursorPos, i32 0, i32 0
  store float %14, ptr %x, align 8
  %16 = load ptr, ptr %table.addr, align 8
  %RowPosY1 = getelementptr inbounds %struct.ImGuiTable, ptr %16, i32 0, i32 18
  %17 = load float, ptr %RowPosY1, align 4
  %18 = load ptr, ptr %table.addr, align 8
  %RowCellPaddingY = getelementptr inbounds %struct.ImGuiTable, ptr %18, i32 0, i32 21
  %19 = load float, ptr %RowCellPaddingY, align 8
  %add1 = fadd float %17, %19
  %20 = load ptr, ptr %window, align 8
  %DC2 = getelementptr inbounds %struct.ImGuiWindow, ptr %20, i32 0, i32 68
  %CursorPos3 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC2, i32 0, i32 0
  %y = getelementptr inbounds %struct.ImVec2, ptr %CursorPos3, i32 0, i32 1
  store float %add1, ptr %y, align 4
  %21 = load ptr, ptr %window, align 8
  %DC4 = getelementptr inbounds %struct.ImGuiWindow, ptr %21, i32 0, i32 68
  %CursorPos5 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC4, i32 0, i32 0
  %x6 = getelementptr inbounds %struct.ImVec2, ptr %CursorPos5, i32 0, i32 0
  %22 = load float, ptr %x6, align 8
  %23 = load ptr, ptr %window, align 8
  %DC7 = getelementptr inbounds %struct.ImGuiWindow, ptr %23, i32 0, i32 68
  %CursorMaxPos = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC7, i32 0, i32 3
  %x8 = getelementptr inbounds %struct.ImVec2, ptr %CursorMaxPos, i32 0, i32 0
  store float %22, ptr %x8, align 8
  %24 = load float, ptr %start_x, align 4
  %25 = load ptr, ptr %window, align 8
  %Pos = getelementptr inbounds %struct.ImGuiWindow, ptr %25, i32 0, i32 7
  %x9 = getelementptr inbounds %struct.ImVec2, ptr %Pos, i32 0, i32 0
  %26 = load float, ptr %x9, align 8
  %sub = fsub float %24, %26
  %27 = load ptr, ptr %window, align 8
  %DC10 = getelementptr inbounds %struct.ImGuiWindow, ptr %27, i32 0, i32 68
  %Indent = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC10, i32 0, i32 11
  %x11 = getelementptr inbounds %struct.ImVec1, ptr %Indent, i32 0, i32 0
  %28 = load float, ptr %x11, align 4
  %sub12 = fsub float %sub, %28
  %29 = load ptr, ptr %window, align 8
  %DC13 = getelementptr inbounds %struct.ImGuiWindow, ptr %29, i32 0, i32 68
  %ColumnsOffset = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC13, i32 0, i32 12
  %x14 = getelementptr inbounds %struct.ImVec1, ptr %ColumnsOffset, i32 0, i32 0
  store float %sub12, ptr %x14, align 8
  %30 = load ptr, ptr %window, align 8
  %DC15 = getelementptr inbounds %struct.ImGuiWindow, ptr %30, i32 0, i32 68
  %CursorPos16 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC15, i32 0, i32 0
  %x17 = getelementptr inbounds %struct.ImVec2, ptr %CursorPos16, i32 0, i32 0
  %31 = load float, ptr %x17, align 8
  %32 = load ptr, ptr %window, align 8
  %DC18 = getelementptr inbounds %struct.ImGuiWindow, ptr %32, i32 0, i32 68
  %CursorPosPrevLine = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC18, i32 0, i32 1
  %x19 = getelementptr inbounds %struct.ImVec2, ptr %CursorPosPrevLine, i32 0, i32 0
  store float %31, ptr %x19, align 8
  %33 = load ptr, ptr %table.addr, align 8
  %RowTextBaseline = getelementptr inbounds %struct.ImGuiTable, ptr %33, i32 0, i32 22
  %34 = load float, ptr %RowTextBaseline, align 4
  %35 = load ptr, ptr %window, align 8
  %DC20 = getelementptr inbounds %struct.ImGuiWindow, ptr %35, i32 0, i32 68
  %CurrLineTextBaseOffset = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC20, i32 0, i32 7
  store float %34, ptr %CurrLineTextBaseOffset, align 8
  %36 = load ptr, ptr %column, align 8
  %NavLayerCurrent = getelementptr inbounds %struct.ImGuiTableColumn, ptr %36, i32 0, i32 34
  %37 = load i8, ptr %NavLayerCurrent, align 2
  %conv = sext i8 %37 to i32
  %38 = load ptr, ptr %window, align 8
  %DC21 = getelementptr inbounds %struct.ImGuiWindow, ptr %38, i32 0, i32 68
  %NavLayerCurrent22 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC21, i32 0, i32 15
  store i32 %conv, ptr %NavLayerCurrent22, align 8
  %39 = load ptr, ptr %window, align 8
  %DC23 = getelementptr inbounds %struct.ImGuiWindow, ptr %39, i32 0, i32 68
  %CursorPos24 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC23, i32 0, i32 0
  %y25 = getelementptr inbounds %struct.ImVec2, ptr %CursorPos24, i32 0, i32 1
  %40 = load float, ptr %y25, align 4
  %41 = load ptr, ptr %window, align 8
  %WorkRect = getelementptr inbounds %struct.ImGuiWindow, ptr %41, i32 0, i32 72
  %Min = getelementptr inbounds %struct.ImRect, ptr %WorkRect, i32 0, i32 0
  %y26 = getelementptr inbounds %struct.ImVec2, ptr %Min, i32 0, i32 1
  store float %40, ptr %y26, align 4
  %42 = load ptr, ptr %column, align 8
  %WorkMinX27 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %42, i32 0, i32 10
  %43 = load float, ptr %WorkMinX27, align 4
  %44 = load ptr, ptr %window, align 8
  %WorkRect28 = getelementptr inbounds %struct.ImGuiWindow, ptr %44, i32 0, i32 72
  %Min29 = getelementptr inbounds %struct.ImRect, ptr %WorkRect28, i32 0, i32 0
  %x30 = getelementptr inbounds %struct.ImVec2, ptr %Min29, i32 0, i32 0
  store float %43, ptr %x30, align 8
  %45 = load ptr, ptr %column, align 8
  %WorkMaxX = getelementptr inbounds %struct.ImGuiTableColumn, ptr %45, i32 0, i32 11
  %46 = load float, ptr %WorkMaxX, align 4
  %47 = load ptr, ptr %window, align 8
  %WorkRect31 = getelementptr inbounds %struct.ImGuiWindow, ptr %47, i32 0, i32 72
  %Max = getelementptr inbounds %struct.ImRect, ptr %WorkRect31, i32 0, i32 1
  %x32 = getelementptr inbounds %struct.ImVec2, ptr %Max, i32 0, i32 0
  store float %46, ptr %x32, align 8
  %48 = load ptr, ptr %column, align 8
  %ItemWidth = getelementptr inbounds %struct.ImGuiTableColumn, ptr %48, i32 0, i32 12
  %49 = load float, ptr %ItemWidth, align 4
  %50 = load ptr, ptr %window, align 8
  %DC33 = getelementptr inbounds %struct.ImGuiWindow, ptr %50, i32 0, i32 68
  %ItemWidth34 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC33, i32 0, i32 32
  store float %49, ptr %ItemWidth34, align 4
  %51 = load ptr, ptr %column, align 8
  %IsSkipItems = getelementptr inbounds %struct.ImGuiTableColumn, ptr %51, i32 0, i32 32
  %52 = load i8, ptr %IsSkipItems, align 4
  %tobool35 = trunc i8 %52 to i1
  %53 = load ptr, ptr %window, align 8
  %SkipItems = getelementptr inbounds %struct.ImGuiWindow, ptr %53, i32 0, i32 38
  %frombool = zext i1 %tobool35 to i8
  store i8 %frombool, ptr %SkipItems, align 1
  %54 = load ptr, ptr %column, align 8
  %IsSkipItems36 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %54, i32 0, i32 32
  %55 = load i8, ptr %IsSkipItems36, align 4
  %tobool37 = trunc i8 %55 to i1
  br i1 %tobool37, label %if.then38, label %if.end40

if.then38:                                        ; preds = %if.end
  %56 = load ptr, ptr %g, align 8
  %LastItemData = getelementptr inbounds %struct.ImGuiContext, ptr %56, i32 0, i32 75
  %ID = getelementptr inbounds %struct.ImGuiLastItemData, ptr %LastItemData, i32 0, i32 0
  store i32 0, ptr %ID, align 8
  %57 = load ptr, ptr %g, align 8
  %LastItemData39 = getelementptr inbounds %struct.ImGuiContext, ptr %57, i32 0, i32 75
  %StatusFlags = getelementptr inbounds %struct.ImGuiLastItemData, ptr %LastItemData39, i32 0, i32 2
  store i32 0, ptr %StatusFlags, align 8
  br label %if.end40

if.end40:                                         ; preds = %if.then38, %if.end
  %58 = load ptr, ptr %table.addr, align 8
  %Flags41 = getelementptr inbounds %struct.ImGuiTable, ptr %58, i32 0, i32 1
  %59 = load i32, ptr %Flags41, align 4
  %and42 = and i32 %59, 1048576
  %tobool43 = icmp ne i32 %and42, 0
  br i1 %tobool43, label %if.then44, label %if.else

if.then44:                                        ; preds = %if.end40
  %60 = load ptr, ptr %table.addr, align 8
  %DrawSplitter = getelementptr inbounds %struct.ImGuiTable, ptr %60, i32 0, i32 58
  %61 = load ptr, ptr %DrawSplitter, align 8
  %62 = load ptr, ptr %window, align 8
  %DrawList = getelementptr inbounds %struct.ImGuiWindow, ptr %62, i32 0, i32 86
  %63 = load ptr, ptr %DrawList, align 8
  call void @_ZN18ImDrawListSplitter17SetCurrentChannelEP10ImDrawListi(ptr noundef nonnull align 8 dereferenceable(24) %61, ptr noundef %63, i32 noundef 2)
  br label %if.end48

if.else:                                          ; preds = %if.end40
  %64 = load ptr, ptr %window, align 8
  %65 = load ptr, ptr %column, align 8
  %ClipRect = getelementptr inbounds %struct.ImGuiTableColumn, ptr %65, i32 0, i32 8
  call void @_ZN5ImGui33SetWindowClipRectBeforeSetChannelEP11ImGuiWindowRK6ImRect(ptr noundef %64, ptr noundef nonnull align 4 dereferenceable(16) %ClipRect)
  %66 = load ptr, ptr %table.addr, align 8
  %DrawSplitter45 = getelementptr inbounds %struct.ImGuiTable, ptr %66, i32 0, i32 58
  %67 = load ptr, ptr %DrawSplitter45, align 8
  %68 = load ptr, ptr %window, align 8
  %DrawList46 = getelementptr inbounds %struct.ImGuiWindow, ptr %68, i32 0, i32 86
  %69 = load ptr, ptr %DrawList46, align 8
  %70 = load ptr, ptr %column, align 8
  %DrawChannelCurrent = getelementptr inbounds %struct.ImGuiTableColumn, ptr %70, i32 0, i32 23
  %71 = load i16, ptr %DrawChannelCurrent, align 4
  %conv47 = zext i16 %71 to i32
  call void @_ZN18ImDrawListSplitter17SetCurrentChannelEP10ImDrawListi(ptr noundef nonnull align 8 dereferenceable(24) %67, ptr noundef %69, i32 noundef %conv47)
  br label %if.end48

if.end48:                                         ; preds = %if.else, %if.then44
  %72 = load ptr, ptr %g, align 8
  %LogEnabled = getelementptr inbounds %struct.ImGuiContext, ptr %72, i32 0, i32 222
  %73 = load i8, ptr %LogEnabled, align 8
  %tobool49 = trunc i8 %73 to i1
  br i1 %tobool49, label %land.lhs.true, label %if.end55

land.lhs.true:                                    ; preds = %if.end48
  %74 = load ptr, ptr %column, align 8
  %IsSkipItems50 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %74, i32 0, i32 32
  %75 = load i8, ptr %IsSkipItems50, align 4
  %tobool51 = trunc i8 %75 to i1
  br i1 %tobool51, label %if.end55, label %if.then52

if.then52:                                        ; preds = %land.lhs.true
  %76 = load ptr, ptr %window, align 8
  %DC53 = getelementptr inbounds %struct.ImGuiWindow, ptr %76, i32 0, i32 68
  %CursorPos54 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC53, i32 0, i32 0
  call void @_ZN5ImGui15LogRenderedTextEPK6ImVec2PKcS4_(ptr noundef %CursorPos54, ptr noundef @.str.2, ptr noundef null)
  %77 = load ptr, ptr %g, align 8
  %LogLinePosY = getelementptr inbounds %struct.ImGuiContext, ptr %77, i32 0, i32 228
  store float 0x47EFFFFFE0000000, ptr %LogLinePosY, align 8
  br label %if.end55

if.end55:                                         ; preds = %if.then52, %land.lhs.true, %if.end48
  ret void
}

; Function Attrs: mustprogress uwtable
define noundef zeroext i1 @_ZN5ImGui15TableNextColumnEv() #0 {
entry:
  %retval = alloca i1, align 1
  %g = alloca ptr, align 8
  %table = alloca ptr, align 8
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %g, align 8
  %CurrentTable = getelementptr inbounds %struct.ImGuiContext, ptr %1, i32 0, i32 164
  %2 = load ptr, ptr %CurrentTable, align 8
  store ptr %2, ptr %table, align 8
  %3 = load ptr, ptr %table, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %table, align 8
  %IsInsideRow = getelementptr inbounds %struct.ImGuiTable, ptr %4, i32 0, i32 93
  %5 = load i8, ptr %IsInsideRow, align 1
  %tobool1 = trunc i8 %5 to i1
  br i1 %tobool1, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.end
  %6 = load ptr, ptr %table, align 8
  %CurrentColumn = getelementptr inbounds %struct.ImGuiTable, ptr %6, i32 0, i32 15
  %7 = load i32, ptr %CurrentColumn, align 4
  %add = add nsw i32 %7, 1
  %8 = load ptr, ptr %table, align 8
  %ColumnsCount = getelementptr inbounds %struct.ImGuiTable, ptr %8, i32 0, i32 13
  %9 = load i32, ptr %ColumnsCount, align 4
  %cmp = icmp slt i32 %add, %9
  br i1 %cmp, label %if.then2, label %if.else

if.then2:                                         ; preds = %land.lhs.true
  %10 = load ptr, ptr %table, align 8
  %CurrentColumn3 = getelementptr inbounds %struct.ImGuiTable, ptr %10, i32 0, i32 15
  %11 = load i32, ptr %CurrentColumn3, align 4
  %cmp4 = icmp ne i32 %11, -1
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.then2
  %12 = load ptr, ptr %table, align 8
  call void @_ZN5ImGui12TableEndCellEP10ImGuiTable(ptr noundef %12)
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %if.then2
  %13 = load ptr, ptr %table, align 8
  %14 = load ptr, ptr %table, align 8
  %CurrentColumn7 = getelementptr inbounds %struct.ImGuiTable, ptr %14, i32 0, i32 15
  %15 = load i32, ptr %CurrentColumn7, align 4
  %add8 = add nsw i32 %15, 1
  call void @_ZN5ImGui14TableBeginCellEP10ImGuiTablei(ptr noundef %13, i32 noundef %add8)
  br label %if.end9

if.else:                                          ; preds = %land.lhs.true, %if.end
  call void @_ZN5ImGui12TableNextRowEif(i32 noundef 0, float noundef 0.000000e+00)
  %16 = load ptr, ptr %table, align 8
  call void @_ZN5ImGui14TableBeginCellEP10ImGuiTablei(ptr noundef %16, i32 noundef 0)
  br label %if.end9

if.end9:                                          ; preds = %if.else, %if.end6
  %17 = load ptr, ptr %table, align 8
  %Columns = getelementptr inbounds %struct.ImGuiTable, ptr %17, i32 0, i32 4
  %18 = load ptr, ptr %table, align 8
  %CurrentColumn10 = getelementptr inbounds %struct.ImGuiTable, ptr %18, i32 0, i32 15
  %19 = load i32, ptr %CurrentColumn10, align 4
  %call = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns, i32 noundef %19)
  %IsRequestOutput = getelementptr inbounds %struct.ImGuiTableColumn, ptr %call, i32 0, i32 31
  %20 = load i8, ptr %IsRequestOutput, align 1
  %tobool11 = trunc i8 %20 to i1
  store i1 %tobool11, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end9, %if.then
  %21 = load i1, ptr %retval, align 1
  ret i1 %21
}

declare void @_ZN5ImGui51ErrorCheckUsingSetCursorPosToExtendParentBoundariesEv() #1

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui33TableUpdateColumnsWeightFromWidthEP10ImGuiTable(ptr noundef %table) #0 {
entry:
  %table.addr = alloca ptr, align 8
  %visible_weight = alloca float, align 4
  %visible_width = alloca float, align 4
  %column_n = alloca i32, align 4
  %column = alloca ptr, align 8
  %column_n3 = alloca i32, align 4
  %column8 = alloca ptr, align 8
  store ptr %table, ptr %table.addr, align 8
  store float 0.000000e+00, ptr %visible_weight, align 4
  store float 0.000000e+00, ptr %visible_width, align 4
  store i32 0, ptr %column_n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %column_n, align 4
  %1 = load ptr, ptr %table.addr, align 8
  %ColumnsCount = getelementptr inbounds %struct.ImGuiTable, ptr %1, i32 0, i32 13
  %2 = load i32, ptr %ColumnsCount, align 4
  %cmp = icmp slt i32 %0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %table.addr, align 8
  %Columns = getelementptr inbounds %struct.ImGuiTable, ptr %3, i32 0, i32 4
  %4 = load i32, ptr %column_n, align 4
  %call = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns, i32 noundef %4)
  store ptr %call, ptr %column, align 8
  %5 = load ptr, ptr %column, align 8
  %IsEnabled = getelementptr inbounds %struct.ImGuiTableColumn, ptr %5, i32 0, i32 26
  %6 = load i8, ptr %IsEnabled, align 2
  %tobool = trunc i8 %6 to i1
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %for.body
  %7 = load ptr, ptr %column, align 8
  %Flags = getelementptr inbounds %struct.ImGuiTableColumn, ptr %7, i32 0, i32 0
  %8 = load i32, ptr %Flags, align 4
  %and = and i32 %8, 8
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %for.body
  br label %for.inc

if.end:                                           ; preds = %lor.lhs.false
  %9 = load ptr, ptr %column, align 8
  %StretchWeight = getelementptr inbounds %struct.ImGuiTableColumn, ptr %9, i32 0, i32 6
  %10 = load float, ptr %StretchWeight, align 4
  %11 = load float, ptr %visible_weight, align 4
  %add = fadd float %11, %10
  store float %add, ptr %visible_weight, align 4
  %12 = load ptr, ptr %column, align 8
  %WidthRequest = getelementptr inbounds %struct.ImGuiTableColumn, ptr %12, i32 0, i32 4
  %13 = load float, ptr %WidthRequest, align 4
  %14 = load float, ptr %visible_width, align 4
  %add2 = fadd float %14, %13
  store float %add2, ptr %visible_width, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %15 = load i32, ptr %column_n, align 4
  %inc = add nsw i32 %15, 1
  store i32 %inc, ptr %column_n, align 4
  br label %for.cond, !llvm.loop !39

for.end:                                          ; preds = %for.cond
  store i32 0, ptr %column_n3, align 4
  br label %for.cond4

for.cond4:                                        ; preds = %for.inc21, %for.end
  %16 = load i32, ptr %column_n3, align 4
  %17 = load ptr, ptr %table.addr, align 8
  %ColumnsCount5 = getelementptr inbounds %struct.ImGuiTable, ptr %17, i32 0, i32 13
  %18 = load i32, ptr %ColumnsCount5, align 4
  %cmp6 = icmp slt i32 %16, %18
  br i1 %cmp6, label %for.body7, label %for.end23

for.body7:                                        ; preds = %for.cond4
  %19 = load ptr, ptr %table.addr, align 8
  %Columns9 = getelementptr inbounds %struct.ImGuiTable, ptr %19, i32 0, i32 4
  %20 = load i32, ptr %column_n3, align 4
  %call10 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns9, i32 noundef %20)
  store ptr %call10, ptr %column8, align 8
  %21 = load ptr, ptr %column8, align 8
  %IsEnabled11 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %21, i32 0, i32 26
  %22 = load i8, ptr %IsEnabled11, align 2
  %tobool12 = trunc i8 %22 to i1
  br i1 %tobool12, label %lor.lhs.false13, label %if.then17

lor.lhs.false13:                                  ; preds = %for.body7
  %23 = load ptr, ptr %column8, align 8
  %Flags14 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %23, i32 0, i32 0
  %24 = load i32, ptr %Flags14, align 4
  %and15 = and i32 %24, 8
  %tobool16 = icmp ne i32 %and15, 0
  br i1 %tobool16, label %if.end18, label %if.then17

if.then17:                                        ; preds = %lor.lhs.false13, %for.body7
  br label %for.inc21

if.end18:                                         ; preds = %lor.lhs.false13
  %25 = load ptr, ptr %column8, align 8
  %WidthRequest19 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %25, i32 0, i32 4
  %26 = load float, ptr %WidthRequest19, align 4
  %27 = load float, ptr %visible_width, align 4
  %div = fdiv float %26, %27
  %28 = load float, ptr %visible_weight, align 4
  %mul = fmul float %div, %28
  %29 = load ptr, ptr %column8, align 8
  %StretchWeight20 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %29, i32 0, i32 6
  store float %mul, ptr %StretchWeight20, align 4
  br label %for.inc21

for.inc21:                                        ; preds = %if.end18, %if.then17
  %30 = load i32, ptr %column_n3, align 4
  %inc22 = add nsw i32 %30, 1
  store i32 %inc22, ptr %column_n3, align 4
  br label %for.cond4, !llvm.loop !40

for.end23:                                        ; preds = %for.cond4
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui26TableSetColumnWidthAutoAllEP10ImGuiTable(ptr noundef %table) #0 {
entry:
  %table.addr = alloca ptr, align 8
  %column_n = alloca i32, align 4
  %column = alloca ptr, align 8
  store ptr %table, ptr %table.addr, align 8
  store i32 0, ptr %column_n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %column_n, align 4
  %1 = load ptr, ptr %table.addr, align 8
  %ColumnsCount = getelementptr inbounds %struct.ImGuiTable, ptr %1, i32 0, i32 13
  %2 = load i32, ptr %ColumnsCount, align 4
  %cmp = icmp slt i32 %0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %table.addr, align 8
  %Columns = getelementptr inbounds %struct.ImGuiTable, ptr %3, i32 0, i32 4
  %4 = load i32, ptr %column_n, align 4
  %call = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns, i32 noundef %4)
  store ptr %call, ptr %column, align 8
  %5 = load ptr, ptr %column, align 8
  %IsEnabled = getelementptr inbounds %struct.ImGuiTableColumn, ptr %5, i32 0, i32 26
  %6 = load i8, ptr %IsEnabled, align 2
  %tobool = trunc i8 %6 to i1
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %7 = load ptr, ptr %column, align 8
  %Flags = getelementptr inbounds %struct.ImGuiTableColumn, ptr %7, i32 0, i32 0
  %8 = load i32, ptr %Flags, align 4
  %and = and i32 %8, 8
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %9 = load ptr, ptr %column, align 8
  %CannotSkipItemsQueue = getelementptr inbounds %struct.ImGuiTableColumn, ptr %9, i32 0, i32 36
  store i8 1, ptr %CannotSkipItemsQueue, align 4
  %10 = load ptr, ptr %column, align 8
  %AutoFitQueue = getelementptr inbounds %struct.ImGuiTableColumn, ptr %10, i32 0, i32 35
  store i8 2, ptr %AutoFitQueue, align 1
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %11 = load i32, ptr %column_n, align 4
  %inc = add nsw i32 %11, 1
  store i32 %inc, ptr %column_n, align 4
  br label %for.cond, !llvm.loop !41

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui26TablePushBackgroundChannelEv() #0 {
entry:
  %g = alloca ptr, align 8
  %window = alloca ptr, align 8
  %table = alloca ptr, align 8
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %g, align 8
  %CurrentWindow = getelementptr inbounds %struct.ImGuiContext, ptr %1, i32 0, i32 29
  %2 = load ptr, ptr %CurrentWindow, align 8
  store ptr %2, ptr %window, align 8
  %3 = load ptr, ptr %g, align 8
  %CurrentTable = getelementptr inbounds %struct.ImGuiContext, ptr %3, i32 0, i32 164
  %4 = load ptr, ptr %CurrentTable, align 8
  store ptr %4, ptr %table, align 8
  %5 = load ptr, ptr %window, align 8
  %ClipRect = getelementptr inbounds %struct.ImGuiWindow, ptr %5, i32 0, i32 74
  %6 = load ptr, ptr %table, align 8
  %HostBackupInnerClipRect = getelementptr inbounds %struct.ImGuiTable, ptr %6, i32 0, i32 54
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %HostBackupInnerClipRect, ptr align 8 %ClipRect, i64 16, i1 false)
  %7 = load ptr, ptr %window, align 8
  %8 = load ptr, ptr %table, align 8
  %Bg2ClipRectForDrawCmd = getelementptr inbounds %struct.ImGuiTable, ptr %8, i32 0, i32 52
  call void @_ZN5ImGui33SetWindowClipRectBeforeSetChannelEP11ImGuiWindowRK6ImRect(ptr noundef %7, ptr noundef nonnull align 4 dereferenceable(16) %Bg2ClipRectForDrawCmd)
  %9 = load ptr, ptr %table, align 8
  %DrawSplitter = getelementptr inbounds %struct.ImGuiTable, ptr %9, i32 0, i32 58
  %10 = load ptr, ptr %DrawSplitter, align 8
  %11 = load ptr, ptr %window, align 8
  %DrawList = getelementptr inbounds %struct.ImGuiWindow, ptr %11, i32 0, i32 86
  %12 = load ptr, ptr %DrawList, align 8
  %13 = load ptr, ptr %table, align 8
  %Bg2DrawChannelCurrent = getelementptr inbounds %struct.ImGuiTable, ptr %13, i32 0, i32 90
  %14 = load i16, ptr %Bg2DrawChannelCurrent, align 2
  %conv = zext i16 %14 to i32
  call void @_ZN18ImDrawListSplitter17SetCurrentChannelEP10ImDrawListi(ptr noundef nonnull align 8 dereferenceable(24) %10, ptr noundef %12, i32 noundef %conv)
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui25TablePopBackgroundChannelEv() #0 {
entry:
  %g = alloca ptr, align 8
  %window = alloca ptr, align 8
  %table = alloca ptr, align 8
  %column = alloca ptr, align 8
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %g, align 8
  %CurrentWindow = getelementptr inbounds %struct.ImGuiContext, ptr %1, i32 0, i32 29
  %2 = load ptr, ptr %CurrentWindow, align 8
  store ptr %2, ptr %window, align 8
  %3 = load ptr, ptr %g, align 8
  %CurrentTable = getelementptr inbounds %struct.ImGuiContext, ptr %3, i32 0, i32 164
  %4 = load ptr, ptr %CurrentTable, align 8
  store ptr %4, ptr %table, align 8
  %5 = load ptr, ptr %table, align 8
  %Columns = getelementptr inbounds %struct.ImGuiTable, ptr %5, i32 0, i32 4
  %6 = load ptr, ptr %table, align 8
  %CurrentColumn = getelementptr inbounds %struct.ImGuiTable, ptr %6, i32 0, i32 15
  %7 = load i32, ptr %CurrentColumn, align 4
  %call = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns, i32 noundef %7)
  store ptr %call, ptr %column, align 8
  %8 = load ptr, ptr %window, align 8
  %9 = load ptr, ptr %table, align 8
  %HostBackupInnerClipRect = getelementptr inbounds %struct.ImGuiTable, ptr %9, i32 0, i32 54
  call void @_ZN5ImGui33SetWindowClipRectBeforeSetChannelEP11ImGuiWindowRK6ImRect(ptr noundef %8, ptr noundef nonnull align 4 dereferenceable(16) %HostBackupInnerClipRect)
  %10 = load ptr, ptr %table, align 8
  %DrawSplitter = getelementptr inbounds %struct.ImGuiTable, ptr %10, i32 0, i32 58
  %11 = load ptr, ptr %DrawSplitter, align 8
  %12 = load ptr, ptr %window, align 8
  %DrawList = getelementptr inbounds %struct.ImGuiWindow, ptr %12, i32 0, i32 86
  %13 = load ptr, ptr %DrawList, align 8
  %14 = load ptr, ptr %column, align 8
  %DrawChannelCurrent = getelementptr inbounds %struct.ImGuiTableColumn, ptr %14, i32 0, i32 23
  %15 = load i16, ptr %DrawChannelCurrent, align 4
  %conv = zext i16 %15 to i32
  call void @_ZN18ImDrawListSplitter17SetCurrentChannelEP10ImDrawListi(ptr noundef nonnull align 8 dereferenceable(24) %11, ptr noundef %13, i32 noundef %conv)
  ret void
}

; Function Attrs: nounwind willreturn memory(read)
declare i32 @memcmp(ptr noundef, ptr noundef, i64 noundef) #7

declare void @_ZN18ImDrawListSplitter5SplitEP10ImDrawListi(ptr noundef nonnull align 8 dereferenceable(24), ptr noundef, i32 noundef) #1

; Function Attrs: mustprogress uwtable
define internal void @_ZZN5ImGui22TableMergeDrawChannelsEP10ImGuiTableEN10MergeGroupC2Ev(ptr noundef nonnull align 8 dereferenceable(32) %this) unnamed_addr #0 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %ClipRect = getelementptr inbounds %struct.MergeGroup, ptr %this1, i32 0, i32 0
  call void @_ZN6ImRectC2Ev(ptr noundef nonnull align 4 dereferenceable(16) %ClipRect)
  %ChannelsCount = getelementptr inbounds %struct.MergeGroup, ptr %this1, i32 0, i32 1
  store i32 0, ptr %ChannelsCount, align 8
  %ChannelsMask = getelementptr inbounds %struct.MergeGroup, ptr %this1, i32 0, i32 2
  store ptr null, ptr %ChannelsMask, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorIcE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_capacity) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_capacity.addr = alloca i32, align 4
  %new_data = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_capacity, ptr %new_capacity.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_capacity.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.25, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sle i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %new_capacity.addr, align 4
  %conv = sext i32 %2 to i64
  %mul = mul i64 %conv, 1
  %call = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef %mul)
  store ptr %call, ptr %new_data, align 8
  %Data = getelementptr inbounds %struct.ImVector.25, ptr %this1, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.then2, label %if.end7

if.then2:                                         ; preds = %if.end
  %4 = load ptr, ptr %new_data, align 8
  %Data3 = getelementptr inbounds %struct.ImVector.25, ptr %this1, i32 0, i32 2
  %5 = load ptr, ptr %Data3, align 8
  %Size = getelementptr inbounds %struct.ImVector.25, ptr %this1, i32 0, i32 0
  %6 = load i32, ptr %Size, align 8
  %conv4 = sext i32 %6 to i64
  %mul5 = mul i64 %conv4, 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %4, ptr align 1 %5, i64 %mul5, i1 false)
  %Data6 = getelementptr inbounds %struct.ImVector.25, ptr %this1, i32 0, i32 2
  %7 = load ptr, ptr %Data6, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %7)
  br label %if.end7

if.end7:                                          ; preds = %if.then2, %if.end
  %8 = load ptr, ptr %new_data, align 8
  %Data8 = getelementptr inbounds %struct.ImVector.25, ptr %this1, i32 0, i32 2
  store ptr %8, ptr %Data8, align 8
  %9 = load i32, ptr %new_capacity.addr, align 4
  %Capacity9 = getelementptr inbounds %struct.ImVector.25, ptr %this1, i32 0, i32 1
  store i32 %9, ptr %Capacity9, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef nonnull align 8 dereferenceable(32) ptr @_ZN8ImVectorI13ImDrawChannelEixEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %i) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.20, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.ImDrawChannel, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef nonnull align 8 dereferenceable(56) ptr @_ZN8ImVectorI9ImDrawCmdE4backEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.32, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %Size = getelementptr inbounds %struct.ImVector.32, ptr %this1, i32 0, i32 0
  %1 = load i32, ptr %Size, align 8
  %sub = sub nsw i32 %1, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.ImDrawCmd, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorI9ImDrawCmdE8pop_backEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Size = getelementptr inbounds %struct.ImVector.32, ptr %this1, i32 0, i32 0
  %0 = load i32, ptr %Size, align 8
  %dec = add nsw i32 %0, -1
  store i32 %dec, ptr %Size, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN6ImRect3AddERKS_(ptr noundef nonnull align 4 dereferenceable(16) %this, ptr noundef nonnull align 4 dereferenceable(16) %r) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %r.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %r, ptr %r.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Min = getelementptr inbounds %struct.ImRect, ptr %this1, i32 0, i32 0
  %x = getelementptr inbounds %struct.ImVec2, ptr %Min, i32 0, i32 0
  %0 = load float, ptr %x, align 4
  %1 = load ptr, ptr %r.addr, align 8
  %Min2 = getelementptr inbounds %struct.ImRect, ptr %1, i32 0, i32 0
  %x3 = getelementptr inbounds %struct.ImVec2, ptr %Min2, i32 0, i32 0
  %2 = load float, ptr %x3, align 4
  %cmp = fcmp ogt float %0, %2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %r.addr, align 8
  %Min4 = getelementptr inbounds %struct.ImRect, ptr %3, i32 0, i32 0
  %x5 = getelementptr inbounds %struct.ImVec2, ptr %Min4, i32 0, i32 0
  %4 = load float, ptr %x5, align 4
  %Min6 = getelementptr inbounds %struct.ImRect, ptr %this1, i32 0, i32 0
  %x7 = getelementptr inbounds %struct.ImVec2, ptr %Min6, i32 0, i32 0
  store float %4, ptr %x7, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %Min8 = getelementptr inbounds %struct.ImRect, ptr %this1, i32 0, i32 0
  %y = getelementptr inbounds %struct.ImVec2, ptr %Min8, i32 0, i32 1
  %5 = load float, ptr %y, align 4
  %6 = load ptr, ptr %r.addr, align 8
  %Min9 = getelementptr inbounds %struct.ImRect, ptr %6, i32 0, i32 0
  %y10 = getelementptr inbounds %struct.ImVec2, ptr %Min9, i32 0, i32 1
  %7 = load float, ptr %y10, align 4
  %cmp11 = fcmp ogt float %5, %7
  br i1 %cmp11, label %if.then12, label %if.end17

if.then12:                                        ; preds = %if.end
  %8 = load ptr, ptr %r.addr, align 8
  %Min13 = getelementptr inbounds %struct.ImRect, ptr %8, i32 0, i32 0
  %y14 = getelementptr inbounds %struct.ImVec2, ptr %Min13, i32 0, i32 1
  %9 = load float, ptr %y14, align 4
  %Min15 = getelementptr inbounds %struct.ImRect, ptr %this1, i32 0, i32 0
  %y16 = getelementptr inbounds %struct.ImVec2, ptr %Min15, i32 0, i32 1
  store float %9, ptr %y16, align 4
  br label %if.end17

if.end17:                                         ; preds = %if.then12, %if.end
  %Max = getelementptr inbounds %struct.ImRect, ptr %this1, i32 0, i32 1
  %x18 = getelementptr inbounds %struct.ImVec2, ptr %Max, i32 0, i32 0
  %10 = load float, ptr %x18, align 4
  %11 = load ptr, ptr %r.addr, align 8
  %Max19 = getelementptr inbounds %struct.ImRect, ptr %11, i32 0, i32 1
  %x20 = getelementptr inbounds %struct.ImVec2, ptr %Max19, i32 0, i32 0
  %12 = load float, ptr %x20, align 4
  %cmp21 = fcmp olt float %10, %12
  br i1 %cmp21, label %if.then22, label %if.end27

if.then22:                                        ; preds = %if.end17
  %13 = load ptr, ptr %r.addr, align 8
  %Max23 = getelementptr inbounds %struct.ImRect, ptr %13, i32 0, i32 1
  %x24 = getelementptr inbounds %struct.ImVec2, ptr %Max23, i32 0, i32 0
  %14 = load float, ptr %x24, align 4
  %Max25 = getelementptr inbounds %struct.ImRect, ptr %this1, i32 0, i32 1
  %x26 = getelementptr inbounds %struct.ImVec2, ptr %Max25, i32 0, i32 0
  store float %14, ptr %x26, align 4
  br label %if.end27

if.end27:                                         ; preds = %if.then22, %if.end17
  %Max28 = getelementptr inbounds %struct.ImRect, ptr %this1, i32 0, i32 1
  %y29 = getelementptr inbounds %struct.ImVec2, ptr %Max28, i32 0, i32 1
  %15 = load float, ptr %y29, align 4
  %16 = load ptr, ptr %r.addr, align 8
  %Max30 = getelementptr inbounds %struct.ImRect, ptr %16, i32 0, i32 1
  %y31 = getelementptr inbounds %struct.ImVec2, ptr %Max30, i32 0, i32 1
  %17 = load float, ptr %y31, align 4
  %cmp32 = fcmp olt float %15, %17
  br i1 %cmp32, label %if.then33, label %if.end38

if.then33:                                        ; preds = %if.end27
  %18 = load ptr, ptr %r.addr, align 8
  %Max34 = getelementptr inbounds %struct.ImRect, ptr %18, i32 0, i32 1
  %y35 = getelementptr inbounds %struct.ImVec2, ptr %Max34, i32 0, i32 1
  %19 = load float, ptr %y35, align 4
  %Max36 = getelementptr inbounds %struct.ImRect, ptr %this1, i32 0, i32 1
  %y37 = getelementptr inbounds %struct.ImVec2, ptr %Max36, i32 0, i32 1
  store float %19, ptr %y37, align 4
  br label %if.end38

if.end38:                                         ; preds = %if.then33, %if.end27
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef nonnull align 8 dereferenceable(56) ptr @_ZN8ImVectorI9ImDrawCmdEixEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %i) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.32, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.ImDrawCmd, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI13ImDrawChannelE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_size) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_size.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_size, ptr %new_size.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_size.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.20, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sgt i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %new_size.addr, align 4
  %call = call noundef i32 @_ZNK8ImVectorI13ImDrawChannelE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %2)
  call void @_ZN8ImVectorI13ImDrawChannelE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %call)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32, ptr %new_size.addr, align 4
  %Size = getelementptr inbounds %struct.ImVector.20, ptr %this1, i32 0, i32 0
  store i32 %3, ptr %Size, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_Z21ImBitArraySetBitRangePjii(ptr noundef %arr, i32 noundef %n, i32 noundef %n2) #3 comdat {
entry:
  %arr.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  %n2.addr = alloca i32, align 4
  %a_mod = alloca i32, align 4
  %b_mod = alloca i32, align 4
  %mask = alloca i32, align 4
  store ptr %arr, ptr %arr.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  store i32 %n2, ptr %n2.addr, align 4
  %0 = load i32, ptr %n2.addr, align 4
  %dec = add nsw i32 %0, -1
  store i32 %dec, ptr %n2.addr, align 4
  br label %while.cond

while.cond:                                       ; preds = %cond.end, %entry
  %1 = load i32, ptr %n.addr, align 4
  %2 = load i32, ptr %n2.addr, align 4
  %cmp = icmp sle i32 %1, %2
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load i32, ptr %n.addr, align 4
  %and = and i32 %3, 31
  store i32 %and, ptr %a_mod, align 4
  %4 = load i32, ptr %n2.addr, align 4
  %5 = load i32, ptr %n.addr, align 4
  %or = or i32 %5, 31
  %cmp1 = icmp sgt i32 %4, %or
  br i1 %cmp1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %while.body
  br label %cond.end

cond.false:                                       ; preds = %while.body
  %6 = load i32, ptr %n2.addr, align 4
  %and2 = and i32 %6, 31
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 31, %cond.true ], [ %and2, %cond.false ]
  %add = add nsw i32 %cond, 1
  store i32 %add, ptr %b_mod, align 4
  %7 = load i32, ptr %b_mod, align 4
  %sh_prom = zext i32 %7 to i64
  %shl = shl i64 1, %sh_prom
  %sub = sub i64 %shl, 1
  %conv = trunc i64 %sub to i32
  %8 = load i32, ptr %a_mod, align 4
  %sh_prom3 = zext i32 %8 to i64
  %shl4 = shl i64 1, %sh_prom3
  %sub5 = sub i64 %shl4, 1
  %conv6 = trunc i64 %sub5 to i32
  %not = xor i32 %conv6, -1
  %and7 = and i32 %conv, %not
  store i32 %and7, ptr %mask, align 4
  %9 = load i32, ptr %mask, align 4
  %10 = load ptr, ptr %arr.addr, align 8
  %11 = load i32, ptr %n.addr, align 4
  %shr = ashr i32 %11, 5
  %idxprom = sext i32 %shr to i64
  %arrayidx = getelementptr inbounds i32, ptr %10, i64 %idxprom
  %12 = load i32, ptr %arrayidx, align 4
  %or8 = or i32 %12, %9
  store i32 %or8, ptr %arrayidx, align 4
  %13 = load i32, ptr %n.addr, align 4
  %add9 = add nsw i32 %13, 32
  %and10 = and i32 %add9, -32
  store i32 %and10, ptr %n.addr, align 4
  br label %while.cond, !llvm.loop !42

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_Z18ImBitArrayClearBitPji(ptr noundef %arr, i32 noundef %n) #3 comdat {
entry:
  %arr.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  %mask = alloca i32, align 4
  store ptr %arr, ptr %arr.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %0 = load i32, ptr %n.addr, align 4
  %and = and i32 %0, 31
  %shl = shl i32 1, %and
  store i32 %shl, ptr %mask, align 4
  %1 = load i32, ptr %mask, align 4
  %not = xor i32 %1, -1
  %2 = load ptr, ptr %arr.addr, align 8
  %3 = load i32, ptr %n.addr, align 4
  %shr = ashr i32 %3, 5
  %idxprom = sext i32 %shr to i64
  %arrayidx = getelementptr inbounds i32, ptr %2, i64 %idxprom
  %4 = load i32, ptr %arrayidx, align 4
  %and1 = and i32 %4, %not
  store i32 %and1, ptr %arrayidx, align 4
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef zeroext i1 @_ZNK6ImRect8OverlapsERKS_(ptr noundef nonnull align 4 dereferenceable(16) %this, ptr noundef nonnull align 4 dereferenceable(16) %r) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %r.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %r, ptr %r.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %r.addr, align 8
  %Min = getelementptr inbounds %struct.ImRect, ptr %0, i32 0, i32 0
  %y = getelementptr inbounds %struct.ImVec2, ptr %Min, i32 0, i32 1
  %1 = load float, ptr %y, align 4
  %Max = getelementptr inbounds %struct.ImRect, ptr %this1, i32 0, i32 1
  %y2 = getelementptr inbounds %struct.ImVec2, ptr %Max, i32 0, i32 1
  %2 = load float, ptr %y2, align 4
  %cmp = fcmp olt float %1, %2
  br i1 %cmp, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %3 = load ptr, ptr %r.addr, align 8
  %Max3 = getelementptr inbounds %struct.ImRect, ptr %3, i32 0, i32 1
  %y4 = getelementptr inbounds %struct.ImVec2, ptr %Max3, i32 0, i32 1
  %4 = load float, ptr %y4, align 4
  %Min5 = getelementptr inbounds %struct.ImRect, ptr %this1, i32 0, i32 0
  %y6 = getelementptr inbounds %struct.ImVec2, ptr %Min5, i32 0, i32 1
  %5 = load float, ptr %y6, align 4
  %cmp7 = fcmp ogt float %4, %5
  br i1 %cmp7, label %land.lhs.true8, label %land.end

land.lhs.true8:                                   ; preds = %land.lhs.true
  %6 = load ptr, ptr %r.addr, align 8
  %Min9 = getelementptr inbounds %struct.ImRect, ptr %6, i32 0, i32 0
  %x = getelementptr inbounds %struct.ImVec2, ptr %Min9, i32 0, i32 0
  %7 = load float, ptr %x, align 4
  %Max10 = getelementptr inbounds %struct.ImRect, ptr %this1, i32 0, i32 1
  %x11 = getelementptr inbounds %struct.ImVec2, ptr %Max10, i32 0, i32 0
  %8 = load float, ptr %x11, align 4
  %cmp12 = fcmp olt float %7, %8
  br i1 %cmp12, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true8
  %9 = load ptr, ptr %r.addr, align 8
  %Max13 = getelementptr inbounds %struct.ImRect, ptr %9, i32 0, i32 1
  %x14 = getelementptr inbounds %struct.ImVec2, ptr %Max13, i32 0, i32 0
  %10 = load float, ptr %x14, align 4
  %Min15 = getelementptr inbounds %struct.ImRect, ptr %this1, i32 0, i32 0
  %x16 = getelementptr inbounds %struct.ImVec2, ptr %Min15, i32 0, i32 0
  %11 = load float, ptr %x16, align 4
  %cmp17 = fcmp ogt float %10, %11
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true8, %land.lhs.true, %entry
  %12 = phi i1 [ false, %land.lhs.true8 ], [ false, %land.lhs.true ], [ false, %entry ], [ %cmp17, %land.rhs ]
  ret i1 %12
}

; Function Attrs: mustprogress uwtable
define internal noundef i32 @_ZL23TableGetColumnBorderColP10ImGuiTableii(ptr noundef %table, i32 noundef %order_n, i32 noundef %column_n) #0 {
entry:
  %retval = alloca i32, align 4
  %table.addr = alloca ptr, align 8
  %order_n.addr = alloca i32, align 4
  %column_n.addr = alloca i32, align 4
  %is_hovered = alloca i8, align 1
  %is_resized = alloca i8, align 1
  %is_frozen_separator = alloca i8, align 1
  store ptr %table, ptr %table.addr, align 8
  store i32 %order_n, ptr %order_n.addr, align 4
  store i32 %column_n, ptr %column_n.addr, align 4
  %0 = load ptr, ptr %table.addr, align 8
  %HoveredColumnBorder = getelementptr inbounds %struct.ImGuiTable, ptr %0, i32 0, i32 71
  %1 = load i16, ptr %HoveredColumnBorder, align 4
  %conv = sext i16 %1 to i32
  %2 = load i32, ptr %column_n.addr, align 4
  %cmp = icmp eq i32 %conv, %2
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, ptr %is_hovered, align 1
  %3 = load ptr, ptr %table.addr, align 8
  %ResizedColumn = getelementptr inbounds %struct.ImGuiTable, ptr %3, i32 0, i32 74
  %4 = load i16, ptr %ResizedColumn, align 2
  %conv1 = sext i16 %4 to i32
  %5 = load i32, ptr %column_n.addr, align 4
  %cmp2 = icmp eq i32 %conv1, %5
  br i1 %cmp2, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %6 = load ptr, ptr %table.addr, align 8
  %InstanceInteracted = getelementptr inbounds %struct.ImGuiTable, ptr %6, i32 0, i32 17
  %7 = load i16, ptr %InstanceInteracted, align 2
  %conv3 = sext i16 %7 to i32
  %8 = load ptr, ptr %table.addr, align 8
  %InstanceCurrent = getelementptr inbounds %struct.ImGuiTable, ptr %8, i32 0, i32 16
  %9 = load i16, ptr %InstanceCurrent, align 8
  %conv4 = sext i16 %9 to i32
  %cmp5 = icmp eq i32 %conv3, %conv4
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %10 = phi i1 [ false, %entry ], [ %cmp5, %land.rhs ]
  %frombool6 = zext i1 %10 to i8
  store i8 %frombool6, ptr %is_resized, align 1
  %11 = load ptr, ptr %table.addr, align 8
  %FreezeColumnsCount = getelementptr inbounds %struct.ImGuiTable, ptr %11, i32 0, i32 87
  %12 = load i16, ptr %FreezeColumnsCount, align 4
  %conv7 = sext i16 %12 to i32
  %13 = load i32, ptr %order_n.addr, align 4
  %add = add nsw i32 %13, 1
  %cmp8 = icmp eq i32 %conv7, %add
  %frombool9 = zext i1 %cmp8 to i8
  store i8 %frombool9, ptr %is_frozen_separator, align 1
  %14 = load i8, ptr %is_resized, align 1
  %tobool = trunc i8 %14 to i1
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.end
  %15 = load i8, ptr %is_hovered, align 1
  %tobool10 = trunc i8 %15 to i1
  br i1 %tobool10, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %land.end
  %16 = load i8, ptr %is_resized, align 1
  %tobool11 = trunc i8 %16 to i1
  %cond = select i1 %tobool11, i32 29, i32 28
  %call = call noundef i32 @_ZN5ImGui11GetColorU32Eif(i32 noundef %cond, float noundef 1.000000e+00)
  store i32 %call, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %17 = load i8, ptr %is_frozen_separator, align 1
  %tobool12 = trunc i8 %17 to i1
  br i1 %tobool12, label %if.then15, label %lor.lhs.false13

lor.lhs.false13:                                  ; preds = %if.end
  %18 = load ptr, ptr %table.addr, align 8
  %Flags = getelementptr inbounds %struct.ImGuiTable, ptr %18, i32 0, i32 1
  %19 = load i32, ptr %Flags, align 4
  %and = and i32 %19, 6144
  %tobool14 = icmp ne i32 %and, 0
  br i1 %tobool14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %lor.lhs.false13, %if.end
  %20 = load ptr, ptr %table.addr, align 8
  %BorderColorStrong = getelementptr inbounds %struct.ImGuiTable, ptr %20, i32 0, i32 27
  %21 = load i32, ptr %BorderColorStrong, align 4
  store i32 %21, ptr %retval, align 4
  br label %return

if.end16:                                         ; preds = %lor.lhs.false13
  %22 = load ptr, ptr %table.addr, align 8
  %BorderColorLight = getelementptr inbounds %struct.ImGuiTable, ptr %22, i32 0, i32 28
  %23 = load i32, ptr %BorderColorLight, align 8
  store i32 %23, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end16, %if.then15, %if.then
  %24 = load i32, ptr %retval, align 4
  ret i32 %24
}

declare void @_ZN10ImDrawList7AddRectERK6ImVec2S2_jfif(ptr noundef nonnull align 8 dereferenceable(196), ptr noundef nonnull align 4 dereferenceable(8), ptr noundef nonnull align 4 dereferenceable(8), i32 noundef, float noundef, i32 noundef, float noundef) #1

; Function Attrs: mustprogress uwtable
define noundef ptr @_ZN5ImGui17TableGetSortSpecsEv() #0 {
entry:
  %retval = alloca ptr, align 8
  %g = alloca ptr, align 8
  %table = alloca ptr, align 8
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %g, align 8
  %CurrentTable = getelementptr inbounds %struct.ImGuiContext, ptr %1, i32 0, i32 164
  %2 = load ptr, ptr %CurrentTable, align 8
  store ptr %2, ptr %table, align 8
  %3 = load ptr, ptr %table, align 8
  %Flags = getelementptr inbounds %struct.ImGuiTable, ptr %3, i32 0, i32 1
  %4 = load i32, ptr %Flags, align 4
  %and = and i32 %4, 8
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %5 = load ptr, ptr %table, align 8
  %IsLayoutLocked = getelementptr inbounds %struct.ImGuiTable, ptr %5, i32 0, i32 92
  %6 = load i8, ptr %IsLayoutLocked, align 2
  %tobool1 = trunc i8 %6 to i1
  br i1 %tobool1, label %if.end3, label %if.then2

if.then2:                                         ; preds = %if.end
  %7 = load ptr, ptr %table, align 8
  call void @_ZN5ImGui17TableUpdateLayoutEP10ImGuiTable(ptr noundef %7)
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end
  %8 = load ptr, ptr %table, align 8
  call void @_ZN5ImGui19TableSortSpecsBuildEP10ImGuiTable(ptr noundef %8)
  %9 = load ptr, ptr %table, align 8
  %SortSpecs = getelementptr inbounds %struct.ImGuiTable, ptr %9, i32 0, i32 64
  store ptr %SortSpecs, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end3, %if.then
  %10 = load ptr, ptr %retval, align 8
  ret ptr %10
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui27TableFixColumnSortDirectionEP10ImGuiTableP16ImGuiTableColumn(ptr noundef %table, ptr noundef %column) #0 {
entry:
  %table.addr = alloca ptr, align 8
  %column.addr = alloca ptr, align 8
  store ptr %table, ptr %table.addr, align 8
  store ptr %column, ptr %column.addr, align 8
  %0 = load ptr, ptr %column.addr, align 8
  %SortOrder = getelementptr inbounds %struct.ImGuiTableColumn, ptr %0, i32 0, i32 22
  %1 = load i16, ptr %SortOrder, align 2
  %conv = sext i16 %1 to i32
  %cmp = icmp eq i32 %conv, -1
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load ptr, ptr %column.addr, align 8
  %SortDirectionsAvailMask = getelementptr inbounds %struct.ImGuiTableColumn, ptr %2, i32 0, i32 37
  %bf.load = load i8, ptr %SortDirectionsAvailMask, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv1 = zext i8 %bf.lshr to i32
  %3 = load ptr, ptr %column.addr, align 8
  %SortDirection = getelementptr inbounds %struct.ImGuiTableColumn, ptr %3, i32 0, i32 37
  %bf.load2 = load i8, ptr %SortDirection, align 1
  %bf.clear = and i8 %bf.load2, 3
  %conv3 = zext i8 %bf.clear to i32
  %shl = shl i32 1, %conv3
  %and = and i32 %conv1, %shl
  %cmp4 = icmp ne i32 %and, 0
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %4 = load ptr, ptr %column.addr, align 8
  %call = call noundef i32 @_ZL32TableGetColumnAvailSortDirectionP16ImGuiTableColumni(ptr noundef %4, i32 noundef 0)
  %conv5 = trunc i32 %call to i8
  %5 = load ptr, ptr %column.addr, align 8
  %SortDirection6 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %5, i32 0, i32 37
  %bf.load7 = load i8, ptr %SortDirection6, align 1
  %bf.value = and i8 %conv5, 3
  %bf.clear8 = and i8 %bf.load7, -4
  %bf.set = or i8 %bf.clear8, %bf.value
  store i8 %bf.set, ptr %SortDirection6, align 1
  %6 = load ptr, ptr %table.addr, align 8
  %IsSortSpecsDirty = getelementptr inbounds %struct.ImGuiTable, ptr %6, i32 0, i32 95
  store i8 1, ptr %IsSortSpecsDirty, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef i32 @_ZL32TableGetColumnAvailSortDirectionP16ImGuiTableColumni(ptr noundef %column, i32 noundef %n) #3 {
entry:
  %column.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %column, ptr %column.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %0 = load ptr, ptr %column.addr, align 8
  %SortDirectionsAvailList = getelementptr inbounds %struct.ImGuiTableColumn, ptr %0, i32 0, i32 38
  %1 = load i8, ptr %SortDirectionsAvailList, align 2
  %conv = zext i8 %1 to i32
  %2 = load i32, ptr %n.addr, align 4
  %shl = shl i32 %2, 1
  %shr = ashr i32 %conv, %shl
  %and = and i32 %shr, 3
  ret i32 %and
}

; Function Attrs: mustprogress uwtable
define noundef i32 @_ZN5ImGui31TableGetColumnNextSortDirectionEP16ImGuiTableColumn(ptr noundef %column) #0 {
entry:
  %retval = alloca i32, align 4
  %column.addr = alloca ptr, align 8
  %n = alloca i32, align 4
  store ptr %column, ptr %column.addr, align 8
  %0 = load ptr, ptr %column.addr, align 8
  %SortOrder = getelementptr inbounds %struct.ImGuiTableColumn, ptr %0, i32 0, i32 22
  %1 = load i16, ptr %SortOrder, align 2
  %conv = sext i16 %1 to i32
  %cmp = icmp eq i32 %conv, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %column.addr, align 8
  %call = call noundef i32 @_ZL32TableGetColumnAvailSortDirectionP16ImGuiTableColumni(ptr noundef %2, i32 noundef 0)
  store i32 %call, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, ptr %n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %3 = load i32, ptr %n, align 4
  %cmp1 = icmp slt i32 %3, 3
  br i1 %cmp1, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load ptr, ptr %column.addr, align 8
  %SortDirection = getelementptr inbounds %struct.ImGuiTableColumn, ptr %4, i32 0, i32 37
  %bf.load = load i8, ptr %SortDirection, align 1
  %bf.clear = and i8 %bf.load, 3
  %conv2 = zext i8 %bf.clear to i32
  %5 = load ptr, ptr %column.addr, align 8
  %6 = load i32, ptr %n, align 4
  %call3 = call noundef i32 @_ZL32TableGetColumnAvailSortDirectionP16ImGuiTableColumni(ptr noundef %5, i32 noundef %6)
  %cmp4 = icmp eq i32 %conv2, %call3
  br i1 %cmp4, label %if.then5, label %if.end10

if.then5:                                         ; preds = %for.body
  %7 = load ptr, ptr %column.addr, align 8
  %8 = load i32, ptr %n, align 4
  %add = add nsw i32 %8, 1
  %9 = load ptr, ptr %column.addr, align 8
  %SortDirectionsAvailCount = getelementptr inbounds %struct.ImGuiTableColumn, ptr %9, i32 0, i32 37
  %bf.load6 = load i8, ptr %SortDirectionsAvailCount, align 1
  %bf.lshr = lshr i8 %bf.load6, 2
  %bf.clear7 = and i8 %bf.lshr, 3
  %conv8 = zext i8 %bf.clear7 to i32
  %rem = srem i32 %add, %conv8
  %call9 = call noundef i32 @_ZL32TableGetColumnAvailSortDirectionP16ImGuiTableColumni(ptr noundef %7, i32 noundef %rem)
  store i32 %call9, ptr %retval, align 4
  br label %return

if.end10:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end10
  %10 = load i32, ptr %n, align 4
  %inc = add nsw i32 %10, 1
  store i32 %inc, ptr %n, align 4
  br label %for.cond, !llvm.loop !43

for.end:                                          ; preds = %for.cond
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then5, %if.then
  %11 = load i32, ptr %retval, align 4
  ret i32 %11
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui27TableSetColumnSortDirectionEiib(i32 noundef %column_n, i32 noundef %sort_direction, i1 noundef zeroext %append_to_sort_specs) #0 {
entry:
  %column_n.addr = alloca i32, align 4
  %sort_direction.addr = alloca i32, align 4
  %append_to_sort_specs.addr = alloca i8, align 1
  %g = alloca ptr, align 8
  %table = alloca ptr, align 8
  %sort_order_max = alloca i16, align 2
  %other_column_n = alloca i32, align 4
  %column = alloca ptr, align 8
  %other_column_n30 = alloca i32, align 4
  %other_column = alloca ptr, align 8
  store i32 %column_n, ptr %column_n.addr, align 4
  store i32 %sort_direction, ptr %sort_direction.addr, align 4
  %frombool = zext i1 %append_to_sort_specs to i8
  store i8 %frombool, ptr %append_to_sort_specs.addr, align 1
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %g, align 8
  %CurrentTable = getelementptr inbounds %struct.ImGuiContext, ptr %1, i32 0, i32 164
  %2 = load ptr, ptr %CurrentTable, align 8
  store ptr %2, ptr %table, align 8
  %3 = load ptr, ptr %table, align 8
  %Flags = getelementptr inbounds %struct.ImGuiTable, ptr %3, i32 0, i32 1
  %4 = load i32, ptr %Flags, align 4
  %and = and i32 %4, 67108864
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i8 0, ptr %append_to_sort_specs.addr, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load ptr, ptr %table, align 8
  %Flags1 = getelementptr inbounds %struct.ImGuiTable, ptr %5, i32 0, i32 1
  %6 = load i32, ptr %Flags1, align 4
  %and2 = and i32 %6, 134217728
  %tobool3 = icmp ne i32 %and2, 0
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.end
  br label %if.end5

if.end5:                                          ; preds = %if.then4, %if.end
  store i16 0, ptr %sort_order_max, align 2
  %7 = load i8, ptr %append_to_sort_specs.addr, align 1
  %tobool6 = trunc i8 %7 to i1
  br i1 %tobool6, label %if.then7, label %if.end9

if.then7:                                         ; preds = %if.end5
  store i32 0, ptr %other_column_n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then7
  %8 = load i32, ptr %other_column_n, align 4
  %9 = load ptr, ptr %table, align 8
  %ColumnsCount = getelementptr inbounds %struct.ImGuiTable, ptr %9, i32 0, i32 13
  %10 = load i32, ptr %ColumnsCount, align 4
  %cmp = icmp slt i32 %8, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i16, ptr %sort_order_max, align 2
  %12 = load ptr, ptr %table, align 8
  %Columns = getelementptr inbounds %struct.ImGuiTable, ptr %12, i32 0, i32 4
  %13 = load i32, ptr %other_column_n, align 4
  %call = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns, i32 noundef %13)
  %SortOrder = getelementptr inbounds %struct.ImGuiTableColumn, ptr %call, i32 0, i32 22
  %14 = load i16, ptr %SortOrder, align 2
  %call8 = call noundef signext i16 @_ZL5ImMaxIsET_S0_S0_(i16 noundef signext %11, i16 noundef signext %14)
  store i16 %call8, ptr %sort_order_max, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %15 = load i32, ptr %other_column_n, align 4
  %inc = add nsw i32 %15, 1
  store i32 %inc, ptr %other_column_n, align 4
  br label %for.cond, !llvm.loop !44

for.end:                                          ; preds = %for.cond
  br label %if.end9

if.end9:                                          ; preds = %for.end, %if.end5
  %16 = load ptr, ptr %table, align 8
  %Columns10 = getelementptr inbounds %struct.ImGuiTable, ptr %16, i32 0, i32 4
  %17 = load i32, ptr %column_n.addr, align 4
  %call11 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns10, i32 noundef %17)
  store ptr %call11, ptr %column, align 8
  %18 = load i32, ptr %sort_direction.addr, align 4
  %conv = trunc i32 %18 to i8
  %19 = load ptr, ptr %column, align 8
  %SortDirection = getelementptr inbounds %struct.ImGuiTableColumn, ptr %19, i32 0, i32 37
  %bf.load = load i8, ptr %SortDirection, align 1
  %bf.value = and i8 %conv, 3
  %bf.clear = and i8 %bf.load, -4
  %bf.set = or i8 %bf.clear, %bf.value
  store i8 %bf.set, ptr %SortDirection, align 1
  %20 = load ptr, ptr %column, align 8
  %SortDirection12 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %20, i32 0, i32 37
  %bf.load13 = load i8, ptr %SortDirection12, align 1
  %bf.clear14 = and i8 %bf.load13, 3
  %conv15 = zext i8 %bf.clear14 to i32
  %cmp16 = icmp eq i32 %conv15, 0
  br i1 %cmp16, label %if.then17, label %if.else

if.then17:                                        ; preds = %if.end9
  %21 = load ptr, ptr %column, align 8
  %SortOrder18 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %21, i32 0, i32 22
  store i16 -1, ptr %SortOrder18, align 2
  br label %if.end29

if.else:                                          ; preds = %if.end9
  %22 = load ptr, ptr %column, align 8
  %SortOrder19 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %22, i32 0, i32 22
  %23 = load i16, ptr %SortOrder19, align 2
  %conv20 = sext i16 %23 to i32
  %cmp21 = icmp eq i32 %conv20, -1
  br i1 %cmp21, label %if.then23, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else
  %24 = load i8, ptr %append_to_sort_specs.addr, align 1
  %tobool22 = trunc i8 %24 to i1
  br i1 %tobool22, label %if.end28, label %if.then23

if.then23:                                        ; preds = %lor.lhs.false, %if.else
  %25 = load i8, ptr %append_to_sort_specs.addr, align 1
  %tobool24 = trunc i8 %25 to i1
  br i1 %tobool24, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then23
  %26 = load i16, ptr %sort_order_max, align 2
  %conv25 = sext i16 %26 to i32
  %add = add nsw i32 %conv25, 1
  br label %cond.end

cond.false:                                       ; preds = %if.then23
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %add, %cond.true ], [ 0, %cond.false ]
  %conv26 = trunc i32 %cond to i16
  %27 = load ptr, ptr %column, align 8
  %SortOrder27 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %27, i32 0, i32 22
  store i16 %conv26, ptr %SortOrder27, align 2
  br label %if.end28

if.end28:                                         ; preds = %cond.end, %lor.lhs.false
  br label %if.end29

if.end29:                                         ; preds = %if.end28, %if.then17
  store i32 0, ptr %other_column_n30, align 4
  br label %for.cond31

for.cond31:                                       ; preds = %for.inc42, %if.end29
  %28 = load i32, ptr %other_column_n30, align 4
  %29 = load ptr, ptr %table, align 8
  %ColumnsCount32 = getelementptr inbounds %struct.ImGuiTable, ptr %29, i32 0, i32 13
  %30 = load i32, ptr %ColumnsCount32, align 4
  %cmp33 = icmp slt i32 %28, %30
  br i1 %cmp33, label %for.body34, label %for.end44

for.body34:                                       ; preds = %for.cond31
  %31 = load ptr, ptr %table, align 8
  %Columns35 = getelementptr inbounds %struct.ImGuiTable, ptr %31, i32 0, i32 4
  %32 = load i32, ptr %other_column_n30, align 4
  %call36 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns35, i32 noundef %32)
  store ptr %call36, ptr %other_column, align 8
  %33 = load ptr, ptr %other_column, align 8
  %34 = load ptr, ptr %column, align 8
  %cmp37 = icmp ne ptr %33, %34
  br i1 %cmp37, label %land.lhs.true, label %if.end41

land.lhs.true:                                    ; preds = %for.body34
  %35 = load i8, ptr %append_to_sort_specs.addr, align 1
  %tobool38 = trunc i8 %35 to i1
  br i1 %tobool38, label %if.end41, label %if.then39

if.then39:                                        ; preds = %land.lhs.true
  %36 = load ptr, ptr %other_column, align 8
  %SortOrder40 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %36, i32 0, i32 22
  store i16 -1, ptr %SortOrder40, align 2
  br label %if.end41

if.end41:                                         ; preds = %if.then39, %land.lhs.true, %for.body34
  %37 = load ptr, ptr %table, align 8
  %38 = load ptr, ptr %other_column, align 8
  call void @_ZN5ImGui27TableFixColumnSortDirectionEP10ImGuiTableP16ImGuiTableColumn(ptr noundef %37, ptr noundef %38)
  br label %for.inc42

for.inc42:                                        ; preds = %if.end41
  %39 = load i32, ptr %other_column_n30, align 4
  %inc43 = add nsw i32 %39, 1
  store i32 %inc43, ptr %other_column_n30, align 4
  br label %for.cond31, !llvm.loop !45

for.end44:                                        ; preds = %for.cond31
  %40 = load ptr, ptr %table, align 8
  %IsSettingsDirty = getelementptr inbounds %struct.ImGuiTable, ptr %40, i32 0, i32 100
  store i8 1, ptr %IsSettingsDirty, align 2
  %41 = load ptr, ptr %table, align 8
  %IsSortSpecsDirty = getelementptr inbounds %struct.ImGuiTable, ptr %41, i32 0, i32 95
  store i8 1, ptr %IsSortSpecsDirty, align 1
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef signext i16 @_ZL5ImMaxIsET_S0_S0_(i16 noundef signext %lhs, i16 noundef signext %rhs) #3 {
entry:
  %lhs.addr = alloca i16, align 2
  %rhs.addr = alloca i16, align 2
  store i16 %lhs, ptr %lhs.addr, align 2
  store i16 %rhs, ptr %rhs.addr, align 2
  %0 = load i16, ptr %lhs.addr, align 2
  %conv = sext i16 %0 to i32
  %1 = load i16, ptr %rhs.addr, align 2
  %conv1 = sext i16 %1 to i32
  %cmp = icmp sge i32 %conv, %conv1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load i16, ptr %lhs.addr, align 2
  br label %cond.end

cond.false:                                       ; preds = %entry
  %3 = load i16, ptr %rhs.addr, align 2
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i16 [ %2, %cond.true ], [ %3, %cond.false ]
  ret i16 %cond
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui22TableSortSpecsSanitizeEP10ImGuiTable(ptr noundef %table) #0 {
entry:
  %table.addr = alloca ptr, align 8
  %sort_order_count = alloca i32, align 4
  %sort_order_mask = alloca i64, align 8
  %column_n = alloca i32, align 4
  %column = alloca ptr, align 8
  %need_fix_linearize = alloca i8, align 1
  %need_fix_single_sort_order = alloca i8, align 1
  %fixed_mask = alloca i64, align 8
  %sort_n = alloca i32, align 4
  %column_with_smallest_sort_order = alloca i32, align 4
  %column_n23 = alloca i32, align 4
  %column_n65 = alloca i32, align 4
  %column_n90 = alloca i32, align 4
  %column95 = alloca ptr, align 8
  store ptr %table, ptr %table.addr, align 8
  store i32 0, ptr %sort_order_count, align 4
  store i64 0, ptr %sort_order_mask, align 8
  store i32 0, ptr %column_n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %column_n, align 4
  %1 = load ptr, ptr %table.addr, align 8
  %ColumnsCount = getelementptr inbounds %struct.ImGuiTable, ptr %1, i32 0, i32 13
  %2 = load i32, ptr %ColumnsCount, align 4
  %cmp = icmp slt i32 %0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %table.addr, align 8
  %Columns = getelementptr inbounds %struct.ImGuiTable, ptr %3, i32 0, i32 4
  %4 = load i32, ptr %column_n, align 4
  %call = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns, i32 noundef %4)
  store ptr %call, ptr %column, align 8
  %5 = load ptr, ptr %column, align 8
  %SortOrder = getelementptr inbounds %struct.ImGuiTableColumn, ptr %5, i32 0, i32 22
  %6 = load i16, ptr %SortOrder, align 2
  %conv = sext i16 %6 to i32
  %cmp1 = icmp ne i32 %conv, -1
  br i1 %cmp1, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.body
  %7 = load ptr, ptr %column, align 8
  %IsEnabled = getelementptr inbounds %struct.ImGuiTableColumn, ptr %7, i32 0, i32 26
  %8 = load i8, ptr %IsEnabled, align 2
  %tobool = trunc i8 %8 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %9 = load ptr, ptr %column, align 8
  %SortOrder2 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %9, i32 0, i32 22
  store i16 -1, ptr %SortOrder2, align 2
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %for.body
  %10 = load ptr, ptr %column, align 8
  %SortOrder3 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %10, i32 0, i32 22
  %11 = load i16, ptr %SortOrder3, align 2
  %conv4 = sext i16 %11 to i32
  %cmp5 = icmp eq i32 %conv4, -1
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  br label %for.inc

if.end7:                                          ; preds = %if.end
  %12 = load i32, ptr %sort_order_count, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, ptr %sort_order_count, align 4
  %13 = load ptr, ptr %column, align 8
  %SortOrder8 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %13, i32 0, i32 22
  %14 = load i16, ptr %SortOrder8, align 2
  %conv9 = sext i16 %14 to i32
  %sh_prom = zext i32 %conv9 to i64
  %shl = shl i64 1, %sh_prom
  %15 = load i64, ptr %sort_order_mask, align 8
  %or = or i64 %15, %shl
  store i64 %or, ptr %sort_order_mask, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end7, %if.then6
  %16 = load i32, ptr %column_n, align 4
  %inc10 = add nsw i32 %16, 1
  store i32 %inc10, ptr %column_n, align 4
  br label %for.cond, !llvm.loop !46

for.end:                                          ; preds = %for.cond
  %17 = load i32, ptr %sort_order_count, align 4
  %sh_prom11 = zext i32 %17 to i64
  %shl12 = shl i64 1, %sh_prom11
  %18 = load i64, ptr %sort_order_mask, align 8
  %add = add i64 %18, 1
  %cmp13 = icmp ne i64 %shl12, %add
  %frombool = zext i1 %cmp13 to i8
  store i8 %frombool, ptr %need_fix_linearize, align 1
  %19 = load i32, ptr %sort_order_count, align 4
  %cmp14 = icmp sgt i32 %19, 1
  br i1 %cmp14, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.end
  %20 = load ptr, ptr %table.addr, align 8
  %Flags = getelementptr inbounds %struct.ImGuiTable, ptr %20, i32 0, i32 1
  %21 = load i32, ptr %Flags, align 4
  %and = and i32 %21, 67108864
  %tobool15 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool15, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.end
  %22 = phi i1 [ false, %for.end ], [ %lnot, %land.rhs ]
  %frombool16 = zext i1 %22 to i8
  store i8 %frombool16, ptr %need_fix_single_sort_order, align 1
  %23 = load i8, ptr %need_fix_linearize, align 1
  %tobool17 = trunc i8 %23 to i1
  br i1 %tobool17, label %if.then19, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.end
  %24 = load i8, ptr %need_fix_single_sort_order, align 1
  %tobool18 = trunc i8 %24 to i1
  br i1 %tobool18, label %if.then19, label %if.end83

if.then19:                                        ; preds = %lor.lhs.false, %land.end
  store i64 0, ptr %fixed_mask, align 8
  store i32 0, ptr %sort_n, align 4
  br label %for.cond20

for.cond20:                                       ; preds = %for.inc80, %if.then19
  %25 = load i32, ptr %sort_n, align 4
  %26 = load i32, ptr %sort_order_count, align 4
  %cmp21 = icmp slt i32 %25, %26
  br i1 %cmp21, label %for.body22, label %for.end82

for.body22:                                       ; preds = %for.cond20
  store i32 -1, ptr %column_with_smallest_sort_order, align 4
  store i32 0, ptr %column_n23, align 4
  br label %for.cond24

for.cond24:                                       ; preds = %for.inc53, %for.body22
  %27 = load i32, ptr %column_n23, align 4
  %28 = load ptr, ptr %table.addr, align 8
  %ColumnsCount25 = getelementptr inbounds %struct.ImGuiTable, ptr %28, i32 0, i32 13
  %29 = load i32, ptr %ColumnsCount25, align 4
  %cmp26 = icmp slt i32 %27, %29
  br i1 %cmp26, label %for.body27, label %for.end55

for.body27:                                       ; preds = %for.cond24
  %30 = load i64, ptr %fixed_mask, align 8
  %31 = load i32, ptr %column_n23, align 4
  %conv28 = sext i32 %31 to i64
  %shl29 = shl i64 1, %conv28
  %and30 = and i64 %30, %shl29
  %cmp31 = icmp eq i64 %and30, 0
  br i1 %cmp31, label %land.lhs.true32, label %if.end52

land.lhs.true32:                                  ; preds = %for.body27
  %32 = load ptr, ptr %table.addr, align 8
  %Columns33 = getelementptr inbounds %struct.ImGuiTable, ptr %32, i32 0, i32 4
  %33 = load i32, ptr %column_n23, align 4
  %call34 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns33, i32 noundef %33)
  %SortOrder35 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %call34, i32 0, i32 22
  %34 = load i16, ptr %SortOrder35, align 2
  %conv36 = sext i16 %34 to i32
  %cmp37 = icmp ne i32 %conv36, -1
  br i1 %cmp37, label %if.then38, label %if.end52

if.then38:                                        ; preds = %land.lhs.true32
  %35 = load i32, ptr %column_with_smallest_sort_order, align 4
  %cmp39 = icmp eq i32 %35, -1
  br i1 %cmp39, label %if.then50, label %lor.lhs.false40

lor.lhs.false40:                                  ; preds = %if.then38
  %36 = load ptr, ptr %table.addr, align 8
  %Columns41 = getelementptr inbounds %struct.ImGuiTable, ptr %36, i32 0, i32 4
  %37 = load i32, ptr %column_n23, align 4
  %call42 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns41, i32 noundef %37)
  %SortOrder43 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %call42, i32 0, i32 22
  %38 = load i16, ptr %SortOrder43, align 2
  %conv44 = sext i16 %38 to i32
  %39 = load ptr, ptr %table.addr, align 8
  %Columns45 = getelementptr inbounds %struct.ImGuiTable, ptr %39, i32 0, i32 4
  %40 = load i32, ptr %column_with_smallest_sort_order, align 4
  %call46 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns45, i32 noundef %40)
  %SortOrder47 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %call46, i32 0, i32 22
  %41 = load i16, ptr %SortOrder47, align 2
  %conv48 = sext i16 %41 to i32
  %cmp49 = icmp slt i32 %conv44, %conv48
  br i1 %cmp49, label %if.then50, label %if.end51

if.then50:                                        ; preds = %lor.lhs.false40, %if.then38
  %42 = load i32, ptr %column_n23, align 4
  store i32 %42, ptr %column_with_smallest_sort_order, align 4
  br label %if.end51

if.end51:                                         ; preds = %if.then50, %lor.lhs.false40
  br label %if.end52

if.end52:                                         ; preds = %if.end51, %land.lhs.true32, %for.body27
  br label %for.inc53

for.inc53:                                        ; preds = %if.end52
  %43 = load i32, ptr %column_n23, align 4
  %inc54 = add nsw i32 %43, 1
  store i32 %inc54, ptr %column_n23, align 4
  br label %for.cond24, !llvm.loop !47

for.end55:                                        ; preds = %for.cond24
  %44 = load i32, ptr %column_with_smallest_sort_order, align 4
  %sh_prom56 = zext i32 %44 to i64
  %shl57 = shl i64 1, %sh_prom56
  %45 = load i64, ptr %fixed_mask, align 8
  %or58 = or i64 %45, %shl57
  store i64 %or58, ptr %fixed_mask, align 8
  %46 = load i32, ptr %sort_n, align 4
  %conv59 = trunc i32 %46 to i16
  %47 = load ptr, ptr %table.addr, align 8
  %Columns60 = getelementptr inbounds %struct.ImGuiTable, ptr %47, i32 0, i32 4
  %48 = load i32, ptr %column_with_smallest_sort_order, align 4
  %call61 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns60, i32 noundef %48)
  %SortOrder62 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %call61, i32 0, i32 22
  store i16 %conv59, ptr %SortOrder62, align 2
  %49 = load i8, ptr %need_fix_single_sort_order, align 1
  %tobool63 = trunc i8 %49 to i1
  br i1 %tobool63, label %if.then64, label %if.end79

if.then64:                                        ; preds = %for.end55
  store i32 1, ptr %sort_order_count, align 4
  store i32 0, ptr %column_n65, align 4
  br label %for.cond66

for.cond66:                                       ; preds = %for.inc76, %if.then64
  %50 = load i32, ptr %column_n65, align 4
  %51 = load ptr, ptr %table.addr, align 8
  %ColumnsCount67 = getelementptr inbounds %struct.ImGuiTable, ptr %51, i32 0, i32 13
  %52 = load i32, ptr %ColumnsCount67, align 4
  %cmp68 = icmp slt i32 %50, %52
  br i1 %cmp68, label %for.body69, label %for.end78

for.body69:                                       ; preds = %for.cond66
  %53 = load i32, ptr %column_n65, align 4
  %54 = load i32, ptr %column_with_smallest_sort_order, align 4
  %cmp70 = icmp ne i32 %53, %54
  br i1 %cmp70, label %if.then71, label %if.end75

if.then71:                                        ; preds = %for.body69
  %55 = load ptr, ptr %table.addr, align 8
  %Columns72 = getelementptr inbounds %struct.ImGuiTable, ptr %55, i32 0, i32 4
  %56 = load i32, ptr %column_n65, align 4
  %call73 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns72, i32 noundef %56)
  %SortOrder74 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %call73, i32 0, i32 22
  store i16 -1, ptr %SortOrder74, align 2
  br label %if.end75

if.end75:                                         ; preds = %if.then71, %for.body69
  br label %for.inc76

for.inc76:                                        ; preds = %if.end75
  %57 = load i32, ptr %column_n65, align 4
  %inc77 = add nsw i32 %57, 1
  store i32 %inc77, ptr %column_n65, align 4
  br label %for.cond66, !llvm.loop !48

for.end78:                                        ; preds = %for.cond66
  br label %for.end82

if.end79:                                         ; preds = %for.end55
  br label %for.inc80

for.inc80:                                        ; preds = %if.end79
  %58 = load i32, ptr %sort_n, align 4
  %inc81 = add nsw i32 %58, 1
  store i32 %inc81, ptr %sort_n, align 4
  br label %for.cond20, !llvm.loop !49

for.end82:                                        ; preds = %for.end78, %for.cond20
  br label %if.end83

if.end83:                                         ; preds = %for.end82, %lor.lhs.false
  %59 = load i32, ptr %sort_order_count, align 4
  %cmp84 = icmp eq i32 %59, 0
  br i1 %cmp84, label %land.lhs.true85, label %if.end112

land.lhs.true85:                                  ; preds = %if.end83
  %60 = load ptr, ptr %table.addr, align 8
  %Flags86 = getelementptr inbounds %struct.ImGuiTable, ptr %60, i32 0, i32 1
  %61 = load i32, ptr %Flags86, align 4
  %and87 = and i32 %61, 134217728
  %tobool88 = icmp ne i32 %and87, 0
  br i1 %tobool88, label %if.end112, label %if.then89

if.then89:                                        ; preds = %land.lhs.true85
  store i32 0, ptr %column_n90, align 4
  br label %for.cond91

for.cond91:                                       ; preds = %for.inc109, %if.then89
  %62 = load i32, ptr %column_n90, align 4
  %63 = load ptr, ptr %table.addr, align 8
  %ColumnsCount92 = getelementptr inbounds %struct.ImGuiTable, ptr %63, i32 0, i32 13
  %64 = load i32, ptr %ColumnsCount92, align 4
  %cmp93 = icmp slt i32 %62, %64
  br i1 %cmp93, label %for.body94, label %for.end111

for.body94:                                       ; preds = %for.cond91
  %65 = load ptr, ptr %table.addr, align 8
  %Columns96 = getelementptr inbounds %struct.ImGuiTable, ptr %65, i32 0, i32 4
  %66 = load i32, ptr %column_n90, align 4
  %call97 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns96, i32 noundef %66)
  store ptr %call97, ptr %column95, align 8
  %67 = load ptr, ptr %column95, align 8
  %IsEnabled98 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %67, i32 0, i32 26
  %68 = load i8, ptr %IsEnabled98, align 2
  %tobool99 = trunc i8 %68 to i1
  br i1 %tobool99, label %land.lhs.true100, label %if.end108

land.lhs.true100:                                 ; preds = %for.body94
  %69 = load ptr, ptr %column95, align 8
  %Flags101 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %69, i32 0, i32 0
  %70 = load i32, ptr %Flags101, align 4
  %and102 = and i32 %70, 512
  %tobool103 = icmp ne i32 %and102, 0
  br i1 %tobool103, label %if.end108, label %if.then104

if.then104:                                       ; preds = %land.lhs.true100
  store i32 1, ptr %sort_order_count, align 4
  %71 = load ptr, ptr %column95, align 8
  %SortOrder105 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %71, i32 0, i32 22
  store i16 0, ptr %SortOrder105, align 2
  %72 = load ptr, ptr %column95, align 8
  %call106 = call noundef i32 @_ZL32TableGetColumnAvailSortDirectionP16ImGuiTableColumni(ptr noundef %72, i32 noundef 0)
  %conv107 = trunc i32 %call106 to i8
  %73 = load ptr, ptr %column95, align 8
  %SortDirection = getelementptr inbounds %struct.ImGuiTableColumn, ptr %73, i32 0, i32 37
  %bf.load = load i8, ptr %SortDirection, align 1
  %bf.value = and i8 %conv107, 3
  %bf.clear = and i8 %bf.load, -4
  %bf.set = or i8 %bf.clear, %bf.value
  store i8 %bf.set, ptr %SortDirection, align 1
  br label %for.end111

if.end108:                                        ; preds = %land.lhs.true100, %for.body94
  br label %for.inc109

for.inc109:                                       ; preds = %if.end108
  %74 = load i32, ptr %column_n90, align 4
  %inc110 = add nsw i32 %74, 1
  store i32 %inc110, ptr %column_n90, align 4
  br label %for.cond91, !llvm.loop !50

for.end111:                                       ; preds = %if.then104, %for.cond91
  br label %if.end112

if.end112:                                        ; preds = %for.end111, %land.lhs.true85, %if.end83
  %75 = load i32, ptr %sort_order_count, align 4
  %conv113 = trunc i32 %75 to i16
  %76 = load ptr, ptr %table.addr, align 8
  %SortSpecsCount = getelementptr inbounds %struct.ImGuiTable, ptr %76, i32 0, i32 65
  store i16 %conv113, ptr %SortSpecsCount, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI25ImGuiTableColumnSortSpecsE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_size) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_size.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_size, ptr %new_size.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_size.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.39, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sgt i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %new_size.addr, align 4
  %call = call noundef i32 @_ZNK8ImVectorI25ImGuiTableColumnSortSpecsE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %2)
  call void @_ZN8ImVectorI25ImGuiTableColumnSortSpecsE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %call)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32, ptr %new_size.addr, align 4
  %Size = getelementptr inbounds %struct.ImVector.39, ptr %this1, i32 0, i32 0
  store i32 %3, ptr %Size, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define noundef float @_ZN5ImGui23TableGetHeaderRowHeightEv() #2 {
entry:
  %g = alloca ptr, align 8
  %table = alloca ptr, align 8
  %row_height = alloca float, align 4
  %column_n = alloca i32, align 4
  %ref.tmp = alloca %struct.ImVec2, align 4
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %g, align 8
  %CurrentTable = getelementptr inbounds %struct.ImGuiContext, ptr %1, i32 0, i32 164
  %2 = load ptr, ptr %CurrentTable, align 8
  store ptr %2, ptr %table, align 8
  %3 = load ptr, ptr %g, align 8
  %FontSize = getelementptr inbounds %struct.ImGuiContext, ptr %3, i32 0, i32 5
  %4 = load float, ptr %FontSize, align 8
  store float %4, ptr %row_height, align 4
  store i32 0, ptr %column_n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %5 = load i32, ptr %column_n, align 4
  %6 = load ptr, ptr %table, align 8
  %ColumnsCount = getelementptr inbounds %struct.ImGuiTable, ptr %6, i32 0, i32 13
  %7 = load i32, ptr %ColumnsCount, align 4
  %cmp = icmp slt i32 %5, %7
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load ptr, ptr %table, align 8
  %EnabledMaskByIndex = getelementptr inbounds %struct.ImGuiTable, ptr %8, i32 0, i32 8
  %9 = load ptr, ptr %EnabledMaskByIndex, align 8
  %10 = load i32, ptr %column_n, align 4
  %shr = ashr i32 %10, 5
  %idxprom = sext i32 %shr to i64
  %arrayidx = getelementptr inbounds i32, ptr %9, i64 %idxprom
  %11 = load i32, ptr %arrayidx, align 4
  %12 = load i32, ptr %column_n, align 4
  %and = and i32 %12, 31
  %shl = shl i32 1, %and
  %and1 = and i32 %11, %shl
  %cmp2 = icmp ne i32 %and1, 0
  br i1 %cmp2, label %if.then, label %if.end9

if.then:                                          ; preds = %for.body
  %13 = load ptr, ptr %table, align 8
  %Columns = getelementptr inbounds %struct.ImGuiTable, ptr %13, i32 0, i32 4
  %14 = load i32, ptr %column_n, align 4
  %call = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns, i32 noundef %14)
  %Flags = getelementptr inbounds %struct.ImGuiTableColumn, ptr %call, i32 0, i32 0
  %15 = load i32, ptr %Flags, align 4
  %and3 = and i32 %15, 4096
  %cmp4 = icmp eq i32 %and3, 0
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.then
  %16 = load float, ptr %row_height, align 4
  %17 = load ptr, ptr %table, align 8
  %18 = load i32, ptr %column_n, align 4
  %call6 = call noundef ptr @_ZN5ImGui18TableGetColumnNameEPK10ImGuiTablei(ptr noundef %17, i32 noundef %18)
  %call7 = call <2 x float> @_ZN5ImGui12CalcTextSizeEPKcS1_bf(ptr noundef %call6, ptr noundef null, i1 noundef zeroext false, float noundef -1.000000e+00)
  store <2 x float> %call7, ptr %ref.tmp, align 4
  %y = getelementptr inbounds %struct.ImVec2, ptr %ref.tmp, i32 0, i32 1
  %19 = load float, ptr %y, align 4
  %call8 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %16, float noundef %19)
  store float %call8, ptr %row_height, align 4
  br label %if.end

if.end:                                           ; preds = %if.then5, %if.then
  br label %if.end9

if.end9:                                          ; preds = %if.end, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end9
  %20 = load i32, ptr %column_n, align 4
  %inc = add nsw i32 %20, 1
  store i32 %inc, ptr %column_n, align 4
  br label %for.cond, !llvm.loop !51

for.end:                                          ; preds = %for.cond
  %21 = load float, ptr %row_height, align 4
  %22 = load ptr, ptr %g, align 8
  %Style = getelementptr inbounds %struct.ImGuiContext, ptr %22, i32 0, i32 3
  %CellPadding = getelementptr inbounds %struct.ImGuiStyle, ptr %Style, i32 0, i32 17
  %y10 = getelementptr inbounds %struct.ImVec2, ptr %CellPadding, i32 0, i32 1
  %23 = load float, ptr %y10, align 4
  %24 = call float @llvm.fmuladd.f32(float %23, float 2.000000e+00, float %21)
  ret float %24
}

declare <2 x float> @_ZN5ImGui12CalcTextSizeEPKcS1_bf(ptr noundef, ptr noundef, i1 noundef zeroext, float noundef) #1

; Function Attrs: mustprogress uwtable
define noundef float @_ZN5ImGui33TableGetHeaderAngledMaxLabelWidthEv() #2 {
entry:
  %g = alloca ptr, align 8
  %table = alloca ptr, align 8
  %width = alloca float, align 4
  %column_n = alloca i32, align 4
  %ref.tmp = alloca %struct.ImVec2, align 4
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %g, align 8
  %CurrentTable = getelementptr inbounds %struct.ImGuiContext, ptr %1, i32 0, i32 164
  %2 = load ptr, ptr %CurrentTable, align 8
  store ptr %2, ptr %table, align 8
  store float 0.000000e+00, ptr %width, align 4
  store i32 0, ptr %column_n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %3 = load i32, ptr %column_n, align 4
  %4 = load ptr, ptr %table, align 8
  %ColumnsCount = getelementptr inbounds %struct.ImGuiTable, ptr %4, i32 0, i32 13
  %5 = load i32, ptr %ColumnsCount, align 4
  %cmp = icmp slt i32 %3, %5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load ptr, ptr %table, align 8
  %EnabledMaskByIndex = getelementptr inbounds %struct.ImGuiTable, ptr %6, i32 0, i32 8
  %7 = load ptr, ptr %EnabledMaskByIndex, align 8
  %8 = load i32, ptr %column_n, align 4
  %shr = ashr i32 %8, 5
  %idxprom = sext i32 %shr to i64
  %arrayidx = getelementptr inbounds i32, ptr %7, i64 %idxprom
  %9 = load i32, ptr %arrayidx, align 4
  %10 = load i32, ptr %column_n, align 4
  %and = and i32 %10, 31
  %shl = shl i32 1, %and
  %and1 = and i32 %9, %shl
  %cmp2 = icmp ne i32 %and1, 0
  br i1 %cmp2, label %if.then, label %if.end8

if.then:                                          ; preds = %for.body
  %11 = load ptr, ptr %table, align 8
  %Columns = getelementptr inbounds %struct.ImGuiTable, ptr %11, i32 0, i32 4
  %12 = load i32, ptr %column_n, align 4
  %call = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns, i32 noundef %12)
  %Flags = getelementptr inbounds %struct.ImGuiTableColumn, ptr %call, i32 0, i32 0
  %13 = load i32, ptr %Flags, align 4
  %and3 = and i32 %13, 262144
  %tobool = icmp ne i32 %and3, 0
  br i1 %tobool, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  %14 = load float, ptr %width, align 4
  %15 = load ptr, ptr %table, align 8
  %16 = load i32, ptr %column_n, align 4
  %call5 = call noundef ptr @_ZN5ImGui18TableGetColumnNameEPK10ImGuiTablei(ptr noundef %15, i32 noundef %16)
  %call6 = call <2 x float> @_ZN5ImGui12CalcTextSizeEPKcS1_bf(ptr noundef %call5, ptr noundef null, i1 noundef zeroext true, float noundef -1.000000e+00)
  store <2 x float> %call6, ptr %ref.tmp, align 4
  %x = getelementptr inbounds %struct.ImVec2, ptr %ref.tmp, i32 0, i32 0
  %17 = load float, ptr %x, align 4
  %call7 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %14, float noundef %17)
  store float %call7, ptr %width, align 4
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then
  br label %if.end8

if.end8:                                          ; preds = %if.end, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end8
  %18 = load i32, ptr %column_n, align 4
  %inc = add nsw i32 %18, 1
  store i32 %inc, ptr %column_n, align 4
  br label %for.cond, !llvm.loop !52

for.end:                                          ; preds = %for.cond
  %19 = load float, ptr %width, align 4
  %20 = load ptr, ptr %g, align 8
  %Style = getelementptr inbounds %struct.ImGuiContext, ptr %20, i32 0, i32 3
  %CellPadding = getelementptr inbounds %struct.ImGuiStyle, ptr %Style, i32 0, i32 17
  %x9 = getelementptr inbounds %struct.ImVec2, ptr %CellPadding, i32 0, i32 0
  %21 = load float, ptr %x9, align 4
  %22 = call float @llvm.fmuladd.f32(float %21, float 2.000000e+00, float %19)
  ret float %22
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui15TableHeadersRowEv() #2 {
entry:
  %g = alloca ptr, align 8
  %table = alloca ptr, align 8
  %row_height = alloca float, align 4
  %row_y1 = alloca float, align 4
  %ref.tmp = alloca %struct.ImVec2, align 4
  %columns_count = alloca i32, align 4
  %column_n = alloca i32, align 4
  %name = alloca ptr, align 8
  %mouse_pos = alloca %struct.ImVec2, align 4
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %g, align 8
  %CurrentTable = getelementptr inbounds %struct.ImGuiContext, ptr %1, i32 0, i32 164
  %2 = load ptr, ptr %CurrentTable, align 8
  store ptr %2, ptr %table, align 8
  %3 = load ptr, ptr %table, align 8
  %IsLayoutLocked = getelementptr inbounds %struct.ImGuiTable, ptr %3, i32 0, i32 92
  %4 = load i8, ptr %IsLayoutLocked, align 2
  %tobool = trunc i8 %4 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load ptr, ptr %table, align 8
  call void @_ZN5ImGui17TableUpdateLayoutEP10ImGuiTable(ptr noundef %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %call = call noundef float @_ZN5ImGui23TableGetHeaderRowHeightEv()
  store float %call, ptr %row_height, align 4
  %6 = load float, ptr %row_height, align 4
  call void @_ZN5ImGui12TableNextRowEif(i32 noundef 1, float noundef %6)
  %call1 = call <2 x float> @_ZN5ImGui18GetCursorScreenPosEv()
  store <2 x float> %call1, ptr %ref.tmp, align 4
  %y = getelementptr inbounds %struct.ImVec2, ptr %ref.tmp, i32 0, i32 1
  %7 = load float, ptr %y, align 4
  store float %7, ptr %row_y1, align 4
  %8 = load ptr, ptr %table, align 8
  %HostSkipItems = getelementptr inbounds %struct.ImGuiTable, ptr %8, i32 0, i32 111
  %9 = load i8, ptr %HostSkipItems, align 1
  %tobool2 = trunc i8 %9 to i1
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  br label %if.end24

if.end4:                                          ; preds = %if.end
  %call5 = call noundef i32 @_ZN5ImGui19TableGetColumnCountEv()
  store i32 %call5, ptr %columns_count, align 4
  store i32 0, ptr %column_n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end4
  %10 = load i32, ptr %column_n, align 4
  %11 = load i32, ptr %columns_count, align 4
  %cmp = icmp slt i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %column_n, align 4
  %call6 = call noundef zeroext i1 @_ZN5ImGui19TableSetColumnIndexEi(i32 noundef %12)
  br i1 %call6, label %if.end8, label %if.then7

if.then7:                                         ; preds = %for.body
  br label %for.inc

if.end8:                                          ; preds = %for.body
  %13 = load i32, ptr %column_n, align 4
  %call9 = call noundef i32 @_ZN5ImGui19TableGetColumnFlagsEi(i32 noundef %13)
  %and = and i32 %call9, 4096
  %tobool10 = icmp ne i32 %and, 0
  br i1 %tobool10, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end8
  br label %cond.end

cond.false:                                       ; preds = %if.end8
  %14 = load i32, ptr %column_n, align 4
  %call11 = call noundef ptr @_ZN5ImGui18TableGetColumnNameEi(i32 noundef %14)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ @.str.1, %cond.true ], [ %call11, %cond.false ]
  store ptr %cond, ptr %name, align 8
  %15 = load i32, ptr %column_n, align 4
  call void @_ZN5ImGui6PushIDEi(i32 noundef %15)
  %16 = load ptr, ptr %name, align 8
  call void @_ZN5ImGui11TableHeaderEPKc(ptr noundef %16)
  call void @_ZN5ImGui5PopIDEv()
  br label %for.inc

for.inc:                                          ; preds = %cond.end, %if.then7
  %17 = load i32, ptr %column_n, align 4
  %inc = add nsw i32 %17, 1
  store i32 %inc, ptr %column_n, align 4
  br label %for.cond, !llvm.loop !53

for.end:                                          ; preds = %for.cond
  %call12 = call <2 x float> @_ZN5ImGui11GetMousePosEv()
  store <2 x float> %call12, ptr %mouse_pos, align 4
  %call13 = call noundef zeroext i1 @_ZN5ImGui15IsMouseReleasedEi(i32 noundef 1)
  br i1 %call13, label %land.lhs.true, label %if.end24

land.lhs.true:                                    ; preds = %for.end
  %call14 = call noundef i32 @_ZN5ImGui21TableGetHoveredColumnEv()
  %18 = load i32, ptr %columns_count, align 4
  %cmp15 = icmp eq i32 %call14, %18
  br i1 %cmp15, label %if.then16, label %if.end24

if.then16:                                        ; preds = %land.lhs.true
  %y17 = getelementptr inbounds %struct.ImVec2, ptr %mouse_pos, i32 0, i32 1
  %19 = load float, ptr %y17, align 4
  %20 = load float, ptr %row_y1, align 4
  %cmp18 = fcmp oge float %19, %20
  br i1 %cmp18, label %land.lhs.true19, label %if.end23

land.lhs.true19:                                  ; preds = %if.then16
  %y20 = getelementptr inbounds %struct.ImVec2, ptr %mouse_pos, i32 0, i32 1
  %21 = load float, ptr %y20, align 4
  %22 = load float, ptr %row_y1, align 4
  %23 = load float, ptr %row_height, align 4
  %add = fadd float %22, %23
  %cmp21 = fcmp olt float %21, %add
  br i1 %cmp21, label %if.then22, label %if.end23

if.then22:                                        ; preds = %land.lhs.true19
  %24 = load i32, ptr %columns_count, align 4
  call void @_ZN5ImGui20TableOpenContextMenuEi(i32 noundef %24)
  br label %if.end23

if.end23:                                         ; preds = %if.then22, %land.lhs.true19, %if.then16
  br label %if.end24

if.end24:                                         ; preds = %if.end23, %land.lhs.true, %for.end, %if.then3
  ret void
}

declare <2 x float> @_ZN5ImGui18GetCursorScreenPosEv() #1

declare void @_ZN5ImGui6PushIDEi(i32 noundef) #1

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui11TableHeaderEPKc(ptr noundef %label) #2 {
entry:
  %label.addr = alloca ptr, align 8
  %g = alloca ptr, align 8
  %window = alloca ptr, align 8
  %table = alloca ptr, align 8
  %column_n = alloca i32, align 4
  %column = alloca ptr, align 8
  %label_end = alloca ptr, align 8
  %label_size = alloca %struct.ImVec2, align 4
  %label_pos = alloca %struct.ImVec2, align 4
  %cell_r = alloca %struct.ImRect, align 4
  %label_height = alloca float, align 4
  %w_arrow = alloca float, align 4
  %w_sort_text = alloca float, align 4
  %sort_arrow = alloca i8, align 1
  %sort_order_suf = alloca [4 x i8], align 1
  %ARROW_SCALE = alloca float, align 4
  %ref.tmp = alloca %struct.ImVec2, align 4
  %max_pos_x = alloca float, align 4
  %id = alloca i32, align 4
  %bb = alloca %struct.ImRect, align 4
  %ref.tmp59 = alloca %struct.ImVec2, align 4
  %highlight = alloca i8, align 1
  %hovered = alloca i8, align 1
  %held = alloca i8, align 1
  %pressed = alloca i8, align 1
  %col = alloca i32, align 4
  %prev_column = alloca ptr, align 8
  %next_column = alloca ptr, align 8
  %ellipsis_max = alloca float, align 4
  %x218 = alloca float, align 4
  %y226 = alloca float, align 4
  %agg.tmp = alloca %struct.ImVec2, align 4
  %agg.tmp240 = alloca %struct.ImVec2, align 4
  %sort_direction = alloca i32, align 4
  %ref.tmp259 = alloca %struct.ImVec2, align 4
  %text_clipped = alloca i8, align 1
  store ptr %label, ptr %label.addr, align 8
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %g, align 8
  %CurrentWindow = getelementptr inbounds %struct.ImGuiContext, ptr %1, i32 0, i32 29
  %2 = load ptr, ptr %CurrentWindow, align 8
  store ptr %2, ptr %window, align 8
  %3 = load ptr, ptr %window, align 8
  %SkipItems = getelementptr inbounds %struct.ImGuiWindow, ptr %3, i32 0, i32 38
  %4 = load i8, ptr %SkipItems, align 1
  %tobool = trunc i8 %4 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end283

if.end:                                           ; preds = %entry
  %5 = load ptr, ptr %g, align 8
  %CurrentTable = getelementptr inbounds %struct.ImGuiContext, ptr %5, i32 0, i32 164
  %6 = load ptr, ptr %CurrentTable, align 8
  store ptr %6, ptr %table, align 8
  %7 = load ptr, ptr %table, align 8
  %CurrentColumn = getelementptr inbounds %struct.ImGuiTable, ptr %7, i32 0, i32 15
  %8 = load i32, ptr %CurrentColumn, align 4
  store i32 %8, ptr %column_n, align 4
  %9 = load ptr, ptr %table, align 8
  %Columns = getelementptr inbounds %struct.ImGuiTable, ptr %9, i32 0, i32 4
  %10 = load i32, ptr %column_n, align 4
  %call = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns, i32 noundef %10)
  store ptr %call, ptr %column, align 8
  %11 = load ptr, ptr %label.addr, align 8
  %cmp = icmp eq ptr %11, null
  br i1 %cmp, label %if.then1, label %if.end2

if.then1:                                         ; preds = %if.end
  store ptr @.str.1, ptr %label.addr, align 8
  br label %if.end2

if.end2:                                          ; preds = %if.then1, %if.end
  %12 = load ptr, ptr %label.addr, align 8
  %call3 = call noundef ptr @_ZN5ImGui19FindRenderedTextEndEPKcS1_(ptr noundef %12, ptr noundef null)
  store ptr %call3, ptr %label_end, align 8
  %13 = load ptr, ptr %label.addr, align 8
  %14 = load ptr, ptr %label_end, align 8
  %call4 = call <2 x float> @_ZN5ImGui12CalcTextSizeEPKcS1_bf(ptr noundef %13, ptr noundef %14, i1 noundef zeroext true, float noundef -1.000000e+00)
  store <2 x float> %call4, ptr %label_size, align 4
  %15 = load ptr, ptr %window, align 8
  %DC = getelementptr inbounds %struct.ImGuiWindow, ptr %15, i32 0, i32 68
  %CursorPos = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %label_pos, ptr align 8 %CursorPos, i64 8, i1 false)
  %16 = load ptr, ptr %table, align 8
  %17 = load i32, ptr %column_n, align 4
  %call5 = call { <2 x float>, <2 x float> } @_ZN5ImGui18TableGetCellBgRectEPK10ImGuiTablei(ptr noundef %16, i32 noundef %17)
  %18 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %cell_r, i32 0, i32 0
  %19 = extractvalue { <2 x float>, <2 x float> } %call5, 0
  store <2 x float> %19, ptr %18, align 4
  %20 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %cell_r, i32 0, i32 1
  %21 = extractvalue { <2 x float>, <2 x float> } %call5, 1
  store <2 x float> %21, ptr %20, align 4
  %y = getelementptr inbounds %struct.ImVec2, ptr %label_size, i32 0, i32 1
  %22 = load float, ptr %y, align 4
  %23 = load ptr, ptr %table, align 8
  %RowMinHeight = getelementptr inbounds %struct.ImGuiTable, ptr %23, i32 0, i32 20
  %24 = load float, ptr %RowMinHeight, align 4
  %25 = load ptr, ptr %table, align 8
  %RowCellPaddingY = getelementptr inbounds %struct.ImGuiTable, ptr %25, i32 0, i32 21
  %26 = load float, ptr %RowCellPaddingY, align 8
  %neg = fneg float %26
  %27 = call float @llvm.fmuladd.f32(float %neg, float 2.000000e+00, float %24)
  %call6 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %22, float noundef %27)
  store float %call6, ptr %label_height, align 4
  store float 0.000000e+00, ptr %w_arrow, align 4
  store float 0.000000e+00, ptr %w_sort_text, align 4
  store i8 0, ptr %sort_arrow, align 1
  call void @llvm.memset.p0.i64(ptr align 1 %sort_order_suf, i8 0, i64 4, i1 false)
  store float 0x3FE4CCCCC0000000, ptr %ARROW_SCALE, align 4
  %28 = load ptr, ptr %table, align 8
  %Flags = getelementptr inbounds %struct.ImGuiTable, ptr %28, i32 0, i32 1
  %29 = load i32, ptr %Flags, align 4
  %and = and i32 %29, 8
  %tobool7 = icmp ne i32 %and, 0
  br i1 %tobool7, label %land.lhs.true, label %if.end30

land.lhs.true:                                    ; preds = %if.end2
  %30 = load ptr, ptr %column, align 8
  %Flags8 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %30, i32 0, i32 0
  %31 = load i32, ptr %Flags8, align 4
  %and9 = and i32 %31, 512
  %tobool10 = icmp ne i32 %and9, 0
  br i1 %tobool10, label %if.end30, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %32 = load ptr, ptr %g, align 8
  %FontSize = getelementptr inbounds %struct.ImGuiContext, ptr %32, i32 0, i32 5
  %33 = load float, ptr %FontSize, align 8
  %34 = load ptr, ptr %g, align 8
  %Style = getelementptr inbounds %struct.ImGuiContext, ptr %34, i32 0, i32 3
  %FramePadding = getelementptr inbounds %struct.ImGuiStyle, ptr %Style, i32 0, i32 12
  %x = getelementptr inbounds %struct.ImVec2, ptr %FramePadding, i32 0, i32 0
  %35 = load float, ptr %x, align 4
  %36 = call float @llvm.fmuladd.f32(float %33, float 0x3FE4CCCCC0000000, float %35)
  %call12 = call noundef float @_ZL7ImTruncf(float noundef %36)
  store float %call12, ptr %w_arrow, align 4
  %37 = load ptr, ptr %column, align 8
  %SortOrder = getelementptr inbounds %struct.ImGuiTableColumn, ptr %37, i32 0, i32 22
  %38 = load i16, ptr %SortOrder, align 2
  %conv = sext i16 %38 to i32
  %cmp13 = icmp ne i32 %conv, -1
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.then11
  store i8 1, ptr %sort_arrow, align 1
  br label %if.end15

if.end15:                                         ; preds = %if.then14, %if.then11
  %39 = load ptr, ptr %column, align 8
  %SortOrder16 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %39, i32 0, i32 22
  %40 = load i16, ptr %SortOrder16, align 2
  %conv17 = sext i16 %40 to i32
  %cmp18 = icmp sgt i32 %conv17, 0
  br i1 %cmp18, label %if.then19, label %if.end29

if.then19:                                        ; preds = %if.end15
  %arraydecay = getelementptr inbounds [4 x i8], ptr %sort_order_suf, i64 0, i64 0
  %41 = load ptr, ptr %column, align 8
  %SortOrder20 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %41, i32 0, i32 22
  %42 = load i16, ptr %SortOrder20, align 2
  %conv21 = sext i16 %42 to i32
  %add = add nsw i32 %conv21, 1
  %call22 = call noundef i32 (ptr, i64, ptr, ...) @_Z14ImFormatStringPcmPKcz(ptr noundef %arraydecay, i64 noundef 4, ptr noundef @.str.3, i32 noundef %add)
  %43 = load ptr, ptr %g, align 8
  %Style23 = getelementptr inbounds %struct.ImGuiContext, ptr %43, i32 0, i32 3
  %ItemInnerSpacing = getelementptr inbounds %struct.ImGuiStyle, ptr %Style23, i32 0, i32 16
  %x24 = getelementptr inbounds %struct.ImVec2, ptr %ItemInnerSpacing, i32 0, i32 0
  %44 = load float, ptr %x24, align 4
  %arraydecay25 = getelementptr inbounds [4 x i8], ptr %sort_order_suf, i64 0, i64 0
  %call26 = call <2 x float> @_ZN5ImGui12CalcTextSizeEPKcS1_bf(ptr noundef %arraydecay25, ptr noundef null, i1 noundef zeroext false, float noundef -1.000000e+00)
  store <2 x float> %call26, ptr %ref.tmp, align 4
  %x27 = getelementptr inbounds %struct.ImVec2, ptr %ref.tmp, i32 0, i32 0
  %45 = load float, ptr %x27, align 4
  %add28 = fadd float %44, %45
  store float %add28, ptr %w_sort_text, align 4
  br label %if.end29

if.end29:                                         ; preds = %if.then19, %if.end15
  br label %if.end30

if.end30:                                         ; preds = %if.end29, %land.lhs.true, %if.end2
  %x31 = getelementptr inbounds %struct.ImVec2, ptr %label_pos, i32 0, i32 0
  %46 = load float, ptr %x31, align 4
  %x32 = getelementptr inbounds %struct.ImVec2, ptr %label_size, i32 0, i32 0
  %47 = load float, ptr %x32, align 4
  %add33 = fadd float %46, %47
  %48 = load float, ptr %w_sort_text, align 4
  %add34 = fadd float %add33, %48
  %49 = load float, ptr %w_arrow, align 4
  %add35 = fadd float %add34, %49
  store float %add35, ptr %max_pos_x, align 4
  %50 = load ptr, ptr %column, align 8
  %ContentMaxXHeadersUsed = getelementptr inbounds %struct.ImGuiTableColumn, ptr %50, i32 0, i32 15
  %51 = load float, ptr %ContentMaxXHeadersUsed, align 4
  %52 = load i8, ptr %sort_arrow, align 1
  %tobool36 = trunc i8 %52 to i1
  br i1 %tobool36, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end30
  %Max = getelementptr inbounds %struct.ImRect, ptr %cell_r, i32 0, i32 1
  %x37 = getelementptr inbounds %struct.ImVec2, ptr %Max, i32 0, i32 0
  %53 = load float, ptr %x37, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end30
  %54 = load float, ptr %max_pos_x, align 4
  %Max38 = getelementptr inbounds %struct.ImRect, ptr %cell_r, i32 0, i32 1
  %x39 = getelementptr inbounds %struct.ImVec2, ptr %Max38, i32 0, i32 0
  %55 = load float, ptr %x39, align 4
  %call40 = call noundef float @_ZL5ImMinIfET_S0_S0_(float noundef %54, float noundef %55)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi float [ %53, %cond.true ], [ %call40, %cond.false ]
  %call41 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %51, float noundef %cond)
  %56 = load ptr, ptr %column, align 8
  %ContentMaxXHeadersUsed42 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %56, i32 0, i32 15
  store float %call41, ptr %ContentMaxXHeadersUsed42, align 4
  %57 = load ptr, ptr %column, align 8
  %ContentMaxXHeadersIdeal = getelementptr inbounds %struct.ImGuiTableColumn, ptr %57, i32 0, i32 16
  %58 = load float, ptr %ContentMaxXHeadersIdeal, align 4
  %59 = load float, ptr %max_pos_x, align 4
  %call43 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %58, float noundef %59)
  %60 = load ptr, ptr %column, align 8
  %ContentMaxXHeadersIdeal44 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %60, i32 0, i32 16
  store float %call43, ptr %ContentMaxXHeadersIdeal44, align 4
  %61 = load ptr, ptr %window, align 8
  %62 = load ptr, ptr %label.addr, align 8
  %call45 = call noundef i32 @_ZN11ImGuiWindow5GetIDEPKcS1_(ptr noundef nonnull align 8 dereferenceable(1013) %61, ptr noundef %62, ptr noundef null)
  store i32 %call45, ptr %id, align 4
  %Min = getelementptr inbounds %struct.ImRect, ptr %cell_r, i32 0, i32 0
  %x46 = getelementptr inbounds %struct.ImVec2, ptr %Min, i32 0, i32 0
  %63 = load float, ptr %x46, align 4
  %Min47 = getelementptr inbounds %struct.ImRect, ptr %cell_r, i32 0, i32 0
  %y48 = getelementptr inbounds %struct.ImVec2, ptr %Min47, i32 0, i32 1
  %64 = load float, ptr %y48, align 4
  %Max49 = getelementptr inbounds %struct.ImRect, ptr %cell_r, i32 0, i32 1
  %x50 = getelementptr inbounds %struct.ImVec2, ptr %Max49, i32 0, i32 0
  %65 = load float, ptr %x50, align 4
  %Max51 = getelementptr inbounds %struct.ImRect, ptr %cell_r, i32 0, i32 1
  %y52 = getelementptr inbounds %struct.ImVec2, ptr %Max51, i32 0, i32 1
  %66 = load float, ptr %y52, align 4
  %Min53 = getelementptr inbounds %struct.ImRect, ptr %cell_r, i32 0, i32 0
  %y54 = getelementptr inbounds %struct.ImVec2, ptr %Min53, i32 0, i32 1
  %67 = load float, ptr %y54, align 4
  %68 = load float, ptr %label_height, align 4
  %add55 = fadd float %67, %68
  %69 = load ptr, ptr %g, align 8
  %Style56 = getelementptr inbounds %struct.ImGuiContext, ptr %69, i32 0, i32 3
  %CellPadding = getelementptr inbounds %struct.ImGuiStyle, ptr %Style56, i32 0, i32 17
  %y57 = getelementptr inbounds %struct.ImVec2, ptr %CellPadding, i32 0, i32 1
  %70 = load float, ptr %y57, align 4
  %71 = call float @llvm.fmuladd.f32(float %70, float 2.000000e+00, float %add55)
  %call58 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %66, float noundef %71)
  call void @_ZN6ImRectC2Effff(ptr noundef nonnull align 4 dereferenceable(16) %bb, float noundef %63, float noundef %64, float noundef %65, float noundef %call58)
  %72 = load float, ptr %label_height, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp59, float noundef 0.000000e+00, float noundef %72)
  call void @_ZN5ImGui8ItemSizeERK6ImVec2f(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp59, float noundef -1.000000e+00)
  %73 = load i32, ptr %id, align 4
  %call60 = call noundef zeroext i1 @_ZN5ImGui7ItemAddERK6ImRectjPS1_i(ptr noundef nonnull align 4 dereferenceable(16) %bb, i32 noundef %73, ptr noundef null, i32 noundef 0)
  br i1 %call60, label %if.end62, label %if.then61

if.then61:                                        ; preds = %cond.end
  br label %if.end283

if.end62:                                         ; preds = %cond.end
  %74 = load ptr, ptr %table, align 8
  %HighlightColumnHeader = getelementptr inbounds %struct.ImGuiTable, ptr %74, i32 0, i32 72
  %75 = load i16, ptr %HighlightColumnHeader, align 2
  %conv63 = sext i16 %75 to i32
  %76 = load i32, ptr %column_n, align 4
  %cmp64 = icmp eq i32 %conv63, %76
  %frombool = zext i1 %cmp64 to i8
  store i8 %frombool, ptr %highlight, align 1
  %77 = load i32, ptr %id, align 4
  %call65 = call noundef zeroext i1 @_ZN5ImGui14ButtonBehaviorERK6ImRectjPbS3_i(ptr noundef nonnull align 4 dereferenceable(16) %bb, i32 noundef %77, ptr noundef %hovered, ptr noundef %held, i32 noundef 4096)
  %frombool66 = zext i1 %call65 to i8
  store i8 %frombool66, ptr %pressed, align 1
  %78 = load i8, ptr %held, align 1
  %tobool67 = trunc i8 %78 to i1
  br i1 %tobool67, label %if.then71, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end62
  %79 = load i8, ptr %hovered, align 1
  %tobool68 = trunc i8 %79 to i1
  br i1 %tobool68, label %if.then71, label %lor.lhs.false69

lor.lhs.false69:                                  ; preds = %lor.lhs.false
  %80 = load i8, ptr %highlight, align 1
  %tobool70 = trunc i8 %80 to i1
  br i1 %tobool70, label %if.then71, label %if.else

if.then71:                                        ; preds = %lor.lhs.false69, %lor.lhs.false, %if.end62
  %81 = load i8, ptr %held, align 1
  %tobool72 = trunc i8 %81 to i1
  br i1 %tobool72, label %cond.true73, label %cond.false74

cond.true73:                                      ; preds = %if.then71
  br label %cond.end77

cond.false74:                                     ; preds = %if.then71
  %82 = load i8, ptr %hovered, align 1
  %tobool75 = trunc i8 %82 to i1
  %cond76 = select i1 %tobool75, i32 25, i32 24
  br label %cond.end77

cond.end77:                                       ; preds = %cond.false74, %cond.true73
  %cond78 = phi i32 [ 26, %cond.true73 ], [ %cond76, %cond.false74 ]
  %call79 = call noundef i32 @_ZN5ImGui11GetColorU32Eif(i32 noundef %cond78, float noundef 1.000000e+00)
  store i32 %call79, ptr %col, align 4
  %83 = load i32, ptr %col, align 4
  %84 = load ptr, ptr %table, align 8
  %CurrentColumn80 = getelementptr inbounds %struct.ImGuiTable, ptr %84, i32 0, i32 15
  %85 = load i32, ptr %CurrentColumn80, align 4
  call void @_ZN5ImGui15TableSetBgColorEiji(i32 noundef 3, i32 noundef %83, i32 noundef %85)
  br label %if.end87

if.else:                                          ; preds = %lor.lhs.false69
  %86 = load ptr, ptr %table, align 8
  %RowFlags = getelementptr inbounds %struct.ImGuiTable, ptr %86, i32 0, i32 24
  %bf.load = load i32, ptr %RowFlags, align 4
  %bf.shl = shl i32 %bf.load, 16
  %bf.ashr = ashr i32 %bf.shl, 16
  %and81 = and i32 %bf.ashr, 1
  %cmp82 = icmp eq i32 %and81, 0
  br i1 %cmp82, label %if.then83, label %if.end86

if.then83:                                        ; preds = %if.else
  %call84 = call noundef i32 @_ZN5ImGui11GetColorU32Eif(i32 noundef 42, float noundef 1.000000e+00)
  %87 = load ptr, ptr %table, align 8
  %CurrentColumn85 = getelementptr inbounds %struct.ImGuiTable, ptr %87, i32 0, i32 15
  %88 = load i32, ptr %CurrentColumn85, align 4
  call void @_ZN5ImGui15TableSetBgColorEiji(i32 noundef 3, i32 noundef %call84, i32 noundef %88)
  br label %if.end86

if.end86:                                         ; preds = %if.then83, %if.else
  br label %if.end87

if.end87:                                         ; preds = %if.end86, %cond.end77
  %89 = load i32, ptr %id, align 4
  call void @_ZN5ImGui18RenderNavHighlightERK6ImRectji(ptr noundef nonnull align 4 dereferenceable(16) %bb, i32 noundef %89, i32 noundef 10)
  %90 = load i8, ptr %held, align 1
  %tobool88 = trunc i8 %90 to i1
  br i1 %tobool88, label %if.then89, label %if.end91

if.then89:                                        ; preds = %if.end87
  %91 = load i32, ptr %column_n, align 4
  %conv90 = trunc i32 %91 to i16
  %92 = load ptr, ptr %table, align 8
  %HeldHeaderColumn = getelementptr inbounds %struct.ImGuiTable, ptr %92, i32 0, i32 76
  store i16 %conv90, ptr %HeldHeaderColumn, align 2
  br label %if.end91

if.end91:                                         ; preds = %if.then89, %if.end87
  %93 = load ptr, ptr %g, align 8
  %Style92 = getelementptr inbounds %struct.ImGuiContext, ptr %93, i32 0, i32 3
  %ItemSpacing = getelementptr inbounds %struct.ImGuiStyle, ptr %Style92, i32 0, i32 15
  %y93 = getelementptr inbounds %struct.ImVec2, ptr %ItemSpacing, i32 0, i32 1
  %94 = load float, ptr %y93, align 4
  %95 = load ptr, ptr %window, align 8
  %DC94 = getelementptr inbounds %struct.ImGuiWindow, ptr %95, i32 0, i32 68
  %CursorPos95 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC94, i32 0, i32 0
  %y96 = getelementptr inbounds %struct.ImVec2, ptr %CursorPos95, i32 0, i32 1
  %96 = load float, ptr %y96, align 4
  %neg97 = fneg float %94
  %97 = call float @llvm.fmuladd.f32(float %neg97, float 5.000000e-01, float %96)
  store float %97, ptr %y96, align 4
  %98 = load i8, ptr %held, align 1
  %tobool98 = trunc i8 %98 to i1
  br i1 %tobool98, label %land.lhs.true99, label %if.end200

land.lhs.true99:                                  ; preds = %if.end91
  %99 = load ptr, ptr %table, align 8
  %Flags100 = getelementptr inbounds %struct.ImGuiTable, ptr %99, i32 0, i32 1
  %100 = load i32, ptr %Flags100, align 4
  %and101 = and i32 %100, 2
  %tobool102 = icmp ne i32 %and101, 0
  br i1 %tobool102, label %land.lhs.true103, label %if.end200

land.lhs.true103:                                 ; preds = %land.lhs.true99
  %call104 = call noundef zeroext i1 @_ZN5ImGui15IsMouseDraggingEif(i32 noundef 0, float noundef -1.000000e+00)
  br i1 %call104, label %land.lhs.true105, label %if.end200

land.lhs.true105:                                 ; preds = %land.lhs.true103
  %101 = load ptr, ptr %g, align 8
  %DragDropActive = getelementptr inbounds %struct.ImGuiContext, ptr %101, i32 0, i32 144
  %102 = load i8, ptr %DragDropActive, align 8
  %tobool106 = trunc i8 %102 to i1
  br i1 %tobool106, label %if.end200, label %if.then107

if.then107:                                       ; preds = %land.lhs.true105
  %103 = load i32, ptr %column_n, align 4
  %conv108 = trunc i32 %103 to i16
  %104 = load ptr, ptr %table, align 8
  %ReorderColumn = getelementptr inbounds %struct.ImGuiTable, ptr %104, i32 0, i32 77
  store i16 %conv108, ptr %ReorderColumn, align 8
  %105 = load ptr, ptr %table, align 8
  %InstanceCurrent = getelementptr inbounds %struct.ImGuiTable, ptr %105, i32 0, i32 16
  %106 = load i16, ptr %InstanceCurrent, align 8
  %107 = load ptr, ptr %table, align 8
  %InstanceInteracted = getelementptr inbounds %struct.ImGuiTable, ptr %107, i32 0, i32 17
  store i16 %106, ptr %InstanceInteracted, align 2
  %108 = load ptr, ptr %g, align 8
  %IO = getelementptr inbounds %struct.ImGuiContext, ptr %108, i32 0, i32 2
  %MouseDelta = getelementptr inbounds %struct.ImGuiIO, ptr %IO, i32 0, i32 53
  %x109 = getelementptr inbounds %struct.ImVec2, ptr %MouseDelta, i32 0, i32 0
  %109 = load float, ptr %x109, align 8
  %cmp110 = fcmp olt float %109, 0.000000e+00
  br i1 %cmp110, label %land.lhs.true111, label %if.end150

land.lhs.true111:                                 ; preds = %if.then107
  %110 = load ptr, ptr %g, align 8
  %IO112 = getelementptr inbounds %struct.ImGuiContext, ptr %110, i32 0, i32 2
  %MousePos = getelementptr inbounds %struct.ImGuiIO, ptr %IO112, i32 0, i32 59
  %x113 = getelementptr inbounds %struct.ImVec2, ptr %MousePos, i32 0, i32 0
  %111 = load float, ptr %x113, align 8
  %Min114 = getelementptr inbounds %struct.ImRect, ptr %cell_r, i32 0, i32 0
  %x115 = getelementptr inbounds %struct.ImVec2, ptr %Min114, i32 0, i32 0
  %112 = load float, ptr %x115, align 4
  %cmp116 = fcmp olt float %111, %112
  br i1 %cmp116, label %if.then117, label %if.end150

if.then117:                                       ; preds = %land.lhs.true111
  %113 = load ptr, ptr %column, align 8
  %PrevEnabledColumn = getelementptr inbounds %struct.ImGuiTableColumn, ptr %113, i32 0, i32 20
  %114 = load i16, ptr %PrevEnabledColumn, align 2
  %conv118 = sext i16 %114 to i32
  %cmp119 = icmp ne i32 %conv118, -1
  br i1 %cmp119, label %cond.true120, label %cond.false125

cond.true120:                                     ; preds = %if.then117
  %115 = load ptr, ptr %table, align 8
  %Columns121 = getelementptr inbounds %struct.ImGuiTable, ptr %115, i32 0, i32 4
  %116 = load ptr, ptr %column, align 8
  %PrevEnabledColumn122 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %116, i32 0, i32 20
  %117 = load i16, ptr %PrevEnabledColumn122, align 2
  %conv123 = sext i16 %117 to i32
  %call124 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns121, i32 noundef %conv123)
  br label %cond.end126

cond.false125:                                    ; preds = %if.then117
  br label %cond.end126

cond.end126:                                      ; preds = %cond.false125, %cond.true120
  %cond127 = phi ptr [ %call124, %cond.true120 ], [ null, %cond.false125 ]
  store ptr %cond127, ptr %prev_column, align 8
  %118 = load ptr, ptr %prev_column, align 8
  %tobool128 = icmp ne ptr %118, null
  br i1 %tobool128, label %if.then129, label %if.end149

if.then129:                                       ; preds = %cond.end126
  %119 = load ptr, ptr %column, align 8
  %Flags130 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %119, i32 0, i32 0
  %120 = load i32, ptr %Flags130, align 4
  %121 = load ptr, ptr %prev_column, align 8
  %Flags131 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %121, i32 0, i32 0
  %122 = load i32, ptr %Flags131, align 4
  %or = or i32 %120, %122
  %and132 = and i32 %or, 64
  %tobool133 = icmp ne i32 %and132, 0
  br i1 %tobool133, label %if.end148, label %if.then134

if.then134:                                       ; preds = %if.then129
  %123 = load ptr, ptr %column, align 8
  %IndexWithinEnabledSet = getelementptr inbounds %struct.ImGuiTableColumn, ptr %123, i32 0, i32 19
  %124 = load i16, ptr %IndexWithinEnabledSet, align 4
  %conv135 = sext i16 %124 to i32
  %125 = load ptr, ptr %table, align 8
  %FreezeColumnsRequest = getelementptr inbounds %struct.ImGuiTable, ptr %125, i32 0, i32 86
  %126 = load i16, ptr %FreezeColumnsRequest, align 2
  %conv136 = sext i16 %126 to i32
  %cmp137 = icmp slt i32 %conv135, %conv136
  %conv138 = zext i1 %cmp137 to i32
  %127 = load ptr, ptr %prev_column, align 8
  %IndexWithinEnabledSet139 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %127, i32 0, i32 19
  %128 = load i16, ptr %IndexWithinEnabledSet139, align 4
  %conv140 = sext i16 %128 to i32
  %129 = load ptr, ptr %table, align 8
  %FreezeColumnsRequest141 = getelementptr inbounds %struct.ImGuiTable, ptr %129, i32 0, i32 86
  %130 = load i16, ptr %FreezeColumnsRequest141, align 2
  %conv142 = sext i16 %130 to i32
  %cmp143 = icmp slt i32 %conv140, %conv142
  %conv144 = zext i1 %cmp143 to i32
  %cmp145 = icmp eq i32 %conv138, %conv144
  br i1 %cmp145, label %if.then146, label %if.end147

if.then146:                                       ; preds = %if.then134
  %131 = load ptr, ptr %table, align 8
  %ReorderColumnDir = getelementptr inbounds %struct.ImGuiTable, ptr %131, i32 0, i32 78
  store i16 -1, ptr %ReorderColumnDir, align 2
  br label %if.end147

if.end147:                                        ; preds = %if.then146, %if.then134
  br label %if.end148

if.end148:                                        ; preds = %if.end147, %if.then129
  br label %if.end149

if.end149:                                        ; preds = %if.end148, %cond.end126
  br label %if.end150

if.end150:                                        ; preds = %if.end149, %land.lhs.true111, %if.then107
  %132 = load ptr, ptr %g, align 8
  %IO151 = getelementptr inbounds %struct.ImGuiContext, ptr %132, i32 0, i32 2
  %MouseDelta152 = getelementptr inbounds %struct.ImGuiIO, ptr %IO151, i32 0, i32 53
  %x153 = getelementptr inbounds %struct.ImVec2, ptr %MouseDelta152, i32 0, i32 0
  %133 = load float, ptr %x153, align 8
  %cmp154 = fcmp ogt float %133, 0.000000e+00
  br i1 %cmp154, label %land.lhs.true155, label %if.end199

land.lhs.true155:                                 ; preds = %if.end150
  %134 = load ptr, ptr %g, align 8
  %IO156 = getelementptr inbounds %struct.ImGuiContext, ptr %134, i32 0, i32 2
  %MousePos157 = getelementptr inbounds %struct.ImGuiIO, ptr %IO156, i32 0, i32 59
  %x158 = getelementptr inbounds %struct.ImVec2, ptr %MousePos157, i32 0, i32 0
  %135 = load float, ptr %x158, align 8
  %Max159 = getelementptr inbounds %struct.ImRect, ptr %cell_r, i32 0, i32 1
  %x160 = getelementptr inbounds %struct.ImVec2, ptr %Max159, i32 0, i32 0
  %136 = load float, ptr %x160, align 4
  %cmp161 = fcmp ogt float %135, %136
  br i1 %cmp161, label %if.then162, label %if.end199

if.then162:                                       ; preds = %land.lhs.true155
  %137 = load ptr, ptr %column, align 8
  %NextEnabledColumn = getelementptr inbounds %struct.ImGuiTableColumn, ptr %137, i32 0, i32 21
  %138 = load i16, ptr %NextEnabledColumn, align 4
  %conv163 = sext i16 %138 to i32
  %cmp164 = icmp ne i32 %conv163, -1
  br i1 %cmp164, label %cond.true165, label %cond.false170

cond.true165:                                     ; preds = %if.then162
  %139 = load ptr, ptr %table, align 8
  %Columns166 = getelementptr inbounds %struct.ImGuiTable, ptr %139, i32 0, i32 4
  %140 = load ptr, ptr %column, align 8
  %NextEnabledColumn167 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %140, i32 0, i32 21
  %141 = load i16, ptr %NextEnabledColumn167, align 4
  %conv168 = sext i16 %141 to i32
  %call169 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns166, i32 noundef %conv168)
  br label %cond.end171

cond.false170:                                    ; preds = %if.then162
  br label %cond.end171

cond.end171:                                      ; preds = %cond.false170, %cond.true165
  %cond172 = phi ptr [ %call169, %cond.true165 ], [ null, %cond.false170 ]
  store ptr %cond172, ptr %next_column, align 8
  %142 = load ptr, ptr %next_column, align 8
  %tobool173 = icmp ne ptr %142, null
  br i1 %tobool173, label %if.then174, label %if.end198

if.then174:                                       ; preds = %cond.end171
  %143 = load ptr, ptr %column, align 8
  %Flags175 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %143, i32 0, i32 0
  %144 = load i32, ptr %Flags175, align 4
  %145 = load ptr, ptr %next_column, align 8
  %Flags176 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %145, i32 0, i32 0
  %146 = load i32, ptr %Flags176, align 4
  %or177 = or i32 %144, %146
  %and178 = and i32 %or177, 64
  %tobool179 = icmp ne i32 %and178, 0
  br i1 %tobool179, label %if.end197, label %if.then180

if.then180:                                       ; preds = %if.then174
  %147 = load ptr, ptr %column, align 8
  %IndexWithinEnabledSet181 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %147, i32 0, i32 19
  %148 = load i16, ptr %IndexWithinEnabledSet181, align 4
  %conv182 = sext i16 %148 to i32
  %149 = load ptr, ptr %table, align 8
  %FreezeColumnsRequest183 = getelementptr inbounds %struct.ImGuiTable, ptr %149, i32 0, i32 86
  %150 = load i16, ptr %FreezeColumnsRequest183, align 2
  %conv184 = sext i16 %150 to i32
  %cmp185 = icmp slt i32 %conv182, %conv184
  %conv186 = zext i1 %cmp185 to i32
  %151 = load ptr, ptr %next_column, align 8
  %IndexWithinEnabledSet187 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %151, i32 0, i32 19
  %152 = load i16, ptr %IndexWithinEnabledSet187, align 4
  %conv188 = sext i16 %152 to i32
  %153 = load ptr, ptr %table, align 8
  %FreezeColumnsRequest189 = getelementptr inbounds %struct.ImGuiTable, ptr %153, i32 0, i32 86
  %154 = load i16, ptr %FreezeColumnsRequest189, align 2
  %conv190 = sext i16 %154 to i32
  %cmp191 = icmp slt i32 %conv188, %conv190
  %conv192 = zext i1 %cmp191 to i32
  %cmp193 = icmp eq i32 %conv186, %conv192
  br i1 %cmp193, label %if.then194, label %if.end196

if.then194:                                       ; preds = %if.then180
  %155 = load ptr, ptr %table, align 8
  %ReorderColumnDir195 = getelementptr inbounds %struct.ImGuiTable, ptr %155, i32 0, i32 78
  store i16 1, ptr %ReorderColumnDir195, align 2
  br label %if.end196

if.end196:                                        ; preds = %if.then194, %if.then180
  br label %if.end197

if.end197:                                        ; preds = %if.end196, %if.then174
  br label %if.end198

if.end198:                                        ; preds = %if.end197, %cond.end171
  br label %if.end199

if.end199:                                        ; preds = %if.end198, %land.lhs.true155, %if.end150
  br label %if.end200

if.end200:                                        ; preds = %if.end199, %land.lhs.true105, %land.lhs.true103, %land.lhs.true99, %if.end91
  %Max201 = getelementptr inbounds %struct.ImRect, ptr %cell_r, i32 0, i32 1
  %x202 = getelementptr inbounds %struct.ImVec2, ptr %Max201, i32 0, i32 0
  %156 = load float, ptr %x202, align 4
  %157 = load float, ptr %w_arrow, align 4
  %sub = fsub float %156, %157
  %158 = load float, ptr %w_sort_text, align 4
  %sub203 = fsub float %sub, %158
  %x204 = getelementptr inbounds %struct.ImVec2, ptr %label_pos, i32 0, i32 0
  %159 = load float, ptr %x204, align 4
  %call205 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %sub203, float noundef %159)
  store float %call205, ptr %ellipsis_max, align 4
  %160 = load ptr, ptr %table, align 8
  %Flags206 = getelementptr inbounds %struct.ImGuiTable, ptr %160, i32 0, i32 1
  %161 = load i32, ptr %Flags206, align 4
  %and207 = and i32 %161, 8
  %tobool208 = icmp ne i32 %and207, 0
  br i1 %tobool208, label %land.lhs.true209, label %if.end257

land.lhs.true209:                                 ; preds = %if.end200
  %162 = load ptr, ptr %column, align 8
  %Flags210 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %162, i32 0, i32 0
  %163 = load i32, ptr %Flags210, align 4
  %and211 = and i32 %163, 512
  %tobool212 = icmp ne i32 %and211, 0
  br i1 %tobool212, label %if.end257, label %if.then213

if.then213:                                       ; preds = %land.lhs.true209
  %164 = load ptr, ptr %column, align 8
  %SortOrder214 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %164, i32 0, i32 22
  %165 = load i16, ptr %SortOrder214, align 2
  %conv215 = sext i16 %165 to i32
  %cmp216 = icmp ne i32 %conv215, -1
  br i1 %cmp216, label %if.then217, label %if.end246

if.then217:                                       ; preds = %if.then213
  %Min219 = getelementptr inbounds %struct.ImRect, ptr %cell_r, i32 0, i32 0
  %x220 = getelementptr inbounds %struct.ImVec2, ptr %Min219, i32 0, i32 0
  %166 = load float, ptr %x220, align 4
  %Max221 = getelementptr inbounds %struct.ImRect, ptr %cell_r, i32 0, i32 1
  %x222 = getelementptr inbounds %struct.ImVec2, ptr %Max221, i32 0, i32 0
  %167 = load float, ptr %x222, align 4
  %168 = load float, ptr %w_arrow, align 4
  %sub223 = fsub float %167, %168
  %169 = load float, ptr %w_sort_text, align 4
  %sub224 = fsub float %sub223, %169
  %call225 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %166, float noundef %sub224)
  store float %call225, ptr %x218, align 4
  %y227 = getelementptr inbounds %struct.ImVec2, ptr %label_pos, i32 0, i32 1
  %170 = load float, ptr %y227, align 4
  store float %170, ptr %y226, align 4
  %171 = load ptr, ptr %column, align 8
  %SortOrder228 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %171, i32 0, i32 22
  %172 = load i16, ptr %SortOrder228, align 2
  %conv229 = sext i16 %172 to i32
  %cmp230 = icmp sgt i32 %conv229, 0
  br i1 %cmp230, label %if.then231, label %if.end239

if.then231:                                       ; preds = %if.then217
  %call232 = call noundef i32 @_ZN5ImGui11GetColorU32Eif(i32 noundef 0, float noundef 0x3FE6666660000000)
  call void @_ZN5ImGui14PushStyleColorEij(i32 noundef 0, i32 noundef %call232)
  %173 = load float, ptr %x218, align 4
  %174 = load ptr, ptr %g, align 8
  %Style233 = getelementptr inbounds %struct.ImGuiContext, ptr %174, i32 0, i32 3
  %ItemInnerSpacing234 = getelementptr inbounds %struct.ImGuiStyle, ptr %Style233, i32 0, i32 16
  %x235 = getelementptr inbounds %struct.ImVec2, ptr %ItemInnerSpacing234, i32 0, i32 0
  %175 = load float, ptr %x235, align 4
  %add236 = fadd float %173, %175
  %176 = load float, ptr %y226, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %agg.tmp, float noundef %add236, float noundef %176)
  %arraydecay237 = getelementptr inbounds [4 x i8], ptr %sort_order_suf, i64 0, i64 0
  %177 = load <2 x float>, ptr %agg.tmp, align 4
  call void @_ZN5ImGui10RenderTextE6ImVec2PKcS2_b(<2 x float> %177, ptr noundef %arraydecay237, ptr noundef null, i1 noundef zeroext true)
  call void @_ZN5ImGui13PopStyleColorEi(i32 noundef 1)
  %178 = load float, ptr %w_sort_text, align 4
  %179 = load float, ptr %x218, align 4
  %add238 = fadd float %179, %178
  store float %add238, ptr %x218, align 4
  br label %if.end239

if.end239:                                        ; preds = %if.then231, %if.then217
  %180 = load ptr, ptr %window, align 8
  %DrawList = getelementptr inbounds %struct.ImGuiWindow, ptr %180, i32 0, i32 86
  %181 = load ptr, ptr %DrawList, align 8
  %182 = load float, ptr %x218, align 4
  %183 = load float, ptr %y226, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %agg.tmp240, float noundef %182, float noundef %183)
  %call241 = call noundef i32 @_ZN5ImGui11GetColorU32Eif(i32 noundef 0, float noundef 1.000000e+00)
  %184 = load ptr, ptr %column, align 8
  %SortDirection = getelementptr inbounds %struct.ImGuiTableColumn, ptr %184, i32 0, i32 37
  %bf.load242 = load i8, ptr %SortDirection, align 1
  %bf.clear = and i8 %bf.load242, 3
  %conv243 = zext i8 %bf.clear to i32
  %cmp244 = icmp eq i32 %conv243, 1
  %cond245 = select i1 %cmp244, i32 2, i32 3
  %185 = load <2 x float>, ptr %agg.tmp240, align 4
  call void @_ZN5ImGui11RenderArrowEP10ImDrawList6ImVec2jif(ptr noundef %181, <2 x float> %185, i32 noundef %call241, i32 noundef %cond245, float noundef 0x3FE4CCCCC0000000)
  br label %if.end246

if.end246:                                        ; preds = %if.end239, %if.then213
  %186 = load i8, ptr %pressed, align 1
  %tobool247 = trunc i8 %186 to i1
  br i1 %tobool247, label %land.lhs.true248, label %if.end256

land.lhs.true248:                                 ; preds = %if.end246
  %187 = load ptr, ptr %table, align 8
  %ReorderColumn249 = getelementptr inbounds %struct.ImGuiTable, ptr %187, i32 0, i32 77
  %188 = load i16, ptr %ReorderColumn249, align 8
  %conv250 = sext i16 %188 to i32
  %189 = load i32, ptr %column_n, align 4
  %cmp251 = icmp ne i32 %conv250, %189
  br i1 %cmp251, label %if.then252, label %if.end256

if.then252:                                       ; preds = %land.lhs.true248
  %190 = load ptr, ptr %column, align 8
  %call253 = call noundef i32 @_ZN5ImGui31TableGetColumnNextSortDirectionEP16ImGuiTableColumn(ptr noundef %190)
  store i32 %call253, ptr %sort_direction, align 4
  %191 = load i32, ptr %column_n, align 4
  %192 = load i32, ptr %sort_direction, align 4
  %193 = load ptr, ptr %g, align 8
  %IO254 = getelementptr inbounds %struct.ImGuiContext, ptr %193, i32 0, i32 2
  %KeyShift = getelementptr inbounds %struct.ImGuiIO, ptr %IO254, i32 0, i32 65
  %194 = load i8, ptr %KeyShift, align 1
  %tobool255 = trunc i8 %194 to i1
  call void @_ZN5ImGui27TableSetColumnSortDirectionEiib(i32 noundef %191, i32 noundef %192, i1 noundef zeroext %tobool255)
  br label %if.end256

if.end256:                                        ; preds = %if.then252, %land.lhs.true248, %if.end246
  br label %if.end257

if.end257:                                        ; preds = %if.end256, %land.lhs.true209, %if.end200
  %195 = load ptr, ptr %window, align 8
  %DrawList258 = getelementptr inbounds %struct.ImGuiWindow, ptr %195, i32 0, i32 86
  %196 = load ptr, ptr %DrawList258, align 8
  %197 = load float, ptr %ellipsis_max, align 4
  %y260 = getelementptr inbounds %struct.ImVec2, ptr %label_pos, i32 0, i32 1
  %198 = load float, ptr %y260, align 4
  %199 = load float, ptr %label_height, align 4
  %add261 = fadd float %198, %199
  %200 = load ptr, ptr %g, align 8
  %Style262 = getelementptr inbounds %struct.ImGuiContext, ptr %200, i32 0, i32 3
  %FramePadding263 = getelementptr inbounds %struct.ImGuiStyle, ptr %Style262, i32 0, i32 12
  %y264 = getelementptr inbounds %struct.ImVec2, ptr %FramePadding263, i32 0, i32 1
  %201 = load float, ptr %y264, align 4
  %add265 = fadd float %add261, %201
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp259, float noundef %197, float noundef %add265)
  %202 = load float, ptr %ellipsis_max, align 4
  %203 = load float, ptr %ellipsis_max, align 4
  %204 = load ptr, ptr %label.addr, align 8
  %205 = load ptr, ptr %label_end, align 8
  call void @_ZN5ImGui18RenderTextEllipsisEP10ImDrawListRK6ImVec2S4_ffPKcS6_PS3_(ptr noundef %196, ptr noundef nonnull align 4 dereferenceable(8) %label_pos, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp259, float noundef %202, float noundef %203, ptr noundef %204, ptr noundef %205, ptr noundef %label_size)
  %x266 = getelementptr inbounds %struct.ImVec2, ptr %label_size, i32 0, i32 0
  %206 = load float, ptr %x266, align 4
  %207 = load float, ptr %ellipsis_max, align 4
  %x267 = getelementptr inbounds %struct.ImVec2, ptr %label_pos, i32 0, i32 0
  %208 = load float, ptr %x267, align 4
  %sub268 = fsub float %207, %208
  %cmp269 = fcmp ogt float %206, %sub268
  %frombool270 = zext i1 %cmp269 to i8
  store i8 %frombool270, ptr %text_clipped, align 1
  %209 = load i8, ptr %text_clipped, align 1
  %tobool271 = trunc i8 %209 to i1
  br i1 %tobool271, label %land.lhs.true272, label %if.end278

land.lhs.true272:                                 ; preds = %if.end257
  %210 = load i8, ptr %hovered, align 1
  %tobool273 = trunc i8 %210 to i1
  br i1 %tobool273, label %land.lhs.true274, label %if.end278

land.lhs.true274:                                 ; preds = %land.lhs.true272
  %211 = load ptr, ptr %g, align 8
  %ActiveId = getelementptr inbounds %struct.ImGuiContext, ptr %211, i32 0, i32 47
  %212 = load i32, ptr %ActiveId, align 4
  %cmp275 = icmp eq i32 %212, 0
  br i1 %cmp275, label %if.then276, label %if.end278

if.then276:                                       ; preds = %land.lhs.true274
  %213 = load ptr, ptr %label_end, align 8
  %214 = load ptr, ptr %label.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %213 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %214 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv277 = trunc i64 %sub.ptr.sub to i32
  %215 = load ptr, ptr %label.addr, align 8
  call void (ptr, ...) @_ZN5ImGui14SetItemTooltipEPKcz(ptr noundef @.str.4, i32 noundef %conv277, ptr noundef %215)
  br label %if.end278

if.end278:                                        ; preds = %if.then276, %land.lhs.true274, %land.lhs.true272, %if.end257
  %call279 = call noundef zeroext i1 @_ZN5ImGui15IsMouseReleasedEi(i32 noundef 1)
  br i1 %call279, label %land.lhs.true280, label %if.end283

land.lhs.true280:                                 ; preds = %if.end278
  %call281 = call noundef zeroext i1 @_ZN5ImGui13IsItemHoveredEi(i32 noundef 0)
  br i1 %call281, label %if.then282, label %if.end283

if.then282:                                       ; preds = %land.lhs.true280
  %216 = load i32, ptr %column_n, align 4
  call void @_ZN5ImGui20TableOpenContextMenuEi(i32 noundef %216)
  br label %if.end283

if.end283:                                        ; preds = %if.then282, %land.lhs.true280, %if.end278, %if.then61, %if.then
  ret void
}

declare <2 x float> @_ZN5ImGui11GetMousePosEv() #1

declare noundef ptr @_ZN5ImGui19FindRenderedTextEndEPKcS1_(ptr noundef, ptr noundef) #1

declare noundef i32 @_Z14ImFormatStringPcmPKcz(ptr noundef, i64 noundef, ptr noundef, ...) #1

declare noundef i32 @_ZN11ImGuiWindow5GetIDEPKcS1_(ptr noundef nonnull align 8 dereferenceable(1013), ptr noundef, ptr noundef) #1

declare void @_ZN5ImGui18RenderNavHighlightERK6ImRectji(ptr noundef nonnull align 4 dereferenceable(16), i32 noundef, i32 noundef) #1

declare noundef zeroext i1 @_ZN5ImGui15IsMouseDraggingEif(i32 noundef, float noundef) #1

declare void @_ZN5ImGui14PushStyleColorEij(i32 noundef, i32 noundef) #1

declare void @_ZN5ImGui10RenderTextE6ImVec2PKcS2_b(<2 x float>, ptr noundef, ptr noundef, i1 noundef zeroext) #1

declare void @_ZN5ImGui13PopStyleColorEi(i32 noundef) #1

declare void @_ZN5ImGui11RenderArrowEP10ImDrawList6ImVec2jif(ptr noundef, <2 x float>, i32 noundef, i32 noundef, float noundef) #1

declare void @_ZN5ImGui18RenderTextEllipsisEP10ImDrawListRK6ImVec2S4_ffPKcS6_PS3_(ptr noundef, ptr noundef nonnull align 4 dereferenceable(8), ptr noundef nonnull align 4 dereferenceable(8), float noundef, float noundef, ptr noundef, ptr noundef, ptr noundef) #1

declare void @_ZN5ImGui14SetItemTooltipEPKcz(ptr noundef, ...) #1

declare noundef zeroext i1 @_ZN5ImGui13IsItemHoveredEi(i32 noundef) #1

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui21TableAngledHeadersRowEv() #0 {
entry:
  %g = alloca ptr, align 8
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %g, align 8
  %Style = getelementptr inbounds %struct.ImGuiContext, ptr %1, i32 0, i32 3
  %TableAngledHeadersAngle = getelementptr inbounds %struct.ImGuiStyle, ptr %Style, i32 0, i32 30
  %2 = load float, ptr %TableAngledHeadersAngle, align 8
  call void @_ZN5ImGui23TableAngledHeadersRowExEff(float noundef %2, float noundef 0.000000e+00)
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui23TableAngledHeadersRowExEff(float noundef %angle, float noundef %max_label_width) #2 {
entry:
  %angle.addr = alloca float, align 4
  %max_label_width.addr = alloca float, align 4
  %g = alloca ptr, align 8
  %table = alloca ptr, align 8
  %window = alloca ptr, align 8
  %draw_list = alloca ptr, align 8
  %flip_label = alloca i8, align 1
  %cos_a = alloca float, align 4
  %sin_a = alloca float, align 4
  %label_cos_a = alloca float, align 4
  %label_sin_a = alloca float, align 4
  %unit_right = alloca %struct.ImVec2, align 4
  %header_height = alloca float, align 4
  %row_height = alloca float, align 4
  %ref.tmp = alloca %struct.ImVec2, align 4
  %ref.tmp12 = alloca %struct.ImVec2, align 4
  %header_angled_vector = alloca %struct.ImVec2, align 4
  %clip_rect_min_x = alloca float, align 4
  %ref.tmp44 = alloca %struct.ImVec2, align 4
  %row_r = alloca %struct.ImRect, align 4
  %row_id = alloca i32, align 4
  %table_instance = alloca ptr, align 8
  %highlight_column_n = alloca i32, align 4
  %max_x = alloca float, align 4
  %pass = alloca i32, align 4
  %order_n = alloca i32, align 4
  %column_n = alloca i32, align 4
  %column = alloca ptr, align 8
  %bg_shape = alloca [4 x %struct.ImVec2], align 16
  %ref.tmp102 = alloca %struct.ImVec2, align 4
  %ref.tmp107 = alloca %struct.ImVec2, align 4
  %ref.tmp111 = alloca %struct.ImVec2, align 4
  %ref.tmp115 = alloca %struct.ImVec2, align 4
  %label_name = alloca ptr, align 8
  %clip_width = alloca float, align 4
  %label_r = alloca %struct.ImRect, align 4
  %ref.tmp140 = alloca %struct.ImVec2, align 4
  %ref.tmp143 = alloca %struct.ImVec2, align 4
  %label_size = alloca %struct.ImVec2, align 4
  %label_off = alloca %struct.ImVec2, align 4
  %vtx_idx_begin = alloca i32, align 4
  %ref.tmp166 = alloca %struct.ImVec2, align 4
  %vtx_idx_end = alloca i32, align 4
  %pivot_in = alloca %struct.ImVec2, align 4
  %pivot_out = alloca %struct.ImVec2, align 4
  %ref.tmp176 = alloca %struct.ImVec2, align 4
  %ref.tmp179 = alloca %struct.ImVec2, align 4
  store float %angle, ptr %angle.addr, align 4
  store float %max_label_width, ptr %max_label_width.addr, align 4
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %g, align 8
  %CurrentTable = getelementptr inbounds %struct.ImGuiContext, ptr %1, i32 0, i32 164
  %2 = load ptr, ptr %CurrentTable, align 8
  store ptr %2, ptr %table, align 8
  %3 = load ptr, ptr %g, align 8
  %CurrentWindow = getelementptr inbounds %struct.ImGuiContext, ptr %3, i32 0, i32 29
  %4 = load ptr, ptr %CurrentWindow, align 8
  store ptr %4, ptr %window, align 8
  %5 = load ptr, ptr %window, align 8
  %DrawList = getelementptr inbounds %struct.ImGuiWindow, ptr %5, i32 0, i32 86
  %6 = load ptr, ptr %DrawList, align 8
  store ptr %6, ptr %draw_list, align 8
  %7 = load float, ptr %max_label_width.addr, align 4
  %cmp = fcmp oeq float %7, 0.000000e+00
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call noundef float @_ZN5ImGui33TableGetHeaderAngledMaxLabelWidthEv()
  store float %call, ptr %max_label_width.addr, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %8 = load float, ptr %angle.addr, align 4
  %cmp1 = fcmp olt float %8, 0.000000e+00
  %frombool = zext i1 %cmp1 to i8
  store i8 %frombool, ptr %flip_label, align 1
  %9 = load float, ptr %angle.addr, align 4
  %sub = fsub float %9, 0x3FF921FB60000000
  store float %sub, ptr %angle.addr, align 4
  %10 = load float, ptr %angle.addr, align 4
  %call2 = call float @cosf(float noundef %10) #10
  store float %call2, ptr %cos_a, align 4
  %11 = load float, ptr %angle.addr, align 4
  %call3 = call float @sinf(float noundef %11) #10
  store float %call3, ptr %sin_a, align 4
  %12 = load i8, ptr %flip_label, align 1
  %tobool = trunc i8 %12 to i1
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %13 = load float, ptr %angle.addr, align 4
  %add = fadd float %13, 0x400921FB60000000
  %call4 = call float @cosf(float noundef %add) #10
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %14 = load float, ptr %cos_a, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi float [ %call4, %cond.true ], [ %14, %cond.false ]
  store float %cond, ptr %label_cos_a, align 4
  %15 = load i8, ptr %flip_label, align 1
  %tobool5 = trunc i8 %15 to i1
  br i1 %tobool5, label %cond.true6, label %cond.false9

cond.true6:                                       ; preds = %cond.end
  %16 = load float, ptr %angle.addr, align 4
  %add7 = fadd float %16, 0x400921FB60000000
  %call8 = call float @sinf(float noundef %add7) #10
  br label %cond.end10

cond.false9:                                      ; preds = %cond.end
  %17 = load float, ptr %sin_a, align 4
  br label %cond.end10

cond.end10:                                       ; preds = %cond.false9, %cond.true6
  %cond11 = phi float [ %call8, %cond.true6 ], [ %17, %cond.false9 ]
  store float %cond11, ptr %label_sin_a, align 4
  %18 = load float, ptr %cos_a, align 4
  %19 = load float, ptr %sin_a, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %unit_right, float noundef %18, float noundef %19)
  %20 = load ptr, ptr %table, align 8
  %RowCellPaddingY = getelementptr inbounds %struct.ImGuiTable, ptr %20, i32 0, i32 21
  %21 = load float, ptr %RowCellPaddingY, align 8
  %22 = load ptr, ptr %g, align 8
  %FontSize = getelementptr inbounds %struct.ImGuiContext, ptr %22, i32 0, i32 5
  %23 = load float, ptr %FontSize, align 8
  %24 = call float @llvm.fmuladd.f32(float %21, float 2.000000e+00, float %23)
  store float %24, ptr %header_height, align 4
  %25 = load float, ptr %max_label_width.addr, align 4
  %26 = load i8, ptr %flip_label, align 1
  %tobool13 = trunc i8 %26 to i1
  br i1 %tobool13, label %cond.true14, label %cond.false15

cond.true14:                                      ; preds = %cond.end10
  %27 = load float, ptr %header_height, align 4
  br label %cond.end16

cond.false15:                                     ; preds = %cond.end10
  %28 = load float, ptr %header_height, align 4
  %fneg = fneg float %28
  br label %cond.end16

cond.end16:                                       ; preds = %cond.false15, %cond.true14
  %cond17 = phi float [ %27, %cond.true14 ], [ %fneg, %cond.false15 ]
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp12, float noundef %25, float noundef %cond17)
  %29 = load float, ptr %cos_a, align 4
  %30 = load float, ptr %sin_a, align 4
  %call18 = call <2 x float> @_ZL8ImRotateRK6ImVec2ff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp12, float noundef %29, float noundef %30)
  store <2 x float> %call18, ptr %ref.tmp, align 4
  %y = getelementptr inbounds %struct.ImVec2, ptr %ref.tmp, i32 0, i32 1
  %31 = load float, ptr %y, align 4
  %32 = call float @llvm.fabs.f32(float %31)
  store float %32, ptr %row_height, align 4
  %33 = load float, ptr %row_height, align 4
  %34 = load float, ptr %sin_a, align 4
  %fneg19 = fneg float %34
  %div = fdiv float %33, %fneg19
  %call20 = call <2 x float> @_ZmlRK6ImVec2f(ptr noundef nonnull align 4 dereferenceable(8) %unit_right, float noundef %div)
  store <2 x float> %call20, ptr %header_angled_vector, align 4
  %35 = load float, ptr %row_height, align 4
  %36 = load ptr, ptr %table, align 8
  %AngledHeadersHeight = getelementptr inbounds %struct.ImGuiTable, ptr %36, i32 0, i32 44
  store float %35, ptr %AngledHeadersHeight, align 8
  %37 = load float, ptr %sin_a, align 4
  %cmp21 = fcmp une float %37, 0.000000e+00
  br i1 %cmp21, label %cond.true22, label %cond.false24

cond.true22:                                      ; preds = %cond.end16
  %38 = load float, ptr %cos_a, align 4
  %39 = load float, ptr %sin_a, align 4
  %div23 = fdiv float %38, %39
  br label %cond.end25

cond.false24:                                     ; preds = %cond.end16
  br label %cond.end25

cond.end25:                                       ; preds = %cond.false24, %cond.true22
  %cond26 = phi float [ %div23, %cond.true22 ], [ 0.000000e+00, %cond.false24 ]
  %40 = load ptr, ptr %table, align 8
  %AngledHeadersSlope = getelementptr inbounds %struct.ImGuiTable, ptr %40, i32 0, i32 45
  store float %cond26, ptr %AngledHeadersSlope, align 4
  %41 = load float, ptr %row_height, align 4
  call void @_ZN5ImGui12TableNextRowEif(i32 noundef 1, float noundef %41)
  %call27 = call noundef zeroext i1 @_ZN5ImGui15TableNextColumnEv()
  %42 = load ptr, ptr %table, align 8
  %DrawSplitter = getelementptr inbounds %struct.ImGuiTable, ptr %42, i32 0, i32 58
  %43 = load ptr, ptr %DrawSplitter, align 8
  %44 = load ptr, ptr %draw_list, align 8
  call void @_ZN18ImDrawListSplitter17SetCurrentChannelEP10ImDrawListi(ptr noundef nonnull align 8 dereferenceable(24) %43, ptr noundef %44, i32 noundef 0)
  %45 = load ptr, ptr %table, align 8
  %BgClipRect = getelementptr inbounds %struct.ImGuiTable, ptr %45, i32 0, i32 50
  %Min = getelementptr inbounds %struct.ImRect, ptr %BgClipRect, i32 0, i32 0
  %x = getelementptr inbounds %struct.ImVec2, ptr %Min, i32 0, i32 0
  %46 = load float, ptr %x, align 8
  store float %46, ptr %clip_rect_min_x, align 4
  %47 = load ptr, ptr %table, align 8
  %FreezeColumnsCount = getelementptr inbounds %struct.ImGuiTable, ptr %47, i32 0, i32 87
  %48 = load i16, ptr %FreezeColumnsCount, align 4
  %conv = sext i16 %48 to i32
  %cmp28 = icmp sgt i32 %conv, 0
  br i1 %cmp28, label %if.then29, label %if.end35

if.then29:                                        ; preds = %cond.end25
  %49 = load float, ptr %clip_rect_min_x, align 4
  %50 = load ptr, ptr %table, align 8
  %Columns = getelementptr inbounds %struct.ImGuiTable, ptr %50, i32 0, i32 4
  %51 = load ptr, ptr %table, align 8
  %FreezeColumnsCount30 = getelementptr inbounds %struct.ImGuiTable, ptr %51, i32 0, i32 87
  %52 = load i16, ptr %FreezeColumnsCount30, align 4
  %conv31 = sext i16 %52 to i32
  %sub32 = sub nsw i32 %conv31, 1
  %call33 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns, i32 noundef %sub32)
  %MaxX = getelementptr inbounds %struct.ImGuiTableColumn, ptr %call33, i32 0, i32 3
  %53 = load float, ptr %MaxX, align 4
  %call34 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %49, float noundef %53)
  store float %call34, ptr %clip_rect_min_x, align 4
  br label %if.end35

if.end35:                                         ; preds = %if.then29, %cond.end25
  call void @_ZN5ImGui15TableSetBgColorEiji(i32 noundef 1, i32 noundef 0, i32 noundef -1)
  %54 = load ptr, ptr %table, align 8
  %BgClipRect36 = getelementptr inbounds %struct.ImGuiTable, ptr %54, i32 0, i32 50
  %Min37 = getelementptr inbounds %struct.ImRect, ptr %BgClipRect36, i32 0, i32 0
  %55 = load ptr, ptr %table, align 8
  %BgClipRect38 = getelementptr inbounds %struct.ImGuiTable, ptr %55, i32 0, i32 50
  %Max = getelementptr inbounds %struct.ImRect, ptr %BgClipRect38, i32 0, i32 1
  call void @_ZN5ImGui12PushClipRectERK6ImVec2S2_b(ptr noundef nonnull align 4 dereferenceable(8) %Min37, ptr noundef nonnull align 4 dereferenceable(8) %Max, i1 noundef zeroext false)
  %56 = load ptr, ptr %draw_list, align 8
  %57 = load ptr, ptr %table, align 8
  %BgClipRect39 = getelementptr inbounds %struct.ImGuiTable, ptr %57, i32 0, i32 50
  %Min40 = getelementptr inbounds %struct.ImRect, ptr %BgClipRect39, i32 0, i32 0
  %58 = load ptr, ptr %table, align 8
  %BgClipRect41 = getelementptr inbounds %struct.ImGuiTable, ptr %58, i32 0, i32 50
  %Max42 = getelementptr inbounds %struct.ImRect, ptr %BgClipRect41, i32 0, i32 1
  %call43 = call noundef i32 @_ZN5ImGui11GetColorU32Eif(i32 noundef 42, float noundef 2.500000e-01)
  call void @_ZN10ImDrawList13AddRectFilledERK6ImVec2S2_jfi(ptr noundef nonnull align 8 dereferenceable(196) %56, ptr noundef nonnull align 4 dereferenceable(8) %Min40, ptr noundef nonnull align 4 dereferenceable(8) %Max42, i32 noundef %call43, float noundef 0.000000e+00, i32 noundef 0)
  %59 = load float, ptr %clip_rect_min_x, align 4
  %60 = load ptr, ptr %table, align 8
  %BgClipRect45 = getelementptr inbounds %struct.ImGuiTable, ptr %60, i32 0, i32 50
  %Min46 = getelementptr inbounds %struct.ImRect, ptr %BgClipRect45, i32 0, i32 0
  %y47 = getelementptr inbounds %struct.ImVec2, ptr %Min46, i32 0, i32 1
  %61 = load float, ptr %y47, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp44, float noundef %59, float noundef %61)
  %62 = load ptr, ptr %table, align 8
  %BgClipRect48 = getelementptr inbounds %struct.ImGuiTable, ptr %62, i32 0, i32 50
  %Max49 = getelementptr inbounds %struct.ImRect, ptr %BgClipRect48, i32 0, i32 1
  call void @_ZN5ImGui12PushClipRectERK6ImVec2S2_b(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp44, ptr noundef nonnull align 4 dereferenceable(8) %Max49, i1 noundef zeroext true)
  %63 = load ptr, ptr %table, align 8
  %WorkRect = getelementptr inbounds %struct.ImGuiTable, ptr %63, i32 0, i32 48
  %Min50 = getelementptr inbounds %struct.ImRect, ptr %WorkRect, i32 0, i32 0
  %x51 = getelementptr inbounds %struct.ImVec2, ptr %Min50, i32 0, i32 0
  %64 = load float, ptr %x51, align 8
  %65 = load ptr, ptr %table, align 8
  %BgClipRect52 = getelementptr inbounds %struct.ImGuiTable, ptr %65, i32 0, i32 50
  %Min53 = getelementptr inbounds %struct.ImRect, ptr %BgClipRect52, i32 0, i32 0
  %y54 = getelementptr inbounds %struct.ImVec2, ptr %Min53, i32 0, i32 1
  %66 = load float, ptr %y54, align 4
  %67 = load ptr, ptr %table, align 8
  %WorkRect55 = getelementptr inbounds %struct.ImGuiTable, ptr %67, i32 0, i32 48
  %Max56 = getelementptr inbounds %struct.ImRect, ptr %WorkRect55, i32 0, i32 1
  %x57 = getelementptr inbounds %struct.ImVec2, ptr %Max56, i32 0, i32 0
  %68 = load float, ptr %x57, align 8
  %69 = load ptr, ptr %window, align 8
  %DC = getelementptr inbounds %struct.ImGuiWindow, ptr %69, i32 0, i32 68
  %CursorPos = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC, i32 0, i32 0
  %y58 = getelementptr inbounds %struct.ImVec2, ptr %CursorPos, i32 0, i32 1
  %70 = load float, ptr %y58, align 4
  %71 = load float, ptr %row_height, align 4
  %add59 = fadd float %70, %71
  call void @_ZN6ImRectC2Effff(ptr noundef nonnull align 4 dereferenceable(16) %row_r, float noundef %64, float noundef %66, float noundef %68, float noundef %add59)
  %call60 = call noundef i32 @_ZN5ImGui5GetIDEPKc(ptr noundef @.str.5)
  store i32 %call60, ptr %row_id, align 4
  %72 = load i32, ptr %row_id, align 4
  %call61 = call noundef zeroext i1 @_ZN5ImGui14ButtonBehaviorERK6ImRectjPbS3_i(ptr noundef nonnull align 4 dereferenceable(16) %row_r, i32 noundef %72, ptr noundef null, ptr noundef null, i32 noundef 0)
  %73 = load i32, ptr %row_id, align 4
  call void @_ZN5ImGui11KeepAliveIDEj(i32 noundef %73)
  %74 = load ptr, ptr %table, align 8
  %75 = load ptr, ptr %table, align 8
  %InstanceCurrent = getelementptr inbounds %struct.ImGuiTable, ptr %75, i32 0, i32 16
  %76 = load i16, ptr %InstanceCurrent, align 8
  %conv62 = sext i16 %76 to i32
  %call63 = call noundef ptr @_ZN5ImGui20TableGetInstanceDataEP10ImGuiTablei(ptr noundef %74, i32 noundef %conv62)
  store ptr %call63, ptr %table_instance, align 8
  %77 = load ptr, ptr %table, align 8
  %HighlightColumnHeader = getelementptr inbounds %struct.ImGuiTable, ptr %77, i32 0, i32 72
  %78 = load i16, ptr %HighlightColumnHeader, align 2
  %conv64 = sext i16 %78 to i32
  store i32 %conv64, ptr %highlight_column_n, align 4
  %79 = load i32, ptr %highlight_column_n, align 4
  %cmp65 = icmp eq i32 %79, -1
  br i1 %cmp65, label %land.lhs.true, label %if.end85

land.lhs.true:                                    ; preds = %if.end35
  %80 = load ptr, ptr %table, align 8
  %HoveredColumnBody = getelementptr inbounds %struct.ImGuiTable, ptr %80, i32 0, i32 70
  %81 = load i16, ptr %HoveredColumnBody, align 2
  %conv66 = sext i16 %81 to i32
  %cmp67 = icmp ne i32 %conv66, -1
  br i1 %cmp67, label %if.then68, label %if.end85

if.then68:                                        ; preds = %land.lhs.true
  %82 = load ptr, ptr %table_instance, align 8
  %HoveredRowLast = getelementptr inbounds %struct.ImGuiTableInstanceData, ptr %82, i32 0, i32 4
  %83 = load i32, ptr %HoveredRowLast, align 4
  %cmp69 = icmp eq i32 %83, 0
  br i1 %cmp69, label %land.lhs.true70, label %if.end84

land.lhs.true70:                                  ; preds = %if.then68
  %84 = load ptr, ptr %table, align 8
  %HoveredColumnBorder = getelementptr inbounds %struct.ImGuiTable, ptr %84, i32 0, i32 71
  %85 = load i16, ptr %HoveredColumnBorder, align 4
  %conv71 = sext i16 %85 to i32
  %cmp72 = icmp eq i32 %conv71, -1
  br i1 %cmp72, label %land.lhs.true73, label %if.end84

land.lhs.true73:                                  ; preds = %land.lhs.true70
  %86 = load ptr, ptr %g, align 8
  %ActiveId = getelementptr inbounds %struct.ImGuiContext, ptr %86, i32 0, i32 47
  %87 = load i32, ptr %ActiveId, align 4
  %cmp74 = icmp eq i32 %87, 0
  br i1 %cmp74, label %if.then81, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true73
  %88 = load ptr, ptr %g, align 8
  %ActiveId75 = getelementptr inbounds %struct.ImGuiContext, ptr %88, i32 0, i32 47
  %89 = load i32, ptr %ActiveId75, align 4
  %90 = load i32, ptr %row_id, align 4
  %cmp76 = icmp eq i32 %89, %90
  br i1 %cmp76, label %if.then81, label %lor.lhs.false77

lor.lhs.false77:                                  ; preds = %lor.lhs.false
  %91 = load ptr, ptr %table, align 8
  %IsActiveIdInTable = getelementptr inbounds %struct.ImGuiTable, ptr %91, i32 0, i32 107
  %92 = load i8, ptr %IsActiveIdInTable, align 1
  %tobool78 = trunc i8 %92 to i1
  br i1 %tobool78, label %if.then81, label %lor.lhs.false79

lor.lhs.false79:                                  ; preds = %lor.lhs.false77
  %93 = load ptr, ptr %g, align 8
  %DragDropActive = getelementptr inbounds %struct.ImGuiContext, ptr %93, i32 0, i32 144
  %94 = load i8, ptr %DragDropActive, align 8
  %tobool80 = trunc i8 %94 to i1
  br i1 %tobool80, label %if.then81, label %if.end84

if.then81:                                        ; preds = %lor.lhs.false79, %lor.lhs.false77, %lor.lhs.false, %land.lhs.true73
  %95 = load ptr, ptr %table, align 8
  %HoveredColumnBody82 = getelementptr inbounds %struct.ImGuiTable, ptr %95, i32 0, i32 70
  %96 = load i16, ptr %HoveredColumnBody82, align 2
  %conv83 = sext i16 %96 to i32
  store i32 %conv83, ptr %highlight_column_n, align 4
  br label %if.end84

if.end84:                                         ; preds = %if.then81, %lor.lhs.false79, %land.lhs.true70, %if.then68
  br label %if.end85

if.end85:                                         ; preds = %if.end84, %land.lhs.true, %if.end35
  store float 0.000000e+00, ptr %max_x, align 4
  store i32 0, ptr %pass, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc193, %if.end85
  %97 = load i32, ptr %pass, align 4
  %cmp86 = icmp slt i32 %97, 2
  br i1 %cmp86, label %for.body, label %for.end195

for.body:                                         ; preds = %for.cond
  store i32 0, ptr %order_n, align 4
  br label %for.cond87

for.cond87:                                       ; preds = %for.inc, %for.body
  %98 = load i32, ptr %order_n, align 4
  %99 = load ptr, ptr %table, align 8
  %ColumnsCount = getelementptr inbounds %struct.ImGuiTable, ptr %99, i32 0, i32 13
  %100 = load i32, ptr %ColumnsCount, align 4
  %cmp88 = icmp slt i32 %98, %100
  br i1 %cmp88, label %for.body89, label %for.end

for.body89:                                       ; preds = %for.cond87
  %101 = load ptr, ptr %table, align 8
  %EnabledMaskByDisplayOrder = getelementptr inbounds %struct.ImGuiTable, ptr %101, i32 0, i32 7
  %102 = load ptr, ptr %EnabledMaskByDisplayOrder, align 8
  %103 = load i32, ptr %order_n, align 4
  %shr = ashr i32 %103, 5
  %idxprom = sext i32 %shr to i64
  %arrayidx = getelementptr inbounds i32, ptr %102, i64 %idxprom
  %104 = load i32, ptr %arrayidx, align 4
  %105 = load i32, ptr %order_n, align 4
  %and = and i32 %105, 31
  %shl = shl i32 1, %and
  %and90 = and i32 %104, %shl
  %cmp91 = icmp ne i32 %and90, 0
  br i1 %cmp91, label %if.end93, label %if.then92

if.then92:                                        ; preds = %for.body89
  br label %for.inc

if.end93:                                         ; preds = %for.body89
  %106 = load ptr, ptr %table, align 8
  %DisplayOrderToIndex = getelementptr inbounds %struct.ImGuiTable, ptr %106, i32 0, i32 5
  %107 = load i32, ptr %order_n, align 4
  %call94 = call noundef nonnull align 2 dereferenceable(2) ptr @_ZN6ImSpanIsEixEi(ptr noundef nonnull align 8 dereferenceable(16) %DisplayOrderToIndex, i32 noundef %107)
  %108 = load i16, ptr %call94, align 2
  %conv95 = sext i16 %108 to i32
  store i32 %conv95, ptr %column_n, align 4
  %109 = load ptr, ptr %table, align 8
  %Columns96 = getelementptr inbounds %struct.ImGuiTable, ptr %109, i32 0, i32 4
  %110 = load i32, ptr %column_n, align 4
  %call97 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns96, i32 noundef %110)
  store ptr %call97, ptr %column, align 8
  %111 = load ptr, ptr %column, align 8
  %Flags = getelementptr inbounds %struct.ImGuiTableColumn, ptr %111, i32 0, i32 0
  %112 = load i32, ptr %Flags, align 4
  %and98 = and i32 %112, 262144
  %cmp99 = icmp eq i32 %and98, 0
  br i1 %cmp99, label %if.then100, label %if.end101

if.then100:                                       ; preds = %if.end93
  br label %for.inc

if.end101:                                        ; preds = %if.end93
  %array.begin = getelementptr inbounds [4 x %struct.ImVec2], ptr %bg_shape, i32 0, i32 0
  %arrayctor.end = getelementptr inbounds %struct.ImVec2, ptr %array.begin, i64 4
  br label %arrayctor.loop

arrayctor.loop:                                   ; preds = %arrayctor.loop, %if.end101
  %arrayctor.cur = phi ptr [ %array.begin, %if.end101 ], [ %arrayctor.next, %arrayctor.loop ]
  call void @_ZN6ImVec2C2Ev(ptr noundef nonnull align 4 dereferenceable(8) %arrayctor.cur)
  %arrayctor.next = getelementptr inbounds %struct.ImVec2, ptr %arrayctor.cur, i64 1
  %arrayctor.done = icmp eq ptr %arrayctor.next, %arrayctor.end
  br i1 %arrayctor.done, label %arrayctor.cont, label %arrayctor.loop

arrayctor.cont:                                   ; preds = %arrayctor.loop
  %113 = load ptr, ptr %column, align 8
  %MaxX103 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %113, i32 0, i32 3
  %114 = load float, ptr %MaxX103, align 4
  %Max104 = getelementptr inbounds %struct.ImRect, ptr %row_r, i32 0, i32 1
  %y105 = getelementptr inbounds %struct.ImVec2, ptr %Max104, i32 0, i32 1
  %115 = load float, ptr %y105, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp102, float noundef %114, float noundef %115)
  %arrayidx106 = getelementptr inbounds [4 x %struct.ImVec2], ptr %bg_shape, i64 0, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx106, ptr align 4 %ref.tmp102, i64 8, i1 false)
  %116 = load ptr, ptr %column, align 8
  %MinX = getelementptr inbounds %struct.ImGuiTableColumn, ptr %116, i32 0, i32 2
  %117 = load float, ptr %MinX, align 4
  %Max108 = getelementptr inbounds %struct.ImRect, ptr %row_r, i32 0, i32 1
  %y109 = getelementptr inbounds %struct.ImVec2, ptr %Max108, i32 0, i32 1
  %118 = load float, ptr %y109, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp107, float noundef %117, float noundef %118)
  %arrayidx110 = getelementptr inbounds [4 x %struct.ImVec2], ptr %bg_shape, i64 0, i64 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arrayidx110, ptr align 4 %ref.tmp107, i64 8, i1 false)
  %arrayidx112 = getelementptr inbounds [4 x %struct.ImVec2], ptr %bg_shape, i64 0, i64 1
  %call113 = call <2 x float> @_ZplRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %arrayidx112, ptr noundef nonnull align 4 dereferenceable(8) %header_angled_vector)
  store <2 x float> %call113, ptr %ref.tmp111, align 4
  %arrayidx114 = getelementptr inbounds [4 x %struct.ImVec2], ptr %bg_shape, i64 0, i64 2
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx114, ptr align 4 %ref.tmp111, i64 8, i1 false)
  %arrayidx116 = getelementptr inbounds [4 x %struct.ImVec2], ptr %bg_shape, i64 0, i64 0
  %call117 = call <2 x float> @_ZplRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %arrayidx116, ptr noundef nonnull align 4 dereferenceable(8) %header_angled_vector)
  store <2 x float> %call117, ptr %ref.tmp115, align 4
  %arrayidx118 = getelementptr inbounds [4 x %struct.ImVec2], ptr %bg_shape, i64 0, i64 3
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arrayidx118, ptr align 4 %ref.tmp115, i64 8, i1 false)
  %119 = load i32, ptr %pass, align 4
  %cmp119 = icmp eq i32 %119, 0
  br i1 %cmp119, label %if.then120, label %if.end186

if.then120:                                       ; preds = %arrayctor.cont
  %120 = load ptr, ptr %draw_list, align 8
  %arrayidx121 = getelementptr inbounds [4 x %struct.ImVec2], ptr %bg_shape, i64 0, i64 0
  %arrayidx122 = getelementptr inbounds [4 x %struct.ImVec2], ptr %bg_shape, i64 0, i64 1
  %arrayidx123 = getelementptr inbounds [4 x %struct.ImVec2], ptr %bg_shape, i64 0, i64 2
  %arrayidx124 = getelementptr inbounds [4 x %struct.ImVec2], ptr %bg_shape, i64 0, i64 3
  %call125 = call noundef i32 @_ZN5ImGui11GetColorU32Eif(i32 noundef 42, float noundef 1.000000e+00)
  call void @_ZN10ImDrawList13AddQuadFilledERK6ImVec2S2_S2_S2_j(ptr noundef nonnull align 8 dereferenceable(196) %120, ptr noundef nonnull align 4 dereferenceable(8) %arrayidx121, ptr noundef nonnull align 4 dereferenceable(8) %arrayidx122, ptr noundef nonnull align 4 dereferenceable(8) %arrayidx123, ptr noundef nonnull align 4 dereferenceable(8) %arrayidx124, i32 noundef %call125)
  %121 = load i32, ptr %column_n, align 4
  %122 = load i32, ptr %highlight_column_n, align 4
  %cmp126 = icmp eq i32 %121, %122
  br i1 %cmp126, label %if.then127, label %if.end133

if.then127:                                       ; preds = %if.then120
  %123 = load ptr, ptr %draw_list, align 8
  %arrayidx128 = getelementptr inbounds [4 x %struct.ImVec2], ptr %bg_shape, i64 0, i64 0
  %arrayidx129 = getelementptr inbounds [4 x %struct.ImVec2], ptr %bg_shape, i64 0, i64 1
  %arrayidx130 = getelementptr inbounds [4 x %struct.ImVec2], ptr %bg_shape, i64 0, i64 2
  %arrayidx131 = getelementptr inbounds [4 x %struct.ImVec2], ptr %bg_shape, i64 0, i64 3
  %call132 = call noundef i32 @_ZN5ImGui11GetColorU32Eif(i32 noundef 24, float noundef 1.000000e+00)
  call void @_ZN10ImDrawList13AddQuadFilledERK6ImVec2S2_S2_S2_j(ptr noundef nonnull align 8 dereferenceable(196) %123, ptr noundef nonnull align 4 dereferenceable(8) %arrayidx128, ptr noundef nonnull align 4 dereferenceable(8) %arrayidx129, ptr noundef nonnull align 4 dereferenceable(8) %arrayidx130, ptr noundef nonnull align 4 dereferenceable(8) %arrayidx131, i32 noundef %call132)
  br label %if.end133

if.end133:                                        ; preds = %if.then127, %if.then120
  %124 = load float, ptr %max_x, align 4
  %arrayidx134 = getelementptr inbounds [4 x %struct.ImVec2], ptr %bg_shape, i64 0, i64 3
  %x135 = getelementptr inbounds %struct.ImVec2, ptr %arrayidx134, i32 0, i32 0
  %125 = load float, ptr %x135, align 8
  %call136 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %124, float noundef %125)
  store float %call136, ptr %max_x, align 4
  %126 = load ptr, ptr %table, align 8
  %127 = load i32, ptr %column_n, align 4
  %call137 = call noundef ptr @_ZN5ImGui18TableGetColumnNameEPK10ImGuiTablei(ptr noundef %126, i32 noundef %127)
  store ptr %call137, ptr %label_name, align 8
  %128 = load float, ptr %max_label_width.addr, align 4
  %129 = load float, ptr %sin_a, align 4
  %130 = load ptr, ptr %table, align 8
  %RowCellPaddingY138 = getelementptr inbounds %struct.ImGuiTable, ptr %130, i32 0, i32 21
  %131 = load float, ptr %RowCellPaddingY138, align 8
  %neg = fneg float %129
  %132 = call float @llvm.fmuladd.f32(float %neg, float %131, float %128)
  store float %132, ptr %clip_width, align 4
  %133 = load ptr, ptr %window, align 8
  %ClipRect = getelementptr inbounds %struct.ImGuiWindow, ptr %133, i32 0, i32 74
  %Min139 = getelementptr inbounds %struct.ImRect, ptr %ClipRect, i32 0, i32 0
  %134 = load ptr, ptr %window, align 8
  %ClipRect141 = getelementptr inbounds %struct.ImGuiWindow, ptr %134, i32 0, i32 74
  %Min142 = getelementptr inbounds %struct.ImRect, ptr %ClipRect141, i32 0, i32 0
  %135 = load float, ptr %clip_width, align 4
  %136 = load i8, ptr %flip_label, align 1
  %tobool144 = trunc i8 %136 to i1
  br i1 %tobool144, label %cond.true145, label %cond.false146

cond.true145:                                     ; preds = %if.end133
  br label %cond.end147

cond.false146:                                    ; preds = %if.end133
  %137 = load ptr, ptr %table, align 8
  %CellPaddingX = getelementptr inbounds %struct.ImGuiTable, ptr %137, i32 0, i32 34
  %138 = load float, ptr %CellPaddingX, align 8
  br label %cond.end147

cond.end147:                                      ; preds = %cond.false146, %cond.true145
  %cond148 = phi float [ 0.000000e+00, %cond.true145 ], [ %138, %cond.false146 ]
  %add149 = fadd float %135, %cond148
  %139 = load float, ptr %header_height, align 4
  %140 = load ptr, ptr %table, align 8
  %RowCellPaddingY150 = getelementptr inbounds %struct.ImGuiTable, ptr %140, i32 0, i32 21
  %141 = load float, ptr %RowCellPaddingY150, align 8
  %add151 = fadd float %139, %141
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp143, float noundef %add149, float noundef %add151)
  %call152 = call <2 x float> @_ZplRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %Min142, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp143)
  store <2 x float> %call152, ptr %ref.tmp140, align 4
  call void @_ZN6ImRectC2ERK6ImVec2S2_(ptr noundef nonnull align 4 dereferenceable(16) %label_r, ptr noundef nonnull align 4 dereferenceable(8) %Min139, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp140)
  %142 = load ptr, ptr %label_name, align 8
  %call153 = call <2 x float> @_ZN5ImGui12CalcTextSizeEPKcS1_bf(ptr noundef %142, ptr noundef null, i1 noundef zeroext true, float noundef -1.000000e+00)
  store <2 x float> %call153, ptr %label_size, align 4
  %143 = load i8, ptr %flip_label, align 1
  %tobool154 = trunc i8 %143 to i1
  br i1 %tobool154, label %cond.true155, label %cond.false161

cond.true155:                                     ; preds = %cond.end147
  %144 = load float, ptr %max_label_width.addr, align 4
  %x156 = getelementptr inbounds %struct.ImVec2, ptr %label_size, i32 0, i32 0
  %145 = load float, ptr %x156, align 4
  %sub157 = fsub float %144, %145
  %146 = load ptr, ptr %table, align 8
  %CellPaddingX158 = getelementptr inbounds %struct.ImGuiTable, ptr %146, i32 0, i32 34
  %147 = load float, ptr %CellPaddingX158, align 8
  %sub159 = fsub float %sub157, %147
  %call160 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef 0.000000e+00, float noundef %sub159)
  br label %cond.end163

cond.false161:                                    ; preds = %cond.end147
  %148 = load ptr, ptr %table, align 8
  %CellPaddingX162 = getelementptr inbounds %struct.ImGuiTable, ptr %148, i32 0, i32 34
  %149 = load float, ptr %CellPaddingX162, align 8
  br label %cond.end163

cond.end163:                                      ; preds = %cond.false161, %cond.true155
  %cond164 = phi float [ %call160, %cond.true155 ], [ %149, %cond.false161 ]
  %150 = load ptr, ptr %table, align 8
  %RowCellPaddingY165 = getelementptr inbounds %struct.ImGuiTable, ptr %150, i32 0, i32 21
  %151 = load float, ptr %RowCellPaddingY165, align 8
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %label_off, float noundef %cond164, float noundef %151)
  %152 = load ptr, ptr %draw_list, align 8
  %_VtxCurrentIdx = getelementptr inbounds %struct.ImDrawList, ptr %152, i32 0, i32 4
  %153 = load i32, ptr %_VtxCurrentIdx, align 4
  store i32 %153, ptr %vtx_idx_begin, align 4
  %154 = load ptr, ptr %draw_list, align 8
  %Min167 = getelementptr inbounds %struct.ImRect, ptr %label_r, i32 0, i32 0
  %call168 = call <2 x float> @_ZplRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %Min167, ptr noundef nonnull align 4 dereferenceable(8) %label_off)
  store <2 x float> %call168, ptr %ref.tmp166, align 4
  %Max169 = getelementptr inbounds %struct.ImRect, ptr %label_r, i32 0, i32 1
  %Max170 = getelementptr inbounds %struct.ImRect, ptr %label_r, i32 0, i32 1
  %x171 = getelementptr inbounds %struct.ImVec2, ptr %Max170, i32 0, i32 0
  %155 = load float, ptr %x171, align 4
  %Max172 = getelementptr inbounds %struct.ImRect, ptr %label_r, i32 0, i32 1
  %x173 = getelementptr inbounds %struct.ImVec2, ptr %Max172, i32 0, i32 0
  %156 = load float, ptr %x173, align 4
  %157 = load ptr, ptr %label_name, align 8
  call void @_ZN5ImGui18RenderTextEllipsisEP10ImDrawListRK6ImVec2S4_ffPKcS6_PS3_(ptr noundef %154, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp166, ptr noundef nonnull align 4 dereferenceable(8) %Max169, float noundef %155, float noundef %156, ptr noundef %157, ptr noundef null, ptr noundef %label_size)
  %158 = load ptr, ptr %draw_list, align 8
  %_VtxCurrentIdx174 = getelementptr inbounds %struct.ImDrawList, ptr %158, i32 0, i32 4
  %159 = load i32, ptr %_VtxCurrentIdx174, align 4
  store i32 %159, ptr %vtx_idx_end, align 4
  %call175 = call <2 x float> @_ZNK6ImRect5GetBLEv(ptr noundef nonnull align 4 dereferenceable(16) %label_r)
  store <2 x float> %call175, ptr %pivot_in, align 4
  %160 = load ptr, ptr %column, align 8
  %WorkMinX = getelementptr inbounds %struct.ImGuiTableColumn, ptr %160, i32 0, i32 10
  %161 = load float, ptr %WorkMinX, align 4
  %Max177 = getelementptr inbounds %struct.ImRect, ptr %row_r, i32 0, i32 1
  %y178 = getelementptr inbounds %struct.ImVec2, ptr %Max177, i32 0, i32 1
  %162 = load float, ptr %y178, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp176, float noundef %161, float noundef %162)
  %163 = load i8, ptr %flip_label, align 1
  %tobool180 = trunc i8 %163 to i1
  br i1 %tobool180, label %cond.true181, label %cond.false183

cond.true181:                                     ; preds = %cond.end163
  %164 = load float, ptr %clip_width, align 4
  %call182 = call <2 x float> @_ZmlRK6ImVec2f(ptr noundef nonnull align 4 dereferenceable(8) %unit_right, float noundef %164)
  store <2 x float> %call182, ptr %ref.tmp179, align 4
  br label %cond.end184

cond.false183:                                    ; preds = %cond.end163
  %165 = load float, ptr %header_height, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp179, float noundef %165, float noundef 0.000000e+00)
  br label %cond.end184

cond.end184:                                      ; preds = %cond.false183, %cond.true181
  %call185 = call <2 x float> @_ZplRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp176, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp179)
  store <2 x float> %call185, ptr %pivot_out, align 4
  %166 = load ptr, ptr %draw_list, align 8
  %167 = load i32, ptr %vtx_idx_begin, align 4
  %168 = load i32, ptr %vtx_idx_end, align 4
  %169 = load float, ptr %label_cos_a, align 4
  %170 = load float, ptr %label_sin_a, align 4
  call void @_ZN5ImGui22ShadeVertsTransformPosEP10ImDrawListiiRK6ImVec2ffS4_(ptr noundef %166, i32 noundef %167, i32 noundef %168, ptr noundef nonnull align 4 dereferenceable(8) %pivot_in, float noundef %169, float noundef %170, ptr noundef nonnull align 4 dereferenceable(8) %pivot_out)
  br label %if.end186

if.end186:                                        ; preds = %cond.end184, %arrayctor.cont
  %171 = load i32, ptr %pass, align 4
  %cmp187 = icmp eq i32 %171, 1
  br i1 %cmp187, label %if.then188, label %if.end192

if.then188:                                       ; preds = %if.end186
  %172 = load ptr, ptr %draw_list, align 8
  %arrayidx189 = getelementptr inbounds [4 x %struct.ImVec2], ptr %bg_shape, i64 0, i64 0
  %arrayidx190 = getelementptr inbounds [4 x %struct.ImVec2], ptr %bg_shape, i64 0, i64 3
  %173 = load ptr, ptr %table, align 8
  %174 = load i32, ptr %order_n, align 4
  %175 = load i32, ptr %column_n, align 4
  %call191 = call noundef i32 @_ZL23TableGetColumnBorderColP10ImGuiTableii(ptr noundef %173, i32 noundef %174, i32 noundef %175)
  call void @_ZN10ImDrawList7AddLineERK6ImVec2S2_jf(ptr noundef nonnull align 8 dereferenceable(196) %172, ptr noundef nonnull align 4 dereferenceable(8) %arrayidx189, ptr noundef nonnull align 4 dereferenceable(8) %arrayidx190, i32 noundef %call191, float noundef 1.000000e+00)
  br label %if.end192

if.end192:                                        ; preds = %if.then188, %if.end186
  br label %for.inc

for.inc:                                          ; preds = %if.end192, %if.then100, %if.then92
  %176 = load i32, ptr %order_n, align 4
  %inc = add nsw i32 %176, 1
  store i32 %inc, ptr %order_n, align 4
  br label %for.cond87, !llvm.loop !54

for.end:                                          ; preds = %for.cond87
  br label %for.inc193

for.inc193:                                       ; preds = %for.end
  %177 = load i32, ptr %pass, align 4
  %inc194 = add nsw i32 %177, 1
  store i32 %inc194, ptr %pass, align 4
  br label %for.cond, !llvm.loop !55

for.end195:                                       ; preds = %for.cond
  call void @_ZN5ImGui11PopClipRectEv()
  call void @_ZN5ImGui11PopClipRectEv()
  %178 = load float, ptr %max_x, align 4
  %179 = load ptr, ptr %table, align 8
  %Columns196 = getelementptr inbounds %struct.ImGuiTable, ptr %179, i32 0, i32 4
  %180 = load ptr, ptr %table, align 8
  %RightMostEnabledColumn = getelementptr inbounds %struct.ImGuiTable, ptr %180, i32 0, i32 80
  %181 = load i16, ptr %RightMostEnabledColumn, align 2
  %conv197 = sext i16 %181 to i32
  %call198 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns196, i32 noundef %conv197)
  %MaxX199 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %call198, i32 0, i32 3
  %182 = load float, ptr %MaxX199, align 4
  %sub200 = fsub float %178, %182
  %call201 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef 0.000000e+00, float noundef %sub200)
  %183 = load ptr, ptr %table, align 8
  %TempData = getelementptr inbounds %struct.ImGuiTable, ptr %183, i32 0, i32 3
  %184 = load ptr, ptr %TempData, align 8
  %AngledheadersExtraWidth = getelementptr inbounds %struct.ImGuiTableTempData, ptr %184, i32 0, i32 2
  store float %call201, ptr %AngledheadersExtraWidth, align 8
  ret void
}

; Function Attrs: nounwind
declare float @cosf(float noundef) #8

; Function Attrs: nounwind
declare float @sinf(float noundef) #8

; Function Attrs: mustprogress uwtable
define internal <2 x float> @_ZL8ImRotateRK6ImVec2ff(ptr noundef nonnull align 4 dereferenceable(8) %v, float noundef %cos_a, float noundef %sin_a) #2 {
entry:
  %retval = alloca %struct.ImVec2, align 4
  %v.addr = alloca ptr, align 8
  %cos_a.addr = alloca float, align 4
  %sin_a.addr = alloca float, align 4
  store ptr %v, ptr %v.addr, align 8
  store float %cos_a, ptr %cos_a.addr, align 4
  store float %sin_a, ptr %sin_a.addr, align 4
  %0 = load ptr, ptr %v.addr, align 8
  %x = getelementptr inbounds %struct.ImVec2, ptr %0, i32 0, i32 0
  %1 = load float, ptr %x, align 4
  %2 = load float, ptr %cos_a.addr, align 4
  %3 = load ptr, ptr %v.addr, align 8
  %y = getelementptr inbounds %struct.ImVec2, ptr %3, i32 0, i32 1
  %4 = load float, ptr %y, align 4
  %5 = load float, ptr %sin_a.addr, align 4
  %mul1 = fmul float %4, %5
  %neg = fneg float %mul1
  %6 = call float @llvm.fmuladd.f32(float %1, float %2, float %neg)
  %7 = load ptr, ptr %v.addr, align 8
  %x2 = getelementptr inbounds %struct.ImVec2, ptr %7, i32 0, i32 0
  %8 = load float, ptr %x2, align 4
  %9 = load float, ptr %sin_a.addr, align 4
  %10 = load ptr, ptr %v.addr, align 8
  %y3 = getelementptr inbounds %struct.ImVec2, ptr %10, i32 0, i32 1
  %11 = load float, ptr %y3, align 4
  %12 = load float, ptr %cos_a.addr, align 4
  %mul4 = fmul float %11, %12
  %13 = call float @llvm.fmuladd.f32(float %8, float %9, float %mul4)
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %retval, float noundef %6, float noundef %13)
  %14 = load <2 x float>, ptr %retval, align 4
  ret <2 x float> %14
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.fabs.f32(float) #6

; Function Attrs: mustprogress uwtable
define internal <2 x float> @_ZmlRK6ImVec2f(ptr noundef nonnull align 4 dereferenceable(8) %lhs, float noundef %rhs) #2 {
entry:
  %retval = alloca %struct.ImVec2, align 4
  %lhs.addr = alloca ptr, align 8
  %rhs.addr = alloca float, align 4
  store ptr %lhs, ptr %lhs.addr, align 8
  store float %rhs, ptr %rhs.addr, align 4
  %0 = load ptr, ptr %lhs.addr, align 8
  %x = getelementptr inbounds %struct.ImVec2, ptr %0, i32 0, i32 0
  %1 = load float, ptr %x, align 4
  %2 = load float, ptr %rhs.addr, align 4
  %mul = fmul float %1, %2
  %3 = load ptr, ptr %lhs.addr, align 8
  %y = getelementptr inbounds %struct.ImVec2, ptr %3, i32 0, i32 1
  %4 = load float, ptr %y, align 4
  %5 = load float, ptr %rhs.addr, align 4
  %mul1 = fmul float %4, %5
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %retval, float noundef %mul, float noundef %mul1)
  %6 = load <2 x float>, ptr %retval, align 4
  ret <2 x float> %6
}

declare void @_ZN5ImGui12PushClipRectERK6ImVec2S2_b(ptr noundef nonnull align 4 dereferenceable(8), ptr noundef nonnull align 4 dereferenceable(8), i1 noundef zeroext) #1

declare void @_ZN5ImGui11KeepAliveIDEj(i32 noundef) #1

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN6ImVec2C2Ev(ptr noundef nonnull align 4 dereferenceable(8) %this) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %x = getelementptr inbounds %struct.ImVec2, ptr %this1, i32 0, i32 0
  store float 0.000000e+00, ptr %x, align 4
  %y = getelementptr inbounds %struct.ImVec2, ptr %this1, i32 0, i32 1
  store float 0.000000e+00, ptr %y, align 4
  ret void
}

declare void @_ZN10ImDrawList13AddQuadFilledERK6ImVec2S2_S2_S2_j(ptr noundef nonnull align 8 dereferenceable(196), ptr noundef nonnull align 4 dereferenceable(8), ptr noundef nonnull align 4 dereferenceable(8), ptr noundef nonnull align 4 dereferenceable(8), ptr noundef nonnull align 4 dereferenceable(8), i32 noundef) #1

; Function Attrs: mustprogress uwtable
define linkonce_odr <2 x float> @_ZNK6ImRect5GetBLEv(ptr noundef nonnull align 4 dereferenceable(16) %this) #2 comdat align 2 {
entry:
  %retval = alloca %struct.ImVec2, align 4
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Min = getelementptr inbounds %struct.ImRect, ptr %this1, i32 0, i32 0
  %x = getelementptr inbounds %struct.ImVec2, ptr %Min, i32 0, i32 0
  %0 = load float, ptr %x, align 4
  %Max = getelementptr inbounds %struct.ImRect, ptr %this1, i32 0, i32 1
  %y = getelementptr inbounds %struct.ImVec2, ptr %Max, i32 0, i32 1
  %1 = load float, ptr %y, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %retval, float noundef %0, float noundef %1)
  %2 = load <2 x float>, ptr %retval, align 4
  ret <2 x float> %2
}

declare void @_ZN5ImGui22ShadeVertsTransformPosEP10ImDrawListiiRK6ImVec2ffS4_(ptr noundef, i32 noundef, i32 noundef, ptr noundef nonnull align 4 dereferenceable(8), float noundef, float noundef, ptr noundef nonnull align 4 dereferenceable(8)) #1

declare void @_ZN5ImGui11PopClipRectEv() #1

declare noundef i32 @_Z9ImHashStrPKcmj(ptr noundef, i64 noundef, i32 noundef) #1

declare void @_ZN5ImGui11OpenPopupExEji(i32 noundef, i32 noundef) #1

declare noundef zeroext i1 @_ZN5ImGui12BeginPopupExEji(i32 noundef, i32 noundef) #1

declare noundef zeroext i1 @_ZN5ImGui8MenuItemEPKcS1_bb(ptr noundef, ptr noundef, i1 noundef zeroext, i1 noundef zeroext) #1

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef ptr @_ZN5ImGui14LocalizeGetMsgE11ImGuiLocKey(i32 noundef %key) #3 comdat {
entry:
  %key.addr = alloca i32, align 4
  %g = alloca ptr, align 8
  %msg = alloca ptr, align 8
  store i32 %key, ptr %key.addr, align 4
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %g, align 8
  %LocalizationTable = getelementptr inbounds %struct.ImGuiContext, ptr %1, i32 0, i32 221
  %2 = load i32, ptr %key.addr, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [8 x ptr], ptr %LocalizationTable, i64 0, i64 %idxprom
  %3 = load ptr, ptr %arrayidx, align 8
  store ptr %3, ptr %msg, align 8
  %4 = load ptr, ptr %msg, align 8
  %tobool = icmp ne ptr %4, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %5 = load ptr, ptr %msg, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %5, %cond.true ], [ @.str.37, %cond.false ]
  ret ptr %cond
}

declare void @_ZN5ImGui9SeparatorEv() #1

declare void @_ZN5ImGui12PushItemFlagEib(i32 noundef, i1 noundef zeroext) #1

declare void @_ZN5ImGui11PopItemFlagEv() #1

; Function Attrs: mustprogress uwtable
define noundef ptr @_ZN5ImGui19TableSettingsCreateEji(i32 noundef %id, i32 noundef %columns_count) #0 {
entry:
  %id.addr = alloca i32, align 4
  %columns_count.addr = alloca i32, align 4
  %g = alloca ptr, align 8
  %settings = alloca ptr, align 8
  store i32 %id, ptr %id.addr, align 4
  store i32 %columns_count, ptr %columns_count.addr, align 4
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %g, align 8
  %SettingsTables = getelementptr inbounds %struct.ImGuiContext, ptr %1, i32 0, i32 218
  %2 = load i32, ptr %columns_count.addr, align 4
  %call = call noundef i64 @_ZL26TableSettingsCalcChunkSizei(i32 noundef %2)
  %call1 = call noundef ptr @_ZN13ImChunkStreamI18ImGuiTableSettingsE11alloc_chunkEm(ptr noundef nonnull align 8 dereferenceable(16) %SettingsTables, i64 noundef %call)
  store ptr %call1, ptr %settings, align 8
  %3 = load ptr, ptr %settings, align 8
  %4 = load i32, ptr %id.addr, align 4
  %5 = load i32, ptr %columns_count.addr, align 4
  %6 = load i32, ptr %columns_count.addr, align 4
  call void @_ZL17TableSettingsInitP18ImGuiTableSettingsjii(ptr noundef %3, i32 noundef %4, i32 noundef %5, i32 noundef %6)
  %7 = load ptr, ptr %settings, align 8
  ret ptr %7
}

; Function Attrs: mustprogress uwtable
define linkonce_odr noundef ptr @_ZN13ImChunkStreamI18ImGuiTableSettingsE11alloc_chunkEm(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %sz) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %sz.addr = alloca i64, align 8
  %HDR_SZ = alloca i64, align 8
  %off = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i64 %sz, ptr %sz.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  store i64 4, ptr %HDR_SZ, align 8
  %0 = load i64, ptr %HDR_SZ, align 8
  %1 = load i64, ptr %sz.addr, align 8
  %add = add i64 %0, %1
  %add2 = add i64 %add, 3
  %and = and i64 %add2, 4294967292
  store i64 %and, ptr %sz.addr, align 8
  %Buf = getelementptr inbounds %struct.ImChunkStream.28, ptr %this1, i32 0, i32 0
  %Size = getelementptr inbounds %struct.ImVector.25, ptr %Buf, i32 0, i32 0
  %2 = load i32, ptr %Size, align 8
  store i32 %2, ptr %off, align 4
  %Buf3 = getelementptr inbounds %struct.ImChunkStream.28, ptr %this1, i32 0, i32 0
  %3 = load i32, ptr %off, align 4
  %4 = load i64, ptr %sz.addr, align 8
  %conv = trunc i64 %4 to i32
  %add4 = add nsw i32 %3, %conv
  call void @_ZN8ImVectorIcE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %Buf3, i32 noundef %add4)
  %5 = load i64, ptr %sz.addr, align 8
  %conv5 = trunc i64 %5 to i32
  %Buf6 = getelementptr inbounds %struct.ImChunkStream.28, ptr %this1, i32 0, i32 0
  %Data = getelementptr inbounds %struct.ImVector.25, ptr %Buf6, i32 0, i32 2
  %6 = load ptr, ptr %Data, align 8
  %7 = load i32, ptr %off, align 4
  %idx.ext = sext i32 %7 to i64
  %add.ptr = getelementptr inbounds i8, ptr %6, i64 %idx.ext
  %arrayidx = getelementptr inbounds i32, ptr %add.ptr, i64 0
  store i32 %conv5, ptr %arrayidx, align 4
  %Buf7 = getelementptr inbounds %struct.ImChunkStream.28, ptr %this1, i32 0, i32 0
  %Data8 = getelementptr inbounds %struct.ImVector.25, ptr %Buf7, i32 0, i32 2
  %8 = load ptr, ptr %Data8, align 8
  %9 = load i32, ptr %off, align 4
  %idx.ext9 = sext i32 %9 to i64
  %add.ptr10 = getelementptr inbounds i8, ptr %8, i64 %idx.ext9
  %10 = load i64, ptr %HDR_SZ, align 8
  %conv11 = trunc i64 %10 to i32
  %idx.ext12 = sext i32 %conv11 to i64
  %add.ptr13 = getelementptr inbounds i8, ptr %add.ptr10, i64 %idx.ext12
  ret ptr %add.ptr13
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef i64 @_ZL26TableSettingsCalcChunkSizei(i32 noundef %columns_count) #3 {
entry:
  %columns_count.addr = alloca i32, align 4
  store i32 %columns_count, ptr %columns_count.addr, align 4
  %0 = load i32, ptr %columns_count.addr, align 4
  %conv = sext i32 %0 to i64
  %mul = mul i64 %conv, 16
  %add = add i64 20, %mul
  ret i64 %add
}

; Function Attrs: mustprogress uwtable
define internal void @_ZL17TableSettingsInitP18ImGuiTableSettingsjii(ptr noundef %settings, i32 noundef %id, i32 noundef %columns_count, i32 noundef %columns_count_max) #0 personality ptr @__gxx_personality_v0 {
entry:
  %settings.addr = alloca ptr, align 8
  %id.addr = alloca i32, align 4
  %columns_count.addr = alloca i32, align 4
  %columns_count_max.addr = alloca i32, align 4
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  %settings_column = alloca ptr, align 8
  %n = alloca i32, align 4
  store ptr %settings, ptr %settings.addr, align 8
  store i32 %id, ptr %id.addr, align 4
  store i32 %columns_count, ptr %columns_count.addr, align 4
  store i32 %columns_count_max, ptr %columns_count_max.addr, align 4
  %0 = load ptr, ptr %settings.addr, align 8
  %call = call noundef ptr @_Znwm12ImNewWrapperPv(i64 noundef 20, ptr noundef %0)
  invoke void @_ZN18ImGuiTableSettingsC2Ev(ptr noundef nonnull align 4 dereferenceable(17) %call)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  %1 = load ptr, ptr %settings.addr, align 8
  %call1 = call noundef ptr @_ZN18ImGuiTableSettings17GetColumnSettingsEv(ptr noundef nonnull align 4 dereferenceable(17) %1)
  store ptr %call1, ptr %settings_column, align 8
  store i32 0, ptr %n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %invoke.cont
  %2 = load i32, ptr %n, align 4
  %3 = load i32, ptr %columns_count_max.addr, align 4
  %cmp = icmp slt i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load ptr, ptr %settings_column, align 8
  %call3 = call noundef ptr @_Znwm12ImNewWrapperPv(i64 noundef 16, ptr noundef %4)
  invoke void @_ZN24ImGuiTableColumnSettingsC2Ev(ptr noundef nonnull align 4 dereferenceable(15) %call3)
          to label %invoke.cont5 unwind label %lpad4

invoke.cont5:                                     ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %invoke.cont5
  %5 = load i32, ptr %n, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, ptr %n, align 4
  %6 = load ptr, ptr %settings_column, align 8
  %incdec.ptr = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %6, i32 1
  store ptr %incdec.ptr, ptr %settings_column, align 8
  br label %for.cond, !llvm.loop !56

lpad:                                             ; preds = %entry
  %7 = landingpad { ptr, i32 }
          cleanup
  %8 = extractvalue { ptr, i32 } %7, 0
  store ptr %8, ptr %exn.slot, align 8
  %9 = extractvalue { ptr, i32 } %7, 1
  store i32 %9, ptr %ehselector.slot, align 4
  call void @_ZdlPv12ImNewWrapperS_(ptr noundef %call, ptr noundef %0) #10
  br label %eh.resume

lpad4:                                            ; preds = %for.body
  %10 = landingpad { ptr, i32 }
          cleanup
  %11 = extractvalue { ptr, i32 } %10, 0
  store ptr %11, ptr %exn.slot, align 8
  %12 = extractvalue { ptr, i32 } %10, 1
  store i32 %12, ptr %ehselector.slot, align 4
  call void @_ZdlPv12ImNewWrapperS_(ptr noundef %call3, ptr noundef %4) #10
  br label %eh.resume

for.end:                                          ; preds = %for.cond
  %13 = load i32, ptr %id.addr, align 4
  %14 = load ptr, ptr %settings.addr, align 8
  %ID = getelementptr inbounds %struct.ImGuiTableSettings, ptr %14, i32 0, i32 0
  store i32 %13, ptr %ID, align 4
  %15 = load i32, ptr %columns_count.addr, align 4
  %conv = trunc i32 %15 to i16
  %16 = load ptr, ptr %settings.addr, align 8
  %ColumnsCount = getelementptr inbounds %struct.ImGuiTableSettings, ptr %16, i32 0, i32 3
  store i16 %conv, ptr %ColumnsCount, align 4
  %17 = load i32, ptr %columns_count_max.addr, align 4
  %conv6 = trunc i32 %17 to i16
  %18 = load ptr, ptr %settings.addr, align 8
  %ColumnsCountMax = getelementptr inbounds %struct.ImGuiTableSettings, ptr %18, i32 0, i32 4
  store i16 %conv6, ptr %ColumnsCountMax, align 2
  %19 = load ptr, ptr %settings.addr, align 8
  %WantApply = getelementptr inbounds %struct.ImGuiTableSettings, ptr %19, i32 0, i32 5
  store i8 1, ptr %WantApply, align 4
  ret void

eh.resume:                                        ; preds = %lpad4, %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val7 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val7
}

; Function Attrs: mustprogress uwtable
define noundef ptr @_ZN5ImGui21TableSettingsFindByIDEj(i32 noundef %id) #0 {
entry:
  %retval = alloca ptr, align 8
  %id.addr = alloca i32, align 4
  %g = alloca ptr, align 8
  %settings = alloca ptr, align 8
  store i32 %id, ptr %id.addr, align 4
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %g, align 8
  %SettingsTables = getelementptr inbounds %struct.ImGuiContext, ptr %1, i32 0, i32 218
  %call = call noundef ptr @_ZN13ImChunkStreamI18ImGuiTableSettingsE5beginEv(ptr noundef nonnull align 8 dereferenceable(16) %SettingsTables)
  store ptr %call, ptr %settings, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load ptr, ptr %settings, align 8
  %cmp = icmp ne ptr %2, null
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %settings, align 8
  %ID = getelementptr inbounds %struct.ImGuiTableSettings, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %ID, align 4
  %5 = load i32, ptr %id.addr, align 4
  %cmp1 = icmp eq i32 %4, %5
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %6 = load ptr, ptr %settings, align 8
  store ptr %6, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %7 = load ptr, ptr %g, align 8
  %SettingsTables2 = getelementptr inbounds %struct.ImGuiContext, ptr %7, i32 0, i32 218
  %8 = load ptr, ptr %settings, align 8
  %call3 = call noundef ptr @_ZN13ImChunkStreamI18ImGuiTableSettingsE10next_chunkEPS0_(ptr noundef nonnull align 8 dereferenceable(16) %SettingsTables2, ptr noundef %8)
  store ptr %call3, ptr %settings, align 8
  br label %for.cond, !llvm.loop !57

for.end:                                          ; preds = %for.cond
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %for.end, %if.then
  %9 = load ptr, ptr %retval, align 8
  ret ptr %9
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef ptr @_ZN13ImChunkStreamI18ImGuiTableSettingsE5beginEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #3 comdat align 2 {
entry:
  %retval = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %HDR_SZ = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  store i64 4, ptr %HDR_SZ, align 8
  %Buf = getelementptr inbounds %struct.ImChunkStream.28, ptr %this1, i32 0, i32 0
  %Data = getelementptr inbounds %struct.ImVector.25, ptr %Buf, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %Buf2 = getelementptr inbounds %struct.ImChunkStream.28, ptr %this1, i32 0, i32 0
  %Data3 = getelementptr inbounds %struct.ImVector.25, ptr %Buf2, i32 0, i32 2
  %1 = load ptr, ptr %Data3, align 8
  %2 = load i64, ptr %HDR_SZ, align 8
  %add.ptr = getelementptr inbounds i8, ptr %1, i64 %2
  store ptr %add.ptr, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load ptr, ptr %retval, align 8
  ret ptr %3
}

; Function Attrs: mustprogress uwtable
define linkonce_odr noundef ptr @_ZN13ImChunkStreamI18ImGuiTableSettingsE10next_chunkEPS0_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %p) #0 comdat align 2 {
entry:
  %retval = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %HDR_SZ = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  store i64 4, ptr %HDR_SZ, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %1 = load ptr, ptr %p.addr, align 8
  %call = call noundef i32 @_ZN13ImChunkStreamI18ImGuiTableSettingsE10chunk_sizeEPKS0_(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef %1)
  %idx.ext = sext i32 %call to i64
  %add.ptr = getelementptr inbounds i8, ptr %0, i64 %idx.ext
  store ptr %add.ptr, ptr %p.addr, align 8
  %2 = load ptr, ptr %p.addr, align 8
  %call2 = call noundef ptr @_ZN13ImChunkStreamI18ImGuiTableSettingsE3endEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  %3 = load i64, ptr %HDR_SZ, align 8
  %add.ptr3 = getelementptr inbounds i8, ptr %call2, i64 %3
  %cmp = icmp eq ptr %2, %add.ptr3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %p.addr, align 8
  store ptr %4, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %5 = load ptr, ptr %retval, align 8
  ret ptr %5
}

; Function Attrs: mustprogress uwtable
define noundef ptr @_ZN5ImGui21TableGetBoundSettingsEP10ImGuiTable(ptr noundef %table) #0 {
entry:
  %retval = alloca ptr, align 8
  %table.addr = alloca ptr, align 8
  %g = alloca ptr, align 8
  %settings = alloca ptr, align 8
  store ptr %table, ptr %table.addr, align 8
  %0 = load ptr, ptr %table.addr, align 8
  %SettingsOffset = getelementptr inbounds %struct.ImGuiTable, ptr %0, i32 0, i32 11
  %1 = load i32, ptr %SettingsOffset, align 4
  %cmp = icmp ne i32 %1, -1
  br i1 %cmp, label %if.then, label %if.end4

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr @GImGui, align 8
  store ptr %2, ptr %g, align 8
  %3 = load ptr, ptr %g, align 8
  %SettingsTables = getelementptr inbounds %struct.ImGuiContext, ptr %3, i32 0, i32 218
  %4 = load ptr, ptr %table.addr, align 8
  %SettingsOffset1 = getelementptr inbounds %struct.ImGuiTable, ptr %4, i32 0, i32 11
  %5 = load i32, ptr %SettingsOffset1, align 4
  %call = call noundef ptr @_ZN13ImChunkStreamI18ImGuiTableSettingsE15ptr_from_offsetEi(ptr noundef nonnull align 8 dereferenceable(16) %SettingsTables, i32 noundef %5)
  store ptr %call, ptr %settings, align 8
  %6 = load ptr, ptr %settings, align 8
  %ColumnsCountMax = getelementptr inbounds %struct.ImGuiTableSettings, ptr %6, i32 0, i32 4
  %7 = load i16, ptr %ColumnsCountMax, align 2
  %conv = sext i16 %7 to i32
  %8 = load ptr, ptr %table.addr, align 8
  %ColumnsCount = getelementptr inbounds %struct.ImGuiTable, ptr %8, i32 0, i32 13
  %9 = load i32, ptr %ColumnsCount, align 4
  %cmp2 = icmp sge i32 %conv, %9
  br i1 %cmp2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %10 = load ptr, ptr %settings, align 8
  store ptr %10, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %if.then
  %11 = load ptr, ptr %settings, align 8
  %ID = getelementptr inbounds %struct.ImGuiTableSettings, ptr %11, i32 0, i32 0
  store i32 0, ptr %ID, align 4
  br label %if.end4

if.end4:                                          ; preds = %if.end, %entry
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end4, %if.then3
  %12 = load ptr, ptr %retval, align 8
  ret ptr %12
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef ptr @_ZN13ImChunkStreamI18ImGuiTableSettingsE15ptr_from_offsetEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %off) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %off.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %off, ptr %off.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Buf = getelementptr inbounds %struct.ImChunkStream.28, ptr %this1, i32 0, i32 0
  %Data = getelementptr inbounds %struct.ImVector.25, ptr %Buf, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %1 = load i32, ptr %off.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr inbounds i8, ptr %0, i64 %idx.ext
  ret ptr %add.ptr
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i32 @_ZN13ImChunkStreamI18ImGuiTableSettingsE15offset_from_ptrEPKS0_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %p) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %off = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %Buf = getelementptr inbounds %struct.ImChunkStream.28, ptr %this1, i32 0, i32 0
  %Data = getelementptr inbounds %struct.ImVector.25, ptr %Buf, i32 0, i32 2
  %1 = load ptr, ptr %Data, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, ptr %off, align 8
  %2 = load i64, ptr %off, align 8
  %conv = trunc i64 %2 to i32
  ret i32 %conv
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef ptr @_ZN18ImGuiTableSettings17GetColumnSettingsEv(ptr noundef nonnull align 4 dereferenceable(17) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %add.ptr = getelementptr inbounds %struct.ImGuiTableSettings, ptr %this1, i64 1
  ret ptr %add.ptr
}

declare void @_ZN5ImGui20MarkIniSettingsDirtyEv() #1

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui31TableSettingsAddSettingsHandlerEv() #0 {
entry:
  %ini_handler = alloca %struct.ImGuiSettingsHandler, align 8
  call void @_ZN20ImGuiSettingsHandlerC2Ev(ptr noundef nonnull align 8 dereferenceable(72) %ini_handler)
  %TypeName = getelementptr inbounds %struct.ImGuiSettingsHandler, ptr %ini_handler, i32 0, i32 0
  store ptr @.str.8, ptr %TypeName, align 8
  %call = call noundef i32 @_Z9ImHashStrPKcmj(ptr noundef @.str.8, i64 noundef 0, i32 noundef 0)
  %TypeHash = getelementptr inbounds %struct.ImGuiSettingsHandler, ptr %ini_handler, i32 0, i32 1
  store i32 %call, ptr %TypeHash, align 8
  %ClearAllFn = getelementptr inbounds %struct.ImGuiSettingsHandler, ptr %ini_handler, i32 0, i32 2
  store ptr @_ZL29TableSettingsHandler_ClearAllP12ImGuiContextP20ImGuiSettingsHandler, ptr %ClearAllFn, align 8
  %ReadOpenFn = getelementptr inbounds %struct.ImGuiSettingsHandler, ptr %ini_handler, i32 0, i32 4
  store ptr @_ZL29TableSettingsHandler_ReadOpenP12ImGuiContextP20ImGuiSettingsHandlerPKc, ptr %ReadOpenFn, align 8
  %ReadLineFn = getelementptr inbounds %struct.ImGuiSettingsHandler, ptr %ini_handler, i32 0, i32 5
  store ptr @_ZL29TableSettingsHandler_ReadLineP12ImGuiContextP20ImGuiSettingsHandlerPvPKc, ptr %ReadLineFn, align 8
  %ApplyAllFn = getelementptr inbounds %struct.ImGuiSettingsHandler, ptr %ini_handler, i32 0, i32 6
  store ptr @_ZL29TableSettingsHandler_ApplyAllP12ImGuiContextP20ImGuiSettingsHandler, ptr %ApplyAllFn, align 8
  %WriteAllFn = getelementptr inbounds %struct.ImGuiSettingsHandler, ptr %ini_handler, i32 0, i32 7
  store ptr @_ZL29TableSettingsHandler_WriteAllP12ImGuiContextP20ImGuiSettingsHandlerP15ImGuiTextBuffer, ptr %WriteAllFn, align 8
  call void @_ZN5ImGui18AddSettingsHandlerEPK20ImGuiSettingsHandler(ptr noundef %ini_handler)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN20ImGuiSettingsHandlerC2Ev(ptr noundef nonnull align 8 dereferenceable(72) %this) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %this1, i8 0, i64 72, i1 false)
  ret void
}

; Function Attrs: mustprogress uwtable
define internal void @_ZL29TableSettingsHandler_ClearAllP12ImGuiContextP20ImGuiSettingsHandler(ptr noundef %ctx, ptr noundef %0) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %.addr = alloca ptr, align 8
  %g = alloca ptr, align 8
  %i = alloca i32, align 4
  %table = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %0, ptr %.addr, align 8
  %1 = load ptr, ptr %ctx.addr, align 8
  store ptr %1, ptr %g, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, ptr %i, align 4
  %3 = load ptr, ptr %g, align 8
  %Tables = getelementptr inbounds %struct.ImGuiContext, ptr %3, i32 0, i32 167
  %call = call noundef i32 @_ZNK6ImPoolI10ImGuiTableE10GetMapSizeEv(ptr noundef nonnull align 8 dereferenceable(40) %Tables)
  %cmp = icmp ne i32 %2, %call
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load ptr, ptr %g, align 8
  %Tables1 = getelementptr inbounds %struct.ImGuiContext, ptr %4, i32 0, i32 167
  %5 = load i32, ptr %i, align 4
  %call2 = call noundef ptr @_ZN6ImPoolI10ImGuiTableE13TryGetMapDataEi(ptr noundef nonnull align 8 dereferenceable(40) %Tables1, i32 noundef %5)
  store ptr %call2, ptr %table, align 8
  %6 = load ptr, ptr %table, align 8
  %tobool = icmp ne ptr %6, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %7 = load ptr, ptr %table, align 8
  %SettingsOffset = getelementptr inbounds %struct.ImGuiTable, ptr %7, i32 0, i32 11
  store i32 -1, ptr %SettingsOffset, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %8 = load i32, ptr %i, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !58

for.end:                                          ; preds = %for.cond
  %9 = load ptr, ptr %g, align 8
  %SettingsTables = getelementptr inbounds %struct.ImGuiContext, ptr %9, i32 0, i32 218
  call void @_ZN13ImChunkStreamI18ImGuiTableSettingsE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %SettingsTables)
  ret void
}

; Function Attrs: mustprogress uwtable
define internal noundef ptr @_ZL29TableSettingsHandler_ReadOpenP12ImGuiContextP20ImGuiSettingsHandlerPKc(ptr noundef %0, ptr noundef %1, ptr noundef %name) #0 {
entry:
  %retval = alloca ptr, align 8
  %.addr = alloca ptr, align 8
  %.addr1 = alloca ptr, align 8
  %name.addr = alloca ptr, align 8
  %id = alloca i32, align 4
  %columns_count = alloca i32, align 4
  %settings = alloca ptr, align 8
  store ptr %0, ptr %.addr, align 8
  store ptr %1, ptr %.addr1, align 8
  store ptr %name, ptr %name.addr, align 8
  store i32 0, ptr %id, align 4
  store i32 0, ptr %columns_count, align 4
  %2 = load ptr, ptr %name.addr, align 8
  %call = call i32 (ptr, ptr, ...) @__isoc99_sscanf(ptr noundef %2, ptr noundef @.str.38, ptr noundef %id, ptr noundef %columns_count) #10
  %cmp = icmp slt i32 %call, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load i32, ptr %id, align 4
  %call2 = call noundef ptr @_ZN5ImGui21TableSettingsFindByIDEj(i32 noundef %3)
  store ptr %call2, ptr %settings, align 8
  %4 = load ptr, ptr %settings, align 8
  %tobool = icmp ne ptr %4, null
  br i1 %tobool, label %if.then3, label %if.end9

if.then3:                                         ; preds = %if.end
  %5 = load ptr, ptr %settings, align 8
  %ColumnsCountMax = getelementptr inbounds %struct.ImGuiTableSettings, ptr %5, i32 0, i32 4
  %6 = load i16, ptr %ColumnsCountMax, align 2
  %conv = sext i16 %6 to i32
  %7 = load i32, ptr %columns_count, align 4
  %cmp4 = icmp sge i32 %conv, %7
  br i1 %cmp4, label %if.then5, label %if.end8

if.then5:                                         ; preds = %if.then3
  %8 = load ptr, ptr %settings, align 8
  %9 = load i32, ptr %id, align 4
  %10 = load i32, ptr %columns_count, align 4
  %11 = load ptr, ptr %settings, align 8
  %ColumnsCountMax6 = getelementptr inbounds %struct.ImGuiTableSettings, ptr %11, i32 0, i32 4
  %12 = load i16, ptr %ColumnsCountMax6, align 2
  %conv7 = sext i16 %12 to i32
  call void @_ZL17TableSettingsInitP18ImGuiTableSettingsjii(ptr noundef %8, i32 noundef %9, i32 noundef %10, i32 noundef %conv7)
  %13 = load ptr, ptr %settings, align 8
  store ptr %13, ptr %retval, align 8
  br label %return

if.end8:                                          ; preds = %if.then3
  %14 = load ptr, ptr %settings, align 8
  %ID = getelementptr inbounds %struct.ImGuiTableSettings, ptr %14, i32 0, i32 0
  store i32 0, ptr %ID, align 4
  br label %if.end9

if.end9:                                          ; preds = %if.end8, %if.end
  %15 = load i32, ptr %id, align 4
  %16 = load i32, ptr %columns_count, align 4
  %call10 = call noundef ptr @_ZN5ImGui19TableSettingsCreateEji(i32 noundef %15, i32 noundef %16)
  store ptr %call10, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end9, %if.then5, %if.then
  %17 = load ptr, ptr %retval, align 8
  ret ptr %17
}

; Function Attrs: mustprogress uwtable
define internal void @_ZL29TableSettingsHandler_ReadLineP12ImGuiContextP20ImGuiSettingsHandlerPvPKc(ptr noundef %0, ptr noundef %1, ptr noundef %entry2, ptr noundef %line) #0 {
entry:
  %.addr = alloca ptr, align 8
  %.addr1 = alloca ptr, align 8
  %entry.addr = alloca ptr, align 8
  %line.addr = alloca ptr, align 8
  %settings = alloca ptr, align 8
  %f = alloca float, align 4
  %column_n = alloca i32, align 4
  %r = alloca i32, align 4
  %n = alloca i32, align 4
  %c = alloca i8, align 1
  %column = alloca ptr, align 8
  store ptr %0, ptr %.addr, align 8
  store ptr %1, ptr %.addr1, align 8
  store ptr %entry2, ptr %entry.addr, align 8
  store ptr %line, ptr %line.addr, align 8
  %2 = load ptr, ptr %entry.addr, align 8
  store ptr %2, ptr %settings, align 8
  store float 0.000000e+00, ptr %f, align 4
  store i32 0, ptr %column_n, align 4
  store i32 0, ptr %r, align 4
  store i32 0, ptr %n, align 4
  %3 = load ptr, ptr %line.addr, align 8
  %call = call i32 (ptr, ptr, ...) @__isoc99_sscanf(ptr noundef %3, ptr noundef @.str.39, ptr noundef %f) #10
  %cmp = icmp eq i32 %call, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load float, ptr %f, align 4
  %5 = load ptr, ptr %settings, align 8
  %RefScale = getelementptr inbounds %struct.ImGuiTableSettings, ptr %5, i32 0, i32 2
  store float %4, ptr %RefScale, align 4
  br label %if.end84

if.end:                                           ; preds = %entry
  %6 = load ptr, ptr %line.addr, align 8
  %call3 = call i32 (ptr, ptr, ...) @__isoc99_sscanf(ptr noundef %6, ptr noundef @.str.40, ptr noundef %column_n, ptr noundef %r) #10
  %cmp4 = icmp eq i32 %call3, 1
  br i1 %cmp4, label %if.then5, label %if.end84

if.then5:                                         ; preds = %if.end
  %7 = load i32, ptr %column_n, align 4
  %cmp6 = icmp slt i32 %7, 0
  br i1 %cmp6, label %if.then8, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then5
  %8 = load i32, ptr %column_n, align 4
  %9 = load ptr, ptr %settings, align 8
  %ColumnsCount = getelementptr inbounds %struct.ImGuiTableSettings, ptr %9, i32 0, i32 3
  %10 = load i16, ptr %ColumnsCount, align 4
  %conv = sext i16 %10 to i32
  %cmp7 = icmp sge i32 %8, %conv
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %lor.lhs.false, %if.then5
  br label %if.end84

if.end9:                                          ; preds = %lor.lhs.false
  %11 = load ptr, ptr %line.addr, align 8
  %12 = load i32, ptr %r, align 4
  %idx.ext = sext i32 %12 to i64
  %add.ptr = getelementptr inbounds i8, ptr %11, i64 %idx.ext
  %call10 = call noundef ptr @_Z14ImStrSkipBlankPKc(ptr noundef %add.ptr)
  store ptr %call10, ptr %line.addr, align 8
  store i8 0, ptr %c, align 1
  %13 = load ptr, ptr %settings, align 8
  %call11 = call noundef ptr @_ZN18ImGuiTableSettings17GetColumnSettingsEv(ptr noundef nonnull align 4 dereferenceable(17) %13)
  %14 = load i32, ptr %column_n, align 4
  %idx.ext12 = sext i32 %14 to i64
  %add.ptr13 = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %call11, i64 %idx.ext12
  store ptr %add.ptr13, ptr %column, align 8
  %15 = load i32, ptr %column_n, align 4
  %conv14 = trunc i32 %15 to i16
  %16 = load ptr, ptr %column, align 8
  %Index = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %16, i32 0, i32 2
  store i16 %conv14, ptr %Index, align 4
  %17 = load ptr, ptr %line.addr, align 8
  %call15 = call i32 (ptr, ptr, ...) @__isoc99_sscanf(ptr noundef %17, ptr noundef @.str.41, ptr noundef %n, ptr noundef %r) #10
  %cmp16 = icmp eq i32 %call15, 1
  br i1 %cmp16, label %if.then17, label %if.end21

if.then17:                                        ; preds = %if.end9
  %18 = load ptr, ptr %line.addr, align 8
  %19 = load i32, ptr %r, align 4
  %idx.ext18 = sext i32 %19 to i64
  %add.ptr19 = getelementptr inbounds i8, ptr %18, i64 %idx.ext18
  %call20 = call noundef ptr @_Z14ImStrSkipBlankPKc(ptr noundef %add.ptr19)
  store ptr %call20, ptr %line.addr, align 8
  %20 = load i32, ptr %n, align 4
  %21 = load ptr, ptr %column, align 8
  %UserID = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %21, i32 0, i32 1
  store i32 %20, ptr %UserID, align 4
  br label %if.end21

if.end21:                                         ; preds = %if.then17, %if.end9
  %22 = load ptr, ptr %line.addr, align 8
  %call22 = call i32 (ptr, ptr, ...) @__isoc99_sscanf(ptr noundef %22, ptr noundef @.str.42, ptr noundef %n, ptr noundef %r) #10
  %cmp23 = icmp eq i32 %call22, 1
  br i1 %cmp23, label %if.then24, label %if.end29

if.then24:                                        ; preds = %if.end21
  %23 = load ptr, ptr %line.addr, align 8
  %24 = load i32, ptr %r, align 4
  %idx.ext25 = sext i32 %24 to i64
  %add.ptr26 = getelementptr inbounds i8, ptr %23, i64 %idx.ext25
  %call27 = call noundef ptr @_Z14ImStrSkipBlankPKc(ptr noundef %add.ptr26)
  store ptr %call27, ptr %line.addr, align 8
  %25 = load i32, ptr %n, align 4
  %conv28 = sitofp i32 %25 to float
  %26 = load ptr, ptr %column, align 8
  %WidthOrWeight = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %26, i32 0, i32 0
  store float %conv28, ptr %WidthOrWeight, align 4
  %27 = load ptr, ptr %column, align 8
  %IsStretch = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %27, i32 0, i32 5
  %bf.load = load i8, ptr %IsStretch, align 2
  %bf.clear = and i8 %bf.load, -9
  %bf.set = or i8 %bf.clear, 0
  store i8 %bf.set, ptr %IsStretch, align 2
  %28 = load ptr, ptr %settings, align 8
  %SaveFlags = getelementptr inbounds %struct.ImGuiTableSettings, ptr %28, i32 0, i32 1
  %29 = load i32, ptr %SaveFlags, align 4
  %or = or i32 %29, 1
  store i32 %or, ptr %SaveFlags, align 4
  br label %if.end29

if.end29:                                         ; preds = %if.then24, %if.end21
  %30 = load ptr, ptr %line.addr, align 8
  %call30 = call i32 (ptr, ptr, ...) @__isoc99_sscanf(ptr noundef %30, ptr noundef @.str.43, ptr noundef %f, ptr noundef %r) #10
  %cmp31 = icmp eq i32 %call30, 1
  br i1 %cmp31, label %if.then32, label %if.end43

if.then32:                                        ; preds = %if.end29
  %31 = load ptr, ptr %line.addr, align 8
  %32 = load i32, ptr %r, align 4
  %idx.ext33 = sext i32 %32 to i64
  %add.ptr34 = getelementptr inbounds i8, ptr %31, i64 %idx.ext33
  %call35 = call noundef ptr @_Z14ImStrSkipBlankPKc(ptr noundef %add.ptr34)
  store ptr %call35, ptr %line.addr, align 8
  %33 = load float, ptr %f, align 4
  %34 = load ptr, ptr %column, align 8
  %WidthOrWeight36 = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %34, i32 0, i32 0
  store float %33, ptr %WidthOrWeight36, align 4
  %35 = load ptr, ptr %column, align 8
  %IsStretch37 = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %35, i32 0, i32 5
  %bf.load38 = load i8, ptr %IsStretch37, align 2
  %bf.clear39 = and i8 %bf.load38, -9
  %bf.set40 = or i8 %bf.clear39, 8
  store i8 %bf.set40, ptr %IsStretch37, align 2
  %36 = load ptr, ptr %settings, align 8
  %SaveFlags41 = getelementptr inbounds %struct.ImGuiTableSettings, ptr %36, i32 0, i32 1
  %37 = load i32, ptr %SaveFlags41, align 4
  %or42 = or i32 %37, 1
  store i32 %or42, ptr %SaveFlags41, align 4
  br label %if.end43

if.end43:                                         ; preds = %if.then32, %if.end29
  %38 = load ptr, ptr %line.addr, align 8
  %call44 = call i32 (ptr, ptr, ...) @__isoc99_sscanf(ptr noundef %38, ptr noundef @.str.44, ptr noundef %n, ptr noundef %r) #10
  %cmp45 = icmp eq i32 %call44, 1
  br i1 %cmp45, label %if.then46, label %if.end56

if.then46:                                        ; preds = %if.end43
  %39 = load ptr, ptr %line.addr, align 8
  %40 = load i32, ptr %r, align 4
  %idx.ext47 = sext i32 %40 to i64
  %add.ptr48 = getelementptr inbounds i8, ptr %39, i64 %idx.ext47
  %call49 = call noundef ptr @_Z14ImStrSkipBlankPKc(ptr noundef %add.ptr48)
  store ptr %call49, ptr %line.addr, align 8
  %41 = load i32, ptr %n, align 4
  %conv50 = trunc i32 %41 to i8
  %42 = load ptr, ptr %column, align 8
  %IsEnabled = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %42, i32 0, i32 5
  %bf.load51 = load i8, ptr %IsEnabled, align 2
  %bf.value = and i8 %conv50, 1
  %bf.shl = shl i8 %bf.value, 2
  %bf.clear52 = and i8 %bf.load51, -5
  %bf.set53 = or i8 %bf.clear52, %bf.shl
  store i8 %bf.set53, ptr %IsEnabled, align 2
  %43 = load ptr, ptr %settings, align 8
  %SaveFlags54 = getelementptr inbounds %struct.ImGuiTableSettings, ptr %43, i32 0, i32 1
  %44 = load i32, ptr %SaveFlags54, align 4
  %or55 = or i32 %44, 4
  store i32 %or55, ptr %SaveFlags54, align 4
  br label %if.end56

if.end56:                                         ; preds = %if.then46, %if.end43
  %45 = load ptr, ptr %line.addr, align 8
  %call57 = call i32 (ptr, ptr, ...) @__isoc99_sscanf(ptr noundef %45, ptr noundef @.str.45, ptr noundef %n, ptr noundef %r) #10
  %cmp58 = icmp eq i32 %call57, 1
  br i1 %cmp58, label %if.then59, label %if.end66

if.then59:                                        ; preds = %if.end56
  %46 = load ptr, ptr %line.addr, align 8
  %47 = load i32, ptr %r, align 4
  %idx.ext60 = sext i32 %47 to i64
  %add.ptr61 = getelementptr inbounds i8, ptr %46, i64 %idx.ext60
  %call62 = call noundef ptr @_Z14ImStrSkipBlankPKc(ptr noundef %add.ptr61)
  store ptr %call62, ptr %line.addr, align 8
  %48 = load i32, ptr %n, align 4
  %conv63 = trunc i32 %48 to i16
  %49 = load ptr, ptr %column, align 8
  %DisplayOrder = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %49, i32 0, i32 3
  store i16 %conv63, ptr %DisplayOrder, align 2
  %50 = load ptr, ptr %settings, align 8
  %SaveFlags64 = getelementptr inbounds %struct.ImGuiTableSettings, ptr %50, i32 0, i32 1
  %51 = load i32, ptr %SaveFlags64, align 4
  %or65 = or i32 %51, 2
  store i32 %or65, ptr %SaveFlags64, align 4
  br label %if.end66

if.end66:                                         ; preds = %if.then59, %if.end56
  %52 = load ptr, ptr %line.addr, align 8
  %call67 = call i32 (ptr, ptr, ...) @__isoc99_sscanf(ptr noundef %52, ptr noundef @.str.46, ptr noundef %n, ptr noundef %c, ptr noundef %r) #10
  %cmp68 = icmp eq i32 %call67, 2
  br i1 %cmp68, label %if.then69, label %if.end83

if.then69:                                        ; preds = %if.end66
  %53 = load ptr, ptr %line.addr, align 8
  %54 = load i32, ptr %r, align 4
  %idx.ext70 = sext i32 %54 to i64
  %add.ptr71 = getelementptr inbounds i8, ptr %53, i64 %idx.ext70
  %call72 = call noundef ptr @_Z14ImStrSkipBlankPKc(ptr noundef %add.ptr71)
  store ptr %call72, ptr %line.addr, align 8
  %55 = load i32, ptr %n, align 4
  %conv73 = trunc i32 %55 to i16
  %56 = load ptr, ptr %column, align 8
  %SortOrder = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %56, i32 0, i32 4
  store i16 %conv73, ptr %SortOrder, align 4
  %57 = load i8, ptr %c, align 1
  %conv74 = sext i8 %57 to i32
  %cmp75 = icmp eq i32 %conv74, 94
  %cond = select i1 %cmp75, i32 2, i32 1
  %conv76 = trunc i32 %cond to i8
  %58 = load ptr, ptr %column, align 8
  %SortDirection = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %58, i32 0, i32 5
  %bf.load77 = load i8, ptr %SortDirection, align 2
  %bf.value78 = and i8 %conv76, 3
  %bf.clear79 = and i8 %bf.load77, -4
  %bf.set80 = or i8 %bf.clear79, %bf.value78
  store i8 %bf.set80, ptr %SortDirection, align 2
  %59 = load ptr, ptr %settings, align 8
  %SaveFlags81 = getelementptr inbounds %struct.ImGuiTableSettings, ptr %59, i32 0, i32 1
  %60 = load i32, ptr %SaveFlags81, align 4
  %or82 = or i32 %60, 8
  store i32 %or82, ptr %SaveFlags81, align 4
  br label %if.end83

if.end83:                                         ; preds = %if.then69, %if.end66
  br label %if.end84

if.end84:                                         ; preds = %if.end83, %if.then8, %if.end, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define internal void @_ZL29TableSettingsHandler_ApplyAllP12ImGuiContextP20ImGuiSettingsHandler(ptr noundef %ctx, ptr noundef %0) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %.addr = alloca ptr, align 8
  %g = alloca ptr, align 8
  %i = alloca i32, align 4
  %table = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %0, ptr %.addr, align 8
  %1 = load ptr, ptr %ctx.addr, align 8
  store ptr %1, ptr %g, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, ptr %i, align 4
  %3 = load ptr, ptr %g, align 8
  %Tables = getelementptr inbounds %struct.ImGuiContext, ptr %3, i32 0, i32 167
  %call = call noundef i32 @_ZNK6ImPoolI10ImGuiTableE10GetMapSizeEv(ptr noundef nonnull align 8 dereferenceable(40) %Tables)
  %cmp = icmp ne i32 %2, %call
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load ptr, ptr %g, align 8
  %Tables1 = getelementptr inbounds %struct.ImGuiContext, ptr %4, i32 0, i32 167
  %5 = load i32, ptr %i, align 4
  %call2 = call noundef ptr @_ZN6ImPoolI10ImGuiTableE13TryGetMapDataEi(ptr noundef nonnull align 8 dereferenceable(40) %Tables1, i32 noundef %5)
  store ptr %call2, ptr %table, align 8
  %6 = load ptr, ptr %table, align 8
  %tobool = icmp ne ptr %6, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %7 = load ptr, ptr %table, align 8
  %IsSettingsRequestLoad = getelementptr inbounds %struct.ImGuiTable, ptr %7, i32 0, i32 99
  store i8 1, ptr %IsSettingsRequestLoad, align 1
  %8 = load ptr, ptr %table, align 8
  %SettingsOffset = getelementptr inbounds %struct.ImGuiTable, ptr %8, i32 0, i32 11
  store i32 -1, ptr %SettingsOffset, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %9 = load i32, ptr %i, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !59

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress uwtable
define internal void @_ZL29TableSettingsHandler_WriteAllP12ImGuiContextP20ImGuiSettingsHandlerP15ImGuiTextBuffer(ptr noundef %ctx, ptr noundef %handler, ptr noundef %buf) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %handler.addr = alloca ptr, align 8
  %buf.addr = alloca ptr, align 8
  %g = alloca ptr, align 8
  %settings = alloca ptr, align 8
  %save_size = alloca i8, align 1
  %save_visible = alloca i8, align 1
  %save_order = alloca i8, align 1
  %save_sort = alloca i8, align 1
  %column = alloca ptr, align 8
  %column_n = alloca i32, align 4
  %save_column = alloca i8, align 1
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %handler, ptr %handler.addr, align 8
  store ptr %buf, ptr %buf.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %g, align 8
  %SettingsTables = getelementptr inbounds %struct.ImGuiContext, ptr %1, i32 0, i32 218
  %call = call noundef ptr @_ZN13ImChunkStreamI18ImGuiTableSettingsE5beginEv(ptr noundef nonnull align 8 dereferenceable(16) %SettingsTables)
  store ptr %call, ptr %settings, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc98, %entry
  %2 = load ptr, ptr %settings, align 8
  %cmp = icmp ne ptr %2, null
  br i1 %cmp, label %for.body, label %for.end101

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %settings, align 8
  %ID = getelementptr inbounds %struct.ImGuiTableSettings, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %ID, align 4
  %cmp1 = icmp eq i32 %4, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %for.inc98

if.end:                                           ; preds = %for.body
  %5 = load ptr, ptr %settings, align 8
  %SaveFlags = getelementptr inbounds %struct.ImGuiTableSettings, ptr %5, i32 0, i32 1
  %6 = load i32, ptr %SaveFlags, align 4
  %and = and i32 %6, 1
  %cmp2 = icmp ne i32 %and, 0
  %frombool = zext i1 %cmp2 to i8
  store i8 %frombool, ptr %save_size, align 1
  %7 = load ptr, ptr %settings, align 8
  %SaveFlags3 = getelementptr inbounds %struct.ImGuiTableSettings, ptr %7, i32 0, i32 1
  %8 = load i32, ptr %SaveFlags3, align 4
  %and4 = and i32 %8, 4
  %cmp5 = icmp ne i32 %and4, 0
  %frombool6 = zext i1 %cmp5 to i8
  store i8 %frombool6, ptr %save_visible, align 1
  %9 = load ptr, ptr %settings, align 8
  %SaveFlags7 = getelementptr inbounds %struct.ImGuiTableSettings, ptr %9, i32 0, i32 1
  %10 = load i32, ptr %SaveFlags7, align 4
  %and8 = and i32 %10, 2
  %cmp9 = icmp ne i32 %and8, 0
  %frombool10 = zext i1 %cmp9 to i8
  store i8 %frombool10, ptr %save_order, align 1
  %11 = load ptr, ptr %settings, align 8
  %SaveFlags11 = getelementptr inbounds %struct.ImGuiTableSettings, ptr %11, i32 0, i32 1
  %12 = load i32, ptr %SaveFlags11, align 4
  %and12 = and i32 %12, 8
  %cmp13 = icmp ne i32 %and12, 0
  %frombool14 = zext i1 %cmp13 to i8
  store i8 %frombool14, ptr %save_sort, align 1
  %13 = load i8, ptr %save_size, align 1
  %tobool = trunc i8 %13 to i1
  br i1 %tobool, label %if.end21, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %14 = load i8, ptr %save_visible, align 1
  %tobool15 = trunc i8 %14 to i1
  br i1 %tobool15, label %if.end21, label %land.lhs.true16

land.lhs.true16:                                  ; preds = %land.lhs.true
  %15 = load i8, ptr %save_order, align 1
  %tobool17 = trunc i8 %15 to i1
  br i1 %tobool17, label %if.end21, label %land.lhs.true18

land.lhs.true18:                                  ; preds = %land.lhs.true16
  %16 = load i8, ptr %save_sort, align 1
  %tobool19 = trunc i8 %16 to i1
  br i1 %tobool19, label %if.end21, label %if.then20

if.then20:                                        ; preds = %land.lhs.true18
  br label %for.inc98

if.end21:                                         ; preds = %land.lhs.true18, %land.lhs.true16, %land.lhs.true, %if.end
  %17 = load ptr, ptr %buf.addr, align 8
  %18 = load ptr, ptr %buf.addr, align 8
  %call22 = call noundef i32 @_ZNK15ImGuiTextBuffer4sizeEv(ptr noundef nonnull align 8 dereferenceable(16) %18)
  %add = add nsw i32 %call22, 30
  %19 = load ptr, ptr %settings, align 8
  %ColumnsCount = getelementptr inbounds %struct.ImGuiTableSettings, ptr %19, i32 0, i32 3
  %20 = load i16, ptr %ColumnsCount, align 4
  %conv = sext i16 %20 to i32
  %mul = mul nsw i32 %conv, 50
  %add23 = add nsw i32 %add, %mul
  call void @_ZN15ImGuiTextBuffer7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %17, i32 noundef %add23)
  %21 = load ptr, ptr %buf.addr, align 8
  %22 = load ptr, ptr %handler.addr, align 8
  %TypeName = getelementptr inbounds %struct.ImGuiSettingsHandler, ptr %22, i32 0, i32 0
  %23 = load ptr, ptr %TypeName, align 8
  %24 = load ptr, ptr %settings, align 8
  %ID24 = getelementptr inbounds %struct.ImGuiTableSettings, ptr %24, i32 0, i32 0
  %25 = load i32, ptr %ID24, align 4
  %26 = load ptr, ptr %settings, align 8
  %ColumnsCount25 = getelementptr inbounds %struct.ImGuiTableSettings, ptr %26, i32 0, i32 3
  %27 = load i16, ptr %ColumnsCount25, align 4
  %conv26 = sext i16 %27 to i32
  call void (ptr, ptr, ...) @_ZN15ImGuiTextBuffer7appendfEPKcz(ptr noundef nonnull align 8 dereferenceable(16) %21, ptr noundef @.str.47, ptr noundef %23, i32 noundef %25, i32 noundef %conv26)
  %28 = load ptr, ptr %settings, align 8
  %RefScale = getelementptr inbounds %struct.ImGuiTableSettings, ptr %28, i32 0, i32 2
  %29 = load float, ptr %RefScale, align 4
  %cmp27 = fcmp une float %29, 0.000000e+00
  br i1 %cmp27, label %if.then28, label %if.end31

if.then28:                                        ; preds = %if.end21
  %30 = load ptr, ptr %buf.addr, align 8
  %31 = load ptr, ptr %settings, align 8
  %RefScale29 = getelementptr inbounds %struct.ImGuiTableSettings, ptr %31, i32 0, i32 2
  %32 = load float, ptr %RefScale29, align 4
  %conv30 = fpext float %32 to double
  call void (ptr, ptr, ...) @_ZN15ImGuiTextBuffer7appendfEPKcz(ptr noundef nonnull align 8 dereferenceable(16) %30, ptr noundef @.str.48, double noundef %conv30)
  br label %if.end31

if.end31:                                         ; preds = %if.then28, %if.end21
  %33 = load ptr, ptr %settings, align 8
  %call32 = call noundef ptr @_ZN18ImGuiTableSettings17GetColumnSettingsEv(ptr noundef nonnull align 4 dereferenceable(17) %33)
  store ptr %call32, ptr %column, align 8
  store i32 0, ptr %column_n, align 4
  br label %for.cond33

for.cond33:                                       ; preds = %for.inc, %if.end31
  %34 = load i32, ptr %column_n, align 4
  %35 = load ptr, ptr %settings, align 8
  %ColumnsCount34 = getelementptr inbounds %struct.ImGuiTableSettings, ptr %35, i32 0, i32 3
  %36 = load i16, ptr %ColumnsCount34, align 4
  %conv35 = sext i16 %36 to i32
  %cmp36 = icmp slt i32 %34, %conv35
  br i1 %cmp36, label %for.body37, label %for.end

for.body37:                                       ; preds = %for.cond33
  %37 = load ptr, ptr %column, align 8
  %UserID = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %37, i32 0, i32 1
  %38 = load i32, ptr %UserID, align 4
  %cmp38 = icmp ne i32 %38, 0
  br i1 %cmp38, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body37
  %39 = load i8, ptr %save_size, align 1
  %tobool39 = trunc i8 %39 to i1
  br i1 %tobool39, label %lor.end, label %lor.lhs.false40

lor.lhs.false40:                                  ; preds = %lor.lhs.false
  %40 = load i8, ptr %save_visible, align 1
  %tobool41 = trunc i8 %40 to i1
  br i1 %tobool41, label %lor.end, label %lor.lhs.false42

lor.lhs.false42:                                  ; preds = %lor.lhs.false40
  %41 = load i8, ptr %save_order, align 1
  %tobool43 = trunc i8 %41 to i1
  br i1 %tobool43, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false42
  %42 = load i8, ptr %save_sort, align 1
  %tobool44 = trunc i8 %42 to i1
  br i1 %tobool44, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %lor.rhs
  %43 = load ptr, ptr %column, align 8
  %SortOrder = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %43, i32 0, i32 4
  %44 = load i16, ptr %SortOrder, align 4
  %conv45 = sext i16 %44 to i32
  %cmp46 = icmp ne i32 %conv45, -1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %lor.rhs
  %45 = phi i1 [ false, %lor.rhs ], [ %cmp46, %land.rhs ]
  br label %lor.end

lor.end:                                          ; preds = %land.end, %lor.lhs.false42, %lor.lhs.false40, %lor.lhs.false, %for.body37
  %46 = phi i1 [ true, %lor.lhs.false42 ], [ true, %lor.lhs.false40 ], [ true, %lor.lhs.false ], [ true, %for.body37 ], [ %45, %land.end ]
  %frombool47 = zext i1 %46 to i8
  store i8 %frombool47, ptr %save_column, align 1
  %47 = load i8, ptr %save_column, align 1
  %tobool48 = trunc i8 %47 to i1
  br i1 %tobool48, label %if.end50, label %if.then49

if.then49:                                        ; preds = %lor.end
  br label %for.inc

if.end50:                                         ; preds = %lor.end
  %48 = load ptr, ptr %buf.addr, align 8
  %49 = load i32, ptr %column_n, align 4
  call void (ptr, ptr, ...) @_ZN15ImGuiTextBuffer7appendfEPKcz(ptr noundef nonnull align 8 dereferenceable(16) %48, ptr noundef @.str.49, i32 noundef %49)
  %50 = load ptr, ptr %column, align 8
  %UserID51 = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %50, i32 0, i32 1
  %51 = load i32, ptr %UserID51, align 4
  %cmp52 = icmp ne i32 %51, 0
  br i1 %cmp52, label %if.then53, label %if.end55

if.then53:                                        ; preds = %if.end50
  %52 = load ptr, ptr %buf.addr, align 8
  %53 = load ptr, ptr %column, align 8
  %UserID54 = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %53, i32 0, i32 1
  %54 = load i32, ptr %UserID54, align 4
  call void (ptr, ptr, ...) @_ZN15ImGuiTextBuffer7appendfEPKcz(ptr noundef nonnull align 8 dereferenceable(16) %52, ptr noundef @.str.50, i32 noundef %54)
  br label %if.end55

if.end55:                                         ; preds = %if.then53, %if.end50
  %55 = load i8, ptr %save_size, align 1
  %tobool56 = trunc i8 %55 to i1
  br i1 %tobool56, label %land.lhs.true57, label %if.end61

land.lhs.true57:                                  ; preds = %if.end55
  %56 = load ptr, ptr %column, align 8
  %IsStretch = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %56, i32 0, i32 5
  %bf.load = load i8, ptr %IsStretch, align 2
  %bf.lshr = lshr i8 %bf.load, 3
  %bf.clear = and i8 %bf.lshr, 1
  %tobool58 = icmp ne i8 %bf.clear, 0
  br i1 %tobool58, label %if.then59, label %if.end61

if.then59:                                        ; preds = %land.lhs.true57
  %57 = load ptr, ptr %buf.addr, align 8
  %58 = load ptr, ptr %column, align 8
  %WidthOrWeight = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %58, i32 0, i32 0
  %59 = load float, ptr %WidthOrWeight, align 4
  %conv60 = fpext float %59 to double
  call void (ptr, ptr, ...) @_ZN15ImGuiTextBuffer7appendfEPKcz(ptr noundef nonnull align 8 dereferenceable(16) %57, ptr noundef @.str.51, double noundef %conv60)
  br label %if.end61

if.end61:                                         ; preds = %if.then59, %land.lhs.true57, %if.end55
  %60 = load i8, ptr %save_size, align 1
  %tobool62 = trunc i8 %60 to i1
  br i1 %tobool62, label %land.lhs.true63, label %if.end72

land.lhs.true63:                                  ; preds = %if.end61
  %61 = load ptr, ptr %column, align 8
  %IsStretch64 = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %61, i32 0, i32 5
  %bf.load65 = load i8, ptr %IsStretch64, align 2
  %bf.lshr66 = lshr i8 %bf.load65, 3
  %bf.clear67 = and i8 %bf.lshr66, 1
  %tobool68 = icmp ne i8 %bf.clear67, 0
  br i1 %tobool68, label %if.end72, label %if.then69

if.then69:                                        ; preds = %land.lhs.true63
  %62 = load ptr, ptr %buf.addr, align 8
  %63 = load ptr, ptr %column, align 8
  %WidthOrWeight70 = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %63, i32 0, i32 0
  %64 = load float, ptr %WidthOrWeight70, align 4
  %conv71 = fptosi float %64 to i32
  call void (ptr, ptr, ...) @_ZN15ImGuiTextBuffer7appendfEPKcz(ptr noundef nonnull align 8 dereferenceable(16) %62, ptr noundef @.str.52, i32 noundef %conv71)
  br label %if.end72

if.end72:                                         ; preds = %if.then69, %land.lhs.true63, %if.end61
  %65 = load i8, ptr %save_visible, align 1
  %tobool73 = trunc i8 %65 to i1
  br i1 %tobool73, label %if.then74, label %if.end79

if.then74:                                        ; preds = %if.end72
  %66 = load ptr, ptr %buf.addr, align 8
  %67 = load ptr, ptr %column, align 8
  %IsEnabled = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %67, i32 0, i32 5
  %bf.load75 = load i8, ptr %IsEnabled, align 2
  %bf.lshr76 = lshr i8 %bf.load75, 2
  %bf.clear77 = and i8 %bf.lshr76, 1
  %conv78 = zext i8 %bf.clear77 to i32
  call void (ptr, ptr, ...) @_ZN15ImGuiTextBuffer7appendfEPKcz(ptr noundef nonnull align 8 dereferenceable(16) %66, ptr noundef @.str.53, i32 noundef %conv78)
  br label %if.end79

if.end79:                                         ; preds = %if.then74, %if.end72
  %68 = load i8, ptr %save_order, align 1
  %tobool80 = trunc i8 %68 to i1
  br i1 %tobool80, label %if.then81, label %if.end83

if.then81:                                        ; preds = %if.end79
  %69 = load ptr, ptr %buf.addr, align 8
  %70 = load ptr, ptr %column, align 8
  %DisplayOrder = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %70, i32 0, i32 3
  %71 = load i16, ptr %DisplayOrder, align 2
  %conv82 = sext i16 %71 to i32
  call void (ptr, ptr, ...) @_ZN15ImGuiTextBuffer7appendfEPKcz(ptr noundef nonnull align 8 dereferenceable(16) %69, ptr noundef @.str.54, i32 noundef %conv82)
  br label %if.end83

if.end83:                                         ; preds = %if.then81, %if.end79
  %72 = load i8, ptr %save_sort, align 1
  %tobool84 = trunc i8 %72 to i1
  br i1 %tobool84, label %land.lhs.true85, label %if.end97

land.lhs.true85:                                  ; preds = %if.end83
  %73 = load ptr, ptr %column, align 8
  %SortOrder86 = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %73, i32 0, i32 4
  %74 = load i16, ptr %SortOrder86, align 4
  %conv87 = sext i16 %74 to i32
  %cmp88 = icmp ne i32 %conv87, -1
  br i1 %cmp88, label %if.then89, label %if.end97

if.then89:                                        ; preds = %land.lhs.true85
  %75 = load ptr, ptr %buf.addr, align 8
  %76 = load ptr, ptr %column, align 8
  %SortOrder90 = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %76, i32 0, i32 4
  %77 = load i16, ptr %SortOrder90, align 4
  %conv91 = sext i16 %77 to i32
  %78 = load ptr, ptr %column, align 8
  %SortDirection = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %78, i32 0, i32 5
  %bf.load92 = load i8, ptr %SortDirection, align 2
  %bf.clear93 = and i8 %bf.load92, 3
  %conv94 = zext i8 %bf.clear93 to i32
  %cmp95 = icmp eq i32 %conv94, 1
  %cond = select i1 %cmp95, i8 118, i8 94
  %conv96 = sext i8 %cond to i32
  call void (ptr, ptr, ...) @_ZN15ImGuiTextBuffer7appendfEPKcz(ptr noundef nonnull align 8 dereferenceable(16) %75, ptr noundef @.str.55, i32 noundef %conv91, i32 noundef %conv96)
  br label %if.end97

if.end97:                                         ; preds = %if.then89, %land.lhs.true85, %if.end83
  %79 = load ptr, ptr %buf.addr, align 8
  call void @_ZN15ImGuiTextBuffer6appendEPKcS1_(ptr noundef nonnull align 8 dereferenceable(16) %79, ptr noundef @.str.56, ptr noundef null)
  br label %for.inc

for.inc:                                          ; preds = %if.end97, %if.then49
  %80 = load i32, ptr %column_n, align 4
  %inc = add nsw i32 %80, 1
  store i32 %inc, ptr %column_n, align 4
  %81 = load ptr, ptr %column, align 8
  %incdec.ptr = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %81, i32 1
  store ptr %incdec.ptr, ptr %column, align 8
  br label %for.cond33, !llvm.loop !60

for.end:                                          ; preds = %for.cond33
  %82 = load ptr, ptr %buf.addr, align 8
  call void @_ZN15ImGuiTextBuffer6appendEPKcS1_(ptr noundef nonnull align 8 dereferenceable(16) %82, ptr noundef @.str.56, ptr noundef null)
  br label %for.inc98

for.inc98:                                        ; preds = %for.end, %if.then20, %if.then
  %83 = load ptr, ptr %g, align 8
  %SettingsTables99 = getelementptr inbounds %struct.ImGuiContext, ptr %83, i32 0, i32 218
  %84 = load ptr, ptr %settings, align 8
  %call100 = call noundef ptr @_ZN13ImChunkStreamI18ImGuiTableSettingsE10next_chunkEPS0_(ptr noundef nonnull align 8 dereferenceable(16) %SettingsTables99, ptr noundef %84)
  store ptr %call100, ptr %settings, align 8
  br label %for.cond, !llvm.loop !61

for.end101:                                       ; preds = %for.cond
  ret void
}

declare void @_ZN5ImGui18AddSettingsHandlerEPK20ImGuiSettingsHandler(ptr noundef) #1

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui11TableRemoveEP10ImGuiTable(ptr noundef %table) #0 {
entry:
  %table.addr = alloca ptr, align 8
  %g = alloca ptr, align 8
  %table_idx = alloca i32, align 4
  store ptr %table, ptr %table.addr, align 8
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %g, align 8
  %Tables = getelementptr inbounds %struct.ImGuiContext, ptr %1, i32 0, i32 167
  %2 = load ptr, ptr %table.addr, align 8
  %call = call noundef i32 @_ZNK6ImPoolI10ImGuiTableE8GetIndexEPKS0_(ptr noundef nonnull align 8 dereferenceable(40) %Tables, ptr noundef %2)
  store i32 %call, ptr %table_idx, align 4
  %3 = load ptr, ptr %g, align 8
  %Tables1 = getelementptr inbounds %struct.ImGuiContext, ptr %3, i32 0, i32 167
  %4 = load ptr, ptr %table.addr, align 8
  %ID = getelementptr inbounds %struct.ImGuiTable, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %ID, align 8
  %6 = load ptr, ptr %table.addr, align 8
  call void @_ZN6ImPoolI10ImGuiTableE6RemoveEjPKS0_(ptr noundef nonnull align 8 dereferenceable(40) %Tables1, i32 noundef %5, ptr noundef %6)
  %7 = load ptr, ptr %g, align 8
  %TablesLastTimeActive = getelementptr inbounds %struct.ImGuiContext, ptr %7, i32 0, i32 168
  %8 = load i32, ptr %table_idx, align 4
  %call2 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZN8ImVectorIfEixEi(ptr noundef nonnull align 8 dereferenceable(16) %TablesLastTimeActive, i32 noundef %8)
  store float -1.000000e+00, ptr %call2, align 4
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN6ImPoolI10ImGuiTableE6RemoveEjPKS0_(ptr noundef nonnull align 8 dereferenceable(40) %this, i32 noundef %key, ptr noundef %p) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %key.addr = alloca i32, align 4
  %p.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %key, ptr %key.addr, align 4
  store ptr %p, ptr %p.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %key.addr, align 4
  %1 = load ptr, ptr %p.addr, align 8
  %call = call noundef i32 @_ZNK6ImPoolI10ImGuiTableE8GetIndexEPKS0_(ptr noundef nonnull align 8 dereferenceable(40) %this1, ptr noundef %1)
  call void @_ZN6ImPoolI10ImGuiTableE6RemoveEji(ptr noundef nonnull align 8 dereferenceable(40) %this1, i32 noundef %0, i32 noundef %call)
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui30TableGcCompactTransientBuffersEP10ImGuiTable(ptr noundef %table) #0 {
entry:
  %table.addr = alloca ptr, align 8
  %g = alloca ptr, align 8
  %n = alloca i32, align 4
  store ptr %table, ptr %table.addr, align 8
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %table.addr, align 8
  %SortSpecs = getelementptr inbounds %struct.ImGuiTable, ptr %1, i32 0, i32 64
  %Specs = getelementptr inbounds %struct.ImGuiTableSortSpecs, ptr %SortSpecs, i32 0, i32 0
  store ptr null, ptr %Specs, align 8
  %2 = load ptr, ptr %table.addr, align 8
  %SortSpecsMulti = getelementptr inbounds %struct.ImGuiTable, ptr %2, i32 0, i32 63
  call void @_ZN8ImVectorI25ImGuiTableColumnSortSpecsE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %SortSpecsMulti)
  %3 = load ptr, ptr %table.addr, align 8
  %IsSortSpecsDirty = getelementptr inbounds %struct.ImGuiTable, ptr %3, i32 0, i32 95
  store i8 1, ptr %IsSortSpecsDirty, align 1
  %4 = load ptr, ptr %table.addr, align 8
  %ColumnsNames = getelementptr inbounds %struct.ImGuiTable, ptr %4, i32 0, i32 57
  call void @_ZN15ImGuiTextBuffer5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %ColumnsNames)
  %5 = load ptr, ptr %table.addr, align 8
  %MemoryCompacted = getelementptr inbounds %struct.ImGuiTable, ptr %5, i32 0, i32 110
  store i8 1, ptr %MemoryCompacted, align 8
  store i32 0, ptr %n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %6 = load i32, ptr %n, align 4
  %7 = load ptr, ptr %table.addr, align 8
  %ColumnsCount = getelementptr inbounds %struct.ImGuiTable, ptr %7, i32 0, i32 13
  %8 = load i32, ptr %ColumnsCount, align 4
  %cmp = icmp slt i32 %6, %8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load ptr, ptr %table.addr, align 8
  %Columns = getelementptr inbounds %struct.ImGuiTable, ptr %9, i32 0, i32 4
  %10 = load i32, ptr %n, align 4
  %call = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns, i32 noundef %10)
  %NameOffset = getelementptr inbounds %struct.ImGuiTableColumn, ptr %call, i32 0, i32 17
  store i16 -1, ptr %NameOffset, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %11 = load i32, ptr %n, align 4
  %inc = add nsw i32 %11, 1
  store i32 %inc, ptr %n, align 4
  br label %for.cond, !llvm.loop !62

for.end:                                          ; preds = %for.cond
  %12 = load ptr, ptr %g, align 8
  %TablesLastTimeActive = getelementptr inbounds %struct.ImGuiContext, ptr %12, i32 0, i32 168
  %13 = load ptr, ptr %g, align 8
  %Tables = getelementptr inbounds %struct.ImGuiContext, ptr %13, i32 0, i32 167
  %14 = load ptr, ptr %table.addr, align 8
  %call1 = call noundef i32 @_ZNK6ImPoolI10ImGuiTableE8GetIndexEPKS0_(ptr noundef nonnull align 8 dereferenceable(40) %Tables, ptr noundef %14)
  %call2 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZN8ImVectorIfEixEi(ptr noundef nonnull align 8 dereferenceable(16) %TablesLastTimeActive, i32 noundef %call1)
  store float -1.000000e+00, ptr %call2, align 4
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI25ImGuiTableColumnSortSpecsE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.39, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Capacity = getelementptr inbounds %struct.ImVector.39, ptr %this1, i32 0, i32 1
  store i32 0, ptr %Capacity, align 4
  %Size = getelementptr inbounds %struct.ImVector.39, ptr %this1, i32 0, i32 0
  store i32 0, ptr %Size, align 8
  %Data2 = getelementptr inbounds %struct.ImVector.39, ptr %this1, i32 0, i32 2
  %1 = load ptr, ptr %Data2, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %1)
  %Data3 = getelementptr inbounds %struct.ImVector.39, ptr %this1, i32 0, i32 2
  store ptr null, ptr %Data3, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN15ImGuiTextBuffer5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Buf = getelementptr inbounds %struct.ImGuiTextBuffer, ptr %this1, i32 0, i32 0
  call void @_ZN8ImVectorIcE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %Buf)
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui30TableGcCompactTransientBuffersEP18ImGuiTableTempData(ptr noundef %temp_data) #0 {
entry:
  %temp_data.addr = alloca ptr, align 8
  store ptr %temp_data, ptr %temp_data.addr, align 8
  %0 = load ptr, ptr %temp_data.addr, align 8
  %DrawSplitter = getelementptr inbounds %struct.ImGuiTableTempData, ptr %0, i32 0, i32 5
  call void @_ZN18ImDrawListSplitter15ClearFreeMemoryEv(ptr noundef nonnull align 8 dereferenceable(24) %DrawSplitter)
  %1 = load ptr, ptr %temp_data.addr, align 8
  %LastTimeActive = getelementptr inbounds %struct.ImGuiTableTempData, ptr %1, i32 0, i32 1
  store float -1.000000e+00, ptr %LastTimeActive, align 4
  ret void
}

declare void @_ZN18ImDrawListSplitter15ClearFreeMemoryEv(ptr noundef nonnull align 8 dereferenceable(24)) #1

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui22TableGcCompactSettingsEv() #0 personality ptr @__gxx_personality_v0 {
entry:
  %g = alloca ptr, align 8
  %required_memory = alloca i32, align 4
  %settings = alloca ptr, align 8
  %new_chunk_stream = alloca %struct.ImChunkStream.28, align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  %settings11 = alloca ptr, align 8
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  store i32 0, ptr %required_memory, align 4
  %1 = load ptr, ptr %g, align 8
  %SettingsTables = getelementptr inbounds %struct.ImGuiContext, ptr %1, i32 0, i32 218
  %call = call noundef ptr @_ZN13ImChunkStreamI18ImGuiTableSettingsE5beginEv(ptr noundef nonnull align 8 dereferenceable(16) %SettingsTables)
  store ptr %call, ptr %settings, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load ptr, ptr %settings, align 8
  %cmp = icmp ne ptr %2, null
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %settings, align 8
  %ID = getelementptr inbounds %struct.ImGuiTableSettings, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %ID, align 4
  %cmp1 = icmp ne i32 %4, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %5 = load ptr, ptr %settings, align 8
  %ColumnsCount = getelementptr inbounds %struct.ImGuiTableSettings, ptr %5, i32 0, i32 3
  %6 = load i16, ptr %ColumnsCount, align 4
  %conv = sext i16 %6 to i32
  %call2 = call noundef i64 @_ZL26TableSettingsCalcChunkSizei(i32 noundef %conv)
  %conv3 = trunc i64 %call2 to i32
  %7 = load i32, ptr %required_memory, align 4
  %add = add nsw i32 %7, %conv3
  store i32 %add, ptr %required_memory, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %8 = load ptr, ptr %g, align 8
  %SettingsTables4 = getelementptr inbounds %struct.ImGuiContext, ptr %8, i32 0, i32 218
  %9 = load ptr, ptr %settings, align 8
  %call5 = call noundef ptr @_ZN13ImChunkStreamI18ImGuiTableSettingsE10next_chunkEPS0_(ptr noundef nonnull align 8 dereferenceable(16) %SettingsTables4, ptr noundef %9)
  store ptr %call5, ptr %settings, align 8
  br label %for.cond, !llvm.loop !63

for.end:                                          ; preds = %for.cond
  %10 = load i32, ptr %required_memory, align 4
  %11 = load ptr, ptr %g, align 8
  %SettingsTables6 = getelementptr inbounds %struct.ImGuiContext, ptr %11, i32 0, i32 218
  %Buf = getelementptr inbounds %struct.ImChunkStream.28, ptr %SettingsTables6, i32 0, i32 0
  %Size = getelementptr inbounds %struct.ImVector.25, ptr %Buf, i32 0, i32 0
  %12 = load i32, ptr %Size, align 8
  %cmp7 = icmp eq i32 %10, %12
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %for.end
  br label %return

if.end9:                                          ; preds = %for.end
  call void @_ZN13ImChunkStreamI18ImGuiTableSettingsEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %new_chunk_stream)
  %Buf10 = getelementptr inbounds %struct.ImChunkStream.28, ptr %new_chunk_stream, i32 0, i32 0
  %13 = load i32, ptr %required_memory, align 4
  invoke void @_ZN8ImVectorIcE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %Buf10, i32 noundef %13)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %if.end9
  %14 = load ptr, ptr %g, align 8
  %SettingsTables12 = getelementptr inbounds %struct.ImGuiContext, ptr %14, i32 0, i32 218
  %call14 = invoke noundef ptr @_ZN13ImChunkStreamI18ImGuiTableSettingsE5beginEv(ptr noundef nonnull align 8 dereferenceable(16) %SettingsTables12)
          to label %invoke.cont13 unwind label %lpad

invoke.cont13:                                    ; preds = %invoke.cont
  store ptr %call14, ptr %settings11, align 8
  br label %for.cond15

for.cond15:                                       ; preds = %invoke.cont34, %invoke.cont13
  %15 = load ptr, ptr %settings11, align 8
  %cmp16 = icmp ne ptr %15, null
  br i1 %cmp16, label %for.body17, label %for.end36

for.body17:                                       ; preds = %for.cond15
  %16 = load ptr, ptr %settings11, align 8
  %ID18 = getelementptr inbounds %struct.ImGuiTableSettings, ptr %16, i32 0, i32 0
  %17 = load i32, ptr %ID18, align 4
  %cmp19 = icmp ne i32 %17, 0
  br i1 %cmp19, label %if.then20, label %if.end31

if.then20:                                        ; preds = %for.body17
  %18 = load ptr, ptr %settings11, align 8
  %ColumnsCount21 = getelementptr inbounds %struct.ImGuiTableSettings, ptr %18, i32 0, i32 3
  %19 = load i16, ptr %ColumnsCount21, align 4
  %conv22 = sext i16 %19 to i32
  %call24 = invoke noundef i64 @_ZL26TableSettingsCalcChunkSizei(i32 noundef %conv22)
          to label %invoke.cont23 unwind label %lpad

invoke.cont23:                                    ; preds = %if.then20
  %call26 = invoke noundef ptr @_ZN13ImChunkStreamI18ImGuiTableSettingsE11alloc_chunkEm(ptr noundef nonnull align 8 dereferenceable(16) %new_chunk_stream, i64 noundef %call24)
          to label %invoke.cont25 unwind label %lpad

invoke.cont25:                                    ; preds = %invoke.cont23
  %20 = load ptr, ptr %settings11, align 8
  %21 = load ptr, ptr %settings11, align 8
  %ColumnsCount27 = getelementptr inbounds %struct.ImGuiTableSettings, ptr %21, i32 0, i32 3
  %22 = load i16, ptr %ColumnsCount27, align 4
  %conv28 = sext i16 %22 to i32
  %call30 = invoke noundef i64 @_ZL26TableSettingsCalcChunkSizei(i32 noundef %conv28)
          to label %invoke.cont29 unwind label %lpad

invoke.cont29:                                    ; preds = %invoke.cont25
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %call26, ptr align 4 %20, i64 %call30, i1 false)
  br label %if.end31

lpad:                                             ; preds = %for.end36, %for.inc32, %invoke.cont25, %invoke.cont23, %if.then20, %invoke.cont, %if.end9
  %23 = landingpad { ptr, i32 }
          cleanup
  %24 = extractvalue { ptr, i32 } %23, 0
  store ptr %24, ptr %exn.slot, align 8
  %25 = extractvalue { ptr, i32 } %23, 1
  store i32 %25, ptr %ehselector.slot, align 4
  call void @_ZN13ImChunkStreamI18ImGuiTableSettingsED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %new_chunk_stream) #10
  br label %eh.resume

if.end31:                                         ; preds = %invoke.cont29, %for.body17
  br label %for.inc32

for.inc32:                                        ; preds = %if.end31
  %26 = load ptr, ptr %g, align 8
  %SettingsTables33 = getelementptr inbounds %struct.ImGuiContext, ptr %26, i32 0, i32 218
  %27 = load ptr, ptr %settings11, align 8
  %call35 = invoke noundef ptr @_ZN13ImChunkStreamI18ImGuiTableSettingsE10next_chunkEPS0_(ptr noundef nonnull align 8 dereferenceable(16) %SettingsTables33, ptr noundef %27)
          to label %invoke.cont34 unwind label %lpad

invoke.cont34:                                    ; preds = %for.inc32
  store ptr %call35, ptr %settings11, align 8
  br label %for.cond15, !llvm.loop !64

for.end36:                                        ; preds = %for.cond15
  %28 = load ptr, ptr %g, align 8
  %SettingsTables37 = getelementptr inbounds %struct.ImGuiContext, ptr %28, i32 0, i32 218
  invoke void @_ZN13ImChunkStreamI18ImGuiTableSettingsE4swapERS1_(ptr noundef nonnull align 8 dereferenceable(16) %SettingsTables37, ptr noundef nonnull align 8 dereferenceable(16) %new_chunk_stream)
          to label %invoke.cont38 unwind label %lpad

invoke.cont38:                                    ; preds = %for.end36
  call void @_ZN13ImChunkStreamI18ImGuiTableSettingsED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %new_chunk_stream) #10
  br label %return

return:                                           ; preds = %invoke.cont38, %if.then8
  ret void

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val39 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val39
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN13ImChunkStreamI18ImGuiTableSettingsEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Buf = getelementptr inbounds %struct.ImChunkStream.28, ptr %this1, i32 0, i32 0
  call void @_ZN8ImVectorIcEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %Buf)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN13ImChunkStreamI18ImGuiTableSettingsE4swapERS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %rhs) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %rhs.addr, align 8
  %Buf = getelementptr inbounds %struct.ImChunkStream.28, ptr %0, i32 0, i32 0
  %Buf2 = getelementptr inbounds %struct.ImChunkStream.28, ptr %this1, i32 0, i32 0
  call void @_ZN8ImVectorIcE4swapERS0_(ptr noundef nonnull align 8 dereferenceable(16) %Buf, ptr noundef nonnull align 8 dereferenceable(16) %Buf2)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN13ImChunkStreamI18ImGuiTableSettingsED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Buf = getelementptr inbounds %struct.ImChunkStream.28, ptr %this1, i32 0, i32 0
  call void @_ZN8ImVectorIcED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %Buf) #10
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui14DebugNodeTableEP10ImGuiTable(ptr noundef %table) #2 {
entry:
  %table.addr = alloca ptr, align 8
  %is_active = alloca i8, align 1
  %open = alloca i8, align 1
  %ref.tmp = alloca %struct.ImVec2, align 4
  %ref.tmp18 = alloca %struct.ImVec2, align 4
  %clear_settings = alloca i8, align 1
  %n = alloca i32, align 4
  %table_instance = alloca ptr, align 8
  %sum_weights = alloca float, align 4
  %n67 = alloca i32, align 4
  %n83 = alloca i32, align 4
  %column = alloca ptr, align 8
  %name = alloca ptr, align 8
  %buf = alloca [512 x i8], align 16
  %ref.tmp188 = alloca %struct.ImVec2, align 4
  %r = alloca %struct.ImRect, align 4
  %settings = alloca ptr, align 8
  store ptr %table, ptr %table.addr, align 8
  %0 = load ptr, ptr %table.addr, align 8
  %LastFrameActive = getelementptr inbounds %struct.ImGuiTable, ptr %0, i32 0, i32 12
  %1 = load i32, ptr %LastFrameActive, align 8
  %call = call noundef i32 @_ZN5ImGui13GetFrameCountEv()
  %sub = sub nsw i32 %call, 2
  %cmp = icmp sge i32 %1, %sub
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, ptr %is_active, align 1
  %2 = load i8, ptr %is_active, align 1
  %tobool = trunc i8 %2 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call1 = call noundef nonnull align 4 dereferenceable(16) ptr @_ZN5ImGui17GetStyleColorVec4Ei(i32 noundef 1)
  call void @_ZN5ImGui14PushStyleColorEiRK6ImVec4(i32 noundef 0, ptr noundef nonnull align 4 dereferenceable(16) %call1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load ptr, ptr %table.addr, align 8
  %4 = load ptr, ptr %table.addr, align 8
  %ID = getelementptr inbounds %struct.ImGuiTable, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %ID, align 8
  %6 = load ptr, ptr %table.addr, align 8
  %ColumnsCount = getelementptr inbounds %struct.ImGuiTable, ptr %6, i32 0, i32 13
  %7 = load i32, ptr %ColumnsCount, align 4
  %8 = load ptr, ptr %table.addr, align 8
  %OuterWindow = getelementptr inbounds %struct.ImGuiTable, ptr %8, i32 0, i32 55
  %9 = load ptr, ptr %OuterWindow, align 8
  %Name = getelementptr inbounds %struct.ImGuiWindow, ptr %9, i32 0, i32 1
  %10 = load ptr, ptr %Name, align 8
  %11 = load i8, ptr %is_active, align 1
  %tobool2 = trunc i8 %11 to i1
  %cond = select i1 %tobool2, ptr @.str.1, ptr @.str.10
  %call3 = call noundef zeroext i1 (ptr, ptr, ...) @_ZN5ImGui8TreeNodeEPKvPKcz(ptr noundef %3, ptr noundef @.str.9, i32 noundef %5, i32 noundef %7, ptr noundef %10, ptr noundef %cond)
  %frombool4 = zext i1 %call3 to i8
  store i8 %frombool4, ptr %open, align 1
  %12 = load i8, ptr %is_active, align 1
  %tobool5 = trunc i8 %12 to i1
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %if.end
  call void @_ZN5ImGui13PopStyleColorEi(i32 noundef 1)
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %if.end
  %call8 = call noundef zeroext i1 @_ZN5ImGui13IsItemHoveredEi(i32 noundef 0)
  br i1 %call8, label %if.then9, label %if.end12

if.then9:                                         ; preds = %if.end7
  %call10 = call noundef ptr @_ZN5ImGui21GetForegroundDrawListEv()
  %13 = load ptr, ptr %table.addr, align 8
  %OuterRect = getelementptr inbounds %struct.ImGuiTable, ptr %13, i32 0, i32 46
  %Min = getelementptr inbounds %struct.ImRect, ptr %OuterRect, i32 0, i32 0
  %14 = load ptr, ptr %table.addr, align 8
  %OuterRect11 = getelementptr inbounds %struct.ImGuiTable, ptr %14, i32 0, i32 46
  %Max = getelementptr inbounds %struct.ImRect, ptr %OuterRect11, i32 0, i32 1
  call void @_ZN10ImDrawList7AddRectERK6ImVec2S2_jfif(ptr noundef nonnull align 8 dereferenceable(196) %call10, ptr noundef nonnull align 4 dereferenceable(8) %Min, ptr noundef nonnull align 4 dereferenceable(8) %Max, i32 noundef -16711681, float noundef 0.000000e+00, i32 noundef 0, float noundef 1.000000e+00)
  br label %if.end12

if.end12:                                         ; preds = %if.then9, %if.end7
  %call13 = call noundef zeroext i1 @_ZN5ImGui13IsItemVisibleEv()
  br i1 %call13, label %land.lhs.true, label %if.end20

land.lhs.true:                                    ; preds = %if.end12
  %15 = load ptr, ptr %table.addr, align 8
  %HoveredColumnBody = getelementptr inbounds %struct.ImGuiTable, ptr %15, i32 0, i32 70
  %16 = load i16, ptr %HoveredColumnBody, align 2
  %conv = sext i16 %16 to i32
  %cmp14 = icmp ne i32 %conv, -1
  br i1 %cmp14, label %if.then15, label %if.end20

if.then15:                                        ; preds = %land.lhs.true
  %call16 = call noundef ptr @_ZN5ImGui21GetForegroundDrawListEv()
  %call17 = call <2 x float> @_ZN5ImGui14GetItemRectMinEv()
  store <2 x float> %call17, ptr %ref.tmp, align 4
  %call19 = call <2 x float> @_ZN5ImGui14GetItemRectMaxEv()
  store <2 x float> %call19, ptr %ref.tmp18, align 4
  call void @_ZN10ImDrawList7AddRectERK6ImVec2S2_jfif(ptr noundef nonnull align 8 dereferenceable(196) %call16, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp18, i32 noundef -16711681, float noundef 0.000000e+00, i32 noundef 0, float noundef 1.000000e+00)
  br label %if.end20

if.end20:                                         ; preds = %if.then15, %land.lhs.true, %if.end12
  %17 = load i8, ptr %open, align 1
  %tobool21 = trunc i8 %17 to i1
  br i1 %tobool21, label %if.end23, label %if.then22

if.then22:                                        ; preds = %if.end20
  br label %return

if.end23:                                         ; preds = %if.end20
  %18 = load ptr, ptr %table.addr, align 8
  %InstanceCurrent = getelementptr inbounds %struct.ImGuiTable, ptr %18, i32 0, i32 16
  %19 = load i16, ptr %InstanceCurrent, align 8
  %conv24 = sext i16 %19 to i32
  %cmp25 = icmp sgt i32 %conv24, 0
  br i1 %cmp25, label %if.then26, label %if.end29

if.then26:                                        ; preds = %if.end23
  %20 = load ptr, ptr %table.addr, align 8
  %InstanceCurrent27 = getelementptr inbounds %struct.ImGuiTable, ptr %20, i32 0, i32 16
  %21 = load i16, ptr %InstanceCurrent27, align 8
  %conv28 = sext i16 %21 to i32
  %add = add nsw i32 %conv28, 1
  call void (ptr, ...) @_ZN5ImGui4TextEPKcz(ptr noundef @.str.11, i32 noundef %add)
  br label %if.end29

if.end29:                                         ; preds = %if.then26, %if.end23
  %call30 = call noundef zeroext i1 @_ZN5ImGui11SmallButtonEPKc(ptr noundef @.str.12)
  %frombool31 = zext i1 %call30 to i8
  store i8 %frombool31, ptr %clear_settings, align 1
  %22 = load ptr, ptr %table.addr, align 8
  %OuterRect32 = getelementptr inbounds %struct.ImGuiTable, ptr %22, i32 0, i32 46
  %Min33 = getelementptr inbounds %struct.ImRect, ptr %OuterRect32, i32 0, i32 0
  %x = getelementptr inbounds %struct.ImVec2, ptr %Min33, i32 0, i32 0
  %23 = load float, ptr %x, align 8
  %conv34 = fpext float %23 to double
  %24 = load ptr, ptr %table.addr, align 8
  %OuterRect35 = getelementptr inbounds %struct.ImGuiTable, ptr %24, i32 0, i32 46
  %Min36 = getelementptr inbounds %struct.ImRect, ptr %OuterRect35, i32 0, i32 0
  %y = getelementptr inbounds %struct.ImVec2, ptr %Min36, i32 0, i32 1
  %25 = load float, ptr %y, align 4
  %conv37 = fpext float %25 to double
  %26 = load ptr, ptr %table.addr, align 8
  %OuterRect38 = getelementptr inbounds %struct.ImGuiTable, ptr %26, i32 0, i32 46
  %call39 = call noundef float @_ZNK6ImRect8GetWidthEv(ptr noundef nonnull align 4 dereferenceable(16) %OuterRect38)
  %conv40 = fpext float %call39 to double
  %27 = load ptr, ptr %table.addr, align 8
  %OuterRect41 = getelementptr inbounds %struct.ImGuiTable, ptr %27, i32 0, i32 46
  %call42 = call noundef float @_ZNK6ImRect9GetHeightEv(ptr noundef nonnull align 4 dereferenceable(16) %OuterRect41)
  %conv43 = fpext float %call42 to double
  %28 = load ptr, ptr %table.addr, align 8
  %Flags = getelementptr inbounds %struct.ImGuiTable, ptr %28, i32 0, i32 1
  %29 = load i32, ptr %Flags, align 4
  %call44 = call noundef ptr @_ZL33DebugNodeTableGetSizingPolicyDesci(i32 noundef %29)
  call void (ptr, ...) @_ZN5ImGui10BulletTextEPKcz(ptr noundef @.str.13, double noundef %conv34, double noundef %conv37, double noundef %conv40, double noundef %conv43, ptr noundef %call44)
  %30 = load ptr, ptr %table.addr, align 8
  %ColumnsGivenWidth = getelementptr inbounds %struct.ImGuiTable, ptr %30, i32 0, i32 38
  %31 = load float, ptr %ColumnsGivenWidth, align 8
  %conv45 = fpext float %31 to double
  %32 = load ptr, ptr %table.addr, align 8
  %ColumnsAutoFitWidth = getelementptr inbounds %struct.ImGuiTable, ptr %32, i32 0, i32 39
  %33 = load float, ptr %ColumnsAutoFitWidth, align 4
  %conv46 = fpext float %33 to double
  %34 = load ptr, ptr %table.addr, align 8
  %InnerWidth = getelementptr inbounds %struct.ImGuiTable, ptr %34, i32 0, i32 37
  %35 = load float, ptr %InnerWidth, align 4
  %conv47 = fpext float %35 to double
  %36 = load ptr, ptr %table.addr, align 8
  %InnerWidth48 = getelementptr inbounds %struct.ImGuiTable, ptr %36, i32 0, i32 37
  %37 = load float, ptr %InnerWidth48, align 4
  %cmp49 = fcmp oeq float %37, 0.000000e+00
  %cond50 = select i1 %cmp49, ptr @.str.15, ptr @.str.1
  call void (ptr, ...) @_ZN5ImGui10BulletTextEPKcz(ptr noundef @.str.14, double noundef %conv45, double noundef %conv46, double noundef %conv47, ptr noundef %cond50)
  %38 = load ptr, ptr %table.addr, align 8
  %CellPaddingX = getelementptr inbounds %struct.ImGuiTable, ptr %38, i32 0, i32 34
  %39 = load float, ptr %CellPaddingX, align 8
  %conv51 = fpext float %39 to double
  %40 = load ptr, ptr %table.addr, align 8
  %CellSpacingX1 = getelementptr inbounds %struct.ImGuiTable, ptr %40, i32 0, i32 35
  %41 = load float, ptr %CellSpacingX1, align 4
  %conv52 = fpext float %41 to double
  %42 = load ptr, ptr %table.addr, align 8
  %CellSpacingX2 = getelementptr inbounds %struct.ImGuiTable, ptr %42, i32 0, i32 36
  %43 = load float, ptr %CellSpacingX2, align 8
  %conv53 = fpext float %43 to double
  %44 = load ptr, ptr %table.addr, align 8
  %OuterPaddingX = getelementptr inbounds %struct.ImGuiTable, ptr %44, i32 0, i32 33
  %45 = load float, ptr %OuterPaddingX, align 4
  %conv54 = fpext float %45 to double
  call void (ptr, ...) @_ZN5ImGui10BulletTextEPKcz(ptr noundef @.str.16, double noundef %conv51, double noundef %conv52, double noundef %conv53, double noundef %conv54)
  %46 = load ptr, ptr %table.addr, align 8
  %HoveredColumnBody55 = getelementptr inbounds %struct.ImGuiTable, ptr %46, i32 0, i32 70
  %47 = load i16, ptr %HoveredColumnBody55, align 2
  %conv56 = sext i16 %47 to i32
  %48 = load ptr, ptr %table.addr, align 8
  %HoveredColumnBorder = getelementptr inbounds %struct.ImGuiTable, ptr %48, i32 0, i32 71
  %49 = load i16, ptr %HoveredColumnBorder, align 4
  %conv57 = sext i16 %49 to i32
  call void (ptr, ...) @_ZN5ImGui10BulletTextEPKcz(ptr noundef @.str.17, i32 noundef %conv56, i32 noundef %conv57)
  %50 = load ptr, ptr %table.addr, align 8
  %ResizedColumn = getelementptr inbounds %struct.ImGuiTable, ptr %50, i32 0, i32 74
  %51 = load i16, ptr %ResizedColumn, align 2
  %conv58 = sext i16 %51 to i32
  %52 = load ptr, ptr %table.addr, align 8
  %ReorderColumn = getelementptr inbounds %struct.ImGuiTable, ptr %52, i32 0, i32 77
  %53 = load i16, ptr %ReorderColumn, align 8
  %conv59 = sext i16 %53 to i32
  %54 = load ptr, ptr %table.addr, align 8
  %HeldHeaderColumn = getelementptr inbounds %struct.ImGuiTable, ptr %54, i32 0, i32 76
  %55 = load i16, ptr %HeldHeaderColumn, align 2
  %conv60 = sext i16 %55 to i32
  call void (ptr, ...) @_ZN5ImGui10BulletTextEPKcz(ptr noundef @.str.18, i32 noundef %conv58, i32 noundef %conv59, i32 noundef %conv60)
  store i32 0, ptr %n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end29
  %56 = load i32, ptr %n, align 4
  %57 = load ptr, ptr %table.addr, align 8
  %InstanceCurrent61 = getelementptr inbounds %struct.ImGuiTable, ptr %57, i32 0, i32 16
  %58 = load i16, ptr %InstanceCurrent61, align 8
  %conv62 = sext i16 %58 to i32
  %add63 = add nsw i32 %conv62, 1
  %cmp64 = icmp slt i32 %56, %add63
  br i1 %cmp64, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %59 = load ptr, ptr %table.addr, align 8
  %60 = load i32, ptr %n, align 4
  %call65 = call noundef ptr @_ZN5ImGui20TableGetInstanceDataEP10ImGuiTablei(ptr noundef %59, i32 noundef %60)
  store ptr %call65, ptr %table_instance, align 8
  %61 = load i32, ptr %n, align 4
  %62 = load ptr, ptr %table_instance, align 8
  %HoveredRowLast = getelementptr inbounds %struct.ImGuiTableInstanceData, ptr %62, i32 0, i32 4
  %63 = load i32, ptr %HoveredRowLast, align 4
  %64 = load ptr, ptr %table_instance, align 8
  %LastOuterHeight = getelementptr inbounds %struct.ImGuiTableInstanceData, ptr %64, i32 0, i32 1
  %65 = load float, ptr %LastOuterHeight, align 4
  %conv66 = fpext float %65 to double
  call void (ptr, ...) @_ZN5ImGui10BulletTextEPKcz(ptr noundef @.str.19, i32 noundef %61, i32 noundef %63, double noundef %conv66)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %66 = load i32, ptr %n, align 4
  %inc = add nsw i32 %66, 1
  store i32 %inc, ptr %n, align 4
  br label %for.cond, !llvm.loop !65

for.end:                                          ; preds = %for.cond
  store float 0.000000e+00, ptr %sum_weights, align 4
  store i32 0, ptr %n67, align 4
  br label %for.cond68

for.cond68:                                       ; preds = %for.inc80, %for.end
  %67 = load i32, ptr %n67, align 4
  %68 = load ptr, ptr %table.addr, align 8
  %ColumnsCount69 = getelementptr inbounds %struct.ImGuiTable, ptr %68, i32 0, i32 13
  %69 = load i32, ptr %ColumnsCount69, align 4
  %cmp70 = icmp slt i32 %67, %69
  br i1 %cmp70, label %for.body71, label %for.end82

for.body71:                                       ; preds = %for.cond68
  %70 = load ptr, ptr %table.addr, align 8
  %Columns = getelementptr inbounds %struct.ImGuiTable, ptr %70, i32 0, i32 4
  %71 = load i32, ptr %n67, align 4
  %call72 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns, i32 noundef %71)
  %Flags73 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %call72, i32 0, i32 0
  %72 = load i32, ptr %Flags73, align 4
  %and = and i32 %72, 8
  %tobool74 = icmp ne i32 %and, 0
  br i1 %tobool74, label %if.then75, label %if.end79

if.then75:                                        ; preds = %for.body71
  %73 = load ptr, ptr %table.addr, align 8
  %Columns76 = getelementptr inbounds %struct.ImGuiTable, ptr %73, i32 0, i32 4
  %74 = load i32, ptr %n67, align 4
  %call77 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns76, i32 noundef %74)
  %StretchWeight = getelementptr inbounds %struct.ImGuiTableColumn, ptr %call77, i32 0, i32 6
  %75 = load float, ptr %StretchWeight, align 4
  %76 = load float, ptr %sum_weights, align 4
  %add78 = fadd float %76, %75
  store float %add78, ptr %sum_weights, align 4
  br label %if.end79

if.end79:                                         ; preds = %if.then75, %for.body71
  br label %for.inc80

for.inc80:                                        ; preds = %if.end79
  %77 = load i32, ptr %n67, align 4
  %inc81 = add nsw i32 %77, 1
  store i32 %inc81, ptr %n67, align 4
  br label %for.cond68, !llvm.loop !66

for.end82:                                        ; preds = %for.cond68
  store i32 0, ptr %n83, align 4
  br label %for.cond84

for.cond84:                                       ; preds = %for.inc204, %for.end82
  %78 = load i32, ptr %n83, align 4
  %79 = load ptr, ptr %table.addr, align 8
  %ColumnsCount85 = getelementptr inbounds %struct.ImGuiTable, ptr %79, i32 0, i32 13
  %80 = load i32, ptr %ColumnsCount85, align 4
  %cmp86 = icmp slt i32 %78, %80
  br i1 %cmp86, label %for.body87, label %for.end206

for.body87:                                       ; preds = %for.cond84
  %81 = load ptr, ptr %table.addr, align 8
  %Columns88 = getelementptr inbounds %struct.ImGuiTable, ptr %81, i32 0, i32 4
  %82 = load i32, ptr %n83, align 4
  %call89 = call noundef nonnull align 4 dereferenceable(111) ptr @_ZN6ImSpanI16ImGuiTableColumnEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns88, i32 noundef %82)
  store ptr %call89, ptr %column, align 8
  %83 = load ptr, ptr %table.addr, align 8
  %84 = load i32, ptr %n83, align 4
  %call90 = call noundef ptr @_ZN5ImGui18TableGetColumnNameEPK10ImGuiTablei(ptr noundef %83, i32 noundef %84)
  store ptr %call90, ptr %name, align 8
  %arraydecay = getelementptr inbounds [512 x i8], ptr %buf, i64 0, i64 0
  %85 = load i32, ptr %n83, align 4
  %86 = load ptr, ptr %column, align 8
  %DisplayOrder = getelementptr inbounds %struct.ImGuiTableColumn, ptr %86, i32 0, i32 18
  %87 = load i16, ptr %DisplayOrder, align 2
  %conv91 = sext i16 %87 to i32
  %88 = load ptr, ptr %name, align 8
  %89 = load ptr, ptr %column, align 8
  %MinX = getelementptr inbounds %struct.ImGuiTableColumn, ptr %89, i32 0, i32 2
  %90 = load float, ptr %MinX, align 4
  %91 = load ptr, ptr %table.addr, align 8
  %WorkRect = getelementptr inbounds %struct.ImGuiTable, ptr %91, i32 0, i32 48
  %Min92 = getelementptr inbounds %struct.ImRect, ptr %WorkRect, i32 0, i32 0
  %x93 = getelementptr inbounds %struct.ImVec2, ptr %Min92, i32 0, i32 0
  %92 = load float, ptr %x93, align 8
  %sub94 = fsub float %90, %92
  %conv95 = fpext float %sub94 to double
  %93 = load ptr, ptr %column, align 8
  %MaxX = getelementptr inbounds %struct.ImGuiTableColumn, ptr %93, i32 0, i32 3
  %94 = load float, ptr %MaxX, align 4
  %95 = load ptr, ptr %table.addr, align 8
  %WorkRect96 = getelementptr inbounds %struct.ImGuiTable, ptr %95, i32 0, i32 48
  %Min97 = getelementptr inbounds %struct.ImRect, ptr %WorkRect96, i32 0, i32 0
  %x98 = getelementptr inbounds %struct.ImVec2, ptr %Min97, i32 0, i32 0
  %96 = load float, ptr %x98, align 8
  %sub99 = fsub float %94, %96
  %conv100 = fpext float %sub99 to double
  %97 = load i32, ptr %n83, align 4
  %98 = load ptr, ptr %table.addr, align 8
  %FreezeColumnsRequest = getelementptr inbounds %struct.ImGuiTable, ptr %98, i32 0, i32 86
  %99 = load i16, ptr %FreezeColumnsRequest, align 2
  %conv101 = sext i16 %99 to i32
  %cmp102 = icmp slt i32 %97, %conv101
  %cond103 = select i1 %cmp102, ptr @.str.21, ptr @.str.1
  %100 = load ptr, ptr %column, align 8
  %IsEnabled = getelementptr inbounds %struct.ImGuiTableColumn, ptr %100, i32 0, i32 26
  %101 = load i8, ptr %IsEnabled, align 2
  %tobool104 = trunc i8 %101 to i1
  %conv105 = zext i1 %tobool104 to i32
  %102 = load ptr, ptr %column, align 8
  %IsVisibleX = getelementptr inbounds %struct.ImGuiTableColumn, ptr %102, i32 0, i32 29
  %103 = load i8, ptr %IsVisibleX, align 1
  %tobool106 = trunc i8 %103 to i1
  %conv107 = zext i1 %tobool106 to i32
  %104 = load ptr, ptr %column, align 8
  %IsVisibleY = getelementptr inbounds %struct.ImGuiTableColumn, ptr %104, i32 0, i32 30
  %105 = load i8, ptr %IsVisibleY, align 2
  %tobool108 = trunc i8 %105 to i1
  %conv109 = zext i1 %tobool108 to i32
  %106 = load ptr, ptr %column, align 8
  %IsRequestOutput = getelementptr inbounds %struct.ImGuiTableColumn, ptr %106, i32 0, i32 31
  %107 = load i8, ptr %IsRequestOutput, align 1
  %tobool110 = trunc i8 %107 to i1
  %conv111 = zext i1 %tobool110 to i32
  %108 = load ptr, ptr %column, align 8
  %IsSkipItems = getelementptr inbounds %struct.ImGuiTableColumn, ptr %108, i32 0, i32 32
  %109 = load i8, ptr %IsSkipItems, align 4
  %tobool112 = trunc i8 %109 to i1
  %conv113 = zext i1 %tobool112 to i32
  %110 = load ptr, ptr %column, align 8
  %DrawChannelFrozen = getelementptr inbounds %struct.ImGuiTableColumn, ptr %110, i32 0, i32 24
  %111 = load i16, ptr %DrawChannelFrozen, align 2
  %conv114 = zext i16 %111 to i32
  %112 = load ptr, ptr %column, align 8
  %DrawChannelUnfrozen = getelementptr inbounds %struct.ImGuiTableColumn, ptr %112, i32 0, i32 25
  %113 = load i16, ptr %DrawChannelUnfrozen, align 4
  %conv115 = zext i16 %113 to i32
  %114 = load ptr, ptr %column, align 8
  %WidthGiven = getelementptr inbounds %struct.ImGuiTableColumn, ptr %114, i32 0, i32 1
  %115 = load float, ptr %WidthGiven, align 4
  %conv116 = fpext float %115 to double
  %116 = load ptr, ptr %column, align 8
  %WidthRequest = getelementptr inbounds %struct.ImGuiTableColumn, ptr %116, i32 0, i32 4
  %117 = load float, ptr %WidthRequest, align 4
  %conv117 = fpext float %117 to double
  %118 = load ptr, ptr %column, align 8
  %WidthAuto = getelementptr inbounds %struct.ImGuiTableColumn, ptr %118, i32 0, i32 5
  %119 = load float, ptr %WidthAuto, align 4
  %conv118 = fpext float %119 to double
  %120 = load ptr, ptr %column, align 8
  %StretchWeight119 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %120, i32 0, i32 6
  %121 = load float, ptr %StretchWeight119, align 4
  %conv120 = fpext float %121 to double
  %122 = load ptr, ptr %column, align 8
  %StretchWeight121 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %122, i32 0, i32 6
  %123 = load float, ptr %StretchWeight121, align 4
  %cmp122 = fcmp ogt float %123, 0.000000e+00
  br i1 %cmp122, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body87
  %124 = load ptr, ptr %column, align 8
  %StretchWeight123 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %124, i32 0, i32 6
  %125 = load float, ptr %StretchWeight123, align 4
  %126 = load float, ptr %sum_weights, align 4
  %div = fdiv float %125, %126
  %mul = fmul float %div, 1.000000e+02
  br label %cond.end

cond.false:                                       ; preds = %for.body87
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond124 = phi float [ %mul, %cond.true ], [ 0.000000e+00, %cond.false ]
  %conv125 = fpext float %cond124 to double
  %127 = load ptr, ptr %column, align 8
  %MinX126 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %127, i32 0, i32 2
  %128 = load float, ptr %MinX126, align 4
  %conv127 = fpext float %128 to double
  %129 = load ptr, ptr %column, align 8
  %MaxX128 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %129, i32 0, i32 3
  %130 = load float, ptr %MaxX128, align 4
  %conv129 = fpext float %130 to double
  %131 = load ptr, ptr %column, align 8
  %MaxX130 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %131, i32 0, i32 3
  %132 = load float, ptr %MaxX130, align 4
  %133 = load ptr, ptr %column, align 8
  %MinX131 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %133, i32 0, i32 2
  %134 = load float, ptr %MinX131, align 4
  %sub132 = fsub float %132, %134
  %conv133 = fpext float %sub132 to double
  %135 = load ptr, ptr %column, align 8
  %ClipRect = getelementptr inbounds %struct.ImGuiTableColumn, ptr %135, i32 0, i32 8
  %Min134 = getelementptr inbounds %struct.ImRect, ptr %ClipRect, i32 0, i32 0
  %x135 = getelementptr inbounds %struct.ImVec2, ptr %Min134, i32 0, i32 0
  %136 = load float, ptr %x135, align 4
  %conv136 = fpext float %136 to double
  %137 = load ptr, ptr %column, align 8
  %ClipRect137 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %137, i32 0, i32 8
  %Max138 = getelementptr inbounds %struct.ImRect, ptr %ClipRect137, i32 0, i32 1
  %x139 = getelementptr inbounds %struct.ImVec2, ptr %Max138, i32 0, i32 0
  %138 = load float, ptr %x139, align 4
  %conv140 = fpext float %138 to double
  %139 = load ptr, ptr %column, align 8
  %ClipRect141 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %139, i32 0, i32 8
  %Max142 = getelementptr inbounds %struct.ImRect, ptr %ClipRect141, i32 0, i32 1
  %x143 = getelementptr inbounds %struct.ImVec2, ptr %Max142, i32 0, i32 0
  %140 = load float, ptr %x143, align 4
  %141 = load ptr, ptr %column, align 8
  %ClipRect144 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %141, i32 0, i32 8
  %Min145 = getelementptr inbounds %struct.ImRect, ptr %ClipRect144, i32 0, i32 0
  %x146 = getelementptr inbounds %struct.ImVec2, ptr %Min145, i32 0, i32 0
  %142 = load float, ptr %x146, align 4
  %sub147 = fsub float %140, %142
  %conv148 = fpext float %sub147 to double
  %143 = load ptr, ptr %column, align 8
  %ContentMaxXFrozen = getelementptr inbounds %struct.ImGuiTableColumn, ptr %143, i32 0, i32 13
  %144 = load float, ptr %ContentMaxXFrozen, align 4
  %145 = load ptr, ptr %column, align 8
  %WorkMinX = getelementptr inbounds %struct.ImGuiTableColumn, ptr %145, i32 0, i32 10
  %146 = load float, ptr %WorkMinX, align 4
  %sub149 = fsub float %144, %146
  %conv150 = fpext float %sub149 to double
  %147 = load ptr, ptr %column, align 8
  %ContentMaxXUnfrozen = getelementptr inbounds %struct.ImGuiTableColumn, ptr %147, i32 0, i32 14
  %148 = load float, ptr %ContentMaxXUnfrozen, align 4
  %149 = load ptr, ptr %column, align 8
  %WorkMinX151 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %149, i32 0, i32 10
  %150 = load float, ptr %WorkMinX151, align 4
  %sub152 = fsub float %148, %150
  %conv153 = fpext float %sub152 to double
  %151 = load ptr, ptr %column, align 8
  %ContentMaxXHeadersUsed = getelementptr inbounds %struct.ImGuiTableColumn, ptr %151, i32 0, i32 15
  %152 = load float, ptr %ContentMaxXHeadersUsed, align 4
  %153 = load ptr, ptr %column, align 8
  %WorkMinX154 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %153, i32 0, i32 10
  %154 = load float, ptr %WorkMinX154, align 4
  %sub155 = fsub float %152, %154
  %conv156 = fpext float %sub155 to double
  %155 = load ptr, ptr %column, align 8
  %ContentMaxXHeadersIdeal = getelementptr inbounds %struct.ImGuiTableColumn, ptr %155, i32 0, i32 16
  %156 = load float, ptr %ContentMaxXHeadersIdeal, align 4
  %157 = load ptr, ptr %column, align 8
  %WorkMinX157 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %157, i32 0, i32 10
  %158 = load float, ptr %WorkMinX157, align 4
  %sub158 = fsub float %156, %158
  %conv159 = fpext float %sub158 to double
  %159 = load ptr, ptr %column, align 8
  %SortOrder = getelementptr inbounds %struct.ImGuiTableColumn, ptr %159, i32 0, i32 22
  %160 = load i16, ptr %SortOrder, align 2
  %conv160 = sext i16 %160 to i32
  %161 = load ptr, ptr %column, align 8
  %SortDirection = getelementptr inbounds %struct.ImGuiTableColumn, ptr %161, i32 0, i32 37
  %bf.load = load i8, ptr %SortDirection, align 1
  %bf.clear = and i8 %bf.load, 3
  %conv161 = zext i8 %bf.clear to i32
  %cmp162 = icmp eq i32 %conv161, 1
  br i1 %cmp162, label %cond.true163, label %cond.false164

cond.true163:                                     ; preds = %cond.end
  br label %cond.end171

cond.false164:                                    ; preds = %cond.end
  %162 = load ptr, ptr %column, align 8
  %SortDirection165 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %162, i32 0, i32 37
  %bf.load166 = load i8, ptr %SortDirection165, align 1
  %bf.clear167 = and i8 %bf.load166, 3
  %conv168 = zext i8 %bf.clear167 to i32
  %cmp169 = icmp eq i32 %conv168, 2
  %cond170 = select i1 %cmp169, ptr @.str.23, ptr @.str.1
  br label %cond.end171

cond.end171:                                      ; preds = %cond.false164, %cond.true163
  %cond172 = phi ptr [ @.str.22, %cond.true163 ], [ %cond170, %cond.false164 ]
  %163 = load ptr, ptr %column, align 8
  %UserID = getelementptr inbounds %struct.ImGuiTableColumn, ptr %163, i32 0, i32 9
  %164 = load i32, ptr %UserID, align 4
  %165 = load ptr, ptr %column, align 8
  %Flags173 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %165, i32 0, i32 0
  %166 = load i32, ptr %Flags173, align 4
  %167 = load ptr, ptr %column, align 8
  %Flags174 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %167, i32 0, i32 0
  %168 = load i32, ptr %Flags174, align 4
  %and175 = and i32 %168, 8
  %tobool176 = icmp ne i32 %and175, 0
  %cond177 = select i1 %tobool176, ptr @.str.24, ptr @.str.1
  %169 = load ptr, ptr %column, align 8
  %Flags178 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %169, i32 0, i32 0
  %170 = load i32, ptr %Flags178, align 4
  %and179 = and i32 %170, 16
  %tobool180 = icmp ne i32 %and179, 0
  %cond181 = select i1 %tobool180, ptr @.str.25, ptr @.str.1
  %171 = load ptr, ptr %column, align 8
  %Flags182 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %171, i32 0, i32 0
  %172 = load i32, ptr %Flags182, align 4
  %and183 = and i32 %172, 32
  %tobool184 = icmp ne i32 %and183, 0
  %cond185 = select i1 %tobool184, ptr @.str.26, ptr @.str.1
  %call186 = call noundef i32 (ptr, i64, ptr, ...) @_Z14ImFormatStringPcmPKcz(ptr noundef %arraydecay, i64 noundef 512, ptr noundef @.str.20, i32 noundef %85, i32 noundef %conv91, ptr noundef %88, double noundef %conv95, double noundef %conv100, ptr noundef %cond103, i32 noundef %conv105, i32 noundef %conv107, i32 noundef %conv109, i32 noundef %conv111, i32 noundef %conv113, i32 noundef %conv114, i32 noundef %conv115, double noundef %conv116, double noundef %conv117, double noundef %conv118, double noundef %conv120, double noundef %conv125, double noundef %conv127, double noundef %conv129, double noundef %conv133, double noundef %conv136, double noundef %conv140, double noundef %conv148, double noundef %conv150, double noundef %conv153, double noundef %conv156, double noundef %conv159, i32 noundef %conv160, ptr noundef %cond172, i32 noundef %164, i32 noundef %166, ptr noundef %cond177, ptr noundef %cond181, ptr noundef %cond185)
  call void @_ZN5ImGui6BulletEv()
  %arraydecay187 = getelementptr inbounds [512 x i8], ptr %buf, i64 0, i64 0
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp188, float noundef 0.000000e+00, float noundef 0.000000e+00)
  %call189 = call noundef zeroext i1 @_ZN5ImGui10SelectableEPKcbiRK6ImVec2(ptr noundef %arraydecay187, i1 noundef zeroext false, i32 noundef 0, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp188)
  %call190 = call noundef zeroext i1 @_ZN5ImGui13IsItemHoveredEi(i32 noundef 0)
  br i1 %call190, label %if.then191, label %if.end203

if.then191:                                       ; preds = %cond.end171
  %173 = load ptr, ptr %column, align 8
  %MinX192 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %173, i32 0, i32 2
  %174 = load float, ptr %MinX192, align 4
  %175 = load ptr, ptr %table.addr, align 8
  %OuterRect193 = getelementptr inbounds %struct.ImGuiTable, ptr %175, i32 0, i32 46
  %Min194 = getelementptr inbounds %struct.ImRect, ptr %OuterRect193, i32 0, i32 0
  %y195 = getelementptr inbounds %struct.ImVec2, ptr %Min194, i32 0, i32 1
  %176 = load float, ptr %y195, align 4
  %177 = load ptr, ptr %column, align 8
  %MaxX196 = getelementptr inbounds %struct.ImGuiTableColumn, ptr %177, i32 0, i32 3
  %178 = load float, ptr %MaxX196, align 4
  %179 = load ptr, ptr %table.addr, align 8
  %OuterRect197 = getelementptr inbounds %struct.ImGuiTable, ptr %179, i32 0, i32 46
  %Max198 = getelementptr inbounds %struct.ImRect, ptr %OuterRect197, i32 0, i32 1
  %y199 = getelementptr inbounds %struct.ImVec2, ptr %Max198, i32 0, i32 1
  %180 = load float, ptr %y199, align 4
  call void @_ZN6ImRectC2Effff(ptr noundef nonnull align 4 dereferenceable(16) %r, float noundef %174, float noundef %176, float noundef %178, float noundef %180)
  %call200 = call noundef ptr @_ZN5ImGui21GetForegroundDrawListEv()
  %Min201 = getelementptr inbounds %struct.ImRect, ptr %r, i32 0, i32 0
  %Max202 = getelementptr inbounds %struct.ImRect, ptr %r, i32 0, i32 1
  call void @_ZN10ImDrawList7AddRectERK6ImVec2S2_jfif(ptr noundef nonnull align 8 dereferenceable(196) %call200, ptr noundef nonnull align 4 dereferenceable(8) %Min201, ptr noundef nonnull align 4 dereferenceable(8) %Max202, i32 noundef -16711681, float noundef 0.000000e+00, i32 noundef 0, float noundef 1.000000e+00)
  br label %if.end203

if.end203:                                        ; preds = %if.then191, %cond.end171
  br label %for.inc204

for.inc204:                                       ; preds = %if.end203
  %181 = load i32, ptr %n83, align 4
  %inc205 = add nsw i32 %181, 1
  store i32 %inc205, ptr %n83, align 4
  br label %for.cond84, !llvm.loop !67

for.end206:                                       ; preds = %for.cond84
  %182 = load ptr, ptr %table.addr, align 8
  %call207 = call noundef ptr @_ZN5ImGui21TableGetBoundSettingsEP10ImGuiTable(ptr noundef %182)
  store ptr %call207, ptr %settings, align 8
  %183 = load ptr, ptr %settings, align 8
  %tobool208 = icmp ne ptr %183, null
  br i1 %tobool208, label %if.then209, label %if.end210

if.then209:                                       ; preds = %for.end206
  %184 = load ptr, ptr %settings, align 8
  call void @_ZN5ImGui22DebugNodeTableSettingsEP18ImGuiTableSettings(ptr noundef %184)
  br label %if.end210

if.end210:                                        ; preds = %if.then209, %for.end206
  %185 = load i8, ptr %clear_settings, align 1
  %tobool211 = trunc i8 %185 to i1
  br i1 %tobool211, label %if.then212, label %if.end213

if.then212:                                       ; preds = %if.end210
  %186 = load ptr, ptr %table.addr, align 8
  %IsResetAllRequest = getelementptr inbounds %struct.ImGuiTable, ptr %186, i32 0, i32 102
  store i8 1, ptr %IsResetAllRequest, align 8
  br label %if.end213

if.end213:                                        ; preds = %if.then212, %if.end210
  call void @_ZN5ImGui7TreePopEv()
  br label %return

return:                                           ; preds = %if.end213, %if.then22
  ret void
}

declare noundef i32 @_ZN5ImGui13GetFrameCountEv() #1

declare void @_ZN5ImGui14PushStyleColorEiRK6ImVec4(i32 noundef, ptr noundef nonnull align 4 dereferenceable(16)) #1

declare noundef nonnull align 4 dereferenceable(16) ptr @_ZN5ImGui17GetStyleColorVec4Ei(i32 noundef) #1

declare noundef zeroext i1 @_ZN5ImGui8TreeNodeEPKvPKcz(ptr noundef, ptr noundef, ...) #1

declare noundef ptr @_ZN5ImGui21GetForegroundDrawListEv() #1

declare noundef zeroext i1 @_ZN5ImGui13IsItemVisibleEv() #1

declare <2 x float> @_ZN5ImGui14GetItemRectMinEv() #1

declare <2 x float> @_ZN5ImGui14GetItemRectMaxEv() #1

declare void @_ZN5ImGui4TextEPKcz(ptr noundef, ...) #1

declare noundef zeroext i1 @_ZN5ImGui11SmallButtonEPKc(ptr noundef) #1

declare void @_ZN5ImGui10BulletTextEPKcz(ptr noundef, ...) #1

; Function Attrs: mustprogress nounwind uwtable
define internal noundef ptr @_ZL33DebugNodeTableGetSizingPolicyDesci(i32 noundef %sizing_policy) #3 {
entry:
  %retval = alloca ptr, align 8
  %sizing_policy.addr = alloca i32, align 4
  store i32 %sizing_policy, ptr %sizing_policy.addr, align 4
  %0 = load i32, ptr %sizing_policy.addr, align 4
  %and = and i32 %0, 57344
  store i32 %and, ptr %sizing_policy.addr, align 4
  %1 = load i32, ptr %sizing_policy.addr, align 4
  %cmp = icmp eq i32 %1, 8192
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr @.str.57, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %sizing_policy.addr, align 4
  %cmp1 = icmp eq i32 %2, 16384
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store ptr @.str.58, ptr %retval, align 8
  br label %return

if.end3:                                          ; preds = %if.end
  %3 = load i32, ptr %sizing_policy.addr, align 4
  %cmp4 = icmp eq i32 %3, 24576
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end3
  store ptr @.str.59, ptr %retval, align 8
  br label %return

if.end6:                                          ; preds = %if.end3
  %4 = load i32, ptr %sizing_policy.addr, align 4
  %cmp7 = icmp eq i32 %4, 32768
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end6
  store ptr @.str.60, ptr %retval, align 8
  br label %return

if.end9:                                          ; preds = %if.end6
  store ptr @.str.61, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end9, %if.then8, %if.then5, %if.then2, %if.then
  %5 = load ptr, ptr %retval, align 8
  ret ptr %5
}

declare void @_ZN5ImGui6BulletEv() #1

declare noundef zeroext i1 @_ZN5ImGui10SelectableEPKcbiRK6ImVec2(ptr noundef, i1 noundef zeroext, i32 noundef, ptr noundef nonnull align 4 dereferenceable(8)) #1

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui22DebugNodeTableSettingsEP18ImGuiTableSettings(ptr noundef %settings) #0 {
entry:
  %settings.addr = alloca ptr, align 8
  %n = alloca i32, align 4
  %column_settings = alloca ptr, align 8
  %sort_dir = alloca i32, align 4
  store ptr %settings, ptr %settings.addr, align 8
  %0 = load ptr, ptr %settings.addr, align 8
  %ID = getelementptr inbounds %struct.ImGuiTableSettings, ptr %0, i32 0, i32 0
  %1 = load i32, ptr %ID, align 4
  %conv = zext i32 %1 to i64
  %2 = inttoptr i64 %conv to ptr
  %3 = load ptr, ptr %settings.addr, align 8
  %ID1 = getelementptr inbounds %struct.ImGuiTableSettings, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %ID1, align 4
  %5 = load ptr, ptr %settings.addr, align 8
  %ColumnsCount = getelementptr inbounds %struct.ImGuiTableSettings, ptr %5, i32 0, i32 3
  %6 = load i16, ptr %ColumnsCount, align 4
  %conv2 = sext i16 %6 to i32
  %call = call noundef zeroext i1 (ptr, ptr, ...) @_ZN5ImGui8TreeNodeEPKvPKcz(ptr noundef %2, ptr noundef @.str.27, i32 noundef %4, i32 noundef %conv2)
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %7 = load ptr, ptr %settings.addr, align 8
  %SaveFlags = getelementptr inbounds %struct.ImGuiTableSettings, ptr %7, i32 0, i32 1
  %8 = load i32, ptr %SaveFlags, align 4
  call void (ptr, ...) @_ZN5ImGui10BulletTextEPKcz(ptr noundef @.str.28, i32 noundef %8)
  %9 = load ptr, ptr %settings.addr, align 8
  %ColumnsCount3 = getelementptr inbounds %struct.ImGuiTableSettings, ptr %9, i32 0, i32 3
  %10 = load i16, ptr %ColumnsCount3, align 4
  %conv4 = sext i16 %10 to i32
  %11 = load ptr, ptr %settings.addr, align 8
  %ColumnsCountMax = getelementptr inbounds %struct.ImGuiTableSettings, ptr %11, i32 0, i32 4
  %12 = load i16, ptr %ColumnsCountMax, align 2
  %conv5 = sext i16 %12 to i32
  call void (ptr, ...) @_ZN5ImGui10BulletTextEPKcz(ptr noundef @.str.29, i32 noundef %conv4, i32 noundef %conv5)
  store i32 0, ptr %n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %13 = load i32, ptr %n, align 4
  %14 = load ptr, ptr %settings.addr, align 8
  %ColumnsCount6 = getelementptr inbounds %struct.ImGuiTableSettings, ptr %14, i32 0, i32 3
  %15 = load i16, ptr %ColumnsCount6, align 4
  %conv7 = sext i16 %15 to i32
  %cmp = icmp slt i32 %13, %conv7
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %16 = load ptr, ptr %settings.addr, align 8
  %call8 = call noundef ptr @_ZN18ImGuiTableSettings17GetColumnSettingsEv(ptr noundef nonnull align 4 dereferenceable(17) %16)
  %17 = load i32, ptr %n, align 4
  %idxprom = sext i32 %17 to i64
  %arrayidx = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %call8, i64 %idxprom
  store ptr %arrayidx, ptr %column_settings, align 8
  %18 = load ptr, ptr %column_settings, align 8
  %SortOrder = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %18, i32 0, i32 4
  %19 = load i16, ptr %SortOrder, align 4
  %conv9 = sext i16 %19 to i32
  %cmp10 = icmp ne i32 %conv9, -1
  br i1 %cmp10, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  %20 = load ptr, ptr %column_settings, align 8
  %SortDirection = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %20, i32 0, i32 5
  %bf.load = load i8, ptr %SortDirection, align 2
  %bf.clear = and i8 %bf.load, 3
  %conv11 = zext i8 %bf.clear to i32
  br label %cond.end

cond.false:                                       ; preds = %for.body
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv11, %cond.true ], [ 0, %cond.false ]
  store i32 %cond, ptr %sort_dir, align 4
  %21 = load i32, ptr %n, align 4
  %22 = load ptr, ptr %column_settings, align 8
  %DisplayOrder = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %22, i32 0, i32 3
  %23 = load i16, ptr %DisplayOrder, align 2
  %conv12 = sext i16 %23 to i32
  %24 = load ptr, ptr %column_settings, align 8
  %SortOrder13 = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %24, i32 0, i32 4
  %25 = load i16, ptr %SortOrder13, align 4
  %conv14 = sext i16 %25 to i32
  %26 = load i32, ptr %sort_dir, align 4
  %cmp15 = icmp eq i32 %26, 1
  br i1 %cmp15, label %cond.true16, label %cond.false17

cond.true16:                                      ; preds = %cond.end
  br label %cond.end22

cond.false17:                                     ; preds = %cond.end
  %27 = load i32, ptr %sort_dir, align 4
  %cmp18 = icmp eq i32 %27, 2
  br i1 %cmp18, label %cond.true19, label %cond.false20

cond.true19:                                      ; preds = %cond.false17
  br label %cond.end21

cond.false20:                                     ; preds = %cond.false17
  br label %cond.end21

cond.end21:                                       ; preds = %cond.false20, %cond.true19
  %cond-lvalue = phi ptr [ @.str.32, %cond.true19 ], [ @.str.33, %cond.false20 ]
  br label %cond.end22

cond.end22:                                       ; preds = %cond.end21, %cond.true16
  %cond-lvalue23 = phi ptr [ @.str.31, %cond.true16 ], [ %cond-lvalue, %cond.end21 ]
  %arraydecay = getelementptr inbounds [4 x i8], ptr %cond-lvalue23, i64 0, i64 0
  %28 = load ptr, ptr %column_settings, align 8
  %IsEnabled = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %28, i32 0, i32 5
  %bf.load24 = load i8, ptr %IsEnabled, align 2
  %bf.lshr = lshr i8 %bf.load24, 2
  %bf.clear25 = and i8 %bf.lshr, 1
  %conv26 = zext i8 %bf.clear25 to i32
  %29 = load ptr, ptr %column_settings, align 8
  %IsStretch = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %29, i32 0, i32 5
  %bf.load27 = load i8, ptr %IsStretch, align 2
  %bf.lshr28 = lshr i8 %bf.load27, 3
  %bf.clear29 = and i8 %bf.lshr28, 1
  %tobool = icmp ne i8 %bf.clear29, 0
  br i1 %tobool, label %cond.true30, label %cond.false31

cond.true30:                                      ; preds = %cond.end22
  br label %cond.end32

cond.false31:                                     ; preds = %cond.end22
  br label %cond.end32

cond.end32:                                       ; preds = %cond.false31, %cond.true30
  %cond-lvalue33 = phi ptr [ @.str.34, %cond.true30 ], [ @.str.35, %cond.false31 ]
  %arraydecay34 = getelementptr inbounds [7 x i8], ptr %cond-lvalue33, i64 0, i64 0
  %30 = load ptr, ptr %column_settings, align 8
  %WidthOrWeight = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %30, i32 0, i32 0
  %31 = load float, ptr %WidthOrWeight, align 4
  %conv35 = fpext float %31 to double
  %32 = load ptr, ptr %column_settings, align 8
  %UserID = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %32, i32 0, i32 1
  %33 = load i32, ptr %UserID, align 4
  call void (ptr, ...) @_ZN5ImGui10BulletTextEPKcz(ptr noundef @.str.30, i32 noundef %21, i32 noundef %conv12, i32 noundef %conv14, ptr noundef %arraydecay, i32 noundef %conv26, ptr noundef %arraydecay34, double noundef %conv35, i32 noundef %33)
  br label %for.inc

for.inc:                                          ; preds = %cond.end32
  %34 = load i32, ptr %n, align 4
  %inc = add nsw i32 %34, 1
  store i32 %inc, ptr %n, align 4
  br label %for.cond, !llvm.loop !68

for.end:                                          ; preds = %for.cond
  call void @_ZN5ImGui7TreePopEv()
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

declare void @_ZN5ImGui7TreePopEv() #1

; Function Attrs: mustprogress uwtable
define noundef i32 @_ZN5ImGui14GetColumnIndexEv() #0 {
entry:
  %window = alloca ptr, align 8
  %call = call noundef ptr @_ZN5ImGui20GetCurrentWindowReadEv()
  store ptr %call, ptr %window, align 8
  %0 = load ptr, ptr %window, align 8
  %DC = getelementptr inbounds %struct.ImGuiWindow, ptr %0, i32 0, i32 68
  %CurrentColumns = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC, i32 0, i32 28
  %1 = load ptr, ptr %CurrentColumns, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %window, align 8
  %DC1 = getelementptr inbounds %struct.ImGuiWindow, ptr %2, i32 0, i32 68
  %CurrentColumns2 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC1, i32 0, i32 28
  %3 = load ptr, ptr %CurrentColumns2, align 8
  %Current = getelementptr inbounds %struct.ImGuiOldColumns, ptr %3, i32 0, i32 4
  %4 = load i32, ptr %Current, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %4, %cond.true ], [ 0, %cond.false ]
  ret i32 %cond
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef ptr @_ZN5ImGui20GetCurrentWindowReadEv() #3 comdat {
entry:
  %g = alloca ptr, align 8
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %g, align 8
  %CurrentWindow = getelementptr inbounds %struct.ImGuiContext, ptr %1, i32 0, i32 29
  %2 = load ptr, ptr %CurrentWindow, align 8
  ret ptr %2
}

; Function Attrs: mustprogress uwtable
define noundef i32 @_ZN5ImGui15GetColumnsCountEv() #0 {
entry:
  %window = alloca ptr, align 8
  %call = call noundef ptr @_ZN5ImGui20GetCurrentWindowReadEv()
  store ptr %call, ptr %window, align 8
  %0 = load ptr, ptr %window, align 8
  %DC = getelementptr inbounds %struct.ImGuiWindow, ptr %0, i32 0, i32 68
  %CurrentColumns = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC, i32 0, i32 28
  %1 = load ptr, ptr %CurrentColumns, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %window, align 8
  %DC1 = getelementptr inbounds %struct.ImGuiWindow, ptr %2, i32 0, i32 68
  %CurrentColumns2 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC1, i32 0, i32 28
  %3 = load ptr, ptr %CurrentColumns2, align 8
  %Count = getelementptr inbounds %struct.ImGuiOldColumns, ptr %3, i32 0, i32 5
  %4 = load i32, ptr %Count, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %4, %cond.true ], [ 1, %cond.false ]
  ret i32 %cond
}

; Function Attrs: mustprogress nounwind uwtable
define noundef float @_ZN5ImGui23GetColumnOffsetFromNormEPK15ImGuiOldColumnsf(ptr noundef %columns, float noundef %offset_norm) #3 {
entry:
  %columns.addr = alloca ptr, align 8
  %offset_norm.addr = alloca float, align 4
  store ptr %columns, ptr %columns.addr, align 8
  store float %offset_norm, ptr %offset_norm.addr, align 4
  %0 = load float, ptr %offset_norm.addr, align 4
  %1 = load ptr, ptr %columns.addr, align 8
  %OffMaxX = getelementptr inbounds %struct.ImGuiOldColumns, ptr %1, i32 0, i32 7
  %2 = load float, ptr %OffMaxX, align 8
  %3 = load ptr, ptr %columns.addr, align 8
  %OffMinX = getelementptr inbounds %struct.ImGuiOldColumns, ptr %3, i32 0, i32 6
  %4 = load float, ptr %OffMinX, align 4
  %sub = fsub float %2, %4
  %mul = fmul float %0, %sub
  ret float %mul
}

; Function Attrs: mustprogress nounwind uwtable
define noundef float @_ZN5ImGui23GetColumnNormFromOffsetEPK15ImGuiOldColumnsf(ptr noundef %columns, float noundef %offset) #3 {
entry:
  %columns.addr = alloca ptr, align 8
  %offset.addr = alloca float, align 4
  store ptr %columns, ptr %columns.addr, align 8
  store float %offset, ptr %offset.addr, align 4
  %0 = load float, ptr %offset.addr, align 4
  %1 = load ptr, ptr %columns.addr, align 8
  %OffMaxX = getelementptr inbounds %struct.ImGuiOldColumns, ptr %1, i32 0, i32 7
  %2 = load float, ptr %OffMaxX, align 8
  %3 = load ptr, ptr %columns.addr, align 8
  %OffMinX = getelementptr inbounds %struct.ImGuiOldColumns, ptr %3, i32 0, i32 6
  %4 = load float, ptr %OffMinX, align 4
  %sub = fsub float %2, %4
  %div = fdiv float %0, %sub
  ret float %div
}

; Function Attrs: mustprogress uwtable
define noundef float @_ZN5ImGui15GetColumnOffsetEi(i32 noundef %column_index) #0 {
entry:
  %retval = alloca float, align 4
  %column_index.addr = alloca i32, align 4
  %window = alloca ptr, align 8
  %columns = alloca ptr, align 8
  %t = alloca float, align 4
  %x_offset = alloca float, align 4
  store i32 %column_index, ptr %column_index.addr, align 4
  %call = call noundef ptr @_ZN5ImGui20GetCurrentWindowReadEv()
  store ptr %call, ptr %window, align 8
  %0 = load ptr, ptr %window, align 8
  %DC = getelementptr inbounds %struct.ImGuiWindow, ptr %0, i32 0, i32 68
  %CurrentColumns = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC, i32 0, i32 28
  %1 = load ptr, ptr %CurrentColumns, align 8
  store ptr %1, ptr %columns, align 8
  %2 = load ptr, ptr %columns, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store float 0.000000e+00, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %3 = load i32, ptr %column_index.addr, align 4
  %cmp1 = icmp slt i32 %3, 0
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %4 = load ptr, ptr %columns, align 8
  %Current = getelementptr inbounds %struct.ImGuiOldColumns, ptr %4, i32 0, i32 4
  %5 = load i32, ptr %Current, align 4
  store i32 %5, ptr %column_index.addr, align 4
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end
  %6 = load ptr, ptr %columns, align 8
  %Columns = getelementptr inbounds %struct.ImGuiOldColumns, ptr %6, i32 0, i32 15
  %7 = load i32, ptr %column_index.addr, align 4
  %call4 = call noundef nonnull align 4 dereferenceable(28) ptr @_ZN8ImVectorI18ImGuiOldColumnDataEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns, i32 noundef %7)
  %OffsetNorm = getelementptr inbounds %struct.ImGuiOldColumnData, ptr %call4, i32 0, i32 0
  %8 = load float, ptr %OffsetNorm, align 4
  store float %8, ptr %t, align 4
  %9 = load ptr, ptr %columns, align 8
  %OffMinX = getelementptr inbounds %struct.ImGuiOldColumns, ptr %9, i32 0, i32 6
  %10 = load float, ptr %OffMinX, align 4
  %11 = load ptr, ptr %columns, align 8
  %OffMaxX = getelementptr inbounds %struct.ImGuiOldColumns, ptr %11, i32 0, i32 7
  %12 = load float, ptr %OffMaxX, align 8
  %13 = load float, ptr %t, align 4
  %call5 = call noundef float @_ZL6ImLerpIfET_S0_S0_f(float noundef %10, float noundef %12, float noundef %13)
  store float %call5, ptr %x_offset, align 4
  %14 = load float, ptr %x_offset, align 4
  store float %14, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end3, %if.then
  %15 = load float, ptr %retval, align 4
  ret float %15
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef nonnull align 4 dereferenceable(28) ptr @_ZN8ImVectorI18ImGuiOldColumnDataEixEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %i) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.40, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.ImGuiOldColumnData, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef float @_ZL6ImLerpIfET_S0_S0_f(float noundef %a, float noundef %b, float noundef %t) #3 {
entry:
  %a.addr = alloca float, align 4
  %b.addr = alloca float, align 4
  %t.addr = alloca float, align 4
  store float %a, ptr %a.addr, align 4
  store float %b, ptr %b.addr, align 4
  store float %t, ptr %t.addr, align 4
  %0 = load float, ptr %a.addr, align 4
  %1 = load float, ptr %b.addr, align 4
  %2 = load float, ptr %a.addr, align 4
  %sub = fsub float %1, %2
  %3 = load float, ptr %t.addr, align 4
  %4 = call float @llvm.fmuladd.f32(float %sub, float %3, float %0)
  ret float %4
}

; Function Attrs: mustprogress uwtable
define noundef float @_ZN5ImGui14GetColumnWidthEi(i32 noundef %column_index) #2 {
entry:
  %retval = alloca float, align 4
  %column_index.addr = alloca i32, align 4
  %g = alloca ptr, align 8
  %window = alloca ptr, align 8
  %columns = alloca ptr, align 8
  %ref.tmp = alloca %struct.ImVec2, align 4
  store i32 %column_index, ptr %column_index.addr, align 4
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %g, align 8
  %CurrentWindow = getelementptr inbounds %struct.ImGuiContext, ptr %1, i32 0, i32 29
  %2 = load ptr, ptr %CurrentWindow, align 8
  store ptr %2, ptr %window, align 8
  %3 = load ptr, ptr %window, align 8
  %DC = getelementptr inbounds %struct.ImGuiWindow, ptr %3, i32 0, i32 68
  %CurrentColumns = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC, i32 0, i32 28
  %4 = load ptr, ptr %CurrentColumns, align 8
  store ptr %4, ptr %columns, align 8
  %5 = load ptr, ptr %columns, align 8
  %cmp = icmp eq ptr %5, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call <2 x float> @_ZN5ImGui21GetContentRegionAvailEv()
  store <2 x float> %call, ptr %ref.tmp, align 4
  %x = getelementptr inbounds %struct.ImVec2, ptr %ref.tmp, i32 0, i32 0
  %6 = load float, ptr %x, align 4
  store float %6, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %7 = load i32, ptr %column_index.addr, align 4
  %cmp1 = icmp slt i32 %7, 0
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %8 = load ptr, ptr %columns, align 8
  %Current = getelementptr inbounds %struct.ImGuiOldColumns, ptr %8, i32 0, i32 4
  %9 = load i32, ptr %Current, align 4
  store i32 %9, ptr %column_index.addr, align 4
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end
  %10 = load ptr, ptr %columns, align 8
  %11 = load ptr, ptr %columns, align 8
  %Columns = getelementptr inbounds %struct.ImGuiOldColumns, ptr %11, i32 0, i32 15
  %12 = load i32, ptr %column_index.addr, align 4
  %add = add nsw i32 %12, 1
  %call4 = call noundef nonnull align 4 dereferenceable(28) ptr @_ZN8ImVectorI18ImGuiOldColumnDataEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns, i32 noundef %add)
  %OffsetNorm = getelementptr inbounds %struct.ImGuiOldColumnData, ptr %call4, i32 0, i32 0
  %13 = load float, ptr %OffsetNorm, align 4
  %14 = load ptr, ptr %columns, align 8
  %Columns5 = getelementptr inbounds %struct.ImGuiOldColumns, ptr %14, i32 0, i32 15
  %15 = load i32, ptr %column_index.addr, align 4
  %call6 = call noundef nonnull align 4 dereferenceable(28) ptr @_ZN8ImVectorI18ImGuiOldColumnDataEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns5, i32 noundef %15)
  %OffsetNorm7 = getelementptr inbounds %struct.ImGuiOldColumnData, ptr %call6, i32 0, i32 0
  %16 = load float, ptr %OffsetNorm7, align 4
  %sub = fsub float %13, %16
  %call8 = call noundef float @_ZN5ImGui23GetColumnOffsetFromNormEPK15ImGuiOldColumnsf(ptr noundef %10, float noundef %sub)
  store float %call8, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end3, %if.then
  %17 = load float, ptr %retval, align 4
  ret float %17
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui15SetColumnOffsetEif(i32 noundef %column_index, float noundef %offset) #0 {
entry:
  %column_index.addr = alloca i32, align 4
  %offset.addr = alloca float, align 4
  %g = alloca ptr, align 8
  %window = alloca ptr, align 8
  %columns = alloca ptr, align 8
  %preserve_width = alloca i8, align 1
  %width = alloca float, align 4
  store i32 %column_index, ptr %column_index.addr, align 4
  store float %offset, ptr %offset.addr, align 4
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %g, align 8
  %CurrentWindow = getelementptr inbounds %struct.ImGuiContext, ptr %1, i32 0, i32 29
  %2 = load ptr, ptr %CurrentWindow, align 8
  store ptr %2, ptr %window, align 8
  %3 = load ptr, ptr %window, align 8
  %DC = getelementptr inbounds %struct.ImGuiWindow, ptr %3, i32 0, i32 68
  %CurrentColumns = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC, i32 0, i32 28
  %4 = load ptr, ptr %CurrentColumns, align 8
  store ptr %4, ptr %columns, align 8
  %5 = load i32, ptr %column_index.addr, align 4
  %cmp = icmp slt i32 %5, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load ptr, ptr %columns, align 8
  %Current = getelementptr inbounds %struct.ImGuiOldColumns, ptr %6, i32 0, i32 4
  %7 = load i32, ptr %Current, align 4
  store i32 %7, ptr %column_index.addr, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %8 = load ptr, ptr %columns, align 8
  %Flags = getelementptr inbounds %struct.ImGuiOldColumns, ptr %8, i32 0, i32 1
  %9 = load i32, ptr %Flags, align 4
  %and = and i32 %9, 4
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %if.end
  %10 = load i32, ptr %column_index.addr, align 4
  %11 = load ptr, ptr %columns, align 8
  %Count = getelementptr inbounds %struct.ImGuiOldColumns, ptr %11, i32 0, i32 5
  %12 = load i32, ptr %Count, align 8
  %sub = sub nsw i32 %12, 1
  %cmp1 = icmp slt i32 %10, %sub
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end
  %13 = phi i1 [ false, %if.end ], [ %cmp1, %land.rhs ]
  %frombool = zext i1 %13 to i8
  store i8 %frombool, ptr %preserve_width, align 1
  %14 = load i8, ptr %preserve_width, align 1
  %tobool2 = trunc i8 %14 to i1
  br i1 %tobool2, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.end
  %15 = load ptr, ptr %columns, align 8
  %16 = load i32, ptr %column_index.addr, align 4
  %17 = load ptr, ptr %columns, align 8
  %IsBeingResized = getelementptr inbounds %struct.ImGuiOldColumns, ptr %17, i32 0, i32 3
  %18 = load i8, ptr %IsBeingResized, align 1
  %tobool3 = trunc i8 %18 to i1
  %call = call noundef float @_ZL16GetColumnWidthExP15ImGuiOldColumnsib(ptr noundef %15, i32 noundef %16, i1 noundef zeroext %tobool3)
  br label %cond.end

cond.false:                                       ; preds = %land.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi float [ %call, %cond.true ], [ 0.000000e+00, %cond.false ]
  store float %cond, ptr %width, align 4
  %19 = load ptr, ptr %columns, align 8
  %Flags4 = getelementptr inbounds %struct.ImGuiOldColumns, ptr %19, i32 0, i32 1
  %20 = load i32, ptr %Flags4, align 4
  %and5 = and i32 %20, 8
  %tobool6 = icmp ne i32 %and5, 0
  br i1 %tobool6, label %if.end11, label %if.then7

if.then7:                                         ; preds = %cond.end
  %21 = load float, ptr %offset.addr, align 4
  %22 = load ptr, ptr %columns, align 8
  %OffMaxX = getelementptr inbounds %struct.ImGuiOldColumns, ptr %22, i32 0, i32 7
  %23 = load float, ptr %OffMaxX, align 8
  %24 = load ptr, ptr %g, align 8
  %Style = getelementptr inbounds %struct.ImGuiContext, ptr %24, i32 0, i32 3
  %ColumnsMinSpacing = getelementptr inbounds %struct.ImGuiStyle, ptr %Style, i32 0, i32 20
  %25 = load float, ptr %ColumnsMinSpacing, align 8
  %26 = load ptr, ptr %columns, align 8
  %Count8 = getelementptr inbounds %struct.ImGuiOldColumns, ptr %26, i32 0, i32 5
  %27 = load i32, ptr %Count8, align 8
  %28 = load i32, ptr %column_index.addr, align 4
  %sub9 = sub nsw i32 %27, %28
  %conv = sitofp i32 %sub9 to float
  %neg = fneg float %25
  %29 = call float @llvm.fmuladd.f32(float %neg, float %conv, float %23)
  %call10 = call noundef float @_ZL5ImMinIfET_S0_S0_(float noundef %21, float noundef %29)
  store float %call10, ptr %offset.addr, align 4
  br label %if.end11

if.end11:                                         ; preds = %if.then7, %cond.end
  %30 = load ptr, ptr %columns, align 8
  %31 = load float, ptr %offset.addr, align 4
  %32 = load ptr, ptr %columns, align 8
  %OffMinX = getelementptr inbounds %struct.ImGuiOldColumns, ptr %32, i32 0, i32 6
  %33 = load float, ptr %OffMinX, align 4
  %sub12 = fsub float %31, %33
  %call13 = call noundef float @_ZN5ImGui23GetColumnNormFromOffsetEPK15ImGuiOldColumnsf(ptr noundef %30, float noundef %sub12)
  %34 = load ptr, ptr %columns, align 8
  %Columns = getelementptr inbounds %struct.ImGuiOldColumns, ptr %34, i32 0, i32 15
  %35 = load i32, ptr %column_index.addr, align 4
  %call14 = call noundef nonnull align 4 dereferenceable(28) ptr @_ZN8ImVectorI18ImGuiOldColumnDataEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns, i32 noundef %35)
  %OffsetNorm = getelementptr inbounds %struct.ImGuiOldColumnData, ptr %call14, i32 0, i32 0
  store float %call13, ptr %OffsetNorm, align 4
  %36 = load i8, ptr %preserve_width, align 1
  %tobool15 = trunc i8 %36 to i1
  br i1 %tobool15, label %if.then16, label %if.end21

if.then16:                                        ; preds = %if.end11
  %37 = load i32, ptr %column_index.addr, align 4
  %add = add nsw i32 %37, 1
  %38 = load float, ptr %offset.addr, align 4
  %39 = load ptr, ptr %g, align 8
  %Style17 = getelementptr inbounds %struct.ImGuiContext, ptr %39, i32 0, i32 3
  %ColumnsMinSpacing18 = getelementptr inbounds %struct.ImGuiStyle, ptr %Style17, i32 0, i32 20
  %40 = load float, ptr %ColumnsMinSpacing18, align 8
  %41 = load float, ptr %width, align 4
  %call19 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %40, float noundef %41)
  %add20 = fadd float %38, %call19
  call void @_ZN5ImGui15SetColumnOffsetEif(i32 noundef %add, float noundef %add20)
  br label %if.end21

if.end21:                                         ; preds = %if.then16, %if.end11
  ret void
}

; Function Attrs: mustprogress uwtable
define internal noundef float @_ZL16GetColumnWidthExP15ImGuiOldColumnsib(ptr noundef %columns, i32 noundef %column_index, i1 noundef zeroext %before_resize) #0 {
entry:
  %columns.addr = alloca ptr, align 8
  %column_index.addr = alloca i32, align 4
  %before_resize.addr = alloca i8, align 1
  %offset_norm = alloca float, align 4
  store ptr %columns, ptr %columns.addr, align 8
  store i32 %column_index, ptr %column_index.addr, align 4
  %frombool = zext i1 %before_resize to i8
  store i8 %frombool, ptr %before_resize.addr, align 1
  %0 = load i32, ptr %column_index.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %columns.addr, align 8
  %Current = getelementptr inbounds %struct.ImGuiOldColumns, ptr %1, i32 0, i32 4
  %2 = load i32, ptr %Current, align 4
  store i32 %2, ptr %column_index.addr, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i8, ptr %before_resize.addr, align 1
  %tobool = trunc i8 %3 to i1
  br i1 %tobool, label %if.then1, label %if.else

if.then1:                                         ; preds = %if.end
  %4 = load ptr, ptr %columns.addr, align 8
  %Columns = getelementptr inbounds %struct.ImGuiOldColumns, ptr %4, i32 0, i32 15
  %5 = load i32, ptr %column_index.addr, align 4
  %add = add nsw i32 %5, 1
  %call = call noundef nonnull align 4 dereferenceable(28) ptr @_ZN8ImVectorI18ImGuiOldColumnDataEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns, i32 noundef %add)
  %OffsetNormBeforeResize = getelementptr inbounds %struct.ImGuiOldColumnData, ptr %call, i32 0, i32 1
  %6 = load float, ptr %OffsetNormBeforeResize, align 4
  %7 = load ptr, ptr %columns.addr, align 8
  %Columns2 = getelementptr inbounds %struct.ImGuiOldColumns, ptr %7, i32 0, i32 15
  %8 = load i32, ptr %column_index.addr, align 4
  %call3 = call noundef nonnull align 4 dereferenceable(28) ptr @_ZN8ImVectorI18ImGuiOldColumnDataEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns2, i32 noundef %8)
  %OffsetNormBeforeResize4 = getelementptr inbounds %struct.ImGuiOldColumnData, ptr %call3, i32 0, i32 1
  %9 = load float, ptr %OffsetNormBeforeResize4, align 4
  %sub = fsub float %6, %9
  store float %sub, ptr %offset_norm, align 4
  br label %if.end12

if.else:                                          ; preds = %if.end
  %10 = load ptr, ptr %columns.addr, align 8
  %Columns5 = getelementptr inbounds %struct.ImGuiOldColumns, ptr %10, i32 0, i32 15
  %11 = load i32, ptr %column_index.addr, align 4
  %add6 = add nsw i32 %11, 1
  %call7 = call noundef nonnull align 4 dereferenceable(28) ptr @_ZN8ImVectorI18ImGuiOldColumnDataEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns5, i32 noundef %add6)
  %OffsetNorm = getelementptr inbounds %struct.ImGuiOldColumnData, ptr %call7, i32 0, i32 0
  %12 = load float, ptr %OffsetNorm, align 4
  %13 = load ptr, ptr %columns.addr, align 8
  %Columns8 = getelementptr inbounds %struct.ImGuiOldColumns, ptr %13, i32 0, i32 15
  %14 = load i32, ptr %column_index.addr, align 4
  %call9 = call noundef nonnull align 4 dereferenceable(28) ptr @_ZN8ImVectorI18ImGuiOldColumnDataEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns8, i32 noundef %14)
  %OffsetNorm10 = getelementptr inbounds %struct.ImGuiOldColumnData, ptr %call9, i32 0, i32 0
  %15 = load float, ptr %OffsetNorm10, align 4
  %sub11 = fsub float %12, %15
  store float %sub11, ptr %offset_norm, align 4
  br label %if.end12

if.end12:                                         ; preds = %if.else, %if.then1
  %16 = load ptr, ptr %columns.addr, align 8
  %17 = load float, ptr %offset_norm, align 4
  %call13 = call noundef float @_ZN5ImGui23GetColumnOffsetFromNormEPK15ImGuiOldColumnsf(ptr noundef %16, float noundef %17)
  ret float %call13
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui14SetColumnWidthEif(i32 noundef %column_index, float noundef %width) #0 {
entry:
  %column_index.addr = alloca i32, align 4
  %width.addr = alloca float, align 4
  %window = alloca ptr, align 8
  %columns = alloca ptr, align 8
  store i32 %column_index, ptr %column_index.addr, align 4
  store float %width, ptr %width.addr, align 4
  %call = call noundef ptr @_ZN5ImGui20GetCurrentWindowReadEv()
  store ptr %call, ptr %window, align 8
  %0 = load ptr, ptr %window, align 8
  %DC = getelementptr inbounds %struct.ImGuiWindow, ptr %0, i32 0, i32 68
  %CurrentColumns = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC, i32 0, i32 28
  %1 = load ptr, ptr %CurrentColumns, align 8
  store ptr %1, ptr %columns, align 8
  %2 = load i32, ptr %column_index.addr, align 4
  %cmp = icmp slt i32 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %columns, align 8
  %Current = getelementptr inbounds %struct.ImGuiOldColumns, ptr %3, i32 0, i32 4
  %4 = load i32, ptr %Current, align 4
  store i32 %4, ptr %column_index.addr, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load i32, ptr %column_index.addr, align 4
  %add = add nsw i32 %5, 1
  %6 = load i32, ptr %column_index.addr, align 4
  %call1 = call noundef float @_ZN5ImGui15GetColumnOffsetEi(i32 noundef %6)
  %7 = load float, ptr %width.addr, align 4
  %add2 = fadd float %call1, %7
  call void @_ZN5ImGui15SetColumnOffsetEif(i32 noundef %add, float noundef %add2)
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui18PushColumnClipRectEi(i32 noundef %column_index) #0 {
entry:
  %column_index.addr = alloca i32, align 4
  %window = alloca ptr, align 8
  %columns = alloca ptr, align 8
  %column = alloca ptr, align 8
  store i32 %column_index, ptr %column_index.addr, align 4
  %call = call noundef ptr @_ZN5ImGui20GetCurrentWindowReadEv()
  store ptr %call, ptr %window, align 8
  %0 = load ptr, ptr %window, align 8
  %DC = getelementptr inbounds %struct.ImGuiWindow, ptr %0, i32 0, i32 68
  %CurrentColumns = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC, i32 0, i32 28
  %1 = load ptr, ptr %CurrentColumns, align 8
  store ptr %1, ptr %columns, align 8
  %2 = load i32, ptr %column_index.addr, align 4
  %cmp = icmp slt i32 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %columns, align 8
  %Current = getelementptr inbounds %struct.ImGuiOldColumns, ptr %3, i32 0, i32 4
  %4 = load i32, ptr %Current, align 4
  store i32 %4, ptr %column_index.addr, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load ptr, ptr %columns, align 8
  %Columns = getelementptr inbounds %struct.ImGuiOldColumns, ptr %5, i32 0, i32 15
  %6 = load i32, ptr %column_index.addr, align 4
  %call1 = call noundef nonnull align 4 dereferenceable(28) ptr @_ZN8ImVectorI18ImGuiOldColumnDataEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns, i32 noundef %6)
  store ptr %call1, ptr %column, align 8
  %7 = load ptr, ptr %column, align 8
  %ClipRect = getelementptr inbounds %struct.ImGuiOldColumnData, ptr %7, i32 0, i32 3
  %Min = getelementptr inbounds %struct.ImRect, ptr %ClipRect, i32 0, i32 0
  %8 = load ptr, ptr %column, align 8
  %ClipRect2 = getelementptr inbounds %struct.ImGuiOldColumnData, ptr %8, i32 0, i32 3
  %Max = getelementptr inbounds %struct.ImRect, ptr %ClipRect2, i32 0, i32 1
  call void @_ZN5ImGui12PushClipRectERK6ImVec2S2_b(ptr noundef nonnull align 4 dereferenceable(8) %Min, ptr noundef nonnull align 4 dereferenceable(8) %Max, i1 noundef zeroext false)
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui21PushColumnsBackgroundEv() #0 {
entry:
  %window = alloca ptr, align 8
  %columns = alloca ptr, align 8
  %call = call noundef ptr @_ZN5ImGui20GetCurrentWindowReadEv()
  store ptr %call, ptr %window, align 8
  %0 = load ptr, ptr %window, align 8
  %DC = getelementptr inbounds %struct.ImGuiWindow, ptr %0, i32 0, i32 68
  %CurrentColumns = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC, i32 0, i32 28
  %1 = load ptr, ptr %CurrentColumns, align 8
  store ptr %1, ptr %columns, align 8
  %2 = load ptr, ptr %columns, align 8
  %Count = getelementptr inbounds %struct.ImGuiOldColumns, ptr %2, i32 0, i32 5
  %3 = load i32, ptr %Count, align 8
  %cmp = icmp eq i32 %3, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %window, align 8
  %ClipRect = getelementptr inbounds %struct.ImGuiWindow, ptr %4, i32 0, i32 74
  %5 = load ptr, ptr %columns, align 8
  %HostBackupClipRect = getelementptr inbounds %struct.ImGuiOldColumns, ptr %5, i32 0, i32 13
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %HostBackupClipRect, ptr align 8 %ClipRect, i64 16, i1 false)
  %6 = load ptr, ptr %window, align 8
  %7 = load ptr, ptr %columns, align 8
  %HostInitialClipRect = getelementptr inbounds %struct.ImGuiOldColumns, ptr %7, i32 0, i32 12
  call void @_ZN5ImGui33SetWindowClipRectBeforeSetChannelEP11ImGuiWindowRK6ImRect(ptr noundef %6, ptr noundef nonnull align 4 dereferenceable(16) %HostInitialClipRect)
  %8 = load ptr, ptr %columns, align 8
  %Splitter = getelementptr inbounds %struct.ImGuiOldColumns, ptr %8, i32 0, i32 16
  %9 = load ptr, ptr %window, align 8
  %DrawList = getelementptr inbounds %struct.ImGuiWindow, ptr %9, i32 0, i32 86
  %10 = load ptr, ptr %DrawList, align 8
  call void @_ZN18ImDrawListSplitter17SetCurrentChannelEP10ImDrawListi(ptr noundef nonnull align 8 dereferenceable(24) %Splitter, ptr noundef %10, i32 noundef 0)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui20PopColumnsBackgroundEv() #0 {
entry:
  %window = alloca ptr, align 8
  %columns = alloca ptr, align 8
  %call = call noundef ptr @_ZN5ImGui20GetCurrentWindowReadEv()
  store ptr %call, ptr %window, align 8
  %0 = load ptr, ptr %window, align 8
  %DC = getelementptr inbounds %struct.ImGuiWindow, ptr %0, i32 0, i32 68
  %CurrentColumns = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC, i32 0, i32 28
  %1 = load ptr, ptr %CurrentColumns, align 8
  store ptr %1, ptr %columns, align 8
  %2 = load ptr, ptr %columns, align 8
  %Count = getelementptr inbounds %struct.ImGuiOldColumns, ptr %2, i32 0, i32 5
  %3 = load i32, ptr %Count, align 8
  %cmp = icmp eq i32 %3, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %window, align 8
  %5 = load ptr, ptr %columns, align 8
  %HostBackupClipRect = getelementptr inbounds %struct.ImGuiOldColumns, ptr %5, i32 0, i32 13
  call void @_ZN5ImGui33SetWindowClipRectBeforeSetChannelEP11ImGuiWindowRK6ImRect(ptr noundef %4, ptr noundef nonnull align 4 dereferenceable(16) %HostBackupClipRect)
  %6 = load ptr, ptr %columns, align 8
  %Splitter = getelementptr inbounds %struct.ImGuiOldColumns, ptr %6, i32 0, i32 16
  %7 = load ptr, ptr %window, align 8
  %DrawList = getelementptr inbounds %struct.ImGuiWindow, ptr %7, i32 0, i32 86
  %8 = load ptr, ptr %DrawList, align 8
  %9 = load ptr, ptr %columns, align 8
  %Current = getelementptr inbounds %struct.ImGuiOldColumns, ptr %9, i32 0, i32 4
  %10 = load i32, ptr %Current, align 4
  %add = add nsw i32 %10, 1
  call void @_ZN18ImDrawListSplitter17SetCurrentChannelEP10ImDrawListi(ptr noundef nonnull align 8 dereferenceable(24) %Splitter, ptr noundef %8, i32 noundef %add)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define noundef ptr @_ZN5ImGui19FindOrCreateColumnsEP11ImGuiWindowj(ptr noundef %window, i32 noundef %id) #0 personality ptr @__gxx_personality_v0 {
entry:
  %retval = alloca ptr, align 8
  %window.addr = alloca ptr, align 8
  %id.addr = alloca i32, align 4
  %n = alloca i32, align 4
  %ref.tmp = alloca %struct.ImGuiOldColumns, align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  %columns = alloca ptr, align 8
  store ptr %window, ptr %window.addr, align 8
  store i32 %id, ptr %id.addr, align 4
  store i32 0, ptr %n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %n, align 4
  %1 = load ptr, ptr %window.addr, align 8
  %ColumnsStorage = getelementptr inbounds %struct.ImGuiWindow, ptr %1, i32 0, i32 83
  %Size = getelementptr inbounds %struct.ImVector.31, ptr %ColumnsStorage, i32 0, i32 0
  %2 = load i32, ptr %Size, align 8
  %cmp = icmp slt i32 %0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %window.addr, align 8
  %ColumnsStorage1 = getelementptr inbounds %struct.ImGuiWindow, ptr %3, i32 0, i32 83
  %4 = load i32, ptr %n, align 4
  %call = call noundef nonnull align 8 dereferenceable(136) ptr @_ZN8ImVectorI15ImGuiOldColumnsEixEi(ptr noundef nonnull align 8 dereferenceable(16) %ColumnsStorage1, i32 noundef %4)
  %ID = getelementptr inbounds %struct.ImGuiOldColumns, ptr %call, i32 0, i32 0
  %5 = load i32, ptr %ID, align 8
  %6 = load i32, ptr %id.addr, align 4
  %cmp2 = icmp eq i32 %5, %6
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %7 = load ptr, ptr %window.addr, align 8
  %ColumnsStorage3 = getelementptr inbounds %struct.ImGuiWindow, ptr %7, i32 0, i32 83
  %8 = load i32, ptr %n, align 4
  %call4 = call noundef nonnull align 8 dereferenceable(136) ptr @_ZN8ImVectorI15ImGuiOldColumnsEixEi(ptr noundef nonnull align 8 dereferenceable(16) %ColumnsStorage3, i32 noundef %8)
  store ptr %call4, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %9 = load i32, ptr %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, ptr %n, align 4
  br label %for.cond, !llvm.loop !69

for.end:                                          ; preds = %for.cond
  %10 = load ptr, ptr %window.addr, align 8
  %ColumnsStorage5 = getelementptr inbounds %struct.ImGuiWindow, ptr %10, i32 0, i32 83
  call void @_ZN15ImGuiOldColumnsC2Ev(ptr noundef nonnull align 8 dereferenceable(136) %ref.tmp)
  invoke void @_ZN8ImVectorI15ImGuiOldColumnsE9push_backERKS0_(ptr noundef nonnull align 8 dereferenceable(16) %ColumnsStorage5, ptr noundef nonnull align 8 dereferenceable(136) %ref.tmp)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %for.end
  call void @_ZN15ImGuiOldColumnsD2Ev(ptr noundef nonnull align 8 dereferenceable(136) %ref.tmp) #10
  %11 = load ptr, ptr %window.addr, align 8
  %ColumnsStorage6 = getelementptr inbounds %struct.ImGuiWindow, ptr %11, i32 0, i32 83
  %call7 = call noundef nonnull align 8 dereferenceable(136) ptr @_ZN8ImVectorI15ImGuiOldColumnsE4backEv(ptr noundef nonnull align 8 dereferenceable(16) %ColumnsStorage6)
  store ptr %call7, ptr %columns, align 8
  %12 = load i32, ptr %id.addr, align 4
  %13 = load ptr, ptr %columns, align 8
  %ID8 = getelementptr inbounds %struct.ImGuiOldColumns, ptr %13, i32 0, i32 0
  store i32 %12, ptr %ID8, align 8
  %14 = load ptr, ptr %columns, align 8
  store ptr %14, ptr %retval, align 8
  br label %return

lpad:                                             ; preds = %for.end
  %15 = landingpad { ptr, i32 }
          cleanup
  %16 = extractvalue { ptr, i32 } %15, 0
  store ptr %16, ptr %exn.slot, align 8
  %17 = extractvalue { ptr, i32 } %15, 1
  store i32 %17, ptr %ehselector.slot, align 4
  call void @_ZN15ImGuiOldColumnsD2Ev(ptr noundef nonnull align 8 dereferenceable(136) %ref.tmp) #10
  br label %eh.resume

return:                                           ; preds = %invoke.cont, %if.then
  %18 = load ptr, ptr %retval, align 8
  ret ptr %18

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val9 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val9
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef nonnull align 8 dereferenceable(136) ptr @_ZN8ImVectorI15ImGuiOldColumnsEixEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %i) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.31, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.ImGuiOldColumns, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI15ImGuiOldColumnsE9push_backERKS0_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(136) %v) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %v.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %v, ptr %v.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Size = getelementptr inbounds %struct.ImVector.31, ptr %this1, i32 0, i32 0
  %0 = load i32, ptr %Size, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.31, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp eq i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Size2 = getelementptr inbounds %struct.ImVector.31, ptr %this1, i32 0, i32 0
  %2 = load i32, ptr %Size2, align 8
  %add = add nsw i32 %2, 1
  %call = call noundef i32 @_ZNK8ImVectorI15ImGuiOldColumnsE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %add)
  call void @_ZN8ImVectorI15ImGuiOldColumnsE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %call)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %Data = getelementptr inbounds %struct.ImVector.31, ptr %this1, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %Size3 = getelementptr inbounds %struct.ImVector.31, ptr %this1, i32 0, i32 0
  %4 = load i32, ptr %Size3, align 8
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds %struct.ImGuiOldColumns, ptr %3, i64 %idxprom
  %5 = load ptr, ptr %v.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arrayidx, ptr align 8 %5, i64 136, i1 false)
  %Size4 = getelementptr inbounds %struct.ImVector.31, ptr %this1, i32 0, i32 0
  %6 = load i32, ptr %Size4, align 8
  %inc = add nsw i32 %6, 1
  store i32 %inc, ptr %Size4, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN15ImGuiOldColumnsC2Ev(ptr noundef nonnull align 8 dereferenceable(136) %this) unnamed_addr #0 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %HostInitialClipRect = getelementptr inbounds %struct.ImGuiOldColumns, ptr %this1, i32 0, i32 12
  call void @_ZN6ImRectC2Ev(ptr noundef nonnull align 4 dereferenceable(16) %HostInitialClipRect)
  %HostBackupClipRect = getelementptr inbounds %struct.ImGuiOldColumns, ptr %this1, i32 0, i32 13
  call void @_ZN6ImRectC2Ev(ptr noundef nonnull align 4 dereferenceable(16) %HostBackupClipRect)
  %HostBackupParentWorkRect = getelementptr inbounds %struct.ImGuiOldColumns, ptr %this1, i32 0, i32 14
  call void @_ZN6ImRectC2Ev(ptr noundef nonnull align 4 dereferenceable(16) %HostBackupParentWorkRect)
  %Columns = getelementptr inbounds %struct.ImGuiOldColumns, ptr %this1, i32 0, i32 15
  call void @_ZN8ImVectorI18ImGuiOldColumnDataEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %Columns)
  %Splitter = getelementptr inbounds %struct.ImGuiOldColumns, ptr %this1, i32 0, i32 16
  invoke void @_ZN18ImDrawListSplitterC2Ev(ptr noundef nonnull align 8 dereferenceable(24) %Splitter)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  call void @llvm.memset.p0.i64(ptr align 8 %this1, i8 0, i64 136, i1 false)
  ret void

lpad:                                             ; preds = %entry
  %0 = landingpad { ptr, i32 }
          cleanup
  %1 = extractvalue { ptr, i32 } %0, 0
  store ptr %1, ptr %exn.slot, align 8
  %2 = extractvalue { ptr, i32 } %0, 1
  store i32 %2, ptr %ehselector.slot, align 4
  call void @_ZN8ImVectorI18ImGuiOldColumnDataED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %Columns) #10
  br label %eh.resume

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val2 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val2
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN15ImGuiOldColumnsD2Ev(ptr noundef nonnull align 8 dereferenceable(136) %this) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Splitter = getelementptr inbounds %struct.ImGuiOldColumns, ptr %this1, i32 0, i32 16
  call void @_ZN18ImDrawListSplitterD2Ev(ptr noundef nonnull align 8 dereferenceable(24) %Splitter) #10
  %Columns = getelementptr inbounds %struct.ImGuiOldColumns, ptr %this1, i32 0, i32 15
  call void @_ZN8ImVectorI18ImGuiOldColumnDataED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %Columns) #10
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef nonnull align 8 dereferenceable(136) ptr @_ZN8ImVectorI15ImGuiOldColumnsE4backEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.31, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %Size = getelementptr inbounds %struct.ImVector.31, ptr %this1, i32 0, i32 0
  %1 = load i32, ptr %Size, align 8
  %sub = sub nsw i32 %1, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.ImGuiOldColumns, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress uwtable
define noundef i32 @_ZN5ImGui12GetColumnsIDEPKci(ptr noundef %str_id, i32 noundef %columns_count) #0 {
entry:
  %str_id.addr = alloca ptr, align 8
  %columns_count.addr = alloca i32, align 4
  %window = alloca ptr, align 8
  %id = alloca i32, align 4
  store ptr %str_id, ptr %str_id.addr, align 8
  store i32 %columns_count, ptr %columns_count.addr, align 4
  %call = call noundef ptr @_ZN5ImGui16GetCurrentWindowEv()
  store ptr %call, ptr %window, align 8
  %0 = load ptr, ptr %str_id.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %1 = load i32, ptr %columns_count.addr, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 0, %cond.true ], [ %1, %cond.false ]
  %add = add nsw i32 287454023, %cond
  call void @_ZN5ImGui6PushIDEi(i32 noundef %add)
  %2 = load ptr, ptr %window, align 8
  %3 = load ptr, ptr %str_id.addr, align 8
  %tobool1 = icmp ne ptr %3, null
  br i1 %tobool1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.end
  %4 = load ptr, ptr %str_id.addr, align 8
  br label %cond.end4

cond.false3:                                      ; preds = %cond.end
  br label %cond.end4

cond.end4:                                        ; preds = %cond.false3, %cond.true2
  %cond5 = phi ptr [ %4, %cond.true2 ], [ @.str.36, %cond.false3 ]
  %call6 = call noundef i32 @_ZN11ImGuiWindow5GetIDEPKcS1_(ptr noundef nonnull align 8 dereferenceable(1013) %2, ptr noundef %cond5, ptr noundef null)
  store i32 %call6, ptr %id, align 4
  call void @_ZN5ImGui5PopIDEv()
  %5 = load i32, ptr %id, align 4
  ret i32 %5
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui12BeginColumnsEPKcii(ptr noundef %str_id, i32 noundef %columns_count, i32 noundef %flags) #0 {
entry:
  %str_id.addr = alloca ptr, align 8
  %columns_count.addr = alloca i32, align 4
  %flags.addr = alloca i32, align 4
  %g = alloca ptr, align 8
  %window = alloca ptr, align 8
  %id = alloca i32, align 4
  %columns = alloca ptr, align 8
  %column_padding = alloca float, align 4
  %half_clip_extend_x = alloca float, align 4
  %max_1 = alloca float, align 4
  %max_2 = alloca float, align 4
  %n = alloca i32, align 4
  %column = alloca %struct.ImGuiOldColumnData, align 4
  %n57 = alloca i32, align 4
  %column61 = alloca ptr, align 8
  %clip_x1 = alloca float, align 4
  %clip_x2 = alloca float, align 4
  %ref.tmp = alloca %struct.ImRect, align 4
  %offset_0 = alloca float, align 4
  %offset_1 = alloca float, align 4
  %width = alloca float, align 4
  store ptr %str_id, ptr %str_id.addr, align 8
  store i32 %columns_count, ptr %columns_count.addr, align 4
  store i32 %flags, ptr %flags.addr, align 4
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %call = call noundef ptr @_ZN5ImGui16GetCurrentWindowEv()
  store ptr %call, ptr %window, align 8
  %1 = load ptr, ptr %str_id.addr, align 8
  %2 = load i32, ptr %columns_count.addr, align 4
  %call1 = call noundef i32 @_ZN5ImGui12GetColumnsIDEPKci(ptr noundef %1, i32 noundef %2)
  store i32 %call1, ptr %id, align 4
  %3 = load ptr, ptr %window, align 8
  %4 = load i32, ptr %id, align 4
  %call2 = call noundef ptr @_ZN5ImGui19FindOrCreateColumnsEP11ImGuiWindowj(ptr noundef %3, i32 noundef %4)
  store ptr %call2, ptr %columns, align 8
  %5 = load ptr, ptr %columns, align 8
  %Current = getelementptr inbounds %struct.ImGuiOldColumns, ptr %5, i32 0, i32 4
  store i32 0, ptr %Current, align 4
  %6 = load i32, ptr %columns_count.addr, align 4
  %7 = load ptr, ptr %columns, align 8
  %Count = getelementptr inbounds %struct.ImGuiOldColumns, ptr %7, i32 0, i32 5
  store i32 %6, ptr %Count, align 8
  %8 = load i32, ptr %flags.addr, align 4
  %9 = load ptr, ptr %columns, align 8
  %Flags = getelementptr inbounds %struct.ImGuiOldColumns, ptr %9, i32 0, i32 1
  store i32 %8, ptr %Flags, align 4
  %10 = load ptr, ptr %columns, align 8
  %11 = load ptr, ptr %window, align 8
  %DC = getelementptr inbounds %struct.ImGuiWindow, ptr %11, i32 0, i32 68
  %CurrentColumns = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC, i32 0, i32 28
  store ptr %10, ptr %CurrentColumns, align 8
  %12 = load ptr, ptr %window, align 8
  %DC3 = getelementptr inbounds %struct.ImGuiWindow, ptr %12, i32 0, i32 68
  %NavIsScrollPushableX = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC3, i32 0, i32 18
  store i8 0, ptr %NavIsScrollPushableX, align 8
  %13 = load ptr, ptr %window, align 8
  %DC4 = getelementptr inbounds %struct.ImGuiWindow, ptr %13, i32 0, i32 68
  %CursorPos = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC4, i32 0, i32 0
  %y = getelementptr inbounds %struct.ImVec2, ptr %CursorPos, i32 0, i32 1
  %14 = load float, ptr %y, align 4
  %15 = load ptr, ptr %columns, align 8
  %HostCursorPosY = getelementptr inbounds %struct.ImGuiOldColumns, ptr %15, i32 0, i32 10
  store float %14, ptr %HostCursorPosY, align 4
  %16 = load ptr, ptr %window, align 8
  %DC5 = getelementptr inbounds %struct.ImGuiWindow, ptr %16, i32 0, i32 68
  %CursorMaxPos = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC5, i32 0, i32 3
  %x = getelementptr inbounds %struct.ImVec2, ptr %CursorMaxPos, i32 0, i32 0
  %17 = load float, ptr %x, align 8
  %18 = load ptr, ptr %columns, align 8
  %HostCursorMaxPosX = getelementptr inbounds %struct.ImGuiOldColumns, ptr %18, i32 0, i32 11
  store float %17, ptr %HostCursorMaxPosX, align 8
  %19 = load ptr, ptr %window, align 8
  %ClipRect = getelementptr inbounds %struct.ImGuiWindow, ptr %19, i32 0, i32 74
  %20 = load ptr, ptr %columns, align 8
  %HostInitialClipRect = getelementptr inbounds %struct.ImGuiOldColumns, ptr %20, i32 0, i32 12
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %HostInitialClipRect, ptr align 8 %ClipRect, i64 16, i1 false)
  %21 = load ptr, ptr %window, align 8
  %ParentWorkRect = getelementptr inbounds %struct.ImGuiWindow, ptr %21, i32 0, i32 73
  %22 = load ptr, ptr %columns, align 8
  %HostBackupParentWorkRect = getelementptr inbounds %struct.ImGuiOldColumns, ptr %22, i32 0, i32 14
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %HostBackupParentWorkRect, ptr align 8 %ParentWorkRect, i64 16, i1 false)
  %23 = load ptr, ptr %window, align 8
  %WorkRect = getelementptr inbounds %struct.ImGuiWindow, ptr %23, i32 0, i32 72
  %24 = load ptr, ptr %window, align 8
  %ParentWorkRect6 = getelementptr inbounds %struct.ImGuiWindow, ptr %24, i32 0, i32 73
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %ParentWorkRect6, ptr align 8 %WorkRect, i64 16, i1 false)
  %25 = load ptr, ptr %g, align 8
  %Style = getelementptr inbounds %struct.ImGuiContext, ptr %25, i32 0, i32 3
  %ItemSpacing = getelementptr inbounds %struct.ImGuiStyle, ptr %Style, i32 0, i32 15
  %x7 = getelementptr inbounds %struct.ImVec2, ptr %ItemSpacing, i32 0, i32 0
  %26 = load float, ptr %x7, align 4
  store float %26, ptr %column_padding, align 4
  %27 = load ptr, ptr %window, align 8
  %WindowPadding = getelementptr inbounds %struct.ImGuiWindow, ptr %27, i32 0, i32 13
  %x8 = getelementptr inbounds %struct.ImVec2, ptr %WindowPadding, i32 0, i32 0
  %28 = load float, ptr %x8, align 8
  %mul = fmul float %28, 5.000000e-01
  %29 = load ptr, ptr %window, align 8
  %WindowBorderSize = getelementptr inbounds %struct.ImGuiWindow, ptr %29, i32 0, i32 15
  %30 = load float, ptr %WindowBorderSize, align 4
  %call9 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %mul, float noundef %30)
  %call10 = call noundef float @_ZL7ImTruncf(float noundef %call9)
  store float %call10, ptr %half_clip_extend_x, align 4
  %31 = load ptr, ptr %window, align 8
  %WorkRect11 = getelementptr inbounds %struct.ImGuiWindow, ptr %31, i32 0, i32 72
  %Max = getelementptr inbounds %struct.ImRect, ptr %WorkRect11, i32 0, i32 1
  %x12 = getelementptr inbounds %struct.ImVec2, ptr %Max, i32 0, i32 0
  %32 = load float, ptr %x12, align 8
  %33 = load float, ptr %column_padding, align 4
  %add = fadd float %32, %33
  %34 = load float, ptr %column_padding, align 4
  %35 = load ptr, ptr %window, align 8
  %WindowPadding13 = getelementptr inbounds %struct.ImGuiWindow, ptr %35, i32 0, i32 13
  %x14 = getelementptr inbounds %struct.ImVec2, ptr %WindowPadding13, i32 0, i32 0
  %36 = load float, ptr %x14, align 8
  %sub = fsub float %34, %36
  %call15 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %sub, float noundef 0.000000e+00)
  %sub16 = fsub float %add, %call15
  store float %sub16, ptr %max_1, align 4
  %37 = load ptr, ptr %window, align 8
  %WorkRect17 = getelementptr inbounds %struct.ImGuiWindow, ptr %37, i32 0, i32 72
  %Max18 = getelementptr inbounds %struct.ImRect, ptr %WorkRect17, i32 0, i32 1
  %x19 = getelementptr inbounds %struct.ImVec2, ptr %Max18, i32 0, i32 0
  %38 = load float, ptr %x19, align 8
  %39 = load float, ptr %half_clip_extend_x, align 4
  %add20 = fadd float %38, %39
  store float %add20, ptr %max_2, align 4
  %40 = load ptr, ptr %window, align 8
  %DC21 = getelementptr inbounds %struct.ImGuiWindow, ptr %40, i32 0, i32 68
  %Indent = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC21, i32 0, i32 11
  %x22 = getelementptr inbounds %struct.ImVec1, ptr %Indent, i32 0, i32 0
  %41 = load float, ptr %x22, align 4
  %42 = load float, ptr %column_padding, align 4
  %sub23 = fsub float %41, %42
  %43 = load float, ptr %column_padding, align 4
  %44 = load ptr, ptr %window, align 8
  %WindowPadding24 = getelementptr inbounds %struct.ImGuiWindow, ptr %44, i32 0, i32 13
  %x25 = getelementptr inbounds %struct.ImVec2, ptr %WindowPadding24, i32 0, i32 0
  %45 = load float, ptr %x25, align 8
  %sub26 = fsub float %43, %45
  %call27 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %sub26, float noundef 0.000000e+00)
  %add28 = fadd float %sub23, %call27
  %46 = load ptr, ptr %columns, align 8
  %OffMinX = getelementptr inbounds %struct.ImGuiOldColumns, ptr %46, i32 0, i32 6
  store float %add28, ptr %OffMinX, align 4
  %47 = load float, ptr %max_1, align 4
  %48 = load float, ptr %max_2, align 4
  %call29 = call noundef float @_ZL5ImMinIfET_S0_S0_(float noundef %47, float noundef %48)
  %49 = load ptr, ptr %window, align 8
  %Pos = getelementptr inbounds %struct.ImGuiWindow, ptr %49, i32 0, i32 7
  %x30 = getelementptr inbounds %struct.ImVec2, ptr %Pos, i32 0, i32 0
  %50 = load float, ptr %x30, align 8
  %sub31 = fsub float %call29, %50
  %51 = load ptr, ptr %columns, align 8
  %OffMinX32 = getelementptr inbounds %struct.ImGuiOldColumns, ptr %51, i32 0, i32 6
  %52 = load float, ptr %OffMinX32, align 4
  %add33 = fadd float %52, 1.000000e+00
  %call34 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %sub31, float noundef %add33)
  %53 = load ptr, ptr %columns, align 8
  %OffMaxX = getelementptr inbounds %struct.ImGuiOldColumns, ptr %53, i32 0, i32 7
  store float %call34, ptr %OffMaxX, align 8
  %54 = load ptr, ptr %window, align 8
  %DC35 = getelementptr inbounds %struct.ImGuiWindow, ptr %54, i32 0, i32 68
  %CursorPos36 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC35, i32 0, i32 0
  %y37 = getelementptr inbounds %struct.ImVec2, ptr %CursorPos36, i32 0, i32 1
  %55 = load float, ptr %y37, align 4
  %56 = load ptr, ptr %columns, align 8
  %LineMaxY = getelementptr inbounds %struct.ImGuiOldColumns, ptr %56, i32 0, i32 9
  store float %55, ptr %LineMaxY, align 8
  %57 = load ptr, ptr %columns, align 8
  %LineMinY = getelementptr inbounds %struct.ImGuiOldColumns, ptr %57, i32 0, i32 8
  store float %55, ptr %LineMinY, align 4
  %58 = load ptr, ptr %columns, align 8
  %Columns = getelementptr inbounds %struct.ImGuiOldColumns, ptr %58, i32 0, i32 15
  %Size = getelementptr inbounds %struct.ImVector.40, ptr %Columns, i32 0, i32 0
  %59 = load i32, ptr %Size, align 8
  %cmp = icmp ne i32 %59, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %60 = load ptr, ptr %columns, align 8
  %Columns38 = getelementptr inbounds %struct.ImGuiOldColumns, ptr %60, i32 0, i32 15
  %Size39 = getelementptr inbounds %struct.ImVector.40, ptr %Columns38, i32 0, i32 0
  %61 = load i32, ptr %Size39, align 8
  %62 = load i32, ptr %columns_count.addr, align 4
  %add40 = add nsw i32 %62, 1
  %cmp41 = icmp ne i32 %61, %add40
  br i1 %cmp41, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %63 = load ptr, ptr %columns, align 8
  %Columns42 = getelementptr inbounds %struct.ImGuiOldColumns, ptr %63, i32 0, i32 15
  call void @_ZN8ImVectorI18ImGuiOldColumnDataE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns42, i32 noundef 0)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %64 = load ptr, ptr %columns, align 8
  %Columns43 = getelementptr inbounds %struct.ImGuiOldColumns, ptr %64, i32 0, i32 15
  %Size44 = getelementptr inbounds %struct.ImVector.40, ptr %Columns43, i32 0, i32 0
  %65 = load i32, ptr %Size44, align 8
  %cmp45 = icmp eq i32 %65, 0
  %66 = load ptr, ptr %columns, align 8
  %IsFirstFrame = getelementptr inbounds %struct.ImGuiOldColumns, ptr %66, i32 0, i32 2
  %frombool = zext i1 %cmp45 to i8
  store i8 %frombool, ptr %IsFirstFrame, align 8
  %67 = load ptr, ptr %columns, align 8
  %Columns46 = getelementptr inbounds %struct.ImGuiOldColumns, ptr %67, i32 0, i32 15
  %Size47 = getelementptr inbounds %struct.ImVector.40, ptr %Columns46, i32 0, i32 0
  %68 = load i32, ptr %Size47, align 8
  %cmp48 = icmp eq i32 %68, 0
  br i1 %cmp48, label %if.then49, label %if.end56

if.then49:                                        ; preds = %if.end
  %69 = load ptr, ptr %columns, align 8
  %Columns50 = getelementptr inbounds %struct.ImGuiOldColumns, ptr %69, i32 0, i32 15
  %70 = load i32, ptr %columns_count.addr, align 4
  %add51 = add nsw i32 %70, 1
  call void @_ZN8ImVectorI18ImGuiOldColumnDataE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns50, i32 noundef %add51)
  store i32 0, ptr %n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then49
  %71 = load i32, ptr %n, align 4
  %72 = load i32, ptr %columns_count.addr, align 4
  %add52 = add nsw i32 %72, 1
  %cmp53 = icmp slt i32 %71, %add52
  br i1 %cmp53, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  call void @_ZN18ImGuiOldColumnDataC2Ev(ptr noundef nonnull align 4 dereferenceable(28) %column)
  %73 = load i32, ptr %n, align 4
  %conv = sitofp i32 %73 to float
  %74 = load i32, ptr %columns_count.addr, align 4
  %conv54 = sitofp i32 %74 to float
  %div = fdiv float %conv, %conv54
  %OffsetNorm = getelementptr inbounds %struct.ImGuiOldColumnData, ptr %column, i32 0, i32 0
  store float %div, ptr %OffsetNorm, align 4
  %75 = load ptr, ptr %columns, align 8
  %Columns55 = getelementptr inbounds %struct.ImGuiOldColumns, ptr %75, i32 0, i32 15
  call void @_ZN8ImVectorI18ImGuiOldColumnDataE9push_backERKS0_(ptr noundef nonnull align 8 dereferenceable(16) %Columns55, ptr noundef nonnull align 4 dereferenceable(28) %column)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %76 = load i32, ptr %n, align 4
  %inc = add nsw i32 %76, 1
  store i32 %inc, ptr %n, align 4
  br label %for.cond, !llvm.loop !70

for.end:                                          ; preds = %for.cond
  br label %if.end56

if.end56:                                         ; preds = %for.end, %if.end
  store i32 0, ptr %n57, align 4
  br label %for.cond58

for.cond58:                                       ; preds = %for.inc83, %if.end56
  %77 = load i32, ptr %n57, align 4
  %78 = load i32, ptr %columns_count.addr, align 4
  %cmp59 = icmp slt i32 %77, %78
  br i1 %cmp59, label %for.body60, label %for.end85

for.body60:                                       ; preds = %for.cond58
  %79 = load ptr, ptr %columns, align 8
  %Columns62 = getelementptr inbounds %struct.ImGuiOldColumns, ptr %79, i32 0, i32 15
  %80 = load i32, ptr %n57, align 4
  %call63 = call noundef nonnull align 4 dereferenceable(28) ptr @_ZN8ImVectorI18ImGuiOldColumnDataEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns62, i32 noundef %80)
  store ptr %call63, ptr %column61, align 8
  %81 = load ptr, ptr %window, align 8
  %Pos64 = getelementptr inbounds %struct.ImGuiWindow, ptr %81, i32 0, i32 7
  %x65 = getelementptr inbounds %struct.ImVec2, ptr %Pos64, i32 0, i32 0
  %82 = load float, ptr %x65, align 8
  %83 = load i32, ptr %n57, align 4
  %call66 = call noundef float @_ZN5ImGui15GetColumnOffsetEi(i32 noundef %83)
  %add67 = fadd float %82, %call66
  %add68 = fadd float %add67, 5.000000e-01
  %conv69 = fptosi float %add68 to i32
  %conv70 = sitofp i32 %conv69 to float
  store float %conv70, ptr %clip_x1, align 4
  %84 = load ptr, ptr %window, align 8
  %Pos71 = getelementptr inbounds %struct.ImGuiWindow, ptr %84, i32 0, i32 7
  %x72 = getelementptr inbounds %struct.ImVec2, ptr %Pos71, i32 0, i32 0
  %85 = load float, ptr %x72, align 8
  %86 = load i32, ptr %n57, align 4
  %add73 = add nsw i32 %86, 1
  %call74 = call noundef float @_ZN5ImGui15GetColumnOffsetEi(i32 noundef %add73)
  %add75 = fadd float %85, %call74
  %sub76 = fsub float %add75, 1.000000e+00
  %add77 = fadd float %sub76, 5.000000e-01
  %conv78 = fptosi float %add77 to i32
  %conv79 = sitofp i32 %conv78 to float
  store float %conv79, ptr %clip_x2, align 4
  %87 = load float, ptr %clip_x1, align 4
  %88 = load float, ptr %clip_x2, align 4
  call void @_ZN6ImRectC2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp, float noundef %87, float noundef 0xC7EFFFFFE0000000, float noundef %88, float noundef 0x47EFFFFFE0000000)
  %89 = load ptr, ptr %column61, align 8
  %ClipRect80 = getelementptr inbounds %struct.ImGuiOldColumnData, ptr %89, i32 0, i32 3
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %ClipRect80, ptr align 4 %ref.tmp, i64 16, i1 false)
  %90 = load ptr, ptr %column61, align 8
  %ClipRect81 = getelementptr inbounds %struct.ImGuiOldColumnData, ptr %90, i32 0, i32 3
  %91 = load ptr, ptr %window, align 8
  %ClipRect82 = getelementptr inbounds %struct.ImGuiWindow, ptr %91, i32 0, i32 74
  call void @_ZN6ImRect12ClipWithFullERKS_(ptr noundef nonnull align 4 dereferenceable(16) %ClipRect81, ptr noundef nonnull align 4 dereferenceable(16) %ClipRect82)
  br label %for.inc83

for.inc83:                                        ; preds = %for.body60
  %92 = load i32, ptr %n57, align 4
  %inc84 = add nsw i32 %92, 1
  store i32 %inc84, ptr %n57, align 4
  br label %for.cond58, !llvm.loop !71

for.end85:                                        ; preds = %for.cond58
  %93 = load ptr, ptr %columns, align 8
  %Count86 = getelementptr inbounds %struct.ImGuiOldColumns, ptr %93, i32 0, i32 5
  %94 = load i32, ptr %Count86, align 8
  %cmp87 = icmp sgt i32 %94, 1
  br i1 %cmp87, label %if.then88, label %if.end93

if.then88:                                        ; preds = %for.end85
  %95 = load ptr, ptr %columns, align 8
  %Splitter = getelementptr inbounds %struct.ImGuiOldColumns, ptr %95, i32 0, i32 16
  %96 = load ptr, ptr %window, align 8
  %DrawList = getelementptr inbounds %struct.ImGuiWindow, ptr %96, i32 0, i32 86
  %97 = load ptr, ptr %DrawList, align 8
  %98 = load ptr, ptr %columns, align 8
  %Count89 = getelementptr inbounds %struct.ImGuiOldColumns, ptr %98, i32 0, i32 5
  %99 = load i32, ptr %Count89, align 8
  %add90 = add nsw i32 1, %99
  call void @_ZN18ImDrawListSplitter5SplitEP10ImDrawListi(ptr noundef nonnull align 8 dereferenceable(24) %Splitter, ptr noundef %97, i32 noundef %add90)
  %100 = load ptr, ptr %columns, align 8
  %Splitter91 = getelementptr inbounds %struct.ImGuiOldColumns, ptr %100, i32 0, i32 16
  %101 = load ptr, ptr %window, align 8
  %DrawList92 = getelementptr inbounds %struct.ImGuiWindow, ptr %101, i32 0, i32 86
  %102 = load ptr, ptr %DrawList92, align 8
  call void @_ZN18ImDrawListSplitter17SetCurrentChannelEP10ImDrawListi(ptr noundef nonnull align 8 dereferenceable(24) %Splitter91, ptr noundef %102, i32 noundef 1)
  call void @_ZN5ImGui18PushColumnClipRectEi(i32 noundef 0)
  br label %if.end93

if.end93:                                         ; preds = %if.then88, %for.end85
  %103 = load ptr, ptr %columns, align 8
  %Current94 = getelementptr inbounds %struct.ImGuiOldColumns, ptr %103, i32 0, i32 4
  %104 = load i32, ptr %Current94, align 4
  %call95 = call noundef float @_ZN5ImGui15GetColumnOffsetEi(i32 noundef %104)
  store float %call95, ptr %offset_0, align 4
  %105 = load ptr, ptr %columns, align 8
  %Current96 = getelementptr inbounds %struct.ImGuiOldColumns, ptr %105, i32 0, i32 4
  %106 = load i32, ptr %Current96, align 4
  %add97 = add nsw i32 %106, 1
  %call98 = call noundef float @_ZN5ImGui15GetColumnOffsetEi(i32 noundef %add97)
  store float %call98, ptr %offset_1, align 4
  %107 = load float, ptr %offset_1, align 4
  %108 = load float, ptr %offset_0, align 4
  %sub99 = fsub float %107, %108
  store float %sub99, ptr %width, align 4
  %109 = load float, ptr %width, align 4
  %mul100 = fmul float %109, 0x3FE4CCCCC0000000
  call void @_ZN5ImGui13PushItemWidthEf(float noundef %mul100)
  %110 = load float, ptr %column_padding, align 4
  %111 = load ptr, ptr %window, align 8
  %WindowPadding101 = getelementptr inbounds %struct.ImGuiWindow, ptr %111, i32 0, i32 13
  %x102 = getelementptr inbounds %struct.ImVec2, ptr %WindowPadding101, i32 0, i32 0
  %112 = load float, ptr %x102, align 8
  %sub103 = fsub float %110, %112
  %call104 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %sub103, float noundef 0.000000e+00)
  %113 = load ptr, ptr %window, align 8
  %DC105 = getelementptr inbounds %struct.ImGuiWindow, ptr %113, i32 0, i32 68
  %ColumnsOffset = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC105, i32 0, i32 12
  %x106 = getelementptr inbounds %struct.ImVec1, ptr %ColumnsOffset, i32 0, i32 0
  store float %call104, ptr %x106, align 8
  %114 = load ptr, ptr %window, align 8
  %Pos107 = getelementptr inbounds %struct.ImGuiWindow, ptr %114, i32 0, i32 7
  %x108 = getelementptr inbounds %struct.ImVec2, ptr %Pos107, i32 0, i32 0
  %115 = load float, ptr %x108, align 8
  %116 = load ptr, ptr %window, align 8
  %DC109 = getelementptr inbounds %struct.ImGuiWindow, ptr %116, i32 0, i32 68
  %Indent110 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC109, i32 0, i32 11
  %x111 = getelementptr inbounds %struct.ImVec1, ptr %Indent110, i32 0, i32 0
  %117 = load float, ptr %x111, align 4
  %add112 = fadd float %115, %117
  %118 = load ptr, ptr %window, align 8
  %DC113 = getelementptr inbounds %struct.ImGuiWindow, ptr %118, i32 0, i32 68
  %ColumnsOffset114 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC113, i32 0, i32 12
  %x115 = getelementptr inbounds %struct.ImVec1, ptr %ColumnsOffset114, i32 0, i32 0
  %119 = load float, ptr %x115, align 8
  %add116 = fadd float %add112, %119
  %conv117 = fptosi float %add116 to i32
  %conv118 = sitofp i32 %conv117 to float
  %120 = load ptr, ptr %window, align 8
  %DC119 = getelementptr inbounds %struct.ImGuiWindow, ptr %120, i32 0, i32 68
  %CursorPos120 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC119, i32 0, i32 0
  %x121 = getelementptr inbounds %struct.ImVec2, ptr %CursorPos120, i32 0, i32 0
  store float %conv118, ptr %x121, align 8
  %121 = load ptr, ptr %window, align 8
  %Pos122 = getelementptr inbounds %struct.ImGuiWindow, ptr %121, i32 0, i32 7
  %x123 = getelementptr inbounds %struct.ImVec2, ptr %Pos122, i32 0, i32 0
  %122 = load float, ptr %x123, align 8
  %123 = load float, ptr %offset_1, align 4
  %add124 = fadd float %122, %123
  %124 = load float, ptr %column_padding, align 4
  %sub125 = fsub float %add124, %124
  %125 = load ptr, ptr %window, align 8
  %WorkRect126 = getelementptr inbounds %struct.ImGuiWindow, ptr %125, i32 0, i32 72
  %Max127 = getelementptr inbounds %struct.ImRect, ptr %WorkRect126, i32 0, i32 1
  %x128 = getelementptr inbounds %struct.ImVec2, ptr %Max127, i32 0, i32 0
  store float %sub125, ptr %x128, align 8
  %126 = load ptr, ptr %window, align 8
  %ContentRegionRect = getelementptr inbounds %struct.ImGuiWindow, ptr %126, i32 0, i32 75
  %Max129 = getelementptr inbounds %struct.ImRect, ptr %ContentRegionRect, i32 0, i32 1
  %y130 = getelementptr inbounds %struct.ImVec2, ptr %Max129, i32 0, i32 1
  %127 = load float, ptr %y130, align 4
  %128 = load ptr, ptr %window, align 8
  %WorkRect131 = getelementptr inbounds %struct.ImGuiWindow, ptr %128, i32 0, i32 72
  %Max132 = getelementptr inbounds %struct.ImRect, ptr %WorkRect131, i32 0, i32 1
  %y133 = getelementptr inbounds %struct.ImVec2, ptr %Max132, i32 0, i32 1
  store float %127, ptr %y133, align 4
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI18ImGuiOldColumnDataE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_size) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_size.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_size, ptr %new_size.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_size.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.40, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sgt i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %new_size.addr, align 4
  %call = call noundef i32 @_ZNK8ImVectorI18ImGuiOldColumnDataE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %2)
  call void @_ZN8ImVectorI18ImGuiOldColumnDataE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %call)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32, ptr %new_size.addr, align 4
  %Size = getelementptr inbounds %struct.ImVector.40, ptr %this1, i32 0, i32 0
  store i32 %3, ptr %Size, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI18ImGuiOldColumnDataE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_capacity) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_capacity.addr = alloca i32, align 4
  %new_data = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_capacity, ptr %new_capacity.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_capacity.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.40, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sle i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %new_capacity.addr, align 4
  %conv = sext i32 %2 to i64
  %mul = mul i64 %conv, 28
  %call = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef %mul)
  store ptr %call, ptr %new_data, align 8
  %Data = getelementptr inbounds %struct.ImVector.40, ptr %this1, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.then2, label %if.end7

if.then2:                                         ; preds = %if.end
  %4 = load ptr, ptr %new_data, align 8
  %Data3 = getelementptr inbounds %struct.ImVector.40, ptr %this1, i32 0, i32 2
  %5 = load ptr, ptr %Data3, align 8
  %Size = getelementptr inbounds %struct.ImVector.40, ptr %this1, i32 0, i32 0
  %6 = load i32, ptr %Size, align 8
  %conv4 = sext i32 %6 to i64
  %mul5 = mul i64 %conv4, 28
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %4, ptr align 4 %5, i64 %mul5, i1 false)
  %Data6 = getelementptr inbounds %struct.ImVector.40, ptr %this1, i32 0, i32 2
  %7 = load ptr, ptr %Data6, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %7)
  br label %if.end7

if.end7:                                          ; preds = %if.then2, %if.end
  %8 = load ptr, ptr %new_data, align 8
  %Data8 = getelementptr inbounds %struct.ImVector.40, ptr %this1, i32 0, i32 2
  store ptr %8, ptr %Data8, align 8
  %9 = load i32, ptr %new_capacity.addr, align 4
  %Capacity9 = getelementptr inbounds %struct.ImVector.40, ptr %this1, i32 0, i32 1
  store i32 %9, ptr %Capacity9, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN18ImGuiOldColumnDataC2Ev(ptr noundef nonnull align 4 dereferenceable(28) %this) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %ClipRect = getelementptr inbounds %struct.ImGuiOldColumnData, ptr %this1, i32 0, i32 3
  call void @_ZN6ImRectC2Ev(ptr noundef nonnull align 4 dereferenceable(16) %ClipRect)
  call void @llvm.memset.p0.i64(ptr align 4 %this1, i8 0, i64 28, i1 false)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI18ImGuiOldColumnDataE9push_backERKS0_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 4 dereferenceable(28) %v) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %v.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %v, ptr %v.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Size = getelementptr inbounds %struct.ImVector.40, ptr %this1, i32 0, i32 0
  %0 = load i32, ptr %Size, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.40, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp eq i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Size2 = getelementptr inbounds %struct.ImVector.40, ptr %this1, i32 0, i32 0
  %2 = load i32, ptr %Size2, align 8
  %add = add nsw i32 %2, 1
  %call = call noundef i32 @_ZNK8ImVectorI18ImGuiOldColumnDataE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %add)
  call void @_ZN8ImVectorI18ImGuiOldColumnDataE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %call)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %Data = getelementptr inbounds %struct.ImVector.40, ptr %this1, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %Size3 = getelementptr inbounds %struct.ImVector.40, ptr %this1, i32 0, i32 0
  %4 = load i32, ptr %Size3, align 8
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds %struct.ImGuiOldColumnData, ptr %3, i64 %idxprom
  %5 = load ptr, ptr %v.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx, ptr align 4 %5, i64 28, i1 false)
  %Size4 = getelementptr inbounds %struct.ImVector.40, ptr %this1, i32 0, i32 0
  %6 = load i32, ptr %Size4, align 8
  %inc = add nsw i32 %6, 1
  store i32 %inc, ptr %Size4, align 8
  ret void
}

declare void @_ZN5ImGui13PushItemWidthEf(float noundef) #1

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui10NextColumnEv() #0 {
entry:
  %window = alloca ptr, align 8
  %g = alloca ptr, align 8
  %columns = alloca ptr, align 8
  %column = alloca ptr, align 8
  %column_padding = alloca float, align 4
  %ref.tmp = alloca %struct.ImVec2, align 4
  %offset_0 = alloca float, align 4
  %offset_1 = alloca float, align 4
  %width = alloca float, align 4
  %call = call noundef ptr @_ZN5ImGui16GetCurrentWindowEv()
  store ptr %call, ptr %window, align 8
  %0 = load ptr, ptr %window, align 8
  %SkipItems = getelementptr inbounds %struct.ImGuiWindow, ptr %0, i32 0, i32 38
  %1 = load i8, ptr %SkipItems, align 1
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load ptr, ptr %window, align 8
  %DC = getelementptr inbounds %struct.ImGuiWindow, ptr %2, i32 0, i32 68
  %CurrentColumns = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC, i32 0, i32 28
  %3 = load ptr, ptr %CurrentColumns, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %4 = load ptr, ptr @GImGui, align 8
  store ptr %4, ptr %g, align 8
  %5 = load ptr, ptr %window, align 8
  %DC1 = getelementptr inbounds %struct.ImGuiWindow, ptr %5, i32 0, i32 68
  %CurrentColumns2 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC1, i32 0, i32 28
  %6 = load ptr, ptr %CurrentColumns2, align 8
  store ptr %6, ptr %columns, align 8
  %7 = load ptr, ptr %columns, align 8
  %Count = getelementptr inbounds %struct.ImGuiOldColumns, ptr %7, i32 0, i32 5
  %8 = load i32, ptr %Count, align 8
  %cmp3 = icmp eq i32 %8, 1
  br i1 %cmp3, label %if.then4, label %if.end13

if.then4:                                         ; preds = %if.end
  %9 = load ptr, ptr %window, align 8
  %Pos = getelementptr inbounds %struct.ImGuiWindow, ptr %9, i32 0, i32 7
  %x = getelementptr inbounds %struct.ImVec2, ptr %Pos, i32 0, i32 0
  %10 = load float, ptr %x, align 8
  %11 = load ptr, ptr %window, align 8
  %DC5 = getelementptr inbounds %struct.ImGuiWindow, ptr %11, i32 0, i32 68
  %Indent = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC5, i32 0, i32 11
  %x6 = getelementptr inbounds %struct.ImVec1, ptr %Indent, i32 0, i32 0
  %12 = load float, ptr %x6, align 4
  %add = fadd float %10, %12
  %13 = load ptr, ptr %window, align 8
  %DC7 = getelementptr inbounds %struct.ImGuiWindow, ptr %13, i32 0, i32 68
  %ColumnsOffset = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC7, i32 0, i32 12
  %x8 = getelementptr inbounds %struct.ImVec1, ptr %ColumnsOffset, i32 0, i32 0
  %14 = load float, ptr %x8, align 8
  %add9 = fadd float %add, %14
  %conv = fptosi float %add9 to i32
  %conv10 = sitofp i32 %conv to float
  %15 = load ptr, ptr %window, align 8
  %DC11 = getelementptr inbounds %struct.ImGuiWindow, ptr %15, i32 0, i32 68
  %CursorPos = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC11, i32 0, i32 0
  %x12 = getelementptr inbounds %struct.ImVec2, ptr %CursorPos, i32 0, i32 0
  store float %conv10, ptr %x12, align 8
  br label %return

if.end13:                                         ; preds = %if.end
  %16 = load ptr, ptr %columns, align 8
  %Current = getelementptr inbounds %struct.ImGuiOldColumns, ptr %16, i32 0, i32 4
  %17 = load i32, ptr %Current, align 4
  %inc = add nsw i32 %17, 1
  store i32 %inc, ptr %Current, align 4
  %18 = load ptr, ptr %columns, align 8
  %Count14 = getelementptr inbounds %struct.ImGuiOldColumns, ptr %18, i32 0, i32 5
  %19 = load i32, ptr %Count14, align 8
  %cmp15 = icmp eq i32 %inc, %19
  br i1 %cmp15, label %if.then16, label %if.end18

if.then16:                                        ; preds = %if.end13
  %20 = load ptr, ptr %columns, align 8
  %Current17 = getelementptr inbounds %struct.ImGuiOldColumns, ptr %20, i32 0, i32 4
  store i32 0, ptr %Current17, align 4
  br label %if.end18

if.end18:                                         ; preds = %if.then16, %if.end13
  call void @_ZN5ImGui12PopItemWidthEv()
  %21 = load ptr, ptr %columns, align 8
  %Columns = getelementptr inbounds %struct.ImGuiOldColumns, ptr %21, i32 0, i32 15
  %22 = load ptr, ptr %columns, align 8
  %Current19 = getelementptr inbounds %struct.ImGuiOldColumns, ptr %22, i32 0, i32 4
  %23 = load i32, ptr %Current19, align 4
  %call20 = call noundef nonnull align 4 dereferenceable(28) ptr @_ZN8ImVectorI18ImGuiOldColumnDataEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns, i32 noundef %23)
  store ptr %call20, ptr %column, align 8
  %24 = load ptr, ptr %window, align 8
  %25 = load ptr, ptr %column, align 8
  %ClipRect = getelementptr inbounds %struct.ImGuiOldColumnData, ptr %25, i32 0, i32 3
  call void @_ZN5ImGui33SetWindowClipRectBeforeSetChannelEP11ImGuiWindowRK6ImRect(ptr noundef %24, ptr noundef nonnull align 4 dereferenceable(16) %ClipRect)
  %26 = load ptr, ptr %columns, align 8
  %Splitter = getelementptr inbounds %struct.ImGuiOldColumns, ptr %26, i32 0, i32 16
  %27 = load ptr, ptr %window, align 8
  %DrawList = getelementptr inbounds %struct.ImGuiWindow, ptr %27, i32 0, i32 86
  %28 = load ptr, ptr %DrawList, align 8
  %29 = load ptr, ptr %columns, align 8
  %Current21 = getelementptr inbounds %struct.ImGuiOldColumns, ptr %29, i32 0, i32 4
  %30 = load i32, ptr %Current21, align 4
  %add22 = add nsw i32 %30, 1
  call void @_ZN18ImDrawListSplitter17SetCurrentChannelEP10ImDrawListi(ptr noundef nonnull align 8 dereferenceable(24) %Splitter, ptr noundef %28, i32 noundef %add22)
  %31 = load ptr, ptr %g, align 8
  %Style = getelementptr inbounds %struct.ImGuiContext, ptr %31, i32 0, i32 3
  %ItemSpacing = getelementptr inbounds %struct.ImGuiStyle, ptr %Style, i32 0, i32 15
  %x23 = getelementptr inbounds %struct.ImVec2, ptr %ItemSpacing, i32 0, i32 0
  %32 = load float, ptr %x23, align 4
  store float %32, ptr %column_padding, align 4
  %33 = load ptr, ptr %columns, align 8
  %LineMaxY = getelementptr inbounds %struct.ImGuiOldColumns, ptr %33, i32 0, i32 9
  %34 = load float, ptr %LineMaxY, align 8
  %35 = load ptr, ptr %window, align 8
  %DC24 = getelementptr inbounds %struct.ImGuiWindow, ptr %35, i32 0, i32 68
  %CursorPos25 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC24, i32 0, i32 0
  %y = getelementptr inbounds %struct.ImVec2, ptr %CursorPos25, i32 0, i32 1
  %36 = load float, ptr %y, align 4
  %call26 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %34, float noundef %36)
  %37 = load ptr, ptr %columns, align 8
  %LineMaxY27 = getelementptr inbounds %struct.ImGuiOldColumns, ptr %37, i32 0, i32 9
  store float %call26, ptr %LineMaxY27, align 8
  %38 = load ptr, ptr %columns, align 8
  %Current28 = getelementptr inbounds %struct.ImGuiOldColumns, ptr %38, i32 0, i32 4
  %39 = load i32, ptr %Current28, align 4
  %cmp29 = icmp sgt i32 %39, 0
  br i1 %cmp29, label %if.then30, label %if.else

if.then30:                                        ; preds = %if.end18
  %40 = load ptr, ptr %columns, align 8
  %Current31 = getelementptr inbounds %struct.ImGuiOldColumns, ptr %40, i32 0, i32 4
  %41 = load i32, ptr %Current31, align 4
  %call32 = call noundef float @_ZN5ImGui15GetColumnOffsetEi(i32 noundef %41)
  %42 = load ptr, ptr %window, align 8
  %DC33 = getelementptr inbounds %struct.ImGuiWindow, ptr %42, i32 0, i32 68
  %Indent34 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC33, i32 0, i32 11
  %x35 = getelementptr inbounds %struct.ImVec1, ptr %Indent34, i32 0, i32 0
  %43 = load float, ptr %x35, align 4
  %sub = fsub float %call32, %43
  %44 = load float, ptr %column_padding, align 4
  %add36 = fadd float %sub, %44
  %45 = load ptr, ptr %window, align 8
  %DC37 = getelementptr inbounds %struct.ImGuiWindow, ptr %45, i32 0, i32 68
  %ColumnsOffset38 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC37, i32 0, i32 12
  %x39 = getelementptr inbounds %struct.ImVec1, ptr %ColumnsOffset38, i32 0, i32 0
  store float %add36, ptr %x39, align 8
  br label %if.end48

if.else:                                          ; preds = %if.end18
  %46 = load float, ptr %column_padding, align 4
  %47 = load ptr, ptr %window, align 8
  %WindowPadding = getelementptr inbounds %struct.ImGuiWindow, ptr %47, i32 0, i32 13
  %x40 = getelementptr inbounds %struct.ImVec2, ptr %WindowPadding, i32 0, i32 0
  %48 = load float, ptr %x40, align 8
  %sub41 = fsub float %46, %48
  %call42 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %sub41, float noundef 0.000000e+00)
  %49 = load ptr, ptr %window, align 8
  %DC43 = getelementptr inbounds %struct.ImGuiWindow, ptr %49, i32 0, i32 68
  %ColumnsOffset44 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC43, i32 0, i32 12
  %x45 = getelementptr inbounds %struct.ImVec1, ptr %ColumnsOffset44, i32 0, i32 0
  store float %call42, ptr %x45, align 8
  %50 = load ptr, ptr %window, align 8
  %DC46 = getelementptr inbounds %struct.ImGuiWindow, ptr %50, i32 0, i32 68
  %IsSameLine = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC46, i32 0, i32 9
  store i8 0, ptr %IsSameLine, align 8
  %51 = load ptr, ptr %columns, align 8
  %LineMaxY47 = getelementptr inbounds %struct.ImGuiOldColumns, ptr %51, i32 0, i32 9
  %52 = load float, ptr %LineMaxY47, align 8
  %53 = load ptr, ptr %columns, align 8
  %LineMinY = getelementptr inbounds %struct.ImGuiOldColumns, ptr %53, i32 0, i32 8
  store float %52, ptr %LineMinY, align 4
  br label %if.end48

if.end48:                                         ; preds = %if.else, %if.then30
  %54 = load ptr, ptr %window, align 8
  %Pos49 = getelementptr inbounds %struct.ImGuiWindow, ptr %54, i32 0, i32 7
  %x50 = getelementptr inbounds %struct.ImVec2, ptr %Pos49, i32 0, i32 0
  %55 = load float, ptr %x50, align 8
  %56 = load ptr, ptr %window, align 8
  %DC51 = getelementptr inbounds %struct.ImGuiWindow, ptr %56, i32 0, i32 68
  %Indent52 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC51, i32 0, i32 11
  %x53 = getelementptr inbounds %struct.ImVec1, ptr %Indent52, i32 0, i32 0
  %57 = load float, ptr %x53, align 4
  %add54 = fadd float %55, %57
  %58 = load ptr, ptr %window, align 8
  %DC55 = getelementptr inbounds %struct.ImGuiWindow, ptr %58, i32 0, i32 68
  %ColumnsOffset56 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC55, i32 0, i32 12
  %x57 = getelementptr inbounds %struct.ImVec1, ptr %ColumnsOffset56, i32 0, i32 0
  %59 = load float, ptr %x57, align 8
  %add58 = fadd float %add54, %59
  %conv59 = fptosi float %add58 to i32
  %conv60 = sitofp i32 %conv59 to float
  %60 = load ptr, ptr %window, align 8
  %DC61 = getelementptr inbounds %struct.ImGuiWindow, ptr %60, i32 0, i32 68
  %CursorPos62 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC61, i32 0, i32 0
  %x63 = getelementptr inbounds %struct.ImVec2, ptr %CursorPos62, i32 0, i32 0
  store float %conv60, ptr %x63, align 8
  %61 = load ptr, ptr %columns, align 8
  %LineMinY64 = getelementptr inbounds %struct.ImGuiOldColumns, ptr %61, i32 0, i32 8
  %62 = load float, ptr %LineMinY64, align 4
  %63 = load ptr, ptr %window, align 8
  %DC65 = getelementptr inbounds %struct.ImGuiWindow, ptr %63, i32 0, i32 68
  %CursorPos66 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC65, i32 0, i32 0
  %y67 = getelementptr inbounds %struct.ImVec2, ptr %CursorPos66, i32 0, i32 1
  store float %62, ptr %y67, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp, float noundef 0.000000e+00, float noundef 0.000000e+00)
  %64 = load ptr, ptr %window, align 8
  %DC68 = getelementptr inbounds %struct.ImGuiWindow, ptr %64, i32 0, i32 68
  %CurrLineSize = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC68, i32 0, i32 5
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %CurrLineSize, ptr align 4 %ref.tmp, i64 8, i1 false)
  %65 = load ptr, ptr %window, align 8
  %DC69 = getelementptr inbounds %struct.ImGuiWindow, ptr %65, i32 0, i32 68
  %CurrLineTextBaseOffset = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC69, i32 0, i32 7
  store float 0.000000e+00, ptr %CurrLineTextBaseOffset, align 8
  %66 = load ptr, ptr %columns, align 8
  %Current70 = getelementptr inbounds %struct.ImGuiOldColumns, ptr %66, i32 0, i32 4
  %67 = load i32, ptr %Current70, align 4
  %call71 = call noundef float @_ZN5ImGui15GetColumnOffsetEi(i32 noundef %67)
  store float %call71, ptr %offset_0, align 4
  %68 = load ptr, ptr %columns, align 8
  %Current72 = getelementptr inbounds %struct.ImGuiOldColumns, ptr %68, i32 0, i32 4
  %69 = load i32, ptr %Current72, align 4
  %add73 = add nsw i32 %69, 1
  %call74 = call noundef float @_ZN5ImGui15GetColumnOffsetEi(i32 noundef %add73)
  store float %call74, ptr %offset_1, align 4
  %70 = load float, ptr %offset_1, align 4
  %71 = load float, ptr %offset_0, align 4
  %sub75 = fsub float %70, %71
  store float %sub75, ptr %width, align 4
  %72 = load float, ptr %width, align 4
  %mul = fmul float %72, 0x3FE4CCCCC0000000
  call void @_ZN5ImGui13PushItemWidthEf(float noundef %mul)
  %73 = load ptr, ptr %window, align 8
  %Pos76 = getelementptr inbounds %struct.ImGuiWindow, ptr %73, i32 0, i32 7
  %x77 = getelementptr inbounds %struct.ImVec2, ptr %Pos76, i32 0, i32 0
  %74 = load float, ptr %x77, align 8
  %75 = load float, ptr %offset_1, align 4
  %add78 = fadd float %74, %75
  %76 = load float, ptr %column_padding, align 4
  %sub79 = fsub float %add78, %76
  %77 = load ptr, ptr %window, align 8
  %WorkRect = getelementptr inbounds %struct.ImGuiWindow, ptr %77, i32 0, i32 72
  %Max = getelementptr inbounds %struct.ImRect, ptr %WorkRect, i32 0, i32 1
  %x80 = getelementptr inbounds %struct.ImVec2, ptr %Max, i32 0, i32 0
  store float %sub79, ptr %x80, align 8
  br label %return

return:                                           ; preds = %if.end48, %if.then4, %if.then
  ret void
}

declare void @_ZN5ImGui12PopItemWidthEv() #1

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui10EndColumnsEv() #0 {
entry:
  %g = alloca ptr, align 8
  %window = alloca ptr, align 8
  %columns = alloca ptr, align 8
  %flags = alloca i32, align 4
  %is_being_resized = alloca i8, align 1
  %y1 = alloca float, align 4
  %y2 = alloca float, align 4
  %dragging_column = alloca i32, align 4
  %n = alloca i32, align 4
  %column = alloca ptr, align 8
  %x26 = alloca float, align 4
  %column_id = alloca i32, align 4
  %column_hit_hw = alloca float, align 4
  %column_hit_rect = alloca %struct.ImRect, align 4
  %ref.tmp = alloca %struct.ImVec2, align 4
  %ref.tmp30 = alloca %struct.ImVec2, align 4
  %hovered = alloca i8, align 1
  %held = alloca i8, align 1
  %col = alloca i32, align 4
  %xi = alloca float, align 4
  %ref.tmp57 = alloca %struct.ImVec2, align 4
  %ref.tmp59 = alloca %struct.ImVec2, align 4
  %n64 = alloca i32, align 4
  %x79 = alloca float, align 4
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %call = call noundef ptr @_ZN5ImGui16GetCurrentWindowEv()
  store ptr %call, ptr %window, align 8
  %1 = load ptr, ptr %window, align 8
  %DC = getelementptr inbounds %struct.ImGuiWindow, ptr %1, i32 0, i32 68
  %CurrentColumns = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC, i32 0, i32 28
  %2 = load ptr, ptr %CurrentColumns, align 8
  store ptr %2, ptr %columns, align 8
  call void @_ZN5ImGui12PopItemWidthEv()
  %3 = load ptr, ptr %columns, align 8
  %Count = getelementptr inbounds %struct.ImGuiOldColumns, ptr %3, i32 0, i32 5
  %4 = load i32, ptr %Count, align 8
  %cmp = icmp sgt i32 %4, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @_ZN5ImGui11PopClipRectEv()
  %5 = load ptr, ptr %columns, align 8
  %Splitter = getelementptr inbounds %struct.ImGuiOldColumns, ptr %5, i32 0, i32 16
  %6 = load ptr, ptr %window, align 8
  %DrawList = getelementptr inbounds %struct.ImGuiWindow, ptr %6, i32 0, i32 86
  %7 = load ptr, ptr %DrawList, align 8
  call void @_ZN18ImDrawListSplitter5MergeEP10ImDrawList(ptr noundef nonnull align 8 dereferenceable(24) %Splitter, ptr noundef %7)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %8 = load ptr, ptr %columns, align 8
  %Flags = getelementptr inbounds %struct.ImGuiOldColumns, ptr %8, i32 0, i32 1
  %9 = load i32, ptr %Flags, align 4
  store i32 %9, ptr %flags, align 4
  %10 = load ptr, ptr %columns, align 8
  %LineMaxY = getelementptr inbounds %struct.ImGuiOldColumns, ptr %10, i32 0, i32 9
  %11 = load float, ptr %LineMaxY, align 8
  %12 = load ptr, ptr %window, align 8
  %DC1 = getelementptr inbounds %struct.ImGuiWindow, ptr %12, i32 0, i32 68
  %CursorPos = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC1, i32 0, i32 0
  %y = getelementptr inbounds %struct.ImVec2, ptr %CursorPos, i32 0, i32 1
  %13 = load float, ptr %y, align 4
  %call2 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %11, float noundef %13)
  %14 = load ptr, ptr %columns, align 8
  %LineMaxY3 = getelementptr inbounds %struct.ImGuiOldColumns, ptr %14, i32 0, i32 9
  store float %call2, ptr %LineMaxY3, align 8
  %15 = load ptr, ptr %columns, align 8
  %LineMaxY4 = getelementptr inbounds %struct.ImGuiOldColumns, ptr %15, i32 0, i32 9
  %16 = load float, ptr %LineMaxY4, align 8
  %17 = load ptr, ptr %window, align 8
  %DC5 = getelementptr inbounds %struct.ImGuiWindow, ptr %17, i32 0, i32 68
  %CursorPos6 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC5, i32 0, i32 0
  %y7 = getelementptr inbounds %struct.ImVec2, ptr %CursorPos6, i32 0, i32 1
  store float %16, ptr %y7, align 4
  %18 = load i32, ptr %flags, align 4
  %and = and i32 %18, 16
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end10, label %if.then8

if.then8:                                         ; preds = %if.end
  %19 = load ptr, ptr %columns, align 8
  %HostCursorMaxPosX = getelementptr inbounds %struct.ImGuiOldColumns, ptr %19, i32 0, i32 11
  %20 = load float, ptr %HostCursorMaxPosX, align 8
  %21 = load ptr, ptr %window, align 8
  %DC9 = getelementptr inbounds %struct.ImGuiWindow, ptr %21, i32 0, i32 68
  %CursorMaxPos = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC9, i32 0, i32 3
  %x = getelementptr inbounds %struct.ImVec2, ptr %CursorMaxPos, i32 0, i32 0
  store float %20, ptr %x, align 8
  br label %if.end10

if.end10:                                         ; preds = %if.then8, %if.end
  store i8 0, ptr %is_being_resized, align 1
  %22 = load i32, ptr %flags, align 4
  %and11 = and i32 %22, 1
  %tobool12 = icmp ne i32 %and11, 0
  br i1 %tobool12, label %if.end82, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end10
  %23 = load ptr, ptr %window, align 8
  %SkipItems = getelementptr inbounds %struct.ImGuiWindow, ptr %23, i32 0, i32 38
  %24 = load i8, ptr %SkipItems, align 1
  %tobool13 = trunc i8 %24 to i1
  br i1 %tobool13, label %if.end82, label %if.then14

if.then14:                                        ; preds = %land.lhs.true
  %25 = load ptr, ptr %columns, align 8
  %HostCursorPosY = getelementptr inbounds %struct.ImGuiOldColumns, ptr %25, i32 0, i32 10
  %26 = load float, ptr %HostCursorPosY, align 4
  %27 = load ptr, ptr %window, align 8
  %ClipRect = getelementptr inbounds %struct.ImGuiWindow, ptr %27, i32 0, i32 74
  %Min = getelementptr inbounds %struct.ImRect, ptr %ClipRect, i32 0, i32 0
  %y15 = getelementptr inbounds %struct.ImVec2, ptr %Min, i32 0, i32 1
  %28 = load float, ptr %y15, align 4
  %call16 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %26, float noundef %28)
  store float %call16, ptr %y1, align 4
  %29 = load ptr, ptr %window, align 8
  %DC17 = getelementptr inbounds %struct.ImGuiWindow, ptr %29, i32 0, i32 68
  %CursorPos18 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC17, i32 0, i32 0
  %y19 = getelementptr inbounds %struct.ImVec2, ptr %CursorPos18, i32 0, i32 1
  %30 = load float, ptr %y19, align 4
  %31 = load ptr, ptr %window, align 8
  %ClipRect20 = getelementptr inbounds %struct.ImGuiWindow, ptr %31, i32 0, i32 74
  %Max = getelementptr inbounds %struct.ImRect, ptr %ClipRect20, i32 0, i32 1
  %y21 = getelementptr inbounds %struct.ImVec2, ptr %Max, i32 0, i32 1
  %32 = load float, ptr %y21, align 4
  %call22 = call noundef float @_ZL5ImMinIfET_S0_S0_(float noundef %30, float noundef %32)
  store float %call22, ptr %y2, align 4
  store i32 -1, ptr %dragging_column, align 4
  store i32 1, ptr %n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then14
  %33 = load i32, ptr %n, align 4
  %34 = load ptr, ptr %columns, align 8
  %Count23 = getelementptr inbounds %struct.ImGuiOldColumns, ptr %34, i32 0, i32 5
  %35 = load i32, ptr %Count23, align 8
  %cmp24 = icmp slt i32 %33, %35
  br i1 %cmp24, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %36 = load ptr, ptr %columns, align 8
  %Columns = getelementptr inbounds %struct.ImGuiOldColumns, ptr %36, i32 0, i32 15
  %37 = load i32, ptr %n, align 4
  %call25 = call noundef nonnull align 4 dereferenceable(28) ptr @_ZN8ImVectorI18ImGuiOldColumnDataEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns, i32 noundef %37)
  store ptr %call25, ptr %column, align 8
  %38 = load ptr, ptr %window, align 8
  %Pos = getelementptr inbounds %struct.ImGuiWindow, ptr %38, i32 0, i32 7
  %x27 = getelementptr inbounds %struct.ImVec2, ptr %Pos, i32 0, i32 0
  %39 = load float, ptr %x27, align 8
  %40 = load i32, ptr %n, align 4
  %call28 = call noundef float @_ZN5ImGui15GetColumnOffsetEi(i32 noundef %40)
  %add = fadd float %39, %call28
  store float %add, ptr %x26, align 4
  %41 = load ptr, ptr %columns, align 8
  %ID = getelementptr inbounds %struct.ImGuiOldColumns, ptr %41, i32 0, i32 0
  %42 = load i32, ptr %ID, align 8
  %43 = load i32, ptr %n, align 4
  %add29 = add i32 %42, %43
  store i32 %add29, ptr %column_id, align 4
  store float 4.000000e+00, ptr %column_hit_hw, align 4
  %44 = load float, ptr %x26, align 4
  %sub = fsub float %44, 4.000000e+00
  %45 = load float, ptr %y1, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp, float noundef %sub, float noundef %45)
  %46 = load float, ptr %x26, align 4
  %add31 = fadd float %46, 4.000000e+00
  %47 = load float, ptr %y2, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp30, float noundef %add31, float noundef %47)
  call void @_ZN6ImRectC2ERK6ImVec2S2_(ptr noundef nonnull align 4 dereferenceable(16) %column_hit_rect, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp30)
  %48 = load i32, ptr %column_id, align 4
  %call32 = call noundef zeroext i1 @_ZN5ImGui7ItemAddERK6ImRectjPS1_i(ptr noundef nonnull align 4 dereferenceable(16) %column_hit_rect, i32 noundef %48, ptr noundef null, i32 noundef 8)
  br i1 %call32, label %if.end34, label %if.then33

if.then33:                                        ; preds = %for.body
  br label %for.inc

if.end34:                                         ; preds = %for.body
  store i8 0, ptr %hovered, align 1
  store i8 0, ptr %held, align 1
  %49 = load i32, ptr %flags, align 4
  %and35 = and i32 %49, 2
  %tobool36 = icmp ne i32 %and35, 0
  br i1 %tobool36, label %if.end50, label %if.then37

if.then37:                                        ; preds = %if.end34
  %50 = load i32, ptr %column_id, align 4
  %call38 = call noundef zeroext i1 @_ZN5ImGui14ButtonBehaviorERK6ImRectjPbS3_i(ptr noundef nonnull align 4 dereferenceable(16) %column_hit_rect, i32 noundef %50, ptr noundef %hovered, ptr noundef %held, i32 noundef 0)
  %51 = load i8, ptr %hovered, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.then41, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then37
  %52 = load i8, ptr %held, align 1
  %tobool40 = trunc i8 %52 to i1
  br i1 %tobool40, label %if.then41, label %if.end42

if.then41:                                        ; preds = %lor.lhs.false, %if.then37
  %53 = load ptr, ptr %g, align 8
  %MouseCursor = getelementptr inbounds %struct.ImGuiContext, ptr %53, i32 0, i32 180
  store i32 4, ptr %MouseCursor, align 8
  br label %if.end42

if.end42:                                         ; preds = %if.then41, %lor.lhs.false
  %54 = load i8, ptr %held, align 1
  %tobool43 = trunc i8 %54 to i1
  br i1 %tobool43, label %land.lhs.true44, label %if.end49

land.lhs.true44:                                  ; preds = %if.end42
  %55 = load ptr, ptr %column, align 8
  %Flags45 = getelementptr inbounds %struct.ImGuiOldColumnData, ptr %55, i32 0, i32 2
  %56 = load i32, ptr %Flags45, align 4
  %and46 = and i32 %56, 2
  %tobool47 = icmp ne i32 %and46, 0
  br i1 %tobool47, label %if.end49, label %if.then48

if.then48:                                        ; preds = %land.lhs.true44
  %57 = load i32, ptr %n, align 4
  store i32 %57, ptr %dragging_column, align 4
  br label %if.end49

if.end49:                                         ; preds = %if.then48, %land.lhs.true44, %if.end42
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.end34
  %58 = load i8, ptr %held, align 1
  %tobool51 = trunc i8 %58 to i1
  br i1 %tobool51, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end50
  br label %cond.end

cond.false:                                       ; preds = %if.end50
  %59 = load i8, ptr %hovered, align 1
  %tobool52 = trunc i8 %59 to i1
  %cond = select i1 %tobool52, i32 28, i32 27
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond53 = phi i32 [ 29, %cond.true ], [ %cond, %cond.false ]
  %call54 = call noundef i32 @_ZN5ImGui11GetColorU32Eif(i32 noundef %cond53, float noundef 1.000000e+00)
  store i32 %call54, ptr %col, align 4
  %60 = load float, ptr %x26, align 4
  %conv = fptosi float %60 to i32
  %conv55 = sitofp i32 %conv to float
  store float %conv55, ptr %xi, align 4
  %61 = load ptr, ptr %window, align 8
  %DrawList56 = getelementptr inbounds %struct.ImGuiWindow, ptr %61, i32 0, i32 86
  %62 = load ptr, ptr %DrawList56, align 8
  %63 = load float, ptr %xi, align 4
  %64 = load float, ptr %y1, align 4
  %add58 = fadd float %64, 1.000000e+00
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp57, float noundef %63, float noundef %add58)
  %65 = load float, ptr %xi, align 4
  %66 = load float, ptr %y2, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp59, float noundef %65, float noundef %66)
  %67 = load i32, ptr %col, align 4
  call void @_ZN10ImDrawList7AddLineERK6ImVec2S2_jf(ptr noundef nonnull align 8 dereferenceable(196) %62, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp57, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp59, i32 noundef %67, float noundef 1.000000e+00)
  br label %for.inc

for.inc:                                          ; preds = %cond.end, %if.then33
  %68 = load i32, ptr %n, align 4
  %inc = add nsw i32 %68, 1
  store i32 %inc, ptr %n, align 4
  br label %for.cond, !llvm.loop !72

for.end:                                          ; preds = %for.cond
  %69 = load i32, ptr %dragging_column, align 4
  %cmp60 = icmp ne i32 %69, -1
  br i1 %cmp60, label %if.then61, label %if.end81

if.then61:                                        ; preds = %for.end
  %70 = load ptr, ptr %columns, align 8
  %IsBeingResized = getelementptr inbounds %struct.ImGuiOldColumns, ptr %70, i32 0, i32 3
  %71 = load i8, ptr %IsBeingResized, align 1
  %tobool62 = trunc i8 %71 to i1
  br i1 %tobool62, label %if.end77, label %if.then63

if.then63:                                        ; preds = %if.then61
  store i32 0, ptr %n64, align 4
  br label %for.cond65

for.cond65:                                       ; preds = %for.inc74, %if.then63
  %72 = load i32, ptr %n64, align 4
  %73 = load ptr, ptr %columns, align 8
  %Count66 = getelementptr inbounds %struct.ImGuiOldColumns, ptr %73, i32 0, i32 5
  %74 = load i32, ptr %Count66, align 8
  %add67 = add nsw i32 %74, 1
  %cmp68 = icmp slt i32 %72, %add67
  br i1 %cmp68, label %for.body69, label %for.end76

for.body69:                                       ; preds = %for.cond65
  %75 = load ptr, ptr %columns, align 8
  %Columns70 = getelementptr inbounds %struct.ImGuiOldColumns, ptr %75, i32 0, i32 15
  %76 = load i32, ptr %n64, align 4
  %call71 = call noundef nonnull align 4 dereferenceable(28) ptr @_ZN8ImVectorI18ImGuiOldColumnDataEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns70, i32 noundef %76)
  %OffsetNorm = getelementptr inbounds %struct.ImGuiOldColumnData, ptr %call71, i32 0, i32 0
  %77 = load float, ptr %OffsetNorm, align 4
  %78 = load ptr, ptr %columns, align 8
  %Columns72 = getelementptr inbounds %struct.ImGuiOldColumns, ptr %78, i32 0, i32 15
  %79 = load i32, ptr %n64, align 4
  %call73 = call noundef nonnull align 4 dereferenceable(28) ptr @_ZN8ImVectorI18ImGuiOldColumnDataEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Columns72, i32 noundef %79)
  %OffsetNormBeforeResize = getelementptr inbounds %struct.ImGuiOldColumnData, ptr %call73, i32 0, i32 1
  store float %77, ptr %OffsetNormBeforeResize, align 4
  br label %for.inc74

for.inc74:                                        ; preds = %for.body69
  %80 = load i32, ptr %n64, align 4
  %inc75 = add nsw i32 %80, 1
  store i32 %inc75, ptr %n64, align 4
  br label %for.cond65, !llvm.loop !73

for.end76:                                        ; preds = %for.cond65
  br label %if.end77

if.end77:                                         ; preds = %for.end76, %if.then61
  store i8 1, ptr %is_being_resized, align 1
  %81 = load ptr, ptr %columns, align 8
  %IsBeingResized78 = getelementptr inbounds %struct.ImGuiOldColumns, ptr %81, i32 0, i32 3
  store i8 1, ptr %IsBeingResized78, align 1
  %82 = load ptr, ptr %columns, align 8
  %83 = load i32, ptr %dragging_column, align 4
  %call80 = call noundef float @_ZL22GetDraggedColumnOffsetP15ImGuiOldColumnsi(ptr noundef %82, i32 noundef %83)
  store float %call80, ptr %x79, align 4
  %84 = load i32, ptr %dragging_column, align 4
  %85 = load float, ptr %x79, align 4
  call void @_ZN5ImGui15SetColumnOffsetEif(i32 noundef %84, float noundef %85)
  br label %if.end81

if.end81:                                         ; preds = %if.end77, %for.end
  br label %if.end82

if.end82:                                         ; preds = %if.end81, %land.lhs.true, %if.end10
  %86 = load i8, ptr %is_being_resized, align 1
  %tobool83 = trunc i8 %86 to i1
  %87 = load ptr, ptr %columns, align 8
  %IsBeingResized84 = getelementptr inbounds %struct.ImGuiOldColumns, ptr %87, i32 0, i32 3
  %frombool = zext i1 %tobool83 to i8
  store i8 %frombool, ptr %IsBeingResized84, align 1
  %88 = load ptr, ptr %window, align 8
  %ParentWorkRect = getelementptr inbounds %struct.ImGuiWindow, ptr %88, i32 0, i32 73
  %89 = load ptr, ptr %window, align 8
  %WorkRect = getelementptr inbounds %struct.ImGuiWindow, ptr %89, i32 0, i32 72
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %WorkRect, ptr align 8 %ParentWorkRect, i64 16, i1 false)
  %90 = load ptr, ptr %columns, align 8
  %HostBackupParentWorkRect = getelementptr inbounds %struct.ImGuiOldColumns, ptr %90, i32 0, i32 14
  %91 = load ptr, ptr %window, align 8
  %ParentWorkRect85 = getelementptr inbounds %struct.ImGuiWindow, ptr %91, i32 0, i32 73
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %ParentWorkRect85, ptr align 4 %HostBackupParentWorkRect, i64 16, i1 false)
  %92 = load ptr, ptr %window, align 8
  %DC86 = getelementptr inbounds %struct.ImGuiWindow, ptr %92, i32 0, i32 68
  %CurrentColumns87 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC86, i32 0, i32 28
  store ptr null, ptr %CurrentColumns87, align 8
  %93 = load ptr, ptr %window, align 8
  %DC88 = getelementptr inbounds %struct.ImGuiWindow, ptr %93, i32 0, i32 68
  %ColumnsOffset = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC88, i32 0, i32 12
  %x89 = getelementptr inbounds %struct.ImVec1, ptr %ColumnsOffset, i32 0, i32 0
  store float 0.000000e+00, ptr %x89, align 8
  %94 = load ptr, ptr %window, align 8
  %Pos90 = getelementptr inbounds %struct.ImGuiWindow, ptr %94, i32 0, i32 7
  %x91 = getelementptr inbounds %struct.ImVec2, ptr %Pos90, i32 0, i32 0
  %95 = load float, ptr %x91, align 8
  %96 = load ptr, ptr %window, align 8
  %DC92 = getelementptr inbounds %struct.ImGuiWindow, ptr %96, i32 0, i32 68
  %Indent = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC92, i32 0, i32 11
  %x93 = getelementptr inbounds %struct.ImVec1, ptr %Indent, i32 0, i32 0
  %97 = load float, ptr %x93, align 4
  %add94 = fadd float %95, %97
  %98 = load ptr, ptr %window, align 8
  %DC95 = getelementptr inbounds %struct.ImGuiWindow, ptr %98, i32 0, i32 68
  %ColumnsOffset96 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC95, i32 0, i32 12
  %x97 = getelementptr inbounds %struct.ImVec1, ptr %ColumnsOffset96, i32 0, i32 0
  %99 = load float, ptr %x97, align 8
  %add98 = fadd float %add94, %99
  %conv99 = fptosi float %add98 to i32
  %conv100 = sitofp i32 %conv99 to float
  %100 = load ptr, ptr %window, align 8
  %DC101 = getelementptr inbounds %struct.ImGuiWindow, ptr %100, i32 0, i32 68
  %CursorPos102 = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC101, i32 0, i32 0
  %x103 = getelementptr inbounds %struct.ImVec2, ptr %CursorPos102, i32 0, i32 0
  store float %conv100, ptr %x103, align 8
  call void @_ZN5ImGui39NavUpdateCurrentWindowIsScrollPushableXEv()
  ret void
}

; Function Attrs: mustprogress uwtable
define internal noundef float @_ZL22GetDraggedColumnOffsetP15ImGuiOldColumnsi(ptr noundef %columns, i32 noundef %column_index) #0 {
entry:
  %columns.addr = alloca ptr, align 8
  %column_index.addr = alloca i32, align 4
  %g = alloca ptr, align 8
  %window = alloca ptr, align 8
  %x = alloca float, align 4
  store ptr %columns, ptr %columns.addr, align 8
  store i32 %column_index, ptr %column_index.addr, align 4
  %0 = load ptr, ptr @GImGui, align 8
  store ptr %0, ptr %g, align 8
  %1 = load ptr, ptr %g, align 8
  %CurrentWindow = getelementptr inbounds %struct.ImGuiContext, ptr %1, i32 0, i32 29
  %2 = load ptr, ptr %CurrentWindow, align 8
  store ptr %2, ptr %window, align 8
  %3 = load ptr, ptr %g, align 8
  %IO = getelementptr inbounds %struct.ImGuiContext, ptr %3, i32 0, i32 2
  %MousePos = getelementptr inbounds %struct.ImGuiIO, ptr %IO, i32 0, i32 59
  %x1 = getelementptr inbounds %struct.ImVec2, ptr %MousePos, i32 0, i32 0
  %4 = load float, ptr %x1, align 8
  %5 = load ptr, ptr %g, align 8
  %ActiveIdClickOffset = getelementptr inbounds %struct.ImGuiContext, ptr %5, i32 0, i32 56
  %x2 = getelementptr inbounds %struct.ImVec2, ptr %ActiveIdClickOffset, i32 0, i32 0
  %6 = load float, ptr %x2, align 8
  %sub = fsub float %4, %6
  %add = fadd float %sub, 4.000000e+00
  %7 = load ptr, ptr %window, align 8
  %Pos = getelementptr inbounds %struct.ImGuiWindow, ptr %7, i32 0, i32 7
  %x3 = getelementptr inbounds %struct.ImVec2, ptr %Pos, i32 0, i32 0
  %8 = load float, ptr %x3, align 8
  %sub4 = fsub float %add, %8
  store float %sub4, ptr %x, align 4
  %9 = load float, ptr %x, align 4
  %10 = load i32, ptr %column_index.addr, align 4
  %sub5 = sub nsw i32 %10, 1
  %call = call noundef float @_ZN5ImGui15GetColumnOffsetEi(i32 noundef %sub5)
  %11 = load ptr, ptr %g, align 8
  %Style = getelementptr inbounds %struct.ImGuiContext, ptr %11, i32 0, i32 3
  %ColumnsMinSpacing = getelementptr inbounds %struct.ImGuiStyle, ptr %Style, i32 0, i32 20
  %12 = load float, ptr %ColumnsMinSpacing, align 8
  %add6 = fadd float %call, %12
  %call7 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %9, float noundef %add6)
  store float %call7, ptr %x, align 4
  %13 = load ptr, ptr %columns.addr, align 8
  %Flags = getelementptr inbounds %struct.ImGuiOldColumns, ptr %13, i32 0, i32 1
  %14 = load i32, ptr %Flags, align 4
  %and = and i32 %14, 4
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %15 = load float, ptr %x, align 4
  %16 = load i32, ptr %column_index.addr, align 4
  %add8 = add nsw i32 %16, 1
  %call9 = call noundef float @_ZN5ImGui15GetColumnOffsetEi(i32 noundef %add8)
  %17 = load ptr, ptr %g, align 8
  %Style10 = getelementptr inbounds %struct.ImGuiContext, ptr %17, i32 0, i32 3
  %ColumnsMinSpacing11 = getelementptr inbounds %struct.ImGuiStyle, ptr %Style10, i32 0, i32 20
  %18 = load float, ptr %ColumnsMinSpacing11, align 8
  %sub12 = fsub float %call9, %18
  %call13 = call noundef float @_ZL5ImMinIfET_S0_S0_(float noundef %15, float noundef %sub12)
  store float %call13, ptr %x, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %19 = load float, ptr %x, align 4
  ret float %19
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui7ColumnsEiPKcb(i32 noundef %columns_count, ptr noundef %id, i1 noundef zeroext %border) #0 {
entry:
  %columns_count.addr = alloca i32, align 4
  %id.addr = alloca ptr, align 8
  %border.addr = alloca i8, align 1
  %window = alloca ptr, align 8
  %flags = alloca i32, align 4
  %columns = alloca ptr, align 8
  store i32 %columns_count, ptr %columns_count.addr, align 4
  store ptr %id, ptr %id.addr, align 8
  %frombool = zext i1 %border to i8
  store i8 %frombool, ptr %border.addr, align 1
  %call = call noundef ptr @_ZN5ImGui16GetCurrentWindowEv()
  store ptr %call, ptr %window, align 8
  %0 = load i8, ptr %border.addr, align 1
  %tobool = trunc i8 %0 to i1
  %cond = select i1 %tobool, i32 0, i32 1
  store i32 %cond, ptr %flags, align 4
  %1 = load ptr, ptr %window, align 8
  %DC = getelementptr inbounds %struct.ImGuiWindow, ptr %1, i32 0, i32 68
  %CurrentColumns = getelementptr inbounds %struct.ImGuiWindowTempData, ptr %DC, i32 0, i32 28
  %2 = load ptr, ptr %CurrentColumns, align 8
  store ptr %2, ptr %columns, align 8
  %3 = load ptr, ptr %columns, align 8
  %cmp = icmp ne ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %4 = load ptr, ptr %columns, align 8
  %Count = getelementptr inbounds %struct.ImGuiOldColumns, ptr %4, i32 0, i32 5
  %5 = load i32, ptr %Count, align 8
  %6 = load i32, ptr %columns_count.addr, align 4
  %cmp1 = icmp eq i32 %5, %6
  br i1 %cmp1, label %land.lhs.true2, label %if.end

land.lhs.true2:                                   ; preds = %land.lhs.true
  %7 = load ptr, ptr %columns, align 8
  %Flags = getelementptr inbounds %struct.ImGuiOldColumns, ptr %7, i32 0, i32 1
  %8 = load i32, ptr %Flags, align 4
  %9 = load i32, ptr %flags, align 4
  %cmp3 = icmp eq i32 %8, %9
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true2
  br label %if.end9

if.end:                                           ; preds = %land.lhs.true2, %land.lhs.true, %entry
  %10 = load ptr, ptr %columns, align 8
  %cmp4 = icmp ne ptr %10, null
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end
  call void @_ZN5ImGui10EndColumnsEv()
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %if.end
  %11 = load i32, ptr %columns_count.addr, align 4
  %cmp7 = icmp ne i32 %11, 1
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end6
  %12 = load ptr, ptr %id.addr, align 8
  %13 = load i32, ptr %columns_count.addr, align 4
  %14 = load i32, ptr %flags, align 4
  call void @_ZN5ImGui12BeginColumnsEPKcii(ptr noundef %12, i32 noundef %13, i32 noundef %14)
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %if.end6, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN18ImDrawListSplitterC2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %_Channels = getelementptr inbounds %struct.ImDrawListSplitter, ptr %this1, i32 0, i32 2
  call void @_ZN8ImVectorI13ImDrawChannelEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %_Channels)
  call void @llvm.memset.p0.i64(ptr align 8 %this1, i8 0, i64 24, i1 false)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN6ImRectC2Ev(ptr noundef nonnull align 4 dereferenceable(16) %this) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Min = getelementptr inbounds %struct.ImRect, ptr %this1, i32 0, i32 0
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %Min, float noundef 0.000000e+00, float noundef 0.000000e+00)
  %Max = getelementptr inbounds %struct.ImRect, ptr %this1, i32 0, i32 1
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %Max, float noundef 0.000000e+00, float noundef 0.000000e+00)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN6ImVec1C2Ev(ptr noundef nonnull align 4 dereferenceable(4) %this) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %x = getelementptr inbounds %struct.ImVec1, ptr %this1, i32 0, i32 0
  store float 0.000000e+00, ptr %x, align 4
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN18ImDrawListSplitterD2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this) unnamed_addr #3 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  invoke void @_ZN18ImDrawListSplitter15ClearFreeMemoryEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %_Channels = getelementptr inbounds %struct.ImDrawListSplitter, ptr %this1, i32 0, i32 2
  call void @_ZN8ImVectorI13ImDrawChannelED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %_Channels) #10
  ret void

terminate.lpad:                                   ; preds = %entry
  %0 = landingpad { ptr, i32 }
          catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  call void @__clang_call_terminate(ptr %1) #12
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorI13ImDrawChannelEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.20, ptr %this1, i32 0, i32 1
  store i32 0, ptr %Capacity, align 4
  %Size = getelementptr inbounds %struct.ImVector.20, ptr %this1, i32 0, i32 0
  store i32 0, ptr %Size, align 8
  %Data = getelementptr inbounds %struct.ImVector.20, ptr %this1, i32 0, i32 2
  store ptr null, ptr %Data, align 8
  ret void
}

; Function Attrs: noreturn nounwind uwtable
define linkonce_odr hidden void @__clang_call_terminate(ptr noundef %0) #9 comdat {
  %2 = call ptr @__cxa_begin_catch(ptr %0) #10
  call void @_ZSt9terminatev() #12
  unreachable
}

declare ptr @__cxa_begin_catch(ptr)

declare void @_ZSt9terminatev()

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorI13ImDrawChannelED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #3 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.20, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Data2 = getelementptr inbounds %struct.ImVector.20, ptr %this1, i32 0, i32 2
  %1 = load ptr, ptr %Data2, align 8
  invoke void @_ZN5ImGui7MemFreeEPv(ptr noundef %1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %if.then
  br label %if.end

if.end:                                           ; preds = %invoke.cont, %entry
  ret void

terminate.lpad:                                   ; preds = %if.then
  %2 = landingpad { ptr, i32 }
          catch ptr null
  %3 = extractvalue { ptr, i32 } %2, 0
  call void @__clang_call_terminate(ptr %3) #12
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef nonnull align 4 dereferenceable(24) ptr @_ZN8ImVectorI22ImGuiTableInstanceDataEixEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %i) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.38, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.ImGuiTableInstanceData, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress uwtable
define internal <2 x float> @_ZL5ImMaxRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %lhs, ptr noundef nonnull align 4 dereferenceable(8) %rhs) #2 {
entry:
  %retval = alloca %struct.ImVec2, align 4
  %lhs.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %lhs, ptr %lhs.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %0 = load ptr, ptr %lhs.addr, align 8
  %x = getelementptr inbounds %struct.ImVec2, ptr %0, i32 0, i32 0
  %1 = load float, ptr %x, align 4
  %2 = load ptr, ptr %rhs.addr, align 8
  %x1 = getelementptr inbounds %struct.ImVec2, ptr %2, i32 0, i32 0
  %3 = load float, ptr %x1, align 4
  %cmp = fcmp oge float %1, %3
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %4 = load ptr, ptr %lhs.addr, align 8
  %x2 = getelementptr inbounds %struct.ImVec2, ptr %4, i32 0, i32 0
  %5 = load float, ptr %x2, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %6 = load ptr, ptr %rhs.addr, align 8
  %x3 = getelementptr inbounds %struct.ImVec2, ptr %6, i32 0, i32 0
  %7 = load float, ptr %x3, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi float [ %5, %cond.true ], [ %7, %cond.false ]
  %8 = load ptr, ptr %lhs.addr, align 8
  %y = getelementptr inbounds %struct.ImVec2, ptr %8, i32 0, i32 1
  %9 = load float, ptr %y, align 4
  %10 = load ptr, ptr %rhs.addr, align 8
  %y4 = getelementptr inbounds %struct.ImVec2, ptr %10, i32 0, i32 1
  %11 = load float, ptr %y4, align 4
  %cmp5 = fcmp oge float %9, %11
  br i1 %cmp5, label %cond.true6, label %cond.false8

cond.true6:                                       ; preds = %cond.end
  %12 = load ptr, ptr %lhs.addr, align 8
  %y7 = getelementptr inbounds %struct.ImVec2, ptr %12, i32 0, i32 1
  %13 = load float, ptr %y7, align 4
  br label %cond.end10

cond.false8:                                      ; preds = %cond.end
  %14 = load ptr, ptr %rhs.addr, align 8
  %y9 = getelementptr inbounds %struct.ImVec2, ptr %14, i32 0, i32 1
  %15 = load float, ptr %y9, align 4
  br label %cond.end10

cond.end10:                                       ; preds = %cond.false8, %cond.true6
  %cond11 = phi float [ %13, %cond.true6 ], [ %15, %cond.false8 ]
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %retval, float noundef %cond, float noundef %cond11)
  %16 = load <2 x float>, ptr %retval, align 4
  ret <2 x float> %16
}

; Function Attrs: mustprogress uwtable
define internal <2 x float> @_ZL5ImMinRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %lhs, ptr noundef nonnull align 4 dereferenceable(8) %rhs) #2 {
entry:
  %retval = alloca %struct.ImVec2, align 4
  %lhs.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %lhs, ptr %lhs.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %0 = load ptr, ptr %lhs.addr, align 8
  %x = getelementptr inbounds %struct.ImVec2, ptr %0, i32 0, i32 0
  %1 = load float, ptr %x, align 4
  %2 = load ptr, ptr %rhs.addr, align 8
  %x1 = getelementptr inbounds %struct.ImVec2, ptr %2, i32 0, i32 0
  %3 = load float, ptr %x1, align 4
  %cmp = fcmp olt float %1, %3
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %4 = load ptr, ptr %lhs.addr, align 8
  %x2 = getelementptr inbounds %struct.ImVec2, ptr %4, i32 0, i32 0
  %5 = load float, ptr %x2, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %6 = load ptr, ptr %rhs.addr, align 8
  %x3 = getelementptr inbounds %struct.ImVec2, ptr %6, i32 0, i32 0
  %7 = load float, ptr %x3, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi float [ %5, %cond.true ], [ %7, %cond.false ]
  %8 = load ptr, ptr %lhs.addr, align 8
  %y = getelementptr inbounds %struct.ImVec2, ptr %8, i32 0, i32 1
  %9 = load float, ptr %y, align 4
  %10 = load ptr, ptr %rhs.addr, align 8
  %y4 = getelementptr inbounds %struct.ImVec2, ptr %10, i32 0, i32 1
  %11 = load float, ptr %y4, align 4
  %cmp5 = fcmp olt float %9, %11
  br i1 %cmp5, label %cond.true6, label %cond.false8

cond.true6:                                       ; preds = %cond.end
  %12 = load ptr, ptr %lhs.addr, align 8
  %y7 = getelementptr inbounds %struct.ImVec2, ptr %12, i32 0, i32 1
  %13 = load float, ptr %y7, align 4
  br label %cond.end10

cond.false8:                                      ; preds = %cond.end
  %14 = load ptr, ptr %rhs.addr, align 8
  %y9 = getelementptr inbounds %struct.ImVec2, ptr %14, i32 0, i32 1
  %15 = load float, ptr %y9, align 4
  br label %cond.end10

cond.end10:                                       ; preds = %cond.false8, %cond.true6
  %cond11 = phi float [ %13, %cond.true6 ], [ %15, %cond.false8 ]
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %retval, float noundef %cond, float noundef %cond11)
  %16 = load <2 x float>, ptr %retval, align 4
  ret <2 x float> %16
}

; Function Attrs: mustprogress uwtable
define internal <2 x float> @_ZL7ImClampRK6ImVec2S1_S_(ptr noundef nonnull align 4 dereferenceable(8) %v, ptr noundef nonnull align 4 dereferenceable(8) %mn, <2 x float> %mx.coerce) #2 {
entry:
  %retval = alloca %struct.ImVec2, align 4
  %mx = alloca %struct.ImVec2, align 4
  %v.addr = alloca ptr, align 8
  %mn.addr = alloca ptr, align 8
  store <2 x float> %mx.coerce, ptr %mx, align 4
  store ptr %v, ptr %v.addr, align 8
  store ptr %mn, ptr %mn.addr, align 8
  %0 = load ptr, ptr %v.addr, align 8
  %x = getelementptr inbounds %struct.ImVec2, ptr %0, i32 0, i32 0
  %1 = load float, ptr %x, align 4
  %2 = load ptr, ptr %mn.addr, align 8
  %x1 = getelementptr inbounds %struct.ImVec2, ptr %2, i32 0, i32 0
  %3 = load float, ptr %x1, align 4
  %cmp = fcmp olt float %1, %3
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %4 = load ptr, ptr %mn.addr, align 8
  %x2 = getelementptr inbounds %struct.ImVec2, ptr %4, i32 0, i32 0
  %5 = load float, ptr %x2, align 4
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %6 = load ptr, ptr %v.addr, align 8
  %x3 = getelementptr inbounds %struct.ImVec2, ptr %6, i32 0, i32 0
  %7 = load float, ptr %x3, align 4
  %x4 = getelementptr inbounds %struct.ImVec2, ptr %mx, i32 0, i32 0
  %8 = load float, ptr %x4, align 4
  %cmp5 = fcmp ogt float %7, %8
  br i1 %cmp5, label %cond.true6, label %cond.false8

cond.true6:                                       ; preds = %cond.false
  %x7 = getelementptr inbounds %struct.ImVec2, ptr %mx, i32 0, i32 0
  %9 = load float, ptr %x7, align 4
  br label %cond.end

cond.false8:                                      ; preds = %cond.false
  %10 = load ptr, ptr %v.addr, align 8
  %x9 = getelementptr inbounds %struct.ImVec2, ptr %10, i32 0, i32 0
  %11 = load float, ptr %x9, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false8, %cond.true6
  %cond = phi float [ %9, %cond.true6 ], [ %11, %cond.false8 ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end, %cond.true
  %cond11 = phi float [ %5, %cond.true ], [ %cond, %cond.end ]
  %12 = load ptr, ptr %v.addr, align 8
  %y = getelementptr inbounds %struct.ImVec2, ptr %12, i32 0, i32 1
  %13 = load float, ptr %y, align 4
  %14 = load ptr, ptr %mn.addr, align 8
  %y12 = getelementptr inbounds %struct.ImVec2, ptr %14, i32 0, i32 1
  %15 = load float, ptr %y12, align 4
  %cmp13 = fcmp olt float %13, %15
  br i1 %cmp13, label %cond.true14, label %cond.false16

cond.true14:                                      ; preds = %cond.end10
  %16 = load ptr, ptr %mn.addr, align 8
  %y15 = getelementptr inbounds %struct.ImVec2, ptr %16, i32 0, i32 1
  %17 = load float, ptr %y15, align 4
  br label %cond.end26

cond.false16:                                     ; preds = %cond.end10
  %18 = load ptr, ptr %v.addr, align 8
  %y17 = getelementptr inbounds %struct.ImVec2, ptr %18, i32 0, i32 1
  %19 = load float, ptr %y17, align 4
  %y18 = getelementptr inbounds %struct.ImVec2, ptr %mx, i32 0, i32 1
  %20 = load float, ptr %y18, align 4
  %cmp19 = fcmp ogt float %19, %20
  br i1 %cmp19, label %cond.true20, label %cond.false22

cond.true20:                                      ; preds = %cond.false16
  %y21 = getelementptr inbounds %struct.ImVec2, ptr %mx, i32 0, i32 1
  %21 = load float, ptr %y21, align 4
  br label %cond.end24

cond.false22:                                     ; preds = %cond.false16
  %22 = load ptr, ptr %v.addr, align 8
  %y23 = getelementptr inbounds %struct.ImVec2, ptr %22, i32 0, i32 1
  %23 = load float, ptr %y23, align 4
  br label %cond.end24

cond.end24:                                       ; preds = %cond.false22, %cond.true20
  %cond25 = phi float [ %21, %cond.true20 ], [ %23, %cond.false22 ]
  br label %cond.end26

cond.end26:                                       ; preds = %cond.end24, %cond.true14
  %cond27 = phi float [ %17, %cond.true14 ], [ %cond25, %cond.end24 ]
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %retval, float noundef %cond11, float noundef %cond27)
  %24 = load <2 x float>, ptr %retval, align 4
  ret <2 x float> %24
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i32 @_ZNK6ImSpanI16ImGuiTableColumnE14index_from_ptrEPKS0_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %it) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %it.addr = alloca ptr, align 8
  %off = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %it, ptr %it.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %it.addr, align 8
  %Data = getelementptr inbounds %struct.ImSpan, ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %Data, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 112
  store i64 %sub.ptr.div, ptr %off, align 8
  %2 = load i64, ptr %off, align 8
  %conv = trunc i64 %2 to i32
  ret i32 %conv
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %this, float noundef %_x, float noundef %_y, float noundef %_z, float noundef %_w) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %_x.addr = alloca float, align 4
  %_y.addr = alloca float, align 4
  %_z.addr = alloca float, align 4
  %_w.addr = alloca float, align 4
  store ptr %this, ptr %this.addr, align 8
  store float %_x, ptr %_x.addr, align 4
  store float %_y, ptr %_y.addr, align 4
  store float %_z, ptr %_z.addr, align 4
  store float %_w, ptr %_w.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %x = getelementptr inbounds %struct.ImVec4, ptr %this1, i32 0, i32 0
  %0 = load float, ptr %_x.addr, align 4
  store float %0, ptr %x, align 4
  %y = getelementptr inbounds %struct.ImVec4, ptr %this1, i32 0, i32 1
  %1 = load float, ptr %_y.addr, align 4
  store float %1, ptr %y, align 4
  %z = getelementptr inbounds %struct.ImVec4, ptr %this1, i32 0, i32 2
  %2 = load float, ptr %_z.addr, align 4
  store float %2, ptr %z, align 4
  %w = getelementptr inbounds %struct.ImVec4, ptr %this1, i32 0, i32 3
  %3 = load float, ptr %_w.addr, align 4
  store float %3, ptr %w, align 4
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef ptr @_Znwm12ImNewWrapperPv(i64 noundef %0, ptr noundef %ptr) #3 comdat {
entry:
  %.addr = alloca i64, align 8
  %ptr.addr = alloca ptr, align 8
  store i64 %0, ptr %.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %1 = load ptr, ptr %ptr.addr, align 8
  ret ptr %1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN18ImGuiTableSettingsC2Ev(ptr noundef nonnull align 4 dereferenceable(17) %this) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @llvm.memset.p0.i64(ptr align 4 %this1, i8 0, i64 20, i1 false)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZdlPv12ImNewWrapperS_(ptr noundef %0, ptr noundef %1) #3 comdat {
entry:
  %.addr = alloca ptr, align 8
  %.addr1 = alloca ptr, align 8
  store ptr %0, ptr %.addr, align 8
  store ptr %1, ptr %.addr1, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN24ImGuiTableColumnSettingsC2Ev(ptr noundef nonnull align 4 dereferenceable(15) %this) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %WidthOrWeight = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %this1, i32 0, i32 0
  store float 0.000000e+00, ptr %WidthOrWeight, align 4
  %UserID = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %this1, i32 0, i32 1
  store i32 0, ptr %UserID, align 4
  %Index = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %this1, i32 0, i32 2
  store i16 -1, ptr %Index, align 4
  %SortOrder = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %this1, i32 0, i32 4
  store i16 -1, ptr %SortOrder, align 4
  %DisplayOrder = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %this1, i32 0, i32 3
  store i16 -1, ptr %DisplayOrder, align 2
  %SortDirection = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %this1, i32 0, i32 5
  %bf.load = load i8, ptr %SortDirection, align 2
  %bf.clear = and i8 %bf.load, -4
  %bf.set = or i8 %bf.clear, 0
  store i8 %bf.set, ptr %SortDirection, align 2
  %IsEnabled = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %this1, i32 0, i32 5
  %bf.load2 = load i8, ptr %IsEnabled, align 2
  %bf.clear3 = and i8 %bf.load2, -5
  %bf.set4 = or i8 %bf.clear3, 4
  store i8 %bf.set4, ptr %IsEnabled, align 2
  %IsStretch = getelementptr inbounds %struct.ImGuiTableColumnSettings, ptr %this1, i32 0, i32 5
  %bf.load5 = load i8, ptr %IsStretch, align 2
  %bf.clear6 = and i8 %bf.load5, -9
  %bf.set7 = or i8 %bf.clear6, 0
  store i8 %bf.set7, ptr %IsStretch, align 2
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i32 @_ZNK6ImPoolI10ImGuiTableE10GetMapSizeEv(ptr noundef nonnull align 8 dereferenceable(40) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Map = getelementptr inbounds %struct.ImPool, ptr %this1, i32 0, i32 1
  %Data = getelementptr inbounds %struct.ImGuiStorage, ptr %Map, i32 0, i32 0
  %Size = getelementptr inbounds %struct.ImVector.4, ptr %Data, i32 0, i32 0
  %0 = load i32, ptr %Size, align 8
  ret i32 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr noundef ptr @_ZN6ImPoolI10ImGuiTableE13TryGetMapDataEi(ptr noundef nonnull align 8 dereferenceable(40) %this, i32 noundef %n) #0 comdat align 2 {
entry:
  %retval = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  %idx = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Map = getelementptr inbounds %struct.ImPool, ptr %this1, i32 0, i32 1
  %Data = getelementptr inbounds %struct.ImGuiStorage, ptr %Map, i32 0, i32 0
  %0 = load i32, ptr %n.addr, align 4
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN8ImVectorIN12ImGuiStorage16ImGuiStoragePairEEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Data, i32 noundef %0)
  %1 = getelementptr inbounds %"struct.ImGuiStorage::ImGuiStoragePair", ptr %call, i32 0, i32 1
  %2 = load i32, ptr %1, align 8
  store i32 %2, ptr %idx, align 4
  %3 = load i32, ptr %idx, align 4
  %cmp = icmp eq i32 %3, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %4 = load i32, ptr %idx, align 4
  %call2 = call noundef ptr @_ZN6ImPoolI10ImGuiTableE10GetByIndexEi(ptr noundef nonnull align 8 dereferenceable(40) %this1, i32 noundef %4)
  store ptr %call2, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %5 = load ptr, ptr %retval, align 8
  ret ptr %5
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN13ImChunkStreamI18ImGuiTableSettingsE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Buf = getelementptr inbounds %struct.ImChunkStream.28, ptr %this1, i32 0, i32 0
  call void @_ZN8ImVectorIcE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %Buf)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef nonnull align 8 dereferenceable(16) ptr @_ZN8ImVectorIN12ImGuiStorage16ImGuiStoragePairEEixEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %i) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.4, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %"struct.ImGuiStorage::ImGuiStoragePair", ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorIcE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.25, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Capacity = getelementptr inbounds %struct.ImVector.25, ptr %this1, i32 0, i32 1
  store i32 0, ptr %Capacity, align 4
  %Size = getelementptr inbounds %struct.ImVector.25, ptr %this1, i32 0, i32 0
  store i32 0, ptr %Size, align 8
  %Data2 = getelementptr inbounds %struct.ImVector.25, ptr %this1, i32 0, i32 2
  %1 = load ptr, ptr %Data2, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %1)
  %Data3 = getelementptr inbounds %struct.ImVector.25, ptr %this1, i32 0, i32 2
  store ptr null, ptr %Data3, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind
declare i32 @__isoc99_sscanf(ptr noundef, ptr noundef, ...) #8

declare noundef ptr @_Z14ImStrSkipBlankPKc(ptr noundef) #1

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN15ImGuiTextBuffer7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %capacity) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %capacity.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %capacity, ptr %capacity.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Buf = getelementptr inbounds %struct.ImGuiTextBuffer, ptr %this1, i32 0, i32 0
  %0 = load i32, ptr %capacity.addr, align 4
  call void @_ZN8ImVectorIcE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %Buf, i32 noundef %0)
  ret void
}

declare void @_ZN15ImGuiTextBuffer7appendfEPKcz(ptr noundef nonnull align 8 dereferenceable(16), ptr noundef, ...) #1

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorIcEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.25, ptr %this1, i32 0, i32 1
  store i32 0, ptr %Capacity, align 4
  %Size = getelementptr inbounds %struct.ImVector.25, ptr %this1, i32 0, i32 0
  store i32 0, ptr %Size, align 8
  %Data = getelementptr inbounds %struct.ImVector.25, ptr %this1, i32 0, i32 2
  store ptr null, ptr %Data, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorIcED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #3 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.25, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Data2 = getelementptr inbounds %struct.ImVector.25, ptr %this1, i32 0, i32 2
  %1 = load ptr, ptr %Data2, align 8
  invoke void @_ZN5ImGui7MemFreeEPv(ptr noundef %1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %if.then
  br label %if.end

if.end:                                           ; preds = %invoke.cont, %entry
  ret void

terminate.lpad:                                   ; preds = %if.then
  %2 = landingpad { ptr, i32 }
          catch ptr null
  %3 = extractvalue { ptr, i32 } %2, 0
  call void @__clang_call_terminate(ptr %3) #12
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorI18ImGuiOldColumnDataEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.40, ptr %this1, i32 0, i32 1
  store i32 0, ptr %Capacity, align 4
  %Size = getelementptr inbounds %struct.ImVector.40, ptr %this1, i32 0, i32 0
  store i32 0, ptr %Size, align 8
  %Data = getelementptr inbounds %struct.ImVector.40, ptr %this1, i32 0, i32 2
  store ptr null, ptr %Data, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorI18ImGuiOldColumnDataED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #3 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.40, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Data2 = getelementptr inbounds %struct.ImVector.40, ptr %this1, i32 0, i32 2
  %1 = load ptr, ptr %Data2, align 8
  invoke void @_ZN5ImGui7MemFreeEPv(ptr noundef %1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %if.then
  br label %if.end

if.end:                                           ; preds = %invoke.cont, %entry
  ret void

terminate.lpad:                                   ; preds = %if.then
  %2 = landingpad { ptr, i32 }
          catch ptr null
  %3 = extractvalue { ptr, i32 } %2, 0
  call void @__clang_call_terminate(ptr %3) #12
  unreachable
}

declare noundef i32 @_ZNK12ImGuiStorage6GetIntEji(ptr noundef nonnull align 8 dereferenceable(16), i32 noundef, i32 noundef) #1

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef nonnull align 8 dereferenceable(586) ptr @_ZN8ImVectorI10ImGuiTableEixEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %i) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.18, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.ImGuiTable, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

declare noundef ptr @_ZN12ImGuiStorage9GetIntRefEji(ptr noundef nonnull align 8 dereferenceable(16), i32 noundef, i32 noundef) #1

; Function Attrs: mustprogress uwtable
define linkonce_odr noundef ptr @_ZN6ImPoolI10ImGuiTableE3AddEv(ptr noundef nonnull align 8 dereferenceable(40) %this) #0 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  %idx = alloca i32, align 4
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %FreeIdx = getelementptr inbounds %struct.ImPool, ptr %this1, i32 0, i32 2
  %0 = load i32, ptr %FreeIdx, align 8
  store i32 %0, ptr %idx, align 4
  %1 = load i32, ptr %idx, align 4
  %Buf = getelementptr inbounds %struct.ImPool, ptr %this1, i32 0, i32 0
  %Size = getelementptr inbounds %struct.ImVector.18, ptr %Buf, i32 0, i32 0
  %2 = load i32, ptr %Size, align 8
  %cmp = icmp eq i32 %1, %2
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %Buf2 = getelementptr inbounds %struct.ImPool, ptr %this1, i32 0, i32 0
  %Buf3 = getelementptr inbounds %struct.ImPool, ptr %this1, i32 0, i32 0
  %Size4 = getelementptr inbounds %struct.ImVector.18, ptr %Buf3, i32 0, i32 0
  %3 = load i32, ptr %Size4, align 8
  %add = add nsw i32 %3, 1
  call void @_ZN8ImVectorI10ImGuiTableE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %Buf2, i32 noundef %add)
  %FreeIdx5 = getelementptr inbounds %struct.ImPool, ptr %this1, i32 0, i32 2
  %4 = load i32, ptr %FreeIdx5, align 8
  %inc = add nsw i32 %4, 1
  store i32 %inc, ptr %FreeIdx5, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %Buf6 = getelementptr inbounds %struct.ImPool, ptr %this1, i32 0, i32 0
  %5 = load i32, ptr %idx, align 4
  %call = call noundef nonnull align 8 dereferenceable(586) ptr @_ZN8ImVectorI10ImGuiTableEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Buf6, i32 noundef %5)
  %6 = load i32, ptr %call, align 4
  %FreeIdx7 = getelementptr inbounds %struct.ImPool, ptr %this1, i32 0, i32 2
  store i32 %6, ptr %FreeIdx7, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %Buf8 = getelementptr inbounds %struct.ImPool, ptr %this1, i32 0, i32 0
  %7 = load i32, ptr %idx, align 4
  %call9 = call noundef nonnull align 8 dereferenceable(586) ptr @_ZN8ImVectorI10ImGuiTableEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Buf8, i32 noundef %7)
  %call10 = call noundef ptr @_Znwm12ImNewWrapperPv(i64 noundef 592, ptr noundef %call9)
  invoke void @_ZN10ImGuiTableC2Ev(ptr noundef nonnull align 8 dereferenceable(586) %call10)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %if.end
  %AliveCount = getelementptr inbounds %struct.ImPool, ptr %this1, i32 0, i32 3
  %8 = load i32, ptr %AliveCount, align 4
  %inc11 = add nsw i32 %8, 1
  store i32 %inc11, ptr %AliveCount, align 4
  %Buf12 = getelementptr inbounds %struct.ImPool, ptr %this1, i32 0, i32 0
  %9 = load i32, ptr %idx, align 4
  %call13 = call noundef nonnull align 8 dereferenceable(586) ptr @_ZN8ImVectorI10ImGuiTableEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Buf12, i32 noundef %9)
  ret ptr %call13

lpad:                                             ; preds = %if.end
  %10 = landingpad { ptr, i32 }
          cleanup
  %11 = extractvalue { ptr, i32 } %10, 0
  store ptr %11, ptr %exn.slot, align 8
  %12 = extractvalue { ptr, i32 } %10, 1
  store i32 %12, ptr %ehselector.slot, align 4
  call void @_ZdlPv12ImNewWrapperS_(ptr noundef %call10, ptr noundef %call9) #10
  br label %eh.resume

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val14 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val14
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI10ImGuiTableE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_size) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_size.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_size, ptr %new_size.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_size.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.18, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sgt i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %new_size.addr, align 4
  %call = call noundef i32 @_ZNK8ImVectorI10ImGuiTableE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %2)
  call void @_ZN8ImVectorI10ImGuiTableE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %call)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32, ptr %new_size.addr, align 4
  %Size = getelementptr inbounds %struct.ImVector.18, ptr %this1, i32 0, i32 0
  store i32 %3, ptr %Size, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN10ImGuiTableC2Ev(ptr noundef nonnull align 8 dereferenceable(586) %this) unnamed_addr #0 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Columns = getelementptr inbounds %struct.ImGuiTable, ptr %this1, i32 0, i32 4
  call void @_ZN6ImSpanI16ImGuiTableColumnEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %Columns)
  %DisplayOrderToIndex = getelementptr inbounds %struct.ImGuiTable, ptr %this1, i32 0, i32 5
  call void @_ZN6ImSpanIsEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %DisplayOrderToIndex)
  %RowCellData = getelementptr inbounds %struct.ImGuiTable, ptr %this1, i32 0, i32 6
  call void @_ZN6ImSpanI18ImGuiTableCellDataEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %RowCellData)
  %OuterRect = getelementptr inbounds %struct.ImGuiTable, ptr %this1, i32 0, i32 46
  call void @_ZN6ImRectC2Ev(ptr noundef nonnull align 4 dereferenceable(16) %OuterRect)
  %InnerRect = getelementptr inbounds %struct.ImGuiTable, ptr %this1, i32 0, i32 47
  call void @_ZN6ImRectC2Ev(ptr noundef nonnull align 4 dereferenceable(16) %InnerRect)
  %WorkRect = getelementptr inbounds %struct.ImGuiTable, ptr %this1, i32 0, i32 48
  call void @_ZN6ImRectC2Ev(ptr noundef nonnull align 4 dereferenceable(16) %WorkRect)
  %InnerClipRect = getelementptr inbounds %struct.ImGuiTable, ptr %this1, i32 0, i32 49
  call void @_ZN6ImRectC2Ev(ptr noundef nonnull align 4 dereferenceable(16) %InnerClipRect)
  %BgClipRect = getelementptr inbounds %struct.ImGuiTable, ptr %this1, i32 0, i32 50
  call void @_ZN6ImRectC2Ev(ptr noundef nonnull align 4 dereferenceable(16) %BgClipRect)
  %Bg0ClipRectForDrawCmd = getelementptr inbounds %struct.ImGuiTable, ptr %this1, i32 0, i32 51
  call void @_ZN6ImRectC2Ev(ptr noundef nonnull align 4 dereferenceable(16) %Bg0ClipRectForDrawCmd)
  %Bg2ClipRectForDrawCmd = getelementptr inbounds %struct.ImGuiTable, ptr %this1, i32 0, i32 52
  call void @_ZN6ImRectC2Ev(ptr noundef nonnull align 4 dereferenceable(16) %Bg2ClipRectForDrawCmd)
  %HostClipRect = getelementptr inbounds %struct.ImGuiTable, ptr %this1, i32 0, i32 53
  call void @_ZN6ImRectC2Ev(ptr noundef nonnull align 4 dereferenceable(16) %HostClipRect)
  %HostBackupInnerClipRect = getelementptr inbounds %struct.ImGuiTable, ptr %this1, i32 0, i32 54
  call void @_ZN6ImRectC2Ev(ptr noundef nonnull align 4 dereferenceable(16) %HostBackupInnerClipRect)
  %ColumnsNames = getelementptr inbounds %struct.ImGuiTable, ptr %this1, i32 0, i32 57
  call void @_ZN15ImGuiTextBufferC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %ColumnsNames)
  %InstanceDataFirst = getelementptr inbounds %struct.ImGuiTable, ptr %this1, i32 0, i32 59
  invoke void @_ZN22ImGuiTableInstanceDataC2Ev(ptr noundef nonnull align 4 dereferenceable(24) %InstanceDataFirst)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  %InstanceDataExtra = getelementptr inbounds %struct.ImGuiTable, ptr %this1, i32 0, i32 60
  invoke void @_ZN8ImVectorI22ImGuiTableInstanceDataEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %InstanceDataExtra)
          to label %invoke.cont2 unwind label %lpad

invoke.cont2:                                     ; preds = %invoke.cont
  %SortSpecsSingle = getelementptr inbounds %struct.ImGuiTable, ptr %this1, i32 0, i32 61
  invoke void @_ZN25ImGuiTableColumnSortSpecsC2Ev(ptr noundef nonnull align 4 dereferenceable(9) %SortSpecsSingle)
          to label %invoke.cont4 unwind label %lpad3

invoke.cont4:                                     ; preds = %invoke.cont2
  %SortSpecsMulti = getelementptr inbounds %struct.ImGuiTable, ptr %this1, i32 0, i32 63
  invoke void @_ZN8ImVectorI25ImGuiTableColumnSortSpecsEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %SortSpecsMulti)
          to label %invoke.cont5 unwind label %lpad3

invoke.cont5:                                     ; preds = %invoke.cont4
  %SortSpecs = getelementptr inbounds %struct.ImGuiTable, ptr %this1, i32 0, i32 64
  invoke void @_ZN19ImGuiTableSortSpecsC2Ev(ptr noundef nonnull align 8 dereferenceable(13) %SortSpecs)
          to label %invoke.cont7 unwind label %lpad6

invoke.cont7:                                     ; preds = %invoke.cont5
  call void @llvm.memset.p0.i64(ptr align 8 %this1, i8 0, i64 592, i1 false)
  %LastFrameActive = getelementptr inbounds %struct.ImGuiTable, ptr %this1, i32 0, i32 12
  store i32 -1, ptr %LastFrameActive, align 8
  ret void

lpad:                                             ; preds = %invoke.cont, %entry
  %0 = landingpad { ptr, i32 }
          cleanup
  %1 = extractvalue { ptr, i32 } %0, 0
  store ptr %1, ptr %exn.slot, align 8
  %2 = extractvalue { ptr, i32 } %0, 1
  store i32 %2, ptr %ehselector.slot, align 4
  br label %ehcleanup8

lpad3:                                            ; preds = %invoke.cont4, %invoke.cont2
  %3 = landingpad { ptr, i32 }
          cleanup
  %4 = extractvalue { ptr, i32 } %3, 0
  store ptr %4, ptr %exn.slot, align 8
  %5 = extractvalue { ptr, i32 } %3, 1
  store i32 %5, ptr %ehselector.slot, align 4
  br label %ehcleanup

lpad6:                                            ; preds = %invoke.cont5
  %6 = landingpad { ptr, i32 }
          cleanup
  %7 = extractvalue { ptr, i32 } %6, 0
  store ptr %7, ptr %exn.slot, align 8
  %8 = extractvalue { ptr, i32 } %6, 1
  store i32 %8, ptr %ehselector.slot, align 4
  call void @_ZN8ImVectorI25ImGuiTableColumnSortSpecsED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %SortSpecsMulti) #10
  br label %ehcleanup

ehcleanup:                                        ; preds = %lpad6, %lpad3
  call void @_ZN8ImVectorI22ImGuiTableInstanceDataED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %InstanceDataExtra) #10
  br label %ehcleanup8

ehcleanup8:                                       ; preds = %ehcleanup, %lpad
  call void @_ZN15ImGuiTextBufferD2Ev(ptr noundef nonnull align 8 dereferenceable(16) %ColumnsNames) #10
  br label %eh.resume

eh.resume:                                        ; preds = %ehcleanup8
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val9 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val9
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI10ImGuiTableE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_capacity) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_capacity.addr = alloca i32, align 4
  %new_data = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_capacity, ptr %new_capacity.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_capacity.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.18, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sle i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %new_capacity.addr, align 4
  %conv = sext i32 %2 to i64
  %mul = mul i64 %conv, 592
  %call = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef %mul)
  store ptr %call, ptr %new_data, align 8
  %Data = getelementptr inbounds %struct.ImVector.18, ptr %this1, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.then2, label %if.end7

if.then2:                                         ; preds = %if.end
  %4 = load ptr, ptr %new_data, align 8
  %Data3 = getelementptr inbounds %struct.ImVector.18, ptr %this1, i32 0, i32 2
  %5 = load ptr, ptr %Data3, align 8
  %Size = getelementptr inbounds %struct.ImVector.18, ptr %this1, i32 0, i32 0
  %6 = load i32, ptr %Size, align 8
  %conv4 = sext i32 %6 to i64
  %mul5 = mul i64 %conv4, 592
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %4, ptr align 8 %5, i64 %mul5, i1 false)
  %Data6 = getelementptr inbounds %struct.ImVector.18, ptr %this1, i32 0, i32 2
  %7 = load ptr, ptr %Data6, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %7)
  br label %if.end7

if.end7:                                          ; preds = %if.then2, %if.end
  %8 = load ptr, ptr %new_data, align 8
  %Data8 = getelementptr inbounds %struct.ImVector.18, ptr %this1, i32 0, i32 2
  store ptr %8, ptr %Data8, align 8
  %9 = load i32, ptr %new_capacity.addr, align 4
  %Capacity9 = getelementptr inbounds %struct.ImVector.18, ptr %this1, i32 0, i32 1
  store i32 %9, ptr %Capacity9, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i32 @_ZNK8ImVectorI10ImGuiTableE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %sz) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %sz.addr = alloca i32, align 4
  %new_capacity = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %sz, ptr %sz.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.18, ptr %this1, i32 0, i32 1
  %0 = load i32, ptr %Capacity, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %Capacity2 = getelementptr inbounds %struct.ImVector.18, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity2, align 4
  %Capacity3 = getelementptr inbounds %struct.ImVector.18, ptr %this1, i32 0, i32 1
  %2 = load i32, ptr %Capacity3, align 4
  %div = sdiv i32 %2, 2
  %add = add nsw i32 %1, %div
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %add, %cond.true ], [ 8, %cond.false ]
  store i32 %cond, ptr %new_capacity, align 4
  %3 = load i32, ptr %new_capacity, align 4
  %4 = load i32, ptr %sz.addr, align 4
  %cmp = icmp sgt i32 %3, %4
  br i1 %cmp, label %cond.true4, label %cond.false5

cond.true4:                                       ; preds = %cond.end
  %5 = load i32, ptr %new_capacity, align 4
  br label %cond.end6

cond.false5:                                      ; preds = %cond.end
  %6 = load i32, ptr %sz.addr, align 4
  br label %cond.end6

cond.end6:                                        ; preds = %cond.false5, %cond.true4
  %cond7 = phi i32 [ %5, %cond.true4 ], [ %6, %cond.false5 ]
  ret i32 %cond7
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN6ImSpanI16ImGuiTableColumnEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %DataEnd = getelementptr inbounds %struct.ImSpan, ptr %this1, i32 0, i32 1
  store ptr null, ptr %DataEnd, align 8
  %Data = getelementptr inbounds %struct.ImSpan, ptr %this1, i32 0, i32 0
  store ptr null, ptr %Data, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN6ImSpanIsEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %DataEnd = getelementptr inbounds %struct.ImSpan.36, ptr %this1, i32 0, i32 1
  store ptr null, ptr %DataEnd, align 8
  %Data = getelementptr inbounds %struct.ImSpan.36, ptr %this1, i32 0, i32 0
  store ptr null, ptr %Data, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN6ImSpanI18ImGuiTableCellDataEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %DataEnd = getelementptr inbounds %struct.ImSpan.37, ptr %this1, i32 0, i32 1
  store ptr null, ptr %DataEnd, align 8
  %Data = getelementptr inbounds %struct.ImSpan.37, ptr %this1, i32 0, i32 0
  store ptr null, ptr %Data, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN15ImGuiTextBufferC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Buf = getelementptr inbounds %struct.ImGuiTextBuffer, ptr %this1, i32 0, i32 0
  call void @_ZN8ImVectorIcEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %Buf)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorI22ImGuiTableInstanceDataEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.38, ptr %this1, i32 0, i32 1
  store i32 0, ptr %Capacity, align 4
  %Size = getelementptr inbounds %struct.ImVector.38, ptr %this1, i32 0, i32 0
  store i32 0, ptr %Size, align 8
  %Data = getelementptr inbounds %struct.ImVector.38, ptr %this1, i32 0, i32 2
  store ptr null, ptr %Data, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN25ImGuiTableColumnSortSpecsC2Ev(ptr noundef nonnull align 4 dereferenceable(9) %this) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @llvm.memset.p0.i64(ptr align 4 %this1, i8 0, i64 12, i1 false)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorI25ImGuiTableColumnSortSpecsEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.39, ptr %this1, i32 0, i32 1
  store i32 0, ptr %Capacity, align 4
  %Size = getelementptr inbounds %struct.ImVector.39, ptr %this1, i32 0, i32 0
  store i32 0, ptr %Size, align 8
  %Data = getelementptr inbounds %struct.ImVector.39, ptr %this1, i32 0, i32 2
  store ptr null, ptr %Data, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN19ImGuiTableSortSpecsC2Ev(ptr noundef nonnull align 8 dereferenceable(13) %this) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %this1, i8 0, i64 16, i1 false)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorI25ImGuiTableColumnSortSpecsED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #3 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.39, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Data2 = getelementptr inbounds %struct.ImVector.39, ptr %this1, i32 0, i32 2
  %1 = load ptr, ptr %Data2, align 8
  invoke void @_ZN5ImGui7MemFreeEPv(ptr noundef %1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %if.then
  br label %if.end

if.end:                                           ; preds = %invoke.cont, %entry
  ret void

terminate.lpad:                                   ; preds = %if.then
  %2 = landingpad { ptr, i32 }
          catch ptr null
  %3 = extractvalue { ptr, i32 } %2, 0
  call void @__clang_call_terminate(ptr %3) #12
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorI22ImGuiTableInstanceDataED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #3 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.38, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Data2 = getelementptr inbounds %struct.ImVector.38, ptr %this1, i32 0, i32 2
  %1 = load ptr, ptr %Data2, align 8
  invoke void @_ZN5ImGui7MemFreeEPv(ptr noundef %1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %if.then
  br label %if.end

if.end:                                           ; preds = %invoke.cont, %entry
  ret void

terminate.lpad:                                   ; preds = %if.then
  %2 = landingpad { ptr, i32 }
          catch ptr null
  %3 = extractvalue { ptr, i32 } %2, 0
  call void @__clang_call_terminate(ptr %3) #12
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN15ImGuiTextBufferD2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Buf = getelementptr inbounds %struct.ImGuiTextBuffer, ptr %this1, i32 0, i32 0
  call void @_ZN8ImVectorIcED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %Buf) #10
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI18ImGuiTableTempDataE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_capacity) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_capacity.addr = alloca i32, align 4
  %new_data = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_capacity, ptr %new_capacity.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_capacity.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.17, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sle i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %new_capacity.addr, align 4
  %conv = sext i32 %2 to i64
  %mul = mul i64 %conv, 120
  %call = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef %mul)
  store ptr %call, ptr %new_data, align 8
  %Data = getelementptr inbounds %struct.ImVector.17, ptr %this1, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.then2, label %if.end7

if.then2:                                         ; preds = %if.end
  %4 = load ptr, ptr %new_data, align 8
  %Data3 = getelementptr inbounds %struct.ImVector.17, ptr %this1, i32 0, i32 2
  %5 = load ptr, ptr %Data3, align 8
  %Size = getelementptr inbounds %struct.ImVector.17, ptr %this1, i32 0, i32 0
  %6 = load i32, ptr %Size, align 8
  %conv4 = sext i32 %6 to i64
  %mul5 = mul i64 %conv4, 120
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %4, ptr align 8 %5, i64 %mul5, i1 false)
  %Data6 = getelementptr inbounds %struct.ImVector.17, ptr %this1, i32 0, i32 2
  %7 = load ptr, ptr %Data6, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %7)
  br label %if.end7

if.end7:                                          ; preds = %if.then2, %if.end
  %8 = load ptr, ptr %new_data, align 8
  %Data8 = getelementptr inbounds %struct.ImVector.17, ptr %this1, i32 0, i32 2
  store ptr %8, ptr %Data8, align 8
  %9 = load i32, ptr %new_capacity.addr, align 4
  %Capacity9 = getelementptr inbounds %struct.ImVector.17, ptr %this1, i32 0, i32 1
  store i32 %9, ptr %Capacity9, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i32 @_ZNK8ImVectorI18ImGuiTableTempDataE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %sz) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %sz.addr = alloca i32, align 4
  %new_capacity = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %sz, ptr %sz.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.17, ptr %this1, i32 0, i32 1
  %0 = load i32, ptr %Capacity, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %Capacity2 = getelementptr inbounds %struct.ImVector.17, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity2, align 4
  %Capacity3 = getelementptr inbounds %struct.ImVector.17, ptr %this1, i32 0, i32 1
  %2 = load i32, ptr %Capacity3, align 4
  %div = sdiv i32 %2, 2
  %add = add nsw i32 %1, %div
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %add, %cond.true ], [ 8, %cond.false ]
  store i32 %cond, ptr %new_capacity, align 4
  %3 = load i32, ptr %new_capacity, align 4
  %4 = load i32, ptr %sz.addr, align 4
  %cmp = icmp sgt i32 %3, %4
  br i1 %cmp, label %cond.true4, label %cond.false5

cond.true4:                                       ; preds = %cond.end
  %5 = load i32, ptr %new_capacity, align 4
  br label %cond.end6

cond.false5:                                      ; preds = %cond.end
  %6 = load i32, ptr %sz.addr, align 4
  br label %cond.end6

cond.end6:                                        ; preds = %cond.false5, %cond.true4
  %cond7 = phi i32 [ %5, %cond.true4 ], [ %6, %cond.false5 ]
  ret i32 %cond7
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI22ImGuiTableInstanceDataE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_capacity) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_capacity.addr = alloca i32, align 4
  %new_data = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_capacity, ptr %new_capacity.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_capacity.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.38, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sle i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %new_capacity.addr, align 4
  %conv = sext i32 %2 to i64
  %mul = mul i64 %conv, 24
  %call = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef %mul)
  store ptr %call, ptr %new_data, align 8
  %Data = getelementptr inbounds %struct.ImVector.38, ptr %this1, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.then2, label %if.end7

if.then2:                                         ; preds = %if.end
  %4 = load ptr, ptr %new_data, align 8
  %Data3 = getelementptr inbounds %struct.ImVector.38, ptr %this1, i32 0, i32 2
  %5 = load ptr, ptr %Data3, align 8
  %Size = getelementptr inbounds %struct.ImVector.38, ptr %this1, i32 0, i32 0
  %6 = load i32, ptr %Size, align 8
  %conv4 = sext i32 %6 to i64
  %mul5 = mul i64 %conv4, 24
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %4, ptr align 4 %5, i64 %mul5, i1 false)
  %Data6 = getelementptr inbounds %struct.ImVector.38, ptr %this1, i32 0, i32 2
  %7 = load ptr, ptr %Data6, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %7)
  br label %if.end7

if.end7:                                          ; preds = %if.then2, %if.end
  %8 = load ptr, ptr %new_data, align 8
  %Data8 = getelementptr inbounds %struct.ImVector.38, ptr %this1, i32 0, i32 2
  store ptr %8, ptr %Data8, align 8
  %9 = load i32, ptr %new_capacity.addr, align 4
  %Capacity9 = getelementptr inbounds %struct.ImVector.38, ptr %this1, i32 0, i32 1
  store i32 %9, ptr %Capacity9, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i32 @_ZNK8ImVectorI22ImGuiTableInstanceDataE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %sz) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %sz.addr = alloca i32, align 4
  %new_capacity = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %sz, ptr %sz.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.38, ptr %this1, i32 0, i32 1
  %0 = load i32, ptr %Capacity, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %Capacity2 = getelementptr inbounds %struct.ImVector.38, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity2, align 4
  %Capacity3 = getelementptr inbounds %struct.ImVector.38, ptr %this1, i32 0, i32 1
  %2 = load i32, ptr %Capacity3, align 4
  %div = sdiv i32 %2, 2
  %add = add nsw i32 %1, %div
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %add, %cond.true ], [ 8, %cond.false ]
  store i32 %cond, ptr %new_capacity, align 4
  %3 = load i32, ptr %new_capacity, align 4
  %4 = load i32, ptr %sz.addr, align 4
  %cmp = icmp sgt i32 %3, %4
  br i1 %cmp, label %cond.true4, label %cond.false5

cond.true4:                                       ; preds = %cond.end
  %5 = load i32, ptr %new_capacity, align 4
  br label %cond.end6

cond.false5:                                      ; preds = %cond.end
  %6 = load i32, ptr %sz.addr, align 4
  br label %cond.end6

cond.end6:                                        ; preds = %cond.false5, %cond.true4
  %cond7 = phi i32 [ %5, %cond.true4 ], [ %6, %cond.false5 ]
  ret i32 %cond7
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorIfE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_capacity) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_capacity.addr = alloca i32, align 4
  %new_data = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_capacity, ptr %new_capacity.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_capacity.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.19, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sle i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %new_capacity.addr, align 4
  %conv = sext i32 %2 to i64
  %mul = mul i64 %conv, 4
  %call = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef %mul)
  store ptr %call, ptr %new_data, align 8
  %Data = getelementptr inbounds %struct.ImVector.19, ptr %this1, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.then2, label %if.end7

if.then2:                                         ; preds = %if.end
  %4 = load ptr, ptr %new_data, align 8
  %Data3 = getelementptr inbounds %struct.ImVector.19, ptr %this1, i32 0, i32 2
  %5 = load ptr, ptr %Data3, align 8
  %Size = getelementptr inbounds %struct.ImVector.19, ptr %this1, i32 0, i32 0
  %6 = load i32, ptr %Size, align 8
  %conv4 = sext i32 %6 to i64
  %mul5 = mul i64 %conv4, 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %4, ptr align 4 %5, i64 %mul5, i1 false)
  %Data6 = getelementptr inbounds %struct.ImVector.19, ptr %this1, i32 0, i32 2
  %7 = load ptr, ptr %Data6, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %7)
  br label %if.end7

if.end7:                                          ; preds = %if.then2, %if.end
  %8 = load ptr, ptr %new_data, align 8
  %Data8 = getelementptr inbounds %struct.ImVector.19, ptr %this1, i32 0, i32 2
  store ptr %8, ptr %Data8, align 8
  %9 = load i32, ptr %new_capacity.addr, align 4
  %Capacity9 = getelementptr inbounds %struct.ImVector.19, ptr %this1, i32 0, i32 1
  store i32 %9, ptr %Capacity9, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i32 @_ZNK8ImVectorIfE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %sz) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %sz.addr = alloca i32, align 4
  %new_capacity = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %sz, ptr %sz.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.19, ptr %this1, i32 0, i32 1
  %0 = load i32, ptr %Capacity, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %Capacity2 = getelementptr inbounds %struct.ImVector.19, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity2, align 4
  %Capacity3 = getelementptr inbounds %struct.ImVector.19, ptr %this1, i32 0, i32 1
  %2 = load i32, ptr %Capacity3, align 4
  %div = sdiv i32 %2, 2
  %add = add nsw i32 %1, %div
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %add, %cond.true ], [ 8, %cond.false ]
  store i32 %cond, ptr %new_capacity, align 4
  %3 = load i32, ptr %new_capacity, align 4
  %4 = load i32, ptr %sz.addr, align 4
  %cmp = icmp sgt i32 %3, %4
  br i1 %cmp, label %cond.true4, label %cond.false5

cond.true4:                                       ; preds = %cond.end
  %5 = load i32, ptr %new_capacity, align 4
  br label %cond.end6

cond.false5:                                      ; preds = %cond.end
  %6 = load i32, ptr %sz.addr, align 4
  br label %cond.end6

cond.end6:                                        ; preds = %cond.false5, %cond.true4
  %cond7 = phi i32 [ %5, %cond.true4 ], [ %6, %cond.false5 ]
  ret i32 %cond7
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i32 @_ZNK8ImVectorIcE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %sz) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %sz.addr = alloca i32, align 4
  %new_capacity = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %sz, ptr %sz.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.25, ptr %this1, i32 0, i32 1
  %0 = load i32, ptr %Capacity, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %Capacity2 = getelementptr inbounds %struct.ImVector.25, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity2, align 4
  %Capacity3 = getelementptr inbounds %struct.ImVector.25, ptr %this1, i32 0, i32 1
  %2 = load i32, ptr %Capacity3, align 4
  %div = sdiv i32 %2, 2
  %add = add nsw i32 %1, %div
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %add, %cond.true ], [ 8, %cond.false ]
  store i32 %cond, ptr %new_capacity, align 4
  %3 = load i32, ptr %new_capacity, align 4
  %4 = load i32, ptr %sz.addr, align 4
  %cmp = icmp sgt i32 %3, %4
  br i1 %cmp, label %cond.true4, label %cond.false5

cond.true4:                                       ; preds = %cond.end
  %5 = load i32, ptr %new_capacity, align 4
  br label %cond.end6

cond.false5:                                      ; preds = %cond.end
  %6 = load i32, ptr %sz.addr, align 4
  br label %cond.end6

cond.end6:                                        ; preds = %cond.false5, %cond.true4
  %cond7 = phi i32 [ %5, %cond.true4 ], [ %6, %cond.false5 ]
  ret i32 %cond7
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN6ImSpanI16ImGuiTableColumnE3setEPS0_S2_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %data, ptr noundef %data_end) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %data.addr = alloca ptr, align 8
  %data_end.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %data, ptr %data.addr, align 8
  store ptr %data_end, ptr %data_end.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %data.addr, align 8
  %Data = getelementptr inbounds %struct.ImSpan, ptr %this1, i32 0, i32 0
  store ptr %0, ptr %Data, align 8
  %1 = load ptr, ptr %data_end.addr, align 8
  %DataEnd = getelementptr inbounds %struct.ImSpan, ptr %this1, i32 0, i32 1
  store ptr %1, ptr %DataEnd, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef ptr @_ZN15ImSpanAllocatorILi6EE13GetSpanPtrEndEi(ptr noundef nonnull align 8 dereferenceable(64) %this, i32 noundef %n) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %BasePtr = getelementptr inbounds %struct.ImSpanAllocator, ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %BasePtr, align 8
  %Offsets = getelementptr inbounds %struct.ImSpanAllocator, ptr %this1, i32 0, i32 3
  %1 = load i32, ptr %n.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds [6 x i32], ptr %Offsets, i64 0, i64 %idxprom
  %2 = load i32, ptr %arrayidx, align 4
  %idx.ext = sext i32 %2 to i64
  %add.ptr = getelementptr inbounds i8, ptr %0, i64 %idx.ext
  %Sizes = getelementptr inbounds %struct.ImSpanAllocator, ptr %this1, i32 0, i32 4
  %3 = load i32, ptr %n.addr, align 4
  %idxprom2 = sext i32 %3 to i64
  %arrayidx3 = getelementptr inbounds [6 x i32], ptr %Sizes, i64 0, i64 %idxprom2
  %4 = load i32, ptr %arrayidx3, align 4
  %idx.ext4 = sext i32 %4 to i64
  %add.ptr5 = getelementptr inbounds i8, ptr %add.ptr, i64 %idx.ext4
  ret ptr %add.ptr5
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN6ImSpanIsE3setEPsS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %data, ptr noundef %data_end) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %data.addr = alloca ptr, align 8
  %data_end.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %data, ptr %data.addr, align 8
  store ptr %data_end, ptr %data_end.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %data.addr, align 8
  %Data = getelementptr inbounds %struct.ImSpan.36, ptr %this1, i32 0, i32 0
  store ptr %0, ptr %Data, align 8
  %1 = load ptr, ptr %data_end.addr, align 8
  %DataEnd = getelementptr inbounds %struct.ImSpan.36, ptr %this1, i32 0, i32 1
  store ptr %1, ptr %DataEnd, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN6ImSpanI18ImGuiTableCellDataE3setEPS0_S2_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %data, ptr noundef %data_end) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %data.addr = alloca ptr, align 8
  %data_end.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %data, ptr %data.addr, align 8
  store ptr %data_end, ptr %data_end.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %data.addr, align 8
  %Data = getelementptr inbounds %struct.ImSpan.37, ptr %this1, i32 0, i32 0
  store ptr %0, ptr %Data, align 8
  %1 = load ptr, ptr %data_end.addr, align 8
  %DataEnd = getelementptr inbounds %struct.ImSpan.37, ptr %this1, i32 0, i32 1
  store ptr %1, ptr %DataEnd, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI13ImDrawChannelE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_capacity) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_capacity.addr = alloca i32, align 4
  %new_data = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_capacity, ptr %new_capacity.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_capacity.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.20, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sle i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %new_capacity.addr, align 4
  %conv = sext i32 %2 to i64
  %mul = mul i64 %conv, 32
  %call = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef %mul)
  store ptr %call, ptr %new_data, align 8
  %Data = getelementptr inbounds %struct.ImVector.20, ptr %this1, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.then2, label %if.end7

if.then2:                                         ; preds = %if.end
  %4 = load ptr, ptr %new_data, align 8
  %Data3 = getelementptr inbounds %struct.ImVector.20, ptr %this1, i32 0, i32 2
  %5 = load ptr, ptr %Data3, align 8
  %Size = getelementptr inbounds %struct.ImVector.20, ptr %this1, i32 0, i32 0
  %6 = load i32, ptr %Size, align 8
  %conv4 = sext i32 %6 to i64
  %mul5 = mul i64 %conv4, 32
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %4, ptr align 8 %5, i64 %mul5, i1 false)
  %Data6 = getelementptr inbounds %struct.ImVector.20, ptr %this1, i32 0, i32 2
  %7 = load ptr, ptr %Data6, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %7)
  br label %if.end7

if.end7:                                          ; preds = %if.then2, %if.end
  %8 = load ptr, ptr %new_data, align 8
  %Data8 = getelementptr inbounds %struct.ImVector.20, ptr %this1, i32 0, i32 2
  store ptr %8, ptr %Data8, align 8
  %9 = load i32, ptr %new_capacity.addr, align 4
  %Capacity9 = getelementptr inbounds %struct.ImVector.20, ptr %this1, i32 0, i32 1
  store i32 %9, ptr %Capacity9, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i32 @_ZNK8ImVectorI13ImDrawChannelE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %sz) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %sz.addr = alloca i32, align 4
  %new_capacity = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %sz, ptr %sz.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.20, ptr %this1, i32 0, i32 1
  %0 = load i32, ptr %Capacity, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %Capacity2 = getelementptr inbounds %struct.ImVector.20, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity2, align 4
  %Capacity3 = getelementptr inbounds %struct.ImVector.20, ptr %this1, i32 0, i32 1
  %2 = load i32, ptr %Capacity3, align 4
  %div = sdiv i32 %2, 2
  %add = add nsw i32 %1, %div
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %add, %cond.true ], [ 8, %cond.false ]
  store i32 %cond, ptr %new_capacity, align 4
  %3 = load i32, ptr %new_capacity, align 4
  %4 = load i32, ptr %sz.addr, align 4
  %cmp = icmp sgt i32 %3, %4
  br i1 %cmp, label %cond.true4, label %cond.false5

cond.true4:                                       ; preds = %cond.end
  %5 = load i32, ptr %new_capacity, align 4
  br label %cond.end6

cond.false5:                                      ; preds = %cond.end
  %6 = load i32, ptr %sz.addr, align 4
  br label %cond.end6

cond.end6:                                        ; preds = %cond.false5, %cond.true4
  %cond7 = phi i32 [ %5, %cond.true4 ], [ %6, %cond.false5 ]
  ret i32 %cond7
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI25ImGuiTableColumnSortSpecsE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_capacity) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_capacity.addr = alloca i32, align 4
  %new_data = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_capacity, ptr %new_capacity.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_capacity.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.39, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sle i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %new_capacity.addr, align 4
  %conv = sext i32 %2 to i64
  %mul = mul i64 %conv, 12
  %call = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef %mul)
  store ptr %call, ptr %new_data, align 8
  %Data = getelementptr inbounds %struct.ImVector.39, ptr %this1, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.then2, label %if.end7

if.then2:                                         ; preds = %if.end
  %4 = load ptr, ptr %new_data, align 8
  %Data3 = getelementptr inbounds %struct.ImVector.39, ptr %this1, i32 0, i32 2
  %5 = load ptr, ptr %Data3, align 8
  %Size = getelementptr inbounds %struct.ImVector.39, ptr %this1, i32 0, i32 0
  %6 = load i32, ptr %Size, align 8
  %conv4 = sext i32 %6 to i64
  %mul5 = mul i64 %conv4, 12
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %4, ptr align 4 %5, i64 %mul5, i1 false)
  %Data6 = getelementptr inbounds %struct.ImVector.39, ptr %this1, i32 0, i32 2
  %7 = load ptr, ptr %Data6, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %7)
  br label %if.end7

if.end7:                                          ; preds = %if.then2, %if.end
  %8 = load ptr, ptr %new_data, align 8
  %Data8 = getelementptr inbounds %struct.ImVector.39, ptr %this1, i32 0, i32 2
  store ptr %8, ptr %Data8, align 8
  %9 = load i32, ptr %new_capacity.addr, align 4
  %Capacity9 = getelementptr inbounds %struct.ImVector.39, ptr %this1, i32 0, i32 1
  store i32 %9, ptr %Capacity9, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i32 @_ZNK8ImVectorI25ImGuiTableColumnSortSpecsE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %sz) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %sz.addr = alloca i32, align 4
  %new_capacity = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %sz, ptr %sz.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.39, ptr %this1, i32 0, i32 1
  %0 = load i32, ptr %Capacity, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %Capacity2 = getelementptr inbounds %struct.ImVector.39, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity2, align 4
  %Capacity3 = getelementptr inbounds %struct.ImVector.39, ptr %this1, i32 0, i32 1
  %2 = load i32, ptr %Capacity3, align 4
  %div = sdiv i32 %2, 2
  %add = add nsw i32 %1, %div
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %add, %cond.true ], [ 8, %cond.false ]
  store i32 %cond, ptr %new_capacity, align 4
  %3 = load i32, ptr %new_capacity, align 4
  %4 = load i32, ptr %sz.addr, align 4
  %cmp = icmp sgt i32 %3, %4
  br i1 %cmp, label %cond.true4, label %cond.false5

cond.true4:                                       ; preds = %cond.end
  %5 = load i32, ptr %new_capacity, align 4
  br label %cond.end6

cond.false5:                                      ; preds = %cond.end
  %6 = load i32, ptr %sz.addr, align 4
  br label %cond.end6

cond.end6:                                        ; preds = %cond.false5, %cond.true4
  %cond7 = phi i32 [ %5, %cond.true4 ], [ %6, %cond.false5 ]
  ret i32 %cond7
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i32 @_ZN13ImChunkStreamI18ImGuiTableSettingsE10chunk_sizeEPKS0_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %p) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %arrayidx = getelementptr inbounds i32, ptr %0, i64 -1
  %1 = load i32, ptr %arrayidx, align 4
  ret i32 %1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef ptr @_ZN13ImChunkStreamI18ImGuiTableSettingsE3endEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Buf = getelementptr inbounds %struct.ImChunkStream.28, ptr %this1, i32 0, i32 0
  %Data = getelementptr inbounds %struct.ImVector.25, ptr %Buf, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %Buf2 = getelementptr inbounds %struct.ImChunkStream.28, ptr %this1, i32 0, i32 0
  %Size = getelementptr inbounds %struct.ImVector.25, ptr %Buf2, i32 0, i32 0
  %1 = load i32, ptr %Size, align 8
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr inbounds i8, ptr %0, i64 %idx.ext
  ret ptr %add.ptr
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN6ImPoolI10ImGuiTableE6RemoveEji(ptr noundef nonnull align 8 dereferenceable(40) %this, i32 noundef %key, i32 noundef %idx) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %key.addr = alloca i32, align 4
  %idx.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %key, ptr %key.addr, align 4
  store i32 %idx, ptr %idx.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Buf = getelementptr inbounds %struct.ImPool, ptr %this1, i32 0, i32 0
  %0 = load i32, ptr %idx.addr, align 4
  %call = call noundef nonnull align 8 dereferenceable(586) ptr @_ZN8ImVectorI10ImGuiTableEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Buf, i32 noundef %0)
  call void @_ZN10ImGuiTableD2Ev(ptr noundef nonnull align 8 dereferenceable(586) %call) #10
  %FreeIdx = getelementptr inbounds %struct.ImPool, ptr %this1, i32 0, i32 2
  %1 = load i32, ptr %FreeIdx, align 8
  %Buf2 = getelementptr inbounds %struct.ImPool, ptr %this1, i32 0, i32 0
  %2 = load i32, ptr %idx.addr, align 4
  %call3 = call noundef nonnull align 8 dereferenceable(586) ptr @_ZN8ImVectorI10ImGuiTableEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Buf2, i32 noundef %2)
  store i32 %1, ptr %call3, align 4
  %3 = load i32, ptr %idx.addr, align 4
  %FreeIdx4 = getelementptr inbounds %struct.ImPool, ptr %this1, i32 0, i32 2
  store i32 %3, ptr %FreeIdx4, align 8
  %Map = getelementptr inbounds %struct.ImPool, ptr %this1, i32 0, i32 1
  %4 = load i32, ptr %key.addr, align 4
  call void @_ZN12ImGuiStorage6SetIntEji(ptr noundef nonnull align 8 dereferenceable(16) %Map, i32 noundef %4, i32 noundef -1)
  %AliveCount = getelementptr inbounds %struct.ImPool, ptr %this1, i32 0, i32 3
  %5 = load i32, ptr %AliveCount, align 4
  %dec = add nsw i32 %5, -1
  store i32 %dec, ptr %AliveCount, align 4
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN10ImGuiTableD2Ev(ptr noundef nonnull align 8 dereferenceable(586) %this) unnamed_addr #3 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %RawData = getelementptr inbounds %struct.ImGuiTable, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %RawData, align 8
  invoke void @_ZN5ImGui7MemFreeEPv(ptr noundef %0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %SortSpecsMulti = getelementptr inbounds %struct.ImGuiTable, ptr %this1, i32 0, i32 63
  call void @_ZN8ImVectorI25ImGuiTableColumnSortSpecsED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %SortSpecsMulti) #10
  %InstanceDataExtra = getelementptr inbounds %struct.ImGuiTable, ptr %this1, i32 0, i32 60
  call void @_ZN8ImVectorI22ImGuiTableInstanceDataED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %InstanceDataExtra) #10
  %ColumnsNames = getelementptr inbounds %struct.ImGuiTable, ptr %this1, i32 0, i32 57
  call void @_ZN15ImGuiTextBufferD2Ev(ptr noundef nonnull align 8 dereferenceable(16) %ColumnsNames) #10
  ret void

terminate.lpad:                                   ; preds = %entry
  %1 = landingpad { ptr, i32 }
          catch ptr null
  %2 = extractvalue { ptr, i32 } %1, 0
  call void @__clang_call_terminate(ptr %2) #12
  unreachable
}

declare void @_ZN12ImGuiStorage6SetIntEji(ptr noundef nonnull align 8 dereferenceable(16), i32 noundef, i32 noundef) #1

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorIcE4swapERS0_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %rhs) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  %rhs_size = alloca i32, align 4
  %rhs_cap = alloca i32, align 4
  %rhs_data = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %rhs.addr, align 8
  %Size = getelementptr inbounds %struct.ImVector.25, ptr %0, i32 0, i32 0
  %1 = load i32, ptr %Size, align 8
  store i32 %1, ptr %rhs_size, align 4
  %Size2 = getelementptr inbounds %struct.ImVector.25, ptr %this1, i32 0, i32 0
  %2 = load i32, ptr %Size2, align 8
  %3 = load ptr, ptr %rhs.addr, align 8
  %Size3 = getelementptr inbounds %struct.ImVector.25, ptr %3, i32 0, i32 0
  store i32 %2, ptr %Size3, align 8
  %4 = load i32, ptr %rhs_size, align 4
  %Size4 = getelementptr inbounds %struct.ImVector.25, ptr %this1, i32 0, i32 0
  store i32 %4, ptr %Size4, align 8
  %5 = load ptr, ptr %rhs.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.25, ptr %5, i32 0, i32 1
  %6 = load i32, ptr %Capacity, align 4
  store i32 %6, ptr %rhs_cap, align 4
  %Capacity5 = getelementptr inbounds %struct.ImVector.25, ptr %this1, i32 0, i32 1
  %7 = load i32, ptr %Capacity5, align 4
  %8 = load ptr, ptr %rhs.addr, align 8
  %Capacity6 = getelementptr inbounds %struct.ImVector.25, ptr %8, i32 0, i32 1
  store i32 %7, ptr %Capacity6, align 4
  %9 = load i32, ptr %rhs_cap, align 4
  %Capacity7 = getelementptr inbounds %struct.ImVector.25, ptr %this1, i32 0, i32 1
  store i32 %9, ptr %Capacity7, align 4
  %10 = load ptr, ptr %rhs.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.25, ptr %10, i32 0, i32 2
  %11 = load ptr, ptr %Data, align 8
  store ptr %11, ptr %rhs_data, align 8
  %Data8 = getelementptr inbounds %struct.ImVector.25, ptr %this1, i32 0, i32 2
  %12 = load ptr, ptr %Data8, align 8
  %13 = load ptr, ptr %rhs.addr, align 8
  %Data9 = getelementptr inbounds %struct.ImVector.25, ptr %13, i32 0, i32 2
  store ptr %12, ptr %Data9, align 8
  %14 = load ptr, ptr %rhs_data, align 8
  %Data10 = getelementptr inbounds %struct.ImVector.25, ptr %this1, i32 0, i32 2
  store ptr %14, ptr %Data10, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI15ImGuiOldColumnsE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_capacity) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_capacity.addr = alloca i32, align 4
  %new_data = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_capacity, ptr %new_capacity.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_capacity.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.31, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sle i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %new_capacity.addr, align 4
  %conv = sext i32 %2 to i64
  %mul = mul i64 %conv, 136
  %call = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef %mul)
  store ptr %call, ptr %new_data, align 8
  %Data = getelementptr inbounds %struct.ImVector.31, ptr %this1, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.then2, label %if.end7

if.then2:                                         ; preds = %if.end
  %4 = load ptr, ptr %new_data, align 8
  %Data3 = getelementptr inbounds %struct.ImVector.31, ptr %this1, i32 0, i32 2
  %5 = load ptr, ptr %Data3, align 8
  %Size = getelementptr inbounds %struct.ImVector.31, ptr %this1, i32 0, i32 0
  %6 = load i32, ptr %Size, align 8
  %conv4 = sext i32 %6 to i64
  %mul5 = mul i64 %conv4, 136
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %4, ptr align 8 %5, i64 %mul5, i1 false)
  %Data6 = getelementptr inbounds %struct.ImVector.31, ptr %this1, i32 0, i32 2
  %7 = load ptr, ptr %Data6, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %7)
  br label %if.end7

if.end7:                                          ; preds = %if.then2, %if.end
  %8 = load ptr, ptr %new_data, align 8
  %Data8 = getelementptr inbounds %struct.ImVector.31, ptr %this1, i32 0, i32 2
  store ptr %8, ptr %Data8, align 8
  %9 = load i32, ptr %new_capacity.addr, align 4
  %Capacity9 = getelementptr inbounds %struct.ImVector.31, ptr %this1, i32 0, i32 1
  store i32 %9, ptr %Capacity9, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i32 @_ZNK8ImVectorI15ImGuiOldColumnsE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %sz) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %sz.addr = alloca i32, align 4
  %new_capacity = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %sz, ptr %sz.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.31, ptr %this1, i32 0, i32 1
  %0 = load i32, ptr %Capacity, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %Capacity2 = getelementptr inbounds %struct.ImVector.31, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity2, align 4
  %Capacity3 = getelementptr inbounds %struct.ImVector.31, ptr %this1, i32 0, i32 1
  %2 = load i32, ptr %Capacity3, align 4
  %div = sdiv i32 %2, 2
  %add = add nsw i32 %1, %div
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %add, %cond.true ], [ 8, %cond.false ]
  store i32 %cond, ptr %new_capacity, align 4
  %3 = load i32, ptr %new_capacity, align 4
  %4 = load i32, ptr %sz.addr, align 4
  %cmp = icmp sgt i32 %3, %4
  br i1 %cmp, label %cond.true4, label %cond.false5

cond.true4:                                       ; preds = %cond.end
  %5 = load i32, ptr %new_capacity, align 4
  br label %cond.end6

cond.false5:                                      ; preds = %cond.end
  %6 = load i32, ptr %sz.addr, align 4
  br label %cond.end6

cond.end6:                                        ; preds = %cond.false5, %cond.true4
  %cond7 = phi i32 [ %5, %cond.true4 ], [ %6, %cond.false5 ]
  ret i32 %cond7
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i32 @_ZNK8ImVectorI18ImGuiOldColumnDataE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %sz) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %sz.addr = alloca i32, align 4
  %new_capacity = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %sz, ptr %sz.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.40, ptr %this1, i32 0, i32 1
  %0 = load i32, ptr %Capacity, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %Capacity2 = getelementptr inbounds %struct.ImVector.40, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity2, align 4
  %Capacity3 = getelementptr inbounds %struct.ImVector.40, ptr %this1, i32 0, i32 1
  %2 = load i32, ptr %Capacity3, align 4
  %div = sdiv i32 %2, 2
  %add = add nsw i32 %1, %div
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %add, %cond.true ], [ 8, %cond.false ]
  store i32 %cond, ptr %new_capacity, align 4
  %3 = load i32, ptr %new_capacity, align 4
  %4 = load i32, ptr %sz.addr, align 4
  %cmp = icmp sgt i32 %3, %4
  br i1 %cmp, label %cond.true4, label %cond.false5

cond.true4:                                       ; preds = %cond.end
  %5 = load i32, ptr %new_capacity, align 4
  br label %cond.end6

cond.false5:                                      ; preds = %cond.end
  %6 = load i32, ptr %sz.addr, align 4
  br label %cond.end6

cond.end6:                                        ; preds = %cond.false5, %cond.true4
  %cond7 = phi i32 [ %5, %cond.true4 ], [ %6, %cond.false5 ]
  ret i32 %cond7
}

attributes #0 = { mustprogress uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #2 = { mustprogress uwtable "frame-pointer"="all" "min-legal-vector-width"="64" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { mustprogress nounwind uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #4 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #5 = { nocallback nofree nounwind willreturn memory(argmem: write) }
attributes #6 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #7 = { nounwind willreturn memory(read) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #8 = { nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #9 = { noreturn nounwind uwtable "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #10 = { nounwind }
attributes #11 = { nounwind willreturn memory(read) }
attributes #12 = { noreturn nounwind }

!llvm.module.flags = !{!0, !1, !2, !3}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"uwtable", i32 2}
!3 = !{i32 7, !"frame-pointer", i32 2}
!4 = distinct !{!4, !5}
!5 = !{!"llvm.loop.mustprogress"}
!6 = distinct !{!6, !5}
!7 = distinct !{!7, !5}
!8 = distinct !{!8, !5}
!9 = distinct !{!9, !5}
!10 = distinct !{!10, !5}
!11 = distinct !{!11, !5}
!12 = distinct !{!12, !5}
!13 = distinct !{!13, !5}
!14 = distinct !{!14, !5}
!15 = distinct !{!15, !5}
!16 = distinct !{!16, !5}
!17 = distinct !{!17, !5}
!18 = distinct !{!18, !5}
!19 = distinct !{!19, !5}
!20 = distinct !{!20, !5}
!21 = distinct !{!21, !5}
!22 = distinct !{!22, !5}
!23 = distinct !{!23, !5}
!24 = distinct !{!24, !5}
!25 = distinct !{!25, !5}
!26 = distinct !{!26, !5}
!27 = distinct !{!27, !5}
!28 = distinct !{!28, !5}
!29 = distinct !{!29, !5}
!30 = distinct !{!30, !5}
!31 = distinct !{!31, !5}
!32 = distinct !{!32, !5}
!33 = distinct !{!33, !5}
!34 = distinct !{!34, !5}
!35 = distinct !{!35, !5}
!36 = distinct !{!36, !5}
!37 = distinct !{!37, !5}
!38 = distinct !{!38, !5}
!39 = distinct !{!39, !5}
!40 = distinct !{!40, !5}
!41 = distinct !{!41, !5}
!42 = distinct !{!42, !5}
!43 = distinct !{!43, !5}
!44 = distinct !{!44, !5}
!45 = distinct !{!45, !5}
!46 = distinct !{!46, !5}
!47 = distinct !{!47, !5}
!48 = distinct !{!48, !5}
!49 = distinct !{!49, !5}
!50 = distinct !{!50, !5}
!51 = distinct !{!51, !5}
!52 = distinct !{!52, !5}
!53 = distinct !{!53, !5}
!54 = distinct !{!54, !5}
!55 = distinct !{!55, !5}
!56 = distinct !{!56, !5}
!57 = distinct !{!57, !5}
!58 = distinct !{!58, !5}
!59 = distinct !{!59, !5}
!60 = distinct !{!60, !5}
!61 = distinct !{!61, !5}
!62 = distinct !{!62, !5}
!63 = distinct !{!63, !5}
!64 = distinct !{!64, !5}
!65 = distinct !{!65, !5}
!66 = distinct !{!66, !5}
!67 = distinct !{!67, !5}
!68 = distinct !{!68, !5}
!69 = distinct !{!69, !5}
!70 = distinct !{!70, !5}
!71 = distinct !{!71, !5}
!72 = distinct !{!72, !5}
!73 = distinct !{!73, !5}
