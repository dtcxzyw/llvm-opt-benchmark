; ModuleID = 'bench/luajit/original/minilua.ll'
source_filename = "bench/luajit/original/minilua.ll"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.luaL_Reg = type { ptr, ptr }
%struct.lua_TValue = type { %union.Value, i32 }
%union.Value = type { ptr }
%struct.Node = type { %struct.lua_TValue, %union.TKey }
%union.TKey = type { %struct.anon.2 }
%struct.anon.2 = type { %union.Value, i32, ptr }
%struct.anon.5 = type { i8, i8 }
%struct.CallS = type { ptr, i32 }
%struct.LG = type { %struct.lua_State, %struct.global_State }
%struct.lua_State = type { ptr, i8, i8, i8, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i32, i32, i16, i16, i8, i8, i32, i32, ptr, %struct.lua_TValue, %struct.lua_TValue, ptr, ptr, ptr, i64 }
%struct.global_State = type { %struct.stringtable, ptr, ptr, i8, i8, i32, ptr, ptr, ptr, ptr, ptr, ptr, %struct.Mbuffer, i64, i64, i64, i64, i32, i32, ptr, %struct.lua_TValue, ptr, %struct.UpVal, [9 x ptr], [17 x ptr] }
%struct.stringtable = type { ptr, i32, i32 }
%struct.Mbuffer = type { ptr, i64, i64 }
%struct.UpVal = type { ptr, i8, i8, ptr, %union.anon }
%union.anon = type { %struct.lua_TValue }
%struct.Table = type { ptr, i8, i8, i8, i8, ptr, ptr, ptr, ptr, ptr, i32 }
%struct.GCheader = type { ptr, i8, i8 }
%struct.CallInfo = type { ptr, ptr, ptr, ptr, i32, i32 }
%struct.CClosure = type { ptr, i8, i8, i8, i8, ptr, ptr, ptr, [1 x %struct.lua_TValue] }
%struct.SParser = type { ptr, %struct.Mbuffer, ptr }
%struct.Zio = type { i64, ptr, ptr, ptr, ptr }
%struct.LoadF = type { i32, ptr, [8192 x i8] }
%struct.anon.0 = type { ptr, i8, i8, i8, i32, i64 }
%union.TString = type { %struct.anon.0 }
%struct.lua_longjmp = type { ptr, [1 x %struct.__jmp_buf_tag], i32 }
%struct.__jmp_buf_tag = type { [8 x i64], i32, %struct.__sigset_t }
%struct.__sigset_t = type { [16 x i64] }
%struct.anon.1 = type { ptr, i8, i8, ptr, ptr, i64 }
%struct.Proto = type { ptr, i8, i8, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i32, i32, i32, i32, i32, i32, i32, i32, ptr, i8, i8, i8, i8 }
%struct.__va_list_tag = type { i32, i32, ptr, ptr }
%struct.LClosure = type { ptr, i8, i8, i8, i8, ptr, ptr, ptr, [1 x ptr] }
%struct.LocVar = type { ptr, i32, i32 }
%struct.LoadS = type { ptr, i64 }
%struct.lua_Debug = type { i32, ptr, ptr, ptr, ptr, i32, i32, i32, i32, [60 x i8], i32 }
%struct.LexState = type { i32, i32, i32, %struct.Token, %struct.Token, ptr, ptr, ptr, ptr, ptr, i8 }
%struct.Token = type { i32, %union.SemInfo }
%union.SemInfo = type { double }
%struct.FuncState = type { ptr, ptr, ptr, ptr, ptr, ptr, i32, i32, i32, i32, i32, i32, i16, i8, [60 x %struct.upvaldesc], [200 x i16] }
%struct.upvaldesc = type { i8, i8 }
%struct.expdesc = type { i32, %union.anon.3, i32, i32 }
%union.anon.3 = type { double }
%struct.BlockCnt = type { ptr, i32, i8, i8, i8 }
%struct.LHS_assign = type { ptr, %struct.expdesc }
%struct.ConsControl = type { %struct.expdesc, ptr, i32, i32, i32 }
%union.Udata = type { %struct.anon.1 }
%struct.luaL_Buffer = type { ptr, i32, ptr, [8192 x i8] }
%struct.MatchState = type { ptr, ptr, ptr, i32, [32 x %struct.anon.6] }
%struct.anon.6 = type { ptr, i64 }

@_CRT_glob = dso_local local_unnamed_addr global i32 0, align 4
@.str = private unnamed_addr constant [4 x i8] c"bit\00", align 1
@bitlib = internal constant [13 x %struct.luaL_Reg] [%struct.luaL_Reg { ptr @.str.257, ptr @tobit }, %struct.luaL_Reg { ptr @.str.258, ptr @bnot }, %struct.luaL_Reg { ptr @.str.259, ptr @band }, %struct.luaL_Reg { ptr @.str.260, ptr @bor }, %struct.luaL_Reg { ptr @.str.261, ptr @bxor }, %struct.luaL_Reg { ptr @.str.262, ptr @lshift }, %struct.luaL_Reg { ptr @.str.263, ptr @rshift }, %struct.luaL_Reg { ptr @.str.264, ptr @arshift }, %struct.luaL_Reg { ptr @.str.265, ptr @rol }, %struct.luaL_Reg { ptr @.str.266, ptr @ror }, %struct.luaL_Reg { ptr @.str.267, ptr @bswap }, %struct.luaL_Reg { ptr @.str.268, ptr @tohex }, %struct.luaL_Reg zeroinitializer], align 16
@.str.1 = private unnamed_addr constant [4 x i8] c"arg\00", align 1
@stderr = external local_unnamed_addr global ptr, align 8
@.str.2 = private unnamed_addr constant [11 x i8] c"Error: %s\0A\00", align 1
@.str.3 = private unnamed_addr constant [18 x i8] c"not enough memory\00", align 1
@.str.4 = private unnamed_addr constant [24 x i8] c"error in error handling\00", align 1
@.str.5 = private unnamed_addr constant [39 x i8] c"memory allocation error: block too big\00", align 1
@.str.6 = private unnamed_addr constant [10 x i8] c"%s:%d: %s\00", align 1
@.str.7 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.8 = private unnamed_addr constant [4 x i8] c"...\00", align 1
@.str.9 = private unnamed_addr constant [3 x i8] c"\0A\0D\00", align 1
@.str.10 = private unnamed_addr constant [10 x i8] c"[string \22\00", align 1
@.str.11 = private unnamed_addr constant [3 x i8] c"\22]\00", align 1
@.str.12 = private unnamed_addr constant [7 x i8] c"(null)\00", align 1
@.str.13 = private unnamed_addr constant [3 x i8] c"%p\00", align 1
@.str.14 = private unnamed_addr constant [2 x i8] c"%\00", align 1
@.str.15 = private unnamed_addr constant [23 x i8] c"string length overflow\00", align 1
@.str.16 = private unnamed_addr constant [6 x i8] c"%.14g\00", align 1
@luaO_nilobject_ = internal constant %struct.lua_TValue zeroinitializer, align 8
@.str.17 = private unnamed_addr constant [17 x i8] c"C stack overflow\00", align 1
@.str.18 = private unnamed_addr constant [5 x i8] c"call\00", align 1
@luaT_typenames = internal unnamed_addr constant [11 x ptr] [ptr @.str.21, ptr @.str.22, ptr @.str.23, ptr @.str.24, ptr @.str.25, ptr @.str.26, ptr @.str.27, ptr @.str.23, ptr @.str.28, ptr @.str.29, ptr @.str.30], align 16
@.str.20 = private unnamed_addr constant [25 x i8] c"attempt to %s a %s value\00", align 1
@.str.21 = private unnamed_addr constant [4 x i8] c"nil\00", align 1
@.str.22 = private unnamed_addr constant [8 x i8] c"boolean\00", align 1
@.str.23 = private unnamed_addr constant [9 x i8] c"userdata\00", align 1
@.str.24 = private unnamed_addr constant [7 x i8] c"number\00", align 1
@.str.25 = private unnamed_addr constant [7 x i8] c"string\00", align 1
@.str.26 = private unnamed_addr constant [6 x i8] c"table\00", align 1
@.str.27 = private unnamed_addr constant [9 x i8] c"function\00", align 1
@.str.28 = private unnamed_addr constant [7 x i8] c"thread\00", align 1
@.str.29 = private unnamed_addr constant [6 x i8] c"proto\00", align 1
@.str.30 = private unnamed_addr constant [6 x i8] c"upval\00", align 1
@.str.31 = private unnamed_addr constant [15 x i8] c"stack overflow\00", align 1
@.str.32 = private unnamed_addr constant [14 x i8] c"get length of\00", align 1
@.str.33 = private unnamed_addr constant [37 x i8] c"'for' initial value must be a number\00", align 1
@.str.34 = private unnamed_addr constant [29 x i8] c"'for' limit must be a number\00", align 1
@.str.35 = private unnamed_addr constant [28 x i8] c"'for' step must be a number\00", align 1
@.str.36 = private unnamed_addr constant [6 x i8] c"index\00", align 1
@.str.37 = private unnamed_addr constant [17 x i8] c"loop in gettable\00", align 1
@.str.38 = private unnamed_addr constant [17 x i8] c"loop in settable\00", align 1
@.str.39 = private unnamed_addr constant [19 x i8] c"table index is nil\00", align 1
@.str.40 = private unnamed_addr constant [19 x i8] c"table index is NaN\00", align 1
@dummynode_ = internal constant %struct.Node zeroinitializer, align 8
@luaO_log2.log_2 = internal unnamed_addr constant [256 x i8] c"\00\01\02\02\03\03\03\03\04\04\04\04\04\04\04\04\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08", align 16
@.str.41 = private unnamed_addr constant [15 x i8] c"table overflow\00", align 1
@.str.42 = private unnamed_addr constant [22 x i8] c"perform arithmetic on\00", align 1
@.str.43 = private unnamed_addr constant [33 x i8] c"attempt to compare two %s values\00", align 1
@.str.44 = private unnamed_addr constant [30 x i8] c"attempt to compare %s with %s\00", align 1
@.str.45 = private unnamed_addr constant [12 x i8] c"concatenate\00", align 1
@luaT_init.luaT_eventname = internal unnamed_addr constant [17 x ptr] [ptr @.str.46, ptr @.str.47, ptr @.str.48, ptr @.str.49, ptr @.str.50, ptr @.str.51, ptr @.str.52, ptr @.str.53, ptr @.str.54, ptr @.str.55, ptr @.str.56, ptr @.str.57, ptr @.str.58, ptr @.str.59, ptr @.str.60, ptr @.str.61, ptr @.str.62], align 16
@.str.46 = private unnamed_addr constant [8 x i8] c"__index\00", align 1
@.str.47 = private unnamed_addr constant [11 x i8] c"__newindex\00", align 1
@.str.48 = private unnamed_addr constant [5 x i8] c"__gc\00", align 1
@.str.49 = private unnamed_addr constant [7 x i8] c"__mode\00", align 1
@.str.50 = private unnamed_addr constant [5 x i8] c"__eq\00", align 1
@.str.51 = private unnamed_addr constant [6 x i8] c"__add\00", align 1
@.str.52 = private unnamed_addr constant [6 x i8] c"__sub\00", align 1
@.str.53 = private unnamed_addr constant [6 x i8] c"__mul\00", align 1
@.str.54 = private unnamed_addr constant [6 x i8] c"__div\00", align 1
@.str.55 = private unnamed_addr constant [6 x i8] c"__mod\00", align 1
@.str.56 = private unnamed_addr constant [6 x i8] c"__pow\00", align 1
@.str.57 = private unnamed_addr constant [6 x i8] c"__unm\00", align 1
@.str.58 = private unnamed_addr constant [6 x i8] c"__len\00", align 1
@.str.59 = private unnamed_addr constant [5 x i8] c"__lt\00", align 1
@.str.60 = private unnamed_addr constant [5 x i8] c"__le\00", align 1
@.str.61 = private unnamed_addr constant [9 x i8] c"__concat\00", align 1
@.str.62 = private unnamed_addr constant [7 x i8] c"__call\00", align 1
@luaX_tokens = internal unnamed_addr constant [32 x ptr] [ptr @.str.63, ptr @.str.64, ptr @.str.65, ptr @.str.66, ptr @.str.67, ptr @.str.68, ptr @.str.69, ptr @.str.70, ptr @.str.27, ptr @.str.71, ptr @.str.72, ptr @.str.73, ptr @.str.21, ptr @.str.74, ptr @.str.75, ptr @.str.76, ptr @.str.77, ptr @.str.78, ptr @.str.79, ptr @.str.80, ptr @.str.81, ptr @.str.82, ptr @.str.8, ptr @.str.83, ptr @.str.84, ptr @.str.85, ptr @.str.86, ptr @.str.87, ptr @.str.88, ptr @.str.89, ptr @.str.90, ptr null], align 16
@.str.63 = private unnamed_addr constant [4 x i8] c"and\00", align 1
@.str.64 = private unnamed_addr constant [6 x i8] c"break\00", align 1
@.str.65 = private unnamed_addr constant [3 x i8] c"do\00", align 1
@.str.66 = private unnamed_addr constant [5 x i8] c"else\00", align 1
@.str.67 = private unnamed_addr constant [7 x i8] c"elseif\00", align 1
@.str.68 = private unnamed_addr constant [4 x i8] c"end\00", align 1
@.str.69 = private unnamed_addr constant [6 x i8] c"false\00", align 1
@.str.70 = private unnamed_addr constant [4 x i8] c"for\00", align 1
@.str.71 = private unnamed_addr constant [3 x i8] c"if\00", align 1
@.str.72 = private unnamed_addr constant [3 x i8] c"in\00", align 1
@.str.73 = private unnamed_addr constant [6 x i8] c"local\00", align 1
@.str.74 = private unnamed_addr constant [4 x i8] c"not\00", align 1
@.str.75 = private unnamed_addr constant [3 x i8] c"or\00", align 1
@.str.76 = private unnamed_addr constant [7 x i8] c"repeat\00", align 1
@.str.77 = private unnamed_addr constant [7 x i8] c"return\00", align 1
@.str.78 = private unnamed_addr constant [5 x i8] c"then\00", align 1
@.str.79 = private unnamed_addr constant [5 x i8] c"true\00", align 1
@.str.80 = private unnamed_addr constant [6 x i8] c"until\00", align 1
@.str.81 = private unnamed_addr constant [6 x i8] c"while\00", align 1
@.str.82 = private unnamed_addr constant [3 x i8] c"..\00", align 1
@.str.83 = private unnamed_addr constant [3 x i8] c"==\00", align 1
@.str.84 = private unnamed_addr constant [3 x i8] c">=\00", align 1
@.str.85 = private unnamed_addr constant [3 x i8] c"<=\00", align 1
@.str.86 = private unnamed_addr constant [3 x i8] c"~=\00", align 1
@.str.87 = private unnamed_addr constant [9 x i8] c"<number>\00", align 1
@.str.88 = private unnamed_addr constant [7 x i8] c"<name>\00", align 1
@.str.89 = private unnamed_addr constant [9 x i8] c"<string>\00", align 1
@.str.90 = private unnamed_addr constant [6 x i8] c"<eof>\00", align 1
@.str.91 = private unnamed_addr constant [50 x i8] c"PANIC: unprotected error in call to Lua API (%s)\0A\00", align 1
@lualibs = internal unnamed_addr constant [6 x %struct.luaL_Reg] [%struct.luaL_Reg { ptr @.str.7, ptr @luaopen_base }, %struct.luaL_Reg { ptr @.str.26, ptr @luaopen_table }, %struct.luaL_Reg { ptr @.str.92, ptr @luaopen_io }, %struct.luaL_Reg { ptr @.str.93, ptr @luaopen_os }, %struct.luaL_Reg { ptr @.str.25, ptr @luaopen_string }, %struct.luaL_Reg zeroinitializer], align 16
@.str.92 = private unnamed_addr constant [3 x i8] c"io\00", align 1
@.str.93 = private unnamed_addr constant [3 x i8] c"os\00", align 1
@.str.94 = private unnamed_addr constant [3 x i8] c"_G\00", align 1
@base_funcs = internal constant [13 x %struct.luaL_Reg] [%struct.luaL_Reg { ptr @.str.101, ptr @luaB_assert }, %struct.luaL_Reg { ptr @.str.102, ptr @luaB_error }, %struct.luaL_Reg { ptr @.str.103, ptr @luaB_loadfile }, %struct.luaL_Reg { ptr @.str.104, ptr @luaB_loadstring }, %struct.luaL_Reg { ptr @.str.105, ptr @luaB_next }, %struct.luaL_Reg { ptr @.str.106, ptr @luaB_pcall }, %struct.luaL_Reg { ptr @.str.107, ptr @luaB_rawget }, %struct.luaL_Reg { ptr @.str.108, ptr @luaB_setfenv }, %struct.luaL_Reg { ptr @.str.109, ptr @luaB_setmetatable }, %struct.luaL_Reg { ptr @.str.110, ptr @luaB_tonumber }, %struct.luaL_Reg { ptr @.str.111, ptr @luaB_type }, %struct.luaL_Reg { ptr @.str.112, ptr @luaB_unpack }, %struct.luaL_Reg zeroinitializer], align 16
@.str.95 = private unnamed_addr constant [8 x i8] c"Lua 5.1\00", align 1
@.str.96 = private unnamed_addr constant [9 x i8] c"_VERSION\00", align 1
@.str.97 = private unnamed_addr constant [7 x i8] c"ipairs\00", align 1
@.str.98 = private unnamed_addr constant [6 x i8] c"pairs\00", align 1
@.str.99 = private unnamed_addr constant [3 x i8] c"kv\00", align 1
@.str.100 = private unnamed_addr constant [9 x i8] c"newproxy\00", align 1
@.str.101 = private unnamed_addr constant [7 x i8] c"assert\00", align 1
@.str.102 = private unnamed_addr constant [6 x i8] c"error\00", align 1
@.str.103 = private unnamed_addr constant [9 x i8] c"loadfile\00", align 1
@.str.104 = private unnamed_addr constant [11 x i8] c"loadstring\00", align 1
@.str.105 = private unnamed_addr constant [5 x i8] c"next\00", align 1
@.str.106 = private unnamed_addr constant [6 x i8] c"pcall\00", align 1
@.str.107 = private unnamed_addr constant [7 x i8] c"rawget\00", align 1
@.str.108 = private unnamed_addr constant [8 x i8] c"setfenv\00", align 1
@.str.109 = private unnamed_addr constant [13 x i8] c"setmetatable\00", align 1
@.str.110 = private unnamed_addr constant [9 x i8] c"tonumber\00", align 1
@.str.111 = private unnamed_addr constant [5 x i8] c"type\00", align 1
@.str.112 = private unnamed_addr constant [7 x i8] c"unpack\00", align 1
@.str.113 = private unnamed_addr constant [3 x i8] c"%s\00", align 1
@.str.114 = private unnamed_addr constant [18 x i8] c"assertion failed!\00", align 1
@.str.115 = private unnamed_addr constant [15 x i8] c"value expected\00", align 1
@.str.116 = private unnamed_addr constant [22 x i8] c"bad argument #%d (%s)\00", align 1
@.str.117 = private unnamed_addr constant [2 x i8] c"n\00", align 1
@.str.118 = private unnamed_addr constant [7 x i8] c"method\00", align 1
@.str.119 = private unnamed_addr constant [30 x i8] c"calling '%s' on bad self (%s)\00", align 1
@.str.120 = private unnamed_addr constant [2 x i8] c"?\00", align 1
@.str.121 = private unnamed_addr constant [30 x i8] c"bad argument #%d to '%s' (%s)\00", align 1
@.str.122 = private unnamed_addr constant [5 x i8] c"tail\00", align 1
@.str.123 = private unnamed_addr constant [13 x i8] c"=(tail call)\00", align 1
@.str.124 = private unnamed_addr constant [5 x i8] c"=[C]\00", align 1
@.str.125 = private unnamed_addr constant [2 x i8] c"C\00", align 1
@.str.126 = private unnamed_addr constant [5 x i8] c"main\00", align 1
@.str.127 = private unnamed_addr constant [4 x i8] c"Lua\00", align 1
@.str.128 = private unnamed_addr constant [3 x i8] c"Sl\00", align 1
@.str.129 = private unnamed_addr constant [8 x i8] c"%s:%d: \00", align 1
@.str.130 = private unnamed_addr constant [20 x i8] c"%s expected, got %s\00", align 1
@.str.131 = private unnamed_addr constant [9 x i8] c"no value\00", align 1
@.str.132 = private unnamed_addr constant [30 x i8] c"invalid long string delimiter\00", align 1
@.str.134 = private unnamed_addr constant [25 x i8] c"chunk has too many lines\00", align 1
@.str.135 = private unnamed_addr constant [23 x i8] c"unfinished long string\00", align 1
@.str.136 = private unnamed_addr constant [24 x i8] c"unfinished long comment\00", align 1
@.str.137 = private unnamed_addr constant [13 x i8] c"%s near '%s'\00", align 1
@.str.138 = private unnamed_addr constant [9 x i8] c"char(%d)\00", align 1
@.str.139 = private unnamed_addr constant [3 x i8] c"%c\00", align 1
@.str.140 = private unnamed_addr constant [18 x i8] c"unfinished string\00", align 1
@.str.141 = private unnamed_addr constant [26 x i8] c"escape sequence too large\00", align 1
@.str.142 = private unnamed_addr constant [25 x i8] c"lexical element too long\00", align 1
@.str.143 = private unnamed_addr constant [3 x i8] c"Ee\00", align 1
@.str.145 = private unnamed_addr constant [17 x i8] c"malformed number\00", align 1
@.str.146 = private unnamed_addr constant [33 x i8] c"chunk has too many syntax levels\00", align 1
@priority = internal unnamed_addr constant [15 x %struct.anon.5] [%struct.anon.5 { i8 6, i8 6 }, %struct.anon.5 { i8 6, i8 6 }, %struct.anon.5 { i8 7, i8 7 }, %struct.anon.5 { i8 7, i8 7 }, %struct.anon.5 { i8 7, i8 7 }, %struct.anon.5 { i8 10, i8 9 }, %struct.anon.5 { i8 5, i8 4 }, %struct.anon.5 { i8 3, i8 3 }, %struct.anon.5 { i8 3, i8 3 }, %struct.anon.5 { i8 3, i8 3 }, %struct.anon.5 { i8 3, i8 3 }, %struct.anon.5 { i8 3, i8 3 }, %struct.anon.5 { i8 3, i8 3 }, %struct.anon.5 { i8 2, i8 2 }, %struct.anon.5 { i8 1, i8 1 }], align 16
@.str.147 = private unnamed_addr constant [19 x i8] c"code size overflow\00", align 1
@.str.148 = private unnamed_addr constant [27 x i8] c"control structure too long\00", align 1
@.str.149 = private unnamed_addr constant [24 x i8] c"constant table overflow\00", align 1
@.str.150 = private unnamed_addr constant [35 x i8] c"function or expression too complex\00", align 1
@.str.151 = private unnamed_addr constant [43 x i8] c"cannot use '...' outside a vararg function\00", align 1
@.str.152 = private unnamed_addr constant [23 x i8] c"items in a constructor\00", align 1
@.str.153 = private unnamed_addr constant [34 x i8] c"main function has more than %d %s\00", align 1
@.str.154 = private unnamed_addr constant [40 x i8] c"function at line %d has more than %d %s\00", align 1
@.str.155 = private unnamed_addr constant [5 x i8] c"self\00", align 1
@.str.156 = private unnamed_addr constant [16 x i8] c"local variables\00", align 1
@.str.157 = private unnamed_addr constant [25 x i8] c"too many local variables\00", align 1
@.str.158 = private unnamed_addr constant [25 x i8] c"<name> or '...' expected\00", align 1
@.str.159 = private unnamed_addr constant [18 x i8] c"unexpected symbol\00", align 1
@.str.160 = private unnamed_addr constant [9 x i8] c"upvalues\00", align 1
@.str.161 = private unnamed_addr constant [49 x i8] c"ambiguous syntax (function call x new statement)\00", align 1
@.str.162 = private unnamed_addr constant [28 x i8] c"function arguments expected\00", align 1
@.str.163 = private unnamed_addr constant [41 x i8] c"'%s' expected (to close '%s' at line %d)\00", align 1
@.str.164 = private unnamed_addr constant [14 x i8] c"'%s' expected\00", align 1
@.str.165 = private unnamed_addr constant [21 x i8] c"'=' or 'in' expected\00", align 1
@.str.166 = private unnamed_addr constant [12 x i8] c"(for index)\00", align 1
@.str.167 = private unnamed_addr constant [12 x i8] c"(for limit)\00", align 1
@.str.168 = private unnamed_addr constant [11 x i8] c"(for step)\00", align 1
@.str.169 = private unnamed_addr constant [16 x i8] c"(for generator)\00", align 1
@.str.170 = private unnamed_addr constant [12 x i8] c"(for state)\00", align 1
@.str.171 = private unnamed_addr constant [14 x i8] c"(for control)\00", align 1
@.str.172 = private unnamed_addr constant [17 x i8] c"no loop to break\00", align 1
@.str.173 = private unnamed_addr constant [13 x i8] c"syntax error\00", align 1
@.str.174 = private unnamed_addr constant [24 x i8] c"variables in assignment\00", align 1
@.str.175 = private unnamed_addr constant [52 x i8] c"'setfenv' cannot change environment of given object\00", align 1
@.str.176 = private unnamed_addr constant [27 x i8] c"level must be non-negative\00", align 1
@.str.177 = private unnamed_addr constant [14 x i8] c"invalid level\00", align 1
@.str.178 = private unnamed_addr constant [2 x i8] c"f\00", align 1
@.str.179 = private unnamed_addr constant [50 x i8] c"no function environment for tail call at level %d\00", align 1
@.str.180 = private unnamed_addr constant [22 x i8] c"nil or table expected\00", align 1
@.str.181 = private unnamed_addr constant [12 x i8] c"__metatable\00", align 1
@.str.182 = private unnamed_addr constant [36 x i8] c"cannot change a protected metatable\00", align 1
@.str.183 = private unnamed_addr constant [18 x i8] c"base out of range\00", align 1
@.str.184 = private unnamed_addr constant [27 x i8] c"too many results to unpack\00", align 1
@.str.185 = private unnamed_addr constant [22 x i8] c"invalid key to 'next'\00", align 1
@.str.186 = private unnamed_addr constant [26 x i8] c"boolean or proxy expected\00", align 1
@tab_funcs = internal constant [5 x %struct.luaL_Reg] [%struct.luaL_Reg { ptr @.str.187, ptr @tconcat }, %struct.luaL_Reg { ptr @.str.188, ptr @tinsert }, %struct.luaL_Reg { ptr @.str.189, ptr @tremove }, %struct.luaL_Reg { ptr @.str.190, ptr @sort }, %struct.luaL_Reg zeroinitializer], align 16
@.str.187 = private unnamed_addr constant [7 x i8] c"concat\00", align 1
@.str.188 = private unnamed_addr constant [7 x i8] c"insert\00", align 1
@.str.189 = private unnamed_addr constant [7 x i8] c"remove\00", align 1
@.str.190 = private unnamed_addr constant [5 x i8] c"sort\00", align 1
@.str.191 = private unnamed_addr constant [53 x i8] c"invalid value (%s) at index %d in table for 'concat'\00", align 1
@.str.192 = private unnamed_addr constant [38 x i8] c"wrong number of arguments to 'insert'\00", align 1
@.str.193 = private unnamed_addr constant [20 x i8] c"stack overflow (%s)\00", align 1
@.str.194 = private unnamed_addr constant [35 x i8] c"invalid order function for sorting\00", align 1
@iolib = internal constant [10 x %struct.luaL_Reg] [%struct.luaL_Reg { ptr @.str.200, ptr @io_close }, %struct.luaL_Reg { ptr @.str.201, ptr @io_flush }, %struct.luaL_Reg { ptr @.str.214, ptr @io_input }, %struct.luaL_Reg { ptr @.str.202, ptr @io_lines }, %struct.luaL_Reg { ptr @.str.215, ptr @io_open }, %struct.luaL_Reg { ptr @.str.216, ptr @io_output }, %struct.luaL_Reg { ptr @.str.203, ptr @io_read }, %struct.luaL_Reg { ptr @.str.111, ptr @io_type }, %struct.luaL_Reg { ptr @.str.204, ptr @io_write }, %struct.luaL_Reg zeroinitializer], align 16
@stdin = external local_unnamed_addr global ptr, align 8
@.str.195 = private unnamed_addr constant [6 x i8] c"stdin\00", align 1
@stdout = external local_unnamed_addr global ptr, align 8
@.str.196 = private unnamed_addr constant [7 x i8] c"stdout\00", align 1
@.str.197 = private unnamed_addr constant [7 x i8] c"stderr\00", align 1
@.str.198 = private unnamed_addr constant [6 x i8] c"popen\00", align 1
@.str.199 = private unnamed_addr constant [6 x i8] c"FILE*\00", align 1
@flib = internal unnamed_addr constant [7 x %struct.luaL_Reg] [%struct.luaL_Reg { ptr @.str.200, ptr @io_close }, %struct.luaL_Reg { ptr @.str.201, ptr @f_flush }, %struct.luaL_Reg { ptr @.str.202, ptr @f_lines }, %struct.luaL_Reg { ptr @.str.203, ptr @f_read }, %struct.luaL_Reg { ptr @.str.204, ptr @f_write }, %struct.luaL_Reg { ptr @.str.48, ptr @io_gc }, %struct.luaL_Reg zeroinitializer], align 16
@.str.200 = private unnamed_addr constant [6 x i8] c"close\00", align 1
@.str.201 = private unnamed_addr constant [6 x i8] c"flush\00", align 1
@.str.202 = private unnamed_addr constant [6 x i8] c"lines\00", align 1
@.str.203 = private unnamed_addr constant [5 x i8] c"read\00", align 1
@.str.204 = private unnamed_addr constant [6 x i8] c"write\00", align 1
@.str.205 = private unnamed_addr constant [29 x i8] c"attempt to use a closed file\00", align 1
@.str.206 = private unnamed_addr constant [8 x i8] c"__close\00", align 1
@.str.207 = private unnamed_addr constant [7 x i8] c"%s: %s\00", align 1
@.str.208 = private unnamed_addr constant [23 x i8] c"file is already closed\00", align 1
@.str.209 = private unnamed_addr constant [19 x i8] c"too many arguments\00", align 1
@.str.210 = private unnamed_addr constant [15 x i8] c"invalid option\00", align 1
@.str.211 = private unnamed_addr constant [15 x i8] c"invalid format\00", align 1
@.str.212 = private unnamed_addr constant [4 x i8] c"%lf\00", align 1
@.str.213 = private unnamed_addr constant [23 x i8] c"no calling environment\00", align 1
@.str.214 = private unnamed_addr constant [6 x i8] c"input\00", align 1
@.str.215 = private unnamed_addr constant [5 x i8] c"open\00", align 1
@.str.216 = private unnamed_addr constant [7 x i8] c"output\00", align 1
@.str.217 = private unnamed_addr constant [27 x i8] c"standard %s file is closed\00", align 1
@.str.218 = private unnamed_addr constant [2 x i8] c"r\00", align 1
@.str.219 = private unnamed_addr constant [2 x i8] c"w\00", align 1
@.str.220 = private unnamed_addr constant [12 x i8] c"closed file\00", align 1
@.str.221 = private unnamed_addr constant [5 x i8] c"file\00", align 1
@.str.222 = private unnamed_addr constant [27 x i8] c"cannot close standard file\00", align 1
@syslib = internal constant [3 x %struct.luaL_Reg] [%struct.luaL_Reg { ptr @.str.223, ptr @os_exit }, %struct.luaL_Reg { ptr @.str.189, ptr @os_remove }, %struct.luaL_Reg zeroinitializer], align 16
@.str.223 = private unnamed_addr constant [5 x i8] c"exit\00", align 1
@strlib = internal constant [12 x %struct.luaL_Reg] [%struct.luaL_Reg { ptr @.str.224, ptr @str_byte }, %struct.luaL_Reg { ptr @.str.225, ptr @str_char }, %struct.luaL_Reg { ptr @.str.226, ptr @str_find }, %struct.luaL_Reg { ptr @.str.227, ptr @str_format }, %struct.luaL_Reg { ptr @.str.228, ptr @gmatch }, %struct.luaL_Reg { ptr @.str.229, ptr @str_gsub }, %struct.luaL_Reg { ptr @.str.230, ptr @str_lower }, %struct.luaL_Reg { ptr @.str.231, ptr @str_match }, %struct.luaL_Reg { ptr @.str.232, ptr @str_rep }, %struct.luaL_Reg { ptr @.str.233, ptr @str_sub }, %struct.luaL_Reg { ptr @.str.234, ptr @str_upper }, %struct.luaL_Reg zeroinitializer], align 16
@.str.224 = private unnamed_addr constant [5 x i8] c"byte\00", align 1
@.str.225 = private unnamed_addr constant [5 x i8] c"char\00", align 1
@.str.226 = private unnamed_addr constant [5 x i8] c"find\00", align 1
@.str.227 = private unnamed_addr constant [7 x i8] c"format\00", align 1
@.str.228 = private unnamed_addr constant [7 x i8] c"gmatch\00", align 1
@.str.229 = private unnamed_addr constant [5 x i8] c"gsub\00", align 1
@.str.230 = private unnamed_addr constant [6 x i8] c"lower\00", align 1
@.str.231 = private unnamed_addr constant [6 x i8] c"match\00", align 1
@.str.232 = private unnamed_addr constant [4 x i8] c"rep\00", align 1
@.str.233 = private unnamed_addr constant [4 x i8] c"sub\00", align 1
@.str.234 = private unnamed_addr constant [6 x i8] c"upper\00", align 1
@.str.235 = private unnamed_addr constant [22 x i8] c"string slice too long\00", align 1
@.str.236 = private unnamed_addr constant [14 x i8] c"invalid value\00", align 1
@.str.237 = private unnamed_addr constant [11 x i8] c"^$*+?.([%-\00", align 1
@.str.238 = private unnamed_addr constant [35 x i8] c"missing '[' after '%%f' in pattern\00", align 1
@.str.239 = private unnamed_addr constant [18 x i8] c"too many captures\00", align 1
@.str.240 = private unnamed_addr constant [24 x i8] c"invalid pattern capture\00", align 1
@.str.241 = private unnamed_addr constant [19 x i8] c"unbalanced pattern\00", align 1
@.str.242 = private unnamed_addr constant [35 x i8] c"malformed pattern (ends with '%%')\00", align 1
@.str.243 = private unnamed_addr constant [32 x i8] c"malformed pattern (missing ']')\00", align 1
@.str.244 = private unnamed_addr constant [22 x i8] c"invalid capture index\00", align 1
@.str.245 = private unnamed_addr constant [19 x i8] c"unfinished capture\00", align 1
@.str.246 = private unnamed_addr constant [34 x i8] c"invalid option '%%%c' to 'format'\00", align 1
@.str.248 = private unnamed_addr constant [32 x i8] c"invalid format (repeated flags)\00", align 1
@.str.249 = private unnamed_addr constant [45 x i8] c"invalid format (width or precision too long)\00", align 1
@.str.251 = private unnamed_addr constant [3 x i8] c"\\r\00", align 1
@.str.252 = private unnamed_addr constant [5 x i8] c"\\000\00", align 1
@.str.253 = private unnamed_addr constant [31 x i8] c"string/function/table expected\00", align 1
@.str.254 = private unnamed_addr constant [33 x i8] c"invalid replacement value (a %s)\00", align 1
@.str.255 = private unnamed_addr constant [8 x i8] c"_LOADED\00", align 1
@.str.256 = private unnamed_addr constant [30 x i8] c"name conflict for module '%s'\00", align 1
@.str.257 = private unnamed_addr constant [6 x i8] c"tobit\00", align 1
@.str.258 = private unnamed_addr constant [5 x i8] c"bnot\00", align 1
@.str.259 = private unnamed_addr constant [5 x i8] c"band\00", align 1
@.str.260 = private unnamed_addr constant [4 x i8] c"bor\00", align 1
@.str.261 = private unnamed_addr constant [5 x i8] c"bxor\00", align 1
@.str.262 = private unnamed_addr constant [7 x i8] c"lshift\00", align 1
@.str.263 = private unnamed_addr constant [7 x i8] c"rshift\00", align 1
@.str.264 = private unnamed_addr constant [8 x i8] c"arshift\00", align 1
@.str.265 = private unnamed_addr constant [4 x i8] c"rol\00", align 1
@.str.266 = private unnamed_addr constant [4 x i8] c"ror\00", align 1
@.str.267 = private unnamed_addr constant [6 x i8] c"bswap\00", align 1
@.str.268 = private unnamed_addr constant [6 x i8] c"tohex\00", align 1
@.str.269 = private unnamed_addr constant [17 x i8] c"0123456789abcdef\00", align 1
@.str.270 = private unnamed_addr constant [17 x i8] c"0123456789ABCDEF\00", align 1
@.str.271 = private unnamed_addr constant [7 x i8] c"=stdin\00", align 1
@.str.272 = private unnamed_addr constant [4 x i8] c"@%s\00", align 1
@.str.274 = private unnamed_addr constant [3 x i8] c"rb\00", align 1
@.str.275 = private unnamed_addr constant [7 x i8] c"reopen\00", align 1
@.str.276 = private unnamed_addr constant [17 x i8] c"cannot %s %s: %s\00", align 1
@.str.277 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1

; Function Attrs: nounwind uwtable
define dso_local i32 @main(i32 noundef %argc, ptr nocapture noundef readonly %argv) local_unnamed_addr #0 {
entry:
  %c.i = alloca %struct.CallS, align 8
  %key.i = alloca %struct.lua_TValue, align 8
  %k.i.i = alloca %struct.lua_TValue, align 8
  %malloc.i.i = tail call dereferenceable_or_null(616) ptr @malloc(i64 616)
  %cmp.i.i = icmp eq ptr %malloc.i.i, null
  br i1 %cmp.i.i, label %luaL_newstate.exit, label %if.end.i.i

if.end.i.i:                                       ; preds = %entry
  %g1.i.i = getelementptr inbounds %struct.LG, ptr %malloc.i.i, i64 0, i32 1
  store ptr null, ptr %malloc.i.i, align 8
  %tt.i.i = getelementptr inbounds %struct.lua_State, ptr %malloc.i.i, i64 0, i32 1
  store i8 8, ptr %tt.i.i, align 8
  %currentwhite.i.i = getelementptr inbounds %struct.LG, ptr %malloc.i.i, i64 0, i32 1, i32 3
  store i8 33, ptr %currentwhite.i.i, align 8
  %marked.i.i = getelementptr inbounds %struct.lua_State, ptr %malloc.i.i, i64 0, i32 2
  store i8 97, ptr %marked.i.i, align 1
  %l_G.i.i.i = getelementptr %struct.lua_State, ptr %malloc.i.i, i64 0, i32 6
  store ptr %g1.i.i, ptr %l_G.i.i.i, align 8
  %stack.i.i.i = getelementptr inbounds %struct.lua_State, ptr %malloc.i.i, i64 0, i32 10
  store ptr null, ptr %stack.i.i.i, align 8
  %stacksize.i.i.i = getelementptr inbounds %struct.lua_State, ptr %malloc.i.i, i64 0, i32 13
  store i32 0, ptr %stacksize.i.i.i, align 8
  %errorJmp.i.i.i = getelementptr inbounds %struct.lua_State, ptr %malloc.i.i, i64 0, i32 26
  store ptr null, ptr %errorJmp.i.i.i, align 8
  %hook.i.i.i = getelementptr inbounds %struct.lua_State, ptr %malloc.i.i, i64 0, i32 21
  store ptr null, ptr %hook.i.i.i, align 8
  %hookmask.i.i.i = getelementptr inbounds %struct.lua_State, ptr %malloc.i.i, i64 0, i32 17
  store i8 0, ptr %hookmask.i.i.i, align 4
  %basehookcount.i.i.i = getelementptr inbounds %struct.lua_State, ptr %malloc.i.i, i64 0, i32 19
  store i32 0, ptr %basehookcount.i.i.i, align 8
  %allowhook.i.i.i = getelementptr inbounds %struct.lua_State, ptr %malloc.i.i, i64 0, i32 18
  store i8 1, ptr %allowhook.i.i.i, align 1
  %hookcount.i.i.i = getelementptr inbounds %struct.lua_State, ptr %malloc.i.i, i64 0, i32 20
  store i32 0, ptr %hookcount.i.i.i, align 4
  %openupval.i.i.i = getelementptr inbounds %struct.lua_State, ptr %malloc.i.i, i64 0, i32 24
  store ptr null, ptr %openupval.i.i.i, align 8
  %size_ci.i.i.i = getelementptr inbounds %struct.lua_State, ptr %malloc.i.i, i64 0, i32 14
  %status.i.i.i = getelementptr inbounds %struct.lua_State, ptr %malloc.i.i, i64 0, i32 3
  store i8 0, ptr %status.i.i.i, align 2
  %ci.i.i.i = getelementptr inbounds %struct.lua_State, ptr %malloc.i.i, i64 0, i32 7
  %base_ci.i.i.i = getelementptr inbounds %struct.lua_State, ptr %malloc.i.i, i64 0, i32 12
  store ptr null, ptr %base_ci.i.i.i, align 8
  %errfunc.i.i.i = getelementptr inbounds %struct.lua_State, ptr %malloc.i.i, i64 0, i32 27
  store i64 0, ptr %errfunc.i.i.i, align 8
  %tt.i.i.i = getelementptr inbounds %struct.lua_State, ptr %malloc.i.i, i64 0, i32 22, i32 1
  store i32 0, ptr %tt.i.i.i, align 8
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %ci.i.i.i, i8 0, i64 16, i1 false)
  store i64 0, ptr %size_ci.i.i.i, align 4
  %frealloc.i.i = getelementptr inbounds %struct.LG, ptr %malloc.i.i, i64 0, i32 1, i32 1
  store ptr @l_alloc, ptr %frealloc.i.i, align 8
  %ud7.i.i = getelementptr inbounds %struct.LG, ptr %malloc.i.i, i64 0, i32 1, i32 2
  store ptr null, ptr %ud7.i.i, align 8
  %mainthread.i.i = getelementptr inbounds %struct.LG, ptr %malloc.i.i, i64 0, i32 1, i32 21
  store ptr %malloc.i.i, ptr %mainthread.i.i, align 8
  %uvhead.i.i = getelementptr inbounds %struct.LG, ptr %malloc.i.i, i64 0, i32 1, i32 22
  %u.i.i = getelementptr inbounds %struct.LG, ptr %malloc.i.i, i64 0, i32 1, i32 22, i32 4
  store ptr %uvhead.i.i, ptr %u.i.i, align 8
  %next12.i.i = getelementptr inbounds %struct.LG, ptr %malloc.i.i, i64 0, i32 1, i32 22, i32 4, i32 0, i32 1
  store ptr %uvhead.i.i, ptr %next12.i.i, align 8
  %tt15.i.i = getelementptr inbounds %struct.LG, ptr %malloc.i.i, i64 0, i32 1, i32 20, i32 1
  store i32 0, ptr %tt15.i.i, align 8
  %buff.i.i = getelementptr inbounds %struct.LG, ptr %malloc.i.i, i64 0, i32 1, i32 12
  store ptr null, ptr %buff.i.i, align 8
  %buffsize.i.i = getelementptr inbounds %struct.LG, ptr %malloc.i.i, i64 0, i32 1, i32 12, i32 2
  %panic.i.i = getelementptr inbounds %struct.LG, ptr %malloc.i.i, i64 0, i32 1, i32 19
  store ptr null, ptr %panic.i.i, align 8
  %gcstate.i.i = getelementptr inbounds %struct.LG, ptr %malloc.i.i, i64 0, i32 1, i32 4
  store i8 0, ptr %gcstate.i.i, align 1
  %rootgc.i.i = getelementptr inbounds %struct.LG, ptr %malloc.i.i, i64 0, i32 1, i32 6
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %g1.i.i, i8 0, i64 16, i1 false)
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %buffsize.i.i, i8 0, i64 16, i1 false)
  store ptr %malloc.i.i, ptr %rootgc.i.i, align 8
  %sweepstrgc.i.i = getelementptr inbounds %struct.LG, ptr %malloc.i.i, i64 0, i32 1, i32 5
  store i32 0, ptr %sweepstrgc.i.i, align 4
  %sweepgc.i.i = getelementptr inbounds %struct.LG, ptr %malloc.i.i, i64 0, i32 1, i32 7
  store ptr %rootgc.i.i, ptr %sweepgc.i.i, align 8
  %gray.i.i = getelementptr inbounds %struct.LG, ptr %malloc.i.i, i64 0, i32 1, i32 8
  %totalbytes.i.i = getelementptr inbounds %struct.LG, ptr %malloc.i.i, i64 0, i32 1, i32 14
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %gray.i.i, i8 0, i64 32, i1 false)
  store i64 616, ptr %totalbytes.i.i, align 8
  %gcpause.i.i = getelementptr inbounds %struct.LG, ptr %malloc.i.i, i64 0, i32 1, i32 17
  store i32 200, ptr %gcpause.i.i, align 8
  %gcstepmul.i.i = getelementptr inbounds %struct.LG, ptr %malloc.i.i, i64 0, i32 1, i32 18
  store i32 200, ptr %gcstepmul.i.i, align 4
  %gcdept.i.i = getelementptr inbounds %struct.LG, ptr %malloc.i.i, i64 0, i32 1, i32 16
  store i64 0, ptr %gcdept.i.i, align 8
  %scevgep.i.i = getelementptr i8, ptr %malloc.i.i, i64 408
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(72) %scevgep.i.i, i8 0, i64 72, i1 false)
  %call20.i.i = tail call fastcc i32 @luaD_rawrunprotected(ptr noundef nonnull %malloc.i.i, ptr noundef nonnull @f_luaopen, ptr noundef null)
  %cmp21.not.i.i = icmp eq i32 %call20.i.i, 0
  br i1 %cmp21.not.i.i, label %if.then.i, label %if.then23.i.i

if.then23.i.i:                                    ; preds = %if.end.i.i
  tail call fastcc void @close_state(ptr noundef nonnull %malloc.i.i)
  br label %luaL_newstate.exit

if.then.i:                                        ; preds = %if.end.i.i
  %call.val.i = load ptr, ptr %l_G.i.i.i, align 8
  %panic.i3.i = getelementptr inbounds %struct.global_State, ptr %call.val.i, i64 0, i32 19
  store ptr @panic, ptr %panic.i3.i, align 8
  br label %luaL_newstate.exit

luaL_newstate.exit:                               ; preds = %entry, %if.then23.i.i, %if.then.i
  %retval.0.i6.i = phi ptr [ %malloc.i.i, %if.then.i ], [ null, %entry ], [ null, %if.then23.i.i ]
  %top.i.i = getelementptr inbounds %struct.lua_State, ptr %retval.0.i6.i, i64 0, i32 4
  br label %for.body.i

for.body.i:                                       ; preds = %for.body.i, %luaL_newstate.exit
  %0 = phi ptr [ @luaopen_base, %luaL_newstate.exit ], [ %3, %for.body.i ]
  %lib.06.i = phi ptr [ @lualibs, %luaL_newstate.exit ], [ %incdec.ptr.i, %for.body.i ]
  tail call fastcc void @lua_pushcclosure(ptr noundef %retval.0.i6.i, ptr noundef nonnull %0, i32 noundef 0)
  %1 = load ptr, ptr %lib.06.i, align 8
  tail call fastcc void @lua_pushstring(ptr noundef %retval.0.i6.i, ptr noundef %1)
  %2 = load ptr, ptr %top.i.i, align 8
  %add.ptr.i.i = getelementptr inbounds %struct.lua_TValue, ptr %2, i64 -2
  tail call fastcc void @luaD_call(ptr noundef %retval.0.i6.i, ptr noundef nonnull %add.ptr.i.i, i32 noundef 0)
  %incdec.ptr.i = getelementptr inbounds %struct.luaL_Reg, ptr %lib.06.i, i64 1
  %func.i = getelementptr inbounds %struct.luaL_Reg, ptr %lib.06.i, i64 1, i32 1
  %3 = load ptr, ptr %func.i, align 8
  %tobool.not.i = icmp eq ptr %3, null
  br i1 %tobool.not.i, label %luaL_openlibs.exit, label %for.body.i, !llvm.loop !4

luaL_openlibs.exit:                               ; preds = %for.body.i
  tail call fastcc void @luaL_register(ptr noundef nonnull %retval.0.i6.i, ptr noundef nonnull @.str, ptr noundef nonnull @bitlib)
  %cmp = icmp slt i32 %argc, 2
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %luaL_openlibs.exit
  %l_G.i = getelementptr inbounds %struct.lua_State, ptr %retval.0.i6.i, i64 0, i32 6
  %4 = load ptr, ptr %l_G.i, align 8
  %totalbytes.i = getelementptr inbounds %struct.global_State, ptr %4, i64 0, i32 14
  %5 = load i64, ptr %totalbytes.i, align 8
  %GCthreshold.i = getelementptr inbounds %struct.global_State, ptr %4, i64 0, i32 13
  %6 = load i64, ptr %GCthreshold.i, align 8
  %cmp.not.i = icmp ult i64 %5, %6
  br i1 %cmp.not.i, label %lua_createtable.exit, label %if.then.i17

if.then.i17:                                      ; preds = %if.end
  %gcstepmul.i.i18 = getelementptr inbounds %struct.global_State, ptr %4, i64 0, i32 18
  %7 = load i32, ptr %gcstepmul.i.i18, align 4
  %mul.i.i = mul i32 %7, 10
  %conv.i.i = zext i32 %mul.i.i to i64
  %cmp.i.i19 = icmp eq i32 %mul.i.i, 0
  %spec.store.select.i.i = select i1 %cmp.i.i19, i64 9223372036854775806, i64 %conv.i.i
  %sub.i.i = sub i64 %5, %6
  %gcdept.i.i20 = getelementptr inbounds %struct.global_State, ptr %4, i64 0, i32 16
  %8 = load i64, ptr %gcdept.i.i20, align 8
  %add.i.i = add i64 %sub.i.i, %8
  store i64 %add.i.i, ptr %gcdept.i.i20, align 8
  %gcstate.i.i21 = getelementptr inbounds %struct.global_State, ptr %4, i64 0, i32 4
  br label %do.body.i.i

do.body.i.i:                                      ; preds = %do.body.i.i, %if.then.i17
  %lim.0.i.i = phi i64 [ %spec.store.select.i.i, %if.then.i17 ], [ %sub2.i.i, %do.body.i.i ]
  %call.i.i = tail call fastcc i64 @singlestep(ptr noundef %retval.0.i6.i)
  %sub2.i.i = sub nsw i64 %lim.0.i.i, %call.i.i
  %9 = load i8, ptr %gcstate.i.i21, align 1
  %cmp4.i.i = icmp ne i8 %9, 0
  %cmp8.i.i = icmp sgt i64 %sub2.i.i, 0
  %or.cond.i.i = select i1 %cmp4.i.i, i1 %cmp8.i.i, i1 false
  br i1 %or.cond.i.i, label %do.body.i.i, label %do.end.i.i, !llvm.loop !6

do.end.i.i:                                       ; preds = %do.body.i.i
  br i1 %cmp4.i.i, label %if.then14.i.i, label %if.else27.i.i

if.then14.i.i:                                    ; preds = %do.end.i.i
  %10 = load i64, ptr %gcdept.i.i20, align 8
  %cmp16.i.i = icmp ult i64 %10, 1024
  br i1 %cmp16.i.i, label %if.then18.i.i, label %if.else.i.i

if.then18.i.i:                                    ; preds = %if.then14.i.i
  %11 = load i64, ptr %totalbytes.i, align 8
  %add20.i.i = add i64 %11, 1024
  br label %luaC_step.exit.i

if.else.i.i:                                      ; preds = %if.then14.i.i
  %sub23.i.i = add i64 %10, -1024
  store i64 %sub23.i.i, ptr %gcdept.i.i20, align 8
  %12 = load i64, ptr %totalbytes.i, align 8
  br label %luaC_step.exit.i

if.else27.i.i:                                    ; preds = %do.end.i.i
  %estimate.i.i = getelementptr inbounds %struct.global_State, ptr %4, i64 0, i32 15
  %13 = load i64, ptr %estimate.i.i, align 8
  %div.i.i = udiv i64 %13, 100
  %gcpause.i.i22 = getelementptr inbounds %struct.global_State, ptr %4, i64 0, i32 17
  %14 = load i32, ptr %gcpause.i.i22, align 8
  %conv28.i.i = sext i32 %14 to i64
  %mul29.i.i = mul i64 %div.i.i, %conv28.i.i
  br label %luaC_step.exit.i

luaC_step.exit.i:                                 ; preds = %if.else27.i.i, %if.else.i.i, %if.then18.i.i
  %add20.sink.i.i = phi i64 [ %add20.i.i, %if.then18.i.i ], [ %12, %if.else.i.i ], [ %mul29.i.i, %if.else27.i.i ]
  store i64 %add20.sink.i.i, ptr %GCthreshold.i, align 8
  br label %lua_createtable.exit

lua_createtable.exit:                             ; preds = %if.end, %luaC_step.exit.i
  %15 = load ptr, ptr %top.i.i, align 8
  %call.i = tail call fastcc ptr @luaH_new(ptr noundef %retval.0.i6.i, i32 noundef 0, i32 noundef 1)
  store ptr %call.i, ptr %15, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %15, i64 0, i32 1
  store i32 5, ptr %tt.i, align 8
  %16 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i23 = getelementptr inbounds %struct.lua_TValue, ptr %16, i64 1
  store ptr %incdec.ptr.i23, ptr %top.i.i, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %argv, i64 1
  %17 = load ptr, ptr %arrayidx, align 8
  tail call fastcc void @lua_pushstring(ptr noundef %retval.0.i6.i, ptr noundef %17)
  %18 = load ptr, ptr %top.i.i, align 8
  %add.ptr8.i.i = getelementptr inbounds %struct.lua_TValue, ptr %18, i64 -2
  %add.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %18, i64 -1
  %19 = load ptr, ptr %add.ptr8.i.i, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %k.i.i)
  %node.i.i.i.i = getelementptr inbounds %struct.Table, ptr %19, i64 0, i32 7
  %20 = load ptr, ptr %node.i.i.i.i, align 8
  br label %do.body.i.i.i

do.body.i.i.i:                                    ; preds = %if.else8.i.i.i, %lua_createtable.exit
  %n.0.i.i.i = phi ptr [ %20, %lua_createtable.exit ], [ %23, %if.else8.i.i.i ]
  %tt.i.i.i25 = getelementptr inbounds %struct.Node, ptr %n.0.i.i.i, i64 0, i32 1, i32 0, i32 1
  %21 = load i32, ptr %tt.i.i.i25, align 8
  %cmp2.i.i.i = icmp eq i32 %21, 3
  br i1 %cmp2.i.i.i, label %land.lhs.true.i.i.i, label %if.else8.i.i.i

land.lhs.true.i.i.i:                              ; preds = %do.body.i.i.i
  %i_key.i.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i.i, i64 0, i32 1
  %22 = load double, ptr %i_key.i.i.i, align 8
  %cmp5.i.i.i = fcmp oeq double %22, 0.000000e+00
  br i1 %cmp5.i.i.i, label %luaH_getnum.exit.i.i, label %if.else8.i.i.i

if.else8.i.i.i:                                   ; preds = %land.lhs.true.i.i.i, %do.body.i.i.i
  %next.i.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i.i, i64 0, i32 1, i32 0, i32 2
  %23 = load ptr, ptr %next.i.i.i, align 8
  %tobool.not.i.i.i = icmp eq ptr %23, null
  br i1 %tobool.not.i.i.i, label %if.else.i.i26, label %do.body.i.i.i, !llvm.loop !7

luaH_getnum.exit.i.i:                             ; preds = %land.lhs.true.i.i.i
  %cmp.not.i.i = icmp eq ptr %n.0.i.i.i, @luaO_nilobject_
  br i1 %cmp.not.i.i, label %if.else.i.i26, label %luaH_setnum.exit.i

if.else.i.i26:                                    ; preds = %if.else8.i.i.i, %luaH_getnum.exit.i.i
  store double 0.000000e+00, ptr %k.i.i, align 8
  %tt.i11.i = getelementptr inbounds %struct.lua_TValue, ptr %k.i.i, i64 0, i32 1
  store i32 3, ptr %tt.i11.i, align 8
  %call1.i.i = call fastcc ptr @newkey(ptr noundef %retval.0.i6.i, ptr noundef %19, ptr noundef nonnull %k.i.i)
  br label %luaH_setnum.exit.i

luaH_setnum.exit.i:                               ; preds = %if.else.i.i26, %luaH_getnum.exit.i.i
  %retval.0.i12.i = phi ptr [ %call1.i.i, %if.else.i.i26 ], [ %n.0.i.i.i, %luaH_getnum.exit.i.i ]
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %k.i.i)
  %24 = load i64, ptr %add.ptr.i, align 8
  store i64 %24, ptr %retval.0.i12.i, align 8
  %tt.i27 = getelementptr %struct.lua_TValue, ptr %18, i64 -1, i32 1
  %25 = load i32, ptr %tt.i27, align 8
  %tt4.i = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i12.i, i64 0, i32 1
  store i32 %25, ptr %tt4.i, align 8
  %26 = load ptr, ptr %top.i.i, align 8
  %tt7.i = getelementptr %struct.lua_TValue, ptr %26, i64 -1, i32 1
  %27 = load i32, ptr %tt7.i, align 8
  %cmp.i = icmp sgt i32 %27, 3
  br i1 %cmp.i, label %land.lhs.true.i, label %lua_rawseti.exit

land.lhs.true.i:                                  ; preds = %luaH_setnum.exit.i
  %add.ptr6.i = getelementptr inbounds %struct.lua_TValue, ptr %26, i64 -1
  %28 = load ptr, ptr %add.ptr6.i, align 8
  %marked.i = getelementptr inbounds %struct.GCheader, ptr %28, i64 0, i32 2
  %29 = load i8, ptr %marked.i, align 1
  %30 = and i8 %29, 3
  %tobool.not.i29 = icmp eq i8 %30, 0
  br i1 %tobool.not.i29, label %lua_rawseti.exit, label %land.lhs.true11.i

land.lhs.true11.i:                                ; preds = %land.lhs.true.i
  %31 = load ptr, ptr %add.ptr8.i.i, align 8
  %marked13.i = getelementptr inbounds %struct.GCheader, ptr %31, i64 0, i32 2
  %32 = load i8, ptr %marked13.i, align 1
  %33 = and i8 %32, 4
  %tobool16.not.i = icmp eq i8 %33, 0
  br i1 %tobool16.not.i, label %lua_rawseti.exit, label %if.then.i30

if.then.i30:                                      ; preds = %land.lhs.true11.i
  %L.val.i = load ptr, ptr %l_G.i, align 8
  %34 = and i8 %32, -5
  store i8 %34, ptr %marked13.i, align 1
  %grayagain.i.i = getelementptr inbounds %struct.global_State, ptr %L.val.i, i64 0, i32 9
  %35 = load ptr, ptr %grayagain.i.i, align 8
  %gclist.i.i = getelementptr inbounds %struct.Table, ptr %31, i64 0, i32 9
  store ptr %35, ptr %gclist.i.i, align 8
  store ptr %31, ptr %grayagain.i.i, align 8
  %.pre.i = load ptr, ptr %top.i.i, align 8
  br label %lua_rawseti.exit

lua_rawseti.exit:                                 ; preds = %luaH_setnum.exit.i, %land.lhs.true.i, %land.lhs.true11.i, %if.then.i30
  %36 = phi ptr [ %.pre.i, %if.then.i30 ], [ %26, %land.lhs.true11.i ], [ %26, %land.lhs.true.i ], [ %26, %luaH_setnum.exit.i ]
  %incdec.ptr.i28 = getelementptr inbounds %struct.lua_TValue, ptr %36, i64 -1
  store ptr %incdec.ptr.i28, ptr %top.i.i, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %key.i)
  %l_gt.i.i = getelementptr inbounds %struct.lua_State, ptr %retval.0.i6.i, i64 0, i32 22
  %call2.i = tail call fastcc ptr @luaS_newlstr(ptr noundef nonnull %retval.0.i6.i, ptr noundef nonnull @.str.1, i64 noundef 3)
  store ptr %call2.i, ptr %key.i, align 8
  %tt.i31 = getelementptr inbounds %struct.lua_TValue, ptr %key.i, i64 0, i32 1
  store i32 4, ptr %tt.i31, align 8
  %37 = load ptr, ptr %top.i.i, align 8
  %add.ptr.i33 = getelementptr inbounds %struct.lua_TValue, ptr %37, i64 -1
  call fastcc void @luaV_settable(ptr noundef nonnull %retval.0.i6.i, ptr noundef nonnull %l_gt.i.i, ptr noundef nonnull %key.i, ptr noundef nonnull %add.ptr.i33)
  %38 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i34 = getelementptr inbounds %struct.lua_TValue, ptr %38, i64 -1
  store ptr %incdec.ptr.i34, ptr %top.i.i, align 8
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %key.i)
  %39 = load ptr, ptr %arrayidx, align 8
  %call2 = tail call fastcc i32 @luaL_loadfile(ptr noundef nonnull %retval.0.i6.i, ptr noundef %39)
  %tobool.not = icmp eq i32 %call2, 0
  br i1 %tobool.not, label %for.cond.preheader, label %err

for.cond.preheader:                               ; preds = %lua_rawseti.exit
  %cmp541.not = icmp eq i32 %argc, 2
  br i1 %cmp541.not, label %for.end, label %for.body.preheader

for.body.preheader:                               ; preds = %for.cond.preheader
  %smax = tail call i32 @llvm.smax.i32(i32 %argc, i32 3)
  %wide.trip.count = zext nneg i32 %smax to i64
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %for.body
  %indvars.iv = phi i64 [ 2, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %arrayidx6 = getelementptr inbounds ptr, ptr %argv, i64 %indvars.iv
  %40 = load ptr, ptr %arrayidx6, align 8
  tail call fastcc void @lua_pushstring(ptr noundef %retval.0.i6.i, ptr noundef %40)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !8

for.end:                                          ; preds = %for.body, %for.cond.preheader
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %c.i)
  %41 = load ptr, ptr %top.i.i, align 8
  %narrow.i = sub nsw i32 1, %argc
  %idx.neg.i = sext i32 %narrow.i to i64
  %add.ptr.i36 = getelementptr inbounds %struct.lua_TValue, ptr %41, i64 %idx.neg.i
  store ptr %add.ptr.i36, ptr %c.i, align 8
  %nresults2.i = getelementptr inbounds %struct.CallS, ptr %c.i, i64 0, i32 1
  store i32 0, ptr %nresults2.i, align 8
  %stack4.i = getelementptr inbounds %struct.lua_State, ptr %retval.0.i6.i, i64 0, i32 10
  %42 = load ptr, ptr %stack4.i, align 8
  %sub.ptr.lhs.cast5.i = ptrtoint ptr %add.ptr.i36 to i64
  %sub.ptr.rhs.cast6.i = ptrtoint ptr %42 to i64
  %sub.ptr.sub7.i = sub i64 %sub.ptr.lhs.cast5.i, %sub.ptr.rhs.cast6.i
  %call8.i = call fastcc i32 @luaD_pcall(ptr noundef %retval.0.i6.i, ptr noundef nonnull @f_call, ptr noundef nonnull %c.i, i64 noundef %sub.ptr.sub7.i, i64 noundef 0)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %c.i)
  %tobool8.not = icmp eq i32 %call8.i, 0
  br i1 %tobool8.not, label %if.end12, label %err

err:                                              ; preds = %for.end, %lua_rawseti.exit
  %43 = load ptr, ptr @stderr, align 8
  %call10 = call fastcc ptr @lua_tolstring(ptr noundef nonnull %retval.0.i6.i, i32 noundef -1, ptr noundef null)
  %call11 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %43, ptr noundef nonnull @.str.2, ptr noundef %call10) #33
  br label %return

if.end12:                                         ; preds = %for.end
  %call.val = load ptr, ptr %l_G.i, align 8
  %44 = getelementptr i8, ptr %call.val, i64 176
  %call.val.val = load ptr, ptr %44, align 8
  %stack.i = getelementptr inbounds %struct.lua_State, ptr %call.val.val, i64 0, i32 10
  %45 = load ptr, ptr %stack.i, align 8
  call fastcc void @luaF_close(ptr noundef %call.val.val, ptr noundef %45)
  %call.i37 = call fastcc i64 @luaC_separateudata(ptr noundef %call.val.val, i32 noundef 1)
  %errfunc.i = getelementptr inbounds %struct.lua_State, ptr %call.val.val, i64 0, i32 27
  store i64 0, ptr %errfunc.i, align 8
  %base_ci.i = getelementptr inbounds %struct.lua_State, ptr %call.val.val, i64 0, i32 12
  %ci.i = getelementptr inbounds %struct.lua_State, ptr %call.val.val, i64 0, i32 7
  %top.i38 = getelementptr inbounds %struct.lua_State, ptr %call.val.val, i64 0, i32 4
  %base2.i = getelementptr inbounds %struct.lua_State, ptr %call.val.val, i64 0, i32 5
  %baseCcalls.i = getelementptr inbounds %struct.lua_State, ptr %call.val.val, i64 0, i32 16
  %nCcalls.i = getelementptr inbounds %struct.lua_State, ptr %call.val.val, i64 0, i32 15
  br label %do.body.i

do.body.i:                                        ; preds = %do.body.i, %if.end12
  %46 = load ptr, ptr %base_ci.i, align 8
  store ptr %46, ptr %ci.i, align 8
  %47 = load ptr, ptr %46, align 8
  store ptr %47, ptr %top.i38, align 8
  store ptr %47, ptr %base2.i, align 8
  store i16 0, ptr %baseCcalls.i, align 2
  store i16 0, ptr %nCcalls.i, align 8
  %call3.i = call fastcc i32 @luaD_rawrunprotected(ptr noundef nonnull %call.val.val, ptr noundef nonnull @callallgcTM, ptr noundef null)
  %cmp.not.i39 = icmp eq i32 %call3.i, 0
  br i1 %cmp.not.i39, label %lua_close.exit, label %do.body.i, !llvm.loop !9

lua_close.exit:                                   ; preds = %do.body.i
  call fastcc void @close_state(ptr noundef nonnull %call.val.val)
  br label %return

return:                                           ; preds = %luaL_openlibs.exit, %lua_close.exit, %err
  %retval.0 = phi i32 [ 1, %err ], [ 0, %lua_close.exit ], [ 8, %luaL_openlibs.exit ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaL_register(ptr noundef %L, ptr noundef %libname, ptr nocapture noundef readonly %l) unnamed_addr #0 {
entry:
  %key.i61.i = alloca %struct.lua_TValue, align 8
  %key.i38.i = alloca %struct.lua_TValue, align 8
  %key.i.i = alloca %struct.lua_TValue, align 8
  %tobool.not.i = icmp eq ptr %libname, null
  br i1 %tobool.not.i, label %if.end9.i, label %if.then.i

if.then.i:                                        ; preds = %entry
  %0 = load ptr, ptr %l, align 8
  %tobool.not3.i.i = icmp eq ptr %0, null
  br i1 %tobool.not3.i.i, label %libsize.exit.i, label %for.body.i.i

for.body.i.i:                                     ; preds = %if.then.i, %for.body.i.i
  %size.05.i.i = phi i32 [ %inc.i.i, %for.body.i.i ], [ 0, %if.then.i ]
  %l.addr.04.i.i = phi ptr [ %incdec.ptr.i.i, %for.body.i.i ], [ %l, %if.then.i ]
  %inc.i.i = add nuw nsw i32 %size.05.i.i, 1
  %incdec.ptr.i.i = getelementptr inbounds %struct.luaL_Reg, ptr %l.addr.04.i.i, i64 1
  %1 = load ptr, ptr %incdec.ptr.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %1, null
  br i1 %tobool.not.i.i, label %libsize.exit.i, label %for.body.i.i, !llvm.loop !10

libsize.exit.i:                                   ; preds = %for.body.i.i, %if.then.i
  %size.0.lcssa.i.i = phi i32 [ 0, %if.then.i ], [ %inc.i.i, %for.body.i.i ]
  %call1.i = tail call fastcc ptr @luaL_findtable(ptr noundef %L, i32 noundef -10000, ptr noundef nonnull @.str.255, i32 noundef 1)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %key.i.i)
  %top6.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %2 = load ptr, ptr %top6.i.i.i, align 8
  %add.ptr8.i.i.i = getelementptr inbounds %struct.lua_TValue, ptr %2, i64 -1
  %call1.i.i = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %libname) #34
  %call2.i.i = tail call fastcc ptr @luaS_newlstr(ptr noundef %L, ptr noundef nonnull %libname, i64 noundef %call1.i.i)
  store ptr %call2.i.i, ptr %key.i.i, align 8
  %tt.i.i = getelementptr inbounds %struct.lua_TValue, ptr %key.i.i, i64 0, i32 1
  store i32 4, ptr %tt.i.i, align 8
  %3 = load ptr, ptr %top6.i.i.i, align 8
  call fastcc void @luaV_gettable(ptr noundef %L, ptr noundef nonnull %add.ptr8.i.i.i, ptr noundef nonnull %key.i.i, ptr noundef %3)
  %4 = load ptr, ptr %top6.i.i.i, align 8
  %incdec.ptr.i28.i = getelementptr inbounds %struct.lua_TValue, ptr %4, i64 1
  store ptr %incdec.ptr.i28.i, ptr %top6.i.i.i, align 8
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %key.i.i)
  %cmp.i.i = icmp eq ptr %4, @luaO_nilobject_
  br i1 %cmp.i.i, label %if.then3.i, label %lua_type.exit.i

lua_type.exit.i:                                  ; preds = %libsize.exit.i
  %tt.i31.i = getelementptr inbounds %struct.lua_TValue, ptr %4, i64 0, i32 1
  %5 = load i32, ptr %tt.i31.i, align 8
  %cmp.i = icmp eq i32 %5, 5
  br i1 %cmp.i, label %if.end8.i, label %if.then3.i

if.then3.i:                                       ; preds = %lua_type.exit.i, %libsize.exit.i
  store ptr %4, ptr %top6.i.i.i, align 8
  %call4.i = tail call fastcc ptr @luaL_findtable(ptr noundef nonnull %L, i32 noundef -10002, ptr noundef nonnull %libname, i32 noundef %size.0.lcssa.i.i)
  %cmp5.not.i = icmp eq ptr %call4.i, null
  br i1 %cmp5.not.i, label %if.end.i, label %if.then6.i

if.then6.i:                                       ; preds = %if.then3.i
  tail call void (ptr, ptr, ...) @luaL_error(ptr noundef nonnull %L, ptr noundef nonnull @.str.256, ptr noundef nonnull %libname)
  unreachable

if.end.i:                                         ; preds = %if.then3.i
  %6 = load ptr, ptr %top6.i.i.i, align 8
  %add.ptr8.i.i34.i = getelementptr inbounds %struct.lua_TValue, ptr %6, i64 -1
  %7 = load i64, ptr %add.ptr8.i.i34.i, align 8
  store i64 %7, ptr %6, align 8
  %tt.i36.i = getelementptr %struct.lua_TValue, ptr %6, i64 -1, i32 1
  %8 = load i32, ptr %tt.i36.i, align 8
  %tt2.i.i = getelementptr inbounds %struct.lua_TValue, ptr %6, i64 0, i32 1
  store i32 %8, ptr %tt2.i.i, align 8
  %9 = load ptr, ptr %top6.i.i.i, align 8
  %incdec.ptr.i37.i = getelementptr inbounds %struct.lua_TValue, ptr %9, i64 1
  store ptr %incdec.ptr.i37.i, ptr %top6.i.i.i, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %key.i38.i)
  %add.ptr8.i.i40.i = getelementptr inbounds %struct.lua_TValue, ptr %9, i64 -2
  %call1.i41.i = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %libname) #34
  %call2.i42.i = tail call fastcc ptr @luaS_newlstr(ptr noundef nonnull %L, ptr noundef nonnull %libname, i64 noundef %call1.i41.i)
  store ptr %call2.i42.i, ptr %key.i38.i, align 8
  %tt.i43.i = getelementptr inbounds %struct.lua_TValue, ptr %key.i38.i, i64 0, i32 1
  store i32 4, ptr %tt.i43.i, align 8
  %10 = load ptr, ptr %top6.i.i.i, align 8
  %add.ptr.i.i = getelementptr inbounds %struct.lua_TValue, ptr %10, i64 -1
  call fastcc void @luaV_settable(ptr noundef nonnull %L, ptr noundef nonnull %add.ptr8.i.i40.i, ptr noundef nonnull %key.i38.i, ptr noundef nonnull %add.ptr.i.i)
  %11 = load ptr, ptr %top6.i.i.i, align 8
  %incdec.ptr.i45.i = getelementptr inbounds %struct.lua_TValue, ptr %11, i64 -1
  store ptr %incdec.ptr.i45.i, ptr %top6.i.i.i, align 8
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %key.i38.i)
  br label %if.end8.i

if.end8.i:                                        ; preds = %if.end.i, %lua_type.exit.i
  %12 = phi ptr [ %incdec.ptr.i45.i, %if.end.i ], [ %incdec.ptr.i28.i, %lua_type.exit.i ]
  %add.ptr8.i.i47.i = getelementptr inbounds %struct.lua_TValue, ptr %12, i64 -2
  %incdec.ptr7.i.i = getelementptr inbounds %struct.lua_TValue, ptr %12, i64 -1
  br label %while.body.i.i

while.body.i.i:                                   ; preds = %while.body.i.i, %if.end8.i
  %incdec.ptr10.i.i = phi ptr [ %incdec.ptr.i51.i, %while.body.i.i ], [ %incdec.ptr7.i.i, %if.end8.i ]
  %p.09.i.i = phi ptr [ %incdec.ptr10.i.i, %while.body.i.i ], [ %add.ptr8.i.i47.i, %if.end8.i ]
  %13 = load i64, ptr %incdec.ptr10.i.i, align 8
  store i64 %13, ptr %p.09.i.i, align 8
  %tt.i49.i = getelementptr inbounds %struct.lua_TValue, ptr %p.09.i.i, i64 1, i32 1
  %14 = load i32, ptr %tt.i49.i, align 8
  %tt2.i50.i = getelementptr inbounds %struct.lua_TValue, ptr %p.09.i.i, i64 0, i32 1
  store i32 %14, ptr %tt2.i50.i, align 8
  %incdec.ptr.i51.i = getelementptr inbounds %struct.lua_TValue, ptr %incdec.ptr10.i.i, i64 1
  %15 = load ptr, ptr %top6.i.i.i, align 8
  %cmp.i52.i = icmp ult ptr %incdec.ptr.i51.i, %15
  br i1 %cmp.i52.i, label %while.body.i.i, label %lua_remove.exit.i, !llvm.loop !11

lua_remove.exit.i:                                ; preds = %while.body.i.i
  %incdec.ptr4.i.ptr.i = getelementptr inbounds i8, ptr %15, i64 -16
  store ptr %incdec.ptr4.i.ptr.i, ptr %top6.i.i.i, align 8
  %add.ptr.i57.ptr.i = getelementptr inbounds i8, ptr %15, i64 -32
  %16 = load i64, ptr %add.ptr.i57.ptr.i, align 8
  store i64 %16, ptr %incdec.ptr4.i.ptr.i, align 8
  %tt.i58.i = getelementptr i8, ptr %15, i64 -24
  %17 = load i32, ptr %tt.i58.i, align 8
  %tt2.i59.i = getelementptr inbounds i8, ptr %15, i64 -8
  store i32 %17, ptr %tt2.i59.i, align 8
  %.pre.i.i = load ptr, ptr %top6.i.i.i, align 8
  %18 = load i64, ptr %.pre.i.i, align 8
  store i64 %18, ptr %add.ptr.i57.ptr.i, align 8
  %tt8.i.i = getelementptr inbounds %struct.lua_TValue, ptr %.pre.i.i, i64 0, i32 1
  %19 = load i32, ptr %tt8.i.i, align 8
  store i32 %19, ptr %tt.i58.i, align 8
  br label %if.end9.i

if.end9.i:                                        ; preds = %lua_remove.exit.i, %entry
  %20 = load ptr, ptr %l, align 8
  %tobool10.not74.i = icmp eq ptr %20, null
  br i1 %tobool10.not74.i, label %luaI_openlib.exit, label %for.end.lr.ph.i

for.end.lr.ph.i:                                  ; preds = %if.end9.i
  %top6.i.i62.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %tt.i66.i = getelementptr inbounds %struct.lua_TValue, ptr %key.i61.i, i64 0, i32 1
  br label %for.end.i

for.end.i:                                        ; preds = %for.end.i, %for.end.lr.ph.i
  %l.addr.075.i = phi ptr [ %l, %for.end.lr.ph.i ], [ %incdec.ptr.i, %for.end.i ]
  %func.i = getelementptr inbounds %struct.luaL_Reg, ptr %l.addr.075.i, i64 0, i32 1
  %21 = load ptr, ptr %func.i, align 8
  tail call fastcc void @lua_pushcclosure(ptr noundef %L, ptr noundef %21, i32 noundef 0)
  %22 = load ptr, ptr %l.addr.075.i, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %key.i61.i)
  %23 = load ptr, ptr %top6.i.i62.i, align 8
  %add.ptr8.i.i63.i = getelementptr inbounds %struct.lua_TValue, ptr %23, i64 -2
  %call1.i64.i = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %22) #34
  %call2.i65.i = tail call fastcc ptr @luaS_newlstr(ptr noundef %L, ptr noundef %22, i64 noundef %call1.i64.i)
  store ptr %call2.i65.i, ptr %key.i61.i, align 8
  store i32 4, ptr %tt.i66.i, align 8
  %24 = load ptr, ptr %top6.i.i62.i, align 8
  %add.ptr.i68.i = getelementptr inbounds %struct.lua_TValue, ptr %24, i64 -1
  call fastcc void @luaV_settable(ptr noundef %L, ptr noundef nonnull %add.ptr8.i.i63.i, ptr noundef nonnull %key.i61.i, ptr noundef nonnull %add.ptr.i68.i)
  %25 = load ptr, ptr %top6.i.i62.i, align 8
  %incdec.ptr.i69.i = getelementptr inbounds %struct.lua_TValue, ptr %25, i64 -1
  store ptr %incdec.ptr.i69.i, ptr %top6.i.i62.i, align 8
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %key.i61.i)
  %incdec.ptr.i = getelementptr inbounds %struct.luaL_Reg, ptr %l.addr.075.i, i64 1
  %26 = load ptr, ptr %incdec.ptr.i, align 8
  %tobool10.not.i = icmp eq ptr %26, null
  br i1 %tobool10.not.i, label %luaI_openlib.exit, label %for.end.i, !llvm.loop !12

luaI_openlib.exit:                                ; preds = %for.end.i, %if.end9.i
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @lua_pushstring(ptr noundef %L, ptr noundef readonly %s) unnamed_addr #0 {
entry:
  %cmp = icmp eq ptr %s, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %top.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %0 = load ptr, ptr %top.i, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %call = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %s) #34
  %l_G.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %1 = load ptr, ptr %l_G.i, align 8
  %totalbytes.i = getelementptr inbounds %struct.global_State, ptr %1, i64 0, i32 14
  %2 = load i64, ptr %totalbytes.i, align 8
  %GCthreshold.i = getelementptr inbounds %struct.global_State, ptr %1, i64 0, i32 13
  %3 = load i64, ptr %GCthreshold.i, align 8
  %cmp.not.i = icmp ult i64 %2, %3
  br i1 %cmp.not.i, label %lua_pushlstring.exit, label %if.then.i

if.then.i:                                        ; preds = %if.else
  %gcstepmul.i.i = getelementptr inbounds %struct.global_State, ptr %1, i64 0, i32 18
  %4 = load i32, ptr %gcstepmul.i.i, align 4
  %mul.i.i = mul i32 %4, 10
  %conv.i.i = zext i32 %mul.i.i to i64
  %cmp.i.i = icmp eq i32 %mul.i.i, 0
  %spec.store.select.i.i = select i1 %cmp.i.i, i64 9223372036854775806, i64 %conv.i.i
  %sub.i.i = sub i64 %2, %3
  %gcdept.i.i = getelementptr inbounds %struct.global_State, ptr %1, i64 0, i32 16
  %5 = load i64, ptr %gcdept.i.i, align 8
  %add.i.i = add i64 %sub.i.i, %5
  store i64 %add.i.i, ptr %gcdept.i.i, align 8
  %gcstate.i.i = getelementptr inbounds %struct.global_State, ptr %1, i64 0, i32 4
  br label %do.body.i.i

do.body.i.i:                                      ; preds = %do.body.i.i, %if.then.i
  %lim.0.i.i = phi i64 [ %spec.store.select.i.i, %if.then.i ], [ %sub2.i.i, %do.body.i.i ]
  %call.i.i = tail call fastcc i64 @singlestep(ptr noundef %L)
  %sub2.i.i = sub nsw i64 %lim.0.i.i, %call.i.i
  %6 = load i8, ptr %gcstate.i.i, align 1
  %cmp4.i.i = icmp ne i8 %6, 0
  %cmp8.i.i = icmp sgt i64 %sub2.i.i, 0
  %or.cond.i.i = select i1 %cmp4.i.i, i1 %cmp8.i.i, i1 false
  br i1 %or.cond.i.i, label %do.body.i.i, label %do.end.i.i, !llvm.loop !6

do.end.i.i:                                       ; preds = %do.body.i.i
  br i1 %cmp4.i.i, label %if.then14.i.i, label %if.else27.i.i

if.then14.i.i:                                    ; preds = %do.end.i.i
  %7 = load i64, ptr %gcdept.i.i, align 8
  %cmp16.i.i = icmp ult i64 %7, 1024
  br i1 %cmp16.i.i, label %if.then18.i.i, label %if.else.i.i

if.then18.i.i:                                    ; preds = %if.then14.i.i
  %8 = load i64, ptr %totalbytes.i, align 8
  %add20.i.i = add i64 %8, 1024
  br label %luaC_step.exit.i

if.else.i.i:                                      ; preds = %if.then14.i.i
  %sub23.i.i = add i64 %7, -1024
  store i64 %sub23.i.i, ptr %gcdept.i.i, align 8
  %9 = load i64, ptr %totalbytes.i, align 8
  br label %luaC_step.exit.i

if.else27.i.i:                                    ; preds = %do.end.i.i
  %estimate.i.i = getelementptr inbounds %struct.global_State, ptr %1, i64 0, i32 15
  %10 = load i64, ptr %estimate.i.i, align 8
  %div.i.i = udiv i64 %10, 100
  %gcpause.i.i = getelementptr inbounds %struct.global_State, ptr %1, i64 0, i32 17
  %11 = load i32, ptr %gcpause.i.i, align 8
  %conv28.i.i = sext i32 %11 to i64
  %mul29.i.i = mul i64 %div.i.i, %conv28.i.i
  br label %luaC_step.exit.i

luaC_step.exit.i:                                 ; preds = %if.else27.i.i, %if.else.i.i, %if.then18.i.i
  %add20.sink.i.i = phi i64 [ %add20.i.i, %if.then18.i.i ], [ %9, %if.else.i.i ], [ %mul29.i.i, %if.else27.i.i ]
  store i64 %add20.sink.i.i, ptr %GCthreshold.i, align 8
  br label %lua_pushlstring.exit

lua_pushlstring.exit:                             ; preds = %if.else, %luaC_step.exit.i
  %top.i4 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %12 = load ptr, ptr %top.i4, align 8
  %call.i = tail call fastcc ptr @luaS_newlstr(ptr noundef %L, ptr noundef nonnull %s, i64 noundef %call)
  store ptr %call.i, ptr %12, align 8
  br label %if.end

if.end:                                           ; preds = %lua_pushlstring.exit, %if.then
  %.sink8 = phi ptr [ %12, %lua_pushlstring.exit ], [ %0, %if.then ]
  %.sink = phi i32 [ 4, %lua_pushlstring.exit ], [ 0, %if.then ]
  %top.i4.sink7 = phi ptr [ %top.i4, %lua_pushlstring.exit ], [ %top.i, %if.then ]
  %tt.i5 = getelementptr inbounds %struct.lua_TValue, ptr %.sink8, i64 0, i32 1
  store i32 %.sink, ptr %tt.i5, align 8
  %13 = load ptr, ptr %top.i4.sink7, align 8
  %incdec.ptr.i6 = getelementptr inbounds %struct.lua_TValue, ptr %13, i64 1
  store ptr %incdec.ptr.i6, ptr %top.i4.sink7, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @lua_rawseti(ptr noundef %L, i32 noundef %idx, i32 noundef %n) unnamed_addr #0 {
entry:
  %k.i = alloca %struct.lua_TValue, align 8
  %cmp.i = icmp sgt i32 %idx, 0
  br i1 %cmp.i, label %if.then.i, label %if.else3.i

if.then.i:                                        ; preds = %entry
  %base.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i, align 8
  %1 = zext nneg i32 %idx to i64
  %2 = getelementptr %struct.lua_TValue, ptr %0, i64 %1
  %add.ptr.i = getelementptr %struct.lua_TValue, ptr %2, i64 -1
  %top.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %3 = load ptr, ptr %top.i, align 8
  %cmp1.not.i = icmp ult ptr %add.ptr.i, %3
  %add.ptr.luaO_nilobject_.i = select i1 %cmp1.not.i, ptr %add.ptr.i, ptr @luaO_nilobject_
  br label %index2adr.exit

if.else3.i:                                       ; preds = %entry
  %cmp4.i = icmp sgt i32 %idx, -10000
  br i1 %cmp4.i, label %if.then5.i, label %if.else9.i

if.then5.i:                                       ; preds = %if.else3.i
  %top6.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %4 = load ptr, ptr %top6.i, align 8
  %idx.ext7.i = sext i32 %idx to i64
  %add.ptr8.i = getelementptr inbounds %struct.lua_TValue, ptr %4, i64 %idx.ext7.i
  br label %index2adr.exit

if.else9.i:                                       ; preds = %if.else3.i
  switch i32 %idx, label %sw.default.i [
    i32 -10000, label %sw.bb.i
    i32 -10001, label %sw.bb10.i
    i32 -10002, label %sw.bb15.i
  ]

sw.bb.i:                                          ; preds = %if.else9.i
  %l_G.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %5 = load ptr, ptr %l_G.i, align 8
  %l_registry.i = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 20
  br label %index2adr.exit

sw.bb10.i:                                        ; preds = %if.else9.i
  %ci.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %6 = load ptr, ptr %ci.i, align 8
  %func11.i = getelementptr inbounds %struct.CallInfo, ptr %6, i64 0, i32 1
  %7 = load ptr, ptr %func11.i, align 8
  %8 = load ptr, ptr %7, align 8
  %env.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23
  %env12.i = getelementptr inbounds %struct.CClosure, ptr %8, i64 0, i32 6
  %9 = load ptr, ptr %env12.i, align 8
  store ptr %9, ptr %env.i, align 8
  %tt.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23, i32 1
  store i32 5, ptr %tt.i, align 8
  br label %index2adr.exit

sw.bb15.i:                                        ; preds = %if.else9.i
  %l_gt.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 22
  br label %index2adr.exit

sw.default.i:                                     ; preds = %if.else9.i
  %ci17.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %10 = load ptr, ptr %ci17.i, align 8
  %func18.i = getelementptr inbounds %struct.CallInfo, ptr %10, i64 0, i32 1
  %11 = load ptr, ptr %func18.i, align 8
  %12 = load ptr, ptr %11, align 8
  %sub20.i = sub nuw nsw i32 -10002, %idx
  %nupvalues.i = getelementptr inbounds %struct.CClosure, ptr %12, i64 0, i32 4
  %13 = load i8, ptr %nupvalues.i, align 1
  %conv.i = zext i8 %13 to i32
  %cmp21.not.i = icmp ugt i32 %sub20.i, %conv.i
  %sub23.i = sub nuw nsw i32 -10003, %idx
  %idxprom.i = zext nneg i32 %sub23.i to i64
  %arrayidx.i = getelementptr inbounds %struct.CClosure, ptr %12, i64 0, i32 8, i64 %idxprom.i
  %cond.i = select i1 %cmp21.not.i, ptr @luaO_nilobject_, ptr %arrayidx.i
  br label %index2adr.exit

index2adr.exit:                                   ; preds = %if.then.i, %if.then5.i, %sw.bb.i, %sw.bb10.i, %sw.bb15.i, %sw.default.i
  %retval.0.i = phi ptr [ %add.ptr8.i, %if.then5.i ], [ %cond.i, %sw.default.i ], [ %l_gt.i, %sw.bb15.i ], [ %env.i, %sw.bb10.i ], [ %l_registry.i, %sw.bb.i ], [ %add.ptr.luaO_nilobject_.i, %if.then.i ]
  %top = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %14 = load ptr, ptr %top, align 8
  %add.ptr = getelementptr inbounds %struct.lua_TValue, ptr %14, i64 -1
  %15 = load ptr, ptr %retval.0.i, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %k.i)
  %sub.i.i = add i32 %n, -1
  %sizearray.i.i = getelementptr inbounds %struct.Table, ptr %15, i64 0, i32 10
  %16 = load i32, ptr %sizearray.i.i, align 8
  %cmp.i.i = icmp ult i32 %sub.i.i, %16
  br i1 %cmp.i.i, label %if.then.i.i, label %if.else.i.i

if.then.i.i:                                      ; preds = %index2adr.exit
  %array.i.i = getelementptr inbounds %struct.Table, ptr %15, i64 0, i32 6
  %17 = load ptr, ptr %array.i.i, align 8
  %idxprom.i.i = sext i32 %sub.i.i to i64
  %arrayidx.i.i = getelementptr inbounds %struct.lua_TValue, ptr %17, i64 %idxprom.i.i
  br label %luaH_getnum.exit.i

if.else.i.i:                                      ; preds = %index2adr.exit
  %conv.i.i = sitofp i32 %n to double
  %cmp.i.i.i = icmp eq i32 %n, 0
  br i1 %cmp.i.i.i, label %if.then.i.i.i, label %if.end.i.i.i

if.then.i.i.i:                                    ; preds = %if.else.i.i
  %node.i.i.i = getelementptr inbounds %struct.Table, ptr %15, i64 0, i32 7
  %18 = load ptr, ptr %node.i.i.i, align 8
  br label %do.body.i.i.preheader

if.end.i.i.i:                                     ; preds = %if.else.i.i
  %19 = bitcast double %conv.i.i to i64
  %a.sroa.0.4.extract.shift.i.i.i = lshr i64 %19, 32
  %add.i.i.i = add i64 %a.sroa.0.4.extract.shift.i.i.i, %19
  %node4.i.i.i = getelementptr inbounds %struct.Table, ptr %15, i64 0, i32 7
  %20 = load ptr, ptr %node4.i.i.i, align 8
  %conv.i.i.i = and i64 %add.i.i.i, 4294967295
  %lsizenode.i.i.i = getelementptr inbounds %struct.Table, ptr %15, i64 0, i32 4
  %21 = load i8, ptr %lsizenode.i.i.i, align 1
  %sh_prom.i.i.i = zext nneg i8 %21 to i64
  %notmask.i.i.i = shl nsw i64 -1, %sh_prom.i.i.i
  %sub.i.i.i = xor i64 %notmask.i.i.i, -1
  %or.i.i.i = or i64 %sub.i.i.i, 1
  %rem.i.i.i = urem i64 %conv.i.i.i, %or.i.i.i
  %arrayidx7.i.i.i = getelementptr inbounds %struct.Node, ptr %20, i64 %rem.i.i.i
  br label %do.body.i.i.preheader

do.body.i.i.preheader:                            ; preds = %if.end.i.i.i, %if.then.i.i.i
  %n.0.i.i.ph = phi ptr [ %arrayidx7.i.i.i, %if.end.i.i.i ], [ %18, %if.then.i.i.i ]
  br label %do.body.i.i

do.body.i.i:                                      ; preds = %do.body.i.i.preheader, %if.else8.i.i
  %n.0.i.i = phi ptr [ %24, %if.else8.i.i ], [ %n.0.i.i.ph, %do.body.i.i.preheader ]
  %tt.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1, i32 0, i32 1
  %22 = load i32, ptr %tt.i.i, align 8
  %cmp2.i.i = icmp eq i32 %22, 3
  br i1 %cmp2.i.i, label %land.lhs.true.i.i, label %if.else8.i.i

land.lhs.true.i.i:                                ; preds = %do.body.i.i
  %i_key.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1
  %23 = load double, ptr %i_key.i.i, align 8
  %cmp5.i.i = fcmp oeq double %23, %conv.i.i
  br i1 %cmp5.i.i, label %luaH_getnum.exit.i, label %if.else8.i.i

if.else8.i.i:                                     ; preds = %land.lhs.true.i.i, %do.body.i.i
  %next.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1, i32 0, i32 2
  %24 = load ptr, ptr %next.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %24, null
  br i1 %tobool.not.i.i, label %if.else.i, label %do.body.i.i, !llvm.loop !7

luaH_getnum.exit.i:                               ; preds = %land.lhs.true.i.i, %if.then.i.i
  %retval.0.i.i = phi ptr [ %arrayidx.i.i, %if.then.i.i ], [ %n.0.i.i, %land.lhs.true.i.i ]
  %cmp.not.i = icmp eq ptr %retval.0.i.i, @luaO_nilobject_
  br i1 %cmp.not.i, label %luaH_getnum.exit.if.else_crit_edge.i, label %luaH_setnum.exit

luaH_getnum.exit.if.else_crit_edge.i:             ; preds = %luaH_getnum.exit.i
  %.pre.i = sitofp i32 %n to double
  br label %if.else.i

if.else.i:                                        ; preds = %if.else8.i.i, %luaH_getnum.exit.if.else_crit_edge.i
  %conv.pre-phi.i = phi double [ %.pre.i, %luaH_getnum.exit.if.else_crit_edge.i ], [ %conv.i.i, %if.else8.i.i ]
  store double %conv.pre-phi.i, ptr %k.i, align 8
  %tt.i11 = getelementptr inbounds %struct.lua_TValue, ptr %k.i, i64 0, i32 1
  store i32 3, ptr %tt.i11, align 8
  %call1.i = call fastcc ptr @newkey(ptr noundef %L, ptr noundef %15, ptr noundef nonnull %k.i)
  br label %luaH_setnum.exit

luaH_setnum.exit:                                 ; preds = %luaH_getnum.exit.i, %if.else.i
  %retval.0.i12 = phi ptr [ %call1.i, %if.else.i ], [ %retval.0.i.i, %luaH_getnum.exit.i ]
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %k.i)
  %25 = load i64, ptr %add.ptr, align 8
  store i64 %25, ptr %retval.0.i12, align 8
  %tt = getelementptr %struct.lua_TValue, ptr %14, i64 -1, i32 1
  %26 = load i32, ptr %tt, align 8
  %tt4 = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i12, i64 0, i32 1
  store i32 %26, ptr %tt4, align 8
  %27 = load ptr, ptr %top, align 8
  %tt7 = getelementptr %struct.lua_TValue, ptr %27, i64 -1, i32 1
  %28 = load i32, ptr %tt7, align 8
  %cmp = icmp sgt i32 %28, 3
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %luaH_setnum.exit
  %add.ptr6 = getelementptr inbounds %struct.lua_TValue, ptr %27, i64 -1
  %29 = load ptr, ptr %add.ptr6, align 8
  %marked = getelementptr inbounds %struct.GCheader, ptr %29, i64 0, i32 2
  %30 = load i8, ptr %marked, align 1
  %31 = and i8 %30, 3
  %tobool.not = icmp eq i8 %31, 0
  br i1 %tobool.not, label %if.end, label %land.lhs.true11

land.lhs.true11:                                  ; preds = %land.lhs.true
  %32 = load ptr, ptr %retval.0.i, align 8
  %marked13 = getelementptr inbounds %struct.GCheader, ptr %32, i64 0, i32 2
  %33 = load i8, ptr %marked13, align 1
  %34 = and i8 %33, 4
  %tobool16.not = icmp eq i8 %34, 0
  br i1 %tobool16.not, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true11
  %35 = getelementptr i8, ptr %L, i64 32
  %L.val = load ptr, ptr %35, align 8
  %36 = and i8 %33, -5
  store i8 %36, ptr %marked13, align 1
  %grayagain.i = getelementptr inbounds %struct.global_State, ptr %L.val, i64 0, i32 9
  %37 = load ptr, ptr %grayagain.i, align 8
  %gclist.i = getelementptr inbounds %struct.Table, ptr %32, i64 0, i32 9
  store ptr %37, ptr %gclist.i, align 8
  store ptr %32, ptr %grayagain.i, align 8
  %.pre = load ptr, ptr %top, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true11, %land.lhs.true, %luaH_setnum.exit
  %38 = phi ptr [ %.pre, %if.then ], [ %27, %land.lhs.true11 ], [ %27, %land.lhs.true ], [ %27, %luaH_setnum.exit ]
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue, ptr %38, i64 -1
  store ptr %incdec.ptr, ptr %top, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @luaL_loadfile(ptr noundef %L, ptr noundef %filename) unnamed_addr #0 {
entry:
  %p.i.i = alloca %struct.SParser, align 8
  %z.i = alloca %struct.Zio, align 8
  %lf = alloca %struct.LoadF, align 8
  %0 = getelementptr i8, ptr %L, i64 16
  %L.val = load ptr, ptr %0, align 8
  %1 = getelementptr i8, ptr %L, i64 24
  %L.val24 = load ptr, ptr %1, align 8
  %sub.ptr.lhs.cast.i = ptrtoint ptr %L.val to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %L.val24 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %sub.ptr.div.i = lshr exact i64 %sub.ptr.sub.i, 4
  %conv.i = trunc i64 %sub.ptr.div.i to i32
  %add = add nsw i32 %conv.i, 1
  store i32 0, ptr %lf, align 8
  %cmp = icmp eq ptr %filename, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %l_G.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %2 = load ptr, ptr %l_G.i, align 8
  %totalbytes.i = getelementptr inbounds %struct.global_State, ptr %2, i64 0, i32 14
  %3 = load i64, ptr %totalbytes.i, align 8
  %GCthreshold.i = getelementptr inbounds %struct.global_State, ptr %2, i64 0, i32 13
  %4 = load i64, ptr %GCthreshold.i, align 8
  %cmp.not.i = icmp ult i64 %3, %4
  br i1 %cmp.not.i, label %lua_pushlstring.exit, label %if.then.i

if.then.i:                                        ; preds = %if.then
  %gcstepmul.i.i = getelementptr inbounds %struct.global_State, ptr %2, i64 0, i32 18
  %5 = load i32, ptr %gcstepmul.i.i, align 4
  %mul.i.i = mul i32 %5, 10
  %conv.i.i = zext i32 %mul.i.i to i64
  %cmp.i.i = icmp eq i32 %mul.i.i, 0
  %spec.store.select.i.i = select i1 %cmp.i.i, i64 9223372036854775806, i64 %conv.i.i
  %sub.i.i = sub i64 %3, %4
  %gcdept.i.i = getelementptr inbounds %struct.global_State, ptr %2, i64 0, i32 16
  %6 = load i64, ptr %gcdept.i.i, align 8
  %add.i.i = add i64 %sub.i.i, %6
  store i64 %add.i.i, ptr %gcdept.i.i, align 8
  %gcstate.i.i = getelementptr inbounds %struct.global_State, ptr %2, i64 0, i32 4
  br label %do.body.i.i

do.body.i.i:                                      ; preds = %do.body.i.i, %if.then.i
  %lim.0.i.i = phi i64 [ %spec.store.select.i.i, %if.then.i ], [ %sub2.i.i, %do.body.i.i ]
  %call.i.i = tail call fastcc i64 @singlestep(ptr noundef %L)
  %sub2.i.i = sub nsw i64 %lim.0.i.i, %call.i.i
  %7 = load i8, ptr %gcstate.i.i, align 1
  %cmp4.i.i = icmp ne i8 %7, 0
  %cmp8.i.i = icmp sgt i64 %sub2.i.i, 0
  %or.cond.i.i = select i1 %cmp4.i.i, i1 %cmp8.i.i, i1 false
  br i1 %or.cond.i.i, label %do.body.i.i, label %do.end.i.i, !llvm.loop !6

do.end.i.i:                                       ; preds = %do.body.i.i
  br i1 %cmp4.i.i, label %if.then14.i.i, label %if.else27.i.i

if.then14.i.i:                                    ; preds = %do.end.i.i
  %8 = load i64, ptr %gcdept.i.i, align 8
  %cmp16.i.i = icmp ult i64 %8, 1024
  br i1 %cmp16.i.i, label %if.then18.i.i, label %if.else.i.i

if.then18.i.i:                                    ; preds = %if.then14.i.i
  %9 = load i64, ptr %totalbytes.i, align 8
  %add20.i.i = add i64 %9, 1024
  br label %luaC_step.exit.i

if.else.i.i:                                      ; preds = %if.then14.i.i
  %sub23.i.i = add i64 %8, -1024
  store i64 %sub23.i.i, ptr %gcdept.i.i, align 8
  %10 = load i64, ptr %totalbytes.i, align 8
  br label %luaC_step.exit.i

if.else27.i.i:                                    ; preds = %do.end.i.i
  %estimate.i.i = getelementptr inbounds %struct.global_State, ptr %2, i64 0, i32 15
  %11 = load i64, ptr %estimate.i.i, align 8
  %div.i.i = udiv i64 %11, 100
  %gcpause.i.i = getelementptr inbounds %struct.global_State, ptr %2, i64 0, i32 17
  %12 = load i32, ptr %gcpause.i.i, align 8
  %conv28.i.i = sext i32 %12 to i64
  %mul29.i.i = mul i64 %div.i.i, %conv28.i.i
  br label %luaC_step.exit.i

luaC_step.exit.i:                                 ; preds = %if.else27.i.i, %if.else.i.i, %if.then18.i.i
  %add20.sink.i.i = phi i64 [ %add20.i.i, %if.then18.i.i ], [ %10, %if.else.i.i ], [ %mul29.i.i, %if.else27.i.i ]
  store i64 %add20.sink.i.i, ptr %GCthreshold.i, align 8
  %.pre = load ptr, ptr %0, align 8
  br label %lua_pushlstring.exit

lua_pushlstring.exit:                             ; preds = %if.then, %luaC_step.exit.i
  %13 = phi ptr [ %L.val, %if.then ], [ %.pre, %luaC_step.exit.i ]
  %call.i = tail call fastcc ptr @luaS_newlstr(ptr noundef nonnull %L, ptr noundef nonnull @.str.271, i64 noundef 6)
  store ptr %call.i, ptr %13, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %13, i64 0, i32 1
  store i32 4, ptr %tt.i, align 8
  %14 = load ptr, ptr %0, align 8
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %14, i64 1
  store ptr %incdec.ptr.i, ptr %0, align 8
  %15 = load ptr, ptr @stdin, align 8
  %f = getelementptr inbounds %struct.LoadF, ptr %lf, i64 0, i32 1
  store ptr %15, ptr %f, align 8
  br label %if.end8

if.else:                                          ; preds = %entry
  %call1 = tail call ptr (ptr, ptr, ...) @lua_pushfstring(ptr noundef nonnull %L, ptr noundef nonnull @.str.272, ptr noundef nonnull %filename)
  %call2 = tail call noalias ptr @fopen(ptr noundef nonnull %filename, ptr noundef nonnull @.str.218)
  %f3 = getelementptr inbounds %struct.LoadF, ptr %lf, i64 0, i32 1
  store ptr %call2, ptr %f3, align 8
  %cmp5 = icmp eq ptr %call2, null
  br i1 %cmp5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.else
  tail call fastcc void @errfile(ptr noundef nonnull %L, ptr noundef nonnull @.str.215, i32 noundef %add)
  br label %return

if.end8:                                          ; preds = %if.else, %lua_pushlstring.exit
  %16 = phi ptr [ %call2, %if.else ], [ %15, %lua_pushlstring.exit ]
  %f9 = getelementptr inbounds %struct.LoadF, ptr %lf, i64 0, i32 1
  %call10 = tail call i32 @getc(ptr noundef %16)
  %cmp11 = icmp eq i32 %call10, 35
  br i1 %cmp11, label %if.then12, label %if.end23

if.then12:                                        ; preds = %if.end8
  store i32 1, ptr %lf, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.cond, %if.then12
  %call15 = tail call i32 @getc(ptr noundef %16)
  switch i32 %call15, label %while.cond [
    i32 10, label %if.then19
    i32 -1, label %if.end23.thread
  ]

if.end23.thread:                                  ; preds = %while.cond
  %tobool41 = icmp ne ptr %filename, null
  br label %if.end49

if.then19:                                        ; preds = %while.cond
  %call21 = tail call i32 @getc(ptr noundef %16)
  br label %if.end23

if.end23:                                         ; preds = %if.then19, %if.end8
  %c.0 = phi i32 [ %call21, %if.then19 ], [ %call10, %if.end8 ]
  %cmp24 = icmp eq i32 %c.0, 27
  %tobool = icmp ne ptr %filename, null
  %or.cond = and i1 %tobool, %cmp24
  br i1 %or.cond, label %if.then26, label %if.end49

if.then26:                                        ; preds = %if.end23
  %call28 = tail call ptr @freopen(ptr noundef nonnull %filename, ptr noundef nonnull @.str.274, ptr noundef %16) #35
  store ptr %call28, ptr %f9, align 8
  %cmp31 = icmp eq ptr %call28, null
  br i1 %cmp31, label %if.then33, label %while.cond36

if.then33:                                        ; preds = %if.then26
  tail call fastcc void @errfile(ptr noundef %L, ptr noundef nonnull @.str.275, i32 noundef %add)
  br label %return

while.cond36:                                     ; preds = %if.then26, %while.cond36
  %call38 = tail call i32 @getc(ptr noundef nonnull %call28)
  switch i32 %call38, label %while.cond36 [
    i32 -1, label %while.end47
    i32 27, label %while.end47
  ]

while.end47:                                      ; preds = %while.cond36, %while.cond36
  store i32 0, ptr %lf, align 8
  br label %if.end49

if.end49:                                         ; preds = %if.end23.thread, %while.end47, %if.end23
  %17 = phi ptr [ %call28, %while.end47 ], [ %16, %if.end23 ], [ %16, %if.end23.thread ]
  %tobool43 = phi i1 [ true, %while.end47 ], [ %tobool, %if.end23 ], [ %tobool41, %if.end23.thread ]
  %c.1 = phi i32 [ %call38, %while.end47 ], [ %c.0, %if.end23 ], [ -1, %if.end23.thread ]
  %call51 = tail call i32 @ungetc(i32 noundef %c.1, ptr noundef %17)
  %call52 = tail call fastcc ptr @lua_tolstring(ptr noundef %L, i32 noundef -1, ptr noundef null)
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %z.i)
  %tobool.not.i = icmp eq ptr %call52, null
  %spec.store.select.i = select i1 %tobool.not.i, ptr @.str.120, ptr %call52
  %L1.i.i = getelementptr inbounds %struct.Zio, ptr %z.i, i64 0, i32 4
  store ptr %L, ptr %L1.i.i, align 8
  %reader2.i.i = getelementptr inbounds %struct.Zio, ptr %z.i, i64 0, i32 2
  store ptr @getF, ptr %reader2.i.i, align 8
  %data3.i.i = getelementptr inbounds %struct.Zio, ptr %z.i, i64 0, i32 3
  store ptr %lf, ptr %data3.i.i, align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %z.i, i8 0, i64 16, i1 false)
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %p.i.i)
  store ptr %z.i, ptr %p.i.i, align 8
  %name2.i.i = getelementptr inbounds %struct.SParser, ptr %p.i.i, i64 0, i32 2
  store ptr %spec.store.select.i, ptr %name2.i.i, align 8
  %buff.i.i = getelementptr inbounds %struct.SParser, ptr %p.i.i, i64 0, i32 1
  store ptr null, ptr %buff.i.i, align 8
  %buffsize.i.i = getelementptr inbounds %struct.SParser, ptr %p.i.i, i64 0, i32 1, i32 2
  store i64 0, ptr %buffsize.i.i, align 8
  %18 = load ptr, ptr %0, align 8
  %stack.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 10
  %19 = load ptr, ptr %stack.i.i, align 8
  %sub.ptr.lhs.cast.i.i = ptrtoint ptr %18 to i64
  %sub.ptr.rhs.cast.i.i = ptrtoint ptr %19 to i64
  %sub.ptr.sub.i.i = sub i64 %sub.ptr.lhs.cast.i.i, %sub.ptr.rhs.cast.i.i
  %errfunc.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 27
  %20 = load i64, ptr %errfunc.i.i, align 8
  %call.i.i25 = call fastcc i32 @luaD_pcall(ptr noundef %L, ptr noundef nonnull @f_parser, ptr noundef nonnull %p.i.i, i64 noundef %sub.ptr.sub.i.i, i64 noundef %20)
  %21 = load ptr, ptr %buff.i.i, align 8
  %22 = load i64, ptr %buffsize.i.i, align 8
  %l_G.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %23 = load ptr, ptr %l_G.i.i.i, align 8
  %frealloc.i.i.i = getelementptr inbounds %struct.global_State, ptr %23, i64 0, i32 1
  %24 = load ptr, ptr %frealloc.i.i.i, align 8
  %ud.i.i.i = getelementptr inbounds %struct.global_State, ptr %23, i64 0, i32 2
  %25 = load ptr, ptr %ud.i.i.i, align 8
  %call.i.i.i = call ptr %24(ptr noundef %25, ptr noundef %21, i64 noundef %22, i64 noundef 0) #35
  %totalbytes.i.i.i = getelementptr inbounds %struct.global_State, ptr %23, i64 0, i32 14
  %26 = load i64, ptr %totalbytes.i.i.i, align 8
  %add.i.i.i = sub i64 %26, %22
  store i64 %add.i.i.i, ptr %totalbytes.i.i.i, align 8
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %p.i.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %z.i)
  %27 = load ptr, ptr %f9, align 8
  %call55 = call i32 @ferror(ptr noundef %27) #35
  br i1 %tobool43, label %if.then57, label %if.end60

if.then57:                                        ; preds = %if.end49
  %call59 = call i32 @fclose(ptr noundef %27)
  br label %if.end60

if.end60:                                         ; preds = %if.then57, %if.end49
  %tobool61.not = icmp eq i32 %call55, 0
  br i1 %tobool61.not, label %if.end64, label %if.then62

if.then62:                                        ; preds = %if.end60
  %cmp.i = icmp sgt i32 %conv.i, -2
  br i1 %cmp.i, label %while.cond.preheader.i, label %if.else.i

while.cond.preheader.i:                           ; preds = %if.then62
  %idx.ext.i = zext nneg i32 %add to i64
  %28 = load ptr, ptr %0, align 8
  %29 = load ptr, ptr %1, align 8
  %add.ptr10.i = getelementptr inbounds %struct.lua_TValue, ptr %29, i64 %idx.ext.i
  %cmp111.i = icmp ult ptr %28, %add.ptr10.i
  br i1 %cmp111.i, label %while.body.i, label %lua_settop.exit

while.body.i:                                     ; preds = %while.cond.preheader.i, %while.body.i
  %30 = phi ptr [ %31, %while.body.i ], [ %28, %while.cond.preheader.i ]
  %incdec.ptr.i27 = getelementptr inbounds %struct.lua_TValue, ptr %30, i64 1
  store ptr %incdec.ptr.i27, ptr %0, align 8
  %tt.i28 = getelementptr inbounds %struct.lua_TValue, ptr %30, i64 0, i32 1
  store i32 0, ptr %tt.i28, align 8
  %31 = load ptr, ptr %0, align 8
  %32 = load ptr, ptr %1, align 8
  %add.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %32, i64 %idx.ext.i
  %cmp1.i = icmp ult ptr %31, %add.ptr.i
  br i1 %cmp1.i, label %while.body.i, label %lua_settop.exit, !llvm.loop !13

if.else.i:                                        ; preds = %if.then62
  %33 = load ptr, ptr %0, align 8
  %34 = sext i32 %add to i64
  %35 = getelementptr %struct.lua_TValue, ptr %33, i64 %34
  %add.ptr9.i = getelementptr %struct.lua_TValue, ptr %35, i64 1
  br label %lua_settop.exit

lua_settop.exit:                                  ; preds = %while.body.i, %while.cond.preheader.i, %if.else.i
  %add.ptr9.sink.i = phi ptr [ %add.ptr9.i, %if.else.i ], [ %add.ptr10.i, %while.cond.preheader.i ], [ %add.ptr.i, %while.body.i ]
  store ptr %add.ptr9.sink.i, ptr %0, align 8
  call fastcc void @errfile(ptr noundef nonnull %L, ptr noundef nonnull @.str.203, i32 noundef %add)
  br label %return

if.end64:                                         ; preds = %if.end60
  %cmp.i.i29 = icmp sgt i32 %conv.i, -1
  br i1 %cmp.i.i29, label %if.then.i.i, label %if.else3.i.i

if.then.i.i:                                      ; preds = %if.end64
  %36 = load ptr, ptr %1, align 8
  %37 = zext nneg i32 %add to i64
  %38 = getelementptr %struct.lua_TValue, ptr %36, i64 %37
  %add.ptr.i.i = getelementptr %struct.lua_TValue, ptr %38, i64 -1
  %39 = load ptr, ptr %0, align 8
  %cmp1.not.i.i = icmp ult ptr %add.ptr.i.i, %39
  %add.ptr.luaO_nilobject_.i.i = select i1 %cmp1.not.i.i, ptr %add.ptr.i.i, ptr @luaO_nilobject_
  br label %index2adr.exit.i

if.else3.i.i:                                     ; preds = %if.end64
  %cmp4.i.i30 = icmp ugt i32 %conv.i, -10001
  br i1 %cmp4.i.i30, label %if.then5.i.i, label %if.else9.i.i

if.then5.i.i:                                     ; preds = %if.else3.i.i
  %40 = load ptr, ptr %0, align 8
  %idx.ext7.i.i = sext i32 %add to i64
  %add.ptr8.i.i = getelementptr inbounds %struct.lua_TValue, ptr %40, i64 %idx.ext7.i.i
  br label %index2adr.exit.i

if.else9.i.i:                                     ; preds = %if.else3.i.i
  switch i32 %conv.i, label %sw.default.i.i [
    i32 -10001, label %sw.bb.i.i
    i32 -10002, label %sw.bb10.i.i
    i32 -10003, label %sw.bb15.i.i
  ]

sw.bb.i.i:                                        ; preds = %if.else9.i.i
  %41 = load ptr, ptr %l_G.i.i.i, align 8
  %l_registry.i.i = getelementptr inbounds %struct.global_State, ptr %41, i64 0, i32 20
  br label %index2adr.exit.i

sw.bb10.i.i:                                      ; preds = %if.else9.i.i
  %ci.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %42 = load ptr, ptr %ci.i.i, align 8
  %func11.i.i = getelementptr inbounds %struct.CallInfo, ptr %42, i64 0, i32 1
  %43 = load ptr, ptr %func11.i.i, align 8
  %44 = load ptr, ptr %43, align 8
  %env.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23
  %env12.i.i = getelementptr inbounds %struct.CClosure, ptr %44, i64 0, i32 6
  %45 = load ptr, ptr %env12.i.i, align 8
  store ptr %45, ptr %env.i.i, align 8
  %tt.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23, i32 1
  store i32 5, ptr %tt.i.i, align 8
  br label %index2adr.exit.i

sw.bb15.i.i:                                      ; preds = %if.else9.i.i
  %l_gt.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 22
  br label %index2adr.exit.i

sw.default.i.i:                                   ; preds = %if.else9.i.i
  %ci17.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %46 = load ptr, ptr %ci17.i.i, align 8
  %func18.i.i = getelementptr inbounds %struct.CallInfo, ptr %46, i64 0, i32 1
  %47 = load ptr, ptr %func18.i.i, align 8
  %48 = load ptr, ptr %47, align 8
  %sub20.i.i = sub nuw nsw i32 -10003, %conv.i
  %nupvalues.i.i = getelementptr inbounds %struct.CClosure, ptr %48, i64 0, i32 4
  %49 = load i8, ptr %nupvalues.i.i, align 1
  %conv.i.i36 = zext i8 %49 to i32
  %cmp21.not.i.i = icmp ugt i32 %sub20.i.i, %conv.i.i36
  %sub23.i.i37 = sub nsw i64 4294957292, %sub.ptr.div.i
  %idxprom.i.i = and i64 %sub23.i.i37, 4294967295
  %arrayidx.i.i = getelementptr inbounds %struct.CClosure, ptr %48, i64 0, i32 8, i64 %idxprom.i.i
  %cond.i.i = select i1 %cmp21.not.i.i, ptr @luaO_nilobject_, ptr %arrayidx.i.i
  br label %index2adr.exit.i

index2adr.exit.i:                                 ; preds = %sw.default.i.i, %sw.bb15.i.i, %sw.bb10.i.i, %sw.bb.i.i, %if.then5.i.i, %if.then.i.i
  %retval.0.i.i = phi ptr [ %add.ptr8.i.i, %if.then5.i.i ], [ %cond.i.i, %sw.default.i.i ], [ %l_gt.i.i, %sw.bb15.i.i ], [ %env.i.i, %sw.bb10.i.i ], [ %l_registry.i.i, %sw.bb.i.i ], [ %add.ptr.luaO_nilobject_.i.i, %if.then.i.i ]
  %incdec.ptr7.i = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i.i, i64 1
  %50 = load ptr, ptr %0, align 8
  %cmp8.i = icmp ult ptr %incdec.ptr7.i, %50
  br i1 %cmp8.i, label %while.body.i32, label %lua_remove.exit

while.body.i32:                                   ; preds = %index2adr.exit.i, %while.body.i32
  %incdec.ptr10.i = phi ptr [ %incdec.ptr.i34, %while.body.i32 ], [ %incdec.ptr7.i, %index2adr.exit.i ]
  %p.09.i = phi ptr [ %incdec.ptr10.i, %while.body.i32 ], [ %retval.0.i.i, %index2adr.exit.i ]
  %51 = load i64, ptr %incdec.ptr10.i, align 8
  store i64 %51, ptr %p.09.i, align 8
  %tt.i33 = getelementptr inbounds %struct.lua_TValue, ptr %p.09.i, i64 1, i32 1
  %52 = load i32, ptr %tt.i33, align 8
  %tt2.i = getelementptr inbounds %struct.lua_TValue, ptr %p.09.i, i64 0, i32 1
  store i32 %52, ptr %tt2.i, align 8
  %incdec.ptr.i34 = getelementptr inbounds %struct.lua_TValue, ptr %incdec.ptr10.i, i64 1
  %53 = load ptr, ptr %0, align 8
  %cmp.i35 = icmp ult ptr %incdec.ptr.i34, %53
  br i1 %cmp.i35, label %while.body.i32, label %lua_remove.exit, !llvm.loop !11

lua_remove.exit:                                  ; preds = %while.body.i32, %index2adr.exit.i
  %.lcssa.i = phi ptr [ %50, %index2adr.exit.i ], [ %53, %while.body.i32 ]
  %incdec.ptr4.i = getelementptr inbounds %struct.lua_TValue, ptr %.lcssa.i, i64 -1
  store ptr %incdec.ptr4.i, ptr %0, align 8
  br label %return

return:                                           ; preds = %lua_remove.exit, %lua_settop.exit, %if.then33, %if.then6
  %retval.0 = phi i32 [ 6, %if.then33 ], [ 6, %lua_settop.exit ], [ %call.i.i25, %lua_remove.exit ], [ 6, %if.then6 ]
  ret i32 %retval.0
}

; Function Attrs: nofree nounwind
declare noundef i32 @fprintf(ptr nocapture noundef, ptr nocapture noundef readonly, ...) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define internal fastcc ptr @lua_tolstring(ptr noundef %L, i32 noundef %idx, ptr noundef writeonly %len) unnamed_addr #0 {
entry:
  %s.i = alloca [32 x i8], align 16
  %cmp.i = icmp sgt i32 %idx, 0
  br i1 %cmp.i, label %if.then.i, label %if.else3.i

if.then.i:                                        ; preds = %entry
  %base.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i, align 8
  %1 = zext nneg i32 %idx to i64
  %2 = getelementptr %struct.lua_TValue, ptr %0, i64 %1
  %add.ptr.i = getelementptr %struct.lua_TValue, ptr %2, i64 -1
  %top.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %3 = load ptr, ptr %top.i, align 8
  %cmp1.not.i = icmp ult ptr %add.ptr.i, %3
  %add.ptr.luaO_nilobject_.i = select i1 %cmp1.not.i, ptr %add.ptr.i, ptr @luaO_nilobject_
  br label %index2adr.exit

if.else3.i:                                       ; preds = %entry
  %cmp4.i = icmp sgt i32 %idx, -10000
  br i1 %cmp4.i, label %if.then5.i, label %if.else9.i

if.then5.i:                                       ; preds = %if.else3.i
  %top6.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %4 = load ptr, ptr %top6.i, align 8
  %idx.ext7.i = sext i32 %idx to i64
  %add.ptr8.i = getelementptr inbounds %struct.lua_TValue, ptr %4, i64 %idx.ext7.i
  br label %index2adr.exit

if.else9.i:                                       ; preds = %if.else3.i
  switch i32 %idx, label %sw.default.i [
    i32 -10000, label %sw.bb.i
    i32 -10001, label %sw.bb10.i
    i32 -10002, label %sw.bb15.i
  ]

sw.bb.i:                                          ; preds = %if.else9.i
  %l_G.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %5 = load ptr, ptr %l_G.i, align 8
  %l_registry.i = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 20
  br label %index2adr.exit

sw.bb10.i:                                        ; preds = %if.else9.i
  %ci.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %6 = load ptr, ptr %ci.i, align 8
  %func11.i = getelementptr inbounds %struct.CallInfo, ptr %6, i64 0, i32 1
  %7 = load ptr, ptr %func11.i, align 8
  %8 = load ptr, ptr %7, align 8
  %env.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23
  %env12.i = getelementptr inbounds %struct.CClosure, ptr %8, i64 0, i32 6
  %9 = load ptr, ptr %env12.i, align 8
  store ptr %9, ptr %env.i, align 8
  %tt.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23, i32 1
  store i32 5, ptr %tt.i, align 8
  br label %index2adr.exit

sw.bb15.i:                                        ; preds = %if.else9.i
  %l_gt.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 22
  br label %index2adr.exit

sw.default.i:                                     ; preds = %if.else9.i
  %ci17.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %10 = load ptr, ptr %ci17.i, align 8
  %func18.i = getelementptr inbounds %struct.CallInfo, ptr %10, i64 0, i32 1
  %11 = load ptr, ptr %func18.i, align 8
  %12 = load ptr, ptr %11, align 8
  %sub20.i = sub nuw nsw i32 -10002, %idx
  %nupvalues.i = getelementptr inbounds %struct.CClosure, ptr %12, i64 0, i32 4
  %13 = load i8, ptr %nupvalues.i, align 1
  %conv.i = zext i8 %13 to i32
  %cmp21.not.i = icmp ugt i32 %sub20.i, %conv.i
  %sub23.i = sub nuw nsw i32 -10003, %idx
  %idxprom.i = zext nneg i32 %sub23.i to i64
  %arrayidx.i = getelementptr inbounds %struct.CClosure, ptr %12, i64 0, i32 8, i64 %idxprom.i
  %cond.i = select i1 %cmp21.not.i, ptr @luaO_nilobject_, ptr %arrayidx.i
  br label %index2adr.exit

index2adr.exit:                                   ; preds = %if.then.i, %if.then5.i, %sw.bb.i, %sw.bb10.i, %sw.bb15.i, %sw.default.i
  %retval.0.i = phi ptr [ %add.ptr8.i, %if.then5.i ], [ %cond.i, %sw.default.i ], [ %l_gt.i, %sw.bb15.i ], [ %env.i, %sw.bb10.i ], [ %l_registry.i, %sw.bb.i ], [ %add.ptr.luaO_nilobject_.i, %if.then.i ]
  %tt = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i, i64 0, i32 1
  %14 = load i32, ptr %tt, align 8
  %cmp = icmp eq i32 %14, 4
  br i1 %cmp, label %if.end11, label %if.then

if.then:                                          ; preds = %index2adr.exit
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %s.i)
  %cmp.i14 = icmp eq i32 %14, 3
  br i1 %cmp.i14, label %if.end5, label %if.then2

if.then2:                                         ; preds = %if.then
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %s.i)
  %cmp3.not = icmp eq ptr %len, null
  br i1 %cmp3.not, label %return, label %if.then4

if.then4:                                         ; preds = %if.then2
  store i64 0, ptr %len, align 8
  br label %return

if.end5:                                          ; preds = %if.then
  %15 = load double, ptr %retval.0.i, align 8
  %call.i = call i32 (ptr, ptr, ...) @sprintf(ptr noundef nonnull dereferenceable(1) %s.i, ptr noundef nonnull dereferenceable(1) @.str.16, double noundef %15) #35
  %call3.i = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %s.i) #34
  %call4.i = call fastcc ptr @luaS_newlstr(ptr noundef %L, ptr noundef nonnull %s.i, i64 noundef %call3.i)
  store ptr %call4.i, ptr %retval.0.i, align 8
  store i32 4, ptr %tt, align 8
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %s.i)
  %l_G = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %16 = load ptr, ptr %l_G, align 8
  %totalbytes = getelementptr inbounds %struct.global_State, ptr %16, i64 0, i32 14
  %17 = load i64, ptr %totalbytes, align 8
  %GCthreshold = getelementptr inbounds %struct.global_State, ptr %16, i64 0, i32 13
  %18 = load i64, ptr %GCthreshold, align 8
  %cmp7.not = icmp ult i64 %17, %18
  br i1 %cmp7.not, label %if.end9, label %if.then8

if.then8:                                         ; preds = %if.end5
  %gcstepmul.i = getelementptr inbounds %struct.global_State, ptr %16, i64 0, i32 18
  %19 = load i32, ptr %gcstepmul.i, align 4
  %mul.i = mul i32 %19, 10
  %conv.i17 = zext i32 %mul.i to i64
  %cmp.i18 = icmp eq i32 %mul.i, 0
  %spec.store.select.i = select i1 %cmp.i18, i64 9223372036854775806, i64 %conv.i17
  %sub.i = sub i64 %17, %18
  %gcdept.i = getelementptr inbounds %struct.global_State, ptr %16, i64 0, i32 16
  %20 = load i64, ptr %gcdept.i, align 8
  %add.i = add i64 %sub.i, %20
  store i64 %add.i, ptr %gcdept.i, align 8
  %gcstate.i = getelementptr inbounds %struct.global_State, ptr %16, i64 0, i32 4
  br label %do.body.i

do.body.i:                                        ; preds = %do.body.i, %if.then8
  %lim.0.i = phi i64 [ %spec.store.select.i, %if.then8 ], [ %sub2.i, %do.body.i ]
  %call.i19 = tail call fastcc i64 @singlestep(ptr noundef %L)
  %sub2.i = sub nsw i64 %lim.0.i, %call.i19
  %21 = load i8, ptr %gcstate.i, align 1
  %cmp4.i20 = icmp ne i8 %21, 0
  %cmp8.i = icmp sgt i64 %sub2.i, 0
  %or.cond.i = select i1 %cmp4.i20, i1 %cmp8.i, i1 false
  br i1 %or.cond.i, label %do.body.i, label %do.end.i, !llvm.loop !6

do.end.i:                                         ; preds = %do.body.i
  br i1 %cmp4.i20, label %if.then14.i, label %if.else27.i

if.then14.i:                                      ; preds = %do.end.i
  %22 = load i64, ptr %gcdept.i, align 8
  %cmp16.i = icmp ult i64 %22, 1024
  br i1 %cmp16.i, label %if.then18.i, label %if.else.i21

if.then18.i:                                      ; preds = %if.then14.i
  %23 = load i64, ptr %totalbytes, align 8
  %add20.i = add i64 %23, 1024
  br label %luaC_step.exit

if.else.i21:                                      ; preds = %if.then14.i
  %sub23.i22 = add i64 %22, -1024
  store i64 %sub23.i22, ptr %gcdept.i, align 8
  %24 = load i64, ptr %totalbytes, align 8
  br label %luaC_step.exit

if.else27.i:                                      ; preds = %do.end.i
  %estimate.i = getelementptr inbounds %struct.global_State, ptr %16, i64 0, i32 15
  %25 = load i64, ptr %estimate.i, align 8
  %div.i = udiv i64 %25, 100
  %gcpause.i = getelementptr inbounds %struct.global_State, ptr %16, i64 0, i32 17
  %26 = load i32, ptr %gcpause.i, align 8
  %conv28.i = sext i32 %26 to i64
  %mul29.i = mul i64 %div.i, %conv28.i
  br label %luaC_step.exit

luaC_step.exit:                                   ; preds = %if.then18.i, %if.else.i21, %if.else27.i
  %add20.sink.i = phi i64 [ %add20.i, %if.then18.i ], [ %24, %if.else.i21 ], [ %mul29.i, %if.else27.i ]
  store i64 %add20.sink.i, ptr %GCthreshold, align 8
  br label %if.end9

if.end9:                                          ; preds = %luaC_step.exit, %if.end5
  br i1 %cmp.i, label %if.then.i54, label %if.else3.i24

if.then.i54:                                      ; preds = %if.end9
  %base.i55 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %27 = load ptr, ptr %base.i55, align 8
  %28 = zext nneg i32 %idx to i64
  %29 = getelementptr %struct.lua_TValue, ptr %27, i64 %28
  %add.ptr.i56 = getelementptr %struct.lua_TValue, ptr %29, i64 -1
  %top.i57 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %30 = load ptr, ptr %top.i57, align 8
  %cmp1.not.i58 = icmp ult ptr %add.ptr.i56, %30
  %add.ptr.luaO_nilobject_.i59 = select i1 %cmp1.not.i58, ptr %add.ptr.i56, ptr @luaO_nilobject_
  br label %if.end11

if.else3.i24:                                     ; preds = %if.end9
  %cmp4.i25 = icmp sgt i32 %idx, -10000
  br i1 %cmp4.i25, label %if.then5.i50, label %if.else9.i26

if.then5.i50:                                     ; preds = %if.else3.i24
  %top6.i51 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %31 = load ptr, ptr %top6.i51, align 8
  %idx.ext7.i52 = sext i32 %idx to i64
  %add.ptr8.i53 = getelementptr inbounds %struct.lua_TValue, ptr %31, i64 %idx.ext7.i52
  br label %if.end11

if.else9.i26:                                     ; preds = %if.else3.i24
  switch i32 %idx, label %sw.default.i39 [
    i32 -10000, label %sw.bb.i36
    i32 -10001, label %sw.bb10.i30
    i32 -10002, label %sw.bb15.i27
  ]

sw.bb.i36:                                        ; preds = %if.else9.i26
  %32 = load ptr, ptr %l_G, align 8
  %l_registry.i38 = getelementptr inbounds %struct.global_State, ptr %32, i64 0, i32 20
  br label %if.end11

sw.bb10.i30:                                      ; preds = %if.else9.i26
  %ci.i31 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %33 = load ptr, ptr %ci.i31, align 8
  %func11.i32 = getelementptr inbounds %struct.CallInfo, ptr %33, i64 0, i32 1
  %34 = load ptr, ptr %func11.i32, align 8
  %35 = load ptr, ptr %34, align 8
  %env.i33 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23
  %env12.i34 = getelementptr inbounds %struct.CClosure, ptr %35, i64 0, i32 6
  %36 = load ptr, ptr %env12.i34, align 8
  store ptr %36, ptr %env.i33, align 8
  %tt.i35 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23, i32 1
  store i32 5, ptr %tt.i35, align 8
  br label %if.end11

sw.bb15.i27:                                      ; preds = %if.else9.i26
  %l_gt.i28 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 22
  br label %if.end11

sw.default.i39:                                   ; preds = %if.else9.i26
  %ci17.i40 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %37 = load ptr, ptr %ci17.i40, align 8
  %func18.i41 = getelementptr inbounds %struct.CallInfo, ptr %37, i64 0, i32 1
  %38 = load ptr, ptr %func18.i41, align 8
  %39 = load ptr, ptr %38, align 8
  %sub20.i42 = sub nuw nsw i32 -10002, %idx
  %nupvalues.i43 = getelementptr inbounds %struct.CClosure, ptr %39, i64 0, i32 4
  %40 = load i8, ptr %nupvalues.i43, align 1
  %conv.i44 = zext i8 %40 to i32
  %cmp21.not.i45 = icmp ugt i32 %sub20.i42, %conv.i44
  %sub23.i46 = sub nuw nsw i32 -10003, %idx
  %idxprom.i47 = zext nneg i32 %sub23.i46 to i64
  %arrayidx.i48 = getelementptr inbounds %struct.CClosure, ptr %39, i64 0, i32 8, i64 %idxprom.i47
  %cond.i49 = select i1 %cmp21.not.i45, ptr @luaO_nilobject_, ptr %arrayidx.i48
  br label %if.end11

if.end11:                                         ; preds = %sw.default.i39, %sw.bb15.i27, %sw.bb10.i30, %sw.bb.i36, %if.then5.i50, %if.then.i54, %index2adr.exit
  %o.0 = phi ptr [ %retval.0.i, %index2adr.exit ], [ %add.ptr8.i53, %if.then5.i50 ], [ %cond.i49, %sw.default.i39 ], [ %l_gt.i28, %sw.bb15.i27 ], [ %env.i33, %sw.bb10.i30 ], [ %l_registry.i38, %sw.bb.i36 ], [ %add.ptr.luaO_nilobject_.i59, %if.then.i54 ]
  %cmp12.not = icmp eq ptr %len, null
  %.pre63 = load ptr, ptr %o.0, align 8
  br i1 %cmp12.not, label %if.end15, label %if.then13

if.then13:                                        ; preds = %if.end11
  %len14 = getelementptr inbounds %struct.anon.0, ptr %.pre63, i64 0, i32 5
  %41 = load i64, ptr %len14, align 8
  store i64 %41, ptr %len, align 8
  %.pre = load ptr, ptr %o.0, align 8
  br label %if.end15

if.end15:                                         ; preds = %if.then13, %if.end11
  %42 = phi ptr [ %.pre, %if.then13 ], [ %.pre63, %if.end11 ]
  %add.ptr = getelementptr inbounds %union.TString, ptr %42, i64 1
  br label %return

return:                                           ; preds = %if.then2, %if.then4, %if.end15
  %retval.0 = phi ptr [ %add.ptr, %if.end15 ], [ null, %if.then4 ], [ null, %if.then2 ]
  ret ptr %retval.0
}

; Function Attrs: mustprogress nounwind willreturn memory(argmem: readwrite, inaccessiblemem: readwrite) uwtable
define internal noalias ptr @l_alloc(ptr nocapture readnone %ud, ptr nocapture noundef %ptr, i64 %osize, i64 noundef %nsize) #2 {
entry:
  %cmp = icmp eq i64 %nsize, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  tail call void @free(ptr noundef %ptr) #35
  br label %return

if.else:                                          ; preds = %entry
  %call = tail call ptr @realloc(ptr noundef %ptr, i64 noundef %nsize) #36
  br label %return

return:                                           ; preds = %if.else, %if.then
  %retval.0 = phi ptr [ null, %if.then ], [ %call, %if.else ]
  ret ptr %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @panic(ptr noundef %L) #0 {
entry:
  %0 = load ptr, ptr @stderr, align 8
  %call = tail call fastcc ptr @lua_tolstring(ptr noundef %L, i32 noundef -1, ptr noundef null)
  %call1 = tail call i32 (ptr, ptr, ...) @fprintf(ptr noundef %0, ptr noundef nonnull @.str.91, ptr noundef %call) #33
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @luaD_rawrunprotected(ptr noundef %L, ptr nocapture noundef readonly %f, ptr noundef %ud) unnamed_addr #0 {
entry:
  %lj = alloca %struct.lua_longjmp, align 8
  %status = getelementptr inbounds %struct.lua_longjmp, ptr %lj, i64 0, i32 2
  store volatile i32 0, ptr %status, align 8
  %errorJmp = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 26
  %0 = load ptr, ptr %errorJmp, align 8
  store ptr %0, ptr %lj, align 8
  store ptr %lj, ptr %errorJmp, align 8
  %b = getelementptr inbounds %struct.lua_longjmp, ptr %lj, i64 0, i32 1
  %call = call i32 @_setjmp(ptr noundef nonnull %b) #37
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void %f(ptr noundef nonnull %L, ptr noundef %ud) #35, !callees !14
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = load ptr, ptr %lj, align 8
  store ptr %1, ptr %errorJmp, align 8
  %2 = load volatile i32, ptr %status, align 8
  ret i32 %2
}

; Function Attrs: nounwind uwtable
define internal void @f_luaopen(ptr noundef %L, ptr nocapture readnone %ud) #0 {
entry:
  %l_G = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %0 = load ptr, ptr %l_G, align 8
  %frealloc.i.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 1
  %1 = load ptr, ptr %frealloc.i.i, align 8
  %ud.i.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 2
  %2 = load ptr, ptr %ud.i.i, align 8
  %call.i.i = tail call ptr %1(ptr noundef %2, ptr noundef null, i64 noundef 0, i64 noundef 320) #35
  %cmp.i.i = icmp eq ptr %call.i.i, null
  br i1 %cmp.i.i, label %if.then.i.i, label %luaM_realloc_.exit.i

if.then.i.i:                                      ; preds = %entry
  %errorJmp.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 26
  %3 = load ptr, ptr %errorJmp.i.i.i, align 8
  %tobool.not.i.i.i = icmp eq ptr %3, null
  br i1 %tobool.not.i.i.i, label %if.else.i.i.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %if.then.i.i
  %status.i.i.i = getelementptr inbounds %struct.lua_longjmp, ptr %3, i64 0, i32 2
  store volatile i32 4, ptr %status.i.i.i, align 8
  %4 = load ptr, ptr %errorJmp.i.i.i, align 8
  %b.i.i.i = getelementptr inbounds %struct.lua_longjmp, ptr %4, i64 0, i32 1
  tail call void @longjmp(ptr noundef nonnull %b.i.i.i, i32 noundef 1) #38
  unreachable

if.else.i.i.i:                                    ; preds = %if.then.i.i
  %status3.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 3
  store i8 4, ptr %status3.i.i.i, align 2
  %5 = load ptr, ptr %l_G, align 8
  %panic.i.i.i = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 19
  %6 = load ptr, ptr %panic.i.i.i, align 8
  %tobool4.not.i.i.i = icmp eq ptr %6, null
  br i1 %tobool4.not.i.i.i, label %if.end.i.i.i, label %if.then5.i.i.i

if.then5.i.i.i:                                   ; preds = %if.else.i.i.i
  tail call fastcc void @resetstack(ptr noundef nonnull %L, i32 noundef 4)
  %7 = load ptr, ptr %l_G, align 8
  %panic7.i.i.i = getelementptr inbounds %struct.global_State, ptr %7, i64 0, i32 19
  %8 = load ptr, ptr %panic7.i.i.i, align 8
  %call.i.i.i = tail call i32 %8(ptr noundef nonnull %L) #35
  br label %if.end.i.i.i

if.end.i.i.i:                                     ; preds = %if.then5.i.i.i, %if.else.i.i.i
  tail call void @exit(i32 noundef 1) #38
  unreachable

luaM_realloc_.exit.i:                             ; preds = %entry
  %totalbytes.i.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 14
  %9 = load i64, ptr %totalbytes.i.i, align 8
  %add.i.i = add i64 %9, 320
  store i64 %add.i.i, ptr %totalbytes.i.i, align 8
  %base_ci.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 12
  store ptr %call.i.i, ptr %base_ci.i, align 8
  %ci.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  store ptr %call.i.i, ptr %ci.i, align 8
  %size_ci.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 14
  store i32 8, ptr %size_ci.i, align 4
  %add.ptr4.i = getelementptr inbounds %struct.CallInfo, ptr %call.i.i, i64 7
  %end_ci.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 11
  store ptr %add.ptr4.i, ptr %end_ci.i, align 8
  %10 = load ptr, ptr %l_G, align 8
  %frealloc.i24.i = getelementptr inbounds %struct.global_State, ptr %10, i64 0, i32 1
  %11 = load ptr, ptr %frealloc.i24.i, align 8
  %ud.i25.i = getelementptr inbounds %struct.global_State, ptr %10, i64 0, i32 2
  %12 = load ptr, ptr %ud.i25.i, align 8
  %call.i26.i = tail call ptr %11(ptr noundef %12, ptr noundef null, i64 noundef 0, i64 noundef 720) #35
  %cmp.i27.i = icmp eq ptr %call.i26.i, null
  br i1 %cmp.i27.i, label %if.then.i30.i, label %stack_init.exit

if.then.i30.i:                                    ; preds = %luaM_realloc_.exit.i
  %errorJmp.i.i31.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 26
  %13 = load ptr, ptr %errorJmp.i.i31.i, align 8
  %tobool.not.i.i32.i = icmp eq ptr %13, null
  br i1 %tobool.not.i.i32.i, label %if.else.i.i36.i, label %if.then.i.i33.i

if.then.i.i33.i:                                  ; preds = %if.then.i30.i
  %status.i.i34.i = getelementptr inbounds %struct.lua_longjmp, ptr %13, i64 0, i32 2
  store volatile i32 4, ptr %status.i.i34.i, align 8
  %14 = load ptr, ptr %errorJmp.i.i31.i, align 8
  %b.i.i35.i = getelementptr inbounds %struct.lua_longjmp, ptr %14, i64 0, i32 1
  tail call void @longjmp(ptr noundef nonnull %b.i.i35.i, i32 noundef 1) #38
  unreachable

if.else.i.i36.i:                                  ; preds = %if.then.i30.i
  %status3.i.i37.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 3
  store i8 4, ptr %status3.i.i37.i, align 2
  %15 = load ptr, ptr %l_G, align 8
  %panic.i.i38.i = getelementptr inbounds %struct.global_State, ptr %15, i64 0, i32 19
  %16 = load ptr, ptr %panic.i.i38.i, align 8
  %tobool4.not.i.i39.i = icmp eq ptr %16, null
  br i1 %tobool4.not.i.i39.i, label %if.end.i.i43.i, label %if.then5.i.i40.i

if.then5.i.i40.i:                                 ; preds = %if.else.i.i36.i
  tail call fastcc void @resetstack(ptr noundef nonnull %L, i32 noundef 4)
  %17 = load ptr, ptr %l_G, align 8
  %panic7.i.i41.i = getelementptr inbounds %struct.global_State, ptr %17, i64 0, i32 19
  %18 = load ptr, ptr %panic7.i.i41.i, align 8
  %call.i.i42.i = tail call i32 %18(ptr noundef nonnull %L) #35
  br label %if.end.i.i43.i

if.end.i.i43.i:                                   ; preds = %if.then5.i.i40.i, %if.else.i.i36.i
  tail call void @exit(i32 noundef 1) #38
  unreachable

stack_init.exit:                                  ; preds = %luaM_realloc_.exit.i
  %totalbytes.i28.i = getelementptr inbounds %struct.global_State, ptr %10, i64 0, i32 14
  %19 = load i64, ptr %totalbytes.i28.i, align 8
  %add.i29.i = add i64 %19, 720
  store i64 %add.i29.i, ptr %totalbytes.i28.i, align 8
  %stack.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 10
  store ptr %call.i26.i, ptr %stack.i, align 8
  %stacksize.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 13
  store i32 45, ptr %stacksize.i, align 8
  %top.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  store ptr %call.i26.i, ptr %top.i, align 8
  %add.ptr11.i = getelementptr inbounds %struct.lua_TValue, ptr %call.i26.i, i64 39
  %stack_last.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 9
  store ptr %add.ptr11.i, ptr %stack_last.i, align 8
  %20 = load ptr, ptr %ci.i, align 8
  %func.i = getelementptr inbounds %struct.CallInfo, ptr %20, i64 0, i32 1
  store ptr %call.i26.i, ptr %func.i, align 8
  %21 = load ptr, ptr %top.i, align 8
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %21, i64 1
  store ptr %incdec.ptr.i, ptr %top.i, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %21, i64 0, i32 1
  store i32 0, ptr %tt.i, align 8
  %22 = load ptr, ptr %top.i, align 8
  %23 = load ptr, ptr %ci.i, align 8
  store ptr %22, ptr %23, align 8
  %base17.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  store ptr %22, ptr %base17.i, align 8
  %add.ptr19.i = getelementptr inbounds %struct.lua_TValue, ptr %22, i64 20
  %24 = load ptr, ptr %ci.i, align 8
  %top21.i = getelementptr inbounds %struct.CallInfo, ptr %24, i64 0, i32 2
  store ptr %add.ptr19.i, ptr %top21.i, align 8
  %l_gt = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 22
  %call = tail call fastcc ptr @luaH_new(ptr noundef nonnull %L, i32 noundef 0, i32 noundef 2)
  store ptr %call, ptr %l_gt, align 8
  %tt = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 22, i32 1
  store i32 5, ptr %tt, align 8
  %25 = load ptr, ptr %l_G, align 8
  %l_registry = getelementptr inbounds %struct.global_State, ptr %25, i64 0, i32 20
  %call3 = tail call fastcc ptr @luaH_new(ptr noundef nonnull %L, i32 noundef 0, i32 noundef 2)
  store ptr %call3, ptr %l_registry, align 8
  %tt5 = getelementptr inbounds %struct.global_State, ptr %25, i64 0, i32 20, i32 1
  store i32 5, ptr %tt5, align 8
  tail call fastcc void @luaS_resize(ptr noundef nonnull %L, i32 noundef 32)
  br label %for.body.i

for.body.i:                                       ; preds = %for.body.i, %stack_init.exit
  %indvars.iv.i = phi i64 [ 0, %stack_init.exit ], [ %indvars.iv.next.i, %for.body.i ]
  %arrayidx.i = getelementptr inbounds [17 x ptr], ptr @luaT_init.luaT_eventname, i64 0, i64 %indvars.iv.i
  %26 = load ptr, ptr %arrayidx.i, align 8
  %call.i = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %26) #34
  %call3.i = tail call fastcc ptr @luaS_newlstr(ptr noundef nonnull %L, ptr noundef %26, i64 noundef %call.i)
  %27 = load ptr, ptr %l_G, align 8
  %arrayidx5.i = getelementptr inbounds %struct.global_State, ptr %27, i64 0, i32 24, i64 %indvars.iv.i
  store ptr %call3.i, ptr %arrayidx5.i, align 8
  %28 = load ptr, ptr %l_G, align 8
  %arrayidx9.i = getelementptr inbounds %struct.global_State, ptr %28, i64 0, i32 24, i64 %indvars.iv.i
  %29 = load ptr, ptr %arrayidx9.i, align 8
  %marked.i = getelementptr inbounds %struct.anon.0, ptr %29, i64 0, i32 2
  %30 = load i8, ptr %marked.i, align 1
  %31 = or i8 %30, 32
  store i8 %31, ptr %marked.i, align 1
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next.i, 17
  br i1 %exitcond.not.i, label %for.body.i14, label %for.body.i, !llvm.loop !15

for.body.i14:                                     ; preds = %for.body.i, %for.body.i14
  %indvars.iv.i15 = phi i64 [ %indvars.iv.next.i20, %for.body.i14 ], [ 0, %for.body.i ]
  %arrayidx.i16 = getelementptr inbounds [32 x ptr], ptr @luaX_tokens, i64 0, i64 %indvars.iv.i15
  %32 = load ptr, ptr %arrayidx.i16, align 8
  %call.i17 = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %32) #34
  %call3.i18 = tail call fastcc ptr @luaS_newlstr(ptr noundef %L, ptr noundef %32, i64 noundef %call.i17)
  %marked.i19 = getelementptr inbounds %struct.anon.0, ptr %call3.i18, i64 0, i32 2
  %33 = load i8, ptr %marked.i19, align 1
  %34 = or i8 %33, 32
  store i8 %34, ptr %marked.i19, align 1
  %indvars.iv.next.i20 = add nuw nsw i64 %indvars.iv.i15, 1
  %reserved.i = getelementptr inbounds %struct.anon.0, ptr %call3.i18, i64 0, i32 3
  %35 = trunc i64 %indvars.iv.next.i20 to i8
  store i8 %35, ptr %reserved.i, align 2
  %exitcond.not.i21 = icmp eq i64 %indvars.iv.next.i20, 21
  br i1 %exitcond.not.i21, label %luaX_init.exit, label %for.body.i14, !llvm.loop !16

luaX_init.exit:                                   ; preds = %for.body.i14
  %call6 = tail call fastcc ptr @luaS_newlstr(ptr noundef %L, ptr noundef nonnull @.str.3, i64 noundef 17)
  %marked = getelementptr inbounds %struct.anon.0, ptr %call6, i64 0, i32 2
  %36 = load i8, ptr %marked, align 1
  %37 = or i8 %36, 32
  store i8 %37, ptr %marked, align 1
  %38 = load i64, ptr %totalbytes.i.i, align 8
  %mul = shl i64 %38, 2
  %GCthreshold = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 13
  store i64 %mul, ptr %GCthreshold, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @close_state(ptr noundef %L) unnamed_addr #0 {
entry:
  %l_G = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %0 = load ptr, ptr %l_G, align 8
  %stack = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 10
  %1 = load ptr, ptr %stack, align 8
  tail call fastcc void @luaF_close(ptr noundef %L, ptr noundef %1)
  %2 = load ptr, ptr %l_G, align 8
  %currentwhite.i = getelementptr inbounds %struct.global_State, ptr %2, i64 0, i32 3
  store i8 67, ptr %currentwhite.i, align 8
  %rootgc.i = getelementptr inbounds %struct.global_State, ptr %2, i64 0, i32 6
  %call.i = tail call fastcc ptr @sweeplist(ptr noundef %L, ptr noundef nonnull %rootgc.i, i64 noundef -3)
  %size.i = getelementptr inbounds %struct.stringtable, ptr %2, i64 0, i32 2
  %3 = load i32, ptr %size.i, align 4
  %cmp8.i = icmp sgt i32 %3, 0
  br i1 %cmp8.i, label %for.body.i, label %luaC_freeall.exit

for.body.i:                                       ; preds = %entry, %for.body.i
  %indvars.iv.i = phi i64 [ %indvars.iv.next.i, %for.body.i ], [ 0, %entry ]
  %4 = load ptr, ptr %2, align 8
  %arrayidx.i = getelementptr inbounds ptr, ptr %4, i64 %indvars.iv.i
  %call2.i = tail call fastcc ptr @sweeplist(ptr noundef %L, ptr noundef %arrayidx.i, i64 noundef -3)
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %5 = load i32, ptr %size.i, align 4
  %6 = sext i32 %5 to i64
  %cmp.i = icmp slt i64 %indvars.iv.next.i, %6
  br i1 %cmp.i, label %for.body.i, label %luaC_freeall.exit, !llvm.loop !17

luaC_freeall.exit:                                ; preds = %for.body.i, %entry
  %7 = load ptr, ptr %l_G, align 8
  %8 = load ptr, ptr %7, align 8
  %size = getelementptr inbounds %struct.stringtable, ptr %7, i64 0, i32 2
  %9 = load i32, ptr %size, align 4
  %conv = sext i32 %9 to i64
  %mul = shl nsw i64 %conv, 3
  %frealloc.i = getelementptr inbounds %struct.global_State, ptr %7, i64 0, i32 1
  %10 = load ptr, ptr %frealloc.i, align 8
  %ud.i = getelementptr inbounds %struct.global_State, ptr %7, i64 0, i32 2
  %11 = load ptr, ptr %ud.i, align 8
  %call.i17 = tail call ptr %10(ptr noundef %11, ptr noundef %8, i64 noundef %mul, i64 noundef 0) #35
  %totalbytes.i = getelementptr inbounds %struct.global_State, ptr %7, i64 0, i32 14
  %12 = load i64, ptr %totalbytes.i, align 8
  %add.i = sub i64 %12, %mul
  store i64 %add.i, ptr %totalbytes.i, align 8
  %buff = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 12
  %13 = load ptr, ptr %buff, align 8
  %buffsize = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 12, i32 2
  %14 = load i64, ptr %buffsize, align 8
  %15 = load ptr, ptr %l_G, align 8
  %frealloc.i20 = getelementptr inbounds %struct.global_State, ptr %15, i64 0, i32 1
  %16 = load ptr, ptr %frealloc.i20, align 8
  %ud.i21 = getelementptr inbounds %struct.global_State, ptr %15, i64 0, i32 2
  %17 = load ptr, ptr %ud.i21, align 8
  %call.i22 = tail call ptr %16(ptr noundef %17, ptr noundef %13, i64 noundef %14, i64 noundef 0) #35
  %totalbytes.i24 = getelementptr inbounds %struct.global_State, ptr %15, i64 0, i32 14
  %18 = load i64, ptr %totalbytes.i24, align 8
  %add.i26 = sub i64 %18, %14
  store i64 %add.i26, ptr %totalbytes.i24, align 8
  store ptr %call.i22, ptr %buff, align 8
  store i64 0, ptr %buffsize, align 8
  %base_ci.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 12
  %19 = load ptr, ptr %base_ci.i, align 8
  %size_ci.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 14
  %20 = load i32, ptr %size_ci.i, align 4
  %conv.i = sext i32 %20 to i64
  %mul.i = mul nsw i64 %conv.i, 40
  %21 = load ptr, ptr %l_G, align 8
  %frealloc.i.i = getelementptr inbounds %struct.global_State, ptr %21, i64 0, i32 1
  %22 = load ptr, ptr %frealloc.i.i, align 8
  %ud.i.i = getelementptr inbounds %struct.global_State, ptr %21, i64 0, i32 2
  %23 = load ptr, ptr %ud.i.i, align 8
  %call.i.i = tail call ptr %22(ptr noundef %23, ptr noundef %19, i64 noundef %mul.i, i64 noundef 0) #35
  %totalbytes.i.i = getelementptr inbounds %struct.global_State, ptr %21, i64 0, i32 14
  %24 = load i64, ptr %totalbytes.i.i, align 8
  %sub.i.i = sub i64 %24, %mul.i
  store i64 %sub.i.i, ptr %totalbytes.i.i, align 8
  %25 = load ptr, ptr %stack, align 8
  %stacksize.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 13
  %26 = load i32, ptr %stacksize.i, align 8
  %conv1.i = sext i32 %26 to i64
  %mul2.i = shl nsw i64 %conv1.i, 4
  %27 = load ptr, ptr %l_G, align 8
  %frealloc.i6.i = getelementptr inbounds %struct.global_State, ptr %27, i64 0, i32 1
  %28 = load ptr, ptr %frealloc.i6.i, align 8
  %ud.i7.i = getelementptr inbounds %struct.global_State, ptr %27, i64 0, i32 2
  %29 = load ptr, ptr %ud.i7.i, align 8
  %call.i8.i = tail call ptr %28(ptr noundef %29, ptr noundef %25, i64 noundef %mul2.i, i64 noundef 0) #35
  %totalbytes.i10.i = getelementptr inbounds %struct.global_State, ptr %27, i64 0, i32 14
  %30 = load i64, ptr %totalbytes.i10.i, align 8
  %sub.i11.i = sub i64 %30, %mul2.i
  store i64 %sub.i11.i, ptr %totalbytes.i10.i, align 8
  %frealloc = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 1
  %31 = load ptr, ptr %frealloc, align 8
  %ud = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 2
  %32 = load ptr, ptr %ud, align 8
  %call11 = tail call ptr %31(ptr noundef %32, ptr noundef %L, i64 noundef 616, i64 noundef 0) #35
  ret void
}

; Function Attrs: nounwind returns_twice
declare i32 @_setjmp(ptr noundef) local_unnamed_addr #3

; Function Attrs: nounwind uwtable
define internal fastcc ptr @luaH_new(ptr noundef %L, i32 noundef %narray, i32 noundef %nhash) unnamed_addr #0 {
entry:
  %l_G.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %0 = load ptr, ptr %l_G.i, align 8
  %frealloc.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 1
  %1 = load ptr, ptr %frealloc.i, align 8
  %ud.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 2
  %2 = load ptr, ptr %ud.i, align 8
  %call.i = tail call ptr %1(ptr noundef %2, ptr noundef null, i64 noundef 0, i64 noundef 64) #35
  %cmp.i = icmp eq ptr %call.i, null
  br i1 %cmp.i, label %if.then.i, label %luaM_realloc_.exit

if.then.i:                                        ; preds = %entry
  %errorJmp.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 26
  %3 = load ptr, ptr %errorJmp.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %3, null
  br i1 %tobool.not.i.i, label %if.else.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %if.then.i
  %status.i.i = getelementptr inbounds %struct.lua_longjmp, ptr %3, i64 0, i32 2
  store volatile i32 4, ptr %status.i.i, align 8
  %4 = load ptr, ptr %errorJmp.i.i, align 8
  %b.i.i = getelementptr inbounds %struct.lua_longjmp, ptr %4, i64 0, i32 1
  tail call void @longjmp(ptr noundef nonnull %b.i.i, i32 noundef 1) #38
  unreachable

if.else.i.i:                                      ; preds = %if.then.i
  %status3.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 3
  store i8 4, ptr %status3.i.i, align 2
  %5 = load ptr, ptr %l_G.i, align 8
  %panic.i.i = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 19
  %6 = load ptr, ptr %panic.i.i, align 8
  %tobool4.not.i.i = icmp eq ptr %6, null
  br i1 %tobool4.not.i.i, label %if.end.i.i, label %if.then5.i.i

if.then5.i.i:                                     ; preds = %if.else.i.i
  tail call fastcc void @resetstack(ptr noundef nonnull %L, i32 noundef 4)
  %7 = load ptr, ptr %l_G.i, align 8
  %panic7.i.i = getelementptr inbounds %struct.global_State, ptr %7, i64 0, i32 19
  %8 = load ptr, ptr %panic7.i.i, align 8
  %call.i.i = tail call i32 %8(ptr noundef nonnull %L) #35
  br label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then5.i.i, %if.else.i.i
  tail call void @exit(i32 noundef 1) #38
  unreachable

luaM_realloc_.exit:                               ; preds = %entry
  %totalbytes.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 14
  %9 = load i64, ptr %totalbytes.i, align 8
  %add.i = add i64 %9, 64
  store i64 %add.i, ptr %totalbytes.i, align 8
  %L.val = load ptr, ptr %l_G.i, align 8
  %rootgc.i = getelementptr inbounds %struct.global_State, ptr %L.val, i64 0, i32 6
  %10 = load ptr, ptr %rootgc.i, align 8
  store ptr %10, ptr %call.i, align 8
  store ptr %call.i, ptr %rootgc.i, align 8
  %currentwhite.i = getelementptr inbounds %struct.global_State, ptr %L.val, i64 0, i32 3
  %11 = load i8, ptr %currentwhite.i, align 8
  %12 = and i8 %11, 3
  %marked.i = getelementptr inbounds %struct.GCheader, ptr %call.i, i64 0, i32 2
  store i8 %12, ptr %marked.i, align 1
  %tt3.i = getelementptr inbounds %struct.GCheader, ptr %call.i, i64 0, i32 1
  store i8 5, ptr %tt3.i, align 8
  %metatable = getelementptr inbounds %struct.Table, ptr %call.i, i64 0, i32 5
  store ptr null, ptr %metatable, align 8
  %flags = getelementptr inbounds %struct.Table, ptr %call.i, i64 0, i32 3
  store i8 -1, ptr %flags, align 2
  %array = getelementptr inbounds %struct.Table, ptr %call.i, i64 0, i32 6
  store ptr null, ptr %array, align 8
  %sizearray = getelementptr inbounds %struct.Table, ptr %call.i, i64 0, i32 10
  store i32 0, ptr %sizearray, align 8
  %lsizenode = getelementptr inbounds %struct.Table, ptr %call.i, i64 0, i32 4
  store i8 0, ptr %lsizenode, align 1
  %node = getelementptr inbounds %struct.Table, ptr %call.i, i64 0, i32 7
  store ptr @dummynode_, ptr %node, align 8
  tail call fastcc void @setarrayvector(ptr noundef nonnull %L, ptr noundef nonnull %call.i, i32 noundef %narray)
  tail call fastcc void @setnodevector(ptr noundef nonnull %L, ptr noundef nonnull %call.i, i32 noundef %nhash)
  ret ptr %call.i
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaS_resize(ptr noundef %L, i32 noundef %newsize) unnamed_addr #0 {
entry:
  %l_G = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %0 = load ptr, ptr %l_G, align 8
  %gcstate = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 4
  %1 = load i8, ptr %gcstate, align 1
  %cmp = icmp eq i8 %1, 2
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %cmp3 = icmp sgt i32 %newsize, -2
  br i1 %cmp3, label %cond.true, label %cond.end.thread

cond.true:                                        ; preds = %if.end
  %conv5 = sext i32 %newsize to i64
  %mul = shl nsw i64 %conv5, 3
  %frealloc.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 1
  %2 = load ptr, ptr %frealloc.i, align 8
  %ud.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 2
  %3 = load ptr, ptr %ud.i, align 8
  %call.i = tail call ptr %2(ptr noundef %3, ptr noundef null, i64 noundef 0, i64 noundef %mul) #35
  %cmp.i = icmp eq ptr %call.i, null
  %cmp1.i = icmp ne i32 %newsize, 0
  %or.cond.i = and i1 %cmp1.i, %cmp.i
  br i1 %or.cond.i, label %if.then.i, label %cond.end

if.then.i:                                        ; preds = %cond.true
  %errorJmp.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 26
  %4 = load ptr, ptr %errorJmp.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %4, null
  br i1 %tobool.not.i.i, label %if.else.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %if.then.i
  %status.i.i = getelementptr inbounds %struct.lua_longjmp, ptr %4, i64 0, i32 2
  store volatile i32 4, ptr %status.i.i, align 8
  %5 = load ptr, ptr %errorJmp.i.i, align 8
  %b.i.i = getelementptr inbounds %struct.lua_longjmp, ptr %5, i64 0, i32 1
  tail call void @longjmp(ptr noundef nonnull %b.i.i, i32 noundef 1) #38
  unreachable

if.else.i.i:                                      ; preds = %if.then.i
  %status3.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 3
  store i8 4, ptr %status3.i.i, align 2
  %6 = load ptr, ptr %l_G, align 8
  %panic.i.i = getelementptr inbounds %struct.global_State, ptr %6, i64 0, i32 19
  %7 = load ptr, ptr %panic.i.i, align 8
  %tobool4.not.i.i = icmp eq ptr %7, null
  br i1 %tobool4.not.i.i, label %if.end.i.i, label %if.then5.i.i

if.then5.i.i:                                     ; preds = %if.else.i.i
  tail call fastcc void @resetstack(ptr noundef nonnull %L, i32 noundef 4)
  %8 = load ptr, ptr %l_G, align 8
  %panic7.i.i = getelementptr inbounds %struct.global_State, ptr %8, i64 0, i32 19
  %9 = load ptr, ptr %panic7.i.i, align 8
  %call.i.i = tail call i32 %9(ptr noundef nonnull %L) #35
  br label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then5.i.i, %if.else.i.i
  tail call void @exit(i32 noundef 1) #38
  unreachable

cond.end.thread:                                  ; preds = %if.end
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef nonnull %L, ptr noundef nonnull @.str.5)
  unreachable

cond.end:                                         ; preds = %cond.true
  %totalbytes.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 14
  %10 = load i64, ptr %totalbytes.i, align 8
  %add.i = add i64 %10, %mul
  store i64 %add.i, ptr %totalbytes.i, align 8
  %11 = load ptr, ptr %l_G, align 8
  %cmp833 = icmp sgt i32 %newsize, 0
  br i1 %cmp833, label %for.body.preheader, label %for.cond10.preheader

for.body.preheader:                               ; preds = %cond.end
  %12 = zext nneg i32 %newsize to i64
  %13 = shl nuw nsw i64 %12, 3
  tail call void @llvm.memset.p0.i64(ptr align 8 %call.i, i8 0, i64 %13, i1 false)
  br label %for.cond10.preheader

for.cond10.preheader:                             ; preds = %for.body.preheader, %cond.end
  %size = getelementptr inbounds %struct.stringtable, ptr %11, i64 0, i32 2
  %14 = load i32, ptr %size, align 4
  %cmp1137 = icmp sgt i32 %14, 0
  br i1 %cmp1137, label %for.body13.lr.ph, label %for.cond10.preheader.for.end25_crit_edge

for.cond10.preheader.for.end25_crit_edge:         ; preds = %for.cond10.preheader
  %.pre42 = sext i32 %14 to i64
  br label %for.end25

for.body13.lr.ph:                                 ; preds = %for.cond10.preheader
  %sub = add nsw i32 %newsize, -1
  br label %for.body13

for.body13:                                       ; preds = %for.body13.lr.ph, %for.inc23
  %15 = phi i32 [ %14, %for.body13.lr.ph ], [ %21, %for.inc23 ]
  %indvars.iv = phi i64 [ 0, %for.body13.lr.ph ], [ %indvars.iv.next, %for.inc23 ]
  %16 = load ptr, ptr %11, align 8
  %arrayidx15 = getelementptr inbounds ptr, ptr %16, i64 %indvars.iv
  %17 = load ptr, ptr %arrayidx15, align 8
  %tobool.not35 = icmp eq ptr %17, null
  br i1 %tobool.not35, label %for.inc23, label %while.body

while.body:                                       ; preds = %for.body13, %while.body
  %p.036 = phi ptr [ %18, %while.body ], [ %17, %for.body13 ]
  %18 = load ptr, ptr %p.036, align 8
  %hash17 = getelementptr inbounds %struct.anon.0, ptr %p.036, i64 0, i32 4
  %19 = load i32, ptr %hash17, align 4
  %and = and i32 %19, %sub
  %idxprom18 = sext i32 %and to i64
  %arrayidx19 = getelementptr inbounds ptr, ptr %call.i, i64 %idxprom18
  %20 = load ptr, ptr %arrayidx19, align 8
  store ptr %20, ptr %p.036, align 8
  store ptr %p.036, ptr %arrayidx19, align 8
  %tobool.not = icmp eq ptr %18, null
  br i1 %tobool.not, label %for.inc23.loopexit, label %while.body, !llvm.loop !18

for.inc23.loopexit:                               ; preds = %while.body
  %.pre = load i32, ptr %size, align 4
  br label %for.inc23

for.inc23:                                        ; preds = %for.inc23.loopexit, %for.body13
  %21 = phi i32 [ %.pre, %for.inc23.loopexit ], [ %15, %for.body13 ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %22 = sext i32 %21 to i64
  %cmp11 = icmp slt i64 %indvars.iv.next, %22
  br i1 %cmp11, label %for.body13, label %for.end25, !llvm.loop !19

for.end25:                                        ; preds = %for.inc23, %for.cond10.preheader.for.end25_crit_edge
  %conv28.pre-phi = phi i64 [ %.pre42, %for.cond10.preheader.for.end25_crit_edge ], [ %22, %for.inc23 ]
  %23 = load ptr, ptr %11, align 8
  %mul29 = shl nsw i64 %conv28.pre-phi, 3
  %24 = load ptr, ptr %l_G, align 8
  %frealloc.i28 = getelementptr inbounds %struct.global_State, ptr %24, i64 0, i32 1
  %25 = load ptr, ptr %frealloc.i28, align 8
  %ud.i29 = getelementptr inbounds %struct.global_State, ptr %24, i64 0, i32 2
  %26 = load ptr, ptr %ud.i29, align 8
  %call.i30 = tail call ptr %25(ptr noundef %26, ptr noundef %23, i64 noundef %mul29, i64 noundef 0) #35
  %totalbytes.i32 = getelementptr inbounds %struct.global_State, ptr %24, i64 0, i32 14
  %27 = load i64, ptr %totalbytes.i32, align 8
  %sub.i = sub i64 %27, %mul29
  store i64 %sub.i, ptr %totalbytes.i32, align 8
  store i32 %newsize, ptr %size, align 4
  store ptr %call.i, ptr %11, align 8
  br label %return

return:                                           ; preds = %entry, %for.end25
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc ptr @luaS_newlstr(ptr noundef %L, ptr nocapture noundef readonly %str, i64 noundef %l) unnamed_addr #0 {
entry:
  %conv = trunc i64 %l to i32
  %shr = lshr i64 %l, 5
  %add.neg = xor i64 %shr, -1
  %invariant.gep = getelementptr i8, ptr %str, i64 -1
  %cmp.not.not26 = icmp ult i64 %shr, %l
  br i1 %cmp.not.not26, label %for.body, label %for.end

for.body:                                         ; preds = %entry, %for.body
  %l1.028 = phi i64 [ %sub6, %for.body ], [ %l, %entry ]
  %h.027 = phi i32 [ %xor, %for.body ], [ %conv, %entry ]
  %shl = shl i32 %h.027, 5
  %shr2 = lshr i32 %h.027, 2
  %add3 = add i32 %shl, %shr2
  %gep = getelementptr i8, ptr %invariant.gep, i64 %l1.028
  %0 = load i8, ptr %gep, align 1
  %conv4 = zext i8 %0 to i32
  %add5 = add i32 %add3, %conv4
  %xor = xor i32 %add5, %h.027
  %sub6 = add i64 %l1.028, %add.neg
  %cmp.not.not = icmp ugt i64 %sub6, %shr
  br i1 %cmp.not.not, label %for.body, label %for.end, !llvm.loop !20

for.end:                                          ; preds = %for.body, %entry
  %h.0.lcssa = phi i32 [ %conv, %entry ], [ %xor, %for.body ]
  %l_G = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %1 = load ptr, ptr %l_G, align 8
  %2 = load ptr, ptr %1, align 8
  %size = getelementptr inbounds %struct.stringtable, ptr %1, i64 0, i32 2
  %3 = load i32, ptr %size, align 4
  %sub9 = add nsw i32 %3, -1
  %and = and i32 %sub9, %h.0.lcssa
  %idxprom = sext i32 %and to i64
  %arrayidx10 = getelementptr inbounds ptr, ptr %2, i64 %idxprom
  %o.029 = load ptr, ptr %arrayidx10, align 8
  %cmp12.not30 = icmp eq ptr %o.029, null
  br i1 %cmp12.not30, label %for.end32, label %for.body14

for.body14:                                       ; preds = %for.end, %for.inc31
  %o.031 = phi ptr [ %o.0, %for.inc31 ], [ %o.029, %for.end ]
  %len = getelementptr inbounds %struct.anon.0, ptr %o.031, i64 0, i32 5
  %4 = load i64, ptr %len, align 8
  %cmp15 = icmp eq i64 %4, %l
  br i1 %cmp15, label %land.lhs.true, label %for.inc31

land.lhs.true:                                    ; preds = %for.body14
  %add.ptr = getelementptr inbounds %union.TString, ptr %o.031, i64 1
  %bcmp = tail call i32 @bcmp(ptr %str, ptr nonnull %add.ptr, i64 %l)
  %cmp17 = icmp eq i32 %bcmp, 0
  br i1 %cmp17, label %if.then, label %for.inc31

if.then:                                          ; preds = %land.lhs.true
  %marked = getelementptr inbounds %struct.GCheader, ptr %o.031, i64 0, i32 2
  %5 = load i8, ptr %marked, align 1
  %currentwhite = getelementptr inbounds %struct.global_State, ptr %1, i64 0, i32 3
  %6 = load i8, ptr %currentwhite, align 8
  %7 = xor i8 %6, -1
  %and2324 = and i8 %5, 3
  %8 = and i8 %and2324, %7
  %tobool.not = icmp eq i8 %8, 0
  br i1 %tobool.not, label %return, label %if.then25

if.then25:                                        ; preds = %if.then
  %9 = xor i8 %5, 3
  store i8 %9, ptr %marked, align 1
  br label %return

for.inc31:                                        ; preds = %for.body14, %land.lhs.true
  %o.0 = load ptr, ptr %o.031, align 8
  %cmp12.not = icmp eq ptr %o.0, null
  br i1 %cmp12.not, label %for.end32, label %for.body14, !llvm.loop !21

for.end32:                                        ; preds = %for.inc31, %for.end
  %10 = add i64 %l, 27
  %cmp.i = icmp ult i64 %10, 26
  br i1 %cmp.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %for.end32
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef %L, ptr noundef nonnull @.str.5)
  unreachable

if.end.i:                                         ; preds = %for.end32
  %add2.i = add i64 %l, 25
  %frealloc.i.i = getelementptr inbounds %struct.global_State, ptr %1, i64 0, i32 1
  %11 = load ptr, ptr %frealloc.i.i, align 8
  %ud.i.i = getelementptr inbounds %struct.global_State, ptr %1, i64 0, i32 2
  %12 = load ptr, ptr %ud.i.i, align 8
  %call.i.i = tail call ptr %11(ptr noundef %12, ptr noundef null, i64 noundef 0, i64 noundef %add2.i) #35
  %cmp.i.i = icmp eq ptr %call.i.i, null
  %cmp1.i.i = icmp ne i64 %add2.i, 0
  %or.cond.i.i = and i1 %cmp1.i.i, %cmp.i.i
  br i1 %or.cond.i.i, label %if.then.i.i, label %luaM_realloc_.exit.i

if.then.i.i:                                      ; preds = %if.end.i
  %errorJmp.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 26
  %13 = load ptr, ptr %errorJmp.i.i.i, align 8
  %tobool.not.i.i.i = icmp eq ptr %13, null
  br i1 %tobool.not.i.i.i, label %if.else.i.i.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %if.then.i.i
  %status.i.i.i = getelementptr inbounds %struct.lua_longjmp, ptr %13, i64 0, i32 2
  store volatile i32 4, ptr %status.i.i.i, align 8
  %14 = load ptr, ptr %errorJmp.i.i.i, align 8
  %b.i.i.i = getelementptr inbounds %struct.lua_longjmp, ptr %14, i64 0, i32 1
  tail call void @longjmp(ptr noundef nonnull %b.i.i.i, i32 noundef 1) #38
  unreachable

if.else.i.i.i:                                    ; preds = %if.then.i.i
  %status3.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 3
  store i8 4, ptr %status3.i.i.i, align 2
  %15 = load ptr, ptr %l_G, align 8
  %panic.i.i.i = getelementptr inbounds %struct.global_State, ptr %15, i64 0, i32 19
  %16 = load ptr, ptr %panic.i.i.i, align 8
  %tobool4.not.i.i.i = icmp eq ptr %16, null
  br i1 %tobool4.not.i.i.i, label %if.end.i.i.i, label %if.then5.i.i.i

if.then5.i.i.i:                                   ; preds = %if.else.i.i.i
  tail call fastcc void @resetstack(ptr noundef nonnull %L, i32 noundef 4)
  %17 = load ptr, ptr %l_G, align 8
  %panic7.i.i.i = getelementptr inbounds %struct.global_State, ptr %17, i64 0, i32 19
  %18 = load ptr, ptr %panic7.i.i.i, align 8
  %call.i.i.i = tail call i32 %18(ptr noundef nonnull %L) #35
  br label %if.end.i.i.i

if.end.i.i.i:                                     ; preds = %if.then5.i.i.i, %if.else.i.i.i
  tail call void @exit(i32 noundef 1) #38
  unreachable

luaM_realloc_.exit.i:                             ; preds = %if.end.i
  %totalbytes.i.i = getelementptr inbounds %struct.global_State, ptr %1, i64 0, i32 14
  %19 = load i64, ptr %totalbytes.i.i, align 8
  %add.i.i = add i64 %19, %add2.i
  store i64 %add.i.i, ptr %totalbytes.i.i, align 8
  %len.i = getelementptr inbounds %struct.anon.0, ptr %call.i.i, i64 0, i32 5
  store i64 %l, ptr %len.i, align 8
  %hash.i = getelementptr inbounds %struct.anon.0, ptr %call.i.i, i64 0, i32 4
  store i32 %h.0.lcssa, ptr %hash.i, align 4
  %20 = load ptr, ptr %l_G, align 8
  %currentwhite.i = getelementptr inbounds %struct.global_State, ptr %20, i64 0, i32 3
  %21 = load i8, ptr %currentwhite.i, align 8
  %22 = and i8 %21, 3
  %marked.i = getelementptr inbounds %struct.anon.0, ptr %call.i.i, i64 0, i32 2
  store i8 %22, ptr %marked.i, align 1
  %tt.i = getelementptr inbounds %struct.anon.0, ptr %call.i.i, i64 0, i32 1
  store i8 4, ptr %tt.i, align 8
  %reserved.i = getelementptr inbounds %struct.anon.0, ptr %call.i.i, i64 0, i32 3
  store i8 0, ptr %reserved.i, align 2
  %add.ptr.i = getelementptr inbounds %union.TString, ptr %call.i.i, i64 1
  tail call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 8 %add.ptr.i, ptr align 1 %str, i64 %l, i1 false)
  %arrayidx.i = getelementptr inbounds i8, ptr %add.ptr.i, i64 %l
  store i8 0, ptr %arrayidx.i, align 1
  %23 = load ptr, ptr %l_G, align 8
  %size.i = getelementptr inbounds %struct.stringtable, ptr %23, i64 0, i32 2
  %24 = load i32, ptr %size.i, align 4
  %sub.i = add nsw i32 %24, -1
  %and8.i = and i32 %sub.i, %h.0.lcssa
  %25 = load ptr, ptr %23, align 8
  %idxprom.i = zext i32 %and8.i to i64
  %arrayidx10.i = getelementptr inbounds ptr, ptr %25, i64 %idxprom.i
  %26 = load ptr, ptr %arrayidx10.i, align 8
  store ptr %26, ptr %call.i.i, align 8
  %27 = load ptr, ptr %23, align 8
  %arrayidx13.i = getelementptr inbounds ptr, ptr %27, i64 %idxprom.i
  store ptr %call.i.i, ptr %arrayidx13.i, align 8
  %nuse.i = getelementptr inbounds %struct.stringtable, ptr %23, i64 0, i32 1
  %28 = load i32, ptr %nuse.i, align 8
  %inc.i = add i32 %28, 1
  store i32 %inc.i, ptr %nuse.i, align 8
  %29 = load i32, ptr %size.i, align 4
  %cmp16.i = icmp ugt i32 %inc.i, %29
  %cmp19.i = icmp slt i32 %29, 1073741823
  %or.cond.i = and i1 %cmp16.i, %cmp19.i
  br i1 %or.cond.i, label %if.then21.i, label %return

if.then21.i:                                      ; preds = %luaM_realloc_.exit.i
  %mul23.i = shl nsw i32 %29, 1
  tail call fastcc void @luaS_resize(ptr noundef nonnull %L, i32 noundef %mul23.i)
  br label %return

return:                                           ; preds = %if.then21.i, %luaM_realloc_.exit.i, %if.then, %if.then25
  %retval.0 = phi ptr [ %o.031, %if.then25 ], [ %o.031, %if.then ], [ %call.i.i, %luaM_realloc_.exit.i ], [ %call.i.i, %if.then21.i ]
  ret ptr %retval.0
}

; Function Attrs: noreturn nounwind
declare void @longjmp(ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define internal fastcc void @resetstack(ptr noundef %L, i32 noundef %status) unnamed_addr #0 {
entry:
  %base_ci = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 12
  %0 = load ptr, ptr %base_ci, align 8
  %ci = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  store ptr %0, ptr %ci, align 8
  %1 = load ptr, ptr %0, align 8
  %base2 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  store ptr %1, ptr %base2, align 8
  tail call fastcc void @luaF_close(ptr noundef %L, ptr noundef %1)
  %2 = load ptr, ptr %base2, align 8
  switch i32 %status, label %luaD_seterrorobj.exit [
    i32 4, label %sw.bb.i
    i32 5, label %sw.bb1.i
    i32 3, label %sw.bb6.i
    i32 2, label %sw.bb6.i
  ]

sw.bb.i:                                          ; preds = %entry
  %call.i = tail call fastcc ptr @luaS_newlstr(ptr noundef nonnull %L, ptr noundef nonnull @.str.3, i64 noundef 17)
  store ptr %call.i, ptr %2, align 8
  br label %luaD_seterrorobj.exit.sink.split

sw.bb1.i:                                         ; preds = %entry
  %call3.i = tail call fastcc ptr @luaS_newlstr(ptr noundef nonnull %L, ptr noundef nonnull @.str.4, i64 noundef 23)
  store ptr %call3.i, ptr %2, align 8
  br label %luaD_seterrorobj.exit.sink.split

sw.bb6.i:                                         ; preds = %entry, %entry
  %top.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %3 = load ptr, ptr %top.i, align 8
  %add.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %3, i64 -1
  %4 = load i64, ptr %add.ptr.i, align 8
  store i64 %4, ptr %2, align 8
  %tt9.i = getelementptr %struct.lua_TValue, ptr %3, i64 -1, i32 1
  %5 = load i32, ptr %tt9.i, align 8
  br label %luaD_seterrorobj.exit.sink.split

luaD_seterrorobj.exit.sink.split:                 ; preds = %sw.bb6.i, %sw.bb1.i, %sw.bb.i
  %.sink = phi i32 [ 4, %sw.bb.i ], [ 4, %sw.bb1.i ], [ %5, %sw.bb6.i ]
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %2, i64 0, i32 1
  store i32 %.sink, ptr %tt.i, align 8
  br label %luaD_seterrorobj.exit

luaD_seterrorobj.exit:                            ; preds = %luaD_seterrorobj.exit.sink.split, %entry
  %add.ptr11.i = getelementptr inbounds %struct.lua_TValue, ptr %2, i64 1
  %top12.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  store ptr %add.ptr11.i, ptr %top12.i, align 8
  %baseCcalls = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 16
  %6 = load i16, ptr %baseCcalls, align 2
  %nCcalls = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 15
  store i16 %6, ptr %nCcalls, align 8
  %allowhook = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 18
  store i8 1, ptr %allowhook, align 1
  %size_ci.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 14
  %7 = load i32, ptr %size_ci.i, align 4
  %cmp.i = icmp sgt i32 %7, 20000
  br i1 %cmp.i, label %if.then.i, label %restore_stack_limit.exit

if.then.i:                                        ; preds = %luaD_seterrorobj.exit
  %8 = load ptr, ptr %ci, align 8
  %9 = load ptr, ptr %base_ci, align 8
  %sub.ptr.lhs.cast.i = ptrtoint ptr %8 to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %9 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %sub.ptr.div.i = sdiv exact i64 %sub.ptr.sub.i, 40
  %conv.i = trunc i64 %sub.ptr.div.i to i32
  %cmp1.i = icmp slt i32 %conv.i, 19999
  br i1 %cmp1.i, label %if.then3.i, label %restore_stack_limit.exit

if.then3.i:                                       ; preds = %if.then.i
  tail call fastcc void @luaD_reallocCI(ptr noundef nonnull %L, i32 noundef 20000)
  br label %restore_stack_limit.exit

restore_stack_limit.exit:                         ; preds = %luaD_seterrorobj.exit, %if.then.i, %if.then3.i
  %errorJmp = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 26
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %errorJmp, i8 0, i64 16, i1 false)
  ret void
}

; Function Attrs: noreturn nounwind
declare void @exit(i32 noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define internal fastcc void @luaF_close(ptr nocapture noundef %L, ptr noundef readnone %level) unnamed_addr #0 {
entry:
  %l_G = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %openupval = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 24
  %0 = load ptr, ptr %openupval, align 8
  %cmp.not27 = icmp eq ptr %0, null
  br i1 %cmp.not27, label %while.end, label %land.rhs.lr.ph

land.rhs.lr.ph:                                   ; preds = %entry
  %1 = load ptr, ptr %l_G, align 8
  %currentwhite = getelementptr inbounds %struct.global_State, ptr %1, i64 0, i32 3
  br label %land.rhs

land.rhs:                                         ; preds = %land.rhs.lr.ph, %if.end
  %2 = phi ptr [ %0, %land.rhs.lr.ph ], [ %38, %if.end ]
  %v = getelementptr inbounds %struct.UpVal, ptr %2, i64 0, i32 3
  %3 = load ptr, ptr %v, align 8
  %cmp2.not = icmp ult ptr %3, %level
  br i1 %cmp2.not, label %while.end, label %while.body

while.body:                                       ; preds = %land.rhs
  %4 = load ptr, ptr %2, align 8
  store ptr %4, ptr %openupval, align 8
  %marked = getelementptr inbounds %struct.GCheader, ptr %2, i64 0, i32 2
  %5 = load i8, ptr %marked, align 1
  %6 = load i8, ptr %currentwhite, align 8
  %7 = xor i8 %6, -1
  %and16 = and i8 %5, 3
  %8 = and i8 %and16, %7
  %tobool.not = icmp eq i8 %8, 0
  br i1 %tobool.not, label %if.else, label %if.then

if.then:                                          ; preds = %while.body
  %9 = load ptr, ptr %v, align 8
  %u.i = getelementptr inbounds %struct.UpVal, ptr %2, i64 0, i32 4
  %cmp.not.i = icmp eq ptr %9, %u.i
  br i1 %cmp.not.i, label %luaF_freeupval.exit, label %if.then.i

if.then.i:                                        ; preds = %if.then
  %10 = load ptr, ptr %u.i, align 8
  %next.i21 = getelementptr inbounds %struct.UpVal, ptr %2, i64 0, i32 4, i32 0, i32 1
  %11 = load ptr, ptr %next.i21, align 8
  %u2.i22 = getelementptr inbounds %struct.UpVal, ptr %11, i64 0, i32 4
  store ptr %10, ptr %u2.i22, align 8
  %12 = load ptr, ptr %next.i21, align 8
  %next9.i23 = getelementptr inbounds %struct.UpVal, ptr %10, i64 0, i32 4, i32 0, i32 1
  store ptr %12, ptr %next9.i23, align 8
  br label %luaF_freeupval.exit

luaF_freeupval.exit:                              ; preds = %if.then, %if.then.i
  %13 = load ptr, ptr %l_G, align 8
  %frealloc.i = getelementptr inbounds %struct.global_State, ptr %13, i64 0, i32 1
  %14 = load ptr, ptr %frealloc.i, align 8
  %ud.i = getelementptr inbounds %struct.global_State, ptr %13, i64 0, i32 2
  %15 = load ptr, ptr %ud.i, align 8
  %call.i25 = tail call ptr %14(ptr noundef %15, ptr noundef nonnull %2, i64 noundef 40, i64 noundef 0) #35
  %totalbytes.i = getelementptr inbounds %struct.global_State, ptr %13, i64 0, i32 14
  %16 = load i64, ptr %totalbytes.i, align 8
  %sub.i = add i64 %16, -40
  store i64 %sub.i, ptr %totalbytes.i, align 8
  br label %if.end

if.else:                                          ; preds = %while.body
  %u.i17 = getelementptr inbounds %struct.UpVal, ptr %2, i64 0, i32 4
  %17 = load ptr, ptr %u.i17, align 8
  %next.i = getelementptr inbounds %struct.UpVal, ptr %2, i64 0, i32 4, i32 0, i32 1
  %18 = load ptr, ptr %next.i, align 8
  %u2.i = getelementptr inbounds %struct.UpVal, ptr %18, i64 0, i32 4
  store ptr %17, ptr %u2.i, align 8
  %19 = load ptr, ptr %next.i, align 8
  %next9.i = getelementptr inbounds %struct.UpVal, ptr %17, i64 0, i32 4, i32 0, i32 1
  store ptr %19, ptr %next9.i, align 8
  %20 = load ptr, ptr %v, align 8
  %21 = load i64, ptr %20, align 8
  store i64 %21, ptr %u.i17, align 8
  %tt = getelementptr inbounds %struct.lua_TValue, ptr %20, i64 0, i32 1
  %22 = load i32, ptr %tt, align 8
  store i32 %22, ptr %next.i, align 8
  store ptr %u.i17, ptr %v, align 8
  %23 = load ptr, ptr %l_G, align 8
  %rootgc.i = getelementptr inbounds %struct.global_State, ptr %23, i64 0, i32 6
  %24 = load ptr, ptr %rootgc.i, align 8
  store ptr %24, ptr %2, align 8
  store ptr %2, ptr %rootgc.i, align 8
  %25 = load i8, ptr %marked, align 1
  %26 = and i8 %25, 7
  %or.cond.i = icmp eq i8 %26, 0
  br i1 %or.cond.i, label %if.then.i18, label %if.end

if.then.i18:                                      ; preds = %if.else
  %gcstate.i = getelementptr inbounds %struct.global_State, ptr %23, i64 0, i32 4
  %27 = load i8, ptr %gcstate.i, align 1
  %cmp.i = icmp eq i8 %27, 1
  br i1 %cmp.i, label %if.then8.i, label %if.else.i

if.then8.i:                                       ; preds = %if.then.i18
  %or.i = or disjoint i8 %25, 4
  store i8 %or.i, ptr %marked, align 1
  %28 = load ptr, ptr %v, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %28, i64 0, i32 1
  %29 = load i32, ptr %tt.i, align 8
  %cmp12.i = icmp sgt i32 %29, 3
  br i1 %cmp12.i, label %land.lhs.true14.i, label %if.end

land.lhs.true14.i:                                ; preds = %if.then8.i
  %30 = load ptr, ptr %28, align 8
  %marked16.i = getelementptr inbounds %struct.GCheader, ptr %30, i64 0, i32 2
  %31 = load i8, ptr %marked16.i, align 1
  %32 = and i8 %31, 3
  %tobool19.not.i = icmp eq i8 %32, 0
  br i1 %tobool19.not.i, label %if.end, label %if.then25.i

if.then25.i:                                      ; preds = %land.lhs.true14.i
  %L.val.i = load ptr, ptr %l_G, align 8
  %gcstate.i.i = getelementptr inbounds %struct.global_State, ptr %L.val.i, i64 0, i32 4
  %33 = load i8, ptr %gcstate.i.i, align 1
  %cmp.i.i = icmp eq i8 %33, 1
  br i1 %cmp.i.i, label %if.then.i.i, label %if.else.i.i

if.then.i.i:                                      ; preds = %if.then25.i
  tail call fastcc void @reallymarkobject(ptr noundef nonnull %L.val.i, ptr noundef nonnull %30)
  br label %if.end

if.else.i.i:                                      ; preds = %if.then25.i
  %currentwhite.i.i = getelementptr inbounds %struct.global_State, ptr %L.val.i, i64 0, i32 3
  %34 = load i8, ptr %currentwhite.i.i, align 8
  %35 = and i8 %34, 3
  %or4.i.i = or disjoint i8 %35, %25
  store i8 %or4.i.i, ptr %marked, align 1
  br label %if.end

if.else.i:                                        ; preds = %if.then.i18
  %currentwhite.i = getelementptr inbounds %struct.global_State, ptr %23, i64 0, i32 3
  %36 = load i8, ptr %currentwhite.i, align 8
  %37 = and i8 %36, 3
  %or3516.i = or disjoint i8 %37, %25
  store i8 %or3516.i, ptr %marked, align 1
  br label %if.end

if.end:                                           ; preds = %if.else.i, %if.else.i.i, %if.then.i.i, %land.lhs.true14.i, %if.then8.i, %if.else, %luaF_freeupval.exit
  %38 = load ptr, ptr %openupval, align 8
  %cmp.not = icmp eq ptr %38, null
  br i1 %cmp.not, label %while.end, label %land.rhs, !llvm.loop !22

while.end:                                        ; preds = %land.rhs, %if.end, %entry
  ret void
}

; Function Attrs: mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #5

; Function Attrs: nofree nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define internal fastcc void @reallymarkobject(ptr noundef %g, ptr noundef %o) unnamed_addr #6 {
entry:
  %marked.phi.trans.insert = getelementptr inbounds %struct.GCheader, ptr %o, i64 0, i32 2
  %.pre = load i8, ptr %marked.phi.trans.insert, align 1
  br label %tailrecurse

tailrecurse:                                      ; preds = %if.end12, %entry
  %0 = phi i8 [ %.pre, %entry ], [ %8, %if.end12 ]
  %o.tr = phi ptr [ %o, %entry ], [ %7, %if.end12 ]
  %marked = getelementptr inbounds %struct.GCheader, ptr %o.tr, i64 0, i32 2
  %1 = and i8 %0, -4
  store i8 %1, ptr %marked, align 1
  %tt = getelementptr inbounds %struct.GCheader, ptr %o.tr, i64 0, i32 1
  %2 = load i8, ptr %tt, align 8
  switch i8 %2, label %sw.epilog [
    i8 9, label %sw.bb51
    i8 7, label %sw.bb3
    i8 10, label %sw.bb20
    i8 6, label %sw.bb41
    i8 5, label %sw.bb43
    i8 8, label %sw.bb47
  ]

sw.bb3:                                           ; preds = %tailrecurse
  %metatable = getelementptr inbounds %struct.anon.1, ptr %o.tr, i64 0, i32 3
  %3 = load ptr, ptr %metatable, align 8
  %4 = or i8 %1, 4
  store i8 %4, ptr %marked, align 1
  %tobool.not = icmp eq ptr %3, null
  br i1 %tobool.not, label %if.end12, label %if.then

if.then:                                          ; preds = %sw.bb3
  %marked7 = getelementptr inbounds %struct.GCheader, ptr %3, i64 0, i32 2
  %5 = load i8, ptr %marked7, align 1
  %6 = and i8 %5, 3
  %tobool10.not = icmp eq i8 %6, 0
  br i1 %tobool10.not, label %if.end12, label %if.then11

if.then11:                                        ; preds = %if.then
  tail call fastcc void @reallymarkobject(ptr noundef %g, ptr noundef nonnull %3)
  br label %if.end12

if.end12:                                         ; preds = %if.then, %if.then11, %sw.bb3
  %env = getelementptr inbounds %struct.anon.1, ptr %o.tr, i64 0, i32 4
  %7 = load ptr, ptr %env, align 8
  %marked13 = getelementptr inbounds %struct.GCheader, ptr %7, i64 0, i32 2
  %8 = load i8, ptr %marked13, align 1
  %9 = and i8 %8, 3
  %tobool16.not = icmp eq i8 %9, 0
  br i1 %tobool16.not, label %sw.epilog, label %tailrecurse

sw.bb20:                                          ; preds = %tailrecurse
  %v = getelementptr inbounds %struct.UpVal, ptr %o.tr, i64 0, i32 3
  %10 = load ptr, ptr %v, align 8
  %tt21 = getelementptr inbounds %struct.lua_TValue, ptr %10, i64 0, i32 1
  %11 = load i32, ptr %tt21, align 8
  %cmp = icmp sgt i32 %11, 3
  br i1 %cmp, label %land.lhs.true, label %if.end31

land.lhs.true:                                    ; preds = %sw.bb20
  %12 = load ptr, ptr %10, align 8
  %marked24 = getelementptr inbounds %struct.GCheader, ptr %12, i64 0, i32 2
  %13 = load i8, ptr %marked24, align 1
  %14 = and i8 %13, 3
  %tobool27.not = icmp eq i8 %14, 0
  br i1 %tobool27.not, label %if.end31, label %if.then28

if.then28:                                        ; preds = %land.lhs.true
  tail call fastcc void @reallymarkobject(ptr noundef %g, ptr noundef nonnull %12)
  %.pre52 = load ptr, ptr %v, align 8
  br label %if.end31

if.end31:                                         ; preds = %if.then28, %land.lhs.true, %sw.bb20
  %15 = phi ptr [ %.pre52, %if.then28 ], [ %10, %land.lhs.true ], [ %10, %sw.bb20 ]
  %u = getelementptr inbounds %struct.UpVal, ptr %o.tr, i64 0, i32 4
  %cmp33 = icmp eq ptr %15, %u
  br i1 %cmp33, label %if.then35, label %sw.epilog

if.then35:                                        ; preds = %if.end31
  %16 = load i8, ptr %marked, align 1
  %17 = or i8 %16, 4
  store i8 %17, ptr %marked, align 1
  br label %sw.epilog

sw.bb41:                                          ; preds = %tailrecurse
  %gray = getelementptr inbounds %struct.global_State, ptr %g, i64 0, i32 8
  %18 = load ptr, ptr %gray, align 8
  %gclist = getelementptr inbounds %struct.CClosure, ptr %o.tr, i64 0, i32 5
  store ptr %18, ptr %gclist, align 8
  store ptr %o.tr, ptr %gray, align 8
  br label %sw.epilog

sw.bb43:                                          ; preds = %tailrecurse
  %gray44 = getelementptr inbounds %struct.global_State, ptr %g, i64 0, i32 8
  %19 = load ptr, ptr %gray44, align 8
  %gclist45 = getelementptr inbounds %struct.Table, ptr %o.tr, i64 0, i32 9
  store ptr %19, ptr %gclist45, align 8
  store ptr %o.tr, ptr %gray44, align 8
  br label %sw.epilog

sw.bb47:                                          ; preds = %tailrecurse
  %gray48 = getelementptr inbounds %struct.global_State, ptr %g, i64 0, i32 8
  %20 = load ptr, ptr %gray48, align 8
  %gclist49 = getelementptr inbounds %struct.lua_State, ptr %o.tr, i64 0, i32 25
  store ptr %20, ptr %gclist49, align 8
  store ptr %o.tr, ptr %gray48, align 8
  br label %sw.epilog

sw.bb51:                                          ; preds = %tailrecurse
  %gray52 = getelementptr inbounds %struct.global_State, ptr %g, i64 0, i32 8
  %21 = load ptr, ptr %gray52, align 8
  %gclist53 = getelementptr inbounds %struct.Proto, ptr %o.tr, i64 0, i32 18
  store ptr %21, ptr %gclist53, align 8
  store ptr %o.tr, ptr %gray52, align 8
  br label %sw.epilog

sw.epilog:                                        ; preds = %tailrecurse, %if.end12, %if.end31, %if.then35, %sw.bb51, %sw.bb47, %sw.bb43, %sw.bb41
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaD_reallocCI(ptr noundef %L, i32 noundef %newsize) unnamed_addr #0 {
entry:
  %base_ci = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 12
  %0 = load ptr, ptr %base_ci, align 8
  %cmp = icmp sgt i32 %newsize, -2
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %size_ci = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 14
  %1 = load i32, ptr %size_ci, align 4
  %conv3 = sext i32 %1 to i64
  %mul = mul nsw i64 %conv3, 40
  %conv4 = sext i32 %newsize to i64
  %mul5 = mul nsw i64 %conv4, 40
  %l_G.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %2 = load ptr, ptr %l_G.i, align 8
  %frealloc.i = getelementptr inbounds %struct.global_State, ptr %2, i64 0, i32 1
  %3 = load ptr, ptr %frealloc.i, align 8
  %ud.i = getelementptr inbounds %struct.global_State, ptr %2, i64 0, i32 2
  %4 = load ptr, ptr %ud.i, align 8
  %call.i = tail call ptr %3(ptr noundef %4, ptr noundef %0, i64 noundef %mul, i64 noundef %mul5) #35
  %cmp.i = icmp eq ptr %call.i, null
  %cmp1.i = icmp ne i32 %newsize, 0
  %or.cond.i = and i1 %cmp1.i, %cmp.i
  br i1 %or.cond.i, label %if.then.i, label %luaM_realloc_.exit

if.then.i:                                        ; preds = %cond.true
  %errorJmp.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 26
  %5 = load ptr, ptr %errorJmp.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %5, null
  br i1 %tobool.not.i.i, label %if.else.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %if.then.i
  %status.i.i = getelementptr inbounds %struct.lua_longjmp, ptr %5, i64 0, i32 2
  store volatile i32 4, ptr %status.i.i, align 8
  %6 = load ptr, ptr %errorJmp.i.i, align 8
  %b.i.i = getelementptr inbounds %struct.lua_longjmp, ptr %6, i64 0, i32 1
  tail call void @longjmp(ptr noundef nonnull %b.i.i, i32 noundef 1) #38
  unreachable

if.else.i.i:                                      ; preds = %if.then.i
  %status3.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 3
  store i8 4, ptr %status3.i.i, align 2
  %7 = load ptr, ptr %l_G.i, align 8
  %panic.i.i = getelementptr inbounds %struct.global_State, ptr %7, i64 0, i32 19
  %8 = load ptr, ptr %panic.i.i, align 8
  %tobool4.not.i.i = icmp eq ptr %8, null
  br i1 %tobool4.not.i.i, label %if.end.i.i, label %if.then5.i.i

if.then5.i.i:                                     ; preds = %if.else.i.i
  tail call fastcc void @resetstack(ptr noundef nonnull %L, i32 noundef 4)
  %9 = load ptr, ptr %l_G.i, align 8
  %panic7.i.i = getelementptr inbounds %struct.global_State, ptr %9, i64 0, i32 19
  %10 = load ptr, ptr %panic7.i.i, align 8
  %call.i.i = tail call i32 %10(ptr noundef nonnull %L) #35
  br label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then5.i.i, %if.else.i.i
  tail call void @exit(i32 noundef 1) #38
  unreachable

luaM_realloc_.exit:                               ; preds = %cond.true
  %totalbytes.i = getelementptr inbounds %struct.global_State, ptr %2, i64 0, i32 14
  %11 = load i64, ptr %totalbytes.i, align 8
  %sub.i = sub nsw i64 %mul5, %mul
  %add.i = add i64 %sub.i, %11
  store i64 %add.i, ptr %totalbytes.i, align 8
  store ptr %call.i, ptr %base_ci, align 8
  %size_ci8 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 14
  store i32 %newsize, ptr %size_ci8, align 4
  %ci = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %12 = load ptr, ptr %ci, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %12 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 40
  %add.ptr = getelementptr inbounds %struct.CallInfo, ptr %call.i, i64 %sub.ptr.div
  store ptr %add.ptr, ptr %ci, align 8
  %add.ptr13 = getelementptr inbounds %struct.CallInfo, ptr %call.i, i64 %conv4
  %add.ptr14 = getelementptr inbounds %struct.CallInfo, ptr %add.ptr13, i64 -1
  %end_ci = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 11
  store ptr %add.ptr14, ptr %end_ci, align 8
  ret void

cond.false:                                       ; preds = %entry
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef nonnull %L, ptr noundef nonnull @.str.5)
  unreachable
}

; Function Attrs: noreturn nounwind uwtable
define internal void @luaG_runerror(ptr noundef %L, ptr noundef %fmt, ...) unnamed_addr #7 {
entry:
  %buff.i = alloca [60 x i8], align 16
  %argp = alloca [1 x %struct.__va_list_tag], align 16
  call void @llvm.va_start(ptr nonnull %argp)
  %call = call fastcc ptr @luaO_pushvfstring(ptr noundef %L, ptr noundef %fmt, ptr noundef nonnull %argp)
  call void @llvm.lifetime.start.p0(i64 60, ptr nonnull %buff.i)
  %ci1.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %0 = load ptr, ptr %ci1.i, align 8
  %func.i = getelementptr inbounds %struct.CallInfo, ptr %0, i64 0, i32 1
  %1 = load ptr, ptr %func.i, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 0, i32 1
  %2 = load i32, ptr %tt.i, align 8
  %cmp.i = icmp eq i32 %2, 6
  br i1 %cmp.i, label %land.lhs.true.i, label %addinfo.exit

land.lhs.true.i:                                  ; preds = %entry
  %3 = load ptr, ptr %1, align 8
  %isC.i = getelementptr inbounds %struct.CClosure, ptr %3, i64 0, i32 3
  %4 = load i8, ptr %isC.i, align 2
  %tobool.not.i = icmp eq i8 %4, 0
  br i1 %tobool.not.i, label %currentpc.exit.i, label %addinfo.exit

currentpc.exit.i:                                 ; preds = %land.lhs.true.i
  %savedpc.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 8
  %5 = load ptr, ptr %savedpc.i.i, align 8
  %savedpc5.i.i = getelementptr inbounds %struct.CallInfo, ptr %0, i64 0, i32 3
  store ptr %5, ptr %savedpc5.i.i, align 8
  %.pre7.i.i = load ptr, ptr %1, align 8
  %p.i.i = getelementptr inbounds %struct.LClosure, ptr %.pre7.i.i, i64 0, i32 7
  %6 = load ptr, ptr %p.i.i, align 8
  %code.i.i = getelementptr inbounds %struct.Proto, ptr %6, i64 0, i32 4
  %7 = load ptr, ptr %code.i.i, align 8
  %sub.ptr.lhs.cast.i.i = ptrtoint ptr %5 to i64
  %sub.ptr.rhs.cast.i.i = ptrtoint ptr %7 to i64
  %sub.ptr.sub.i.i = sub i64 %sub.ptr.lhs.cast.i.i, %sub.ptr.rhs.cast.i.i
  %sub.ptr.div.i.i = lshr exact i64 %sub.ptr.sub.i.i, 2
  %conv.i.i = trunc i64 %sub.ptr.div.i.i to i32
  %sub.i.i = add nuw nsw i64 %sub.ptr.div.i.i, 4294967295
  %cmp.i3 = icmp slt i32 %conv.i.i, 1
  br i1 %cmp.i3, label %currentline.exit, label %if.else.i

if.else.i:                                        ; preds = %currentpc.exit.i
  %lineinfo.i = getelementptr inbounds %struct.Proto, ptr %6, i64 0, i32 6
  %8 = load ptr, ptr %lineinfo.i, align 8
  %tobool.not.i4 = icmp eq ptr %8, null
  br i1 %tobool.not.i4, label %currentline.exit, label %cond.true.i

cond.true.i:                                      ; preds = %if.else.i
  %idxprom.i = and i64 %sub.i.i, 4294967295
  %arrayidx.i = getelementptr inbounds i32, ptr %8, i64 %idxprom.i
  %9 = load i32, ptr %arrayidx.i, align 4
  br label %currentline.exit

currentline.exit:                                 ; preds = %currentpc.exit.i, %if.else.i, %cond.true.i
  %retval.0.i = phi i32 [ -1, %currentpc.exit.i ], [ %9, %cond.true.i ], [ 0, %if.else.i ]
  %10 = load i32, ptr %tt.i, align 8
  %cmp.i6 = icmp eq i32 %10, 6
  call void @llvm.assume(i1 %cmp.i6)
  %isC.i8 = getelementptr inbounds %struct.CClosure, ptr %.pre7.i.i, i64 0, i32 3
  %11 = load i8, ptr %isC.i8, align 2
  %tobool.not.i9 = icmp eq i8 %11, 0
  call void @llvm.assume(i1 %tobool.not.i9)
  %source.i = getelementptr inbounds %struct.Proto, ptr %6, i64 0, i32 9
  %12 = load ptr, ptr %source.i, align 8
  %add.ptr.i = getelementptr inbounds %union.TString, ptr %12, i64 1
  call fastcc void @luaO_chunkid(ptr noundef nonnull %buff.i, ptr noundef nonnull %add.ptr.i, i64 noundef 60)
  %call5.i = call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef nonnull %L, ptr noundef nonnull @.str.6, ptr noundef nonnull %buff.i, i32 noundef %retval.0.i, ptr noundef %call)
  br label %addinfo.exit

addinfo.exit:                                     ; preds = %entry, %land.lhs.true.i, %currentline.exit
  call void @llvm.lifetime.end.p0(i64 60, ptr nonnull %buff.i)
  call void @llvm.va_end(ptr nonnull %argp)
  call fastcc void @luaG_errormsg(ptr noundef nonnull %L)
  unreachable
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn
declare void @llvm.va_start(ptr) #8

; Function Attrs: nounwind uwtable
define internal fastcc ptr @luaO_pushvfstring(ptr noundef %L, ptr noundef %fmt, ptr nocapture noundef %argp) unnamed_addr #0 {
entry:
  %buff = alloca [2 x i8], align 1
  %buff83 = alloca [40 x i8], align 16
  %buff99 = alloca [3 x i8], align 1
  %top.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %0 = load ptr, ptr %top.i, align 8
  %call1.i = tail call fastcc ptr @luaS_newlstr(ptr noundef %L, ptr noundef nonnull @.str.7, i64 noundef 0)
  store ptr %call1.i, ptr %0, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %0, i64 0, i32 1
  store i32 4, ptr %tt.i, align 8
  %stack_last.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 9
  %1 = load ptr, ptr %stack_last.i, align 8
  %2 = load ptr, ptr %top.i, align 8
  %sub.ptr.lhs.cast.i = ptrtoint ptr %1 to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %2 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %cmp.i = icmp slt i64 %sub.ptr.sub.i, 17
  br i1 %cmp.i, label %if.then.i, label %pushstr.exit

if.then.i:                                        ; preds = %entry
  %stacksize.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 13
  %3 = load i32, ptr %stacksize.i.i, align 8
  %cmp.not.i.i = icmp slt i32 %3, 1
  %mul.i.i = shl nuw nsw i32 %3, 1
  %add.i.i = add nsw i32 %3, 1
  %mul.i.i.sink = select i1 %cmp.not.i.i, i32 %add.i.i, i32 %mul.i.i
  tail call fastcc void @luaD_reallocstack(ptr noundef nonnull %L, i32 noundef %mul.i.i.sink)
  br label %pushstr.exit

pushstr.exit:                                     ; preds = %if.then.i, %entry
  %4 = load ptr, ptr %top.i, align 8
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %4, i64 1
  store ptr %incdec.ptr.i, ptr %top.i, align 8
  %call174 = tail call ptr @strchr(ptr noundef nonnull dereferenceable(1) %fmt, i32 noundef 37) #34
  %cmp175 = icmp eq ptr %call174, null
  br i1 %cmp175, label %for.end, label %if.end.lr.ph

if.end.lr.ph:                                     ; preds = %pushstr.exit
  %stacksize.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 13
  %overflow_arg_area_p91 = getelementptr inbounds %struct.__va_list_tag, ptr %argp, i64 0, i32 2
  %5 = getelementptr inbounds %struct.__va_list_tag, ptr %argp, i64 0, i32 3
  %fp_offset_p = getelementptr inbounds %struct.__va_list_tag, ptr %argp, i64 0, i32 1
  %arrayidx27 = getelementptr inbounds [2 x i8], ptr %buff, i64 0, i64 1
  %arrayidx102 = getelementptr inbounds [3 x i8], ptr %buff99, i64 0, i64 1
  %arrayidx103 = getelementptr inbounds [3 x i8], ptr %buff99, i64 0, i64 2
  br label %if.end

if.end:                                           ; preds = %if.end.lr.ph, %sw.epilog
  %6 = phi ptr [ %incdec.ptr.i, %if.end.lr.ph ], [ %incdec.ptr.i145, %sw.epilog ]
  %call178 = phi ptr [ %call174, %if.end.lr.ph ], [ %call, %sw.epilog ]
  %fmt.addr.0177 = phi ptr [ %fmt, %if.end.lr.ph ], [ %add.ptr105, %sw.epilog ]
  %n.0176 = phi i32 [ 1, %if.end.lr.ph ], [ %add, %sw.epilog ]
  %sub.ptr.lhs.cast = ptrtoint ptr %call178 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %fmt.addr.0177 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %call1 = tail call fastcc ptr @luaS_newlstr(ptr noundef nonnull %L, ptr noundef %fmt.addr.0177, i64 noundef %sub.ptr.sub)
  store ptr %call1, ptr %6, align 8
  %tt = getelementptr inbounds %struct.lua_TValue, ptr %6, i64 0, i32 1
  store i32 4, ptr %tt, align 8
  %7 = load ptr, ptr %stack_last.i, align 8
  %8 = load ptr, ptr %top.i, align 8
  %sub.ptr.lhs.cast3 = ptrtoint ptr %7 to i64
  %sub.ptr.rhs.cast4 = ptrtoint ptr %8 to i64
  %sub.ptr.sub5 = sub i64 %sub.ptr.lhs.cast3, %sub.ptr.rhs.cast4
  %cmp6 = icmp slt i64 %sub.ptr.sub5, 17
  br i1 %cmp6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end
  %9 = load i32, ptr %stacksize.i, align 8
  %cmp.not.i = icmp slt i32 %9, 1
  %add.i = add nsw i32 %9, 1
  %mul.i = shl nuw nsw i32 %9, 1
  %add.i.sink = select i1 %cmp.not.i, i32 %add.i, i32 %mul.i
  tail call fastcc void @luaD_reallocstack(ptr noundef nonnull %L, i32 noundef %add.i.sink)
  br label %if.end8

if.end8:                                          ; preds = %if.then7, %if.end
  %10 = load ptr, ptr %top.i, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue, ptr %10, i64 1
  store ptr %incdec.ptr, ptr %top.i, align 8
  %add.ptr = getelementptr inbounds i8, ptr %call178, i64 1
  %11 = load i8, ptr %add.ptr, align 1
  %conv = sext i8 %11 to i32
  switch i32 %conv, label %sw.default [
    i32 115, label %sw.bb
    i32 99, label %sw.bb14
    i32 100, label %sw.bb28
    i32 102, label %sw.bb57
    i32 112, label %sw.bb82
    i32 37, label %sw.bb98
  ]

sw.bb:                                            ; preds = %if.end8
  %gp_offset = load i32, ptr %argp, align 8
  %fits_in_gp = icmp ult i32 %gp_offset, 41
  br i1 %fits_in_gp, label %vaarg.in_reg, label %vaarg.in_mem

vaarg.in_reg:                                     ; preds = %sw.bb
  %reg_save_area = load ptr, ptr %5, align 8
  %12 = zext nneg i32 %gp_offset to i64
  %13 = getelementptr i8, ptr %reg_save_area, i64 %12
  %14 = add nuw nsw i32 %gp_offset, 8
  store i32 %14, ptr %argp, align 8
  br label %vaarg.end

vaarg.in_mem:                                     ; preds = %sw.bb
  %overflow_arg_area = load ptr, ptr %overflow_arg_area_p91, align 8
  %overflow_arg_area.next = getelementptr i8, ptr %overflow_arg_area, i64 8
  store ptr %overflow_arg_area.next, ptr %overflow_arg_area_p91, align 8
  br label %vaarg.end

vaarg.end:                                        ; preds = %vaarg.in_mem, %vaarg.in_reg
  %vaarg.addr = phi ptr [ %13, %vaarg.in_reg ], [ %overflow_arg_area, %vaarg.in_mem ]
  %15 = load ptr, ptr %vaarg.addr, align 8
  %cmp10 = icmp eq ptr %15, null
  %spec.store.select = select i1 %cmp10, ptr @.str.12, ptr %15
  %16 = load ptr, ptr %top.i, align 8
  %call.i47 = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %spec.store.select) #34
  %call1.i48 = tail call fastcc ptr @luaS_newlstr(ptr noundef nonnull %L, ptr noundef nonnull %spec.store.select, i64 noundef %call.i47)
  store ptr %call1.i48, ptr %16, align 8
  %tt.i49 = getelementptr inbounds %struct.lua_TValue, ptr %16, i64 0, i32 1
  store i32 4, ptr %tt.i49, align 8
  %17 = load ptr, ptr %stack_last.i, align 8
  %18 = load ptr, ptr %top.i, align 8
  %sub.ptr.lhs.cast.i51 = ptrtoint ptr %17 to i64
  %sub.ptr.rhs.cast.i52 = ptrtoint ptr %18 to i64
  %sub.ptr.sub.i53 = sub i64 %sub.ptr.lhs.cast.i51, %sub.ptr.rhs.cast.i52
  %cmp.i54 = icmp slt i64 %sub.ptr.sub.i53, 17
  br i1 %cmp.i54, label %if.then.i56, label %sw.epilog

if.then.i56:                                      ; preds = %vaarg.end
  %19 = load i32, ptr %stacksize.i, align 8
  %cmp.not.i.i58 = icmp slt i32 %19, 1
  %mul.i.i60 = shl nuw nsw i32 %19, 1
  %add.i.i63 = add nsw i32 %19, 1
  %mul.i.i60.sink = select i1 %cmp.not.i.i58, i32 %add.i.i63, i32 %mul.i.i60
  br label %sw.epilog.sink.split

sw.bb14:                                          ; preds = %if.end8
  %gp_offset16 = load i32, ptr %argp, align 8
  %fits_in_gp17 = icmp ult i32 %gp_offset16, 41
  br i1 %fits_in_gp17, label %vaarg.in_reg18, label %vaarg.in_mem20

vaarg.in_reg18:                                   ; preds = %sw.bb14
  %reg_save_area19 = load ptr, ptr %5, align 8
  %20 = zext nneg i32 %gp_offset16 to i64
  %21 = getelementptr i8, ptr %reg_save_area19, i64 %20
  %22 = add nuw nsw i32 %gp_offset16, 8
  store i32 %22, ptr %argp, align 8
  br label %vaarg.end24

vaarg.in_mem20:                                   ; preds = %sw.bb14
  %overflow_arg_area22 = load ptr, ptr %overflow_arg_area_p91, align 8
  %overflow_arg_area.next23 = getelementptr i8, ptr %overflow_arg_area22, i64 8
  store ptr %overflow_arg_area.next23, ptr %overflow_arg_area_p91, align 8
  br label %vaarg.end24

vaarg.end24:                                      ; preds = %vaarg.in_mem20, %vaarg.in_reg18
  %vaarg.addr25 = phi ptr [ %21, %vaarg.in_reg18 ], [ %overflow_arg_area22, %vaarg.in_mem20 ]
  %23 = load i32, ptr %vaarg.addr25, align 4
  %conv26 = trunc i32 %23 to i8
  store i8 %conv26, ptr %buff, align 1
  store i8 0, ptr %arrayidx27, align 1
  %24 = load ptr, ptr %top.i, align 8
  %call.i66 = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %buff) #34
  %call1.i67 = call fastcc ptr @luaS_newlstr(ptr noundef nonnull %L, ptr noundef nonnull %buff, i64 noundef %call.i66)
  store ptr %call1.i67, ptr %24, align 8
  %tt.i68 = getelementptr inbounds %struct.lua_TValue, ptr %24, i64 0, i32 1
  store i32 4, ptr %tt.i68, align 8
  %25 = load ptr, ptr %stack_last.i, align 8
  %26 = load ptr, ptr %top.i, align 8
  %sub.ptr.lhs.cast.i70 = ptrtoint ptr %25 to i64
  %sub.ptr.rhs.cast.i71 = ptrtoint ptr %26 to i64
  %sub.ptr.sub.i72 = sub i64 %sub.ptr.lhs.cast.i70, %sub.ptr.rhs.cast.i71
  %cmp.i73 = icmp slt i64 %sub.ptr.sub.i72, 17
  br i1 %cmp.i73, label %if.then.i75, label %sw.epilog

if.then.i75:                                      ; preds = %vaarg.end24
  %27 = load i32, ptr %stacksize.i, align 8
  %cmp.not.i.i77 = icmp slt i32 %27, 1
  %mul.i.i79 = shl nuw nsw i32 %27, 1
  %add.i.i82 = add nsw i32 %27, 1
  %mul.i.i79.sink = select i1 %cmp.not.i.i77, i32 %add.i.i82, i32 %mul.i.i79
  br label %sw.epilog.sink.split

sw.bb28:                                          ; preds = %if.end8
  %gp_offset32 = load i32, ptr %argp, align 8
  %fits_in_gp33 = icmp ult i32 %gp_offset32, 41
  br i1 %fits_in_gp33, label %vaarg.in_reg34, label %vaarg.in_mem36

vaarg.in_reg34:                                   ; preds = %sw.bb28
  %reg_save_area35 = load ptr, ptr %5, align 8
  %28 = zext nneg i32 %gp_offset32 to i64
  %29 = getelementptr i8, ptr %reg_save_area35, i64 %28
  %30 = add nuw nsw i32 %gp_offset32, 8
  store i32 %30, ptr %argp, align 8
  br label %vaarg.end40

vaarg.in_mem36:                                   ; preds = %sw.bb28
  %overflow_arg_area38 = load ptr, ptr %overflow_arg_area_p91, align 8
  %overflow_arg_area.next39 = getelementptr i8, ptr %overflow_arg_area38, i64 8
  store ptr %overflow_arg_area.next39, ptr %overflow_arg_area_p91, align 8
  br label %vaarg.end40

vaarg.end40:                                      ; preds = %vaarg.in_mem36, %vaarg.in_reg34
  %vaarg.addr41 = phi ptr [ %29, %vaarg.in_reg34 ], [ %overflow_arg_area38, %vaarg.in_mem36 ]
  %31 = load i32, ptr %vaarg.addr41, align 4
  %conv42 = sitofp i32 %31 to double
  store double %conv42, ptr %incdec.ptr, align 8
  %tt44 = getelementptr inbounds %struct.lua_TValue, ptr %10, i64 1, i32 1
  store i32 3, ptr %tt44, align 8
  %32 = load ptr, ptr %stack_last.i, align 8
  %33 = load ptr, ptr %top.i, align 8
  %sub.ptr.lhs.cast47 = ptrtoint ptr %32 to i64
  %sub.ptr.rhs.cast48 = ptrtoint ptr %33 to i64
  %sub.ptr.sub49 = sub i64 %sub.ptr.lhs.cast47, %sub.ptr.rhs.cast48
  %cmp50 = icmp slt i64 %sub.ptr.sub49, 17
  br i1 %cmp50, label %if.then52, label %sw.epilog

if.then52:                                        ; preds = %vaarg.end40
  %34 = load i32, ptr %stacksize.i, align 8
  %cmp.not.i85 = icmp slt i32 %34, 1
  %add.i89 = add nsw i32 %34, 1
  %mul.i87 = shl nuw nsw i32 %34, 1
  %add.i89.sink = select i1 %cmp.not.i85, i32 %add.i89, i32 %mul.i87
  br label %sw.epilog.sink.split

sw.bb57:                                          ; preds = %if.end8
  %fp_offset = load i32, ptr %fp_offset_p, align 4
  %fits_in_fp = icmp ult i32 %fp_offset, 161
  br i1 %fits_in_fp, label %vaarg.in_reg60, label %vaarg.in_mem62

vaarg.in_reg60:                                   ; preds = %sw.bb57
  %reg_save_area61 = load ptr, ptr %5, align 8
  %35 = zext nneg i32 %fp_offset to i64
  %36 = getelementptr i8, ptr %reg_save_area61, i64 %35
  %37 = add nuw nsw i32 %fp_offset, 16
  store i32 %37, ptr %fp_offset_p, align 4
  br label %vaarg.end66

vaarg.in_mem62:                                   ; preds = %sw.bb57
  %overflow_arg_area64 = load ptr, ptr %overflow_arg_area_p91, align 8
  %overflow_arg_area.next65 = getelementptr i8, ptr %overflow_arg_area64, i64 8
  store ptr %overflow_arg_area.next65, ptr %overflow_arg_area_p91, align 8
  br label %vaarg.end66

vaarg.end66:                                      ; preds = %vaarg.in_mem62, %vaarg.in_reg60
  %vaarg.addr67 = phi ptr [ %36, %vaarg.in_reg60 ], [ %overflow_arg_area64, %vaarg.in_mem62 ]
  %38 = load double, ptr %vaarg.addr67, align 8
  store double %38, ptr %incdec.ptr, align 8
  %tt69 = getelementptr inbounds %struct.lua_TValue, ptr %10, i64 1, i32 1
  store i32 3, ptr %tt69, align 8
  %39 = load ptr, ptr %stack_last.i, align 8
  %40 = load ptr, ptr %top.i, align 8
  %sub.ptr.lhs.cast72 = ptrtoint ptr %39 to i64
  %sub.ptr.rhs.cast73 = ptrtoint ptr %40 to i64
  %sub.ptr.sub74 = sub i64 %sub.ptr.lhs.cast72, %sub.ptr.rhs.cast73
  %cmp75 = icmp slt i64 %sub.ptr.sub74, 17
  br i1 %cmp75, label %if.then77, label %sw.epilog

if.then77:                                        ; preds = %vaarg.end66
  %41 = load i32, ptr %stacksize.i, align 8
  %cmp.not.i92 = icmp slt i32 %41, 1
  %add.i96 = add nsw i32 %41, 1
  %mul.i94 = shl nuw nsw i32 %41, 1
  %add.i96.sink = select i1 %cmp.not.i92, i32 %add.i96, i32 %mul.i94
  br label %sw.epilog.sink.split

sw.bb82:                                          ; preds = %if.end8
  %gp_offset86 = load i32, ptr %argp, align 8
  %fits_in_gp87 = icmp ult i32 %gp_offset86, 41
  br i1 %fits_in_gp87, label %vaarg.in_reg88, label %vaarg.in_mem90

vaarg.in_reg88:                                   ; preds = %sw.bb82
  %reg_save_area89 = load ptr, ptr %5, align 8
  %42 = zext nneg i32 %gp_offset86 to i64
  %43 = getelementptr i8, ptr %reg_save_area89, i64 %42
  %44 = add nuw nsw i32 %gp_offset86, 8
  store i32 %44, ptr %argp, align 8
  br label %vaarg.end94

vaarg.in_mem90:                                   ; preds = %sw.bb82
  %overflow_arg_area92 = load ptr, ptr %overflow_arg_area_p91, align 8
  %overflow_arg_area.next93 = getelementptr i8, ptr %overflow_arg_area92, i64 8
  store ptr %overflow_arg_area.next93, ptr %overflow_arg_area_p91, align 8
  br label %vaarg.end94

vaarg.end94:                                      ; preds = %vaarg.in_mem90, %vaarg.in_reg88
  %vaarg.addr95 = phi ptr [ %43, %vaarg.in_reg88 ], [ %overflow_arg_area92, %vaarg.in_mem90 ]
  %45 = load ptr, ptr %vaarg.addr95, align 8
  %call96 = call i32 (ptr, ptr, ...) @sprintf(ptr noundef nonnull dereferenceable(1) %buff83, ptr noundef nonnull dereferenceable(1) @.str.13, ptr noundef %45) #35
  %46 = load ptr, ptr %top.i, align 8
  %call.i99 = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %buff83) #34
  %call1.i100 = call fastcc ptr @luaS_newlstr(ptr noundef nonnull %L, ptr noundef nonnull %buff83, i64 noundef %call.i99)
  store ptr %call1.i100, ptr %46, align 8
  %tt.i101 = getelementptr inbounds %struct.lua_TValue, ptr %46, i64 0, i32 1
  store i32 4, ptr %tt.i101, align 8
  %47 = load ptr, ptr %stack_last.i, align 8
  %48 = load ptr, ptr %top.i, align 8
  %sub.ptr.lhs.cast.i103 = ptrtoint ptr %47 to i64
  %sub.ptr.rhs.cast.i104 = ptrtoint ptr %48 to i64
  %sub.ptr.sub.i105 = sub i64 %sub.ptr.lhs.cast.i103, %sub.ptr.rhs.cast.i104
  %cmp.i106 = icmp slt i64 %sub.ptr.sub.i105, 17
  br i1 %cmp.i106, label %if.then.i108, label %sw.epilog

if.then.i108:                                     ; preds = %vaarg.end94
  %49 = load i32, ptr %stacksize.i, align 8
  %cmp.not.i.i110 = icmp slt i32 %49, 1
  %mul.i.i112 = shl nuw nsw i32 %49, 1
  %add.i.i115 = add nsw i32 %49, 1
  %mul.i.i112.sink = select i1 %cmp.not.i.i110, i32 %add.i.i115, i32 %mul.i.i112
  br label %sw.epilog.sink.split

sw.bb98:                                          ; preds = %if.end8
  %call1.i119 = tail call fastcc ptr @luaS_newlstr(ptr noundef nonnull %L, ptr noundef nonnull @.str.14, i64 noundef 1)
  store ptr %call1.i119, ptr %incdec.ptr, align 8
  %tt.i120 = getelementptr inbounds %struct.lua_TValue, ptr %10, i64 1, i32 1
  store i32 4, ptr %tt.i120, align 8
  %50 = load ptr, ptr %stack_last.i, align 8
  %51 = load ptr, ptr %top.i, align 8
  %sub.ptr.lhs.cast.i122 = ptrtoint ptr %50 to i64
  %sub.ptr.rhs.cast.i123 = ptrtoint ptr %51 to i64
  %sub.ptr.sub.i124 = sub i64 %sub.ptr.lhs.cast.i122, %sub.ptr.rhs.cast.i123
  %cmp.i125 = icmp slt i64 %sub.ptr.sub.i124, 17
  br i1 %cmp.i125, label %if.then.i127, label %sw.epilog

if.then.i127:                                     ; preds = %sw.bb98
  %52 = load i32, ptr %stacksize.i, align 8
  %cmp.not.i.i129 = icmp slt i32 %52, 1
  %mul.i.i131 = shl nuw nsw i32 %52, 1
  %add.i.i134 = add nsw i32 %52, 1
  %mul.i.i131.sink = select i1 %cmp.not.i.i129, i32 %add.i.i134, i32 %mul.i.i131
  br label %sw.epilog.sink.split

sw.default:                                       ; preds = %if.end8
  store i8 37, ptr %buff99, align 1
  store i8 %11, ptr %arrayidx102, align 1
  store i8 0, ptr %arrayidx103, align 1
  %call.i137 = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %buff99) #34
  %call1.i138 = call fastcc ptr @luaS_newlstr(ptr noundef nonnull %L, ptr noundef nonnull %buff99, i64 noundef %call.i137)
  store ptr %call1.i138, ptr %incdec.ptr, align 8
  %tt.i139 = getelementptr inbounds %struct.lua_TValue, ptr %10, i64 1, i32 1
  store i32 4, ptr %tt.i139, align 8
  %53 = load ptr, ptr %stack_last.i, align 8
  %54 = load ptr, ptr %top.i, align 8
  %sub.ptr.lhs.cast.i141 = ptrtoint ptr %53 to i64
  %sub.ptr.rhs.cast.i142 = ptrtoint ptr %54 to i64
  %sub.ptr.sub.i143 = sub i64 %sub.ptr.lhs.cast.i141, %sub.ptr.rhs.cast.i142
  %cmp.i144 = icmp slt i64 %sub.ptr.sub.i143, 17
  br i1 %cmp.i144, label %if.then.i146, label %sw.epilog

if.then.i146:                                     ; preds = %sw.default
  %55 = load i32, ptr %stacksize.i, align 8
  %cmp.not.i.i148 = icmp slt i32 %55, 1
  %mul.i.i150 = shl nuw nsw i32 %55, 1
  %add.i.i153 = add nsw i32 %55, 1
  %mul.i.i150.sink = select i1 %cmp.not.i.i148, i32 %add.i.i153, i32 %mul.i.i150
  br label %sw.epilog.sink.split

sw.epilog.sink.split:                             ; preds = %if.then.i56, %if.then.i75, %if.then52, %if.then77, %if.then.i108, %if.then.i127, %if.then.i146
  %mul.i.i150.sink.sink = phi i32 [ %mul.i.i150.sink, %if.then.i146 ], [ %mul.i.i131.sink, %if.then.i127 ], [ %mul.i.i112.sink, %if.then.i108 ], [ %add.i96.sink, %if.then77 ], [ %add.i89.sink, %if.then52 ], [ %mul.i.i79.sink, %if.then.i75 ], [ %mul.i.i60.sink, %if.then.i56 ]
  tail call fastcc void @luaD_reallocstack(ptr noundef nonnull %L, i32 noundef %mul.i.i150.sink.sink)
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.epilog.sink.split, %sw.default, %sw.bb98, %vaarg.end94, %vaarg.end66, %vaarg.end40, %vaarg.end24, %vaarg.end
  %56 = load ptr, ptr %top.i, align 8
  %incdec.ptr.i145 = getelementptr inbounds %struct.lua_TValue, ptr %56, i64 1
  store ptr %incdec.ptr.i145, ptr %top.i, align 8
  %add = add nuw nsw i32 %n.0176, 2
  %add.ptr105 = getelementptr inbounds i8, ptr %call178, i64 2
  %call = tail call ptr @strchr(ptr noundef nonnull dereferenceable(1) %add.ptr105, i32 noundef 37) #34
  %cmp = icmp eq ptr %call, null
  br i1 %cmp, label %for.end, label %if.end

for.end:                                          ; preds = %sw.epilog, %pushstr.exit
  %57 = phi ptr [ %incdec.ptr.i, %pushstr.exit ], [ %incdec.ptr.i145, %sw.epilog ]
  %n.0.lcssa = phi i32 [ 1, %pushstr.exit ], [ %add, %sw.epilog ]
  %fmt.addr.0.lcssa = phi ptr [ %fmt, %pushstr.exit ], [ %add.ptr105, %sw.epilog ]
  %call.i156 = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %fmt.addr.0.lcssa) #34
  %call1.i157 = tail call fastcc ptr @luaS_newlstr(ptr noundef nonnull %L, ptr noundef %fmt.addr.0.lcssa, i64 noundef %call.i156)
  store ptr %call1.i157, ptr %57, align 8
  %tt.i158 = getelementptr inbounds %struct.lua_TValue, ptr %57, i64 0, i32 1
  store i32 4, ptr %tt.i158, align 8
  %58 = load ptr, ptr %stack_last.i, align 8
  %59 = load ptr, ptr %top.i, align 8
  %sub.ptr.lhs.cast.i160 = ptrtoint ptr %58 to i64
  %sub.ptr.rhs.cast.i161 = ptrtoint ptr %59 to i64
  %sub.ptr.sub.i162 = sub i64 %sub.ptr.lhs.cast.i160, %sub.ptr.rhs.cast.i161
  %cmp.i163 = icmp slt i64 %sub.ptr.sub.i162, 17
  br i1 %cmp.i163, label %if.then.i165, label %pushstr.exit173

if.then.i165:                                     ; preds = %for.end
  %stacksize.i.i166 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 13
  %60 = load i32, ptr %stacksize.i.i166, align 8
  %cmp.not.i.i167 = icmp slt i32 %60, 1
  %mul.i.i169 = shl nuw nsw i32 %60, 1
  %add.i.i172 = add nsw i32 %60, 1
  %mul.i.i169.sink = select i1 %cmp.not.i.i167, i32 %add.i.i172, i32 %mul.i.i169
  tail call fastcc void @luaD_reallocstack(ptr noundef nonnull %L, i32 noundef %mul.i.i169.sink)
  br label %pushstr.exit173

pushstr.exit173:                                  ; preds = %if.then.i165, %for.end
  %61 = load ptr, ptr %top.i, align 8
  %incdec.ptr.i164 = getelementptr inbounds %struct.lua_TValue, ptr %61, i64 1
  store ptr %incdec.ptr.i164, ptr %top.i, align 8
  %add106 = add nuw nsw i32 %n.0.lcssa, 1
  %base = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %62 = load ptr, ptr %base, align 8
  %sub.ptr.lhs.cast108 = ptrtoint ptr %incdec.ptr.i164 to i64
  %sub.ptr.rhs.cast109 = ptrtoint ptr %62 to i64
  %sub.ptr.sub110 = sub i64 %sub.ptr.lhs.cast108, %sub.ptr.rhs.cast109
  %sub.ptr.div = lshr exact i64 %sub.ptr.sub110, 4
  %conv111 = trunc i64 %sub.ptr.div to i32
  %sub = add nsw i32 %conv111, -1
  tail call fastcc void @luaV_concat(ptr noundef nonnull %L, i32 noundef %add106, i32 noundef %sub)
  %63 = load ptr, ptr %top.i, align 8
  %idx.ext = zext nneg i32 %n.0.lcssa to i64
  %idx.neg = sub nsw i64 0, %idx.ext
  %add.ptr113 = getelementptr inbounds %struct.lua_TValue, ptr %63, i64 %idx.neg
  store ptr %add.ptr113, ptr %top.i, align 8
  %add.ptr115 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr113, i64 -1
  %64 = load ptr, ptr %add.ptr115, align 8
  %add.ptr117 = getelementptr inbounds %union.TString, ptr %64, i64 1
  ret ptr %add.ptr117
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn
declare void @llvm.va_end(ptr) #8

; Function Attrs: noreturn nounwind uwtable
define internal fastcc void @luaG_errormsg(ptr noundef %L) unnamed_addr #7 {
entry:
  %errfunc = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 27
  %0 = load i64, ptr %errfunc, align 8
  %cmp.not = icmp eq i64 %0, 0
  br i1 %cmp.not, label %if.end25, label %if.then

if.then:                                          ; preds = %entry
  %stack = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 10
  %1 = load ptr, ptr %stack, align 8
  %add.ptr = getelementptr inbounds i8, ptr %1, i64 %0
  %tt = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr, i64 0, i32 1
  %2 = load i32, ptr %tt, align 8
  %cmp3 = icmp eq i32 %2, 6
  br i1 %cmp3, label %if.end, label %if.then4

if.then4:                                         ; preds = %if.then
  %errorJmp.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 26
  %3 = load ptr, ptr %errorJmp.i, align 8
  %tobool.not.i = icmp eq ptr %3, null
  br i1 %tobool.not.i, label %if.else.i, label %if.then.i

if.then.i:                                        ; preds = %if.then4
  %status.i = getelementptr inbounds %struct.lua_longjmp, ptr %3, i64 0, i32 2
  store volatile i32 5, ptr %status.i, align 8
  %4 = load ptr, ptr %errorJmp.i, align 8
  %b.i = getelementptr inbounds %struct.lua_longjmp, ptr %4, i64 0, i32 1
  tail call void @longjmp(ptr noundef nonnull %b.i, i32 noundef 1) #38
  unreachable

if.else.i:                                        ; preds = %if.then4
  %status3.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 3
  store i8 5, ptr %status3.i, align 2
  %l_G.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %5 = load ptr, ptr %l_G.i, align 8
  %panic.i = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 19
  %6 = load ptr, ptr %panic.i, align 8
  %tobool4.not.i = icmp eq ptr %6, null
  br i1 %tobool4.not.i, label %if.end.i, label %if.then5.i

if.then5.i:                                       ; preds = %if.else.i
  %base_ci.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 12
  %7 = load ptr, ptr %base_ci.i, align 8
  %ci.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  store ptr %7, ptr %ci.i, align 8
  %8 = load ptr, ptr %7, align 8
  %base2.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  store ptr %8, ptr %base2.i, align 8
  tail call fastcc void @luaF_close(ptr noundef nonnull %L, ptr noundef %8)
  %9 = load ptr, ptr %base2.i, align 8
  %call3.i.i = tail call fastcc ptr @luaS_newlstr(ptr noundef nonnull %L, ptr noundef nonnull @.str.4, i64 noundef 23)
  store ptr %call3.i.i, ptr %9, align 8
  %tt5.i.i = getelementptr inbounds %struct.lua_TValue, ptr %9, i64 0, i32 1
  store i32 4, ptr %tt5.i.i, align 8
  %add.ptr11.i.i = getelementptr inbounds %struct.lua_TValue, ptr %9, i64 1
  %top12.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  store ptr %add.ptr11.i.i, ptr %top12.i.i, align 8
  %baseCcalls.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 16
  %10 = load i16, ptr %baseCcalls.i, align 2
  %nCcalls.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 15
  store i16 %10, ptr %nCcalls.i, align 8
  %allowhook.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 18
  store i8 1, ptr %allowhook.i, align 1
  %size_ci.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 14
  %11 = load i32, ptr %size_ci.i.i, align 4
  %cmp.i.i = icmp sgt i32 %11, 20000
  br i1 %cmp.i.i, label %if.then.i.i, label %resetstack.exit

if.then.i.i:                                      ; preds = %if.then5.i
  %12 = load ptr, ptr %ci.i, align 8
  %13 = load ptr, ptr %base_ci.i, align 8
  %sub.ptr.lhs.cast.i.i = ptrtoint ptr %12 to i64
  %sub.ptr.rhs.cast.i.i = ptrtoint ptr %13 to i64
  %sub.ptr.sub.i.i = sub i64 %sub.ptr.lhs.cast.i.i, %sub.ptr.rhs.cast.i.i
  %sub.ptr.div.i.i = sdiv exact i64 %sub.ptr.sub.i.i, 40
  %conv.i.i = trunc i64 %sub.ptr.div.i.i to i32
  %cmp1.i.i = icmp slt i32 %conv.i.i, 19999
  br i1 %cmp1.i.i, label %if.then3.i.i, label %resetstack.exit

if.then3.i.i:                                     ; preds = %if.then.i.i
  tail call fastcc void @luaD_reallocCI(ptr noundef nonnull %L, i32 noundef 20000)
  br label %resetstack.exit

resetstack.exit:                                  ; preds = %if.then5.i, %if.then.i.i, %if.then3.i.i
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %errorJmp.i, i8 0, i64 16, i1 false)
  %14 = load ptr, ptr %l_G.i, align 8
  %panic7.i = getelementptr inbounds %struct.global_State, ptr %14, i64 0, i32 19
  %15 = load ptr, ptr %panic7.i, align 8
  %call.i = tail call i32 %15(ptr noundef nonnull %L) #35
  br label %if.end.i

if.end.i:                                         ; preds = %resetstack.exit, %if.else.i
  tail call void @exit(i32 noundef 1) #38
  unreachable

if.end:                                           ; preds = %if.then
  %top = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %16 = load ptr, ptr %top, align 8
  %add.ptr5 = getelementptr inbounds %struct.lua_TValue, ptr %16, i64 -1
  %17 = load i64, ptr %add.ptr5, align 8
  store i64 %17, ptr %16, align 8
  %tt8 = getelementptr %struct.lua_TValue, ptr %16, i64 -1, i32 1
  %18 = load i32, ptr %tt8, align 8
  %tt9 = getelementptr inbounds %struct.lua_TValue, ptr %16, i64 0, i32 1
  store i32 %18, ptr %tt9, align 8
  %19 = load ptr, ptr %top, align 8
  %add.ptr13 = getelementptr inbounds %struct.lua_TValue, ptr %19, i64 -1
  %20 = load i64, ptr %add.ptr, align 8
  store i64 %20, ptr %add.ptr13, align 8
  %21 = load i32, ptr %tt, align 8
  %tt17 = getelementptr %struct.lua_TValue, ptr %19, i64 -1, i32 1
  store i32 %21, ptr %tt17, align 8
  %stack_last = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 9
  %22 = load ptr, ptr %stack_last, align 8
  %23 = load ptr, ptr %top, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %22 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %23 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp19 = icmp slt i64 %sub.ptr.sub, 17
  br i1 %cmp19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %if.end
  %stacksize.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 13
  %24 = load i32, ptr %stacksize.i, align 8
  %cmp.not.i = icmp slt i32 %24, 1
  %add.i = add nsw i32 %24, 1
  %mul.i = shl nuw nsw i32 %24, 1
  %add.i.sink = select i1 %cmp.not.i, i32 %add.i, i32 %mul.i
  tail call fastcc void @luaD_reallocstack(ptr noundef nonnull %L, i32 noundef %add.i.sink)
  br label %if.end21

if.end21:                                         ; preds = %if.then20, %if.end
  %25 = load ptr, ptr %top, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue, ptr %25, i64 1
  store ptr %incdec.ptr, ptr %top, align 8
  %add.ptr24 = getelementptr inbounds %struct.lua_TValue, ptr %25, i64 -1
  tail call fastcc void @luaD_call(ptr noundef nonnull %L, ptr noundef nonnull %add.ptr24, i32 noundef 1)
  br label %if.end25

if.end25:                                         ; preds = %if.end21, %entry
  %errorJmp.i22 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 26
  %26 = load ptr, ptr %errorJmp.i22, align 8
  %tobool.not.i23 = icmp eq ptr %26, null
  br i1 %tobool.not.i23, label %if.else.i27, label %if.then.i24

if.then.i24:                                      ; preds = %if.end25
  %status.i25 = getelementptr inbounds %struct.lua_longjmp, ptr %26, i64 0, i32 2
  store volatile i32 2, ptr %status.i25, align 8
  %27 = load ptr, ptr %errorJmp.i22, align 8
  %b.i26 = getelementptr inbounds %struct.lua_longjmp, ptr %27, i64 0, i32 1
  tail call void @longjmp(ptr noundef nonnull %b.i26, i32 noundef 1) #38
  unreachable

if.else.i27:                                      ; preds = %if.end25
  %status3.i28 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 3
  store i8 2, ptr %status3.i28, align 2
  %l_G.i29 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %28 = load ptr, ptr %l_G.i29, align 8
  %panic.i30 = getelementptr inbounds %struct.global_State, ptr %28, i64 0, i32 19
  %29 = load ptr, ptr %panic.i30, align 8
  %tobool4.not.i31 = icmp eq ptr %29, null
  br i1 %tobool4.not.i31, label %if.end.i35, label %if.then5.i32

if.then5.i32:                                     ; preds = %if.else.i27
  %base_ci.i38 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 12
  %30 = load ptr, ptr %base_ci.i38, align 8
  %ci.i39 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  store ptr %30, ptr %ci.i39, align 8
  %31 = load ptr, ptr %30, align 8
  %base2.i40 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  store ptr %31, ptr %base2.i40, align 8
  tail call fastcc void @luaF_close(ptr noundef nonnull %L, ptr noundef %31)
  %32 = load ptr, ptr %base2.i40, align 8
  %top.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %33 = load ptr, ptr %top.i.i, align 8
  %add.ptr.i.i = getelementptr inbounds %struct.lua_TValue, ptr %33, i64 -1
  %34 = load i64, ptr %add.ptr.i.i, align 8
  store i64 %34, ptr %32, align 8
  %tt9.i.i = getelementptr %struct.lua_TValue, ptr %33, i64 -1, i32 1
  %35 = load i32, ptr %tt9.i.i, align 8
  %tt10.i.i = getelementptr inbounds %struct.lua_TValue, ptr %32, i64 0, i32 1
  store i32 %35, ptr %tt10.i.i, align 8
  %add.ptr11.i.i41 = getelementptr inbounds %struct.lua_TValue, ptr %32, i64 1
  store ptr %add.ptr11.i.i41, ptr %top.i.i, align 8
  %baseCcalls.i43 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 16
  %36 = load i16, ptr %baseCcalls.i43, align 2
  %nCcalls.i44 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 15
  store i16 %36, ptr %nCcalls.i44, align 8
  %allowhook.i45 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 18
  store i8 1, ptr %allowhook.i45, align 1
  %size_ci.i.i46 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 14
  %37 = load i32, ptr %size_ci.i.i46, align 4
  %cmp.i.i47 = icmp sgt i32 %37, 20000
  br i1 %cmp.i.i47, label %if.then.i.i50, label %resetstack.exit60

if.then.i.i50:                                    ; preds = %if.then5.i32
  %38 = load ptr, ptr %ci.i39, align 8
  %39 = load ptr, ptr %base_ci.i38, align 8
  %sub.ptr.lhs.cast.i.i53 = ptrtoint ptr %38 to i64
  %sub.ptr.rhs.cast.i.i54 = ptrtoint ptr %39 to i64
  %sub.ptr.sub.i.i55 = sub i64 %sub.ptr.lhs.cast.i.i53, %sub.ptr.rhs.cast.i.i54
  %sub.ptr.div.i.i56 = sdiv exact i64 %sub.ptr.sub.i.i55, 40
  %conv.i.i57 = trunc i64 %sub.ptr.div.i.i56 to i32
  %cmp1.i.i58 = icmp slt i32 %conv.i.i57, 19999
  br i1 %cmp1.i.i58, label %if.then3.i.i59, label %resetstack.exit60

if.then3.i.i59:                                   ; preds = %if.then.i.i50
  tail call fastcc void @luaD_reallocCI(ptr noundef nonnull %L, i32 noundef 20000)
  br label %resetstack.exit60

resetstack.exit60:                                ; preds = %if.then5.i32, %if.then.i.i50, %if.then3.i.i59
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %errorJmp.i22, i8 0, i64 16, i1 false)
  %40 = load ptr, ptr %l_G.i29, align 8
  %panic7.i33 = getelementptr inbounds %struct.global_State, ptr %40, i64 0, i32 19
  %41 = load ptr, ptr %panic7.i33, align 8
  %call.i34 = tail call i32 %41(ptr noundef nonnull %L) #35
  br label %if.end.i35

if.end.i35:                                       ; preds = %resetstack.exit60, %if.else.i27
  tail call void @exit(i32 noundef 1) #38
  unreachable
}

; Function Attrs: mustprogress nofree nounwind willreturn memory(readwrite, inaccessiblemem: none) uwtable
define internal fastcc void @luaO_chunkid(ptr noundef %out, ptr nocapture noundef readonly %source, i64 noundef %bufflen) unnamed_addr #9 {
entry:
  %0 = load i8, ptr %source, align 1
  switch i8 %0, label %if.else16 [
    i8 61, label %if.then
    i8 64, label %if.then5
  ]

if.then:                                          ; preds = %entry
  %add.ptr = getelementptr inbounds i8, ptr %source, i64 1
  %call = tail call ptr @strncpy(ptr noundef %out, ptr noundef nonnull %add.ptr, i64 noundef %bufflen) #35
  %1 = getelementptr i8, ptr %out, i64 %bufflen
  %arrayidx = getelementptr i8, ptr %1, i64 -1
  store i8 0, ptr %arrayidx, align 1
  br label %if.end36

if.then5:                                         ; preds = %entry
  %incdec.ptr = getelementptr inbounds i8, ptr %source, i64 1
  %sub6 = add nsw i64 %bufflen, -8
  %call7 = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %incdec.ptr) #34
  store i8 0, ptr %out, align 1
  %cmp9 = icmp ugt i64 %call7, %sub6
  br i1 %cmp9, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then5
  %sub12 = sub i64 %call7, %sub6
  %add.ptr13 = getelementptr inbounds i8, ptr %incdec.ptr, i64 %sub12
  %strlen32 = tail call i64 @strlen(ptr nonnull dereferenceable(1) %out)
  %endptr33 = getelementptr inbounds i8, ptr %out, i64 %strlen32
  store i32 3026478, ptr %endptr33, align 1
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then5
  %source.addr.0 = phi ptr [ %add.ptr13, %if.then11 ], [ %incdec.ptr, %if.then5 ]
  %call15 = tail call ptr @strcat(ptr noundef nonnull dereferenceable(1) %out, ptr noundef nonnull dereferenceable(1) %source.addr.0) #35
  br label %if.end36

if.else16:                                        ; preds = %entry
  %call17 = tail call i64 @strcspn(ptr noundef nonnull %source, ptr noundef nonnull @.str.9) #34
  %sub18 = add nsw i64 %bufflen, -17
  %spec.select = tail call i64 @llvm.umin.i64(i64 %call17, i64 %sub18)
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(10) %out, ptr noundef nonnull align 1 dereferenceable(10) @.str.10, i64 10, i1 false) #35
  %arrayidx24 = getelementptr inbounds i8, ptr %source, i64 %spec.select
  %2 = load i8, ptr %arrayidx24, align 1
  %cmp26.not = icmp eq i8 %2, 0
  br i1 %cmp26.not, label %if.else31, label %if.then28

if.then28:                                        ; preds = %if.else16
  %call29 = tail call ptr @strncat(ptr noundef nonnull dereferenceable(1) %out, ptr noundef nonnull %source, i64 noundef %spec.select) #35
  %strlen = tail call i64 @strlen(ptr nonnull dereferenceable(1) %out)
  %endptr = getelementptr inbounds i8, ptr %out, i64 %strlen
  store i32 3026478, ptr %endptr, align 1
  br label %if.end33

if.else31:                                        ; preds = %if.else16
  %call32 = tail call ptr @strcat(ptr noundef nonnull dereferenceable(1) %out, ptr noundef nonnull dereferenceable(1) %source) #35
  br label %if.end33

if.end33:                                         ; preds = %if.else31, %if.then28
  %strlen30 = tail call i64 @strlen(ptr nonnull dereferenceable(1) %out)
  %endptr31 = getelementptr inbounds i8, ptr %out, i64 %strlen30
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %endptr31, ptr noundef nonnull align 1 dereferenceable(3) @.str.11, i64 3, i1 false)
  br label %if.end36

if.end36:                                         ; preds = %if.end, %if.end33, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal ptr @luaO_pushfstring(ptr noundef %L, ptr noundef %fmt, ...) unnamed_addr #0 {
entry:
  %argp = alloca [1 x %struct.__va_list_tag], align 16
  call void @llvm.va_start(ptr nonnull %argp)
  %call = call fastcc ptr @luaO_pushvfstring(ptr noundef %L, ptr noundef %fmt, ptr noundef nonnull %argp)
  call void @llvm.va_end(ptr nonnull %argp)
  ret ptr %call
}

; Function Attrs: mustprogress nofree nounwind willreturn memory(argmem: readwrite)
declare ptr @strncpy(ptr noalias noundef returned writeonly, ptr noalias nocapture noundef readonly, i64 noundef) local_unnamed_addr #10

; Function Attrs: mustprogress nofree nounwind willreturn memory(argmem: read)
declare i64 @strlen(ptr nocapture noundef) local_unnamed_addr #11

; Function Attrs: mustprogress nofree nounwind willreturn memory(argmem: readwrite)
declare ptr @strcat(ptr noalias noundef returned, ptr noalias nocapture noundef readonly) local_unnamed_addr #10

; Function Attrs: mustprogress nofree nounwind willreturn memory(argmem: read)
declare i64 @strcspn(ptr nocapture noundef, ptr nocapture noundef) local_unnamed_addr #11

; Function Attrs: mustprogress nofree nounwind willreturn memory(argmem: readwrite)
declare ptr @strncat(ptr noalias noundef returned, ptr noalias nocapture noundef readonly, i64 noundef) local_unnamed_addr #10

; Function Attrs: mustprogress nofree nounwind willreturn memory(argmem: read)
declare ptr @strchr(ptr noundef, i32 noundef) local_unnamed_addr #11

; Function Attrs: nofree nounwind
declare noundef i32 @sprintf(ptr noalias nocapture noundef writeonly, ptr nocapture noundef readonly, ...) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define internal fastcc void @luaV_concat(ptr noundef %L, i32 noundef %total, i32 noundef %last) unnamed_addr #0 {
entry:
  %s.i62 = alloca [32 x i8], align 16
  %s.i53 = alloca [32 x i8], align 16
  %s.i = alloca [32 x i8], align 16
  %base = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %l_G = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  br label %do.body

do.body:                                          ; preds = %if.end83, %entry
  %last.addr.0 = phi i32 [ %last, %entry ], [ %sub87, %if.end83 ]
  %total.addr.0 = phi i32 [ %total, %entry ], [ %sub85, %if.end83 ]
  %0 = load ptr, ptr %base, align 8
  %idx.ext = sext i32 %last.addr.0 to i64
  %add.ptr = getelementptr inbounds %struct.lua_TValue, ptr %0, i64 %idx.ext
  %add.ptr1 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr, i64 1
  %add.ptr2 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr, i64 -1
  %tt = getelementptr %struct.lua_TValue, ptr %add.ptr, i64 -1, i32 1
  %1 = load i32, ptr %tt, align 8
  %.off = add i32 %1, -3
  %switch = icmp ult i32 %.off, 2
  br i1 %switch, label %lor.lhs.false6, label %if.then

lor.lhs.false6:                                   ; preds = %do.body
  %tt8 = getelementptr inbounds %struct.lua_TValue, ptr %0, i64 %idx.ext, i32 1
  %2 = load i32, ptr %tt8, align 8
  %cmp9 = icmp eq i32 %2, 4
  br i1 %cmp9, label %lor.lhs.false6.if.else_crit_edge, label %lor.lhs.false10

lor.lhs.false6.if.else_crit_edge:                 ; preds = %lor.lhs.false6
  %.pre = load ptr, ptr %add.ptr, align 8
  br label %if.else

lor.lhs.false10:                                  ; preds = %lor.lhs.false6
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %s.i)
  %cmp.i = icmp eq i32 %2, 3
  br i1 %cmp.i, label %luaV_tostring.exit, label %luaV_tostring.exit.thread

luaV_tostring.exit.thread:                        ; preds = %lor.lhs.false10
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %s.i)
  br label %if.then

luaV_tostring.exit:                               ; preds = %lor.lhs.false10
  %3 = load double, ptr %add.ptr, align 8
  %call.i = call i32 (ptr, ptr, ...) @sprintf(ptr noundef nonnull dereferenceable(1) %s.i, ptr noundef nonnull dereferenceable(1) @.str.16, double noundef %3) #35
  %call3.i = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %s.i) #34
  %call4.i = call fastcc ptr @luaS_newlstr(ptr noundef nonnull %L, ptr noundef nonnull %s.i, i64 noundef %call3.i)
  store ptr %call4.i, ptr %add.ptr, align 8
  store i32 4, ptr %tt8, align 8
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %s.i)
  br label %if.else

if.then:                                          ; preds = %luaV_tostring.exit.thread, %do.body
  %call15 = tail call fastcc i32 @call_binTM(ptr noundef nonnull %L, ptr noundef nonnull %add.ptr2, ptr noundef nonnull %add.ptr, ptr noundef nonnull %add.ptr2, i32 noundef 15), !range !23
  %tobool16.not = icmp eq i32 %call15, 0
  br i1 %tobool16.not, label %if.then17, label %if.end83

if.then17:                                        ; preds = %if.then
  %4 = load i32, ptr %tt, align 8
  %.off.i = add i32 %4, -3
  %switch.i = icmp ult i32 %.off.i, 2
  %spec.select.i = select i1 %switch.i, ptr %add.ptr, ptr %add.ptr2
  %tt.i73 = getelementptr inbounds %struct.lua_TValue, ptr %spec.select.i, i64 0, i32 1
  %5 = load i32, ptr %tt.i73, align 8
  %idxprom.i = sext i32 %5 to i64
  %arrayidx.i = getelementptr inbounds [11 x ptr], ptr @luaT_typenames, i64 0, i64 %idxprom.i
  %6 = load ptr, ptr %arrayidx.i, align 8
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef nonnull %L, ptr noundef nonnull @.str.20, ptr noundef nonnull @.str.45, ptr noundef %6)
  unreachable

if.else:                                          ; preds = %lor.lhs.false6.if.else_crit_edge, %luaV_tostring.exit
  %7 = phi ptr [ %.pre, %lor.lhs.false6.if.else_crit_edge ], [ %call4.i, %luaV_tostring.exit ]
  %len = getelementptr inbounds %struct.anon.0, ptr %7, i64 0, i32 5
  %8 = load i64, ptr %len, align 8
  %cmp21 = icmp eq i64 %8, 0
  br i1 %cmp21, label %if.then22, label %for.cond.preheader

for.cond.preheader:                               ; preds = %if.else
  %cmp3386 = icmp sgt i32 %total.addr.0, 1
  br i1 %cmp3386, label %land.rhs.preheader, label %for.end

land.rhs.preheader:                               ; preds = %for.cond.preheader
  %9 = zext nneg i32 %total.addr.0 to i64
  br label %land.rhs

if.then22:                                        ; preds = %if.else
  %10 = load i32, ptr %tt, align 8
  %cmp25 = icmp eq i32 %10, 4
  br i1 %cmp25, label %if.end83, label %lor.rhs

lor.rhs:                                          ; preds = %if.then22
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %s.i53)
  %cmp.i55 = icmp eq i32 %10, 3
  br i1 %cmp.i55, label %if.else.i57, label %luaV_tostring.exit61

if.else.i57:                                      ; preds = %lor.rhs
  %11 = load double, ptr %add.ptr2, align 8
  %call.i58 = call i32 (ptr, ptr, ...) @sprintf(ptr noundef nonnull dereferenceable(1) %s.i53, ptr noundef nonnull dereferenceable(1) @.str.16, double noundef %11) #35
  %call3.i59 = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %s.i53) #34
  %call4.i60 = call fastcc ptr @luaS_newlstr(ptr noundef nonnull %L, ptr noundef nonnull %s.i53, i64 noundef %call3.i59)
  store ptr %call4.i60, ptr %add.ptr2, align 8
  store i32 4, ptr %tt, align 8
  br label %luaV_tostring.exit61

luaV_tostring.exit61:                             ; preds = %lor.rhs, %if.else.i57
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %s.i53)
  br label %if.end83

land.rhs:                                         ; preds = %land.rhs.preheader, %if.end56
  %indvars.iv = phi i64 [ 1, %land.rhs.preheader ], [ %indvars.iv.next, %if.end56 ]
  %tl.087 = phi i64 [ %8, %land.rhs.preheader ], [ %add, %if.end56 ]
  %idx.neg = sub nsw i64 0, %indvars.iv
  %add.ptr35 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr1, i64 %idx.neg
  %add.ptr36 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr35, i64 -1
  %tt37 = getelementptr %struct.lua_TValue, ptr %add.ptr35, i64 -1, i32 1
  %12 = load i32, ptr %tt37, align 8
  %cmp38 = icmp eq i32 %12, 4
  br i1 %cmp38, label %land.rhs.for.body_crit_edge, label %lor.rhs39

land.rhs.for.body_crit_edge:                      ; preds = %land.rhs
  %.pre98 = load ptr, ptr %add.ptr36, align 8
  br label %for.body

lor.rhs39:                                        ; preds = %land.rhs
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %s.i62)
  %cmp.i64 = icmp eq i32 %12, 3
  br i1 %cmp.i64, label %luaV_tostring.exit70, label %luaV_tostring.exit70.thread

luaV_tostring.exit70.thread:                      ; preds = %lor.rhs39
  %13 = trunc i64 %indvars.iv to i32
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %s.i62)
  br label %for.end

luaV_tostring.exit70:                             ; preds = %lor.rhs39
  %14 = load double, ptr %add.ptr36, align 8
  %call.i67 = call i32 (ptr, ptr, ...) @sprintf(ptr noundef nonnull dereferenceable(1) %s.i62, ptr noundef nonnull dereferenceable(1) @.str.16, double noundef %14) #35
  %call3.i68 = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %s.i62) #34
  %call4.i69 = call fastcc ptr @luaS_newlstr(ptr noundef %L, ptr noundef nonnull %s.i62, i64 noundef %call3.i68)
  store ptr %call4.i69, ptr %add.ptr36, align 8
  store i32 4, ptr %tt37, align 8
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %s.i62)
  br label %for.body

for.body:                                         ; preds = %land.rhs.for.body_crit_edge, %luaV_tostring.exit70
  %15 = phi ptr [ %.pre98, %land.rhs.for.body_crit_edge ], [ %call4.i69, %luaV_tostring.exit70 ]
  %len53 = getelementptr inbounds %struct.anon.0, ptr %15, i64 0, i32 5
  %16 = load i64, ptr %len53, align 8
  %sub = sub i64 -3, %tl.087
  %cmp54.not = icmp ult i64 %16, %sub
  br i1 %cmp54.not, label %if.end56, label %if.then55

if.then55:                                        ; preds = %for.body
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef %L, ptr noundef nonnull @.str.15)
  unreachable

if.end56:                                         ; preds = %for.body
  %add = add i64 %16, %tl.087
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %9
  br i1 %exitcond.not, label %for.end, label %land.rhs, !llvm.loop !24

for.end:                                          ; preds = %if.end56, %for.cond.preheader, %luaV_tostring.exit70.thread
  %tl.085 = phi i64 [ %tl.087, %luaV_tostring.exit70.thread ], [ %8, %for.cond.preheader ], [ %add, %if.end56 ]
  %n.083 = phi i32 [ %13, %luaV_tostring.exit70.thread ], [ 1, %for.cond.preheader ], [ %total.addr.0, %if.end56 ]
  %17 = load ptr, ptr %l_G, align 8
  %buff = getelementptr inbounds %struct.global_State, ptr %17, i64 0, i32 12
  %buffsize.i = getelementptr inbounds %struct.global_State, ptr %17, i64 0, i32 12, i32 2
  %18 = load i64, ptr %buffsize.i, align 8
  %cmp.i71 = icmp ult i64 %18, %tl.085
  br i1 %cmp.i71, label %if.then.i, label %for.end.luaZ_openspace.exit_crit_edge

for.end.luaZ_openspace.exit_crit_edge:            ; preds = %for.end
  %.pre99 = load ptr, ptr %buff, align 8
  br label %luaZ_openspace.exit

if.then.i:                                        ; preds = %for.end
  %spec.store.select.i = tail call i64 @llvm.umax.i64(i64 %tl.085, i64 32)
  %add.i = add i64 %spec.store.select.i, 1
  %cmp3.i = icmp ult i64 %add.i, -2
  br i1 %cmp3.i, label %cond.true.i, label %cond.false.i

cond.true.i:                                      ; preds = %if.then.i
  %19 = load ptr, ptr %buff, align 8
  %frealloc.i = getelementptr inbounds %struct.global_State, ptr %17, i64 0, i32 1
  %20 = load ptr, ptr %frealloc.i, align 8
  %ud.i = getelementptr inbounds %struct.global_State, ptr %17, i64 0, i32 2
  %21 = load ptr, ptr %ud.i, align 8
  %call.i74 = tail call ptr %20(ptr noundef %21, ptr noundef %19, i64 noundef %18, i64 noundef %spec.store.select.i) #35
  %cmp.i75 = icmp eq ptr %call.i74, null
  br i1 %cmp.i75, label %if.then.i77, label %luaM_realloc_.exit

if.then.i77:                                      ; preds = %cond.true.i
  %errorJmp.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 26
  %22 = load ptr, ptr %errorJmp.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %22, null
  br i1 %tobool.not.i.i, label %if.else.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %if.then.i77
  %status.i.i = getelementptr inbounds %struct.lua_longjmp, ptr %22, i64 0, i32 2
  store volatile i32 4, ptr %status.i.i, align 8
  %23 = load ptr, ptr %errorJmp.i.i, align 8
  %b.i.i = getelementptr inbounds %struct.lua_longjmp, ptr %23, i64 0, i32 1
  tail call void @longjmp(ptr noundef nonnull %b.i.i, i32 noundef 1) #38
  unreachable

if.else.i.i:                                      ; preds = %if.then.i77
  %status3.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 3
  store i8 4, ptr %status3.i.i, align 2
  %24 = load ptr, ptr %l_G, align 8
  %panic.i.i = getelementptr inbounds %struct.global_State, ptr %24, i64 0, i32 19
  %25 = load ptr, ptr %panic.i.i, align 8
  %tobool4.not.i.i = icmp eq ptr %25, null
  br i1 %tobool4.not.i.i, label %if.end.i.i, label %if.then5.i.i

if.then5.i.i:                                     ; preds = %if.else.i.i
  tail call fastcc void @resetstack(ptr noundef nonnull %L, i32 noundef 4)
  %26 = load ptr, ptr %l_G, align 8
  %panic7.i.i = getelementptr inbounds %struct.global_State, ptr %26, i64 0, i32 19
  %27 = load ptr, ptr %panic7.i.i, align 8
  %call.i.i = tail call i32 %27(ptr noundef nonnull %L) #35
  br label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then5.i.i, %if.else.i.i
  tail call void @exit(i32 noundef 1) #38
  unreachable

luaM_realloc_.exit:                               ; preds = %cond.true.i
  %totalbytes.i = getelementptr inbounds %struct.global_State, ptr %17, i64 0, i32 14
  %28 = load i64, ptr %totalbytes.i, align 8
  %sub.i = sub i64 %spec.store.select.i, %18
  %add.i76 = add i64 %sub.i, %28
  store i64 %add.i76, ptr %totalbytes.i, align 8
  store ptr %call.i74, ptr %buff, align 8
  store i64 %spec.store.select.i, ptr %buffsize.i, align 8
  br label %luaZ_openspace.exit

cond.false.i:                                     ; preds = %if.then.i
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef nonnull %L, ptr noundef nonnull @.str.5)
  unreachable

luaZ_openspace.exit:                              ; preds = %for.end.luaZ_openspace.exit_crit_edge, %luaM_realloc_.exit
  %29 = phi ptr [ %.pre99, %for.end.luaZ_openspace.exit_crit_edge ], [ %call.i74, %luaM_realloc_.exit ]
  %30 = zext nneg i32 %n.083 to i64
  br label %for.body60

for.body60:                                       ; preds = %luaZ_openspace.exit, %for.body60
  %indvars.iv95 = phi i64 [ %30, %luaZ_openspace.exit ], [ %indvars.iv.next96, %for.body60 ]
  %tl.190 = phi i64 [ 0, %luaZ_openspace.exit ], [ %add73, %for.body60 ]
  %idx.neg63 = sub nsw i64 0, %indvars.iv95
  %add.ptr64 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr1, i64 %idx.neg63
  %31 = load ptr, ptr %add.ptr64, align 8
  %len66 = getelementptr inbounds %struct.anon.0, ptr %31, i64 0, i32 5
  %32 = load i64, ptr %len66, align 8
  %add.ptr67 = getelementptr inbounds i8, ptr %29, i64 %tl.190
  %add.ptr72 = getelementptr inbounds %union.TString, ptr %31, i64 1
  tail call void @llvm.memcpy.p0.p0.i64(ptr align 1 %add.ptr67, ptr nonnull align 1 %add.ptr72, i64 %32, i1 false)
  %add73 = add i64 %32, %tl.190
  %indvars.iv.next96 = add nsw i64 %indvars.iv95, -1
  %cmp59 = icmp ugt i64 %indvars.iv95, 1
  br i1 %cmp59, label %for.body60, label %for.end75, !llvm.loop !25

for.end75:                                        ; preds = %for.body60
  %idx.neg77 = sub nsw i64 0, %30
  %add.ptr78 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr1, i64 %idx.neg77
  %call79 = tail call fastcc ptr @luaS_newlstr(ptr noundef %L, ptr noundef %29, i64 noundef %add73)
  store ptr %call79, ptr %add.ptr78, align 8
  %tt81 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr1, i64 %idx.neg77, i32 1
  store i32 4, ptr %tt81, align 8
  br label %if.end83

if.end83:                                         ; preds = %for.end75, %luaV_tostring.exit61, %if.then22, %if.then
  %n.1 = phi i32 [ 2, %if.then22 ], [ 2, %luaV_tostring.exit61 ], [ %n.083, %for.end75 ], [ 2, %if.then ]
  %sub84 = add nsw i32 %n.1, -1
  %sub85 = sub nsw i32 %total.addr.0, %sub84
  %sub87 = sub nsw i32 %last.addr.0, %sub84
  %cmp88 = icmp sgt i32 %sub85, 1
  br i1 %cmp88, label %do.body, label %do.end, !llvm.loop !26

do.end:                                           ; preds = %if.end83
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaD_reallocstack(ptr noundef %L, i32 noundef %newsize) unnamed_addr #0 {
entry:
  %stack = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 10
  %0 = load ptr, ptr %stack, align 8
  %add1 = add nsw i32 %newsize, 6
  %cmp = icmp sgt i32 %newsize, -8
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %stacksize = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 13
  %1 = load i32, ptr %stacksize, align 8
  %conv5 = sext i32 %1 to i64
  %mul = shl nsw i64 %conv5, 4
  %conv6 = sext i32 %add1 to i64
  %mul7 = shl nsw i64 %conv6, 4
  %l_G.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %2 = load ptr, ptr %l_G.i, align 8
  %frealloc.i = getelementptr inbounds %struct.global_State, ptr %2, i64 0, i32 1
  %3 = load ptr, ptr %frealloc.i, align 8
  %ud.i = getelementptr inbounds %struct.global_State, ptr %2, i64 0, i32 2
  %4 = load ptr, ptr %ud.i, align 8
  %call.i = tail call ptr %3(ptr noundef %4, ptr noundef %0, i64 noundef %mul, i64 noundef %mul7) #35
  %cmp.i = icmp eq ptr %call.i, null
  %cmp1.i = icmp ne i32 %add1, 0
  %or.cond.i = and i1 %cmp1.i, %cmp.i
  br i1 %or.cond.i, label %if.then.i, label %luaM_realloc_.exit

if.then.i:                                        ; preds = %cond.true
  %errorJmp.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 26
  %5 = load ptr, ptr %errorJmp.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %5, null
  br i1 %tobool.not.i.i, label %if.else.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %if.then.i
  %status.i.i = getelementptr inbounds %struct.lua_longjmp, ptr %5, i64 0, i32 2
  store volatile i32 4, ptr %status.i.i, align 8
  %6 = load ptr, ptr %errorJmp.i.i, align 8
  %b.i.i = getelementptr inbounds %struct.lua_longjmp, ptr %6, i64 0, i32 1
  tail call void @longjmp(ptr noundef nonnull %b.i.i, i32 noundef 1) #38
  unreachable

if.else.i.i:                                      ; preds = %if.then.i
  %status3.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 3
  store i8 4, ptr %status3.i.i, align 2
  %7 = load ptr, ptr %l_G.i, align 8
  %panic.i.i = getelementptr inbounds %struct.global_State, ptr %7, i64 0, i32 19
  %8 = load ptr, ptr %panic.i.i, align 8
  %tobool4.not.i.i = icmp eq ptr %8, null
  br i1 %tobool4.not.i.i, label %if.end.i.i, label %if.then5.i.i

if.then5.i.i:                                     ; preds = %if.else.i.i
  tail call fastcc void @resetstack(ptr noundef nonnull %L, i32 noundef 4)
  %9 = load ptr, ptr %l_G.i, align 8
  %panic7.i.i = getelementptr inbounds %struct.global_State, ptr %9, i64 0, i32 19
  %10 = load ptr, ptr %panic7.i.i, align 8
  %call.i.i = tail call i32 %10(ptr noundef nonnull %L) #35
  br label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then5.i.i, %if.else.i.i
  tail call void @exit(i32 noundef 1) #38
  unreachable

luaM_realloc_.exit:                               ; preds = %cond.true
  %totalbytes.i = getelementptr inbounds %struct.global_State, ptr %2, i64 0, i32 14
  %11 = load i64, ptr %totalbytes.i, align 8
  %sub.i = sub nsw i64 %mul7, %mul
  %add.i = add i64 %sub.i, %11
  store i64 %add.i, ptr %totalbytes.i, align 8
  store ptr %call.i, ptr %stack, align 8
  %stacksize10 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 13
  store i32 %add1, ptr %stacksize10, align 8
  %idx.ext = sext i32 %newsize to i64
  %add.ptr = getelementptr inbounds %struct.lua_TValue, ptr %call.i, i64 %idx.ext
  %stack_last = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 9
  store ptr %add.ptr, ptr %stack_last, align 8
  %top.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %12 = load ptr, ptr %top.i, align 8
  %sub.ptr.lhs.cast.i = ptrtoint ptr %12 to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %0 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %sub.ptr.div.i = ashr exact i64 %sub.ptr.sub.i, 4
  %add.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %call.i, i64 %sub.ptr.div.i
  store ptr %add.ptr.i, ptr %top.i, align 8
  %openupval.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 24
  %up.028.i = load ptr, ptr %openupval.i, align 8
  %cmp.not29.i = icmp eq ptr %up.028.i, null
  br i1 %cmp.not29.i, label %for.end.i, label %for.body.i

cond.false:                                       ; preds = %entry
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef nonnull %L, ptr noundef nonnull @.str.5)
  unreachable

for.body.i:                                       ; preds = %luaM_realloc_.exit, %for.body.i
  %up.030.i = phi ptr [ %up.0.i, %for.body.i ], [ %up.028.i, %luaM_realloc_.exit ]
  %v.i = getelementptr inbounds %struct.UpVal, ptr %up.030.i, i64 0, i32 3
  %13 = load ptr, ptr %v.i, align 8
  %sub.ptr.lhs.cast2.i = ptrtoint ptr %13 to i64
  %sub.ptr.sub4.i = sub i64 %sub.ptr.lhs.cast2.i, %sub.ptr.rhs.cast.i
  %sub.ptr.div5.i = ashr exact i64 %sub.ptr.sub4.i, 4
  %14 = load ptr, ptr %stack, align 8
  %add.ptr7.i = getelementptr inbounds %struct.lua_TValue, ptr %14, i64 %sub.ptr.div5.i
  store ptr %add.ptr7.i, ptr %v.i, align 8
  %up.0.i = load ptr, ptr %up.030.i, align 8
  %cmp.not.i = icmp eq ptr %up.0.i, null
  br i1 %cmp.not.i, label %for.end.i, label %for.body.i, !llvm.loop !27

for.end.i:                                        ; preds = %for.body.i, %luaM_realloc_.exit
  %base_ci.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 12
  %15 = load ptr, ptr %base_ci.i, align 8
  %ci10.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %16 = load ptr, ptr %ci10.i, align 8
  %cmp11.not31.i = icmp ugt ptr %15, %16
  br i1 %cmp11.not31.i, label %correctstack.exit, label %for.body12.i

for.body12.i:                                     ; preds = %for.end.i, %for.body12.i
  %ci.032.i = phi ptr [ %incdec.ptr.i, %for.body12.i ], [ %15, %for.end.i ]
  %top13.i = getelementptr inbounds %struct.CallInfo, ptr %ci.032.i, i64 0, i32 2
  %17 = load ptr, ptr %top13.i, align 8
  %sub.ptr.lhs.cast14.i = ptrtoint ptr %17 to i64
  %sub.ptr.sub16.i = sub i64 %sub.ptr.lhs.cast14.i, %sub.ptr.rhs.cast.i
  %sub.ptr.div17.i = ashr exact i64 %sub.ptr.sub16.i, 4
  %18 = load ptr, ptr %stack, align 8
  %add.ptr19.i = getelementptr inbounds %struct.lua_TValue, ptr %18, i64 %sub.ptr.div17.i
  store ptr %add.ptr19.i, ptr %top13.i, align 8
  %19 = load ptr, ptr %ci.032.i, align 8
  %sub.ptr.lhs.cast21.i = ptrtoint ptr %19 to i64
  %sub.ptr.sub23.i = sub i64 %sub.ptr.lhs.cast21.i, %sub.ptr.rhs.cast.i
  %sub.ptr.div24.i = ashr exact i64 %sub.ptr.sub23.i, 4
  %20 = load ptr, ptr %stack, align 8
  %add.ptr26.i = getelementptr inbounds %struct.lua_TValue, ptr %20, i64 %sub.ptr.div24.i
  store ptr %add.ptr26.i, ptr %ci.032.i, align 8
  %func.i = getelementptr inbounds %struct.CallInfo, ptr %ci.032.i, i64 0, i32 1
  %21 = load ptr, ptr %func.i, align 8
  %sub.ptr.lhs.cast28.i = ptrtoint ptr %21 to i64
  %sub.ptr.sub30.i = sub i64 %sub.ptr.lhs.cast28.i, %sub.ptr.rhs.cast.i
  %sub.ptr.div31.i = ashr exact i64 %sub.ptr.sub30.i, 4
  %22 = load ptr, ptr %stack, align 8
  %add.ptr33.i = getelementptr inbounds %struct.lua_TValue, ptr %22, i64 %sub.ptr.div31.i
  store ptr %add.ptr33.i, ptr %func.i, align 8
  %incdec.ptr.i = getelementptr inbounds %struct.CallInfo, ptr %ci.032.i, i64 1
  %23 = load ptr, ptr %ci10.i, align 8
  %cmp11.not.i = icmp ugt ptr %incdec.ptr.i, %23
  br i1 %cmp11.not.i, label %correctstack.exit, label %for.body12.i, !llvm.loop !28

correctstack.exit:                                ; preds = %for.body12.i, %for.end.i
  %base37.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %24 = load ptr, ptr %base37.i, align 8
  %sub.ptr.lhs.cast38.i = ptrtoint ptr %24 to i64
  %sub.ptr.sub40.i = sub i64 %sub.ptr.lhs.cast38.i, %sub.ptr.rhs.cast.i
  %sub.ptr.div41.i = ashr exact i64 %sub.ptr.sub40.i, 4
  %25 = load ptr, ptr %stack, align 8
  %add.ptr43.i = getelementptr inbounds %struct.lua_TValue, ptr %25, i64 %sub.ptr.div41.i
  store ptr %add.ptr43.i, ptr %base37.i, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @call_binTM(ptr noundef %L, ptr nocapture noundef readonly %p1, ptr nocapture noundef readonly %p2, ptr noundef %res, i32 noundef %event) unnamed_addr #0 {
entry:
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %p1, i64 0, i32 1
  %0 = load i32, ptr %tt.i, align 8
  switch i32 %0, label %sw.default.i [
    i32 5, label %sw.bb.i
    i32 7, label %sw.bb1.i
  ]

sw.bb.i:                                          ; preds = %entry
  %1 = load ptr, ptr %p1, align 8
  %metatable.i = getelementptr inbounds %struct.Table, ptr %1, i64 0, i32 5
  br label %sw.epilog.i

sw.bb1.i:                                         ; preds = %entry
  %2 = load ptr, ptr %p1, align 8
  %metatable3.i = getelementptr inbounds %struct.anon.1, ptr %2, i64 0, i32 3
  br label %sw.epilog.i

sw.default.i:                                     ; preds = %entry
  %l_G.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %3 = load ptr, ptr %l_G.i, align 8
  %idxprom.i = sext i32 %0 to i64
  %arrayidx.i = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 23, i64 %idxprom.i
  br label %sw.epilog.i

sw.epilog.i:                                      ; preds = %sw.default.i, %sw.bb1.i, %sw.bb.i
  %mt.0.in.i = phi ptr [ %arrayidx.i, %sw.default.i ], [ %metatable3.i, %sw.bb1.i ], [ %metatable.i, %sw.bb.i ]
  %mt.0.i = load ptr, ptr %mt.0.in.i, align 8
  %tobool.not.i = icmp eq ptr %mt.0.i, null
  br i1 %tobool.not.i, label %luaT_gettmbyobj.exit, label %cond.true.i

cond.true.i:                                      ; preds = %sw.epilog.i
  %l_G6.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %4 = load ptr, ptr %l_G6.i, align 8
  %idxprom7.i = zext nneg i32 %event to i64
  %arrayidx8.i = getelementptr inbounds %struct.global_State, ptr %4, i64 0, i32 24, i64 %idxprom7.i
  %5 = load ptr, ptr %arrayidx8.i, align 8
  %6 = getelementptr i8, ptr %mt.0.i, i64 11
  %mt.0.val.i = load i8, ptr %6, align 1
  %7 = getelementptr i8, ptr %mt.0.i, i64 32
  %mt.0.val6.i = load ptr, ptr %7, align 8
  %hash.i.i = getelementptr inbounds %struct.anon.0, ptr %5, i64 0, i32 4
  %8 = load i32, ptr %hash.i.i, align 4
  %sh_prom.i.i = zext nneg i8 %mt.0.val.i to i64
  %notmask.i.i = shl nsw i64 -1, %sh_prom.i.i
  %9 = trunc i64 %notmask.i.i to i32
  %10 = xor i32 %9, -1
  %conv2.i.i = and i32 %8, %10
  %idxprom.i.i = sext i32 %conv2.i.i to i64
  %arrayidx.i.i = getelementptr inbounds %struct.Node, ptr %mt.0.val6.i, i64 %idxprom.i.i
  br label %do.body.i.i

do.body.i.i:                                      ; preds = %if.else.i.i, %cond.true.i
  %n.0.i.i = phi ptr [ %arrayidx.i.i, %cond.true.i ], [ %13, %if.else.i.i ]
  %tt.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1, i32 0, i32 1
  %11 = load i32, ptr %tt.i.i, align 8
  %cmp.i.i = icmp eq i32 %11, 4
  br i1 %cmp.i.i, label %land.lhs.true.i.i, label %if.else.i.i

land.lhs.true.i.i:                                ; preds = %do.body.i.i
  %i_key.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1
  %12 = load ptr, ptr %i_key.i.i, align 8
  %cmp5.i.i = icmp eq ptr %12, %5
  br i1 %cmp5.i.i, label %luaT_gettmbyobj.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %land.lhs.true.i.i, %do.body.i.i
  %next.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1, i32 0, i32 2
  %13 = load ptr, ptr %next.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %13, null
  br i1 %tobool.not.i.i, label %luaT_gettmbyobj.exit, label %do.body.i.i, !llvm.loop !29

luaT_gettmbyobj.exit:                             ; preds = %land.lhs.true.i.i, %if.else.i.i, %sw.epilog.i
  %cond.i = phi ptr [ @luaO_nilobject_, %sw.epilog.i ], [ @luaO_nilobject_, %if.else.i.i ], [ %n.0.i.i, %land.lhs.true.i.i ]
  %tt = getelementptr inbounds %struct.lua_TValue, ptr %cond.i, i64 0, i32 1
  %14 = load i32, ptr %tt, align 8
  %cmp = icmp eq i32 %14, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %luaT_gettmbyobj.exit
  %tt.i8 = getelementptr inbounds %struct.lua_TValue, ptr %p2, i64 0, i32 1
  %15 = load i32, ptr %tt.i8, align 8
  switch i32 %15, label %sw.default.i40 [
    i32 5, label %sw.bb.i38
    i32 7, label %sw.bb1.i9
  ]

sw.bb.i38:                                        ; preds = %if.then
  %16 = load ptr, ptr %p2, align 8
  %metatable.i39 = getelementptr inbounds %struct.Table, ptr %16, i64 0, i32 5
  br label %sw.epilog.i11

sw.bb1.i9:                                        ; preds = %if.then
  %17 = load ptr, ptr %p2, align 8
  %metatable3.i10 = getelementptr inbounds %struct.anon.1, ptr %17, i64 0, i32 3
  br label %sw.epilog.i11

sw.default.i40:                                   ; preds = %if.then
  %l_G.i41 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %18 = load ptr, ptr %l_G.i41, align 8
  %idxprom.i42 = sext i32 %15 to i64
  %arrayidx.i43 = getelementptr inbounds %struct.global_State, ptr %18, i64 0, i32 23, i64 %idxprom.i42
  br label %sw.epilog.i11

sw.epilog.i11:                                    ; preds = %sw.default.i40, %sw.bb1.i9, %sw.bb.i38
  %mt.0.in.i12 = phi ptr [ %arrayidx.i43, %sw.default.i40 ], [ %metatable3.i10, %sw.bb1.i9 ], [ %metatable.i39, %sw.bb.i38 ]
  %mt.0.i13 = load ptr, ptr %mt.0.in.i12, align 8
  %tobool.not.i14 = icmp eq ptr %mt.0.i13, null
  br i1 %tobool.not.i14, label %if.end, label %cond.true.i15

cond.true.i15:                                    ; preds = %sw.epilog.i11
  %l_G6.i16 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %19 = load ptr, ptr %l_G6.i16, align 8
  %idxprom7.i17 = zext nneg i32 %event to i64
  %arrayidx8.i18 = getelementptr inbounds %struct.global_State, ptr %19, i64 0, i32 24, i64 %idxprom7.i17
  %20 = load ptr, ptr %arrayidx8.i18, align 8
  %21 = getelementptr i8, ptr %mt.0.i13, i64 11
  %mt.0.val.i19 = load i8, ptr %21, align 1
  %22 = getelementptr i8, ptr %mt.0.i13, i64 32
  %mt.0.val6.i20 = load ptr, ptr %22, align 8
  %hash.i.i21 = getelementptr inbounds %struct.anon.0, ptr %20, i64 0, i32 4
  %23 = load i32, ptr %hash.i.i21, align 4
  %sh_prom.i.i22 = zext nneg i8 %mt.0.val.i19 to i64
  %notmask.i.i23 = shl nsw i64 -1, %sh_prom.i.i22
  %24 = trunc i64 %notmask.i.i23 to i32
  %25 = xor i32 %24, -1
  %conv2.i.i24 = and i32 %23, %25
  %idxprom.i.i25 = sext i32 %conv2.i.i24 to i64
  %arrayidx.i.i26 = getelementptr inbounds %struct.Node, ptr %mt.0.val6.i20, i64 %idxprom.i.i25
  br label %do.body.i.i27

do.body.i.i27:                                    ; preds = %if.else.i.i31, %cond.true.i15
  %n.0.i.i28 = phi ptr [ %arrayidx.i.i26, %cond.true.i15 ], [ %28, %if.else.i.i31 ]
  %tt.i.i29 = getelementptr inbounds %struct.Node, ptr %n.0.i.i28, i64 0, i32 1, i32 0, i32 1
  %26 = load i32, ptr %tt.i.i29, align 8
  %cmp.i.i30 = icmp eq i32 %26, 4
  br i1 %cmp.i.i30, label %land.lhs.true.i.i35, label %if.else.i.i31

land.lhs.true.i.i35:                              ; preds = %do.body.i.i27
  %i_key.i.i36 = getelementptr inbounds %struct.Node, ptr %n.0.i.i28, i64 0, i32 1
  %27 = load ptr, ptr %i_key.i.i36, align 8
  %cmp5.i.i37 = icmp eq ptr %27, %20
  br i1 %cmp5.i.i37, label %if.end, label %if.else.i.i31

if.else.i.i31:                                    ; preds = %land.lhs.true.i.i35, %do.body.i.i27
  %next.i.i32 = getelementptr inbounds %struct.Node, ptr %n.0.i.i28, i64 0, i32 1, i32 0, i32 2
  %28 = load ptr, ptr %next.i.i32, align 8
  %tobool.not.i.i33 = icmp eq ptr %28, null
  br i1 %tobool.not.i.i33, label %if.end, label %do.body.i.i27, !llvm.loop !29

if.end:                                           ; preds = %if.else.i.i31, %land.lhs.true.i.i35, %sw.epilog.i11, %luaT_gettmbyobj.exit
  %tm.0 = phi ptr [ %cond.i, %luaT_gettmbyobj.exit ], [ @luaO_nilobject_, %sw.epilog.i11 ], [ @luaO_nilobject_, %if.else.i.i31 ], [ %n.0.i.i28, %land.lhs.true.i.i35 ]
  %tt2 = getelementptr inbounds %struct.lua_TValue, ptr %tm.0, i64 0, i32 1
  %29 = load i32, ptr %tt2, align 8
  %cmp3 = icmp eq i32 %29, 0
  br i1 %cmp3, label %return, label %if.end5

if.end5:                                          ; preds = %if.end
  %stack.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 10
  %30 = load ptr, ptr %stack.i, align 8
  %top.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %31 = load ptr, ptr %top.i, align 8
  %32 = load i64, ptr %tm.0, align 8
  store i64 %32, ptr %31, align 8
  %33 = load i32, ptr %tt2, align 8
  %tt2.i = getelementptr inbounds %struct.lua_TValue, ptr %31, i64 0, i32 1
  store i32 %33, ptr %tt2.i, align 8
  %34 = load ptr, ptr %top.i, align 8
  %add.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %34, i64 1
  %35 = load i64, ptr %p1, align 8
  store i64 %35, ptr %add.ptr.i, align 8
  %36 = load i32, ptr %tt.i, align 8
  %tt9.i = getelementptr inbounds %struct.lua_TValue, ptr %34, i64 1, i32 1
  store i32 %36, ptr %tt9.i, align 8
  %37 = load ptr, ptr %top.i, align 8
  %add.ptr13.i = getelementptr inbounds %struct.lua_TValue, ptr %37, i64 2
  %38 = load i64, ptr %p2, align 8
  store i64 %38, ptr %add.ptr13.i, align 8
  %tt16.i = getelementptr inbounds %struct.lua_TValue, ptr %p2, i64 0, i32 1
  %39 = load i32, ptr %tt16.i, align 8
  %tt17.i = getelementptr inbounds %struct.lua_TValue, ptr %37, i64 2, i32 1
  store i32 %39, ptr %tt17.i, align 8
  %stack_last.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 9
  %40 = load ptr, ptr %stack_last.i, align 8
  %41 = load ptr, ptr %top.i, align 8
  %sub.ptr.lhs.cast19.i = ptrtoint ptr %40 to i64
  %sub.ptr.rhs.cast20.i = ptrtoint ptr %41 to i64
  %sub.ptr.sub21.i = sub i64 %sub.ptr.lhs.cast19.i, %sub.ptr.rhs.cast20.i
  %cmp.i = icmp slt i64 %sub.ptr.sub21.i, 49
  br i1 %cmp.i, label %if.then.i, label %callTMres.exit

if.then.i:                                        ; preds = %if.end5
  %stacksize.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 13
  %42 = load i32, ptr %stacksize.i.i, align 8
  %cmp.not.i.i = icmp slt i32 %42, 3
  %add.i.i = add nsw i32 %42, 3
  %mul.i.i = shl nuw nsw i32 %42, 1
  %add.i.sink.i = select i1 %cmp.not.i.i, i32 %add.i.i, i32 %mul.i.i
  tail call fastcc void @luaD_reallocstack(ptr noundef nonnull %L, i32 noundef %add.i.sink.i)
  %.pre = load ptr, ptr %top.i, align 8
  br label %callTMres.exit

callTMres.exit:                                   ; preds = %if.end5, %if.then.i
  %43 = phi ptr [ %41, %if.end5 ], [ %.pre, %if.then.i ]
  %sub.ptr.lhs.cast.i = ptrtoint ptr %res to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %30 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %add.ptr23.i = getelementptr inbounds %struct.lua_TValue, ptr %43, i64 3
  store ptr %add.ptr23.i, ptr %top.i, align 8
  tail call fastcc void @luaD_call(ptr noundef nonnull %L, ptr noundef %43, i32 noundef 1)
  %44 = load ptr, ptr %stack.i, align 8
  %add.ptr27.i = getelementptr inbounds i8, ptr %44, i64 %sub.ptr.sub.i
  %45 = load ptr, ptr %top.i, align 8
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %45, i64 -1
  store ptr %incdec.ptr.i, ptr %top.i, align 8
  %46 = load i64, ptr %incdec.ptr.i, align 8
  store i64 %46, ptr %add.ptr27.i, align 8
  %tt34.i = getelementptr %struct.lua_TValue, ptr %45, i64 -1, i32 1
  %47 = load i32, ptr %tt34.i, align 8
  %tt35.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr27.i, i64 0, i32 1
  store i32 %47, ptr %tt35.i, align 8
  br label %return

return:                                           ; preds = %if.end, %callTMres.exit
  %retval.0 = phi i32 [ 1, %callTMres.exit ], [ 0, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaD_call(ptr noundef %L, ptr noundef %func, i32 noundef %nResults) unnamed_addr #0 {
entry:
  %k.i = alloca %struct.lua_TValue, align 8
  %endptr.i.i195 = alloca ptr, align 8
  %endptr.i.i162 = alloca ptr, align 8
  %endptr.i.i = alloca ptr, align 8
  %g.i = alloca %struct.lua_TValue, align 8
  %g79.i = alloca %struct.lua_TValue, align 8
  %nCcalls = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 15
  %0 = load i16, ptr %nCcalls, align 8
  %inc = add i16 %0, 1
  store i16 %inc, ptr %nCcalls, align 8
  %cmp = icmp ugt i16 %inc, 199
  br i1 %cmp, label %if.then, label %if.end13

if.then:                                          ; preds = %entry
  %cmp4 = icmp eq i16 %inc, 200
  br i1 %cmp4, label %if.then6, label %if.else

if.then6:                                         ; preds = %if.then
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef nonnull %L, ptr noundef nonnull @.str.17)
  unreachable

if.else:                                          ; preds = %if.then
  %cmp9 = icmp ugt i16 %inc, 224
  br i1 %cmp9, label %if.then11, label %if.end13

if.then11:                                        ; preds = %if.else
  %errorJmp.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 26
  %1 = load ptr, ptr %errorJmp.i, align 8
  %tobool.not.i = icmp eq ptr %1, null
  br i1 %tobool.not.i, label %if.else.i, label %if.then.i

if.then.i:                                        ; preds = %if.then11
  %status.i = getelementptr inbounds %struct.lua_longjmp, ptr %1, i64 0, i32 2
  store volatile i32 5, ptr %status.i, align 8
  %2 = load ptr, ptr %errorJmp.i, align 8
  %b.i = getelementptr inbounds %struct.lua_longjmp, ptr %2, i64 0, i32 1
  tail call void @longjmp(ptr noundef nonnull %b.i, i32 noundef 1) #38
  unreachable

if.else.i:                                        ; preds = %if.then11
  %status3.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 3
  store i8 5, ptr %status3.i, align 2
  %l_G.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %3 = load ptr, ptr %l_G.i, align 8
  %panic.i = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 19
  %4 = load ptr, ptr %panic.i, align 8
  %tobool4.not.i = icmp eq ptr %4, null
  br i1 %tobool4.not.i, label %if.end.i, label %if.then5.i

if.then5.i:                                       ; preds = %if.else.i
  tail call fastcc void @resetstack(ptr noundef nonnull %L, i32 noundef 5)
  %5 = load ptr, ptr %l_G.i, align 8
  %panic7.i = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 19
  %6 = load ptr, ptr %panic7.i, align 8
  %call.i = tail call i32 %6(ptr noundef nonnull %L) #35
  br label %if.end.i

if.end.i:                                         ; preds = %if.then5.i, %if.else.i
  tail call void @exit(i32 noundef 1) #38
  unreachable

if.end13:                                         ; preds = %if.else, %entry
  %call = tail call fastcc i32 @luaD_precall(ptr noundef nonnull %L, ptr noundef %func, i32 noundef %nResults), !range !30
  %cmp14 = icmp eq i32 %call, 0
  br i1 %cmp14, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.end13
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %g.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %g79.i)
  %savedpc.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 8
  %ci.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %base1.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %stack_last.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 9
  %top1267.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %stacksize.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 13
  %l_G.i467 = getelementptr %struct.lua_State, ptr %L, i64 0, i32 6
  %openupval.i259 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 24
  %tt.i242 = getelementptr inbounds %struct.lua_TValue, ptr %k.i, i64 0, i32 1
  %tt83.i = getelementptr inbounds %struct.lua_TValue, ptr %g79.i, i64 0, i32 1
  %tt55.i = getelementptr inbounds %struct.lua_TValue, ptr %g.i, i64 0, i32 1
  %stack.i763 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 10
  br label %reentry.i.outer

reentry.i.outer:                                  ; preds = %reentry.i.outer.backedge, %if.then16
  %nexeccalls.addr.0.i.ph = phi i32 [ 1, %if.then16 ], [ %nexeccalls.addr.0.i.ph.be, %reentry.i.outer.backedge ]
  %.pre = load ptr, ptr %ci.i, align 8
  br label %reentry.i

reentry.i:                                        ; preds = %reentry.i.outer, %for.end.i
  %7 = phi ptr [ %.pre, %reentry.i.outer ], [ %incdec.ptr953.i, %for.end.i ]
  %8 = load ptr, ptr %savedpc.i, align 8
  %func.i = getelementptr inbounds %struct.CallInfo, ptr %7, i64 0, i32 1
  %9 = load ptr, ptr %func.i, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %base1.i, align 8
  %p.i = getelementptr inbounds %struct.LClosure, ptr %10, i64 0, i32 7
  %12 = load ptr, ptr %p.i, align 8
  %k2.i = getelementptr inbounds %struct.Proto, ptr %12, i64 0, i32 3
  %13 = load ptr, ptr %k2.i, align 8
  %env1196.i = getelementptr inbounds %struct.LClosure, ptr %10, i64 0, i32 6
  br label %for.cond.i

for.cond.i:                                       ; preds = %for.cond.i.backedge, %reentry.i
  %pc.0.i = phi ptr [ %8, %reentry.i ], [ %pc.0.i.be, %for.cond.i.backedge ]
  %base.0.i = phi ptr [ %11, %reentry.i ], [ %base.0.i.be, %for.cond.i.backedge ]
  %incdec.ptr.i = getelementptr inbounds i32, ptr %pc.0.i, i64 1
  %14 = load i32, ptr %pc.0.i, align 4
  %shr.i = lshr i32 %14, 6
  %and.i = and i32 %shr.i, 255
  %idx.ext.i = zext nneg i32 %and.i to i64
  %add.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext.i
  %and4.i = and i32 %14, 63
  switch i32 %and4.i, label %for.cond.i.backedge [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb12.i
    i32 2, label %sw.bb23.i
    i32 3, label %sw.bb31.i
    i32 4, label %sw.bb38.i
    i32 5, label %sw.bb47.i
    i32 6, label %sw.bb58.i
    i32 7, label %sw.bb78.i
    i32 8, label %sw.bb90.i
    i32 9, label %sw.bb116.i
    i32 10, label %sw.bb153.i
    i32 11, label %sw.bb171.i
    i32 12, label %sw.bb203.i
    i32 13, label %sw.bb255.i
    i32 14, label %sw.bb311.i
    i32 15, label %sw.bb367.i
    i32 16, label %sw.bb423.i
    i32 17, label %sw.bb481.i
    i32 18, label %sw.bb538.i
    i32 19, label %sw.bb557.i
    i32 20, label %sw.bb582.i
    i32 21, label %sw.bb608.i
    i32 22, label %sw.bb639.i
    i32 23, label %sw.bb645.i
    i32 24, label %sw.bb704.i
    i32 25, label %sw.bb754.i
    i32 26, label %sw.bb804.i
    i32 27, label %sw.bb832.i
    i32 28, label %sw.bb871.i
    i32 29, label %sw.bb897.i
    i32 30, label %sw.bb957.i
    i32 31, label %sw.bb985.i
    i32 32, label %sw.bb1014.i
    i32 33, label %sw.bb1059.i
    i32 34, label %sw.bb1115.i
    i32 35, label %sw.bb1186.i
    i32 36, label %sw.bb1187.i
    i32 37, label %sw.bb1243.i
  ]

for.cond.i.backedge:                              ; preds = %for.inc1312.i, %for.inc1183.i, %do.body.i, %for.cond.i, %if.end1139.i, %cond.true994.i, %cond.false997.i, %if.then1000.i, %sw.bb589.i, %sw.bb596.i, %if.end606.i, %if.then547.i, %if.else553.i, %if.then525.i, %if.else534.i, %if.then467.i, %if.else477.i, %if.then411.i, %if.else419.i, %if.then355.i, %if.else363.i, %if.then299.i, %if.else307.i, %if.then246.i, %if.else.i11, %sw.bb90.i, %land.lhs.true.i, %land.lhs.true108.i, %if.then.i30, %if.else.i27, %if.end1286.i, %if.end1152.i, %sw.bb.i, %sw.bb12.i, %sw.bb23.i, %sw.bb38.i, %sw.bb47.i, %sw.bb58.i, %sw.bb78.i, %sw.bb116.i, %if.end169.i, %sw.bb171.i, %lor.end.i, %if.end625.i, %sw.bb639.i, %if.end701.i, %if.end751.i, %if.end801.i, %if.end830.i, %if.end869.i, %if.end894.i, %sw.bb954.i, %if.end1047.i, %if.end1113.i, %sw.bb1186.i, %if.end1241.i
  %pc.0.i.be = phi ptr [ %pc.10.i.lcssa, %if.end1241.i ], [ %incdec.ptr.i, %sw.bb1186.i ], [ %incdec.ptr1114.i, %if.end1113.i ], [ %add.ptr1058.i, %if.end1047.i ], [ %incdec.ptr.i, %sw.bb954.i ], [ %incdec.ptr.i, %if.end894.i ], [ %incdec.ptr870.i, %if.end869.i ], [ %incdec.ptr831.i, %if.end830.i ], [ %incdec.ptr803.i, %if.end801.i ], [ %incdec.ptr753.i, %if.end751.i ], [ %incdec.ptr703.i, %if.end701.i ], [ %add.ptr644.i, %sw.bb639.i ], [ %incdec.ptr.i, %if.end625.i ], [ %incdec.ptr.i, %lor.end.i ], [ %incdec.ptr.i, %sw.bb171.i ], [ %incdec.ptr.i, %if.end169.i ], [ %incdec.ptr.i, %sw.bb116.i ], [ %incdec.ptr.i, %sw.bb78.i ], [ %incdec.ptr.i, %sw.bb58.i ], [ %incdec.ptr.i, %sw.bb47.i ], [ %incdec.ptr.i, %sw.bb38.i ], [ %spec.select.i, %sw.bb23.i ], [ %incdec.ptr.i, %sw.bb12.i ], [ %incdec.ptr.i, %sw.bb.i ], [ %pc.9.i, %if.end1152.i ], [ %incdec.ptr.i, %if.end1286.i ], [ %incdec.ptr.i, %if.else.i27 ], [ %incdec.ptr.i, %if.then.i30 ], [ %incdec.ptr.i, %land.lhs.true108.i ], [ %incdec.ptr.i, %land.lhs.true.i ], [ %incdec.ptr.i, %sw.bb90.i ], [ %incdec.ptr.i, %if.else.i11 ], [ %incdec.ptr.i, %if.then246.i ], [ %incdec.ptr.i, %if.else307.i ], [ %incdec.ptr.i, %if.then299.i ], [ %incdec.ptr.i, %if.else363.i ], [ %incdec.ptr.i, %if.then355.i ], [ %incdec.ptr.i, %if.else419.i ], [ %incdec.ptr.i, %if.then411.i ], [ %incdec.ptr.i, %if.else477.i ], [ %incdec.ptr.i, %if.then467.i ], [ %incdec.ptr.i, %if.else534.i ], [ %incdec.ptr.i, %if.then525.i ], [ %incdec.ptr.i, %if.else553.i ], [ %incdec.ptr.i, %if.then547.i ], [ %incdec.ptr.i, %if.end606.i ], [ %incdec.ptr.i, %sw.bb596.i ], [ %incdec.ptr.i, %sw.bb589.i ], [ %add.ptr1005.i, %if.then1000.i ], [ %incdec.ptr.i, %cond.true994.i ], [ %incdec.ptr.i, %cond.false997.i ], [ %incdec.ptr.i, %for.cond.i ], [ %pc.9.i, %if.end1139.i ], [ %incdec.ptr.i, %do.body.i ], [ %pc.9.i, %for.inc1183.i ], [ %incdec.ptr.i, %for.inc1312.i ]
  %base.0.i.be = phi ptr [ %520, %if.end1241.i ], [ %base.0.i, %sw.bb1186.i ], [ %424, %if.end1113.i ], [ %base.0.i, %if.end1047.i ], [ %370, %sw.bb954.i ], [ %355, %if.end894.i ], [ %base.0.i, %if.end869.i ], [ %base.0.i, %if.end830.i ], [ %339, %if.end801.i ], [ %205, %if.end751.i ], [ %200, %if.end701.i ], [ %base.0.i, %sw.bb639.i ], [ %123, %if.end625.i ], [ %base.0.i, %lor.end.i ], [ %60, %sw.bb171.i ], [ %56, %if.end169.i ], [ %44, %sw.bb116.i ], [ %29, %sw.bb78.i ], [ %27, %sw.bb58.i ], [ %25, %sw.bb47.i ], [ %base.0.i, %sw.bb38.i ], [ %base.0.i, %sw.bb23.i ], [ %base.0.i, %sw.bb12.i ], [ %base.0.i, %sw.bb.i ], [ %base.0.i, %if.end1152.i ], [ %base.9.i, %if.end1286.i ], [ %base.0.i, %if.else.i27 ], [ %base.0.i, %if.then.i30 ], [ %base.0.i, %land.lhs.true108.i ], [ %base.0.i, %land.lhs.true.i ], [ %base.0.i, %sw.bb90.i ], [ %66, %if.else.i11 ], [ %base.0.i, %if.then246.i ], [ %72, %if.else307.i ], [ %base.0.i, %if.then299.i ], [ %78, %if.else363.i ], [ %base.0.i, %if.then355.i ], [ %84, %if.else419.i ], [ %base.0.i, %if.then411.i ], [ %92, %if.else477.i ], [ %base.0.i, %if.then467.i ], [ %98, %if.else534.i ], [ %base.0.i, %if.then525.i ], [ %101, %if.else553.i ], [ %base.0.i, %if.then547.i ], [ %111, %if.end606.i ], [ %base.0.i, %sw.bb596.i ], [ %base.0.i, %sw.bb589.i ], [ %base.0.i, %if.then1000.i ], [ %base.0.i, %cond.true994.i ], [ %base.0.i, %cond.false997.i ], [ %base.0.i, %for.cond.i ], [ %base.0.i, %if.end1139.i ], [ %base.0.i, %do.body.i ], [ %base.0.i, %for.inc1183.i ], [ %base.9.i, %for.inc1312.i ]
  br label %for.cond.i

sw.bb.i:                                          ; preds = %for.cond.i
  %shr5.i = lshr i32 %14, 23
  %idx.ext7.i = zext nneg i32 %shr5.i to i64
  %add.ptr8.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext7.i
  %15 = load i64, ptr %add.ptr8.i, align 8
  store i64 %15, ptr %add.ptr.i, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext7.i, i32 1
  %16 = load i32, ptr %tt.i, align 8
  %tt11.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext.i, i32 1
  store i32 %16, ptr %tt11.i, align 8
  br label %for.cond.i.backedge

sw.bb12.i:                                        ; preds = %for.cond.i
  %shr14.i = lshr i32 %14, 14
  %idx.ext16.i = zext nneg i32 %shr14.i to i64
  %add.ptr17.i = getelementptr inbounds %struct.lua_TValue, ptr %13, i64 %idx.ext16.i
  %17 = load i64, ptr %add.ptr17.i, align 8
  store i64 %17, ptr %add.ptr.i, align 8
  %tt21.i = getelementptr inbounds %struct.lua_TValue, ptr %13, i64 %idx.ext16.i, i32 1
  %18 = load i32, ptr %tt21.i, align 8
  %tt22.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext.i, i32 1
  store i32 %18, ptr %tt22.i, align 8
  br label %for.cond.i.backedge

sw.bb23.i:                                        ; preds = %for.cond.i
  %shr24.i = lshr i32 %14, 23
  store i32 %shr24.i, ptr %add.ptr.i, align 8
  %tt27.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext.i, i32 1
  store i32 1, ptr %tt27.i, align 8
  %19 = and i32 %14, 8372224
  %tobool.not.i14 = icmp eq i32 %19, 0
  %incdec.ptr30.i = getelementptr inbounds i32, ptr %pc.0.i, i64 2
  %spec.select.i = select i1 %tobool.not.i14, ptr %incdec.ptr.i, ptr %incdec.ptr30.i
  br label %for.cond.i.backedge

sw.bb31.i:                                        ; preds = %for.cond.i
  %shr32.i = lshr i32 %14, 23
  %idx.ext34.i = zext nneg i32 %shr32.i to i64
  %add.ptr35.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext34.i
  br label %do.body.i

do.body.i:                                        ; preds = %do.body.i, %sw.bb31.i
  %rb.0.i = phi ptr [ %add.ptr35.i, %sw.bb31.i ], [ %incdec.ptr36.i, %do.body.i ]
  %incdec.ptr36.i = getelementptr inbounds %struct.lua_TValue, ptr %rb.0.i, i64 -1
  %tt37.i = getelementptr inbounds %struct.lua_TValue, ptr %rb.0.i, i64 0, i32 1
  store i32 0, ptr %tt37.i, align 8
  %cmp.not.i = icmp ult ptr %incdec.ptr36.i, %add.ptr.i
  br i1 %cmp.not.i, label %for.cond.i.backedge, label %do.body.i, !llvm.loop !31

sw.bb38.i:                                        ; preds = %for.cond.i
  %shr39.i = lshr i32 %14, 23
  %idxprom.i = zext nneg i32 %shr39.i to i64
  %arrayidx.i = getelementptr inbounds %struct.LClosure, ptr %10, i64 0, i32 8, i64 %idxprom.i
  %20 = load ptr, ptr %arrayidx.i, align 8
  %v.i = getelementptr inbounds %struct.UpVal, ptr %20, i64 0, i32 3
  %21 = load ptr, ptr %v.i, align 8
  %22 = load i64, ptr %21, align 8
  store i64 %22, ptr %add.ptr.i, align 8
  %tt45.i = getelementptr inbounds %struct.lua_TValue, ptr %21, i64 0, i32 1
  %23 = load i32, ptr %tt45.i, align 8
  %tt46.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext.i, i32 1
  store i32 %23, ptr %tt46.i, align 8
  br label %for.cond.i.backedge

sw.bb47.i:                                        ; preds = %for.cond.i
  %shr49.i = lshr i32 %14, 14
  %idx.ext51.i = zext nneg i32 %shr49.i to i64
  %add.ptr52.i = getelementptr inbounds %struct.lua_TValue, ptr %13, i64 %idx.ext51.i
  %24 = load ptr, ptr %env1196.i, align 8
  store ptr %24, ptr %g.i, align 8
  store i32 5, ptr %tt55.i, align 8
  store ptr %incdec.ptr.i, ptr %savedpc.i, align 8
  call fastcc void @luaV_gettable(ptr noundef %L, ptr noundef nonnull %g.i, ptr noundef %add.ptr52.i, ptr noundef %add.ptr.i)
  %25 = load ptr, ptr %base1.i, align 8
  br label %for.cond.i.backedge

sw.bb58.i:                                        ; preds = %for.cond.i
  store ptr %incdec.ptr.i, ptr %savedpc.i, align 8
  %shr60.i = lshr i32 %14, 23
  %idx.ext62.i = zext nneg i32 %shr60.i to i64
  %add.ptr63.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext62.i
  %shr64.i = lshr i32 %14, 14
  %26 = and i32 %14, 4194304
  %tobool67.not.i = icmp eq i32 %26, 0
  %and70.i = and i32 %shr64.i, 255
  %idx.ext71.i = zext nneg i32 %and70.i to i64
  %cond.i.v = select i1 %tobool67.not.i, ptr %base.0.i, ptr %13
  %cond.i = getelementptr inbounds %struct.lua_TValue, ptr %cond.i.v, i64 %idx.ext71.i
  tail call fastcc void @luaV_gettable(ptr noundef %L, ptr noundef %add.ptr63.i, ptr noundef %cond.i, ptr noundef %add.ptr.i)
  %27 = load ptr, ptr %base1.i, align 8
  br label %for.cond.i.backedge

sw.bb78.i:                                        ; preds = %for.cond.i
  %28 = load ptr, ptr %env1196.i, align 8
  store ptr %28, ptr %g79.i, align 8
  store i32 5, ptr %tt83.i, align 8
  store ptr %incdec.ptr.i, ptr %savedpc.i, align 8
  %shr85.i = lshr i32 %14, 14
  %idx.ext87.i = zext nneg i32 %shr85.i to i64
  %add.ptr88.i = getelementptr inbounds %struct.lua_TValue, ptr %13, i64 %idx.ext87.i
  call fastcc void @luaV_settable(ptr noundef %L, ptr noundef nonnull %g79.i, ptr noundef %add.ptr88.i, ptr noundef %add.ptr.i)
  %29 = load ptr, ptr %base1.i, align 8
  br label %for.cond.i.backedge

sw.bb90.i:                                        ; preds = %for.cond.i
  %shr92.i = lshr i32 %14, 23
  %idxprom94.i = zext nneg i32 %shr92.i to i64
  %arrayidx95.i = getelementptr inbounds %struct.LClosure, ptr %10, i64 0, i32 8, i64 %idxprom94.i
  %30 = load ptr, ptr %arrayidx95.i, align 8
  %v98.i = getelementptr inbounds %struct.UpVal, ptr %30, i64 0, i32 3
  %31 = load ptr, ptr %v98.i, align 8
  %32 = load i64, ptr %add.ptr.i, align 8
  store i64 %32, ptr %31, align 8
  %tt101.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext.i, i32 1
  %33 = load i32, ptr %tt101.i, align 8
  %tt102.i = getelementptr inbounds %struct.lua_TValue, ptr %31, i64 0, i32 1
  store i32 %33, ptr %tt102.i, align 8
  %cmp104.i = icmp sgt i32 %33, 3
  br i1 %cmp104.i, label %land.lhs.true.i, label %for.cond.i.backedge

land.lhs.true.i:                                  ; preds = %sw.bb90.i
  %34 = load ptr, ptr %add.ptr.i, align 8
  %marked.i = getelementptr inbounds %struct.GCheader, ptr %34, i64 0, i32 2
  %35 = load i8, ptr %marked.i, align 1
  %36 = and i8 %35, 3
  %tobool107.not.i = icmp eq i8 %36, 0
  br i1 %tobool107.not.i, label %for.cond.i.backedge, label %land.lhs.true108.i

land.lhs.true108.i:                               ; preds = %land.lhs.true.i
  %marked109.i = getelementptr inbounds %struct.GCheader, ptr %30, i64 0, i32 2
  %37 = load i8, ptr %marked109.i, align 1
  %38 = and i8 %37, 4
  %tobool112.not.i = icmp eq i8 %38, 0
  br i1 %tobool112.not.i, label %for.cond.i.backedge, label %if.then113.i

if.then113.i:                                     ; preds = %land.lhs.true108.i
  %L.val583.i = load ptr, ptr %l_G.i467, align 8
  %gcstate.i25 = getelementptr inbounds %struct.global_State, ptr %L.val583.i, i64 0, i32 4
  %39 = load i8, ptr %gcstate.i25, align 1
  %cmp.i26 = icmp eq i8 %39, 1
  br i1 %cmp.i26, label %if.then.i30, label %if.else.i27

if.then.i30:                                      ; preds = %if.then113.i
  tail call fastcc void @reallymarkobject(ptr noundef nonnull %L.val583.i, ptr noundef nonnull %34)
  br label %for.cond.i.backedge

if.else.i27:                                      ; preds = %if.then113.i
  %40 = and i8 %37, -8
  %currentwhite.i = getelementptr inbounds %struct.global_State, ptr %L.val583.i, i64 0, i32 3
  %41 = load i8, ptr %currentwhite.i, align 8
  %42 = and i8 %41, 3
  %or4.i = or disjoint i8 %42, %40
  store i8 %or4.i, ptr %marked109.i, align 1
  br label %for.cond.i.backedge

sw.bb116.i:                                       ; preds = %for.cond.i
  store ptr %incdec.ptr.i, ptr %savedpc.i, align 8
  %shr118.i = lshr i32 %14, 23
  %and125.i = and i32 %shr118.i, 255
  %idx.ext126.i = zext nneg i32 %and125.i to i64
  %add.ptr127.i = getelementptr inbounds %struct.lua_TValue, ptr %13, i64 %idx.ext126.i
  %idx.ext131.i = zext nneg i32 %shr118.i to i64
  %add.ptr132.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext131.i
  %tobool121.not.i538 = icmp slt i32 %14, 0
  %cond134.i = select i1 %tobool121.not.i538, ptr %add.ptr127.i, ptr %add.ptr132.i
  %shr135.i = lshr i32 %14, 14
  %43 = and i32 %14, 4194304
  %tobool138.not.i = icmp eq i32 %43, 0
  %and142.i = and i32 %shr135.i, 255
  %idx.ext143.i = zext nneg i32 %and142.i to i64
  %cond151.i.v = select i1 %tobool138.not.i, ptr %base.0.i, ptr %13
  %cond151.i = getelementptr inbounds %struct.lua_TValue, ptr %cond151.i.v, i64 %idx.ext143.i
  tail call fastcc void @luaV_settable(ptr noundef %L, ptr noundef %add.ptr.i, ptr noundef %cond134.i, ptr noundef %cond151.i)
  %44 = load ptr, ptr %base1.i, align 8
  br label %for.cond.i.backedge

sw.bb153.i:                                       ; preds = %for.cond.i
  %shr155.i = lshr i32 %14, 23
  %shr157.i = lshr i32 %14, 14
  %and158.i = and i32 %shr157.i, 511
  %shr.i31 = lshr i32 %14, 26
  %and.i32 = and i32 %shr.i31, 31
  %cmp.i33 = icmp eq i32 %and.i32, 0
  %and1.i = and i32 %shr155.i, 7
  %add.i34 = or disjoint i32 %and1.i, 8
  %sub.i35 = add nsw i32 %and.i32, -1
  %shl.i = shl i32 %add.i34, %sub.i35
  %retval.0.i = select i1 %cmp.i33, i32 %shr155.i, i32 %shl.i
  %shr.i36 = lshr i32 %14, 17
  %and.i37 = and i32 %shr.i36, 31
  %cmp.i38 = icmp eq i32 %and.i37, 0
  %and1.i39 = and i32 %shr157.i, 7
  %add.i40 = or disjoint i32 %and1.i39, 8
  %sub.i41 = add nsw i32 %and.i37, -1
  %shl.i42 = shl i32 %add.i40, %sub.i41
  %retval.0.i43 = select i1 %cmp.i38, i32 %and158.i, i32 %shl.i42
  %call161.i = tail call fastcc ptr @luaH_new(ptr noundef %L, i32 noundef %retval.0.i, i32 noundef %retval.0.i43)
  store ptr %call161.i, ptr %add.ptr.i, align 8
  %tt163.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext.i, i32 1
  store i32 5, ptr %tt163.i, align 8
  store ptr %incdec.ptr.i, ptr %savedpc.i, align 8
  %45 = load ptr, ptr %l_G.i467, align 8
  %totalbytes.i = getelementptr inbounds %struct.global_State, ptr %45, i64 0, i32 14
  %46 = load i64, ptr %totalbytes.i, align 8
  %GCthreshold.i = getelementptr inbounds %struct.global_State, ptr %45, i64 0, i32 13
  %47 = load i64, ptr %GCthreshold.i, align 8
  %cmp166.not.i = icmp ult i64 %46, %47
  br i1 %cmp166.not.i, label %if.end169.i, label %if.then168.i

if.then168.i:                                     ; preds = %sw.bb153.i
  %gcstepmul.i45 = getelementptr inbounds %struct.global_State, ptr %45, i64 0, i32 18
  %48 = load i32, ptr %gcstepmul.i45, align 4
  %mul.i46 = mul i32 %48, 10
  %conv.i47 = zext i32 %mul.i46 to i64
  %cmp.i48 = icmp eq i32 %mul.i46, 0
  %spec.store.select.i49 = select i1 %cmp.i48, i64 9223372036854775806, i64 %conv.i47
  %sub.i52 = sub i64 %46, %47
  %gcdept.i53 = getelementptr inbounds %struct.global_State, ptr %45, i64 0, i32 16
  %49 = load i64, ptr %gcdept.i53, align 8
  %add.i54 = add i64 %sub.i52, %49
  store i64 %add.i54, ptr %gcdept.i53, align 8
  %gcstate.i59 = getelementptr inbounds %struct.global_State, ptr %45, i64 0, i32 4
  br label %do.body.i55

do.body.i55:                                      ; preds = %do.body.i55, %if.then168.i
  %lim.0.i56 = phi i64 [ %spec.store.select.i49, %if.then168.i ], [ %sub2.i58, %do.body.i55 ]
  %call.i57 = tail call fastcc i64 @singlestep(ptr noundef %L)
  %sub2.i58 = sub nsw i64 %lim.0.i56, %call.i57
  %50 = load i8, ptr %gcstate.i59, align 1
  %cmp4.i60 = icmp ne i8 %50, 0
  %cmp8.i61 = icmp sgt i64 %sub2.i58, 0
  %or.cond.i62 = select i1 %cmp4.i60, i1 %cmp8.i61, i1 false
  br i1 %or.cond.i62, label %do.body.i55, label %do.end.i63, !llvm.loop !6

do.end.i63:                                       ; preds = %do.body.i55
  br i1 %cmp4.i60, label %if.then14.i70, label %if.else27.i64

if.then14.i70:                                    ; preds = %do.end.i63
  %51 = load i64, ptr %gcdept.i53, align 8
  %cmp16.i71 = icmp ult i64 %51, 1024
  br i1 %cmp16.i71, label %if.then18.i74, label %if.else.i72

if.then18.i74:                                    ; preds = %if.then14.i70
  %52 = load i64, ptr %totalbytes.i, align 8
  %add20.i75 = add i64 %52, 1024
  br label %if.end169.i.sink.split

if.else.i72:                                      ; preds = %if.then14.i70
  %sub23.i73 = add i64 %51, -1024
  store i64 %sub23.i73, ptr %gcdept.i53, align 8
  %53 = load i64, ptr %totalbytes.i, align 8
  br label %if.end169.i.sink.split

if.else27.i64:                                    ; preds = %do.end.i63
  %estimate.i65 = getelementptr inbounds %struct.global_State, ptr %45, i64 0, i32 15
  %54 = load i64, ptr %estimate.i65, align 8
  %div.i66 = udiv i64 %54, 100
  %gcpause.i67 = getelementptr inbounds %struct.global_State, ptr %45, i64 0, i32 17
  %55 = load i32, ptr %gcpause.i67, align 8
  %conv28.i68 = sext i32 %55 to i64
  %mul29.i69 = mul i64 %div.i66, %conv28.i68
  br label %if.end169.i.sink.split

if.end169.i.sink.split:                           ; preds = %if.then18.i74, %if.else.i72, %if.else27.i64
  %mul29.i69.sink = phi i64 [ %mul29.i69, %if.else27.i64 ], [ %53, %if.else.i72 ], [ %add20.i75, %if.then18.i74 ]
  store i64 %mul29.i69.sink, ptr %GCthreshold.i, align 8
  br label %if.end169.i

if.end169.i:                                      ; preds = %if.end169.i.sink.split, %sw.bb153.i
  %56 = load ptr, ptr %base1.i, align 8
  br label %for.cond.i.backedge

sw.bb171.i:                                       ; preds = %for.cond.i
  %shr173.i = lshr i32 %14, 23
  %idx.ext175.i = zext nneg i32 %shr173.i to i64
  %add.ptr176.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext175.i
  %add.ptr179.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.i, i64 1
  %57 = load i64, ptr %add.ptr176.i, align 8
  store i64 %57, ptr %add.ptr179.i, align 8
  %tt182.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext175.i, i32 1
  %58 = load i32, ptr %tt182.i, align 8
  %tt183.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.i, i64 1, i32 1
  store i32 %58, ptr %tt183.i, align 8
  store ptr %incdec.ptr.i, ptr %savedpc.i, align 8
  %shr185.i = lshr i32 %14, 14
  %59 = and i32 %14, 4194304
  %tobool188.not.i = icmp eq i32 %59, 0
  %and192.i = and i32 %shr185.i, 255
  %idx.ext193.i = zext nneg i32 %and192.i to i64
  %cond201.i.v = select i1 %tobool188.not.i, ptr %base.0.i, ptr %13
  %cond201.i = getelementptr inbounds %struct.lua_TValue, ptr %cond201.i.v, i64 %idx.ext193.i
  tail call fastcc void @luaV_gettable(ptr noundef %L, ptr noundef nonnull %add.ptr176.i, ptr noundef %cond201.i, ptr noundef %add.ptr.i)
  %60 = load ptr, ptr %base1.i, align 8
  br label %for.cond.i.backedge

sw.bb203.i:                                       ; preds = %for.cond.i
  %shr205.i = lshr i32 %14, 23
  %and212.i = and i32 %shr205.i, 255
  %idx.ext213.i = zext nneg i32 %and212.i to i64
  %add.ptr214.i = getelementptr inbounds %struct.lua_TValue, ptr %13, i64 %idx.ext213.i
  %idx.ext218.i = zext nneg i32 %shr205.i to i64
  %add.ptr219.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext218.i
  %tobool208.not.i537 = icmp slt i32 %14, 0
  %cond221.i = select i1 %tobool208.not.i537, ptr %add.ptr214.i, ptr %add.ptr219.i
  %shr222.i = lshr i32 %14, 14
  %61 = and i32 %14, 4194304
  %tobool225.not.i = icmp eq i32 %61, 0
  %and229.i = and i32 %shr222.i, 255
  %idx.ext230.i = zext nneg i32 %and229.i to i64
  %cond238.i.v = select i1 %tobool225.not.i, ptr %base.0.i, ptr %13
  %cond238.i = getelementptr inbounds %struct.lua_TValue, ptr %cond238.i.v, i64 %idx.ext230.i
  %tt239.i = getelementptr inbounds %struct.lua_TValue, ptr %cond221.i, i64 0, i32 1
  %62 = load i32, ptr %tt239.i, align 8
  %cmp240.i = icmp eq i32 %62, 3
  br i1 %cmp240.i, label %land.lhs.true242.i, label %if.else.i11

land.lhs.true242.i:                               ; preds = %sw.bb203.i
  %tt243.i = getelementptr inbounds %struct.lua_TValue, ptr %cond238.i.v, i64 %idx.ext230.i, i32 1
  %63 = load i32, ptr %tt243.i, align 8
  %cmp244.i = icmp eq i32 %63, 3
  br i1 %cmp244.i, label %if.then246.i, label %if.else.i11

if.then246.i:                                     ; preds = %land.lhs.true242.i
  %64 = load double, ptr %cond221.i, align 8
  %65 = load double, ptr %cond238.i, align 8
  %add.i = fadd double %64, %65
  store double %add.i, ptr %add.ptr.i, align 8
  %tt251.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext.i, i32 1
  store i32 3, ptr %tt251.i, align 8
  br label %for.cond.i.backedge

if.else.i11:                                      ; preds = %land.lhs.true242.i, %sw.bb203.i
  store ptr %incdec.ptr.i, ptr %savedpc.i, align 8
  tail call fastcc void @Arith(ptr noundef %L, ptr noundef %add.ptr.i, ptr noundef nonnull %cond221.i, ptr noundef %cond238.i, i32 noundef 5)
  %66 = load ptr, ptr %base1.i, align 8
  br label %for.cond.i.backedge

sw.bb255.i:                                       ; preds = %for.cond.i
  %shr257.i = lshr i32 %14, 23
  %and264.i = and i32 %shr257.i, 255
  %idx.ext265.i = zext nneg i32 %and264.i to i64
  %add.ptr266.i = getelementptr inbounds %struct.lua_TValue, ptr %13, i64 %idx.ext265.i
  %idx.ext270.i = zext nneg i32 %shr257.i to i64
  %add.ptr271.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext270.i
  %tobool260.not.i536 = icmp slt i32 %14, 0
  %cond273.i = select i1 %tobool260.not.i536, ptr %add.ptr266.i, ptr %add.ptr271.i
  %shr275.i = lshr i32 %14, 14
  %67 = and i32 %14, 4194304
  %tobool278.not.i = icmp eq i32 %67, 0
  %and282.i = and i32 %shr275.i, 255
  %idx.ext283.i = zext nneg i32 %and282.i to i64
  %cond291.i.v = select i1 %tobool278.not.i, ptr %base.0.i, ptr %13
  %cond291.i = getelementptr inbounds %struct.lua_TValue, ptr %cond291.i.v, i64 %idx.ext283.i
  %tt292.i = getelementptr inbounds %struct.lua_TValue, ptr %cond273.i, i64 0, i32 1
  %68 = load i32, ptr %tt292.i, align 8
  %cmp293.i = icmp eq i32 %68, 3
  br i1 %cmp293.i, label %land.lhs.true295.i, label %if.else307.i

land.lhs.true295.i:                               ; preds = %sw.bb255.i
  %tt296.i = getelementptr inbounds %struct.lua_TValue, ptr %cond291.i.v, i64 %idx.ext283.i, i32 1
  %69 = load i32, ptr %tt296.i, align 8
  %cmp297.i = icmp eq i32 %69, 3
  br i1 %cmp297.i, label %if.then299.i, label %if.else307.i

if.then299.i:                                     ; preds = %land.lhs.true295.i
  %70 = load double, ptr %cond273.i, align 8
  %71 = load double, ptr %cond291.i, align 8
  %sub.i = fsub double %70, %71
  store double %sub.i, ptr %add.ptr.i, align 8
  %tt306.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext.i, i32 1
  store i32 3, ptr %tt306.i, align 8
  br label %for.cond.i.backedge

if.else307.i:                                     ; preds = %land.lhs.true295.i, %sw.bb255.i
  store ptr %incdec.ptr.i, ptr %savedpc.i, align 8
  tail call fastcc void @Arith(ptr noundef %L, ptr noundef %add.ptr.i, ptr noundef nonnull %cond273.i, ptr noundef %cond291.i, i32 noundef 6)
  %72 = load ptr, ptr %base1.i, align 8
  br label %for.cond.i.backedge

sw.bb311.i:                                       ; preds = %for.cond.i
  %shr313.i = lshr i32 %14, 23
  %and320.i = and i32 %shr313.i, 255
  %idx.ext321.i = zext nneg i32 %and320.i to i64
  %add.ptr322.i = getelementptr inbounds %struct.lua_TValue, ptr %13, i64 %idx.ext321.i
  %idx.ext326.i = zext nneg i32 %shr313.i to i64
  %add.ptr327.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext326.i
  %tobool316.not.i535 = icmp slt i32 %14, 0
  %cond329.i = select i1 %tobool316.not.i535, ptr %add.ptr322.i, ptr %add.ptr327.i
  %shr331.i = lshr i32 %14, 14
  %73 = and i32 %14, 4194304
  %tobool334.not.i = icmp eq i32 %73, 0
  %and338.i = and i32 %shr331.i, 255
  %idx.ext339.i = zext nneg i32 %and338.i to i64
  %cond347.i.v = select i1 %tobool334.not.i, ptr %base.0.i, ptr %13
  %cond347.i = getelementptr inbounds %struct.lua_TValue, ptr %cond347.i.v, i64 %idx.ext339.i
  %tt348.i = getelementptr inbounds %struct.lua_TValue, ptr %cond329.i, i64 0, i32 1
  %74 = load i32, ptr %tt348.i, align 8
  %cmp349.i = icmp eq i32 %74, 3
  br i1 %cmp349.i, label %land.lhs.true351.i, label %if.else363.i

land.lhs.true351.i:                               ; preds = %sw.bb311.i
  %tt352.i = getelementptr inbounds %struct.lua_TValue, ptr %cond347.i.v, i64 %idx.ext339.i, i32 1
  %75 = load i32, ptr %tt352.i, align 8
  %cmp353.i = icmp eq i32 %75, 3
  br i1 %cmp353.i, label %if.then355.i, label %if.else363.i

if.then355.i:                                     ; preds = %land.lhs.true351.i
  %76 = load double, ptr %cond329.i, align 8
  %77 = load double, ptr %cond347.i, align 8
  %mul.i = fmul double %76, %77
  store double %mul.i, ptr %add.ptr.i, align 8
  %tt362.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext.i, i32 1
  store i32 3, ptr %tt362.i, align 8
  br label %for.cond.i.backedge

if.else363.i:                                     ; preds = %land.lhs.true351.i, %sw.bb311.i
  store ptr %incdec.ptr.i, ptr %savedpc.i, align 8
  tail call fastcc void @Arith(ptr noundef %L, ptr noundef %add.ptr.i, ptr noundef nonnull %cond329.i, ptr noundef %cond347.i, i32 noundef 7)
  %78 = load ptr, ptr %base1.i, align 8
  br label %for.cond.i.backedge

sw.bb367.i:                                       ; preds = %for.cond.i
  %shr369.i = lshr i32 %14, 23
  %and376.i = and i32 %shr369.i, 255
  %idx.ext377.i = zext nneg i32 %and376.i to i64
  %add.ptr378.i = getelementptr inbounds %struct.lua_TValue, ptr %13, i64 %idx.ext377.i
  %idx.ext382.i = zext nneg i32 %shr369.i to i64
  %add.ptr383.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext382.i
  %tobool372.not.i534 = icmp slt i32 %14, 0
  %cond385.i = select i1 %tobool372.not.i534, ptr %add.ptr378.i, ptr %add.ptr383.i
  %shr387.i = lshr i32 %14, 14
  %79 = and i32 %14, 4194304
  %tobool390.not.i = icmp eq i32 %79, 0
  %and394.i = and i32 %shr387.i, 255
  %idx.ext395.i = zext nneg i32 %and394.i to i64
  %cond403.i.v = select i1 %tobool390.not.i, ptr %base.0.i, ptr %13
  %cond403.i = getelementptr inbounds %struct.lua_TValue, ptr %cond403.i.v, i64 %idx.ext395.i
  %tt404.i = getelementptr inbounds %struct.lua_TValue, ptr %cond385.i, i64 0, i32 1
  %80 = load i32, ptr %tt404.i, align 8
  %cmp405.i = icmp eq i32 %80, 3
  br i1 %cmp405.i, label %land.lhs.true407.i, label %if.else419.i

land.lhs.true407.i:                               ; preds = %sw.bb367.i
  %tt408.i = getelementptr inbounds %struct.lua_TValue, ptr %cond403.i.v, i64 %idx.ext395.i, i32 1
  %81 = load i32, ptr %tt408.i, align 8
  %cmp409.i = icmp eq i32 %81, 3
  br i1 %cmp409.i, label %if.then411.i, label %if.else419.i

if.then411.i:                                     ; preds = %land.lhs.true407.i
  %82 = load double, ptr %cond385.i, align 8
  %83 = load double, ptr %cond403.i, align 8
  %div.i = fdiv double %82, %83
  store double %div.i, ptr %add.ptr.i, align 8
  %tt418.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext.i, i32 1
  store i32 3, ptr %tt418.i, align 8
  br label %for.cond.i.backedge

if.else419.i:                                     ; preds = %land.lhs.true407.i, %sw.bb367.i
  store ptr %incdec.ptr.i, ptr %savedpc.i, align 8
  tail call fastcc void @Arith(ptr noundef %L, ptr noundef %add.ptr.i, ptr noundef nonnull %cond385.i, ptr noundef %cond403.i, i32 noundef 8)
  %84 = load ptr, ptr %base1.i, align 8
  br label %for.cond.i.backedge

sw.bb423.i:                                       ; preds = %for.cond.i
  %shr425.i = lshr i32 %14, 23
  %and432.i = and i32 %shr425.i, 255
  %idx.ext433.i = zext nneg i32 %and432.i to i64
  %add.ptr434.i = getelementptr inbounds %struct.lua_TValue, ptr %13, i64 %idx.ext433.i
  %idx.ext438.i = zext nneg i32 %shr425.i to i64
  %add.ptr439.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext438.i
  %tobool428.not.i533 = icmp slt i32 %14, 0
  %cond441.i = select i1 %tobool428.not.i533, ptr %add.ptr434.i, ptr %add.ptr439.i
  %shr443.i = lshr i32 %14, 14
  %85 = and i32 %14, 4194304
  %tobool446.not.i = icmp eq i32 %85, 0
  %and450.i = and i32 %shr443.i, 255
  %idx.ext451.i = zext nneg i32 %and450.i to i64
  %cond459.i.v = select i1 %tobool446.not.i, ptr %base.0.i, ptr %13
  %cond459.i = getelementptr inbounds %struct.lua_TValue, ptr %cond459.i.v, i64 %idx.ext451.i
  %tt460.i = getelementptr inbounds %struct.lua_TValue, ptr %cond441.i, i64 0, i32 1
  %86 = load i32, ptr %tt460.i, align 8
  %cmp461.i = icmp eq i32 %86, 3
  br i1 %cmp461.i, label %land.lhs.true463.i, label %if.else477.i

land.lhs.true463.i:                               ; preds = %sw.bb423.i
  %tt464.i = getelementptr inbounds %struct.lua_TValue, ptr %cond459.i.v, i64 %idx.ext451.i, i32 1
  %87 = load i32, ptr %tt464.i, align 8
  %cmp465.i = icmp eq i32 %87, 3
  br i1 %cmp465.i, label %if.then467.i, label %if.else477.i

if.then467.i:                                     ; preds = %land.lhs.true463.i
  %88 = load double, ptr %cond441.i, align 8
  %89 = load double, ptr %cond459.i, align 8
  %div473.i = fdiv double %88, %89
  %90 = tail call double @llvm.floor.f64(double %div473.i)
  %neg.i = fneg double %90
  %91 = tail call double @llvm.fmuladd.f64(double %neg.i, double %89, double %88)
  store double %91, ptr %add.ptr.i, align 8
  %tt476.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext.i, i32 1
  store i32 3, ptr %tt476.i, align 8
  br label %for.cond.i.backedge

if.else477.i:                                     ; preds = %land.lhs.true463.i, %sw.bb423.i
  store ptr %incdec.ptr.i, ptr %savedpc.i, align 8
  tail call fastcc void @Arith(ptr noundef %L, ptr noundef %add.ptr.i, ptr noundef nonnull %cond441.i, ptr noundef %cond459.i, i32 noundef 9)
  %92 = load ptr, ptr %base1.i, align 8
  br label %for.cond.i.backedge

sw.bb481.i:                                       ; preds = %for.cond.i
  %shr483.i = lshr i32 %14, 23
  %and490.i = and i32 %shr483.i, 255
  %idx.ext491.i = zext nneg i32 %and490.i to i64
  %add.ptr492.i = getelementptr inbounds %struct.lua_TValue, ptr %13, i64 %idx.ext491.i
  %idx.ext496.i = zext nneg i32 %shr483.i to i64
  %add.ptr497.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext496.i
  %tobool486.not.i532 = icmp slt i32 %14, 0
  %cond499.i = select i1 %tobool486.not.i532, ptr %add.ptr492.i, ptr %add.ptr497.i
  %shr501.i = lshr i32 %14, 14
  %93 = and i32 %14, 4194304
  %tobool504.not.i = icmp eq i32 %93, 0
  %and508.i = and i32 %shr501.i, 255
  %idx.ext509.i = zext nneg i32 %and508.i to i64
  %cond517.i.v = select i1 %tobool504.not.i, ptr %base.0.i, ptr %13
  %cond517.i = getelementptr inbounds %struct.lua_TValue, ptr %cond517.i.v, i64 %idx.ext509.i
  %tt518.i = getelementptr inbounds %struct.lua_TValue, ptr %cond499.i, i64 0, i32 1
  %94 = load i32, ptr %tt518.i, align 8
  %cmp519.i = icmp eq i32 %94, 3
  br i1 %cmp519.i, label %land.lhs.true521.i, label %if.else534.i

land.lhs.true521.i:                               ; preds = %sw.bb481.i
  %tt522.i = getelementptr inbounds %struct.lua_TValue, ptr %cond517.i.v, i64 %idx.ext509.i, i32 1
  %95 = load i32, ptr %tt522.i, align 8
  %cmp523.i = icmp eq i32 %95, 3
  br i1 %cmp523.i, label %if.then525.i, label %if.else534.i

if.then525.i:                                     ; preds = %land.lhs.true521.i
  %96 = load double, ptr %cond499.i, align 8
  %97 = load double, ptr %cond517.i, align 8
  %call531.i = tail call double @pow(double noundef %96, double noundef %97) #35
  store double %call531.i, ptr %add.ptr.i, align 8
  %tt533.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext.i, i32 1
  store i32 3, ptr %tt533.i, align 8
  br label %for.cond.i.backedge

if.else534.i:                                     ; preds = %land.lhs.true521.i, %sw.bb481.i
  store ptr %incdec.ptr.i, ptr %savedpc.i, align 8
  tail call fastcc void @Arith(ptr noundef %L, ptr noundef %add.ptr.i, ptr noundef nonnull %cond499.i, ptr noundef %cond517.i, i32 noundef 10)
  %98 = load ptr, ptr %base1.i, align 8
  br label %for.cond.i.backedge

sw.bb538.i:                                       ; preds = %for.cond.i
  %shr540.i = lshr i32 %14, 23
  %idx.ext542.i = zext nneg i32 %shr540.i to i64
  %add.ptr543.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext542.i
  %tt544.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext542.i, i32 1
  %99 = load i32, ptr %tt544.i, align 8
  %cmp545.i = icmp eq i32 %99, 3
  br i1 %cmp545.i, label %if.then547.i, label %if.else553.i

if.then547.i:                                     ; preds = %sw.bb538.i
  %100 = load double, ptr %add.ptr543.i, align 8
  %fneg.i = fneg double %100
  store double %fneg.i, ptr %add.ptr.i, align 8
  %tt552.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext.i, i32 1
  store i32 3, ptr %tt552.i, align 8
  br label %for.cond.i.backedge

if.else553.i:                                     ; preds = %sw.bb538.i
  store ptr %incdec.ptr.i, ptr %savedpc.i, align 8
  tail call fastcc void @Arith(ptr noundef %L, ptr noundef nonnull %add.ptr.i, ptr noundef nonnull %add.ptr543.i, ptr noundef nonnull %add.ptr543.i, i32 noundef 11)
  %101 = load ptr, ptr %base1.i, align 8
  br label %for.cond.i.backedge

sw.bb557.i:                                       ; preds = %for.cond.i
  %shr558.i = lshr i32 %14, 23
  %idx.ext560.i = zext nneg i32 %shr558.i to i64
  %tt562.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext560.i, i32 1
  %102 = load i32, ptr %tt562.i, align 8
  switch i32 %102, label %lor.end.fold.split.i [
    i32 0, label %lor.end.i
    i32 1, label %land.rhs.i
  ]

land.rhs.i:                                       ; preds = %sw.bb557.i
  %add.ptr561.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext560.i
  %103 = load i32, ptr %add.ptr561.i, align 8
  %cmp577.i = icmp eq i32 %103, 0
  br label %lor.end.i

lor.end.fold.split.i:                             ; preds = %sw.bb557.i
  br label %lor.end.i

lor.end.i:                                        ; preds = %lor.end.fold.split.i, %land.rhs.i, %sw.bb557.i
  %104 = phi i1 [ true, %sw.bb557.i ], [ %cmp577.i, %land.rhs.i ], [ false, %lor.end.fold.split.i ]
  %lor.ext.i = zext i1 %104 to i32
  store i32 %lor.ext.i, ptr %add.ptr.i, align 8
  %tt581.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext.i, i32 1
  store i32 1, ptr %tt581.i, align 8
  br label %for.cond.i.backedge

sw.bb582.i:                                       ; preds = %for.cond.i
  %shr584.i = lshr i32 %14, 23
  %idx.ext586.i = zext nneg i32 %shr584.i to i64
  %add.ptr587.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext586.i
  %tt588.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext586.i, i32 1
  %105 = load i32, ptr %tt588.i, align 8
  switch i32 %105, label %sw.default.i [
    i32 5, label %sw.bb589.i
    i32 4, label %sw.bb596.i
  ]

sw.bb589.i:                                       ; preds = %sw.bb582.i
  %106 = load ptr, ptr %add.ptr587.i, align 8
  %call592.i = tail call fastcc i32 @luaH_getn(ptr noundef %106)
  %conv593.i = sitofp i32 %call592.i to double
  store double %conv593.i, ptr %add.ptr.i, align 8
  %tt595.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext.i, i32 1
  store i32 3, ptr %tt595.i, align 8
  br label %for.cond.i.backedge

sw.bb596.i:                                       ; preds = %sw.bb582.i
  %107 = load ptr, ptr %add.ptr587.i, align 8
  %len.i = getelementptr inbounds %struct.anon.0, ptr %107, i64 0, i32 5
  %108 = load i64, ptr %len.i, align 8
  %conv599.i = uitofp i64 %108 to double
  store double %conv599.i, ptr %add.ptr.i, align 8
  %tt601.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext.i, i32 1
  store i32 3, ptr %tt601.i, align 8
  br label %for.cond.i.backedge

sw.default.i:                                     ; preds = %sw.bb582.i
  store ptr %incdec.ptr.i, ptr %savedpc.i, align 8
  %call603.i = tail call fastcc i32 @call_binTM(ptr noundef %L, ptr noundef nonnull %add.ptr587.i, ptr noundef nonnull @luaO_nilobject_, ptr noundef nonnull %add.ptr.i, i32 noundef 12), !range !23
  %tobool604.not.i = icmp eq i32 %call603.i, 0
  br i1 %tobool604.not.i, label %if.then605.i, label %if.end606.i

if.then605.i:                                     ; preds = %sw.default.i
  %109 = load i32, ptr %tt588.i, align 8
  %idxprom.i78 = sext i32 %109 to i64
  %arrayidx.i79 = getelementptr inbounds [11 x ptr], ptr @luaT_typenames, i64 0, i64 %idxprom.i78
  %110 = load ptr, ptr %arrayidx.i79, align 8
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef nonnull %L, ptr noundef nonnull @.str.20, ptr noundef nonnull @.str.32, ptr noundef %110)
  unreachable

if.end606.i:                                      ; preds = %sw.default.i
  %111 = load ptr, ptr %base1.i, align 8
  br label %for.cond.i.backedge

sw.bb608.i:                                       ; preds = %for.cond.i
  %shr610.i = lshr i32 %14, 23
  %shr613.i = lshr i32 %14, 14
  %and614.i = and i32 %shr613.i, 511
  store ptr %incdec.ptr.i, ptr %savedpc.i, align 8
  %reass.sub911 = sub nsw i32 %and614.i, %shr610.i
  %add617.i = add nsw i32 %reass.sub911, 1
  tail call fastcc void @luaV_concat(ptr noundef %L, i32 noundef %add617.i, i32 noundef %and614.i)
  %112 = load ptr, ptr %l_G.i467, align 8
  %totalbytes619.i = getelementptr inbounds %struct.global_State, ptr %112, i64 0, i32 14
  %113 = load i64, ptr %totalbytes619.i, align 8
  %GCthreshold621.i = getelementptr inbounds %struct.global_State, ptr %112, i64 0, i32 13
  %114 = load i64, ptr %GCthreshold621.i, align 8
  %cmp622.not.i = icmp ult i64 %113, %114
  br i1 %cmp622.not.i, label %if.end625.i, label %if.then624.i

if.then624.i:                                     ; preds = %sw.bb608.i
  %gcstepmul.i82 = getelementptr inbounds %struct.global_State, ptr %112, i64 0, i32 18
  %115 = load i32, ptr %gcstepmul.i82, align 4
  %mul.i83 = mul i32 %115, 10
  %conv.i84 = zext i32 %mul.i83 to i64
  %cmp.i85 = icmp eq i32 %mul.i83, 0
  %spec.store.select.i86 = select i1 %cmp.i85, i64 9223372036854775806, i64 %conv.i84
  %sub.i89 = sub i64 %113, %114
  %gcdept.i90 = getelementptr inbounds %struct.global_State, ptr %112, i64 0, i32 16
  %116 = load i64, ptr %gcdept.i90, align 8
  %add.i91 = add i64 %sub.i89, %116
  store i64 %add.i91, ptr %gcdept.i90, align 8
  %gcstate.i96 = getelementptr inbounds %struct.global_State, ptr %112, i64 0, i32 4
  br label %do.body.i92

do.body.i92:                                      ; preds = %do.body.i92, %if.then624.i
  %lim.0.i93 = phi i64 [ %spec.store.select.i86, %if.then624.i ], [ %sub2.i95, %do.body.i92 ]
  %call.i94 = tail call fastcc i64 @singlestep(ptr noundef %L)
  %sub2.i95 = sub nsw i64 %lim.0.i93, %call.i94
  %117 = load i8, ptr %gcstate.i96, align 1
  %cmp4.i97 = icmp ne i8 %117, 0
  %cmp8.i98 = icmp sgt i64 %sub2.i95, 0
  %or.cond.i99 = select i1 %cmp4.i97, i1 %cmp8.i98, i1 false
  br i1 %or.cond.i99, label %do.body.i92, label %do.end.i100, !llvm.loop !6

do.end.i100:                                      ; preds = %do.body.i92
  br i1 %cmp4.i97, label %if.then14.i107, label %if.else27.i101

if.then14.i107:                                   ; preds = %do.end.i100
  %118 = load i64, ptr %gcdept.i90, align 8
  %cmp16.i108 = icmp ult i64 %118, 1024
  br i1 %cmp16.i108, label %if.then18.i111, label %if.else.i109

if.then18.i111:                                   ; preds = %if.then14.i107
  %119 = load i64, ptr %totalbytes619.i, align 8
  %add20.i112 = add i64 %119, 1024
  br label %if.end625.i.sink.split

if.else.i109:                                     ; preds = %if.then14.i107
  %sub23.i110 = add i64 %118, -1024
  store i64 %sub23.i110, ptr %gcdept.i90, align 8
  %120 = load i64, ptr %totalbytes619.i, align 8
  br label %if.end625.i.sink.split

if.else27.i101:                                   ; preds = %do.end.i100
  %estimate.i102 = getelementptr inbounds %struct.global_State, ptr %112, i64 0, i32 15
  %121 = load i64, ptr %estimate.i102, align 8
  %div.i103 = udiv i64 %121, 100
  %gcpause.i104 = getelementptr inbounds %struct.global_State, ptr %112, i64 0, i32 17
  %122 = load i32, ptr %gcpause.i104, align 8
  %conv28.i105 = sext i32 %122 to i64
  %mul29.i106 = mul i64 %div.i103, %conv28.i105
  br label %if.end625.i.sink.split

if.end625.i.sink.split:                           ; preds = %if.then18.i111, %if.else.i109, %if.else27.i101
  %mul29.i106.sink = phi i64 [ %mul29.i106, %if.else27.i101 ], [ %120, %if.else.i109 ], [ %add20.i112, %if.then18.i111 ]
  store i64 %mul29.i106.sink, ptr %GCthreshold621.i, align 8
  br label %if.end625.i

if.end625.i:                                      ; preds = %if.end625.i.sink.split, %sw.bb608.i
  %123 = load ptr, ptr %base1.i, align 8
  %idx.ext628.i = zext nneg i32 %shr610.i to i64
  %add.ptr629.i = getelementptr inbounds %struct.lua_TValue, ptr %123, i64 %idx.ext628.i
  %add.ptr634.i = getelementptr inbounds %struct.lua_TValue, ptr %123, i64 %idx.ext.i
  %124 = load i64, ptr %add.ptr629.i, align 8
  store i64 %124, ptr %add.ptr634.i, align 8
  %tt637.i = getelementptr inbounds %struct.lua_TValue, ptr %123, i64 %idx.ext628.i, i32 1
  %125 = load i32, ptr %tt637.i, align 8
  %tt638.i = getelementptr inbounds %struct.lua_TValue, ptr %123, i64 %idx.ext.i, i32 1
  store i32 %125, ptr %tt638.i, align 8
  br label %for.cond.i.backedge

sw.bb639.i:                                       ; preds = %for.cond.i
  %shr640.i = lshr i32 %14, 14
  %126 = zext nneg i32 %shr640.i to i64
  %127 = getelementptr i32, ptr %incdec.ptr.i, i64 %126
  %add.ptr644.i = getelementptr i32, ptr %127, i64 -131071
  br label %for.cond.i.backedge

sw.bb645.i:                                       ; preds = %for.cond.i
  %shr647.i = lshr i32 %14, 23
  %and654.i = and i32 %shr647.i, 255
  %idx.ext655.i = zext nneg i32 %and654.i to i64
  %add.ptr656.i = getelementptr inbounds %struct.lua_TValue, ptr %13, i64 %idx.ext655.i
  %idx.ext660.i = zext nneg i32 %shr647.i to i64
  %add.ptr661.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext660.i
  %tobool650.not.i531 = icmp slt i32 %14, 0
  %cond663.i = select i1 %tobool650.not.i531, ptr %add.ptr656.i, ptr %add.ptr661.i
  %shr665.i = lshr i32 %14, 14
  %128 = and i32 %14, 4194304
  %tobool668.not.i = icmp eq i32 %128, 0
  %and672.i = and i32 %shr665.i, 255
  %idx.ext673.i = zext nneg i32 %and672.i to i64
  %cond681.i.v = select i1 %tobool668.not.i, ptr %base.0.i, ptr %13
  %cond681.i = getelementptr inbounds %struct.lua_TValue, ptr %cond681.i.v, i64 %idx.ext673.i
  store ptr %incdec.ptr.i, ptr %savedpc.i, align 8
  %tt683.i = getelementptr inbounds %struct.lua_TValue, ptr %cond663.i, i64 0, i32 1
  %129 = load i32, ptr %tt683.i, align 8
  %tt684.i = getelementptr inbounds %struct.lua_TValue, ptr %cond681.i.v, i64 %idx.ext673.i, i32 1
  %130 = load i32, ptr %tt684.i, align 8
  %cmp685.i = icmp eq i32 %129, %130
  br i1 %cmp685.i, label %land.rhs687.i, label %land.end690.i

land.rhs687.i:                                    ; preds = %sw.bb645.i
  switch i32 %129, label %sw.default.i125 [
    i32 0, label %land.end690.i
    i32 3, label %sw.bb1.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb8.i
    i32 7, label %sw.bb13.i
    i32 5, label %sw.bb21.i
  ]

sw.bb1.i:                                         ; preds = %land.rhs687.i
  %131 = load double, ptr %cond663.i, align 8
  %132 = load double, ptr %cond681.i, align 8
  %cmp.i123 = fcmp oeq double %131, %132
  br label %land.end690.i

sw.bb3.i:                                         ; preds = %land.rhs687.i
  %133 = load i32, ptr %cond663.i, align 8
  %134 = load i32, ptr %cond681.i, align 8
  %cmp6.i = icmp eq i32 %133, %134
  br label %land.end690.i

sw.bb8.i:                                         ; preds = %land.rhs687.i
  %135 = load ptr, ptr %cond663.i, align 8
  %136 = load ptr, ptr %cond681.i, align 8
  %cmp11.i = icmp eq ptr %135, %136
  br label %land.end690.i

sw.bb13.i:                                        ; preds = %land.rhs687.i
  %137 = load ptr, ptr %cond663.i, align 8
  %138 = load ptr, ptr %cond681.i, align 8
  %cmp16.i120 = icmp eq ptr %137, %138
  br i1 %cmp16.i120, label %land.end690.i, label %if.end.i121

if.end.i121:                                      ; preds = %sw.bb13.i
  %metatable.i = getelementptr inbounds %struct.anon.1, ptr %137, i64 0, i32 3
  %metatable20.i = getelementptr inbounds %struct.anon.1, ptr %138, i64 0, i32 3
  br label %sw.epilog.i115

sw.bb21.i:                                        ; preds = %land.rhs687.i
  %139 = load ptr, ptr %cond663.i, align 8
  %140 = load ptr, ptr %cond681.i, align 8
  %cmp24.i = icmp eq ptr %139, %140
  br i1 %cmp24.i, label %land.end690.i, label %if.end27.i

if.end27.i:                                       ; preds = %sw.bb21.i
  %metatable29.i = getelementptr inbounds %struct.Table, ptr %139, i64 0, i32 5
  %metatable31.i = getelementptr inbounds %struct.Table, ptr %140, i64 0, i32 5
  br label %sw.epilog.i115

sw.default.i125:                                  ; preds = %land.rhs687.i
  %141 = load ptr, ptr %cond663.i, align 8
  %142 = load ptr, ptr %cond681.i, align 8
  %cmp35.i = icmp eq ptr %141, %142
  br label %land.end690.i

sw.epilog.i115:                                   ; preds = %if.end27.i, %if.end.i121
  %metatable31.i.sink = phi ptr [ %metatable31.i, %if.end27.i ], [ %metatable20.i, %if.end.i121 ]
  %.sink732.in = phi ptr [ %metatable29.i, %if.end27.i ], [ %metatable.i, %if.end.i121 ]
  %.sink732 = load ptr, ptr %.sink732.in, align 8
  %143 = load ptr, ptr %metatable31.i.sink, align 8
  %cmp.i734 = icmp eq ptr %.sink732, null
  br i1 %cmp.i734, label %land.end690.i, label %cond.false.i735

cond.false.i735:                                  ; preds = %sw.epilog.i115
  %flags.i = getelementptr inbounds %struct.Table, ptr %.sink732, i64 0, i32 3
  %144 = load i8, ptr %flags.i, align 2
  %145 = and i8 %144, 16
  %tobool.not.i736 = icmp eq i8 %145, 0
  br i1 %tobool.not.i736, label %cond.false2.i, label %land.end690.i

cond.false2.i:                                    ; preds = %cond.false.i735
  %146 = load ptr, ptr %l_G.i467, align 8
  %arrayidx.i739 = getelementptr inbounds %struct.global_State, ptr %146, i64 0, i32 24, i64 4
  %147 = load ptr, ptr %arrayidx.i739, align 8
  %148 = getelementptr i8, ptr %.sink732, i64 11
  %events.val.i.i = load i8, ptr %148, align 1
  %149 = getelementptr i8, ptr %.sink732, i64 32
  %events.val3.i.i = load ptr, ptr %149, align 8
  %hash.i.i.i = getelementptr inbounds %struct.anon.0, ptr %147, i64 0, i32 4
  %150 = load i32, ptr %hash.i.i.i, align 4
  %sh_prom.i.i.i740 = zext nneg i8 %events.val.i.i to i64
  %notmask.i.i.i741 = shl nsw i64 -1, %sh_prom.i.i.i740
  %151 = trunc i64 %notmask.i.i.i741 to i32
  %152 = xor i32 %151, -1
  %conv2.i.i.i = and i32 %150, %152
  %idxprom.i.i.i = sext i32 %conv2.i.i.i to i64
  %arrayidx.i.i.i = getelementptr inbounds %struct.Node, ptr %events.val3.i.i, i64 %idxprom.i.i.i
  br label %do.body.i.i.i

do.body.i.i.i:                                    ; preds = %if.else.i.i.i, %cond.false2.i
  %n.0.i.i.i = phi ptr [ %arrayidx.i.i.i, %cond.false2.i ], [ %155, %if.else.i.i.i ]
  %tt.i.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i.i, i64 0, i32 1, i32 0, i32 1
  %153 = load i32, ptr %tt.i.i.i, align 8
  %cmp.i.i.i742 = icmp eq i32 %153, 4
  br i1 %cmp.i.i.i742, label %land.lhs.true.i.i.i, label %if.else.i.i.i

land.lhs.true.i.i.i:                              ; preds = %do.body.i.i.i
  %i_key.i.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i.i, i64 0, i32 1
  %154 = load ptr, ptr %i_key.i.i.i, align 8
  %cmp5.i.i.i = icmp eq ptr %154, %147
  br i1 %cmp5.i.i.i, label %luaH_getstr.exit.i.i, label %if.else.i.i.i

if.else.i.i.i:                                    ; preds = %land.lhs.true.i.i.i, %do.body.i.i.i
  %next.i.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i.i, i64 0, i32 1, i32 0, i32 2
  %155 = load ptr, ptr %next.i.i.i, align 8
  %tobool.not.i.i.i = icmp eq ptr %155, null
  br i1 %tobool.not.i.i.i, label %luaH_getstr.exit.i.i, label %do.body.i.i.i, !llvm.loop !29

luaH_getstr.exit.i.i:                             ; preds = %if.else.i.i.i, %land.lhs.true.i.i.i
  %retval.0.i.i.i743 = phi ptr [ %n.0.i.i.i, %land.lhs.true.i.i.i ], [ @luaO_nilobject_, %if.else.i.i.i ]
  %tt.i.i = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i.i.i743, i64 0, i32 1
  %156 = load i32, ptr %tt.i.i, align 8
  %cmp.i.i = icmp eq i32 %156, 0
  br i1 %cmp.i.i, label %if.then.i.i750, label %if.end.i744

if.then.i.i750:                                   ; preds = %luaH_getstr.exit.i.i
  %conv3.i.i = or disjoint i8 %144, 16
  store i8 %conv3.i.i, ptr %flags.i, align 2
  br label %land.end690.i

if.end.i744:                                      ; preds = %luaH_getstr.exit.i.i
  %cmp7.i = icmp eq ptr %.sink732, %143
  br i1 %cmp7.i, label %if.end40.i, label %if.end10.i

if.end10.i:                                       ; preds = %if.end.i744
  %cmp11.i745 = icmp eq ptr %143, null
  br i1 %cmp11.i745, label %land.end690.i, label %cond.false14.i

cond.false14.i:                                   ; preds = %if.end10.i
  %flags15.i = getelementptr inbounds %struct.Table, ptr %143, i64 0, i32 3
  %157 = load i8, ptr %flags15.i, align 2
  %158 = and i8 %157, 16
  %tobool19.not.i = icmp eq i8 %158, 0
  br i1 %tobool19.not.i, label %cond.false21.i, label %land.end690.i

cond.false21.i:                                   ; preds = %cond.false14.i
  %159 = getelementptr i8, ptr %143, i64 11
  %events.val.i17.i = load i8, ptr %159, align 1
  %160 = getelementptr i8, ptr %143, i64 32
  %events.val3.i18.i = load ptr, ptr %160, align 8
  %sh_prom.i.i20.i = zext nneg i8 %events.val.i17.i to i64
  %notmask.i.i21.i = shl nsw i64 -1, %sh_prom.i.i20.i
  %161 = trunc i64 %notmask.i.i21.i to i32
  %162 = xor i32 %161, -1
  %conv2.i.i22.i = and i32 %150, %162
  %idxprom.i.i23.i = sext i32 %conv2.i.i22.i to i64
  %arrayidx.i.i24.i = getelementptr inbounds %struct.Node, ptr %events.val3.i18.i, i64 %idxprom.i.i23.i
  br label %do.body.i.i25.i

do.body.i.i25.i:                                  ; preds = %if.else.i.i29.i, %cond.false21.i
  %n.0.i.i26.i = phi ptr [ %arrayidx.i.i24.i, %cond.false21.i ], [ %165, %if.else.i.i29.i ]
  %tt.i.i27.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i26.i, i64 0, i32 1, i32 0, i32 1
  %163 = load i32, ptr %tt.i.i27.i, align 8
  %cmp.i.i28.i = icmp eq i32 %163, 4
  br i1 %cmp.i.i28.i, label %land.lhs.true.i.i40.i, label %if.else.i.i29.i

land.lhs.true.i.i40.i:                            ; preds = %do.body.i.i25.i
  %i_key.i.i41.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i26.i, i64 0, i32 1
  %164 = load ptr, ptr %i_key.i.i41.i, align 8
  %cmp5.i.i42.i = icmp eq ptr %164, %147
  br i1 %cmp5.i.i42.i, label %luaH_getstr.exit.i32.i, label %if.else.i.i29.i

if.else.i.i29.i:                                  ; preds = %land.lhs.true.i.i40.i, %do.body.i.i25.i
  %next.i.i30.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i26.i, i64 0, i32 1, i32 0, i32 2
  %165 = load ptr, ptr %next.i.i30.i, align 8
  %tobool.not.i.i31.i = icmp eq ptr %165, null
  br i1 %tobool.not.i.i31.i, label %luaH_getstr.exit.i32.i, label %do.body.i.i25.i, !llvm.loop !29

luaH_getstr.exit.i32.i:                           ; preds = %if.else.i.i29.i, %land.lhs.true.i.i40.i
  %retval.0.i.i33.i = phi ptr [ %n.0.i.i26.i, %land.lhs.true.i.i40.i ], [ @luaO_nilobject_, %if.else.i.i29.i ]
  %tt.i34.i = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i.i33.i, i64 0, i32 1
  %166 = load i32, ptr %tt.i34.i, align 8
  %cmp.i35.i = icmp eq i32 %166, 0
  br i1 %cmp.i35.i, label %if.then.i37.i, label %if.end34.i

if.then.i37.i:                                    ; preds = %luaH_getstr.exit.i32.i
  %conv3.i39.i = or disjoint i8 %157, 16
  store i8 %conv3.i39.i, ptr %flags15.i, align 2
  br label %land.end690.i

if.end34.i:                                       ; preds = %luaH_getstr.exit.i32.i
  %cmp.not.i.i746 = icmp eq i32 %156, %166
  br i1 %cmp.not.i.i746, label %if.else.i.i747, label %land.end690.i

if.else.i.i747:                                   ; preds = %if.end34.i
  switch i32 %156, label %sw.default.i.i [
    i32 0, label %get_compTM.exit
    i32 3, label %luaO_rawequalObj.exit.i
    i32 1, label %sw.bb6.i.i
    i32 2, label %sw.bb11.i.i
  ]

sw.bb6.i.i:                                       ; preds = %if.else.i.i747
  %167 = load i32, ptr %retval.0.i.i.i743, align 8
  %168 = load i32, ptr %retval.0.i.i33.i, align 8
  %cmp9.i.i748 = icmp eq i32 %167, %168
  %cond.fr57.i = freeze i1 %cmp9.i.i748
  br i1 %cond.fr57.i, label %if.end40.i, label %land.end690.i

sw.bb11.i.i:                                      ; preds = %if.else.i.i747
  %169 = load ptr, ptr %retval.0.i.i.i743, align 8
  %170 = load ptr, ptr %retval.0.i.i33.i, align 8
  %cmp14.i.i = icmp eq ptr %169, %170
  %cond.fr56.i = freeze i1 %cmp14.i.i
  br i1 %cond.fr56.i, label %if.end40.i, label %land.end690.i

sw.default.i.i:                                   ; preds = %if.else.i.i747
  %171 = load ptr, ptr %retval.0.i.i.i743, align 8
  %172 = load ptr, ptr %retval.0.i.i33.i, align 8
  %cmp18.i.i = icmp eq ptr %171, %172
  %cond.fr55.i = freeze i1 %cmp18.i.i
  br i1 %cond.fr55.i, label %if.end40.i, label %land.end690.i

luaO_rawequalObj.exit.i:                          ; preds = %if.else.i.i747
  %173 = load double, ptr %retval.0.i.i.i743, align 8
  %174 = load double, ptr %retval.0.i.i33.i, align 8
  %cmp5.i.i749 = fcmp oeq double %173, %174
  %cond.fr.i = freeze i1 %cmp5.i.i749
  br i1 %cond.fr.i, label %if.end40.i, label %land.end690.i

get_compTM.exit:                                  ; preds = %if.else.i.i747
  %cmp37.i = icmp eq ptr %retval.0.i.i.i743, null
  br i1 %cmp37.i, label %land.end690.i, label %if.end40.i

if.end40.i:                                       ; preds = %luaO_rawequalObj.exit.i, %sw.default.i.i, %sw.bb11.i.i, %sw.bb6.i.i, %if.end.i744, %get_compTM.exit
  %175 = load ptr, ptr %top1267.i, align 8
  %176 = load ptr, ptr %stack.i763, align 8
  %177 = load i64, ptr %retval.0.i.i.i743, align 8
  store i64 %177, ptr %175, align 8
  %178 = load i32, ptr %tt.i.i, align 8
  %tt2.i = getelementptr inbounds %struct.lua_TValue, ptr %175, i64 0, i32 1
  store i32 %178, ptr %tt2.i, align 8
  %179 = load ptr, ptr %top1267.i, align 8
  %add.ptr.i752 = getelementptr inbounds %struct.lua_TValue, ptr %179, i64 1
  %180 = load i64, ptr %cond663.i, align 8
  store i64 %180, ptr %add.ptr.i752, align 8
  %181 = load i32, ptr %tt683.i, align 8
  %tt9.i753 = getelementptr inbounds %struct.lua_TValue, ptr %179, i64 1, i32 1
  store i32 %181, ptr %tt9.i753, align 8
  %182 = load ptr, ptr %top1267.i, align 8
  %add.ptr13.i = getelementptr inbounds %struct.lua_TValue, ptr %182, i64 2
  %183 = load i64, ptr %cond681.i, align 8
  store i64 %183, ptr %add.ptr13.i, align 8
  %184 = load i32, ptr %tt684.i, align 8
  %tt17.i = getelementptr inbounds %struct.lua_TValue, ptr %182, i64 2, i32 1
  store i32 %184, ptr %tt17.i, align 8
  %185 = load ptr, ptr %stack_last.i, align 8
  %186 = load ptr, ptr %top1267.i, align 8
  %sub.ptr.lhs.cast19.i = ptrtoint ptr %185 to i64
  %sub.ptr.rhs.cast20.i = ptrtoint ptr %186 to i64
  %sub.ptr.sub21.i = sub i64 %sub.ptr.lhs.cast19.i, %sub.ptr.rhs.cast20.i
  %cmp.i755 = icmp slt i64 %sub.ptr.sub21.i, 49
  br i1 %cmp.i755, label %if.then.i761, label %callTMres.exit

if.then.i761:                                     ; preds = %if.end40.i
  %187 = load i32, ptr %stacksize.i, align 8
  %cmp.not.i.i762 = icmp slt i32 %187, 3
  %add.i.i = add nsw i32 %187, 3
  %mul.i.i = shl nuw nsw i32 %187, 1
  %add.i.sink.i = select i1 %cmp.not.i.i762, i32 %add.i.i, i32 %mul.i.i
  tail call fastcc void @luaD_reallocstack(ptr noundef nonnull %L, i32 noundef %add.i.sink.i)
  %.pre990 = load ptr, ptr %top1267.i, align 8
  br label %callTMres.exit

callTMres.exit:                                   ; preds = %if.end40.i, %if.then.i761
  %188 = phi ptr [ %186, %if.end40.i ], [ %.pre990, %if.then.i761 ]
  %sub.ptr.lhs.cast.i757 = ptrtoint ptr %175 to i64
  %sub.ptr.rhs.cast.i758 = ptrtoint ptr %176 to i64
  %sub.ptr.sub.i759 = sub i64 %sub.ptr.lhs.cast.i757, %sub.ptr.rhs.cast.i758
  %add.ptr23.i = getelementptr inbounds %struct.lua_TValue, ptr %188, i64 3
  store ptr %add.ptr23.i, ptr %top1267.i, align 8
  tail call fastcc void @luaD_call(ptr noundef nonnull %L, ptr noundef %188, i32 noundef 1)
  %189 = load ptr, ptr %stack.i763, align 8
  %add.ptr27.i = getelementptr inbounds i8, ptr %189, i64 %sub.ptr.sub.i759
  %190 = load ptr, ptr %top1267.i, align 8
  %incdec.ptr.i760 = getelementptr inbounds %struct.lua_TValue, ptr %190, i64 -1
  store ptr %incdec.ptr.i760, ptr %top1267.i, align 8
  %191 = load i64, ptr %incdec.ptr.i760, align 8
  store i64 %191, ptr %add.ptr27.i, align 8
  %tt34.i = getelementptr %struct.lua_TValue, ptr %190, i64 -1, i32 1
  %192 = load i32, ptr %tt34.i, align 8
  %tt35.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr27.i, i64 0, i32 1
  store i32 %192, ptr %tt35.i, align 8
  %193 = load ptr, ptr %top1267.i, align 8
  %tt42.i = getelementptr inbounds %struct.lua_TValue, ptr %193, i64 0, i32 1
  %194 = load i32, ptr %tt42.i, align 8
  switch i32 %194, label %lor.end.fold.split.i119 [
    i32 0, label %land.end690.i
    i32 1, label %land.rhs.i117
  ]

land.rhs.i117:                                    ; preds = %callTMres.exit
  %195 = load i32, ptr %193, align 8
  %cmp51.i = icmp ne i32 %195, 0
  br label %land.end690.i

lor.end.fold.split.i119:                          ; preds = %callTMres.exit
  br label %land.end690.i

land.end690.i:                                    ; preds = %if.end34.i, %sw.bb6.i.i, %sw.bb11.i.i, %sw.default.i.i, %luaO_rawequalObj.exit.i, %if.then.i37.i, %cond.false14.i, %if.end10.i, %if.then.i.i750, %cond.false.i735, %sw.epilog.i115, %lor.end.fold.split.i119, %land.rhs.i117, %callTMres.exit, %get_compTM.exit, %sw.default.i125, %sw.bb21.i, %sw.bb13.i, %sw.bb8.i, %sw.bb3.i, %sw.bb1.i, %land.rhs687.i, %sw.bb645.i
  %196 = phi i1 [ false, %sw.bb645.i ], [ %cmp35.i, %sw.default.i125 ], [ %cmp11.i, %sw.bb8.i ], [ %cmp6.i, %sw.bb3.i ], [ %cmp.i123, %sw.bb1.i ], [ true, %land.rhs687.i ], [ true, %sw.bb13.i ], [ true, %sw.bb21.i ], [ false, %get_compTM.exit ], [ false, %callTMres.exit ], [ %cmp51.i, %land.rhs.i117 ], [ true, %lor.end.fold.split.i119 ], [ false, %sw.epilog.i115 ], [ false, %cond.false.i735 ], [ false, %if.then.i.i750 ], [ false, %if.end10.i ], [ false, %cond.false14.i ], [ false, %if.then.i37.i ], [ false, %luaO_rawequalObj.exit.i ], [ false, %sw.default.i.i ], [ false, %sw.bb11.i.i ], [ false, %sw.bb6.i.i ], [ false, %if.end34.i ]
  %land.ext.i = zext i1 %196 to i32
  %cmp693.i = icmp eq i32 %and.i, %land.ext.i
  br i1 %cmp693.i, label %if.then695.i, label %if.end701.i

if.then695.i:                                     ; preds = %land.end690.i
  %197 = load i32, ptr %incdec.ptr.i, align 4
  %shr696.i = lshr i32 %197, 14
  %198 = zext nneg i32 %shr696.i to i64
  %199 = getelementptr i32, ptr %incdec.ptr.i, i64 %198
  %add.ptr700.i = getelementptr i32, ptr %199, i64 -131071
  br label %if.end701.i

if.end701.i:                                      ; preds = %if.then695.i, %land.end690.i
  %pc.2.i = phi ptr [ %add.ptr700.i, %if.then695.i ], [ %incdec.ptr.i, %land.end690.i ]
  %200 = load ptr, ptr %base1.i, align 8
  %incdec.ptr703.i = getelementptr inbounds i32, ptr %pc.2.i, i64 1
  br label %for.cond.i.backedge

sw.bb704.i:                                       ; preds = %for.cond.i
  store ptr %incdec.ptr.i, ptr %savedpc.i, align 8
  %shr706.i = lshr i32 %14, 23
  %and713.i = and i32 %shr706.i, 255
  %idx.ext714.i = zext nneg i32 %and713.i to i64
  %add.ptr715.i = getelementptr inbounds %struct.lua_TValue, ptr %13, i64 %idx.ext714.i
  %idx.ext719.i = zext nneg i32 %shr706.i to i64
  %add.ptr720.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext719.i
  %tobool709.not.i530 = icmp slt i32 %14, 0
  %cond722.i = select i1 %tobool709.not.i530, ptr %add.ptr715.i, ptr %add.ptr720.i
  %shr723.i = lshr i32 %14, 14
  %201 = and i32 %14, 4194304
  %tobool726.not.i = icmp eq i32 %201, 0
  %and730.i = and i32 %shr723.i, 255
  %idx.ext731.i = zext nneg i32 %and730.i to i64
  %cond739.i.v = select i1 %tobool726.not.i, ptr %base.0.i, ptr %13
  %cond739.i = getelementptr inbounds %struct.lua_TValue, ptr %cond739.i.v, i64 %idx.ext731.i
  %call740.i = tail call fastcc i32 @luaV_lessthan(ptr noundef %L, ptr noundef %cond722.i, ptr noundef %cond739.i), !range !23
  %cmp743.i = icmp eq i32 %call740.i, %and.i
  br i1 %cmp743.i, label %if.then745.i, label %if.end751.i

if.then745.i:                                     ; preds = %sw.bb704.i
  %202 = load i32, ptr %incdec.ptr.i, align 4
  %shr746.i = lshr i32 %202, 14
  %203 = zext nneg i32 %shr746.i to i64
  %204 = getelementptr i32, ptr %incdec.ptr.i, i64 %203
  %add.ptr750.i = getelementptr i32, ptr %204, i64 -131071
  br label %if.end751.i

if.end751.i:                                      ; preds = %if.then745.i, %sw.bb704.i
  %pc.3.i = phi ptr [ %add.ptr750.i, %if.then745.i ], [ %incdec.ptr.i, %sw.bb704.i ]
  %205 = load ptr, ptr %base1.i, align 8
  %incdec.ptr753.i = getelementptr inbounds i32, ptr %pc.3.i, i64 1
  br label %for.cond.i.backedge

sw.bb754.i:                                       ; preds = %for.cond.i
  store ptr %incdec.ptr.i, ptr %savedpc.i, align 8
  %shr756.i = lshr i32 %14, 23
  %and763.i = and i32 %shr756.i, 255
  %idx.ext764.i = zext nneg i32 %and763.i to i64
  %add.ptr765.i = getelementptr inbounds %struct.lua_TValue, ptr %13, i64 %idx.ext764.i
  %idx.ext769.i = zext nneg i32 %shr756.i to i64
  %add.ptr770.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext769.i
  %tobool759.not.i529 = icmp slt i32 %14, 0
  %cond772.i = select i1 %tobool759.not.i529, ptr %add.ptr765.i, ptr %add.ptr770.i
  %shr773.i = lshr i32 %14, 14
  %206 = and i32 %14, 4194304
  %tobool776.not.i = icmp eq i32 %206, 0
  %and780.i = and i32 %shr773.i, 255
  %idx.ext781.i = zext nneg i32 %and780.i to i64
  %cond789.i.v = select i1 %tobool776.not.i, ptr %base.0.i, ptr %13
  %cond789.i = getelementptr inbounds %struct.lua_TValue, ptr %cond789.i.v, i64 %idx.ext781.i
  %tt.i126 = getelementptr inbounds %struct.lua_TValue, ptr %cond772.i, i64 0, i32 1
  %207 = load i32, ptr %tt.i126, align 8
  %tt1.i = getelementptr inbounds %struct.lua_TValue, ptr %cond789.i.v, i64 %idx.ext781.i, i32 1
  %208 = load i32, ptr %tt1.i, align 8
  %cmp.not.i127 = icmp eq i32 %207, %208
  br i1 %cmp.not.i127, label %if.else.i131, label %if.then.i128

if.then.i128:                                     ; preds = %sw.bb754.i
  %idxprom.i.i = sext i32 %207 to i64
  %arrayidx.i.i = getelementptr inbounds [11 x ptr], ptr @luaT_typenames, i64 0, i64 %idxprom.i.i
  %209 = load ptr, ptr %arrayidx.i.i, align 8
  %idxprom2.i.i = sext i32 %208 to i64
  %arrayidx3.i.i = getelementptr inbounds [11 x ptr], ptr @luaT_typenames, i64 0, i64 %idxprom2.i.i
  %210 = load ptr, ptr %arrayidx3.i.i, align 8
  %arrayidx4.i.i = getelementptr inbounds i8, ptr %209, i64 2
  %211 = load i8, ptr %arrayidx4.i.i, align 1
  %arrayidx5.i.i = getelementptr inbounds i8, ptr %210, i64 2
  %212 = load i8, ptr %arrayidx5.i.i, align 1
  %cmp.i.i129 = icmp eq i8 %211, %212
  br i1 %cmp.i.i129, label %if.then.i.i, label %if.else.i.i

if.then.i.i:                                      ; preds = %if.then.i128
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef nonnull %L, ptr noundef nonnull @.str.43, ptr noundef nonnull %209)
  unreachable

if.else.i.i:                                      ; preds = %if.then.i128
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef nonnull %L, ptr noundef nonnull @.str.44, ptr noundef nonnull %209, ptr noundef nonnull %210)
  unreachable

if.else.i131:                                     ; preds = %sw.bb754.i
  switch i32 %207, label %sw.default.i460 [
    i32 3, label %if.then4.i
    i32 4, label %if.then11.i
    i32 5, label %sw.bb.i458
    i32 7, label %sw.bb1.i430
  ]

if.then4.i:                                       ; preds = %if.else.i131
  %213 = load double, ptr %cond772.i, align 8
  %214 = load double, ptr %cond789.i, align 8
  %cmp6.i133 = fcmp ole double %213, %214
  %conv.i134 = zext i1 %cmp6.i133 to i32
  br label %lessequal.exit

if.then11.i:                                      ; preds = %if.else.i131
  %215 = load ptr, ptr %cond772.i, align 8
  %216 = load ptr, ptr %cond789.i, align 8
  %add.ptr.i.i = getelementptr inbounds %union.TString, ptr %215, i64 1
  %add.ptr1.i.i = getelementptr inbounds %union.TString, ptr %216, i64 1
  %call18.i.i = tail call i32 @strcoll(ptr noundef nonnull %add.ptr.i.i, ptr noundef nonnull %add.ptr1.i.i) #34
  %cmp.not19.i.i = icmp eq i32 %call18.i.i, 0
  br i1 %cmp.not19.i.i, label %if.else.preheader.i.i, label %l_strcmp.exit.i

if.else.preheader.i.i:                            ; preds = %if.then11.i
  %len2.i.i = getelementptr inbounds %struct.anon.0, ptr %216, i64 0, i32 5
  %217 = load i64, ptr %len2.i.i, align 8
  %len.i.i = getelementptr inbounds %struct.anon.0, ptr %215, i64 0, i32 5
  %218 = load i64, ptr %len.i.i, align 8
  br label %if.else.i19.i

if.else.i19.i:                                    ; preds = %if.end11.i.i, %if.else.preheader.i.i
  %lr.023.i.i = phi i64 [ %sub14.i.i, %if.end11.i.i ], [ %217, %if.else.preheader.i.i ]
  %r.022.i.i = phi ptr [ %add.ptr13.i.i, %if.end11.i.i ], [ %add.ptr1.i.i, %if.else.preheader.i.i ]
  %ll.021.i.i = phi i64 [ %sub.i.i, %if.end11.i.i ], [ %218, %if.else.preheader.i.i ]
  %l.020.i.i = phi ptr [ %add.ptr12.i.i, %if.end11.i.i ], [ %add.ptr.i.i, %if.else.preheader.i.i ]
  %call4.i.i = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %l.020.i.i) #34
  %cmp5.i.i = icmp eq i64 %call4.i.i, %lr.023.i.i
  br i1 %cmp5.i.i, label %if.then6.i.i, label %if.else8.i.i

if.then6.i.i:                                     ; preds = %if.else.i19.i
  %cmp7.i.i = icmp ne i64 %lr.023.i.i, %ll.021.i.i
  %cond.i.i = zext i1 %cmp7.i.i to i32
  br label %l_strcmp.exit.i

if.else8.i.i:                                     ; preds = %if.else.i19.i
  %cmp9.i.i = icmp eq i64 %call4.i.i, %ll.021.i.i
  br i1 %cmp9.i.i, label %l_strcmp.exit.i, label %if.end11.i.i

if.end11.i.i:                                     ; preds = %if.else8.i.i
  %inc.i.i = add i64 %call4.i.i, 1
  %add.ptr12.i.i = getelementptr inbounds i8, ptr %l.020.i.i, i64 %inc.i.i
  %sub.i.i = sub i64 %ll.021.i.i, %inc.i.i
  %add.ptr13.i.i = getelementptr inbounds i8, ptr %r.022.i.i, i64 %inc.i.i
  %sub14.i.i = sub i64 %lr.023.i.i, %inc.i.i
  %call.i.i = tail call i32 @strcoll(ptr noundef %add.ptr12.i.i, ptr noundef %add.ptr13.i.i) #34
  %cmp.not.i.i = icmp eq i32 %call.i.i, 0
  br i1 %cmp.not.i.i, label %if.else.i19.i, label %l_strcmp.exit.i

l_strcmp.exit.i:                                  ; preds = %if.end11.i.i, %if.else8.i.i, %if.then6.i.i, %if.then11.i
  %retval.0.i.i132 = phi i32 [ %cond.i.i, %if.then6.i.i ], [ %call18.i.i, %if.then11.i ], [ %call.i.i, %if.end11.i.i ], [ -1, %if.else8.i.i ]
  %cmp15.i = icmp slt i32 %retval.0.i.i132, 1
  %conv16.i = zext i1 %cmp15.i to i32
  br label %lessequal.exit

sw.bb.i458:                                       ; preds = %if.else.i131
  %219 = load ptr, ptr %cond772.i, align 8
  %metatable.i459 = getelementptr inbounds %struct.Table, ptr %219, i64 0, i32 5
  br label %sw.epilog.i432

sw.bb1.i430:                                      ; preds = %if.else.i131
  %220 = load ptr, ptr %cond772.i, align 8
  %metatable3.i431 = getelementptr inbounds %struct.anon.1, ptr %220, i64 0, i32 3
  br label %sw.epilog.i432

sw.default.i460:                                  ; preds = %if.else.i131
  %221 = load ptr, ptr %l_G.i467, align 8
  %idxprom.i462 = sext i32 %207 to i64
  %arrayidx.i463 = getelementptr inbounds %struct.global_State, ptr %221, i64 0, i32 23, i64 %idxprom.i462
  br label %sw.epilog.i432

sw.epilog.i432:                                   ; preds = %sw.default.i460, %sw.bb1.i430, %sw.bb.i458
  %mt.0.in.i433 = phi ptr [ %arrayidx.i463, %sw.default.i460 ], [ %metatable3.i431, %sw.bb1.i430 ], [ %metatable.i459, %sw.bb.i458 ]
  %mt.0.i434 = load ptr, ptr %mt.0.in.i433, align 8
  %tobool.not.i435 = icmp eq ptr %mt.0.i434, null
  br i1 %tobool.not.i435, label %luaT_gettmbyobj.exit464, label %cond.true.i436

cond.true.i436:                                   ; preds = %sw.epilog.i432
  %222 = load ptr, ptr %l_G.i467, align 8
  %arrayidx8.i438 = getelementptr inbounds %struct.global_State, ptr %222, i64 0, i32 24, i64 14
  %223 = load ptr, ptr %arrayidx8.i438, align 8
  %224 = getelementptr i8, ptr %mt.0.i434, i64 11
  %mt.0.val.i439 = load i8, ptr %224, align 1
  %225 = getelementptr i8, ptr %mt.0.i434, i64 32
  %mt.0.val6.i440 = load ptr, ptr %225, align 8
  %hash.i.i441 = getelementptr inbounds %struct.anon.0, ptr %223, i64 0, i32 4
  %226 = load i32, ptr %hash.i.i441, align 4
  %sh_prom.i.i442 = zext nneg i8 %mt.0.val.i439 to i64
  %notmask.i.i443 = shl nsw i64 -1, %sh_prom.i.i442
  %227 = trunc i64 %notmask.i.i443 to i32
  %228 = xor i32 %227, -1
  %conv2.i.i444 = and i32 %226, %228
  %idxprom.i.i445 = sext i32 %conv2.i.i444 to i64
  %arrayidx.i.i446 = getelementptr inbounds %struct.Node, ptr %mt.0.val6.i440, i64 %idxprom.i.i445
  br label %do.body.i.i447

do.body.i.i447:                                   ; preds = %if.else.i.i451, %cond.true.i436
  %n.0.i.i448 = phi ptr [ %arrayidx.i.i446, %cond.true.i436 ], [ %231, %if.else.i.i451 ]
  %tt.i.i449 = getelementptr inbounds %struct.Node, ptr %n.0.i.i448, i64 0, i32 1, i32 0, i32 1
  %229 = load i32, ptr %tt.i.i449, align 8
  %cmp.i.i450 = icmp eq i32 %229, 4
  br i1 %cmp.i.i450, label %land.lhs.true.i.i455, label %if.else.i.i451

land.lhs.true.i.i455:                             ; preds = %do.body.i.i447
  %i_key.i.i456 = getelementptr inbounds %struct.Node, ptr %n.0.i.i448, i64 0, i32 1
  %230 = load ptr, ptr %i_key.i.i456, align 8
  %cmp5.i.i457 = icmp eq ptr %230, %223
  br i1 %cmp5.i.i457, label %luaT_gettmbyobj.exit464, label %if.else.i.i451

if.else.i.i451:                                   ; preds = %land.lhs.true.i.i455, %do.body.i.i447
  %next.i.i452 = getelementptr inbounds %struct.Node, ptr %n.0.i.i448, i64 0, i32 1, i32 0, i32 2
  %231 = load ptr, ptr %next.i.i452, align 8
  %tobool.not.i.i453 = icmp eq ptr %231, null
  br i1 %tobool.not.i.i453, label %luaT_gettmbyobj.exit464, label %do.body.i.i447, !llvm.loop !29

luaT_gettmbyobj.exit464:                          ; preds = %land.lhs.true.i.i455, %if.else.i.i451, %sw.epilog.i432
  %cond.i454 = phi ptr [ @luaO_nilobject_, %sw.epilog.i432 ], [ @luaO_nilobject_, %if.else.i.i451 ], [ %n.0.i.i448, %land.lhs.true.i.i455 ]
  %tt.i21.i = getelementptr inbounds %struct.lua_TValue, ptr %cond.i454, i64 0, i32 1
  %232 = load i32, ptr %tt.i21.i, align 8
  %cmp.i22.i = icmp eq i32 %232, 0
  br i1 %cmp.i22.i, label %if.else22.i, label %if.end.i.i

if.end.i.i:                                       ; preds = %luaT_gettmbyobj.exit464
  switch i32 %207, label %sw.default.i424 [
    i32 5, label %sw.bb.i422
    i32 7, label %sw.bb1.i394
  ]

sw.bb.i422:                                       ; preds = %if.end.i.i
  %233 = load ptr, ptr %cond789.i, align 8
  %metatable.i423 = getelementptr inbounds %struct.Table, ptr %233, i64 0, i32 5
  br label %sw.epilog.i396

sw.bb1.i394:                                      ; preds = %if.end.i.i
  %234 = load ptr, ptr %cond789.i, align 8
  %metatable3.i395 = getelementptr inbounds %struct.anon.1, ptr %234, i64 0, i32 3
  br label %sw.epilog.i396

sw.default.i424:                                  ; preds = %if.end.i.i
  %235 = load ptr, ptr %l_G.i467, align 8
  %idxprom.i426 = sext i32 %207 to i64
  %arrayidx.i427 = getelementptr inbounds %struct.global_State, ptr %235, i64 0, i32 23, i64 %idxprom.i426
  br label %sw.epilog.i396

sw.epilog.i396:                                   ; preds = %sw.default.i424, %sw.bb1.i394, %sw.bb.i422
  %mt.0.in.i397 = phi ptr [ %arrayidx.i427, %sw.default.i424 ], [ %metatable3.i395, %sw.bb1.i394 ], [ %metatable.i423, %sw.bb.i422 ]
  %mt.0.i398 = load ptr, ptr %mt.0.in.i397, align 8
  %tobool.not.i399 = icmp eq ptr %mt.0.i398, null
  br i1 %tobool.not.i399, label %luaT_gettmbyobj.exit428, label %cond.true.i400

cond.true.i400:                                   ; preds = %sw.epilog.i396
  %236 = load ptr, ptr %l_G.i467, align 8
  %arrayidx8.i402 = getelementptr inbounds %struct.global_State, ptr %236, i64 0, i32 24, i64 14
  %237 = load ptr, ptr %arrayidx8.i402, align 8
  %238 = getelementptr i8, ptr %mt.0.i398, i64 11
  %mt.0.val.i403 = load i8, ptr %238, align 1
  %239 = getelementptr i8, ptr %mt.0.i398, i64 32
  %mt.0.val6.i404 = load ptr, ptr %239, align 8
  %hash.i.i405 = getelementptr inbounds %struct.anon.0, ptr %237, i64 0, i32 4
  %240 = load i32, ptr %hash.i.i405, align 4
  %sh_prom.i.i406 = zext nneg i8 %mt.0.val.i403 to i64
  %notmask.i.i407 = shl nsw i64 -1, %sh_prom.i.i406
  %241 = trunc i64 %notmask.i.i407 to i32
  %242 = xor i32 %241, -1
  %conv2.i.i408 = and i32 %240, %242
  %idxprom.i.i409 = sext i32 %conv2.i.i408 to i64
  %arrayidx.i.i410 = getelementptr inbounds %struct.Node, ptr %mt.0.val6.i404, i64 %idxprom.i.i409
  br label %do.body.i.i411

do.body.i.i411:                                   ; preds = %if.else.i.i415, %cond.true.i400
  %n.0.i.i412 = phi ptr [ %arrayidx.i.i410, %cond.true.i400 ], [ %245, %if.else.i.i415 ]
  %tt.i.i413 = getelementptr inbounds %struct.Node, ptr %n.0.i.i412, i64 0, i32 1, i32 0, i32 1
  %243 = load i32, ptr %tt.i.i413, align 8
  %cmp.i.i414 = icmp eq i32 %243, 4
  br i1 %cmp.i.i414, label %land.lhs.true.i.i419, label %if.else.i.i415

land.lhs.true.i.i419:                             ; preds = %do.body.i.i411
  %i_key.i.i420 = getelementptr inbounds %struct.Node, ptr %n.0.i.i412, i64 0, i32 1
  %244 = load ptr, ptr %i_key.i.i420, align 8
  %cmp5.i.i421 = icmp eq ptr %244, %237
  br i1 %cmp5.i.i421, label %luaT_gettmbyobj.exit428, label %if.else.i.i415

if.else.i.i415:                                   ; preds = %land.lhs.true.i.i419, %do.body.i.i411
  %next.i.i416 = getelementptr inbounds %struct.Node, ptr %n.0.i.i412, i64 0, i32 1, i32 0, i32 2
  %245 = load ptr, ptr %next.i.i416, align 8
  %tobool.not.i.i417 = icmp eq ptr %245, null
  br i1 %tobool.not.i.i417, label %luaT_gettmbyobj.exit428, label %do.body.i.i411, !llvm.loop !29

luaT_gettmbyobj.exit428:                          ; preds = %land.lhs.true.i.i419, %if.else.i.i415, %sw.epilog.i396
  %cond.i418 = phi ptr [ @luaO_nilobject_, %sw.epilog.i396 ], [ @luaO_nilobject_, %if.else.i.i415 ], [ %n.0.i.i412, %land.lhs.true.i.i419 ]
  %tt1.i379 = getelementptr inbounds %struct.lua_TValue, ptr %cond.i418, i64 0, i32 1
  %246 = load i32, ptr %tt1.i379, align 8
  %cmp.not.i380 = icmp eq i32 %232, %246
  br i1 %cmp.not.i380, label %if.else.i383, label %if.else22.i

if.else.i383:                                     ; preds = %luaT_gettmbyobj.exit428
  switch i32 %232, label %sw.default.i390 [
    i32 0, label %if.end4.i.i
    i32 3, label %luaO_rawequalObj.exit392
    i32 1, label %sw.bb6.i386
    i32 2, label %sw.bb11.i384
  ]

sw.bb6.i386:                                      ; preds = %if.else.i383
  %247 = load i32, ptr %cond.i454, align 8
  %248 = load i32, ptr %cond.i418, align 8
  %cmp9.i387 = icmp eq i32 %247, %248
  br i1 %cmp9.i387, label %if.end4.i.i, label %if.else22.i

sw.bb11.i384:                                     ; preds = %if.else.i383
  %249 = load ptr, ptr %cond.i454, align 8
  %250 = load ptr, ptr %cond.i418, align 8
  %cmp14.i385 = icmp eq ptr %249, %250
  br i1 %cmp14.i385, label %if.end4.i.i, label %if.else22.i

sw.default.i390:                                  ; preds = %if.else.i383
  %251 = load ptr, ptr %cond.i454, align 8
  %252 = load ptr, ptr %cond.i418, align 8
  %cmp18.i391 = icmp eq ptr %251, %252
  br i1 %cmp18.i391, label %if.end4.i.i, label %if.else22.i

luaO_rawequalObj.exit392:                         ; preds = %if.else.i383
  %253 = load double, ptr %cond.i454, align 8
  %254 = load double, ptr %cond.i418, align 8
  %cmp5.i389 = fcmp oeq double %253, %254
  br i1 %cmp5.i389, label %if.end4.i.i, label %if.else22.i

if.end4.i.i:                                      ; preds = %sw.bb6.i386, %sw.bb11.i384, %sw.default.i390, %if.else.i383, %luaO_rawequalObj.exit392
  %255 = load ptr, ptr %top1267.i, align 8
  %256 = load ptr, ptr %stack.i763, align 8
  %257 = load i64, ptr %cond.i454, align 8
  store i64 %257, ptr %255, align 8
  %258 = load i32, ptr %tt.i21.i, align 8
  %tt2.i766 = getelementptr inbounds %struct.lua_TValue, ptr %255, i64 0, i32 1
  store i32 %258, ptr %tt2.i766, align 8
  %259 = load ptr, ptr %top1267.i, align 8
  %add.ptr.i767 = getelementptr inbounds %struct.lua_TValue, ptr %259, i64 1
  %260 = load i64, ptr %cond772.i, align 8
  store i64 %260, ptr %add.ptr.i767, align 8
  %261 = load i32, ptr %tt.i126, align 8
  %tt9.i769 = getelementptr inbounds %struct.lua_TValue, ptr %259, i64 1, i32 1
  store i32 %261, ptr %tt9.i769, align 8
  %262 = load ptr, ptr %top1267.i, align 8
  %add.ptr13.i770 = getelementptr inbounds %struct.lua_TValue, ptr %262, i64 2
  %263 = load i64, ptr %cond789.i, align 8
  store i64 %263, ptr %add.ptr13.i770, align 8
  %264 = load i32, ptr %tt1.i, align 8
  %tt17.i772 = getelementptr inbounds %struct.lua_TValue, ptr %262, i64 2, i32 1
  store i32 %264, ptr %tt17.i772, align 8
  %265 = load ptr, ptr %stack_last.i, align 8
  %266 = load ptr, ptr %top1267.i, align 8
  %sub.ptr.lhs.cast19.i774 = ptrtoint ptr %265 to i64
  %sub.ptr.rhs.cast20.i775 = ptrtoint ptr %266 to i64
  %sub.ptr.sub21.i776 = sub i64 %sub.ptr.lhs.cast19.i774, %sub.ptr.rhs.cast20.i775
  %cmp.i777 = icmp slt i64 %sub.ptr.sub21.i776, 49
  br i1 %cmp.i777, label %if.then.i787, label %callTMres.exit793

if.then.i787:                                     ; preds = %if.end4.i.i
  %267 = load i32, ptr %stacksize.i, align 8
  %cmp.not.i.i789 = icmp slt i32 %267, 3
  %add.i.i790 = add nsw i32 %267, 3
  %mul.i.i791 = shl nuw nsw i32 %267, 1
  %add.i.sink.i792 = select i1 %cmp.not.i.i789, i32 %add.i.i790, i32 %mul.i.i791
  tail call fastcc void @luaD_reallocstack(ptr noundef nonnull %L, i32 noundef %add.i.sink.i792)
  %.pre988 = load ptr, ptr %top1267.i, align 8
  br label %callTMres.exit793

callTMres.exit793:                                ; preds = %if.end4.i.i, %if.then.i787
  %268 = phi ptr [ %266, %if.end4.i.i ], [ %.pre988, %if.then.i787 ]
  %sub.ptr.lhs.cast.i779 = ptrtoint ptr %255 to i64
  %sub.ptr.rhs.cast.i780 = ptrtoint ptr %256 to i64
  %sub.ptr.sub.i781 = sub i64 %sub.ptr.lhs.cast.i779, %sub.ptr.rhs.cast.i780
  %add.ptr23.i782 = getelementptr inbounds %struct.lua_TValue, ptr %268, i64 3
  store ptr %add.ptr23.i782, ptr %top1267.i, align 8
  tail call fastcc void @luaD_call(ptr noundef nonnull %L, ptr noundef %268, i32 noundef 1)
  %269 = load ptr, ptr %stack.i763, align 8
  %add.ptr27.i783 = getelementptr inbounds i8, ptr %269, i64 %sub.ptr.sub.i781
  %270 = load ptr, ptr %top1267.i, align 8
  %incdec.ptr.i784 = getelementptr inbounds %struct.lua_TValue, ptr %270, i64 -1
  store ptr %incdec.ptr.i784, ptr %top1267.i, align 8
  %271 = load i64, ptr %incdec.ptr.i784, align 8
  store i64 %271, ptr %add.ptr27.i783, align 8
  %tt34.i785 = getelementptr %struct.lua_TValue, ptr %270, i64 -1, i32 1
  %272 = load i32, ptr %tt34.i785, align 8
  %tt35.i786 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr27.i783, i64 0, i32 1
  store i32 %272, ptr %tt35.i786, align 8
  %273 = load ptr, ptr %top1267.i, align 8
  %tt6.i.i = getelementptr inbounds %struct.lua_TValue, ptr %273, i64 0, i32 1
  %274 = load i32, ptr %tt6.i.i, align 8
  switch i32 %274, label %lor.end.fold.split.i.i [
    i32 0, label %lessequal.exit
    i32 1, label %land.rhs.i.i
  ]

land.rhs.i.i:                                     ; preds = %callTMres.exit793
  %275 = load i32, ptr %273, align 8
  %cmp12.i.i = icmp ne i32 %275, 0
  %276 = zext i1 %cmp12.i.i to i32
  br label %lessequal.exit

lor.end.fold.split.i.i:                           ; preds = %callTMres.exit793
  br label %lessequal.exit

if.else22.i:                                      ; preds = %sw.bb6.i386, %sw.bb11.i384, %sw.default.i390, %luaT_gettmbyobj.exit428, %luaT_gettmbyobj.exit464, %luaO_rawequalObj.exit392
  switch i32 %207, label %sw.default.i373 [
    i32 5, label %sw.bb.i371
    i32 7, label %sw.bb1.i343
  ]

sw.bb.i371:                                       ; preds = %if.else22.i
  %277 = load ptr, ptr %cond789.i, align 8
  %metatable.i372 = getelementptr inbounds %struct.Table, ptr %277, i64 0, i32 5
  br label %sw.epilog.i345

sw.bb1.i343:                                      ; preds = %if.else22.i
  %278 = load ptr, ptr %cond789.i, align 8
  %metatable3.i344 = getelementptr inbounds %struct.anon.1, ptr %278, i64 0, i32 3
  br label %sw.epilog.i345

sw.default.i373:                                  ; preds = %if.else22.i
  %279 = load ptr, ptr %l_G.i467, align 8
  %idxprom.i375 = sext i32 %207 to i64
  %arrayidx.i376 = getelementptr inbounds %struct.global_State, ptr %279, i64 0, i32 23, i64 %idxprom.i375
  br label %sw.epilog.i345

sw.epilog.i345:                                   ; preds = %sw.default.i373, %sw.bb1.i343, %sw.bb.i371
  %mt.0.in.i346 = phi ptr [ %arrayidx.i376, %sw.default.i373 ], [ %metatable3.i344, %sw.bb1.i343 ], [ %metatable.i372, %sw.bb.i371 ]
  %mt.0.i347 = load ptr, ptr %mt.0.in.i346, align 8
  %tobool.not.i348 = icmp eq ptr %mt.0.i347, null
  br i1 %tobool.not.i348, label %luaT_gettmbyobj.exit377, label %cond.true.i349

cond.true.i349:                                   ; preds = %sw.epilog.i345
  %280 = load ptr, ptr %l_G.i467, align 8
  %arrayidx8.i351 = getelementptr inbounds %struct.global_State, ptr %280, i64 0, i32 24, i64 13
  %281 = load ptr, ptr %arrayidx8.i351, align 8
  %282 = getelementptr i8, ptr %mt.0.i347, i64 11
  %mt.0.val.i352 = load i8, ptr %282, align 1
  %283 = getelementptr i8, ptr %mt.0.i347, i64 32
  %mt.0.val6.i353 = load ptr, ptr %283, align 8
  %hash.i.i354 = getelementptr inbounds %struct.anon.0, ptr %281, i64 0, i32 4
  %284 = load i32, ptr %hash.i.i354, align 4
  %sh_prom.i.i355 = zext nneg i8 %mt.0.val.i352 to i64
  %notmask.i.i356 = shl nsw i64 -1, %sh_prom.i.i355
  %285 = trunc i64 %notmask.i.i356 to i32
  %286 = xor i32 %285, -1
  %conv2.i.i357 = and i32 %284, %286
  %idxprom.i.i358 = sext i32 %conv2.i.i357 to i64
  %arrayidx.i.i359 = getelementptr inbounds %struct.Node, ptr %mt.0.val6.i353, i64 %idxprom.i.i358
  br label %do.body.i.i360

do.body.i.i360:                                   ; preds = %if.else.i.i364, %cond.true.i349
  %n.0.i.i361 = phi ptr [ %arrayidx.i.i359, %cond.true.i349 ], [ %289, %if.else.i.i364 ]
  %tt.i.i362 = getelementptr inbounds %struct.Node, ptr %n.0.i.i361, i64 0, i32 1, i32 0, i32 1
  %287 = load i32, ptr %tt.i.i362, align 8
  %cmp.i.i363 = icmp eq i32 %287, 4
  br i1 %cmp.i.i363, label %land.lhs.true.i.i368, label %if.else.i.i364

land.lhs.true.i.i368:                             ; preds = %do.body.i.i360
  %i_key.i.i369 = getelementptr inbounds %struct.Node, ptr %n.0.i.i361, i64 0, i32 1
  %288 = load ptr, ptr %i_key.i.i369, align 8
  %cmp5.i.i370 = icmp eq ptr %288, %281
  br i1 %cmp5.i.i370, label %luaT_gettmbyobj.exit377, label %if.else.i.i364

if.else.i.i364:                                   ; preds = %land.lhs.true.i.i368, %do.body.i.i360
  %next.i.i365 = getelementptr inbounds %struct.Node, ptr %n.0.i.i361, i64 0, i32 1, i32 0, i32 2
  %289 = load ptr, ptr %next.i.i365, align 8
  %tobool.not.i.i366 = icmp eq ptr %289, null
  br i1 %tobool.not.i.i366, label %luaT_gettmbyobj.exit377, label %do.body.i.i360, !llvm.loop !29

luaT_gettmbyobj.exit377:                          ; preds = %land.lhs.true.i.i368, %if.else.i.i364, %sw.epilog.i345
  %cond.i367 = phi ptr [ @luaO_nilobject_, %sw.epilog.i345 ], [ @luaO_nilobject_, %if.else.i.i364 ], [ %n.0.i.i361, %land.lhs.true.i.i368 ]
  %tt.i25.i = getelementptr inbounds %struct.lua_TValue, ptr %cond.i367, i64 0, i32 1
  %290 = load i32, ptr %tt.i25.i, align 8
  %cmp.i26.i = icmp eq i32 %290, 0
  br i1 %cmp.i26.i, label %if.then.i50.i, label %if.end.i27.i

if.end.i27.i:                                     ; preds = %luaT_gettmbyobj.exit377
  switch i32 %207, label %sw.default.i338 [
    i32 5, label %sw.bb.i336
    i32 7, label %sw.bb1.i320
  ]

sw.bb.i336:                                       ; preds = %if.end.i27.i
  %291 = load ptr, ptr %cond772.i, align 8
  %metatable.i337 = getelementptr inbounds %struct.Table, ptr %291, i64 0, i32 5
  br label %sw.epilog.i321

sw.bb1.i320:                                      ; preds = %if.end.i27.i
  %292 = load ptr, ptr %cond772.i, align 8
  %metatable3.i = getelementptr inbounds %struct.anon.1, ptr %292, i64 0, i32 3
  br label %sw.epilog.i321

sw.default.i338:                                  ; preds = %if.end.i27.i
  %293 = load ptr, ptr %l_G.i467, align 8
  %idxprom.i340 = sext i32 %207 to i64
  %arrayidx.i341 = getelementptr inbounds %struct.global_State, ptr %293, i64 0, i32 23, i64 %idxprom.i340
  br label %sw.epilog.i321

sw.epilog.i321:                                   ; preds = %sw.default.i338, %sw.bb1.i320, %sw.bb.i336
  %mt.0.in.i = phi ptr [ %arrayidx.i341, %sw.default.i338 ], [ %metatable3.i, %sw.bb1.i320 ], [ %metatable.i337, %sw.bb.i336 ]
  %mt.0.i = load ptr, ptr %mt.0.in.i, align 8
  %tobool.not.i322 = icmp eq ptr %mt.0.i, null
  br i1 %tobool.not.i322, label %luaT_gettmbyobj.exit, label %cond.true.i

cond.true.i:                                      ; preds = %sw.epilog.i321
  %294 = load ptr, ptr %l_G.i467, align 8
  %arrayidx8.i = getelementptr inbounds %struct.global_State, ptr %294, i64 0, i32 24, i64 13
  %295 = load ptr, ptr %arrayidx8.i, align 8
  %296 = getelementptr i8, ptr %mt.0.i, i64 11
  %mt.0.val.i = load i8, ptr %296, align 1
  %297 = getelementptr i8, ptr %mt.0.i, i64 32
  %mt.0.val6.i = load ptr, ptr %297, align 8
  %hash.i.i = getelementptr inbounds %struct.anon.0, ptr %295, i64 0, i32 4
  %298 = load i32, ptr %hash.i.i, align 4
  %sh_prom.i.i = zext nneg i8 %mt.0.val.i to i64
  %notmask.i.i = shl nsw i64 -1, %sh_prom.i.i
  %299 = trunc i64 %notmask.i.i to i32
  %300 = xor i32 %299, -1
  %conv2.i.i = and i32 %298, %300
  %idxprom.i.i323 = sext i32 %conv2.i.i to i64
  %arrayidx.i.i324 = getelementptr inbounds %struct.Node, ptr %mt.0.val6.i, i64 %idxprom.i.i323
  br label %do.body.i.i325

do.body.i.i325:                                   ; preds = %if.else.i.i329, %cond.true.i
  %n.0.i.i326 = phi ptr [ %arrayidx.i.i324, %cond.true.i ], [ %303, %if.else.i.i329 ]
  %tt.i.i327 = getelementptr inbounds %struct.Node, ptr %n.0.i.i326, i64 0, i32 1, i32 0, i32 1
  %301 = load i32, ptr %tt.i.i327, align 8
  %cmp.i.i328 = icmp eq i32 %301, 4
  br i1 %cmp.i.i328, label %land.lhs.true.i.i333, label %if.else.i.i329

land.lhs.true.i.i333:                             ; preds = %do.body.i.i325
  %i_key.i.i334 = getelementptr inbounds %struct.Node, ptr %n.0.i.i326, i64 0, i32 1
  %302 = load ptr, ptr %i_key.i.i334, align 8
  %cmp5.i.i335 = icmp eq ptr %302, %295
  br i1 %cmp5.i.i335, label %luaT_gettmbyobj.exit, label %if.else.i.i329

if.else.i.i329:                                   ; preds = %land.lhs.true.i.i333, %do.body.i.i325
  %next.i.i330 = getelementptr inbounds %struct.Node, ptr %n.0.i.i326, i64 0, i32 1, i32 0, i32 2
  %303 = load ptr, ptr %next.i.i330, align 8
  %tobool.not.i.i331 = icmp eq ptr %303, null
  br i1 %tobool.not.i.i331, label %luaT_gettmbyobj.exit, label %do.body.i.i325, !llvm.loop !29

luaT_gettmbyobj.exit:                             ; preds = %land.lhs.true.i.i333, %if.else.i.i329, %sw.epilog.i321
  %cond.i332 = phi ptr [ @luaO_nilobject_, %sw.epilog.i321 ], [ @luaO_nilobject_, %if.else.i.i329 ], [ %n.0.i.i326, %land.lhs.true.i.i333 ]
  %tt1.i312 = getelementptr inbounds %struct.lua_TValue, ptr %cond.i332, i64 0, i32 1
  %304 = load i32, ptr %tt1.i312, align 8
  %cmp.not.i313 = icmp eq i32 %290, %304
  br i1 %cmp.not.i313, label %if.else.i315, label %if.then.i50.i

if.else.i315:                                     ; preds = %luaT_gettmbyobj.exit
  switch i32 %290, label %sw.default.i318 [
    i32 0, label %if.end4.i31.i
    i32 3, label %luaO_rawequalObj.exit
    i32 1, label %sw.bb6.i
    i32 2, label %sw.bb11.i
  ]

sw.bb6.i:                                         ; preds = %if.else.i315
  %305 = load i32, ptr %cond.i367, align 8
  %306 = load i32, ptr %cond.i332, align 8
  %cmp9.i = icmp eq i32 %305, %306
  br i1 %cmp9.i, label %if.end4.i31.i, label %if.then.i50.i

sw.bb11.i:                                        ; preds = %if.else.i315
  %307 = load ptr, ptr %cond.i367, align 8
  %308 = load ptr, ptr %cond.i332, align 8
  %cmp14.i = icmp eq ptr %307, %308
  br i1 %cmp14.i, label %if.end4.i31.i, label %if.then.i50.i

sw.default.i318:                                  ; preds = %if.else.i315
  %309 = load ptr, ptr %cond.i367, align 8
  %310 = load ptr, ptr %cond.i332, align 8
  %cmp18.i = icmp eq ptr %309, %310
  br i1 %cmp18.i, label %if.end4.i31.i, label %if.then.i50.i

luaO_rawequalObj.exit:                            ; preds = %if.else.i315
  %311 = load double, ptr %cond.i367, align 8
  %312 = load double, ptr %cond.i332, align 8
  %cmp5.i317 = fcmp oeq double %311, %312
  br i1 %cmp5.i317, label %if.end4.i31.i, label %if.then.i50.i

if.end4.i31.i:                                    ; preds = %sw.bb6.i, %sw.bb11.i, %sw.default.i318, %if.else.i315, %luaO_rawequalObj.exit
  %313 = load ptr, ptr %top1267.i, align 8
  %314 = load ptr, ptr %stack.i763, align 8
  %315 = load i64, ptr %cond.i367, align 8
  store i64 %315, ptr %313, align 8
  %316 = load i32, ptr %tt.i25.i, align 8
  %tt2.i797 = getelementptr inbounds %struct.lua_TValue, ptr %313, i64 0, i32 1
  store i32 %316, ptr %tt2.i797, align 8
  %317 = load ptr, ptr %top1267.i, align 8
  %add.ptr.i798 = getelementptr inbounds %struct.lua_TValue, ptr %317, i64 1
  %318 = load i64, ptr %cond789.i, align 8
  store i64 %318, ptr %add.ptr.i798, align 8
  %319 = load i32, ptr %tt1.i, align 8
  %tt9.i800 = getelementptr inbounds %struct.lua_TValue, ptr %317, i64 1, i32 1
  store i32 %319, ptr %tt9.i800, align 8
  %320 = load ptr, ptr %top1267.i, align 8
  %add.ptr13.i801 = getelementptr inbounds %struct.lua_TValue, ptr %320, i64 2
  %321 = load i64, ptr %cond772.i, align 8
  store i64 %321, ptr %add.ptr13.i801, align 8
  %322 = load i32, ptr %tt.i126, align 8
  %tt17.i803 = getelementptr inbounds %struct.lua_TValue, ptr %320, i64 2, i32 1
  store i32 %322, ptr %tt17.i803, align 8
  %323 = load ptr, ptr %stack_last.i, align 8
  %324 = load ptr, ptr %top1267.i, align 8
  %sub.ptr.lhs.cast19.i805 = ptrtoint ptr %323 to i64
  %sub.ptr.rhs.cast20.i806 = ptrtoint ptr %324 to i64
  %sub.ptr.sub21.i807 = sub i64 %sub.ptr.lhs.cast19.i805, %sub.ptr.rhs.cast20.i806
  %cmp.i808 = icmp slt i64 %sub.ptr.sub21.i807, 49
  br i1 %cmp.i808, label %if.then.i818, label %callTMres.exit824

if.then.i818:                                     ; preds = %if.end4.i31.i
  %325 = load i32, ptr %stacksize.i, align 8
  %cmp.not.i.i820 = icmp slt i32 %325, 3
  %add.i.i821 = add nsw i32 %325, 3
  %mul.i.i822 = shl nuw nsw i32 %325, 1
  %add.i.sink.i823 = select i1 %cmp.not.i.i820, i32 %add.i.i821, i32 %mul.i.i822
  tail call fastcc void @luaD_reallocstack(ptr noundef nonnull %L, i32 noundef %add.i.sink.i823)
  %.pre989 = load ptr, ptr %top1267.i, align 8
  br label %callTMres.exit824

callTMres.exit824:                                ; preds = %if.end4.i31.i, %if.then.i818
  %326 = phi ptr [ %324, %if.end4.i31.i ], [ %.pre989, %if.then.i818 ]
  %sub.ptr.lhs.cast.i810 = ptrtoint ptr %313 to i64
  %sub.ptr.rhs.cast.i811 = ptrtoint ptr %314 to i64
  %sub.ptr.sub.i812 = sub i64 %sub.ptr.lhs.cast.i810, %sub.ptr.rhs.cast.i811
  %add.ptr23.i813 = getelementptr inbounds %struct.lua_TValue, ptr %326, i64 3
  store ptr %add.ptr23.i813, ptr %top1267.i, align 8
  tail call fastcc void @luaD_call(ptr noundef nonnull %L, ptr noundef %326, i32 noundef 1)
  %327 = load ptr, ptr %stack.i763, align 8
  %add.ptr27.i814 = getelementptr inbounds i8, ptr %327, i64 %sub.ptr.sub.i812
  %328 = load ptr, ptr %top1267.i, align 8
  %incdec.ptr.i815 = getelementptr inbounds %struct.lua_TValue, ptr %328, i64 -1
  store ptr %incdec.ptr.i815, ptr %top1267.i, align 8
  %329 = load i64, ptr %incdec.ptr.i815, align 8
  store i64 %329, ptr %add.ptr27.i814, align 8
  %tt34.i816 = getelementptr %struct.lua_TValue, ptr %328, i64 -1, i32 1
  %330 = load i32, ptr %tt34.i816, align 8
  %tt35.i817 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr27.i814, i64 0, i32 1
  store i32 %330, ptr %tt35.i817, align 8
  %331 = load ptr, ptr %top1267.i, align 8
  %tt6.i33.i = getelementptr inbounds %struct.lua_TValue, ptr %331, i64 0, i32 1
  %332 = load i32, ptr %tt6.i33.i, align 8
  switch i32 %332, label %lor.end.fold.split.i37.i [
    i32 0, label %if.then26.i
    i32 1, label %land.rhs.i34.i
  ]

land.rhs.i34.i:                                   ; preds = %callTMres.exit824
  %333 = load i32, ptr %331, align 8
  %cmp12.i35.i = icmp ne i32 %333, 0
  %334 = zext i1 %cmp12.i35.i to i32
  br label %if.then26.i

lor.end.fold.split.i37.i:                         ; preds = %callTMres.exit824
  br label %if.then26.i

if.then26.i:                                      ; preds = %callTMres.exit824, %land.rhs.i34.i, %lor.end.fold.split.i37.i
  %retval.0.i36.i = phi i32 [ %332, %callTMres.exit824 ], [ %334, %land.rhs.i34.i ], [ 1, %lor.end.fold.split.i37.i ]
  %lnot.ext.i = xor i32 %retval.0.i36.i, 1
  br label %lessequal.exit

if.then.i50.i:                                    ; preds = %luaO_rawequalObj.exit, %luaT_gettmbyobj.exit377, %luaT_gettmbyobj.exit, %sw.default.i318, %sw.bb11.i, %sw.bb6.i
  %idxprom.i40.i = sext i32 %207 to i64
  %arrayidx.i41.i = getelementptr inbounds [11 x ptr], ptr @luaT_typenames, i64 0, i64 %idxprom.i40.i
  %335 = load ptr, ptr %arrayidx.i41.i, align 8
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef %L, ptr noundef nonnull @.str.43, ptr noundef nonnull %335)
  unreachable

lessequal.exit:                                   ; preds = %callTMres.exit793, %land.rhs.i.i, %lor.end.fold.split.i.i, %if.then4.i, %l_strcmp.exit.i, %if.then26.i
  %retval.0.i130 = phi i32 [ %conv.i134, %if.then4.i ], [ %conv16.i, %l_strcmp.exit.i ], [ %lnot.ext.i, %if.then26.i ], [ %274, %callTMres.exit793 ], [ %276, %land.rhs.i.i ], [ 1, %lor.end.fold.split.i.i ]
  %cmp793.i = icmp eq i32 %retval.0.i130, %and.i
  br i1 %cmp793.i, label %if.then795.i, label %if.end801.i

if.then795.i:                                     ; preds = %lessequal.exit
  %336 = load i32, ptr %incdec.ptr.i, align 4
  %shr796.i = lshr i32 %336, 14
  %337 = zext nneg i32 %shr796.i to i64
  %338 = getelementptr i32, ptr %incdec.ptr.i, i64 %337
  %add.ptr800.i = getelementptr i32, ptr %338, i64 -131071
  br label %if.end801.i

if.end801.i:                                      ; preds = %if.then795.i, %lessequal.exit
  %pc.4.i = phi ptr [ %add.ptr800.i, %if.then795.i ], [ %incdec.ptr.i, %lessequal.exit ]
  %339 = load ptr, ptr %base1.i, align 8
  %incdec.ptr803.i = getelementptr inbounds i32, ptr %pc.4.i, i64 1
  br label %for.cond.i.backedge

sw.bb804.i:                                       ; preds = %for.cond.i
  %tt805.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext.i, i32 1
  %340 = load i32, ptr %tt805.i, align 8
  switch i32 %340, label %lor.end818.fold.split.i [
    i32 0, label %lor.end818.i
    i32 1, label %land.rhs812.i
  ]

land.rhs812.i:                                    ; preds = %sw.bb804.i
  %341 = load i32, ptr %add.ptr.i, align 8
  %cmp814.i = icmp eq i32 %341, 0
  br label %lor.end818.i

lor.end818.fold.split.i:                          ; preds = %sw.bb804.i
  br label %lor.end818.i

lor.end818.i:                                     ; preds = %lor.end818.fold.split.i, %land.rhs812.i, %sw.bb804.i
  %342 = phi i1 [ true, %sw.bb804.i ], [ %cmp814.i, %land.rhs812.i ], [ false, %lor.end818.fold.split.i ]
  %lor.ext819.i = zext i1 %342 to i32
  %shr820.i = lshr i32 %14, 14
  %and821.i = and i32 %shr820.i, 511
  %cmp822.not.i = icmp eq i32 %and821.i, %lor.ext819.i
  br i1 %cmp822.not.i, label %if.end830.i, label %if.then824.i

if.then824.i:                                     ; preds = %lor.end818.i
  %343 = load i32, ptr %incdec.ptr.i, align 4
  %shr825.i = lshr i32 %343, 14
  %344 = zext nneg i32 %shr825.i to i64
  %345 = getelementptr i32, ptr %incdec.ptr.i, i64 %344
  %add.ptr829.i = getelementptr i32, ptr %345, i64 -131071
  br label %if.end830.i

if.end830.i:                                      ; preds = %if.then824.i, %lor.end818.i
  %pc.5.i = phi ptr [ %add.ptr829.i, %if.then824.i ], [ %incdec.ptr.i, %lor.end818.i ]
  %incdec.ptr831.i = getelementptr inbounds i32, ptr %pc.5.i, i64 1
  br label %for.cond.i.backedge

sw.bb832.i:                                       ; preds = %for.cond.i
  %shr834.i = lshr i32 %14, 23
  %idx.ext836.i = zext nneg i32 %shr834.i to i64
  %add.ptr837.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext836.i
  %tt838.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext836.i, i32 1
  %346 = load i32, ptr %tt838.i, align 8
  switch i32 %346, label %lor.end851.fold.split.i [
    i32 0, label %lor.end851.i
    i32 1, label %land.rhs845.i
  ]

land.rhs845.i:                                    ; preds = %sw.bb832.i
  %347 = load i32, ptr %add.ptr837.i, align 8
  %cmp847.i = icmp eq i32 %347, 0
  br label %lor.end851.i

lor.end851.fold.split.i:                          ; preds = %sw.bb832.i
  br label %lor.end851.i

lor.end851.i:                                     ; preds = %lor.end851.fold.split.i, %land.rhs845.i, %sw.bb832.i
  %348 = phi i1 [ true, %sw.bb832.i ], [ %cmp847.i, %land.rhs845.i ], [ false, %lor.end851.fold.split.i ]
  %lor.ext852.i = zext i1 %348 to i32
  %shr853.i = lshr i32 %14, 14
  %and854.i = and i32 %shr853.i, 511
  %cmp855.not.i = icmp eq i32 %and854.i, %lor.ext852.i
  br i1 %cmp855.not.i, label %if.end869.i, label %if.then857.i

if.then857.i:                                     ; preds = %lor.end851.i
  %349 = load i64, ptr %add.ptr837.i, align 8
  store i64 %349, ptr %add.ptr.i, align 8
  %tt863.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext.i, i32 1
  store i32 %346, ptr %tt863.i, align 8
  %350 = load i32, ptr %incdec.ptr.i, align 4
  %shr864.i = lshr i32 %350, 14
  %351 = zext nneg i32 %shr864.i to i64
  %352 = getelementptr i32, ptr %incdec.ptr.i, i64 %351
  %add.ptr868.i = getelementptr i32, ptr %352, i64 -131071
  br label %if.end869.i

if.end869.i:                                      ; preds = %if.then857.i, %lor.end851.i
  %pc.6.i = phi ptr [ %add.ptr868.i, %if.then857.i ], [ %incdec.ptr.i, %lor.end851.i ]
  %incdec.ptr870.i = getelementptr inbounds i32, ptr %pc.6.i, i64 1
  br label %for.cond.i.backedge

sw.bb871.i:                                       ; preds = %for.cond.i
  %shr875.i = lshr i32 %14, 14
  %and876.i = and i32 %shr875.i, 511
  %sub877.i = add nsw i32 %and876.i, -1
  %cmp878.not.i = icmp ult i32 %14, 8388608
  br i1 %cmp878.not.i, label %if.end883.i, label %if.then880.i

if.then880.i:                                     ; preds = %sw.bb871.i
  %shr873.i = lshr i32 %14, 23
  %idx.ext881.i = zext nneg i32 %shr873.i to i64
  %add.ptr882.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.i, i64 %idx.ext881.i
  store ptr %add.ptr882.i, ptr %top1267.i, align 8
  br label %if.end883.i

if.end883.i:                                      ; preds = %if.then880.i, %sw.bb871.i
  store ptr %incdec.ptr.i, ptr %savedpc.i, align 8
  %call885.i = tail call fastcc i32 @luaD_precall(ptr noundef %L, ptr noundef %add.ptr.i, i32 noundef %sub877.i), !range !30
  switch i32 %call885.i, label %luaV_execute.exit [
    i32 0, label %sw.bb886.i
    i32 1, label %sw.bb887.i
  ]

sw.bb886.i:                                       ; preds = %if.end883.i
  %inc.i = add nsw i32 %nexeccalls.addr.0.i.ph, 1
  br label %reentry.i.outer.backedge

sw.bb887.i:                                       ; preds = %if.end883.i
  %cmp888.not.i = icmp eq i32 %and876.i, 0
  br i1 %cmp888.not.i, label %if.end894.i, label %if.then890.i

if.then890.i:                                     ; preds = %sw.bb887.i
  %353 = load ptr, ptr %ci.i, align 8
  %top892.i = getelementptr inbounds %struct.CallInfo, ptr %353, i64 0, i32 2
  %354 = load ptr, ptr %top892.i, align 8
  store ptr %354, ptr %top1267.i, align 8
  br label %if.end894.i

if.end894.i:                                      ; preds = %if.then890.i, %sw.bb887.i
  %355 = load ptr, ptr %base1.i, align 8
  br label %for.cond.i.backedge

sw.bb897.i:                                       ; preds = %for.cond.i
  %cmp901.not.i = icmp ult i32 %14, 8388608
  br i1 %cmp901.not.i, label %if.end907.i, label %if.then903.i

if.then903.i:                                     ; preds = %sw.bb897.i
  %shr899.i = lshr i32 %14, 23
  %idx.ext904.i = zext nneg i32 %shr899.i to i64
  %add.ptr905.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.i, i64 %idx.ext904.i
  store ptr %add.ptr905.i, ptr %top1267.i, align 8
  br label %if.end907.i

if.end907.i:                                      ; preds = %if.then903.i, %sw.bb897.i
  store ptr %incdec.ptr.i, ptr %savedpc.i, align 8
  %call909.i = tail call fastcc i32 @luaD_precall(ptr noundef %L, ptr noundef %add.ptr.i, i32 noundef -1), !range !30
  switch i32 %call909.i, label %luaV_execute.exit [
    i32 0, label %sw.bb910.i
    i32 1, label %sw.bb954.i
  ]

sw.bb910.i:                                       ; preds = %if.end907.i
  %356 = load ptr, ptr %ci.i, align 8
  %add.ptr913.i = getelementptr inbounds %struct.CallInfo, ptr %356, i64 -1
  %func915.i = getelementptr %struct.CallInfo, ptr %356, i64 -1, i32 1
  %357 = load ptr, ptr %func915.i, align 8
  %func917.i = getelementptr inbounds %struct.CallInfo, ptr %356, i64 0, i32 1
  %358 = load ptr, ptr %func917.i, align 8
  %359 = load ptr, ptr %openupval.i259, align 8
  %tobool918.not.i = icmp eq ptr %359, null
  br i1 %tobool918.not.i, label %if.end921.i, label %if.then919.i

if.then919.i:                                     ; preds = %sw.bb910.i
  %360 = load ptr, ptr %add.ptr913.i, align 8
  tail call fastcc void @luaF_close(ptr noundef nonnull %L, ptr noundef %360)
  %.pre678 = load ptr, ptr %func915.i, align 8
  br label %if.end921.i

if.end921.i:                                      ; preds = %if.then919.i, %sw.bb910.i
  %361 = phi ptr [ %.pre678, %if.then919.i ], [ %357, %sw.bb910.i ]
  %362 = load ptr, ptr %356, align 8
  %sub.ptr.lhs.cast.i = ptrtoint ptr %362 to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %358 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %sub.ptr.div.i = ashr exact i64 %sub.ptr.sub.i, 4
  %add.ptr925.i = getelementptr inbounds %struct.lua_TValue, ptr %361, i64 %sub.ptr.div.i
  store ptr %add.ptr925.i, ptr %add.ptr913.i, align 8
  store ptr %add.ptr925.i, ptr %base1.i, align 8
  %363 = load ptr, ptr %top1267.i, align 8
  %cmp932.i614 = icmp ult ptr %358, %363
  br i1 %cmp932.i614, label %for.body.i, label %for.end.i

for.body.i:                                       ; preds = %if.end921.i, %for.body.i
  %indvars.iv675 = phi i64 [ %indvars.iv.next676, %for.body.i ], [ 0, %if.end921.i ]
  %add.ptr930.i617 = phi ptr [ %add.ptr930.i, %for.body.i ], [ %358, %if.end921.i ]
  %add.ptr939.i = getelementptr inbounds %struct.lua_TValue, ptr %357, i64 %indvars.iv675
  %364 = load i64, ptr %add.ptr930.i617, align 8
  store i64 %364, ptr %add.ptr939.i, align 8
  %tt942.i = getelementptr inbounds %struct.lua_TValue, ptr %358, i64 %indvars.iv675, i32 1
  %365 = load i32, ptr %tt942.i, align 8
  %tt943.i = getelementptr inbounds %struct.lua_TValue, ptr %357, i64 %indvars.iv675, i32 1
  store i32 %365, ptr %tt943.i, align 8
  %indvars.iv.next676 = add nuw nsw i64 %indvars.iv675, 1
  %add.ptr930.i = getelementptr inbounds %struct.lua_TValue, ptr %358, i64 %indvars.iv.next676
  %366 = load ptr, ptr %top1267.i, align 8
  %cmp932.i = icmp ult ptr %add.ptr930.i, %366
  br i1 %cmp932.i, label %for.body.i, label %for.end.i, !llvm.loop !32

for.end.i:                                        ; preds = %for.body.i, %if.end921.i
  %idx.ext929.i.lcssa = phi i64 [ 0, %if.end921.i ], [ %indvars.iv.next676, %for.body.i ]
  %add.ptr946.i = getelementptr inbounds %struct.lua_TValue, ptr %357, i64 %idx.ext929.i.lcssa
  store ptr %add.ptr946.i, ptr %top1267.i, align 8
  %top948.i = getelementptr %struct.CallInfo, ptr %356, i64 -1, i32 2
  store ptr %add.ptr946.i, ptr %top948.i, align 8
  %367 = load ptr, ptr %savedpc.i, align 8
  %savedpc950.i = getelementptr %struct.CallInfo, ptr %356, i64 -1, i32 3
  store ptr %367, ptr %savedpc950.i, align 8
  %tailcalls.i = getelementptr %struct.CallInfo, ptr %356, i64 -1, i32 5
  %368 = load i32, ptr %tailcalls.i, align 4
  %inc951.i = add nsw i32 %368, 1
  store i32 %inc951.i, ptr %tailcalls.i, align 4
  %369 = load ptr, ptr %ci.i, align 8
  %incdec.ptr953.i = getelementptr inbounds %struct.CallInfo, ptr %369, i64 -1
  store ptr %incdec.ptr953.i, ptr %ci.i, align 8
  br label %reentry.i

sw.bb954.i:                                       ; preds = %if.end907.i
  %370 = load ptr, ptr %base1.i, align 8
  br label %for.cond.i.backedge

sw.bb957.i:                                       ; preds = %for.cond.i
  %cmp961.not.i = icmp ult i32 %14, 8388608
  br i1 %cmp961.not.i, label %if.end968.i, label %if.then963.i

if.then963.i:                                     ; preds = %sw.bb957.i
  %shr959.i = lshr i32 %14, 23
  %idx.ext964.i = zext nneg i32 %shr959.i to i64
  %add.ptr965.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.i, i64 %idx.ext964.i
  %add.ptr966.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr965.i, i64 -1
  store ptr %add.ptr966.i, ptr %top1267.i, align 8
  br label %if.end968.i

if.end968.i:                                      ; preds = %if.then963.i, %sw.bb957.i
  %371 = load ptr, ptr %openupval.i259, align 8
  %tobool970.not.i = icmp eq ptr %371, null
  br i1 %tobool970.not.i, label %if.end972.i, label %if.then971.i

if.then971.i:                                     ; preds = %if.end968.i
  tail call fastcc void @luaF_close(ptr noundef nonnull %L, ptr noundef %base.0.i)
  br label %if.end972.i

if.end972.i:                                      ; preds = %if.then971.i, %if.end968.i
  store ptr %incdec.ptr.i, ptr %savedpc.i, align 8
  %372 = load ptr, ptr %ci.i, align 8
  %incdec.ptr.i137 = getelementptr inbounds %struct.CallInfo, ptr %372, i64 -1
  store ptr %incdec.ptr.i137, ptr %ci.i, align 8
  %func.i138 = getelementptr inbounds %struct.CallInfo, ptr %372, i64 0, i32 1
  %373 = load ptr, ptr %func.i138, align 8
  %nresults.i = getelementptr inbounds %struct.CallInfo, ptr %372, i64 0, i32 4
  %374 = load i32, ptr %nresults.i, align 8
  %375 = load ptr, ptr %incdec.ptr.i137, align 8
  store ptr %375, ptr %base1.i, align 8
  %savedpc.i139 = getelementptr %struct.CallInfo, ptr %372, i64 -1, i32 3
  %376 = load ptr, ptr %savedpc.i139, align 8
  store ptr %376, ptr %savedpc.i, align 8
  %cmp.not16.i = icmp eq i32 %374, 0
  br i1 %cmp.not16.i, label %luaD_poscall.exit.thread, label %land.rhs.i141

land.rhs.i141:                                    ; preds = %if.end972.i, %for.body.i145
  %firstResult.addr.019.i = phi ptr [ %incdec.ptr6.i, %for.body.i145 ], [ %add.ptr.i, %if.end972.i ]
  %res.018.i = phi ptr [ %incdec.ptr7.i, %for.body.i145 ], [ %373, %if.end972.i ]
  %i.017.i = phi i32 [ %dec.i147, %for.body.i145 ], [ %374, %if.end972.i ]
  %377 = load ptr, ptr %top1267.i, align 8
  %cmp5.i = icmp ult ptr %firstResult.addr.019.i, %377
  br i1 %cmp5.i, label %for.body.i145, label %for.end.i142

for.body.i145:                                    ; preds = %land.rhs.i141
  %incdec.ptr6.i = getelementptr inbounds %struct.lua_TValue, ptr %firstResult.addr.019.i, i64 1
  %incdec.ptr7.i = getelementptr inbounds %struct.lua_TValue, ptr %res.018.i, i64 1
  %378 = load i64, ptr %firstResult.addr.019.i, align 8
  store i64 %378, ptr %res.018.i, align 8
  %tt.i146 = getelementptr inbounds %struct.lua_TValue, ptr %firstResult.addr.019.i, i64 0, i32 1
  %379 = load i32, ptr %tt.i146, align 8
  %tt9.i = getelementptr inbounds %struct.lua_TValue, ptr %res.018.i, i64 0, i32 1
  store i32 %379, ptr %tt9.i, align 8
  %dec.i147 = add nsw i32 %i.017.i, -1
  %cmp.not.i148 = icmp eq i32 %dec.i147, 0
  br i1 %cmp.not.i148, label %luaD_poscall.exit, label %land.rhs.i141, !llvm.loop !33

for.end.i142:                                     ; preds = %land.rhs.i141
  %cmp1123.i = icmp sgt i32 %i.017.i, 0
  br i1 %cmp1123.i, label %while.body.i, label %luaD_poscall.exit

while.body.i:                                     ; preds = %for.end.i142, %while.body.i
  %res.125.i = phi ptr [ %incdec.ptr12.i, %while.body.i ], [ %res.018.i, %for.end.i142 ]
  %i.124.i = phi i32 [ %dec10.i, %while.body.i ], [ %i.017.i, %for.end.i142 ]
  %dec10.i = add nsw i32 %i.124.i, -1
  %incdec.ptr12.i = getelementptr inbounds %struct.lua_TValue, ptr %res.125.i, i64 1
  %tt13.i = getelementptr inbounds %struct.lua_TValue, ptr %res.125.i, i64 0, i32 1
  store i32 0, ptr %tt13.i, align 8
  %cmp11.i144 = icmp ugt i32 %i.124.i, 1
  br i1 %cmp11.i144, label %while.body.i, label %luaD_poscall.exit, !llvm.loop !34

luaD_poscall.exit:                                ; preds = %for.body.i145, %while.body.i, %for.end.i142
  %res.1.lcssa.i = phi ptr [ %res.018.i, %for.end.i142 ], [ %incdec.ptr12.i, %while.body.i ], [ %incdec.ptr7.i, %for.body.i145 ]
  store ptr %res.1.lcssa.i, ptr %top1267.i, align 8
  %dec.i = add nsw i32 %nexeccalls.addr.0.i.ph, -1
  %cmp975.i = icmp eq i32 %dec.i, 0
  br i1 %cmp975.i, label %luaV_execute.exit, label %if.else978.i

luaD_poscall.exit.thread:                         ; preds = %if.end972.i
  store ptr %373, ptr %top1267.i, align 8
  %dec.i681 = add nsw i32 %nexeccalls.addr.0.i.ph, -1
  %cmp975.i682 = icmp eq i32 %dec.i681, 0
  br i1 %cmp975.i682, label %luaV_execute.exit, label %if.then980.i

if.else978.i:                                     ; preds = %luaD_poscall.exit
  %tobool979.not.i = icmp eq i32 %374, -1
  br i1 %tobool979.not.i, label %reentry.i.outer.backedge, label %if.else978.i.if.then980.i_crit_edge

reentry.i.outer.backedge:                         ; preds = %if.else978.i, %if.then980.i, %sw.bb886.i
  %nexeccalls.addr.0.i.ph.be = phi i32 [ %inc.i, %sw.bb886.i ], [ %dec.i683686, %if.then980.i ], [ %dec.i, %if.else978.i ]
  br label %reentry.i.outer

if.else978.i.if.then980.i_crit_edge:              ; preds = %if.else978.i
  %.pre987 = load ptr, ptr %ci.i, align 8
  br label %if.then980.i

if.then980.i:                                     ; preds = %if.else978.i.if.then980.i_crit_edge, %luaD_poscall.exit.thread
  %380 = phi ptr [ %.pre987, %if.else978.i.if.then980.i_crit_edge ], [ %incdec.ptr.i137, %luaD_poscall.exit.thread ]
  %dec.i683686 = phi i32 [ %dec.i, %if.else978.i.if.then980.i_crit_edge ], [ %dec.i681, %luaD_poscall.exit.thread ]
  %top982.i = getelementptr inbounds %struct.CallInfo, ptr %380, i64 0, i32 2
  %381 = load ptr, ptr %top982.i, align 8
  store ptr %381, ptr %top1267.i, align 8
  br label %reentry.i.outer.backedge

sw.bb985.i:                                       ; preds = %for.cond.i
  %add.ptr986.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.i, i64 2
  %382 = load double, ptr %add.ptr986.i, align 8
  %383 = load double, ptr %add.ptr.i, align 8
  %add989.i = fadd double %382, %383
  %add.ptr990.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.i, i64 1
  %384 = load double, ptr %add.ptr990.i, align 8
  %cmp992.i = fcmp ogt double %382, 0.000000e+00
  br i1 %cmp992.i, label %cond.true994.i, label %cond.false997.i

cond.true994.i:                                   ; preds = %sw.bb985.i
  %cmp995.i = fcmp ugt double %add989.i, %384
  br i1 %cmp995.i, label %for.cond.i.backedge, label %if.then1000.i

cond.false997.i:                                  ; preds = %sw.bb985.i
  %cmp998.i = fcmp ugt double %384, %add989.i
  br i1 %cmp998.i, label %for.cond.i.backedge, label %if.then1000.i

if.then1000.i:                                    ; preds = %cond.false997.i, %cond.true994.i
  %shr1001.i = lshr i32 %14, 14
  %385 = zext nneg i32 %shr1001.i to i64
  %386 = getelementptr i32, ptr %incdec.ptr.i, i64 %385
  %add.ptr1005.i = getelementptr i32, ptr %386, i64 -131071
  store double %add989.i, ptr %add.ptr.i, align 8
  %tt1008.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext.i, i32 1
  store i32 3, ptr %tt1008.i, align 8
  %add.ptr1010.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.i, i64 3
  store double %add989.i, ptr %add.ptr1010.i, align 8
  %tt1012.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.i, i64 3, i32 1
  store i32 3, ptr %tt1012.i, align 8
  br label %for.cond.i.backedge

sw.bb1014.i:                                      ; preds = %for.cond.i
  %add.ptr1015.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.i, i64 1
  %add.ptr1016.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.i, i64 2
  store ptr %incdec.ptr.i, ptr %savedpc.i, align 8
  %tt1018.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext.i, i32 1
  %387 = load i32, ptr %tt1018.i, align 8
  switch i32 %387, label %if.then1024.i [
    i32 3, label %if.else1025.i
    i32 4, label %land.lhs.true.i150
  ]

land.lhs.true.i150:                               ; preds = %sw.bb1014.i
  %388 = load ptr, ptr %add.ptr.i, align 8
  %add.ptr.i151 = getelementptr inbounds %union.TString, ptr %388, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i)
  %call.i.i152 = call double @strtod(ptr noundef nonnull %add.ptr.i151, ptr noundef nonnull %endptr.i.i) #35
  %389 = load ptr, ptr %endptr.i.i, align 8
  %cmp.i.i153 = icmp eq ptr %389, %add.ptr.i151
  br i1 %cmp.i.i153, label %luaO_str2d.exit.thread.i, label %if.end.i.i154

luaO_str2d.exit.thread.i:                         ; preds = %land.lhs.true.i150
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i)
  br label %if.then1024.i

if.end.i.i154:                                    ; preds = %land.lhs.true.i150
  %390 = load i8, ptr %389, align 1
  switch i8 %390, label %if.end9.i.i [
    i8 120, label %if.then6.i.i155
    i8 88, label %if.then6.i.i155
  ]

if.then6.i.i155:                                  ; preds = %if.end.i.i154, %if.end.i.i154
  %call7.i.i = call i64 @strtoul(ptr noundef nonnull %add.ptr.i151, ptr noundef nonnull %endptr.i.i, i32 noundef 16) #35
  %conv8.i.i = uitofp i64 %call7.i.i to double
  %.pre.i.i = load ptr, ptr %endptr.i.i, align 8
  %.pre5.i.i = load i8, ptr %.pre.i.i, align 1
  br label %if.end9.i.i

if.end9.i.i:                                      ; preds = %if.then6.i.i155, %if.end.i.i154
  %num.0.i = phi double [ %call.i.i152, %if.end.i.i154 ], [ %conv8.i.i, %if.then6.i.i155 ]
  %391 = phi i8 [ %390, %if.end.i.i154 ], [ %.pre5.i.i, %if.then6.i.i155 ]
  %endptr.promoted.i.i = phi ptr [ %389, %if.end.i.i154 ], [ %.pre.i.i, %if.then6.i.i155 ]
  %cmp11.i.i = icmp eq i8 %391, 0
  br i1 %cmp11.i.i, label %luaO_str2d.exit.thread9.i, label %while.cond.preheader.i.i

luaO_str2d.exit.thread9.i:                        ; preds = %if.end9.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i)
  br label %if.then3.i

while.cond.preheader.i.i:                         ; preds = %if.end9.i.i
  %call15.i.i = tail call ptr @__ctype_b_loc() #39
  %392 = load ptr, ptr %call15.i.i, align 8
  br label %while.cond.i.i

while.cond.i.i:                                   ; preds = %while.cond.i.i, %while.cond.preheader.i.i
  %incdec.ptr4.i.i = phi ptr [ %endptr.promoted.i.i, %while.cond.preheader.i.i ], [ %incdec.ptr.i.i159, %while.cond.i.i ]
  %393 = load i8, ptr %incdec.ptr4.i.i, align 1
  %idxprom.i.i156 = zext i8 %393 to i64
  %arrayidx.i.i157 = getelementptr inbounds i16, ptr %392, i64 %idxprom.i.i156
  %394 = load i16, ptr %arrayidx.i.i157, align 2
  %395 = and i16 %394, 8192
  %tobool.not.i.i158 = icmp eq i16 %395, 0
  %incdec.ptr.i.i159 = getelementptr inbounds i8, ptr %incdec.ptr4.i.i, i64 1
  br i1 %tobool.not.i.i158, label %luaO_str2d.exit.i, label %while.cond.i.i, !llvm.loop !35

luaO_str2d.exit.i:                                ; preds = %while.cond.i.i
  %cmp19.not.i.not.i = icmp eq i8 %393, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i)
  br i1 %cmp19.not.i.not.i, label %if.then3.i, label %if.then1024.i

if.then3.i:                                       ; preds = %luaO_str2d.exit.i, %luaO_str2d.exit.thread9.i
  store double %num.0.i, ptr %add.ptr.i, align 8
  store i32 3, ptr %tt1018.i, align 8
  br label %if.else1025.i

if.then1024.i:                                    ; preds = %sw.bb1014.i, %luaO_str2d.exit.i, %luaO_str2d.exit.thread.i
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef %L, ptr noundef nonnull @.str.33)
  unreachable

if.else1025.i:                                    ; preds = %sw.bb1014.i, %if.then3.i
  %tt1026.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.i, i64 1, i32 1
  %396 = load i32, ptr %tt1026.i, align 8
  switch i32 %396, label %if.then1034.i [
    i32 3, label %if.else1035.i
    i32 4, label %land.lhs.true.i164
  ]

land.lhs.true.i164:                               ; preds = %if.else1025.i
  %397 = load ptr, ptr %add.ptr1015.i, align 8
  %add.ptr.i165 = getelementptr inbounds %union.TString, ptr %397, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i162)
  %call.i.i166 = call double @strtod(ptr noundef nonnull %add.ptr.i165, ptr noundef nonnull %endptr.i.i162) #35
  %398 = load ptr, ptr %endptr.i.i162, align 8
  %cmp.i.i167 = icmp eq ptr %398, %add.ptr.i165
  br i1 %cmp.i.i167, label %luaO_str2d.exit.thread.i193, label %if.end.i.i168

luaO_str2d.exit.thread.i193:                      ; preds = %land.lhs.true.i164
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i162)
  br label %if.then1034.i

if.end.i.i168:                                    ; preds = %land.lhs.true.i164
  %399 = load i8, ptr %398, align 1
  switch i8 %399, label %if.end9.i.i174 [
    i8 120, label %if.then6.i.i169
    i8 88, label %if.then6.i.i169
  ]

if.then6.i.i169:                                  ; preds = %if.end.i.i168, %if.end.i.i168
  %call7.i.i170 = call i64 @strtoul(ptr noundef nonnull %add.ptr.i165, ptr noundef nonnull %endptr.i.i162, i32 noundef 16) #35
  %conv8.i.i171 = uitofp i64 %call7.i.i170 to double
  %.pre.i.i172 = load ptr, ptr %endptr.i.i162, align 8
  %.pre5.i.i173 = load i8, ptr %.pre.i.i172, align 1
  br label %if.end9.i.i174

if.end9.i.i174:                                   ; preds = %if.then6.i.i169, %if.end.i.i168
  %num.0.i175 = phi double [ %call.i.i166, %if.end.i.i168 ], [ %conv8.i.i171, %if.then6.i.i169 ]
  %400 = phi i8 [ %399, %if.end.i.i168 ], [ %.pre5.i.i173, %if.then6.i.i169 ]
  %endptr.promoted.i.i176 = phi ptr [ %398, %if.end.i.i168 ], [ %.pre.i.i172, %if.then6.i.i169 ]
  %cmp11.i.i177 = icmp eq i8 %400, 0
  br i1 %cmp11.i.i177, label %luaO_str2d.exit.thread9.i192, label %while.cond.preheader.i.i178

luaO_str2d.exit.thread9.i192:                     ; preds = %if.end9.i.i174
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i162)
  br label %if.then3.i190

while.cond.preheader.i.i178:                      ; preds = %if.end9.i.i174
  %call15.i.i179 = tail call ptr @__ctype_b_loc() #39
  %401 = load ptr, ptr %call15.i.i179, align 8
  br label %while.cond.i.i180

while.cond.i.i180:                                ; preds = %while.cond.i.i180, %while.cond.preheader.i.i178
  %incdec.ptr4.i.i181 = phi ptr [ %endptr.promoted.i.i176, %while.cond.preheader.i.i178 ], [ %incdec.ptr.i.i185, %while.cond.i.i180 ]
  %402 = load i8, ptr %incdec.ptr4.i.i181, align 1
  %idxprom.i.i182 = zext i8 %402 to i64
  %arrayidx.i.i183 = getelementptr inbounds i16, ptr %401, i64 %idxprom.i.i182
  %403 = load i16, ptr %arrayidx.i.i183, align 2
  %404 = and i16 %403, 8192
  %tobool.not.i.i184 = icmp eq i16 %404, 0
  %incdec.ptr.i.i185 = getelementptr inbounds i8, ptr %incdec.ptr4.i.i181, i64 1
  br i1 %tobool.not.i.i184, label %luaO_str2d.exit.i186, label %while.cond.i.i180, !llvm.loop !35

luaO_str2d.exit.i186:                             ; preds = %while.cond.i.i180
  %cmp19.not.i.not.i187 = icmp eq i8 %402, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i162)
  br i1 %cmp19.not.i.not.i187, label %if.then3.i190, label %if.then1034.i

if.then3.i190:                                    ; preds = %luaO_str2d.exit.i186, %luaO_str2d.exit.thread9.i192
  store double %num.0.i175, ptr %add.ptr1015.i, align 8
  store i32 3, ptr %tt1026.i, align 8
  br label %if.else1035.i

if.then1034.i:                                    ; preds = %if.else1025.i, %luaO_str2d.exit.i186, %luaO_str2d.exit.thread.i193
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef %L, ptr noundef nonnull @.str.34)
  unreachable

if.else1035.i:                                    ; preds = %if.else1025.i, %if.then3.i190
  %tt1036.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.i, i64 2, i32 1
  %405 = load i32, ptr %tt1036.i, align 8
  switch i32 %405, label %if.then1044.i [
    i32 3, label %if.else1035.i.if.end1047.i_crit_edge
    i32 4, label %land.lhs.true.i197
  ]

if.else1035.i.if.end1047.i_crit_edge:             ; preds = %if.else1035.i
  %.pre986 = load double, ptr %add.ptr1016.i, align 8
  br label %if.end1047.i

land.lhs.true.i197:                               ; preds = %if.else1035.i
  %406 = load ptr, ptr %add.ptr1016.i, align 8
  %add.ptr.i198 = getelementptr inbounds %union.TString, ptr %406, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i195)
  %call.i.i199 = call double @strtod(ptr noundef nonnull %add.ptr.i198, ptr noundef nonnull %endptr.i.i195) #35
  %407 = load ptr, ptr %endptr.i.i195, align 8
  %cmp.i.i200 = icmp eq ptr %407, %add.ptr.i198
  br i1 %cmp.i.i200, label %luaO_str2d.exit.thread.i226, label %if.end.i.i201

luaO_str2d.exit.thread.i226:                      ; preds = %land.lhs.true.i197
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i195)
  br label %if.then1044.i

if.end.i.i201:                                    ; preds = %land.lhs.true.i197
  %408 = load i8, ptr %407, align 1
  switch i8 %408, label %if.end9.i.i207 [
    i8 120, label %if.then6.i.i202
    i8 88, label %if.then6.i.i202
  ]

if.then6.i.i202:                                  ; preds = %if.end.i.i201, %if.end.i.i201
  %call7.i.i203 = call i64 @strtoul(ptr noundef nonnull %add.ptr.i198, ptr noundef nonnull %endptr.i.i195, i32 noundef 16) #35
  %conv8.i.i204 = uitofp i64 %call7.i.i203 to double
  %.pre.i.i205 = load ptr, ptr %endptr.i.i195, align 8
  %.pre5.i.i206 = load i8, ptr %.pre.i.i205, align 1
  br label %if.end9.i.i207

if.end9.i.i207:                                   ; preds = %if.then6.i.i202, %if.end.i.i201
  %num.0.i208 = phi double [ %call.i.i199, %if.end.i.i201 ], [ %conv8.i.i204, %if.then6.i.i202 ]
  %409 = phi i8 [ %408, %if.end.i.i201 ], [ %.pre5.i.i206, %if.then6.i.i202 ]
  %endptr.promoted.i.i209 = phi ptr [ %407, %if.end.i.i201 ], [ %.pre.i.i205, %if.then6.i.i202 ]
  %cmp11.i.i210 = icmp eq i8 %409, 0
  br i1 %cmp11.i.i210, label %luaO_str2d.exit.thread9.i225, label %while.cond.preheader.i.i211

luaO_str2d.exit.thread9.i225:                     ; preds = %if.end9.i.i207
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i195)
  br label %if.then3.i223

while.cond.preheader.i.i211:                      ; preds = %if.end9.i.i207
  %call15.i.i212 = tail call ptr @__ctype_b_loc() #39
  %410 = load ptr, ptr %call15.i.i212, align 8
  br label %while.cond.i.i213

while.cond.i.i213:                                ; preds = %while.cond.i.i213, %while.cond.preheader.i.i211
  %incdec.ptr4.i.i214 = phi ptr [ %endptr.promoted.i.i209, %while.cond.preheader.i.i211 ], [ %incdec.ptr.i.i218, %while.cond.i.i213 ]
  %411 = load i8, ptr %incdec.ptr4.i.i214, align 1
  %idxprom.i.i215 = zext i8 %411 to i64
  %arrayidx.i.i216 = getelementptr inbounds i16, ptr %410, i64 %idxprom.i.i215
  %412 = load i16, ptr %arrayidx.i.i216, align 2
  %413 = and i16 %412, 8192
  %tobool.not.i.i217 = icmp eq i16 %413, 0
  %incdec.ptr.i.i218 = getelementptr inbounds i8, ptr %incdec.ptr4.i.i214, i64 1
  br i1 %tobool.not.i.i217, label %luaO_str2d.exit.i219, label %while.cond.i.i213, !llvm.loop !35

luaO_str2d.exit.i219:                             ; preds = %while.cond.i.i213
  %cmp19.not.i.not.i220 = icmp eq i8 %411, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i195)
  br i1 %cmp19.not.i.not.i220, label %if.then3.i223, label %if.then1044.i

if.then3.i223:                                    ; preds = %luaO_str2d.exit.i219, %luaO_str2d.exit.thread9.i225
  store double %num.0.i208, ptr %add.ptr1016.i, align 8
  store i32 3, ptr %tt1036.i, align 8
  br label %if.end1047.i

if.then1044.i:                                    ; preds = %luaO_str2d.exit.i219, %if.else1035.i, %luaO_str2d.exit.thread.i226
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef %L, ptr noundef nonnull @.str.35)
  unreachable

if.end1047.i:                                     ; preds = %if.else1035.i.if.end1047.i_crit_edge, %if.then3.i223
  %414 = phi double [ %.pre986, %if.else1035.i.if.end1047.i_crit_edge ], [ %num.0.i208, %if.then3.i223 ]
  %415 = load double, ptr %add.ptr.i, align 8
  %sub1051.i = fsub double %415, %414
  store double %sub1051.i, ptr %add.ptr.i, align 8
  store i32 3, ptr %tt1018.i, align 8
  %shr1054.i = lshr i32 %14, 14
  %416 = zext nneg i32 %shr1054.i to i64
  %417 = getelementptr i32, ptr %incdec.ptr.i, i64 %416
  %add.ptr1058.i = getelementptr i32, ptr %417, i64 -131071
  br label %for.cond.i.backedge

sw.bb1059.i:                                      ; preds = %for.cond.i
  %add.ptr1060.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.i, i64 3
  %add.ptr1062.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.i, i64 2
  %add.ptr1064.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.i, i64 5
  %418 = load i64, ptr %add.ptr1062.i, align 8
  store i64 %418, ptr %add.ptr1064.i, align 8
  %tt1067.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.i, i64 2, i32 1
  %419 = load i32, ptr %tt1067.i, align 8
  %tt1068.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.i, i64 5, i32 1
  store i32 %419, ptr %tt1068.i, align 8
  %add.ptr1070.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.i, i64 1
  %add.ptr1072.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.i, i64 4
  %420 = load i64, ptr %add.ptr1070.i, align 8
  store i64 %420, ptr %add.ptr1072.i, align 8
  %tt1075.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.i, i64 1, i32 1
  %421 = load i32, ptr %tt1075.i, align 8
  %tt1076.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.i, i64 4, i32 1
  store i32 %421, ptr %tt1076.i, align 8
  %422 = load i64, ptr %add.ptr.i, align 8
  store i64 %422, ptr %add.ptr1060.i, align 8
  %tt1081.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext.i, i32 1
  %423 = load i32, ptr %tt1081.i, align 8
  %tt1082.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.i, i64 3, i32 1
  store i32 %423, ptr %tt1082.i, align 8
  %add.ptr1083.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.i, i64 6
  store ptr %add.ptr1083.i, ptr %top1267.i, align 8
  store ptr %incdec.ptr.i, ptr %savedpc.i, align 8
  %shr1086.i = lshr i32 %14, 14
  %and1087.i = and i32 %shr1086.i, 511
  tail call fastcc void @luaD_call(ptr noundef %L, ptr noundef nonnull %add.ptr1060.i, i32 noundef %and1087.i)
  %424 = load ptr, ptr %base1.i, align 8
  %425 = load ptr, ptr %ci.i, align 8
  %top1090.i = getelementptr inbounds %struct.CallInfo, ptr %425, i64 0, i32 2
  %426 = load ptr, ptr %top1090.i, align 8
  store ptr %426, ptr %top1267.i, align 8
  %add.ptr1095.i = getelementptr inbounds %struct.lua_TValue, ptr %424, i64 %idx.ext.i
  %tt1097.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr1095.i, i64 3, i32 1
  %427 = load i32, ptr %tt1097.i, align 8
  %cmp1098.i = icmp eq i32 %427, 0
  br i1 %cmp1098.i, label %if.end1113.i, label %if.then1100.i

if.then1100.i:                                    ; preds = %sw.bb1059.i
  %add.ptr1096.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr1095.i, i64 3
  %add.ptr1103.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr1095.i, i64 2
  %428 = load i64, ptr %add.ptr1096.i, align 8
  store i64 %428, ptr %add.ptr1103.i, align 8
  %tt1107.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr1095.i, i64 2, i32 1
  store i32 %427, ptr %tt1107.i, align 8
  %429 = load i32, ptr %incdec.ptr.i, align 4
  %shr1108.i = lshr i32 %429, 14
  %430 = zext nneg i32 %shr1108.i to i64
  %431 = getelementptr i32, ptr %incdec.ptr.i, i64 %430
  %add.ptr1112.i = getelementptr i32, ptr %431, i64 -131071
  br label %if.end1113.i

if.end1113.i:                                     ; preds = %if.then1100.i, %sw.bb1059.i
  %pc.8.i = phi ptr [ %incdec.ptr.i, %sw.bb1059.i ], [ %add.ptr1112.i, %if.then1100.i ]
  %incdec.ptr1114.i = getelementptr inbounds i32, ptr %pc.8.i, i64 1
  br label %for.cond.i.backedge

sw.bb1115.i:                                      ; preds = %for.cond.i
  %shr1116.i = lshr i32 %14, 23
  %shr1119.i = lshr i32 %14, 14
  %and1120.i = and i32 %shr1119.i, 511
  %cmp1121.i = icmp ult i32 %14, 8388608
  br i1 %cmp1121.i, label %if.then1123.i, label %if.end1134.i

if.then1123.i:                                    ; preds = %sw.bb1115.i
  %432 = load ptr, ptr %top1267.i, align 8
  %sub.ptr.lhs.cast1125.i = ptrtoint ptr %432 to i64
  %sub.ptr.rhs.cast1126.i = ptrtoint ptr %add.ptr.i to i64
  %sub.ptr.sub1127.i = sub i64 %sub.ptr.lhs.cast1125.i, %sub.ptr.rhs.cast1126.i
  %sub.ptr.div1128.i = lshr exact i64 %sub.ptr.sub1127.i, 4
  %conv1129.i = trunc i64 %sub.ptr.div1128.i to i32
  %sub1130.i = add nsw i32 %conv1129.i, -1
  %433 = load ptr, ptr %ci.i, align 8
  %top1132.i = getelementptr inbounds %struct.CallInfo, ptr %433, i64 0, i32 2
  %434 = load ptr, ptr %top1132.i, align 8
  store ptr %434, ptr %top1267.i, align 8
  br label %if.end1134.i

if.end1134.i:                                     ; preds = %if.then1123.i, %sw.bb1115.i
  %n.0.i = phi i32 [ %sub1130.i, %if.then1123.i ], [ %shr1116.i, %sw.bb1115.i ]
  %cmp1135.i = icmp eq i32 %and1120.i, 0
  br i1 %cmp1135.i, label %if.then1137.i, label %if.end1139.i

if.then1137.i:                                    ; preds = %if.end1134.i
  %incdec.ptr1138.i = getelementptr inbounds i32, ptr %pc.0.i, i64 2
  %435 = load i32, ptr %incdec.ptr.i, align 4
  br label %if.end1139.i

if.end1139.i:                                     ; preds = %if.then1137.i, %if.end1134.i
  %c1118.0.i = phi i32 [ %435, %if.then1137.i ], [ %and1120.i, %if.end1134.i ]
  %pc.9.i = phi ptr [ %incdec.ptr1138.i, %if.then1137.i ], [ %incdec.ptr.i, %if.end1134.i ]
  %tt1140.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext.i, i32 1
  %436 = load i32, ptr %tt1140.i, align 8
  %cmp1141.i = icmp eq i32 %436, 5
  br i1 %cmp1141.i, label %if.end1144.i, label %for.cond.i.backedge

if.end1144.i:                                     ; preds = %if.end1139.i
  %437 = load ptr, ptr %add.ptr.i, align 8
  %438 = mul i32 %c1118.0.i, 50
  %mul1147.i = add i32 %n.0.i, -50
  %add1148.i = add i32 %mul1147.i, %438
  %sizearray.i = getelementptr inbounds %struct.Table, ptr %437, i64 0, i32 10
  %439 = load i32, ptr %sizearray.i, align 8
  %cmp1149.i = icmp sgt i32 %add1148.i, %439
  br i1 %cmp1149.i, label %if.then1151.i, label %if.end1152.i

if.then1151.i:                                    ; preds = %if.end1144.i
  %node.i = getelementptr inbounds %struct.Table, ptr %437, i64 0, i32 7
  %440 = load ptr, ptr %node.i, align 8
  %cmp.i228 = icmp eq ptr %440, @dummynode_
  br i1 %cmp.i228, label %luaH_resizearray.exit, label %cond.false.i

cond.false.i:                                     ; preds = %if.then1151.i
  %lsizenode.i = getelementptr inbounds %struct.Table, ptr %437, i64 0, i32 4
  %441 = load i8, ptr %lsizenode.i, align 1
  %sh_prom.i = zext nneg i8 %441 to i64
  %shl.i229 = shl nuw i64 1, %sh_prom.i
  %442 = trunc i64 %shl.i229 to i32
  br label %luaH_resizearray.exit

luaH_resizearray.exit:                            ; preds = %if.then1151.i, %cond.false.i
  %cond.i230 = phi i32 [ %442, %cond.false.i ], [ 0, %if.then1151.i ]
  tail call fastcc void @resize(ptr noundef %L, ptr noundef nonnull %437, i32 noundef %add1148.i, i32 noundef %cond.i230)
  br label %if.end1152.i

if.end1152.i:                                     ; preds = %luaH_resizearray.exit, %if.end1144.i
  %cmp1154.i611 = icmp sgt i32 %n.0.i, 0
  br i1 %cmp1154.i611, label %for.body1156.i.lr.ph, label %for.cond.i.backedge

for.body1156.i.lr.ph:                             ; preds = %if.end1152.i
  %node4.i.i.i = getelementptr inbounds %struct.Table, ptr %437, i64 0, i32 7
  %lsizenode.i.i.i = getelementptr inbounds %struct.Table, ptr %437, i64 0, i32 4
  %array.i.i = getelementptr inbounds %struct.Table, ptr %437, i64 0, i32 6
  %marked1177.i = getelementptr inbounds %struct.GCheader, ptr %437, i64 0, i32 2
  %gclist.i = getelementptr inbounds %struct.Table, ptr %437, i64 0, i32 9
  %443 = zext nneg i32 %n.0.i to i64
  br label %for.body1156.i

for.body1156.i:                                   ; preds = %for.body1156.i.lr.ph, %for.inc1183.i
  %indvars.iv672 = phi i64 [ %443, %for.body1156.i.lr.ph ], [ %indvars.iv.next673, %for.inc1183.i ]
  %last.0.i612 = phi i32 [ %add1148.i, %for.body1156.i.lr.ph ], [ %dec1161.i, %for.inc1183.i ]
  %add.ptr1158.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.i, i64 %indvars.iv672
  %dec1161.i = add i32 %last.0.i612, -1
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %k.i)
  %444 = load i32, ptr %sizearray.i, align 8
  %cmp.i.i232 = icmp ult i32 %dec1161.i, %444
  br i1 %cmp.i.i232, label %if.then.i.i244, label %if.else.i.i233

if.then.i.i244:                                   ; preds = %for.body1156.i
  %445 = load ptr, ptr %array.i.i, align 8
  %idxprom.i.i245 = sext i32 %dec1161.i to i64
  %arrayidx.i.i246 = getelementptr inbounds %struct.lua_TValue, ptr %445, i64 %idxprom.i.i245
  br label %luaH_getnum.exit.i

if.else.i.i233:                                   ; preds = %for.body1156.i
  %conv.i.i = sitofp i32 %last.0.i612 to double
  %cmp.i.i.i = icmp eq i32 %last.0.i612, 0
  br i1 %cmp.i.i.i, label %if.then.i.i.i, label %if.end.i.i.i

if.then.i.i.i:                                    ; preds = %if.else.i.i233
  %446 = load ptr, ptr %node4.i.i.i, align 8
  br label %do.body.i.i.preheader

if.end.i.i.i:                                     ; preds = %if.else.i.i233
  %447 = bitcast double %conv.i.i to i64
  %a.sroa.0.4.extract.shift.i.i.i = lshr i64 %447, 32
  %add.i.i.i = add i64 %a.sroa.0.4.extract.shift.i.i.i, %447
  %448 = load ptr, ptr %node4.i.i.i, align 8
  %conv.i.i.i = and i64 %add.i.i.i, 4294967295
  %449 = load i8, ptr %lsizenode.i.i.i, align 1
  %sh_prom.i.i.i = zext nneg i8 %449 to i64
  %notmask.i.i.i = shl nsw i64 -1, %sh_prom.i.i.i
  %sub.i.i.i = xor i64 %notmask.i.i.i, -1
  %or.i.i.i = or i64 %sub.i.i.i, 1
  %rem.i.i.i = urem i64 %conv.i.i.i, %or.i.i.i
  %arrayidx7.i.i.i = getelementptr inbounds %struct.Node, ptr %448, i64 %rem.i.i.i
  br label %do.body.i.i.preheader

do.body.i.i.preheader:                            ; preds = %if.end.i.i.i, %if.then.i.i.i
  %n.0.i.i.ph = phi ptr [ %arrayidx7.i.i.i, %if.end.i.i.i ], [ %446, %if.then.i.i.i ]
  br label %do.body.i.i

do.body.i.i:                                      ; preds = %do.body.i.i.preheader, %if.else8.i.i235
  %n.0.i.i = phi ptr [ %452, %if.else8.i.i235 ], [ %n.0.i.i.ph, %do.body.i.i.preheader ]
  %tt.i.i234 = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1, i32 0, i32 1
  %450 = load i32, ptr %tt.i.i234, align 8
  %cmp2.i.i = icmp eq i32 %450, 3
  br i1 %cmp2.i.i, label %land.lhs.true.i.i, label %if.else8.i.i235

land.lhs.true.i.i:                                ; preds = %do.body.i.i
  %i_key.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1
  %451 = load double, ptr %i_key.i.i, align 8
  %cmp5.i.i243 = fcmp oeq double %451, %conv.i.i
  br i1 %cmp5.i.i243, label %luaH_getnum.exit.i, label %if.else8.i.i235

if.else8.i.i235:                                  ; preds = %land.lhs.true.i.i, %do.body.i.i
  %next.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1, i32 0, i32 2
  %452 = load ptr, ptr %next.i.i, align 8
  %tobool.not.i.i236 = icmp eq ptr %452, null
  br i1 %tobool.not.i.i236, label %if.else.i240, label %do.body.i.i, !llvm.loop !7

luaH_getnum.exit.i:                               ; preds = %land.lhs.true.i.i, %if.then.i.i244
  %retval.0.i.i237 = phi ptr [ %arrayidx.i.i246, %if.then.i.i244 ], [ %n.0.i.i, %land.lhs.true.i.i ]
  %cmp.not.i238 = icmp eq ptr %retval.0.i.i237, @luaO_nilobject_
  br i1 %cmp.not.i238, label %luaH_getnum.exit.i.if.else.i240_crit_edge, label %luaH_setnum.exit

luaH_getnum.exit.i.if.else.i240_crit_edge:        ; preds = %luaH_getnum.exit.i
  %.pre679 = sitofp i32 %last.0.i612 to double
  br label %if.else.i240

if.else.i240:                                     ; preds = %if.else8.i.i235, %luaH_getnum.exit.i.if.else.i240_crit_edge
  %conv.i241.pre-phi = phi double [ %.pre679, %luaH_getnum.exit.i.if.else.i240_crit_edge ], [ %conv.i.i, %if.else8.i.i235 ]
  store double %conv.i241.pre-phi, ptr %k.i, align 8
  store i32 3, ptr %tt.i242, align 8
  %call1.i = call fastcc ptr @newkey(ptr noundef %L, ptr noundef %437, ptr noundef nonnull %k.i)
  br label %luaH_setnum.exit

luaH_setnum.exit:                                 ; preds = %luaH_getnum.exit.i, %if.else.i240
  %retval.0.i239 = phi ptr [ %call1.i, %if.else.i240 ], [ %retval.0.i.i237, %luaH_getnum.exit.i ]
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %k.i)
  %453 = load i64, ptr %add.ptr1158.i, align 8
  store i64 %453, ptr %retval.0.i239, align 8
  %tt1165.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.i, i64 %indvars.iv672, i32 1
  %454 = load i32, ptr %tt1165.i, align 8
  %tt1166.i = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i239, i64 0, i32 1
  store i32 %454, ptr %tt1166.i, align 8
  %cmp1168.i = icmp sgt i32 %454, 3
  br i1 %cmp1168.i, label %land.lhs.true1170.i, label %for.inc1183.i

land.lhs.true1170.i:                              ; preds = %luaH_setnum.exit
  %455 = load ptr, ptr %add.ptr1158.i, align 8
  %marked1172.i = getelementptr inbounds %struct.GCheader, ptr %455, i64 0, i32 2
  %456 = load i8, ptr %marked1172.i, align 1
  %457 = and i8 %456, 3
  %tobool1175.not.i = icmp eq i8 %457, 0
  br i1 %tobool1175.not.i, label %for.inc1183.i, label %land.lhs.true1176.i

land.lhs.true1176.i:                              ; preds = %land.lhs.true1170.i
  %458 = load i8, ptr %marked1177.i, align 1
  %459 = and i8 %458, 4
  %tobool1180.not.i = icmp eq i8 %459, 0
  br i1 %tobool1180.not.i, label %for.inc1183.i, label %if.then1181.i

if.then1181.i:                                    ; preds = %land.lhs.true1176.i
  %L.val.i = load ptr, ptr %l_G.i467, align 8
  %460 = and i8 %458, -5
  store i8 %460, ptr %marked1177.i, align 1
  %grayagain.i = getelementptr inbounds %struct.global_State, ptr %L.val.i, i64 0, i32 9
  %461 = load ptr, ptr %grayagain.i, align 8
  store ptr %461, ptr %gclist.i, align 8
  store ptr %437, ptr %grayagain.i, align 8
  br label %for.inc1183.i

for.inc1183.i:                                    ; preds = %if.then1181.i, %land.lhs.true1176.i, %land.lhs.true1170.i, %luaH_setnum.exit
  %indvars.iv.next673 = add nsw i64 %indvars.iv672, -1
  %cmp1154.i = icmp sgt i64 %indvars.iv672, 1
  br i1 %cmp1154.i, label %for.body1156.i, label %for.cond.i.backedge, !llvm.loop !36

sw.bb1186.i:                                      ; preds = %for.cond.i
  tail call fastcc void @luaF_close(ptr noundef %L, ptr noundef %add.ptr.i)
  br label %for.cond.i.backedge

sw.bb1187.i:                                      ; preds = %for.cond.i
  %462 = load ptr, ptr %p.i, align 8
  %p1190.i = getelementptr inbounds %struct.Proto, ptr %462, i64 0, i32 5
  %463 = load ptr, ptr %p1190.i, align 8
  %shr1191.i = lshr i32 %14, 14
  %idxprom1193.i = zext nneg i32 %shr1191.i to i64
  %arrayidx1194.i = getelementptr inbounds ptr, ptr %463, i64 %idxprom1193.i
  %464 = load ptr, ptr %arrayidx1194.i, align 8
  %nups.i = getelementptr inbounds %struct.Proto, ptr %464, i64 0, i32 19
  %465 = load i8, ptr %nups.i, align 8
  %conv1195.i = zext i8 %465 to i32
  %466 = load ptr, ptr %env1196.i, align 8
  %sub.i248 = shl nuw nsw i32 %conv1195.i, 3
  %add.i249 = add nuw nsw i32 %sub.i248, 40
  %conv2.i = zext nneg i32 %add.i249 to i64
  %467 = load ptr, ptr %l_G.i467, align 8
  %frealloc.i = getelementptr inbounds %struct.global_State, ptr %467, i64 0, i32 1
  %468 = load ptr, ptr %frealloc.i, align 8
  %ud.i = getelementptr inbounds %struct.global_State, ptr %467, i64 0, i32 2
  %469 = load ptr, ptr %ud.i, align 8
  %call.i468 = tail call ptr %468(ptr noundef %469, ptr noundef null, i64 noundef 0, i64 noundef %conv2.i) #35
  %cmp.i469 = icmp eq ptr %call.i468, null
  br i1 %cmp.i469, label %if.then.i473, label %luaM_realloc_.exit

if.then.i473:                                     ; preds = %sw.bb1187.i
  %errorJmp.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 26
  %470 = load ptr, ptr %errorJmp.i.i, align 8
  %tobool.not.i.i474 = icmp eq ptr %470, null
  br i1 %tobool.not.i.i474, label %if.else.i.i476, label %if.then.i.i475

if.then.i.i475:                                   ; preds = %if.then.i473
  %status.i.i = getelementptr inbounds %struct.lua_longjmp, ptr %470, i64 0, i32 2
  store volatile i32 4, ptr %status.i.i, align 8
  %471 = load ptr, ptr %errorJmp.i.i, align 8
  %b.i.i = getelementptr inbounds %struct.lua_longjmp, ptr %471, i64 0, i32 1
  tail call void @longjmp(ptr noundef nonnull %b.i.i, i32 noundef 1) #38
  unreachable

if.else.i.i476:                                   ; preds = %if.then.i473
  %status3.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 3
  store i8 4, ptr %status3.i.i, align 2
  %472 = load ptr, ptr %l_G.i467, align 8
  %panic.i.i = getelementptr inbounds %struct.global_State, ptr %472, i64 0, i32 19
  %473 = load ptr, ptr %panic.i.i, align 8
  %tobool4.not.i.i = icmp eq ptr %473, null
  br i1 %tobool4.not.i.i, label %if.end.i.i478, label %if.then5.i.i

if.then5.i.i:                                     ; preds = %if.else.i.i476
  tail call fastcc void @resetstack(ptr noundef nonnull %L, i32 noundef 4)
  %474 = load ptr, ptr %l_G.i467, align 8
  %panic7.i.i = getelementptr inbounds %struct.global_State, ptr %474, i64 0, i32 19
  %475 = load ptr, ptr %panic7.i.i, align 8
  %call.i.i477 = tail call i32 %475(ptr noundef nonnull %L) #35
  br label %if.end.i.i478

if.end.i.i478:                                    ; preds = %if.then5.i.i, %if.else.i.i476
  tail call void @exit(i32 noundef 1) #38
  unreachable

luaM_realloc_.exit:                               ; preds = %sw.bb1187.i
  %totalbytes.i471 = getelementptr inbounds %struct.global_State, ptr %467, i64 0, i32 14
  %476 = load i64, ptr %totalbytes.i471, align 8
  %add.i472 = add i64 %476, %conv2.i
  store i64 %add.i472, ptr %totalbytes.i471, align 8
  %L.val.i251 = load ptr, ptr %l_G.i467, align 8
  %rootgc.i = getelementptr inbounds %struct.global_State, ptr %L.val.i251, i64 0, i32 6
  %477 = load ptr, ptr %rootgc.i, align 8
  store ptr %477, ptr %call.i468, align 8
  store ptr %call.i468, ptr %rootgc.i, align 8
  %currentwhite.i465 = getelementptr inbounds %struct.global_State, ptr %L.val.i251, i64 0, i32 3
  %478 = load i8, ptr %currentwhite.i465, align 8
  %479 = and i8 %478, 3
  %marked.i466 = getelementptr inbounds %struct.GCheader, ptr %call.i468, i64 0, i32 2
  store i8 %479, ptr %marked.i466, align 1
  %tt3.i = getelementptr inbounds %struct.GCheader, ptr %call.i468, i64 0, i32 1
  store i8 6, ptr %tt3.i, align 8
  %isC.i = getelementptr inbounds %struct.LClosure, ptr %call.i468, i64 0, i32 3
  store i8 0, ptr %isC.i, align 2
  %env.i252 = getelementptr inbounds %struct.LClosure, ptr %call.i468, i64 0, i32 6
  store ptr %466, ptr %env.i252, align 8
  %nupvalues.i = getelementptr inbounds %struct.LClosure, ptr %call.i468, i64 0, i32 4
  store i8 %465, ptr %nupvalues.i, align 1
  %tobool.not.i253606 = icmp eq i8 %465, 0
  br i1 %tobool.not.i253606, label %luaF_newLclosure.exit.thread, label %for.body1202.i.preheader

luaF_newLclosure.exit.thread:                     ; preds = %luaM_realloc_.exit
  %p1198.i687 = getelementptr inbounds %struct.LClosure, ptr %call.i468, i64 0, i32 7
  store ptr %464, ptr %p1198.i687, align 8
  br label %for.end1229.i

for.body1202.i.preheader:                         ; preds = %luaM_realloc_.exit
  %scevgep = getelementptr i8, ptr %call.i468, i64 32
  %480 = zext i8 %465 to i64
  %481 = shl nuw nsw i64 %480, 3
  %482 = add nsw i32 %conv1195.i, -1
  %483 = zext i32 %482 to i64
  %484 = sub nsw i64 %480, %483
  %485 = shl nsw i64 %484, 3
  %scevgep663 = getelementptr i8, ptr %scevgep, i64 %485
  tail call void @llvm.memset.p0.i64(ptr align 8 %scevgep663, i8 0, i64 %481, i1 false)
  store ptr %464, ptr %scevgep, align 8
  br label %for.body1202.i

for.body1202.i:                                   ; preds = %for.body1202.i.preheader, %for.inc1226.i
  %indvars.iv667 = phi i64 [ 0, %for.body1202.i.preheader ], [ %indvars.iv.next668, %for.inc1226.i ]
  %pc.10.i610 = phi ptr [ %incdec.ptr.i, %for.body1202.i.preheader ], [ %incdec.ptr1228.i, %for.inc1226.i ]
  %486 = load i32, ptr %pc.10.i610, align 4
  %and1204.i = and i32 %486, 63
  %cmp1205.i = icmp eq i32 %and1204.i, 4
  %shr1209.i = lshr i32 %486, 23
  %idxprom1211.i = zext nneg i32 %shr1209.i to i64
  br i1 %cmp1205.i, label %if.then1207.i, label %if.else1216.i

if.then1207.i:                                    ; preds = %for.body1202.i
  %arrayidx1212.i = getelementptr inbounds %struct.LClosure, ptr %10, i64 0, i32 8, i64 %idxprom1211.i
  %487 = load ptr, ptr %arrayidx1212.i, align 8
  br label %for.inc1226.i

if.else1216.i:                                    ; preds = %for.body1202.i
  %add.ptr1220.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idxprom1211.i
  %488 = load ptr, ptr %l_G.i467, align 8
  br label %while.cond.i260

while.cond.i260:                                  ; preds = %while.body.i264, %if.else1216.i
  %pp.0.i = phi ptr [ %openupval.i259, %if.else1216.i ], [ %489, %while.body.i264 ]
  %489 = load ptr, ptr %pp.0.i, align 8
  %cmp.not.i261 = icmp eq ptr %489, null
  br i1 %cmp.not.i261, label %while.end.i, label %land.rhs.i262

land.rhs.i262:                                    ; preds = %while.cond.i260
  %v.i263 = getelementptr inbounds %struct.UpVal, ptr %489, i64 0, i32 3
  %490 = load ptr, ptr %v.i263, align 8
  %cmp1.not.i = icmp ult ptr %490, %add.ptr1220.i
  br i1 %cmp1.not.i, label %while.end.i, label %while.body.i264

while.body.i264:                                  ; preds = %land.rhs.i262
  %cmp3.i = icmp eq ptr %490, %add.ptr1220.i
  br i1 %cmp3.i, label %if.then.i265, label %while.cond.i260, !llvm.loop !37

if.then.i265:                                     ; preds = %while.body.i264
  %marked.i266 = getelementptr inbounds %struct.GCheader, ptr %489, i64 0, i32 2
  %491 = load i8, ptr %marked.i266, align 1
  %currentwhite.i267 = getelementptr inbounds %struct.global_State, ptr %488, i64 0, i32 3
  %492 = load i8, ptr %currentwhite.i267, align 8
  %493 = xor i8 %492, -1
  %and27.i = and i8 %491, 3
  %494 = and i8 %and27.i, %493
  %tobool.not.i268 = icmp eq i8 %494, 0
  br i1 %tobool.not.i268, label %for.inc1226.i, label %if.then6.i

if.then6.i:                                       ; preds = %if.then.i265
  %495 = xor i8 %491, 3
  store i8 %495, ptr %marked.i266, align 1
  br label %for.inc1226.i

while.end.i:                                      ; preds = %land.rhs.i262, %while.cond.i260
  %frealloc.i480 = getelementptr inbounds %struct.global_State, ptr %488, i64 0, i32 1
  %496 = load ptr, ptr %frealloc.i480, align 8
  %ud.i481 = getelementptr inbounds %struct.global_State, ptr %488, i64 0, i32 2
  %497 = load ptr, ptr %ud.i481, align 8
  %call.i482 = tail call ptr %496(ptr noundef %497, ptr noundef null, i64 noundef 0, i64 noundef 40) #35
  %cmp.i483 = icmp eq ptr %call.i482, null
  br i1 %cmp.i483, label %if.then.i487, label %luaM_realloc_.exit502

if.then.i487:                                     ; preds = %while.end.i
  %errorJmp.i.i488 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 26
  %498 = load ptr, ptr %errorJmp.i.i488, align 8
  %tobool.not.i.i489 = icmp eq ptr %498, null
  br i1 %tobool.not.i.i489, label %if.else.i.i493, label %if.then.i.i490

if.then.i.i490:                                   ; preds = %if.then.i487
  %status.i.i491 = getelementptr inbounds %struct.lua_longjmp, ptr %498, i64 0, i32 2
  store volatile i32 4, ptr %status.i.i491, align 8
  %499 = load ptr, ptr %errorJmp.i.i488, align 8
  %b.i.i492 = getelementptr inbounds %struct.lua_longjmp, ptr %499, i64 0, i32 1
  tail call void @longjmp(ptr noundef nonnull %b.i.i492, i32 noundef 1) #38
  unreachable

if.else.i.i493:                                   ; preds = %if.then.i487
  %status3.i.i494 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 3
  store i8 4, ptr %status3.i.i494, align 2
  %500 = load ptr, ptr %l_G.i467, align 8
  %panic.i.i496 = getelementptr inbounds %struct.global_State, ptr %500, i64 0, i32 19
  %501 = load ptr, ptr %panic.i.i496, align 8
  %tobool4.not.i.i497 = icmp eq ptr %501, null
  br i1 %tobool4.not.i.i497, label %if.end.i.i501, label %if.then5.i.i498

if.then5.i.i498:                                  ; preds = %if.else.i.i493
  tail call fastcc void @resetstack(ptr noundef nonnull %L, i32 noundef 4)
  %502 = load ptr, ptr %l_G.i467, align 8
  %panic7.i.i499 = getelementptr inbounds %struct.global_State, ptr %502, i64 0, i32 19
  %503 = load ptr, ptr %panic7.i.i499, align 8
  %call.i.i500 = tail call i32 %503(ptr noundef nonnull %L) #35
  br label %if.end.i.i501

if.end.i.i501:                                    ; preds = %if.then5.i.i498, %if.else.i.i493
  tail call void @exit(i32 noundef 1) #38
  unreachable

luaM_realloc_.exit502:                            ; preds = %while.end.i
  %totalbytes.i485 = getelementptr inbounds %struct.global_State, ptr %488, i64 0, i32 14
  %504 = load i64, ptr %totalbytes.i485, align 8
  %add.i486 = add i64 %504, 40
  store i64 %add.i486, ptr %totalbytes.i485, align 8
  %tt.i271 = getelementptr inbounds %struct.UpVal, ptr %call.i482, i64 0, i32 1
  store i8 10, ptr %tt.i271, align 8
  %currentwhite12.i = getelementptr inbounds %struct.global_State, ptr %488, i64 0, i32 3
  %505 = load i8, ptr %currentwhite12.i, align 8
  %506 = and i8 %505, 3
  %marked16.i = getelementptr inbounds %struct.UpVal, ptr %call.i482, i64 0, i32 2
  store i8 %506, ptr %marked16.i, align 1
  %v17.i = getelementptr inbounds %struct.UpVal, ptr %call.i482, i64 0, i32 3
  store ptr %add.ptr1220.i, ptr %v17.i, align 8
  %507 = load ptr, ptr %pp.0.i, align 8
  store ptr %507, ptr %call.i482, align 8
  store ptr %call.i482, ptr %pp.0.i, align 8
  %uvhead.i = getelementptr inbounds %struct.global_State, ptr %488, i64 0, i32 22
  %u.i = getelementptr inbounds %struct.UpVal, ptr %call.i482, i64 0, i32 4
  store ptr %uvhead.i, ptr %u.i, align 8
  %next21.i = getelementptr inbounds %struct.global_State, ptr %488, i64 0, i32 22, i32 4, i32 0, i32 1
  %508 = load ptr, ptr %next21.i, align 8
  %next23.i = getelementptr inbounds %struct.UpVal, ptr %call.i482, i64 0, i32 4, i32 0, i32 1
  store ptr %508, ptr %next23.i, align 8
  %u26.i = getelementptr inbounds %struct.UpVal, ptr %508, i64 0, i32 4
  store ptr %call.i482, ptr %u26.i, align 8
  store ptr %call.i482, ptr %next21.i, align 8
  br label %for.inc1226.i

for.inc1226.i:                                    ; preds = %luaM_realloc_.exit502, %if.then6.i, %if.then.i265, %if.then1207.i
  %retval.0.i269.sink = phi ptr [ %487, %if.then1207.i ], [ %call.i482, %luaM_realloc_.exit502 ], [ %489, %if.then6.i ], [ %489, %if.then.i265 ]
  %arrayidx1224.i = getelementptr inbounds %struct.LClosure, ptr %call.i468, i64 0, i32 8, i64 %indvars.iv667
  store ptr %retval.0.i269.sink, ptr %arrayidx1224.i, align 8
  %indvars.iv.next668 = add nuw nsw i64 %indvars.iv667, 1
  %incdec.ptr1228.i = getelementptr inbounds i32, ptr %pc.10.i610, i64 1
  %exitcond671.not = icmp eq i64 %indvars.iv.next668, %480
  br i1 %exitcond671.not, label %for.end1229.i, label %for.body1202.i, !llvm.loop !38

for.end1229.i:                                    ; preds = %for.inc1226.i, %luaF_newLclosure.exit.thread
  %pc.10.i.lcssa = phi ptr [ %incdec.ptr.i, %luaF_newLclosure.exit.thread ], [ %incdec.ptr1228.i, %for.inc1226.i ]
  store ptr %call.i468, ptr %add.ptr.i, align 8
  %tt1232.i = getelementptr inbounds %struct.lua_TValue, ptr %base.0.i, i64 %idx.ext.i, i32 1
  store i32 6, ptr %tt1232.i, align 8
  store ptr %pc.10.i.lcssa, ptr %savedpc.i, align 8
  %509 = load ptr, ptr %l_G.i467, align 8
  %totalbytes1235.i = getelementptr inbounds %struct.global_State, ptr %509, i64 0, i32 14
  %510 = load i64, ptr %totalbytes1235.i, align 8
  %GCthreshold1237.i = getelementptr inbounds %struct.global_State, ptr %509, i64 0, i32 13
  %511 = load i64, ptr %GCthreshold1237.i, align 8
  %cmp1238.not.i = icmp ult i64 %510, %511
  br i1 %cmp1238.not.i, label %if.end1241.i, label %if.then1240.i

if.then1240.i:                                    ; preds = %for.end1229.i
  %gcstepmul.i273 = getelementptr inbounds %struct.global_State, ptr %509, i64 0, i32 18
  %512 = load i32, ptr %gcstepmul.i273, align 4
  %mul.i274 = mul i32 %512, 10
  %conv.i275 = zext i32 %mul.i274 to i64
  %cmp.i276 = icmp eq i32 %mul.i274, 0
  %spec.store.select.i277 = select i1 %cmp.i276, i64 9223372036854775806, i64 %conv.i275
  %sub.i280 = sub i64 %510, %511
  %gcdept.i281 = getelementptr inbounds %struct.global_State, ptr %509, i64 0, i32 16
  %513 = load i64, ptr %gcdept.i281, align 8
  %add.i282 = add i64 %sub.i280, %513
  store i64 %add.i282, ptr %gcdept.i281, align 8
  %gcstate.i287 = getelementptr inbounds %struct.global_State, ptr %509, i64 0, i32 4
  br label %do.body.i283

do.body.i283:                                     ; preds = %do.body.i283, %if.then1240.i
  %lim.0.i284 = phi i64 [ %spec.store.select.i277, %if.then1240.i ], [ %sub2.i286, %do.body.i283 ]
  %call.i285 = tail call fastcc i64 @singlestep(ptr noundef %L)
  %sub2.i286 = sub nsw i64 %lim.0.i284, %call.i285
  %514 = load i8, ptr %gcstate.i287, align 1
  %cmp4.i288 = icmp ne i8 %514, 0
  %cmp8.i289 = icmp sgt i64 %sub2.i286, 0
  %or.cond.i290 = select i1 %cmp4.i288, i1 %cmp8.i289, i1 false
  br i1 %or.cond.i290, label %do.body.i283, label %do.end.i291, !llvm.loop !6

do.end.i291:                                      ; preds = %do.body.i283
  br i1 %cmp4.i288, label %if.then14.i298, label %if.else27.i292

if.then14.i298:                                   ; preds = %do.end.i291
  %515 = load i64, ptr %gcdept.i281, align 8
  %cmp16.i299 = icmp ult i64 %515, 1024
  br i1 %cmp16.i299, label %if.then18.i302, label %if.else.i300

if.then18.i302:                                   ; preds = %if.then14.i298
  %516 = load i64, ptr %totalbytes1235.i, align 8
  %add20.i303 = add i64 %516, 1024
  br label %if.end1241.i.sink.split

if.else.i300:                                     ; preds = %if.then14.i298
  %sub23.i301 = add i64 %515, -1024
  store i64 %sub23.i301, ptr %gcdept.i281, align 8
  %517 = load i64, ptr %totalbytes1235.i, align 8
  br label %if.end1241.i.sink.split

if.else27.i292:                                   ; preds = %do.end.i291
  %estimate.i293 = getelementptr inbounds %struct.global_State, ptr %509, i64 0, i32 15
  %518 = load i64, ptr %estimate.i293, align 8
  %div.i294 = udiv i64 %518, 100
  %gcpause.i295 = getelementptr inbounds %struct.global_State, ptr %509, i64 0, i32 17
  %519 = load i32, ptr %gcpause.i295, align 8
  %conv28.i296 = sext i32 %519 to i64
  %mul29.i297 = mul i64 %div.i294, %conv28.i296
  br label %if.end1241.i.sink.split

if.end1241.i.sink.split:                          ; preds = %if.then18.i302, %if.else.i300, %if.else27.i292
  %mul29.i297.sink = phi i64 [ %mul29.i297, %if.else27.i292 ], [ %517, %if.else.i300 ], [ %add20.i303, %if.then18.i302 ]
  store i64 %mul29.i297.sink, ptr %GCthreshold1237.i, align 8
  br label %if.end1241.i

if.end1241.i:                                     ; preds = %if.end1241.i.sink.split, %for.end1229.i
  %520 = load ptr, ptr %base1.i, align 8
  br label %for.cond.i.backedge

sw.bb1243.i:                                      ; preds = %for.cond.i
  %shr1245.i = lshr i32 %14, 23
  %sub1247.i = add nsw i32 %shr1245.i, -1
  %521 = load ptr, ptr %ci.i, align 8
  %522 = load ptr, ptr %521, align 8
  %func1253.i = getelementptr inbounds %struct.CallInfo, ptr %521, i64 0, i32 1
  %523 = load ptr, ptr %func1253.i, align 8
  %sub.ptr.lhs.cast1254.i = ptrtoint ptr %522 to i64
  %sub.ptr.rhs.cast1255.i = ptrtoint ptr %523 to i64
  %sub.ptr.sub1256.i = sub i64 %sub.ptr.lhs.cast1254.i, %sub.ptr.rhs.cast1255.i
  %sub.ptr.div1257.i = lshr exact i64 %sub.ptr.sub1256.i, 4
  %conv1258.i = trunc i64 %sub.ptr.div1257.i to i32
  %524 = load ptr, ptr %p.i, align 8
  %numparams.i = getelementptr inbounds %struct.Proto, ptr %524, i64 0, i32 20
  %525 = load i8, ptr %numparams.i, align 1
  %conv1260.i = zext i8 %525 to i32
  %526 = xor i32 %conv1260.i, -1
  %sub1262.i = add i32 %conv1258.i, %526
  %cmp1263.i = icmp ult i32 %14, 8388608
  br i1 %cmp1263.i, label %if.then1265.i, label %if.end1286.i

if.then1265.i:                                    ; preds = %sw.bb1243.i
  store ptr %incdec.ptr.i, ptr %savedpc.i, align 8
  %527 = load ptr, ptr %stack_last.i, align 8
  %528 = load ptr, ptr %top1267.i, align 8
  %sub.ptr.lhs.cast1268.i = ptrtoint ptr %527 to i64
  %sub.ptr.rhs.cast1269.i = ptrtoint ptr %528 to i64
  %sub.ptr.sub1270.i = sub i64 %sub.ptr.lhs.cast1268.i, %sub.ptr.rhs.cast1269.i
  %mul1271.i = shl nsw i32 %sub1262.i, 4
  %conv1272.i = sext i32 %mul1271.i to i64
  %cmp1273.not.i = icmp sgt i64 %sub.ptr.sub1270.i, %conv1272.i
  br i1 %cmp1273.not.i, label %if.end1277.i, label %if.then1275.i

if.then1275.i:                                    ; preds = %if.then1265.i
  %529 = load i32, ptr %stacksize.i, align 8
  %cmp.not.i305 = icmp slt i32 %529, %sub1262.i
  %add.i310 = add nsw i32 %529, %sub1262.i
  %mul.i307 = shl nsw i32 %529, 1
  %add.i310.sink = select i1 %cmp.not.i305, i32 %add.i310, i32 %mul.i307
  tail call fastcc void @luaD_reallocstack(ptr noundef nonnull %L, i32 noundef %add.i310.sink)
  br label %if.end1277.i

if.end1277.i:                                     ; preds = %if.then1275.i, %if.then1265.i
  %530 = load ptr, ptr %base1.i, align 8
  %add.ptr1282.i = getelementptr inbounds %struct.lua_TValue, ptr %530, i64 %idx.ext.i
  %idx.ext1283.i = sext i32 %sub1262.i to i64
  %add.ptr1284.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr1282.i, i64 %idx.ext1283.i
  store ptr %add.ptr1284.i, ptr %top1267.i, align 8
  br label %if.end1286.i

if.end1286.i:                                     ; preds = %if.end1277.i, %sw.bb1243.i
  %b1244.0.i = phi i32 [ %sub1262.i, %if.end1277.i ], [ %sub1247.i, %sw.bb1243.i ]
  %ra.0.i = phi ptr [ %add.ptr1282.i, %if.end1277.i ], [ %add.ptr.i, %sw.bb1243.i ]
  %base.9.i = phi ptr [ %530, %if.end1277.i ], [ %base.0.i, %sw.bb1243.i ]
  %cmp1288.i604 = icmp sgt i32 %b1244.0.i, 0
  br i1 %cmp1288.i604, label %for.body1290.i.lr.ph, label %for.cond.i.backedge

for.body1290.i.lr.ph:                             ; preds = %if.end1286.i
  %idx.ext1296.i = sext i32 %sub1262.i to i64
  %idx.neg.i = sub nsw i64 0, %idx.ext1296.i
  %wide.trip.count = zext nneg i32 %b1244.0.i to i64
  br label %for.body1290.i

for.body1290.i:                                   ; preds = %for.body1290.i.lr.ph, %for.inc1312.i
  %indvars.iv = phi i64 [ 0, %for.body1290.i.lr.ph ], [ %indvars.iv.next, %for.inc1312.i ]
  %cmp1291.i = icmp slt i64 %indvars.iv, %idx.ext1296.i
  br i1 %cmp1291.i, label %if.then1293.i, label %for.inc1312.i

if.then1293.i:                                    ; preds = %for.body1290.i
  %531 = load ptr, ptr %521, align 8
  %add.ptr1297.i = getelementptr inbounds %struct.lua_TValue, ptr %531, i64 %idx.neg.i
  %add.ptr1299.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr1297.i, i64 %indvars.iv
  %add.ptr1302.i = getelementptr inbounds %struct.lua_TValue, ptr %ra.0.i, i64 %indvars.iv
  %532 = load i64, ptr %add.ptr1299.i, align 8
  store i64 %532, ptr %add.ptr1302.i, align 8
  %tt1305.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr1297.i, i64 %indvars.iv, i32 1
  %533 = load i32, ptr %tt1305.i, align 8
  br label %for.inc1312.i

for.inc1312.i:                                    ; preds = %for.body1290.i, %if.then1293.i
  %.sink = phi i32 [ %533, %if.then1293.i ], [ 0, %for.body1290.i ]
  %534 = getelementptr inbounds %struct.lua_TValue, ptr %ra.0.i, i64 %indvars.iv, i32 1
  store i32 %.sink, ptr %534, align 8
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.cond.i.backedge, label %for.body1290.i, !llvm.loop !39

luaV_execute.exit:                                ; preds = %luaD_poscall.exit, %luaD_poscall.exit.thread, %if.end883.i, %if.end907.i
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %g.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %g79.i)
  br label %if.end17

if.end17:                                         ; preds = %luaV_execute.exit, %if.end13
  %535 = load i16, ptr %nCcalls, align 8
  %dec = add i16 %535, -1
  store i16 %dec, ptr %nCcalls, align 8
  %l_G = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %536 = load ptr, ptr %l_G, align 8
  %totalbytes = getelementptr inbounds %struct.global_State, ptr %536, i64 0, i32 14
  %537 = load i64, ptr %totalbytes, align 8
  %GCthreshold = getelementptr inbounds %struct.global_State, ptr %536, i64 0, i32 13
  %538 = load i64, ptr %GCthreshold, align 8
  %cmp20.not = icmp ult i64 %537, %538
  br i1 %cmp20.not, label %if.end23, label %if.then22

if.then22:                                        ; preds = %if.end17
  %gcstepmul.i = getelementptr inbounds %struct.global_State, ptr %536, i64 0, i32 18
  %539 = load i32, ptr %gcstepmul.i, align 4
  %mul.i16 = mul i32 %539, 10
  %conv.i = zext i32 %mul.i16 to i64
  %cmp.i = icmp eq i32 %mul.i16, 0
  %spec.store.select.i = select i1 %cmp.i, i64 9223372036854775806, i64 %conv.i
  %sub.i19 = sub i64 %537, %538
  %gcdept.i = getelementptr inbounds %struct.global_State, ptr %536, i64 0, i32 16
  %540 = load i64, ptr %gcdept.i, align 8
  %add.i20 = add i64 %sub.i19, %540
  store i64 %add.i20, ptr %gcdept.i, align 8
  %gcstate.i = getelementptr inbounds %struct.global_State, ptr %536, i64 0, i32 4
  br label %do.body.i21

do.body.i21:                                      ; preds = %do.body.i21, %if.then22
  %lim.0.i = phi i64 [ %spec.store.select.i, %if.then22 ], [ %sub2.i, %do.body.i21 ]
  %call.i22 = tail call fastcc i64 @singlestep(ptr noundef %L)
  %sub2.i = sub nsw i64 %lim.0.i, %call.i22
  %541 = load i8, ptr %gcstate.i, align 1
  %cmp4.i = icmp ne i8 %541, 0
  %cmp8.i = icmp sgt i64 %sub2.i, 0
  %or.cond.i = select i1 %cmp4.i, i1 %cmp8.i, i1 false
  br i1 %or.cond.i, label %do.body.i21, label %do.end.i, !llvm.loop !6

do.end.i:                                         ; preds = %do.body.i21
  br i1 %cmp4.i, label %if.then14.i, label %if.else27.i

if.then14.i:                                      ; preds = %do.end.i
  %542 = load i64, ptr %gcdept.i, align 8
  %cmp16.i = icmp ult i64 %542, 1024
  br i1 %cmp16.i, label %if.then18.i, label %if.else.i24

if.then18.i:                                      ; preds = %if.then14.i
  %543 = load i64, ptr %totalbytes, align 8
  %add20.i = add i64 %543, 1024
  br label %if.end23.sink.split

if.else.i24:                                      ; preds = %if.then14.i
  %sub23.i = add i64 %542, -1024
  store i64 %sub23.i, ptr %gcdept.i, align 8
  %544 = load i64, ptr %totalbytes, align 8
  br label %if.end23.sink.split

if.else27.i:                                      ; preds = %do.end.i
  %estimate.i = getelementptr inbounds %struct.global_State, ptr %536, i64 0, i32 15
  %545 = load i64, ptr %estimate.i, align 8
  %div.i23 = udiv i64 %545, 100
  %gcpause.i = getelementptr inbounds %struct.global_State, ptr %536, i64 0, i32 17
  %546 = load i32, ptr %gcpause.i, align 8
  %conv28.i = sext i32 %546 to i64
  %mul29.i = mul i64 %div.i23, %conv28.i
  br label %if.end23.sink.split

if.end23.sink.split:                              ; preds = %if.then18.i, %if.else.i24, %if.else27.i
  %mul29.i.sink = phi i64 [ %mul29.i, %if.else27.i ], [ %544, %if.else.i24 ], [ %add20.i, %if.then18.i ]
  store i64 %mul29.i.sink, ptr %GCthreshold, align 8
  br label %if.end23

if.end23:                                         ; preds = %if.end23.sink.split, %if.end17
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @luaD_precall(ptr noundef %L, ptr noundef %func, i32 noundef %nresults) unnamed_addr #0 {
entry:
  %tt = getelementptr inbounds %struct.lua_TValue, ptr %func, i64 0, i32 1
  %0 = load i32, ptr %tt, align 8
  switch i32 %0, label %sw.default.i.i [
    i32 6, label %entry.if.end_crit_edge
    i32 5, label %sw.bb.i.i
    i32 7, label %sw.bb1.i.i
  ]

entry.if.end_crit_edge:                           ; preds = %entry
  %.pre107 = load ptr, ptr %func, align 8
  br label %if.end

sw.bb.i.i:                                        ; preds = %entry
  %1 = load ptr, ptr %func, align 8
  %metatable.i.i = getelementptr inbounds %struct.Table, ptr %1, i64 0, i32 5
  br label %sw.epilog.i.i

sw.bb1.i.i:                                       ; preds = %entry
  %2 = load ptr, ptr %func, align 8
  %metatable3.i.i = getelementptr inbounds %struct.anon.1, ptr %2, i64 0, i32 3
  br label %sw.epilog.i.i

sw.default.i.i:                                   ; preds = %entry
  %l_G.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %3 = load ptr, ptr %l_G.i.i, align 8
  %idxprom.i.i = sext i32 %0 to i64
  %arrayidx.i.i = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 23, i64 %idxprom.i.i
  br label %sw.epilog.i.i

sw.epilog.i.i:                                    ; preds = %sw.default.i.i, %sw.bb1.i.i, %sw.bb.i.i
  %mt.0.in.i.i = phi ptr [ %arrayidx.i.i, %sw.default.i.i ], [ %metatable3.i.i, %sw.bb1.i.i ], [ %metatable.i.i, %sw.bb.i.i ]
  %mt.0.i.i = load ptr, ptr %mt.0.in.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %mt.0.i.i, null
  br i1 %tobool.not.i.i, label %luaT_gettmbyobj.exit.i, label %cond.true.i.i

cond.true.i.i:                                    ; preds = %sw.epilog.i.i
  %l_G6.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %4 = load ptr, ptr %l_G6.i.i, align 8
  %arrayidx8.i.i = getelementptr inbounds %struct.global_State, ptr %4, i64 0, i32 24, i64 16
  %5 = load ptr, ptr %arrayidx8.i.i, align 8
  %6 = getelementptr i8, ptr %mt.0.i.i, i64 11
  %mt.0.val.i.i = load i8, ptr %6, align 1
  %7 = getelementptr i8, ptr %mt.0.i.i, i64 32
  %mt.0.val6.i.i = load ptr, ptr %7, align 8
  %hash.i.i.i = getelementptr inbounds %struct.anon.0, ptr %5, i64 0, i32 4
  %8 = load i32, ptr %hash.i.i.i, align 4
  %sh_prom.i.i.i = zext nneg i8 %mt.0.val.i.i to i64
  %notmask.i.i.i = shl nsw i64 -1, %sh_prom.i.i.i
  %9 = trunc i64 %notmask.i.i.i to i32
  %10 = xor i32 %9, -1
  %conv2.i.i.i = and i32 %8, %10
  %idxprom.i.i.i = sext i32 %conv2.i.i.i to i64
  %arrayidx.i.i.i = getelementptr inbounds %struct.Node, ptr %mt.0.val6.i.i, i64 %idxprom.i.i.i
  br label %do.body.i.i.i

do.body.i.i.i:                                    ; preds = %if.else.i.i.i, %cond.true.i.i
  %n.0.i.i.i = phi ptr [ %arrayidx.i.i.i, %cond.true.i.i ], [ %13, %if.else.i.i.i ]
  %tt.i.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i.i, i64 0, i32 1, i32 0, i32 1
  %11 = load i32, ptr %tt.i.i.i, align 8
  %cmp.i.i.i = icmp eq i32 %11, 4
  br i1 %cmp.i.i.i, label %land.lhs.true.i.i.i, label %if.else.i.i.i

land.lhs.true.i.i.i:                              ; preds = %do.body.i.i.i
  %i_key.i.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i.i, i64 0, i32 1
  %12 = load ptr, ptr %i_key.i.i.i, align 8
  %cmp5.i.i.i = icmp eq ptr %12, %5
  br i1 %cmp5.i.i.i, label %luaT_gettmbyobj.exit.i, label %if.else.i.i.i

if.else.i.i.i:                                    ; preds = %land.lhs.true.i.i.i, %do.body.i.i.i
  %next.i.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i.i, i64 0, i32 1, i32 0, i32 2
  %13 = load ptr, ptr %next.i.i.i, align 8
  %tobool.not.i.i.i = icmp eq ptr %13, null
  br i1 %tobool.not.i.i.i, label %luaT_gettmbyobj.exit.i, label %do.body.i.i.i, !llvm.loop !29

luaT_gettmbyobj.exit.i:                           ; preds = %if.else.i.i.i, %land.lhs.true.i.i.i, %sw.epilog.i.i
  %cond.i.i = phi ptr [ @luaO_nilobject_, %sw.epilog.i.i ], [ %n.0.i.i.i, %land.lhs.true.i.i.i ], [ @luaO_nilobject_, %if.else.i.i.i ]
  %stack.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 10
  %14 = load ptr, ptr %stack.i, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %cond.i.i, i64 0, i32 1
  %15 = load i32, ptr %tt.i, align 8
  %cmp.i = icmp eq i32 %15, 6
  br i1 %cmp.i, label %if.end.i, label %if.then.i

if.then.i:                                        ; preds = %luaT_gettmbyobj.exit.i
  %idxprom.i23.i = sext i32 %0 to i64
  %arrayidx.i24.i = getelementptr inbounds [11 x ptr], ptr @luaT_typenames, i64 0, i64 %idxprom.i23.i
  %16 = load ptr, ptr %arrayidx.i24.i, align 8
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef nonnull %L, ptr noundef nonnull @.str.20, ptr noundef nonnull @.str.18, ptr noundef %16)
  unreachable

if.end.i:                                         ; preds = %luaT_gettmbyobj.exit.i
  %top.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %17 = load ptr, ptr %top.i, align 8
  %cmp1.i99 = icmp ugt ptr %17, %func
  br i1 %cmp1.i99, label %for.body.i, label %for.end.i

for.body.i:                                       ; preds = %if.end.i, %for.body.i
  %p.0.i100 = phi ptr [ %add.ptr.i, %for.body.i ], [ %17, %if.end.i ]
  %add.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %p.0.i100, i64 -1
  %18 = load i64, ptr %add.ptr.i, align 8
  store i64 %18, ptr %p.0.i100, align 8
  %tt3.i = getelementptr %struct.lua_TValue, ptr %p.0.i100, i64 -1, i32 1
  %19 = load i32, ptr %tt3.i, align 8
  %tt4.i = getelementptr inbounds %struct.lua_TValue, ptr %p.0.i100, i64 0, i32 1
  store i32 %19, ptr %tt4.i, align 8
  %cmp1.i = icmp ugt ptr %add.ptr.i, %func
  br i1 %cmp1.i, label %for.body.i, label %for.end.i.loopexit, !llvm.loop !40

for.end.i.loopexit:                               ; preds = %for.body.i
  %.pre = load ptr, ptr %top.i, align 8
  br label %for.end.i

for.end.i:                                        ; preds = %for.end.i.loopexit, %if.end.i
  %20 = phi ptr [ %.pre, %for.end.i.loopexit ], [ %17, %if.end.i ]
  %stack_last.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 9
  %21 = load ptr, ptr %stack_last.i, align 8
  %sub.ptr.lhs.cast6.i = ptrtoint ptr %21 to i64
  %sub.ptr.rhs.cast7.i = ptrtoint ptr %20 to i64
  %sub.ptr.sub8.i = sub i64 %sub.ptr.lhs.cast6.i, %sub.ptr.rhs.cast7.i
  %cmp9.i = icmp slt i64 %sub.ptr.sub8.i, 17
  br i1 %cmp9.i, label %if.then10.i, label %tryfuncTM.exit

if.then10.i:                                      ; preds = %for.end.i
  %stacksize.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 13
  %22 = load i32, ptr %stacksize.i.i, align 8
  %cmp.not.i.i = icmp slt i32 %22, 1
  %mul.i.i = shl nuw nsw i32 %22, 1
  %add.i.i = add nsw i32 %22, 1
  %mul.i.i.sink = select i1 %cmp.not.i.i, i32 %add.i.i, i32 %mul.i.i
  tail call fastcc void @luaD_reallocstack(ptr noundef nonnull %L, i32 noundef %mul.i.i.sink)
  br label %tryfuncTM.exit

tryfuncTM.exit:                                   ; preds = %if.then10.i, %for.end.i
  %sub.ptr.lhs.cast.i = ptrtoint ptr %func to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %14 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %23 = load ptr, ptr %top.i, align 8
  %incdec.ptr13.i = getelementptr inbounds %struct.lua_TValue, ptr %23, i64 1
  store ptr %incdec.ptr13.i, ptr %top.i, align 8
  %24 = load ptr, ptr %stack.i, align 8
  %add.ptr15.i = getelementptr inbounds i8, ptr %24, i64 %sub.ptr.sub.i
  %25 = load i64, ptr %cond.i.i, align 8
  store i64 %25, ptr %add.ptr15.i, align 8
  %26 = load i32, ptr %tt.i, align 8
  %tt21.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr15.i, i64 0, i32 1
  store i32 %26, ptr %tt21.i, align 8
  %27 = inttoptr i64 %25 to ptr
  br label %if.end

if.end:                                           ; preds = %entry.if.end_crit_edge, %tryfuncTM.exit
  %28 = phi ptr [ %.pre107, %entry.if.end_crit_edge ], [ %27, %tryfuncTM.exit ]
  %func.addr.0 = phi ptr [ %func, %entry.if.end_crit_edge ], [ %add.ptr15.i, %tryfuncTM.exit ]
  %stack = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 10
  %29 = load ptr, ptr %stack, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %func.addr.0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %29 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %savedpc = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 8
  %30 = load ptr, ptr %savedpc, align 8
  %ci = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %31 = load ptr, ptr %ci, align 8
  %savedpc1 = getelementptr inbounds %struct.CallInfo, ptr %31, i64 0, i32 3
  store ptr %30, ptr %savedpc1, align 8
  %isC = getelementptr inbounds %struct.LClosure, ptr %28, i64 0, i32 3
  %32 = load i8, ptr %isC, align 2
  %tobool.not = icmp eq i8 %32, 0
  br i1 %tobool.not, label %if.then2, label %if.else70

if.then2:                                         ; preds = %if.end
  %p4 = getelementptr inbounds %struct.LClosure, ptr %28, i64 0, i32 7
  %33 = load ptr, ptr %p4, align 8
  %stack_last = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 9
  %34 = load ptr, ptr %stack_last, align 8
  %top = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %35 = load ptr, ptr %top, align 8
  %sub.ptr.lhs.cast5 = ptrtoint ptr %34 to i64
  %sub.ptr.rhs.cast6 = ptrtoint ptr %35 to i64
  %sub.ptr.sub7 = sub i64 %sub.ptr.lhs.cast5, %sub.ptr.rhs.cast6
  %maxstacksize = getelementptr inbounds %struct.Proto, ptr %33, i64 0, i32 22
  %36 = load i8, ptr %maxstacksize, align 1
  %conv = zext i8 %36 to i32
  %numparams = getelementptr inbounds %struct.Proto, ptr %33, i64 0, i32 20
  %37 = load i8, ptr %numparams, align 1
  %conv8 = zext i8 %37 to i32
  %add = add nuw nsw i32 %conv8, %conv
  %mul = shl nuw nsw i32 %add, 4
  %conv9 = zext nneg i32 %mul to i64
  %cmp10.not = icmp sgt i64 %sub.ptr.sub7, %conv9
  br i1 %cmp10.not, label %if.end18, label %if.then12

if.then12:                                        ; preds = %if.then2
  %stacksize.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 13
  %38 = load i32, ptr %stacksize.i, align 8
  %cmp.not.i = icmp slt i32 %38, %add
  %add.i = add nsw i32 %38, %add
  %mul.i = shl nsw i32 %38, 1
  %add.i.sink = select i1 %cmp.not.i, i32 %add.i, i32 %mul.i
  tail call fastcc void @luaD_reallocstack(ptr noundef nonnull %L, i32 noundef %add.i.sink)
  br label %if.end18

if.end18:                                         ; preds = %if.then12, %if.then2
  %39 = load ptr, ptr %stack, align 8
  %add.ptr = getelementptr inbounds i8, ptr %39, i64 %sub.ptr.sub
  %is_vararg = getelementptr inbounds %struct.Proto, ptr %33, i64 0, i32 21
  %40 = load i8, ptr %is_vararg, align 2
  %tobool20.not = icmp eq i8 %40, 0
  br i1 %tobool20.not, label %if.then21, label %if.else36

if.then21:                                        ; preds = %if.end18
  %add.ptr22 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr, i64 1
  %41 = load ptr, ptr %top, align 8
  %42 = load i8, ptr %numparams, align 1
  %idx.ext = zext i8 %42 to i64
  %add.ptr26 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr22, i64 %idx.ext
  %cmp27 = icmp ugt ptr %41, %add.ptr26
  br i1 %cmp27, label %if.then29, label %if.end45

if.then29:                                        ; preds = %if.then21
  store ptr %add.ptr26, ptr %top, align 8
  br label %if.end45

if.else36:                                        ; preds = %if.end18
  %43 = load ptr, ptr %top, align 8
  %sub.ptr.lhs.cast38 = ptrtoint ptr %43 to i64
  %sub.ptr.rhs.cast39 = ptrtoint ptr %add.ptr to i64
  %sub.ptr.sub40 = sub i64 %sub.ptr.lhs.cast38, %sub.ptr.rhs.cast39
  %sub.ptr.div = lshr exact i64 %sub.ptr.sub40, 4
  %conv41 = trunc i64 %sub.ptr.div to i32
  %sub = add nsw i32 %conv41, -1
  %.val = load i8, ptr %numparams, align 1
  %conv.i = zext i8 %.val to i32
  %cmp1.i74.not = icmp sgt i32 %conv41, %conv.i
  br i1 %cmp1.i74.not, label %for.end.i75, label %for.body.i79

for.body.i79:                                     ; preds = %if.else36, %for.body.i79
  %actual.addr.02.i = phi i32 [ %inc.i, %for.body.i79 ], [ %sub, %if.else36 ]
  %44 = load ptr, ptr %top, align 8
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %44, i64 1
  store ptr %incdec.ptr.i, ptr %top, align 8
  %tt.i80 = getelementptr inbounds %struct.lua_TValue, ptr %44, i64 0, i32 1
  store i32 0, ptr %tt.i80, align 8
  %inc.i = add nsw i32 %actual.addr.02.i, 1
  %exitcond.not.i = icmp eq i32 %inc.i, %conv.i
  br i1 %exitcond.not.i, label %for.end.i75.loopexit, label %for.body.i79, !llvm.loop !41

for.end.i75.loopexit:                             ; preds = %for.body.i79
  %.pre108 = load ptr, ptr %top, align 8
  br label %for.end.i75

for.end.i75:                                      ; preds = %for.end.i75.loopexit, %if.else36
  %45 = phi ptr [ %43, %if.else36 ], [ %.pre108, %for.end.i75.loopexit ]
  %actual.addr.0.lcssa.i = phi i32 [ %sub, %if.else36 ], [ %conv.i, %for.end.i75.loopexit ]
  %idx.ext.i = zext nneg i32 %actual.addr.0.lcssa.i to i64
  %idx.neg.i = sub nsw i64 0, %idx.ext.i
  %add.ptr.i76 = getelementptr inbounds %struct.lua_TValue, ptr %45, i64 %idx.neg.i
  %cmp53.not.i = icmp eq i8 %.val, 0
  br i1 %cmp53.not.i, label %adjust_varargs.exit, label %for.body7.preheader.i

for.body7.preheader.i:                            ; preds = %for.end.i75
  %wide.trip.count.i = zext i8 %.val to i64
  br label %for.body7.i

for.body7.i:                                      ; preds = %for.body7.i, %for.body7.preheader.i
  %indvars.iv.i = phi i64 [ 0, %for.body7.preheader.i ], [ %indvars.iv.next.i, %for.body7.i ]
  %add.ptr9.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.i76, i64 %indvars.iv.i
  %46 = load ptr, ptr %top, align 8
  %incdec.ptr11.i = getelementptr inbounds %struct.lua_TValue, ptr %46, i64 1
  store ptr %incdec.ptr11.i, ptr %top, align 8
  %47 = load i64, ptr %add.ptr9.i, align 8
  store i64 %47, ptr %46, align 8
  %tt13.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.i76, i64 %indvars.iv.i, i32 1
  %48 = load i32, ptr %tt13.i, align 8
  %tt14.i = getelementptr inbounds %struct.lua_TValue, ptr %46, i64 0, i32 1
  store i32 %48, ptr %tt14.i, align 8
  store i32 0, ptr %tt13.i, align 8
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond6.not.i = icmp eq i64 %indvars.iv.next.i, %wide.trip.count.i
  br i1 %exitcond6.not.i, label %adjust_varargs.exit, label %for.body7.i, !llvm.loop !42

adjust_varargs.exit:                              ; preds = %for.body7.i, %for.end.i75
  %49 = load ptr, ptr %stack, align 8
  %add.ptr44 = getelementptr inbounds i8, ptr %49, i64 %sub.ptr.sub
  br label %if.end45

if.end45:                                         ; preds = %if.then21, %if.then29, %adjust_varargs.exit
  %base.0 = phi ptr [ %45, %adjust_varargs.exit ], [ %add.ptr22, %if.then29 ], [ %add.ptr22, %if.then21 ]
  %func.addr.1 = phi ptr [ %add.ptr44, %adjust_varargs.exit ], [ %add.ptr, %if.then29 ], [ %add.ptr, %if.then21 ]
  %50 = load ptr, ptr %ci, align 8
  %end_ci = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 11
  %51 = load ptr, ptr %end_ci, align 8
  %cmp47 = icmp eq ptr %50, %51
  br i1 %cmp47, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end45
  %call49 = tail call fastcc ptr @growCI(ptr noundef nonnull %L)
  br label %cond.end

cond.false:                                       ; preds = %if.end45
  %incdec.ptr = getelementptr inbounds %struct.CallInfo, ptr %50, i64 1
  store ptr %incdec.ptr, ptr %ci, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call49, %cond.true ], [ %incdec.ptr, %cond.false ]
  %func51 = getelementptr inbounds %struct.CallInfo, ptr %cond, i64 0, i32 1
  store ptr %func.addr.1, ptr %func51, align 8
  store ptr %base.0, ptr %cond, align 8
  %base53 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  store ptr %base.0, ptr %base53, align 8
  %52 = load i8, ptr %maxstacksize, align 1
  %idx.ext57 = zext i8 %52 to i64
  %add.ptr58 = getelementptr inbounds %struct.lua_TValue, ptr %base.0, i64 %idx.ext57
  %top59 = getelementptr inbounds %struct.CallInfo, ptr %cond, i64 0, i32 2
  store ptr %add.ptr58, ptr %top59, align 8
  %code = getelementptr inbounds %struct.Proto, ptr %33, i64 0, i32 4
  %53 = load ptr, ptr %code, align 8
  store ptr %53, ptr %savedpc, align 8
  %tailcalls = getelementptr inbounds %struct.CallInfo, ptr %cond, i64 0, i32 5
  store i32 0, ptr %tailcalls, align 4
  %nresults61 = getelementptr inbounds %struct.CallInfo, ptr %cond, i64 0, i32 4
  store i32 %nresults, ptr %nresults61, align 8
  %54 = load ptr, ptr %top, align 8
  %55 = load ptr, ptr %top59, align 8
  %cmp64101 = icmp ult ptr %54, %55
  br i1 %cmp64101, label %for.body, label %for.end

for.body:                                         ; preds = %cond.end, %for.body
  %st.0102 = phi ptr [ %incdec.ptr67, %for.body ], [ %54, %cond.end ]
  %tt66 = getelementptr inbounds %struct.lua_TValue, ptr %st.0102, i64 0, i32 1
  store i32 0, ptr %tt66, align 8
  %incdec.ptr67 = getelementptr inbounds %struct.lua_TValue, ptr %st.0102, i64 1
  %56 = load ptr, ptr %top59, align 8
  %cmp64 = icmp ult ptr %incdec.ptr67, %56
  br i1 %cmp64, label %for.body, label %for.end, !llvm.loop !43

for.end:                                          ; preds = %for.body, %cond.end
  %.lcssa = phi ptr [ %55, %cond.end ], [ %56, %for.body ]
  store ptr %.lcssa, ptr %top, align 8
  br label %return

if.else70:                                        ; preds = %if.end
  %stack_last72 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 9
  %57 = load ptr, ptr %stack_last72, align 8
  %top73 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %58 = load ptr, ptr %top73, align 8
  %sub.ptr.lhs.cast74 = ptrtoint ptr %57 to i64
  %sub.ptr.rhs.cast75 = ptrtoint ptr %58 to i64
  %sub.ptr.sub76 = sub i64 %sub.ptr.lhs.cast74, %sub.ptr.rhs.cast75
  %cmp77 = icmp slt i64 %sub.ptr.sub76, 321
  br i1 %cmp77, label %if.then79, label %if.end81

if.then79:                                        ; preds = %if.else70
  %stacksize.i81 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 13
  %59 = load i32, ptr %stacksize.i81, align 8
  %cmp.not.i82 = icmp slt i32 %59, 20
  %add.i87 = add nsw i32 %59, 20
  %mul.i84 = shl nuw nsw i32 %59, 1
  %add.i87.sink = select i1 %cmp.not.i82, i32 %add.i87, i32 %mul.i84
  tail call fastcc void @luaD_reallocstack(ptr noundef nonnull %L, i32 noundef %add.i87.sink)
  br label %if.end81

if.end81:                                         ; preds = %if.then79, %if.else70
  %60 = load ptr, ptr %ci, align 8
  %end_ci83 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 11
  %61 = load ptr, ptr %end_ci83, align 8
  %cmp84 = icmp eq ptr %60, %61
  br i1 %cmp84, label %cond.true86, label %cond.false88

cond.true86:                                      ; preds = %if.end81
  %call87 = tail call fastcc ptr @growCI(ptr noundef nonnull %L)
  br label %cond.end91

cond.false88:                                     ; preds = %if.end81
  %incdec.ptr90 = getelementptr inbounds %struct.CallInfo, ptr %60, i64 1
  store ptr %incdec.ptr90, ptr %ci, align 8
  br label %cond.end91

cond.end91:                                       ; preds = %cond.false88, %cond.true86
  %cond92 = phi ptr [ %call87, %cond.true86 ], [ %incdec.ptr90, %cond.false88 ]
  %62 = load ptr, ptr %stack, align 8
  %add.ptr94 = getelementptr inbounds i8, ptr %62, i64 %sub.ptr.sub
  %func95 = getelementptr inbounds %struct.CallInfo, ptr %cond92, i64 0, i32 1
  store ptr %add.ptr94, ptr %func95, align 8
  %add.ptr97 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr94, i64 1
  store ptr %add.ptr97, ptr %cond92, align 8
  %base99 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  store ptr %add.ptr97, ptr %base99, align 8
  %63 = load ptr, ptr %top73, align 8
  %add.ptr101 = getelementptr inbounds %struct.lua_TValue, ptr %63, i64 20
  %top102 = getelementptr inbounds %struct.CallInfo, ptr %cond92, i64 0, i32 2
  store ptr %add.ptr101, ptr %top102, align 8
  %nresults103 = getelementptr inbounds %struct.CallInfo, ptr %cond92, i64 0, i32 4
  store i32 %nresults, ptr %nresults103, align 8
  %64 = load ptr, ptr %ci, align 8
  %func105 = getelementptr inbounds %struct.CallInfo, ptr %64, i64 0, i32 1
  %65 = load ptr, ptr %func105, align 8
  %66 = load ptr, ptr %65, align 8
  %f = getelementptr inbounds %struct.CClosure, ptr %66, i64 0, i32 7
  %67 = load ptr, ptr %f, align 8
  %call107 = tail call i32 %67(ptr noundef nonnull %L) #35
  %cmp108 = icmp slt i32 %call107, 0
  br i1 %cmp108, label %return, label %if.else111

if.else111:                                       ; preds = %cond.end91
  %68 = load ptr, ptr %top73, align 8
  %69 = load ptr, ptr %ci, align 8
  %incdec.ptr.i89 = getelementptr inbounds %struct.CallInfo, ptr %69, i64 -1
  store ptr %incdec.ptr.i89, ptr %ci, align 8
  %func.i = getelementptr inbounds %struct.CallInfo, ptr %69, i64 0, i32 1
  %70 = load ptr, ptr %func.i, align 8
  %nresults.i = getelementptr inbounds %struct.CallInfo, ptr %69, i64 0, i32 4
  %71 = load i32, ptr %nresults.i, align 8
  %72 = load ptr, ptr %incdec.ptr.i89, align 8
  store ptr %72, ptr %base99, align 8
  %savedpc.i = getelementptr %struct.CallInfo, ptr %69, i64 -1, i32 3
  %73 = load ptr, ptr %savedpc.i, align 8
  store ptr %73, ptr %savedpc, align 8
  %cmp.not16.i = icmp eq i32 %71, 0
  br i1 %cmp.not16.i, label %luaD_poscall.exit, label %land.rhs.i.preheader

land.rhs.i.preheader:                             ; preds = %if.else111
  %idx.ext113 = zext nneg i32 %call107 to i64
  %idx.neg = sub nsw i64 0, %idx.ext113
  %add.ptr114 = getelementptr inbounds %struct.lua_TValue, ptr %68, i64 %idx.neg
  br label %land.rhs.i

land.rhs.i:                                       ; preds = %land.rhs.i.preheader, %for.body.i93
  %firstResult.addr.019.i = phi ptr [ %incdec.ptr6.i, %for.body.i93 ], [ %add.ptr114, %land.rhs.i.preheader ]
  %res.018.i = phi ptr [ %incdec.ptr7.i, %for.body.i93 ], [ %70, %land.rhs.i.preheader ]
  %i.017.i = phi i32 [ %dec.i, %for.body.i93 ], [ %71, %land.rhs.i.preheader ]
  %74 = load ptr, ptr %top73, align 8
  %cmp5.i = icmp ult ptr %firstResult.addr.019.i, %74
  br i1 %cmp5.i, label %for.body.i93, label %for.end.i91

for.body.i93:                                     ; preds = %land.rhs.i
  %incdec.ptr6.i = getelementptr inbounds %struct.lua_TValue, ptr %firstResult.addr.019.i, i64 1
  %incdec.ptr7.i = getelementptr inbounds %struct.lua_TValue, ptr %res.018.i, i64 1
  %75 = load i64, ptr %firstResult.addr.019.i, align 8
  store i64 %75, ptr %res.018.i, align 8
  %tt.i94 = getelementptr inbounds %struct.lua_TValue, ptr %firstResult.addr.019.i, i64 0, i32 1
  %76 = load i32, ptr %tt.i94, align 8
  %tt9.i = getelementptr inbounds %struct.lua_TValue, ptr %res.018.i, i64 0, i32 1
  store i32 %76, ptr %tt9.i, align 8
  %dec.i = add nsw i32 %i.017.i, -1
  %cmp.not.i95 = icmp eq i32 %dec.i, 0
  br i1 %cmp.not.i95, label %luaD_poscall.exit, label %land.rhs.i, !llvm.loop !33

for.end.i91:                                      ; preds = %land.rhs.i
  %cmp1123.i = icmp sgt i32 %i.017.i, 0
  br i1 %cmp1123.i, label %while.body.i, label %luaD_poscall.exit

while.body.i:                                     ; preds = %for.end.i91, %while.body.i
  %res.125.i = phi ptr [ %incdec.ptr12.i, %while.body.i ], [ %res.018.i, %for.end.i91 ]
  %i.124.i = phi i32 [ %dec10.i, %while.body.i ], [ %i.017.i, %for.end.i91 ]
  %dec10.i = add nsw i32 %i.124.i, -1
  %incdec.ptr12.i = getelementptr inbounds %struct.lua_TValue, ptr %res.125.i, i64 1
  %tt13.i92 = getelementptr inbounds %struct.lua_TValue, ptr %res.125.i, i64 0, i32 1
  store i32 0, ptr %tt13.i92, align 8
  %cmp11.i = icmp ugt i32 %i.124.i, 1
  br i1 %cmp11.i, label %while.body.i, label %luaD_poscall.exit, !llvm.loop !34

luaD_poscall.exit:                                ; preds = %for.body.i93, %while.body.i, %if.else111, %for.end.i91
  %res.1.lcssa.i = phi ptr [ %res.018.i, %for.end.i91 ], [ %70, %if.else111 ], [ %incdec.ptr12.i, %while.body.i ], [ %incdec.ptr7.i, %for.body.i93 ]
  store ptr %res.1.lcssa.i, ptr %top73, align 8
  br label %return

return:                                           ; preds = %cond.end91, %luaD_poscall.exit, %for.end
  %retval.0 = phi i32 [ 1, %luaD_poscall.exit ], [ 0, %for.end ], [ 2, %cond.end91 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal fastcc ptr @growCI(ptr noundef %L) unnamed_addr #0 {
entry:
  %size_ci = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 14
  %0 = load i32, ptr %size_ci, align 4
  %cmp = icmp sgt i32 %0, 20000
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %errorJmp.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 26
  %1 = load ptr, ptr %errorJmp.i, align 8
  %tobool.not.i = icmp eq ptr %1, null
  br i1 %tobool.not.i, label %if.else.i, label %if.then.i

if.then.i:                                        ; preds = %if.then
  %status.i = getelementptr inbounds %struct.lua_longjmp, ptr %1, i64 0, i32 2
  store volatile i32 5, ptr %status.i, align 8
  %2 = load ptr, ptr %errorJmp.i, align 8
  %b.i = getelementptr inbounds %struct.lua_longjmp, ptr %2, i64 0, i32 1
  tail call void @longjmp(ptr noundef nonnull %b.i, i32 noundef 1) #38
  unreachable

if.else.i:                                        ; preds = %if.then
  %status3.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 3
  store i8 5, ptr %status3.i, align 2
  %l_G.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %3 = load ptr, ptr %l_G.i, align 8
  %panic.i = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 19
  %4 = load ptr, ptr %panic.i, align 8
  %tobool4.not.i = icmp eq ptr %4, null
  br i1 %tobool4.not.i, label %if.end.i, label %if.then5.i

if.then5.i:                                       ; preds = %if.else.i
  tail call fastcc void @resetstack(ptr noundef nonnull %L, i32 noundef 5)
  %5 = load ptr, ptr %l_G.i, align 8
  %panic7.i = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 19
  %6 = load ptr, ptr %panic7.i, align 8
  %call.i = tail call i32 %6(ptr noundef nonnull %L) #35
  br label %if.end.i

if.end.i:                                         ; preds = %if.then5.i, %if.else.i
  tail call void @exit(i32 noundef 1) #38
  unreachable

if.else:                                          ; preds = %entry
  %mul = shl nsw i32 %0, 1
  tail call fastcc void @luaD_reallocCI(ptr noundef nonnull %L, i32 noundef %mul)
  %7 = load i32, ptr %size_ci, align 4
  %cmp3 = icmp sgt i32 %7, 20000
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.else
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef nonnull %L, ptr noundef nonnull @.str.31)
  unreachable

if.end5:                                          ; preds = %if.else
  %ci = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %8 = load ptr, ptr %ci, align 8
  %incdec.ptr = getelementptr inbounds %struct.CallInfo, ptr %8, i64 1
  store ptr %incdec.ptr, ptr %ci, align 8
  ret ptr %incdec.ptr
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaV_gettable(ptr noundef %L, ptr nocapture noundef readonly %t, ptr nocapture noundef readonly %key, ptr noundef %val) unnamed_addr #0 {
entry:
  %l_G = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %tt.phi.trans.insert = getelementptr inbounds %struct.lua_TValue, ptr %t, i64 0, i32 1
  %.pre = load i32, ptr %tt.phi.trans.insert, align 8
  br label %for.body

for.cond:                                         ; preds = %if.end25
  %inc = add nuw nsw i32 %loop.055, 1
  %exitcond.not = icmp eq i32 %inc, 100
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !44

for.body:                                         ; preds = %entry, %for.cond
  %0 = phi i32 [ %.pre, %entry ], [ %32, %for.cond ]
  %t.addr.056 = phi ptr [ %t, %entry ], [ %tm.0, %for.cond ]
  %loop.055 = phi i32 [ 0, %entry ], [ %inc, %for.cond ]
  switch i32 %0, label %sw.default.i [
    i32 5, label %if.then
    i32 7, label %sw.bb1.i
  ]

if.then:                                          ; preds = %for.body
  %1 = load ptr, ptr %t.addr.056, align 8
  %call = tail call fastcc ptr @luaH_get(ptr noundef %1, ptr noundef %key)
  %tt2 = getelementptr inbounds %struct.lua_TValue, ptr %call, i64 0, i32 1
  %2 = load i32, ptr %tt2, align 8
  %cmp3 = icmp eq i32 %2, 0
  br i1 %cmp3, label %lor.lhs.false, label %if.then14

lor.lhs.false:                                    ; preds = %if.then
  %metatable = getelementptr inbounds %struct.Table, ptr %1, i64 0, i32 5
  %3 = load ptr, ptr %metatable, align 8
  %cmp4 = icmp eq ptr %3, null
  br i1 %cmp4, label %if.then14, label %cond.false

cond.false:                                       ; preds = %lor.lhs.false
  %flags = getelementptr inbounds %struct.Table, ptr %3, i64 0, i32 3
  %4 = load i8, ptr %flags, align 2
  %5 = and i8 %4, 1
  %tobool.not = icmp eq i8 %5, 0
  br i1 %tobool.not, label %cond.false7, label %if.then14

cond.false7:                                      ; preds = %cond.false
  %6 = load ptr, ptr %l_G, align 8
  %tmname = getelementptr inbounds %struct.global_State, ptr %6, i64 0, i32 24
  %7 = load ptr, ptr %tmname, align 8
  %8 = getelementptr i8, ptr %3, i64 11
  %events.val.i = load i8, ptr %8, align 1
  %9 = getelementptr i8, ptr %3, i64 32
  %events.val3.i = load ptr, ptr %9, align 8
  %hash.i.i = getelementptr inbounds %struct.anon.0, ptr %7, i64 0, i32 4
  %10 = load i32, ptr %hash.i.i, align 4
  %sh_prom.i.i = zext nneg i8 %events.val.i to i64
  %notmask.i.i = shl nsw i64 -1, %sh_prom.i.i
  %11 = trunc i64 %notmask.i.i to i32
  %12 = xor i32 %11, -1
  %conv2.i.i = and i32 %10, %12
  %idxprom.i.i = sext i32 %conv2.i.i to i64
  %arrayidx.i.i = getelementptr inbounds %struct.Node, ptr %events.val3.i, i64 %idxprom.i.i
  br label %do.body.i.i

do.body.i.i:                                      ; preds = %if.else.i.i, %cond.false7
  %n.0.i.i = phi ptr [ %arrayidx.i.i, %cond.false7 ], [ %15, %if.else.i.i ]
  %tt.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1, i32 0, i32 1
  %13 = load i32, ptr %tt.i.i, align 8
  %cmp.i.i = icmp eq i32 %13, 4
  br i1 %cmp.i.i, label %land.lhs.true.i.i, label %if.else.i.i

land.lhs.true.i.i:                                ; preds = %do.body.i.i
  %i_key.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1
  %14 = load ptr, ptr %i_key.i.i, align 8
  %cmp5.i.i = icmp eq ptr %14, %7
  br i1 %cmp5.i.i, label %luaH_getstr.exit.i, label %if.else.i.i

if.else.i.i:                                      ; preds = %land.lhs.true.i.i, %do.body.i.i
  %next.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1, i32 0, i32 2
  %15 = load ptr, ptr %next.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %15, null
  br i1 %tobool.not.i.i, label %luaH_getstr.exit.i, label %do.body.i.i, !llvm.loop !29

luaH_getstr.exit.i:                               ; preds = %if.else.i.i, %land.lhs.true.i.i
  %retval.0.i.i = phi ptr [ %n.0.i.i, %land.lhs.true.i.i ], [ @luaO_nilobject_, %if.else.i.i ]
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i.i, i64 0, i32 1
  %16 = load i32, ptr %tt.i, align 8
  %cmp.i = icmp eq i32 %16, 0
  br i1 %cmp.i, label %if.then.i, label %if.end25

if.then.i:                                        ; preds = %luaH_getstr.exit.i
  %flags.le = getelementptr inbounds %struct.Table, ptr %3, i64 0, i32 3
  %conv3.i = or disjoint i8 %4, 1
  store i8 %conv3.i, ptr %flags.le, align 2
  br label %if.then14

if.then14:                                        ; preds = %cond.false, %lor.lhs.false, %if.then, %if.then.i
  %tt2113 = getelementptr inbounds %struct.lua_TValue, ptr %call, i64 0, i32 1
  %17 = load i64, ptr %call, align 8
  store i64 %17, ptr %val, align 8
  br label %return

sw.bb1.i:                                         ; preds = %for.body
  %18 = load ptr, ptr %t.addr.056, align 8
  %metatable3.i = getelementptr inbounds %struct.anon.1, ptr %18, i64 0, i32 3
  br label %sw.epilog.i

sw.default.i:                                     ; preds = %for.body
  %19 = load ptr, ptr %l_G, align 8
  %idxprom.i = sext i32 %0 to i64
  %arrayidx.i = getelementptr inbounds %struct.global_State, ptr %19, i64 0, i32 23, i64 %idxprom.i
  br label %sw.epilog.i

sw.epilog.i:                                      ; preds = %sw.default.i, %sw.bb1.i
  %mt.0.in.i = phi ptr [ %arrayidx.i, %sw.default.i ], [ %metatable3.i, %sw.bb1.i ]
  %mt.0.i = load ptr, ptr %mt.0.in.i, align 8
  %tobool.not.i = icmp eq ptr %mt.0.i, null
  br i1 %tobool.not.i, label %luaT_gettmbyobj.exit, label %cond.true.i

cond.true.i:                                      ; preds = %sw.epilog.i
  %20 = load ptr, ptr %l_G, align 8
  %arrayidx8.i = getelementptr inbounds %struct.global_State, ptr %20, i64 0, i32 24, i64 0
  %21 = load ptr, ptr %arrayidx8.i, align 8
  %22 = getelementptr i8, ptr %mt.0.i, i64 11
  %mt.0.val.i = load i8, ptr %22, align 1
  %23 = getelementptr i8, ptr %mt.0.i, i64 32
  %mt.0.val6.i = load ptr, ptr %23, align 8
  %hash.i.i21 = getelementptr inbounds %struct.anon.0, ptr %21, i64 0, i32 4
  %24 = load i32, ptr %hash.i.i21, align 4
  %sh_prom.i.i22 = zext nneg i8 %mt.0.val.i to i64
  %notmask.i.i23 = shl nsw i64 -1, %sh_prom.i.i22
  %25 = trunc i64 %notmask.i.i23 to i32
  %26 = xor i32 %25, -1
  %conv2.i.i24 = and i32 %24, %26
  %idxprom.i.i25 = sext i32 %conv2.i.i24 to i64
  %arrayidx.i.i26 = getelementptr inbounds %struct.Node, ptr %mt.0.val6.i, i64 %idxprom.i.i25
  br label %do.body.i.i27

do.body.i.i27:                                    ; preds = %if.else.i.i31, %cond.true.i
  %n.0.i.i28 = phi ptr [ %arrayidx.i.i26, %cond.true.i ], [ %29, %if.else.i.i31 ]
  %tt.i.i29 = getelementptr inbounds %struct.Node, ptr %n.0.i.i28, i64 0, i32 1, i32 0, i32 1
  %27 = load i32, ptr %tt.i.i29, align 8
  %cmp.i.i30 = icmp eq i32 %27, 4
  br i1 %cmp.i.i30, label %land.lhs.true.i.i34, label %if.else.i.i31

land.lhs.true.i.i34:                              ; preds = %do.body.i.i27
  %i_key.i.i35 = getelementptr inbounds %struct.Node, ptr %n.0.i.i28, i64 0, i32 1
  %28 = load ptr, ptr %i_key.i.i35, align 8
  %cmp5.i.i36 = icmp eq ptr %28, %21
  br i1 %cmp5.i.i36, label %luaT_gettmbyobj.exit, label %if.else.i.i31

if.else.i.i31:                                    ; preds = %land.lhs.true.i.i34, %do.body.i.i27
  %next.i.i32 = getelementptr inbounds %struct.Node, ptr %n.0.i.i28, i64 0, i32 1, i32 0, i32 2
  %29 = load ptr, ptr %next.i.i32, align 8
  %tobool.not.i.i33 = icmp eq ptr %29, null
  br i1 %tobool.not.i.i33, label %luaT_gettmbyobj.exit, label %do.body.i.i27, !llvm.loop !29

luaT_gettmbyobj.exit:                             ; preds = %land.lhs.true.i.i34, %if.else.i.i31, %sw.epilog.i
  %cond.i = phi ptr [ @luaO_nilobject_, %sw.epilog.i ], [ @luaO_nilobject_, %if.else.i.i31 ], [ %n.0.i.i28, %land.lhs.true.i.i34 ]
  %tt20 = getelementptr inbounds %struct.lua_TValue, ptr %cond.i, i64 0, i32 1
  %30 = load i32, ptr %tt20, align 8
  %cmp21 = icmp eq i32 %30, 0
  br i1 %cmp21, label %if.then23, label %if.end25

if.then23:                                        ; preds = %luaT_gettmbyobj.exit
  %idxprom.i38 = sext i32 %0 to i64
  %arrayidx.i39 = getelementptr inbounds [11 x ptr], ptr @luaT_typenames, i64 0, i64 %idxprom.i38
  %31 = load ptr, ptr %arrayidx.i39, align 8
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef nonnull %L, ptr noundef nonnull @.str.20, ptr noundef nonnull @.str.36, ptr noundef %31)
  unreachable

if.end25:                                         ; preds = %luaH_getstr.exit.i, %luaT_gettmbyobj.exit
  %32 = phi i32 [ %30, %luaT_gettmbyobj.exit ], [ %16, %luaH_getstr.exit.i ]
  %tm.0 = phi ptr [ %cond.i, %luaT_gettmbyobj.exit ], [ %retval.0.i.i, %luaH_getstr.exit.i ]
  %cmp27 = icmp eq i32 %32, 6
  br i1 %cmp27, label %if.then29, label %for.cond

if.then29:                                        ; preds = %if.end25
  %stack.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 10
  %33 = load ptr, ptr %stack.i, align 8
  %top.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %34 = load ptr, ptr %top.i, align 8
  %35 = load i64, ptr %tm.0, align 8
  store i64 %35, ptr %34, align 8
  %tt.i77 = getelementptr inbounds %struct.lua_TValue, ptr %tm.0, i64 0, i32 1
  %36 = load i32, ptr %tt.i77, align 8
  %tt2.i = getelementptr inbounds %struct.lua_TValue, ptr %34, i64 0, i32 1
  store i32 %36, ptr %tt2.i, align 8
  %37 = load ptr, ptr %top.i, align 8
  %add.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %37, i64 1
  %38 = load i64, ptr %t.addr.056, align 8
  store i64 %38, ptr %add.ptr.i, align 8
  %tt8.i = getelementptr inbounds %struct.lua_TValue, ptr %t.addr.056, i64 0, i32 1
  %39 = load i32, ptr %tt8.i, align 8
  %tt9.i = getelementptr inbounds %struct.lua_TValue, ptr %37, i64 1, i32 1
  store i32 %39, ptr %tt9.i, align 8
  %40 = load ptr, ptr %top.i, align 8
  %add.ptr13.i = getelementptr inbounds %struct.lua_TValue, ptr %40, i64 2
  %41 = load i64, ptr %key, align 8
  store i64 %41, ptr %add.ptr13.i, align 8
  %tt16.i = getelementptr inbounds %struct.lua_TValue, ptr %key, i64 0, i32 1
  %42 = load i32, ptr %tt16.i, align 8
  %tt17.i = getelementptr inbounds %struct.lua_TValue, ptr %40, i64 2, i32 1
  store i32 %42, ptr %tt17.i, align 8
  %stack_last.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 9
  %43 = load ptr, ptr %stack_last.i, align 8
  %44 = load ptr, ptr %top.i, align 8
  %sub.ptr.lhs.cast19.i = ptrtoint ptr %43 to i64
  %sub.ptr.rhs.cast20.i = ptrtoint ptr %44 to i64
  %sub.ptr.sub21.i = sub i64 %sub.ptr.lhs.cast19.i, %sub.ptr.rhs.cast20.i
  %cmp.i78 = icmp slt i64 %sub.ptr.sub21.i, 49
  br i1 %cmp.i78, label %if.then.i79, label %callTMres.exit

if.then.i79:                                      ; preds = %if.then29
  %stacksize.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 13
  %45 = load i32, ptr %stacksize.i.i, align 8
  %cmp.not.i.i = icmp slt i32 %45, 3
  %add.i.i = add nsw i32 %45, 3
  %mul.i.i = shl nuw nsw i32 %45, 1
  %add.i.sink.i = select i1 %cmp.not.i.i, i32 %add.i.i, i32 %mul.i.i
  tail call fastcc void @luaD_reallocstack(ptr noundef nonnull %L, i32 noundef %add.i.sink.i)
  %.pre111 = load ptr, ptr %top.i, align 8
  br label %callTMres.exit

callTMres.exit:                                   ; preds = %if.then29, %if.then.i79
  %46 = phi ptr [ %44, %if.then29 ], [ %.pre111, %if.then.i79 ]
  %sub.ptr.lhs.cast.i = ptrtoint ptr %val to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %33 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %add.ptr23.i = getelementptr inbounds %struct.lua_TValue, ptr %46, i64 3
  store ptr %add.ptr23.i, ptr %top.i, align 8
  tail call fastcc void @luaD_call(ptr noundef nonnull %L, ptr noundef %46, i32 noundef 1)
  %47 = load ptr, ptr %stack.i, align 8
  %add.ptr27.i = getelementptr inbounds i8, ptr %47, i64 %sub.ptr.sub.i
  %48 = load ptr, ptr %top.i, align 8
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %48, i64 -1
  store ptr %incdec.ptr.i, ptr %top.i, align 8
  %49 = load i64, ptr %incdec.ptr.i, align 8
  store i64 %49, ptr %add.ptr27.i, align 8
  %tt34.i = getelementptr %struct.lua_TValue, ptr %48, i64 -1, i32 1
  br label %return

for.end:                                          ; preds = %for.cond
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef %L, ptr noundef nonnull @.str.37)
  unreachable

return:                                           ; preds = %callTMres.exit, %if.then14
  %tt34.i.sink = phi ptr [ %tt34.i, %callTMres.exit ], [ %tt2113, %if.then14 ]
  %add.ptr27.i.sink = phi ptr [ %add.ptr27.i, %callTMres.exit ], [ %val, %if.then14 ]
  %50 = load i32, ptr %tt34.i.sink, align 8
  %tt35.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr27.i.sink, i64 0, i32 1
  store i32 %50, ptr %tt35.i, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaV_settable(ptr noundef %L, ptr nocapture noundef readonly %t, ptr nocapture noundef readonly %key, ptr nocapture noundef readonly %val) unnamed_addr #0 {
entry:
  %temp = alloca %struct.lua_TValue, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %key, i64 0, i32 1
  %l_G = getelementptr %struct.lua_State, ptr %L, i64 0, i32 6
  %tt51 = getelementptr inbounds %struct.lua_TValue, ptr %temp, i64 0, i32 1
  %tt.phi.trans.insert = getelementptr inbounds %struct.lua_TValue, ptr %t, i64 0, i32 1
  %.pre = load i32, ptr %tt.phi.trans.insert, align 8
  br label %for.body

for.body:                                         ; preds = %entry, %if.end45
  %0 = phi i32 [ %.pre, %entry ], [ %43, %if.end45 ]
  %t.addr.082 = phi ptr [ %t, %entry ], [ %temp, %if.end45 ]
  %loop.081 = phi i32 [ 0, %entry ], [ %inc, %if.end45 ]
  switch i32 %0, label %sw.default.i [
    i32 5, label %if.then
    i32 7, label %sw.bb1.i
  ]

if.then:                                          ; preds = %for.body
  %1 = load ptr, ptr %t.addr.082, align 8
  %call.i = tail call fastcc ptr @luaH_get(ptr noundef %1, ptr noundef %key)
  %flags.i = getelementptr inbounds %struct.Table, ptr %1, i64 0, i32 3
  store i8 0, ptr %flags.i, align 2
  %cmp.not.i = icmp eq ptr %call.i, @luaO_nilobject_
  br i1 %cmp.not.i, label %if.else.i, label %luaH_set.exit

if.else.i:                                        ; preds = %if.then
  %2 = load i32, ptr %tt.i, align 8
  switch i32 %2, label %if.end9.i [
    i32 0, label %if.end9.i.sink.split
    i32 3, label %land.lhs.true.i
  ]

land.lhs.true.i:                                  ; preds = %if.else.i
  %3 = load double, ptr %key, align 8
  %cmp7.i = fcmp ord double %3, 0.000000e+00
  br i1 %cmp7.i, label %if.end9.i, label %if.end9.i.sink.split

if.end9.i.sink.split:                             ; preds = %land.lhs.true.i, %if.else.i
  %.str.40.sink = phi ptr [ @.str.39, %if.else.i ], [ @.str.40, %land.lhs.true.i ]
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef %L, ptr noundef nonnull %.str.40.sink)
  unreachable

if.end9.i:                                        ; preds = %land.lhs.true.i, %if.else.i
  %call10.i = tail call fastcc ptr @newkey(ptr noundef %L, ptr noundef nonnull %1, ptr noundef nonnull %key)
  br label %luaH_set.exit

luaH_set.exit:                                    ; preds = %if.then, %if.end9.i
  %retval.0.i = phi ptr [ %call10.i, %if.end9.i ], [ %call.i, %if.then ]
  %tt2 = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i, i64 0, i32 1
  %4 = load i32, ptr %tt2, align 8
  %cmp3 = icmp eq i32 %4, 0
  br i1 %cmp3, label %lor.lhs.false, label %if.then14

lor.lhs.false:                                    ; preds = %luaH_set.exit
  %metatable = getelementptr inbounds %struct.Table, ptr %1, i64 0, i32 5
  %5 = load ptr, ptr %metatable, align 8
  %cmp4 = icmp eq ptr %5, null
  br i1 %cmp4, label %if.then14, label %cond.false

cond.false:                                       ; preds = %lor.lhs.false
  %flags = getelementptr inbounds %struct.Table, ptr %5, i64 0, i32 3
  %6 = load i8, ptr %flags, align 2
  %7 = and i8 %6, 2
  %tobool.not = icmp eq i8 %7, 0
  br i1 %tobool.not, label %cond.false7, label %if.then14

cond.false7:                                      ; preds = %cond.false
  %8 = load ptr, ptr %l_G, align 8
  %arrayidx = getelementptr inbounds %struct.global_State, ptr %8, i64 0, i32 24, i64 1
  %9 = load ptr, ptr %arrayidx, align 8
  %10 = getelementptr i8, ptr %5, i64 11
  %events.val.i = load i8, ptr %10, align 1
  %11 = getelementptr i8, ptr %5, i64 32
  %events.val3.i = load ptr, ptr %11, align 8
  %hash.i.i = getelementptr inbounds %struct.anon.0, ptr %9, i64 0, i32 4
  %12 = load i32, ptr %hash.i.i, align 4
  %sh_prom.i.i = zext nneg i8 %events.val.i to i64
  %notmask.i.i = shl nsw i64 -1, %sh_prom.i.i
  %13 = trunc i64 %notmask.i.i to i32
  %14 = xor i32 %13, -1
  %conv2.i.i = and i32 %12, %14
  %idxprom.i.i = sext i32 %conv2.i.i to i64
  %arrayidx.i.i = getelementptr inbounds %struct.Node, ptr %events.val3.i, i64 %idxprom.i.i
  br label %do.body.i.i

do.body.i.i:                                      ; preds = %if.else.i.i, %cond.false7
  %n.0.i.i = phi ptr [ %arrayidx.i.i, %cond.false7 ], [ %17, %if.else.i.i ]
  %tt.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1, i32 0, i32 1
  %15 = load i32, ptr %tt.i.i, align 8
  %cmp.i.i = icmp eq i32 %15, 4
  br i1 %cmp.i.i, label %land.lhs.true.i.i, label %if.else.i.i

land.lhs.true.i.i:                                ; preds = %do.body.i.i
  %i_key.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1
  %16 = load ptr, ptr %i_key.i.i, align 8
  %cmp5.i.i = icmp eq ptr %16, %9
  br i1 %cmp5.i.i, label %luaH_getstr.exit.i, label %if.else.i.i

if.else.i.i:                                      ; preds = %land.lhs.true.i.i, %do.body.i.i
  %next.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1, i32 0, i32 2
  %17 = load ptr, ptr %next.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %17, null
  br i1 %tobool.not.i.i, label %luaH_getstr.exit.i, label %do.body.i.i, !llvm.loop !29

luaH_getstr.exit.i:                               ; preds = %if.else.i.i, %land.lhs.true.i.i
  %retval.0.i.i = phi ptr [ %n.0.i.i, %land.lhs.true.i.i ], [ @luaO_nilobject_, %if.else.i.i ]
  %tt.i29 = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i.i, i64 0, i32 1
  %18 = load i32, ptr %tt.i29, align 8
  %cmp.i = icmp eq i32 %18, 0
  br i1 %cmp.i, label %if.then.i, label %if.end40

if.then.i:                                        ; preds = %luaH_getstr.exit.i
  %flags.le = getelementptr inbounds %struct.Table, ptr %5, i64 0, i32 3
  %conv3.i = or disjoint i8 %6, 2
  store i8 %conv3.i, ptr %flags.le, align 2
  br label %if.then14

if.then14:                                        ; preds = %cond.false, %lor.lhs.false, %luaH_set.exit, %if.then.i
  %flags.i94 = getelementptr inbounds %struct.Table, ptr %1, i64 0, i32 3
  %tt297 = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i, i64 0, i32 1
  %19 = load i64, ptr %val, align 8
  store i64 %19, ptr %retval.0.i, align 8
  %tt17 = getelementptr inbounds %struct.lua_TValue, ptr %val, i64 0, i32 1
  %20 = load i32, ptr %tt17, align 8
  store i32 %20, ptr %tt297, align 8
  store i8 0, ptr %flags.i94, align 2
  %21 = load i32, ptr %tt17, align 8
  %cmp21 = icmp sgt i32 %21, 3
  br i1 %cmp21, label %land.lhs.true, label %return

land.lhs.true:                                    ; preds = %if.then14
  %22 = load ptr, ptr %val, align 8
  %marked = getelementptr inbounds %struct.GCheader, ptr %22, i64 0, i32 2
  %23 = load i8, ptr %marked, align 1
  %24 = and i8 %23, 3
  %tobool26.not = icmp eq i8 %24, 0
  br i1 %tobool26.not, label %return, label %land.lhs.true27

land.lhs.true27:                                  ; preds = %land.lhs.true
  %marked28 = getelementptr inbounds %struct.GCheader, ptr %1, i64 0, i32 2
  %25 = load i8, ptr %marked28, align 1
  %26 = and i8 %25, 4
  %tobool31.not = icmp eq i8 %26, 0
  br i1 %tobool31.not, label %return, label %if.then32

if.then32:                                        ; preds = %land.lhs.true27
  %L.val = load ptr, ptr %l_G, align 8
  %27 = and i8 %25, -5
  store i8 %27, ptr %marked28, align 1
  %grayagain.i = getelementptr inbounds %struct.global_State, ptr %L.val, i64 0, i32 9
  %28 = load ptr, ptr %grayagain.i, align 8
  %gclist.i = getelementptr inbounds %struct.Table, ptr %1, i64 0, i32 9
  store ptr %28, ptr %gclist.i, align 8
  store ptr %1, ptr %grayagain.i, align 8
  br label %return

sw.bb1.i:                                         ; preds = %for.body
  %29 = load ptr, ptr %t.addr.082, align 8
  %metatable3.i = getelementptr inbounds %struct.anon.1, ptr %29, i64 0, i32 3
  br label %sw.epilog.i

sw.default.i:                                     ; preds = %for.body
  %30 = load ptr, ptr %l_G, align 8
  %idxprom.i = sext i32 %0 to i64
  %arrayidx.i = getelementptr inbounds %struct.global_State, ptr %30, i64 0, i32 23, i64 %idxprom.i
  br label %sw.epilog.i

sw.epilog.i:                                      ; preds = %sw.default.i, %sw.bb1.i
  %mt.0.in.i = phi ptr [ %arrayidx.i, %sw.default.i ], [ %metatable3.i, %sw.bb1.i ]
  %mt.0.i = load ptr, ptr %mt.0.in.i, align 8
  %tobool.not.i = icmp eq ptr %mt.0.i, null
  br i1 %tobool.not.i, label %luaT_gettmbyobj.exit, label %cond.true.i

cond.true.i:                                      ; preds = %sw.epilog.i
  %31 = load ptr, ptr %l_G, align 8
  %arrayidx8.i = getelementptr inbounds %struct.global_State, ptr %31, i64 0, i32 24, i64 1
  %32 = load ptr, ptr %arrayidx8.i, align 8
  %33 = getelementptr i8, ptr %mt.0.i, i64 11
  %mt.0.val.i = load i8, ptr %33, align 1
  %34 = getelementptr i8, ptr %mt.0.i, i64 32
  %mt.0.val6.i = load ptr, ptr %34, align 8
  %hash.i.i33 = getelementptr inbounds %struct.anon.0, ptr %32, i64 0, i32 4
  %35 = load i32, ptr %hash.i.i33, align 4
  %sh_prom.i.i34 = zext nneg i8 %mt.0.val.i to i64
  %notmask.i.i35 = shl nsw i64 -1, %sh_prom.i.i34
  %36 = trunc i64 %notmask.i.i35 to i32
  %37 = xor i32 %36, -1
  %conv2.i.i36 = and i32 %35, %37
  %idxprom.i.i37 = sext i32 %conv2.i.i36 to i64
  %arrayidx.i.i38 = getelementptr inbounds %struct.Node, ptr %mt.0.val6.i, i64 %idxprom.i.i37
  br label %do.body.i.i39

do.body.i.i39:                                    ; preds = %if.else.i.i43, %cond.true.i
  %n.0.i.i40 = phi ptr [ %arrayidx.i.i38, %cond.true.i ], [ %40, %if.else.i.i43 ]
  %tt.i.i41 = getelementptr inbounds %struct.Node, ptr %n.0.i.i40, i64 0, i32 1, i32 0, i32 1
  %38 = load i32, ptr %tt.i.i41, align 8
  %cmp.i.i42 = icmp eq i32 %38, 4
  br i1 %cmp.i.i42, label %land.lhs.true.i.i46, label %if.else.i.i43

land.lhs.true.i.i46:                              ; preds = %do.body.i.i39
  %i_key.i.i47 = getelementptr inbounds %struct.Node, ptr %n.0.i.i40, i64 0, i32 1
  %39 = load ptr, ptr %i_key.i.i47, align 8
  %cmp5.i.i48 = icmp eq ptr %39, %32
  br i1 %cmp5.i.i48, label %luaT_gettmbyobj.exit, label %if.else.i.i43

if.else.i.i43:                                    ; preds = %land.lhs.true.i.i46, %do.body.i.i39
  %next.i.i44 = getelementptr inbounds %struct.Node, ptr %n.0.i.i40, i64 0, i32 1, i32 0, i32 2
  %40 = load ptr, ptr %next.i.i44, align 8
  %tobool.not.i.i45 = icmp eq ptr %40, null
  br i1 %tobool.not.i.i45, label %luaT_gettmbyobj.exit, label %do.body.i.i39, !llvm.loop !29

luaT_gettmbyobj.exit:                             ; preds = %land.lhs.true.i.i46, %if.else.i.i43, %sw.epilog.i
  %cond.i = phi ptr [ @luaO_nilobject_, %sw.epilog.i ], [ %n.0.i.i40, %land.lhs.true.i.i46 ], [ @luaO_nilobject_, %if.else.i.i43 ]
  %tt35 = getelementptr inbounds %struct.lua_TValue, ptr %cond.i, i64 0, i32 1
  %41 = load i32, ptr %tt35, align 8
  %cmp36 = icmp eq i32 %41, 0
  br i1 %cmp36, label %if.then38, label %if.end40

if.then38:                                        ; preds = %luaT_gettmbyobj.exit
  %idxprom.i50 = sext i32 %0 to i64
  %arrayidx.i51 = getelementptr inbounds [11 x ptr], ptr @luaT_typenames, i64 0, i64 %idxprom.i50
  %42 = load ptr, ptr %arrayidx.i51, align 8
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef nonnull %L, ptr noundef nonnull @.str.20, ptr noundef nonnull @.str.36, ptr noundef %42)
  unreachable

if.end40:                                         ; preds = %luaH_getstr.exit.i, %luaT_gettmbyobj.exit
  %43 = phi i32 [ %41, %luaT_gettmbyobj.exit ], [ %18, %luaH_getstr.exit.i ]
  %tm.0 = phi ptr [ %cond.i, %luaT_gettmbyobj.exit ], [ %retval.0.i.i, %luaH_getstr.exit.i ]
  %cmp42 = icmp eq i32 %43, 6
  br i1 %cmp42, label %if.then44, label %if.end45

if.then44:                                        ; preds = %if.end40
  %tt.le = getelementptr inbounds %struct.lua_TValue, ptr %t.addr.082, i64 0, i32 1
  %tt41 = getelementptr inbounds %struct.lua_TValue, ptr %tm.0, i64 0, i32 1
  %top.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %44 = load ptr, ptr %top.i, align 8
  %45 = load i64, ptr %tm.0, align 8
  store i64 %45, ptr %44, align 8
  %46 = load i32, ptr %tt41, align 8
  %tt2.i = getelementptr inbounds %struct.lua_TValue, ptr %44, i64 0, i32 1
  store i32 %46, ptr %tt2.i, align 8
  %47 = load ptr, ptr %top.i, align 8
  %add.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %47, i64 1
  %48 = load i64, ptr %t.addr.082, align 8
  store i64 %48, ptr %add.ptr.i, align 8
  %49 = load i32, ptr %tt.le, align 8
  %tt9.i = getelementptr inbounds %struct.lua_TValue, ptr %47, i64 1, i32 1
  store i32 %49, ptr %tt9.i, align 8
  %50 = load ptr, ptr %top.i, align 8
  %add.ptr13.i = getelementptr inbounds %struct.lua_TValue, ptr %50, i64 2
  %51 = load i64, ptr %key, align 8
  store i64 %51, ptr %add.ptr13.i, align 8
  %52 = load i32, ptr %tt.i, align 8
  %tt17.i = getelementptr inbounds %struct.lua_TValue, ptr %50, i64 2, i32 1
  store i32 %52, ptr %tt17.i, align 8
  %53 = load ptr, ptr %top.i, align 8
  %add.ptr21.i = getelementptr inbounds %struct.lua_TValue, ptr %53, i64 3
  %54 = load i64, ptr %val, align 8
  store i64 %54, ptr %add.ptr21.i, align 8
  %tt24.i = getelementptr inbounds %struct.lua_TValue, ptr %val, i64 0, i32 1
  %55 = load i32, ptr %tt24.i, align 8
  %tt25.i = getelementptr inbounds %struct.lua_TValue, ptr %53, i64 3, i32 1
  store i32 %55, ptr %tt25.i, align 8
  %stack_last.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 9
  %56 = load ptr, ptr %stack_last.i, align 8
  %57 = load ptr, ptr %top.i, align 8
  %sub.ptr.lhs.cast.i = ptrtoint ptr %56 to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %57 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %cmp.i55 = icmp slt i64 %sub.ptr.sub.i, 65
  br i1 %cmp.i55, label %if.then.i56, label %callTM.exit

if.then.i56:                                      ; preds = %if.then44
  %stacksize.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 13
  %58 = load i32, ptr %stacksize.i.i, align 8
  %cmp.not.i.i = icmp slt i32 %58, 4
  %mul.i.i = shl nuw nsw i32 %58, 1
  %add.i.i = add nsw i32 %58, 4
  %mul.i.i.sink = select i1 %cmp.not.i.i, i32 %add.i.i, i32 %mul.i.i
  tail call fastcc void @luaD_reallocstack(ptr noundef nonnull %L, i32 noundef %mul.i.i.sink)
  br label %callTM.exit

callTM.exit:                                      ; preds = %if.then.i56, %if.then44
  %59 = load ptr, ptr %top.i, align 8
  %add.ptr28.i = getelementptr inbounds %struct.lua_TValue, ptr %59, i64 4
  store ptr %add.ptr28.i, ptr %top.i, align 8
  tail call fastcc void @luaD_call(ptr noundef nonnull %L, ptr noundef %59, i32 noundef 0)
  br label %return

if.end45:                                         ; preds = %if.end40
  %60 = load i64, ptr %tm.0, align 8
  store i64 %60, ptr %temp, align 8
  store i32 %43, ptr %tt51, align 8
  %inc = add nuw nsw i32 %loop.081, 1
  %exitcond.not = icmp eq i32 %inc, 100
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !45

for.end:                                          ; preds = %if.end45
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef %L, ptr noundef nonnull @.str.38)
  unreachable

return:                                           ; preds = %if.then14, %land.lhs.true, %land.lhs.true27, %if.then32, %callTM.exit
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @Arith(ptr noundef %L, ptr noundef %ra, ptr noundef readonly %rb, ptr nocapture noundef readonly %rc, i32 noundef %op) unnamed_addr #0 {
entry:
  %endptr.i.i67 = alloca ptr, align 8
  %temp.i = alloca %struct.lua_TValue, align 8
  %endptr.i.i34 = alloca ptr, align 8
  %endptr.i.i = alloca ptr, align 8
  %tempb.sroa.0 = alloca ptr, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %rb, i64 0, i32 1
  %0 = load i32, ptr %tt.i, align 8
  switch i32 %0, label %if.else [
    i32 3, label %land.lhs.true
    i32 4, label %land.lhs.true.i
  ]

land.lhs.true.i:                                  ; preds = %entry
  %1 = load ptr, ptr %rb, align 8
  %add.ptr.i = getelementptr inbounds %union.TString, ptr %1, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i)
  %call.i.i = call double @strtod(ptr noundef nonnull %add.ptr.i, ptr noundef nonnull %endptr.i.i) #35
  %2 = load ptr, ptr %endptr.i.i, align 8
  %cmp.i.i = icmp eq ptr %2, %add.ptr.i
  br i1 %cmp.i.i, label %luaO_str2d.exit.thread.i, label %if.end.i.i

luaO_str2d.exit.thread.i:                         ; preds = %land.lhs.true.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i)
  br label %if.else

if.end.i.i:                                       ; preds = %land.lhs.true.i
  %3 = load i8, ptr %2, align 1
  switch i8 %3, label %if.end9.i.i [
    i8 120, label %if.then6.i.i
    i8 88, label %if.then6.i.i
  ]

if.then6.i.i:                                     ; preds = %if.end.i.i, %if.end.i.i
  %call7.i.i = call i64 @strtoul(ptr noundef nonnull %add.ptr.i, ptr noundef nonnull %endptr.i.i, i32 noundef 16) #35
  %conv8.i.i = uitofp i64 %call7.i.i to double
  %.pre.i.i = load ptr, ptr %endptr.i.i, align 8
  %.pre5.i.i = load i8, ptr %.pre.i.i, align 1
  br label %if.end9.i.i

if.end9.i.i:                                      ; preds = %if.then6.i.i, %if.end.i.i
  %num.0.i = phi double [ %call.i.i, %if.end.i.i ], [ %conv8.i.i, %if.then6.i.i ]
  %4 = phi i8 [ %3, %if.end.i.i ], [ %.pre5.i.i, %if.then6.i.i ]
  %endptr.promoted.i.i = phi ptr [ %2, %if.end.i.i ], [ %.pre.i.i, %if.then6.i.i ]
  %cmp11.i.i = icmp eq i8 %4, 0
  br i1 %cmp11.i.i, label %luaO_str2d.exit.thread9.i, label %while.cond.preheader.i.i

luaO_str2d.exit.thread9.i:                        ; preds = %if.end9.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i)
  br label %if.then3.i

while.cond.preheader.i.i:                         ; preds = %if.end9.i.i
  %call15.i.i = tail call ptr @__ctype_b_loc() #39
  %5 = load ptr, ptr %call15.i.i, align 8
  br label %while.cond.i.i

while.cond.i.i:                                   ; preds = %while.cond.i.i, %while.cond.preheader.i.i
  %incdec.ptr4.i.i = phi ptr [ %endptr.promoted.i.i, %while.cond.preheader.i.i ], [ %incdec.ptr.i.i, %while.cond.i.i ]
  %6 = load i8, ptr %incdec.ptr4.i.i, align 1
  %idxprom.i.i = zext i8 %6 to i64
  %arrayidx.i.i = getelementptr inbounds i16, ptr %5, i64 %idxprom.i.i
  %7 = load i16, ptr %arrayidx.i.i, align 2
  %8 = and i16 %7, 8192
  %tobool.not.i.i = icmp eq i16 %8, 0
  %incdec.ptr.i.i = getelementptr inbounds i8, ptr %incdec.ptr4.i.i, i64 1
  br i1 %tobool.not.i.i, label %luaO_str2d.exit.i, label %while.cond.i.i, !llvm.loop !35

luaO_str2d.exit.i:                                ; preds = %while.cond.i.i
  %cmp19.not.i.not.i = icmp eq i8 %6, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i)
  br i1 %cmp19.not.i.not.i, label %if.then3.i, label %if.else

if.then3.i:                                       ; preds = %luaO_str2d.exit.i, %luaO_str2d.exit.thread9.i
  store double %num.0.i, ptr %tempb.sroa.0, align 8
  br label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then3.i, %entry
  %retval.0.i.ph = phi ptr [ %rb, %entry ], [ %tempb.sroa.0, %if.then3.i ]
  %tt.i35 = getelementptr inbounds %struct.lua_TValue, ptr %rc, i64 0, i32 1
  %9 = load i32, ptr %tt.i35, align 8
  switch i32 %9, label %if.else [
    i32 3, label %land.lhs.true.if.then_crit_edge
    i32 4, label %land.lhs.true.i36
  ]

land.lhs.true.if.then_crit_edge:                  ; preds = %land.lhs.true
  %.pre = load double, ptr %rc, align 8
  br label %if.then

land.lhs.true.i36:                                ; preds = %land.lhs.true
  %10 = load ptr, ptr %rc, align 8
  %add.ptr.i37 = getelementptr inbounds %union.TString, ptr %10, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i34)
  %call.i.i38 = call double @strtod(ptr noundef nonnull %add.ptr.i37, ptr noundef nonnull %endptr.i.i34) #35
  %11 = load ptr, ptr %endptr.i.i34, align 8
  %cmp.i.i39 = icmp eq ptr %11, %add.ptr.i37
  br i1 %cmp.i.i39, label %luaO_str2d.exit.thread.i65, label %if.end.i.i40

luaO_str2d.exit.thread.i65:                       ; preds = %land.lhs.true.i36
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i34)
  br label %if.else

if.end.i.i40:                                     ; preds = %land.lhs.true.i36
  %12 = load i8, ptr %11, align 1
  switch i8 %12, label %if.end9.i.i46 [
    i8 120, label %if.then6.i.i41
    i8 88, label %if.then6.i.i41
  ]

if.then6.i.i41:                                   ; preds = %if.end.i.i40, %if.end.i.i40
  %call7.i.i42 = call i64 @strtoul(ptr noundef nonnull %add.ptr.i37, ptr noundef nonnull %endptr.i.i34, i32 noundef 16) #35
  %conv8.i.i43 = uitofp i64 %call7.i.i42 to double
  %.pre.i.i44 = load ptr, ptr %endptr.i.i34, align 8
  %.pre5.i.i45 = load i8, ptr %.pre.i.i44, align 1
  br label %if.end9.i.i46

if.end9.i.i46:                                    ; preds = %if.then6.i.i41, %if.end.i.i40
  %num.0.i47 = phi double [ %call.i.i38, %if.end.i.i40 ], [ %conv8.i.i43, %if.then6.i.i41 ]
  %13 = phi i8 [ %12, %if.end.i.i40 ], [ %.pre5.i.i45, %if.then6.i.i41 ]
  %endptr.promoted.i.i48 = phi ptr [ %11, %if.end.i.i40 ], [ %.pre.i.i44, %if.then6.i.i41 ]
  %cmp11.i.i49 = icmp eq i8 %13, 0
  br i1 %cmp11.i.i49, label %luaO_str2d.exit.thread9.i64, label %while.cond.preheader.i.i50

luaO_str2d.exit.thread9.i64:                      ; preds = %if.end9.i.i46
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i34)
  br label %if.then

while.cond.preheader.i.i50:                       ; preds = %if.end9.i.i46
  %call15.i.i51 = tail call ptr @__ctype_b_loc() #39
  %14 = load ptr, ptr %call15.i.i51, align 8
  br label %while.cond.i.i52

while.cond.i.i52:                                 ; preds = %while.cond.i.i52, %while.cond.preheader.i.i50
  %incdec.ptr4.i.i53 = phi ptr [ %endptr.promoted.i.i48, %while.cond.preheader.i.i50 ], [ %incdec.ptr.i.i57, %while.cond.i.i52 ]
  %15 = load i8, ptr %incdec.ptr4.i.i53, align 1
  %idxprom.i.i54 = zext i8 %15 to i64
  %arrayidx.i.i55 = getelementptr inbounds i16, ptr %14, i64 %idxprom.i.i54
  %16 = load i16, ptr %arrayidx.i.i55, align 2
  %17 = and i16 %16, 8192
  %tobool.not.i.i56 = icmp eq i16 %17, 0
  %incdec.ptr.i.i57 = getelementptr inbounds i8, ptr %incdec.ptr4.i.i53, i64 1
  br i1 %tobool.not.i.i56, label %luaO_str2d.exit.i58, label %while.cond.i.i52, !llvm.loop !35

luaO_str2d.exit.i58:                              ; preds = %while.cond.i.i52
  %cmp19.not.i.not.i59 = icmp eq i8 %15, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i34)
  br i1 %cmp19.not.i.not.i59, label %if.then, label %if.else

if.then:                                          ; preds = %luaO_str2d.exit.thread9.i64, %luaO_str2d.exit.i58, %land.lhs.true.if.then_crit_edge
  %18 = phi double [ %.pre, %land.lhs.true.if.then_crit_edge ], [ %num.0.i47, %luaO_str2d.exit.i58 ], [ %num.0.i47, %luaO_str2d.exit.thread9.i64 ]
  %19 = load double, ptr %retval.0.i.ph, align 8
  switch i32 %op, label %if.end34 [
    i32 5, label %sw.bb
    i32 6, label %sw.bb5
    i32 7, label %sw.bb9
    i32 8, label %sw.bb13
    i32 9, label %sw.bb17
    i32 10, label %sw.bb23
    i32 11, label %sw.bb28
  ]

sw.bb:                                            ; preds = %if.then
  %add = fadd double %19, %18
  br label %if.end34.sink.split

sw.bb5:                                           ; preds = %if.then
  %sub = fsub double %19, %18
  br label %if.end34.sink.split

sw.bb9:                                           ; preds = %if.then
  %mul = fmul double %19, %18
  br label %if.end34.sink.split

sw.bb13:                                          ; preds = %if.then
  %div = fdiv double %19, %18
  br label %if.end34.sink.split

sw.bb17:                                          ; preds = %if.then
  %div19 = fdiv double %19, %18
  %20 = tail call double @llvm.floor.f64(double %div19)
  %neg = fneg double %20
  %21 = tail call double @llvm.fmuladd.f64(double %neg, double %18, double %19)
  br label %if.end34.sink.split

sw.bb23:                                          ; preds = %if.then
  %call25 = tail call double @pow(double noundef %19, double noundef %18) #35
  br label %if.end34.sink.split

sw.bb28:                                          ; preds = %if.then
  %fneg = fneg double %19
  br label %if.end34.sink.split

if.else:                                          ; preds = %luaO_str2d.exit.i58, %luaO_str2d.exit.thread.i65, %land.lhs.true, %luaO_str2d.exit.i, %luaO_str2d.exit.thread.i, %entry
  %call32 = tail call fastcc i32 @call_binTM(ptr noundef %L, ptr noundef %rb, ptr noundef %rc, ptr noundef %ra, i32 noundef %op), !range !23
  %tobool.not = icmp eq i32 %call32, 0
  br i1 %tobool.not, label %if.then33, label %if.end34

if.then33:                                        ; preds = %if.else
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %temp.i)
  %22 = load i32, ptr %tt.i, align 8
  switch i32 %22, label %if.else.i93 [
    i32 3, label %luaV_tonumber.exit99
    i32 4, label %land.lhs.true.i69
  ]

land.lhs.true.i69:                                ; preds = %if.then33
  %23 = load ptr, ptr %rb, align 8
  %add.ptr.i70 = getelementptr inbounds %union.TString, ptr %23, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i67)
  %call.i.i71 = call double @strtod(ptr noundef nonnull %add.ptr.i70, ptr noundef nonnull %endptr.i.i67) #35
  %24 = load ptr, ptr %endptr.i.i67, align 8
  %cmp.i.i72 = icmp eq ptr %24, %add.ptr.i70
  br i1 %cmp.i.i72, label %luaO_str2d.exit.thread.i98, label %if.end.i.i73

luaO_str2d.exit.thread.i98:                       ; preds = %land.lhs.true.i69
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i67)
  br label %if.else.i93

if.end.i.i73:                                     ; preds = %land.lhs.true.i69
  %25 = load i8, ptr %24, align 1
  switch i8 %25, label %if.end9.i.i79 [
    i8 120, label %if.then6.i.i74
    i8 88, label %if.then6.i.i74
  ]

if.then6.i.i74:                                   ; preds = %if.end.i.i73, %if.end.i.i73
  %call7.i.i75 = call i64 @strtoul(ptr noundef nonnull %add.ptr.i70, ptr noundef nonnull %endptr.i.i67, i32 noundef 16) #35
  %conv8.i.i76 = uitofp i64 %call7.i.i75 to double
  %.pre.i.i77 = load ptr, ptr %endptr.i.i67, align 8
  %.pre5.i.i78 = load i8, ptr %.pre.i.i77, align 1
  br label %if.end9.i.i79

if.end9.i.i79:                                    ; preds = %if.then6.i.i74, %if.end.i.i73
  %num.0.i80 = phi double [ %call.i.i71, %if.end.i.i73 ], [ %conv8.i.i76, %if.then6.i.i74 ]
  %26 = phi i8 [ %25, %if.end.i.i73 ], [ %.pre5.i.i78, %if.then6.i.i74 ]
  %endptr.promoted.i.i81 = phi ptr [ %24, %if.end.i.i73 ], [ %.pre.i.i77, %if.then6.i.i74 ]
  %cmp11.i.i82 = icmp eq i8 %26, 0
  br i1 %cmp11.i.i82, label %luaO_str2d.exit.thread9.i97, label %while.cond.preheader.i.i83

luaO_str2d.exit.thread9.i97:                      ; preds = %if.end9.i.i79
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i67)
  br label %if.then3.i95

while.cond.preheader.i.i83:                       ; preds = %if.end9.i.i79
  %call15.i.i84 = tail call ptr @__ctype_b_loc() #39
  %27 = load ptr, ptr %call15.i.i84, align 8
  br label %while.cond.i.i85

while.cond.i.i85:                                 ; preds = %while.cond.i.i85, %while.cond.preheader.i.i83
  %incdec.ptr4.i.i86 = phi ptr [ %endptr.promoted.i.i81, %while.cond.preheader.i.i83 ], [ %incdec.ptr.i.i90, %while.cond.i.i85 ]
  %28 = load i8, ptr %incdec.ptr4.i.i86, align 1
  %idxprom.i.i87 = zext i8 %28 to i64
  %arrayidx.i.i88 = getelementptr inbounds i16, ptr %27, i64 %idxprom.i.i87
  %29 = load i16, ptr %arrayidx.i.i88, align 2
  %30 = and i16 %29, 8192
  %tobool.not.i.i89 = icmp eq i16 %30, 0
  %incdec.ptr.i.i90 = getelementptr inbounds i8, ptr %incdec.ptr4.i.i86, i64 1
  br i1 %tobool.not.i.i89, label %luaO_str2d.exit.i91, label %while.cond.i.i85, !llvm.loop !35

luaO_str2d.exit.i91:                              ; preds = %while.cond.i.i85
  %cmp19.not.i.not.i92 = icmp eq i8 %28, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i67)
  br i1 %cmp19.not.i.not.i92, label %if.then3.i95, label %if.else.i93

if.then3.i95:                                     ; preds = %luaO_str2d.exit.i91, %luaO_str2d.exit.thread9.i97
  store double %num.0.i80, ptr %temp.i, align 8
  %tt5.i96 = getelementptr inbounds %struct.lua_TValue, ptr %temp.i, i64 0, i32 1
  store i32 3, ptr %tt5.i96, align 8
  br label %luaV_tonumber.exit99

if.else.i93:                                      ; preds = %luaO_str2d.exit.i91, %luaO_str2d.exit.thread.i98, %if.then33
  br label %luaV_tonumber.exit99

luaV_tonumber.exit99:                             ; preds = %if.then33, %if.then3.i95, %if.else.i93
  %retval.0.i94 = phi ptr [ %temp.i, %if.then3.i95 ], [ null, %if.else.i93 ], [ %rb, %if.then33 ]
  %cmp.i = icmp eq ptr %retval.0.i94, null
  %spec.select.i = select i1 %cmp.i, ptr %rb, ptr %rc
  %tt.i100 = getelementptr inbounds %struct.lua_TValue, ptr %spec.select.i, i64 0, i32 1
  %31 = load i32, ptr %tt.i100, align 8
  %idxprom.i = sext i32 %31 to i64
  %arrayidx.i = getelementptr inbounds [11 x ptr], ptr @luaT_typenames, i64 0, i64 %idxprom.i
  %32 = load ptr, ptr %arrayidx.i, align 8
  call void (ptr, ptr, ...) @luaG_runerror(ptr noundef nonnull %L, ptr noundef nonnull @.str.20, ptr noundef nonnull @.str.42, ptr noundef %32)
  unreachable

if.end34.sink.split:                              ; preds = %sw.bb28, %sw.bb23, %sw.bb17, %sw.bb13, %sw.bb9, %sw.bb5, %sw.bb
  %add.sink = phi double [ %add, %sw.bb ], [ %sub, %sw.bb5 ], [ %mul, %sw.bb9 ], [ %div, %sw.bb13 ], [ %21, %sw.bb17 ], [ %call25, %sw.bb23 ], [ %fneg, %sw.bb28 ]
  store double %add.sink, ptr %ra, align 8
  %tt = getelementptr inbounds %struct.lua_TValue, ptr %ra, i64 0, i32 1
  store i32 3, ptr %tt, align 8
  br label %if.end34

if.end34:                                         ; preds = %if.end34.sink.split, %if.else, %if.then
  ret void
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.floor.f64(double) #12

; Function Attrs: mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.fmuladd.f64(double, double, double) #12

; Function Attrs: mustprogress nofree nounwind willreturn memory(write)
declare double @pow(double noundef, double noundef) local_unnamed_addr #13

; Function Attrs: nofree norecurse nosync nounwind memory(read, inaccessiblemem: none) uwtable
define internal fastcc i32 @luaH_getn(ptr nocapture noundef readonly %t) unnamed_addr #14 {
entry:
  %sizearray = getelementptr inbounds %struct.Table, ptr %t, i64 0, i32 10
  %0 = load i32, ptr %sizearray, align 8
  %cmp.not = icmp eq i32 %0, 0
  br i1 %cmp.not, label %if.else11, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %array = getelementptr inbounds %struct.Table, ptr %t, i64 0, i32 6
  %1 = load ptr, ptr %array, align 8
  %sub = add i32 %0, -1
  %idxprom = zext i32 %sub to i64
  %tt = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 %idxprom, i32 1
  %2 = load i32, ptr %tt, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %while.cond.preheader, label %if.else11

while.cond.preheader:                             ; preds = %land.lhs.true
  %cmp319.not = icmp eq i32 %0, 1
  br i1 %cmp319.not, label %return, label %while.body

while.body:                                       ; preds = %while.cond.preheader, %while.body
  %i.021 = phi i32 [ %i.0.div14, %while.body ], [ 0, %while.cond.preheader ]
  %j.020 = phi i32 [ %div14.j.0, %while.body ], [ %0, %while.cond.preheader ]
  %add = add i32 %i.021, %j.020
  %div14 = lshr i32 %add, 1
  %sub5 = add nsw i32 %div14, -1
  %idxprom6 = zext i32 %sub5 to i64
  %tt8 = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 %idxprom6, i32 1
  %3 = load i32, ptr %tt8, align 8
  %cmp9 = icmp eq i32 %3, 0
  %div14.j.0 = select i1 %cmp9, i32 %div14, i32 %j.020
  %i.0.div14 = select i1 %cmp9, i32 %i.021, i32 %div14
  %sub2 = sub i32 %div14.j.0, %i.0.div14
  %cmp3 = icmp ugt i32 %sub2, 1
  br i1 %cmp3, label %while.body, label %return, !llvm.loop !46

if.else11:                                        ; preds = %land.lhs.true, %entry
  %node = getelementptr inbounds %struct.Table, ptr %t, i64 0, i32 7
  %4 = load ptr, ptr %node, align 8
  %cmp12 = icmp eq ptr %4, @dummynode_
  br i1 %cmp12, label %return, label %if.else14

if.else14:                                        ; preds = %if.else11
  %inc.i = add i32 %0, 1
  %lsizenode.i.i.i = getelementptr inbounds %struct.Table, ptr %t, i64 0, i32 4
  %array.i.i = getelementptr inbounds %struct.Table, ptr %t, i64 0, i32 6
  br label %while.cond.i

while.cond.i:                                     ; preds = %while.body.i, %if.else14
  %j.addr.0.i = phi i32 [ %inc.i, %if.else14 ], [ %mul.i, %while.body.i ]
  %i.0.i = phi i32 [ %0, %if.else14 ], [ %j.addr.0.i, %while.body.i ]
  %sub.i.i = add i32 %j.addr.0.i, -1
  %cmp.i.i = icmp ult i32 %sub.i.i, %0
  br i1 %cmp.i.i, label %if.then.i.i, label %if.else.i.i

if.then.i.i:                                      ; preds = %while.cond.i
  %5 = load ptr, ptr %array.i.i, align 8
  %idxprom.i.i = sext i32 %sub.i.i to i64
  %arrayidx.i.i = getelementptr inbounds %struct.lua_TValue, ptr %5, i64 %idxprom.i.i
  br label %luaH_getnum.exit.i

if.else.i.i:                                      ; preds = %while.cond.i
  %conv.i.i = sitofp i32 %j.addr.0.i to double
  %cmp.i.i.i = icmp eq i32 %j.addr.0.i, 0
  br i1 %cmp.i.i.i, label %do.body.i.i.preheader, label %if.end.i.i.i

if.end.i.i.i:                                     ; preds = %if.else.i.i
  %6 = bitcast double %conv.i.i to i64
  %a.sroa.0.4.extract.shift.i.i.i = lshr i64 %6, 32
  %add.i.i.i = add i64 %a.sroa.0.4.extract.shift.i.i.i, %6
  %conv.i.i.i = and i64 %add.i.i.i, 4294967295
  %7 = load i8, ptr %lsizenode.i.i.i, align 1
  %sh_prom.i.i.i = zext nneg i8 %7 to i64
  %notmask.i.i.i = shl nsw i64 -1, %sh_prom.i.i.i
  %sub.i.i.i = xor i64 %notmask.i.i.i, -1
  %or.i.i.i = or i64 %sub.i.i.i, 1
  %rem.i.i.i = urem i64 %conv.i.i.i, %or.i.i.i
  %arrayidx7.i.i.i = getelementptr inbounds %struct.Node, ptr %4, i64 %rem.i.i.i
  br label %do.body.i.i.preheader

do.body.i.i.preheader:                            ; preds = %if.else.i.i, %if.end.i.i.i
  %n.0.i.i.ph = phi ptr [ %4, %if.else.i.i ], [ %arrayidx7.i.i.i, %if.end.i.i.i ]
  br label %do.body.i.i

do.body.i.i:                                      ; preds = %do.body.i.i.preheader, %if.else8.i.i
  %n.0.i.i = phi ptr [ %10, %if.else8.i.i ], [ %n.0.i.i.ph, %do.body.i.i.preheader ]
  %tt.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1, i32 0, i32 1
  %8 = load i32, ptr %tt.i.i, align 8
  %cmp2.i.i = icmp eq i32 %8, 3
  br i1 %cmp2.i.i, label %land.lhs.true.i.i, label %if.else8.i.i

land.lhs.true.i.i:                                ; preds = %do.body.i.i
  %i_key.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1
  %9 = load double, ptr %i_key.i.i, align 8
  %cmp5.i.i = fcmp oeq double %9, %conv.i.i
  br i1 %cmp5.i.i, label %luaH_getnum.exit.i, label %if.else8.i.i

if.else8.i.i:                                     ; preds = %land.lhs.true.i.i, %do.body.i.i
  %next.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1, i32 0, i32 2
  %10 = load ptr, ptr %next.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %10, null
  br i1 %tobool.not.i.i, label %luaH_getnum.exit.i, label %do.body.i.i, !llvm.loop !7

luaH_getnum.exit.i:                               ; preds = %if.else8.i.i, %land.lhs.true.i.i, %if.then.i.i
  %retval.0.i.i = phi ptr [ %arrayidx.i.i, %if.then.i.i ], [ @luaO_nilobject_, %if.else8.i.i ], [ %n.0.i.i, %land.lhs.true.i.i ]
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i.i, i64 0, i32 1
  %11 = load i32, ptr %tt.i, align 8
  %cmp.not.i = icmp eq i32 %11, 0
  br i1 %cmp.not.i, label %while.cond10.preheader.i, label %while.body.i

while.cond10.preheader.i:                         ; preds = %luaH_getnum.exit.i
  %sub1198.i = sub i32 %j.addr.0.i, %i.0.i
  %cmp1299.i = icmp ugt i32 %sub1198.i, 1
  br i1 %cmp1299.i, label %while.body13.i, label %return

while.body.i:                                     ; preds = %luaH_getnum.exit.i
  %mul.i = shl i32 %j.addr.0.i, 1
  %cmp1.i = icmp ugt i32 %mul.i, 2147483645
  br i1 %cmp1.i, label %while.cond2.i, label %while.cond.i, !llvm.loop !47

while.cond2.i:                                    ; preds = %while.body.i, %luaH_getnum.exit55.i
  %i.1.i = phi i32 [ %inc8.i, %luaH_getnum.exit55.i ], [ 1, %while.body.i ]
  %sub.i18.i = add i32 %i.1.i, -1
  %cmp.i20.i = icmp ult i32 %sub.i18.i, %0
  br i1 %cmp.i20.i, label %if.then.i51.i, label %if.else.i21.i

if.then.i51.i:                                    ; preds = %while.cond2.i
  %12 = load ptr, ptr %array.i.i, align 8
  %idxprom.i53.i = sext i32 %sub.i18.i to i64
  %arrayidx.i54.i = getelementptr inbounds %struct.lua_TValue, ptr %12, i64 %idxprom.i53.i
  br label %luaH_getnum.exit55.i

if.else.i21.i:                                    ; preds = %while.cond2.i
  %conv.i22.i = sitofp i32 %i.1.i to double
  %cmp.i.i23.i = icmp eq i32 %i.1.i, 0
  br i1 %cmp.i.i23.i, label %do.body.i38.i.preheader, label %if.end.i.i24.i

if.end.i.i24.i:                                   ; preds = %if.else.i21.i
  %13 = bitcast double %conv.i22.i to i64
  %a.sroa.0.4.extract.shift.i.i25.i = lshr i64 %13, 32
  %add.i.i26.i = add i64 %a.sroa.0.4.extract.shift.i.i25.i, %13
  %conv.i.i28.i = and i64 %add.i.i26.i, 4294967295
  %14 = load i8, ptr %lsizenode.i.i.i, align 1
  %sh_prom.i.i30.i = zext nneg i8 %14 to i64
  %notmask.i.i31.i = shl nsw i64 -1, %sh_prom.i.i30.i
  %sub.i.i32.i = xor i64 %notmask.i.i31.i, -1
  %or.i.i33.i = or i64 %sub.i.i32.i, 1
  %rem.i.i34.i = urem i64 %conv.i.i28.i, %or.i.i33.i
  %arrayidx7.i.i35.i = getelementptr inbounds %struct.Node, ptr %4, i64 %rem.i.i34.i
  br label %do.body.i38.i.preheader

do.body.i38.i.preheader:                          ; preds = %if.else.i21.i, %if.end.i.i24.i
  %n.0.i39.i.ph = phi ptr [ %4, %if.else.i21.i ], [ %arrayidx7.i.i35.i, %if.end.i.i24.i ]
  br label %do.body.i38.i

do.body.i38.i:                                    ; preds = %do.body.i38.i.preheader, %if.else8.i42.i
  %n.0.i39.i = phi ptr [ %17, %if.else8.i42.i ], [ %n.0.i39.i.ph, %do.body.i38.i.preheader ]
  %tt.i40.i = getelementptr inbounds %struct.Node, ptr %n.0.i39.i, i64 0, i32 1, i32 0, i32 1
  %15 = load i32, ptr %tt.i40.i, align 8
  %cmp2.i41.i = icmp eq i32 %15, 3
  br i1 %cmp2.i41.i, label %land.lhs.true.i46.i, label %if.else8.i42.i

land.lhs.true.i46.i:                              ; preds = %do.body.i38.i
  %i_key.i47.i = getelementptr inbounds %struct.Node, ptr %n.0.i39.i, i64 0, i32 1
  %16 = load double, ptr %i_key.i47.i, align 8
  %cmp5.i48.i = fcmp oeq double %16, %conv.i22.i
  br i1 %cmp5.i48.i, label %luaH_getnum.exit55.i, label %if.else8.i42.i

if.else8.i42.i:                                   ; preds = %land.lhs.true.i46.i, %do.body.i38.i
  %next.i43.i = getelementptr inbounds %struct.Node, ptr %n.0.i39.i, i64 0, i32 1, i32 0, i32 2
  %17 = load ptr, ptr %next.i43.i, align 8
  %tobool.not.i44.i = icmp eq ptr %17, null
  br i1 %tobool.not.i44.i, label %luaH_getnum.exit55.i, label %do.body.i38.i, !llvm.loop !7

luaH_getnum.exit55.i:                             ; preds = %if.else8.i42.i, %land.lhs.true.i46.i, %if.then.i51.i
  %retval.0.i45.i = phi ptr [ %arrayidx.i54.i, %if.then.i51.i ], [ @luaO_nilobject_, %if.else8.i42.i ], [ %n.0.i39.i, %land.lhs.true.i46.i ]
  %tt4.i = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i45.i, i64 0, i32 1
  %18 = load i32, ptr %tt4.i, align 8
  %cmp5.not.i = icmp eq i32 %18, 0
  %inc8.i = add i32 %i.1.i, 1
  br i1 %cmp5.not.i, label %return, label %while.cond2.i, !llvm.loop !48

while.body13.i:                                   ; preds = %while.cond10.preheader.i, %luaH_getnum.exit93.i
  %i.2101.i = phi i32 [ %i.2.div17.i, %luaH_getnum.exit93.i ], [ %i.0.i, %while.cond10.preheader.i ]
  %j.addr.1100.i = phi i32 [ %div17.j.addr.1.i, %luaH_getnum.exit93.i ], [ %j.addr.0.i, %while.cond10.preheader.i ]
  %add.i = add i32 %j.addr.1100.i, %i.2101.i
  %div17.i = lshr i32 %add.i, 1
  %sub.i56.i = add nsw i32 %div17.i, -1
  %cmp.i58.i = icmp ult i32 %sub.i56.i, %0
  br i1 %cmp.i58.i, label %if.then.i89.i, label %if.else.i59.i

if.then.i89.i:                                    ; preds = %while.body13.i
  %19 = load ptr, ptr %array.i.i, align 8
  %idxprom.i91.i = zext nneg i32 %sub.i56.i to i64
  %arrayidx.i92.i = getelementptr inbounds %struct.lua_TValue, ptr %19, i64 %idxprom.i91.i
  br label %luaH_getnum.exit93.i

if.else.i59.i:                                    ; preds = %while.body13.i
  %conv.i60.i = sitofp i32 %div17.i to double
  %cmp.i.i61.i = icmp ult i32 %add.i, 2
  br i1 %cmp.i.i61.i, label %do.body.i76.i.preheader, label %if.end.i.i62.i

if.end.i.i62.i:                                   ; preds = %if.else.i59.i
  %20 = bitcast double %conv.i60.i to i64
  %a.sroa.0.4.extract.shift.i.i63.i = lshr i64 %20, 32
  %add.i.i64.i = add i64 %a.sroa.0.4.extract.shift.i.i63.i, %20
  %conv.i.i66.i = and i64 %add.i.i64.i, 4294967295
  %21 = load i8, ptr %lsizenode.i.i.i, align 1
  %sh_prom.i.i68.i = zext nneg i8 %21 to i64
  %notmask.i.i69.i = shl nsw i64 -1, %sh_prom.i.i68.i
  %sub.i.i70.i = xor i64 %notmask.i.i69.i, -1
  %or.i.i71.i = or i64 %sub.i.i70.i, 1
  %rem.i.i72.i = urem i64 %conv.i.i66.i, %or.i.i71.i
  %arrayidx7.i.i73.i = getelementptr inbounds %struct.Node, ptr %4, i64 %rem.i.i72.i
  br label %do.body.i76.i.preheader

do.body.i76.i.preheader:                          ; preds = %if.else.i59.i, %if.end.i.i62.i
  %n.0.i77.i.ph = phi ptr [ %4, %if.else.i59.i ], [ %arrayidx7.i.i73.i, %if.end.i.i62.i ]
  br label %do.body.i76.i

do.body.i76.i:                                    ; preds = %do.body.i76.i.preheader, %if.else8.i80.i
  %n.0.i77.i = phi ptr [ %24, %if.else8.i80.i ], [ %n.0.i77.i.ph, %do.body.i76.i.preheader ]
  %tt.i78.i = getelementptr inbounds %struct.Node, ptr %n.0.i77.i, i64 0, i32 1, i32 0, i32 1
  %22 = load i32, ptr %tt.i78.i, align 8
  %cmp2.i79.i = icmp eq i32 %22, 3
  br i1 %cmp2.i79.i, label %land.lhs.true.i84.i, label %if.else8.i80.i

land.lhs.true.i84.i:                              ; preds = %do.body.i76.i
  %i_key.i85.i = getelementptr inbounds %struct.Node, ptr %n.0.i77.i, i64 0, i32 1
  %23 = load double, ptr %i_key.i85.i, align 8
  %cmp5.i86.i = fcmp oeq double %23, %conv.i60.i
  br i1 %cmp5.i86.i, label %luaH_getnum.exit93.i, label %if.else8.i80.i

if.else8.i80.i:                                   ; preds = %land.lhs.true.i84.i, %do.body.i76.i
  %next.i81.i = getelementptr inbounds %struct.Node, ptr %n.0.i77.i, i64 0, i32 1, i32 0, i32 2
  %24 = load ptr, ptr %next.i81.i, align 8
  %tobool.not.i82.i = icmp eq ptr %24, null
  br i1 %tobool.not.i82.i, label %luaH_getnum.exit93.i, label %do.body.i76.i, !llvm.loop !7

luaH_getnum.exit93.i:                             ; preds = %if.else8.i80.i, %land.lhs.true.i84.i, %if.then.i89.i
  %retval.0.i83.i = phi ptr [ %arrayidx.i92.i, %if.then.i89.i ], [ @luaO_nilobject_, %if.else8.i80.i ], [ %n.0.i77.i, %land.lhs.true.i84.i ]
  %tt15.i = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i83.i, i64 0, i32 1
  %25 = load i32, ptr %tt15.i, align 8
  %cmp16.i = icmp eq i32 %25, 0
  %div17.j.addr.1.i = select i1 %cmp16.i, i32 %div17.i, i32 %j.addr.1100.i
  %i.2.div17.i = select i1 %cmp16.i, i32 %i.2101.i, i32 %div17.i
  %sub11.i = sub i32 %div17.j.addr.1.i, %i.2.div17.i
  %cmp12.i = icmp ugt i32 %sub11.i, 1
  br i1 %cmp12.i, label %while.body13.i, label %return, !llvm.loop !49

return:                                           ; preds = %while.body, %luaH_getnum.exit55.i, %luaH_getnum.exit93.i, %while.cond.preheader, %while.cond10.preheader.i, %if.else11
  %retval.0 = phi i32 [ %0, %if.else11 ], [ %i.0.i, %while.cond10.preheader.i ], [ 0, %while.cond.preheader ], [ %i.2.div17.i, %luaH_getnum.exit93.i ], [ %sub.i18.i, %luaH_getnum.exit55.i ], [ %i.0.div14, %while.body ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @luaV_lessthan(ptr noundef %L, ptr nocapture noundef readonly %l, ptr nocapture noundef readonly %r) unnamed_addr #0 {
entry:
  %tt = getelementptr inbounds %struct.lua_TValue, ptr %l, i64 0, i32 1
  %0 = load i32, ptr %tt, align 8
  %tt1 = getelementptr inbounds %struct.lua_TValue, ptr %r, i64 0, i32 1
  %1 = load i32, ptr %tt1, align 8
  %cmp.not = icmp eq i32 %0, %1
  br i1 %cmp.not, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %idxprom.i = sext i32 %0 to i64
  %arrayidx.i = getelementptr inbounds [11 x ptr], ptr @luaT_typenames, i64 0, i64 %idxprom.i
  %2 = load ptr, ptr %arrayidx.i, align 8
  %idxprom2.i = sext i32 %1 to i64
  %arrayidx3.i = getelementptr inbounds [11 x ptr], ptr @luaT_typenames, i64 0, i64 %idxprom2.i
  %3 = load ptr, ptr %arrayidx3.i, align 8
  %arrayidx4.i = getelementptr inbounds i8, ptr %2, i64 2
  %4 = load i8, ptr %arrayidx4.i, align 1
  %arrayidx5.i = getelementptr inbounds i8, ptr %3, i64 2
  %5 = load i8, ptr %arrayidx5.i, align 1
  %cmp.i = icmp eq i8 %4, %5
  br i1 %cmp.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %if.then
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef %L, ptr noundef nonnull @.str.43, ptr noundef nonnull %2)
  unreachable

if.else.i:                                        ; preds = %if.then
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef %L, ptr noundef nonnull @.str.44, ptr noundef nonnull %2, ptr noundef nonnull %3)
  unreachable

if.else:                                          ; preds = %entry
  switch i32 %0, label %sw.default.i [
    i32 3, label %if.then4
    i32 4, label %if.then11
    i32 5, label %sw.bb.i
    i32 7, label %sw.bb1.i
  ]

if.then4:                                         ; preds = %if.else
  %6 = load double, ptr %l, align 8
  %7 = load double, ptr %r, align 8
  %cmp6 = fcmp olt double %6, %7
  %conv = zext i1 %cmp6 to i32
  br label %return

if.then11:                                        ; preds = %if.else
  %8 = load ptr, ptr %l, align 8
  %9 = load ptr, ptr %r, align 8
  %add.ptr.i = getelementptr inbounds %union.TString, ptr %8, i64 1
  %add.ptr1.i = getelementptr inbounds %union.TString, ptr %9, i64 1
  %call18.i = tail call i32 @strcoll(ptr noundef nonnull %add.ptr.i, ptr noundef nonnull %add.ptr1.i) #34
  %cmp.not19.i = icmp eq i32 %call18.i, 0
  br i1 %cmp.not19.i, label %if.else.preheader.i, label %l_strcmp.exit

if.else.preheader.i:                              ; preds = %if.then11
  %len2.i = getelementptr inbounds %struct.anon.0, ptr %9, i64 0, i32 5
  %10 = load i64, ptr %len2.i, align 8
  %len.i = getelementptr inbounds %struct.anon.0, ptr %8, i64 0, i32 5
  %11 = load i64, ptr %len.i, align 8
  br label %if.else.i15

if.else.i15:                                      ; preds = %if.end11.i, %if.else.preheader.i
  %lr.023.i = phi i64 [ %sub14.i, %if.end11.i ], [ %10, %if.else.preheader.i ]
  %r.022.i = phi ptr [ %add.ptr13.i, %if.end11.i ], [ %add.ptr1.i, %if.else.preheader.i ]
  %ll.021.i = phi i64 [ %sub.i, %if.end11.i ], [ %11, %if.else.preheader.i ]
  %l.020.i = phi ptr [ %add.ptr12.i, %if.end11.i ], [ %add.ptr.i, %if.else.preheader.i ]
  %call4.i = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %l.020.i) #34
  %cmp5.i = icmp eq i64 %call4.i, %lr.023.i
  br i1 %cmp5.i, label %l_strcmp.exit, label %if.else8.i

if.else8.i:                                       ; preds = %if.else.i15
  %cmp9.i = icmp eq i64 %call4.i, %ll.021.i
  br i1 %cmp9.i, label %l_strcmp.exit, label %if.end11.i

if.end11.i:                                       ; preds = %if.else8.i
  %inc.i = add i64 %call4.i, 1
  %add.ptr12.i = getelementptr inbounds i8, ptr %l.020.i, i64 %inc.i
  %sub.i = sub i64 %ll.021.i, %inc.i
  %add.ptr13.i = getelementptr inbounds i8, ptr %r.022.i, i64 %inc.i
  %sub14.i = sub i64 %lr.023.i, %inc.i
  %call.i = tail call i32 @strcoll(ptr noundef %add.ptr12.i, ptr noundef %add.ptr13.i) #34
  %cmp.not.i = icmp eq i32 %call.i, 0
  br i1 %cmp.not.i, label %if.else.i15, label %l_strcmp.exit

l_strcmp.exit:                                    ; preds = %if.else8.i, %if.end11.i, %if.else.i15, %if.then11
  %retval.0.i = phi i32 [ %call18.i, %if.then11 ], [ 0, %if.else.i15 ], [ %call.i, %if.end11.i ], [ -1, %if.else8.i ]
  %call14.lobit = lshr i32 %retval.0.i, 31
  br label %return

sw.bb.i:                                          ; preds = %if.else
  %12 = load ptr, ptr %l, align 8
  %metatable.i = getelementptr inbounds %struct.Table, ptr %12, i64 0, i32 5
  br label %sw.epilog.i

sw.bb1.i:                                         ; preds = %if.else
  %13 = load ptr, ptr %l, align 8
  %metatable3.i = getelementptr inbounds %struct.anon.1, ptr %13, i64 0, i32 3
  br label %sw.epilog.i

sw.default.i:                                     ; preds = %if.else
  %l_G.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %14 = load ptr, ptr %l_G.i, align 8
  %idxprom.i36 = sext i32 %0 to i64
  %arrayidx.i37 = getelementptr inbounds %struct.global_State, ptr %14, i64 0, i32 23, i64 %idxprom.i36
  br label %sw.epilog.i

sw.epilog.i:                                      ; preds = %sw.default.i, %sw.bb1.i, %sw.bb.i
  %mt.0.in.i = phi ptr [ %arrayidx.i37, %sw.default.i ], [ %metatable3.i, %sw.bb1.i ], [ %metatable.i, %sw.bb.i ]
  %mt.0.i = load ptr, ptr %mt.0.in.i, align 8
  %tobool.not.i34 = icmp eq ptr %mt.0.i, null
  br i1 %tobool.not.i34, label %luaT_gettmbyobj.exit, label %cond.true.i

cond.true.i:                                      ; preds = %sw.epilog.i
  %l_G6.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %15 = load ptr, ptr %l_G6.i, align 8
  %arrayidx8.i = getelementptr inbounds %struct.global_State, ptr %15, i64 0, i32 24, i64 13
  %16 = load ptr, ptr %arrayidx8.i, align 8
  %17 = getelementptr i8, ptr %mt.0.i, i64 11
  %mt.0.val.i = load i8, ptr %17, align 1
  %18 = getelementptr i8, ptr %mt.0.i, i64 32
  %mt.0.val6.i = load ptr, ptr %18, align 8
  %hash.i.i = getelementptr inbounds %struct.anon.0, ptr %16, i64 0, i32 4
  %19 = load i32, ptr %hash.i.i, align 4
  %sh_prom.i.i = zext nneg i8 %mt.0.val.i to i64
  %notmask.i.i = shl nsw i64 -1, %sh_prom.i.i
  %20 = trunc i64 %notmask.i.i to i32
  %21 = xor i32 %20, -1
  %conv2.i.i = and i32 %19, %21
  %idxprom.i.i = sext i32 %conv2.i.i to i64
  %arrayidx.i.i = getelementptr inbounds %struct.Node, ptr %mt.0.val6.i, i64 %idxprom.i.i
  br label %do.body.i.i

do.body.i.i:                                      ; preds = %if.else.i.i, %cond.true.i
  %n.0.i.i = phi ptr [ %arrayidx.i.i, %cond.true.i ], [ %24, %if.else.i.i ]
  %tt.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1, i32 0, i32 1
  %22 = load i32, ptr %tt.i.i, align 8
  %cmp.i.i = icmp eq i32 %22, 4
  br i1 %cmp.i.i, label %land.lhs.true.i.i, label %if.else.i.i

land.lhs.true.i.i:                                ; preds = %do.body.i.i
  %i_key.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1
  %23 = load ptr, ptr %i_key.i.i, align 8
  %cmp5.i.i = icmp eq ptr %23, %16
  br i1 %cmp5.i.i, label %luaT_gettmbyobj.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %land.lhs.true.i.i, %do.body.i.i
  %next.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1, i32 0, i32 2
  %24 = load ptr, ptr %next.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %24, null
  br i1 %tobool.not.i.i, label %luaT_gettmbyobj.exit, label %do.body.i.i, !llvm.loop !29

luaT_gettmbyobj.exit:                             ; preds = %land.lhs.true.i.i, %if.else.i.i, %sw.epilog.i
  %cond.i35 = phi ptr [ @luaO_nilobject_, %sw.epilog.i ], [ @luaO_nilobject_, %if.else.i.i ], [ %n.0.i.i, %land.lhs.true.i.i ]
  %tt.i17 = getelementptr inbounds %struct.lua_TValue, ptr %cond.i35, i64 0, i32 1
  %25 = load i32, ptr %tt.i17, align 8
  %cmp.i18 = icmp eq i32 %25, 0
  br i1 %cmp.i18, label %if.then.i31, label %if.end.i

if.end.i:                                         ; preds = %luaT_gettmbyobj.exit
  switch i32 %0, label %sw.default.i69 [
    i32 5, label %sw.bb.i67
    i32 7, label %sw.bb1.i39
  ]

sw.bb.i67:                                        ; preds = %if.end.i
  %26 = load ptr, ptr %r, align 8
  %metatable.i68 = getelementptr inbounds %struct.Table, ptr %26, i64 0, i32 5
  br label %sw.epilog.i41

sw.bb1.i39:                                       ; preds = %if.end.i
  %27 = load ptr, ptr %r, align 8
  %metatable3.i40 = getelementptr inbounds %struct.anon.1, ptr %27, i64 0, i32 3
  br label %sw.epilog.i41

sw.default.i69:                                   ; preds = %if.end.i
  %l_G.i70 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %28 = load ptr, ptr %l_G.i70, align 8
  %idxprom.i71 = sext i32 %0 to i64
  %arrayidx.i72 = getelementptr inbounds %struct.global_State, ptr %28, i64 0, i32 23, i64 %idxprom.i71
  br label %sw.epilog.i41

sw.epilog.i41:                                    ; preds = %sw.default.i69, %sw.bb1.i39, %sw.bb.i67
  %mt.0.in.i42 = phi ptr [ %arrayidx.i72, %sw.default.i69 ], [ %metatable3.i40, %sw.bb1.i39 ], [ %metatable.i68, %sw.bb.i67 ]
  %mt.0.i43 = load ptr, ptr %mt.0.in.i42, align 8
  %tobool.not.i44 = icmp eq ptr %mt.0.i43, null
  br i1 %tobool.not.i44, label %luaT_gettmbyobj.exit73, label %cond.true.i45

cond.true.i45:                                    ; preds = %sw.epilog.i41
  %l_G6.i46 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %29 = load ptr, ptr %l_G6.i46, align 8
  %arrayidx8.i47 = getelementptr inbounds %struct.global_State, ptr %29, i64 0, i32 24, i64 13
  %30 = load ptr, ptr %arrayidx8.i47, align 8
  %31 = getelementptr i8, ptr %mt.0.i43, i64 11
  %mt.0.val.i48 = load i8, ptr %31, align 1
  %32 = getelementptr i8, ptr %mt.0.i43, i64 32
  %mt.0.val6.i49 = load ptr, ptr %32, align 8
  %hash.i.i50 = getelementptr inbounds %struct.anon.0, ptr %30, i64 0, i32 4
  %33 = load i32, ptr %hash.i.i50, align 4
  %sh_prom.i.i51 = zext nneg i8 %mt.0.val.i48 to i64
  %notmask.i.i52 = shl nsw i64 -1, %sh_prom.i.i51
  %34 = trunc i64 %notmask.i.i52 to i32
  %35 = xor i32 %34, -1
  %conv2.i.i53 = and i32 %33, %35
  %idxprom.i.i54 = sext i32 %conv2.i.i53 to i64
  %arrayidx.i.i55 = getelementptr inbounds %struct.Node, ptr %mt.0.val6.i49, i64 %idxprom.i.i54
  br label %do.body.i.i56

do.body.i.i56:                                    ; preds = %if.else.i.i60, %cond.true.i45
  %n.0.i.i57 = phi ptr [ %arrayidx.i.i55, %cond.true.i45 ], [ %38, %if.else.i.i60 ]
  %tt.i.i58 = getelementptr inbounds %struct.Node, ptr %n.0.i.i57, i64 0, i32 1, i32 0, i32 1
  %36 = load i32, ptr %tt.i.i58, align 8
  %cmp.i.i59 = icmp eq i32 %36, 4
  br i1 %cmp.i.i59, label %land.lhs.true.i.i64, label %if.else.i.i60

land.lhs.true.i.i64:                              ; preds = %do.body.i.i56
  %i_key.i.i65 = getelementptr inbounds %struct.Node, ptr %n.0.i.i57, i64 0, i32 1
  %37 = load ptr, ptr %i_key.i.i65, align 8
  %cmp5.i.i66 = icmp eq ptr %37, %30
  br i1 %cmp5.i.i66, label %luaT_gettmbyobj.exit73, label %if.else.i.i60

if.else.i.i60:                                    ; preds = %land.lhs.true.i.i64, %do.body.i.i56
  %next.i.i61 = getelementptr inbounds %struct.Node, ptr %n.0.i.i57, i64 0, i32 1, i32 0, i32 2
  %38 = load ptr, ptr %next.i.i61, align 8
  %tobool.not.i.i62 = icmp eq ptr %38, null
  br i1 %tobool.not.i.i62, label %luaT_gettmbyobj.exit73, label %do.body.i.i56, !llvm.loop !29

luaT_gettmbyobj.exit73:                           ; preds = %land.lhs.true.i.i64, %if.else.i.i60, %sw.epilog.i41
  %cond.i63 = phi ptr [ @luaO_nilobject_, %sw.epilog.i41 ], [ @luaO_nilobject_, %if.else.i.i60 ], [ %n.0.i.i57, %land.lhs.true.i.i64 ]
  %tt1.i75 = getelementptr inbounds %struct.lua_TValue, ptr %cond.i63, i64 0, i32 1
  %39 = load i32, ptr %tt1.i75, align 8
  %cmp.not.i76 = icmp eq i32 %25, %39
  br i1 %cmp.not.i76, label %if.else.i78, label %if.then.i31

if.else.i78:                                      ; preds = %luaT_gettmbyobj.exit73
  switch i32 %25, label %sw.default.i81 [
    i32 0, label %if.end4.i
    i32 3, label %luaO_rawequalObj.exit
    i32 1, label %sw.bb6.i
    i32 2, label %sw.bb11.i
  ]

sw.bb6.i:                                         ; preds = %if.else.i78
  %40 = load i32, ptr %cond.i35, align 8
  %41 = load i32, ptr %cond.i63, align 8
  %cmp9.i79 = icmp eq i32 %40, %41
  br i1 %cmp9.i79, label %if.end4.i, label %if.then.i31

sw.bb11.i:                                        ; preds = %if.else.i78
  %42 = load ptr, ptr %cond.i35, align 8
  %43 = load ptr, ptr %cond.i63, align 8
  %cmp14.i = icmp eq ptr %42, %43
  br i1 %cmp14.i, label %if.end4.i, label %if.then.i31

sw.default.i81:                                   ; preds = %if.else.i78
  %44 = load ptr, ptr %cond.i35, align 8
  %45 = load ptr, ptr %cond.i63, align 8
  %cmp18.i = icmp eq ptr %44, %45
  br i1 %cmp18.i, label %if.end4.i, label %if.then.i31

luaO_rawequalObj.exit:                            ; preds = %if.else.i78
  %46 = load double, ptr %cond.i35, align 8
  %47 = load double, ptr %cond.i63, align 8
  %cmp5.i80 = fcmp oeq double %46, %47
  br i1 %cmp5.i80, label %if.end4.i, label %if.then.i31

if.end4.i:                                        ; preds = %sw.bb6.i, %sw.bb11.i, %sw.default.i81, %if.else.i78, %luaO_rawequalObj.exit
  %top.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %48 = load ptr, ptr %top.i, align 8
  %stack.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 10
  %49 = load ptr, ptr %stack.i, align 8
  %50 = load i64, ptr %cond.i35, align 8
  store i64 %50, ptr %48, align 8
  %51 = load i32, ptr %tt.i17, align 8
  %tt2.i = getelementptr inbounds %struct.lua_TValue, ptr %48, i64 0, i32 1
  store i32 %51, ptr %tt2.i, align 8
  %52 = load ptr, ptr %top.i, align 8
  %add.ptr.i96 = getelementptr inbounds %struct.lua_TValue, ptr %52, i64 1
  %53 = load i64, ptr %l, align 8
  store i64 %53, ptr %add.ptr.i96, align 8
  %54 = load i32, ptr %tt, align 8
  %tt9.i = getelementptr inbounds %struct.lua_TValue, ptr %52, i64 1, i32 1
  store i32 %54, ptr %tt9.i, align 8
  %55 = load ptr, ptr %top.i, align 8
  %add.ptr13.i97 = getelementptr inbounds %struct.lua_TValue, ptr %55, i64 2
  %56 = load i64, ptr %r, align 8
  store i64 %56, ptr %add.ptr13.i97, align 8
  %57 = load i32, ptr %tt1, align 8
  %tt17.i = getelementptr inbounds %struct.lua_TValue, ptr %55, i64 2, i32 1
  store i32 %57, ptr %tt17.i, align 8
  %stack_last.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 9
  %58 = load ptr, ptr %stack_last.i, align 8
  %59 = load ptr, ptr %top.i, align 8
  %sub.ptr.lhs.cast19.i = ptrtoint ptr %58 to i64
  %sub.ptr.rhs.cast20.i = ptrtoint ptr %59 to i64
  %sub.ptr.sub21.i = sub i64 %sub.ptr.lhs.cast19.i, %sub.ptr.rhs.cast20.i
  %cmp.i98 = icmp slt i64 %sub.ptr.sub21.i, 49
  br i1 %cmp.i98, label %if.then.i100, label %callTMres.exit

if.then.i100:                                     ; preds = %if.end4.i
  %stacksize.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 13
  %60 = load i32, ptr %stacksize.i.i, align 8
  %cmp.not.i.i = icmp slt i32 %60, 3
  %add.i.i = add nsw i32 %60, 3
  %mul.i.i = shl nuw nsw i32 %60, 1
  %add.i.sink.i = select i1 %cmp.not.i.i, i32 %add.i.i, i32 %mul.i.i
  tail call fastcc void @luaD_reallocstack(ptr noundef nonnull %L, i32 noundef %add.i.sink.i)
  %.pre = load ptr, ptr %top.i, align 8
  br label %callTMres.exit

callTMres.exit:                                   ; preds = %if.end4.i, %if.then.i100
  %61 = phi ptr [ %59, %if.end4.i ], [ %.pre, %if.then.i100 ]
  %sub.ptr.lhs.cast.i = ptrtoint ptr %48 to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %49 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %add.ptr23.i = getelementptr inbounds %struct.lua_TValue, ptr %61, i64 3
  store ptr %add.ptr23.i, ptr %top.i, align 8
  tail call fastcc void @luaD_call(ptr noundef nonnull %L, ptr noundef %61, i32 noundef 1)
  %62 = load ptr, ptr %stack.i, align 8
  %add.ptr27.i = getelementptr inbounds i8, ptr %62, i64 %sub.ptr.sub.i
  %63 = load ptr, ptr %top.i, align 8
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %63, i64 -1
  store ptr %incdec.ptr.i, ptr %top.i, align 8
  %64 = load i64, ptr %incdec.ptr.i, align 8
  store i64 %64, ptr %add.ptr27.i, align 8
  %tt34.i = getelementptr %struct.lua_TValue, ptr %63, i64 -1, i32 1
  %65 = load i32, ptr %tt34.i, align 8
  %tt35.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr27.i, i64 0, i32 1
  store i32 %65, ptr %tt35.i, align 8
  %66 = load ptr, ptr %top.i, align 8
  %tt6.i = getelementptr inbounds %struct.lua_TValue, ptr %66, i64 0, i32 1
  %67 = load i32, ptr %tt6.i, align 8
  switch i32 %67, label %lor.end.fold.split.i [
    i32 0, label %return
    i32 1, label %land.rhs.i
  ]

land.rhs.i:                                       ; preds = %callTMres.exit
  %68 = load i32, ptr %66, align 8
  %cmp12.i = icmp ne i32 %68, 0
  %69 = zext i1 %cmp12.i to i32
  br label %return

lor.end.fold.split.i:                             ; preds = %callTMres.exit
  br label %return

if.then.i31:                                      ; preds = %luaO_rawequalObj.exit, %luaT_gettmbyobj.exit, %luaT_gettmbyobj.exit73, %sw.default.i81, %sw.bb11.i, %sw.bb6.i
  %idxprom.i21 = sext i32 %0 to i64
  %arrayidx.i22 = getelementptr inbounds [11 x ptr], ptr @luaT_typenames, i64 0, i64 %idxprom.i21
  %70 = load ptr, ptr %arrayidx.i22, align 8
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef %L, ptr noundef nonnull @.str.43, ptr noundef nonnull %70)
  unreachable

return:                                           ; preds = %lor.end.fold.split.i, %land.rhs.i, %callTMres.exit, %l_strcmp.exit, %if.then4
  %retval.0 = phi i32 [ %conv, %if.then4 ], [ %call14.lobit, %l_strcmp.exit ], [ %67, %callTMres.exit ], [ %69, %land.rhs.i ], [ 1, %lor.end.fold.split.i ]
  ret i32 %retval.0
}

; Function Attrs: nofree norecurse nosync nounwind memory(read, inaccessiblemem: none) uwtable
define internal fastcc ptr @luaH_get(ptr nocapture noundef readonly %t, ptr nocapture noundef readonly %key) unnamed_addr #14 {
entry:
  %tt = getelementptr inbounds %struct.lua_TValue, ptr %key, i64 0, i32 1
  %0 = load i32, ptr %tt, align 8
  switch i32 %0, label %sw.default.i [
    i32 0, label %return
    i32 4, label %sw.bb1
    i32 3, label %sw.bb2
    i32 2, label %sw.bb18.i
    i32 1, label %sw.bb5.i
  ]

sw.bb1:                                           ; preds = %entry
  %1 = load ptr, ptr %key, align 8
  %2 = getelementptr i8, ptr %t, i64 11
  %t.val = load i8, ptr %2, align 1
  %3 = getelementptr i8, ptr %t, i64 32
  %t.val12 = load ptr, ptr %3, align 8
  %hash.i = getelementptr inbounds %struct.anon.0, ptr %1, i64 0, i32 4
  %4 = load i32, ptr %hash.i, align 4
  %sh_prom.i = zext nneg i8 %t.val to i64
  %notmask.i = shl nsw i64 -1, %sh_prom.i
  %5 = trunc i64 %notmask.i to i32
  %6 = xor i32 %5, -1
  %conv2.i = and i32 %4, %6
  %idxprom.i = sext i32 %conv2.i to i64
  %arrayidx.i = getelementptr inbounds %struct.Node, ptr %t.val12, i64 %idxprom.i
  br label %do.body.i

do.body.i:                                        ; preds = %if.else.i, %sw.bb1
  %n.0.i = phi ptr [ %arrayidx.i, %sw.bb1 ], [ %9, %if.else.i ]
  %tt.i = getelementptr inbounds %struct.Node, ptr %n.0.i, i64 0, i32 1, i32 0, i32 1
  %7 = load i32, ptr %tt.i, align 8
  %cmp.i = icmp eq i32 %7, 4
  br i1 %cmp.i, label %land.lhs.true.i, label %if.else.i

land.lhs.true.i:                                  ; preds = %do.body.i
  %i_key.i = getelementptr inbounds %struct.Node, ptr %n.0.i, i64 0, i32 1
  %8 = load ptr, ptr %i_key.i, align 8
  %cmp5.i = icmp eq ptr %8, %1
  br i1 %cmp5.i, label %return, label %if.else.i

if.else.i:                                        ; preds = %land.lhs.true.i, %do.body.i
  %next.i = getelementptr inbounds %struct.Node, ptr %n.0.i, i64 0, i32 1, i32 0, i32 2
  %9 = load ptr, ptr %next.i, align 8
  %tobool.not.i = icmp eq ptr %9, null
  br i1 %tobool.not.i, label %return, label %do.body.i, !llvm.loop !29

sw.bb2:                                           ; preds = %entry
  %10 = load double, ptr %key, align 8
  %conv = fptosi double %10 to i32
  %conv4 = sitofp i32 %conv to double
  %cmp = fcmp oeq double %10, %conv4
  %11 = bitcast double %10 to i64
  %12 = trunc i64 %11 to i32
  br i1 %cmp, label %if.then, label %sw.bb.i

if.then:                                          ; preds = %sw.bb2
  %sub.i = add i32 %conv, -1
  %sizearray.i = getelementptr inbounds %struct.Table, ptr %t, i64 0, i32 10
  %13 = load i32, ptr %sizearray.i, align 8
  %cmp.i13 = icmp ult i32 %sub.i, %13
  br i1 %cmp.i13, label %if.then.i, label %if.else.i14

if.then.i:                                        ; preds = %if.then
  %array.i = getelementptr inbounds %struct.Table, ptr %t, i64 0, i32 6
  %14 = load ptr, ptr %array.i, align 8
  %idxprom.i24 = sext i32 %sub.i to i64
  %arrayidx.i25 = getelementptr inbounds %struct.lua_TValue, ptr %14, i64 %idxprom.i24
  br label %return

if.else.i14:                                      ; preds = %if.then
  %cmp.i.i = icmp eq i32 %conv, 0
  br i1 %cmp.i.i, label %if.then.i.i, label %if.end.i.i

if.then.i.i:                                      ; preds = %if.else.i14
  %node.i.i = getelementptr inbounds %struct.Table, ptr %t, i64 0, i32 7
  %15 = load ptr, ptr %node.i.i, align 8
  br label %do.body.i15.preheader

if.end.i.i:                                       ; preds = %if.else.i14
  %16 = bitcast double %conv4 to i64
  %a.sroa.0.4.extract.shift.i.i = lshr i64 %16, 32
  %add.i.i = add i64 %a.sroa.0.4.extract.shift.i.i, %16
  %node4.i.i = getelementptr inbounds %struct.Table, ptr %t, i64 0, i32 7
  %17 = load ptr, ptr %node4.i.i, align 8
  %conv.i.i = and i64 %add.i.i, 4294967295
  %lsizenode.i.i = getelementptr inbounds %struct.Table, ptr %t, i64 0, i32 4
  %18 = load i8, ptr %lsizenode.i.i, align 1
  %sh_prom.i.i = zext nneg i8 %18 to i64
  %notmask.i.i = shl nsw i64 -1, %sh_prom.i.i
  %sub.i.i = xor i64 %notmask.i.i, -1
  %or.i.i = or i64 %sub.i.i, 1
  %rem.i.i = urem i64 %conv.i.i, %or.i.i
  %arrayidx7.i.i = getelementptr inbounds %struct.Node, ptr %17, i64 %rem.i.i
  br label %do.body.i15.preheader

do.body.i15.preheader:                            ; preds = %if.end.i.i, %if.then.i.i
  %n.0.i16.ph = phi ptr [ %arrayidx7.i.i, %if.end.i.i ], [ %15, %if.then.i.i ]
  br label %do.body.i15

do.body.i15:                                      ; preds = %do.body.i15.preheader, %if.else8.i
  %n.0.i16 = phi ptr [ %21, %if.else8.i ], [ %n.0.i16.ph, %do.body.i15.preheader ]
  %tt.i17 = getelementptr inbounds %struct.Node, ptr %n.0.i16, i64 0, i32 1, i32 0, i32 1
  %19 = load i32, ptr %tt.i17, align 8
  %cmp2.i = icmp eq i32 %19, 3
  br i1 %cmp2.i, label %land.lhs.true.i21, label %if.else8.i

land.lhs.true.i21:                                ; preds = %do.body.i15
  %i_key.i22 = getelementptr inbounds %struct.Node, ptr %n.0.i16, i64 0, i32 1
  %20 = load double, ptr %i_key.i22, align 8
  %cmp5.i23 = fcmp oeq double %20, %conv4
  br i1 %cmp5.i23, label %return, label %if.else8.i

if.else8.i:                                       ; preds = %land.lhs.true.i21, %do.body.i15
  %next.i18 = getelementptr inbounds %struct.Node, ptr %n.0.i16, i64 0, i32 1, i32 0, i32 2
  %21 = load ptr, ptr %next.i18, align 8
  %tobool.not.i19 = icmp eq ptr %21, null
  br i1 %tobool.not.i19, label %return, label %do.body.i15, !llvm.loop !7

sw.bb.i:                                          ; preds = %sw.bb2
  %cmp.i.i33 = fcmp oeq double %10, 0.000000e+00
  br i1 %cmp.i.i33, label %if.then.i.i46, label %if.end.i.i34

if.then.i.i46:                                    ; preds = %sw.bb.i
  %node.i.i47 = getelementptr inbounds %struct.Table, ptr %t, i64 0, i32 7
  %22 = load ptr, ptr %node.i.i47, align 8
  br label %do.body.preheader

if.end.i.i34:                                     ; preds = %sw.bb.i
  %a.sroa.0.4.extract.shift.i.i35 = lshr i64 %11, 32
  %add.i.i36 = add i64 %a.sroa.0.4.extract.shift.i.i35, %11
  %node4.i.i37 = getelementptr inbounds %struct.Table, ptr %t, i64 0, i32 7
  %23 = load ptr, ptr %node4.i.i37, align 8
  %conv.i.i38 = and i64 %add.i.i36, 4294967295
  %lsizenode.i.i39 = getelementptr inbounds %struct.Table, ptr %t, i64 0, i32 4
  %24 = load i8, ptr %lsizenode.i.i39, align 1
  %sh_prom.i.i40 = zext nneg i8 %24 to i64
  %notmask.i.i41 = shl nsw i64 -1, %sh_prom.i.i40
  %sub.i.i42 = xor i64 %notmask.i.i41, -1
  %or.i.i43 = or i64 %sub.i.i42, 1
  %rem.i.i44 = urem i64 %conv.i.i38, %or.i.i43
  %arrayidx7.i.i45 = getelementptr inbounds %struct.Node, ptr %23, i64 %rem.i.i44
  br label %do.body.preheader

sw.bb5.i:                                         ; preds = %entry
  %node6.i = getelementptr inbounds %struct.Table, ptr %t, i64 0, i32 7
  %25 = load ptr, ptr %node6.i, align 8
  %26 = load i32, ptr %key, align 8
  %lsizenode9.i = getelementptr inbounds %struct.Table, ptr %t, i64 0, i32 4
  %27 = load i8, ptr %lsizenode9.i, align 1
  %sh_prom11.i = zext nneg i8 %27 to i64
  %notmask14.i = shl nsw i64 -1, %sh_prom11.i
  %28 = trunc i64 %notmask14.i to i32
  %29 = xor i32 %28, -1
  %conv15.i = and i32 %26, %29
  %idxprom16.i = sext i32 %conv15.i to i64
  %arrayidx17.i = getelementptr inbounds %struct.Node, ptr %25, i64 %idxprom16.i
  br label %do.body.preheader

sw.bb18.i:                                        ; preds = %entry
  %node19.i = getelementptr inbounds %struct.Table, ptr %t, i64 0, i32 7
  %30 = load ptr, ptr %node19.i, align 8
  %31 = load ptr, ptr %key, align 8
  %32 = ptrtoint ptr %31 to i64
  %conv22.i = and i64 %32, 4294967295
  %lsizenode23.i = getelementptr inbounds %struct.Table, ptr %t, i64 0, i32 4
  %33 = load i8, ptr %lsizenode23.i, align 1
  %sh_prom25.i = zext nneg i8 %33 to i64
  %notmask.i27 = shl nsw i64 -1, %sh_prom25.i
  %sub27.i = xor i64 %notmask.i27, -1
  %or.i = or i64 %sub27.i, 1
  %rem.i = urem i64 %conv22.i, %or.i
  %arrayidx28.i = getelementptr inbounds %struct.Node, ptr %30, i64 %rem.i
  %34 = trunc i64 %32 to i32
  br label %do.body.preheader

sw.default.i:                                     ; preds = %entry
  %node29.i = getelementptr inbounds %struct.Table, ptr %t, i64 0, i32 7
  %35 = load ptr, ptr %node29.i, align 8
  %36 = load ptr, ptr %key, align 8
  %37 = ptrtoint ptr %36 to i64
  %conv32.i = and i64 %37, 4294967295
  %lsizenode33.i = getelementptr inbounds %struct.Table, ptr %t, i64 0, i32 4
  %38 = load i8, ptr %lsizenode33.i, align 1
  %sh_prom35.i = zext nneg i8 %38 to i64
  %notmask16.i = shl nsw i64 -1, %sh_prom35.i
  %sub37.i = xor i64 %notmask16.i, -1
  %or38.i = or i64 %sub37.i, 1
  %rem39.i = urem i64 %conv32.i, %or38.i
  %arrayidx40.i = getelementptr inbounds %struct.Node, ptr %35, i64 %rem39.i
  %39 = trunc i64 %37 to i32
  br label %do.body.preheader

do.body.preheader:                                ; preds = %if.then.i.i46, %if.end.i.i34, %sw.bb5.i, %sw.bb18.i, %sw.default.i
  %.ph = phi i32 [ %12, %if.end.i.i34 ], [ %12, %if.then.i.i46 ], [ %26, %sw.bb5.i ], [ %34, %sw.bb18.i ], [ %39, %sw.default.i ]
  %n8.0.ph = phi ptr [ %arrayidx7.i.i45, %if.end.i.i34 ], [ %22, %if.then.i.i46 ], [ %arrayidx17.i, %sw.bb5.i ], [ %arrayidx28.i, %sw.bb18.i ], [ %arrayidx40.i, %sw.default.i ]
  br label %do.body

do.body:                                          ; preds = %do.body.preheader, %if.else
  %40 = phi i32 [ %55, %if.else ], [ %.ph, %do.body.preheader ]
  %n8.0 = phi ptr [ %56, %if.else ], [ %n8.0.ph, %do.body.preheader ]
  %i_key = getelementptr inbounds %struct.Node, ptr %n8.0, i64 0, i32 1
  %tt.i48 = getelementptr inbounds %struct.Node, ptr %n8.0, i64 0, i32 1, i32 0, i32 1
  %41 = load i32, ptr %tt.i48, align 8
  %cmp.not.i = icmp eq i32 %41, %0
  br i1 %cmp.not.i, label %if.else.i50, label %if.else

if.else.i50:                                      ; preds = %do.body
  switch i32 %0, label %sw.default.i52 [
    i32 0, label %return
    i32 3, label %luaO_rawequalObj.exit
    i32 1, label %sw.bb6.i
    i32 2, label %sw.bb11.i
  ]

sw.bb6.i:                                         ; preds = %if.else.i50
  %42 = load i32, ptr %i_key, align 8
  %cmp9.i = icmp eq i32 %42, %40
  br i1 %cmp9.i, label %return, label %if.else

sw.bb11.i:                                        ; preds = %if.else.i50
  %43 = load ptr, ptr %i_key, align 8
  %44 = load ptr, ptr %key, align 8
  %cmp14.i = icmp eq ptr %43, %44
  %45 = ptrtoint ptr %44 to i64
  %46 = trunc i64 %45 to i32
  br i1 %cmp14.i, label %return, label %if.else

sw.default.i52:                                   ; preds = %if.else.i50
  %47 = load ptr, ptr %i_key, align 8
  %48 = load ptr, ptr %key, align 8
  %cmp18.i = icmp eq ptr %47, %48
  %49 = ptrtoint ptr %48 to i64
  %50 = trunc i64 %49 to i32
  br i1 %cmp18.i, label %return, label %if.else

luaO_rawequalObj.exit:                            ; preds = %if.else.i50
  %51 = load double, ptr %i_key, align 8
  %52 = load double, ptr %key, align 8
  %cmp5.i51 = fcmp oeq double %51, %52
  %53 = bitcast double %52 to i64
  %54 = trunc i64 %53 to i32
  br i1 %cmp5.i51, label %return, label %if.else

if.else:                                          ; preds = %sw.bb6.i, %sw.bb11.i, %sw.default.i52, %do.body, %luaO_rawequalObj.exit
  %55 = phi i32 [ %40, %do.body ], [ %54, %luaO_rawequalObj.exit ], [ %50, %sw.default.i52 ], [ %46, %sw.bb11.i ], [ %40, %sw.bb6.i ]
  %next = getelementptr inbounds %struct.Node, ptr %n8.0, i64 0, i32 1, i32 0, i32 2
  %56 = load ptr, ptr %next, align 8
  %tobool14.not = icmp eq ptr %56, null
  br i1 %tobool14.not, label %return, label %do.body, !llvm.loop !50

return:                                           ; preds = %if.else8.i, %land.lhs.true.i21, %if.else.i, %land.lhs.true.i, %if.else.i50, %if.else, %luaO_rawequalObj.exit, %sw.default.i52, %sw.bb11.i, %sw.bb6.i, %entry, %if.then.i
  %retval.0 = phi ptr [ @luaO_nilobject_, %entry ], [ %arrayidx.i25, %if.then.i ], [ %n8.0, %sw.bb6.i ], [ %n8.0, %sw.bb11.i ], [ %n8.0, %sw.default.i52 ], [ %n8.0, %if.else.i50 ], [ @luaO_nilobject_, %if.else ], [ %n8.0, %luaO_rawequalObj.exit ], [ @luaO_nilobject_, %if.else.i ], [ %n.0.i, %land.lhs.true.i ], [ %n.0.i16, %land.lhs.true.i21 ], [ @luaO_nilobject_, %if.else8.i ]
  ret ptr %retval.0
}

; Function Attrs: nounwind uwtable
define internal fastcc ptr @newkey(ptr noundef %L, ptr noundef %t, ptr nocapture noundef readonly %key) unnamed_addr #0 {
entry:
  %nums.i = alloca [31 x i32], align 16
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %key, i64 0, i32 1
  %invariant.gep = getelementptr inbounds i32, ptr %nums.i, i64 1
  %node19.i = getelementptr inbounds %struct.Table, ptr %t, i64 0, i32 7
  %lsizenode23.i = getelementptr inbounds %struct.Table, ptr %t, i64 0, i32 4
  %lastfree.i = getelementptr inbounds %struct.Table, ptr %t, i64 0, i32 8
  %sizearray.i.i = getelementptr inbounds %struct.Table, ptr %t, i64 0, i32 10
  %array.i.i = getelementptr inbounds %struct.Table, ptr %t, i64 0, i32 6
  %flags.i = getelementptr inbounds %struct.Table, ptr %t, i64 0, i32 3
  br label %tailrecurse

tailrecurse:                                      ; preds = %tailrecurse.backedge, %entry
  %0 = load i32, ptr %tt.i, align 8
  switch i32 %0, label %sw.default.i [
    i32 3, label %sw.bb.i
    i32 4, label %sw.bb1.i
    i32 1, label %sw.bb5.i
    i32 2, label %sw.bb18.i
  ]

sw.bb.i:                                          ; preds = %tailrecurse
  %1 = load double, ptr %key, align 8
  %cmp.i.i = fcmp oeq double %1, 0.000000e+00
  br i1 %cmp.i.i, label %if.then.i.i, label %if.end.i.i

if.then.i.i:                                      ; preds = %sw.bb.i
  %2 = load ptr, ptr %node19.i, align 8
  br label %mainposition.exit

if.end.i.i:                                       ; preds = %sw.bb.i
  %3 = bitcast double %1 to i64
  %a.sroa.0.4.extract.shift.i.i = lshr i64 %3, 32
  %add.i.i = add i64 %a.sroa.0.4.extract.shift.i.i, %3
  %4 = load ptr, ptr %node19.i, align 8
  %conv.i.i = and i64 %add.i.i, 4294967295
  %5 = load i8, ptr %lsizenode23.i, align 1
  %sh_prom.i.i = zext nneg i8 %5 to i64
  %notmask.i.i = shl nsw i64 -1, %sh_prom.i.i
  %sub.i.i = xor i64 %notmask.i.i, -1
  %or.i.i = or i64 %sub.i.i, 1
  %rem.i.i = urem i64 %conv.i.i, %or.i.i
  %arrayidx7.i.i = getelementptr inbounds %struct.Node, ptr %4, i64 %rem.i.i
  br label %mainposition.exit

sw.bb1.i:                                         ; preds = %tailrecurse
  %6 = load ptr, ptr %node19.i, align 8
  %7 = load ptr, ptr %key, align 8
  %hash.i = getelementptr inbounds %struct.anon.0, ptr %7, i64 0, i32 4
  %8 = load i32, ptr %hash.i, align 4
  %9 = load i8, ptr %lsizenode23.i, align 1
  %sh_prom.i = zext nneg i8 %9 to i64
  %notmask15.i = shl nsw i64 -1, %sh_prom.i
  %10 = trunc i64 %notmask15.i to i32
  %11 = xor i32 %10, -1
  %conv4.i = and i32 %8, %11
  %idxprom.i = sext i32 %conv4.i to i64
  %arrayidx.i = getelementptr inbounds %struct.Node, ptr %6, i64 %idxprom.i
  br label %mainposition.exit

sw.bb5.i:                                         ; preds = %tailrecurse
  %12 = load ptr, ptr %node19.i, align 8
  %13 = load i32, ptr %key, align 8
  %14 = load i8, ptr %lsizenode23.i, align 1
  %sh_prom11.i = zext nneg i8 %14 to i64
  %notmask14.i = shl nsw i64 -1, %sh_prom11.i
  %15 = trunc i64 %notmask14.i to i32
  %16 = xor i32 %15, -1
  %conv15.i = and i32 %13, %16
  %idxprom16.i = sext i32 %conv15.i to i64
  %arrayidx17.i = getelementptr inbounds %struct.Node, ptr %12, i64 %idxprom16.i
  br label %mainposition.exit

sw.bb18.i:                                        ; preds = %tailrecurse
  %17 = load ptr, ptr %node19.i, align 8
  %18 = load ptr, ptr %key, align 8
  %19 = ptrtoint ptr %18 to i64
  %conv22.i = and i64 %19, 4294967295
  %20 = load i8, ptr %lsizenode23.i, align 1
  %sh_prom25.i = zext nneg i8 %20 to i64
  %notmask.i = shl nsw i64 -1, %sh_prom25.i
  %sub27.i = xor i64 %notmask.i, -1
  %or.i = or i64 %sub27.i, 1
  %rem.i = urem i64 %conv22.i, %or.i
  %arrayidx28.i = getelementptr inbounds %struct.Node, ptr %17, i64 %rem.i
  br label %mainposition.exit

sw.default.i:                                     ; preds = %tailrecurse
  %21 = load ptr, ptr %node19.i, align 8
  %22 = load ptr, ptr %key, align 8
  %23 = ptrtoint ptr %22 to i64
  %conv32.i = and i64 %23, 4294967295
  %24 = load i8, ptr %lsizenode23.i, align 1
  %sh_prom35.i = zext nneg i8 %24 to i64
  %notmask16.i = shl nsw i64 -1, %sh_prom35.i
  %sub37.i = xor i64 %notmask16.i, -1
  %or38.i = or i64 %sub37.i, 1
  %rem39.i = urem i64 %conv32.i, %or38.i
  %arrayidx40.i = getelementptr inbounds %struct.Node, ptr %21, i64 %rem39.i
  br label %mainposition.exit

mainposition.exit:                                ; preds = %if.then.i.i, %if.end.i.i, %sw.bb1.i, %sw.bb5.i, %sw.bb18.i, %sw.default.i
  %25 = phi ptr [ %21, %sw.default.i ], [ %17, %sw.bb18.i ], [ %12, %sw.bb5.i ], [ %6, %sw.bb1.i ], [ %2, %if.then.i.i ], [ %4, %if.end.i.i ]
  %retval.0.i = phi ptr [ %arrayidx40.i, %sw.default.i ], [ %arrayidx28.i, %sw.bb18.i ], [ %arrayidx17.i, %sw.bb5.i ], [ %arrayidx.i, %sw.bb1.i ], [ %2, %if.then.i.i ], [ %arrayidx7.i.i, %if.end.i.i ]
  %tt = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i, i64 0, i32 1
  %26 = load i32, ptr %tt, align 8
  %cmp = icmp ne i32 %26, 0
  %cmp1 = icmp eq ptr %retval.0.i, @dummynode_
  %or.cond = or i1 %cmp1, %cmp
  br i1 %or.cond, label %if.then, label %if.end26

if.then:                                          ; preds = %mainposition.exit
  %lastfree.promoted.i = load ptr, ptr %lastfree.i, align 8
  br label %while.cond.i

while.cond.i:                                     ; preds = %while.body.i, %if.then
  %incdec.ptr6.i = phi ptr [ %incdec.ptr.i, %while.body.i ], [ %lastfree.promoted.i, %if.then ]
  %incdec.ptr.i = getelementptr inbounds %struct.Node, ptr %incdec.ptr6.i, i64 -1
  store ptr %incdec.ptr.i, ptr %lastfree.i, align 8
  %cmp.i = icmp ugt ptr %incdec.ptr6.i, %25
  br i1 %cmp.i, label %while.body.i, label %if.then4

while.body.i:                                     ; preds = %while.cond.i
  %tt.i37 = getelementptr %struct.Node, ptr %incdec.ptr6.i, i64 -1, i32 1, i32 0, i32 1
  %27 = load i32, ptr %tt.i37, align 8
  %cmp2.i = icmp eq i32 %27, 0
  br i1 %cmp2.i, label %if.end, label %while.cond.i, !llvm.loop !51

if.then4:                                         ; preds = %while.cond.i
  call void @llvm.lifetime.start.p0(i64 124, ptr nonnull %nums.i)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(124) %nums.i, i8 0, i64 124, i1 false)
  %28 = load i32, ptr %sizearray.i.i, align 8
  br label %for.body.i.i

for.body.i.i:                                     ; preds = %for.end.i.i, %if.then4
  %indvars.iv23.i.i = phi i64 [ 0, %if.then4 ], [ %indvars.iv.next24.i.i, %for.end.i.i ]
  %i.021.i.i = phi i32 [ 1, %if.then4 ], [ %i.1.lcssa.i.i, %for.end.i.i ]
  %ause.020.i.i = phi i32 [ 0, %if.then4 ], [ %add15.i.i, %for.end.i.i ]
  %ttlg.019.i.i = phi i32 [ 1, %if.then4 ], [ %mul.i.i, %for.end.i.i ]
  %cmp1.i.i = icmp sgt i32 %ttlg.019.i.i, %28
  br i1 %cmp1.i.i, label %if.then.i.i45, label %if.end5.i.i

if.then.i.i45:                                    ; preds = %for.body.i.i
  %cmp3.i.i = icmp sgt i32 %i.021.i.i, %28
  br i1 %cmp3.i.i, label %numusearray.exit.i, label %if.end5.i.i

if.end5.i.i:                                      ; preds = %if.then.i.i45, %for.body.i.i
  %lim.0.i.i = phi i32 [ %28, %if.then.i.i45 ], [ %ttlg.019.i.i, %for.body.i.i ]
  %cmp7.not14.i.i = icmp sgt i32 %i.021.i.i, %lim.0.i.i
  br i1 %cmp7.not14.i.i, label %for.end.i.i, label %for.body8.lr.ph.i.i

for.body8.lr.ph.i.i:                              ; preds = %if.end5.i.i
  %29 = load ptr, ptr %array.i.i, align 8
  %invariant.gep.i.i = getelementptr %struct.lua_TValue, ptr %29, i64 -1, i32 1
  %30 = sext i32 %i.021.i.i to i64
  %31 = sext i32 %lim.0.i.i to i64
  br label %for.body8.i.i

for.body8.i.i:                                    ; preds = %for.body8.i.i, %for.body8.lr.ph.i.i
  %indvars.iv.i.i = phi i64 [ %30, %for.body8.lr.ph.i.i ], [ %indvars.iv.next.i.i, %for.body8.i.i ]
  %lc.016.i.i = phi i32 [ 0, %for.body8.lr.ph.i.i ], [ %spec.select.i.i, %for.body8.i.i ]
  %gep.i.i = getelementptr %struct.lua_TValue, ptr %invariant.gep.i.i, i64 %indvars.iv.i.i
  %32 = load i32, ptr %gep.i.i, align 8
  %cmp9.i.i = icmp ne i32 %32, 0
  %inc.i.i = zext i1 %cmp9.i.i to i32
  %spec.select.i.i = add nuw nsw i32 %lc.016.i.i, %inc.i.i
  %indvars.iv.next.i.i = add nsw i64 %indvars.iv.i.i, 1
  %cmp7.not.not.i.i = icmp slt i64 %indvars.iv.i.i, %31
  br i1 %cmp7.not.not.i.i, label %for.body8.i.i, label %for.end.loopexit.i.i, !llvm.loop !52

for.end.loopexit.i.i:                             ; preds = %for.body8.i.i
  %33 = add i32 %lim.0.i.i, 1
  br label %for.end.i.i

for.end.i.i:                                      ; preds = %for.end.loopexit.i.i, %if.end5.i.i
  %i.1.lcssa.i.i = phi i32 [ %i.021.i.i, %if.end5.i.i ], [ %33, %for.end.loopexit.i.i ]
  %lc.0.lcssa.i.i = phi i32 [ 0, %if.end5.i.i ], [ %spec.select.i.i, %for.end.loopexit.i.i ]
  %arrayidx14.i.i = getelementptr inbounds i32, ptr %nums.i, i64 %indvars.iv23.i.i
  %34 = load i32, ptr %arrayidx14.i.i, align 4
  %add.i.i39 = add nsw i32 %34, %lc.0.lcssa.i.i
  store i32 %add.i.i39, ptr %arrayidx14.i.i, align 4
  %add15.i.i = add nuw nsw i32 %lc.0.lcssa.i.i, %ause.020.i.i
  %indvars.iv.next24.i.i = add nuw nsw i64 %indvars.iv23.i.i, 1
  %mul.i.i = shl nsw i32 %ttlg.019.i.i, 1
  %exitcond.not.i.i = icmp eq i64 %indvars.iv.next24.i.i, 31
  br i1 %exitcond.not.i.i, label %numusearray.exit.i, label %for.body.i.i, !llvm.loop !53

numusearray.exit.i:                               ; preds = %for.end.i.i, %if.then.i.i45
  %ause.0.lcssa.i.i = phi i32 [ %ause.020.i.i, %if.then.i.i45 ], [ %add15.i.i, %for.end.i.i ]
  %35 = load i8, ptr %lsizenode23.i, align 1
  %tobool.not7.i.i = icmp ugt i8 %35, 31
  br i1 %tobool.not7.i.i, label %numusehash.exit.i, label %while.body.lr.ph.i.i

while.body.lr.ph.i.i:                             ; preds = %numusearray.exit.i
  %sh_prom.i.i41 = zext nneg i8 %35 to i64
  %sext.i.i = shl nuw i64 4294967296, %sh_prom.i.i41
  %36 = ashr exact i64 %sext.i.i, 32
  br label %while.body.i.i

while.body.i.i:                                   ; preds = %if.end.i.i44, %while.body.lr.ph.i.i
  %indvars.iv.i8.i = phi i64 [ %36, %while.body.lr.ph.i.i ], [ %indvars.iv.next.i9.i, %if.end.i.i44 ]
  %totaluse.09.i.i = phi i32 [ 0, %while.body.lr.ph.i.i ], [ %totaluse.1.i.i, %if.end.i.i44 ]
  %ause.08.i.i = phi i32 [ 0, %while.body.lr.ph.i.i ], [ %ause.1.i.i, %if.end.i.i44 ]
  %indvars.iv.next.i9.i = add nsw i64 %indvars.iv.i8.i, -1
  %tt.i.i = getelementptr inbounds %struct.Node, ptr %25, i64 %indvars.iv.next.i9.i, i32 0, i32 1
  %37 = load i32, ptr %tt.i.i, align 8
  %cmp.i.i43 = icmp eq i32 %37, 0
  br i1 %cmp.i.i43, label %if.end.i.i44, label %if.then.i10.i

if.then.i10.i:                                    ; preds = %while.body.i.i
  %i_key.i.i = getelementptr inbounds %struct.Node, ptr %25, i64 %indvars.iv.next.i9.i, i32 1
  %tt.i.i.i.i = getelementptr inbounds %struct.lua_TValue, ptr %i_key.i.i, i64 0, i32 1
  %38 = load i32, ptr %tt.i.i.i.i, align 8
  %cmp.i.i.i.i = icmp eq i32 %38, 3
  br i1 %cmp.i.i.i.i, label %if.then.i.i.i.i, label %countint.exit.i.i

if.then.i.i.i.i:                                  ; preds = %if.then.i10.i
  %39 = load double, ptr %i_key.i.i, align 8
  %conv.i.i.i.i = fptosi double %39 to i32
  %conv1.i.i.i.i = sitofp i32 %conv.i.i.i.i to double
  %cmp2.i.i.i.i = fcmp oeq double %39, %conv1.i.i.i.i
  br i1 %cmp2.i.i.i.i, label %arrayindex.exit.i.i.i, label %countint.exit.i.i

arrayindex.exit.i.i.i:                            ; preds = %if.then.i.i.i.i
  %40 = add i32 %conv.i.i.i.i, -1
  %or.cond.i.i.i = icmp ult i32 %40, 1073741824
  br i1 %or.cond.i.i.i, label %if.then.i.i.i, label %countint.exit.i.i

if.then.i.i.i:                                    ; preds = %arrayindex.exit.i.i.i
  %cmp4.i.i.i.i = icmp ugt i32 %40, 255
  br i1 %cmp4.i.i.i.i, label %while.body.i.i.i.i, label %luaO_log2.exit.i.i.i

while.body.i.i.i.i:                               ; preds = %if.then.i.i.i, %while.body.i.i.i.i
  %l.06.i.i.i.i = phi i32 [ %add.i.i.i.i, %while.body.i.i.i.i ], [ -1, %if.then.i.i.i ]
  %x.addr.05.i.i.i.i = phi i32 [ %shr.i.i.i.i, %while.body.i.i.i.i ], [ %40, %if.then.i.i.i ]
  %add.i.i.i.i = add nsw i32 %l.06.i.i.i.i, 8
  %shr.i.i.i.i = lshr i32 %x.addr.05.i.i.i.i, 8
  %cmp.i4.i.i.i = icmp ugt i32 %x.addr.05.i.i.i.i, 65535
  br i1 %cmp.i4.i.i.i, label %while.body.i.i.i.i, label %luaO_log2.exit.i.i.i, !llvm.loop !54

luaO_log2.exit.i.i.i:                             ; preds = %while.body.i.i.i.i, %if.then.i.i.i
  %x.addr.0.lcssa.i.i.i.i = phi i32 [ %40, %if.then.i.i.i ], [ %shr.i.i.i.i, %while.body.i.i.i.i ]
  %l.0.lcssa.i.i.i.i = phi i32 [ -1, %if.then.i.i.i ], [ %add.i.i.i.i, %while.body.i.i.i.i ]
  %idxprom.i.i.i.i = zext nneg i32 %x.addr.0.lcssa.i.i.i.i to i64
  %arrayidx.i.i.i.i = getelementptr inbounds [256 x i8], ptr @luaO_log2.log_2, i64 0, i64 %idxprom.i.i.i.i
  %41 = load i8, ptr %arrayidx.i.i.i.i, align 1
  %conv.i3.i.i.i = zext i8 %41 to i32
  %add1.i.i.i.i = add nsw i32 %l.0.lcssa.i.i.i.i, %conv.i3.i.i.i
  %42 = sext i32 %add1.i.i.i.i to i64
  %gep.i14.i = getelementptr i32, ptr %invariant.gep, i64 %42
  %43 = load i32, ptr %gep.i14.i, align 4
  %inc.i.i.i = add nsw i32 %43, 1
  store i32 %inc.i.i.i, ptr %gep.i14.i, align 4
  br label %countint.exit.i.i

countint.exit.i.i:                                ; preds = %luaO_log2.exit.i.i.i, %arrayindex.exit.i.i.i, %if.then.i.i.i.i, %if.then.i10.i
  %retval.0.i.i.i = phi i32 [ 1, %luaO_log2.exit.i.i.i ], [ 0, %arrayindex.exit.i.i.i ], [ 0, %if.then.i10.i ], [ 0, %if.then.i.i.i.i ]
  %add.i11.i = add nsw i32 %retval.0.i.i.i, %ause.08.i.i
  %inc.i12.i = add nsw i32 %totaluse.09.i.i, 1
  br label %if.end.i.i44

if.end.i.i44:                                     ; preds = %countint.exit.i.i, %while.body.i.i
  %ause.1.i.i = phi i32 [ %ause.08.i.i, %while.body.i.i ], [ %add.i11.i, %countint.exit.i.i ]
  %totaluse.1.i.i = phi i32 [ %totaluse.09.i.i, %while.body.i.i ], [ %inc.i12.i, %countint.exit.i.i ]
  %44 = icmp eq i64 %indvars.iv.next.i9.i, 0
  br i1 %44, label %numusehash.exit.i, label %while.body.i.i, !llvm.loop !55

numusehash.exit.i:                                ; preds = %if.end.i.i44, %numusearray.exit.i
  %ause.0.lcssa.i13.i = phi i32 [ 0, %numusearray.exit.i ], [ %ause.1.i.i, %if.end.i.i44 ]
  %totaluse.0.lcssa.i.i = phi i32 [ 0, %numusearray.exit.i ], [ %totaluse.1.i.i, %if.end.i.i44 ]
  %add3.i.i = add nsw i32 %ause.0.lcssa.i13.i, %ause.0.lcssa.i.i
  %45 = load i32, ptr %tt.i, align 8
  %cmp.i.i.i = icmp eq i32 %45, 3
  br i1 %cmp.i.i.i, label %if.then.i.i15.i, label %countint.exit.i

if.then.i.i15.i:                                  ; preds = %numusehash.exit.i
  %46 = load double, ptr %key, align 8
  %conv.i.i.i = fptosi double %46 to i32
  %conv1.i.i.i = sitofp i32 %conv.i.i.i to double
  %cmp2.i.i.i = fcmp oeq double %46, %conv1.i.i.i
  br i1 %cmp2.i.i.i, label %arrayindex.exit.i.i, label %countint.exit.i

arrayindex.exit.i.i:                              ; preds = %if.then.i.i15.i
  %47 = add i32 %conv.i.i.i, -1
  %or.cond.i.i = icmp ult i32 %47, 1073741824
  br i1 %or.cond.i.i, label %if.then.i16.i, label %countint.exit.i

if.then.i16.i:                                    ; preds = %arrayindex.exit.i.i
  %cmp4.i.i.i = icmp ugt i32 %47, 255
  br i1 %cmp4.i.i.i, label %while.body.i.i.i, label %luaO_log2.exit.i.i

while.body.i.i.i:                                 ; preds = %if.then.i16.i, %while.body.i.i.i
  %l.06.i.i.i = phi i32 [ %add.i.i.i, %while.body.i.i.i ], [ -1, %if.then.i16.i ]
  %x.addr.05.i.i.i = phi i32 [ %shr.i.i.i, %while.body.i.i.i ], [ %47, %if.then.i16.i ]
  %add.i.i.i = add nsw i32 %l.06.i.i.i, 8
  %shr.i.i.i = lshr i32 %x.addr.05.i.i.i, 8
  %cmp.i4.i.i = icmp ugt i32 %x.addr.05.i.i.i, 65535
  br i1 %cmp.i4.i.i, label %while.body.i.i.i, label %luaO_log2.exit.i.i, !llvm.loop !54

luaO_log2.exit.i.i:                               ; preds = %while.body.i.i.i, %if.then.i16.i
  %x.addr.0.lcssa.i.i.i = phi i32 [ %47, %if.then.i16.i ], [ %shr.i.i.i, %while.body.i.i.i ]
  %l.0.lcssa.i.i.i = phi i32 [ -1, %if.then.i16.i ], [ %add.i.i.i, %while.body.i.i.i ]
  %idxprom.i.i.i = zext nneg i32 %x.addr.0.lcssa.i.i.i to i64
  %arrayidx.i.i.i = getelementptr inbounds [256 x i8], ptr @luaO_log2.log_2, i64 0, i64 %idxprom.i.i.i
  %48 = load i8, ptr %arrayidx.i.i.i, align 1
  %conv.i3.i.i = zext i8 %48 to i32
  %add1.i.i.i = add nsw i32 %l.0.lcssa.i.i.i, %conv.i3.i.i
  %49 = sext i32 %add1.i.i.i to i64
  %gep = getelementptr i32, ptr %invariant.gep, i64 %49
  %50 = load i32, ptr %gep, align 4
  %inc.i17.i = add nsw i32 %50, 1
  store i32 %inc.i17.i, ptr %gep, align 4
  br label %countint.exit.i

countint.exit.i:                                  ; preds = %luaO_log2.exit.i.i, %arrayindex.exit.i.i, %if.then.i.i15.i, %numusehash.exit.i
  %retval.0.i.i = phi i32 [ 1, %luaO_log2.exit.i.i ], [ 0, %arrayindex.exit.i.i ], [ 0, %numusehash.exit.i ], [ 0, %if.then.i.i15.i ]
  %add5.i = add nsw i32 %add3.i.i, %retval.0.i.i
  %cmp14.i.i = icmp sgt i32 %add5.i, 0
  br i1 %cmp14.i.i, label %for.body.i19.i, label %rehash.exit

for.body.i19.i:                                   ; preds = %countint.exit.i, %for.inc.i.i
  %indvars.iv.i20.i = phi i64 [ %indvars.iv.next.i24.i, %for.inc.i.i ], [ 0, %countint.exit.i ]
  %div1220.i.i = phi i32 [ %div12.i.i, %for.inc.i.i ], [ 0, %countint.exit.i ]
  %n.019.i.i = phi i32 [ %n.1.i.i, %for.inc.i.i ], [ 0, %countint.exit.i ]
  %na.018.i.i = phi i32 [ %na.1.i.i, %for.inc.i.i ], [ 0, %countint.exit.i ]
  %a.017.i.i = phi i32 [ %a.1.i.i, %for.inc.i.i ], [ 0, %countint.exit.i ]
  %twotoi.016.i.i = phi i32 [ %mul.i25.i, %for.inc.i.i ], [ 1, %countint.exit.i ]
  %arrayidx.i21.i = getelementptr inbounds i32, ptr %nums.i, i64 %indvars.iv.i20.i
  %51 = load i32, ptr %arrayidx.i21.i, align 4
  %cmp1.i22.i = icmp sgt i32 %51, 0
  %add.i23.i = add nsw i32 %51, %a.017.i.i
  %cmp5.i.i = icmp sgt i32 %add.i23.i, %div1220.i.i
  %a.1.i.i = select i1 %cmp1.i22.i, i32 %add.i23.i, i32 %a.017.i.i
  %52 = select i1 %cmp1.i22.i, i1 %cmp5.i.i, i1 false
  %na.1.i.i = select i1 %52, i32 %add.i23.i, i32 %na.018.i.i
  %n.1.i.i = select i1 %52, i32 %twotoi.016.i.i, i32 %n.019.i.i
  %cmp8.i.i = icmp eq i32 %a.1.i.i, %add5.i
  br i1 %cmp8.i.i, label %rehash.exit, label %for.inc.i.i

for.inc.i.i:                                      ; preds = %for.body.i19.i
  %indvars.iv.next.i24.i = add nuw i64 %indvars.iv.i20.i, 1
  %mul.i25.i = shl nsw i32 %twotoi.016.i.i, 1
  %div12.i.i = and i32 %twotoi.016.i.i, 2147483647
  %cmp.i26.i = icmp slt i32 %div12.i.i, %add5.i
  br i1 %cmp.i26.i, label %for.body.i19.i, label %rehash.exit, !llvm.loop !56

rehash.exit:                                      ; preds = %for.body.i19.i, %for.inc.i.i, %countint.exit.i
  %na.2.i.i = phi i32 [ 0, %countint.exit.i ], [ %na.1.i.i, %for.inc.i.i ], [ %na.1.i.i, %for.body.i19.i ]
  %n.2.i.i = phi i32 [ 0, %countint.exit.i ], [ %n.1.i.i, %for.inc.i.i ], [ %n.1.i.i, %for.body.i19.i ]
  %add.i = add i32 %ause.0.lcssa.i.i, 1
  %inc6.i = add i32 %add.i, %totaluse.0.lcssa.i.i
  %sub.i = sub i32 %inc6.i, %na.2.i.i
  tail call fastcc void @resize(ptr noundef %L, ptr noundef %t, i32 noundef %n.2.i.i, i32 noundef %sub.i)
  call void @llvm.lifetime.end.p0(i64 124, ptr nonnull %nums.i)
  %call.i = tail call fastcc ptr @luaH_get(ptr noundef %t, ptr noundef %key)
  store i8 0, ptr %flags.i, align 2
  %cmp.not.i = icmp eq ptr %call.i, @luaO_nilobject_
  br i1 %cmp.not.i, label %if.else.i, label %return

if.else.i:                                        ; preds = %rehash.exit
  %53 = load i32, ptr %tt.i, align 8
  switch i32 %53, label %tailrecurse.backedge [
    i32 0, label %if.end9.i.sink.split
    i32 3, label %land.lhs.true.i
  ]

land.lhs.true.i:                                  ; preds = %if.else.i
  %54 = load double, ptr %key, align 8
  %cmp7.i = fcmp ord double %54, 0.000000e+00
  br i1 %cmp7.i, label %tailrecurse.backedge, label %if.end9.i.sink.split

tailrecurse.backedge:                             ; preds = %land.lhs.true.i, %if.else.i
  br label %tailrecurse

if.end9.i.sink.split:                             ; preds = %land.lhs.true.i, %if.else.i
  %.str.40.sink = phi ptr [ @.str.39, %if.else.i ], [ @.str.40, %land.lhs.true.i ]
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef %L, ptr noundef nonnull %.str.40.sink)
  unreachable

if.end:                                           ; preds = %while.body.i
  %tt.le = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i, i64 0, i32 1
  %i_key = getelementptr inbounds %struct.Node, ptr %retval.0.i, i64 0, i32 1
  %tt.i50 = getelementptr inbounds %struct.Node, ptr %retval.0.i, i64 0, i32 1, i32 0, i32 1
  %55 = load i32, ptr %tt.i50, align 8
  switch i32 %55, label %sw.default.i95 [
    i32 3, label %sw.bb.i79
    i32 4, label %sw.bb1.i70
    i32 1, label %sw.bb5.i62
    i32 2, label %sw.bb18.i51
  ]

sw.bb.i79:                                        ; preds = %if.end
  %56 = load double, ptr %i_key, align 8
  %cmp.i.i80 = fcmp oeq double %56, 0.000000e+00
  br i1 %cmp.i.i80, label %mainposition.exit105, label %if.end.i.i81

if.end.i.i81:                                     ; preds = %sw.bb.i79
  %57 = bitcast double %56 to i64
  %a.sroa.0.4.extract.shift.i.i82 = lshr i64 %57, 32
  %add.i.i83 = add i64 %a.sroa.0.4.extract.shift.i.i82, %57
  %conv.i.i85 = and i64 %add.i.i83, 4294967295
  %58 = load i8, ptr %lsizenode23.i, align 1
  %sh_prom.i.i87 = zext nneg i8 %58 to i64
  %notmask.i.i88 = shl nsw i64 -1, %sh_prom.i.i87
  %sub.i.i89 = xor i64 %notmask.i.i88, -1
  %or.i.i90 = or i64 %sub.i.i89, 1
  %rem.i.i91 = urem i64 %conv.i.i85, %or.i.i90
  %arrayidx7.i.i92 = getelementptr inbounds %struct.Node, ptr %25, i64 %rem.i.i91
  br label %mainposition.exit105

sw.bb1.i70:                                       ; preds = %if.end
  %59 = load ptr, ptr %i_key, align 8
  %hash.i72 = getelementptr inbounds %struct.anon.0, ptr %59, i64 0, i32 4
  %60 = load i32, ptr %hash.i72, align 4
  %61 = load i8, ptr %lsizenode23.i, align 1
  %sh_prom.i74 = zext nneg i8 %61 to i64
  %notmask15.i75 = shl nsw i64 -1, %sh_prom.i74
  %62 = trunc i64 %notmask15.i75 to i32
  %63 = xor i32 %62, -1
  %conv4.i76 = and i32 %60, %63
  %idxprom.i77 = sext i32 %conv4.i76 to i64
  %arrayidx.i78 = getelementptr inbounds %struct.Node, ptr %25, i64 %idxprom.i77
  br label %mainposition.exit105

sw.bb5.i62:                                       ; preds = %if.end
  %64 = load i32, ptr %i_key, align 8
  %65 = load i8, ptr %lsizenode23.i, align 1
  %sh_prom11.i65 = zext nneg i8 %65 to i64
  %notmask14.i66 = shl nsw i64 -1, %sh_prom11.i65
  %66 = trunc i64 %notmask14.i66 to i32
  %67 = xor i32 %66, -1
  %conv15.i67 = and i32 %64, %67
  %idxprom16.i68 = sext i32 %conv15.i67 to i64
  %arrayidx17.i69 = getelementptr inbounds %struct.Node, ptr %25, i64 %idxprom16.i68
  br label %mainposition.exit105

sw.bb18.i51:                                      ; preds = %if.end
  %68 = load ptr, ptr %i_key, align 8
  %69 = ptrtoint ptr %68 to i64
  %conv22.i53 = and i64 %69, 4294967295
  %70 = load i8, ptr %lsizenode23.i, align 1
  %sh_prom25.i55 = zext nneg i8 %70 to i64
  %notmask.i56 = shl nsw i64 -1, %sh_prom25.i55
  %sub27.i57 = xor i64 %notmask.i56, -1
  %or.i58 = or i64 %sub27.i57, 1
  %rem.i59 = urem i64 %conv22.i53, %or.i58
  %arrayidx28.i60 = getelementptr inbounds %struct.Node, ptr %25, i64 %rem.i59
  br label %mainposition.exit105

sw.default.i95:                                   ; preds = %if.end
  %71 = load ptr, ptr %i_key, align 8
  %72 = ptrtoint ptr %71 to i64
  %conv32.i97 = and i64 %72, 4294967295
  %73 = load i8, ptr %lsizenode23.i, align 1
  %sh_prom35.i99 = zext nneg i8 %73 to i64
  %notmask16.i100 = shl nsw i64 -1, %sh_prom35.i99
  %sub37.i101 = xor i64 %notmask16.i100, -1
  %or38.i102 = or i64 %sub37.i101, 1
  %rem39.i103 = urem i64 %conv32.i97, %or38.i102
  %arrayidx40.i104 = getelementptr inbounds %struct.Node, ptr %25, i64 %rem39.i103
  br label %mainposition.exit105

mainposition.exit105:                             ; preds = %sw.bb.i79, %if.end.i.i81, %sw.bb1.i70, %sw.bb5.i62, %sw.bb18.i51, %sw.default.i95
  %retval.0.i61 = phi ptr [ %arrayidx40.i104, %sw.default.i95 ], [ %arrayidx28.i60, %sw.bb18.i51 ], [ %arrayidx17.i69, %sw.bb5.i62 ], [ %arrayidx.i78, %sw.bb1.i70 ], [ %arrayidx7.i.i92, %if.end.i.i81 ], [ %25, %sw.bb.i79 ]
  %cmp7.not = icmp eq ptr %retval.0.i61, %retval.0.i
  br i1 %cmp7.not, label %if.else, label %while.cond

while.cond:                                       ; preds = %mainposition.exit105, %while.cond
  %othern.0 = phi ptr [ %74, %while.cond ], [ %retval.0.i61, %mainposition.exit105 ]
  %next = getelementptr inbounds %struct.Node, ptr %othern.0, i64 0, i32 1, i32 0, i32 2
  %74 = load ptr, ptr %next, align 8
  %cmp10.not = icmp eq ptr %74, %retval.0.i
  br i1 %cmp10.not, label %while.end, label %while.cond, !llvm.loop !57

while.end:                                        ; preds = %while.cond
  %next.le = getelementptr inbounds %struct.Node, ptr %othern.0, i64 0, i32 1, i32 0, i32 2
  store ptr %incdec.ptr.i, ptr %next.le, align 8
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %incdec.ptr.i, ptr noundef nonnull align 8 dereferenceable(40) %retval.0.i, i64 40, i1 false)
  %next16 = getelementptr inbounds %struct.Node, ptr %retval.0.i, i64 0, i32 1, i32 0, i32 2
  store ptr null, ptr %next16, align 8
  store i32 0, ptr %tt.le, align 8
  br label %if.end26

if.else:                                          ; preds = %mainposition.exit105
  %next20 = getelementptr inbounds %struct.Node, ptr %retval.0.i, i64 0, i32 1, i32 0, i32 2
  %75 = load ptr, ptr %next20, align 8
  %next22 = getelementptr %struct.Node, ptr %incdec.ptr6.i, i64 -1, i32 1, i32 0, i32 2
  store ptr %75, ptr %next22, align 8
  store ptr %incdec.ptr.i, ptr %next20, align 8
  br label %if.end26

if.end26:                                         ; preds = %mainposition.exit, %while.end, %if.else
  %mp.0 = phi ptr [ %retval.0.i, %while.end ], [ %incdec.ptr.i, %if.else ], [ %retval.0.i, %mainposition.exit ]
  %i_key27 = getelementptr inbounds %struct.Node, ptr %mp.0, i64 0, i32 1
  %76 = load i64, ptr %key, align 8
  store i64 %76, ptr %i_key27, align 8
  %77 = load i32, ptr %tt.i, align 8
  %tt31 = getelementptr inbounds %struct.Node, ptr %mp.0, i64 0, i32 1, i32 0, i32 1
  store i32 %77, ptr %tt31, align 8
  %cmp33 = icmp sgt i32 %77, 3
  br i1 %cmp33, label %land.lhs.true, label %return

land.lhs.true:                                    ; preds = %if.end26
  %78 = load ptr, ptr %key, align 8
  %marked = getelementptr inbounds %struct.GCheader, ptr %78, i64 0, i32 2
  %79 = load i8, ptr %marked, align 1
  %80 = and i8 %79, 3
  %tobool.not = icmp eq i8 %80, 0
  br i1 %tobool.not, label %return, label %land.lhs.true35

land.lhs.true35:                                  ; preds = %land.lhs.true
  %marked36 = getelementptr inbounds %struct.GCheader, ptr %t, i64 0, i32 2
  %81 = load i8, ptr %marked36, align 1
  %82 = and i8 %81, 4
  %tobool39.not = icmp eq i8 %82, 0
  br i1 %tobool39.not, label %return, label %if.then40

if.then40:                                        ; preds = %land.lhs.true35
  %83 = getelementptr i8, ptr %L, i64 32
  %L.val = load ptr, ptr %83, align 8
  %84 = and i8 %81, -5
  store i8 %84, ptr %marked36, align 1
  %grayagain.i = getelementptr inbounds %struct.global_State, ptr %L.val, i64 0, i32 9
  %85 = load ptr, ptr %grayagain.i, align 8
  %gclist.i = getelementptr inbounds %struct.Table, ptr %t, i64 0, i32 9
  store ptr %85, ptr %gclist.i, align 8
  store ptr %t, ptr %grayagain.i, align 8
  br label %return

return:                                           ; preds = %rehash.exit, %if.end26, %land.lhs.true, %land.lhs.true35, %if.then40
  %retval.0 = phi ptr [ %mp.0, %if.then40 ], [ %mp.0, %land.lhs.true35 ], [ %mp.0, %land.lhs.true ], [ %mp.0, %if.end26 ], [ %call.i, %rehash.exit ]
  ret ptr %retval.0
}

; Function Attrs: nounwind uwtable
define internal fastcc void @resize(ptr noundef %L, ptr noundef %t, i32 noundef %nasize, i32 noundef %nhsize) unnamed_addr #0 {
entry:
  %k.i = alloca %struct.lua_TValue, align 8
  %sizearray = getelementptr inbounds %struct.Table, ptr %t, i64 0, i32 10
  %0 = load i32, ptr %sizearray, align 8
  %lsizenode = getelementptr inbounds %struct.Table, ptr %t, i64 0, i32 4
  %1 = load i8, ptr %lsizenode, align 1
  %node = getelementptr inbounds %struct.Table, ptr %t, i64 0, i32 7
  %2 = load ptr, ptr %node, align 8
  %cmp = icmp slt i32 %0, %nasize
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call fastcc void @setarrayvector(ptr noundef %L, ptr noundef nonnull %t, i32 noundef %nasize)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  tail call fastcc void @setnodevector(ptr noundef %L, ptr noundef nonnull %t, i32 noundef %nhsize)
  %cmp2 = icmp sgt i32 %0, %nasize
  br i1 %cmp2, label %if.then4, label %if.end29

if.then4:                                         ; preds = %if.end
  store i32 %nasize, ptr %sizearray, align 8
  %array = getelementptr inbounds %struct.Table, ptr %t, i64 0, i32 6
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %k.i, i64 0, i32 1
  %3 = sext i32 %nasize to i64
  br label %for.body

for.body:                                         ; preds = %if.then4, %for.inc
  %indvars.iv = phi i64 [ %3, %if.then4 ], [ %indvars.iv.next.pre-phi, %for.inc ]
  %4 = load ptr, ptr %array, align 8
  %tt = getelementptr inbounds %struct.lua_TValue, ptr %4, i64 %indvars.iv, i32 1
  %5 = load i32, ptr %tt, align 8
  %cmp8 = icmp eq i32 %5, 0
  br i1 %cmp8, label %for.body.for.inc_crit_edge, label %if.then10

for.body.for.inc_crit_edge:                       ; preds = %for.body
  %.pre = add nsw i64 %indvars.iv, 1
  br label %for.inc

if.then10:                                        ; preds = %for.body
  %arrayidx = getelementptr inbounds %struct.lua_TValue, ptr %4, i64 %indvars.iv
  %6 = add nsw i64 %indvars.iv, 1
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %k.i)
  %7 = load i32, ptr %sizearray, align 8
  %8 = trunc i64 %indvars.iv to i32
  %cmp.i58 = icmp ugt i32 %7, %8
  br i1 %cmp.i58, label %luaH_getnum.exit, label %if.else.i59

if.else.i59:                                      ; preds = %if.then10
  %9 = trunc i64 %6 to i32
  %conv.i60 = sitofp i32 %9 to double
  %cmp.i.i = icmp eq i32 %9, 0
  br i1 %cmp.i.i, label %if.then.i.i65, label %if.end.i.i61

if.then.i.i65:                                    ; preds = %if.else.i59
  %10 = load ptr, ptr %node, align 8
  br label %do.body.i.preheader

if.end.i.i61:                                     ; preds = %if.else.i59
  %11 = bitcast double %conv.i60 to i64
  %a.sroa.0.4.extract.shift.i.i = lshr i64 %11, 32
  %add.i.i = add i64 %a.sroa.0.4.extract.shift.i.i, %11
  %12 = load ptr, ptr %node, align 8
  %conv.i.i = and i64 %add.i.i, 4294967295
  %13 = load i8, ptr %lsizenode, align 1
  %sh_prom.i.i = zext nneg i8 %13 to i64
  %notmask.i.i = shl nsw i64 -1, %sh_prom.i.i
  %sub.i.i = xor i64 %notmask.i.i, -1
  %or.i.i = or i64 %sub.i.i, 1
  %rem.i.i = urem i64 %conv.i.i, %or.i.i
  %arrayidx7.i.i = getelementptr inbounds %struct.Node, ptr %12, i64 %rem.i.i
  br label %do.body.i.preheader

do.body.i.preheader:                              ; preds = %if.end.i.i61, %if.then.i.i65
  %n.0.i.ph = phi ptr [ %arrayidx7.i.i, %if.end.i.i61 ], [ %10, %if.then.i.i65 ]
  br label %do.body.i

do.body.i:                                        ; preds = %do.body.i.preheader, %if.else8.i
  %n.0.i = phi ptr [ %16, %if.else8.i ], [ %n.0.i.ph, %do.body.i.preheader ]
  %tt.i62 = getelementptr inbounds %struct.Node, ptr %n.0.i, i64 0, i32 1, i32 0, i32 1
  %14 = load i32, ptr %tt.i62, align 8
  %cmp2.i = icmp eq i32 %14, 3
  br i1 %cmp2.i, label %land.lhs.true.i64, label %if.else8.i

land.lhs.true.i64:                                ; preds = %do.body.i
  %i_key.i = getelementptr inbounds %struct.Node, ptr %n.0.i, i64 0, i32 1
  %15 = load double, ptr %i_key.i, align 8
  %cmp5.i = fcmp oeq double %15, %conv.i60
  br i1 %cmp5.i, label %luaH_getnum.exit, label %if.else8.i

if.else8.i:                                       ; preds = %land.lhs.true.i64, %do.body.i
  %next.i = getelementptr inbounds %struct.Node, ptr %n.0.i, i64 0, i32 1, i32 0, i32 2
  %16 = load ptr, ptr %next.i, align 8
  %tobool.not.i = icmp eq ptr %16, null
  br i1 %tobool.not.i, label %if.else.i, label %do.body.i, !llvm.loop !7

luaH_getnum.exit:                                 ; preds = %land.lhs.true.i64, %if.then10
  %retval.0.i63 = phi ptr [ %arrayidx, %if.then10 ], [ %n.0.i, %land.lhs.true.i64 ]
  %cmp.not.i = icmp eq ptr %retval.0.i63, @luaO_nilobject_
  br i1 %cmp.not.i, label %luaH_getnum.exit.if.else.i_crit_edge, label %luaH_setnum.exit

luaH_getnum.exit.if.else.i_crit_edge:             ; preds = %luaH_getnum.exit
  %.pre80 = trunc i64 %6 to i32
  %.pre81 = sitofp i32 %.pre80 to double
  br label %if.else.i

if.else.i:                                        ; preds = %if.else8.i, %luaH_getnum.exit.if.else.i_crit_edge
  %conv.i.pre-phi = phi double [ %.pre81, %luaH_getnum.exit.if.else.i_crit_edge ], [ %conv.i60, %if.else8.i ]
  store double %conv.i.pre-phi, ptr %k.i, align 8
  store i32 3, ptr %tt.i, align 8
  %call1.i = call fastcc ptr @newkey(ptr noundef %L, ptr noundef %t, ptr noundef nonnull %k.i)
  br label %luaH_setnum.exit

luaH_setnum.exit:                                 ; preds = %luaH_getnum.exit, %if.else.i
  %retval.0.i = phi ptr [ %call1.i, %if.else.i ], [ %retval.0.i63, %luaH_getnum.exit ]
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %k.i)
  %17 = load i64, ptr %arrayidx, align 8
  store i64 %17, ptr %retval.0.i, align 8
  %18 = load i32, ptr %tt, align 8
  %tt16 = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i, i64 0, i32 1
  store i32 %18, ptr %tt16, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body.for.inc_crit_edge, %luaH_setnum.exit
  %indvars.iv.next.pre-phi = phi i64 [ %.pre, %for.body.for.inc_crit_edge ], [ %6, %luaH_setnum.exit ]
  %lftr.wideiv = trunc i64 %indvars.iv.next.pre-phi to i32
  %exitcond.not = icmp eq i32 %0, %lftr.wideiv
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !58

for.end:                                          ; preds = %for.inc
  %cmp20 = icmp sgt i32 %nasize, -2
  br i1 %cmp20, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.end
  %19 = load ptr, ptr %array, align 8
  %conv23 = sext i32 %0 to i64
  %mul = shl nsw i64 %conv23, 4
  %mul25 = shl nsw i64 %3, 4
  %l_G.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %20 = load ptr, ptr %l_G.i, align 8
  %frealloc.i = getelementptr inbounds %struct.global_State, ptr %20, i64 0, i32 1
  %21 = load ptr, ptr %frealloc.i, align 8
  %ud.i = getelementptr inbounds %struct.global_State, ptr %20, i64 0, i32 2
  %22 = load ptr, ptr %ud.i, align 8
  %call.i45 = tail call ptr %21(ptr noundef %22, ptr noundef %19, i64 noundef %mul, i64 noundef %mul25) #35
  %cmp.i = icmp eq ptr %call.i45, null
  %cmp1.i = icmp ne i32 %nasize, 0
  %or.cond.i = and i1 %cmp1.i, %cmp.i
  br i1 %or.cond.i, label %if.then.i, label %luaM_realloc_.exit

if.then.i:                                        ; preds = %cond.true
  %errorJmp.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 26
  %23 = load ptr, ptr %errorJmp.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %23, null
  br i1 %tobool.not.i.i, label %if.else.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %if.then.i
  %status.i.i = getelementptr inbounds %struct.lua_longjmp, ptr %23, i64 0, i32 2
  store volatile i32 4, ptr %status.i.i, align 8
  %24 = load ptr, ptr %errorJmp.i.i, align 8
  %b.i.i = getelementptr inbounds %struct.lua_longjmp, ptr %24, i64 0, i32 1
  tail call void @longjmp(ptr noundef nonnull %b.i.i, i32 noundef 1) #38
  unreachable

if.else.i.i:                                      ; preds = %if.then.i
  %status3.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 3
  store i8 4, ptr %status3.i.i, align 2
  %25 = load ptr, ptr %l_G.i, align 8
  %panic.i.i = getelementptr inbounds %struct.global_State, ptr %25, i64 0, i32 19
  %26 = load ptr, ptr %panic.i.i, align 8
  %tobool4.not.i.i = icmp eq ptr %26, null
  br i1 %tobool4.not.i.i, label %if.end.i.i, label %if.then5.i.i

if.then5.i.i:                                     ; preds = %if.else.i.i
  tail call fastcc void @resetstack(ptr noundef nonnull %L, i32 noundef 4)
  %27 = load ptr, ptr %l_G.i, align 8
  %panic7.i.i = getelementptr inbounds %struct.global_State, ptr %27, i64 0, i32 19
  %28 = load ptr, ptr %panic7.i.i, align 8
  %call.i.i = tail call i32 %28(ptr noundef nonnull %L) #35
  br label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then5.i.i, %if.else.i.i
  tail call void @exit(i32 noundef 1) #38
  unreachable

luaM_realloc_.exit:                               ; preds = %cond.true
  %totalbytes.i = getelementptr inbounds %struct.global_State, ptr %20, i64 0, i32 14
  %29 = load i64, ptr %totalbytes.i, align 8
  %sub.i = sub nsw i64 %mul25, %mul
  %add.i = add i64 %sub.i, %29
  store i64 %add.i, ptr %totalbytes.i, align 8
  store ptr %call.i45, ptr %array, align 8
  br label %if.end29

cond.false:                                       ; preds = %for.end
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef %L, ptr noundef nonnull @.str.5)
  unreachable

if.end29:                                         ; preds = %luaM_realloc_.exit, %if.end
  %sh_prom = zext nneg i8 %1 to i64
  %shl = shl nuw i64 1, %sh_prom
  %30 = trunc i64 %shl to i32
  %i.171 = add i32 %30, -1
  %cmp3272 = icmp sgt i32 %i.171, -1
  br i1 %cmp3272, label %for.body34.lr.ph, label %for.end49

for.body34.lr.ph:                                 ; preds = %if.end29
  %flags.i = getelementptr inbounds %struct.Table, ptr %t, i64 0, i32 3
  %31 = zext nneg i32 %i.171 to i64
  br label %for.body34

for.body34:                                       ; preds = %for.body34.lr.ph, %for.inc48
  %indvars.iv77 = phi i64 [ %31, %for.body34.lr.ph ], [ %indvars.iv.next78, %for.inc48 ]
  %add.ptr = getelementptr inbounds %struct.Node, ptr %2, i64 %indvars.iv77
  %tt35 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr, i64 0, i32 1
  %32 = load i32, ptr %tt35, align 8
  %cmp36 = icmp eq i32 %32, 0
  br i1 %cmp36, label %for.inc48, label %if.then38

if.then38:                                        ; preds = %for.body34
  %i_key = getelementptr inbounds %struct.Node, ptr %2, i64 %indvars.iv77, i32 1
  %call.i46 = tail call fastcc ptr @luaH_get(ptr noundef %t, ptr noundef nonnull %i_key)
  store i8 0, ptr %flags.i, align 2
  %cmp.not.i47 = icmp eq ptr %call.i46, @luaO_nilobject_
  br i1 %cmp.not.i47, label %if.else.i49, label %luaH_set.exit

if.else.i49:                                      ; preds = %if.then38
  %tt.i50 = getelementptr inbounds %struct.lua_TValue, ptr %i_key, i64 0, i32 1
  %33 = load i32, ptr %tt.i50, align 8
  switch i32 %33, label %if.end9.i [
    i32 0, label %if.end9.i.sink.split
    i32 3, label %land.lhs.true.i
  ]

land.lhs.true.i:                                  ; preds = %if.else.i49
  %34 = load double, ptr %i_key, align 8
  %cmp7.i = fcmp ord double %34, 0.000000e+00
  br i1 %cmp7.i, label %if.end9.i, label %if.end9.i.sink.split

if.end9.i.sink.split:                             ; preds = %land.lhs.true.i, %if.else.i49
  %.str.40.sink = phi ptr [ @.str.39, %if.else.i49 ], [ @.str.40, %land.lhs.true.i ]
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef %L, ptr noundef nonnull %.str.40.sink)
  unreachable

if.end9.i:                                        ; preds = %land.lhs.true.i, %if.else.i49
  %call10.i = tail call fastcc ptr @newkey(ptr noundef %L, ptr noundef nonnull %t, ptr noundef nonnull %i_key)
  br label %luaH_set.exit

luaH_set.exit:                                    ; preds = %if.then38, %if.end9.i
  %retval.0.i48 = phi ptr [ %call10.i, %if.end9.i ], [ %call.i46, %if.then38 ]
  %35 = load i64, ptr %add.ptr, align 8
  store i64 %35, ptr %retval.0.i48, align 8
  %36 = load i32, ptr %tt35, align 8
  %tt46 = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i48, i64 0, i32 1
  store i32 %36, ptr %tt46, align 8
  br label %for.inc48

for.inc48:                                        ; preds = %for.body34, %luaH_set.exit
  %indvars.iv.next78 = add nsw i64 %indvars.iv77, -1
  %cmp32 = icmp sgt i64 %indvars.iv77, 0
  br i1 %cmp32, label %for.body34, label %for.end49, !llvm.loop !59

for.end49:                                        ; preds = %for.inc48, %if.end29
  %cmp50.not = icmp eq ptr %2, @dummynode_
  br i1 %cmp50.not, label %if.end57, label %if.then52

if.then52:                                        ; preds = %for.end49
  %mul5544 = shl i64 40, %sh_prom
  %l_G.i51 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %37 = load ptr, ptr %l_G.i51, align 8
  %frealloc.i52 = getelementptr inbounds %struct.global_State, ptr %37, i64 0, i32 1
  %38 = load ptr, ptr %frealloc.i52, align 8
  %ud.i53 = getelementptr inbounds %struct.global_State, ptr %37, i64 0, i32 2
  %39 = load ptr, ptr %ud.i53, align 8
  %call.i54 = tail call ptr %38(ptr noundef %39, ptr noundef %2, i64 noundef %mul5544, i64 noundef 0) #35
  %totalbytes.i56 = getelementptr inbounds %struct.global_State, ptr %37, i64 0, i32 14
  %40 = load i64, ptr %totalbytes.i56, align 8
  %sub.i57 = sub i64 %40, %mul5544
  store i64 %sub.i57, ptr %totalbytes.i56, align 8
  br label %if.end57

if.end57:                                         ; preds = %if.then52, %for.end49
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @setarrayvector(ptr noundef %L, ptr nocapture noundef %t, i32 noundef %size) unnamed_addr #0 {
entry:
  %cmp = icmp sgt i32 %size, -2
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %array = getelementptr inbounds %struct.Table, ptr %t, i64 0, i32 6
  %0 = load ptr, ptr %array, align 8
  %sizearray = getelementptr inbounds %struct.Table, ptr %t, i64 0, i32 10
  %1 = load i32, ptr %sizearray, align 8
  %conv2 = sext i32 %1 to i64
  %mul = shl nsw i64 %conv2, 4
  %conv3 = sext i32 %size to i64
  %mul4 = shl nsw i64 %conv3, 4
  %l_G.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %2 = load ptr, ptr %l_G.i, align 8
  %frealloc.i = getelementptr inbounds %struct.global_State, ptr %2, i64 0, i32 1
  %3 = load ptr, ptr %frealloc.i, align 8
  %ud.i = getelementptr inbounds %struct.global_State, ptr %2, i64 0, i32 2
  %4 = load ptr, ptr %ud.i, align 8
  %call.i = tail call ptr %3(ptr noundef %4, ptr noundef %0, i64 noundef %mul, i64 noundef %mul4) #35
  %cmp.i = icmp eq ptr %call.i, null
  %cmp1.i = icmp ne i32 %size, 0
  %or.cond.i = and i1 %cmp1.i, %cmp.i
  br i1 %or.cond.i, label %if.then.i, label %luaM_realloc_.exit

if.then.i:                                        ; preds = %cond.true
  %errorJmp.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 26
  %5 = load ptr, ptr %errorJmp.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %5, null
  br i1 %tobool.not.i.i, label %if.else.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %if.then.i
  %status.i.i = getelementptr inbounds %struct.lua_longjmp, ptr %5, i64 0, i32 2
  store volatile i32 4, ptr %status.i.i, align 8
  %6 = load ptr, ptr %errorJmp.i.i, align 8
  %b.i.i = getelementptr inbounds %struct.lua_longjmp, ptr %6, i64 0, i32 1
  tail call void @longjmp(ptr noundef nonnull %b.i.i, i32 noundef 1) #38
  unreachable

if.else.i.i:                                      ; preds = %if.then.i
  %status3.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 3
  store i8 4, ptr %status3.i.i, align 2
  %7 = load ptr, ptr %l_G.i, align 8
  %panic.i.i = getelementptr inbounds %struct.global_State, ptr %7, i64 0, i32 19
  %8 = load ptr, ptr %panic.i.i, align 8
  %tobool4.not.i.i = icmp eq ptr %8, null
  br i1 %tobool4.not.i.i, label %if.end.i.i, label %if.then5.i.i

if.then5.i.i:                                     ; preds = %if.else.i.i
  tail call fastcc void @resetstack(ptr noundef nonnull %L, i32 noundef 4)
  %9 = load ptr, ptr %l_G.i, align 8
  %panic7.i.i = getelementptr inbounds %struct.global_State, ptr %9, i64 0, i32 19
  %10 = load ptr, ptr %panic7.i.i, align 8
  %call.i.i = tail call i32 %10(ptr noundef nonnull %L) #35
  br label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then5.i.i, %if.else.i.i
  tail call void @exit(i32 noundef 1) #38
  unreachable

luaM_realloc_.exit:                               ; preds = %cond.true
  %totalbytes.i = getelementptr inbounds %struct.global_State, ptr %2, i64 0, i32 14
  %11 = load i64, ptr %totalbytes.i, align 8
  %sub.i = sub nsw i64 %mul4, %mul
  %add.i = add i64 %sub.i, %11
  store i64 %add.i, ptr %totalbytes.i, align 8
  %array6 = getelementptr inbounds %struct.Table, ptr %t, i64 0, i32 6
  store ptr %call.i, ptr %array6, align 8
  %sizearray7 = getelementptr inbounds %struct.Table, ptr %t, i64 0, i32 10
  %12 = load i32, ptr %sizearray7, align 8
  %cmp812 = icmp slt i32 %12, %size
  br i1 %cmp812, label %for.body.preheader, label %for.end

cond.false:                                       ; preds = %entry
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef %L, ptr noundef nonnull @.str.5)
  unreachable

for.body.preheader:                               ; preds = %luaM_realloc_.exit
  %13 = sext i32 %12 to i64
  %wide.trip.count = sext i32 %size to i64
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %for.body
  %indvars.iv = phi i64 [ %13, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %14 = load ptr, ptr %array6, align 8
  %tt = getelementptr inbounds %struct.lua_TValue, ptr %14, i64 %indvars.iv, i32 1
  store i32 0, ptr %tt, align 8
  %indvars.iv.next = add nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !60

for.end:                                          ; preds = %for.body, %luaM_realloc_.exit
  store i32 %size, ptr %sizearray7, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @setnodevector(ptr noundef %L, ptr nocapture noundef %t, i32 noundef %size) unnamed_addr #0 {
entry:
  %cmp = icmp eq i32 %size, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %node = getelementptr inbounds %struct.Table, ptr %t, i64 0, i32 7
  store ptr @dummynode_, ptr %node, align 8
  br label %if.end16

if.else:                                          ; preds = %entry
  %sub = add nsw i32 %size, -1
  %cmp4.i = icmp ugt i32 %sub, 255
  br i1 %cmp4.i, label %while.body.i, label %luaO_log2.exit

while.body.i:                                     ; preds = %if.else, %while.body.i
  %l.06.i = phi i32 [ %add.i, %while.body.i ], [ -1, %if.else ]
  %x.addr.05.i = phi i32 [ %shr.i, %while.body.i ], [ %sub, %if.else ]
  %add.i = add nsw i32 %l.06.i, 8
  %shr.i = lshr i32 %x.addr.05.i, 8
  %cmp.i = icmp ugt i32 %x.addr.05.i, 65535
  br i1 %cmp.i, label %while.body.i, label %luaO_log2.exit, !llvm.loop !54

luaO_log2.exit:                                   ; preds = %while.body.i, %if.else
  %x.addr.0.lcssa.i = phi i32 [ %sub, %if.else ], [ %shr.i, %while.body.i ]
  %l.0.lcssa.i = phi i32 [ -1, %if.else ], [ %add.i, %while.body.i ]
  %idxprom.i = zext nneg i32 %x.addr.0.lcssa.i to i64
  %arrayidx.i = getelementptr inbounds [256 x i8], ptr @luaO_log2.log_2, i64 0, i64 %idxprom.i
  %0 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %0 to i32
  %add1.i = add nsw i32 %l.0.lcssa.i, %conv.i
  %add = add nsw i32 %add1.i, 1
  %cmp1 = icmp sgt i32 %add1.i, 29
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %luaO_log2.exit
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef %L, ptr noundef nonnull @.str.41)
  unreachable

if.end:                                           ; preds = %luaO_log2.exit
  %sh_prom = zext nneg i32 %add to i64
  %shl = shl nuw i64 1, %sh_prom
  %conv = trunc i64 %shl to i32
  %add3 = shl i64 4294967296, %sh_prom
  %sext = add nuw i64 %add3, 4294967296
  %cmp5 = icmp sgt i64 %sext, -1
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %conv7 = ashr exact i64 %add3, 32
  %mul = mul nsw i64 %conv7, 40
  %l_G.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %1 = load ptr, ptr %l_G.i, align 8
  %frealloc.i = getelementptr inbounds %struct.global_State, ptr %1, i64 0, i32 1
  %2 = load ptr, ptr %frealloc.i, align 8
  %ud.i = getelementptr inbounds %struct.global_State, ptr %1, i64 0, i32 2
  %3 = load ptr, ptr %ud.i, align 8
  %call.i = tail call ptr %2(ptr noundef %3, ptr noundef null, i64 noundef 0, i64 noundef %mul) #35
  %cmp.i21 = icmp eq ptr %call.i, null
  %cmp1.i = icmp ult i32 %add, 32
  %or.cond.i = and i1 %cmp1.i, %cmp.i21
  br i1 %or.cond.i, label %if.then.i, label %luaM_realloc_.exit

if.then.i:                                        ; preds = %cond.true
  %errorJmp.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 26
  %4 = load ptr, ptr %errorJmp.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %4, null
  br i1 %tobool.not.i.i, label %if.else.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %if.then.i
  %status.i.i = getelementptr inbounds %struct.lua_longjmp, ptr %4, i64 0, i32 2
  store volatile i32 4, ptr %status.i.i, align 8
  %5 = load ptr, ptr %errorJmp.i.i, align 8
  %b.i.i = getelementptr inbounds %struct.lua_longjmp, ptr %5, i64 0, i32 1
  tail call void @longjmp(ptr noundef nonnull %b.i.i, i32 noundef 1) #38
  unreachable

if.else.i.i:                                      ; preds = %if.then.i
  %status3.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 3
  store i8 4, ptr %status3.i.i, align 2
  %6 = load ptr, ptr %l_G.i, align 8
  %panic.i.i = getelementptr inbounds %struct.global_State, ptr %6, i64 0, i32 19
  %7 = load ptr, ptr %panic.i.i, align 8
  %tobool4.not.i.i = icmp eq ptr %7, null
  br i1 %tobool4.not.i.i, label %if.end.i.i, label %if.then5.i.i

if.then5.i.i:                                     ; preds = %if.else.i.i
  tail call fastcc void @resetstack(ptr noundef nonnull %L, i32 noundef 4)
  %8 = load ptr, ptr %l_G.i, align 8
  %panic7.i.i = getelementptr inbounds %struct.global_State, ptr %8, i64 0, i32 19
  %9 = load ptr, ptr %panic7.i.i, align 8
  %call.i.i = tail call i32 %9(ptr noundef nonnull %L) #35
  br label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then5.i.i, %if.else.i.i
  tail call void @exit(i32 noundef 1) #38
  unreachable

luaM_realloc_.exit:                               ; preds = %cond.true
  %totalbytes.i = getelementptr inbounds %struct.global_State, ptr %1, i64 0, i32 14
  %10 = load i64, ptr %totalbytes.i, align 8
  %add.i22 = add i64 %10, %mul
  store i64 %add.i22, ptr %totalbytes.i, align 8
  %node10 = getelementptr inbounds %struct.Table, ptr %t, i64 0, i32 7
  store ptr %call.i, ptr %node10, align 8
  %cmp1123 = icmp sgt i32 %conv, 0
  br i1 %cmp1123, label %for.body.preheader, label %if.end16

cond.false:                                       ; preds = %if.end
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef %L, ptr noundef nonnull @.str.5)
  unreachable

for.body.preheader:                               ; preds = %luaM_realloc_.exit
  %wide.trip.count = and i64 %shl, 4294967295
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %11 = load ptr, ptr %node10, align 8
  %i_key = getelementptr inbounds %struct.Node, ptr %11, i64 %indvars.iv, i32 1
  %next = getelementptr inbounds %struct.anon.2, ptr %i_key, i64 0, i32 2
  store ptr null, ptr %next, align 8
  %tt = getelementptr inbounds %struct.anon.2, ptr %i_key, i64 0, i32 1
  store i32 0, ptr %tt, align 8
  %tt15 = getelementptr inbounds %struct.Node, ptr %11, i64 %indvars.iv, i32 0, i32 1
  store i32 0, ptr %tt15, align 8
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %if.end16.loopexit, label %for.body, !llvm.loop !61

if.end16.loopexit:                                ; preds = %for.body
  %.pre = load ptr, ptr %node10, align 8
  br label %if.end16

if.end16:                                         ; preds = %if.end16.loopexit, %luaM_realloc_.exit, %if.then
  %12 = phi ptr [ @dummynode_, %if.then ], [ %call.i, %luaM_realloc_.exit ], [ %.pre, %if.end16.loopexit ]
  %lsize.0 = phi i32 [ 0, %if.then ], [ %add, %luaM_realloc_.exit ], [ %add, %if.end16.loopexit ]
  %size.addr.0 = phi i64 [ 0, %if.then ], [ %shl, %luaM_realloc_.exit ], [ %shl, %if.end16.loopexit ]
  %conv17 = trunc i32 %lsize.0 to i8
  %lsizenode = getelementptr inbounds %struct.Table, ptr %t, i64 0, i32 4
  store i8 %conv17, ptr %lsizenode, align 1
  %sext20 = shl i64 %size.addr.0, 32
  %idxprom19 = ashr exact i64 %sext20, 32
  %arrayidx20 = getelementptr inbounds %struct.Node, ptr %12, i64 %idxprom19
  %lastfree = getelementptr inbounds %struct.Table, ptr %t, i64 0, i32 8
  store ptr %arrayidx20, ptr %lastfree, align 8
  ret void
}

; Function Attrs: mustprogress nofree nounwind willreturn memory(read)
declare i32 @strcoll(ptr nocapture noundef, ptr nocapture noundef) local_unnamed_addr #15

; Function Attrs: mustprogress nofree nounwind willreturn
declare double @strtod(ptr noundef readonly, ptr nocapture noundef) local_unnamed_addr #16

; Function Attrs: mustprogress nofree nounwind willreturn
declare i64 @strtoul(ptr noundef readonly, ptr nocapture noundef, i32 noundef) local_unnamed_addr #16

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
declare ptr @__ctype_b_loc() local_unnamed_addr #17

; Function Attrs: nounwind uwtable
define internal fastcc i64 @singlestep(ptr noundef %L) unnamed_addr #0 {
entry:
  %l_G = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %0 = load ptr, ptr %l_G, align 8
  %gcstate = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 4
  %1 = load i8, ptr %gcstate, align 1
  switch i8 %1, label %return [
    i8 0, label %sw.bb
    i8 1, label %sw.bb1
    i8 2, label %sw.bb2
    i8 3, label %sw.bb11
    i8 4, label %sw.bb26
  ]

sw.bb:                                            ; preds = %entry
  %gray.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 8
  %mainthread.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 21
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %gray.i, i8 0, i64 24, i1 false)
  %2 = load ptr, ptr %mainthread.i, align 8
  %marked.i = getelementptr inbounds %struct.GCheader, ptr %2, i64 0, i32 2
  %3 = load i8, ptr %marked.i, align 1
  %4 = and i8 %3, 3
  %tobool.not.i = icmp eq i8 %4, 0
  br i1 %tobool.not.i, label %if.end.i, label %if.then.i

if.then.i:                                        ; preds = %sw.bb
  tail call fastcc void @reallymarkobject(ptr noundef nonnull %0, ptr noundef nonnull %2)
  %.pre.i = load ptr, ptr %mainthread.i, align 8
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %sw.bb
  %5 = phi ptr [ %.pre.i, %if.then.i ], [ %2, %sw.bb ]
  %tt.i = getelementptr inbounds %struct.lua_State, ptr %5, i64 0, i32 22, i32 1
  %6 = load i32, ptr %tt.i, align 8
  %cmp.i = icmp sgt i32 %6, 3
  br i1 %cmp.i, label %land.lhs.true.i, label %if.end14.i

land.lhs.true.i:                                  ; preds = %if.end.i
  %l_gt.i = getelementptr inbounds %struct.lua_State, ptr %5, i64 0, i32 22
  %7 = load ptr, ptr %l_gt.i, align 8
  %marked6.i = getelementptr inbounds %struct.GCheader, ptr %7, i64 0, i32 2
  %8 = load i8, ptr %marked6.i, align 1
  %9 = and i8 %8, 3
  %tobool9.not.i = icmp eq i8 %9, 0
  br i1 %tobool9.not.i, label %if.end14.i, label %if.then10.i

if.then10.i:                                      ; preds = %land.lhs.true.i
  tail call fastcc void @reallymarkobject(ptr noundef nonnull %0, ptr noundef nonnull %7)
  br label %if.end14.i

if.end14.i:                                       ; preds = %if.then10.i, %land.lhs.true.i, %if.end.i
  %10 = load ptr, ptr %l_G, align 8
  %tt16.i = getelementptr inbounds %struct.global_State, ptr %10, i64 0, i32 20, i32 1
  %11 = load i32, ptr %tt16.i, align 8
  %cmp17.i = icmp sgt i32 %11, 3
  br i1 %cmp17.i, label %land.lhs.true19.i, label %for.body.i.i.preheader

land.lhs.true19.i:                                ; preds = %if.end14.i
  %l_registry.i = getelementptr inbounds %struct.global_State, ptr %10, i64 0, i32 20
  %12 = load ptr, ptr %l_registry.i, align 8
  %marked23.i = getelementptr inbounds %struct.GCheader, ptr %12, i64 0, i32 2
  %13 = load i8, ptr %marked23.i, align 1
  %14 = and i8 %13, 3
  %tobool26.not.i = icmp eq i8 %14, 0
  br i1 %tobool26.not.i, label %for.body.i.i.preheader, label %if.then27.i

if.then27.i:                                      ; preds = %land.lhs.true19.i
  tail call fastcc void @reallymarkobject(ptr noundef nonnull %0, ptr noundef nonnull %12)
  br label %for.body.i.i.preheader

for.body.i.i.preheader:                           ; preds = %if.then27.i, %land.lhs.true19.i, %if.end14.i
  br label %for.body.i.i

for.body.i.i:                                     ; preds = %for.body.i.i.preheader, %for.inc.i.i
  %indvars.iv.i.i = phi i64 [ %indvars.iv.next.i.i, %for.inc.i.i ], [ 0, %for.body.i.i.preheader ]
  %arrayidx.i.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 23, i64 %indvars.iv.i.i
  %15 = load ptr, ptr %arrayidx.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %15, null
  br i1 %tobool.not.i.i, label %for.inc.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %for.body.i.i
  %marked.i.i = getelementptr inbounds %struct.GCheader, ptr %15, i64 0, i32 2
  %16 = load i8, ptr %marked.i.i, align 1
  %17 = and i8 %16, 3
  %tobool4.not.i.i = icmp eq i8 %17, 0
  br i1 %tobool4.not.i.i, label %for.inc.i.i, label %if.then5.i.i

if.then5.i.i:                                     ; preds = %if.then.i.i
  tail call fastcc void @reallymarkobject(ptr noundef nonnull %0, ptr noundef nonnull %15)
  br label %for.inc.i.i

for.inc.i.i:                                      ; preds = %if.then5.i.i, %if.then.i.i, %for.body.i.i
  %indvars.iv.next.i.i = add nuw nsw i64 %indvars.iv.i.i, 1
  %exitcond.not.i.i = icmp eq i64 %indvars.iv.next.i.i, 9
  br i1 %exitcond.not.i.i, label %markroot.exit, label %for.body.i.i, !llvm.loop !62

markroot.exit:                                    ; preds = %for.inc.i.i
  store i8 1, ptr %gcstate, align 1
  br label %return

sw.bb1:                                           ; preds = %entry
  %gray = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 8
  %18 = load ptr, ptr %gray, align 8
  %tobool.not = icmp eq ptr %18, null
  br i1 %tobool.not, label %if.else, label %if.then

if.then:                                          ; preds = %sw.bb1
  %call = tail call fastcc i64 @propagatemark(ptr noundef nonnull %0)
  br label %return

if.else:                                          ; preds = %sw.bb1
  %uvhead.i.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 22
  %next.i.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 22, i32 4, i32 0, i32 1
  %uv.09.i.i = load ptr, ptr %next.i.i, align 8
  %cmp.not10.i.i = icmp eq ptr %uv.09.i.i, %uvhead.i.i
  br i1 %cmp.not10.i.i, label %propagateall.exit.i, label %for.body.i.i30

for.body.i.i30:                                   ; preds = %if.else, %for.inc.i.i32
  %uv.011.i.i = phi ptr [ %uv.0.i.i, %for.inc.i.i32 ], [ %uv.09.i.i, %if.else ]
  %marked.i.i31 = getelementptr inbounds %struct.GCheader, ptr %uv.011.i.i, i64 0, i32 2
  %19 = load i8, ptr %marked.i.i31, align 1
  %20 = and i8 %19, 7
  %or.cond.i.i = icmp eq i8 %20, 0
  br i1 %or.cond.i.i, label %if.then.i.i46, label %for.inc.i.i32

if.then.i.i46:                                    ; preds = %for.body.i.i30
  %v.i.i = getelementptr inbounds %struct.UpVal, ptr %uv.011.i.i, i64 0, i32 3
  %21 = load ptr, ptr %v.i.i, align 8
  %tt.i.i = getelementptr inbounds %struct.lua_TValue, ptr %21, i64 0, i32 1
  %22 = load i32, ptr %tt.i.i, align 8
  %cmp6.i.i = icmp sgt i32 %22, 3
  br i1 %cmp6.i.i, label %land.lhs.true8.i.i, label %for.inc.i.i32

land.lhs.true8.i.i:                               ; preds = %if.then.i.i46
  %23 = load ptr, ptr %21, align 8
  %marked10.i.i = getelementptr inbounds %struct.GCheader, ptr %23, i64 0, i32 2
  %24 = load i8, ptr %marked10.i.i, align 1
  %25 = and i8 %24, 3
  %tobool13.not.i.i = icmp eq i8 %25, 0
  br i1 %tobool13.not.i.i, label %for.inc.i.i32, label %if.then14.i.i

if.then14.i.i:                                    ; preds = %land.lhs.true8.i.i
  tail call fastcc void @reallymarkobject(ptr noundef %0, ptr noundef nonnull %23)
  br label %for.inc.i.i32

for.inc.i.i32:                                    ; preds = %if.then14.i.i, %land.lhs.true8.i.i, %if.then.i.i46, %for.body.i.i30
  %next19.i.i = getelementptr inbounds %struct.UpVal, ptr %uv.011.i.i, i64 0, i32 4, i32 0, i32 1
  %uv.0.i.i = load ptr, ptr %next19.i.i, align 8
  %cmp.not.i.i = icmp eq ptr %uv.0.i.i, %uvhead.i.i
  br i1 %cmp.not.i.i, label %remarkupvals.exit.i, label %for.body.i.i30, !llvm.loop !63

remarkupvals.exit.i:                              ; preds = %for.inc.i.i32
  %.pre = load ptr, ptr %gray, align 8
  %26 = icmp eq ptr %.pre, null
  br i1 %26, label %propagateall.exit.i, label %while.body.i.i

while.body.i.i:                                   ; preds = %remarkupvals.exit.i, %while.body.i.i
  %call.i.i = tail call fastcc i64 @propagatemark(ptr noundef nonnull %0)
  %27 = load ptr, ptr %gray, align 8
  %tobool.not.i.i33 = icmp eq ptr %27, null
  br i1 %tobool.not.i.i33, label %propagateall.exit.i, label %while.body.i.i, !llvm.loop !64

propagateall.exit.i:                              ; preds = %while.body.i.i, %if.else, %remarkupvals.exit.i
  %weak.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 10
  %28 = load ptr, ptr %weak.i, align 8
  store ptr %28, ptr %gray, align 8
  store ptr null, ptr %weak.i, align 8
  %marked.i35 = getelementptr inbounds %struct.GCheader, ptr %L, i64 0, i32 2
  %29 = load i8, ptr %marked.i35, align 1
  %30 = and i8 %29, 3
  %tobool.not.i36 = icmp eq i8 %30, 0
  br i1 %tobool.not.i36, label %for.body.i27.i.preheader, label %if.then.i37

if.then.i37:                                      ; preds = %propagateall.exit.i
  tail call fastcc void @reallymarkobject(ptr noundef nonnull %0, ptr noundef nonnull %L)
  br label %for.body.i27.i.preheader

for.body.i27.i.preheader:                         ; preds = %if.then.i37, %propagateall.exit.i
  br label %for.body.i27.i

for.body.i27.i:                                   ; preds = %for.body.i27.i.preheader, %for.inc.i31.i
  %indvars.iv.i.i39 = phi i64 [ %indvars.iv.next.i.i43, %for.inc.i31.i ], [ 0, %for.body.i27.i.preheader ]
  %arrayidx.i.i40 = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 23, i64 %indvars.iv.i.i39
  %31 = load ptr, ptr %arrayidx.i.i40, align 8
  %tobool.not.i28.i = icmp eq ptr %31, null
  br i1 %tobool.not.i28.i, label %for.inc.i31.i, label %if.then.i29.i

if.then.i29.i:                                    ; preds = %for.body.i27.i
  %marked.i30.i = getelementptr inbounds %struct.GCheader, ptr %31, i64 0, i32 2
  %32 = load i8, ptr %marked.i30.i, align 1
  %33 = and i8 %32, 3
  %tobool4.not.i.i41 = icmp eq i8 %33, 0
  br i1 %tobool4.not.i.i41, label %for.inc.i31.i, label %if.then5.i.i42

if.then5.i.i42:                                   ; preds = %if.then.i29.i
  tail call fastcc void @reallymarkobject(ptr noundef nonnull %0, ptr noundef nonnull %31)
  br label %for.inc.i31.i

for.inc.i31.i:                                    ; preds = %if.then5.i.i42, %if.then.i29.i, %for.body.i27.i
  %indvars.iv.next.i.i43 = add nuw nsw i64 %indvars.iv.i.i39, 1
  %exitcond.not.i.i44 = icmp eq i64 %indvars.iv.next.i.i43, 9
  br i1 %exitcond.not.i.i44, label %while.cond.i32.i.preheader, label %for.body.i27.i, !llvm.loop !62

while.cond.i32.i.preheader:                       ; preds = %for.inc.i31.i
  %34 = load ptr, ptr %gray, align 8
  %tobool.not.i35.i69 = icmp eq ptr %34, null
  br i1 %tobool.not.i35.i69, label %propagateall.exit39.i, label %while.body.i36.i

while.body.i36.i:                                 ; preds = %while.cond.i32.i.preheader, %while.body.i36.i
  %call.i37.i = tail call fastcc i64 @propagatemark(ptr noundef nonnull %0)
  %35 = load ptr, ptr %gray, align 8
  %tobool.not.i35.i = icmp eq ptr %35, null
  br i1 %tobool.not.i35.i, label %propagateall.exit39.i, label %while.body.i36.i, !llvm.loop !64

propagateall.exit39.i:                            ; preds = %while.body.i36.i, %while.cond.i32.i.preheader
  %grayagain.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 9
  %36 = load ptr, ptr %grayagain.i, align 8
  store ptr %36, ptr %gray, align 8
  store ptr null, ptr %grayagain.i, align 8
  %tobool.not.i43.i70 = icmp eq ptr %36, null
  br i1 %tobool.not.i43.i70, label %propagateall.exit47.i, label %while.body.i44.i

while.body.i44.i:                                 ; preds = %propagateall.exit39.i, %while.body.i44.i
  %call.i45.i = tail call fastcc i64 @propagatemark(ptr noundef nonnull %0)
  %.pr = load ptr, ptr %gray, align 8
  %tobool.not.i43.i = icmp eq ptr %.pr, null
  br i1 %tobool.not.i43.i, label %propagateall.exit47.i, label %while.body.i44.i, !llvm.loop !64

propagateall.exit47.i:                            ; preds = %while.body.i44.i, %propagateall.exit39.i
  %call6.i = tail call fastcc i64 @luaC_separateudata(ptr noundef %L, i32 noundef 0)
  %tmudata.i.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 11
  %37 = load ptr, ptr %tmudata.i.i, align 8
  %tobool.not.i48.i = icmp eq ptr %37, null
  br i1 %tobool.not.i48.i, label %marktmu.exit.i, label %do.body.preheader.i.i

do.body.preheader.i.i:                            ; preds = %propagateall.exit47.i
  %currentwhite.i.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 3
  br label %do.body.i.i

do.body.i.i:                                      ; preds = %do.body.i.i, %do.body.preheader.i.i
  %u.0.i.i = phi ptr [ %38, %do.body.i.i ], [ %37, %do.body.preheader.i.i ]
  %38 = load ptr, ptr %u.0.i.i, align 8
  %marked.i49.i = getelementptr inbounds %struct.GCheader, ptr %38, i64 0, i32 2
  %39 = load i8, ptr %marked.i49.i, align 1
  %40 = and i8 %39, -8
  %41 = load i8, ptr %currentwhite.i.i, align 8
  %42 = and i8 %41, 3
  %or9.i.i = or disjoint i8 %42, %40
  store i8 %or9.i.i, ptr %marked.i49.i, align 1
  tail call fastcc void @reallymarkobject(ptr noundef nonnull %0, ptr noundef %38)
  %43 = load ptr, ptr %tmudata.i.i, align 8
  %cmp.not.i50.i = icmp eq ptr %38, %43
  br i1 %cmp.not.i50.i, label %marktmu.exit.i, label %do.body.i.i, !llvm.loop !65

marktmu.exit.i:                                   ; preds = %do.body.i.i, %propagateall.exit47.i
  %44 = load ptr, ptr %gray, align 8
  %tobool.not.i54.i71 = icmp eq ptr %44, null
  br i1 %tobool.not.i54.i71, label %propagateall.exit58.i, label %while.body.i55.i

while.body.i55.i:                                 ; preds = %marktmu.exit.i, %while.body.i55.i
  %m.0.i52.i72 = phi i64 [ %add.i57.i, %while.body.i55.i ], [ 0, %marktmu.exit.i ]
  %call.i56.i = tail call fastcc i64 @propagatemark(ptr noundef nonnull %0)
  %add.i57.i = add i64 %call.i56.i, %m.0.i52.i72
  %45 = load ptr, ptr %gray, align 8
  %tobool.not.i54.i = icmp eq ptr %45, null
  br i1 %tobool.not.i54.i, label %propagateall.exit58.i, label %while.body.i55.i, !llvm.loop !64

propagateall.exit58.i:                            ; preds = %while.body.i55.i, %marktmu.exit.i
  %m.0.i52.i.lcssa = phi i64 [ 0, %marktmu.exit.i ], [ %add.i57.i, %while.body.i55.i ]
  %46 = load ptr, ptr %weak.i, align 8
  %tobool.not70.i.i = icmp eq ptr %46, null
  br i1 %tobool.not70.i.i, label %atomic.exit, label %while.body.i59.i

while.body.i59.i:                                 ; preds = %propagateall.exit58.i, %while.end27.i.i
  %l.addr.071.i.i = phi ptr [ %77, %while.end27.i.i ], [ %46, %propagateall.exit58.i ]
  %marked.i60.i = getelementptr inbounds %struct.Table, ptr %l.addr.071.i.i, i64 0, i32 2
  %47 = load i8, ptr %marked.i60.i, align 1
  %48 = and i8 %47, 16
  %tobool1.not.i.i = icmp eq i8 %48, 0
  br i1 %tobool1.not.i.i, label %if.end7.i.i, label %while.cond2.preheader.i.i

while.cond2.preheader.i.i:                        ; preds = %while.body.i59.i
  %sizearray.i.i = getelementptr inbounds %struct.Table, ptr %l.addr.071.i.i, i64 0, i32 10
  %49 = load i32, ptr %sizearray.i.i, align 8
  %tobool3.not65.i.i = icmp eq i32 %49, 0
  br i1 %tobool3.not65.i.i, label %if.end7.i.i, label %while.body4.lr.ph.i.i

while.body4.lr.ph.i.i:                            ; preds = %while.cond2.preheader.i.i
  %array.i.i = getelementptr inbounds %struct.Table, ptr %l.addr.071.i.i, i64 0, i32 6
  %50 = sext i32 %49 to i64
  br label %while.body4.i.i

while.body4.i.i:                                  ; preds = %if.end.i.i, %while.body4.lr.ph.i.i
  %indvars.iv.i61.i = phi i64 [ %50, %while.body4.lr.ph.i.i ], [ %indvars.iv.next.i62.i, %if.end.i.i ]
  %indvars.iv.next.i62.i = add nsw i64 %indvars.iv.i61.i, -1
  %51 = load ptr, ptr %array.i.i, align 8
  %tt.i.i.i = getelementptr inbounds %struct.lua_TValue, ptr %51, i64 %indvars.iv.next.i62.i, i32 1
  %52 = load i32, ptr %tt.i.i.i, align 8
  %cmp.i.i.i = icmp sgt i32 %52, 3
  br i1 %cmp.i.i.i, label %if.end.i.i.i, label %if.end.i.i

if.end.i.i.i:                                     ; preds = %while.body4.i.i
  %arrayidx.i64.i = getelementptr inbounds %struct.lua_TValue, ptr %51, i64 %indvars.iv.next.i62.i
  %cmp2.i.i.i = icmp eq i32 %52, 4
  %53 = load ptr, ptr %arrayidx.i64.i, align 8
  br i1 %cmp2.i.i.i, label %if.then3.i.i.i, label %if.end5.i.i.i

if.then3.i.i.i:                                   ; preds = %if.end.i.i.i
  %marked.i.i.i = getelementptr inbounds %struct.anon.0, ptr %53, i64 0, i32 2
  %54 = load i8, ptr %marked.i.i.i, align 1
  %55 = and i8 %54, -4
  store i8 %55, ptr %marked.i.i.i, align 1
  br label %if.end.i.i

if.end5.i.i.i:                                    ; preds = %if.end.i.i.i
  %marked7.i.i.i = getelementptr inbounds %struct.GCheader, ptr %53, i64 0, i32 2
  %56 = load i8, ptr %marked7.i.i.i, align 1
  %conv8.i.i.i = zext i8 %56 to i32
  %and9.i.i.i = and i32 %conv8.i.i.i, 3
  %tobool.not.i.i.i = icmp eq i32 %and9.i.i.i, 0
  br i1 %tobool.not.i.i.i, label %lor.rhs.i.i.i, label %if.then6.i.i

lor.rhs.i.i.i:                                    ; preds = %if.end5.i.i.i
  %cmp11.i.not.i.i = icmp ne i32 %52, 7
  %57 = and i32 %conv8.i.i.i, 8
  %tobool5.not.i.i = icmp eq i32 %57, 0
  %or.cond.i65.i = or i1 %cmp11.i.not.i.i, %tobool5.not.i.i
  br i1 %or.cond.i65.i, label %if.end.i.i, label %if.then6.i.i

if.then6.i.i:                                     ; preds = %lor.rhs.i.i.i, %if.end5.i.i.i
  store i32 0, ptr %tt.i.i.i, align 8
  br label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then6.i.i, %lor.rhs.i.i.i, %if.then3.i.i.i, %while.body4.i.i
  %58 = and i64 %indvars.iv.next.i62.i, 4294967295
  %tobool3.not.i.i = icmp eq i64 %58, 0
  br i1 %tobool3.not.i.i, label %if.end7.i.i, label %while.body4.i.i, !llvm.loop !66

if.end7.i.i:                                      ; preds = %if.end.i.i, %while.cond2.preheader.i.i, %while.body.i59.i
  %lsizenode.i.i = getelementptr inbounds %struct.Table, ptr %l.addr.071.i.i, i64 0, i32 4
  %59 = load i8, ptr %lsizenode.i.i, align 1
  %tobool12.not68.i.i = icmp ugt i8 %59, 31
  br i1 %tobool12.not68.i.i, label %while.end27.i.i, label %while.body13.lr.ph.i.i

while.body13.lr.ph.i.i:                           ; preds = %if.end7.i.i
  %sh_prom.i.i = zext nneg i8 %59 to i64
  %node.i.i = getelementptr inbounds %struct.Table, ptr %l.addr.071.i.i, i64 0, i32 7
  %sext.i.i = shl nuw i64 4294967296, %sh_prom.i.i
  %60 = ashr exact i64 %sext.i.i, 32
  br label %while.body13.i.i

while.body13.i.i:                                 ; preds = %if.end26.i.i, %while.body13.lr.ph.i.i
  %indvars.iv74.i.i = phi i64 [ %60, %while.body13.lr.ph.i.i ], [ %indvars.iv.next75.i.i, %if.end26.i.i ]
  %indvars.iv.next75.i.i = add nsw i64 %indvars.iv74.i.i, -1
  %61 = load ptr, ptr %node.i.i, align 8
  %arrayidx15.i.i = getelementptr inbounds %struct.Node, ptr %61, i64 %indvars.iv.next75.i.i
  %tt16.i.i = getelementptr inbounds %struct.lua_TValue, ptr %arrayidx15.i.i, i64 0, i32 1
  %62 = load i32, ptr %tt16.i.i, align 8
  %cmp.i.i = icmp eq i32 %62, 0
  br i1 %cmp.i.i, label %if.end26.i.i, label %land.lhs.true.i.i

land.lhs.true.i.i:                                ; preds = %while.body13.i.i
  %i_key.i.i = getelementptr inbounds %struct.Node, ptr %61, i64 %indvars.iv.next75.i.i, i32 1
  %tt.i15.i.i = getelementptr inbounds %struct.lua_TValue, ptr %i_key.i.i, i64 0, i32 1
  %63 = load i32, ptr %tt.i15.i.i, align 8
  %cmp.i16.i.i = icmp sgt i32 %63, 3
  br i1 %cmp.i16.i.i, label %if.end.i18.i.i, label %lor.lhs.false.i.i

if.end.i18.i.i:                                   ; preds = %land.lhs.true.i.i
  %cmp2.i19.i.i = icmp eq i32 %63, 4
  %64 = load ptr, ptr %i_key.i.i, align 8
  br i1 %cmp2.i19.i.i, label %if.then3.i27.i.i, label %if.end5.i20.i.i

if.then3.i27.i.i:                                 ; preds = %if.end.i18.i.i
  %marked.i28.i.i = getelementptr inbounds %struct.anon.0, ptr %64, i64 0, i32 2
  %65 = load i8, ptr %marked.i28.i.i, align 1
  %66 = and i8 %65, -4
  store i8 %66, ptr %marked.i28.i.i, align 1
  %.pre.i.i = load i32, ptr %tt16.i.i, align 8
  br label %lor.lhs.false.i.i

if.end5.i20.i.i:                                  ; preds = %if.end.i18.i.i
  %marked7.i21.i.i = getelementptr inbounds %struct.GCheader, ptr %64, i64 0, i32 2
  %67 = load i8, ptr %marked7.i21.i.i, align 1
  %68 = and i8 %67, 3
  %tobool.not.i24.i.i = icmp eq i8 %68, 0
  br i1 %tobool.not.i24.i.i, label %lor.lhs.false.i.i, label %if.then23.i.i

lor.lhs.false.i.i:                                ; preds = %if.end5.i20.i.i, %if.then3.i27.i.i, %land.lhs.true.i.i
  %69 = phi i32 [ %62, %if.end5.i20.i.i ], [ %.pre.i.i, %if.then3.i27.i.i ], [ %62, %land.lhs.true.i.i ]
  %cmp.i31.i.i = icmp sgt i32 %69, 3
  br i1 %cmp.i31.i.i, label %if.end.i33.i.i, label %if.end26.i.i

if.end.i33.i.i:                                   ; preds = %lor.lhs.false.i.i
  %cmp2.i34.i.i = icmp eq i32 %69, 4
  %70 = load ptr, ptr %arrayidx15.i.i, align 8
  br i1 %cmp2.i34.i.i, label %if.then3.i45.i.i, label %if.end5.i35.i.i

if.then3.i45.i.i:                                 ; preds = %if.end.i33.i.i
  %marked.i46.i.i = getelementptr inbounds %struct.anon.0, ptr %70, i64 0, i32 2
  %71 = load i8, ptr %marked.i46.i.i, align 1
  %72 = and i8 %71, -4
  store i8 %72, ptr %marked.i46.i.i, align 1
  br label %if.end26.i.i

if.end5.i35.i.i:                                  ; preds = %if.end.i33.i.i
  %marked7.i36.i.i = getelementptr inbounds %struct.GCheader, ptr %70, i64 0, i32 2
  %73 = load i8, ptr %marked7.i36.i.i, align 1
  %conv8.i37.i.i = zext i8 %73 to i32
  %and9.i38.i.i = and i32 %conv8.i37.i.i, 3
  %tobool.not.i39.i.i = icmp eq i32 %and9.i38.i.i, 0
  br i1 %tobool.not.i39.i.i, label %lor.rhs.i40.i.i, label %if.then23.i.i

lor.rhs.i40.i.i:                                  ; preds = %if.end5.i35.i.i
  %cmp11.i41.not.i.i = icmp ne i32 %69, 7
  %74 = and i32 %conv8.i37.i.i, 8
  %tobool22.not.i.i = icmp eq i32 %74, 0
  %or.cond63.i.i = or i1 %cmp11.i41.not.i.i, %tobool22.not.i.i
  br i1 %or.cond63.i.i, label %if.end26.i.i, label %if.then23.i.i

if.then23.i.i:                                    ; preds = %lor.rhs.i40.i.i, %if.end5.i35.i.i, %if.end5.i20.i.i
  store i32 0, ptr %tt16.i.i, align 8
  %tt.i48.i.i = getelementptr inbounds %struct.Node, ptr %61, i64 %indvars.iv.next75.i.i, i32 1, i32 0, i32 1
  %75 = load i32, ptr %tt.i48.i.i, align 8
  %cmp.i49.i.i = icmp sgt i32 %75, 3
  br i1 %cmp.i49.i.i, label %if.then.i.i.i, label %if.end26.i.i

if.then.i.i.i:                                    ; preds = %if.then23.i.i
  store i32 11, ptr %tt.i48.i.i, align 8
  br label %if.end26.i.i

if.end26.i.i:                                     ; preds = %if.then.i.i.i, %if.then23.i.i, %lor.rhs.i40.i.i, %if.then3.i45.i.i, %lor.lhs.false.i.i, %while.body13.i.i
  %76 = icmp eq i64 %indvars.iv.next75.i.i, 0
  br i1 %76, label %while.end27.i.i, label %while.body13.i.i, !llvm.loop !67

while.end27.i.i:                                  ; preds = %if.end26.i.i, %if.end7.i.i
  %gclist.i.i = getelementptr inbounds %struct.Table, ptr %l.addr.071.i.i, i64 0, i32 9
  %77 = load ptr, ptr %gclist.i.i, align 8
  %tobool.not.i63.i = icmp eq ptr %77, null
  br i1 %tobool.not.i63.i, label %atomic.exit, label %while.body.i59.i, !llvm.loop !68

atomic.exit:                                      ; preds = %while.end27.i.i, %propagateall.exit58.i
  %currentwhite.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 3
  %78 = load i8, ptr %currentwhite.i, align 8
  %79 = xor i8 %78, 3
  store i8 %79, ptr %currentwhite.i, align 8
  %sweepstrgc.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 5
  store i32 0, ptr %sweepstrgc.i, align 4
  %rootgc.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 6
  %sweepgc.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 7
  store ptr %rootgc.i, ptr %sweepgc.i, align 8
  store i8 2, ptr %gcstate, align 1
  %totalbytes.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 14
  %80 = load i64, ptr %totalbytes.i, align 8
  %81 = add i64 %m.0.i52.i.lcssa, %call6.i
  %sub.i = sub i64 %80, %81
  %estimate.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 15
  store i64 %sub.i, ptr %estimate.i, align 8
  br label %return

sw.bb2:                                           ; preds = %entry
  %totalbytes = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 14
  %82 = load i64, ptr %totalbytes, align 8
  %83 = load ptr, ptr %0, align 8
  %sweepstrgc = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 5
  %84 = load i32, ptr %sweepstrgc, align 4
  %inc = add nsw i32 %84, 1
  store i32 %inc, ptr %sweepstrgc, align 4
  %idxprom = sext i32 %84 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %83, i64 %idxprom
  %call3 = tail call fastcc ptr @sweeplist(ptr noundef nonnull %L, ptr noundef %arrayidx, i64 noundef -3)
  %85 = load i32, ptr %sweepstrgc, align 4
  %size = getelementptr inbounds %struct.stringtable, ptr %0, i64 0, i32 2
  %86 = load i32, ptr %size, align 4
  %cmp.not = icmp slt i32 %85, %86
  br i1 %cmp.not, label %if.end, label %if.then7

if.then7:                                         ; preds = %sw.bb2
  store i8 3, ptr %gcstate, align 1
  br label %if.end

if.end:                                           ; preds = %if.then7, %sw.bb2
  %87 = load i64, ptr %totalbytes, align 8
  %sub.neg = sub i64 %87, %82
  %estimate = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 15
  %88 = load i64, ptr %estimate, align 8
  %sub10 = add i64 %sub.neg, %88
  store i64 %sub10, ptr %estimate, align 8
  br label %return

sw.bb11:                                          ; preds = %entry
  %totalbytes13 = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 14
  %89 = load i64, ptr %totalbytes13, align 8
  %sweepgc = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 7
  %90 = load ptr, ptr %sweepgc, align 8
  %call14 = tail call fastcc ptr @sweeplist(ptr noundef nonnull %L, ptr noundef %90, i64 noundef 40)
  store ptr %call14, ptr %sweepgc, align 8
  %91 = load ptr, ptr %call14, align 8
  %cmp17 = icmp eq ptr %91, null
  br i1 %cmp17, label %if.then19, label %if.end21

if.then19:                                        ; preds = %sw.bb11
  %92 = load ptr, ptr %l_G, align 8
  %nuse.i = getelementptr inbounds %struct.stringtable, ptr %92, i64 0, i32 1
  %93 = load i32, ptr %nuse.i, align 8
  %size.i = getelementptr inbounds %struct.stringtable, ptr %92, i64 0, i32 2
  %94 = load i32, ptr %size.i, align 4
  %div.i = sdiv i32 %94, 4
  %cmp.i48 = icmp ult i32 %93, %div.i
  %cmp4.i = icmp sgt i32 %94, 64
  %or.cond.i = and i1 %cmp4.i, %cmp.i48
  br i1 %or.cond.i, label %if.then.i50, label %if.end.i49

if.then.i50:                                      ; preds = %if.then19
  %div716.i = lshr i32 %94, 1
  tail call fastcc void @luaS_resize(ptr noundef nonnull %L, i32 noundef %div716.i)
  br label %if.end.i49

if.end.i49:                                       ; preds = %if.then.i50, %if.then19
  %buff.i = getelementptr inbounds %struct.global_State, ptr %92, i64 0, i32 12
  %buffsize.i = getelementptr inbounds %struct.global_State, ptr %92, i64 0, i32 12, i32 2
  %95 = load i64, ptr %buffsize.i, align 8
  %cmp8.i = icmp ugt i64 %95, 64
  br i1 %cmp8.i, label %if.then9.i, label %checkSizes.exit

if.then9.i:                                       ; preds = %if.end.i49
  %div1217.i = lshr i64 %95, 1
  %96 = load ptr, ptr %buff.i, align 8
  %97 = load ptr, ptr %l_G, align 8
  %frealloc.i = getelementptr inbounds %struct.global_State, ptr %97, i64 0, i32 1
  %98 = load ptr, ptr %frealloc.i, align 8
  %ud.i = getelementptr inbounds %struct.global_State, ptr %97, i64 0, i32 2
  %99 = load ptr, ptr %ud.i, align 8
  %call.i52 = tail call ptr %98(ptr noundef %99, ptr noundef %96, i64 noundef %95, i64 noundef %div1217.i) #35
  %cmp.i53 = icmp eq ptr %call.i52, null
  br i1 %cmp.i53, label %if.then.i59, label %luaM_realloc_.exit

if.then.i59:                                      ; preds = %if.then9.i
  %errorJmp.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 26
  %100 = load ptr, ptr %errorJmp.i.i, align 8
  %tobool.not.i.i60 = icmp eq ptr %100, null
  br i1 %tobool.not.i.i60, label %if.else.i.i, label %if.then.i.i61

if.then.i.i61:                                    ; preds = %if.then.i59
  %status.i.i = getelementptr inbounds %struct.lua_longjmp, ptr %100, i64 0, i32 2
  store volatile i32 4, ptr %status.i.i, align 8
  %101 = load ptr, ptr %errorJmp.i.i, align 8
  %b.i.i = getelementptr inbounds %struct.lua_longjmp, ptr %101, i64 0, i32 1
  tail call void @longjmp(ptr noundef nonnull %b.i.i, i32 noundef 1) #38
  unreachable

if.else.i.i:                                      ; preds = %if.then.i59
  %status3.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 3
  store i8 4, ptr %status3.i.i, align 2
  %102 = load ptr, ptr %l_G, align 8
  %panic.i.i = getelementptr inbounds %struct.global_State, ptr %102, i64 0, i32 19
  %103 = load ptr, ptr %panic.i.i, align 8
  %tobool4.not.i.i62 = icmp eq ptr %103, null
  br i1 %tobool4.not.i.i62, label %if.end.i.i65, label %if.then5.i.i63

if.then5.i.i63:                                   ; preds = %if.else.i.i
  tail call fastcc void @resetstack(ptr noundef nonnull %L, i32 noundef 4)
  %104 = load ptr, ptr %l_G, align 8
  %panic7.i.i = getelementptr inbounds %struct.global_State, ptr %104, i64 0, i32 19
  %105 = load ptr, ptr %panic7.i.i, align 8
  %call.i.i64 = tail call i32 %105(ptr noundef nonnull %L) #35
  br label %if.end.i.i65

if.end.i.i65:                                     ; preds = %if.then5.i.i63, %if.else.i.i
  tail call void @exit(i32 noundef 1) #38
  unreachable

luaM_realloc_.exit:                               ; preds = %if.then9.i
  %totalbytes.i56 = getelementptr inbounds %struct.global_State, ptr %97, i64 0, i32 14
  %106 = load i64, ptr %totalbytes.i56, align 8
  %sub.i57 = sub i64 %div1217.i, %95
  %add.i58 = add i64 %sub.i57, %106
  store i64 %add.i58, ptr %totalbytes.i56, align 8
  store ptr %call.i52, ptr %buff.i, align 8
  store i64 %div1217.i, ptr %buffsize.i, align 8
  br label %checkSizes.exit

checkSizes.exit:                                  ; preds = %if.end.i49, %luaM_realloc_.exit
  store i8 4, ptr %gcstate, align 1
  br label %if.end21

if.end21:                                         ; preds = %checkSizes.exit, %sw.bb11
  %107 = load i64, ptr %totalbytes13, align 8
  %sub23.neg = sub i64 %107, %89
  %estimate24 = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 15
  %108 = load i64, ptr %estimate24, align 8
  %sub25 = add i64 %sub23.neg, %108
  store i64 %sub25, ptr %estimate24, align 8
  br label %return

sw.bb26:                                          ; preds = %entry
  %tmudata = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 11
  %109 = load ptr, ptr %tmudata, align 8
  %tobool27.not = icmp eq ptr %109, null
  br i1 %tobool27.not, label %if.else36, label %if.then28

if.then28:                                        ; preds = %sw.bb26
  tail call fastcc void @GCTM(ptr noundef nonnull %L)
  %estimate29 = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 15
  %110 = load i64, ptr %estimate29, align 8
  %cmp30 = icmp ugt i64 %110, 100
  br i1 %cmp30, label %if.then32, label %return

if.then32:                                        ; preds = %if.then28
  %sub34 = add i64 %110, -100
  store i64 %sub34, ptr %estimate29, align 8
  br label %return

if.else36:                                        ; preds = %sw.bb26
  store i8 0, ptr %gcstate, align 1
  %gcdept = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 16
  store i64 0, ptr %gcdept, align 8
  br label %return

return:                                           ; preds = %entry, %if.then28, %if.then32, %if.else36, %if.end21, %if.end, %atomic.exit, %if.then, %markroot.exit
  %retval.0 = phi i64 [ 0, %if.else36 ], [ 400, %if.end21 ], [ 10, %if.end ], [ %call, %if.then ], [ 0, %atomic.exit ], [ 0, %markroot.exit ], [ 100, %if.then32 ], [ 100, %if.then28 ], [ 0, %entry ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal fastcc i64 @propagatemark(ptr noundef %g) unnamed_addr #0 {
entry:
  %gray = getelementptr inbounds %struct.global_State, ptr %g, i64 0, i32 8
  %0 = load ptr, ptr %gray, align 8
  %marked = getelementptr inbounds %struct.GCheader, ptr %0, i64 0, i32 2
  %1 = load i8, ptr %marked, align 1
  %2 = or i8 %1, 4
  store i8 %2, ptr %marked, align 1
  %tt = getelementptr inbounds %struct.GCheader, ptr %0, i64 0, i32 1
  %3 = load i8, ptr %tt, align 8
  switch i8 %3, label %return [
    i8 5, label %sw.bb
    i8 6, label %sw.bb11
    i8 8, label %sw.bb29
    i8 9, label %sw.bb44
  ]

sw.bb:                                            ; preds = %entry
  %gclist = getelementptr inbounds %struct.Table, ptr %0, i64 0, i32 9
  %4 = load ptr, ptr %gclist, align 8
  store ptr %4, ptr %gray, align 8
  %metatable.i = getelementptr inbounds %struct.Table, ptr %0, i64 0, i32 5
  %5 = load ptr, ptr %metatable.i, align 8
  %tobool.not.i = icmp eq ptr %5, null
  br i1 %tobool.not.i, label %if.then52.i, label %if.then.i

if.then.i:                                        ; preds = %sw.bb
  %marked.i = getelementptr inbounds %struct.GCheader, ptr %5, i64 0, i32 2
  %6 = load i8, ptr %marked.i, align 1
  %7 = and i8 %6, 3
  %tobool2.not.i = icmp eq i8 %7, 0
  br i1 %tobool2.not.i, label %cond.false.i, label %if.end5.i

if.end5.i:                                        ; preds = %if.then.i
  tail call fastcc void @reallymarkobject(ptr noundef nonnull %g, ptr noundef nonnull %5)
  %.pr.pre.i = load ptr, ptr %metatable.i, align 8
  %cmp.i = icmp eq ptr %.pr.pre.i, null
  br i1 %cmp.i, label %if.then52.i, label %cond.false.i

cond.false.i:                                     ; preds = %if.end5.i, %if.then.i
  %.pr86.i = phi ptr [ %.pr.pre.i, %if.end5.i ], [ %5, %if.then.i ]
  %flags.i = getelementptr inbounds %struct.Table, ptr %.pr86.i, i64 0, i32 3
  %8 = load i8, ptr %flags.i, align 2
  %9 = and i8 %8, 8
  %tobool11.not.i = icmp eq i8 %9, 0
  br i1 %tobool11.not.i, label %cond.false13.i, label %if.then52.i

cond.false13.i:                                   ; preds = %cond.false.i
  %arrayidx.i = getelementptr inbounds %struct.global_State, ptr %g, i64 0, i32 24, i64 3
  %10 = load ptr, ptr %arrayidx.i, align 8
  %11 = getelementptr i8, ptr %.pr86.i, i64 11
  %events.val.i.i = load i8, ptr %11, align 1
  %12 = getelementptr i8, ptr %.pr86.i, i64 32
  %events.val3.i.i = load ptr, ptr %12, align 8
  %hash.i.i.i = getelementptr inbounds %struct.anon.0, ptr %10, i64 0, i32 4
  %13 = load i32, ptr %hash.i.i.i, align 4
  %sh_prom.i.i.i = zext nneg i8 %events.val.i.i to i64
  %notmask.i.i.i = shl nsw i64 -1, %sh_prom.i.i.i
  %14 = trunc i64 %notmask.i.i.i to i32
  %15 = xor i32 %14, -1
  %conv2.i.i.i = and i32 %13, %15
  %idxprom.i.i.i = sext i32 %conv2.i.i.i to i64
  %arrayidx.i.i.i = getelementptr inbounds %struct.Node, ptr %events.val3.i.i, i64 %idxprom.i.i.i
  br label %do.body.i.i.i

do.body.i.i.i:                                    ; preds = %if.else.i.i.i, %cond.false13.i
  %n.0.i.i.i = phi ptr [ %arrayidx.i.i.i, %cond.false13.i ], [ %18, %if.else.i.i.i ]
  %tt.i.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i.i, i64 0, i32 1, i32 0, i32 1
  %16 = load i32, ptr %tt.i.i.i, align 8
  %cmp.i.i.i = icmp eq i32 %16, 4
  br i1 %cmp.i.i.i, label %land.lhs.true.i.i.i, label %if.else.i.i.i

land.lhs.true.i.i.i:                              ; preds = %do.body.i.i.i
  %i_key.i.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i.i, i64 0, i32 1
  %17 = load ptr, ptr %i_key.i.i.i, align 8
  %cmp5.i.i.i = icmp eq ptr %17, %10
  br i1 %cmp5.i.i.i, label %luaH_getstr.exit.i.i, label %if.else.i.i.i

if.else.i.i.i:                                    ; preds = %land.lhs.true.i.i.i, %do.body.i.i.i
  %next.i.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i.i, i64 0, i32 1, i32 0, i32 2
  %18 = load ptr, ptr %next.i.i.i, align 8
  %tobool.not.i.i.i = icmp eq ptr %18, null
  br i1 %tobool.not.i.i.i, label %luaH_getstr.exit.i.i, label %do.body.i.i.i, !llvm.loop !29

luaH_getstr.exit.i.i:                             ; preds = %if.else.i.i.i, %land.lhs.true.i.i.i
  %retval.0.i.i.i = phi ptr [ %n.0.i.i.i, %land.lhs.true.i.i.i ], [ @luaO_nilobject_, %if.else.i.i.i ]
  %tt.i.i = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i.i.i, i64 0, i32 1
  %19 = load i32, ptr %tt.i.i, align 8
  switch i32 %19, label %if.then52.i [
    i32 0, label %if.then.i.i
    i32 4, label %if.then20.i
  ]

if.then.i.i:                                      ; preds = %luaH_getstr.exit.i.i
  %conv3.i.i = or disjoint i8 %8, 8
  store i8 %conv3.i.i, ptr %flags.i, align 2
  br label %if.then52.i

if.then20.i:                                      ; preds = %luaH_getstr.exit.i.i
  %20 = load ptr, ptr %retval.0.i.i.i, align 8
  %add.ptr.i = getelementptr inbounds %union.TString, ptr %20, i64 1
  %call21.i = tail call ptr @strchr(ptr noundef nonnull dereferenceable(1) %add.ptr.i, i32 noundef 107) #34
  %cmp22.i = icmp ne ptr %call21.i, null
  %call26.i = tail call ptr @strchr(ptr noundef nonnull dereferenceable(1) %add.ptr.i, i32 noundef 118) #34
  %cmp27.i = icmp ne ptr %call26.i, null
  %or.cond.i = select i1 %cmp22.i, i1 true, i1 %cmp27.i
  br i1 %or.cond.i, label %if.end45.i, label %if.then52.i

if.end45.i:                                       ; preds = %if.then20.i
  %21 = load i8, ptr %marked, align 1
  %22 = and i8 %21, -25
  %shl.i = select i1 %cmp22.i, i8 8, i8 0
  %shl36.i = select i1 %cmp27.i, i8 16, i8 0
  %or.i = or disjoint i8 %shl36.i, %shl.i
  %or41.i = or disjoint i8 %or.i, %22
  store i8 %or41.i, ptr %marked, align 1
  %weak.i = getelementptr inbounds %struct.global_State, ptr %g, i64 0, i32 10
  %23 = load ptr, ptr %weak.i, align 8
  store ptr %23, ptr %gclist, align 8
  store ptr %0, ptr %weak.i, align 8
  %or.cond1.i = select i1 %cmp22.i, i1 %cmp27.i, i1 false
  br i1 %or.cond1.i, label %if.then, label %if.end50.i

if.end50.i:                                       ; preds = %if.end45.i
  br i1 %cmp27.i, label %if.end73.i, label %if.then52.i

if.then52.i:                                      ; preds = %if.end50.i, %if.then20.i, %if.then.i.i, %luaH_getstr.exit.i.i, %cond.false.i, %if.end5.i, %sw.bb
  %weakkey.0.shrunk5763.i = phi i1 [ %cmp22.i, %if.end50.i ], [ false, %sw.bb ], [ false, %if.then.i.i ], [ false, %cond.false.i ], [ false, %if.end5.i ], [ false, %if.then20.i ], [ false, %luaH_getstr.exit.i.i ]
  %sizearray.i = getelementptr inbounds %struct.Table, ptr %0, i64 0, i32 10
  %24 = load i32, ptr %sizearray.i, align 8
  %tobool53.not66.i = icmp eq i32 %24, 0
  br i1 %tobool53.not66.i, label %if.end73.i, label %while.body.lr.ph.i

while.body.lr.ph.i:                               ; preds = %if.then52.i
  %array.i = getelementptr inbounds %struct.Table, ptr %0, i64 0, i32 6
  %25 = sext i32 %24 to i64
  br label %while.body.i

while.body.i:                                     ; preds = %if.end72.i, %while.body.lr.ph.i
  %indvars.iv.i = phi i64 [ %25, %while.body.lr.ph.i ], [ %indvars.iv.next.i, %if.end72.i ]
  %indvars.iv.next.i = add nsw i64 %indvars.iv.i, -1
  %26 = load ptr, ptr %array.i, align 8
  %tt55.i = getelementptr inbounds %struct.lua_TValue, ptr %26, i64 %indvars.iv.next.i, i32 1
  %27 = load i32, ptr %tt55.i, align 8
  %cmp56.i = icmp sgt i32 %27, 3
  br i1 %cmp56.i, label %land.lhs.true58.i, label %if.end72.i

land.lhs.true58.i:                                ; preds = %while.body.i
  %arrayidx54.i = getelementptr inbounds %struct.lua_TValue, ptr %26, i64 %indvars.iv.next.i
  %28 = load ptr, ptr %arrayidx54.i, align 8
  %marked63.i = getelementptr inbounds %struct.GCheader, ptr %28, i64 0, i32 2
  %29 = load i8, ptr %marked63.i, align 1
  %30 = and i8 %29, 3
  %tobool66.not.i = icmp eq i8 %30, 0
  br i1 %tobool66.not.i, label %if.end72.i, label %if.then67.i

if.then67.i:                                      ; preds = %land.lhs.true58.i
  tail call fastcc void @reallymarkobject(ptr noundef %g, ptr noundef nonnull %28)
  br label %if.end72.i

if.end72.i:                                       ; preds = %if.then67.i, %land.lhs.true58.i, %while.body.i
  %31 = and i64 %indvars.iv.next.i, 4294967295
  %tobool53.not.i = icmp eq i64 %31, 0
  br i1 %tobool53.not.i, label %if.end73.i, label %while.body.i, !llvm.loop !69

if.end73.i:                                       ; preds = %if.end72.i, %if.then52.i, %if.end50.i
  %weakkey.0.shrunk5764.i = phi i1 [ %cmp22.i, %if.end50.i ], [ %weakkey.0.shrunk5763.i, %if.then52.i ], [ %weakkey.0.shrunk5763.i, %if.end72.i ]
  %weakvalue.0.shrunk5862.i = phi i1 [ true, %if.end50.i ], [ false, %if.then52.i ], [ false, %if.end72.i ]
  %weakkey.0.shrunk5764.fr.i = freeze i1 %weakkey.0.shrunk5764.i
  %lsizenode.i = getelementptr inbounds %struct.Table, ptr %0, i64 0, i32 4
  %32 = load i8, ptr %lsizenode.i, align 1
  %tobool79.not69.i = icmp ugt i8 %32, 31
  br i1 %tobool79.not69.i, label %traversetable.exit, label %while.body80.lr.ph.i

while.body80.lr.ph.i:                             ; preds = %if.end73.i
  %sh_prom.i = zext nneg i8 %32 to i64
  %notmask.i = shl nsw i64 -1, %sh_prom.i
  %dec7868.i = xor i64 %notmask.i, -1
  %node.i = getelementptr inbounds %struct.Table, ptr %0, i64 0, i32 7
  br i1 %weakkey.0.shrunk5764.fr.i, label %while.body80.lr.ph.split.us.i, label %while.body80.i

while.body80.lr.ph.split.us.i:                    ; preds = %while.body80.lr.ph.i
  br i1 %weakvalue.0.shrunk5862.i, label %while.body80.us.us.i, label %while.body80.us.i

while.body80.us.us.i:                             ; preds = %while.body80.lr.ph.split.us.i, %if.end122.us.us.i
  %indvars.iv80.i = phi i64 [ %indvars.iv.next81.i, %if.end122.us.us.i ], [ %dec7868.i, %while.body80.lr.ph.split.us.i ]
  %33 = load ptr, ptr %node.i, align 8
  %tt83.us.us.i = getelementptr inbounds %struct.Node, ptr %33, i64 %indvars.iv80.i, i32 0, i32 1
  %34 = load i32, ptr %tt83.us.us.i, align 8
  %cmp84.us.us.i = icmp eq i32 %34, 0
  br i1 %cmp84.us.us.i, label %if.then86.us.us.i, label %if.end122.us.us.i

if.then86.us.us.i:                                ; preds = %while.body80.us.us.i
  %tt.i48.us.us.i = getelementptr inbounds %struct.Node, ptr %33, i64 %indvars.iv80.i, i32 1, i32 0, i32 1
  %35 = load i32, ptr %tt.i48.us.us.i, align 8
  %cmp.i49.us.us.i = icmp sgt i32 %35, 3
  br i1 %cmp.i49.us.us.i, label %if.then.i50.us.us.i, label %if.end122.us.us.i

if.then.i50.us.us.i:                              ; preds = %if.then86.us.us.i
  store i32 11, ptr %tt.i48.us.us.i, align 8
  br label %if.end122.us.us.i

if.end122.us.us.i:                                ; preds = %if.then.i50.us.us.i, %if.then86.us.us.i, %while.body80.us.us.i
  %indvars.iv.next81.i = add nsw i64 %indvars.iv80.i, -1
  %36 = icmp eq i64 %indvars.iv80.i, 0
  br i1 %36, label %traversetable.exit, label %while.body80.us.us.i, !llvm.loop !70

while.body80.us.i:                                ; preds = %while.body80.lr.ph.split.us.i, %if.end122.us.i
  %indvars.iv77.i = phi i64 [ %indvars.iv.next78.i, %if.end122.us.i ], [ %dec7868.i, %while.body80.lr.ph.split.us.i ]
  %37 = load ptr, ptr %node.i, align 8
  %arrayidx82.us.i = getelementptr inbounds %struct.Node, ptr %37, i64 %indvars.iv77.i
  %tt83.us.i = getelementptr inbounds %struct.lua_TValue, ptr %arrayidx82.us.i, i64 0, i32 1
  %38 = load i32, ptr %tt83.us.i, align 8
  %cmp84.us.i = icmp eq i32 %38, 0
  br i1 %cmp84.us.i, label %if.then86.us.i, label %if.else.us.i

if.else.us.i:                                     ; preds = %while.body80.us.i
  %cmp108.us.i = icmp sgt i32 %38, 3
  br i1 %cmp108.us.i, label %land.lhs.true110.us.i, label %if.end122.us.i

land.lhs.true110.us.i:                            ; preds = %if.else.us.i
  %39 = load ptr, ptr %arrayidx82.us.i, align 8
  %marked113.us.i = getelementptr inbounds %struct.GCheader, ptr %39, i64 0, i32 2
  %40 = load i8, ptr %marked113.us.i, align 1
  %41 = and i8 %40, 3
  %tobool116.not.us.i = icmp eq i8 %41, 0
  br i1 %tobool116.not.us.i, label %if.end122.us.i, label %if.then117.us.i

if.then117.us.i:                                  ; preds = %land.lhs.true110.us.i
  tail call fastcc void @reallymarkobject(ptr noundef %g, ptr noundef nonnull %39)
  br label %if.end122.us.i

if.then86.us.i:                                   ; preds = %while.body80.us.i
  %tt.i48.us.i = getelementptr inbounds %struct.Node, ptr %37, i64 %indvars.iv77.i, i32 1, i32 0, i32 1
  %42 = load i32, ptr %tt.i48.us.i, align 8
  %cmp.i49.us.i = icmp sgt i32 %42, 3
  br i1 %cmp.i49.us.i, label %if.then.i50.us.i, label %if.end122.us.i

if.then.i50.us.i:                                 ; preds = %if.then86.us.i
  store i32 11, ptr %tt.i48.us.i, align 8
  br label %if.end122.us.i

if.end122.us.i:                                   ; preds = %if.then.i50.us.i, %if.then86.us.i, %if.then117.us.i, %land.lhs.true110.us.i, %if.else.us.i
  %indvars.iv.next78.i = add nsw i64 %indvars.iv77.i, -1
  %43 = icmp eq i64 %indvars.iv77.i, 0
  br i1 %43, label %traversetable.exit, label %while.body80.us.i, !llvm.loop !70

while.body80.i:                                   ; preds = %while.body80.lr.ph.i, %if.end122.i
  %indvars.iv74.i = phi i64 [ %indvars.iv.next75.i, %if.end122.i ], [ %dec7868.i, %while.body80.lr.ph.i ]
  %44 = load ptr, ptr %node.i, align 8
  %arrayidx82.i = getelementptr inbounds %struct.Node, ptr %44, i64 %indvars.iv74.i
  %tt83.i = getelementptr inbounds %struct.lua_TValue, ptr %arrayidx82.i, i64 0, i32 1
  %45 = load i32, ptr %tt83.i, align 8
  %cmp84.i = icmp eq i32 %45, 0
  br i1 %cmp84.i, label %if.then86.i, label %if.else.i

if.then86.i:                                      ; preds = %while.body80.i
  %tt.i48.i = getelementptr inbounds %struct.Node, ptr %44, i64 %indvars.iv74.i, i32 1, i32 0, i32 1
  %46 = load i32, ptr %tt.i48.i, align 8
  %cmp.i49.i = icmp sgt i32 %46, 3
  br i1 %cmp.i49.i, label %if.then.i50.i, label %if.end122.i

if.then.i50.i:                                    ; preds = %if.then86.i
  store i32 11, ptr %tt.i48.i, align 8
  br label %if.end122.i

if.else.i:                                        ; preds = %while.body80.i
  %i_key.i = getelementptr inbounds %struct.Node, ptr %44, i64 %indvars.iv74.i, i32 1
  %tt89.i = getelementptr inbounds %struct.anon.2, ptr %i_key.i, i64 0, i32 1
  %47 = load i32, ptr %tt89.i, align 8
  %cmp90.i = icmp sgt i32 %47, 3
  br i1 %cmp90.i, label %land.lhs.true92.i, label %if.end103.i

land.lhs.true92.i:                                ; preds = %if.else.i
  %48 = load ptr, ptr %i_key.i, align 8
  %marked95.i = getelementptr inbounds %struct.GCheader, ptr %48, i64 0, i32 2
  %49 = load i8, ptr %marked95.i, align 1
  %50 = and i8 %49, 3
  %tobool98.not.i = icmp eq i8 %50, 0
  br i1 %tobool98.not.i, label %if.end103.i, label %if.then99.i

if.then99.i:                                      ; preds = %land.lhs.true92.i
  tail call fastcc void @reallymarkobject(ptr noundef %g, ptr noundef nonnull %48)
  br label %if.end103.i

if.end103.i:                                      ; preds = %if.then99.i, %land.lhs.true92.i, %if.else.i
  br i1 %weakvalue.0.shrunk5862.i, label %if.end122.i, label %if.then105.i

if.then105.i:                                     ; preds = %if.end103.i
  %51 = load i32, ptr %tt83.i, align 8
  %cmp108.i = icmp sgt i32 %51, 3
  br i1 %cmp108.i, label %land.lhs.true110.i, label %if.end122.i

land.lhs.true110.i:                               ; preds = %if.then105.i
  %52 = load ptr, ptr %arrayidx82.i, align 8
  %marked113.i = getelementptr inbounds %struct.GCheader, ptr %52, i64 0, i32 2
  %53 = load i8, ptr %marked113.i, align 1
  %54 = and i8 %53, 3
  %tobool116.not.i = icmp eq i8 %54, 0
  br i1 %tobool116.not.i, label %if.end122.i, label %if.then117.i

if.then117.i:                                     ; preds = %land.lhs.true110.i
  tail call fastcc void @reallymarkobject(ptr noundef %g, ptr noundef nonnull %52)
  br label %if.end122.i

if.end122.i:                                      ; preds = %if.then117.i, %land.lhs.true110.i, %if.then105.i, %if.end103.i, %if.then.i50.i, %if.then86.i
  %indvars.iv.next75.i = add nsw i64 %indvars.iv74.i, -1
  %55 = icmp eq i64 %indvars.iv74.i, 0
  br i1 %55, label %traversetable.exit, label %while.body80.i, !llvm.loop !70

traversetable.exit:                               ; preds = %if.end122.i, %if.end122.us.i, %if.end122.us.us.i, %if.end73.i
  %56 = or i1 %weakkey.0.shrunk5764.fr.i, %weakvalue.0.shrunk5862.i
  br i1 %56, label %if.then, label %if.end

if.then:                                          ; preds = %if.end45.i, %traversetable.exit
  %57 = load i8, ptr %marked, align 1
  %58 = and i8 %57, -5
  store i8 %58, ptr %marked, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %traversetable.exit
  %sizearray = getelementptr inbounds %struct.Table, ptr %0, i64 0, i32 10
  %59 = load i32, ptr %sizearray, align 8
  %conv7 = sext i32 %59 to i64
  %mul = shl nsw i64 %conv7, 4
  %add = add nsw i64 %mul, 64
  %lsizenode = getelementptr inbounds %struct.Table, ptr %0, i64 0, i32 4
  %60 = load i8, ptr %lsizenode, align 1
  %sh_prom = zext nneg i8 %60 to i64
  %mul937 = shl i64 40, %sh_prom
  %add10 = add i64 %add, %mul937
  br label %return

sw.bb11:                                          ; preds = %entry
  %gclist12 = getelementptr inbounds %struct.CClosure, ptr %0, i64 0, i32 5
  %61 = load ptr, ptr %gclist12, align 8
  store ptr %61, ptr %gray, align 8
  %env.i = getelementptr inbounds %struct.CClosure, ptr %0, i64 0, i32 6
  %62 = load ptr, ptr %env.i, align 8
  %marked.i38 = getelementptr inbounds %struct.GCheader, ptr %62, i64 0, i32 2
  %63 = load i8, ptr %marked.i38, align 1
  %64 = and i8 %63, 3
  %tobool.not.i39 = icmp eq i8 %64, 0
  br i1 %tobool.not.i39, label %if.end.i, label %if.then.i40

if.then.i40:                                      ; preds = %sw.bb11
  tail call fastcc void @reallymarkobject(ptr noundef nonnull %g, ptr noundef nonnull %62)
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i40, %sw.bb11
  %isC.i = getelementptr inbounds %struct.CClosure, ptr %0, i64 0, i32 3
  %65 = load i8, ptr %isC.i, align 2
  %tobool2.not.i41 = icmp eq i8 %65, 0
  br i1 %tobool2.not.i41, label %if.else.i46, label %for.cond.preheader.i

for.cond.preheader.i:                             ; preds = %if.end.i
  %nupvalues.i = getelementptr inbounds %struct.CClosure, ptr %0, i64 0, i32 4
  %66 = load i8, ptr %nupvalues.i, align 1
  %cmp24.not.i = icmp eq i8 %66, 0
  br i1 %cmp24.not.i, label %traverseclosure.exit, label %for.body.i

for.body.i:                                       ; preds = %for.cond.preheader.i, %for.inc.i
  %67 = phi i8 [ %72, %for.inc.i ], [ %66, %for.cond.preheader.i ]
  %indvars.iv.i42 = phi i64 [ %indvars.iv.next.i43, %for.inc.i ], [ 0, %for.cond.preheader.i ]
  %tt.i = getelementptr inbounds %struct.CClosure, ptr %0, i64 0, i32 8, i64 %indvars.iv.i42, i32 1
  %68 = load i32, ptr %tt.i, align 8
  %cmp6.i = icmp sgt i32 %68, 3
  br i1 %cmp6.i, label %land.lhs.true.i, label %for.inc.i

land.lhs.true.i:                                  ; preds = %for.body.i
  %arrayidx.i45 = getelementptr inbounds %struct.CClosure, ptr %0, i64 0, i32 8, i64 %indvars.iv.i42
  %69 = load ptr, ptr %arrayidx.i45, align 8
  %marked11.i = getelementptr inbounds %struct.GCheader, ptr %69, i64 0, i32 2
  %70 = load i8, ptr %marked11.i, align 1
  %71 = and i8 %70, 3
  %tobool14.not.i = icmp eq i8 %71, 0
  br i1 %tobool14.not.i, label %for.inc.i, label %if.then15.i

if.then15.i:                                      ; preds = %land.lhs.true.i
  tail call fastcc void @reallymarkobject(ptr noundef %g, ptr noundef nonnull %69)
  %.pre.i = load i8, ptr %nupvalues.i, align 1
  br label %for.inc.i

for.inc.i:                                        ; preds = %if.then15.i, %land.lhs.true.i, %for.body.i
  %72 = phi i8 [ %67, %for.body.i ], [ %67, %land.lhs.true.i ], [ %.pre.i, %if.then15.i ]
  %indvars.iv.next.i43 = add nuw nsw i64 %indvars.iv.i42, 1
  %73 = zext i8 %72 to i64
  %cmp.i44 = icmp ult i64 %indvars.iv.next.i43, %73
  br i1 %cmp.i44, label %for.body.i, label %traverseclosure.exit, !llvm.loop !71

if.else.i46:                                      ; preds = %if.end.i
  %p.i = getelementptr inbounds %struct.LClosure, ptr %0, i64 0, i32 7
  %74 = load ptr, ptr %p.i, align 8
  %marked22.i = getelementptr inbounds %struct.GCheader, ptr %74, i64 0, i32 2
  %75 = load i8, ptr %marked22.i, align 1
  %76 = and i8 %75, 3
  %tobool25.not.i = icmp eq i8 %76, 0
  br i1 %tobool25.not.i, label %if.end28.i, label %if.then26.i

if.then26.i:                                      ; preds = %if.else.i46
  tail call fastcc void @reallymarkobject(ptr noundef nonnull %g, ptr noundef nonnull %74)
  br label %if.end28.i

if.end28.i:                                       ; preds = %if.then26.i, %if.else.i46
  %nupvalues30.i = getelementptr inbounds %struct.LClosure, ptr %0, i64 0, i32 4
  %77 = load i8, ptr %nupvalues30.i, align 1
  %cmp3227.not.i = icmp eq i8 %77, 0
  br i1 %cmp3227.not.i, label %traverseclosure.exit, label %for.body34.i

for.body34.i:                                     ; preds = %if.end28.i, %for.inc46.i
  %78 = phi i8 [ %82, %for.inc46.i ], [ %77, %if.end28.i ]
  %indvars.iv31.i = phi i64 [ %indvars.iv.next32.i, %for.inc46.i ], [ 0, %if.end28.i ]
  %arrayidx36.i = getelementptr inbounds %struct.LClosure, ptr %0, i64 0, i32 8, i64 %indvars.iv31.i
  %79 = load ptr, ptr %arrayidx36.i, align 8
  %marked37.i = getelementptr inbounds %struct.GCheader, ptr %79, i64 0, i32 2
  %80 = load i8, ptr %marked37.i, align 1
  %81 = and i8 %80, 3
  %tobool40.not.i = icmp eq i8 %81, 0
  br i1 %tobool40.not.i, label %for.inc46.i, label %if.then41.i

if.then41.i:                                      ; preds = %for.body34.i
  tail call fastcc void @reallymarkobject(ptr noundef %g, ptr noundef nonnull %79)
  %.pre34.i = load i8, ptr %nupvalues30.i, align 1
  br label %for.inc46.i

for.inc46.i:                                      ; preds = %if.then41.i, %for.body34.i
  %82 = phi i8 [ %78, %for.body34.i ], [ %.pre34.i, %if.then41.i ]
  %indvars.iv.next32.i = add nuw nsw i64 %indvars.iv31.i, 1
  %83 = zext i8 %82 to i64
  %cmp32.i = icmp ult i64 %indvars.iv.next32.i, %83
  br i1 %cmp32.i, label %for.body34.i, label %traverseclosure.exit, !llvm.loop !72

traverseclosure.exit:                             ; preds = %for.inc.i, %for.inc46.i, %for.cond.preheader.i, %if.end28.i
  %84 = phi i8 [ 0, %for.cond.preheader.i ], [ 0, %if.end28.i ], [ %82, %for.inc46.i ], [ %72, %for.inc.i ]
  %85 = load i8, ptr %isC.i, align 2
  %tobool15.not = icmp eq i8 %85, 0
  %conv22 = zext i8 %84 to i64
  %. = select i1 %tobool15.not, i64 3, i64 4
  %sub23 = shl nuw nsw i64 %conv22, %.
  %cond = add nuw nsw i64 %sub23, 40
  %conv28 = and i64 %cond, 65528
  br label %return

sw.bb29:                                          ; preds = %entry
  %gclist30 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 25
  %86 = load ptr, ptr %gclist30, align 8
  store ptr %86, ptr %gray, align 8
  %grayagain = getelementptr inbounds %struct.global_State, ptr %g, i64 0, i32 9
  %87 = load ptr, ptr %grayagain, align 8
  store ptr %87, ptr %gclist30, align 8
  store ptr %0, ptr %grayagain, align 8
  %88 = load i8, ptr %marked, align 1
  %89 = and i8 %88, -5
  store i8 %89, ptr %marked, align 1
  %tt.i47 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 22, i32 1
  %90 = load i32, ptr %tt.i47, align 8
  %cmp.i48 = icmp sgt i32 %90, 3
  br i1 %cmp.i48, label %land.lhs.true.i51, label %if.end.i49

land.lhs.true.i51:                                ; preds = %sw.bb29
  %l_gt.i = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 22
  %91 = load ptr, ptr %l_gt.i, align 8
  %marked.i52 = getelementptr inbounds %struct.GCheader, ptr %91, i64 0, i32 2
  %92 = load i8, ptr %marked.i52, align 1
  %93 = and i8 %92, 3
  %tobool.not.i53 = icmp eq i8 %93, 0
  br i1 %tobool.not.i53, label %if.end.i49, label %if.then.i54

if.then.i54:                                      ; preds = %land.lhs.true.i51
  tail call fastcc void @reallymarkobject(ptr noundef nonnull %g, ptr noundef nonnull %91)
  br label %if.end.i49

if.end.i49:                                       ; preds = %if.then.i54, %land.lhs.true.i51, %sw.bb29
  %top.i = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %94 = load ptr, ptr %top.i, align 8
  %base_ci.i = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 12
  %95 = load ptr, ptr %base_ci.i, align 8
  %ci4.i = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 7
  %96 = load ptr, ptr %ci4.i, align 8
  %cmp5.not.i80 = icmp ugt ptr %95, %96
  br i1 %cmp5.not.i80, label %for.end.i, label %for.body.i50

for.body.i50:                                     ; preds = %if.end.i49, %for.body.i50
  %ci.0.i82 = phi ptr [ %incdec.ptr.i, %for.body.i50 ], [ %95, %if.end.i49 ]
  %lim.0.i81 = phi ptr [ %spec.select.i, %for.body.i50 ], [ %94, %if.end.i49 ]
  %top7.i = getelementptr inbounds %struct.CallInfo, ptr %ci.0.i82, i64 0, i32 2
  %97 = load ptr, ptr %top7.i, align 8
  %cmp8.i = icmp ult ptr %lim.0.i81, %97
  %spec.select.i = select i1 %cmp8.i, ptr %97, ptr %lim.0.i81
  %incdec.ptr.i = getelementptr inbounds %struct.CallInfo, ptr %ci.0.i82, i64 1
  %cmp5.not.i = icmp ugt ptr %incdec.ptr.i, %96
  br i1 %cmp5.not.i, label %for.end.i, label %for.body.i50, !llvm.loop !73

for.end.i:                                        ; preds = %for.body.i50, %if.end.i49
  %lim.0.i.lcssa = phi ptr [ %94, %if.end.i49 ], [ %spec.select.i, %for.body.i50 ]
  %stack.i = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 10
  %98 = load ptr, ptr %stack.i, align 8
  %cmp15.i83 = icmp ult ptr %98, %94
  br i1 %cmp15.i83, label %for.body17.i, label %for.cond33.i.preheader

for.cond33.i.preheader:                           ; preds = %for.inc30.i, %for.end.i
  %o.0.i.lcssa = phi ptr [ %98, %for.end.i ], [ %incdec.ptr31.i, %for.inc30.i ]
  %cmp34.not.i86 = icmp ugt ptr %o.0.i.lcssa, %lim.0.i.lcssa
  br i1 %cmp34.not.i86, label %for.end40.i, label %for.body36.i

for.body17.i:                                     ; preds = %for.end.i, %for.inc30.i
  %99 = phi ptr [ %104, %for.inc30.i ], [ %94, %for.end.i ]
  %o.0.i84 = phi ptr [ %incdec.ptr31.i, %for.inc30.i ], [ %98, %for.end.i ]
  %tt18.i = getelementptr inbounds %struct.lua_TValue, ptr %o.0.i84, i64 0, i32 1
  %100 = load i32, ptr %tt18.i, align 8
  %cmp19.i = icmp sgt i32 %100, 3
  br i1 %cmp19.i, label %land.lhs.true21.i, label %for.inc30.i

land.lhs.true21.i:                                ; preds = %for.body17.i
  %101 = load ptr, ptr %o.0.i84, align 8
  %marked23.i = getelementptr inbounds %struct.GCheader, ptr %101, i64 0, i32 2
  %102 = load i8, ptr %marked23.i, align 1
  %103 = and i8 %102, 3
  %tobool26.not.i = icmp eq i8 %103, 0
  br i1 %tobool26.not.i, label %for.inc30.i, label %if.then27.i

if.then27.i:                                      ; preds = %land.lhs.true21.i
  tail call fastcc void @reallymarkobject(ptr noundef %g, ptr noundef nonnull %101)
  %.pre91 = load ptr, ptr %top.i, align 8
  br label %for.inc30.i

for.inc30.i:                                      ; preds = %if.then27.i, %land.lhs.true21.i, %for.body17.i
  %104 = phi ptr [ %.pre91, %if.then27.i ], [ %99, %land.lhs.true21.i ], [ %99, %for.body17.i ]
  %incdec.ptr31.i = getelementptr inbounds %struct.lua_TValue, ptr %o.0.i84, i64 1
  %cmp15.i = icmp ult ptr %incdec.ptr31.i, %104
  br i1 %cmp15.i, label %for.body17.i, label %for.cond33.i.preheader, !llvm.loop !74

for.body36.i:                                     ; preds = %for.cond33.i.preheader, %for.body36.i
  %o.1.i87 = phi ptr [ %incdec.ptr39.i, %for.body36.i ], [ %o.0.i.lcssa, %for.cond33.i.preheader ]
  %tt37.i = getelementptr inbounds %struct.lua_TValue, ptr %o.1.i87, i64 0, i32 1
  store i32 0, ptr %tt37.i, align 8
  %incdec.ptr39.i = getelementptr inbounds %struct.lua_TValue, ptr %o.1.i87, i64 1
  %cmp34.not.i = icmp ugt ptr %incdec.ptr39.i, %lim.0.i.lcssa
  br i1 %cmp34.not.i, label %for.end40.i, label %for.body36.i, !llvm.loop !75

for.end40.i:                                      ; preds = %for.body36.i, %for.cond33.i.preheader
  %105 = load ptr, ptr %stack.i, align 8
  %sub.ptr.lhs.cast1.i.i = ptrtoint ptr %lim.0.i.lcssa to i64
  %sub.ptr.rhs.cast2.i.i = ptrtoint ptr %105 to i64
  %sub.ptr.sub3.i.i = sub i64 %sub.ptr.lhs.cast1.i.i, %sub.ptr.rhs.cast2.i.i
  %size_ci.i.i = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 14
  %106 = load i32, ptr %size_ci.i.i, align 4
  %cmp.i.i = icmp sgt i32 %106, 20000
  br i1 %cmp.i.i, label %traversestack.exit, label %if.end.i.i

if.end.i.i:                                       ; preds = %for.end40.i
  %107 = load ptr, ptr %ci4.i, align 8
  %sub.ptr.lhs.cast.i.i = ptrtoint ptr %107 to i64
  %108 = load ptr, ptr %base_ci.i, align 8
  %sub.ptr.rhs.cast.i.i = ptrtoint ptr %108 to i64
  %sub.ptr.sub.i.i = sub i64 %sub.ptr.lhs.cast.i.i, %sub.ptr.rhs.cast.i.i
  %sub.ptr.div.i.i = sdiv exact i64 %sub.ptr.sub.i.i, 40
  %conv.i.i = trunc i64 %sub.ptr.div.i.i to i32
  %mul.i.i = shl nsw i32 %conv.i.i, 2
  %cmp8.i.i = icmp slt i32 %mul.i.i, %106
  %cmp11.i.i = icmp sgt i32 %106, 16
  %or.cond.i.i = and i1 %cmp11.i.i, %cmp8.i.i
  br i1 %or.cond.i.i, label %if.then13.i.i, label %if.end15.i.i

if.then13.i.i:                                    ; preds = %if.end.i.i
  %div13.i.i = lshr i32 %106, 1
  tail call fastcc void @luaD_reallocCI(ptr noundef nonnull %0, i32 noundef %div13.i.i)
  br label %if.end15.i.i

if.end15.i.i:                                     ; preds = %if.then13.i.i, %if.end.i.i
  %sh.diff.i.i = lshr i64 %sub.ptr.sub3.i.i, 2
  %tr.sh.diff.i.i = trunc i64 %sh.diff.i.i to i32
  %mul16.i.i = and i32 %tr.sh.diff.i.i, -4
  %stacksize.i.i = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 13
  %109 = load i32, ptr %stacksize.i.i, align 8
  %cmp17.i.i = icmp slt i32 %mul16.i.i, %109
  %cmp21.i.i = icmp sgt i32 %109, 90
  %or.cond15.i.i = and i1 %cmp17.i.i, %cmp21.i.i
  br i1 %or.cond15.i.i, label %if.then23.i.i, label %traversestack.exit

if.then23.i.i:                                    ; preds = %if.end15.i.i
  %div2514.i.i = lshr i32 %109, 1
  tail call fastcc void @luaD_reallocstack(ptr noundef nonnull %0, i32 noundef %div2514.i.i)
  br label %traversestack.exit

traversestack.exit:                               ; preds = %for.end40.i, %if.end15.i.i, %if.then23.i.i
  %stacksize = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 13
  %110 = load i32, ptr %stacksize, align 8
  %conv38 = sext i32 %110 to i64
  %mul39 = shl nsw i64 %conv38, 4
  %add40 = add nsw i64 %mul39, 184
  %111 = load i32, ptr %size_ci.i.i, align 4
  %conv41 = sext i32 %111 to i64
  %mul42 = mul nsw i64 %conv41, 40
  %add43 = add nsw i64 %add40, %mul42
  br label %return

sw.bb44:                                          ; preds = %entry
  %gclist45 = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 18
  %112 = load ptr, ptr %gclist45, align 8
  store ptr %112, ptr %gray, align 8
  %source.i = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 9
  %113 = load ptr, ptr %source.i, align 8
  %tobool.not.i55 = icmp eq ptr %113, null
  br i1 %tobool.not.i55, label %if.end.i58, label %if.then.i56

if.then.i56:                                      ; preds = %sw.bb44
  %marked.i57 = getelementptr inbounds %struct.anon.0, ptr %113, i64 0, i32 2
  %114 = load i8, ptr %marked.i57, align 1
  %115 = and i8 %114, -4
  store i8 %115, ptr %marked.i57, align 1
  br label %if.end.i58

if.end.i58:                                       ; preds = %if.then.i56, %sw.bb44
  %sizek.i = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 11
  %116 = load i32, ptr %sizek.i, align 4
  %cmp37.i = icmp sgt i32 %116, 0
  br i1 %cmp37.i, label %for.body.lr.ph.i, label %for.cond19.preheader.i

for.body.lr.ph.i:                                 ; preds = %if.end.i58
  %k.i = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 3
  br label %for.body.i62

for.cond19.preheader.i:                           ; preds = %for.inc.i65, %if.end.i58
  %sizeupvalues.i = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 10
  %117 = load i32, ptr %sizeupvalues.i, align 8
  %cmp2039.i = icmp sgt i32 %117, 0
  br i1 %cmp2039.i, label %for.body22.lr.ph.i, label %for.cond38.preheader.i

for.body22.lr.ph.i:                               ; preds = %for.cond19.preheader.i
  %upvalues.i = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 8
  br label %for.body22.i

for.body.i62:                                     ; preds = %for.inc.i65, %for.body.lr.ph.i
  %118 = phi i32 [ %116, %for.body.lr.ph.i ], [ %124, %for.inc.i65 ]
  %indvars.iv.i63 = phi i64 [ 0, %for.body.lr.ph.i ], [ %indvars.iv.next.i66, %for.inc.i65 ]
  %119 = load ptr, ptr %k.i, align 8
  %tt.i64 = getelementptr inbounds %struct.lua_TValue, ptr %119, i64 %indvars.iv.i63, i32 1
  %120 = load i32, ptr %tt.i64, align 8
  %cmp4.i = icmp sgt i32 %120, 3
  br i1 %cmp4.i, label %land.lhs.true.i68, label %for.inc.i65

land.lhs.true.i68:                                ; preds = %for.body.i62
  %arrayidx.i69 = getelementptr inbounds %struct.lua_TValue, ptr %119, i64 %indvars.iv.i63
  %121 = load ptr, ptr %arrayidx.i69, align 8
  %marked9.i = getelementptr inbounds %struct.GCheader, ptr %121, i64 0, i32 2
  %122 = load i8, ptr %marked9.i, align 1
  %123 = and i8 %122, 3
  %tobool12.not.i = icmp eq i8 %123, 0
  br i1 %tobool12.not.i, label %for.inc.i65, label %if.then13.i

if.then13.i:                                      ; preds = %land.lhs.true.i68
  tail call fastcc void @reallymarkobject(ptr noundef %g, ptr noundef nonnull %121)
  %.pre.i70 = load i32, ptr %sizek.i, align 4
  br label %for.inc.i65

for.inc.i65:                                      ; preds = %if.then13.i, %land.lhs.true.i68, %for.body.i62
  %124 = phi i32 [ %118, %for.body.i62 ], [ %118, %land.lhs.true.i68 ], [ %.pre.i70, %if.then13.i ]
  %indvars.iv.next.i66 = add nuw nsw i64 %indvars.iv.i63, 1
  %125 = sext i32 %124 to i64
  %cmp.i67 = icmp slt i64 %indvars.iv.next.i66, %125
  br i1 %cmp.i67, label %for.body.i62, label %for.cond19.preheader.i, !llvm.loop !76

for.cond38.preheader.i:                           ; preds = %for.inc35.i, %for.cond19.preheader.i
  %sizep.i = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 14
  %126 = load i32, ptr %sizep.i, align 8
  %cmp3941.i = icmp sgt i32 %126, 0
  br i1 %cmp3941.i, label %for.body41.lr.ph.i, label %for.cond62.preheader.i

for.body41.lr.ph.i:                               ; preds = %for.cond38.preheader.i
  %p.i59 = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 5
  br label %for.body41.i

for.body22.i:                                     ; preds = %for.inc35.i, %for.body22.lr.ph.i
  %127 = phi i32 [ %117, %for.body22.lr.ph.i ], [ %132, %for.inc35.i ]
  %indvars.iv46.i = phi i64 [ 0, %for.body22.lr.ph.i ], [ %indvars.iv.next47.i, %for.inc35.i ]
  %128 = load ptr, ptr %upvalues.i, align 8
  %arrayidx24.i = getelementptr inbounds ptr, ptr %128, i64 %indvars.iv46.i
  %129 = load ptr, ptr %arrayidx24.i, align 8
  %tobool25.not.i60 = icmp eq ptr %129, null
  br i1 %tobool25.not.i60, label %for.inc35.i, label %if.then26.i61

if.then26.i61:                                    ; preds = %for.body22.i
  %marked30.i = getelementptr inbounds %struct.anon.0, ptr %129, i64 0, i32 2
  %130 = load i8, ptr %marked30.i, align 1
  %131 = and i8 %130, -4
  store i8 %131, ptr %marked30.i, align 1
  %.pre55.i = load i32, ptr %sizeupvalues.i, align 8
  br label %for.inc35.i

for.inc35.i:                                      ; preds = %if.then26.i61, %for.body22.i
  %132 = phi i32 [ %127, %for.body22.i ], [ %.pre55.i, %if.then26.i61 ]
  %indvars.iv.next47.i = add nuw nsw i64 %indvars.iv46.i, 1
  %133 = sext i32 %132 to i64
  %cmp20.i = icmp slt i64 %indvars.iv.next47.i, %133
  br i1 %cmp20.i, label %for.body22.i, label %for.cond38.preheader.i, !llvm.loop !77

for.cond62.preheader.i:                           ; preds = %for.inc59.i, %for.cond38.preheader.i
  %134 = phi i32 [ %126, %for.cond38.preheader.i ], [ %141, %for.inc59.i ]
  %sizelocvars.i = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 15
  %135 = load i32, ptr %sizelocvars.i, align 4
  %cmp6343.i = icmp sgt i32 %135, 0
  br i1 %cmp6343.i, label %for.body65.lr.ph.i, label %for.cond62.preheader.i.traverseproto.exit_crit_edge

for.cond62.preheader.i.traverseproto.exit_crit_edge: ; preds = %for.cond62.preheader.i
  %.pre92 = sext i32 %135 to i64
  br label %traverseproto.exit

for.body65.lr.ph.i:                               ; preds = %for.cond62.preheader.i
  %locvars.i = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 7
  br label %for.body65.i

for.body41.i:                                     ; preds = %for.inc59.i, %for.body41.lr.ph.i
  %136 = phi i32 [ %126, %for.body41.lr.ph.i ], [ %141, %for.inc59.i ]
  %indvars.iv49.i = phi i64 [ 0, %for.body41.lr.ph.i ], [ %indvars.iv.next50.i, %for.inc59.i ]
  %137 = load ptr, ptr %p.i59, align 8
  %arrayidx43.i = getelementptr inbounds ptr, ptr %137, i64 %indvars.iv49.i
  %138 = load ptr, ptr %arrayidx43.i, align 8
  %tobool44.not.i = icmp eq ptr %138, null
  br i1 %tobool44.not.i, label %for.inc59.i, label %if.then45.i

if.then45.i:                                      ; preds = %for.body41.i
  %marked49.i = getelementptr inbounds %struct.GCheader, ptr %138, i64 0, i32 2
  %139 = load i8, ptr %marked49.i, align 1
  %140 = and i8 %139, 3
  %tobool52.not.i = icmp eq i8 %140, 0
  br i1 %tobool52.not.i, label %for.inc59.i, label %if.then53.i

if.then53.i:                                      ; preds = %if.then45.i
  tail call fastcc void @reallymarkobject(ptr noundef %g, ptr noundef nonnull %138)
  %.pre56.i = load i32, ptr %sizep.i, align 8
  br label %for.inc59.i

for.inc59.i:                                      ; preds = %if.then53.i, %if.then45.i, %for.body41.i
  %141 = phi i32 [ %136, %for.body41.i ], [ %.pre56.i, %if.then53.i ], [ %136, %if.then45.i ]
  %indvars.iv.next50.i = add nuw nsw i64 %indvars.iv49.i, 1
  %142 = sext i32 %141 to i64
  %cmp39.i = icmp slt i64 %indvars.iv.next50.i, %142
  br i1 %cmp39.i, label %for.body41.i, label %for.cond62.preheader.i, !llvm.loop !78

for.body65.i:                                     ; preds = %for.inc79.i, %for.body65.lr.ph.i
  %143 = phi i32 [ %135, %for.body65.lr.ph.i ], [ %148, %for.inc79.i ]
  %indvars.iv52.i = phi i64 [ 0, %for.body65.lr.ph.i ], [ %indvars.iv.next53.i, %for.inc79.i ]
  %144 = load ptr, ptr %locvars.i, align 8
  %arrayidx67.i = getelementptr inbounds %struct.LocVar, ptr %144, i64 %indvars.iv52.i
  %145 = load ptr, ptr %arrayidx67.i, align 8
  %tobool68.not.i = icmp eq ptr %145, null
  br i1 %tobool68.not.i, label %for.inc79.i, label %if.then69.i

if.then69.i:                                      ; preds = %for.body65.i
  %marked74.i = getelementptr inbounds %struct.anon.0, ptr %145, i64 0, i32 2
  %146 = load i8, ptr %marked74.i, align 1
  %147 = and i8 %146, -4
  store i8 %147, ptr %marked74.i, align 1
  %.pre57.i = load i32, ptr %sizelocvars.i, align 4
  br label %for.inc79.i

for.inc79.i:                                      ; preds = %if.then69.i, %for.body65.i
  %148 = phi i32 [ %143, %for.body65.i ], [ %.pre57.i, %if.then69.i ]
  %indvars.iv.next53.i = add nuw nsw i64 %indvars.iv52.i, 1
  %149 = sext i32 %148 to i64
  %cmp63.i = icmp slt i64 %indvars.iv.next53.i, %149
  br i1 %cmp63.i, label %for.body65.i, label %traverseproto.exit.loopexit, !llvm.loop !79

traverseproto.exit.loopexit:                      ; preds = %for.inc79.i
  %.pre = load i32, ptr %sizep.i, align 8
  br label %traverseproto.exit

traverseproto.exit:                               ; preds = %for.cond62.preheader.i.traverseproto.exit_crit_edge, %traverseproto.exit.loopexit
  %conv59.pre-phi = phi i64 [ %.pre92, %for.cond62.preheader.i.traverseproto.exit_crit_edge ], [ %149, %traverseproto.exit.loopexit ]
  %150 = phi i32 [ %134, %for.cond62.preheader.i.traverseproto.exit_crit_edge ], [ %.pre, %traverseproto.exit.loopexit ]
  %sizecode = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 12
  %151 = load i32, ptr %sizecode, align 8
  %conv47 = sext i32 %151 to i64
  %conv50 = sext i32 %150 to i64
  %152 = load i32, ptr %sizek.i, align 4
  %conv53 = sext i32 %152 to i64
  %sizelineinfo = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 13
  %153 = load i32, ptr %sizelineinfo, align 4
  %conv56 = sext i32 %153 to i64
  %154 = load i32, ptr %sizeupvalues.i, align 8
  %conv62 = sext i32 %154 to i64
  %reass.add = add nsw i64 %conv59.pre-phi, %conv53
  %reass.mul = shl nsw i64 %reass.add, 4
  %reass.add73 = add nsw i64 %conv62, %conv50
  %reass.mul74 = shl nsw i64 %reass.add73, 3
  %reass.add75 = add nsw i64 %conv56, %conv47
  %reass.mul76 = shl nsw i64 %reass.add75, 2
  %add58 = add nsw i64 %reass.mul76, 120
  %add61 = add nsw i64 %add58, %reass.mul
  %add64 = add nsw i64 %add61, %reass.mul74
  br label %return

return:                                           ; preds = %entry, %traverseproto.exit, %traversestack.exit, %traverseclosure.exit, %if.end
  %retval.0 = phi i64 [ %add64, %traverseproto.exit ], [ %add43, %traversestack.exit ], [ %conv28, %traverseclosure.exit ], [ %add10, %if.end ], [ 0, %entry ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal fastcc ptr @sweeplist(ptr nocapture noundef readonly %L, ptr noundef %p, i64 noundef %count) unnamed_addr #0 {
entry:
  %l_G = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %0 = load ptr, ptr %l_G, align 8
  %currentwhite = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 3
  %1 = load i8, ptr %currentwhite, align 8
  %2 = xor i8 %1, 3
  %3 = load ptr, ptr %p, align 8
  %cmp.not18 = icmp eq ptr %3, null
  br i1 %cmp.not18, label %while.end, label %land.rhs.lr.ph

land.rhs.lr.ph:                                   ; preds = %entry
  %rootgc = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 6
  br label %land.rhs

land.rhs:                                         ; preds = %land.rhs.lr.ph, %if.end27
  %4 = phi ptr [ %3, %land.rhs.lr.ph ], [ %111, %if.end27 ]
  %p.addr.020 = phi ptr [ %p, %land.rhs.lr.ph ], [ %p.addr.1, %if.end27 ]
  %count.addr.019 = phi i64 [ %count, %land.rhs.lr.ph ], [ %dec, %if.end27 ]
  %dec = add i64 %count.addr.019, -1
  %cmp2.not = icmp eq i64 %count.addr.019, 0
  br i1 %cmp2.not, label %while.end, label %while.body

while.body:                                       ; preds = %land.rhs
  %tt = getelementptr inbounds %struct.GCheader, ptr %4, i64 0, i32 1
  %5 = load i8, ptr %tt, align 8
  %cmp5 = icmp eq i8 %5, 8
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %openupval = getelementptr inbounds %struct.lua_State, ptr %4, i64 0, i32 24
  %call = tail call fastcc ptr @sweeplist(ptr noundef %L, ptr noundef nonnull %openupval, i64 noundef -3)
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  %marked = getelementptr inbounds %struct.GCheader, ptr %4, i64 0, i32 2
  %6 = load i8, ptr %marked, align 1
  %7 = xor i8 %6, 3
  %and17 = and i8 %7, %2
  %tobool.not = icmp eq i8 %and17, 0
  br i1 %tobool.not, label %if.else, label %if.then9

if.then9:                                         ; preds = %if.end
  %and12 = and i8 %6, -8
  %8 = load i8, ptr %currentwhite, align 8
  %9 = and i8 %8, 3
  %or = or disjoint i8 %9, %and12
  store i8 %or, ptr %marked, align 1
  br label %if.end27

if.else:                                          ; preds = %if.end
  %10 = load ptr, ptr %4, align 8
  store ptr %10, ptr %p.addr.020, align 8
  %11 = load ptr, ptr %rootgc, align 8
  %cmp21 = icmp eq ptr %4, %11
  br i1 %cmp21, label %if.then23, label %if.end26

if.then23:                                        ; preds = %if.else
  store ptr %10, ptr %rootgc, align 8
  br label %if.end26

if.end26:                                         ; preds = %if.then23, %if.else
  %12 = load i8, ptr %tt, align 8
  switch i8 %12, label %if.end27 [
    i8 9, label %sw.bb.i
    i8 6, label %sw.bb1.i
    i8 10, label %sw.bb2.i
    i8 5, label %sw.bb3.i
    i8 8, label %sw.bb4.i
    i8 4, label %sw.bb5.i
    i8 7, label %sw.bb7.i
  ]

sw.bb.i:                                          ; preds = %if.end26
  %code.i.i = getelementptr inbounds %struct.Proto, ptr %4, i64 0, i32 4
  %13 = load ptr, ptr %code.i.i, align 8
  %sizecode.i.i = getelementptr inbounds %struct.Proto, ptr %4, i64 0, i32 12
  %14 = load i32, ptr %sizecode.i.i, align 8
  %conv.i.i = sext i32 %14 to i64
  %mul.i.i = shl nsw i64 %conv.i.i, 2
  %15 = load ptr, ptr %l_G, align 8
  %frealloc.i.i.i = getelementptr inbounds %struct.global_State, ptr %15, i64 0, i32 1
  %16 = load ptr, ptr %frealloc.i.i.i, align 8
  %ud.i.i.i = getelementptr inbounds %struct.global_State, ptr %15, i64 0, i32 2
  %17 = load ptr, ptr %ud.i.i.i, align 8
  %call.i.i.i = tail call ptr %16(ptr noundef %17, ptr noundef %13, i64 noundef %mul.i.i, i64 noundef 0) #35
  %totalbytes.i.i.i = getelementptr inbounds %struct.global_State, ptr %15, i64 0, i32 14
  %18 = load i64, ptr %totalbytes.i.i.i, align 8
  %sub.i.i.i = sub i64 %18, %mul.i.i
  store i64 %sub.i.i.i, ptr %totalbytes.i.i.i, align 8
  %p.i.i = getelementptr inbounds %struct.Proto, ptr %4, i64 0, i32 5
  %19 = load ptr, ptr %p.i.i, align 8
  %sizep.i.i = getelementptr inbounds %struct.Proto, ptr %4, i64 0, i32 14
  %20 = load i32, ptr %sizep.i.i, align 8
  %conv1.i.i = sext i32 %20 to i64
  %mul2.i.i = shl nsw i64 %conv1.i.i, 3
  %21 = load ptr, ptr %l_G, align 8
  %frealloc.i20.i.i = getelementptr inbounds %struct.global_State, ptr %21, i64 0, i32 1
  %22 = load ptr, ptr %frealloc.i20.i.i, align 8
  %ud.i21.i.i = getelementptr inbounds %struct.global_State, ptr %21, i64 0, i32 2
  %23 = load ptr, ptr %ud.i21.i.i, align 8
  %call.i22.i.i = tail call ptr %22(ptr noundef %23, ptr noundef %19, i64 noundef %mul2.i.i, i64 noundef 0) #35
  %totalbytes.i24.i.i = getelementptr inbounds %struct.global_State, ptr %21, i64 0, i32 14
  %24 = load i64, ptr %totalbytes.i24.i.i, align 8
  %sub.i25.i.i = sub i64 %24, %mul2.i.i
  store i64 %sub.i25.i.i, ptr %totalbytes.i24.i.i, align 8
  %k.i.i = getelementptr inbounds %struct.Proto, ptr %4, i64 0, i32 3
  %25 = load ptr, ptr %k.i.i, align 8
  %sizek.i.i = getelementptr inbounds %struct.Proto, ptr %4, i64 0, i32 11
  %26 = load i32, ptr %sizek.i.i, align 4
  %conv4.i.i = sext i32 %26 to i64
  %mul5.i.i = shl nsw i64 %conv4.i.i, 4
  %27 = load ptr, ptr %l_G, align 8
  %frealloc.i27.i.i = getelementptr inbounds %struct.global_State, ptr %27, i64 0, i32 1
  %28 = load ptr, ptr %frealloc.i27.i.i, align 8
  %ud.i28.i.i = getelementptr inbounds %struct.global_State, ptr %27, i64 0, i32 2
  %29 = load ptr, ptr %ud.i28.i.i, align 8
  %call.i29.i.i = tail call ptr %28(ptr noundef %29, ptr noundef %25, i64 noundef %mul5.i.i, i64 noundef 0) #35
  %totalbytes.i31.i.i = getelementptr inbounds %struct.global_State, ptr %27, i64 0, i32 14
  %30 = load i64, ptr %totalbytes.i31.i.i, align 8
  %sub.i32.i.i = sub i64 %30, %mul5.i.i
  store i64 %sub.i32.i.i, ptr %totalbytes.i31.i.i, align 8
  %lineinfo.i.i = getelementptr inbounds %struct.Proto, ptr %4, i64 0, i32 6
  %31 = load ptr, ptr %lineinfo.i.i, align 8
  %sizelineinfo.i.i = getelementptr inbounds %struct.Proto, ptr %4, i64 0, i32 13
  %32 = load i32, ptr %sizelineinfo.i.i, align 4
  %conv7.i.i = sext i32 %32 to i64
  %mul8.i.i = shl nsw i64 %conv7.i.i, 2
  %33 = load ptr, ptr %l_G, align 8
  %frealloc.i34.i.i = getelementptr inbounds %struct.global_State, ptr %33, i64 0, i32 1
  %34 = load ptr, ptr %frealloc.i34.i.i, align 8
  %ud.i35.i.i = getelementptr inbounds %struct.global_State, ptr %33, i64 0, i32 2
  %35 = load ptr, ptr %ud.i35.i.i, align 8
  %call.i36.i.i = tail call ptr %34(ptr noundef %35, ptr noundef %31, i64 noundef %mul8.i.i, i64 noundef 0) #35
  %totalbytes.i38.i.i = getelementptr inbounds %struct.global_State, ptr %33, i64 0, i32 14
  %36 = load i64, ptr %totalbytes.i38.i.i, align 8
  %sub.i39.i.i = sub i64 %36, %mul8.i.i
  store i64 %sub.i39.i.i, ptr %totalbytes.i38.i.i, align 8
  %locvars.i.i = getelementptr inbounds %struct.Proto, ptr %4, i64 0, i32 7
  %37 = load ptr, ptr %locvars.i.i, align 8
  %sizelocvars.i.i = getelementptr inbounds %struct.Proto, ptr %4, i64 0, i32 15
  %38 = load i32, ptr %sizelocvars.i.i, align 4
  %conv10.i.i = sext i32 %38 to i64
  %mul11.i.i = shl nsw i64 %conv10.i.i, 4
  %39 = load ptr, ptr %l_G, align 8
  %frealloc.i41.i.i = getelementptr inbounds %struct.global_State, ptr %39, i64 0, i32 1
  %40 = load ptr, ptr %frealloc.i41.i.i, align 8
  %ud.i42.i.i = getelementptr inbounds %struct.global_State, ptr %39, i64 0, i32 2
  %41 = load ptr, ptr %ud.i42.i.i, align 8
  %call.i43.i.i = tail call ptr %40(ptr noundef %41, ptr noundef %37, i64 noundef %mul11.i.i, i64 noundef 0) #35
  %totalbytes.i45.i.i = getelementptr inbounds %struct.global_State, ptr %39, i64 0, i32 14
  %42 = load i64, ptr %totalbytes.i45.i.i, align 8
  %sub.i46.i.i = sub i64 %42, %mul11.i.i
  store i64 %sub.i46.i.i, ptr %totalbytes.i45.i.i, align 8
  %upvalues.i.i = getelementptr inbounds %struct.Proto, ptr %4, i64 0, i32 8
  %43 = load ptr, ptr %upvalues.i.i, align 8
  %sizeupvalues.i.i = getelementptr inbounds %struct.Proto, ptr %4, i64 0, i32 10
  %44 = load i32, ptr %sizeupvalues.i.i, align 8
  %conv13.i.i = sext i32 %44 to i64
  %mul14.i.i = shl nsw i64 %conv13.i.i, 3
  %45 = load ptr, ptr %l_G, align 8
  %frealloc.i48.i.i = getelementptr inbounds %struct.global_State, ptr %45, i64 0, i32 1
  %46 = load ptr, ptr %frealloc.i48.i.i, align 8
  %ud.i49.i.i = getelementptr inbounds %struct.global_State, ptr %45, i64 0, i32 2
  %47 = load ptr, ptr %ud.i49.i.i, align 8
  %call.i50.i.i = tail call ptr %46(ptr noundef %47, ptr noundef %43, i64 noundef %mul14.i.i, i64 noundef 0) #35
  %totalbytes.i52.i.i = getelementptr inbounds %struct.global_State, ptr %45, i64 0, i32 14
  %48 = load i64, ptr %totalbytes.i52.i.i, align 8
  %sub.i53.i.i = sub i64 %48, %mul14.i.i
  store i64 %sub.i53.i.i, ptr %totalbytes.i52.i.i, align 8
  %49 = load ptr, ptr %l_G, align 8
  %frealloc.i55.i.i = getelementptr inbounds %struct.global_State, ptr %49, i64 0, i32 1
  %50 = load ptr, ptr %frealloc.i55.i.i, align 8
  %ud.i56.i.i = getelementptr inbounds %struct.global_State, ptr %49, i64 0, i32 2
  %51 = load ptr, ptr %ud.i56.i.i, align 8
  %call.i57.i.i = tail call ptr %50(ptr noundef %51, ptr noundef nonnull %4, i64 noundef 120, i64 noundef 0) #35
  %totalbytes.i59.i.i = getelementptr inbounds %struct.global_State, ptr %49, i64 0, i32 14
  %52 = load i64, ptr %totalbytes.i59.i.i, align 8
  %sub.i60.i.i = add i64 %52, -120
  store i64 %sub.i60.i.i, ptr %totalbytes.i59.i.i, align 8
  br label %if.end27

sw.bb1.i:                                         ; preds = %if.end26
  %L.val.i = load ptr, ptr %l_G, align 8
  %isC.i.i = getelementptr inbounds %struct.CClosure, ptr %4, i64 0, i32 3
  %53 = load i8, ptr %isC.i.i, align 2
  %tobool.not.i.i = icmp eq i8 %53, 0
  %nupvalues4.i.i = getelementptr inbounds %struct.LClosure, ptr %4, i64 0, i32 4
  %.sink.i.i = select i1 %tobool.not.i.i, i64 3, i64 4
  %54 = load i8, ptr %nupvalues4.i.i, align 1
  %conv5.i.i = zext i8 %54 to i64
  %sub6.i.i = shl nuw nsw i64 %conv5.i.i, %.sink.i.i
  %cond.i.i = add nuw nsw i64 %sub6.i.i, 40
  %conv11.i.i = and i64 %cond.i.i, 65528
  %frealloc.i.i17.i = getelementptr inbounds %struct.global_State, ptr %L.val.i, i64 0, i32 1
  %55 = load ptr, ptr %frealloc.i.i17.i, align 8
  %ud.i.i18.i = getelementptr inbounds %struct.global_State, ptr %L.val.i, i64 0, i32 2
  %56 = load ptr, ptr %ud.i.i18.i, align 8
  %call.i.i19.i = tail call ptr %55(ptr noundef %56, ptr noundef nonnull %4, i64 noundef %conv11.i.i, i64 noundef 0) #35
  %totalbytes.i.i20.i = getelementptr inbounds %struct.global_State, ptr %L.val.i, i64 0, i32 14
  %57 = load i64, ptr %totalbytes.i.i20.i, align 8
  %sub.i.i21.i = sub i64 %57, %conv11.i.i
  store i64 %sub.i.i21.i, ptr %totalbytes.i.i20.i, align 8
  br label %if.end27

sw.bb2.i:                                         ; preds = %if.end26
  %v.i.i = getelementptr inbounds %struct.UpVal, ptr %4, i64 0, i32 3
  %58 = load ptr, ptr %v.i.i, align 8
  %u.i.i = getelementptr inbounds %struct.UpVal, ptr %4, i64 0, i32 4
  %cmp.not.i.i = icmp eq ptr %58, %u.i.i
  br i1 %cmp.not.i.i, label %luaF_freeupval.exit.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %sw.bb2.i
  %59 = load ptr, ptr %u.i.i, align 8
  %next.i.i.i = getelementptr inbounds %struct.UpVal, ptr %4, i64 0, i32 4, i32 0, i32 1
  %60 = load ptr, ptr %next.i.i.i, align 8
  %u2.i.i.i = getelementptr inbounds %struct.UpVal, ptr %60, i64 0, i32 4
  store ptr %59, ptr %u2.i.i.i, align 8
  %61 = load ptr, ptr %next.i.i.i, align 8
  %next9.i.i.i = getelementptr inbounds %struct.UpVal, ptr %59, i64 0, i32 4, i32 0, i32 1
  store ptr %61, ptr %next9.i.i.i, align 8
  br label %luaF_freeupval.exit.i

luaF_freeupval.exit.i:                            ; preds = %if.then.i.i, %sw.bb2.i
  %62 = load ptr, ptr %l_G, align 8
  %frealloc.i.i23.i = getelementptr inbounds %struct.global_State, ptr %62, i64 0, i32 1
  %63 = load ptr, ptr %frealloc.i.i23.i, align 8
  %ud.i.i24.i = getelementptr inbounds %struct.global_State, ptr %62, i64 0, i32 2
  %64 = load ptr, ptr %ud.i.i24.i, align 8
  %call.i.i25.i = tail call ptr %63(ptr noundef %64, ptr noundef nonnull %4, i64 noundef 40, i64 noundef 0) #35
  %totalbytes.i.i26.i = getelementptr inbounds %struct.global_State, ptr %62, i64 0, i32 14
  %65 = load i64, ptr %totalbytes.i.i26.i, align 8
  %sub.i.i27.i = add i64 %65, -40
  store i64 %sub.i.i27.i, ptr %totalbytes.i.i26.i, align 8
  br label %if.end27

sw.bb3.i:                                         ; preds = %if.end26
  %node.i.i = getelementptr inbounds %struct.Table, ptr %4, i64 0, i32 7
  %66 = load ptr, ptr %node.i.i, align 8
  %cmp.not.i28.i = icmp eq ptr %66, @dummynode_
  br i1 %cmp.not.i28.i, label %luaH_free.exit.i, label %if.then.i29.i

if.then.i29.i:                                    ; preds = %sw.bb3.i
  %lsizenode.i.i = getelementptr inbounds %struct.Table, ptr %4, i64 0, i32 4
  %67 = load i8, ptr %lsizenode.i.i, align 1
  %sh_prom.i.i = zext nneg i8 %67 to i64
  %mul8.i30.i = shl i64 40, %sh_prom.i.i
  %68 = load ptr, ptr %l_G, align 8
  %frealloc.i.i32.i = getelementptr inbounds %struct.global_State, ptr %68, i64 0, i32 1
  %69 = load ptr, ptr %frealloc.i.i32.i, align 8
  %ud.i.i33.i = getelementptr inbounds %struct.global_State, ptr %68, i64 0, i32 2
  %70 = load ptr, ptr %ud.i.i33.i, align 8
  %call.i.i34.i = tail call ptr %69(ptr noundef %70, ptr noundef %66, i64 noundef %mul8.i30.i, i64 noundef 0) #35
  %totalbytes.i.i35.i = getelementptr inbounds %struct.global_State, ptr %68, i64 0, i32 14
  %71 = load i64, ptr %totalbytes.i.i35.i, align 8
  %sub.i.i36.i = sub i64 %71, %mul8.i30.i
  store i64 %sub.i.i36.i, ptr %totalbytes.i.i35.i, align 8
  br label %luaH_free.exit.i

luaH_free.exit.i:                                 ; preds = %if.then.i29.i, %sw.bb3.i
  %array.i.i = getelementptr inbounds %struct.Table, ptr %4, i64 0, i32 6
  %72 = load ptr, ptr %array.i.i, align 8
  %sizearray.i.i = getelementptr inbounds %struct.Table, ptr %4, i64 0, i32 10
  %73 = load i32, ptr %sizearray.i.i, align 8
  %conv2.i.i = sext i32 %73 to i64
  %mul3.i.i = shl nsw i64 %conv2.i.i, 4
  %74 = load ptr, ptr %l_G, align 8
  %frealloc.i10.i.i = getelementptr inbounds %struct.global_State, ptr %74, i64 0, i32 1
  %75 = load ptr, ptr %frealloc.i10.i.i, align 8
  %ud.i11.i.i = getelementptr inbounds %struct.global_State, ptr %74, i64 0, i32 2
  %76 = load ptr, ptr %ud.i11.i.i, align 8
  %call.i12.i.i = tail call ptr %75(ptr noundef %76, ptr noundef %72, i64 noundef %mul3.i.i, i64 noundef 0) #35
  %totalbytes.i14.i.i = getelementptr inbounds %struct.global_State, ptr %74, i64 0, i32 14
  %77 = load i64, ptr %totalbytes.i14.i.i, align 8
  %sub.i15.i.i = sub i64 %77, %mul3.i.i
  store i64 %sub.i15.i.i, ptr %totalbytes.i14.i.i, align 8
  %78 = load ptr, ptr %l_G, align 8
  %frealloc.i17.i.i = getelementptr inbounds %struct.global_State, ptr %78, i64 0, i32 1
  %79 = load ptr, ptr %frealloc.i17.i.i, align 8
  %ud.i18.i.i = getelementptr inbounds %struct.global_State, ptr %78, i64 0, i32 2
  %80 = load ptr, ptr %ud.i18.i.i, align 8
  %call.i19.i.i = tail call ptr %79(ptr noundef %80, ptr noundef nonnull %4, i64 noundef 64, i64 noundef 0) #35
  %totalbytes.i21.i.i = getelementptr inbounds %struct.global_State, ptr %78, i64 0, i32 14
  %81 = load i64, ptr %totalbytes.i21.i.i, align 8
  %sub.i22.i.i = add i64 %81, -64
  store i64 %sub.i22.i.i, ptr %totalbytes.i21.i.i, align 8
  br label %if.end27

sw.bb4.i:                                         ; preds = %if.end26
  %stack.i.i = getelementptr inbounds %struct.lua_State, ptr %4, i64 0, i32 10
  %82 = load ptr, ptr %stack.i.i, align 8
  tail call fastcc void @luaF_close(ptr noundef nonnull %4, ptr noundef %82)
  %base_ci.i.i.i = getelementptr inbounds %struct.lua_State, ptr %4, i64 0, i32 12
  %83 = load ptr, ptr %base_ci.i.i.i, align 8
  %size_ci.i.i.i = getelementptr inbounds %struct.lua_State, ptr %4, i64 0, i32 14
  %84 = load i32, ptr %size_ci.i.i.i, align 4
  %conv.i.i.i = sext i32 %84 to i64
  %mul.i.i.i = mul nsw i64 %conv.i.i.i, 40
  %85 = load ptr, ptr %l_G, align 8
  %frealloc.i.i.i.i = getelementptr inbounds %struct.global_State, ptr %85, i64 0, i32 1
  %86 = load ptr, ptr %frealloc.i.i.i.i, align 8
  %ud.i.i.i.i = getelementptr inbounds %struct.global_State, ptr %85, i64 0, i32 2
  %87 = load ptr, ptr %ud.i.i.i.i, align 8
  %call.i.i.i.i = tail call ptr %86(ptr noundef %87, ptr noundef %83, i64 noundef %mul.i.i.i, i64 noundef 0) #35
  %totalbytes.i.i.i.i = getelementptr inbounds %struct.global_State, ptr %85, i64 0, i32 14
  %88 = load i64, ptr %totalbytes.i.i.i.i, align 8
  %sub.i.i.i.i = sub i64 %88, %mul.i.i.i
  store i64 %sub.i.i.i.i, ptr %totalbytes.i.i.i.i, align 8
  %89 = load ptr, ptr %stack.i.i, align 8
  %stacksize.i.i.i = getelementptr inbounds %struct.lua_State, ptr %4, i64 0, i32 13
  %90 = load i32, ptr %stacksize.i.i.i, align 8
  %conv1.i.i.i = sext i32 %90 to i64
  %mul2.i.i.i = shl nsw i64 %conv1.i.i.i, 4
  %91 = load ptr, ptr %l_G, align 8
  %frealloc.i6.i.i.i = getelementptr inbounds %struct.global_State, ptr %91, i64 0, i32 1
  %92 = load ptr, ptr %frealloc.i6.i.i.i, align 8
  %ud.i7.i.i.i = getelementptr inbounds %struct.global_State, ptr %91, i64 0, i32 2
  %93 = load ptr, ptr %ud.i7.i.i.i, align 8
  %call.i8.i.i.i = tail call ptr %92(ptr noundef %93, ptr noundef %89, i64 noundef %mul2.i.i.i, i64 noundef 0) #35
  %totalbytes.i10.i.i.i = getelementptr inbounds %struct.global_State, ptr %91, i64 0, i32 14
  %94 = load i64, ptr %totalbytes.i10.i.i.i, align 8
  %sub.i11.i.i.i = sub i64 %94, %mul2.i.i.i
  store i64 %sub.i11.i.i.i, ptr %totalbytes.i10.i.i.i, align 8
  %95 = load ptr, ptr %l_G, align 8
  %frealloc.i.i37.i = getelementptr inbounds %struct.global_State, ptr %95, i64 0, i32 1
  %96 = load ptr, ptr %frealloc.i.i37.i, align 8
  %ud.i.i38.i = getelementptr inbounds %struct.global_State, ptr %95, i64 0, i32 2
  %97 = load ptr, ptr %ud.i.i38.i, align 8
  %call.i.i39.i = tail call ptr %96(ptr noundef %97, ptr noundef nonnull %4, i64 noundef 184, i64 noundef 0) #35
  %totalbytes.i.i40.i = getelementptr inbounds %struct.global_State, ptr %95, i64 0, i32 14
  %98 = load i64, ptr %totalbytes.i.i40.i, align 8
  %sub.i.i41.i = add i64 %98, -184
  store i64 %sub.i.i41.i, ptr %totalbytes.i.i40.i, align 8
  br label %if.end27

sw.bb5.i:                                         ; preds = %if.end26
  %99 = load ptr, ptr %l_G, align 8
  %nuse.i = getelementptr inbounds %struct.stringtable, ptr %99, i64 0, i32 1
  %100 = load i32, ptr %nuse.i, align 8
  %dec.i = add i32 %100, -1
  store i32 %dec.i, ptr %nuse.i, align 8
  %len.i = getelementptr inbounds %struct.anon.0, ptr %4, i64 0, i32 5
  %101 = load i64, ptr %len.i, align 8
  %add6.i = add i64 %101, 25
  %102 = load ptr, ptr %l_G, align 8
  %frealloc.i.i = getelementptr inbounds %struct.global_State, ptr %102, i64 0, i32 1
  %103 = load ptr, ptr %frealloc.i.i, align 8
  %ud.i.i = getelementptr inbounds %struct.global_State, ptr %102, i64 0, i32 2
  %104 = load ptr, ptr %ud.i.i, align 8
  %call.i.i = tail call ptr %103(ptr noundef %104, ptr noundef nonnull %4, i64 noundef %add6.i, i64 noundef 0) #35
  %totalbytes.i.i = getelementptr inbounds %struct.global_State, ptr %102, i64 0, i32 14
  %105 = load i64, ptr %totalbytes.i.i, align 8
  %sub.i.i = sub i64 %105, %add6.i
  store i64 %sub.i.i, ptr %totalbytes.i.i, align 8
  br label %if.end27

sw.bb7.i:                                         ; preds = %if.end26
  %len8.i = getelementptr inbounds %struct.anon.1, ptr %4, i64 0, i32 5
  %106 = load i64, ptr %len8.i, align 8
  %add9.i = add i64 %106, 40
  %107 = load ptr, ptr %l_G, align 8
  %frealloc.i43.i = getelementptr inbounds %struct.global_State, ptr %107, i64 0, i32 1
  %108 = load ptr, ptr %frealloc.i43.i, align 8
  %ud.i44.i = getelementptr inbounds %struct.global_State, ptr %107, i64 0, i32 2
  %109 = load ptr, ptr %ud.i44.i, align 8
  %call.i45.i = tail call ptr %108(ptr noundef %109, ptr noundef nonnull %4, i64 noundef %add9.i, i64 noundef 0) #35
  %totalbytes.i47.i = getelementptr inbounds %struct.global_State, ptr %107, i64 0, i32 14
  %110 = load i64, ptr %totalbytes.i47.i, align 8
  %sub.i48.i = sub i64 %110, %add9.i
  store i64 %sub.i48.i, ptr %totalbytes.i47.i, align 8
  br label %if.end27

if.end27:                                         ; preds = %sw.bb7.i, %sw.bb5.i, %sw.bb4.i, %luaH_free.exit.i, %luaF_freeupval.exit.i, %sw.bb1.i, %sw.bb.i, %if.end26, %if.then9
  %p.addr.1 = phi ptr [ %4, %if.then9 ], [ %p.addr.020, %if.end26 ], [ %p.addr.020, %sw.bb.i ], [ %p.addr.020, %sw.bb1.i ], [ %p.addr.020, %luaF_freeupval.exit.i ], [ %p.addr.020, %luaH_free.exit.i ], [ %p.addr.020, %sw.bb4.i ], [ %p.addr.020, %sw.bb5.i ], [ %p.addr.020, %sw.bb7.i ]
  %111 = load ptr, ptr %p.addr.1, align 8
  %cmp.not = icmp eq ptr %111, null
  br i1 %cmp.not, label %while.end, label %land.rhs, !llvm.loop !80

while.end:                                        ; preds = %land.rhs, %if.end27, %entry
  %p.addr.0.lcssa = phi ptr [ %p, %entry ], [ %p.addr.1, %if.end27 ], [ %p.addr.020, %land.rhs ]
  ret ptr %p.addr.0.lcssa
}

; Function Attrs: nounwind uwtable
define internal fastcc void @GCTM(ptr noundef %L) unnamed_addr #0 {
entry:
  %l_G = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %0 = load ptr, ptr %l_G, align 8
  %tmudata = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 11
  %1 = load ptr, ptr %tmudata, align 8
  %2 = load ptr, ptr %1, align 8
  %cmp = icmp eq ptr %2, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store ptr null, ptr %tmudata, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %3 = load ptr, ptr %2, align 8
  store ptr %3, ptr %1, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %mainthread = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 21
  %4 = load ptr, ptr %mainthread, align 8
  %5 = load ptr, ptr %4, align 8
  store ptr %5, ptr %2, align 8
  %6 = load ptr, ptr %mainthread, align 8
  store ptr %2, ptr %6, align 8
  %marked = getelementptr inbounds %struct.GCheader, ptr %2, i64 0, i32 2
  %7 = load i8, ptr %marked, align 1
  %8 = and i8 %7, -8
  %currentwhite = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 3
  %9 = load i8, ptr %currentwhite, align 8
  %10 = and i8 %9, 3
  %or35 = or disjoint i8 %10, %8
  store i8 %or35, ptr %marked, align 1
  %metatable = getelementptr inbounds %struct.anon.1, ptr %2, i64 0, i32 3
  %11 = load ptr, ptr %metatable, align 8
  %cmp16 = icmp eq ptr %11, null
  br i1 %cmp16, label %if.end43, label %cond.false

cond.false:                                       ; preds = %if.end
  %flags = getelementptr inbounds %struct.Table, ptr %11, i64 0, i32 3
  %12 = load i8, ptr %flags, align 2
  %13 = and i8 %12, 4
  %tobool.not = icmp eq i8 %13, 0
  br i1 %tobool.not, label %cond.false22, label %if.end43

cond.false22:                                     ; preds = %cond.false
  %14 = load ptr, ptr %l_G, align 8
  %arrayidx = getelementptr inbounds %struct.global_State, ptr %14, i64 0, i32 24, i64 2
  %15 = load ptr, ptr %arrayidx, align 8
  %16 = getelementptr i8, ptr %11, i64 11
  %events.val.i = load i8, ptr %16, align 1
  %17 = getelementptr i8, ptr %11, i64 32
  %events.val3.i = load ptr, ptr %17, align 8
  %hash.i.i = getelementptr inbounds %struct.anon.0, ptr %15, i64 0, i32 4
  %18 = load i32, ptr %hash.i.i, align 4
  %sh_prom.i.i = zext nneg i8 %events.val.i to i64
  %notmask.i.i = shl nsw i64 -1, %sh_prom.i.i
  %19 = trunc i64 %notmask.i.i to i32
  %20 = xor i32 %19, -1
  %conv2.i.i = and i32 %18, %20
  %idxprom.i.i = sext i32 %conv2.i.i to i64
  %arrayidx.i.i = getelementptr inbounds %struct.Node, ptr %events.val3.i, i64 %idxprom.i.i
  br label %do.body.i.i

do.body.i.i:                                      ; preds = %if.else.i.i, %cond.false22
  %n.0.i.i = phi ptr [ %arrayidx.i.i, %cond.false22 ], [ %23, %if.else.i.i ]
  %tt.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1, i32 0, i32 1
  %21 = load i32, ptr %tt.i.i, align 8
  %cmp.i.i = icmp eq i32 %21, 4
  br i1 %cmp.i.i, label %land.lhs.true.i.i, label %if.else.i.i

land.lhs.true.i.i:                                ; preds = %do.body.i.i
  %i_key.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1
  %22 = load ptr, ptr %i_key.i.i, align 8
  %cmp5.i.i = icmp eq ptr %22, %15
  br i1 %cmp5.i.i, label %luaH_getstr.exit.i, label %if.else.i.i

if.else.i.i:                                      ; preds = %land.lhs.true.i.i, %do.body.i.i
  %next.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1, i32 0, i32 2
  %23 = load ptr, ptr %next.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %23, null
  br i1 %tobool.not.i.i, label %luaH_getstr.exit.i, label %do.body.i.i, !llvm.loop !29

luaH_getstr.exit.i:                               ; preds = %if.else.i.i, %land.lhs.true.i.i
  %retval.0.i.i = phi ptr [ %n.0.i.i, %land.lhs.true.i.i ], [ @luaO_nilobject_, %if.else.i.i ]
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i.i, i64 0, i32 1
  %24 = load i32, ptr %tt.i, align 8
  %cmp.i = icmp eq i32 %24, 0
  br i1 %cmp.i, label %if.then.i, label %if.then29

if.then.i:                                        ; preds = %luaH_getstr.exit.i
  %conv3.i = or disjoint i8 %12, 4
  store i8 %conv3.i, ptr %flags, align 2
  br label %if.end43

if.then29:                                        ; preds = %luaH_getstr.exit.i
  %allowhook = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 18
  %25 = load i8, ptr %allowhook, align 1
  %GCthreshold = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 13
  %26 = load i64, ptr %GCthreshold, align 8
  store i8 0, ptr %allowhook, align 1
  %totalbytes = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 14
  %27 = load i64, ptr %totalbytes, align 8
  %mul = shl i64 %27, 1
  store i64 %mul, ptr %GCthreshold, align 8
  %top = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %28 = load ptr, ptr %top, align 8
  %29 = load i64, ptr %retval.0.i.i, align 8
  store i64 %29, ptr %28, align 8
  %30 = load i32, ptr %tt.i, align 8
  %tt33 = getelementptr inbounds %struct.lua_TValue, ptr %28, i64 0, i32 1
  store i32 %30, ptr %tt33, align 8
  %31 = load ptr, ptr %top, align 8
  %add.ptr = getelementptr inbounds %struct.lua_TValue, ptr %31, i64 1
  store ptr %2, ptr %add.ptr, align 8
  %tt36 = getelementptr inbounds %struct.lua_TValue, ptr %31, i64 1, i32 1
  store i32 7, ptr %tt36, align 8
  %32 = load ptr, ptr %top, align 8
  %add.ptr38 = getelementptr inbounds %struct.lua_TValue, ptr %32, i64 2
  store ptr %add.ptr38, ptr %top, align 8
  tail call fastcc void @luaD_call(ptr noundef %L, ptr noundef %32, i32 noundef 0)
  store i8 %25, ptr %allowhook, align 1
  store i64 %26, ptr %GCthreshold, align 8
  br label %if.end43

if.end43:                                         ; preds = %if.then.i, %cond.false, %if.end, %if.then29
  ret void
}

; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define internal fastcc i64 @luaC_separateudata(ptr nocapture noundef readonly %L, i32 noundef %all) unnamed_addr #18 {
entry:
  %l_G = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %0 = load ptr, ptr %l_G, align 8
  %mainthread = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 21
  %1 = load ptr, ptr %mainthread, align 8
  %2 = load ptr, ptr %1, align 8
  %cmp.not28 = icmp eq ptr %2, null
  br i1 %cmp.not28, label %while.end, label %while.body.lr.ph

while.body.lr.ph:                                 ; preds = %entry
  %tmudata = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 11
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %if.end47
  %3 = phi ptr [ %2, %while.body.lr.ph ], [ %28, %if.end47 ]
  %deadmem.030 = phi i64 [ 0, %while.body.lr.ph ], [ %deadmem.1, %if.end47 ]
  %p.029 = phi ptr [ %1, %while.body.lr.ph ], [ %p.1, %if.end47 ]
  %marked = getelementptr inbounds %struct.GCheader, ptr %3, i64 0, i32 2
  %4 = load i8, ptr %marked, align 1
  %conv = zext i8 %4 to i32
  %and = and i32 %conv, 3
  %5 = or i32 %and, %all
  %or.cond.not = icmp ne i32 %5, 0
  %and5 = and i32 %conv, 8
  %tobool6.not = icmp eq i32 %and5, 0
  %or.cond = and i1 %tobool6.not, %or.cond.not
  br i1 %or.cond, label %if.else, label %if.end47

if.else:                                          ; preds = %while.body
  %metatable = getelementptr inbounds %struct.anon.1, ptr %3, i64 0, i32 3
  %6 = load ptr, ptr %metatable, align 8
  %cmp8 = icmp eq ptr %6, null
  br i1 %cmp8, label %if.then22, label %cond.false

cond.false:                                       ; preds = %if.else
  %flags = getelementptr inbounds %struct.Table, ptr %6, i64 0, i32 3
  %7 = load i8, ptr %flags, align 2
  %8 = and i8 %7, 4
  %tobool13.not = icmp eq i8 %8, 0
  br i1 %tobool13.not, label %cond.false15, label %if.then22

cond.false15:                                     ; preds = %cond.false
  %9 = load ptr, ptr %l_G, align 8
  %arrayidx = getelementptr inbounds %struct.global_State, ptr %9, i64 0, i32 24, i64 2
  %10 = load ptr, ptr %arrayidx, align 8
  %11 = getelementptr i8, ptr %6, i64 11
  %events.val.i = load i8, ptr %11, align 1
  %12 = getelementptr i8, ptr %6, i64 32
  %events.val3.i = load ptr, ptr %12, align 8
  %hash.i.i = getelementptr inbounds %struct.anon.0, ptr %10, i64 0, i32 4
  %13 = load i32, ptr %hash.i.i, align 4
  %sh_prom.i.i = zext nneg i8 %events.val.i to i64
  %notmask.i.i = shl nsw i64 -1, %sh_prom.i.i
  %14 = trunc i64 %notmask.i.i to i32
  %15 = xor i32 %14, -1
  %conv2.i.i = and i32 %13, %15
  %idxprom.i.i = sext i32 %conv2.i.i to i64
  %arrayidx.i.i = getelementptr inbounds %struct.Node, ptr %events.val3.i, i64 %idxprom.i.i
  br label %do.body.i.i

do.body.i.i:                                      ; preds = %if.else.i.i, %cond.false15
  %n.0.i.i = phi ptr [ %arrayidx.i.i, %cond.false15 ], [ %18, %if.else.i.i ]
  %tt.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1, i32 0, i32 1
  %16 = load i32, ptr %tt.i.i, align 8
  %cmp.i.i = icmp eq i32 %16, 4
  br i1 %cmp.i.i, label %land.lhs.true.i.i, label %if.else.i.i

land.lhs.true.i.i:                                ; preds = %do.body.i.i
  %i_key.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1
  %17 = load ptr, ptr %i_key.i.i, align 8
  %cmp5.i.i = icmp eq ptr %17, %10
  br i1 %cmp5.i.i, label %luaH_getstr.exit.i, label %if.else.i.i

if.else.i.i:                                      ; preds = %land.lhs.true.i.i, %do.body.i.i
  %next.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1, i32 0, i32 2
  %18 = load ptr, ptr %next.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %18, null
  br i1 %tobool.not.i.i, label %luaH_getstr.exit.i, label %do.body.i.i, !llvm.loop !29

luaH_getstr.exit.i:                               ; preds = %if.else.i.i, %land.lhs.true.i.i
  %retval.0.i.i = phi ptr [ %n.0.i.i, %land.lhs.true.i.i ], [ @luaO_nilobject_, %if.else.i.i ]
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i.i, i64 0, i32 1
  %19 = load i32, ptr %tt.i, align 8
  %cmp.i = icmp eq i32 %19, 0
  br i1 %cmp.i, label %if.then.i, label %if.else27

if.then.i:                                        ; preds = %luaH_getstr.exit.i
  %conv3.i = or disjoint i8 %7, 4
  store i8 %conv3.i, ptr %flags, align 2
  %.pre = load i8, ptr %marked, align 1
  br label %if.then22

if.then22:                                        ; preds = %if.else, %cond.false, %if.then.i
  %20 = phi i8 [ %4, %if.else ], [ %4, %cond.false ], [ %.pre, %if.then.i ]
  %21 = or i8 %20, 8
  store i8 %21, ptr %marked, align 1
  br label %if.end47

if.else27:                                        ; preds = %luaH_getstr.exit.i
  %len = getelementptr inbounds %struct.anon.1, ptr %3, i64 0, i32 5
  %22 = load i64, ptr %len, align 8
  %add = add i64 %deadmem.030, 40
  %add28 = add i64 %add, %22
  %23 = or i8 %4, 8
  store i8 %23, ptr %marked, align 1
  %24 = load ptr, ptr %3, align 8
  store ptr %24, ptr %p.029, align 8
  %25 = load ptr, ptr %tmudata, align 8
  %cmp34 = icmp eq ptr %25, null
  br i1 %cmp34, label %if.then36, label %if.else39

if.then36:                                        ; preds = %if.else27
  store ptr %3, ptr %3, align 8
  store ptr %3, ptr %tmudata, align 8
  br label %if.end47

if.else39:                                        ; preds = %if.else27
  %26 = load ptr, ptr %25, align 8
  store ptr %26, ptr %3, align 8
  %27 = load ptr, ptr %tmudata, align 8
  store ptr %3, ptr %27, align 8
  store ptr %3, ptr %tmudata, align 8
  br label %if.end47

if.end47:                                         ; preds = %while.body, %if.then22, %if.else39, %if.then36
  %p.1 = phi ptr [ %3, %if.then22 ], [ %p.029, %if.then36 ], [ %p.029, %if.else39 ], [ %3, %while.body ]
  %deadmem.1 = phi i64 [ %deadmem.030, %if.then22 ], [ %add28, %if.then36 ], [ %add28, %if.else39 ], [ %deadmem.030, %while.body ]
  %28 = load ptr, ptr %p.1, align 8
  %cmp.not = icmp eq ptr %28, null
  br i1 %cmp.not, label %while.end, label %while.body, !llvm.loop !81

while.end:                                        ; preds = %if.end47, %entry
  %deadmem.0.lcssa = phi i64 [ 0, %entry ], [ %deadmem.1, %if.end47 ]
  ret i64 %deadmem.0.lcssa
}

; Function Attrs: mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite)
declare void @free(ptr allocptr nocapture noundef) local_unnamed_addr #19

; Function Attrs: mustprogress nounwind willreturn allockind("realloc") allocsize(1) memory(argmem: readwrite, inaccessiblemem: readwrite)
declare noalias noundef ptr @realloc(ptr allocptr nocapture noundef, i64 noundef) local_unnamed_addr #20

; Function Attrs: nounwind uwtable
define internal fastcc void @lua_pushcclosure(ptr noundef %L, ptr noundef %fn, i32 noundef %n) unnamed_addr #0 {
entry:
  %l_G = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %0 = load ptr, ptr %l_G, align 8
  %totalbytes = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 14
  %1 = load i64, ptr %totalbytes, align 8
  %GCthreshold = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 13
  %2 = load i64, ptr %GCthreshold, align 8
  %cmp.not = icmp ult i64 %1, %2
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %gcstepmul.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 18
  %3 = load i32, ptr %gcstepmul.i, align 4
  %mul.i = mul i32 %3, 10
  %conv.i = zext i32 %mul.i to i64
  %cmp.i = icmp eq i32 %mul.i, 0
  %spec.store.select.i = select i1 %cmp.i, i64 9223372036854775806, i64 %conv.i
  %sub.i = sub i64 %1, %2
  %gcdept.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 16
  %4 = load i64, ptr %gcdept.i, align 8
  %add.i = add i64 %sub.i, %4
  store i64 %add.i, ptr %gcdept.i, align 8
  %gcstate.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 4
  br label %do.body.i

do.body.i:                                        ; preds = %do.body.i, %if.then
  %lim.0.i = phi i64 [ %spec.store.select.i, %if.then ], [ %sub2.i, %do.body.i ]
  %call.i = tail call fastcc i64 @singlestep(ptr noundef %L)
  %sub2.i = sub nsw i64 %lim.0.i, %call.i
  %5 = load i8, ptr %gcstate.i, align 1
  %cmp4.i = icmp ne i8 %5, 0
  %cmp8.i = icmp sgt i64 %sub2.i, 0
  %or.cond.i = select i1 %cmp4.i, i1 %cmp8.i, i1 false
  br i1 %or.cond.i, label %do.body.i, label %do.end.i, !llvm.loop !6

do.end.i:                                         ; preds = %do.body.i
  br i1 %cmp4.i, label %if.then14.i, label %if.else27.i

if.then14.i:                                      ; preds = %do.end.i
  %6 = load i64, ptr %gcdept.i, align 8
  %cmp16.i = icmp ult i64 %6, 1024
  br i1 %cmp16.i, label %if.then18.i, label %if.else.i

if.then18.i:                                      ; preds = %if.then14.i
  %7 = load i64, ptr %totalbytes, align 8
  %add20.i = add i64 %7, 1024
  br label %luaC_step.exit

if.else.i:                                        ; preds = %if.then14.i
  %sub23.i = add i64 %6, -1024
  store i64 %sub23.i, ptr %gcdept.i, align 8
  %8 = load i64, ptr %totalbytes, align 8
  br label %luaC_step.exit

if.else27.i:                                      ; preds = %do.end.i
  %estimate.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 15
  %9 = load i64, ptr %estimate.i, align 8
  %div.i = udiv i64 %9, 100
  %gcpause.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 17
  %10 = load i32, ptr %gcpause.i, align 8
  %conv28.i = sext i32 %10 to i64
  %mul29.i = mul i64 %div.i, %conv28.i
  br label %luaC_step.exit

luaC_step.exit:                                   ; preds = %if.then18.i, %if.else.i, %if.else27.i
  %add20.sink.i = phi i64 [ %add20.i, %if.then18.i ], [ %8, %if.else.i ], [ %mul29.i, %if.else27.i ]
  store i64 %add20.sink.i, ptr %GCthreshold, align 8
  br label %if.end

if.end:                                           ; preds = %luaC_step.exit, %entry
  %ci.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %11 = load ptr, ptr %ci.i, align 8
  %base_ci.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 12
  %12 = load ptr, ptr %base_ci.i, align 8
  %cmp.i18 = icmp eq ptr %11, %12
  br i1 %cmp.i18, label %if.then.i, label %if.else.i19

if.then.i:                                        ; preds = %if.end
  %l_gt.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 22
  br label %getcurrenv.exit

if.else.i19:                                      ; preds = %if.end
  %func2.i = getelementptr inbounds %struct.CallInfo, ptr %11, i64 0, i32 1
  %13 = load ptr, ptr %func2.i, align 8
  %14 = load ptr, ptr %13, align 8
  %env.i = getelementptr inbounds %struct.CClosure, ptr %14, i64 0, i32 6
  br label %getcurrenv.exit

getcurrenv.exit:                                  ; preds = %if.then.i, %if.else.i19
  %retval.0.in.i = phi ptr [ %l_gt.i, %if.then.i ], [ %env.i, %if.else.i19 ]
  %retval.0.i = load ptr, ptr %retval.0.in.i, align 8
  %sub.i20 = shl i32 %n, 4
  %add.i21 = add i32 %sub.i20, 40
  %conv2.i = zext nneg i32 %add.i21 to i64
  %15 = load ptr, ptr %l_G, align 8
  %frealloc.i.i = getelementptr inbounds %struct.global_State, ptr %15, i64 0, i32 1
  %16 = load ptr, ptr %frealloc.i.i, align 8
  %ud.i.i = getelementptr inbounds %struct.global_State, ptr %15, i64 0, i32 2
  %17 = load ptr, ptr %ud.i.i, align 8
  %call.i.i = tail call ptr %16(ptr noundef %17, ptr noundef null, i64 noundef 0, i64 noundef %conv2.i) #35
  %cmp.i.i = icmp eq ptr %call.i.i, null
  br i1 %cmp.i.i, label %if.then.i.i, label %luaF_newCclosure.exit

if.then.i.i:                                      ; preds = %getcurrenv.exit
  %errorJmp.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 26
  %18 = load ptr, ptr %errorJmp.i.i.i, align 8
  %tobool.not.i.i.i = icmp eq ptr %18, null
  br i1 %tobool.not.i.i.i, label %if.else.i.i.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %if.then.i.i
  %status.i.i.i = getelementptr inbounds %struct.lua_longjmp, ptr %18, i64 0, i32 2
  store volatile i32 4, ptr %status.i.i.i, align 8
  %19 = load ptr, ptr %errorJmp.i.i.i, align 8
  %b.i.i.i = getelementptr inbounds %struct.lua_longjmp, ptr %19, i64 0, i32 1
  tail call void @longjmp(ptr noundef nonnull %b.i.i.i, i32 noundef 1) #38
  unreachable

if.else.i.i.i:                                    ; preds = %if.then.i.i
  %status3.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 3
  store i8 4, ptr %status3.i.i.i, align 2
  %20 = load ptr, ptr %l_G, align 8
  %panic.i.i.i = getelementptr inbounds %struct.global_State, ptr %20, i64 0, i32 19
  %21 = load ptr, ptr %panic.i.i.i, align 8
  %tobool4.not.i.i.i = icmp eq ptr %21, null
  br i1 %tobool4.not.i.i.i, label %if.end.i.i.i, label %if.then5.i.i.i

if.then5.i.i.i:                                   ; preds = %if.else.i.i.i
  tail call fastcc void @resetstack(ptr noundef nonnull %L, i32 noundef 4)
  %22 = load ptr, ptr %l_G, align 8
  %panic7.i.i.i = getelementptr inbounds %struct.global_State, ptr %22, i64 0, i32 19
  %23 = load ptr, ptr %panic7.i.i.i, align 8
  %call.i.i.i = tail call i32 %23(ptr noundef nonnull %L) #35
  br label %if.end.i.i.i

if.end.i.i.i:                                     ; preds = %if.then5.i.i.i, %if.else.i.i.i
  tail call void @exit(i32 noundef 1) #38
  unreachable

luaF_newCclosure.exit:                            ; preds = %getcurrenv.exit
  %totalbytes.i.i = getelementptr inbounds %struct.global_State, ptr %15, i64 0, i32 14
  %24 = load i64, ptr %totalbytes.i.i, align 8
  %add.i.i = add i64 %24, %conv2.i
  store i64 %add.i.i, ptr %totalbytes.i.i, align 8
  %L.val.i = load ptr, ptr %l_G, align 8
  %rootgc.i.i = getelementptr inbounds %struct.global_State, ptr %L.val.i, i64 0, i32 6
  %25 = load ptr, ptr %rootgc.i.i, align 8
  store ptr %25, ptr %call.i.i, align 8
  store ptr %call.i.i, ptr %rootgc.i.i, align 8
  %currentwhite.i.i = getelementptr inbounds %struct.global_State, ptr %L.val.i, i64 0, i32 3
  %26 = load i8, ptr %currentwhite.i.i, align 8
  %27 = and i8 %26, 3
  %marked.i.i = getelementptr inbounds %struct.GCheader, ptr %call.i.i, i64 0, i32 2
  store i8 %27, ptr %marked.i.i, align 1
  %tt3.i.i = getelementptr inbounds %struct.GCheader, ptr %call.i.i, i64 0, i32 1
  store i8 6, ptr %tt3.i.i, align 8
  %isC.i = getelementptr inbounds %struct.CClosure, ptr %call.i.i, i64 0, i32 3
  store i8 1, ptr %isC.i, align 2
  %env.i22 = getelementptr inbounds %struct.CClosure, ptr %call.i.i, i64 0, i32 6
  store ptr %retval.0.i, ptr %env.i22, align 8
  %conv3.i = trunc i32 %n to i8
  %nupvalues.i = getelementptr inbounds %struct.CClosure, ptr %call.i.i, i64 0, i32 4
  store i8 %conv3.i, ptr %nupvalues.i, align 1
  %f = getelementptr inbounds %struct.CClosure, ptr %call.i.i, i64 0, i32 7
  store ptr %fn, ptr %f, align 8
  %top = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %28 = load ptr, ptr %top, align 8
  %idx.ext = zext nneg i32 %n to i64
  %idx.neg = sub nsw i64 0, %idx.ext
  %add.ptr = getelementptr inbounds %struct.lua_TValue, ptr %28, i64 %idx.neg
  store ptr %add.ptr, ptr %top, align 8
  %tobool.not23 = icmp eq i32 %n, 0
  br i1 %tobool.not23, label %while.end, label %while.body.preheader

while.body.preheader:                             ; preds = %luaF_newCclosure.exit
  %29 = sext i32 %n to i64
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %while.body
  %indvars.iv = phi i64 [ %29, %while.body.preheader ], [ %indvars.iv.next, %while.body ]
  %indvars.iv.next = add nsw i64 %indvars.iv, -1
  %30 = load ptr, ptr %top, align 8
  %add.ptr5 = getelementptr inbounds %struct.lua_TValue, ptr %30, i64 %indvars.iv.next
  %arrayidx = getelementptr inbounds %struct.CClosure, ptr %call.i.i, i64 0, i32 8, i64 %indvars.iv.next
  %31 = load i64, ptr %add.ptr5, align 8
  store i64 %31, ptr %arrayidx, align 8
  %tt = getelementptr inbounds %struct.lua_TValue, ptr %30, i64 %indvars.iv.next, i32 1
  %32 = load i32, ptr %tt, align 8
  %tt7 = getelementptr inbounds %struct.CClosure, ptr %call.i.i, i64 0, i32 8, i64 %indvars.iv.next, i32 1
  store i32 %32, ptr %tt7, align 8
  %33 = and i64 %indvars.iv.next, 4294967295
  %tobool.not = icmp eq i64 %33, 0
  br i1 %tobool.not, label %while.end.loopexit, label %while.body, !llvm.loop !82

while.end.loopexit:                               ; preds = %while.body
  %.pre = load ptr, ptr %top, align 8
  br label %while.end

while.end:                                        ; preds = %while.end.loopexit, %luaF_newCclosure.exit
  %34 = phi ptr [ %.pre, %while.end.loopexit ], [ %add.ptr, %luaF_newCclosure.exit ]
  store ptr %call.i.i, ptr %34, align 8
  %tt10 = getelementptr inbounds %struct.lua_TValue, ptr %34, i64 0, i32 1
  store i32 6, ptr %tt10, align 8
  %35 = load ptr, ptr %top, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue, ptr %35, i64 1
  store ptr %incdec.ptr, ptr %top, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @luaopen_base(ptr noundef %L) #0 {
entry:
  %key.i131.i = alloca %struct.lua_TValue, align 8
  %key.i122.i = alloca %struct.lua_TValue, align 8
  %key.i.i29.i = alloca %struct.lua_TValue, align 8
  %key.i.i.i = alloca %struct.lua_TValue, align 8
  %key.i21.i = alloca %struct.lua_TValue, align 8
  %key.i.i = alloca %struct.lua_TValue, align 8
  %l_gt.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 22
  %top.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %0 = load ptr, ptr %top.i.i, align 8
  %1 = load i64, ptr %l_gt.i.i.i, align 8
  store i64 %1, ptr %0, align 8
  %tt.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 22, i32 1
  %2 = load i32, ptr %tt.i.i, align 8
  %tt2.i.i = getelementptr inbounds %struct.lua_TValue, ptr %0, i64 0, i32 1
  store i32 %2, ptr %tt2.i.i, align 8
  %3 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i.i = getelementptr inbounds %struct.lua_TValue, ptr %3, i64 1
  store ptr %incdec.ptr.i.i, ptr %top.i.i, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %key.i.i)
  %call2.i.i = tail call fastcc ptr @luaS_newlstr(ptr noundef %L, ptr noundef nonnull @.str.94, i64 noundef 2)
  store ptr %call2.i.i, ptr %key.i.i, align 8
  %tt.i15.i = getelementptr inbounds %struct.lua_TValue, ptr %key.i.i, i64 0, i32 1
  store i32 4, ptr %tt.i15.i, align 8
  %4 = load ptr, ptr %top.i.i, align 8
  %add.ptr.i.i = getelementptr inbounds %struct.lua_TValue, ptr %4, i64 -1
  call fastcc void @luaV_settable(ptr noundef %L, ptr noundef nonnull %l_gt.i.i.i, ptr noundef nonnull %key.i.i, ptr noundef nonnull %add.ptr.i.i)
  %5 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i17.i = getelementptr inbounds %struct.lua_TValue, ptr %5, i64 -1
  store ptr %incdec.ptr.i17.i, ptr %top.i.i, align 8
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %key.i.i)
  tail call fastcc void @luaL_register(ptr noundef %L, ptr noundef nonnull @.str.94, ptr noundef nonnull @base_funcs)
  %l_G.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %6 = load ptr, ptr %l_G.i.i, align 8
  %totalbytes.i.i = getelementptr inbounds %struct.global_State, ptr %6, i64 0, i32 14
  %7 = load i64, ptr %totalbytes.i.i, align 8
  %GCthreshold.i.i = getelementptr inbounds %struct.global_State, ptr %6, i64 0, i32 13
  %8 = load i64, ptr %GCthreshold.i.i, align 8
  %cmp.not.i.i = icmp ult i64 %7, %8
  br i1 %cmp.not.i.i, label %lua_pushlstring.exit.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %entry
  %gcstepmul.i.i.i = getelementptr inbounds %struct.global_State, ptr %6, i64 0, i32 18
  %9 = load i32, ptr %gcstepmul.i.i.i, align 4
  %mul.i.i.i = mul i32 %9, 10
  %conv.i.i.i = zext i32 %mul.i.i.i to i64
  %cmp.i.i.i = icmp eq i32 %mul.i.i.i, 0
  %spec.store.select.i.i.i = select i1 %cmp.i.i.i, i64 9223372036854775806, i64 %conv.i.i.i
  %sub.i.i.i = sub i64 %7, %8
  %gcdept.i.i.i = getelementptr inbounds %struct.global_State, ptr %6, i64 0, i32 16
  %10 = load i64, ptr %gcdept.i.i.i, align 8
  %add.i.i.i = add i64 %sub.i.i.i, %10
  store i64 %add.i.i.i, ptr %gcdept.i.i.i, align 8
  %gcstate.i.i.i = getelementptr inbounds %struct.global_State, ptr %6, i64 0, i32 4
  br label %do.body.i.i.i

do.body.i.i.i:                                    ; preds = %do.body.i.i.i, %if.then.i.i
  %lim.0.i.i.i = phi i64 [ %spec.store.select.i.i.i, %if.then.i.i ], [ %sub2.i.i.i, %do.body.i.i.i ]
  %call.i.i.i = tail call fastcc i64 @singlestep(ptr noundef %L)
  %sub2.i.i.i = sub nsw i64 %lim.0.i.i.i, %call.i.i.i
  %11 = load i8, ptr %gcstate.i.i.i, align 1
  %cmp4.i.i.i = icmp ne i8 %11, 0
  %cmp8.i.i.i = icmp sgt i64 %sub2.i.i.i, 0
  %or.cond.i.i.i = select i1 %cmp4.i.i.i, i1 %cmp8.i.i.i, i1 false
  br i1 %or.cond.i.i.i, label %do.body.i.i.i, label %do.end.i.i.i, !llvm.loop !6

do.end.i.i.i:                                     ; preds = %do.body.i.i.i
  br i1 %cmp4.i.i.i, label %if.then14.i.i.i, label %if.else27.i.i.i

if.then14.i.i.i:                                  ; preds = %do.end.i.i.i
  %12 = load i64, ptr %gcdept.i.i.i, align 8
  %cmp16.i.i.i = icmp ult i64 %12, 1024
  br i1 %cmp16.i.i.i, label %if.then18.i.i.i, label %if.else.i.i.i

if.then18.i.i.i:                                  ; preds = %if.then14.i.i.i
  %13 = load i64, ptr %totalbytes.i.i, align 8
  %add20.i.i.i = add i64 %13, 1024
  br label %luaC_step.exit.i.i

if.else.i.i.i:                                    ; preds = %if.then14.i.i.i
  %sub23.i.i.i = add i64 %12, -1024
  store i64 %sub23.i.i.i, ptr %gcdept.i.i.i, align 8
  %14 = load i64, ptr %totalbytes.i.i, align 8
  br label %luaC_step.exit.i.i

if.else27.i.i.i:                                  ; preds = %do.end.i.i.i
  %estimate.i.i.i = getelementptr inbounds %struct.global_State, ptr %6, i64 0, i32 15
  %15 = load i64, ptr %estimate.i.i.i, align 8
  %div.i.i.i = udiv i64 %15, 100
  %gcpause.i.i.i = getelementptr inbounds %struct.global_State, ptr %6, i64 0, i32 17
  %16 = load i32, ptr %gcpause.i.i.i, align 8
  %conv28.i.i.i = sext i32 %16 to i64
  %mul29.i.i.i = mul i64 %div.i.i.i, %conv28.i.i.i
  br label %luaC_step.exit.i.i

luaC_step.exit.i.i:                               ; preds = %if.else27.i.i.i, %if.else.i.i.i, %if.then18.i.i.i
  %add20.sink.i.i.i = phi i64 [ %add20.i.i.i, %if.then18.i.i.i ], [ %14, %if.else.i.i.i ], [ %mul29.i.i.i, %if.else27.i.i.i ]
  store i64 %add20.sink.i.i.i, ptr %GCthreshold.i.i, align 8
  br label %lua_pushlstring.exit.i

lua_pushlstring.exit.i:                           ; preds = %luaC_step.exit.i.i, %entry
  %17 = load ptr, ptr %top.i.i, align 8
  %call.i.i = tail call fastcc ptr @luaS_newlstr(ptr noundef %L, ptr noundef nonnull @.str.95, i64 noundef 7)
  store ptr %call.i.i, ptr %17, align 8
  %tt.i19.i = getelementptr inbounds %struct.lua_TValue, ptr %17, i64 0, i32 1
  store i32 4, ptr %tt.i19.i, align 8
  %18 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i20.i = getelementptr inbounds %struct.lua_TValue, ptr %18, i64 1
  store ptr %incdec.ptr.i20.i, ptr %top.i.i, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %key.i21.i)
  %call2.i24.i = tail call fastcc ptr @luaS_newlstr(ptr noundef %L, ptr noundef nonnull @.str.96, i64 noundef 8)
  store ptr %call2.i24.i, ptr %key.i21.i, align 8
  %tt.i25.i = getelementptr inbounds %struct.lua_TValue, ptr %key.i21.i, i64 0, i32 1
  store i32 4, ptr %tt.i25.i, align 8
  %19 = load ptr, ptr %top.i.i, align 8
  %add.ptr.i27.i = getelementptr inbounds %struct.lua_TValue, ptr %19, i64 -1
  call fastcc void @luaV_settable(ptr noundef %L, ptr noundef nonnull %l_gt.i.i.i, ptr noundef nonnull %key.i21.i, ptr noundef nonnull %add.ptr.i27.i)
  %20 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i28.i = getelementptr inbounds %struct.lua_TValue, ptr %20, i64 -1
  store ptr %incdec.ptr.i28.i, ptr %top.i.i, align 8
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %key.i21.i)
  tail call fastcc void @lua_pushcclosure(ptr noundef %L, ptr noundef nonnull @ipairsaux, i32 noundef 0)
  tail call fastcc void @lua_pushcclosure(ptr noundef %L, ptr noundef nonnull @luaB_ipairs, i32 noundef 1)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %key.i.i.i)
  %21 = load ptr, ptr %top.i.i, align 8
  %add.ptr8.i.i.i.i = getelementptr inbounds %struct.lua_TValue, ptr %21, i64 -2
  %call2.i.i.i = tail call fastcc ptr @luaS_newlstr(ptr noundef %L, ptr noundef nonnull @.str.97, i64 noundef 6)
  store ptr %call2.i.i.i, ptr %key.i.i.i, align 8
  %tt.i.i.i = getelementptr inbounds %struct.lua_TValue, ptr %key.i.i.i, i64 0, i32 1
  store i32 4, ptr %tt.i.i.i, align 8
  %22 = load ptr, ptr %top.i.i, align 8
  %add.ptr.i.i.i = getelementptr inbounds %struct.lua_TValue, ptr %22, i64 -1
  call fastcc void @luaV_settable(ptr noundef %L, ptr noundef nonnull %add.ptr8.i.i.i.i, ptr noundef nonnull %key.i.i.i, ptr noundef nonnull %add.ptr.i.i.i)
  %23 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i.i.i = getelementptr inbounds %struct.lua_TValue, ptr %23, i64 -1
  store ptr %incdec.ptr.i.i.i, ptr %top.i.i, align 8
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %key.i.i.i)
  tail call fastcc void @lua_pushcclosure(ptr noundef %L, ptr noundef nonnull @luaB_next, i32 noundef 0)
  tail call fastcc void @lua_pushcclosure(ptr noundef %L, ptr noundef nonnull @luaB_pairs, i32 noundef 1)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %key.i.i29.i)
  %24 = load ptr, ptr %top.i.i, align 8
  %add.ptr8.i.i.i31.i = getelementptr inbounds %struct.lua_TValue, ptr %24, i64 -2
  %call2.i.i33.i = tail call fastcc ptr @luaS_newlstr(ptr noundef %L, ptr noundef nonnull @.str.98, i64 noundef 5)
  store ptr %call2.i.i33.i, ptr %key.i.i29.i, align 8
  %tt.i.i34.i = getelementptr inbounds %struct.lua_TValue, ptr %key.i.i29.i, i64 0, i32 1
  store i32 4, ptr %tt.i.i34.i, align 8
  %25 = load ptr, ptr %top.i.i, align 8
  %add.ptr.i.i35.i = getelementptr inbounds %struct.lua_TValue, ptr %25, i64 -1
  call fastcc void @luaV_settable(ptr noundef %L, ptr noundef nonnull %add.ptr8.i.i.i31.i, ptr noundef nonnull %key.i.i29.i, ptr noundef nonnull %add.ptr.i.i35.i)
  %26 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i.i36.i = getelementptr inbounds %struct.lua_TValue, ptr %26, i64 -1
  store ptr %incdec.ptr.i.i36.i, ptr %top.i.i, align 8
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %key.i.i29.i)
  %27 = load ptr, ptr %l_G.i.i, align 8
  %totalbytes.i38.i = getelementptr inbounds %struct.global_State, ptr %27, i64 0, i32 14
  %28 = load i64, ptr %totalbytes.i38.i, align 8
  %GCthreshold.i39.i = getelementptr inbounds %struct.global_State, ptr %27, i64 0, i32 13
  %29 = load i64, ptr %GCthreshold.i39.i, align 8
  %cmp.not.i40.i = icmp ult i64 %28, %29
  br i1 %cmp.not.i40.i, label %lua_createtable.exit.i, label %if.then.i41.i

if.then.i41.i:                                    ; preds = %lua_pushlstring.exit.i
  %gcstepmul.i.i42.i = getelementptr inbounds %struct.global_State, ptr %27, i64 0, i32 18
  %30 = load i32, ptr %gcstepmul.i.i42.i, align 4
  %mul.i.i43.i = mul i32 %30, 10
  %conv.i.i44.i = zext i32 %mul.i.i43.i to i64
  %cmp.i.i45.i = icmp eq i32 %mul.i.i43.i, 0
  %spec.store.select.i.i46.i = select i1 %cmp.i.i45.i, i64 9223372036854775806, i64 %conv.i.i44.i
  %sub.i.i47.i = sub i64 %28, %29
  %gcdept.i.i48.i = getelementptr inbounds %struct.global_State, ptr %27, i64 0, i32 16
  %31 = load i64, ptr %gcdept.i.i48.i, align 8
  %add.i.i49.i = add i64 %sub.i.i47.i, %31
  store i64 %add.i.i49.i, ptr %gcdept.i.i48.i, align 8
  %gcstate.i.i50.i = getelementptr inbounds %struct.global_State, ptr %27, i64 0, i32 4
  br label %do.body.i.i51.i

do.body.i.i51.i:                                  ; preds = %do.body.i.i51.i, %if.then.i41.i
  %lim.0.i.i52.i = phi i64 [ %spec.store.select.i.i46.i, %if.then.i41.i ], [ %sub2.i.i54.i, %do.body.i.i51.i ]
  %call.i.i53.i = tail call fastcc i64 @singlestep(ptr noundef %L)
  %sub2.i.i54.i = sub nsw i64 %lim.0.i.i52.i, %call.i.i53.i
  %32 = load i8, ptr %gcstate.i.i50.i, align 1
  %cmp4.i.i55.i = icmp ne i8 %32, 0
  %cmp8.i.i56.i = icmp sgt i64 %sub2.i.i54.i, 0
  %or.cond.i.i57.i = select i1 %cmp4.i.i55.i, i1 %cmp8.i.i56.i, i1 false
  br i1 %or.cond.i.i57.i, label %do.body.i.i51.i, label %do.end.i.i58.i, !llvm.loop !6

do.end.i.i58.i:                                   ; preds = %do.body.i.i51.i
  br i1 %cmp4.i.i55.i, label %if.then14.i.i71.i, label %if.else27.i.i59.i

if.then14.i.i71.i:                                ; preds = %do.end.i.i58.i
  %33 = load i64, ptr %gcdept.i.i48.i, align 8
  %cmp16.i.i72.i = icmp ult i64 %33, 1024
  br i1 %cmp16.i.i72.i, label %if.then18.i.i75.i, label %if.else.i.i73.i

if.then18.i.i75.i:                                ; preds = %if.then14.i.i71.i
  %34 = load i64, ptr %totalbytes.i38.i, align 8
  %add20.i.i76.i = add i64 %34, 1024
  br label %luaC_step.exit.i65.i

if.else.i.i73.i:                                  ; preds = %if.then14.i.i71.i
  %sub23.i.i74.i = add i64 %33, -1024
  store i64 %sub23.i.i74.i, ptr %gcdept.i.i48.i, align 8
  %35 = load i64, ptr %totalbytes.i38.i, align 8
  br label %luaC_step.exit.i65.i

if.else27.i.i59.i:                                ; preds = %do.end.i.i58.i
  %estimate.i.i60.i = getelementptr inbounds %struct.global_State, ptr %27, i64 0, i32 15
  %36 = load i64, ptr %estimate.i.i60.i, align 8
  %div.i.i61.i = udiv i64 %36, 100
  %gcpause.i.i62.i = getelementptr inbounds %struct.global_State, ptr %27, i64 0, i32 17
  %37 = load i32, ptr %gcpause.i.i62.i, align 8
  %conv28.i.i63.i = sext i32 %37 to i64
  %mul29.i.i64.i = mul i64 %div.i.i61.i, %conv28.i.i63.i
  br label %luaC_step.exit.i65.i

luaC_step.exit.i65.i:                             ; preds = %if.else27.i.i59.i, %if.else.i.i73.i, %if.then18.i.i75.i
  %add20.sink.i.i66.i = phi i64 [ %add20.i.i76.i, %if.then18.i.i75.i ], [ %35, %if.else.i.i73.i ], [ %mul29.i.i64.i, %if.else27.i.i59.i ]
  store i64 %add20.sink.i.i66.i, ptr %GCthreshold.i39.i, align 8
  %.pre.i = load ptr, ptr %top.i.i, align 8
  br label %lua_createtable.exit.i

lua_createtable.exit.i:                           ; preds = %luaC_step.exit.i65.i, %lua_pushlstring.exit.i
  %38 = phi ptr [ %incdec.ptr.i.i36.i, %lua_pushlstring.exit.i ], [ %.pre.i, %luaC_step.exit.i65.i ]
  %call.i68.i = tail call fastcc ptr @luaH_new(ptr noundef nonnull %L, i32 noundef 0, i32 noundef 1)
  store ptr %call.i68.i, ptr %38, align 8
  %tt.i69.i = getelementptr inbounds %struct.lua_TValue, ptr %38, i64 0, i32 1
  store i32 5, ptr %tt.i69.i, align 8
  %39 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i70.i = getelementptr inbounds %struct.lua_TValue, ptr %39, i64 1
  store ptr %incdec.ptr.i70.i, ptr %top.i.i, align 8
  %40 = load i64, ptr %39, align 8
  store i64 %40, ptr %incdec.ptr.i70.i, align 8
  %tt.i78.i = getelementptr inbounds %struct.lua_TValue, ptr %39, i64 0, i32 1
  %41 = load i32, ptr %tt.i78.i, align 8
  %tt2.i79.i = getelementptr inbounds %struct.lua_TValue, ptr %39, i64 1, i32 1
  store i32 %41, ptr %tt2.i79.i, align 8
  %42 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i80.i = getelementptr inbounds %struct.lua_TValue, ptr %42, i64 1
  store ptr %incdec.ptr.i80.i, ptr %top.i.i, align 8
  tail call fastcc void @lua_setmetatable(ptr noundef nonnull %L, i32 noundef -2)
  %43 = load ptr, ptr %l_G.i.i, align 8
  %totalbytes.i82.i = getelementptr inbounds %struct.global_State, ptr %43, i64 0, i32 14
  %44 = load i64, ptr %totalbytes.i82.i, align 8
  %GCthreshold.i83.i = getelementptr inbounds %struct.global_State, ptr %43, i64 0, i32 13
  %45 = load i64, ptr %GCthreshold.i83.i, align 8
  %cmp.not.i84.i = icmp ult i64 %44, %45
  br i1 %cmp.not.i84.i, label %base_open.exit, label %if.then.i85.i

if.then.i85.i:                                    ; preds = %lua_createtable.exit.i
  %gcstepmul.i.i86.i = getelementptr inbounds %struct.global_State, ptr %43, i64 0, i32 18
  %46 = load i32, ptr %gcstepmul.i.i86.i, align 4
  %mul.i.i87.i = mul i32 %46, 10
  %conv.i.i88.i = zext i32 %mul.i.i87.i to i64
  %cmp.i.i89.i = icmp eq i32 %mul.i.i87.i, 0
  %spec.store.select.i.i90.i = select i1 %cmp.i.i89.i, i64 9223372036854775806, i64 %conv.i.i88.i
  %sub.i.i91.i = sub i64 %44, %45
  %gcdept.i.i92.i = getelementptr inbounds %struct.global_State, ptr %43, i64 0, i32 16
  %47 = load i64, ptr %gcdept.i.i92.i, align 8
  %add.i.i93.i = add i64 %sub.i.i91.i, %47
  store i64 %add.i.i93.i, ptr %gcdept.i.i92.i, align 8
  %gcstate.i.i94.i = getelementptr inbounds %struct.global_State, ptr %43, i64 0, i32 4
  br label %do.body.i.i95.i

do.body.i.i95.i:                                  ; preds = %do.body.i.i95.i, %if.then.i85.i
  %lim.0.i.i96.i = phi i64 [ %spec.store.select.i.i90.i, %if.then.i85.i ], [ %sub2.i.i98.i, %do.body.i.i95.i ]
  %call.i.i97.i = tail call fastcc i64 @singlestep(ptr noundef %L)
  %sub2.i.i98.i = sub nsw i64 %lim.0.i.i96.i, %call.i.i97.i
  %48 = load i8, ptr %gcstate.i.i94.i, align 1
  %cmp4.i.i99.i = icmp ne i8 %48, 0
  %cmp8.i.i100.i = icmp sgt i64 %sub2.i.i98.i, 0
  %or.cond.i.i101.i = select i1 %cmp4.i.i99.i, i1 %cmp8.i.i100.i, i1 false
  br i1 %or.cond.i.i101.i, label %do.body.i.i95.i, label %do.end.i.i102.i, !llvm.loop !6

do.end.i.i102.i:                                  ; preds = %do.body.i.i95.i
  br i1 %cmp4.i.i99.i, label %if.then14.i.i115.i, label %if.else27.i.i103.i

if.then14.i.i115.i:                               ; preds = %do.end.i.i102.i
  %49 = load i64, ptr %gcdept.i.i92.i, align 8
  %cmp16.i.i116.i = icmp ult i64 %49, 1024
  br i1 %cmp16.i.i116.i, label %if.then18.i.i119.i, label %if.else.i.i117.i

if.then18.i.i119.i:                               ; preds = %if.then14.i.i115.i
  %50 = load i64, ptr %totalbytes.i82.i, align 8
  %add20.i.i120.i = add i64 %50, 1024
  br label %luaC_step.exit.i109.i

if.else.i.i117.i:                                 ; preds = %if.then14.i.i115.i
  %sub23.i.i118.i = add i64 %49, -1024
  store i64 %sub23.i.i118.i, ptr %gcdept.i.i92.i, align 8
  %51 = load i64, ptr %totalbytes.i82.i, align 8
  br label %luaC_step.exit.i109.i

if.else27.i.i103.i:                               ; preds = %do.end.i.i102.i
  %estimate.i.i104.i = getelementptr inbounds %struct.global_State, ptr %43, i64 0, i32 15
  %52 = load i64, ptr %estimate.i.i104.i, align 8
  %div.i.i105.i = udiv i64 %52, 100
  %gcpause.i.i106.i = getelementptr inbounds %struct.global_State, ptr %43, i64 0, i32 17
  %53 = load i32, ptr %gcpause.i.i106.i, align 8
  %conv28.i.i107.i = sext i32 %53 to i64
  %mul29.i.i108.i = mul i64 %div.i.i105.i, %conv28.i.i107.i
  br label %luaC_step.exit.i109.i

luaC_step.exit.i109.i:                            ; preds = %if.else27.i.i103.i, %if.else.i.i117.i, %if.then18.i.i119.i
  %add20.sink.i.i110.i = phi i64 [ %add20.i.i120.i, %if.then18.i.i119.i ], [ %51, %if.else.i.i117.i ], [ %mul29.i.i108.i, %if.else27.i.i103.i ]
  store i64 %add20.sink.i.i110.i, ptr %GCthreshold.i83.i, align 8
  br label %base_open.exit

base_open.exit:                                   ; preds = %lua_createtable.exit.i, %luaC_step.exit.i109.i
  %54 = load ptr, ptr %top.i.i, align 8
  %call.i112.i = tail call fastcc ptr @luaS_newlstr(ptr noundef %L, ptr noundef nonnull @.str.99, i64 noundef 2)
  store ptr %call.i112.i, ptr %54, align 8
  %tt.i113.i = getelementptr inbounds %struct.lua_TValue, ptr %54, i64 0, i32 1
  store i32 4, ptr %tt.i113.i, align 8
  %55 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i114.i = getelementptr inbounds %struct.lua_TValue, ptr %55, i64 1
  store ptr %incdec.ptr.i114.i, ptr %top.i.i, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %key.i122.i)
  %add.ptr8.i.i124.i = getelementptr inbounds %struct.lua_TValue, ptr %55, i64 -1
  %call2.i126.i = tail call fastcc ptr @luaS_newlstr(ptr noundef %L, ptr noundef nonnull @.str.49, i64 noundef 6)
  store ptr %call2.i126.i, ptr %key.i122.i, align 8
  %tt.i127.i = getelementptr inbounds %struct.lua_TValue, ptr %key.i122.i, i64 0, i32 1
  store i32 4, ptr %tt.i127.i, align 8
  %56 = load ptr, ptr %top.i.i, align 8
  %add.ptr.i129.i = getelementptr inbounds %struct.lua_TValue, ptr %56, i64 -1
  call fastcc void @luaV_settable(ptr noundef %L, ptr noundef nonnull %add.ptr8.i.i124.i, ptr noundef nonnull %key.i122.i, ptr noundef nonnull %add.ptr.i129.i)
  %57 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i130.i = getelementptr inbounds %struct.lua_TValue, ptr %57, i64 -1
  store ptr %incdec.ptr.i130.i, ptr %top.i.i, align 8
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %key.i122.i)
  tail call fastcc void @lua_pushcclosure(ptr noundef %L, ptr noundef nonnull @luaB_newproxy, i32 noundef 1)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %key.i131.i)
  %call2.i134.i = tail call fastcc ptr @luaS_newlstr(ptr noundef %L, ptr noundef nonnull @.str.100, i64 noundef 8)
  store ptr %call2.i134.i, ptr %key.i131.i, align 8
  %tt.i135.i = getelementptr inbounds %struct.lua_TValue, ptr %key.i131.i, i64 0, i32 1
  store i32 4, ptr %tt.i135.i, align 8
  %58 = load ptr, ptr %top.i.i, align 8
  %add.ptr.i137.i = getelementptr inbounds %struct.lua_TValue, ptr %58, i64 -1
  call fastcc void @luaV_settable(ptr noundef %L, ptr noundef nonnull %l_gt.i.i.i, ptr noundef nonnull %key.i131.i, ptr noundef nonnull %add.ptr.i137.i)
  %59 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i138.i = getelementptr inbounds %struct.lua_TValue, ptr %59, i64 -1
  store ptr %incdec.ptr.i138.i, ptr %top.i.i, align 8
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %key.i131.i)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @luaopen_table(ptr noundef %L) #0 {
entry:
  tail call fastcc void @luaL_register(ptr noundef %L, ptr noundef nonnull @.str.26, ptr noundef nonnull @tab_funcs)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @luaopen_io(ptr noundef %L) #0 {
entry:
  %key.i = alloca %struct.lua_TValue, align 8
  %key.i61.i.i.i = alloca %struct.lua_TValue, align 8
  %key.i.i = alloca %struct.lua_TValue, align 8
  %key.i17.i.i = alloca %struct.lua_TValue, align 8
  %key.i.i.i = alloca %struct.lua_TValue, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %key.i.i.i)
  %l_G.i.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %0 = load ptr, ptr %l_G.i.i.i.i, align 8
  %l_registry.i.i.i.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 20
  %call2.i.i.i = tail call fastcc ptr @luaS_newlstr(ptr noundef %L, ptr noundef nonnull @.str.199, i64 noundef 5)
  store ptr %call2.i.i.i, ptr %key.i.i.i, align 8
  %tt.i.i.i = getelementptr inbounds %struct.lua_TValue, ptr %key.i.i.i, i64 0, i32 1
  store i32 4, ptr %tt.i.i.i, align 8
  %top.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i.i, align 8
  call fastcc void @luaV_gettable(ptr noundef %L, ptr noundef nonnull %l_registry.i.i.i.i, ptr noundef nonnull %key.i.i.i, ptr noundef %1)
  %2 = load ptr, ptr %top.i.i.i, align 8
  %incdec.ptr.i.i.i = getelementptr inbounds %struct.lua_TValue, ptr %2, i64 1
  store ptr %incdec.ptr.i.i.i, ptr %top.i.i.i, align 8
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %key.i.i.i)
  %cmp.i.i.i = icmp eq ptr %2, @luaO_nilobject_
  br i1 %cmp.i.i.i, label %luaL_newmetatable.exit.i, label %lua_type.exit.i.i

lua_type.exit.i.i:                                ; preds = %entry
  %tt.i7.i.i = getelementptr inbounds %struct.lua_TValue, ptr %2, i64 0, i32 1
  %3 = load i32, ptr %tt.i7.i.i, align 8
  %cmp.i.i = icmp eq i32 %3, 0
  br i1 %cmp.i.i, label %if.end.i.i, label %luaL_newmetatable.exit.i

if.end.i.i:                                       ; preds = %lua_type.exit.i.i
  store ptr %2, ptr %top.i.i.i, align 8
  %4 = load ptr, ptr %l_G.i.i.i.i, align 8
  %totalbytes.i.i.i = getelementptr inbounds %struct.global_State, ptr %4, i64 0, i32 14
  %5 = load i64, ptr %totalbytes.i.i.i, align 8
  %GCthreshold.i.i.i = getelementptr inbounds %struct.global_State, ptr %4, i64 0, i32 13
  %6 = load i64, ptr %GCthreshold.i.i.i, align 8
  %cmp.not.i.i.i = icmp ult i64 %5, %6
  br i1 %cmp.not.i.i.i, label %lua_createtable.exit.i.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %if.end.i.i
  %gcstepmul.i.i.i.i = getelementptr inbounds %struct.global_State, ptr %4, i64 0, i32 18
  %7 = load i32, ptr %gcstepmul.i.i.i.i, align 4
  %mul.i.i.i.i = mul i32 %7, 10
  %conv.i.i.i.i = zext i32 %mul.i.i.i.i to i64
  %cmp.i.i.i.i = icmp eq i32 %mul.i.i.i.i, 0
  %spec.store.select.i.i.i.i = select i1 %cmp.i.i.i.i, i64 9223372036854775806, i64 %conv.i.i.i.i
  %sub.i.i.i.i = sub i64 %5, %6
  %gcdept.i.i.i.i = getelementptr inbounds %struct.global_State, ptr %4, i64 0, i32 16
  %8 = load i64, ptr %gcdept.i.i.i.i, align 8
  %add.i.i.i.i = add i64 %sub.i.i.i.i, %8
  store i64 %add.i.i.i.i, ptr %gcdept.i.i.i.i, align 8
  %gcstate.i.i.i.i = getelementptr inbounds %struct.global_State, ptr %4, i64 0, i32 4
  br label %do.body.i.i.i.i

do.body.i.i.i.i:                                  ; preds = %do.body.i.i.i.i, %if.then.i.i.i
  %lim.0.i.i.i.i = phi i64 [ %spec.store.select.i.i.i.i, %if.then.i.i.i ], [ %sub2.i.i.i.i, %do.body.i.i.i.i ]
  %call.i.i.i.i = tail call fastcc i64 @singlestep(ptr noundef %L)
  %sub2.i.i.i.i = sub nsw i64 %lim.0.i.i.i.i, %call.i.i.i.i
  %9 = load i8, ptr %gcstate.i.i.i.i, align 1
  %cmp4.i.i.i.i = icmp ne i8 %9, 0
  %cmp8.i.i.i.i = icmp sgt i64 %sub2.i.i.i.i, 0
  %or.cond.i.i.i.i = select i1 %cmp4.i.i.i.i, i1 %cmp8.i.i.i.i, i1 false
  br i1 %or.cond.i.i.i.i, label %do.body.i.i.i.i, label %do.end.i.i.i.i, !llvm.loop !6

do.end.i.i.i.i:                                   ; preds = %do.body.i.i.i.i
  br i1 %cmp4.i.i.i.i, label %if.then14.i.i.i.i, label %if.else27.i.i.i.i

if.then14.i.i.i.i:                                ; preds = %do.end.i.i.i.i
  %10 = load i64, ptr %gcdept.i.i.i.i, align 8
  %cmp16.i.i.i.i = icmp ult i64 %10, 1024
  br i1 %cmp16.i.i.i.i, label %if.then18.i.i.i.i, label %if.else.i.i.i.i

if.then18.i.i.i.i:                                ; preds = %if.then14.i.i.i.i
  %11 = load i64, ptr %totalbytes.i.i.i, align 8
  %add20.i.i.i.i = add i64 %11, 1024
  br label %luaC_step.exit.i.i.i

if.else.i.i.i.i:                                  ; preds = %if.then14.i.i.i.i
  %sub23.i.i.i.i = add i64 %10, -1024
  store i64 %sub23.i.i.i.i, ptr %gcdept.i.i.i.i, align 8
  %12 = load i64, ptr %totalbytes.i.i.i, align 8
  br label %luaC_step.exit.i.i.i

if.else27.i.i.i.i:                                ; preds = %do.end.i.i.i.i
  %estimate.i.i.i.i = getelementptr inbounds %struct.global_State, ptr %4, i64 0, i32 15
  %13 = load i64, ptr %estimate.i.i.i.i, align 8
  %div.i.i.i.i = udiv i64 %13, 100
  %gcpause.i.i.i.i = getelementptr inbounds %struct.global_State, ptr %4, i64 0, i32 17
  %14 = load i32, ptr %gcpause.i.i.i.i, align 8
  %conv28.i.i.i.i = sext i32 %14 to i64
  %mul29.i.i.i.i = mul i64 %div.i.i.i.i, %conv28.i.i.i.i
  br label %luaC_step.exit.i.i.i

luaC_step.exit.i.i.i:                             ; preds = %if.else27.i.i.i.i, %if.else.i.i.i.i, %if.then18.i.i.i.i
  %add20.sink.i.i.i.i = phi i64 [ %add20.i.i.i.i, %if.then18.i.i.i.i ], [ %12, %if.else.i.i.i.i ], [ %mul29.i.i.i.i, %if.else27.i.i.i.i ]
  store i64 %add20.sink.i.i.i.i, ptr %GCthreshold.i.i.i, align 8
  %.pre.i.i = load ptr, ptr %top.i.i.i, align 8
  br label %lua_createtable.exit.i.i

lua_createtable.exit.i.i:                         ; preds = %luaC_step.exit.i.i.i, %if.end.i.i
  %15 = phi ptr [ %2, %if.end.i.i ], [ %.pre.i.i, %luaC_step.exit.i.i.i ]
  %call.i.i.i = tail call fastcc ptr @luaH_new(ptr noundef nonnull %L, i32 noundef 0, i32 noundef 0)
  store ptr %call.i.i.i, ptr %15, align 8
  %tt.i10.i.i = getelementptr inbounds %struct.lua_TValue, ptr %15, i64 0, i32 1
  store i32 5, ptr %tt.i10.i.i, align 8
  %16 = load ptr, ptr %top.i.i.i, align 8
  %incdec.ptr.i11.i.i = getelementptr inbounds %struct.lua_TValue, ptr %16, i64 1
  store ptr %incdec.ptr.i11.i.i, ptr %top.i.i.i, align 8
  %17 = load i64, ptr %16, align 8
  store i64 %17, ptr %incdec.ptr.i11.i.i, align 8
  %tt.i15.i.i = getelementptr inbounds %struct.lua_TValue, ptr %16, i64 0, i32 1
  %18 = load i32, ptr %tt.i15.i.i, align 8
  %tt2.i.i.i = getelementptr inbounds %struct.lua_TValue, ptr %16, i64 1, i32 1
  store i32 %18, ptr %tt2.i.i.i, align 8
  %19 = load ptr, ptr %top.i.i.i, align 8
  %incdec.ptr.i16.i.i = getelementptr inbounds %struct.lua_TValue, ptr %19, i64 1
  store ptr %incdec.ptr.i16.i.i, ptr %top.i.i.i, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %key.i17.i.i)
  %20 = load ptr, ptr %l_G.i.i.i.i, align 8
  %l_registry.i.i19.i.i = getelementptr inbounds %struct.global_State, ptr %20, i64 0, i32 20
  %call2.i21.i.i = tail call fastcc ptr @luaS_newlstr(ptr noundef nonnull %L, ptr noundef nonnull @.str.199, i64 noundef 5)
  store ptr %call2.i21.i.i, ptr %key.i17.i.i, align 8
  %tt.i22.i.i = getelementptr inbounds %struct.lua_TValue, ptr %key.i17.i.i, i64 0, i32 1
  store i32 4, ptr %tt.i22.i.i, align 8
  %21 = load ptr, ptr %top.i.i.i, align 8
  %add.ptr.i.i.i = getelementptr inbounds %struct.lua_TValue, ptr %21, i64 -1
  call fastcc void @luaV_settable(ptr noundef nonnull %L, ptr noundef nonnull %l_registry.i.i19.i.i, ptr noundef nonnull %key.i17.i.i, ptr noundef nonnull %add.ptr.i.i.i)
  %22 = load ptr, ptr %top.i.i.i, align 8
  %incdec.ptr.i24.i.i = getelementptr inbounds %struct.lua_TValue, ptr %22, i64 -1
  store ptr %incdec.ptr.i24.i.i, ptr %top.i.i.i, align 8
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %key.i17.i.i)
  br label %luaL_newmetatable.exit.i

luaL_newmetatable.exit.i:                         ; preds = %lua_createtable.exit.i.i, %lua_type.exit.i.i, %entry
  %23 = phi ptr [ %incdec.ptr.i.i.i, %entry ], [ %incdec.ptr.i.i.i, %lua_type.exit.i.i ], [ %incdec.ptr.i24.i.i, %lua_createtable.exit.i.i ]
  %add.ptr8.i.i.i = getelementptr inbounds %struct.lua_TValue, ptr %23, i64 -1
  %24 = load i64, ptr %add.ptr8.i.i.i, align 8
  store i64 %24, ptr %23, align 8
  %tt.i.i = getelementptr %struct.lua_TValue, ptr %23, i64 -1, i32 1
  %25 = load i32, ptr %tt.i.i, align 8
  %tt2.i.i = getelementptr inbounds %struct.lua_TValue, ptr %23, i64 0, i32 1
  store i32 %25, ptr %tt2.i.i, align 8
  %26 = load ptr, ptr %top.i.i.i, align 8
  %incdec.ptr.i.i = getelementptr inbounds %struct.lua_TValue, ptr %26, i64 1
  store ptr %incdec.ptr.i.i, ptr %top.i.i.i, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %key.i.i)
  %add.ptr8.i.i5.i = getelementptr inbounds %struct.lua_TValue, ptr %26, i64 -1
  %call2.i.i = tail call fastcc ptr @luaS_newlstr(ptr noundef nonnull %L, ptr noundef nonnull @.str.46, i64 noundef 7)
  store ptr %call2.i.i, ptr %key.i.i, align 8
  %tt.i6.i = getelementptr inbounds %struct.lua_TValue, ptr %key.i.i, i64 0, i32 1
  store i32 4, ptr %tt.i6.i, align 8
  %27 = load ptr, ptr %top.i.i.i, align 8
  %add.ptr.i.i = getelementptr inbounds %struct.lua_TValue, ptr %27, i64 -1
  call fastcc void @luaV_settable(ptr noundef nonnull %L, ptr noundef nonnull %add.ptr8.i.i5.i, ptr noundef nonnull %key.i.i, ptr noundef nonnull %add.ptr.i.i)
  %28 = load ptr, ptr %top.i.i.i, align 8
  %incdec.ptr.i8.i = getelementptr inbounds %struct.lua_TValue, ptr %28, i64 -1
  store ptr %incdec.ptr.i8.i, ptr %top.i.i.i, align 8
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %key.i.i)
  %tt.i66.i.i.i = getelementptr inbounds %struct.lua_TValue, ptr %key.i61.i.i.i, i64 0, i32 1
  br label %for.end.i.i.i

for.end.i.i.i:                                    ; preds = %for.end.i.i.i, %luaL_newmetatable.exit.i
  %l.addr.075.i.i.i = phi ptr [ @flib, %luaL_newmetatable.exit.i ], [ %incdec.ptr.i.i9.i, %for.end.i.i.i ]
  %func.i.i.i = getelementptr inbounds %struct.luaL_Reg, ptr %l.addr.075.i.i.i, i64 0, i32 1
  %29 = load ptr, ptr %func.i.i.i, align 8
  tail call fastcc void @lua_pushcclosure(ptr noundef nonnull %L, ptr noundef %29, i32 noundef 0)
  %30 = load ptr, ptr %l.addr.075.i.i.i, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %key.i61.i.i.i)
  %31 = load ptr, ptr %top.i.i.i, align 8
  %add.ptr8.i.i63.i.i.i = getelementptr inbounds %struct.lua_TValue, ptr %31, i64 -2
  %call1.i64.i.i.i = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %30) #34
  %call2.i65.i.i.i = tail call fastcc ptr @luaS_newlstr(ptr noundef nonnull %L, ptr noundef %30, i64 noundef %call1.i64.i.i.i)
  store ptr %call2.i65.i.i.i, ptr %key.i61.i.i.i, align 8
  store i32 4, ptr %tt.i66.i.i.i, align 8
  %32 = load ptr, ptr %top.i.i.i, align 8
  %add.ptr.i68.i.i.i = getelementptr inbounds %struct.lua_TValue, ptr %32, i64 -1
  call fastcc void @luaV_settable(ptr noundef nonnull %L, ptr noundef nonnull %add.ptr8.i.i63.i.i.i, ptr noundef nonnull %key.i61.i.i.i, ptr noundef nonnull %add.ptr.i68.i.i.i)
  %33 = load ptr, ptr %top.i.i.i, align 8
  %incdec.ptr.i69.i.i.i = getelementptr inbounds %struct.lua_TValue, ptr %33, i64 -1
  store ptr %incdec.ptr.i69.i.i.i, ptr %top.i.i.i, align 8
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %key.i61.i.i.i)
  %incdec.ptr.i.i9.i = getelementptr inbounds %struct.luaL_Reg, ptr %l.addr.075.i.i.i, i64 1
  %34 = load ptr, ptr %incdec.ptr.i.i9.i, align 8
  %tobool10.not.i.i.i = icmp eq ptr %34, null
  br i1 %tobool10.not.i.i.i, label %createmeta.exit, label %for.end.i.i.i, !llvm.loop !12

createmeta.exit:                                  ; preds = %for.end.i.i.i
  tail call fastcc void @newfenv(ptr noundef nonnull %L, ptr noundef nonnull @io_fclose)
  %ci.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %35 = load ptr, ptr %ci.i, align 8
  %base_ci.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 12
  %36 = load ptr, ptr %base_ci.i, align 8
  %cmp1.i = icmp eq ptr %35, %36
  br i1 %cmp1.i, label %if.then.i, label %if.then3.i

if.then.i:                                        ; preds = %createmeta.exit
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef nonnull %L, ptr noundef nonnull @.str.213)
  unreachable

if.then3.i:                                       ; preds = %createmeta.exit
  %func11.i.i = getelementptr inbounds %struct.CallInfo, ptr %35, i64 0, i32 1
  %37 = load ptr, ptr %func11.i.i, align 8
  %38 = load ptr, ptr %37, align 8
  %env.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23
  %env12.i.i = getelementptr inbounds %struct.CClosure, ptr %38, i64 0, i32 6
  %39 = load ptr, ptr %env12.i.i, align 8
  store ptr %39, ptr %env.i.i, align 8
  %tt.i.i13 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23, i32 1
  store i32 5, ptr %tt.i.i13, align 8
  %40 = load ptr, ptr %func11.i.i, align 8
  %41 = load ptr, ptr %40, align 8
  %42 = load ptr, ptr %top.i.i.i, align 8
  %add.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %42, i64 -1
  %43 = load ptr, ptr %add.ptr.i, align 8
  %env.i = getelementptr inbounds %struct.CClosure, ptr %41, i64 0, i32 6
  store ptr %43, ptr %env.i, align 8
  %44 = load ptr, ptr %top.i.i.i, align 8
  %tt.i = getelementptr %struct.lua_TValue, ptr %44, i64 -1, i32 1
  %45 = load i32, ptr %tt.i, align 8
  %cmp9.i = icmp sgt i32 %45, 3
  br i1 %cmp9.i, label %land.lhs.true10.i, label %lua_replace.exit

land.lhs.true10.i:                                ; preds = %if.then3.i
  %add.ptr8.i = getelementptr inbounds %struct.lua_TValue, ptr %44, i64 -1
  %46 = load ptr, ptr %add.ptr8.i, align 8
  %marked.i = getelementptr inbounds %struct.GCheader, ptr %46, i64 0, i32 2
  %47 = load i8, ptr %marked.i, align 1
  %48 = and i8 %47, 3
  %tobool.not.i = icmp eq i8 %48, 0
  br i1 %tobool.not.i, label %lua_replace.exit, label %land.lhs.true14.i

land.lhs.true14.i:                                ; preds = %land.lhs.true10.i
  %marked15.i = getelementptr inbounds %struct.GCheader, ptr %41, i64 0, i32 2
  %49 = load i8, ptr %marked15.i, align 1
  %50 = and i8 %49, 4
  %tobool18.not.i = icmp eq i8 %50, 0
  br i1 %tobool18.not.i, label %lua_replace.exit, label %if.then19.i

if.then19.i:                                      ; preds = %land.lhs.true14.i
  %L.val25.i = load ptr, ptr %l_G.i.i.i.i, align 8
  %gcstate.i.i = getelementptr inbounds %struct.global_State, ptr %L.val25.i, i64 0, i32 4
  %51 = load i8, ptr %gcstate.i.i, align 1
  %cmp.i26.i = icmp eq i8 %51, 1
  br i1 %cmp.i26.i, label %if.then.i27.i, label %if.else.i.i

if.then.i27.i:                                    ; preds = %if.then19.i
  tail call fastcc void @reallymarkobject(ptr noundef nonnull %L.val25.i, ptr noundef nonnull %46)
  br label %lua_replace.exit

if.else.i.i:                                      ; preds = %if.then19.i
  %52 = and i8 %49, -8
  %currentwhite.i.i = getelementptr inbounds %struct.global_State, ptr %L.val25.i, i64 0, i32 3
  %53 = load i8, ptr %currentwhite.i.i, align 8
  %54 = and i8 %53, 3
  %or4.i.i = or disjoint i8 %54, %52
  store i8 %or4.i.i, ptr %marked15.i, align 1
  br label %lua_replace.exit

lua_replace.exit:                                 ; preds = %if.then3.i, %land.lhs.true10.i, %land.lhs.true14.i, %if.then.i27.i, %if.else.i.i
  %55 = load ptr, ptr %top.i.i.i, align 8
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %55, i64 -1
  store ptr %incdec.ptr.i, ptr %top.i.i.i, align 8
  tail call fastcc void @luaL_register(ptr noundef nonnull %L, ptr noundef nonnull @.str.92, ptr noundef nonnull @iolib)
  tail call fastcc void @newfenv(ptr noundef nonnull %L, ptr noundef nonnull @io_noclose)
  %56 = load ptr, ptr @stdin, align 8
  tail call fastcc void @createstdfile(ptr noundef nonnull %L, ptr noundef %56, i32 noundef 1, ptr noundef nonnull @.str.195)
  %57 = load ptr, ptr @stdout, align 8
  tail call fastcc void @createstdfile(ptr noundef nonnull %L, ptr noundef %57, i32 noundef 2, ptr noundef nonnull @.str.196)
  %58 = load ptr, ptr @stderr, align 8
  tail call fastcc void @createstdfile(ptr noundef nonnull %L, ptr noundef %58, i32 noundef 0, ptr noundef nonnull @.str.197)
  %59 = load ptr, ptr %top.i.i.i, align 8
  %add.ptr9.i = getelementptr %struct.lua_TValue, ptr %59, i64 -1
  store ptr %add.ptr9.i, ptr %top.i.i.i, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %key.i)
  %add.ptr8.i.i = getelementptr %struct.lua_TValue, ptr %59, i64 -2
  %call2.i = tail call fastcc ptr @luaS_newlstr(ptr noundef nonnull %L, ptr noundef nonnull @.str.198, i64 noundef 5)
  store ptr %call2.i, ptr %key.i, align 8
  %tt.i15 = getelementptr inbounds %struct.lua_TValue, ptr %key.i, i64 0, i32 1
  store i32 4, ptr %tt.i15, align 8
  %60 = load ptr, ptr %top.i.i.i, align 8
  call fastcc void @luaV_gettable(ptr noundef nonnull %L, ptr noundef nonnull %add.ptr8.i.i, ptr noundef nonnull %key.i, ptr noundef %60)
  %61 = load ptr, ptr %top.i.i.i, align 8
  %incdec.ptr.i17 = getelementptr inbounds %struct.lua_TValue, ptr %61, i64 1
  store ptr %incdec.ptr.i17, ptr %top.i.i.i, align 8
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %key.i)
  tail call fastcc void @newfenv(ptr noundef nonnull %L, ptr noundef nonnull @io_pclose)
  %62 = load ptr, ptr %top.i.i.i, align 8
  %add.ptr8.i.i19 = getelementptr inbounds %struct.lua_TValue, ptr %62, i64 -2
  %tt.i20 = getelementptr %struct.lua_TValue, ptr %62, i64 -2, i32 1
  %63 = load i32, ptr %tt.i20, align 8
  switch i32 %63, label %lua_setfenv.exit [
    i32 6, label %sw.bb.i
    i32 7, label %sw.bb2.i
    i32 8, label %sw.bb8.i
  ]

sw.bb.i:                                          ; preds = %lua_replace.exit
  %add.ptr.i30 = getelementptr inbounds %struct.lua_TValue, ptr %62, i64 -1
  %64 = load ptr, ptr %add.ptr.i30, align 8
  %65 = load ptr, ptr %add.ptr8.i.i19, align 8
  %env.i31 = getelementptr inbounds %struct.CClosure, ptr %65, i64 0, i32 6
  store ptr %64, ptr %env.i31, align 8
  br label %if.then.i21

sw.bb2.i:                                         ; preds = %lua_replace.exit
  %add.ptr4.i = getelementptr inbounds %struct.lua_TValue, ptr %62, i64 -1
  %66 = load ptr, ptr %add.ptr4.i, align 8
  %67 = load ptr, ptr %add.ptr8.i.i19, align 8
  %env7.i = getelementptr inbounds %struct.anon.1, ptr %67, i64 0, i32 4
  store ptr %66, ptr %env7.i, align 8
  br label %if.then.i21

sw.bb8.i:                                         ; preds = %lua_replace.exit
  %68 = load ptr, ptr %add.ptr8.i.i19, align 8
  %l_gt.i = getelementptr inbounds %struct.lua_State, ptr %68, i64 0, i32 22
  %add.ptr11.i = getelementptr inbounds %struct.lua_TValue, ptr %62, i64 -1
  %69 = load ptr, ptr %add.ptr11.i, align 8
  store ptr %69, ptr %l_gt.i, align 8
  %tt14.i = getelementptr inbounds %struct.lua_State, ptr %68, i64 0, i32 22, i32 1
  store i32 5, ptr %tt14.i, align 8
  br label %if.then.i21

if.then.i21:                                      ; preds = %sw.bb8.i, %sw.bb2.i, %sw.bb.i
  %70 = load ptr, ptr %top.i.i.i, align 8
  %add.ptr16.i = getelementptr inbounds %struct.lua_TValue, ptr %70, i64 -1
  %71 = load ptr, ptr %add.ptr16.i, align 8
  %marked.i22 = getelementptr inbounds %struct.GCheader, ptr %71, i64 0, i32 2
  %72 = load i8, ptr %marked.i22, align 1
  %73 = and i8 %72, 3
  %tobool18.not.i23 = icmp eq i8 %73, 0
  br i1 %tobool18.not.i23, label %lua_setfenv.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.then.i21
  %74 = load ptr, ptr %add.ptr8.i.i19, align 8
  %marked20.i = getelementptr inbounds %struct.GCheader, ptr %74, i64 0, i32 2
  %75 = load i8, ptr %marked20.i, align 1
  %76 = and i8 %75, 4
  %tobool23.not.i = icmp eq i8 %76, 0
  br i1 %tobool23.not.i, label %lua_setfenv.exit, label %if.then24.i

if.then24.i:                                      ; preds = %land.lhs.true.i
  %L.val.i = load ptr, ptr %l_G.i.i.i.i, align 8
  %gcstate.i.i24 = getelementptr inbounds %struct.global_State, ptr %L.val.i, i64 0, i32 4
  %77 = load i8, ptr %gcstate.i.i24, align 1
  %cmp.i.i25 = icmp eq i8 %77, 1
  br i1 %cmp.i.i25, label %if.then.i.i, label %if.else.i.i26

if.then.i.i:                                      ; preds = %if.then24.i
  tail call fastcc void @reallymarkobject(ptr noundef nonnull %L.val.i, ptr noundef nonnull %71)
  br label %lua_setfenv.exit

if.else.i.i26:                                    ; preds = %if.then24.i
  %78 = and i8 %75, -8
  %currentwhite.i.i27 = getelementptr inbounds %struct.global_State, ptr %L.val.i, i64 0, i32 3
  %79 = load i8, ptr %currentwhite.i.i27, align 8
  %80 = and i8 %79, 3
  %or4.i.i28 = or disjoint i8 %80, %78
  store i8 %or4.i.i28, ptr %marked20.i, align 1
  br label %lua_setfenv.exit

lua_setfenv.exit:                                 ; preds = %lua_replace.exit, %if.then.i21, %land.lhs.true.i, %if.then.i.i, %if.else.i.i26
  %81 = load ptr, ptr %top.i.i.i, align 8
  %add.ptr9.i33 = getelementptr %struct.lua_TValue, ptr %81, i64 -2
  store ptr %add.ptr9.i33, ptr %top.i.i.i, align 8
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @luaopen_os(ptr noundef %L) #0 {
entry:
  tail call fastcc void @luaL_register(ptr noundef %L, ptr noundef nonnull @.str.93, ptr noundef nonnull @syslib)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @luaopen_string(ptr noundef %L) #0 {
entry:
  %key.i.i = alloca %struct.lua_TValue, align 8
  tail call fastcc void @luaL_register(ptr noundef %L, ptr noundef nonnull @.str.25, ptr noundef nonnull @strlib)
  %l_G.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %0 = load ptr, ptr %l_G.i.i, align 8
  %totalbytes.i.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 14
  %1 = load i64, ptr %totalbytes.i.i, align 8
  %GCthreshold.i.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 13
  %2 = load i64, ptr %GCthreshold.i.i, align 8
  %cmp.not.i.i = icmp ult i64 %1, %2
  br i1 %cmp.not.i.i, label %lua_createtable.exit.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %entry
  %gcstepmul.i.i.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 18
  %3 = load i32, ptr %gcstepmul.i.i.i, align 4
  %mul.i.i.i = mul i32 %3, 10
  %conv.i.i.i = zext i32 %mul.i.i.i to i64
  %cmp.i.i.i = icmp eq i32 %mul.i.i.i, 0
  %spec.store.select.i.i.i = select i1 %cmp.i.i.i, i64 9223372036854775806, i64 %conv.i.i.i
  %sub.i.i.i = sub i64 %1, %2
  %gcdept.i.i.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 16
  %4 = load i64, ptr %gcdept.i.i.i, align 8
  %add.i.i.i = add i64 %sub.i.i.i, %4
  store i64 %add.i.i.i, ptr %gcdept.i.i.i, align 8
  %gcstate.i.i.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 4
  br label %do.body.i.i.i

do.body.i.i.i:                                    ; preds = %do.body.i.i.i, %if.then.i.i
  %lim.0.i.i.i = phi i64 [ %spec.store.select.i.i.i, %if.then.i.i ], [ %sub2.i.i.i, %do.body.i.i.i ]
  %call.i.i.i = tail call fastcc i64 @singlestep(ptr noundef %L)
  %sub2.i.i.i = sub nsw i64 %lim.0.i.i.i, %call.i.i.i
  %5 = load i8, ptr %gcstate.i.i.i, align 1
  %cmp4.i.i.i = icmp ne i8 %5, 0
  %cmp8.i.i.i = icmp sgt i64 %sub2.i.i.i, 0
  %or.cond.i.i.i = select i1 %cmp4.i.i.i, i1 %cmp8.i.i.i, i1 false
  br i1 %or.cond.i.i.i, label %do.body.i.i.i, label %do.end.i.i.i, !llvm.loop !6

do.end.i.i.i:                                     ; preds = %do.body.i.i.i
  br i1 %cmp4.i.i.i, label %if.then14.i.i.i, label %if.else27.i.i.i

if.then14.i.i.i:                                  ; preds = %do.end.i.i.i
  %6 = load i64, ptr %gcdept.i.i.i, align 8
  %cmp16.i.i.i = icmp ult i64 %6, 1024
  br i1 %cmp16.i.i.i, label %if.then18.i.i.i, label %if.else.i.i.i

if.then18.i.i.i:                                  ; preds = %if.then14.i.i.i
  %7 = load i64, ptr %totalbytes.i.i, align 8
  %add20.i.i.i = add i64 %7, 1024
  br label %luaC_step.exit.i.i

if.else.i.i.i:                                    ; preds = %if.then14.i.i.i
  %sub23.i.i.i = add i64 %6, -1024
  store i64 %sub23.i.i.i, ptr %gcdept.i.i.i, align 8
  %8 = load i64, ptr %totalbytes.i.i, align 8
  br label %luaC_step.exit.i.i

if.else27.i.i.i:                                  ; preds = %do.end.i.i.i
  %estimate.i.i.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 15
  %9 = load i64, ptr %estimate.i.i.i, align 8
  %div.i.i.i = udiv i64 %9, 100
  %gcpause.i.i.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 17
  %10 = load i32, ptr %gcpause.i.i.i, align 8
  %conv28.i.i.i = sext i32 %10 to i64
  %mul29.i.i.i = mul i64 %div.i.i.i, %conv28.i.i.i
  br label %luaC_step.exit.i.i

luaC_step.exit.i.i:                               ; preds = %if.else27.i.i.i, %if.else.i.i.i, %if.then18.i.i.i
  %add20.sink.i.i.i = phi i64 [ %add20.i.i.i, %if.then18.i.i.i ], [ %8, %if.else.i.i.i ], [ %mul29.i.i.i, %if.else27.i.i.i ]
  store i64 %add20.sink.i.i.i, ptr %GCthreshold.i.i, align 8
  br label %lua_createtable.exit.i

lua_createtable.exit.i:                           ; preds = %luaC_step.exit.i.i, %entry
  %top.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %11 = load ptr, ptr %top.i.i, align 8
  %call.i.i = tail call fastcc ptr @luaH_new(ptr noundef %L, i32 noundef 0, i32 noundef 1)
  store ptr %call.i.i, ptr %11, align 8
  %tt.i.i = getelementptr inbounds %struct.lua_TValue, ptr %11, i64 0, i32 1
  store i32 5, ptr %tt.i.i, align 8
  %12 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i.i = getelementptr inbounds %struct.lua_TValue, ptr %12, i64 1
  store ptr %incdec.ptr.i.i, ptr %top.i.i, align 8
  %13 = load ptr, ptr %l_G.i.i, align 8
  %totalbytes.i9.i = getelementptr inbounds %struct.global_State, ptr %13, i64 0, i32 14
  %14 = load i64, ptr %totalbytes.i9.i, align 8
  %GCthreshold.i10.i = getelementptr inbounds %struct.global_State, ptr %13, i64 0, i32 13
  %15 = load i64, ptr %GCthreshold.i10.i, align 8
  %cmp.not.i11.i = icmp ult i64 %14, %15
  br i1 %cmp.not.i11.i, label %createmetatable.exit, label %if.then.i12.i

if.then.i12.i:                                    ; preds = %lua_createtable.exit.i
  %gcstepmul.i.i13.i = getelementptr inbounds %struct.global_State, ptr %13, i64 0, i32 18
  %16 = load i32, ptr %gcstepmul.i.i13.i, align 4
  %mul.i.i14.i = mul i32 %16, 10
  %conv.i.i15.i = zext i32 %mul.i.i14.i to i64
  %cmp.i.i16.i = icmp eq i32 %mul.i.i14.i, 0
  %spec.store.select.i.i17.i = select i1 %cmp.i.i16.i, i64 9223372036854775806, i64 %conv.i.i15.i
  %sub.i.i18.i = sub i64 %14, %15
  %gcdept.i.i19.i = getelementptr inbounds %struct.global_State, ptr %13, i64 0, i32 16
  %17 = load i64, ptr %gcdept.i.i19.i, align 8
  %add.i.i20.i = add i64 %sub.i.i18.i, %17
  store i64 %add.i.i20.i, ptr %gcdept.i.i19.i, align 8
  %gcstate.i.i21.i = getelementptr inbounds %struct.global_State, ptr %13, i64 0, i32 4
  br label %do.body.i.i22.i

do.body.i.i22.i:                                  ; preds = %do.body.i.i22.i, %if.then.i12.i
  %lim.0.i.i23.i = phi i64 [ %spec.store.select.i.i17.i, %if.then.i12.i ], [ %sub2.i.i25.i, %do.body.i.i22.i ]
  %call.i.i24.i = tail call fastcc i64 @singlestep(ptr noundef %L)
  %sub2.i.i25.i = sub nsw i64 %lim.0.i.i23.i, %call.i.i24.i
  %18 = load i8, ptr %gcstate.i.i21.i, align 1
  %cmp4.i.i26.i = icmp ne i8 %18, 0
  %cmp8.i.i27.i = icmp sgt i64 %sub2.i.i25.i, 0
  %or.cond.i.i28.i = select i1 %cmp4.i.i26.i, i1 %cmp8.i.i27.i, i1 false
  br i1 %or.cond.i.i28.i, label %do.body.i.i22.i, label %do.end.i.i29.i, !llvm.loop !6

do.end.i.i29.i:                                   ; preds = %do.body.i.i22.i
  br i1 %cmp4.i.i26.i, label %if.then14.i.i42.i, label %if.else27.i.i30.i

if.then14.i.i42.i:                                ; preds = %do.end.i.i29.i
  %19 = load i64, ptr %gcdept.i.i19.i, align 8
  %cmp16.i.i43.i = icmp ult i64 %19, 1024
  br i1 %cmp16.i.i43.i, label %if.then18.i.i46.i, label %if.else.i.i44.i

if.then18.i.i46.i:                                ; preds = %if.then14.i.i42.i
  %20 = load i64, ptr %totalbytes.i9.i, align 8
  %add20.i.i47.i = add i64 %20, 1024
  br label %luaC_step.exit.i36.i

if.else.i.i44.i:                                  ; preds = %if.then14.i.i42.i
  %sub23.i.i45.i = add i64 %19, -1024
  store i64 %sub23.i.i45.i, ptr %gcdept.i.i19.i, align 8
  %21 = load i64, ptr %totalbytes.i9.i, align 8
  br label %luaC_step.exit.i36.i

if.else27.i.i30.i:                                ; preds = %do.end.i.i29.i
  %estimate.i.i31.i = getelementptr inbounds %struct.global_State, ptr %13, i64 0, i32 15
  %22 = load i64, ptr %estimate.i.i31.i, align 8
  %div.i.i32.i = udiv i64 %22, 100
  %gcpause.i.i33.i = getelementptr inbounds %struct.global_State, ptr %13, i64 0, i32 17
  %23 = load i32, ptr %gcpause.i.i33.i, align 8
  %conv28.i.i34.i = sext i32 %23 to i64
  %mul29.i.i35.i = mul i64 %div.i.i32.i, %conv28.i.i34.i
  br label %luaC_step.exit.i36.i

luaC_step.exit.i36.i:                             ; preds = %if.else27.i.i30.i, %if.else.i.i44.i, %if.then18.i.i46.i
  %add20.sink.i.i37.i = phi i64 [ %add20.i.i47.i, %if.then18.i.i46.i ], [ %21, %if.else.i.i44.i ], [ %mul29.i.i35.i, %if.else27.i.i30.i ]
  store i64 %add20.sink.i.i37.i, ptr %GCthreshold.i10.i, align 8
  %.pre.i = load ptr, ptr %top.i.i, align 8
  br label %createmetatable.exit

createmetatable.exit:                             ; preds = %lua_createtable.exit.i, %luaC_step.exit.i36.i
  %24 = phi ptr [ %incdec.ptr.i.i, %lua_createtable.exit.i ], [ %.pre.i, %luaC_step.exit.i36.i ]
  %call.i39.i = tail call fastcc ptr @luaS_newlstr(ptr noundef nonnull %L, ptr noundef nonnull @.str.7, i64 noundef 0)
  store ptr %call.i39.i, ptr %24, align 8
  %tt.i40.i = getelementptr inbounds %struct.lua_TValue, ptr %24, i64 0, i32 1
  store i32 4, ptr %tt.i40.i, align 8
  %25 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i41.i = getelementptr inbounds %struct.lua_TValue, ptr %25, i64 1
  store ptr %incdec.ptr.i41.i, ptr %top.i.i, align 8
  %add.ptr8.i.i.i = getelementptr inbounds %struct.lua_TValue, ptr %25, i64 -1
  %26 = load i64, ptr %add.ptr8.i.i.i, align 8
  store i64 %26, ptr %incdec.ptr.i41.i, align 8
  %tt.i49.i = getelementptr %struct.lua_TValue, ptr %25, i64 -1, i32 1
  %27 = load i32, ptr %tt.i49.i, align 8
  %tt2.i.i = getelementptr inbounds %struct.lua_TValue, ptr %25, i64 1, i32 1
  store i32 %27, ptr %tt2.i.i, align 8
  %28 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i50.i = getelementptr inbounds %struct.lua_TValue, ptr %28, i64 1
  store ptr %incdec.ptr.i50.i, ptr %top.i.i, align 8
  tail call fastcc void @lua_setmetatable(ptr noundef nonnull %L, i32 noundef -2)
  %29 = load ptr, ptr %top.i.i, align 8
  %add.ptr9.i.i = getelementptr %struct.lua_TValue, ptr %29, i64 -1
  store ptr %add.ptr9.i.i, ptr %top.i.i, align 8
  %add.ptr8.i.i53.i = getelementptr %struct.lua_TValue, ptr %29, i64 -3
  %30 = load i64, ptr %add.ptr8.i.i53.i, align 8
  store i64 %30, ptr %add.ptr9.i.i, align 8
  %tt.i55.i = getelementptr %struct.lua_TValue, ptr %29, i64 -3, i32 1
  %31 = load i32, ptr %tt.i55.i, align 8
  %tt2.i56.i = getelementptr %struct.lua_TValue, ptr %29, i64 -1, i32 1
  store i32 %31, ptr %tt2.i56.i, align 8
  %32 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i57.i = getelementptr inbounds %struct.lua_TValue, ptr %32, i64 1
  store ptr %incdec.ptr.i57.i, ptr %top.i.i, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %key.i.i)
  %add.ptr8.i.i59.i = getelementptr inbounds %struct.lua_TValue, ptr %32, i64 -1
  %call2.i.i = tail call fastcc ptr @luaS_newlstr(ptr noundef nonnull %L, ptr noundef nonnull @.str.46, i64 noundef 7)
  store ptr %call2.i.i, ptr %key.i.i, align 8
  %tt.i60.i = getelementptr inbounds %struct.lua_TValue, ptr %key.i.i, i64 0, i32 1
  store i32 4, ptr %tt.i60.i, align 8
  %33 = load ptr, ptr %top.i.i, align 8
  %add.ptr.i.i = getelementptr inbounds %struct.lua_TValue, ptr %33, i64 -1
  call fastcc void @luaV_settable(ptr noundef nonnull %L, ptr noundef nonnull %add.ptr8.i.i59.i, ptr noundef nonnull %key.i.i, ptr noundef nonnull %add.ptr.i.i)
  %34 = load ptr, ptr %top.i.i, align 8
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %key.i.i)
  %add.ptr9.i64.i = getelementptr %struct.lua_TValue, ptr %34, i64 -2
  store ptr %add.ptr9.i64.i, ptr %top.i.i, align 8
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_ipairs(ptr noundef %L) #0 {
entry:
  %base.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i.i, align 8
  %top.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i.i = icmp uge ptr %0, %1
  %cmp.i.i = icmp eq ptr %0, @luaO_nilobject_
  %or.cond = or i1 %cmp.i.i, %cmp1.not.i.i.i
  br i1 %or.cond, label %if.then.i, label %lua_type.exit.i

lua_type.exit.i:                                  ; preds = %entry
  %tt.i.i = getelementptr inbounds %struct.lua_TValue, ptr %0, i64 0, i32 1
  %2 = load i32, ptr %tt.i.i, align 8
  %cmp.not.i = icmp eq i32 %2, 5
  br i1 %cmp.not.i, label %luaL_checktype.exit, label %if.then.i

if.then.i:                                        ; preds = %entry, %lua_type.exit.i
  tail call fastcc void @luaL_typerror(ptr noundef nonnull %L, i32 noundef 1, ptr noundef nonnull @.str.26)
  unreachable

luaL_checktype.exit:                              ; preds = %lua_type.exit.i
  %ci17.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %3 = load ptr, ptr %ci17.i.i, align 8
  %func18.i.i = getelementptr inbounds %struct.CallInfo, ptr %3, i64 0, i32 1
  %4 = load ptr, ptr %func18.i.i, align 8
  %5 = load ptr, ptr %4, align 8
  %nupvalues.i.i = getelementptr inbounds %struct.CClosure, ptr %5, i64 0, i32 4
  %6 = load i8, ptr %nupvalues.i.i, align 1
  %cmp21.not.i.i = icmp eq i8 %6, 0
  %arrayidx.i.i = getelementptr inbounds %struct.CClosure, ptr %5, i64 0, i32 8, i64 0
  %cond.i.i4 = select i1 %cmp21.not.i.i, ptr @luaO_nilobject_, ptr %arrayidx.i.i
  %7 = load i64, ptr %cond.i.i4, align 8
  store i64 %7, ptr %1, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %cond.i.i4, i64 0, i32 1
  %8 = load i32, ptr %tt.i, align 8
  %tt2.i = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 0, i32 1
  store i32 %8, ptr %tt2.i, align 8
  %9 = load ptr, ptr %top.i.i.i, align 8
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %9, i64 1
  store ptr %incdec.ptr.i, ptr %top.i.i.i, align 8
  %10 = load ptr, ptr %base.i.i.i, align 8
  %cmp1.not.i.i = icmp ult ptr %10, %incdec.ptr.i
  %add.ptr.luaO_nilobject_.i.i = select i1 %cmp1.not.i.i, ptr %10, ptr @luaO_nilobject_
  %11 = load i64, ptr %add.ptr.luaO_nilobject_.i.i, align 8
  store i64 %11, ptr %incdec.ptr.i, align 8
  %tt.i6 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i, i64 0, i32 1
  %12 = load i32, ptr %tt.i6, align 8
  %tt2.i7 = getelementptr inbounds %struct.lua_TValue, ptr %9, i64 1, i32 1
  store i32 %12, ptr %tt2.i7, align 8
  %13 = load ptr, ptr %top.i.i.i, align 8
  %incdec.ptr.i8 = getelementptr inbounds %struct.lua_TValue, ptr %13, i64 1
  store ptr %incdec.ptr.i8, ptr %top.i.i.i, align 8
  store double 0.000000e+00, ptr %incdec.ptr.i8, align 8
  %tt.i10 = getelementptr inbounds %struct.lua_TValue, ptr %13, i64 1, i32 1
  store i32 3, ptr %tt.i10, align 8
  %14 = load ptr, ptr %top.i.i.i, align 8
  %incdec.ptr.i11 = getelementptr inbounds %struct.lua_TValue, ptr %14, i64 1
  store ptr %incdec.ptr.i11, ptr %top.i.i.i, align 8
  ret i32 3
}

; Function Attrs: nounwind uwtable
define internal i32 @ipairsaux(ptr noundef %L) #0 {
entry:
  %endptr.i.i.i = alloca ptr, align 8
  %call.i = tail call fastcc i64 @lua_tointeger(ptr noundef %L, i32 noundef 2)
  %cmp.i = icmp eq i64 %call.i, 0
  br i1 %cmp.i, label %land.lhs.true.i, label %luaL_checkinteger.exit

land.lhs.true.i:                                  ; preds = %entry
  %base.i.i14 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i14, align 8
  %add.ptr.i.i15 = getelementptr %struct.lua_TValue, ptr %0, i64 1
  %top.i.i16 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i16, align 8
  %cmp1.not.i.i17 = icmp ult ptr %add.ptr.i.i15, %1
  %add.ptr.luaO_nilobject_.i.i18 = select i1 %cmp1.not.i.i17, ptr %add.ptr.i.i15, ptr @luaO_nilobject_
  %tt.i19 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i18, i64 0, i32 1
  %2 = load i32, ptr %tt.i19, align 8
  switch i32 %2, label %if.then.i [
    i32 3, label %luaL_checkinteger.exit
    i32 4, label %land.lhs.true.i.i20
  ]

land.lhs.true.i.i20:                              ; preds = %land.lhs.true.i
  %3 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i18, align 8
  %add.ptr.i3.i = getelementptr inbounds %union.TString, ptr %3, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i.i)
  %call.i.i.i = call double @strtod(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i) #35
  %4 = load ptr, ptr %endptr.i.i.i, align 8
  %cmp.i.i.i21 = icmp eq ptr %4, %add.ptr.i3.i
  br i1 %cmp.i.i.i21, label %luaO_str2d.exit.thread.i.i, label %if.end.i.i.i22

luaO_str2d.exit.thread.i.i:                       ; preds = %land.lhs.true.i.i20
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %if.then.i

if.end.i.i.i22:                                   ; preds = %land.lhs.true.i.i20
  %5 = load i8, ptr %4, align 1
  switch i8 %5, label %if.end9.i.i.i [
    i8 120, label %if.then6.i.i.i
    i8 88, label %if.then6.i.i.i
  ]

if.then6.i.i.i:                                   ; preds = %if.end.i.i.i22, %if.end.i.i.i22
  %call7.i.i.i = call i64 @strtoul(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i, i32 noundef 16) #35
  %.pre.i.i.i = load ptr, ptr %endptr.i.i.i, align 8
  %.pre5.i.i.i = load i8, ptr %.pre.i.i.i, align 1
  br label %if.end9.i.i.i

if.end9.i.i.i:                                    ; preds = %if.then6.i.i.i, %if.end.i.i.i22
  %6 = phi i8 [ %5, %if.end.i.i.i22 ], [ %.pre5.i.i.i, %if.then6.i.i.i ]
  %endptr.promoted.i.i.i = phi ptr [ %4, %if.end.i.i.i22 ], [ %.pre.i.i.i, %if.then6.i.i.i ]
  %cmp11.i.i.i = icmp eq i8 %6, 0
  br i1 %cmp11.i.i.i, label %luaO_str2d.exit.thread9.i.i, label %while.cond.preheader.i.i.i

luaO_str2d.exit.thread9.i.i:                      ; preds = %if.end9.i.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %luaL_checkinteger.exit

while.cond.preheader.i.i.i:                       ; preds = %if.end9.i.i.i
  %call15.i.i.i = tail call ptr @__ctype_b_loc() #39
  %7 = load ptr, ptr %call15.i.i.i, align 8
  br label %while.cond.i.i.i

while.cond.i.i.i:                                 ; preds = %while.cond.i.i.i, %while.cond.preheader.i.i.i
  %incdec.ptr4.i.i.i = phi ptr [ %endptr.promoted.i.i.i, %while.cond.preheader.i.i.i ], [ %incdec.ptr.i.i.i, %while.cond.i.i.i ]
  %8 = load i8, ptr %incdec.ptr4.i.i.i, align 1
  %idxprom.i.i.i = zext i8 %8 to i64
  %arrayidx.i.i.i = getelementptr inbounds i16, ptr %7, i64 %idxprom.i.i.i
  %9 = load i16, ptr %arrayidx.i.i.i, align 2
  %10 = and i16 %9, 8192
  %tobool.not.i.i.i = icmp eq i16 %10, 0
  %incdec.ptr.i.i.i = getelementptr inbounds i8, ptr %incdec.ptr4.i.i.i, i64 1
  br i1 %tobool.not.i.i.i, label %luaO_str2d.exit.i.i, label %while.cond.i.i.i, !llvm.loop !35

luaO_str2d.exit.i.i:                              ; preds = %while.cond.i.i.i
  %cmp19.not.i.not.i.i = icmp eq i8 %8, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br i1 %cmp19.not.i.not.i.i, label %luaL_checkinteger.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true.i, %luaO_str2d.exit.i.i, %luaO_str2d.exit.thread.i.i
  tail call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 2, ptr noundef nonnull @.str.24)
  unreachable

luaL_checkinteger.exit:                           ; preds = %luaO_str2d.exit.thread9.i.i, %luaO_str2d.exit.i.i, %land.lhs.true.i, %entry
  %conv = trunc i64 %call.i to i32
  %base.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %11 = load ptr, ptr %base.i.i.i, align 8
  %top.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %12 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i.i = icmp uge ptr %11, %12
  %cmp.i.i = icmp eq ptr %11, @luaO_nilobject_
  %or.cond = or i1 %cmp.i.i, %cmp1.not.i.i.i
  br i1 %or.cond, label %if.then.i7, label %lua_type.exit.i

lua_type.exit.i:                                  ; preds = %luaL_checkinteger.exit
  %tt.i.i = getelementptr inbounds %struct.lua_TValue, ptr %11, i64 0, i32 1
  %13 = load i32, ptr %tt.i.i, align 8
  %cmp.not.i = icmp eq i32 %13, 5
  br i1 %cmp.not.i, label %luaL_checktype.exit, label %if.then.i7

if.then.i7:                                       ; preds = %luaL_checkinteger.exit, %lua_type.exit.i
  tail call fastcc void @luaL_typerror(ptr noundef nonnull %L, i32 noundef 1, ptr noundef nonnull @.str.26)
  unreachable

luaL_checktype.exit:                              ; preds = %lua_type.exit.i
  %inc = add nsw i32 %conv, 1
  %conv.i = sitofp i32 %inc to double
  store double %conv.i, ptr %12, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %12, i64 0, i32 1
  store i32 3, ptr %tt.i, align 8
  %14 = load ptr, ptr %top.i.i.i, align 8
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %14, i64 1
  store ptr %incdec.ptr.i, ptr %top.i.i.i, align 8
  %15 = load ptr, ptr %base.i.i.i, align 8
  %cmp1.not.i.i = icmp ult ptr %15, %incdec.ptr.i
  %add.ptr.luaO_nilobject_.i.i = select i1 %cmp1.not.i.i, ptr %15, ptr @luaO_nilobject_
  %16 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i, align 8
  %sizearray.i.i = getelementptr inbounds %struct.Table, ptr %16, i64 0, i32 10
  %17 = load i32, ptr %sizearray.i.i, align 8
  %cmp.i5.i = icmp ugt i32 %17, %conv
  br i1 %cmp.i5.i, label %if.then.i9.i, label %if.else.i.i

if.then.i9.i:                                     ; preds = %luaL_checktype.exit
  %array.i.i = getelementptr inbounds %struct.Table, ptr %16, i64 0, i32 6
  %18 = load ptr, ptr %array.i.i, align 8
  %sext = shl i64 %call.i, 32
  %idxprom.i10.i = ashr exact i64 %sext, 32
  %arrayidx.i11.i = getelementptr inbounds %struct.lua_TValue, ptr %18, i64 %idxprom.i10.i
  br label %lua_rawgeti.exit

if.else.i.i:                                      ; preds = %luaL_checktype.exit
  %cmp.i.i.i = icmp eq i32 %inc, 0
  br i1 %cmp.i.i.i, label %if.then.i.i.i, label %if.end.i.i.i

if.then.i.i.i:                                    ; preds = %if.else.i.i
  %node.i.i.i = getelementptr inbounds %struct.Table, ptr %16, i64 0, i32 7
  %19 = load ptr, ptr %node.i.i.i, align 8
  br label %do.body.i.i.preheader

if.end.i.i.i:                                     ; preds = %if.else.i.i
  %20 = bitcast double %conv.i to i64
  %a.sroa.0.4.extract.shift.i.i.i = lshr i64 %20, 32
  %add.i.i.i = add i64 %a.sroa.0.4.extract.shift.i.i.i, %20
  %node4.i.i.i = getelementptr inbounds %struct.Table, ptr %16, i64 0, i32 7
  %21 = load ptr, ptr %node4.i.i.i, align 8
  %conv.i.i.i = and i64 %add.i.i.i, 4294967295
  %lsizenode.i.i.i = getelementptr inbounds %struct.Table, ptr %16, i64 0, i32 4
  %22 = load i8, ptr %lsizenode.i.i.i, align 1
  %sh_prom.i.i.i = zext nneg i8 %22 to i64
  %notmask.i.i.i = shl nsw i64 -1, %sh_prom.i.i.i
  %sub.i.i.i = xor i64 %notmask.i.i.i, -1
  %or.i.i.i = or i64 %sub.i.i.i, 1
  %rem.i.i.i = urem i64 %conv.i.i.i, %or.i.i.i
  %arrayidx7.i.i.i = getelementptr inbounds %struct.Node, ptr %21, i64 %rem.i.i.i
  br label %do.body.i.i.preheader

do.body.i.i.preheader:                            ; preds = %if.end.i.i.i, %if.then.i.i.i
  %n.0.i.i.ph = phi ptr [ %arrayidx7.i.i.i, %if.end.i.i.i ], [ %19, %if.then.i.i.i ]
  br label %do.body.i.i

do.body.i.i:                                      ; preds = %do.body.i.i.preheader, %if.else8.i.i
  %n.0.i.i = phi ptr [ %25, %if.else8.i.i ], [ %n.0.i.i.ph, %do.body.i.i.preheader ]
  %tt.i7.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1, i32 0, i32 1
  %23 = load i32, ptr %tt.i7.i, align 8
  %cmp2.i.i = icmp eq i32 %23, 3
  br i1 %cmp2.i.i, label %land.lhs.true.i.i, label %if.else8.i.i

land.lhs.true.i.i:                                ; preds = %do.body.i.i
  %i_key.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1
  %24 = load double, ptr %i_key.i.i, align 8
  %cmp5.i.i = fcmp oeq double %24, %conv.i
  br i1 %cmp5.i.i, label %lua_rawgeti.exit, label %if.else8.i.i

if.else8.i.i:                                     ; preds = %land.lhs.true.i.i, %do.body.i.i
  %next.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1, i32 0, i32 2
  %25 = load ptr, ptr %next.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %25, null
  br i1 %tobool.not.i.i, label %lua_rawgeti.exit, label %do.body.i.i, !llvm.loop !7

lua_rawgeti.exit:                                 ; preds = %land.lhs.true.i.i, %if.else8.i.i, %if.then.i9.i
  %retval.0.i8.i = phi ptr [ %arrayidx.i11.i, %if.then.i9.i ], [ @luaO_nilobject_, %if.else8.i.i ], [ %n.0.i.i, %land.lhs.true.i.i ]
  %26 = load i64, ptr %retval.0.i8.i, align 8
  store i64 %26, ptr %incdec.ptr.i, align 8
  %tt.i10 = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i8.i, i64 0, i32 1
  %27 = load i32, ptr %tt.i10, align 8
  %tt4.i = getelementptr inbounds %struct.lua_TValue, ptr %14, i64 1, i32 1
  store i32 %27, ptr %tt4.i, align 8
  %28 = load ptr, ptr %top.i.i.i, align 8
  %incdec.ptr.i11 = getelementptr inbounds %struct.lua_TValue, ptr %28, i64 1
  store ptr %incdec.ptr.i11, ptr %top.i.i.i, align 8
  %cmp.i12 = icmp eq ptr %28, @luaO_nilobject_
  br i1 %cmp.i12, label %lua_type.exit.thread, label %lua_type.exit

lua_type.exit:                                    ; preds = %lua_rawgeti.exit
  %tt.i13 = getelementptr inbounds %struct.lua_TValue, ptr %28, i64 0, i32 1
  %29 = load i32, ptr %tt.i13, align 8
  %.fr = freeze i32 %29
  %cmp = icmp eq i32 %.fr, 0
  %spec.select = select i1 %cmp, i32 0, i32 2
  br label %lua_type.exit.thread

lua_type.exit.thread:                             ; preds = %lua_type.exit, %lua_rawgeti.exit
  %30 = phi i32 [ 2, %lua_rawgeti.exit ], [ %spec.select, %lua_type.exit ]
  ret i32 %30
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_pairs(ptr noundef %L) #0 {
entry:
  %base.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i.i, align 8
  %top.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i.i = icmp uge ptr %0, %1
  %cmp.i.i = icmp eq ptr %0, @luaO_nilobject_
  %or.cond = or i1 %cmp.i.i, %cmp1.not.i.i.i
  br i1 %or.cond, label %if.then.i, label %lua_type.exit.i

lua_type.exit.i:                                  ; preds = %entry
  %tt.i.i = getelementptr inbounds %struct.lua_TValue, ptr %0, i64 0, i32 1
  %2 = load i32, ptr %tt.i.i, align 8
  %cmp.not.i = icmp eq i32 %2, 5
  br i1 %cmp.not.i, label %luaL_checktype.exit, label %if.then.i

if.then.i:                                        ; preds = %entry, %lua_type.exit.i
  tail call fastcc void @luaL_typerror(ptr noundef nonnull %L, i32 noundef 1, ptr noundef nonnull @.str.26)
  unreachable

luaL_checktype.exit:                              ; preds = %lua_type.exit.i
  %ci17.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %3 = load ptr, ptr %ci17.i.i, align 8
  %func18.i.i = getelementptr inbounds %struct.CallInfo, ptr %3, i64 0, i32 1
  %4 = load ptr, ptr %func18.i.i, align 8
  %5 = load ptr, ptr %4, align 8
  %nupvalues.i.i = getelementptr inbounds %struct.CClosure, ptr %5, i64 0, i32 4
  %6 = load i8, ptr %nupvalues.i.i, align 1
  %cmp21.not.i.i = icmp eq i8 %6, 0
  %arrayidx.i.i = getelementptr inbounds %struct.CClosure, ptr %5, i64 0, i32 8, i64 0
  %cond.i.i4 = select i1 %cmp21.not.i.i, ptr @luaO_nilobject_, ptr %arrayidx.i.i
  %7 = load i64, ptr %cond.i.i4, align 8
  store i64 %7, ptr %1, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %cond.i.i4, i64 0, i32 1
  %8 = load i32, ptr %tt.i, align 8
  %tt2.i = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 0, i32 1
  store i32 %8, ptr %tt2.i, align 8
  %9 = load ptr, ptr %top.i.i.i, align 8
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %9, i64 1
  store ptr %incdec.ptr.i, ptr %top.i.i.i, align 8
  %10 = load ptr, ptr %base.i.i.i, align 8
  %cmp1.not.i.i = icmp ult ptr %10, %incdec.ptr.i
  %add.ptr.luaO_nilobject_.i.i = select i1 %cmp1.not.i.i, ptr %10, ptr @luaO_nilobject_
  %11 = load i64, ptr %add.ptr.luaO_nilobject_.i.i, align 8
  store i64 %11, ptr %incdec.ptr.i, align 8
  %tt.i6 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i, i64 0, i32 1
  %12 = load i32, ptr %tt.i6, align 8
  %tt2.i7 = getelementptr inbounds %struct.lua_TValue, ptr %9, i64 1, i32 1
  store i32 %12, ptr %tt2.i7, align 8
  %13 = load ptr, ptr %top.i.i.i, align 8
  %incdec.ptr.i8 = getelementptr inbounds %struct.lua_TValue, ptr %13, i64 1
  store ptr %incdec.ptr.i8, ptr %top.i.i.i, align 8
  %tt.i10 = getelementptr inbounds %struct.lua_TValue, ptr %13, i64 1, i32 1
  store i32 0, ptr %tt.i10, align 8
  %14 = load ptr, ptr %top.i.i.i, align 8
  %incdec.ptr.i11 = getelementptr inbounds %struct.lua_TValue, ptr %14, i64 1
  store ptr %incdec.ptr.i11, ptr %top.i.i.i, align 8
  ret i32 3
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_next(ptr noundef %L) #0 {
entry:
  %base.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i.i, align 8
  %top.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i.i = icmp uge ptr %0, %1
  %cmp.i.i = icmp eq ptr %0, @luaO_nilobject_
  %or.cond = or i1 %cmp.i.i, %cmp1.not.i.i.i
  br i1 %or.cond, label %if.then.i, label %lua_type.exit.i

lua_type.exit.i:                                  ; preds = %entry
  %tt.i.i = getelementptr inbounds %struct.lua_TValue, ptr %0, i64 0, i32 1
  %2 = load i32, ptr %tt.i.i, align 8
  %cmp.not.i = icmp eq i32 %2, 5
  br i1 %cmp.not.i, label %luaL_checktype.exit, label %if.then.i

if.then.i:                                        ; preds = %entry, %lua_type.exit.i
  tail call fastcc void @luaL_typerror(ptr noundef nonnull %L, i32 noundef 1, ptr noundef nonnull @.str.26)
  unreachable

luaL_checktype.exit:                              ; preds = %lua_type.exit.i
  %add.ptr10.i = getelementptr inbounds %struct.lua_TValue, ptr %0, i64 2
  %cmp111.i = icmp ult ptr %1, %add.ptr10.i
  br i1 %cmp111.i, label %while.body.i, label %lua_settop.exit

while.body.i:                                     ; preds = %luaL_checktype.exit, %while.body.i
  %3 = phi ptr [ %4, %while.body.i ], [ %1, %luaL_checktype.exit ]
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %3, i64 1
  store ptr %incdec.ptr.i, ptr %top.i.i.i, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %3, i64 0, i32 1
  store i32 0, ptr %tt.i, align 8
  %4 = load ptr, ptr %top.i.i.i, align 8
  %5 = load ptr, ptr %base.i.i.i, align 8
  %add.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %5, i64 2
  %cmp1.i = icmp ult ptr %4, %add.ptr.i
  br i1 %cmp1.i, label %while.body.i, label %lua_settop.exit, !llvm.loop !13

lua_settop.exit:                                  ; preds = %while.body.i, %luaL_checktype.exit
  %6 = phi ptr [ %0, %luaL_checktype.exit ], [ %5, %while.body.i ]
  %add.ptr9.sink.i = phi ptr [ %add.ptr10.i, %luaL_checktype.exit ], [ %add.ptr.i, %while.body.i ]
  store ptr %add.ptr9.sink.i, ptr %top.i.i.i, align 8
  %cmp1.not.i.i = icmp ult ptr %6, %add.ptr9.sink.i
  %add.ptr.luaO_nilobject_.i.i = select i1 %cmp1.not.i.i, ptr %6, ptr @luaO_nilobject_
  %7 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i, align 8
  %add.ptr.i4 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr9.sink.i, i64 -1
  %tt.i.i.i = getelementptr %struct.lua_TValue, ptr %add.ptr9.sink.i, i64 -1, i32 1
  %8 = load i32, ptr %tt.i.i.i, align 8
  switch i32 %8, label %mainposition.exit.i.i.i [
    i32 0, label %entry.findindex.exit_crit_edge.i.i
    i32 3, label %if.then.i.i.i.i
    i32 2, label %sw.bb18.i.i.i.i
    i32 4, label %mainposition.exit.thread41.i.i.i
    i32 1, label %sw.bb5.i.i.i.i
  ]

entry.findindex.exit_crit_edge.i.i:               ; preds = %lua_settop.exit
  %sizearray.phi.trans.insert.i.i = getelementptr inbounds %struct.Table, ptr %7, i64 0, i32 10
  %.pre.i.i = load i32, ptr %sizearray.phi.trans.insert.i.i, align 8
  br label %findindex.exit.i.i

if.then.i.i.i.i:                                  ; preds = %lua_settop.exit
  %9 = load double, ptr %add.ptr.i4, align 8
  %conv.i.i.i.i = fptosi double %9 to i32
  %conv1.i.i.i.i = sitofp i32 %conv.i.i.i.i to double
  %cmp2.i.i.i.i = fcmp oeq double %9, %conv1.i.i.i.i
  %10 = bitcast double %9 to i64
  %11 = trunc i64 %10 to i32
  %cmp1.i.i.i = icmp sgt i32 %conv.i.i.i.i, 0
  %or.cond.i.i.i = and i1 %cmp1.i.i.i, %cmp2.i.i.i.i
  br i1 %or.cond.i.i.i, label %land.lhs.true.i.i.i, label %sw.bb.i.i.i.i

land.lhs.true.i.i.i:                              ; preds = %if.then.i.i.i.i
  %sizearray.i.i.i = getelementptr inbounds %struct.Table, ptr %7, i64 0, i32 10
  %12 = load i32, ptr %sizearray.i.i.i, align 8
  %cmp2.not.i.i.i = icmp slt i32 %12, %conv.i.i.i.i
  br i1 %cmp2.not.i.i.i, label %sw.bb.i.i.i.i, label %if.then3.i.i.i

if.then3.i.i.i:                                   ; preds = %land.lhs.true.i.i.i
  %sub.i.i.i = add nsw i32 %conv.i.i.i.i, -1
  br label %findindex.exit.i.i

sw.bb.i.i.i.i:                                    ; preds = %land.lhs.true.i.i.i, %if.then.i.i.i.i
  %cmp.i.i.i.i.i = fcmp oeq double %9, 0.000000e+00
  br i1 %cmp.i.i.i.i.i, label %if.then.i.i.i.i.i, label %if.end.i.i.i.i.i

if.then.i.i.i.i.i:                                ; preds = %sw.bb.i.i.i.i
  %node.i.i.i.i.i = getelementptr inbounds %struct.Table, ptr %7, i64 0, i32 7
  %13 = load ptr, ptr %node.i.i.i.i.i, align 8
  br label %do.body.us.preheader.i.i.i

if.end.i.i.i.i.i:                                 ; preds = %sw.bb.i.i.i.i
  %a.sroa.0.4.extract.shift.i.i.i.i.i = lshr i64 %10, 32
  %add.i.i.i.i.i = add i64 %a.sroa.0.4.extract.shift.i.i.i.i.i, %10
  %node4.i.i.i.i.i = getelementptr inbounds %struct.Table, ptr %7, i64 0, i32 7
  %14 = load ptr, ptr %node4.i.i.i.i.i, align 8
  %conv.i.i.i.i.i = and i64 %add.i.i.i.i.i, 4294967295
  %lsizenode.i.i.i.i.i = getelementptr inbounds %struct.Table, ptr %7, i64 0, i32 4
  %15 = load i8, ptr %lsizenode.i.i.i.i.i, align 1
  %sh_prom.i.i.i.i.i = zext nneg i8 %15 to i64
  %notmask.i.i.i.i.i = shl nsw i64 -1, %sh_prom.i.i.i.i.i
  %sub.i.i.i.i.i = xor i64 %notmask.i.i.i.i.i, -1
  %or.i.i.i.i.i = or i64 %sub.i.i.i.i.i, 1
  %rem.i.i.i.i.i = urem i64 %conv.i.i.i.i.i, %or.i.i.i.i.i
  %arrayidx7.i.i.i.i.i = getelementptr inbounds %struct.Node, ptr %14, i64 %rem.i.i.i.i.i
  br label %do.body.us.preheader.i.i.i

mainposition.exit.thread41.i.i.i:                 ; preds = %lua_settop.exit
  %node.i.i.i.i = getelementptr inbounds %struct.Table, ptr %7, i64 0, i32 7
  %16 = load ptr, ptr %node.i.i.i.i, align 8
  %17 = load ptr, ptr %add.ptr.i4, align 8
  %hash.i.i.i.i = getelementptr inbounds %struct.anon.0, ptr %17, i64 0, i32 4
  %18 = load i32, ptr %hash.i.i.i.i, align 4
  %lsizenode.i.i.i.i = getelementptr inbounds %struct.Table, ptr %7, i64 0, i32 4
  %19 = load i8, ptr %lsizenode.i.i.i.i, align 1
  %sh_prom.i.i.i.i = zext nneg i8 %19 to i64
  %notmask15.i.i.i.i = shl nsw i64 -1, %sh_prom.i.i.i.i
  %20 = trunc i64 %notmask15.i.i.i.i to i32
  %21 = xor i32 %20, -1
  %conv4.i.i.i.i = and i32 %18, %21
  %idxprom.i.i.i.i = sext i32 %conv4.i.i.i.i to i64
  %arrayidx.i.i.i.i = getelementptr inbounds %struct.Node, ptr %16, i64 %idxprom.i.i.i.i
  %22 = ptrtoint ptr %17 to i64
  %23 = trunc i64 %22 to i32
  br label %do.body.preheader.i.i.i

sw.bb5.i.i.i.i:                                   ; preds = %lua_settop.exit
  %node6.i.i.i.i = getelementptr inbounds %struct.Table, ptr %7, i64 0, i32 7
  %24 = load ptr, ptr %node6.i.i.i.i, align 8
  %25 = load i32, ptr %add.ptr.i4, align 8
  %lsizenode9.i.i.i.i = getelementptr inbounds %struct.Table, ptr %7, i64 0, i32 4
  %26 = load i8, ptr %lsizenode9.i.i.i.i, align 1
  %sh_prom11.i.i.i.i = zext nneg i8 %26 to i64
  %notmask14.i.i.i.i = shl nsw i64 -1, %sh_prom11.i.i.i.i
  %27 = trunc i64 %notmask14.i.i.i.i to i32
  %28 = xor i32 %27, -1
  %conv15.i.i.i.i = and i32 %25, %28
  %idxprom16.i.i.i.i = sext i32 %conv15.i.i.i.i to i64
  %arrayidx17.i.i.i.i = getelementptr inbounds %struct.Node, ptr %24, i64 %idxprom16.i.i.i.i
  br label %do.body.us.preheader.i.i.i

sw.bb18.i.i.i.i:                                  ; preds = %lua_settop.exit
  %node19.i.i.i.i = getelementptr inbounds %struct.Table, ptr %7, i64 0, i32 7
  %29 = load ptr, ptr %node19.i.i.i.i, align 8
  %30 = load ptr, ptr %add.ptr.i4, align 8
  %31 = ptrtoint ptr %30 to i64
  %conv22.i.i.i.i = and i64 %31, 4294967295
  %lsizenode23.i.i.i.i = getelementptr inbounds %struct.Table, ptr %7, i64 0, i32 4
  %32 = load i8, ptr %lsizenode23.i.i.i.i, align 1
  %sh_prom25.i.i.i.i = zext nneg i8 %32 to i64
  %notmask.i.i.i.i = shl nsw i64 -1, %sh_prom25.i.i.i.i
  %sub27.i.i.i.i = xor i64 %notmask.i.i.i.i, -1
  %or.i.i.i.i = or i64 %sub27.i.i.i.i, 1
  %rem.i.i.i.i = urem i64 %conv22.i.i.i.i, %or.i.i.i.i
  %arrayidx28.i.i.i.i = getelementptr inbounds %struct.Node, ptr %29, i64 %rem.i.i.i.i
  %33 = trunc i64 %31 to i32
  br label %do.body.us.preheader.i.i.i

mainposition.exit.i.i.i:                          ; preds = %lua_settop.exit
  %node29.i.i.i.i = getelementptr inbounds %struct.Table, ptr %7, i64 0, i32 7
  %34 = load ptr, ptr %node29.i.i.i.i, align 8
  %35 = load ptr, ptr %add.ptr.i4, align 8
  %36 = ptrtoint ptr %35 to i64
  %conv32.i.i.i.i = and i64 %36, 4294967295
  %lsizenode33.i.i.i.i = getelementptr inbounds %struct.Table, ptr %7, i64 0, i32 4
  %37 = load i8, ptr %lsizenode33.i.i.i.i, align 1
  %sh_prom35.i.i.i.i = zext nneg i8 %37 to i64
  %notmask16.i.i.i.i = shl nsw i64 -1, %sh_prom35.i.i.i.i
  %sub37.i.i.i.i = xor i64 %notmask16.i.i.i.i, -1
  %or38.i.i.i.i = or i64 %sub37.i.i.i.i, 1
  %rem39.i.i.i.i = urem i64 %conv32.i.i.i.i, %or38.i.i.i.i
  %arrayidx40.i.i.i.i = getelementptr inbounds %struct.Node, ptr %34, i64 %rem39.i.i.i.i
  %38 = trunc i64 %36 to i32
  %cmp11.i.i.i = icmp sgt i32 %8, 3
  br i1 %cmp11.i.i.i, label %do.body.preheader.i.i.i, label %do.body.us.preheader.i.i.i

do.body.us.preheader.i.i.i:                       ; preds = %mainposition.exit.i.i.i, %sw.bb18.i.i.i.i, %sw.bb5.i.i.i.i, %if.end.i.i.i.i.i, %if.then.i.i.i.i.i
  %retval.0.i1840.i.i.i = phi ptr [ %arrayidx40.i.i.i.i, %mainposition.exit.i.i.i ], [ %arrayidx7.i.i.i.i.i, %if.end.i.i.i.i.i ], [ %13, %if.then.i.i.i.i.i ], [ %arrayidx17.i.i.i.i, %sw.bb5.i.i.i.i ], [ %arrayidx28.i.i.i.i, %sw.bb18.i.i.i.i ]
  %39 = phi i32 [ %38, %mainposition.exit.i.i.i ], [ %11, %if.end.i.i.i.i.i ], [ %11, %if.then.i.i.i.i.i ], [ %25, %sw.bb5.i.i.i.i ], [ %33, %sw.bb18.i.i.i.i ]
  %40 = phi ptr [ %34, %mainposition.exit.i.i.i ], [ %14, %if.end.i.i.i.i.i ], [ %13, %if.then.i.i.i.i.i ], [ %24, %sw.bb5.i.i.i.i ], [ %29, %sw.bb18.i.i.i.i ]
  br label %do.body.us.i.i.i

do.body.preheader.i.i.i:                          ; preds = %mainposition.exit.i.i.i, %mainposition.exit.thread41.i.i.i
  %.pre-phi27.i = phi i32 [ %38, %mainposition.exit.i.i.i ], [ %23, %mainposition.exit.thread41.i.i.i ]
  %.pre-phi.i = phi i64 [ %36, %mainposition.exit.i.i.i ], [ %22, %mainposition.exit.thread41.i.i.i ]
  %41 = phi ptr [ %35, %mainposition.exit.i.i.i ], [ %17, %mainposition.exit.thread41.i.i.i ]
  %retval.0.i1844.i.i.i = phi ptr [ %arrayidx40.i.i.i.i, %mainposition.exit.i.i.i ], [ %arrayidx.i.i.i.i, %mainposition.exit.thread41.i.i.i ]
  %42 = phi ptr [ %34, %mainposition.exit.i.i.i ], [ %16, %mainposition.exit.thread41.i.i.i ]
  %43 = bitcast i64 %.pre-phi.i to double
  %44 = inttoptr i64 %.pre-phi.i to ptr
  br label %do.body.i.i.i

do.body.us.i.i.i:                                 ; preds = %lor.lhs.false.us.i.i.i, %do.body.us.preheader.i.i.i
  %45 = phi i32 [ %60, %lor.lhs.false.us.i.i.i ], [ %39, %do.body.us.preheader.i.i.i ]
  %n.0.us.i.i.i = phi ptr [ %61, %lor.lhs.false.us.i.i.i ], [ %retval.0.i1840.i.i.i, %do.body.us.preheader.i.i.i ]
  %i_key.us.i.i.i = getelementptr inbounds %struct.Node, ptr %n.0.us.i.i.i, i64 0, i32 1
  %tt.i19.us.i.i.i = getelementptr inbounds %struct.Node, ptr %n.0.us.i.i.i, i64 0, i32 1, i32 0, i32 1
  %46 = load i32, ptr %tt.i19.us.i.i.i, align 8
  %cmp.not.i.us.i.i.i = icmp eq i32 %46, %8
  br i1 %cmp.not.i.us.i.i.i, label %if.else.i.us.i.i.i, label %lor.lhs.false.us.i.i.i

if.else.i.us.i.i.i:                               ; preds = %do.body.us.i.i.i
  switch i32 %8, label %sw.default.i21.us.i.i.i [
    i32 0, label %if.then16.i.i.i
    i32 3, label %luaO_rawequalObj.exit.us.i.i.i
    i32 1, label %sw.bb6.i.us.i.i.i
    i32 2, label %sw.bb11.i.us.i.i.i
  ]

sw.bb11.i.us.i.i.i:                               ; preds = %if.else.i.us.i.i.i
  %47 = load ptr, ptr %i_key.us.i.i.i, align 8
  %48 = load ptr, ptr %add.ptr.i4, align 8
  %cmp14.i.us.i.i.i = icmp eq ptr %47, %48
  %49 = ptrtoint ptr %48 to i64
  %50 = trunc i64 %49 to i32
  br i1 %cmp14.i.us.i.i.i, label %if.then16.i.i.i, label %lor.lhs.false.us.i.i.i

sw.bb6.i.us.i.i.i:                                ; preds = %if.else.i.us.i.i.i
  %51 = load i32, ptr %i_key.us.i.i.i, align 8
  %cmp9.i.us.i.i.i = icmp eq i32 %51, %45
  br i1 %cmp9.i.us.i.i.i, label %if.then16.i.i.i, label %lor.lhs.false.us.i.i.i

sw.default.i21.us.i.i.i:                          ; preds = %if.else.i.us.i.i.i
  %52 = load ptr, ptr %i_key.us.i.i.i, align 8
  %53 = load ptr, ptr %add.ptr.i4, align 8
  %cmp18.i.us.i.i.i = icmp eq ptr %52, %53
  %54 = ptrtoint ptr %53 to i64
  %55 = trunc i64 %54 to i32
  br i1 %cmp18.i.us.i.i.i, label %if.then16.i.i.i, label %lor.lhs.false.us.i.i.i

luaO_rawequalObj.exit.us.i.i.i:                   ; preds = %if.else.i.us.i.i.i
  %56 = load double, ptr %i_key.us.i.i.i, align 8
  %57 = load double, ptr %add.ptr.i4, align 8
  %cmp5.i.us.i.i.i = fcmp oeq double %56, %57
  %58 = bitcast double %57 to i64
  %59 = trunc i64 %58 to i32
  br i1 %cmp5.i.us.i.i.i, label %if.then16.i.i.i, label %lor.lhs.false.us.i.i.i

lor.lhs.false.us.i.i.i:                           ; preds = %luaO_rawequalObj.exit.us.i.i.i, %sw.default.i21.us.i.i.i, %sw.bb6.i.us.i.i.i, %sw.bb11.i.us.i.i.i, %do.body.us.i.i.i
  %60 = phi i32 [ %59, %luaO_rawequalObj.exit.us.i.i.i ], [ %45, %do.body.us.i.i.i ], [ %55, %sw.default.i21.us.i.i.i ], [ %50, %sw.bb11.i.us.i.i.i ], [ %45, %sw.bb6.i.us.i.i.i ]
  %next.us.i.i.i = getelementptr inbounds %struct.Node, ptr %n.0.us.i.i.i, i64 0, i32 1, i32 0, i32 2
  %61 = load ptr, ptr %next.us.i.i.i, align 8
  %tobool21.not.us.i.i.i = icmp eq ptr %61, null
  br i1 %tobool21.not.us.i.i.i, label %do.end.i.i.i, label %do.body.us.i.i.i, !llvm.loop !83

do.body.i.i.i:                                    ; preds = %if.else18.i.i.i, %do.body.preheader.i.i.i
  %62 = phi ptr [ %76, %if.else18.i.i.i ], [ %41, %do.body.preheader.i.i.i ]
  %63 = phi i32 [ %77, %if.else18.i.i.i ], [ %.pre-phi27.i, %do.body.preheader.i.i.i ]
  %n.0.i.i.i = phi ptr [ %78, %if.else18.i.i.i ], [ %retval.0.i1844.i.i.i, %do.body.preheader.i.i.i ]
  %i_key.i.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i.i, i64 0, i32 1
  %tt.i19.i.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i.i, i64 0, i32 1, i32 0, i32 1
  %64 = load i32, ptr %tt.i19.i.i.i, align 8
  %cmp.not.i.i.i.i = icmp eq i32 %64, %8
  br i1 %cmp.not.i.i.i.i, label %if.else.i.i.i.i, label %lor.lhs.false.i.i.i

if.else.i.i.i.i:                                  ; preds = %do.body.i.i.i
  switch i32 %8, label %sw.default.i21.i.i.i [
    i32 0, label %if.then16.i.i.i
    i32 3, label %luaO_rawequalObj.exit.i.i.i
    i32 1, label %sw.bb6.i.i.i.i
    i32 2, label %sw.bb11.i.i.i.i
  ]

sw.bb6.i.i.i.i:                                   ; preds = %if.else.i.i.i.i
  %65 = load i32, ptr %i_key.i.i.i, align 8
  %cmp9.i.i.i.i = icmp eq i32 %65, %63
  br i1 %cmp9.i.i.i.i, label %if.then16.i.i.i, label %lor.lhs.false.i.i.i

sw.bb11.i.i.i.i:                                  ; preds = %if.else.i.i.i.i
  %66 = load ptr, ptr %i_key.i.i.i, align 8
  %cmp14.i.i.i.i = icmp eq ptr %66, %62
  %67 = ptrtoint ptr %62 to i64
  %68 = trunc i64 %67 to i32
  br i1 %cmp14.i.i.i.i, label %if.then16.i.i.i, label %lor.lhs.false.i.i.i

sw.default.i21.i.i.i:                             ; preds = %if.else.i.i.i.i
  %69 = load ptr, ptr %i_key.i.i.i, align 8
  %cmp18.i.i.i.i = icmp eq ptr %69, %41
  br i1 %cmp18.i.i.i.i, label %if.then16.i.i.i, label %lor.lhs.false.i.i.i

luaO_rawequalObj.exit.i.i.i:                      ; preds = %if.else.i.i.i.i
  %70 = load double, ptr %i_key.i.i.i, align 8
  %cmp5.i.i.i.i = fcmp oeq double %70, %43
  br i1 %cmp5.i.i.i.i, label %if.then16.i.i.i, label %lor.lhs.false.i.i.i

lor.lhs.false.i.i.i:                              ; preds = %luaO_rawequalObj.exit.i.i.i, %sw.default.i21.i.i.i, %sw.bb11.i.i.i.i, %sw.bb6.i.i.i.i, %do.body.i.i.i
  %71 = phi ptr [ %62, %do.body.i.i.i ], [ %44, %luaO_rawequalObj.exit.i.i.i ], [ %41, %sw.default.i21.i.i.i ], [ %62, %sw.bb11.i.i.i.i ], [ %62, %sw.bb6.i.i.i.i ]
  %72 = phi i32 [ %63, %do.body.i.i.i ], [ %.pre-phi27.i, %luaO_rawequalObj.exit.i.i.i ], [ %.pre-phi27.i, %sw.default.i21.i.i.i ], [ %68, %sw.bb11.i.i.i.i ], [ %63, %sw.bb6.i.i.i.i ]
  %cmp8.i.i.i = icmp eq i32 %64, 11
  br i1 %cmp8.i.i.i, label %land.lhs.true12.i.i.i, label %if.else18.i.i.i

land.lhs.true12.i.i.i:                            ; preds = %lor.lhs.false.i.i.i
  %73 = load ptr, ptr %i_key.i.i.i, align 8
  %cmp15.i.i.i = icmp eq ptr %73, %41
  br i1 %cmp15.i.i.i, label %if.then16.i.i.i, label %if.else18.i.i.i

if.then16.i.i.i:                                  ; preds = %luaO_rawequalObj.exit.us.i.i.i, %sw.default.i21.us.i.i.i, %sw.bb6.i.us.i.i.i, %sw.bb11.i.us.i.i.i, %if.else.i.us.i.i.i, %land.lhs.true12.i.i.i, %luaO_rawequalObj.exit.i.i.i, %sw.default.i21.i.i.i, %sw.bb11.i.i.i.i, %sw.bb6.i.i.i.i, %if.else.i.i.i.i
  %74 = phi ptr [ %42, %if.else.i.i.i.i ], [ %42, %sw.bb6.i.i.i.i ], [ %42, %sw.bb11.i.i.i.i ], [ %42, %sw.default.i21.i.i.i ], [ %42, %luaO_rawequalObj.exit.i.i.i ], [ %42, %land.lhs.true12.i.i.i ], [ %40, %if.else.i.us.i.i.i ], [ %40, %sw.bb11.i.us.i.i.i ], [ %40, %sw.bb6.i.us.i.i.i ], [ %40, %sw.default.i21.us.i.i.i ], [ %40, %luaO_rawequalObj.exit.us.i.i.i ]
  %.us-phi.i.i.i = phi ptr [ %n.0.i.i.i, %if.else.i.i.i.i ], [ %n.0.i.i.i, %sw.bb6.i.i.i.i ], [ %n.0.i.i.i, %sw.bb11.i.i.i.i ], [ %n.0.i.i.i, %sw.default.i21.i.i.i ], [ %n.0.i.i.i, %luaO_rawequalObj.exit.i.i.i ], [ %n.0.i.i.i, %land.lhs.true12.i.i.i ], [ %n.0.us.i.i.i, %if.else.i.us.i.i.i ], [ %n.0.us.i.i.i, %sw.bb11.i.us.i.i.i ], [ %n.0.us.i.i.i, %sw.bb6.i.us.i.i.i ], [ %n.0.us.i.i.i, %sw.default.i21.us.i.i.i ], [ %n.0.us.i.i.i, %luaO_rawequalObj.exit.us.i.i.i ]
  %sub.ptr.lhs.cast.i.i.i = ptrtoint ptr %.us-phi.i.i.i to i64
  %sub.ptr.rhs.cast.i.i.i = ptrtoint ptr %74 to i64
  %sub.ptr.sub.i.i.i = sub i64 %sub.ptr.lhs.cast.i.i.i, %sub.ptr.rhs.cast.i.i.i
  %sub.ptr.div.i.i.i = sdiv exact i64 %sub.ptr.sub.i.i.i, 40
  %conv.i.i.i = trunc i64 %sub.ptr.div.i.i.i to i32
  %sizearray17.i.i.i = getelementptr inbounds %struct.Table, ptr %7, i64 0, i32 10
  %75 = load i32, ptr %sizearray17.i.i.i, align 8
  %add.i.i.i = add nsw i32 %75, %conv.i.i.i
  br label %findindex.exit.i.i

if.else18.i.i.i:                                  ; preds = %land.lhs.true12.i.i.i, %lor.lhs.false.i.i.i
  %76 = phi ptr [ %41, %land.lhs.true12.i.i.i ], [ %71, %lor.lhs.false.i.i.i ]
  %77 = phi i32 [ %.pre-phi27.i, %land.lhs.true12.i.i.i ], [ %72, %lor.lhs.false.i.i.i ]
  %next.i.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i.i, i64 0, i32 1, i32 0, i32 2
  %78 = load ptr, ptr %next.i.i.i, align 8
  %tobool21.not.i.i.i = icmp eq ptr %78, null
  br i1 %tobool21.not.i.i.i, label %do.end.i.i.i, label %do.body.i.i.i, !llvm.loop !83

do.end.i.i.i:                                     ; preds = %lor.lhs.false.us.i.i.i, %if.else18.i.i.i
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef %L, ptr noundef nonnull @.str.185)
  unreachable

findindex.exit.i.i:                               ; preds = %if.then16.i.i.i, %if.then3.i.i.i, %entry.findindex.exit_crit_edge.i.i
  %79 = phi i32 [ %12, %if.then3.i.i.i ], [ %75, %if.then16.i.i.i ], [ %.pre.i.i, %entry.findindex.exit_crit_edge.i.i ]
  %retval.0.i.i.i = phi i32 [ %sub.i.i.i, %if.then3.i.i.i ], [ %add.i.i.i, %if.then16.i.i.i ], [ -1, %entry.findindex.exit_crit_edge.i.i ]
  %array.i.i = getelementptr inbounds %struct.Table, ptr %7, i64 0, i32 6
  %80 = sext i32 %retval.0.i.i.i to i64
  %81 = sext i32 %79 to i64
  %reass.sub.i = sub i32 %retval.0.i.i.i, %79
  %82 = add nsw i64 %80, 1
  %smax.i = tail call i64 @llvm.smax.i64(i64 %82, i64 %81)
  br label %for.cond.i.i

for.cond.i.i:                                     ; preds = %for.body.i.i, %findindex.exit.i.i
  %indvars.iv49.i.in.i = phi i32 [ %indvars.iv49.i.i, %for.body.i.i ], [ %reass.sub.i, %findindex.exit.i.i ]
  %indvars.iv.i.i = phi i64 [ %indvars.iv.next.i.i, %for.body.i.i ], [ %80, %findindex.exit.i.i ]
  %indvars.iv49.i.i = add i32 %indvars.iv49.i.in.i, 1
  %indvars.iv.next.i.i = add nsw i64 %indvars.iv.i.i, 1
  %cmp.i.i5 = icmp slt i64 %indvars.iv.next.i.i, %81
  br i1 %cmp.i.i5, label %for.body.i.i, label %for.end.i.i

for.body.i.i:                                     ; preds = %for.cond.i.i
  %83 = load ptr, ptr %array.i.i, align 8
  %tt.i.i8 = getelementptr inbounds %struct.lua_TValue, ptr %83, i64 %indvars.iv.next.i.i, i32 1
  %84 = load i32, ptr %tt.i.i8, align 8
  %cmp1.i.i = icmp eq i32 %84, 0
  br i1 %cmp1.i.i, label %for.cond.i.i, label %if.then.i.i, !llvm.loop !84

if.then.i.i:                                      ; preds = %for.body.i.i
  %85 = trunc i64 %indvars.iv.i.i to i32
  %add.i.i = add nsw i32 %85, 2
  %conv.i.i = sitofp i32 %add.i.i to double
  store double %conv.i.i, ptr %add.ptr.i4, align 8
  store i32 3, ptr %tt.i.i.i, align 8
  %86 = load ptr, ptr %array.i.i, align 8
  %arrayidx5.i.i = getelementptr inbounds %struct.lua_TValue, ptr %86, i64 %indvars.iv.next.i.i
  %87 = load i64, ptr %arrayidx5.i.i, align 8
  store i64 %87, ptr %add.ptr9.sink.i, align 8
  %tt8.i.i = getelementptr inbounds %struct.lua_TValue, ptr %86, i64 %indvars.iv.next.i.i, i32 1
  br label %lua_next.exit

for.end.i.i:                                      ; preds = %for.cond.i.i
  %88 = trunc i64 %smax.i to i32
  %sub.i.i = sub nsw i32 %88, %79
  %lsizenode.i.i = getelementptr inbounds %struct.Table, ptr %7, i64 0, i32 4
  %89 = load i8, ptr %lsizenode.i.i, align 1
  %sh_prom.i.i = zext nneg i8 %89 to i64
  %shl.i.i = shl nuw i64 1, %sh_prom.i.i
  %conv14.i.i = trunc i64 %shl.i.i to i32
  %cmp1539.i.i = icmp slt i32 %sub.i.i, %conv14.i.i
  br i1 %cmp1539.i.i, label %for.body17.lr.ph.i.i, label %if.else

for.body17.lr.ph.i.i:                             ; preds = %for.end.i.i
  %node.i.i = getelementptr inbounds %struct.Table, ptr %7, i64 0, i32 7
  %90 = load ptr, ptr %node.i.i, align 8
  %91 = sext i32 %indvars.iv49.i.i to i64
  %sext.i.i = shl i64 4294967296, %sh_prom.i.i
  %92 = ashr exact i64 %sext.i.i, 32
  br label %for.body17.i.i

for.cond12.i.i:                                   ; preds = %for.body17.i.i
  %indvars.iv.next53.i.i = add nsw i64 %indvars.iv52.i.i, 1
  %cmp15.i.i = icmp slt i64 %indvars.iv.next53.i.i, %92
  br i1 %cmp15.i.i, label %for.body17.i.i, label %if.else, !llvm.loop !85

for.body17.i.i:                                   ; preds = %for.cond12.i.i, %for.body17.lr.ph.i.i
  %indvars.iv52.i.i = phi i64 [ %91, %for.body17.lr.ph.i.i ], [ %indvars.iv.next53.i.i, %for.cond12.i.i ]
  %tt20.i.i = getelementptr inbounds %struct.Node, ptr %90, i64 %indvars.iv52.i.i, i32 0, i32 1
  %93 = load i32, ptr %tt20.i.i, align 8
  %cmp21.i.i = icmp eq i32 %93, 0
  br i1 %cmp21.i.i, label %for.cond12.i.i, label %if.then23.i.i

if.then23.i.i:                                    ; preds = %for.body17.i.i
  %i_key.i.i = getelementptr inbounds %struct.Node, ptr %90, i64 %indvars.iv52.i.i, i32 1
  %94 = load i64, ptr %i_key.i.i, align 8
  store i64 %94, ptr %add.ptr.i4, align 8
  %tt31.i.i = getelementptr inbounds %struct.lua_TValue, ptr %i_key.i.i, i64 0, i32 1
  %95 = load i32, ptr %tt31.i.i, align 8
  store i32 %95, ptr %tt.i.i.i, align 8
  %96 = load ptr, ptr %node.i.i, align 8
  %arrayidx36.i.i = getelementptr inbounds %struct.Node, ptr %96, i64 %indvars.iv52.i.i
  %97 = load i64, ptr %arrayidx36.i.i, align 8
  store i64 %97, ptr %add.ptr9.sink.i, align 8
  %tt42.i.i = getelementptr inbounds %struct.lua_TValue, ptr %arrayidx36.i.i, i64 0, i32 1
  br label %lua_next.exit

lua_next.exit:                                    ; preds = %if.then.i.i, %if.then23.i.i
  %tt42.sink.i.i = phi ptr [ %tt42.i.i, %if.then23.i.i ], [ %tt8.i.i, %if.then.i.i ]
  %98 = load i32, ptr %tt42.sink.i.i, align 8
  %tt43.i.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr9.sink.i, i64 0, i32 1
  store i32 %98, ptr %tt43.i.i, align 8
  br label %return

if.else:                                          ; preds = %for.cond12.i.i, %for.end.i.i
  store ptr %add.ptr.i4, ptr %top.i.i.i, align 8
  store i32 0, ptr %tt.i.i.i, align 8
  br label %return

return:                                           ; preds = %lua_next.exit, %if.else
  %retval.0 = phi i32 [ 1, %if.else ], [ 2, %lua_next.exit ]
  %.pn = load ptr, ptr %top.i.i.i, align 8
  %storemerge = getelementptr inbounds %struct.lua_TValue, ptr %.pn, i64 1
  store ptr %storemerge, ptr %top.i.i.i, align 8
  ret i32 %retval.0
}

; Function Attrs: nofree nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define internal fastcc void @lua_setmetatable(ptr nocapture noundef %L, i32 noundef %objindex) unnamed_addr #6 {
entry:
  %cmp.i = icmp sgt i32 %objindex, 0
  br i1 %cmp.i, label %if.then.i, label %if.else3.i

if.then.i:                                        ; preds = %entry
  %base.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i, align 8
  %1 = zext nneg i32 %objindex to i64
  %2 = getelementptr %struct.lua_TValue, ptr %0, i64 %1
  %add.ptr.i = getelementptr %struct.lua_TValue, ptr %2, i64 -1
  %top.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %3 = load ptr, ptr %top.i, align 8
  %cmp1.not.i = icmp ult ptr %add.ptr.i, %3
  %add.ptr.luaO_nilobject_.i = select i1 %cmp1.not.i, ptr %add.ptr.i, ptr @luaO_nilobject_
  br label %index2adr.exit

if.else3.i:                                       ; preds = %entry
  %cmp4.i = icmp sgt i32 %objindex, -10000
  br i1 %cmp4.i, label %if.then5.i, label %if.else9.i

if.then5.i:                                       ; preds = %if.else3.i
  %top6.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %4 = load ptr, ptr %top6.i, align 8
  %idx.ext7.i = sext i32 %objindex to i64
  %add.ptr8.i = getelementptr inbounds %struct.lua_TValue, ptr %4, i64 %idx.ext7.i
  br label %index2adr.exit

if.else9.i:                                       ; preds = %if.else3.i
  switch i32 %objindex, label %sw.default.i [
    i32 -10000, label %sw.bb.i
    i32 -10001, label %sw.bb10.i
    i32 -10002, label %sw.bb15.i
  ]

sw.bb.i:                                          ; preds = %if.else9.i
  %l_G.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %5 = load ptr, ptr %l_G.i, align 8
  %l_registry.i = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 20
  br label %index2adr.exit

sw.bb10.i:                                        ; preds = %if.else9.i
  %ci.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %6 = load ptr, ptr %ci.i, align 8
  %func11.i = getelementptr inbounds %struct.CallInfo, ptr %6, i64 0, i32 1
  %7 = load ptr, ptr %func11.i, align 8
  %8 = load ptr, ptr %7, align 8
  %env.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23
  %env12.i = getelementptr inbounds %struct.CClosure, ptr %8, i64 0, i32 6
  %9 = load ptr, ptr %env12.i, align 8
  store ptr %9, ptr %env.i, align 8
  %tt.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23, i32 1
  store i32 5, ptr %tt.i, align 8
  br label %index2adr.exit

sw.bb15.i:                                        ; preds = %if.else9.i
  %l_gt.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 22
  br label %index2adr.exit

sw.default.i:                                     ; preds = %if.else9.i
  %ci17.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %10 = load ptr, ptr %ci17.i, align 8
  %func18.i = getelementptr inbounds %struct.CallInfo, ptr %10, i64 0, i32 1
  %11 = load ptr, ptr %func18.i, align 8
  %12 = load ptr, ptr %11, align 8
  %sub20.i = sub nuw nsw i32 -10002, %objindex
  %nupvalues.i = getelementptr inbounds %struct.CClosure, ptr %12, i64 0, i32 4
  %13 = load i8, ptr %nupvalues.i, align 1
  %conv.i = zext i8 %13 to i32
  %cmp21.not.i = icmp ugt i32 %sub20.i, %conv.i
  %sub23.i = sub nuw nsw i32 -10003, %objindex
  %idxprom.i = zext nneg i32 %sub23.i to i64
  %arrayidx.i = getelementptr inbounds %struct.CClosure, ptr %12, i64 0, i32 8, i64 %idxprom.i
  %cond.i = select i1 %cmp21.not.i, ptr @luaO_nilobject_, ptr %arrayidx.i
  br label %index2adr.exit

index2adr.exit:                                   ; preds = %if.then.i, %if.then5.i, %sw.bb.i, %sw.bb10.i, %sw.bb15.i, %sw.default.i
  %retval.0.i = phi ptr [ %add.ptr8.i, %if.then5.i ], [ %cond.i, %sw.default.i ], [ %l_gt.i, %sw.bb15.i ], [ %env.i, %sw.bb10.i ], [ %l_registry.i, %sw.bb.i ], [ %add.ptr.luaO_nilobject_.i, %if.then.i ]
  %top = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %14 = load ptr, ptr %top, align 8
  %tt = getelementptr %struct.lua_TValue, ptr %14, i64 -1, i32 1
  %15 = load i32, ptr %tt, align 8
  %cmp = icmp eq i32 %15, 0
  br i1 %cmp, label %if.end, label %if.else

if.else:                                          ; preds = %index2adr.exit
  %add.ptr = getelementptr inbounds %struct.lua_TValue, ptr %14, i64 -1
  %16 = load ptr, ptr %add.ptr, align 8
  br label %if.end

if.end:                                           ; preds = %index2adr.exit, %if.else
  %mt.0 = phi ptr [ %16, %if.else ], [ null, %index2adr.exit ]
  %tt3 = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i, i64 0, i32 1
  %17 = load i32, ptr %tt3, align 8
  switch i32 %17, label %sw.default [
    i32 5, label %sw.bb
    i32 7, label %sw.bb16
  ]

sw.bb:                                            ; preds = %if.end
  %18 = load ptr, ptr %retval.0.i, align 8
  %metatable = getelementptr inbounds %struct.Table, ptr %18, i64 0, i32 5
  store ptr %mt.0, ptr %metatable, align 8
  %tobool.not = icmp eq ptr %mt.0, null
  br i1 %tobool.not, label %sw.epilog, label %if.then5

if.then5:                                         ; preds = %sw.bb
  %marked = getelementptr inbounds %struct.GCheader, ptr %mt.0, i64 0, i32 2
  %19 = load i8, ptr %marked, align 1
  %20 = and i8 %19, 3
  %tobool6.not = icmp eq i8 %20, 0
  br i1 %tobool6.not, label %sw.epilog, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then5
  %21 = load ptr, ptr %retval.0.i, align 8
  %marked8 = getelementptr inbounds %struct.GCheader, ptr %21, i64 0, i32 2
  %22 = load i8, ptr %marked8, align 1
  %23 = and i8 %22, 4
  %tobool11.not = icmp eq i8 %23, 0
  br i1 %tobool11.not, label %sw.epilog, label %if.then12

if.then12:                                        ; preds = %land.lhs.true
  %24 = getelementptr i8, ptr %L, i64 32
  %L.val = load ptr, ptr %24, align 8
  %25 = and i8 %22, -5
  store i8 %25, ptr %marked8, align 1
  %grayagain.i = getelementptr inbounds %struct.global_State, ptr %L.val, i64 0, i32 9
  %26 = load ptr, ptr %grayagain.i, align 8
  %gclist.i = getelementptr inbounds %struct.Table, ptr %21, i64 0, i32 9
  store ptr %26, ptr %gclist.i, align 8
  store ptr %21, ptr %grayagain.i, align 8
  br label %sw.epilog

sw.bb16:                                          ; preds = %if.end
  %27 = load ptr, ptr %retval.0.i, align 8
  %metatable18 = getelementptr inbounds %struct.anon.1, ptr %27, i64 0, i32 3
  store ptr %mt.0, ptr %metatable18, align 8
  %tobool19.not = icmp eq ptr %mt.0, null
  br i1 %tobool19.not, label %sw.epilog, label %if.then20

if.then20:                                        ; preds = %sw.bb16
  %marked21 = getelementptr inbounds %struct.GCheader, ptr %mt.0, i64 0, i32 2
  %28 = load i8, ptr %marked21, align 1
  %29 = and i8 %28, 3
  %tobool24.not = icmp eq i8 %29, 0
  br i1 %tobool24.not, label %sw.epilog, label %land.lhs.true25

land.lhs.true25:                                  ; preds = %if.then20
  %30 = load ptr, ptr %retval.0.i, align 8
  %marked27 = getelementptr inbounds %struct.GCheader, ptr %30, i64 0, i32 2
  %31 = load i8, ptr %marked27, align 1
  %32 = and i8 %31, 4
  %tobool30.not = icmp eq i8 %32, 0
  br i1 %tobool30.not, label %sw.epilog, label %if.then31

if.then31:                                        ; preds = %land.lhs.true25
  %33 = getelementptr i8, ptr %L, i64 32
  %L.val21 = load ptr, ptr %33, align 8
  %gcstate.i = getelementptr inbounds %struct.global_State, ptr %L.val21, i64 0, i32 4
  %34 = load i8, ptr %gcstate.i, align 1
  %cmp.i22 = icmp eq i8 %34, 1
  br i1 %cmp.i22, label %if.then.i24, label %if.else.i

if.then.i24:                                      ; preds = %if.then31
  tail call fastcc void @reallymarkobject(ptr noundef nonnull %L.val21, ptr noundef nonnull %mt.0)
  br label %sw.epilog

if.else.i:                                        ; preds = %if.then31
  %35 = and i8 %31, -8
  %currentwhite.i = getelementptr inbounds %struct.global_State, ptr %L.val21, i64 0, i32 3
  %36 = load i8, ptr %currentwhite.i, align 8
  %37 = and i8 %36, 3
  %or4.i = or disjoint i8 %37, %35
  store i8 %or4.i, ptr %marked27, align 1
  br label %sw.epilog

sw.default:                                       ; preds = %if.end
  %l_G = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %38 = load ptr, ptr %l_G, align 8
  %idxprom = sext i32 %17 to i64
  %arrayidx = getelementptr inbounds %struct.global_State, ptr %38, i64 0, i32 23, i64 %idxprom
  store ptr %mt.0, ptr %arrayidx, align 8
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.else.i, %if.then.i24, %sw.bb16, %land.lhs.true25, %if.then20, %sw.bb, %if.then12, %land.lhs.true, %if.then5, %sw.default
  %39 = load ptr, ptr %top, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue, ptr %39, i64 -1
  store ptr %incdec.ptr, ptr %top, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_newproxy(ptr noundef %L) #0 {
entry:
  %top.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %base.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %top.i, align 8
  %1 = load ptr, ptr %base.i, align 8
  %add.ptr10.i = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 1
  %cmp111.i = icmp ult ptr %0, %add.ptr10.i
  br i1 %cmp111.i, label %while.body.i, label %lua_settop.exit

while.body.i:                                     ; preds = %entry, %while.body.i
  %2 = phi ptr [ %3, %while.body.i ], [ %0, %entry ]
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %2, i64 1
  store ptr %incdec.ptr.i, ptr %top.i, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %2, i64 0, i32 1
  store i32 0, ptr %tt.i, align 8
  %3 = load ptr, ptr %top.i, align 8
  %4 = load ptr, ptr %base.i, align 8
  %add.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %4, i64 1
  %cmp1.i = icmp ult ptr %3, %add.ptr.i
  br i1 %cmp1.i, label %while.body.i, label %lua_settop.exit, !llvm.loop !13

lua_settop.exit:                                  ; preds = %while.body.i, %entry
  %add.ptr9.sink.i = phi ptr [ %add.ptr10.i, %entry ], [ %add.ptr.i, %while.body.i ]
  store ptr %add.ptr9.sink.i, ptr %top.i, align 8
  %call = tail call fastcc ptr @lua_newuserdata(ptr noundef nonnull %L, i64 noundef 0)
  %5 = load ptr, ptr %base.i, align 8
  %6 = load ptr, ptr %top.i, align 8
  %cmp1.not.i.i = icmp uge ptr %5, %6
  %add.ptr.luaO_nilobject_.i.i = select i1 %cmp1.not.i.i, ptr @luaO_nilobject_, ptr %5
  %tt.i15 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i, i64 0, i32 1
  %7 = load i32, ptr %tt.i15, align 8
  switch i32 %7, label %if.else [
    i32 0, label %return
    i32 1, label %lua_toboolean.exit
  ]

lua_toboolean.exit:                               ; preds = %lua_settop.exit
  %8 = load i32, ptr %add.ptr.luaO_nilobject_.i.i, align 8
  %cmp3.i.not = icmp eq i32 %8, 0
  br i1 %cmp3.i.not, label %return, label %if.else

if.else:                                          ; preds = %lua_settop.exit, %lua_toboolean.exit
  %cmp.i = icmp eq ptr %5, @luaO_nilobject_
  %or.cond = or i1 %cmp.i, %cmp1.not.i.i
  br i1 %or.cond, label %if.else5, label %lua_type.exit

lua_type.exit:                                    ; preds = %if.else
  %tt.i20 = getelementptr inbounds %struct.lua_TValue, ptr %5, i64 0, i32 1
  %9 = load i32, ptr %tt.i20, align 8
  %cmp3 = icmp eq i32 %9, 1
  br i1 %cmp3, label %if.then4, label %if.else5

if.then4:                                         ; preds = %lua_type.exit
  %l_G.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %10 = load ptr, ptr %l_G.i, align 8
  %totalbytes.i = getelementptr inbounds %struct.global_State, ptr %10, i64 0, i32 14
  %11 = load i64, ptr %totalbytes.i, align 8
  %GCthreshold.i = getelementptr inbounds %struct.global_State, ptr %10, i64 0, i32 13
  %12 = load i64, ptr %GCthreshold.i, align 8
  %cmp.not.i = icmp ult i64 %11, %12
  br i1 %cmp.not.i, label %lua_createtable.exit, label %if.then.i

if.then.i:                                        ; preds = %if.then4
  %gcstepmul.i.i = getelementptr inbounds %struct.global_State, ptr %10, i64 0, i32 18
  %13 = load i32, ptr %gcstepmul.i.i, align 4
  %mul.i.i = mul i32 %13, 10
  %conv.i.i = zext i32 %mul.i.i to i64
  %cmp.i.i = icmp eq i32 %mul.i.i, 0
  %spec.store.select.i.i = select i1 %cmp.i.i, i64 9223372036854775806, i64 %conv.i.i
  %sub.i.i = sub i64 %11, %12
  %gcdept.i.i = getelementptr inbounds %struct.global_State, ptr %10, i64 0, i32 16
  %14 = load i64, ptr %gcdept.i.i, align 8
  %add.i.i = add i64 %sub.i.i, %14
  store i64 %add.i.i, ptr %gcdept.i.i, align 8
  %gcstate.i.i = getelementptr inbounds %struct.global_State, ptr %10, i64 0, i32 4
  br label %do.body.i.i

do.body.i.i:                                      ; preds = %do.body.i.i, %if.then.i
  %lim.0.i.i = phi i64 [ %spec.store.select.i.i, %if.then.i ], [ %sub2.i.i, %do.body.i.i ]
  %call.i.i = tail call fastcc i64 @singlestep(ptr noundef %L)
  %sub2.i.i = sub nsw i64 %lim.0.i.i, %call.i.i
  %15 = load i8, ptr %gcstate.i.i, align 1
  %cmp4.i.i = icmp ne i8 %15, 0
  %cmp8.i.i = icmp sgt i64 %sub2.i.i, 0
  %or.cond.i.i = select i1 %cmp4.i.i, i1 %cmp8.i.i, i1 false
  br i1 %or.cond.i.i, label %do.body.i.i, label %do.end.i.i, !llvm.loop !6

do.end.i.i:                                       ; preds = %do.body.i.i
  br i1 %cmp4.i.i, label %if.then14.i.i, label %if.else27.i.i

if.then14.i.i:                                    ; preds = %do.end.i.i
  %16 = load i64, ptr %gcdept.i.i, align 8
  %cmp16.i.i = icmp ult i64 %16, 1024
  br i1 %cmp16.i.i, label %if.then18.i.i, label %if.else.i.i

if.then18.i.i:                                    ; preds = %if.then14.i.i
  %17 = load i64, ptr %totalbytes.i, align 8
  %add20.i.i = add i64 %17, 1024
  br label %luaC_step.exit.i

if.else.i.i:                                      ; preds = %if.then14.i.i
  %sub23.i.i = add i64 %16, -1024
  store i64 %sub23.i.i, ptr %gcdept.i.i, align 8
  %18 = load i64, ptr %totalbytes.i, align 8
  br label %luaC_step.exit.i

if.else27.i.i:                                    ; preds = %do.end.i.i
  %estimate.i.i = getelementptr inbounds %struct.global_State, ptr %10, i64 0, i32 15
  %19 = load i64, ptr %estimate.i.i, align 8
  %div.i.i = udiv i64 %19, 100
  %gcpause.i.i = getelementptr inbounds %struct.global_State, ptr %10, i64 0, i32 17
  %20 = load i32, ptr %gcpause.i.i, align 8
  %conv28.i.i = sext i32 %20 to i64
  %mul29.i.i = mul i64 %div.i.i, %conv28.i.i
  br label %luaC_step.exit.i

luaC_step.exit.i:                                 ; preds = %if.else27.i.i, %if.else.i.i, %if.then18.i.i
  %add20.sink.i.i = phi i64 [ %add20.i.i, %if.then18.i.i ], [ %18, %if.else.i.i ], [ %mul29.i.i, %if.else27.i.i ]
  store i64 %add20.sink.i.i, ptr %GCthreshold.i, align 8
  %.pre = load ptr, ptr %top.i, align 8
  br label %lua_createtable.exit

lua_createtable.exit:                             ; preds = %if.then4, %luaC_step.exit.i
  %21 = phi ptr [ %6, %if.then4 ], [ %.pre, %luaC_step.exit.i ]
  %call.i = tail call fastcc ptr @luaH_new(ptr noundef nonnull %L, i32 noundef 0, i32 noundef 0)
  store ptr %call.i, ptr %21, align 8
  %tt.i22 = getelementptr inbounds %struct.lua_TValue, ptr %21, i64 0, i32 1
  store i32 5, ptr %tt.i22, align 8
  %22 = load ptr, ptr %top.i, align 8
  %incdec.ptr.i23 = getelementptr inbounds %struct.lua_TValue, ptr %22, i64 1
  store ptr %incdec.ptr.i23, ptr %top.i, align 8
  %23 = load i64, ptr %22, align 8
  store i64 %23, ptr %incdec.ptr.i23, align 8
  %tt.i26 = getelementptr inbounds %struct.lua_TValue, ptr %22, i64 0, i32 1
  %24 = load i32, ptr %tt.i26, align 8
  %tt2.i = getelementptr inbounds %struct.lua_TValue, ptr %22, i64 1, i32 1
  store i32 %24, ptr %tt2.i, align 8
  %25 = load ptr, ptr %top.i, align 8
  %incdec.ptr.i27 = getelementptr inbounds %struct.lua_TValue, ptr %25, i64 1
  store ptr %incdec.ptr.i27, ptr %top.i, align 8
  store i32 1, ptr %incdec.ptr.i27, align 8
  %tt.i29 = getelementptr inbounds %struct.lua_TValue, ptr %25, i64 1, i32 1
  store i32 1, ptr %tt.i29, align 8
  %26 = load ptr, ptr %top.i, align 8
  %incdec.ptr.i30 = getelementptr inbounds %struct.lua_TValue, ptr %26, i64 1
  store ptr %incdec.ptr.i30, ptr %top.i, align 8
  %ci17.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %27 = load ptr, ptr %ci17.i.i, align 8
  %func18.i.i = getelementptr inbounds %struct.CallInfo, ptr %27, i64 0, i32 1
  %28 = load ptr, ptr %func18.i.i, align 8
  %29 = load ptr, ptr %28, align 8
  %nupvalues.i.i = getelementptr inbounds %struct.CClosure, ptr %29, i64 0, i32 4
  %30 = load i8, ptr %nupvalues.i.i, align 1
  %cmp21.not.i.i = icmp eq i8 %30, 0
  %arrayidx.i.i = getelementptr inbounds %struct.CClosure, ptr %29, i64 0, i32 8, i64 0
  %cond.i.i = select i1 %cmp21.not.i.i, ptr @luaO_nilobject_, ptr %arrayidx.i.i
  %31 = load ptr, ptr %cond.i.i, align 8
  %add.ptr2.i = getelementptr inbounds %struct.lua_TValue, ptr %26, i64 -1
  %call.i.i33 = tail call fastcc ptr @luaH_get(ptr noundef %31, ptr noundef nonnull %add.ptr2.i)
  %flags.i.i = getelementptr inbounds %struct.Table, ptr %31, i64 0, i32 3
  store i8 0, ptr %flags.i.i, align 2
  %cmp.not.i.i = icmp eq ptr %call.i.i33, @luaO_nilobject_
  br i1 %cmp.not.i.i, label %if.else.i.i37, label %luaH_set.exit.i

if.else.i.i37:                                    ; preds = %lua_createtable.exit
  %tt.i.i = getelementptr %struct.lua_TValue, ptr %26, i64 -1, i32 1
  %32 = load i32, ptr %tt.i.i, align 8
  switch i32 %32, label %if.end9.i.i [
    i32 0, label %if.then2.i.i
    i32 3, label %land.lhs.true.i.i
  ]

if.then2.i.i:                                     ; preds = %if.else.i.i37
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef nonnull %L, ptr noundef nonnull @.str.39)
  unreachable

land.lhs.true.i.i:                                ; preds = %if.else.i.i37
  %33 = load double, ptr %add.ptr2.i, align 8
  %cmp7.i.i = fcmp ord double %33, 0.000000e+00
  br i1 %cmp7.i.i, label %if.end9.i.i, label %if.then8.i.i

if.then8.i.i:                                     ; preds = %land.lhs.true.i.i
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef nonnull %L, ptr noundef nonnull @.str.40)
  unreachable

if.end9.i.i:                                      ; preds = %land.lhs.true.i.i, %if.else.i.i37
  %call10.i.i = tail call fastcc ptr @newkey(ptr noundef nonnull %L, ptr noundef nonnull %31, ptr noundef nonnull %add.ptr2.i)
  br label %luaH_set.exit.i

luaH_set.exit.i:                                  ; preds = %if.end9.i.i, %lua_createtable.exit
  %retval.0.i.i = phi ptr [ %call10.i.i, %if.end9.i.i ], [ %call.i.i33, %lua_createtable.exit ]
  %34 = load i64, ptr %26, align 8
  store i64 %34, ptr %retval.0.i.i, align 8
  %tt.i34 = getelementptr %struct.lua_TValue, ptr %26, i64 0, i32 1
  %35 = load i32, ptr %tt.i34, align 8
  %tt6.i = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i.i, i64 0, i32 1
  store i32 %35, ptr %tt6.i, align 8
  %36 = load ptr, ptr %top.i, align 8
  %tt9.i = getelementptr %struct.lua_TValue, ptr %36, i64 -1, i32 1
  %37 = load i32, ptr %tt9.i, align 8
  %cmp.i35 = icmp sgt i32 %37, 3
  br i1 %cmp.i35, label %land.lhs.true.i, label %lua_rawset.exit

land.lhs.true.i:                                  ; preds = %luaH_set.exit.i
  %add.ptr8.i = getelementptr inbounds %struct.lua_TValue, ptr %36, i64 -1
  %38 = load ptr, ptr %add.ptr8.i, align 8
  %marked.i = getelementptr inbounds %struct.GCheader, ptr %38, i64 0, i32 2
  %39 = load i8, ptr %marked.i, align 1
  %40 = and i8 %39, 3
  %tobool.not.i = icmp eq i8 %40, 0
  br i1 %tobool.not.i, label %lua_rawset.exit, label %land.lhs.true13.i

land.lhs.true13.i:                                ; preds = %land.lhs.true.i
  %41 = load ptr, ptr %cond.i.i, align 8
  %marked15.i = getelementptr inbounds %struct.GCheader, ptr %41, i64 0, i32 2
  %42 = load i8, ptr %marked15.i, align 1
  %43 = and i8 %42, 4
  %tobool18.not.i = icmp eq i8 %43, 0
  br i1 %tobool18.not.i, label %lua_rawset.exit, label %if.then.i36

if.then.i36:                                      ; preds = %land.lhs.true13.i
  %L.val.i = load ptr, ptr %l_G.i, align 8
  %44 = and i8 %42, -5
  store i8 %44, ptr %marked15.i, align 1
  %grayagain.i.i = getelementptr inbounds %struct.global_State, ptr %L.val.i, i64 0, i32 9
  %45 = load ptr, ptr %grayagain.i.i, align 8
  %gclist.i.i = getelementptr inbounds %struct.Table, ptr %41, i64 0, i32 9
  store ptr %45, ptr %gclist.i.i, align 8
  store ptr %41, ptr %grayagain.i.i, align 8
  %.pre.i = load ptr, ptr %top.i, align 8
  br label %lua_rawset.exit

lua_rawset.exit:                                  ; preds = %luaH_set.exit.i, %land.lhs.true.i, %land.lhs.true13.i, %if.then.i36
  %46 = phi ptr [ %.pre.i, %if.then.i36 ], [ %36, %land.lhs.true13.i ], [ %36, %land.lhs.true.i ], [ %36, %luaH_set.exit.i ]
  %add.ptr21.i = getelementptr inbounds %struct.lua_TValue, ptr %46, i64 -2
  br label %if.end14.sink.split

if.else5:                                         ; preds = %if.else, %lua_type.exit
  %cmp1.not.i.i40 = icmp ult ptr %5, %6
  %add.ptr.luaO_nilobject_.i.i41 = select i1 %cmp1.not.i.i40, ptr %5, ptr @luaO_nilobject_
  %tt.i42 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i41, i64 0, i32 1
  %47 = load i32, ptr %tt.i42, align 8
  switch i32 %47, label %sw.default.i [
    i32 5, label %sw.bb.i
    i32 7, label %sw.bb1.i
  ]

sw.bb.i:                                          ; preds = %if.else5
  %48 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i41, align 8
  %metatable.i = getelementptr inbounds %struct.Table, ptr %48, i64 0, i32 5
  br label %sw.epilog.i

sw.bb1.i:                                         ; preds = %if.else5
  %49 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i41, align 8
  %metatable3.i = getelementptr inbounds %struct.anon.1, ptr %49, i64 0, i32 3
  br label %sw.epilog.i

sw.default.i:                                     ; preds = %if.else5
  %l_G.i45 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %50 = load ptr, ptr %l_G.i45, align 8
  %idxprom.i = sext i32 %47 to i64
  %arrayidx.i = getelementptr inbounds %struct.global_State, ptr %50, i64 0, i32 23, i64 %idxprom.i
  br label %sw.epilog.i

sw.epilog.i:                                      ; preds = %sw.default.i, %sw.bb1.i, %sw.bb.i
  %mt.0.in.i = phi ptr [ %arrayidx.i, %sw.default.i ], [ %metatable3.i, %sw.bb1.i ], [ %metatable.i, %sw.bb.i ]
  %mt.0.i = load ptr, ptr %mt.0.in.i, align 8
  %cmp.i43 = icmp eq ptr %mt.0.i, null
  br i1 %cmp.i43, label %lor.rhs, label %if.then7

if.then7:                                         ; preds = %sw.epilog.i
  store ptr %mt.0.i, ptr %6, align 8
  %tt7.i = getelementptr inbounds %struct.lua_TValue, ptr %6, i64 0, i32 1
  store i32 5, ptr %tt7.i, align 8
  %51 = load ptr, ptr %top.i, align 8
  %incdec.ptr.i44 = getelementptr inbounds %struct.lua_TValue, ptr %51, i64 1
  store ptr %incdec.ptr.i44, ptr %top.i, align 8
  %ci17.i.i46 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %52 = load ptr, ptr %ci17.i.i46, align 8
  %func18.i.i47 = getelementptr inbounds %struct.CallInfo, ptr %52, i64 0, i32 1
  %53 = load ptr, ptr %func18.i.i47, align 8
  %54 = load ptr, ptr %53, align 8
  %nupvalues.i.i48 = getelementptr inbounds %struct.CClosure, ptr %54, i64 0, i32 4
  %55 = load i8, ptr %nupvalues.i.i48, align 1
  %cmp21.not.i.i50 = icmp eq i8 %55, 0
  %arrayidx.i.i51 = getelementptr inbounds %struct.CClosure, ptr %54, i64 0, i32 8, i64 0
  %cond.i.i52 = select i1 %cmp21.not.i.i50, ptr @luaO_nilobject_, ptr %arrayidx.i.i51
  %56 = load ptr, ptr %cond.i.i52, align 8
  %call1.i = tail call fastcc ptr @luaH_get(ptr noundef %56, ptr noundef nonnull %51)
  %57 = load i64, ptr %call1.i, align 8
  store i64 %57, ptr %51, align 8
  %tt.i57 = getelementptr inbounds %struct.lua_TValue, ptr %call1.i, i64 0, i32 1
  %58 = load i32, ptr %tt.i57, align 8
  %tt6.i58 = getelementptr %struct.lua_TValue, ptr %51, i64 0, i32 1
  store i32 %58, ptr %tt6.i58, align 8
  %59 = load ptr, ptr %top.i, align 8
  %tt.i63 = getelementptr %struct.lua_TValue, ptr %59, i64 -1, i32 1
  %60 = load i32, ptr %tt.i63, align 8
  %add.ptr9.i107 = getelementptr %struct.lua_TValue, ptr %59, i64 -1
  switch i32 %60, label %lua_toboolean.exit68.thread105 [
    i32 0, label %lua_toboolean.exit68.thread
    i32 1, label %lua_toboolean.exit68
  ]

lua_toboolean.exit68.thread:                      ; preds = %if.then7
  store ptr %add.ptr9.i107, ptr %top.i, align 8
  br label %lor.rhs

lua_toboolean.exit68.thread105:                   ; preds = %if.then7
  store ptr %add.ptr9.i107, ptr %top.i, align 8
  br label %lor.end

lua_toboolean.exit68:                             ; preds = %if.then7
  %61 = load i32, ptr %add.ptr9.i107, align 8
  %cmp3.i65.not = icmp eq i32 %61, 0
  store ptr %add.ptr9.i107, ptr %top.i, align 8
  br i1 %cmp3.i65.not, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %sw.epilog.i, %lua_toboolean.exit68.thread, %lua_toboolean.exit68
  tail call fastcc void @luaL_argerror(ptr noundef nonnull %L, i32 noundef 1, ptr noundef nonnull @.str.186)
  unreachable

lor.end:                                          ; preds = %lua_toboolean.exit68.thread105, %lua_toboolean.exit68
  %62 = load ptr, ptr %base.i, align 8
  %cmp1.not.i.i74 = icmp ult ptr %62, %add.ptr9.i107
  %add.ptr.luaO_nilobject_.i.i75 = select i1 %cmp1.not.i.i74, ptr %62, ptr @luaO_nilobject_
  %tt.i76 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i75, i64 0, i32 1
  %63 = load i32, ptr %tt.i76, align 8
  switch i32 %63, label %sw.default.i89 [
    i32 5, label %sw.bb.i87
    i32 7, label %sw.bb1.i77
  ]

sw.bb.i87:                                        ; preds = %lor.end
  %64 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i75, align 8
  %metatable.i88 = getelementptr inbounds %struct.Table, ptr %64, i64 0, i32 5
  br label %sw.epilog.i79

sw.bb1.i77:                                       ; preds = %lor.end
  %65 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i75, align 8
  %metatable3.i78 = getelementptr inbounds %struct.anon.1, ptr %65, i64 0, i32 3
  br label %sw.epilog.i79

sw.default.i89:                                   ; preds = %lor.end
  %l_G.i90 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %66 = load ptr, ptr %l_G.i90, align 8
  %idxprom.i91 = sext i32 %63 to i64
  %arrayidx.i92 = getelementptr inbounds %struct.global_State, ptr %66, i64 0, i32 23, i64 %idxprom.i91
  br label %sw.epilog.i79

sw.epilog.i79:                                    ; preds = %sw.default.i89, %sw.bb1.i77, %sw.bb.i87
  %mt.0.in.i80 = phi ptr [ %arrayidx.i92, %sw.default.i89 ], [ %metatable3.i78, %sw.bb1.i77 ], [ %metatable.i88, %sw.bb.i87 ]
  %mt.0.i81 = load ptr, ptr %mt.0.in.i80, align 8
  %cmp.i82 = icmp eq ptr %mt.0.i81, null
  br i1 %cmp.i82, label %if.end14, label %if.else.i83

if.else.i83:                                      ; preds = %sw.epilog.i79
  store ptr %mt.0.i81, ptr %add.ptr9.i107, align 8
  %tt7.i84 = getelementptr %struct.lua_TValue, ptr %59, i64 -1, i32 1
  store i32 5, ptr %tt7.i84, align 8
  %67 = load ptr, ptr %top.i, align 8
  %incdec.ptr.i85 = getelementptr inbounds %struct.lua_TValue, ptr %67, i64 1
  br label %if.end14.sink.split

if.end14.sink.split:                              ; preds = %lua_rawset.exit, %if.else.i83
  %incdec.ptr.i85.sink = phi ptr [ %incdec.ptr.i85, %if.else.i83 ], [ %add.ptr21.i, %lua_rawset.exit ]
  store ptr %incdec.ptr.i85.sink, ptr %top.i, align 8
  br label %if.end14

if.end14:                                         ; preds = %if.end14.sink.split, %sw.epilog.i79
  tail call fastcc void @lua_setmetatable(ptr noundef nonnull %L, i32 noundef 2)
  br label %return

return:                                           ; preds = %lua_settop.exit, %lua_toboolean.exit, %if.end14
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_assert(ptr noundef %L) #0 {
entry:
  %base.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i.i, align 8
  %top.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i.i = icmp uge ptr %0, %1
  %cmp.i.i = icmp eq ptr %0, @luaO_nilobject_
  %or.cond = or i1 %cmp.i.i, %cmp1.not.i.i.i
  br i1 %or.cond, label %if.then.i, label %lua_type.exit.i

lua_type.exit.i:                                  ; preds = %entry
  %tt.i.i = getelementptr inbounds %struct.lua_TValue, ptr %0, i64 0, i32 1
  %2 = load i32, ptr %tt.i.i, align 8
  switch i32 %2, label %if.end [
    i32 -1, label %if.then.i
    i32 0, label %if.then
    i32 1, label %lua_toboolean.exit
  ]

if.then.i:                                        ; preds = %lua_type.exit.i, %entry
  tail call fastcc void @luaL_argerror(ptr noundef nonnull %L, i32 noundef 1, ptr noundef nonnull @.str.115)
  unreachable

lua_toboolean.exit:                               ; preds = %lua_type.exit.i
  %3 = load i32, ptr %0, align 8
  %cmp3.i.not = icmp eq i32 %3, 0
  br i1 %cmp3.i.not, label %if.then, label %if.end

if.then:                                          ; preds = %lua_type.exit.i, %lua_toboolean.exit
  %add.ptr.i.i.i7 = getelementptr %struct.lua_TValue, ptr %0, i64 1
  %cmp1.not.i.i.i9 = icmp uge ptr %add.ptr.i.i.i7, %1
  %cmp.i.i12 = icmp eq ptr %add.ptr.i.i.i7, @luaO_nilobject_
  %or.cond21 = or i1 %cmp1.not.i.i.i9, %cmp.i.i12
  br i1 %or.cond21, label %luaL_optlstring.exit, label %lua_type.exit.i13

lua_type.exit.i13:                                ; preds = %if.then
  %tt.i.i14 = getelementptr %struct.lua_TValue, ptr %0, i64 1, i32 1
  %4 = load i32, ptr %tt.i.i14, align 8
  %cmp.i15 = icmp slt i32 %4, 1
  br i1 %cmp.i15, label %luaL_optlstring.exit, label %if.else.i

if.else.i:                                        ; preds = %lua_type.exit.i13
  %call.i.i = tail call fastcc ptr @lua_tolstring(ptr noundef nonnull %L, i32 noundef 2, ptr noundef null)
  %tobool.not.i.i = icmp eq ptr %call.i.i, null
  br i1 %tobool.not.i.i, label %if.then.i.i, label %luaL_optlstring.exit

if.then.i.i:                                      ; preds = %if.else.i
  tail call fastcc void @luaL_typerror(ptr noundef nonnull %L, i32 noundef 2, ptr noundef nonnull @.str.25)
  unreachable

luaL_optlstring.exit:                             ; preds = %if.then, %lua_type.exit.i13, %if.else.i
  %retval.0.i = phi ptr [ %call.i.i, %if.else.i ], [ @.str.114, %lua_type.exit.i13 ], [ @.str.114, %if.then ]
  tail call void (ptr, ptr, ...) @luaL_error(ptr noundef nonnull %L, ptr noundef nonnull @.str.113, ptr noundef nonnull %retval.0.i)
  unreachable

if.end:                                           ; preds = %lua_type.exit.i, %lua_toboolean.exit
  %sub.ptr.lhs.cast.i = ptrtoint ptr %1 to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %0 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %sub.ptr.div.i = lshr exact i64 %sub.ptr.sub.i, 4
  %conv.i = trunc i64 %sub.ptr.div.i to i32
  ret i32 %conv.i
}

; Function Attrs: noreturn nounwind uwtable
define internal i32 @luaB_error(ptr noundef %L) #7 {
entry:
  %endptr.i.i.i = alloca ptr, align 8
  %base.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i.i, align 8
  %add.ptr.i.i.i = getelementptr %struct.lua_TValue, ptr %0, i64 1
  %top.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i.i = icmp uge ptr %add.ptr.i.i.i, %1
  %cmp.i.i = icmp eq ptr %add.ptr.i.i.i, @luaO_nilobject_
  %or.cond39 = or i1 %cmp1.not.i.i.i, %cmp.i.i
  br i1 %or.cond39, label %luaL_optinteger.exit, label %lua_type.exit.i

lua_type.exit.i:                                  ; preds = %entry
  %tt.i.i = getelementptr %struct.lua_TValue, ptr %0, i64 1, i32 1
  %2 = load i32, ptr %tt.i.i, align 8
  %cmp.i = icmp slt i32 %2, 1
  br i1 %cmp.i, label %luaL_optinteger.exit, label %cond.false.i

cond.false.i:                                     ; preds = %lua_type.exit.i
  %call.i.i = tail call fastcc i64 @lua_tointeger(ptr noundef nonnull %L, i32 noundef 2)
  %cmp.i3.i = icmp eq i64 %call.i.i, 0
  br i1 %cmp.i3.i, label %land.lhs.true.i.i, label %luaL_optinteger.exit

land.lhs.true.i.i:                                ; preds = %cond.false.i
  %3 = load ptr, ptr %base.i.i.i, align 8
  %add.ptr.i.i27 = getelementptr %struct.lua_TValue, ptr %3, i64 1
  %4 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i29 = icmp ult ptr %add.ptr.i.i27, %4
  %add.ptr.luaO_nilobject_.i.i30 = select i1 %cmp1.not.i.i29, ptr %add.ptr.i.i27, ptr @luaO_nilobject_
  %tt.i31 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i30, i64 0, i32 1
  %5 = load i32, ptr %tt.i31, align 8
  switch i32 %5, label %if.then.i.i [
    i32 3, label %luaL_optinteger.exit
    i32 4, label %land.lhs.true.i.i32
  ]

land.lhs.true.i.i32:                              ; preds = %land.lhs.true.i.i
  %6 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i30, align 8
  %add.ptr.i3.i = getelementptr inbounds %union.TString, ptr %6, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i.i)
  %call.i.i.i = call double @strtod(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i) #35
  %7 = load ptr, ptr %endptr.i.i.i, align 8
  %cmp.i.i.i = icmp eq ptr %7, %add.ptr.i3.i
  br i1 %cmp.i.i.i, label %luaO_str2d.exit.thread.i.i, label %if.end.i.i.i

luaO_str2d.exit.thread.i.i:                       ; preds = %land.lhs.true.i.i32
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %if.then.i.i

if.end.i.i.i:                                     ; preds = %land.lhs.true.i.i32
  %8 = load i8, ptr %7, align 1
  switch i8 %8, label %if.end9.i.i.i [
    i8 120, label %if.then6.i.i.i
    i8 88, label %if.then6.i.i.i
  ]

if.then6.i.i.i:                                   ; preds = %if.end.i.i.i, %if.end.i.i.i
  %call7.i.i.i = call i64 @strtoul(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i, i32 noundef 16) #35
  %.pre.i.i.i = load ptr, ptr %endptr.i.i.i, align 8
  %.pre5.i.i.i = load i8, ptr %.pre.i.i.i, align 1
  br label %if.end9.i.i.i

if.end9.i.i.i:                                    ; preds = %if.then6.i.i.i, %if.end.i.i.i
  %9 = phi i8 [ %8, %if.end.i.i.i ], [ %.pre5.i.i.i, %if.then6.i.i.i ]
  %endptr.promoted.i.i.i = phi ptr [ %7, %if.end.i.i.i ], [ %.pre.i.i.i, %if.then6.i.i.i ]
  %cmp11.i.i.i = icmp eq i8 %9, 0
  br i1 %cmp11.i.i.i, label %luaO_str2d.exit.thread9.i.i, label %while.cond.preheader.i.i.i

luaO_str2d.exit.thread9.i.i:                      ; preds = %if.end9.i.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %luaL_optinteger.exit

while.cond.preheader.i.i.i:                       ; preds = %if.end9.i.i.i
  %call15.i.i.i = tail call ptr @__ctype_b_loc() #39
  %10 = load ptr, ptr %call15.i.i.i, align 8
  br label %while.cond.i.i.i

while.cond.i.i.i:                                 ; preds = %while.cond.i.i.i, %while.cond.preheader.i.i.i
  %incdec.ptr4.i.i.i = phi ptr [ %endptr.promoted.i.i.i, %while.cond.preheader.i.i.i ], [ %incdec.ptr.i.i.i, %while.cond.i.i.i ]
  %11 = load i8, ptr %incdec.ptr4.i.i.i, align 1
  %idxprom.i.i.i = zext i8 %11 to i64
  %arrayidx.i.i.i = getelementptr inbounds i16, ptr %10, i64 %idxprom.i.i.i
  %12 = load i16, ptr %arrayidx.i.i.i, align 2
  %13 = and i16 %12, 8192
  %tobool.not.i.i.i = icmp eq i16 %13, 0
  %incdec.ptr.i.i.i = getelementptr inbounds i8, ptr %incdec.ptr4.i.i.i, i64 1
  br i1 %tobool.not.i.i.i, label %luaO_str2d.exit.i.i, label %while.cond.i.i.i, !llvm.loop !35

luaO_str2d.exit.i.i:                              ; preds = %while.cond.i.i.i
  %cmp19.not.i.not.i.i = icmp eq i8 %11, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br i1 %cmp19.not.i.not.i.i, label %luaL_optinteger.exit, label %if.then.i.i

if.then.i.i:                                      ; preds = %land.lhs.true.i.i, %luaO_str2d.exit.i.i, %luaO_str2d.exit.thread.i.i
  tail call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 2, ptr noundef nonnull @.str.24)
  unreachable

luaL_optinteger.exit:                             ; preds = %luaO_str2d.exit.thread9.i.i, %luaO_str2d.exit.i.i, %land.lhs.true.i.i, %entry, %lua_type.exit.i, %cond.false.i
  %cond.i = phi i64 [ 1, %lua_type.exit.i ], [ %call.i.i, %cond.false.i ], [ 1, %entry ], [ 0, %land.lhs.true.i.i ], [ 0, %luaO_str2d.exit.i.i ], [ 0, %luaO_str2d.exit.thread9.i.i ]
  %conv = trunc i64 %cond.i to i32
  %14 = load ptr, ptr %top.i.i.i, align 8
  %15 = load ptr, ptr %base.i.i.i, align 8
  %add.ptr10.i = getelementptr inbounds %struct.lua_TValue, ptr %15, i64 1
  %cmp111.i = icmp ult ptr %14, %add.ptr10.i
  br i1 %cmp111.i, label %while.body.i, label %lua_settop.exit

while.body.i:                                     ; preds = %luaL_optinteger.exit, %while.body.i
  %16 = phi ptr [ %17, %while.body.i ], [ %14, %luaL_optinteger.exit ]
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %16, i64 1
  store ptr %incdec.ptr.i, ptr %top.i.i.i, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %16, i64 0, i32 1
  store i32 0, ptr %tt.i, align 8
  %17 = load ptr, ptr %top.i.i.i, align 8
  %18 = load ptr, ptr %base.i.i.i, align 8
  %add.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %18, i64 1
  %cmp1.i = icmp ult ptr %17, %add.ptr.i
  br i1 %cmp1.i, label %while.body.i, label %lua_settop.exit, !llvm.loop !13

lua_settop.exit:                                  ; preds = %while.body.i, %luaL_optinteger.exit
  %19 = phi ptr [ %15, %luaL_optinteger.exit ], [ %18, %while.body.i ]
  %add.ptr9.sink.i = phi ptr [ %add.ptr10.i, %luaL_optinteger.exit ], [ %add.ptr.i, %while.body.i ]
  store ptr %add.ptr9.sink.i, ptr %top.i.i.i, align 8
  %cmp1.not.i.i.i11 = icmp uge ptr %19, %add.ptr9.sink.i
  %cmp.i.i14 = icmp eq ptr %19, @luaO_nilobject_
  %or.cond40 = or i1 %cmp1.not.i.i.i11, %cmp.i.i14
  br i1 %or.cond40, label %if.end, label %lua_isstring.exit

lua_isstring.exit:                                ; preds = %lua_settop.exit
  %tt.i.i15 = getelementptr inbounds %struct.lua_TValue, ptr %19, i64 0, i32 1
  %20 = load i32, ptr %tt.i.i15, align 8
  %21 = add i32 %20, -3
  %22 = icmp ult i32 %21, 2
  %cmp = icmp sgt i32 %conv, 0
  %or.cond = and i1 %cmp, %22
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %lua_isstring.exit
  tail call fastcc void @luaL_where(ptr noundef nonnull %L, i32 noundef %conv)
  %23 = load ptr, ptr %base.i.i.i, align 8
  %24 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i = icmp ult ptr %23, %24
  %add.ptr.luaO_nilobject_.i.i = select i1 %cmp1.not.i.i, ptr %23, ptr @luaO_nilobject_
  %25 = load i64, ptr %add.ptr.luaO_nilobject_.i.i, align 8
  store i64 %25, ptr %24, align 8
  %tt.i18 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i, i64 0, i32 1
  %26 = load i32, ptr %tt.i18, align 8
  %tt2.i = getelementptr inbounds %struct.lua_TValue, ptr %24, i64 0, i32 1
  store i32 %26, ptr %tt2.i, align 8
  %27 = load ptr, ptr %top.i.i.i, align 8
  %incdec.ptr.i19 = getelementptr inbounds %struct.lua_TValue, ptr %27, i64 1
  store ptr %incdec.ptr.i19, ptr %top.i.i.i, align 8
  %l_G.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %28 = load ptr, ptr %l_G.i, align 8
  %totalbytes.i = getelementptr inbounds %struct.global_State, ptr %28, i64 0, i32 14
  %29 = load i64, ptr %totalbytes.i, align 8
  %GCthreshold.i = getelementptr inbounds %struct.global_State, ptr %28, i64 0, i32 13
  %30 = load i64, ptr %GCthreshold.i, align 8
  %cmp2.not.i = icmp ult i64 %29, %30
  br i1 %cmp2.not.i, label %lua_concat.exit, label %if.then3.i

if.then3.i:                                       ; preds = %if.then
  %gcstepmul.i.i = getelementptr inbounds %struct.global_State, ptr %28, i64 0, i32 18
  %31 = load i32, ptr %gcstepmul.i.i, align 4
  %mul.i.i = mul i32 %31, 10
  %conv.i.i = zext i32 %mul.i.i to i64
  %cmp.i.i20 = icmp eq i32 %mul.i.i, 0
  %spec.store.select.i.i = select i1 %cmp.i.i20, i64 9223372036854775806, i64 %conv.i.i
  %sub.i.i = sub i64 %29, %30
  %gcdept.i.i = getelementptr inbounds %struct.global_State, ptr %28, i64 0, i32 16
  %32 = load i64, ptr %gcdept.i.i, align 8
  %add.i.i = add i64 %sub.i.i, %32
  store i64 %add.i.i, ptr %gcdept.i.i, align 8
  %gcstate.i.i = getelementptr inbounds %struct.global_State, ptr %28, i64 0, i32 4
  br label %do.body.i.i

do.body.i.i:                                      ; preds = %do.body.i.i, %if.then3.i
  %lim.0.i.i = phi i64 [ %spec.store.select.i.i, %if.then3.i ], [ %sub2.i.i, %do.body.i.i ]
  %call.i.i21 = tail call fastcc i64 @singlestep(ptr noundef %L)
  %sub2.i.i = sub nsw i64 %lim.0.i.i, %call.i.i21
  %33 = load i8, ptr %gcstate.i.i, align 1
  %cmp4.i.i = icmp ne i8 %33, 0
  %cmp8.i.i = icmp sgt i64 %sub2.i.i, 0
  %or.cond.i.i = select i1 %cmp4.i.i, i1 %cmp8.i.i, i1 false
  br i1 %or.cond.i.i, label %do.body.i.i, label %do.end.i.i, !llvm.loop !6

do.end.i.i:                                       ; preds = %do.body.i.i
  br i1 %cmp4.i.i, label %if.then14.i.i, label %if.else27.i.i

if.then14.i.i:                                    ; preds = %do.end.i.i
  %34 = load i64, ptr %gcdept.i.i, align 8
  %cmp16.i.i = icmp ult i64 %34, 1024
  br i1 %cmp16.i.i, label %if.then18.i.i, label %if.else.i.i

if.then18.i.i:                                    ; preds = %if.then14.i.i
  %35 = load i64, ptr %totalbytes.i, align 8
  %add20.i.i = add i64 %35, 1024
  br label %luaC_step.exit.i

if.else.i.i:                                      ; preds = %if.then14.i.i
  %sub23.i.i = add i64 %34, -1024
  store i64 %sub23.i.i, ptr %gcdept.i.i, align 8
  %36 = load i64, ptr %totalbytes.i, align 8
  br label %luaC_step.exit.i

if.else27.i.i:                                    ; preds = %do.end.i.i
  %estimate.i.i = getelementptr inbounds %struct.global_State, ptr %28, i64 0, i32 15
  %37 = load i64, ptr %estimate.i.i, align 8
  %div.i.i = udiv i64 %37, 100
  %gcpause.i.i = getelementptr inbounds %struct.global_State, ptr %28, i64 0, i32 17
  %38 = load i32, ptr %gcpause.i.i, align 8
  %conv28.i.i = sext i32 %38 to i64
  %mul29.i.i = mul i64 %div.i.i, %conv28.i.i
  br label %luaC_step.exit.i

luaC_step.exit.i:                                 ; preds = %if.else27.i.i, %if.else.i.i, %if.then18.i.i
  %add20.sink.i.i = phi i64 [ %add20.i.i, %if.then18.i.i ], [ %36, %if.else.i.i ], [ %mul29.i.i, %if.else27.i.i ]
  store i64 %add20.sink.i.i, ptr %GCthreshold.i, align 8
  %.pre = load ptr, ptr %top.i.i.i, align 8
  br label %lua_concat.exit

lua_concat.exit:                                  ; preds = %if.then, %luaC_step.exit.i
  %39 = phi ptr [ %incdec.ptr.i19, %if.then ], [ %.pre, %luaC_step.exit.i ]
  %40 = load ptr, ptr %base.i.i.i, align 8
  %sub.ptr.lhs.cast.i = ptrtoint ptr %39 to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %40 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %sub.ptr.div.i = lshr exact i64 %sub.ptr.sub.i, 4
  %conv.i = trunc i64 %sub.ptr.div.i to i32
  %sub.i = add nsw i32 %conv.i, -1
  tail call fastcc void @luaV_concat(ptr noundef nonnull %L, i32 noundef 2, i32 noundef %sub.i)
  %41 = load ptr, ptr %top.i.i.i, align 8
  %add.ptr.i24 = getelementptr inbounds %struct.lua_TValue, ptr %41, i64 -1
  store ptr %add.ptr.i24, ptr %top.i.i.i, align 8
  br label %if.end

if.end:                                           ; preds = %lua_settop.exit, %lua_concat.exit, %lua_isstring.exit
  tail call fastcc void @luaG_errormsg(ptr noundef nonnull %L)
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_loadfile(ptr noundef %L) #0 {
entry:
  %base.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i.i, align 8
  %top.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i.i = icmp uge ptr %0, %1
  %cmp.i.i = icmp eq ptr %0, @luaO_nilobject_
  %or.cond = or i1 %cmp.i.i, %cmp1.not.i.i.i
  br i1 %or.cond, label %luaL_optlstring.exit, label %lua_type.exit.i

lua_type.exit.i:                                  ; preds = %entry
  %tt.i.i = getelementptr inbounds %struct.lua_TValue, ptr %0, i64 0, i32 1
  %2 = load i32, ptr %tt.i.i, align 8
  %cmp.i = icmp slt i32 %2, 1
  br i1 %cmp.i, label %luaL_optlstring.exit, label %if.else.i

if.else.i:                                        ; preds = %lua_type.exit.i
  %call.i.i = tail call fastcc ptr @lua_tolstring(ptr noundef nonnull %L, i32 noundef 1, ptr noundef null)
  %tobool.not.i.i = icmp eq ptr %call.i.i, null
  br i1 %tobool.not.i.i, label %if.then.i.i, label %luaL_optlstring.exit

if.then.i.i:                                      ; preds = %if.else.i
  tail call fastcc void @luaL_typerror(ptr noundef nonnull %L, i32 noundef 1, ptr noundef nonnull @.str.25)
  unreachable

luaL_optlstring.exit:                             ; preds = %entry, %lua_type.exit.i, %if.else.i
  %retval.0.i = phi ptr [ %call.i.i, %if.else.i ], [ null, %lua_type.exit.i ], [ null, %entry ]
  %call1 = tail call fastcc i32 @luaL_loadfile(ptr noundef nonnull %L, ptr noundef %retval.0.i)
  %cmp.i3 = icmp eq i32 %call1, 0
  br i1 %cmp.i3, label %load_aux.exit, label %if.else.i4

if.else.i4:                                       ; preds = %luaL_optlstring.exit
  %3 = load ptr, ptr %top.i.i.i, align 8
  %tt.i.i5 = getelementptr inbounds %struct.lua_TValue, ptr %3, i64 0, i32 1
  store i32 0, ptr %tt.i.i5, align 8
  %4 = load ptr, ptr %top.i.i.i, align 8
  %incdec.ptr.i.i = getelementptr inbounds %struct.lua_TValue, ptr %4, i64 1
  store ptr %incdec.ptr.i.i, ptr %top.i.i.i, align 8
  br label %for.body.i.i

for.body.i.i:                                     ; preds = %for.body.i.i, %if.else.i4
  %q.012.i.i = phi ptr [ %add.ptr.i.i, %for.body.i.i ], [ %incdec.ptr.i.i, %if.else.i4 ]
  %add.ptr.i.i = getelementptr inbounds %struct.lua_TValue, ptr %q.012.i.i, i64 -1
  %5 = load i64, ptr %add.ptr.i.i, align 8
  store i64 %5, ptr %q.012.i.i, align 8
  %tt.i3.i = getelementptr %struct.lua_TValue, ptr %q.012.i.i, i64 -1, i32 1
  %6 = load i32, ptr %tt.i3.i, align 8
  %tt2.i.i = getelementptr inbounds %struct.lua_TValue, ptr %q.012.i.i, i64 0, i32 1
  store i32 %6, ptr %tt2.i.i, align 8
  %cmp.i.i6 = icmp ugt ptr %q.012.i.i, %4
  br i1 %cmp.i.i6, label %for.body.i.i, label %lua_insert.exit.i, !llvm.loop !86

lua_insert.exit.i:                                ; preds = %for.body.i.i
  %add.ptr8.i.i.i = getelementptr inbounds %struct.lua_TValue, ptr %4, i64 -1
  %.pre.i.i = load ptr, ptr %top.i.i.i, align 8
  %7 = load i64, ptr %.pre.i.i, align 8
  store i64 %7, ptr %add.ptr8.i.i.i, align 8
  %tt8.i.i = getelementptr inbounds %struct.lua_TValue, ptr %.pre.i.i, i64 0, i32 1
  %8 = load i32, ptr %tt8.i.i, align 8
  %tt9.i.i = getelementptr %struct.lua_TValue, ptr %4, i64 -1, i32 1
  store i32 %8, ptr %tt9.i.i, align 8
  br label %load_aux.exit

load_aux.exit:                                    ; preds = %luaL_optlstring.exit, %lua_insert.exit.i
  %retval.0.i7 = phi i32 [ 2, %lua_insert.exit.i ], [ 1, %luaL_optlstring.exit ]
  ret i32 %retval.0.i7
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_loadstring(ptr noundef %L) #0 {
entry:
  %p.i.i.i = alloca %struct.SParser, align 8
  %z.i.i = alloca %struct.Zio, align 8
  %ls.i = alloca %struct.LoadS, align 8
  %l = alloca i64, align 8
  %call.i = call fastcc ptr @lua_tolstring(ptr noundef %L, i32 noundef 1, ptr noundef nonnull %l)
  %tobool.not.i = icmp eq ptr %call.i, null
  br i1 %tobool.not.i, label %if.then.i, label %luaL_checklstring.exit

if.then.i:                                        ; preds = %entry
  call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 1, ptr noundef nonnull @.str.25)
  unreachable

luaL_checklstring.exit:                           ; preds = %entry
  %base.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i.i, align 8
  %add.ptr.i.i.i = getelementptr %struct.lua_TValue, ptr %0, i64 1
  %top.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i.i = icmp uge ptr %add.ptr.i.i.i, %1
  %cmp.i.i = icmp eq ptr %add.ptr.i.i.i, @luaO_nilobject_
  %or.cond = or i1 %cmp1.not.i.i.i, %cmp.i.i
  br i1 %or.cond, label %luaL_optlstring.exit, label %lua_type.exit.i

lua_type.exit.i:                                  ; preds = %luaL_checklstring.exit
  %tt.i.i = getelementptr %struct.lua_TValue, ptr %0, i64 1, i32 1
  %2 = load i32, ptr %tt.i.i, align 8
  %cmp.i = icmp slt i32 %2, 1
  br i1 %cmp.i, label %luaL_optlstring.exit, label %if.else.i

if.else.i:                                        ; preds = %lua_type.exit.i
  %call.i.i = call fastcc ptr @lua_tolstring(ptr noundef nonnull %L, i32 noundef 2, ptr noundef null)
  %tobool.not.i.i = icmp eq ptr %call.i.i, null
  br i1 %tobool.not.i.i, label %if.then.i.i, label %if.else.i.luaL_optlstring.exit_crit_edge

if.else.i.luaL_optlstring.exit_crit_edge:         ; preds = %if.else.i
  %.pre = load ptr, ptr %top.i.i.i, align 8
  br label %luaL_optlstring.exit

if.then.i.i:                                      ; preds = %if.else.i
  call fastcc void @luaL_typerror(ptr noundef nonnull %L, i32 noundef 2, ptr noundef nonnull @.str.25)
  unreachable

luaL_optlstring.exit:                             ; preds = %if.else.i.luaL_optlstring.exit_crit_edge, %luaL_checklstring.exit, %lua_type.exit.i
  %3 = phi ptr [ %.pre, %if.else.i.luaL_optlstring.exit_crit_edge ], [ %1, %lua_type.exit.i ], [ %1, %luaL_checklstring.exit ]
  %retval.0.i = phi ptr [ %call.i.i, %if.else.i.luaL_optlstring.exit_crit_edge ], [ %call.i, %lua_type.exit.i ], [ %call.i, %luaL_checklstring.exit ]
  %4 = load i64, ptr %l, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %ls.i)
  store ptr %call.i, ptr %ls.i, align 8
  %size1.i = getelementptr inbounds %struct.LoadS, ptr %ls.i, i64 0, i32 1
  store i64 %4, ptr %size1.i, align 8
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %z.i.i)
  %L1.i.i.i = getelementptr inbounds %struct.Zio, ptr %z.i.i, i64 0, i32 4
  store ptr %L, ptr %L1.i.i.i, align 8
  %reader2.i.i.i = getelementptr inbounds %struct.Zio, ptr %z.i.i, i64 0, i32 2
  store ptr @getS, ptr %reader2.i.i.i, align 8
  %data3.i.i.i = getelementptr inbounds %struct.Zio, ptr %z.i.i, i64 0, i32 3
  store ptr %ls.i, ptr %data3.i.i.i, align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %z.i.i, i8 0, i64 16, i1 false)
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %p.i.i.i)
  store ptr %z.i.i, ptr %p.i.i.i, align 8
  %name2.i.i.i = getelementptr inbounds %struct.SParser, ptr %p.i.i.i, i64 0, i32 2
  store ptr %retval.0.i, ptr %name2.i.i.i, align 8
  %buff.i.i.i = getelementptr inbounds %struct.SParser, ptr %p.i.i.i, i64 0, i32 1
  store ptr null, ptr %buff.i.i.i, align 8
  %buffsize.i.i.i = getelementptr inbounds %struct.SParser, ptr %p.i.i.i, i64 0, i32 1, i32 2
  store i64 0, ptr %buffsize.i.i.i, align 8
  %stack.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 10
  %5 = load ptr, ptr %stack.i.i.i, align 8
  %sub.ptr.lhs.cast.i.i.i = ptrtoint ptr %3 to i64
  %sub.ptr.rhs.cast.i.i.i = ptrtoint ptr %5 to i64
  %sub.ptr.sub.i.i.i = sub i64 %sub.ptr.lhs.cast.i.i.i, %sub.ptr.rhs.cast.i.i.i
  %errfunc.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 27
  %6 = load i64, ptr %errfunc.i.i.i, align 8
  %call.i.i.i = call fastcc i32 @luaD_pcall(ptr noundef nonnull %L, ptr noundef nonnull @f_parser, ptr noundef nonnull %p.i.i.i, i64 noundef %sub.ptr.sub.i.i.i, i64 noundef %6)
  %7 = load ptr, ptr %buff.i.i.i, align 8
  %8 = load i64, ptr %buffsize.i.i.i, align 8
  %l_G.i.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %9 = load ptr, ptr %l_G.i.i.i.i, align 8
  %frealloc.i.i.i.i = getelementptr inbounds %struct.global_State, ptr %9, i64 0, i32 1
  %10 = load ptr, ptr %frealloc.i.i.i.i, align 8
  %ud.i.i.i.i = getelementptr inbounds %struct.global_State, ptr %9, i64 0, i32 2
  %11 = load ptr, ptr %ud.i.i.i.i, align 8
  %call.i.i.i.i = call ptr %10(ptr noundef %11, ptr noundef %7, i64 noundef %8, i64 noundef 0) #35
  %totalbytes.i.i.i.i = getelementptr inbounds %struct.global_State, ptr %9, i64 0, i32 14
  %12 = load i64, ptr %totalbytes.i.i.i.i, align 8
  %add.i.i.i.i = sub i64 %12, %8
  store i64 %add.i.i.i.i, ptr %totalbytes.i.i.i.i, align 8
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %p.i.i.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %z.i.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %ls.i)
  %cmp.i8 = icmp eq i32 %call.i.i.i, 0
  br i1 %cmp.i8, label %load_aux.exit, label %if.else.i9

if.else.i9:                                       ; preds = %luaL_optlstring.exit
  %13 = load ptr, ptr %top.i.i.i, align 8
  %tt.i.i10 = getelementptr inbounds %struct.lua_TValue, ptr %13, i64 0, i32 1
  store i32 0, ptr %tt.i.i10, align 8
  %14 = load ptr, ptr %top.i.i.i, align 8
  %incdec.ptr.i.i = getelementptr inbounds %struct.lua_TValue, ptr %14, i64 1
  store ptr %incdec.ptr.i.i, ptr %top.i.i.i, align 8
  br label %for.body.i.i

for.body.i.i:                                     ; preds = %for.body.i.i, %if.else.i9
  %q.012.i.i = phi ptr [ %add.ptr.i.i, %for.body.i.i ], [ %incdec.ptr.i.i, %if.else.i9 ]
  %add.ptr.i.i = getelementptr inbounds %struct.lua_TValue, ptr %q.012.i.i, i64 -1
  %15 = load i64, ptr %add.ptr.i.i, align 8
  store i64 %15, ptr %q.012.i.i, align 8
  %tt.i3.i = getelementptr %struct.lua_TValue, ptr %q.012.i.i, i64 -1, i32 1
  %16 = load i32, ptr %tt.i3.i, align 8
  %tt2.i.i = getelementptr inbounds %struct.lua_TValue, ptr %q.012.i.i, i64 0, i32 1
  store i32 %16, ptr %tt2.i.i, align 8
  %cmp.i.i11 = icmp ugt ptr %q.012.i.i, %14
  br i1 %cmp.i.i11, label %for.body.i.i, label %lua_insert.exit.i, !llvm.loop !86

lua_insert.exit.i:                                ; preds = %for.body.i.i
  %add.ptr8.i.i.i = getelementptr inbounds %struct.lua_TValue, ptr %14, i64 -1
  %.pre.i.i = load ptr, ptr %top.i.i.i, align 8
  %17 = load i64, ptr %.pre.i.i, align 8
  store i64 %17, ptr %add.ptr8.i.i.i, align 8
  %tt8.i.i = getelementptr inbounds %struct.lua_TValue, ptr %.pre.i.i, i64 0, i32 1
  %18 = load i32, ptr %tt8.i.i, align 8
  %tt9.i.i = getelementptr %struct.lua_TValue, ptr %14, i64 -1, i32 1
  store i32 %18, ptr %tt9.i.i, align 8
  br label %load_aux.exit

load_aux.exit:                                    ; preds = %luaL_optlstring.exit, %lua_insert.exit.i
  %retval.0.i12 = phi i32 [ 2, %lua_insert.exit.i ], [ 1, %luaL_optlstring.exit ]
  ret i32 %retval.0.i12
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_pcall(ptr noundef %L) #0 {
entry:
  %c.i = alloca %struct.CallS, align 8
  %base.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i.i, align 8
  %top.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i.i = icmp uge ptr %0, %1
  %cmp.i.i = icmp eq ptr %0, @luaO_nilobject_
  %or.cond = or i1 %cmp.i.i, %cmp1.not.i.i.i
  br i1 %or.cond, label %if.then.i, label %lua_type.exit.i

lua_type.exit.i:                                  ; preds = %entry
  %tt.i.i = getelementptr inbounds %struct.lua_TValue, ptr %0, i64 0, i32 1
  %2 = load i32, ptr %tt.i.i, align 8
  %cmp.i = icmp eq i32 %2, -1
  br i1 %cmp.i, label %if.then.i, label %luaL_checkany.exit

if.then.i:                                        ; preds = %lua_type.exit.i, %entry
  tail call fastcc void @luaL_argerror(ptr noundef nonnull %L, i32 noundef 1, ptr noundef nonnull @.str.115)
  unreachable

luaL_checkany.exit:                               ; preds = %lua_type.exit.i
  %sub.ptr.lhs.cast.i = ptrtoint ptr %1 to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %0 to i64
  %sub.ptr.sub.i.neg = sub i64 %sub.ptr.rhs.cast.i, %sub.ptr.lhs.cast.i
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %c.i)
  %.neg = shl i64 %sub.ptr.sub.i.neg, 28
  %idx.neg.i = ashr i64 %.neg, 32
  %add.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 %idx.neg.i
  store ptr %add.ptr.i, ptr %c.i, align 8
  %nresults2.i = getelementptr inbounds %struct.CallS, ptr %c.i, i64 0, i32 1
  store i32 -1, ptr %nresults2.i, align 8
  %stack4.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 10
  %3 = load ptr, ptr %stack4.i, align 8
  %sub.ptr.lhs.cast5.i = ptrtoint ptr %add.ptr.i to i64
  %sub.ptr.rhs.cast6.i = ptrtoint ptr %3 to i64
  %sub.ptr.sub7.i = sub i64 %sub.ptr.lhs.cast5.i, %sub.ptr.rhs.cast6.i
  %call8.i = call fastcc i32 @luaD_pcall(ptr noundef nonnull %L, ptr noundef nonnull @f_call, ptr noundef nonnull %c.i, i64 noundef %sub.ptr.sub7.i, i64 noundef 0)
  %4 = load ptr, ptr %top.i.i.i, align 8
  %ci.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %5 = load ptr, ptr %ci.i, align 8
  %top11.i = getelementptr inbounds %struct.CallInfo, ptr %5, i64 0, i32 2
  %6 = load ptr, ptr %top11.i, align 8
  %cmp12.not.i = icmp ult ptr %4, %6
  br i1 %cmp12.not.i, label %lua_pcall.exit, label %if.then13.i

if.then13.i:                                      ; preds = %luaL_checkany.exit
  store ptr %4, ptr %top11.i, align 8
  %.pre = load ptr, ptr %top.i.i.i, align 8
  br label %lua_pcall.exit

lua_pcall.exit:                                   ; preds = %luaL_checkany.exit, %if.then13.i
  %7 = phi ptr [ %4, %luaL_checkany.exit ], [ %.pre, %if.then13.i ]
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %c.i)
  %cmp = icmp eq i32 %call8.i, 0
  %conv.i10 = zext i1 %cmp to i32
  store i32 %conv.i10, ptr %7, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %7, i64 0, i32 1
  store i32 1, ptr %tt.i, align 8
  %8 = load ptr, ptr %top.i.i.i, align 8
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %8, i64 1
  store ptr %incdec.ptr.i, ptr %top.i.i.i, align 8
  %9 = load ptr, ptr %base.i.i.i, align 8
  %cmp1.not.i.i = icmp ult ptr %9, %incdec.ptr.i
  %add.ptr.luaO_nilobject_.i.i = select i1 %cmp1.not.i.i, ptr %9, ptr @luaO_nilobject_
  %cmp11.i = icmp ugt ptr %incdec.ptr.i, %add.ptr.luaO_nilobject_.i.i
  br i1 %cmp11.i, label %for.body.i, label %lua_insert.exit

for.body.i:                                       ; preds = %lua_pcall.exit, %for.body.i
  %q.012.i = phi ptr [ %add.ptr.i12, %for.body.i ], [ %incdec.ptr.i, %lua_pcall.exit ]
  %add.ptr.i12 = getelementptr inbounds %struct.lua_TValue, ptr %q.012.i, i64 -1
  %10 = load i64, ptr %add.ptr.i12, align 8
  store i64 %10, ptr %q.012.i, align 8
  %tt.i13 = getelementptr %struct.lua_TValue, ptr %q.012.i, i64 -1, i32 1
  %11 = load i32, ptr %tt.i13, align 8
  %tt2.i = getelementptr inbounds %struct.lua_TValue, ptr %q.012.i, i64 0, i32 1
  store i32 %11, ptr %tt2.i, align 8
  %cmp.i14 = icmp ugt ptr %add.ptr.i12, %add.ptr.luaO_nilobject_.i.i
  br i1 %cmp.i14, label %for.body.i, label %for.end.loopexit.i, !llvm.loop !86

for.end.loopexit.i:                               ; preds = %for.body.i
  %.pre.i = load ptr, ptr %top.i.i.i, align 8
  br label %lua_insert.exit

lua_insert.exit:                                  ; preds = %lua_pcall.exit, %for.end.loopexit.i
  %12 = phi ptr [ %.pre.i, %for.end.loopexit.i ], [ %incdec.ptr.i, %lua_pcall.exit ]
  %13 = load i64, ptr %12, align 8
  store i64 %13, ptr %add.ptr.luaO_nilobject_.i.i, align 8
  %tt8.i = getelementptr inbounds %struct.lua_TValue, ptr %12, i64 0, i32 1
  %14 = load i32, ptr %tt8.i, align 8
  %tt9.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i, i64 0, i32 1
  store i32 %14, ptr %tt9.i, align 8
  %L.val7 = load ptr, ptr %top.i.i.i, align 8
  %L.val8 = load ptr, ptr %base.i.i.i, align 8
  %sub.ptr.lhs.cast.i15 = ptrtoint ptr %L.val7 to i64
  %sub.ptr.rhs.cast.i16 = ptrtoint ptr %L.val8 to i64
  %sub.ptr.sub.i17 = sub i64 %sub.ptr.lhs.cast.i15, %sub.ptr.rhs.cast.i16
  %sub.ptr.div.i18 = lshr exact i64 %sub.ptr.sub.i17, 4
  %conv.i19 = trunc i64 %sub.ptr.div.i18 to i32
  ret i32 %conv.i19
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_rawget(ptr noundef %L) #0 {
entry:
  %base.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i.i, align 8
  %top.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i.i = icmp uge ptr %0, %1
  %cmp.i.i = icmp eq ptr %0, @luaO_nilobject_
  %or.cond = or i1 %cmp.i.i, %cmp1.not.i.i.i
  br i1 %or.cond, label %if.then.i, label %lua_type.exit.i

lua_type.exit.i:                                  ; preds = %entry
  %tt.i.i = getelementptr inbounds %struct.lua_TValue, ptr %0, i64 0, i32 1
  %2 = load i32, ptr %tt.i.i, align 8
  %cmp.not.i = icmp eq i32 %2, 5
  br i1 %cmp.not.i, label %luaL_checktype.exit, label %if.then.i

if.then.i:                                        ; preds = %entry, %lua_type.exit.i
  tail call fastcc void @luaL_typerror(ptr noundef nonnull %L, i32 noundef 1, ptr noundef nonnull @.str.26)
  unreachable

luaL_checktype.exit:                              ; preds = %lua_type.exit.i
  %3 = getelementptr %struct.lua_TValue, ptr %0, i64 2
  %add.ptr.i.i.i5 = getelementptr %struct.lua_TValue, ptr %0, i64 1
  %cmp1.not.i.i.i7 = icmp uge ptr %add.ptr.i.i.i5, %1
  %cmp.i.i10 = icmp eq ptr %add.ptr.i.i.i5, @luaO_nilobject_
  %or.cond19 = or i1 %cmp1.not.i.i.i7, %cmp.i.i10
  br i1 %or.cond19, label %if.then.i8, label %lua_type.exit.i11

lua_type.exit.i11:                                ; preds = %luaL_checktype.exit
  %tt.i.i12 = getelementptr %struct.lua_TValue, ptr %0, i64 1, i32 1
  %4 = load i32, ptr %tt.i.i12, align 8
  %cmp.i = icmp eq i32 %4, -1
  br i1 %cmp.i, label %if.then.i8, label %luaL_checkany.exit

if.then.i8:                                       ; preds = %lua_type.exit.i11, %luaL_checktype.exit
  tail call fastcc void @luaL_argerror(ptr noundef nonnull %L, i32 noundef 2, ptr noundef nonnull @.str.115)
  unreachable

luaL_checkany.exit:                               ; preds = %lua_type.exit.i11
  %cmp111.i = icmp ult ptr %1, %3
  br i1 %cmp111.i, label %while.body.i, label %lua_settop.exit

while.body.i:                                     ; preds = %luaL_checkany.exit, %while.body.i
  %5 = phi ptr [ %6, %while.body.i ], [ %1, %luaL_checkany.exit ]
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %5, i64 1
  store ptr %incdec.ptr.i, ptr %top.i.i.i, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %5, i64 0, i32 1
  store i32 0, ptr %tt.i, align 8
  %6 = load ptr, ptr %top.i.i.i, align 8
  %7 = load ptr, ptr %base.i.i.i, align 8
  %add.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %7, i64 2
  %cmp1.i = icmp ult ptr %6, %add.ptr.i
  br i1 %cmp1.i, label %while.body.i, label %lua_settop.exit, !llvm.loop !13

lua_settop.exit:                                  ; preds = %while.body.i, %luaL_checkany.exit
  %8 = phi ptr [ %0, %luaL_checkany.exit ], [ %7, %while.body.i ]
  %add.ptr9.sink.i = phi ptr [ %3, %luaL_checkany.exit ], [ %add.ptr.i, %while.body.i ]
  store ptr %add.ptr9.sink.i, ptr %top.i.i.i, align 8
  %cmp1.not.i.i = icmp ult ptr %8, %add.ptr9.sink.i
  %add.ptr.luaO_nilobject_.i.i = select i1 %cmp1.not.i.i, ptr %8, ptr @luaO_nilobject_
  %9 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i, align 8
  %add.ptr.i14 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr9.sink.i, i64 -1
  %call1.i15 = tail call fastcc ptr @luaH_get(ptr noundef %9, ptr noundef nonnull %add.ptr.i14)
  %10 = load i64, ptr %call1.i15, align 8
  store i64 %10, ptr %add.ptr.i14, align 8
  %tt.i16 = getelementptr inbounds %struct.lua_TValue, ptr %call1.i15, i64 0, i32 1
  %11 = load i32, ptr %tt.i16, align 8
  %tt6.i = getelementptr %struct.lua_TValue, ptr %add.ptr9.sink.i, i64 -1, i32 1
  store i32 %11, ptr %tt6.i, align 8
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_setfenv(ptr noundef %L) #0 {
entry:
  %endptr.i.i.i = alloca ptr, align 8
  %endptr.i.i.i.i = alloca ptr, align 8
  %ar.i = alloca %struct.lua_Debug, align 8
  %base.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i.i, align 8
  %add.ptr.i.i.i = getelementptr %struct.lua_TValue, ptr %0, i64 1
  %top.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i.i = icmp uge ptr %add.ptr.i.i.i, %1
  %cmp.i.i = icmp eq ptr %add.ptr.i.i.i, @luaO_nilobject_
  %or.cond = or i1 %cmp1.not.i.i.i, %cmp.i.i
  br i1 %or.cond, label %if.then.i, label %lua_type.exit.i

lua_type.exit.i:                                  ; preds = %entry
  %tt.i.i = getelementptr %struct.lua_TValue, ptr %0, i64 1, i32 1
  %2 = load i32, ptr %tt.i.i, align 8
  %cmp.not.i = icmp eq i32 %2, 5
  br i1 %cmp.not.i, label %luaL_checktype.exit, label %if.then.i

if.then.i:                                        ; preds = %entry, %lua_type.exit.i
  tail call fastcc void @luaL_typerror(ptr noundef nonnull %L, i32 noundef 2, ptr noundef nonnull @.str.26)
  unreachable

luaL_checktype.exit:                              ; preds = %lua_type.exit.i
  call void @llvm.lifetime.start.p0(i64 120, ptr nonnull %ar.i)
  %cmp1.not.i.i.i13 = icmp uge ptr %0, %1
  %cmp.i.i14 = icmp eq ptr %0, @luaO_nilobject_
  %or.cond.i = or i1 %cmp.i.i14, %cmp1.not.i.i.i13
  br i1 %or.cond.i, label %cond.false.i, label %lua_type.exit.i15

lua_type.exit.i15:                                ; preds = %luaL_checktype.exit
  %tt.i.i16 = getelementptr inbounds %struct.lua_TValue, ptr %0, i64 0, i32 1
  %3 = load i32, ptr %tt.i.i16, align 8
  %cmp.i = icmp eq i32 %3, 6
  br i1 %cmp.i, label %if.then.i17, label %cond.false.i

if.then.i17:                                      ; preds = %lua_type.exit.i15
  %4 = load i64, ptr %0, align 8
  store i64 %4, ptr %1, align 8
  %5 = load i32, ptr %tt.i.i16, align 8
  %tt2.i.i = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 0, i32 1
  store i32 %5, ptr %tt2.i.i, align 8
  %6 = load ptr, ptr %top.i.i.i, align 8
  %incdec.ptr.i.i = getelementptr inbounds %struct.lua_TValue, ptr %6, i64 1
  store ptr %incdec.ptr.i.i, ptr %top.i.i.i, align 8
  br label %getfunc.exit

cond.false.i:                                     ; preds = %lua_type.exit.i15, %luaL_checktype.exit
  %call.i.i = tail call fastcc i64 @lua_tointeger(ptr noundef nonnull %L, i32 noundef 1)
  %cmp.i18.i = icmp eq i64 %call.i.i, 0
  br i1 %cmp.i18.i, label %land.lhs.true.i.i, label %luaL_checkinteger.exit.i

land.lhs.true.i.i:                                ; preds = %cond.false.i
  %7 = load ptr, ptr %base.i.i.i, align 8
  %8 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i33.i = icmp ult ptr %7, %8
  %add.ptr.luaO_nilobject_.i.i34.i = select i1 %cmp1.not.i.i33.i, ptr %7, ptr @luaO_nilobject_
  %tt.i36.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i34.i, i64 0, i32 1
  %9 = load i32, ptr %tt.i36.i, align 8
  switch i32 %9, label %if.then.i.i [
    i32 3, label %land.lhs.true.i19.sink.split.i
    i32 4, label %land.lhs.true.i.i.i
  ]

land.lhs.true.i.i.i:                              ; preds = %land.lhs.true.i.i
  %10 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i34.i, align 8
  %add.ptr.i3.i.i = getelementptr inbounds %union.TString, ptr %10, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i.i.i)
  %call.i.i.i.i = call double @strtod(ptr noundef nonnull %add.ptr.i3.i.i, ptr noundef nonnull %endptr.i.i.i.i) #35
  %11 = load ptr, ptr %endptr.i.i.i.i, align 8
  %cmp.i.i.i.i = icmp eq ptr %11, %add.ptr.i3.i.i
  br i1 %cmp.i.i.i.i, label %luaO_str2d.exit.thread.i.i.i, label %if.end.i.i.i.i

luaO_str2d.exit.thread.i.i.i:                     ; preds = %land.lhs.true.i.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i.i)
  br label %if.then.i.i

if.end.i.i.i.i:                                   ; preds = %land.lhs.true.i.i.i
  %12 = load i8, ptr %11, align 1
  switch i8 %12, label %if.end9.i.i.i.i [
    i8 120, label %if.then6.i.i.i.i
    i8 88, label %if.then6.i.i.i.i
  ]

if.then6.i.i.i.i:                                 ; preds = %if.end.i.i.i.i, %if.end.i.i.i.i
  %call7.i.i.i.i = call i64 @strtoul(ptr noundef nonnull %add.ptr.i3.i.i, ptr noundef nonnull %endptr.i.i.i.i, i32 noundef 16) #35
  %.pre.i.i.i.i = load ptr, ptr %endptr.i.i.i.i, align 8
  %.pre5.i.i.i.i = load i8, ptr %.pre.i.i.i.i, align 1
  br label %if.end9.i.i.i.i

if.end9.i.i.i.i:                                  ; preds = %if.then6.i.i.i.i, %if.end.i.i.i.i
  %13 = phi i8 [ %12, %if.end.i.i.i.i ], [ %.pre5.i.i.i.i, %if.then6.i.i.i.i ]
  %endptr.promoted.i.i.i.i = phi ptr [ %11, %if.end.i.i.i.i ], [ %.pre.i.i.i.i, %if.then6.i.i.i.i ]
  %cmp11.i.i.i.i = icmp eq i8 %13, 0
  br i1 %cmp11.i.i.i.i, label %lor.end.thread66.i, label %while.cond.preheader.i.i.i.i

lor.end.thread66.i:                               ; preds = %if.end9.i.i.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i.i)
  br label %land.lhs.true.i19.sink.split.i

while.cond.preheader.i.i.i.i:                     ; preds = %if.end9.i.i.i.i
  %call15.i.i.i.i = tail call ptr @__ctype_b_loc() #39
  %14 = load ptr, ptr %call15.i.i.i.i, align 8
  br label %while.cond.i.i.i.i

while.cond.i.i.i.i:                               ; preds = %while.cond.i.i.i.i, %while.cond.preheader.i.i.i.i
  %incdec.ptr4.i.i.i.i = phi ptr [ %endptr.promoted.i.i.i.i, %while.cond.preheader.i.i.i.i ], [ %incdec.ptr.i.i.i.i, %while.cond.i.i.i.i ]
  %15 = load i8, ptr %incdec.ptr4.i.i.i.i, align 1
  %idxprom.i.i.i.i = zext i8 %15 to i64
  %arrayidx.i.i.i.i = getelementptr inbounds i16, ptr %14, i64 %idxprom.i.i.i.i
  %16 = load i16, ptr %arrayidx.i.i.i.i, align 2
  %17 = and i16 %16, 8192
  %tobool.not.i.i.i.i = icmp eq i16 %17, 0
  %incdec.ptr.i.i.i.i = getelementptr inbounds i8, ptr %incdec.ptr4.i.i.i.i, i64 1
  br i1 %tobool.not.i.i.i.i, label %luaO_str2d.exit.i.i.i, label %while.cond.i.i.i.i, !llvm.loop !35

luaO_str2d.exit.i.i.i:                            ; preds = %while.cond.i.i.i.i
  %cmp19.not.i.not.i.i.i = icmp eq i8 %15, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i.i)
  br i1 %cmp19.not.i.not.i.i.i, label %luaL_checkinteger.exit.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %luaO_str2d.exit.i.i.i, %luaO_str2d.exit.thread.i.i.i, %land.lhs.true.i.i
  tail call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 1, ptr noundef nonnull @.str.24)
  unreachable

luaL_checkinteger.exit.i:                         ; preds = %luaO_str2d.exit.i.i.i, %cond.false.i
  %conv3.i = trunc i64 %call.i.i to i32
  %cmp4.i = icmp sgt i32 %conv3.i, -1
  br i1 %cmp4.i, label %lor.end.i, label %lor.rhs.i

lor.rhs.i:                                        ; preds = %luaL_checkinteger.exit.i
  tail call fastcc void @luaL_argerror(ptr noundef %L, i32 noundef 1, ptr noundef nonnull @.str.176)
  unreachable

lor.end.i:                                        ; preds = %luaL_checkinteger.exit.i
  %ci1.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %18 = load ptr, ptr %ci1.i.i, align 8
  %cmp18.i.not.i = icmp eq i32 %conv3.i, 0
  br i1 %cmp18.i.not.i, label %land.lhs.true.i19.i, label %land.rhs.lr.ph.i.i

land.rhs.lr.ph.i.i:                               ; preds = %lor.end.i
  %base_ci.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 12
  %19 = load ptr, ptr %base_ci.i.i, align 8
  br label %land.rhs.i.i

land.rhs.i.i:                                     ; preds = %for.inc.i.i, %land.rhs.lr.ph.i.i
  %ci.020.i.i = phi ptr [ %18, %land.rhs.lr.ph.i.i ], [ %incdec.ptr.i21.i, %for.inc.i.i ]
  %level.addr.019.i.i = phi i32 [ %conv3.i, %land.rhs.lr.ph.i.i ], [ %level.addr.1.i.i, %for.inc.i.i ]
  %cmp2.i.i = icmp ugt ptr %ci.020.i.i, %19
  br i1 %cmp2.i.i, label %for.body.i.i, label %if.then11.i

for.body.i.i:                                     ; preds = %land.rhs.i.i
  %dec.i.i = add nsw i32 %level.addr.019.i.i, -1
  %func.i.i = getelementptr inbounds %struct.CallInfo, ptr %ci.020.i.i, i64 0, i32 1
  %20 = load ptr, ptr %func.i.i, align 8
  %21 = load ptr, ptr %20, align 8
  %isC.i.i = getelementptr inbounds %struct.CClosure, ptr %21, i64 0, i32 3
  %22 = load i8, ptr %isC.i.i, align 2
  %tobool.not.i20.i = icmp eq i8 %22, 0
  br i1 %tobool.not.i20.i, label %if.then.i23.i, label %for.inc.i.i

if.then.i23.i:                                    ; preds = %for.body.i.i
  %tailcalls.i.i = getelementptr inbounds %struct.CallInfo, ptr %ci.020.i.i, i64 0, i32 5
  %23 = load i32, ptr %tailcalls.i.i, align 4
  %sub.i.i = sub nsw i32 %dec.i.i, %23
  br label %for.inc.i.i

for.inc.i.i:                                      ; preds = %if.then.i23.i, %for.body.i.i
  %level.addr.1.i.i = phi i32 [ %dec.i.i, %for.body.i.i ], [ %sub.i.i, %if.then.i23.i ]
  %incdec.ptr.i21.i = getelementptr inbounds %struct.CallInfo, ptr %ci.020.i.i, i64 -1
  %cmp.i22.i = icmp sgt i32 %level.addr.1.i.i, 0
  br i1 %cmp.i22.i, label %land.rhs.i.i, label %for.end.i.i, !llvm.loop !87

for.end.i.i:                                      ; preds = %for.inc.i.i
  %24 = icmp eq i32 %level.addr.1.i.i, 0
  br i1 %24, label %land.lhs.true.i19.i, label %lua_getstack.exit.i

land.lhs.true.i19.sink.split.i:                   ; preds = %lor.end.thread66.i, %land.lhs.true.i.i
  %ci1.i45.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %25 = load ptr, ptr %ci1.i45.i, align 8
  br label %land.lhs.true.i19.i

land.lhs.true.i19.i:                              ; preds = %land.lhs.true.i19.sink.split.i, %for.end.i.i, %lor.end.i
  %ci.0.lcssa.i55.i = phi ptr [ %incdec.ptr.i21.i, %for.end.i.i ], [ %18, %lor.end.i ], [ %25, %land.lhs.true.i19.sink.split.i ]
  %conv3434853.i = phi i32 [ %conv3.i, %for.end.i.i ], [ 0, %lor.end.i ], [ 0, %land.lhs.true.i19.sink.split.i ]
  %base_ci4.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 12
  %26 = load ptr, ptr %base_ci4.i.i, align 8
  %cmp5.i.i = icmp ugt ptr %ci.0.lcssa.i55.i, %26
  br i1 %cmp5.i.i, label %if.then6.i.i, label %if.then11.i

if.then6.i.i:                                     ; preds = %land.lhs.true.i19.i
  %sub.ptr.lhs.cast.i.i = ptrtoint ptr %ci.0.lcssa.i55.i to i64
  %sub.ptr.rhs.cast.i.i = ptrtoint ptr %26 to i64
  %sub.ptr.sub.i.i = sub i64 %sub.ptr.lhs.cast.i.i, %sub.ptr.rhs.cast.i.i
  %sub.ptr.div.i.i = sdiv exact i64 %sub.ptr.sub.i.i, 40
  %conv.i.i = trunc i64 %sub.ptr.div.i.i to i32
  br label %lua_getstack.exit.i

lua_getstack.exit.i:                              ; preds = %if.then6.i.i, %for.end.i.i
  %conv3434854.i = phi i32 [ %conv3434853.i, %if.then6.i.i ], [ %conv3.i, %for.end.i.i ]
  %.sink.i.i = phi i32 [ %conv.i.i, %if.then6.i.i ], [ 0, %for.end.i.i ]
  %i_ci11.i.i = getelementptr inbounds %struct.lua_Debug, ptr %ar.i, i64 0, i32 10
  store i32 %.sink.i.i, ptr %i_ci11.i.i, align 4
  call fastcc void @lua_getinfo(ptr noundef %L, ptr noundef nonnull @.str.178, ptr noundef nonnull %ar.i)
  %27 = load ptr, ptr %top.i.i.i, align 8
  %add.ptr8.i.i.i = getelementptr inbounds %struct.lua_TValue, ptr %27, i64 -1
  %cmp.i25.i = icmp eq ptr %add.ptr8.i.i.i, @luaO_nilobject_
  br i1 %cmp.i25.i, label %getfunc.exit, label %lua_type.exit29.i

if.then11.i:                                      ; preds = %land.rhs.i.i, %land.lhs.true.i19.i
  tail call fastcc void @luaL_argerror(ptr noundef %L, i32 noundef 1, ptr noundef nonnull @.str.177)
  unreachable

lua_type.exit29.i:                                ; preds = %lua_getstack.exit.i
  %tt.i27.i = getelementptr %struct.lua_TValue, ptr %27, i64 -1, i32 1
  %28 = load i32, ptr %tt.i27.i, align 8
  %cmp15.i = icmp eq i32 %28, 0
  br i1 %cmp15.i, label %if.then17.i, label %getfunc.exit

if.then17.i:                                      ; preds = %lua_type.exit29.i
  call void (ptr, ptr, ...) @luaL_error(ptr noundef nonnull %L, ptr noundef nonnull @.str.179, i32 noundef %conv3434854.i)
  unreachable

getfunc.exit:                                     ; preds = %if.then.i17, %lua_getstack.exit.i, %lua_type.exit29.i
  %29 = phi ptr [ %incdec.ptr.i.i, %if.then.i17 ], [ %27, %lua_getstack.exit.i ], [ %27, %lua_type.exit29.i ]
  call void @llvm.lifetime.end.p0(i64 120, ptr nonnull %ar.i)
  %30 = load ptr, ptr %base.i.i.i, align 8
  %add.ptr.i.i = getelementptr %struct.lua_TValue, ptr %30, i64 1
  %cmp1.not.i.i = icmp ult ptr %add.ptr.i.i, %29
  %add.ptr.luaO_nilobject_.i.i = select i1 %cmp1.not.i.i, ptr %add.ptr.i.i, ptr @luaO_nilobject_
  %31 = load i64, ptr %add.ptr.luaO_nilobject_.i.i, align 8
  store i64 %31, ptr %29, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i, i64 0, i32 1
  %32 = load i32, ptr %tt.i, align 8
  %tt2.i = getelementptr inbounds %struct.lua_TValue, ptr %29, i64 0, i32 1
  store i32 %32, ptr %tt2.i, align 8
  %33 = load ptr, ptr %top.i.i.i, align 8
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %33, i64 1
  store ptr %incdec.ptr.i, ptr %top.i.i.i, align 8
  %34 = load ptr, ptr %base.i.i.i, align 8
  %cmp1.not.i.i23 = icmp ult ptr %34, %incdec.ptr.i
  %add.ptr.luaO_nilobject_.i.i24 = select i1 %cmp1.not.i.i23, ptr %34, ptr @luaO_nilobject_
  %tt.i25 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i24, i64 0, i32 1
  %35 = load i32, ptr %tt.i25, align 8
  switch i32 %35, label %if.else [
    i32 3, label %land.lhs.true
    i32 4, label %land.lhs.true.i.i26
  ]

land.lhs.true.i.i26:                              ; preds = %getfunc.exit
  %36 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i24, align 8
  %add.ptr.i3.i = getelementptr inbounds %union.TString, ptr %36, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i.i)
  %call.i.i.i = call double @strtod(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i) #35
  %37 = load ptr, ptr %endptr.i.i.i, align 8
  %cmp.i.i.i = icmp eq ptr %37, %add.ptr.i3.i
  br i1 %cmp.i.i.i, label %luaO_str2d.exit.thread.i.i, label %if.end.i.i.i

luaO_str2d.exit.thread.i.i:                       ; preds = %land.lhs.true.i.i26
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %if.else

if.end.i.i.i:                                     ; preds = %land.lhs.true.i.i26
  %38 = load i8, ptr %37, align 1
  switch i8 %38, label %if.end9.i.i.i [
    i8 120, label %if.then6.i.i.i
    i8 88, label %if.then6.i.i.i
  ]

if.then6.i.i.i:                                   ; preds = %if.end.i.i.i, %if.end.i.i.i
  %call7.i.i.i = call i64 @strtoul(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i, i32 noundef 16) #35
  %.pre.i.i.i = load ptr, ptr %endptr.i.i.i, align 8
  %.pre5.i.i.i = load i8, ptr %.pre.i.i.i, align 1
  br label %if.end9.i.i.i

if.end9.i.i.i:                                    ; preds = %if.then6.i.i.i, %if.end.i.i.i
  %39 = phi i8 [ %38, %if.end.i.i.i ], [ %.pre5.i.i.i, %if.then6.i.i.i ]
  %endptr.promoted.i.i.i = phi ptr [ %37, %if.end.i.i.i ], [ %.pre.i.i.i, %if.then6.i.i.i ]
  %cmp11.i.i.i = icmp eq i8 %39, 0
  br i1 %cmp11.i.i.i, label %luaO_str2d.exit.thread9.i.i, label %while.cond.preheader.i.i.i

luaO_str2d.exit.thread9.i.i:                      ; preds = %if.end9.i.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %land.lhs.true

while.cond.preheader.i.i.i:                       ; preds = %if.end9.i.i.i
  %call15.i.i.i = tail call ptr @__ctype_b_loc() #39
  %40 = load ptr, ptr %call15.i.i.i, align 8
  br label %while.cond.i.i.i

while.cond.i.i.i:                                 ; preds = %while.cond.i.i.i, %while.cond.preheader.i.i.i
  %incdec.ptr4.i.i.i = phi ptr [ %endptr.promoted.i.i.i, %while.cond.preheader.i.i.i ], [ %incdec.ptr.i.i.i, %while.cond.i.i.i ]
  %41 = load i8, ptr %incdec.ptr4.i.i.i, align 1
  %idxprom.i.i.i = zext i8 %41 to i64
  %arrayidx.i.i.i = getelementptr inbounds i16, ptr %40, i64 %idxprom.i.i.i
  %42 = load i16, ptr %arrayidx.i.i.i, align 2
  %43 = and i16 %42, 8192
  %tobool.not.i.i.i = icmp eq i16 %43, 0
  %incdec.ptr.i.i.i = getelementptr inbounds i8, ptr %incdec.ptr4.i.i.i, i64 1
  br i1 %tobool.not.i.i.i, label %luaO_str2d.exit.i.i, label %while.cond.i.i.i, !llvm.loop !35

luaO_str2d.exit.i.i:                              ; preds = %while.cond.i.i.i
  %cmp19.not.i.not.i.i = icmp eq i8 %41, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br i1 %cmp19.not.i.not.i.i, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %luaO_str2d.exit.thread9.i.i, %luaO_str2d.exit.i.i, %getfunc.exit
  %call1 = call fastcc double @lua_tonumber(ptr noundef %L, i32 noundef 1)
  %cmp = fcmp oeq double %call1, 0.000000e+00
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %44 = load ptr, ptr %top.i.i.i, align 8
  store ptr %L, ptr %44, align 8
  %tt.i29 = getelementptr inbounds %struct.lua_TValue, ptr %44, i64 0, i32 1
  store i32 8, ptr %tt.i29, align 8
  %45 = load ptr, ptr %top.i.i.i, align 8
  %incdec.ptr.i30 = getelementptr inbounds %struct.lua_TValue, ptr %45, i64 1
  store ptr %incdec.ptr.i30, ptr %top.i.i.i, align 8
  %l_G.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  br label %for.body.i

for.body.i:                                       ; preds = %if.then, %for.body.i
  %q.012.i = phi ptr [ %add.ptr.i, %for.body.i ], [ %incdec.ptr.i30, %if.then ]
  %add.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %q.012.i, i64 -1
  %46 = load i64, ptr %add.ptr.i, align 8
  store i64 %46, ptr %q.012.i, align 8
  %tt.i33 = getelementptr %struct.lua_TValue, ptr %q.012.i, i64 -1, i32 1
  %47 = load i32, ptr %tt.i33, align 8
  %tt2.i34 = getelementptr inbounds %struct.lua_TValue, ptr %q.012.i, i64 0, i32 1
  store i32 %47, ptr %tt2.i34, align 8
  %cmp.i35 = icmp ugt ptr %q.012.i, %45
  br i1 %cmp.i35, label %for.body.i, label %lua_insert.exit, !llvm.loop !86

lua_insert.exit:                                  ; preds = %for.body.i
  %add.ptr8.i.i = getelementptr inbounds %struct.lua_TValue, ptr %45, i64 -1
  %.pre.i = load ptr, ptr %top.i.i.i, align 8
  %48 = load i64, ptr %.pre.i, align 8
  store i64 %48, ptr %add.ptr8.i.i, align 8
  %tt8.i = getelementptr inbounds %struct.lua_TValue, ptr %.pre.i, i64 0, i32 1
  %49 = load i32, ptr %tt8.i, align 8
  %tt9.i = getelementptr %struct.lua_TValue, ptr %45, i64 -1, i32 1
  store i32 %49, ptr %tt9.i, align 8
  %50 = load ptr, ptr %top.i.i.i, align 8
  %add.ptr8.i.i37 = getelementptr inbounds %struct.lua_TValue, ptr %50, i64 -2
  %tt.i38 = getelementptr %struct.lua_TValue, ptr %50, i64 -2, i32 1
  %51 = load i32, ptr %tt.i38, align 8
  switch i32 %51, label %return [
    i32 6, label %sw.bb.i
    i32 7, label %sw.bb2.i
    i32 8, label %sw.bb8.i
  ]

sw.bb.i:                                          ; preds = %lua_insert.exit
  %add.ptr.i43 = getelementptr inbounds %struct.lua_TValue, ptr %50, i64 -1
  %52 = load ptr, ptr %add.ptr.i43, align 8
  %53 = load ptr, ptr %add.ptr8.i.i37, align 8
  %env.i = getelementptr inbounds %struct.CClosure, ptr %53, i64 0, i32 6
  store ptr %52, ptr %env.i, align 8
  br label %if.then.i39

sw.bb2.i:                                         ; preds = %lua_insert.exit
  %add.ptr4.i = getelementptr inbounds %struct.lua_TValue, ptr %50, i64 -1
  %54 = load ptr, ptr %add.ptr4.i, align 8
  %55 = load ptr, ptr %add.ptr8.i.i37, align 8
  %env7.i = getelementptr inbounds %struct.anon.1, ptr %55, i64 0, i32 4
  store ptr %54, ptr %env7.i, align 8
  br label %if.then.i39

sw.bb8.i:                                         ; preds = %lua_insert.exit
  %56 = load ptr, ptr %add.ptr8.i.i37, align 8
  %l_gt.i = getelementptr inbounds %struct.lua_State, ptr %56, i64 0, i32 22
  %add.ptr11.i = getelementptr inbounds %struct.lua_TValue, ptr %50, i64 -1
  %57 = load ptr, ptr %add.ptr11.i, align 8
  store ptr %57, ptr %l_gt.i, align 8
  %tt14.i = getelementptr inbounds %struct.lua_State, ptr %56, i64 0, i32 22, i32 1
  store i32 5, ptr %tt14.i, align 8
  br label %if.then.i39

if.then.i39:                                      ; preds = %sw.bb8.i, %sw.bb2.i, %sw.bb.i
  %58 = load ptr, ptr %top.i.i.i, align 8
  %add.ptr16.i = getelementptr inbounds %struct.lua_TValue, ptr %58, i64 -1
  %59 = load ptr, ptr %add.ptr16.i, align 8
  %marked.i = getelementptr inbounds %struct.GCheader, ptr %59, i64 0, i32 2
  %60 = load i8, ptr %marked.i, align 1
  %61 = and i8 %60, 3
  %tobool18.not.i = icmp eq i8 %61, 0
  br i1 %tobool18.not.i, label %return, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.then.i39
  %62 = load ptr, ptr %add.ptr8.i.i37, align 8
  %marked20.i = getelementptr inbounds %struct.GCheader, ptr %62, i64 0, i32 2
  %63 = load i8, ptr %marked20.i, align 1
  %64 = and i8 %63, 4
  %tobool23.not.i = icmp eq i8 %64, 0
  br i1 %tobool23.not.i, label %return, label %if.then24.i

if.then24.i:                                      ; preds = %land.lhs.true.i
  %L.val.i = load ptr, ptr %l_G.i, align 8
  %gcstate.i.i = getelementptr inbounds %struct.global_State, ptr %L.val.i, i64 0, i32 4
  %65 = load i8, ptr %gcstate.i.i, align 1
  %cmp.i.i40 = icmp eq i8 %65, 1
  br i1 %cmp.i.i40, label %if.then.i.i42, label %if.else.i.i

if.then.i.i42:                                    ; preds = %if.then24.i
  call fastcc void @reallymarkobject(ptr noundef nonnull %L.val.i, ptr noundef nonnull %59)
  br label %return

if.else.i.i:                                      ; preds = %if.then24.i
  %66 = and i8 %63, -8
  %currentwhite.i.i = getelementptr inbounds %struct.global_State, ptr %L.val.i, i64 0, i32 3
  %67 = load i8, ptr %currentwhite.i.i, align 8
  %68 = and i8 %67, 3
  %or4.i.i = or disjoint i8 %68, %66
  store i8 %or4.i.i, ptr %marked20.i, align 1
  br label %return

if.else:                                          ; preds = %getfunc.exit, %luaO_str2d.exit.thread.i.i, %luaO_str2d.exit.i.i, %land.lhs.true
  %L.val = load ptr, ptr %top.i.i.i, align 8
  %tt.i44 = getelementptr %struct.lua_TValue, ptr %L.val, i64 -2, i32 1
  %69 = load i32, ptr %tt.i44, align 8
  %add.ptr8.i.i46 = getelementptr inbounds %struct.lua_TValue, ptr %L.val, i64 -2
  switch i32 %69, label %lua_setfenv.exit77 [
    i32 6, label %lua_iscfunction.exit
    i32 8, label %sw.bb8.i50
    i32 7, label %sw.bb2.i71
  ]

lua_iscfunction.exit:                             ; preds = %if.else
  %70 = load ptr, ptr %add.ptr8.i.i46, align 8
  %isC.i = getelementptr inbounds %struct.CClosure, ptr %70, i64 0, i32 3
  %71 = load i8, ptr %isC.i, align 2
  %tobool.i.not = icmp eq i8 %71, 0
  br i1 %tobool.i.not, label %lor.lhs.false.thread, label %if.then8

lor.lhs.false.thread:                             ; preds = %lua_iscfunction.exit
  %add.ptr.i75 = getelementptr inbounds %struct.lua_TValue, ptr %L.val, i64 -1
  %72 = load ptr, ptr %add.ptr.i75, align 8
  %env.i76 = getelementptr inbounds %struct.CClosure, ptr %70, i64 0, i32 6
  store ptr %72, ptr %env.i76, align 8
  br label %if.then.i54

sw.bb2.i71:                                       ; preds = %if.else
  %add.ptr4.i72 = getelementptr inbounds %struct.lua_TValue, ptr %L.val, i64 -1
  %73 = load ptr, ptr %add.ptr4.i72, align 8
  %74 = load ptr, ptr %add.ptr8.i.i46, align 8
  %env7.i73 = getelementptr inbounds %struct.anon.1, ptr %74, i64 0, i32 4
  store ptr %73, ptr %env7.i73, align 8
  br label %if.then.i54

sw.bb8.i50:                                       ; preds = %if.else
  %75 = load ptr, ptr %add.ptr8.i.i46, align 8
  %l_gt.i51 = getelementptr inbounds %struct.lua_State, ptr %75, i64 0, i32 22
  %add.ptr11.i52 = getelementptr inbounds %struct.lua_TValue, ptr %L.val, i64 -1
  %76 = load ptr, ptr %add.ptr11.i52, align 8
  store ptr %76, ptr %l_gt.i51, align 8
  %tt14.i53 = getelementptr inbounds %struct.lua_State, ptr %75, i64 0, i32 22, i32 1
  store i32 5, ptr %tt14.i53, align 8
  br label %if.then.i54

if.then.i54:                                      ; preds = %sw.bb8.i50, %sw.bb2.i71, %lor.lhs.false.thread
  %77 = load ptr, ptr %top.i.i.i, align 8
  %add.ptr16.i55 = getelementptr inbounds %struct.lua_TValue, ptr %77, i64 -1
  %78 = load ptr, ptr %add.ptr16.i55, align 8
  %marked.i56 = getelementptr inbounds %struct.GCheader, ptr %78, i64 0, i32 2
  %79 = load i8, ptr %marked.i56, align 1
  %80 = and i8 %79, 3
  %tobool18.not.i57 = icmp eq i8 %80, 0
  br i1 %tobool18.not.i57, label %return, label %land.lhs.true.i58

land.lhs.true.i58:                                ; preds = %if.then.i54
  %81 = load ptr, ptr %add.ptr8.i.i46, align 8
  %marked20.i59 = getelementptr inbounds %struct.GCheader, ptr %81, i64 0, i32 2
  %82 = load i8, ptr %marked20.i59, align 1
  %83 = and i8 %82, 4
  %tobool23.not.i60 = icmp eq i8 %83, 0
  br i1 %tobool23.not.i60, label %return, label %if.then24.i61

if.then24.i61:                                    ; preds = %land.lhs.true.i58
  %84 = getelementptr i8, ptr %L, i64 32
  %L.val.i62 = load ptr, ptr %84, align 8
  %gcstate.i.i63 = getelementptr inbounds %struct.global_State, ptr %L.val.i62, i64 0, i32 4
  %85 = load i8, ptr %gcstate.i.i63, align 1
  %cmp.i.i64 = icmp eq i8 %85, 1
  br i1 %cmp.i.i64, label %if.then.i.i70, label %if.else.i.i65

if.then.i.i70:                                    ; preds = %if.then24.i61
  call fastcc void @reallymarkobject(ptr noundef nonnull %L.val.i62, ptr noundef nonnull %78)
  br label %return

if.else.i.i65:                                    ; preds = %if.then24.i61
  %86 = and i8 %82, -8
  %currentwhite.i.i66 = getelementptr inbounds %struct.global_State, ptr %L.val.i62, i64 0, i32 3
  %87 = load i8, ptr %currentwhite.i.i66, align 8
  %88 = and i8 %87, 3
  %or4.i.i67 = or disjoint i8 %88, %86
  store i8 %or4.i.i67, ptr %marked20.i59, align 1
  br label %return

lua_setfenv.exit77:                               ; preds = %if.else
  %incdec.ptr.i69 = getelementptr inbounds %struct.lua_TValue, ptr %L.val, i64 -1
  store ptr %incdec.ptr.i69, ptr %top.i.i.i, align 8
  br label %if.then8

if.then8:                                         ; preds = %lua_setfenv.exit77, %lua_iscfunction.exit
  call void (ptr, ptr, ...) @luaL_error(ptr noundef nonnull %L, ptr noundef nonnull @.str.175)
  unreachable

return:                                           ; preds = %if.else.i.i65, %if.then.i.i70, %land.lhs.true.i58, %if.then.i54, %if.else.i.i, %if.then.i.i42, %land.lhs.true.i, %if.then.i39, %lua_insert.exit
  %retval.0 = phi i32 [ 0, %lua_insert.exit ], [ 0, %if.then.i39 ], [ 0, %land.lhs.true.i ], [ 0, %if.then.i.i42 ], [ 0, %if.else.i.i ], [ 1, %if.then.i54 ], [ 1, %land.lhs.true.i58 ], [ 1, %if.then.i.i70 ], [ 1, %if.else.i.i65 ]
  %.pn = load ptr, ptr %top.i.i.i, align 8
  %storemerge = getelementptr inbounds %struct.lua_TValue, ptr %.pn, i64 -1
  store ptr %storemerge, ptr %top.i.i.i, align 8
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_setmetatable(ptr noundef %L) #0 {
entry:
  %ar.i = alloca %struct.lua_Debug, align 8
  %base.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i, align 8
  %add.ptr.i.i = getelementptr %struct.lua_TValue, ptr %0, i64 1
  %top.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i, align 8
  %cmp1.not.i.i = icmp uge ptr %add.ptr.i.i, %1
  %cmp.i = icmp eq ptr %add.ptr.i.i, @luaO_nilobject_
  %or.cond = or i1 %cmp1.not.i.i, %cmp.i
  br i1 %or.cond, label %lua_type.exit, label %cond.false.i

cond.false.i:                                     ; preds = %entry
  %tt.i = getelementptr %struct.lua_TValue, ptr %0, i64 1, i32 1
  %2 = load i32, ptr %tt.i, align 8
  br label %lua_type.exit

lua_type.exit:                                    ; preds = %entry, %cond.false.i
  %cond.i = phi i32 [ %2, %cond.false.i ], [ -1, %entry ]
  %cmp1.not.i.i.i = icmp uge ptr %0, %1
  %cmp.i.i = icmp eq ptr %0, @luaO_nilobject_
  %or.cond30 = or i1 %cmp.i.i, %cmp1.not.i.i.i
  br i1 %or.cond30, label %if.then.i, label %lua_type.exit.i

lua_type.exit.i:                                  ; preds = %lua_type.exit
  %tt.i.i = getelementptr inbounds %struct.lua_TValue, ptr %0, i64 0, i32 1
  %3 = load i32, ptr %tt.i.i, align 8
  %cmp.not.i = icmp eq i32 %3, 5
  br i1 %cmp.not.i, label %luaL_checktype.exit, label %if.then.i

if.then.i:                                        ; preds = %lua_type.exit, %lua_type.exit.i
  tail call fastcc void @luaL_typerror(ptr noundef nonnull %L, i32 noundef 1, ptr noundef nonnull @.str.26)
  unreachable

luaL_checktype.exit:                              ; preds = %lua_type.exit.i
  switch i32 %cond.i, label %lor.rhs [
    i32 5, label %sw.epilog.i.i
    i32 0, label %sw.epilog.i.i
  ]

lor.rhs:                                          ; preds = %luaL_checktype.exit
  call void @llvm.lifetime.start.p0(i64 120, ptr nonnull %ar.i)
  %ci1.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %4 = load ptr, ptr %ci1.i.i, align 8
  %base_ci4.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 12
  %5 = load ptr, ptr %base_ci4.i.i, align 8
  %cmp5.i.i = icmp ugt ptr %4, %5
  br i1 %cmp5.i.i, label %if.end.i, label %if.then.i8

if.then.i8:                                       ; preds = %lor.rhs
  tail call void (ptr, ptr, ...) @luaL_error(ptr noundef nonnull %L, ptr noundef nonnull @.str.116, i32 noundef 2, ptr noundef nonnull @.str.180)
  unreachable

if.end.i:                                         ; preds = %lor.rhs
  %sub.ptr.lhs.cast.i.i = ptrtoint ptr %4 to i64
  %sub.ptr.rhs.cast.i.i = ptrtoint ptr %5 to i64
  %sub.ptr.sub.i.i = sub i64 %sub.ptr.lhs.cast.i.i, %sub.ptr.rhs.cast.i.i
  %sub.ptr.div.i.i = sdiv exact i64 %sub.ptr.sub.i.i, 40
  %conv.i.i = trunc i64 %sub.ptr.div.i.i to i32
  %i_ci11.i.i = getelementptr inbounds %struct.lua_Debug, ptr %ar.i, i64 0, i32 10
  store i32 %conv.i.i, ptr %i_ci11.i.i, align 4
  call fastcc void @lua_getinfo(ptr noundef nonnull %L, ptr noundef nonnull @.str.117, ptr noundef nonnull %ar.i)
  %namewhat.i = getelementptr inbounds %struct.lua_Debug, ptr %ar.i, i64 0, i32 2
  %6 = load ptr, ptr %namewhat.i, align 8
  %call3.i = call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %6, ptr noundef nonnull dereferenceable(7) @.str.118) #34
  %name10.i = getelementptr inbounds %struct.lua_Debug, ptr %ar.i, i64 0, i32 1
  %7 = load ptr, ptr %name10.i, align 8
  %cmp11.i = icmp eq ptr %7, null
  br i1 %cmp11.i, label %if.then12.i, label %if.end14.i

if.then12.i:                                      ; preds = %if.end.i
  store ptr @.str.120, ptr %name10.i, align 8
  br label %if.end14.i

if.end14.i:                                       ; preds = %if.then12.i, %if.end.i
  %8 = phi ptr [ @.str.120, %if.then12.i ], [ %7, %if.end.i ]
  %cmp.i9 = icmp eq i32 %call3.i, 0
  %spec.select = select i1 %cmp.i9, i32 1, i32 2
  call void (ptr, ptr, ...) @luaL_error(ptr noundef nonnull %L, ptr noundef nonnull @.str.121, i32 noundef %spec.select, ptr noundef nonnull %8, ptr noundef nonnull @.str.180)
  unreachable

sw.epilog.i.i:                                    ; preds = %luaL_checktype.exit, %luaL_checktype.exit
  %9 = load ptr, ptr %0, align 8
  %metatable.i.i = getelementptr inbounds %struct.Table, ptr %9, i64 0, i32 5
  %mt.0.i.i = load ptr, ptr %metatable.i.i, align 8
  %cmp.i.i14 = icmp eq ptr %mt.0.i.i, null
  br i1 %cmp.i.i14, label %if.end, label %if.end.i15

if.end.i15:                                       ; preds = %sw.epilog.i.i
  store ptr %mt.0.i.i, ptr %1, align 8
  %tt7.i.i = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 0, i32 1
  store i32 5, ptr %tt7.i.i, align 8
  %10 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i.i = getelementptr inbounds %struct.lua_TValue, ptr %10, i64 1
  store ptr %incdec.ptr.i.i, ptr %top.i.i, align 8
  tail call fastcc void @lua_pushstring(ptr noundef nonnull %L, ptr noundef nonnull @.str.181)
  %11 = load ptr, ptr %top.i.i, align 8
  %add.ptr8.i.i.i = getelementptr inbounds %struct.lua_TValue, ptr %11, i64 -2
  %12 = load ptr, ptr %add.ptr8.i.i.i, align 8
  %add.ptr.i.i16 = getelementptr inbounds %struct.lua_TValue, ptr %11, i64 -1
  %call1.i.i17 = tail call fastcc ptr @luaH_get(ptr noundef %12, ptr noundef nonnull %add.ptr.i.i16)
  %13 = load i64, ptr %call1.i.i17, align 8
  store i64 %13, ptr %add.ptr.i.i16, align 8
  %tt.i6.i = getelementptr inbounds %struct.lua_TValue, ptr %call1.i.i17, i64 0, i32 1
  %14 = load i32, ptr %tt.i6.i, align 8
  %tt6.i.i = getelementptr %struct.lua_TValue, ptr %11, i64 -1, i32 1
  store i32 %14, ptr %tt6.i.i, align 8
  %15 = load ptr, ptr %top.i.i, align 8
  %add.ptr8.i.i8.i = getelementptr inbounds %struct.lua_TValue, ptr %15, i64 -1
  %cmp.i9.i = icmp eq ptr %add.ptr8.i.i8.i, @luaO_nilobject_
  br i1 %cmp.i9.i, label %if.else.i, label %lua_type.exit.i18

lua_type.exit.i18:                                ; preds = %if.end.i15
  %tt.i10.i = getelementptr %struct.lua_TValue, ptr %15, i64 -1, i32 1
  %16 = load i32, ptr %tt.i10.i, align 8
  %cmp.i19 = icmp eq i32 %16, 0
  br i1 %cmp.i19, label %luaL_getmetafield.exit.thread26, label %if.else.i

luaL_getmetafield.exit.thread26:                  ; preds = %lua_type.exit.i18
  %add.ptr9.i.i = getelementptr %struct.lua_TValue, ptr %15, i64 -2
  %.pre = load ptr, ptr %base.i.i, align 8
  br label %if.end

if.else.i:                                        ; preds = %lua_type.exit.i18, %if.end.i15
  %add.ptr8.i.i14.i = getelementptr inbounds %struct.lua_TValue, ptr %15, i64 -2
  br label %while.body.i.i

while.body.i.i:                                   ; preds = %while.body.i.i, %if.else.i
  %incdec.ptr10.i.i = phi ptr [ %incdec.ptr.i17.i, %while.body.i.i ], [ %add.ptr8.i.i8.i, %if.else.i ]
  %p.09.i.i = phi ptr [ %incdec.ptr10.i.i, %while.body.i.i ], [ %add.ptr8.i.i14.i, %if.else.i ]
  %17 = load i64, ptr %incdec.ptr10.i.i, align 8
  store i64 %17, ptr %p.09.i.i, align 8
  %tt.i16.i = getelementptr inbounds %struct.lua_TValue, ptr %p.09.i.i, i64 1, i32 1
  %18 = load i32, ptr %tt.i16.i, align 8
  %tt2.i.i = getelementptr inbounds %struct.lua_TValue, ptr %p.09.i.i, i64 0, i32 1
  store i32 %18, ptr %tt2.i.i, align 8
  %incdec.ptr.i17.i = getelementptr inbounds %struct.lua_TValue, ptr %incdec.ptr10.i.i, i64 1
  %19 = load ptr, ptr %top.i.i, align 8
  %cmp.i18.i = icmp ult ptr %incdec.ptr.i17.i, %19
  br i1 %cmp.i18.i, label %while.body.i.i, label %if.then, !llvm.loop !11

if.then:                                          ; preds = %while.body.i.i
  %incdec.ptr4.i.i = getelementptr inbounds %struct.lua_TValue, ptr %19, i64 -1
  store ptr %incdec.ptr4.i.i, ptr %top.i.i, align 8
  tail call void (ptr, ptr, ...) @luaL_error(ptr noundef nonnull %L, ptr noundef nonnull @.str.182)
  unreachable

if.end:                                           ; preds = %sw.epilog.i.i, %luaL_getmetafield.exit.thread26
  %20 = phi ptr [ %0, %sw.epilog.i.i ], [ %.pre, %luaL_getmetafield.exit.thread26 ]
  %21 = phi ptr [ %1, %sw.epilog.i.i ], [ %add.ptr9.i.i, %luaL_getmetafield.exit.thread26 ]
  %add.ptr10.i = getelementptr inbounds %struct.lua_TValue, ptr %20, i64 2
  %cmp111.i = icmp ult ptr %21, %add.ptr10.i
  br i1 %cmp111.i, label %while.body.i, label %lua_settop.exit

while.body.i:                                     ; preds = %if.end, %while.body.i
  %22 = phi ptr [ %23, %while.body.i ], [ %21, %if.end ]
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %22, i64 1
  store ptr %incdec.ptr.i, ptr %top.i.i, align 8
  %tt.i21 = getelementptr inbounds %struct.lua_TValue, ptr %22, i64 0, i32 1
  store i32 0, ptr %tt.i21, align 8
  %23 = load ptr, ptr %top.i.i, align 8
  %24 = load ptr, ptr %base.i.i, align 8
  %add.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %24, i64 2
  %cmp1.i = icmp ult ptr %23, %add.ptr.i
  br i1 %cmp1.i, label %while.body.i, label %lua_settop.exit, !llvm.loop !13

lua_settop.exit:                                  ; preds = %while.body.i, %if.end
  %add.ptr9.sink.i = phi ptr [ %add.ptr10.i, %if.end ], [ %add.ptr.i, %while.body.i ]
  store ptr %add.ptr9.sink.i, ptr %top.i.i, align 8
  tail call fastcc void @lua_setmetatable(ptr noundef nonnull %L, i32 noundef 1)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_tonumber(ptr noundef %L) #0 {
entry:
  %endptr.i.i.i36 = alloca ptr, align 8
  %ar.i = alloca %struct.lua_Debug, align 8
  %endptr.i.i.i = alloca ptr, align 8
  %s2 = alloca ptr, align 8
  %base.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i.i, align 8
  %add.ptr.i.i.i = getelementptr %struct.lua_TValue, ptr %0, i64 1
  %top.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i.i = icmp uge ptr %add.ptr.i.i.i, %1
  %cmp.i.i = icmp eq ptr %add.ptr.i.i.i, @luaO_nilobject_
  %or.cond86 = or i1 %cmp1.not.i.i.i, %cmp.i.i
  br i1 %or.cond86, label %if.then, label %lua_type.exit.i

lua_type.exit.i:                                  ; preds = %entry
  %tt.i.i = getelementptr %struct.lua_TValue, ptr %0, i64 1, i32 1
  %2 = load i32, ptr %tt.i.i, align 8
  %cmp.i = icmp slt i32 %2, 1
  br i1 %cmp.i, label %if.then, label %cond.false.i

cond.false.i:                                     ; preds = %lua_type.exit.i
  %call.i.i = tail call fastcc i64 @lua_tointeger(ptr noundef nonnull %L, i32 noundef 2)
  %cmp.i3.i = icmp eq i64 %call.i.i, 0
  br i1 %cmp.i3.i, label %land.lhs.true.i.i, label %luaL_optinteger.exit

land.lhs.true.i.i:                                ; preds = %cond.false.i
  %3 = load ptr, ptr %base.i.i.i, align 8
  %add.ptr.i.i39 = getelementptr %struct.lua_TValue, ptr %3, i64 1
  %4 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i41 = icmp ult ptr %add.ptr.i.i39, %4
  %add.ptr.luaO_nilobject_.i.i42 = select i1 %cmp1.not.i.i41, ptr %add.ptr.i.i39, ptr @luaO_nilobject_
  %tt.i43 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i42, i64 0, i32 1
  %5 = load i32, ptr %tt.i43, align 8
  switch i32 %5, label %if.then.i.i [
    i32 3, label %if.else
    i32 4, label %land.lhs.true.i.i44
  ]

land.lhs.true.i.i44:                              ; preds = %land.lhs.true.i.i
  %6 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i42, align 8
  %add.ptr.i3.i45 = getelementptr inbounds %union.TString, ptr %6, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i.i36)
  %call.i.i.i46 = call double @strtod(ptr noundef nonnull %add.ptr.i3.i45, ptr noundef nonnull %endptr.i.i.i36) #35
  %7 = load ptr, ptr %endptr.i.i.i36, align 8
  %cmp.i.i.i47 = icmp eq ptr %7, %add.ptr.i3.i45
  br i1 %cmp.i.i.i47, label %luaO_str2d.exit.thread.i.i69, label %if.end.i.i.i48

luaO_str2d.exit.thread.i.i69:                     ; preds = %land.lhs.true.i.i44
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i36)
  br label %if.then.i.i

if.end.i.i.i48:                                   ; preds = %land.lhs.true.i.i44
  %8 = load i8, ptr %7, align 1
  switch i8 %8, label %if.end9.i.i.i53 [
    i8 120, label %if.then6.i.i.i49
    i8 88, label %if.then6.i.i.i49
  ]

if.then6.i.i.i49:                                 ; preds = %if.end.i.i.i48, %if.end.i.i.i48
  %call7.i.i.i50 = call i64 @strtoul(ptr noundef nonnull %add.ptr.i3.i45, ptr noundef nonnull %endptr.i.i.i36, i32 noundef 16) #35
  %.pre.i.i.i51 = load ptr, ptr %endptr.i.i.i36, align 8
  %.pre5.i.i.i52 = load i8, ptr %.pre.i.i.i51, align 1
  br label %if.end9.i.i.i53

if.end9.i.i.i53:                                  ; preds = %if.then6.i.i.i49, %if.end.i.i.i48
  %9 = phi i8 [ %8, %if.end.i.i.i48 ], [ %.pre5.i.i.i52, %if.then6.i.i.i49 ]
  %endptr.promoted.i.i.i54 = phi ptr [ %7, %if.end.i.i.i48 ], [ %.pre.i.i.i51, %if.then6.i.i.i49 ]
  %cmp11.i.i.i55 = icmp eq i8 %9, 0
  br i1 %cmp11.i.i.i55, label %luaO_str2d.exit.thread9.i.i68, label %while.cond.preheader.i.i.i56

luaO_str2d.exit.thread9.i.i68:                    ; preds = %if.end9.i.i.i53
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i36)
  br label %if.else

while.cond.preheader.i.i.i56:                     ; preds = %if.end9.i.i.i53
  %call15.i.i.i57 = tail call ptr @__ctype_b_loc() #39
  %10 = load ptr, ptr %call15.i.i.i57, align 8
  br label %while.cond.i.i.i58

while.cond.i.i.i58:                               ; preds = %while.cond.i.i.i58, %while.cond.preheader.i.i.i56
  %incdec.ptr4.i.i.i59 = phi ptr [ %endptr.promoted.i.i.i54, %while.cond.preheader.i.i.i56 ], [ %incdec.ptr.i.i.i63, %while.cond.i.i.i58 ]
  %11 = load i8, ptr %incdec.ptr4.i.i.i59, align 1
  %idxprom.i.i.i60 = zext i8 %11 to i64
  %arrayidx.i.i.i61 = getelementptr inbounds i16, ptr %10, i64 %idxprom.i.i.i60
  %12 = load i16, ptr %arrayidx.i.i.i61, align 2
  %13 = and i16 %12, 8192
  %tobool.not.i.i.i62 = icmp eq i16 %13, 0
  %incdec.ptr.i.i.i63 = getelementptr inbounds i8, ptr %incdec.ptr4.i.i.i59, i64 1
  br i1 %tobool.not.i.i.i62, label %luaO_str2d.exit.i.i64, label %while.cond.i.i.i58, !llvm.loop !35

luaO_str2d.exit.i.i64:                            ; preds = %while.cond.i.i.i58
  %cmp19.not.i.not.i.i65 = icmp eq i8 %11, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i36)
  br i1 %cmp19.not.i.not.i.i65, label %if.else, label %if.then.i.i

if.then.i.i:                                      ; preds = %land.lhs.true.i.i, %luaO_str2d.exit.i.i64, %luaO_str2d.exit.thread.i.i69
  tail call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 2, ptr noundef nonnull @.str.24)
  unreachable

luaL_optinteger.exit:                             ; preds = %cond.false.i
  %conv = trunc i64 %call.i.i to i32
  %cmp = icmp eq i32 %conv, 10
  br i1 %cmp, label %luaL_optinteger.exit.if.then_crit_edge, label %if.else

luaL_optinteger.exit.if.then_crit_edge:           ; preds = %luaL_optinteger.exit
  %.pre = load ptr, ptr %base.i.i.i, align 8
  %.pre93 = load ptr, ptr %top.i.i.i, align 8
  br label %if.then

if.then:                                          ; preds = %luaL_optinteger.exit.if.then_crit_edge, %entry, %lua_type.exit.i
  %14 = phi ptr [ %.pre93, %luaL_optinteger.exit.if.then_crit_edge ], [ %1, %entry ], [ %1, %lua_type.exit.i ]
  %15 = phi ptr [ %.pre, %luaL_optinteger.exit.if.then_crit_edge ], [ %0, %entry ], [ %0, %lua_type.exit.i ]
  %cmp1.not.i.i.i16 = icmp uge ptr %15, %14
  %cmp.i.i18 = icmp eq ptr %15, @luaO_nilobject_
  %or.cond87 = or i1 %cmp.i.i18, %cmp1.not.i.i.i16
  br i1 %or.cond87, label %if.then.i, label %lua_type.exit.i19

lua_type.exit.i19:                                ; preds = %if.then
  %tt.i.i20 = getelementptr inbounds %struct.lua_TValue, ptr %15, i64 0, i32 1
  %16 = load i32, ptr %tt.i.i20, align 8
  switch i32 %16, label %if.end27 [
    i32 -1, label %if.then.i
    i32 3, label %if.then3
    i32 4, label %land.lhs.true.i.i23
  ]

if.then.i:                                        ; preds = %lua_type.exit.i19, %if.then
  tail call fastcc void @luaL_argerror(ptr noundef nonnull %L, i32 noundef 1, ptr noundef nonnull @.str.115)
  unreachable

land.lhs.true.i.i23:                              ; preds = %lua_type.exit.i19
  %17 = load ptr, ptr %15, align 8
  %add.ptr.i3.i = getelementptr inbounds %union.TString, ptr %17, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i.i)
  %call.i.i.i = call double @strtod(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i) #35
  %18 = load ptr, ptr %endptr.i.i.i, align 8
  %cmp.i.i.i = icmp eq ptr %18, %add.ptr.i3.i
  br i1 %cmp.i.i.i, label %luaO_str2d.exit.thread.i.i, label %if.end.i.i.i

luaO_str2d.exit.thread.i.i:                       ; preds = %land.lhs.true.i.i23
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %if.end27

if.end.i.i.i:                                     ; preds = %land.lhs.true.i.i23
  %19 = load i8, ptr %18, align 1
  switch i8 %19, label %if.end9.i.i.i [
    i8 120, label %if.then6.i.i.i
    i8 88, label %if.then6.i.i.i
  ]

if.then6.i.i.i:                                   ; preds = %if.end.i.i.i, %if.end.i.i.i
  %call7.i.i.i = call i64 @strtoul(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i, i32 noundef 16) #35
  %.pre.i.i.i = load ptr, ptr %endptr.i.i.i, align 8
  %.pre5.i.i.i = load i8, ptr %.pre.i.i.i, align 1
  br label %if.end9.i.i.i

if.end9.i.i.i:                                    ; preds = %if.then6.i.i.i, %if.end.i.i.i
  %20 = phi i8 [ %19, %if.end.i.i.i ], [ %.pre5.i.i.i, %if.then6.i.i.i ]
  %endptr.promoted.i.i.i = phi ptr [ %18, %if.end.i.i.i ], [ %.pre.i.i.i, %if.then6.i.i.i ]
  %cmp11.i.i.i = icmp eq i8 %20, 0
  br i1 %cmp11.i.i.i, label %luaO_str2d.exit.thread9.i.i, label %while.cond.preheader.i.i.i

luaO_str2d.exit.thread9.i.i:                      ; preds = %if.end9.i.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %if.then3

while.cond.preheader.i.i.i:                       ; preds = %if.end9.i.i.i
  %call15.i.i.i = tail call ptr @__ctype_b_loc() #39
  %21 = load ptr, ptr %call15.i.i.i, align 8
  br label %while.cond.i.i.i

while.cond.i.i.i:                                 ; preds = %while.cond.i.i.i, %while.cond.preheader.i.i.i
  %incdec.ptr4.i.i.i = phi ptr [ %endptr.promoted.i.i.i, %while.cond.preheader.i.i.i ], [ %incdec.ptr.i.i.i, %while.cond.i.i.i ]
  %22 = load i8, ptr %incdec.ptr4.i.i.i, align 1
  %idxprom.i.i.i = zext i8 %22 to i64
  %arrayidx.i.i.i = getelementptr inbounds i16, ptr %21, i64 %idxprom.i.i.i
  %23 = load i16, ptr %arrayidx.i.i.i, align 2
  %24 = and i16 %23, 8192
  %tobool.not.i.i.i = icmp eq i16 %24, 0
  %incdec.ptr.i.i.i = getelementptr inbounds i8, ptr %incdec.ptr4.i.i.i, i64 1
  br i1 %tobool.not.i.i.i, label %luaO_str2d.exit.i.i, label %while.cond.i.i.i, !llvm.loop !35

luaO_str2d.exit.i.i:                              ; preds = %while.cond.i.i.i
  %cmp19.not.i.not.i.i = icmp eq i8 %22, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br i1 %cmp19.not.i.not.i.i, label %if.then3, label %if.end27

if.then3:                                         ; preds = %lua_type.exit.i19, %luaO_str2d.exit.thread9.i.i, %luaO_str2d.exit.i.i
  %call4 = tail call fastcc double @lua_tonumber(ptr noundef %L, i32 noundef 1)
  %25 = load ptr, ptr %top.i.i.i, align 8
  store double %call4, ptr %25, align 8
  br label %return

if.else:                                          ; preds = %luaO_str2d.exit.thread9.i.i68, %luaO_str2d.exit.i.i64, %land.lhs.true.i.i, %luaL_optinteger.exit
  %conv83 = phi i32 [ %conv, %luaL_optinteger.exit ], [ 0, %land.lhs.true.i.i ], [ 0, %luaO_str2d.exit.i.i64 ], [ 0, %luaO_str2d.exit.thread9.i.i68 ]
  %call.i = tail call fastcc ptr @lua_tolstring(ptr noundef %L, i32 noundef 1, ptr noundef null)
  %tobool.not.i = icmp eq ptr %call.i, null
  br i1 %tobool.not.i, label %if.then.i25, label %luaL_checklstring.exit

if.then.i25:                                      ; preds = %if.else
  tail call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 1, ptr noundef nonnull @.str.25)
  unreachable

luaL_checklstring.exit:                           ; preds = %if.else
  %26 = add i32 %conv83, -2
  %or.cond = icmp ult i32 %26, 35
  br i1 %or.cond, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %luaL_checklstring.exit
  call void @llvm.lifetime.start.p0(i64 120, ptr nonnull %ar.i)
  %ci1.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %27 = load ptr, ptr %ci1.i.i, align 8
  %base_ci4.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 12
  %28 = load ptr, ptr %base_ci4.i.i, align 8
  %cmp5.i.i = icmp ugt ptr %27, %28
  br i1 %cmp5.i.i, label %if.end.i, label %if.then.i27

if.then.i27:                                      ; preds = %lor.rhs
  tail call void (ptr, ptr, ...) @luaL_error(ptr noundef nonnull %L, ptr noundef nonnull @.str.116, i32 noundef 2, ptr noundef nonnull @.str.183)
  unreachable

if.end.i:                                         ; preds = %lor.rhs
  %sub.ptr.lhs.cast.i.i = ptrtoint ptr %27 to i64
  %sub.ptr.rhs.cast.i.i = ptrtoint ptr %28 to i64
  %sub.ptr.sub.i.i = sub i64 %sub.ptr.lhs.cast.i.i, %sub.ptr.rhs.cast.i.i
  %sub.ptr.div.i.i = sdiv exact i64 %sub.ptr.sub.i.i, 40
  %conv.i.i = trunc i64 %sub.ptr.div.i.i to i32
  %i_ci11.i.i = getelementptr inbounds %struct.lua_Debug, ptr %ar.i, i64 0, i32 10
  store i32 %conv.i.i, ptr %i_ci11.i.i, align 4
  call fastcc void @lua_getinfo(ptr noundef nonnull %L, ptr noundef nonnull @.str.117, ptr noundef nonnull %ar.i)
  %namewhat.i = getelementptr inbounds %struct.lua_Debug, ptr %ar.i, i64 0, i32 2
  %29 = load ptr, ptr %namewhat.i, align 8
  %call3.i = call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %29, ptr noundef nonnull dereferenceable(7) @.str.118) #34
  %name10.i = getelementptr inbounds %struct.lua_Debug, ptr %ar.i, i64 0, i32 1
  %30 = load ptr, ptr %name10.i, align 8
  %cmp11.i = icmp eq ptr %30, null
  br i1 %cmp11.i, label %if.then12.i, label %if.end14.i

if.then12.i:                                      ; preds = %if.end.i
  store ptr @.str.120, ptr %name10.i, align 8
  br label %if.end14.i

if.end14.i:                                       ; preds = %if.then12.i, %if.end.i
  %31 = phi ptr [ @.str.120, %if.then12.i ], [ %30, %if.end.i ]
  %cmp.i29 = icmp eq i32 %call3.i, 0
  %spec.select = select i1 %cmp.i29, i32 1, i32 2
  call void (ptr, ptr, ...) @luaL_error(ptr noundef nonnull %L, ptr noundef nonnull @.str.121, i32 noundef %spec.select, ptr noundef nonnull %31, ptr noundef nonnull @.str.183)
  unreachable

lor.end:                                          ; preds = %luaL_checklstring.exit
  %call12 = call i64 @strtoul(ptr noundef nonnull %call.i, ptr noundef nonnull %s2, i32 noundef %conv83) #35
  %32 = load ptr, ptr %s2, align 8
  %cmp13.not = icmp eq ptr %call.i, %32
  br i1 %cmp13.not, label %if.end27, label %while.cond.preheader

while.cond.preheader:                             ; preds = %lor.end
  %call16 = tail call ptr @__ctype_b_loc() #39
  %33 = load ptr, ptr %call16, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.cond, %while.cond.preheader
  %incdec.ptr90 = phi ptr [ %32, %while.cond.preheader ], [ %incdec.ptr, %while.cond ]
  %34 = load i8, ptr %incdec.ptr90, align 1
  %idxprom = zext i8 %34 to i64
  %arrayidx = getelementptr inbounds i16, ptr %33, i64 %idxprom
  %35 = load i16, ptr %arrayidx, align 2
  %36 = and i16 %35, 8192
  %tobool19.not = icmp eq i16 %36, 0
  %incdec.ptr = getelementptr inbounds i8, ptr %incdec.ptr90, i64 1
  br i1 %tobool19.not, label %while.end, label %while.cond, !llvm.loop !88

while.end:                                        ; preds = %while.cond
  %cmp21 = icmp eq i8 %34, 0
  br i1 %cmp21, label %if.then23, label %if.end27

if.then23:                                        ; preds = %while.end
  %conv24 = uitofp i64 %call12 to double
  %37 = load ptr, ptr %top.i.i.i, align 8
  store double %conv24, ptr %37, align 8
  br label %return

if.end27:                                         ; preds = %lua_type.exit.i19, %luaO_str2d.exit.thread.i.i, %luaO_str2d.exit.i.i, %lor.end, %while.end
  %38 = load ptr, ptr %top.i.i.i, align 8
  br label %return

return:                                           ; preds = %if.end27, %if.then23, %if.then3
  %.sink96 = phi ptr [ %38, %if.end27 ], [ %37, %if.then23 ], [ %25, %if.then3 ]
  %.sink = phi i32 [ 0, %if.end27 ], [ 3, %if.then23 ], [ 3, %if.then3 ]
  %tt.i34 = getelementptr inbounds %struct.lua_TValue, ptr %.sink96, i64 0, i32 1
  store i32 %.sink, ptr %tt.i34, align 8
  %39 = load ptr, ptr %top.i.i.i, align 8
  %incdec.ptr.i35 = getelementptr inbounds %struct.lua_TValue, ptr %39, i64 1
  store ptr %incdec.ptr.i35, ptr %top.i.i.i, align 8
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_type(ptr noundef %L) #0 {
entry:
  %base.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i.i, align 8
  %top.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i.i = icmp uge ptr %0, %1
  %cmp.i.i = icmp eq ptr %0, @luaO_nilobject_
  %or.cond = or i1 %cmp.i.i, %cmp1.not.i.i.i
  br i1 %or.cond, label %if.then.i, label %lua_type.exit.i

lua_type.exit.i:                                  ; preds = %entry
  %tt.i.i = getelementptr inbounds %struct.lua_TValue, ptr %0, i64 0, i32 1
  %2 = load i32, ptr %tt.i.i, align 8
  %cmp.i = icmp eq i32 %2, -1
  br i1 %cmp.i, label %if.then.i, label %lua_typename.exit

if.then.i:                                        ; preds = %lua_type.exit.i, %entry
  tail call fastcc void @luaL_argerror(ptr noundef nonnull %L, i32 noundef 1, ptr noundef nonnull @.str.115)
  unreachable

lua_typename.exit:                                ; preds = %lua_type.exit.i
  %idxprom.i = sext i32 %2 to i64
  %arrayidx.i = getelementptr inbounds [11 x ptr], ptr @luaT_typenames, i64 0, i64 %idxprom.i
  %3 = load ptr, ptr %arrayidx.i, align 8
  tail call fastcc void @lua_pushstring(ptr noundef nonnull %L, ptr noundef %3)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_unpack(ptr noundef %L) #0 {
entry:
  %endptr.i.i.i103 = alloca ptr, align 8
  %endptr.i.i.i = alloca ptr, align 8
  %base.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i.i, align 8
  %top.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i.i = icmp uge ptr %0, %1
  %cmp.i.i = icmp eq ptr %0, @luaO_nilobject_
  %or.cond = or i1 %cmp.i.i, %cmp1.not.i.i.i
  br i1 %or.cond, label %if.then.i, label %lua_type.exit.i

lua_type.exit.i:                                  ; preds = %entry
  %tt.i.i = getelementptr inbounds %struct.lua_TValue, ptr %0, i64 0, i32 1
  %2 = load i32, ptr %tt.i.i, align 8
  %cmp.not.i = icmp eq i32 %2, 5
  br i1 %cmp.not.i, label %luaL_checktype.exit, label %if.then.i

if.then.i:                                        ; preds = %entry, %lua_type.exit.i
  tail call fastcc void @luaL_typerror(ptr noundef nonnull %L, i32 noundef 1, ptr noundef nonnull @.str.26)
  unreachable

luaL_checktype.exit:                              ; preds = %lua_type.exit.i
  %add.ptr.i.i.i18 = getelementptr %struct.lua_TValue, ptr %0, i64 1
  %cmp1.not.i.i.i20 = icmp uge ptr %add.ptr.i.i.i18, %1
  %cmp.i.i22 = icmp eq ptr %add.ptr.i.i.i18, @luaO_nilobject_
  %or.cond150 = or i1 %cmp1.not.i.i.i20, %cmp.i.i22
  br i1 %or.cond150, label %luaL_optinteger.exit, label %lua_type.exit.i23

lua_type.exit.i23:                                ; preds = %luaL_checktype.exit
  %tt.i.i24 = getelementptr %struct.lua_TValue, ptr %0, i64 1, i32 1
  %3 = load i32, ptr %tt.i.i24, align 8
  %cmp.i = icmp slt i32 %3, 1
  br i1 %cmp.i, label %luaL_optinteger.exit, label %cond.false.i

cond.false.i:                                     ; preds = %lua_type.exit.i23
  %call.i.i = tail call fastcc i64 @lua_tointeger(ptr noundef nonnull %L, i32 noundef 2)
  %cmp.i3.i = icmp eq i64 %call.i.i, 0
  br i1 %cmp.i3.i, label %land.lhs.true.i.i, label %luaL_optinteger.exit

land.lhs.true.i.i:                                ; preds = %cond.false.i
  %4 = load ptr, ptr %base.i.i.i, align 8
  %add.ptr.i.i94 = getelementptr %struct.lua_TValue, ptr %4, i64 1
  %5 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i96 = icmp ult ptr %add.ptr.i.i94, %5
  %add.ptr.luaO_nilobject_.i.i97 = select i1 %cmp1.not.i.i96, ptr %add.ptr.i.i94, ptr @luaO_nilobject_
  %tt.i99 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i97, i64 0, i32 1
  %6 = load i32, ptr %tt.i99, align 8
  switch i32 %6, label %if.then.i.i [
    i32 3, label %luaL_optinteger.exit
    i32 4, label %land.lhs.true.i.i100
  ]

land.lhs.true.i.i100:                             ; preds = %land.lhs.true.i.i
  %7 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i97, align 8
  %add.ptr.i3.i = getelementptr inbounds %union.TString, ptr %7, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i.i)
  %call.i.i.i = call double @strtod(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i) #35
  %8 = load ptr, ptr %endptr.i.i.i, align 8
  %cmp.i.i.i101 = icmp eq ptr %8, %add.ptr.i3.i
  br i1 %cmp.i.i.i101, label %luaO_str2d.exit.thread.i.i, label %if.end.i.i.i102

luaO_str2d.exit.thread.i.i:                       ; preds = %land.lhs.true.i.i100
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %if.then.i.i

if.end.i.i.i102:                                  ; preds = %land.lhs.true.i.i100
  %9 = load i8, ptr %8, align 1
  switch i8 %9, label %if.end9.i.i.i [
    i8 120, label %if.then6.i.i.i
    i8 88, label %if.then6.i.i.i
  ]

if.then6.i.i.i:                                   ; preds = %if.end.i.i.i102, %if.end.i.i.i102
  %call7.i.i.i = call i64 @strtoul(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i, i32 noundef 16) #35
  %.pre.i.i.i = load ptr, ptr %endptr.i.i.i, align 8
  %.pre5.i.i.i = load i8, ptr %.pre.i.i.i, align 1
  br label %if.end9.i.i.i

if.end9.i.i.i:                                    ; preds = %if.then6.i.i.i, %if.end.i.i.i102
  %10 = phi i8 [ %9, %if.end.i.i.i102 ], [ %.pre5.i.i.i, %if.then6.i.i.i ]
  %endptr.promoted.i.i.i = phi ptr [ %8, %if.end.i.i.i102 ], [ %.pre.i.i.i, %if.then6.i.i.i ]
  %cmp11.i.i.i = icmp eq i8 %10, 0
  br i1 %cmp11.i.i.i, label %luaO_str2d.exit.thread9.i.i, label %while.cond.preheader.i.i.i

luaO_str2d.exit.thread9.i.i:                      ; preds = %if.end9.i.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %luaL_optinteger.exit

while.cond.preheader.i.i.i:                       ; preds = %if.end9.i.i.i
  %call15.i.i.i = tail call ptr @__ctype_b_loc() #39
  %11 = load ptr, ptr %call15.i.i.i, align 8
  br label %while.cond.i.i.i

while.cond.i.i.i:                                 ; preds = %while.cond.i.i.i, %while.cond.preheader.i.i.i
  %incdec.ptr4.i.i.i = phi ptr [ %endptr.promoted.i.i.i, %while.cond.preheader.i.i.i ], [ %incdec.ptr.i.i.i, %while.cond.i.i.i ]
  %12 = load i8, ptr %incdec.ptr4.i.i.i, align 1
  %idxprom.i.i.i = zext i8 %12 to i64
  %arrayidx.i.i.i = getelementptr inbounds i16, ptr %11, i64 %idxprom.i.i.i
  %13 = load i16, ptr %arrayidx.i.i.i, align 2
  %14 = and i16 %13, 8192
  %tobool.not.i.i.i = icmp eq i16 %14, 0
  %incdec.ptr.i.i.i = getelementptr inbounds i8, ptr %incdec.ptr4.i.i.i, i64 1
  br i1 %tobool.not.i.i.i, label %luaO_str2d.exit.i.i, label %while.cond.i.i.i, !llvm.loop !35

luaO_str2d.exit.i.i:                              ; preds = %while.cond.i.i.i
  %cmp19.not.i.not.i.i = icmp eq i8 %12, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br i1 %cmp19.not.i.not.i.i, label %luaL_optinteger.exit, label %if.then.i.i

if.then.i.i:                                      ; preds = %land.lhs.true.i.i, %luaO_str2d.exit.i.i, %luaO_str2d.exit.thread.i.i
  tail call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 2, ptr noundef nonnull @.str.24)
  unreachable

luaL_optinteger.exit:                             ; preds = %luaO_str2d.exit.thread9.i.i, %luaO_str2d.exit.i.i, %land.lhs.true.i.i, %luaL_checktype.exit, %lua_type.exit.i23, %cond.false.i
  %cond.i = phi i64 [ 1, %lua_type.exit.i23 ], [ %call.i.i, %cond.false.i ], [ 1, %luaL_checktype.exit ], [ 0, %land.lhs.true.i.i ], [ 0, %luaO_str2d.exit.i.i ], [ 0, %luaO_str2d.exit.thread9.i.i ]
  %conv = trunc i64 %cond.i to i32
  %15 = load ptr, ptr %base.i.i.i, align 8
  %add.ptr.i.i = getelementptr %struct.lua_TValue, ptr %15, i64 2
  %16 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i = icmp uge ptr %add.ptr.i.i, %16
  %cmp.i28 = icmp eq ptr %add.ptr.i.i, @luaO_nilobject_
  %or.cond151 = or i1 %cmp1.not.i.i, %cmp.i28
  br i1 %or.cond151, label %cond.true, label %lua_type.exit

lua_type.exit:                                    ; preds = %luaL_optinteger.exit
  %tt.i = getelementptr %struct.lua_TValue, ptr %15, i64 2, i32 1
  %17 = load i32, ptr %tt.i, align 8
  %cmp = icmp slt i32 %17, 1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %luaL_optinteger.exit, %lua_type.exit
  %call3 = tail call fastcc i64 @lua_objlen(ptr noundef nonnull %L, i32 noundef 1)
  br label %cond.end

cond.false:                                       ; preds = %lua_type.exit
  %call.i = tail call fastcc i64 @lua_tointeger(ptr noundef nonnull %L, i32 noundef 3)
  %cmp.i30 = icmp eq i64 %call.i, 0
  br i1 %cmp.i30, label %land.lhs.true.i, label %cond.end

land.lhs.true.i:                                  ; preds = %cond.false
  %18 = load ptr, ptr %base.i.i.i, align 8
  %add.ptr.i.i106 = getelementptr %struct.lua_TValue, ptr %18, i64 2
  %19 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i108 = icmp ult ptr %add.ptr.i.i106, %19
  %add.ptr.luaO_nilobject_.i.i109 = select i1 %cmp1.not.i.i108, ptr %add.ptr.i.i106, ptr @luaO_nilobject_
  %tt.i111 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i109, i64 0, i32 1
  %20 = load i32, ptr %tt.i111, align 8
  switch i32 %20, label %if.then.i31 [
    i32 3, label %cond.end
    i32 4, label %land.lhs.true.i.i112
  ]

land.lhs.true.i.i112:                             ; preds = %land.lhs.true.i
  %21 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i109, align 8
  %add.ptr.i3.i113 = getelementptr inbounds %union.TString, ptr %21, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i.i103)
  %call.i.i.i114 = call double @strtod(ptr noundef nonnull %add.ptr.i3.i113, ptr noundef nonnull %endptr.i.i.i103) #35
  %22 = load ptr, ptr %endptr.i.i.i103, align 8
  %cmp.i.i.i115 = icmp eq ptr %22, %add.ptr.i3.i113
  br i1 %cmp.i.i.i115, label %luaO_str2d.exit.thread.i.i137, label %if.end.i.i.i116

luaO_str2d.exit.thread.i.i137:                    ; preds = %land.lhs.true.i.i112
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i103)
  br label %if.then.i31

if.end.i.i.i116:                                  ; preds = %land.lhs.true.i.i112
  %23 = load i8, ptr %22, align 1
  switch i8 %23, label %if.end9.i.i.i121 [
    i8 120, label %if.then6.i.i.i117
    i8 88, label %if.then6.i.i.i117
  ]

if.then6.i.i.i117:                                ; preds = %if.end.i.i.i116, %if.end.i.i.i116
  %call7.i.i.i118 = call i64 @strtoul(ptr noundef nonnull %add.ptr.i3.i113, ptr noundef nonnull %endptr.i.i.i103, i32 noundef 16) #35
  %.pre.i.i.i119 = load ptr, ptr %endptr.i.i.i103, align 8
  %.pre5.i.i.i120 = load i8, ptr %.pre.i.i.i119, align 1
  br label %if.end9.i.i.i121

if.end9.i.i.i121:                                 ; preds = %if.then6.i.i.i117, %if.end.i.i.i116
  %24 = phi i8 [ %23, %if.end.i.i.i116 ], [ %.pre5.i.i.i120, %if.then6.i.i.i117 ]
  %endptr.promoted.i.i.i122 = phi ptr [ %22, %if.end.i.i.i116 ], [ %.pre.i.i.i119, %if.then6.i.i.i117 ]
  %cmp11.i.i.i123 = icmp eq i8 %24, 0
  br i1 %cmp11.i.i.i123, label %luaO_str2d.exit.thread9.i.i136, label %while.cond.preheader.i.i.i124

luaO_str2d.exit.thread9.i.i136:                   ; preds = %if.end9.i.i.i121
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i103)
  br label %cond.end

while.cond.preheader.i.i.i124:                    ; preds = %if.end9.i.i.i121
  %call15.i.i.i125 = tail call ptr @__ctype_b_loc() #39
  %25 = load ptr, ptr %call15.i.i.i125, align 8
  br label %while.cond.i.i.i126

while.cond.i.i.i126:                              ; preds = %while.cond.i.i.i126, %while.cond.preheader.i.i.i124
  %incdec.ptr4.i.i.i127 = phi ptr [ %endptr.promoted.i.i.i122, %while.cond.preheader.i.i.i124 ], [ %incdec.ptr.i.i.i131, %while.cond.i.i.i126 ]
  %26 = load i8, ptr %incdec.ptr4.i.i.i127, align 1
  %idxprom.i.i.i128 = zext i8 %26 to i64
  %arrayidx.i.i.i129 = getelementptr inbounds i16, ptr %25, i64 %idxprom.i.i.i128
  %27 = load i16, ptr %arrayidx.i.i.i129, align 2
  %28 = and i16 %27, 8192
  %tobool.not.i.i.i130 = icmp eq i16 %28, 0
  %incdec.ptr.i.i.i131 = getelementptr inbounds i8, ptr %incdec.ptr4.i.i.i127, i64 1
  br i1 %tobool.not.i.i.i130, label %luaO_str2d.exit.i.i132, label %while.cond.i.i.i126, !llvm.loop !35

luaO_str2d.exit.i.i132:                           ; preds = %while.cond.i.i.i126
  %cmp19.not.i.not.i.i133 = icmp eq i8 %26, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i103)
  br i1 %cmp19.not.i.not.i.i133, label %cond.end, label %if.then.i31

if.then.i31:                                      ; preds = %land.lhs.true.i, %luaO_str2d.exit.i.i132, %luaO_str2d.exit.thread.i.i137
  tail call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 3, ptr noundef nonnull @.str.24)
  unreachable

cond.end:                                         ; preds = %luaO_str2d.exit.thread9.i.i136, %luaO_str2d.exit.i.i132, %cond.false, %land.lhs.true.i, %cond.true
  %cond.in = phi i64 [ %call3, %cond.true ], [ 0, %land.lhs.true.i ], [ %call.i, %cond.false ], [ 0, %luaO_str2d.exit.i.i132 ], [ 0, %luaO_str2d.exit.thread9.i.i136 ]
  %cond = trunc i64 %cond.in to i32
  %cmp7 = icmp sgt i32 %conv, %cond
  br i1 %cmp7, label %return, label %if.end

if.end:                                           ; preds = %cond.end
  %sub = sub nsw i32 %cond, %conv
  %add = add nsw i32 %sub, 1
  %or.cond152 = icmp ugt i32 %sub, 7999
  br i1 %or.cond152, label %if.then12, label %lor.lhs.false.i

lor.lhs.false.i:                                  ; preds = %if.end
  %29 = load ptr, ptr %top.i.i.i, align 8
  %30 = load ptr, ptr %base.i.i.i, align 8
  %sub.ptr.lhs.cast.i = ptrtoint ptr %29 to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %30 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %sub.ptr.div.i = ashr exact i64 %sub.ptr.sub.i, 4
  %conv.i = zext nneg i32 %add to i64
  %add.i = add nsw i64 %sub.ptr.div.i, %conv.i
  %cmp1.i = icmp sgt i64 %add.i, 8000
  br i1 %cmp1.i, label %if.then12, label %if.then5.i

if.then5.i:                                       ; preds = %lor.lhs.false.i
  %stack_last.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 9
  %31 = load ptr, ptr %stack_last.i, align 8
  %sub.ptr.lhs.cast7.i = ptrtoint ptr %31 to i64
  %sub.ptr.sub9.i = sub i64 %sub.ptr.lhs.cast7.i, %sub.ptr.lhs.cast.i
  %mul.i = shl nuw nsw i32 %add, 4
  %conv10.i = zext nneg i32 %mul.i to i64
  %cmp11.not.i = icmp sgt i64 %sub.ptr.sub9.i, %conv10.i
  br i1 %cmp11.not.i, label %if.end.i, label %if.then13.i

if.then13.i:                                      ; preds = %if.then5.i
  %stacksize.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 13
  %32 = load i32, ptr %stacksize.i.i, align 8
  %cmp.not.i.i.not = icmp sgt i32 %32, %sub
  %add.i.i = add nsw i32 %32, %add
  %mul.i.i = shl nsw i32 %32, 1
  %add.sink.i.i = select i1 %cmp.not.i.i.not, i32 %mul.i.i, i32 %add.i.i
  tail call fastcc void @luaD_reallocstack(ptr noundef nonnull %L, i32 noundef %add.sink.i.i)
  %.pre.i = load ptr, ptr %top.i.i.i, align 8
  br label %if.end.i

if.end.i:                                         ; preds = %if.then13.i, %if.then5.i
  %33 = phi ptr [ %29, %if.then5.i ], [ %.pre.i, %if.then13.i ]
  %ci.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %34 = load ptr, ptr %ci.i, align 8
  %top15.i = getelementptr inbounds %struct.CallInfo, ptr %34, i64 0, i32 2
  %35 = load ptr, ptr %top15.i, align 8
  %add.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %33, i64 %conv.i
  %cmp17.i = icmp ult ptr %35, %add.ptr.i
  br i1 %cmp17.i, label %if.then19.i, label %if.end14

if.then19.i:                                      ; preds = %if.end.i
  store ptr %add.ptr.i, ptr %top15.i, align 8
  %.pre = load ptr, ptr %top.i.i.i, align 8
  br label %if.end14

if.then12:                                        ; preds = %lor.lhs.false.i, %if.end
  tail call void (ptr, ptr, ...) @luaL_error(ptr noundef %L, ptr noundef nonnull @.str.184)
  unreachable

if.end14:                                         ; preds = %if.then19.i, %if.end.i
  %36 = phi ptr [ %.pre, %if.then19.i ], [ %33, %if.end.i ]
  %37 = load ptr, ptr %base.i.i.i, align 8
  %cmp1.not.i.i38 = icmp ult ptr %37, %36
  %add.ptr.luaO_nilobject_.i.i = select i1 %cmp1.not.i.i38, ptr %37, ptr @luaO_nilobject_
  %38 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i, align 8
  %sub.i.i = add i32 %conv, -1
  %sizearray.i.i = getelementptr inbounds %struct.Table, ptr %38, i64 0, i32 10
  %39 = load i32, ptr %sizearray.i.i, align 8
  %cmp.i5.i = icmp ult i32 %sub.i.i, %39
  br i1 %cmp.i5.i, label %if.then.i9.i, label %if.else.i.i

if.then.i9.i:                                     ; preds = %if.end14
  %array.i.i = getelementptr inbounds %struct.Table, ptr %38, i64 0, i32 6
  %40 = load ptr, ptr %array.i.i, align 8
  %idxprom.i10.i = sext i32 %sub.i.i to i64
  %arrayidx.i11.i = getelementptr inbounds %struct.lua_TValue, ptr %40, i64 %idxprom.i10.i
  br label %lua_rawgeti.exit

if.else.i.i:                                      ; preds = %if.end14
  %conv.i6.i = sitofp i32 %conv to double
  %cmp.i.i.i = icmp eq i32 %conv, 0
  br i1 %cmp.i.i.i, label %if.then.i.i.i, label %if.end.i.i.i

if.then.i.i.i:                                    ; preds = %if.else.i.i
  %node.i.i.i = getelementptr inbounds %struct.Table, ptr %38, i64 0, i32 7
  %41 = load ptr, ptr %node.i.i.i, align 8
  br label %do.body.i.i.preheader

if.end.i.i.i:                                     ; preds = %if.else.i.i
  %42 = bitcast double %conv.i6.i to i64
  %a.sroa.0.4.extract.shift.i.i.i = lshr i64 %42, 32
  %add.i.i.i = add i64 %a.sroa.0.4.extract.shift.i.i.i, %42
  %node4.i.i.i = getelementptr inbounds %struct.Table, ptr %38, i64 0, i32 7
  %43 = load ptr, ptr %node4.i.i.i, align 8
  %conv.i.i.i = and i64 %add.i.i.i, 4294967295
  %lsizenode.i.i.i = getelementptr inbounds %struct.Table, ptr %38, i64 0, i32 4
  %44 = load i8, ptr %lsizenode.i.i.i, align 1
  %sh_prom.i.i.i = zext nneg i8 %44 to i64
  %notmask.i.i.i = shl nsw i64 -1, %sh_prom.i.i.i
  %sub.i.i.i = xor i64 %notmask.i.i.i, -1
  %or.i.i.i = or i64 %sub.i.i.i, 1
  %rem.i.i.i = urem i64 %conv.i.i.i, %or.i.i.i
  %arrayidx7.i.i.i = getelementptr inbounds %struct.Node, ptr %43, i64 %rem.i.i.i
  br label %do.body.i.i.preheader

do.body.i.i.preheader:                            ; preds = %if.end.i.i.i, %if.then.i.i.i
  %n.0.i.i.ph = phi ptr [ %arrayidx7.i.i.i, %if.end.i.i.i ], [ %41, %if.then.i.i.i ]
  br label %do.body.i.i

do.body.i.i:                                      ; preds = %do.body.i.i.preheader, %if.else8.i.i
  %n.0.i.i = phi ptr [ %47, %if.else8.i.i ], [ %n.0.i.i.ph, %do.body.i.i.preheader ]
  %tt.i7.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1, i32 0, i32 1
  %45 = load i32, ptr %tt.i7.i, align 8
  %cmp2.i.i = icmp eq i32 %45, 3
  br i1 %cmp2.i.i, label %land.lhs.true.i.i43, label %if.else8.i.i

land.lhs.true.i.i43:                              ; preds = %do.body.i.i
  %i_key.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1
  %46 = load double, ptr %i_key.i.i, align 8
  %cmp5.i.i = fcmp oeq double %46, %conv.i6.i
  br i1 %cmp5.i.i, label %lua_rawgeti.exit, label %if.else8.i.i

if.else8.i.i:                                     ; preds = %land.lhs.true.i.i43, %do.body.i.i
  %next.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1, i32 0, i32 2
  %47 = load ptr, ptr %next.i.i, align 8
  %tobool.not.i.i40 = icmp eq ptr %47, null
  br i1 %tobool.not.i.i40, label %lua_rawgeti.exit, label %do.body.i.i, !llvm.loop !7

lua_rawgeti.exit:                                 ; preds = %land.lhs.true.i.i43, %if.else8.i.i, %if.then.i9.i
  %retval.0.i8.i = phi ptr [ %arrayidx.i11.i, %if.then.i9.i ], [ @luaO_nilobject_, %if.else8.i.i ], [ %n.0.i.i, %land.lhs.true.i.i43 ]
  %48 = load i64, ptr %retval.0.i8.i, align 8
  store i64 %48, ptr %36, align 8
  %tt.i42 = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i8.i, i64 0, i32 1
  %49 = load i32, ptr %tt.i42, align 8
  %tt4.i = getelementptr inbounds %struct.lua_TValue, ptr %36, i64 0, i32 1
  store i32 %49, ptr %tt4.i, align 8
  %.pn154 = load ptr, ptr %top.i.i.i, align 8
  %storemerge155 = getelementptr inbounds %struct.lua_TValue, ptr %.pn154, i64 1
  store ptr %storemerge155, ptr %top.i.i.i, align 8
  %cmp15156 = icmp slt i32 %conv, %cond
  br i1 %cmp15156, label %while.body.preheader, label %return

while.body.preheader:                             ; preds = %lua_rawgeti.exit
  %sext = shl i64 %cond.i, 32
  %50 = ashr exact i64 %sext, 32
  %sext160 = shl i64 %cond.in, 32
  %wide.trip.count = ashr exact i64 %sext160, 32
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %lua_rawgeti.exit91
  %51 = phi ptr [ %storemerge155, %while.body.preheader ], [ %storemerge, %lua_rawgeti.exit91 ]
  %indvars.iv = phi i64 [ %50, %while.body.preheader ], [ %indvars.iv.next, %lua_rawgeti.exit91 ]
  %indvars.iv.next = add nsw i64 %indvars.iv, 1
  %52 = load ptr, ptr %base.i.i.i, align 8
  %cmp1.not.i.i48 = icmp ult ptr %52, %51
  %add.ptr.luaO_nilobject_.i.i49 = select i1 %cmp1.not.i.i48, ptr %52, ptr @luaO_nilobject_
  %53 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i49, align 8
  %sizearray.i.i51 = getelementptr inbounds %struct.Table, ptr %53, i64 0, i32 10
  %54 = load i32, ptr %sizearray.i.i51, align 8
  %55 = trunc i64 %indvars.iv to i32
  %cmp.i5.i52 = icmp ugt i32 %54, %55
  br i1 %cmp.i5.i52, label %if.then.i9.i87, label %if.else.i.i53

if.then.i9.i87:                                   ; preds = %while.body
  %array.i.i88 = getelementptr inbounds %struct.Table, ptr %53, i64 0, i32 6
  %56 = load ptr, ptr %array.i.i88, align 8
  %arrayidx.i11.i90 = getelementptr inbounds %struct.lua_TValue, ptr %56, i64 %indvars.iv
  br label %lua_rawgeti.exit91

if.else.i.i53:                                    ; preds = %while.body
  %57 = trunc i64 %indvars.iv.next to i32
  %conv.i6.i54 = sitofp i32 %57 to double
  %58 = icmp eq i64 %indvars.iv.next, 0
  br i1 %58, label %if.then.i.i.i85, label %if.end.i.i.i56

if.then.i.i.i85:                                  ; preds = %if.else.i.i53
  %node.i.i.i86 = getelementptr inbounds %struct.Table, ptr %53, i64 0, i32 7
  %59 = load ptr, ptr %node.i.i.i86, align 8
  br label %do.body.i.i70.preheader

if.end.i.i.i56:                                   ; preds = %if.else.i.i53
  %60 = bitcast double %conv.i6.i54 to i64
  %a.sroa.0.4.extract.shift.i.i.i57 = lshr i64 %60, 32
  %add.i.i.i58 = add i64 %a.sroa.0.4.extract.shift.i.i.i57, %60
  %node4.i.i.i59 = getelementptr inbounds %struct.Table, ptr %53, i64 0, i32 7
  %61 = load ptr, ptr %node4.i.i.i59, align 8
  %conv.i.i.i60 = and i64 %add.i.i.i58, 4294967295
  %lsizenode.i.i.i61 = getelementptr inbounds %struct.Table, ptr %53, i64 0, i32 4
  %62 = load i8, ptr %lsizenode.i.i.i61, align 1
  %sh_prom.i.i.i62 = zext nneg i8 %62 to i64
  %notmask.i.i.i63 = shl nsw i64 -1, %sh_prom.i.i.i62
  %sub.i.i.i64 = xor i64 %notmask.i.i.i63, -1
  %or.i.i.i65 = or i64 %sub.i.i.i64, 1
  %rem.i.i.i66 = urem i64 %conv.i.i.i60, %or.i.i.i65
  %arrayidx7.i.i.i67 = getelementptr inbounds %struct.Node, ptr %61, i64 %rem.i.i.i66
  br label %do.body.i.i70.preheader

do.body.i.i70.preheader:                          ; preds = %if.end.i.i.i56, %if.then.i.i.i85
  %n.0.i.i71.ph = phi ptr [ %arrayidx7.i.i.i67, %if.end.i.i.i56 ], [ %59, %if.then.i.i.i85 ]
  br label %do.body.i.i70

do.body.i.i70:                                    ; preds = %do.body.i.i70.preheader, %if.else8.i.i74
  %n.0.i.i71 = phi ptr [ %65, %if.else8.i.i74 ], [ %n.0.i.i71.ph, %do.body.i.i70.preheader ]
  %tt.i7.i72 = getelementptr inbounds %struct.Node, ptr %n.0.i.i71, i64 0, i32 1, i32 0, i32 1
  %63 = load i32, ptr %tt.i7.i72, align 8
  %cmp2.i.i73 = icmp eq i32 %63, 3
  br i1 %cmp2.i.i73, label %land.lhs.true.i.i82, label %if.else8.i.i74

land.lhs.true.i.i82:                              ; preds = %do.body.i.i70
  %i_key.i.i83 = getelementptr inbounds %struct.Node, ptr %n.0.i.i71, i64 0, i32 1
  %64 = load double, ptr %i_key.i.i83, align 8
  %cmp5.i.i84 = fcmp oeq double %64, %conv.i6.i54
  br i1 %cmp5.i.i84, label %lua_rawgeti.exit91, label %if.else8.i.i74

if.else8.i.i74:                                   ; preds = %land.lhs.true.i.i82, %do.body.i.i70
  %next.i.i75 = getelementptr inbounds %struct.Node, ptr %n.0.i.i71, i64 0, i32 1, i32 0, i32 2
  %65 = load ptr, ptr %next.i.i75, align 8
  %tobool.not.i.i76 = icmp eq ptr %65, null
  br i1 %tobool.not.i.i76, label %lua_rawgeti.exit91, label %do.body.i.i70, !llvm.loop !7

lua_rawgeti.exit91:                               ; preds = %land.lhs.true.i.i82, %if.else8.i.i74, %if.then.i9.i87
  %retval.0.i8.i77 = phi ptr [ %arrayidx.i11.i90, %if.then.i9.i87 ], [ @luaO_nilobject_, %if.else8.i.i74 ], [ %n.0.i.i71, %land.lhs.true.i.i82 ]
  %66 = load i64, ptr %retval.0.i8.i77, align 8
  store i64 %66, ptr %51, align 8
  %tt.i79 = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i8.i77, i64 0, i32 1
  %67 = load i32, ptr %tt.i79, align 8
  %tt4.i80 = getelementptr inbounds %struct.lua_TValue, ptr %51, i64 0, i32 1
  store i32 %67, ptr %tt4.i80, align 8
  %.pn = load ptr, ptr %top.i.i.i, align 8
  %storemerge = getelementptr inbounds %struct.lua_TValue, ptr %.pn, i64 1
  store ptr %storemerge, ptr %top.i.i.i, align 8
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %return, label %while.body, !llvm.loop !89

return:                                           ; preds = %lua_rawgeti.exit91, %lua_rawgeti.exit, %cond.end
  %retval.0 = phi i32 [ 0, %cond.end ], [ %add, %lua_rawgeti.exit ], [ %add, %lua_rawgeti.exit91 ]
  ret i32 %retval.0
}

; Function Attrs: noreturn nounwind uwtable
define internal void @luaL_error(ptr noundef %L, ptr noundef %fmt, ...) unnamed_addr #7 {
entry:
  %argp = alloca [1 x %struct.__va_list_tag], align 16
  call void @llvm.va_start(ptr nonnull %argp)
  call fastcc void @luaL_where(ptr noundef %L, i32 noundef 1)
  %l_G.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %0 = load ptr, ptr %l_G.i, align 8
  %totalbytes.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 14
  %1 = load i64, ptr %totalbytes.i, align 8
  %GCthreshold.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 13
  %2 = load i64, ptr %GCthreshold.i, align 8
  %cmp.not.i = icmp ult i64 %1, %2
  br i1 %cmp.not.i, label %lua_pushvfstring.exit, label %if.then.i

if.then.i:                                        ; preds = %entry
  %gcstepmul.i.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 18
  %3 = load i32, ptr %gcstepmul.i.i, align 4
  %mul.i.i = mul i32 %3, 10
  %conv.i.i = zext i32 %mul.i.i to i64
  %cmp.i.i = icmp eq i32 %mul.i.i, 0
  %spec.store.select.i.i = select i1 %cmp.i.i, i64 9223372036854775806, i64 %conv.i.i
  %sub.i.i = sub i64 %1, %2
  %gcdept.i.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 16
  %4 = load i64, ptr %gcdept.i.i, align 8
  %add.i.i = add i64 %sub.i.i, %4
  store i64 %add.i.i, ptr %gcdept.i.i, align 8
  %gcstate.i.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 4
  br label %do.body.i.i

do.body.i.i:                                      ; preds = %do.body.i.i, %if.then.i
  %lim.0.i.i = phi i64 [ %spec.store.select.i.i, %if.then.i ], [ %sub2.i.i, %do.body.i.i ]
  %call.i.i = call fastcc i64 @singlestep(ptr noundef %L)
  %sub2.i.i = sub nsw i64 %lim.0.i.i, %call.i.i
  %5 = load i8, ptr %gcstate.i.i, align 1
  %cmp4.i.i = icmp ne i8 %5, 0
  %cmp8.i.i = icmp sgt i64 %sub2.i.i, 0
  %or.cond.i.i = select i1 %cmp4.i.i, i1 %cmp8.i.i, i1 false
  br i1 %or.cond.i.i, label %do.body.i.i, label %do.end.i.i, !llvm.loop !6

do.end.i.i:                                       ; preds = %do.body.i.i
  br i1 %cmp4.i.i, label %if.then14.i.i, label %if.else27.i.i

if.then14.i.i:                                    ; preds = %do.end.i.i
  %6 = load i64, ptr %gcdept.i.i, align 8
  %cmp16.i.i = icmp ult i64 %6, 1024
  br i1 %cmp16.i.i, label %if.then18.i.i, label %if.else.i.i

if.then18.i.i:                                    ; preds = %if.then14.i.i
  %7 = load i64, ptr %totalbytes.i, align 8
  %add20.i.i = add i64 %7, 1024
  br label %luaC_step.exit.i

if.else.i.i:                                      ; preds = %if.then14.i.i
  %sub23.i.i = add i64 %6, -1024
  store i64 %sub23.i.i, ptr %gcdept.i.i, align 8
  %8 = load i64, ptr %totalbytes.i, align 8
  br label %luaC_step.exit.i

if.else27.i.i:                                    ; preds = %do.end.i.i
  %estimate.i.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 15
  %9 = load i64, ptr %estimate.i.i, align 8
  %div.i.i = udiv i64 %9, 100
  %gcpause.i.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 17
  %10 = load i32, ptr %gcpause.i.i, align 8
  %conv28.i.i = sext i32 %10 to i64
  %mul29.i.i = mul i64 %div.i.i, %conv28.i.i
  br label %luaC_step.exit.i

luaC_step.exit.i:                                 ; preds = %if.else27.i.i, %if.else.i.i, %if.then18.i.i
  %add20.sink.i.i = phi i64 [ %add20.i.i, %if.then18.i.i ], [ %8, %if.else.i.i ], [ %mul29.i.i, %if.else27.i.i ]
  store i64 %add20.sink.i.i, ptr %GCthreshold.i, align 8
  br label %lua_pushvfstring.exit

lua_pushvfstring.exit:                            ; preds = %entry, %luaC_step.exit.i
  %call.i = call fastcc ptr @luaO_pushvfstring(ptr noundef %L, ptr noundef %fmt, ptr noundef nonnull %argp)
  call void @llvm.va_end(ptr nonnull %argp)
  %11 = load ptr, ptr %l_G.i, align 8
  %totalbytes.i6 = getelementptr inbounds %struct.global_State, ptr %11, i64 0, i32 14
  %12 = load i64, ptr %totalbytes.i6, align 8
  %GCthreshold.i7 = getelementptr inbounds %struct.global_State, ptr %11, i64 0, i32 13
  %13 = load i64, ptr %GCthreshold.i7, align 8
  %cmp2.not.i = icmp ult i64 %12, %13
  br i1 %cmp2.not.i, label %lua_concat.exit, label %if.then3.i

if.then3.i:                                       ; preds = %lua_pushvfstring.exit
  %gcstepmul.i.i8 = getelementptr inbounds %struct.global_State, ptr %11, i64 0, i32 18
  %14 = load i32, ptr %gcstepmul.i.i8, align 4
  %mul.i.i9 = mul i32 %14, 10
  %conv.i.i10 = zext i32 %mul.i.i9 to i64
  %cmp.i.i11 = icmp eq i32 %mul.i.i9, 0
  %spec.store.select.i.i12 = select i1 %cmp.i.i11, i64 9223372036854775806, i64 %conv.i.i10
  %sub.i.i13 = sub i64 %12, %13
  %gcdept.i.i14 = getelementptr inbounds %struct.global_State, ptr %11, i64 0, i32 16
  %15 = load i64, ptr %gcdept.i.i14, align 8
  %add.i.i15 = add i64 %sub.i.i13, %15
  store i64 %add.i.i15, ptr %gcdept.i.i14, align 8
  %gcstate.i.i16 = getelementptr inbounds %struct.global_State, ptr %11, i64 0, i32 4
  br label %do.body.i.i17

do.body.i.i17:                                    ; preds = %do.body.i.i17, %if.then3.i
  %lim.0.i.i18 = phi i64 [ %spec.store.select.i.i12, %if.then3.i ], [ %sub2.i.i20, %do.body.i.i17 ]
  %call.i.i19 = call fastcc i64 @singlestep(ptr noundef %L)
  %sub2.i.i20 = sub nsw i64 %lim.0.i.i18, %call.i.i19
  %16 = load i8, ptr %gcstate.i.i16, align 1
  %cmp4.i.i21 = icmp ne i8 %16, 0
  %cmp8.i.i22 = icmp sgt i64 %sub2.i.i20, 0
  %or.cond.i.i23 = select i1 %cmp4.i.i21, i1 %cmp8.i.i22, i1 false
  br i1 %or.cond.i.i23, label %do.body.i.i17, label %do.end.i.i24, !llvm.loop !6

do.end.i.i24:                                     ; preds = %do.body.i.i17
  br i1 %cmp4.i.i21, label %if.then14.i.i33, label %if.else27.i.i25

if.then14.i.i33:                                  ; preds = %do.end.i.i24
  %17 = load i64, ptr %gcdept.i.i14, align 8
  %cmp16.i.i34 = icmp ult i64 %17, 1024
  br i1 %cmp16.i.i34, label %if.then18.i.i37, label %if.else.i.i35

if.then18.i.i37:                                  ; preds = %if.then14.i.i33
  %18 = load i64, ptr %totalbytes.i6, align 8
  %add20.i.i38 = add i64 %18, 1024
  br label %luaC_step.exit.i31

if.else.i.i35:                                    ; preds = %if.then14.i.i33
  %sub23.i.i36 = add i64 %17, -1024
  store i64 %sub23.i.i36, ptr %gcdept.i.i14, align 8
  %19 = load i64, ptr %totalbytes.i6, align 8
  br label %luaC_step.exit.i31

if.else27.i.i25:                                  ; preds = %do.end.i.i24
  %estimate.i.i26 = getelementptr inbounds %struct.global_State, ptr %11, i64 0, i32 15
  %20 = load i64, ptr %estimate.i.i26, align 8
  %div.i.i27 = udiv i64 %20, 100
  %gcpause.i.i28 = getelementptr inbounds %struct.global_State, ptr %11, i64 0, i32 17
  %21 = load i32, ptr %gcpause.i.i28, align 8
  %conv28.i.i29 = sext i32 %21 to i64
  %mul29.i.i30 = mul i64 %div.i.i27, %conv28.i.i29
  br label %luaC_step.exit.i31

luaC_step.exit.i31:                               ; preds = %if.else27.i.i25, %if.else.i.i35, %if.then18.i.i37
  %add20.sink.i.i32 = phi i64 [ %add20.i.i38, %if.then18.i.i37 ], [ %19, %if.else.i.i35 ], [ %mul29.i.i30, %if.else27.i.i25 ]
  store i64 %add20.sink.i.i32, ptr %GCthreshold.i7, align 8
  br label %lua_concat.exit

lua_concat.exit:                                  ; preds = %lua_pushvfstring.exit, %luaC_step.exit.i31
  %top.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %22 = load ptr, ptr %top.i, align 8
  %base.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %23 = load ptr, ptr %base.i, align 8
  %sub.ptr.lhs.cast.i = ptrtoint ptr %22 to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %23 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %sub.ptr.div.i = lshr exact i64 %sub.ptr.sub.i, 4
  %conv.i = trunc i64 %sub.ptr.div.i to i32
  %sub.i = add nsw i32 %conv.i, -1
  call fastcc void @luaV_concat(ptr noundef %L, i32 noundef 2, i32 noundef %sub.i)
  %24 = load ptr, ptr %top.i, align 8
  %add.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %24, i64 -1
  store ptr %add.ptr.i, ptr %top.i, align 8
  call fastcc void @luaG_errormsg(ptr noundef %L)
  unreachable
}

; Function Attrs: noreturn nounwind uwtable
define internal fastcc void @luaL_argerror(ptr noundef %L, i32 noundef %narg, ptr noundef %extramsg) unnamed_addr #7 {
entry:
  %ar = alloca %struct.lua_Debug, align 8
  %ci1.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %0 = load ptr, ptr %ci1.i, align 8
  %base_ci4.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 12
  %1 = load ptr, ptr %base_ci4.i, align 8
  %cmp5.i = icmp ugt ptr %0, %1
  br i1 %cmp5.i, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void (ptr, ptr, ...) @luaL_error(ptr noundef nonnull %L, ptr noundef nonnull @.str.116, i32 noundef %narg, ptr noundef %extramsg)
  unreachable

if.end:                                           ; preds = %entry
  %sub.ptr.lhs.cast.i = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %1 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %sub.ptr.div.i = sdiv exact i64 %sub.ptr.sub.i, 40
  %conv.i = trunc i64 %sub.ptr.div.i to i32
  %i_ci11.i = getelementptr inbounds %struct.lua_Debug, ptr %ar, i64 0, i32 10
  store i32 %conv.i, ptr %i_ci11.i, align 4
  call fastcc void @lua_getinfo(ptr noundef nonnull %L, ptr noundef nonnull @.str.117, ptr noundef nonnull %ar)
  %namewhat = getelementptr inbounds %struct.lua_Debug, ptr %ar, i64 0, i32 2
  %2 = load ptr, ptr %namewhat, align 8
  %call3 = call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %2, ptr noundef nonnull dereferenceable(7) @.str.118) #34
  %cmp = icmp eq i32 %call3, 0
  br i1 %cmp, label %if.then4, label %if.end9

if.then4:                                         ; preds = %if.end
  %dec = add nsw i32 %narg, -1
  %cmp5 = icmp eq i32 %dec, 0
  br i1 %cmp5, label %if.then6, label %if.end9

if.then6:                                         ; preds = %if.then4
  %name = getelementptr inbounds %struct.lua_Debug, ptr %ar, i64 0, i32 1
  %3 = load ptr, ptr %name, align 8
  call void (ptr, ptr, ...) @luaL_error(ptr noundef nonnull %L, ptr noundef nonnull @.str.119, ptr noundef %3, ptr noundef %extramsg)
  unreachable

if.end9:                                          ; preds = %if.then4, %if.end
  %narg.addr.0 = phi i32 [ %dec, %if.then4 ], [ %narg, %if.end ]
  %name10 = getelementptr inbounds %struct.lua_Debug, ptr %ar, i64 0, i32 1
  %4 = load ptr, ptr %name10, align 8
  %cmp11 = icmp eq ptr %4, null
  br i1 %cmp11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %if.end9
  store ptr @.str.120, ptr %name10, align 8
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %if.end9
  %5 = phi ptr [ @.str.120, %if.then12 ], [ %4, %if.end9 ]
  call void (ptr, ptr, ...) @luaL_error(ptr noundef nonnull %L, ptr noundef nonnull @.str.121, i32 noundef %narg.addr.0, ptr noundef nonnull %5, ptr noundef %extramsg)
  unreachable
}

; Function Attrs: nounwind uwtable
define internal fastcc void @lua_getinfo(ptr noundef %L, ptr noundef readonly %what, ptr noundef %ar) unnamed_addr #0 {
entry:
  %k.i.i = alloca %struct.lua_TValue, align 8
  %0 = load i8, ptr %what, align 1
  %cmp = icmp eq i8 %0, 62
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %top = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top, align 8
  %add.ptr = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 -1
  %incdec.ptr = getelementptr inbounds i8, ptr %what, i64 1
  %2 = load ptr, ptr %add.ptr, align 8
  store ptr %add.ptr, ptr %top, align 8
  br label %if.end11

if.else:                                          ; preds = %entry
  %i_ci = getelementptr inbounds %struct.lua_Debug, ptr %ar, i64 0, i32 10
  %3 = load i32, ptr %i_ci, align 4
  %cmp4.not = icmp eq i32 %3, 0
  br i1 %cmp4.not, label %auxgetinfo.exit.thread, label %if.then6

if.then6:                                         ; preds = %if.else
  %base_ci = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 12
  %4 = load ptr, ptr %base_ci, align 8
  %idx.ext = sext i32 %3 to i64
  %add.ptr8 = getelementptr inbounds %struct.CallInfo, ptr %4, i64 %idx.ext
  %func9 = getelementptr inbounds %struct.CallInfo, ptr %4, i64 %idx.ext, i32 1
  %5 = load ptr, ptr %func9, align 8
  %6 = load ptr, ptr %5, align 8
  br label %if.end11

if.end11:                                         ; preds = %if.then6, %if.then
  %ci.0 = phi ptr [ null, %if.then ], [ %add.ptr8, %if.then6 ]
  %f.0 = phi ptr [ %2, %if.then ], [ %6, %if.then6 ]
  %what.addr.0 = phi ptr [ %incdec.ptr, %if.then ], [ %what, %if.then6 ]
  %cmp.i = icmp eq ptr %f.0, null
  br i1 %cmp.i, label %auxgetinfo.exit.thread, label %for.cond.preheader.i

for.cond.preheader.i:                             ; preds = %if.end11
  %7 = load i8, ptr %what.addr.0, align 1
  %tobool.not21.i = icmp eq i8 %7, 0
  br i1 %tobool.not21.i, label %auxgetinfo.exit, label %for.body.lr.ph.i

for.body.lr.ph.i:                                 ; preds = %for.cond.preheader.i
  %namewhat.i = getelementptr inbounds %struct.lua_Debug, ptr %ar, i64 0, i32 2
  %name.i = getelementptr inbounds %struct.lua_Debug, ptr %ar, i64 0, i32 1
  %nupvalues.i = getelementptr inbounds %struct.CClosure, ptr %f.0, i64 0, i32 4
  %nups.i = getelementptr inbounds %struct.lua_Debug, ptr %ar, i64 0, i32 6
  %tobool2.not.i = icmp eq ptr %ci.0, null
  %func.i.i.i = getelementptr inbounds %struct.CallInfo, ptr %ci.0, i64 0, i32 1
  %ci2.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %savedpc7.phi.trans.insert.i.i.i = getelementptr inbounds %struct.CallInfo, ptr %ci.0, i64 0, i32 3
  %savedpc.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 8
  %currentline.i = getelementptr inbounds %struct.lua_Debug, ptr %ar, i64 0, i32 5
  %isC.i.i = getelementptr inbounds %struct.CClosure, ptr %f.0, i64 0, i32 3
  %source.i15.i = getelementptr inbounds %struct.lua_Debug, ptr %ar, i64 0, i32 4
  %linedefined.i16.i = getelementptr inbounds %struct.lua_Debug, ptr %ar, i64 0, i32 7
  %p.i.i = getelementptr inbounds %struct.LClosure, ptr %f.0, i64 0, i32 7
  %8 = getelementptr inbounds %struct.lua_Debug, ptr %ar, i64 0, i32 8
  %9 = getelementptr inbounds %struct.lua_Debug, ptr %ar, i64 0, i32 3
  %short_src.i17.i = getelementptr inbounds %struct.lua_Debug, ptr %ar, i64 0, i32 9
  br i1 %tobool2.not.i, label %for.body.us.i, label %for.body.i

for.body.us.i:                                    ; preds = %for.body.lr.ph.i, %for.inc.us.i
  %10 = phi i8 [ %20, %for.inc.us.i ], [ %7, %for.body.lr.ph.i ]
  %status.023.us.i = phi i32 [ %status.1.us.i, %for.inc.us.i ], [ 1, %for.body.lr.ph.i ]
  %what.addr.022.us.i = phi ptr [ %incdec.ptr.us.i, %for.inc.us.i ], [ %what.addr.0, %for.body.lr.ph.i ]
  %conv.us.i = sext i8 %10 to i32
  switch i32 %conv.us.i, label %sw.default.us.i [
    i32 83, label %sw.bb.us.i
    i32 108, label %sw.bb1.us.i
    i32 117, label %sw.bb3.us.i
    i32 110, label %sw.bb5.us.i
    i32 76, label %for.inc.us.i
    i32 102, label %for.inc.us.i
  ]

sw.bb5.us.i:                                      ; preds = %for.body.us.i
  store ptr @.str.7, ptr %namewhat.i, align 8
  store ptr null, ptr %name.i, align 8
  br label %for.inc.us.i

sw.bb3.us.i:                                      ; preds = %for.body.us.i
  %11 = load i8, ptr %nupvalues.i, align 1
  %conv4.us.i = zext i8 %11 to i32
  store i32 %conv4.us.i, ptr %nups.i, align 4
  br label %for.inc.us.i

sw.bb1.us.i:                                      ; preds = %for.body.us.i
  store i32 -1, ptr %currentline.i, align 8
  br label %for.inc.us.i

sw.bb.us.i:                                       ; preds = %for.body.us.i
  %12 = load i8, ptr %isC.i.i, align 2
  %tobool.not.i.us.i = icmp eq i8 %12, 0
  br i1 %tobool.not.i.us.i, label %if.else.i.us.i, label %if.then.i.us.i

if.then.i.us.i:                                   ; preds = %sw.bb.us.i
  store ptr @.str.124, ptr %source.i15.i, align 8
  store i32 -1, ptr %linedefined.i16.i, align 8
  br label %funcinfo.exit.us.i

if.else.i.us.i:                                   ; preds = %sw.bb.us.i
  %13 = load ptr, ptr %p.i.i, align 8
  %source1.i.us.i = getelementptr inbounds %struct.Proto, ptr %13, i64 0, i32 9
  %14 = load ptr, ptr %source1.i.us.i, align 8
  %add.ptr.i.us.i = getelementptr inbounds %union.TString, ptr %14, i64 1
  store ptr %add.ptr.i.us.i, ptr %source.i15.i, align 8
  %15 = load ptr, ptr %p.i.i, align 8
  %linedefined4.i.us.i = getelementptr inbounds %struct.Proto, ptr %15, i64 0, i32 16
  %16 = load i32, ptr %linedefined4.i.us.i, align 8
  store i32 %16, ptr %linedefined.i16.i, align 8
  %17 = load ptr, ptr %p.i.i, align 8
  %lastlinedefined7.i.us.i = getelementptr inbounds %struct.Proto, ptr %17, i64 0, i32 17
  %18 = load i32, ptr %lastlinedefined7.i.us.i, align 4
  %cmp.i.us.i = icmp eq i32 %16, 0
  %cond.i.us.i = select i1 %cmp.i.us.i, ptr @.str.126, ptr @.str.127
  br label %funcinfo.exit.us.i

funcinfo.exit.us.i:                               ; preds = %if.else.i.us.i, %if.then.i.us.i
  %19 = phi ptr [ %add.ptr.i.us.i, %if.else.i.us.i ], [ @.str.124, %if.then.i.us.i ]
  %.sink.i.us.i = phi i32 [ %18, %if.else.i.us.i ], [ -1, %if.then.i.us.i ]
  %.str.125.sink.i.us.i = phi ptr [ %cond.i.us.i, %if.else.i.us.i ], [ @.str.125, %if.then.i.us.i ]
  store i32 %.sink.i.us.i, ptr %8, align 4
  store ptr %.str.125.sink.i.us.i, ptr %9, align 8
  tail call fastcc void @luaO_chunkid(ptr noundef nonnull %short_src.i17.i, ptr noundef nonnull %19, i64 noundef 60)
  br label %for.inc.us.i

sw.default.us.i:                                  ; preds = %for.body.us.i
  br label %for.inc.us.i

for.inc.us.i:                                     ; preds = %sw.default.us.i, %funcinfo.exit.us.i, %sw.bb1.us.i, %sw.bb3.us.i, %sw.bb5.us.i, %for.body.us.i, %for.body.us.i
  %status.1.us.i = phi i32 [ 0, %sw.default.us.i ], [ %status.023.us.i, %for.body.us.i ], [ %status.023.us.i, %for.body.us.i ], [ %status.023.us.i, %sw.bb5.us.i ], [ %status.023.us.i, %sw.bb3.us.i ], [ %status.023.us.i, %sw.bb1.us.i ], [ %status.023.us.i, %funcinfo.exit.us.i ]
  %incdec.ptr.us.i = getelementptr inbounds i8, ptr %what.addr.022.us.i, i64 1
  %20 = load i8, ptr %incdec.ptr.us.i, align 1
  %tobool.not.us.i = icmp eq i8 %20, 0
  br i1 %tobool.not.us.i, label %auxgetinfo.exit, label %for.body.us.i, !llvm.loop !90

for.body.i:                                       ; preds = %for.body.lr.ph.i, %for.inc.i
  %21 = phi i8 [ %43, %for.inc.i ], [ %7, %for.body.lr.ph.i ]
  %status.023.i = phi i32 [ %status.1.i, %for.inc.i ], [ 1, %for.body.lr.ph.i ]
  %what.addr.022.i = phi ptr [ %incdec.ptr.i, %for.inc.i ], [ %what.addr.0, %for.body.lr.ph.i ]
  %conv.i = sext i8 %21 to i32
  switch i32 %conv.i, label %sw.default.i [
    i32 83, label %sw.bb.i
    i32 108, label %sw.bb1.i
    i32 117, label %sw.bb3.i
    i32 110, label %sw.bb5.i
    i32 76, label %for.inc.i
    i32 102, label %for.inc.i
  ]

sw.bb.i:                                          ; preds = %for.body.i
  %22 = load i8, ptr %isC.i.i, align 2
  %tobool.not.i.i = icmp eq i8 %22, 0
  br i1 %tobool.not.i.i, label %if.else.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %sw.bb.i
  store ptr @.str.124, ptr %source.i15.i, align 8
  store i32 -1, ptr %linedefined.i16.i, align 8
  br label %funcinfo.exit.i

if.else.i.i:                                      ; preds = %sw.bb.i
  %23 = load ptr, ptr %p.i.i, align 8
  %source1.i.i = getelementptr inbounds %struct.Proto, ptr %23, i64 0, i32 9
  %24 = load ptr, ptr %source1.i.i, align 8
  %add.ptr.i.i = getelementptr inbounds %union.TString, ptr %24, i64 1
  store ptr %add.ptr.i.i, ptr %source.i15.i, align 8
  %25 = load ptr, ptr %p.i.i, align 8
  %linedefined4.i.i = getelementptr inbounds %struct.Proto, ptr %25, i64 0, i32 16
  %26 = load i32, ptr %linedefined4.i.i, align 8
  store i32 %26, ptr %linedefined.i16.i, align 8
  %27 = load ptr, ptr %p.i.i, align 8
  %lastlinedefined7.i.i = getelementptr inbounds %struct.Proto, ptr %27, i64 0, i32 17
  %28 = load i32, ptr %lastlinedefined7.i.i, align 4
  %cmp.i.i = icmp eq i32 %26, 0
  %cond.i.i = select i1 %cmp.i.i, ptr @.str.126, ptr @.str.127
  br label %funcinfo.exit.i

funcinfo.exit.i:                                  ; preds = %if.else.i.i, %if.then.i.i
  %29 = phi ptr [ %add.ptr.i.i, %if.else.i.i ], [ @.str.124, %if.then.i.i ]
  %.sink.i.i = phi i32 [ %28, %if.else.i.i ], [ -1, %if.then.i.i ]
  %.str.125.sink.i.i = phi ptr [ %cond.i.i, %if.else.i.i ], [ @.str.125, %if.then.i.i ]
  store i32 %.sink.i.i, ptr %8, align 4
  store ptr %.str.125.sink.i.i, ptr %9, align 8
  tail call fastcc void @luaO_chunkid(ptr noundef nonnull %short_src.i17.i, ptr noundef nonnull %29, i64 noundef 60)
  br label %for.inc.i

sw.bb1.i:                                         ; preds = %for.body.i
  %30 = load ptr, ptr %func.i.i.i, align 8
  %tt.i.i.i = getelementptr inbounds %struct.lua_TValue, ptr %30, i64 0, i32 1
  %31 = load i32, ptr %tt.i.i.i, align 8
  %cmp.i.i.i = icmp eq i32 %31, 6
  br i1 %cmp.i.i.i, label %land.lhs.true.i.i.i, label %cond.end.i

land.lhs.true.i.i.i:                              ; preds = %sw.bb1.i
  %32 = load ptr, ptr %30, align 8
  %isC.i.i.i = getelementptr inbounds %struct.CClosure, ptr %32, i64 0, i32 3
  %33 = load i8, ptr %isC.i.i.i, align 2
  %tobool.not.i.i.i = icmp eq i8 %33, 0
  br i1 %tobool.not.i.i.i, label %if.end.i.i.i, label %cond.end.i

if.end.i.i.i:                                     ; preds = %land.lhs.true.i.i.i
  %34 = load ptr, ptr %ci2.i.i.i, align 8
  %cmp3.i.i.i = icmp eq ptr %34, %ci.0
  br i1 %cmp3.i.i.i, label %if.then4.i.i.i, label %if.end.if.end6_crit_edge.i.i.i

if.end.if.end6_crit_edge.i.i.i:                   ; preds = %if.end.i.i.i
  %.pre.i.i.i = load ptr, ptr %savedpc7.phi.trans.insert.i.i.i, align 8
  br label %currentpc.exit.i.i

if.then4.i.i.i:                                   ; preds = %if.end.i.i.i
  %35 = load ptr, ptr %savedpc.i.i.i, align 8
  store ptr %35, ptr %savedpc7.phi.trans.insert.i.i.i, align 8
  %.pre7.i.i.i = load ptr, ptr %30, align 8
  br label %currentpc.exit.i.i

currentpc.exit.i.i:                               ; preds = %if.then4.i.i.i, %if.end.if.end6_crit_edge.i.i.i
  %36 = phi ptr [ %32, %if.end.if.end6_crit_edge.i.i.i ], [ %.pre7.i.i.i, %if.then4.i.i.i ]
  %37 = phi ptr [ %.pre.i.i.i, %if.end.if.end6_crit_edge.i.i.i ], [ %35, %if.then4.i.i.i ]
  %p.i.i.i = getelementptr inbounds %struct.LClosure, ptr %36, i64 0, i32 7
  %38 = load ptr, ptr %p.i.i.i, align 8
  %code.i.i.i = getelementptr inbounds %struct.Proto, ptr %38, i64 0, i32 4
  %39 = load ptr, ptr %code.i.i.i, align 8
  %sub.ptr.lhs.cast.i.i.i = ptrtoint ptr %37 to i64
  %sub.ptr.rhs.cast.i.i.i = ptrtoint ptr %39 to i64
  %sub.ptr.sub.i.i.i = sub i64 %sub.ptr.lhs.cast.i.i.i, %sub.ptr.rhs.cast.i.i.i
  %sub.ptr.div.i.i.i = lshr exact i64 %sub.ptr.sub.i.i.i, 2
  %conv.i.i.i = trunc i64 %sub.ptr.div.i.i.i to i32
  %sub.i.i.i = add nuw nsw i64 %sub.ptr.div.i.i.i, 4294967295
  %cmp.i18.i = icmp slt i32 %conv.i.i.i, 1
  br i1 %cmp.i18.i, label %cond.end.i, label %if.else.i19.i

if.else.i19.i:                                    ; preds = %currentpc.exit.i.i
  %lineinfo.i.i = getelementptr inbounds %struct.Proto, ptr %38, i64 0, i32 6
  %40 = load ptr, ptr %lineinfo.i.i, align 8
  %tobool.not.i20.i = icmp eq ptr %40, null
  br i1 %tobool.not.i20.i, label %cond.end.i, label %cond.true.i.i

cond.true.i.i:                                    ; preds = %if.else.i19.i
  %idxprom.i.i = and i64 %sub.i.i.i, 4294967295
  %arrayidx.i.i = getelementptr inbounds i32, ptr %40, i64 %idxprom.i.i
  %41 = load i32, ptr %arrayidx.i.i, align 4
  br label %cond.end.i

cond.end.i:                                       ; preds = %cond.true.i.i, %if.else.i19.i, %currentpc.exit.i.i, %land.lhs.true.i.i.i, %sw.bb1.i
  %cond.i = phi i32 [ -1, %currentpc.exit.i.i ], [ %41, %cond.true.i.i ], [ 0, %if.else.i19.i ], [ -1, %land.lhs.true.i.i.i ], [ -1, %sw.bb1.i ]
  store i32 %cond.i, ptr %currentline.i, align 8
  br label %for.inc.i

sw.bb3.i:                                         ; preds = %for.body.i
  %42 = load i8, ptr %nupvalues.i, align 1
  %conv4.i = zext i8 %42 to i32
  store i32 %conv4.i, ptr %nups.i, align 4
  br label %for.inc.i

sw.bb5.i:                                         ; preds = %for.body.i
  store ptr @.str.7, ptr %namewhat.i, align 8
  store ptr null, ptr %name.i, align 8
  br label %for.inc.i

sw.default.i:                                     ; preds = %for.body.i
  br label %for.inc.i

for.inc.i:                                        ; preds = %sw.default.i, %sw.bb5.i, %sw.bb3.i, %cond.end.i, %funcinfo.exit.i, %for.body.i, %for.body.i
  %status.1.i = phi i32 [ 0, %sw.default.i ], [ %status.023.i, %for.body.i ], [ %status.023.i, %for.body.i ], [ %status.023.i, %sw.bb5.i ], [ %status.023.i, %sw.bb3.i ], [ %status.023.i, %cond.end.i ], [ %status.023.i, %funcinfo.exit.i ]
  %incdec.ptr.i = getelementptr inbounds i8, ptr %what.addr.022.i, i64 1
  %43 = load i8, ptr %incdec.ptr.i, align 1
  %tobool.not.i = icmp eq i8 %43, 0
  br i1 %tobool.not.i, label %auxgetinfo.exit, label %for.body.i, !llvm.loop !90

auxgetinfo.exit:                                  ; preds = %for.inc.i, %for.inc.us.i, %for.cond.preheader.i
  %call12 = tail call ptr @strchr(ptr noundef nonnull dereferenceable(1) %what.addr.0, i32 noundef 102) #34
  %tobool.not = icmp eq ptr %call12, null
  br i1 %tobool.not, label %if.end31.thread, label %if.else18

auxgetinfo.exit.thread:                           ; preds = %if.end11, %if.else
  %what.addr.043 = phi ptr [ %what.addr.0, %if.end11 ], [ %what, %if.else ]
  %namewhat.i.i = getelementptr inbounds %struct.lua_Debug, ptr %ar, i64 0, i32 2
  store ptr @.str.7, ptr %namewhat.i.i, align 8
  %name.i.i = getelementptr inbounds %struct.lua_Debug, ptr %ar, i64 0, i32 1
  store ptr @.str.7, ptr %name.i.i, align 8
  %what.i.i = getelementptr inbounds %struct.lua_Debug, ptr %ar, i64 0, i32 3
  store ptr @.str.122, ptr %what.i.i, align 8
  %currentline.i.i = getelementptr inbounds %struct.lua_Debug, ptr %ar, i64 0, i32 5
  store i32 -1, ptr %currentline.i.i, align 8
  %linedefined.i.i = getelementptr inbounds %struct.lua_Debug, ptr %ar, i64 0, i32 7
  store i32 -1, ptr %linedefined.i.i, align 8
  %lastlinedefined.i.i = getelementptr inbounds %struct.lua_Debug, ptr %ar, i64 0, i32 8
  store i32 -1, ptr %lastlinedefined.i.i, align 4
  %source.i.i = getelementptr inbounds %struct.lua_Debug, ptr %ar, i64 0, i32 4
  store ptr @.str.123, ptr %source.i.i, align 8
  %short_src.i.i = getelementptr inbounds %struct.lua_Debug, ptr %ar, i64 0, i32 9
  tail call fastcc void @luaO_chunkid(ptr noundef nonnull %short_src.i.i, ptr noundef nonnull @.str.123, i64 noundef 60)
  %nups.i.i = getelementptr inbounds %struct.lua_Debug, ptr %ar, i64 0, i32 6
  store i32 0, ptr %nups.i.i, align 4
  %call1254 = tail call ptr @strchr(ptr noundef nonnull dereferenceable(1) %what.addr.043, i32 noundef 102) #34
  %tobool.not55 = icmp eq ptr %call1254, null
  br i1 %tobool.not55, label %if.end31, label %if.then16

if.then16:                                        ; preds = %auxgetinfo.exit.thread
  %top17 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %44 = load ptr, ptr %top17, align 8
  br label %if.end22

if.else18:                                        ; preds = %auxgetinfo.exit
  %top19 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %45 = load ptr, ptr %top19, align 8
  store ptr %f.0, ptr %45, align 8
  br label %if.end22

if.end22:                                         ; preds = %if.else18, %if.then16
  %.sink95 = phi ptr [ %45, %if.else18 ], [ %44, %if.then16 ]
  %.sink = phi i32 [ 6, %if.else18 ], [ 0, %if.then16 ]
  %cmp.i445674 = phi i1 [ false, %if.else18 ], [ true, %if.then16 ]
  %what.addr.0425872 = phi ptr [ %what.addr.0, %if.else18 ], [ %what.addr.043, %if.then16 ]
  %f.0396070 = phi ptr [ %f.0, %if.else18 ], [ null, %if.then16 ]
  %tt21 = getelementptr inbounds %struct.lua_TValue, ptr %.sink95, i64 0, i32 1
  store i32 %.sink, ptr %tt21, align 8
  %stack_last = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 9
  %46 = load ptr, ptr %stack_last, align 8
  %top23 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %47 = load ptr, ptr %top23, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %46 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %47 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp24 = icmp slt i64 %sub.ptr.sub, 17
  br i1 %cmp24, label %if.then26, label %if.end28

if.then26:                                        ; preds = %if.end22
  %stacksize.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 13
  %48 = load i32, ptr %stacksize.i, align 8
  %cmp.not.i = icmp slt i32 %48, 1
  %add.i = add nsw i32 %48, 1
  %mul.i = shl nsw i32 %48, 1
  %add.sink.i = select i1 %cmp.not.i, i32 %add.i, i32 %mul.i
  tail call fastcc void @luaD_reallocstack(ptr noundef nonnull %L, i32 noundef %add.sink.i)
  %.pre = load ptr, ptr %top23, align 8
  br label %if.end28

if.end28:                                         ; preds = %if.end22, %if.then26
  %49 = phi ptr [ %47, %if.end22 ], [ %.pre, %if.then26 ]
  %incdec.ptr30 = getelementptr inbounds %struct.lua_TValue, ptr %49, i64 1
  store ptr %incdec.ptr30, ptr %top23, align 8
  br label %if.end31

if.end31:                                         ; preds = %auxgetinfo.exit.thread, %if.end28
  %f.03961 = phi ptr [ null, %auxgetinfo.exit.thread ], [ %f.0396070, %if.end28 ]
  %what.addr.04259 = phi ptr [ %what.addr.043, %auxgetinfo.exit.thread ], [ %what.addr.0425872, %if.end28 ]
  %cmp.i4457 = phi i1 [ true, %auxgetinfo.exit.thread ], [ %cmp.i445674, %if.end28 ]
  %call32 = tail call ptr @strchr(ptr noundef nonnull dereferenceable(1) %what.addr.04259, i32 noundef 76) #34
  %tobool33.not = icmp eq ptr %call32, null
  br i1 %tobool33.not, label %if.end35, label %if.then34

if.end31.thread:                                  ; preds = %auxgetinfo.exit
  %call3280 = tail call ptr @strchr(ptr noundef nonnull dereferenceable(1) %what.addr.0, i32 noundef 76) #34
  %tobool33.not81 = icmp eq ptr %call3280, null
  br i1 %tobool33.not81, label %if.end35, label %lor.lhs.false.i

if.then34:                                        ; preds = %if.end31
  br i1 %cmp.i4457, label %if.then.i24, label %lor.lhs.false.i

lor.lhs.false.i:                                  ; preds = %if.end31.thread, %if.then34
  %f.039618489 = phi ptr [ %f.03961, %if.then34 ], [ %f.0, %if.end31.thread ]
  %isC.i = getelementptr inbounds %struct.CClosure, ptr %f.039618489, i64 0, i32 3
  %50 = load i8, ptr %isC.i, align 2
  %tobool.not.i23 = icmp eq i8 %50, 0
  br i1 %tobool.not.i23, label %if.else.i, label %if.then.i24

if.then.i24:                                      ; preds = %lor.lhs.false.i, %if.then34
  %top.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %51 = load ptr, ptr %top.i, align 8
  br label %if.end.i

if.else.i:                                        ; preds = %lor.lhs.false.i
  %call.i = tail call fastcc ptr @luaH_new(ptr noundef %L, i32 noundef 0, i32 noundef 0)
  %p.i = getelementptr inbounds %struct.LClosure, ptr %f.039618489, i64 0, i32 7
  %52 = load ptr, ptr %p.i, align 8
  %lineinfo1.i = getelementptr inbounds %struct.Proto, ptr %52, i64 0, i32 6
  %53 = load ptr, ptr %lineinfo1.i, align 8
  %sizelineinfo18.i = getelementptr inbounds %struct.Proto, ptr %52, i64 0, i32 13
  %54 = load i32, ptr %sizelineinfo18.i, align 4
  %cmp319.i = icmp sgt i32 %54, 0
  br i1 %cmp319.i, label %for.body.lr.ph.i26, label %for.end.i

for.body.lr.ph.i26:                               ; preds = %if.else.i
  %sizearray.i.i.i = getelementptr inbounds %struct.Table, ptr %call.i, i64 0, i32 10
  %node4.i.i.i.i = getelementptr inbounds %struct.Table, ptr %call.i, i64 0, i32 7
  %lsizenode.i.i.i.i = getelementptr inbounds %struct.Table, ptr %call.i, i64 0, i32 4
  %array.i.i.i = getelementptr inbounds %struct.Table, ptr %call.i, i64 0, i32 6
  %tt.i.i = getelementptr inbounds %struct.lua_TValue, ptr %k.i.i, i64 0, i32 1
  br label %for.body.i27

for.body.i27:                                     ; preds = %luaH_setnum.exit.i, %for.body.lr.ph.i26
  %indvars.iv.i = phi i64 [ 0, %for.body.lr.ph.i26 ], [ %indvars.iv.next.i, %luaH_setnum.exit.i ]
  %arrayidx.i = getelementptr inbounds i32, ptr %53, i64 %indvars.iv.i
  %55 = load i32, ptr %arrayidx.i, align 4
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %k.i.i)
  %sub.i.i.i28 = add i32 %55, -1
  %56 = load i32, ptr %sizearray.i.i.i, align 8
  %cmp.i.i.i29 = icmp ult i32 %sub.i.i.i28, %56
  br i1 %cmp.i.i.i29, label %if.then.i.i.i, label %if.else.i.i.i

if.then.i.i.i:                                    ; preds = %for.body.i27
  %57 = load ptr, ptr %array.i.i.i, align 8
  %idxprom.i.i.i = sext i32 %sub.i.i.i28 to i64
  %arrayidx.i.i.i = getelementptr inbounds %struct.lua_TValue, ptr %57, i64 %idxprom.i.i.i
  br label %luaH_getnum.exit.i.i

if.else.i.i.i:                                    ; preds = %for.body.i27
  %conv.i.i.i30 = sitofp i32 %55 to double
  %cmp.i.i.i.i = icmp eq i32 %55, 0
  br i1 %cmp.i.i.i.i, label %if.then.i.i.i.i, label %if.end.i.i.i.i

if.then.i.i.i.i:                                  ; preds = %if.else.i.i.i
  %58 = load ptr, ptr %node4.i.i.i.i, align 8
  br label %do.body.i.i.i.preheader

if.end.i.i.i.i:                                   ; preds = %if.else.i.i.i
  %59 = bitcast double %conv.i.i.i30 to i64
  %a.sroa.0.4.extract.shift.i.i.i.i = lshr i64 %59, 32
  %add.i.i.i.i = add i64 %a.sroa.0.4.extract.shift.i.i.i.i, %59
  %60 = load ptr, ptr %node4.i.i.i.i, align 8
  %conv.i.i.i.i = and i64 %add.i.i.i.i, 4294967295
  %61 = load i8, ptr %lsizenode.i.i.i.i, align 1
  %sh_prom.i.i.i.i = zext nneg i8 %61 to i64
  %notmask.i.i.i.i = shl nsw i64 -1, %sh_prom.i.i.i.i
  %sub.i.i.i.i = xor i64 %notmask.i.i.i.i, -1
  %or.i.i.i.i = or i64 %sub.i.i.i.i, 1
  %rem.i.i.i.i = urem i64 %conv.i.i.i.i, %or.i.i.i.i
  %arrayidx7.i.i.i.i = getelementptr inbounds %struct.Node, ptr %60, i64 %rem.i.i.i.i
  br label %do.body.i.i.i.preheader

do.body.i.i.i.preheader:                          ; preds = %if.end.i.i.i.i, %if.then.i.i.i.i
  %n.0.i.i.i.ph = phi ptr [ %arrayidx7.i.i.i.i, %if.end.i.i.i.i ], [ %58, %if.then.i.i.i.i ]
  br label %do.body.i.i.i

do.body.i.i.i:                                    ; preds = %do.body.i.i.i.preheader, %if.else8.i.i.i
  %n.0.i.i.i = phi ptr [ %64, %if.else8.i.i.i ], [ %n.0.i.i.i.ph, %do.body.i.i.i.preheader ]
  %tt.i.i.i31 = getelementptr inbounds %struct.Node, ptr %n.0.i.i.i, i64 0, i32 1, i32 0, i32 1
  %62 = load i32, ptr %tt.i.i.i31, align 8
  %cmp2.i.i.i = icmp eq i32 %62, 3
  br i1 %cmp2.i.i.i, label %land.lhs.true.i.i.i34, label %if.else8.i.i.i

land.lhs.true.i.i.i34:                            ; preds = %do.body.i.i.i
  %i_key.i.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i.i, i64 0, i32 1
  %63 = load double, ptr %i_key.i.i.i, align 8
  %cmp5.i.i.i = fcmp oeq double %63, %conv.i.i.i30
  br i1 %cmp5.i.i.i, label %luaH_getnum.exit.i.i, label %if.else8.i.i.i

if.else8.i.i.i:                                   ; preds = %land.lhs.true.i.i.i34, %do.body.i.i.i
  %next.i.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i.i, i64 0, i32 1, i32 0, i32 2
  %64 = load ptr, ptr %next.i.i.i, align 8
  %tobool.not.i.i.i32 = icmp eq ptr %64, null
  br i1 %tobool.not.i.i.i32, label %if.else.i.i33, label %do.body.i.i.i, !llvm.loop !7

luaH_getnum.exit.i.i:                             ; preds = %land.lhs.true.i.i.i34, %if.then.i.i.i
  %retval.0.i.i.i = phi ptr [ %arrayidx.i.i.i, %if.then.i.i.i ], [ %n.0.i.i.i, %land.lhs.true.i.i.i34 ]
  %cmp.not.i.i = icmp eq ptr %retval.0.i.i.i, @luaO_nilobject_
  br i1 %cmp.not.i.i, label %luaH_getnum.exit.if.else_crit_edge.i.i, label %luaH_setnum.exit.i

luaH_getnum.exit.if.else_crit_edge.i.i:           ; preds = %luaH_getnum.exit.i.i
  %.pre.i.i = sitofp i32 %55 to double
  br label %if.else.i.i33

if.else.i.i33:                                    ; preds = %if.else8.i.i.i, %luaH_getnum.exit.if.else_crit_edge.i.i
  %conv.pre-phi.i.i = phi double [ %.pre.i.i, %luaH_getnum.exit.if.else_crit_edge.i.i ], [ %conv.i.i.i30, %if.else8.i.i.i ]
  store double %conv.pre-phi.i.i, ptr %k.i.i, align 8
  store i32 3, ptr %tt.i.i, align 8
  %call1.i.i = call fastcc ptr @newkey(ptr noundef %L, ptr noundef %call.i, ptr noundef nonnull %k.i.i)
  br label %luaH_setnum.exit.i

luaH_setnum.exit.i:                               ; preds = %if.else.i.i33, %luaH_getnum.exit.i.i
  %retval.0.i.i = phi ptr [ %call1.i.i, %if.else.i.i33 ], [ %retval.0.i.i.i, %luaH_getnum.exit.i.i ]
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %k.i.i)
  store i32 1, ptr %retval.0.i.i, align 8
  %tt6.i = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i.i, i64 0, i32 1
  store i32 1, ptr %tt6.i, align 8
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %65 = load ptr, ptr %p.i, align 8
  %sizelineinfo.i = getelementptr inbounds %struct.Proto, ptr %65, i64 0, i32 13
  %66 = load i32, ptr %sizelineinfo.i, align 4
  %67 = sext i32 %66 to i64
  %cmp3.i = icmp slt i64 %indvars.iv.next.i, %67
  br i1 %cmp3.i, label %for.body.i27, label %for.end.i, !llvm.loop !91

for.end.i:                                        ; preds = %luaH_setnum.exit.i, %if.else.i
  %top8.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %68 = load ptr, ptr %top8.i, align 8
  store ptr %call.i, ptr %68, align 8
  br label %if.end.i

if.end.i:                                         ; preds = %for.end.i, %if.then.i24
  %.sink24.i = phi ptr [ %68, %for.end.i ], [ %51, %if.then.i24 ]
  %.sink.i = phi i32 [ 5, %for.end.i ], [ 0, %if.then.i24 ]
  %tt10.i = getelementptr inbounds %struct.lua_TValue, ptr %.sink24.i, i64 0, i32 1
  store i32 %.sink.i, ptr %tt10.i, align 8
  %stack_last.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 9
  %69 = load ptr, ptr %stack_last.i, align 8
  %top11.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %70 = load ptr, ptr %top11.i, align 8
  %sub.ptr.lhs.cast.i = ptrtoint ptr %69 to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %70 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %cmp12.i = icmp slt i64 %sub.ptr.sub.i, 17
  br i1 %cmp12.i, label %if.then14.i, label %collectvalidlines.exit

if.then14.i:                                      ; preds = %if.end.i
  %stacksize.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 13
  %71 = load i32, ptr %stacksize.i.i, align 8
  %cmp.not.i16.i = icmp slt i32 %71, 1
  %add.i.i = add nsw i32 %71, 1
  %mul.i.i = shl nsw i32 %71, 1
  %add.sink.i.i = select i1 %cmp.not.i16.i, i32 %add.i.i, i32 %mul.i.i
  tail call fastcc void @luaD_reallocstack(ptr noundef nonnull %L, i32 noundef %add.sink.i.i)
  %.pre.i = load ptr, ptr %top11.i, align 8
  br label %collectvalidlines.exit

collectvalidlines.exit:                           ; preds = %if.end.i, %if.then14.i
  %72 = phi ptr [ %70, %if.end.i ], [ %.pre.i, %if.then14.i ]
  %incdec.ptr.i25 = getelementptr inbounds %struct.lua_TValue, ptr %72, i64 1
  store ptr %incdec.ptr.i25, ptr %top11.i, align 8
  br label %if.end35

if.end35:                                         ; preds = %if.end31.thread, %collectvalidlines.exit, %if.end31
  ret void
}

; Function Attrs: mustprogress nofree nounwind willreturn memory(argmem: read)
declare i32 @strcmp(ptr nocapture noundef, ptr nocapture noundef) local_unnamed_addr #11

; Function Attrs: nounwind uwtable
define internal fastcc void @luaL_where(ptr noundef %L, i32 noundef %level) unnamed_addr #0 {
entry:
  %ar = alloca %struct.lua_Debug, align 8
  %ci1.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %0 = load ptr, ptr %ci1.i, align 8
  %cmp18.i = icmp sgt i32 %level, 0
  br i1 %cmp18.i, label %land.rhs.lr.ph.i, label %for.end.i

land.rhs.lr.ph.i:                                 ; preds = %entry
  %base_ci.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 12
  %1 = load ptr, ptr %base_ci.i, align 8
  br label %land.rhs.i

land.rhs.i:                                       ; preds = %for.inc.i, %land.rhs.lr.ph.i
  %ci.020.i = phi ptr [ %0, %land.rhs.lr.ph.i ], [ %incdec.ptr.i, %for.inc.i ]
  %level.addr.019.i = phi i32 [ %level, %land.rhs.lr.ph.i ], [ %level.addr.1.i, %for.inc.i ]
  %cmp2.i = icmp ugt ptr %ci.020.i, %1
  br i1 %cmp2.i, label %for.body.i, label %if.end5

for.body.i:                                       ; preds = %land.rhs.i
  %dec.i = add nsw i32 %level.addr.019.i, -1
  %func.i = getelementptr inbounds %struct.CallInfo, ptr %ci.020.i, i64 0, i32 1
  %2 = load ptr, ptr %func.i, align 8
  %3 = load ptr, ptr %2, align 8
  %isC.i = getelementptr inbounds %struct.CClosure, ptr %3, i64 0, i32 3
  %4 = load i8, ptr %isC.i, align 2
  %tobool.not.i = icmp eq i8 %4, 0
  br i1 %tobool.not.i, label %if.then.i, label %for.inc.i

if.then.i:                                        ; preds = %for.body.i
  %tailcalls.i = getelementptr inbounds %struct.CallInfo, ptr %ci.020.i, i64 0, i32 5
  %5 = load i32, ptr %tailcalls.i, align 4
  %sub.i = sub nsw i32 %dec.i, %5
  br label %for.inc.i

for.inc.i:                                        ; preds = %if.then.i, %for.body.i
  %level.addr.1.i = phi i32 [ %dec.i, %for.body.i ], [ %sub.i, %if.then.i ]
  %incdec.ptr.i = getelementptr inbounds %struct.CallInfo, ptr %ci.020.i, i64 -1
  %cmp.i = icmp sgt i32 %level.addr.1.i, 0
  br i1 %cmp.i, label %land.rhs.i, label %for.end.i, !llvm.loop !87

for.end.i:                                        ; preds = %for.inc.i, %entry
  %level.addr.0.lcssa.i = phi i32 [ %level, %entry ], [ %level.addr.1.i, %for.inc.i ]
  %ci.0.lcssa.i = phi ptr [ %0, %entry ], [ %incdec.ptr.i, %for.inc.i ]
  %cmp3.i = icmp eq i32 %level.addr.0.lcssa.i, 0
  br i1 %cmp3.i, label %land.lhs.true.i, label %if.then

land.lhs.true.i:                                  ; preds = %for.end.i
  %base_ci4.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 12
  %6 = load ptr, ptr %base_ci4.i, align 8
  %cmp5.i = icmp ugt ptr %ci.0.lcssa.i, %6
  br i1 %cmp5.i, label %if.then6.i, label %if.end5

if.then6.i:                                       ; preds = %land.lhs.true.i
  %sub.ptr.lhs.cast.i = ptrtoint ptr %ci.0.lcssa.i to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %6 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %sub.ptr.div.i = sdiv exact i64 %sub.ptr.sub.i, 40
  %conv.i = trunc i64 %sub.ptr.div.i to i32
  br label %if.then

if.then:                                          ; preds = %if.then6.i, %for.end.i
  %.sink.i = phi i32 [ %conv.i, %if.then6.i ], [ 0, %for.end.i ]
  %i_ci11.i = getelementptr inbounds %struct.lua_Debug, ptr %ar, i64 0, i32 10
  store i32 %.sink.i, ptr %i_ci11.i, align 4
  call fastcc void @lua_getinfo(ptr noundef %L, ptr noundef nonnull @.str.128, ptr noundef nonnull %ar)
  %currentline = getelementptr inbounds %struct.lua_Debug, ptr %ar, i64 0, i32 5
  %7 = load i32, ptr %currentline, align 8
  %cmp = icmp sgt i32 %7, 0
  br i1 %cmp, label %if.then2, label %if.end5

if.then2:                                         ; preds = %if.then
  %short_src = getelementptr inbounds %struct.lua_Debug, ptr %ar, i64 0, i32 9
  %call4 = call ptr (ptr, ptr, ...) @lua_pushfstring(ptr noundef %L, ptr noundef nonnull @.str.129, ptr noundef nonnull %short_src, i32 noundef %7)
  br label %return

if.end5:                                          ; preds = %land.rhs.i, %land.lhs.true.i, %if.then
  %l_G.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %8 = load ptr, ptr %l_G.i, align 8
  %totalbytes.i = getelementptr inbounds %struct.global_State, ptr %8, i64 0, i32 14
  %9 = load i64, ptr %totalbytes.i, align 8
  %GCthreshold.i = getelementptr inbounds %struct.global_State, ptr %8, i64 0, i32 13
  %10 = load i64, ptr %GCthreshold.i, align 8
  %cmp.not.i = icmp ult i64 %9, %10
  br i1 %cmp.not.i, label %lua_pushlstring.exit, label %if.then.i4

if.then.i4:                                       ; preds = %if.end5
  %gcstepmul.i.i = getelementptr inbounds %struct.global_State, ptr %8, i64 0, i32 18
  %11 = load i32, ptr %gcstepmul.i.i, align 4
  %mul.i.i = mul i32 %11, 10
  %conv.i.i = zext i32 %mul.i.i to i64
  %cmp.i.i = icmp eq i32 %mul.i.i, 0
  %spec.store.select.i.i = select i1 %cmp.i.i, i64 9223372036854775806, i64 %conv.i.i
  %sub.i.i = sub i64 %9, %10
  %gcdept.i.i = getelementptr inbounds %struct.global_State, ptr %8, i64 0, i32 16
  %12 = load i64, ptr %gcdept.i.i, align 8
  %add.i.i = add i64 %sub.i.i, %12
  store i64 %add.i.i, ptr %gcdept.i.i, align 8
  %gcstate.i.i = getelementptr inbounds %struct.global_State, ptr %8, i64 0, i32 4
  br label %do.body.i.i

do.body.i.i:                                      ; preds = %do.body.i.i, %if.then.i4
  %lim.0.i.i = phi i64 [ %spec.store.select.i.i, %if.then.i4 ], [ %sub2.i.i, %do.body.i.i ]
  %call.i.i = call fastcc i64 @singlestep(ptr noundef %L)
  %sub2.i.i = sub nsw i64 %lim.0.i.i, %call.i.i
  %13 = load i8, ptr %gcstate.i.i, align 1
  %cmp4.i.i = icmp ne i8 %13, 0
  %cmp8.i.i = icmp sgt i64 %sub2.i.i, 0
  %or.cond.i.i = select i1 %cmp4.i.i, i1 %cmp8.i.i, i1 false
  br i1 %or.cond.i.i, label %do.body.i.i, label %do.end.i.i, !llvm.loop !6

do.end.i.i:                                       ; preds = %do.body.i.i
  br i1 %cmp4.i.i, label %if.then14.i.i, label %if.else27.i.i

if.then14.i.i:                                    ; preds = %do.end.i.i
  %14 = load i64, ptr %gcdept.i.i, align 8
  %cmp16.i.i = icmp ult i64 %14, 1024
  br i1 %cmp16.i.i, label %if.then18.i.i, label %if.else.i.i

if.then18.i.i:                                    ; preds = %if.then14.i.i
  %15 = load i64, ptr %totalbytes.i, align 8
  %add20.i.i = add i64 %15, 1024
  br label %luaC_step.exit.i

if.else.i.i:                                      ; preds = %if.then14.i.i
  %sub23.i.i = add i64 %14, -1024
  store i64 %sub23.i.i, ptr %gcdept.i.i, align 8
  %16 = load i64, ptr %totalbytes.i, align 8
  br label %luaC_step.exit.i

if.else27.i.i:                                    ; preds = %do.end.i.i
  %estimate.i.i = getelementptr inbounds %struct.global_State, ptr %8, i64 0, i32 15
  %17 = load i64, ptr %estimate.i.i, align 8
  %div.i.i = udiv i64 %17, 100
  %gcpause.i.i = getelementptr inbounds %struct.global_State, ptr %8, i64 0, i32 17
  %18 = load i32, ptr %gcpause.i.i, align 8
  %conv28.i.i = sext i32 %18 to i64
  %mul29.i.i = mul i64 %div.i.i, %conv28.i.i
  br label %luaC_step.exit.i

luaC_step.exit.i:                                 ; preds = %if.else27.i.i, %if.else.i.i, %if.then18.i.i
  %add20.sink.i.i = phi i64 [ %add20.i.i, %if.then18.i.i ], [ %16, %if.else.i.i ], [ %mul29.i.i, %if.else27.i.i ]
  store i64 %add20.sink.i.i, ptr %GCthreshold.i, align 8
  br label %lua_pushlstring.exit

lua_pushlstring.exit:                             ; preds = %if.end5, %luaC_step.exit.i
  %top.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %19 = load ptr, ptr %top.i, align 8
  %call.i = call fastcc ptr @luaS_newlstr(ptr noundef %L, ptr noundef nonnull @.str.7, i64 noundef 0)
  store ptr %call.i, ptr %19, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %19, i64 0, i32 1
  store i32 4, ptr %tt.i, align 8
  %20 = load ptr, ptr %top.i, align 8
  %incdec.ptr.i5 = getelementptr inbounds %struct.lua_TValue, ptr %20, i64 1
  store ptr %incdec.ptr.i5, ptr %top.i, align 8
  br label %return

return:                                           ; preds = %lua_pushlstring.exit, %if.then2
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @lua_concat(ptr noundef %L, i32 noundef %n) unnamed_addr #0 {
entry:
  %cmp = icmp sgt i32 %n, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %l_G = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %0 = load ptr, ptr %l_G, align 8
  %totalbytes = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 14
  %1 = load i64, ptr %totalbytes, align 8
  %GCthreshold = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 13
  %2 = load i64, ptr %GCthreshold, align 8
  %cmp2.not = icmp ult i64 %1, %2
  br i1 %cmp2.not, label %if.end, label %if.then3

if.then3:                                         ; preds = %if.then
  %gcstepmul.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 18
  %3 = load i32, ptr %gcstepmul.i, align 4
  %mul.i = mul i32 %3, 10
  %conv.i = zext i32 %mul.i to i64
  %cmp.i = icmp eq i32 %mul.i, 0
  %spec.store.select.i = select i1 %cmp.i, i64 9223372036854775806, i64 %conv.i
  %sub.i = sub i64 %1, %2
  %gcdept.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 16
  %4 = load i64, ptr %gcdept.i, align 8
  %add.i = add i64 %sub.i, %4
  store i64 %add.i, ptr %gcdept.i, align 8
  %gcstate.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 4
  br label %do.body.i

do.body.i:                                        ; preds = %do.body.i, %if.then3
  %lim.0.i = phi i64 [ %spec.store.select.i, %if.then3 ], [ %sub2.i, %do.body.i ]
  %call.i = tail call fastcc i64 @singlestep(ptr noundef %L)
  %sub2.i = sub nsw i64 %lim.0.i, %call.i
  %5 = load i8, ptr %gcstate.i, align 1
  %cmp4.i = icmp ne i8 %5, 0
  %cmp8.i = icmp sgt i64 %sub2.i, 0
  %or.cond.i = select i1 %cmp4.i, i1 %cmp8.i, i1 false
  br i1 %or.cond.i, label %do.body.i, label %do.end.i, !llvm.loop !6

do.end.i:                                         ; preds = %do.body.i
  br i1 %cmp4.i, label %if.then14.i, label %if.else27.i

if.then14.i:                                      ; preds = %do.end.i
  %6 = load i64, ptr %gcdept.i, align 8
  %cmp16.i = icmp ult i64 %6, 1024
  br i1 %cmp16.i, label %if.then18.i, label %if.else.i

if.then18.i:                                      ; preds = %if.then14.i
  %7 = load i64, ptr %totalbytes, align 8
  %add20.i = add i64 %7, 1024
  br label %luaC_step.exit

if.else.i:                                        ; preds = %if.then14.i
  %sub23.i = add i64 %6, -1024
  store i64 %sub23.i, ptr %gcdept.i, align 8
  %8 = load i64, ptr %totalbytes, align 8
  br label %luaC_step.exit

if.else27.i:                                      ; preds = %do.end.i
  %estimate.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 15
  %9 = load i64, ptr %estimate.i, align 8
  %div.i = udiv i64 %9, 100
  %gcpause.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 17
  %10 = load i32, ptr %gcpause.i, align 8
  %conv28.i = sext i32 %10 to i64
  %mul29.i = mul i64 %div.i, %conv28.i
  br label %luaC_step.exit

luaC_step.exit:                                   ; preds = %if.then18.i, %if.else.i, %if.else27.i
  %add20.sink.i = phi i64 [ %add20.i, %if.then18.i ], [ %8, %if.else.i ], [ %mul29.i, %if.else27.i ]
  store i64 %add20.sink.i, ptr %GCthreshold, align 8
  br label %if.end

if.end:                                           ; preds = %luaC_step.exit, %if.then
  %top = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %11 = load ptr, ptr %top, align 8
  %base = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %12 = load ptr, ptr %base, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %11 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %12 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = lshr exact i64 %sub.ptr.sub, 4
  %conv = trunc i64 %sub.ptr.div to i32
  %sub = add nsw i32 %conv, -1
  tail call fastcc void @luaV_concat(ptr noundef %L, i32 noundef %n, i32 noundef %sub)
  %sub4 = add nsw i32 %n, -1
  %13 = load ptr, ptr %top, align 8
  %idx.ext = zext nneg i32 %sub4 to i64
  %idx.neg = sub nsw i64 0, %idx.ext
  %add.ptr = getelementptr inbounds %struct.lua_TValue, ptr %13, i64 %idx.neg
  store ptr %add.ptr, ptr %top, align 8
  br label %if.end12

if.else:                                          ; preds = %entry
  %cmp6 = icmp eq i32 %n, 0
  br i1 %cmp6, label %if.then8, label %if.end12

if.then8:                                         ; preds = %if.else
  %top9 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %14 = load ptr, ptr %top9, align 8
  %call = tail call fastcc ptr @luaS_newlstr(ptr noundef %L, ptr noundef nonnull @.str.7, i64 noundef 0)
  store ptr %call, ptr %14, align 8
  %tt = getelementptr inbounds %struct.lua_TValue, ptr %14, i64 0, i32 1
  store i32 4, ptr %tt, align 8
  %15 = load ptr, ptr %top9, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue, ptr %15, i64 1
  store ptr %incdec.ptr, ptr %top9, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.else, %if.then8, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal ptr @lua_pushfstring(ptr noundef %L, ptr noundef %fmt, ...) unnamed_addr #0 {
entry:
  %argp = alloca [1 x %struct.__va_list_tag], align 16
  %l_G = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %0 = load ptr, ptr %l_G, align 8
  %totalbytes = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 14
  %1 = load i64, ptr %totalbytes, align 8
  %GCthreshold = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 13
  %2 = load i64, ptr %GCthreshold, align 8
  %cmp.not = icmp ult i64 %1, %2
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %gcstepmul.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 18
  %3 = load i32, ptr %gcstepmul.i, align 4
  %mul.i = mul i32 %3, 10
  %conv.i = zext i32 %mul.i to i64
  %cmp.i = icmp eq i32 %mul.i, 0
  %spec.store.select.i = select i1 %cmp.i, i64 9223372036854775806, i64 %conv.i
  %sub.i = sub i64 %1, %2
  %gcdept.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 16
  %4 = load i64, ptr %gcdept.i, align 8
  %add.i = add i64 %sub.i, %4
  store i64 %add.i, ptr %gcdept.i, align 8
  %gcstate.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 4
  br label %do.body.i

do.body.i:                                        ; preds = %do.body.i, %if.then
  %lim.0.i = phi i64 [ %spec.store.select.i, %if.then ], [ %sub2.i, %do.body.i ]
  %call.i = tail call fastcc i64 @singlestep(ptr noundef %L)
  %sub2.i = sub nsw i64 %lim.0.i, %call.i
  %5 = load i8, ptr %gcstate.i, align 1
  %cmp4.i = icmp ne i8 %5, 0
  %cmp8.i = icmp sgt i64 %sub2.i, 0
  %or.cond.i = select i1 %cmp4.i, i1 %cmp8.i, i1 false
  br i1 %or.cond.i, label %do.body.i, label %do.end.i, !llvm.loop !6

do.end.i:                                         ; preds = %do.body.i
  br i1 %cmp4.i, label %if.then14.i, label %if.else27.i

if.then14.i:                                      ; preds = %do.end.i
  %6 = load i64, ptr %gcdept.i, align 8
  %cmp16.i = icmp ult i64 %6, 1024
  br i1 %cmp16.i, label %if.then18.i, label %if.else.i

if.then18.i:                                      ; preds = %if.then14.i
  %7 = load i64, ptr %totalbytes, align 8
  %add20.i = add i64 %7, 1024
  br label %luaC_step.exit

if.else.i:                                        ; preds = %if.then14.i
  %sub23.i = add i64 %6, -1024
  store i64 %sub23.i, ptr %gcdept.i, align 8
  %8 = load i64, ptr %totalbytes, align 8
  br label %luaC_step.exit

if.else27.i:                                      ; preds = %do.end.i
  %estimate.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 15
  %9 = load i64, ptr %estimate.i, align 8
  %div.i = udiv i64 %9, 100
  %gcpause.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 17
  %10 = load i32, ptr %gcpause.i, align 8
  %conv28.i = sext i32 %10 to i64
  %mul29.i = mul i64 %div.i, %conv28.i
  br label %luaC_step.exit

luaC_step.exit:                                   ; preds = %if.then18.i, %if.else.i, %if.else27.i
  %add20.sink.i = phi i64 [ %add20.i, %if.then18.i ], [ %8, %if.else.i ], [ %mul29.i, %if.else27.i ]
  store i64 %add20.sink.i, ptr %GCthreshold, align 8
  br label %if.end

if.end:                                           ; preds = %luaC_step.exit, %entry
  call void @llvm.va_start(ptr nonnull %argp)
  %call = call fastcc ptr @luaO_pushvfstring(ptr noundef %L, ptr noundef %fmt, ptr noundef nonnull %argp)
  call void @llvm.va_end(ptr nonnull %argp)
  ret ptr %call
}

; Function Attrs: noreturn nounwind uwtable
define internal fastcc void @luaL_typerror(ptr noundef %L, i32 noundef %narg, ptr noundef %tname) unnamed_addr #7 {
entry:
  %cmp.i.i = icmp sgt i32 %narg, 0
  br i1 %cmp.i.i, label %if.then.i.i, label %if.else3.i.i

if.then.i.i:                                      ; preds = %entry
  %base.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i, align 8
  %1 = zext nneg i32 %narg to i64
  %2 = getelementptr %struct.lua_TValue, ptr %0, i64 %1
  %add.ptr.i.i = getelementptr %struct.lua_TValue, ptr %2, i64 -1
  %top.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %3 = load ptr, ptr %top.i.i, align 8
  %cmp1.not.i.i = icmp ult ptr %add.ptr.i.i, %3
  br i1 %cmp1.not.i.i, label %index2adr.exit.i, label %lua_typename.exit

if.else3.i.i:                                     ; preds = %entry
  %cmp4.i.i = icmp sgt i32 %narg, -10000
  br i1 %cmp4.i.i, label %if.then5.i.i, label %if.else9.i.i

if.then5.i.i:                                     ; preds = %if.else3.i.i
  %top6.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %4 = load ptr, ptr %top6.i.i, align 8
  %idx.ext7.i.i = sext i32 %narg to i64
  %add.ptr8.i.i = getelementptr inbounds %struct.lua_TValue, ptr %4, i64 %idx.ext7.i.i
  br label %index2adr.exit.i

if.else9.i.i:                                     ; preds = %if.else3.i.i
  switch i32 %narg, label %sw.default.i.i [
    i32 -10000, label %sw.bb.i.i
    i32 -10001, label %sw.bb10.i.i
    i32 -10002, label %sw.bb15.i.i
  ]

sw.bb.i.i:                                        ; preds = %if.else9.i.i
  %l_G.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %5 = load ptr, ptr %l_G.i.i, align 8
  %l_registry.i.i = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 20
  br label %index2adr.exit.i

sw.bb10.i.i:                                      ; preds = %if.else9.i.i
  %ci.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %6 = load ptr, ptr %ci.i.i, align 8
  %func11.i.i = getelementptr inbounds %struct.CallInfo, ptr %6, i64 0, i32 1
  %7 = load ptr, ptr %func11.i.i, align 8
  %8 = load ptr, ptr %7, align 8
  %env.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23
  %env12.i.i = getelementptr inbounds %struct.CClosure, ptr %8, i64 0, i32 6
  %9 = load ptr, ptr %env12.i.i, align 8
  store ptr %9, ptr %env.i.i, align 8
  %tt.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23, i32 1
  store i32 5, ptr %tt.i.i, align 8
  br label %index2adr.exit.i

sw.bb15.i.i:                                      ; preds = %if.else9.i.i
  %l_gt.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 22
  br label %index2adr.exit.i

sw.default.i.i:                                   ; preds = %if.else9.i.i
  %ci17.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %10 = load ptr, ptr %ci17.i.i, align 8
  %func18.i.i = getelementptr inbounds %struct.CallInfo, ptr %10, i64 0, i32 1
  %11 = load ptr, ptr %func18.i.i, align 8
  %12 = load ptr, ptr %11, align 8
  %sub20.i.i = sub nuw nsw i32 -10002, %narg
  %nupvalues.i.i = getelementptr inbounds %struct.CClosure, ptr %12, i64 0, i32 4
  %13 = load i8, ptr %nupvalues.i.i, align 1
  %conv.i.i = zext i8 %13 to i32
  %cmp21.not.i.i = icmp ugt i32 %sub20.i.i, %conv.i.i
  %sub23.i.i = sub nuw nsw i32 -10003, %narg
  %idxprom.i.i = zext nneg i32 %sub23.i.i to i64
  %arrayidx.i.i = getelementptr inbounds %struct.CClosure, ptr %12, i64 0, i32 8, i64 %idxprom.i.i
  br i1 %cmp21.not.i.i, label %lua_typename.exit, label %index2adr.exit.i

index2adr.exit.i:                                 ; preds = %sw.default.i.i, %sw.bb15.i.i, %sw.bb10.i.i, %sw.bb.i.i, %if.then5.i.i, %if.then.i.i
  %retval.0.i.i = phi ptr [ %add.ptr8.i.i, %if.then5.i.i ], [ %arrayidx.i.i, %sw.default.i.i ], [ %l_gt.i.i, %sw.bb15.i.i ], [ %env.i.i, %sw.bb10.i.i ], [ %l_registry.i.i, %sw.bb.i.i ], [ %add.ptr.i.i, %if.then.i.i ]
  %cmp.i = icmp eq ptr %retval.0.i.i, @luaO_nilobject_
  br i1 %cmp.i, label %lua_typename.exit, label %lua_type.exit

lua_type.exit:                                    ; preds = %index2adr.exit.i
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i.i, i64 0, i32 1
  %14 = load i32, ptr %tt.i, align 8
  %cmp.i5 = icmp eq i32 %14, -1
  br i1 %cmp.i5, label %lua_typename.exit, label %cond.false.i6

cond.false.i6:                                    ; preds = %lua_type.exit
  %idxprom.i = sext i32 %14 to i64
  %arrayidx.i = getelementptr inbounds [11 x ptr], ptr @luaT_typenames, i64 0, i64 %idxprom.i
  %15 = load ptr, ptr %arrayidx.i, align 8
  br label %lua_typename.exit

lua_typename.exit:                                ; preds = %sw.default.i.i, %if.then.i.i, %index2adr.exit.i, %lua_type.exit, %cond.false.i6
  %cond.i7 = phi ptr [ %15, %cond.false.i6 ], [ @.str.131, %lua_type.exit ], [ @.str.131, %index2adr.exit.i ], [ @.str.131, %if.then.i.i ], [ @.str.131, %sw.default.i.i ]
  %call2 = tail call ptr (ptr, ptr, ...) @lua_pushfstring(ptr noundef %L, ptr noundef nonnull @.str.130, ptr noundef %tname, ptr noundef %cond.i7)
  tail call fastcc void @luaL_argerror(ptr noundef %L, i32 noundef %narg, ptr noundef %call2)
  unreachable
}

; Function Attrs: nounwind uwtable
define internal fastcc i64 @luaL_optinteger(ptr noundef %L, i32 noundef %narg, i64 noundef %def) unnamed_addr #0 {
entry:
  %cmp.i.i = icmp sgt i32 %narg, 0
  br i1 %cmp.i.i, label %if.then.i.i, label %if.else3.i.i

if.then.i.i:                                      ; preds = %entry
  %base.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i, align 8
  %1 = zext nneg i32 %narg to i64
  %2 = getelementptr %struct.lua_TValue, ptr %0, i64 %1
  %add.ptr.i.i = getelementptr %struct.lua_TValue, ptr %2, i64 -1
  %top.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %3 = load ptr, ptr %top.i.i, align 8
  %cmp1.not.i.i = icmp ult ptr %add.ptr.i.i, %3
  br i1 %cmp1.not.i.i, label %index2adr.exit.i, label %cond.end

if.else3.i.i:                                     ; preds = %entry
  %cmp4.i.i = icmp sgt i32 %narg, -10000
  br i1 %cmp4.i.i, label %if.then5.i.i, label %if.else9.i.i

if.then5.i.i:                                     ; preds = %if.else3.i.i
  %top6.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %4 = load ptr, ptr %top6.i.i, align 8
  %idx.ext7.i.i = sext i32 %narg to i64
  %add.ptr8.i.i = getelementptr inbounds %struct.lua_TValue, ptr %4, i64 %idx.ext7.i.i
  br label %index2adr.exit.i

if.else9.i.i:                                     ; preds = %if.else3.i.i
  switch i32 %narg, label %sw.default.i.i [
    i32 -10000, label %sw.bb.i.i
    i32 -10001, label %sw.bb10.i.i
    i32 -10002, label %sw.bb15.i.i
  ]

sw.bb.i.i:                                        ; preds = %if.else9.i.i
  %l_G.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %5 = load ptr, ptr %l_G.i.i, align 8
  %l_registry.i.i = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 20
  br label %index2adr.exit.i

sw.bb10.i.i:                                      ; preds = %if.else9.i.i
  %ci.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %6 = load ptr, ptr %ci.i.i, align 8
  %func11.i.i = getelementptr inbounds %struct.CallInfo, ptr %6, i64 0, i32 1
  %7 = load ptr, ptr %func11.i.i, align 8
  %8 = load ptr, ptr %7, align 8
  %env.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23
  %env12.i.i = getelementptr inbounds %struct.CClosure, ptr %8, i64 0, i32 6
  %9 = load ptr, ptr %env12.i.i, align 8
  store ptr %9, ptr %env.i.i, align 8
  %tt.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23, i32 1
  store i32 5, ptr %tt.i.i, align 8
  br label %index2adr.exit.i

sw.bb15.i.i:                                      ; preds = %if.else9.i.i
  %l_gt.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 22
  br label %index2adr.exit.i

sw.default.i.i:                                   ; preds = %if.else9.i.i
  %ci17.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %10 = load ptr, ptr %ci17.i.i, align 8
  %func18.i.i = getelementptr inbounds %struct.CallInfo, ptr %10, i64 0, i32 1
  %11 = load ptr, ptr %func18.i.i, align 8
  %12 = load ptr, ptr %11, align 8
  %sub20.i.i = sub nuw nsw i32 -10002, %narg
  %nupvalues.i.i = getelementptr inbounds %struct.CClosure, ptr %12, i64 0, i32 4
  %13 = load i8, ptr %nupvalues.i.i, align 1
  %conv.i.i = zext i8 %13 to i32
  %cmp21.not.i.i = icmp ugt i32 %sub20.i.i, %conv.i.i
  %sub23.i.i = sub nuw nsw i32 -10003, %narg
  %idxprom.i.i = zext nneg i32 %sub23.i.i to i64
  %arrayidx.i.i = getelementptr inbounds %struct.CClosure, ptr %12, i64 0, i32 8, i64 %idxprom.i.i
  br i1 %cmp21.not.i.i, label %cond.end, label %index2adr.exit.i

index2adr.exit.i:                                 ; preds = %sw.default.i.i, %sw.bb15.i.i, %sw.bb10.i.i, %sw.bb.i.i, %if.then5.i.i, %if.then.i.i
  %retval.0.i.i = phi ptr [ %add.ptr8.i.i, %if.then5.i.i ], [ %arrayidx.i.i, %sw.default.i.i ], [ %l_gt.i.i, %sw.bb15.i.i ], [ %env.i.i, %sw.bb10.i.i ], [ %l_registry.i.i, %sw.bb.i.i ], [ %add.ptr.i.i, %if.then.i.i ]
  %cmp.i = icmp eq ptr %retval.0.i.i, @luaO_nilobject_
  br i1 %cmp.i, label %cond.end, label %lua_type.exit

lua_type.exit:                                    ; preds = %index2adr.exit.i
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i.i, i64 0, i32 1
  %14 = load i32, ptr %tt.i, align 8
  %cmp = icmp slt i32 %14, 1
  br i1 %cmp, label %cond.end, label %cond.false

cond.false:                                       ; preds = %lua_type.exit
  %call.i = tail call fastcc i64 @lua_tointeger(ptr noundef %L, i32 noundef %narg)
  %cmp.i3 = icmp eq i64 %call.i, 0
  br i1 %cmp.i3, label %land.lhs.true.i, label %cond.end

land.lhs.true.i:                                  ; preds = %cond.false
  %call1.i = tail call fastcc i32 @lua_isnumber(ptr noundef %L, i32 noundef %narg), !range !23
  %tobool.not.i = icmp eq i32 %call1.i, 0
  br i1 %tobool.not.i, label %if.then.i, label %cond.end

if.then.i:                                        ; preds = %land.lhs.true.i
  tail call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef %narg, ptr noundef nonnull @.str.24)
  unreachable

cond.end:                                         ; preds = %sw.default.i.i, %if.then.i.i, %index2adr.exit.i, %land.lhs.true.i, %cond.false, %lua_type.exit
  %cond = phi i64 [ %def, %lua_type.exit ], [ %call.i, %cond.false ], [ 0, %land.lhs.true.i ], [ %def, %index2adr.exit.i ], [ %def, %if.then.i.i ], [ %def, %sw.default.i.i ]
  ret i64 %cond
}

; Function Attrs: nofree nounwind uwtable
define internal fastcc i64 @lua_tointeger(ptr nocapture noundef %L, i32 noundef %idx) unnamed_addr #21 {
entry:
  %endptr.i.i = alloca ptr, align 8
  %cmp.i = icmp sgt i32 %idx, 0
  br i1 %cmp.i, label %if.then.i, label %if.else3.i

if.then.i:                                        ; preds = %entry
  %base.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i, align 8
  %1 = zext nneg i32 %idx to i64
  %2 = getelementptr %struct.lua_TValue, ptr %0, i64 %1
  %add.ptr.i = getelementptr %struct.lua_TValue, ptr %2, i64 -1
  %top.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %3 = load ptr, ptr %top.i, align 8
  %cmp1.not.i = icmp ult ptr %add.ptr.i, %3
  %add.ptr.luaO_nilobject_.i = select i1 %cmp1.not.i, ptr %add.ptr.i, ptr @luaO_nilobject_
  br label %index2adr.exit

if.else3.i:                                       ; preds = %entry
  %cmp4.i = icmp sgt i32 %idx, -10000
  br i1 %cmp4.i, label %if.then5.i, label %if.else9.i

if.then5.i:                                       ; preds = %if.else3.i
  %top6.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %4 = load ptr, ptr %top6.i, align 8
  %idx.ext7.i = sext i32 %idx to i64
  %add.ptr8.i = getelementptr inbounds %struct.lua_TValue, ptr %4, i64 %idx.ext7.i
  br label %index2adr.exit

if.else9.i:                                       ; preds = %if.else3.i
  switch i32 %idx, label %sw.default.i [
    i32 -10000, label %sw.bb.i
    i32 -10001, label %sw.bb10.i
    i32 -10002, label %sw.bb15.i
  ]

sw.bb.i:                                          ; preds = %if.else9.i
  %l_G.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %5 = load ptr, ptr %l_G.i, align 8
  %l_registry.i = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 20
  br label %index2adr.exit

sw.bb10.i:                                        ; preds = %if.else9.i
  %ci.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %6 = load ptr, ptr %ci.i, align 8
  %func11.i = getelementptr inbounds %struct.CallInfo, ptr %6, i64 0, i32 1
  %7 = load ptr, ptr %func11.i, align 8
  %8 = load ptr, ptr %7, align 8
  %env.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23
  %env12.i = getelementptr inbounds %struct.CClosure, ptr %8, i64 0, i32 6
  %9 = load ptr, ptr %env12.i, align 8
  store ptr %9, ptr %env.i, align 8
  %tt.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23, i32 1
  store i32 5, ptr %tt.i, align 8
  br label %index2adr.exit

sw.bb15.i:                                        ; preds = %if.else9.i
  %l_gt.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 22
  br label %index2adr.exit

sw.default.i:                                     ; preds = %if.else9.i
  %ci17.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %10 = load ptr, ptr %ci17.i, align 8
  %func18.i = getelementptr inbounds %struct.CallInfo, ptr %10, i64 0, i32 1
  %11 = load ptr, ptr %func18.i, align 8
  %12 = load ptr, ptr %11, align 8
  %sub20.i = sub nuw nsw i32 -10002, %idx
  %nupvalues.i = getelementptr inbounds %struct.CClosure, ptr %12, i64 0, i32 4
  %13 = load i8, ptr %nupvalues.i, align 1
  %conv.i = zext i8 %13 to i32
  %cmp21.not.i = icmp ugt i32 %sub20.i, %conv.i
  %sub23.i = sub nuw nsw i32 -10003, %idx
  %idxprom.i = zext nneg i32 %sub23.i to i64
  %arrayidx.i = getelementptr inbounds %struct.CClosure, ptr %12, i64 0, i32 8, i64 %idxprom.i
  %cond.i = select i1 %cmp21.not.i, ptr @luaO_nilobject_, ptr %arrayidx.i
  br label %index2adr.exit

index2adr.exit:                                   ; preds = %if.then.i, %if.then5.i, %sw.bb.i, %sw.bb10.i, %sw.bb15.i, %sw.default.i
  %retval.0.i = phi ptr [ %add.ptr8.i, %if.then5.i ], [ %cond.i, %sw.default.i ], [ %l_gt.i, %sw.bb15.i ], [ %env.i, %sw.bb10.i ], [ %l_registry.i, %sw.bb.i ], [ %add.ptr.luaO_nilobject_.i, %if.then.i ]
  %tt = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i, i64 0, i32 1
  %14 = load i32, ptr %tt, align 8
  switch i32 %14, label %return [
    i32 3, label %index2adr.exit.if.then_crit_edge
    i32 4, label %land.lhs.true.i
  ]

index2adr.exit.if.then_crit_edge:                 ; preds = %index2adr.exit
  %.pre = load double, ptr %retval.0.i, align 8
  br label %if.then

land.lhs.true.i:                                  ; preds = %index2adr.exit
  %15 = load ptr, ptr %retval.0.i, align 8
  %add.ptr.i4 = getelementptr inbounds %union.TString, ptr %15, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i)
  %call.i.i = call double @strtod(ptr noundef nonnull %add.ptr.i4, ptr noundef nonnull %endptr.i.i) #35
  %16 = load ptr, ptr %endptr.i.i, align 8
  %cmp.i.i = icmp eq ptr %16, %add.ptr.i4
  br i1 %cmp.i.i, label %luaO_str2d.exit.thread.i, label %if.end.i.i

luaO_str2d.exit.thread.i:                         ; preds = %land.lhs.true.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i)
  br label %return

if.end.i.i:                                       ; preds = %land.lhs.true.i
  %17 = load i8, ptr %16, align 1
  switch i8 %17, label %if.end9.i.i [
    i8 120, label %if.then6.i.i
    i8 88, label %if.then6.i.i
  ]

if.then6.i.i:                                     ; preds = %if.end.i.i, %if.end.i.i
  %call7.i.i = call i64 @strtoul(ptr noundef nonnull %add.ptr.i4, ptr noundef nonnull %endptr.i.i, i32 noundef 16) #35
  %conv8.i.i = uitofp i64 %call7.i.i to double
  %.pre.i.i = load ptr, ptr %endptr.i.i, align 8
  %.pre5.i.i = load i8, ptr %.pre.i.i, align 1
  br label %if.end9.i.i

if.end9.i.i:                                      ; preds = %if.then6.i.i, %if.end.i.i
  %num.0.i = phi double [ %call.i.i, %if.end.i.i ], [ %conv8.i.i, %if.then6.i.i ]
  %18 = phi i8 [ %17, %if.end.i.i ], [ %.pre5.i.i, %if.then6.i.i ]
  %endptr.promoted.i.i = phi ptr [ %16, %if.end.i.i ], [ %.pre.i.i, %if.then6.i.i ]
  %cmp11.i.i = icmp eq i8 %18, 0
  br i1 %cmp11.i.i, label %luaO_str2d.exit.thread9.i, label %while.cond.preheader.i.i

luaO_str2d.exit.thread9.i:                        ; preds = %if.end9.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i)
  br label %if.then

while.cond.preheader.i.i:                         ; preds = %if.end9.i.i
  %call15.i.i = tail call ptr @__ctype_b_loc() #39
  %19 = load ptr, ptr %call15.i.i, align 8
  br label %while.cond.i.i

while.cond.i.i:                                   ; preds = %while.cond.i.i, %while.cond.preheader.i.i
  %incdec.ptr4.i.i = phi ptr [ %endptr.promoted.i.i, %while.cond.preheader.i.i ], [ %incdec.ptr.i.i, %while.cond.i.i ]
  %20 = load i8, ptr %incdec.ptr4.i.i, align 1
  %idxprom.i.i = zext i8 %20 to i64
  %arrayidx.i.i = getelementptr inbounds i16, ptr %19, i64 %idxprom.i.i
  %21 = load i16, ptr %arrayidx.i.i, align 2
  %22 = and i16 %21, 8192
  %tobool.not.i.i = icmp eq i16 %22, 0
  %incdec.ptr.i.i = getelementptr inbounds i8, ptr %incdec.ptr4.i.i, i64 1
  br i1 %tobool.not.i.i, label %luaO_str2d.exit.i, label %while.cond.i.i, !llvm.loop !35

luaO_str2d.exit.i:                                ; preds = %while.cond.i.i
  %cmp19.not.i.not.i = icmp eq i8 %20, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i)
  br i1 %cmp19.not.i.not.i, label %if.then, label %return

if.then:                                          ; preds = %luaO_str2d.exit.thread9.i, %luaO_str2d.exit.i, %index2adr.exit.if.then_crit_edge
  %23 = phi double [ %.pre, %index2adr.exit.if.then_crit_edge ], [ %num.0.i, %luaO_str2d.exit.i ], [ %num.0.i, %luaO_str2d.exit.thread9.i ]
  %conv = fptosi double %23 to i64
  br label %return

return:                                           ; preds = %index2adr.exit, %luaO_str2d.exit.i, %luaO_str2d.exit.thread.i, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ 0, %luaO_str2d.exit.thread.i ], [ 0, %luaO_str2d.exit.i ], [ 0, %index2adr.exit ]
  ret i64 %retval.0
}

; Function Attrs: nofree nounwind uwtable
define internal fastcc i32 @lua_isnumber(ptr nocapture noundef %L, i32 noundef %idx) unnamed_addr #21 {
entry:
  %endptr.i.i = alloca ptr, align 8
  %cmp.i = icmp sgt i32 %idx, 0
  br i1 %cmp.i, label %if.then.i, label %if.else3.i

if.then.i:                                        ; preds = %entry
  %base.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i, align 8
  %1 = zext nneg i32 %idx to i64
  %2 = getelementptr %struct.lua_TValue, ptr %0, i64 %1
  %add.ptr.i = getelementptr %struct.lua_TValue, ptr %2, i64 -1
  %top.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %3 = load ptr, ptr %top.i, align 8
  %cmp1.not.i = icmp ult ptr %add.ptr.i, %3
  %add.ptr.luaO_nilobject_.i = select i1 %cmp1.not.i, ptr %add.ptr.i, ptr @luaO_nilobject_
  br label %index2adr.exit

if.else3.i:                                       ; preds = %entry
  %cmp4.i = icmp sgt i32 %idx, -10000
  br i1 %cmp4.i, label %if.then5.i, label %if.else9.i

if.then5.i:                                       ; preds = %if.else3.i
  %top6.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %4 = load ptr, ptr %top6.i, align 8
  %idx.ext7.i = sext i32 %idx to i64
  %add.ptr8.i = getelementptr inbounds %struct.lua_TValue, ptr %4, i64 %idx.ext7.i
  br label %index2adr.exit

if.else9.i:                                       ; preds = %if.else3.i
  switch i32 %idx, label %sw.default.i [
    i32 -10000, label %sw.bb.i
    i32 -10001, label %sw.bb10.i
    i32 -10002, label %sw.bb15.i
  ]

sw.bb.i:                                          ; preds = %if.else9.i
  %l_G.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %5 = load ptr, ptr %l_G.i, align 8
  %l_registry.i = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 20
  br label %index2adr.exit

sw.bb10.i:                                        ; preds = %if.else9.i
  %ci.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %6 = load ptr, ptr %ci.i, align 8
  %func11.i = getelementptr inbounds %struct.CallInfo, ptr %6, i64 0, i32 1
  %7 = load ptr, ptr %func11.i, align 8
  %8 = load ptr, ptr %7, align 8
  %env.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23
  %env12.i = getelementptr inbounds %struct.CClosure, ptr %8, i64 0, i32 6
  %9 = load ptr, ptr %env12.i, align 8
  store ptr %9, ptr %env.i, align 8
  %tt.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23, i32 1
  store i32 5, ptr %tt.i, align 8
  br label %index2adr.exit

sw.bb15.i:                                        ; preds = %if.else9.i
  %l_gt.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 22
  br label %index2adr.exit

sw.default.i:                                     ; preds = %if.else9.i
  %ci17.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %10 = load ptr, ptr %ci17.i, align 8
  %func18.i = getelementptr inbounds %struct.CallInfo, ptr %10, i64 0, i32 1
  %11 = load ptr, ptr %func18.i, align 8
  %12 = load ptr, ptr %11, align 8
  %sub20.i = sub nuw nsw i32 -10002, %idx
  %nupvalues.i = getelementptr inbounds %struct.CClosure, ptr %12, i64 0, i32 4
  %13 = load i8, ptr %nupvalues.i, align 1
  %conv.i = zext i8 %13 to i32
  %cmp21.not.i = icmp ugt i32 %sub20.i, %conv.i
  %sub23.i = sub nuw nsw i32 -10003, %idx
  %idxprom.i = zext nneg i32 %sub23.i to i64
  %arrayidx.i = getelementptr inbounds %struct.CClosure, ptr %12, i64 0, i32 8, i64 %idxprom.i
  %cond.i = select i1 %cmp21.not.i, ptr @luaO_nilobject_, ptr %arrayidx.i
  br label %index2adr.exit

index2adr.exit:                                   ; preds = %if.then.i, %if.then5.i, %sw.bb.i, %sw.bb10.i, %sw.bb15.i, %sw.default.i
  %retval.0.i = phi ptr [ %add.ptr8.i, %if.then5.i ], [ %cond.i, %sw.default.i ], [ %l_gt.i, %sw.bb15.i ], [ %env.i, %sw.bb10.i ], [ %l_registry.i, %sw.bb.i ], [ %add.ptr.luaO_nilobject_.i, %if.then.i ]
  %tt = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i, i64 0, i32 1
  %14 = load i32, ptr %tt, align 8
  switch i32 %14, label %luaV_tonumber.exit [
    i32 3, label %lor.end
    i32 4, label %land.lhs.true.i
  ]

land.lhs.true.i:                                  ; preds = %index2adr.exit
  %15 = load ptr, ptr %retval.0.i, align 8
  %add.ptr.i3 = getelementptr inbounds %union.TString, ptr %15, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i)
  %call.i.i = call double @strtod(ptr noundef nonnull %add.ptr.i3, ptr noundef nonnull %endptr.i.i) #35
  %16 = load ptr, ptr %endptr.i.i, align 8
  %cmp.i.i = icmp eq ptr %16, %add.ptr.i3
  br i1 %cmp.i.i, label %luaO_str2d.exit.thread.i, label %if.end.i.i

luaO_str2d.exit.thread.i:                         ; preds = %land.lhs.true.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i)
  br label %lor.end

if.end.i.i:                                       ; preds = %land.lhs.true.i
  %17 = load i8, ptr %16, align 1
  switch i8 %17, label %if.end9.i.i [
    i8 120, label %if.then6.i.i
    i8 88, label %if.then6.i.i
  ]

if.then6.i.i:                                     ; preds = %if.end.i.i, %if.end.i.i
  %call7.i.i = call i64 @strtoul(ptr noundef nonnull %add.ptr.i3, ptr noundef nonnull %endptr.i.i, i32 noundef 16) #35
  %.pre.i.i = load ptr, ptr %endptr.i.i, align 8
  %.pre5.i.i = load i8, ptr %.pre.i.i, align 1
  br label %if.end9.i.i

if.end9.i.i:                                      ; preds = %if.then6.i.i, %if.end.i.i
  %18 = phi i8 [ %17, %if.end.i.i ], [ %.pre5.i.i, %if.then6.i.i ]
  %endptr.promoted.i.i = phi ptr [ %16, %if.end.i.i ], [ %.pre.i.i, %if.then6.i.i ]
  %cmp11.i.i = icmp eq i8 %18, 0
  br i1 %cmp11.i.i, label %luaO_str2d.exit.thread9.i, label %while.cond.preheader.i.i

luaO_str2d.exit.thread9.i:                        ; preds = %if.end9.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i)
  br label %if.then3.i

while.cond.preheader.i.i:                         ; preds = %if.end9.i.i
  %call15.i.i = tail call ptr @__ctype_b_loc() #39
  %19 = load ptr, ptr %call15.i.i, align 8
  br label %while.cond.i.i

while.cond.i.i:                                   ; preds = %while.cond.i.i, %while.cond.preheader.i.i
  %incdec.ptr4.i.i = phi ptr [ %endptr.promoted.i.i, %while.cond.preheader.i.i ], [ %incdec.ptr.i.i, %while.cond.i.i ]
  %20 = load i8, ptr %incdec.ptr4.i.i, align 1
  %idxprom.i.i = zext i8 %20 to i64
  %arrayidx.i.i = getelementptr inbounds i16, ptr %19, i64 %idxprom.i.i
  %21 = load i16, ptr %arrayidx.i.i, align 2
  %22 = and i16 %21, 8192
  %tobool.not.i.i = icmp eq i16 %22, 0
  %incdec.ptr.i.i = getelementptr inbounds i8, ptr %incdec.ptr4.i.i, i64 1
  br i1 %tobool.not.i.i, label %luaO_str2d.exit.i, label %while.cond.i.i, !llvm.loop !35

luaO_str2d.exit.i:                                ; preds = %while.cond.i.i
  %cmp19.not.i.not.i = icmp eq i8 %20, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i)
  br i1 %cmp19.not.i.not.i, label %if.then3.i, label %lor.end

if.then3.i:                                       ; preds = %luaO_str2d.exit.i, %luaO_str2d.exit.thread9.i
  br label %lor.end

luaV_tonumber.exit:                               ; preds = %index2adr.exit
  br label %lor.end

lor.end:                                          ; preds = %if.then3.i, %luaO_str2d.exit.i, %luaO_str2d.exit.thread.i, %index2adr.exit, %luaV_tonumber.exit
  %lor.ext = phi i32 [ 1, %index2adr.exit ], [ 1, %if.then3.i ], [ 0, %luaO_str2d.exit.i ], [ 0, %luaO_str2d.exit.thread.i ], [ 0, %luaV_tonumber.exit ]
  ret i32 %lor.ext
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite) uwtable
define internal ptr @getS(ptr nocapture readnone %L, ptr nocapture noundef %ud, ptr nocapture noundef writeonly %size) #22 {
entry:
  %size1 = getelementptr inbounds %struct.LoadS, ptr %ud, i64 0, i32 1
  %0 = load i64, ptr %size1, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  store i64 %0, ptr %size, align 8
  store i64 0, ptr %size1, align 8
  %1 = load ptr, ptr %ud, align 8
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi ptr [ %1, %if.end ], [ null, %entry ]
  ret ptr %retval.0
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @luaD_pcall(ptr noundef %L, ptr nocapture noundef readonly %func, ptr noundef %u, i64 noundef %old_top, i64 noundef %ef) unnamed_addr #0 {
entry:
  %nCcalls = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 15
  %0 = load i16, ptr %nCcalls, align 8
  %ci = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %1 = load ptr, ptr %ci, align 8
  %base_ci = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 12
  %2 = load ptr, ptr %base_ci, align 8
  %allowhook = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 18
  %3 = load i8, ptr %allowhook, align 1
  %errfunc = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 27
  %4 = load i64, ptr %errfunc, align 8
  store i64 %ef, ptr %errfunc, align 8
  %call = tail call fastcc i32 @luaD_rawrunprotected(ptr noundef %L, ptr noundef %func, ptr noundef %u)
  %cmp.not = icmp eq i32 %call, 0
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %sub.ptr.lhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %stack = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 10
  %5 = load ptr, ptr %stack, align 8
  %add.ptr = getelementptr inbounds i8, ptr %5, i64 %old_top
  tail call fastcc void @luaF_close(ptr noundef nonnull %L, ptr noundef %add.ptr)
  switch i32 %call, label %luaD_seterrorobj.exit [
    i32 4, label %sw.bb.i
    i32 5, label %sw.bb1.i
    i32 3, label %sw.bb6.i
    i32 2, label %sw.bb6.i
  ]

sw.bb.i:                                          ; preds = %if.then
  %call.i = tail call fastcc ptr @luaS_newlstr(ptr noundef nonnull %L, ptr noundef nonnull @.str.3, i64 noundef 17)
  store ptr %call.i, ptr %add.ptr, align 8
  br label %sw.epilog.sink.split.i

sw.bb1.i:                                         ; preds = %if.then
  %call3.i = tail call fastcc ptr @luaS_newlstr(ptr noundef nonnull %L, ptr noundef nonnull @.str.4, i64 noundef 23)
  store ptr %call3.i, ptr %add.ptr, align 8
  br label %sw.epilog.sink.split.i

sw.bb6.i:                                         ; preds = %if.then, %if.then
  %top.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %6 = load ptr, ptr %top.i, align 8
  %add.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %6, i64 -1
  %7 = load i64, ptr %add.ptr.i, align 8
  store i64 %7, ptr %add.ptr, align 8
  %tt9.i = getelementptr %struct.lua_TValue, ptr %6, i64 -1, i32 1
  %8 = load i32, ptr %tt9.i, align 8
  br label %sw.epilog.sink.split.i

sw.epilog.sink.split.i:                           ; preds = %sw.bb6.i, %sw.bb1.i, %sw.bb.i
  %.sink.i = phi i32 [ %8, %sw.bb6.i ], [ 4, %sw.bb1.i ], [ 4, %sw.bb.i ]
  %tt10.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr, i64 0, i32 1
  store i32 %.sink.i, ptr %tt10.i, align 8
  br label %luaD_seterrorobj.exit

luaD_seterrorobj.exit:                            ; preds = %if.then, %sw.epilog.sink.split.i
  %add.ptr11.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr, i64 1
  %top12.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  store ptr %add.ptr11.i, ptr %top12.i, align 8
  store i16 %0, ptr %nCcalls, align 8
  %9 = load ptr, ptr %base_ci, align 8
  %add.ptr4 = getelementptr inbounds i8, ptr %9, i64 %sub.ptr.sub
  store ptr %add.ptr4, ptr %ci, align 8
  %10 = load ptr, ptr %add.ptr4, align 8
  %base7 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  store ptr %10, ptr %base7, align 8
  %savedpc = getelementptr inbounds %struct.CallInfo, ptr %add.ptr4, i64 0, i32 3
  %11 = load ptr, ptr %savedpc, align 8
  %savedpc9 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 8
  store ptr %11, ptr %savedpc9, align 8
  store i8 %3, ptr %allowhook, align 1
  %size_ci.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 14
  %12 = load i32, ptr %size_ci.i, align 4
  %cmp.i = icmp sgt i32 %12, 20000
  %sub.ptr.div.i = sdiv exact i64 %sub.ptr.sub, 40
  %conv.i = trunc i64 %sub.ptr.div.i to i32
  %cmp1.i = icmp slt i32 %conv.i, 19999
  %or.cond = select i1 %cmp.i, i1 %cmp1.i, i1 false
  br i1 %or.cond, label %if.then3.i, label %if.end

if.then3.i:                                       ; preds = %luaD_seterrorobj.exit
  tail call fastcc void @luaD_reallocCI(ptr noundef nonnull %L, i32 noundef 20000)
  br label %if.end

if.end:                                           ; preds = %if.then3.i, %luaD_seterrorobj.exit, %entry
  store i64 %4, ptr %errfunc, align 8
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal void @f_parser(ptr noundef %L, ptr noundef %ud) #0 {
entry:
  %size.i.i.i = alloca i64, align 8
  %lexstate.i = alloca %struct.LexState, align 8
  %funcstate.i = alloca %struct.FuncState, align 8
  %l_G = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %0 = load ptr, ptr %l_G, align 8
  %totalbytes = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 14
  %1 = load i64, ptr %totalbytes, align 8
  %GCthreshold = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 13
  %2 = load i64, ptr %GCthreshold, align 8
  %cmp.not = icmp ult i64 %1, %2
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %gcstepmul.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 18
  %3 = load i32, ptr %gcstepmul.i, align 4
  %mul.i = mul i32 %3, 10
  %conv.i = zext i32 %mul.i to i64
  %cmp.i = icmp eq i32 %mul.i, 0
  %spec.store.select.i = select i1 %cmp.i, i64 9223372036854775806, i64 %conv.i
  %sub.i = sub i64 %1, %2
  %gcdept.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 16
  %4 = load i64, ptr %gcdept.i, align 8
  %add.i = add i64 %sub.i, %4
  store i64 %add.i, ptr %gcdept.i, align 8
  %gcstate.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 4
  br label %do.body.i

do.body.i:                                        ; preds = %do.body.i, %if.then
  %lim.0.i = phi i64 [ %spec.store.select.i, %if.then ], [ %sub2.i, %do.body.i ]
  %call.i = tail call fastcc i64 @singlestep(ptr noundef %L)
  %sub2.i = sub nsw i64 %lim.0.i, %call.i
  %5 = load i8, ptr %gcstate.i, align 1
  %cmp4.i = icmp ne i8 %5, 0
  %cmp8.i = icmp sgt i64 %sub2.i, 0
  %or.cond.i = select i1 %cmp4.i, i1 %cmp8.i, i1 false
  br i1 %or.cond.i, label %do.body.i, label %do.end.i, !llvm.loop !6

do.end.i:                                         ; preds = %do.body.i
  br i1 %cmp4.i, label %if.then14.i, label %if.else27.i

if.then14.i:                                      ; preds = %do.end.i
  %6 = load i64, ptr %gcdept.i, align 8
  %cmp16.i = icmp ult i64 %6, 1024
  br i1 %cmp16.i, label %if.then18.i, label %if.else.i

if.then18.i:                                      ; preds = %if.then14.i
  %7 = load i64, ptr %totalbytes, align 8
  %add20.i = add i64 %7, 1024
  br label %luaC_step.exit

if.else.i:                                        ; preds = %if.then14.i
  %sub23.i = add i64 %6, -1024
  store i64 %sub23.i, ptr %gcdept.i, align 8
  %8 = load i64, ptr %totalbytes, align 8
  br label %luaC_step.exit

if.else27.i:                                      ; preds = %do.end.i
  %estimate.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 15
  %9 = load i64, ptr %estimate.i, align 8
  %div.i = udiv i64 %9, 100
  %gcpause.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 17
  %10 = load i32, ptr %gcpause.i, align 8
  %conv28.i = sext i32 %10 to i64
  %mul29.i = mul i64 %div.i, %conv28.i
  br label %luaC_step.exit

luaC_step.exit:                                   ; preds = %if.then18.i, %if.else.i, %if.else27.i
  %add20.sink.i = phi i64 [ %add20.i, %if.then18.i ], [ %8, %if.else.i ], [ %mul29.i, %if.else27.i ]
  store i64 %add20.sink.i, ptr %GCthreshold, align 8
  br label %if.end

if.end:                                           ; preds = %luaC_step.exit, %entry
  %11 = load ptr, ptr %ud, align 8
  %buff = getelementptr inbounds %struct.SParser, ptr %ud, i64 0, i32 1
  %name = getelementptr inbounds %struct.SParser, ptr %ud, i64 0, i32 2
  %12 = load ptr, ptr %name, align 8
  call void @llvm.lifetime.start.p0(i64 96, ptr nonnull %lexstate.i)
  call void @llvm.lifetime.start.p0(i64 600, ptr nonnull %funcstate.i)
  %buff1.i = getelementptr inbounds %struct.LexState, ptr %lexstate.i, i64 0, i32 8
  store ptr %buff, ptr %buff1.i, align 8
  %call.i21 = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %12) #34
  %call2.i = tail call fastcc ptr @luaS_newlstr(ptr noundef %L, ptr noundef %12, i64 noundef %call.i21)
  %decpoint.i.i = getelementptr inbounds %struct.LexState, ptr %lexstate.i, i64 0, i32 10
  store i8 46, ptr %decpoint.i.i, align 8
  %L1.i.i = getelementptr inbounds %struct.LexState, ptr %lexstate.i, i64 0, i32 6
  store ptr %L, ptr %L1.i.i, align 8
  %lookahead.i.i = getelementptr inbounds %struct.LexState, ptr %lexstate.i, i64 0, i32 4
  store i32 287, ptr %lookahead.i.i, align 8
  %z2.i.i = getelementptr inbounds %struct.LexState, ptr %lexstate.i, i64 0, i32 7
  store ptr %11, ptr %z2.i.i, align 8
  %fs.i.i = getelementptr inbounds %struct.LexState, ptr %lexstate.i, i64 0, i32 5
  store ptr null, ptr %fs.i.i, align 8
  %linenumber.i.i = getelementptr inbounds %struct.LexState, ptr %lexstate.i, i64 0, i32 1
  store i32 1, ptr %linenumber.i.i, align 4
  %lastline.i.i = getelementptr inbounds %struct.LexState, ptr %lexstate.i, i64 0, i32 2
  store i32 1, ptr %lastline.i.i, align 8
  %source3.i.i = getelementptr inbounds %struct.LexState, ptr %lexstate.i, i64 0, i32 9
  store ptr %call2.i, ptr %source3.i.i, align 8
  %13 = load ptr, ptr %buff, align 8
  %buffsize.i.i = getelementptr inbounds %struct.SParser, ptr %ud, i64 0, i32 1, i32 2
  %14 = load i64, ptr %buffsize.i.i, align 8
  %15 = load ptr, ptr %l_G, align 8
  %frealloc.i.i.i = getelementptr inbounds %struct.global_State, ptr %15, i64 0, i32 1
  %16 = load ptr, ptr %frealloc.i.i.i, align 8
  %ud.i.i.i = getelementptr inbounds %struct.global_State, ptr %15, i64 0, i32 2
  %17 = load ptr, ptr %ud.i.i.i, align 8
  %call.i.i.i = tail call ptr %16(ptr noundef %17, ptr noundef %13, i64 noundef %14, i64 noundef 32) #35
  %cmp.i.i.i = icmp eq ptr %call.i.i.i, null
  br i1 %cmp.i.i.i, label %if.then.i.i.i, label %luaM_realloc_.exit.i.i

if.then.i.i.i:                                    ; preds = %if.end
  %errorJmp.i.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 26
  %18 = load ptr, ptr %errorJmp.i.i.i.i, align 8
  %tobool.not.i.i.i.i = icmp eq ptr %18, null
  br i1 %tobool.not.i.i.i.i, label %if.else.i.i.i.i, label %if.then.i.i.i.i

if.then.i.i.i.i:                                  ; preds = %if.then.i.i.i
  %status.i.i.i.i = getelementptr inbounds %struct.lua_longjmp, ptr %18, i64 0, i32 2
  store volatile i32 4, ptr %status.i.i.i.i, align 8
  %19 = load ptr, ptr %errorJmp.i.i.i.i, align 8
  %b.i.i.i.i = getelementptr inbounds %struct.lua_longjmp, ptr %19, i64 0, i32 1
  tail call void @longjmp(ptr noundef nonnull %b.i.i.i.i, i32 noundef 1) #38
  unreachable

if.else.i.i.i.i:                                  ; preds = %if.then.i.i.i
  %status3.i.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 3
  store i8 4, ptr %status3.i.i.i.i, align 2
  %20 = load ptr, ptr %l_G, align 8
  %panic.i.i.i.i = getelementptr inbounds %struct.global_State, ptr %20, i64 0, i32 19
  %21 = load ptr, ptr %panic.i.i.i.i, align 8
  %tobool4.not.i.i.i.i = icmp eq ptr %21, null
  br i1 %tobool4.not.i.i.i.i, label %if.end.i.i.i.i, label %if.then5.i.i.i.i

if.then5.i.i.i.i:                                 ; preds = %if.else.i.i.i.i
  tail call fastcc void @resetstack(ptr noundef nonnull %L, i32 noundef 4)
  %22 = load ptr, ptr %l_G, align 8
  %panic7.i.i.i.i = getelementptr inbounds %struct.global_State, ptr %22, i64 0, i32 19
  %23 = load ptr, ptr %panic7.i.i.i.i, align 8
  %call.i.i.i.i = tail call i32 %23(ptr noundef nonnull %L) #35
  br label %if.end.i.i.i.i

if.end.i.i.i.i:                                   ; preds = %if.then5.i.i.i.i, %if.else.i.i.i.i
  tail call void @exit(i32 noundef 1) #38
  unreachable

luaM_realloc_.exit.i.i:                           ; preds = %if.end
  %totalbytes.i.i.i = getelementptr inbounds %struct.global_State, ptr %15, i64 0, i32 14
  %24 = load i64, ptr %totalbytes.i.i.i, align 8
  %reass.sub = sub i64 %24, %14
  %add.i.i.i = add i64 %reass.sub, 32
  store i64 %add.i.i.i, ptr %totalbytes.i.i.i, align 8
  store ptr %call.i.i.i, ptr %buff, align 8
  store i64 32, ptr %buffsize.i.i, align 8
  %25 = load i64, ptr %11, align 8
  %dec.i.i = add i64 %25, -1
  store i64 %dec.i.i, ptr %11, align 8
  %cmp.not.i.i = icmp eq i64 %25, 0
  br i1 %cmp.not.i.i, label %cond.false.i.i, label %cond.true.i.i

cond.true.i.i:                                    ; preds = %luaM_realloc_.exit.i.i
  %p.i.i = getelementptr inbounds %struct.Zio, ptr %11, i64 0, i32 1
  %26 = load ptr, ptr %p.i.i, align 8
  %incdec.ptr.i.i = getelementptr inbounds i8, ptr %26, i64 1
  store ptr %incdec.ptr.i.i, ptr %p.i.i, align 8
  %27 = load i8, ptr %26, align 1
  %conv.i.i = zext i8 %27 to i32
  br label %luaX_setinput.exit.i

cond.false.i.i:                                   ; preds = %luaM_realloc_.exit.i.i
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %size.i.i.i)
  %L1.i.i.i = getelementptr inbounds %struct.Zio, ptr %11, i64 0, i32 4
  %28 = load ptr, ptr %L1.i.i.i, align 8
  %reader.i.i.i = getelementptr inbounds %struct.Zio, ptr %11, i64 0, i32 2
  %29 = load ptr, ptr %reader.i.i.i, align 8
  %data.i.i.i = getelementptr inbounds %struct.Zio, ptr %11, i64 0, i32 3
  %30 = load ptr, ptr %data.i.i.i, align 8
  %call.i17.i.i = call ptr %29(ptr noundef %28, ptr noundef %30, ptr noundef nonnull %size.i.i.i) #35
  %cmp.i18.i.i = icmp eq ptr %call.i17.i.i, null
  %31 = load i64, ptr %size.i.i.i, align 8
  %cmp2.i.i.i = icmp eq i64 %31, 0
  %or.cond.i.i.i = select i1 %cmp.i18.i.i, i1 true, i1 %cmp2.i.i.i
  br i1 %or.cond.i.i.i, label %luaZ_fill.exit.i.i, label %if.end.i.i.i

if.end.i.i.i:                                     ; preds = %cond.false.i.i
  %sub.i19.i.i = add i64 %31, -1
  store i64 %sub.i19.i.i, ptr %11, align 8
  %p.i.i.i = getelementptr inbounds %struct.Zio, ptr %11, i64 0, i32 1
  %incdec.ptr.i.i.i = getelementptr inbounds i8, ptr %call.i17.i.i, i64 1
  store ptr %incdec.ptr.i.i.i, ptr %p.i.i.i, align 8
  %32 = load i8, ptr %call.i17.i.i, align 1
  %conv.i.i.i = zext i8 %32 to i32
  br label %luaZ_fill.exit.i.i

luaZ_fill.exit.i.i:                               ; preds = %if.end.i.i.i, %cond.false.i.i
  %retval.0.i.i.i = phi i32 [ %conv.i.i.i, %if.end.i.i.i ], [ -1, %cond.false.i.i ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %size.i.i.i)
  br label %luaX_setinput.exit.i

luaX_setinput.exit.i:                             ; preds = %luaZ_fill.exit.i.i, %cond.true.i.i
  %cond.i.i = phi i32 [ %conv.i.i, %cond.true.i.i ], [ %retval.0.i.i.i, %luaZ_fill.exit.i.i ]
  store i32 %cond.i.i, ptr %lexstate.i, align 8
  call fastcc void @open_func(ptr noundef nonnull %lexstate.i, ptr noundef nonnull %funcstate.i)
  %33 = load ptr, ptr %funcstate.i, align 8
  %is_vararg.i = getelementptr inbounds %struct.Proto, ptr %33, i64 0, i32 21
  store i8 2, ptr %is_vararg.i, align 2
  %34 = load i32, ptr %linenumber.i.i, align 4
  store i32 %34, ptr %lastline.i.i, align 8
  %35 = load i32, ptr %lookahead.i.i, align 8
  %cmp.not.i6.i = icmp eq i32 %35, 287
  %t4.i.i = getelementptr inbounds %struct.LexState, ptr %lexstate.i, i64 0, i32 3
  br i1 %cmp.not.i6.i, label %if.else.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %luaX_setinput.exit.i
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t4.i.i, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i.i, align 8
  br label %luaX_next.exit.i

if.else.i.i:                                      ; preds = %luaX_setinput.exit.i
  %seminfo.i.i = getelementptr inbounds %struct.LexState, ptr %lexstate.i, i64 0, i32 3, i32 1
  %call.i.i = call fastcc i32 @llex(ptr noundef nonnull %lexstate.i, ptr noundef nonnull %seminfo.i.i)
  store i32 %call.i.i, ptr %t4.i.i, align 8
  br label %luaX_next.exit.i

luaX_next.exit.i:                                 ; preds = %if.else.i.i, %if.then.i.i
  call fastcc void @chunk(ptr noundef nonnull %lexstate.i)
  %36 = load i32, ptr %t4.i.i, align 8
  %cmp.not.i7.i = icmp eq i32 %36, 287
  br i1 %cmp.not.i7.i, label %luaY_parser.exit, label %if.then.i8.i

if.then.i8.i:                                     ; preds = %luaX_next.exit.i
  %37 = load ptr, ptr %L1.i.i, align 8
  %call1.i.i.i = call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %37, ptr noundef nonnull @.str.164, ptr noundef nonnull @.str.90)
  %38 = load i32, ptr %t4.i.i, align 8
  call fastcc void @luaX_lexerror(ptr noundef nonnull %lexstate.i, ptr noundef %call1.i.i.i, i32 noundef %38)
  unreachable

luaY_parser.exit:                                 ; preds = %luaX_next.exit.i
  call fastcc void @close_func(ptr noundef nonnull %lexstate.i)
  %39 = load ptr, ptr %funcstate.i, align 8
  call void @llvm.lifetime.end.p0(i64 96, ptr nonnull %lexstate.i)
  call void @llvm.lifetime.end.p0(i64 600, ptr nonnull %funcstate.i)
  %nups = getelementptr inbounds %struct.Proto, ptr %39, i64 0, i32 19
  %40 = load i8, ptr %nups, align 8
  %conv = zext i8 %40 to i64
  %l_gt = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 22
  %41 = load ptr, ptr %l_gt, align 8
  %sub.i22 = shl nuw nsw i64 %conv, 3
  %add.i23 = add nuw nsw i64 %sub.i22, 40
  %42 = load ptr, ptr %l_G, align 8
  %frealloc.i.i = getelementptr inbounds %struct.global_State, ptr %42, i64 0, i32 1
  %43 = load ptr, ptr %frealloc.i.i, align 8
  %ud.i.i = getelementptr inbounds %struct.global_State, ptr %42, i64 0, i32 2
  %44 = load ptr, ptr %ud.i.i, align 8
  %call.i.i24 = call ptr %43(ptr noundef %44, ptr noundef null, i64 noundef 0, i64 noundef %add.i23) #35
  %cmp.i.i = icmp eq ptr %call.i.i24, null
  br i1 %cmp.i.i, label %if.then.i.i25, label %luaM_realloc_.exit.i

if.then.i.i25:                                    ; preds = %luaY_parser.exit
  %errorJmp.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 26
  %45 = load ptr, ptr %errorJmp.i.i.i, align 8
  %tobool.not.i.i.i = icmp eq ptr %45, null
  br i1 %tobool.not.i.i.i, label %if.else.i.i.i, label %if.then.i.i.i26

if.then.i.i.i26:                                  ; preds = %if.then.i.i25
  %status.i.i.i = getelementptr inbounds %struct.lua_longjmp, ptr %45, i64 0, i32 2
  store volatile i32 4, ptr %status.i.i.i, align 8
  %46 = load ptr, ptr %errorJmp.i.i.i, align 8
  %b.i.i.i = getelementptr inbounds %struct.lua_longjmp, ptr %46, i64 0, i32 1
  call void @longjmp(ptr noundef nonnull %b.i.i.i, i32 noundef 1) #38
  unreachable

if.else.i.i.i:                                    ; preds = %if.then.i.i25
  %status3.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 3
  store i8 4, ptr %status3.i.i.i, align 2
  %47 = load ptr, ptr %l_G, align 8
  %panic.i.i.i = getelementptr inbounds %struct.global_State, ptr %47, i64 0, i32 19
  %48 = load ptr, ptr %panic.i.i.i, align 8
  %tobool4.not.i.i.i = icmp eq ptr %48, null
  br i1 %tobool4.not.i.i.i, label %if.end.i.i.i28, label %if.then5.i.i.i

if.then5.i.i.i:                                   ; preds = %if.else.i.i.i
  call fastcc void @resetstack(ptr noundef nonnull %L, i32 noundef 4)
  %49 = load ptr, ptr %l_G, align 8
  %panic7.i.i.i = getelementptr inbounds %struct.global_State, ptr %49, i64 0, i32 19
  %50 = load ptr, ptr %panic7.i.i.i, align 8
  %call.i.i.i27 = call i32 %50(ptr noundef nonnull %L) #35
  br label %if.end.i.i.i28

if.end.i.i.i28:                                   ; preds = %if.then5.i.i.i, %if.else.i.i.i
  call void @exit(i32 noundef 1) #38
  unreachable

luaM_realloc_.exit.i:                             ; preds = %luaY_parser.exit
  %totalbytes.i.i = getelementptr inbounds %struct.global_State, ptr %42, i64 0, i32 14
  %51 = load i64, ptr %totalbytes.i.i, align 8
  %add.i.i = add i64 %51, %add.i23
  store i64 %add.i.i, ptr %totalbytes.i.i, align 8
  %L.val.i = load ptr, ptr %l_G, align 8
  %rootgc.i.i = getelementptr inbounds %struct.global_State, ptr %L.val.i, i64 0, i32 6
  %52 = load ptr, ptr %rootgc.i.i, align 8
  store ptr %52, ptr %call.i.i24, align 8
  store ptr %call.i.i24, ptr %rootgc.i.i, align 8
  %currentwhite.i.i = getelementptr inbounds %struct.global_State, ptr %L.val.i, i64 0, i32 3
  %53 = load i8, ptr %currentwhite.i.i, align 8
  %54 = and i8 %53, 3
  %marked.i.i = getelementptr inbounds %struct.GCheader, ptr %call.i.i24, i64 0, i32 2
  store i8 %54, ptr %marked.i.i, align 1
  %tt3.i.i = getelementptr inbounds %struct.GCheader, ptr %call.i.i24, i64 0, i32 1
  store i8 6, ptr %tt3.i.i, align 8
  %isC.i = getelementptr inbounds %struct.LClosure, ptr %call.i.i24, i64 0, i32 3
  store i8 0, ptr %isC.i, align 2
  %env.i = getelementptr inbounds %struct.LClosure, ptr %call.i.i24, i64 0, i32 6
  store ptr %41, ptr %env.i, align 8
  %nupvalues.i = getelementptr inbounds %struct.LClosure, ptr %call.i.i24, i64 0, i32 4
  store i8 %40, ptr %nupvalues.i, align 1
  %tobool.not10.i = icmp eq i8 %40, 0
  br i1 %tobool.not10.i, label %luaF_newLclosure.exit, label %while.body.preheader.i

while.body.preheader.i:                           ; preds = %luaM_realloc_.exit.i
  %scevgep.i = getelementptr i8, ptr %call.i.i24, i64 40
  %55 = zext i8 %40 to i64
  %56 = shl nuw nsw i64 %55, 3
  call void @llvm.memset.p0.i64(ptr align 8 %scevgep.i, i8 0, i64 %56, i1 false)
  br label %luaF_newLclosure.exit

luaF_newLclosure.exit:                            ; preds = %luaM_realloc_.exit.i, %while.body.preheader.i
  %p3 = getelementptr inbounds %struct.LClosure, ptr %call.i.i24, i64 0, i32 7
  store ptr %39, ptr %p3, align 8
  %57 = load i8, ptr %nups, align 8
  %cmp661.not = icmp eq i8 %57, 0
  br i1 %cmp661.not, label %for.end, label %for.body

for.body:                                         ; preds = %luaF_newLclosure.exit, %luaF_newupval.exit
  %indvars.iv = phi i64 [ %indvars.iv.next, %luaF_newupval.exit ], [ 0, %luaF_newLclosure.exit ]
  %58 = load ptr, ptr %l_G, align 8
  %frealloc.i.i30 = getelementptr inbounds %struct.global_State, ptr %58, i64 0, i32 1
  %59 = load ptr, ptr %frealloc.i.i30, align 8
  %ud.i.i31 = getelementptr inbounds %struct.global_State, ptr %58, i64 0, i32 2
  %60 = load ptr, ptr %ud.i.i31, align 8
  %call.i.i32 = call ptr %59(ptr noundef %60, ptr noundef null, i64 noundef 0, i64 noundef 40) #35
  %cmp.i.i33 = icmp eq ptr %call.i.i32, null
  br i1 %cmp.i.i33, label %if.then.i.i42, label %luaF_newupval.exit

if.then.i.i42:                                    ; preds = %for.body
  %errorJmp.i.i.i43 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 26
  %61 = load ptr, ptr %errorJmp.i.i.i43, align 8
  %tobool.not.i.i.i44 = icmp eq ptr %61, null
  br i1 %tobool.not.i.i.i44, label %if.else.i.i.i48, label %if.then.i.i.i45

if.then.i.i.i45:                                  ; preds = %if.then.i.i42
  %status.i.i.i46 = getelementptr inbounds %struct.lua_longjmp, ptr %61, i64 0, i32 2
  store volatile i32 4, ptr %status.i.i.i46, align 8
  %62 = load ptr, ptr %errorJmp.i.i.i43, align 8
  %b.i.i.i47 = getelementptr inbounds %struct.lua_longjmp, ptr %62, i64 0, i32 1
  call void @longjmp(ptr noundef nonnull %b.i.i.i47, i32 noundef 1) #38
  unreachable

if.else.i.i.i48:                                  ; preds = %if.then.i.i42
  %status3.i.i.i49 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 3
  store i8 4, ptr %status3.i.i.i49, align 2
  %63 = load ptr, ptr %l_G, align 8
  %panic.i.i.i50 = getelementptr inbounds %struct.global_State, ptr %63, i64 0, i32 19
  %64 = load ptr, ptr %panic.i.i.i50, align 8
  %tobool4.not.i.i.i51 = icmp eq ptr %64, null
  br i1 %tobool4.not.i.i.i51, label %if.end.i.i.i55, label %if.then5.i.i.i52

if.then5.i.i.i52:                                 ; preds = %if.else.i.i.i48
  call fastcc void @resetstack(ptr noundef nonnull %L, i32 noundef 4)
  %65 = load ptr, ptr %l_G, align 8
  %panic7.i.i.i53 = getelementptr inbounds %struct.global_State, ptr %65, i64 0, i32 19
  %66 = load ptr, ptr %panic7.i.i.i53, align 8
  %call.i.i.i54 = call i32 %66(ptr noundef nonnull %L) #35
  br label %if.end.i.i.i55

if.end.i.i.i55:                                   ; preds = %if.then5.i.i.i52, %if.else.i.i.i48
  call void @exit(i32 noundef 1) #38
  unreachable

luaF_newupval.exit:                               ; preds = %for.body
  %totalbytes.i.i35 = getelementptr inbounds %struct.global_State, ptr %58, i64 0, i32 14
  %67 = load i64, ptr %totalbytes.i.i35, align 8
  %add.i.i36 = add i64 %67, 40
  store i64 %add.i.i36, ptr %totalbytes.i.i35, align 8
  %L.val.i37 = load ptr, ptr %l_G, align 8
  %rootgc.i.i38 = getelementptr inbounds %struct.global_State, ptr %L.val.i37, i64 0, i32 6
  %68 = load ptr, ptr %rootgc.i.i38, align 8
  store ptr %68, ptr %call.i.i32, align 8
  store ptr %call.i.i32, ptr %rootgc.i.i38, align 8
  %currentwhite.i.i39 = getelementptr inbounds %struct.global_State, ptr %L.val.i37, i64 0, i32 3
  %69 = load i8, ptr %currentwhite.i.i39, align 8
  %70 = and i8 %69, 3
  %marked.i.i40 = getelementptr inbounds %struct.GCheader, ptr %call.i.i32, i64 0, i32 2
  store i8 %70, ptr %marked.i.i40, align 1
  %tt3.i.i41 = getelementptr inbounds %struct.GCheader, ptr %call.i.i32, i64 0, i32 1
  store i8 10, ptr %tt3.i.i41, align 8
  %u.i = getelementptr inbounds %struct.UpVal, ptr %call.i.i32, i64 0, i32 4
  %v.i = getelementptr inbounds %struct.UpVal, ptr %call.i.i32, i64 0, i32 3
  store ptr %u.i, ptr %v.i, align 8
  %tt.i = getelementptr inbounds %struct.UpVal, ptr %call.i.i32, i64 0, i32 4, i32 0, i32 1
  store i32 0, ptr %tt.i, align 8
  %arrayidx = getelementptr inbounds %struct.LClosure, ptr %call.i.i24, i64 0, i32 8, i64 %indvars.iv
  store ptr %call.i.i32, ptr %arrayidx, align 8
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %71 = load i8, ptr %nups, align 8
  %72 = zext i8 %71 to i64
  %cmp6 = icmp ult i64 %indvars.iv.next, %72
  br i1 %cmp6, label %for.body, label %for.end, !llvm.loop !92

for.end:                                          ; preds = %luaF_newupval.exit, %luaF_newLclosure.exit
  %top = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %73 = load ptr, ptr %top, align 8
  store ptr %call.i.i24, ptr %73, align 8
  %tt = getelementptr inbounds %struct.lua_TValue, ptr %73, i64 0, i32 1
  store i32 6, ptr %tt, align 8
  %stack_last = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 9
  %74 = load ptr, ptr %stack_last, align 8
  %75 = load ptr, ptr %top, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %74 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %75 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp11 = icmp slt i64 %sub.ptr.sub, 17
  br i1 %cmp11, label %if.then13, label %if.end14

if.then13:                                        ; preds = %for.end
  %stacksize.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 13
  %76 = load i32, ptr %stacksize.i, align 8
  %cmp.not.i = icmp slt i32 %76, 1
  %add.i56 = add nsw i32 %76, 1
  %mul.i57 = shl nsw i32 %76, 1
  %add.sink.i = select i1 %cmp.not.i, i32 %add.i56, i32 %mul.i57
  call fastcc void @luaD_reallocstack(ptr noundef nonnull %L, i32 noundef %add.sink.i)
  %.pre = load ptr, ptr %top, align 8
  br label %if.end14

if.end14:                                         ; preds = %for.end, %if.then13
  %77 = phi ptr [ %75, %for.end ], [ %.pre, %if.then13 ]
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue, ptr %77, i64 1
  store ptr %incdec.ptr, ptr %top, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @open_func(ptr noundef %ls, ptr noundef %fs) unnamed_addr #0 {
entry:
  %L1 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 6
  %0 = load ptr, ptr %L1, align 8
  %l_G.i.i = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %1 = load ptr, ptr %l_G.i.i, align 8
  %frealloc.i.i = getelementptr inbounds %struct.global_State, ptr %1, i64 0, i32 1
  %2 = load ptr, ptr %frealloc.i.i, align 8
  %ud.i.i = getelementptr inbounds %struct.global_State, ptr %1, i64 0, i32 2
  %3 = load ptr, ptr %ud.i.i, align 8
  %call.i.i = tail call ptr %2(ptr noundef %3, ptr noundef null, i64 noundef 0, i64 noundef 120) #35
  %cmp.i.i = icmp eq ptr %call.i.i, null
  br i1 %cmp.i.i, label %if.then.i.i, label %luaF_newproto.exit

if.then.i.i:                                      ; preds = %entry
  %errorJmp.i.i.i = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 26
  %4 = load ptr, ptr %errorJmp.i.i.i, align 8
  %tobool.not.i.i.i = icmp eq ptr %4, null
  br i1 %tobool.not.i.i.i, label %if.else.i.i.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %if.then.i.i
  %status.i.i.i = getelementptr inbounds %struct.lua_longjmp, ptr %4, i64 0, i32 2
  store volatile i32 4, ptr %status.i.i.i, align 8
  %5 = load ptr, ptr %errorJmp.i.i.i, align 8
  %b.i.i.i = getelementptr inbounds %struct.lua_longjmp, ptr %5, i64 0, i32 1
  tail call void @longjmp(ptr noundef nonnull %b.i.i.i, i32 noundef 1) #38
  unreachable

if.else.i.i.i:                                    ; preds = %if.then.i.i
  %status3.i.i.i = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 3
  store i8 4, ptr %status3.i.i.i, align 2
  %6 = load ptr, ptr %l_G.i.i, align 8
  %panic.i.i.i = getelementptr inbounds %struct.global_State, ptr %6, i64 0, i32 19
  %7 = load ptr, ptr %panic.i.i.i, align 8
  %tobool4.not.i.i.i = icmp eq ptr %7, null
  br i1 %tobool4.not.i.i.i, label %if.end.i.i.i, label %if.then5.i.i.i

if.then5.i.i.i:                                   ; preds = %if.else.i.i.i
  tail call fastcc void @resetstack(ptr noundef nonnull %0, i32 noundef 4)
  %8 = load ptr, ptr %l_G.i.i, align 8
  %panic7.i.i.i = getelementptr inbounds %struct.global_State, ptr %8, i64 0, i32 19
  %9 = load ptr, ptr %panic7.i.i.i, align 8
  %call.i.i.i = tail call i32 %9(ptr noundef nonnull %0) #35
  br label %if.end.i.i.i

if.end.i.i.i:                                     ; preds = %if.then5.i.i.i, %if.else.i.i.i
  tail call void @exit(i32 noundef 1) #38
  unreachable

luaF_newproto.exit:                               ; preds = %entry
  %totalbytes.i.i = getelementptr inbounds %struct.global_State, ptr %1, i64 0, i32 14
  %10 = load i64, ptr %totalbytes.i.i, align 8
  %add.i.i = add i64 %10, 120
  store i64 %add.i.i, ptr %totalbytes.i.i, align 8
  %L.val.i = load ptr, ptr %l_G.i.i, align 8
  %rootgc.i.i = getelementptr inbounds %struct.global_State, ptr %L.val.i, i64 0, i32 6
  %11 = load ptr, ptr %rootgc.i.i, align 8
  store ptr %11, ptr %call.i.i, align 8
  store ptr %call.i.i, ptr %rootgc.i.i, align 8
  %currentwhite.i.i = getelementptr inbounds %struct.global_State, ptr %L.val.i, i64 0, i32 3
  %12 = load i8, ptr %currentwhite.i.i, align 8
  %13 = and i8 %12, 3
  %marked.i.i = getelementptr inbounds %struct.GCheader, ptr %call.i.i, i64 0, i32 2
  store i8 %13, ptr %marked.i.i, align 1
  %tt3.i.i = getelementptr inbounds %struct.GCheader, ptr %call.i.i, i64 0, i32 1
  store i8 9, ptr %tt3.i.i, align 8
  %k.i = getelementptr inbounds %struct.Proto, ptr %call.i.i, i64 0, i32 3
  %nups.i = getelementptr inbounds %struct.Proto, ptr %call.i.i, i64 0, i32 19
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(88) %k.i, i8 0, i64 88, i1 false)
  store i32 0, ptr %nups.i, align 8
  store ptr %call.i.i, ptr %fs, align 8
  %fs3 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 5
  %14 = load ptr, ptr %fs3, align 8
  %prev = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 2
  store ptr %14, ptr %prev, align 8
  %ls4 = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 3
  store ptr %ls, ptr %ls4, align 8
  %L5 = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 4
  store ptr %0, ptr %L5, align 8
  store ptr %fs, ptr %fs3, align 8
  %pc = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 6
  store i32 0, ptr %pc, align 8
  %lasttarget = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 7
  store i32 -1, ptr %lasttarget, align 4
  %jpc = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 8
  store i32 -1, ptr %jpc, align 8
  %freereg = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 9
  %bl = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 5
  store ptr null, ptr %bl, align 8
  %source = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 9
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 4 dereferenceable(15) %freereg, i8 0, i64 15, i1 false)
  %15 = load ptr, ptr %source, align 8
  %source7 = getelementptr inbounds %struct.Proto, ptr %call.i.i, i64 0, i32 9
  store ptr %15, ptr %source7, align 8
  %maxstacksize = getelementptr inbounds %struct.Proto, ptr %call.i.i, i64 0, i32 22
  store i8 2, ptr %maxstacksize, align 1
  %call8 = tail call fastcc ptr @luaH_new(ptr noundef nonnull %0, i32 noundef 0, i32 noundef 0)
  %h = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 1
  store ptr %call8, ptr %h, align 8
  %top = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %16 = load ptr, ptr %top, align 8
  store ptr %call8, ptr %16, align 8
  %tt = getelementptr inbounds %struct.lua_TValue, ptr %16, i64 0, i32 1
  store i32 5, ptr %tt, align 8
  %stack_last = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 9
  %17 = load ptr, ptr %stack_last, align 8
  %18 = load ptr, ptr %top, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %17 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %18 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp = icmp slt i64 %sub.ptr.sub, 17
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %luaF_newproto.exit
  %stacksize.i = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 13
  %19 = load i32, ptr %stacksize.i, align 8
  %cmp.not.i = icmp slt i32 %19, 1
  %add.i = add nsw i32 %19, 1
  %mul.i = shl nsw i32 %19, 1
  %add.sink.i = select i1 %cmp.not.i, i32 %add.i, i32 %mul.i
  tail call fastcc void @luaD_reallocstack(ptr noundef nonnull %0, i32 noundef %add.sink.i)
  %.pre = load ptr, ptr %top, align 8
  br label %if.end

if.end:                                           ; preds = %luaF_newproto.exit, %if.then
  %20 = phi ptr [ %18, %luaF_newproto.exit ], [ %.pre, %if.then ]
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue, ptr %20, i64 1
  store ptr %incdec.ptr, ptr %top, align 8
  store ptr %call.i.i, ptr %incdec.ptr, align 8
  %tt15 = getelementptr inbounds %struct.lua_TValue, ptr %20, i64 1, i32 1
  store i32 9, ptr %tt15, align 8
  %21 = load ptr, ptr %stack_last, align 8
  %22 = load ptr, ptr %top, align 8
  %sub.ptr.lhs.cast18 = ptrtoint ptr %21 to i64
  %sub.ptr.rhs.cast19 = ptrtoint ptr %22 to i64
  %sub.ptr.sub20 = sub i64 %sub.ptr.lhs.cast18, %sub.ptr.rhs.cast19
  %cmp21 = icmp slt i64 %sub.ptr.sub20, 17
  br i1 %cmp21, label %if.then22, label %if.end24

if.then22:                                        ; preds = %if.end
  %stacksize.i37 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 13
  %23 = load i32, ptr %stacksize.i37, align 8
  %cmp.not.i38 = icmp slt i32 %23, 1
  %add.i39 = add nsw i32 %23, 1
  %mul.i40 = shl nsw i32 %23, 1
  %add.sink.i41 = select i1 %cmp.not.i38, i32 %add.i39, i32 %mul.i40
  tail call fastcc void @luaD_reallocstack(ptr noundef nonnull %0, i32 noundef %add.sink.i41)
  %.pre42 = load ptr, ptr %top, align 8
  br label %if.end24

if.end24:                                         ; preds = %if.end, %if.then22
  %24 = phi ptr [ %22, %if.end ], [ %.pre42, %if.then22 ]
  %incdec.ptr26 = getelementptr inbounds %struct.lua_TValue, ptr %24, i64 1
  store ptr %incdec.ptr26, ptr %top, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @chunk(ptr noundef %ls) unnamed_addr #0 {
entry:
  %v.i702 = alloca %struct.expdesc, align 8
  %bl.i677 = alloca %struct.BlockCnt, align 8
  %v.i660 = alloca %struct.expdesc, align 8
  %bl.i635 = alloca %struct.BlockCnt, align 8
  %o.i = alloca %struct.lua_TValue, align 8
  %new_fs.i = alloca %struct.FuncState, align 8
  %bl.i.i343 = alloca %struct.BlockCnt, align 8
  %bl.i.i = alloca %struct.BlockCnt, align 8
  %v.i.i234 = alloca %struct.expdesc, align 8
  %bl.i235 = alloca %struct.BlockCnt, align 8
  %bl.i215 = alloca %struct.BlockCnt, align 8
  %e.i.i = alloca %struct.expdesc, align 8
  %bl.i = alloca %struct.BlockCnt, align 8
  %v.i.i = alloca %struct.expdesc, align 8
  %bl1.i = alloca %struct.BlockCnt, align 8
  %bl2.i = alloca %struct.BlockCnt, align 8
  %v.i128 = alloca %struct.expdesc, align 8
  %b.i129 = alloca %struct.expdesc, align 8
  %new_fs.i.i = alloca %struct.FuncState, align 8
  %v.i63 = alloca %struct.expdesc, align 8
  %b.i = alloca %struct.expdesc, align 8
  %e.i40 = alloca %struct.expdesc, align 8
  %e.i = alloca %struct.expdesc, align 8
  %v.i = alloca %struct.LHS_assign, align 8
  %L.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 6
  %0 = load ptr, ptr %L.i, align 8
  %nCcalls.i = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 15
  %1 = load i16, ptr %nCcalls.i, align 8
  %inc.i = add i16 %1, 1
  store i16 %inc.i, ptr %nCcalls.i, align 8
  %cmp.i = icmp ugt i16 %inc.i, 200
  br i1 %cmp.i, label %if.then.i, label %while.cond.preheader

while.cond.preheader:                             ; preds = %entry
  %t = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 3
  %linenumber.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 1
  %lastline.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 2
  %lookahead.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 4
  %seminfo.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 3, i32 1
  %fs1.i21 = getelementptr %struct.LexState, ptr %ls, i64 0, i32 5
  %u.i.i423 = getelementptr inbounds %struct.expdesc, ptr %e.i, i64 0, i32 1
  %u.i.i464 = getelementptr inbounds %struct.expdesc, ptr %e.i40, i64 0, i32 1
  %t.i.i78 = getelementptr inbounds %struct.expdesc, ptr %v.i63, i64 0, i32 2
  %f.i.i = getelementptr inbounds %struct.expdesc, ptr %v.i63, i64 0, i32 3
  %u.i.i79 = getelementptr inbounds %struct.expdesc, ptr %v.i63, i64 0, i32 1
  %breaklist.i.i = getelementptr inbounds %struct.BlockCnt, ptr %bl1.i, i64 0, i32 1
  %isbreakable1.i.i = getelementptr inbounds %struct.BlockCnt, ptr %bl1.i, i64 0, i32 4
  %nactvar2.i.i = getelementptr inbounds %struct.BlockCnt, ptr %bl1.i, i64 0, i32 2
  %upval.i.i = getelementptr inbounds %struct.BlockCnt, ptr %bl1.i, i64 0, i32 3
  %breaklist.i17.i = getelementptr inbounds %struct.BlockCnt, ptr %bl2.i, i64 0, i32 1
  %isbreakable1.i18.i = getelementptr inbounds %struct.BlockCnt, ptr %bl2.i, i64 0, i32 4
  %nactvar2.i20.i = getelementptr inbounds %struct.BlockCnt, ptr %bl2.i, i64 0, i32 2
  %upval.i21.i = getelementptr inbounds %struct.BlockCnt, ptr %bl2.i, i64 0, i32 3
  %f.i.i156 = getelementptr inbounds %struct.expdesc, ptr %v.i.i, i64 0, i32 3
  %breaklist.i.i175 = getelementptr inbounds %struct.BlockCnt, ptr %bl.i, i64 0, i32 1
  %isbreakable1.i.i176 = getelementptr inbounds %struct.BlockCnt, ptr %bl.i, i64 0, i32 4
  %nactvar2.i.i178 = getelementptr inbounds %struct.BlockCnt, ptr %bl.i, i64 0, i32 2
  %upval.i.i179 = getelementptr inbounds %struct.BlockCnt, ptr %bl.i, i64 0, i32 3
  %u.i.i.i546 = getelementptr inbounds %struct.expdesc, ptr %e.i.i, i64 0, i32 1
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %o.i, i64 0, i32 1
  %breaklist.i.i217 = getelementptr inbounds %struct.BlockCnt, ptr %bl.i215, i64 0, i32 1
  %isbreakable1.i.i218 = getelementptr inbounds %struct.BlockCnt, ptr %bl.i215, i64 0, i32 4
  %nactvar2.i.i220 = getelementptr inbounds %struct.BlockCnt, ptr %bl.i215, i64 0, i32 2
  %upval.i.i221 = getelementptr inbounds %struct.BlockCnt, ptr %bl.i215, i64 0, i32 3
  %f.i.i249 = getelementptr inbounds %struct.expdesc, ptr %v.i.i234, i64 0, i32 3
  %breaklist.i.i250 = getelementptr inbounds %struct.BlockCnt, ptr %bl.i235, i64 0, i32 1
  %isbreakable1.i.i251 = getelementptr inbounds %struct.BlockCnt, ptr %bl.i235, i64 0, i32 4
  %nactvar2.i.i253 = getelementptr inbounds %struct.BlockCnt, ptr %bl.i235, i64 0, i32 2
  %upval.i.i254 = getelementptr inbounds %struct.BlockCnt, ptr %bl.i235, i64 0, i32 3
  %breaklist.i = getelementptr inbounds %struct.BlockCnt, ptr %bl.i.i, i64 0, i32 1
  %isbreakable1.i = getelementptr inbounds %struct.BlockCnt, ptr %bl.i.i, i64 0, i32 4
  %nactvar2.i = getelementptr inbounds %struct.BlockCnt, ptr %bl.i.i, i64 0, i32 2
  %upval.i627 = getelementptr inbounds %struct.BlockCnt, ptr %bl.i.i, i64 0, i32 3
  %f.i707 = getelementptr inbounds %struct.expdesc, ptr %v.i702, i64 0, i32 3
  %breaklist.i.i679 = getelementptr inbounds %struct.BlockCnt, ptr %bl.i677, i64 0, i32 1
  %isbreakable1.i.i680 = getelementptr inbounds %struct.BlockCnt, ptr %bl.i677, i64 0, i32 4
  %nactvar2.i.i682 = getelementptr inbounds %struct.BlockCnt, ptr %bl.i677, i64 0, i32 2
  %upval.i.i683 = getelementptr inbounds %struct.BlockCnt, ptr %bl.i677, i64 0, i32 3
  %f.i = getelementptr inbounds %struct.expdesc, ptr %v.i660, i64 0, i32 3
  %breaklist.i.i637 = getelementptr inbounds %struct.BlockCnt, ptr %bl.i635, i64 0, i32 1
  %isbreakable1.i.i638 = getelementptr inbounds %struct.BlockCnt, ptr %bl.i635, i64 0, i32 4
  %nactvar2.i.i640 = getelementptr inbounds %struct.BlockCnt, ptr %bl.i635, i64 0, i32 2
  %upval.i.i641 = getelementptr inbounds %struct.BlockCnt, ptr %bl.i635, i64 0, i32 3
  %breaklist.i629 = getelementptr inbounds %struct.BlockCnt, ptr %bl.i.i343, i64 0, i32 1
  %isbreakable1.i630 = getelementptr inbounds %struct.BlockCnt, ptr %bl.i.i343, i64 0, i32 4
  %nactvar2.i632 = getelementptr inbounds %struct.BlockCnt, ptr %bl.i.i343, i64 0, i32 2
  %upval.i633 = getelementptr inbounds %struct.BlockCnt, ptr %bl.i.i343, i64 0, i32 3
  %v2.i = getelementptr inbounds %struct.LHS_assign, ptr %v.i, i64 0, i32 1
  %u.i = getelementptr inbounds %struct.LHS_assign, ptr %v.i, i64 0, i32 1, i32 1
  br label %land.rhs

if.then.i:                                        ; preds = %entry
  tail call fastcc void @luaX_lexerror(ptr noundef nonnull %ls, ptr noundef nonnull @.str.146, i32 noundef 0)
  unreachable

land.rhs:                                         ; preds = %while.cond.preheader, %testnext.exit
  %2 = load i32, ptr %t, align 8
  switch i32 %2, label %while.body [
    i32 260, label %while.end
    i32 261, label %while.end
    i32 262, label %while.end
    i32 276, label %while.end
    i32 287, label %while.end
  ]

while.body:                                       ; preds = %land.rhs
  %3 = load i32, ptr %linenumber.i, align 4
  switch i32 %2, label %sw.default.i9 [
    i32 266, label %sw.bb.i
    i32 277, label %sw.bb1.i
    i32 259, label %sw.bb2.i
    i32 264, label %sw.bb3.i
    i32 272, label %sw.bb4.i
    i32 265, label %sw.bb5.i
    i32 268, label %sw.bb6.i
    i32 273, label %sw.bb7.i
    i32 258, label %sw.bb8.i
  ]

sw.bb.i:                                          ; preds = %while.body
  %4 = load ptr, ptr %fs1.i21, align 8
  store i32 %3, ptr %lastline.i, align 8
  %5 = load i32, ptr %lookahead.i, align 8
  %cmp.not.i713 = icmp eq i32 %5, 287
  br i1 %cmp.not.i713, label %if.else.i717, label %if.then.i715

if.then.i715:                                     ; preds = %sw.bb.i
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i, align 8
  br label %luaX_next.exit720

if.else.i717:                                     ; preds = %sw.bb.i
  %call.i719 = call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i)
  store i32 %call.i719, ptr %t, align 8
  br label %luaX_next.exit720

luaX_next.exit720:                                ; preds = %if.then.i715, %if.else.i717
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %v.i702)
  %call.i.i703 = call fastcc i32 @subexpr(ptr noundef nonnull %ls, ptr noundef nonnull %v.i702, i32 noundef 0), !range !93
  %6 = load i32, ptr %v.i702, align 8
  %cmp.i704 = icmp eq i32 %6, 1
  br i1 %cmp.i704, label %if.then.i708, label %cond.exit709

if.then.i708:                                     ; preds = %luaX_next.exit720
  store i32 3, ptr %v.i702, align 8
  br label %cond.exit709

cond.exit709:                                     ; preds = %luaX_next.exit720, %if.then.i708
  %7 = load ptr, ptr %fs1.i21, align 8
  call fastcc void @luaK_goiftrue(ptr noundef %7, ptr noundef nonnull %v.i702)
  %8 = load i32, ptr %f.i707, align 4
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %v.i702)
  %9 = load i32, ptr %t, align 8
  %cmp.not.i.i686 = icmp eq i32 %9, 274
  br i1 %cmp.not.i.i686, label %check.exit.i691, label %if.then.i.i687

if.then.i.i687:                                   ; preds = %cond.exit709
  %10 = load ptr, ptr %L.i, align 8
  %call1.i.i.i690 = call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %10, ptr noundef nonnull @.str.164, ptr noundef nonnull @.str.78)
  %11 = load i32, ptr %t, align 8
  call fastcc void @luaX_lexerror(ptr noundef nonnull %ls, ptr noundef %call1.i.i.i690, i32 noundef %11)
  unreachable

check.exit.i691:                                  ; preds = %cond.exit709
  %12 = load i32, ptr %linenumber.i, align 4
  store i32 %12, ptr %lastline.i, align 8
  %13 = load i32, ptr %lookahead.i, align 8
  %cmp.not.i2.i695 = icmp eq i32 %13, 287
  br i1 %cmp.not.i2.i695, label %if.else.i.i698, label %if.then.i3.i696

if.then.i3.i696:                                  ; preds = %check.exit.i691
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i, align 8
  br label %checknext.exit701

if.else.i.i698:                                   ; preds = %check.exit.i691
  %call.i.i700 = call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i)
  store i32 %call.i.i700, ptr %t, align 8
  br label %checknext.exit701

checknext.exit701:                                ; preds = %if.then.i3.i696, %if.else.i.i698
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %bl.i677)
  %14 = load ptr, ptr %fs1.i21, align 8
  store i32 -1, ptr %breaklist.i.i679, align 8
  store i8 0, ptr %isbreakable1.i.i680, align 2
  %nactvar.i.i681 = getelementptr inbounds %struct.FuncState, ptr %14, i64 0, i32 13
  %15 = load i8, ptr %nactvar.i.i681, align 2
  store i8 %15, ptr %nactvar2.i.i682, align 4
  store i8 0, ptr %upval.i.i683, align 1
  %bl3.i.i684 = getelementptr inbounds %struct.FuncState, ptr %14, i64 0, i32 5
  %16 = load ptr, ptr %bl3.i.i684, align 8
  store ptr %16, ptr %bl.i677, align 8
  store ptr %bl.i677, ptr %bl3.i.i684, align 8
  call fastcc void @chunk(ptr noundef nonnull %ls)
  call fastcc void @leaveblock(ptr noundef %14)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %bl.i677)
  %jpc1.i.i358 = getelementptr inbounds %struct.FuncState, ptr %4, i64 0, i32 8
  %ls.i.i.i359 = getelementptr inbounds %struct.FuncState, ptr %4, i64 0, i32 3
  %pc.i.i.i396 = getelementptr inbounds %struct.FuncState, ptr %4, i64 0, i32 6
  %lasttarget.i.i.i397 = getelementptr inbounds %struct.FuncState, ptr %4, i64 0, i32 7
  br label %while.cond.i

while.cond.i:                                     ; preds = %checknext.exit659, %checknext.exit701
  %escapelist.i.0 = phi i32 [ -1, %checknext.exit701 ], [ %escapelist.i.1, %checknext.exit659 ]
  %flist.0.i = phi i32 [ %8, %checknext.exit701 ], [ %42, %checknext.exit659 ]
  %17 = load i32, ptr %t, align 8
  switch i32 %17, label %if.else.i406 [
    i32 261, label %while.body.i
    i32 260, label %if.then.i347
  ]

while.body.i:                                     ; preds = %while.cond.i
  %18 = load i32, ptr %jpc1.i.i358, align 8
  store i32 -1, ptr %jpc1.i.i358, align 8
  %19 = load ptr, ptr %ls.i.i.i359, align 8
  %lastline.i.i.i360 = getelementptr inbounds %struct.LexState, ptr %19, i64 0, i32 2
  %20 = load i32, ptr %lastline.i.i.i360, align 8
  %call.i.i.i361 = call fastcc i32 @luaK_code(ptr noundef %4, i32 noundef 2147450902, i32 noundef %20)
  %cmp.i.i.i362 = icmp eq i32 %18, -1
  br i1 %cmp.i.i.i362, label %luaK_jump.exit.i389, label %if.else.i.i.i363

if.else.i.i.i363:                                 ; preds = %while.body.i
  %cmp1.i.i.i364 = icmp eq i32 %call.i.i.i361, -1
  br i1 %cmp1.i.i.i364, label %if.else.i.i392, label %while.cond.preheader.i.i.i365

while.cond.preheader.i.i.i365:                    ; preds = %if.else.i.i.i363
  %fs.val.i.i.i366 = load ptr, ptr %4, align 8
  %21 = getelementptr i8, ptr %fs.val.i.i.i366, i64 24
  %fs.val.val.i.i.i367 = load ptr, ptr %21, align 8
  br label %while.cond.i.i.i368

while.cond.i.i.i368:                              ; preds = %while.cond.i.i.i368, %while.cond.preheader.i.i.i365
  %list.0.i.i.i369 = phi i32 [ %add1.i.i.i.i376, %while.cond.i.i.i368 ], [ %call.i.i.i361, %while.cond.preheader.i.i.i365 ]
  %idxprom.i.i.i.i370 = sext i32 %list.0.i.i.i369 to i64
  %arrayidx.i.i.i.i371 = getelementptr inbounds i32, ptr %fs.val.val.i.i.i367, i64 %idxprom.i.i.i.i370
  %22 = load i32, ptr %arrayidx.i.i.i.i371, align 4
  %shr.i.i.i.i372 = lshr i32 %22, 14
  %sub.i.i.i.i373 = add nsw i32 %shr.i.i.i.i372, -131071
  %cmp.i.i.i.i374 = icmp eq i32 %sub.i.i.i.i373, -1
  %add.i.i.i.i375 = add nuw nsw i32 %list.0.i.i.i369, 1
  %add1.i.i.i.i376 = add nsw i32 %add.i.i.i.i375, %sub.i.i.i.i373
  %cmp4.not12.i.i.i377 = icmp eq i32 %add1.i.i.i.i376, -1
  %cmp4.not.i.i.i378 = select i1 %cmp.i.i.i.i374, i1 true, i1 %cmp4.not12.i.i.i377
  br i1 %cmp4.not.i.i.i378, label %while.end.i.i.i379, label %while.cond.i.i.i368, !llvm.loop !94

while.end.i.i.i379:                               ; preds = %while.cond.i.i.i368
  %add.neg.i.i.i.i380 = xor i32 %list.0.i.i.i369, -1
  %sub.i7.i.i.i381 = add i32 %18, %add.neg.i.i.i.i380
  %23 = call i32 @llvm.abs.i32(i32 %sub.i7.i.i.i381, i1 true)
  %cmp.i8.i.i.i382 = icmp ugt i32 %23, 131071
  br i1 %cmp.i8.i.i.i382, label %if.then.i.i.i.i404, label %fixjump.exit.i.i.i383

if.then.i.i.i.i404:                               ; preds = %while.end.i.i.i379
  %24 = load ptr, ptr %ls.i.i.i359, align 8
  %t.i.i.i.i.i405 = getelementptr inbounds %struct.LexState, ptr %24, i64 0, i32 3
  %25 = load i32, ptr %t.i.i.i.i.i405, align 8
  call fastcc void @luaX_lexerror(ptr noundef %24, ptr noundef nonnull @.str.148, i32 noundef %25)
  unreachable

fixjump.exit.i.i.i383:                            ; preds = %while.end.i.i.i379
  %arrayidx.i.i.i.i371.le = getelementptr inbounds i32, ptr %fs.val.val.i.i.i367, i64 %idxprom.i.i.i.i370
  %and.i.i.i.i385 = and i32 %22, 16383
  %add1.i11.i.i.i386 = shl i32 %sub.i7.i.i.i381, 14
  %shl.i.i.i.i387 = add i32 %add1.i11.i.i.i386, 2147467264
  %or.i.i.i.i388 = or disjoint i32 %shl.i.i.i.i387, %and.i.i.i.i385
  store i32 %or.i.i.i.i388, ptr %arrayidx.i.i.i.i371.le, align 4
  br label %luaK_jump.exit.i389

luaK_jump.exit.i389:                              ; preds = %fixjump.exit.i.i.i383, %while.body.i
  %cmp.i.i391 = icmp eq i32 %call.i.i.i361, -1
  br i1 %cmp.i.i391, label %luaK_concat.exit.i, label %if.else.i.i392

if.else.i.i392:                                   ; preds = %if.else.i.i.i363, %luaK_jump.exit.i389
  %j.0.i.i390728 = phi i32 [ %call.i.i.i361, %luaK_jump.exit.i389 ], [ %18, %if.else.i.i.i363 ]
  %cmp1.i.i = icmp eq i32 %escapelist.i.0, -1
  br i1 %cmp1.i.i, label %luaK_concat.exit.i, label %while.cond.preheader.i.i

while.cond.preheader.i.i:                         ; preds = %if.else.i.i392
  %fs.val.i.i = load ptr, ptr %4, align 8
  %26 = getelementptr i8, ptr %fs.val.i.i, i64 24
  %fs.val.val.i.i = load ptr, ptr %26, align 8
  br label %while.cond.i.i393

while.cond.i.i393:                                ; preds = %while.cond.i.i393, %while.cond.preheader.i.i
  %list.0.i.i = phi i32 [ %add1.i.i.i, %while.cond.i.i393 ], [ %escapelist.i.0, %while.cond.preheader.i.i ]
  %idxprom.i.i.i = sext i32 %list.0.i.i to i64
  %arrayidx.i.i.i = getelementptr inbounds i32, ptr %fs.val.val.i.i, i64 %idxprom.i.i.i
  %27 = load i32, ptr %arrayidx.i.i.i, align 4
  %shr.i.i.i = lshr i32 %27, 14
  %sub.i.i.i = add nsw i32 %shr.i.i.i, -131071
  %cmp.i.i17.i = icmp eq i32 %sub.i.i.i, -1
  %add.i.i.i394 = add nuw nsw i32 %list.0.i.i, 1
  %add1.i.i.i = add nsw i32 %add.i.i.i394, %sub.i.i.i
  %cmp4.not12.i.i = icmp eq i32 %add1.i.i.i, -1
  %cmp4.not.i.i = select i1 %cmp.i.i17.i, i1 true, i1 %cmp4.not12.i.i
  br i1 %cmp4.not.i.i, label %while.end.i.i, label %while.cond.i.i393, !llvm.loop !94

while.end.i.i:                                    ; preds = %while.cond.i.i393
  %add.neg.i.i.i = xor i32 %list.0.i.i, -1
  %sub.i7.i.i = add i32 %j.0.i.i390728, %add.neg.i.i.i
  %28 = call i32 @llvm.abs.i32(i32 %sub.i7.i.i, i1 true)
  %cmp.i8.i.i = icmp ugt i32 %28, 131071
  br i1 %cmp.i8.i.i, label %if.then.i.i.i402, label %fixjump.exit.i.i

if.then.i.i.i402:                                 ; preds = %while.end.i.i
  %29 = load ptr, ptr %ls.i.i.i359, align 8
  %t.i.i.i.i403 = getelementptr inbounds %struct.LexState, ptr %29, i64 0, i32 3
  %30 = load i32, ptr %t.i.i.i.i403, align 8
  call fastcc void @luaX_lexerror(ptr noundef %29, ptr noundef nonnull @.str.148, i32 noundef %30)
  unreachable

fixjump.exit.i.i:                                 ; preds = %while.end.i.i
  %arrayidx.i.i.i.le = getelementptr inbounds i32, ptr %fs.val.val.i.i, i64 %idxprom.i.i.i
  %and.i.i.i = and i32 %27, 16383
  %add1.i11.i.i = shl i32 %sub.i7.i.i, 14
  %shl.i.i.i = add i32 %add1.i11.i.i, 2147467264
  %or.i.i.i395 = or disjoint i32 %shl.i.i.i, %and.i.i.i
  store i32 %or.i.i.i395, ptr %arrayidx.i.i.i.le, align 4
  br label %luaK_concat.exit.i

luaK_concat.exit.i:                               ; preds = %if.else.i.i392, %fixjump.exit.i.i, %luaK_jump.exit.i389
  %escapelist.i.1 = phi i32 [ %escapelist.i.0, %luaK_jump.exit.i389 ], [ %escapelist.i.0, %fixjump.exit.i.i ], [ %j.0.i.i390728, %if.else.i.i392 ]
  %31 = load i32, ptr %pc.i.i.i396, align 8
  store i32 %31, ptr %lasttarget.i.i.i397, align 4
  %cmp.i.i19.i = icmp eq i32 %flist.0.i, -1
  br i1 %cmp.i.i19.i, label %luaK_patchtohere.exit.i399, label %if.else.i.i20.i

if.else.i.i20.i:                                  ; preds = %luaK_concat.exit.i
  %32 = load i32, ptr %jpc1.i.i358, align 4
  %cmp1.i.i21.i = icmp eq i32 %32, -1
  br i1 %cmp1.i.i21.i, label %if.then2.i.i.i401, label %while.cond.preheader.i.i22.i

while.cond.preheader.i.i22.i:                     ; preds = %if.else.i.i20.i
  %fs.val.i.i23.i = load ptr, ptr %4, align 8
  %33 = getelementptr i8, ptr %fs.val.i.i23.i, i64 24
  %fs.val.val.i.i24.i = load ptr, ptr %33, align 8
  br label %while.cond.i.i25.i

if.then2.i.i.i401:                                ; preds = %if.else.i.i20.i
  store i32 %flist.0.i, ptr %jpc1.i.i358, align 4
  br label %luaK_patchtohere.exit.i399

while.cond.i.i25.i:                               ; preds = %while.cond.i.i25.i, %while.cond.preheader.i.i22.i
  %list.0.i.i26.i = phi i32 [ %add1.i.i.i33.i, %while.cond.i.i25.i ], [ %32, %while.cond.preheader.i.i22.i ]
  %idxprom.i.i.i27.i = sext i32 %list.0.i.i26.i to i64
  %arrayidx.i.i.i28.i = getelementptr inbounds i32, ptr %fs.val.val.i.i24.i, i64 %idxprom.i.i.i27.i
  %34 = load i32, ptr %arrayidx.i.i.i28.i, align 4
  %shr.i.i.i29.i = lshr i32 %34, 14
  %sub.i.i.i30.i = add nsw i32 %shr.i.i.i29.i, -131071
  %cmp.i.i.i31.i = icmp eq i32 %sub.i.i.i30.i, -1
  %add.i.i.i32.i = add nuw nsw i32 %list.0.i.i26.i, 1
  %add1.i.i.i33.i = add nsw i32 %add.i.i.i32.i, %sub.i.i.i30.i
  %cmp4.not12.i.i34.i = icmp eq i32 %add1.i.i.i33.i, -1
  %cmp4.not.i.i35.i = select i1 %cmp.i.i.i31.i, i1 true, i1 %cmp4.not12.i.i34.i
  br i1 %cmp4.not.i.i35.i, label %while.end.i.i36.i, label %while.cond.i.i25.i, !llvm.loop !94

while.end.i.i36.i:                                ; preds = %while.cond.i.i25.i
  %add.neg.i.i.i37.i = xor i32 %list.0.i.i26.i, -1
  %sub.i7.i.i38.i = add i32 %flist.0.i, %add.neg.i.i.i37.i
  %35 = call i32 @llvm.abs.i32(i32 %sub.i7.i.i38.i, i1 true)
  %cmp.i8.i.i39.i = icmp ugt i32 %35, 131071
  br i1 %cmp.i8.i.i39.i, label %if.then.i.i.i46.i, label %fixjump.exit.i.i40.i

if.then.i.i.i46.i:                                ; preds = %while.end.i.i36.i
  %36 = load ptr, ptr %ls.i.i.i359, align 8
  %t.i.i.i.i47.i = getelementptr inbounds %struct.LexState, ptr %36, i64 0, i32 3
  %37 = load i32, ptr %t.i.i.i.i47.i, align 8
  call fastcc void @luaX_lexerror(ptr noundef %36, ptr noundef nonnull @.str.148, i32 noundef %37)
  unreachable

fixjump.exit.i.i40.i:                             ; preds = %while.end.i.i36.i
  %arrayidx.i.i.i28.i.le = getelementptr inbounds i32, ptr %fs.val.val.i.i24.i, i64 %idxprom.i.i.i27.i
  %and.i.i.i42.i = and i32 %34, 16383
  %add1.i11.i.i43.i = shl i32 %sub.i7.i.i38.i, 14
  %shl.i.i.i44.i = add i32 %add1.i11.i.i43.i, 2147467264
  %or.i.i.i45.i = or disjoint i32 %shl.i.i.i44.i, %and.i.i.i42.i
  store i32 %or.i.i.i45.i, ptr %arrayidx.i.i.i28.i.le, align 4
  br label %luaK_patchtohere.exit.i399

luaK_patchtohere.exit.i399:                       ; preds = %fixjump.exit.i.i40.i, %if.then2.i.i.i401, %luaK_concat.exit.i
  %38 = load i32, ptr %linenumber.i, align 4
  store i32 %38, ptr %lastline.i, align 8
  %39 = load i32, ptr %lookahead.i, align 8
  %cmp.not.i669 = icmp eq i32 %39, 287
  br i1 %cmp.not.i669, label %if.else.i673, label %if.then.i671

if.then.i671:                                     ; preds = %luaK_patchtohere.exit.i399
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i, align 8
  br label %luaX_next.exit676

if.else.i673:                                     ; preds = %luaK_patchtohere.exit.i399
  %call.i675 = call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i)
  store i32 %call.i675, ptr %t, align 8
  br label %luaX_next.exit676

luaX_next.exit676:                                ; preds = %if.then.i671, %if.else.i673
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %v.i660)
  %call.i.i661 = call fastcc i32 @subexpr(ptr noundef nonnull %ls, ptr noundef nonnull %v.i660, i32 noundef 0), !range !93
  %40 = load i32, ptr %v.i660, align 8
  %cmp.i662 = icmp eq i32 %40, 1
  br i1 %cmp.i662, label %if.then.i665, label %cond.exit

if.then.i665:                                     ; preds = %luaX_next.exit676
  store i32 3, ptr %v.i660, align 8
  br label %cond.exit

cond.exit:                                        ; preds = %luaX_next.exit676, %if.then.i665
  %41 = load ptr, ptr %fs1.i21, align 8
  call fastcc void @luaK_goiftrue(ptr noundef %41, ptr noundef nonnull %v.i660)
  %42 = load i32, ptr %f.i, align 4
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %v.i660)
  %43 = load i32, ptr %t, align 8
  %cmp.not.i.i644 = icmp eq i32 %43, 274
  br i1 %cmp.not.i.i644, label %check.exit.i649, label %if.then.i.i645

if.then.i.i645:                                   ; preds = %cond.exit
  %44 = load ptr, ptr %L.i, align 8
  %call1.i.i.i648 = call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %44, ptr noundef nonnull @.str.164, ptr noundef nonnull @.str.78)
  %45 = load i32, ptr %t, align 8
  call fastcc void @luaX_lexerror(ptr noundef nonnull %ls, ptr noundef %call1.i.i.i648, i32 noundef %45)
  unreachable

check.exit.i649:                                  ; preds = %cond.exit
  %46 = load i32, ptr %linenumber.i, align 4
  store i32 %46, ptr %lastline.i, align 8
  %47 = load i32, ptr %lookahead.i, align 8
  %cmp.not.i2.i653 = icmp eq i32 %47, 287
  br i1 %cmp.not.i2.i653, label %if.else.i.i656, label %if.then.i3.i654

if.then.i3.i654:                                  ; preds = %check.exit.i649
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i, align 8
  br label %checknext.exit659

if.else.i.i656:                                   ; preds = %check.exit.i649
  %call.i.i658 = call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i)
  store i32 %call.i.i658, ptr %t, align 8
  br label %checknext.exit659

checknext.exit659:                                ; preds = %if.then.i3.i654, %if.else.i.i656
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %bl.i635)
  %48 = load ptr, ptr %fs1.i21, align 8
  store i32 -1, ptr %breaklist.i.i637, align 8
  store i8 0, ptr %isbreakable1.i.i638, align 2
  %nactvar.i.i639 = getelementptr inbounds %struct.FuncState, ptr %48, i64 0, i32 13
  %49 = load i8, ptr %nactvar.i.i639, align 2
  store i8 %49, ptr %nactvar2.i.i640, align 4
  store i8 0, ptr %upval.i.i641, align 1
  %bl3.i.i642 = getelementptr inbounds %struct.FuncState, ptr %48, i64 0, i32 5
  %50 = load ptr, ptr %bl3.i.i642, align 8
  store ptr %50, ptr %bl.i635, align 8
  store ptr %bl.i635, ptr %bl3.i.i642, align 8
  call fastcc void @chunk(ptr noundef nonnull %ls)
  call fastcc void @leaveblock(ptr noundef %48)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %bl.i635)
  br label %while.cond.i, !llvm.loop !95

if.then.i347:                                     ; preds = %while.cond.i
  %51 = load i32, ptr %jpc1.i.i358, align 8
  store i32 -1, ptr %jpc1.i.i358, align 8
  %52 = load ptr, ptr %ls.i.i.i359, align 8
  %lastline.i.i51.i = getelementptr inbounds %struct.LexState, ptr %52, i64 0, i32 2
  %53 = load i32, ptr %lastline.i.i51.i, align 8
  %call.i.i52.i = call fastcc i32 @luaK_code(ptr noundef %4, i32 noundef 2147450902, i32 noundef %53)
  %cmp.i.i53.i = icmp eq i32 %51, -1
  br i1 %cmp.i.i53.i, label %luaK_jump.exit83.i, label %if.else.i.i54.i

if.else.i.i54.i:                                  ; preds = %if.then.i347
  %cmp1.i.i55.i = icmp eq i32 %call.i.i52.i, -1
  br i1 %cmp1.i.i55.i, label %if.else.i85.i, label %while.cond.preheader.i.i56.i

while.cond.preheader.i.i56.i:                     ; preds = %if.else.i.i54.i
  %fs.val.i.i57.i = load ptr, ptr %4, align 8
  %54 = getelementptr i8, ptr %fs.val.i.i57.i, i64 24
  %fs.val.val.i.i58.i = load ptr, ptr %54, align 8
  br label %while.cond.i.i59.i

while.cond.i.i59.i:                               ; preds = %while.cond.i.i59.i, %while.cond.preheader.i.i56.i
  %list.0.i.i60.i = phi i32 [ %add1.i.i.i67.i, %while.cond.i.i59.i ], [ %call.i.i52.i, %while.cond.preheader.i.i56.i ]
  %idxprom.i.i.i61.i = sext i32 %list.0.i.i60.i to i64
  %arrayidx.i.i.i62.i = getelementptr inbounds i32, ptr %fs.val.val.i.i58.i, i64 %idxprom.i.i.i61.i
  %55 = load i32, ptr %arrayidx.i.i.i62.i, align 4
  %shr.i.i.i63.i = lshr i32 %55, 14
  %sub.i.i.i64.i = add nsw i32 %shr.i.i.i63.i, -131071
  %cmp.i.i.i65.i = icmp eq i32 %sub.i.i.i64.i, -1
  %add.i.i.i66.i = add nuw nsw i32 %list.0.i.i60.i, 1
  %add1.i.i.i67.i = add nsw i32 %add.i.i.i66.i, %sub.i.i.i64.i
  %cmp4.not12.i.i68.i = icmp eq i32 %add1.i.i.i67.i, -1
  %cmp4.not.i.i69.i = select i1 %cmp.i.i.i65.i, i1 true, i1 %cmp4.not12.i.i68.i
  br i1 %cmp4.not.i.i69.i, label %while.end.i.i70.i, label %while.cond.i.i59.i, !llvm.loop !94

while.end.i.i70.i:                                ; preds = %while.cond.i.i59.i
  %add.neg.i.i.i71.i = xor i32 %list.0.i.i60.i, -1
  %sub.i7.i.i72.i = add i32 %51, %add.neg.i.i.i71.i
  %56 = call i32 @llvm.abs.i32(i32 %sub.i7.i.i72.i, i1 true)
  %cmp.i8.i.i73.i = icmp ugt i32 %56, 131071
  br i1 %cmp.i8.i.i73.i, label %if.then.i.i.i81.i, label %fixjump.exit.i.i74.i

if.then.i.i.i81.i:                                ; preds = %while.end.i.i70.i
  %57 = load ptr, ptr %ls.i.i.i359, align 8
  %t.i.i.i.i82.i = getelementptr inbounds %struct.LexState, ptr %57, i64 0, i32 3
  %58 = load i32, ptr %t.i.i.i.i82.i, align 8
  call fastcc void @luaX_lexerror(ptr noundef %57, ptr noundef nonnull @.str.148, i32 noundef %58)
  unreachable

fixjump.exit.i.i74.i:                             ; preds = %while.end.i.i70.i
  %arrayidx.i.i.i62.i.le = getelementptr inbounds i32, ptr %fs.val.val.i.i58.i, i64 %idxprom.i.i.i61.i
  %and.i.i.i76.i = and i32 %55, 16383
  %add1.i11.i.i77.i = shl i32 %sub.i7.i.i72.i, 14
  %shl.i.i.i78.i = add i32 %add1.i11.i.i77.i, 2147467264
  %or.i.i.i79.i = or disjoint i32 %shl.i.i.i78.i, %and.i.i.i76.i
  store i32 %or.i.i.i79.i, ptr %arrayidx.i.i.i62.i.le, align 4
  br label %luaK_jump.exit83.i

luaK_jump.exit83.i:                               ; preds = %fixjump.exit.i.i74.i, %if.then.i347
  %cmp.i84.i = icmp eq i32 %call.i.i52.i, -1
  br i1 %cmp.i84.i, label %luaK_concat.exit115.i, label %if.else.i85.i

if.else.i85.i:                                    ; preds = %if.else.i.i54.i, %luaK_jump.exit83.i
  %j.0.i80.i731 = phi i32 [ %call.i.i52.i, %luaK_jump.exit83.i ], [ %51, %if.else.i.i54.i ]
  %cmp1.i86.i = icmp eq i32 %escapelist.i.0, -1
  br i1 %cmp1.i86.i, label %luaK_concat.exit115.i, label %while.cond.preheader.i87.i

while.cond.preheader.i87.i:                       ; preds = %if.else.i85.i
  %fs.val.i88.i = load ptr, ptr %4, align 8
  %59 = getelementptr i8, ptr %fs.val.i88.i, i64 24
  %fs.val.val.i89.i = load ptr, ptr %59, align 8
  br label %while.cond.i90.i

while.cond.i90.i:                                 ; preds = %while.cond.i90.i, %while.cond.preheader.i87.i
  %list.0.i91.i = phi i32 [ %add1.i.i98.i, %while.cond.i90.i ], [ %escapelist.i.0, %while.cond.preheader.i87.i ]
  %idxprom.i.i92.i = sext i32 %list.0.i91.i to i64
  %arrayidx.i.i93.i = getelementptr inbounds i32, ptr %fs.val.val.i89.i, i64 %idxprom.i.i92.i
  %60 = load i32, ptr %arrayidx.i.i93.i, align 4
  %shr.i.i94.i = lshr i32 %60, 14
  %sub.i.i95.i = add nsw i32 %shr.i.i94.i, -131071
  %cmp.i.i96.i = icmp eq i32 %sub.i.i95.i, -1
  %add.i.i97.i = add nuw nsw i32 %list.0.i91.i, 1
  %add1.i.i98.i = add nsw i32 %add.i.i97.i, %sub.i.i95.i
  %cmp4.not12.i99.i = icmp eq i32 %add1.i.i98.i, -1
  %cmp4.not.i100.i = select i1 %cmp.i.i96.i, i1 true, i1 %cmp4.not12.i99.i
  br i1 %cmp4.not.i100.i, label %while.end.i101.i, label %while.cond.i90.i, !llvm.loop !94

while.end.i101.i:                                 ; preds = %while.cond.i90.i
  %add.neg.i.i102.i = xor i32 %list.0.i91.i, -1
  %sub.i7.i103.i = add i32 %j.0.i80.i731, %add.neg.i.i102.i
  %61 = call i32 @llvm.abs.i32(i32 %sub.i7.i103.i, i1 true)
  %cmp.i8.i104.i = icmp ugt i32 %61, 131071
  br i1 %cmp.i8.i104.i, label %if.then.i.i111.i, label %fixjump.exit.i105.i

if.then.i.i111.i:                                 ; preds = %while.end.i101.i
  %62 = load ptr, ptr %ls.i.i.i359, align 8
  %t.i.i.i113.i = getelementptr inbounds %struct.LexState, ptr %62, i64 0, i32 3
  %63 = load i32, ptr %t.i.i.i113.i, align 8
  call fastcc void @luaX_lexerror(ptr noundef %62, ptr noundef nonnull @.str.148, i32 noundef %63)
  unreachable

fixjump.exit.i105.i:                              ; preds = %while.end.i101.i
  %arrayidx.i.i93.i.le = getelementptr inbounds i32, ptr %fs.val.val.i89.i, i64 %idxprom.i.i92.i
  %and.i.i107.i = and i32 %60, 16383
  %add1.i11.i108.i = shl i32 %sub.i7.i103.i, 14
  %shl.i.i109.i = add i32 %add1.i11.i108.i, 2147467264
  %or.i.i110.i = or disjoint i32 %shl.i.i109.i, %and.i.i107.i
  store i32 %or.i.i110.i, ptr %arrayidx.i.i93.i.le, align 4
  br label %luaK_concat.exit115.i

luaK_concat.exit115.i:                            ; preds = %if.else.i85.i, %fixjump.exit.i105.i, %luaK_jump.exit83.i
  %escapelist.i.2 = phi i32 [ %escapelist.i.0, %luaK_jump.exit83.i ], [ %escapelist.i.0, %fixjump.exit.i105.i ], [ %j.0.i80.i731, %if.else.i85.i ]
  %64 = load i32, ptr %pc.i.i.i396, align 8
  store i32 %64, ptr %lasttarget.i.i.i397, align 4
  %cmp.i.i119.i = icmp eq i32 %flist.0.i, -1
  br i1 %cmp.i.i119.i, label %luaK_patchtohere.exit150.i, label %if.else.i.i120.i

if.else.i.i120.i:                                 ; preds = %luaK_concat.exit115.i
  %65 = load i32, ptr %jpc1.i.i358, align 4
  %cmp1.i.i121.i = icmp eq i32 %65, -1
  br i1 %cmp1.i.i121.i, label %if.then2.i.i149.i, label %while.cond.preheader.i.i122.i

while.cond.preheader.i.i122.i:                    ; preds = %if.else.i.i120.i
  %fs.val.i.i123.i = load ptr, ptr %4, align 8
  %66 = getelementptr i8, ptr %fs.val.i.i123.i, i64 24
  %fs.val.val.i.i124.i = load ptr, ptr %66, align 8
  br label %while.cond.i.i125.i

if.then2.i.i149.i:                                ; preds = %if.else.i.i120.i
  store i32 %flist.0.i, ptr %jpc1.i.i358, align 4
  br label %luaK_patchtohere.exit150.i

while.cond.i.i125.i:                              ; preds = %while.cond.i.i125.i, %while.cond.preheader.i.i122.i
  %list.0.i.i126.i = phi i32 [ %add1.i.i.i133.i, %while.cond.i.i125.i ], [ %65, %while.cond.preheader.i.i122.i ]
  %idxprom.i.i.i127.i = sext i32 %list.0.i.i126.i to i64
  %arrayidx.i.i.i128.i = getelementptr inbounds i32, ptr %fs.val.val.i.i124.i, i64 %idxprom.i.i.i127.i
  %67 = load i32, ptr %arrayidx.i.i.i128.i, align 4
  %shr.i.i.i129.i = lshr i32 %67, 14
  %sub.i.i.i130.i = add nsw i32 %shr.i.i.i129.i, -131071
  %cmp.i.i.i131.i = icmp eq i32 %sub.i.i.i130.i, -1
  %add.i.i.i132.i = add nuw nsw i32 %list.0.i.i126.i, 1
  %add1.i.i.i133.i = add nsw i32 %add.i.i.i132.i, %sub.i.i.i130.i
  %cmp4.not12.i.i134.i = icmp eq i32 %add1.i.i.i133.i, -1
  %cmp4.not.i.i135.i = select i1 %cmp.i.i.i131.i, i1 true, i1 %cmp4.not12.i.i134.i
  br i1 %cmp4.not.i.i135.i, label %while.end.i.i136.i, label %while.cond.i.i125.i, !llvm.loop !94

while.end.i.i136.i:                               ; preds = %while.cond.i.i125.i
  %add.neg.i.i.i137.i = xor i32 %list.0.i.i126.i, -1
  %sub.i7.i.i138.i = add i32 %flist.0.i, %add.neg.i.i.i137.i
  %68 = call i32 @llvm.abs.i32(i32 %sub.i7.i.i138.i, i1 true)
  %cmp.i8.i.i139.i = icmp ugt i32 %68, 131071
  br i1 %cmp.i8.i.i139.i, label %if.then.i.i.i146.i, label %fixjump.exit.i.i140.i

if.then.i.i.i146.i:                               ; preds = %while.end.i.i136.i
  %69 = load ptr, ptr %ls.i.i.i359, align 8
  %t.i.i.i.i148.i = getelementptr inbounds %struct.LexState, ptr %69, i64 0, i32 3
  %70 = load i32, ptr %t.i.i.i.i148.i, align 8
  call fastcc void @luaX_lexerror(ptr noundef %69, ptr noundef nonnull @.str.148, i32 noundef %70)
  unreachable

fixjump.exit.i.i140.i:                            ; preds = %while.end.i.i136.i
  %arrayidx.i.i.i128.i.le = getelementptr inbounds i32, ptr %fs.val.val.i.i124.i, i64 %idxprom.i.i.i127.i
  %and.i.i.i142.i = and i32 %67, 16383
  %add1.i11.i.i143.i = shl i32 %sub.i7.i.i138.i, 14
  %shl.i.i.i144.i = add i32 %add1.i11.i.i143.i, 2147467264
  %or.i.i.i145.i = or disjoint i32 %shl.i.i.i144.i, %and.i.i.i142.i
  store i32 %or.i.i.i145.i, ptr %arrayidx.i.i.i128.i.le, align 4
  br label %luaK_patchtohere.exit150.i

luaK_patchtohere.exit150.i:                       ; preds = %fixjump.exit.i.i140.i, %if.then2.i.i149.i, %luaK_concat.exit115.i
  %71 = load i32, ptr %linenumber.i, align 4
  store i32 %71, ptr %lastline.i, align 8
  %72 = load i32, ptr %lookahead.i, align 8
  %cmp.not.i.i351 = icmp eq i32 %72, 287
  br i1 %cmp.not.i.i351, label %if.else.i151.i, label %if.then.i.i353

if.then.i.i353:                                   ; preds = %luaK_patchtohere.exit150.i
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i, align 8
  br label %luaX_next.exit.i354

if.else.i151.i:                                   ; preds = %luaK_patchtohere.exit150.i
  %call.i152.i = call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i)
  store i32 %call.i152.i, ptr %t, align 8
  br label %luaX_next.exit.i354

luaX_next.exit.i354:                              ; preds = %if.else.i151.i, %if.then.i.i353
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %bl.i.i343)
  %73 = load ptr, ptr %fs1.i21, align 8
  store i32 -1, ptr %breaklist.i629, align 8
  store i8 0, ptr %isbreakable1.i630, align 2
  %nactvar.i631 = getelementptr inbounds %struct.FuncState, ptr %73, i64 0, i32 13
  %74 = load i8, ptr %nactvar.i631, align 2
  store i8 %74, ptr %nactvar2.i632, align 4
  store i8 0, ptr %upval.i633, align 1
  %bl3.i634 = getelementptr inbounds %struct.FuncState, ptr %73, i64 0, i32 5
  %75 = load ptr, ptr %bl3.i634, align 8
  store ptr %75, ptr %bl.i.i343, align 8
  store ptr %bl.i.i343, ptr %bl3.i634, align 8
  call fastcc void @chunk(ptr noundef nonnull %ls)
  call fastcc void @leaveblock(ptr noundef %73)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %bl.i.i343)
  br label %if.end.i356

if.else.i406:                                     ; preds = %while.cond.i
  %cmp.i153.i = icmp eq i32 %flist.0.i, -1
  br i1 %cmp.i153.i, label %if.end.i356, label %if.else.i154.i

if.else.i154.i:                                   ; preds = %if.else.i406
  %cmp1.i155.i = icmp eq i32 %escapelist.i.0, -1
  br i1 %cmp1.i155.i, label %if.end.i356.thread, label %while.cond.preheader.i156.i

if.end.i356.thread:                               ; preds = %if.else.i154.i
  %76 = load i32, ptr %pc.i.i.i396, align 8
  store i32 %76, ptr %lasttarget.i.i.i397, align 4
  br label %if.else.i.i189.i

while.cond.preheader.i156.i:                      ; preds = %if.else.i154.i
  %fs.val.i157.i = load ptr, ptr %4, align 8
  %77 = getelementptr i8, ptr %fs.val.i157.i, i64 24
  %fs.val.val.i158.i = load ptr, ptr %77, align 8
  br label %while.cond.i159.i

while.cond.i159.i:                                ; preds = %while.cond.i159.i, %while.cond.preheader.i156.i
  %list.0.i160.i = phi i32 [ %add1.i.i167.i, %while.cond.i159.i ], [ %escapelist.i.0, %while.cond.preheader.i156.i ]
  %idxprom.i.i161.i = sext i32 %list.0.i160.i to i64
  %arrayidx.i.i162.i = getelementptr inbounds i32, ptr %fs.val.val.i158.i, i64 %idxprom.i.i161.i
  %78 = load i32, ptr %arrayidx.i.i162.i, align 4
  %shr.i.i163.i = lshr i32 %78, 14
  %sub.i.i164.i = add nsw i32 %shr.i.i163.i, -131071
  %cmp.i.i165.i = icmp eq i32 %sub.i.i164.i, -1
  %add.i.i166.i = add nuw nsw i32 %list.0.i160.i, 1
  %add1.i.i167.i = add nsw i32 %add.i.i166.i, %sub.i.i164.i
  %cmp4.not12.i168.i = icmp eq i32 %add1.i.i167.i, -1
  %cmp4.not.i169.i = select i1 %cmp.i.i165.i, i1 true, i1 %cmp4.not12.i168.i
  br i1 %cmp4.not.i169.i, label %while.end.i170.i, label %while.cond.i159.i, !llvm.loop !94

while.end.i170.i:                                 ; preds = %while.cond.i159.i
  %add.neg.i.i171.i = xor i32 %list.0.i160.i, -1
  %sub.i7.i172.i = add i32 %flist.0.i, %add.neg.i.i171.i
  %79 = call i32 @llvm.abs.i32(i32 %sub.i7.i172.i, i1 true)
  %cmp.i8.i173.i = icmp ugt i32 %79, 131071
  br i1 %cmp.i8.i173.i, label %if.then.i.i180.i, label %fixjump.exit.i174.i

if.then.i.i180.i:                                 ; preds = %while.end.i170.i
  %80 = load ptr, ptr %ls.i.i.i359, align 8
  %t.i.i.i182.i = getelementptr inbounds %struct.LexState, ptr %80, i64 0, i32 3
  %81 = load i32, ptr %t.i.i.i182.i, align 8
  call fastcc void @luaX_lexerror(ptr noundef %80, ptr noundef nonnull @.str.148, i32 noundef %81)
  unreachable

fixjump.exit.i174.i:                              ; preds = %while.end.i170.i
  %arrayidx.i.i162.i.le = getelementptr inbounds i32, ptr %fs.val.val.i158.i, i64 %idxprom.i.i161.i
  %and.i.i176.i = and i32 %78, 16383
  %add1.i11.i177.i = shl i32 %sub.i7.i172.i, 14
  %shl.i.i178.i = add i32 %add1.i11.i177.i, 2147467264
  %or.i.i179.i = or disjoint i32 %shl.i.i178.i, %and.i.i176.i
  store i32 %or.i.i179.i, ptr %arrayidx.i.i162.i.le, align 4
  br label %if.end.i356

if.end.i356:                                      ; preds = %if.else.i406, %fixjump.exit.i174.i, %luaX_next.exit.i354
  %escapelist.i.4 = phi i32 [ %escapelist.i.2, %luaX_next.exit.i354 ], [ %escapelist.i.0, %if.else.i406 ], [ %escapelist.i.0, %fixjump.exit.i174.i ]
  %82 = load i32, ptr %pc.i.i.i396, align 8
  store i32 %82, ptr %lasttarget.i.i.i397, align 4
  %cmp.i.i188.i = icmp eq i32 %escapelist.i.4, -1
  br i1 %cmp.i.i188.i, label %ifstat.exit, label %if.else.i.i189.i

if.else.i.i189.i:                                 ; preds = %if.end.i356.thread, %if.end.i356
  %escapelist.i.4737 = phi i32 [ %flist.0.i, %if.end.i356.thread ], [ %escapelist.i.4, %if.end.i356 ]
  %83 = load i32, ptr %jpc1.i.i358, align 4
  %cmp1.i.i190.i = icmp eq i32 %83, -1
  br i1 %cmp1.i.i190.i, label %if.then2.i.i218.i, label %while.cond.preheader.i.i191.i

while.cond.preheader.i.i191.i:                    ; preds = %if.else.i.i189.i
  %fs.val.i.i192.i = load ptr, ptr %4, align 8
  %84 = getelementptr i8, ptr %fs.val.i.i192.i, i64 24
  %fs.val.val.i.i193.i = load ptr, ptr %84, align 8
  br label %while.cond.i.i194.i

if.then2.i.i218.i:                                ; preds = %if.else.i.i189.i
  store i32 %escapelist.i.4737, ptr %jpc1.i.i358, align 4
  br label %ifstat.exit

while.cond.i.i194.i:                              ; preds = %while.cond.i.i194.i, %while.cond.preheader.i.i191.i
  %list.0.i.i195.i = phi i32 [ %add1.i.i.i202.i, %while.cond.i.i194.i ], [ %83, %while.cond.preheader.i.i191.i ]
  %idxprom.i.i.i196.i = sext i32 %list.0.i.i195.i to i64
  %arrayidx.i.i.i197.i = getelementptr inbounds i32, ptr %fs.val.val.i.i193.i, i64 %idxprom.i.i.i196.i
  %85 = load i32, ptr %arrayidx.i.i.i197.i, align 4
  %shr.i.i.i198.i = lshr i32 %85, 14
  %sub.i.i.i199.i = add nsw i32 %shr.i.i.i198.i, -131071
  %cmp.i.i.i200.i = icmp eq i32 %sub.i.i.i199.i, -1
  %add.i.i.i201.i = add nuw nsw i32 %list.0.i.i195.i, 1
  %add1.i.i.i202.i = add nsw i32 %add.i.i.i201.i, %sub.i.i.i199.i
  %cmp4.not12.i.i203.i = icmp eq i32 %add1.i.i.i202.i, -1
  %cmp4.not.i.i204.i = select i1 %cmp.i.i.i200.i, i1 true, i1 %cmp4.not12.i.i203.i
  br i1 %cmp4.not.i.i204.i, label %while.end.i.i205.i, label %while.cond.i.i194.i, !llvm.loop !94

while.end.i.i205.i:                               ; preds = %while.cond.i.i194.i
  %add.neg.i.i.i206.i = xor i32 %list.0.i.i195.i, -1
  %sub.i7.i.i207.i = add i32 %escapelist.i.4737, %add.neg.i.i.i206.i
  %86 = call i32 @llvm.abs.i32(i32 %sub.i7.i.i207.i, i1 true)
  %cmp.i8.i.i208.i = icmp ugt i32 %86, 131071
  br i1 %cmp.i8.i.i208.i, label %if.then.i.i.i215.i, label %fixjump.exit.i.i209.i

if.then.i.i.i215.i:                               ; preds = %while.end.i.i205.i
  %87 = load ptr, ptr %ls.i.i.i359, align 8
  %t.i.i.i.i217.i = getelementptr inbounds %struct.LexState, ptr %87, i64 0, i32 3
  %88 = load i32, ptr %t.i.i.i.i217.i, align 8
  call fastcc void @luaX_lexerror(ptr noundef %87, ptr noundef nonnull @.str.148, i32 noundef %88)
  unreachable

fixjump.exit.i.i209.i:                            ; preds = %while.end.i.i205.i
  %arrayidx.i.i.i197.i.le = getelementptr inbounds i32, ptr %fs.val.val.i.i193.i, i64 %idxprom.i.i.i196.i
  %and.i.i.i211.i = and i32 %85, 16383
  %add1.i11.i.i212.i = shl i32 %sub.i7.i.i207.i, 14
  %shl.i.i.i213.i = add i32 %add1.i11.i.i212.i, 2147467264
  %or.i.i.i214.i = or disjoint i32 %shl.i.i.i213.i, %and.i.i.i211.i
  store i32 %or.i.i.i214.i, ptr %arrayidx.i.i.i197.i.le, align 4
  br label %ifstat.exit

ifstat.exit:                                      ; preds = %if.end.i356, %if.then2.i.i218.i, %fixjump.exit.i.i209.i
  call fastcc void @check_match(ptr noundef %ls, i32 noundef 262, i32 noundef 266, i32 noundef %3)
  br label %statement.exit

sw.bb1.i:                                         ; preds = %while.body
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %bl.i235)
  %89 = load ptr, ptr %fs1.i21, align 8
  store i32 %3, ptr %lastline.i, align 8
  %90 = load i32, ptr %lookahead.i, align 8
  %cmp.not.i.i240 = icmp eq i32 %90, 287
  br i1 %cmp.not.i.i240, label %if.else.i.i340, label %if.then.i.i242

if.then.i.i242:                                   ; preds = %sw.bb1.i
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i, align 8
  br label %luaX_next.exit.i243

if.else.i.i340:                                   ; preds = %sw.bb1.i
  %call.i.i342 = call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i)
  store i32 %call.i.i342, ptr %t, align 8
  br label %luaX_next.exit.i243

luaX_next.exit.i243:                              ; preds = %if.else.i.i340, %if.then.i.i242
  %pc.i.i244 = getelementptr inbounds %struct.FuncState, ptr %89, i64 0, i32 6
  %91 = load i32, ptr %pc.i.i244, align 8
  %lasttarget.i.i245 = getelementptr inbounds %struct.FuncState, ptr %89, i64 0, i32 7
  store i32 %91, ptr %lasttarget.i.i245, align 4
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %v.i.i234)
  %call.i628 = call fastcc i32 @subexpr(ptr noundef nonnull %ls, ptr noundef nonnull %v.i.i234, i32 noundef 0), !range !93
  %92 = load i32, ptr %v.i.i234, align 8
  %cmp.i.i246 = icmp eq i32 %92, 1
  br i1 %cmp.i.i246, label %if.then.i11.i, label %cond.exit.i247

if.then.i11.i:                                    ; preds = %luaX_next.exit.i243
  store i32 3, ptr %v.i.i234, align 8
  br label %cond.exit.i247

cond.exit.i247:                                   ; preds = %if.then.i11.i, %luaX_next.exit.i243
  %93 = load ptr, ptr %fs1.i21, align 8
  call fastcc void @luaK_goiftrue(ptr noundef %93, ptr noundef nonnull %v.i.i234)
  %94 = load i32, ptr %f.i.i249, align 4
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %v.i.i234)
  store i32 -1, ptr %breaklist.i.i250, align 8
  store i8 1, ptr %isbreakable1.i.i251, align 2
  %nactvar.i.i252 = getelementptr inbounds %struct.FuncState, ptr %89, i64 0, i32 13
  %95 = load i8, ptr %nactvar.i.i252, align 2
  store i8 %95, ptr %nactvar2.i.i253, align 4
  store i8 0, ptr %upval.i.i254, align 1
  %bl3.i.i255 = getelementptr inbounds %struct.FuncState, ptr %89, i64 0, i32 5
  %96 = load ptr, ptr %bl3.i.i255, align 8
  store ptr %96, ptr %bl.i235, align 8
  store ptr %bl.i235, ptr %bl3.i.i255, align 8
  %97 = load i32, ptr %t, align 8
  %cmp.not.i.i.i257 = icmp eq i32 %97, 259
  br i1 %cmp.not.i.i.i257, label %check.exit.i.i261, label %if.then.i.i.i258

if.then.i.i.i258:                                 ; preds = %cond.exit.i247
  %98 = load ptr, ptr %L.i, align 8
  %call1.i.i.i.i260 = call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %98, ptr noundef nonnull @.str.164, ptr noundef nonnull @.str.65)
  %99 = load i32, ptr %t, align 8
  call fastcc void @luaX_lexerror(ptr noundef nonnull %ls, ptr noundef %call1.i.i.i.i260, i32 noundef %99)
  unreachable

check.exit.i.i261:                                ; preds = %cond.exit.i247
  %100 = load i32, ptr %linenumber.i, align 4
  store i32 %100, ptr %lastline.i, align 8
  %101 = load i32, ptr %lookahead.i, align 8
  %cmp.not.i2.i.i = icmp eq i32 %101, 287
  br i1 %cmp.not.i2.i.i, label %if.else.i.i.i337, label %if.then.i3.i.i

if.then.i3.i.i:                                   ; preds = %check.exit.i.i261
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i, align 8
  br label %checknext.exit.i

if.else.i.i.i337:                                 ; preds = %check.exit.i.i261
  %call.i.i.i339 = call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i)
  store i32 %call.i.i.i339, ptr %t, align 8
  br label %checknext.exit.i

checknext.exit.i:                                 ; preds = %if.else.i.i.i337, %if.then.i3.i.i
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %bl.i.i)
  %102 = load ptr, ptr %fs1.i21, align 8
  store i32 -1, ptr %breaklist.i, align 8
  store i8 0, ptr %isbreakable1.i, align 2
  %nactvar.i626 = getelementptr inbounds %struct.FuncState, ptr %102, i64 0, i32 13
  %103 = load i8, ptr %nactvar.i626, align 2
  store i8 %103, ptr %nactvar2.i, align 4
  store i8 0, ptr %upval.i627, align 1
  %bl3.i = getelementptr inbounds %struct.FuncState, ptr %102, i64 0, i32 5
  %104 = load ptr, ptr %bl3.i, align 8
  store ptr %104, ptr %bl.i.i, align 8
  store ptr %bl.i.i, ptr %bl3.i, align 8
  call fastcc void @chunk(ptr noundef nonnull %ls)
  call fastcc void @leaveblock(ptr noundef %102)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %bl.i.i)
  %jpc1.i.i266 = getelementptr inbounds %struct.FuncState, ptr %89, i64 0, i32 8
  %105 = load i32, ptr %jpc1.i.i266, align 8
  store i32 -1, ptr %jpc1.i.i266, align 8
  %ls.i.i.i267 = getelementptr inbounds %struct.FuncState, ptr %89, i64 0, i32 3
  %106 = load ptr, ptr %ls.i.i.i267, align 8
  %lastline.i.i12.i = getelementptr inbounds %struct.LexState, ptr %106, i64 0, i32 2
  %107 = load i32, ptr %lastline.i.i12.i, align 8
  %call.i.i13.i = call fastcc i32 @luaK_code(ptr noundef nonnull %89, i32 noundef 2147450902, i32 noundef %107)
  %cmp.i.i.i268 = icmp eq i32 %105, -1
  br i1 %cmp.i.i.i268, label %luaK_jump.exit.i294, label %if.else.i.i14.i

if.else.i.i14.i:                                  ; preds = %checknext.exit.i
  %cmp1.i.i.i269 = icmp eq i32 %call.i.i13.i, -1
  br i1 %cmp1.i.i.i269, label %luaK_jump.exit.i294, label %while.cond.preheader.i.i.i270

while.cond.preheader.i.i.i270:                    ; preds = %if.else.i.i14.i
  %fs.val.i.i.i271 = load ptr, ptr %89, align 8
  %108 = getelementptr i8, ptr %fs.val.i.i.i271, i64 24
  %fs.val.val.i.i.i272 = load ptr, ptr %108, align 8
  br label %while.cond.i.i.i273

while.cond.i.i.i273:                              ; preds = %while.cond.i.i.i273, %while.cond.preheader.i.i.i270
  %list.0.i.i.i274 = phi i32 [ %add1.i.i.i.i281, %while.cond.i.i.i273 ], [ %call.i.i13.i, %while.cond.preheader.i.i.i270 ]
  %idxprom.i.i.i.i275 = sext i32 %list.0.i.i.i274 to i64
  %arrayidx.i.i.i.i276 = getelementptr inbounds i32, ptr %fs.val.val.i.i.i272, i64 %idxprom.i.i.i.i275
  %109 = load i32, ptr %arrayidx.i.i.i.i276, align 4
  %shr.i.i.i.i277 = lshr i32 %109, 14
  %sub.i.i.i.i278 = add nsw i32 %shr.i.i.i.i277, -131071
  %cmp.i.i.i.i279 = icmp eq i32 %sub.i.i.i.i278, -1
  %add.i.i.i.i280 = add nuw nsw i32 %list.0.i.i.i274, 1
  %add1.i.i.i.i281 = add nsw i32 %add.i.i.i.i280, %sub.i.i.i.i278
  %cmp4.not12.i.i.i282 = icmp eq i32 %add1.i.i.i.i281, -1
  %cmp4.not.i.i.i283 = select i1 %cmp.i.i.i.i279, i1 true, i1 %cmp4.not12.i.i.i282
  br i1 %cmp4.not.i.i.i283, label %while.end.i.i.i284, label %while.cond.i.i.i273, !llvm.loop !94

while.end.i.i.i284:                               ; preds = %while.cond.i.i.i273
  %add.neg.i.i.i.i285 = xor i32 %list.0.i.i.i274, -1
  %sub.i7.i.i.i286 = add i32 %105, %add.neg.i.i.i.i285
  %110 = call i32 @llvm.abs.i32(i32 %sub.i7.i.i.i286, i1 true)
  %cmp.i8.i.i.i287 = icmp ugt i32 %110, 131071
  br i1 %cmp.i8.i.i.i287, label %if.then.i.i.i.i335, label %fixjump.exit.i.i.i288

if.then.i.i.i.i335:                               ; preds = %while.end.i.i.i284
  %ls.i.i.i267.le1046 = getelementptr inbounds %struct.FuncState, ptr %89, i64 0, i32 3
  %111 = load ptr, ptr %ls.i.i.i267.le1046, align 8
  %t.i.i.i.i.i336 = getelementptr inbounds %struct.LexState, ptr %111, i64 0, i32 3
  %112 = load i32, ptr %t.i.i.i.i.i336, align 8
  call fastcc void @luaX_lexerror(ptr noundef %111, ptr noundef nonnull @.str.148, i32 noundef %112)
  unreachable

fixjump.exit.i.i.i288:                            ; preds = %while.end.i.i.i284
  %arrayidx.i.i.i.i276.le = getelementptr inbounds i32, ptr %fs.val.val.i.i.i272, i64 %idxprom.i.i.i.i275
  %and.i.i.i.i290 = and i32 %109, 16383
  %add1.i11.i.i.i291 = shl i32 %sub.i7.i.i.i286, 14
  %shl.i.i.i.i292 = add i32 %add1.i11.i.i.i291, 2147467264
  %or.i.i.i.i293 = or disjoint i32 %shl.i.i.i.i292, %and.i.i.i.i290
  store i32 %or.i.i.i.i293, ptr %arrayidx.i.i.i.i276.le, align 4
  br label %luaK_jump.exit.i294

luaK_jump.exit.i294:                              ; preds = %fixjump.exit.i.i.i288, %if.else.i.i14.i, %checknext.exit.i
  %j.0.i.i295 = phi i32 [ %call.i.i13.i, %checknext.exit.i ], [ %call.i.i13.i, %fixjump.exit.i.i.i288 ], [ %105, %if.else.i.i14.i ]
  %113 = load i32, ptr %pc.i.i244, align 8
  %cmp.i16.i = icmp eq i32 %113, %91
  br i1 %cmp.i16.i, label %if.then.i18.i, label %if.else.i17.i

if.then.i18.i:                                    ; preds = %luaK_jump.exit.i294
  store i32 %91, ptr %lasttarget.i.i245, align 4
  %cmp.i.i.i19.i = icmp eq i32 %j.0.i.i295, -1
  br i1 %cmp.i.i.i19.i, label %luaK_patchlist.exit.i296, label %if.else.i.i.i.i305

if.else.i.i.i.i305:                               ; preds = %if.then.i18.i
  %114 = load i32, ptr %jpc1.i.i266, align 4
  %cmp1.i.i.i.i306 = icmp eq i32 %114, -1
  br i1 %cmp1.i.i.i.i306, label %if.then2.i.i.i.i334, label %while.cond.preheader.i.i.i.i307

while.cond.preheader.i.i.i.i307:                  ; preds = %if.else.i.i.i.i305
  %fs.val.i.i.i.i308 = load ptr, ptr %89, align 8
  %115 = getelementptr i8, ptr %fs.val.i.i.i.i308, i64 24
  %fs.val.val.i.i.i.i309 = load ptr, ptr %115, align 8
  br label %while.cond.i.i.i.i310

if.then2.i.i.i.i334:                              ; preds = %if.else.i.i.i.i305
  store i32 %j.0.i.i295, ptr %jpc1.i.i266, align 4
  br label %luaK_patchlist.exit.i296

while.cond.i.i.i.i310:                            ; preds = %while.cond.i.i.i.i310, %while.cond.preheader.i.i.i.i307
  %list.0.i.i.i.i311 = phi i32 [ %add1.i.i.i.i.i318, %while.cond.i.i.i.i310 ], [ %114, %while.cond.preheader.i.i.i.i307 ]
  %idxprom.i.i.i.i.i312 = sext i32 %list.0.i.i.i.i311 to i64
  %arrayidx.i.i.i.i.i313 = getelementptr inbounds i32, ptr %fs.val.val.i.i.i.i309, i64 %idxprom.i.i.i.i.i312
  %116 = load i32, ptr %arrayidx.i.i.i.i.i313, align 4
  %shr.i.i.i.i.i314 = lshr i32 %116, 14
  %sub.i.i.i.i.i315 = add nsw i32 %shr.i.i.i.i.i314, -131071
  %cmp.i.i.i.i.i316 = icmp eq i32 %sub.i.i.i.i.i315, -1
  %add.i.i.i.i.i317 = add nuw nsw i32 %list.0.i.i.i.i311, 1
  %add1.i.i.i.i.i318 = add nsw i32 %add.i.i.i.i.i317, %sub.i.i.i.i.i315
  %cmp4.not12.i.i.i.i319 = icmp eq i32 %add1.i.i.i.i.i318, -1
  %cmp4.not.i.i.i.i320 = select i1 %cmp.i.i.i.i.i316, i1 true, i1 %cmp4.not12.i.i.i.i319
  br i1 %cmp4.not.i.i.i.i320, label %while.end.i.i.i.i321, label %while.cond.i.i.i.i310, !llvm.loop !94

while.end.i.i.i.i321:                             ; preds = %while.cond.i.i.i.i310
  %add.neg.i.i.i.i.i322 = xor i32 %list.0.i.i.i.i311, -1
  %sub.i7.i.i.i.i323 = add i32 %j.0.i.i295, %add.neg.i.i.i.i.i322
  %117 = call i32 @llvm.abs.i32(i32 %sub.i7.i.i.i.i323, i1 true)
  %cmp.i8.i.i.i.i324 = icmp ugt i32 %117, 131071
  br i1 %cmp.i8.i.i.i.i324, label %if.then.i.i.i.i.i331, label %fixjump.exit.i.i.i.i325

if.then.i.i.i.i.i331:                             ; preds = %while.end.i.i.i.i321
  %ls.i.i.i267.le1044 = getelementptr inbounds %struct.FuncState, ptr %89, i64 0, i32 3
  %118 = load ptr, ptr %ls.i.i.i267.le1044, align 8
  %t.i.i.i.i.i.i333 = getelementptr inbounds %struct.LexState, ptr %118, i64 0, i32 3
  %119 = load i32, ptr %t.i.i.i.i.i.i333, align 8
  call fastcc void @luaX_lexerror(ptr noundef %118, ptr noundef nonnull @.str.148, i32 noundef %119)
  unreachable

fixjump.exit.i.i.i.i325:                          ; preds = %while.end.i.i.i.i321
  %arrayidx.i.i.i.i.i313.le = getelementptr inbounds i32, ptr %fs.val.val.i.i.i.i309, i64 %idxprom.i.i.i.i.i312
  %and.i.i.i.i.i327 = and i32 %116, 16383
  %add1.i11.i.i.i.i328 = shl i32 %sub.i7.i.i.i.i323, 14
  %shl.i.i.i.i.i329 = add i32 %add1.i11.i.i.i.i328, 2147467264
  %or.i.i.i.i.i330 = or disjoint i32 %shl.i.i.i.i.i329, %and.i.i.i.i.i327
  store i32 %or.i.i.i.i.i330, ptr %arrayidx.i.i.i.i.i313.le, align 4
  br label %luaK_patchlist.exit.i296

if.else.i17.i:                                    ; preds = %luaK_jump.exit.i294
  call fastcc void @patchlistaux(ptr noundef nonnull %89, i32 noundef %j.0.i.i295, i32 noundef %91, i32 noundef 255, i32 noundef %91)
  br label %luaK_patchlist.exit.i296

luaK_patchlist.exit.i296:                         ; preds = %if.else.i17.i, %fixjump.exit.i.i.i.i325, %if.then2.i.i.i.i334, %if.then.i18.i
  call fastcc void @check_match(ptr noundef %ls, i32 noundef 262, i32 noundef 277, i32 noundef %3)
  call fastcc void @leaveblock(ptr noundef %89)
  %120 = load i32, ptr %pc.i.i244, align 8
  store i32 %120, ptr %lasttarget.i.i245, align 4
  %cmp.i.i20.i = icmp eq i32 %94, -1
  br i1 %cmp.i.i20.i, label %whilestat.exit, label %if.else.i.i21.i

if.else.i.i21.i:                                  ; preds = %luaK_patchlist.exit.i296
  %121 = load i32, ptr %jpc1.i.i266, align 4
  %cmp1.i.i22.i = icmp eq i32 %121, -1
  br i1 %cmp1.i.i22.i, label %if.then2.i.i.i302, label %while.cond.preheader.i.i23.i

while.cond.preheader.i.i23.i:                     ; preds = %if.else.i.i21.i
  %fs.val.i.i24.i = load ptr, ptr %89, align 8
  %122 = getelementptr i8, ptr %fs.val.i.i24.i, i64 24
  %fs.val.val.i.i25.i = load ptr, ptr %122, align 8
  br label %while.cond.i.i26.i

if.then2.i.i.i302:                                ; preds = %if.else.i.i21.i
  store i32 %94, ptr %jpc1.i.i266, align 4
  br label %whilestat.exit

while.cond.i.i26.i:                               ; preds = %while.cond.i.i26.i, %while.cond.preheader.i.i23.i
  %list.0.i.i27.i = phi i32 [ %add1.i.i.i34.i, %while.cond.i.i26.i ], [ %121, %while.cond.preheader.i.i23.i ]
  %idxprom.i.i.i28.i = sext i32 %list.0.i.i27.i to i64
  %arrayidx.i.i.i29.i = getelementptr inbounds i32, ptr %fs.val.val.i.i25.i, i64 %idxprom.i.i.i28.i
  %123 = load i32, ptr %arrayidx.i.i.i29.i, align 4
  %shr.i.i.i30.i = lshr i32 %123, 14
  %sub.i.i.i31.i = add nsw i32 %shr.i.i.i30.i, -131071
  %cmp.i.i.i32.i = icmp eq i32 %sub.i.i.i31.i, -1
  %add.i.i.i33.i = add nuw nsw i32 %list.0.i.i27.i, 1
  %add1.i.i.i34.i = add nsw i32 %add.i.i.i33.i, %sub.i.i.i31.i
  %cmp4.not12.i.i35.i = icmp eq i32 %add1.i.i.i34.i, -1
  %cmp4.not.i.i36.i = select i1 %cmp.i.i.i32.i, i1 true, i1 %cmp4.not12.i.i35.i
  br i1 %cmp4.not.i.i36.i, label %while.end.i.i37.i, label %while.cond.i.i26.i, !llvm.loop !94

while.end.i.i37.i:                                ; preds = %while.cond.i.i26.i
  %add.neg.i.i.i38.i = xor i32 %list.0.i.i27.i, -1
  %sub.i7.i.i39.i = add i32 %94, %add.neg.i.i.i38.i
  %124 = call i32 @llvm.abs.i32(i32 %sub.i7.i.i39.i, i1 true)
  %cmp.i8.i.i40.i = icmp ugt i32 %124, 131071
  br i1 %cmp.i8.i.i40.i, label %if.then.i.i.i47.i, label %fixjump.exit.i.i41.i

if.then.i.i.i47.i:                                ; preds = %while.end.i.i37.i
  %ls.i.i.i267.le = getelementptr inbounds %struct.FuncState, ptr %89, i64 0, i32 3
  %125 = load ptr, ptr %ls.i.i.i267.le, align 8
  %t.i.i.i.i48.i = getelementptr inbounds %struct.LexState, ptr %125, i64 0, i32 3
  %126 = load i32, ptr %t.i.i.i.i48.i, align 8
  call fastcc void @luaX_lexerror(ptr noundef %125, ptr noundef nonnull @.str.148, i32 noundef %126)
  unreachable

fixjump.exit.i.i41.i:                             ; preds = %while.end.i.i37.i
  %arrayidx.i.i.i29.i.le = getelementptr inbounds i32, ptr %fs.val.val.i.i25.i, i64 %idxprom.i.i.i28.i
  %and.i.i.i43.i = and i32 %123, 16383
  %add1.i11.i.i44.i = shl i32 %sub.i7.i.i39.i, 14
  %shl.i.i.i45.i = add i32 %add1.i11.i.i44.i, 2147467264
  %or.i.i.i46.i = or disjoint i32 %shl.i.i.i45.i, %and.i.i.i43.i
  store i32 %or.i.i.i46.i, ptr %arrayidx.i.i.i29.i.le, align 4
  br label %whilestat.exit

whilestat.exit:                                   ; preds = %luaK_patchlist.exit.i296, %if.then2.i.i.i302, %fixjump.exit.i.i41.i
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %bl.i235)
  br label %statement.exit

sw.bb2.i:                                         ; preds = %while.body
  store i32 %3, ptr %lastline.i, align 8
  %127 = load i32, ptr %lookahead.i, align 8
  %cmp.not.i226 = icmp eq i32 %127, 287
  br i1 %cmp.not.i226, label %if.else.i230, label %if.then.i228

if.then.i228:                                     ; preds = %sw.bb2.i
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i, align 8
  br label %luaX_next.exit233

if.else.i230:                                     ; preds = %sw.bb2.i
  %call.i232 = call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i)
  store i32 %call.i232, ptr %t, align 8
  br label %luaX_next.exit233

luaX_next.exit233:                                ; preds = %if.then.i228, %if.else.i230
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %bl.i215)
  %128 = load ptr, ptr %fs1.i21, align 8
  store i32 -1, ptr %breaklist.i.i217, align 8
  store i8 0, ptr %isbreakable1.i.i218, align 2
  %nactvar.i.i219 = getelementptr inbounds %struct.FuncState, ptr %128, i64 0, i32 13
  %129 = load i8, ptr %nactvar.i.i219, align 2
  store i8 %129, ptr %nactvar2.i.i220, align 4
  store i8 0, ptr %upval.i.i221, align 1
  %bl3.i.i222 = getelementptr inbounds %struct.FuncState, ptr %128, i64 0, i32 5
  %130 = load ptr, ptr %bl3.i.i222, align 8
  store ptr %130, ptr %bl.i215, align 8
  store ptr %bl.i215, ptr %bl3.i.i222, align 8
  call fastcc void @chunk(ptr noundef nonnull %ls)
  call fastcc void @leaveblock(ptr noundef %128)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %bl.i215)
  call fastcc void @check_match(ptr noundef nonnull %ls, i32 noundef 262, i32 noundef 259, i32 noundef %3)
  br label %statement.exit

sw.bb3.i:                                         ; preds = %while.body
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %bl.i)
  %131 = load ptr, ptr %fs1.i21, align 8
  store i32 -1, ptr %breaklist.i.i175, align 8
  store i8 1, ptr %isbreakable1.i.i176, align 2
  %nactvar.i.i177 = getelementptr inbounds %struct.FuncState, ptr %131, i64 0, i32 13
  %132 = load i8, ptr %nactvar.i.i177, align 2
  store i8 %132, ptr %nactvar2.i.i178, align 4
  store i8 0, ptr %upval.i.i179, align 1
  %bl3.i.i180 = getelementptr inbounds %struct.FuncState, ptr %131, i64 0, i32 5
  %133 = load ptr, ptr %bl3.i.i180, align 8
  store ptr %133, ptr %bl.i, align 8
  store ptr %bl.i, ptr %bl3.i.i180, align 8
  %134 = load i32, ptr %linenumber.i, align 4
  store i32 %134, ptr %lastline.i, align 8
  %135 = load i32, ptr %lookahead.i, align 8
  %cmp.not.i.i184 = icmp eq i32 %135, 287
  br i1 %cmp.not.i.i184, label %if.else.i.i212, label %if.then.i.i186

if.then.i.i186:                                   ; preds = %sw.bb3.i
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i, align 8
  %.pr = load i32, ptr %t, align 8
  br label %luaX_next.exit.i187

if.else.i.i212:                                   ; preds = %sw.bb3.i
  %call.i.i214 = call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i)
  store i32 %call.i.i214, ptr %t, align 8
  br label %luaX_next.exit.i187

luaX_next.exit.i187:                              ; preds = %if.else.i.i212, %if.then.i.i186
  %136 = phi i32 [ %call.i.i214, %if.else.i.i212 ], [ %.pr, %if.then.i.i186 ]
  %cmp.not.i.i.i189 = icmp eq i32 %136, 285
  br i1 %cmp.not.i.i.i189, label %check.exit.i.i193, label %if.then.i.i.i190

if.then.i.i.i190:                                 ; preds = %luaX_next.exit.i187
  %137 = load ptr, ptr %L.i, align 8
  %call1.i.i.i.i192 = call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %137, ptr noundef nonnull @.str.164, ptr noundef nonnull @.str.88)
  %138 = load i32, ptr %t, align 8
  call fastcc void @luaX_lexerror(ptr noundef nonnull %ls, ptr noundef %call1.i.i.i.i192, i32 noundef %138)
  unreachable

check.exit.i.i193:                                ; preds = %luaX_next.exit.i187
  %139 = load ptr, ptr %seminfo.i, align 8
  %140 = load i32, ptr %linenumber.i, align 4
  store i32 %140, ptr %lastline.i, align 8
  %141 = load i32, ptr %lookahead.i, align 8
  %cmp.not.i3.i.i197 = icmp eq i32 %141, 287
  br i1 %cmp.not.i3.i.i197, label %if.else.i.i.i210, label %if.then.i4.i.i198

if.then.i4.i.i198:                                ; preds = %check.exit.i.i193
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i, align 8
  %.pr739 = load i32, ptr %t, align 8
  br label %str_checkname.exit.i199

if.else.i.i.i210:                                 ; preds = %check.exit.i.i193
  %call.i.i.i211 = call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i)
  store i32 %call.i.i.i211, ptr %t, align 8
  br label %str_checkname.exit.i199

str_checkname.exit.i199:                          ; preds = %if.else.i.i.i210, %if.then.i4.i.i198
  %142 = phi i32 [ %call.i.i.i211, %if.else.i.i.i210 ], [ %.pr739, %if.then.i4.i.i198 ]
  switch i32 %142, label %sw.default.i208 [
    i32 61, label %sw.bb.i205
    i32 44, label %sw.bb2.i201
    i32 267, label %sw.bb2.i201
  ]

sw.bb.i205:                                       ; preds = %str_checkname.exit.i199
  %143 = load ptr, ptr %fs1.i21, align 8
  %freereg.i.i206 = getelementptr inbounds %struct.FuncState, ptr %143, i64 0, i32 9
  %144 = load i32, ptr %freereg.i.i206, align 4
  %call.i12.i = call fastcc ptr @luaX_newstring(ptr noundef nonnull %ls, ptr noundef nonnull @.str.166, i64 noundef 11)
  call fastcc void @new_localvar(ptr noundef nonnull %ls, ptr noundef %call.i12.i, i32 noundef 0)
  %call2.i.i = call fastcc ptr @luaX_newstring(ptr noundef nonnull %ls, ptr noundef nonnull @.str.167, i64 noundef 11)
  call fastcc void @new_localvar(ptr noundef nonnull %ls, ptr noundef %call2.i.i, i32 noundef 1)
  %call3.i.i = call fastcc ptr @luaX_newstring(ptr noundef nonnull %ls, ptr noundef nonnull @.str.168, i64 noundef 10)
  call fastcc void @new_localvar(ptr noundef nonnull %ls, ptr noundef %call3.i.i, i32 noundef 2)
  call fastcc void @new_localvar(ptr noundef nonnull %ls, ptr noundef %139, i32 noundef 3)
  call fastcc void @checknext(ptr noundef nonnull %ls, i32 noundef 61)
  call fastcc void @exp1(ptr noundef nonnull %ls)
  call fastcc void @checknext(ptr noundef nonnull %ls, i32 noundef 44)
  call fastcc void @exp1(ptr noundef nonnull %ls)
  %145 = load i32, ptr %t, align 8
  %cmp.i614 = icmp eq i32 %145, 44
  br i1 %cmp.i614, label %if.then.i616, label %if.else.i14.i

if.then.i616:                                     ; preds = %sw.bb.i205
  %146 = load i32, ptr %linenumber.i, align 4
  store i32 %146, ptr %lastline.i, align 8
  %147 = load i32, ptr %lookahead.i, align 8
  %cmp.not.i.i620 = icmp eq i32 %147, 287
  br i1 %cmp.not.i.i620, label %if.else.i.i622, label %if.then.i.i621

if.then.i.i621:                                   ; preds = %if.then.i616
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i, align 8
  br label %if.then.i13.i

if.else.i.i622:                                   ; preds = %if.then.i616
  %call.i.i624 = call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i)
  store i32 %call.i.i624, ptr %t, align 8
  br label %if.then.i13.i

if.then.i13.i:                                    ; preds = %if.then.i.i621, %if.else.i.i622
  call fastcc void @exp1(ptr noundef nonnull %ls)
  br label %fornum.exit.i

if.else.i14.i:                                    ; preds = %sw.bb.i205
  %148 = load i32, ptr %freereg.i.i206, align 4
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %o.i)
  store double 1.000000e+00, ptr %o.i, align 8
  store i32 3, ptr %tt.i, align 8
  %call.i612 = call fastcc i32 @addk(ptr noundef nonnull %143, ptr noundef nonnull %o.i, ptr noundef nonnull %o.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %o.i)
  %shl1.i = shl i32 %148, 6
  %shl2.i = shl i32 %call.i612, 14
  %or.i608 = or i32 %shl1.i, %shl2.i
  %or3.i = or disjoint i32 %or.i608, 1
  %ls.i609 = getelementptr inbounds %struct.FuncState, ptr %143, i64 0, i32 3
  %149 = load ptr, ptr %ls.i609, align 8
  %lastline.i610 = getelementptr inbounds %struct.LexState, ptr %149, i64 0, i32 2
  %150 = load i32, ptr %lastline.i610, align 8
  %call.i611 = call fastcc i32 @luaK_code(ptr noundef nonnull %143, i32 noundef %or3.i, i32 noundef %150)
  %151 = load i32, ptr %freereg.i.i206, align 4
  %add.i.i603 = add nsw i32 %151, 1
  %152 = load ptr, ptr %143, align 8
  %maxstacksize.i.i = getelementptr inbounds %struct.Proto, ptr %152, i64 0, i32 22
  %153 = load i8, ptr %maxstacksize.i.i, align 1
  %conv.i.i = zext i8 %153 to i32
  %cmp.i.i604.not = icmp slt i32 %151, %conv.i.i
  br i1 %cmp.i.i604.not, label %luaK_reserveregs.exit, label %if.then.i.i605

if.then.i.i605:                                   ; preds = %if.else.i14.i
  %cmp2.i.i = icmp sgt i32 %151, 248
  br i1 %cmp2.i.i, label %if.then4.i.i, label %if.end.i.i

if.then4.i.i:                                     ; preds = %if.then.i.i605
  %ls.i609.le = getelementptr inbounds %struct.FuncState, ptr %143, i64 0, i32 3
  %154 = load ptr, ptr %ls.i609.le, align 8
  %t.i.i.i607 = getelementptr inbounds %struct.LexState, ptr %154, i64 0, i32 3
  %155 = load i32, ptr %t.i.i.i607, align 8
  call fastcc void @luaX_lexerror(ptr noundef %154, ptr noundef nonnull @.str.150, i32 noundef %155)
  unreachable

if.end.i.i:                                       ; preds = %if.then.i.i605
  %conv5.i.i606 = trunc i32 %add.i.i603 to i8
  store i8 %conv5.i.i606, ptr %maxstacksize.i.i, align 1
  %.pre.i = load i32, ptr %freereg.i.i206, align 4
  %.pre3.i = add nsw i32 %.pre.i, 1
  br label %luaK_reserveregs.exit

luaK_reserveregs.exit:                            ; preds = %if.else.i14.i, %if.end.i.i
  %add.pre-phi.i = phi i32 [ %add.i.i603, %if.else.i14.i ], [ %.pre3.i, %if.end.i.i ]
  store i32 %add.pre-phi.i, ptr %freereg.i.i206, align 4
  br label %fornum.exit.i

fornum.exit.i:                                    ; preds = %luaK_reserveregs.exit, %if.then.i13.i
  call fastcc void @forbody(ptr noundef nonnull %ls, i32 noundef %144, i32 noundef %3, i32 noundef 1, i32 noundef 1)
  br label %forstat.exit

sw.bb2.i201:                                      ; preds = %str_checkname.exit.i199, %str_checkname.exit.i199
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %e.i.i)
  %156 = load ptr, ptr %fs1.i21, align 8
  %freereg.i16.i = getelementptr inbounds %struct.FuncState, ptr %156, i64 0, i32 9
  %157 = load i32, ptr %freereg.i16.i, align 4
  %call.i17.i = call fastcc ptr @luaX_newstring(ptr noundef nonnull %ls, ptr noundef nonnull @.str.169, i64 noundef 15)
  call fastcc void @new_localvar(ptr noundef nonnull %ls, ptr noundef %call.i17.i, i32 noundef 0)
  %call2.i18.i = call fastcc ptr @luaX_newstring(ptr noundef nonnull %ls, ptr noundef nonnull @.str.170, i64 noundef 11)
  call fastcc void @new_localvar(ptr noundef nonnull %ls, ptr noundef %call2.i18.i, i32 noundef 1)
  %call4.i19.i = call fastcc ptr @luaX_newstring(ptr noundef nonnull %ls, ptr noundef nonnull @.str.171, i64 noundef 13)
  call fastcc void @new_localvar(ptr noundef nonnull %ls, ptr noundef %call4.i19.i, i32 noundef 2)
  call fastcc void @new_localvar(ptr noundef nonnull %ls, ptr noundef %139, i32 noundef 3)
  %158 = load i32, ptr %t, align 8
  %cmp.i590872 = icmp eq i32 %158, 44
  br i1 %cmp.i590872, label %if.then.i592, label %forlist.exit.i

if.then.i592:                                     ; preds = %sw.bb2.i201, %str_checkname.exit
  %nvars.0.i.i873 = phi i32 [ %inc9.i.i, %str_checkname.exit ], [ 4, %sw.bb2.i201 ]
  %159 = load i32, ptr %linenumber.i, align 4
  store i32 %159, ptr %lastline.i, align 8
  %160 = load i32, ptr %lookahead.i, align 8
  %cmp.not.i.i596 = icmp eq i32 %160, 287
  br i1 %cmp.not.i.i596, label %if.else.i.i598, label %if.then.i.i597

if.then.i.i597:                                   ; preds = %if.then.i592
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i, align 8
  %.pr744 = load i32, ptr %t, align 8
  br label %while.body.i.i203

if.else.i.i598:                                   ; preds = %if.then.i592
  %call.i.i600 = call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i)
  store i32 %call.i.i600, ptr %t, align 8
  br label %while.body.i.i203

while.body.i.i203:                                ; preds = %if.then.i.i597, %if.else.i.i598
  %161 = phi i32 [ %.pr744, %if.then.i.i597 ], [ %call.i.i600, %if.else.i.i598 ]
  %cmp.not.i.i577 = icmp eq i32 %161, 285
  br i1 %cmp.not.i.i577, label %check.exit.i581, label %if.then.i.i578

if.then.i.i578:                                   ; preds = %while.body.i.i203
  %162 = load ptr, ptr %L.i, align 8
  %call1.i.i.i580 = call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %162, ptr noundef nonnull @.str.164, ptr noundef nonnull @.str.88)
  %163 = load i32, ptr %t, align 8
  call fastcc void @luaX_lexerror(ptr noundef nonnull %ls, ptr noundef %call1.i.i.i580, i32 noundef %163)
  unreachable

check.exit.i581:                                  ; preds = %while.body.i.i203
  %164 = load ptr, ptr %seminfo.i, align 8
  %165 = load i32, ptr %linenumber.i, align 4
  store i32 %165, ptr %lastline.i, align 8
  %166 = load i32, ptr %lookahead.i, align 8
  %cmp.not.i3.i = icmp eq i32 %166, 287
  br i1 %cmp.not.i3.i, label %if.else.i.i587, label %if.then.i4.i

if.then.i4.i:                                     ; preds = %check.exit.i581
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i, align 8
  br label %str_checkname.exit

if.else.i.i587:                                   ; preds = %check.exit.i581
  %call.i.i588 = call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i)
  store i32 %call.i.i588, ptr %t, align 8
  br label %str_checkname.exit

str_checkname.exit:                               ; preds = %if.then.i4.i, %if.else.i.i587
  %inc9.i.i = add nuw nsw i32 %nvars.0.i.i873, 1
  call fastcc void @new_localvar(ptr noundef nonnull %ls, ptr noundef %164, i32 noundef %nvars.0.i.i873)
  %167 = load i32, ptr %t, align 8
  %cmp.i590 = icmp eq i32 %167, 44
  br i1 %cmp.i590, label %if.then.i592, label %forlist.exit.i, !llvm.loop !96

forlist.exit.i:                                   ; preds = %str_checkname.exit, %sw.bb2.i201
  %168 = phi i32 [ %158, %sw.bb2.i201 ], [ %167, %str_checkname.exit ]
  %nvars.0.i.i.lcssa = phi i32 [ 4, %sw.bb2.i201 ], [ %inc9.i.i, %str_checkname.exit ]
  %cmp.not.i.i566 = icmp eq i32 %168, 267
  br i1 %cmp.not.i.i566, label %check.exit.i, label %if.then.i.i567

if.then.i.i567:                                   ; preds = %forlist.exit.i
  %169 = load ptr, ptr %L.i, align 8
  %call1.i.i.i = call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %169, ptr noundef nonnull @.str.164, ptr noundef nonnull @.str.72)
  %170 = load i32, ptr %t, align 8
  call fastcc void @luaX_lexerror(ptr noundef nonnull %ls, ptr noundef %call1.i.i.i, i32 noundef %170)
  unreachable

check.exit.i:                                     ; preds = %forlist.exit.i
  %171 = load i32, ptr %linenumber.i, align 4
  store i32 %171, ptr %lastline.i, align 8
  %172 = load i32, ptr %lookahead.i, align 8
  %cmp.not.i2.i = icmp eq i32 %172, 287
  br i1 %cmp.not.i2.i, label %if.else.i.i573, label %if.then.i3.i

if.then.i3.i:                                     ; preds = %check.exit.i
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i, align 8
  br label %checknext.exit

if.else.i.i573:                                   ; preds = %check.exit.i
  %call.i.i575 = call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i)
  store i32 %call.i.i575, ptr %t, align 8
  %.pre967 = load i32, ptr %linenumber.i, align 4
  br label %checknext.exit

checknext.exit:                                   ; preds = %if.then.i3.i, %if.else.i.i573
  %173 = phi i32 [ %171, %if.then.i3.i ], [ %.pre967, %if.else.i.i573 ]
  %call.i.i517 = call fastcc i32 @subexpr(ptr noundef nonnull %ls, ptr noundef nonnull %e.i.i, i32 noundef 0), !range !93
  %174 = load i32, ptr %t, align 8
  %cmp.i.i520875 = icmp eq i32 %174, 44
  br i1 %cmp.i.i520875, label %if.then.i.i556, label %explist1.exit

if.then.i.i556:                                   ; preds = %checknext.exit, %luaK_exp2nextreg.exit.i539
  %n.0.i876 = phi i32 [ %inc.i542, %luaK_exp2nextreg.exit.i539 ], [ 1, %checknext.exit ]
  %175 = load i32, ptr %linenumber.i, align 4
  store i32 %175, ptr %lastline.i, align 8
  %176 = load i32, ptr %lookahead.i, align 8
  %cmp.not.i.i.i560 = icmp eq i32 %176, 287
  br i1 %cmp.not.i.i.i560, label %if.else.i.i.i562, label %if.then.i.i.i561

if.then.i.i.i561:                                 ; preds = %if.then.i.i556
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i, align 8
  br label %while.body.i524

if.else.i.i.i562:                                 ; preds = %if.then.i.i556
  %call.i.i.i564 = call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i)
  store i32 %call.i.i.i564, ptr %t, align 8
  br label %while.body.i524

while.body.i524:                                  ; preds = %if.then.i.i.i561, %if.else.i.i.i562
  %177 = load ptr, ptr %fs1.i21, align 8
  call fastcc void @luaK_dischargevars(ptr noundef %177, ptr noundef nonnull %e.i.i)
  %178 = load i32, ptr %e.i.i, align 8
  %cmp.i.i.i526 = icmp eq i32 %178, 12
  br i1 %cmp.i.i.i526, label %if.then.i.i7.i, label %freeexp.exit.i.i527

if.then.i.i7.i:                                   ; preds = %while.body.i524
  %179 = load i32, ptr %u.i.i.i546, align 8
  %and.i.i.i.i547 = and i32 %179, 256
  %tobool.not.i.i.i.i548 = icmp eq i32 %and.i.i.i.i547, 0
  br i1 %tobool.not.i.i.i.i548, label %land.lhs.true.i.i.i.i549, label %freeexp.exit.i.i527

land.lhs.true.i.i.i.i549:                         ; preds = %if.then.i.i7.i
  %nactvar.i.i.i.i550 = getelementptr inbounds %struct.FuncState, ptr %177, i64 0, i32 13
  %180 = load i8, ptr %nactvar.i.i.i.i550, align 2
  %conv.i.i.i.i551 = zext i8 %180 to i32
  %cmp.not.i.i.i.i552 = icmp slt i32 %179, %conv.i.i.i.i551
  br i1 %cmp.not.i.i.i.i552, label %freeexp.exit.i.i527, label %if.then.i.i.i.i553

if.then.i.i.i.i553:                               ; preds = %land.lhs.true.i.i.i.i549
  %freereg.i.i.i.i554 = getelementptr inbounds %struct.FuncState, ptr %177, i64 0, i32 9
  %181 = load i32, ptr %freereg.i.i.i.i554, align 4
  %dec.i.i.i.i555 = add nsw i32 %181, -1
  store i32 %dec.i.i.i.i555, ptr %freereg.i.i.i.i554, align 4
  br label %freeexp.exit.i.i527

freeexp.exit.i.i527:                              ; preds = %if.then.i.i.i.i553, %land.lhs.true.i.i.i.i549, %if.then.i.i7.i, %while.body.i524
  %freereg.i.i7.i.i528 = getelementptr inbounds %struct.FuncState, ptr %177, i64 0, i32 9
  %182 = load i32, ptr %freereg.i.i7.i.i528, align 4
  %add.i.i.i.i529 = add nsw i32 %182, 1
  %183 = load ptr, ptr %177, align 8
  %maxstacksize.i.i.i.i530 = getelementptr inbounds %struct.Proto, ptr %183, i64 0, i32 22
  %184 = load i8, ptr %maxstacksize.i.i.i.i530, align 1
  %conv.i.i8.i.i531 = zext i8 %184 to i32
  %cmp.i.i.not.i.i532 = icmp slt i32 %182, %conv.i.i8.i.i531
  br i1 %cmp.i.i.not.i.i532, label %luaK_exp2nextreg.exit.i539, label %if.then.i.i9.i.i533

if.then.i.i9.i.i533:                              ; preds = %freeexp.exit.i.i527
  %cmp2.i.i.i.i534 = icmp sgt i32 %182, 248
  br i1 %cmp2.i.i.i.i534, label %if.then4.i.i.i.i543, label %if.end.i.i.i.i535

if.then4.i.i.i.i543:                              ; preds = %if.then.i.i9.i.i533
  %ls.i.i.i.i544 = getelementptr inbounds %struct.FuncState, ptr %177, i64 0, i32 3
  %185 = load ptr, ptr %ls.i.i.i.i544, align 8
  %t.i.i.i.i.i545 = getelementptr inbounds %struct.LexState, ptr %185, i64 0, i32 3
  %186 = load i32, ptr %t.i.i.i.i.i545, align 8
  call fastcc void @luaX_lexerror(ptr noundef %185, ptr noundef nonnull @.str.150, i32 noundef %186)
  unreachable

if.end.i.i.i.i535:                                ; preds = %if.then.i.i9.i.i533
  %conv5.i.i.i.i536 = trunc i32 %add.i.i.i.i529 to i8
  store i8 %conv5.i.i.i.i536, ptr %maxstacksize.i.i.i.i530, align 1
  %.pre.i.i.i537 = load i32, ptr %freereg.i.i7.i.i528, align 4
  %.pre3.i.i.i538 = add nsw i32 %.pre.i.i.i537, 1
  br label %luaK_exp2nextreg.exit.i539

luaK_exp2nextreg.exit.i539:                       ; preds = %if.end.i.i.i.i535, %freeexp.exit.i.i527
  %add.pre-phi.i.i.i540 = phi i32 [ %add.i.i.i.i529, %freeexp.exit.i.i527 ], [ %.pre3.i.i.i538, %if.end.i.i.i.i535 ]
  store i32 %add.pre-phi.i.i.i540, ptr %freereg.i.i7.i.i528, align 4
  %sub.i.i541 = add nsw i32 %add.pre-phi.i.i.i540, -1
  call fastcc void @exp2reg(ptr noundef nonnull %177, ptr noundef nonnull %e.i.i, i32 noundef %sub.i.i541)
  %call.i8.i = call fastcc i32 @subexpr(ptr noundef nonnull %ls, ptr noundef nonnull %e.i.i, i32 noundef 0), !range !93
  %inc.i542 = add nuw nsw i32 %n.0.i876, 1
  %187 = load i32, ptr %t, align 8
  %cmp.i.i520 = icmp eq i32 %187, 44
  br i1 %cmp.i.i520, label %if.then.i.i556, label %explist1.exit, !llvm.loop !97

explist1.exit:                                    ; preds = %luaK_exp2nextreg.exit.i539, %checknext.exit
  %n.0.i.lcssa = phi i32 [ 1, %checknext.exit ], [ %inc.i542, %luaK_exp2nextreg.exit.i539 ]
  %ls.val.i.i = load ptr, ptr %fs1.i21, align 8
  call fastcc void @adjust_assign(ptr %ls.val.i.i, i32 noundef 3, i32 noundef %n.0.i.lcssa, ptr noundef nonnull %e.i.i)
  %188 = load i32, ptr %freereg.i16.i, align 4
  %add.i = add nsw i32 %188, 3
  %189 = load ptr, ptr %156, align 8
  %maxstacksize.i = getelementptr inbounds %struct.Proto, ptr %189, i64 0, i32 22
  %190 = load i8, ptr %maxstacksize.i, align 1
  %conv.i512 = zext i8 %190 to i32
  %cmp.i513 = icmp sgt i32 %add.i, %conv.i512
  br i1 %cmp.i513, label %if.then.i514, label %luaK_checkstack.exit

if.then.i514:                                     ; preds = %explist1.exit
  %cmp2.i = icmp sgt i32 %188, 246
  br i1 %cmp2.i, label %if.then4.i, label %if.end.i515

if.then4.i:                                       ; preds = %if.then.i514
  %ls.i = getelementptr inbounds %struct.FuncState, ptr %156, i64 0, i32 3
  %191 = load ptr, ptr %ls.i, align 8
  %t.i.i516 = getelementptr inbounds %struct.LexState, ptr %191, i64 0, i32 3
  %192 = load i32, ptr %t.i.i516, align 8
  call fastcc void @luaX_lexerror(ptr noundef %191, ptr noundef nonnull @.str.150, i32 noundef %192)
  unreachable

if.end.i515:                                      ; preds = %if.then.i514
  %conv5.i = trunc i32 %add.i to i8
  store i8 %conv5.i, ptr %maxstacksize.i, align 1
  br label %luaK_checkstack.exit

luaK_checkstack.exit:                             ; preds = %explist1.exit, %if.end.i515
  %sub.i.i204 = add nsw i32 %nvars.0.i.i.lcssa, -3
  call fastcc void @forbody(ptr noundef nonnull %ls, i32 noundef %157, i32 noundef %173, i32 noundef %sub.i.i204, i32 noundef 0)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %e.i.i)
  br label %forstat.exit

sw.default.i208:                                  ; preds = %str_checkname.exit.i199
  call fastcc void @luaX_lexerror(ptr noundef nonnull %ls, ptr noundef nonnull @.str.165, i32 noundef %142)
  unreachable

forstat.exit:                                     ; preds = %fornum.exit.i, %luaK_checkstack.exit
  call fastcc void @check_match(ptr noundef nonnull %ls, i32 noundef 262, i32 noundef 264, i32 noundef %3)
  call fastcc void @leaveblock(ptr noundef %131)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %bl.i)
  br label %statement.exit

sw.bb4.i:                                         ; preds = %while.body
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %bl1.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %bl2.i)
  %193 = load ptr, ptr %fs1.i21, align 8
  %pc.i.i145 = getelementptr inbounds %struct.FuncState, ptr %193, i64 0, i32 6
  %194 = load i32, ptr %pc.i.i145, align 8
  %lasttarget.i.i = getelementptr inbounds %struct.FuncState, ptr %193, i64 0, i32 7
  store i32 %194, ptr %lasttarget.i.i, align 4
  store i32 -1, ptr %breaklist.i.i, align 8
  store i8 1, ptr %isbreakable1.i.i, align 2
  %nactvar.i.i146 = getelementptr inbounds %struct.FuncState, ptr %193, i64 0, i32 13
  %195 = load i8, ptr %nactvar.i.i146, align 2
  store i8 %195, ptr %nactvar2.i.i, align 4
  store i8 0, ptr %upval.i.i, align 1
  %bl3.i.i = getelementptr inbounds %struct.FuncState, ptr %193, i64 0, i32 5
  %196 = load ptr, ptr %bl3.i.i, align 8
  store ptr %196, ptr %bl1.i, align 8
  store i32 -1, ptr %breaklist.i17.i, align 8
  store i8 0, ptr %isbreakable1.i18.i, align 2
  store i8 %195, ptr %nactvar2.i20.i, align 4
  store i8 0, ptr %upval.i21.i, align 1
  store ptr %bl1.i, ptr %bl2.i, align 8
  store ptr %bl2.i, ptr %bl3.i.i, align 8
  %197 = load i32, ptr %linenumber.i, align 4
  store i32 %197, ptr %lastline.i, align 8
  %198 = load i32, ptr %lookahead.i, align 8
  %cmp.not.i.i150 = icmp eq i32 %198, 287
  br i1 %cmp.not.i.i150, label %if.else.i.i171, label %if.then.i.i152

if.then.i.i152:                                   ; preds = %sw.bb4.i
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i, align 8
  br label %luaX_next.exit.i153

if.else.i.i171:                                   ; preds = %sw.bb4.i
  %call.i.i173 = call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i)
  store i32 %call.i.i173, ptr %t, align 8
  br label %luaX_next.exit.i153

luaX_next.exit.i153:                              ; preds = %if.else.i.i171, %if.then.i.i152
  call fastcc void @chunk(ptr noundef nonnull %ls)
  call fastcc void @check_match(ptr noundef nonnull %ls, i32 noundef 276, i32 noundef 272, i32 noundef %3)
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %v.i.i)
  %call.i510 = call fastcc i32 @subexpr(ptr noundef nonnull %ls, ptr noundef nonnull %v.i.i, i32 noundef 0), !range !93
  %199 = load i32, ptr %v.i.i, align 8
  %cmp.i.i154 = icmp eq i32 %199, 1
  br i1 %cmp.i.i154, label %if.then.i23.i, label %cond.exit.i

if.then.i23.i:                                    ; preds = %luaX_next.exit.i153
  store i32 3, ptr %v.i.i, align 8
  br label %cond.exit.i

cond.exit.i:                                      ; preds = %if.then.i23.i, %luaX_next.exit.i153
  %200 = load ptr, ptr %fs1.i21, align 8
  call fastcc void @luaK_goiftrue(ptr noundef %200, ptr noundef nonnull %v.i.i)
  %201 = load i32, ptr %f.i.i156, align 4
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %v.i.i)
  %202 = load i8, ptr %upval.i21.i, align 1
  %tobool.not.i157 = icmp eq i8 %202, 0
  br i1 %tobool.not.i157, label %if.then.i170, label %if.else.i158

if.then.i170:                                     ; preds = %cond.exit.i
  call fastcc void @leaveblock(ptr noundef nonnull %193)
  %203 = load ptr, ptr %fs1.i21, align 8
  %pc.i24.i = getelementptr inbounds %struct.FuncState, ptr %203, i64 0, i32 6
  %204 = load i32, ptr %pc.i24.i, align 8
  %cmp.i25.i = icmp eq i32 %204, %194
  br i1 %cmp.i25.i, label %if.then.i27.i, label %if.else.i26.i

if.then.i27.i:                                    ; preds = %if.then.i170
  %lasttarget.i.i.i.i = getelementptr inbounds %struct.FuncState, ptr %203, i64 0, i32 7
  store i32 %194, ptr %lasttarget.i.i.i.i, align 4
  %jpc.i.i.i = getelementptr inbounds %struct.FuncState, ptr %203, i64 0, i32 8
  %cmp.i.i.i.i = icmp eq i32 %201, -1
  br i1 %cmp.i.i.i.i, label %repeatstat.exit, label %if.else.i.i.i.i

if.else.i.i.i.i:                                  ; preds = %if.then.i27.i
  %205 = load i32, ptr %jpc.i.i.i, align 4
  %cmp1.i.i.i.i = icmp eq i32 %205, -1
  br i1 %cmp1.i.i.i.i, label %if.then2.i.i.i.i, label %while.cond.preheader.i.i.i.i

while.cond.preheader.i.i.i.i:                     ; preds = %if.else.i.i.i.i
  %fs.val.i.i.i.i = load ptr, ptr %203, align 8
  %206 = getelementptr i8, ptr %fs.val.i.i.i.i, i64 24
  %fs.val.val.i.i.i.i = load ptr, ptr %206, align 8
  br label %while.cond.i.i.i.i

if.then2.i.i.i.i:                                 ; preds = %if.else.i.i.i.i
  store i32 %201, ptr %jpc.i.i.i, align 4
  br label %repeatstat.exit

while.cond.i.i.i.i:                               ; preds = %while.cond.i.i.i.i, %while.cond.preheader.i.i.i.i
  %list.0.i.i.i.i = phi i32 [ %add1.i.i.i.i.i, %while.cond.i.i.i.i ], [ %205, %while.cond.preheader.i.i.i.i ]
  %idxprom.i.i.i.i.i = sext i32 %list.0.i.i.i.i to i64
  %arrayidx.i.i.i.i.i = getelementptr inbounds i32, ptr %fs.val.val.i.i.i.i, i64 %idxprom.i.i.i.i.i
  %207 = load i32, ptr %arrayidx.i.i.i.i.i, align 4
  %shr.i.i.i.i.i = lshr i32 %207, 14
  %sub.i.i.i.i.i = add nsw i32 %shr.i.i.i.i.i, -131071
  %cmp.i.i.i.i.i = icmp eq i32 %sub.i.i.i.i.i, -1
  %add.i.i.i.i.i = add nuw nsw i32 %list.0.i.i.i.i, 1
  %add1.i.i.i.i.i = add nsw i32 %add.i.i.i.i.i, %sub.i.i.i.i.i
  %cmp4.not12.i.i.i.i = icmp eq i32 %add1.i.i.i.i.i, -1
  %cmp4.not.i.i.i.i = select i1 %cmp.i.i.i.i.i, i1 true, i1 %cmp4.not12.i.i.i.i
  br i1 %cmp4.not.i.i.i.i, label %while.end.i.i.i.i, label %while.cond.i.i.i.i, !llvm.loop !94

while.end.i.i.i.i:                                ; preds = %while.cond.i.i.i.i
  %add.neg.i.i.i.i.i = xor i32 %list.0.i.i.i.i, -1
  %sub.i7.i.i.i.i = add i32 %201, %add.neg.i.i.i.i.i
  %208 = call i32 @llvm.abs.i32(i32 %sub.i7.i.i.i.i, i1 true)
  %cmp.i8.i.i.i.i = icmp ugt i32 %208, 131071
  br i1 %cmp.i8.i.i.i.i, label %if.then.i.i.i.i.i, label %fixjump.exit.i.i.i.i

if.then.i.i.i.i.i:                                ; preds = %while.end.i.i.i.i
  %ls.i.i.i.i.i = getelementptr inbounds %struct.FuncState, ptr %203, i64 0, i32 3
  %209 = load ptr, ptr %ls.i.i.i.i.i, align 8
  %t.i.i.i.i.i.i = getelementptr inbounds %struct.LexState, ptr %209, i64 0, i32 3
  %210 = load i32, ptr %t.i.i.i.i.i.i, align 8
  call fastcc void @luaX_lexerror(ptr noundef %209, ptr noundef nonnull @.str.148, i32 noundef %210)
  unreachable

fixjump.exit.i.i.i.i:                             ; preds = %while.end.i.i.i.i
  %arrayidx.i.i.i.i.i.le = getelementptr inbounds i32, ptr %fs.val.val.i.i.i.i, i64 %idxprom.i.i.i.i.i
  %and.i.i.i.i.i = and i32 %207, 16383
  %add1.i11.i.i.i.i = shl i32 %sub.i7.i.i.i.i, 14
  %shl.i.i.i.i.i = add i32 %add1.i11.i.i.i.i, 2147467264
  %or.i.i.i.i.i = or disjoint i32 %shl.i.i.i.i.i, %and.i.i.i.i.i
  store i32 %or.i.i.i.i.i, ptr %arrayidx.i.i.i.i.i.le, align 4
  br label %repeatstat.exit

if.else.i26.i:                                    ; preds = %if.then.i170
  call fastcc void @patchlistaux(ptr noundef nonnull %203, i32 noundef %201, i32 noundef %194, i32 noundef 255, i32 noundef %194)
  br label %repeatstat.exit

if.else.i158:                                     ; preds = %cond.exit.i
  call fastcc void @breakstat(ptr noundef nonnull %ls)
  %211 = load ptr, ptr %fs1.i21, align 8
  %pc.i.i.i = getelementptr inbounds %struct.FuncState, ptr %211, i64 0, i32 6
  %212 = load i32, ptr %pc.i.i.i, align 8
  %lasttarget.i.i.i = getelementptr inbounds %struct.FuncState, ptr %211, i64 0, i32 7
  store i32 %212, ptr %lasttarget.i.i.i, align 4
  %jpc.i.i = getelementptr inbounds %struct.FuncState, ptr %211, i64 0, i32 8
  %cmp.i.i.i159 = icmp eq i32 %201, -1
  br i1 %cmp.i.i.i159, label %luaK_patchtohere.exit.i, label %if.else.i.i.i160

if.else.i.i.i160:                                 ; preds = %if.else.i158
  %213 = load i32, ptr %jpc.i.i, align 4
  %cmp1.i.i.i = icmp eq i32 %213, -1
  br i1 %cmp1.i.i.i, label %if.then2.i.i.i, label %while.cond.preheader.i.i.i

while.cond.preheader.i.i.i:                       ; preds = %if.else.i.i.i160
  %fs.val.i.i.i = load ptr, ptr %211, align 8
  %214 = getelementptr i8, ptr %fs.val.i.i.i, i64 24
  %fs.val.val.i.i.i = load ptr, ptr %214, align 8
  br label %while.cond.i.i.i

if.then2.i.i.i:                                   ; preds = %if.else.i.i.i160
  store i32 %201, ptr %jpc.i.i, align 4
  br label %luaK_patchtohere.exit.i

while.cond.i.i.i:                                 ; preds = %while.cond.i.i.i, %while.cond.preheader.i.i.i
  %list.0.i.i.i = phi i32 [ %add1.i.i.i.i, %while.cond.i.i.i ], [ %213, %while.cond.preheader.i.i.i ]
  %idxprom.i.i.i.i = sext i32 %list.0.i.i.i to i64
  %arrayidx.i.i.i.i = getelementptr inbounds i32, ptr %fs.val.val.i.i.i, i64 %idxprom.i.i.i.i
  %215 = load i32, ptr %arrayidx.i.i.i.i, align 4
  %shr.i.i.i.i = lshr i32 %215, 14
  %sub.i.i.i.i = add nsw i32 %shr.i.i.i.i, -131071
  %cmp.i.i.i28.i = icmp eq i32 %sub.i.i.i.i, -1
  %add.i.i.i.i161 = add nuw nsw i32 %list.0.i.i.i, 1
  %add1.i.i.i.i = add nsw i32 %add.i.i.i.i161, %sub.i.i.i.i
  %cmp4.not12.i.i.i = icmp eq i32 %add1.i.i.i.i, -1
  %cmp4.not.i.i.i = select i1 %cmp.i.i.i28.i, i1 true, i1 %cmp4.not12.i.i.i
  br i1 %cmp4.not.i.i.i, label %while.end.i.i.i, label %while.cond.i.i.i, !llvm.loop !94

while.end.i.i.i:                                  ; preds = %while.cond.i.i.i
  %add.neg.i.i.i.i = xor i32 %list.0.i.i.i, -1
  %sub.i7.i.i.i = add i32 %201, %add.neg.i.i.i.i
  %216 = call i32 @llvm.abs.i32(i32 %sub.i7.i.i.i, i1 true)
  %cmp.i8.i.i.i = icmp ugt i32 %216, 131071
  br i1 %cmp.i8.i.i.i, label %if.then.i.i.i.i167, label %fixjump.exit.i.i.i

if.then.i.i.i.i167:                               ; preds = %while.end.i.i.i
  %ls.i.i.i.i168 = getelementptr inbounds %struct.FuncState, ptr %211, i64 0, i32 3
  %217 = load ptr, ptr %ls.i.i.i.i168, align 8
  %t.i.i.i.i.i169 = getelementptr inbounds %struct.LexState, ptr %217, i64 0, i32 3
  %218 = load i32, ptr %t.i.i.i.i.i169, align 8
  call fastcc void @luaX_lexerror(ptr noundef %217, ptr noundef nonnull @.str.148, i32 noundef %218)
  unreachable

fixjump.exit.i.i.i:                               ; preds = %while.end.i.i.i
  %arrayidx.i.i.i.i.le = getelementptr inbounds i32, ptr %fs.val.val.i.i.i, i64 %idxprom.i.i.i.i
  %and.i.i.i.i162 = and i32 %215, 16383
  %add1.i11.i.i.i = shl i32 %sub.i7.i.i.i, 14
  %shl.i.i.i.i = add i32 %add1.i11.i.i.i, 2147467264
  %or.i.i.i.i = or disjoint i32 %shl.i.i.i.i, %and.i.i.i.i162
  store i32 %or.i.i.i.i, ptr %arrayidx.i.i.i.i.le, align 4
  br label %luaK_patchtohere.exit.i

luaK_patchtohere.exit.i:                          ; preds = %fixjump.exit.i.i.i, %if.then2.i.i.i, %if.else.i158
  call fastcc void @leaveblock(ptr noundef %193)
  %219 = load ptr, ptr %fs1.i21, align 8
  %jpc1.i.i = getelementptr inbounds %struct.FuncState, ptr %193, i64 0, i32 8
  %220 = load i32, ptr %jpc1.i.i, align 8
  store i32 -1, ptr %jpc1.i.i, align 8
  %ls.i.i.i163 = getelementptr inbounds %struct.FuncState, ptr %193, i64 0, i32 3
  %221 = load ptr, ptr %ls.i.i.i163, align 8
  %lastline.i.i.i164 = getelementptr inbounds %struct.LexState, ptr %221, i64 0, i32 2
  %222 = load i32, ptr %lastline.i.i.i164, align 8
  %call.i.i.i165 = call fastcc i32 @luaK_code(ptr noundef %193, i32 noundef 2147450902, i32 noundef %222)
  %cmp.i.i29.i = icmp eq i32 %220, -1
  br i1 %cmp.i.i29.i, label %luaK_jump.exit.i, label %if.else.i.i30.i

if.else.i.i30.i:                                  ; preds = %luaK_patchtohere.exit.i
  %cmp1.i.i31.i = icmp eq i32 %call.i.i.i165, -1
  br i1 %cmp1.i.i31.i, label %luaK_jump.exit.i, label %while.cond.preheader.i.i32.i

while.cond.preheader.i.i32.i:                     ; preds = %if.else.i.i30.i
  %fs.val.i.i33.i = load ptr, ptr %193, align 8
  %223 = getelementptr i8, ptr %fs.val.i.i33.i, i64 24
  %fs.val.val.i.i34.i = load ptr, ptr %223, align 8
  br label %while.cond.i.i35.i

while.cond.i.i35.i:                               ; preds = %while.cond.i.i35.i, %while.cond.preheader.i.i32.i
  %list.0.i.i36.i = phi i32 [ %add1.i.i.i43.i, %while.cond.i.i35.i ], [ %call.i.i.i165, %while.cond.preheader.i.i32.i ]
  %idxprom.i.i.i37.i = sext i32 %list.0.i.i36.i to i64
  %arrayidx.i.i.i38.i = getelementptr inbounds i32, ptr %fs.val.val.i.i34.i, i64 %idxprom.i.i.i37.i
  %224 = load i32, ptr %arrayidx.i.i.i38.i, align 4
  %shr.i.i.i39.i = lshr i32 %224, 14
  %sub.i.i.i40.i = add nsw i32 %shr.i.i.i39.i, -131071
  %cmp.i.i.i41.i = icmp eq i32 %sub.i.i.i40.i, -1
  %add.i.i.i42.i = add nuw nsw i32 %list.0.i.i36.i, 1
  %add1.i.i.i43.i = add nsw i32 %add.i.i.i42.i, %sub.i.i.i40.i
  %cmp4.not12.i.i44.i = icmp eq i32 %add1.i.i.i43.i, -1
  %cmp4.not.i.i45.i = select i1 %cmp.i.i.i41.i, i1 true, i1 %cmp4.not12.i.i44.i
  br i1 %cmp4.not.i.i45.i, label %while.end.i.i46.i, label %while.cond.i.i35.i, !llvm.loop !94

while.end.i.i46.i:                                ; preds = %while.cond.i.i35.i
  %add.neg.i.i.i47.i = xor i32 %list.0.i.i36.i, -1
  %sub.i7.i.i48.i = add i32 %220, %add.neg.i.i.i47.i
  %225 = call i32 @llvm.abs.i32(i32 %sub.i7.i.i48.i, i1 true)
  %cmp.i8.i.i49.i = icmp ugt i32 %225, 131071
  br i1 %cmp.i8.i.i49.i, label %if.then.i.i.i56.i, label %fixjump.exit.i.i50.i

if.then.i.i.i56.i:                                ; preds = %while.end.i.i46.i
  %ls.i.i.i163.le = getelementptr inbounds %struct.FuncState, ptr %193, i64 0, i32 3
  %226 = load ptr, ptr %ls.i.i.i163.le, align 8
  %t.i.i.i.i57.i = getelementptr inbounds %struct.LexState, ptr %226, i64 0, i32 3
  %227 = load i32, ptr %t.i.i.i.i57.i, align 8
  call fastcc void @luaX_lexerror(ptr noundef %226, ptr noundef nonnull @.str.148, i32 noundef %227)
  unreachable

fixjump.exit.i.i50.i:                             ; preds = %while.end.i.i46.i
  %arrayidx.i.i.i38.i.le = getelementptr inbounds i32, ptr %fs.val.val.i.i34.i, i64 %idxprom.i.i.i37.i
  %and.i.i.i52.i = and i32 %224, 16383
  %add1.i11.i.i53.i = shl i32 %sub.i7.i.i48.i, 14
  %shl.i.i.i54.i = add i32 %add1.i11.i.i53.i, 2147467264
  %or.i.i.i55.i = or disjoint i32 %shl.i.i.i54.i, %and.i.i.i52.i
  store i32 %or.i.i.i55.i, ptr %arrayidx.i.i.i38.i.le, align 4
  br label %luaK_jump.exit.i

luaK_jump.exit.i:                                 ; preds = %fixjump.exit.i.i50.i, %if.else.i.i30.i, %luaK_patchtohere.exit.i
  %j.0.i.i = phi i32 [ %call.i.i.i165, %luaK_patchtohere.exit.i ], [ %call.i.i.i165, %fixjump.exit.i.i50.i ], [ %220, %if.else.i.i30.i ]
  %pc.i58.i = getelementptr inbounds %struct.FuncState, ptr %219, i64 0, i32 6
  %228 = load i32, ptr %pc.i58.i, align 8
  %cmp.i59.i = icmp eq i32 %228, %194
  br i1 %cmp.i59.i, label %if.then.i61.i, label %if.else.i60.i

if.then.i61.i:                                    ; preds = %luaK_jump.exit.i
  %lasttarget.i.i.i62.i = getelementptr inbounds %struct.FuncState, ptr %219, i64 0, i32 7
  store i32 %194, ptr %lasttarget.i.i.i62.i, align 4
  %jpc.i.i63.i = getelementptr inbounds %struct.FuncState, ptr %219, i64 0, i32 8
  %cmp.i.i.i64.i = icmp eq i32 %j.0.i.i, -1
  br i1 %cmp.i.i.i64.i, label %repeatstat.exit, label %if.else.i.i.i65.i

if.else.i.i.i65.i:                                ; preds = %if.then.i61.i
  %229 = load i32, ptr %jpc.i.i63.i, align 4
  %cmp1.i.i.i66.i = icmp eq i32 %229, -1
  br i1 %cmp1.i.i.i66.i, label %if.then2.i.i.i94.i, label %while.cond.preheader.i.i.i67.i

while.cond.preheader.i.i.i67.i:                   ; preds = %if.else.i.i.i65.i
  %fs.val.i.i.i68.i = load ptr, ptr %219, align 8
  %230 = getelementptr i8, ptr %fs.val.i.i.i68.i, i64 24
  %fs.val.val.i.i.i69.i = load ptr, ptr %230, align 8
  br label %while.cond.i.i.i70.i

if.then2.i.i.i94.i:                               ; preds = %if.else.i.i.i65.i
  store i32 %j.0.i.i, ptr %jpc.i.i63.i, align 4
  br label %repeatstat.exit

while.cond.i.i.i70.i:                             ; preds = %while.cond.i.i.i70.i, %while.cond.preheader.i.i.i67.i
  %list.0.i.i.i71.i = phi i32 [ %add1.i.i.i.i78.i, %while.cond.i.i.i70.i ], [ %229, %while.cond.preheader.i.i.i67.i ]
  %idxprom.i.i.i.i72.i = sext i32 %list.0.i.i.i71.i to i64
  %arrayidx.i.i.i.i73.i = getelementptr inbounds i32, ptr %fs.val.val.i.i.i69.i, i64 %idxprom.i.i.i.i72.i
  %231 = load i32, ptr %arrayidx.i.i.i.i73.i, align 4
  %shr.i.i.i.i74.i = lshr i32 %231, 14
  %sub.i.i.i.i75.i = add nsw i32 %shr.i.i.i.i74.i, -131071
  %cmp.i.i.i.i76.i = icmp eq i32 %sub.i.i.i.i75.i, -1
  %add.i.i.i.i77.i = add nuw nsw i32 %list.0.i.i.i71.i, 1
  %add1.i.i.i.i78.i = add nsw i32 %add.i.i.i.i77.i, %sub.i.i.i.i75.i
  %cmp4.not12.i.i.i79.i = icmp eq i32 %add1.i.i.i.i78.i, -1
  %cmp4.not.i.i.i80.i = select i1 %cmp.i.i.i.i76.i, i1 true, i1 %cmp4.not12.i.i.i79.i
  br i1 %cmp4.not.i.i.i80.i, label %while.end.i.i.i81.i, label %while.cond.i.i.i70.i, !llvm.loop !94

while.end.i.i.i81.i:                              ; preds = %while.cond.i.i.i70.i
  %add.neg.i.i.i.i82.i = xor i32 %list.0.i.i.i71.i, -1
  %sub.i7.i.i.i83.i = add i32 %j.0.i.i, %add.neg.i.i.i.i82.i
  %232 = call i32 @llvm.abs.i32(i32 %sub.i7.i.i.i83.i, i1 true)
  %cmp.i8.i.i.i84.i = icmp ugt i32 %232, 131071
  br i1 %cmp.i8.i.i.i84.i, label %if.then.i.i.i.i91.i, label %fixjump.exit.i.i.i85.i

if.then.i.i.i.i91.i:                              ; preds = %while.end.i.i.i81.i
  %ls.i.i.i.i92.i = getelementptr inbounds %struct.FuncState, ptr %219, i64 0, i32 3
  %233 = load ptr, ptr %ls.i.i.i.i92.i, align 8
  %t.i.i.i.i.i93.i = getelementptr inbounds %struct.LexState, ptr %233, i64 0, i32 3
  %234 = load i32, ptr %t.i.i.i.i.i93.i, align 8
  call fastcc void @luaX_lexerror(ptr noundef %233, ptr noundef nonnull @.str.148, i32 noundef %234)
  unreachable

fixjump.exit.i.i.i85.i:                           ; preds = %while.end.i.i.i81.i
  %arrayidx.i.i.i.i73.i.le = getelementptr inbounds i32, ptr %fs.val.val.i.i.i69.i, i64 %idxprom.i.i.i.i72.i
  %and.i.i.i.i87.i = and i32 %231, 16383
  %add1.i11.i.i.i88.i = shl i32 %sub.i7.i.i.i83.i, 14
  %shl.i.i.i.i89.i = add i32 %add1.i11.i.i.i88.i, 2147467264
  %or.i.i.i.i90.i = or disjoint i32 %shl.i.i.i.i89.i, %and.i.i.i.i87.i
  store i32 %or.i.i.i.i90.i, ptr %arrayidx.i.i.i.i73.i.le, align 4
  br label %repeatstat.exit

if.else.i60.i:                                    ; preds = %luaK_jump.exit.i
  call fastcc void @patchlistaux(ptr noundef nonnull %219, i32 noundef %j.0.i.i, i32 noundef %194, i32 noundef 255, i32 noundef %194)
  br label %repeatstat.exit

repeatstat.exit:                                  ; preds = %if.then.i61.i, %if.then2.i.i.i94.i, %fixjump.exit.i.i.i85.i, %if.else.i60.i, %if.then.i27.i, %if.then2.i.i.i.i, %fixjump.exit.i.i.i.i, %if.else.i26.i
  call fastcc void @leaveblock(ptr noundef %193)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %bl1.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %bl2.i)
  br label %statement.exit

sw.bb5.i:                                         ; preds = %while.body
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %v.i128)
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %b.i129)
  store i32 %3, ptr %lastline.i, align 8
  %235 = load i32, ptr %lookahead.i, align 8
  %cmp.not.i.i133 = icmp eq i32 %235, 287
  br i1 %cmp.not.i.i133, label %if.else.i.i141, label %if.then.i.i135

if.then.i.i135:                                   ; preds = %sw.bb5.i
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i, align 8
  br label %luaX_next.exit.i136

if.else.i.i141:                                   ; preds = %sw.bb5.i
  %call.i.i143 = call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i)
  store i32 %call.i.i143, ptr %t, align 8
  br label %luaX_next.exit.i136

luaX_next.exit.i136:                              ; preds = %if.else.i.i141, %if.then.i.i135
  call fastcc void @singlevar(ptr noundef nonnull %ls, ptr noundef nonnull %v.i128)
  br label %while.cond.i.i138

while.cond.i.i138:                                ; preds = %while.body.i.i140, %luaX_next.exit.i136
  %236 = load i32, ptr %t, align 8
  switch i32 %236, label %funcstat.exit [
    i32 46, label %while.body.i.i140
    i32 58, label %if.then.i7.i
  ]

while.body.i.i140:                                ; preds = %while.cond.i.i138
  call fastcc void @field(ptr noundef nonnull %ls, ptr noundef nonnull %v.i128)
  br label %while.cond.i.i138, !llvm.loop !98

if.then.i7.i:                                     ; preds = %while.cond.i.i138
  call fastcc void @field(ptr noundef nonnull %ls, ptr noundef nonnull %v.i128)
  call void @llvm.lifetime.start.p0(i64 600, ptr nonnull %new_fs.i)
  call fastcc void @open_func(ptr noundef nonnull %ls, ptr noundef nonnull %new_fs.i)
  %237 = load ptr, ptr %new_fs.i, align 8
  %linedefined.i.c = getelementptr inbounds %struct.Proto, ptr %237, i64 0, i32 16
  store i32 %3, ptr %linedefined.i.c, align 8
  call fastcc void @checknext(ptr noundef nonnull %ls, i32 noundef 40)
  %call.i491 = call fastcc ptr @luaX_newstring(ptr noundef nonnull %ls, ptr noundef nonnull @.str.155, i64 noundef 4)
  call fastcc void @new_localvar(ptr noundef nonnull %ls, ptr noundef %call.i491, i32 noundef 0)
  %ls.val.i492 = load ptr, ptr %fs1.i21, align 8
  %nactvar.i.i493 = getelementptr inbounds %struct.FuncState, ptr %ls.val.i492, i64 0, i32 13
  %238 = load i8, ptr %nactvar.i.i493, align 2
  %conv2.i.i494 = add i8 %238, 1
  store i8 %conv2.i.i494, ptr %nactvar.i.i493, align 2
  %pc.i.i495 = getelementptr inbounds %struct.FuncState, ptr %ls.val.i492, i64 0, i32 6
  %.pre.i.i496 = load i32, ptr %pc.i.i495, align 8
  %239 = load ptr, ptr %ls.val.i492, align 8
  %locvars.i.i499 = getelementptr inbounds %struct.Proto, ptr %239, i64 0, i32 7
  %240 = load ptr, ptr %locvars.i.i499, align 8
  %conv5.i.i500 = zext i8 %conv2.i.i494 to i64
  %sub.i.i501 = add nsw i64 %conv5.i.i500, -1
  %arrayidx.i.i503 = getelementptr inbounds %struct.FuncState, ptr %ls.val.i492, i64 0, i32 15, i64 %sub.i.i501
  %241 = load i16, ptr %arrayidx.i.i503, align 2
  %idxprom6.i.i504 = zext i16 %241 to i64
  %startpc.i.i505 = getelementptr inbounds %struct.LocVar, ptr %240, i64 %idxprom6.i.i504, i32 1
  store i32 %.pre.i.i496, ptr %startpc.i.i505, align 8
  br label %body.exit

funcstat.exit:                                    ; preds = %while.cond.i.i138
  call void @llvm.lifetime.start.p0(i64 600, ptr nonnull %new_fs.i)
  call fastcc void @open_func(ptr noundef nonnull %ls, ptr noundef nonnull %new_fs.i)
  %242 = load ptr, ptr %new_fs.i, align 8
  %linedefined.i = getelementptr inbounds %struct.Proto, ptr %242, i64 0, i32 16
  store i32 %3, ptr %linedefined.i, align 8
  call fastcc void @checknext(ptr noundef nonnull %ls, i32 noundef 40)
  br label %body.exit

body.exit:                                        ; preds = %if.then.i7.i, %funcstat.exit
  call fastcc void @parlist(ptr noundef nonnull %ls)
  call fastcc void @checknext(ptr noundef nonnull %ls, i32 noundef 41)
  call fastcc void @chunk(ptr noundef nonnull %ls)
  %243 = load i32, ptr %linenumber.i, align 4
  %244 = load ptr, ptr %new_fs.i, align 8
  %lastlinedefined.i = getelementptr inbounds %struct.Proto, ptr %244, i64 0, i32 17
  store i32 %243, ptr %lastlinedefined.i, align 4
  call fastcc void @check_match(ptr noundef nonnull %ls, i32 noundef 262, i32 noundef 265, i32 noundef %3)
  call fastcc void @close_func(ptr noundef nonnull %ls)
  call fastcc void @pushclosure(ptr noundef nonnull %ls, ptr noundef nonnull %new_fs.i, ptr noundef nonnull %b.i129)
  call void @llvm.lifetime.end.p0(i64 600, ptr nonnull %new_fs.i)
  %245 = load ptr, ptr %fs1.i21, align 8
  call fastcc void @luaK_storevar(ptr noundef %245, ptr noundef nonnull %v.i128, ptr noundef nonnull %b.i129)
  %246 = load ptr, ptr %fs1.i21, align 8
  %.val.i = load ptr, ptr %246, align 8
  %247 = getelementptr i8, ptr %246, i64 48
  %.val6.i = load i32, ptr %247, align 8
  %248 = getelementptr i8, ptr %.val.i, i64 40
  %.val.val.i = load ptr, ptr %248, align 8
  %249 = sext i32 %.val6.i to i64
  %250 = getelementptr i32, ptr %.val.val.i, i64 %249
  %arrayidx.i.i139 = getelementptr i32, ptr %250, i64 -1
  store i32 %3, ptr %arrayidx.i.i139, align 4
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %v.i128)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %b.i129)
  br label %statement.exit

sw.bb6.i:                                         ; preds = %while.body
  store i32 %3, ptr %lastline.i, align 8
  %251 = load i32, ptr %lookahead.i, align 8
  %cmp.not.i121 = icmp eq i32 %251, 287
  br i1 %cmp.not.i121, label %if.else.i125, label %if.then.i123

if.then.i123:                                     ; preds = %sw.bb6.i
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i, align 8
  %.pr747 = load i32, ptr %t, align 8
  br label %luaX_next.exit127

if.else.i125:                                     ; preds = %sw.bb6.i
  %call.i = call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i)
  store i32 %call.i, ptr %t, align 8
  br label %luaX_next.exit127

luaX_next.exit127:                                ; preds = %if.then.i123, %if.else.i125
  %252 = phi i32 [ %.pr747, %if.then.i123 ], [ %call.i, %if.else.i125 ]
  %cmp.i106 = icmp eq i32 %252, 265
  br i1 %cmp.i106, label %if.then.i108, label %if.else.i

if.then.i108:                                     ; preds = %luaX_next.exit127
  %253 = load i32, ptr %linenumber.i, align 4
  store i32 %253, ptr %lastline.i, align 8
  %254 = load i32, ptr %lookahead.i, align 8
  %cmp.not.i.i112 = icmp eq i32 %254, 287
  br i1 %cmp.not.i.i112, label %if.else.i.i114, label %if.then.i.i113

if.then.i.i113:                                   ; preds = %if.then.i108
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i, align 8
  %.pr750 = load i32, ptr %t, align 8
  br label %if.then.i8

if.else.i.i114:                                   ; preds = %if.then.i108
  %call.i.i116 = call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i)
  store i32 %call.i.i116, ptr %t, align 8
  br label %if.then.i8

if.then.i8:                                       ; preds = %if.then.i.i113, %if.else.i.i114
  %255 = phi i32 [ %.pr750, %if.then.i.i113 ], [ %call.i.i116, %if.else.i.i114 ]
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %v.i63)
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %b.i)
  %256 = load ptr, ptr %fs1.i21, align 8
  %cmp.not.i.i.i66 = icmp eq i32 %255, 285
  br i1 %cmp.not.i.i.i66, label %check.exit.i.i70, label %if.then.i.i.i67

if.then.i.i.i67:                                  ; preds = %if.then.i8
  %257 = load ptr, ptr %L.i, align 8
  %call1.i.i.i.i69 = call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %257, ptr noundef nonnull @.str.164, ptr noundef nonnull @.str.88)
  %258 = load i32, ptr %t, align 8
  call fastcc void @luaX_lexerror(ptr noundef nonnull %ls, ptr noundef %call1.i.i.i.i69, i32 noundef %258)
  unreachable

check.exit.i.i70:                                 ; preds = %if.then.i8
  %259 = load ptr, ptr %seminfo.i, align 8
  %260 = load i32, ptr %linenumber.i, align 4
  store i32 %260, ptr %lastline.i, align 8
  %261 = load i32, ptr %lookahead.i, align 8
  %cmp.not.i3.i.i75 = icmp eq i32 %261, 287
  br i1 %cmp.not.i3.i.i75, label %if.else.i.i.i103, label %if.then.i4.i.i76

if.then.i4.i.i76:                                 ; preds = %check.exit.i.i70
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i, align 8
  br label %str_checkname.exit.i77

if.else.i.i.i103:                                 ; preds = %check.exit.i.i70
  %call.i.i.i104 = call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i)
  store i32 %call.i.i.i104, ptr %t, align 8
  br label %str_checkname.exit.i77

str_checkname.exit.i77:                           ; preds = %if.else.i.i.i103, %if.then.i4.i.i76
  call fastcc void @new_localvar(ptr noundef nonnull %ls, ptr noundef %259, i32 noundef 0)
  %freereg.i = getelementptr inbounds %struct.FuncState, ptr %256, i64 0, i32 9
  %262 = load i32, ptr %freereg.i, align 4
  store i32 -1, ptr %t.i.i78, align 8
  store i32 -1, ptr %f.i.i, align 4
  store i32 6, ptr %v.i63, align 8
  store i32 %262, ptr %u.i.i79, align 8
  %add.i.i.i = add nsw i32 %262, 1
  %263 = load ptr, ptr %256, align 8
  %maxstacksize.i.i.i = getelementptr inbounds %struct.Proto, ptr %263, i64 0, i32 22
  %264 = load i8, ptr %maxstacksize.i.i.i, align 1
  %conv.i.i.i = zext i8 %264 to i32
  %cmp.i.i.i80.not = icmp slt i32 %262, %conv.i.i.i
  br i1 %cmp.i.i.i80.not, label %luaK_reserveregs.exit.i, label %if.then.i.i12.i

if.then.i.i12.i:                                  ; preds = %str_checkname.exit.i77
  %cmp2.i.i.i = icmp sgt i32 %262, 248
  br i1 %cmp2.i.i.i, label %if.then4.i.i.i, label %if.end.i.i.i

if.then4.i.i.i:                                   ; preds = %if.then.i.i12.i
  %ls.i.i.i102 = getelementptr inbounds %struct.FuncState, ptr %256, i64 0, i32 3
  %265 = load ptr, ptr %ls.i.i.i102, align 8
  %t.i.i.i.i = getelementptr inbounds %struct.LexState, ptr %265, i64 0, i32 3
  %266 = load i32, ptr %t.i.i.i.i, align 8
  call fastcc void @luaX_lexerror(ptr noundef %265, ptr noundef nonnull @.str.150, i32 noundef %266)
  unreachable

if.end.i.i.i:                                     ; preds = %if.then.i.i12.i
  %conv5.i.i.i = trunc i32 %add.i.i.i to i8
  store i8 %conv5.i.i.i, ptr %maxstacksize.i.i.i, align 1
  %.pre.i.i101 = load i32, ptr %freereg.i, align 4
  %.pre3.i.i = add nsw i32 %.pre.i.i101, 1
  br label %luaK_reserveregs.exit.i

luaK_reserveregs.exit.i:                          ; preds = %if.end.i.i.i, %str_checkname.exit.i77
  %add.pre-phi.i.i = phi i32 [ %add.i.i.i, %str_checkname.exit.i77 ], [ %.pre3.i.i, %if.end.i.i.i ]
  store i32 %add.pre-phi.i.i, ptr %freereg.i, align 4
  %ls.val.i81 = load ptr, ptr %fs1.i21, align 8
  %nactvar.i.i82 = getelementptr inbounds %struct.FuncState, ptr %ls.val.i81, i64 0, i32 13
  %267 = load i8, ptr %nactvar.i.i82, align 2
  %conv2.i.i83 = add i8 %267, 1
  store i8 %conv2.i.i83, ptr %nactvar.i.i82, align 2
  %pc.i.i84 = getelementptr inbounds %struct.FuncState, ptr %ls.val.i81, i64 0, i32 6
  %.pre.i13.i = load i32, ptr %pc.i.i84, align 8
  %268 = load ptr, ptr %ls.val.i81, align 8
  %locvars.i.i87 = getelementptr inbounds %struct.Proto, ptr %268, i64 0, i32 7
  %269 = load ptr, ptr %locvars.i.i87, align 8
  %conv5.i.i88 = zext i8 %conv2.i.i83 to i64
  %sub.i.i89 = add nsw i64 %conv5.i.i88, -1
  %arrayidx.i.i91 = getelementptr inbounds %struct.FuncState, ptr %ls.val.i81, i64 0, i32 15, i64 %sub.i.i89
  %270 = load i16, ptr %arrayidx.i.i91, align 2
  %idxprom6.i.i92 = zext i16 %270 to i64
  %startpc.i.i93 = getelementptr inbounds %struct.LocVar, ptr %269, i64 %idxprom6.i.i92, i32 1
  store i32 %.pre.i13.i, ptr %startpc.i.i93, align 8
  %271 = load i32, ptr %linenumber.i, align 4
  call void @llvm.lifetime.start.p0(i64 600, ptr nonnull %new_fs.i.i)
  call fastcc void @open_func(ptr noundef nonnull %ls, ptr noundef nonnull %new_fs.i.i)
  %272 = load ptr, ptr %new_fs.i.i, align 8
  %linedefined.i.i = getelementptr inbounds %struct.Proto, ptr %272, i64 0, i32 16
  store i32 %271, ptr %linedefined.i.i, align 8
  call fastcc void @checknext(ptr noundef nonnull %ls, i32 noundef 40)
  call fastcc void @parlist(ptr noundef nonnull %ls)
  call fastcc void @checknext(ptr noundef nonnull %ls, i32 noundef 41)
  call fastcc void @chunk(ptr noundef nonnull %ls)
  %273 = load i32, ptr %linenumber.i, align 4
  %274 = load ptr, ptr %new_fs.i.i, align 8
  %lastlinedefined.i.i = getelementptr inbounds %struct.Proto, ptr %274, i64 0, i32 17
  store i32 %273, ptr %lastlinedefined.i.i, align 4
  call fastcc void @check_match(ptr noundef nonnull %ls, i32 noundef 262, i32 noundef 265, i32 noundef %271)
  call fastcc void @close_func(ptr noundef nonnull %ls)
  call fastcc void @pushclosure(ptr noundef nonnull %ls, ptr noundef nonnull %new_fs.i.i, ptr noundef nonnull %b.i)
  call void @llvm.lifetime.end.p0(i64 600, ptr nonnull %new_fs.i.i)
  call fastcc void @luaK_storevar(ptr noundef nonnull %256, ptr noundef nonnull %v.i63, ptr noundef nonnull %b.i)
  %pc.i = getelementptr inbounds %struct.FuncState, ptr %256, i64 0, i32 6
  %275 = load i32, ptr %pc.i, align 8
  %276 = load ptr, ptr %256, align 8
  %locvars.i = getelementptr inbounds %struct.Proto, ptr %276, i64 0, i32 7
  %277 = load ptr, ptr %locvars.i, align 8
  %nactvar.i98 = getelementptr inbounds %struct.FuncState, ptr %256, i64 0, i32 13
  %278 = load i8, ptr %nactvar.i98, align 2
  %conv.i99 = zext i8 %278 to i64
  %sub.i = add nsw i64 %conv.i99, -1
  %arrayidx.i100 = getelementptr inbounds %struct.FuncState, ptr %256, i64 0, i32 15, i64 %sub.i
  %279 = load i16, ptr %arrayidx.i100, align 2
  %idxprom2.i = zext i16 %279 to i64
  %startpc.i = getelementptr inbounds %struct.LocVar, ptr %277, i64 %idxprom2.i, i32 1
  store i32 %275, ptr %startpc.i, align 8
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %v.i63)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %b.i)
  br label %statement.exit

if.else.i:                                        ; preds = %luaX_next.exit127
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %e.i40)
  %cmp.not.i.i.i865 = icmp eq i32 %252, 285
  br i1 %cmp.not.i.i.i865, label %check.exit.i.i, label %if.then.i.i.i41

if.then.i.i.i41:                                  ; preds = %if.else.i, %testnext.exit.i
  %280 = load ptr, ptr %L.i, align 8
  %call1.i.i.i.i = call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %280, ptr noundef nonnull @.str.164, ptr noundef nonnull @.str.88)
  %281 = load i32, ptr %t, align 8
  call fastcc void @luaX_lexerror(ptr noundef nonnull %ls, ptr noundef %call1.i.i.i.i, i32 noundef %281)
  unreachable

check.exit.i.i:                                   ; preds = %if.else.i, %testnext.exit.i
  %nvars.0.i866 = phi i32 [ %inc.i44, %testnext.exit.i ], [ 0, %if.else.i ]
  %282 = load ptr, ptr %seminfo.i, align 8
  %283 = load i32, ptr %linenumber.i, align 4
  store i32 %283, ptr %lastline.i, align 8
  %284 = load i32, ptr %lookahead.i, align 8
  %cmp.not.i3.i.i = icmp eq i32 %284, 287
  br i1 %cmp.not.i3.i.i, label %if.else.i.i.i, label %if.then.i4.i.i

if.then.i4.i.i:                                   ; preds = %check.exit.i.i
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i, align 8
  br label %str_checkname.exit.i

if.else.i.i.i:                                    ; preds = %check.exit.i.i
  %call.i.i.i62 = call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i)
  store i32 %call.i.i.i62, ptr %t, align 8
  br label %str_checkname.exit.i

str_checkname.exit.i:                             ; preds = %if.else.i.i.i, %if.then.i4.i.i
  %inc.i44 = add nuw nsw i32 %nvars.0.i866, 1
  call fastcc void @new_localvar(ptr noundef nonnull %ls, ptr noundef %282, i32 noundef %nvars.0.i866)
  %285 = load i32, ptr %t, align 8
  switch i32 %285, label %if.else.i60 [
    i32 44, label %if.then.i.i61
    i32 61, label %if.then.i20.i
  ]

if.then.i.i61:                                    ; preds = %str_checkname.exit.i
  %286 = load i32, ptr %linenumber.i, align 4
  store i32 %286, ptr %lastline.i, align 8
  %287 = load i32, ptr %lookahead.i, align 8
  %cmp.not.i.i13.i = icmp eq i32 %287, 287
  br i1 %cmp.not.i.i13.i, label %if.else.i.i15.i, label %if.then.i.i14.i

if.then.i.i14.i:                                  ; preds = %if.then.i.i61
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i, align 8
  %.pre = load i32, ptr %t, align 8
  br label %testnext.exit.i

if.else.i.i15.i:                                  ; preds = %if.then.i.i61
  %call.i.i16.i = call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i)
  store i32 %call.i.i16.i, ptr %t, align 8
  br label %testnext.exit.i

testnext.exit.i:                                  ; preds = %if.else.i.i15.i, %if.then.i.i14.i
  %288 = phi i32 [ %call.i.i16.i, %if.else.i.i15.i ], [ %.pre, %if.then.i.i14.i ]
  %cmp.not.i.i.i = icmp eq i32 %288, 285
  br i1 %cmp.not.i.i.i, label %check.exit.i.i, label %if.then.i.i.i41, !llvm.loop !99

if.then.i20.i:                                    ; preds = %str_checkname.exit.i
  %289 = load i32, ptr %linenumber.i, align 4
  store i32 %289, ptr %lastline.i, align 8
  %290 = load i32, ptr %lookahead.i, align 8
  %cmp.not.i.i24.i = icmp eq i32 %290, 287
  br i1 %cmp.not.i.i24.i, label %if.else.i.i26.i, label %if.then.i.i25.i

if.then.i.i25.i:                                  ; preds = %if.then.i20.i
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i, align 8
  br label %if.then.i47

if.else.i.i26.i:                                  ; preds = %if.then.i20.i
  %call.i.i28.i = call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i)
  store i32 %call.i.i28.i, ptr %t, align 8
  br label %if.then.i47

if.then.i47:                                      ; preds = %if.then.i.i25.i, %if.else.i.i26.i
  %call.i488 = call fastcc i32 @subexpr(ptr noundef nonnull %ls, ptr noundef nonnull %e.i40, i32 noundef 0), !range !93
  %291 = load i32, ptr %t, align 8
  %cmp.i476869 = icmp eq i32 %291, 44
  br i1 %cmp.i476869, label %if.then.i478, label %if.end.i56

if.then.i478:                                     ; preds = %if.then.i47, %luaK_exp2nextreg.exit474
  %n.0.i.i49870 = phi i32 [ %inc.i.i54, %luaK_exp2nextreg.exit474 ], [ 1, %if.then.i47 ]
  %292 = load i32, ptr %linenumber.i, align 4
  store i32 %292, ptr %lastline.i, align 8
  %293 = load i32, ptr %lookahead.i, align 8
  %cmp.not.i.i482 = icmp eq i32 %293, 287
  br i1 %cmp.not.i.i482, label %if.else.i.i484, label %if.then.i.i483

if.then.i.i483:                                   ; preds = %if.then.i478
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i, align 8
  br label %while.body.i.i52

if.else.i.i484:                                   ; preds = %if.then.i478
  %call.i.i486 = call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i)
  store i32 %call.i.i486, ptr %t, align 8
  br label %while.body.i.i52

while.body.i.i52:                                 ; preds = %if.then.i.i483, %if.else.i.i484
  %294 = load ptr, ptr %fs1.i21, align 8
  call fastcc void @luaK_dischargevars(ptr noundef %294, ptr noundef nonnull %e.i40)
  %295 = load i32, ptr %e.i40, align 8
  %cmp.i.i444 = icmp eq i32 %295, 12
  br i1 %cmp.i.i444, label %if.then.i.i463, label %freeexp.exit.i445

if.then.i.i463:                                   ; preds = %while.body.i.i52
  %296 = load i32, ptr %u.i.i464, align 8
  %and.i.i.i465 = and i32 %296, 256
  %tobool.not.i.i.i466 = icmp eq i32 %and.i.i.i465, 0
  br i1 %tobool.not.i.i.i466, label %land.lhs.true.i.i.i467, label %freeexp.exit.i445

land.lhs.true.i.i.i467:                           ; preds = %if.then.i.i463
  %nactvar.i.i.i468 = getelementptr inbounds %struct.FuncState, ptr %294, i64 0, i32 13
  %297 = load i8, ptr %nactvar.i.i.i468, align 2
  %conv.i.i.i469 = zext i8 %297 to i32
  %cmp.not.i.i.i470 = icmp slt i32 %296, %conv.i.i.i469
  br i1 %cmp.not.i.i.i470, label %freeexp.exit.i445, label %if.then.i.i.i471

if.then.i.i.i471:                                 ; preds = %land.lhs.true.i.i.i467
  %freereg.i.i.i472 = getelementptr inbounds %struct.FuncState, ptr %294, i64 0, i32 9
  %298 = load i32, ptr %freereg.i.i.i472, align 4
  %dec.i.i.i473 = add nsw i32 %298, -1
  store i32 %dec.i.i.i473, ptr %freereg.i.i.i472, align 4
  br label %freeexp.exit.i445

freeexp.exit.i445:                                ; preds = %if.then.i.i.i471, %land.lhs.true.i.i.i467, %if.then.i.i463, %while.body.i.i52
  %freereg.i.i7.i446 = getelementptr inbounds %struct.FuncState, ptr %294, i64 0, i32 9
  %299 = load i32, ptr %freereg.i.i7.i446, align 4
  %add.i.i.i447 = add nsw i32 %299, 1
  %300 = load ptr, ptr %294, align 8
  %maxstacksize.i.i.i448 = getelementptr inbounds %struct.Proto, ptr %300, i64 0, i32 22
  %301 = load i8, ptr %maxstacksize.i.i.i448, align 1
  %conv.i.i8.i449 = zext i8 %301 to i32
  %cmp.i.i.not.i450 = icmp slt i32 %299, %conv.i.i8.i449
  br i1 %cmp.i.i.not.i450, label %luaK_exp2nextreg.exit474, label %if.then.i.i9.i451

if.then.i.i9.i451:                                ; preds = %freeexp.exit.i445
  %cmp2.i.i.i452 = icmp sgt i32 %299, 248
  br i1 %cmp2.i.i.i452, label %if.then4.i.i.i460, label %if.end.i.i.i453

if.then4.i.i.i460:                                ; preds = %if.then.i.i9.i451
  %ls.i.i.i461 = getelementptr inbounds %struct.FuncState, ptr %294, i64 0, i32 3
  %302 = load ptr, ptr %ls.i.i.i461, align 8
  %t.i.i.i.i462 = getelementptr inbounds %struct.LexState, ptr %302, i64 0, i32 3
  %303 = load i32, ptr %t.i.i.i.i462, align 8
  call fastcc void @luaX_lexerror(ptr noundef %302, ptr noundef nonnull @.str.150, i32 noundef %303)
  unreachable

if.end.i.i.i453:                                  ; preds = %if.then.i.i9.i451
  %conv5.i.i.i454 = trunc i32 %add.i.i.i447 to i8
  store i8 %conv5.i.i.i454, ptr %maxstacksize.i.i.i448, align 1
  %.pre.i.i455 = load i32, ptr %freereg.i.i7.i446, align 4
  %.pre3.i.i456 = add nsw i32 %.pre.i.i455, 1
  br label %luaK_exp2nextreg.exit474

luaK_exp2nextreg.exit474:                         ; preds = %freeexp.exit.i445, %if.end.i.i.i453
  %add.pre-phi.i.i458 = phi i32 [ %add.i.i.i447, %freeexp.exit.i445 ], [ %.pre3.i.i456, %if.end.i.i.i453 ]
  store i32 %add.pre-phi.i.i458, ptr %freereg.i.i7.i446, align 4
  %sub.i459 = add nsw i32 %add.pre-phi.i.i458, -1
  call fastcc void @exp2reg(ptr noundef nonnull %294, ptr noundef nonnull %e.i40, i32 noundef %sub.i459)
  %call.i443 = call fastcc i32 @subexpr(ptr noundef nonnull %ls, ptr noundef nonnull %e.i40, i32 noundef 0), !range !93
  %inc.i.i54 = add nuw nsw i32 %n.0.i.i49870, 1
  %304 = load i32, ptr %t, align 8
  %cmp.i476 = icmp eq i32 %304, 44
  br i1 %cmp.i476, label %if.then.i478, label %if.end.i56, !llvm.loop !97

if.else.i60:                                      ; preds = %str_checkname.exit.i
  store i32 0, ptr %e.i40, align 8
  br label %if.end.i56

if.end.i56:                                       ; preds = %luaK_exp2nextreg.exit474, %if.then.i47, %if.else.i60
  %nexps.0.i = phi i32 [ 0, %if.else.i60 ], [ 1, %if.then.i47 ], [ %inc.i.i54, %luaK_exp2nextreg.exit474 ]
  %ls.val9.i = load ptr, ptr %fs1.i21, align 8
  call fastcc void @adjust_assign(ptr %ls.val9.i, i32 noundef %inc.i44, i32 noundef %nexps.0.i, ptr noundef nonnull %e.i40)
  %ls.val.i = load ptr, ptr %fs1.i21, align 8
  %nactvar.i.i = getelementptr inbounds %struct.FuncState, ptr %ls.val.i, i64 0, i32 13
  %305 = load i8, ptr %nactvar.i.i, align 2
  %306 = trunc i32 %inc.i44 to i8
  %conv2.i.i = add i8 %305, %306
  store i8 %conv2.i.i, ptr %nactvar.i.i, align 2
  %pc.i.i = getelementptr inbounds %struct.FuncState, ptr %ls.val.i, i64 0, i32 6
  %.pre.i.i = load i32, ptr %pc.i.i, align 8
  br label %for.body.i.i

for.body.i.i:                                     ; preds = %for.body.i.i, %if.end.i56
  %nvars.addr.02.i.i = phi i32 [ %inc.i44, %if.end.i56 ], [ %dec.i.i, %for.body.i.i ]
  %307 = load ptr, ptr %ls.val.i, align 8
  %locvars.i.i = getelementptr inbounds %struct.Proto, ptr %307, i64 0, i32 7
  %308 = load ptr, ptr %locvars.i.i, align 8
  %309 = load i8, ptr %nactvar.i.i, align 2
  %conv5.i.i = zext i8 %309 to i32
  %sub.i.i57 = sub nsw i32 %conv5.i.i, %nvars.addr.02.i.i
  %idxprom.i.i58 = sext i32 %sub.i.i57 to i64
  %arrayidx.i.i59 = getelementptr inbounds %struct.FuncState, ptr %ls.val.i, i64 0, i32 15, i64 %idxprom.i.i58
  %310 = load i16, ptr %arrayidx.i.i59, align 2
  %idxprom6.i.i = zext i16 %310 to i64
  %startpc.i.i = getelementptr inbounds %struct.LocVar, ptr %308, i64 %idxprom6.i.i, i32 1
  store i32 %.pre.i.i, ptr %startpc.i.i, align 8
  %dec.i.i = add nsw i32 %nvars.addr.02.i.i, -1
  %tobool.not.i30.i = icmp eq i32 %dec.i.i, 0
  br i1 %tobool.not.i30.i, label %localstat.exit, label %for.body.i.i, !llvm.loop !100

localstat.exit:                                   ; preds = %for.body.i.i
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %e.i40)
  br label %statement.exit

sw.bb7.i:                                         ; preds = %while.body
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %e.i)
  %311 = load ptr, ptr %fs1.i21, align 8
  store i32 %3, ptr %lastline.i, align 8
  %312 = load i32, ptr %lookahead.i, align 8
  %cmp.not.i.i25 = icmp eq i32 %312, 287
  br i1 %cmp.not.i.i25, label %if.else.i.i37, label %if.then.i.i26

if.then.i.i26:                                    ; preds = %sw.bb7.i
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i, align 8
  %.pr757 = load i32, ptr %t, align 8
  br label %luaX_next.exit.i

if.else.i.i37:                                    ; preds = %sw.bb7.i
  %call.i.i39 = call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i)
  store i32 %call.i.i39, ptr %t, align 8
  br label %luaX_next.exit.i

luaX_next.exit.i:                                 ; preds = %if.else.i.i37, %if.then.i.i26
  %313 = phi i32 [ %call.i.i39, %if.else.i.i37 ], [ %.pr757, %if.then.i.i26 ]
  switch i32 %313, label %if.else.i30 [
    i32 260, label %retstat.exit
    i32 261, label %retstat.exit
    i32 262, label %retstat.exit
    i32 276, label %retstat.exit
    i32 287, label %retstat.exit
    i32 59, label %retstat.exit
  ]

if.else.i30:                                      ; preds = %luaX_next.exit.i
  %call.i442 = call fastcc i32 @subexpr(ptr noundef nonnull %ls, ptr noundef nonnull %e.i, i32 noundef 0), !range !93
  %314 = load i32, ptr %t, align 8
  %cmp.i430863 = icmp ne i32 %314, 44
  br i1 %cmp.i430863, label %explist1.exit.i.thread, label %if.then.i432

if.then.i432:                                     ; preds = %if.else.i30, %luaK_exp2nextreg.exit
  %n.0.i.i864 = phi i32 [ %inc.i.i, %luaK_exp2nextreg.exit ], [ 1, %if.else.i30 ]
  %315 = load i32, ptr %linenumber.i, align 4
  store i32 %315, ptr %lastline.i, align 8
  %316 = load i32, ptr %lookahead.i, align 8
  %cmp.not.i.i436 = icmp eq i32 %316, 287
  br i1 %cmp.not.i.i436, label %if.else.i.i438, label %if.then.i.i437

if.then.i.i437:                                   ; preds = %if.then.i432
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i, align 8
  br label %while.body.i.i

if.else.i.i438:                                   ; preds = %if.then.i432
  %call.i.i440 = call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i)
  store i32 %call.i.i440, ptr %t, align 8
  br label %while.body.i.i

while.body.i.i:                                   ; preds = %if.then.i.i437, %if.else.i.i438
  %317 = load ptr, ptr %fs1.i21, align 8
  call fastcc void @luaK_dischargevars(ptr noundef %317, ptr noundef nonnull %e.i)
  %318 = load i32, ptr %e.i, align 8
  %cmp.i.i408 = icmp eq i32 %318, 12
  br i1 %cmp.i.i408, label %if.then.i.i422, label %freeexp.exit.i

if.then.i.i422:                                   ; preds = %while.body.i.i
  %319 = load i32, ptr %u.i.i423, align 8
  %and.i.i.i424 = and i32 %319, 256
  %tobool.not.i.i.i = icmp eq i32 %and.i.i.i424, 0
  br i1 %tobool.not.i.i.i, label %land.lhs.true.i.i.i, label %freeexp.exit.i

land.lhs.true.i.i.i:                              ; preds = %if.then.i.i422
  %nactvar.i.i.i = getelementptr inbounds %struct.FuncState, ptr %317, i64 0, i32 13
  %320 = load i8, ptr %nactvar.i.i.i, align 2
  %conv.i.i.i425 = zext i8 %320 to i32
  %cmp.not.i.i.i426 = icmp slt i32 %319, %conv.i.i.i425
  br i1 %cmp.not.i.i.i426, label %freeexp.exit.i, label %if.then.i.i.i427

if.then.i.i.i427:                                 ; preds = %land.lhs.true.i.i.i
  %freereg.i.i.i428 = getelementptr inbounds %struct.FuncState, ptr %317, i64 0, i32 9
  %321 = load i32, ptr %freereg.i.i.i428, align 4
  %dec.i.i.i = add nsw i32 %321, -1
  store i32 %dec.i.i.i, ptr %freereg.i.i.i428, align 4
  br label %freeexp.exit.i

freeexp.exit.i:                                   ; preds = %if.then.i.i.i427, %land.lhs.true.i.i.i, %if.then.i.i422, %while.body.i.i
  %freereg.i.i7.i = getelementptr inbounds %struct.FuncState, ptr %317, i64 0, i32 9
  %322 = load i32, ptr %freereg.i.i7.i, align 4
  %add.i.i.i409 = add nsw i32 %322, 1
  %323 = load ptr, ptr %317, align 8
  %maxstacksize.i.i.i410 = getelementptr inbounds %struct.Proto, ptr %323, i64 0, i32 22
  %324 = load i8, ptr %maxstacksize.i.i.i410, align 1
  %conv.i.i8.i = zext i8 %324 to i32
  %cmp.i.i.not.i = icmp slt i32 %322, %conv.i.i8.i
  br i1 %cmp.i.i.not.i, label %luaK_exp2nextreg.exit, label %if.then.i.i9.i

if.then.i.i9.i:                                   ; preds = %freeexp.exit.i
  %cmp2.i.i.i411 = icmp sgt i32 %322, 248
  br i1 %cmp2.i.i.i411, label %if.then4.i.i.i419, label %if.end.i.i.i412

if.then4.i.i.i419:                                ; preds = %if.then.i.i9.i
  %ls.i.i.i420 = getelementptr inbounds %struct.FuncState, ptr %317, i64 0, i32 3
  %325 = load ptr, ptr %ls.i.i.i420, align 8
  %t.i.i.i.i421 = getelementptr inbounds %struct.LexState, ptr %325, i64 0, i32 3
  %326 = load i32, ptr %t.i.i.i.i421, align 8
  call fastcc void @luaX_lexerror(ptr noundef %325, ptr noundef nonnull @.str.150, i32 noundef %326)
  unreachable

if.end.i.i.i412:                                  ; preds = %if.then.i.i9.i
  %conv5.i.i.i413 = trunc i32 %add.i.i.i409 to i8
  store i8 %conv5.i.i.i413, ptr %maxstacksize.i.i.i410, align 1
  %.pre.i.i414 = load i32, ptr %freereg.i.i7.i, align 4
  %.pre3.i.i415 = add nsw i32 %.pre.i.i414, 1
  br label %luaK_exp2nextreg.exit

luaK_exp2nextreg.exit:                            ; preds = %freeexp.exit.i, %if.end.i.i.i412
  %add.pre-phi.i.i417 = phi i32 [ %add.i.i.i409, %freeexp.exit.i ], [ %.pre3.i.i415, %if.end.i.i.i412 ]
  store i32 %add.pre-phi.i.i417, ptr %freereg.i.i7.i, align 4
  %sub.i418 = add nsw i32 %add.pre-phi.i.i417, -1
  call fastcc void @exp2reg(ptr noundef nonnull %317, ptr noundef nonnull %e.i, i32 noundef %sub.i418)
  %call.i407 = call fastcc i32 @subexpr(ptr noundef nonnull %ls, ptr noundef nonnull %e.i, i32 noundef 0), !range !93
  %inc.i.i = add nuw nsw i32 %n.0.i.i864, 1
  %327 = load i32, ptr %t, align 8
  %cmp.i430 = icmp eq i32 %327, 44
  br i1 %cmp.i430, label %if.then.i432, label %explist1.exit.i, !llvm.loop !97

explist1.exit.i:                                  ; preds = %luaK_exp2nextreg.exit
  %328 = load i32, ptr %e.i, align 8
  %329 = add i32 %328, -13
  %or.cond.i = icmp ult i32 %329, 2
  br i1 %or.cond.i, label %if.then9.i, label %if.else25.i

explist1.exit.i.thread:                           ; preds = %if.else.i30
  %330 = load i32, ptr %e.i, align 8
  %331 = add i32 %330, -13
  %or.cond.i969 = icmp ult i32 %331, 2
  br i1 %or.cond.i969, label %if.then9.i, label %if.then23.i

if.then9.i:                                       ; preds = %explist1.exit.i.thread, %explist1.exit.i
  %332 = phi i32 [ %330, %explist1.exit.i.thread ], [ %328, %explist1.exit.i ]
  switch i32 %332, label %luaK_setreturns.exit.i [
    i32 13, label %if.then.i16.i
    i32 14, label %if.then10.i.i
  ]

if.then.i16.i:                                    ; preds = %if.then9.i
  %333 = load ptr, ptr %311, align 8
  %code.i.i = getelementptr inbounds %struct.Proto, ptr %333, i64 0, i32 4
  %334 = load ptr, ptr %code.i.i, align 8
  %335 = load i32, ptr %u.i.i423, align 8
  %idxprom.i.i = sext i32 %335 to i64
  %arrayidx.i.i = getelementptr inbounds i32, ptr %334, i64 %idxprom.i.i
  %336 = load i32, ptr %arrayidx.i.i, align 4
  %and.i.i = and i32 %336, -8372225
  store i32 %and.i.i, ptr %arrayidx.i.i, align 4
  br label %luaK_setreturns.exit.i

if.then10.i.i:                                    ; preds = %if.then9.i
  %337 = load ptr, ptr %311, align 8
  %code12.i.i = getelementptr inbounds %struct.Proto, ptr %337, i64 0, i32 4
  %338 = load ptr, ptr %code12.i.i, align 8
  %339 = load i32, ptr %u.i.i423, align 8
  %idxprom15.i.i = sext i32 %339 to i64
  %arrayidx16.i.i = getelementptr inbounds i32, ptr %338, i64 %idxprom15.i.i
  %340 = load i32, ptr %arrayidx16.i.i, align 4
  %and17.i.i = and i32 %340, 8388607
  store i32 %and17.i.i, ptr %arrayidx16.i.i, align 4
  %341 = load ptr, ptr %311, align 8
  %code29.i.i = getelementptr inbounds %struct.Proto, ptr %341, i64 0, i32 4
  %342 = load ptr, ptr %code29.i.i, align 8
  %343 = load i32, ptr %u.i.i423, align 8
  %idxprom32.i.i = sext i32 %343 to i64
  %arrayidx33.i.i = getelementptr inbounds i32, ptr %342, i64 %idxprom32.i.i
  %344 = load i32, ptr %arrayidx33.i.i, align 4
  %and34.i.i = and i32 %344, -16321
  %freereg.i.i = getelementptr inbounds %struct.FuncState, ptr %311, i64 0, i32 9
  %345 = load i32, ptr %freereg.i.i, align 4
  %shl35.i.i = shl i32 %345, 6
  %and36.i.i = and i32 %shl35.i.i, 16320
  %or37.i.i = or disjoint i32 %and36.i.i, %and34.i.i
  store i32 %or37.i.i, ptr %arrayidx33.i.i, align 4
  %346 = load i32, ptr %freereg.i.i, align 4
  %add.i.i.i.i = add nsw i32 %346, 1
  %347 = load ptr, ptr %311, align 8
  %maxstacksize.i.i.i.i = getelementptr inbounds %struct.Proto, ptr %347, i64 0, i32 22
  %348 = load i8, ptr %maxstacksize.i.i.i.i, align 1
  %conv.i.i.i.i = zext i8 %348 to i32
  %cmp.i.i.not.i.i = icmp slt i32 %346, %conv.i.i.i.i
  br i1 %cmp.i.i.not.i.i, label %luaK_reserveregs.exit.i.i, label %if.then.i.i.i.i

if.then.i.i.i.i:                                  ; preds = %if.then10.i.i
  %cmp2.i.i.i.i = icmp sgt i32 %346, 248
  br i1 %cmp2.i.i.i.i, label %if.then4.i.i.i.i, label %if.end.i.i.i.i

if.then4.i.i.i.i:                                 ; preds = %if.then.i.i.i.i
  %ls.i.i.i.i = getelementptr inbounds %struct.FuncState, ptr %311, i64 0, i32 3
  %349 = load ptr, ptr %ls.i.i.i.i, align 8
  %t.i.i.i.i.i = getelementptr inbounds %struct.LexState, ptr %349, i64 0, i32 3
  %350 = load i32, ptr %t.i.i.i.i.i, align 8
  call fastcc void @luaX_lexerror(ptr noundef %349, ptr noundef nonnull @.str.150, i32 noundef %350)
  unreachable

if.end.i.i.i.i:                                   ; preds = %if.then.i.i.i.i
  %conv5.i.i.i.i = trunc i32 %add.i.i.i.i to i8
  store i8 %conv5.i.i.i.i, ptr %maxstacksize.i.i.i.i, align 1
  %.pre.i.i.i = load i32, ptr %freereg.i.i, align 4
  %.pre3.i.i.i = add nsw i32 %.pre.i.i.i, 1
  br label %luaK_reserveregs.exit.i.i

luaK_reserveregs.exit.i.i:                        ; preds = %if.end.i.i.i.i, %if.then10.i.i
  %add.pre-phi.i.i.i = phi i32 [ %add.i.i.i.i, %if.then10.i.i ], [ %.pre3.i.i.i, %if.end.i.i.i.i ]
  store i32 %add.pre-phi.i.i.i, ptr %freereg.i.i, align 4
  br label %luaK_setreturns.exit.i

luaK_setreturns.exit.i:                           ; preds = %luaK_reserveregs.exit.i.i, %if.then.i16.i, %if.then9.i
  %351 = load i32, ptr %e.i, align 8
  %cmp11.i = icmp eq i32 %351, 13
  %or.cond1.i = and i1 %cmp11.i, %cmp.i430863
  br i1 %or.cond1.i, label %if.then13.i, label %if.end.i

if.then13.i:                                      ; preds = %luaK_setreturns.exit.i
  %352 = load ptr, ptr %311, align 8
  %code.i31 = getelementptr inbounds %struct.Proto, ptr %352, i64 0, i32 4
  %353 = load ptr, ptr %code.i31, align 8
  %354 = load i32, ptr %u.i.i423, align 8
  %idxprom.i33 = sext i32 %354 to i64
  %arrayidx.i34 = getelementptr inbounds i32, ptr %353, i64 %idxprom.i33
  %355 = load i32, ptr %arrayidx.i34, align 4
  %and.i35 = and i32 %355, -64
  %or.i36 = or disjoint i32 %and.i35, 29
  store i32 %or.i36, ptr %arrayidx.i34, align 4
  br label %if.end.i

if.end.i:                                         ; preds = %if.then13.i, %luaK_setreturns.exit.i
  %nactvar.i = getelementptr inbounds %struct.FuncState, ptr %311, i64 0, i32 13
  %356 = load i8, ptr %nactvar.i, align 2
  %conv.i = zext i8 %356 to i32
  br label %retstat.exit

if.then23.i:                                      ; preds = %explist1.exit.i.thread
  %call24.i = call fastcc i32 @luaK_exp2anyreg(ptr noundef %311, ptr noundef nonnull %e.i)
  br label %retstat.exit

if.else25.i:                                      ; preds = %explist1.exit.i
  call fastcc void @luaK_dischargevars(ptr noundef %311, ptr noundef nonnull %e.i)
  %357 = load i32, ptr %e.i, align 8
  %cmp.i.i.i = icmp eq i32 %357, 12
  br i1 %cmp.i.i.i, label %if.then.i.i.i, label %freeexp.exit.i.i

if.then.i.i.i:                                    ; preds = %if.else25.i
  %358 = load i32, ptr %u.i.i423, align 8
  %and.i.i.i.i = and i32 %358, 256
  %tobool.not.i.i.i.i = icmp eq i32 %and.i.i.i.i, 0
  br i1 %tobool.not.i.i.i.i, label %land.lhs.true.i.i.i.i, label %freeexp.exit.i.i

land.lhs.true.i.i.i.i:                            ; preds = %if.then.i.i.i
  %nactvar.i.i.i.i = getelementptr inbounds %struct.FuncState, ptr %311, i64 0, i32 13
  %359 = load i8, ptr %nactvar.i.i.i.i, align 2
  %conv.i.i.i30.i = zext i8 %359 to i32
  %cmp.not.i.i.i.i = icmp slt i32 %358, %conv.i.i.i30.i
  br i1 %cmp.not.i.i.i.i, label %freeexp.exit.i.i, label %if.then.i.i.i31.i

if.then.i.i.i31.i:                                ; preds = %land.lhs.true.i.i.i.i
  %freereg.i.i.i.i = getelementptr inbounds %struct.FuncState, ptr %311, i64 0, i32 9
  %360 = load i32, ptr %freereg.i.i.i.i, align 4
  %dec.i.i.i.i = add nsw i32 %360, -1
  store i32 %dec.i.i.i.i, ptr %freereg.i.i.i.i, align 4
  br label %freeexp.exit.i.i

freeexp.exit.i.i:                                 ; preds = %if.then.i.i.i31.i, %land.lhs.true.i.i.i.i, %if.then.i.i.i, %if.else25.i
  %freereg.i.i7.i.i = getelementptr inbounds %struct.FuncState, ptr %311, i64 0, i32 9
  %361 = load i32, ptr %freereg.i.i7.i.i, align 4
  %add.i.i.i17.i = add nsw i32 %361, 1
  %362 = load ptr, ptr %311, align 8
  %maxstacksize.i.i.i18.i = getelementptr inbounds %struct.Proto, ptr %362, i64 0, i32 22
  %363 = load i8, ptr %maxstacksize.i.i.i18.i, align 1
  %conv.i.i8.i.i = zext i8 %363 to i32
  %cmp.i.i.not.i19.i = icmp slt i32 %361, %conv.i.i8.i.i
  br i1 %cmp.i.i.not.i19.i, label %luaK_exp2nextreg.exit.i, label %if.then.i.i9.i.i

if.then.i.i9.i.i:                                 ; preds = %freeexp.exit.i.i
  %cmp2.i.i.i20.i = icmp sgt i32 %361, 248
  br i1 %cmp2.i.i.i20.i, label %if.then4.i.i.i27.i, label %if.end.i.i.i21.i

if.then4.i.i.i27.i:                               ; preds = %if.then.i.i9.i.i
  %ls.i.i.i28.i = getelementptr inbounds %struct.FuncState, ptr %311, i64 0, i32 3
  %364 = load ptr, ptr %ls.i.i.i28.i, align 8
  %t.i.i.i.i29.i = getelementptr inbounds %struct.LexState, ptr %364, i64 0, i32 3
  %365 = load i32, ptr %t.i.i.i.i29.i, align 8
  call fastcc void @luaX_lexerror(ptr noundef %364, ptr noundef nonnull @.str.150, i32 noundef %365)
  unreachable

if.end.i.i.i21.i:                                 ; preds = %if.then.i.i9.i.i
  %conv5.i.i.i22.i = trunc i32 %add.i.i.i17.i to i8
  store i8 %conv5.i.i.i22.i, ptr %maxstacksize.i.i.i18.i, align 1
  %.pre.i.i23.i = load i32, ptr %freereg.i.i7.i.i, align 4
  %.pre3.i.i24.i = add nsw i32 %.pre.i.i23.i, 1
  br label %luaK_exp2nextreg.exit.i

luaK_exp2nextreg.exit.i:                          ; preds = %if.end.i.i.i21.i, %freeexp.exit.i.i
  %add.pre-phi.i.i26.i = phi i32 [ %add.i.i.i17.i, %freeexp.exit.i.i ], [ %.pre3.i.i24.i, %if.end.i.i.i21.i ]
  store i32 %add.pre-phi.i.i26.i, ptr %freereg.i.i7.i.i, align 4
  %sub.i.i = add nsw i32 %add.pre-phi.i.i26.i, -1
  call fastcc void @exp2reg(ptr noundef nonnull %311, ptr noundef nonnull %e.i, i32 noundef %sub.i.i)
  %nactvar26.i = getelementptr inbounds %struct.FuncState, ptr %311, i64 0, i32 13
  %366 = load i8, ptr %nactvar26.i, align 2
  %conv27.i = zext i8 %366 to i32
  br label %retstat.exit

retstat.exit:                                     ; preds = %luaX_next.exit.i, %luaX_next.exit.i, %luaX_next.exit.i, %luaX_next.exit.i, %luaX_next.exit.i, %luaX_next.exit.i, %if.end.i, %if.then23.i, %luaK_exp2nextreg.exit.i
  %first.0.i = phi i32 [ %conv.i, %if.end.i ], [ %call24.i, %if.then23.i ], [ %conv27.i, %luaK_exp2nextreg.exit.i ], [ 0, %luaX_next.exit.i ], [ 0, %luaX_next.exit.i ], [ 0, %luaX_next.exit.i ], [ 0, %luaX_next.exit.i ], [ 0, %luaX_next.exit.i ], [ 0, %luaX_next.exit.i ]
  %nret.0.i = phi i32 [ -1, %if.end.i ], [ 1, %if.then23.i ], [ %inc.i.i, %luaK_exp2nextreg.exit.i ], [ 0, %luaX_next.exit.i ], [ 0, %luaX_next.exit.i ], [ 0, %luaX_next.exit.i ], [ 0, %luaX_next.exit.i ], [ 0, %luaX_next.exit.i ], [ 0, %luaX_next.exit.i ]
  %shl1.i.i.i = shl i32 %first.0.i, 6
  %add.i.i = shl i32 %nret.0.i, 23
  %shl2.i.i.i = add i32 %add.i.i, 8388608
  %or.i.i.i = or i32 %shl1.i.i.i, %shl2.i.i.i
  %or3.i.i.i = or disjoint i32 %or.i.i.i, 30
  %ls.i.i.i = getelementptr inbounds %struct.FuncState, ptr %311, i64 0, i32 3
  %367 = load ptr, ptr %ls.i.i.i, align 8
  %lastline.i.i.i = getelementptr inbounds %struct.LexState, ptr %367, i64 0, i32 2
  %368 = load i32, ptr %lastline.i.i.i, align 8
  %call.i.i.i = call fastcc i32 @luaK_code(ptr noundef %311, i32 noundef %or3.i.i.i, i32 noundef %368)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %e.i)
  br label %statement.exit

sw.bb8.i:                                         ; preds = %while.body
  store i32 %3, ptr %lastline.i, align 8
  %369 = load i32, ptr %lookahead.i, align 8
  %cmp.not.i = icmp eq i32 %369, 287
  br i1 %cmp.not.i, label %if.else.i19, label %if.then.i18

if.then.i18:                                      ; preds = %sw.bb8.i
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i, align 8
  br label %luaX_next.exit

if.else.i19:                                      ; preds = %sw.bb8.i
  %call.i20 = call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i)
  store i32 %call.i20, ptr %t, align 8
  br label %luaX_next.exit

luaX_next.exit:                                   ; preds = %if.then.i18, %if.else.i19
  call fastcc void @breakstat(ptr noundef nonnull %ls)
  br label %statement.exit

sw.default.i9:                                    ; preds = %while.body
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %v.i)
  %370 = load ptr, ptr %fs1.i21, align 8
  call fastcc void @primaryexp(ptr noundef nonnull %ls, ptr noundef nonnull %v2.i)
  %371 = load i32, ptr %v2.i, align 8
  %cmp.i14 = icmp eq i32 %371, 13
  br i1 %cmp.i14, label %if.then.i16, label %if.else.i15

if.then.i16:                                      ; preds = %sw.default.i9
  %372 = load ptr, ptr %370, align 8
  %code.i = getelementptr inbounds %struct.Proto, ptr %372, i64 0, i32 4
  %373 = load ptr, ptr %code.i, align 8
  %374 = load i32, ptr %u.i, align 8
  %idxprom.i = sext i32 %374 to i64
  %arrayidx.i = getelementptr inbounds i32, ptr %373, i64 %idxprom.i
  %375 = load i32, ptr %arrayidx.i, align 4
  %and.i = and i32 %375, -8372225
  %or.i = or disjoint i32 %and.i, 16384
  store i32 %or.i, ptr %arrayidx.i, align 4
  br label %exprstat.exit

if.else.i15:                                      ; preds = %sw.default.i9
  store ptr null, ptr %v.i, align 8
  call fastcc void @assignment(ptr noundef nonnull %ls, ptr noundef nonnull %v.i, i32 noundef 1)
  br label %exprstat.exit

exprstat.exit:                                    ; preds = %if.then.i16, %if.else.i15
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %v.i)
  br label %statement.exit

statement.exit:                                   ; preds = %ifstat.exit, %whilestat.exit, %luaX_next.exit233, %forstat.exit, %repeatstat.exit, %body.exit, %luaK_reserveregs.exit.i, %localstat.exit, %retstat.exit, %luaX_next.exit, %exprstat.exit
  %tobool.not = phi i1 [ true, %exprstat.exit ], [ false, %luaX_next.exit ], [ false, %retstat.exit ], [ true, %body.exit ], [ true, %repeatstat.exit ], [ true, %forstat.exit ], [ true, %luaX_next.exit233 ], [ true, %whilestat.exit ], [ true, %ifstat.exit ], [ true, %localstat.exit ], [ true, %luaK_reserveregs.exit.i ]
  %376 = load i32, ptr %t, align 8
  %cmp.i11 = icmp eq i32 %376, 59
  br i1 %cmp.i11, label %if.then.i13, label %testnext.exit

if.then.i13:                                      ; preds = %statement.exit
  %377 = load i32, ptr %linenumber.i, align 4
  store i32 %377, ptr %lastline.i, align 8
  %378 = load i32, ptr %lookahead.i, align 8
  %cmp.not.i.i = icmp eq i32 %378, 287
  br i1 %cmp.not.i.i, label %if.else.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %if.then.i13
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i, align 8
  br label %testnext.exit

if.else.i.i:                                      ; preds = %if.then.i13
  %call.i.i = call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i)
  store i32 %call.i.i, ptr %t, align 8
  br label %testnext.exit

testnext.exit:                                    ; preds = %statement.exit, %if.then.i.i, %if.else.i.i
  %379 = load ptr, ptr %fs1.i21, align 8
  %nactvar = getelementptr inbounds %struct.FuncState, ptr %379, i64 0, i32 13
  %380 = load i8, ptr %nactvar, align 2
  %conv = zext i8 %380 to i32
  %freereg = getelementptr inbounds %struct.FuncState, ptr %379, i64 0, i32 9
  store i32 %conv, ptr %freereg, align 4
  br i1 %tobool.not, label %land.rhs, label %while.end, !llvm.loop !101

while.end:                                        ; preds = %land.rhs, %land.rhs, %land.rhs, %land.rhs, %land.rhs, %testnext.exit
  %381 = load ptr, ptr %L.i, align 8
  %nCcalls = getelementptr inbounds %struct.lua_State, ptr %381, i64 0, i32 15
  %382 = load i16, ptr %nCcalls, align 8
  %dec = add i16 %382, -1
  store i16 %dec, ptr %nCcalls, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @close_func(ptr nocapture noundef %ls) unnamed_addr #0 {
entry:
  %L1 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 6
  %0 = load ptr, ptr %L1, align 8
  %fs2 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 5
  %1 = load ptr, ptr %fs2, align 8
  %2 = load ptr, ptr %1, align 8
  %nactvar.i = getelementptr inbounds %struct.FuncState, ptr %1, i64 0, i32 13
  %3 = load i8, ptr %nactvar.i, align 2
  %cmp2.i.not = icmp eq i8 %3, 0
  br i1 %cmp2.i.not, label %removevars.exit, label %while.body.lr.ph.i

while.body.lr.ph.i:                               ; preds = %entry
  %pc.i = getelementptr inbounds %struct.FuncState, ptr %1, i64 0, i32 6
  %.pre.i = load i32, ptr %pc.i, align 8
  br label %while.body.i

while.body.i:                                     ; preds = %while.body.i, %while.body.lr.ph.i
  %4 = phi i8 [ %3, %while.body.lr.ph.i ], [ %8, %while.body.i ]
  %5 = load ptr, ptr %1, align 8
  %locvars.i = getelementptr inbounds %struct.Proto, ptr %5, i64 0, i32 7
  %6 = load ptr, ptr %locvars.i, align 8
  %dec.i = add i8 %4, -1
  store i8 %dec.i, ptr %nactvar.i, align 2
  %idxprom.i = zext i8 %dec.i to i64
  %arrayidx.i = getelementptr inbounds %struct.FuncState, ptr %1, i64 0, i32 15, i64 %idxprom.i
  %7 = load i16, ptr %arrayidx.i, align 2
  %idxprom4.i = zext i16 %7 to i64
  %endpc.i = getelementptr inbounds %struct.LocVar, ptr %6, i64 %idxprom4.i, i32 2
  store i32 %.pre.i, ptr %endpc.i, align 4
  %8 = load i8, ptr %nactvar.i, align 2
  %cmp.i.not = icmp eq i8 %8, 0
  br i1 %cmp.i.not, label %removevars.exit, label %while.body.i, !llvm.loop !102

removevars.exit:                                  ; preds = %while.body.i, %entry
  %ls.i.i = getelementptr inbounds %struct.FuncState, ptr %1, i64 0, i32 3
  %9 = load ptr, ptr %ls.i.i, align 8
  %lastline.i.i = getelementptr inbounds %struct.LexState, ptr %9, i64 0, i32 2
  %10 = load i32, ptr %lastline.i.i, align 8
  %call.i.i = tail call fastcc i32 @luaK_code(ptr noundef nonnull %1, i32 noundef 8388638, i32 noundef %10)
  %pc = getelementptr inbounds %struct.FuncState, ptr %1, i64 0, i32 6
  %11 = load i32, ptr %pc, align 8
  %cmp = icmp sgt i32 %11, -2
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %removevars.exit
  %code = getelementptr inbounds %struct.Proto, ptr %2, i64 0, i32 4
  %12 = load ptr, ptr %code, align 8
  %sizecode = getelementptr inbounds %struct.Proto, ptr %2, i64 0, i32 12
  %13 = load i32, ptr %sizecode, align 8
  %conv5 = sext i32 %13 to i64
  %mul = shl nsw i64 %conv5, 2
  %conv7 = sext i32 %11 to i64
  %mul8 = shl nsw i64 %conv7, 2
  %l_G.i = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %14 = load ptr, ptr %l_G.i, align 8
  %frealloc.i = getelementptr inbounds %struct.global_State, ptr %14, i64 0, i32 1
  %15 = load ptr, ptr %frealloc.i, align 8
  %ud.i = getelementptr inbounds %struct.global_State, ptr %14, i64 0, i32 2
  %16 = load ptr, ptr %ud.i, align 8
  %call.i = tail call ptr %15(ptr noundef %16, ptr noundef %12, i64 noundef %mul, i64 noundef %mul8) #35
  %cmp.i61 = icmp eq ptr %call.i, null
  %cmp1.i = icmp ne i32 %11, 0
  %or.cond.i = and i1 %cmp1.i, %cmp.i61
  br i1 %or.cond.i, label %if.then.i, label %luaM_realloc_.exit

if.then.i:                                        ; preds = %cond.true
  %errorJmp.i.i = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 26
  %17 = load ptr, ptr %errorJmp.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %17, null
  br i1 %tobool.not.i.i, label %if.else.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %if.then.i
  %status.i.i = getelementptr inbounds %struct.lua_longjmp, ptr %17, i64 0, i32 2
  store volatile i32 4, ptr %status.i.i, align 8
  %18 = load ptr, ptr %errorJmp.i.i, align 8
  %b.i.i = getelementptr inbounds %struct.lua_longjmp, ptr %18, i64 0, i32 1
  tail call void @longjmp(ptr noundef nonnull %b.i.i, i32 noundef 1) #38
  unreachable

if.else.i.i:                                      ; preds = %if.then.i
  %status3.i.i = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 3
  store i8 4, ptr %status3.i.i, align 2
  %19 = load ptr, ptr %l_G.i, align 8
  %panic.i.i = getelementptr inbounds %struct.global_State, ptr %19, i64 0, i32 19
  %20 = load ptr, ptr %panic.i.i, align 8
  %tobool4.not.i.i = icmp eq ptr %20, null
  br i1 %tobool4.not.i.i, label %if.end.i.i, label %if.then5.i.i

if.then5.i.i:                                     ; preds = %if.else.i.i
  tail call fastcc void @resetstack(ptr noundef nonnull %0, i32 noundef 4)
  %21 = load ptr, ptr %l_G.i, align 8
  %panic7.i.i = getelementptr inbounds %struct.global_State, ptr %21, i64 0, i32 19
  %22 = load ptr, ptr %panic7.i.i, align 8
  %call.i.i62 = tail call i32 %22(ptr noundef nonnull %0) #35
  br label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then5.i.i, %if.else.i.i
  tail call void @exit(i32 noundef 1) #38
  unreachable

luaM_realloc_.exit:                               ; preds = %cond.true
  %totalbytes.i = getelementptr inbounds %struct.global_State, ptr %14, i64 0, i32 14
  %23 = load i64, ptr %totalbytes.i, align 8
  %sub.i = sub nsw i64 %mul8, %mul
  %add.i = add i64 %sub.i, %23
  store i64 %add.i, ptr %totalbytes.i, align 8
  store ptr %call.i, ptr %code, align 8
  %24 = load i32, ptr %pc, align 8
  store i32 %24, ptr %sizecode, align 8
  %cmp16 = icmp sgt i32 %24, -2
  br i1 %cmp16, label %cond.true18, label %cond.false25

cond.false:                                       ; preds = %removevars.exit
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef %0, ptr noundef nonnull @.str.5)
  unreachable

cond.true18:                                      ; preds = %luaM_realloc_.exit
  %lineinfo = getelementptr inbounds %struct.Proto, ptr %2, i64 0, i32 6
  %25 = load ptr, ptr %lineinfo, align 8
  %sizelineinfo = getelementptr inbounds %struct.Proto, ptr %2, i64 0, i32 13
  %26 = load i32, ptr %sizelineinfo, align 4
  %conv19 = sext i32 %26 to i64
  %mul20 = shl nsw i64 %conv19, 2
  %conv22 = sext i32 %24 to i64
  %mul23 = shl nsw i64 %conv22, 2
  %27 = load ptr, ptr %l_G.i, align 8
  %frealloc.i64 = getelementptr inbounds %struct.global_State, ptr %27, i64 0, i32 1
  %28 = load ptr, ptr %frealloc.i64, align 8
  %ud.i65 = getelementptr inbounds %struct.global_State, ptr %27, i64 0, i32 2
  %29 = load ptr, ptr %ud.i65, align 8
  %call.i66 = tail call ptr %28(ptr noundef %29, ptr noundef %25, i64 noundef %mul20, i64 noundef %mul23) #35
  %cmp.i67 = icmp eq ptr %call.i66, null
  %cmp1.i68 = icmp ne i32 %24, 0
  %or.cond.i69 = and i1 %cmp1.i68, %cmp.i67
  br i1 %or.cond.i69, label %if.then.i73, label %luaM_realloc_.exit87

if.then.i73:                                      ; preds = %cond.true18
  %errorJmp.i.i74 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 26
  %30 = load ptr, ptr %errorJmp.i.i74, align 8
  %tobool.not.i.i75 = icmp eq ptr %30, null
  br i1 %tobool.not.i.i75, label %if.else.i.i79, label %if.then.i.i76

if.then.i.i76:                                    ; preds = %if.then.i73
  %status.i.i77 = getelementptr inbounds %struct.lua_longjmp, ptr %30, i64 0, i32 2
  store volatile i32 4, ptr %status.i.i77, align 8
  %31 = load ptr, ptr %errorJmp.i.i74, align 8
  %b.i.i78 = getelementptr inbounds %struct.lua_longjmp, ptr %31, i64 0, i32 1
  tail call void @longjmp(ptr noundef nonnull %b.i.i78, i32 noundef 1) #38
  unreachable

if.else.i.i79:                                    ; preds = %if.then.i73
  %status3.i.i80 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 3
  store i8 4, ptr %status3.i.i80, align 2
  %32 = load ptr, ptr %l_G.i, align 8
  %panic.i.i81 = getelementptr inbounds %struct.global_State, ptr %32, i64 0, i32 19
  %33 = load ptr, ptr %panic.i.i81, align 8
  %tobool4.not.i.i82 = icmp eq ptr %33, null
  br i1 %tobool4.not.i.i82, label %if.end.i.i86, label %if.then5.i.i83

if.then5.i.i83:                                   ; preds = %if.else.i.i79
  tail call fastcc void @resetstack(ptr noundef nonnull %0, i32 noundef 4)
  %34 = load ptr, ptr %l_G.i, align 8
  %panic7.i.i84 = getelementptr inbounds %struct.global_State, ptr %34, i64 0, i32 19
  %35 = load ptr, ptr %panic7.i.i84, align 8
  %call.i.i85 = tail call i32 %35(ptr noundef nonnull %0) #35
  br label %if.end.i.i86

if.end.i.i86:                                     ; preds = %if.then5.i.i83, %if.else.i.i79
  tail call void @exit(i32 noundef 1) #38
  unreachable

luaM_realloc_.exit87:                             ; preds = %cond.true18
  %totalbytes.i70 = getelementptr inbounds %struct.global_State, ptr %27, i64 0, i32 14
  %36 = load i64, ptr %totalbytes.i70, align 8
  %sub.i71 = sub nsw i64 %mul23, %mul20
  %add.i72 = add i64 %sub.i71, %36
  store i64 %add.i72, ptr %totalbytes.i70, align 8
  store ptr %call.i66, ptr %lineinfo, align 8
  %37 = load i32, ptr %pc, align 8
  store i32 %37, ptr %sizelineinfo, align 4
  %nk = getelementptr inbounds %struct.FuncState, ptr %1, i64 0, i32 10
  %38 = load i32, ptr %nk, align 8
  %cmp34 = icmp sgt i32 %38, -2
  br i1 %cmp34, label %cond.true36, label %cond.false43

cond.false25:                                     ; preds = %luaM_realloc_.exit
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef nonnull %0, ptr noundef nonnull @.str.5)
  unreachable

cond.true36:                                      ; preds = %luaM_realloc_.exit87
  %k = getelementptr inbounds %struct.Proto, ptr %2, i64 0, i32 3
  %39 = load ptr, ptr %k, align 8
  %sizek = getelementptr inbounds %struct.Proto, ptr %2, i64 0, i32 11
  %40 = load i32, ptr %sizek, align 4
  %conv37 = sext i32 %40 to i64
  %mul38 = shl nsw i64 %conv37, 4
  %conv40 = sext i32 %38 to i64
  %mul41 = shl nsw i64 %conv40, 4
  %41 = load ptr, ptr %l_G.i, align 8
  %frealloc.i90 = getelementptr inbounds %struct.global_State, ptr %41, i64 0, i32 1
  %42 = load ptr, ptr %frealloc.i90, align 8
  %ud.i91 = getelementptr inbounds %struct.global_State, ptr %41, i64 0, i32 2
  %43 = load ptr, ptr %ud.i91, align 8
  %call.i92 = tail call ptr %42(ptr noundef %43, ptr noundef %39, i64 noundef %mul38, i64 noundef %mul41) #35
  %cmp.i93 = icmp eq ptr %call.i92, null
  %cmp1.i94 = icmp ne i32 %38, 0
  %or.cond.i95 = and i1 %cmp1.i94, %cmp.i93
  br i1 %or.cond.i95, label %if.then.i99, label %luaM_realloc_.exit113

if.then.i99:                                      ; preds = %cond.true36
  %errorJmp.i.i100 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 26
  %44 = load ptr, ptr %errorJmp.i.i100, align 8
  %tobool.not.i.i101 = icmp eq ptr %44, null
  br i1 %tobool.not.i.i101, label %if.else.i.i105, label %if.then.i.i102

if.then.i.i102:                                   ; preds = %if.then.i99
  %status.i.i103 = getelementptr inbounds %struct.lua_longjmp, ptr %44, i64 0, i32 2
  store volatile i32 4, ptr %status.i.i103, align 8
  %45 = load ptr, ptr %errorJmp.i.i100, align 8
  %b.i.i104 = getelementptr inbounds %struct.lua_longjmp, ptr %45, i64 0, i32 1
  tail call void @longjmp(ptr noundef nonnull %b.i.i104, i32 noundef 1) #38
  unreachable

if.else.i.i105:                                   ; preds = %if.then.i99
  %status3.i.i106 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 3
  store i8 4, ptr %status3.i.i106, align 2
  %46 = load ptr, ptr %l_G.i, align 8
  %panic.i.i107 = getelementptr inbounds %struct.global_State, ptr %46, i64 0, i32 19
  %47 = load ptr, ptr %panic.i.i107, align 8
  %tobool4.not.i.i108 = icmp eq ptr %47, null
  br i1 %tobool4.not.i.i108, label %if.end.i.i112, label %if.then5.i.i109

if.then5.i.i109:                                  ; preds = %if.else.i.i105
  tail call fastcc void @resetstack(ptr noundef nonnull %0, i32 noundef 4)
  %48 = load ptr, ptr %l_G.i, align 8
  %panic7.i.i110 = getelementptr inbounds %struct.global_State, ptr %48, i64 0, i32 19
  %49 = load ptr, ptr %panic7.i.i110, align 8
  %call.i.i111 = tail call i32 %49(ptr noundef nonnull %0) #35
  br label %if.end.i.i112

if.end.i.i112:                                    ; preds = %if.then5.i.i109, %if.else.i.i105
  tail call void @exit(i32 noundef 1) #38
  unreachable

luaM_realloc_.exit113:                            ; preds = %cond.true36
  %totalbytes.i96 = getelementptr inbounds %struct.global_State, ptr %41, i64 0, i32 14
  %50 = load i64, ptr %totalbytes.i96, align 8
  %sub.i97 = sub nsw i64 %mul41, %mul38
  %add.i98 = add i64 %sub.i97, %50
  store i64 %add.i98, ptr %totalbytes.i96, align 8
  store ptr %call.i92, ptr %k, align 8
  %51 = load i32, ptr %nk, align 8
  store i32 %51, ptr %sizek, align 4
  %np = getelementptr inbounds %struct.FuncState, ptr %1, i64 0, i32 11
  %52 = load i32, ptr %np, align 4
  %cmp52 = icmp sgt i32 %52, -2
  br i1 %cmp52, label %cond.true54, label %cond.false61

cond.false43:                                     ; preds = %luaM_realloc_.exit87
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef nonnull %0, ptr noundef nonnull @.str.5)
  unreachable

cond.true54:                                      ; preds = %luaM_realloc_.exit113
  %p = getelementptr inbounds %struct.Proto, ptr %2, i64 0, i32 5
  %53 = load ptr, ptr %p, align 8
  %sizep = getelementptr inbounds %struct.Proto, ptr %2, i64 0, i32 14
  %54 = load i32, ptr %sizep, align 8
  %conv55 = sext i32 %54 to i64
  %mul56 = shl nsw i64 %conv55, 3
  %conv58 = sext i32 %52 to i64
  %mul59 = shl nsw i64 %conv58, 3
  %55 = load ptr, ptr %l_G.i, align 8
  %frealloc.i116 = getelementptr inbounds %struct.global_State, ptr %55, i64 0, i32 1
  %56 = load ptr, ptr %frealloc.i116, align 8
  %ud.i117 = getelementptr inbounds %struct.global_State, ptr %55, i64 0, i32 2
  %57 = load ptr, ptr %ud.i117, align 8
  %call.i118 = tail call ptr %56(ptr noundef %57, ptr noundef %53, i64 noundef %mul56, i64 noundef %mul59) #35
  %cmp.i119 = icmp eq ptr %call.i118, null
  %cmp1.i120 = icmp ne i32 %52, 0
  %or.cond.i121 = and i1 %cmp1.i120, %cmp.i119
  br i1 %or.cond.i121, label %if.then.i125, label %luaM_realloc_.exit139

if.then.i125:                                     ; preds = %cond.true54
  %errorJmp.i.i126 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 26
  %58 = load ptr, ptr %errorJmp.i.i126, align 8
  %tobool.not.i.i127 = icmp eq ptr %58, null
  br i1 %tobool.not.i.i127, label %if.else.i.i131, label %if.then.i.i128

if.then.i.i128:                                   ; preds = %if.then.i125
  %status.i.i129 = getelementptr inbounds %struct.lua_longjmp, ptr %58, i64 0, i32 2
  store volatile i32 4, ptr %status.i.i129, align 8
  %59 = load ptr, ptr %errorJmp.i.i126, align 8
  %b.i.i130 = getelementptr inbounds %struct.lua_longjmp, ptr %59, i64 0, i32 1
  tail call void @longjmp(ptr noundef nonnull %b.i.i130, i32 noundef 1) #38
  unreachable

if.else.i.i131:                                   ; preds = %if.then.i125
  %status3.i.i132 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 3
  store i8 4, ptr %status3.i.i132, align 2
  %60 = load ptr, ptr %l_G.i, align 8
  %panic.i.i133 = getelementptr inbounds %struct.global_State, ptr %60, i64 0, i32 19
  %61 = load ptr, ptr %panic.i.i133, align 8
  %tobool4.not.i.i134 = icmp eq ptr %61, null
  br i1 %tobool4.not.i.i134, label %if.end.i.i138, label %if.then5.i.i135

if.then5.i.i135:                                  ; preds = %if.else.i.i131
  tail call fastcc void @resetstack(ptr noundef nonnull %0, i32 noundef 4)
  %62 = load ptr, ptr %l_G.i, align 8
  %panic7.i.i136 = getelementptr inbounds %struct.global_State, ptr %62, i64 0, i32 19
  %63 = load ptr, ptr %panic7.i.i136, align 8
  %call.i.i137 = tail call i32 %63(ptr noundef nonnull %0) #35
  br label %if.end.i.i138

if.end.i.i138:                                    ; preds = %if.then5.i.i135, %if.else.i.i131
  tail call void @exit(i32 noundef 1) #38
  unreachable

luaM_realloc_.exit139:                            ; preds = %cond.true54
  %totalbytes.i122 = getelementptr inbounds %struct.global_State, ptr %55, i64 0, i32 14
  %64 = load i64, ptr %totalbytes.i122, align 8
  %sub.i123 = sub nsw i64 %mul59, %mul56
  %add.i124 = add i64 %sub.i123, %64
  store i64 %add.i124, ptr %totalbytes.i122, align 8
  store ptr %call.i118, ptr %p, align 8
  %65 = load i32, ptr %np, align 4
  store i32 %65, ptr %sizep, align 8
  %nlocvars = getelementptr inbounds %struct.FuncState, ptr %1, i64 0, i32 12
  %66 = load i16, ptr %nlocvars, align 8
  %conv68 = sext i16 %66 to i64
  %add69 = add nsw i64 %conv68, 1
  %cmp71 = icmp ult i64 %add69, 1152921504606846976
  br i1 %cmp71, label %cond.true73, label %cond.false80

cond.false61:                                     ; preds = %luaM_realloc_.exit113
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef nonnull %0, ptr noundef nonnull @.str.5)
  unreachable

cond.true73:                                      ; preds = %luaM_realloc_.exit139
  %locvars = getelementptr inbounds %struct.Proto, ptr %2, i64 0, i32 7
  %67 = load ptr, ptr %locvars, align 8
  %sizelocvars = getelementptr inbounds %struct.Proto, ptr %2, i64 0, i32 15
  %68 = load i32, ptr %sizelocvars, align 4
  %conv74 = sext i32 %68 to i64
  %mul75 = shl nsw i64 %conv74, 4
  %mul78 = shl nsw i64 %conv68, 4
  %69 = load ptr, ptr %l_G.i, align 8
  %frealloc.i142 = getelementptr inbounds %struct.global_State, ptr %69, i64 0, i32 1
  %70 = load ptr, ptr %frealloc.i142, align 8
  %ud.i143 = getelementptr inbounds %struct.global_State, ptr %69, i64 0, i32 2
  %71 = load ptr, ptr %ud.i143, align 8
  %call.i144 = tail call ptr %70(ptr noundef %71, ptr noundef %67, i64 noundef %mul75, i64 noundef %mul78) #35
  %cmp.i145 = icmp eq ptr %call.i144, null
  %cmp1.i146 = icmp ne i16 %66, 0
  %or.cond.i147 = and i1 %cmp1.i146, %cmp.i145
  br i1 %or.cond.i147, label %if.then.i151, label %luaM_realloc_.exit165

if.then.i151:                                     ; preds = %cond.true73
  %errorJmp.i.i152 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 26
  %72 = load ptr, ptr %errorJmp.i.i152, align 8
  %tobool.not.i.i153 = icmp eq ptr %72, null
  br i1 %tobool.not.i.i153, label %if.else.i.i157, label %if.then.i.i154

if.then.i.i154:                                   ; preds = %if.then.i151
  %status.i.i155 = getelementptr inbounds %struct.lua_longjmp, ptr %72, i64 0, i32 2
  store volatile i32 4, ptr %status.i.i155, align 8
  %73 = load ptr, ptr %errorJmp.i.i152, align 8
  %b.i.i156 = getelementptr inbounds %struct.lua_longjmp, ptr %73, i64 0, i32 1
  tail call void @longjmp(ptr noundef nonnull %b.i.i156, i32 noundef 1) #38
  unreachable

if.else.i.i157:                                   ; preds = %if.then.i151
  %status3.i.i158 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 3
  store i8 4, ptr %status3.i.i158, align 2
  %74 = load ptr, ptr %l_G.i, align 8
  %panic.i.i159 = getelementptr inbounds %struct.global_State, ptr %74, i64 0, i32 19
  %75 = load ptr, ptr %panic.i.i159, align 8
  %tobool4.not.i.i160 = icmp eq ptr %75, null
  br i1 %tobool4.not.i.i160, label %if.end.i.i164, label %if.then5.i.i161

if.then5.i.i161:                                  ; preds = %if.else.i.i157
  tail call fastcc void @resetstack(ptr noundef nonnull %0, i32 noundef 4)
  %76 = load ptr, ptr %l_G.i, align 8
  %panic7.i.i162 = getelementptr inbounds %struct.global_State, ptr %76, i64 0, i32 19
  %77 = load ptr, ptr %panic7.i.i162, align 8
  %call.i.i163 = tail call i32 %77(ptr noundef nonnull %0) #35
  br label %if.end.i.i164

if.end.i.i164:                                    ; preds = %if.then5.i.i161, %if.else.i.i157
  tail call void @exit(i32 noundef 1) #38
  unreachable

luaM_realloc_.exit165:                            ; preds = %cond.true73
  %totalbytes.i148 = getelementptr inbounds %struct.global_State, ptr %69, i64 0, i32 14
  %78 = load i64, ptr %totalbytes.i148, align 8
  %sub.i149 = sub nsw i64 %mul78, %mul75
  %add.i150 = add i64 %sub.i149, %78
  store i64 %add.i150, ptr %totalbytes.i148, align 8
  store ptr %call.i144, ptr %locvars, align 8
  %79 = load i16, ptr %nlocvars, align 8
  %conv86 = sext i16 %79 to i32
  store i32 %conv86, ptr %sizelocvars, align 4
  %nups = getelementptr inbounds %struct.Proto, ptr %2, i64 0, i32 19
  %80 = load i8, ptr %nups, align 8
  %upvalues = getelementptr inbounds %struct.Proto, ptr %2, i64 0, i32 8
  %81 = load ptr, ptr %upvalues, align 8
  %sizeupvalues = getelementptr inbounds %struct.Proto, ptr %2, i64 0, i32 10
  %82 = load i32, ptr %sizeupvalues, align 8
  %conv94 = sext i32 %82 to i64
  %mul95 = shl nsw i64 %conv94, 3
  %conv97 = zext i8 %80 to i64
  %mul98 = shl nuw nsw i64 %conv97, 3
  %83 = load ptr, ptr %l_G.i, align 8
  %frealloc.i168 = getelementptr inbounds %struct.global_State, ptr %83, i64 0, i32 1
  %84 = load ptr, ptr %frealloc.i168, align 8
  %ud.i169 = getelementptr inbounds %struct.global_State, ptr %83, i64 0, i32 2
  %85 = load ptr, ptr %ud.i169, align 8
  %call.i170 = tail call ptr %84(ptr noundef %85, ptr noundef %81, i64 noundef %mul95, i64 noundef %mul98) #35
  %cmp.i171 = icmp eq ptr %call.i170, null
  %cmp1.i172 = icmp ne i8 %80, 0
  %or.cond.i173 = and i1 %cmp1.i172, %cmp.i171
  br i1 %or.cond.i173, label %if.then.i177, label %luaM_realloc_.exit191

cond.false80:                                     ; preds = %luaM_realloc_.exit139
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef nonnull %0, ptr noundef nonnull @.str.5)
  unreachable

if.then.i177:                                     ; preds = %luaM_realloc_.exit165
  %errorJmp.i.i178 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 26
  %86 = load ptr, ptr %errorJmp.i.i178, align 8
  %tobool.not.i.i179 = icmp eq ptr %86, null
  br i1 %tobool.not.i.i179, label %if.else.i.i183, label %if.then.i.i180

if.then.i.i180:                                   ; preds = %if.then.i177
  %status.i.i181 = getelementptr inbounds %struct.lua_longjmp, ptr %86, i64 0, i32 2
  store volatile i32 4, ptr %status.i.i181, align 8
  %87 = load ptr, ptr %errorJmp.i.i178, align 8
  %b.i.i182 = getelementptr inbounds %struct.lua_longjmp, ptr %87, i64 0, i32 1
  tail call void @longjmp(ptr noundef nonnull %b.i.i182, i32 noundef 1) #38
  unreachable

if.else.i.i183:                                   ; preds = %if.then.i177
  %status3.i.i184 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 3
  store i8 4, ptr %status3.i.i184, align 2
  %88 = load ptr, ptr %l_G.i, align 8
  %panic.i.i185 = getelementptr inbounds %struct.global_State, ptr %88, i64 0, i32 19
  %89 = load ptr, ptr %panic.i.i185, align 8
  %tobool4.not.i.i186 = icmp eq ptr %89, null
  br i1 %tobool4.not.i.i186, label %if.end.i.i190, label %if.then5.i.i187

if.then5.i.i187:                                  ; preds = %if.else.i.i183
  tail call fastcc void @resetstack(ptr noundef nonnull %0, i32 noundef 4)
  %90 = load ptr, ptr %l_G.i, align 8
  %panic7.i.i188 = getelementptr inbounds %struct.global_State, ptr %90, i64 0, i32 19
  %91 = load ptr, ptr %panic7.i.i188, align 8
  %call.i.i189 = tail call i32 %91(ptr noundef nonnull %0) #35
  br label %if.end.i.i190

if.end.i.i190:                                    ; preds = %if.then5.i.i187, %if.else.i.i183
  tail call void @exit(i32 noundef 1) #38
  unreachable

luaM_realloc_.exit191:                            ; preds = %luaM_realloc_.exit165
  %totalbytes.i174 = getelementptr inbounds %struct.global_State, ptr %83, i64 0, i32 14
  %92 = load i64, ptr %totalbytes.i174, align 8
  %sub.i175 = sub nsw i64 %mul98, %mul95
  %add.i176 = add i64 %sub.i175, %92
  store i64 %add.i176, ptr %totalbytes.i174, align 8
  store ptr %call.i170, ptr %upvalues, align 8
  %93 = load i8, ptr %nups, align 8
  %conv106 = zext i8 %93 to i32
  store i32 %conv106, ptr %sizeupvalues, align 8
  %prev = getelementptr inbounds %struct.FuncState, ptr %1, i64 0, i32 2
  %94 = load ptr, ptr %prev, align 8
  store ptr %94, ptr %fs2, align 8
  %t.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 3
  %95 = load i32, ptr %t.i, align 8
  %.off.i = add i32 %95, -285
  %switch.i = icmp ult i32 %.off.i, 2
  br i1 %switch.i, label %if.then.i192, label %anchor_token.exit

if.then.i192:                                     ; preds = %luaM_realloc_.exit191
  %seminfo.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 3, i32 1
  %96 = load ptr, ptr %seminfo.i, align 8
  %add.ptr.i = getelementptr inbounds %union.TString, ptr %96, i64 1
  %len.i = getelementptr inbounds %struct.anon.0, ptr %96, i64 0, i32 5
  %97 = load i64, ptr %len.i, align 8
  %call.i193 = tail call fastcc ptr @luaX_newstring(ptr noundef nonnull %ls, ptr noundef nonnull %add.ptr.i, i64 noundef %97)
  br label %anchor_token.exit

anchor_token.exit:                                ; preds = %luaM_realloc_.exit191, %if.then.i192
  %top = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %98 = load ptr, ptr %top, align 8
  %add.ptr = getelementptr inbounds %struct.lua_TValue, ptr %98, i64 -2
  store ptr %add.ptr, ptr %top, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @luaZ_fill(ptr nocapture noundef %z) unnamed_addr #0 {
entry:
  %size = alloca i64, align 8
  %L1 = getelementptr inbounds %struct.Zio, ptr %z, i64 0, i32 4
  %0 = load ptr, ptr %L1, align 8
  %reader = getelementptr inbounds %struct.Zio, ptr %z, i64 0, i32 2
  %1 = load ptr, ptr %reader, align 8
  %data = getelementptr inbounds %struct.Zio, ptr %z, i64 0, i32 3
  %2 = load ptr, ptr %data, align 8
  %call = call ptr %1(ptr noundef %0, ptr noundef %2, ptr noundef nonnull %size) #35
  %cmp = icmp eq ptr %call, null
  %3 = load i64, ptr %size, align 8
  %cmp2 = icmp eq i64 %3, 0
  %or.cond = select i1 %cmp, i1 true, i1 %cmp2
  br i1 %or.cond, label %return, label %if.end

if.end:                                           ; preds = %entry
  %sub = add i64 %3, -1
  store i64 %sub, ptr %z, align 8
  %p = getelementptr inbounds %struct.Zio, ptr %z, i64 0, i32 1
  %incdec.ptr = getelementptr inbounds i8, ptr %call, i64 1
  store ptr %incdec.ptr, ptr %p, align 8
  %4 = load i8, ptr %call, align 1
  %conv = zext i8 %4 to i32
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi i32 [ %conv, %if.end ], [ -1, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @llex(ptr noundef %ls, ptr noundef %seminfo) unnamed_addr #0 {
entry:
  %size.i295 = alloca i64, align 8
  %size.i280 = alloca i64, align 8
  %size.i.i250 = alloca i64, align 8
  %size.i.i221 = alloca i64, align 8
  %size.i206 = alloca i64, align 8
  %size.i130.i = alloca i64, align 8
  %size.i115.i = alloca i64, align 8
  %size.i100.i = alloca i64, align 8
  %size.i85.i = alloca i64, align 8
  %size.i70.i = alloca i64, align 8
  %size.i55.i = alloca i64, align 8
  %size.i.i = alloca i64, align 8
  %size.i186 = alloca i64, align 8
  %size.i171 = alloca i64, align 8
  %size.i156 = alloca i64, align 8
  %size.i141 = alloca i64, align 8
  %size.i126 = alloca i64, align 8
  %size.i111 = alloca i64, align 8
  %size.i = alloca i64, align 8
  %buff = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 8
  %0 = load ptr, ptr %buff, align 8
  %n = getelementptr inbounds %struct.Mbuffer, ptr %0, i64 0, i32 1
  store i64 0, ptr %n, align 8
  %z269 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 7
  br label %for.condthread-pre-split

for.condthread-pre-split:                         ; preds = %for.condthread-pre-split.backedge, %entry
  %.pr = load i32, ptr %ls, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.condthread-pre-split, %cond.end282
  %1 = phi i32 [ %.pr, %for.condthread-pre-split ], [ %cond283, %cond.end282 ]
  switch i32 %1, label %sw.default [
    i32 10, label %sw.bb
    i32 13, label %sw.bb
    i32 45, label %sw.bb1
    i32 91, label %sw.bb64
    i32 61, label %sw.bb75
    i32 60, label %sw.bb113
    i32 62, label %sw.bb151
    i32 126, label %sw.bb189
    i32 34, label %sw.bb227
    i32 39, label %sw.bb227
    i32 46, label %sw.bb229
    i32 -1, label %return
  ]

sw.bb:                                            ; preds = %for.cond, %for.cond
  call fastcc void @inclinenumber(ptr noundef nonnull %ls)
  br label %for.condthread-pre-split.backedge

sw.bb1:                                           ; preds = %for.cond
  %2 = load ptr, ptr %z269, align 8
  %3 = load i64, ptr %2, align 8
  %dec = add i64 %3, -1
  store i64 %dec, ptr %2, align 8
  %cmp.not = icmp eq i64 %3, 0
  %4 = load ptr, ptr %z269, align 8
  br i1 %cmp.not, label %cond.false, label %cond.true

cond.true:                                        ; preds = %sw.bb1
  %p = getelementptr inbounds %struct.Zio, ptr %4, i64 0, i32 1
  %5 = load ptr, ptr %p, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %5, i64 1
  store ptr %incdec.ptr, ptr %p, align 8
  %6 = load i8, ptr %5, align 1
  %conv = zext i8 %6 to i32
  br label %cond.end

cond.false:                                       ; preds = %sw.bb1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %size.i)
  %L1.i = getelementptr inbounds %struct.Zio, ptr %4, i64 0, i32 4
  %7 = load ptr, ptr %L1.i, align 8
  %reader.i = getelementptr inbounds %struct.Zio, ptr %4, i64 0, i32 2
  %8 = load ptr, ptr %reader.i, align 8
  %data.i = getelementptr inbounds %struct.Zio, ptr %4, i64 0, i32 3
  %9 = load ptr, ptr %data.i, align 8
  %call.i = call ptr %8(ptr noundef %7, ptr noundef %9, ptr noundef nonnull %size.i) #35
  %cmp.i = icmp eq ptr %call.i, null
  %10 = load i64, ptr %size.i, align 8
  %cmp2.i = icmp eq i64 %10, 0
  %or.cond.i = select i1 %cmp.i, i1 true, i1 %cmp2.i
  br i1 %or.cond.i, label %luaZ_fill.exit, label %if.end.i

if.end.i:                                         ; preds = %cond.false
  %sub.i = add i64 %10, -1
  store i64 %sub.i, ptr %4, align 8
  %p.i = getelementptr inbounds %struct.Zio, ptr %4, i64 0, i32 1
  %incdec.ptr.i = getelementptr inbounds i8, ptr %call.i, i64 1
  store ptr %incdec.ptr.i, ptr %p.i, align 8
  %11 = load i8, ptr %call.i, align 1
  %conv.i = zext i8 %11 to i32
  br label %luaZ_fill.exit

luaZ_fill.exit:                                   ; preds = %cond.false, %if.end.i
  %retval.0.i = phi i32 [ %conv.i, %if.end.i ], [ -1, %cond.false ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %size.i)
  br label %cond.end

cond.end:                                         ; preds = %luaZ_fill.exit, %cond.true
  %cond = phi i32 [ %conv, %cond.true ], [ %retval.0.i, %luaZ_fill.exit ]
  store i32 %cond, ptr %ls, align 8
  %cmp7.not = icmp eq i32 %cond, 45
  br i1 %cmp7.not, label %if.end, label %return

if.end:                                           ; preds = %cond.end
  %12 = load ptr, ptr %z269, align 8
  %13 = load i64, ptr %12, align 8
  %dec11 = add i64 %13, -1
  store i64 %dec11, ptr %12, align 8
  %cmp12.not = icmp eq i64 %13, 0
  %14 = load ptr, ptr %z269, align 8
  br i1 %cmp12.not, label %cond.false19, label %cond.true14

cond.true14:                                      ; preds = %if.end
  %p16 = getelementptr inbounds %struct.Zio, ptr %14, i64 0, i32 1
  %15 = load ptr, ptr %p16, align 8
  %incdec.ptr17 = getelementptr inbounds i8, ptr %15, i64 1
  store ptr %incdec.ptr17, ptr %p16, align 8
  %16 = load i8, ptr %15, align 1
  %conv18 = zext i8 %16 to i32
  br label %cond.end22

cond.false19:                                     ; preds = %if.end
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %size.i111)
  %L1.i112 = getelementptr inbounds %struct.Zio, ptr %14, i64 0, i32 4
  %17 = load ptr, ptr %L1.i112, align 8
  %reader.i113 = getelementptr inbounds %struct.Zio, ptr %14, i64 0, i32 2
  %18 = load ptr, ptr %reader.i113, align 8
  %data.i114 = getelementptr inbounds %struct.Zio, ptr %14, i64 0, i32 3
  %19 = load ptr, ptr %data.i114, align 8
  %call.i115 = call ptr %18(ptr noundef %17, ptr noundef %19, ptr noundef nonnull %size.i111) #35
  %cmp.i116 = icmp eq ptr %call.i115, null
  %20 = load i64, ptr %size.i111, align 8
  %cmp2.i117 = icmp eq i64 %20, 0
  %or.cond.i118 = select i1 %cmp.i116, i1 true, i1 %cmp2.i117
  br i1 %or.cond.i118, label %luaZ_fill.exit125, label %if.end.i119

if.end.i119:                                      ; preds = %cond.false19
  %sub.i120 = add i64 %20, -1
  store i64 %sub.i120, ptr %14, align 8
  %p.i121 = getelementptr inbounds %struct.Zio, ptr %14, i64 0, i32 1
  %incdec.ptr.i122 = getelementptr inbounds i8, ptr %call.i115, i64 1
  store ptr %incdec.ptr.i122, ptr %p.i121, align 8
  %21 = load i8, ptr %call.i115, align 1
  %conv.i123 = zext i8 %21 to i32
  br label %luaZ_fill.exit125

luaZ_fill.exit125:                                ; preds = %cond.false19, %if.end.i119
  %retval.0.i124 = phi i32 [ %conv.i123, %if.end.i119 ], [ -1, %cond.false19 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %size.i111)
  br label %cond.end22

cond.end22:                                       ; preds = %luaZ_fill.exit125, %cond.true14
  %cond23 = phi i32 [ %conv18, %cond.true14 ], [ %retval.0.i124, %luaZ_fill.exit125 ]
  store i32 %cond23, ptr %ls, align 8
  %cmp26 = icmp eq i32 %cond23, 91
  br i1 %cmp26, label %if.then28, label %while.cond.preheader

while.cond.preheader:                             ; preds = %if.then28.if.end38_crit_edge, %cond.end22
  %.ph = phi i32 [ %cond23, %cond.end22 ], [ %.pr310.pre, %if.then28.if.end38_crit_edge ]
  br label %while.cond

if.then28:                                        ; preds = %cond.end22
  %call29 = call fastcc i32 @skip_sep(ptr noundef nonnull %ls)
  %22 = load ptr, ptr %buff, align 8
  %n31 = getelementptr inbounds %struct.Mbuffer, ptr %22, i64 0, i32 1
  store i64 0, ptr %n31, align 8
  %cmp32 = icmp sgt i32 %call29, -1
  br i1 %cmp32, label %if.then34, label %if.then28.if.end38_crit_edge

if.then28.if.end38_crit_edge:                     ; preds = %if.then28
  %.pr310.pre = load i32, ptr %ls, align 8
  br label %while.cond.preheader

if.then34:                                        ; preds = %if.then28
  call fastcc void @read_long_string(ptr noundef nonnull %ls, ptr noundef null, i32 noundef %call29)
  %23 = load ptr, ptr %buff, align 8
  %n36 = getelementptr inbounds %struct.Mbuffer, ptr %23, i64 0, i32 1
  store i64 0, ptr %n36, align 8
  br label %for.condthread-pre-split.backedge

for.condthread-pre-split.backedge:                ; preds = %while.cond, %while.cond, %while.cond, %if.then34, %sw.bb
  br label %for.condthread-pre-split

while.cond:                                       ; preds = %while.cond.preheader, %cond.end61
  %24 = phi i32 [ %cond62, %cond.end61 ], [ %.ph, %while.cond.preheader ]
  switch i32 %24, label %while.body [
    i32 10, label %for.condthread-pre-split.backedge
    i32 13, label %for.condthread-pre-split.backedge
    i32 -1, label %for.condthread-pre-split.backedge
  ]

while.body:                                       ; preds = %while.cond
  %25 = load ptr, ptr %z269, align 8
  %26 = load i64, ptr %25, align 8
  %dec50 = add i64 %26, -1
  store i64 %dec50, ptr %25, align 8
  %cmp51.not = icmp eq i64 %26, 0
  %27 = load ptr, ptr %z269, align 8
  br i1 %cmp51.not, label %cond.false58, label %cond.true53

cond.true53:                                      ; preds = %while.body
  %p55 = getelementptr inbounds %struct.Zio, ptr %27, i64 0, i32 1
  %28 = load ptr, ptr %p55, align 8
  %incdec.ptr56 = getelementptr inbounds i8, ptr %28, i64 1
  store ptr %incdec.ptr56, ptr %p55, align 8
  %29 = load i8, ptr %28, align 1
  %conv57 = zext i8 %29 to i32
  br label %cond.end61

cond.false58:                                     ; preds = %while.body
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %size.i126)
  %L1.i127 = getelementptr inbounds %struct.Zio, ptr %27, i64 0, i32 4
  %30 = load ptr, ptr %L1.i127, align 8
  %reader.i128 = getelementptr inbounds %struct.Zio, ptr %27, i64 0, i32 2
  %31 = load ptr, ptr %reader.i128, align 8
  %data.i129 = getelementptr inbounds %struct.Zio, ptr %27, i64 0, i32 3
  %32 = load ptr, ptr %data.i129, align 8
  %call.i130 = call ptr %31(ptr noundef %30, ptr noundef %32, ptr noundef nonnull %size.i126) #35
  %cmp.i131 = icmp eq ptr %call.i130, null
  %33 = load i64, ptr %size.i126, align 8
  %cmp2.i132 = icmp eq i64 %33, 0
  %or.cond.i133 = select i1 %cmp.i131, i1 true, i1 %cmp2.i132
  br i1 %or.cond.i133, label %luaZ_fill.exit140, label %if.end.i134

if.end.i134:                                      ; preds = %cond.false58
  %sub.i135 = add i64 %33, -1
  store i64 %sub.i135, ptr %27, align 8
  %p.i136 = getelementptr inbounds %struct.Zio, ptr %27, i64 0, i32 1
  %incdec.ptr.i137 = getelementptr inbounds i8, ptr %call.i130, i64 1
  store ptr %incdec.ptr.i137, ptr %p.i136, align 8
  %34 = load i8, ptr %call.i130, align 1
  %conv.i138 = zext i8 %34 to i32
  br label %luaZ_fill.exit140

luaZ_fill.exit140:                                ; preds = %cond.false58, %if.end.i134
  %retval.0.i139 = phi i32 [ %conv.i138, %if.end.i134 ], [ -1, %cond.false58 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %size.i126)
  br label %cond.end61

cond.end61:                                       ; preds = %luaZ_fill.exit140, %cond.true53
  %cond62 = phi i32 [ %conv57, %cond.true53 ], [ %retval.0.i139, %luaZ_fill.exit140 ]
  store i32 %cond62, ptr %ls, align 8
  br label %while.cond, !llvm.loop !103

sw.bb64:                                          ; preds = %for.cond
  %call66 = call fastcc i32 @skip_sep(ptr noundef nonnull %ls)
  %cmp67 = icmp sgt i32 %call66, -1
  br i1 %cmp67, label %if.then69, label %if.else

if.then69:                                        ; preds = %sw.bb64
  call fastcc void @read_long_string(ptr noundef nonnull %ls, ptr noundef %seminfo, i32 noundef %call66)
  br label %return

if.else:                                          ; preds = %sw.bb64
  %cmp70.not = icmp eq i32 %call66, -1
  br i1 %cmp70.not, label %return, label %if.then72

if.then72:                                        ; preds = %if.else
  call fastcc void @luaX_lexerror(ptr noundef nonnull %ls, ptr noundef nonnull @.str.132, i32 noundef 286)
  unreachable

sw.bb75:                                          ; preds = %for.cond
  %35 = load ptr, ptr %z269, align 8
  %36 = load i64, ptr %35, align 8
  %dec78 = add i64 %36, -1
  store i64 %dec78, ptr %35, align 8
  %cmp79.not = icmp eq i64 %36, 0
  %37 = load ptr, ptr %z269, align 8
  br i1 %cmp79.not, label %cond.false86, label %cond.true81

cond.true81:                                      ; preds = %sw.bb75
  %p83 = getelementptr inbounds %struct.Zio, ptr %37, i64 0, i32 1
  %38 = load ptr, ptr %p83, align 8
  %incdec.ptr84 = getelementptr inbounds i8, ptr %38, i64 1
  store ptr %incdec.ptr84, ptr %p83, align 8
  %39 = load i8, ptr %38, align 1
  %conv85 = zext i8 %39 to i32
  br label %cond.end89

cond.false86:                                     ; preds = %sw.bb75
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %size.i141)
  %L1.i142 = getelementptr inbounds %struct.Zio, ptr %37, i64 0, i32 4
  %40 = load ptr, ptr %L1.i142, align 8
  %reader.i143 = getelementptr inbounds %struct.Zio, ptr %37, i64 0, i32 2
  %41 = load ptr, ptr %reader.i143, align 8
  %data.i144 = getelementptr inbounds %struct.Zio, ptr %37, i64 0, i32 3
  %42 = load ptr, ptr %data.i144, align 8
  %call.i145 = call ptr %41(ptr noundef %40, ptr noundef %42, ptr noundef nonnull %size.i141) #35
  %cmp.i146 = icmp eq ptr %call.i145, null
  %43 = load i64, ptr %size.i141, align 8
  %cmp2.i147 = icmp eq i64 %43, 0
  %or.cond.i148 = select i1 %cmp.i146, i1 true, i1 %cmp2.i147
  br i1 %or.cond.i148, label %luaZ_fill.exit155, label %if.end.i149

if.end.i149:                                      ; preds = %cond.false86
  %sub.i150 = add i64 %43, -1
  store i64 %sub.i150, ptr %37, align 8
  %p.i151 = getelementptr inbounds %struct.Zio, ptr %37, i64 0, i32 1
  %incdec.ptr.i152 = getelementptr inbounds i8, ptr %call.i145, i64 1
  store ptr %incdec.ptr.i152, ptr %p.i151, align 8
  %44 = load i8, ptr %call.i145, align 1
  %conv.i153 = zext i8 %44 to i32
  br label %luaZ_fill.exit155

luaZ_fill.exit155:                                ; preds = %cond.false86, %if.end.i149
  %retval.0.i154 = phi i32 [ %conv.i153, %if.end.i149 ], [ -1, %cond.false86 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %size.i141)
  br label %cond.end89

cond.end89:                                       ; preds = %luaZ_fill.exit155, %cond.true81
  %cond90 = phi i32 [ %conv85, %cond.true81 ], [ %retval.0.i154, %luaZ_fill.exit155 ]
  store i32 %cond90, ptr %ls, align 8
  %cmp93.not = icmp eq i32 %cond90, 61
  br i1 %cmp93.not, label %if.else96, label %return

if.else96:                                        ; preds = %cond.end89
  %45 = load ptr, ptr %z269, align 8
  %46 = load i64, ptr %45, align 8
  %dec99 = add i64 %46, -1
  store i64 %dec99, ptr %45, align 8
  %cmp100.not = icmp eq i64 %46, 0
  %47 = load ptr, ptr %z269, align 8
  br i1 %cmp100.not, label %cond.false107, label %cond.true102

cond.true102:                                     ; preds = %if.else96
  %p104 = getelementptr inbounds %struct.Zio, ptr %47, i64 0, i32 1
  %48 = load ptr, ptr %p104, align 8
  %incdec.ptr105 = getelementptr inbounds i8, ptr %48, i64 1
  store ptr %incdec.ptr105, ptr %p104, align 8
  %49 = load i8, ptr %48, align 1
  %conv106 = zext i8 %49 to i32
  br label %cond.end110

cond.false107:                                    ; preds = %if.else96
  %call109 = call fastcc i32 @luaZ_fill(ptr noundef %47), !range !104
  br label %cond.end110

cond.end110:                                      ; preds = %cond.false107, %cond.true102
  %cond111 = phi i32 [ %conv106, %cond.true102 ], [ %call109, %cond.false107 ]
  store i32 %cond111, ptr %ls, align 8
  br label %return

sw.bb113:                                         ; preds = %for.cond
  %50 = load ptr, ptr %z269, align 8
  %51 = load i64, ptr %50, align 8
  %dec116 = add i64 %51, -1
  store i64 %dec116, ptr %50, align 8
  %cmp117.not = icmp eq i64 %51, 0
  %52 = load ptr, ptr %z269, align 8
  br i1 %cmp117.not, label %cond.false124, label %cond.true119

cond.true119:                                     ; preds = %sw.bb113
  %p121 = getelementptr inbounds %struct.Zio, ptr %52, i64 0, i32 1
  %53 = load ptr, ptr %p121, align 8
  %incdec.ptr122 = getelementptr inbounds i8, ptr %53, i64 1
  store ptr %incdec.ptr122, ptr %p121, align 8
  %54 = load i8, ptr %53, align 1
  %conv123 = zext i8 %54 to i32
  br label %cond.end127

cond.false124:                                    ; preds = %sw.bb113
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %size.i156)
  %L1.i157 = getelementptr inbounds %struct.Zio, ptr %52, i64 0, i32 4
  %55 = load ptr, ptr %L1.i157, align 8
  %reader.i158 = getelementptr inbounds %struct.Zio, ptr %52, i64 0, i32 2
  %56 = load ptr, ptr %reader.i158, align 8
  %data.i159 = getelementptr inbounds %struct.Zio, ptr %52, i64 0, i32 3
  %57 = load ptr, ptr %data.i159, align 8
  %call.i160 = call ptr %56(ptr noundef %55, ptr noundef %57, ptr noundef nonnull %size.i156) #35
  %cmp.i161 = icmp eq ptr %call.i160, null
  %58 = load i64, ptr %size.i156, align 8
  %cmp2.i162 = icmp eq i64 %58, 0
  %or.cond.i163 = select i1 %cmp.i161, i1 true, i1 %cmp2.i162
  br i1 %or.cond.i163, label %luaZ_fill.exit170, label %if.end.i164

if.end.i164:                                      ; preds = %cond.false124
  %sub.i165 = add i64 %58, -1
  store i64 %sub.i165, ptr %52, align 8
  %p.i166 = getelementptr inbounds %struct.Zio, ptr %52, i64 0, i32 1
  %incdec.ptr.i167 = getelementptr inbounds i8, ptr %call.i160, i64 1
  store ptr %incdec.ptr.i167, ptr %p.i166, align 8
  %59 = load i8, ptr %call.i160, align 1
  %conv.i168 = zext i8 %59 to i32
  br label %luaZ_fill.exit170

luaZ_fill.exit170:                                ; preds = %cond.false124, %if.end.i164
  %retval.0.i169 = phi i32 [ %conv.i168, %if.end.i164 ], [ -1, %cond.false124 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %size.i156)
  br label %cond.end127

cond.end127:                                      ; preds = %luaZ_fill.exit170, %cond.true119
  %cond128 = phi i32 [ %conv123, %cond.true119 ], [ %retval.0.i169, %luaZ_fill.exit170 ]
  store i32 %cond128, ptr %ls, align 8
  %cmp131.not = icmp eq i32 %cond128, 61
  br i1 %cmp131.not, label %if.else134, label %return

if.else134:                                       ; preds = %cond.end127
  %60 = load ptr, ptr %z269, align 8
  %61 = load i64, ptr %60, align 8
  %dec137 = add i64 %61, -1
  store i64 %dec137, ptr %60, align 8
  %cmp138.not = icmp eq i64 %61, 0
  %62 = load ptr, ptr %z269, align 8
  br i1 %cmp138.not, label %cond.false145, label %cond.true140

cond.true140:                                     ; preds = %if.else134
  %p142 = getelementptr inbounds %struct.Zio, ptr %62, i64 0, i32 1
  %63 = load ptr, ptr %p142, align 8
  %incdec.ptr143 = getelementptr inbounds i8, ptr %63, i64 1
  store ptr %incdec.ptr143, ptr %p142, align 8
  %64 = load i8, ptr %63, align 1
  %conv144 = zext i8 %64 to i32
  br label %cond.end148

cond.false145:                                    ; preds = %if.else134
  %call147 = call fastcc i32 @luaZ_fill(ptr noundef %62), !range !104
  br label %cond.end148

cond.end148:                                      ; preds = %cond.false145, %cond.true140
  %cond149 = phi i32 [ %conv144, %cond.true140 ], [ %call147, %cond.false145 ]
  store i32 %cond149, ptr %ls, align 8
  br label %return

sw.bb151:                                         ; preds = %for.cond
  %65 = load ptr, ptr %z269, align 8
  %66 = load i64, ptr %65, align 8
  %dec154 = add i64 %66, -1
  store i64 %dec154, ptr %65, align 8
  %cmp155.not = icmp eq i64 %66, 0
  %67 = load ptr, ptr %z269, align 8
  br i1 %cmp155.not, label %cond.false162, label %cond.true157

cond.true157:                                     ; preds = %sw.bb151
  %p159 = getelementptr inbounds %struct.Zio, ptr %67, i64 0, i32 1
  %68 = load ptr, ptr %p159, align 8
  %incdec.ptr160 = getelementptr inbounds i8, ptr %68, i64 1
  store ptr %incdec.ptr160, ptr %p159, align 8
  %69 = load i8, ptr %68, align 1
  %conv161 = zext i8 %69 to i32
  br label %cond.end165

cond.false162:                                    ; preds = %sw.bb151
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %size.i171)
  %L1.i172 = getelementptr inbounds %struct.Zio, ptr %67, i64 0, i32 4
  %70 = load ptr, ptr %L1.i172, align 8
  %reader.i173 = getelementptr inbounds %struct.Zio, ptr %67, i64 0, i32 2
  %71 = load ptr, ptr %reader.i173, align 8
  %data.i174 = getelementptr inbounds %struct.Zio, ptr %67, i64 0, i32 3
  %72 = load ptr, ptr %data.i174, align 8
  %call.i175 = call ptr %71(ptr noundef %70, ptr noundef %72, ptr noundef nonnull %size.i171) #35
  %cmp.i176 = icmp eq ptr %call.i175, null
  %73 = load i64, ptr %size.i171, align 8
  %cmp2.i177 = icmp eq i64 %73, 0
  %or.cond.i178 = select i1 %cmp.i176, i1 true, i1 %cmp2.i177
  br i1 %or.cond.i178, label %luaZ_fill.exit185, label %if.end.i179

if.end.i179:                                      ; preds = %cond.false162
  %sub.i180 = add i64 %73, -1
  store i64 %sub.i180, ptr %67, align 8
  %p.i181 = getelementptr inbounds %struct.Zio, ptr %67, i64 0, i32 1
  %incdec.ptr.i182 = getelementptr inbounds i8, ptr %call.i175, i64 1
  store ptr %incdec.ptr.i182, ptr %p.i181, align 8
  %74 = load i8, ptr %call.i175, align 1
  %conv.i183 = zext i8 %74 to i32
  br label %luaZ_fill.exit185

luaZ_fill.exit185:                                ; preds = %cond.false162, %if.end.i179
  %retval.0.i184 = phi i32 [ %conv.i183, %if.end.i179 ], [ -1, %cond.false162 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %size.i171)
  br label %cond.end165

cond.end165:                                      ; preds = %luaZ_fill.exit185, %cond.true157
  %cond166 = phi i32 [ %conv161, %cond.true157 ], [ %retval.0.i184, %luaZ_fill.exit185 ]
  store i32 %cond166, ptr %ls, align 8
  %cmp169.not = icmp eq i32 %cond166, 61
  br i1 %cmp169.not, label %if.else172, label %return

if.else172:                                       ; preds = %cond.end165
  %75 = load ptr, ptr %z269, align 8
  %76 = load i64, ptr %75, align 8
  %dec175 = add i64 %76, -1
  store i64 %dec175, ptr %75, align 8
  %cmp176.not = icmp eq i64 %76, 0
  %77 = load ptr, ptr %z269, align 8
  br i1 %cmp176.not, label %cond.false183, label %cond.true178

cond.true178:                                     ; preds = %if.else172
  %p180 = getelementptr inbounds %struct.Zio, ptr %77, i64 0, i32 1
  %78 = load ptr, ptr %p180, align 8
  %incdec.ptr181 = getelementptr inbounds i8, ptr %78, i64 1
  store ptr %incdec.ptr181, ptr %p180, align 8
  %79 = load i8, ptr %78, align 1
  %conv182 = zext i8 %79 to i32
  br label %cond.end186

cond.false183:                                    ; preds = %if.else172
  %call185 = call fastcc i32 @luaZ_fill(ptr noundef %77), !range !104
  br label %cond.end186

cond.end186:                                      ; preds = %cond.false183, %cond.true178
  %cond187 = phi i32 [ %conv182, %cond.true178 ], [ %call185, %cond.false183 ]
  store i32 %cond187, ptr %ls, align 8
  br label %return

sw.bb189:                                         ; preds = %for.cond
  %80 = load ptr, ptr %z269, align 8
  %81 = load i64, ptr %80, align 8
  %dec192 = add i64 %81, -1
  store i64 %dec192, ptr %80, align 8
  %cmp193.not = icmp eq i64 %81, 0
  %82 = load ptr, ptr %z269, align 8
  br i1 %cmp193.not, label %cond.false200, label %cond.true195

cond.true195:                                     ; preds = %sw.bb189
  %p197 = getelementptr inbounds %struct.Zio, ptr %82, i64 0, i32 1
  %83 = load ptr, ptr %p197, align 8
  %incdec.ptr198 = getelementptr inbounds i8, ptr %83, i64 1
  store ptr %incdec.ptr198, ptr %p197, align 8
  %84 = load i8, ptr %83, align 1
  %conv199 = zext i8 %84 to i32
  br label %cond.end203

cond.false200:                                    ; preds = %sw.bb189
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %size.i186)
  %L1.i187 = getelementptr inbounds %struct.Zio, ptr %82, i64 0, i32 4
  %85 = load ptr, ptr %L1.i187, align 8
  %reader.i188 = getelementptr inbounds %struct.Zio, ptr %82, i64 0, i32 2
  %86 = load ptr, ptr %reader.i188, align 8
  %data.i189 = getelementptr inbounds %struct.Zio, ptr %82, i64 0, i32 3
  %87 = load ptr, ptr %data.i189, align 8
  %call.i190 = call ptr %86(ptr noundef %85, ptr noundef %87, ptr noundef nonnull %size.i186) #35
  %cmp.i191 = icmp eq ptr %call.i190, null
  %88 = load i64, ptr %size.i186, align 8
  %cmp2.i192 = icmp eq i64 %88, 0
  %or.cond.i193 = select i1 %cmp.i191, i1 true, i1 %cmp2.i192
  br i1 %or.cond.i193, label %luaZ_fill.exit200, label %if.end.i194

if.end.i194:                                      ; preds = %cond.false200
  %sub.i195 = add i64 %88, -1
  store i64 %sub.i195, ptr %82, align 8
  %p.i196 = getelementptr inbounds %struct.Zio, ptr %82, i64 0, i32 1
  %incdec.ptr.i197 = getelementptr inbounds i8, ptr %call.i190, i64 1
  store ptr %incdec.ptr.i197, ptr %p.i196, align 8
  %89 = load i8, ptr %call.i190, align 1
  %conv.i198 = zext i8 %89 to i32
  br label %luaZ_fill.exit200

luaZ_fill.exit200:                                ; preds = %cond.false200, %if.end.i194
  %retval.0.i199 = phi i32 [ %conv.i198, %if.end.i194 ], [ -1, %cond.false200 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %size.i186)
  br label %cond.end203

cond.end203:                                      ; preds = %luaZ_fill.exit200, %cond.true195
  %cond204 = phi i32 [ %conv199, %cond.true195 ], [ %retval.0.i199, %luaZ_fill.exit200 ]
  store i32 %cond204, ptr %ls, align 8
  %cmp207.not = icmp eq i32 %cond204, 61
  br i1 %cmp207.not, label %if.else210, label %return

if.else210:                                       ; preds = %cond.end203
  %90 = load ptr, ptr %z269, align 8
  %91 = load i64, ptr %90, align 8
  %dec213 = add i64 %91, -1
  store i64 %dec213, ptr %90, align 8
  %cmp214.not = icmp eq i64 %91, 0
  %92 = load ptr, ptr %z269, align 8
  br i1 %cmp214.not, label %cond.false221, label %cond.true216

cond.true216:                                     ; preds = %if.else210
  %p218 = getelementptr inbounds %struct.Zio, ptr %92, i64 0, i32 1
  %93 = load ptr, ptr %p218, align 8
  %incdec.ptr219 = getelementptr inbounds i8, ptr %93, i64 1
  store ptr %incdec.ptr219, ptr %p218, align 8
  %94 = load i8, ptr %93, align 1
  %conv220 = zext i8 %94 to i32
  br label %cond.end224

cond.false221:                                    ; preds = %if.else210
  %call223 = call fastcc i32 @luaZ_fill(ptr noundef %92), !range !104
  br label %cond.end224

cond.end224:                                      ; preds = %cond.false221, %cond.true216
  %cond225 = phi i32 [ %conv220, %cond.true216 ], [ %call223, %cond.false221 ]
  store i32 %cond225, ptr %ls, align 8
  br label %return

sw.bb227:                                         ; preds = %for.cond, %for.cond
  call fastcc void @save(ptr noundef nonnull %ls, i32 noundef %1)
  %95 = load ptr, ptr %z269, align 8
  %96 = load i64, ptr %95, align 8
  %dec.i = add i64 %96, -1
  store i64 %dec.i, ptr %95, align 8
  %cmp.not.i = icmp eq i64 %96, 0
  %97 = load ptr, ptr %z269, align 8
  br i1 %cmp.not.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %sw.bb227
  %p.i201 = getelementptr inbounds %struct.Zio, ptr %97, i64 0, i32 1
  %98 = load ptr, ptr %p.i201, align 8
  %incdec.ptr.i202 = getelementptr inbounds i8, ptr %98, i64 1
  store ptr %incdec.ptr.i202, ptr %p.i201, align 8
  %99 = load i8, ptr %98, align 1
  %conv.i203 = zext i8 %99 to i32
  br label %cond.end.i

cond.false.i:                                     ; preds = %sw.bb227
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %size.i.i)
  %L1.i.i = getelementptr inbounds %struct.Zio, ptr %97, i64 0, i32 4
  %100 = load ptr, ptr %L1.i.i, align 8
  %reader.i.i = getelementptr inbounds %struct.Zio, ptr %97, i64 0, i32 2
  %101 = load ptr, ptr %reader.i.i, align 8
  %data.i.i = getelementptr inbounds %struct.Zio, ptr %97, i64 0, i32 3
  %102 = load ptr, ptr %data.i.i, align 8
  %call.i.i = call ptr %101(ptr noundef %100, ptr noundef %102, ptr noundef nonnull %size.i.i) #35
  %cmp.i.i = icmp eq ptr %call.i.i, null
  %103 = load i64, ptr %size.i.i, align 8
  %cmp2.i.i = icmp eq i64 %103, 0
  %or.cond.i.i = select i1 %cmp.i.i, i1 true, i1 %cmp2.i.i
  br i1 %or.cond.i.i, label %luaZ_fill.exit.i, label %if.end.i.i

if.end.i.i:                                       ; preds = %cond.false.i
  %sub.i.i = add i64 %103, -1
  store i64 %sub.i.i, ptr %97, align 8
  %p.i.i = getelementptr inbounds %struct.Zio, ptr %97, i64 0, i32 1
  %incdec.ptr.i.i = getelementptr inbounds i8, ptr %call.i.i, i64 1
  store ptr %incdec.ptr.i.i, ptr %p.i.i, align 8
  %104 = load i8, ptr %call.i.i, align 1
  %conv.i.i = zext i8 %104 to i32
  br label %luaZ_fill.exit.i

luaZ_fill.exit.i:                                 ; preds = %if.end.i.i, %cond.false.i
  %retval.0.i.i = phi i32 [ %conv.i.i, %if.end.i.i ], [ -1, %cond.false.i ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %size.i.i)
  br label %cond.end.i

cond.end.i:                                       ; preds = %luaZ_fill.exit.i, %cond.true.i
  %cond.i = phi i32 [ %conv.i203, %cond.true.i ], [ %retval.0.i.i, %luaZ_fill.exit.i ]
  store i32 %cond.i, ptr %ls, align 8
  %cmp5.not148.i = icmp eq i32 %cond.i, %1
  br i1 %cmp5.not148.i, label %while.end.i, label %while.body.i

while.condthread-pre-split.i:                     ; preds = %if.end.i205, %cond.end53.i, %sw.bb34.i
  %.pr.i = load i32, ptr %ls, align 8
  br label %while.cond.backedge.i

while.body.i:                                     ; preds = %cond.end.i, %while.cond.backedge.i
  %105 = phi i32 [ %.be.i, %while.cond.backedge.i ], [ %cond.i, %cond.end.i ]
  switch i32 %105, label %sw.default102.i [
    i32 -1, label %sw.bb.i
    i32 10, label %sw.bb8.i
    i32 13, label %sw.bb8.i
    i32 92, label %sw.bb9.i
  ]

sw.bb.i:                                          ; preds = %while.body.i
  call fastcc void @luaX_lexerror(ptr noundef nonnull %ls, ptr noundef nonnull @.str.140, i32 noundef 287)
  unreachable

sw.bb8.i:                                         ; preds = %while.body.i, %while.body.i
  call fastcc void @luaX_lexerror(ptr noundef nonnull %ls, ptr noundef nonnull @.str.140, i32 noundef 286)
  unreachable

sw.bb9.i:                                         ; preds = %while.body.i
  %106 = load ptr, ptr %z269, align 8
  %107 = load i64, ptr %106, align 8
  %dec12.i = add i64 %107, -1
  store i64 %dec12.i, ptr %106, align 8
  %cmp13.not.i = icmp eq i64 %107, 0
  %108 = load ptr, ptr %z269, align 8
  br i1 %cmp13.not.i, label %cond.false20.i, label %cond.true15.i

cond.true15.i:                                    ; preds = %sw.bb9.i
  %p17.i = getelementptr inbounds %struct.Zio, ptr %108, i64 0, i32 1
  %109 = load ptr, ptr %p17.i, align 8
  %incdec.ptr18.i = getelementptr inbounds i8, ptr %109, i64 1
  store ptr %incdec.ptr18.i, ptr %p17.i, align 8
  %110 = load i8, ptr %109, align 1
  %conv19.i = zext i8 %110 to i32
  br label %cond.end23.i

cond.false20.i:                                   ; preds = %sw.bb9.i
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %size.i55.i)
  %L1.i56.i = getelementptr inbounds %struct.Zio, ptr %108, i64 0, i32 4
  %111 = load ptr, ptr %L1.i56.i, align 8
  %reader.i57.i = getelementptr inbounds %struct.Zio, ptr %108, i64 0, i32 2
  %112 = load ptr, ptr %reader.i57.i, align 8
  %data.i58.i = getelementptr inbounds %struct.Zio, ptr %108, i64 0, i32 3
  %113 = load ptr, ptr %data.i58.i, align 8
  %call.i59.i = call ptr %112(ptr noundef %111, ptr noundef %113, ptr noundef nonnull %size.i55.i) #35
  %cmp.i60.i = icmp eq ptr %call.i59.i, null
  %114 = load i64, ptr %size.i55.i, align 8
  %cmp2.i61.i = icmp eq i64 %114, 0
  %or.cond.i62.i = select i1 %cmp.i60.i, i1 true, i1 %cmp2.i61.i
  br i1 %or.cond.i62.i, label %luaZ_fill.exit69.i, label %if.end.i63.i

if.end.i63.i:                                     ; preds = %cond.false20.i
  %sub.i64.i = add i64 %114, -1
  store i64 %sub.i64.i, ptr %108, align 8
  %p.i65.i = getelementptr inbounds %struct.Zio, ptr %108, i64 0, i32 1
  %incdec.ptr.i66.i = getelementptr inbounds i8, ptr %call.i59.i, i64 1
  store ptr %incdec.ptr.i66.i, ptr %p.i65.i, align 8
  %115 = load i8, ptr %call.i59.i, align 1
  %conv.i67.i = zext i8 %115 to i32
  br label %luaZ_fill.exit69.i

luaZ_fill.exit69.i:                               ; preds = %if.end.i63.i, %cond.false20.i
  %retval.0.i68.i = phi i32 [ %conv.i67.i, %if.end.i63.i ], [ -1, %cond.false20.i ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %size.i55.i)
  br label %cond.end23.i

cond.end23.i:                                     ; preds = %luaZ_fill.exit69.i, %cond.true15.i
  %cond24.i = phi i32 [ %conv19.i, %cond.true15.i ], [ %retval.0.i68.i, %luaZ_fill.exit69.i ]
  store i32 %cond24.i, ptr %ls, align 8
  switch i32 %cond24.i, label %sw.default.i [
    i32 97, label %sw.epilog.i
    i32 98, label %sw.bb28.i
    i32 102, label %sw.bb29.i
    i32 110, label %sw.bb30.i
    i32 114, label %sw.bb31.i
    i32 116, label %sw.bb32.i
    i32 118, label %sw.bb33.i
    i32 10, label %sw.bb34.i
    i32 13, label %sw.bb34.i
    i32 -1, label %while.cond.backedge.i
  ]

sw.bb28.i:                                        ; preds = %cond.end23.i
  br label %sw.epilog.i

sw.bb29.i:                                        ; preds = %cond.end23.i
  br label %sw.epilog.i

sw.bb30.i:                                        ; preds = %cond.end23.i
  br label %sw.epilog.i

sw.bb31.i:                                        ; preds = %cond.end23.i
  br label %sw.epilog.i

sw.bb32.i:                                        ; preds = %cond.end23.i
  br label %sw.epilog.i

sw.bb33.i:                                        ; preds = %cond.end23.i
  br label %sw.epilog.i

sw.bb34.i:                                        ; preds = %cond.end23.i, %cond.end23.i
  call fastcc void @save(ptr noundef nonnull %ls, i32 noundef 10)
  call fastcc void @inclinenumber(ptr noundef nonnull %ls)
  br label %while.condthread-pre-split.i, !llvm.loop !105

sw.default.i:                                     ; preds = %cond.end23.i
  %call36.i = tail call ptr @__ctype_b_loc() #39
  %116 = load ptr, ptr %call36.i, align 8
  %idxprom.i = sext i32 %cond24.i to i64
  %arrayidx.i = getelementptr inbounds i16, ptr %116, i64 %idxprom.i
  %117 = load i16, ptr %arrayidx.i, align 2
  %118 = and i16 %117, 2048
  %tobool.not.i = icmp eq i16 %118, 0
  br i1 %tobool.not.i, label %if.then.i, label %do.body.i

if.then.i:                                        ; preds = %sw.default.i
  call fastcc void @save(ptr noundef nonnull %ls, i32 noundef %cond24.i)
  %119 = load ptr, ptr %z269, align 8
  %120 = load i64, ptr %119, align 8
  %dec42.i = add i64 %120, -1
  store i64 %dec42.i, ptr %119, align 8
  %cmp43.not.i = icmp eq i64 %120, 0
  %121 = load ptr, ptr %z269, align 8
  br i1 %cmp43.not.i, label %cond.false50.i, label %cond.true45.i

cond.true45.i:                                    ; preds = %if.then.i
  %p47.i = getelementptr inbounds %struct.Zio, ptr %121, i64 0, i32 1
  %122 = load ptr, ptr %p47.i, align 8
  %incdec.ptr48.i = getelementptr inbounds i8, ptr %122, i64 1
  store ptr %incdec.ptr48.i, ptr %p47.i, align 8
  %123 = load i8, ptr %122, align 1
  %conv49.i = zext i8 %123 to i32
  br label %cond.end53.i

cond.false50.i:                                   ; preds = %if.then.i
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %size.i70.i)
  %L1.i71.i = getelementptr inbounds %struct.Zio, ptr %121, i64 0, i32 4
  %124 = load ptr, ptr %L1.i71.i, align 8
  %reader.i72.i = getelementptr inbounds %struct.Zio, ptr %121, i64 0, i32 2
  %125 = load ptr, ptr %reader.i72.i, align 8
  %data.i73.i = getelementptr inbounds %struct.Zio, ptr %121, i64 0, i32 3
  %126 = load ptr, ptr %data.i73.i, align 8
  %call.i74.i = call ptr %125(ptr noundef %124, ptr noundef %126, ptr noundef nonnull %size.i70.i) #35
  %cmp.i75.i = icmp eq ptr %call.i74.i, null
  %127 = load i64, ptr %size.i70.i, align 8
  %cmp2.i76.i = icmp eq i64 %127, 0
  %or.cond.i77.i = select i1 %cmp.i75.i, i1 true, i1 %cmp2.i76.i
  br i1 %or.cond.i77.i, label %luaZ_fill.exit84.i, label %if.end.i78.i

if.end.i78.i:                                     ; preds = %cond.false50.i
  %sub.i79.i = add i64 %127, -1
  store i64 %sub.i79.i, ptr %121, align 8
  %p.i80.i = getelementptr inbounds %struct.Zio, ptr %121, i64 0, i32 1
  %incdec.ptr.i81.i = getelementptr inbounds i8, ptr %call.i74.i, i64 1
  store ptr %incdec.ptr.i81.i, ptr %p.i80.i, align 8
  %128 = load i8, ptr %call.i74.i, align 1
  %conv.i82.i = zext i8 %128 to i32
  br label %luaZ_fill.exit84.i

luaZ_fill.exit84.i:                               ; preds = %if.end.i78.i, %cond.false50.i
  %retval.0.i83.i = phi i32 [ %conv.i82.i, %if.end.i78.i ], [ -1, %cond.false50.i ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %size.i70.i)
  br label %cond.end53.i

cond.end53.i:                                     ; preds = %luaZ_fill.exit84.i, %cond.true45.i
  %cond54.i = phi i32 [ %conv49.i, %cond.true45.i ], [ %retval.0.i83.i, %luaZ_fill.exit84.i ]
  store i32 %cond54.i, ptr %ls, align 8
  br label %while.condthread-pre-split.i, !llvm.loop !105

do.body.i:                                        ; preds = %sw.default.i, %land.rhs.i
  %129 = phi i32 [ %cond71.i, %land.rhs.i ], [ %cond24.i, %sw.default.i ]
  %c.0.i = phi i32 [ %add.i, %land.rhs.i ], [ 0, %sw.default.i ]
  %i.0.i = phi i32 [ %inc.i, %land.rhs.i ], [ 0, %sw.default.i ]
  %mul.i = mul nsw i32 %c.0.i, 10
  %sub.i204 = add nsw i32 %129, -48
  %add.i = add i32 %sub.i204, %mul.i
  %130 = load ptr, ptr %z269, align 8
  %131 = load i64, ptr %130, align 8
  %dec59.i = add i64 %131, -1
  store i64 %dec59.i, ptr %130, align 8
  %cmp60.not.i = icmp eq i64 %131, 0
  %132 = load ptr, ptr %z269, align 8
  br i1 %cmp60.not.i, label %cond.false67.i, label %cond.true62.i

cond.true62.i:                                    ; preds = %do.body.i
  %p64.i = getelementptr inbounds %struct.Zio, ptr %132, i64 0, i32 1
  %133 = load ptr, ptr %p64.i, align 8
  %incdec.ptr65.i = getelementptr inbounds i8, ptr %133, i64 1
  store ptr %incdec.ptr65.i, ptr %p64.i, align 8
  %134 = load i8, ptr %133, align 1
  %conv66.i = zext i8 %134 to i32
  br label %cond.end70.i

cond.false67.i:                                   ; preds = %do.body.i
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %size.i85.i)
  %L1.i86.i = getelementptr inbounds %struct.Zio, ptr %132, i64 0, i32 4
  %135 = load ptr, ptr %L1.i86.i, align 8
  %reader.i87.i = getelementptr inbounds %struct.Zio, ptr %132, i64 0, i32 2
  %136 = load ptr, ptr %reader.i87.i, align 8
  %data.i88.i = getelementptr inbounds %struct.Zio, ptr %132, i64 0, i32 3
  %137 = load ptr, ptr %data.i88.i, align 8
  %call.i89.i = call ptr %136(ptr noundef %135, ptr noundef %137, ptr noundef nonnull %size.i85.i) #35
  %cmp.i90.i = icmp eq ptr %call.i89.i, null
  %138 = load i64, ptr %size.i85.i, align 8
  %cmp2.i91.i = icmp eq i64 %138, 0
  %or.cond.i92.i = select i1 %cmp.i90.i, i1 true, i1 %cmp2.i91.i
  br i1 %or.cond.i92.i, label %luaZ_fill.exit99.i, label %if.end.i93.i

if.end.i93.i:                                     ; preds = %cond.false67.i
  %sub.i94.i = add i64 %138, -1
  store i64 %sub.i94.i, ptr %132, align 8
  %p.i95.i = getelementptr inbounds %struct.Zio, ptr %132, i64 0, i32 1
  %incdec.ptr.i96.i = getelementptr inbounds i8, ptr %call.i89.i, i64 1
  store ptr %incdec.ptr.i96.i, ptr %p.i95.i, align 8
  %139 = load i8, ptr %call.i89.i, align 1
  %conv.i97.i = zext i8 %139 to i32
  br label %luaZ_fill.exit99.i

luaZ_fill.exit99.i:                               ; preds = %if.end.i93.i, %cond.false67.i
  %retval.0.i98.i = phi i32 [ %conv.i97.i, %if.end.i93.i ], [ -1, %cond.false67.i ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %size.i85.i)
  br label %cond.end70.i

cond.end70.i:                                     ; preds = %luaZ_fill.exit99.i, %cond.true62.i
  %cond71.i = phi i32 [ %conv66.i, %cond.true62.i ], [ %retval.0.i98.i, %luaZ_fill.exit99.i ]
  store i32 %cond71.i, ptr %ls, align 8
  %exitcond.not.i = icmp eq i32 %i.0.i, 2
  br i1 %exitcond.not.i, label %do.end.i, label %land.rhs.i

land.rhs.i:                                       ; preds = %cond.end70.i
  %inc.i = add nuw nsw i32 %i.0.i, 1
  %140 = load ptr, ptr %call36.i, align 8
  %idxprom77.i = sext i32 %cond71.i to i64
  %arrayidx78.i = getelementptr inbounds i16, ptr %140, i64 %idxprom77.i
  %141 = load i16, ptr %arrayidx78.i, align 2
  %142 = and i16 %141, 2048
  %tobool81.not.i = icmp eq i16 %142, 0
  br i1 %tobool81.not.i, label %do.end.i, label %do.body.i, !llvm.loop !106

do.end.i:                                         ; preds = %land.rhs.i, %cond.end70.i
  %cmp82.i = icmp sgt i32 %add.i, 255
  br i1 %cmp82.i, label %if.then84.i, label %if.end.i205

if.then84.i:                                      ; preds = %do.end.i
  call fastcc void @luaX_lexerror(ptr noundef nonnull %ls, ptr noundef nonnull @.str.141, i32 noundef 286)
  unreachable

if.end.i205:                                      ; preds = %do.end.i
  call fastcc void @save(ptr noundef nonnull %ls, i32 noundef %add.i)
  br label %while.condthread-pre-split.i, !llvm.loop !105

sw.epilog.i:                                      ; preds = %sw.bb33.i, %sw.bb32.i, %sw.bb31.i, %sw.bb30.i, %sw.bb29.i, %sw.bb28.i, %cond.end23.i
  %c.1.i = phi i32 [ 11, %sw.bb33.i ], [ 9, %sw.bb32.i ], [ 13, %sw.bb31.i ], [ 10, %sw.bb30.i ], [ 12, %sw.bb29.i ], [ 8, %sw.bb28.i ], [ 7, %cond.end23.i ]
  call fastcc void @save(ptr noundef nonnull %ls, i32 noundef %c.1.i)
  %143 = load ptr, ptr %z269, align 8
  %144 = load i64, ptr %143, align 8
  %dec88.i = add i64 %144, -1
  store i64 %dec88.i, ptr %143, align 8
  %cmp89.not.i = icmp eq i64 %144, 0
  %145 = load ptr, ptr %z269, align 8
  br i1 %cmp89.not.i, label %cond.false96.i, label %cond.true91.i

cond.true91.i:                                    ; preds = %sw.epilog.i
  %p93.i = getelementptr inbounds %struct.Zio, ptr %145, i64 0, i32 1
  %146 = load ptr, ptr %p93.i, align 8
  %incdec.ptr94.i = getelementptr inbounds i8, ptr %146, i64 1
  store ptr %incdec.ptr94.i, ptr %p93.i, align 8
  %147 = load i8, ptr %146, align 1
  %conv95.i = zext i8 %147 to i32
  br label %cond.end99.i

cond.false96.i:                                   ; preds = %sw.epilog.i
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %size.i100.i)
  %L1.i101.i = getelementptr inbounds %struct.Zio, ptr %145, i64 0, i32 4
  %148 = load ptr, ptr %L1.i101.i, align 8
  %reader.i102.i = getelementptr inbounds %struct.Zio, ptr %145, i64 0, i32 2
  %149 = load ptr, ptr %reader.i102.i, align 8
  %data.i103.i = getelementptr inbounds %struct.Zio, ptr %145, i64 0, i32 3
  %150 = load ptr, ptr %data.i103.i, align 8
  %call.i104.i = call ptr %149(ptr noundef %148, ptr noundef %150, ptr noundef nonnull %size.i100.i) #35
  %cmp.i105.i = icmp eq ptr %call.i104.i, null
  %151 = load i64, ptr %size.i100.i, align 8
  %cmp2.i106.i = icmp eq i64 %151, 0
  %or.cond.i107.i = select i1 %cmp.i105.i, i1 true, i1 %cmp2.i106.i
  br i1 %or.cond.i107.i, label %luaZ_fill.exit114.i, label %if.end.i108.i

if.end.i108.i:                                    ; preds = %cond.false96.i
  %sub.i109.i = add i64 %151, -1
  store i64 %sub.i109.i, ptr %145, align 8
  %p.i110.i = getelementptr inbounds %struct.Zio, ptr %145, i64 0, i32 1
  %incdec.ptr.i111.i = getelementptr inbounds i8, ptr %call.i104.i, i64 1
  store ptr %incdec.ptr.i111.i, ptr %p.i110.i, align 8
  %152 = load i8, ptr %call.i104.i, align 1
  %conv.i112.i = zext i8 %152 to i32
  br label %luaZ_fill.exit114.i

luaZ_fill.exit114.i:                              ; preds = %if.end.i108.i, %cond.false96.i
  %retval.0.i113.i = phi i32 [ %conv.i112.i, %if.end.i108.i ], [ -1, %cond.false96.i ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %size.i100.i)
  br label %cond.end99.i

cond.end99.i:                                     ; preds = %luaZ_fill.exit114.i, %cond.true91.i
  %cond100.i = phi i32 [ %conv95.i, %cond.true91.i ], [ %retval.0.i113.i, %luaZ_fill.exit114.i ]
  store i32 %cond100.i, ptr %ls, align 8
  br label %while.cond.backedge.i

while.cond.backedge.i:                            ; preds = %cond.end117.i, %cond.end99.i, %cond.end23.i, %while.condthread-pre-split.i
  %.be.i = phi i32 [ %.pr.i, %while.condthread-pre-split.i ], [ %cond24.i, %cond.end23.i ], [ %cond118.i, %cond.end117.i ], [ %cond100.i, %cond.end99.i ]
  %cmp5.not.i = icmp eq i32 %.be.i, %1
  br i1 %cmp5.not.i, label %while.end.i, label %while.body.i, !llvm.loop !105

sw.default102.i:                                  ; preds = %while.body.i
  call fastcc void @save(ptr noundef nonnull %ls, i32 noundef %105)
  %153 = load ptr, ptr %z269, align 8
  %154 = load i64, ptr %153, align 8
  %dec106.i = add i64 %154, -1
  store i64 %dec106.i, ptr %153, align 8
  %cmp107.not.i = icmp eq i64 %154, 0
  %155 = load ptr, ptr %z269, align 8
  br i1 %cmp107.not.i, label %cond.false114.i, label %cond.true109.i

cond.true109.i:                                   ; preds = %sw.default102.i
  %p111.i = getelementptr inbounds %struct.Zio, ptr %155, i64 0, i32 1
  %156 = load ptr, ptr %p111.i, align 8
  %incdec.ptr112.i = getelementptr inbounds i8, ptr %156, i64 1
  store ptr %incdec.ptr112.i, ptr %p111.i, align 8
  %157 = load i8, ptr %156, align 1
  %conv113.i = zext i8 %157 to i32
  br label %cond.end117.i

cond.false114.i:                                  ; preds = %sw.default102.i
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %size.i115.i)
  %L1.i116.i = getelementptr inbounds %struct.Zio, ptr %155, i64 0, i32 4
  %158 = load ptr, ptr %L1.i116.i, align 8
  %reader.i117.i = getelementptr inbounds %struct.Zio, ptr %155, i64 0, i32 2
  %159 = load ptr, ptr %reader.i117.i, align 8
  %data.i118.i = getelementptr inbounds %struct.Zio, ptr %155, i64 0, i32 3
  %160 = load ptr, ptr %data.i118.i, align 8
  %call.i119.i = call ptr %159(ptr noundef %158, ptr noundef %160, ptr noundef nonnull %size.i115.i) #35
  %cmp.i120.i = icmp eq ptr %call.i119.i, null
  %161 = load i64, ptr %size.i115.i, align 8
  %cmp2.i121.i = icmp eq i64 %161, 0
  %or.cond.i122.i = select i1 %cmp.i120.i, i1 true, i1 %cmp2.i121.i
  br i1 %or.cond.i122.i, label %luaZ_fill.exit129.i, label %if.end.i123.i

if.end.i123.i:                                    ; preds = %cond.false114.i
  %sub.i124.i = add i64 %161, -1
  store i64 %sub.i124.i, ptr %155, align 8
  %p.i125.i = getelementptr inbounds %struct.Zio, ptr %155, i64 0, i32 1
  %incdec.ptr.i126.i = getelementptr inbounds i8, ptr %call.i119.i, i64 1
  store ptr %incdec.ptr.i126.i, ptr %p.i125.i, align 8
  %162 = load i8, ptr %call.i119.i, align 1
  %conv.i127.i = zext i8 %162 to i32
  br label %luaZ_fill.exit129.i

luaZ_fill.exit129.i:                              ; preds = %if.end.i123.i, %cond.false114.i
  %retval.0.i128.i = phi i32 [ %conv.i127.i, %if.end.i123.i ], [ -1, %cond.false114.i ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %size.i115.i)
  br label %cond.end117.i

cond.end117.i:                                    ; preds = %luaZ_fill.exit129.i, %cond.true109.i
  %cond118.i = phi i32 [ %conv113.i, %cond.true109.i ], [ %retval.0.i128.i, %luaZ_fill.exit129.i ]
  store i32 %cond118.i, ptr %ls, align 8
  br label %while.cond.backedge.i

while.end.i:                                      ; preds = %while.cond.backedge.i, %cond.end.i
  call fastcc void @save(ptr noundef nonnull %ls, i32 noundef %1)
  %163 = load ptr, ptr %z269, align 8
  %164 = load i64, ptr %163, align 8
  %dec124.i = add i64 %164, -1
  store i64 %dec124.i, ptr %163, align 8
  %cmp125.not.i = icmp eq i64 %164, 0
  %165 = load ptr, ptr %z269, align 8
  br i1 %cmp125.not.i, label %cond.false132.i, label %cond.true127.i

cond.true127.i:                                   ; preds = %while.end.i
  %p129.i = getelementptr inbounds %struct.Zio, ptr %165, i64 0, i32 1
  %166 = load ptr, ptr %p129.i, align 8
  %incdec.ptr130.i = getelementptr inbounds i8, ptr %166, i64 1
  store ptr %incdec.ptr130.i, ptr %p129.i, align 8
  %167 = load i8, ptr %166, align 1
  %conv131.i = zext i8 %167 to i32
  br label %read_string.exit

cond.false132.i:                                  ; preds = %while.end.i
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %size.i130.i)
  %L1.i131.i = getelementptr inbounds %struct.Zio, ptr %165, i64 0, i32 4
  %168 = load ptr, ptr %L1.i131.i, align 8
  %reader.i132.i = getelementptr inbounds %struct.Zio, ptr %165, i64 0, i32 2
  %169 = load ptr, ptr %reader.i132.i, align 8
  %data.i133.i = getelementptr inbounds %struct.Zio, ptr %165, i64 0, i32 3
  %170 = load ptr, ptr %data.i133.i, align 8
  %call.i134.i = call ptr %169(ptr noundef %168, ptr noundef %170, ptr noundef nonnull %size.i130.i) #35
  %cmp.i135.i = icmp eq ptr %call.i134.i, null
  %171 = load i64, ptr %size.i130.i, align 8
  %cmp2.i136.i = icmp eq i64 %171, 0
  %or.cond.i137.i = select i1 %cmp.i135.i, i1 true, i1 %cmp2.i136.i
  br i1 %or.cond.i137.i, label %luaZ_fill.exit144.i, label %if.end.i138.i

if.end.i138.i:                                    ; preds = %cond.false132.i
  %sub.i139.i = add i64 %171, -1
  store i64 %sub.i139.i, ptr %165, align 8
  %p.i140.i = getelementptr inbounds %struct.Zio, ptr %165, i64 0, i32 1
  %incdec.ptr.i141.i = getelementptr inbounds i8, ptr %call.i134.i, i64 1
  store ptr %incdec.ptr.i141.i, ptr %p.i140.i, align 8
  %172 = load i8, ptr %call.i134.i, align 1
  %conv.i142.i = zext i8 %172 to i32
  br label %luaZ_fill.exit144.i

luaZ_fill.exit144.i:                              ; preds = %if.end.i138.i, %cond.false132.i
  %retval.0.i143.i = phi i32 [ %conv.i142.i, %if.end.i138.i ], [ -1, %cond.false132.i ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %size.i130.i)
  br label %read_string.exit

read_string.exit:                                 ; preds = %cond.true127.i, %luaZ_fill.exit144.i
  %cond136.i = phi i32 [ %conv131.i, %cond.true127.i ], [ %retval.0.i143.i, %luaZ_fill.exit144.i ]
  store i32 %cond136.i, ptr %ls, align 8
  %173 = load ptr, ptr %buff, align 8
  %174 = load ptr, ptr %173, align 8
  %add.ptr.i = getelementptr inbounds i8, ptr %174, i64 1
  %n139.i = getelementptr inbounds %struct.Mbuffer, ptr %173, i64 0, i32 1
  %175 = load i64, ptr %n139.i, align 8
  %sub140.i = add i64 %175, -2
  %call141.i = call fastcc ptr @luaX_newstring(ptr noundef nonnull %ls, ptr noundef nonnull %add.ptr.i, i64 noundef %sub140.i)
  store ptr %call141.i, ptr %seminfo, align 8
  br label %return

sw.bb229:                                         ; preds = %for.cond
  call fastcc void @save(ptr noundef nonnull %ls, i32 noundef 46)
  %176 = load ptr, ptr %z269, align 8
  %177 = load i64, ptr %176, align 8
  %dec233 = add i64 %177, -1
  store i64 %dec233, ptr %176, align 8
  %cmp234.not = icmp eq i64 %177, 0
  %178 = load ptr, ptr %z269, align 8
  br i1 %cmp234.not, label %cond.false241, label %cond.true236

cond.true236:                                     ; preds = %sw.bb229
  %p238 = getelementptr inbounds %struct.Zio, ptr %178, i64 0, i32 1
  %179 = load ptr, ptr %p238, align 8
  %incdec.ptr239 = getelementptr inbounds i8, ptr %179, i64 1
  store ptr %incdec.ptr239, ptr %p238, align 8
  %180 = load i8, ptr %179, align 1
  %conv240 = zext i8 %180 to i32
  br label %cond.end244

cond.false241:                                    ; preds = %sw.bb229
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %size.i206)
  %L1.i207 = getelementptr inbounds %struct.Zio, ptr %178, i64 0, i32 4
  %181 = load ptr, ptr %L1.i207, align 8
  %reader.i208 = getelementptr inbounds %struct.Zio, ptr %178, i64 0, i32 2
  %182 = load ptr, ptr %reader.i208, align 8
  %data.i209 = getelementptr inbounds %struct.Zio, ptr %178, i64 0, i32 3
  %183 = load ptr, ptr %data.i209, align 8
  %call.i210 = call ptr %182(ptr noundef %181, ptr noundef %183, ptr noundef nonnull %size.i206) #35
  %cmp.i211 = icmp eq ptr %call.i210, null
  %184 = load i64, ptr %size.i206, align 8
  %cmp2.i212 = icmp eq i64 %184, 0
  %or.cond.i213 = select i1 %cmp.i211, i1 true, i1 %cmp2.i212
  br i1 %or.cond.i213, label %luaZ_fill.exit220, label %if.end.i214

if.end.i214:                                      ; preds = %cond.false241
  %sub.i215 = add i64 %184, -1
  store i64 %sub.i215, ptr %178, align 8
  %p.i216 = getelementptr inbounds %struct.Zio, ptr %178, i64 0, i32 1
  %incdec.ptr.i217 = getelementptr inbounds i8, ptr %call.i210, i64 1
  store ptr %incdec.ptr.i217, ptr %p.i216, align 8
  %185 = load i8, ptr %call.i210, align 1
  %conv.i218 = zext i8 %185 to i32
  br label %luaZ_fill.exit220

luaZ_fill.exit220:                                ; preds = %cond.false241, %if.end.i214
  %retval.0.i219 = phi i32 [ %conv.i218, %if.end.i214 ], [ -1, %cond.false241 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %size.i206)
  br label %cond.end244

cond.end244:                                      ; preds = %luaZ_fill.exit220, %cond.true236
  %186 = phi i32 [ %conv240, %cond.true236 ], [ %retval.0.i219, %luaZ_fill.exit220 ]
  store i32 %186, ptr %ls, align 8
  %187 = trunc i32 %186 to i8
  switch i8 %187, label %if.else253 [
    i8 46, label %if.end.i224
    i8 0, label %if.end.i224
  ]

if.end.i224:                                      ; preds = %cond.end244, %cond.end244
  call fastcc void @save(ptr noundef nonnull %ls, i32 noundef %186)
  %188 = load ptr, ptr %z269, align 8
  %189 = load i64, ptr %188, align 8
  %dec.i226 = add i64 %189, -1
  store i64 %dec.i226, ptr %188, align 8
  %cmp.not.i227 = icmp eq i64 %189, 0
  %190 = load ptr, ptr %z269, align 8
  br i1 %cmp.not.i227, label %cond.false.i235, label %cond.true.i228

cond.true.i228:                                   ; preds = %if.end.i224
  %p.i229 = getelementptr inbounds %struct.Zio, ptr %190, i64 0, i32 1
  %191 = load ptr, ptr %p.i229, align 8
  %incdec.ptr.i230 = getelementptr inbounds i8, ptr %191, i64 1
  store ptr %incdec.ptr.i230, ptr %p.i229, align 8
  %192 = load i8, ptr %191, align 1
  %conv.i231 = zext i8 %192 to i32
  br label %if.then248

cond.false.i235:                                  ; preds = %if.end.i224
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %size.i.i221)
  %L1.i.i236 = getelementptr inbounds %struct.Zio, ptr %190, i64 0, i32 4
  %193 = load ptr, ptr %L1.i.i236, align 8
  %reader.i.i237 = getelementptr inbounds %struct.Zio, ptr %190, i64 0, i32 2
  %194 = load ptr, ptr %reader.i.i237, align 8
  %data.i.i238 = getelementptr inbounds %struct.Zio, ptr %190, i64 0, i32 3
  %195 = load ptr, ptr %data.i.i238, align 8
  %call.i.i239 = call ptr %194(ptr noundef %193, ptr noundef %195, ptr noundef nonnull %size.i.i221) #35
  %cmp.i.i240 = icmp eq ptr %call.i.i239, null
  %196 = load i64, ptr %size.i.i221, align 8
  %cmp2.i.i241 = icmp eq i64 %196, 0
  %or.cond.i.i242 = select i1 %cmp.i.i240, i1 true, i1 %cmp2.i.i241
  br i1 %or.cond.i.i242, label %luaZ_fill.exit.i248, label %if.end.i.i243

if.end.i.i243:                                    ; preds = %cond.false.i235
  %sub.i.i244 = add i64 %196, -1
  store i64 %sub.i.i244, ptr %190, align 8
  %p.i.i245 = getelementptr inbounds %struct.Zio, ptr %190, i64 0, i32 1
  %incdec.ptr.i.i246 = getelementptr inbounds i8, ptr %call.i.i239, i64 1
  store ptr %incdec.ptr.i.i246, ptr %p.i.i245, align 8
  %197 = load i8, ptr %call.i.i239, align 1
  %conv.i.i247 = zext i8 %197 to i32
  br label %luaZ_fill.exit.i248

luaZ_fill.exit.i248:                              ; preds = %if.end.i.i243, %cond.false.i235
  %retval.0.i.i249 = phi i32 [ %conv.i.i247, %if.end.i.i243 ], [ -1, %cond.false.i235 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %size.i.i221)
  br label %if.then248

if.then248:                                       ; preds = %luaZ_fill.exit.i248, %cond.true.i228
  %cond.i233 = phi i32 [ %conv.i231, %cond.true.i228 ], [ %retval.0.i.i249, %luaZ_fill.exit.i248 ]
  store i32 %cond.i233, ptr %ls, align 8
  %198 = trunc i32 %cond.i233 to i8
  switch i8 %198, label %return [
    i8 46, label %if.end.i253
    i8 0, label %if.end.i253
  ]

if.end.i253:                                      ; preds = %if.then248, %if.then248
  call fastcc void @save(ptr noundef nonnull %ls, i32 noundef %cond.i233)
  %199 = load ptr, ptr %z269, align 8
  %200 = load i64, ptr %199, align 8
  %dec.i255 = add i64 %200, -1
  store i64 %dec.i255, ptr %199, align 8
  %cmp.not.i256 = icmp eq i64 %200, 0
  %201 = load ptr, ptr %z269, align 8
  br i1 %cmp.not.i256, label %cond.false.i264, label %cond.true.i257

cond.true.i257:                                   ; preds = %if.end.i253
  %p.i258 = getelementptr inbounds %struct.Zio, ptr %201, i64 0, i32 1
  %202 = load ptr, ptr %p.i258, align 8
  %incdec.ptr.i259 = getelementptr inbounds i8, ptr %202, i64 1
  store ptr %incdec.ptr.i259, ptr %p.i258, align 8
  %203 = load i8, ptr %202, align 1
  %conv.i260 = zext i8 %203 to i32
  br label %check_next.exit279

cond.false.i264:                                  ; preds = %if.end.i253
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %size.i.i250)
  %L1.i.i265 = getelementptr inbounds %struct.Zio, ptr %201, i64 0, i32 4
  %204 = load ptr, ptr %L1.i.i265, align 8
  %reader.i.i266 = getelementptr inbounds %struct.Zio, ptr %201, i64 0, i32 2
  %205 = load ptr, ptr %reader.i.i266, align 8
  %data.i.i267 = getelementptr inbounds %struct.Zio, ptr %201, i64 0, i32 3
  %206 = load ptr, ptr %data.i.i267, align 8
  %call.i.i268 = call ptr %205(ptr noundef %204, ptr noundef %206, ptr noundef nonnull %size.i.i250) #35
  %cmp.i.i269 = icmp eq ptr %call.i.i268, null
  %207 = load i64, ptr %size.i.i250, align 8
  %cmp2.i.i270 = icmp eq i64 %207, 0
  %or.cond.i.i271 = select i1 %cmp.i.i269, i1 true, i1 %cmp2.i.i270
  br i1 %or.cond.i.i271, label %luaZ_fill.exit.i277, label %if.end.i.i272

if.end.i.i272:                                    ; preds = %cond.false.i264
  %sub.i.i273 = add i64 %207, -1
  store i64 %sub.i.i273, ptr %201, align 8
  %p.i.i274 = getelementptr inbounds %struct.Zio, ptr %201, i64 0, i32 1
  %incdec.ptr.i.i275 = getelementptr inbounds i8, ptr %call.i.i268, i64 1
  store ptr %incdec.ptr.i.i275, ptr %p.i.i274, align 8
  %208 = load i8, ptr %call.i.i268, align 1
  %conv.i.i276 = zext i8 %208 to i32
  br label %luaZ_fill.exit.i277

luaZ_fill.exit.i277:                              ; preds = %if.end.i.i272, %cond.false.i264
  %retval.0.i.i278 = phi i32 [ %conv.i.i276, %if.end.i.i272 ], [ -1, %cond.false.i264 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %size.i.i250)
  br label %check_next.exit279

check_next.exit279:                               ; preds = %cond.true.i257, %luaZ_fill.exit.i277
  %cond.i262 = phi i32 [ %conv.i260, %cond.true.i257 ], [ %retval.0.i.i278, %luaZ_fill.exit.i277 ]
  store i32 %cond.i262, ptr %ls, align 8
  br label %return

if.else253:                                       ; preds = %cond.end244
  %call254 = tail call ptr @__ctype_b_loc() #39
  %209 = load ptr, ptr %call254, align 8
  %idxprom = sext i32 %186 to i64
  %arrayidx = getelementptr inbounds i16, ptr %209, i64 %idxprom
  %210 = load i16, ptr %arrayidx, align 2
  %211 = and i16 %210, 2048
  %tobool257.not = icmp eq i16 %211, 0
  br i1 %tobool257.not, label %return, label %if.else259

if.else259:                                       ; preds = %if.else253
  call fastcc void @read_numeral(ptr noundef nonnull %ls, ptr noundef %seminfo)
  br label %return

sw.default:                                       ; preds = %for.cond
  %call261 = tail call ptr @__ctype_b_loc() #39
  %212 = load ptr, ptr %call261, align 8
  %idxprom263 = sext i32 %1 to i64
  %arrayidx264 = getelementptr inbounds i16, ptr %212, i64 %idxprom263
  %213 = load i16, ptr %arrayidx264, align 2
  %conv265 = zext i16 %213 to i32
  %and266 = and i32 %conv265, 8192
  %tobool267.not = icmp eq i32 %and266, 0
  br i1 %tobool267.not, label %if.else285, label %if.then268

if.then268:                                       ; preds = %sw.default
  %214 = load ptr, ptr %z269, align 8
  %215 = load i64, ptr %214, align 8
  %dec271 = add i64 %215, -1
  store i64 %dec271, ptr %214, align 8
  %cmp272.not = icmp eq i64 %215, 0
  %216 = load ptr, ptr %z269, align 8
  br i1 %cmp272.not, label %cond.false279, label %cond.true274

cond.true274:                                     ; preds = %if.then268
  %p276 = getelementptr inbounds %struct.Zio, ptr %216, i64 0, i32 1
  %217 = load ptr, ptr %p276, align 8
  %incdec.ptr277 = getelementptr inbounds i8, ptr %217, i64 1
  store ptr %incdec.ptr277, ptr %p276, align 8
  %218 = load i8, ptr %217, align 1
  %conv278 = zext i8 %218 to i32
  br label %cond.end282

cond.false279:                                    ; preds = %if.then268
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %size.i280)
  %L1.i281 = getelementptr inbounds %struct.Zio, ptr %216, i64 0, i32 4
  %219 = load ptr, ptr %L1.i281, align 8
  %reader.i282 = getelementptr inbounds %struct.Zio, ptr %216, i64 0, i32 2
  %220 = load ptr, ptr %reader.i282, align 8
  %data.i283 = getelementptr inbounds %struct.Zio, ptr %216, i64 0, i32 3
  %221 = load ptr, ptr %data.i283, align 8
  %call.i284 = call ptr %220(ptr noundef %219, ptr noundef %221, ptr noundef nonnull %size.i280) #35
  %cmp.i285 = icmp eq ptr %call.i284, null
  %222 = load i64, ptr %size.i280, align 8
  %cmp2.i286 = icmp eq i64 %222, 0
  %or.cond.i287 = select i1 %cmp.i285, i1 true, i1 %cmp2.i286
  br i1 %or.cond.i287, label %luaZ_fill.exit294, label %if.end.i288

if.end.i288:                                      ; preds = %cond.false279
  %sub.i289 = add i64 %222, -1
  store i64 %sub.i289, ptr %216, align 8
  %p.i290 = getelementptr inbounds %struct.Zio, ptr %216, i64 0, i32 1
  %incdec.ptr.i291 = getelementptr inbounds i8, ptr %call.i284, i64 1
  store ptr %incdec.ptr.i291, ptr %p.i290, align 8
  %223 = load i8, ptr %call.i284, align 1
  %conv.i292 = zext i8 %223 to i32
  br label %luaZ_fill.exit294

luaZ_fill.exit294:                                ; preds = %cond.false279, %if.end.i288
  %retval.0.i293 = phi i32 [ %conv.i292, %if.end.i288 ], [ -1, %cond.false279 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %size.i280)
  br label %cond.end282

cond.end282:                                      ; preds = %luaZ_fill.exit294, %cond.true274
  %cond283 = phi i32 [ %conv278, %cond.true274 ], [ %retval.0.i293, %luaZ_fill.exit294 ]
  store i32 %cond283, ptr %ls, align 8
  br label %for.cond

if.else285:                                       ; preds = %sw.default
  %and291 = and i32 %conv265, 2048
  %tobool292.not = icmp eq i32 %and291, 0
  br i1 %tobool292.not, label %if.else294, label %if.then293

if.then293:                                       ; preds = %if.else285
  call fastcc void @read_numeral(ptr noundef nonnull %ls, ptr noundef %seminfo)
  br label %return

if.else294:                                       ; preds = %if.else285
  %and300 = and i32 %conv265, 1024
  %tobool301.not = icmp ne i32 %and300, 0
  %cmp304 = icmp eq i32 %1, 95
  %or.cond = or i1 %cmp304, %tobool301.not
  br i1 %or.cond, label %do.body, label %if.else345

do.body:                                          ; preds = %if.else294, %cond.end321
  %224 = phi i32 [ %cond322, %cond.end321 ], [ %1, %if.else294 ]
  call fastcc void @save(ptr noundef nonnull %ls, i32 noundef %224)
  %225 = load ptr, ptr %z269, align 8
  %226 = load i64, ptr %225, align 8
  %dec310 = add i64 %226, -1
  store i64 %dec310, ptr %225, align 8
  %cmp311.not = icmp eq i64 %226, 0
  %227 = load ptr, ptr %z269, align 8
  br i1 %cmp311.not, label %cond.false318, label %cond.true313

cond.true313:                                     ; preds = %do.body
  %p315 = getelementptr inbounds %struct.Zio, ptr %227, i64 0, i32 1
  %228 = load ptr, ptr %p315, align 8
  %incdec.ptr316 = getelementptr inbounds i8, ptr %228, i64 1
  store ptr %incdec.ptr316, ptr %p315, align 8
  %229 = load i8, ptr %228, align 1
  %conv317 = zext i8 %229 to i32
  br label %cond.end321

cond.false318:                                    ; preds = %do.body
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %size.i295)
  %L1.i296 = getelementptr inbounds %struct.Zio, ptr %227, i64 0, i32 4
  %230 = load ptr, ptr %L1.i296, align 8
  %reader.i297 = getelementptr inbounds %struct.Zio, ptr %227, i64 0, i32 2
  %231 = load ptr, ptr %reader.i297, align 8
  %data.i298 = getelementptr inbounds %struct.Zio, ptr %227, i64 0, i32 3
  %232 = load ptr, ptr %data.i298, align 8
  %call.i299 = call ptr %231(ptr noundef %230, ptr noundef %232, ptr noundef nonnull %size.i295) #35
  %cmp.i300 = icmp eq ptr %call.i299, null
  %233 = load i64, ptr %size.i295, align 8
  %cmp2.i301 = icmp eq i64 %233, 0
  %or.cond.i302 = select i1 %cmp.i300, i1 true, i1 %cmp2.i301
  br i1 %or.cond.i302, label %luaZ_fill.exit309, label %if.end.i303

if.end.i303:                                      ; preds = %cond.false318
  %sub.i304 = add i64 %233, -1
  store i64 %sub.i304, ptr %227, align 8
  %p.i305 = getelementptr inbounds %struct.Zio, ptr %227, i64 0, i32 1
  %incdec.ptr.i306 = getelementptr inbounds i8, ptr %call.i299, i64 1
  store ptr %incdec.ptr.i306, ptr %p.i305, align 8
  %234 = load i8, ptr %call.i299, align 1
  %conv.i307 = zext i8 %234 to i32
  br label %luaZ_fill.exit309

luaZ_fill.exit309:                                ; preds = %cond.false318, %if.end.i303
  %retval.0.i308 = phi i32 [ %conv.i307, %if.end.i303 ], [ -1, %cond.false318 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %size.i295)
  br label %cond.end321

cond.end321:                                      ; preds = %luaZ_fill.exit309, %cond.true313
  %cond322 = phi i32 [ %conv317, %cond.true313 ], [ %retval.0.i308, %luaZ_fill.exit309 ]
  store i32 %cond322, ptr %ls, align 8
  %235 = load ptr, ptr %call261, align 8
  %idxprom326 = sext i32 %cond322 to i64
  %arrayidx327 = getelementptr inbounds i16, ptr %235, i64 %idxprom326
  %236 = load i16, ptr %arrayidx327, align 2
  %237 = and i16 %236, 8
  %tobool330.not = icmp ne i16 %237, 0
  %cmp332 = icmp eq i32 %cond322, 95
  %or.cond110 = or i1 %cmp332, %tobool330.not
  br i1 %or.cond110, label %do.body, label %do.end, !llvm.loop !107

do.end:                                           ; preds = %cond.end321
  %238 = load ptr, ptr %buff, align 8
  %239 = load ptr, ptr %238, align 8
  %n336 = getelementptr inbounds %struct.Mbuffer, ptr %238, i64 0, i32 1
  %240 = load i64, ptr %n336, align 8
  %call337 = call fastcc ptr @luaX_newstring(ptr noundef nonnull %ls, ptr noundef %239, i64 noundef %240)
  %reserved = getelementptr inbounds %struct.anon.0, ptr %call337, i64 0, i32 3
  %241 = load i8, ptr %reserved, align 2
  %cmp339.not = icmp eq i8 %241, 0
  br i1 %cmp339.not, label %if.else344, label %if.then341

if.then341:                                       ; preds = %do.end
  %conv338 = zext i8 %241 to i32
  %add = or disjoint i32 %conv338, 256
  br label %return

if.else344:                                       ; preds = %do.end
  store ptr %call337, ptr %seminfo, align 8
  br label %return

if.else345:                                       ; preds = %if.else294
  %242 = load ptr, ptr %z269, align 8
  %243 = load i64, ptr %242, align 8
  %dec349 = add i64 %243, -1
  store i64 %dec349, ptr %242, align 8
  %cmp350.not = icmp eq i64 %243, 0
  %244 = load ptr, ptr %z269, align 8
  br i1 %cmp350.not, label %cond.false357, label %cond.true352

cond.true352:                                     ; preds = %if.else345
  %p354 = getelementptr inbounds %struct.Zio, ptr %244, i64 0, i32 1
  %245 = load ptr, ptr %p354, align 8
  %incdec.ptr355 = getelementptr inbounds i8, ptr %245, i64 1
  store ptr %incdec.ptr355, ptr %p354, align 8
  %246 = load i8, ptr %245, align 1
  %conv356 = zext i8 %246 to i32
  br label %cond.end360

cond.false357:                                    ; preds = %if.else345
  %call359 = call fastcc i32 @luaZ_fill(ptr noundef %244), !range !104
  br label %cond.end360

cond.end360:                                      ; preds = %cond.false357, %cond.true352
  %cond361 = phi i32 [ %conv356, %cond.true352 ], [ %call359, %cond.false357 ]
  store i32 %cond361, ptr %ls, align 8
  br label %return

return:                                           ; preds = %cond.end, %for.cond, %if.then248, %check_next.exit279, %if.else253, %cond.end203, %cond.end165, %cond.end127, %cond.end89, %if.else, %cond.end360, %if.else344, %if.then341, %if.then293, %if.else259, %read_string.exit, %cond.end224, %cond.end186, %cond.end148, %cond.end110, %if.then69
  %retval.0 = phi i32 [ 284, %if.then293 ], [ %add, %if.then341 ], [ 285, %if.else344 ], [ %1, %cond.end360 ], [ 284, %if.else259 ], [ 286, %read_string.exit ], [ 283, %cond.end224 ], [ 281, %cond.end186 ], [ 282, %cond.end148 ], [ 280, %cond.end110 ], [ 286, %if.then69 ], [ 91, %if.else ], [ 61, %cond.end89 ], [ 60, %cond.end127 ], [ 62, %cond.end165 ], [ 126, %cond.end203 ], [ 46, %if.else253 ], [ 279, %check_next.exit279 ], [ 278, %if.then248 ], [ 287, %for.cond ], [ 45, %cond.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal fastcc void @inclinenumber(ptr nocapture noundef %ls) unnamed_addr #0 {
entry:
  %size.i14 = alloca i64, align 8
  %size.i = alloca i64, align 8
  %0 = load i32, ptr %ls, align 8
  %z = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 7
  %1 = load ptr, ptr %z, align 8
  %2 = load i64, ptr %1, align 8
  %dec = add i64 %2, -1
  store i64 %dec, ptr %1, align 8
  %cmp.not = icmp eq i64 %2, 0
  %3 = load ptr, ptr %z, align 8
  br i1 %cmp.not, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %p = getelementptr inbounds %struct.Zio, ptr %3, i64 0, i32 1
  %4 = load ptr, ptr %p, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %4, i64 1
  store ptr %incdec.ptr, ptr %p, align 8
  %5 = load i8, ptr %4, align 1
  %conv = zext i8 %5 to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %size.i)
  %L1.i = getelementptr inbounds %struct.Zio, ptr %3, i64 0, i32 4
  %6 = load ptr, ptr %L1.i, align 8
  %reader.i = getelementptr inbounds %struct.Zio, ptr %3, i64 0, i32 2
  %7 = load ptr, ptr %reader.i, align 8
  %data.i = getelementptr inbounds %struct.Zio, ptr %3, i64 0, i32 3
  %8 = load ptr, ptr %data.i, align 8
  %call.i = call ptr %7(ptr noundef %6, ptr noundef %8, ptr noundef nonnull %size.i) #35
  %cmp.i = icmp eq ptr %call.i, null
  %9 = load i64, ptr %size.i, align 8
  %cmp2.i = icmp eq i64 %9, 0
  %or.cond.i = select i1 %cmp.i, i1 true, i1 %cmp2.i
  br i1 %or.cond.i, label %luaZ_fill.exit, label %if.end.i

if.end.i:                                         ; preds = %cond.false
  %sub.i = add i64 %9, -1
  store i64 %sub.i, ptr %3, align 8
  %p.i = getelementptr inbounds %struct.Zio, ptr %3, i64 0, i32 1
  %incdec.ptr.i = getelementptr inbounds i8, ptr %call.i, i64 1
  store ptr %incdec.ptr.i, ptr %p.i, align 8
  %10 = load i8, ptr %call.i, align 1
  %conv.i = zext i8 %10 to i32
  br label %luaZ_fill.exit

luaZ_fill.exit:                                   ; preds = %cond.false, %if.end.i
  %retval.0.i = phi i32 [ %conv.i, %if.end.i ], [ -1, %cond.false ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %size.i)
  br label %cond.end

cond.end:                                         ; preds = %luaZ_fill.exit, %cond.true
  %cond = phi i32 [ %conv, %cond.true ], [ %retval.0.i, %luaZ_fill.exit ]
  store i32 %cond, ptr %ls, align 8
  switch i32 %cond, label %if.end [
    i32 10, label %land.lhs.true
    i32 13, label %land.lhs.true
  ]

land.lhs.true:                                    ; preds = %cond.end, %cond.end
  %cmp11.not = icmp eq i32 %cond, %0
  br i1 %cmp11.not, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %11 = load ptr, ptr %z, align 8
  %12 = load i64, ptr %11, align 8
  %dec15 = add i64 %12, -1
  store i64 %dec15, ptr %11, align 8
  %cmp16.not = icmp eq i64 %12, 0
  %13 = load ptr, ptr %z, align 8
  br i1 %cmp16.not, label %cond.false23, label %cond.true18

cond.true18:                                      ; preds = %if.then
  %p20 = getelementptr inbounds %struct.Zio, ptr %13, i64 0, i32 1
  %14 = load ptr, ptr %p20, align 8
  %incdec.ptr21 = getelementptr inbounds i8, ptr %14, i64 1
  store ptr %incdec.ptr21, ptr %p20, align 8
  %15 = load i8, ptr %14, align 1
  %conv22 = zext i8 %15 to i32
  br label %cond.end26

cond.false23:                                     ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %size.i14)
  %L1.i15 = getelementptr inbounds %struct.Zio, ptr %13, i64 0, i32 4
  %16 = load ptr, ptr %L1.i15, align 8
  %reader.i16 = getelementptr inbounds %struct.Zio, ptr %13, i64 0, i32 2
  %17 = load ptr, ptr %reader.i16, align 8
  %data.i17 = getelementptr inbounds %struct.Zio, ptr %13, i64 0, i32 3
  %18 = load ptr, ptr %data.i17, align 8
  %call.i18 = call ptr %17(ptr noundef %16, ptr noundef %18, ptr noundef nonnull %size.i14) #35
  %cmp.i19 = icmp eq ptr %call.i18, null
  %19 = load i64, ptr %size.i14, align 8
  %cmp2.i20 = icmp eq i64 %19, 0
  %or.cond.i21 = select i1 %cmp.i19, i1 true, i1 %cmp2.i20
  br i1 %or.cond.i21, label %luaZ_fill.exit28, label %if.end.i22

if.end.i22:                                       ; preds = %cond.false23
  %sub.i23 = add i64 %19, -1
  store i64 %sub.i23, ptr %13, align 8
  %p.i24 = getelementptr inbounds %struct.Zio, ptr %13, i64 0, i32 1
  %incdec.ptr.i25 = getelementptr inbounds i8, ptr %call.i18, i64 1
  store ptr %incdec.ptr.i25, ptr %p.i24, align 8
  %20 = load i8, ptr %call.i18, align 1
  %conv.i26 = zext i8 %20 to i32
  br label %luaZ_fill.exit28

luaZ_fill.exit28:                                 ; preds = %cond.false23, %if.end.i22
  %retval.0.i27 = phi i32 [ %conv.i26, %if.end.i22 ], [ -1, %cond.false23 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %size.i14)
  br label %cond.end26

cond.end26:                                       ; preds = %luaZ_fill.exit28, %cond.true18
  %cond27 = phi i32 [ %conv22, %cond.true18 ], [ %retval.0.i27, %luaZ_fill.exit28 ]
  store i32 %cond27, ptr %ls, align 8
  br label %if.end

if.end:                                           ; preds = %cond.end, %cond.end26, %land.lhs.true
  %linenumber = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 1
  %21 = load i32, ptr %linenumber, align 4
  %inc = add nsw i32 %21, 1
  store i32 %inc, ptr %linenumber, align 4
  %cmp29 = icmp sgt i32 %21, 2147483643
  br i1 %cmp29, label %if.then31, label %if.end32

if.then31:                                        ; preds = %if.end
  %t.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 3
  %22 = load i32, ptr %t.i, align 8
  call fastcc void @luaX_lexerror(ptr noundef nonnull %ls, ptr noundef nonnull @.str.134, i32 noundef %22)
  unreachable

if.end32:                                         ; preds = %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @skip_sep(ptr nocapture noundef %ls) unnamed_addr #0 {
entry:
  %size.i17 = alloca i64, align 8
  %size.i = alloca i64, align 8
  %0 = load i32, ptr %ls, align 8
  tail call fastcc void @save(ptr noundef nonnull %ls, i32 noundef %0)
  %z = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 7
  %1 = load ptr, ptr %z, align 8
  %2 = load i64, ptr %1, align 8
  %dec = add i64 %2, -1
  store i64 %dec, ptr %1, align 8
  %cmp.not = icmp eq i64 %2, 0
  %3 = load ptr, ptr %z, align 8
  br i1 %cmp.not, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %p = getelementptr inbounds %struct.Zio, ptr %3, i64 0, i32 1
  %4 = load ptr, ptr %p, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %4, i64 1
  store ptr %incdec.ptr, ptr %p, align 8
  %5 = load i8, ptr %4, align 1
  %conv = zext i8 %5 to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %size.i)
  %L1.i = getelementptr inbounds %struct.Zio, ptr %3, i64 0, i32 4
  %6 = load ptr, ptr %L1.i, align 8
  %reader.i = getelementptr inbounds %struct.Zio, ptr %3, i64 0, i32 2
  %7 = load ptr, ptr %reader.i, align 8
  %data.i = getelementptr inbounds %struct.Zio, ptr %3, i64 0, i32 3
  %8 = load ptr, ptr %data.i, align 8
  %call.i = call ptr %7(ptr noundef %6, ptr noundef %8, ptr noundef nonnull %size.i) #35
  %cmp.i = icmp eq ptr %call.i, null
  %9 = load i64, ptr %size.i, align 8
  %cmp2.i = icmp eq i64 %9, 0
  %or.cond.i = select i1 %cmp.i, i1 true, i1 %cmp2.i
  br i1 %or.cond.i, label %luaZ_fill.exit, label %if.end.i

if.end.i:                                         ; preds = %cond.false
  %sub.i = add i64 %9, -1
  store i64 %sub.i, ptr %3, align 8
  %p.i = getelementptr inbounds %struct.Zio, ptr %3, i64 0, i32 1
  %incdec.ptr.i = getelementptr inbounds i8, ptr %call.i, i64 1
  store ptr %incdec.ptr.i, ptr %p.i, align 8
  %10 = load i8, ptr %call.i, align 1
  %conv.i = zext i8 %10 to i32
  br label %luaZ_fill.exit

luaZ_fill.exit:                                   ; preds = %cond.false, %if.end.i
  %retval.0.i = phi i32 [ %conv.i, %if.end.i ], [ -1, %cond.false ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %size.i)
  br label %cond.end

cond.end:                                         ; preds = %luaZ_fill.exit, %cond.true
  %cond = phi i32 [ %conv, %cond.true ], [ %retval.0.i, %luaZ_fill.exit ]
  store i32 %cond, ptr %ls, align 8
  %cmp632 = icmp eq i32 %cond, 61
  br i1 %cmp632, label %while.body, label %while.end

while.body:                                       ; preds = %cond.end, %cond.end22
  %count.033 = phi i32 [ %inc, %cond.end22 ], [ 0, %cond.end ]
  call fastcc void @save(ptr noundef nonnull %ls, i32 noundef 61)
  %11 = load ptr, ptr %z, align 8
  %12 = load i64, ptr %11, align 8
  %dec11 = add i64 %12, -1
  store i64 %dec11, ptr %11, align 8
  %cmp12.not = icmp eq i64 %12, 0
  %13 = load ptr, ptr %z, align 8
  br i1 %cmp12.not, label %cond.false19, label %cond.true14

cond.true14:                                      ; preds = %while.body
  %p16 = getelementptr inbounds %struct.Zio, ptr %13, i64 0, i32 1
  %14 = load ptr, ptr %p16, align 8
  %incdec.ptr17 = getelementptr inbounds i8, ptr %14, i64 1
  store ptr %incdec.ptr17, ptr %p16, align 8
  %15 = load i8, ptr %14, align 1
  %conv18 = zext i8 %15 to i32
  br label %cond.end22

cond.false19:                                     ; preds = %while.body
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %size.i17)
  %L1.i18 = getelementptr inbounds %struct.Zio, ptr %13, i64 0, i32 4
  %16 = load ptr, ptr %L1.i18, align 8
  %reader.i19 = getelementptr inbounds %struct.Zio, ptr %13, i64 0, i32 2
  %17 = load ptr, ptr %reader.i19, align 8
  %data.i20 = getelementptr inbounds %struct.Zio, ptr %13, i64 0, i32 3
  %18 = load ptr, ptr %data.i20, align 8
  %call.i21 = call ptr %17(ptr noundef %16, ptr noundef %18, ptr noundef nonnull %size.i17) #35
  %cmp.i22 = icmp eq ptr %call.i21, null
  %19 = load i64, ptr %size.i17, align 8
  %cmp2.i23 = icmp eq i64 %19, 0
  %or.cond.i24 = select i1 %cmp.i22, i1 true, i1 %cmp2.i23
  br i1 %or.cond.i24, label %luaZ_fill.exit31, label %if.end.i25

if.end.i25:                                       ; preds = %cond.false19
  %sub.i26 = add i64 %19, -1
  store i64 %sub.i26, ptr %13, align 8
  %p.i27 = getelementptr inbounds %struct.Zio, ptr %13, i64 0, i32 1
  %incdec.ptr.i28 = getelementptr inbounds i8, ptr %call.i21, i64 1
  store ptr %incdec.ptr.i28, ptr %p.i27, align 8
  %20 = load i8, ptr %call.i21, align 1
  %conv.i29 = zext i8 %20 to i32
  br label %luaZ_fill.exit31

luaZ_fill.exit31:                                 ; preds = %cond.false19, %if.end.i25
  %retval.0.i30 = phi i32 [ %conv.i29, %if.end.i25 ], [ -1, %cond.false19 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %size.i17)
  br label %cond.end22

cond.end22:                                       ; preds = %luaZ_fill.exit31, %cond.true14
  %cond23 = phi i32 [ %conv18, %cond.true14 ], [ %retval.0.i30, %luaZ_fill.exit31 ]
  store i32 %cond23, ptr %ls, align 8
  %inc = add nuw nsw i32 %count.033, 1
  %cmp6 = icmp eq i32 %cond23, 61
  br i1 %cmp6, label %while.body, label %while.end, !llvm.loop !108

while.end:                                        ; preds = %cond.end22, %cond.end
  %.lcssa = phi i32 [ %cond, %cond.end ], [ %cond23, %cond.end22 ]
  %count.0.lcssa = phi i32 [ 0, %cond.end ], [ %inc, %cond.end22 ]
  %cmp26 = icmp ne i32 %.lcssa, %0
  %sub30 = sext i1 %cmp26 to i32
  %cond32 = xor i32 %count.0.lcssa, %sub30
  ret i32 %cond32
}

; Function Attrs: nounwind uwtable
define internal fastcc void @read_long_string(ptr nocapture noundef %ls, ptr noundef writeonly %seminfo, i32 noundef %sep) unnamed_addr #0 {
entry:
  %size.i81 = alloca i64, align 8
  %size.i66 = alloca i64, align 8
  %size.i14.i = alloca i64, align 8
  %size.i.i = alloca i64, align 8
  %size.i40 = alloca i64, align 8
  %size.i = alloca i64, align 8
  %0 = load i32, ptr %ls, align 8
  tail call fastcc void @save(ptr noundef nonnull %ls, i32 noundef %0)
  %z = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 7
  %1 = load ptr, ptr %z, align 8
  %2 = load i64, ptr %1, align 8
  %dec = add i64 %2, -1
  store i64 %dec, ptr %1, align 8
  %cmp.not = icmp eq i64 %2, 0
  %3 = load ptr, ptr %z, align 8
  br i1 %cmp.not, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %p = getelementptr inbounds %struct.Zio, ptr %3, i64 0, i32 1
  %4 = load ptr, ptr %p, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %4, i64 1
  store ptr %incdec.ptr, ptr %p, align 8
  %5 = load i8, ptr %4, align 1
  %conv = zext i8 %5 to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %size.i)
  %L1.i = getelementptr inbounds %struct.Zio, ptr %3, i64 0, i32 4
  %6 = load ptr, ptr %L1.i, align 8
  %reader.i = getelementptr inbounds %struct.Zio, ptr %3, i64 0, i32 2
  %7 = load ptr, ptr %reader.i, align 8
  %data.i = getelementptr inbounds %struct.Zio, ptr %3, i64 0, i32 3
  %8 = load ptr, ptr %data.i, align 8
  %call.i = call ptr %7(ptr noundef %6, ptr noundef %8, ptr noundef nonnull %size.i) #35
  %cmp.i = icmp eq ptr %call.i, null
  %9 = load i64, ptr %size.i, align 8
  %cmp2.i = icmp eq i64 %9, 0
  %or.cond.i = select i1 %cmp.i, i1 true, i1 %cmp2.i
  br i1 %or.cond.i, label %luaZ_fill.exit, label %if.end.i

if.end.i:                                         ; preds = %cond.false
  %sub.i = add i64 %9, -1
  store i64 %sub.i, ptr %3, align 8
  %p.i = getelementptr inbounds %struct.Zio, ptr %3, i64 0, i32 1
  %incdec.ptr.i = getelementptr inbounds i8, ptr %call.i, i64 1
  store ptr %incdec.ptr.i, ptr %p.i, align 8
  %10 = load i8, ptr %call.i, align 1
  %conv.i = zext i8 %10 to i32
  br label %luaZ_fill.exit

luaZ_fill.exit:                                   ; preds = %cond.false, %if.end.i
  %retval.0.i = phi i32 [ %conv.i, %if.end.i ], [ -1, %cond.false ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %size.i)
  br label %cond.end

cond.end:                                         ; preds = %luaZ_fill.exit, %cond.true
  %cond = phi i32 [ %conv, %cond.true ], [ %retval.0.i, %luaZ_fill.exit ]
  store i32 %cond, ptr %ls, align 8
  switch i32 %cond, label %if.end [
    i32 10, label %if.then
    i32 13, label %if.then
  ]

if.then:                                          ; preds = %cond.end, %cond.end
  call fastcc void @inclinenumber(ptr noundef nonnull %ls)
  br label %if.end

if.end:                                           ; preds = %cond.end, %if.then
  %buff.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 8
  %L.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 6
  %linenumber.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 1
  %tobool36.not = icmp eq ptr %seminfo, null
  br label %for.cond

for.cond:                                         ; preds = %for.cond.backedge, %if.end
  %11 = load i32, ptr %ls, align 8
  switch i32 %11, label %sw.default [
    i32 -1, label %sw.bb
    i32 93, label %sw.bb12
    i32 10, label %sw.bb35
    i32 13, label %sw.bb35
  ]

sw.bb:                                            ; preds = %for.cond
  %cond11 = select i1 %tobool36.not, ptr @.str.136, ptr @.str.135
  call fastcc void @luaX_lexerror(ptr noundef nonnull %ls, ptr noundef nonnull %cond11, i32 noundef 287)
  unreachable

sw.bb12:                                          ; preds = %for.cond
  %call13 = call fastcc i32 @skip_sep(ptr noundef nonnull %ls)
  %cmp14 = icmp eq i32 %call13, %sep
  br i1 %cmp14, label %if.then16, label %for.cond.backedge

if.then16:                                        ; preds = %sw.bb12
  %12 = load i32, ptr %ls, align 8
  call fastcc void @save(ptr noundef nonnull %ls, i32 noundef %12)
  %13 = load ptr, ptr %z, align 8
  %14 = load i64, ptr %13, align 8
  %dec20 = add i64 %14, -1
  store i64 %dec20, ptr %13, align 8
  %cmp21.not = icmp eq i64 %14, 0
  %15 = load ptr, ptr %z, align 8
  br i1 %cmp21.not, label %cond.false28, label %cond.true23

cond.true23:                                      ; preds = %if.then16
  %p25 = getelementptr inbounds %struct.Zio, ptr %15, i64 0, i32 1
  %16 = load ptr, ptr %p25, align 8
  %incdec.ptr26 = getelementptr inbounds i8, ptr %16, i64 1
  store ptr %incdec.ptr26, ptr %p25, align 8
  %17 = load i8, ptr %16, align 1
  %conv27 = zext i8 %17 to i32
  br label %cond.end31

cond.false28:                                     ; preds = %if.then16
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %size.i40)
  %L1.i41 = getelementptr inbounds %struct.Zio, ptr %15, i64 0, i32 4
  %18 = load ptr, ptr %L1.i41, align 8
  %reader.i42 = getelementptr inbounds %struct.Zio, ptr %15, i64 0, i32 2
  %19 = load ptr, ptr %reader.i42, align 8
  %data.i43 = getelementptr inbounds %struct.Zio, ptr %15, i64 0, i32 3
  %20 = load ptr, ptr %data.i43, align 8
  %call.i44 = call ptr %19(ptr noundef %18, ptr noundef %20, ptr noundef nonnull %size.i40) #35
  %cmp.i45 = icmp eq ptr %call.i44, null
  %21 = load i64, ptr %size.i40, align 8
  %cmp2.i46 = icmp eq i64 %21, 0
  %or.cond.i47 = select i1 %cmp.i45, i1 true, i1 %cmp2.i46
  br i1 %or.cond.i47, label %luaZ_fill.exit54, label %if.end.i48

if.end.i48:                                       ; preds = %cond.false28
  %sub.i49 = add i64 %21, -1
  store i64 %sub.i49, ptr %15, align 8
  %p.i50 = getelementptr inbounds %struct.Zio, ptr %15, i64 0, i32 1
  %incdec.ptr.i51 = getelementptr inbounds i8, ptr %call.i44, i64 1
  store ptr %incdec.ptr.i51, ptr %p.i50, align 8
  %22 = load i8, ptr %call.i44, align 1
  %conv.i52 = zext i8 %22 to i32
  br label %luaZ_fill.exit54

luaZ_fill.exit54:                                 ; preds = %cond.false28, %if.end.i48
  %retval.0.i53 = phi i32 [ %conv.i52, %if.end.i48 ], [ -1, %cond.false28 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %size.i40)
  br label %cond.end31

cond.end31:                                       ; preds = %luaZ_fill.exit54, %cond.true23
  %cond32 = phi i32 [ %conv27, %cond.true23 ], [ %retval.0.i53, %luaZ_fill.exit54 ]
  store i32 %cond32, ptr %ls, align 8
  br i1 %tobool36.not, label %if.end84, label %if.then77

sw.bb35:                                          ; preds = %for.cond, %for.cond
  %23 = load ptr, ptr %buff.i, align 8
  %n.i = getelementptr inbounds %struct.Mbuffer, ptr %23, i64 0, i32 1
  %24 = load i64, ptr %n.i, align 8
  %add.i = add i64 %24, 1
  %buffsize.i = getelementptr inbounds %struct.Mbuffer, ptr %23, i64 0, i32 2
  %25 = load i64, ptr %buffsize.i, align 8
  %cmp.i55 = icmp ugt i64 %add.i, %25
  br i1 %cmp.i55, label %if.then.i, label %entry.if.end14_crit_edge.i

entry.if.end14_crit_edge.i:                       ; preds = %sw.bb35
  %.pre.i = load ptr, ptr %23, align 8
  br label %save.exit

if.then.i:                                        ; preds = %sw.bb35
  %cmp2.i56 = icmp ugt i64 %25, 9223372036854775805
  br i1 %cmp2.i56, label %if.then3.i, label %cond.true.i

if.then3.i:                                       ; preds = %if.then.i
  call fastcc void @luaX_lexerror(ptr noundef nonnull %ls, ptr noundef nonnull @.str.142, i32 noundef 0) #40
  unreachable

cond.true.i:                                      ; preds = %if.then.i
  %mul.i = shl nuw i64 %25, 1
  %26 = load ptr, ptr %L.i, align 8
  %27 = load ptr, ptr %23, align 8
  %l_G.i.i = getelementptr inbounds %struct.lua_State, ptr %26, i64 0, i32 6
  %28 = load ptr, ptr %l_G.i.i, align 8
  %frealloc.i.i = getelementptr inbounds %struct.global_State, ptr %28, i64 0, i32 1
  %29 = load ptr, ptr %frealloc.i.i, align 8
  %ud.i.i = getelementptr inbounds %struct.global_State, ptr %28, i64 0, i32 2
  %30 = load ptr, ptr %ud.i.i, align 8
  %call.i.i = call ptr %29(ptr noundef %30, ptr noundef %27, i64 noundef %25, i64 noundef %mul.i) #35
  %cmp.i.i = icmp eq ptr %call.i.i, null
  %cmp1.i.i = icmp ne i64 %25, 0
  %or.cond.i.i = and i1 %cmp1.i.i, %cmp.i.i
  br i1 %or.cond.i.i, label %if.then.i.i, label %luaM_realloc_.exit.i

if.then.i.i:                                      ; preds = %cond.true.i
  %l_G.i.i.le = getelementptr inbounds %struct.lua_State, ptr %26, i64 0, i32 6
  %errorJmp.i.i.i = getelementptr inbounds %struct.lua_State, ptr %26, i64 0, i32 26
  %31 = load ptr, ptr %errorJmp.i.i.i, align 8
  %tobool.not.i.i.i = icmp eq ptr %31, null
  br i1 %tobool.not.i.i.i, label %if.else.i.i.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %if.then.i.i
  %status.i.i.i = getelementptr inbounds %struct.lua_longjmp, ptr %31, i64 0, i32 2
  store volatile i32 4, ptr %status.i.i.i, align 8
  %32 = load ptr, ptr %errorJmp.i.i.i, align 8
  %b.i.i.i = getelementptr inbounds %struct.lua_longjmp, ptr %32, i64 0, i32 1
  call void @longjmp(ptr noundef nonnull %b.i.i.i, i32 noundef 1) #38
  unreachable

if.else.i.i.i:                                    ; preds = %if.then.i.i
  %status3.i.i.i = getelementptr inbounds %struct.lua_State, ptr %26, i64 0, i32 3
  store i8 4, ptr %status3.i.i.i, align 2
  %33 = load ptr, ptr %l_G.i.i.le, align 8
  %panic.i.i.i = getelementptr inbounds %struct.global_State, ptr %33, i64 0, i32 19
  %34 = load ptr, ptr %panic.i.i.i, align 8
  %tobool4.not.i.i.i = icmp eq ptr %34, null
  br i1 %tobool4.not.i.i.i, label %if.end.i.i.i, label %if.then5.i.i.i

if.then5.i.i.i:                                   ; preds = %if.else.i.i.i
  call fastcc void @resetstack(ptr noundef nonnull %26, i32 noundef 4)
  %35 = load ptr, ptr %l_G.i.i.le, align 8
  %panic7.i.i.i = getelementptr inbounds %struct.global_State, ptr %35, i64 0, i32 19
  %36 = load ptr, ptr %panic7.i.i.i, align 8
  %call.i.i.i = call i32 %36(ptr noundef nonnull %26) #35
  br label %if.end.i.i.i

if.end.i.i.i:                                     ; preds = %if.then5.i.i.i, %if.else.i.i.i
  call void @exit(i32 noundef 1) #38
  unreachable

luaM_realloc_.exit.i:                             ; preds = %cond.true.i
  %totalbytes.i.i = getelementptr inbounds %struct.global_State, ptr %28, i64 0, i32 14
  %37 = load i64, ptr %totalbytes.i.i, align 8
  %add.i.i = add i64 %37, %25
  store i64 %add.i.i, ptr %totalbytes.i.i, align 8
  store ptr %call.i.i, ptr %23, align 8
  store i64 %mul.i, ptr %buffsize.i, align 8
  %.pre15.i = load i64, ptr %n.i, align 8
  %.pre16.i = add i64 %.pre15.i, 1
  br label %save.exit

save.exit:                                        ; preds = %entry.if.end14_crit_edge.i, %luaM_realloc_.exit.i
  %inc.pre-phi.i = phi i64 [ %add.i, %entry.if.end14_crit_edge.i ], [ %.pre16.i, %luaM_realloc_.exit.i ]
  %38 = phi i64 [ %24, %entry.if.end14_crit_edge.i ], [ %.pre15.i, %luaM_realloc_.exit.i ]
  %39 = phi ptr [ %.pre.i, %entry.if.end14_crit_edge.i ], [ %call.i.i, %luaM_realloc_.exit.i ]
  store i64 %inc.pre-phi.i, ptr %n.i, align 8
  %arrayidx.i = getelementptr inbounds i8, ptr %39, i64 %38
  store i8 10, ptr %arrayidx.i, align 1
  %40 = load i32, ptr %ls, align 8
  %41 = load ptr, ptr %z, align 8
  %42 = load i64, ptr %41, align 8
  %dec.i = add i64 %42, -1
  store i64 %dec.i, ptr %41, align 8
  %cmp.not.i = icmp eq i64 %42, 0
  %43 = load ptr, ptr %z, align 8
  br i1 %cmp.not.i, label %cond.false.i, label %cond.true.i57

cond.true.i57:                                    ; preds = %save.exit
  %p.i58 = getelementptr inbounds %struct.Zio, ptr %43, i64 0, i32 1
  %44 = load ptr, ptr %p.i58, align 8
  %incdec.ptr.i59 = getelementptr inbounds i8, ptr %44, i64 1
  store ptr %incdec.ptr.i59, ptr %p.i58, align 8
  %45 = load i8, ptr %44, align 1
  %conv.i60 = zext i8 %45 to i32
  br label %cond.end.i

cond.false.i:                                     ; preds = %save.exit
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %size.i.i)
  %L1.i.i = getelementptr inbounds %struct.Zio, ptr %43, i64 0, i32 4
  %46 = load ptr, ptr %L1.i.i, align 8
  %reader.i.i = getelementptr inbounds %struct.Zio, ptr %43, i64 0, i32 2
  %47 = load ptr, ptr %reader.i.i, align 8
  %data.i.i = getelementptr inbounds %struct.Zio, ptr %43, i64 0, i32 3
  %48 = load ptr, ptr %data.i.i, align 8
  %call.i.i63 = call ptr %47(ptr noundef %46, ptr noundef %48, ptr noundef nonnull %size.i.i) #35
  %cmp.i.i64 = icmp eq ptr %call.i.i63, null
  %49 = load i64, ptr %size.i.i, align 8
  %cmp2.i.i = icmp eq i64 %49, 0
  %or.cond.i.i65 = select i1 %cmp.i.i64, i1 true, i1 %cmp2.i.i
  br i1 %or.cond.i.i65, label %luaZ_fill.exit.i, label %if.end.i.i

if.end.i.i:                                       ; preds = %cond.false.i
  %sub.i.i = add i64 %49, -1
  store i64 %sub.i.i, ptr %43, align 8
  %p.i.i = getelementptr inbounds %struct.Zio, ptr %43, i64 0, i32 1
  %incdec.ptr.i.i = getelementptr inbounds i8, ptr %call.i.i63, i64 1
  store ptr %incdec.ptr.i.i, ptr %p.i.i, align 8
  %50 = load i8, ptr %call.i.i63, align 1
  %conv.i.i = zext i8 %50 to i32
  br label %luaZ_fill.exit.i

luaZ_fill.exit.i:                                 ; preds = %if.end.i.i, %cond.false.i
  %retval.0.i.i = phi i32 [ %conv.i.i, %if.end.i.i ], [ -1, %cond.false.i ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %size.i.i)
  br label %cond.end.i

cond.end.i:                                       ; preds = %luaZ_fill.exit.i, %cond.true.i57
  %cond.i = phi i32 [ %conv.i60, %cond.true.i57 ], [ %retval.0.i.i, %luaZ_fill.exit.i ]
  store i32 %cond.i, ptr %ls, align 8
  switch i32 %cond.i, label %if.end.i62 [
    i32 10, label %land.lhs.true.i
    i32 13, label %land.lhs.true.i
  ]

land.lhs.true.i:                                  ; preds = %cond.end.i, %cond.end.i
  %cmp11.not.i = icmp eq i32 %cond.i, %40
  br i1 %cmp11.not.i, label %if.end.i62, label %if.then.i61

if.then.i61:                                      ; preds = %land.lhs.true.i
  %51 = load ptr, ptr %z, align 8
  %52 = load i64, ptr %51, align 8
  %dec15.i = add i64 %52, -1
  store i64 %dec15.i, ptr %51, align 8
  %cmp16.not.i = icmp eq i64 %52, 0
  %53 = load ptr, ptr %z, align 8
  br i1 %cmp16.not.i, label %cond.false23.i, label %cond.true18.i

cond.true18.i:                                    ; preds = %if.then.i61
  %p20.i = getelementptr inbounds %struct.Zio, ptr %53, i64 0, i32 1
  %54 = load ptr, ptr %p20.i, align 8
  %incdec.ptr21.i = getelementptr inbounds i8, ptr %54, i64 1
  store ptr %incdec.ptr21.i, ptr %p20.i, align 8
  %55 = load i8, ptr %54, align 1
  %conv22.i = zext i8 %55 to i32
  br label %cond.end26.i

cond.false23.i:                                   ; preds = %if.then.i61
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %size.i14.i)
  %L1.i15.i = getelementptr inbounds %struct.Zio, ptr %53, i64 0, i32 4
  %56 = load ptr, ptr %L1.i15.i, align 8
  %reader.i16.i = getelementptr inbounds %struct.Zio, ptr %53, i64 0, i32 2
  %57 = load ptr, ptr %reader.i16.i, align 8
  %data.i17.i = getelementptr inbounds %struct.Zio, ptr %53, i64 0, i32 3
  %58 = load ptr, ptr %data.i17.i, align 8
  %call.i18.i = call ptr %57(ptr noundef %56, ptr noundef %58, ptr noundef nonnull %size.i14.i) #35
  %cmp.i19.i = icmp eq ptr %call.i18.i, null
  %59 = load i64, ptr %size.i14.i, align 8
  %cmp2.i20.i = icmp eq i64 %59, 0
  %or.cond.i21.i = select i1 %cmp.i19.i, i1 true, i1 %cmp2.i20.i
  br i1 %or.cond.i21.i, label %luaZ_fill.exit28.i, label %if.end.i22.i

if.end.i22.i:                                     ; preds = %cond.false23.i
  %sub.i23.i = add i64 %59, -1
  store i64 %sub.i23.i, ptr %53, align 8
  %p.i24.i = getelementptr inbounds %struct.Zio, ptr %53, i64 0, i32 1
  %incdec.ptr.i25.i = getelementptr inbounds i8, ptr %call.i18.i, i64 1
  store ptr %incdec.ptr.i25.i, ptr %p.i24.i, align 8
  %60 = load i8, ptr %call.i18.i, align 1
  %conv.i26.i = zext i8 %60 to i32
  br label %luaZ_fill.exit28.i

luaZ_fill.exit28.i:                               ; preds = %if.end.i22.i, %cond.false23.i
  %retval.0.i27.i = phi i32 [ %conv.i26.i, %if.end.i22.i ], [ -1, %cond.false23.i ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %size.i14.i)
  br label %cond.end26.i

cond.end26.i:                                     ; preds = %luaZ_fill.exit28.i, %cond.true18.i
  %cond27.i = phi i32 [ %conv22.i, %cond.true18.i ], [ %retval.0.i27.i, %luaZ_fill.exit28.i ]
  store i32 %cond27.i, ptr %ls, align 8
  br label %if.end.i62

if.end.i62:                                       ; preds = %cond.end26.i, %land.lhs.true.i, %cond.end.i
  %61 = load i32, ptr %linenumber.i, align 4
  %inc.i = add nsw i32 %61, 1
  store i32 %inc.i, ptr %linenumber.i, align 4
  %cmp29.i = icmp sgt i32 %61, 2147483643
  br i1 %cmp29.i, label %if.then31.i, label %inclinenumber.exit

if.then31.i:                                      ; preds = %if.end.i62
  %t.i.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 3
  %62 = load i32, ptr %t.i.i, align 8
  call fastcc void @luaX_lexerror(ptr noundef nonnull %ls, ptr noundef nonnull @.str.134, i32 noundef %62)
  unreachable

inclinenumber.exit:                               ; preds = %if.end.i62
  br i1 %tobool36.not, label %if.then37, label %for.cond.backedge

if.then37:                                        ; preds = %inclinenumber.exit
  %63 = load ptr, ptr %buff.i, align 8
  %n38 = getelementptr inbounds %struct.Mbuffer, ptr %63, i64 0, i32 1
  store i64 0, ptr %n38, align 8
  br label %for.cond.backedge

sw.default:                                       ; preds = %for.cond
  br i1 %tobool36.not, label %if.else, label %if.then41

if.then41:                                        ; preds = %sw.default
  call fastcc void @save(ptr noundef nonnull %ls, i32 noundef %11)
  %64 = load ptr, ptr %z, align 8
  %65 = load i64, ptr %64, align 8
  %dec45 = add i64 %65, -1
  store i64 %dec45, ptr %64, align 8
  %cmp46.not = icmp eq i64 %65, 0
  %66 = load ptr, ptr %z, align 8
  br i1 %cmp46.not, label %cond.false53, label %cond.true48

cond.true48:                                      ; preds = %if.then41
  %p50 = getelementptr inbounds %struct.Zio, ptr %66, i64 0, i32 1
  %67 = load ptr, ptr %p50, align 8
  %incdec.ptr51 = getelementptr inbounds i8, ptr %67, i64 1
  store ptr %incdec.ptr51, ptr %p50, align 8
  %68 = load i8, ptr %67, align 1
  %conv52 = zext i8 %68 to i32
  br label %cond.end56

cond.false53:                                     ; preds = %if.then41
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %size.i66)
  %L1.i67 = getelementptr inbounds %struct.Zio, ptr %66, i64 0, i32 4
  %69 = load ptr, ptr %L1.i67, align 8
  %reader.i68 = getelementptr inbounds %struct.Zio, ptr %66, i64 0, i32 2
  %70 = load ptr, ptr %reader.i68, align 8
  %data.i69 = getelementptr inbounds %struct.Zio, ptr %66, i64 0, i32 3
  %71 = load ptr, ptr %data.i69, align 8
  %call.i70 = call ptr %70(ptr noundef %69, ptr noundef %71, ptr noundef nonnull %size.i66) #35
  %cmp.i71 = icmp eq ptr %call.i70, null
  %72 = load i64, ptr %size.i66, align 8
  %cmp2.i72 = icmp eq i64 %72, 0
  %or.cond.i73 = select i1 %cmp.i71, i1 true, i1 %cmp2.i72
  br i1 %or.cond.i73, label %luaZ_fill.exit80, label %if.end.i74

if.end.i74:                                       ; preds = %cond.false53
  %sub.i75 = add i64 %72, -1
  store i64 %sub.i75, ptr %66, align 8
  %p.i76 = getelementptr inbounds %struct.Zio, ptr %66, i64 0, i32 1
  %incdec.ptr.i77 = getelementptr inbounds i8, ptr %call.i70, i64 1
  store ptr %incdec.ptr.i77, ptr %p.i76, align 8
  %73 = load i8, ptr %call.i70, align 1
  %conv.i78 = zext i8 %73 to i32
  br label %luaZ_fill.exit80

luaZ_fill.exit80:                                 ; preds = %cond.false53, %if.end.i74
  %retval.0.i79 = phi i32 [ %conv.i78, %if.end.i74 ], [ -1, %cond.false53 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %size.i66)
  br label %cond.end56

cond.end56:                                       ; preds = %luaZ_fill.exit80, %cond.true48
  %cond57 = phi i32 [ %conv52, %cond.true48 ], [ %retval.0.i79, %luaZ_fill.exit80 ]
  store i32 %cond57, ptr %ls, align 8
  br label %for.cond.backedge

for.cond.backedge:                                ; preds = %cond.end56, %cond.end72, %inclinenumber.exit, %if.then37, %sw.bb12
  br label %for.cond

if.else:                                          ; preds = %sw.default
  %74 = load ptr, ptr %z, align 8
  %75 = load i64, ptr %74, align 8
  %dec61 = add i64 %75, -1
  store i64 %dec61, ptr %74, align 8
  %cmp62.not = icmp eq i64 %75, 0
  %76 = load ptr, ptr %z, align 8
  br i1 %cmp62.not, label %cond.false69, label %cond.true64

cond.true64:                                      ; preds = %if.else
  %p66 = getelementptr inbounds %struct.Zio, ptr %76, i64 0, i32 1
  %77 = load ptr, ptr %p66, align 8
  %incdec.ptr67 = getelementptr inbounds i8, ptr %77, i64 1
  store ptr %incdec.ptr67, ptr %p66, align 8
  %78 = load i8, ptr %77, align 1
  %conv68 = zext i8 %78 to i32
  br label %cond.end72

cond.false69:                                     ; preds = %if.else
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %size.i81)
  %L1.i82 = getelementptr inbounds %struct.Zio, ptr %76, i64 0, i32 4
  %79 = load ptr, ptr %L1.i82, align 8
  %reader.i83 = getelementptr inbounds %struct.Zio, ptr %76, i64 0, i32 2
  %80 = load ptr, ptr %reader.i83, align 8
  %data.i84 = getelementptr inbounds %struct.Zio, ptr %76, i64 0, i32 3
  %81 = load ptr, ptr %data.i84, align 8
  %call.i85 = call ptr %80(ptr noundef %79, ptr noundef %81, ptr noundef nonnull %size.i81) #35
  %cmp.i86 = icmp eq ptr %call.i85, null
  %82 = load i64, ptr %size.i81, align 8
  %cmp2.i87 = icmp eq i64 %82, 0
  %or.cond.i88 = select i1 %cmp.i86, i1 true, i1 %cmp2.i87
  br i1 %or.cond.i88, label %luaZ_fill.exit95, label %if.end.i89

if.end.i89:                                       ; preds = %cond.false69
  %sub.i90 = add i64 %82, -1
  store i64 %sub.i90, ptr %76, align 8
  %p.i91 = getelementptr inbounds %struct.Zio, ptr %76, i64 0, i32 1
  %incdec.ptr.i92 = getelementptr inbounds i8, ptr %call.i85, i64 1
  store ptr %incdec.ptr.i92, ptr %p.i91, align 8
  %83 = load i8, ptr %call.i85, align 1
  %conv.i93 = zext i8 %83 to i32
  br label %luaZ_fill.exit95

luaZ_fill.exit95:                                 ; preds = %cond.false69, %if.end.i89
  %retval.0.i94 = phi i32 [ %conv.i93, %if.end.i89 ], [ -1, %cond.false69 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %size.i81)
  br label %cond.end72

cond.end72:                                       ; preds = %luaZ_fill.exit95, %cond.true64
  %cond73 = phi i32 [ %conv68, %cond.true64 ], [ %retval.0.i94, %luaZ_fill.exit95 ]
  store i32 %cond73, ptr %ls, align 8
  br label %for.cond.backedge

if.then77:                                        ; preds = %cond.end31
  %84 = load ptr, ptr %buff.i, align 8
  %85 = load ptr, ptr %84, align 8
  %add = add nuw nsw i32 %sep, 2
  %idx.ext = sext i32 %add to i64
  %add.ptr = getelementptr inbounds i8, ptr %85, i64 %idx.ext
  %n80 = getelementptr inbounds %struct.Mbuffer, ptr %84, i64 0, i32 1
  %86 = load i64, ptr %n80, align 8
  %mul = shl nsw i32 %add, 1
  %conv82 = sext i32 %mul to i64
  %sub = sub i64 %86, %conv82
  %call83 = call fastcc ptr @luaX_newstring(ptr noundef nonnull %ls, ptr noundef nonnull %add.ptr, i64 noundef %sub)
  store ptr %call83, ptr %seminfo, align 8
  br label %if.end84

if.end84:                                         ; preds = %if.then77, %cond.end31
  ret void
}

; Function Attrs: noreturn nounwind uwtable
define internal fastcc void @luaX_lexerror(ptr nocapture noundef readonly %ls, ptr noundef %msg, i32 noundef %token) unnamed_addr #7 {
entry:
  %buff = alloca [80 x i8], align 16
  %source = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 9
  %0 = load ptr, ptr %source, align 8
  %add.ptr = getelementptr inbounds %union.TString, ptr %0, i64 1
  call fastcc void @luaO_chunkid(ptr noundef nonnull %buff, ptr noundef nonnull %add.ptr, i64 noundef 80)
  %L = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 6
  %1 = load ptr, ptr %L, align 8
  %linenumber = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 1
  %2 = load i32, ptr %linenumber, align 4
  %call = call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %1, ptr noundef nonnull @.str.6, ptr noundef nonnull %buff, i32 noundef %2, ptr noundef %msg)
  %tobool.not = icmp eq i32 %token, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %L, align 8
  %token.off.i = add i32 %token, -284
  %switch.i = icmp ult i32 %token.off.i, 3
  br i1 %switch.i, label %sw.bb.i, label %sw.default.i

sw.bb.i:                                          ; preds = %if.then
  call fastcc void @save(ptr noundef nonnull %ls, i32 noundef 0)
  %buff.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 8
  %4 = load ptr, ptr %buff.i, align 8
  %5 = load ptr, ptr %4, align 8
  br label %txtToken.exit

sw.default.i:                                     ; preds = %if.then
  %cmp.i = icmp slt i32 %token, 257
  br i1 %cmp.i, label %if.then.i11, label %if.else.i9

if.then.i11:                                      ; preds = %sw.default.i
  %call.i12 = tail call ptr @__ctype_b_loc() #39
  %6 = load ptr, ptr %call.i12, align 8
  %idxprom.i = sext i32 %token to i64
  %arrayidx.i = getelementptr inbounds i16, ptr %6, i64 %idxprom.i
  %7 = load i16, ptr %arrayidx.i, align 2
  %8 = and i16 %7, 2
  %tobool.not.i13 = icmp eq i16 %8, 0
  br i1 %tobool.not.i13, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %if.then.i11
  %call1.i = call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %3, ptr noundef nonnull @.str.138, i32 noundef %token)
  br label %txtToken.exit

cond.false.i:                                     ; preds = %if.then.i11
  %call3.i = call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %3, ptr noundef nonnull @.str.139, i32 noundef %token)
  br label %txtToken.exit

if.else.i9:                                       ; preds = %sw.default.i
  %sub.i = add nsw i32 %token, -257
  %idxprom4.i = zext nneg i32 %sub.i to i64
  %arrayidx5.i = getelementptr inbounds [32 x ptr], ptr @luaX_tokens, i64 0, i64 %idxprom4.i
  %9 = load ptr, ptr %arrayidx5.i, align 8
  br label %txtToken.exit

txtToken.exit:                                    ; preds = %if.else.i9, %cond.false.i, %cond.true.i, %sw.bb.i
  %retval.0.i = phi ptr [ %5, %sw.bb.i ], [ %9, %if.else.i9 ], [ %call1.i, %cond.true.i ], [ %call3.i, %cond.false.i ]
  %call4 = call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %3, ptr noundef nonnull @.str.137, ptr noundef %call, ptr noundef %retval.0.i)
  br label %if.end

if.end:                                           ; preds = %txtToken.exit, %entry
  %10 = load ptr, ptr %L, align 8
  %errorJmp.i = getelementptr inbounds %struct.lua_State, ptr %10, i64 0, i32 26
  %11 = load ptr, ptr %errorJmp.i, align 8
  %tobool.not.i = icmp eq ptr %11, null
  br i1 %tobool.not.i, label %if.else.i, label %if.then.i

if.then.i:                                        ; preds = %if.end
  %status.i = getelementptr inbounds %struct.lua_longjmp, ptr %11, i64 0, i32 2
  store volatile i32 3, ptr %status.i, align 8
  %12 = load ptr, ptr %errorJmp.i, align 8
  %b.i = getelementptr inbounds %struct.lua_longjmp, ptr %12, i64 0, i32 1
  call void @longjmp(ptr noundef nonnull %b.i, i32 noundef 1) #38
  unreachable

if.else.i:                                        ; preds = %if.end
  %status3.i = getelementptr inbounds %struct.lua_State, ptr %10, i64 0, i32 3
  store i8 3, ptr %status3.i, align 2
  %l_G.i = getelementptr inbounds %struct.lua_State, ptr %10, i64 0, i32 6
  %13 = load ptr, ptr %l_G.i, align 8
  %panic.i = getelementptr inbounds %struct.global_State, ptr %13, i64 0, i32 19
  %14 = load ptr, ptr %panic.i, align 8
  %tobool4.not.i = icmp eq ptr %14, null
  br i1 %tobool4.not.i, label %if.end.i, label %if.then5.i

if.then5.i:                                       ; preds = %if.else.i
  %base_ci.i = getelementptr inbounds %struct.lua_State, ptr %10, i64 0, i32 12
  %15 = load ptr, ptr %base_ci.i, align 8
  %ci.i = getelementptr inbounds %struct.lua_State, ptr %10, i64 0, i32 7
  store ptr %15, ptr %ci.i, align 8
  %16 = load ptr, ptr %15, align 8
  %base2.i = getelementptr inbounds %struct.lua_State, ptr %10, i64 0, i32 5
  store ptr %16, ptr %base2.i, align 8
  call fastcc void @luaF_close(ptr noundef nonnull %10, ptr noundef %16)
  %17 = load ptr, ptr %base2.i, align 8
  %top.i.i = getelementptr inbounds %struct.lua_State, ptr %10, i64 0, i32 4
  %18 = load ptr, ptr %top.i.i, align 8
  %add.ptr.i.i = getelementptr inbounds %struct.lua_TValue, ptr %18, i64 -1
  %19 = load i64, ptr %add.ptr.i.i, align 8
  store i64 %19, ptr %17, align 8
  %tt9.i.i = getelementptr %struct.lua_TValue, ptr %18, i64 -1, i32 1
  %20 = load i32, ptr %tt9.i.i, align 8
  %tt.i.i = getelementptr inbounds %struct.lua_TValue, ptr %17, i64 0, i32 1
  store i32 %20, ptr %tt.i.i, align 8
  %add.ptr11.i.i = getelementptr inbounds %struct.lua_TValue, ptr %17, i64 1
  store ptr %add.ptr11.i.i, ptr %top.i.i, align 8
  %baseCcalls.i = getelementptr inbounds %struct.lua_State, ptr %10, i64 0, i32 16
  %21 = load i16, ptr %baseCcalls.i, align 2
  %nCcalls.i = getelementptr inbounds %struct.lua_State, ptr %10, i64 0, i32 15
  store i16 %21, ptr %nCcalls.i, align 8
  %allowhook.i = getelementptr inbounds %struct.lua_State, ptr %10, i64 0, i32 18
  store i8 1, ptr %allowhook.i, align 1
  %size_ci.i.i = getelementptr inbounds %struct.lua_State, ptr %10, i64 0, i32 14
  %22 = load i32, ptr %size_ci.i.i, align 4
  %cmp.i.i = icmp sgt i32 %22, 20000
  br i1 %cmp.i.i, label %if.then.i.i, label %resetstack.exit

if.then.i.i:                                      ; preds = %if.then5.i
  %23 = load ptr, ptr %ci.i, align 8
  %24 = load ptr, ptr %base_ci.i, align 8
  %sub.ptr.lhs.cast.i.i = ptrtoint ptr %23 to i64
  %sub.ptr.rhs.cast.i.i = ptrtoint ptr %24 to i64
  %sub.ptr.sub.i.i = sub i64 %sub.ptr.lhs.cast.i.i, %sub.ptr.rhs.cast.i.i
  %sub.ptr.div.i.i = sdiv exact i64 %sub.ptr.sub.i.i, 40
  %conv.i.i = trunc i64 %sub.ptr.div.i.i to i32
  %cmp1.i.i = icmp slt i32 %conv.i.i, 19999
  br i1 %cmp1.i.i, label %if.then3.i.i, label %resetstack.exit

if.then3.i.i:                                     ; preds = %if.then.i.i
  call fastcc void @luaD_reallocCI(ptr noundef nonnull %10, i32 noundef 20000) #40
  br label %resetstack.exit

resetstack.exit:                                  ; preds = %if.then5.i, %if.then.i.i, %if.then3.i.i
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %errorJmp.i, i8 0, i64 16, i1 false)
  %25 = load ptr, ptr %l_G.i, align 8
  %panic7.i = getelementptr inbounds %struct.global_State, ptr %25, i64 0, i32 19
  %26 = load ptr, ptr %panic7.i, align 8
  %call.i8 = call i32 %26(ptr noundef nonnull %10) #35
  br label %if.end.i

if.end.i:                                         ; preds = %resetstack.exit, %if.else.i
  call void @exit(i32 noundef 1) #38
  unreachable
}

; Function Attrs: nounwind uwtable
define internal fastcc void @save(ptr nocapture noundef readonly %ls, i32 noundef %c) unnamed_addr #0 {
entry:
  %buff = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 8
  %0 = load ptr, ptr %buff, align 8
  %n = getelementptr inbounds %struct.Mbuffer, ptr %0, i64 0, i32 1
  %1 = load i64, ptr %n, align 8
  %add = add i64 %1, 1
  %buffsize = getelementptr inbounds %struct.Mbuffer, ptr %0, i64 0, i32 2
  %2 = load i64, ptr %buffsize, align 8
  %cmp = icmp ugt i64 %add, %2
  br i1 %cmp, label %if.then, label %entry.if.end14_crit_edge

entry.if.end14_crit_edge:                         ; preds = %entry
  %.pre = load ptr, ptr %0, align 8
  br label %if.end14

if.then:                                          ; preds = %entry
  %cmp2 = icmp ugt i64 %2, 9223372036854775805
  br i1 %cmp2, label %if.then3, label %cond.true

if.then3:                                         ; preds = %if.then
  tail call fastcc void @luaX_lexerror(ptr noundef nonnull %ls, ptr noundef nonnull @.str.142, i32 noundef 0)
  unreachable

cond.true:                                        ; preds = %if.then
  %mul = shl nuw i64 %2, 1
  %L = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 6
  %3 = load ptr, ptr %L, align 8
  %4 = load ptr, ptr %0, align 8
  %l_G.i = getelementptr inbounds %struct.lua_State, ptr %3, i64 0, i32 6
  %5 = load ptr, ptr %l_G.i, align 8
  %frealloc.i = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 1
  %6 = load ptr, ptr %frealloc.i, align 8
  %ud.i = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 2
  %7 = load ptr, ptr %ud.i, align 8
  %call.i = tail call ptr %6(ptr noundef %7, ptr noundef %4, i64 noundef %2, i64 noundef %mul) #35
  %cmp.i = icmp eq ptr %call.i, null
  %cmp1.i = icmp ne i64 %2, 0
  %or.cond.i = and i1 %cmp1.i, %cmp.i
  br i1 %or.cond.i, label %if.then.i, label %luaM_realloc_.exit

if.then.i:                                        ; preds = %cond.true
  %errorJmp.i.i = getelementptr inbounds %struct.lua_State, ptr %3, i64 0, i32 26
  %8 = load ptr, ptr %errorJmp.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %8, null
  br i1 %tobool.not.i.i, label %if.else.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %if.then.i
  %status.i.i = getelementptr inbounds %struct.lua_longjmp, ptr %8, i64 0, i32 2
  store volatile i32 4, ptr %status.i.i, align 8
  %9 = load ptr, ptr %errorJmp.i.i, align 8
  %b.i.i = getelementptr inbounds %struct.lua_longjmp, ptr %9, i64 0, i32 1
  tail call void @longjmp(ptr noundef nonnull %b.i.i, i32 noundef 1) #38
  unreachable

if.else.i.i:                                      ; preds = %if.then.i
  %status3.i.i = getelementptr inbounds %struct.lua_State, ptr %3, i64 0, i32 3
  store i8 4, ptr %status3.i.i, align 2
  %10 = load ptr, ptr %l_G.i, align 8
  %panic.i.i = getelementptr inbounds %struct.global_State, ptr %10, i64 0, i32 19
  %11 = load ptr, ptr %panic.i.i, align 8
  %tobool4.not.i.i = icmp eq ptr %11, null
  br i1 %tobool4.not.i.i, label %if.end.i.i, label %if.then5.i.i

if.then5.i.i:                                     ; preds = %if.else.i.i
  tail call fastcc void @resetstack(ptr noundef nonnull %3, i32 noundef 4)
  %12 = load ptr, ptr %l_G.i, align 8
  %panic7.i.i = getelementptr inbounds %struct.global_State, ptr %12, i64 0, i32 19
  %13 = load ptr, ptr %panic7.i.i, align 8
  %call.i.i = tail call i32 %13(ptr noundef nonnull %3) #35
  br label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then5.i.i, %if.else.i.i
  tail call void @exit(i32 noundef 1) #38
  unreachable

luaM_realloc_.exit:                               ; preds = %cond.true
  %totalbytes.i = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 14
  %14 = load i64, ptr %totalbytes.i, align 8
  %add.i = add i64 %14, %2
  store i64 %add.i, ptr %totalbytes.i, align 8
  store ptr %call.i, ptr %0, align 8
  store i64 %mul, ptr %buffsize, align 8
  %.pre15 = load i64, ptr %n, align 8
  %.pre16 = add i64 %.pre15, 1
  br label %if.end14

if.end14:                                         ; preds = %entry.if.end14_crit_edge, %luaM_realloc_.exit
  %inc.pre-phi = phi i64 [ %add, %entry.if.end14_crit_edge ], [ %.pre16, %luaM_realloc_.exit ]
  %15 = phi i64 [ %1, %entry.if.end14_crit_edge ], [ %.pre15, %luaM_realloc_.exit ]
  %16 = phi ptr [ %.pre, %entry.if.end14_crit_edge ], [ %call.i, %luaM_realloc_.exit ]
  %conv = trunc i32 %c to i8
  store i64 %inc.pre-phi, ptr %n, align 8
  %arrayidx = getelementptr inbounds i8, ptr %16, i64 %15
  store i8 %conv, ptr %arrayidx, align 1
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @read_numeral(ptr nocapture noundef %ls, ptr nocapture noundef writeonly %seminfo) unnamed_addr #0 {
entry:
  %endptr.i = alloca ptr, align 8
  %size.i61 = alloca i64, align 8
  %size.i.i31 = alloca i64, align 8
  %size.i.i = alloca i64, align 8
  %size.i = alloca i64, align 8
  %z = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 7
  %.pre = load i32, ptr %ls, align 8
  br label %do.body

do.body:                                          ; preds = %cond.end, %entry
  %0 = phi i32 [ %cond, %cond.end ], [ %.pre, %entry ]
  call fastcc void @save(ptr noundef nonnull %ls, i32 noundef %0)
  %1 = load ptr, ptr %z, align 8
  %2 = load i64, ptr %1, align 8
  %dec = add i64 %2, -1
  store i64 %dec, ptr %1, align 8
  %cmp.not = icmp eq i64 %2, 0
  %3 = load ptr, ptr %z, align 8
  br i1 %cmp.not, label %cond.false, label %cond.true

cond.true:                                        ; preds = %do.body
  %p = getelementptr inbounds %struct.Zio, ptr %3, i64 0, i32 1
  %4 = load ptr, ptr %p, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %4, i64 1
  store ptr %incdec.ptr, ptr %p, align 8
  %5 = load i8, ptr %4, align 1
  %conv = zext i8 %5 to i32
  br label %cond.end

cond.false:                                       ; preds = %do.body
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %size.i)
  %L1.i = getelementptr inbounds %struct.Zio, ptr %3, i64 0, i32 4
  %6 = load ptr, ptr %L1.i, align 8
  %reader.i = getelementptr inbounds %struct.Zio, ptr %3, i64 0, i32 2
  %7 = load ptr, ptr %reader.i, align 8
  %data.i = getelementptr inbounds %struct.Zio, ptr %3, i64 0, i32 3
  %8 = load ptr, ptr %data.i, align 8
  %call.i = call ptr %7(ptr noundef %6, ptr noundef %8, ptr noundef nonnull %size.i) #35
  %cmp.i = icmp eq ptr %call.i, null
  %9 = load i64, ptr %size.i, align 8
  %cmp2.i = icmp eq i64 %9, 0
  %or.cond.i = select i1 %cmp.i, i1 true, i1 %cmp2.i
  br i1 %or.cond.i, label %luaZ_fill.exit, label %if.end.i

if.end.i:                                         ; preds = %cond.false
  %sub.i = add i64 %9, -1
  store i64 %sub.i, ptr %3, align 8
  %p.i = getelementptr inbounds %struct.Zio, ptr %3, i64 0, i32 1
  %incdec.ptr.i = getelementptr inbounds i8, ptr %call.i, i64 1
  store ptr %incdec.ptr.i, ptr %p.i, align 8
  %10 = load i8, ptr %call.i, align 1
  %conv.i = zext i8 %10 to i32
  br label %luaZ_fill.exit

luaZ_fill.exit:                                   ; preds = %cond.false, %if.end.i
  %retval.0.i = phi i32 [ %conv.i, %if.end.i ], [ -1, %cond.false ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %size.i)
  br label %cond.end

cond.end:                                         ; preds = %luaZ_fill.exit, %cond.true
  %cond = phi i32 [ %conv, %cond.true ], [ %retval.0.i, %luaZ_fill.exit ]
  store i32 %cond, ptr %ls, align 8
  %call4 = tail call ptr @__ctype_b_loc() #39
  %11 = load ptr, ptr %call4, align 8
  %idxprom = sext i32 %cond to i64
  %arrayidx = getelementptr inbounds i16, ptr %11, i64 %idxprom
  %12 = load i16, ptr %arrayidx, align 2
  %13 = and i16 %12, 2048
  %tobool.not = icmp ne i16 %13, 0
  %cmp8 = icmp eq i32 %cond, 46
  %or.cond = or i1 %cmp8, %tobool.not
  br i1 %or.cond, label %do.body, label %do.end, !llvm.loop !109

do.end:                                           ; preds = %cond.end
  %memchr = call ptr @memchr(ptr nonnull dereferenceable(1) @.str.143, i32 %cond, i64 3)
  %tobool.not.i = icmp eq ptr %memchr, null
  br i1 %tobool.not.i, label %if.end, label %if.end.i26

if.end.i26:                                       ; preds = %do.end
  call fastcc void @save(ptr noundef nonnull %ls, i32 noundef %cond)
  %14 = load ptr, ptr %z, align 8
  %15 = load i64, ptr %14, align 8
  %dec.i = add i64 %15, -1
  store i64 %dec.i, ptr %14, align 8
  %cmp.not.i = icmp eq i64 %15, 0
  %16 = load ptr, ptr %z, align 8
  br i1 %cmp.not.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %if.end.i26
  %p.i27 = getelementptr inbounds %struct.Zio, ptr %16, i64 0, i32 1
  %17 = load ptr, ptr %p.i27, align 8
  %incdec.ptr.i28 = getelementptr inbounds i8, ptr %17, i64 1
  store ptr %incdec.ptr.i28, ptr %p.i27, align 8
  %18 = load i8, ptr %17, align 1
  %conv.i29 = zext i8 %18 to i32
  br label %if.then

cond.false.i:                                     ; preds = %if.end.i26
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %size.i.i)
  %L1.i.i = getelementptr inbounds %struct.Zio, ptr %16, i64 0, i32 4
  %19 = load ptr, ptr %L1.i.i, align 8
  %reader.i.i = getelementptr inbounds %struct.Zio, ptr %16, i64 0, i32 2
  %20 = load ptr, ptr %reader.i.i, align 8
  %data.i.i = getelementptr inbounds %struct.Zio, ptr %16, i64 0, i32 3
  %21 = load ptr, ptr %data.i.i, align 8
  %call.i.i = call ptr %20(ptr noundef %19, ptr noundef %21, ptr noundef nonnull %size.i.i) #35
  %cmp.i.i = icmp eq ptr %call.i.i, null
  %22 = load i64, ptr %size.i.i, align 8
  %cmp2.i.i = icmp eq i64 %22, 0
  %or.cond.i.i = select i1 %cmp.i.i, i1 true, i1 %cmp2.i.i
  br i1 %or.cond.i.i, label %luaZ_fill.exit.i, label %if.end.i.i

if.end.i.i:                                       ; preds = %cond.false.i
  %sub.i.i = add i64 %22, -1
  store i64 %sub.i.i, ptr %16, align 8
  %p.i.i = getelementptr inbounds %struct.Zio, ptr %16, i64 0, i32 1
  %incdec.ptr.i.i = getelementptr inbounds i8, ptr %call.i.i, i64 1
  store ptr %incdec.ptr.i.i, ptr %p.i.i, align 8
  %23 = load i8, ptr %call.i.i, align 1
  %conv.i.i = zext i8 %23 to i32
  br label %luaZ_fill.exit.i

luaZ_fill.exit.i:                                 ; preds = %if.end.i.i, %cond.false.i
  %retval.0.i.i = phi i32 [ %conv.i.i, %if.end.i.i ], [ -1, %cond.false.i ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %size.i.i)
  br label %if.then

if.then:                                          ; preds = %luaZ_fill.exit.i, %cond.true.i
  %cond.i = phi i32 [ %conv.i29, %cond.true.i ], [ %retval.0.i.i, %luaZ_fill.exit.i ]
  store i32 %cond.i, ptr %ls, align 8
  %24 = and i32 %cond.i, 255
  %25 = zext nneg i32 %24 to i64
  %memchr.bounds = icmp ugt i32 %24, 63
  %26 = shl nuw i64 1, %25
  %27 = and i64 %26, 43980465111041
  %memchr.bits = icmp eq i64 %27, 0
  %memchr94.not = select i1 %memchr.bounds, i1 true, i1 %memchr.bits
  br i1 %memchr94.not, label %if.end, label %if.end.i34

if.end.i34:                                       ; preds = %if.then
  call fastcc void @save(ptr noundef nonnull %ls, i32 noundef %cond.i)
  %28 = load ptr, ptr %z, align 8
  %29 = load i64, ptr %28, align 8
  %dec.i36 = add i64 %29, -1
  store i64 %dec.i36, ptr %28, align 8
  %cmp.not.i37 = icmp eq i64 %29, 0
  %30 = load ptr, ptr %z, align 8
  br i1 %cmp.not.i37, label %cond.false.i45, label %cond.true.i38

cond.true.i38:                                    ; preds = %if.end.i34
  %p.i39 = getelementptr inbounds %struct.Zio, ptr %30, i64 0, i32 1
  %31 = load ptr, ptr %p.i39, align 8
  %incdec.ptr.i40 = getelementptr inbounds i8, ptr %31, i64 1
  store ptr %incdec.ptr.i40, ptr %p.i39, align 8
  %32 = load i8, ptr %31, align 1
  %conv.i41 = zext i8 %32 to i32
  br label %cond.end.i42

cond.false.i45:                                   ; preds = %if.end.i34
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %size.i.i31)
  %L1.i.i46 = getelementptr inbounds %struct.Zio, ptr %30, i64 0, i32 4
  %33 = load ptr, ptr %L1.i.i46, align 8
  %reader.i.i47 = getelementptr inbounds %struct.Zio, ptr %30, i64 0, i32 2
  %34 = load ptr, ptr %reader.i.i47, align 8
  %data.i.i48 = getelementptr inbounds %struct.Zio, ptr %30, i64 0, i32 3
  %35 = load ptr, ptr %data.i.i48, align 8
  %call.i.i49 = call ptr %34(ptr noundef %33, ptr noundef %35, ptr noundef nonnull %size.i.i31) #35
  %cmp.i.i50 = icmp eq ptr %call.i.i49, null
  %36 = load i64, ptr %size.i.i31, align 8
  %cmp2.i.i51 = icmp eq i64 %36, 0
  %or.cond.i.i52 = select i1 %cmp.i.i50, i1 true, i1 %cmp2.i.i51
  br i1 %or.cond.i.i52, label %luaZ_fill.exit.i58, label %if.end.i.i53

if.end.i.i53:                                     ; preds = %cond.false.i45
  %sub.i.i54 = add i64 %36, -1
  store i64 %sub.i.i54, ptr %30, align 8
  %p.i.i55 = getelementptr inbounds %struct.Zio, ptr %30, i64 0, i32 1
  %incdec.ptr.i.i56 = getelementptr inbounds i8, ptr %call.i.i49, i64 1
  store ptr %incdec.ptr.i.i56, ptr %p.i.i55, align 8
  %37 = load i8, ptr %call.i.i49, align 1
  %conv.i.i57 = zext i8 %37 to i32
  br label %luaZ_fill.exit.i58

luaZ_fill.exit.i58:                               ; preds = %if.end.i.i53, %cond.false.i45
  %retval.0.i.i59 = phi i32 [ %conv.i.i57, %if.end.i.i53 ], [ -1, %cond.false.i45 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %size.i.i31)
  br label %cond.end.i42

cond.end.i42:                                     ; preds = %luaZ_fill.exit.i58, %cond.true.i38
  %cond.i43 = phi i32 [ %conv.i41, %cond.true.i38 ], [ %retval.0.i.i59, %luaZ_fill.exit.i58 ]
  store i32 %cond.i43, ptr %ls, align 8
  br label %if.end

if.end:                                           ; preds = %do.end, %cond.end.i42, %if.then
  %38 = phi i32 [ %cond, %do.end ], [ %cond.i43, %cond.end.i42 ], [ %cond.i, %if.then ]
  %39 = load ptr, ptr %call4, align 8
  %idxprom1595 = sext i32 %38 to i64
  %arrayidx1696 = getelementptr inbounds i16, ptr %39, i64 %idxprom1595
  %40 = load i16, ptr %arrayidx1696, align 2
  %41 = and i16 %40, 8
  %tobool19.not97 = icmp ne i16 %41, 0
  %cmp2298 = icmp eq i32 %38, 95
  %or.cond2399 = or i1 %cmp2298, %tobool19.not97
  br i1 %or.cond2399, label %while.body, label %while.end

while.body:                                       ; preds = %if.end, %cond.end39
  %42 = phi i32 [ %cond40, %cond.end39 ], [ %38, %if.end ]
  call fastcc void @save(ptr noundef nonnull %ls, i32 noundef %42)
  %43 = load ptr, ptr %z, align 8
  %44 = load i64, ptr %43, align 8
  %dec28 = add i64 %44, -1
  store i64 %dec28, ptr %43, align 8
  %cmp29.not = icmp eq i64 %44, 0
  %45 = load ptr, ptr %z, align 8
  br i1 %cmp29.not, label %cond.false36, label %cond.true31

cond.true31:                                      ; preds = %while.body
  %p33 = getelementptr inbounds %struct.Zio, ptr %45, i64 0, i32 1
  %46 = load ptr, ptr %p33, align 8
  %incdec.ptr34 = getelementptr inbounds i8, ptr %46, i64 1
  store ptr %incdec.ptr34, ptr %p33, align 8
  %47 = load i8, ptr %46, align 1
  %conv35 = zext i8 %47 to i32
  br label %cond.end39

cond.false36:                                     ; preds = %while.body
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %size.i61)
  %L1.i62 = getelementptr inbounds %struct.Zio, ptr %45, i64 0, i32 4
  %48 = load ptr, ptr %L1.i62, align 8
  %reader.i63 = getelementptr inbounds %struct.Zio, ptr %45, i64 0, i32 2
  %49 = load ptr, ptr %reader.i63, align 8
  %data.i64 = getelementptr inbounds %struct.Zio, ptr %45, i64 0, i32 3
  %50 = load ptr, ptr %data.i64, align 8
  %call.i65 = call ptr %49(ptr noundef %48, ptr noundef %50, ptr noundef nonnull %size.i61) #35
  %cmp.i66 = icmp eq ptr %call.i65, null
  %51 = load i64, ptr %size.i61, align 8
  %cmp2.i67 = icmp eq i64 %51, 0
  %or.cond.i68 = select i1 %cmp.i66, i1 true, i1 %cmp2.i67
  br i1 %or.cond.i68, label %luaZ_fill.exit75, label %if.end.i69

if.end.i69:                                       ; preds = %cond.false36
  %sub.i70 = add i64 %51, -1
  store i64 %sub.i70, ptr %45, align 8
  %p.i71 = getelementptr inbounds %struct.Zio, ptr %45, i64 0, i32 1
  %incdec.ptr.i72 = getelementptr inbounds i8, ptr %call.i65, i64 1
  store ptr %incdec.ptr.i72, ptr %p.i71, align 8
  %52 = load i8, ptr %call.i65, align 1
  %conv.i73 = zext i8 %52 to i32
  br label %luaZ_fill.exit75

luaZ_fill.exit75:                                 ; preds = %cond.false36, %if.end.i69
  %retval.0.i74 = phi i32 [ %conv.i73, %if.end.i69 ], [ -1, %cond.false36 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %size.i61)
  br label %cond.end39

cond.end39:                                       ; preds = %luaZ_fill.exit75, %cond.true31
  %cond40 = phi i32 [ %conv35, %cond.true31 ], [ %retval.0.i74, %luaZ_fill.exit75 ]
  store i32 %cond40, ptr %ls, align 8
  %53 = load ptr, ptr %call4, align 8
  %idxprom15 = sext i32 %cond40 to i64
  %arrayidx16 = getelementptr inbounds i16, ptr %53, i64 %idxprom15
  %54 = load i16, ptr %arrayidx16, align 2
  %55 = and i16 %54, 8
  %tobool19.not = icmp ne i16 %55, 0
  %cmp22 = icmp eq i32 %cond40, 95
  %or.cond23 = or i1 %cmp22, %tobool19.not
  br i1 %or.cond23, label %while.body, label %while.end, !llvm.loop !110

while.end:                                        ; preds = %cond.end39, %if.end
  call fastcc void @save(ptr noundef nonnull %ls, i32 noundef 0)
  %decpoint = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 10
  %56 = load i8, ptr %decpoint, align 8
  %57 = getelementptr i8, ptr %ls, i64 72
  %ls.val = load ptr, ptr %57, align 8
  %ls.val.val = load ptr, ptr %ls.val, align 8
  %58 = getelementptr i8, ptr %ls.val, i64 8
  %ls.val.val24 = load i64, ptr %58, align 8
  %tobool.not2.i = icmp eq i64 %ls.val.val24, 0
  br i1 %tobool.not2.i, label %buffreplace.exit, label %while.body.i

while.body.i:                                     ; preds = %while.end, %if.end.i77
  %dec3.in.i = phi i64 [ %dec3.i, %if.end.i77 ], [ %ls.val.val24, %while.end ]
  %dec3.i = add i64 %dec3.in.i, -1
  %arrayidx.i = getelementptr inbounds i8, ptr %ls.val.val, i64 %dec3.i
  %59 = load i8, ptr %arrayidx.i, align 1
  %cmp.i76 = icmp eq i8 %59, 46
  br i1 %cmp.i76, label %if.then.i, label %if.end.i77

if.then.i:                                        ; preds = %while.body.i
  store i8 %56, ptr %arrayidx.i, align 1
  br label %if.end.i77

if.end.i77:                                       ; preds = %if.then.i, %while.body.i
  %tobool.not.i78 = icmp eq i64 %dec3.i, 0
  br i1 %tobool.not.i78, label %buffreplace.exit.loopexit, label %while.body.i, !llvm.loop !111

buffreplace.exit.loopexit:                        ; preds = %if.end.i77
  %.pre100 = load ptr, ptr %57, align 8
  %.pre101 = load ptr, ptr %.pre100, align 8
  br label %buffreplace.exit

buffreplace.exit:                                 ; preds = %buffreplace.exit.loopexit, %while.end
  %60 = phi ptr [ %.pre101, %buffreplace.exit.loopexit ], [ %ls.val.val, %while.end ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i)
  %call.i79 = call double @strtod(ptr noundef %60, ptr noundef nonnull %endptr.i) #35
  store double %call.i79, ptr %seminfo, align 8
  %61 = load ptr, ptr %endptr.i, align 8
  %cmp.i80 = icmp eq ptr %61, %60
  br i1 %cmp.i80, label %luaO_str2d.exit.thread, label %if.end.i81

luaO_str2d.exit.thread:                           ; preds = %buffreplace.exit
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i)
  br label %if.then44

if.end.i81:                                       ; preds = %buffreplace.exit
  %62 = load i8, ptr %61, align 1
  switch i8 %62, label %if.end9.i [
    i8 120, label %if.then6.i
    i8 88, label %if.then6.i
  ]

if.then6.i:                                       ; preds = %if.end.i81, %if.end.i81
  %call7.i = call i64 @strtoul(ptr noundef %60, ptr noundef nonnull %endptr.i, i32 noundef 16) #35
  %conv8.i = uitofp i64 %call7.i to double
  store double %conv8.i, ptr %seminfo, align 8
  %.pre.i = load ptr, ptr %endptr.i, align 8
  %.pre5.i = load i8, ptr %.pre.i, align 1
  br label %if.end9.i

if.end9.i:                                        ; preds = %if.then6.i, %if.end.i81
  %63 = phi i8 [ %62, %if.end.i81 ], [ %.pre5.i, %if.then6.i ]
  %endptr.promoted.i = phi ptr [ %61, %if.end.i81 ], [ %.pre.i, %if.then6.i ]
  %cmp11.i = icmp eq i8 %63, 0
  br i1 %cmp11.i, label %luaO_str2d.exit.thread90, label %while.cond.preheader.i

luaO_str2d.exit.thread90:                         ; preds = %if.end9.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i)
  br label %if.end45

while.cond.preheader.i:                           ; preds = %if.end9.i
  %64 = load ptr, ptr %call4, align 8
  br label %while.cond.i

while.cond.i:                                     ; preds = %while.cond.i, %while.cond.preheader.i
  %incdec.ptr4.i = phi ptr [ %endptr.promoted.i, %while.cond.preheader.i ], [ %incdec.ptr.i84, %while.cond.i ]
  %65 = load i8, ptr %incdec.ptr4.i, align 1
  %idxprom.i = zext i8 %65 to i64
  %arrayidx.i82 = getelementptr inbounds i16, ptr %64, i64 %idxprom.i
  %66 = load i16, ptr %arrayidx.i82, align 2
  %67 = and i16 %66, 8192
  %tobool.not.i83 = icmp eq i16 %67, 0
  %incdec.ptr.i84 = getelementptr inbounds i8, ptr %incdec.ptr4.i, i64 1
  br i1 %tobool.not.i83, label %luaO_str2d.exit, label %while.cond.i, !llvm.loop !35

luaO_str2d.exit:                                  ; preds = %while.cond.i
  %cmp19.not.i.not = icmp eq i8 %65, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i)
  br i1 %cmp19.not.i.not, label %if.end45, label %if.then44

if.then44:                                        ; preds = %luaO_str2d.exit.thread, %luaO_str2d.exit
  call fastcc void @luaX_lexerror(ptr noundef nonnull %ls, ptr noundef nonnull @.str.145, i32 noundef 284)
  unreachable

if.end45:                                         ; preds = %luaO_str2d.exit.thread90, %luaO_str2d.exit
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc ptr @luaX_newstring(ptr nocapture noundef readonly %ls, ptr nocapture noundef readonly %str, i64 noundef %l) unnamed_addr #0 {
entry:
  %k.i = alloca %struct.lua_TValue, align 8
  %L1 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 6
  %0 = load ptr, ptr %L1, align 8
  %call = tail call fastcc ptr @luaS_newlstr(ptr noundef %0, ptr noundef %str, i64 noundef %l)
  %fs = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 5
  %1 = load ptr, ptr %fs, align 8
  %h = getelementptr inbounds %struct.FuncState, ptr %1, i64 0, i32 1
  %2 = load ptr, ptr %h, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %k.i)
  %3 = getelementptr i8, ptr %2, i64 11
  %t.val.i = load i8, ptr %3, align 1
  %4 = getelementptr i8, ptr %2, i64 32
  %t.val5.i = load ptr, ptr %4, align 8
  %hash.i.i = getelementptr inbounds %struct.anon.0, ptr %call, i64 0, i32 4
  %5 = load i32, ptr %hash.i.i, align 4
  %sh_prom.i.i = zext nneg i8 %t.val.i to i64
  %notmask.i.i = shl nsw i64 -1, %sh_prom.i.i
  %6 = trunc i64 %notmask.i.i to i32
  %7 = xor i32 %6, -1
  %conv2.i.i = and i32 %5, %7
  %idxprom.i.i = sext i32 %conv2.i.i to i64
  %arrayidx.i.i = getelementptr inbounds %struct.Node, ptr %t.val5.i, i64 %idxprom.i.i
  br label %do.body.i.i

do.body.i.i:                                      ; preds = %if.else.i.i, %entry
  %n.0.i.i = phi ptr [ %arrayidx.i.i, %entry ], [ %10, %if.else.i.i ]
  %tt.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1, i32 0, i32 1
  %8 = load i32, ptr %tt.i.i, align 8
  %cmp.i.i = icmp eq i32 %8, 4
  br i1 %cmp.i.i, label %land.lhs.true.i.i, label %if.else.i.i

land.lhs.true.i.i:                                ; preds = %do.body.i.i
  %i_key.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1
  %9 = load ptr, ptr %i_key.i.i, align 8
  %cmp5.i.i = icmp eq ptr %9, %call
  br i1 %cmp5.i.i, label %luaH_getstr.exit.i, label %if.else.i.i

if.else.i.i:                                      ; preds = %land.lhs.true.i.i, %do.body.i.i
  %next.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1, i32 0, i32 2
  %10 = load ptr, ptr %next.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %10, null
  br i1 %tobool.not.i.i, label %if.else.i, label %do.body.i.i, !llvm.loop !29

luaH_getstr.exit.i:                               ; preds = %land.lhs.true.i.i
  %cmp.not.i = icmp eq ptr %n.0.i.i, @luaO_nilobject_
  br i1 %cmp.not.i, label %if.else.i, label %luaH_setstr.exit

if.else.i:                                        ; preds = %if.else.i.i, %luaH_getstr.exit.i
  store ptr %call, ptr %k.i, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %k.i, i64 0, i32 1
  store i32 4, ptr %tt.i, align 8
  %call1.i = call fastcc ptr @newkey(ptr noundef %0, ptr noundef %2, ptr noundef nonnull %k.i)
  br label %luaH_setstr.exit

luaH_setstr.exit:                                 ; preds = %luaH_getstr.exit.i, %if.else.i
  %retval.0.i = phi ptr [ %call1.i, %if.else.i ], [ %n.0.i.i, %luaH_getstr.exit.i ]
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %k.i)
  %tt = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i, i64 0, i32 1
  %11 = load i32, ptr %tt, align 8
  %cmp = icmp eq i32 %11, 0
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %luaH_setstr.exit
  store i32 1, ptr %retval.0.i, align 8
  store i32 1, ptr %tt, align 8
  %l_G = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %12 = load ptr, ptr %l_G, align 8
  %totalbytes = getelementptr inbounds %struct.global_State, ptr %12, i64 0, i32 14
  %13 = load i64, ptr %totalbytes, align 8
  %GCthreshold = getelementptr inbounds %struct.global_State, ptr %12, i64 0, i32 13
  %14 = load i64, ptr %GCthreshold, align 8
  %cmp5.not = icmp ult i64 %13, %14
  br i1 %cmp5.not, label %if.end7, label %if.then6

if.then6:                                         ; preds = %if.then
  %gcstepmul.i = getelementptr inbounds %struct.global_State, ptr %12, i64 0, i32 18
  %15 = load i32, ptr %gcstepmul.i, align 4
  %mul.i = mul i32 %15, 10
  %conv.i = zext i32 %mul.i to i64
  %cmp.i = icmp eq i32 %mul.i, 0
  %spec.store.select.i = select i1 %cmp.i, i64 9223372036854775806, i64 %conv.i
  %sub.i = sub i64 %13, %14
  %gcdept.i = getelementptr inbounds %struct.global_State, ptr %12, i64 0, i32 16
  %16 = load i64, ptr %gcdept.i, align 8
  %add.i = add i64 %sub.i, %16
  store i64 %add.i, ptr %gcdept.i, align 8
  %gcstate.i = getelementptr inbounds %struct.global_State, ptr %12, i64 0, i32 4
  br label %do.body.i

do.body.i:                                        ; preds = %do.body.i, %if.then6
  %lim.0.i = phi i64 [ %spec.store.select.i, %if.then6 ], [ %sub2.i, %do.body.i ]
  %call.i = tail call fastcc i64 @singlestep(ptr noundef %0)
  %sub2.i = sub nsw i64 %lim.0.i, %call.i
  %17 = load i8, ptr %gcstate.i, align 1
  %cmp4.i = icmp ne i8 %17, 0
  %cmp8.i = icmp sgt i64 %sub2.i, 0
  %or.cond.i = select i1 %cmp4.i, i1 %cmp8.i, i1 false
  br i1 %or.cond.i, label %do.body.i, label %do.end.i, !llvm.loop !6

do.end.i:                                         ; preds = %do.body.i
  br i1 %cmp4.i, label %if.then14.i, label %if.else27.i

if.then14.i:                                      ; preds = %do.end.i
  %18 = load i64, ptr %gcdept.i, align 8
  %cmp16.i = icmp ult i64 %18, 1024
  br i1 %cmp16.i, label %if.then18.i, label %if.else.i9

if.then18.i:                                      ; preds = %if.then14.i
  %19 = load i64, ptr %totalbytes, align 8
  %add20.i = add i64 %19, 1024
  br label %luaC_step.exit

if.else.i9:                                       ; preds = %if.then14.i
  %sub23.i = add i64 %18, -1024
  store i64 %sub23.i, ptr %gcdept.i, align 8
  %20 = load i64, ptr %totalbytes, align 8
  br label %luaC_step.exit

if.else27.i:                                      ; preds = %do.end.i
  %estimate.i = getelementptr inbounds %struct.global_State, ptr %12, i64 0, i32 15
  %21 = load i64, ptr %estimate.i, align 8
  %div.i = udiv i64 %21, 100
  %gcpause.i = getelementptr inbounds %struct.global_State, ptr %12, i64 0, i32 17
  %22 = load i32, ptr %gcpause.i, align 8
  %conv28.i = sext i32 %22 to i64
  %mul29.i = mul i64 %div.i, %conv28.i
  br label %luaC_step.exit

luaC_step.exit:                                   ; preds = %if.then18.i, %if.else.i9, %if.else27.i
  %add20.sink.i = phi i64 [ %add20.i, %if.then18.i ], [ %20, %if.else.i9 ], [ %mul29.i, %if.else27.i ]
  store i64 %add20.sink.i, ptr %GCthreshold, align 8
  br label %if.end7

if.end7:                                          ; preds = %if.then, %luaC_step.exit, %luaH_setstr.exit
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal fastcc void @check_match(ptr noundef %ls, i32 noundef %what, i32 noundef %who, i32 noundef %where) unnamed_addr #0 {
entry:
  %t.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 3
  %0 = load i32, ptr %t.i, align 8
  %cmp.i = icmp eq i32 %0, %what
  %linenumber.i.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 1
  %1 = load i32, ptr %linenumber.i.i, align 4
  br i1 %cmp.i, label %if.then.i, label %if.then

if.then.i:                                        ; preds = %entry
  %lastline.i.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 2
  store i32 %1, ptr %lastline.i.i, align 8
  %lookahead.i.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 4
  %2 = load i32, ptr %lookahead.i.i, align 8
  %cmp.not.i.i = icmp eq i32 %2, 287
  br i1 %cmp.not.i.i, label %if.else.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %if.then.i
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t.i, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i.i, align 8
  br label %if.end5

if.else.i.i:                                      ; preds = %if.then.i
  %seminfo.i.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 3, i32 1
  %call.i.i = tail call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i.i)
  store i32 %call.i.i, ptr %t.i, align 8
  br label %if.end5

if.then:                                          ; preds = %entry
  %cmp = icmp eq i32 %1, %where
  %L.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 6
  %3 = load ptr, ptr %L.i, align 8
  %cmp.i.i = icmp slt i32 %what, 257
  br i1 %cmp, label %if.then1, label %if.else

if.then1:                                         ; preds = %if.then
  br i1 %cmp.i.i, label %if.then.i.i11, label %if.else.i.i10

if.then.i.i11:                                    ; preds = %if.then1
  %call.i.i12 = tail call ptr @__ctype_b_loc() #39
  %4 = load ptr, ptr %call.i.i12, align 8
  %idxprom.i.i = sext i32 %what to i64
  %arrayidx.i.i = getelementptr inbounds i16, ptr %4, i64 %idxprom.i.i
  %5 = load i16, ptr %arrayidx.i.i, align 2
  %6 = and i16 %5, 2
  %tobool.not.i.i = icmp eq i16 %6, 0
  br i1 %tobool.not.i.i, label %cond.false.i.i, label %cond.true.i.i

cond.true.i.i:                                    ; preds = %if.then.i.i11
  %call1.i.i = tail call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %3, ptr noundef nonnull @.str.138, i32 noundef %what)
  br label %luaX_token2str.exit.i

cond.false.i.i:                                   ; preds = %if.then.i.i11
  %call3.i.i = tail call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %3, ptr noundef nonnull @.str.139, i32 noundef %what)
  br label %luaX_token2str.exit.i

if.else.i.i10:                                    ; preds = %if.then1
  %sub.i.i = add nsw i32 %what, -257
  %idxprom4.i.i = zext nneg i32 %sub.i.i to i64
  %arrayidx5.i.i = getelementptr inbounds [32 x ptr], ptr @luaX_tokens, i64 0, i64 %idxprom4.i.i
  %7 = load ptr, ptr %arrayidx5.i.i, align 8
  br label %luaX_token2str.exit.i

luaX_token2str.exit.i:                            ; preds = %if.else.i.i10, %cond.false.i.i, %cond.true.i.i
  %retval.0.i.i = phi ptr [ %7, %if.else.i.i10 ], [ %call1.i.i, %cond.true.i.i ], [ %call3.i.i, %cond.false.i.i ]
  %call1.i = tail call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %3, ptr noundef nonnull @.str.164, ptr noundef %retval.0.i.i)
  %8 = load i32, ptr %t.i, align 8
  tail call fastcc void @luaX_lexerror(ptr noundef nonnull %ls, ptr noundef %call1.i, i32 noundef %8)
  unreachable

if.else:                                          ; preds = %if.then
  br i1 %cmp.i.i, label %if.then.i15, label %if.else.i

if.then.i15:                                      ; preds = %if.else
  %call.i = tail call ptr @__ctype_b_loc() #39
  %9 = load ptr, ptr %call.i, align 8
  %idxprom.i = sext i32 %what to i64
  %arrayidx.i = getelementptr inbounds i16, ptr %9, i64 %idxprom.i
  %10 = load i16, ptr %arrayidx.i, align 2
  %11 = and i16 %10, 2
  %tobool.not.i = icmp eq i16 %11, 0
  br i1 %tobool.not.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %if.then.i15
  %call1.i16 = tail call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %3, ptr noundef nonnull @.str.138, i32 noundef %what)
  br label %luaX_token2str.exit

cond.false.i:                                     ; preds = %if.then.i15
  %call3.i = tail call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %3, ptr noundef nonnull @.str.139, i32 noundef %what)
  br label %luaX_token2str.exit

if.else.i:                                        ; preds = %if.else
  %sub.i = add nsw i32 %what, -257
  %idxprom4.i = zext nneg i32 %sub.i to i64
  %arrayidx5.i = getelementptr inbounds [32 x ptr], ptr @luaX_tokens, i64 0, i64 %idxprom4.i
  %12 = load ptr, ptr %arrayidx5.i, align 8
  br label %luaX_token2str.exit

luaX_token2str.exit:                              ; preds = %cond.true.i, %cond.false.i, %if.else.i
  %retval.0.i14 = phi ptr [ %12, %if.else.i ], [ %call1.i16, %cond.true.i ], [ %call3.i, %cond.false.i ]
  %cmp.i17 = icmp slt i32 %who, 257
  br i1 %cmp.i17, label %if.then.i23, label %if.else.i18

if.then.i23:                                      ; preds = %luaX_token2str.exit
  %call.i24 = tail call ptr @__ctype_b_loc() #39
  %13 = load ptr, ptr %call.i24, align 8
  %idxprom.i25 = sext i32 %who to i64
  %arrayidx.i26 = getelementptr inbounds i16, ptr %13, i64 %idxprom.i25
  %14 = load i16, ptr %arrayidx.i26, align 2
  %15 = and i16 %14, 2
  %tobool.not.i27 = icmp eq i16 %15, 0
  %16 = load ptr, ptr %L.i, align 8
  br i1 %tobool.not.i27, label %cond.false.i31, label %cond.true.i29

cond.true.i29:                                    ; preds = %if.then.i23
  %call1.i30 = tail call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %16, ptr noundef nonnull @.str.138, i32 noundef %who)
  br label %luaX_token2str.exit33

cond.false.i31:                                   ; preds = %if.then.i23
  %call3.i32 = tail call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %16, ptr noundef nonnull @.str.139, i32 noundef %who)
  br label %luaX_token2str.exit33

if.else.i18:                                      ; preds = %luaX_token2str.exit
  %sub.i19 = add nsw i32 %who, -257
  %idxprom4.i20 = zext nneg i32 %sub.i19 to i64
  %arrayidx5.i21 = getelementptr inbounds [32 x ptr], ptr @luaX_tokens, i64 0, i64 %idxprom4.i20
  %17 = load ptr, ptr %arrayidx5.i21, align 8
  br label %luaX_token2str.exit33

luaX_token2str.exit33:                            ; preds = %cond.true.i29, %cond.false.i31, %if.else.i18
  %retval.0.i22 = phi ptr [ %17, %if.else.i18 ], [ %call1.i30, %cond.true.i29 ], [ %call3.i32, %cond.false.i31 ]
  %call4 = tail call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %3, ptr noundef nonnull @.str.163, ptr noundef %retval.0.i14, ptr noundef %retval.0.i22, i32 noundef %where)
  %18 = load i32, ptr %t.i, align 8
  tail call fastcc void @luaX_lexerror(ptr noundef nonnull %ls, ptr noundef %call4, i32 noundef %18)
  unreachable

if.end5:                                          ; preds = %if.else.i.i, %if.then.i.i
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @breakstat(ptr nocapture noundef readonly %ls) unnamed_addr #0 {
entry:
  %fs1 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 5
  %0 = load ptr, ptr %fs1, align 8
  %bl2 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 5
  %bl.020 = load ptr, ptr %bl2, align 8
  %tobool.not21 = icmp eq ptr %bl.020, null
  br i1 %tobool.not21, label %if.then, label %land.rhs

land.rhs:                                         ; preds = %entry, %while.body
  %bl.023 = phi ptr [ %bl.0, %while.body ], [ %bl.020, %entry ]
  %upval.022 = phi i32 [ %or, %while.body ], [ 0, %entry ]
  %isbreakable = getelementptr inbounds %struct.BlockCnt, ptr %bl.023, i64 0, i32 4
  %1 = load i8, ptr %isbreakable, align 2
  %tobool3.not = icmp eq i8 %1, 0
  br i1 %tobool3.not, label %while.body, label %if.end

while.body:                                       ; preds = %land.rhs
  %upval4 = getelementptr inbounds %struct.BlockCnt, ptr %bl.023, i64 0, i32 3
  %2 = load i8, ptr %upval4, align 1
  %conv = zext i8 %2 to i32
  %or = or i32 %upval.022, %conv
  %bl.0 = load ptr, ptr %bl.023, align 8
  %tobool.not = icmp eq ptr %bl.0, null
  br i1 %tobool.not, label %if.then, label %land.rhs, !llvm.loop !112

if.then:                                          ; preds = %while.body, %entry
  %t.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 3
  %3 = load i32, ptr %t.i, align 8
  tail call fastcc void @luaX_lexerror(ptr noundef %ls, ptr noundef nonnull @.str.172, i32 noundef %3)
  unreachable

if.end:                                           ; preds = %land.rhs
  %tobool6.not = icmp eq i32 %upval.022, 0
  br i1 %tobool6.not, label %if.end9, label %if.then7

if.then7:                                         ; preds = %if.end
  %nactvar = getelementptr inbounds %struct.BlockCnt, ptr %bl.023, i64 0, i32 2
  %4 = load i8, ptr %nactvar, align 4
  %conv8 = zext i8 %4 to i32
  %shl1.i = shl nuw nsw i32 %conv8, 6
  %or.i = or disjoint i32 %shl1.i, 35
  %ls.i = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  %5 = load ptr, ptr %ls.i, align 8
  %lastline.i = getelementptr inbounds %struct.LexState, ptr %5, i64 0, i32 2
  %6 = load i32, ptr %lastline.i, align 8
  %call.i = tail call fastcc i32 @luaK_code(ptr noundef %0, i32 noundef %or.i, i32 noundef %6)
  br label %if.end9

if.end9:                                          ; preds = %if.then7, %if.end
  %breaklist = getelementptr inbounds %struct.BlockCnt, ptr %bl.023, i64 0, i32 1
  %jpc1.i = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 8
  %7 = load i32, ptr %jpc1.i, align 8
  store i32 -1, ptr %jpc1.i, align 8
  %ls.i.i = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  %8 = load ptr, ptr %ls.i.i, align 8
  %lastline.i.i = getelementptr inbounds %struct.LexState, ptr %8, i64 0, i32 2
  %9 = load i32, ptr %lastline.i.i, align 8
  %call.i.i = tail call fastcc i32 @luaK_code(ptr noundef %0, i32 noundef 2147450902, i32 noundef %9)
  %cmp.i.i = icmp eq i32 %7, -1
  br i1 %cmp.i.i, label %luaK_jump.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.end9
  %cmp1.i.i = icmp eq i32 %call.i.i, -1
  br i1 %cmp1.i.i, label %if.else.i, label %while.cond.preheader.i.i

while.cond.preheader.i.i:                         ; preds = %if.else.i.i
  %fs.val.i.i = load ptr, ptr %0, align 8
  %10 = getelementptr i8, ptr %fs.val.i.i, i64 24
  %fs.val.val.i.i = load ptr, ptr %10, align 8
  br label %while.cond.i.i

while.cond.i.i:                                   ; preds = %while.cond.i.i, %while.cond.preheader.i.i
  %list.0.i.i = phi i32 [ %add1.i.i.i, %while.cond.i.i ], [ %call.i.i, %while.cond.preheader.i.i ]
  %idxprom.i.i.i = sext i32 %list.0.i.i to i64
  %arrayidx.i.i.i = getelementptr inbounds i32, ptr %fs.val.val.i.i, i64 %idxprom.i.i.i
  %11 = load i32, ptr %arrayidx.i.i.i, align 4
  %shr.i.i.i = lshr i32 %11, 14
  %sub.i.i.i = add nsw i32 %shr.i.i.i, -131071
  %cmp.i.i.i = icmp eq i32 %sub.i.i.i, -1
  %add.i.i.i = add nuw nsw i32 %list.0.i.i, 1
  %add1.i.i.i = add nsw i32 %add.i.i.i, %sub.i.i.i
  %cmp4.not12.i.i = icmp eq i32 %add1.i.i.i, -1
  %cmp4.not.i.i = select i1 %cmp.i.i.i, i1 true, i1 %cmp4.not12.i.i
  br i1 %cmp4.not.i.i, label %while.end.i.i, label %while.cond.i.i, !llvm.loop !94

while.end.i.i:                                    ; preds = %while.cond.i.i
  %add.neg.i.i.i = xor i32 %list.0.i.i, -1
  %sub.i7.i.i = add i32 %7, %add.neg.i.i.i
  %12 = tail call i32 @llvm.abs.i32(i32 %sub.i7.i.i, i1 true)
  %cmp.i8.i.i = icmp ugt i32 %12, 131071
  br i1 %cmp.i8.i.i, label %if.then.i.i.i, label %fixjump.exit.i.i

if.then.i.i.i:                                    ; preds = %while.end.i.i
  %13 = load ptr, ptr %ls.i.i, align 8
  %t.i.i.i.i = getelementptr inbounds %struct.LexState, ptr %13, i64 0, i32 3
  %14 = load i32, ptr %t.i.i.i.i, align 8
  tail call fastcc void @luaX_lexerror(ptr noundef %13, ptr noundef nonnull @.str.148, i32 noundef %14)
  unreachable

fixjump.exit.i.i:                                 ; preds = %while.end.i.i
  %arrayidx.i.i.i.le = getelementptr inbounds i32, ptr %fs.val.val.i.i, i64 %idxprom.i.i.i
  %and.i.i.i = and i32 %11, 16383
  %add1.i11.i.i = shl i32 %sub.i7.i.i, 14
  %shl.i.i.i = add i32 %add1.i11.i.i, 2147467264
  %or.i.i.i = or disjoint i32 %shl.i.i.i, %and.i.i.i
  store i32 %or.i.i.i, ptr %arrayidx.i.i.i.le, align 4
  br label %luaK_jump.exit

luaK_jump.exit:                                   ; preds = %if.end9, %fixjump.exit.i.i
  %cmp.i = icmp eq i32 %call.i.i, -1
  br i1 %cmp.i, label %luaK_concat.exit, label %if.else.i

if.else.i:                                        ; preds = %if.else.i.i, %luaK_jump.exit
  %j.0.i16 = phi i32 [ %call.i.i, %luaK_jump.exit ], [ %7, %if.else.i.i ]
  %15 = load i32, ptr %breaklist, align 4
  %cmp1.i = icmp eq i32 %15, -1
  br i1 %cmp1.i, label %if.then2.i, label %while.cond.preheader.i

while.cond.preheader.i:                           ; preds = %if.else.i
  %fs.val.i = load ptr, ptr %0, align 8
  %16 = getelementptr i8, ptr %fs.val.i, i64 24
  %fs.val.val.i = load ptr, ptr %16, align 8
  br label %while.cond.i

if.then2.i:                                       ; preds = %if.else.i
  store i32 %j.0.i16, ptr %breaklist, align 4
  br label %luaK_concat.exit

while.cond.i:                                     ; preds = %while.cond.i, %while.cond.preheader.i
  %list.0.i = phi i32 [ %add1.i.i, %while.cond.i ], [ %15, %while.cond.preheader.i ]
  %idxprom.i.i = sext i32 %list.0.i to i64
  %arrayidx.i.i = getelementptr inbounds i32, ptr %fs.val.val.i, i64 %idxprom.i.i
  %17 = load i32, ptr %arrayidx.i.i, align 4
  %shr.i.i = lshr i32 %17, 14
  %sub.i.i = add nsw i32 %shr.i.i, -131071
  %cmp.i.i12 = icmp eq i32 %sub.i.i, -1
  %add.i.i = add nuw nsw i32 %list.0.i, 1
  %add1.i.i = add nsw i32 %add.i.i, %sub.i.i
  %cmp4.not12.i = icmp eq i32 %add1.i.i, -1
  %cmp4.not.i = select i1 %cmp.i.i12, i1 true, i1 %cmp4.not12.i
  br i1 %cmp4.not.i, label %while.end.i, label %while.cond.i, !llvm.loop !94

while.end.i:                                      ; preds = %while.cond.i
  %add.neg.i.i = xor i32 %list.0.i, -1
  %sub.i7.i = add i32 %j.0.i16, %add.neg.i.i
  %18 = tail call i32 @llvm.abs.i32(i32 %sub.i7.i, i1 true)
  %cmp.i8.i = icmp ugt i32 %18, 131071
  br i1 %cmp.i8.i, label %if.then.i.i, label %fixjump.exit.i

if.then.i.i:                                      ; preds = %while.end.i
  %19 = load ptr, ptr %ls.i.i, align 8
  %t.i.i.i = getelementptr inbounds %struct.LexState, ptr %19, i64 0, i32 3
  %20 = load i32, ptr %t.i.i.i, align 8
  tail call fastcc void @luaX_lexerror(ptr noundef %19, ptr noundef nonnull @.str.148, i32 noundef %20)
  unreachable

fixjump.exit.i:                                   ; preds = %while.end.i
  %arrayidx.i.i.le = getelementptr inbounds i32, ptr %fs.val.val.i, i64 %idxprom.i.i
  %and.i.i = and i32 %17, 16383
  %add1.i11.i = shl i32 %sub.i7.i, 14
  %shl.i.i = add i32 %add1.i11.i, 2147467264
  %or.i.i = or disjoint i32 %shl.i.i, %and.i.i
  store i32 %or.i.i, ptr %arrayidx.i.i.le, align 4
  br label %luaK_concat.exit

luaK_concat.exit:                                 ; preds = %luaK_jump.exit, %if.then2.i, %fixjump.exit.i
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @checknext(ptr noundef %ls, i32 noundef %c) unnamed_addr #0 {
entry:
  %t.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 3
  %0 = load i32, ptr %t.i, align 8
  %cmp.not.i = icmp eq i32 %0, %c
  br i1 %cmp.not.i, label %check.exit, label %if.then.i

if.then.i:                                        ; preds = %entry
  %L.i.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 6
  %1 = load ptr, ptr %L.i.i, align 8
  %cmp.i.i.i = icmp slt i32 %c, 257
  br i1 %cmp.i.i.i, label %if.then.i.i.i, label %if.else.i.i.i

if.then.i.i.i:                                    ; preds = %if.then.i
  %call.i.i.i = tail call ptr @__ctype_b_loc() #39
  %2 = load ptr, ptr %call.i.i.i, align 8
  %idxprom.i.i.i = sext i32 %c to i64
  %arrayidx.i.i.i = getelementptr inbounds i16, ptr %2, i64 %idxprom.i.i.i
  %3 = load i16, ptr %arrayidx.i.i.i, align 2
  %4 = and i16 %3, 2
  %tobool.not.i.i.i = icmp eq i16 %4, 0
  br i1 %tobool.not.i.i.i, label %cond.false.i.i.i, label %cond.true.i.i.i

cond.true.i.i.i:                                  ; preds = %if.then.i.i.i
  %call1.i.i.i = tail call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %1, ptr noundef nonnull @.str.138, i32 noundef %c)
  br label %luaX_token2str.exit.i.i

cond.false.i.i.i:                                 ; preds = %if.then.i.i.i
  %call3.i.i.i = tail call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %1, ptr noundef nonnull @.str.139, i32 noundef %c)
  br label %luaX_token2str.exit.i.i

if.else.i.i.i:                                    ; preds = %if.then.i
  %sub.i.i.i = add nsw i32 %c, -257
  %idxprom4.i.i.i = zext nneg i32 %sub.i.i.i to i64
  %arrayidx5.i.i.i = getelementptr inbounds [32 x ptr], ptr @luaX_tokens, i64 0, i64 %idxprom4.i.i.i
  %5 = load ptr, ptr %arrayidx5.i.i.i, align 8
  br label %luaX_token2str.exit.i.i

luaX_token2str.exit.i.i:                          ; preds = %if.else.i.i.i, %cond.false.i.i.i, %cond.true.i.i.i
  %retval.0.i.i.i = phi ptr [ %5, %if.else.i.i.i ], [ %call1.i.i.i, %cond.true.i.i.i ], [ %call3.i.i.i, %cond.false.i.i.i ]
  %call1.i.i = tail call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %1, ptr noundef nonnull @.str.164, ptr noundef %retval.0.i.i.i)
  %6 = load i32, ptr %t.i, align 8
  tail call fastcc void @luaX_lexerror(ptr noundef nonnull %ls, ptr noundef %call1.i.i, i32 noundef %6)
  unreachable

check.exit:                                       ; preds = %entry
  %linenumber.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 1
  %7 = load i32, ptr %linenumber.i, align 4
  %lastline.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 2
  store i32 %7, ptr %lastline.i, align 8
  %lookahead.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 4
  %8 = load i32, ptr %lookahead.i, align 8
  %cmp.not.i2 = icmp eq i32 %8, 287
  br i1 %cmp.not.i2, label %if.else.i, label %if.then.i3

if.then.i3:                                       ; preds = %check.exit
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t.i, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i, align 8
  br label %luaX_next.exit

if.else.i:                                        ; preds = %check.exit
  %seminfo.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 3, i32 1
  %call.i = tail call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i)
  store i32 %call.i, ptr %t.i, align 8
  br label %luaX_next.exit

luaX_next.exit:                                   ; preds = %if.then.i3, %if.else.i
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaK_goiftrue(ptr nocapture noundef %fs, ptr nocapture noundef %e) unnamed_addr #0 {
entry:
  tail call fastcc void @luaK_dischargevars(ptr noundef %fs, ptr noundef %e)
  %0 = load i32, ptr %e, align 8
  switch i32 %0, label %sw.default [
    i32 4, label %luaK_concat.exit
    i32 5, label %luaK_concat.exit
    i32 2, label %luaK_concat.exit
    i32 10, label %sw.bb1
  ]

sw.bb1:                                           ; preds = %entry
  %fs.val = load ptr, ptr %fs, align 8
  %1 = getelementptr i8, ptr %e, i64 8
  %e.val = load i32, ptr %1, align 8
  %2 = getelementptr i8, ptr %fs.val, i64 24
  %fs.val.val = load ptr, ptr %2, align 8
  %idxprom.i.i = sext i32 %e.val to i64
  %arrayidx.i.i = getelementptr inbounds i32, ptr %fs.val.val, i64 %idxprom.i.i
  %cmp.i.i = icmp sgt i32 %e.val, 0
  br i1 %cmp.i.i, label %land.lhs.true.i.i, label %if.else.i.i

land.lhs.true.i.i:                                ; preds = %sw.bb1
  %add.ptr.i.i = getelementptr inbounds i32, ptr %arrayidx.i.i, i64 -1
  %3 = load i32, ptr %add.ptr.i.i, align 4
  %and.i.i = and i32 %3, 63
  %idxprom1.i.i = zext nneg i32 %and.i.i to i64
  %4 = lshr i64 266027925503, %idxprom1.i.i
  %5 = and i64 %4, 1
  %tobool.not.not.i.i = icmp eq i64 %5, 0
  br i1 %tobool.not.not.i.i, label %invertjump.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %land.lhs.true.i.i, %sw.bb1
  %.pre.i = load i32, ptr %arrayidx.i.i, align 4
  br label %invertjump.exit

invertjump.exit:                                  ; preds = %land.lhs.true.i.i, %if.else.i.i
  %6 = phi i32 [ %.pre.i, %if.else.i.i ], [ %3, %land.lhs.true.i.i ]
  %retval.0.i.i = phi ptr [ %arrayidx.i.i, %if.else.i.i ], [ %add.ptr.i.i, %land.lhs.true.i.i ]
  %and.i = and i32 %6, -16321
  %7 = and i32 %6, 16320
  %tobool.not.i = icmp eq i32 %7, 0
  %shl.i = select i1 %tobool.not.i, i32 64, i32 0
  %or.i = or disjoint i32 %shl.i, %and.i
  store i32 %or.i, ptr %retval.0.i.i, align 4
  %8 = load i32, ptr %1, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %call = tail call fastcc i32 @jumponcond(ptr noundef %fs, ptr noundef nonnull %e, i32 noundef 0)
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %invertjump.exit
  %pc.0 = phi i32 [ %call, %sw.default ], [ %8, %invertjump.exit ]
  %f = getelementptr inbounds %struct.expdesc, ptr %e, i64 0, i32 3
  %cmp.i = icmp eq i32 %pc.0, -1
  br i1 %cmp.i, label %luaK_concat.exit, label %if.else.i

if.else.i:                                        ; preds = %sw.epilog
  %9 = load i32, ptr %f, align 4
  %cmp1.i = icmp eq i32 %9, -1
  br i1 %cmp1.i, label %if.then2.i, label %while.cond.preheader.i

while.cond.preheader.i:                           ; preds = %if.else.i
  %fs.val.i = load ptr, ptr %fs, align 8
  %10 = getelementptr i8, ptr %fs.val.i, i64 24
  %fs.val.val.i = load ptr, ptr %10, align 8
  br label %while.cond.i

if.then2.i:                                       ; preds = %if.else.i
  store i32 %pc.0, ptr %f, align 4
  br label %luaK_concat.exit

while.cond.i:                                     ; preds = %while.cond.i, %while.cond.preheader.i
  %list.0.i = phi i32 [ %add1.i.i, %while.cond.i ], [ %9, %while.cond.preheader.i ]
  %idxprom.i.i12 = sext i32 %list.0.i to i64
  %arrayidx.i.i13 = getelementptr inbounds i32, ptr %fs.val.val.i, i64 %idxprom.i.i12
  %11 = load i32, ptr %arrayidx.i.i13, align 4
  %shr.i.i = lshr i32 %11, 14
  %sub.i.i = add nsw i32 %shr.i.i, -131071
  %cmp.i.i14 = icmp eq i32 %sub.i.i, -1
  %add.i.i = add nuw nsw i32 %list.0.i, 1
  %add1.i.i = add nsw i32 %add.i.i, %sub.i.i
  %cmp4.not12.i = icmp eq i32 %add1.i.i, -1
  %cmp4.not.i = select i1 %cmp.i.i14, i1 true, i1 %cmp4.not12.i
  br i1 %cmp4.not.i, label %while.end.i, label %while.cond.i, !llvm.loop !94

while.end.i:                                      ; preds = %while.cond.i
  %add.neg.i.i = xor i32 %list.0.i, -1
  %sub.i7.i = add i32 %pc.0, %add.neg.i.i
  %12 = tail call i32 @llvm.abs.i32(i32 %sub.i7.i, i1 true)
  %cmp.i8.i = icmp ugt i32 %12, 131071
  br i1 %cmp.i8.i, label %if.then.i.i, label %fixjump.exit.i

if.then.i.i:                                      ; preds = %while.end.i
  %ls.i.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 3
  %13 = load ptr, ptr %ls.i.i, align 8
  %t.i.i.i = getelementptr inbounds %struct.LexState, ptr %13, i64 0, i32 3
  %14 = load i32, ptr %t.i.i.i, align 8
  tail call fastcc void @luaX_lexerror(ptr noundef %13, ptr noundef nonnull @.str.148, i32 noundef %14)
  unreachable

fixjump.exit.i:                                   ; preds = %while.end.i
  %arrayidx.i.i13.le = getelementptr inbounds i32, ptr %fs.val.val.i, i64 %idxprom.i.i12
  %and.i.i15 = and i32 %11, 16383
  %add1.i11.i = shl i32 %sub.i7.i, 14
  %shl.i.i = add i32 %add1.i11.i, 2147467264
  %or.i.i = or disjoint i32 %shl.i.i, %and.i.i15
  store i32 %or.i.i, ptr %arrayidx.i.i13.le, align 4
  br label %luaK_concat.exit

luaK_concat.exit:                                 ; preds = %entry, %entry, %entry, %sw.epilog, %if.then2.i, %fixjump.exit.i
  %t = getelementptr inbounds %struct.expdesc, ptr %e, i64 0, i32 2
  %15 = load i32, ptr %t, align 8
  %pc.i.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 6
  %16 = load i32, ptr %pc.i.i, align 8
  %lasttarget.i.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 7
  store i32 %16, ptr %lasttarget.i.i, align 4
  %jpc.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 8
  %cmp.i.i16 = icmp eq i32 %15, -1
  br i1 %cmp.i.i16, label %luaK_patchtohere.exit, label %if.else.i.i17

if.else.i.i17:                                    ; preds = %luaK_concat.exit
  %17 = load i32, ptr %jpc.i, align 4
  %cmp1.i.i = icmp eq i32 %17, -1
  br i1 %cmp1.i.i, label %if.then2.i.i, label %while.cond.preheader.i.i

while.cond.preheader.i.i:                         ; preds = %if.else.i.i17
  %fs.val.i.i = load ptr, ptr %fs, align 8
  %18 = getelementptr i8, ptr %fs.val.i.i, i64 24
  %fs.val.val.i.i = load ptr, ptr %18, align 8
  br label %while.cond.i.i

if.then2.i.i:                                     ; preds = %if.else.i.i17
  store i32 %15, ptr %jpc.i, align 4
  br label %luaK_patchtohere.exit

while.cond.i.i:                                   ; preds = %while.cond.i.i, %while.cond.preheader.i.i
  %list.0.i.i = phi i32 [ %add1.i.i.i, %while.cond.i.i ], [ %17, %while.cond.preheader.i.i ]
  %idxprom.i.i.i = sext i32 %list.0.i.i to i64
  %arrayidx.i.i.i = getelementptr inbounds i32, ptr %fs.val.val.i.i, i64 %idxprom.i.i.i
  %19 = load i32, ptr %arrayidx.i.i.i, align 4
  %shr.i.i.i = lshr i32 %19, 14
  %sub.i.i.i = add nsw i32 %shr.i.i.i, -131071
  %cmp.i.i.i = icmp eq i32 %sub.i.i.i, -1
  %add.i.i.i = add nuw nsw i32 %list.0.i.i, 1
  %add1.i.i.i = add nsw i32 %add.i.i.i, %sub.i.i.i
  %cmp4.not12.i.i = icmp eq i32 %add1.i.i.i, -1
  %cmp4.not.i.i = select i1 %cmp.i.i.i, i1 true, i1 %cmp4.not12.i.i
  br i1 %cmp4.not.i.i, label %while.end.i.i, label %while.cond.i.i, !llvm.loop !94

while.end.i.i:                                    ; preds = %while.cond.i.i
  %add.neg.i.i.i = xor i32 %list.0.i.i, -1
  %sub.i7.i.i = add i32 %15, %add.neg.i.i.i
  %20 = tail call i32 @llvm.abs.i32(i32 %sub.i7.i.i, i1 true)
  %cmp.i8.i.i = icmp ugt i32 %20, 131071
  br i1 %cmp.i8.i.i, label %if.then.i.i.i, label %fixjump.exit.i.i

if.then.i.i.i:                                    ; preds = %while.end.i.i
  %ls.i.i.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 3
  %21 = load ptr, ptr %ls.i.i.i, align 8
  %t.i.i.i.i = getelementptr inbounds %struct.LexState, ptr %21, i64 0, i32 3
  %22 = load i32, ptr %t.i.i.i.i, align 8
  tail call fastcc void @luaX_lexerror(ptr noundef %21, ptr noundef nonnull @.str.148, i32 noundef %22)
  unreachable

fixjump.exit.i.i:                                 ; preds = %while.end.i.i
  %arrayidx.i.i.i.le = getelementptr inbounds i32, ptr %fs.val.val.i.i, i64 %idxprom.i.i.i
  %and.i.i.i = and i32 %19, 16383
  %add1.i11.i.i = shl i32 %sub.i7.i.i, 14
  %shl.i.i.i = add i32 %add1.i11.i.i, 2147467264
  %or.i.i.i = or disjoint i32 %shl.i.i.i, %and.i.i.i
  store i32 %or.i.i.i, ptr %arrayidx.i.i.i.le, align 4
  br label %luaK_patchtohere.exit

luaK_patchtohere.exit:                            ; preds = %luaK_concat.exit, %if.then2.i.i, %fixjump.exit.i.i
  store i32 -1, ptr %t, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @subexpr(ptr noundef %ls, ptr noundef %v, i32 noundef %limit) unnamed_addr #0 {
entry:
  %o.i.i = alloca %struct.lua_TValue, align 8
  %new_fs.i = alloca %struct.FuncState, align 8
  %e2.i = alloca %struct.expdesc, align 8
  %v2 = alloca %struct.expdesc, align 8
  %L.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 6
  %0 = load ptr, ptr %L.i, align 8
  %nCcalls.i = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 15
  %1 = load i16, ptr %nCcalls.i, align 8
  %inc.i = add i16 %1, 1
  store i16 %inc.i, ptr %nCcalls.i, align 8
  %cmp.i = icmp ugt i16 %inc.i, 200
  br i1 %cmp.i, label %if.then.i, label %enterlevel.exit

if.then.i:                                        ; preds = %entry
  tail call fastcc void @luaX_lexerror(ptr noundef nonnull %ls, ptr noundef nonnull @.str.146, i32 noundef 0)
  unreachable

enterlevel.exit:                                  ; preds = %entry
  %t = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 3
  %2 = load i32, ptr %t, align 8
  switch i32 %2, label %sw.default.i34 [
    i32 270, label %if.then
    i32 45, label %sw.bb1.i
    i32 35, label %sw.bb2.i
    i32 284, label %sw.bb.i31
    i32 286, label %sw.bb2.i30
    i32 269, label %sw.bb5.i
    i32 275, label %sw.bb6.i
    i32 263, label %sw.bb7.i
    i32 279, label %sw.bb8.i
    i32 123, label %sw.bb13.i
    i32 265, label %sw.bb14.i
  ]

sw.bb1.i:                                         ; preds = %enterlevel.exit
  br label %if.then

sw.bb2.i:                                         ; preds = %enterlevel.exit
  br label %if.then

if.then:                                          ; preds = %enterlevel.exit, %sw.bb2.i, %sw.bb1.i
  %retval.0.i.ph = phi i32 [ 1, %enterlevel.exit ], [ 0, %sw.bb1.i ], [ 2, %sw.bb2.i ]
  %linenumber.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 1
  %3 = load i32, ptr %linenumber.i, align 4
  %lastline.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 2
  store i32 %3, ptr %lastline.i, align 8
  %lookahead.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 4
  %4 = load i32, ptr %lookahead.i, align 8
  %cmp.not.i = icmp eq i32 %4, 287
  br i1 %cmp.not.i, label %if.else.i, label %if.then.i22

if.then.i22:                                      ; preds = %if.then
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i, align 8
  br label %luaX_next.exit

if.else.i:                                        ; preds = %if.then
  %seminfo.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 3, i32 1
  %call.i = tail call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i)
  store i32 %call.i, ptr %t, align 8
  br label %luaX_next.exit

luaX_next.exit:                                   ; preds = %if.then.i22, %if.else.i
  %call1 = tail call fastcc i32 @subexpr(ptr noundef nonnull %ls, ptr noundef %v, i32 noundef 8), !range !93
  %fs = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 5
  %5 = load ptr, ptr %fs, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %e2.i)
  %f.i = getelementptr inbounds %struct.expdesc, ptr %e2.i, i64 0, i32 3
  store i32 -1, ptr %f.i, align 4
  %t.i = getelementptr inbounds %struct.expdesc, ptr %e2.i, i64 0, i32 2
  store i32 -1, ptr %t.i, align 8
  store i32 5, ptr %e2.i, align 8
  %u.i = getelementptr inbounds %struct.expdesc, ptr %e2.i, i64 0, i32 1
  store double 0.000000e+00, ptr %u.i, align 8
  switch i32 %retval.0.i.ph, label %luaK_prefix.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb2.i23
    i32 2, label %sw.bb3.i
  ]

sw.bb.i:                                          ; preds = %luaX_next.exit
  %6 = load i32, ptr %v, align 8
  %cmp.i.i = icmp eq i32 %6, 5
  br i1 %cmp.i.i, label %land.lhs.true.i.i, label %if.then.i24

land.lhs.true.i.i:                                ; preds = %sw.bb.i
  %t.i.i = getelementptr inbounds %struct.expdesc, ptr %v, i64 0, i32 2
  %7 = load i32, ptr %t.i.i, align 8
  %cmp1.i.i = icmp eq i32 %7, -1
  br i1 %cmp1.i.i, label %isnumeral.exit.i, label %if.then.i24

isnumeral.exit.i:                                 ; preds = %land.lhs.true.i.i
  %f.i.i = getelementptr inbounds %struct.expdesc, ptr %v, i64 0, i32 3
  %8 = load i32, ptr %f.i.i, align 4
  %cmp2.i.not.i = icmp eq i32 %8, -1
  br i1 %cmp2.i.not.i, label %if.end.i, label %if.then.i24

if.then.i24:                                      ; preds = %isnumeral.exit.i, %land.lhs.true.i.i, %sw.bb.i
  %call1.i = tail call fastcc i32 @luaK_exp2anyreg(ptr noundef %5, ptr noundef nonnull %v)
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i24, %isnumeral.exit.i
  call fastcc void @codearith(ptr noundef %5, i32 noundef 18, ptr noundef nonnull %v, ptr noundef nonnull %e2.i)
  br label %luaK_prefix.exit

sw.bb2.i23:                                       ; preds = %luaX_next.exit
  tail call fastcc void @luaK_dischargevars(ptr noundef %5, ptr noundef %v)
  %9 = load i32, ptr %v, align 8
  switch i32 %9, label %sw.epilog.i.i [
    i32 1, label %sw.bb.i.i
    i32 3, label %sw.bb.i.i
    i32 4, label %sw.bb2.i.i
    i32 5, label %sw.bb2.i.i
    i32 2, label %sw.bb2.i.i
    i32 10, label %sw.bb4.i.i
    i32 12, label %if.then.i22.i.i
    i32 11, label %if.then.i.i.i
  ]

sw.bb.i.i:                                        ; preds = %sw.bb2.i23, %sw.bb2.i23
  store i32 2, ptr %v, align 8
  br label %sw.epilog.i.i

sw.bb2.i.i:                                       ; preds = %sw.bb2.i23, %sw.bb2.i23, %sw.bb2.i23
  store i32 3, ptr %v, align 8
  br label %sw.epilog.i.i

sw.bb4.i.i:                                       ; preds = %sw.bb2.i23
  %fs.val.i.i = load ptr, ptr %5, align 8
  %10 = getelementptr i8, ptr %v, i64 8
  %e.val.i.i = load i32, ptr %10, align 8
  %11 = getelementptr i8, ptr %fs.val.i.i, i64 24
  %fs.val.val.i.i = load ptr, ptr %11, align 8
  %idxprom.i.i.i.i = sext i32 %e.val.i.i to i64
  %arrayidx.i.i.i.i = getelementptr inbounds i32, ptr %fs.val.val.i.i, i64 %idxprom.i.i.i.i
  %cmp.i.i.i.i = icmp sgt i32 %e.val.i.i, 0
  br i1 %cmp.i.i.i.i, label %land.lhs.true.i.i.i.i, label %if.else.i.i.i.i

land.lhs.true.i.i.i.i:                            ; preds = %sw.bb4.i.i
  %add.ptr.i.i.i.i = getelementptr inbounds i32, ptr %arrayidx.i.i.i.i, i64 -1
  %12 = load i32, ptr %add.ptr.i.i.i.i, align 4
  %and.i.i.i.i = and i32 %12, 63
  %idxprom1.i.i.i.i = zext nneg i32 %and.i.i.i.i to i64
  %13 = lshr i64 266027925503, %idxprom1.i.i.i.i
  %14 = and i64 %13, 1
  %tobool.not.not.i.i.i.i = icmp eq i64 %14, 0
  br i1 %tobool.not.not.i.i.i.i, label %invertjump.exit.i.i, label %if.else.i.i.i.i

if.else.i.i.i.i:                                  ; preds = %land.lhs.true.i.i.i.i, %sw.bb4.i.i
  %.pre.i.i.i = load i32, ptr %arrayidx.i.i.i.i, align 4
  br label %invertjump.exit.i.i

invertjump.exit.i.i:                              ; preds = %if.else.i.i.i.i, %land.lhs.true.i.i.i.i
  %15 = phi i32 [ %.pre.i.i.i, %if.else.i.i.i.i ], [ %12, %land.lhs.true.i.i.i.i ]
  %retval.0.i.i.i.i = phi ptr [ %arrayidx.i.i.i.i, %if.else.i.i.i.i ], [ %add.ptr.i.i.i.i, %land.lhs.true.i.i.i.i ]
  %and.i.i.i = and i32 %15, -16321
  %16 = and i32 %15, 16320
  %tobool.not.i.i.i = icmp eq i32 %16, 0
  %shl.i.i.i = select i1 %tobool.not.i.i.i, i32 64, i32 0
  %or.i.i.i = or disjoint i32 %shl.i.i.i, %and.i.i.i
  store i32 %or.i.i.i, ptr %retval.0.i.i.i.i, align 4
  br label %sw.epilog.i.i

if.then.i.i.i:                                    ; preds = %sw.bb2.i23
  %freereg.i.i.i.i.i = getelementptr inbounds %struct.FuncState, ptr %5, i64 0, i32 9
  %17 = load i32, ptr %freereg.i.i.i.i.i, align 4
  %add.i.i.i.i.i = add nsw i32 %17, 1
  %18 = load ptr, ptr %5, align 8
  %maxstacksize.i.i.i.i.i = getelementptr inbounds %struct.Proto, ptr %18, i64 0, i32 22
  %19 = load i8, ptr %maxstacksize.i.i.i.i.i, align 1
  %conv.i.i.i.i.i = zext i8 %19 to i32
  %cmp.i.i.not.i.i.i = icmp slt i32 %17, %conv.i.i.i.i.i
  br i1 %cmp.i.i.not.i.i.i, label %discharge2anyreg.exit.i.i, label %if.then.i.i.i.i.i

if.then.i.i.i.i.i:                                ; preds = %if.then.i.i.i
  %cmp2.i.i.i.i.i = icmp sgt i32 %17, 248
  br i1 %cmp2.i.i.i.i.i, label %if.then4.i.i.i.i.i, label %if.end.i.i.i.i.i

if.then4.i.i.i.i.i:                               ; preds = %if.then.i.i.i.i.i
  %ls.i.i.i.i.i = getelementptr inbounds %struct.FuncState, ptr %5, i64 0, i32 3
  %20 = load ptr, ptr %ls.i.i.i.i.i, align 8
  %t.i.i.i.i.i.i = getelementptr inbounds %struct.LexState, ptr %20, i64 0, i32 3
  %21 = load i32, ptr %t.i.i.i.i.i.i, align 8
  tail call fastcc void @luaX_lexerror(ptr noundef %20, ptr noundef nonnull @.str.150, i32 noundef %21)
  unreachable

if.end.i.i.i.i.i:                                 ; preds = %if.then.i.i.i.i.i
  %conv5.i.i.i.i.i = trunc i32 %add.i.i.i.i.i to i8
  store i8 %conv5.i.i.i.i.i, ptr %maxstacksize.i.i.i.i.i, align 1
  %.pre.i.i.i.i = load i32, ptr %freereg.i.i.i.i.i, align 4
  %.pre3.i.i.i.i = add nsw i32 %.pre.i.i.i.i, 1
  br label %discharge2anyreg.exit.i.i

discharge2anyreg.exit.i.i:                        ; preds = %if.end.i.i.i.i.i, %if.then.i.i.i
  %add.pre-phi.i.i.i.i = phi i32 [ %add.i.i.i.i.i, %if.then.i.i.i ], [ %.pre3.i.i.i.i, %if.end.i.i.i.i.i ]
  store i32 %add.pre-phi.i.i.i.i, ptr %freereg.i.i.i.i.i, align 4
  %sub.i.i.i = add nsw i32 %add.pre-phi.i.i.i.i, -1
  tail call fastcc void @discharge2reg(ptr noundef nonnull %5, ptr noundef nonnull %v, i32 noundef %sub.i.i.i)
  %.pre.i.i = load i32, ptr %v, align 8
  %22 = icmp eq i32 %.pre.i.i, 12
  br i1 %22, label %if.then.i22.i.i, label %freeexp.exit.i.i

if.then.i22.i.i:                                  ; preds = %discharge2anyreg.exit.i.i, %sw.bb2.i23
  %u.i.i.i = getelementptr inbounds %struct.expdesc, ptr %v, i64 0, i32 1
  %23 = load i32, ptr %u.i.i.i, align 8
  %and.i.i23.i.i = and i32 %23, 256
  %tobool.not.i.i.i.i = icmp eq i32 %and.i.i23.i.i, 0
  br i1 %tobool.not.i.i.i.i, label %land.lhs.true.i.i24.i.i, label %freeexp.exit.i.i

land.lhs.true.i.i24.i.i:                          ; preds = %if.then.i22.i.i
  %nactvar.i.i.i.i = getelementptr inbounds %struct.FuncState, ptr %5, i64 0, i32 13
  %24 = load i8, ptr %nactvar.i.i.i.i, align 2
  %conv.i.i.i.i = zext i8 %24 to i32
  %cmp.not.i.i.i.i = icmp slt i32 %23, %conv.i.i.i.i
  br i1 %cmp.not.i.i.i.i, label %freeexp.exit.i.i, label %if.then.i.i.i.i

if.then.i.i.i.i:                                  ; preds = %land.lhs.true.i.i24.i.i
  %freereg.i.i.i.i = getelementptr inbounds %struct.FuncState, ptr %5, i64 0, i32 9
  %25 = load i32, ptr %freereg.i.i.i.i, align 4
  %dec.i.i.i.i = add nsw i32 %25, -1
  store i32 %dec.i.i.i.i, ptr %freereg.i.i.i.i, align 4
  br label %freeexp.exit.i.i

freeexp.exit.i.i:                                 ; preds = %if.then.i.i.i.i, %land.lhs.true.i.i24.i.i, %if.then.i22.i.i, %discharge2anyreg.exit.i.i
  %u.i.i = getelementptr inbounds %struct.expdesc, ptr %v, i64 0, i32 1
  %26 = load i32, ptr %u.i.i, align 8
  %shl2.i.i.i = shl i32 %26, 23
  %or3.i.i.i = or disjoint i32 %shl2.i.i.i, 19
  %ls.i.i.i = getelementptr inbounds %struct.FuncState, ptr %5, i64 0, i32 3
  %27 = load ptr, ptr %ls.i.i.i, align 8
  %lastline.i.i.i = getelementptr inbounds %struct.LexState, ptr %27, i64 0, i32 2
  %28 = load i32, ptr %lastline.i.i.i, align 8
  %call.i.i.i = tail call fastcc i32 @luaK_code(ptr noundef %5, i32 noundef %or3.i.i.i, i32 noundef %28)
  store i32 %call.i.i.i, ptr %u.i.i, align 8
  store i32 11, ptr %v, align 8
  br label %sw.epilog.i.i

sw.epilog.i.i:                                    ; preds = %freeexp.exit.i.i, %invertjump.exit.i.i, %sw.bb2.i.i, %sw.bb.i.i, %sw.bb2.i23
  %f.i10.i = getelementptr inbounds %struct.expdesc, ptr %v, i64 0, i32 3
  %29 = load i32, ptr %f.i10.i, align 4
  %t.i11.i = getelementptr inbounds %struct.expdesc, ptr %v, i64 0, i32 2
  %30 = load i32, ptr %t.i11.i, align 8
  store i32 %30, ptr %f.i10.i, align 4
  store i32 %29, ptr %t.i11.i, align 8
  %cmp.not6.i.i.i = icmp eq i32 %30, -1
  br i1 %cmp.not6.i.i.i, label %removevalues.exit.i.i, label %for.body.preheader.i.i.i

for.body.preheader.i.i.i:                         ; preds = %sw.epilog.i.i
  %fs.val4.pre.i.i.i = load ptr, ptr %5, align 8
  %.phi.trans.insert.i.i.i = getelementptr i8, ptr %fs.val4.pre.i.i.i, i64 24
  %fs.val4.val.pre.i.i.i = load ptr, ptr %.phi.trans.insert.i.i.i, align 8
  br label %for.body.i.i.i

for.body.i.i.i:                                   ; preds = %patchtestreg.exit.i.i.i, %for.body.preheader.i.i.i
  %fs.val.val13.i.i.i = phi ptr [ %fs.val.val.i.i.i, %patchtestreg.exit.i.i.i ], [ %fs.val4.val.pre.i.i.i, %for.body.preheader.i.i.i ]
  %list.addr.07.i.i.i = phi i32 [ %add1.i.i.i.i, %patchtestreg.exit.i.i.i ], [ %30, %for.body.preheader.i.i.i ]
  %idxprom.i.i.i.i.i = sext i32 %list.addr.07.i.i.i to i64
  %arrayidx.i.i.i.i.i = getelementptr inbounds i32, ptr %fs.val.val13.i.i.i, i64 %idxprom.i.i.i.i.i
  %cmp.i.i.i.i.i = icmp sgt i32 %list.addr.07.i.i.i, 0
  br i1 %cmp.i.i.i.i.i, label %land.lhs.true.i.i.i.i.i, label %if.else.i.i.i.i.i

land.lhs.true.i.i.i.i.i:                          ; preds = %for.body.i.i.i
  %add.ptr.i.i.i.i.i = getelementptr inbounds i32, ptr %arrayidx.i.i.i.i.i, i64 -1
  %31 = load i32, ptr %add.ptr.i.i.i.i.i, align 4
  %and.i.i.i.i.i = and i32 %31, 63
  %idxprom1.i.i.i.i.i = zext nneg i32 %and.i.i.i.i.i to i64
  %32 = lshr i64 266027925503, %idxprom1.i.i.i.i.i
  %33 = and i64 %32, 1
  %tobool.not.not.i.i.i.i.i = icmp eq i64 %33, 0
  br i1 %tobool.not.not.i.i.i.i.i, label %getjumpcontrol.exit.i.i.i.i, label %if.else.i.i.i.i.i

if.else.i.i.i.i.i:                                ; preds = %land.lhs.true.i.i.i.i.i, %for.body.i.i.i
  %.pre.i.i25.i.i = load i32, ptr %arrayidx.i.i.i.i.i, align 4
  br label %getjumpcontrol.exit.i.i.i.i

getjumpcontrol.exit.i.i.i.i:                      ; preds = %if.else.i.i.i.i.i, %land.lhs.true.i.i.i.i.i
  %34 = phi i32 [ %.pre.i.i25.i.i, %if.else.i.i.i.i.i ], [ %31, %land.lhs.true.i.i.i.i.i ]
  %retval.0.i.i.i.i.i = phi ptr [ %arrayidx.i.i.i.i.i, %if.else.i.i.i.i.i ], [ %add.ptr.i.i.i.i.i, %land.lhs.true.i.i.i.i.i ]
  %and.i.i26.i.i = and i32 %34, 63
  %cmp.not.i.i27.i.i = icmp eq i32 %and.i.i26.i.i, 27
  br i1 %cmp.not.i.i27.i.i, label %if.end.i.i.i.i, label %patchtestreg.exit.i.i.i

if.end.i.i.i.i:                                   ; preds = %getjumpcontrol.exit.i.i.i.i
  %35 = lshr i32 %34, 17
  %shl10.i.i.i.i = and i32 %35, 32704
  %or11.i.i.i.i = and i32 %34, 8372250
  %or16.i.i.i.i = or i32 %shl10.i.i.i.i, %or11.i.i.i.i
  store i32 %or16.i.i.i.i, ptr %retval.0.i.i.i.i.i, align 4
  %fs.val.pre.i.i.i = load ptr, ptr %5, align 8
  %.phi.trans.insert12.i.i.i = getelementptr i8, ptr %fs.val.pre.i.i.i, i64 24
  %fs.val.val.pre.i.i.i = load ptr, ptr %.phi.trans.insert12.i.i.i, align 8
  br label %patchtestreg.exit.i.i.i

patchtestreg.exit.i.i.i:                          ; preds = %if.end.i.i.i.i, %getjumpcontrol.exit.i.i.i.i
  %fs.val.val.i.i.i = phi ptr [ %fs.val.val13.i.i.i, %getjumpcontrol.exit.i.i.i.i ], [ %fs.val.val.pre.i.i.i, %if.end.i.i.i.i ]
  %arrayidx.i.i28.i.i = getelementptr inbounds i32, ptr %fs.val.val.i.i.i, i64 %idxprom.i.i.i.i.i
  %36 = load i32, ptr %arrayidx.i.i28.i.i, align 4
  %shr.i.i.i.i = lshr i32 %36, 14
  %sub.i.i.i.i = add nsw i32 %shr.i.i.i.i, -131071
  %cmp.i.i29.i.i = icmp eq i32 %sub.i.i.i.i, -1
  %add.i.i.i.i = add nuw nsw i32 %list.addr.07.i.i.i, 1
  %add1.i.i.i.i = add nsw i32 %add.i.i.i.i, %sub.i.i.i.i
  %cmp.not15.i.i.i = icmp eq i32 %add1.i.i.i.i, -1
  %cmp.not.i30.i.i = select i1 %cmp.i.i29.i.i, i1 true, i1 %cmp.not15.i.i.i
  br i1 %cmp.not.i30.i.i, label %removevalues.exitthread-pre-split.i.i, label %for.body.i.i.i

removevalues.exitthread-pre-split.i.i:            ; preds = %patchtestreg.exit.i.i.i
  %.pr.i.i = load i32, ptr %t.i11.i, align 8
  br label %removevalues.exit.i.i

removevalues.exit.i.i:                            ; preds = %removevalues.exitthread-pre-split.i.i, %sw.epilog.i.i
  %37 = phi i32 [ %.pr.i.i, %removevalues.exitthread-pre-split.i.i ], [ %29, %sw.epilog.i.i ]
  %cmp.not6.i31.i.i = icmp eq i32 %37, -1
  br i1 %cmp.not6.i31.i.i, label %luaK_prefix.exit, label %for.body.preheader.i32.i.i

for.body.preheader.i32.i.i:                       ; preds = %removevalues.exit.i.i
  %fs.val4.pre.i33.i.i = load ptr, ptr %5, align 8
  %.phi.trans.insert.i34.i.i = getelementptr i8, ptr %fs.val4.pre.i33.i.i, i64 24
  %fs.val4.val.pre.i35.i.i = load ptr, ptr %.phi.trans.insert.i34.i.i, align 8
  br label %for.body.i36.i.i

for.body.i36.i.i:                                 ; preds = %patchtestreg.exit.i48.i.i, %for.body.preheader.i32.i.i
  %fs.val.val13.i37.i.i = phi ptr [ %fs.val.val.i49.i.i, %patchtestreg.exit.i48.i.i ], [ %fs.val4.val.pre.i35.i.i, %for.body.preheader.i32.i.i ]
  %list.addr.07.i38.i.i = phi i32 [ %add1.i.i55.i.i, %patchtestreg.exit.i48.i.i ], [ %37, %for.body.preheader.i32.i.i ]
  %idxprom.i.i.i39.i.i = sext i32 %list.addr.07.i38.i.i to i64
  %arrayidx.i.i.i40.i.i = getelementptr inbounds i32, ptr %fs.val.val13.i37.i.i, i64 %idxprom.i.i.i39.i.i
  %cmp.i.i.i41.i.i = icmp sgt i32 %list.addr.07.i38.i.i, 0
  br i1 %cmp.i.i.i41.i.i, label %land.lhs.true.i.i.i65.i.i, label %if.else.i.i.i42.i.i

land.lhs.true.i.i.i65.i.i:                        ; preds = %for.body.i36.i.i
  %add.ptr.i.i.i66.i.i = getelementptr inbounds i32, ptr %arrayidx.i.i.i40.i.i, i64 -1
  %38 = load i32, ptr %add.ptr.i.i.i66.i.i, align 4
  %and.i.i.i67.i.i = and i32 %38, 63
  %idxprom1.i.i.i68.i.i = zext nneg i32 %and.i.i.i67.i.i to i64
  %39 = lshr i64 266027925503, %idxprom1.i.i.i68.i.i
  %40 = and i64 %39, 1
  %tobool.not.not.i.i.i69.i.i = icmp eq i64 %40, 0
  br i1 %tobool.not.not.i.i.i69.i.i, label %getjumpcontrol.exit.i.i44.i.i, label %if.else.i.i.i42.i.i

if.else.i.i.i42.i.i:                              ; preds = %land.lhs.true.i.i.i65.i.i, %for.body.i36.i.i
  %.pre.i.i43.i.i = load i32, ptr %arrayidx.i.i.i40.i.i, align 4
  br label %getjumpcontrol.exit.i.i44.i.i

getjumpcontrol.exit.i.i44.i.i:                    ; preds = %if.else.i.i.i42.i.i, %land.lhs.true.i.i.i65.i.i
  %41 = phi i32 [ %.pre.i.i43.i.i, %if.else.i.i.i42.i.i ], [ %38, %land.lhs.true.i.i.i65.i.i ]
  %retval.0.i.i.i45.i.i = phi ptr [ %arrayidx.i.i.i40.i.i, %if.else.i.i.i42.i.i ], [ %add.ptr.i.i.i66.i.i, %land.lhs.true.i.i.i65.i.i ]
  %and.i.i46.i.i = and i32 %41, 63
  %cmp.not.i.i47.i.i = icmp eq i32 %and.i.i46.i.i, 27
  br i1 %cmp.not.i.i47.i.i, label %if.end.i.i58.i.i, label %patchtestreg.exit.i48.i.i

if.end.i.i58.i.i:                                 ; preds = %getjumpcontrol.exit.i.i44.i.i
  %42 = lshr i32 %41, 17
  %shl10.i.i59.i.i = and i32 %42, 32704
  %or11.i.i60.i.i = and i32 %41, 8372250
  %or16.i.i61.i.i = or i32 %shl10.i.i59.i.i, %or11.i.i60.i.i
  store i32 %or16.i.i61.i.i, ptr %retval.0.i.i.i45.i.i, align 4
  %fs.val.pre.i62.i.i = load ptr, ptr %5, align 8
  %.phi.trans.insert12.i63.i.i = getelementptr i8, ptr %fs.val.pre.i62.i.i, i64 24
  %fs.val.val.pre.i64.i.i = load ptr, ptr %.phi.trans.insert12.i63.i.i, align 8
  br label %patchtestreg.exit.i48.i.i

patchtestreg.exit.i48.i.i:                        ; preds = %if.end.i.i58.i.i, %getjumpcontrol.exit.i.i44.i.i
  %fs.val.val.i49.i.i = phi ptr [ %fs.val.val13.i37.i.i, %getjumpcontrol.exit.i.i44.i.i ], [ %fs.val.val.pre.i64.i.i, %if.end.i.i58.i.i ]
  %arrayidx.i.i50.i.i = getelementptr inbounds i32, ptr %fs.val.val.i49.i.i, i64 %idxprom.i.i.i39.i.i
  %43 = load i32, ptr %arrayidx.i.i50.i.i, align 4
  %shr.i.i51.i.i = lshr i32 %43, 14
  %sub.i.i52.i.i = add nsw i32 %shr.i.i51.i.i, -131071
  %cmp.i.i53.i.i = icmp eq i32 %sub.i.i52.i.i, -1
  %add.i.i54.i.i = add nuw nsw i32 %list.addr.07.i38.i.i, 1
  %add1.i.i55.i.i = add nsw i32 %add.i.i54.i.i, %sub.i.i52.i.i
  %cmp.not15.i56.i.i = icmp eq i32 %add1.i.i55.i.i, -1
  %cmp.not.i57.i.i = select i1 %cmp.i.i53.i.i, i1 true, i1 %cmp.not15.i56.i.i
  br i1 %cmp.not.i57.i.i, label %luaK_prefix.exit, label %for.body.i36.i.i

sw.bb3.i:                                         ; preds = %luaX_next.exit
  %call4.i = tail call fastcc i32 @luaK_exp2anyreg(ptr noundef %5, ptr noundef %v)
  call fastcc void @codearith(ptr noundef %5, i32 noundef 20, ptr noundef %v, ptr noundef nonnull %e2.i)
  br label %luaK_prefix.exit

luaK_prefix.exit:                                 ; preds = %patchtestreg.exit.i48.i.i, %luaX_next.exit, %if.end.i, %removevalues.exit.i.i, %sw.bb3.i
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %e2.i)
  br label %if.endthread-pre-split

sw.bb.i31:                                        ; preds = %enterlevel.exit
  %t.i202 = getelementptr inbounds %struct.expdesc, ptr %v, i64 0, i32 2
  store i32 -1, ptr %t.i202, align 8
  %f.i203 = getelementptr inbounds %struct.expdesc, ptr %v, i64 0, i32 3
  store i32 -1, ptr %f.i203, align 4
  store i32 5, ptr %v, align 8
  %u.i204 = getelementptr inbounds %struct.expdesc, ptr %v, i64 0, i32 1
  store i32 0, ptr %u.i204, align 8
  %seminfo.i32 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 3, i32 1
  %44 = load double, ptr %seminfo.i32, align 8
  store double %44, ptr %u.i204, align 8
  br label %sw.epilog.i

sw.bb2.i30:                                       ; preds = %enterlevel.exit
  %seminfo4.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 3, i32 1
  %45 = load ptr, ptr %seminfo4.i, align 8
  %46 = getelementptr i8, ptr %ls, i64 48
  %ls.val.i = load ptr, ptr %46, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %o.i.i)
  store ptr %45, ptr %o.i.i, align 8
  %tt.i.i = getelementptr inbounds %struct.lua_TValue, ptr %o.i.i, i64 0, i32 1
  store i32 4, ptr %tt.i.i, align 8
  %call.i.i198 = call fastcc i32 @addk(ptr noundef %ls.val.i, ptr noundef nonnull %o.i.i, ptr noundef nonnull %o.i.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %o.i.i)
  %t.i.i199 = getelementptr inbounds %struct.expdesc, ptr %v, i64 0, i32 2
  store i32 -1, ptr %t.i.i199, align 8
  %f.i.i200 = getelementptr inbounds %struct.expdesc, ptr %v, i64 0, i32 3
  store i32 -1, ptr %f.i.i200, align 4
  store i32 4, ptr %v, align 8
  %u.i.i201 = getelementptr inbounds %struct.expdesc, ptr %v, i64 0, i32 1
  store i32 %call.i.i198, ptr %u.i.i201, align 8
  br label %sw.epilog.i

sw.bb5.i:                                         ; preds = %enterlevel.exit
  %t.i195 = getelementptr inbounds %struct.expdesc, ptr %v, i64 0, i32 2
  store i32 -1, ptr %t.i195, align 8
  %f.i196 = getelementptr inbounds %struct.expdesc, ptr %v, i64 0, i32 3
  store i32 -1, ptr %f.i196, align 4
  store i32 1, ptr %v, align 8
  %u.i197 = getelementptr inbounds %struct.expdesc, ptr %v, i64 0, i32 1
  store i32 0, ptr %u.i197, align 8
  br label %sw.epilog.i

sw.bb6.i:                                         ; preds = %enterlevel.exit
  %t.i192 = getelementptr inbounds %struct.expdesc, ptr %v, i64 0, i32 2
  store i32 -1, ptr %t.i192, align 8
  %f.i193 = getelementptr inbounds %struct.expdesc, ptr %v, i64 0, i32 3
  store i32 -1, ptr %f.i193, align 4
  store i32 2, ptr %v, align 8
  %u.i194 = getelementptr inbounds %struct.expdesc, ptr %v, i64 0, i32 1
  store i32 0, ptr %u.i194, align 8
  br label %sw.epilog.i

sw.bb7.i:                                         ; preds = %enterlevel.exit
  %t.i189 = getelementptr inbounds %struct.expdesc, ptr %v, i64 0, i32 2
  store i32 -1, ptr %t.i189, align 8
  %f.i190 = getelementptr inbounds %struct.expdesc, ptr %v, i64 0, i32 3
  store i32 -1, ptr %f.i190, align 4
  store i32 3, ptr %v, align 8
  %u.i191 = getelementptr inbounds %struct.expdesc, ptr %v, i64 0, i32 1
  store i32 0, ptr %u.i191, align 8
  br label %sw.epilog.i

sw.bb8.i:                                         ; preds = %enterlevel.exit
  %fs9.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 5
  %47 = load ptr, ptr %fs9.i, align 8
  %48 = load ptr, ptr %47, align 8
  %is_vararg.i = getelementptr inbounds %struct.Proto, ptr %48, i64 0, i32 21
  %49 = load i8, ptr %is_vararg.i, align 2
  %tobool.not.i = icmp eq i8 %49, 0
  br i1 %tobool.not.i, label %if.then.i29, label %if.end.i27

if.then.i29:                                      ; preds = %sw.bb8.i
  tail call fastcc void @luaX_lexerror(ptr noundef nonnull %ls, ptr noundef nonnull @.str.151, i32 noundef 279)
  unreachable

if.end.i27:                                       ; preds = %sw.bb8.i
  %50 = and i8 %49, -5
  store i8 %50, ptr %is_vararg.i, align 2
  %ls.i = getelementptr inbounds %struct.FuncState, ptr %47, i64 0, i32 3
  %51 = load ptr, ptr %ls.i, align 8
  %lastline.i186 = getelementptr inbounds %struct.LexState, ptr %51, i64 0, i32 2
  %52 = load i32, ptr %lastline.i186, align 8
  %call.i187 = tail call fastcc i32 @luaK_code(ptr noundef nonnull %47, i32 noundef 8388645, i32 noundef %52)
  %t.i183 = getelementptr inbounds %struct.expdesc, ptr %v, i64 0, i32 2
  store i32 -1, ptr %t.i183, align 8
  %f.i184 = getelementptr inbounds %struct.expdesc, ptr %v, i64 0, i32 3
  store i32 -1, ptr %f.i184, align 4
  store i32 14, ptr %v, align 8
  %u.i185 = getelementptr inbounds %struct.expdesc, ptr %v, i64 0, i32 1
  store i32 %call.i187, ptr %u.i185, align 8
  br label %sw.epilog.i

sw.bb13.i:                                        ; preds = %enterlevel.exit
  tail call fastcc void @constructor(ptr noundef nonnull %ls, ptr noundef %v)
  br label %if.endthread-pre-split

sw.bb14.i:                                        ; preds = %enterlevel.exit
  %linenumber.i172 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 1
  %53 = load i32, ptr %linenumber.i172, align 4
  %lastline.i173 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 2
  store i32 %53, ptr %lastline.i173, align 8
  %lookahead.i174 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 4
  %54 = load i32, ptr %lookahead.i174, align 8
  %cmp.not.i175 = icmp eq i32 %54, 287
  br i1 %cmp.not.i175, label %if.else.i179, label %if.then.i177

if.then.i177:                                     ; preds = %sw.bb14.i
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i174, i64 16, i1 false)
  store i32 287, ptr %lookahead.i174, align 8
  br label %luaX_next.exit182

if.else.i179:                                     ; preds = %sw.bb14.i
  %seminfo.i180 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 3, i32 1
  %call.i181 = tail call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i180)
  store i32 %call.i181, ptr %t, align 8
  %.pre = load i32, ptr %linenumber.i172, align 4
  br label %luaX_next.exit182

luaX_next.exit182:                                ; preds = %if.then.i177, %if.else.i179
  %55 = phi i32 [ %53, %if.then.i177 ], [ %.pre, %if.else.i179 ]
  call void @llvm.lifetime.start.p0(i64 600, ptr nonnull %new_fs.i)
  call fastcc void @open_func(ptr noundef nonnull %ls, ptr noundef nonnull %new_fs.i)
  %56 = load ptr, ptr %new_fs.i, align 8
  %linedefined.i = getelementptr inbounds %struct.Proto, ptr %56, i64 0, i32 16
  store i32 %55, ptr %linedefined.i, align 8
  call fastcc void @checknext(ptr noundef nonnull %ls, i32 noundef 40)
  call fastcc void @parlist(ptr noundef nonnull %ls)
  call fastcc void @checknext(ptr noundef nonnull %ls, i32 noundef 41)
  call fastcc void @chunk(ptr noundef nonnull %ls)
  %57 = load i32, ptr %linenumber.i172, align 4
  %58 = load ptr, ptr %new_fs.i, align 8
  %lastlinedefined.i = getelementptr inbounds %struct.Proto, ptr %58, i64 0, i32 17
  store i32 %57, ptr %lastlinedefined.i, align 4
  call fastcc void @check_match(ptr noundef nonnull %ls, i32 noundef 262, i32 noundef 265, i32 noundef %55)
  call fastcc void @close_func(ptr noundef nonnull %ls)
  call fastcc void @pushclosure(ptr noundef nonnull %ls, ptr noundef nonnull %new_fs.i, ptr noundef %v)
  call void @llvm.lifetime.end.p0(i64 600, ptr nonnull %new_fs.i)
  br label %if.endthread-pre-split

sw.default.i34:                                   ; preds = %enterlevel.exit
  tail call fastcc void @primaryexp(ptr noundef nonnull %ls, ptr noundef %v)
  br label %if.endthread-pre-split

sw.epilog.i:                                      ; preds = %if.end.i27, %sw.bb7.i, %sw.bb6.i, %sw.bb5.i, %sw.bb2.i30, %sw.bb.i31
  %linenumber.i159 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 1
  %59 = load i32, ptr %linenumber.i159, align 4
  %lastline.i160 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 2
  store i32 %59, ptr %lastline.i160, align 8
  %lookahead.i161 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 4
  %60 = load i32, ptr %lookahead.i161, align 8
  %cmp.not.i162 = icmp eq i32 %60, 287
  br i1 %cmp.not.i162, label %if.else.i166, label %if.then.i164

if.then.i164:                                     ; preds = %sw.epilog.i
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i161, i64 16, i1 false)
  store i32 287, ptr %lookahead.i161, align 8
  br label %if.endthread-pre-split

if.else.i166:                                     ; preds = %sw.epilog.i
  %seminfo.i167 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 3, i32 1
  %call.i168 = tail call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i167)
  store i32 %call.i168, ptr %t, align 8
  br label %if.end

if.endthread-pre-split:                           ; preds = %luaK_prefix.exit, %if.then.i164, %sw.bb13.i, %luaX_next.exit182, %sw.default.i34
  %.pr = load i32, ptr %t, align 8
  br label %if.end

if.end:                                           ; preds = %if.endthread-pre-split, %if.else.i166
  %61 = phi i32 [ %.pr, %if.endthread-pre-split ], [ %call.i168, %if.else.i166 ]
  switch i32 %61, label %while.end [
    i32 43, label %land.rhs.lr.ph
    i32 45, label %sw.bb1.i44
    i32 42, label %sw.bb2.i43
    i32 47, label %sw.bb3.i42
    i32 37, label %sw.bb4.i
    i32 94, label %sw.bb5.i41
    i32 278, label %sw.bb6.i40
    i32 283, label %sw.bb7.i39
    i32 280, label %sw.bb8.i38
    i32 60, label %sw.bb9.i
    i32 282, label %sw.bb10.i
    i32 62, label %sw.bb11.i
    i32 281, label %sw.bb12.i
    i32 257, label %sw.bb13.i37
    i32 271, label %sw.bb14.i35
  ]

sw.bb1.i44:                                       ; preds = %if.end
  br label %land.rhs.lr.ph

sw.bb2.i43:                                       ; preds = %if.end
  br label %land.rhs.lr.ph

sw.bb3.i42:                                       ; preds = %if.end
  br label %land.rhs.lr.ph

sw.bb4.i:                                         ; preds = %if.end
  br label %land.rhs.lr.ph

sw.bb5.i41:                                       ; preds = %if.end
  br label %land.rhs.lr.ph

sw.bb6.i40:                                       ; preds = %if.end
  br label %land.rhs.lr.ph

sw.bb7.i39:                                       ; preds = %if.end
  br label %land.rhs.lr.ph

sw.bb8.i38:                                       ; preds = %if.end
  br label %land.rhs.lr.ph

sw.bb9.i:                                         ; preds = %if.end
  br label %land.rhs.lr.ph

sw.bb10.i:                                        ; preds = %if.end
  br label %land.rhs.lr.ph

sw.bb11.i:                                        ; preds = %if.end
  br label %land.rhs.lr.ph

sw.bb12.i:                                        ; preds = %if.end
  br label %land.rhs.lr.ph

sw.bb13.i37:                                      ; preds = %if.end
  br label %land.rhs.lr.ph

sw.bb14.i35:                                      ; preds = %if.end
  br label %land.rhs.lr.ph

land.rhs.lr.ph:                                   ; preds = %sw.bb14.i35, %sw.bb13.i37, %sw.bb12.i, %sw.bb11.i, %sw.bb10.i, %sw.bb9.i, %sw.bb8.i38, %sw.bb7.i39, %sw.bb6.i40, %sw.bb5.i41, %sw.bb4.i, %sw.bb3.i42, %sw.bb2.i43, %sw.bb1.i44, %if.end
  %retval.0.i36.ph = phi i32 [ 0, %if.end ], [ 1, %sw.bb1.i44 ], [ 2, %sw.bb2.i43 ], [ 3, %sw.bb3.i42 ], [ 4, %sw.bb4.i ], [ 5, %sw.bb5.i41 ], [ 6, %sw.bb6.i40 ], [ 7, %sw.bb7.i39 ], [ 8, %sw.bb8.i38 ], [ 9, %sw.bb9.i ], [ 10, %sw.bb10.i ], [ 11, %sw.bb11.i ], [ 12, %sw.bb12.i ], [ 13, %sw.bb13.i37 ], [ 14, %sw.bb14.i35 ]
  %linenumber.i46 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 1
  %lastline.i47 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 2
  %lookahead.i48 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 4
  %seminfo.i54 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 3, i32 1
  %fs8 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 5
  %t.i16.i = getelementptr inbounds %struct.expdesc, ptr %v, i64 0, i32 2
  %f.i17.i = getelementptr inbounds %struct.expdesc, ptr %v, i64 0, i32 3
  %u.i.i.i71 = getelementptr inbounds %struct.expdesc, ptr %v, i64 0, i32 1
  %u.i.i261.i = getelementptr inbounds %struct.expdesc, ptr %v2, i64 0, i32 1
  %t.i.i107 = getelementptr inbounds %struct.expdesc, ptr %v2, i64 0, i32 2
  %f.i.i108 = getelementptr inbounds %struct.expdesc, ptr %v2, i64 0, i32 3
  br label %land.rhs

land.rhs:                                         ; preds = %land.rhs.lr.ph, %luaK_posfix.exit
  %op.0237 = phi i32 [ %retval.0.i36.ph, %land.rhs.lr.ph ], [ %call12212, %luaK_posfix.exit ]
  %idxprom = zext nneg i32 %op.0237 to i64
  %arrayidx = getelementptr inbounds [15 x %struct.anon.5], ptr @priority, i64 0, i64 %idxprom
  %62 = load i8, ptr %arrayidx, align 2
  %conv = zext i8 %62 to i32
  %cmp6 = icmp ugt i32 %conv, %limit
  br i1 %cmp6, label %while.body, label %while.end

while.body:                                       ; preds = %land.rhs
  %63 = load i32, ptr %linenumber.i46, align 4
  store i32 %63, ptr %lastline.i47, align 8
  %64 = load i32, ptr %lookahead.i48, align 8
  %cmp.not.i49 = icmp eq i32 %64, 287
  br i1 %cmp.not.i49, label %if.else.i53, label %if.then.i51

if.then.i51:                                      ; preds = %while.body
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i48, i64 16, i1 false)
  store i32 287, ptr %lookahead.i48, align 8
  br label %luaX_next.exit56

if.else.i53:                                      ; preds = %while.body
  %call.i55 = call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i54)
  store i32 %call.i55, ptr %t, align 8
  br label %luaX_next.exit56

luaX_next.exit56:                                 ; preds = %if.then.i51, %if.else.i53
  %65 = load ptr, ptr %fs8, align 8
  switch i32 %op.0237, label %sw.default.i104 [
    i32 13, label %luaK_infix.exit.thread
    i32 14, label %sw.bb1.i79
    i32 6, label %sw.bb2.i66
    i32 0, label %sw.bb3.i57
    i32 1, label %sw.bb3.i57
    i32 2, label %sw.bb3.i57
    i32 3, label %sw.bb3.i57
    i32 4, label %sw.bb3.i57
    i32 5, label %sw.bb3.i57
  ]

luaK_infix.exit.thread:                           ; preds = %luaX_next.exit56
  call fastcc void @luaK_goiftrue(ptr noundef %65, ptr noundef %v)
  %right208 = getelementptr inbounds [15 x %struct.anon.5], ptr @priority, i64 0, i64 %idxprom, i32 1
  %66 = load i8, ptr %right208, align 1
  %conv11209 = zext i8 %66 to i32
  %call12210 = call fastcc i32 @subexpr(ptr noundef nonnull %ls, ptr noundef nonnull %v2, i32 noundef %conv11209), !range !93
  %67 = load ptr, ptr %fs8, align 8
  br label %sw.bb.i146

sw.bb1.i79:                                       ; preds = %luaX_next.exit56
  call fastcc void @luaK_dischargevars(ptr noundef %65, ptr noundef %v)
  %68 = load i32, ptr %v, align 8
  switch i32 %68, label %sw.default.i.i [
    i32 1, label %luaK_concat.exit.i.i
    i32 3, label %luaK_concat.exit.i.i
    i32 10, label %sw.bb1.i.i
  ]

sw.bb1.i.i:                                       ; preds = %sw.bb1.i79
  %69 = load i32, ptr %u.i.i.i71, align 8
  br label %sw.epilog.i.i81

sw.default.i.i:                                   ; preds = %sw.bb1.i79
  %call.i.i = call fastcc i32 @jumponcond(ptr noundef %65, ptr noundef nonnull %v, i32 noundef 1)
  br label %sw.epilog.i.i81

sw.epilog.i.i81:                                  ; preds = %sw.default.i.i, %sw.bb1.i.i
  %pc.0.i.i = phi i32 [ %call.i.i, %sw.default.i.i ], [ %69, %sw.bb1.i.i ]
  %cmp.i.i.i = icmp eq i32 %pc.0.i.i, -1
  br i1 %cmp.i.i.i, label %luaK_concat.exit.i.i, label %if.else.i.i.i

if.else.i.i.i:                                    ; preds = %sw.epilog.i.i81
  %70 = load i32, ptr %t.i16.i, align 4
  %cmp1.i.i.i = icmp eq i32 %70, -1
  br i1 %cmp1.i.i.i, label %if.then2.i.i.i, label %while.cond.preheader.i.i.i

while.cond.preheader.i.i.i:                       ; preds = %if.else.i.i.i
  %fs.val.i.i.i = load ptr, ptr %65, align 8
  %71 = getelementptr i8, ptr %fs.val.i.i.i, i64 24
  %fs.val.val.i.i.i83 = load ptr, ptr %71, align 8
  br label %while.cond.i.i.i

if.then2.i.i.i:                                   ; preds = %if.else.i.i.i
  store i32 %pc.0.i.i, ptr %t.i16.i, align 4
  br label %luaK_concat.exit.i.i

while.cond.i.i.i:                                 ; preds = %while.cond.i.i.i, %while.cond.preheader.i.i.i
  %list.0.i.i.i = phi i32 [ %add1.i.i.i.i90, %while.cond.i.i.i ], [ %70, %while.cond.preheader.i.i.i ]
  %idxprom.i.i.i.i84 = sext i32 %list.0.i.i.i to i64
  %arrayidx.i.i.i.i85 = getelementptr inbounds i32, ptr %fs.val.val.i.i.i83, i64 %idxprom.i.i.i.i84
  %72 = load i32, ptr %arrayidx.i.i.i.i85, align 4
  %shr.i.i.i.i86 = lshr i32 %72, 14
  %sub.i.i.i.i87 = add nsw i32 %shr.i.i.i.i86, -131071
  %cmp.i.i.i.i88 = icmp eq i32 %sub.i.i.i.i87, -1
  %add.i.i.i.i89 = add nuw nsw i32 %list.0.i.i.i, 1
  %add1.i.i.i.i90 = add nsw i32 %add.i.i.i.i89, %sub.i.i.i.i87
  %cmp4.not12.i.i.i = icmp eq i32 %add1.i.i.i.i90, -1
  %cmp4.not.i.i.i = select i1 %cmp.i.i.i.i88, i1 true, i1 %cmp4.not12.i.i.i
  br i1 %cmp4.not.i.i.i, label %while.end.i.i.i, label %while.cond.i.i.i, !llvm.loop !94

while.end.i.i.i:                                  ; preds = %while.cond.i.i.i
  %add.neg.i.i.i.i = xor i32 %list.0.i.i.i, -1
  %sub.i7.i.i.i = add i32 %pc.0.i.i, %add.neg.i.i.i.i
  %73 = call i32 @llvm.abs.i32(i32 %sub.i7.i.i.i, i1 true)
  %cmp.i8.i.i.i = icmp ugt i32 %73, 131071
  br i1 %cmp.i8.i.i.i, label %if.then.i.i.i.i102, label %fixjump.exit.i.i.i

if.then.i.i.i.i102:                               ; preds = %while.end.i.i.i
  %ls.i.i.i.i = getelementptr inbounds %struct.FuncState, ptr %65, i64 0, i32 3
  %74 = load ptr, ptr %ls.i.i.i.i, align 8
  %t.i.i.i.i.i = getelementptr inbounds %struct.LexState, ptr %74, i64 0, i32 3
  %75 = load i32, ptr %t.i.i.i.i.i, align 8
  call fastcc void @luaX_lexerror(ptr noundef %74, ptr noundef nonnull @.str.148, i32 noundef %75)
  unreachable

fixjump.exit.i.i.i:                               ; preds = %while.end.i.i.i
  %arrayidx.i.i.i.i85.le = getelementptr inbounds i32, ptr %fs.val.val.i.i.i83, i64 %idxprom.i.i.i.i84
  %and.i.i.i.i91 = and i32 %72, 16383
  %add1.i11.i.i.i = shl i32 %sub.i7.i.i.i, 14
  %shl.i.i.i.i = add i32 %add1.i11.i.i.i, 2147467264
  %or.i.i.i.i = or disjoint i32 %shl.i.i.i.i, %and.i.i.i.i91
  store i32 %or.i.i.i.i, ptr %arrayidx.i.i.i.i85.le, align 4
  br label %luaK_concat.exit.i.i

luaK_concat.exit.i.i:                             ; preds = %fixjump.exit.i.i.i, %if.then2.i.i.i, %sw.epilog.i.i81, %sw.bb1.i79, %sw.bb1.i79
  %76 = load i32, ptr %f.i17.i, align 4
  %pc.i.i.i.i = getelementptr inbounds %struct.FuncState, ptr %65, i64 0, i32 6
  %77 = load i32, ptr %pc.i.i.i.i, align 8
  %lasttarget.i.i.i.i = getelementptr inbounds %struct.FuncState, ptr %65, i64 0, i32 7
  store i32 %77, ptr %lasttarget.i.i.i.i, align 4
  %jpc.i.i.i = getelementptr inbounds %struct.FuncState, ptr %65, i64 0, i32 8
  %cmp.i.i10.i.i = icmp eq i32 %76, -1
  br i1 %cmp.i.i10.i.i, label %luaK_goiffalse.exit.i, label %if.else.i.i.i.i93

if.else.i.i.i.i93:                                ; preds = %luaK_concat.exit.i.i
  %78 = load i32, ptr %jpc.i.i.i, align 4
  %cmp1.i.i.i.i = icmp eq i32 %78, -1
  br i1 %cmp1.i.i.i.i, label %if.then2.i.i.i.i, label %while.cond.preheader.i.i.i.i

while.cond.preheader.i.i.i.i:                     ; preds = %if.else.i.i.i.i93
  %fs.val.i.i.i.i = load ptr, ptr %65, align 8
  %79 = getelementptr i8, ptr %fs.val.i.i.i.i, i64 24
  %fs.val.val.i.i.i.i = load ptr, ptr %79, align 8
  br label %while.cond.i.i.i.i

if.then2.i.i.i.i:                                 ; preds = %if.else.i.i.i.i93
  store i32 %76, ptr %jpc.i.i.i, align 4
  br label %luaK_goiffalse.exit.i

while.cond.i.i.i.i:                               ; preds = %while.cond.i.i.i.i, %while.cond.preheader.i.i.i.i
  %list.0.i.i.i.i = phi i32 [ %add1.i.i.i.i.i, %while.cond.i.i.i.i ], [ %78, %while.cond.preheader.i.i.i.i ]
  %idxprom.i.i.i.i.i94 = sext i32 %list.0.i.i.i.i to i64
  %arrayidx.i.i.i.i.i95 = getelementptr inbounds i32, ptr %fs.val.val.i.i.i.i, i64 %idxprom.i.i.i.i.i94
  %80 = load i32, ptr %arrayidx.i.i.i.i.i95, align 4
  %shr.i.i.i.i.i = lshr i32 %80, 14
  %sub.i.i.i.i.i = add nsw i32 %shr.i.i.i.i.i, -131071
  %cmp.i.i.i.i.i96 = icmp eq i32 %sub.i.i.i.i.i, -1
  %add.i.i.i.i.i97 = add nuw nsw i32 %list.0.i.i.i.i, 1
  %add1.i.i.i.i.i = add nsw i32 %add.i.i.i.i.i97, %sub.i.i.i.i.i
  %cmp4.not12.i.i.i.i = icmp eq i32 %add1.i.i.i.i.i, -1
  %cmp4.not.i.i.i.i = select i1 %cmp.i.i.i.i.i96, i1 true, i1 %cmp4.not12.i.i.i.i
  br i1 %cmp4.not.i.i.i.i, label %while.end.i.i.i.i, label %while.cond.i.i.i.i, !llvm.loop !94

while.end.i.i.i.i:                                ; preds = %while.cond.i.i.i.i
  %add.neg.i.i.i.i.i = xor i32 %list.0.i.i.i.i, -1
  %sub.i7.i.i.i.i = add i32 %76, %add.neg.i.i.i.i.i
  %81 = call i32 @llvm.abs.i32(i32 %sub.i7.i.i.i.i, i1 true)
  %cmp.i8.i.i.i.i = icmp ugt i32 %81, 131071
  br i1 %cmp.i8.i.i.i.i, label %if.then.i.i.i.i.i99, label %fixjump.exit.i.i.i.i

if.then.i.i.i.i.i99:                              ; preds = %while.end.i.i.i.i
  %ls.i.i.i.i.i100 = getelementptr inbounds %struct.FuncState, ptr %65, i64 0, i32 3
  %82 = load ptr, ptr %ls.i.i.i.i.i100, align 8
  %t.i.i.i.i.i.i101 = getelementptr inbounds %struct.LexState, ptr %82, i64 0, i32 3
  %83 = load i32, ptr %t.i.i.i.i.i.i101, align 8
  call fastcc void @luaX_lexerror(ptr noundef %82, ptr noundef nonnull @.str.148, i32 noundef %83)
  unreachable

fixjump.exit.i.i.i.i:                             ; preds = %while.end.i.i.i.i
  %arrayidx.i.i.i.i.i95.le = getelementptr inbounds i32, ptr %fs.val.val.i.i.i.i, i64 %idxprom.i.i.i.i.i94
  %and.i.i.i.i.i98 = and i32 %80, 16383
  %add1.i11.i.i.i.i = shl i32 %sub.i7.i.i.i.i, 14
  %shl.i.i.i.i.i = add i32 %add1.i11.i.i.i.i, 2147467264
  %or.i.i.i.i.i = or disjoint i32 %shl.i.i.i.i.i, %and.i.i.i.i.i98
  store i32 %or.i.i.i.i.i, ptr %arrayidx.i.i.i.i.i95.le, align 4
  br label %luaK_goiffalse.exit.i

luaK_goiffalse.exit.i:                            ; preds = %fixjump.exit.i.i.i.i, %if.then2.i.i.i.i, %luaK_concat.exit.i.i
  store i32 -1, ptr %f.i17.i, align 4
  br label %luaK_infix.exit

sw.bb2.i66:                                       ; preds = %luaX_next.exit56
  call fastcc void @luaK_dischargevars(ptr noundef %65, ptr noundef %v)
  %84 = load i32, ptr %v, align 8
  %cmp.i.i10.i = icmp eq i32 %84, 12
  br i1 %cmp.i.i10.i, label %if.then.i.i.i70, label %freeexp.exit.i.i67

if.then.i.i.i70:                                  ; preds = %sw.bb2.i66
  %85 = load i32, ptr %u.i.i.i71, align 8
  %and.i.i.i14.i = and i32 %85, 256
  %tobool.not.i.i.i.i72 = icmp eq i32 %and.i.i.i14.i, 0
  br i1 %tobool.not.i.i.i.i72, label %land.lhs.true.i.i.i.i73, label %freeexp.exit.i.i67

land.lhs.true.i.i.i.i73:                          ; preds = %if.then.i.i.i70
  %nactvar.i.i.i.i74 = getelementptr inbounds %struct.FuncState, ptr %65, i64 0, i32 13
  %86 = load i8, ptr %nactvar.i.i.i.i74, align 2
  %conv.i.i.i.i75 = zext i8 %86 to i32
  %cmp.not.i.i.i.i76 = icmp slt i32 %85, %conv.i.i.i.i75
  br i1 %cmp.not.i.i.i.i76, label %freeexp.exit.i.i67, label %if.then.i.i.i15.i

if.then.i.i.i15.i:                                ; preds = %land.lhs.true.i.i.i.i73
  %freereg.i.i.i.i77 = getelementptr inbounds %struct.FuncState, ptr %65, i64 0, i32 9
  %87 = load i32, ptr %freereg.i.i.i.i77, align 4
  %dec.i.i.i.i78 = add nsw i32 %87, -1
  store i32 %dec.i.i.i.i78, ptr %freereg.i.i.i.i77, align 4
  br label %freeexp.exit.i.i67

freeexp.exit.i.i67:                               ; preds = %if.then.i.i.i15.i, %land.lhs.true.i.i.i.i73, %if.then.i.i.i70, %sw.bb2.i66
  %freereg.i.i7.i.i = getelementptr inbounds %struct.FuncState, ptr %65, i64 0, i32 9
  %88 = load i32, ptr %freereg.i.i7.i.i, align 4
  %add.i.i.i11.i = add nsw i32 %88, 1
  %89 = load ptr, ptr %65, align 8
  %maxstacksize.i.i.i.i = getelementptr inbounds %struct.Proto, ptr %89, i64 0, i32 22
  %90 = load i8, ptr %maxstacksize.i.i.i.i, align 1
  %conv.i.i8.i.i = zext i8 %90 to i32
  %cmp.i.i.not.i.i = icmp slt i32 %88, %conv.i.i8.i.i
  br i1 %cmp.i.i.not.i.i, label %luaK_infix.exit.thread213, label %if.then.i.i9.i.i

if.then.i.i9.i.i:                                 ; preds = %freeexp.exit.i.i67
  %cmp2.i.i.i.i = icmp sgt i32 %88, 248
  br i1 %cmp2.i.i.i.i, label %if.then4.i.i.i.i, label %if.end.i.i.i.i68

if.then4.i.i.i.i:                                 ; preds = %if.then.i.i9.i.i
  %ls.i.i.i12.i = getelementptr inbounds %struct.FuncState, ptr %65, i64 0, i32 3
  %91 = load ptr, ptr %ls.i.i.i12.i, align 8
  %t.i.i.i.i13.i = getelementptr inbounds %struct.LexState, ptr %91, i64 0, i32 3
  %92 = load i32, ptr %t.i.i.i.i13.i, align 8
  call fastcc void @luaX_lexerror(ptr noundef %91, ptr noundef nonnull @.str.150, i32 noundef %92)
  unreachable

if.end.i.i.i.i68:                                 ; preds = %if.then.i.i9.i.i
  %conv5.i.i.i.i = trunc i32 %add.i.i.i11.i to i8
  store i8 %conv5.i.i.i.i, ptr %maxstacksize.i.i.i.i, align 1
  %.pre.i.i.i69 = load i32, ptr %freereg.i.i7.i.i, align 4
  %.pre3.i.i.i = add nsw i32 %.pre.i.i.i69, 1
  br label %luaK_infix.exit.thread213

luaK_infix.exit.thread213:                        ; preds = %freeexp.exit.i.i67, %if.end.i.i.i.i68
  %add.pre-phi.i.i.i = phi i32 [ %add.i.i.i11.i, %freeexp.exit.i.i67 ], [ %.pre3.i.i.i, %if.end.i.i.i.i68 ]
  store i32 %add.pre-phi.i.i.i, ptr %freereg.i.i7.i.i, align 4
  %sub.i.i = add nsw i32 %add.pre-phi.i.i.i, -1
  call fastcc void @exp2reg(ptr noundef nonnull %65, ptr noundef nonnull %v, i32 noundef %sub.i.i)
  %right214 = getelementptr inbounds [15 x %struct.anon.5], ptr @priority, i64 0, i64 %idxprom, i32 1
  %93 = load i8, ptr %right214, align 1
  %conv11215 = zext i8 %93 to i32
  %call12216 = call fastcc i32 @subexpr(ptr noundef nonnull %ls, ptr noundef nonnull %v2, i32 noundef %conv11215), !range !93
  %94 = load ptr, ptr %fs8, align 8
  br label %sw.bb4.i106

sw.bb3.i57:                                       ; preds = %luaX_next.exit56, %luaX_next.exit56, %luaX_next.exit56, %luaX_next.exit56, %luaX_next.exit56, %luaX_next.exit56
  %95 = load i32, ptr %v, align 8
  %cmp.i.i58 = icmp eq i32 %95, 5
  br i1 %cmp.i.i58, label %land.lhs.true.i.i62, label %if.then.i59

land.lhs.true.i.i62:                              ; preds = %sw.bb3.i57
  %96 = load i32, ptr %t.i16.i, align 8
  %cmp1.i.i63 = icmp eq i32 %96, -1
  br i1 %cmp1.i.i63, label %isnumeral.exit.i64, label %if.then.i59

isnumeral.exit.i64:                               ; preds = %land.lhs.true.i.i62
  %97 = load i32, ptr %f.i17.i, align 4
  %cmp2.i.not.i65 = icmp eq i32 %97, -1
  br i1 %cmp2.i.not.i65, label %luaK_infix.exit, label %if.then.i59

if.then.i59:                                      ; preds = %isnumeral.exit.i64, %land.lhs.true.i.i62, %sw.bb3.i57
  %call4.i60 = call fastcc i32 @luaK_exp2RK(ptr noundef %65, ptr noundef nonnull %v)
  br label %luaK_infix.exit

sw.default.i104:                                  ; preds = %luaX_next.exit56
  %call5.i = call fastcc i32 @luaK_exp2RK(ptr noundef %65, ptr noundef %v)
  br label %luaK_infix.exit

luaK_infix.exit:                                  ; preds = %luaK_goiffalse.exit.i, %isnumeral.exit.i64, %if.then.i59, %sw.default.i104
  %right = getelementptr inbounds [15 x %struct.anon.5], ptr @priority, i64 0, i64 %idxprom, i32 1
  %98 = load i8, ptr %right, align 1
  %conv11 = zext i8 %98 to i32
  %call12 = call fastcc i32 @subexpr(ptr noundef %ls, ptr noundef nonnull %v2, i32 noundef %conv11), !range !93
  %99 = load ptr, ptr %fs8, align 8
  switch i32 %op.0237, label %luaK_posfix.exit [
    i32 13, label %sw.bb.i146
    i32 14, label %sw.bb2.i144
    i32 6, label %sw.bb4.i106
    i32 0, label %sw.bb28.i
    i32 1, label %sw.bb29.i
    i32 2, label %sw.bb30.i
    i32 3, label %sw.bb31.i
    i32 4, label %sw.bb32.i
    i32 5, label %sw.bb33.i
    i32 8, label %sw.bb34.i
    i32 7, label %sw.bb35.i
    i32 9, label %sw.bb36.i
    i32 10, label %sw.bb37.i
    i32 11, label %sw.bb38.i
    i32 12, label %sw.bb39.i
  ]

sw.bb.i146:                                       ; preds = %luaK_infix.exit.thread, %luaK_infix.exit
  %100 = phi ptr [ %67, %luaK_infix.exit.thread ], [ %99, %luaK_infix.exit ]
  %call12211 = phi i32 [ %call12210, %luaK_infix.exit.thread ], [ %call12, %luaK_infix.exit ]
  call fastcc void @luaK_dischargevars(ptr noundef %100, ptr noundef nonnull %v2)
  %101 = load i32, ptr %f.i17.i, align 4
  %cmp.i.i148 = icmp eq i32 %101, -1
  br i1 %cmp.i.i148, label %luaK_concat.exit.i, label %if.else.i.i

if.else.i.i:                                      ; preds = %sw.bb.i146
  %102 = load i32, ptr %f.i.i108, align 4
  %cmp1.i.i149 = icmp eq i32 %102, -1
  br i1 %cmp1.i.i149, label %if.then2.i.i, label %while.cond.preheader.i.i

while.cond.preheader.i.i:                         ; preds = %if.else.i.i
  %fs.val.i.i150 = load ptr, ptr %100, align 8
  %103 = getelementptr i8, ptr %fs.val.i.i150, i64 24
  %fs.val.val.i.i151 = load ptr, ptr %103, align 8
  br label %while.cond.i.i

if.then2.i.i:                                     ; preds = %if.else.i.i
  store i32 %101, ptr %f.i.i108, align 4
  br label %luaK_concat.exit.i

while.cond.i.i:                                   ; preds = %while.cond.i.i, %while.cond.preheader.i.i
  %list.0.i.i = phi i32 [ %add1.i.i.i, %while.cond.i.i ], [ %102, %while.cond.preheader.i.i ]
  %idxprom.i.i.i = sext i32 %list.0.i.i to i64
  %arrayidx.i.i.i = getelementptr inbounds i32, ptr %fs.val.val.i.i151, i64 %idxprom.i.i.i
  %104 = load i32, ptr %arrayidx.i.i.i, align 4
  %shr.i.i.i = lshr i32 %104, 14
  %sub.i.i.i152 = add nsw i32 %shr.i.i.i, -131071
  %cmp.i.i.i153 = icmp eq i32 %sub.i.i.i152, -1
  %add.i.i.i = add nuw nsw i32 %list.0.i.i, 1
  %add1.i.i.i = add nsw i32 %add.i.i.i, %sub.i.i.i152
  %cmp4.not12.i.i = icmp eq i32 %add1.i.i.i, -1
  %cmp4.not.i.i = select i1 %cmp.i.i.i153, i1 true, i1 %cmp4.not12.i.i
  br i1 %cmp4.not.i.i, label %while.end.i.i, label %while.cond.i.i, !llvm.loop !94

while.end.i.i:                                    ; preds = %while.cond.i.i
  %add.neg.i.i.i = xor i32 %list.0.i.i, -1
  %sub.i7.i.i = add i32 %101, %add.neg.i.i.i
  %105 = call i32 @llvm.abs.i32(i32 %sub.i7.i.i, i1 true)
  %cmp.i8.i.i = icmp ugt i32 %105, 131071
  br i1 %cmp.i8.i.i, label %if.then.i.i.i157, label %fixjump.exit.i.i

if.then.i.i.i157:                                 ; preds = %while.end.i.i
  %ls.i.i.i158 = getelementptr inbounds %struct.FuncState, ptr %100, i64 0, i32 3
  %106 = load ptr, ptr %ls.i.i.i158, align 8
  %t.i.i.i.i = getelementptr inbounds %struct.LexState, ptr %106, i64 0, i32 3
  %107 = load i32, ptr %t.i.i.i.i, align 8
  call fastcc void @luaX_lexerror(ptr noundef %106, ptr noundef nonnull @.str.148, i32 noundef %107)
  unreachable

fixjump.exit.i.i:                                 ; preds = %while.end.i.i
  %arrayidx.i.i.i.le = getelementptr inbounds i32, ptr %fs.val.val.i.i151, i64 %idxprom.i.i.i
  %and.i.i.i154 = and i32 %104, 16383
  %add1.i11.i.i = shl i32 %sub.i7.i.i, 14
  %shl.i.i.i155 = add i32 %add1.i11.i.i, 2147467264
  %or.i.i.i156 = or disjoint i32 %shl.i.i.i155, %and.i.i.i154
  store i32 %or.i.i.i156, ptr %arrayidx.i.i.i.le, align 4
  br label %luaK_concat.exit.i

luaK_concat.exit.i:                               ; preds = %fixjump.exit.i.i, %if.then2.i.i, %sw.bb.i146
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %v, ptr noundef nonnull align 8 dereferenceable(24) %v2, i64 24, i1 false)
  br label %luaK_posfix.exit

sw.bb2.i144:                                      ; preds = %luaK_infix.exit
  call fastcc void @luaK_dischargevars(ptr noundef %99, ptr noundef nonnull %v2)
  %108 = load i32, ptr %t.i16.i, align 8
  %cmp.i68.i = icmp eq i32 %108, -1
  br i1 %cmp.i68.i, label %luaK_concat.exit99.i, label %if.else.i69.i

if.else.i69.i:                                    ; preds = %sw.bb2.i144
  %109 = load i32, ptr %t.i.i107, align 8
  %cmp1.i70.i = icmp eq i32 %109, -1
  br i1 %cmp1.i70.i, label %if.then2.i98.i, label %while.cond.preheader.i71.i

while.cond.preheader.i71.i:                       ; preds = %if.else.i69.i
  %fs.val.i72.i = load ptr, ptr %99, align 8
  %110 = getelementptr i8, ptr %fs.val.i72.i, i64 24
  %fs.val.val.i73.i = load ptr, ptr %110, align 8
  br label %while.cond.i74.i

if.then2.i98.i:                                   ; preds = %if.else.i69.i
  store i32 %108, ptr %t.i.i107, align 8
  br label %luaK_concat.exit99.i

while.cond.i74.i:                                 ; preds = %while.cond.i74.i, %while.cond.preheader.i71.i
  %list.0.i75.i = phi i32 [ %add1.i.i82.i, %while.cond.i74.i ], [ %109, %while.cond.preheader.i71.i ]
  %idxprom.i.i76.i = sext i32 %list.0.i75.i to i64
  %arrayidx.i.i77.i = getelementptr inbounds i32, ptr %fs.val.val.i73.i, i64 %idxprom.i.i76.i
  %111 = load i32, ptr %arrayidx.i.i77.i, align 4
  %shr.i.i78.i = lshr i32 %111, 14
  %sub.i.i79.i = add nsw i32 %shr.i.i78.i, -131071
  %cmp.i.i80.i = icmp eq i32 %sub.i.i79.i, -1
  %add.i.i81.i = add nuw nsw i32 %list.0.i75.i, 1
  %add1.i.i82.i = add nsw i32 %add.i.i81.i, %sub.i.i79.i
  %cmp4.not12.i83.i = icmp eq i32 %add1.i.i82.i, -1
  %cmp4.not.i84.i = select i1 %cmp.i.i80.i, i1 true, i1 %cmp4.not12.i83.i
  br i1 %cmp4.not.i84.i, label %while.end.i85.i, label %while.cond.i74.i, !llvm.loop !94

while.end.i85.i:                                  ; preds = %while.cond.i74.i
  %add.neg.i.i86.i = xor i32 %list.0.i75.i, -1
  %sub.i7.i87.i = add i32 %108, %add.neg.i.i86.i
  %112 = call i32 @llvm.abs.i32(i32 %sub.i7.i87.i, i1 true)
  %cmp.i8.i88.i = icmp ugt i32 %112, 131071
  br i1 %cmp.i8.i88.i, label %if.then.i.i95.i, label %fixjump.exit.i89.i

if.then.i.i95.i:                                  ; preds = %while.end.i85.i
  %ls.i.i96.i = getelementptr inbounds %struct.FuncState, ptr %99, i64 0, i32 3
  %113 = load ptr, ptr %ls.i.i96.i, align 8
  %t.i.i.i97.i = getelementptr inbounds %struct.LexState, ptr %113, i64 0, i32 3
  %114 = load i32, ptr %t.i.i.i97.i, align 8
  call fastcc void @luaX_lexerror(ptr noundef %113, ptr noundef nonnull @.str.148, i32 noundef %114)
  unreachable

fixjump.exit.i89.i:                               ; preds = %while.end.i85.i
  %arrayidx.i.i77.i.le = getelementptr inbounds i32, ptr %fs.val.val.i73.i, i64 %idxprom.i.i76.i
  %and.i.i91.i = and i32 %111, 16383
  %add1.i11.i92.i = shl i32 %sub.i7.i87.i, 14
  %shl.i.i93.i = add i32 %add1.i11.i92.i, 2147467264
  %or.i.i94.i = or disjoint i32 %shl.i.i93.i, %and.i.i91.i
  store i32 %or.i.i94.i, ptr %arrayidx.i.i77.i.le, align 4
  br label %luaK_concat.exit99.i

luaK_concat.exit99.i:                             ; preds = %fixjump.exit.i89.i, %if.then2.i98.i, %sw.bb2.i144
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %v, ptr noundef nonnull align 8 dereferenceable(24) %v2, i64 24, i1 false)
  br label %luaK_posfix.exit

sw.bb4.i106:                                      ; preds = %luaK_infix.exit.thread213, %luaK_infix.exit
  %115 = phi ptr [ %94, %luaK_infix.exit.thread213 ], [ %99, %luaK_infix.exit ]
  %call12217 = phi i32 [ %call12216, %luaK_infix.exit.thread213 ], [ %call12, %luaK_infix.exit ]
  %116 = load i32, ptr %t.i.i107, align 8
  %117 = load i32, ptr %f.i.i108, align 4
  %cmp.not.i.i = icmp eq i32 %116, %117
  br i1 %cmp.not.i.i, label %if.else.i100.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %sw.bb4.i106
  %call.i.i109 = call fastcc i32 @luaK_exp2anyreg(ptr noundef %115, ptr noundef nonnull %v2)
  br label %luaK_exp2val.exit.i

if.else.i100.i:                                   ; preds = %sw.bb4.i106
  call fastcc void @luaK_dischargevars(ptr noundef %115, ptr noundef nonnull %v2)
  br label %luaK_exp2val.exit.i

luaK_exp2val.exit.i:                              ; preds = %if.else.i100.i, %if.then.i.i
  %118 = load i32, ptr %v2, align 8
  %cmp.i110 = icmp eq i32 %118, 11
  br i1 %cmp.i110, label %land.lhs.true.i, label %if.else.i111

land.lhs.true.i:                                  ; preds = %luaK_exp2val.exit.i
  %119 = load ptr, ptr %115, align 8
  %code.i = getelementptr inbounds %struct.Proto, ptr %119, i64 0, i32 4
  %120 = load ptr, ptr %code.i, align 8
  %121 = load i32, ptr %u.i.i261.i, align 8
  %idxprom.i = sext i32 %121 to i64
  %arrayidx.i = getelementptr inbounds i32, ptr %120, i64 %idxprom.i
  %122 = load i32, ptr %arrayidx.i, align 4
  %and.i = and i32 %122, 63
  %cmp6.i = icmp eq i32 %and.i, 21
  br i1 %cmp6.i, label %if.then.i141, label %if.else.i111

if.then.i141:                                     ; preds = %land.lhs.true.i
  %123 = load i32, ptr %v, align 8
  %cmp.i101.i = icmp eq i32 %123, 12
  %.pre252 = load i32, ptr %u.i.i.i71, align 8
  %and.i.i103.i = and i32 %.pre252, 256
  %tobool.not.i.i.i143 = icmp eq i32 %and.i.i103.i, 0
  %or.cond = select i1 %cmp.i101.i, i1 %tobool.not.i.i.i143, i1 false
  br i1 %or.cond, label %land.lhs.true.i.i.i, label %freeexp.exit.i

land.lhs.true.i.i.i:                              ; preds = %if.then.i141
  %nactvar.i.i.i = getelementptr inbounds %struct.FuncState, ptr %115, i64 0, i32 13
  %124 = load i8, ptr %nactvar.i.i.i, align 2
  %conv.i.i.i = zext i8 %124 to i32
  %cmp.not.i.i.i = icmp slt i32 %.pre252, %conv.i.i.i
  br i1 %cmp.not.i.i.i, label %freeexp.exit.i, label %if.then.i.i104.i

if.then.i.i104.i:                                 ; preds = %land.lhs.true.i.i.i
  %freereg.i.i.i = getelementptr inbounds %struct.FuncState, ptr %115, i64 0, i32 9
  %125 = load i32, ptr %freereg.i.i.i, align 4
  %dec.i.i.i = add nsw i32 %125, -1
  store i32 %dec.i.i.i, ptr %freereg.i.i.i, align 4
  %.pre.i = load ptr, ptr %code.i, align 8
  %arrayidx12.phi.trans.insert.i = getelementptr inbounds i32, ptr %.pre.i, i64 %idxprom.i
  %.pre275.i = load i32, ptr %arrayidx12.phi.trans.insert.i, align 4
  %.pre251 = load i32, ptr %u.i.i.i71, align 8
  br label %freeexp.exit.i

freeexp.exit.i:                                   ; preds = %if.then.i.i104.i, %land.lhs.true.i.i.i, %if.then.i141
  %126 = phi i32 [ %.pre252, %if.then.i141 ], [ %.pre252, %land.lhs.true.i.i.i ], [ %.pre251, %if.then.i.i104.i ]
  %127 = phi i32 [ %122, %if.then.i141 ], [ %122, %land.lhs.true.i.i.i ], [ %.pre275.i, %if.then.i.i104.i ]
  %128 = phi ptr [ %120, %if.then.i141 ], [ %120, %land.lhs.true.i.i.i ], [ %.pre.i, %if.then.i.i104.i ]
  %arrayidx12.i = getelementptr inbounds i32, ptr %128, i64 %idxprom.i
  %and13.i = and i32 %127, 8388607
  %shl.i = shl i32 %126, 23
  %or.i = or disjoint i32 %shl.i, %and13.i
  store i32 %or.i, ptr %arrayidx12.i, align 4
  store i32 11, ptr %v, align 8
  %129 = load i32, ptr %u.i.i261.i, align 8
  store i32 %129, ptr %u.i.i.i71, align 8
  br label %luaK_posfix.exit

if.else.i111:                                     ; preds = %land.lhs.true.i, %luaK_exp2val.exit.i
  call fastcc void @luaK_dischargevars(ptr noundef %115, ptr noundef nonnull %v2)
  %130 = load i32, ptr %v2, align 8
  %cmp.i.i105.i = icmp eq i32 %130, 12
  br i1 %cmp.i.i105.i, label %if.then.i.i106.i, label %freeexp.exit.i.i112

if.then.i.i106.i:                                 ; preds = %if.else.i111
  %131 = load i32, ptr %u.i.i261.i, align 8
  %and.i.i.i.i131 = and i32 %131, 256
  %tobool.not.i.i.i.i132 = icmp eq i32 %and.i.i.i.i131, 0
  br i1 %tobool.not.i.i.i.i132, label %land.lhs.true.i.i.i.i133, label %freeexp.exit.i.i112

land.lhs.true.i.i.i.i133:                         ; preds = %if.then.i.i106.i
  %nactvar.i.i.i.i134 = getelementptr inbounds %struct.FuncState, ptr %115, i64 0, i32 13
  %132 = load i8, ptr %nactvar.i.i.i.i134, align 2
  %conv.i.i.i.i135 = zext i8 %132 to i32
  %cmp.not.i.i.i.i136 = icmp slt i32 %131, %conv.i.i.i.i135
  br i1 %cmp.not.i.i.i.i136, label %freeexp.exit.i.i112, label %if.then.i.i.i.i137

if.then.i.i.i.i137:                               ; preds = %land.lhs.true.i.i.i.i133
  %freereg.i.i.i.i138 = getelementptr inbounds %struct.FuncState, ptr %115, i64 0, i32 9
  %133 = load i32, ptr %freereg.i.i.i.i138, align 4
  %dec.i.i.i.i139 = add nsw i32 %133, -1
  store i32 %dec.i.i.i.i139, ptr %freereg.i.i.i.i138, align 4
  br label %freeexp.exit.i.i112

freeexp.exit.i.i112:                              ; preds = %if.then.i.i.i.i137, %land.lhs.true.i.i.i.i133, %if.then.i.i106.i, %if.else.i111
  %freereg.i.i7.i.i113 = getelementptr inbounds %struct.FuncState, ptr %115, i64 0, i32 9
  %134 = load i32, ptr %freereg.i.i7.i.i113, align 4
  %add.i.i.i.i114 = add nsw i32 %134, 1
  %135 = load ptr, ptr %115, align 8
  %maxstacksize.i.i.i.i115 = getelementptr inbounds %struct.Proto, ptr %135, i64 0, i32 22
  %136 = load i8, ptr %maxstacksize.i.i.i.i115, align 1
  %conv.i.i8.i.i116 = zext i8 %136 to i32
  %cmp.i.i.not.i.i117 = icmp slt i32 %134, %conv.i.i8.i.i116
  br i1 %cmp.i.i.not.i.i117, label %luaK_exp2nextreg.exit.i124, label %if.then.i.i9.i.i118

if.then.i.i9.i.i118:                              ; preds = %freeexp.exit.i.i112
  %cmp2.i.i.i.i119 = icmp sgt i32 %134, 248
  br i1 %cmp2.i.i.i.i119, label %if.then4.i.i.i.i127, label %if.end.i.i.i.i120

if.then4.i.i.i.i127:                              ; preds = %if.then.i.i9.i.i118
  %ls.i.i.i.i128 = getelementptr inbounds %struct.FuncState, ptr %115, i64 0, i32 3
  %137 = load ptr, ptr %ls.i.i.i.i128, align 8
  %t.i.i.i.i.i129 = getelementptr inbounds %struct.LexState, ptr %137, i64 0, i32 3
  %138 = load i32, ptr %t.i.i.i.i.i129, align 8
  call fastcc void @luaX_lexerror(ptr noundef %137, ptr noundef nonnull @.str.150, i32 noundef %138)
  unreachable

if.end.i.i.i.i120:                                ; preds = %if.then.i.i9.i.i118
  %conv5.i.i.i.i121 = trunc i32 %add.i.i.i.i114 to i8
  store i8 %conv5.i.i.i.i121, ptr %maxstacksize.i.i.i.i115, align 1
  %.pre.i.i.i122 = load i32, ptr %freereg.i.i7.i.i113, align 4
  %.pre3.i.i.i123 = add nsw i32 %.pre.i.i.i122, 1
  br label %luaK_exp2nextreg.exit.i124

luaK_exp2nextreg.exit.i124:                       ; preds = %if.end.i.i.i.i120, %freeexp.exit.i.i112
  %add.pre-phi.i.i.i125 = phi i32 [ %add.i.i.i.i114, %freeexp.exit.i.i112 ], [ %.pre3.i.i.i123, %if.end.i.i.i.i120 ]
  store i32 %add.pre-phi.i.i.i125, ptr %freereg.i.i7.i.i113, align 4
  %sub.i.i126 = add nsw i32 %add.pre-phi.i.i.i125, -1
  call fastcc void @exp2reg(ptr noundef nonnull %115, ptr noundef nonnull %v2, i32 noundef %sub.i.i126)
  call fastcc void @codearith(ptr noundef nonnull %115, i32 noundef 21, ptr noundef %v, ptr noundef nonnull %v2)
  br label %luaK_posfix.exit

sw.bb28.i:                                        ; preds = %luaK_infix.exit
  call fastcc void @codearith(ptr noundef %99, i32 noundef 12, ptr noundef %v, ptr noundef nonnull %v2)
  br label %luaK_posfix.exit

sw.bb29.i:                                        ; preds = %luaK_infix.exit
  call fastcc void @codearith(ptr noundef %99, i32 noundef 13, ptr noundef %v, ptr noundef nonnull %v2)
  br label %luaK_posfix.exit

sw.bb30.i:                                        ; preds = %luaK_infix.exit
  call fastcc void @codearith(ptr noundef %99, i32 noundef 14, ptr noundef %v, ptr noundef nonnull %v2)
  br label %luaK_posfix.exit

sw.bb31.i:                                        ; preds = %luaK_infix.exit
  call fastcc void @codearith(ptr noundef %99, i32 noundef 15, ptr noundef %v, ptr noundef nonnull %v2)
  br label %luaK_posfix.exit

sw.bb32.i:                                        ; preds = %luaK_infix.exit
  call fastcc void @codearith(ptr noundef %99, i32 noundef 16, ptr noundef %v, ptr noundef nonnull %v2)
  br label %luaK_posfix.exit

sw.bb33.i:                                        ; preds = %luaK_infix.exit
  call fastcc void @codearith(ptr noundef %99, i32 noundef 17, ptr noundef %v, ptr noundef nonnull %v2)
  br label %luaK_posfix.exit

sw.bb34.i:                                        ; preds = %luaK_infix.exit
  %call.i107.i = call fastcc i32 @luaK_exp2RK(ptr noundef %99, ptr noundef %v)
  %call1.i.i = call fastcc i32 @luaK_exp2RK(ptr noundef %99, ptr noundef nonnull %v2)
  %139 = load i32, ptr %v2, align 8
  %cmp.i.i108.i = icmp eq i32 %139, 12
  br i1 %cmp.i.i108.i, label %if.then.i.i111.i, label %freeexp.exit.i109.i

if.then.i.i111.i:                                 ; preds = %sw.bb34.i
  %140 = load i32, ptr %u.i.i261.i, align 8
  %and.i.i.i113.i = and i32 %140, 256
  %tobool.not.i.i.i114.i = icmp eq i32 %and.i.i.i113.i, 0
  br i1 %tobool.not.i.i.i114.i, label %land.lhs.true.i.i.i115.i, label %freeexp.exit.i109.i

land.lhs.true.i.i.i115.i:                         ; preds = %if.then.i.i111.i
  %nactvar.i.i.i116.i = getelementptr inbounds %struct.FuncState, ptr %99, i64 0, i32 13
  %141 = load i8, ptr %nactvar.i.i.i116.i, align 2
  %conv.i.i.i117.i = zext i8 %141 to i32
  %cmp.not.i.i.i118.i = icmp slt i32 %140, %conv.i.i.i117.i
  br i1 %cmp.not.i.i.i118.i, label %freeexp.exit.i109.i, label %if.then.i.i.i119.i

if.then.i.i.i119.i:                               ; preds = %land.lhs.true.i.i.i115.i
  %freereg.i.i.i120.i = getelementptr inbounds %struct.FuncState, ptr %99, i64 0, i32 9
  %142 = load i32, ptr %freereg.i.i.i120.i, align 4
  %dec.i.i.i121.i = add nsw i32 %142, -1
  store i32 %dec.i.i.i121.i, ptr %freereg.i.i.i120.i, align 4
  br label %freeexp.exit.i109.i

freeexp.exit.i109.i:                              ; preds = %if.then.i.i.i119.i, %land.lhs.true.i.i.i115.i, %if.then.i.i111.i, %sw.bb34.i
  %143 = load i32, ptr %v, align 8
  %cmp.i13.i.i = icmp eq i32 %143, 12
  br i1 %cmp.i13.i.i, label %if.then.i14.i.i, label %codecomp.exit.i

if.then.i14.i.i:                                  ; preds = %freeexp.exit.i109.i
  %144 = load i32, ptr %u.i.i.i71, align 8
  %and.i.i16.i.i = and i32 %144, 256
  %tobool.not.i.i17.i.i = icmp eq i32 %and.i.i16.i.i, 0
  br i1 %tobool.not.i.i17.i.i, label %land.lhs.true.i.i18.i.i, label %codecomp.exit.i

land.lhs.true.i.i18.i.i:                          ; preds = %if.then.i14.i.i
  %nactvar.i.i19.i.i = getelementptr inbounds %struct.FuncState, ptr %99, i64 0, i32 13
  %145 = load i8, ptr %nactvar.i.i19.i.i, align 2
  %conv.i.i20.i.i = zext i8 %145 to i32
  %cmp.not.i.i21.i.i = icmp slt i32 %144, %conv.i.i20.i.i
  br i1 %cmp.not.i.i21.i.i, label %codecomp.exit.i, label %if.then.i.i22.i.i

if.then.i.i22.i.i:                                ; preds = %land.lhs.true.i.i18.i.i
  %freereg.i.i23.i.i = getelementptr inbounds %struct.FuncState, ptr %99, i64 0, i32 9
  %146 = load i32, ptr %freereg.i.i23.i.i, align 4
  %dec.i.i24.i.i = add nsw i32 %146, -1
  store i32 %dec.i.i24.i.i, ptr %freereg.i.i23.i.i, align 4
  br label %codecomp.exit.i

codecomp.exit.i:                                  ; preds = %if.then.i.i22.i.i, %land.lhs.true.i.i18.i.i, %if.then.i14.i.i, %freeexp.exit.i109.i
  %call3.i.i = call fastcc i32 @condjump(ptr noundef %99, i32 noundef 23, i32 noundef 1, i32 noundef %call.i107.i, i32 noundef %call1.i.i)
  store i32 %call3.i.i, ptr %u.i.i.i71, align 8
  store i32 10, ptr %v, align 8
  br label %luaK_posfix.exit

sw.bb35.i:                                        ; preds = %luaK_infix.exit
  %call.i122.i = call fastcc i32 @luaK_exp2RK(ptr noundef %99, ptr noundef %v)
  %call1.i123.i = call fastcc i32 @luaK_exp2RK(ptr noundef %99, ptr noundef nonnull %v2)
  %147 = load i32, ptr %v2, align 8
  %cmp.i.i124.i = icmp eq i32 %147, 12
  br i1 %cmp.i.i124.i, label %if.then.i.i140.i, label %freeexp.exit.i125.i

if.then.i.i140.i:                                 ; preds = %sw.bb35.i
  %148 = load i32, ptr %u.i.i261.i, align 8
  %and.i.i.i142.i = and i32 %148, 256
  %tobool.not.i.i.i143.i = icmp eq i32 %and.i.i.i142.i, 0
  br i1 %tobool.not.i.i.i143.i, label %land.lhs.true.i.i.i144.i, label %freeexp.exit.i125.i

land.lhs.true.i.i.i144.i:                         ; preds = %if.then.i.i140.i
  %nactvar.i.i.i145.i = getelementptr inbounds %struct.FuncState, ptr %99, i64 0, i32 13
  %149 = load i8, ptr %nactvar.i.i.i145.i, align 2
  %conv.i.i.i146.i = zext i8 %149 to i32
  %cmp.not.i.i.i147.i = icmp slt i32 %148, %conv.i.i.i146.i
  br i1 %cmp.not.i.i.i147.i, label %freeexp.exit.i125.i, label %if.then.i.i.i148.i

if.then.i.i.i148.i:                               ; preds = %land.lhs.true.i.i.i144.i
  %freereg.i.i.i149.i = getelementptr inbounds %struct.FuncState, ptr %99, i64 0, i32 9
  %150 = load i32, ptr %freereg.i.i.i149.i, align 4
  %dec.i.i.i150.i = add nsw i32 %150, -1
  store i32 %dec.i.i.i150.i, ptr %freereg.i.i.i149.i, align 4
  br label %freeexp.exit.i125.i

freeexp.exit.i125.i:                              ; preds = %if.then.i.i.i148.i, %land.lhs.true.i.i.i144.i, %if.then.i.i140.i, %sw.bb35.i
  %151 = load i32, ptr %v, align 8
  %cmp.i13.i126.i = icmp eq i32 %151, 12
  br i1 %cmp.i13.i126.i, label %if.then.i14.i129.i, label %codecomp.exit151.i

if.then.i14.i129.i:                               ; preds = %freeexp.exit.i125.i
  %152 = load i32, ptr %u.i.i.i71, align 8
  %and.i.i16.i131.i = and i32 %152, 256
  %tobool.not.i.i17.i132.i = icmp eq i32 %and.i.i16.i131.i, 0
  br i1 %tobool.not.i.i17.i132.i, label %land.lhs.true.i.i18.i133.i, label %codecomp.exit151.i

land.lhs.true.i.i18.i133.i:                       ; preds = %if.then.i14.i129.i
  %nactvar.i.i19.i134.i = getelementptr inbounds %struct.FuncState, ptr %99, i64 0, i32 13
  %153 = load i8, ptr %nactvar.i.i19.i134.i, align 2
  %conv.i.i20.i135.i = zext i8 %153 to i32
  %cmp.not.i.i21.i136.i = icmp slt i32 %152, %conv.i.i20.i135.i
  br i1 %cmp.not.i.i21.i136.i, label %codecomp.exit151.i, label %if.then.i.i22.i137.i

if.then.i.i22.i137.i:                             ; preds = %land.lhs.true.i.i18.i133.i
  %freereg.i.i23.i138.i = getelementptr inbounds %struct.FuncState, ptr %99, i64 0, i32 9
  %154 = load i32, ptr %freereg.i.i23.i138.i, align 4
  %dec.i.i24.i139.i = add nsw i32 %154, -1
  store i32 %dec.i.i24.i139.i, ptr %freereg.i.i23.i138.i, align 4
  br label %codecomp.exit151.i

codecomp.exit151.i:                               ; preds = %if.then.i.i22.i137.i, %land.lhs.true.i.i18.i133.i, %if.then.i14.i129.i, %freeexp.exit.i125.i
  %call3.i127.i = call fastcc i32 @condjump(ptr noundef %99, i32 noundef 23, i32 noundef 0, i32 noundef %call.i122.i, i32 noundef %call1.i123.i)
  store i32 %call3.i127.i, ptr %u.i.i.i71, align 8
  store i32 10, ptr %v, align 8
  br label %luaK_posfix.exit

sw.bb36.i:                                        ; preds = %luaK_infix.exit
  %call.i152.i = call fastcc i32 @luaK_exp2RK(ptr noundef %99, ptr noundef %v)
  %call1.i153.i = call fastcc i32 @luaK_exp2RK(ptr noundef %99, ptr noundef nonnull %v2)
  %155 = load i32, ptr %v2, align 8
  %cmp.i.i154.i = icmp eq i32 %155, 12
  br i1 %cmp.i.i154.i, label %if.then.i.i170.i, label %freeexp.exit.i155.i

if.then.i.i170.i:                                 ; preds = %sw.bb36.i
  %156 = load i32, ptr %u.i.i261.i, align 8
  %and.i.i.i172.i = and i32 %156, 256
  %tobool.not.i.i.i173.i = icmp eq i32 %and.i.i.i172.i, 0
  br i1 %tobool.not.i.i.i173.i, label %land.lhs.true.i.i.i174.i, label %freeexp.exit.i155.i

land.lhs.true.i.i.i174.i:                         ; preds = %if.then.i.i170.i
  %nactvar.i.i.i175.i = getelementptr inbounds %struct.FuncState, ptr %99, i64 0, i32 13
  %157 = load i8, ptr %nactvar.i.i.i175.i, align 2
  %conv.i.i.i176.i = zext i8 %157 to i32
  %cmp.not.i.i.i177.i = icmp slt i32 %156, %conv.i.i.i176.i
  br i1 %cmp.not.i.i.i177.i, label %freeexp.exit.i155.i, label %if.then.i.i.i178.i

if.then.i.i.i178.i:                               ; preds = %land.lhs.true.i.i.i174.i
  %freereg.i.i.i179.i = getelementptr inbounds %struct.FuncState, ptr %99, i64 0, i32 9
  %158 = load i32, ptr %freereg.i.i.i179.i, align 4
  %dec.i.i.i180.i = add nsw i32 %158, -1
  store i32 %dec.i.i.i180.i, ptr %freereg.i.i.i179.i, align 4
  br label %freeexp.exit.i155.i

freeexp.exit.i155.i:                              ; preds = %if.then.i.i.i178.i, %land.lhs.true.i.i.i174.i, %if.then.i.i170.i, %sw.bb36.i
  %159 = load i32, ptr %v, align 8
  %cmp.i13.i156.i = icmp eq i32 %159, 12
  br i1 %cmp.i13.i156.i, label %if.then.i14.i159.i, label %codecomp.exit181.i

if.then.i14.i159.i:                               ; preds = %freeexp.exit.i155.i
  %160 = load i32, ptr %u.i.i.i71, align 8
  %and.i.i16.i161.i = and i32 %160, 256
  %tobool.not.i.i17.i162.i = icmp eq i32 %and.i.i16.i161.i, 0
  br i1 %tobool.not.i.i17.i162.i, label %land.lhs.true.i.i18.i163.i, label %codecomp.exit181.i

land.lhs.true.i.i18.i163.i:                       ; preds = %if.then.i14.i159.i
  %nactvar.i.i19.i164.i = getelementptr inbounds %struct.FuncState, ptr %99, i64 0, i32 13
  %161 = load i8, ptr %nactvar.i.i19.i164.i, align 2
  %conv.i.i20.i165.i = zext i8 %161 to i32
  %cmp.not.i.i21.i166.i = icmp slt i32 %160, %conv.i.i20.i165.i
  br i1 %cmp.not.i.i21.i166.i, label %codecomp.exit181.i, label %if.then.i.i22.i167.i

if.then.i.i22.i167.i:                             ; preds = %land.lhs.true.i.i18.i163.i
  %freereg.i.i23.i168.i = getelementptr inbounds %struct.FuncState, ptr %99, i64 0, i32 9
  %162 = load i32, ptr %freereg.i.i23.i168.i, align 4
  %dec.i.i24.i169.i = add nsw i32 %162, -1
  store i32 %dec.i.i24.i169.i, ptr %freereg.i.i23.i168.i, align 4
  br label %codecomp.exit181.i

codecomp.exit181.i:                               ; preds = %if.then.i.i22.i167.i, %land.lhs.true.i.i18.i163.i, %if.then.i14.i159.i, %freeexp.exit.i155.i
  %call3.i157.i = call fastcc i32 @condjump(ptr noundef %99, i32 noundef 24, i32 noundef 1, i32 noundef %call.i152.i, i32 noundef %call1.i153.i)
  store i32 %call3.i157.i, ptr %u.i.i.i71, align 8
  store i32 10, ptr %v, align 8
  br label %luaK_posfix.exit

sw.bb37.i:                                        ; preds = %luaK_infix.exit
  %call.i182.i = call fastcc i32 @luaK_exp2RK(ptr noundef %99, ptr noundef %v)
  %call1.i183.i = call fastcc i32 @luaK_exp2RK(ptr noundef %99, ptr noundef nonnull %v2)
  %163 = load i32, ptr %v2, align 8
  %cmp.i.i184.i = icmp eq i32 %163, 12
  br i1 %cmp.i.i184.i, label %if.then.i.i200.i, label %freeexp.exit.i185.i

if.then.i.i200.i:                                 ; preds = %sw.bb37.i
  %164 = load i32, ptr %u.i.i261.i, align 8
  %and.i.i.i202.i = and i32 %164, 256
  %tobool.not.i.i.i203.i = icmp eq i32 %and.i.i.i202.i, 0
  br i1 %tobool.not.i.i.i203.i, label %land.lhs.true.i.i.i204.i, label %freeexp.exit.i185.i

land.lhs.true.i.i.i204.i:                         ; preds = %if.then.i.i200.i
  %nactvar.i.i.i205.i = getelementptr inbounds %struct.FuncState, ptr %99, i64 0, i32 13
  %165 = load i8, ptr %nactvar.i.i.i205.i, align 2
  %conv.i.i.i206.i = zext i8 %165 to i32
  %cmp.not.i.i.i207.i = icmp slt i32 %164, %conv.i.i.i206.i
  br i1 %cmp.not.i.i.i207.i, label %freeexp.exit.i185.i, label %if.then.i.i.i208.i

if.then.i.i.i208.i:                               ; preds = %land.lhs.true.i.i.i204.i
  %freereg.i.i.i209.i = getelementptr inbounds %struct.FuncState, ptr %99, i64 0, i32 9
  %166 = load i32, ptr %freereg.i.i.i209.i, align 4
  %dec.i.i.i210.i = add nsw i32 %166, -1
  store i32 %dec.i.i.i210.i, ptr %freereg.i.i.i209.i, align 4
  br label %freeexp.exit.i185.i

freeexp.exit.i185.i:                              ; preds = %if.then.i.i.i208.i, %land.lhs.true.i.i.i204.i, %if.then.i.i200.i, %sw.bb37.i
  %167 = load i32, ptr %v, align 8
  %cmp.i13.i186.i = icmp eq i32 %167, 12
  br i1 %cmp.i13.i186.i, label %if.then.i14.i189.i, label %codecomp.exit211.i

if.then.i14.i189.i:                               ; preds = %freeexp.exit.i185.i
  %168 = load i32, ptr %u.i.i.i71, align 8
  %and.i.i16.i191.i = and i32 %168, 256
  %tobool.not.i.i17.i192.i = icmp eq i32 %and.i.i16.i191.i, 0
  br i1 %tobool.not.i.i17.i192.i, label %land.lhs.true.i.i18.i193.i, label %codecomp.exit211.i

land.lhs.true.i.i18.i193.i:                       ; preds = %if.then.i14.i189.i
  %nactvar.i.i19.i194.i = getelementptr inbounds %struct.FuncState, ptr %99, i64 0, i32 13
  %169 = load i8, ptr %nactvar.i.i19.i194.i, align 2
  %conv.i.i20.i195.i = zext i8 %169 to i32
  %cmp.not.i.i21.i196.i = icmp slt i32 %168, %conv.i.i20.i195.i
  br i1 %cmp.not.i.i21.i196.i, label %codecomp.exit211.i, label %if.then.i.i22.i197.i

if.then.i.i22.i197.i:                             ; preds = %land.lhs.true.i.i18.i193.i
  %freereg.i.i23.i198.i = getelementptr inbounds %struct.FuncState, ptr %99, i64 0, i32 9
  %170 = load i32, ptr %freereg.i.i23.i198.i, align 4
  %dec.i.i24.i199.i = add nsw i32 %170, -1
  store i32 %dec.i.i24.i199.i, ptr %freereg.i.i23.i198.i, align 4
  br label %codecomp.exit211.i

codecomp.exit211.i:                               ; preds = %if.then.i.i22.i197.i, %land.lhs.true.i.i18.i193.i, %if.then.i14.i189.i, %freeexp.exit.i185.i
  %call3.i187.i = call fastcc i32 @condjump(ptr noundef %99, i32 noundef 25, i32 noundef 1, i32 noundef %call.i182.i, i32 noundef %call1.i183.i)
  store i32 %call3.i187.i, ptr %u.i.i.i71, align 8
  store i32 10, ptr %v, align 8
  br label %luaK_posfix.exit

sw.bb38.i:                                        ; preds = %luaK_infix.exit
  %call.i212.i = call fastcc i32 @luaK_exp2RK(ptr noundef %99, ptr noundef %v)
  %call1.i213.i = call fastcc i32 @luaK_exp2RK(ptr noundef %99, ptr noundef nonnull %v2)
  %171 = load i32, ptr %v2, align 8
  %cmp.i.i214.i = icmp eq i32 %171, 12
  br i1 %cmp.i.i214.i, label %if.then.i.i230.i, label %freeexp.exit.i215.i

if.then.i.i230.i:                                 ; preds = %sw.bb38.i
  %172 = load i32, ptr %u.i.i261.i, align 8
  %and.i.i.i232.i = and i32 %172, 256
  %tobool.not.i.i.i233.i = icmp eq i32 %and.i.i.i232.i, 0
  br i1 %tobool.not.i.i.i233.i, label %land.lhs.true.i.i.i234.i, label %freeexp.exit.i215.i

land.lhs.true.i.i.i234.i:                         ; preds = %if.then.i.i230.i
  %nactvar.i.i.i235.i = getelementptr inbounds %struct.FuncState, ptr %99, i64 0, i32 13
  %173 = load i8, ptr %nactvar.i.i.i235.i, align 2
  %conv.i.i.i236.i = zext i8 %173 to i32
  %cmp.not.i.i.i237.i = icmp slt i32 %172, %conv.i.i.i236.i
  br i1 %cmp.not.i.i.i237.i, label %freeexp.exit.i215.i, label %if.then.i.i.i238.i

if.then.i.i.i238.i:                               ; preds = %land.lhs.true.i.i.i234.i
  %freereg.i.i.i239.i = getelementptr inbounds %struct.FuncState, ptr %99, i64 0, i32 9
  %174 = load i32, ptr %freereg.i.i.i239.i, align 4
  %dec.i.i.i240.i = add nsw i32 %174, -1
  store i32 %dec.i.i.i240.i, ptr %freereg.i.i.i239.i, align 4
  br label %freeexp.exit.i215.i

freeexp.exit.i215.i:                              ; preds = %if.then.i.i.i238.i, %land.lhs.true.i.i.i234.i, %if.then.i.i230.i, %sw.bb38.i
  %175 = load i32, ptr %v, align 8
  %cmp.i13.i216.i = icmp eq i32 %175, 12
  br i1 %cmp.i13.i216.i, label %if.then.i14.i219.i, label %codecomp.exit241.i

if.then.i14.i219.i:                               ; preds = %freeexp.exit.i215.i
  %176 = load i32, ptr %u.i.i.i71, align 8
  %and.i.i16.i221.i = and i32 %176, 256
  %tobool.not.i.i17.i222.i = icmp eq i32 %and.i.i16.i221.i, 0
  br i1 %tobool.not.i.i17.i222.i, label %land.lhs.true.i.i18.i223.i, label %codecomp.exit241.i

land.lhs.true.i.i18.i223.i:                       ; preds = %if.then.i14.i219.i
  %nactvar.i.i19.i224.i = getelementptr inbounds %struct.FuncState, ptr %99, i64 0, i32 13
  %177 = load i8, ptr %nactvar.i.i19.i224.i, align 2
  %conv.i.i20.i225.i = zext i8 %177 to i32
  %cmp.not.i.i21.i226.i = icmp slt i32 %176, %conv.i.i20.i225.i
  br i1 %cmp.not.i.i21.i226.i, label %codecomp.exit241.i, label %if.then.i.i22.i227.i

if.then.i.i22.i227.i:                             ; preds = %land.lhs.true.i.i18.i223.i
  %freereg.i.i23.i228.i = getelementptr inbounds %struct.FuncState, ptr %99, i64 0, i32 9
  %178 = load i32, ptr %freereg.i.i23.i228.i, align 4
  %dec.i.i24.i229.i = add nsw i32 %178, -1
  store i32 %dec.i.i24.i229.i, ptr %freereg.i.i23.i228.i, align 4
  br label %codecomp.exit241.i

codecomp.exit241.i:                               ; preds = %if.then.i.i22.i227.i, %land.lhs.true.i.i18.i223.i, %if.then.i14.i219.i, %freeexp.exit.i215.i
  %call3.i217.i = call fastcc i32 @condjump(ptr noundef %99, i32 noundef 24, i32 noundef 1, i32 noundef %call1.i213.i, i32 noundef %call.i212.i)
  store i32 %call3.i217.i, ptr %u.i.i.i71, align 8
  store i32 10, ptr %v, align 8
  br label %luaK_posfix.exit

sw.bb39.i:                                        ; preds = %luaK_infix.exit
  %call.i242.i = call fastcc i32 @luaK_exp2RK(ptr noundef %99, ptr noundef %v)
  %call1.i243.i = call fastcc i32 @luaK_exp2RK(ptr noundef %99, ptr noundef nonnull %v2)
  %179 = load i32, ptr %v2, align 8
  %cmp.i.i244.i = icmp eq i32 %179, 12
  br i1 %cmp.i.i244.i, label %if.then.i.i260.i, label %freeexp.exit.i245.i

if.then.i.i260.i:                                 ; preds = %sw.bb39.i
  %180 = load i32, ptr %u.i.i261.i, align 8
  %and.i.i.i262.i = and i32 %180, 256
  %tobool.not.i.i.i263.i = icmp eq i32 %and.i.i.i262.i, 0
  br i1 %tobool.not.i.i.i263.i, label %land.lhs.true.i.i.i264.i, label %freeexp.exit.i245.i

land.lhs.true.i.i.i264.i:                         ; preds = %if.then.i.i260.i
  %nactvar.i.i.i265.i = getelementptr inbounds %struct.FuncState, ptr %99, i64 0, i32 13
  %181 = load i8, ptr %nactvar.i.i.i265.i, align 2
  %conv.i.i.i266.i = zext i8 %181 to i32
  %cmp.not.i.i.i267.i = icmp slt i32 %180, %conv.i.i.i266.i
  br i1 %cmp.not.i.i.i267.i, label %freeexp.exit.i245.i, label %if.then.i.i.i268.i

if.then.i.i.i268.i:                               ; preds = %land.lhs.true.i.i.i264.i
  %freereg.i.i.i269.i = getelementptr inbounds %struct.FuncState, ptr %99, i64 0, i32 9
  %182 = load i32, ptr %freereg.i.i.i269.i, align 4
  %dec.i.i.i270.i = add nsw i32 %182, -1
  store i32 %dec.i.i.i270.i, ptr %freereg.i.i.i269.i, align 4
  br label %freeexp.exit.i245.i

freeexp.exit.i245.i:                              ; preds = %if.then.i.i.i268.i, %land.lhs.true.i.i.i264.i, %if.then.i.i260.i, %sw.bb39.i
  %183 = load i32, ptr %v, align 8
  %cmp.i13.i246.i = icmp eq i32 %183, 12
  br i1 %cmp.i13.i246.i, label %if.then.i14.i249.i, label %codecomp.exit271.i

if.then.i14.i249.i:                               ; preds = %freeexp.exit.i245.i
  %184 = load i32, ptr %u.i.i.i71, align 8
  %and.i.i16.i251.i = and i32 %184, 256
  %tobool.not.i.i17.i252.i = icmp eq i32 %and.i.i16.i251.i, 0
  br i1 %tobool.not.i.i17.i252.i, label %land.lhs.true.i.i18.i253.i, label %codecomp.exit271.i

land.lhs.true.i.i18.i253.i:                       ; preds = %if.then.i14.i249.i
  %nactvar.i.i19.i254.i = getelementptr inbounds %struct.FuncState, ptr %99, i64 0, i32 13
  %185 = load i8, ptr %nactvar.i.i19.i254.i, align 2
  %conv.i.i20.i255.i = zext i8 %185 to i32
  %cmp.not.i.i21.i256.i = icmp slt i32 %184, %conv.i.i20.i255.i
  br i1 %cmp.not.i.i21.i256.i, label %codecomp.exit271.i, label %if.then.i.i22.i257.i

if.then.i.i22.i257.i:                             ; preds = %land.lhs.true.i.i18.i253.i
  %freereg.i.i23.i258.i = getelementptr inbounds %struct.FuncState, ptr %99, i64 0, i32 9
  %186 = load i32, ptr %freereg.i.i23.i258.i, align 4
  %dec.i.i24.i259.i = add nsw i32 %186, -1
  store i32 %dec.i.i24.i259.i, ptr %freereg.i.i23.i258.i, align 4
  br label %codecomp.exit271.i

codecomp.exit271.i:                               ; preds = %if.then.i.i22.i257.i, %land.lhs.true.i.i18.i253.i, %if.then.i14.i249.i, %freeexp.exit.i245.i
  %call3.i247.i = call fastcc i32 @condjump(ptr noundef %99, i32 noundef 25, i32 noundef 1, i32 noundef %call1.i243.i, i32 noundef %call.i242.i)
  store i32 %call3.i247.i, ptr %u.i.i.i71, align 8
  store i32 10, ptr %v, align 8
  br label %luaK_posfix.exit

luaK_posfix.exit:                                 ; preds = %luaK_infix.exit, %luaK_concat.exit.i, %luaK_concat.exit99.i, %freeexp.exit.i, %luaK_exp2nextreg.exit.i124, %sw.bb28.i, %sw.bb29.i, %sw.bb30.i, %sw.bb31.i, %sw.bb32.i, %sw.bb33.i, %codecomp.exit.i, %codecomp.exit151.i, %codecomp.exit181.i, %codecomp.exit211.i, %codecomp.exit241.i, %codecomp.exit271.i
  %call12212 = phi i32 [ %call12, %luaK_infix.exit ], [ %call12211, %luaK_concat.exit.i ], [ %call12, %luaK_concat.exit99.i ], [ %call12217, %freeexp.exit.i ], [ %call12217, %luaK_exp2nextreg.exit.i124 ], [ %call12, %sw.bb28.i ], [ %call12, %sw.bb29.i ], [ %call12, %sw.bb30.i ], [ %call12, %sw.bb31.i ], [ %call12, %sw.bb32.i ], [ %call12, %sw.bb33.i ], [ %call12, %codecomp.exit.i ], [ %call12, %codecomp.exit151.i ], [ %call12, %codecomp.exit181.i ], [ %call12, %codecomp.exit211.i ], [ %call12, %codecomp.exit241.i ], [ %call12, %codecomp.exit271.i ]
  %cmp5.not = icmp eq i32 %call12212, 15
  br i1 %cmp5.not, label %while.end, label %land.rhs, !llvm.loop !113

while.end:                                        ; preds = %land.rhs, %luaK_posfix.exit, %if.end
  %op.0.lcssa = phi i32 [ 15, %if.end ], [ 15, %luaK_posfix.exit ], [ %op.0237, %land.rhs ]
  %187 = load ptr, ptr %L.i, align 8
  %nCcalls = getelementptr inbounds %struct.lua_State, ptr %187, i64 0, i32 15
  %188 = load i16, ptr %nCcalls, align 8
  %dec = add i16 %188, -1
  store i16 %dec, ptr %nCcalls, align 8
  ret i32 %op.0.lcssa
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @luaK_exp2anyreg(ptr nocapture noundef %fs, ptr nocapture noundef %e) unnamed_addr #0 {
entry:
  tail call fastcc void @luaK_dischargevars(ptr noundef %fs, ptr noundef %e)
  %0 = load i32, ptr %e, align 8
  %cmp = icmp eq i32 %0, 12
  br i1 %cmp, label %if.then, label %if.end13

if.then:                                          ; preds = %entry
  %t = getelementptr inbounds %struct.expdesc, ptr %e, i64 0, i32 2
  %1 = load i32, ptr %t, align 8
  %f = getelementptr inbounds %struct.expdesc, ptr %e, i64 0, i32 3
  %2 = load i32, ptr %f, align 4
  %cmp1.not = icmp eq i32 %1, %2
  %u = getelementptr inbounds %struct.expdesc, ptr %e, i64 0, i32 1
  br i1 %cmp1.not, label %return, label %if.end

if.end:                                           ; preds = %if.then
  %3 = load i32, ptr %u, align 8
  %nactvar = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 13
  %4 = load i8, ptr %nactvar, align 2
  %conv = zext i8 %4 to i32
  %cmp5.not = icmp slt i32 %3, %conv
  br i1 %cmp5.not, label %if.end13, label %if.then7

if.then7:                                         ; preds = %if.end
  tail call fastcc void @exp2reg(ptr noundef nonnull %fs, ptr noundef nonnull %e, i32 noundef %3)
  br label %return

if.end13:                                         ; preds = %if.end, %entry
  tail call fastcc void @luaK_dischargevars(ptr noundef %fs, ptr noundef nonnull %e)
  %5 = load i32, ptr %e, align 8
  %cmp.i.i = icmp eq i32 %5, 12
  br i1 %cmp.i.i, label %if.then.i.i, label %freeexp.exit.i

if.then.i.i:                                      ; preds = %if.end13
  %u.i.i = getelementptr inbounds %struct.expdesc, ptr %e, i64 0, i32 1
  %6 = load i32, ptr %u.i.i, align 8
  %and.i.i.i = and i32 %6, 256
  %tobool.not.i.i.i = icmp eq i32 %and.i.i.i, 0
  br i1 %tobool.not.i.i.i, label %land.lhs.true.i.i.i, label %freeexp.exit.i

land.lhs.true.i.i.i:                              ; preds = %if.then.i.i
  %nactvar.i.i.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 13
  %7 = load i8, ptr %nactvar.i.i.i, align 2
  %conv.i.i.i = zext i8 %7 to i32
  %cmp.not.i.i.i = icmp slt i32 %6, %conv.i.i.i
  br i1 %cmp.not.i.i.i, label %freeexp.exit.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %land.lhs.true.i.i.i
  %freereg.i.i.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 9
  %8 = load i32, ptr %freereg.i.i.i, align 4
  %dec.i.i.i = add nsw i32 %8, -1
  store i32 %dec.i.i.i, ptr %freereg.i.i.i, align 4
  br label %freeexp.exit.i

freeexp.exit.i:                                   ; preds = %if.then.i.i.i, %land.lhs.true.i.i.i, %if.then.i.i, %if.end13
  %freereg.i.i7.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 9
  %9 = load i32, ptr %freereg.i.i7.i, align 4
  %add.i.i.i = add nsw i32 %9, 1
  %10 = load ptr, ptr %fs, align 8
  %maxstacksize.i.i.i = getelementptr inbounds %struct.Proto, ptr %10, i64 0, i32 22
  %11 = load i8, ptr %maxstacksize.i.i.i, align 1
  %conv.i.i8.i = zext i8 %11 to i32
  %cmp.i.i.not.i = icmp slt i32 %9, %conv.i.i8.i
  br i1 %cmp.i.i.not.i, label %luaK_exp2nextreg.exit, label %if.then.i.i9.i

if.then.i.i9.i:                                   ; preds = %freeexp.exit.i
  %cmp2.i.i.i = icmp sgt i32 %9, 248
  br i1 %cmp2.i.i.i, label %if.then4.i.i.i, label %if.end.i.i.i

if.then4.i.i.i:                                   ; preds = %if.then.i.i9.i
  %ls.i.i.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 3
  %12 = load ptr, ptr %ls.i.i.i, align 8
  %t.i.i.i.i = getelementptr inbounds %struct.LexState, ptr %12, i64 0, i32 3
  %13 = load i32, ptr %t.i.i.i.i, align 8
  tail call fastcc void @luaX_lexerror(ptr noundef %12, ptr noundef nonnull @.str.150, i32 noundef %13)
  unreachable

if.end.i.i.i:                                     ; preds = %if.then.i.i9.i
  %conv5.i.i.i = trunc i32 %add.i.i.i to i8
  store i8 %conv5.i.i.i, ptr %maxstacksize.i.i.i, align 1
  %.pre.i.i = load i32, ptr %freereg.i.i7.i, align 4
  %.pre3.i.i = add nsw i32 %.pre.i.i, 1
  br label %luaK_exp2nextreg.exit

luaK_exp2nextreg.exit:                            ; preds = %freeexp.exit.i, %if.end.i.i.i
  %add.pre-phi.i.i = phi i32 [ %add.i.i.i, %freeexp.exit.i ], [ %.pre3.i.i, %if.end.i.i.i ]
  store i32 %add.pre-phi.i.i, ptr %freereg.i.i7.i, align 4
  %sub.i = add nsw i32 %add.pre-phi.i.i, -1
  tail call fastcc void @exp2reg(ptr noundef nonnull %fs, ptr noundef nonnull %e, i32 noundef %sub.i)
  %u14 = getelementptr inbounds %struct.expdesc, ptr %e, i64 0, i32 1
  br label %return

return:                                           ; preds = %if.then, %luaK_exp2nextreg.exit, %if.then7
  %retval.0.in = phi ptr [ %u, %if.then7 ], [ %u14, %luaK_exp2nextreg.exit ], [ %u, %if.then ]
  %retval.0 = load i32, ptr %retval.0.in, align 8
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal fastcc void @codearith(ptr nocapture noundef %fs, i32 noundef %op, ptr nocapture noundef %e1, ptr nocapture noundef %e2) unnamed_addr #0 {
entry:
  %0 = load i32, ptr %e1, align 8
  %cmp.i.i = icmp eq i32 %0, 5
  br i1 %cmp.i.i, label %land.lhs.true.i.i, label %if.else

land.lhs.true.i.i:                                ; preds = %entry
  %t.i.i = getelementptr inbounds %struct.expdesc, ptr %e1, i64 0, i32 2
  %1 = load i32, ptr %t.i.i, align 8
  %cmp1.i.i = icmp eq i32 %1, -1
  br i1 %cmp1.i.i, label %isnumeral.exit.i, label %if.else

isnumeral.exit.i:                                 ; preds = %land.lhs.true.i.i
  %f.i.i = getelementptr inbounds %struct.expdesc, ptr %e1, i64 0, i32 3
  %2 = load i32, ptr %f.i.i, align 4
  %cmp2.i.not.i = icmp eq i32 %2, -1
  br i1 %cmp2.i.not.i, label %lor.lhs.false.i, label %if.else

lor.lhs.false.i:                                  ; preds = %isnumeral.exit.i
  %3 = load i32, ptr %e2, align 8
  %cmp.i21.i = icmp eq i32 %3, 5
  br i1 %cmp.i21.i, label %land.lhs.true.i23.i, label %if.else

land.lhs.true.i23.i:                              ; preds = %lor.lhs.false.i
  %t.i24.i = getelementptr inbounds %struct.expdesc, ptr %e2, i64 0, i32 2
  %4 = load i32, ptr %t.i24.i, align 8
  %cmp1.i25.i = icmp eq i32 %4, -1
  br i1 %cmp1.i25.i, label %isnumeral.exit29.i, label %if.else

isnumeral.exit29.i:                               ; preds = %land.lhs.true.i23.i
  %f.i27.i = getelementptr inbounds %struct.expdesc, ptr %e2, i64 0, i32 3
  %5 = load i32, ptr %f.i27.i, align 4
  %cmp2.i28.not.i = icmp eq i32 %5, -1
  br i1 %cmp2.i28.not.i, label %if.end.i, label %if.else

if.end.i:                                         ; preds = %isnumeral.exit29.i
  %u.i = getelementptr inbounds %struct.expdesc, ptr %e1, i64 0, i32 1
  %6 = load double, ptr %u.i, align 8
  %u3.i = getelementptr inbounds %struct.expdesc, ptr %e2, i64 0, i32 1
  %7 = load double, ptr %u3.i, align 8
  switch i32 %op, label %constfolding.exit [
    i32 12, label %sw.bb.i
    i32 13, label %sw.bb4.i
    i32 14, label %sw.bb5.i
    i32 15, label %sw.bb6.i
    i32 16, label %sw.bb9.i
    i32 17, label %sw.bb15.i
    i32 18, label %sw.bb17.i
    i32 20, label %cond.end
  ]

sw.bb.i:                                          ; preds = %if.end.i
  %add.i = fadd double %6, %7
  br label %sw.epilog.i

sw.bb4.i:                                         ; preds = %if.end.i
  %sub.i = fsub double %6, %7
  br label %sw.epilog.i

sw.bb5.i:                                         ; preds = %if.end.i
  %mul.i = fmul double %6, %7
  br label %sw.epilog.i

sw.bb6.i:                                         ; preds = %if.end.i
  %cmp.i = fcmp oeq double %7, 0.000000e+00
  br i1 %cmp.i, label %cond.true, label %if.end8.i

if.end8.i:                                        ; preds = %sw.bb6.i
  %div.i = fdiv double %6, %7
  br label %sw.epilog.i

sw.bb9.i:                                         ; preds = %if.end.i
  %cmp10.i = fcmp oeq double %7, 0.000000e+00
  br i1 %cmp10.i, label %cond.true, label %if.end12.i

if.end12.i:                                       ; preds = %sw.bb9.i
  %div13.i = fdiv double %6, %7
  %8 = tail call double @llvm.floor.f64(double %div13.i)
  %neg.i = fneg double %8
  %9 = tail call double @llvm.fmuladd.f64(double %neg.i, double %7, double %6)
  br label %sw.epilog.i

sw.bb15.i:                                        ; preds = %if.end.i
  %call16.i = tail call double @pow(double noundef %6, double noundef %7) #35
  br label %sw.epilog.i

sw.bb17.i:                                        ; preds = %if.end.i
  %fneg.i = fneg double %6
  br label %sw.epilog.i

sw.epilog.i:                                      ; preds = %sw.bb17.i, %sw.bb15.i, %if.end12.i, %if.end8.i, %sw.bb5.i, %sw.bb4.i, %sw.bb.i
  %r.0.i = phi double [ %fneg.i, %sw.bb17.i ], [ %call16.i, %sw.bb15.i ], [ %9, %if.end12.i ], [ %div.i, %if.end8.i ], [ %mul.i, %sw.bb5.i ], [ %sub.i, %sw.bb4.i ], [ %add.i, %sw.bb.i ]
  %cmp19.i = fcmp ord double %r.0.i, 0.000000e+00
  br i1 %cmp19.i, label %constfolding.exit, label %if.else

constfolding.exit:                                ; preds = %if.end.i, %sw.epilog.i
  %r.036.i = phi double [ %r.0.i, %sw.epilog.i ], [ 0.000000e+00, %if.end.i ]
  store double %r.036.i, ptr %u.i, align 8
  br label %if.end8

if.else:                                          ; preds = %isnumeral.exit29.i, %isnumeral.exit.i, %sw.epilog.i, %land.lhs.true.i.i, %entry, %land.lhs.true.i23.i, %lor.lhs.false.i
  switch i32 %op, label %cond.true [
    i32 20, label %cond.end
    i32 18, label %cond.end
  ]

cond.true:                                        ; preds = %sw.bb9.i, %sw.bb6.i, %if.else
  %call2 = tail call fastcc i32 @luaK_exp2RK(ptr noundef %fs, ptr noundef %e2)
  br label %cond.end

cond.end:                                         ; preds = %if.end.i, %if.else, %if.else, %cond.true
  %cond = phi i32 [ %call2, %cond.true ], [ 0, %if.else ], [ 0, %if.else ], [ 0, %if.end.i ]
  %call3 = tail call fastcc i32 @luaK_exp2RK(ptr noundef %fs, ptr noundef nonnull %e1)
  %cmp4 = icmp sgt i32 %call3, %cond
  br i1 %cmp4, label %if.then5, label %if.else6

if.then5:                                         ; preds = %cond.end
  %10 = load i32, ptr %e1, align 8
  %cmp.i20 = icmp eq i32 %10, 12
  br i1 %cmp.i20, label %if.then.i, label %freeexp.exit

if.then.i:                                        ; preds = %if.then5
  %u.i22 = getelementptr inbounds %struct.expdesc, ptr %e1, i64 0, i32 1
  %11 = load i32, ptr %u.i22, align 8
  %and.i.i = and i32 %11, 256
  %tobool.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i.i, label %land.lhs.true.i.i23, label %freeexp.exit

land.lhs.true.i.i23:                              ; preds = %if.then.i
  %nactvar.i.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 13
  %12 = load i8, ptr %nactvar.i.i, align 2
  %conv.i.i = zext i8 %12 to i32
  %cmp.not.i.i = icmp slt i32 %11, %conv.i.i
  br i1 %cmp.not.i.i, label %freeexp.exit, label %if.then.i.i

if.then.i.i:                                      ; preds = %land.lhs.true.i.i23
  %freereg.i.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 9
  %13 = load i32, ptr %freereg.i.i, align 4
  %dec.i.i = add nsw i32 %13, -1
  store i32 %dec.i.i, ptr %freereg.i.i, align 4
  br label %freeexp.exit

freeexp.exit:                                     ; preds = %if.then5, %if.then.i, %land.lhs.true.i.i23, %if.then.i.i
  %14 = load i32, ptr %e2, align 8
  %cmp.i24 = icmp eq i32 %14, 12
  br i1 %cmp.i24, label %if.then.i26, label %if.end

if.then.i26:                                      ; preds = %freeexp.exit
  %u.i27 = getelementptr inbounds %struct.expdesc, ptr %e2, i64 0, i32 1
  %15 = load i32, ptr %u.i27, align 8
  %and.i.i28 = and i32 %15, 256
  %tobool.not.i.i29 = icmp eq i32 %and.i.i28, 0
  br i1 %tobool.not.i.i29, label %land.lhs.true.i.i30, label %if.end

land.lhs.true.i.i30:                              ; preds = %if.then.i26
  %nactvar.i.i31 = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 13
  %16 = load i8, ptr %nactvar.i.i31, align 2
  %conv.i.i32 = zext i8 %16 to i32
  %cmp.not.i.i33 = icmp slt i32 %15, %conv.i.i32
  br i1 %cmp.not.i.i33, label %if.end, label %if.end.sink.split

if.else6:                                         ; preds = %cond.end
  %17 = load i32, ptr %e2, align 8
  %cmp.i38 = icmp eq i32 %17, 12
  br i1 %cmp.i38, label %if.then.i40, label %freeexp.exit51

if.then.i40:                                      ; preds = %if.else6
  %u.i41 = getelementptr inbounds %struct.expdesc, ptr %e2, i64 0, i32 1
  %18 = load i32, ptr %u.i41, align 8
  %and.i.i42 = and i32 %18, 256
  %tobool.not.i.i43 = icmp eq i32 %and.i.i42, 0
  br i1 %tobool.not.i.i43, label %land.lhs.true.i.i44, label %freeexp.exit51

land.lhs.true.i.i44:                              ; preds = %if.then.i40
  %nactvar.i.i45 = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 13
  %19 = load i8, ptr %nactvar.i.i45, align 2
  %conv.i.i46 = zext i8 %19 to i32
  %cmp.not.i.i47 = icmp slt i32 %18, %conv.i.i46
  br i1 %cmp.not.i.i47, label %freeexp.exit51, label %if.then.i.i48

if.then.i.i48:                                    ; preds = %land.lhs.true.i.i44
  %freereg.i.i49 = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 9
  %20 = load i32, ptr %freereg.i.i49, align 4
  %dec.i.i50 = add nsw i32 %20, -1
  store i32 %dec.i.i50, ptr %freereg.i.i49, align 4
  br label %freeexp.exit51

freeexp.exit51:                                   ; preds = %if.else6, %if.then.i40, %land.lhs.true.i.i44, %if.then.i.i48
  %21 = load i32, ptr %e1, align 8
  %cmp.i52 = icmp eq i32 %21, 12
  br i1 %cmp.i52, label %if.then.i54, label %if.end

if.then.i54:                                      ; preds = %freeexp.exit51
  %u.i55 = getelementptr inbounds %struct.expdesc, ptr %e1, i64 0, i32 1
  %22 = load i32, ptr %u.i55, align 8
  %and.i.i56 = and i32 %22, 256
  %tobool.not.i.i57 = icmp eq i32 %and.i.i56, 0
  br i1 %tobool.not.i.i57, label %land.lhs.true.i.i58, label %if.end

land.lhs.true.i.i58:                              ; preds = %if.then.i54
  %nactvar.i.i59 = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 13
  %23 = load i8, ptr %nactvar.i.i59, align 2
  %conv.i.i60 = zext i8 %23 to i32
  %cmp.not.i.i61 = icmp slt i32 %22, %conv.i.i60
  br i1 %cmp.not.i.i61, label %if.end, label %if.end.sink.split

if.end.sink.split:                                ; preds = %land.lhs.true.i.i58, %land.lhs.true.i.i30
  %freereg.i.i35 = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 9
  %24 = load i32, ptr %freereg.i.i35, align 4
  %dec.i.i64 = add nsw i32 %24, -1
  store i32 %dec.i.i64, ptr %freereg.i.i35, align 4
  br label %if.end

if.end:                                           ; preds = %if.end.sink.split, %land.lhs.true.i.i58, %if.then.i54, %freeexp.exit51, %land.lhs.true.i.i30, %if.then.i26, %freeexp.exit
  %shl2.i = shl i32 %call3, 23
  %shl4.i = shl i32 %cond, 14
  %25 = or i32 %shl4.i, %shl2.i
  %or5.i = or i32 %25, %op
  %ls.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 3
  %26 = load ptr, ptr %ls.i, align 8
  %lastline.i = getelementptr inbounds %struct.LexState, ptr %26, i64 0, i32 2
  %27 = load i32, ptr %lastline.i, align 8
  %call.i = tail call fastcc i32 @luaK_code(ptr noundef %fs, i32 noundef %or5.i, i32 noundef %27)
  %u = getelementptr inbounds %struct.expdesc, ptr %e1, i64 0, i32 1
  store i32 %call.i, ptr %u, align 8
  store i32 11, ptr %e1, align 8
  br label %if.end8

if.end8:                                          ; preds = %constfolding.exit, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaK_dischargevars(ptr nocapture noundef %fs, ptr nocapture noundef %e) unnamed_addr #0 {
entry:
  %0 = load i32, ptr %e, align 8
  switch i32 %0, label %sw.epilog [
    i32 6, label %sw.bb
    i32 7, label %sw.bb2
    i32 8, label %sw.bb6
    i32 9, label %sw.bb13
    i32 13, label %if.then.i40
    i32 14, label %if.then6.i
  ]

sw.bb:                                            ; preds = %entry
  store i32 12, ptr %e, align 8
  br label %sw.epilog

sw.bb2:                                           ; preds = %entry
  %u = getelementptr inbounds %struct.expdesc, ptr %e, i64 0, i32 1
  %1 = load i32, ptr %u, align 8
  %shl2.i = shl i32 %1, 23
  %or3.i = or disjoint i32 %shl2.i, 4
  %ls.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 3
  %2 = load ptr, ptr %ls.i, align 8
  %lastline.i = getelementptr inbounds %struct.LexState, ptr %2, i64 0, i32 2
  %3 = load i32, ptr %lastline.i, align 8
  %call.i = tail call fastcc i32 @luaK_code(ptr noundef %fs, i32 noundef %or3.i, i32 noundef %3)
  store i32 %call.i, ptr %u, align 8
  store i32 11, ptr %e, align 8
  br label %sw.epilog

sw.bb6:                                           ; preds = %entry
  %u7 = getelementptr inbounds %struct.expdesc, ptr %e, i64 0, i32 1
  %4 = load i32, ptr %u7, align 8
  %shl2.i20 = shl i32 %4, 14
  %or3.i21 = or disjoint i32 %shl2.i20, 5
  %ls.i22 = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 3
  %5 = load ptr, ptr %ls.i22, align 8
  %lastline.i23 = getelementptr inbounds %struct.LexState, ptr %5, i64 0, i32 2
  %6 = load i32, ptr %lastline.i23, align 8
  %call.i24 = tail call fastcc i32 @luaK_code(ptr noundef %fs, i32 noundef %or3.i21, i32 noundef %6)
  store i32 %call.i24, ptr %u7, align 8
  store i32 11, ptr %e, align 8
  br label %sw.epilog

sw.bb13:                                          ; preds = %entry
  %u14 = getelementptr inbounds %struct.expdesc, ptr %e, i64 0, i32 1
  %aux = getelementptr inbounds i8, ptr %e, i64 12
  %7 = load i32, ptr %aux, align 4
  %and.i = and i32 %7, 256
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %land.lhs.true.i, label %freereg.exit

land.lhs.true.i:                                  ; preds = %sw.bb13
  %nactvar.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 13
  %8 = load i8, ptr %nactvar.i, align 2
  %conv.i = zext i8 %8 to i32
  %cmp.not.i = icmp slt i32 %7, %conv.i
  br i1 %cmp.not.i, label %freereg.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true.i
  %freereg.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 9
  %9 = load i32, ptr %freereg.i, align 4
  %dec.i = add nsw i32 %9, -1
  store i32 %dec.i, ptr %freereg.i, align 4
  br label %freereg.exit

freereg.exit:                                     ; preds = %sw.bb13, %land.lhs.true.i, %if.then.i
  %10 = load i32, ptr %u14, align 8
  %and.i25 = and i32 %10, 256
  %tobool.not.i26 = icmp eq i32 %and.i25, 0
  br i1 %tobool.not.i26, label %land.lhs.true.i27, label %freereg.exit34

land.lhs.true.i27:                                ; preds = %freereg.exit
  %nactvar.i28 = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 13
  %11 = load i8, ptr %nactvar.i28, align 2
  %conv.i29 = zext i8 %11 to i32
  %cmp.not.i30 = icmp slt i32 %10, %conv.i29
  br i1 %cmp.not.i30, label %freereg.exit34, label %if.then.i31

if.then.i31:                                      ; preds = %land.lhs.true.i27
  %freereg.i32 = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 9
  %12 = load i32, ptr %freereg.i32, align 4
  %dec.i33 = add nsw i32 %12, -1
  store i32 %dec.i33, ptr %freereg.i32, align 4
  %.pre = load i32, ptr %u14, align 8
  br label %freereg.exit34

freereg.exit34:                                   ; preds = %freereg.exit, %land.lhs.true.i27, %if.then.i31
  %13 = phi i32 [ %10, %freereg.exit ], [ %10, %land.lhs.true.i27 ], [ %.pre, %if.then.i31 ]
  %14 = load i32, ptr %aux, align 4
  %shl2.i35 = shl i32 %13, 23
  %shl4.i = shl i32 %14, 14
  %or3.i36 = or i32 %shl2.i35, %shl4.i
  %or5.i = or disjoint i32 %or3.i36, 6
  %ls.i37 = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 3
  %15 = load ptr, ptr %ls.i37, align 8
  %lastline.i38 = getelementptr inbounds %struct.LexState, ptr %15, i64 0, i32 2
  %16 = load i32, ptr %lastline.i38, align 8
  %call.i39 = tail call fastcc i32 @luaK_code(ptr noundef %fs, i32 noundef %or5.i, i32 noundef %16)
  store i32 %call.i39, ptr %u14, align 8
  store i32 11, ptr %e, align 8
  br label %sw.epilog

if.then.i40:                                      ; preds = %entry
  store i32 12, ptr %e, align 8
  %17 = load ptr, ptr %fs, align 8
  %code.i = getelementptr inbounds %struct.Proto, ptr %17, i64 0, i32 4
  %18 = load ptr, ptr %code.i, align 8
  %u.i = getelementptr inbounds %struct.expdesc, ptr %e, i64 0, i32 1
  %19 = load i32, ptr %u.i, align 8
  %idxprom.i = sext i32 %19 to i64
  %arrayidx.i = getelementptr inbounds i32, ptr %18, i64 %idxprom.i
  %20 = load i32, ptr %arrayidx.i, align 4
  %shr.i = lshr i32 %20, 6
  %and.i41 = and i32 %shr.i, 255
  store i32 %and.i41, ptr %u.i, align 8
  br label %sw.epilog

if.then6.i:                                       ; preds = %entry
  %21 = load ptr, ptr %fs, align 8
  %code8.i = getelementptr inbounds %struct.Proto, ptr %21, i64 0, i32 4
  %22 = load ptr, ptr %code8.i, align 8
  %u9.i = getelementptr inbounds %struct.expdesc, ptr %e, i64 0, i32 1
  %23 = load i32, ptr %u9.i, align 8
  %idxprom11.i = sext i32 %23 to i64
  %arrayidx12.i = getelementptr inbounds i32, ptr %22, i64 %idxprom11.i
  %24 = load i32, ptr %arrayidx12.i, align 4
  %and13.i = and i32 %24, 8388607
  %or.i = or disjoint i32 %and13.i, 16777216
  store i32 %or.i, ptr %arrayidx12.i, align 4
  store i32 11, ptr %e, align 8
  br label %sw.epilog

sw.epilog:                                        ; preds = %entry, %if.then6.i, %if.then.i40, %freereg.exit34, %sw.bb6, %sw.bb2, %sw.bb
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @exp2reg(ptr nocapture noundef %fs, ptr nocapture noundef %e, i32 noundef %reg) unnamed_addr #0 {
entry:
  tail call fastcc void @discharge2reg(ptr noundef %fs, ptr noundef %e, i32 noundef %reg)
  %0 = load i32, ptr %e, align 8
  %cmp = icmp eq i32 %0, 10
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %t = getelementptr inbounds %struct.expdesc, ptr %e, i64 0, i32 2
  %u = getelementptr inbounds %struct.expdesc, ptr %e, i64 0, i32 1
  %1 = load i32, ptr %u, align 8
  %cmp.i = icmp eq i32 %1, -1
  br i1 %cmp.i, label %if.end, label %if.else.i

if.else.i:                                        ; preds = %if.then
  %2 = load i32, ptr %t, align 4
  %cmp1.i = icmp eq i32 %2, -1
  br i1 %cmp1.i, label %if.then2.i, label %while.cond.preheader.i

while.cond.preheader.i:                           ; preds = %if.else.i
  %fs.val.i = load ptr, ptr %fs, align 8
  %3 = getelementptr i8, ptr %fs.val.i, i64 24
  %fs.val.val.i = load ptr, ptr %3, align 8
  br label %while.cond.i

if.then2.i:                                       ; preds = %if.else.i
  store i32 %1, ptr %t, align 4
  br label %if.end

while.cond.i:                                     ; preds = %while.cond.i, %while.cond.preheader.i
  %list.0.i = phi i32 [ %add1.i.i, %while.cond.i ], [ %2, %while.cond.preheader.i ]
  %idxprom.i.i = sext i32 %list.0.i to i64
  %arrayidx.i.i = getelementptr inbounds i32, ptr %fs.val.val.i, i64 %idxprom.i.i
  %4 = load i32, ptr %arrayidx.i.i, align 4
  %shr.i.i = lshr i32 %4, 14
  %sub.i.i = add nsw i32 %shr.i.i, -131071
  %cmp.i.i = icmp eq i32 %sub.i.i, -1
  %add.i.i = add nuw nsw i32 %list.0.i, 1
  %add1.i.i = add nsw i32 %add.i.i, %sub.i.i
  %cmp4.not12.i = icmp eq i32 %add1.i.i, -1
  %cmp4.not.i = select i1 %cmp.i.i, i1 true, i1 %cmp4.not12.i
  br i1 %cmp4.not.i, label %while.end.i, label %while.cond.i, !llvm.loop !94

while.end.i:                                      ; preds = %while.cond.i
  %add.neg.i.i = xor i32 %list.0.i, -1
  %sub.i7.i = add i32 %1, %add.neg.i.i
  %5 = tail call i32 @llvm.abs.i32(i32 %sub.i7.i, i1 true)
  %cmp.i8.i = icmp ugt i32 %5, 131071
  br i1 %cmp.i8.i, label %if.then.i.i, label %fixjump.exit.i

if.then.i.i:                                      ; preds = %while.end.i
  %ls.i.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 3
  %6 = load ptr, ptr %ls.i.i, align 8
  %t.i.i.i = getelementptr inbounds %struct.LexState, ptr %6, i64 0, i32 3
  %7 = load i32, ptr %t.i.i.i, align 8
  tail call fastcc void @luaX_lexerror(ptr noundef %6, ptr noundef nonnull @.str.148, i32 noundef %7)
  unreachable

fixjump.exit.i:                                   ; preds = %while.end.i
  %arrayidx.i.i.le = getelementptr inbounds i32, ptr %fs.val.val.i, i64 %idxprom.i.i
  %and.i.i = and i32 %4, 16383
  %add1.i11.i = shl i32 %sub.i7.i, 14
  %shl.i.i = add i32 %add1.i11.i, 2147467264
  %or.i.i = or disjoint i32 %shl.i.i, %and.i.i
  store i32 %or.i.i, ptr %arrayidx.i.i.le, align 4
  br label %if.end

if.end:                                           ; preds = %fixjump.exit.i, %if.then2.i, %if.then, %entry
  %t1 = getelementptr inbounds %struct.expdesc, ptr %e, i64 0, i32 2
  %8 = load i32, ptr %t1, align 8
  %f = getelementptr inbounds %struct.expdesc, ptr %e, i64 0, i32 3
  %9 = load i32, ptr %f, align 4
  %cmp2.not = icmp eq i32 %8, %9
  br i1 %cmp2.not, label %if.end18, label %if.then3

if.then3:                                         ; preds = %if.end
  %cmp.not9.i = icmp eq i32 %8, -1
  br i1 %cmp.not9.i, label %lor.lhs.false, label %for.body.lr.ph.i

for.body.lr.ph.i:                                 ; preds = %if.then3
  %fs.val4.i = load ptr, ptr %fs, align 8
  %10 = getelementptr i8, ptr %fs.val4.i, i64 24
  %fs.val4.val.i = load ptr, ptr %10, align 8
  br label %for.body.i

for.body.i:                                       ; preds = %for.inc.i, %for.body.lr.ph.i
  %list.addr.010.i = phi i32 [ %8, %for.body.lr.ph.i ], [ %add1.i.i37, %for.inc.i ]
  %idxprom.i.i31 = sext i32 %list.addr.010.i to i64
  %arrayidx.i.i32 = getelementptr inbounds i32, ptr %fs.val4.val.i, i64 %idxprom.i.i31
  %cmp.i.i33 = icmp sgt i32 %list.addr.010.i, 0
  br i1 %cmp.i.i33, label %land.lhs.true.i.i, label %if.else.i.i

land.lhs.true.i.i:                                ; preds = %for.body.i
  %add.ptr.i.i = getelementptr inbounds i32, ptr %arrayidx.i.i32, i64 -1
  %11 = load i32, ptr %add.ptr.i.i, align 4
  %and.i.i38 = and i32 %11, 63
  %idxprom1.i.i = zext nneg i32 %and.i.i38 to i64
  %12 = lshr i64 266027925503, %idxprom1.i.i
  %13 = and i64 %12, 1
  %tobool.not.not.i.i = icmp eq i64 %13, 0
  br i1 %tobool.not.not.i.i, label %getjumpcontrol.exit.i, label %if.else.i.i

if.else.i.i:                                      ; preds = %land.lhs.true.i.i, %for.body.i
  %.pre.i = load i32, ptr %arrayidx.i.i32, align 4
  br label %getjumpcontrol.exit.i

getjumpcontrol.exit.i:                            ; preds = %if.else.i.i, %land.lhs.true.i.i
  %14 = phi i32 [ %.pre.i, %if.else.i.i ], [ %11, %land.lhs.true.i.i ]
  %and.i = and i32 %14, 63
  %cmp1.not.i = icmp eq i32 %and.i, 27
  br i1 %cmp1.not.i, label %for.inc.i, label %if.then8

for.inc.i:                                        ; preds = %getjumpcontrol.exit.i
  %15 = load i32, ptr %arrayidx.i.i32, align 4
  %shr.i.i34 = lshr i32 %15, 14
  %sub.i.i35 = add nsw i32 %shr.i.i34, -131071
  %cmp.i7.i = icmp eq i32 %sub.i.i35, -1
  %add.i.i36 = add nuw nsw i32 %list.addr.010.i, 1
  %add1.i.i37 = add nsw i32 %add.i.i36, %sub.i.i35
  %cmp.not12.i = icmp eq i32 %add1.i.i37, -1
  %cmp.not.i = select i1 %cmp.i7.i, i1 true, i1 %cmp.not12.i
  br i1 %cmp.not.i, label %lor.lhs.false, label %for.body.i

lor.lhs.false:                                    ; preds = %for.inc.i, %if.then3
  %cmp.not9.i39 = icmp eq i32 %9, -1
  br i1 %cmp.not9.i39, label %if.end14, label %for.body.lr.ph.i40

for.body.lr.ph.i40:                               ; preds = %lor.lhs.false
  %fs.val4.i41 = load ptr, ptr %fs, align 8
  %16 = getelementptr i8, ptr %fs.val4.i41, i64 24
  %fs.val4.val.i42 = load ptr, ptr %16, align 8
  br label %for.body.i43

for.body.i43:                                     ; preds = %for.inc.i54, %for.body.lr.ph.i40
  %list.addr.010.i44 = phi i32 [ %9, %for.body.lr.ph.i40 ], [ %add1.i.i59, %for.inc.i54 ]
  %idxprom.i.i45 = sext i32 %list.addr.010.i44 to i64
  %arrayidx.i.i46 = getelementptr inbounds i32, ptr %fs.val4.val.i42, i64 %idxprom.i.i45
  %cmp.i.i47 = icmp sgt i32 %list.addr.010.i44, 0
  br i1 %cmp.i.i47, label %land.lhs.true.i.i62, label %if.else.i.i48

land.lhs.true.i.i62:                              ; preds = %for.body.i43
  %add.ptr.i.i63 = getelementptr inbounds i32, ptr %arrayidx.i.i46, i64 -1
  %17 = load i32, ptr %add.ptr.i.i63, align 4
  %and.i.i64 = and i32 %17, 63
  %idxprom1.i.i65 = zext nneg i32 %and.i.i64 to i64
  %18 = lshr i64 266027925503, %idxprom1.i.i65
  %19 = and i64 %18, 1
  %tobool.not.not.i.i66 = icmp eq i64 %19, 0
  br i1 %tobool.not.not.i.i66, label %getjumpcontrol.exit.i50, label %if.else.i.i48

if.else.i.i48:                                    ; preds = %land.lhs.true.i.i62, %for.body.i43
  %.pre.i49 = load i32, ptr %arrayidx.i.i46, align 4
  br label %getjumpcontrol.exit.i50

getjumpcontrol.exit.i50:                          ; preds = %if.else.i.i48, %land.lhs.true.i.i62
  %20 = phi i32 [ %.pre.i49, %if.else.i.i48 ], [ %17, %land.lhs.true.i.i62 ]
  %and.i51 = and i32 %20, 63
  %cmp1.not.i52 = icmp eq i32 %and.i51, 27
  br i1 %cmp1.not.i52, label %for.inc.i54, label %if.then8

for.inc.i54:                                      ; preds = %getjumpcontrol.exit.i50
  %21 = load i32, ptr %arrayidx.i.i46, align 4
  %shr.i.i55 = lshr i32 %21, 14
  %sub.i.i56 = add nsw i32 %shr.i.i55, -131071
  %cmp.i7.i57 = icmp eq i32 %sub.i.i56, -1
  %add.i.i58 = add nuw nsw i32 %list.addr.010.i44, 1
  %add1.i.i59 = add nsw i32 %add.i.i58, %sub.i.i56
  %cmp.not12.i60 = icmp eq i32 %add1.i.i59, -1
  %cmp.not.i61 = select i1 %cmp.i7.i57, i1 true, i1 %cmp.not12.i60
  br i1 %cmp.not.i61, label %if.end14, label %for.body.i43

if.then8:                                         ; preds = %getjumpcontrol.exit.i, %getjumpcontrol.exit.i50
  %22 = load i32, ptr %e, align 8
  %cmp10 = icmp eq i32 %22, 10
  br i1 %cmp10, label %cond.end, label %cond.false

cond.false:                                       ; preds = %if.then8
  %jpc1.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 8
  %23 = load i32, ptr %jpc1.i, align 8
  store i32 -1, ptr %jpc1.i, align 8
  %ls.i.i68 = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 3
  %24 = load ptr, ptr %ls.i.i68, align 8
  %lastline.i.i = getelementptr inbounds %struct.LexState, ptr %24, i64 0, i32 2
  %25 = load i32, ptr %lastline.i.i, align 8
  %call.i.i = tail call fastcc i32 @luaK_code(ptr noundef %fs, i32 noundef 2147450902, i32 noundef %25)
  %cmp.i.i69 = icmp eq i32 %23, -1
  br i1 %cmp.i.i69, label %cond.end, label %if.else.i.i70

if.else.i.i70:                                    ; preds = %cond.false
  %cmp1.i.i = icmp eq i32 %call.i.i, -1
  br i1 %cmp1.i.i, label %cond.end, label %while.cond.preheader.i.i

while.cond.preheader.i.i:                         ; preds = %if.else.i.i70
  %fs.val.i.i = load ptr, ptr %fs, align 8
  %26 = getelementptr i8, ptr %fs.val.i.i, i64 24
  %fs.val.val.i.i = load ptr, ptr %26, align 8
  br label %while.cond.i.i

while.cond.i.i:                                   ; preds = %while.cond.i.i, %while.cond.preheader.i.i
  %list.0.i.i = phi i32 [ %add1.i.i.i, %while.cond.i.i ], [ %call.i.i, %while.cond.preheader.i.i ]
  %idxprom.i.i.i = sext i32 %list.0.i.i to i64
  %arrayidx.i.i.i = getelementptr inbounds i32, ptr %fs.val.val.i.i, i64 %idxprom.i.i.i
  %27 = load i32, ptr %arrayidx.i.i.i, align 4
  %shr.i.i.i = lshr i32 %27, 14
  %sub.i.i.i = add nsw i32 %shr.i.i.i, -131071
  %cmp.i.i.i = icmp eq i32 %sub.i.i.i, -1
  %add.i.i.i = add nuw nsw i32 %list.0.i.i, 1
  %add1.i.i.i = add nsw i32 %add.i.i.i, %sub.i.i.i
  %cmp4.not12.i.i = icmp eq i32 %add1.i.i.i, -1
  %cmp4.not.i.i = select i1 %cmp.i.i.i, i1 true, i1 %cmp4.not12.i.i
  br i1 %cmp4.not.i.i, label %while.end.i.i, label %while.cond.i.i, !llvm.loop !94

while.end.i.i:                                    ; preds = %while.cond.i.i
  %add.neg.i.i.i = xor i32 %list.0.i.i, -1
  %sub.i7.i.i = add i32 %23, %add.neg.i.i.i
  %28 = tail call i32 @llvm.abs.i32(i32 %sub.i7.i.i, i1 true)
  %cmp.i8.i.i = icmp ugt i32 %28, 131071
  br i1 %cmp.i8.i.i, label %if.then.i.i.i, label %fixjump.exit.i.i

if.then.i.i.i:                                    ; preds = %while.end.i.i
  %29 = load ptr, ptr %ls.i.i68, align 8
  %t.i.i.i.i = getelementptr inbounds %struct.LexState, ptr %29, i64 0, i32 3
  %30 = load i32, ptr %t.i.i.i.i, align 8
  tail call fastcc void @luaX_lexerror(ptr noundef %29, ptr noundef nonnull @.str.148, i32 noundef %30)
  unreachable

fixjump.exit.i.i:                                 ; preds = %while.end.i.i
  %arrayidx.i.i.i.le = getelementptr inbounds i32, ptr %fs.val.val.i.i, i64 %idxprom.i.i.i
  %and.i.i.i = and i32 %27, 16383
  %add1.i11.i.i = shl i32 %sub.i7.i.i, 14
  %shl.i.i.i = add i32 %add1.i11.i.i, 2147467264
  %or.i.i.i = or disjoint i32 %shl.i.i.i, %and.i.i.i
  store i32 %or.i.i.i, ptr %arrayidx.i.i.i.le, align 4
  br label %cond.end

cond.end:                                         ; preds = %fixjump.exit.i.i, %if.else.i.i70, %cond.false, %if.then8
  %cond = phi i32 [ -1, %if.then8 ], [ %call.i.i, %cond.false ], [ %call.i.i, %fixjump.exit.i.i ], [ %23, %if.else.i.i70 ]
  %pc.i.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 6
  %31 = load i32, ptr %pc.i.i, align 8
  %lasttarget.i.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 7
  store i32 %31, ptr %lasttarget.i.i, align 4
  %shl1.i.i = shl i32 %reg, 6
  %or5.i.i = or i32 %shl1.i.i, 16386
  %ls.i.i71 = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 3
  %32 = load ptr, ptr %ls.i.i71, align 8
  %lastline.i.i72 = getelementptr inbounds %struct.LexState, ptr %32, i64 0, i32 2
  %33 = load i32, ptr %lastline.i.i72, align 8
  %call.i.i73 = tail call fastcc i32 @luaK_code(ptr noundef %fs, i32 noundef %or5.i.i, i32 noundef %33)
  %34 = load i32, ptr %pc.i.i, align 8
  store i32 %34, ptr %lasttarget.i.i, align 4
  %or5.i.i78 = or i32 %shl1.i.i, 8388610
  %35 = load ptr, ptr %ls.i.i71, align 8
  %lastline.i.i80 = getelementptr inbounds %struct.LexState, ptr %35, i64 0, i32 2
  %36 = load i32, ptr %lastline.i.i80, align 8
  %call.i.i81 = tail call fastcc i32 @luaK_code(ptr noundef %fs, i32 noundef %or5.i.i78, i32 noundef %36)
  %37 = load i32, ptr %pc.i.i, align 8
  store i32 %37, ptr %lasttarget.i.i, align 4
  %jpc.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 8
  %cmp.i.i84 = icmp eq i32 %cond, -1
  br i1 %cmp.i.i84, label %if.end14, label %if.else.i.i85

if.else.i.i85:                                    ; preds = %cond.end
  %38 = load i32, ptr %jpc.i, align 4
  %cmp1.i.i86 = icmp eq i32 %38, -1
  br i1 %cmp1.i.i86, label %if.then2.i.i, label %while.cond.preheader.i.i87

while.cond.preheader.i.i87:                       ; preds = %if.else.i.i85
  %fs.val.i.i88 = load ptr, ptr %fs, align 8
  %39 = getelementptr i8, ptr %fs.val.i.i88, i64 24
  %fs.val.val.i.i89 = load ptr, ptr %39, align 8
  br label %while.cond.i.i90

if.then2.i.i:                                     ; preds = %if.else.i.i85
  store i32 %cond, ptr %jpc.i, align 4
  br label %if.end14

while.cond.i.i90:                                 ; preds = %while.cond.i.i90, %while.cond.preheader.i.i87
  %list.0.i.i91 = phi i32 [ %add1.i.i.i98, %while.cond.i.i90 ], [ %38, %while.cond.preheader.i.i87 ]
  %idxprom.i.i.i92 = sext i32 %list.0.i.i91 to i64
  %arrayidx.i.i.i93 = getelementptr inbounds i32, ptr %fs.val.val.i.i89, i64 %idxprom.i.i.i92
  %40 = load i32, ptr %arrayidx.i.i.i93, align 4
  %shr.i.i.i94 = lshr i32 %40, 14
  %sub.i.i.i95 = add nsw i32 %shr.i.i.i94, -131071
  %cmp.i.i.i96 = icmp eq i32 %sub.i.i.i95, -1
  %add.i.i.i97 = add nuw nsw i32 %list.0.i.i91, 1
  %add1.i.i.i98 = add nsw i32 %add.i.i.i97, %sub.i.i.i95
  %cmp4.not12.i.i99 = icmp eq i32 %add1.i.i.i98, -1
  %cmp4.not.i.i100 = select i1 %cmp.i.i.i96, i1 true, i1 %cmp4.not12.i.i99
  br i1 %cmp4.not.i.i100, label %while.end.i.i101, label %while.cond.i.i90, !llvm.loop !94

while.end.i.i101:                                 ; preds = %while.cond.i.i90
  %add.neg.i.i.i102 = xor i32 %list.0.i.i91, -1
  %sub.i7.i.i103 = add i32 %cond, %add.neg.i.i.i102
  %41 = tail call i32 @llvm.abs.i32(i32 %sub.i7.i.i103, i1 true)
  %cmp.i8.i.i104 = icmp ugt i32 %41, 131071
  br i1 %cmp.i8.i.i104, label %if.then.i.i.i111, label %fixjump.exit.i.i105

if.then.i.i.i111:                                 ; preds = %while.end.i.i101
  %42 = load ptr, ptr %ls.i.i71, align 8
  %t.i.i.i.i112 = getelementptr inbounds %struct.LexState, ptr %42, i64 0, i32 3
  %43 = load i32, ptr %t.i.i.i.i112, align 8
  tail call fastcc void @luaX_lexerror(ptr noundef %42, ptr noundef nonnull @.str.148, i32 noundef %43)
  unreachable

fixjump.exit.i.i105:                              ; preds = %while.end.i.i101
  %arrayidx.i.i.i93.le = getelementptr inbounds i32, ptr %fs.val.val.i.i89, i64 %idxprom.i.i.i92
  %and.i.i.i107 = and i32 %40, 16383
  %add1.i11.i.i108 = shl i32 %sub.i7.i.i103, 14
  %shl.i.i.i109 = add i32 %add1.i11.i.i108, 2147467264
  %or.i.i.i110 = or disjoint i32 %shl.i.i.i109, %and.i.i.i107
  store i32 %or.i.i.i110, ptr %arrayidx.i.i.i93.le, align 4
  br label %if.end14

if.end14:                                         ; preds = %for.inc.i54, %lor.lhs.false, %fixjump.exit.i.i105, %if.then2.i.i, %cond.end
  %p_t.0 = phi i32 [ %call.i.i81, %cond.end ], [ %call.i.i81, %if.then2.i.i ], [ %call.i.i81, %fixjump.exit.i.i105 ], [ -1, %lor.lhs.false ], [ -1, %for.inc.i54 ]
  %p_f.0 = phi i32 [ %call.i.i73, %cond.end ], [ %call.i.i73, %if.then2.i.i ], [ %call.i.i73, %fixjump.exit.i.i105 ], [ -1, %lor.lhs.false ], [ -1, %for.inc.i54 ]
  %pc.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 6
  %44 = load i32, ptr %pc.i, align 8
  %lasttarget.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 7
  store i32 %44, ptr %lasttarget.i, align 4
  %45 = load i32, ptr %f, align 4
  tail call fastcc void @patchlistaux(ptr noundef %fs, i32 noundef %45, i32 noundef %44, i32 noundef %reg, i32 noundef %p_f.0)
  %46 = load i32, ptr %t1, align 8
  tail call fastcc void @patchlistaux(ptr noundef %fs, i32 noundef %46, i32 noundef %44, i32 noundef %reg, i32 noundef %p_t.0)
  br label %if.end18

if.end18:                                         ; preds = %if.end14, %if.end
  store i32 -1, ptr %t1, align 8
  store i32 -1, ptr %f, align 4
  %u21 = getelementptr inbounds %struct.expdesc, ptr %e, i64 0, i32 1
  store i32 %reg, ptr %u21, align 8
  store i32 12, ptr %e, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @luaK_code(ptr nocapture noundef %fs, i32 noundef %i, i32 noundef %line) unnamed_addr #0 {
entry:
  %0 = load ptr, ptr %fs, align 8
  %jpc.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 8
  %1 = load i32, ptr %jpc.i, align 8
  %pc.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 6
  %2 = load i32, ptr %pc.i, align 8
  tail call fastcc void @patchlistaux(ptr noundef nonnull %fs, i32 noundef %1, i32 noundef %2, i32 noundef 255, i32 noundef %2)
  store i32 -1, ptr %jpc.i, align 8
  %3 = load i32, ptr %pc.i, align 8
  %sizecode = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 12
  %4 = load i32, ptr %sizecode, align 8
  %cmp.not = icmp slt i32 %3, %4
  br i1 %cmp.not, label %entry.if.end_crit_edge, label %if.then

entry.if.end_crit_edge:                           ; preds = %entry
  %code4.phi.trans.insert = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 4
  %.pre = load ptr, ptr %code4.phi.trans.insert, align 8
  br label %if.end

if.then:                                          ; preds = %entry
  %L = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 4
  %5 = load ptr, ptr %L, align 8
  %code = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 4
  %6 = load ptr, ptr %code, align 8
  %call = tail call fastcc ptr @luaM_growaux_(ptr noundef %5, ptr noundef %6, ptr noundef nonnull %sizecode, i64 noundef 4, i32 noundef 2147483645, ptr noundef nonnull @.str.147)
  store ptr %call, ptr %code, align 8
  %.pre18 = load i32, ptr %pc.i, align 8
  br label %if.end

if.end:                                           ; preds = %entry.if.end_crit_edge, %if.then
  %7 = phi i32 [ %3, %entry.if.end_crit_edge ], [ %.pre18, %if.then ]
  %8 = phi ptr [ %.pre, %entry.if.end_crit_edge ], [ %call, %if.then ]
  %idxprom = sext i32 %7 to i64
  %arrayidx = getelementptr inbounds i32, ptr %8, i64 %idxprom
  store i32 %i, ptr %arrayidx, align 4
  %9 = load i32, ptr %pc.i, align 8
  %sizelineinfo = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 13
  %10 = load i32, ptr %sizelineinfo, align 4
  %cmp8.not = icmp slt i32 %9, %10
  br i1 %cmp8.not, label %if.end.if.end14_crit_edge, label %if.then9

if.end.if.end14_crit_edge:                        ; preds = %if.end
  %lineinfo15.phi.trans.insert = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 6
  %.pre19 = load ptr, ptr %lineinfo15.phi.trans.insert, align 8
  br label %if.end14

if.then9:                                         ; preds = %if.end
  %L10 = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 4
  %11 = load ptr, ptr %L10, align 8
  %lineinfo = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 6
  %12 = load ptr, ptr %lineinfo, align 8
  %call12 = tail call fastcc ptr @luaM_growaux_(ptr noundef %11, ptr noundef %12, ptr noundef nonnull %sizelineinfo, i64 noundef 4, i32 noundef 2147483645, ptr noundef nonnull @.str.147)
  store ptr %call12, ptr %lineinfo, align 8
  %.pre20 = load i32, ptr %pc.i, align 8
  br label %if.end14

if.end14:                                         ; preds = %if.end.if.end14_crit_edge, %if.then9
  %13 = phi i32 [ %9, %if.end.if.end14_crit_edge ], [ %.pre20, %if.then9 ]
  %14 = phi ptr [ %.pre19, %if.end.if.end14_crit_edge ], [ %call12, %if.then9 ]
  %idxprom17 = sext i32 %13 to i64
  %arrayidx18 = getelementptr inbounds i32, ptr %14, i64 %idxprom17
  store i32 %line, ptr %arrayidx18, align 4
  %15 = load i32, ptr %pc.i, align 8
  %inc = add nsw i32 %15, 1
  store i32 %inc, ptr %pc.i, align 8
  ret i32 %15
}

; Function Attrs: nounwind uwtable
define internal fastcc ptr @luaM_growaux_(ptr noundef %L, ptr noundef %block, ptr nocapture noundef %size, i64 noundef %size_elems, i32 noundef %limit, ptr noundef %errormsg) unnamed_addr #0 {
entry:
  %0 = load i32, ptr %size, align 4
  %div14 = lshr i32 %limit, 1
  %cmp.not = icmp slt i32 %0, %div14
  br i1 %cmp.not, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %cmp1.not = icmp slt i32 %0, %limit
  br i1 %cmp1.not, label %if.end6, label %if.then2

if.then2:                                         ; preds = %if.then
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef %L, ptr noundef %errormsg)
  unreachable

if.else:                                          ; preds = %entry
  %mul = shl nsw i32 %0, 1
  %spec.store.select = tail call i32 @llvm.smax.i32(i32 %mul, i32 4)
  br label %if.end6

if.end6:                                          ; preds = %if.then, %if.else
  %newsize.0 = phi i32 [ %spec.store.select, %if.else ], [ %limit, %if.then ]
  %add = add nsw i32 %newsize.0, 1
  %conv = sext i32 %add to i64
  %div7 = udiv i64 -3, %size_elems
  %cmp8.not = icmp ult i64 %div7, %conv
  br i1 %cmp8.not, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end6
  %conv10 = sext i32 %0 to i64
  %mul11 = mul nsw i64 %conv10, %size_elems
  %conv12 = sext i32 %newsize.0 to i64
  %mul13 = mul nsw i64 %conv12, %size_elems
  %l_G.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %1 = load ptr, ptr %l_G.i, align 8
  %frealloc.i = getelementptr inbounds %struct.global_State, ptr %1, i64 0, i32 1
  %2 = load ptr, ptr %frealloc.i, align 8
  %ud.i = getelementptr inbounds %struct.global_State, ptr %1, i64 0, i32 2
  %3 = load ptr, ptr %ud.i, align 8
  %call.i = tail call ptr %2(ptr noundef %3, ptr noundef %block, i64 noundef %mul11, i64 noundef %mul13) #35
  %cmp.i = icmp eq ptr %call.i, null
  %cmp1.i = icmp ne i32 %newsize.0, 0
  %or.cond.i = and i1 %cmp1.i, %cmp.i
  br i1 %or.cond.i, label %if.then.i, label %luaM_realloc_.exit

if.then.i:                                        ; preds = %cond.true
  %errorJmp.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 26
  %4 = load ptr, ptr %errorJmp.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %4, null
  br i1 %tobool.not.i.i, label %if.else.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %if.then.i
  %status.i.i = getelementptr inbounds %struct.lua_longjmp, ptr %4, i64 0, i32 2
  store volatile i32 4, ptr %status.i.i, align 8
  %5 = load ptr, ptr %errorJmp.i.i, align 8
  %b.i.i = getelementptr inbounds %struct.lua_longjmp, ptr %5, i64 0, i32 1
  tail call void @longjmp(ptr noundef nonnull %b.i.i, i32 noundef 1) #38
  unreachable

if.else.i.i:                                      ; preds = %if.then.i
  %status3.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 3
  store i8 4, ptr %status3.i.i, align 2
  %6 = load ptr, ptr %l_G.i, align 8
  %panic.i.i = getelementptr inbounds %struct.global_State, ptr %6, i64 0, i32 19
  %7 = load ptr, ptr %panic.i.i, align 8
  %tobool4.not.i.i = icmp eq ptr %7, null
  br i1 %tobool4.not.i.i, label %if.end.i.i, label %if.then5.i.i

if.then5.i.i:                                     ; preds = %if.else.i.i
  tail call fastcc void @resetstack(ptr noundef nonnull %L, i32 noundef 4)
  %8 = load ptr, ptr %l_G.i, align 8
  %panic7.i.i = getelementptr inbounds %struct.global_State, ptr %8, i64 0, i32 19
  %9 = load ptr, ptr %panic7.i.i, align 8
  %call.i.i = tail call i32 %9(ptr noundef nonnull %L) #35
  br label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then5.i.i, %if.else.i.i
  tail call void @exit(i32 noundef 1) #38
  unreachable

luaM_realloc_.exit:                               ; preds = %cond.true
  %totalbytes.i = getelementptr inbounds %struct.global_State, ptr %1, i64 0, i32 14
  %10 = load i64, ptr %totalbytes.i, align 8
  %sub.i = sub i64 %mul13, %mul11
  %add.i = add i64 %sub.i, %10
  store i64 %add.i, ptr %totalbytes.i, align 8
  store i32 %newsize.0, ptr %size, align 4
  ret ptr %call.i

cond.false:                                       ; preds = %if.end6
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef %L, ptr noundef nonnull @.str.5)
  unreachable
}

; Function Attrs: nounwind uwtable
define internal fastcc void @patchlistaux(ptr nocapture noundef readonly %fs, i32 noundef %list, i32 noundef %vtarget, i32 noundef %reg, i32 noundef %dtarget) unnamed_addr #0 {
entry:
  %cmp.not36 = icmp eq i32 %list, -1
  br i1 %cmp.not36, label %while.end, label %while.body.lr.ph

while.body.lr.ph:                                 ; preds = %entry
  %cmp1.not.i = icmp eq i32 %reg, 255
  %shl.i = shl i32 %reg, 6
  %and7.i = and i32 %shl.i, 16320
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %if.end
  %list.addr.037 = phi i32 [ %list, %while.body.lr.ph ], [ %add1.i, %if.end ]
  %fs.val = load ptr, ptr %fs, align 8
  %0 = getelementptr i8, ptr %fs.val, i64 24
  %fs.val.val = load ptr, ptr %0, align 8
  %idxprom.i = sext i32 %list.addr.037 to i64
  %arrayidx.i = getelementptr inbounds i32, ptr %fs.val.val, i64 %idxprom.i
  %1 = load i32, ptr %arrayidx.i, align 4
  %shr.i = lshr i32 %1, 14
  %sub.i = add nsw i32 %shr.i, -131071
  %cmp.i = icmp eq i32 %sub.i, -1
  %add.i = add nuw nsw i32 %list.addr.037, 1
  %add1.i = add nsw i32 %add.i, %sub.i
  %cmp.i.i = icmp sgt i32 %list.addr.037, 0
  br i1 %cmp.i.i, label %land.lhs.true.i.i, label %if.else.i.i

land.lhs.true.i.i:                                ; preds = %while.body
  %add.ptr.i.i = getelementptr inbounds i32, ptr %arrayidx.i, i64 -1
  %2 = load i32, ptr %add.ptr.i.i, align 4
  %and.i.i = and i32 %2, 63
  %idxprom1.i.i = zext nneg i32 %and.i.i to i64
  %3 = lshr i64 266027925503, %idxprom1.i.i
  %4 = and i64 %3, 1
  %tobool.not.not.i.i = icmp eq i64 %4, 0
  br i1 %tobool.not.not.i.i, label %getjumpcontrol.exit.i, label %if.else.i.i

if.else.i.i:                                      ; preds = %land.lhs.true.i.i, %while.body
  br label %getjumpcontrol.exit.i

getjumpcontrol.exit.i:                            ; preds = %if.else.i.i, %land.lhs.true.i.i
  %5 = phi i32 [ %1, %if.else.i.i ], [ %2, %land.lhs.true.i.i ]
  %retval.0.i.i = phi ptr [ %arrayidx.i, %if.else.i.i ], [ %add.ptr.i.i, %land.lhs.true.i.i ]
  %and.i = and i32 %5, 63
  %cmp.not.i = icmp eq i32 %and.i, 27
  br i1 %cmp.not.i, label %if.end.i, label %if.else

if.end.i:                                         ; preds = %getjumpcontrol.exit.i
  %shr2.i = lshr i32 %5, 23
  %cmp4.not.i = icmp eq i32 %shr2.i, %reg
  %or.cond.i = or i1 %cmp1.not.i, %cmp4.not.i
  %6 = lshr i32 %5, 17
  %shl10.i = and i32 %6, 32704
  %or11.i = and i32 %5, 8372250
  %and6.i = and i32 %5, -16357
  %7 = or i32 %shl10.i, %or11.i
  %8 = or disjoint i32 %and6.i, %and7.i
  %or16.i = select i1 %or.cond.i, i32 %7, i32 %8
  store i32 %or16.i, ptr %retval.0.i.i, align 4
  %add.neg.i = xor i32 %list.addr.037, -1
  %sub.i10 = add i32 %add.neg.i, %vtarget
  %9 = tail call i32 @llvm.abs.i32(i32 %sub.i10, i1 true)
  %cmp.i11 = icmp ugt i32 %9, 131071
  br i1 %cmp.i11, label %if.then.i, label %fixjump.exit

if.then.i:                                        ; preds = %if.end.i
  %ls.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 3
  %10 = load ptr, ptr %ls.i, align 8
  %t.i.i = getelementptr inbounds %struct.LexState, ptr %10, i64 0, i32 3
  %11 = load i32, ptr %t.i.i, align 8
  tail call fastcc void @luaX_lexerror(ptr noundef %10, ptr noundef nonnull @.str.148, i32 noundef %11)
  unreachable

fixjump.exit:                                     ; preds = %if.end.i
  %12 = load ptr, ptr %fs, align 8
  %code.i = getelementptr inbounds %struct.Proto, ptr %12, i64 0, i32 4
  %13 = load ptr, ptr %code.i, align 8
  %arrayidx.i14 = getelementptr inbounds i32, ptr %13, i64 %idxprom.i
  %14 = load i32, ptr %arrayidx.i14, align 4
  br label %if.end

if.else:                                          ; preds = %getjumpcontrol.exit.i
  %add.neg.i19 = xor i32 %list.addr.037, -1
  %sub.i20 = add i32 %add.neg.i19, %dtarget
  %15 = tail call i32 @llvm.abs.i32(i32 %sub.i20, i1 true)
  %cmp.i21 = icmp ugt i32 %15, 131071
  br i1 %cmp.i21, label %if.then.i30, label %if.end

if.then.i30:                                      ; preds = %if.else
  %ls.i31 = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 3
  %16 = load ptr, ptr %ls.i31, align 8
  %t.i.i32 = getelementptr inbounds %struct.LexState, ptr %16, i64 0, i32 3
  %17 = load i32, ptr %t.i.i32, align 8
  tail call fastcc void @luaX_lexerror(ptr noundef %16, ptr noundef nonnull @.str.148, i32 noundef %17)
  unreachable

if.end:                                           ; preds = %if.else, %fixjump.exit
  %.sink = phi i32 [ %14, %fixjump.exit ], [ %1, %if.else ]
  %sub.i20.sink = phi i32 [ %sub.i10, %fixjump.exit ], [ %sub.i20, %if.else ]
  %arrayidx.i.sink = phi ptr [ %arrayidx.i14, %fixjump.exit ], [ %arrayidx.i, %if.else ]
  %and.i26 = and i32 %.sink, 16383
  %add1.i27 = shl i32 %sub.i20.sink, 14
  %shl.i28 = add i32 %add1.i27, 2147467264
  %or.i29 = or disjoint i32 %and.i26, %shl.i28
  store i32 %or.i29, ptr %arrayidx.i.sink, align 4
  %cmp.not38 = icmp eq i32 %add1.i, -1
  %cmp.not = select i1 %cmp.i, i1 true, i1 %cmp.not38
  br i1 %cmp.not, label %while.end, label %while.body, !llvm.loop !114

while.end:                                        ; preds = %if.end, %entry
  ret void
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.abs.i32(i32, i1 immarg) #12

; Function Attrs: nounwind uwtable
define internal fastcc void @discharge2reg(ptr nocapture noundef %fs, ptr nocapture noundef %e, i32 noundef %reg) unnamed_addr #0 {
entry:
  %o.i = alloca %struct.lua_TValue, align 8
  tail call fastcc void @luaK_dischargevars(ptr noundef %fs, ptr noundef %e)
  %0 = load i32, ptr %e, align 8
  switch i32 %0, label %return [
    i32 1, label %sw.bb
    i32 3, label %sw.bb1
    i32 2, label %sw.bb1
    i32 4, label %sw.bb3
    i32 5, label %sw.bb5
    i32 11, label %sw.bb9
    i32 12, label %sw.bb13
  ]

sw.bb:                                            ; preds = %entry
  %pc.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 6
  %1 = load i32, ptr %pc.i, align 8
  %lasttarget.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 7
  %2 = load i32, ptr %lasttarget.i, align 4
  %cmp.i = icmp sgt i32 %1, %2
  br i1 %cmp.i, label %if.then.i, label %if.end33.i

if.then.i:                                        ; preds = %sw.bb
  %cmp2.i = icmp eq i32 %1, 0
  br i1 %cmp2.i, label %if.then3.i, label %if.else.i

if.then3.i:                                       ; preds = %if.then.i
  %nactvar.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 13
  %3 = load i8, ptr %nactvar.i, align 2
  %conv.i = zext i8 %3 to i32
  %cmp4.not.i = icmp sgt i32 %conv.i, %reg
  br i1 %cmp4.not.i, label %if.end33.i, label %sw.epilog

if.else.i:                                        ; preds = %if.then.i
  %4 = load ptr, ptr %fs, align 8
  %code.i = getelementptr inbounds %struct.Proto, ptr %4, i64 0, i32 4
  %5 = load ptr, ptr %code.i, align 8
  %6 = sext i32 %1 to i64
  %7 = getelementptr i32, ptr %5, i64 %6
  %arrayidx.i = getelementptr i32, ptr %7, i64 -1
  %8 = load i32, ptr %arrayidx.i, align 4
  %and.i = and i32 %8, 63
  %cmp8.i = icmp eq i32 %and.i, 3
  br i1 %cmp8.i, label %if.then10.i, label %if.end33.i

if.then10.i:                                      ; preds = %if.else.i
  %shr11.i = lshr i32 %8, 6
  %and12.i = and i32 %shr11.i, 255
  %shr13.i = lshr i32 %8, 23
  %cmp15.not.i = icmp sgt i32 %and12.i, %reg
  %add.i = add nuw nsw i32 %shr13.i, 1
  %cmp17.not.i = icmp slt i32 %add.i, %reg
  %or.cond.i = select i1 %cmp15.not.i, i1 true, i1 %cmp17.not.i
  br i1 %or.cond.i, label %if.end33.i, label %if.then19.i

if.then19.i:                                      ; preds = %if.then10.i
  %cmp22.i = icmp slt i32 %shr13.i, %reg
  br i1 %cmp22.i, label %if.then24.i, label %sw.epilog

if.then24.i:                                      ; preds = %if.then19.i
  %and25.i = and i32 %8, 8388547
  %shl.i = shl i32 %reg, 23
  %or.i = or disjoint i32 %and25.i, %shl.i
  store i32 %or.i, ptr %arrayidx.i, align 4
  br label %sw.epilog

if.end33.i:                                       ; preds = %if.then10.i, %if.else.i, %if.then3.i, %sw.bb
  %shl1.i.i = shl i32 %reg, 6
  %add34.i = shl i32 %reg, 23
  %or.i.i = or i32 %add34.i, %shl1.i.i
  %or3.i.i = or disjoint i32 %or.i.i, 3
  %ls.i.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 3
  %9 = load ptr, ptr %ls.i.i, align 8
  %lastline.i.i = getelementptr inbounds %struct.LexState, ptr %9, i64 0, i32 2
  %10 = load i32, ptr %lastline.i.i, align 8
  %call.i.i = tail call fastcc i32 @luaK_code(ptr noundef nonnull %fs, i32 noundef %or3.i.i, i32 noundef %10)
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry, %entry
  %cmp = icmp eq i32 %0, 2
  %shl1.i = shl i32 %reg, 6
  %shl2.i = select i1 %cmp, i32 8388608, i32 2
  %or.i25 = or i32 %shl1.i, %shl2.i
  %or3.i = or i32 %or.i25, 2
  %ls.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 3
  %11 = load ptr, ptr %ls.i, align 8
  %lastline.i = getelementptr inbounds %struct.LexState, ptr %11, i64 0, i32 2
  %12 = load i32, ptr %lastline.i, align 8
  %call.i = tail call fastcc i32 @luaK_code(ptr noundef %fs, i32 noundef %or3.i, i32 noundef %12)
  br label %sw.epilog

sw.bb3:                                           ; preds = %entry
  %u = getelementptr inbounds %struct.expdesc, ptr %e, i64 0, i32 1
  %13 = load i32, ptr %u, align 8
  %shl1.i26 = shl i32 %reg, 6
  %shl2.i28 = shl i32 %13, 14
  %or.i27 = or i32 %shl1.i26, %shl2.i28
  %or3.i29 = or disjoint i32 %or.i27, 1
  %ls.i30 = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 3
  %14 = load ptr, ptr %ls.i30, align 8
  %lastline.i31 = getelementptr inbounds %struct.LexState, ptr %14, i64 0, i32 2
  %15 = load i32, ptr %lastline.i31, align 8
  %call.i32 = tail call fastcc i32 @luaK_code(ptr noundef %fs, i32 noundef %or3.i29, i32 noundef %15)
  br label %sw.epilog

sw.bb5:                                           ; preds = %entry
  %u6 = getelementptr inbounds %struct.expdesc, ptr %e, i64 0, i32 1
  %16 = load double, ptr %u6, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %o.i)
  store double %16, ptr %o.i, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %o.i, i64 0, i32 1
  store i32 3, ptr %tt.i, align 8
  %call.i33 = call fastcc i32 @addk(ptr noundef %fs, ptr noundef nonnull %o.i, ptr noundef nonnull %o.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %o.i)
  %shl1.i34 = shl i32 %reg, 6
  %shl2.i36 = shl i32 %call.i33, 14
  %or.i35 = or i32 %shl1.i34, %shl2.i36
  %or3.i37 = or disjoint i32 %or.i35, 1
  %ls.i38 = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 3
  %17 = load ptr, ptr %ls.i38, align 8
  %lastline.i39 = getelementptr inbounds %struct.LexState, ptr %17, i64 0, i32 2
  %18 = load i32, ptr %lastline.i39, align 8
  %call.i40 = tail call fastcc i32 @luaK_code(ptr noundef %fs, i32 noundef %or3.i37, i32 noundef %18)
  br label %sw.epilog

sw.bb9:                                           ; preds = %entry
  %19 = load ptr, ptr %fs, align 8
  %code = getelementptr inbounds %struct.Proto, ptr %19, i64 0, i32 4
  %20 = load ptr, ptr %code, align 8
  %u10 = getelementptr inbounds %struct.expdesc, ptr %e, i64 0, i32 1
  %21 = load i32, ptr %u10, align 8
  %idxprom = sext i32 %21 to i64
  %arrayidx = getelementptr inbounds i32, ptr %20, i64 %idxprom
  %22 = load i32, ptr %arrayidx, align 4
  %and = and i32 %22, -16321
  %shl = shl i32 %reg, 6
  %and12 = and i32 %shl, 16320
  %or = or disjoint i32 %and, %and12
  store i32 %or, ptr %arrayidx, align 4
  br label %sw.epilog

sw.bb13:                                          ; preds = %entry
  %u14 = getelementptr inbounds %struct.expdesc, ptr %e, i64 0, i32 1
  %23 = load i32, ptr %u14, align 8
  %cmp16.not = icmp eq i32 %23, %reg
  br i1 %cmp16.not, label %sw.epilog, label %if.then

if.then:                                          ; preds = %sw.bb13
  %shl1.i41 = shl i32 %reg, 6
  %shl2.i42 = shl i32 %23, 23
  %or3.i43 = or i32 %shl2.i42, %shl1.i41
  %ls.i44 = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 3
  %24 = load ptr, ptr %ls.i44, align 8
  %lastline.i45 = getelementptr inbounds %struct.LexState, ptr %24, i64 0, i32 2
  %25 = load i32, ptr %lastline.i45, align 8
  %call.i46 = tail call fastcc i32 @luaK_code(ptr noundef %fs, i32 noundef %or3.i43, i32 noundef %25)
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end33.i, %if.then24.i, %if.then19.i, %if.then3.i, %sw.bb13, %if.then, %sw.bb9, %sw.bb5, %sw.bb3, %sw.bb1
  %u21 = getelementptr inbounds %struct.expdesc, ptr %e, i64 0, i32 1
  store i32 %reg, ptr %u21, align 8
  store i32 12, ptr %e, align 8
  br label %return

return:                                           ; preds = %entry, %sw.epilog
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @addk(ptr nocapture noundef %fs, ptr nocapture noundef readonly %k, ptr nocapture noundef readonly %v) unnamed_addr #0 {
entry:
  %L1 = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 4
  %0 = load ptr, ptr %L1, align 8
  %h = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 1
  %1 = load ptr, ptr %h, align 8
  %call.i = tail call fastcc ptr @luaH_get(ptr noundef %1, ptr noundef %k)
  %flags.i = getelementptr inbounds %struct.Table, ptr %1, i64 0, i32 3
  store i8 0, ptr %flags.i, align 2
  %cmp.not.i = icmp eq ptr %call.i, @luaO_nilobject_
  br i1 %cmp.not.i, label %if.else.i, label %luaH_set.exit

if.else.i:                                        ; preds = %entry
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %k, i64 0, i32 1
  %2 = load i32, ptr %tt.i, align 8
  switch i32 %2, label %if.end9.i [
    i32 0, label %if.then2.i
    i32 3, label %land.lhs.true.i
  ]

if.then2.i:                                       ; preds = %if.else.i
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef %0, ptr noundef nonnull @.str.39)
  unreachable

land.lhs.true.i:                                  ; preds = %if.else.i
  %3 = load double, ptr %k, align 8
  %cmp7.i = fcmp ord double %3, 0.000000e+00
  br i1 %cmp7.i, label %if.end9.i, label %if.then8.i

if.then8.i:                                       ; preds = %land.lhs.true.i
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef %0, ptr noundef nonnull @.str.40)
  unreachable

if.end9.i:                                        ; preds = %land.lhs.true.i, %if.else.i
  %call10.i = tail call fastcc ptr @newkey(ptr noundef %0, ptr noundef nonnull %1, ptr noundef nonnull %k)
  br label %luaH_set.exit

luaH_set.exit:                                    ; preds = %entry, %if.end9.i
  %retval.0.i = phi ptr [ %call10.i, %if.end9.i ], [ %call.i, %entry ]
  %4 = load ptr, ptr %fs, align 8
  %sizek = getelementptr inbounds %struct.Proto, ptr %4, i64 0, i32 11
  %5 = load i32, ptr %sizek, align 4
  %tt = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i, i64 0, i32 1
  %6 = load i32, ptr %tt, align 8
  %cmp = icmp eq i32 %6, 3
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %luaH_set.exit
  %7 = load double, ptr %retval.0.i, align 8
  %conv = fptosi double %7 to i32
  br label %return

if.else:                                          ; preds = %luaH_set.exit
  %nk = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 10
  %8 = load i32, ptr %nk, align 8
  %conv3 = sitofp i32 %8 to double
  store double %conv3, ptr %retval.0.i, align 8
  store i32 3, ptr %tt, align 8
  %9 = load i32, ptr %nk, align 8
  %10 = load i32, ptr %sizek, align 4
  %cmp8.not = icmp slt i32 %9, %10
  br i1 %cmp8.not, label %if.end, label %if.then10

if.then10:                                        ; preds = %if.else
  %k11 = getelementptr inbounds %struct.Proto, ptr %4, i64 0, i32 3
  %11 = load ptr, ptr %k11, align 8
  %call13 = tail call fastcc ptr @luaM_growaux_(ptr noundef %0, ptr noundef %11, ptr noundef nonnull %sizek, i64 noundef 16, i32 noundef 262143, ptr noundef nonnull @.str.149)
  store ptr %call13, ptr %k11, align 8
  %.pre = load i32, ptr %sizek, align 4
  br label %if.end

if.end:                                           ; preds = %if.then10, %if.else
  %12 = phi i32 [ %.pre, %if.then10 ], [ %10, %if.else ]
  %cmp1628 = icmp slt i32 %5, %12
  br i1 %cmp1628, label %while.body.lr.ph, label %while.end

while.body.lr.ph:                                 ; preds = %if.end
  %k18 = getelementptr inbounds %struct.Proto, ptr %4, i64 0, i32 3
  %13 = sext i32 %5 to i64
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %while.body
  %indvars.iv = phi i64 [ %13, %while.body.lr.ph ], [ %indvars.iv.next, %while.body ]
  %14 = load ptr, ptr %k18, align 8
  %indvars.iv.next = add nsw i64 %indvars.iv, 1
  %tt19 = getelementptr inbounds %struct.lua_TValue, ptr %14, i64 %indvars.iv, i32 1
  store i32 0, ptr %tt19, align 8
  %15 = load i32, ptr %sizek, align 4
  %16 = sext i32 %15 to i64
  %cmp16 = icmp slt i64 %indvars.iv.next, %16
  br i1 %cmp16, label %while.body, label %while.end, !llvm.loop !115

while.end:                                        ; preds = %while.body, %if.end
  %k20 = getelementptr inbounds %struct.Proto, ptr %4, i64 0, i32 3
  %17 = load ptr, ptr %k20, align 8
  %18 = load i32, ptr %nk, align 8
  %idxprom22 = sext i32 %18 to i64
  %arrayidx23 = getelementptr inbounds %struct.lua_TValue, ptr %17, i64 %idxprom22
  %19 = load i64, ptr %v, align 8
  store i64 %19, ptr %arrayidx23, align 8
  %tt26 = getelementptr inbounds %struct.lua_TValue, ptr %v, i64 0, i32 1
  %20 = load i32, ptr %tt26, align 8
  %tt27 = getelementptr inbounds %struct.lua_TValue, ptr %17, i64 %idxprom22, i32 1
  store i32 %20, ptr %tt27, align 8
  %cmp29 = icmp sgt i32 %20, 3
  br i1 %cmp29, label %land.lhs.true, label %if.end40

land.lhs.true:                                    ; preds = %while.end
  %21 = load ptr, ptr %v, align 8
  %marked = getelementptr inbounds %struct.GCheader, ptr %21, i64 0, i32 2
  %22 = load i8, ptr %marked, align 1
  %23 = and i8 %22, 3
  %tobool.not = icmp eq i8 %23, 0
  br i1 %tobool.not, label %if.end40, label %land.lhs.true33

land.lhs.true33:                                  ; preds = %land.lhs.true
  %marked34 = getelementptr inbounds %struct.GCheader, ptr %4, i64 0, i32 2
  %24 = load i8, ptr %marked34, align 1
  %25 = and i8 %24, 4
  %tobool37.not = icmp eq i8 %25, 0
  br i1 %tobool37.not, label %if.end40, label %if.then38

if.then38:                                        ; preds = %land.lhs.true33
  %26 = getelementptr i8, ptr %0, i64 32
  %.val = load ptr, ptr %26, align 8
  %gcstate.i = getelementptr inbounds %struct.global_State, ptr %.val, i64 0, i32 4
  %27 = load i8, ptr %gcstate.i, align 1
  %cmp.i = icmp eq i8 %27, 1
  br i1 %cmp.i, label %if.then.i, label %if.else.i27

if.then.i:                                        ; preds = %if.then38
  tail call fastcc void @reallymarkobject(ptr noundef nonnull %.val, ptr noundef nonnull %21)
  br label %if.end40

if.else.i27:                                      ; preds = %if.then38
  %28 = and i8 %24, -8
  %currentwhite.i = getelementptr inbounds %struct.global_State, ptr %.val, i64 0, i32 3
  %29 = load i8, ptr %currentwhite.i, align 8
  %30 = and i8 %29, 3
  %or4.i = or disjoint i8 %30, %28
  store i8 %or4.i, ptr %marked34, align 1
  br label %if.end40

if.end40:                                         ; preds = %if.else.i27, %if.then.i, %land.lhs.true33, %land.lhs.true, %while.end
  %31 = load i32, ptr %nk, align 8
  %inc42 = add nsw i32 %31, 1
  store i32 %inc42, ptr %nk, align 8
  br label %return

return:                                           ; preds = %if.end40, %if.then
  %retval.0 = phi i32 [ %conv, %if.then ], [ %31, %if.end40 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @luaK_exp2RK(ptr nocapture noundef %fs, ptr nocapture noundef %e) unnamed_addr #0 {
entry:
  %o.i21 = alloca %struct.lua_TValue, align 8
  %o.i = alloca %struct.lua_TValue, align 8
  %k.i = alloca %struct.lua_TValue, align 8
  %v.i = alloca %struct.lua_TValue, align 8
  %t.i = getelementptr inbounds %struct.expdesc, ptr %e, i64 0, i32 2
  %0 = load i32, ptr %t.i, align 8
  %f.i = getelementptr inbounds %struct.expdesc, ptr %e, i64 0, i32 3
  %1 = load i32, ptr %f.i, align 4
  %cmp.not.i = icmp eq i32 %0, %1
  br i1 %cmp.not.i, label %if.else.i, label %if.then.i

if.then.i:                                        ; preds = %entry
  %call.i = tail call fastcc i32 @luaK_exp2anyreg(ptr noundef %fs, ptr noundef nonnull %e)
  br label %luaK_exp2val.exit

if.else.i:                                        ; preds = %entry
  tail call fastcc void @luaK_dischargevars(ptr noundef %fs, ptr noundef nonnull %e)
  br label %luaK_exp2val.exit

luaK_exp2val.exit:                                ; preds = %if.then.i, %if.else.i
  %2 = load i32, ptr %e, align 8
  switch i32 %2, label %sw.epilog [
    i32 5, label %sw.bb
    i32 2, label %sw.bb
    i32 3, label %sw.bb
    i32 1, label %sw.bb
    i32 4, label %sw.bb17
  ]

sw.bb:                                            ; preds = %luaK_exp2val.exit, %luaK_exp2val.exit, %luaK_exp2val.exit, %luaK_exp2val.exit
  %nk = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 10
  %3 = load i32, ptr %nk, align 8
  %cmp = icmp slt i32 %3, 256
  br i1 %cmp, label %if.then, label %sw.epilog

if.then:                                          ; preds = %sw.bb
  switch i32 %2, label %cond.false7 [
    i32 1, label %cond.true
    i32 5, label %cond.true5
  ]

cond.true:                                        ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %k.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %v.i)
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %v.i, i64 0, i32 1
  store i32 0, ptr %tt.i, align 8
  %h.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 1
  %4 = load ptr, ptr %h.i, align 8
  store ptr %4, ptr %k.i, align 8
  %tt1.i = getelementptr inbounds %struct.lua_TValue, ptr %k.i, i64 0, i32 1
  store i32 5, ptr %tt1.i, align 8
  %call.i18 = call fastcc i32 @addk(ptr noundef nonnull %fs, ptr noundef nonnull %k.i, ptr noundef nonnull %v.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %k.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %v.i)
  br label %cond.end11

cond.true5:                                       ; preds = %if.then
  %u = getelementptr inbounds %struct.expdesc, ptr %e, i64 0, i32 1
  %5 = load double, ptr %u, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %o.i)
  store double %5, ptr %o.i, align 8
  %tt.i19 = getelementptr inbounds %struct.lua_TValue, ptr %o.i, i64 0, i32 1
  store i32 3, ptr %tt.i19, align 8
  %call.i20 = call fastcc i32 @addk(ptr noundef nonnull %fs, ptr noundef nonnull %o.i, ptr noundef nonnull %o.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %o.i)
  br label %cond.end11

cond.false7:                                      ; preds = %if.then
  %cmp9 = icmp eq i32 %2, 2
  %conv = zext i1 %cmp9 to i32
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %o.i21)
  store i32 %conv, ptr %o.i21, align 8
  %tt.i22 = getelementptr inbounds %struct.lua_TValue, ptr %o.i21, i64 0, i32 1
  store i32 1, ptr %tt.i22, align 8
  %call.i23 = call fastcc i32 @addk(ptr noundef nonnull %fs, ptr noundef nonnull %o.i21, ptr noundef nonnull %o.i21)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %o.i21)
  br label %cond.end11

cond.end11:                                       ; preds = %cond.true5, %cond.false7, %cond.true
  %cond12 = phi i32 [ %call.i18, %cond.true ], [ %call.i20, %cond.true5 ], [ %call.i23, %cond.false7 ]
  %u13 = getelementptr inbounds %struct.expdesc, ptr %e, i64 0, i32 1
  store i32 %cond12, ptr %u13, align 8
  store i32 4, ptr %e, align 8
  %or = or i32 %cond12, 256
  br label %return

sw.bb17:                                          ; preds = %luaK_exp2val.exit
  %u18 = getelementptr inbounds %struct.expdesc, ptr %e, i64 0, i32 1
  %6 = load i32, ptr %u18, align 8
  %cmp20 = icmp slt i32 %6, 256
  br i1 %cmp20, label %if.then22, label %sw.epilog

if.then22:                                        ; preds = %sw.bb17
  %or25 = or i32 %6, 256
  br label %return

sw.epilog:                                        ; preds = %luaK_exp2val.exit, %sw.bb17, %sw.bb
  %call27 = tail call fastcc i32 @luaK_exp2anyreg(ptr noundef %fs, ptr noundef nonnull %e)
  br label %return

return:                                           ; preds = %sw.epilog, %if.then22, %cond.end11
  %retval.0 = phi i32 [ %call27, %sw.epilog ], [ %or25, %if.then22 ], [ %or, %cond.end11 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal fastcc void @constructor(ptr noundef %ls, ptr noundef %t) unnamed_addr #0 {
entry:
  %cc = alloca %struct.ConsControl, align 8
  %fs1 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 5
  %0 = load ptr, ptr %fs1, align 8
  %linenumber = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 1
  %1 = load i32, ptr %linenumber, align 4
  %ls.i = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  %2 = load ptr, ptr %ls.i, align 8
  %lastline.i = getelementptr inbounds %struct.LexState, ptr %2, i64 0, i32 2
  %3 = load i32, ptr %lastline.i, align 8
  %call.i = tail call fastcc i32 @luaK_code(ptr noundef %0, i32 noundef 10, i32 noundef %3)
  %tostore = getelementptr inbounds %struct.ConsControl, ptr %cc, i64 0, i32 4
  store i32 0, ptr %tostore, align 8
  %nh = getelementptr inbounds %struct.ConsControl, ptr %cc, i64 0, i32 2
  store i32 0, ptr %nh, align 8
  %na = getelementptr inbounds %struct.ConsControl, ptr %cc, i64 0, i32 3
  store i32 0, ptr %na, align 4
  %t2 = getelementptr inbounds %struct.ConsControl, ptr %cc, i64 0, i32 1
  store ptr %t, ptr %t2, align 8
  %t.i = getelementptr inbounds %struct.expdesc, ptr %t, i64 0, i32 2
  store i32 -1, ptr %t.i, align 8
  %f.i = getelementptr inbounds %struct.expdesc, ptr %t, i64 0, i32 3
  store i32 -1, ptr %f.i, align 4
  store i32 11, ptr %t, align 8
  %u.i = getelementptr inbounds %struct.expdesc, ptr %t, i64 0, i32 1
  store i32 %call.i, ptr %u.i, align 8
  %t.i27 = getelementptr inbounds %struct.expdesc, ptr %cc, i64 0, i32 2
  store i32 -1, ptr %t.i27, align 8
  %f.i28 = getelementptr inbounds %struct.expdesc, ptr %cc, i64 0, i32 3
  store i32 -1, ptr %f.i28, align 4
  store i32 0, ptr %cc, align 8
  %u.i29 = getelementptr inbounds %struct.expdesc, ptr %cc, i64 0, i32 1
  store i32 0, ptr %u.i29, align 8
  %4 = load ptr, ptr %fs1, align 8
  tail call fastcc void @luaK_dischargevars(ptr noundef %4, ptr noundef nonnull %t)
  %5 = load i32, ptr %t, align 8
  %cmp.i.i = icmp eq i32 %5, 12
  br i1 %cmp.i.i, label %if.then.i.i, label %freeexp.exit.i

if.then.i.i:                                      ; preds = %entry
  %6 = load i32, ptr %u.i, align 8
  %and.i.i.i = and i32 %6, 256
  %tobool.not.i.i.i = icmp eq i32 %and.i.i.i, 0
  br i1 %tobool.not.i.i.i, label %land.lhs.true.i.i.i, label %freeexp.exit.i

land.lhs.true.i.i.i:                              ; preds = %if.then.i.i
  %nactvar.i.i.i = getelementptr inbounds %struct.FuncState, ptr %4, i64 0, i32 13
  %7 = load i8, ptr %nactvar.i.i.i, align 2
  %conv.i.i.i = zext i8 %7 to i32
  %cmp.not.i.i.i = icmp slt i32 %6, %conv.i.i.i
  br i1 %cmp.not.i.i.i, label %freeexp.exit.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %land.lhs.true.i.i.i
  %freereg.i.i.i = getelementptr inbounds %struct.FuncState, ptr %4, i64 0, i32 9
  %8 = load i32, ptr %freereg.i.i.i, align 4
  %dec.i.i.i = add nsw i32 %8, -1
  store i32 %dec.i.i.i, ptr %freereg.i.i.i, align 4
  br label %freeexp.exit.i

freeexp.exit.i:                                   ; preds = %if.then.i.i.i, %land.lhs.true.i.i.i, %if.then.i.i, %entry
  %freereg.i.i7.i = getelementptr inbounds %struct.FuncState, ptr %4, i64 0, i32 9
  %9 = load i32, ptr %freereg.i.i7.i, align 4
  %add.i.i.i = add nsw i32 %9, 1
  %10 = load ptr, ptr %4, align 8
  %maxstacksize.i.i.i = getelementptr inbounds %struct.Proto, ptr %10, i64 0, i32 22
  %11 = load i8, ptr %maxstacksize.i.i.i, align 1
  %conv.i.i8.i = zext i8 %11 to i32
  %cmp.i.i.not.i = icmp slt i32 %9, %conv.i.i8.i
  br i1 %cmp.i.i.not.i, label %luaK_exp2nextreg.exit, label %if.then.i.i9.i

if.then.i.i9.i:                                   ; preds = %freeexp.exit.i
  %cmp2.i.i.i = icmp sgt i32 %9, 248
  br i1 %cmp2.i.i.i, label %if.then4.i.i.i, label %if.end.i.i.i

if.then4.i.i.i:                                   ; preds = %if.then.i.i9.i
  %ls.i.i.i = getelementptr inbounds %struct.FuncState, ptr %4, i64 0, i32 3
  %12 = load ptr, ptr %ls.i.i.i, align 8
  %t.i.i.i.i = getelementptr inbounds %struct.LexState, ptr %12, i64 0, i32 3
  %13 = load i32, ptr %t.i.i.i.i, align 8
  tail call fastcc void @luaX_lexerror(ptr noundef %12, ptr noundef nonnull @.str.150, i32 noundef %13)
  unreachable

if.end.i.i.i:                                     ; preds = %if.then.i.i9.i
  %conv5.i.i.i = trunc i32 %add.i.i.i to i8
  store i8 %conv5.i.i.i, ptr %maxstacksize.i.i.i, align 1
  %.pre.i.i = load i32, ptr %freereg.i.i7.i, align 4
  %.pre3.i.i = add nsw i32 %.pre.i.i, 1
  br label %luaK_exp2nextreg.exit

luaK_exp2nextreg.exit:                            ; preds = %freeexp.exit.i, %if.end.i.i.i
  %add.pre-phi.i.i = phi i32 [ %add.i.i.i, %freeexp.exit.i ], [ %.pre3.i.i, %if.end.i.i.i ]
  store i32 %add.pre-phi.i.i, ptr %freereg.i.i7.i, align 4
  %sub.i = add nsw i32 %add.pre-phi.i.i, -1
  tail call fastcc void @exp2reg(ptr noundef nonnull %4, ptr noundef nonnull %t, i32 noundef %sub.i)
  tail call fastcc void @checknext(ptr noundef nonnull %ls, i32 noundef 123)
  %t4 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 3
  %14 = load i32, ptr %t4, align 8
  %cmp165 = icmp eq i32 %14, 125
  br i1 %cmp165, label %do.end, label %if.end.lr.ph

if.end.lr.ph:                                     ; preds = %luaK_exp2nextreg.exit
  %nactvar.i.i.i.i = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 13
  %freereg.i.i.i.i = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 9
  %lookahead.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 4
  %seminfo.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 4, i32 1
  %lastline.i.i60 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 2
  %seminfo.i.i65 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 3, i32 1
  br label %if.end

if.end:                                           ; preds = %if.end.lr.ph, %do.body.backedge
  %15 = phi i32 [ %14, %if.end.lr.ph ], [ %53, %do.body.backedge ]
  %16 = load i32, ptr %cc, align 8
  %cmp.i = icmp eq i32 %16, 0
  br i1 %cmp.i, label %closelistfield.exit, label %if.end.i

if.end.i:                                         ; preds = %if.end
  call fastcc void @luaK_dischargevars(ptr noundef %0, ptr noundef nonnull %cc)
  %17 = load i32, ptr %cc, align 8
  %cmp.i.i.i = icmp eq i32 %17, 12
  br i1 %cmp.i.i.i, label %if.then.i.i.i34, label %freeexp.exit.i.ithread-pre-split

if.then.i.i.i34:                                  ; preds = %if.end.i
  %18 = load i32, ptr %u.i29, align 8
  %and.i.i.i.i = and i32 %18, 256
  %tobool.not.i.i.i.i = icmp eq i32 %and.i.i.i.i, 0
  br i1 %tobool.not.i.i.i.i, label %land.lhs.true.i.i.i.i, label %freeexp.exit.i.ithread-pre-split

land.lhs.true.i.i.i.i:                            ; preds = %if.then.i.i.i34
  %19 = load i8, ptr %nactvar.i.i.i.i, align 2
  %conv.i.i.i.i = zext i8 %19 to i32
  %cmp.not.i.i.i.i = icmp slt i32 %18, %conv.i.i.i.i
  br i1 %cmp.not.i.i.i.i, label %freeexp.exit.i.ithread-pre-split, label %if.then.i.i.i.i

if.then.i.i.i.i:                                  ; preds = %land.lhs.true.i.i.i.i
  %20 = load i32, ptr %freereg.i.i.i.i, align 4
  %dec.i.i.i.i = add nsw i32 %20, -1
  store i32 %dec.i.i.i.i, ptr %freereg.i.i.i.i, align 4
  br label %freeexp.exit.i.i

freeexp.exit.i.ithread-pre-split:                 ; preds = %if.end.i, %if.then.i.i.i34, %land.lhs.true.i.i.i.i
  %.pr166 = load i32, ptr %freereg.i.i.i.i, align 4
  br label %freeexp.exit.i.i

freeexp.exit.i.i:                                 ; preds = %freeexp.exit.i.ithread-pre-split, %if.then.i.i.i.i
  %21 = phi i32 [ %.pr166, %freeexp.exit.i.ithread-pre-split ], [ %dec.i.i.i.i, %if.then.i.i.i.i ]
  %add.i.i.i.i = add nsw i32 %21, 1
  %22 = load ptr, ptr %0, align 8
  %maxstacksize.i.i.i.i = getelementptr inbounds %struct.Proto, ptr %22, i64 0, i32 22
  %23 = load i8, ptr %maxstacksize.i.i.i.i, align 1
  %conv.i.i8.i.i = zext i8 %23 to i32
  %cmp.i.i.not.i.i = icmp slt i32 %21, %conv.i.i8.i.i
  br i1 %cmp.i.i.not.i.i, label %luaK_exp2nextreg.exit.i, label %if.then.i.i9.i.i

if.then.i.i9.i.i:                                 ; preds = %freeexp.exit.i.i
  %cmp2.i.i.i.i = icmp sgt i32 %21, 248
  br i1 %cmp2.i.i.i.i, label %if.then4.i.i.i.i, label %if.end.i.i.i.i

if.then4.i.i.i.i:                                 ; preds = %if.then.i.i9.i.i
  %24 = load ptr, ptr %ls.i, align 8
  %t.i.i.i.i.i = getelementptr inbounds %struct.LexState, ptr %24, i64 0, i32 3
  %25 = load i32, ptr %t.i.i.i.i.i, align 8
  call fastcc void @luaX_lexerror(ptr noundef %24, ptr noundef nonnull @.str.150, i32 noundef %25)
  unreachable

if.end.i.i.i.i:                                   ; preds = %if.then.i.i9.i.i
  %conv5.i.i.i.i = trunc i32 %add.i.i.i.i to i8
  store i8 %conv5.i.i.i.i, ptr %maxstacksize.i.i.i.i, align 1
  %.pre.i.i.i = load i32, ptr %freereg.i.i.i.i, align 4
  %.pre3.i.i.i = add nsw i32 %.pre.i.i.i, 1
  br label %luaK_exp2nextreg.exit.i

luaK_exp2nextreg.exit.i:                          ; preds = %if.end.i.i.i.i, %freeexp.exit.i.i
  %add.pre-phi.i.i.i = phi i32 [ %add.i.i.i.i, %freeexp.exit.i.i ], [ %.pre3.i.i.i, %if.end.i.i.i.i ]
  store i32 %add.pre-phi.i.i.i, ptr %freereg.i.i.i.i, align 4
  %sub.i.i = add nsw i32 %add.pre-phi.i.i.i, -1
  call fastcc void @exp2reg(ptr noundef nonnull %0, ptr noundef nonnull %cc, i32 noundef %sub.i.i)
  store i32 0, ptr %cc, align 8
  %26 = load i32, ptr %tostore, align 8
  %cmp4.i = icmp eq i32 %26, 50
  br i1 %cmp4.i, label %if.then5.i, label %closelistfield.exitthread-pre-split

if.then5.i:                                       ; preds = %luaK_exp2nextreg.exit.i
  %27 = load ptr, ptr %t2, align 8
  %u.i31 = getelementptr inbounds %struct.expdesc, ptr %27, i64 0, i32 1
  %28 = load i32, ptr %u.i31, align 8
  %29 = load i32, ptr %na, align 4
  %sub.i9.i = add nsw i32 %29, -1
  %div.i.i = sdiv i32 %sub.i9.i, 50
  %add.i.i = add nsw i32 %div.i.i, 1
  %cmp1.i.i = icmp slt i32 %29, 25551
  %shl1.i.i.i = shl i32 %28, 6
  br i1 %cmp1.i.i, label %if.then.i.i32, label %if.else.i.i

if.then.i.i32:                                    ; preds = %if.then5.i
  %shl4.i.i.i = shl i32 %add.i.i, 14
  %30 = or i32 %shl1.i.i.i, %shl4.i.i.i
  %or5.i.i.i = or i32 %30, 419430434
  br label %luaK_setlist.exit.i

if.else.i.i:                                      ; preds = %if.then5.i
  %or3.i14.i.i = or i32 %shl1.i.i.i, 419430434
  %31 = load ptr, ptr %ls.i, align 8
  %lastline.i16.i.i = getelementptr inbounds %struct.LexState, ptr %31, i64 0, i32 2
  %32 = load i32, ptr %lastline.i16.i.i, align 8
  %call.i17.i.i = call fastcc i32 @luaK_code(ptr noundef nonnull %0, i32 noundef %or3.i14.i.i, i32 noundef %32)
  br label %luaK_setlist.exit.i

luaK_setlist.exit.i:                              ; preds = %if.else.i.i, %if.then.i.i32
  %add.sink.i.i = phi i32 [ %add.i.i, %if.else.i.i ], [ %or5.i.i.i, %if.then.i.i32 ]
  %33 = load ptr, ptr %ls.i, align 8
  %lastline.i.i = getelementptr inbounds %struct.LexState, ptr %33, i64 0, i32 2
  %34 = load i32, ptr %lastline.i.i, align 8
  %call3.i.i = call fastcc i32 @luaK_code(ptr noundef nonnull %0, i32 noundef %add.sink.i.i, i32 noundef %34)
  %add4.i.i = add nsw i32 %28, 1
  store i32 %add4.i.i, ptr %freereg.i.i.i.i, align 4
  store i32 0, ptr %tostore, align 8
  br label %closelistfield.exitthread-pre-split

closelistfield.exitthread-pre-split:              ; preds = %luaK_setlist.exit.i, %luaK_exp2nextreg.exit.i
  %.pr = load i32, ptr %t4, align 8
  br label %closelistfield.exit

closelistfield.exit:                              ; preds = %closelistfield.exitthread-pre-split, %if.end
  %35 = phi i32 [ %.pr, %closelistfield.exitthread-pre-split ], [ %15, %if.end ]
  switch i32 %35, label %sw.default [
    i32 285, label %sw.bb
    i32 91, label %sw.bb11
  ]

sw.bb:                                            ; preds = %closelistfield.exit
  %call.i35 = call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i)
  store i32 %call.i35, ptr %lookahead.i, align 8
  %cmp8.not = icmp eq i32 %call.i35, 61
  br i1 %cmp8.not, label %if.else, label %if.then9

if.then9:                                         ; preds = %sw.bb
  %call.i148 = call fastcc i32 @subexpr(ptr noundef nonnull %ls, ptr noundef nonnull %cc, i32 noundef 0), !range !93
  %36 = load i32, ptr %na, align 4
  %cmp.i37 = icmp sgt i32 %36, 2147483645
  br i1 %cmp.i37, label %if.then.i, label %listfield.exit

if.then.i:                                        ; preds = %if.then9
  %37 = load ptr, ptr %fs1, align 8
  %38 = load ptr, ptr %37, align 8
  %linedefined.i = getelementptr inbounds %struct.Proto, ptr %38, i64 0, i32 16
  %39 = load i32, ptr %linedefined.i, align 8
  %cmp.i145 = icmp eq i32 %39, 0
  %L.i = getelementptr inbounds %struct.FuncState, ptr %37, i64 0, i32 4
  %40 = load ptr, ptr %L.i, align 8
  br i1 %cmp.i145, label %cond.true.i, label %cond.false.i

cond.true.i:                                      ; preds = %if.then.i
  %call.i147 = call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %40, ptr noundef nonnull @.str.153, i32 noundef 2147483645, ptr noundef nonnull @.str.152)
  br label %cond.end.i

cond.false.i:                                     ; preds = %if.then.i
  %call4.i = call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %40, ptr noundef nonnull @.str.154, i32 noundef %39, i32 noundef 2147483645, ptr noundef nonnull @.str.152)
  br label %cond.end.i

cond.end.i:                                       ; preds = %cond.false.i, %cond.true.i
  %cond.i = phi ptr [ %call.i147, %cond.true.i ], [ %call4.i, %cond.false.i ]
  %ls.i146 = getelementptr inbounds %struct.FuncState, ptr %37, i64 0, i32 3
  %41 = load ptr, ptr %ls.i146, align 8
  call fastcc void @luaX_lexerror(ptr noundef %41, ptr noundef %cond.i, i32 noundef 0)
  unreachable

listfield.exit:                                   ; preds = %if.then9
  %inc.i = add nsw i32 %36, 1
  store i32 %inc.i, ptr %na, align 4
  %42 = load i32, ptr %tostore, align 8
  %inc2.i = add nsw i32 %42, 1
  store i32 %inc2.i, ptr %tostore, align 8
  br label %do.cond

if.else:                                          ; preds = %sw.bb
  call fastcc void @recfield(ptr noundef nonnull %ls, ptr noundef nonnull %cc)
  br label %do.cond

sw.bb11:                                          ; preds = %closelistfield.exit
  call fastcc void @recfield(ptr noundef nonnull %ls, ptr noundef nonnull %cc)
  br label %do.cond

sw.default:                                       ; preds = %closelistfield.exit
  %call.i160 = call fastcc i32 @subexpr(ptr noundef nonnull %ls, ptr noundef nonnull %cc, i32 noundef 0), !range !93
  %43 = load i32, ptr %na, align 4
  %cmp.i41 = icmp sgt i32 %43, 2147483645
  br i1 %cmp.i41, label %if.then.i46, label %listfield.exit48

if.then.i46:                                      ; preds = %sw.default
  %44 = load ptr, ptr %fs1, align 8
  %45 = load ptr, ptr %44, align 8
  %linedefined.i149 = getelementptr inbounds %struct.Proto, ptr %45, i64 0, i32 16
  %46 = load i32, ptr %linedefined.i149, align 8
  %cmp.i150 = icmp eq i32 %46, 0
  %L.i151 = getelementptr inbounds %struct.FuncState, ptr %44, i64 0, i32 4
  %47 = load ptr, ptr %L.i151, align 8
  br i1 %cmp.i150, label %cond.true.i157, label %cond.false.i152

cond.true.i157:                                   ; preds = %if.then.i46
  %call.i158 = call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %47, ptr noundef nonnull @.str.153, i32 noundef 2147483645, ptr noundef nonnull @.str.152)
  br label %cond.end.i154

cond.false.i152:                                  ; preds = %if.then.i46
  %call4.i153 = call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %47, ptr noundef nonnull @.str.154, i32 noundef %46, i32 noundef 2147483645, ptr noundef nonnull @.str.152)
  br label %cond.end.i154

cond.end.i154:                                    ; preds = %cond.false.i152, %cond.true.i157
  %cond.i155 = phi ptr [ %call.i158, %cond.true.i157 ], [ %call4.i153, %cond.false.i152 ]
  %ls.i156 = getelementptr inbounds %struct.FuncState, ptr %44, i64 0, i32 3
  %48 = load ptr, ptr %ls.i156, align 8
  call fastcc void @luaX_lexerror(ptr noundef %48, ptr noundef %cond.i155, i32 noundef 0)
  unreachable

listfield.exit48:                                 ; preds = %sw.default
  %inc.i43 = add nsw i32 %43, 1
  store i32 %inc.i43, ptr %na, align 4
  %49 = load i32, ptr %tostore, align 8
  %inc2.i45 = add nsw i32 %49, 1
  store i32 %inc2.i45, ptr %tostore, align 8
  br label %do.cond

do.cond:                                          ; preds = %sw.bb11, %listfield.exit48, %if.else, %listfield.exit
  %50 = load i32, ptr %t4, align 8
  switch i32 %50, label %do.end [
    i32 44, label %if.then.i51
    i32 59, label %if.then.i58
  ]

if.then.i51:                                      ; preds = %do.cond
  %51 = load i32, ptr %linenumber, align 4
  store i32 %51, ptr %lastline.i.i60, align 8
  %52 = load i32, ptr %lookahead.i, align 8
  %cmp.not.i.i = icmp eq i32 %52, 287
  br i1 %cmp.not.i.i, label %if.else.i.i54, label %do.body.backedgethread-pre-split

if.else.i.i54:                                    ; preds = %if.then.i51
  %call.i.i = call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i.i65)
  store i32 %call.i.i, ptr %t4, align 8
  br label %do.body.backedge

do.body.backedgethread-pre-split:                 ; preds = %if.then.i51, %if.then.i58
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t4, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i, align 8
  %.pr167 = load i32, ptr %t4, align 8
  br label %do.body.backedge

do.body.backedge:                                 ; preds = %do.body.backedgethread-pre-split, %if.else.i.i64, %if.else.i.i54
  %53 = phi i32 [ %.pr167, %do.body.backedgethread-pre-split ], [ %call.i.i66, %if.else.i.i64 ], [ %call.i.i, %if.else.i.i54 ]
  %cmp = icmp eq i32 %53, 125
  br i1 %cmp, label %do.end, label %if.end, !llvm.loop !116

if.then.i58:                                      ; preds = %do.cond
  %54 = load i32, ptr %linenumber, align 4
  store i32 %54, ptr %lastline.i.i60, align 8
  %55 = load i32, ptr %lookahead.i, align 8
  %cmp.not.i.i62 = icmp eq i32 %55, 287
  br i1 %cmp.not.i.i62, label %if.else.i.i64, label %do.body.backedgethread-pre-split

if.else.i.i64:                                    ; preds = %if.then.i58
  %call.i.i66 = call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i.i65)
  store i32 %call.i.i66, ptr %t4, align 8
  br label %do.body.backedge

do.end:                                           ; preds = %do.body.backedge, %do.cond, %luaK_exp2nextreg.exit
  call fastcc void @check_match(ptr noundef nonnull %ls, i32 noundef 125, i32 noundef 123, i32 noundef %1)
  %56 = load i32, ptr %tostore, align 8
  %cmp.i69 = icmp eq i32 %56, 0
  br i1 %cmp.i69, label %lastlistfield.exit, label %if.end.i70

if.end.i70:                                       ; preds = %do.end
  %57 = load i32, ptr %cc, align 8
  switch i32 %57, label %if.then11.i [
    i32 0, label %if.end13.i
    i32 13, label %if.then.i.i107
    i32 14, label %if.then10.i.i
  ]

if.then.i.i107:                                   ; preds = %if.end.i70
  %58 = load ptr, ptr %0, align 8
  %code.i.i = getelementptr inbounds %struct.Proto, ptr %58, i64 0, i32 4
  %59 = load ptr, ptr %code.i.i, align 8
  %60 = load i32, ptr %u.i29, align 8
  %idxprom.i.i = sext i32 %60 to i64
  %arrayidx.i.i = getelementptr inbounds i32, ptr %59, i64 %idxprom.i.i
  %61 = load i32, ptr %arrayidx.i.i, align 4
  %and.i.i = and i32 %61, -8372225
  store i32 %and.i.i, ptr %arrayidx.i.i, align 4
  br label %luaK_setreturns.exit.i

if.then10.i.i:                                    ; preds = %if.end.i70
  %62 = load ptr, ptr %0, align 8
  %code12.i.i = getelementptr inbounds %struct.Proto, ptr %62, i64 0, i32 4
  %63 = load ptr, ptr %code12.i.i, align 8
  %64 = load i32, ptr %u.i29, align 8
  %idxprom15.i.i = sext i32 %64 to i64
  %arrayidx16.i.i = getelementptr inbounds i32, ptr %63, i64 %idxprom15.i.i
  %65 = load i32, ptr %arrayidx16.i.i, align 4
  %and17.i.i = and i32 %65, 8388607
  store i32 %and17.i.i, ptr %arrayidx16.i.i, align 4
  %66 = load ptr, ptr %0, align 8
  %code29.i.i = getelementptr inbounds %struct.Proto, ptr %66, i64 0, i32 4
  %67 = load ptr, ptr %code29.i.i, align 8
  %68 = load i32, ptr %u.i29, align 8
  %idxprom32.i.i = sext i32 %68 to i64
  %arrayidx33.i.i = getelementptr inbounds i32, ptr %67, i64 %idxprom32.i.i
  %69 = load i32, ptr %arrayidx33.i.i, align 4
  %and34.i.i = and i32 %69, -16321
  %freereg.i.i = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 9
  %70 = load i32, ptr %freereg.i.i, align 4
  %shl35.i.i = shl i32 %70, 6
  %and36.i.i = and i32 %shl35.i.i, 16320
  %or37.i.i = or disjoint i32 %and36.i.i, %and34.i.i
  store i32 %or37.i.i, ptr %arrayidx33.i.i, align 4
  %71 = load i32, ptr %freereg.i.i, align 4
  %add.i.i.i.i71 = add nsw i32 %71, 1
  %72 = load ptr, ptr %0, align 8
  %maxstacksize.i.i.i.i72 = getelementptr inbounds %struct.Proto, ptr %72, i64 0, i32 22
  %73 = load i8, ptr %maxstacksize.i.i.i.i72, align 1
  %conv.i.i.i.i73 = zext i8 %73 to i32
  %cmp.i.i.not.i.i74 = icmp slt i32 %71, %conv.i.i.i.i73
  br i1 %cmp.i.i.not.i.i74, label %luaK_reserveregs.exit.i.i, label %if.then.i.i.i.i75

if.then.i.i.i.i75:                                ; preds = %if.then10.i.i
  %cmp2.i.i.i.i76 = icmp sgt i32 %71, 248
  br i1 %cmp2.i.i.i.i76, label %if.then4.i.i.i.i104, label %if.end.i.i.i.i77

if.then4.i.i.i.i104:                              ; preds = %if.then.i.i.i.i75
  %74 = load ptr, ptr %ls.i, align 8
  %t.i.i.i.i.i106 = getelementptr inbounds %struct.LexState, ptr %74, i64 0, i32 3
  %75 = load i32, ptr %t.i.i.i.i.i106, align 8
  call fastcc void @luaX_lexerror(ptr noundef %74, ptr noundef nonnull @.str.150, i32 noundef %75)
  unreachable

if.end.i.i.i.i77:                                 ; preds = %if.then.i.i.i.i75
  %conv5.i.i.i.i78 = trunc i32 %add.i.i.i.i71 to i8
  store i8 %conv5.i.i.i.i78, ptr %maxstacksize.i.i.i.i72, align 1
  %.pre.i.i.i79 = load i32, ptr %freereg.i.i, align 4
  %.pre3.i.i.i80 = add nsw i32 %.pre.i.i.i79, 1
  br label %luaK_reserveregs.exit.i.i

luaK_reserveregs.exit.i.i:                        ; preds = %if.end.i.i.i.i77, %if.then10.i.i
  %add.pre-phi.i.i.i81 = phi i32 [ %add.i.i.i.i71, %if.then10.i.i ], [ %.pre3.i.i.i80, %if.end.i.i.i.i77 ]
  store i32 %add.pre-phi.i.i.i81, ptr %freereg.i.i, align 4
  br label %luaK_setreturns.exit.i

luaK_setreturns.exit.i:                           ; preds = %luaK_reserveregs.exit.i.i, %if.then.i.i107
  %76 = load ptr, ptr %t2, align 8
  %u.i83 = getelementptr inbounds %struct.expdesc, ptr %76, i64 0, i32 1
  %77 = load i32, ptr %u.i83, align 8
  %78 = load i32, ptr %na, align 4
  %sub.i.i85 = add nsw i32 %78, -1
  %div.i.i86 = sdiv i32 %sub.i.i85, 50
  %add.i.i87 = add nsw i32 %div.i.i86, 1
  %cmp1.i.i88 = icmp slt i32 %78, 25551
  %shl1.i.i.i89 = shl i32 %77, 6
  br i1 %cmp1.i.i88, label %if.then.i16.i, label %if.else.i.i90

if.then.i16.i:                                    ; preds = %luaK_setreturns.exit.i
  %shl4.i.i.i101 = shl i32 %add.i.i87, 14
  %or3.i.i.i = or i32 %shl1.i.i.i89, %shl4.i.i.i101
  %or5.i.i.i102 = or disjoint i32 %or3.i.i.i, 34
  br label %luaK_setlist.exit.i95

if.else.i.i90:                                    ; preds = %luaK_setreturns.exit.i
  %or3.i14.i.i91 = or disjoint i32 %shl1.i.i.i89, 34
  %79 = load ptr, ptr %ls.i, align 8
  %lastline.i16.i.i93 = getelementptr inbounds %struct.LexState, ptr %79, i64 0, i32 2
  %80 = load i32, ptr %lastline.i16.i.i93, align 8
  %call.i17.i.i94 = call fastcc i32 @luaK_code(ptr noundef nonnull %0, i32 noundef %or3.i14.i.i91, i32 noundef %80)
  br label %luaK_setlist.exit.i95

luaK_setlist.exit.i95:                            ; preds = %if.else.i.i90, %if.then.i16.i
  %add.sink.i.i97 = phi i32 [ %add.i.i87, %if.else.i.i90 ], [ %or5.i.i.i102, %if.then.i16.i ]
  %81 = load ptr, ptr %ls.i, align 8
  %lastline.i.i98 = getelementptr inbounds %struct.LexState, ptr %81, i64 0, i32 2
  %82 = load i32, ptr %lastline.i.i98, align 8
  %call3.i.i99 = call fastcc i32 @luaK_code(ptr noundef nonnull %0, i32 noundef %add.sink.i.i97, i32 noundef %82)
  %add4.i.i100 = add nsw i32 %77, 1
  %freereg.i15.i = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 9
  store i32 %add4.i.i100, ptr %freereg.i15.i, align 4
  %83 = load i32, ptr %na, align 4
  %dec.i = add nsw i32 %83, -1
  store i32 %dec.i, ptr %na, align 4
  br label %lastlistfield.exit

if.then11.i:                                      ; preds = %if.end.i70
  call fastcc void @luaK_dischargevars(ptr noundef %0, ptr noundef nonnull %cc)
  %84 = load i32, ptr %cc, align 8
  %cmp.i.i.i110 = icmp eq i32 %84, 12
  br i1 %cmp.i.i.i110, label %if.then.i.i.i116, label %freeexp.exit.i.i111

if.then.i.i.i116:                                 ; preds = %if.then11.i
  %85 = load i32, ptr %u.i29, align 8
  %and.i.i.i.i118 = and i32 %85, 256
  %tobool.not.i.i.i.i119 = icmp eq i32 %and.i.i.i.i118, 0
  br i1 %tobool.not.i.i.i.i119, label %land.lhs.true.i.i.i.i120, label %freeexp.exit.i.i111

land.lhs.true.i.i.i.i120:                         ; preds = %if.then.i.i.i116
  %nactvar.i.i.i.i121 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 13
  %86 = load i8, ptr %nactvar.i.i.i.i121, align 2
  %conv.i.i.i31.i = zext i8 %86 to i32
  %cmp.not.i.i.i.i122 = icmp slt i32 %85, %conv.i.i.i31.i
  br i1 %cmp.not.i.i.i.i122, label %freeexp.exit.i.i111, label %if.then.i.i.i32.i

if.then.i.i.i32.i:                                ; preds = %land.lhs.true.i.i.i.i120
  %freereg.i.i.i.i123 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 9
  %87 = load i32, ptr %freereg.i.i.i.i123, align 4
  %dec.i.i.i.i124 = add nsw i32 %87, -1
  store i32 %dec.i.i.i.i124, ptr %freereg.i.i.i.i123, align 4
  br label %freeexp.exit.i.i111

freeexp.exit.i.i111:                              ; preds = %if.then.i.i.i32.i, %land.lhs.true.i.i.i.i120, %if.then.i.i.i116, %if.then11.i
  %freereg.i.i7.i.i112 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 9
  %88 = load i32, ptr %freereg.i.i7.i.i112, align 4
  %add.i.i.i17.i = add nsw i32 %88, 1
  %89 = load ptr, ptr %0, align 8
  %maxstacksize.i.i.i18.i = getelementptr inbounds %struct.Proto, ptr %89, i64 0, i32 22
  %90 = load i8, ptr %maxstacksize.i.i.i18.i, align 1
  %conv.i.i8.i.i113 = zext i8 %90 to i32
  %cmp.i.i.not.i19.i = icmp slt i32 %88, %conv.i.i8.i.i113
  br i1 %cmp.i.i.not.i19.i, label %luaK_exp2nextreg.exit.i115, label %if.then.i.i9.i.i114

if.then.i.i9.i.i114:                              ; preds = %freeexp.exit.i.i111
  %cmp2.i.i.i20.i = icmp sgt i32 %88, 248
  br i1 %cmp2.i.i.i20.i, label %if.then4.i.i.i28.i, label %if.end.i.i.i21.i

if.then4.i.i.i28.i:                               ; preds = %if.then.i.i9.i.i114
  %91 = load ptr, ptr %ls.i, align 8
  %t.i.i.i.i30.i = getelementptr inbounds %struct.LexState, ptr %91, i64 0, i32 3
  %92 = load i32, ptr %t.i.i.i.i30.i, align 8
  call fastcc void @luaX_lexerror(ptr noundef %91, ptr noundef nonnull @.str.150, i32 noundef %92)
  unreachable

if.end.i.i.i21.i:                                 ; preds = %if.then.i.i9.i.i114
  %conv5.i.i.i22.i = trunc i32 %add.i.i.i17.i to i8
  store i8 %conv5.i.i.i22.i, ptr %maxstacksize.i.i.i18.i, align 1
  %.pre.i.i23.i = load i32, ptr %freereg.i.i7.i.i112, align 4
  %.pre3.i.i24.i = add nsw i32 %.pre.i.i23.i, 1
  br label %luaK_exp2nextreg.exit.i115

luaK_exp2nextreg.exit.i115:                       ; preds = %if.end.i.i.i21.i, %freeexp.exit.i.i111
  %add.pre-phi.i.i26.i = phi i32 [ %add.i.i.i17.i, %freeexp.exit.i.i111 ], [ %.pre3.i.i24.i, %if.end.i.i.i21.i ]
  store i32 %add.pre-phi.i.i26.i, ptr %freereg.i.i7.i.i112, align 4
  %sub.i27.i = add nsw i32 %add.pre-phi.i.i26.i, -1
  call fastcc void @exp2reg(ptr noundef nonnull %0, ptr noundef nonnull %cc, i32 noundef %sub.i27.i)
  %.pre.i = load i32, ptr %tostore, align 8
  br label %if.end13.i

if.end13.i:                                       ; preds = %luaK_exp2nextreg.exit.i115, %if.end.i70
  %93 = phi i32 [ %56, %if.end.i70 ], [ %.pre.i, %luaK_exp2nextreg.exit.i115 ]
  %94 = load ptr, ptr %t2, align 8
  %u15.i = getelementptr inbounds %struct.expdesc, ptr %94, i64 0, i32 1
  %95 = load i32, ptr %u15.i, align 8
  %96 = load i32, ptr %na, align 4
  %sub.i33.i = add nsw i32 %96, -1
  %div.i34.i = sdiv i32 %sub.i33.i, 50
  %add.i35.i = add nsw i32 %div.i34.i, 1
  %cmp.i.i109 = icmp eq i32 %93, -1
  %97 = shl i32 %93, 23
  %cmp1.i36.i = icmp slt i32 %96, 25551
  %shl1.i.i37.i = shl i32 %95, 6
  %shl2.i.i.i = select i1 %cmp.i.i109, i32 0, i32 %97
  br i1 %cmp1.i36.i, label %if.then.i49.i, label %if.else.i38.i

if.then.i49.i:                                    ; preds = %if.end13.i
  %shl4.i.i50.i = shl i32 %add.i35.i, 14
  %98 = or i32 %shl1.i.i37.i, %shl4.i.i50.i
  %or3.i.i51.i = or i32 %98, %shl2.i.i.i
  %or5.i.i52.i = or disjoint i32 %or3.i.i51.i, 34
  br label %luaK_setlist.exit54.i

if.else.i38.i:                                    ; preds = %if.end13.i
  %or.i12.i.i = or i32 %shl2.i.i.i, %shl1.i.i37.i
  %or3.i14.i39.i = or disjoint i32 %or.i12.i.i, 34
  %99 = load ptr, ptr %ls.i, align 8
  %lastline.i16.i41.i = getelementptr inbounds %struct.LexState, ptr %99, i64 0, i32 2
  %100 = load i32, ptr %lastline.i16.i41.i, align 8
  %call.i17.i42.i = call fastcc i32 @luaK_code(ptr noundef %0, i32 noundef %or3.i14.i39.i, i32 noundef %100)
  br label %luaK_setlist.exit54.i

luaK_setlist.exit54.i:                            ; preds = %if.else.i38.i, %if.then.i49.i
  %add.sink.i44.i = phi i32 [ %add.i35.i, %if.else.i38.i ], [ %or5.i.i52.i, %if.then.i49.i ]
  %101 = load ptr, ptr %ls.i, align 8
  %lastline.i45.i = getelementptr inbounds %struct.LexState, ptr %101, i64 0, i32 2
  %102 = load i32, ptr %lastline.i45.i, align 8
  %call3.i46.i = call fastcc i32 @luaK_code(ptr noundef %0, i32 noundef %add.sink.i44.i, i32 noundef %102)
  %add4.i47.i = add nsw i32 %95, 1
  %freereg.i48.i = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 9
  store i32 %add4.i47.i, ptr %freereg.i48.i, align 4
  br label %lastlistfield.exit

lastlistfield.exit:                               ; preds = %do.end, %luaK_setlist.exit.i95, %luaK_setlist.exit54.i
  %103 = load ptr, ptr %0, align 8
  %code = getelementptr inbounds %struct.Proto, ptr %103, i64 0, i32 4
  %104 = load ptr, ptr %code, align 8
  %idxprom = sext i32 %call.i to i64
  %arrayidx = getelementptr inbounds i32, ptr %104, i64 %idxprom
  %105 = load i32, ptr %arrayidx, align 4
  %and = and i32 %105, 8388607
  %106 = load i32, ptr %na, align 4
  %cmp6.i = icmp ugt i32 %106, 15
  br i1 %cmp6.i, label %while.body.i, label %luaO_int2fb.exit

while.body.i:                                     ; preds = %lastlistfield.exit, %while.body.i
  %e.08.i = phi i32 [ %inc.i127, %while.body.i ], [ 0, %lastlistfield.exit ]
  %x.addr.07.i = phi i32 [ %shr.i, %while.body.i ], [ %106, %lastlistfield.exit ]
  %add.i = add i32 %x.addr.07.i, 1
  %shr.i = lshr i32 %add.i, 1
  %inc.i127 = add nuw nsw i32 %e.08.i, 1
  %cmp.i128 = icmp ugt i32 %add.i, 31
  br i1 %cmp.i128, label %while.body.i, label %while.end.loopexit.i, !llvm.loop !117

while.end.loopexit.i:                             ; preds = %while.body.i
  %107 = shl i32 %inc.i127, 3
  %108 = add i32 %107, 8
  br label %luaO_int2fb.exit

luaO_int2fb.exit:                                 ; preds = %lastlistfield.exit, %while.end.loopexit.i
  %x.addr.0.lcssa.i = phi i32 [ %106, %lastlistfield.exit ], [ %shr.i, %while.end.loopexit.i ]
  %e.0.lcssa.i = phi i32 [ 8, %lastlistfield.exit ], [ %108, %while.end.loopexit.i ]
  %cmp1.i = icmp ult i32 %x.addr.0.lcssa.i, 8
  %sub.i125 = add nuw i32 %x.addr.0.lcssa.i, 504
  %or.i = or i32 %e.0.lcssa.i, %sub.i125
  %retval.0.i126 = select i1 %cmp1.i, i32 %x.addr.0.lcssa.i, i32 %or.i
  %shl = shl i32 %retval.0.i126, 23
  %or = or disjoint i32 %shl, %and
  store i32 %or, ptr %arrayidx, align 4
  %109 = load ptr, ptr %0, align 8
  %code23 = getelementptr inbounds %struct.Proto, ptr %109, i64 0, i32 4
  %110 = load ptr, ptr %code23, align 8
  %arrayidx25 = getelementptr inbounds i32, ptr %110, i64 %idxprom
  %111 = load i32, ptr %arrayidx25, align 4
  %112 = load i32, ptr %nh, align 8
  %cmp6.i129 = icmp ugt i32 %112, 15
  br i1 %cmp6.i129, label %while.body.i136, label %luaO_int2fb.exit144

while.body.i136:                                  ; preds = %luaO_int2fb.exit, %while.body.i136
  %e.08.i137 = phi i32 [ %inc.i141, %while.body.i136 ], [ 0, %luaO_int2fb.exit ]
  %x.addr.07.i138 = phi i32 [ %shr.i140, %while.body.i136 ], [ %112, %luaO_int2fb.exit ]
  %add.i139 = add i32 %x.addr.07.i138, 1
  %shr.i140 = lshr i32 %add.i139, 1
  %inc.i141 = add nuw nsw i32 %e.08.i137, 1
  %cmp.i142 = icmp ugt i32 %add.i139, 31
  br i1 %cmp.i142, label %while.body.i136, label %while.end.loopexit.i143, !llvm.loop !117

while.end.loopexit.i143:                          ; preds = %while.body.i136
  %113 = shl i32 %inc.i141, 3
  %114 = add i32 %113, 8
  br label %luaO_int2fb.exit144

luaO_int2fb.exit144:                              ; preds = %luaO_int2fb.exit, %while.end.loopexit.i143
  %x.addr.0.lcssa.i130 = phi i32 [ %112, %luaO_int2fb.exit ], [ %shr.i140, %while.end.loopexit.i143 ]
  %e.0.lcssa.i131 = phi i32 [ 8, %luaO_int2fb.exit ], [ %114, %while.end.loopexit.i143 ]
  %and26 = and i32 %111, -8372225
  %cmp1.i132 = icmp ult i32 %x.addr.0.lcssa.i130, 8
  %sub.i133 = add nuw i32 %x.addr.0.lcssa.i130, 504
  %or.i134 = or i32 %e.0.lcssa.i131, %sub.i133
  %retval.0.i135 = select i1 %cmp1.i132, i32 %x.addr.0.lcssa.i130, i32 %or.i134
  %shl29 = shl i32 %retval.0.i135, 14
  %and30 = and i32 %shl29, 8372224
  %or31 = or disjoint i32 %and30, %and26
  store i32 %or31, ptr %arrayidx25, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @primaryexp(ptr noundef %ls, ptr noundef %v) unnamed_addr #0 {
entry:
  %o.i.i.i = alloca %struct.lua_TValue, align 8
  %key = alloca %struct.expdesc, align 8
  %key4 = alloca %struct.expdesc, align 8
  %fs1 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 5
  %0 = load ptr, ptr %fs1, align 8
  %t.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 3
  %1 = load i32, ptr %t.i, align 8
  switch i32 %1, label %sw.default.i [
    i32 40, label %sw.bb.i
    i32 285, label %sw.bb1.i
  ]

sw.bb.i:                                          ; preds = %entry
  %linenumber.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 1
  %2 = load i32, ptr %linenumber.i, align 4
  %lastline.i53 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 2
  store i32 %2, ptr %lastline.i53, align 8
  %lookahead.i54 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 4
  %3 = load i32, ptr %lookahead.i54, align 8
  %cmp.not.i55 = icmp eq i32 %3, 287
  br i1 %cmp.not.i55, label %if.else.i58, label %if.then.i57

if.then.i57:                                      ; preds = %sw.bb.i
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t.i, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i54, i64 16, i1 false)
  store i32 287, ptr %lookahead.i54, align 8
  br label %luaX_next.exit61

if.else.i58:                                      ; preds = %sw.bb.i
  %seminfo.i59 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 3, i32 1
  %call.i60 = tail call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i59)
  store i32 %call.i60, ptr %t.i, align 8
  br label %luaX_next.exit61

luaX_next.exit61:                                 ; preds = %if.then.i57, %if.else.i58
  %call.i51 = tail call fastcc i32 @subexpr(ptr noundef nonnull %ls, ptr noundef %v, i32 noundef 0), !range !93
  tail call fastcc void @check_match(ptr noundef nonnull %ls, i32 noundef 41, i32 noundef 40, i32 noundef %2)
  %4 = load ptr, ptr %fs1, align 8
  tail call fastcc void @luaK_dischargevars(ptr noundef %4, ptr noundef %v)
  br label %prefixexp.exit

sw.bb1.i:                                         ; preds = %entry
  tail call fastcc void @singlevar(ptr noundef nonnull %ls, ptr noundef %v)
  br label %prefixexp.exit

sw.default.i:                                     ; preds = %entry
  tail call fastcc void @luaX_lexerror(ptr noundef nonnull %ls, ptr noundef nonnull @.str.159, i32 noundef %1)
  unreachable

prefixexp.exit:                                   ; preds = %luaX_next.exit61, %sw.bb1.i
  %u9.i.i = getelementptr inbounds %struct.expdesc, ptr %v, i64 0, i32 1
  %aux.i80 = getelementptr inbounds i8, ptr %v, i64 12
  %nactvar.i.i = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 13
  %freereg.i.i = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 9
  %ls.i37.i = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  %linenumber.i20 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 1
  %lastline.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 2
  %lookahead.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 4
  %seminfo.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 3, i32 1
  %tt.i.i.i = getelementptr inbounds %struct.lua_TValue, ptr %o.i.i.i, i64 0, i32 1
  %t.i.i3.i = getelementptr inbounds %struct.expdesc, ptr %key4, i64 0, i32 2
  %f.i.i.i = getelementptr inbounds %struct.expdesc, ptr %key4, i64 0, i32 3
  %u.i.i.i = getelementptr inbounds %struct.expdesc, ptr %key4, i64 0, i32 1
  %t.i62 = getelementptr inbounds %struct.expdesc, ptr %key, i64 0, i32 2
  %f.i = getelementptr inbounds %struct.expdesc, ptr %key, i64 0, i32 3
  br label %for.cond

for.cond:                                         ; preds = %for.cond.backedge, %prefixexp.exit
  %5 = load i32, ptr %t.i, align 8
  switch i32 %5, label %sw.default [
    i32 46, label %sw.bb
    i32 91, label %sw.bb2
    i32 58, label %sw.bb3
    i32 40, label %sw.bb5
    i32 286, label %sw.bb5
    i32 123, label %sw.bb5
  ]

sw.bb:                                            ; preds = %for.cond
  call fastcc void @field(ptr noundef nonnull %ls, ptr noundef %v)
  br label %for.cond.backedge

sw.bb2:                                           ; preds = %for.cond
  %call = call fastcc i32 @luaK_exp2anyreg(ptr noundef %0, ptr noundef %v)
  %6 = load i32, ptr %linenumber.i20, align 4
  store i32 %6, ptr %lastline.i, align 8
  %7 = load i32, ptr %lookahead.i, align 8
  %cmp.not.i71 = icmp eq i32 %7, 287
  br i1 %cmp.not.i71, label %if.else.i74, label %if.then.i73

if.then.i73:                                      ; preds = %sw.bb2
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t.i, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i, align 8
  br label %luaX_next.exit77

if.else.i74:                                      ; preds = %sw.bb2
  %call.i76 = call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i)
  store i32 %call.i76, ptr %t.i, align 8
  br label %luaX_next.exit77

luaX_next.exit77:                                 ; preds = %if.then.i73, %if.else.i74
  %call.i67 = call fastcc i32 @subexpr(ptr noundef nonnull %ls, ptr noundef nonnull %key, i32 noundef 0), !range !93
  %8 = load ptr, ptr %fs1, align 8
  %9 = load i32, ptr %t.i62, align 8
  %10 = load i32, ptr %f.i, align 4
  %cmp.not.i63 = icmp eq i32 %9, %10
  br i1 %cmp.not.i63, label %if.else.i66, label %if.then.i64

if.then.i64:                                      ; preds = %luaX_next.exit77
  %call.i65 = call fastcc i32 @luaK_exp2anyreg(ptr noundef %8, ptr noundef nonnull %key)
  br label %luaK_exp2val.exit

if.else.i66:                                      ; preds = %luaX_next.exit77
  call fastcc void @luaK_dischargevars(ptr noundef %8, ptr noundef nonnull %key)
  br label %luaK_exp2val.exit

luaK_exp2val.exit:                                ; preds = %if.then.i64, %if.else.i66
  call fastcc void @checknext(ptr noundef nonnull %ls, i32 noundef 93)
  %call.i = call fastcc i32 @luaK_exp2RK(ptr noundef %0, ptr noundef nonnull %key)
  store i32 %call.i, ptr %aux.i80, align 4
  store i32 9, ptr %v, align 8
  br label %for.cond.backedge

sw.bb3:                                           ; preds = %for.cond
  %11 = load i32, ptr %linenumber.i20, align 4
  store i32 %11, ptr %lastline.i, align 8
  %12 = load i32, ptr %lookahead.i, align 8
  %cmp.not.i = icmp eq i32 %12, 287
  br i1 %cmp.not.i, label %if.else.i, label %if.then.i

if.then.i:                                        ; preds = %sw.bb3
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t.i, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i, align 8
  %.pr = load i32, ptr %t.i, align 8
  br label %luaX_next.exit

if.else.i:                                        ; preds = %sw.bb3
  %call.i21 = call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i)
  store i32 %call.i21, ptr %t.i, align 8
  br label %luaX_next.exit

luaX_next.exit:                                   ; preds = %if.then.i, %if.else.i
  %13 = phi i32 [ %.pr, %if.then.i ], [ %call.i21, %if.else.i ]
  %cmp.not.i.i.i = icmp eq i32 %13, 285
  br i1 %cmp.not.i.i.i, label %check.exit.i.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %luaX_next.exit
  %L.i.i.i.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 6
  %14 = load ptr, ptr %L.i.i.i.i, align 8
  %call1.i.i.i.i = call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %14, ptr noundef nonnull @.str.164, ptr noundef nonnull @.str.88)
  %15 = load i32, ptr %t.i, align 8
  call fastcc void @luaX_lexerror(ptr noundef nonnull %ls, ptr noundef %call1.i.i.i.i, i32 noundef %15)
  unreachable

check.exit.i.i:                                   ; preds = %luaX_next.exit
  %16 = load ptr, ptr %seminfo.i, align 8
  %17 = load i32, ptr %linenumber.i20, align 4
  store i32 %17, ptr %lastline.i, align 8
  %18 = load i32, ptr %lookahead.i, align 8
  %cmp.not.i3.i.i = icmp eq i32 %18, 287
  br i1 %cmp.not.i3.i.i, label %if.else.i.i.i, label %if.then.i4.i.i

if.then.i4.i.i:                                   ; preds = %check.exit.i.i
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t.i, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i, align 8
  br label %checkname.exit

if.else.i.i.i:                                    ; preds = %check.exit.i.i
  %call.i.i.i = call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i)
  store i32 %call.i.i.i, ptr %t.i, align 8
  br label %checkname.exit

checkname.exit:                                   ; preds = %if.then.i4.i.i, %if.else.i.i.i
  %ls.val.i = load ptr, ptr %fs1, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %o.i.i.i)
  store ptr %16, ptr %o.i.i.i, align 8
  store i32 4, ptr %tt.i.i.i, align 8
  %call.i.i2.i = call fastcc i32 @addk(ptr noundef %ls.val.i, ptr noundef nonnull %o.i.i.i, ptr noundef nonnull %o.i.i.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %o.i.i.i)
  store i32 -1, ptr %t.i.i3.i, align 8
  store i32 -1, ptr %f.i.i.i, align 4
  store i32 4, ptr %key4, align 8
  store i32 %call.i.i2.i, ptr %u.i.i.i, align 8
  %call.i22 = call fastcc i32 @luaK_exp2anyreg(ptr noundef %0, ptr noundef %v)
  %19 = load i32, ptr %v, align 8
  %cmp.i.i = icmp eq i32 %19, 12
  br i1 %cmp.i.i, label %if.then.i.i, label %freeexp.exit.ithread-pre-split

if.then.i.i:                                      ; preds = %checkname.exit
  %20 = load i32, ptr %u9.i.i, align 8
  %and.i.i.i = and i32 %20, 256
  %tobool.not.i.i.i = icmp eq i32 %and.i.i.i, 0
  br i1 %tobool.not.i.i.i, label %land.lhs.true.i.i.i, label %freeexp.exit.ithread-pre-split

land.lhs.true.i.i.i:                              ; preds = %if.then.i.i
  %21 = load i8, ptr %nactvar.i.i, align 2
  %conv.i.i.i = zext i8 %21 to i32
  %cmp.not.i.i.i23 = icmp slt i32 %20, %conv.i.i.i
  br i1 %cmp.not.i.i.i23, label %freeexp.exit.ithread-pre-split, label %if.then.i.i.i24

if.then.i.i.i24:                                  ; preds = %land.lhs.true.i.i.i
  %22 = load i32, ptr %freereg.i.i, align 4
  %dec.i.i.i = add nsw i32 %22, -1
  store i32 %dec.i.i.i, ptr %freereg.i.i, align 4
  br label %freeexp.exit.i

freeexp.exit.ithread-pre-split:                   ; preds = %checkname.exit, %if.then.i.i, %land.lhs.true.i.i.i
  %.pr95 = load i32, ptr %freereg.i.i, align 4
  br label %freeexp.exit.i

freeexp.exit.i:                                   ; preds = %freeexp.exit.ithread-pre-split, %if.then.i.i.i24
  %23 = phi i32 [ %.pr95, %freeexp.exit.ithread-pre-split ], [ %dec.i.i.i, %if.then.i.i.i24 ]
  %add.i.i.i = add nsw i32 %23, 2
  %24 = load ptr, ptr %0, align 8
  %maxstacksize.i.i.i = getelementptr inbounds %struct.Proto, ptr %24, i64 0, i32 22
  %25 = load i8, ptr %maxstacksize.i.i.i, align 1
  %conv.i.i14.i = zext i8 %25 to i32
  %cmp.i.i.i = icmp sgt i32 %add.i.i.i, %conv.i.i14.i
  br i1 %cmp.i.i.i, label %if.then.i.i15.i, label %luaK_reserveregs.exit.i

if.then.i.i15.i:                                  ; preds = %freeexp.exit.i
  %cmp2.i.i.i = icmp sgt i32 %23, 247
  br i1 %cmp2.i.i.i, label %if.then4.i.i.i, label %if.end.i.i.i

if.then4.i.i.i:                                   ; preds = %if.then.i.i15.i
  %26 = load ptr, ptr %ls.i37.i, align 8
  %t.i.i.i.i = getelementptr inbounds %struct.LexState, ptr %26, i64 0, i32 3
  %27 = load i32, ptr %t.i.i.i.i, align 8
  call fastcc void @luaX_lexerror(ptr noundef %26, ptr noundef nonnull @.str.150, i32 noundef %27)
  unreachable

if.end.i.i.i:                                     ; preds = %if.then.i.i15.i
  %conv5.i.i.i = trunc i32 %add.i.i.i to i8
  store i8 %conv5.i.i.i, ptr %maxstacksize.i.i.i, align 1
  %.pre.i.i = load i32, ptr %freereg.i.i, align 4
  %.pre3.i.i = add nsw i32 %.pre.i.i, 2
  br label %luaK_reserveregs.exit.i

luaK_reserveregs.exit.i:                          ; preds = %if.end.i.i.i, %freeexp.exit.i
  %add.pre-phi.i.i = phi i32 [ %add.i.i.i, %freeexp.exit.i ], [ %.pre3.i.i, %if.end.i.i.i ]
  store i32 %add.pre-phi.i.i, ptr %freereg.i.i, align 4
  %28 = load i32, ptr %u9.i.i, align 8
  %call1.i = call fastcc i32 @luaK_exp2RK(ptr noundef nonnull %0, ptr noundef nonnull %key4)
  %shl1.i.i = shl i32 %23, 6
  %shl2.i.i = shl i32 %28, 23
  %shl4.i.i = shl i32 %call1.i, 14
  %or.i.i = or i32 %shl1.i.i, %shl2.i.i
  %or3.i.i = or i32 %or.i.i, %shl4.i.i
  %or5.i.i = or disjoint i32 %or3.i.i, 11
  %29 = load ptr, ptr %ls.i37.i, align 8
  %lastline.i.i = getelementptr inbounds %struct.LexState, ptr %29, i64 0, i32 2
  %30 = load i32, ptr %lastline.i.i, align 8
  %call.i.i = call fastcc i32 @luaK_code(ptr noundef nonnull %0, i32 noundef %or5.i.i, i32 noundef %30)
  %31 = load i32, ptr %key4, align 8
  %cmp.i16.i = icmp eq i32 %31, 12
  br i1 %cmp.i16.i, label %if.then.i17.i, label %luaK_self.exit

if.then.i17.i:                                    ; preds = %luaK_reserveregs.exit.i
  %32 = load i32, ptr %u.i.i.i, align 8
  %and.i.i19.i = and i32 %32, 256
  %tobool.not.i.i20.i = icmp eq i32 %and.i.i19.i, 0
  br i1 %tobool.not.i.i20.i, label %land.lhs.true.i.i21.i, label %luaK_self.exit

land.lhs.true.i.i21.i:                            ; preds = %if.then.i17.i
  %33 = load i8, ptr %nactvar.i.i, align 2
  %conv.i.i23.i = zext i8 %33 to i32
  %cmp.not.i.i24.i = icmp slt i32 %32, %conv.i.i23.i
  br i1 %cmp.not.i.i24.i, label %luaK_self.exit, label %if.then.i.i25.i

if.then.i.i25.i:                                  ; preds = %land.lhs.true.i.i21.i
  %34 = load i32, ptr %freereg.i.i, align 4
  %dec.i.i27.i = add nsw i32 %34, -1
  store i32 %dec.i.i27.i, ptr %freereg.i.i, align 4
  br label %luaK_self.exit

luaK_self.exit:                                   ; preds = %luaK_reserveregs.exit.i, %if.then.i17.i, %land.lhs.true.i.i21.i, %if.then.i.i25.i
  store i32 %23, ptr %u9.i.i, align 8
  store i32 12, ptr %v, align 8
  call fastcc void @funcargs(ptr noundef nonnull %ls, ptr noundef nonnull %v)
  br label %for.cond.backedge

sw.bb5:                                           ; preds = %for.cond, %for.cond, %for.cond
  %35 = load i32, ptr %v, align 8
  switch i32 %35, label %freeexp.exit.i26thread-pre-split [
    i32 6, label %luaK_dischargevars.exit.thread93
    i32 7, label %sw.bb2.i
    i32 8, label %sw.bb6.i
    i32 9, label %sw.bb13.i
    i32 13, label %luaK_dischargevars.exit.thread
    i32 14, label %if.then6.i.i
    i32 12, label %if.then.i.i39
  ]

luaK_dischargevars.exit.thread93:                 ; preds = %sw.bb5
  store i32 12, ptr %v, align 8
  br label %if.then.i.i39

sw.bb2.i:                                         ; preds = %sw.bb5
  %36 = load i32, ptr %u9.i.i, align 8
  %shl2.i.i85 = shl i32 %36, 23
  %or3.i.i86 = or disjoint i32 %shl2.i.i85, 4
  %37 = load ptr, ptr %ls.i37.i, align 8
  %lastline.i.i88 = getelementptr inbounds %struct.LexState, ptr %37, i64 0, i32 2
  %38 = load i32, ptr %lastline.i.i88, align 8
  %call.i.i89 = call fastcc i32 @luaK_code(ptr noundef %0, i32 noundef %or3.i.i86, i32 noundef %38)
  store i32 %call.i.i89, ptr %u9.i.i, align 8
  br label %freeexp.exit.i26thread-pre-split.sink.split

sw.bb6.i:                                         ; preds = %sw.bb5
  %39 = load i32, ptr %u9.i.i, align 8
  %shl2.i20.i = shl i32 %39, 14
  %or3.i21.i = or disjoint i32 %shl2.i20.i, 5
  %40 = load ptr, ptr %ls.i37.i, align 8
  %lastline.i23.i = getelementptr inbounds %struct.LexState, ptr %40, i64 0, i32 2
  %41 = load i32, ptr %lastline.i23.i, align 8
  %call.i24.i = call fastcc i32 @luaK_code(ptr noundef %0, i32 noundef %or3.i21.i, i32 noundef %41)
  store i32 %call.i24.i, ptr %u9.i.i, align 8
  br label %freeexp.exit.i26thread-pre-split.sink.split

sw.bb13.i:                                        ; preds = %sw.bb5
  %42 = load i32, ptr %aux.i80, align 4
  %and.i.i = and i32 %42, 256
  %tobool.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i.i, label %land.lhs.true.i.i, label %freereg.exit.i

land.lhs.true.i.i:                                ; preds = %sw.bb13.i
  %43 = load i8, ptr %nactvar.i.i, align 2
  %conv.i.i = zext i8 %43 to i32
  %cmp.not.i.i = icmp slt i32 %42, %conv.i.i
  br i1 %cmp.not.i.i, label %freereg.exit.i, label %if.then.i.i83

if.then.i.i83:                                    ; preds = %land.lhs.true.i.i
  %44 = load i32, ptr %freereg.i.i, align 4
  %dec.i.i = add nsw i32 %44, -1
  store i32 %dec.i.i, ptr %freereg.i.i, align 4
  br label %freereg.exit.i

freereg.exit.i:                                   ; preds = %if.then.i.i83, %land.lhs.true.i.i, %sw.bb13.i
  %45 = load i32, ptr %u9.i.i, align 8
  %and.i25.i = and i32 %45, 256
  %tobool.not.i26.i = icmp eq i32 %and.i25.i, 0
  br i1 %tobool.not.i26.i, label %land.lhs.true.i27.i, label %freereg.exit34.i

land.lhs.true.i27.i:                              ; preds = %freereg.exit.i
  %46 = load i8, ptr %nactvar.i.i, align 2
  %conv.i29.i = zext i8 %46 to i32
  %cmp.not.i30.i = icmp slt i32 %45, %conv.i29.i
  br i1 %cmp.not.i30.i, label %freereg.exit34.i, label %if.then.i31.i

if.then.i31.i:                                    ; preds = %land.lhs.true.i27.i
  %47 = load i32, ptr %freereg.i.i, align 4
  %dec.i33.i = add nsw i32 %47, -1
  store i32 %dec.i33.i, ptr %freereg.i.i, align 4
  %.pre.i = load i32, ptr %u9.i.i, align 8
  br label %freereg.exit34.i

freereg.exit34.i:                                 ; preds = %if.then.i31.i, %land.lhs.true.i27.i, %freereg.exit.i
  %48 = phi i32 [ %45, %freereg.exit.i ], [ %45, %land.lhs.true.i27.i ], [ %.pre.i, %if.then.i31.i ]
  %49 = load i32, ptr %aux.i80, align 4
  %shl2.i35.i = shl i32 %48, 23
  %shl4.i.i81 = shl i32 %49, 14
  %or3.i36.i = or i32 %shl2.i35.i, %shl4.i.i81
  %or5.i.i82 = or disjoint i32 %or3.i36.i, 6
  %50 = load ptr, ptr %ls.i37.i, align 8
  %lastline.i38.i = getelementptr inbounds %struct.LexState, ptr %50, i64 0, i32 2
  %51 = load i32, ptr %lastline.i38.i, align 8
  %call.i39.i = call fastcc i32 @luaK_code(ptr noundef %0, i32 noundef %or5.i.i82, i32 noundef %51)
  store i32 %call.i39.i, ptr %u9.i.i, align 8
  br label %freeexp.exit.i26thread-pre-split.sink.split

luaK_dischargevars.exit.thread:                   ; preds = %sw.bb5
  store i32 12, ptr %v, align 8
  %52 = load ptr, ptr %0, align 8
  %code.i.i = getelementptr inbounds %struct.Proto, ptr %52, i64 0, i32 4
  %53 = load ptr, ptr %code.i.i, align 8
  %54 = load i32, ptr %u9.i.i, align 8
  %idxprom.i.i = sext i32 %54 to i64
  %arrayidx.i.i = getelementptr inbounds i32, ptr %53, i64 %idxprom.i.i
  %55 = load i32, ptr %arrayidx.i.i, align 4
  %shr.i.i = lshr i32 %55, 6
  %and.i41.i = and i32 %shr.i.i, 255
  store i32 %and.i41.i, ptr %u9.i.i, align 8
  br label %if.then.i.i39

if.then6.i.i:                                     ; preds = %sw.bb5
  %56 = load ptr, ptr %0, align 8
  %code8.i.i = getelementptr inbounds %struct.Proto, ptr %56, i64 0, i32 4
  %57 = load ptr, ptr %code8.i.i, align 8
  %58 = load i32, ptr %u9.i.i, align 8
  %idxprom11.i.i = sext i32 %58 to i64
  %arrayidx12.i.i = getelementptr inbounds i32, ptr %57, i64 %idxprom11.i.i
  %59 = load i32, ptr %arrayidx12.i.i, align 4
  %and13.i.i = and i32 %59, 8388607
  %or.i.i78 = or disjoint i32 %and13.i.i, 16777216
  store i32 %or.i.i78, ptr %arrayidx12.i.i, align 4
  br label %freeexp.exit.i26thread-pre-split.sink.split

if.then.i.i39:                                    ; preds = %sw.bb5, %luaK_dischargevars.exit.thread, %luaK_dischargevars.exit.thread93
  %60 = load i32, ptr %u9.i.i, align 8
  %and.i.i.i41 = and i32 %60, 256
  %tobool.not.i.i.i42 = icmp eq i32 %and.i.i.i41, 0
  br i1 %tobool.not.i.i.i42, label %land.lhs.true.i.i.i43, label %freeexp.exit.i26thread-pre-split

land.lhs.true.i.i.i43:                            ; preds = %if.then.i.i39
  %61 = load i8, ptr %nactvar.i.i, align 2
  %conv.i.i.i45 = zext i8 %61 to i32
  %cmp.not.i.i.i46 = icmp slt i32 %60, %conv.i.i.i45
  br i1 %cmp.not.i.i.i46, label %freeexp.exit.i26thread-pre-split, label %if.then.i.i.i47

if.then.i.i.i47:                                  ; preds = %land.lhs.true.i.i.i43
  %62 = load i32, ptr %freereg.i.i, align 4
  %dec.i.i.i49 = add nsw i32 %62, -1
  store i32 %dec.i.i.i49, ptr %freereg.i.i, align 4
  br label %freeexp.exit.i26

freeexp.exit.i26thread-pre-split.sink.split:      ; preds = %if.then6.i.i, %freereg.exit34.i, %sw.bb6.i, %sw.bb2.i
  store i32 11, ptr %v, align 8
  br label %freeexp.exit.i26thread-pre-split

freeexp.exit.i26thread-pre-split:                 ; preds = %freeexp.exit.i26thread-pre-split.sink.split, %sw.bb5, %if.then.i.i39, %land.lhs.true.i.i.i43
  %.pr97 = load i32, ptr %freereg.i.i, align 4
  br label %freeexp.exit.i26

freeexp.exit.i26:                                 ; preds = %freeexp.exit.i26thread-pre-split, %if.then.i.i.i47
  %63 = phi i32 [ %.pr97, %freeexp.exit.i26thread-pre-split ], [ %dec.i.i.i49, %if.then.i.i.i47 ]
  %add.i.i.i27 = add nsw i32 %63, 1
  %64 = load ptr, ptr %0, align 8
  %maxstacksize.i.i.i28 = getelementptr inbounds %struct.Proto, ptr %64, i64 0, i32 22
  %65 = load i8, ptr %maxstacksize.i.i.i28, align 1
  %conv.i.i8.i = zext i8 %65 to i32
  %cmp.i.i.not.i = icmp slt i32 %63, %conv.i.i8.i
  br i1 %cmp.i.i.not.i, label %luaK_exp2nextreg.exit, label %if.then.i.i9.i

if.then.i.i9.i:                                   ; preds = %freeexp.exit.i26
  %cmp2.i.i.i29 = icmp sgt i32 %63, 248
  br i1 %cmp2.i.i.i29, label %if.then4.i.i.i36, label %if.end.i.i.i30

if.then4.i.i.i36:                                 ; preds = %if.then.i.i9.i
  %66 = load ptr, ptr %ls.i37.i, align 8
  %t.i.i.i.i38 = getelementptr inbounds %struct.LexState, ptr %66, i64 0, i32 3
  %67 = load i32, ptr %t.i.i.i.i38, align 8
  call fastcc void @luaX_lexerror(ptr noundef %66, ptr noundef nonnull @.str.150, i32 noundef %67)
  unreachable

if.end.i.i.i30:                                   ; preds = %if.then.i.i9.i
  %conv5.i.i.i31 = trunc i32 %add.i.i.i27 to i8
  store i8 %conv5.i.i.i31, ptr %maxstacksize.i.i.i28, align 1
  %.pre.i.i32 = load i32, ptr %freereg.i.i, align 4
  %.pre3.i.i33 = add nsw i32 %.pre.i.i32, 1
  br label %luaK_exp2nextreg.exit

luaK_exp2nextreg.exit:                            ; preds = %freeexp.exit.i26, %if.end.i.i.i30
  %add.pre-phi.i.i35 = phi i32 [ %add.i.i.i27, %freeexp.exit.i26 ], [ %.pre3.i.i33, %if.end.i.i.i30 ]
  store i32 %add.pre-phi.i.i35, ptr %freereg.i.i, align 4
  %sub.i = add nsw i32 %add.pre-phi.i.i35, -1
  call fastcc void @exp2reg(ptr noundef nonnull %0, ptr noundef nonnull %v, i32 noundef %sub.i)
  call fastcc void @funcargs(ptr noundef nonnull %ls, ptr noundef nonnull %v)
  br label %for.cond.backedge

for.cond.backedge:                                ; preds = %luaK_exp2nextreg.exit, %luaK_self.exit, %luaK_exp2val.exit, %sw.bb
  br label %for.cond

sw.default:                                       ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @recfield(ptr noundef %ls, ptr nocapture noundef %cc) unnamed_addr #0 {
entry:
  %o.i.i.i = alloca %struct.lua_TValue, align 8
  %key = alloca %struct.expdesc, align 8
  %val = alloca %struct.expdesc, align 8
  %fs1 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 5
  %0 = load ptr, ptr %fs1, align 8
  %freereg = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 9
  %1 = load i32, ptr %freereg, align 4
  %t = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 3
  %2 = load i32, ptr %t, align 8
  %cmp = icmp eq i32 %2, 285
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %nh = getelementptr inbounds %struct.ConsControl, ptr %cc, i64 0, i32 2
  %3 = load i32, ptr %nh, align 8
  %cmp3 = icmp sgt i32 %3, 2147483645
  br i1 %cmp3, label %if.then4, label %check.exit.i.i

if.then4:                                         ; preds = %if.then
  %4 = load ptr, ptr %0, align 8
  %linedefined.i = getelementptr inbounds %struct.Proto, ptr %4, i64 0, i32 16
  %5 = load i32, ptr %linedefined.i, align 8
  %cmp.i = icmp eq i32 %5, 0
  %L.i = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 4
  %6 = load ptr, ptr %L.i, align 8
  br i1 %cmp.i, label %cond.true.i, label %cond.false.i

cond.true.i:                                      ; preds = %if.then4
  %call.i = tail call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %6, ptr noundef nonnull @.str.153, i32 noundef 2147483645, ptr noundef nonnull @.str.152)
  br label %cond.end.i

cond.false.i:                                     ; preds = %if.then4
  %call4.i = tail call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %6, ptr noundef nonnull @.str.154, i32 noundef %5, i32 noundef 2147483645, ptr noundef nonnull @.str.152)
  br label %cond.end.i

cond.end.i:                                       ; preds = %cond.false.i, %cond.true.i
  %cond.i = phi ptr [ %call.i, %cond.true.i ], [ %call4.i, %cond.false.i ]
  %ls.i = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  %7 = load ptr, ptr %ls.i, align 8
  tail call fastcc void @luaX_lexerror(ptr noundef %7, ptr noundef %cond.i, i32 noundef 0)
  unreachable

check.exit.i.i:                                   ; preds = %if.then
  %seminfo.i.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 3, i32 1
  %8 = load ptr, ptr %seminfo.i.i, align 8
  %linenumber.i.i.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 1
  %9 = load i32, ptr %linenumber.i.i.i, align 4
  %lastline.i.i.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 2
  store i32 %9, ptr %lastline.i.i.i, align 8
  %lookahead.i.i.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 4
  %10 = load i32, ptr %lookahead.i.i.i, align 8
  %cmp.not.i3.i.i = icmp eq i32 %10, 287
  br i1 %cmp.not.i3.i.i, label %if.else.i.i.i, label %if.then.i4.i.i

if.then.i4.i.i:                                   ; preds = %check.exit.i.i
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i.i.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i.i.i, align 8
  br label %checkname.exit

if.else.i.i.i:                                    ; preds = %check.exit.i.i
  %call.i.i.i = tail call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i.i)
  store i32 %call.i.i.i, ptr %t, align 8
  %ls.val.i.pre = load ptr, ptr %fs1, align 8
  br label %checkname.exit

checkname.exit:                                   ; preds = %if.then.i4.i.i, %if.else.i.i.i
  %ls.val.i = phi ptr [ %0, %if.then.i4.i.i ], [ %ls.val.i.pre, %if.else.i.i.i ]
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %o.i.i.i)
  store ptr %8, ptr %o.i.i.i, align 8
  %tt.i.i.i = getelementptr inbounds %struct.lua_TValue, ptr %o.i.i.i, i64 0, i32 1
  store i32 4, ptr %tt.i.i.i, align 8
  %call.i.i2.i = call fastcc i32 @addk(ptr noundef %ls.val.i, ptr noundef nonnull %o.i.i.i, ptr noundef nonnull %o.i.i.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %o.i.i.i)
  %t.i.i3.i = getelementptr inbounds %struct.expdesc, ptr %key, i64 0, i32 2
  store i32 -1, ptr %t.i.i3.i, align 8
  %f.i.i.i = getelementptr inbounds %struct.expdesc, ptr %key, i64 0, i32 3
  store i32 -1, ptr %f.i.i.i, align 4
  store i32 4, ptr %key, align 8
  %u.i.i.i = getelementptr inbounds %struct.expdesc, ptr %key, i64 0, i32 1
  store i32 %call.i.i2.i, ptr %u.i.i.i, align 8
  br label %if.end5

if.else:                                          ; preds = %entry
  %linenumber.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 1
  %11 = load i32, ptr %linenumber.i, align 4
  %lastline.i18 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 2
  store i32 %11, ptr %lastline.i18, align 8
  %lookahead.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 4
  %12 = load i32, ptr %lookahead.i, align 8
  %cmp.not.i19 = icmp eq i32 %12, 287
  br i1 %cmp.not.i19, label %if.else.i21, label %if.then.i20

if.then.i20:                                      ; preds = %if.else
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i, align 8
  br label %luaX_next.exit

if.else.i21:                                      ; preds = %if.else
  %seminfo.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 3, i32 1
  %call.i22 = tail call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i)
  store i32 %call.i22, ptr %t, align 8
  br label %luaX_next.exit

luaX_next.exit:                                   ; preds = %if.then.i20, %if.else.i21
  %call.i17 = call fastcc i32 @subexpr(ptr noundef nonnull %ls, ptr noundef nonnull %key, i32 noundef 0), !range !93
  %13 = load ptr, ptr %fs1, align 8
  %t.i = getelementptr inbounds %struct.expdesc, ptr %key, i64 0, i32 2
  %14 = load i32, ptr %t.i, align 8
  %f.i = getelementptr inbounds %struct.expdesc, ptr %key, i64 0, i32 3
  %15 = load i32, ptr %f.i, align 4
  %cmp.not.i = icmp eq i32 %14, %15
  br i1 %cmp.not.i, label %if.else.i, label %if.then.i

if.then.i:                                        ; preds = %luaX_next.exit
  %call.i16 = call fastcc i32 @luaK_exp2anyreg(ptr noundef %13, ptr noundef nonnull %key)
  br label %luaK_exp2val.exit

if.else.i:                                        ; preds = %luaX_next.exit
  call fastcc void @luaK_dischargevars(ptr noundef %13, ptr noundef nonnull %key)
  br label %luaK_exp2val.exit

luaK_exp2val.exit:                                ; preds = %if.then.i, %if.else.i
  call fastcc void @checknext(ptr noundef nonnull %ls, i32 noundef 93)
  br label %if.end5

if.end5:                                          ; preds = %luaK_exp2val.exit, %checkname.exit
  %nh6 = getelementptr inbounds %struct.ConsControl, ptr %cc, i64 0, i32 2
  %16 = load i32, ptr %nh6, align 8
  %inc = add nsw i32 %16, 1
  store i32 %inc, ptr %nh6, align 8
  call fastcc void @checknext(ptr noundef nonnull %ls, i32 noundef 61)
  %call = call fastcc i32 @luaK_exp2RK(ptr noundef nonnull %0, ptr noundef nonnull %key)
  %call.i13 = call fastcc i32 @subexpr(ptr noundef nonnull %ls, ptr noundef nonnull %val, i32 noundef 0), !range !93
  %t7 = getelementptr inbounds %struct.ConsControl, ptr %cc, i64 0, i32 1
  %17 = load ptr, ptr %t7, align 8
  %u = getelementptr inbounds %struct.expdesc, ptr %17, i64 0, i32 1
  %18 = load i32, ptr %u, align 8
  %call8 = call fastcc i32 @luaK_exp2RK(ptr noundef nonnull %0, ptr noundef nonnull %val)
  %shl1.i = shl i32 %18, 6
  %shl2.i = shl i32 %call, 23
  %shl4.i = shl i32 %call8, 14
  %or.i = or i32 %shl2.i, %shl1.i
  %or3.i = or i32 %or.i, %shl4.i
  %or5.i = or disjoint i32 %or3.i, 9
  %ls.i14 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  %19 = load ptr, ptr %ls.i14, align 8
  %lastline.i = getelementptr inbounds %struct.LexState, ptr %19, i64 0, i32 2
  %20 = load i32, ptr %lastline.i, align 8
  %call.i15 = call fastcc i32 @luaK_code(ptr noundef nonnull %0, i32 noundef %or5.i, i32 noundef %20)
  store i32 %1, ptr %freereg, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @new_localvar(ptr nocapture noundef readonly %ls, ptr noundef %name, i32 noundef %n) unnamed_addr #0 {
entry:
  %fs1 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 5
  %0 = load ptr, ptr %fs1, align 8
  %nactvar = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 13
  %1 = load i8, ptr %nactvar, align 2
  %conv = zext i8 %1 to i32
  %add = add nsw i32 %conv, %n
  %cmp = icmp sgt i32 %add, 199
  %2 = load ptr, ptr %0, align 8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %linedefined.i = getelementptr inbounds %struct.Proto, ptr %2, i64 0, i32 16
  %3 = load i32, ptr %linedefined.i, align 8
  %cmp.i = icmp eq i32 %3, 0
  %L.i = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 4
  %4 = load ptr, ptr %L.i, align 8
  br i1 %cmp.i, label %cond.true.i, label %cond.false.i

cond.true.i:                                      ; preds = %if.then
  %call.i = tail call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %4, ptr noundef nonnull @.str.153, i32 noundef 200, ptr noundef nonnull @.str.156)
  br label %cond.end.i

cond.false.i:                                     ; preds = %if.then
  %call4.i = tail call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %4, ptr noundef nonnull @.str.154, i32 noundef %3, i32 noundef 200, ptr noundef nonnull @.str.156)
  br label %cond.end.i

cond.end.i:                                       ; preds = %cond.false.i, %cond.true.i
  %cond.i = phi ptr [ %call.i, %cond.true.i ], [ %call4.i, %cond.false.i ]
  %ls.i = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  %5 = load ptr, ptr %ls.i, align 8
  tail call fastcc void @luaX_lexerror(ptr noundef %5, ptr noundef %cond.i, i32 noundef 0)
  unreachable

if.end:                                           ; preds = %entry
  %sizelocvars.i = getelementptr inbounds %struct.Proto, ptr %2, i64 0, i32 15
  %6 = load i32, ptr %sizelocvars.i, align 4
  %nlocvars.i = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 12
  %7 = load i16, ptr %nlocvars.i, align 8
  %conv.i = sext i16 %7 to i32
  %cmp.not.i = icmp sgt i32 %6, %conv.i
  br i1 %cmp.not.i, label %while.end.i, label %if.end.i

if.end.i:                                         ; preds = %if.end
  %L.i6 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 6
  %8 = load ptr, ptr %L.i6, align 8
  %locvars.i = getelementptr inbounds %struct.Proto, ptr %2, i64 0, i32 7
  %9 = load ptr, ptr %locvars.i, align 8
  %call.i7 = tail call fastcc ptr @luaM_growaux_(ptr noundef %8, ptr noundef %9, ptr noundef nonnull %sizelocvars.i, i64 noundef 16, i32 noundef 32767, ptr noundef nonnull @.str.157)
  store ptr %call.i7, ptr %locvars.i, align 8
  %.pre.i = load i32, ptr %sizelocvars.i, align 4
  %cmp818.i = icmp slt i32 %6, %.pre.i
  br i1 %cmp818.i, label %while.body.lr.ph.i, label %while.end.i

while.body.lr.ph.i:                               ; preds = %if.end.i
  %10 = sext i32 %6 to i64
  br label %while.body.i

while.body.i:                                     ; preds = %while.body.i, %while.body.lr.ph.i
  %indvars.iv.i = phi i64 [ %10, %while.body.lr.ph.i ], [ %indvars.iv.next.i, %while.body.i ]
  %11 = load ptr, ptr %locvars.i, align 8
  %indvars.iv.next.i = add nsw i64 %indvars.iv.i, 1
  %arrayidx.i = getelementptr inbounds %struct.LocVar, ptr %11, i64 %indvars.iv.i
  store ptr null, ptr %arrayidx.i, align 8
  %12 = load i32, ptr %sizelocvars.i, align 4
  %13 = sext i32 %12 to i64
  %cmp8.i = icmp slt i64 %indvars.iv.next.i, %13
  br i1 %cmp8.i, label %while.body.i, label %while.end.i, !llvm.loop !118

while.end.i:                                      ; preds = %while.body.i, %if.end.i, %if.end
  %locvars12.i = getelementptr inbounds %struct.Proto, ptr %2, i64 0, i32 7
  %14 = load ptr, ptr %locvars12.i, align 8
  %15 = load i16, ptr %nlocvars.i, align 8
  %idxprom14.i = sext i16 %15 to i64
  %arrayidx15.i = getelementptr inbounds %struct.LocVar, ptr %14, i64 %idxprom14.i
  store ptr %name, ptr %arrayidx15.i, align 8
  %marked.i = getelementptr inbounds %struct.GCheader, ptr %name, i64 0, i32 2
  %16 = load i8, ptr %marked.i, align 1
  %17 = and i8 %16, 3
  %tobool.not.i = icmp eq i8 %17, 0
  br i1 %tobool.not.i, label %registerlocalvar.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %while.end.i
  %marked18.i = getelementptr inbounds %struct.GCheader, ptr %2, i64 0, i32 2
  %18 = load i8, ptr %marked18.i, align 1
  %19 = and i8 %18, 4
  %tobool21.not.i = icmp eq i8 %19, 0
  br i1 %tobool21.not.i, label %registerlocalvar.exit, label %if.then22.i

if.then22.i:                                      ; preds = %land.lhs.true.i
  %L23.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 6
  %20 = load ptr, ptr %L23.i, align 8
  %21 = getelementptr i8, ptr %20, i64 32
  %.val.i = load ptr, ptr %21, align 8
  %gcstate.i.i = getelementptr inbounds %struct.global_State, ptr %.val.i, i64 0, i32 4
  %22 = load i8, ptr %gcstate.i.i, align 1
  %cmp.i.i = icmp eq i8 %22, 1
  br i1 %cmp.i.i, label %if.then.i.i, label %if.else.i.i

if.then.i.i:                                      ; preds = %if.then22.i
  tail call fastcc void @reallymarkobject(ptr noundef nonnull %.val.i, ptr noundef nonnull %name)
  br label %registerlocalvar.exit

if.else.i.i:                                      ; preds = %if.then22.i
  %23 = and i8 %18, -8
  %currentwhite.i.i = getelementptr inbounds %struct.global_State, ptr %.val.i, i64 0, i32 3
  %24 = load i8, ptr %currentwhite.i.i, align 8
  %25 = and i8 %24, 3
  %or4.i.i = or disjoint i8 %25, %23
  store i8 %or4.i.i, ptr %marked18.i, align 1
  br label %registerlocalvar.exit

registerlocalvar.exit:                            ; preds = %while.end.i, %land.lhs.true.i, %if.then.i.i, %if.else.i.i
  %26 = load i16, ptr %nlocvars.i, align 8
  %inc26.i = add i16 %26, 1
  store i16 %inc26.i, ptr %nlocvars.i, align 8
  %27 = load i8, ptr %nactvar, align 2
  %conv6 = zext i8 %27 to i32
  %add7 = add nsw i32 %conv6, %n
  %idxprom = sext i32 %add7 to i64
  %arrayidx = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 15, i64 %idxprom
  store i16 %26, ptr %arrayidx, align 2
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @parlist(ptr noundef %ls) unnamed_addr #0 {
entry:
  %fs1 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 5
  %0 = load ptr, ptr %fs1, align 8
  %1 = load ptr, ptr %0, align 8
  %is_vararg = getelementptr inbounds %struct.Proto, ptr %1, i64 0, i32 21
  store i8 0, ptr %is_vararg, align 2
  %t = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 3
  %2 = load i32, ptr %t, align 8
  %cmp.not = icmp eq i32 %2, 41
  br i1 %cmp.not, label %adjustlocalvars.exit, label %do.body.preheader

do.body.preheader:                                ; preds = %entry
  %seminfo.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 3, i32 1
  %linenumber.i.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 1
  %lastline.i.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 2
  %lookahead.i.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 4
  br label %do.body

do.body:                                          ; preds = %do.body.backedge, %do.body.preheader
  %3 = phi i32 [ %2, %do.body.preheader ], [ %.be, %do.body.backedge ]
  %nparams.0 = phi i32 [ 0, %do.body.preheader ], [ %inc, %do.body.backedge ]
  switch i32 %3, label %sw.default [
    i32 285, label %check.exit.i
    i32 279, label %sw.bb5
  ]

check.exit.i:                                     ; preds = %do.body
  %4 = load ptr, ptr %seminfo.i, align 8
  %5 = load i32, ptr %linenumber.i.i, align 4
  store i32 %5, ptr %lastline.i.i, align 8
  %6 = load i32, ptr %lookahead.i.i, align 8
  %cmp.not.i3.i = icmp eq i32 %6, 287
  br i1 %cmp.not.i3.i, label %if.else.i.i, label %if.then.i4.i

if.then.i4.i:                                     ; preds = %check.exit.i
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i.i, align 8
  br label %str_checkname.exit

if.else.i.i:                                      ; preds = %check.exit.i
  %call.i.i = tail call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i)
  store i32 %call.i.i, ptr %t, align 8
  br label %str_checkname.exit

str_checkname.exit:                               ; preds = %if.then.i4.i, %if.else.i.i
  %inc = add nuw nsw i32 %nparams.0, 1
  tail call fastcc void @new_localvar(ptr noundef nonnull %ls, ptr noundef %4, i32 noundef %nparams.0)
  %.pr29 = load i8, ptr %is_vararg, align 2
  %tobool.not = icmp eq i8 %.pr29, 0
  br i1 %tobool.not, label %land.rhs, label %if.end.thread

sw.bb5:                                           ; preds = %do.body
  %7 = load i32, ptr %linenumber.i.i, align 4
  store i32 %7, ptr %lastline.i.i, align 8
  %8 = load i32, ptr %lookahead.i.i, align 8
  %cmp.not.i = icmp eq i32 %8, 287
  br i1 %cmp.not.i, label %if.else.i, label %if.then.i

if.then.i:                                        ; preds = %sw.bb5
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i.i, align 8
  br label %if.end

if.else.i:                                        ; preds = %sw.bb5
  %call.i = tail call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i)
  store i32 %call.i, ptr %t, align 8
  br label %if.end

sw.default:                                       ; preds = %do.body
  tail call fastcc void @luaX_lexerror(ptr noundef nonnull %ls, ptr noundef nonnull @.str.158, i32 noundef %3)
  unreachable

land.rhs:                                         ; preds = %str_checkname.exit
  %9 = load i32, ptr %t, align 8
  %cmp.i = icmp eq i32 %9, 44
  br i1 %cmp.i, label %if.then.i19, label %if.end.thread, !llvm.loop !119

if.then.i19:                                      ; preds = %land.rhs
  %10 = load i32, ptr %linenumber.i.i, align 4
  store i32 %10, ptr %lastline.i.i, align 8
  %11 = load i32, ptr %lookahead.i.i, align 8
  %cmp.not.i.i23 = icmp eq i32 %11, 287
  br i1 %cmp.not.i.i23, label %if.else.i.i25, label %if.then.i.i24

if.then.i.i24:                                    ; preds = %if.then.i19
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i.i, align 8
  %.pr.pre = load i32, ptr %t, align 8
  br label %do.body.backedge

do.body.backedge:                                 ; preds = %if.then.i.i24, %if.else.i.i25
  %.be = phi i32 [ %.pr.pre, %if.then.i.i24 ], [ %call.i.i26, %if.else.i.i25 ]
  br label %do.body

if.else.i.i25:                                    ; preds = %if.then.i19
  %call.i.i26 = tail call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i)
  store i32 %call.i.i26, ptr %t, align 8
  br label %do.body.backedge

if.end.thread:                                    ; preds = %str_checkname.exit, %land.rhs
  %ls.val49 = load ptr, ptr %fs1, align 8
  %nactvar.i50 = getelementptr inbounds %struct.FuncState, ptr %ls.val49, i64 0, i32 13
  %12 = load i8, ptr %nactvar.i50, align 2
  %13 = trunc i32 %inc to i8
  %conv2.i51 = add i8 %12, %13
  store i8 %conv2.i51, ptr %nactvar.i50, align 2
  br label %for.body.lr.ph.i

if.end:                                           ; preds = %if.then.i, %if.else.i
  %14 = load i8, ptr %is_vararg, align 2
  %15 = or i8 %14, 2
  store i8 %15, ptr %is_vararg, align 2
  %ls.val = load ptr, ptr %fs1, align 8
  %nactvar.i = getelementptr inbounds %struct.FuncState, ptr %ls.val, i64 0, i32 13
  %16 = load i8, ptr %nactvar.i, align 2
  %17 = trunc i32 %nparams.0 to i8
  %conv2.i = add i8 %16, %17
  store i8 %conv2.i, ptr %nactvar.i, align 2
  %tobool.not1.i = icmp eq i32 %nparams.0, 0
  br i1 %tobool.not1.i, label %adjustlocalvars.exit, label %for.body.lr.ph.i

for.body.lr.ph.i:                                 ; preds = %if.end.thread, %if.end
  %nactvar.i55 = phi ptr [ %nactvar.i50, %if.end.thread ], [ %nactvar.i, %if.end ]
  %ls.val54 = phi ptr [ %ls.val49, %if.end.thread ], [ %ls.val, %if.end ]
  %nparams.253 = phi i32 [ %inc, %if.end.thread ], [ %nparams.0, %if.end ]
  %pc.i = getelementptr inbounds %struct.FuncState, ptr %ls.val54, i64 0, i32 6
  %.pre.i = load i32, ptr %pc.i, align 8
  br label %for.body.i

for.body.i:                                       ; preds = %for.body.i, %for.body.lr.ph.i
  %nvars.addr.02.i = phi i32 [ %nparams.253, %for.body.lr.ph.i ], [ %dec.i, %for.body.i ]
  %18 = load ptr, ptr %ls.val54, align 8
  %locvars.i = getelementptr inbounds %struct.Proto, ptr %18, i64 0, i32 7
  %19 = load ptr, ptr %locvars.i, align 8
  %20 = load i8, ptr %nactvar.i55, align 2
  %conv5.i = zext i8 %20 to i32
  %sub.i = sub nsw i32 %conv5.i, %nvars.addr.02.i
  %idxprom.i = sext i32 %sub.i to i64
  %arrayidx.i = getelementptr inbounds %struct.FuncState, ptr %ls.val54, i64 0, i32 15, i64 %idxprom.i
  %21 = load i16, ptr %arrayidx.i, align 2
  %idxprom6.i = zext i16 %21 to i64
  %startpc.i = getelementptr inbounds %struct.LocVar, ptr %19, i64 %idxprom6.i, i32 1
  store i32 %.pre.i, ptr %startpc.i, align 8
  %dec.i = add nsw i32 %nvars.addr.02.i, -1
  %tobool.not.i = icmp eq i32 %dec.i, 0
  br i1 %tobool.not.i, label %adjustlocalvars.exit, label %for.body.i, !llvm.loop !100

adjustlocalvars.exit:                             ; preds = %for.body.i, %entry, %if.end
  %nactvar = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 13
  %22 = load i8, ptr %nactvar, align 2
  %23 = load i8, ptr %is_vararg, align 2
  %24 = and i8 %23, 1
  %sub = sub i8 %22, %24
  %numparams = getelementptr inbounds %struct.Proto, ptr %1, i64 0, i32 20
  store i8 %sub, ptr %numparams, align 1
  %25 = load i8, ptr %nactvar, align 2
  %conv16 = zext i8 %25 to i32
  %freereg.i.i = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 9
  %26 = load i32, ptr %freereg.i.i, align 4
  %add.i.i = add nsw i32 %26, %conv16
  %27 = load ptr, ptr %0, align 8
  %maxstacksize.i.i = getelementptr inbounds %struct.Proto, ptr %27, i64 0, i32 22
  %28 = load i8, ptr %maxstacksize.i.i, align 1
  %conv.i.i = zext i8 %28 to i32
  %cmp.i.i = icmp sgt i32 %add.i.i, %conv.i.i
  br i1 %cmp.i.i, label %if.then.i.i27, label %luaK_reserveregs.exit

if.then.i.i27:                                    ; preds = %adjustlocalvars.exit
  %cmp2.i.i = icmp sgt i32 %add.i.i, 249
  br i1 %cmp2.i.i, label %if.then4.i.i, label %if.end.i.i

if.then4.i.i:                                     ; preds = %if.then.i.i27
  %ls.i.i = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  %29 = load ptr, ptr %ls.i.i, align 8
  %t.i.i.i = getelementptr inbounds %struct.LexState, ptr %29, i64 0, i32 3
  %30 = load i32, ptr %t.i.i.i, align 8
  tail call fastcc void @luaX_lexerror(ptr noundef %29, ptr noundef nonnull @.str.150, i32 noundef %30)
  unreachable

if.end.i.i:                                       ; preds = %if.then.i.i27
  %conv5.i.i = trunc i32 %add.i.i to i8
  store i8 %conv5.i.i, ptr %maxstacksize.i.i, align 1
  %.pre.i28 = load i32, ptr %freereg.i.i, align 4
  %.pre3.i = add nsw i32 %.pre.i28, %conv16
  br label %luaK_reserveregs.exit

luaK_reserveregs.exit:                            ; preds = %adjustlocalvars.exit, %if.end.i.i
  %add.pre-phi.i = phi i32 [ %add.i.i, %adjustlocalvars.exit ], [ %.pre3.i, %if.end.i.i ]
  store i32 %add.pre-phi.i, ptr %freereg.i.i, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @pushclosure(ptr nocapture noundef readonly %ls, ptr nocapture noundef readonly %func, ptr nocapture noundef writeonly %v) unnamed_addr #0 {
entry:
  %fs1 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 5
  %0 = load ptr, ptr %fs1, align 8
  %1 = load ptr, ptr %0, align 8
  %sizep = getelementptr inbounds %struct.Proto, ptr %1, i64 0, i32 14
  %2 = load i32, ptr %sizep, align 8
  %np = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 11
  %3 = load i32, ptr %np, align 4
  %cmp.not = icmp slt i32 %3, %2
  br i1 %cmp.not, label %while.end, label %if.end

if.end:                                           ; preds = %entry
  %L = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 6
  %4 = load ptr, ptr %L, align 8
  %p = getelementptr inbounds %struct.Proto, ptr %1, i64 0, i32 5
  %5 = load ptr, ptr %p, align 8
  %call = tail call fastcc ptr @luaM_growaux_(ptr noundef %4, ptr noundef %5, ptr noundef nonnull %sizep, i64 noundef 8, i32 noundef 262143, ptr noundef nonnull @.str.149)
  store ptr %call, ptr %p, align 8
  %.pre = load i32, ptr %sizep, align 8
  %cmp731 = icmp slt i32 %2, %.pre
  br i1 %cmp731, label %while.body.lr.ph, label %while.end

while.body.lr.ph:                                 ; preds = %if.end
  %p8 = getelementptr inbounds %struct.Proto, ptr %1, i64 0, i32 5
  %6 = sext i32 %2 to i64
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %while.body
  %indvars.iv = phi i64 [ %6, %while.body.lr.ph ], [ %indvars.iv.next, %while.body ]
  %7 = load ptr, ptr %p8, align 8
  %indvars.iv.next = add nsw i64 %indvars.iv, 1
  %arrayidx = getelementptr inbounds ptr, ptr %7, i64 %indvars.iv
  store ptr null, ptr %arrayidx, align 8
  %8 = load i32, ptr %sizep, align 8
  %9 = sext i32 %8 to i64
  %cmp7 = icmp slt i64 %indvars.iv.next, %9
  br i1 %cmp7, label %while.body, label %while.end, !llvm.loop !120

while.end:                                        ; preds = %while.body, %entry, %if.end
  %10 = load ptr, ptr %func, align 8
  %p10 = getelementptr inbounds %struct.Proto, ptr %1, i64 0, i32 5
  %11 = load ptr, ptr %p10, align 8
  %12 = load i32, ptr %np, align 4
  %inc12 = add nsw i32 %12, 1
  store i32 %inc12, ptr %np, align 4
  %idxprom13 = sext i32 %12 to i64
  %arrayidx14 = getelementptr inbounds ptr, ptr %11, i64 %idxprom13
  store ptr %10, ptr %arrayidx14, align 8
  %13 = load ptr, ptr %func, align 8
  %marked = getelementptr inbounds %struct.GCheader, ptr %13, i64 0, i32 2
  %14 = load i8, ptr %marked, align 1
  %15 = and i8 %14, 3
  %tobool.not = icmp eq i8 %15, 0
  br i1 %tobool.not, label %if.end23, label %land.lhs.true

land.lhs.true:                                    ; preds = %while.end
  %marked16 = getelementptr inbounds %struct.GCheader, ptr %1, i64 0, i32 2
  %16 = load i8, ptr %marked16, align 1
  %17 = and i8 %16, 4
  %tobool19.not = icmp eq i8 %17, 0
  br i1 %tobool19.not, label %if.end23, label %if.then20

if.then20:                                        ; preds = %land.lhs.true
  %L21 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 6
  %18 = load ptr, ptr %L21, align 8
  %19 = getelementptr i8, ptr %18, i64 32
  %.val = load ptr, ptr %19, align 8
  %gcstate.i = getelementptr inbounds %struct.global_State, ptr %.val, i64 0, i32 4
  %20 = load i8, ptr %gcstate.i, align 1
  %cmp.i = icmp eq i8 %20, 1
  br i1 %cmp.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %if.then20
  tail call fastcc void @reallymarkobject(ptr noundef nonnull %.val, ptr noundef nonnull %13)
  br label %if.end23

if.else.i:                                        ; preds = %if.then20
  %21 = and i8 %16, -8
  %currentwhite.i = getelementptr inbounds %struct.global_State, ptr %.val, i64 0, i32 3
  %22 = load i8, ptr %currentwhite.i, align 8
  %23 = and i8 %22, 3
  %or4.i = or disjoint i8 %23, %21
  store i8 %or4.i, ptr %marked16, align 1
  br label %if.end23

if.end23:                                         ; preds = %if.else.i, %if.then.i, %land.lhs.true, %while.end
  %24 = load i32, ptr %np, align 4
  %sub = shl i32 %24, 14
  %or3.i = add i32 %sub, -16348
  %ls.i = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  %25 = load ptr, ptr %ls.i, align 8
  %lastline.i = getelementptr inbounds %struct.LexState, ptr %25, i64 0, i32 2
  %26 = load i32, ptr %lastline.i, align 8
  %call.i = tail call fastcc i32 @luaK_code(ptr noundef nonnull %0, i32 noundef %or3.i, i32 noundef %26)
  %t.i = getelementptr inbounds %struct.expdesc, ptr %v, i64 0, i32 2
  store i32 -1, ptr %t.i, align 8
  %f.i = getelementptr inbounds %struct.expdesc, ptr %v, i64 0, i32 3
  store i32 -1, ptr %f.i, align 4
  store i32 11, ptr %v, align 8
  %u.i = getelementptr inbounds %struct.expdesc, ptr %v, i64 0, i32 1
  store i32 %call.i, ptr %u.i, align 8
  %27 = load ptr, ptr %func, align 8
  %nups33 = getelementptr inbounds %struct.Proto, ptr %27, i64 0, i32 19
  %28 = load i8, ptr %nups33, align 8
  %cmp2835.not = icmp eq i8 %28, 0
  br i1 %cmp2835.not, label %for.end, label %for.body

for.body:                                         ; preds = %if.end23, %for.body
  %indvars.iv38 = phi i64 [ %indvars.iv.next39, %for.body ], [ 0, %if.end23 ]
  %arrayidx31 = getelementptr inbounds %struct.FuncState, ptr %func, i64 0, i32 14, i64 %indvars.iv38
  %29 = load i8, ptr %arrayidx31, align 1
  %cmp33 = icmp eq i8 %29, 6
  %cond = select i1 %cmp33, i32 0, i32 4
  %info = getelementptr inbounds %struct.FuncState, ptr %func, i64 0, i32 14, i64 %indvars.iv38, i32 1
  %30 = load i8, ptr %info, align 1
  %conv38 = zext i8 %30 to i32
  %shl2.i26 = shl nuw nsw i32 %conv38, 23
  %or3.i27 = or disjoint i32 %shl2.i26, %cond
  %31 = load ptr, ptr %ls.i, align 8
  %lastline.i29 = getelementptr inbounds %struct.LexState, ptr %31, i64 0, i32 2
  %32 = load i32, ptr %lastline.i29, align 8
  %call.i30 = tail call fastcc i32 @luaK_code(ptr noundef nonnull %0, i32 noundef %or3.i27, i32 noundef %32)
  %indvars.iv.next39 = add nuw nsw i64 %indvars.iv38, 1
  %33 = load ptr, ptr %func, align 8
  %nups = getelementptr inbounds %struct.Proto, ptr %33, i64 0, i32 19
  %34 = load i8, ptr %nups, align 8
  %35 = zext i8 %34 to i64
  %cmp28 = icmp ult i64 %indvars.iv.next39, %35
  br i1 %cmp28, label %for.body, label %for.end, !llvm.loop !121

for.end:                                          ; preds = %for.body, %if.end23
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @field(ptr noundef %ls, ptr nocapture noundef %v) unnamed_addr #0 {
entry:
  %o.i.i.i = alloca %struct.lua_TValue, align 8
  %key = alloca %struct.expdesc, align 8
  %fs1 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 5
  %0 = load ptr, ptr %fs1, align 8
  %call = tail call fastcc i32 @luaK_exp2anyreg(ptr noundef %0, ptr noundef %v)
  %linenumber.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 1
  %1 = load i32, ptr %linenumber.i, align 4
  %lastline.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 2
  store i32 %1, ptr %lastline.i, align 8
  %lookahead.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 4
  %2 = load i32, ptr %lookahead.i, align 8
  %cmp.not.i = icmp eq i32 %2, 287
  %t4.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 3
  br i1 %cmp.not.i, label %if.else.i, label %if.then.i

if.then.i:                                        ; preds = %entry
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t4.i, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i, align 8
  %.pr = load i32, ptr %t4.i, align 8
  br label %luaX_next.exit

if.else.i:                                        ; preds = %entry
  %seminfo.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 3, i32 1
  %call.i = tail call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i)
  store i32 %call.i, ptr %t4.i, align 8
  br label %luaX_next.exit

luaX_next.exit:                                   ; preds = %if.then.i, %if.else.i
  %3 = phi i32 [ %.pr, %if.then.i ], [ %call.i, %if.else.i ]
  %cmp.not.i.i.i = icmp eq i32 %3, 285
  br i1 %cmp.not.i.i.i, label %check.exit.i.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %luaX_next.exit
  %L.i.i.i.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 6
  %4 = load ptr, ptr %L.i.i.i.i, align 8
  %call1.i.i.i.i = tail call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %4, ptr noundef nonnull @.str.164, ptr noundef nonnull @.str.88)
  %5 = load i32, ptr %t4.i, align 8
  tail call fastcc void @luaX_lexerror(ptr noundef nonnull %ls, ptr noundef %call1.i.i.i.i, i32 noundef %5)
  unreachable

check.exit.i.i:                                   ; preds = %luaX_next.exit
  %seminfo.i.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 3, i32 1
  %6 = load ptr, ptr %seminfo.i.i, align 8
  %7 = load i32, ptr %linenumber.i, align 4
  store i32 %7, ptr %lastline.i, align 8
  %8 = load i32, ptr %lookahead.i, align 8
  %cmp.not.i3.i.i = icmp eq i32 %8, 287
  br i1 %cmp.not.i3.i.i, label %if.else.i.i.i, label %if.then.i4.i.i

if.then.i4.i.i:                                   ; preds = %check.exit.i.i
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t4.i, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i, align 8
  br label %checkname.exit

if.else.i.i.i:                                    ; preds = %check.exit.i.i
  %call.i.i.i = tail call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i.i)
  store i32 %call.i.i.i, ptr %t4.i, align 8
  br label %checkname.exit

checkname.exit:                                   ; preds = %if.then.i4.i.i, %if.else.i.i.i
  %ls.val.i = load ptr, ptr %fs1, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %o.i.i.i)
  store ptr %6, ptr %o.i.i.i, align 8
  %tt.i.i.i = getelementptr inbounds %struct.lua_TValue, ptr %o.i.i.i, i64 0, i32 1
  store i32 4, ptr %tt.i.i.i, align 8
  %call.i.i2.i = call fastcc i32 @addk(ptr noundef %ls.val.i, ptr noundef nonnull %o.i.i.i, ptr noundef nonnull %o.i.i.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %o.i.i.i)
  %t.i.i3.i = getelementptr inbounds %struct.expdesc, ptr %key, i64 0, i32 2
  store i32 -1, ptr %t.i.i3.i, align 8
  %f.i.i.i = getelementptr inbounds %struct.expdesc, ptr %key, i64 0, i32 3
  store i32 -1, ptr %f.i.i.i, align 4
  store i32 4, ptr %key, align 8
  %u.i.i.i = getelementptr inbounds %struct.expdesc, ptr %key, i64 0, i32 1
  store i32 %call.i.i2.i, ptr %u.i.i.i, align 8
  %call.i5 = call fastcc i32 @luaK_exp2RK(ptr noundef %0, ptr noundef nonnull %key)
  %aux.i = getelementptr inbounds i8, ptr %v, i64 12
  store i32 %call.i5, ptr %aux.i, align 4
  store i32 9, ptr %v, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @funcargs(ptr noundef %ls, ptr nocapture noundef %f) unnamed_addr #0 {
entry:
  %o.i.i = alloca %struct.lua_TValue, align 8
  %args = alloca %struct.expdesc, align 8
  %fs1 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 5
  %0 = load ptr, ptr %fs1, align 8
  %linenumber = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 1
  %1 = load i32, ptr %linenumber, align 4
  %t = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 3
  %2 = load i32, ptr %t, align 8
  switch i32 %2, label %sw.default [
    i32 40, label %sw.bb
    i32 123, label %sw.bb7
    i32 286, label %sw.bb8
  ]

sw.bb:                                            ; preds = %entry
  %lastline = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 2
  %3 = load i32, ptr %lastline, align 8
  %cmp.not = icmp eq i32 %1, %3
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %sw.bb
  tail call fastcc void @luaX_lexerror(ptr noundef nonnull %ls, ptr noundef nonnull @.str.161, i32 noundef 40)
  unreachable

if.end:                                           ; preds = %sw.bb
  store i32 %1, ptr %lastline, align 8
  %lookahead.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 4
  %4 = load i32, ptr %lookahead.i, align 8
  %cmp.not.i = icmp eq i32 %4, 287
  br i1 %cmp.not.i, label %if.else.i, label %if.then.i

if.then.i:                                        ; preds = %if.end
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i, align 8
  %.pr = load i32, ptr %t, align 8
  br label %luaX_next.exit

if.else.i:                                        ; preds = %if.end
  %seminfo.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 3, i32 1
  %call.i = tail call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i)
  store i32 %call.i, ptr %t, align 8
  br label %luaX_next.exit

luaX_next.exit:                                   ; preds = %if.then.i, %if.else.i
  %5 = phi i32 [ %.pr, %if.then.i ], [ %call.i, %if.else.i ]
  %cmp4 = icmp eq i32 %5, 41
  br i1 %cmp4, label %if.then5, label %if.else

if.then5:                                         ; preds = %luaX_next.exit
  store i32 0, ptr %args, align 8
  br label %if.end6

if.else:                                          ; preds = %luaX_next.exit
  %call.i96 = call fastcc i32 @subexpr(ptr noundef nonnull %ls, ptr noundef nonnull %args, i32 noundef 0), !range !93
  %6 = load i32, ptr %t, align 8
  %cmp.i99 = icmp eq i32 %6, 44
  br i1 %cmp.i99, label %if.then.i93.lr.ph, label %explist1.exit

if.then.i93.lr.ph:                                ; preds = %if.else
  %seminfo.i.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 3, i32 1
  %u.i.i81 = getelementptr inbounds %struct.expdesc, ptr %args, i64 0, i32 1
  br label %if.then.i93

if.then.i93:                                      ; preds = %if.then.i93.lr.ph, %luaK_exp2nextreg.exit91
  %7 = load i32, ptr %linenumber, align 4
  store i32 %7, ptr %lastline, align 8
  %8 = load i32, ptr %lookahead.i, align 8
  %cmp.not.i.i = icmp eq i32 %8, 287
  br i1 %cmp.not.i.i, label %if.else.i.i, label %if.then.i.i94

if.then.i.i94:                                    ; preds = %if.then.i93
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i, align 8
  br label %while.body.i

if.else.i.i:                                      ; preds = %if.then.i93
  %call.i.i95 = call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i.i)
  store i32 %call.i.i95, ptr %t, align 8
  br label %while.body.i

while.body.i:                                     ; preds = %if.then.i.i94, %if.else.i.i
  %9 = load ptr, ptr %fs1, align 8
  call fastcc void @luaK_dischargevars(ptr noundef %9, ptr noundef nonnull %args)
  %10 = load i32, ptr %args, align 8
  %cmp.i.i61 = icmp eq i32 %10, 12
  br i1 %cmp.i.i61, label %if.then.i.i80, label %freeexp.exit.i62

if.then.i.i80:                                    ; preds = %while.body.i
  %11 = load i32, ptr %u.i.i81, align 8
  %and.i.i.i82 = and i32 %11, 256
  %tobool.not.i.i.i83 = icmp eq i32 %and.i.i.i82, 0
  br i1 %tobool.not.i.i.i83, label %land.lhs.true.i.i.i84, label %freeexp.exit.i62

land.lhs.true.i.i.i84:                            ; preds = %if.then.i.i80
  %nactvar.i.i.i85 = getelementptr inbounds %struct.FuncState, ptr %9, i64 0, i32 13
  %12 = load i8, ptr %nactvar.i.i.i85, align 2
  %conv.i.i.i86 = zext i8 %12 to i32
  %cmp.not.i.i.i87 = icmp slt i32 %11, %conv.i.i.i86
  br i1 %cmp.not.i.i.i87, label %freeexp.exit.i62, label %if.then.i.i.i88

if.then.i.i.i88:                                  ; preds = %land.lhs.true.i.i.i84
  %freereg.i.i.i89 = getelementptr inbounds %struct.FuncState, ptr %9, i64 0, i32 9
  %13 = load i32, ptr %freereg.i.i.i89, align 4
  %dec.i.i.i90 = add nsw i32 %13, -1
  store i32 %dec.i.i.i90, ptr %freereg.i.i.i89, align 4
  br label %freeexp.exit.i62

freeexp.exit.i62:                                 ; preds = %if.then.i.i.i88, %land.lhs.true.i.i.i84, %if.then.i.i80, %while.body.i
  %freereg.i.i7.i63 = getelementptr inbounds %struct.FuncState, ptr %9, i64 0, i32 9
  %14 = load i32, ptr %freereg.i.i7.i63, align 4
  %add.i.i.i64 = add nsw i32 %14, 1
  %15 = load ptr, ptr %9, align 8
  %maxstacksize.i.i.i65 = getelementptr inbounds %struct.Proto, ptr %15, i64 0, i32 22
  %16 = load i8, ptr %maxstacksize.i.i.i65, align 1
  %conv.i.i8.i66 = zext i8 %16 to i32
  %cmp.i.i.not.i67 = icmp slt i32 %14, %conv.i.i8.i66
  br i1 %cmp.i.i.not.i67, label %luaK_exp2nextreg.exit91, label %if.then.i.i9.i68

if.then.i.i9.i68:                                 ; preds = %freeexp.exit.i62
  %cmp2.i.i.i69 = icmp sgt i32 %14, 248
  br i1 %cmp2.i.i.i69, label %if.then4.i.i.i77, label %if.end.i.i.i70

if.then4.i.i.i77:                                 ; preds = %if.then.i.i9.i68
  %ls.i.i.i78 = getelementptr inbounds %struct.FuncState, ptr %9, i64 0, i32 3
  %17 = load ptr, ptr %ls.i.i.i78, align 8
  %t.i.i.i.i79 = getelementptr inbounds %struct.LexState, ptr %17, i64 0, i32 3
  %18 = load i32, ptr %t.i.i.i.i79, align 8
  call fastcc void @luaX_lexerror(ptr noundef %17, ptr noundef nonnull @.str.150, i32 noundef %18)
  unreachable

if.end.i.i.i70:                                   ; preds = %if.then.i.i9.i68
  %conv5.i.i.i71 = trunc i32 %add.i.i.i64 to i8
  store i8 %conv5.i.i.i71, ptr %maxstacksize.i.i.i65, align 1
  %.pre.i.i72 = load i32, ptr %freereg.i.i7.i63, align 4
  %.pre3.i.i73 = add nsw i32 %.pre.i.i72, 1
  br label %luaK_exp2nextreg.exit91

luaK_exp2nextreg.exit91:                          ; preds = %freeexp.exit.i62, %if.end.i.i.i70
  %add.pre-phi.i.i75 = phi i32 [ %add.i.i.i64, %freeexp.exit.i62 ], [ %.pre3.i.i73, %if.end.i.i.i70 ]
  store i32 %add.pre-phi.i.i75, ptr %freereg.i.i7.i63, align 4
  %sub.i76 = add nsw i32 %add.pre-phi.i.i75, -1
  call fastcc void @exp2reg(ptr noundef nonnull %9, ptr noundef nonnull %args, i32 noundef %sub.i76)
  %call.i60 = call fastcc i32 @subexpr(ptr noundef nonnull %ls, ptr noundef nonnull %args, i32 noundef 0), !range !93
  %19 = load i32, ptr %t, align 8
  %cmp.i = icmp eq i32 %19, 44
  br i1 %cmp.i, label %if.then.i93, label %explist1.exit, !llvm.loop !97

explist1.exit:                                    ; preds = %luaK_exp2nextreg.exit91, %if.else
  %20 = load i32, ptr %args, align 8
  switch i32 %20, label %if.end6 [
    i32 13, label %if.then.i26
    i32 14, label %if.then10.i
  ]

if.then.i26:                                      ; preds = %explist1.exit
  %21 = load ptr, ptr %0, align 8
  %code.i = getelementptr inbounds %struct.Proto, ptr %21, i64 0, i32 4
  %22 = load ptr, ptr %code.i, align 8
  %u.i = getelementptr inbounds %struct.expdesc, ptr %args, i64 0, i32 1
  %23 = load i32, ptr %u.i, align 8
  %idxprom.i = sext i32 %23 to i64
  %arrayidx.i = getelementptr inbounds i32, ptr %22, i64 %idxprom.i
  %24 = load i32, ptr %arrayidx.i, align 4
  %and.i = and i32 %24, -8372225
  store i32 %and.i, ptr %arrayidx.i, align 4
  br label %if.end6

if.then10.i:                                      ; preds = %explist1.exit
  %25 = load ptr, ptr %0, align 8
  %code12.i = getelementptr inbounds %struct.Proto, ptr %25, i64 0, i32 4
  %26 = load ptr, ptr %code12.i, align 8
  %u13.i = getelementptr inbounds %struct.expdesc, ptr %args, i64 0, i32 1
  %27 = load i32, ptr %u13.i, align 8
  %idxprom15.i = sext i32 %27 to i64
  %arrayidx16.i = getelementptr inbounds i32, ptr %26, i64 %idxprom15.i
  %28 = load i32, ptr %arrayidx16.i, align 4
  %and17.i = and i32 %28, 8388607
  store i32 %and17.i, ptr %arrayidx16.i, align 4
  %29 = load ptr, ptr %0, align 8
  %code29.i = getelementptr inbounds %struct.Proto, ptr %29, i64 0, i32 4
  %30 = load ptr, ptr %code29.i, align 8
  %31 = load i32, ptr %u13.i, align 8
  %idxprom32.i = sext i32 %31 to i64
  %arrayidx33.i = getelementptr inbounds i32, ptr %30, i64 %idxprom32.i
  %32 = load i32, ptr %arrayidx33.i, align 4
  %and34.i = and i32 %32, -16321
  %freereg.i = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 9
  %33 = load i32, ptr %freereg.i, align 4
  %shl35.i = shl i32 %33, 6
  %and36.i = and i32 %shl35.i, 16320
  %or37.i = or disjoint i32 %and36.i, %and34.i
  store i32 %or37.i, ptr %arrayidx33.i, align 4
  %34 = load i32, ptr %freereg.i, align 4
  %add.i.i.i = add nsw i32 %34, 1
  %35 = load ptr, ptr %0, align 8
  %maxstacksize.i.i.i = getelementptr inbounds %struct.Proto, ptr %35, i64 0, i32 22
  %36 = load i8, ptr %maxstacksize.i.i.i, align 1
  %conv.i.i.i = zext i8 %36 to i32
  %cmp.i.i.not.i = icmp slt i32 %34, %conv.i.i.i
  br i1 %cmp.i.i.not.i, label %luaK_reserveregs.exit.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %if.then10.i
  %cmp2.i.i.i = icmp sgt i32 %34, 248
  br i1 %cmp2.i.i.i, label %if.then4.i.i.i, label %if.end.i.i.i

if.then4.i.i.i:                                   ; preds = %if.then.i.i.i
  %ls.i.i.i = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  %37 = load ptr, ptr %ls.i.i.i, align 8
  %t.i.i.i.i = getelementptr inbounds %struct.LexState, ptr %37, i64 0, i32 3
  %38 = load i32, ptr %t.i.i.i.i, align 8
  call fastcc void @luaX_lexerror(ptr noundef %37, ptr noundef nonnull @.str.150, i32 noundef %38)
  unreachable

if.end.i.i.i:                                     ; preds = %if.then.i.i.i
  %conv5.i.i.i = trunc i32 %add.i.i.i to i8
  store i8 %conv5.i.i.i, ptr %maxstacksize.i.i.i, align 1
  %.pre.i.i = load i32, ptr %freereg.i, align 4
  %.pre3.i.i = add nsw i32 %.pre.i.i, 1
  br label %luaK_reserveregs.exit.i

luaK_reserveregs.exit.i:                          ; preds = %if.end.i.i.i, %if.then10.i
  %add.pre-phi.i.i = phi i32 [ %add.i.i.i, %if.then10.i ], [ %.pre3.i.i, %if.end.i.i.i ]
  store i32 %add.pre-phi.i.i, ptr %freereg.i, align 4
  br label %if.end6

if.end6:                                          ; preds = %luaK_reserveregs.exit.i, %if.then.i26, %explist1.exit, %if.then5
  call fastcc void @check_match(ptr noundef nonnull %ls, i32 noundef 41, i32 noundef 40, i32 noundef %1)
  br label %sw.epilog

sw.bb7:                                           ; preds = %entry
  call fastcc void @constructor(ptr noundef nonnull %ls, ptr noundef nonnull %args)
  br label %sw.epilog

sw.bb8:                                           ; preds = %entry
  %seminfo = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 3, i32 1
  %39 = load ptr, ptr %seminfo, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %o.i.i)
  store ptr %39, ptr %o.i.i, align 8
  %tt.i.i = getelementptr inbounds %struct.lua_TValue, ptr %o.i.i, i64 0, i32 1
  store i32 4, ptr %tt.i.i, align 8
  %call.i.i = call fastcc i32 @addk(ptr noundef %0, ptr noundef nonnull %o.i.i, ptr noundef nonnull %o.i.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %o.i.i)
  %t.i.i = getelementptr inbounds %struct.expdesc, ptr %args, i64 0, i32 2
  store i32 -1, ptr %t.i.i, align 8
  %f.i.i = getelementptr inbounds %struct.expdesc, ptr %args, i64 0, i32 3
  store i32 -1, ptr %f.i.i, align 4
  store i32 4, ptr %args, align 8
  %u.i.i = getelementptr inbounds %struct.expdesc, ptr %args, i64 0, i32 1
  store i32 %call.i.i, ptr %u.i.i, align 8
  %40 = load i32, ptr %linenumber, align 4
  %lastline.i28 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 2
  store i32 %40, ptr %lastline.i28, align 8
  %lookahead.i29 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 4
  %41 = load i32, ptr %lookahead.i29, align 8
  %cmp.not.i30 = icmp eq i32 %41, 287
  br i1 %cmp.not.i30, label %if.else.i33, label %if.then.i32

if.then.i32:                                      ; preds = %sw.bb8
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i29, i64 16, i1 false)
  store i32 287, ptr %lookahead.i29, align 8
  br label %sw.epilog

if.else.i33:                                      ; preds = %sw.bb8
  %call.i35 = tail call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo)
  store i32 %call.i35, ptr %t, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  tail call fastcc void @luaX_lexerror(ptr noundef nonnull %ls, ptr noundef nonnull @.str.162, i32 noundef %2)
  unreachable

sw.epilog:                                        ; preds = %if.else.i33, %if.then.i32, %sw.bb7, %if.end6
  %u = getelementptr inbounds %struct.expdesc, ptr %f, i64 0, i32 1
  %42 = load i32, ptr %u, align 8
  %43 = load i32, ptr %args, align 8
  %44 = add i32 %43, -13
  %or.cond = icmp ult i32 %44, 2
  br i1 %or.cond, label %if.end20, label %if.else15

if.else15:                                        ; preds = %sw.epilog
  %cmp17.not = icmp eq i32 %43, 0
  br i1 %cmp17.not, label %if.end19, label %if.then18

if.then18:                                        ; preds = %if.else15
  call fastcc void @luaK_dischargevars(ptr noundef %0, ptr noundef nonnull %args)
  %45 = load i32, ptr %args, align 8
  %cmp.i.i = icmp eq i32 %45, 12
  br i1 %cmp.i.i, label %if.then.i.i, label %freeexp.exit.i

if.then.i.i:                                      ; preds = %if.then18
  %u.i.i52 = getelementptr inbounds %struct.expdesc, ptr %args, i64 0, i32 1
  %46 = load i32, ptr %u.i.i52, align 8
  %and.i.i.i = and i32 %46, 256
  %tobool.not.i.i.i = icmp eq i32 %and.i.i.i, 0
  br i1 %tobool.not.i.i.i, label %land.lhs.true.i.i.i, label %freeexp.exit.i

land.lhs.true.i.i.i:                              ; preds = %if.then.i.i
  %nactvar.i.i.i = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 13
  %47 = load i8, ptr %nactvar.i.i.i, align 2
  %conv.i.i.i53 = zext i8 %47 to i32
  %cmp.not.i.i.i = icmp slt i32 %46, %conv.i.i.i53
  br i1 %cmp.not.i.i.i, label %freeexp.exit.i, label %if.then.i.i.i54

if.then.i.i.i54:                                  ; preds = %land.lhs.true.i.i.i
  %freereg.i.i.i = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 9
  %48 = load i32, ptr %freereg.i.i.i, align 4
  %dec.i.i.i = add nsw i32 %48, -1
  store i32 %dec.i.i.i, ptr %freereg.i.i.i, align 4
  br label %freeexp.exit.i

freeexp.exit.i:                                   ; preds = %if.then.i.i.i54, %land.lhs.true.i.i.i, %if.then.i.i, %if.then18
  %freereg.i.i7.i = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 9
  %49 = load i32, ptr %freereg.i.i7.i, align 4
  %add.i.i.i39 = add nsw i32 %49, 1
  %50 = load ptr, ptr %0, align 8
  %maxstacksize.i.i.i40 = getelementptr inbounds %struct.Proto, ptr %50, i64 0, i32 22
  %51 = load i8, ptr %maxstacksize.i.i.i40, align 1
  %conv.i.i8.i = zext i8 %51 to i32
  %cmp.i.i.not.i41 = icmp slt i32 %49, %conv.i.i8.i
  br i1 %cmp.i.i.not.i41, label %luaK_exp2nextreg.exit, label %if.then.i.i9.i

if.then.i.i9.i:                                   ; preds = %freeexp.exit.i
  %cmp2.i.i.i42 = icmp sgt i32 %49, 248
  br i1 %cmp2.i.i.i42, label %if.then4.i.i.i49, label %if.end.i.i.i43

if.then4.i.i.i49:                                 ; preds = %if.then.i.i9.i
  %ls.i.i.i50 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  %52 = load ptr, ptr %ls.i.i.i50, align 8
  %t.i.i.i.i51 = getelementptr inbounds %struct.LexState, ptr %52, i64 0, i32 3
  %53 = load i32, ptr %t.i.i.i.i51, align 8
  call fastcc void @luaX_lexerror(ptr noundef %52, ptr noundef nonnull @.str.150, i32 noundef %53)
  unreachable

if.end.i.i.i43:                                   ; preds = %if.then.i.i9.i
  %conv5.i.i.i44 = trunc i32 %add.i.i.i39 to i8
  store i8 %conv5.i.i.i44, ptr %maxstacksize.i.i.i40, align 1
  %.pre.i.i45 = load i32, ptr %freereg.i.i7.i, align 4
  %.pre3.i.i46 = add nsw i32 %.pre.i.i45, 1
  br label %luaK_exp2nextreg.exit

luaK_exp2nextreg.exit:                            ; preds = %freeexp.exit.i, %if.end.i.i.i43
  %add.pre-phi.i.i48 = phi i32 [ %add.i.i.i39, %freeexp.exit.i ], [ %.pre3.i.i46, %if.end.i.i.i43 ]
  store i32 %add.pre-phi.i.i48, ptr %freereg.i.i7.i, align 4
  %sub.i = add nsw i32 %add.pre-phi.i.i48, -1
  call fastcc void @exp2reg(ptr noundef nonnull %0, ptr noundef nonnull %args, i32 noundef %sub.i)
  br label %if.end19

if.end19:                                         ; preds = %luaK_exp2nextreg.exit, %if.else15
  %freereg = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 9
  %54 = load i32, ptr %freereg, align 4
  %55 = sub i32 %54, %42
  %56 = shl i32 %55, 23
  br label %if.end20

if.end20:                                         ; preds = %sw.epilog, %if.end19
  %nparams.0 = phi i32 [ %56, %if.end19 ], [ 0, %sw.epilog ]
  %shl1.i = shl i32 %42, 6
  %or.i = or i32 %shl1.i, %nparams.0
  %or5.i = or i32 %or.i, 32796
  %ls.i = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  %57 = load ptr, ptr %ls.i, align 8
  %lastline.i55 = getelementptr inbounds %struct.LexState, ptr %57, i64 0, i32 2
  %58 = load i32, ptr %lastline.i55, align 8
  %call.i56 = call fastcc i32 @luaK_code(ptr noundef %0, i32 noundef %or5.i, i32 noundef %58)
  %t.i57 = getelementptr inbounds %struct.expdesc, ptr %f, i64 0, i32 2
  store i32 -1, ptr %t.i57, align 8
  %f.i = getelementptr inbounds %struct.expdesc, ptr %f, i64 0, i32 3
  store i32 -1, ptr %f.i, align 4
  store i32 13, ptr %f, align 8
  store i32 %call.i56, ptr %u, align 8
  %.val = load ptr, ptr %0, align 8
  %59 = getelementptr i8, ptr %0, i64 48
  %.val24 = load i32, ptr %59, align 8
  %60 = getelementptr i8, ptr %.val, i64 40
  %.val.val = load ptr, ptr %60, align 8
  %61 = sext i32 %.val24 to i64
  %62 = getelementptr i32, ptr %.val.val, i64 %61
  %arrayidx.i59 = getelementptr i32, ptr %62, i64 -1
  store i32 %1, ptr %arrayidx.i59, align 4
  %add23 = add nsw i32 %42, 1
  %freereg24 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 9
  store i32 %add23, ptr %freereg24, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @singlevar(ptr noundef %ls, ptr nocapture noundef %var) unnamed_addr #0 {
entry:
  %o.i = alloca %struct.lua_TValue, align 8
  %t.i.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 3
  %0 = load i32, ptr %t.i.i, align 8
  %cmp.not.i.i = icmp eq i32 %0, 285
  br i1 %cmp.not.i.i, label %check.exit.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %entry
  %L.i.i.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 6
  %1 = load ptr, ptr %L.i.i.i, align 8
  %call1.i.i.i = tail call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %1, ptr noundef nonnull @.str.164, ptr noundef nonnull @.str.88)
  %2 = load i32, ptr %t.i.i, align 8
  tail call fastcc void @luaX_lexerror(ptr noundef nonnull %ls, ptr noundef %call1.i.i.i, i32 noundef %2)
  unreachable

check.exit.i:                                     ; preds = %entry
  %seminfo.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 3, i32 1
  %3 = load ptr, ptr %seminfo.i, align 8
  %linenumber.i.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 1
  %4 = load i32, ptr %linenumber.i.i, align 4
  %lastline.i.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 2
  store i32 %4, ptr %lastline.i.i, align 8
  %lookahead.i.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 4
  %5 = load i32, ptr %lookahead.i.i, align 8
  %cmp.not.i3.i = icmp eq i32 %5, 287
  br i1 %cmp.not.i3.i, label %if.else.i.i, label %if.then.i4.i

if.then.i4.i:                                     ; preds = %check.exit.i
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t.i.i, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i.i, align 8
  br label %str_checkname.exit

if.else.i.i:                                      ; preds = %check.exit.i
  %call.i.i = tail call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i)
  store i32 %call.i.i, ptr %t.i.i, align 8
  br label %str_checkname.exit

str_checkname.exit:                               ; preds = %if.then.i4.i, %if.else.i.i
  %fs1 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 5
  %6 = load ptr, ptr %fs1, align 8
  %call2 = tail call fastcc i32 @singlevaraux(ptr noundef %6, ptr noundef %3, ptr noundef %var, i32 noundef 1), !range !122
  %cmp = icmp eq i32 %call2, 8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %str_checkname.exit
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %o.i)
  store ptr %3, ptr %o.i, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %o.i, i64 0, i32 1
  store i32 4, ptr %tt.i, align 8
  %call.i = call fastcc i32 @addk(ptr noundef %6, ptr noundef nonnull %o.i, ptr noundef nonnull %o.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %o.i)
  %u = getelementptr inbounds %struct.expdesc, ptr %var, i64 0, i32 1
  store i32 %call.i, ptr %u, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %str_checkname.exit
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @singlevaraux(ptr noundef %fs, ptr noundef %n, ptr nocapture noundef %var, i32 noundef %base) unnamed_addr #0 {
entry:
  %cmp = icmp eq ptr %fs, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %t.i = getelementptr inbounds %struct.expdesc, ptr %var, i64 0, i32 2
  store i32 -1, ptr %t.i, align 8
  %f.i = getelementptr inbounds %struct.expdesc, ptr %var, i64 0, i32 3
  store i32 -1, ptr %f.i, align 4
  store i32 8, ptr %var, align 8
  %u.i = getelementptr inbounds %struct.expdesc, ptr %var, i64 0, i32 1
  store i32 255, ptr %u.i, align 8
  br label %return

if.else:                                          ; preds = %entry
  %nactvar.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 13
  %0 = load i8, ptr %nactvar.i, align 2
  %1 = zext i8 %0 to i64
  br label %for.cond.i

for.cond.i:                                       ; preds = %for.body.i, %if.else
  %indvars.iv.i = phi i64 [ %indvars.iv.next.i, %for.body.i ], [ %1, %if.else ]
  %cmp.i = icmp sgt i64 %indvars.iv.i, 0
  br i1 %cmp.i, label %for.body.i, label %if.else4

for.body.i:                                       ; preds = %for.cond.i
  %indvars.iv.next.i = add nsw i64 %indvars.iv.i, -1
  %2 = load ptr, ptr %fs, align 8
  %locvars.i = getelementptr inbounds %struct.Proto, ptr %2, i64 0, i32 7
  %3 = load ptr, ptr %locvars.i, align 8
  %arrayidx.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 15, i64 %indvars.iv.next.i
  %4 = load i16, ptr %arrayidx.i, align 2
  %idxprom2.i = zext i16 %4 to i64
  %arrayidx3.i = getelementptr inbounds %struct.LocVar, ptr %3, i64 %idxprom2.i
  %5 = load ptr, ptr %arrayidx3.i, align 8
  %cmp4.i = icmp eq ptr %5, %n
  br i1 %cmp4.i, label %searchvar.exit, label %for.cond.i, !llvm.loop !123

searchvar.exit:                                   ; preds = %for.body.i
  %6 = trunc i64 %indvars.iv.next.i to i32
  %cmp1 = icmp sgt i32 %6, -1
  br i1 %cmp1, label %if.then2, label %if.else4

if.then2:                                         ; preds = %searchvar.exit
  %t.i14 = getelementptr inbounds %struct.expdesc, ptr %var, i64 0, i32 2
  store i32 -1, ptr %t.i14, align 8
  %f.i15 = getelementptr inbounds %struct.expdesc, ptr %var, i64 0, i32 3
  store i32 -1, ptr %f.i15, align 4
  store i32 6, ptr %var, align 8
  %u.i16 = getelementptr inbounds %struct.expdesc, ptr %var, i64 0, i32 1
  store i32 %6, ptr %u.i16, align 8
  %tobool.not = icmp eq i32 %base, 0
  br i1 %tobool.not, label %if.then3, label %return

if.then3:                                         ; preds = %if.then2
  %bl1.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 5
  br label %while.cond.i

while.cond.i:                                     ; preds = %land.rhs.i, %if.then3
  %bl.0.in.i = phi ptr [ %bl1.i, %if.then3 ], [ %bl.0.i, %land.rhs.i ]
  %bl.0.i = load ptr, ptr %bl.0.in.i, align 8
  %tobool.not.i = icmp eq ptr %bl.0.i, null
  br i1 %tobool.not.i, label %return, label %land.rhs.i

land.rhs.i:                                       ; preds = %while.cond.i
  %nactvar.i17 = getelementptr inbounds %struct.BlockCnt, ptr %bl.0.i, i64 0, i32 2
  %7 = load i8, ptr %nactvar.i17, align 4
  %conv.i = zext i8 %7 to i32
  %cmp.i18 = icmp sgt i32 %conv.i, %6
  br i1 %cmp.i18, label %while.cond.i, label %if.then.i, !llvm.loop !124

if.then.i:                                        ; preds = %land.rhs.i
  %upval.i = getelementptr inbounds %struct.BlockCnt, ptr %bl.0.i, i64 0, i32 3
  store i8 1, ptr %upval.i, align 1
  br label %return

if.else4:                                         ; preds = %for.cond.i, %searchvar.exit
  %prev = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 2
  %8 = load ptr, ptr %prev, align 8
  %call5 = tail call fastcc i32 @singlevaraux(ptr noundef %8, ptr noundef %n, ptr noundef %var, i32 noundef 0), !range !122
  %cmp6 = icmp eq i32 %call5, 8
  br i1 %cmp6, label %return, label %if.end8

if.end8:                                          ; preds = %if.else4
  %9 = load ptr, ptr %fs, align 8
  %sizeupvalues.i = getelementptr inbounds %struct.Proto, ptr %9, i64 0, i32 10
  %10 = load i32, ptr %sizeupvalues.i, align 8
  %nups.i = getelementptr inbounds %struct.Proto, ptr %9, i64 0, i32 19
  %11 = load i8, ptr %nups.i, align 8
  %conv.i19 = zext i8 %11 to i32
  %cmp39.not.i = icmp eq i8 %11, 0
  br i1 %cmp39.not.i, label %if.end19.i, label %for.body.lr.ph.i

for.body.lr.ph.i:                                 ; preds = %if.end8
  %12 = load i32, ptr %var, align 8
  %u.i20 = getelementptr inbounds %struct.expdesc, ptr %var, i64 0, i32 1
  %wide.trip.count.i = zext i8 %11 to i64
  br label %for.body.i21

for.body.i21:                                     ; preds = %for.inc.i, %for.body.lr.ph.i
  %indvars.iv.i22 = phi i64 [ 0, %for.body.lr.ph.i ], [ %indvars.iv.next.i24, %for.inc.i ]
  %arrayidx.i23 = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 14, i64 %indvars.iv.i22
  %13 = load i8, ptr %arrayidx.i23, align 1
  %conv3.i = zext i8 %13 to i32
  %cmp5.i = icmp eq i32 %12, %conv3.i
  br i1 %cmp5.i, label %land.lhs.true.i, label %for.inc.i

land.lhs.true.i:                                  ; preds = %for.body.i21
  %info.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 14, i64 %indvars.iv.i22, i32 1
  %14 = load i8, ptr %info.i, align 1
  %conv10.i = zext i8 %14 to i32
  %15 = load i32, ptr %u.i20, align 8
  %cmp12.i = icmp eq i32 %15, %conv10.i
  br i1 %cmp12.i, label %return.loopexit.i, label %for.inc.i

for.inc.i:                                        ; preds = %land.lhs.true.i, %for.body.i21
  %indvars.iv.next.i24 = add nuw nsw i64 %indvars.iv.i22, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next.i24, %wide.trip.count.i
  br i1 %exitcond.not.i, label %for.end.i, label %for.body.i21, !llvm.loop !125

for.end.i:                                        ; preds = %for.inc.i
  %cmp16.i = icmp ugt i8 %11, 59
  br i1 %cmp16.i, label %if.then18.i, label %if.end19.i

if.then18.i:                                      ; preds = %for.end.i
  %linedefined.i.i = getelementptr inbounds %struct.Proto, ptr %9, i64 0, i32 16
  %16 = load i32, ptr %linedefined.i.i, align 8
  %cmp.i.i = icmp eq i32 %16, 0
  %L.i.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 4
  %17 = load ptr, ptr %L.i.i, align 8
  br i1 %cmp.i.i, label %cond.true.i.i, label %cond.false.i.i

cond.true.i.i:                                    ; preds = %if.then18.i
  %call.i.i = tail call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %17, ptr noundef nonnull @.str.153, i32 noundef 60, ptr noundef nonnull @.str.160)
  br label %cond.end.i.i

cond.false.i.i:                                   ; preds = %if.then18.i
  %call4.i.i = tail call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %17, ptr noundef nonnull @.str.154, i32 noundef %16, i32 noundef 60, ptr noundef nonnull @.str.160)
  br label %cond.end.i.i

cond.end.i.i:                                     ; preds = %cond.false.i.i, %cond.true.i.i
  %cond.i.i = phi ptr [ %call.i.i, %cond.true.i.i ], [ %call4.i.i, %cond.false.i.i ]
  %ls.i.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 3
  %18 = load ptr, ptr %ls.i.i, align 8
  tail call fastcc void @luaX_lexerror(ptr noundef %18, ptr noundef %cond.i.i, i32 noundef 0)
  unreachable

if.end19.i:                                       ; preds = %for.end.i, %if.end8
  %cmp24.not.i = icmp sgt i32 %10, %conv.i19
  br i1 %cmp24.not.i, label %while.end.i, label %if.end30.i

if.end30.i:                                       ; preds = %if.end19.i
  %L.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 4
  %19 = load ptr, ptr %L.i, align 8
  %upvalues27.i = getelementptr inbounds %struct.Proto, ptr %9, i64 0, i32 8
  %20 = load ptr, ptr %upvalues27.i, align 8
  %call.i = tail call fastcc ptr @luaM_growaux_(ptr noundef %19, ptr noundef %20, ptr noundef nonnull %sizeupvalues.i, i64 noundef 8, i32 noundef 2147483645, ptr noundef nonnull @.str.7)
  store ptr %call.i, ptr %upvalues27.i, align 8
  %.pre.i = load i32, ptr %sizeupvalues.i, align 8
  %cmp3242.i = icmp slt i32 %10, %.pre.i
  br i1 %cmp3242.i, label %while.body.lr.ph.i, label %while.end.i

while.body.lr.ph.i:                               ; preds = %if.end30.i
  %21 = sext i32 %10 to i64
  br label %while.body.i

while.body.i:                                     ; preds = %while.body.i, %while.body.lr.ph.i
  %indvars.iv46.i = phi i64 [ %21, %while.body.lr.ph.i ], [ %indvars.iv.next47.i, %while.body.i ]
  %22 = load ptr, ptr %upvalues27.i, align 8
  %indvars.iv.next47.i = add nsw i64 %indvars.iv46.i, 1
  %arrayidx37.i = getelementptr inbounds ptr, ptr %22, i64 %indvars.iv46.i
  store ptr null, ptr %arrayidx37.i, align 8
  %23 = load i32, ptr %sizeupvalues.i, align 8
  %24 = sext i32 %23 to i64
  %cmp32.i = icmp slt i64 %indvars.iv.next47.i, %24
  br i1 %cmp32.i, label %while.body.i, label %while.end.i, !llvm.loop !126

while.end.i:                                      ; preds = %while.body.i, %if.end30.i, %if.end19.i
  %upvalues38.i = getelementptr inbounds %struct.Proto, ptr %9, i64 0, i32 8
  %25 = load ptr, ptr %upvalues38.i, align 8
  %26 = load i8, ptr %nups.i, align 8
  %idxprom40.i = zext i8 %26 to i64
  %arrayidx41.i = getelementptr inbounds ptr, ptr %25, i64 %idxprom40.i
  store ptr %n, ptr %arrayidx41.i, align 8
  %marked.i = getelementptr inbounds %struct.GCheader, ptr %n, i64 0, i32 2
  %27 = load i8, ptr %marked.i, align 1
  %28 = and i8 %27, 3
  %tobool.not.i25 = icmp eq i8 %28, 0
  br i1 %tobool.not.i25, label %if.end50.i, label %land.lhs.true43.i

land.lhs.true43.i:                                ; preds = %while.end.i
  %marked44.i = getelementptr inbounds %struct.GCheader, ptr %9, i64 0, i32 2
  %29 = load i8, ptr %marked44.i, align 1
  %30 = and i8 %29, 4
  %tobool47.not.i = icmp eq i8 %30, 0
  br i1 %tobool47.not.i, label %if.end50.i, label %if.then48.i

if.then48.i:                                      ; preds = %land.lhs.true43.i
  %L49.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 4
  %31 = load ptr, ptr %L49.i, align 8
  %32 = getelementptr i8, ptr %31, i64 32
  %.val.i = load ptr, ptr %32, align 8
  %gcstate.i.i = getelementptr inbounds %struct.global_State, ptr %.val.i, i64 0, i32 4
  %33 = load i8, ptr %gcstate.i.i, align 1
  %cmp.i34.i = icmp eq i8 %33, 1
  br i1 %cmp.i34.i, label %if.then.i.i, label %if.else.i.i

if.then.i.i:                                      ; preds = %if.then48.i
  tail call fastcc void @reallymarkobject(ptr noundef nonnull %.val.i, ptr noundef nonnull %n)
  br label %if.end50.i

if.else.i.i:                                      ; preds = %if.then48.i
  %34 = and i8 %29, -8
  %currentwhite.i.i = getelementptr inbounds %struct.global_State, ptr %.val.i, i64 0, i32 3
  %35 = load i8, ptr %currentwhite.i.i, align 8
  %36 = and i8 %35, 3
  %or4.i.i = or disjoint i8 %36, %34
  store i8 %or4.i.i, ptr %marked44.i, align 1
  br label %if.end50.i

if.end50.i:                                       ; preds = %if.else.i.i, %if.then.i.i, %land.lhs.true43.i, %while.end.i
  %37 = load i32, ptr %var, align 8
  %conv52.i = trunc i32 %37 to i8
  %38 = load i8, ptr %nups.i, align 8
  %idxprom55.i = zext i8 %38 to i64
  %arrayidx56.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 14, i64 %idxprom55.i
  store i8 %conv52.i, ptr %arrayidx56.i, align 1
  %u58.i = getelementptr inbounds %struct.expdesc, ptr %var, i64 0, i32 1
  %39 = load i32, ptr %u58.i, align 8
  %conv60.i = trunc i32 %39 to i8
  %40 = load i8, ptr %nups.i, align 8
  %idxprom63.i = zext i8 %40 to i64
  %info65.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 14, i64 %idxprom63.i, i32 1
  store i8 %conv60.i, ptr %info65.i, align 1
  %41 = load i8, ptr %nups.i, align 8
  %inc67.i = add i8 %41, 1
  store i8 %inc67.i, ptr %nups.i, align 8
  %conv68.i = zext i8 %41 to i32
  br label %indexupvalue.exit

return.loopexit.i:                                ; preds = %land.lhs.true.i
  %42 = trunc i64 %indvars.iv.i22 to i32
  br label %indexupvalue.exit

indexupvalue.exit:                                ; preds = %if.end50.i, %return.loopexit.i
  %retval.0.i26 = phi i32 [ %conv68.i, %if.end50.i ], [ %42, %return.loopexit.i ]
  %u = getelementptr inbounds %struct.expdesc, ptr %var, i64 0, i32 1
  store i32 %retval.0.i26, ptr %u, align 8
  store i32 7, ptr %var, align 8
  br label %return

return:                                           ; preds = %while.cond.i, %if.then.i, %if.else4, %if.then2, %indexupvalue.exit, %if.then
  %retval.0 = phi i32 [ 8, %if.then ], [ 7, %indexupvalue.exit ], [ 6, %if.then2 ], [ 8, %if.else4 ], [ 6, %if.then.i ], [ 6, %while.cond.i ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @jumponcond(ptr nocapture noundef %fs, ptr nocapture noundef %e, i32 noundef %cond) unnamed_addr #0 {
entry:
  %0 = load i32, ptr %e, align 8
  switch i32 %0, label %entry.if.then.i_crit_edge [
    i32 11, label %if.then
    i32 12, label %if.then.i12
  ]

entry.if.then.i_crit_edge:                        ; preds = %entry
  %.pre = load ptr, ptr %fs, align 8
  br label %if.then.i

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %fs, align 8
  %code = getelementptr inbounds %struct.Proto, ptr %1, i64 0, i32 4
  %2 = load ptr, ptr %code, align 8
  %u = getelementptr inbounds %struct.expdesc, ptr %e, i64 0, i32 1
  %3 = load i32, ptr %u, align 8
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds i32, ptr %2, i64 %idxprom
  %4 = load i32, ptr %arrayidx, align 4
  %and = and i32 %4, 63
  %cmp1 = icmp eq i32 %and, 19
  br i1 %cmp1, label %if.then2, label %if.then.i

if.then2:                                         ; preds = %if.then
  %pc = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 6
  %5 = load i32, ptr %pc, align 8
  %dec = add nsw i32 %5, -1
  store i32 %dec, ptr %pc, align 8
  %shr3 = lshr i32 %4, 23
  %tobool.not = icmp eq i32 %cond, 0
  %lnot.ext = zext i1 %tobool.not to i32
  %call = tail call fastcc i32 @condjump(ptr noundef nonnull %fs, i32 noundef 26, i32 noundef %shr3, i32 noundef 0, i32 noundef %lnot.ext)
  br label %return

if.then.i:                                        ; preds = %entry.if.then.i_crit_edge, %if.then
  %6 = phi ptr [ %.pre, %entry.if.then.i_crit_edge ], [ %1, %if.then ]
  %freereg.i.i.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 9
  %7 = load i32, ptr %freereg.i.i.i, align 4
  %add.i.i.i = add nsw i32 %7, 1
  %maxstacksize.i.i.i = getelementptr inbounds %struct.Proto, ptr %6, i64 0, i32 22
  %8 = load i8, ptr %maxstacksize.i.i.i, align 1
  %conv.i.i.i = zext i8 %8 to i32
  %cmp.i.i.not.i = icmp slt i32 %7, %conv.i.i.i
  br i1 %cmp.i.i.not.i, label %discharge2anyreg.exit, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %if.then.i
  %cmp2.i.i.i = icmp sgt i32 %7, 248
  br i1 %cmp2.i.i.i, label %if.then4.i.i.i, label %if.end.i.i.i

if.then4.i.i.i:                                   ; preds = %if.then.i.i.i
  %ls.i.i.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 3
  %9 = load ptr, ptr %ls.i.i.i, align 8
  %t.i.i.i.i = getelementptr inbounds %struct.LexState, ptr %9, i64 0, i32 3
  %10 = load i32, ptr %t.i.i.i.i, align 8
  tail call fastcc void @luaX_lexerror(ptr noundef %9, ptr noundef nonnull @.str.150, i32 noundef %10)
  unreachable

if.end.i.i.i:                                     ; preds = %if.then.i.i.i
  %conv5.i.i.i = trunc i32 %add.i.i.i to i8
  store i8 %conv5.i.i.i, ptr %maxstacksize.i.i.i, align 1
  %.pre.i.i = load i32, ptr %freereg.i.i.i, align 4
  %.pre3.i.i = add nsw i32 %.pre.i.i, 1
  br label %discharge2anyreg.exit

discharge2anyreg.exit:                            ; preds = %if.then.i, %if.end.i.i.i
  %add.pre-phi.i.i = phi i32 [ %add.i.i.i, %if.then.i ], [ %.pre3.i.i, %if.end.i.i.i ]
  store i32 %add.pre-phi.i.i, ptr %freereg.i.i.i, align 4
  %sub.i = add nsw i32 %add.pre-phi.i.i, -1
  tail call fastcc void @discharge2reg(ptr noundef nonnull %fs, ptr noundef nonnull %e, i32 noundef %sub.i)
  %.pr = load i32, ptr %e, align 8
  %cmp.i = icmp eq i32 %.pr, 12
  br i1 %cmp.i, label %if.then.i12, label %freeexp.exit

if.then.i12:                                      ; preds = %entry, %discharge2anyreg.exit
  %u.i = getelementptr inbounds %struct.expdesc, ptr %e, i64 0, i32 1
  %11 = load i32, ptr %u.i, align 8
  %and.i.i = and i32 %11, 256
  %tobool.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i.i, label %land.lhs.true.i.i, label %freeexp.exit

land.lhs.true.i.i:                                ; preds = %if.then.i12
  %nactvar.i.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 13
  %12 = load i8, ptr %nactvar.i.i, align 2
  %conv.i.i = zext i8 %12 to i32
  %cmp.not.i.i = icmp slt i32 %11, %conv.i.i
  br i1 %cmp.not.i.i, label %freeexp.exit, label %if.then.i.i

if.then.i.i:                                      ; preds = %land.lhs.true.i.i
  %freereg.i.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 9
  %13 = load i32, ptr %freereg.i.i, align 4
  %dec.i.i = add nsw i32 %13, -1
  store i32 %dec.i.i, ptr %freereg.i.i, align 4
  br label %freeexp.exit

freeexp.exit:                                     ; preds = %discharge2anyreg.exit, %if.then.i12, %land.lhs.true.i.i, %if.then.i.i
  %u6 = getelementptr inbounds %struct.expdesc, ptr %e, i64 0, i32 1
  %14 = load i32, ptr %u6, align 8
  %call8 = tail call fastcc i32 @condjump(ptr noundef %fs, i32 noundef 27, i32 noundef 255, i32 noundef %14, i32 noundef %cond)
  br label %return

return:                                           ; preds = %freeexp.exit, %if.then2
  %retval.0 = phi i32 [ %call, %if.then2 ], [ %call8, %freeexp.exit ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @condjump(ptr nocapture noundef %fs, i32 noundef %op, i32 noundef %A, i32 noundef %B, i32 noundef %C) unnamed_addr #0 {
entry:
  %shl1.i = shl i32 %A, 6
  %or.i = or i32 %shl1.i, %op
  %shl2.i = shl i32 %B, 23
  %or3.i = or i32 %or.i, %shl2.i
  %shl4.i = shl i32 %C, 14
  %or5.i = or i32 %or3.i, %shl4.i
  %ls.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 3
  %0 = load ptr, ptr %ls.i, align 8
  %lastline.i = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 2
  %1 = load i32, ptr %lastline.i, align 8
  %call.i = tail call fastcc i32 @luaK_code(ptr noundef %fs, i32 noundef %or5.i, i32 noundef %1)
  %jpc1.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 8
  %2 = load i32, ptr %jpc1.i, align 8
  store i32 -1, ptr %jpc1.i, align 8
  %3 = load ptr, ptr %ls.i, align 8
  %lastline.i.i = getelementptr inbounds %struct.LexState, ptr %3, i64 0, i32 2
  %4 = load i32, ptr %lastline.i.i, align 8
  %call.i.i = tail call fastcc i32 @luaK_code(ptr noundef %fs, i32 noundef 2147450902, i32 noundef %4)
  %cmp.i.i = icmp eq i32 %2, -1
  br i1 %cmp.i.i, label %luaK_jump.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %entry
  %cmp1.i.i = icmp eq i32 %call.i.i, -1
  br i1 %cmp1.i.i, label %luaK_jump.exit, label %while.cond.preheader.i.i

while.cond.preheader.i.i:                         ; preds = %if.else.i.i
  %fs.val.i.i = load ptr, ptr %fs, align 8
  %5 = getelementptr i8, ptr %fs.val.i.i, i64 24
  %fs.val.val.i.i = load ptr, ptr %5, align 8
  br label %while.cond.i.i

while.cond.i.i:                                   ; preds = %while.cond.i.i, %while.cond.preheader.i.i
  %list.0.i.i = phi i32 [ %add1.i.i.i, %while.cond.i.i ], [ %call.i.i, %while.cond.preheader.i.i ]
  %idxprom.i.i.i = sext i32 %list.0.i.i to i64
  %arrayidx.i.i.i = getelementptr inbounds i32, ptr %fs.val.val.i.i, i64 %idxprom.i.i.i
  %6 = load i32, ptr %arrayidx.i.i.i, align 4
  %shr.i.i.i = lshr i32 %6, 14
  %sub.i.i.i = add nsw i32 %shr.i.i.i, -131071
  %cmp.i.i.i = icmp eq i32 %sub.i.i.i, -1
  %add.i.i.i = add nuw nsw i32 %list.0.i.i, 1
  %add1.i.i.i = add nsw i32 %add.i.i.i, %sub.i.i.i
  %cmp4.not12.i.i = icmp eq i32 %add1.i.i.i, -1
  %cmp4.not.i.i = select i1 %cmp.i.i.i, i1 true, i1 %cmp4.not12.i.i
  br i1 %cmp4.not.i.i, label %while.end.i.i, label %while.cond.i.i, !llvm.loop !94

while.end.i.i:                                    ; preds = %while.cond.i.i
  %add.neg.i.i.i = xor i32 %list.0.i.i, -1
  %sub.i7.i.i = add i32 %2, %add.neg.i.i.i
  %7 = tail call i32 @llvm.abs.i32(i32 %sub.i7.i.i, i1 true)
  %cmp.i8.i.i = icmp ugt i32 %7, 131071
  br i1 %cmp.i8.i.i, label %if.then.i.i.i, label %fixjump.exit.i.i

if.then.i.i.i:                                    ; preds = %while.end.i.i
  %8 = load ptr, ptr %ls.i, align 8
  %t.i.i.i.i = getelementptr inbounds %struct.LexState, ptr %8, i64 0, i32 3
  %9 = load i32, ptr %t.i.i.i.i, align 8
  tail call fastcc void @luaX_lexerror(ptr noundef %8, ptr noundef nonnull @.str.148, i32 noundef %9)
  unreachable

fixjump.exit.i.i:                                 ; preds = %while.end.i.i
  %arrayidx.i.i.i.le = getelementptr inbounds i32, ptr %fs.val.val.i.i, i64 %idxprom.i.i.i
  %and.i.i.i = and i32 %6, 16383
  %add1.i11.i.i = shl i32 %sub.i7.i.i, 14
  %shl.i.i.i = add i32 %add1.i11.i.i, 2147467264
  %or.i.i.i = or disjoint i32 %shl.i.i.i, %and.i.i.i
  store i32 %or.i.i.i, ptr %arrayidx.i.i.i.le, align 4
  br label %luaK_jump.exit

luaK_jump.exit:                                   ; preds = %entry, %if.else.i.i, %fixjump.exit.i.i
  %j.0.i = phi i32 [ %call.i.i, %entry ], [ %call.i.i, %fixjump.exit.i.i ], [ %2, %if.else.i.i ]
  ret i32 %j.0.i
}

; Function Attrs: nounwind uwtable
define internal fastcc void @leaveblock(ptr nocapture noundef %fs) unnamed_addr #0 {
entry:
  %bl1 = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 5
  %0 = load ptr, ptr %bl1, align 8
  %1 = load ptr, ptr %0, align 8
  store ptr %1, ptr %bl1, align 8
  %ls = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 3
  %2 = load ptr, ptr %ls, align 8
  %nactvar = getelementptr inbounds %struct.BlockCnt, ptr %0, i64 0, i32 2
  %3 = load i8, ptr %nactvar, align 4
  %4 = getelementptr i8, ptr %2, i64 48
  %.val = load ptr, ptr %4, align 8
  %nactvar.i = getelementptr inbounds %struct.FuncState, ptr %.val, i64 0, i32 13
  %5 = load i8, ptr %nactvar.i, align 2
  %cmp2.i = icmp ugt i8 %5, %3
  br i1 %cmp2.i, label %while.body.lr.ph.i, label %removevars.exit

while.body.lr.ph.i:                               ; preds = %entry
  %pc.i = getelementptr inbounds %struct.FuncState, ptr %.val, i64 0, i32 6
  %.pre.i = load i32, ptr %pc.i, align 8
  br label %while.body.i

while.body.i:                                     ; preds = %while.body.i, %while.body.lr.ph.i
  %6 = phi i8 [ %5, %while.body.lr.ph.i ], [ %10, %while.body.i ]
  %7 = load ptr, ptr %.val, align 8
  %locvars.i = getelementptr inbounds %struct.Proto, ptr %7, i64 0, i32 7
  %8 = load ptr, ptr %locvars.i, align 8
  %dec.i = add i8 %6, -1
  store i8 %dec.i, ptr %nactvar.i, align 2
  %idxprom.i = zext i8 %dec.i to i64
  %arrayidx.i = getelementptr inbounds %struct.FuncState, ptr %.val, i64 0, i32 15, i64 %idxprom.i
  %9 = load i16, ptr %arrayidx.i, align 2
  %idxprom4.i = zext i16 %9 to i64
  %endpc.i = getelementptr inbounds %struct.LocVar, ptr %8, i64 %idxprom4.i, i32 2
  store i32 %.pre.i, ptr %endpc.i, align 4
  %10 = load i8, ptr %nactvar.i, align 2
  %cmp.i = icmp ugt i8 %10, %3
  br i1 %cmp.i, label %while.body.i, label %removevars.exit, !llvm.loop !102

removevars.exit:                                  ; preds = %while.body.i, %entry
  %upval = getelementptr inbounds %struct.BlockCnt, ptr %0, i64 0, i32 3
  %11 = load i8, ptr %upval, align 1
  %tobool.not = icmp eq i8 %11, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %removevars.exit
  %12 = load i8, ptr %nactvar, align 4
  %conv4 = zext i8 %12 to i32
  %shl1.i = shl nuw nsw i32 %conv4, 6
  %or.i = or disjoint i32 %shl1.i, 35
  %13 = load ptr, ptr %ls, align 8
  %lastline.i = getelementptr inbounds %struct.LexState, ptr %13, i64 0, i32 2
  %14 = load i32, ptr %lastline.i, align 8
  %call.i = tail call fastcc i32 @luaK_code(ptr noundef %fs, i32 noundef %or.i, i32 noundef %14)
  br label %if.end

if.end:                                           ; preds = %if.then, %removevars.exit
  %nactvar5 = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 13
  %15 = load i8, ptr %nactvar5, align 2
  %conv6 = zext i8 %15 to i32
  %freereg = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 9
  store i32 %conv6, ptr %freereg, align 4
  %breaklist = getelementptr inbounds %struct.BlockCnt, ptr %0, i64 0, i32 1
  %16 = load i32, ptr %breaklist, align 8
  %pc.i.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 6
  %17 = load i32, ptr %pc.i.i, align 8
  %lasttarget.i.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 7
  store i32 %17, ptr %lasttarget.i.i, align 4
  %jpc.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 8
  %cmp.i.i = icmp eq i32 %16, -1
  br i1 %cmp.i.i, label %luaK_patchtohere.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.end
  %18 = load i32, ptr %jpc.i, align 4
  %cmp1.i.i = icmp eq i32 %18, -1
  br i1 %cmp1.i.i, label %if.then2.i.i, label %while.cond.preheader.i.i

while.cond.preheader.i.i:                         ; preds = %if.else.i.i
  %fs.val.i.i = load ptr, ptr %fs, align 8
  %19 = getelementptr i8, ptr %fs.val.i.i, i64 24
  %fs.val.val.i.i = load ptr, ptr %19, align 8
  br label %while.cond.i.i

if.then2.i.i:                                     ; preds = %if.else.i.i
  store i32 %16, ptr %jpc.i, align 4
  br label %luaK_patchtohere.exit

while.cond.i.i:                                   ; preds = %while.cond.i.i, %while.cond.preheader.i.i
  %list.0.i.i = phi i32 [ %add1.i.i.i, %while.cond.i.i ], [ %18, %while.cond.preheader.i.i ]
  %idxprom.i.i.i = sext i32 %list.0.i.i to i64
  %arrayidx.i.i.i = getelementptr inbounds i32, ptr %fs.val.val.i.i, i64 %idxprom.i.i.i
  %20 = load i32, ptr %arrayidx.i.i.i, align 4
  %shr.i.i.i = lshr i32 %20, 14
  %sub.i.i.i = add nsw i32 %shr.i.i.i, -131071
  %cmp.i.i.i = icmp eq i32 %sub.i.i.i, -1
  %add.i.i.i = add nuw nsw i32 %list.0.i.i, 1
  %add1.i.i.i = add nsw i32 %add.i.i.i, %sub.i.i.i
  %cmp4.not12.i.i = icmp eq i32 %add1.i.i.i, -1
  %cmp4.not.i.i = select i1 %cmp.i.i.i, i1 true, i1 %cmp4.not12.i.i
  br i1 %cmp4.not.i.i, label %while.end.i.i, label %while.cond.i.i, !llvm.loop !94

while.end.i.i:                                    ; preds = %while.cond.i.i
  %add.neg.i.i.i = xor i32 %list.0.i.i, -1
  %sub.i7.i.i = add i32 %16, %add.neg.i.i.i
  %21 = tail call i32 @llvm.abs.i32(i32 %sub.i7.i.i, i1 true)
  %cmp.i8.i.i = icmp ugt i32 %21, 131071
  br i1 %cmp.i8.i.i, label %if.then.i.i.i, label %fixjump.exit.i.i

if.then.i.i.i:                                    ; preds = %while.end.i.i
  %22 = load ptr, ptr %ls, align 8
  %t.i.i.i.i = getelementptr inbounds %struct.LexState, ptr %22, i64 0, i32 3
  %23 = load i32, ptr %t.i.i.i.i, align 8
  tail call fastcc void @luaX_lexerror(ptr noundef %22, ptr noundef nonnull @.str.148, i32 noundef %23)
  unreachable

fixjump.exit.i.i:                                 ; preds = %while.end.i.i
  %arrayidx.i.i.i.le = getelementptr inbounds i32, ptr %fs.val.val.i.i, i64 %idxprom.i.i.i
  %and.i.i.i = and i32 %20, 16383
  %add1.i11.i.i = shl i32 %sub.i7.i.i, 14
  %shl.i.i.i = add i32 %add1.i11.i.i, 2147467264
  %or.i.i.i = or disjoint i32 %shl.i.i.i, %and.i.i.i
  store i32 %or.i.i.i, ptr %arrayidx.i.i.i.le, align 4
  br label %luaK_patchtohere.exit

luaK_patchtohere.exit:                            ; preds = %if.end, %if.then2.i.i, %fixjump.exit.i.i
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @exp1(ptr noundef %ls) unnamed_addr #0 {
entry:
  %e = alloca %struct.expdesc, align 8
  %call.i = call fastcc i32 @subexpr(ptr noundef %ls, ptr noundef nonnull %e, i32 noundef 0), !range !93
  %fs = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 5
  %0 = load ptr, ptr %fs, align 8
  call fastcc void @luaK_dischargevars(ptr noundef %0, ptr noundef nonnull %e)
  %1 = load i32, ptr %e, align 8
  %cmp.i.i = icmp eq i32 %1, 12
  br i1 %cmp.i.i, label %if.then.i.i, label %freeexp.exit.i

if.then.i.i:                                      ; preds = %entry
  %u.i.i = getelementptr inbounds %struct.expdesc, ptr %e, i64 0, i32 1
  %2 = load i32, ptr %u.i.i, align 8
  %and.i.i.i = and i32 %2, 256
  %tobool.not.i.i.i = icmp eq i32 %and.i.i.i, 0
  br i1 %tobool.not.i.i.i, label %land.lhs.true.i.i.i, label %freeexp.exit.i

land.lhs.true.i.i.i:                              ; preds = %if.then.i.i
  %nactvar.i.i.i = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 13
  %3 = load i8, ptr %nactvar.i.i.i, align 2
  %conv.i.i.i = zext i8 %3 to i32
  %cmp.not.i.i.i = icmp slt i32 %2, %conv.i.i.i
  br i1 %cmp.not.i.i.i, label %freeexp.exit.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %land.lhs.true.i.i.i
  %freereg.i.i.i = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 9
  %4 = load i32, ptr %freereg.i.i.i, align 4
  %dec.i.i.i = add nsw i32 %4, -1
  store i32 %dec.i.i.i, ptr %freereg.i.i.i, align 4
  br label %freeexp.exit.i

freeexp.exit.i:                                   ; preds = %if.then.i.i.i, %land.lhs.true.i.i.i, %if.then.i.i, %entry
  %freereg.i.i7.i = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 9
  %5 = load i32, ptr %freereg.i.i7.i, align 4
  %add.i.i.i = add nsw i32 %5, 1
  %6 = load ptr, ptr %0, align 8
  %maxstacksize.i.i.i = getelementptr inbounds %struct.Proto, ptr %6, i64 0, i32 22
  %7 = load i8, ptr %maxstacksize.i.i.i, align 1
  %conv.i.i8.i = zext i8 %7 to i32
  %cmp.i.i.not.i = icmp slt i32 %5, %conv.i.i8.i
  br i1 %cmp.i.i.not.i, label %luaK_exp2nextreg.exit, label %if.then.i.i9.i

if.then.i.i9.i:                                   ; preds = %freeexp.exit.i
  %cmp2.i.i.i = icmp sgt i32 %5, 248
  br i1 %cmp2.i.i.i, label %if.then4.i.i.i, label %if.end.i.i.i

if.then4.i.i.i:                                   ; preds = %if.then.i.i9.i
  %ls.i.i.i = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  %8 = load ptr, ptr %ls.i.i.i, align 8
  %t.i.i.i.i = getelementptr inbounds %struct.LexState, ptr %8, i64 0, i32 3
  %9 = load i32, ptr %t.i.i.i.i, align 8
  call fastcc void @luaX_lexerror(ptr noundef %8, ptr noundef nonnull @.str.150, i32 noundef %9)
  unreachable

if.end.i.i.i:                                     ; preds = %if.then.i.i9.i
  %conv5.i.i.i = trunc i32 %add.i.i.i to i8
  store i8 %conv5.i.i.i, ptr %maxstacksize.i.i.i, align 1
  %.pre.i.i = load i32, ptr %freereg.i.i7.i, align 4
  %.pre3.i.i = add nsw i32 %.pre.i.i, 1
  br label %luaK_exp2nextreg.exit

luaK_exp2nextreg.exit:                            ; preds = %freeexp.exit.i, %if.end.i.i.i
  %add.pre-phi.i.i = phi i32 [ %add.i.i.i, %freeexp.exit.i ], [ %.pre3.i.i, %if.end.i.i.i ]
  store i32 %add.pre-phi.i.i, ptr %freereg.i.i7.i, align 4
  %sub.i = add nsw i32 %add.pre-phi.i.i, -1
  call fastcc void @exp2reg(ptr noundef nonnull %0, ptr noundef nonnull %e, i32 noundef %sub.i)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @forbody(ptr noundef %ls, i32 noundef %base, i32 noundef %line, i32 noundef %nvars, i32 noundef %isnum) unnamed_addr #0 {
entry:
  %bl.i = alloca %struct.BlockCnt, align 8
  %bl = alloca %struct.BlockCnt, align 8
  %fs1 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 5
  %0 = load ptr, ptr %fs1, align 8
  %nactvar.i = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 13
  %1 = load i8, ptr %nactvar.i, align 2
  %conv2.i = add i8 %1, 3
  store i8 %conv2.i, ptr %nactvar.i, align 2
  %pc.i = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 6
  %.pre.i = load i32, ptr %pc.i, align 8
  br label %for.body.i

for.body.i:                                       ; preds = %for.body.i, %entry
  %nvars.addr.02.i = phi i32 [ 3, %entry ], [ %dec.i, %for.body.i ]
  %2 = load ptr, ptr %0, align 8
  %locvars.i = getelementptr inbounds %struct.Proto, ptr %2, i64 0, i32 7
  %3 = load ptr, ptr %locvars.i, align 8
  %4 = load i8, ptr %nactvar.i, align 2
  %conv5.i = zext i8 %4 to i32
  %sub.i = sub nsw i32 %conv5.i, %nvars.addr.02.i
  %idxprom.i = sext i32 %sub.i to i64
  %arrayidx.i = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 15, i64 %idxprom.i
  %5 = load i16, ptr %arrayidx.i, align 2
  %idxprom6.i = zext i16 %5 to i64
  %startpc.i = getelementptr inbounds %struct.LocVar, ptr %3, i64 %idxprom6.i, i32 1
  store i32 %.pre.i, ptr %startpc.i, align 8
  %dec.i = add nsw i32 %nvars.addr.02.i, -1
  %tobool.not.i = icmp eq i32 %dec.i, 0
  br i1 %tobool.not.i, label %adjustlocalvars.exit, label %for.body.i, !llvm.loop !100

adjustlocalvars.exit:                             ; preds = %for.body.i
  %t.i.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 3
  %6 = load i32, ptr %t.i.i, align 8
  %cmp.not.i.i = icmp eq i32 %6, 259
  br i1 %cmp.not.i.i, label %check.exit.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %adjustlocalvars.exit
  %L.i.i.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 6
  %7 = load ptr, ptr %L.i.i.i, align 8
  %call1.i.i.i = tail call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %7, ptr noundef nonnull @.str.164, ptr noundef nonnull @.str.65)
  %8 = load i32, ptr %t.i.i, align 8
  tail call fastcc void @luaX_lexerror(ptr noundef nonnull %ls, ptr noundef %call1.i.i.i, i32 noundef %8)
  unreachable

check.exit.i:                                     ; preds = %adjustlocalvars.exit
  %linenumber.i.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 1
  %9 = load i32, ptr %linenumber.i.i, align 4
  %lastline.i.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 2
  store i32 %9, ptr %lastline.i.i, align 8
  %lookahead.i.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 4
  %10 = load i32, ptr %lookahead.i.i, align 8
  %cmp.not.i2.i = icmp eq i32 %10, 287
  br i1 %cmp.not.i2.i, label %if.else.i.i, label %if.then.i3.i

if.then.i3.i:                                     ; preds = %check.exit.i
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t.i.i, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i.i, align 8
  br label %checknext.exit

if.else.i.i:                                      ; preds = %check.exit.i
  %seminfo.i.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 3, i32 1
  %call.i.i = tail call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i.i)
  store i32 %call.i.i, ptr %t.i.i, align 8
  br label %checknext.exit

checknext.exit:                                   ; preds = %if.then.i3.i, %if.else.i.i
  %tobool.not = icmp eq i32 %isnum, 0
  br i1 %tobool.not, label %cond.false, label %cond.true

cond.true:                                        ; preds = %checknext.exit
  %shl1.i = shl i32 %base, 6
  %or3.i = or i32 %shl1.i, 2147450912
  %ls.i = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  %11 = load ptr, ptr %ls.i, align 8
  %lastline.i = getelementptr inbounds %struct.LexState, ptr %11, i64 0, i32 2
  %12 = load i32, ptr %lastline.i, align 8
  %call.i = tail call fastcc i32 @luaK_code(ptr noundef nonnull %0, i32 noundef %or3.i, i32 noundef %12)
  br label %cond.end

cond.false:                                       ; preds = %checknext.exit
  %jpc1.i = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 8
  %13 = load i32, ptr %jpc1.i, align 8
  store i32 -1, ptr %jpc1.i, align 8
  %ls.i.i = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  %14 = load ptr, ptr %ls.i.i, align 8
  %lastline.i.i24 = getelementptr inbounds %struct.LexState, ptr %14, i64 0, i32 2
  %15 = load i32, ptr %lastline.i.i24, align 8
  %call.i.i25 = tail call fastcc i32 @luaK_code(ptr noundef nonnull %0, i32 noundef 2147450902, i32 noundef %15)
  %cmp.i.i = icmp eq i32 %13, -1
  br i1 %cmp.i.i, label %cond.end, label %if.else.i.i26

if.else.i.i26:                                    ; preds = %cond.false
  %cmp1.i.i = icmp eq i32 %call.i.i25, -1
  br i1 %cmp1.i.i, label %cond.end, label %while.cond.preheader.i.i

while.cond.preheader.i.i:                         ; preds = %if.else.i.i26
  %fs.val.i.i = load ptr, ptr %0, align 8
  %16 = getelementptr i8, ptr %fs.val.i.i, i64 24
  %fs.val.val.i.i = load ptr, ptr %16, align 8
  br label %while.cond.i.i

while.cond.i.i:                                   ; preds = %while.cond.i.i, %while.cond.preheader.i.i
  %list.0.i.i = phi i32 [ %add1.i.i.i, %while.cond.i.i ], [ %call.i.i25, %while.cond.preheader.i.i ]
  %idxprom.i.i.i = sext i32 %list.0.i.i to i64
  %arrayidx.i.i.i = getelementptr inbounds i32, ptr %fs.val.val.i.i, i64 %idxprom.i.i.i
  %17 = load i32, ptr %arrayidx.i.i.i, align 4
  %shr.i.i.i = lshr i32 %17, 14
  %sub.i.i.i = add nsw i32 %shr.i.i.i, -131071
  %cmp.i.i.i = icmp eq i32 %sub.i.i.i, -1
  %add.i.i.i = add nuw nsw i32 %list.0.i.i, 1
  %add1.i.i.i = add nsw i32 %add.i.i.i, %sub.i.i.i
  %cmp4.not12.i.i = icmp eq i32 %add1.i.i.i, -1
  %cmp4.not.i.i = select i1 %cmp.i.i.i, i1 true, i1 %cmp4.not12.i.i
  br i1 %cmp4.not.i.i, label %while.end.i.i, label %while.cond.i.i, !llvm.loop !94

while.end.i.i:                                    ; preds = %while.cond.i.i
  %add.neg.i.i.i = xor i32 %list.0.i.i, -1
  %sub.i7.i.i = add i32 %13, %add.neg.i.i.i
  %18 = tail call i32 @llvm.abs.i32(i32 %sub.i7.i.i, i1 true)
  %cmp.i8.i.i = icmp ugt i32 %18, 131071
  br i1 %cmp.i8.i.i, label %if.then.i.i.i, label %fixjump.exit.i.i

if.then.i.i.i:                                    ; preds = %while.end.i.i
  %19 = load ptr, ptr %ls.i.i, align 8
  %t.i.i.i.i = getelementptr inbounds %struct.LexState, ptr %19, i64 0, i32 3
  %20 = load i32, ptr %t.i.i.i.i, align 8
  tail call fastcc void @luaX_lexerror(ptr noundef %19, ptr noundef nonnull @.str.148, i32 noundef %20)
  unreachable

fixjump.exit.i.i:                                 ; preds = %while.end.i.i
  %arrayidx.i.i.i.le = getelementptr inbounds i32, ptr %fs.val.val.i.i, i64 %idxprom.i.i.i
  %and.i.i.i = and i32 %17, 16383
  %add1.i11.i.i = shl i32 %sub.i7.i.i, 14
  %shl.i.i.i = add i32 %add1.i11.i.i, 2147467264
  %or.i.i.i = or disjoint i32 %shl.i.i.i, %and.i.i.i
  store i32 %or.i.i.i, ptr %arrayidx.i.i.i.le, align 4
  br label %cond.end

cond.end:                                         ; preds = %fixjump.exit.i.i, %if.else.i.i26, %cond.false, %cond.true
  %cond = phi i32 [ %call.i, %cond.true ], [ %call.i.i25, %cond.false ], [ %call.i.i25, %fixjump.exit.i.i ], [ %13, %if.else.i.i26 ]
  %breaklist.i = getelementptr inbounds %struct.BlockCnt, ptr %bl, i64 0, i32 1
  store i32 -1, ptr %breaklist.i, align 8
  %isbreakable1.i = getelementptr inbounds %struct.BlockCnt, ptr %bl, i64 0, i32 4
  store i8 0, ptr %isbreakable1.i, align 2
  %21 = load i8, ptr %nactvar.i, align 2
  %nactvar2.i = getelementptr inbounds %struct.BlockCnt, ptr %bl, i64 0, i32 2
  store i8 %21, ptr %nactvar2.i, align 4
  %upval.i = getelementptr inbounds %struct.BlockCnt, ptr %bl, i64 0, i32 3
  store i8 0, ptr %upval.i, align 1
  %bl3.i = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 5
  %22 = load ptr, ptr %bl3.i, align 8
  store ptr %22, ptr %bl, align 8
  store ptr %bl, ptr %bl3.i, align 8
  %ls.val = load ptr, ptr %fs1, align 8
  %nactvar.i28 = getelementptr inbounds %struct.FuncState, ptr %ls.val, i64 0, i32 13
  %23 = load i8, ptr %nactvar.i28, align 2
  %24 = trunc i32 %nvars to i8
  %conv2.i29 = add i8 %23, %24
  store i8 %conv2.i29, ptr %nactvar.i28, align 2
  %tobool.not1.i = icmp eq i32 %nvars, 0
  br i1 %tobool.not1.i, label %adjustlocalvars.exit43, label %for.body.lr.ph.i

for.body.lr.ph.i:                                 ; preds = %cond.end
  %pc.i30 = getelementptr inbounds %struct.FuncState, ptr %ls.val, i64 0, i32 6
  %.pre.i31 = load i32, ptr %pc.i30, align 8
  br label %for.body.i32

for.body.i32:                                     ; preds = %for.body.i32, %for.body.lr.ph.i
  %nvars.addr.02.i33 = phi i32 [ %nvars, %for.body.lr.ph.i ], [ %dec.i41, %for.body.i32 ]
  %25 = load ptr, ptr %ls.val, align 8
  %locvars.i34 = getelementptr inbounds %struct.Proto, ptr %25, i64 0, i32 7
  %26 = load ptr, ptr %locvars.i34, align 8
  %27 = load i8, ptr %nactvar.i28, align 2
  %conv5.i35 = zext i8 %27 to i32
  %sub.i36 = sub nsw i32 %conv5.i35, %nvars.addr.02.i33
  %idxprom.i37 = sext i32 %sub.i36 to i64
  %arrayidx.i38 = getelementptr inbounds %struct.FuncState, ptr %ls.val, i64 0, i32 15, i64 %idxprom.i37
  %28 = load i16, ptr %arrayidx.i38, align 2
  %idxprom6.i39 = zext i16 %28 to i64
  %startpc.i40 = getelementptr inbounds %struct.LocVar, ptr %26, i64 %idxprom6.i39, i32 1
  store i32 %.pre.i31, ptr %startpc.i40, align 8
  %dec.i41 = add nsw i32 %nvars.addr.02.i33, -1
  %tobool.not.i42 = icmp eq i32 %dec.i41, 0
  br i1 %tobool.not.i42, label %adjustlocalvars.exit43, label %for.body.i32, !llvm.loop !100

adjustlocalvars.exit43:                           ; preds = %for.body.i32, %cond.end
  %freereg.i.i = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 9
  %29 = load i32, ptr %freereg.i.i, align 4
  %add.i.i = add nsw i32 %29, %nvars
  %30 = load ptr, ptr %0, align 8
  %maxstacksize.i.i = getelementptr inbounds %struct.Proto, ptr %30, i64 0, i32 22
  %31 = load i8, ptr %maxstacksize.i.i, align 1
  %conv.i.i = zext i8 %31 to i32
  %cmp.i.i44 = icmp sgt i32 %add.i.i, %conv.i.i
  br i1 %cmp.i.i44, label %if.then.i.i45, label %luaK_reserveregs.exit

if.then.i.i45:                                    ; preds = %adjustlocalvars.exit43
  %cmp2.i.i = icmp sgt i32 %add.i.i, 249
  br i1 %cmp2.i.i, label %if.then4.i.i, label %if.end.i.i

if.then4.i.i:                                     ; preds = %if.then.i.i45
  %ls.i.i47 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  %32 = load ptr, ptr %ls.i.i47, align 8
  %t.i.i.i = getelementptr inbounds %struct.LexState, ptr %32, i64 0, i32 3
  %33 = load i32, ptr %t.i.i.i, align 8
  call fastcc void @luaX_lexerror(ptr noundef %32, ptr noundef nonnull @.str.150, i32 noundef %33)
  unreachable

if.end.i.i:                                       ; preds = %if.then.i.i45
  %conv5.i.i = trunc i32 %add.i.i to i8
  store i8 %conv5.i.i, ptr %maxstacksize.i.i, align 1
  %.pre.i46 = load i32, ptr %freereg.i.i, align 4
  %.pre3.i = add nsw i32 %.pre.i46, %nvars
  br label %luaK_reserveregs.exit

luaK_reserveregs.exit:                            ; preds = %adjustlocalvars.exit43, %if.end.i.i
  %add.pre-phi.i = phi i32 [ %add.i.i, %adjustlocalvars.exit43 ], [ %.pre3.i, %if.end.i.i ]
  store i32 %add.pre-phi.i, ptr %freereg.i.i, align 4
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %bl.i)
  %34 = load ptr, ptr %fs1, align 8
  %breaklist.i126 = getelementptr inbounds %struct.BlockCnt, ptr %bl.i, i64 0, i32 1
  store i32 -1, ptr %breaklist.i126, align 8
  %isbreakable1.i127 = getelementptr inbounds %struct.BlockCnt, ptr %bl.i, i64 0, i32 4
  store i8 0, ptr %isbreakable1.i127, align 2
  %nactvar.i128 = getelementptr inbounds %struct.FuncState, ptr %34, i64 0, i32 13
  %35 = load i8, ptr %nactvar.i128, align 2
  %nactvar2.i129 = getelementptr inbounds %struct.BlockCnt, ptr %bl.i, i64 0, i32 2
  store i8 %35, ptr %nactvar2.i129, align 4
  %upval.i130 = getelementptr inbounds %struct.BlockCnt, ptr %bl.i, i64 0, i32 3
  store i8 0, ptr %upval.i130, align 1
  %bl3.i131 = getelementptr inbounds %struct.FuncState, ptr %34, i64 0, i32 5
  %36 = load ptr, ptr %bl3.i131, align 8
  store ptr %36, ptr %bl.i, align 8
  store ptr %bl.i, ptr %bl3.i131, align 8
  call fastcc void @chunk(ptr noundef %ls)
  call fastcc void @leaveblock(ptr noundef %34)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %bl.i)
  call fastcc void @leaveblock(ptr noundef nonnull %0)
  %37 = load i32, ptr %pc.i, align 8
  %lasttarget.i.i = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 7
  store i32 %37, ptr %lasttarget.i.i, align 4
  %jpc.i = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 8
  %cmp.i.i48 = icmp eq i32 %cond, -1
  br i1 %cmp.i.i48, label %luaK_patchtohere.exit, label %if.else.i.i49

if.else.i.i49:                                    ; preds = %luaK_reserveregs.exit
  %38 = load i32, ptr %jpc.i, align 4
  %cmp1.i.i50 = icmp eq i32 %38, -1
  br i1 %cmp1.i.i50, label %if.then2.i.i, label %while.cond.preheader.i.i51

while.cond.preheader.i.i51:                       ; preds = %if.else.i.i49
  %fs.val.i.i52 = load ptr, ptr %0, align 8
  %39 = getelementptr i8, ptr %fs.val.i.i52, i64 24
  %fs.val.val.i.i53 = load ptr, ptr %39, align 8
  br label %while.cond.i.i54

if.then2.i.i:                                     ; preds = %if.else.i.i49
  store i32 %cond, ptr %jpc.i, align 4
  br label %luaK_patchtohere.exit

while.cond.i.i54:                                 ; preds = %while.cond.i.i54, %while.cond.preheader.i.i51
  %list.0.i.i55 = phi i32 [ %add1.i.i.i62, %while.cond.i.i54 ], [ %38, %while.cond.preheader.i.i51 ]
  %idxprom.i.i.i56 = sext i32 %list.0.i.i55 to i64
  %arrayidx.i.i.i57 = getelementptr inbounds i32, ptr %fs.val.val.i.i53, i64 %idxprom.i.i.i56
  %40 = load i32, ptr %arrayidx.i.i.i57, align 4
  %shr.i.i.i58 = lshr i32 %40, 14
  %sub.i.i.i59 = add nsw i32 %shr.i.i.i58, -131071
  %cmp.i.i.i60 = icmp eq i32 %sub.i.i.i59, -1
  %add.i.i.i61 = add nuw nsw i32 %list.0.i.i55, 1
  %add1.i.i.i62 = add nsw i32 %add.i.i.i61, %sub.i.i.i59
  %cmp4.not12.i.i63 = icmp eq i32 %add1.i.i.i62, -1
  %cmp4.not.i.i64 = select i1 %cmp.i.i.i60, i1 true, i1 %cmp4.not12.i.i63
  br i1 %cmp4.not.i.i64, label %while.end.i.i65, label %while.cond.i.i54, !llvm.loop !94

while.end.i.i65:                                  ; preds = %while.cond.i.i54
  %add.neg.i.i.i66 = xor i32 %list.0.i.i55, -1
  %sub.i7.i.i67 = add i32 %cond, %add.neg.i.i.i66
  %41 = call i32 @llvm.abs.i32(i32 %sub.i7.i.i67, i1 true)
  %cmp.i8.i.i68 = icmp ugt i32 %41, 131071
  br i1 %cmp.i8.i.i68, label %if.then.i.i.i75, label %fixjump.exit.i.i69

if.then.i.i.i75:                                  ; preds = %while.end.i.i65
  %ls.i.i.i = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  %42 = load ptr, ptr %ls.i.i.i, align 8
  %t.i.i.i.i76 = getelementptr inbounds %struct.LexState, ptr %42, i64 0, i32 3
  %43 = load i32, ptr %t.i.i.i.i76, align 8
  call fastcc void @luaX_lexerror(ptr noundef %42, ptr noundef nonnull @.str.148, i32 noundef %43)
  unreachable

fixjump.exit.i.i69:                               ; preds = %while.end.i.i65
  %arrayidx.i.i.i57.le = getelementptr inbounds i32, ptr %fs.val.val.i.i53, i64 %idxprom.i.i.i56
  %and.i.i.i71 = and i32 %40, 16383
  %add1.i11.i.i72 = shl i32 %sub.i7.i.i67, 14
  %shl.i.i.i73 = add i32 %add1.i11.i.i72, 2147467264
  %or.i.i.i74 = or disjoint i32 %shl.i.i.i73, %and.i.i.i71
  store i32 %or.i.i.i74, ptr %arrayidx.i.i.i57.le, align 4
  br label %luaK_patchtohere.exit

luaK_patchtohere.exit:                            ; preds = %luaK_reserveregs.exit, %if.then2.i.i, %fixjump.exit.i.i69
  %shl1.i83 = shl i32 %base, 6
  br i1 %tobool.not, label %cond.false12, label %cond.end8

cond.end8:                                        ; preds = %luaK_patchtohere.exit
  %or3.i79 = or i32 %shl1.i83, 2147450911
  %ls.i80 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  %44 = load ptr, ptr %ls.i80, align 8
  %lastline.i81 = getelementptr inbounds %struct.LexState, ptr %44, i64 0, i32 2
  %45 = load i32, ptr %lastline.i81, align 8
  %call.i82 = call fastcc i32 @luaK_code(ptr noundef nonnull %0, i32 noundef %or3.i79, i32 noundef %45)
  %.val = load ptr, ptr %0, align 8
  %.val23 = load i32, ptr %pc.i, align 8
  %46 = getelementptr i8, ptr %.val, i64 40
  %.val.val = load ptr, ptr %46, align 8
  %47 = sext i32 %.val23 to i64
  %48 = getelementptr i32, ptr %.val.val, i64 %47
  %arrayidx.i88 = getelementptr i32, ptr %48, i64 -1
  store i32 %line, ptr %arrayidx.i88, align 4
  br label %cond.end14

cond.false12:                                     ; preds = %luaK_patchtohere.exit
  %shl4.i = shl i32 %nvars, 14
  %or.i84 = or i32 %shl1.i83, %shl4.i
  %or5.i = or disjoint i32 %or.i84, 33
  %ls.i85 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  %49 = load ptr, ptr %ls.i85, align 8
  %lastline.i86 = getelementptr inbounds %struct.LexState, ptr %49, i64 0, i32 2
  %50 = load i32, ptr %lastline.i86, align 8
  %call.i87 = call fastcc i32 @luaK_code(ptr noundef nonnull %0, i32 noundef %or5.i, i32 noundef %50)
  %.val133 = load ptr, ptr %0, align 8
  %.val23134 = load i32, ptr %pc.i, align 8
  %51 = getelementptr i8, ptr %.val133, i64 40
  %.val.val135 = load ptr, ptr %51, align 8
  %52 = sext i32 %.val23134 to i64
  %53 = getelementptr i32, ptr %.val.val135, i64 %52
  %arrayidx.i88136 = getelementptr i32, ptr %53, i64 -1
  store i32 %line, ptr %arrayidx.i88136, align 4
  %54 = load i32, ptr %jpc.i, align 8
  store i32 -1, ptr %jpc.i, align 8
  %55 = load ptr, ptr %ls.i85, align 8
  %lastline.i.i91 = getelementptr inbounds %struct.LexState, ptr %55, i64 0, i32 2
  %56 = load i32, ptr %lastline.i.i91, align 8
  %call.i.i92 = call fastcc i32 @luaK_code(ptr noundef nonnull %0, i32 noundef 2147450902, i32 noundef %56)
  %cmp.i.i93 = icmp eq i32 %54, -1
  br i1 %cmp.i.i93, label %cond.end14, label %if.else.i.i94

if.else.i.i94:                                    ; preds = %cond.false12
  %cmp1.i.i95 = icmp eq i32 %call.i.i92, -1
  br i1 %cmp1.i.i95, label %cond.end14, label %while.cond.preheader.i.i96

while.cond.preheader.i.i96:                       ; preds = %if.else.i.i94
  %fs.val.i.i97 = load ptr, ptr %0, align 8
  %57 = getelementptr i8, ptr %fs.val.i.i97, i64 24
  %fs.val.val.i.i98 = load ptr, ptr %57, align 8
  br label %while.cond.i.i99

while.cond.i.i99:                                 ; preds = %while.cond.i.i99, %while.cond.preheader.i.i96
  %list.0.i.i100 = phi i32 [ %add1.i.i.i107, %while.cond.i.i99 ], [ %call.i.i92, %while.cond.preheader.i.i96 ]
  %idxprom.i.i.i101 = sext i32 %list.0.i.i100 to i64
  %arrayidx.i.i.i102 = getelementptr inbounds i32, ptr %fs.val.val.i.i98, i64 %idxprom.i.i.i101
  %58 = load i32, ptr %arrayidx.i.i.i102, align 4
  %shr.i.i.i103 = lshr i32 %58, 14
  %sub.i.i.i104 = add nsw i32 %shr.i.i.i103, -131071
  %cmp.i.i.i105 = icmp eq i32 %sub.i.i.i104, -1
  %add.i.i.i106 = add nuw nsw i32 %list.0.i.i100, 1
  %add1.i.i.i107 = add nsw i32 %add.i.i.i106, %sub.i.i.i104
  %cmp4.not12.i.i108 = icmp eq i32 %add1.i.i.i107, -1
  %cmp4.not.i.i109 = select i1 %cmp.i.i.i105, i1 true, i1 %cmp4.not12.i.i108
  br i1 %cmp4.not.i.i109, label %while.end.i.i110, label %while.cond.i.i99, !llvm.loop !94

while.end.i.i110:                                 ; preds = %while.cond.i.i99
  %add.neg.i.i.i111 = xor i32 %list.0.i.i100, -1
  %sub.i7.i.i112 = add i32 %54, %add.neg.i.i.i111
  %59 = call i32 @llvm.abs.i32(i32 %sub.i7.i.i112, i1 true)
  %cmp.i8.i.i113 = icmp ugt i32 %59, 131071
  br i1 %cmp.i8.i.i113, label %if.then.i.i.i121, label %fixjump.exit.i.i114

if.then.i.i.i121:                                 ; preds = %while.end.i.i110
  %60 = load ptr, ptr %ls.i85, align 8
  %t.i.i.i.i122 = getelementptr inbounds %struct.LexState, ptr %60, i64 0, i32 3
  %61 = load i32, ptr %t.i.i.i.i122, align 8
  call fastcc void @luaX_lexerror(ptr noundef %60, ptr noundef nonnull @.str.148, i32 noundef %61)
  unreachable

fixjump.exit.i.i114:                              ; preds = %while.end.i.i110
  %arrayidx.i.i.i102.le = getelementptr inbounds i32, ptr %fs.val.val.i.i98, i64 %idxprom.i.i.i101
  %and.i.i.i116 = and i32 %58, 16383
  %add1.i11.i.i117 = shl i32 %sub.i7.i.i112, 14
  %shl.i.i.i118 = add i32 %add1.i11.i.i117, 2147467264
  %or.i.i.i119 = or disjoint i32 %shl.i.i.i118, %and.i.i.i116
  store i32 %or.i.i.i119, ptr %arrayidx.i.i.i102.le, align 4
  br label %cond.end14

cond.end14:                                       ; preds = %fixjump.exit.i.i114, %if.else.i.i94, %cond.false12, %cond.end8
  %cond15 = phi i32 [ %call.i82, %cond.end8 ], [ %call.i.i92, %cond.false12 ], [ %call.i.i92, %fixjump.exit.i.i114 ], [ %54, %if.else.i.i94 ]
  %add = add nsw i32 %cond, 1
  %62 = load i32, ptr %pc.i, align 8
  %cmp.i = icmp eq i32 %62, %add
  br i1 %cmp.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %cond.end14
  store i32 %add, ptr %lasttarget.i.i, align 4
  %cmp.i.i.i125 = icmp eq i32 %cond15, -1
  br i1 %cmp.i.i.i125, label %luaK_patchlist.exit, label %if.else.i.i.i

if.else.i.i.i:                                    ; preds = %if.then.i
  %63 = load i32, ptr %jpc.i, align 4
  %cmp1.i.i.i = icmp eq i32 %63, -1
  br i1 %cmp1.i.i.i, label %if.then2.i.i.i, label %while.cond.preheader.i.i.i

while.cond.preheader.i.i.i:                       ; preds = %if.else.i.i.i
  %fs.val.i.i.i = load ptr, ptr %0, align 8
  %64 = getelementptr i8, ptr %fs.val.i.i.i, i64 24
  %fs.val.val.i.i.i = load ptr, ptr %64, align 8
  br label %while.cond.i.i.i

if.then2.i.i.i:                                   ; preds = %if.else.i.i.i
  store i32 %cond15, ptr %jpc.i, align 4
  br label %luaK_patchlist.exit

while.cond.i.i.i:                                 ; preds = %while.cond.i.i.i, %while.cond.preheader.i.i.i
  %list.0.i.i.i = phi i32 [ %add1.i.i.i.i, %while.cond.i.i.i ], [ %63, %while.cond.preheader.i.i.i ]
  %idxprom.i.i.i.i = sext i32 %list.0.i.i.i to i64
  %arrayidx.i.i.i.i = getelementptr inbounds i32, ptr %fs.val.val.i.i.i, i64 %idxprom.i.i.i.i
  %65 = load i32, ptr %arrayidx.i.i.i.i, align 4
  %shr.i.i.i.i = lshr i32 %65, 14
  %sub.i.i.i.i = add nsw i32 %shr.i.i.i.i, -131071
  %cmp.i.i.i.i = icmp eq i32 %sub.i.i.i.i, -1
  %add.i.i.i.i = add nuw nsw i32 %list.0.i.i.i, 1
  %add1.i.i.i.i = add nsw i32 %add.i.i.i.i, %sub.i.i.i.i
  %cmp4.not12.i.i.i = icmp eq i32 %add1.i.i.i.i, -1
  %cmp4.not.i.i.i = select i1 %cmp.i.i.i.i, i1 true, i1 %cmp4.not12.i.i.i
  br i1 %cmp4.not.i.i.i, label %while.end.i.i.i, label %while.cond.i.i.i, !llvm.loop !94

while.end.i.i.i:                                  ; preds = %while.cond.i.i.i
  %add.neg.i.i.i.i = xor i32 %list.0.i.i.i, -1
  %sub.i7.i.i.i = add i32 %cond15, %add.neg.i.i.i.i
  %66 = call i32 @llvm.abs.i32(i32 %sub.i7.i.i.i, i1 true)
  %cmp.i8.i.i.i = icmp ugt i32 %66, 131071
  br i1 %cmp.i8.i.i.i, label %if.then.i.i.i.i, label %fixjump.exit.i.i.i

if.then.i.i.i.i:                                  ; preds = %while.end.i.i.i
  %ls.i.i.i.i = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  %67 = load ptr, ptr %ls.i.i.i.i, align 8
  %t.i.i.i.i.i = getelementptr inbounds %struct.LexState, ptr %67, i64 0, i32 3
  %68 = load i32, ptr %t.i.i.i.i.i, align 8
  call fastcc void @luaX_lexerror(ptr noundef %67, ptr noundef nonnull @.str.148, i32 noundef %68)
  unreachable

fixjump.exit.i.i.i:                               ; preds = %while.end.i.i.i
  %arrayidx.i.i.i.i.le = getelementptr inbounds i32, ptr %fs.val.val.i.i.i, i64 %idxprom.i.i.i.i
  %and.i.i.i.i = and i32 %65, 16383
  %add1.i11.i.i.i = shl i32 %sub.i7.i.i.i, 14
  %shl.i.i.i.i = add i32 %add1.i11.i.i.i, 2147467264
  %or.i.i.i.i = or disjoint i32 %shl.i.i.i.i, %and.i.i.i.i
  store i32 %or.i.i.i.i, ptr %arrayidx.i.i.i.i.le, align 4
  br label %luaK_patchlist.exit

if.else.i:                                        ; preds = %cond.end14
  call fastcc void @patchlistaux(ptr noundef nonnull %0, i32 noundef %cond15, i32 noundef %add, i32 noundef 255, i32 noundef %add)
  br label %luaK_patchlist.exit

luaK_patchlist.exit:                              ; preds = %if.then.i, %if.then2.i.i.i, %fixjump.exit.i.i.i, %if.else.i
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @adjust_assign(ptr nocapture %ls.48.val, i32 noundef %nvars, i32 noundef %nexps, ptr nocapture noundef %e) unnamed_addr #0 {
entry:
  %sub = sub nsw i32 %nvars, %nexps
  %0 = load i32, ptr %e, align 8
  switch i32 %0, label %if.then12 [
    i32 13, label %if.then
    i32 14, label %if.then
    i32 0, label %if.end13
  ]

if.then:                                          ; preds = %entry, %entry
  %1 = tail call i32 @llvm.smax.i32(i32 %sub, i32 -1)
  %spec.store.select = add nsw i32 %1, 1
  switch i32 %0, label %luaK_setreturns.exit [
    i32 13, label %if.then.i
    i32 14, label %if.then10.i
  ]

if.then.i:                                        ; preds = %if.then
  %2 = load ptr, ptr %ls.48.val, align 8
  %code.i = getelementptr inbounds %struct.Proto, ptr %2, i64 0, i32 4
  %3 = load ptr, ptr %code.i, align 8
  %u.i = getelementptr inbounds %struct.expdesc, ptr %e, i64 0, i32 1
  %4 = load i32, ptr %u.i, align 8
  %idxprom.i = sext i32 %4 to i64
  %arrayidx.i = getelementptr inbounds i32, ptr %3, i64 %idxprom.i
  %5 = load i32, ptr %arrayidx.i, align 4
  %and.i = and i32 %5, -8372225
  %add.i = shl i32 %spec.store.select, 14
  %shl.i = add i32 %add.i, 16384
  %and1.i = and i32 %shl.i, 8372224
  %or.i = or disjoint i32 %and.i, %and1.i
  store i32 %or.i, ptr %arrayidx.i, align 4
  br label %luaK_setreturns.exit

if.then10.i:                                      ; preds = %if.then
  %6 = load ptr, ptr %ls.48.val, align 8
  %code12.i = getelementptr inbounds %struct.Proto, ptr %6, i64 0, i32 4
  %7 = load ptr, ptr %code12.i, align 8
  %u13.i = getelementptr inbounds %struct.expdesc, ptr %e, i64 0, i32 1
  %8 = load i32, ptr %u13.i, align 8
  %idxprom15.i = sext i32 %8 to i64
  %arrayidx16.i = getelementptr inbounds i32, ptr %7, i64 %idxprom15.i
  %9 = load i32, ptr %arrayidx16.i, align 4
  %and17.i = and i32 %9, 8388607
  %add18.i = shl i32 %spec.store.select, 23
  %shl19.i = add i32 %add18.i, 8388608
  %or21.i = or disjoint i32 %and17.i, %shl19.i
  store i32 %or21.i, ptr %arrayidx16.i, align 4
  %10 = load ptr, ptr %ls.48.val, align 8
  %code29.i = getelementptr inbounds %struct.Proto, ptr %10, i64 0, i32 4
  %11 = load ptr, ptr %code29.i, align 8
  %12 = load i32, ptr %u13.i, align 8
  %idxprom32.i = sext i32 %12 to i64
  %arrayidx33.i = getelementptr inbounds i32, ptr %11, i64 %idxprom32.i
  %13 = load i32, ptr %arrayidx33.i, align 4
  %and34.i = and i32 %13, -16321
  %freereg.i = getelementptr inbounds %struct.FuncState, ptr %ls.48.val, i64 0, i32 9
  %14 = load i32, ptr %freereg.i, align 4
  %shl35.i = shl i32 %14, 6
  %and36.i = and i32 %shl35.i, 16320
  %or37.i = or disjoint i32 %and36.i, %and34.i
  store i32 %or37.i, ptr %arrayidx33.i, align 4
  %15 = load i32, ptr %freereg.i, align 4
  %add.i.i.i = add nsw i32 %15, 1
  %16 = load ptr, ptr %ls.48.val, align 8
  %maxstacksize.i.i.i = getelementptr inbounds %struct.Proto, ptr %16, i64 0, i32 22
  %17 = load i8, ptr %maxstacksize.i.i.i, align 1
  %conv.i.i.i = zext i8 %17 to i32
  %cmp.i.i.not.i = icmp slt i32 %15, %conv.i.i.i
  br i1 %cmp.i.i.not.i, label %luaK_reserveregs.exit.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %if.then10.i
  %cmp2.i.i.i = icmp sgt i32 %15, 248
  br i1 %cmp2.i.i.i, label %if.then4.i.i.i, label %if.end.i.i.i

if.then4.i.i.i:                                   ; preds = %if.then.i.i.i
  %ls.i.i.i = getelementptr inbounds %struct.FuncState, ptr %ls.48.val, i64 0, i32 3
  %18 = load ptr, ptr %ls.i.i.i, align 8
  %t.i.i.i.i = getelementptr inbounds %struct.LexState, ptr %18, i64 0, i32 3
  %19 = load i32, ptr %t.i.i.i.i, align 8
  tail call fastcc void @luaX_lexerror(ptr noundef %18, ptr noundef nonnull @.str.150, i32 noundef %19)
  unreachable

if.end.i.i.i:                                     ; preds = %if.then.i.i.i
  %conv5.i.i.i = trunc i32 %add.i.i.i to i8
  store i8 %conv5.i.i.i, ptr %maxstacksize.i.i.i, align 1
  %.pre.i.i = load i32, ptr %freereg.i, align 4
  %.pre3.i.i = add nsw i32 %.pre.i.i, 1
  br label %luaK_reserveregs.exit.i

luaK_reserveregs.exit.i:                          ; preds = %if.end.i.i.i, %if.then10.i
  %add.pre-phi.i.i = phi i32 [ %add.i.i.i, %if.then10.i ], [ %.pre3.i.i, %if.end.i.i.i ]
  store i32 %add.pre-phi.i.i, ptr %freereg.i, align 4
  br label %luaK_setreturns.exit

luaK_setreturns.exit:                             ; preds = %if.then, %if.then.i, %luaK_reserveregs.exit.i
  %cmp6 = icmp sgt i32 %sub, 0
  br i1 %cmp6, label %if.then7, label %if.end17

if.then7:                                         ; preds = %luaK_setreturns.exit
  %freereg.i.i = getelementptr inbounds %struct.FuncState, ptr %ls.48.val, i64 0, i32 9
  %20 = load i32, ptr %freereg.i.i, align 4
  %add.i.i = add nsw i32 %20, %1
  %21 = load ptr, ptr %ls.48.val, align 8
  %maxstacksize.i.i = getelementptr inbounds %struct.Proto, ptr %21, i64 0, i32 22
  %22 = load i8, ptr %maxstacksize.i.i, align 1
  %conv.i.i = zext i8 %22 to i32
  %cmp.i.i = icmp sgt i32 %add.i.i, %conv.i.i
  br i1 %cmp.i.i, label %if.then.i.i, label %luaK_reserveregs.exit

if.then.i.i:                                      ; preds = %if.then7
  %cmp2.i.i = icmp sgt i32 %add.i.i, 249
  br i1 %cmp2.i.i, label %if.then4.i.i, label %if.end.i.i

if.then4.i.i:                                     ; preds = %if.then.i.i
  %ls.i.i = getelementptr inbounds %struct.FuncState, ptr %ls.48.val, i64 0, i32 3
  %23 = load ptr, ptr %ls.i.i, align 8
  %t.i.i.i = getelementptr inbounds %struct.LexState, ptr %23, i64 0, i32 3
  %24 = load i32, ptr %t.i.i.i, align 8
  tail call fastcc void @luaX_lexerror(ptr noundef %23, ptr noundef nonnull @.str.150, i32 noundef %24)
  unreachable

if.end.i.i:                                       ; preds = %if.then.i.i
  %conv5.i.i = trunc i32 %add.i.i to i8
  store i8 %conv5.i.i, ptr %maxstacksize.i.i, align 1
  %.pre.i = load i32, ptr %freereg.i.i, align 4
  %.pre3.i = add nsw i32 %.pre.i, %1
  br label %luaK_reserveregs.exit

luaK_reserveregs.exit:                            ; preds = %if.then7, %if.end.i.i
  %add.pre-phi.i = phi i32 [ %add.i.i, %if.then7 ], [ %.pre3.i, %if.end.i.i ]
  store i32 %add.pre-phi.i, ptr %freereg.i.i, align 4
  br label %if.end17

if.then12:                                        ; preds = %entry
  tail call fastcc void @luaK_dischargevars(ptr noundef %ls.48.val, ptr noundef nonnull %e)
  %25 = load i32, ptr %e, align 8
  %cmp.i.i17 = icmp eq i32 %25, 12
  br i1 %cmp.i.i17, label %if.then.i.i31, label %freeexp.exit.i

if.then.i.i31:                                    ; preds = %if.then12
  %u.i.i = getelementptr inbounds %struct.expdesc, ptr %e, i64 0, i32 1
  %26 = load i32, ptr %u.i.i, align 8
  %and.i.i.i = and i32 %26, 256
  %tobool.not.i.i.i = icmp eq i32 %and.i.i.i, 0
  br i1 %tobool.not.i.i.i, label %land.lhs.true.i.i.i, label %freeexp.exit.i

land.lhs.true.i.i.i:                              ; preds = %if.then.i.i31
  %nactvar.i.i.i = getelementptr inbounds %struct.FuncState, ptr %ls.48.val, i64 0, i32 13
  %27 = load i8, ptr %nactvar.i.i.i, align 2
  %conv.i.i.i32 = zext i8 %27 to i32
  %cmp.not.i.i.i = icmp slt i32 %26, %conv.i.i.i32
  br i1 %cmp.not.i.i.i, label %freeexp.exit.i, label %if.then.i.i.i33

if.then.i.i.i33:                                  ; preds = %land.lhs.true.i.i.i
  %freereg.i.i.i = getelementptr inbounds %struct.FuncState, ptr %ls.48.val, i64 0, i32 9
  %28 = load i32, ptr %freereg.i.i.i, align 4
  %dec.i.i.i = add nsw i32 %28, -1
  store i32 %dec.i.i.i, ptr %freereg.i.i.i, align 4
  br label %freeexp.exit.i

freeexp.exit.i:                                   ; preds = %if.then.i.i.i33, %land.lhs.true.i.i.i, %if.then.i.i31, %if.then12
  %freereg.i.i7.i = getelementptr inbounds %struct.FuncState, ptr %ls.48.val, i64 0, i32 9
  %29 = load i32, ptr %freereg.i.i7.i, align 4
  %add.i.i.i18 = add nsw i32 %29, 1
  %30 = load ptr, ptr %ls.48.val, align 8
  %maxstacksize.i.i.i19 = getelementptr inbounds %struct.Proto, ptr %30, i64 0, i32 22
  %31 = load i8, ptr %maxstacksize.i.i.i19, align 1
  %conv.i.i8.i = zext i8 %31 to i32
  %cmp.i.i.not.i20 = icmp slt i32 %29, %conv.i.i8.i
  br i1 %cmp.i.i.not.i20, label %luaK_exp2nextreg.exit, label %if.then.i.i9.i

if.then.i.i9.i:                                   ; preds = %freeexp.exit.i
  %cmp2.i.i.i21 = icmp sgt i32 %29, 248
  br i1 %cmp2.i.i.i21, label %if.then4.i.i.i28, label %if.end.i.i.i22

if.then4.i.i.i28:                                 ; preds = %if.then.i.i9.i
  %ls.i.i.i29 = getelementptr inbounds %struct.FuncState, ptr %ls.48.val, i64 0, i32 3
  %32 = load ptr, ptr %ls.i.i.i29, align 8
  %t.i.i.i.i30 = getelementptr inbounds %struct.LexState, ptr %32, i64 0, i32 3
  %33 = load i32, ptr %t.i.i.i.i30, align 8
  tail call fastcc void @luaX_lexerror(ptr noundef %32, ptr noundef nonnull @.str.150, i32 noundef %33)
  unreachable

if.end.i.i.i22:                                   ; preds = %if.then.i.i9.i
  %conv5.i.i.i23 = trunc i32 %add.i.i.i18 to i8
  store i8 %conv5.i.i.i23, ptr %maxstacksize.i.i.i19, align 1
  %.pre.i.i24 = load i32, ptr %freereg.i.i7.i, align 4
  %.pre3.i.i25 = add nsw i32 %.pre.i.i24, 1
  br label %luaK_exp2nextreg.exit

luaK_exp2nextreg.exit:                            ; preds = %freeexp.exit.i, %if.end.i.i.i22
  %add.pre-phi.i.i27 = phi i32 [ %add.i.i.i18, %freeexp.exit.i ], [ %.pre3.i.i25, %if.end.i.i.i22 ]
  store i32 %add.pre-phi.i.i27, ptr %freereg.i.i7.i, align 4
  %sub.i = add nsw i32 %add.pre-phi.i.i27, -1
  tail call fastcc void @exp2reg(ptr noundef nonnull %ls.48.val, ptr noundef nonnull %e, i32 noundef %sub.i)
  br label %if.end13

if.end13:                                         ; preds = %entry, %luaK_exp2nextreg.exit
  %cmp14 = icmp sgt i32 %sub, 0
  br i1 %cmp14, label %if.then15, label %if.end17

if.then15:                                        ; preds = %if.end13
  %freereg = getelementptr inbounds %struct.FuncState, ptr %ls.48.val, i64 0, i32 9
  %34 = load i32, ptr %freereg, align 4
  %add.i.i35 = add nsw i32 %34, %sub
  %35 = load ptr, ptr %ls.48.val, align 8
  %maxstacksize.i.i36 = getelementptr inbounds %struct.Proto, ptr %35, i64 0, i32 22
  %36 = load i8, ptr %maxstacksize.i.i36, align 1
  %conv.i.i37 = zext i8 %36 to i32
  %cmp.i.i38 = icmp sgt i32 %add.i.i35, %conv.i.i37
  br i1 %cmp.i.i38, label %if.then.i.i40, label %luaK_reserveregs.exit49

if.then.i.i40:                                    ; preds = %if.then15
  %cmp2.i.i41 = icmp sgt i32 %add.i.i35, 249
  br i1 %cmp2.i.i41, label %if.then4.i.i46, label %if.end.i.i42

if.then4.i.i46:                                   ; preds = %if.then.i.i40
  %ls.i.i47 = getelementptr inbounds %struct.FuncState, ptr %ls.48.val, i64 0, i32 3
  %37 = load ptr, ptr %ls.i.i47, align 8
  %t.i.i.i48 = getelementptr inbounds %struct.LexState, ptr %37, i64 0, i32 3
  %38 = load i32, ptr %t.i.i.i48, align 8
  tail call fastcc void @luaX_lexerror(ptr noundef %37, ptr noundef nonnull @.str.150, i32 noundef %38)
  unreachable

if.end.i.i42:                                     ; preds = %if.then.i.i40
  %conv5.i.i43 = trunc i32 %add.i.i35 to i8
  store i8 %conv5.i.i43, ptr %maxstacksize.i.i36, align 1
  %.pre.i44 = load i32, ptr %freereg, align 4
  %.pre3.i45 = add nsw i32 %.pre.i44, %sub
  br label %luaK_reserveregs.exit49

luaK_reserveregs.exit49:                          ; preds = %if.then15, %if.end.i.i42
  %add.pre-phi.i39 = phi i32 [ %add.i.i35, %if.then15 ], [ %.pre3.i45, %if.end.i.i42 ]
  store i32 %add.pre-phi.i39, ptr %freereg, align 4
  %pc.i = getelementptr inbounds %struct.FuncState, ptr %ls.48.val, i64 0, i32 6
  %39 = load i32, ptr %pc.i, align 8
  %lasttarget.i = getelementptr inbounds %struct.FuncState, ptr %ls.48.val, i64 0, i32 7
  %40 = load i32, ptr %lasttarget.i, align 4
  %cmp.i = icmp sgt i32 %39, %40
  br i1 %cmp.i, label %if.then.i51, label %if.end33.i

if.then.i51:                                      ; preds = %luaK_reserveregs.exit49
  %cmp2.i = icmp eq i32 %39, 0
  br i1 %cmp2.i, label %if.then3.i, label %if.else.i

if.then3.i:                                       ; preds = %if.then.i51
  %nactvar.i = getelementptr inbounds %struct.FuncState, ptr %ls.48.val, i64 0, i32 13
  %41 = load i8, ptr %nactvar.i, align 2
  %conv.i = zext i8 %41 to i32
  %cmp4.not.i = icmp slt i32 %34, %conv.i
  br i1 %cmp4.not.i, label %if.end33.i, label %if.end17

if.else.i:                                        ; preds = %if.then.i51
  %42 = load ptr, ptr %ls.48.val, align 8
  %code.i52 = getelementptr inbounds %struct.Proto, ptr %42, i64 0, i32 4
  %43 = load ptr, ptr %code.i52, align 8
  %44 = sext i32 %39 to i64
  %45 = getelementptr i32, ptr %43, i64 %44
  %arrayidx.i53 = getelementptr i32, ptr %45, i64 -1
  %46 = load i32, ptr %arrayidx.i53, align 4
  %and.i54 = and i32 %46, 63
  %cmp8.i = icmp eq i32 %and.i54, 3
  br i1 %cmp8.i, label %if.then10.i55, label %if.end33.i

if.then10.i55:                                    ; preds = %if.else.i
  %shr11.i = lshr i32 %46, 6
  %and12.i = and i32 %shr11.i, 255
  %shr13.i = lshr i32 %46, 23
  %cmp15.not.i = icmp sgt i32 %and12.i, %34
  %add.i56 = add nuw nsw i32 %shr13.i, 1
  %cmp17.not.i = icmp slt i32 %add.i56, %34
  %or.cond.i = select i1 %cmp15.not.i, i1 true, i1 %cmp17.not.i
  br i1 %or.cond.i, label %if.end33.i, label %if.then19.i

if.then19.i:                                      ; preds = %if.then10.i55
  %sub21.i = add nsw i32 %add.i.i35, -1
  %cmp22.i = icmp sgt i32 %sub21.i, %shr13.i
  br i1 %cmp22.i, label %if.then24.i, label %if.end17

if.then24.i:                                      ; preds = %if.then19.i
  %and25.i = and i32 %46, 8388547
  %shl.i57 = shl i32 %sub21.i, 23
  %or.i58 = or disjoint i32 %and25.i, %shl.i57
  store i32 %or.i58, ptr %arrayidx.i53, align 4
  br label %if.end17

if.end33.i:                                       ; preds = %if.then10.i55, %if.else.i, %if.then3.i, %luaK_reserveregs.exit49
  %shl1.i.i = shl i32 %34, 6
  %sub35.i = shl i32 %add.i.i35, 23
  %shl2.i.i = add i32 %sub35.i, -8388608
  %or.i.i = or i32 %shl1.i.i, %shl2.i.i
  %or3.i.i = or disjoint i32 %or.i.i, 3
  %ls.i.i50 = getelementptr inbounds %struct.FuncState, ptr %ls.48.val, i64 0, i32 3
  %47 = load ptr, ptr %ls.i.i50, align 8
  %lastline.i.i = getelementptr inbounds %struct.LexState, ptr %47, i64 0, i32 2
  %48 = load i32, ptr %lastline.i.i, align 8
  %call.i.i = tail call fastcc i32 @luaK_code(ptr noundef nonnull %ls.48.val, i32 noundef %or3.i.i, i32 noundef %48)
  br label %if.end17

if.end17:                                         ; preds = %if.end33.i, %if.then24.i, %if.then19.i, %if.then3.i, %if.end13, %luaK_setreturns.exit, %luaK_reserveregs.exit
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaK_storevar(ptr nocapture noundef %fs, ptr nocapture noundef readonly %var, ptr nocapture noundef %ex) unnamed_addr #0 {
entry:
  %0 = load i32, ptr %var, align 8
  switch i32 %0, label %sw.epilog [
    i32 6, label %sw.bb
    i32 7, label %sw.bb1
    i32 8, label %sw.bb5
    i32 9, label %sw.bb11
  ]

sw.bb:                                            ; preds = %entry
  %1 = load i32, ptr %ex, align 8
  %cmp.i = icmp eq i32 %1, 12
  br i1 %cmp.i, label %if.then.i, label %freeexp.exit

if.then.i:                                        ; preds = %sw.bb
  %u.i = getelementptr inbounds %struct.expdesc, ptr %ex, i64 0, i32 1
  %2 = load i32, ptr %u.i, align 8
  %and.i.i = and i32 %2, 256
  %tobool.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i.i, label %land.lhs.true.i.i, label %freeexp.exit

land.lhs.true.i.i:                                ; preds = %if.then.i
  %nactvar.i.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 13
  %3 = load i8, ptr %nactvar.i.i, align 2
  %conv.i.i = zext i8 %3 to i32
  %cmp.not.i.i = icmp slt i32 %2, %conv.i.i
  br i1 %cmp.not.i.i, label %freeexp.exit, label %if.then.i.i

if.then.i.i:                                      ; preds = %land.lhs.true.i.i
  %freereg.i.i = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 9
  %4 = load i32, ptr %freereg.i.i, align 4
  %dec.i.i = add nsw i32 %4, -1
  store i32 %dec.i.i, ptr %freereg.i.i, align 4
  br label %freeexp.exit

freeexp.exit:                                     ; preds = %sw.bb, %if.then.i, %land.lhs.true.i.i, %if.then.i.i
  %u = getelementptr inbounds %struct.expdesc, ptr %var, i64 0, i32 1
  %5 = load i32, ptr %u, align 8
  tail call fastcc void @exp2reg(ptr noundef %fs, ptr noundef nonnull %ex, i32 noundef %5)
  br label %return

sw.bb1:                                           ; preds = %entry
  %call = tail call fastcc i32 @luaK_exp2anyreg(ptr noundef %fs, ptr noundef %ex)
  %u2 = getelementptr inbounds %struct.expdesc, ptr %var, i64 0, i32 1
  %6 = load i32, ptr %u2, align 8
  %shl1.i = shl i32 %call, 6
  %shl2.i = shl i32 %6, 23
  %or.i = or i32 %shl1.i, %shl2.i
  %or3.i = or disjoint i32 %or.i, 8
  br label %sw.epilog.sink.split

sw.bb5:                                           ; preds = %entry
  %call7 = tail call fastcc i32 @luaK_exp2anyreg(ptr noundef %fs, ptr noundef %ex)
  %u8 = getelementptr inbounds %struct.expdesc, ptr %var, i64 0, i32 1
  %7 = load i32, ptr %u8, align 8
  %shl1.i19 = shl i32 %call7, 6
  %shl2.i21 = shl i32 %7, 14
  %or.i20 = or i32 %shl1.i19, %shl2.i21
  %or3.i22 = or disjoint i32 %or.i20, 7
  br label %sw.epilog.sink.split

sw.bb11:                                          ; preds = %entry
  %call13 = tail call fastcc i32 @luaK_exp2RK(ptr noundef %fs, ptr noundef %ex)
  %u14 = getelementptr inbounds %struct.expdesc, ptr %var, i64 0, i32 1
  %8 = load i32, ptr %u14, align 8
  %aux = getelementptr inbounds i8, ptr %var, i64 12
  %9 = load i32, ptr %aux, align 4
  %shl1.i26 = shl i32 %8, 6
  %shl2.i28 = shl i32 %9, 23
  %shl4.i = shl i32 %call13, 14
  %or.i27 = or i32 %shl4.i, %shl1.i26
  %or3.i29 = or i32 %or.i27, %shl2.i28
  %or5.i = or disjoint i32 %or3.i29, 9
  br label %sw.epilog.sink.split

sw.epilog.sink.split:                             ; preds = %sw.bb1, %sw.bb5, %sw.bb11
  %or5.i.sink = phi i32 [ %or5.i, %sw.bb11 ], [ %or3.i22, %sw.bb5 ], [ %or3.i, %sw.bb1 ]
  %ls.i30 = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 3
  %10 = load ptr, ptr %ls.i30, align 8
  %lastline.i31 = getelementptr inbounds %struct.LexState, ptr %10, i64 0, i32 2
  %11 = load i32, ptr %lastline.i31, align 8
  %call.i32 = tail call fastcc i32 @luaK_code(ptr noundef %fs, i32 noundef %or5.i.sink, i32 noundef %11)
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.epilog.sink.split, %entry
  %12 = load i32, ptr %ex, align 8
  %cmp.i33 = icmp eq i32 %12, 12
  br i1 %cmp.i33, label %if.then.i34, label %return

if.then.i34:                                      ; preds = %sw.epilog
  %u.i35 = getelementptr inbounds %struct.expdesc, ptr %ex, i64 0, i32 1
  %13 = load i32, ptr %u.i35, align 8
  %and.i.i36 = and i32 %13, 256
  %tobool.not.i.i37 = icmp eq i32 %and.i.i36, 0
  br i1 %tobool.not.i.i37, label %land.lhs.true.i.i38, label %return

land.lhs.true.i.i38:                              ; preds = %if.then.i34
  %nactvar.i.i39 = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 13
  %14 = load i8, ptr %nactvar.i.i39, align 2
  %conv.i.i40 = zext i8 %14 to i32
  %cmp.not.i.i41 = icmp slt i32 %13, %conv.i.i40
  br i1 %cmp.not.i.i41, label %return, label %if.then.i.i42

if.then.i.i42:                                    ; preds = %land.lhs.true.i.i38
  %freereg.i.i43 = getelementptr inbounds %struct.FuncState, ptr %fs, i64 0, i32 9
  %15 = load i32, ptr %freereg.i.i43, align 4
  %dec.i.i44 = add nsw i32 %15, -1
  store i32 %dec.i.i44, ptr %freereg.i.i43, align 4
  br label %return

return:                                           ; preds = %if.then.i.i42, %land.lhs.true.i.i38, %if.then.i34, %sw.epilog, %freeexp.exit
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @assignment(ptr noundef %ls, ptr noundef %lh, i32 noundef %nvars) unnamed_addr #0 {
entry:
  %e = alloca %struct.expdesc, align 8
  %nv = alloca %struct.LHS_assign, align 8
  %v = getelementptr inbounds %struct.LHS_assign, ptr %lh, i64 0, i32 1
  %0 = load i32, ptr %v, align 8
  %1 = add i32 %0, -6
  %or.cond = icmp ult i32 %1, 4
  %t.i30 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 3
  %2 = load i32, ptr %t.i30, align 8
  br i1 %or.cond, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call fastcc void @luaX_lexerror(ptr noundef %ls, ptr noundef nonnull @.str.173, i32 noundef %2)
  unreachable

if.end:                                           ; preds = %entry
  %cmp.i = icmp eq i32 %2, 44
  br i1 %cmp.i, label %if.then.i, label %if.else

if.then.i:                                        ; preds = %if.end
  %linenumber.i.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 1
  %3 = load i32, ptr %linenumber.i.i, align 4
  %lastline.i.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 2
  store i32 %3, ptr %lastline.i.i, align 8
  %lookahead.i.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 4
  %4 = load i32, ptr %lookahead.i.i, align 8
  %cmp.not.i.i = icmp eq i32 %4, 287
  br i1 %cmp.not.i.i, label %if.else.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %if.then.i
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t.i30, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i.i, i64 16, i1 false)
  store i32 287, ptr %lookahead.i.i, align 8
  br label %if.then4

if.else.i.i:                                      ; preds = %if.then.i
  %seminfo.i.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 3, i32 1
  %call.i.i = tail call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i.i)
  store i32 %call.i.i, ptr %t.i30, align 8
  br label %if.then4

if.then4:                                         ; preds = %if.then.i.i, %if.else.i.i
  store ptr %lh, ptr %nv, align 8
  %v5 = getelementptr inbounds %struct.LHS_assign, ptr %nv, i64 0, i32 1
  call fastcc void @primaryexp(ptr noundef nonnull %ls, ptr noundef nonnull %v5)
  %5 = load i32, ptr %v5, align 8
  %cmp8 = icmp eq i32 %5, 6
  br i1 %cmp8, label %for.body.lr.ph.i, label %if.end11

for.body.lr.ph.i:                                 ; preds = %if.then4
  %6 = getelementptr i8, ptr %ls, i64 48
  %ls.val29 = load ptr, ptr %6, align 8
  %freereg.i = getelementptr inbounds %struct.FuncState, ptr %ls.val29, i64 0, i32 9
  %7 = load i32, ptr %freereg.i, align 4
  %u4.i = getelementptr inbounds %struct.LHS_assign, ptr %nv, i64 0, i32 1, i32 1
  br label %for.body.i

for.body.i:                                       ; preds = %for.body.i.backedge, %for.body.lr.ph.i
  %conflict.03.i = phi i32 [ 0, %for.body.lr.ph.i ], [ %conflict.03.i.be, %for.body.i.backedge ]
  %lh.addr.02.i = phi ptr [ %lh, %for.body.lr.ph.i ], [ %lh.addr.02.i.be, %for.body.i.backedge ]
  %v2.i = getelementptr inbounds %struct.LHS_assign, ptr %lh.addr.02.i, i64 0, i32 1
  %8 = load i32, ptr %v2.i, align 8
  %cmp.i31 = icmp eq i32 %8, 9
  br i1 %cmp.i31, label %if.then.i34, label %for.inc.i

if.then.i34:                                      ; preds = %for.body.i
  %u.i = getelementptr inbounds %struct.LHS_assign, ptr %lh.addr.02.i, i64 0, i32 1, i32 1
  %9 = load i32, ptr %u.i, align 8
  %10 = load i32, ptr %u4.i, align 8
  %cmp6.i = icmp eq i32 %9, %10
  br i1 %cmp6.i, label %if.then7.i, label %if.end.i

if.then7.i:                                       ; preds = %if.then.i34
  store i32 %7, ptr %u.i, align 8
  %.pre.i = load i32, ptr %u4.i, align 8
  br label %if.end.i

if.end.i:                                         ; preds = %if.then7.i, %if.then.i34
  %11 = phi i32 [ %.pre.i, %if.then7.i ], [ %10, %if.then.i34 ]
  %conflict.1.i = phi i32 [ 1, %if.then7.i ], [ %conflict.03.i, %if.then.i34 ]
  %aux.i = getelementptr inbounds i8, ptr %lh.addr.02.i, i64 20
  %12 = load i32, ptr %aux.i, align 4
  %cmp15.i = icmp eq i32 %12, %11
  br i1 %cmp15.i, label %for.inc.thread.i, label %for.inc.i

for.inc.i:                                        ; preds = %if.end.i, %for.body.i
  %conflict.2.i = phi i32 [ %conflict.1.i, %if.end.i ], [ %conflict.03.i, %for.body.i ]
  %13 = load ptr, ptr %lh.addr.02.i, align 8
  %tobool.not.i = icmp eq ptr %13, null
  br i1 %tobool.not.i, label %for.end.i, label %for.body.i.backedge

for.inc.thread.i:                                 ; preds = %if.end.i
  store i32 %7, ptr %aux.i, align 4
  %14 = load ptr, ptr %lh.addr.02.i, align 8
  %tobool.not6.i = icmp eq ptr %14, null
  br i1 %tobool.not6.i, label %if.then23.i, label %for.body.i.backedge

for.body.i.backedge:                              ; preds = %for.inc.thread.i, %for.inc.i
  %conflict.03.i.be = phi i32 [ %conflict.2.i, %for.inc.i ], [ 1, %for.inc.thread.i ]
  %lh.addr.02.i.be = phi ptr [ %13, %for.inc.i ], [ %14, %for.inc.thread.i ]
  br label %for.body.i, !llvm.loop !127

for.end.i:                                        ; preds = %for.inc.i
  %15 = icmp eq i32 %conflict.2.i, 0
  br i1 %15, label %if.end11, label %for.end.i.if.then23.i_crit_edge

for.end.i.if.then23.i_crit_edge:                  ; preds = %for.end.i
  %.pre80 = load i32, ptr %u4.i, align 8
  br label %if.then23.i

if.then23.i:                                      ; preds = %for.inc.thread.i, %for.end.i.if.then23.i_crit_edge
  %16 = phi i32 [ %.pre80, %for.end.i.if.then23.i_crit_edge ], [ %11, %for.inc.thread.i ]
  %17 = load i32, ptr %freereg.i, align 4
  %shl1.i.i = shl i32 %17, 6
  %shl2.i.i = shl i32 %16, 23
  %or3.i.i = or i32 %shl2.i.i, %shl1.i.i
  %ls.i.i = getelementptr inbounds %struct.FuncState, ptr %ls.val29, i64 0, i32 3
  %18 = load ptr, ptr %ls.i.i, align 8
  %lastline.i.i32 = getelementptr inbounds %struct.LexState, ptr %18, i64 0, i32 2
  %19 = load i32, ptr %lastline.i.i32, align 8
  %call.i.i33 = call fastcc i32 @luaK_code(ptr noundef %ls.val29, i32 noundef %or3.i.i, i32 noundef %19)
  %20 = load i32, ptr %freereg.i, align 4
  %add.i.i.i = add nsw i32 %20, 1
  %21 = load ptr, ptr %ls.val29, align 8
  %maxstacksize.i.i.i = getelementptr inbounds %struct.Proto, ptr %21, i64 0, i32 22
  %22 = load i8, ptr %maxstacksize.i.i.i, align 1
  %conv.i.i.i = zext i8 %22 to i32
  %cmp.i.i.not.i = icmp slt i32 %20, %conv.i.i.i
  br i1 %cmp.i.i.not.i, label %luaK_reserveregs.exit.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %if.then23.i
  %cmp2.i.i.i = icmp sgt i32 %20, 248
  br i1 %cmp2.i.i.i, label %if.then4.i.i.i, label %if.end.i.i.i

if.then4.i.i.i:                                   ; preds = %if.then.i.i.i
  %23 = load ptr, ptr %ls.i.i, align 8
  %t.i.i.i.i = getelementptr inbounds %struct.LexState, ptr %23, i64 0, i32 3
  %24 = load i32, ptr %t.i.i.i.i, align 8
  call fastcc void @luaX_lexerror(ptr noundef %23, ptr noundef nonnull @.str.150, i32 noundef %24)
  unreachable

if.end.i.i.i:                                     ; preds = %if.then.i.i.i
  %conv5.i.i.i = trunc i32 %add.i.i.i to i8
  store i8 %conv5.i.i.i, ptr %maxstacksize.i.i.i, align 1
  %.pre.i.i = load i32, ptr %freereg.i, align 4
  %.pre3.i.i = add nsw i32 %.pre.i.i, 1
  br label %luaK_reserveregs.exit.i

luaK_reserveregs.exit.i:                          ; preds = %if.end.i.i.i, %if.then23.i
  %add.pre-phi.i.i = phi i32 [ %add.i.i.i, %if.then23.i ], [ %.pre3.i.i, %if.end.i.i.i ]
  store i32 %add.pre-phi.i.i, ptr %freereg.i, align 4
  br label %if.end11

if.end11:                                         ; preds = %luaK_reserveregs.exit.i, %for.end.i, %if.then4
  %L = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 6
  %25 = load ptr, ptr %L, align 8
  %nCcalls = getelementptr inbounds %struct.lua_State, ptr %25, i64 0, i32 15
  %26 = load i16, ptr %nCcalls, align 8
  %conv = zext i16 %26 to i32
  %sub = sub nsw i32 200, %conv
  %cmp12 = icmp slt i32 %sub, %nvars
  br i1 %cmp12, label %if.then14, label %if.end19

if.then14:                                        ; preds = %if.end11
  %fs = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 5
  %27 = load ptr, ptr %fs, align 8
  %28 = load ptr, ptr %27, align 8
  %linedefined.i = getelementptr inbounds %struct.Proto, ptr %28, i64 0, i32 16
  %29 = load i32, ptr %linedefined.i, align 8
  %cmp.i35 = icmp eq i32 %29, 0
  %L.i = getelementptr inbounds %struct.FuncState, ptr %27, i64 0, i32 4
  %30 = load ptr, ptr %L.i, align 8
  br i1 %cmp.i35, label %cond.true.i, label %cond.false.i

cond.true.i:                                      ; preds = %if.then14
  %call.i = call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %30, ptr noundef nonnull @.str.153, i32 noundef %sub, ptr noundef nonnull @.str.174)
  br label %cond.end.i

cond.false.i:                                     ; preds = %if.then14
  %call4.i = call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %30, ptr noundef nonnull @.str.154, i32 noundef %29, i32 noundef %sub, ptr noundef nonnull @.str.174)
  br label %cond.end.i

cond.end.i:                                       ; preds = %cond.false.i, %cond.true.i
  %cond.i = phi ptr [ %call.i, %cond.true.i ], [ %call4.i, %cond.false.i ]
  %ls.i = getelementptr inbounds %struct.FuncState, ptr %27, i64 0, i32 3
  %31 = load ptr, ptr %ls.i, align 8
  call fastcc void @luaX_lexerror(ptr noundef %31, ptr noundef %cond.i, i32 noundef 0)
  unreachable

if.end19:                                         ; preds = %if.end11
  %add = add nsw i32 %nvars, 1
  call fastcc void @assignment(ptr noundef nonnull %ls, ptr noundef nonnull %nv, i32 noundef %add)
  br label %if.end36

if.else:                                          ; preds = %if.end
  tail call fastcc void @checknext(ptr noundef nonnull %ls, i32 noundef 61)
  %call.i71 = call fastcc i32 @subexpr(ptr noundef nonnull %ls, ptr noundef nonnull %e, i32 noundef 0), !range !93
  %32 = load i32, ptr %t.i30, align 8
  %cmp.i5977 = icmp eq i32 %32, 44
  br i1 %cmp.i5977, label %if.then.i61.lr.ph, label %explist1.exit

if.then.i61.lr.ph:                                ; preds = %if.else
  %linenumber.i.i62 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 1
  %lastline.i.i63 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 2
  %lookahead.i.i64 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 4
  %seminfo.i.i68 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 3, i32 1
  %fs.i = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 5
  %u.i.i = getelementptr inbounds %struct.expdesc, ptr %e, i64 0, i32 1
  br label %if.then.i61

if.then.i61:                                      ; preds = %if.then.i61.lr.ph, %luaK_exp2nextreg.exit
  %n.0.i78 = phi i32 [ 1, %if.then.i61.lr.ph ], [ %inc.i, %luaK_exp2nextreg.exit ]
  %33 = load i32, ptr %linenumber.i.i62, align 4
  store i32 %33, ptr %lastline.i.i63, align 8
  %34 = load i32, ptr %lookahead.i.i64, align 8
  %cmp.not.i.i65 = icmp eq i32 %34, 287
  br i1 %cmp.not.i.i65, label %if.else.i.i67, label %if.then.i.i66

if.then.i.i66:                                    ; preds = %if.then.i61
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %t.i30, ptr noundef nonnull align 8 dereferenceable(16) %lookahead.i.i64, i64 16, i1 false)
  store i32 287, ptr %lookahead.i.i64, align 8
  br label %while.body.i

if.else.i.i67:                                    ; preds = %if.then.i61
  %call.i.i69 = call fastcc i32 @llex(ptr noundef nonnull %ls, ptr noundef nonnull %seminfo.i.i68)
  store i32 %call.i.i69, ptr %t.i30, align 8
  br label %while.body.i

while.body.i:                                     ; preds = %if.then.i.i66, %if.else.i.i67
  %35 = load ptr, ptr %fs.i, align 8
  call fastcc void @luaK_dischargevars(ptr noundef %35, ptr noundef nonnull %e)
  %36 = load i32, ptr %e, align 8
  %cmp.i.i = icmp eq i32 %36, 12
  br i1 %cmp.i.i, label %if.then.i.i55, label %freeexp.exit.i

if.then.i.i55:                                    ; preds = %while.body.i
  %37 = load i32, ptr %u.i.i, align 8
  %and.i.i.i = and i32 %37, 256
  %tobool.not.i.i.i = icmp eq i32 %and.i.i.i, 0
  br i1 %tobool.not.i.i.i, label %land.lhs.true.i.i.i, label %freeexp.exit.i

land.lhs.true.i.i.i:                              ; preds = %if.then.i.i55
  %nactvar.i.i.i = getelementptr inbounds %struct.FuncState, ptr %35, i64 0, i32 13
  %38 = load i8, ptr %nactvar.i.i.i, align 2
  %conv.i.i.i56 = zext i8 %38 to i32
  %cmp.not.i.i.i = icmp slt i32 %37, %conv.i.i.i56
  br i1 %cmp.not.i.i.i, label %freeexp.exit.i, label %if.then.i.i.i57

if.then.i.i.i57:                                  ; preds = %land.lhs.true.i.i.i
  %freereg.i.i.i = getelementptr inbounds %struct.FuncState, ptr %35, i64 0, i32 9
  %39 = load i32, ptr %freereg.i.i.i, align 4
  %dec.i.i.i = add nsw i32 %39, -1
  store i32 %dec.i.i.i, ptr %freereg.i.i.i, align 4
  br label %freeexp.exit.i

freeexp.exit.i:                                   ; preds = %if.then.i.i.i57, %land.lhs.true.i.i.i, %if.then.i.i55, %while.body.i
  %freereg.i.i7.i = getelementptr inbounds %struct.FuncState, ptr %35, i64 0, i32 9
  %40 = load i32, ptr %freereg.i.i7.i, align 4
  %add.i.i.i43 = add nsw i32 %40, 1
  %41 = load ptr, ptr %35, align 8
  %maxstacksize.i.i.i44 = getelementptr inbounds %struct.Proto, ptr %41, i64 0, i32 22
  %42 = load i8, ptr %maxstacksize.i.i.i44, align 1
  %conv.i.i8.i = zext i8 %42 to i32
  %cmp.i.i.not.i45 = icmp slt i32 %40, %conv.i.i8.i
  br i1 %cmp.i.i.not.i45, label %luaK_exp2nextreg.exit, label %if.then.i.i9.i

if.then.i.i9.i:                                   ; preds = %freeexp.exit.i
  %cmp2.i.i.i46 = icmp sgt i32 %40, 248
  br i1 %cmp2.i.i.i46, label %if.then4.i.i.i53, label %if.end.i.i.i47

if.then4.i.i.i53:                                 ; preds = %if.then.i.i9.i
  %ls.i.i.i = getelementptr inbounds %struct.FuncState, ptr %35, i64 0, i32 3
  %43 = load ptr, ptr %ls.i.i.i, align 8
  %t.i.i.i.i54 = getelementptr inbounds %struct.LexState, ptr %43, i64 0, i32 3
  %44 = load i32, ptr %t.i.i.i.i54, align 8
  call fastcc void @luaX_lexerror(ptr noundef %43, ptr noundef nonnull @.str.150, i32 noundef %44)
  unreachable

if.end.i.i.i47:                                   ; preds = %if.then.i.i9.i
  %conv5.i.i.i48 = trunc i32 %add.i.i.i43 to i8
  store i8 %conv5.i.i.i48, ptr %maxstacksize.i.i.i44, align 1
  %.pre.i.i49 = load i32, ptr %freereg.i.i7.i, align 4
  %.pre3.i.i50 = add nsw i32 %.pre.i.i49, 1
  br label %luaK_exp2nextreg.exit

luaK_exp2nextreg.exit:                            ; preds = %freeexp.exit.i, %if.end.i.i.i47
  %add.pre-phi.i.i52 = phi i32 [ %add.i.i.i43, %freeexp.exit.i ], [ %.pre3.i.i50, %if.end.i.i.i47 ]
  store i32 %add.pre-phi.i.i52, ptr %freereg.i.i7.i, align 4
  %sub.i = add nsw i32 %add.pre-phi.i.i52, -1
  call fastcc void @exp2reg(ptr noundef nonnull %35, ptr noundef nonnull %e, i32 noundef %sub.i)
  %call.i42 = call fastcc i32 @subexpr(ptr noundef nonnull %ls, ptr noundef nonnull %e, i32 noundef 0), !range !93
  %inc.i = add nuw nsw i32 %n.0.i78, 1
  %45 = load i32, ptr %t.i30, align 8
  %cmp.i59 = icmp eq i32 %45, 44
  br i1 %cmp.i59, label %if.then.i61, label %explist1.exit, !llvm.loop !97

explist1.exit:                                    ; preds = %luaK_exp2nextreg.exit, %if.else
  %n.0.i.lcssa = phi i32 [ 1, %if.else ], [ %inc.i, %luaK_exp2nextreg.exit ]
  %cmp21.not = icmp eq i32 %n.0.i.lcssa, %nvars
  br i1 %cmp21.not, label %if.else31, label %if.then23

if.then23:                                        ; preds = %explist1.exit
  %46 = getelementptr i8, ptr %ls, i64 48
  %ls.val = load ptr, ptr %46, align 8
  call fastcc void @adjust_assign(ptr %ls.val, i32 noundef %nvars, i32 noundef %n.0.i.lcssa, ptr noundef nonnull %e)
  %cmp24 = icmp sgt i32 %n.0.i.lcssa, %nvars
  br i1 %cmp24, label %if.then26, label %if.end36

if.then26:                                        ; preds = %if.then23
  %sub27.neg = sub i32 %nvars, %n.0.i.lcssa
  %47 = load ptr, ptr %46, align 8
  %freereg = getelementptr inbounds %struct.FuncState, ptr %47, i64 0, i32 9
  %48 = load i32, ptr %freereg, align 4
  %sub29 = add i32 %sub27.neg, %48
  store i32 %sub29, ptr %freereg, align 4
  br label %if.end36

if.else31:                                        ; preds = %explist1.exit
  %fs32 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 5
  %49 = load ptr, ptr %fs32, align 8
  %50 = load i32, ptr %e, align 8
  switch i32 %50, label %return [
    i32 13, label %if.then.i38
    i32 14, label %if.then6.i
  ]

if.then.i38:                                      ; preds = %if.else31
  store i32 12, ptr %e, align 8
  %51 = load ptr, ptr %49, align 8
  %code.i = getelementptr inbounds %struct.Proto, ptr %51, i64 0, i32 4
  %52 = load ptr, ptr %code.i, align 8
  %u.i39 = getelementptr inbounds %struct.expdesc, ptr %e, i64 0, i32 1
  %53 = load i32, ptr %u.i39, align 8
  %idxprom.i = sext i32 %53 to i64
  %arrayidx.i = getelementptr inbounds i32, ptr %52, i64 %idxprom.i
  %54 = load i32, ptr %arrayidx.i, align 4
  %shr.i = lshr i32 %54, 6
  %and.i = and i32 %shr.i, 255
  store i32 %and.i, ptr %u.i39, align 8
  br label %return

if.then6.i:                                       ; preds = %if.else31
  %55 = load ptr, ptr %49, align 8
  %code8.i = getelementptr inbounds %struct.Proto, ptr %55, i64 0, i32 4
  %56 = load ptr, ptr %code8.i, align 8
  %u9.i = getelementptr inbounds %struct.expdesc, ptr %e, i64 0, i32 1
  %57 = load i32, ptr %u9.i, align 8
  %idxprom11.i = sext i32 %57 to i64
  %arrayidx12.i = getelementptr inbounds i32, ptr %56, i64 %idxprom11.i
  %58 = load i32, ptr %arrayidx12.i, align 4
  %and13.i = and i32 %58, 8388607
  %or.i = or disjoint i32 %and13.i, 16777216
  store i32 %or.i, ptr %arrayidx12.i, align 4
  store i32 11, ptr %e, align 8
  %.pre = load ptr, ptr %fs32, align 8
  br label %return

if.end36:                                         ; preds = %if.then26, %if.then23, %if.end19
  %fs37 = getelementptr inbounds %struct.LexState, ptr %ls, i64 0, i32 5
  %59 = load ptr, ptr %fs37, align 8
  %freereg38 = getelementptr inbounds %struct.FuncState, ptr %59, i64 0, i32 9
  %60 = load i32, ptr %freereg38, align 4
  %sub39 = add nsw i32 %60, -1
  %t.i40 = getelementptr inbounds %struct.expdesc, ptr %e, i64 0, i32 2
  store i32 -1, ptr %t.i40, align 8
  %f.i = getelementptr inbounds %struct.expdesc, ptr %e, i64 0, i32 3
  store i32 -1, ptr %f.i, align 4
  store i32 12, ptr %e, align 8
  %u.i41 = getelementptr inbounds %struct.expdesc, ptr %e, i64 0, i32 1
  store i32 %sub39, ptr %u.i41, align 8
  br label %return

return:                                           ; preds = %if.then6.i, %if.then.i38, %if.else31, %if.end36
  %.sink = phi ptr [ %59, %if.end36 ], [ %49, %if.else31 ], [ %49, %if.then.i38 ], [ %.pre, %if.then6.i ]
  call fastcc void @luaK_storevar(ptr noundef %.sink, ptr noundef nonnull %v, ptr noundef nonnull %e)
  ret void
}

; Function Attrs: nofree nounwind uwtable
define internal fastcc double @lua_tonumber(ptr nocapture noundef %L, i32 noundef %idx) unnamed_addr #21 {
entry:
  %endptr.i.i = alloca ptr, align 8
  %cmp.i = icmp sgt i32 %idx, 0
  br i1 %cmp.i, label %if.then.i, label %if.else3.i

if.then.i:                                        ; preds = %entry
  %base.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i, align 8
  %1 = zext nneg i32 %idx to i64
  %2 = getelementptr %struct.lua_TValue, ptr %0, i64 %1
  %add.ptr.i = getelementptr %struct.lua_TValue, ptr %2, i64 -1
  %top.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %3 = load ptr, ptr %top.i, align 8
  %cmp1.not.i = icmp ult ptr %add.ptr.i, %3
  %add.ptr.luaO_nilobject_.i = select i1 %cmp1.not.i, ptr %add.ptr.i, ptr @luaO_nilobject_
  br label %index2adr.exit

if.else3.i:                                       ; preds = %entry
  %cmp4.i = icmp sgt i32 %idx, -10000
  br i1 %cmp4.i, label %if.then5.i, label %if.else9.i

if.then5.i:                                       ; preds = %if.else3.i
  %top6.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %4 = load ptr, ptr %top6.i, align 8
  %idx.ext7.i = sext i32 %idx to i64
  %add.ptr8.i = getelementptr inbounds %struct.lua_TValue, ptr %4, i64 %idx.ext7.i
  br label %index2adr.exit

if.else9.i:                                       ; preds = %if.else3.i
  switch i32 %idx, label %sw.default.i [
    i32 -10000, label %sw.bb.i
    i32 -10001, label %sw.bb10.i
    i32 -10002, label %sw.bb15.i
  ]

sw.bb.i:                                          ; preds = %if.else9.i
  %l_G.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %5 = load ptr, ptr %l_G.i, align 8
  %l_registry.i = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 20
  br label %index2adr.exit

sw.bb10.i:                                        ; preds = %if.else9.i
  %ci.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %6 = load ptr, ptr %ci.i, align 8
  %func11.i = getelementptr inbounds %struct.CallInfo, ptr %6, i64 0, i32 1
  %7 = load ptr, ptr %func11.i, align 8
  %8 = load ptr, ptr %7, align 8
  %env.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23
  %env12.i = getelementptr inbounds %struct.CClosure, ptr %8, i64 0, i32 6
  %9 = load ptr, ptr %env12.i, align 8
  store ptr %9, ptr %env.i, align 8
  %tt.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23, i32 1
  store i32 5, ptr %tt.i, align 8
  br label %index2adr.exit

sw.bb15.i:                                        ; preds = %if.else9.i
  %l_gt.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 22
  br label %index2adr.exit

sw.default.i:                                     ; preds = %if.else9.i
  %ci17.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %10 = load ptr, ptr %ci17.i, align 8
  %func18.i = getelementptr inbounds %struct.CallInfo, ptr %10, i64 0, i32 1
  %11 = load ptr, ptr %func18.i, align 8
  %12 = load ptr, ptr %11, align 8
  %sub20.i = sub nuw nsw i32 -10002, %idx
  %nupvalues.i = getelementptr inbounds %struct.CClosure, ptr %12, i64 0, i32 4
  %13 = load i8, ptr %nupvalues.i, align 1
  %conv.i = zext i8 %13 to i32
  %cmp21.not.i = icmp ugt i32 %sub20.i, %conv.i
  %sub23.i = sub nuw nsw i32 -10003, %idx
  %idxprom.i = zext nneg i32 %sub23.i to i64
  %arrayidx.i = getelementptr inbounds %struct.CClosure, ptr %12, i64 0, i32 8, i64 %idxprom.i
  %cond.i = select i1 %cmp21.not.i, ptr @luaO_nilobject_, ptr %arrayidx.i
  br label %index2adr.exit

index2adr.exit:                                   ; preds = %if.then.i, %if.then5.i, %sw.bb.i, %sw.bb10.i, %sw.bb15.i, %sw.default.i
  %retval.0.i = phi ptr [ %add.ptr8.i, %if.then5.i ], [ %cond.i, %sw.default.i ], [ %l_gt.i, %sw.bb15.i ], [ %env.i, %sw.bb10.i ], [ %l_registry.i, %sw.bb.i ], [ %add.ptr.luaO_nilobject_.i, %if.then.i ]
  %tt = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i, i64 0, i32 1
  %14 = load i32, ptr %tt, align 8
  switch i32 %14, label %return [
    i32 3, label %index2adr.exit.if.then_crit_edge
    i32 4, label %land.lhs.true.i
  ]

index2adr.exit.if.then_crit_edge:                 ; preds = %index2adr.exit
  %.pre = load double, ptr %retval.0.i, align 8
  br label %return

land.lhs.true.i:                                  ; preds = %index2adr.exit
  %15 = load ptr, ptr %retval.0.i, align 8
  %add.ptr.i4 = getelementptr inbounds %union.TString, ptr %15, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i)
  %call.i.i = call double @strtod(ptr noundef nonnull %add.ptr.i4, ptr noundef nonnull %endptr.i.i) #35
  %16 = load ptr, ptr %endptr.i.i, align 8
  %cmp.i.i = icmp eq ptr %16, %add.ptr.i4
  br i1 %cmp.i.i, label %luaO_str2d.exit.thread.i, label %if.end.i.i

luaO_str2d.exit.thread.i:                         ; preds = %land.lhs.true.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i)
  br label %return

if.end.i.i:                                       ; preds = %land.lhs.true.i
  %17 = load i8, ptr %16, align 1
  switch i8 %17, label %if.end9.i.i [
    i8 120, label %if.then6.i.i
    i8 88, label %if.then6.i.i
  ]

if.then6.i.i:                                     ; preds = %if.end.i.i, %if.end.i.i
  %call7.i.i = call i64 @strtoul(ptr noundef nonnull %add.ptr.i4, ptr noundef nonnull %endptr.i.i, i32 noundef 16) #35
  %conv8.i.i = uitofp i64 %call7.i.i to double
  %.pre.i.i = load ptr, ptr %endptr.i.i, align 8
  %.pre5.i.i = load i8, ptr %.pre.i.i, align 1
  br label %if.end9.i.i

if.end9.i.i:                                      ; preds = %if.then6.i.i, %if.end.i.i
  %num.0.i = phi double [ %call.i.i, %if.end.i.i ], [ %conv8.i.i, %if.then6.i.i ]
  %18 = phi i8 [ %17, %if.end.i.i ], [ %.pre5.i.i, %if.then6.i.i ]
  %endptr.promoted.i.i = phi ptr [ %16, %if.end.i.i ], [ %.pre.i.i, %if.then6.i.i ]
  %cmp11.i.i = icmp eq i8 %18, 0
  br i1 %cmp11.i.i, label %luaO_str2d.exit.thread9.i, label %while.cond.preheader.i.i

luaO_str2d.exit.thread9.i:                        ; preds = %if.end9.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i)
  br label %return

while.cond.preheader.i.i:                         ; preds = %if.end9.i.i
  %call15.i.i = tail call ptr @__ctype_b_loc() #39
  %19 = load ptr, ptr %call15.i.i, align 8
  br label %while.cond.i.i

while.cond.i.i:                                   ; preds = %while.cond.i.i, %while.cond.preheader.i.i
  %incdec.ptr4.i.i = phi ptr [ %endptr.promoted.i.i, %while.cond.preheader.i.i ], [ %incdec.ptr.i.i, %while.cond.i.i ]
  %20 = load i8, ptr %incdec.ptr4.i.i, align 1
  %idxprom.i.i = zext i8 %20 to i64
  %arrayidx.i.i = getelementptr inbounds i16, ptr %19, i64 %idxprom.i.i
  %21 = load i16, ptr %arrayidx.i.i, align 2
  %22 = and i16 %21, 8192
  %tobool.not.i.i = icmp eq i16 %22, 0
  %incdec.ptr.i.i = getelementptr inbounds i8, ptr %incdec.ptr4.i.i, i64 1
  br i1 %tobool.not.i.i, label %luaO_str2d.exit.i, label %while.cond.i.i, !llvm.loop !35

luaO_str2d.exit.i:                                ; preds = %while.cond.i.i
  %cmp19.not.i.not.i = icmp eq i8 %20, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i)
  br i1 %cmp19.not.i.not.i, label %if.then, label %return

if.then:                                          ; preds = %luaO_str2d.exit.i
  br label %return

return:                                           ; preds = %index2adr.exit.if.then_crit_edge, %luaO_str2d.exit.thread9.i, %index2adr.exit, %luaO_str2d.exit.i, %luaO_str2d.exit.thread.i, %if.then
  %retval.0 = phi double [ 0.000000e+00, %luaO_str2d.exit.thread.i ], [ 0.000000e+00, %luaO_str2d.exit.i ], [ 0.000000e+00, %index2adr.exit ], [ %.pre, %index2adr.exit.if.then_crit_edge ], [ %num.0.i, %luaO_str2d.exit.thread9.i ], [ %num.0.i, %if.then ]
  ret double %retval.0
}

; Function Attrs: nounwind uwtable
define internal fastcc i64 @lua_objlen(ptr noundef %L, i32 noundef %idx) unnamed_addr #0 {
entry:
  %s.i = alloca [32 x i8], align 16
  %cmp.i = icmp sgt i32 %idx, 0
  br i1 %cmp.i, label %if.then.i, label %if.else3.i

if.then.i:                                        ; preds = %entry
  %base.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i, align 8
  %1 = zext nneg i32 %idx to i64
  %2 = getelementptr %struct.lua_TValue, ptr %0, i64 %1
  %add.ptr.i = getelementptr %struct.lua_TValue, ptr %2, i64 -1
  %top.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %3 = load ptr, ptr %top.i, align 8
  %cmp1.not.i = icmp ult ptr %add.ptr.i, %3
  %add.ptr.luaO_nilobject_.i = select i1 %cmp1.not.i, ptr %add.ptr.i, ptr @luaO_nilobject_
  br label %index2adr.exit

if.else3.i:                                       ; preds = %entry
  %cmp4.i = icmp sgt i32 %idx, -10000
  br i1 %cmp4.i, label %if.then5.i, label %if.else9.i

if.then5.i:                                       ; preds = %if.else3.i
  %top6.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %4 = load ptr, ptr %top6.i, align 8
  %idx.ext7.i = sext i32 %idx to i64
  %add.ptr8.i = getelementptr inbounds %struct.lua_TValue, ptr %4, i64 %idx.ext7.i
  br label %index2adr.exit

if.else9.i:                                       ; preds = %if.else3.i
  switch i32 %idx, label %sw.default.i [
    i32 -10000, label %sw.bb.i
    i32 -10001, label %sw.bb10.i
    i32 -10002, label %sw.bb15.i
  ]

sw.bb.i:                                          ; preds = %if.else9.i
  %l_G.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %5 = load ptr, ptr %l_G.i, align 8
  %l_registry.i = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 20
  br label %index2adr.exit

sw.bb10.i:                                        ; preds = %if.else9.i
  %ci.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %6 = load ptr, ptr %ci.i, align 8
  %func11.i = getelementptr inbounds %struct.CallInfo, ptr %6, i64 0, i32 1
  %7 = load ptr, ptr %func11.i, align 8
  %8 = load ptr, ptr %7, align 8
  %env.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23
  %env12.i = getelementptr inbounds %struct.CClosure, ptr %8, i64 0, i32 6
  %9 = load ptr, ptr %env12.i, align 8
  store ptr %9, ptr %env.i, align 8
  %tt.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23, i32 1
  store i32 5, ptr %tt.i, align 8
  br label %index2adr.exit

sw.bb15.i:                                        ; preds = %if.else9.i
  %l_gt.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 22
  br label %index2adr.exit

sw.default.i:                                     ; preds = %if.else9.i
  %ci17.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %10 = load ptr, ptr %ci17.i, align 8
  %func18.i = getelementptr inbounds %struct.CallInfo, ptr %10, i64 0, i32 1
  %11 = load ptr, ptr %func18.i, align 8
  %12 = load ptr, ptr %11, align 8
  %sub20.i = sub nuw nsw i32 -10002, %idx
  %nupvalues.i = getelementptr inbounds %struct.CClosure, ptr %12, i64 0, i32 4
  %13 = load i8, ptr %nupvalues.i, align 1
  %conv.i = zext i8 %13 to i32
  %cmp21.not.i = icmp ugt i32 %sub20.i, %conv.i
  %sub23.i = sub nuw nsw i32 -10003, %idx
  %idxprom.i = zext nneg i32 %sub23.i to i64
  %arrayidx.i = getelementptr inbounds %struct.CClosure, ptr %12, i64 0, i32 8, i64 %idxprom.i
  %cond.i = select i1 %cmp21.not.i, ptr @luaO_nilobject_, ptr %arrayidx.i
  br label %index2adr.exit

index2adr.exit:                                   ; preds = %if.then.i, %if.then5.i, %sw.bb.i, %sw.bb10.i, %sw.bb15.i, %sw.default.i
  %retval.0.i = phi ptr [ %add.ptr8.i, %if.then5.i ], [ %cond.i, %sw.default.i ], [ %l_gt.i, %sw.bb15.i ], [ %env.i, %sw.bb10.i ], [ %l_registry.i, %sw.bb.i ], [ %add.ptr.luaO_nilobject_.i, %if.then.i ]
  %tt = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i, i64 0, i32 1
  %14 = load i32, ptr %tt, align 8
  switch i32 %14, label %return [
    i32 4, label %sw.bb
    i32 7, label %sw.bb1
    i32 5, label %sw.bb4
    i32 3, label %cond.true
  ]

sw.bb:                                            ; preds = %index2adr.exit
  %15 = load ptr, ptr %retval.0.i, align 8
  %len = getelementptr inbounds %struct.anon.0, ptr %15, i64 0, i32 5
  %16 = load i64, ptr %len, align 8
  br label %return

sw.bb1:                                           ; preds = %index2adr.exit
  %17 = load ptr, ptr %retval.0.i, align 8
  %len3 = getelementptr inbounds %struct.anon.1, ptr %17, i64 0, i32 5
  %18 = load i64, ptr %len3, align 8
  br label %return

sw.bb4:                                           ; preds = %index2adr.exit
  %19 = load ptr, ptr %retval.0.i, align 8
  %call6 = tail call fastcc i32 @luaH_getn(ptr noundef %19)
  %conv = sext i32 %call6 to i64
  br label %return

cond.true:                                        ; preds = %index2adr.exit
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %s.i)
  %20 = load double, ptr %retval.0.i, align 8
  %call.i = call i32 (ptr, ptr, ...) @sprintf(ptr noundef nonnull dereferenceable(1) %s.i, ptr noundef nonnull dereferenceable(1) @.str.16, double noundef %20) #35
  %call3.i = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %s.i) #34
  %call4.i = call fastcc ptr @luaS_newlstr(ptr noundef %L, ptr noundef nonnull %s.i, i64 noundef %call3.i)
  store ptr %call4.i, ptr %retval.0.i, align 8
  store i32 4, ptr %tt, align 8
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %s.i)
  %len10 = getelementptr inbounds %struct.anon.0, ptr %call4.i, i64 0, i32 5
  %21 = load i64, ptr %len10, align 8
  br label %return

return:                                           ; preds = %index2adr.exit, %cond.true, %sw.bb4, %sw.bb1, %sw.bb
  %retval.0 = phi i64 [ %conv, %sw.bb4 ], [ %18, %sw.bb1 ], [ %16, %sw.bb ], [ %21, %cond.true ], [ 0, %index2adr.exit ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal fastcc ptr @lua_newuserdata(ptr noundef %L, i64 noundef %size) unnamed_addr #0 {
entry:
  %l_G = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %0 = load ptr, ptr %l_G, align 8
  %totalbytes = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 14
  %1 = load i64, ptr %totalbytes, align 8
  %GCthreshold = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 13
  %2 = load i64, ptr %GCthreshold, align 8
  %cmp.not = icmp ult i64 %1, %2
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %gcstepmul.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 18
  %3 = load i32, ptr %gcstepmul.i, align 4
  %mul.i = mul i32 %3, 10
  %conv.i = zext i32 %mul.i to i64
  %cmp.i = icmp eq i32 %mul.i, 0
  %spec.store.select.i = select i1 %cmp.i, i64 9223372036854775806, i64 %conv.i
  %sub.i = sub i64 %1, %2
  %gcdept.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 16
  %4 = load i64, ptr %gcdept.i, align 8
  %add.i = add i64 %sub.i, %4
  store i64 %add.i, ptr %gcdept.i, align 8
  %gcstate.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 4
  br label %do.body.i

do.body.i:                                        ; preds = %do.body.i, %if.then
  %lim.0.i = phi i64 [ %spec.store.select.i, %if.then ], [ %sub2.i, %do.body.i ]
  %call.i = tail call fastcc i64 @singlestep(ptr noundef %L)
  %sub2.i = sub nsw i64 %lim.0.i, %call.i
  %5 = load i8, ptr %gcstate.i, align 1
  %cmp4.i = icmp ne i8 %5, 0
  %cmp8.i = icmp sgt i64 %sub2.i, 0
  %or.cond.i = select i1 %cmp4.i, i1 %cmp8.i, i1 false
  br i1 %or.cond.i, label %do.body.i, label %do.end.i, !llvm.loop !6

do.end.i:                                         ; preds = %do.body.i
  br i1 %cmp4.i, label %if.then14.i, label %if.else27.i

if.then14.i:                                      ; preds = %do.end.i
  %6 = load i64, ptr %gcdept.i, align 8
  %cmp16.i = icmp ult i64 %6, 1024
  br i1 %cmp16.i, label %if.then18.i, label %if.else.i

if.then18.i:                                      ; preds = %if.then14.i
  %7 = load i64, ptr %totalbytes, align 8
  %add20.i = add i64 %7, 1024
  br label %luaC_step.exit

if.else.i:                                        ; preds = %if.then14.i
  %sub23.i = add i64 %6, -1024
  store i64 %sub23.i, ptr %gcdept.i, align 8
  %8 = load i64, ptr %totalbytes, align 8
  br label %luaC_step.exit

if.else27.i:                                      ; preds = %do.end.i
  %estimate.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 15
  %9 = load i64, ptr %estimate.i, align 8
  %div.i = udiv i64 %9, 100
  %gcpause.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 17
  %10 = load i32, ptr %gcpause.i, align 8
  %conv28.i = sext i32 %10 to i64
  %mul29.i = mul i64 %div.i, %conv28.i
  br label %luaC_step.exit

luaC_step.exit:                                   ; preds = %if.then18.i, %if.else.i, %if.else27.i
  %add20.sink.i = phi i64 [ %add20.i, %if.then18.i ], [ %8, %if.else.i ], [ %mul29.i, %if.else27.i ]
  store i64 %add20.sink.i, ptr %GCthreshold, align 8
  br label %if.end

if.end:                                           ; preds = %luaC_step.exit, %entry
  %ci.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %11 = load ptr, ptr %ci.i, align 8
  %base_ci.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 12
  %12 = load ptr, ptr %base_ci.i, align 8
  %cmp.i9 = icmp eq ptr %11, %12
  br i1 %cmp.i9, label %if.then.i, label %if.else.i10

if.then.i:                                        ; preds = %if.end
  %l_gt.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 22
  br label %getcurrenv.exit

if.else.i10:                                      ; preds = %if.end
  %func2.i = getelementptr inbounds %struct.CallInfo, ptr %11, i64 0, i32 1
  %13 = load ptr, ptr %func2.i, align 8
  %14 = load ptr, ptr %13, align 8
  %env.i = getelementptr inbounds %struct.CClosure, ptr %14, i64 0, i32 6
  br label %getcurrenv.exit

getcurrenv.exit:                                  ; preds = %if.then.i, %if.else.i10
  %retval.0.in.i = phi ptr [ %l_gt.i, %if.then.i ], [ %env.i, %if.else.i10 ]
  %retval.0.i = load ptr, ptr %retval.0.in.i, align 8
  %add.i11 = add nuw nsw i64 %size, 40
  %15 = load ptr, ptr %l_G, align 8
  %frealloc.i.i = getelementptr inbounds %struct.global_State, ptr %15, i64 0, i32 1
  %16 = load ptr, ptr %frealloc.i.i, align 8
  %ud.i.i = getelementptr inbounds %struct.global_State, ptr %15, i64 0, i32 2
  %17 = load ptr, ptr %ud.i.i, align 8
  %call.i.i = tail call ptr %16(ptr noundef %17, ptr noundef null, i64 noundef 0, i64 noundef %add.i11) #35
  %cmp.i.i = icmp eq ptr %call.i.i, null
  br i1 %cmp.i.i, label %if.then.i.i, label %luaS_newudata.exit

if.then.i.i:                                      ; preds = %getcurrenv.exit
  %errorJmp.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 26
  %18 = load ptr, ptr %errorJmp.i.i.i, align 8
  %tobool.not.i.i.i = icmp eq ptr %18, null
  br i1 %tobool.not.i.i.i, label %if.else.i.i.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %if.then.i.i
  %status.i.i.i = getelementptr inbounds %struct.lua_longjmp, ptr %18, i64 0, i32 2
  store volatile i32 4, ptr %status.i.i.i, align 8
  %19 = load ptr, ptr %errorJmp.i.i.i, align 8
  %b.i.i.i = getelementptr inbounds %struct.lua_longjmp, ptr %19, i64 0, i32 1
  tail call void @longjmp(ptr noundef nonnull %b.i.i.i, i32 noundef 1) #38
  unreachable

if.else.i.i.i:                                    ; preds = %if.then.i.i
  %status3.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 3
  store i8 4, ptr %status3.i.i.i, align 2
  %20 = load ptr, ptr %l_G, align 8
  %panic.i.i.i = getelementptr inbounds %struct.global_State, ptr %20, i64 0, i32 19
  %21 = load ptr, ptr %panic.i.i.i, align 8
  %tobool4.not.i.i.i = icmp eq ptr %21, null
  br i1 %tobool4.not.i.i.i, label %if.end.i.i.i, label %if.then5.i.i.i

if.then5.i.i.i:                                   ; preds = %if.else.i.i.i
  tail call fastcc void @resetstack(ptr noundef nonnull %L, i32 noundef 4)
  %22 = load ptr, ptr %l_G, align 8
  %panic7.i.i.i = getelementptr inbounds %struct.global_State, ptr %22, i64 0, i32 19
  %23 = load ptr, ptr %panic7.i.i.i, align 8
  %call.i.i.i = tail call i32 %23(ptr noundef nonnull %L) #35
  br label %if.end.i.i.i

if.end.i.i.i:                                     ; preds = %if.then5.i.i.i, %if.else.i.i.i
  tail call void @exit(i32 noundef 1) #38
  unreachable

luaS_newudata.exit:                               ; preds = %getcurrenv.exit
  %totalbytes.i.i = getelementptr inbounds %struct.global_State, ptr %15, i64 0, i32 14
  %24 = load i64, ptr %totalbytes.i.i, align 8
  %add.i.i = add i64 %24, %add.i11
  store i64 %add.i.i, ptr %totalbytes.i.i, align 8
  %25 = load ptr, ptr %l_G, align 8
  %currentwhite.i = getelementptr inbounds %struct.global_State, ptr %25, i64 0, i32 3
  %26 = load i8, ptr %currentwhite.i, align 8
  %27 = and i8 %26, 3
  %marked.i = getelementptr inbounds %struct.anon.1, ptr %call.i.i, i64 0, i32 2
  store i8 %27, ptr %marked.i, align 1
  %tt.i = getelementptr inbounds %struct.anon.1, ptr %call.i.i, i64 0, i32 1
  store i8 7, ptr %tt.i, align 8
  %len.i = getelementptr inbounds %struct.anon.1, ptr %call.i.i, i64 0, i32 5
  store i64 %size, ptr %len.i, align 8
  %metatable.i = getelementptr inbounds %struct.anon.1, ptr %call.i.i, i64 0, i32 3
  store ptr null, ptr %metatable.i, align 8
  %env.i12 = getelementptr inbounds %struct.anon.1, ptr %call.i.i, i64 0, i32 4
  store ptr %retval.0.i, ptr %env.i12, align 8
  %28 = load ptr, ptr %l_G, align 8
  %mainthread.i = getelementptr inbounds %struct.global_State, ptr %28, i64 0, i32 21
  %29 = load ptr, ptr %mainthread.i, align 8
  %30 = load ptr, ptr %29, align 8
  store ptr %30, ptr %call.i.i, align 8
  %31 = load ptr, ptr %l_G, align 8
  %mainthread6.i = getelementptr inbounds %struct.global_State, ptr %31, i64 0, i32 21
  %32 = load ptr, ptr %mainthread6.i, align 8
  store ptr %call.i.i, ptr %32, align 8
  %top = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %33 = load ptr, ptr %top, align 8
  store ptr %call.i.i, ptr %33, align 8
  %tt = getelementptr inbounds %struct.lua_TValue, ptr %33, i64 0, i32 1
  store i32 7, ptr %tt, align 8
  %34 = load ptr, ptr %top, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue, ptr %34, i64 1
  store ptr %incdec.ptr, ptr %top, align 8
  %add.ptr = getelementptr inbounds %union.Udata, ptr %call.i.i, i64 1
  ret ptr %add.ptr
}

; Function Attrs: nounwind uwtable
define internal i32 @tconcat(ptr noundef %L) #0 {
entry:
  %s.i.i = alloca [32 x i8], align 16
  %s.i.i.i = alloca [32 x i8], align 16
  %endptr.i.i.i60 = alloca ptr, align 8
  %endptr.i.i.i = alloca ptr, align 8
  %b = alloca %struct.luaL_Buffer, align 8
  %lsep = alloca i64, align 8
  %base.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i.i, align 8
  %add.ptr.i.i.i = getelementptr %struct.lua_TValue, ptr %0, i64 1
  %top.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i.i = icmp uge ptr %add.ptr.i.i.i, %1
  %cmp.i.i = icmp eq ptr %add.ptr.i.i.i, @luaO_nilobject_
  %or.cond = or i1 %cmp1.not.i.i.i, %cmp.i.i
  br i1 %or.cond, label %if.then.i, label %lua_type.exit.i

lua_type.exit.i:                                  ; preds = %entry
  %tt.i.i = getelementptr %struct.lua_TValue, ptr %0, i64 1, i32 1
  %2 = load i32, ptr %tt.i.i, align 8
  %cmp.i = icmp slt i32 %2, 1
  br i1 %cmp.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %lua_type.exit.i, %entry
  store i64 0, ptr %lsep, align 8
  br label %luaL_optlstring.exit

if.else.i:                                        ; preds = %lua_type.exit.i
  %call.i.i = call fastcc ptr @lua_tolstring(ptr noundef nonnull %L, i32 noundef 2, ptr noundef nonnull %lsep)
  %tobool.not.i.i = icmp eq ptr %call.i.i, null
  br i1 %tobool.not.i.i, label %if.then.i.i, label %if.else.i.luaL_optlstring.exit_crit_edge

if.else.i.luaL_optlstring.exit_crit_edge:         ; preds = %if.else.i
  %.pre = load ptr, ptr %base.i.i.i, align 8
  %.pre170 = load ptr, ptr %top.i.i.i, align 8
  br label %luaL_optlstring.exit

if.then.i.i:                                      ; preds = %if.else.i
  call fastcc void @luaL_typerror(ptr noundef nonnull %L, i32 noundef 2, ptr noundef nonnull @.str.25)
  unreachable

luaL_optlstring.exit:                             ; preds = %if.else.i.luaL_optlstring.exit_crit_edge, %if.then.i
  %3 = phi ptr [ %1, %if.then.i ], [ %.pre170, %if.else.i.luaL_optlstring.exit_crit_edge ]
  %4 = phi ptr [ %0, %if.then.i ], [ %.pre, %if.else.i.luaL_optlstring.exit_crit_edge ]
  %retval.0.i = phi ptr [ @.str.7, %if.then.i ], [ %call.i.i, %if.else.i.luaL_optlstring.exit_crit_edge ]
  %cmp1.not.i.i.i17 = icmp uge ptr %4, %3
  %cmp.i.i21 = icmp eq ptr %4, @luaO_nilobject_
  %or.cond155 = or i1 %cmp.i.i21, %cmp1.not.i.i.i17
  br i1 %or.cond155, label %if.then.i19, label %lua_type.exit.i18

lua_type.exit.i18:                                ; preds = %luaL_optlstring.exit
  %tt.i.i22 = getelementptr inbounds %struct.lua_TValue, ptr %4, i64 0, i32 1
  %5 = load i32, ptr %tt.i.i22, align 8
  %cmp.not.i = icmp eq i32 %5, 5
  br i1 %cmp.not.i, label %luaL_checktype.exit, label %if.then.i19

if.then.i19:                                      ; preds = %luaL_optlstring.exit, %lua_type.exit.i18
  call fastcc void @luaL_typerror(ptr noundef nonnull %L, i32 noundef 1, ptr noundef nonnull @.str.26)
  unreachable

luaL_checktype.exit:                              ; preds = %lua_type.exit.i18
  %add.ptr.i.i.i24 = getelementptr %struct.lua_TValue, ptr %4, i64 2
  %cmp1.not.i.i.i26 = icmp uge ptr %add.ptr.i.i.i24, %3
  %cmp.i.i28 = icmp eq ptr %add.ptr.i.i.i24, @luaO_nilobject_
  %or.cond156 = or i1 %cmp1.not.i.i.i26, %cmp.i.i28
  br i1 %or.cond156, label %luaL_optinteger.exit, label %lua_type.exit.i29

lua_type.exit.i29:                                ; preds = %luaL_checktype.exit
  %tt.i.i30 = getelementptr %struct.lua_TValue, ptr %4, i64 2, i32 1
  %6 = load i32, ptr %tt.i.i30, align 8
  %cmp.i31 = icmp slt i32 %6, 1
  br i1 %cmp.i31, label %luaL_optinteger.exit, label %cond.false.i

cond.false.i:                                     ; preds = %lua_type.exit.i29
  %call.i.i32 = call fastcc i64 @lua_tointeger(ptr noundef nonnull %L, i32 noundef 3)
  %cmp.i3.i = icmp eq i64 %call.i.i32, 0
  br i1 %cmp.i3.i, label %land.lhs.true.i.i, label %luaL_optinteger.exit

land.lhs.true.i.i:                                ; preds = %cond.false.i
  %7 = load ptr, ptr %base.i.i.i, align 8
  %add.ptr.i.i53 = getelementptr %struct.lua_TValue, ptr %7, i64 2
  %8 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i55 = icmp ult ptr %add.ptr.i.i53, %8
  %add.ptr.luaO_nilobject_.i.i = select i1 %cmp1.not.i.i55, ptr %add.ptr.i.i53, ptr @luaO_nilobject_
  %tt.i57 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i, i64 0, i32 1
  %9 = load i32, ptr %tt.i57, align 8
  switch i32 %9, label %if.then.i.i35 [
    i32 3, label %luaL_optinteger.exit
    i32 4, label %land.lhs.true.i.i58
  ]

land.lhs.true.i.i58:                              ; preds = %land.lhs.true.i.i
  %10 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i, align 8
  %add.ptr.i3.i = getelementptr inbounds %union.TString, ptr %10, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i.i)
  %call.i.i.i = call double @strtod(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i) #35
  %11 = load ptr, ptr %endptr.i.i.i, align 8
  %cmp.i.i.i = icmp eq ptr %11, %add.ptr.i3.i
  br i1 %cmp.i.i.i, label %luaO_str2d.exit.thread.i.i, label %if.end.i.i.i

luaO_str2d.exit.thread.i.i:                       ; preds = %land.lhs.true.i.i58
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %if.then.i.i35

if.end.i.i.i:                                     ; preds = %land.lhs.true.i.i58
  %12 = load i8, ptr %11, align 1
  switch i8 %12, label %if.end9.i.i.i [
    i8 120, label %if.then6.i.i.i
    i8 88, label %if.then6.i.i.i
  ]

if.then6.i.i.i:                                   ; preds = %if.end.i.i.i, %if.end.i.i.i
  %call7.i.i.i = call i64 @strtoul(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i, i32 noundef 16) #35
  %.pre.i.i.i = load ptr, ptr %endptr.i.i.i, align 8
  %.pre5.i.i.i = load i8, ptr %.pre.i.i.i, align 1
  br label %if.end9.i.i.i

if.end9.i.i.i:                                    ; preds = %if.then6.i.i.i, %if.end.i.i.i
  %13 = phi i8 [ %12, %if.end.i.i.i ], [ %.pre5.i.i.i, %if.then6.i.i.i ]
  %endptr.promoted.i.i.i = phi ptr [ %11, %if.end.i.i.i ], [ %.pre.i.i.i, %if.then6.i.i.i ]
  %cmp11.i.i.i = icmp eq i8 %13, 0
  br i1 %cmp11.i.i.i, label %luaO_str2d.exit.thread9.i.i, label %while.cond.preheader.i.i.i

luaO_str2d.exit.thread9.i.i:                      ; preds = %if.end9.i.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %luaL_optinteger.exit

while.cond.preheader.i.i.i:                       ; preds = %if.end9.i.i.i
  %call15.i.i.i = tail call ptr @__ctype_b_loc() #39
  %14 = load ptr, ptr %call15.i.i.i, align 8
  br label %while.cond.i.i.i

while.cond.i.i.i:                                 ; preds = %while.cond.i.i.i, %while.cond.preheader.i.i.i
  %incdec.ptr4.i.i.i = phi ptr [ %endptr.promoted.i.i.i, %while.cond.preheader.i.i.i ], [ %incdec.ptr.i.i.i, %while.cond.i.i.i ]
  %15 = load i8, ptr %incdec.ptr4.i.i.i, align 1
  %idxprom.i.i.i = zext i8 %15 to i64
  %arrayidx.i.i.i = getelementptr inbounds i16, ptr %14, i64 %idxprom.i.i.i
  %16 = load i16, ptr %arrayidx.i.i.i, align 2
  %17 = and i16 %16, 8192
  %tobool.not.i.i.i = icmp eq i16 %17, 0
  %incdec.ptr.i.i.i = getelementptr inbounds i8, ptr %incdec.ptr4.i.i.i, i64 1
  br i1 %tobool.not.i.i.i, label %luaO_str2d.exit.i.i, label %while.cond.i.i.i, !llvm.loop !35

luaO_str2d.exit.i.i:                              ; preds = %while.cond.i.i.i
  %cmp19.not.i.not.i.i = icmp eq i8 %15, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br i1 %cmp19.not.i.not.i.i, label %luaL_optinteger.exit, label %if.then.i.i35

if.then.i.i35:                                    ; preds = %land.lhs.true.i.i, %luaO_str2d.exit.i.i, %luaO_str2d.exit.thread.i.i
  call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 3, ptr noundef nonnull @.str.24)
  unreachable

luaL_optinteger.exit:                             ; preds = %luaO_str2d.exit.thread9.i.i, %luaO_str2d.exit.i.i, %land.lhs.true.i.i, %luaL_checktype.exit, %lua_type.exit.i29, %cond.false.i
  %cond.i = phi i64 [ 1, %lua_type.exit.i29 ], [ %call.i.i32, %cond.false.i ], [ 1, %luaL_checktype.exit ], [ 0, %land.lhs.true.i.i ], [ 0, %luaO_str2d.exit.i.i ], [ 0, %luaO_str2d.exit.thread9.i.i ]
  %conv = trunc i64 %cond.i to i32
  %18 = load ptr, ptr %base.i.i.i, align 8
  %add.ptr.i.i = getelementptr %struct.lua_TValue, ptr %18, i64 3
  %19 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i = icmp uge ptr %add.ptr.i.i, %19
  %cmp.i39 = icmp eq ptr %add.ptr.i.i, @luaO_nilobject_
  %or.cond157 = or i1 %cmp1.not.i.i, %cmp.i39
  br i1 %or.cond157, label %cond.true, label %lua_type.exit

lua_type.exit:                                    ; preds = %luaL_optinteger.exit
  %tt.i = getelementptr %struct.lua_TValue, ptr %18, i64 3, i32 1
  %20 = load i32, ptr %tt.i, align 8
  %cmp = icmp slt i32 %20, 1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %luaL_optinteger.exit, %lua_type.exit
  %call4 = call fastcc i64 @lua_objlen(ptr noundef nonnull %L, i32 noundef 1)
  br label %cond.end

cond.false:                                       ; preds = %lua_type.exit
  %call.i = call fastcc i64 @lua_tointeger(ptr noundef nonnull %L, i32 noundef 4)
  %cmp.i41 = icmp eq i64 %call.i, 0
  br i1 %cmp.i41, label %land.lhs.true.i, label %cond.end

land.lhs.true.i:                                  ; preds = %cond.false
  %21 = load ptr, ptr %base.i.i.i, align 8
  %add.ptr.i.i63 = getelementptr %struct.lua_TValue, ptr %21, i64 3
  %22 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i65 = icmp ult ptr %add.ptr.i.i63, %22
  %add.ptr.luaO_nilobject_.i.i66 = select i1 %cmp1.not.i.i65, ptr %add.ptr.i.i63, ptr @luaO_nilobject_
  %tt.i68 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i66, i64 0, i32 1
  %23 = load i32, ptr %tt.i68, align 8
  switch i32 %23, label %if.then.i42 [
    i32 3, label %cond.end
    i32 4, label %land.lhs.true.i.i69
  ]

land.lhs.true.i.i69:                              ; preds = %land.lhs.true.i
  %24 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i66, align 8
  %add.ptr.i3.i70 = getelementptr inbounds %union.TString, ptr %24, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i.i60)
  %call.i.i.i71 = call double @strtod(ptr noundef nonnull %add.ptr.i3.i70, ptr noundef nonnull %endptr.i.i.i60) #35
  %25 = load ptr, ptr %endptr.i.i.i60, align 8
  %cmp.i.i.i72 = icmp eq ptr %25, %add.ptr.i3.i70
  br i1 %cmp.i.i.i72, label %luaO_str2d.exit.thread.i.i95, label %if.end.i.i.i73

luaO_str2d.exit.thread.i.i95:                     ; preds = %land.lhs.true.i.i69
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i60)
  br label %if.then.i42

if.end.i.i.i73:                                   ; preds = %land.lhs.true.i.i69
  %26 = load i8, ptr %25, align 1
  switch i8 %26, label %if.end9.i.i.i78 [
    i8 120, label %if.then6.i.i.i74
    i8 88, label %if.then6.i.i.i74
  ]

if.then6.i.i.i74:                                 ; preds = %if.end.i.i.i73, %if.end.i.i.i73
  %call7.i.i.i75 = call i64 @strtoul(ptr noundef nonnull %add.ptr.i3.i70, ptr noundef nonnull %endptr.i.i.i60, i32 noundef 16) #35
  %.pre.i.i.i76 = load ptr, ptr %endptr.i.i.i60, align 8
  %.pre5.i.i.i77 = load i8, ptr %.pre.i.i.i76, align 1
  br label %if.end9.i.i.i78

if.end9.i.i.i78:                                  ; preds = %if.then6.i.i.i74, %if.end.i.i.i73
  %27 = phi i8 [ %26, %if.end.i.i.i73 ], [ %.pre5.i.i.i77, %if.then6.i.i.i74 ]
  %endptr.promoted.i.i.i79 = phi ptr [ %25, %if.end.i.i.i73 ], [ %.pre.i.i.i76, %if.then6.i.i.i74 ]
  %cmp11.i.i.i80 = icmp eq i8 %27, 0
  br i1 %cmp11.i.i.i80, label %luaO_str2d.exit.thread9.i.i94, label %while.cond.preheader.i.i.i81

luaO_str2d.exit.thread9.i.i94:                    ; preds = %if.end9.i.i.i78
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i60)
  br label %cond.end

while.cond.preheader.i.i.i81:                     ; preds = %if.end9.i.i.i78
  %call15.i.i.i82 = tail call ptr @__ctype_b_loc() #39
  %28 = load ptr, ptr %call15.i.i.i82, align 8
  br label %while.cond.i.i.i83

while.cond.i.i.i83:                               ; preds = %while.cond.i.i.i83, %while.cond.preheader.i.i.i81
  %incdec.ptr4.i.i.i84 = phi ptr [ %endptr.promoted.i.i.i79, %while.cond.preheader.i.i.i81 ], [ %incdec.ptr.i.i.i88, %while.cond.i.i.i83 ]
  %29 = load i8, ptr %incdec.ptr4.i.i.i84, align 1
  %idxprom.i.i.i85 = zext i8 %29 to i64
  %arrayidx.i.i.i86 = getelementptr inbounds i16, ptr %28, i64 %idxprom.i.i.i85
  %30 = load i16, ptr %arrayidx.i.i.i86, align 2
  %31 = and i16 %30, 8192
  %tobool.not.i.i.i87 = icmp eq i16 %31, 0
  %incdec.ptr.i.i.i88 = getelementptr inbounds i8, ptr %incdec.ptr4.i.i.i84, i64 1
  br i1 %tobool.not.i.i.i87, label %luaO_str2d.exit.i.i89, label %while.cond.i.i.i83, !llvm.loop !35

luaO_str2d.exit.i.i89:                            ; preds = %while.cond.i.i.i83
  %cmp19.not.i.not.i.i90 = icmp eq i8 %29, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i60)
  br i1 %cmp19.not.i.not.i.i90, label %cond.end, label %if.then.i42

if.then.i42:                                      ; preds = %land.lhs.true.i, %luaO_str2d.exit.i.i89, %luaO_str2d.exit.thread.i.i95
  call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 4, ptr noundef nonnull @.str.24)
  unreachable

cond.end:                                         ; preds = %luaO_str2d.exit.thread9.i.i94, %luaO_str2d.exit.i.i89, %cond.false, %land.lhs.true.i, %cond.true
  %cond.in = phi i64 [ %call4, %cond.true ], [ 0, %land.lhs.true.i ], [ %call.i, %cond.false ], [ 0, %luaO_str2d.exit.i.i89 ], [ 0, %luaO_str2d.exit.thread9.i.i94 ]
  %cond = trunc i64 %cond.in to i32
  %L1.i = getelementptr inbounds %struct.luaL_Buffer, ptr %b, i64 0, i32 2
  store ptr %L, ptr %L1.i, align 8
  %buffer.i = getelementptr inbounds %struct.luaL_Buffer, ptr %b, i64 0, i32 3
  store ptr %buffer.i, ptr %b, align 8
  %lvl.i = getelementptr inbounds %struct.luaL_Buffer, ptr %b, i64 0, i32 1
  store i32 0, ptr %lvl.i, align 8
  %cmp8162 = icmp slt i32 %conv, %cond
  br i1 %cmp8162, label %for.body.lr.ph, label %for.end

for.body.lr.ph:                                   ; preds = %cond.end
  %add.ptr.i = getelementptr inbounds %struct.luaL_Buffer, ptr %b, i64 1
  %sub.ptr.rhs.cast.i = ptrtoint ptr %buffer.i to i64
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %luaL_addlstring.exit
  %i.0163 = phi i32 [ %conv, %for.body.lr.ph ], [ %inc, %luaL_addlstring.exit ]
  call fastcc void @addfield(ptr noundef %L, ptr noundef nonnull %b, i32 noundef %i.0163)
  %32 = load i64, ptr %lsep, align 8
  %tobool.not5.i = icmp eq i64 %32, 0
  br i1 %tobool.not5.i, label %luaL_addlstring.exit, label %while.body.i

while.body.i:                                     ; preds = %for.body, %lor.end.i
  %dec7.in.i = phi i64 [ %dec7.i, %lor.end.i ], [ %32, %for.body ]
  %s.addr.06.i = phi ptr [ %incdec.ptr.i, %lor.end.i ], [ %retval.0.i, %for.body ]
  %dec7.i = add i64 %dec7.in.i, -1
  %33 = load ptr, ptr %b, align 8
  %cmp.i44 = icmp ult ptr %33, %add.ptr.i
  br i1 %cmp.i44, label %lor.end.i, label %if.else.i106

if.else.i106:                                     ; preds = %while.body.i
  %sub.ptr.lhs.cast.i = ptrtoint ptr %33 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %34 = load ptr, ptr %L1.i, align 8
  %l_G.i.i = getelementptr inbounds %struct.lua_State, ptr %34, i64 0, i32 6
  %35 = load ptr, ptr %l_G.i.i, align 8
  %totalbytes.i.i = getelementptr inbounds %struct.global_State, ptr %35, i64 0, i32 14
  %36 = load i64, ptr %totalbytes.i.i, align 8
  %GCthreshold.i.i = getelementptr inbounds %struct.global_State, ptr %35, i64 0, i32 13
  %37 = load i64, ptr %GCthreshold.i.i, align 8
  %cmp.not.i.i = icmp ult i64 %36, %37
  br i1 %cmp.not.i.i, label %if.then.i.i47, label %if.then.i.i108

if.then.i.i108:                                   ; preds = %if.else.i106
  %gcstepmul.i.i.i = getelementptr inbounds %struct.global_State, ptr %35, i64 0, i32 18
  %38 = load i32, ptr %gcstepmul.i.i.i, align 4
  %mul.i.i.i = mul i32 %38, 10
  %conv.i.i.i = zext i32 %mul.i.i.i to i64
  %cmp.i.i.i109 = icmp eq i32 %mul.i.i.i, 0
  %spec.store.select.i.i.i = select i1 %cmp.i.i.i109, i64 9223372036854775806, i64 %conv.i.i.i
  %sub.i.i.i = sub i64 %36, %37
  %gcdept.i.i.i = getelementptr inbounds %struct.global_State, ptr %35, i64 0, i32 16
  %39 = load i64, ptr %gcdept.i.i.i, align 8
  %add.i.i.i = add i64 %sub.i.i.i, %39
  store i64 %add.i.i.i, ptr %gcdept.i.i.i, align 8
  %gcstate.i.i.i = getelementptr inbounds %struct.global_State, ptr %35, i64 0, i32 4
  br label %do.body.i.i.i

do.body.i.i.i:                                    ; preds = %do.body.i.i.i, %if.then.i.i108
  %lim.0.i.i.i = phi i64 [ %spec.store.select.i.i.i, %if.then.i.i108 ], [ %sub2.i.i.i, %do.body.i.i.i ]
  %call.i.i.i110 = call fastcc i64 @singlestep(ptr noundef %34)
  %sub2.i.i.i = sub nsw i64 %lim.0.i.i.i, %call.i.i.i110
  %40 = load i8, ptr %gcstate.i.i.i, align 1
  %cmp4.i.i.i = icmp ne i8 %40, 0
  %cmp8.i.i.i = icmp sgt i64 %sub2.i.i.i, 0
  %or.cond.i.i.i = select i1 %cmp4.i.i.i, i1 %cmp8.i.i.i, i1 false
  br i1 %or.cond.i.i.i, label %do.body.i.i.i, label %do.end.i.i.i, !llvm.loop !6

do.end.i.i.i:                                     ; preds = %do.body.i.i.i
  br i1 %cmp4.i.i.i, label %if.then14.i.i.i, label %if.else27.i.i.i

if.then14.i.i.i:                                  ; preds = %do.end.i.i.i
  %41 = load i64, ptr %gcdept.i.i.i, align 8
  %cmp16.i.i.i = icmp ult i64 %41, 1024
  br i1 %cmp16.i.i.i, label %if.then18.i.i.i, label %if.else.i.i.i

if.then18.i.i.i:                                  ; preds = %if.then14.i.i.i
  %42 = load i64, ptr %totalbytes.i.i, align 8
  %add20.i.i.i = add i64 %42, 1024
  br label %luaC_step.exit.i.i

if.else.i.i.i:                                    ; preds = %if.then14.i.i.i
  %sub23.i.i.i = add i64 %41, -1024
  store i64 %sub23.i.i.i, ptr %gcdept.i.i.i, align 8
  %43 = load i64, ptr %totalbytes.i.i, align 8
  br label %luaC_step.exit.i.i

if.else27.i.i.i:                                  ; preds = %do.end.i.i.i
  %estimate.i.i.i = getelementptr inbounds %struct.global_State, ptr %35, i64 0, i32 15
  %44 = load i64, ptr %estimate.i.i.i, align 8
  %div.i.i.i = udiv i64 %44, 100
  %gcpause.i.i.i = getelementptr inbounds %struct.global_State, ptr %35, i64 0, i32 17
  %45 = load i32, ptr %gcpause.i.i.i, align 8
  %conv28.i.i.i = sext i32 %45 to i64
  %mul29.i.i.i = mul i64 %div.i.i.i, %conv28.i.i.i
  br label %luaC_step.exit.i.i

luaC_step.exit.i.i:                               ; preds = %if.else27.i.i.i, %if.else.i.i.i, %if.then18.i.i.i
  %add20.sink.i.i.i = phi i64 [ %add20.i.i.i, %if.then18.i.i.i ], [ %43, %if.else.i.i.i ], [ %mul29.i.i.i, %if.else27.i.i.i ]
  store i64 %add20.sink.i.i.i, ptr %GCthreshold.i.i, align 8
  br label %if.then.i.i47

if.then.i.i47:                                    ; preds = %luaC_step.exit.i.i, %if.else.i106
  %top.i.i111 = getelementptr inbounds %struct.lua_State, ptr %34, i64 0, i32 4
  %46 = load ptr, ptr %top.i.i111, align 8
  %call.i.i112 = call fastcc ptr @luaS_newlstr(ptr noundef %34, ptr noundef nonnull %buffer.i, i64 noundef %sub.ptr.sub.i)
  store ptr %call.i.i112, ptr %46, align 8
  %tt.i.i113 = getelementptr inbounds %struct.lua_TValue, ptr %46, i64 0, i32 1
  store i32 4, ptr %tt.i.i113, align 8
  %47 = load ptr, ptr %top.i.i111, align 8
  %incdec.ptr.i.i = getelementptr inbounds %struct.lua_TValue, ptr %47, i64 1
  store ptr %incdec.ptr.i.i, ptr %top.i.i111, align 8
  store ptr %buffer.i, ptr %b, align 8
  %48 = load i32, ptr %lvl.i, align 8
  %inc.i = add nsw i32 %48, 1
  store i32 %inc.i, ptr %lvl.i, align 8
  %cmp.i99 = icmp sgt i32 %48, 0
  br i1 %cmp.i99, label %if.then.i100, label %lor.end.i

if.then.i100:                                     ; preds = %if.then.i.i47
  %49 = load ptr, ptr %L1.i, align 8
  %top6.i.i.i = getelementptr inbounds %struct.lua_State, ptr %49, i64 0, i32 4
  %50 = load ptr, ptr %top6.i.i.i, align 8
  %add.ptr8.i.i.i = getelementptr inbounds %struct.lua_TValue, ptr %50, i64 -1
  %tt.i.i102 = getelementptr %struct.lua_TValue, ptr %50, i64 -1, i32 1
  %51 = load i32, ptr %tt.i.i102, align 8
  switch i32 %51, label %lua_objlen.exit.i [
    i32 4, label %sw.bb.i.i
    i32 7, label %sw.bb1.i.i
    i32 5, label %sw.bb4.i.i
    i32 3, label %cond.true.i.i
  ]

sw.bb.i.i:                                        ; preds = %if.then.i100
  %52 = load ptr, ptr %add.ptr8.i.i.i, align 8
  %len.i.i = getelementptr inbounds %struct.anon.0, ptr %52, i64 0, i32 5
  %53 = load i64, ptr %len.i.i, align 8
  br label %lua_objlen.exit.i

sw.bb1.i.i:                                       ; preds = %if.then.i100
  %54 = load ptr, ptr %add.ptr8.i.i.i, align 8
  %len3.i.i = getelementptr inbounds %struct.anon.1, ptr %54, i64 0, i32 5
  %55 = load i64, ptr %len3.i.i, align 8
  br label %lua_objlen.exit.i

sw.bb4.i.i:                                       ; preds = %if.then.i100
  %56 = load ptr, ptr %add.ptr8.i.i.i, align 8
  %call6.i.i = call fastcc i32 @luaH_getn(ptr noundef %56)
  %conv.i.i = sext i32 %call6.i.i to i64
  br label %lua_objlen.exit.i

cond.true.i.i:                                    ; preds = %if.then.i100
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %s.i.i.i)
  %57 = load double, ptr %add.ptr8.i.i.i, align 8
  %call.i.i.i103 = call i32 (ptr, ptr, ...) @sprintf(ptr noundef nonnull dereferenceable(1) %s.i.i.i, ptr noundef nonnull dereferenceable(1) @.str.16, double noundef %57) #35
  %call3.i.i.i = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %s.i.i.i) #34
  %call4.i.i.i = call fastcc ptr @luaS_newlstr(ptr noundef nonnull %49, ptr noundef nonnull %s.i.i.i, i64 noundef %call3.i.i.i)
  store ptr %call4.i.i.i, ptr %add.ptr8.i.i.i, align 8
  store i32 4, ptr %tt.i.i102, align 8
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %s.i.i.i)
  %len10.i.i = getelementptr inbounds %struct.anon.0, ptr %call4.i.i.i, i64 0, i32 5
  %58 = load i64, ptr %len10.i.i, align 8
  br label %lua_objlen.exit.i

lua_objlen.exit.i:                                ; preds = %cond.true.i.i, %sw.bb4.i.i, %sw.bb1.i.i, %sw.bb.i.i, %if.then.i100
  %retval.0.i.i = phi i64 [ %conv.i.i, %sw.bb4.i.i ], [ %55, %sw.bb1.i.i ], [ %53, %sw.bb.i.i ], [ %58, %cond.true.i.i ], [ 0, %if.then.i100 ]
  %l_gt.i.i = getelementptr inbounds %struct.lua_State, ptr %49, i64 0, i32 22
  %ci.i.i = getelementptr inbounds %struct.lua_State, ptr %49, i64 0, i32 7
  %env.i.i = getelementptr inbounds %struct.lua_State, ptr %49, i64 0, i32 23
  %tt.i.i135 = getelementptr inbounds %struct.lua_State, ptr %49, i64 0, i32 23, i32 1
  %l_G.i.i137 = getelementptr inbounds %struct.lua_State, ptr %49, i64 0, i32 6
  br label %do.body.i

do.body.i:                                        ; preds = %if.then8.i, %lua_objlen.exit.i
  %indvars.iv = phi i64 [ %indvars.iv.next, %if.then8.i ], [ 1, %lua_objlen.exit.i ]
  %toplen.0.i = phi i64 [ %add9.i, %if.then8.i ], [ %retval.0.i.i, %lua_objlen.exit.i ]
  %indvars169 = trunc i64 %indvars.iv to i32
  %59 = xor i64 %indvars.iv, -1
  %cmp4.i.i128 = icmp ult i64 %indvars.iv, 9999
  br i1 %cmp4.i.i128, label %if.then5.i.i, label %if.else9.i.i

if.then5.i.i:                                     ; preds = %do.body.i
  %60 = load ptr, ptr %top6.i.i.i, align 8
  %add.ptr8.i.i = getelementptr inbounds %struct.lua_TValue, ptr %60, i64 %59
  br label %index2adr.exit.i129

if.else9.i.i:                                     ; preds = %do.body.i
  %61 = trunc i64 %59 to i32
  switch i32 %61, label %sw.default.i.i [
    i32 -10000, label %sw.bb.i.i136
    i32 -10001, label %sw.bb10.i.i
    i32 -10002, label %index2adr.exit.i129
  ]

sw.bb.i.i136:                                     ; preds = %if.else9.i.i
  %62 = load ptr, ptr %l_G.i.i137, align 8
  %l_registry.i.i = getelementptr inbounds %struct.global_State, ptr %62, i64 0, i32 20
  br label %index2adr.exit.i129

sw.bb10.i.i:                                      ; preds = %if.else9.i.i
  %63 = load ptr, ptr %ci.i.i, align 8
  %func11.i.i = getelementptr inbounds %struct.CallInfo, ptr %63, i64 0, i32 1
  %64 = load ptr, ptr %func11.i.i, align 8
  %65 = load ptr, ptr %64, align 8
  %env12.i.i = getelementptr inbounds %struct.CClosure, ptr %65, i64 0, i32 6
  %66 = load ptr, ptr %env12.i.i, align 8
  store ptr %66, ptr %env.i.i, align 8
  store i32 5, ptr %tt.i.i135, align 8
  br label %index2adr.exit.i129

sw.default.i.i:                                   ; preds = %if.else9.i.i
  %67 = load ptr, ptr %ci.i.i, align 8
  %func18.i.i = getelementptr inbounds %struct.CallInfo, ptr %67, i64 0, i32 1
  %68 = load ptr, ptr %func18.i.i, align 8
  %69 = load ptr, ptr %68, align 8
  %nupvalues.i.i = getelementptr inbounds %struct.CClosure, ptr %69, i64 0, i32 4
  %70 = load i8, ptr %nupvalues.i.i, align 1
  %conv.i.i138 = zext i8 %70 to i32
  %71 = trunc i64 %indvars.iv to i32
  %72 = add i32 %71, -10001
  %cmp21.not.i.i = icmp ugt i32 %72, %conv.i.i138
  %73 = add nsw i64 %indvars.iv, -10002
  %arrayidx.i.i = getelementptr inbounds %struct.CClosure, ptr %69, i64 0, i32 8, i64 %73
  %cond.i.i140 = select i1 %cmp21.not.i.i, ptr @luaO_nilobject_, ptr %arrayidx.i.i
  br label %index2adr.exit.i129

index2adr.exit.i129:                              ; preds = %if.else9.i.i, %sw.default.i.i, %sw.bb10.i.i, %sw.bb.i.i136, %if.then5.i.i
  %retval.0.i.i130 = phi ptr [ %add.ptr8.i.i, %if.then5.i.i ], [ %cond.i.i140, %sw.default.i.i ], [ %env.i.i, %sw.bb10.i.i ], [ %l_registry.i.i, %sw.bb.i.i136 ], [ %l_gt.i.i, %if.else9.i.i ]
  %tt.i131 = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i.i130, i64 0, i32 1
  %74 = load i32, ptr %tt.i131, align 8
  switch i32 %74, label %lua_objlen.exit [
    i32 4, label %sw.bb.i
    i32 7, label %sw.bb1.i
    i32 5, label %sw.bb4.i
    i32 3, label %cond.true.i
  ]

sw.bb.i:                                          ; preds = %index2adr.exit.i129
  %75 = load ptr, ptr %retval.0.i.i130, align 8
  %len.i = getelementptr inbounds %struct.anon.0, ptr %75, i64 0, i32 5
  %76 = load i64, ptr %len.i, align 8
  br label %lua_objlen.exit

sw.bb1.i:                                         ; preds = %index2adr.exit.i129
  %77 = load ptr, ptr %retval.0.i.i130, align 8
  %len3.i = getelementptr inbounds %struct.anon.1, ptr %77, i64 0, i32 5
  %78 = load i64, ptr %len3.i, align 8
  br label %lua_objlen.exit

sw.bb4.i:                                         ; preds = %index2adr.exit.i129
  %79 = load ptr, ptr %retval.0.i.i130, align 8
  %call6.i = call fastcc i32 @luaH_getn(ptr noundef %79)
  %conv.i134 = sext i32 %call6.i to i64
  br label %lua_objlen.exit

cond.true.i:                                      ; preds = %index2adr.exit.i129
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %s.i.i)
  %80 = load double, ptr %retval.0.i.i130, align 8
  %call.i.i132 = call i32 (ptr, ptr, ...) @sprintf(ptr noundef nonnull dereferenceable(1) %s.i.i, ptr noundef nonnull dereferenceable(1) @.str.16, double noundef %80) #35
  %call3.i.i = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %s.i.i) #34
  %call4.i.i = call fastcc ptr @luaS_newlstr(ptr noundef %49, ptr noundef nonnull %s.i.i, i64 noundef %call3.i.i)
  store ptr %call4.i.i, ptr %retval.0.i.i130, align 8
  store i32 4, ptr %tt.i131, align 8
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %s.i.i)
  %len10.i = getelementptr inbounds %struct.anon.0, ptr %call4.i.i, i64 0, i32 5
  %81 = load i64, ptr %len10.i, align 8
  br label %lua_objlen.exit

lua_objlen.exit:                                  ; preds = %index2adr.exit.i129, %sw.bb.i, %sw.bb1.i, %sw.bb4.i, %cond.true.i
  %retval.0.i133 = phi i64 [ %conv.i134, %sw.bb4.i ], [ %78, %sw.bb1.i ], [ %76, %sw.bb.i ], [ %81, %cond.true.i ], [ 0, %index2adr.exit.i129 ]
  %82 = load i32, ptr %lvl.i, align 8
  %sub4.i = sub i32 %82, %indvars169
  %cmp6.i = icmp sgt i32 %sub4.i, 8
  %cmp7.i = icmp ugt i64 %toplen.0.i, %retval.0.i133
  %or.cond.i = select i1 %cmp6.i, i1 true, i1 %cmp7.i
  br i1 %or.cond.i, label %if.then8.i, label %do.end.i

if.then8.i:                                       ; preds = %lua_objlen.exit
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %add9.i = add i64 %retval.0.i133, %toplen.0.i
  %83 = sext i32 %82 to i64
  %cmp11.i = icmp slt i64 %indvars.iv.next, %83
  br i1 %cmp11.i, label %do.body.i, label %if.then.i118.loopexit, !llvm.loop !128

do.end.i:                                         ; preds = %lua_objlen.exit
  %cmp.i116 = icmp ugt i32 %indvars169, 1
  br i1 %cmp.i116, label %if.then.i118, label %lua_concat.exit

if.then.i118.loopexit:                            ; preds = %if.then8.i
  %84 = trunc i64 %indvars.iv.next to i32
  br label %if.then.i118

if.then.i118:                                     ; preds = %if.then.i118.loopexit, %do.end.i
  %toget.1.i154 = phi i32 [ %indvars169, %do.end.i ], [ %84, %if.then.i118.loopexit ]
  %85 = load ptr, ptr %l_G.i.i137, align 8
  %totalbytes.i = getelementptr inbounds %struct.global_State, ptr %85, i64 0, i32 14
  %86 = load i64, ptr %totalbytes.i, align 8
  %GCthreshold.i = getelementptr inbounds %struct.global_State, ptr %85, i64 0, i32 13
  %87 = load i64, ptr %GCthreshold.i, align 8
  %cmp2.not.i = icmp ult i64 %86, %87
  br i1 %cmp2.not.i, label %if.end.i, label %if.then3.i

if.then3.i:                                       ; preds = %if.then.i118
  %gcstepmul.i.i = getelementptr inbounds %struct.global_State, ptr %85, i64 0, i32 18
  %88 = load i32, ptr %gcstepmul.i.i, align 4
  %mul.i.i = mul i32 %88, 10
  %conv.i.i119 = zext i32 %mul.i.i to i64
  %cmp.i.i120 = icmp eq i32 %mul.i.i, 0
  %spec.store.select.i.i = select i1 %cmp.i.i120, i64 9223372036854775806, i64 %conv.i.i119
  %sub.i.i = sub i64 %86, %87
  %gcdept.i.i = getelementptr inbounds %struct.global_State, ptr %85, i64 0, i32 16
  %89 = load i64, ptr %gcdept.i.i, align 8
  %add.i.i = add i64 %sub.i.i, %89
  store i64 %add.i.i, ptr %gcdept.i.i, align 8
  %gcstate.i.i = getelementptr inbounds %struct.global_State, ptr %85, i64 0, i32 4
  br label %do.body.i.i

do.body.i.i:                                      ; preds = %do.body.i.i, %if.then3.i
  %lim.0.i.i = phi i64 [ %spec.store.select.i.i, %if.then3.i ], [ %sub2.i.i, %do.body.i.i ]
  %call.i.i121 = call fastcc i64 @singlestep(ptr noundef %49)
  %sub2.i.i = sub nsw i64 %lim.0.i.i, %call.i.i121
  %90 = load i8, ptr %gcstate.i.i, align 1
  %cmp4.i.i = icmp ne i8 %90, 0
  %cmp8.i.i = icmp sgt i64 %sub2.i.i, 0
  %or.cond.i.i = select i1 %cmp4.i.i, i1 %cmp8.i.i, i1 false
  br i1 %or.cond.i.i, label %do.body.i.i, label %do.end.i.i, !llvm.loop !6

do.end.i.i:                                       ; preds = %do.body.i.i
  br i1 %cmp4.i.i, label %if.then14.i.i, label %if.else27.i.i

if.then14.i.i:                                    ; preds = %do.end.i.i
  %91 = load i64, ptr %gcdept.i.i, align 8
  %cmp16.i.i = icmp ult i64 %91, 1024
  br i1 %cmp16.i.i, label %if.then18.i.i, label %if.else.i.i

if.then18.i.i:                                    ; preds = %if.then14.i.i
  %92 = load i64, ptr %totalbytes.i, align 8
  %add20.i.i = add i64 %92, 1024
  br label %luaC_step.exit.i

if.else.i.i:                                      ; preds = %if.then14.i.i
  %sub23.i.i = add i64 %91, -1024
  store i64 %sub23.i.i, ptr %gcdept.i.i, align 8
  %93 = load i64, ptr %totalbytes.i, align 8
  br label %luaC_step.exit.i

if.else27.i.i:                                    ; preds = %do.end.i.i
  %estimate.i.i = getelementptr inbounds %struct.global_State, ptr %85, i64 0, i32 15
  %94 = load i64, ptr %estimate.i.i, align 8
  %div.i.i = udiv i64 %94, 100
  %gcpause.i.i = getelementptr inbounds %struct.global_State, ptr %85, i64 0, i32 17
  %95 = load i32, ptr %gcpause.i.i, align 8
  %conv28.i.i = sext i32 %95 to i64
  %mul29.i.i = mul i64 %div.i.i, %conv28.i.i
  br label %luaC_step.exit.i

luaC_step.exit.i:                                 ; preds = %if.else27.i.i, %if.else.i.i, %if.then18.i.i
  %add20.sink.i.i = phi i64 [ %add20.i.i, %if.then18.i.i ], [ %93, %if.else.i.i ], [ %mul29.i.i, %if.else27.i.i ]
  store i64 %add20.sink.i.i, ptr %GCthreshold.i, align 8
  br label %if.end.i

if.end.i:                                         ; preds = %luaC_step.exit.i, %if.then.i118
  %96 = load ptr, ptr %top6.i.i.i, align 8
  %base.i = getelementptr inbounds %struct.lua_State, ptr %49, i64 0, i32 5
  %97 = load ptr, ptr %base.i, align 8
  %sub.ptr.lhs.cast.i122 = ptrtoint ptr %96 to i64
  %sub.ptr.rhs.cast.i123 = ptrtoint ptr %97 to i64
  %sub.ptr.sub.i124 = sub i64 %sub.ptr.lhs.cast.i122, %sub.ptr.rhs.cast.i123
  %sub.ptr.div.i = lshr exact i64 %sub.ptr.sub.i124, 4
  %conv.i = trunc i64 %sub.ptr.div.i to i32
  %sub.i125 = add nsw i32 %conv.i, -1
  call fastcc void @luaV_concat(ptr noundef %49, i32 noundef %toget.1.i154, i32 noundef %sub.i125)
  %sub4.i126 = add nsw i32 %toget.1.i154, -1
  %98 = load ptr, ptr %top6.i.i.i, align 8
  %idx.ext.i = zext nneg i32 %sub4.i126 to i64
  %idx.neg.i = sub nsw i64 0, %idx.ext.i
  %add.ptr.i127 = getelementptr inbounds %struct.lua_TValue, ptr %98, i64 %idx.neg.i
  store ptr %add.ptr.i127, ptr %top6.i.i.i, align 8
  %.pre171 = load i32, ptr %lvl.i, align 8
  %.pre173 = sub i32 %.pre171, %toget.1.i154
  br label %lua_concat.exit

lua_concat.exit:                                  ; preds = %do.end.i, %if.end.i
  %reass.sub.pre-phi = phi i32 [ %sub4.i, %do.end.i ], [ %.pre173, %if.end.i ]
  %add14.i = add i32 %reass.sub.pre-phi, 1
  store i32 %add14.i, ptr %lvl.i, align 8
  %.pre172 = load ptr, ptr %b, align 8
  br label %lor.end.i

lor.end.i:                                        ; preds = %lua_concat.exit, %if.then.i.i47, %while.body.i
  %99 = phi ptr [ %.pre172, %lua_concat.exit ], [ %buffer.i, %if.then.i.i47 ], [ %33, %while.body.i ]
  %incdec.ptr.i = getelementptr inbounds i8, ptr %s.addr.06.i, i64 1
  %100 = load i8, ptr %s.addr.06.i, align 1
  %incdec.ptr3.i = getelementptr inbounds i8, ptr %99, i64 1
  store ptr %incdec.ptr3.i, ptr %b, align 8
  store i8 %100, ptr %99, align 1
  %tobool.not.i48 = icmp eq i64 %dec7.i, 0
  br i1 %tobool.not.i48, label %luaL_addlstring.exit, label %while.body.i, !llvm.loop !129

luaL_addlstring.exit:                             ; preds = %lor.end.i, %for.body
  %inc = add i32 %i.0163, 1
  %exitcond.not = icmp eq i32 %inc, %cond
  br i1 %exitcond.not, label %if.then, label %for.body, !llvm.loop !130

for.end:                                          ; preds = %cond.end
  %cmp10 = icmp eq i32 %conv, %cond
  br i1 %cmp10, label %if.then, label %if.end

if.then:                                          ; preds = %luaL_addlstring.exit, %for.end
  call fastcc void @addfield(ptr noundef %L, ptr noundef nonnull %b, i32 noundef %cond)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.end
  %call.i49 = call fastcc i32 @emptybuffer(ptr noundef nonnull %b), !range !23
  %101 = load ptr, ptr %L1.i, align 8
  %102 = load i32, ptr %lvl.i, align 8
  call fastcc void @lua_concat(ptr noundef %101, i32 noundef %102)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @tinsert(ptr noundef %L) #0 {
entry:
  %endptr.i.i.i = alloca ptr, align 8
  %base.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i.i, align 8
  %top.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i.i = icmp uge ptr %0, %1
  %cmp.i.i = icmp eq ptr %0, @luaO_nilobject_
  %or.cond = or i1 %cmp.i.i, %cmp1.not.i.i.i
  br i1 %or.cond, label %if.then.i, label %lua_type.exit.i

lua_type.exit.i:                                  ; preds = %entry
  %tt.i.i = getelementptr inbounds %struct.lua_TValue, ptr %0, i64 0, i32 1
  %2 = load i32, ptr %tt.i.i, align 8
  %cmp.not.i = icmp eq i32 %2, 5
  br i1 %cmp.not.i, label %luaL_checktype.exit, label %if.then.i

if.then.i:                                        ; preds = %entry, %lua_type.exit.i
  tail call fastcc void @luaL_typerror(ptr noundef nonnull %L, i32 noundef 1, ptr noundef nonnull @.str.26)
  unreachable

luaL_checktype.exit:                              ; preds = %lua_type.exit.i
  %call = tail call fastcc i64 @lua_objlen(ptr noundef nonnull %L, i32 noundef 1)
  %conv = trunc i64 %call to i32
  %add = add i32 %conv, 1
  %L.val = load ptr, ptr %top.i.i.i, align 8
  %L.val16 = load ptr, ptr %base.i.i.i, align 8
  %sub.ptr.lhs.cast.i = ptrtoint ptr %L.val to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %L.val16 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %sub.ptr.div.i = lshr exact i64 %sub.ptr.sub.i, 4
  %conv.i = trunc i64 %sub.ptr.div.i to i32
  switch i32 %conv.i, label %sw.default [
    i32 2, label %sw.epilog
    i32 3, label %sw.bb2
  ]

sw.bb2:                                           ; preds = %luaL_checktype.exit
  %call.i = tail call fastcc i64 @lua_tointeger(ptr noundef nonnull %L, i32 noundef 2)
  %cmp.i = icmp eq i64 %call.i, 0
  br i1 %cmp.i, label %land.lhs.true.i, label %luaL_checkinteger.exit

land.lhs.true.i:                                  ; preds = %sw.bb2
  %3 = load ptr, ptr %base.i.i.i, align 8
  %add.ptr.i.i20 = getelementptr %struct.lua_TValue, ptr %3, i64 1
  %4 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i22 = icmp ult ptr %add.ptr.i.i20, %4
  %add.ptr.luaO_nilobject_.i.i23 = select i1 %cmp1.not.i.i22, ptr %add.ptr.i.i20, ptr @luaO_nilobject_
  %tt.i24 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i23, i64 0, i32 1
  %5 = load i32, ptr %tt.i24, align 8
  switch i32 %5, label %if.then.i17 [
    i32 3, label %luaL_checkinteger.exit
    i32 4, label %land.lhs.true.i.i25
  ]

land.lhs.true.i.i25:                              ; preds = %land.lhs.true.i
  %6 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i23, align 8
  %add.ptr.i3.i = getelementptr inbounds %union.TString, ptr %6, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i.i)
  %call.i.i.i = call double @strtod(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i) #35
  %7 = load ptr, ptr %endptr.i.i.i, align 8
  %cmp.i.i.i26 = icmp eq ptr %7, %add.ptr.i3.i
  br i1 %cmp.i.i.i26, label %luaO_str2d.exit.thread.i.i, label %if.end.i.i.i27

luaO_str2d.exit.thread.i.i:                       ; preds = %land.lhs.true.i.i25
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %if.then.i17

if.end.i.i.i27:                                   ; preds = %land.lhs.true.i.i25
  %8 = load i8, ptr %7, align 1
  switch i8 %8, label %if.end9.i.i.i [
    i8 120, label %if.then6.i.i.i
    i8 88, label %if.then6.i.i.i
  ]

if.then6.i.i.i:                                   ; preds = %if.end.i.i.i27, %if.end.i.i.i27
  %call7.i.i.i = call i64 @strtoul(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i, i32 noundef 16) #35
  %.pre.i.i.i = load ptr, ptr %endptr.i.i.i, align 8
  %.pre5.i.i.i = load i8, ptr %.pre.i.i.i, align 1
  br label %if.end9.i.i.i

if.end9.i.i.i:                                    ; preds = %if.then6.i.i.i, %if.end.i.i.i27
  %9 = phi i8 [ %8, %if.end.i.i.i27 ], [ %.pre5.i.i.i, %if.then6.i.i.i ]
  %endptr.promoted.i.i.i = phi ptr [ %7, %if.end.i.i.i27 ], [ %.pre.i.i.i, %if.then6.i.i.i ]
  %cmp11.i.i.i = icmp eq i8 %9, 0
  br i1 %cmp11.i.i.i, label %luaO_str2d.exit.thread9.i.i, label %while.cond.preheader.i.i.i

luaO_str2d.exit.thread9.i.i:                      ; preds = %if.end9.i.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %luaL_checkinteger.exit

while.cond.preheader.i.i.i:                       ; preds = %if.end9.i.i.i
  %call15.i.i.i = tail call ptr @__ctype_b_loc() #39
  %10 = load ptr, ptr %call15.i.i.i, align 8
  br label %while.cond.i.i.i

while.cond.i.i.i:                                 ; preds = %while.cond.i.i.i, %while.cond.preheader.i.i.i
  %incdec.ptr4.i.i.i = phi ptr [ %endptr.promoted.i.i.i, %while.cond.preheader.i.i.i ], [ %incdec.ptr.i.i.i, %while.cond.i.i.i ]
  %11 = load i8, ptr %incdec.ptr4.i.i.i, align 1
  %idxprom.i.i.i = zext i8 %11 to i64
  %arrayidx.i.i.i = getelementptr inbounds i16, ptr %10, i64 %idxprom.i.i.i
  %12 = load i16, ptr %arrayidx.i.i.i, align 2
  %13 = and i16 %12, 8192
  %tobool.not.i.i.i = icmp eq i16 %13, 0
  %incdec.ptr.i.i.i = getelementptr inbounds i8, ptr %incdec.ptr4.i.i.i, i64 1
  br i1 %tobool.not.i.i.i, label %luaO_str2d.exit.i.i, label %while.cond.i.i.i, !llvm.loop !35

luaO_str2d.exit.i.i:                              ; preds = %while.cond.i.i.i
  %cmp19.not.i.not.i.i = icmp eq i8 %11, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br i1 %cmp19.not.i.not.i.i, label %luaL_checkinteger.exit, label %if.then.i17

if.then.i17:                                      ; preds = %land.lhs.true.i, %luaO_str2d.exit.i.i, %luaO_str2d.exit.thread.i.i
  tail call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 2, ptr noundef nonnull @.str.24)
  unreachable

luaL_checkinteger.exit:                           ; preds = %luaO_str2d.exit.thread9.i.i, %luaO_str2d.exit.i.i, %land.lhs.true.i, %sw.bb2
  %conv4 = trunc i64 %call.i to i32
  %cmp632.not = icmp slt i32 %conv, %conv4
  br i1 %cmp632.not, label %sw.epilog, label %for.body.preheader

for.body.preheader:                               ; preds = %luaL_checkinteger.exit
  %14 = sext i32 %add to i64
  %sext = shl i64 %call.i, 32
  %15 = ashr exact i64 %sext, 32
  %smax = tail call i64 @llvm.smax.i64(i64 %14, i64 %15)
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %lua_rawgeti.exit
  %indvars.iv = phi i64 [ %smax, %for.body.preheader ], [ %indvars.iv.next, %lua_rawgeti.exit ]
  %indvars.iv.next = add nsw i64 %indvars.iv, -1
  %16 = load ptr, ptr %base.i.i.i, align 8
  %17 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i = icmp ult ptr %16, %17
  %add.ptr.luaO_nilobject_.i.i = select i1 %cmp1.not.i.i, ptr %16, ptr @luaO_nilobject_
  %18 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i, align 8
  %19 = trunc i64 %indvars.iv to i32
  %sub.i.i = add i32 %19, -2
  %sizearray.i.i = getelementptr inbounds %struct.Table, ptr %18, i64 0, i32 10
  %20 = load i32, ptr %sizearray.i.i, align 8
  %cmp.i5.i = icmp ult i32 %sub.i.i, %20
  br i1 %cmp.i5.i, label %if.then.i9.i, label %if.else.i.i

if.then.i9.i:                                     ; preds = %for.body
  %array.i.i = getelementptr inbounds %struct.Table, ptr %18, i64 0, i32 6
  %21 = load ptr, ptr %array.i.i, align 8
  %idxprom.i10.i = sext i32 %sub.i.i to i64
  %arrayidx.i11.i = getelementptr inbounds %struct.lua_TValue, ptr %21, i64 %idxprom.i10.i
  br label %lua_rawgeti.exit

if.else.i.i:                                      ; preds = %for.body
  %22 = trunc i64 %indvars.iv.next to i32
  %conv.i6.i = sitofp i32 %22 to double
  %cmp.i.i.i = icmp eq i32 %22, 0
  br i1 %cmp.i.i.i, label %if.then.i.i.i, label %if.end.i.i.i

if.then.i.i.i:                                    ; preds = %if.else.i.i
  %node.i.i.i = getelementptr inbounds %struct.Table, ptr %18, i64 0, i32 7
  %23 = load ptr, ptr %node.i.i.i, align 8
  br label %do.body.i.i.preheader

if.end.i.i.i:                                     ; preds = %if.else.i.i
  %24 = bitcast double %conv.i6.i to i64
  %a.sroa.0.4.extract.shift.i.i.i = lshr i64 %24, 32
  %add.i.i.i = add i64 %a.sroa.0.4.extract.shift.i.i.i, %24
  %node4.i.i.i = getelementptr inbounds %struct.Table, ptr %18, i64 0, i32 7
  %25 = load ptr, ptr %node4.i.i.i, align 8
  %conv.i.i.i = and i64 %add.i.i.i, 4294967295
  %lsizenode.i.i.i = getelementptr inbounds %struct.Table, ptr %18, i64 0, i32 4
  %26 = load i8, ptr %lsizenode.i.i.i, align 1
  %sh_prom.i.i.i = zext nneg i8 %26 to i64
  %notmask.i.i.i = shl nsw i64 -1, %sh_prom.i.i.i
  %sub.i.i.i = xor i64 %notmask.i.i.i, -1
  %or.i.i.i = or i64 %sub.i.i.i, 1
  %rem.i.i.i = urem i64 %conv.i.i.i, %or.i.i.i
  %arrayidx7.i.i.i = getelementptr inbounds %struct.Node, ptr %25, i64 %rem.i.i.i
  br label %do.body.i.i.preheader

do.body.i.i.preheader:                            ; preds = %if.end.i.i.i, %if.then.i.i.i
  %n.0.i.i.ph = phi ptr [ %arrayidx7.i.i.i, %if.end.i.i.i ], [ %23, %if.then.i.i.i ]
  br label %do.body.i.i

do.body.i.i:                                      ; preds = %do.body.i.i.preheader, %if.else8.i.i
  %n.0.i.i = phi ptr [ %29, %if.else8.i.i ], [ %n.0.i.i.ph, %do.body.i.i.preheader ]
  %tt.i7.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1, i32 0, i32 1
  %27 = load i32, ptr %tt.i7.i, align 8
  %cmp2.i.i = icmp eq i32 %27, 3
  br i1 %cmp2.i.i, label %land.lhs.true.i.i, label %if.else8.i.i

land.lhs.true.i.i:                                ; preds = %do.body.i.i
  %i_key.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1
  %28 = load double, ptr %i_key.i.i, align 8
  %cmp5.i.i = fcmp oeq double %28, %conv.i6.i
  br i1 %cmp5.i.i, label %lua_rawgeti.exit, label %if.else8.i.i

if.else8.i.i:                                     ; preds = %land.lhs.true.i.i, %do.body.i.i
  %next.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1, i32 0, i32 2
  %29 = load ptr, ptr %next.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %29, null
  br i1 %tobool.not.i.i, label %lua_rawgeti.exit, label %do.body.i.i, !llvm.loop !7

lua_rawgeti.exit:                                 ; preds = %land.lhs.true.i.i, %if.else8.i.i, %if.then.i9.i
  %retval.0.i8.i = phi ptr [ %arrayidx.i11.i, %if.then.i9.i ], [ @luaO_nilobject_, %if.else8.i.i ], [ %n.0.i.i, %land.lhs.true.i.i ]
  %30 = load i64, ptr %retval.0.i8.i, align 8
  store i64 %30, ptr %17, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i8.i, i64 0, i32 1
  %31 = load i32, ptr %tt.i, align 8
  %tt4.i = getelementptr inbounds %struct.lua_TValue, ptr %17, i64 0, i32 1
  store i32 %31, ptr %tt4.i, align 8
  %32 = load ptr, ptr %top.i.i.i, align 8
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %32, i64 1
  store ptr %incdec.ptr.i, ptr %top.i.i.i, align 8
  tail call fastcc void @lua_rawseti(ptr noundef %L, i32 noundef 1, i32 noundef %19)
  %cmp6 = icmp sgt i64 %indvars.iv.next, %15
  br i1 %cmp6, label %for.body, label %sw.epilog, !llvm.loop !131

sw.default:                                       ; preds = %luaL_checktype.exit
  tail call void (ptr, ptr, ...) @luaL_error(ptr noundef nonnull %L, ptr noundef nonnull @.str.192)
  unreachable

sw.epilog:                                        ; preds = %lua_rawgeti.exit, %luaL_checkinteger.exit, %luaL_checktype.exit
  %pos.0 = phi i32 [ %add, %luaL_checktype.exit ], [ %conv4, %luaL_checkinteger.exit ], [ %conv4, %lua_rawgeti.exit ]
  tail call fastcc void @lua_rawseti(ptr noundef %L, i32 noundef 1, i32 noundef %pos.0)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @tremove(ptr noundef %L) #0 {
entry:
  %endptr.i.i.i = alloca ptr, align 8
  %base.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i.i, align 8
  %top.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i.i = icmp uge ptr %0, %1
  %cmp.i.i = icmp eq ptr %0, @luaO_nilobject_
  %or.cond95 = or i1 %cmp.i.i, %cmp1.not.i.i.i
  br i1 %or.cond95, label %if.then.i, label %lua_type.exit.i

lua_type.exit.i:                                  ; preds = %entry
  %tt.i.i = getelementptr inbounds %struct.lua_TValue, ptr %0, i64 0, i32 1
  %2 = load i32, ptr %tt.i.i, align 8
  %cmp.not.i = icmp eq i32 %2, 5
  br i1 %cmp.not.i, label %luaL_checktype.exit, label %if.then.i

if.then.i:                                        ; preds = %entry, %lua_type.exit.i
  tail call fastcc void @luaL_typerror(ptr noundef nonnull %L, i32 noundef 1, ptr noundef nonnull @.str.26)
  unreachable

luaL_checktype.exit:                              ; preds = %lua_type.exit.i
  %call = tail call fastcc i64 @lua_objlen(ptr noundef nonnull %L, i32 noundef 1)
  %conv = trunc i64 %call to i32
  %sext = shl i64 %call, 32
  %conv1 = ashr exact i64 %sext, 32
  %3 = load ptr, ptr %base.i.i.i, align 8
  %add.ptr.i.i.i18 = getelementptr %struct.lua_TValue, ptr %3, i64 1
  %4 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i.i20 = icmp uge ptr %add.ptr.i.i.i18, %4
  %cmp.i.i22 = icmp eq ptr %add.ptr.i.i.i18, @luaO_nilobject_
  %or.cond96 = or i1 %cmp1.not.i.i.i20, %cmp.i.i22
  br i1 %or.cond96, label %luaL_optinteger.exit, label %lua_type.exit.i23

lua_type.exit.i23:                                ; preds = %luaL_checktype.exit
  %tt.i.i24 = getelementptr %struct.lua_TValue, ptr %3, i64 1, i32 1
  %5 = load i32, ptr %tt.i.i24, align 8
  %cmp.i = icmp slt i32 %5, 1
  br i1 %cmp.i, label %luaL_optinteger.exit, label %cond.false.i

cond.false.i:                                     ; preds = %lua_type.exit.i23
  %call.i.i = tail call fastcc i64 @lua_tointeger(ptr noundef nonnull %L, i32 noundef 2)
  %cmp.i3.i = icmp eq i64 %call.i.i, 0
  br i1 %cmp.i3.i, label %land.lhs.true.i.i, label %luaL_optinteger.exit

land.lhs.true.i.i:                                ; preds = %cond.false.i
  %6 = load ptr, ptr %base.i.i.i, align 8
  %add.ptr.i.i78 = getelementptr %struct.lua_TValue, ptr %6, i64 1
  %7 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i80 = icmp ult ptr %add.ptr.i.i78, %7
  %add.ptr.luaO_nilobject_.i.i81 = select i1 %cmp1.not.i.i80, ptr %add.ptr.i.i78, ptr @luaO_nilobject_
  %tt.i82 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i81, i64 0, i32 1
  %8 = load i32, ptr %tt.i82, align 8
  switch i32 %8, label %if.then.i.i [
    i32 3, label %return
    i32 4, label %land.lhs.true.i.i83
  ]

land.lhs.true.i.i83:                              ; preds = %land.lhs.true.i.i
  %9 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i81, align 8
  %add.ptr.i3.i = getelementptr inbounds %union.TString, ptr %9, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i.i)
  %call.i.i.i = call double @strtod(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i) #35
  %10 = load ptr, ptr %endptr.i.i.i, align 8
  %cmp.i.i.i84 = icmp eq ptr %10, %add.ptr.i3.i
  br i1 %cmp.i.i.i84, label %luaO_str2d.exit.thread.i.i, label %if.end.i.i.i85

luaO_str2d.exit.thread.i.i:                       ; preds = %land.lhs.true.i.i83
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %if.then.i.i

if.end.i.i.i85:                                   ; preds = %land.lhs.true.i.i83
  %11 = load i8, ptr %10, align 1
  switch i8 %11, label %if.end9.i.i.i [
    i8 120, label %if.then6.i.i.i
    i8 88, label %if.then6.i.i.i
  ]

if.then6.i.i.i:                                   ; preds = %if.end.i.i.i85, %if.end.i.i.i85
  %call7.i.i.i = call i64 @strtoul(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i, i32 noundef 16) #35
  %.pre.i.i.i = load ptr, ptr %endptr.i.i.i, align 8
  %.pre5.i.i.i = load i8, ptr %.pre.i.i.i, align 1
  br label %if.end9.i.i.i

if.end9.i.i.i:                                    ; preds = %if.then6.i.i.i, %if.end.i.i.i85
  %12 = phi i8 [ %11, %if.end.i.i.i85 ], [ %.pre5.i.i.i, %if.then6.i.i.i ]
  %endptr.promoted.i.i.i = phi ptr [ %10, %if.end.i.i.i85 ], [ %.pre.i.i.i, %if.then6.i.i.i ]
  %cmp11.i.i.i = icmp eq i8 %12, 0
  br i1 %cmp11.i.i.i, label %luaO_str2d.exit.thread9.i.i, label %while.cond.preheader.i.i.i

luaO_str2d.exit.thread9.i.i:                      ; preds = %if.end9.i.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %return

while.cond.preheader.i.i.i:                       ; preds = %if.end9.i.i.i
  %call15.i.i.i = tail call ptr @__ctype_b_loc() #39
  %13 = load ptr, ptr %call15.i.i.i, align 8
  br label %while.cond.i.i.i

while.cond.i.i.i:                                 ; preds = %while.cond.i.i.i, %while.cond.preheader.i.i.i
  %incdec.ptr4.i.i.i = phi ptr [ %endptr.promoted.i.i.i, %while.cond.preheader.i.i.i ], [ %incdec.ptr.i.i.i, %while.cond.i.i.i ]
  %14 = load i8, ptr %incdec.ptr4.i.i.i, align 1
  %idxprom.i.i.i = zext i8 %14 to i64
  %arrayidx.i.i.i = getelementptr inbounds i16, ptr %13, i64 %idxprom.i.i.i
  %15 = load i16, ptr %arrayidx.i.i.i, align 2
  %16 = and i16 %15, 8192
  %tobool.not.i.i.i = icmp eq i16 %16, 0
  %incdec.ptr.i.i.i = getelementptr inbounds i8, ptr %incdec.ptr4.i.i.i, i64 1
  br i1 %tobool.not.i.i.i, label %luaO_str2d.exit.i.i, label %while.cond.i.i.i, !llvm.loop !35

luaO_str2d.exit.i.i:                              ; preds = %while.cond.i.i.i
  %cmp19.not.i.not.i.i = icmp eq i8 %14, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br i1 %cmp19.not.i.not.i.i, label %return, label %if.then.i.i

if.then.i.i:                                      ; preds = %land.lhs.true.i.i, %luaO_str2d.exit.i.i, %luaO_str2d.exit.thread.i.i
  tail call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 2, ptr noundef nonnull @.str.24)
  unreachable

luaL_optinteger.exit:                             ; preds = %luaL_checktype.exit, %lua_type.exit.i23, %cond.false.i
  %cond.i = phi i64 [ %conv1, %lua_type.exit.i23 ], [ %call.i.i, %cond.false.i ], [ %conv1, %luaL_checktype.exit ]
  %conv3 = trunc i64 %cond.i to i32
  %cmp = icmp slt i32 %conv3, 1
  %cmp5.not = icmp sgt i32 %conv3, %conv
  %or.cond = or i1 %cmp, %cmp5.not
  br i1 %or.cond, label %return, label %if.end

if.end:                                           ; preds = %luaL_optinteger.exit
  %17 = load ptr, ptr %base.i.i.i, align 8
  %18 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i = icmp ult ptr %17, %18
  %add.ptr.luaO_nilobject_.i.i = select i1 %cmp1.not.i.i, ptr %17, ptr @luaO_nilobject_
  %19 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i, align 8
  %sub.i.i = add nsw i32 %conv3, -1
  %sizearray.i.i = getelementptr inbounds %struct.Table, ptr %19, i64 0, i32 10
  %20 = load i32, ptr %sizearray.i.i, align 8
  %cmp.i5.i = icmp ult i32 %sub.i.i, %20
  br i1 %cmp.i5.i, label %if.then.i9.i, label %hashnum.exit.i.i

if.then.i9.i:                                     ; preds = %if.end
  %array.i.i = getelementptr inbounds %struct.Table, ptr %19, i64 0, i32 6
  %21 = load ptr, ptr %array.i.i, align 8
  %idxprom.i10.i = zext nneg i32 %sub.i.i to i64
  %arrayidx.i11.i = getelementptr inbounds %struct.lua_TValue, ptr %21, i64 %idxprom.i10.i
  br label %lua_rawgeti.exit

hashnum.exit.i.i:                                 ; preds = %if.end
  %conv.i6.i = sitofp i32 %conv3 to double
  %22 = bitcast double %conv.i6.i to i64
  %a.sroa.0.4.extract.shift.i.i.i = lshr i64 %22, 32
  %add.i.i.i = add i64 %a.sroa.0.4.extract.shift.i.i.i, %22
  %node4.i.i.i = getelementptr inbounds %struct.Table, ptr %19, i64 0, i32 7
  %23 = load ptr, ptr %node4.i.i.i, align 8
  %conv.i.i.i = and i64 %add.i.i.i, 4294967295
  %lsizenode.i.i.i = getelementptr inbounds %struct.Table, ptr %19, i64 0, i32 4
  %24 = load i8, ptr %lsizenode.i.i.i, align 1
  %sh_prom.i.i.i = zext nneg i8 %24 to i64
  %notmask.i.i.i = shl nsw i64 -1, %sh_prom.i.i.i
  %sub.i.i.i = xor i64 %notmask.i.i.i, -1
  %or.i.i.i = or i64 %sub.i.i.i, 1
  %rem.i.i.i = urem i64 %conv.i.i.i, %or.i.i.i
  %arrayidx7.i.i.i = getelementptr inbounds %struct.Node, ptr %23, i64 %rem.i.i.i
  br label %do.body.i.i

do.body.i.i:                                      ; preds = %if.else8.i.i, %hashnum.exit.i.i
  %n.0.i.i = phi ptr [ %arrayidx7.i.i.i, %hashnum.exit.i.i ], [ %27, %if.else8.i.i ]
  %tt.i7.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1, i32 0, i32 1
  %25 = load i32, ptr %tt.i7.i, align 8
  %cmp2.i.i = icmp eq i32 %25, 3
  br i1 %cmp2.i.i, label %land.lhs.true.i.i28, label %if.else8.i.i

land.lhs.true.i.i28:                              ; preds = %do.body.i.i
  %i_key.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1
  %26 = load double, ptr %i_key.i.i, align 8
  %cmp5.i.i = fcmp oeq double %26, %conv.i6.i
  br i1 %cmp5.i.i, label %lua_rawgeti.exit, label %if.else8.i.i

if.else8.i.i:                                     ; preds = %land.lhs.true.i.i28, %do.body.i.i
  %next.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1, i32 0, i32 2
  %27 = load ptr, ptr %next.i.i, align 8
  %tobool.not.i.i27 = icmp eq ptr %27, null
  br i1 %tobool.not.i.i27, label %lua_rawgeti.exit, label %do.body.i.i, !llvm.loop !7

lua_rawgeti.exit:                                 ; preds = %land.lhs.true.i.i28, %if.else8.i.i, %if.then.i9.i
  %retval.0.i8.i = phi ptr [ %arrayidx.i11.i, %if.then.i9.i ], [ @luaO_nilobject_, %if.else8.i.i ], [ %n.0.i.i, %land.lhs.true.i.i28 ]
  %28 = load i64, ptr %retval.0.i8.i, align 8
  store i64 %28, ptr %18, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i8.i, i64 0, i32 1
  %29 = load i32, ptr %tt.i, align 8
  %tt4.i = getelementptr inbounds %struct.lua_TValue, ptr %18, i64 0, i32 1
  store i32 %29, ptr %tt4.i, align 8
  %30 = load ptr, ptr %top.i.i.i, align 8
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %30, i64 1
  store ptr %incdec.ptr.i, ptr %top.i.i.i, align 8
  %cmp797 = icmp slt i32 %conv3, %conv
  br i1 %cmp797, label %for.body.preheader, label %for.end

for.body.preheader:                               ; preds = %lua_rawgeti.exit
  %sext101 = shl i64 %cond.i, 32
  %31 = ashr exact i64 %sext101, 32
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %lua_rawgeti.exit72
  %indvars.iv = phi i64 [ %31, %for.body.preheader ], [ %indvars.iv.next, %lua_rawgeti.exit72 ]
  %indvars.iv.next = add nsw i64 %indvars.iv, 1
  %32 = load ptr, ptr %base.i.i.i, align 8
  %33 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i33 = icmp ult ptr %32, %33
  %add.ptr.luaO_nilobject_.i.i34 = select i1 %cmp1.not.i.i33, ptr %32, ptr @luaO_nilobject_
  %34 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i34, align 8
  %sizearray.i.i35 = getelementptr inbounds %struct.Table, ptr %34, i64 0, i32 10
  %35 = load i32, ptr %sizearray.i.i35, align 8
  %36 = trunc i64 %indvars.iv to i32
  %cmp.i5.i36 = icmp ugt i32 %35, %36
  br i1 %cmp.i5.i36, label %if.then.i9.i68, label %if.else.i.i37

if.then.i9.i68:                                   ; preds = %for.body
  %array.i.i69 = getelementptr inbounds %struct.Table, ptr %34, i64 0, i32 6
  %37 = load ptr, ptr %array.i.i69, align 8
  %arrayidx.i11.i71 = getelementptr inbounds %struct.lua_TValue, ptr %37, i64 %indvars.iv
  %.pre100 = trunc i64 %indvars.iv.next to i32
  br label %lua_rawgeti.exit72

if.else.i.i37:                                    ; preds = %for.body
  %38 = trunc i64 %indvars.iv.next to i32
  %conv.i6.i38 = sitofp i32 %38 to double
  %39 = bitcast double %conv.i6.i38 to i64
  %a.sroa.0.4.extract.shift.i.i.i40 = lshr i64 %39, 32
  %add.i.i.i41 = add i64 %a.sroa.0.4.extract.shift.i.i.i40, %39
  %node4.i.i.i42 = getelementptr inbounds %struct.Table, ptr %34, i64 0, i32 7
  %40 = load ptr, ptr %node4.i.i.i42, align 8
  %conv.i.i.i43 = and i64 %add.i.i.i41, 4294967295
  %lsizenode.i.i.i44 = getelementptr inbounds %struct.Table, ptr %34, i64 0, i32 4
  %41 = load i8, ptr %lsizenode.i.i.i44, align 1
  %sh_prom.i.i.i45 = zext nneg i8 %41 to i64
  %notmask.i.i.i46 = shl nsw i64 -1, %sh_prom.i.i.i45
  %sub.i.i.i47 = xor i64 %notmask.i.i.i46, -1
  %or.i.i.i48 = or i64 %sub.i.i.i47, 1
  %rem.i.i.i49 = urem i64 %conv.i.i.i43, %or.i.i.i48
  %arrayidx7.i.i.i50 = getelementptr inbounds %struct.Node, ptr %40, i64 %rem.i.i.i49
  br label %do.body.i.i53

do.body.i.i53:                                    ; preds = %if.else8.i.i57, %if.else.i.i37
  %n.0.i.i54 = phi ptr [ %arrayidx7.i.i.i50, %if.else.i.i37 ], [ %44, %if.else8.i.i57 ]
  %tt.i7.i55 = getelementptr inbounds %struct.Node, ptr %n.0.i.i54, i64 0, i32 1, i32 0, i32 1
  %42 = load i32, ptr %tt.i7.i55, align 8
  %cmp2.i.i56 = icmp eq i32 %42, 3
  br i1 %cmp2.i.i56, label %land.lhs.true.i.i65, label %if.else8.i.i57

land.lhs.true.i.i65:                              ; preds = %do.body.i.i53
  %i_key.i.i66 = getelementptr inbounds %struct.Node, ptr %n.0.i.i54, i64 0, i32 1
  %43 = load double, ptr %i_key.i.i66, align 8
  %cmp5.i.i67 = fcmp oeq double %43, %conv.i6.i38
  br i1 %cmp5.i.i67, label %lua_rawgeti.exit72, label %if.else8.i.i57

if.else8.i.i57:                                   ; preds = %land.lhs.true.i.i65, %do.body.i.i53
  %next.i.i58 = getelementptr inbounds %struct.Node, ptr %n.0.i.i54, i64 0, i32 1, i32 0, i32 2
  %44 = load ptr, ptr %next.i.i58, align 8
  %tobool.not.i.i59 = icmp eq ptr %44, null
  br i1 %tobool.not.i.i59, label %lua_rawgeti.exit72, label %do.body.i.i53, !llvm.loop !7

lua_rawgeti.exit72:                               ; preds = %land.lhs.true.i.i65, %if.else8.i.i57, %if.then.i9.i68
  %lftr.wideiv.pre-phi = phi i32 [ %.pre100, %if.then.i9.i68 ], [ %38, %if.else8.i.i57 ], [ %38, %land.lhs.true.i.i65 ]
  %retval.0.i8.i60 = phi ptr [ %arrayidx.i11.i71, %if.then.i9.i68 ], [ %n.0.i.i54, %land.lhs.true.i.i65 ], [ @luaO_nilobject_, %if.else8.i.i57 ]
  %45 = load i64, ptr %retval.0.i8.i60, align 8
  store i64 %45, ptr %33, align 8
  %tt.i62 = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i8.i60, i64 0, i32 1
  %46 = load i32, ptr %tt.i62, align 8
  %tt4.i63 = getelementptr inbounds %struct.lua_TValue, ptr %33, i64 0, i32 1
  store i32 %46, ptr %tt4.i63, align 8
  %47 = load ptr, ptr %top.i.i.i, align 8
  %incdec.ptr.i64 = getelementptr inbounds %struct.lua_TValue, ptr %47, i64 1
  store ptr %incdec.ptr.i64, ptr %top.i.i.i, align 8
  tail call fastcc void @lua_rawseti(ptr noundef %L, i32 noundef 1, i32 noundef %36)
  %exitcond.not = icmp eq i32 %lftr.wideiv.pre-phi, %conv
  br i1 %exitcond.not, label %for.end.loopexit, label %for.body, !llvm.loop !132

for.end.loopexit:                                 ; preds = %lua_rawgeti.exit72
  %.pre = load ptr, ptr %top.i.i.i, align 8
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %lua_rawgeti.exit
  %48 = phi ptr [ %.pre, %for.end.loopexit ], [ %incdec.ptr.i, %lua_rawgeti.exit ]
  %tt.i74 = getelementptr inbounds %struct.lua_TValue, ptr %48, i64 0, i32 1
  store i32 0, ptr %tt.i74, align 8
  %49 = load ptr, ptr %top.i.i.i, align 8
  %incdec.ptr.i75 = getelementptr inbounds %struct.lua_TValue, ptr %49, i64 1
  store ptr %incdec.ptr.i75, ptr %top.i.i.i, align 8
  tail call fastcc void @lua_rawseti(ptr noundef nonnull %L, i32 noundef 1, i32 noundef %conv)
  br label %return

return:                                           ; preds = %luaO_str2d.exit.thread9.i.i, %luaO_str2d.exit.i.i, %land.lhs.true.i.i, %luaL_optinteger.exit, %for.end
  %retval.0 = phi i32 [ 1, %for.end ], [ 0, %luaL_optinteger.exit ], [ 0, %land.lhs.true.i.i ], [ 0, %luaO_str2d.exit.i.i ], [ 0, %luaO_str2d.exit.thread9.i.i ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sort(ptr noundef %L) #0 {
entry:
  %base.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i.i, align 8
  %top.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i.i = icmp uge ptr %0, %1
  %cmp.i.i = icmp eq ptr %0, @luaO_nilobject_
  %or.cond = or i1 %cmp.i.i, %cmp1.not.i.i.i
  br i1 %or.cond, label %if.then.i, label %lua_type.exit.i

lua_type.exit.i:                                  ; preds = %entry
  %tt.i.i = getelementptr inbounds %struct.lua_TValue, ptr %0, i64 0, i32 1
  %2 = load i32, ptr %tt.i.i, align 8
  %cmp.not.i = icmp eq i32 %2, 5
  br i1 %cmp.not.i, label %luaL_checktype.exit, label %if.then.i

if.then.i:                                        ; preds = %entry, %lua_type.exit.i
  tail call fastcc void @luaL_typerror(ptr noundef nonnull %L, i32 noundef 1, ptr noundef nonnull @.str.26)
  unreachable

luaL_checktype.exit:                              ; preds = %lua_type.exit.i
  %call = tail call fastcc i64 @lua_objlen(ptr noundef nonnull %L, i32 noundef 1)
  %3 = load ptr, ptr %top.i.i.i, align 8
  %4 = load ptr, ptr %base.i.i.i, align 8
  %sub.ptr.lhs.cast.i.i = ptrtoint ptr %3 to i64
  %sub.ptr.rhs.cast.i.i = ptrtoint ptr %4 to i64
  %sub.ptr.sub.i.i = sub i64 %sub.ptr.lhs.cast.i.i, %sub.ptr.rhs.cast.i.i
  %cmp1.i.i = icmp sgt i64 %sub.ptr.sub.i.i, 127360
  br i1 %cmp1.i.i, label %if.then.i7, label %if.else.i.i

if.else.i.i:                                      ; preds = %luaL_checktype.exit
  %stack_last.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 9
  %5 = load ptr, ptr %stack_last.i.i, align 8
  %sub.ptr.lhs.cast7.i.i = ptrtoint ptr %5 to i64
  %sub.ptr.sub9.i.i = sub i64 %sub.ptr.lhs.cast7.i.i, %sub.ptr.lhs.cast.i.i
  %cmp11.not.i.i = icmp sgt i64 %sub.ptr.sub9.i.i, 640
  br i1 %cmp11.not.i.i, label %if.end.i.i, label %if.then13.i.i

if.then13.i.i:                                    ; preds = %if.else.i.i
  %stacksize.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 13
  %6 = load i32, ptr %stacksize.i.i.i, align 8
  %cmp.not.i.i.i = icmp slt i32 %6, 40
  %add.i.i.i = add nsw i32 %6, 40
  %mul.i.i.i = shl nsw i32 %6, 1
  %add.sink.i.i.i = select i1 %cmp.not.i.i.i, i32 %add.i.i.i, i32 %mul.i.i.i
  tail call fastcc void @luaD_reallocstack(ptr noundef nonnull %L, i32 noundef %add.sink.i.i.i)
  %.pre.i.i = load ptr, ptr %top.i.i.i, align 8
  br label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then13.i.i, %if.else.i.i
  %7 = phi ptr [ %3, %if.else.i.i ], [ %.pre.i.i, %if.then13.i.i ]
  %ci.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %8 = load ptr, ptr %ci.i.i, align 8
  %top15.i.i = getelementptr inbounds %struct.CallInfo, ptr %8, i64 0, i32 2
  %9 = load ptr, ptr %top15.i.i, align 8
  %add.ptr.i.i = getelementptr inbounds %struct.lua_TValue, ptr %7, i64 40
  %cmp17.i.i = icmp ult ptr %9, %add.ptr.i.i
  br i1 %cmp17.i.i, label %if.then19.i.i, label %luaL_checkstack.exit

if.then19.i.i:                                    ; preds = %if.end.i.i
  store ptr %add.ptr.i.i, ptr %top15.i.i, align 8
  %.pre = load ptr, ptr %top.i.i.i, align 8
  br label %luaL_checkstack.exit

if.then.i7:                                       ; preds = %luaL_checktype.exit
  tail call void (ptr, ptr, ...) @luaL_error(ptr noundef nonnull %L, ptr noundef nonnull @.str.193, ptr noundef nonnull @.str.7)
  unreachable

luaL_checkstack.exit:                             ; preds = %if.end.i.i, %if.then19.i.i
  %10 = phi ptr [ %7, %if.end.i.i ], [ %.pre, %if.then19.i.i ]
  %11 = load ptr, ptr %base.i.i.i, align 8
  %12 = getelementptr %struct.lua_TValue, ptr %11, i64 2
  %add.ptr.i.i9 = getelementptr %struct.lua_TValue, ptr %11, i64 1
  %cmp1.not.i.i = icmp uge ptr %add.ptr.i.i9, %10
  %cmp.i = icmp eq ptr %add.ptr.i.i9, @luaO_nilobject_
  %or.cond30 = or i1 %cmp1.not.i.i, %cmp.i
  br i1 %or.cond30, label %if.end, label %lua_type.exit

lua_type.exit:                                    ; preds = %luaL_checkstack.exit
  %tt.i = getelementptr %struct.lua_TValue, ptr %11, i64 1, i32 1
  %13 = load i32, ptr %tt.i, align 8
  %cmp = icmp slt i32 %13, 1
  %cmp.not.i17 = icmp eq i32 %13, 6
  %or.cond31 = or i1 %cmp, %cmp.not.i17
  br i1 %or.cond31, label %if.end, label %if.then.i18

if.then.i18:                                      ; preds = %lua_type.exit
  tail call fastcc void @luaL_typerror(ptr noundef nonnull %L, i32 noundef 2, ptr noundef nonnull @.str.27)
  unreachable

if.end:                                           ; preds = %luaL_checkstack.exit, %lua_type.exit
  %cmp111.i = icmp ult ptr %10, %12
  br i1 %cmp111.i, label %while.body.i, label %lua_settop.exit

while.body.i:                                     ; preds = %if.end, %while.body.i
  %14 = phi ptr [ %15, %while.body.i ], [ %10, %if.end ]
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %14, i64 1
  store ptr %incdec.ptr.i, ptr %top.i.i.i, align 8
  %tt.i25 = getelementptr inbounds %struct.lua_TValue, ptr %14, i64 0, i32 1
  store i32 0, ptr %tt.i25, align 8
  %15 = load ptr, ptr %top.i.i.i, align 8
  %16 = load ptr, ptr %base.i.i.i, align 8
  %add.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %16, i64 2
  %cmp1.i = icmp ult ptr %15, %add.ptr.i
  br i1 %cmp1.i, label %while.body.i, label %lua_settop.exit, !llvm.loop !13

lua_settop.exit:                                  ; preds = %while.body.i, %if.end
  %add.ptr9.sink.i = phi ptr [ %12, %if.end ], [ %add.ptr.i, %while.body.i ]
  %conv = trunc i64 %call to i32
  store ptr %add.ptr9.sink.i, ptr %top.i.i.i, align 8
  tail call fastcc void @auxsort(ptr noundef nonnull %L, i32 noundef 1, i32 noundef %conv)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal fastcc void @addfield(ptr noundef %L, ptr noundef %b, i32 noundef %i) unnamed_addr #0 {
entry:
  %vl.i = alloca i64, align 8
  %base.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i, align 8
  %top.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i, align 8
  %cmp1.not.i.i = icmp ult ptr %0, %1
  %add.ptr.luaO_nilobject_.i.i = select i1 %cmp1.not.i.i, ptr %0, ptr @luaO_nilobject_
  %2 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i, align 8
  %sub.i.i = add i32 %i, -1
  %sizearray.i.i = getelementptr inbounds %struct.Table, ptr %2, i64 0, i32 10
  %3 = load i32, ptr %sizearray.i.i, align 8
  %cmp.i5.i = icmp ult i32 %sub.i.i, %3
  br i1 %cmp.i5.i, label %if.then.i9.i, label %if.else.i.i

if.then.i9.i:                                     ; preds = %entry
  %array.i.i = getelementptr inbounds %struct.Table, ptr %2, i64 0, i32 6
  %4 = load ptr, ptr %array.i.i, align 8
  %idxprom.i10.i = sext i32 %sub.i.i to i64
  %arrayidx.i11.i = getelementptr inbounds %struct.lua_TValue, ptr %4, i64 %idxprom.i10.i
  br label %lua_rawgeti.exit

if.else.i.i:                                      ; preds = %entry
  %conv.i6.i = sitofp i32 %i to double
  %cmp.i.i.i = icmp eq i32 %i, 0
  br i1 %cmp.i.i.i, label %if.then.i.i.i, label %if.end.i.i.i

if.then.i.i.i:                                    ; preds = %if.else.i.i
  %node.i.i.i = getelementptr inbounds %struct.Table, ptr %2, i64 0, i32 7
  %5 = load ptr, ptr %node.i.i.i, align 8
  br label %do.body.i.i.preheader

if.end.i.i.i:                                     ; preds = %if.else.i.i
  %6 = bitcast double %conv.i6.i to i64
  %a.sroa.0.4.extract.shift.i.i.i = lshr i64 %6, 32
  %add.i.i.i = add i64 %a.sroa.0.4.extract.shift.i.i.i, %6
  %node4.i.i.i = getelementptr inbounds %struct.Table, ptr %2, i64 0, i32 7
  %7 = load ptr, ptr %node4.i.i.i, align 8
  %conv.i.i.i = and i64 %add.i.i.i, 4294967295
  %lsizenode.i.i.i = getelementptr inbounds %struct.Table, ptr %2, i64 0, i32 4
  %8 = load i8, ptr %lsizenode.i.i.i, align 1
  %sh_prom.i.i.i = zext nneg i8 %8 to i64
  %notmask.i.i.i = shl nsw i64 -1, %sh_prom.i.i.i
  %sub.i.i.i = xor i64 %notmask.i.i.i, -1
  %or.i.i.i = or i64 %sub.i.i.i, 1
  %rem.i.i.i = urem i64 %conv.i.i.i, %or.i.i.i
  %arrayidx7.i.i.i = getelementptr inbounds %struct.Node, ptr %7, i64 %rem.i.i.i
  br label %do.body.i.i.preheader

do.body.i.i.preheader:                            ; preds = %if.end.i.i.i, %if.then.i.i.i
  %n.0.i.i.ph = phi ptr [ %arrayidx7.i.i.i, %if.end.i.i.i ], [ %5, %if.then.i.i.i ]
  br label %do.body.i.i

do.body.i.i:                                      ; preds = %do.body.i.i.preheader, %if.else8.i.i
  %n.0.i.i = phi ptr [ %11, %if.else8.i.i ], [ %n.0.i.i.ph, %do.body.i.i.preheader ]
  %tt.i7.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1, i32 0, i32 1
  %9 = load i32, ptr %tt.i7.i, align 8
  %cmp2.i.i = icmp eq i32 %9, 3
  br i1 %cmp2.i.i, label %land.lhs.true.i.i, label %if.else8.i.i

land.lhs.true.i.i:                                ; preds = %do.body.i.i
  %i_key.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1
  %10 = load double, ptr %i_key.i.i, align 8
  %cmp5.i.i = fcmp oeq double %10, %conv.i6.i
  br i1 %cmp5.i.i, label %lua_rawgeti.exit, label %if.else8.i.i

if.else8.i.i:                                     ; preds = %land.lhs.true.i.i, %do.body.i.i
  %next.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1, i32 0, i32 2
  %11 = load ptr, ptr %next.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %11, null
  br i1 %tobool.not.i.i, label %lua_rawgeti.exit, label %do.body.i.i, !llvm.loop !7

lua_rawgeti.exit:                                 ; preds = %land.lhs.true.i.i, %if.else8.i.i, %if.then.i9.i
  %retval.0.i8.i = phi ptr [ %arrayidx.i11.i, %if.then.i9.i ], [ @luaO_nilobject_, %if.else8.i.i ], [ %n.0.i.i, %land.lhs.true.i.i ]
  %12 = load i64, ptr %retval.0.i8.i, align 8
  store i64 %12, ptr %1, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i8.i, i64 0, i32 1
  %13 = load i32, ptr %tt.i, align 8
  %tt4.i = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 0, i32 1
  store i32 %13, ptr %tt4.i, align 8
  %14 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %14, i64 1
  store ptr %incdec.ptr.i, ptr %top.i.i, align 8
  %cmp.i.i = icmp eq ptr %14, @luaO_nilobject_
  br i1 %cmp.i.i, label %lua_typename.exit, label %lua_isstring.exit

lua_isstring.exit:                                ; preds = %lua_rawgeti.exit
  %tt.i.i = getelementptr inbounds %struct.lua_TValue, ptr %14, i64 0, i32 1
  %15 = load i32, ptr %tt.i.i, align 8
  %16 = add i32 %15, -5
  %17 = icmp ult i32 %16, -2
  br i1 %17, label %lua_type.exit, label %if.end

lua_type.exit:                                    ; preds = %lua_isstring.exit
  %cmp.i8 = icmp eq i32 %15, -1
  br i1 %cmp.i8, label %lua_typename.exit, label %cond.false.i9

cond.false.i9:                                    ; preds = %lua_type.exit
  %idxprom.i = sext i32 %15 to i64
  %arrayidx.i = getelementptr inbounds [11 x ptr], ptr @luaT_typenames, i64 0, i64 %idxprom.i
  %18 = load ptr, ptr %arrayidx.i, align 8
  br label %lua_typename.exit

lua_typename.exit:                                ; preds = %lua_rawgeti.exit, %lua_type.exit, %cond.false.i9
  %cond.i10 = phi ptr [ %18, %cond.false.i9 ], [ @.str.131, %lua_type.exit ], [ @.str.131, %lua_rawgeti.exit ]
  tail call void (ptr, ptr, ...) @luaL_error(ptr noundef nonnull %L, ptr noundef nonnull @.str.191, ptr noundef %cond.i10, i32 noundef %i)
  unreachable

if.end:                                           ; preds = %lua_isstring.exit
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %vl.i)
  %L1.i = getelementptr inbounds %struct.luaL_Buffer, ptr %b, i64 0, i32 2
  %19 = load ptr, ptr %L1.i, align 8
  %call.i = call fastcc ptr @lua_tolstring(ptr noundef %19, i32 noundef -1, ptr noundef nonnull %vl.i)
  %20 = load i64, ptr %vl.i, align 8
  %21 = load ptr, ptr %b, align 8
  %buffer.i = getelementptr inbounds %struct.luaL_Buffer, ptr %b, i64 0, i32 3
  %sub.ptr.lhs.cast.i = ptrtoint ptr %21 to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %buffer.i to i64
  %sub.ptr.sub.neg.i = add i64 %sub.ptr.rhs.cast.i, 8192
  %sub.i = sub i64 %sub.ptr.sub.neg.i, %sub.ptr.lhs.cast.i
  %cmp.not.i = icmp ugt i64 %20, %sub.i
  br i1 %cmp.not.i, label %if.else.i, label %if.then.i

if.then.i:                                        ; preds = %if.end
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %21, ptr align 1 %call.i, i64 %20, i1 false)
  %22 = load i64, ptr %vl.i, align 8
  %23 = load ptr, ptr %b, align 8
  %add.ptr.i = getelementptr inbounds i8, ptr %23, i64 %22
  store ptr %add.ptr.i, ptr %b, align 8
  %top.i.i11 = getelementptr inbounds %struct.lua_State, ptr %19, i64 0, i32 4
  %24 = load ptr, ptr %top.i.i11, align 8
  %add.ptr9.i.i = getelementptr %struct.lua_TValue, ptr %24, i64 -1
  store ptr %add.ptr9.i.i, ptr %top.i.i11, align 8
  br label %luaL_addvalue.exit

if.else.i:                                        ; preds = %if.end
  %call4.i = call fastcc i32 @emptybuffer(ptr noundef nonnull %b), !range !23
  %tobool.not.i = icmp eq i32 %call4.i, 0
  br i1 %tobool.not.i, label %if.end.i, label %if.then5.i

if.then5.i:                                       ; preds = %if.else.i
  %top6.i.i.i12 = getelementptr inbounds %struct.lua_State, ptr %19, i64 0, i32 4
  %25 = load ptr, ptr %top6.i.i.i12, align 8
  br label %for.body.i.i

for.body.i.i:                                     ; preds = %for.body.i.i, %if.then5.i
  %q.012.i.idx.i = phi i64 [ %q.012.i.add.i, %for.body.i.i ], [ 0, %if.then5.i ]
  %q.012.i.ptr.i = getelementptr inbounds i8, ptr %25, i64 %q.012.i.idx.i
  %q.012.i.add.i = add nsw i64 %q.012.i.idx.i, -16
  %add.ptr.i.ptr.i = getelementptr inbounds i8, ptr %25, i64 %q.012.i.add.i
  %26 = load i64, ptr %add.ptr.i.ptr.i, align 8
  store i64 %26, ptr %q.012.i.ptr.i, align 8
  %tt.i.i13 = getelementptr %struct.lua_TValue, ptr %q.012.i.ptr.i, i64 -1, i32 1
  %27 = load i32, ptr %tt.i.i13, align 8
  %tt2.i.i = getelementptr inbounds %struct.lua_TValue, ptr %q.012.i.ptr.i, i64 0, i32 1
  store i32 %27, ptr %tt2.i.i, align 8
  %cmp.i.i14 = icmp sgt i64 %q.012.i.idx.i, -16
  br i1 %cmp.i.i14, label %for.body.i.i, label %lua_insert.exit.i, !llvm.loop !86

lua_insert.exit.i:                                ; preds = %for.body.i.i
  %add.ptr8.i.i.i15 = getelementptr inbounds %struct.lua_TValue, ptr %25, i64 -2
  %.pre.i.i = load ptr, ptr %top6.i.i.i12, align 8
  %28 = load i64, ptr %.pre.i.i, align 8
  store i64 %28, ptr %add.ptr8.i.i.i15, align 8
  %tt8.i.i = getelementptr inbounds %struct.lua_TValue, ptr %.pre.i.i, i64 0, i32 1
  %29 = load i32, ptr %tt8.i.i, align 8
  %tt9.i.i = getelementptr %struct.lua_TValue, ptr %25, i64 -2, i32 1
  store i32 %29, ptr %tt9.i.i, align 8
  br label %if.end.i

if.end.i:                                         ; preds = %lua_insert.exit.i, %if.else.i
  %lvl.i = getelementptr inbounds %struct.luaL_Buffer, ptr %b, i64 0, i32 1
  %30 = load i32, ptr %lvl.i, align 8
  %inc.i = add nsw i32 %30, 1
  store i32 %inc.i, ptr %lvl.i, align 8
  call fastcc void @adjuststack(ptr noundef nonnull %b)
  br label %luaL_addvalue.exit

luaL_addvalue.exit:                               ; preds = %if.then.i, %if.end.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %vl.i)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @emptybuffer(ptr noundef %B) unnamed_addr #0 {
entry:
  %0 = load ptr, ptr %B, align 8
  %buffer = getelementptr inbounds %struct.luaL_Buffer, ptr %B, i64 0, i32 3
  %cmp = icmp eq ptr %0, %buffer
  br i1 %cmp, label %return, label %if.else

if.else:                                          ; preds = %entry
  %sub.ptr.rhs.cast = ptrtoint ptr %buffer to i64
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %L = getelementptr inbounds %struct.luaL_Buffer, ptr %B, i64 0, i32 2
  %1 = load ptr, ptr %L, align 8
  %l_G.i = getelementptr inbounds %struct.lua_State, ptr %1, i64 0, i32 6
  %2 = load ptr, ptr %l_G.i, align 8
  %totalbytes.i = getelementptr inbounds %struct.global_State, ptr %2, i64 0, i32 14
  %3 = load i64, ptr %totalbytes.i, align 8
  %GCthreshold.i = getelementptr inbounds %struct.global_State, ptr %2, i64 0, i32 13
  %4 = load i64, ptr %GCthreshold.i, align 8
  %cmp.not.i = icmp ult i64 %3, %4
  br i1 %cmp.not.i, label %lua_pushlstring.exit, label %if.then.i

if.then.i:                                        ; preds = %if.else
  %gcstepmul.i.i = getelementptr inbounds %struct.global_State, ptr %2, i64 0, i32 18
  %5 = load i32, ptr %gcstepmul.i.i, align 4
  %mul.i.i = mul i32 %5, 10
  %conv.i.i = zext i32 %mul.i.i to i64
  %cmp.i.i = icmp eq i32 %mul.i.i, 0
  %spec.store.select.i.i = select i1 %cmp.i.i, i64 9223372036854775806, i64 %conv.i.i
  %sub.i.i = sub i64 %3, %4
  %gcdept.i.i = getelementptr inbounds %struct.global_State, ptr %2, i64 0, i32 16
  %6 = load i64, ptr %gcdept.i.i, align 8
  %add.i.i = add i64 %sub.i.i, %6
  store i64 %add.i.i, ptr %gcdept.i.i, align 8
  %gcstate.i.i = getelementptr inbounds %struct.global_State, ptr %2, i64 0, i32 4
  br label %do.body.i.i

do.body.i.i:                                      ; preds = %do.body.i.i, %if.then.i
  %lim.0.i.i = phi i64 [ %spec.store.select.i.i, %if.then.i ], [ %sub2.i.i, %do.body.i.i ]
  %call.i.i = tail call fastcc i64 @singlestep(ptr noundef %1)
  %sub2.i.i = sub nsw i64 %lim.0.i.i, %call.i.i
  %7 = load i8, ptr %gcstate.i.i, align 1
  %cmp4.i.i = icmp ne i8 %7, 0
  %cmp8.i.i = icmp sgt i64 %sub2.i.i, 0
  %or.cond.i.i = select i1 %cmp4.i.i, i1 %cmp8.i.i, i1 false
  br i1 %or.cond.i.i, label %do.body.i.i, label %do.end.i.i, !llvm.loop !6

do.end.i.i:                                       ; preds = %do.body.i.i
  br i1 %cmp4.i.i, label %if.then14.i.i, label %if.else27.i.i

if.then14.i.i:                                    ; preds = %do.end.i.i
  %8 = load i64, ptr %gcdept.i.i, align 8
  %cmp16.i.i = icmp ult i64 %8, 1024
  br i1 %cmp16.i.i, label %if.then18.i.i, label %if.else.i.i

if.then18.i.i:                                    ; preds = %if.then14.i.i
  %9 = load i64, ptr %totalbytes.i, align 8
  %add20.i.i = add i64 %9, 1024
  br label %luaC_step.exit.i

if.else.i.i:                                      ; preds = %if.then14.i.i
  %sub23.i.i = add i64 %8, -1024
  store i64 %sub23.i.i, ptr %gcdept.i.i, align 8
  %10 = load i64, ptr %totalbytes.i, align 8
  br label %luaC_step.exit.i

if.else27.i.i:                                    ; preds = %do.end.i.i
  %estimate.i.i = getelementptr inbounds %struct.global_State, ptr %2, i64 0, i32 15
  %11 = load i64, ptr %estimate.i.i, align 8
  %div.i.i = udiv i64 %11, 100
  %gcpause.i.i = getelementptr inbounds %struct.global_State, ptr %2, i64 0, i32 17
  %12 = load i32, ptr %gcpause.i.i, align 8
  %conv28.i.i = sext i32 %12 to i64
  %mul29.i.i = mul i64 %div.i.i, %conv28.i.i
  br label %luaC_step.exit.i

luaC_step.exit.i:                                 ; preds = %if.else27.i.i, %if.else.i.i, %if.then18.i.i
  %add20.sink.i.i = phi i64 [ %add20.i.i, %if.then18.i.i ], [ %10, %if.else.i.i ], [ %mul29.i.i, %if.else27.i.i ]
  store i64 %add20.sink.i.i, ptr %GCthreshold.i, align 8
  br label %lua_pushlstring.exit

lua_pushlstring.exit:                             ; preds = %if.else, %luaC_step.exit.i
  %top.i = getelementptr inbounds %struct.lua_State, ptr %1, i64 0, i32 4
  %13 = load ptr, ptr %top.i, align 8
  %call.i = tail call fastcc ptr @luaS_newlstr(ptr noundef %1, ptr noundef nonnull %buffer, i64 noundef %sub.ptr.sub)
  store ptr %call.i, ptr %13, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %13, i64 0, i32 1
  store i32 4, ptr %tt.i, align 8
  %14 = load ptr, ptr %top.i, align 8
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %14, i64 1
  store ptr %incdec.ptr.i, ptr %top.i, align 8
  store ptr %buffer, ptr %B, align 8
  %lvl = getelementptr inbounds %struct.luaL_Buffer, ptr %B, i64 0, i32 1
  %15 = load i32, ptr %lvl, align 8
  %inc = add nsw i32 %15, 1
  store i32 %inc, ptr %lvl, align 8
  br label %return

return:                                           ; preds = %entry, %lua_pushlstring.exit
  %retval.0 = phi i32 [ 1, %lua_pushlstring.exit ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal fastcc void @adjuststack(ptr nocapture noundef %B) unnamed_addr #0 {
entry:
  %s.i.i = alloca [32 x i8], align 16
  %lvl = getelementptr inbounds %struct.luaL_Buffer, ptr %B, i64 0, i32 1
  %0 = load i32, ptr %lvl, align 8
  %cmp = icmp sgt i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end16

if.then:                                          ; preds = %entry
  %L1 = getelementptr inbounds %struct.luaL_Buffer, ptr %B, i64 0, i32 2
  %1 = load ptr, ptr %L1, align 8
  %top6.i.i = getelementptr inbounds %struct.lua_State, ptr %1, i64 0, i32 4
  %2 = load ptr, ptr %top6.i.i, align 8
  %add.ptr8.i.i = getelementptr inbounds %struct.lua_TValue, ptr %2, i64 -1
  %tt.i = getelementptr %struct.lua_TValue, ptr %2, i64 -1, i32 1
  %3 = load i32, ptr %tt.i, align 8
  switch i32 %3, label %do.body.preheader [
    i32 4, label %sw.bb.i
    i32 7, label %sw.bb1.i
    i32 5, label %sw.bb4.i
    i32 3, label %cond.true.i
  ]

sw.bb.i:                                          ; preds = %if.then
  %4 = load ptr, ptr %add.ptr8.i.i, align 8
  %len.i = getelementptr inbounds %struct.anon.0, ptr %4, i64 0, i32 5
  %5 = load i64, ptr %len.i, align 8
  br label %do.body.preheader

sw.bb1.i:                                         ; preds = %if.then
  %6 = load ptr, ptr %add.ptr8.i.i, align 8
  %len3.i = getelementptr inbounds %struct.anon.1, ptr %6, i64 0, i32 5
  %7 = load i64, ptr %len3.i, align 8
  br label %do.body.preheader

sw.bb4.i:                                         ; preds = %if.then
  %8 = load ptr, ptr %add.ptr8.i.i, align 8
  %call6.i = tail call fastcc i32 @luaH_getn(ptr noundef %8)
  %conv.i = sext i32 %call6.i to i64
  br label %do.body.preheader

cond.true.i:                                      ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %s.i.i)
  %9 = load double, ptr %add.ptr8.i.i, align 8
  %call.i.i = call i32 (ptr, ptr, ...) @sprintf(ptr noundef nonnull dereferenceable(1) %s.i.i, ptr noundef nonnull dereferenceable(1) @.str.16, double noundef %9) #35
  %call3.i.i = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %s.i.i) #34
  %call4.i.i = call fastcc ptr @luaS_newlstr(ptr noundef nonnull %1, ptr noundef nonnull %s.i.i, i64 noundef %call3.i.i)
  store ptr %call4.i.i, ptr %add.ptr8.i.i, align 8
  store i32 4, ptr %tt.i, align 8
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %s.i.i)
  %len10.i = getelementptr inbounds %struct.anon.0, ptr %call4.i.i, i64 0, i32 5
  %10 = load i64, ptr %len10.i, align 8
  br label %do.body.preheader

do.body.preheader:                                ; preds = %if.then, %sw.bb.i, %sw.bb1.i, %sw.bb4.i, %cond.true.i
  %toplen.0.ph = phi i64 [ 0, %if.then ], [ %10, %cond.true.i ], [ %5, %sw.bb.i ], [ %7, %sw.bb1.i ], [ %conv.i, %sw.bb4.i ]
  br label %do.body

do.body:                                          ; preds = %do.body.preheader, %if.then8
  %toplen.0 = phi i64 [ %add9, %if.then8 ], [ %toplen.0.ph, %do.body.preheader ]
  %toget.0 = phi i32 [ %add, %if.then8 ], [ 1, %do.body.preheader ]
  %sub = xor i32 %toget.0, -1
  %call2 = tail call fastcc i64 @lua_objlen(ptr noundef %1, i32 noundef %sub)
  %11 = load i32, ptr %lvl, align 8
  %sub4 = sub nsw i32 %11, %toget.0
  %cmp6 = icmp sgt i32 %sub4, 8
  %cmp7 = icmp ugt i64 %toplen.0, %call2
  %or.cond = select i1 %cmp6, i1 true, i1 %cmp7
  br i1 %or.cond, label %if.then8, label %do.end

if.then8:                                         ; preds = %do.body
  %add = add nuw nsw i32 %toget.0, 1
  %add9 = add i64 %call2, %toplen.0
  %cmp11 = icmp slt i32 %add, %11
  br i1 %cmp11, label %do.body, label %do.end, !llvm.loop !128

do.end:                                           ; preds = %do.body, %if.then8
  %toget.1 = phi i32 [ %add, %if.then8 ], [ %toget.0, %do.body ]
  tail call fastcc void @lua_concat(ptr noundef %1, i32 noundef %toget.1)
  %12 = load i32, ptr %lvl, align 8
  %reass.sub = sub i32 %12, %toget.1
  %add14 = add i32 %reass.sub, 1
  store i32 %add14, ptr %lvl, align 8
  br label %if.end16

if.end16:                                         ; preds = %do.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @auxsort(ptr noundef %L, i32 noundef %l, i32 noundef %u) unnamed_addr #0 {
entry:
  %k.i.i626 = alloca %struct.lua_TValue, align 8
  %k.i.i = alloca %struct.lua_TValue, align 8
  %cmp712 = icmp slt i32 %l, %u
  br i1 %cmp712, label %while.body.lr.ph, label %while.end53

while.body.lr.ph:                                 ; preds = %entry
  %base.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %top.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %tt.i11.i662 = getelementptr inbounds %struct.lua_TValue, ptr %k.i.i626, i64 0, i32 1
  %0 = getelementptr i8, ptr %L, i64 32
  %tt.i11.i = getelementptr inbounds %struct.lua_TValue, ptr %k.i.i, i64 0, i32 1
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %lua_rawgeti.exit608
  %u.addr.0714 = phi i32 [ %u, %while.body.lr.ph ], [ %u.addr.0714..lcssa.lcssa737, %lua_rawgeti.exit608 ]
  %l.addr.0713 = phi i32 [ %l, %while.body.lr.ph ], [ %add48.l.addr.0713, %lua_rawgeti.exit608 ]
  %1 = load ptr, ptr %base.i.i, align 8
  %2 = load ptr, ptr %top.i.i, align 8
  %cmp1.not.i.i = icmp ult ptr %1, %2
  %add.ptr.luaO_nilobject_.i.i = select i1 %cmp1.not.i.i, ptr %1, ptr @luaO_nilobject_
  %3 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i, align 8
  %sub.i.i = add i32 %l.addr.0713, -1
  %sizearray.i.i = getelementptr inbounds %struct.Table, ptr %3, i64 0, i32 10
  %4 = load i32, ptr %sizearray.i.i, align 8
  %cmp.i5.i = icmp ult i32 %sub.i.i, %4
  br i1 %cmp.i5.i, label %if.then.i9.i, label %if.else.i.i

if.then.i9.i:                                     ; preds = %while.body
  %array.i.i = getelementptr inbounds %struct.Table, ptr %3, i64 0, i32 6
  %5 = load ptr, ptr %array.i.i, align 8
  %idxprom.i10.i = sext i32 %sub.i.i to i64
  %arrayidx.i11.i = getelementptr inbounds %struct.lua_TValue, ptr %5, i64 %idxprom.i10.i
  br label %lua_rawgeti.exit

if.else.i.i:                                      ; preds = %while.body
  %conv.i6.i = sitofp i32 %l.addr.0713 to double
  %cmp.i.i.i = icmp eq i32 %l.addr.0713, 0
  br i1 %cmp.i.i.i, label %if.then.i.i.i, label %if.end.i.i.i

if.then.i.i.i:                                    ; preds = %if.else.i.i
  %node.i.i.i = getelementptr inbounds %struct.Table, ptr %3, i64 0, i32 7
  %6 = load ptr, ptr %node.i.i.i, align 8
  br label %do.body.i.i.preheader

if.end.i.i.i:                                     ; preds = %if.else.i.i
  %7 = bitcast double %conv.i6.i to i64
  %a.sroa.0.4.extract.shift.i.i.i = lshr i64 %7, 32
  %add.i.i.i = add i64 %a.sroa.0.4.extract.shift.i.i.i, %7
  %node4.i.i.i = getelementptr inbounds %struct.Table, ptr %3, i64 0, i32 7
  %8 = load ptr, ptr %node4.i.i.i, align 8
  %conv.i.i.i = and i64 %add.i.i.i, 4294967295
  %lsizenode.i.i.i = getelementptr inbounds %struct.Table, ptr %3, i64 0, i32 4
  %9 = load i8, ptr %lsizenode.i.i.i, align 1
  %sh_prom.i.i.i = zext nneg i8 %9 to i64
  %notmask.i.i.i = shl nsw i64 -1, %sh_prom.i.i.i
  %sub.i.i.i = xor i64 %notmask.i.i.i, -1
  %or.i.i.i = or i64 %sub.i.i.i, 1
  %rem.i.i.i = urem i64 %conv.i.i.i, %or.i.i.i
  %arrayidx7.i.i.i = getelementptr inbounds %struct.Node, ptr %8, i64 %rem.i.i.i
  br label %do.body.i.i.preheader

do.body.i.i.preheader:                            ; preds = %if.end.i.i.i, %if.then.i.i.i
  %n.0.i.i.ph = phi ptr [ %arrayidx7.i.i.i, %if.end.i.i.i ], [ %6, %if.then.i.i.i ]
  br label %do.body.i.i

do.body.i.i:                                      ; preds = %do.body.i.i.preheader, %if.else8.i.i
  %n.0.i.i = phi ptr [ %12, %if.else8.i.i ], [ %n.0.i.i.ph, %do.body.i.i.preheader ]
  %tt.i7.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1, i32 0, i32 1
  %10 = load i32, ptr %tt.i7.i, align 8
  %cmp2.i.i = icmp eq i32 %10, 3
  br i1 %cmp2.i.i, label %land.lhs.true.i.i, label %if.else8.i.i

land.lhs.true.i.i:                                ; preds = %do.body.i.i
  %i_key.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1
  %11 = load double, ptr %i_key.i.i, align 8
  %cmp5.i.i = fcmp oeq double %11, %conv.i6.i
  br i1 %cmp5.i.i, label %lua_rawgeti.exit, label %if.else8.i.i

if.else8.i.i:                                     ; preds = %land.lhs.true.i.i, %do.body.i.i
  %next.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1, i32 0, i32 2
  %12 = load ptr, ptr %next.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %12, null
  br i1 %tobool.not.i.i, label %lua_rawgeti.exit, label %do.body.i.i, !llvm.loop !7

lua_rawgeti.exit:                                 ; preds = %land.lhs.true.i.i, %if.else8.i.i, %if.then.i9.i
  %retval.0.i8.i = phi ptr [ %arrayidx.i11.i, %if.then.i9.i ], [ @luaO_nilobject_, %if.else8.i.i ], [ %n.0.i.i, %land.lhs.true.i.i ]
  %13 = load i64, ptr %retval.0.i8.i, align 8
  store i64 %13, ptr %2, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i8.i, i64 0, i32 1
  %14 = load i32, ptr %tt.i, align 8
  %tt4.i = getelementptr inbounds %struct.lua_TValue, ptr %2, i64 0, i32 1
  store i32 %14, ptr %tt4.i, align 8
  %15 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %15, i64 1
  store ptr %incdec.ptr.i, ptr %top.i.i, align 8
  %16 = load ptr, ptr %base.i.i, align 8
  %cmp1.not.i.i82 = icmp ult ptr %16, %incdec.ptr.i
  %add.ptr.luaO_nilobject_.i.i83 = select i1 %cmp1.not.i.i82, ptr %16, ptr @luaO_nilobject_
  %17 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i83, align 8
  %sub.i.i84 = add i32 %u.addr.0714, -1
  %sizearray.i.i85 = getelementptr inbounds %struct.Table, ptr %17, i64 0, i32 10
  %18 = load i32, ptr %sizearray.i.i85, align 8
  %cmp.i5.i86 = icmp ult i32 %sub.i.i84, %18
  br i1 %cmp.i5.i86, label %if.then.i9.i121, label %if.else.i.i87

if.then.i9.i121:                                  ; preds = %lua_rawgeti.exit
  %array.i.i122 = getelementptr inbounds %struct.Table, ptr %17, i64 0, i32 6
  %19 = load ptr, ptr %array.i.i122, align 8
  %idxprom.i10.i123 = sext i32 %sub.i.i84 to i64
  %arrayidx.i11.i124 = getelementptr inbounds %struct.lua_TValue, ptr %19, i64 %idxprom.i10.i123
  br label %lua_rawgeti.exit125

if.else.i.i87:                                    ; preds = %lua_rawgeti.exit
  %conv.i6.i88 = sitofp i32 %u.addr.0714 to double
  %cmp.i.i.i89 = icmp eq i32 %u.addr.0714, 0
  br i1 %cmp.i.i.i89, label %if.then.i.i.i119, label %if.end.i.i.i90

if.then.i.i.i119:                                 ; preds = %if.else.i.i87
  %node.i.i.i120 = getelementptr inbounds %struct.Table, ptr %17, i64 0, i32 7
  %20 = load ptr, ptr %node.i.i.i120, align 8
  br label %do.body.i.i104.preheader

if.end.i.i.i90:                                   ; preds = %if.else.i.i87
  %21 = bitcast double %conv.i6.i88 to i64
  %a.sroa.0.4.extract.shift.i.i.i91 = lshr i64 %21, 32
  %add.i.i.i92 = add i64 %a.sroa.0.4.extract.shift.i.i.i91, %21
  %node4.i.i.i93 = getelementptr inbounds %struct.Table, ptr %17, i64 0, i32 7
  %22 = load ptr, ptr %node4.i.i.i93, align 8
  %conv.i.i.i94 = and i64 %add.i.i.i92, 4294967295
  %lsizenode.i.i.i95 = getelementptr inbounds %struct.Table, ptr %17, i64 0, i32 4
  %23 = load i8, ptr %lsizenode.i.i.i95, align 1
  %sh_prom.i.i.i96 = zext nneg i8 %23 to i64
  %notmask.i.i.i97 = shl nsw i64 -1, %sh_prom.i.i.i96
  %sub.i.i.i98 = xor i64 %notmask.i.i.i97, -1
  %or.i.i.i99 = or i64 %sub.i.i.i98, 1
  %rem.i.i.i100 = urem i64 %conv.i.i.i94, %or.i.i.i99
  %arrayidx7.i.i.i101 = getelementptr inbounds %struct.Node, ptr %22, i64 %rem.i.i.i100
  br label %do.body.i.i104.preheader

do.body.i.i104.preheader:                         ; preds = %if.end.i.i.i90, %if.then.i.i.i119
  %n.0.i.i105.ph = phi ptr [ %arrayidx7.i.i.i101, %if.end.i.i.i90 ], [ %20, %if.then.i.i.i119 ]
  br label %do.body.i.i104

do.body.i.i104:                                   ; preds = %do.body.i.i104.preheader, %if.else8.i.i108
  %n.0.i.i105 = phi ptr [ %26, %if.else8.i.i108 ], [ %n.0.i.i105.ph, %do.body.i.i104.preheader ]
  %tt.i7.i106 = getelementptr inbounds %struct.Node, ptr %n.0.i.i105, i64 0, i32 1, i32 0, i32 1
  %24 = load i32, ptr %tt.i7.i106, align 8
  %cmp2.i.i107 = icmp eq i32 %24, 3
  br i1 %cmp2.i.i107, label %land.lhs.true.i.i116, label %if.else8.i.i108

land.lhs.true.i.i116:                             ; preds = %do.body.i.i104
  %i_key.i.i117 = getelementptr inbounds %struct.Node, ptr %n.0.i.i105, i64 0, i32 1
  %25 = load double, ptr %i_key.i.i117, align 8
  %cmp5.i.i118 = fcmp oeq double %25, %conv.i6.i88
  br i1 %cmp5.i.i118, label %lua_rawgeti.exit125, label %if.else8.i.i108

if.else8.i.i108:                                  ; preds = %land.lhs.true.i.i116, %do.body.i.i104
  %next.i.i109 = getelementptr inbounds %struct.Node, ptr %n.0.i.i105, i64 0, i32 1, i32 0, i32 2
  %26 = load ptr, ptr %next.i.i109, align 8
  %tobool.not.i.i110 = icmp eq ptr %26, null
  br i1 %tobool.not.i.i110, label %lua_rawgeti.exit125, label %do.body.i.i104, !llvm.loop !7

lua_rawgeti.exit125:                              ; preds = %land.lhs.true.i.i116, %if.else8.i.i108, %if.then.i9.i121
  %retval.0.i8.i111 = phi ptr [ %arrayidx.i11.i124, %if.then.i9.i121 ], [ @luaO_nilobject_, %if.else8.i.i108 ], [ %n.0.i.i105, %land.lhs.true.i.i116 ]
  %27 = load i64, ptr %retval.0.i8.i111, align 8
  store i64 %27, ptr %incdec.ptr.i, align 8
  %tt.i113 = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i8.i111, i64 0, i32 1
  %28 = load i32, ptr %tt.i113, align 8
  %tt4.i114 = getelementptr inbounds %struct.lua_TValue, ptr %15, i64 1, i32 1
  store i32 %28, ptr %tt4.i114, align 8
  %29 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i115 = getelementptr inbounds %struct.lua_TValue, ptr %29, i64 1
  store ptr %incdec.ptr.i115, ptr %top.i.i, align 8
  %call = tail call fastcc i32 @sort_comp(ptr noundef %L, i32 noundef -1, i32 noundef -2), !range !23
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.else, label %if.then

if.then:                                          ; preds = %lua_rawgeti.exit125
  tail call fastcc void @lua_rawseti(ptr noundef nonnull %L, i32 noundef 1, i32 noundef %l.addr.0713)
  tail call fastcc void @lua_rawseti(ptr noundef nonnull %L, i32 noundef 1, i32 noundef %u.addr.0714)
  br label %if.end

if.else:                                          ; preds = %lua_rawgeti.exit125
  %30 = load ptr, ptr %top.i.i, align 8
  %add.ptr9.i = getelementptr %struct.lua_TValue, ptr %30, i64 -2
  store ptr %add.ptr9.i, ptr %top.i.i, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %sub = sub nsw i32 %u.addr.0714, %l.addr.0713
  %cmp1 = icmp eq i32 %sub, 1
  br i1 %cmp1, label %while.end53, label %if.end3

if.end3:                                          ; preds = %if.end
  %add = add nsw i32 %u.addr.0714, %l.addr.0713
  %div = sdiv i32 %add, 2
  %31 = load ptr, ptr %base.i.i, align 8
  %32 = load ptr, ptr %top.i.i, align 8
  %cmp1.not.i.i130 = icmp ult ptr %31, %32
  %add.ptr.luaO_nilobject_.i.i131 = select i1 %cmp1.not.i.i130, ptr %31, ptr @luaO_nilobject_
  %33 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i131, align 8
  %sub.i.i132 = add nsw i32 %div, -1
  %sizearray.i.i133 = getelementptr inbounds %struct.Table, ptr %33, i64 0, i32 10
  %34 = load i32, ptr %sizearray.i.i133, align 8
  %cmp.i5.i134 = icmp ult i32 %sub.i.i132, %34
  br i1 %cmp.i5.i134, label %if.then.i9.i169, label %if.else.i.i135

if.then.i9.i169:                                  ; preds = %if.end3
  %array.i.i170 = getelementptr inbounds %struct.Table, ptr %33, i64 0, i32 6
  %35 = load ptr, ptr %array.i.i170, align 8
  %idxprom.i10.i171 = sext i32 %sub.i.i132 to i64
  %arrayidx.i11.i172 = getelementptr inbounds %struct.lua_TValue, ptr %35, i64 %idxprom.i10.i171
  br label %lua_rawgeti.exit173

if.else.i.i135:                                   ; preds = %if.end3
  %conv.i6.i136 = sitofp i32 %div to double
  %add.off = add i32 %add, 1
  %cmp.i.i.i137 = icmp ult i32 %add.off, 3
  br i1 %cmp.i.i.i137, label %if.then.i.i.i167, label %if.end.i.i.i138

if.then.i.i.i167:                                 ; preds = %if.else.i.i135
  %node.i.i.i168 = getelementptr inbounds %struct.Table, ptr %33, i64 0, i32 7
  %36 = load ptr, ptr %node.i.i.i168, align 8
  br label %do.body.i.i152.preheader

if.end.i.i.i138:                                  ; preds = %if.else.i.i135
  %37 = bitcast double %conv.i6.i136 to i64
  %a.sroa.0.4.extract.shift.i.i.i139 = lshr i64 %37, 32
  %add.i.i.i140 = add i64 %a.sroa.0.4.extract.shift.i.i.i139, %37
  %node4.i.i.i141 = getelementptr inbounds %struct.Table, ptr %33, i64 0, i32 7
  %38 = load ptr, ptr %node4.i.i.i141, align 8
  %conv.i.i.i142 = and i64 %add.i.i.i140, 4294967295
  %lsizenode.i.i.i143 = getelementptr inbounds %struct.Table, ptr %33, i64 0, i32 4
  %39 = load i8, ptr %lsizenode.i.i.i143, align 1
  %sh_prom.i.i.i144 = zext nneg i8 %39 to i64
  %notmask.i.i.i145 = shl nsw i64 -1, %sh_prom.i.i.i144
  %sub.i.i.i146 = xor i64 %notmask.i.i.i145, -1
  %or.i.i.i147 = or i64 %sub.i.i.i146, 1
  %rem.i.i.i148 = urem i64 %conv.i.i.i142, %or.i.i.i147
  %arrayidx7.i.i.i149 = getelementptr inbounds %struct.Node, ptr %38, i64 %rem.i.i.i148
  br label %do.body.i.i152.preheader

do.body.i.i152.preheader:                         ; preds = %if.end.i.i.i138, %if.then.i.i.i167
  %n.0.i.i153.ph = phi ptr [ %arrayidx7.i.i.i149, %if.end.i.i.i138 ], [ %36, %if.then.i.i.i167 ]
  br label %do.body.i.i152

do.body.i.i152:                                   ; preds = %do.body.i.i152.preheader, %if.else8.i.i156
  %n.0.i.i153 = phi ptr [ %42, %if.else8.i.i156 ], [ %n.0.i.i153.ph, %do.body.i.i152.preheader ]
  %tt.i7.i154 = getelementptr inbounds %struct.Node, ptr %n.0.i.i153, i64 0, i32 1, i32 0, i32 1
  %40 = load i32, ptr %tt.i7.i154, align 8
  %cmp2.i.i155 = icmp eq i32 %40, 3
  br i1 %cmp2.i.i155, label %land.lhs.true.i.i164, label %if.else8.i.i156

land.lhs.true.i.i164:                             ; preds = %do.body.i.i152
  %i_key.i.i165 = getelementptr inbounds %struct.Node, ptr %n.0.i.i153, i64 0, i32 1
  %41 = load double, ptr %i_key.i.i165, align 8
  %cmp5.i.i166 = fcmp oeq double %41, %conv.i6.i136
  br i1 %cmp5.i.i166, label %lua_rawgeti.exit173, label %if.else8.i.i156

if.else8.i.i156:                                  ; preds = %land.lhs.true.i.i164, %do.body.i.i152
  %next.i.i157 = getelementptr inbounds %struct.Node, ptr %n.0.i.i153, i64 0, i32 1, i32 0, i32 2
  %42 = load ptr, ptr %next.i.i157, align 8
  %tobool.not.i.i158 = icmp eq ptr %42, null
  br i1 %tobool.not.i.i158, label %lua_rawgeti.exit173, label %do.body.i.i152, !llvm.loop !7

lua_rawgeti.exit173:                              ; preds = %land.lhs.true.i.i164, %if.else8.i.i156, %if.then.i9.i169
  %retval.0.i8.i159 = phi ptr [ %arrayidx.i11.i172, %if.then.i9.i169 ], [ @luaO_nilobject_, %if.else8.i.i156 ], [ %n.0.i.i153, %land.lhs.true.i.i164 ]
  %43 = load i64, ptr %retval.0.i8.i159, align 8
  store i64 %43, ptr %32, align 8
  %tt.i161 = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i8.i159, i64 0, i32 1
  %44 = load i32, ptr %tt.i161, align 8
  %tt4.i162 = getelementptr inbounds %struct.lua_TValue, ptr %32, i64 0, i32 1
  store i32 %44, ptr %tt4.i162, align 8
  %45 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i163 = getelementptr inbounds %struct.lua_TValue, ptr %45, i64 1
  store ptr %incdec.ptr.i163, ptr %top.i.i, align 8
  %46 = load ptr, ptr %base.i.i, align 8
  %cmp1.not.i.i177 = icmp ult ptr %46, %incdec.ptr.i163
  %add.ptr.luaO_nilobject_.i.i178 = select i1 %cmp1.not.i.i177, ptr %46, ptr @luaO_nilobject_
  %47 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i178, align 8
  %sizearray.i.i180 = getelementptr inbounds %struct.Table, ptr %47, i64 0, i32 10
  %48 = load i32, ptr %sizearray.i.i180, align 8
  %cmp.i5.i181 = icmp ult i32 %sub.i.i, %48
  br i1 %cmp.i5.i181, label %if.then.i9.i216, label %if.else.i.i182

if.then.i9.i216:                                  ; preds = %lua_rawgeti.exit173
  %array.i.i217 = getelementptr inbounds %struct.Table, ptr %47, i64 0, i32 6
  %49 = load ptr, ptr %array.i.i217, align 8
  %idxprom.i10.i218 = sext i32 %sub.i.i to i64
  %arrayidx.i11.i219 = getelementptr inbounds %struct.lua_TValue, ptr %49, i64 %idxprom.i10.i218
  br label %lua_rawgeti.exit220

if.else.i.i182:                                   ; preds = %lua_rawgeti.exit173
  %conv.i6.i183 = sitofp i32 %l.addr.0713 to double
  %cmp.i.i.i184 = icmp eq i32 %l.addr.0713, 0
  br i1 %cmp.i.i.i184, label %if.then.i.i.i214, label %if.end.i.i.i185

if.then.i.i.i214:                                 ; preds = %if.else.i.i182
  %node.i.i.i215 = getelementptr inbounds %struct.Table, ptr %47, i64 0, i32 7
  %50 = load ptr, ptr %node.i.i.i215, align 8
  br label %do.body.i.i199.preheader

if.end.i.i.i185:                                  ; preds = %if.else.i.i182
  %51 = bitcast double %conv.i6.i183 to i64
  %a.sroa.0.4.extract.shift.i.i.i186 = lshr i64 %51, 32
  %add.i.i.i187 = add i64 %a.sroa.0.4.extract.shift.i.i.i186, %51
  %node4.i.i.i188 = getelementptr inbounds %struct.Table, ptr %47, i64 0, i32 7
  %52 = load ptr, ptr %node4.i.i.i188, align 8
  %conv.i.i.i189 = and i64 %add.i.i.i187, 4294967295
  %lsizenode.i.i.i190 = getelementptr inbounds %struct.Table, ptr %47, i64 0, i32 4
  %53 = load i8, ptr %lsizenode.i.i.i190, align 1
  %sh_prom.i.i.i191 = zext nneg i8 %53 to i64
  %notmask.i.i.i192 = shl nsw i64 -1, %sh_prom.i.i.i191
  %sub.i.i.i193 = xor i64 %notmask.i.i.i192, -1
  %or.i.i.i194 = or i64 %sub.i.i.i193, 1
  %rem.i.i.i195 = urem i64 %conv.i.i.i189, %or.i.i.i194
  %arrayidx7.i.i.i196 = getelementptr inbounds %struct.Node, ptr %52, i64 %rem.i.i.i195
  br label %do.body.i.i199.preheader

do.body.i.i199.preheader:                         ; preds = %if.end.i.i.i185, %if.then.i.i.i214
  %n.0.i.i200.ph = phi ptr [ %arrayidx7.i.i.i196, %if.end.i.i.i185 ], [ %50, %if.then.i.i.i214 ]
  br label %do.body.i.i199

do.body.i.i199:                                   ; preds = %do.body.i.i199.preheader, %if.else8.i.i203
  %n.0.i.i200 = phi ptr [ %56, %if.else8.i.i203 ], [ %n.0.i.i200.ph, %do.body.i.i199.preheader ]
  %tt.i7.i201 = getelementptr inbounds %struct.Node, ptr %n.0.i.i200, i64 0, i32 1, i32 0, i32 1
  %54 = load i32, ptr %tt.i7.i201, align 8
  %cmp2.i.i202 = icmp eq i32 %54, 3
  br i1 %cmp2.i.i202, label %land.lhs.true.i.i211, label %if.else8.i.i203

land.lhs.true.i.i211:                             ; preds = %do.body.i.i199
  %i_key.i.i212 = getelementptr inbounds %struct.Node, ptr %n.0.i.i200, i64 0, i32 1
  %55 = load double, ptr %i_key.i.i212, align 8
  %cmp5.i.i213 = fcmp oeq double %55, %conv.i6.i183
  br i1 %cmp5.i.i213, label %lua_rawgeti.exit220, label %if.else8.i.i203

if.else8.i.i203:                                  ; preds = %land.lhs.true.i.i211, %do.body.i.i199
  %next.i.i204 = getelementptr inbounds %struct.Node, ptr %n.0.i.i200, i64 0, i32 1, i32 0, i32 2
  %56 = load ptr, ptr %next.i.i204, align 8
  %tobool.not.i.i205 = icmp eq ptr %56, null
  br i1 %tobool.not.i.i205, label %lua_rawgeti.exit220, label %do.body.i.i199, !llvm.loop !7

lua_rawgeti.exit220:                              ; preds = %land.lhs.true.i.i211, %if.else8.i.i203, %if.then.i9.i216
  %retval.0.i8.i206 = phi ptr [ %arrayidx.i11.i219, %if.then.i9.i216 ], [ @luaO_nilobject_, %if.else8.i.i203 ], [ %n.0.i.i200, %land.lhs.true.i.i211 ]
  %57 = load i64, ptr %retval.0.i8.i206, align 8
  store i64 %57, ptr %incdec.ptr.i163, align 8
  %tt.i208 = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i8.i206, i64 0, i32 1
  %58 = load i32, ptr %tt.i208, align 8
  %tt4.i209 = getelementptr inbounds %struct.lua_TValue, ptr %45, i64 1, i32 1
  store i32 %58, ptr %tt4.i209, align 8
  %59 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i210 = getelementptr inbounds %struct.lua_TValue, ptr %59, i64 1
  store ptr %incdec.ptr.i210, ptr %top.i.i, align 8
  %call4 = tail call fastcc i32 @sort_comp(ptr noundef %L, i32 noundef -2, i32 noundef -1), !range !23
  %tobool5.not = icmp eq i32 %call4, 0
  br i1 %tobool5.not, label %if.else7, label %if.then6

if.then6:                                         ; preds = %lua_rawgeti.exit220
  tail call fastcc void @lua_rawseti(ptr noundef nonnull %L, i32 noundef 1, i32 noundef %div)
  tail call fastcc void @lua_rawseti(ptr noundef nonnull %L, i32 noundef 1, i32 noundef %l.addr.0713)
  br label %if.end13

if.else7:                                         ; preds = %lua_rawgeti.exit220
  %60 = load ptr, ptr %top.i.i, align 8
  %add.ptr9.i222 = getelementptr %struct.lua_TValue, ptr %60, i64 -1
  store ptr %add.ptr9.i222, ptr %top.i.i, align 8
  %61 = load ptr, ptr %base.i.i, align 8
  %cmp1.not.i.i226 = icmp ult ptr %61, %add.ptr9.i222
  %add.ptr.luaO_nilobject_.i.i227 = select i1 %cmp1.not.i.i226, ptr %61, ptr @luaO_nilobject_
  %62 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i227, align 8
  %sizearray.i.i229 = getelementptr inbounds %struct.Table, ptr %62, i64 0, i32 10
  %63 = load i32, ptr %sizearray.i.i229, align 8
  %cmp.i5.i230 = icmp ult i32 %sub.i.i84, %63
  br i1 %cmp.i5.i230, label %if.then.i9.i265, label %if.else.i.i231

if.then.i9.i265:                                  ; preds = %if.else7
  %array.i.i266 = getelementptr inbounds %struct.Table, ptr %62, i64 0, i32 6
  %64 = load ptr, ptr %array.i.i266, align 8
  %idxprom.i10.i267 = sext i32 %sub.i.i84 to i64
  %arrayidx.i11.i268 = getelementptr inbounds %struct.lua_TValue, ptr %64, i64 %idxprom.i10.i267
  br label %lua_rawgeti.exit269

if.else.i.i231:                                   ; preds = %if.else7
  %conv.i6.i232 = sitofp i32 %u.addr.0714 to double
  %cmp.i.i.i233 = icmp eq i32 %u.addr.0714, 0
  br i1 %cmp.i.i.i233, label %if.then.i.i.i263, label %if.end.i.i.i234

if.then.i.i.i263:                                 ; preds = %if.else.i.i231
  %node.i.i.i264 = getelementptr inbounds %struct.Table, ptr %62, i64 0, i32 7
  %65 = load ptr, ptr %node.i.i.i264, align 8
  br label %do.body.i.i248.preheader

if.end.i.i.i234:                                  ; preds = %if.else.i.i231
  %66 = bitcast double %conv.i6.i232 to i64
  %a.sroa.0.4.extract.shift.i.i.i235 = lshr i64 %66, 32
  %add.i.i.i236 = add i64 %a.sroa.0.4.extract.shift.i.i.i235, %66
  %node4.i.i.i237 = getelementptr inbounds %struct.Table, ptr %62, i64 0, i32 7
  %67 = load ptr, ptr %node4.i.i.i237, align 8
  %conv.i.i.i238 = and i64 %add.i.i.i236, 4294967295
  %lsizenode.i.i.i239 = getelementptr inbounds %struct.Table, ptr %62, i64 0, i32 4
  %68 = load i8, ptr %lsizenode.i.i.i239, align 1
  %sh_prom.i.i.i240 = zext nneg i8 %68 to i64
  %notmask.i.i.i241 = shl nsw i64 -1, %sh_prom.i.i.i240
  %sub.i.i.i242 = xor i64 %notmask.i.i.i241, -1
  %or.i.i.i243 = or i64 %sub.i.i.i242, 1
  %rem.i.i.i244 = urem i64 %conv.i.i.i238, %or.i.i.i243
  %arrayidx7.i.i.i245 = getelementptr inbounds %struct.Node, ptr %67, i64 %rem.i.i.i244
  br label %do.body.i.i248.preheader

do.body.i.i248.preheader:                         ; preds = %if.end.i.i.i234, %if.then.i.i.i263
  %n.0.i.i249.ph = phi ptr [ %arrayidx7.i.i.i245, %if.end.i.i.i234 ], [ %65, %if.then.i.i.i263 ]
  br label %do.body.i.i248

do.body.i.i248:                                   ; preds = %do.body.i.i248.preheader, %if.else8.i.i252
  %n.0.i.i249 = phi ptr [ %71, %if.else8.i.i252 ], [ %n.0.i.i249.ph, %do.body.i.i248.preheader ]
  %tt.i7.i250 = getelementptr inbounds %struct.Node, ptr %n.0.i.i249, i64 0, i32 1, i32 0, i32 1
  %69 = load i32, ptr %tt.i7.i250, align 8
  %cmp2.i.i251 = icmp eq i32 %69, 3
  br i1 %cmp2.i.i251, label %land.lhs.true.i.i260, label %if.else8.i.i252

land.lhs.true.i.i260:                             ; preds = %do.body.i.i248
  %i_key.i.i261 = getelementptr inbounds %struct.Node, ptr %n.0.i.i249, i64 0, i32 1
  %70 = load double, ptr %i_key.i.i261, align 8
  %cmp5.i.i262 = fcmp oeq double %70, %conv.i6.i232
  br i1 %cmp5.i.i262, label %lua_rawgeti.exit269, label %if.else8.i.i252

if.else8.i.i252:                                  ; preds = %land.lhs.true.i.i260, %do.body.i.i248
  %next.i.i253 = getelementptr inbounds %struct.Node, ptr %n.0.i.i249, i64 0, i32 1, i32 0, i32 2
  %71 = load ptr, ptr %next.i.i253, align 8
  %tobool.not.i.i254 = icmp eq ptr %71, null
  br i1 %tobool.not.i.i254, label %lua_rawgeti.exit269, label %do.body.i.i248, !llvm.loop !7

lua_rawgeti.exit269:                              ; preds = %land.lhs.true.i.i260, %if.else8.i.i252, %if.then.i9.i265
  %retval.0.i8.i255 = phi ptr [ %arrayidx.i11.i268, %if.then.i9.i265 ], [ @luaO_nilobject_, %if.else8.i.i252 ], [ %n.0.i.i249, %land.lhs.true.i.i260 ]
  %72 = load i64, ptr %retval.0.i8.i255, align 8
  store i64 %72, ptr %add.ptr9.i222, align 8
  %tt.i257 = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i8.i255, i64 0, i32 1
  %73 = load i32, ptr %tt.i257, align 8
  %tt4.i258 = getelementptr %struct.lua_TValue, ptr %60, i64 -1, i32 1
  store i32 %73, ptr %tt4.i258, align 8
  %74 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i259 = getelementptr inbounds %struct.lua_TValue, ptr %74, i64 1
  store ptr %incdec.ptr.i259, ptr %top.i.i, align 8
  %call8 = tail call fastcc i32 @sort_comp(ptr noundef %L, i32 noundef -1, i32 noundef -2), !range !23
  %tobool9.not = icmp eq i32 %call8, 0
  br i1 %tobool9.not, label %if.else11, label %if.then10

if.then10:                                        ; preds = %lua_rawgeti.exit269
  tail call fastcc void @lua_rawseti(ptr noundef nonnull %L, i32 noundef 1, i32 noundef %div)
  tail call fastcc void @lua_rawseti(ptr noundef nonnull %L, i32 noundef 1, i32 noundef %u.addr.0714)
  br label %if.end13

if.else11:                                        ; preds = %lua_rawgeti.exit269
  %75 = load ptr, ptr %top.i.i, align 8
  %add.ptr9.i271 = getelementptr %struct.lua_TValue, ptr %75, i64 -2
  store ptr %add.ptr9.i271, ptr %top.i.i, align 8
  br label %if.end13

if.end13:                                         ; preds = %if.then10, %if.else11, %if.then6
  %cmp15 = icmp eq i32 %sub, 2
  br i1 %cmp15, label %while.end53, label %if.end17

if.end17:                                         ; preds = %if.end13
  %76 = load ptr, ptr %base.i.i, align 8
  %77 = load ptr, ptr %top.i.i, align 8
  %cmp1.not.i.i275 = icmp ult ptr %76, %77
  %add.ptr.luaO_nilobject_.i.i276 = select i1 %cmp1.not.i.i275, ptr %76, ptr @luaO_nilobject_
  %78 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i276, align 8
  %sizearray.i.i278 = getelementptr inbounds %struct.Table, ptr %78, i64 0, i32 10
  %79 = load i32, ptr %sizearray.i.i278, align 8
  %cmp.i5.i279 = icmp ult i32 %sub.i.i132, %79
  br i1 %cmp.i5.i279, label %if.then.i9.i314, label %if.else.i.i280

if.then.i9.i314:                                  ; preds = %if.end17
  %array.i.i315 = getelementptr inbounds %struct.Table, ptr %78, i64 0, i32 6
  %80 = load ptr, ptr %array.i.i315, align 8
  %idxprom.i10.i316 = sext i32 %sub.i.i132 to i64
  %arrayidx.i11.i317 = getelementptr inbounds %struct.lua_TValue, ptr %80, i64 %idxprom.i10.i316
  br label %lua_rawgeti.exit318

if.else.i.i280:                                   ; preds = %if.end17
  %conv.i6.i281 = sitofp i32 %div to double
  %add.off700 = add i32 %add, 1
  %cmp.i.i.i282 = icmp ult i32 %add.off700, 3
  br i1 %cmp.i.i.i282, label %if.then.i.i.i312, label %if.end.i.i.i283

if.then.i.i.i312:                                 ; preds = %if.else.i.i280
  %node.i.i.i313 = getelementptr inbounds %struct.Table, ptr %78, i64 0, i32 7
  %81 = load ptr, ptr %node.i.i.i313, align 8
  br label %do.body.i.i297.preheader

if.end.i.i.i283:                                  ; preds = %if.else.i.i280
  %82 = bitcast double %conv.i6.i281 to i64
  %a.sroa.0.4.extract.shift.i.i.i284 = lshr i64 %82, 32
  %add.i.i.i285 = add i64 %a.sroa.0.4.extract.shift.i.i.i284, %82
  %node4.i.i.i286 = getelementptr inbounds %struct.Table, ptr %78, i64 0, i32 7
  %83 = load ptr, ptr %node4.i.i.i286, align 8
  %conv.i.i.i287 = and i64 %add.i.i.i285, 4294967295
  %lsizenode.i.i.i288 = getelementptr inbounds %struct.Table, ptr %78, i64 0, i32 4
  %84 = load i8, ptr %lsizenode.i.i.i288, align 1
  %sh_prom.i.i.i289 = zext nneg i8 %84 to i64
  %notmask.i.i.i290 = shl nsw i64 -1, %sh_prom.i.i.i289
  %sub.i.i.i291 = xor i64 %notmask.i.i.i290, -1
  %or.i.i.i292 = or i64 %sub.i.i.i291, 1
  %rem.i.i.i293 = urem i64 %conv.i.i.i287, %or.i.i.i292
  %arrayidx7.i.i.i294 = getelementptr inbounds %struct.Node, ptr %83, i64 %rem.i.i.i293
  br label %do.body.i.i297.preheader

do.body.i.i297.preheader:                         ; preds = %if.end.i.i.i283, %if.then.i.i.i312
  %n.0.i.i298.ph = phi ptr [ %arrayidx7.i.i.i294, %if.end.i.i.i283 ], [ %81, %if.then.i.i.i312 ]
  br label %do.body.i.i297

do.body.i.i297:                                   ; preds = %do.body.i.i297.preheader, %if.else8.i.i301
  %n.0.i.i298 = phi ptr [ %87, %if.else8.i.i301 ], [ %n.0.i.i298.ph, %do.body.i.i297.preheader ]
  %tt.i7.i299 = getelementptr inbounds %struct.Node, ptr %n.0.i.i298, i64 0, i32 1, i32 0, i32 1
  %85 = load i32, ptr %tt.i7.i299, align 8
  %cmp2.i.i300 = icmp eq i32 %85, 3
  br i1 %cmp2.i.i300, label %land.lhs.true.i.i309, label %if.else8.i.i301

land.lhs.true.i.i309:                             ; preds = %do.body.i.i297
  %i_key.i.i310 = getelementptr inbounds %struct.Node, ptr %n.0.i.i298, i64 0, i32 1
  %86 = load double, ptr %i_key.i.i310, align 8
  %cmp5.i.i311 = fcmp oeq double %86, %conv.i6.i281
  br i1 %cmp5.i.i311, label %lua_rawgeti.exit318, label %if.else8.i.i301

if.else8.i.i301:                                  ; preds = %land.lhs.true.i.i309, %do.body.i.i297
  %next.i.i302 = getelementptr inbounds %struct.Node, ptr %n.0.i.i298, i64 0, i32 1, i32 0, i32 2
  %87 = load ptr, ptr %next.i.i302, align 8
  %tobool.not.i.i303 = icmp eq ptr %87, null
  br i1 %tobool.not.i.i303, label %lua_rawgeti.exit318, label %do.body.i.i297, !llvm.loop !7

lua_rawgeti.exit318:                              ; preds = %land.lhs.true.i.i309, %if.else8.i.i301, %if.then.i9.i314
  %retval.0.i8.i304 = phi ptr [ %arrayidx.i11.i317, %if.then.i9.i314 ], [ @luaO_nilobject_, %if.else8.i.i301 ], [ %n.0.i.i298, %land.lhs.true.i.i309 ]
  %88 = load i64, ptr %retval.0.i8.i304, align 8
  store i64 %88, ptr %77, align 8
  %tt.i306 = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i8.i304, i64 0, i32 1
  %89 = load i32, ptr %tt.i306, align 8
  %tt4.i307 = getelementptr inbounds %struct.lua_TValue, ptr %77, i64 0, i32 1
  store i32 %89, ptr %tt4.i307, align 8
  %90 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i308 = getelementptr inbounds %struct.lua_TValue, ptr %90, i64 1
  store ptr %incdec.ptr.i308, ptr %top.i.i, align 8
  %91 = load i64, ptr %90, align 8
  store i64 %91, ptr %incdec.ptr.i308, align 8
  %tt.i320 = getelementptr inbounds %struct.lua_TValue, ptr %90, i64 0, i32 1
  %92 = load i32, ptr %tt.i320, align 8
  %tt2.i = getelementptr inbounds %struct.lua_TValue, ptr %90, i64 1, i32 1
  store i32 %92, ptr %tt2.i, align 8
  %93 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i321 = getelementptr inbounds %struct.lua_TValue, ptr %93, i64 1
  store ptr %incdec.ptr.i321, ptr %top.i.i, align 8
  %94 = load ptr, ptr %base.i.i, align 8
  %cmp1.not.i.i325 = icmp ult ptr %94, %incdec.ptr.i321
  %add.ptr.luaO_nilobject_.i.i326 = select i1 %cmp1.not.i.i325, ptr %94, ptr @luaO_nilobject_
  %95 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i326, align 8
  %sub.i.i327 = add i32 %u.addr.0714, -2
  %sizearray.i.i328 = getelementptr inbounds %struct.Table, ptr %95, i64 0, i32 10
  %96 = load i32, ptr %sizearray.i.i328, align 8
  %cmp.i5.i329 = icmp ult i32 %sub.i.i327, %96
  br i1 %cmp.i5.i329, label %if.then.i9.i364, label %if.else.i.i330

if.then.i9.i364:                                  ; preds = %lua_rawgeti.exit318
  %array.i.i365 = getelementptr inbounds %struct.Table, ptr %95, i64 0, i32 6
  %97 = load ptr, ptr %array.i.i365, align 8
  %idxprom.i10.i366 = sext i32 %sub.i.i327 to i64
  %arrayidx.i11.i367 = getelementptr inbounds %struct.lua_TValue, ptr %97, i64 %idxprom.i10.i366
  br label %lua_rawgeti.exit368

if.else.i.i330:                                   ; preds = %lua_rawgeti.exit318
  %conv.i6.i331 = sitofp i32 %sub.i.i84 to double
  %cmp.i.i.i332 = icmp eq i32 %sub.i.i84, 0
  br i1 %cmp.i.i.i332, label %if.then.i.i.i362, label %if.end.i.i.i333

if.then.i.i.i362:                                 ; preds = %if.else.i.i330
  %node.i.i.i363 = getelementptr inbounds %struct.Table, ptr %95, i64 0, i32 7
  %98 = load ptr, ptr %node.i.i.i363, align 8
  br label %do.body.i.i347.preheader

if.end.i.i.i333:                                  ; preds = %if.else.i.i330
  %99 = bitcast double %conv.i6.i331 to i64
  %a.sroa.0.4.extract.shift.i.i.i334 = lshr i64 %99, 32
  %add.i.i.i335 = add i64 %a.sroa.0.4.extract.shift.i.i.i334, %99
  %node4.i.i.i336 = getelementptr inbounds %struct.Table, ptr %95, i64 0, i32 7
  %100 = load ptr, ptr %node4.i.i.i336, align 8
  %conv.i.i.i337 = and i64 %add.i.i.i335, 4294967295
  %lsizenode.i.i.i338 = getelementptr inbounds %struct.Table, ptr %95, i64 0, i32 4
  %101 = load i8, ptr %lsizenode.i.i.i338, align 1
  %sh_prom.i.i.i339 = zext nneg i8 %101 to i64
  %notmask.i.i.i340 = shl nsw i64 -1, %sh_prom.i.i.i339
  %sub.i.i.i341 = xor i64 %notmask.i.i.i340, -1
  %or.i.i.i342 = or i64 %sub.i.i.i341, 1
  %rem.i.i.i343 = urem i64 %conv.i.i.i337, %or.i.i.i342
  %arrayidx7.i.i.i344 = getelementptr inbounds %struct.Node, ptr %100, i64 %rem.i.i.i343
  br label %do.body.i.i347.preheader

do.body.i.i347.preheader:                         ; preds = %if.end.i.i.i333, %if.then.i.i.i362
  %n.0.i.i348.ph = phi ptr [ %arrayidx7.i.i.i344, %if.end.i.i.i333 ], [ %98, %if.then.i.i.i362 ]
  br label %do.body.i.i347

do.body.i.i347:                                   ; preds = %do.body.i.i347.preheader, %if.else8.i.i351
  %n.0.i.i348 = phi ptr [ %104, %if.else8.i.i351 ], [ %n.0.i.i348.ph, %do.body.i.i347.preheader ]
  %tt.i7.i349 = getelementptr inbounds %struct.Node, ptr %n.0.i.i348, i64 0, i32 1, i32 0, i32 1
  %102 = load i32, ptr %tt.i7.i349, align 8
  %cmp2.i.i350 = icmp eq i32 %102, 3
  br i1 %cmp2.i.i350, label %land.lhs.true.i.i359, label %if.else8.i.i351

land.lhs.true.i.i359:                             ; preds = %do.body.i.i347
  %i_key.i.i360 = getelementptr inbounds %struct.Node, ptr %n.0.i.i348, i64 0, i32 1
  %103 = load double, ptr %i_key.i.i360, align 8
  %cmp5.i.i361 = fcmp oeq double %103, %conv.i6.i331
  br i1 %cmp5.i.i361, label %lua_rawgeti.exit368, label %if.else8.i.i351

if.else8.i.i351:                                  ; preds = %land.lhs.true.i.i359, %do.body.i.i347
  %next.i.i352 = getelementptr inbounds %struct.Node, ptr %n.0.i.i348, i64 0, i32 1, i32 0, i32 2
  %104 = load ptr, ptr %next.i.i352, align 8
  %tobool.not.i.i353 = icmp eq ptr %104, null
  br i1 %tobool.not.i.i353, label %lua_rawgeti.exit368, label %do.body.i.i347, !llvm.loop !7

lua_rawgeti.exit368:                              ; preds = %land.lhs.true.i.i359, %if.else8.i.i351, %if.then.i9.i364
  %retval.0.i8.i354 = phi ptr [ %arrayidx.i11.i367, %if.then.i9.i364 ], [ @luaO_nilobject_, %if.else8.i.i351 ], [ %n.0.i.i348, %land.lhs.true.i.i359 ]
  %105 = load i64, ptr %retval.0.i8.i354, align 8
  store i64 %105, ptr %incdec.ptr.i321, align 8
  %tt.i356 = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i8.i354, i64 0, i32 1
  %106 = load i32, ptr %tt.i356, align 8
  %tt4.i357 = getelementptr inbounds %struct.lua_TValue, ptr %93, i64 1, i32 1
  store i32 %106, ptr %tt4.i357, align 8
  %107 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i358 = getelementptr inbounds %struct.lua_TValue, ptr %107, i64 1
  store ptr %incdec.ptr.i358, ptr %top.i.i, align 8
  tail call fastcc void @lua_rawseti(ptr noundef %L, i32 noundef 1, i32 noundef %div)
  tail call fastcc void @lua_rawseti(ptr noundef %L, i32 noundef 1, i32 noundef %sub.i.i84)
  %108 = sext i32 %u.addr.0714 to i64
  %109 = sext i32 %l.addr.0713 to i64
  %.pre.pre = load ptr, ptr %top.i.i, align 8
  br label %for.cond

for.cond:                                         ; preds = %lua_rawseti.exit, %lua_rawgeti.exit368
  %.pre = phi ptr [ %.pre.pre, %lua_rawgeti.exit368 ], [ %incdec.ptr.i622, %lua_rawseti.exit ]
  %i.0 = phi i32 [ %l.addr.0713, %lua_rawgeti.exit368 ], [ %143, %lua_rawseti.exit ]
  %j.0 = phi i32 [ %sub.i.i84, %lua_rawgeti.exit368 ], [ %.pre-phi, %lua_rawseti.exit ]
  %110 = sext i32 %i.0 to i64
  br label %while.cond21

while.cond21:                                     ; preds = %if.end28, %for.cond
  %111 = phi ptr [ %add.ptr9.i420, %if.end28 ], [ %.pre, %for.cond ]
  %indvars.iv = phi i64 [ %indvars.iv.next, %if.end28 ], [ %110, %for.cond ]
  %indvars.iv.next = add nsw i64 %indvars.iv, 1
  %112 = load ptr, ptr %base.i.i, align 8
  %cmp1.not.i.i372 = icmp ult ptr %112, %111
  %add.ptr.luaO_nilobject_.i.i373 = select i1 %cmp1.not.i.i372, ptr %112, ptr @luaO_nilobject_
  %113 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i373, align 8
  %sizearray.i.i374 = getelementptr inbounds %struct.Table, ptr %113, i64 0, i32 10
  %114 = load i32, ptr %sizearray.i.i374, align 8
  %115 = trunc i64 %indvars.iv to i32
  %cmp.i5.i375 = icmp ugt i32 %114, %115
  br i1 %cmp.i5.i375, label %if.then.i9.i410, label %if.else.i.i376

if.then.i9.i410:                                  ; preds = %while.cond21
  %array.i.i411 = getelementptr inbounds %struct.Table, ptr %113, i64 0, i32 6
  %116 = load ptr, ptr %array.i.i411, align 8
  %arrayidx.i11.i413 = getelementptr inbounds %struct.lua_TValue, ptr %116, i64 %indvars.iv
  br label %lua_rawgeti.exit414

if.else.i.i376:                                   ; preds = %while.cond21
  %117 = trunc i64 %indvars.iv.next to i32
  %conv.i6.i377 = sitofp i32 %117 to double
  %cmp.i.i.i378 = icmp eq i32 %117, 0
  br i1 %cmp.i.i.i378, label %if.then.i.i.i408, label %if.end.i.i.i379

if.then.i.i.i408:                                 ; preds = %if.else.i.i376
  %node.i.i.i409 = getelementptr inbounds %struct.Table, ptr %113, i64 0, i32 7
  %118 = load ptr, ptr %node.i.i.i409, align 8
  br label %do.body.i.i393.preheader

if.end.i.i.i379:                                  ; preds = %if.else.i.i376
  %119 = bitcast double %conv.i6.i377 to i64
  %a.sroa.0.4.extract.shift.i.i.i380 = lshr i64 %119, 32
  %add.i.i.i381 = add i64 %a.sroa.0.4.extract.shift.i.i.i380, %119
  %node4.i.i.i382 = getelementptr inbounds %struct.Table, ptr %113, i64 0, i32 7
  %120 = load ptr, ptr %node4.i.i.i382, align 8
  %conv.i.i.i383 = and i64 %add.i.i.i381, 4294967295
  %lsizenode.i.i.i384 = getelementptr inbounds %struct.Table, ptr %113, i64 0, i32 4
  %121 = load i8, ptr %lsizenode.i.i.i384, align 1
  %sh_prom.i.i.i385 = zext nneg i8 %121 to i64
  %notmask.i.i.i386 = shl nsw i64 -1, %sh_prom.i.i.i385
  %sub.i.i.i387 = xor i64 %notmask.i.i.i386, -1
  %or.i.i.i388 = or i64 %sub.i.i.i387, 1
  %rem.i.i.i389 = urem i64 %conv.i.i.i383, %or.i.i.i388
  %arrayidx7.i.i.i390 = getelementptr inbounds %struct.Node, ptr %120, i64 %rem.i.i.i389
  br label %do.body.i.i393.preheader

do.body.i.i393.preheader:                         ; preds = %if.end.i.i.i379, %if.then.i.i.i408
  %n.0.i.i394.ph = phi ptr [ %arrayidx7.i.i.i390, %if.end.i.i.i379 ], [ %118, %if.then.i.i.i408 ]
  br label %do.body.i.i393

do.body.i.i393:                                   ; preds = %do.body.i.i393.preheader, %if.else8.i.i397
  %n.0.i.i394 = phi ptr [ %124, %if.else8.i.i397 ], [ %n.0.i.i394.ph, %do.body.i.i393.preheader ]
  %tt.i7.i395 = getelementptr inbounds %struct.Node, ptr %n.0.i.i394, i64 0, i32 1, i32 0, i32 1
  %122 = load i32, ptr %tt.i7.i395, align 8
  %cmp2.i.i396 = icmp eq i32 %122, 3
  br i1 %cmp2.i.i396, label %land.lhs.true.i.i405, label %if.else8.i.i397

land.lhs.true.i.i405:                             ; preds = %do.body.i.i393
  %i_key.i.i406 = getelementptr inbounds %struct.Node, ptr %n.0.i.i394, i64 0, i32 1
  %123 = load double, ptr %i_key.i.i406, align 8
  %cmp5.i.i407 = fcmp oeq double %123, %conv.i6.i377
  br i1 %cmp5.i.i407, label %lua_rawgeti.exit414, label %if.else8.i.i397

if.else8.i.i397:                                  ; preds = %land.lhs.true.i.i405, %do.body.i.i393
  %next.i.i398 = getelementptr inbounds %struct.Node, ptr %n.0.i.i394, i64 0, i32 1, i32 0, i32 2
  %124 = load ptr, ptr %next.i.i398, align 8
  %tobool.not.i.i399 = icmp eq ptr %124, null
  br i1 %tobool.not.i.i399, label %lua_rawgeti.exit414, label %do.body.i.i393, !llvm.loop !7

lua_rawgeti.exit414:                              ; preds = %land.lhs.true.i.i405, %if.else8.i.i397, %if.then.i9.i410
  %retval.0.i8.i400 = phi ptr [ %arrayidx.i11.i413, %if.then.i9.i410 ], [ @luaO_nilobject_, %if.else8.i.i397 ], [ %n.0.i.i394, %land.lhs.true.i.i405 ]
  %125 = load i64, ptr %retval.0.i8.i400, align 8
  store i64 %125, ptr %111, align 8
  %tt.i402 = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i8.i400, i64 0, i32 1
  %126 = load i32, ptr %tt.i402, align 8
  %tt4.i403 = getelementptr inbounds %struct.lua_TValue, ptr %111, i64 0, i32 1
  store i32 %126, ptr %tt4.i403, align 8
  %127 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i404 = getelementptr inbounds %struct.lua_TValue, ptr %127, i64 1
  store ptr %incdec.ptr.i404, ptr %top.i.i, align 8
  %128 = load ptr, ptr %base.i.i, align 8
  %add.ptr.i.i.i = getelementptr %struct.lua_TValue, ptr %128, i64 1
  %cmp1.not.i.i.i = icmp uge ptr %128, %127
  %cmp.i.i = icmp eq ptr %add.ptr.i.i.i, @luaO_nilobject_
  %or.cond.i = or i1 %cmp1.not.i.i.i, %cmp.i.i
  br i1 %or.cond.i, label %if.then.i, label %lua_type.exit.i

lua_type.exit.i:                                  ; preds = %lua_rawgeti.exit414
  %tt.i.i = getelementptr %struct.lua_TValue, ptr %128, i64 1, i32 1
  %129 = load i32, ptr %tt.i.i, align 8
  %cmp.i = icmp eq i32 %129, 0
  br i1 %cmp.i, label %if.else.i, label %if.then.i

if.then.i:                                        ; preds = %lua_type.exit.i, %lua_rawgeti.exit414
  %add.ptr.luaO_nilobject_.i.i.i = select i1 %cmp1.not.i.i.i, ptr @luaO_nilobject_, ptr %add.ptr.i.i.i
  %130 = load i64, ptr %add.ptr.luaO_nilobject_.i.i.i, align 8
  store i64 %130, ptr %incdec.ptr.i404, align 8
  %tt.i15.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i.i, i64 0, i32 1
  %131 = load i32, ptr %tt.i15.i, align 8
  %tt2.i.i = getelementptr inbounds %struct.lua_TValue, ptr %127, i64 1, i32 1
  store i32 %131, ptr %tt2.i.i, align 8
  %132 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i.i = getelementptr inbounds %struct.lua_TValue, ptr %132, i64 1
  store ptr %incdec.ptr.i.i, ptr %top.i.i, align 8
  %add.ptr8.i.i.i = getelementptr inbounds %struct.lua_TValue, ptr %132, i64 -1
  %133 = load i64, ptr %add.ptr8.i.i.i, align 8
  store i64 %133, ptr %incdec.ptr.i.i, align 8
  %tt.i18.i = getelementptr %struct.lua_TValue, ptr %132, i64 -1, i32 1
  %134 = load i32, ptr %tt.i18.i, align 8
  %tt2.i19.i = getelementptr inbounds %struct.lua_TValue, ptr %132, i64 1, i32 1
  store i32 %134, ptr %tt2.i19.i, align 8
  %135 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i20.i = getelementptr inbounds %struct.lua_TValue, ptr %135, i64 1
  store ptr %incdec.ptr.i20.i, ptr %top.i.i, align 8
  %add.ptr8.i.i61.i = getelementptr inbounds %struct.lua_TValue, ptr %135, i64 -3
  %136 = load i64, ptr %add.ptr8.i.i61.i, align 8
  store i64 %136, ptr %incdec.ptr.i20.i, align 8
  %tt.i35.i = getelementptr %struct.lua_TValue, ptr %135, i64 -3, i32 1
  %137 = load i32, ptr %tt.i35.i, align 8
  %tt2.i36.i = getelementptr inbounds %struct.lua_TValue, ptr %135, i64 1, i32 1
  store i32 %137, ptr %tt2.i36.i, align 8
  %138 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i37.i = getelementptr inbounds %struct.lua_TValue, ptr %138, i64 1
  store ptr %incdec.ptr.i37.i, ptr %top.i.i, align 8
  %add.ptr.i.i416 = getelementptr inbounds %struct.lua_TValue, ptr %138, i64 -2
  tail call fastcc void @luaD_call(ptr noundef nonnull %L, ptr noundef nonnull %add.ptr.i.i416, i32 noundef 1)
  %139 = load ptr, ptr %top.i.i, align 8
  %tt.i76.i = getelementptr %struct.lua_TValue, ptr %139, i64 -1, i32 1
  %140 = load i32, ptr %tt.i76.i, align 8
  switch i32 %140, label %lor.end.fold.split.i.i [
    i32 0, label %lua_toboolean.exit.i
    i32 1, label %land.rhs.i.i
  ]

land.rhs.i.i:                                     ; preds = %if.then.i
  %add.ptr8.i.i73.i = getelementptr inbounds %struct.lua_TValue, ptr %139, i64 -1
  %141 = load i32, ptr %add.ptr8.i.i73.i, align 8
  %cmp3.i.i = icmp ne i32 %141, 0
  %142 = zext i1 %cmp3.i.i to i32
  br label %lua_toboolean.exit.i

lor.end.fold.split.i.i:                           ; preds = %if.then.i
  br label %lua_toboolean.exit.i

lua_toboolean.exit.i:                             ; preds = %lor.end.fold.split.i.i, %land.rhs.i.i, %if.then.i
  %lnot.i.i = phi i32 [ %140, %if.then.i ], [ %142, %land.rhs.i.i ], [ 1, %lor.end.fold.split.i.i ]
  %add.ptr9.i.i = getelementptr %struct.lua_TValue, ptr %139, i64 -1
  store ptr %add.ptr9.i.i, ptr %top.i.i, align 8
  br label %sort_comp.exit

if.else.i:                                        ; preds = %lua_type.exit.i
  %add.ptr8.i35.i.i = getelementptr inbounds %struct.lua_TValue, ptr %127, i64 -1
  %cmp.i86.i = icmp eq ptr %127, @luaO_nilobject_
  %cmp2.i.i417 = icmp eq ptr %add.ptr8.i35.i.i, @luaO_nilobject_
  %or.cond.i.i = select i1 %cmp.i86.i, i1 true, i1 %cmp2.i.i417
  br i1 %or.cond.i.i, label %while.cond29.preheader, label %cond.false.i87.i

cond.false.i87.i:                                 ; preds = %if.else.i
  %call3.i.i = tail call fastcc i32 @luaV_lessthan(ptr noundef nonnull %L, ptr noundef nonnull %127, ptr noundef nonnull %add.ptr8.i35.i.i), !range !23
  br label %sort_comp.exit

sort_comp.exit:                                   ; preds = %lua_toboolean.exit.i, %cond.false.i87.i
  %retval.0.i = phi i32 [ %lnot.i.i, %lua_toboolean.exit.i ], [ %call3.i.i, %cond.false.i87.i ]
  %tobool23.not = icmp eq i32 %retval.0.i, 0
  br i1 %tobool23.not, label %while.cond29.preheader, label %while.body24

while.cond29.preheader:                           ; preds = %if.else.i, %sort_comp.exit
  %143 = trunc i64 %indvars.iv.next to i32
  %144 = sext i32 %j.0 to i64
  %.pre730 = load ptr, ptr %top.i.i, align 8
  br label %while.cond29

while.body24:                                     ; preds = %sort_comp.exit
  %cmp25.not = icmp slt i64 %indvars.iv, %108
  br i1 %cmp25.not, label %if.end28, label %if.then26

if.then26:                                        ; preds = %while.body24
  tail call void (ptr, ptr, ...) @luaL_error(ptr noundef nonnull %L, ptr noundef nonnull @.str.194)
  unreachable

if.end28:                                         ; preds = %while.body24
  %145 = load ptr, ptr %top.i.i, align 8
  %add.ptr9.i420 = getelementptr %struct.lua_TValue, ptr %145, i64 -1
  store ptr %add.ptr9.i420, ptr %top.i.i, align 8
  br label %while.cond21, !llvm.loop !133

while.cond29:                                     ; preds = %while.cond29.preheader, %if.end36
  %146 = phi ptr [ %.pre730, %while.cond29.preheader ], [ %add.ptr9.i512, %if.end36 ]
  %indvars.iv727 = phi i64 [ %144, %while.cond29.preheader ], [ %indvars.iv.next728, %if.end36 ]
  %indvars.iv.next728 = add nsw i64 %indvars.iv727, -1
  %147 = load ptr, ptr %base.i.i, align 8
  %cmp1.not.i.i424 = icmp ult ptr %147, %146
  %add.ptr.luaO_nilobject_.i.i425 = select i1 %cmp1.not.i.i424, ptr %147, ptr @luaO_nilobject_
  %148 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i425, align 8
  %149 = trunc i64 %indvars.iv727 to i32
  %sub.i.i426 = add i32 %149, -2
  %sizearray.i.i427 = getelementptr inbounds %struct.Table, ptr %148, i64 0, i32 10
  %150 = load i32, ptr %sizearray.i.i427, align 8
  %cmp.i5.i428 = icmp ult i32 %sub.i.i426, %150
  br i1 %cmp.i5.i428, label %if.then.i9.i463, label %if.else.i.i429

if.then.i9.i463:                                  ; preds = %while.cond29
  %array.i.i464 = getelementptr inbounds %struct.Table, ptr %148, i64 0, i32 6
  %151 = load ptr, ptr %array.i.i464, align 8
  %idxprom.i10.i465 = sext i32 %sub.i.i426 to i64
  %arrayidx.i11.i466 = getelementptr inbounds %struct.lua_TValue, ptr %151, i64 %idxprom.i10.i465
  %.pre732 = trunc i64 %indvars.iv.next728 to i32
  br label %lua_rawgeti.exit467

if.else.i.i429:                                   ; preds = %while.cond29
  %152 = trunc i64 %indvars.iv.next728 to i32
  %conv.i6.i430 = sitofp i32 %152 to double
  %cmp.i.i.i431 = icmp eq i32 %152, 0
  br i1 %cmp.i.i.i431, label %if.then.i.i.i461, label %if.end.i.i.i432

if.then.i.i.i461:                                 ; preds = %if.else.i.i429
  %node.i.i.i462 = getelementptr inbounds %struct.Table, ptr %148, i64 0, i32 7
  %153 = load ptr, ptr %node.i.i.i462, align 8
  br label %do.body.i.i446.preheader

if.end.i.i.i432:                                  ; preds = %if.else.i.i429
  %154 = bitcast double %conv.i6.i430 to i64
  %a.sroa.0.4.extract.shift.i.i.i433 = lshr i64 %154, 32
  %add.i.i.i434 = add i64 %a.sroa.0.4.extract.shift.i.i.i433, %154
  %node4.i.i.i435 = getelementptr inbounds %struct.Table, ptr %148, i64 0, i32 7
  %155 = load ptr, ptr %node4.i.i.i435, align 8
  %conv.i.i.i436 = and i64 %add.i.i.i434, 4294967295
  %lsizenode.i.i.i437 = getelementptr inbounds %struct.Table, ptr %148, i64 0, i32 4
  %156 = load i8, ptr %lsizenode.i.i.i437, align 1
  %sh_prom.i.i.i438 = zext nneg i8 %156 to i64
  %notmask.i.i.i439 = shl nsw i64 -1, %sh_prom.i.i.i438
  %sub.i.i.i440 = xor i64 %notmask.i.i.i439, -1
  %or.i.i.i441 = or i64 %sub.i.i.i440, 1
  %rem.i.i.i442 = urem i64 %conv.i.i.i436, %or.i.i.i441
  %arrayidx7.i.i.i443 = getelementptr inbounds %struct.Node, ptr %155, i64 %rem.i.i.i442
  br label %do.body.i.i446.preheader

do.body.i.i446.preheader:                         ; preds = %if.end.i.i.i432, %if.then.i.i.i461
  %n.0.i.i447.ph = phi ptr [ %arrayidx7.i.i.i443, %if.end.i.i.i432 ], [ %153, %if.then.i.i.i461 ]
  br label %do.body.i.i446

do.body.i.i446:                                   ; preds = %do.body.i.i446.preheader, %if.else8.i.i450
  %n.0.i.i447 = phi ptr [ %159, %if.else8.i.i450 ], [ %n.0.i.i447.ph, %do.body.i.i446.preheader ]
  %tt.i7.i448 = getelementptr inbounds %struct.Node, ptr %n.0.i.i447, i64 0, i32 1, i32 0, i32 1
  %157 = load i32, ptr %tt.i7.i448, align 8
  %cmp2.i.i449 = icmp eq i32 %157, 3
  br i1 %cmp2.i.i449, label %land.lhs.true.i.i458, label %if.else8.i.i450

land.lhs.true.i.i458:                             ; preds = %do.body.i.i446
  %i_key.i.i459 = getelementptr inbounds %struct.Node, ptr %n.0.i.i447, i64 0, i32 1
  %158 = load double, ptr %i_key.i.i459, align 8
  %cmp5.i.i460 = fcmp oeq double %158, %conv.i6.i430
  br i1 %cmp5.i.i460, label %lua_rawgeti.exit467, label %if.else8.i.i450

if.else8.i.i450:                                  ; preds = %land.lhs.true.i.i458, %do.body.i.i446
  %next.i.i451 = getelementptr inbounds %struct.Node, ptr %n.0.i.i447, i64 0, i32 1, i32 0, i32 2
  %159 = load ptr, ptr %next.i.i451, align 8
  %tobool.not.i.i452 = icmp eq ptr %159, null
  br i1 %tobool.not.i.i452, label %lua_rawgeti.exit467, label %do.body.i.i446, !llvm.loop !7

lua_rawgeti.exit467:                              ; preds = %land.lhs.true.i.i458, %if.else8.i.i450, %if.then.i9.i463
  %.pre-phi = phi i32 [ %.pre732, %if.then.i9.i463 ], [ %152, %if.else8.i.i450 ], [ %152, %land.lhs.true.i.i458 ]
  %retval.0.i8.i453 = phi ptr [ %arrayidx.i11.i466, %if.then.i9.i463 ], [ %n.0.i.i447, %land.lhs.true.i.i458 ], [ @luaO_nilobject_, %if.else8.i.i450 ]
  %160 = load i64, ptr %retval.0.i8.i453, align 8
  store i64 %160, ptr %146, align 8
  %tt.i455 = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i8.i453, i64 0, i32 1
  %161 = load i32, ptr %tt.i455, align 8
  %tt4.i456 = getelementptr inbounds %struct.lua_TValue, ptr %146, i64 0, i32 1
  store i32 %161, ptr %tt4.i456, align 8
  %162 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i457 = getelementptr inbounds %struct.lua_TValue, ptr %162, i64 1
  store ptr %incdec.ptr.i457, ptr %top.i.i, align 8
  %163 = load ptr, ptr %base.i.i, align 8
  %add.ptr.i.i.i469 = getelementptr %struct.lua_TValue, ptr %163, i64 1
  %cmp1.not.i.i.i471 = icmp uge ptr %163, %162
  %cmp.i.i472 = icmp eq ptr %add.ptr.i.i.i469, @luaO_nilobject_
  %or.cond.i473 = or i1 %cmp1.not.i.i.i471, %cmp.i.i472
  br i1 %or.cond.i473, label %if.then.i477, label %lua_type.exit.i474

lua_type.exit.i474:                               ; preds = %lua_rawgeti.exit467
  %tt.i.i475 = getelementptr %struct.lua_TValue, ptr %163, i64 1, i32 1
  %164 = load i32, ptr %tt.i.i475, align 8
  %cmp.i476 = icmp eq i32 %164, 0
  br i1 %cmp.i476, label %if.else.i501, label %if.then.i477

if.then.i477:                                     ; preds = %lua_type.exit.i474, %lua_rawgeti.exit467
  %add.ptr.luaO_nilobject_.i.i.i478 = select i1 %cmp1.not.i.i.i471, ptr @luaO_nilobject_, ptr %add.ptr.i.i.i469
  %165 = load i64, ptr %add.ptr.luaO_nilobject_.i.i.i478, align 8
  store i64 %165, ptr %incdec.ptr.i457, align 8
  %tt.i15.i479 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i.i478, i64 0, i32 1
  %166 = load i32, ptr %tt.i15.i479, align 8
  %tt2.i.i480 = getelementptr inbounds %struct.lua_TValue, ptr %162, i64 1, i32 1
  store i32 %166, ptr %tt2.i.i480, align 8
  %167 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i.i481 = getelementptr inbounds %struct.lua_TValue, ptr %167, i64 1
  store ptr %incdec.ptr.i.i481, ptr %top.i.i, align 8
  %add.ptr8.i.i.i482 = getelementptr inbounds %struct.lua_TValue, ptr %167, i64 -3
  %168 = load i64, ptr %add.ptr8.i.i.i482, align 8
  store i64 %168, ptr %incdec.ptr.i.i481, align 8
  %tt.i18.i484 = getelementptr %struct.lua_TValue, ptr %167, i64 -3, i32 1
  %169 = load i32, ptr %tt.i18.i484, align 8
  %tt2.i19.i485 = getelementptr inbounds %struct.lua_TValue, ptr %167, i64 1, i32 1
  store i32 %169, ptr %tt2.i19.i485, align 8
  %170 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i20.i486 = getelementptr inbounds %struct.lua_TValue, ptr %170, i64 1
  store ptr %incdec.ptr.i20.i486, ptr %top.i.i, align 8
  %add.ptr8.i.i61.i487 = getelementptr inbounds %struct.lua_TValue, ptr %170, i64 -2
  %171 = load i64, ptr %add.ptr8.i.i61.i487, align 8
  store i64 %171, ptr %incdec.ptr.i20.i486, align 8
  %tt.i35.i488 = getelementptr %struct.lua_TValue, ptr %170, i64 -2, i32 1
  %172 = load i32, ptr %tt.i35.i488, align 8
  %tt2.i36.i489 = getelementptr inbounds %struct.lua_TValue, ptr %170, i64 1, i32 1
  store i32 %172, ptr %tt2.i36.i489, align 8
  %173 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i37.i490 = getelementptr inbounds %struct.lua_TValue, ptr %173, i64 1
  store ptr %incdec.ptr.i37.i490, ptr %top.i.i, align 8
  %add.ptr.i.i491 = getelementptr inbounds %struct.lua_TValue, ptr %173, i64 -2
  tail call fastcc void @luaD_call(ptr noundef nonnull %L, ptr noundef nonnull %add.ptr.i.i491, i32 noundef 1)
  %174 = load ptr, ptr %top.i.i, align 8
  %tt.i76.i492 = getelementptr %struct.lua_TValue, ptr %174, i64 -1, i32 1
  %175 = load i32, ptr %tt.i76.i492, align 8
  switch i32 %175, label %lor.end.fold.split.i.i500 [
    i32 0, label %lua_toboolean.exit.i496
    i32 1, label %land.rhs.i.i493
  ]

land.rhs.i.i493:                                  ; preds = %if.then.i477
  %add.ptr8.i.i73.i494 = getelementptr inbounds %struct.lua_TValue, ptr %174, i64 -1
  %176 = load i32, ptr %add.ptr8.i.i73.i494, align 8
  %cmp3.i.i495 = icmp ne i32 %176, 0
  %177 = zext i1 %cmp3.i.i495 to i32
  br label %lua_toboolean.exit.i496

lor.end.fold.split.i.i500:                        ; preds = %if.then.i477
  br label %lua_toboolean.exit.i496

lua_toboolean.exit.i496:                          ; preds = %lor.end.fold.split.i.i500, %land.rhs.i.i493, %if.then.i477
  %lnot.i.i497 = phi i32 [ %175, %if.then.i477 ], [ %177, %land.rhs.i.i493 ], [ 1, %lor.end.fold.split.i.i500 ]
  %add.ptr9.i.i498 = getelementptr %struct.lua_TValue, ptr %174, i64 -1
  store ptr %add.ptr9.i.i498, ptr %top.i.i, align 8
  br label %sort_comp.exit509

if.else.i501:                                     ; preds = %lua_type.exit.i474
  %add.ptr8.i.i112.i502 = getelementptr inbounds %struct.lua_TValue, ptr %162, i64 -2
  %cmp.i86.i504 = icmp eq ptr %add.ptr8.i.i112.i502, @luaO_nilobject_
  %cmp2.i.i505 = icmp eq ptr %162, @luaO_nilobject_
  %or.cond.i.i506 = or i1 %cmp2.i.i505, %cmp.i86.i504
  br i1 %or.cond.i.i506, label %while.end37, label %cond.false.i87.i507

cond.false.i87.i507:                              ; preds = %if.else.i501
  %call3.i.i508 = tail call fastcc i32 @luaV_lessthan(ptr noundef nonnull %L, ptr noundef nonnull %add.ptr8.i.i112.i502, ptr noundef nonnull %162), !range !23
  br label %sort_comp.exit509

sort_comp.exit509:                                ; preds = %lua_toboolean.exit.i496, %cond.false.i87.i507
  %retval.0.i499 = phi i32 [ %lnot.i.i497, %lua_toboolean.exit.i496 ], [ %call3.i.i508, %cond.false.i87.i507 ]
  %tobool31.not = icmp eq i32 %retval.0.i499, 0
  br i1 %tobool31.not, label %while.end37, label %while.body32

while.body32:                                     ; preds = %sort_comp.exit509
  %cmp33.not = icmp sgt i64 %indvars.iv727, %109
  br i1 %cmp33.not, label %if.end36, label %if.then34

if.then34:                                        ; preds = %while.body32
  tail call void (ptr, ptr, ...) @luaL_error(ptr noundef nonnull %L, ptr noundef nonnull @.str.194)
  unreachable

if.end36:                                         ; preds = %while.body32
  %178 = load ptr, ptr %top.i.i, align 8
  %add.ptr9.i512 = getelementptr %struct.lua_TValue, ptr %178, i64 -1
  store ptr %add.ptr9.i512, ptr %top.i.i, align 8
  br label %while.cond29, !llvm.loop !134

while.end37:                                      ; preds = %if.else.i501, %sort_comp.exit509
  %cmp38.not = icmp sgt i32 %149, %143
  br i1 %cmp38.not, label %if.end40, label %if.then39

if.then39:                                        ; preds = %while.end37
  %179 = load ptr, ptr %top.i.i, align 8
  %add.ptr9.i515 = getelementptr %struct.lua_TValue, ptr %179, i64 -3
  store ptr %add.ptr9.i515, ptr %top.i.i, align 8
  %180 = load ptr, ptr %base.i.i, align 8
  %cmp1.not.i.i519 = icmp ult ptr %180, %add.ptr9.i515
  %add.ptr.luaO_nilobject_.i.i520 = select i1 %cmp1.not.i.i519, ptr %180, ptr @luaO_nilobject_
  %181 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i520, align 8
  %sizearray.i.i522 = getelementptr inbounds %struct.Table, ptr %181, i64 0, i32 10
  %182 = load i32, ptr %sizearray.i.i522, align 8
  %cmp.i5.i523 = icmp ult i32 %sub.i.i327, %182
  br i1 %cmp.i5.i523, label %if.then.i9.i558, label %if.else.i.i524

if.then.i9.i558:                                  ; preds = %if.then39
  %array.i.i559 = getelementptr inbounds %struct.Table, ptr %181, i64 0, i32 6
  %183 = load ptr, ptr %array.i.i559, align 8
  %idxprom.i10.i560 = sext i32 %sub.i.i327 to i64
  %arrayidx.i11.i561 = getelementptr inbounds %struct.lua_TValue, ptr %183, i64 %idxprom.i10.i560
  br label %lua_rawgeti.exit562

if.else.i.i524:                                   ; preds = %if.then39
  %conv.i6.i525 = sitofp i32 %sub.i.i84 to double
  %cmp.i.i.i526 = icmp eq i32 %sub.i.i84, 0
  br i1 %cmp.i.i.i526, label %if.then.i.i.i556, label %if.end.i.i.i527

if.then.i.i.i556:                                 ; preds = %if.else.i.i524
  %node.i.i.i557 = getelementptr inbounds %struct.Table, ptr %181, i64 0, i32 7
  %184 = load ptr, ptr %node.i.i.i557, align 8
  br label %do.body.i.i541.preheader

if.end.i.i.i527:                                  ; preds = %if.else.i.i524
  %185 = bitcast double %conv.i6.i525 to i64
  %a.sroa.0.4.extract.shift.i.i.i528 = lshr i64 %185, 32
  %add.i.i.i529 = add i64 %a.sroa.0.4.extract.shift.i.i.i528, %185
  %node4.i.i.i530 = getelementptr inbounds %struct.Table, ptr %181, i64 0, i32 7
  %186 = load ptr, ptr %node4.i.i.i530, align 8
  %conv.i.i.i531 = and i64 %add.i.i.i529, 4294967295
  %lsizenode.i.i.i532 = getelementptr inbounds %struct.Table, ptr %181, i64 0, i32 4
  %187 = load i8, ptr %lsizenode.i.i.i532, align 1
  %sh_prom.i.i.i533 = zext nneg i8 %187 to i64
  %notmask.i.i.i534 = shl nsw i64 -1, %sh_prom.i.i.i533
  %sub.i.i.i535 = xor i64 %notmask.i.i.i534, -1
  %or.i.i.i536 = or i64 %sub.i.i.i535, 1
  %rem.i.i.i537 = urem i64 %conv.i.i.i531, %or.i.i.i536
  %arrayidx7.i.i.i538 = getelementptr inbounds %struct.Node, ptr %186, i64 %rem.i.i.i537
  br label %do.body.i.i541.preheader

do.body.i.i541.preheader:                         ; preds = %if.end.i.i.i527, %if.then.i.i.i556
  %n.0.i.i542.ph = phi ptr [ %arrayidx7.i.i.i538, %if.end.i.i.i527 ], [ %184, %if.then.i.i.i556 ]
  br label %do.body.i.i541

do.body.i.i541:                                   ; preds = %do.body.i.i541.preheader, %if.else8.i.i545
  %n.0.i.i542 = phi ptr [ %190, %if.else8.i.i545 ], [ %n.0.i.i542.ph, %do.body.i.i541.preheader ]
  %tt.i7.i543 = getelementptr inbounds %struct.Node, ptr %n.0.i.i542, i64 0, i32 1, i32 0, i32 1
  %188 = load i32, ptr %tt.i7.i543, align 8
  %cmp2.i.i544 = icmp eq i32 %188, 3
  br i1 %cmp2.i.i544, label %land.lhs.true.i.i553, label %if.else8.i.i545

land.lhs.true.i.i553:                             ; preds = %do.body.i.i541
  %i_key.i.i554 = getelementptr inbounds %struct.Node, ptr %n.0.i.i542, i64 0, i32 1
  %189 = load double, ptr %i_key.i.i554, align 8
  %cmp5.i.i555 = fcmp oeq double %189, %conv.i6.i525
  br i1 %cmp5.i.i555, label %lua_rawgeti.exit562, label %if.else8.i.i545

if.else8.i.i545:                                  ; preds = %land.lhs.true.i.i553, %do.body.i.i541
  %next.i.i546 = getelementptr inbounds %struct.Node, ptr %n.0.i.i542, i64 0, i32 1, i32 0, i32 2
  %190 = load ptr, ptr %next.i.i546, align 8
  %tobool.not.i.i547 = icmp eq ptr %190, null
  br i1 %tobool.not.i.i547, label %lua_rawgeti.exit562, label %do.body.i.i541, !llvm.loop !7

lua_rawgeti.exit562:                              ; preds = %land.lhs.true.i.i553, %if.else8.i.i545, %if.then.i9.i558
  %retval.0.i8.i548 = phi ptr [ %arrayidx.i11.i561, %if.then.i9.i558 ], [ @luaO_nilobject_, %if.else8.i.i545 ], [ %n.0.i.i542, %land.lhs.true.i.i553 ]
  %191 = load i64, ptr %retval.0.i8.i548, align 8
  store i64 %191, ptr %add.ptr9.i515, align 8
  %tt.i550 = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i8.i548, i64 0, i32 1
  %192 = load i32, ptr %tt.i550, align 8
  %tt4.i551 = getelementptr %struct.lua_TValue, ptr %179, i64 -3, i32 1
  store i32 %192, ptr %tt4.i551, align 8
  %193 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i552 = getelementptr inbounds %struct.lua_TValue, ptr %193, i64 1
  store ptr %incdec.ptr.i552, ptr %top.i.i, align 8
  %194 = load ptr, ptr %base.i.i, align 8
  %cmp1.not.i.i566 = icmp ult ptr %194, %incdec.ptr.i552
  %add.ptr.luaO_nilobject_.i.i567 = select i1 %cmp1.not.i.i566, ptr %194, ptr @luaO_nilobject_
  %195 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i567, align 8
  %sizearray.i.i568 = getelementptr inbounds %struct.Table, ptr %195, i64 0, i32 10
  %196 = load i32, ptr %sizearray.i.i568, align 8
  %cmp.i5.i569 = icmp ugt i32 %196, %115
  br i1 %cmp.i5.i569, label %if.then.i9.i604, label %if.else.i.i570

if.then.i9.i604:                                  ; preds = %lua_rawgeti.exit562
  %array.i.i605 = getelementptr inbounds %struct.Table, ptr %195, i64 0, i32 6
  %197 = load ptr, ptr %array.i.i605, align 8
  %sext = shl i64 %indvars.iv, 32
  %idxprom.i10.i606 = ashr exact i64 %sext, 32
  %arrayidx.i11.i607 = getelementptr inbounds %struct.lua_TValue, ptr %197, i64 %idxprom.i10.i606
  br label %lua_rawgeti.exit608

if.else.i.i570:                                   ; preds = %lua_rawgeti.exit562
  %conv.i6.i571 = sitofp i32 %143 to double
  %cmp.i.i.i572 = icmp eq i32 %143, 0
  br i1 %cmp.i.i.i572, label %if.then.i.i.i602, label %if.end.i.i.i573

if.then.i.i.i602:                                 ; preds = %if.else.i.i570
  %node.i.i.i603 = getelementptr inbounds %struct.Table, ptr %195, i64 0, i32 7
  %198 = load ptr, ptr %node.i.i.i603, align 8
  br label %do.body.i.i587.preheader

if.end.i.i.i573:                                  ; preds = %if.else.i.i570
  %199 = bitcast double %conv.i6.i571 to i64
  %a.sroa.0.4.extract.shift.i.i.i574 = lshr i64 %199, 32
  %add.i.i.i575 = add i64 %a.sroa.0.4.extract.shift.i.i.i574, %199
  %node4.i.i.i576 = getelementptr inbounds %struct.Table, ptr %195, i64 0, i32 7
  %200 = load ptr, ptr %node4.i.i.i576, align 8
  %conv.i.i.i577 = and i64 %add.i.i.i575, 4294967295
  %lsizenode.i.i.i578 = getelementptr inbounds %struct.Table, ptr %195, i64 0, i32 4
  %201 = load i8, ptr %lsizenode.i.i.i578, align 1
  %sh_prom.i.i.i579 = zext nneg i8 %201 to i64
  %notmask.i.i.i580 = shl nsw i64 -1, %sh_prom.i.i.i579
  %sub.i.i.i581 = xor i64 %notmask.i.i.i580, -1
  %or.i.i.i582 = or i64 %sub.i.i.i581, 1
  %rem.i.i.i583 = urem i64 %conv.i.i.i577, %or.i.i.i582
  %arrayidx7.i.i.i584 = getelementptr inbounds %struct.Node, ptr %200, i64 %rem.i.i.i583
  br label %do.body.i.i587.preheader

do.body.i.i587.preheader:                         ; preds = %if.end.i.i.i573, %if.then.i.i.i602
  %n.0.i.i588.ph = phi ptr [ %arrayidx7.i.i.i584, %if.end.i.i.i573 ], [ %198, %if.then.i.i.i602 ]
  br label %do.body.i.i587

do.body.i.i587:                                   ; preds = %do.body.i.i587.preheader, %if.else8.i.i591
  %n.0.i.i588 = phi ptr [ %204, %if.else8.i.i591 ], [ %n.0.i.i588.ph, %do.body.i.i587.preheader ]
  %tt.i7.i589 = getelementptr inbounds %struct.Node, ptr %n.0.i.i588, i64 0, i32 1, i32 0, i32 1
  %202 = load i32, ptr %tt.i7.i589, align 8
  %cmp2.i.i590 = icmp eq i32 %202, 3
  br i1 %cmp2.i.i590, label %land.lhs.true.i.i599, label %if.else8.i.i591

land.lhs.true.i.i599:                             ; preds = %do.body.i.i587
  %i_key.i.i600 = getelementptr inbounds %struct.Node, ptr %n.0.i.i588, i64 0, i32 1
  %203 = load double, ptr %i_key.i.i600, align 8
  %cmp5.i.i601 = fcmp oeq double %203, %conv.i6.i571
  br i1 %cmp5.i.i601, label %lua_rawgeti.exit608, label %if.else8.i.i591

if.else8.i.i591:                                  ; preds = %land.lhs.true.i.i599, %do.body.i.i587
  %next.i.i592 = getelementptr inbounds %struct.Node, ptr %n.0.i.i588, i64 0, i32 1, i32 0, i32 2
  %204 = load ptr, ptr %next.i.i592, align 8
  %tobool.not.i.i593 = icmp eq ptr %204, null
  br i1 %tobool.not.i.i593, label %lua_rawgeti.exit608, label %do.body.i.i587, !llvm.loop !7

lua_rawgeti.exit608:                              ; preds = %land.lhs.true.i.i599, %if.else8.i.i591, %if.then.i9.i604
  %retval.0.i8.i594 = phi ptr [ %arrayidx.i11.i607, %if.then.i9.i604 ], [ @luaO_nilobject_, %if.else8.i.i591 ], [ %n.0.i.i588, %land.lhs.true.i.i599 ]
  %205 = load i64, ptr %retval.0.i8.i594, align 8
  store i64 %205, ptr %incdec.ptr.i552, align 8
  %tt.i596 = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i8.i594, i64 0, i32 1
  %206 = load i32, ptr %tt.i596, align 8
  %tt4.i597 = getelementptr inbounds %struct.lua_TValue, ptr %193, i64 1, i32 1
  store i32 %206, ptr %tt4.i597, align 8
  %207 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i598 = getelementptr inbounds %struct.lua_TValue, ptr %207, i64 1
  store ptr %incdec.ptr.i598, ptr %top.i.i, align 8
  tail call fastcc void @lua_rawseti(ptr noundef %L, i32 noundef 1, i32 noundef %sub.i.i84)
  tail call fastcc void @lua_rawseti(ptr noundef %L, i32 noundef 1, i32 noundef %143)
  %sub43 = sub nsw i32 %143, %l.addr.0713
  %sub44 = sub nsw i32 %u.addr.0714, %143
  %cmp45 = icmp slt i32 %sub43, %sub44
  %add48 = add nsw i32 %115, 2
  %add48.l.addr.0713 = select i1 %cmp45, i32 %add48, i32 %l.addr.0713
  %u.addr.0714..lcssa.lcssa737 = select i1 %cmp45, i32 %u.addr.0714, i32 %115
  %.lcssa.lcssa737.u.addr.0714 = select i1 %cmp45, i32 %115, i32 %u.addr.0714
  %l.addr.0713.add48 = select i1 %cmp45, i32 %l.addr.0713, i32 %add48
  tail call fastcc void @auxsort(ptr noundef nonnull %L, i32 noundef %l.addr.0713.add48, i32 noundef %.lcssa.lcssa737.u.addr.0714)
  %cmp = icmp slt i32 %add48.l.addr.0713, %u.addr.0714..lcssa.lcssa737
  br i1 %cmp, label %while.body, label %while.end53, !llvm.loop !135

if.end40:                                         ; preds = %while.end37
  %208 = load ptr, ptr %base.i.i, align 8
  %209 = load ptr, ptr %top.i.i, align 8
  %cmp1.not.i.i630 = icmp ult ptr %208, %209
  %add.ptr.luaO_nilobject_.i.i631 = select i1 %cmp1.not.i.i630, ptr %208, ptr @luaO_nilobject_
  %add.ptr.i633 = getelementptr inbounds %struct.lua_TValue, ptr %209, i64 -1
  %210 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i631, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %k.i.i626)
  %sizearray.i.i.i634 = getelementptr inbounds %struct.Table, ptr %210, i64 0, i32 10
  %211 = load i32, ptr %sizearray.i.i.i634, align 8
  %cmp.i.i.i635 = icmp ugt i32 %211, %115
  br i1 %cmp.i.i.i635, label %if.then.i.i.i693, label %if.else.i.i.i636

if.then.i.i.i693:                                 ; preds = %if.end40
  %array.i.i.i694 = getelementptr inbounds %struct.Table, ptr %210, i64 0, i32 6
  %212 = load ptr, ptr %array.i.i.i694, align 8
  %sext733 = shl i64 %indvars.iv, 32
  %idxprom.i.i.i695 = ashr exact i64 %sext733, 32
  %arrayidx.i.i.i696 = getelementptr inbounds %struct.lua_TValue, ptr %212, i64 %idxprom.i.i.i695
  br label %luaH_getnum.exit.i.i686

if.else.i.i.i636:                                 ; preds = %if.end40
  %conv.i.i.i637 = sitofp i32 %143 to double
  %cmp.i.i.i.i638 = icmp eq i32 %143, 0
  br i1 %cmp.i.i.i.i638, label %if.then.i.i.i.i691, label %if.end.i.i.i.i639

if.then.i.i.i.i691:                               ; preds = %if.else.i.i.i636
  %node.i.i.i.i692 = getelementptr inbounds %struct.Table, ptr %210, i64 0, i32 7
  %213 = load ptr, ptr %node.i.i.i.i692, align 8
  br label %do.body.i.i.i653.preheader

if.end.i.i.i.i639:                                ; preds = %if.else.i.i.i636
  %214 = bitcast double %conv.i.i.i637 to i64
  %a.sroa.0.4.extract.shift.i.i.i.i640 = lshr i64 %214, 32
  %add.i.i.i.i641 = add i64 %a.sroa.0.4.extract.shift.i.i.i.i640, %214
  %node4.i.i.i.i642 = getelementptr inbounds %struct.Table, ptr %210, i64 0, i32 7
  %215 = load ptr, ptr %node4.i.i.i.i642, align 8
  %conv.i.i.i.i643 = and i64 %add.i.i.i.i641, 4294967295
  %lsizenode.i.i.i.i644 = getelementptr inbounds %struct.Table, ptr %210, i64 0, i32 4
  %216 = load i8, ptr %lsizenode.i.i.i.i644, align 1
  %sh_prom.i.i.i.i645 = zext nneg i8 %216 to i64
  %notmask.i.i.i.i646 = shl nsw i64 -1, %sh_prom.i.i.i.i645
  %sub.i.i.i.i647 = xor i64 %notmask.i.i.i.i646, -1
  %or.i.i.i.i648 = or i64 %sub.i.i.i.i647, 1
  %rem.i.i.i.i649 = urem i64 %conv.i.i.i.i643, %or.i.i.i.i648
  %arrayidx7.i.i.i.i650 = getelementptr inbounds %struct.Node, ptr %215, i64 %rem.i.i.i.i649
  br label %do.body.i.i.i653.preheader

do.body.i.i.i653.preheader:                       ; preds = %if.end.i.i.i.i639, %if.then.i.i.i.i691
  %n.0.i.i.i654.ph = phi ptr [ %arrayidx7.i.i.i.i650, %if.end.i.i.i.i639 ], [ %213, %if.then.i.i.i.i691 ]
  br label %do.body.i.i.i653

do.body.i.i.i653:                                 ; preds = %do.body.i.i.i653.preheader, %if.else8.i.i.i657
  %n.0.i.i.i654 = phi ptr [ %219, %if.else8.i.i.i657 ], [ %n.0.i.i.i654.ph, %do.body.i.i.i653.preheader ]
  %tt.i.i.i655 = getelementptr inbounds %struct.Node, ptr %n.0.i.i.i654, i64 0, i32 1, i32 0, i32 1
  %217 = load i32, ptr %tt.i.i.i655, align 8
  %cmp2.i.i.i656 = icmp eq i32 %217, 3
  br i1 %cmp2.i.i.i656, label %land.lhs.true.i.i.i683, label %if.else8.i.i.i657

land.lhs.true.i.i.i683:                           ; preds = %do.body.i.i.i653
  %i_key.i.i.i684 = getelementptr inbounds %struct.Node, ptr %n.0.i.i.i654, i64 0, i32 1
  %218 = load double, ptr %i_key.i.i.i684, align 8
  %cmp5.i.i.i685 = fcmp oeq double %218, %conv.i.i.i637
  br i1 %cmp5.i.i.i685, label %luaH_getnum.exit.i.i686, label %if.else8.i.i.i657

if.else8.i.i.i657:                                ; preds = %land.lhs.true.i.i.i683, %do.body.i.i.i653
  %next.i.i.i658 = getelementptr inbounds %struct.Node, ptr %n.0.i.i.i654, i64 0, i32 1, i32 0, i32 2
  %219 = load ptr, ptr %next.i.i.i658, align 8
  %tobool.not.i.i.i659 = icmp eq ptr %219, null
  br i1 %tobool.not.i.i.i659, label %if.else.i.i660, label %do.body.i.i.i653, !llvm.loop !7

luaH_getnum.exit.i.i686:                          ; preds = %land.lhs.true.i.i.i683, %if.then.i.i.i693
  %retval.0.i.i.i687 = phi ptr [ %arrayidx.i.i.i696, %if.then.i.i.i693 ], [ %n.0.i.i.i654, %land.lhs.true.i.i.i683 ]
  %cmp.not.i.i688 = icmp eq ptr %retval.0.i.i.i687, @luaO_nilobject_
  br i1 %cmp.not.i.i688, label %luaH_getnum.exit.if.else_crit_edge.i.i689, label %luaH_setnum.exit.i664

luaH_getnum.exit.if.else_crit_edge.i.i689:        ; preds = %luaH_getnum.exit.i.i686
  %.pre.i.i690 = sitofp i32 %143 to double
  br label %if.else.i.i660

if.else.i.i660:                                   ; preds = %if.else8.i.i.i657, %luaH_getnum.exit.if.else_crit_edge.i.i689
  %conv.pre-phi.i.i661 = phi double [ %.pre.i.i690, %luaH_getnum.exit.if.else_crit_edge.i.i689 ], [ %conv.i.i.i637, %if.else8.i.i.i657 ]
  store double %conv.pre-phi.i.i661, ptr %k.i.i626, align 8
  store i32 3, ptr %tt.i11.i662, align 8
  %call1.i.i663 = call fastcc ptr @newkey(ptr noundef %L, ptr noundef %210, ptr noundef nonnull %k.i.i626)
  br label %luaH_setnum.exit.i664

luaH_setnum.exit.i664:                            ; preds = %if.else.i.i660, %luaH_getnum.exit.i.i686
  %retval.0.i12.i665 = phi ptr [ %call1.i.i663, %if.else.i.i660 ], [ %retval.0.i.i.i687, %luaH_getnum.exit.i.i686 ]
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %k.i.i626)
  %220 = load i64, ptr %add.ptr.i633, align 8
  store i64 %220, ptr %retval.0.i12.i665, align 8
  %tt.i666 = getelementptr %struct.lua_TValue, ptr %209, i64 -1, i32 1
  %221 = load i32, ptr %tt.i666, align 8
  %tt4.i667 = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i12.i665, i64 0, i32 1
  store i32 %221, ptr %tt4.i667, align 8
  %222 = load ptr, ptr %top.i.i, align 8
  %tt7.i668 = getelementptr %struct.lua_TValue, ptr %222, i64 -1, i32 1
  %223 = load i32, ptr %tt7.i668, align 8
  %cmp.i669 = icmp sgt i32 %223, 3
  br i1 %cmp.i669, label %land.lhs.true.i671, label %lua_rawseti.exit697

land.lhs.true.i671:                               ; preds = %luaH_setnum.exit.i664
  %add.ptr6.i672 = getelementptr inbounds %struct.lua_TValue, ptr %222, i64 -1
  %224 = load ptr, ptr %add.ptr6.i672, align 8
  %marked.i673 = getelementptr inbounds %struct.GCheader, ptr %224, i64 0, i32 2
  %225 = load i8, ptr %marked.i673, align 1
  %226 = and i8 %225, 3
  %tobool.not.i674 = icmp eq i8 %226, 0
  br i1 %tobool.not.i674, label %lua_rawseti.exit697, label %land.lhs.true11.i675

land.lhs.true11.i675:                             ; preds = %land.lhs.true.i671
  %227 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i631, align 8
  %marked13.i676 = getelementptr inbounds %struct.GCheader, ptr %227, i64 0, i32 2
  %228 = load i8, ptr %marked13.i676, align 1
  %229 = and i8 %228, 4
  %tobool16.not.i677 = icmp eq i8 %229, 0
  br i1 %tobool16.not.i677, label %lua_rawseti.exit697, label %if.then.i678

if.then.i678:                                     ; preds = %land.lhs.true11.i675
  %L.val.i679 = load ptr, ptr %0, align 8
  %230 = and i8 %228, -5
  store i8 %230, ptr %marked13.i676, align 1
  %grayagain.i.i680 = getelementptr inbounds %struct.global_State, ptr %L.val.i679, i64 0, i32 9
  %231 = load ptr, ptr %grayagain.i.i680, align 8
  %gclist.i.i681 = getelementptr inbounds %struct.Table, ptr %227, i64 0, i32 9
  store ptr %231, ptr %gclist.i.i681, align 8
  store ptr %227, ptr %grayagain.i.i680, align 8
  %.pre.i682 = load ptr, ptr %top.i.i, align 8
  br label %lua_rawseti.exit697

lua_rawseti.exit697:                              ; preds = %luaH_setnum.exit.i664, %land.lhs.true.i671, %land.lhs.true11.i675, %if.then.i678
  %232 = phi ptr [ %.pre.i682, %if.then.i678 ], [ %222, %land.lhs.true11.i675 ], [ %222, %land.lhs.true.i671 ], [ %222, %luaH_setnum.exit.i664 ]
  %incdec.ptr.i670 = getelementptr inbounds %struct.lua_TValue, ptr %232, i64 -1
  store ptr %incdec.ptr.i670, ptr %top.i.i, align 8
  %233 = load ptr, ptr %base.i.i, align 8
  %cmp1.not.i.i612 = icmp ult ptr %233, %incdec.ptr.i670
  %add.ptr.luaO_nilobject_.i.i613 = select i1 %cmp1.not.i.i612, ptr %233, ptr @luaO_nilobject_
  %add.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %232, i64 -2
  %234 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i613, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %k.i.i)
  %sizearray.i.i.i = getelementptr inbounds %struct.Table, ptr %234, i64 0, i32 10
  %235 = load i32, ptr %sizearray.i.i.i, align 8
  %cmp.i.i.i616 = icmp ult i32 %sub.i.i426, %235
  br i1 %cmp.i.i.i616, label %if.then.i.i.i625, label %if.else.i.i.i

if.then.i.i.i625:                                 ; preds = %lua_rawseti.exit697
  %array.i.i.i = getelementptr inbounds %struct.Table, ptr %234, i64 0, i32 6
  %236 = load ptr, ptr %array.i.i.i, align 8
  %idxprom.i.i.i = sext i32 %sub.i.i426 to i64
  %arrayidx.i.i.i = getelementptr inbounds %struct.lua_TValue, ptr %236, i64 %idxprom.i.i.i
  br label %luaH_getnum.exit.i.i

if.else.i.i.i:                                    ; preds = %lua_rawseti.exit697
  %conv.i.i.i617 = sitofp i32 %.pre-phi to double
  %cmp.i.i.i.i = icmp eq i32 %.pre-phi, 0
  br i1 %cmp.i.i.i.i, label %if.then.i.i.i.i, label %if.end.i.i.i.i

if.then.i.i.i.i:                                  ; preds = %if.else.i.i.i
  %node.i.i.i.i = getelementptr inbounds %struct.Table, ptr %234, i64 0, i32 7
  %237 = load ptr, ptr %node.i.i.i.i, align 8
  br label %do.body.i.i.i.preheader

if.end.i.i.i.i:                                   ; preds = %if.else.i.i.i
  %238 = bitcast double %conv.i.i.i617 to i64
  %a.sroa.0.4.extract.shift.i.i.i.i = lshr i64 %238, 32
  %add.i.i.i.i = add i64 %a.sroa.0.4.extract.shift.i.i.i.i, %238
  %node4.i.i.i.i = getelementptr inbounds %struct.Table, ptr %234, i64 0, i32 7
  %239 = load ptr, ptr %node4.i.i.i.i, align 8
  %conv.i.i.i.i = and i64 %add.i.i.i.i, 4294967295
  %lsizenode.i.i.i.i = getelementptr inbounds %struct.Table, ptr %234, i64 0, i32 4
  %240 = load i8, ptr %lsizenode.i.i.i.i, align 1
  %sh_prom.i.i.i.i = zext nneg i8 %240 to i64
  %notmask.i.i.i.i = shl nsw i64 -1, %sh_prom.i.i.i.i
  %sub.i.i.i.i = xor i64 %notmask.i.i.i.i, -1
  %or.i.i.i.i = or i64 %sub.i.i.i.i, 1
  %rem.i.i.i.i = urem i64 %conv.i.i.i.i, %or.i.i.i.i
  %arrayidx7.i.i.i.i = getelementptr inbounds %struct.Node, ptr %239, i64 %rem.i.i.i.i
  br label %do.body.i.i.i.preheader

do.body.i.i.i.preheader:                          ; preds = %if.end.i.i.i.i, %if.then.i.i.i.i
  %n.0.i.i.i.ph = phi ptr [ %arrayidx7.i.i.i.i, %if.end.i.i.i.i ], [ %237, %if.then.i.i.i.i ]
  br label %do.body.i.i.i

do.body.i.i.i:                                    ; preds = %do.body.i.i.i.preheader, %if.else8.i.i.i
  %n.0.i.i.i = phi ptr [ %243, %if.else8.i.i.i ], [ %n.0.i.i.i.ph, %do.body.i.i.i.preheader ]
  %tt.i.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i.i, i64 0, i32 1, i32 0, i32 1
  %241 = load i32, ptr %tt.i.i.i, align 8
  %cmp2.i.i.i = icmp eq i32 %241, 3
  br i1 %cmp2.i.i.i, label %land.lhs.true.i.i.i, label %if.else8.i.i.i

land.lhs.true.i.i.i:                              ; preds = %do.body.i.i.i
  %i_key.i.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i.i, i64 0, i32 1
  %242 = load double, ptr %i_key.i.i.i, align 8
  %cmp5.i.i.i = fcmp oeq double %242, %conv.i.i.i617
  br i1 %cmp5.i.i.i, label %luaH_getnum.exit.i.i, label %if.else8.i.i.i

if.else8.i.i.i:                                   ; preds = %land.lhs.true.i.i.i, %do.body.i.i.i
  %next.i.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i.i, i64 0, i32 1, i32 0, i32 2
  %243 = load ptr, ptr %next.i.i.i, align 8
  %tobool.not.i.i.i = icmp eq ptr %243, null
  br i1 %tobool.not.i.i.i, label %if.else.i.i618, label %do.body.i.i.i, !llvm.loop !7

luaH_getnum.exit.i.i:                             ; preds = %land.lhs.true.i.i.i, %if.then.i.i.i625
  %retval.0.i.i.i624 = phi ptr [ %arrayidx.i.i.i, %if.then.i.i.i625 ], [ %n.0.i.i.i, %land.lhs.true.i.i.i ]
  %cmp.not.i.i = icmp eq ptr %retval.0.i.i.i624, @luaO_nilobject_
  br i1 %cmp.not.i.i, label %luaH_getnum.exit.if.else_crit_edge.i.i, label %luaH_setnum.exit.i

luaH_getnum.exit.if.else_crit_edge.i.i:           ; preds = %luaH_getnum.exit.i.i
  %.pre.i.i = sitofp i32 %.pre-phi to double
  br label %if.else.i.i618

if.else.i.i618:                                   ; preds = %if.else8.i.i.i, %luaH_getnum.exit.if.else_crit_edge.i.i
  %conv.pre-phi.i.i = phi double [ %.pre.i.i, %luaH_getnum.exit.if.else_crit_edge.i.i ], [ %conv.i.i.i617, %if.else8.i.i.i ]
  store double %conv.pre-phi.i.i, ptr %k.i.i, align 8
  store i32 3, ptr %tt.i11.i, align 8
  %call1.i.i = call fastcc ptr @newkey(ptr noundef %L, ptr noundef %234, ptr noundef nonnull %k.i.i)
  br label %luaH_setnum.exit.i

luaH_setnum.exit.i:                               ; preds = %if.else.i.i618, %luaH_getnum.exit.i.i
  %retval.0.i12.i = phi ptr [ %call1.i.i, %if.else.i.i618 ], [ %retval.0.i.i.i624, %luaH_getnum.exit.i.i ]
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %k.i.i)
  %244 = load i64, ptr %add.ptr.i, align 8
  store i64 %244, ptr %retval.0.i12.i, align 8
  %tt.i619 = getelementptr %struct.lua_TValue, ptr %232, i64 -2, i32 1
  %245 = load i32, ptr %tt.i619, align 8
  %tt4.i620 = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i12.i, i64 0, i32 1
  store i32 %245, ptr %tt4.i620, align 8
  %246 = load ptr, ptr %top.i.i, align 8
  %tt7.i = getelementptr %struct.lua_TValue, ptr %246, i64 -1, i32 1
  %247 = load i32, ptr %tt7.i, align 8
  %cmp.i621 = icmp sgt i32 %247, 3
  br i1 %cmp.i621, label %land.lhs.true.i, label %lua_rawseti.exit

land.lhs.true.i:                                  ; preds = %luaH_setnum.exit.i
  %add.ptr6.i = getelementptr inbounds %struct.lua_TValue, ptr %246, i64 -1
  %248 = load ptr, ptr %add.ptr6.i, align 8
  %marked.i = getelementptr inbounds %struct.GCheader, ptr %248, i64 0, i32 2
  %249 = load i8, ptr %marked.i, align 1
  %250 = and i8 %249, 3
  %tobool.not.i = icmp eq i8 %250, 0
  br i1 %tobool.not.i, label %lua_rawseti.exit, label %land.lhs.true11.i

land.lhs.true11.i:                                ; preds = %land.lhs.true.i
  %251 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i613, align 8
  %marked13.i = getelementptr inbounds %struct.GCheader, ptr %251, i64 0, i32 2
  %252 = load i8, ptr %marked13.i, align 1
  %253 = and i8 %252, 4
  %tobool16.not.i = icmp eq i8 %253, 0
  br i1 %tobool16.not.i, label %lua_rawseti.exit, label %if.then.i623

if.then.i623:                                     ; preds = %land.lhs.true11.i
  %L.val.i = load ptr, ptr %0, align 8
  %254 = and i8 %252, -5
  store i8 %254, ptr %marked13.i, align 1
  %grayagain.i.i = getelementptr inbounds %struct.global_State, ptr %L.val.i, i64 0, i32 9
  %255 = load ptr, ptr %grayagain.i.i, align 8
  %gclist.i.i = getelementptr inbounds %struct.Table, ptr %251, i64 0, i32 9
  store ptr %255, ptr %gclist.i.i, align 8
  store ptr %251, ptr %grayagain.i.i, align 8
  %.pre.i = load ptr, ptr %top.i.i, align 8
  br label %lua_rawseti.exit

lua_rawseti.exit:                                 ; preds = %luaH_setnum.exit.i, %land.lhs.true.i, %land.lhs.true11.i, %if.then.i623
  %256 = phi ptr [ %.pre.i, %if.then.i623 ], [ %246, %land.lhs.true11.i ], [ %246, %land.lhs.true.i ], [ %246, %luaH_setnum.exit.i ]
  %incdec.ptr.i622 = getelementptr inbounds %struct.lua_TValue, ptr %256, i64 -1
  store ptr %incdec.ptr.i622, ptr %top.i.i, align 8
  br label %for.cond

while.end53:                                      ; preds = %lua_rawgeti.exit608, %if.end, %if.end13, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @sort_comp(ptr noundef %L, i32 noundef %a, i32 noundef %b) unnamed_addr #0 {
entry:
  %base.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i, align 8
  %add.ptr.i.i = getelementptr %struct.lua_TValue, ptr %0, i64 1
  %top.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i, align 8
  %cmp1.not.i.i = icmp uge ptr %add.ptr.i.i, %1
  %cmp.i = icmp eq ptr %add.ptr.i.i, @luaO_nilobject_
  %or.cond = or i1 %cmp1.not.i.i, %cmp.i
  br i1 %or.cond, label %if.then, label %lua_type.exit

lua_type.exit:                                    ; preds = %entry
  %tt.i = getelementptr %struct.lua_TValue, ptr %0, i64 1, i32 1
  %2 = load i32, ptr %tt.i, align 8
  %cmp = icmp eq i32 %2, 0
  br i1 %cmp, label %if.else, label %if.then

if.then:                                          ; preds = %entry, %lua_type.exit
  %add.ptr.luaO_nilobject_.i.i = select i1 %cmp1.not.i.i, ptr @luaO_nilobject_, ptr %add.ptr.i.i
  %3 = load i64, ptr %add.ptr.luaO_nilobject_.i.i, align 8
  store i64 %3, ptr %1, align 8
  %tt.i15 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i, i64 0, i32 1
  %4 = load i32, ptr %tt.i15, align 8
  %tt2.i = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 0, i32 1
  store i32 %4, ptr %tt2.i, align 8
  %5 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %5, i64 1
  store ptr %incdec.ptr.i, ptr %top.i.i, align 8
  %sub = add nsw i32 %a, -1
  %cmp.i.i = icmp sgt i32 %a, 1
  br i1 %cmp.i.i, label %if.then.i.i, label %if.else3.i.i

if.then.i.i:                                      ; preds = %if.then
  %6 = load ptr, ptr %base.i.i, align 8
  %7 = zext nneg i32 %sub to i64
  %8 = getelementptr %struct.lua_TValue, ptr %6, i64 %7
  %add.ptr.i.i22 = getelementptr %struct.lua_TValue, ptr %8, i64 -1
  %cmp1.not.i.i24 = icmp ult ptr %add.ptr.i.i22, %incdec.ptr.i
  %add.ptr.luaO_nilobject_.i.i25 = select i1 %cmp1.not.i.i24, ptr %add.ptr.i.i22, ptr @luaO_nilobject_
  br label %lua_pushvalue.exit

if.else3.i.i:                                     ; preds = %if.then
  %cmp4.i.i = icmp sgt i32 %a, -9999
  br i1 %cmp4.i.i, label %if.then5.i.i, label %if.else9.i.i

if.then5.i.i:                                     ; preds = %if.else3.i.i
  %idx.ext7.i.i = sext i32 %sub to i64
  %add.ptr8.i.i = getelementptr inbounds %struct.lua_TValue, ptr %incdec.ptr.i, i64 %idx.ext7.i.i
  br label %lua_pushvalue.exit

if.else9.i.i:                                     ; preds = %if.else3.i.i
  switch i32 %a, label %sw.default.i.i [
    i32 -9999, label %sw.bb.i.i
    i32 -10000, label %sw.bb10.i.i
    i32 -10001, label %sw.bb15.i.i
  ]

sw.bb.i.i:                                        ; preds = %if.else9.i.i
  %l_G.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %9 = load ptr, ptr %l_G.i.i, align 8
  %l_registry.i.i = getelementptr inbounds %struct.global_State, ptr %9, i64 0, i32 20
  br label %lua_pushvalue.exit

sw.bb10.i.i:                                      ; preds = %if.else9.i.i
  %ci.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %10 = load ptr, ptr %ci.i.i, align 8
  %func11.i.i = getelementptr inbounds %struct.CallInfo, ptr %10, i64 0, i32 1
  %11 = load ptr, ptr %func11.i.i, align 8
  %12 = load ptr, ptr %11, align 8
  %env.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23
  %env12.i.i = getelementptr inbounds %struct.CClosure, ptr %12, i64 0, i32 6
  %13 = load ptr, ptr %env12.i.i, align 8
  store ptr %13, ptr %env.i.i, align 8
  %tt.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23, i32 1
  store i32 5, ptr %tt.i.i, align 8
  br label %lua_pushvalue.exit

sw.bb15.i.i:                                      ; preds = %if.else9.i.i
  %l_gt.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 22
  br label %lua_pushvalue.exit

sw.default.i.i:                                   ; preds = %if.else9.i.i
  %ci17.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %14 = load ptr, ptr %ci17.i.i, align 8
  %func18.i.i = getelementptr inbounds %struct.CallInfo, ptr %14, i64 0, i32 1
  %15 = load ptr, ptr %func18.i.i, align 8
  %16 = load ptr, ptr %15, align 8
  %sub20.i.i = sub nuw nsw i32 -10001, %a
  %nupvalues.i.i = getelementptr inbounds %struct.CClosure, ptr %16, i64 0, i32 4
  %17 = load i8, ptr %nupvalues.i.i, align 1
  %conv.i.i = zext i8 %17 to i32
  %cmp21.not.i.i = icmp ugt i32 %sub20.i.i, %conv.i.i
  %sub23.i.i = sub nuw nsw i32 -10002, %a
  %idxprom.i.i = zext nneg i32 %sub23.i.i to i64
  %arrayidx.i.i = getelementptr inbounds %struct.CClosure, ptr %16, i64 0, i32 8, i64 %idxprom.i.i
  %cond.i.i = select i1 %cmp21.not.i.i, ptr @luaO_nilobject_, ptr %arrayidx.i.i
  br label %lua_pushvalue.exit

lua_pushvalue.exit:                               ; preds = %if.then.i.i, %if.then5.i.i, %sw.bb.i.i, %sw.bb10.i.i, %sw.bb15.i.i, %sw.default.i.i
  %retval.0.i.i = phi ptr [ %add.ptr8.i.i, %if.then5.i.i ], [ %cond.i.i, %sw.default.i.i ], [ %l_gt.i.i, %sw.bb15.i.i ], [ %env.i.i, %sw.bb10.i.i ], [ %l_registry.i.i, %sw.bb.i.i ], [ %add.ptr.luaO_nilobject_.i.i25, %if.then.i.i ]
  %18 = load i64, ptr %retval.0.i.i, align 8
  store i64 %18, ptr %incdec.ptr.i, align 8
  %tt.i18 = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i.i, i64 0, i32 1
  %19 = load i32, ptr %tt.i18, align 8
  %tt2.i19 = getelementptr inbounds %struct.lua_TValue, ptr %5, i64 1, i32 1
  store i32 %19, ptr %tt2.i19, align 8
  %20 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i20 = getelementptr inbounds %struct.lua_TValue, ptr %20, i64 1
  store ptr %incdec.ptr.i20, ptr %top.i.i, align 8
  %sub1 = add nsw i32 %b, -2
  %cmp.i.i26 = icmp sgt i32 %b, 2
  br i1 %cmp.i.i26, label %if.then.i.i62, label %if.else3.i.i27

if.then.i.i62:                                    ; preds = %lua_pushvalue.exit
  %21 = load ptr, ptr %base.i.i, align 8
  %22 = zext nneg i32 %sub1 to i64
  %23 = getelementptr %struct.lua_TValue, ptr %21, i64 %22
  %add.ptr.i.i64 = getelementptr %struct.lua_TValue, ptr %23, i64 -1
  %cmp1.not.i.i66 = icmp ult ptr %add.ptr.i.i64, %incdec.ptr.i20
  %add.ptr.luaO_nilobject_.i.i67 = select i1 %cmp1.not.i.i66, ptr %add.ptr.i.i64, ptr @luaO_nilobject_
  br label %lua_pushvalue.exit68

if.else3.i.i27:                                   ; preds = %lua_pushvalue.exit
  %cmp4.i.i28 = icmp sgt i32 %b, -9998
  br i1 %cmp4.i.i28, label %if.then5.i.i58, label %if.else9.i.i29

if.then5.i.i58:                                   ; preds = %if.else3.i.i27
  %idx.ext7.i.i60 = sext i32 %sub1 to i64
  %add.ptr8.i.i61 = getelementptr inbounds %struct.lua_TValue, ptr %incdec.ptr.i20, i64 %idx.ext7.i.i60
  br label %lua_pushvalue.exit68

if.else9.i.i29:                                   ; preds = %if.else3.i.i27
  switch i32 %b, label %sw.default.i.i47 [
    i32 -9998, label %sw.bb.i.i44
    i32 -9999, label %sw.bb10.i.i38
    i32 -10000, label %sw.bb15.i.i30
  ]

sw.bb.i.i44:                                      ; preds = %if.else9.i.i29
  %l_G.i.i45 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %24 = load ptr, ptr %l_G.i.i45, align 8
  %l_registry.i.i46 = getelementptr inbounds %struct.global_State, ptr %24, i64 0, i32 20
  br label %lua_pushvalue.exit68

sw.bb10.i.i38:                                    ; preds = %if.else9.i.i29
  %ci.i.i39 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %25 = load ptr, ptr %ci.i.i39, align 8
  %func11.i.i40 = getelementptr inbounds %struct.CallInfo, ptr %25, i64 0, i32 1
  %26 = load ptr, ptr %func11.i.i40, align 8
  %27 = load ptr, ptr %26, align 8
  %env.i.i41 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23
  %env12.i.i42 = getelementptr inbounds %struct.CClosure, ptr %27, i64 0, i32 6
  %28 = load ptr, ptr %env12.i.i42, align 8
  store ptr %28, ptr %env.i.i41, align 8
  %tt.i.i43 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23, i32 1
  store i32 5, ptr %tt.i.i43, align 8
  br label %lua_pushvalue.exit68

sw.bb15.i.i30:                                    ; preds = %if.else9.i.i29
  %l_gt.i.i31 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 22
  br label %lua_pushvalue.exit68

sw.default.i.i47:                                 ; preds = %if.else9.i.i29
  %ci17.i.i48 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %29 = load ptr, ptr %ci17.i.i48, align 8
  %func18.i.i49 = getelementptr inbounds %struct.CallInfo, ptr %29, i64 0, i32 1
  %30 = load ptr, ptr %func18.i.i49, align 8
  %31 = load ptr, ptr %30, align 8
  %sub20.i.i50 = sub nuw nsw i32 -10000, %b
  %nupvalues.i.i51 = getelementptr inbounds %struct.CClosure, ptr %31, i64 0, i32 4
  %32 = load i8, ptr %nupvalues.i.i51, align 1
  %conv.i.i52 = zext i8 %32 to i32
  %cmp21.not.i.i53 = icmp ugt i32 %sub20.i.i50, %conv.i.i52
  %sub23.i.i54 = sub nuw nsw i32 -10001, %b
  %idxprom.i.i55 = zext nneg i32 %sub23.i.i54 to i64
  %arrayidx.i.i56 = getelementptr inbounds %struct.CClosure, ptr %31, i64 0, i32 8, i64 %idxprom.i.i55
  %cond.i.i57 = select i1 %cmp21.not.i.i53, ptr @luaO_nilobject_, ptr %arrayidx.i.i56
  br label %lua_pushvalue.exit68

lua_pushvalue.exit68:                             ; preds = %if.then.i.i62, %if.then5.i.i58, %sw.bb.i.i44, %sw.bb10.i.i38, %sw.bb15.i.i30, %sw.default.i.i47
  %retval.0.i.i33 = phi ptr [ %add.ptr8.i.i61, %if.then5.i.i58 ], [ %cond.i.i57, %sw.default.i.i47 ], [ %l_gt.i.i31, %sw.bb15.i.i30 ], [ %env.i.i41, %sw.bb10.i.i38 ], [ %l_registry.i.i46, %sw.bb.i.i44 ], [ %add.ptr.luaO_nilobject_.i.i67, %if.then.i.i62 ]
  %33 = load i64, ptr %retval.0.i.i33, align 8
  store i64 %33, ptr %incdec.ptr.i20, align 8
  %tt.i35 = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i.i33, i64 0, i32 1
  %34 = load i32, ptr %tt.i35, align 8
  %tt2.i36 = getelementptr inbounds %struct.lua_TValue, ptr %20, i64 1, i32 1
  store i32 %34, ptr %tt2.i36, align 8
  %35 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i37 = getelementptr inbounds %struct.lua_TValue, ptr %35, i64 1
  store ptr %incdec.ptr.i37, ptr %top.i.i, align 8
  %add.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %35, i64 -2
  tail call fastcc void @luaD_call(ptr noundef nonnull %L, ptr noundef nonnull %add.ptr.i, i32 noundef 1)
  %36 = load ptr, ptr %top.i.i, align 8
  %tt.i76 = getelementptr %struct.lua_TValue, ptr %36, i64 -1, i32 1
  %37 = load i32, ptr %tt.i76, align 8
  switch i32 %37, label %lor.end.fold.split.i [
    i32 0, label %lua_toboolean.exit
    i32 1, label %land.rhs.i
  ]

land.rhs.i:                                       ; preds = %lua_pushvalue.exit68
  %add.ptr8.i.i73 = getelementptr inbounds %struct.lua_TValue, ptr %36, i64 -1
  %38 = load i32, ptr %add.ptr8.i.i73, align 8
  %cmp3.i = icmp ne i32 %38, 0
  %39 = zext i1 %cmp3.i to i32
  br label %lua_toboolean.exit

lor.end.fold.split.i:                             ; preds = %lua_pushvalue.exit68
  br label %lua_toboolean.exit

lua_toboolean.exit:                               ; preds = %lua_pushvalue.exit68, %land.rhs.i, %lor.end.fold.split.i
  %lnot.i = phi i32 [ %37, %lua_pushvalue.exit68 ], [ %39, %land.rhs.i ], [ 1, %lor.end.fold.split.i ]
  %add.ptr9.i = getelementptr %struct.lua_TValue, ptr %36, i64 -1
  store ptr %add.ptr9.i, ptr %top.i.i, align 8
  br label %return

if.else:                                          ; preds = %lua_type.exit
  %cmp.i.i78 = icmp sgt i32 %a, 0
  br i1 %cmp.i.i78, label %if.then.i.i113, label %if.else3.i.i79

if.then.i.i113:                                   ; preds = %if.else
  %40 = zext nneg i32 %a to i64
  %41 = getelementptr %struct.lua_TValue, ptr %0, i64 %40
  %add.ptr.i.i115 = getelementptr %struct.lua_TValue, ptr %41, i64 -1
  %cmp1.not.i.i117 = icmp ult ptr %add.ptr.i.i115, %1
  %add.ptr.luaO_nilobject_.i.i118 = select i1 %cmp1.not.i.i117, ptr %add.ptr.i.i115, ptr @luaO_nilobject_
  br label %index2adr.exit.i84

if.else3.i.i79:                                   ; preds = %if.else
  %cmp4.i.i80 = icmp sgt i32 %a, -10000
  br i1 %cmp4.i.i80, label %if.then5.i.i109, label %if.else9.i.i81

if.then5.i.i109:                                  ; preds = %if.else3.i.i79
  %idx.ext7.i.i111 = sext i32 %a to i64
  %add.ptr8.i.i112 = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 %idx.ext7.i.i111
  br label %index2adr.exit.i84

if.else9.i.i81:                                   ; preds = %if.else3.i.i79
  switch i32 %a, label %sw.default.i.i98 [
    i32 -10000, label %sw.bb.i.i95
    i32 -10001, label %sw.bb10.i.i89
    i32 -10002, label %sw.bb15.i.i82
  ]

sw.bb.i.i95:                                      ; preds = %if.else9.i.i81
  %l_G.i.i96 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %42 = load ptr, ptr %l_G.i.i96, align 8
  %l_registry.i.i97 = getelementptr inbounds %struct.global_State, ptr %42, i64 0, i32 20
  br label %index2adr.exit.i84

sw.bb10.i.i89:                                    ; preds = %if.else9.i.i81
  %ci.i.i90 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %43 = load ptr, ptr %ci.i.i90, align 8
  %func11.i.i91 = getelementptr inbounds %struct.CallInfo, ptr %43, i64 0, i32 1
  %44 = load ptr, ptr %func11.i.i91, align 8
  %45 = load ptr, ptr %44, align 8
  %env.i.i92 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23
  %env12.i.i93 = getelementptr inbounds %struct.CClosure, ptr %45, i64 0, i32 6
  %46 = load ptr, ptr %env12.i.i93, align 8
  store ptr %46, ptr %env.i.i92, align 8
  %tt.i.i94 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23, i32 1
  store i32 5, ptr %tt.i.i94, align 8
  br label %index2adr.exit.i84

sw.bb15.i.i82:                                    ; preds = %if.else9.i.i81
  %l_gt.i.i83 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 22
  br label %index2adr.exit.i84

sw.default.i.i98:                                 ; preds = %if.else9.i.i81
  %ci17.i.i99 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %47 = load ptr, ptr %ci17.i.i99, align 8
  %func18.i.i100 = getelementptr inbounds %struct.CallInfo, ptr %47, i64 0, i32 1
  %48 = load ptr, ptr %func18.i.i100, align 8
  %49 = load ptr, ptr %48, align 8
  %sub20.i.i101 = sub nuw nsw i32 -10002, %a
  %nupvalues.i.i102 = getelementptr inbounds %struct.CClosure, ptr %49, i64 0, i32 4
  %50 = load i8, ptr %nupvalues.i.i102, align 1
  %conv.i.i103 = zext i8 %50 to i32
  %cmp21.not.i.i104 = icmp ugt i32 %sub20.i.i101, %conv.i.i103
  %sub23.i.i105 = sub nuw nsw i32 -10003, %a
  %idxprom.i.i106 = zext nneg i32 %sub23.i.i105 to i64
  %arrayidx.i.i107 = getelementptr inbounds %struct.CClosure, ptr %49, i64 0, i32 8, i64 %idxprom.i.i106
  %cond.i.i108 = select i1 %cmp21.not.i.i104, ptr @luaO_nilobject_, ptr %arrayidx.i.i107
  br label %index2adr.exit.i84

index2adr.exit.i84:                               ; preds = %sw.default.i.i98, %sw.bb15.i.i82, %sw.bb10.i.i89, %sw.bb.i.i95, %if.then5.i.i109, %if.then.i.i113
  %retval.0.i.i85 = phi ptr [ %add.ptr8.i.i112, %if.then5.i.i109 ], [ %cond.i.i108, %sw.default.i.i98 ], [ %l_gt.i.i83, %sw.bb15.i.i82 ], [ %env.i.i92, %sw.bb10.i.i89 ], [ %l_registry.i.i97, %sw.bb.i.i95 ], [ %add.ptr.luaO_nilobject_.i.i118, %if.then.i.i113 ]
  %cmp.i5.i = icmp sgt i32 %b, 0
  br i1 %cmp.i5.i, label %if.then.i36.i, label %if.else3.i6.i

if.then.i36.i:                                    ; preds = %index2adr.exit.i84
  %51 = zext nneg i32 %b to i64
  %52 = getelementptr %struct.lua_TValue, ptr %0, i64 %51
  %add.ptr.i38.i = getelementptr %struct.lua_TValue, ptr %52, i64 -1
  %cmp1.not.i40.i = icmp ult ptr %add.ptr.i38.i, %1
  %add.ptr.luaO_nilobject_.i41.i = select i1 %cmp1.not.i40.i, ptr %add.ptr.i38.i, ptr @luaO_nilobject_
  br label %index2adr.exit42.i

if.else3.i6.i:                                    ; preds = %index2adr.exit.i84
  %cmp4.i7.i = icmp sgt i32 %b, -10000
  br i1 %cmp4.i7.i, label %if.then5.i32.i, label %if.else9.i8.i

if.then5.i32.i:                                   ; preds = %if.else3.i6.i
  %idx.ext7.i34.i = sext i32 %b to i64
  %add.ptr8.i35.i = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 %idx.ext7.i34.i
  br label %index2adr.exit42.i

if.else9.i8.i:                                    ; preds = %if.else3.i6.i
  switch i32 %b, label %sw.default.i21.i [
    i32 -10000, label %sw.bb.i18.i
    i32 -10001, label %sw.bb10.i12.i
    i32 -10002, label %sw.bb15.i9.i
  ]

sw.bb.i18.i:                                      ; preds = %if.else9.i8.i
  %l_G.i19.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %53 = load ptr, ptr %l_G.i19.i, align 8
  %l_registry.i20.i = getelementptr inbounds %struct.global_State, ptr %53, i64 0, i32 20
  br label %index2adr.exit42.i

sw.bb10.i12.i:                                    ; preds = %if.else9.i8.i
  %ci.i13.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %54 = load ptr, ptr %ci.i13.i, align 8
  %func11.i14.i = getelementptr inbounds %struct.CallInfo, ptr %54, i64 0, i32 1
  %55 = load ptr, ptr %func11.i14.i, align 8
  %56 = load ptr, ptr %55, align 8
  %env.i15.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23
  %env12.i16.i = getelementptr inbounds %struct.CClosure, ptr %56, i64 0, i32 6
  %57 = load ptr, ptr %env12.i16.i, align 8
  store ptr %57, ptr %env.i15.i, align 8
  %tt.i17.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23, i32 1
  store i32 5, ptr %tt.i17.i, align 8
  br label %index2adr.exit42.i

sw.bb15.i9.i:                                     ; preds = %if.else9.i8.i
  %l_gt.i10.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 22
  br label %index2adr.exit42.i

sw.default.i21.i:                                 ; preds = %if.else9.i8.i
  %ci17.i22.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %58 = load ptr, ptr %ci17.i22.i, align 8
  %func18.i23.i = getelementptr inbounds %struct.CallInfo, ptr %58, i64 0, i32 1
  %59 = load ptr, ptr %func18.i23.i, align 8
  %60 = load ptr, ptr %59, align 8
  %sub20.i24.i = sub nuw nsw i32 -10002, %b
  %nupvalues.i25.i = getelementptr inbounds %struct.CClosure, ptr %60, i64 0, i32 4
  %61 = load i8, ptr %nupvalues.i25.i, align 1
  %conv.i26.i = zext i8 %61 to i32
  %cmp21.not.i27.i = icmp ugt i32 %sub20.i24.i, %conv.i26.i
  %sub23.i28.i = sub nuw nsw i32 -10003, %b
  %idxprom.i29.i = zext nneg i32 %sub23.i28.i to i64
  %arrayidx.i30.i = getelementptr inbounds %struct.CClosure, ptr %60, i64 0, i32 8, i64 %idxprom.i29.i
  %cond.i31.i = select i1 %cmp21.not.i27.i, ptr @luaO_nilobject_, ptr %arrayidx.i30.i
  br label %index2adr.exit42.i

index2adr.exit42.i:                               ; preds = %sw.default.i21.i, %sw.bb15.i9.i, %sw.bb10.i12.i, %sw.bb.i18.i, %if.then5.i32.i, %if.then.i36.i
  %retval.0.i11.i = phi ptr [ %add.ptr8.i35.i, %if.then5.i32.i ], [ %cond.i31.i, %sw.default.i21.i ], [ %l_gt.i10.i, %sw.bb15.i9.i ], [ %env.i15.i, %sw.bb10.i12.i ], [ %l_registry.i20.i, %sw.bb.i18.i ], [ %add.ptr.luaO_nilobject_.i41.i, %if.then.i36.i ]
  %cmp.i86 = icmp eq ptr %retval.0.i.i85, @luaO_nilobject_
  %cmp2.i = icmp eq ptr %retval.0.i11.i, @luaO_nilobject_
  %or.cond.i = select i1 %cmp.i86, i1 true, i1 %cmp2.i
  br i1 %or.cond.i, label %return, label %cond.false.i87

cond.false.i87:                                   ; preds = %index2adr.exit42.i
  %call3.i = tail call fastcc i32 @luaV_lessthan(ptr noundef nonnull %L, ptr noundef %retval.0.i.i85, ptr noundef %retval.0.i11.i), !range !23
  br label %return

return:                                           ; preds = %cond.false.i87, %index2adr.exit42.i, %lua_toboolean.exit
  %retval.0 = phi i32 [ %lnot.i, %lua_toboolean.exit ], [ %call3.i, %cond.false.i87 ], [ 0, %index2adr.exit42.i ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal fastcc void @newfenv(ptr noundef %L, ptr noundef %cls) unnamed_addr #0 {
entry:
  %key.i = alloca %struct.lua_TValue, align 8
  %l_G.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %0 = load ptr, ptr %l_G.i, align 8
  %totalbytes.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 14
  %1 = load i64, ptr %totalbytes.i, align 8
  %GCthreshold.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 13
  %2 = load i64, ptr %GCthreshold.i, align 8
  %cmp.not.i = icmp ult i64 %1, %2
  br i1 %cmp.not.i, label %lua_createtable.exit, label %if.then.i

if.then.i:                                        ; preds = %entry
  %gcstepmul.i.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 18
  %3 = load i32, ptr %gcstepmul.i.i, align 4
  %mul.i.i = mul i32 %3, 10
  %conv.i.i = zext i32 %mul.i.i to i64
  %cmp.i.i = icmp eq i32 %mul.i.i, 0
  %spec.store.select.i.i = select i1 %cmp.i.i, i64 9223372036854775806, i64 %conv.i.i
  %sub.i.i = sub i64 %1, %2
  %gcdept.i.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 16
  %4 = load i64, ptr %gcdept.i.i, align 8
  %add.i.i = add i64 %sub.i.i, %4
  store i64 %add.i.i, ptr %gcdept.i.i, align 8
  %gcstate.i.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 4
  br label %do.body.i.i

do.body.i.i:                                      ; preds = %do.body.i.i, %if.then.i
  %lim.0.i.i = phi i64 [ %spec.store.select.i.i, %if.then.i ], [ %sub2.i.i, %do.body.i.i ]
  %call.i.i = tail call fastcc i64 @singlestep(ptr noundef %L)
  %sub2.i.i = sub nsw i64 %lim.0.i.i, %call.i.i
  %5 = load i8, ptr %gcstate.i.i, align 1
  %cmp4.i.i = icmp ne i8 %5, 0
  %cmp8.i.i = icmp sgt i64 %sub2.i.i, 0
  %or.cond.i.i = select i1 %cmp4.i.i, i1 %cmp8.i.i, i1 false
  br i1 %or.cond.i.i, label %do.body.i.i, label %do.end.i.i, !llvm.loop !6

do.end.i.i:                                       ; preds = %do.body.i.i
  br i1 %cmp4.i.i, label %if.then14.i.i, label %if.else27.i.i

if.then14.i.i:                                    ; preds = %do.end.i.i
  %6 = load i64, ptr %gcdept.i.i, align 8
  %cmp16.i.i = icmp ult i64 %6, 1024
  br i1 %cmp16.i.i, label %if.then18.i.i, label %if.else.i.i

if.then18.i.i:                                    ; preds = %if.then14.i.i
  %7 = load i64, ptr %totalbytes.i, align 8
  %add20.i.i = add i64 %7, 1024
  br label %luaC_step.exit.i

if.else.i.i:                                      ; preds = %if.then14.i.i
  %sub23.i.i = add i64 %6, -1024
  store i64 %sub23.i.i, ptr %gcdept.i.i, align 8
  %8 = load i64, ptr %totalbytes.i, align 8
  br label %luaC_step.exit.i

if.else27.i.i:                                    ; preds = %do.end.i.i
  %estimate.i.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 15
  %9 = load i64, ptr %estimate.i.i, align 8
  %div.i.i = udiv i64 %9, 100
  %gcpause.i.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 17
  %10 = load i32, ptr %gcpause.i.i, align 8
  %conv28.i.i = sext i32 %10 to i64
  %mul29.i.i = mul i64 %div.i.i, %conv28.i.i
  br label %luaC_step.exit.i

luaC_step.exit.i:                                 ; preds = %if.else27.i.i, %if.else.i.i, %if.then18.i.i
  %add20.sink.i.i = phi i64 [ %add20.i.i, %if.then18.i.i ], [ %8, %if.else.i.i ], [ %mul29.i.i, %if.else27.i.i ]
  store i64 %add20.sink.i.i, ptr %GCthreshold.i, align 8
  br label %lua_createtable.exit

lua_createtable.exit:                             ; preds = %entry, %luaC_step.exit.i
  %top.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %11 = load ptr, ptr %top.i, align 8
  %call.i = tail call fastcc ptr @luaH_new(ptr noundef %L, i32 noundef 0, i32 noundef 1)
  store ptr %call.i, ptr %11, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %11, i64 0, i32 1
  store i32 5, ptr %tt.i, align 8
  %12 = load ptr, ptr %top.i, align 8
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %12, i64 1
  store ptr %incdec.ptr.i, ptr %top.i, align 8
  tail call fastcc void @lua_pushcclosure(ptr noundef %L, ptr noundef %cls, i32 noundef 0)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %key.i)
  %13 = load ptr, ptr %top.i, align 8
  %add.ptr8.i.i = getelementptr inbounds %struct.lua_TValue, ptr %13, i64 -2
  %call2.i = tail call fastcc ptr @luaS_newlstr(ptr noundef %L, ptr noundef nonnull @.str.206, i64 noundef 7)
  store ptr %call2.i, ptr %key.i, align 8
  %tt.i3 = getelementptr inbounds %struct.lua_TValue, ptr %key.i, i64 0, i32 1
  store i32 4, ptr %tt.i3, align 8
  %14 = load ptr, ptr %top.i, align 8
  %add.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %14, i64 -1
  call fastcc void @luaV_settable(ptr noundef %L, ptr noundef nonnull %add.ptr8.i.i, ptr noundef nonnull %key.i, ptr noundef nonnull %add.ptr.i)
  %15 = load ptr, ptr %top.i, align 8
  %incdec.ptr.i5 = getelementptr inbounds %struct.lua_TValue, ptr %15, i64 -1
  store ptr %incdec.ptr.i5, ptr %top.i, align 8
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %key.i)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @io_fclose(ptr noundef %L) #0 {
entry:
  %call = tail call fastcc ptr @luaL_checkudata(ptr noundef %L)
  %0 = load ptr, ptr %call, align 8
  %call1 = tail call i32 @fclose(ptr noundef %0)
  %cmp.not = icmp eq i32 %call1, 0
  store ptr null, ptr %call, align 8
  %top.i8.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i8.i, align 8
  br i1 %cmp.not, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %entry
  store i32 1, ptr %1, align 8
  br label %pushresult.exit

if.else.i:                                        ; preds = %entry
  %call.i = tail call ptr @__errno_location() #39
  %2 = load i32, ptr %call.i, align 4
  %tt.i9.i = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 0, i32 1
  store i32 0, ptr %tt.i9.i, align 8
  %3 = load ptr, ptr %top.i8.i, align 8
  %incdec.ptr.i10.i = getelementptr inbounds %struct.lua_TValue, ptr %3, i64 1
  store ptr %incdec.ptr.i10.i, ptr %top.i8.i, align 8
  %call6.i = tail call ptr @strerror(i32 noundef %2) #35
  %call7.i = tail call ptr (ptr, ptr, ...) @lua_pushfstring(ptr noundef nonnull %L, ptr noundef nonnull @.str.113, ptr noundef %call6.i)
  %4 = load ptr, ptr %top.i8.i, align 8
  %conv.i.i = sitofp i32 %2 to double
  store double %conv.i.i, ptr %4, align 8
  br label %pushresult.exit

pushresult.exit:                                  ; preds = %if.then.i, %if.else.i
  %.sink14.i = phi ptr [ %4, %if.else.i ], [ %1, %if.then.i ]
  %.sink.i = phi i32 [ 3, %if.else.i ], [ 1, %if.then.i ]
  %tt.i12.i = getelementptr inbounds %struct.lua_TValue, ptr %.sink14.i, i64 0, i32 1
  store i32 %.sink.i, ptr %tt.i12.i, align 8
  %5 = load ptr, ptr %top.i8.i, align 8
  %incdec.ptr.i13.i = getelementptr inbounds %struct.lua_TValue, ptr %5, i64 1
  store ptr %incdec.ptr.i13.i, ptr %top.i8.i, align 8
  ret i32 %.sink.i
}

; Function Attrs: nounwind uwtable
define internal i32 @io_noclose(ptr noundef %L) #0 {
entry:
  %top.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %0 = load ptr, ptr %top.i, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %0, i64 0, i32 1
  store i32 0, ptr %tt.i, align 8
  %1 = load ptr, ptr %top.i, align 8
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 1
  store ptr %incdec.ptr.i, ptr %top.i, align 8
  %l_G.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %2 = load ptr, ptr %l_G.i, align 8
  %totalbytes.i = getelementptr inbounds %struct.global_State, ptr %2, i64 0, i32 14
  %3 = load i64, ptr %totalbytes.i, align 8
  %GCthreshold.i = getelementptr inbounds %struct.global_State, ptr %2, i64 0, i32 13
  %4 = load i64, ptr %GCthreshold.i, align 8
  %cmp.not.i = icmp ult i64 %3, %4
  br i1 %cmp.not.i, label %lua_pushlstring.exit, label %if.then.i

if.then.i:                                        ; preds = %entry
  %gcstepmul.i.i = getelementptr inbounds %struct.global_State, ptr %2, i64 0, i32 18
  %5 = load i32, ptr %gcstepmul.i.i, align 4
  %mul.i.i = mul i32 %5, 10
  %conv.i.i = zext i32 %mul.i.i to i64
  %cmp.i.i = icmp eq i32 %mul.i.i, 0
  %spec.store.select.i.i = select i1 %cmp.i.i, i64 9223372036854775806, i64 %conv.i.i
  %sub.i.i = sub i64 %3, %4
  %gcdept.i.i = getelementptr inbounds %struct.global_State, ptr %2, i64 0, i32 16
  %6 = load i64, ptr %gcdept.i.i, align 8
  %add.i.i = add i64 %sub.i.i, %6
  store i64 %add.i.i, ptr %gcdept.i.i, align 8
  %gcstate.i.i = getelementptr inbounds %struct.global_State, ptr %2, i64 0, i32 4
  br label %do.body.i.i

do.body.i.i:                                      ; preds = %do.body.i.i, %if.then.i
  %lim.0.i.i = phi i64 [ %spec.store.select.i.i, %if.then.i ], [ %sub2.i.i, %do.body.i.i ]
  %call.i.i = tail call fastcc i64 @singlestep(ptr noundef %L)
  %sub2.i.i = sub nsw i64 %lim.0.i.i, %call.i.i
  %7 = load i8, ptr %gcstate.i.i, align 1
  %cmp4.i.i = icmp ne i8 %7, 0
  %cmp8.i.i = icmp sgt i64 %sub2.i.i, 0
  %or.cond.i.i = select i1 %cmp4.i.i, i1 %cmp8.i.i, i1 false
  br i1 %or.cond.i.i, label %do.body.i.i, label %do.end.i.i, !llvm.loop !6

do.end.i.i:                                       ; preds = %do.body.i.i
  br i1 %cmp4.i.i, label %if.then14.i.i, label %if.else27.i.i

if.then14.i.i:                                    ; preds = %do.end.i.i
  %8 = load i64, ptr %gcdept.i.i, align 8
  %cmp16.i.i = icmp ult i64 %8, 1024
  br i1 %cmp16.i.i, label %if.then18.i.i, label %if.else.i.i

if.then18.i.i:                                    ; preds = %if.then14.i.i
  %9 = load i64, ptr %totalbytes.i, align 8
  %add20.i.i = add i64 %9, 1024
  br label %luaC_step.exit.i

if.else.i.i:                                      ; preds = %if.then14.i.i
  %sub23.i.i = add i64 %8, -1024
  store i64 %sub23.i.i, ptr %gcdept.i.i, align 8
  %10 = load i64, ptr %totalbytes.i, align 8
  br label %luaC_step.exit.i

if.else27.i.i:                                    ; preds = %do.end.i.i
  %estimate.i.i = getelementptr inbounds %struct.global_State, ptr %2, i64 0, i32 15
  %11 = load i64, ptr %estimate.i.i, align 8
  %div.i.i = udiv i64 %11, 100
  %gcpause.i.i = getelementptr inbounds %struct.global_State, ptr %2, i64 0, i32 17
  %12 = load i32, ptr %gcpause.i.i, align 8
  %conv28.i.i = sext i32 %12 to i64
  %mul29.i.i = mul i64 %div.i.i, %conv28.i.i
  br label %luaC_step.exit.i

luaC_step.exit.i:                                 ; preds = %if.else27.i.i, %if.else.i.i, %if.then18.i.i
  %add20.sink.i.i = phi i64 [ %add20.i.i, %if.then18.i.i ], [ %10, %if.else.i.i ], [ %mul29.i.i, %if.else27.i.i ]
  store i64 %add20.sink.i.i, ptr %GCthreshold.i, align 8
  %.pre = load ptr, ptr %top.i, align 8
  br label %lua_pushlstring.exit

lua_pushlstring.exit:                             ; preds = %entry, %luaC_step.exit.i
  %13 = phi ptr [ %incdec.ptr.i, %entry ], [ %.pre, %luaC_step.exit.i ]
  %call.i = tail call fastcc ptr @luaS_newlstr(ptr noundef nonnull %L, ptr noundef nonnull @.str.222, i64 noundef 26)
  store ptr %call.i, ptr %13, align 8
  %tt.i3 = getelementptr inbounds %struct.lua_TValue, ptr %13, i64 0, i32 1
  store i32 4, ptr %tt.i3, align 8
  %14 = load ptr, ptr %top.i, align 8
  %incdec.ptr.i4 = getelementptr inbounds %struct.lua_TValue, ptr %14, i64 1
  store ptr %incdec.ptr.i4, ptr %top.i, align 8
  ret i32 2
}

; Function Attrs: nounwind uwtable
define internal fastcc void @createstdfile(ptr noundef %L, ptr noundef %f, i32 noundef %k, ptr nocapture noundef readonly %fname) unnamed_addr #0 {
entry:
  %key.i = alloca %struct.lua_TValue, align 8
  %key.i.i = alloca %struct.lua_TValue, align 8
  %call.i = tail call fastcc ptr @lua_newuserdata(ptr noundef %L, i64 noundef 8)
  store ptr null, ptr %call.i, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %key.i.i)
  %l_G.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %0 = load ptr, ptr %l_G.i.i.i, align 8
  %l_registry.i.i.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 20
  %call2.i.i = tail call fastcc ptr @luaS_newlstr(ptr noundef %L, ptr noundef nonnull @.str.199, i64 noundef 5)
  store ptr %call2.i.i, ptr %key.i.i, align 8
  %tt.i.i = getelementptr inbounds %struct.lua_TValue, ptr %key.i.i, i64 0, i32 1
  store i32 4, ptr %tt.i.i, align 8
  %top.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i, align 8
  call fastcc void @luaV_gettable(ptr noundef %L, ptr noundef nonnull %l_registry.i.i.i, ptr noundef nonnull %key.i.i, ptr noundef %1)
  %2 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i.i = getelementptr inbounds %struct.lua_TValue, ptr %2, i64 1
  store ptr %incdec.ptr.i.i, ptr %top.i.i, align 8
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %key.i.i)
  tail call fastcc void @lua_setmetatable(ptr noundef %L, i32 noundef -2)
  store ptr %f, ptr %call.i, align 8
  %cmp = icmp sgt i32 %k, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %top.i.i, align 8
  %add.ptr8.i.i = getelementptr inbounds %struct.lua_TValue, ptr %3, i64 -1
  %4 = load i64, ptr %add.ptr8.i.i, align 8
  store i64 %4, ptr %3, align 8
  %tt.i = getelementptr %struct.lua_TValue, ptr %3, i64 -1, i32 1
  %5 = load i32, ptr %tt.i, align 8
  %tt2.i = getelementptr inbounds %struct.lua_TValue, ptr %3, i64 0, i32 1
  store i32 %5, ptr %tt2.i, align 8
  %6 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %6, i64 1
  store ptr %incdec.ptr.i, ptr %top.i.i, align 8
  tail call fastcc void @lua_rawseti(ptr noundef nonnull %L, i32 noundef -10001, i32 noundef %k)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %7 = load ptr, ptr %top.i.i, align 8
  %add.ptr8.i.i8 = getelementptr inbounds %struct.lua_TValue, ptr %7, i64 -2
  %8 = load i64, ptr %add.ptr8.i.i8, align 8
  store i64 %8, ptr %7, align 8
  %tt.i10 = getelementptr %struct.lua_TValue, ptr %7, i64 -2, i32 1
  %9 = load i32, ptr %tt.i10, align 8
  %tt2.i11 = getelementptr inbounds %struct.lua_TValue, ptr %7, i64 0, i32 1
  store i32 %9, ptr %tt2.i11, align 8
  %10 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i12 = getelementptr inbounds %struct.lua_TValue, ptr %10, i64 1
  store ptr %incdec.ptr.i12, ptr %top.i.i, align 8
  %add.ptr8.i.i14 = getelementptr inbounds %struct.lua_TValue, ptr %10, i64 -1
  %tt.i15 = getelementptr %struct.lua_TValue, ptr %10, i64 -1, i32 1
  %11 = load i32, ptr %tt.i15, align 8
  switch i32 %11, label %lua_setfenv.exit [
    i32 6, label %sw.bb.i
    i32 7, label %sw.bb2.i
    i32 8, label %sw.bb8.i
  ]

sw.bb.i:                                          ; preds = %if.end
  %12 = load ptr, ptr %10, align 8
  %13 = load ptr, ptr %add.ptr8.i.i14, align 8
  %env.i = getelementptr inbounds %struct.CClosure, ptr %13, i64 0, i32 6
  store ptr %12, ptr %env.i, align 8
  br label %if.then.i

sw.bb2.i:                                         ; preds = %if.end
  %14 = load ptr, ptr %10, align 8
  %15 = load ptr, ptr %add.ptr8.i.i14, align 8
  %env7.i = getelementptr inbounds %struct.anon.1, ptr %15, i64 0, i32 4
  store ptr %14, ptr %env7.i, align 8
  br label %if.then.i

sw.bb8.i:                                         ; preds = %if.end
  %16 = load ptr, ptr %add.ptr8.i.i14, align 8
  %l_gt.i = getelementptr inbounds %struct.lua_State, ptr %16, i64 0, i32 22
  %17 = load ptr, ptr %10, align 8
  store ptr %17, ptr %l_gt.i, align 8
  %tt14.i = getelementptr inbounds %struct.lua_State, ptr %16, i64 0, i32 22, i32 1
  store i32 5, ptr %tt14.i, align 8
  br label %if.then.i

if.then.i:                                        ; preds = %sw.bb8.i, %sw.bb2.i, %sw.bb.i
  %18 = load ptr, ptr %top.i.i, align 8
  %add.ptr16.i = getelementptr inbounds %struct.lua_TValue, ptr %18, i64 -1
  %19 = load ptr, ptr %add.ptr16.i, align 8
  %marked.i = getelementptr inbounds %struct.GCheader, ptr %19, i64 0, i32 2
  %20 = load i8, ptr %marked.i, align 1
  %21 = and i8 %20, 3
  %tobool18.not.i = icmp eq i8 %21, 0
  br i1 %tobool18.not.i, label %lua_setfenv.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.then.i
  %22 = load ptr, ptr %add.ptr8.i.i14, align 8
  %marked20.i = getelementptr inbounds %struct.GCheader, ptr %22, i64 0, i32 2
  %23 = load i8, ptr %marked20.i, align 1
  %24 = and i8 %23, 4
  %tobool23.not.i = icmp eq i8 %24, 0
  br i1 %tobool23.not.i, label %lua_setfenv.exit, label %if.then24.i

if.then24.i:                                      ; preds = %land.lhs.true.i
  %L.val.i = load ptr, ptr %l_G.i.i.i, align 8
  %gcstate.i.i = getelementptr inbounds %struct.global_State, ptr %L.val.i, i64 0, i32 4
  %25 = load i8, ptr %gcstate.i.i, align 1
  %cmp.i.i = icmp eq i8 %25, 1
  br i1 %cmp.i.i, label %if.then.i.i, label %if.else.i.i

if.then.i.i:                                      ; preds = %if.then24.i
  tail call fastcc void @reallymarkobject(ptr noundef nonnull %L.val.i, ptr noundef nonnull %19)
  br label %lua_setfenv.exit

if.else.i.i:                                      ; preds = %if.then24.i
  %26 = and i8 %23, -8
  %currentwhite.i.i = getelementptr inbounds %struct.global_State, ptr %L.val.i, i64 0, i32 3
  %27 = load i8, ptr %currentwhite.i.i, align 8
  %28 = and i8 %27, 3
  %or4.i.i = or disjoint i8 %28, %26
  store i8 %or4.i.i, ptr %marked20.i, align 1
  br label %lua_setfenv.exit

lua_setfenv.exit:                                 ; preds = %if.end, %if.then.i, %land.lhs.true.i, %if.then.i.i, %if.else.i.i
  %29 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i16 = getelementptr inbounds %struct.lua_TValue, ptr %29, i64 -1
  store ptr %incdec.ptr.i16, ptr %top.i.i, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %key.i)
  %add.ptr8.i.i18 = getelementptr inbounds %struct.lua_TValue, ptr %29, i64 -4
  %call1.i19 = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %fname) #34
  %call2.i = tail call fastcc ptr @luaS_newlstr(ptr noundef nonnull %L, ptr noundef %fname, i64 noundef %call1.i19)
  store ptr %call2.i, ptr %key.i, align 8
  %tt.i20 = getelementptr inbounds %struct.lua_TValue, ptr %key.i, i64 0, i32 1
  store i32 4, ptr %tt.i20, align 8
  %30 = load ptr, ptr %top.i.i, align 8
  %add.ptr.i22 = getelementptr inbounds %struct.lua_TValue, ptr %30, i64 -1
  call fastcc void @luaV_settable(ptr noundef nonnull %L, ptr noundef nonnull %add.ptr8.i.i18, ptr noundef nonnull %key.i, ptr noundef nonnull %add.ptr.i22)
  %31 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i23 = getelementptr inbounds %struct.lua_TValue, ptr %31, i64 -1
  store ptr %incdec.ptr.i23, ptr %top.i.i, align 8
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %key.i)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @io_pclose(ptr noundef %L) #0 {
entry:
  %call = tail call fastcc ptr @luaL_checkudata(ptr noundef %L)
  store ptr null, ptr %call, align 8
  %call.i = tail call ptr @__errno_location() #39
  %0 = load i32, ptr %call.i, align 4
  %top.i8.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i8.i, align 8
  %tt.i9.i = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 0, i32 1
  store i32 0, ptr %tt.i9.i, align 8
  %2 = load ptr, ptr %top.i8.i, align 8
  %incdec.ptr.i10.i = getelementptr inbounds %struct.lua_TValue, ptr %2, i64 1
  store ptr %incdec.ptr.i10.i, ptr %top.i8.i, align 8
  %call6.i = tail call ptr @strerror(i32 noundef %0) #35
  %call7.i = tail call ptr (ptr, ptr, ...) @lua_pushfstring(ptr noundef nonnull %L, ptr noundef nonnull @.str.113, ptr noundef %call6.i)
  %3 = load ptr, ptr %top.i8.i, align 8
  %conv.i.i = sitofp i32 %0 to double
  store double %conv.i.i, ptr %3, align 8
  %tt.i12.i = getelementptr inbounds %struct.lua_TValue, ptr %3, i64 0, i32 1
  store i32 3, ptr %tt.i12.i, align 8
  %4 = load ptr, ptr %top.i8.i, align 8
  %incdec.ptr.i13.i = getelementptr inbounds %struct.lua_TValue, ptr %4, i64 1
  store ptr %incdec.ptr.i13.i, ptr %top.i8.i, align 8
  ret i32 3
}

; Function Attrs: nounwind uwtable
define internal i32 @io_close(ptr noundef %L) #0 {
entry:
  %key.i.i = alloca %struct.lua_TValue, align 8
  %base.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i, align 8
  %top.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i, align 8
  %cmp1.not.i.i = icmp uge ptr %0, %1
  %cmp.i = icmp eq ptr %0, @luaO_nilobject_
  %or.cond = or i1 %cmp.i, %cmp1.not.i.i
  br i1 %or.cond, label %if.then, label %lua_type.exit

lua_type.exit:                                    ; preds = %entry
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %0, i64 0, i32 1
  %2 = load i32, ptr %tt.i, align 8
  %cmp = icmp eq i32 %2, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry, %lua_type.exit
  %ci.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %3 = load ptr, ptr %ci.i.i, align 8
  %func11.i.i = getelementptr inbounds %struct.CallInfo, ptr %3, i64 0, i32 1
  %4 = load ptr, ptr %func11.i.i, align 8
  %5 = load ptr, ptr %4, align 8
  %env.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23
  %env12.i.i = getelementptr inbounds %struct.CClosure, ptr %5, i64 0, i32 6
  %6 = load ptr, ptr %env12.i.i, align 8
  store ptr %6, ptr %env.i.i, align 8
  %tt.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23, i32 1
  store i32 5, ptr %tt.i.i, align 8
  %sizearray.i.i = getelementptr inbounds %struct.Table, ptr %6, i64 0, i32 10
  %7 = load i32, ptr %sizearray.i.i, align 8
  %cmp.i5.i = icmp ugt i32 %7, 1
  br i1 %cmp.i5.i, label %if.then.i9.i, label %if.else.i.i

if.then.i9.i:                                     ; preds = %if.then
  %array.i.i = getelementptr inbounds %struct.Table, ptr %6, i64 0, i32 6
  %8 = load ptr, ptr %array.i.i, align 8
  %arrayidx.i11.i = getelementptr inbounds %struct.lua_TValue, ptr %8, i64 1
  br label %lua_rawgeti.exit

if.else.i.i:                                      ; preds = %if.then
  %node4.i.i.i = getelementptr inbounds %struct.Table, ptr %6, i64 0, i32 7
  %9 = load ptr, ptr %node4.i.i.i, align 8
  %lsizenode.i.i.i = getelementptr inbounds %struct.Table, ptr %6, i64 0, i32 4
  %10 = load i8, ptr %lsizenode.i.i.i, align 1
  %sh_prom.i.i.i = zext nneg i8 %10 to i64
  %notmask.i.i.i = shl nsw i64 -1, %sh_prom.i.i.i
  %sub.i.i.i = xor i64 %notmask.i.i.i, -1
  %or.i.i.i = or i64 %sub.i.i.i, 1
  %rem.i.i.i = urem i64 1073741824, %or.i.i.i
  %arrayidx7.i.i.i = getelementptr inbounds %struct.Node, ptr %9, i64 %rem.i.i.i
  br label %do.body.i.i

do.body.i.i:                                      ; preds = %if.else8.i.i, %if.else.i.i
  %n.0.i.i = phi ptr [ %arrayidx7.i.i.i, %if.else.i.i ], [ %13, %if.else8.i.i ]
  %tt.i7.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1, i32 0, i32 1
  %11 = load i32, ptr %tt.i7.i, align 8
  %cmp2.i.i = icmp eq i32 %11, 3
  br i1 %cmp2.i.i, label %land.lhs.true.i.i, label %if.else8.i.i

land.lhs.true.i.i:                                ; preds = %do.body.i.i
  %i_key.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1
  %12 = load double, ptr %i_key.i.i, align 8
  %cmp5.i.i = fcmp oeq double %12, 2.000000e+00
  br i1 %cmp5.i.i, label %lua_rawgeti.exit, label %if.else8.i.i

if.else8.i.i:                                     ; preds = %land.lhs.true.i.i, %do.body.i.i
  %next.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1, i32 0, i32 2
  %13 = load ptr, ptr %next.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %13, null
  br i1 %tobool.not.i.i, label %lua_rawgeti.exit, label %do.body.i.i, !llvm.loop !7

lua_rawgeti.exit:                                 ; preds = %land.lhs.true.i.i, %if.else8.i.i, %if.then.i9.i
  %retval.0.i8.i = phi ptr [ %arrayidx.i11.i, %if.then.i9.i ], [ @luaO_nilobject_, %if.else8.i.i ], [ %n.0.i.i, %land.lhs.true.i.i ]
  %14 = load i64, ptr %retval.0.i8.i, align 8
  store i64 %14, ptr %1, align 8
  %tt.i5 = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i8.i, i64 0, i32 1
  %15 = load i32, ptr %tt.i5, align 8
  %tt4.i = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 0, i32 1
  store i32 %15, ptr %tt4.i, align 8
  %16 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %16, i64 1
  store ptr %incdec.ptr.i, ptr %top.i.i, align 8
  br label %if.end

if.end:                                           ; preds = %lua_rawgeti.exit, %lua_type.exit
  %call.i = tail call fastcc ptr @luaL_checkudata(ptr noundef nonnull %L)
  %17 = load ptr, ptr %call.i, align 8
  %cmp.i6 = icmp eq ptr %17, null
  br i1 %cmp.i6, label %if.then.i, label %tofile.exit

if.then.i:                                        ; preds = %if.end
  tail call void (ptr, ptr, ...) @luaL_error(ptr noundef nonnull %L, ptr noundef nonnull @.str.205)
  unreachable

tofile.exit:                                      ; preds = %if.end
  %18 = load ptr, ptr %base.i.i, align 8
  %19 = load ptr, ptr %top.i.i, align 8
  %cmp1.not.i.i.i = icmp ult ptr %18, %19
  %add.ptr.luaO_nilobject_.i.i.i = select i1 %cmp1.not.i.i.i, ptr %18, ptr @luaO_nilobject_
  %tt.i.i7 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i.i, i64 0, i32 1
  %20 = load i32, ptr %tt.i.i7, align 8
  switch i32 %20, label %aux_close.exit [
    i32 6, label %sw.bb.i.i
    i32 7, label %sw.bb3.i.i
    i32 8, label %sw.bb10.i.i
  ]

sw.bb.i.i:                                        ; preds = %tofile.exit
  %21 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i.i, align 8
  %env.i.i10 = getelementptr inbounds %struct.CClosure, ptr %21, i64 0, i32 6
  %22 = load ptr, ptr %env.i.i10, align 8
  store ptr %22, ptr %19, align 8
  br label %aux_close.exit

sw.bb3.i.i:                                       ; preds = %tofile.exit
  %23 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i.i, align 8
  %env7.i.i = getelementptr inbounds %struct.anon.1, ptr %23, i64 0, i32 4
  %24 = load ptr, ptr %env7.i.i, align 8
  store ptr %24, ptr %19, align 8
  br label %aux_close.exit

sw.bb10.i.i:                                      ; preds = %tofile.exit
  %25 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i.i, align 8
  %l_gt.i.i = getelementptr inbounds %struct.lua_State, ptr %25, i64 0, i32 22
  %26 = load i64, ptr %l_gt.i.i, align 8
  store i64 %26, ptr %19, align 8
  %tt15.i.i = getelementptr inbounds %struct.lua_State, ptr %25, i64 0, i32 22, i32 1
  %27 = load i32, ptr %tt15.i.i, align 8
  br label %aux_close.exit

aux_close.exit:                                   ; preds = %tofile.exit, %sw.bb.i.i, %sw.bb3.i.i, %sw.bb10.i.i
  %.sink.i.i = phi i32 [ %27, %sw.bb10.i.i ], [ 5, %sw.bb3.i.i ], [ 5, %sw.bb.i.i ], [ 0, %tofile.exit ]
  %tt18.i.i = getelementptr inbounds %struct.lua_TValue, ptr %19, i64 0, i32 1
  store i32 %.sink.i.i, ptr %tt18.i.i, align 8
  %28 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i.i = getelementptr inbounds %struct.lua_TValue, ptr %28, i64 1
  store ptr %incdec.ptr.i.i, ptr %top.i.i, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %key.i.i)
  %call2.i.i = tail call fastcc ptr @luaS_newlstr(ptr noundef nonnull %L, ptr noundef nonnull @.str.206, i64 noundef 7)
  store ptr %call2.i.i, ptr %key.i.i, align 8
  %tt.i4.i = getelementptr inbounds %struct.lua_TValue, ptr %key.i.i, i64 0, i32 1
  store i32 4, ptr %tt.i4.i, align 8
  %29 = load ptr, ptr %top.i.i, align 8
  call fastcc void @luaV_gettable(ptr noundef nonnull %L, ptr noundef nonnull %28, ptr noundef nonnull %key.i.i, ptr noundef %29)
  %30 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i5.i = getelementptr inbounds %struct.lua_TValue, ptr %30, i64 1
  store ptr %incdec.ptr.i5.i, ptr %top.i.i, align 8
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %key.i.i)
  %tt.i6.i = getelementptr %struct.lua_TValue, ptr %30, i64 0, i32 1
  %31 = load i32, ptr %tt.i6.i, align 8
  %cmp.i.i = icmp eq i32 %31, 6
  tail call void @llvm.assume(i1 %cmp.i.i)
  %32 = load ptr, ptr %30, align 8
  %isC.i.i = getelementptr inbounds %struct.CClosure, ptr %32, i64 0, i32 3
  %33 = load i8, ptr %isC.i.i, align 2
  %tobool.not.i.i8 = icmp ne i8 %33, 0
  tail call void @llvm.assume(i1 %tobool.not.i.i8)
  %f.i.i = getelementptr inbounds %struct.CClosure, ptr %32, i64 0, i32 7
  %34 = load ptr, ptr %f.i.i, align 8
  %call1.i9 = tail call i32 %34(ptr noundef nonnull %L) #35
  ret i32 %call1.i9
}

; Function Attrs: nounwind uwtable
define internal i32 @f_flush(ptr noundef %L) #0 {
entry:
  %call.i = tail call fastcc ptr @luaL_checkudata(ptr noundef %L)
  %0 = load ptr, ptr %call.i, align 8
  %cmp.i = icmp eq ptr %0, null
  br i1 %cmp.i, label %if.then.i, label %tofile.exit

if.then.i:                                        ; preds = %entry
  tail call void (ptr, ptr, ...) @luaL_error(ptr noundef %L, ptr noundef nonnull @.str.205)
  unreachable

tofile.exit:                                      ; preds = %entry
  %call1 = tail call i32 @fflush(ptr noundef nonnull %0)
  %cmp.not = icmp eq i32 %call1, 0
  %top.i8.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i8.i, align 8
  br i1 %cmp.not, label %if.then.i3, label %if.else.i

if.then.i3:                                       ; preds = %tofile.exit
  store i32 1, ptr %1, align 8
  br label %pushresult.exit

if.else.i:                                        ; preds = %tofile.exit
  %call.i2 = tail call ptr @__errno_location() #39
  %2 = load i32, ptr %call.i2, align 4
  %tt.i9.i = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 0, i32 1
  store i32 0, ptr %tt.i9.i, align 8
  %3 = load ptr, ptr %top.i8.i, align 8
  %incdec.ptr.i10.i = getelementptr inbounds %struct.lua_TValue, ptr %3, i64 1
  store ptr %incdec.ptr.i10.i, ptr %top.i8.i, align 8
  %call6.i = tail call ptr @strerror(i32 noundef %2) #35
  %call7.i = tail call ptr (ptr, ptr, ...) @lua_pushfstring(ptr noundef nonnull %L, ptr noundef nonnull @.str.113, ptr noundef %call6.i)
  %4 = load ptr, ptr %top.i8.i, align 8
  %conv.i.i = sitofp i32 %2 to double
  store double %conv.i.i, ptr %4, align 8
  br label %pushresult.exit

pushresult.exit:                                  ; preds = %if.then.i3, %if.else.i
  %.sink14.i = phi ptr [ %4, %if.else.i ], [ %1, %if.then.i3 ]
  %.sink.i = phi i32 [ 3, %if.else.i ], [ 1, %if.then.i3 ]
  %tt.i12.i = getelementptr inbounds %struct.lua_TValue, ptr %.sink14.i, i64 0, i32 1
  store i32 %.sink.i, ptr %tt.i12.i, align 8
  %5 = load ptr, ptr %top.i8.i, align 8
  %incdec.ptr.i13.i = getelementptr inbounds %struct.lua_TValue, ptr %5, i64 1
  store ptr %incdec.ptr.i13.i, ptr %top.i8.i, align 8
  ret i32 %.sink.i
}

; Function Attrs: nounwind uwtable
define internal i32 @f_lines(ptr noundef %L) #0 {
entry:
  %call.i = tail call fastcc ptr @luaL_checkudata(ptr noundef %L)
  %0 = load ptr, ptr %call.i, align 8
  %cmp.i = icmp eq ptr %0, null
  br i1 %cmp.i, label %if.then.i, label %tofile.exit

if.then.i:                                        ; preds = %entry
  tail call void (ptr, ptr, ...) @luaL_error(ptr noundef %L, ptr noundef nonnull @.str.205)
  unreachable

tofile.exit:                                      ; preds = %entry
  %base.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %1 = load ptr, ptr %base.i.i.i, align 8
  %top.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %2 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i.i = icmp ult ptr %1, %2
  %add.ptr.luaO_nilobject_.i.i.i = select i1 %cmp1.not.i.i.i, ptr %1, ptr @luaO_nilobject_
  %3 = load i64, ptr %add.ptr.luaO_nilobject_.i.i.i, align 8
  store i64 %3, ptr %2, align 8
  %tt.i.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i.i, i64 0, i32 1
  %4 = load i32, ptr %tt.i.i, align 8
  %tt2.i.i = getelementptr inbounds %struct.lua_TValue, ptr %2, i64 0, i32 1
  store i32 %4, ptr %tt2.i.i, align 8
  %5 = load ptr, ptr %top.i.i.i, align 8
  %incdec.ptr.i.i = getelementptr inbounds %struct.lua_TValue, ptr %5, i64 1
  store ptr %incdec.ptr.i.i, ptr %top.i.i.i, align 8
  store i32 0, ptr %incdec.ptr.i.i, align 8
  %tt.i4.i = getelementptr inbounds %struct.lua_TValue, ptr %5, i64 1, i32 1
  store i32 1, ptr %tt.i4.i, align 8
  %6 = load ptr, ptr %top.i.i.i, align 8
  %incdec.ptr.i5.i = getelementptr inbounds %struct.lua_TValue, ptr %6, i64 1
  store ptr %incdec.ptr.i5.i, ptr %top.i.i.i, align 8
  tail call fastcc void @lua_pushcclosure(ptr noundef %L, ptr noundef nonnull @io_readline, i32 noundef 2)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @f_read(ptr noundef %L) #0 {
entry:
  %call.i = tail call fastcc ptr @luaL_checkudata(ptr noundef %L)
  %0 = load ptr, ptr %call.i, align 8
  %cmp.i = icmp eq ptr %0, null
  br i1 %cmp.i, label %if.then.i, label %tofile.exit

if.then.i:                                        ; preds = %entry
  tail call void (ptr, ptr, ...) @luaL_error(ptr noundef %L, ptr noundef nonnull @.str.205)
  unreachable

tofile.exit:                                      ; preds = %entry
  %call1 = tail call fastcc i32 @g_read(ptr noundef %L, ptr noundef nonnull %0, i32 noundef 2)
  ret i32 %call1
}

; Function Attrs: nounwind uwtable
define internal i32 @f_write(ptr noundef %L) #0 {
entry:
  %call.i = tail call fastcc ptr @luaL_checkudata(ptr noundef %L)
  %0 = load ptr, ptr %call.i, align 8
  %cmp.i = icmp eq ptr %0, null
  br i1 %cmp.i, label %if.then.i, label %tofile.exit

if.then.i:                                        ; preds = %entry
  tail call void (ptr, ptr, ...) @luaL_error(ptr noundef %L, ptr noundef nonnull @.str.205)
  unreachable

tofile.exit:                                      ; preds = %entry
  %call1 = tail call fastcc i32 @g_write(ptr noundef %L, ptr noundef nonnull %0, i32 noundef 2), !range !136
  ret i32 %call1
}

; Function Attrs: nounwind uwtable
define internal i32 @io_gc(ptr noundef %L) #0 {
entry:
  %key.i.i = alloca %struct.lua_TValue, align 8
  %call = tail call fastcc ptr @luaL_checkudata(ptr noundef %L)
  %0 = load ptr, ptr %call, align 8
  %cmp.not = icmp eq ptr %0, null
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %base.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %1 = load ptr, ptr %base.i.i.i, align 8
  %top.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %2 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i.i = icmp ult ptr %1, %2
  %add.ptr.luaO_nilobject_.i.i.i = select i1 %cmp1.not.i.i.i, ptr %1, ptr @luaO_nilobject_
  %tt.i.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i.i, i64 0, i32 1
  %3 = load i32, ptr %tt.i.i, align 8
  switch i32 %3, label %aux_close.exit [
    i32 6, label %sw.bb.i.i
    i32 7, label %sw.bb3.i.i
    i32 8, label %sw.bb10.i.i
  ]

sw.bb.i.i:                                        ; preds = %if.then
  %4 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i.i, align 8
  %env.i.i = getelementptr inbounds %struct.CClosure, ptr %4, i64 0, i32 6
  %5 = load ptr, ptr %env.i.i, align 8
  store ptr %5, ptr %2, align 8
  br label %aux_close.exit

sw.bb3.i.i:                                       ; preds = %if.then
  %6 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i.i, align 8
  %env7.i.i = getelementptr inbounds %struct.anon.1, ptr %6, i64 0, i32 4
  %7 = load ptr, ptr %env7.i.i, align 8
  store ptr %7, ptr %2, align 8
  br label %aux_close.exit

sw.bb10.i.i:                                      ; preds = %if.then
  %8 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i.i, align 8
  %l_gt.i.i = getelementptr inbounds %struct.lua_State, ptr %8, i64 0, i32 22
  %9 = load i64, ptr %l_gt.i.i, align 8
  store i64 %9, ptr %2, align 8
  %tt15.i.i = getelementptr inbounds %struct.lua_State, ptr %8, i64 0, i32 22, i32 1
  %10 = load i32, ptr %tt15.i.i, align 8
  br label %aux_close.exit

aux_close.exit:                                   ; preds = %if.then, %sw.bb.i.i, %sw.bb3.i.i, %sw.bb10.i.i
  %.sink.i.i = phi i32 [ %10, %sw.bb10.i.i ], [ 5, %sw.bb3.i.i ], [ 5, %sw.bb.i.i ], [ 0, %if.then ]
  %tt18.i.i = getelementptr inbounds %struct.lua_TValue, ptr %2, i64 0, i32 1
  store i32 %.sink.i.i, ptr %tt18.i.i, align 8
  %11 = load ptr, ptr %top.i.i.i, align 8
  %incdec.ptr.i.i = getelementptr inbounds %struct.lua_TValue, ptr %11, i64 1
  store ptr %incdec.ptr.i.i, ptr %top.i.i.i, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %key.i.i)
  %call2.i.i = tail call fastcc ptr @luaS_newlstr(ptr noundef nonnull %L, ptr noundef nonnull @.str.206, i64 noundef 7)
  store ptr %call2.i.i, ptr %key.i.i, align 8
  %tt.i4.i = getelementptr inbounds %struct.lua_TValue, ptr %key.i.i, i64 0, i32 1
  store i32 4, ptr %tt.i4.i, align 8
  %12 = load ptr, ptr %top.i.i.i, align 8
  call fastcc void @luaV_gettable(ptr noundef nonnull %L, ptr noundef nonnull %11, ptr noundef nonnull %key.i.i, ptr noundef %12)
  %13 = load ptr, ptr %top.i.i.i, align 8
  %incdec.ptr.i5.i = getelementptr inbounds %struct.lua_TValue, ptr %13, i64 1
  store ptr %incdec.ptr.i5.i, ptr %top.i.i.i, align 8
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %key.i.i)
  %tt.i6.i = getelementptr %struct.lua_TValue, ptr %13, i64 0, i32 1
  %14 = load i32, ptr %tt.i6.i, align 8
  %cmp.i.i = icmp eq i32 %14, 6
  tail call void @llvm.assume(i1 %cmp.i.i)
  %15 = load ptr, ptr %13, align 8
  %isC.i.i = getelementptr inbounds %struct.CClosure, ptr %15, i64 0, i32 3
  %16 = load i8, ptr %isC.i.i, align 2
  %tobool.not.i.i = icmp ne i8 %16, 0
  tail call void @llvm.assume(i1 %tobool.not.i.i)
  %f.i.i = getelementptr inbounds %struct.CClosure, ptr %15, i64 0, i32 7
  %17 = load ptr, ptr %f.i.i, align 8
  %call1.i = tail call i32 %17(ptr noundef nonnull %L) #35
  br label %if.end

if.end:                                           ; preds = %aux_close.exit, %entry
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal fastcc ptr @luaL_checkudata(ptr noundef %L) unnamed_addr #0 {
entry:
  %key.i = alloca %struct.lua_TValue, align 8
  %base.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i, align 8
  %top.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i, align 8
  %cmp1.not.i.i = icmp ult ptr %0, %1
  %add.ptr.luaO_nilobject_.i.i = select i1 %cmp1.not.i.i, ptr %0, ptr @luaO_nilobject_
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i, i64 0, i32 1
  %2 = load i32, ptr %tt.i, align 8
  switch i32 %2, label %if.end7 [
    i32 7, label %sw.bb1.i15
    i32 2, label %lua_touserdata.exit
  ]

lua_touserdata.exit:                              ; preds = %entry
  %3 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i, align 8
  %cmp.not = icmp eq ptr %3, null
  br i1 %cmp.not, label %if.end7, label %sw.default.i

sw.bb1.i15:                                       ; preds = %entry
  %4 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i, align 8
  %add.ptr.i = getelementptr inbounds %union.Udata, ptr %4, i64 1
  %metatable3.i = getelementptr inbounds %struct.anon.1, ptr %4, i64 0, i32 3
  br label %sw.epilog.i

sw.default.i:                                     ; preds = %lua_touserdata.exit
  %l_G.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %5 = load ptr, ptr %l_G.i, align 8
  %idxprom.i = zext nneg i32 %2 to i64
  %arrayidx.i = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 23, i64 %idxprom.i
  br label %sw.epilog.i

sw.epilog.i:                                      ; preds = %sw.default.i, %sw.bb1.i15
  %retval.0.i620 = phi ptr [ %3, %sw.default.i ], [ %add.ptr.i, %sw.bb1.i15 ]
  %mt.0.in.i = phi ptr [ %arrayidx.i, %sw.default.i ], [ %metatable3.i, %sw.bb1.i15 ]
  %mt.0.i = load ptr, ptr %mt.0.in.i, align 8
  %cmp.i = icmp eq ptr %mt.0.i, null
  br i1 %cmp.i, label %if.end7, label %if.then2

if.then2:                                         ; preds = %sw.epilog.i
  store ptr %mt.0.i, ptr %1, align 8
  %tt7.i = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 0, i32 1
  store i32 5, ptr %tt7.i, align 8
  %6 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %6, i64 1
  store ptr %incdec.ptr.i, ptr %top.i.i, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %key.i)
  %l_G.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %7 = load ptr, ptr %l_G.i.i, align 8
  %l_registry.i.i = getelementptr inbounds %struct.global_State, ptr %7, i64 0, i32 20
  %call2.i = tail call fastcc ptr @luaS_newlstr(ptr noundef nonnull %L, ptr noundef nonnull @.str.199, i64 noundef 5)
  store ptr %call2.i, ptr %key.i, align 8
  %tt.i17 = getelementptr inbounds %struct.lua_TValue, ptr %key.i, i64 0, i32 1
  store i32 4, ptr %tt.i17, align 8
  %8 = load ptr, ptr %top.i.i, align 8
  call fastcc void @luaV_gettable(ptr noundef nonnull %L, ptr noundef nonnull %l_registry.i.i, ptr noundef nonnull %key.i, ptr noundef %8)
  %9 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i18 = getelementptr inbounds %struct.lua_TValue, ptr %9, i64 1
  store ptr %incdec.ptr.i18, ptr %top.i.i, align 8
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %key.i)
  %add.ptr8.i34.i = getelementptr %struct.lua_TValue, ptr %9, i64 -1
  %cmp.i19 = icmp eq ptr %9, @luaO_nilobject_
  %cmp2.i = icmp eq ptr %add.ptr8.i34.i, @luaO_nilobject_
  %or.cond.i = or i1 %cmp.i19, %cmp2.i
  br i1 %or.cond.i, label %if.end7, label %cond.false.i

cond.false.i:                                     ; preds = %if.then2
  %tt.i42.i = getelementptr inbounds %struct.lua_TValue, ptr %9, i64 0, i32 1
  %10 = load i32, ptr %tt.i42.i, align 8
  %tt1.i.i = getelementptr %struct.lua_TValue, ptr %9, i64 -1, i32 1
  %11 = load i32, ptr %tt1.i.i, align 8
  %cmp.not.i.i = icmp eq i32 %10, %11
  br i1 %cmp.not.i.i, label %if.else.i.i, label %if.end7

if.else.i.i:                                      ; preds = %cond.false.i
  switch i32 %10, label %sw.default.i44.i [
    i32 0, label %if.then5
    i32 3, label %lua_rawequal.exit
    i32 1, label %sw.bb6.i.i
    i32 2, label %sw.bb11.i.i
  ]

sw.bb6.i.i:                                       ; preds = %if.else.i.i
  %12 = load i32, ptr %9, align 8
  %13 = load i32, ptr %add.ptr8.i34.i, align 8
  %cmp9.i.i = icmp eq i32 %12, %13
  br i1 %cmp9.i.i, label %if.then5, label %if.end7

sw.bb11.i.i:                                      ; preds = %if.else.i.i
  %14 = load ptr, ptr %9, align 8
  %15 = load ptr, ptr %add.ptr8.i34.i, align 8
  %cmp14.i.i = icmp eq ptr %14, %15
  br i1 %cmp14.i.i, label %if.then5, label %if.end7

sw.default.i44.i:                                 ; preds = %if.else.i.i
  %16 = load ptr, ptr %9, align 8
  %17 = load ptr, ptr %add.ptr8.i34.i, align 8
  %cmp18.i.i = icmp eq ptr %16, %17
  br i1 %cmp18.i.i, label %if.then5, label %if.end7

lua_rawequal.exit:                                ; preds = %if.else.i.i
  %18 = load double, ptr %9, align 8
  %19 = load double, ptr %add.ptr8.i34.i, align 8
  %cmp5.i.i = fcmp oeq double %18, %19
  br i1 %cmp5.i.i, label %if.then5, label %if.end7

if.then5:                                         ; preds = %sw.bb6.i.i, %sw.bb11.i.i, %sw.default.i44.i, %if.else.i.i, %lua_rawequal.exit
  store ptr %add.ptr8.i34.i, ptr %top.i.i, align 8
  ret ptr %retval.0.i620

if.end7:                                          ; preds = %sw.bb6.i.i, %sw.bb11.i.i, %sw.default.i44.i, %cond.false.i, %if.then2, %sw.epilog.i, %entry, %lua_rawequal.exit, %lua_touserdata.exit
  %20 = phi ptr [ %incdec.ptr.i18, %cond.false.i ], [ %incdec.ptr.i18, %if.then2 ], [ %1, %sw.epilog.i ], [ %1, %entry ], [ %incdec.ptr.i18, %lua_rawequal.exit ], [ %1, %lua_touserdata.exit ], [ %incdec.ptr.i18, %sw.default.i44.i ], [ %incdec.ptr.i18, %sw.bb11.i.i ], [ %incdec.ptr.i18, %sw.bb6.i.i ]
  %21 = load ptr, ptr %base.i.i, align 8
  %cmp1.not.i.i.i = icmp uge ptr %21, %20
  %cmp.i.i = icmp eq ptr %21, @luaO_nilobject_
  %or.cond = or i1 %cmp.i.i, %cmp1.not.i.i.i
  br i1 %or.cond, label %lua_typename.exit.i, label %lua_type.exit.i

lua_type.exit.i:                                  ; preds = %if.end7
  %tt.i.i = getelementptr inbounds %struct.lua_TValue, ptr %21, i64 0, i32 1
  %22 = load i32, ptr %tt.i.i, align 8
  %cmp.i5.i = icmp eq i32 %22, -1
  br i1 %cmp.i5.i, label %lua_typename.exit.i, label %cond.false.i6.i

cond.false.i6.i:                                  ; preds = %lua_type.exit.i
  %idxprom.i.i = sext i32 %22 to i64
  %arrayidx.i.i = getelementptr inbounds [11 x ptr], ptr @luaT_typenames, i64 0, i64 %idxprom.i.i
  %23 = load ptr, ptr %arrayidx.i.i, align 8
  br label %lua_typename.exit.i

lua_typename.exit.i:                              ; preds = %cond.false.i6.i, %lua_type.exit.i, %if.end7
  %cond.i7.i = phi ptr [ %23, %cond.false.i6.i ], [ @.str.131, %lua_type.exit.i ], [ @.str.131, %if.end7 ]
  %call2.i22 = tail call ptr (ptr, ptr, ...) @lua_pushfstring(ptr noundef nonnull %L, ptr noundef nonnull @.str.130, ptr noundef nonnull @.str.199, ptr noundef %cond.i7.i)
  tail call fastcc void @luaL_argerror(ptr noundef nonnull %L, i32 noundef 1, ptr noundef %call2.i22)
  unreachable
}

; Function Attrs: nofree nounwind
declare noundef i32 @fflush(ptr nocapture noundef) local_unnamed_addr #1

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
declare ptr @__errno_location() local_unnamed_addr #17

; Function Attrs: nounwind
declare ptr @strerror(i32 noundef) local_unnamed_addr #23

; Function Attrs: nounwind uwtable
define internal i32 @io_readline(ptr noundef %L) #0 {
entry:
  %key.i.i = alloca %struct.lua_TValue, align 8
  %ci17.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %0 = load ptr, ptr %ci17.i.i, align 8
  %func18.i.i = getelementptr inbounds %struct.CallInfo, ptr %0, i64 0, i32 1
  %1 = load ptr, ptr %func18.i.i, align 8
  %2 = load ptr, ptr %1, align 8
  %nupvalues.i.i = getelementptr inbounds %struct.CClosure, ptr %2, i64 0, i32 4
  %3 = load i8, ptr %nupvalues.i.i, align 1
  %cmp21.not.i.i = icmp eq i8 %3, 0
  %arrayidx.i.i = getelementptr inbounds %struct.CClosure, ptr %2, i64 0, i32 8, i64 0
  %cond.i.i = select i1 %cmp21.not.i.i, ptr @luaO_nilobject_, ptr %arrayidx.i.i
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %cond.i.i, i64 0, i32 1
  %4 = load i32, ptr %tt.i, align 8
  %switch = icmp eq i32 %4, 7
  %5 = load ptr, ptr %cond.i.i, align 8
  %retval.0.i.idx = zext i1 %switch to i64
  %retval.0.i = getelementptr inbounds %union.Udata, ptr %5, i64 %retval.0.i.idx
  %6 = load ptr, ptr %retval.0.i, align 8
  %cmp = icmp eq ptr %6, null
  br i1 %cmp, label %if.then, label %entry.split

entry.split:                                      ; preds = %entry
  %call210 = tail call fastcc i32 @read_line(ptr noundef nonnull %L, ptr noundef nonnull %6), !range !23
  %call3 = tail call i32 @ferror(ptr noundef nonnull %6) #35
  %tobool.not = icmp eq i32 %call3, 0
  br i1 %tobool.not, label %if.end8, label %if.then4

if.then:                                          ; preds = %entry
  tail call void (ptr, ptr, ...) @luaL_error(ptr noundef nonnull %L, ptr noundef nonnull @.str.208)
  unreachable

if.then4:                                         ; preds = %entry.split
  %call5 = tail call ptr @__errno_location() #39
  %7 = load i32, ptr %call5, align 4
  %call6 = tail call ptr @strerror(i32 noundef %7) #35
  tail call void (ptr, ptr, ...) @luaL_error(ptr noundef nonnull %L, ptr noundef nonnull @.str.113, ptr noundef %call6)
  unreachable

if.end8:                                          ; preds = %entry.split
  %tobool9.not = icmp eq i32 %call210, 0
  br i1 %tobool9.not, label %if.else, label %return

if.else:                                          ; preds = %if.end8
  %8 = load ptr, ptr %ci17.i.i, align 8
  %func18.i.i13 = getelementptr inbounds %struct.CallInfo, ptr %8, i64 0, i32 1
  %9 = load ptr, ptr %func18.i.i13, align 8
  %10 = load ptr, ptr %9, align 8
  %nupvalues.i.i14 = getelementptr inbounds %struct.CClosure, ptr %10, i64 0, i32 4
  %11 = load i8, ptr %nupvalues.i.i14, align 1
  %cmp21.not.i.i16 = icmp ult i8 %11, 2
  %arrayidx.i.i17 = getelementptr inbounds %struct.CClosure, ptr %10, i64 0, i32 8, i64 1
  %cond.i.i18 = select i1 %cmp21.not.i.i16, ptr @luaO_nilobject_, ptr %arrayidx.i.i17
  %tt.i19 = getelementptr inbounds %struct.lua_TValue, ptr %cond.i.i18, i64 0, i32 1
  %12 = load i32, ptr %tt.i19, align 8
  switch i32 %12, label %if.then13 [
    i32 0, label %return
    i32 1, label %lua_toboolean.exit
  ]

lua_toboolean.exit:                               ; preds = %if.else
  %13 = load i32, ptr %cond.i.i18, align 8
  %cmp3.i.not = icmp eq i32 %13, 0
  br i1 %cmp3.i.not, label %return, label %if.then13

if.then13:                                        ; preds = %if.else, %lua_toboolean.exit
  %top.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %base.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %14 = load ptr, ptr %top.i, align 8
  %15 = load ptr, ptr %base.i, align 8
  %cmp111.i = icmp ult ptr %14, %15
  br i1 %cmp111.i, label %while.body.i, label %lua_settop.exit

while.body.i:                                     ; preds = %if.then13, %while.body.i
  %16 = phi ptr [ %17, %while.body.i ], [ %14, %if.then13 ]
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %16, i64 1
  store ptr %incdec.ptr.i, ptr %top.i, align 8
  %tt.i20 = getelementptr inbounds %struct.lua_TValue, ptr %16, i64 0, i32 1
  store i32 0, ptr %tt.i20, align 8
  %17 = load ptr, ptr %top.i, align 8
  %18 = load ptr, ptr %base.i, align 8
  %cmp1.i = icmp ult ptr %17, %18
  br i1 %cmp1.i, label %while.body.i, label %lua_settop.exit.loopexit, !llvm.loop !13

lua_settop.exit.loopexit:                         ; preds = %while.body.i
  %.pre = load ptr, ptr %ci17.i.i, align 8
  br label %lua_settop.exit

lua_settop.exit:                                  ; preds = %lua_settop.exit.loopexit, %if.then13
  %19 = phi ptr [ %8, %if.then13 ], [ %.pre, %lua_settop.exit.loopexit ]
  %add.ptr9.sink.i = phi ptr [ %15, %if.then13 ], [ %18, %lua_settop.exit.loopexit ]
  store ptr %add.ptr9.sink.i, ptr %top.i, align 8
  %func18.i.i22 = getelementptr inbounds %struct.CallInfo, ptr %19, i64 0, i32 1
  %20 = load ptr, ptr %func18.i.i22, align 8
  %21 = load ptr, ptr %20, align 8
  %nupvalues.i.i23 = getelementptr inbounds %struct.CClosure, ptr %21, i64 0, i32 4
  %22 = load i8, ptr %nupvalues.i.i23, align 1
  %cmp21.not.i.i25 = icmp eq i8 %22, 0
  %arrayidx.i.i26 = getelementptr inbounds %struct.CClosure, ptr %21, i64 0, i32 8, i64 0
  %cond.i.i27 = select i1 %cmp21.not.i.i25, ptr @luaO_nilobject_, ptr %arrayidx.i.i26
  %23 = load i64, ptr %cond.i.i27, align 8
  store i64 %23, ptr %add.ptr9.sink.i, align 8
  %tt.i29 = getelementptr inbounds %struct.lua_TValue, ptr %cond.i.i27, i64 0, i32 1
  %24 = load i32, ptr %tt.i29, align 8
  %tt2.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr9.sink.i, i64 0, i32 1
  store i32 %24, ptr %tt2.i, align 8
  %25 = load ptr, ptr %top.i, align 8
  %incdec.ptr.i30 = getelementptr inbounds %struct.lua_TValue, ptr %25, i64 1
  store ptr %incdec.ptr.i30, ptr %top.i, align 8
  %26 = load ptr, ptr %base.i, align 8
  %cmp1.not.i.i.i = icmp ult ptr %26, %incdec.ptr.i30
  %add.ptr.luaO_nilobject_.i.i.i = select i1 %cmp1.not.i.i.i, ptr %26, ptr @luaO_nilobject_
  %tt.i.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i.i, i64 0, i32 1
  %27 = load i32, ptr %tt.i.i, align 8
  switch i32 %27, label %aux_close.exit [
    i32 6, label %sw.bb.i.i
    i32 7, label %sw.bb3.i.i
    i32 8, label %sw.bb10.i.i
  ]

sw.bb.i.i:                                        ; preds = %lua_settop.exit
  %28 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i.i, align 8
  %env.i.i = getelementptr inbounds %struct.CClosure, ptr %28, i64 0, i32 6
  %29 = load ptr, ptr %env.i.i, align 8
  store ptr %29, ptr %incdec.ptr.i30, align 8
  br label %aux_close.exit

sw.bb3.i.i:                                       ; preds = %lua_settop.exit
  %30 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i.i, align 8
  %env7.i.i = getelementptr inbounds %struct.anon.1, ptr %30, i64 0, i32 4
  %31 = load ptr, ptr %env7.i.i, align 8
  store ptr %31, ptr %incdec.ptr.i30, align 8
  br label %aux_close.exit

sw.bb10.i.i:                                      ; preds = %lua_settop.exit
  %32 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i.i, align 8
  %l_gt.i.i = getelementptr inbounds %struct.lua_State, ptr %32, i64 0, i32 22
  %33 = load i64, ptr %l_gt.i.i, align 8
  store i64 %33, ptr %incdec.ptr.i30, align 8
  %tt15.i.i = getelementptr inbounds %struct.lua_State, ptr %32, i64 0, i32 22, i32 1
  %34 = load i32, ptr %tt15.i.i, align 8
  br label %aux_close.exit

aux_close.exit:                                   ; preds = %lua_settop.exit, %sw.bb.i.i, %sw.bb3.i.i, %sw.bb10.i.i
  %.sink.i.i = phi i32 [ %34, %sw.bb10.i.i ], [ 5, %sw.bb3.i.i ], [ 5, %sw.bb.i.i ], [ 0, %lua_settop.exit ]
  %tt18.i.i = getelementptr inbounds %struct.lua_TValue, ptr %25, i64 1, i32 1
  store i32 %.sink.i.i, ptr %tt18.i.i, align 8
  %35 = load ptr, ptr %top.i, align 8
  %incdec.ptr.i.i = getelementptr inbounds %struct.lua_TValue, ptr %35, i64 1
  store ptr %incdec.ptr.i.i, ptr %top.i, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %key.i.i)
  %call2.i.i = tail call fastcc ptr @luaS_newlstr(ptr noundef nonnull %L, ptr noundef nonnull @.str.206, i64 noundef 7)
  store ptr %call2.i.i, ptr %key.i.i, align 8
  %tt.i4.i = getelementptr inbounds %struct.lua_TValue, ptr %key.i.i, i64 0, i32 1
  store i32 4, ptr %tt.i4.i, align 8
  %36 = load ptr, ptr %top.i, align 8
  call fastcc void @luaV_gettable(ptr noundef nonnull %L, ptr noundef nonnull %35, ptr noundef nonnull %key.i.i, ptr noundef %36)
  %37 = load ptr, ptr %top.i, align 8
  %incdec.ptr.i5.i = getelementptr inbounds %struct.lua_TValue, ptr %37, i64 1
  store ptr %incdec.ptr.i5.i, ptr %top.i, align 8
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %key.i.i)
  %tt.i6.i = getelementptr %struct.lua_TValue, ptr %37, i64 0, i32 1
  %38 = load i32, ptr %tt.i6.i, align 8
  %cmp.i.i = icmp eq i32 %38, 6
  tail call void @llvm.assume(i1 %cmp.i.i)
  %39 = load ptr, ptr %37, align 8
  %isC.i.i = getelementptr inbounds %struct.CClosure, ptr %39, i64 0, i32 3
  %40 = load i8, ptr %isC.i.i, align 2
  %tobool.not.i.i = icmp ne i8 %40, 0
  tail call void @llvm.assume(i1 %tobool.not.i.i)
  %f.i.i = getelementptr inbounds %struct.CClosure, ptr %39, i64 0, i32 7
  %41 = load ptr, ptr %f.i.i, align 8
  %call1.i = tail call i32 %41(ptr noundef nonnull %L) #35
  br label %return

return:                                           ; preds = %if.else, %lua_toboolean.exit, %aux_close.exit, %if.end8
  %retval.0 = phi i32 [ 1, %if.end8 ], [ 0, %aux_close.exit ], [ 0, %lua_toboolean.exit ], [ %12, %if.else ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @read_line(ptr noundef %L, ptr nocapture noundef %f) unnamed_addr #0 {
entry:
  %s.i.i = alloca [32 x i8], align 16
  %b = alloca %struct.luaL_Buffer, align 8
  %L1.i = getelementptr inbounds %struct.luaL_Buffer, ptr %b, i64 0, i32 2
  store ptr %L, ptr %L1.i, align 8
  %buffer.i = getelementptr inbounds %struct.luaL_Buffer, ptr %b, i64 0, i32 3
  store ptr %buffer.i, ptr %b, align 8
  %lvl.i = getelementptr inbounds %struct.luaL_Buffer, ptr %b, i64 0, i32 1
  store i32 0, ptr %lvl.i, align 8
  br label %for.cond

for.cond:                                         ; preds = %if.then10, %entry
  %call.i = call fastcc i32 @emptybuffer(ptr noundef nonnull %b), !range !23
  %tobool.not.i = icmp eq i32 %call.i, 0
  br i1 %tobool.not.i, label %luaL_prepbuffer.exit, label %if.then.i

if.then.i:                                        ; preds = %for.cond
  call fastcc void @adjuststack(ptr noundef nonnull %b)
  br label %luaL_prepbuffer.exit

luaL_prepbuffer.exit:                             ; preds = %for.cond, %if.then.i
  %call1 = call ptr @fgets(ptr noundef nonnull %buffer.i, i32 noundef 8192, ptr noundef %f)
  %cmp = icmp eq ptr %call1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %luaL_prepbuffer.exit
  %call.i8 = call fastcc i32 @emptybuffer(ptr noundef nonnull %b), !range !23
  %0 = load ptr, ptr %L1.i, align 8
  %1 = load i32, ptr %lvl.i, align 8
  call fastcc void @lua_concat(ptr noundef %0, i32 noundef %1)
  store i32 1, ptr %lvl.i, align 8
  %top6.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %2 = load ptr, ptr %top6.i.i, align 8
  %add.ptr8.i.i = getelementptr inbounds %struct.lua_TValue, ptr %2, i64 -1
  %tt.i = getelementptr %struct.lua_TValue, ptr %2, i64 -1, i32 1
  %3 = load i32, ptr %tt.i, align 8
  switch i32 %3, label %lua_objlen.exit [
    i32 4, label %sw.bb.i
    i32 7, label %sw.bb1.i
    i32 5, label %sw.bb4.i
    i32 3, label %cond.true.i
  ]

sw.bb.i:                                          ; preds = %if.then
  %4 = load ptr, ptr %add.ptr8.i.i, align 8
  %len.i = getelementptr inbounds %struct.anon.0, ptr %4, i64 0, i32 5
  %5 = load i64, ptr %len.i, align 8
  br label %lua_objlen.exit

sw.bb1.i:                                         ; preds = %if.then
  %6 = load ptr, ptr %add.ptr8.i.i, align 8
  %len3.i = getelementptr inbounds %struct.anon.1, ptr %6, i64 0, i32 5
  %7 = load i64, ptr %len3.i, align 8
  br label %lua_objlen.exit

sw.bb4.i:                                         ; preds = %if.then
  %8 = load ptr, ptr %add.ptr8.i.i, align 8
  %call6.i = call fastcc i32 @luaH_getn(ptr noundef %8)
  %conv.i = sext i32 %call6.i to i64
  br label %lua_objlen.exit

cond.true.i:                                      ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %s.i.i)
  %9 = load double, ptr %add.ptr8.i.i, align 8
  %call.i.i = call i32 (ptr, ptr, ...) @sprintf(ptr noundef nonnull dereferenceable(1) %s.i.i, ptr noundef nonnull dereferenceable(1) @.str.16, double noundef %9) #35
  %call3.i.i = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %s.i.i) #34
  %call4.i.i = call fastcc ptr @luaS_newlstr(ptr noundef nonnull %L, ptr noundef nonnull %s.i.i, i64 noundef %call3.i.i)
  store ptr %call4.i.i, ptr %add.ptr8.i.i, align 8
  store i32 4, ptr %tt.i, align 8
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %s.i.i)
  %len10.i = getelementptr inbounds %struct.anon.0, ptr %call4.i.i, i64 0, i32 5
  %10 = load i64, ptr %len10.i, align 8
  br label %lua_objlen.exit

lua_objlen.exit:                                  ; preds = %if.then, %sw.bb.i, %sw.bb1.i, %sw.bb4.i, %cond.true.i
  %retval.0.i = phi i64 [ %conv.i, %sw.bb4.i ], [ %7, %sw.bb1.i ], [ %5, %sw.bb.i ], [ %10, %cond.true.i ], [ 0, %if.then ]
  %cmp3 = icmp ne i64 %retval.0.i, 0
  %conv = zext i1 %cmp3 to i32
  br label %return

if.end:                                           ; preds = %luaL_prepbuffer.exit
  %call4 = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %buffer.i) #34
  %cmp5 = icmp eq i64 %call4, 0
  br i1 %cmp5, label %if.then10, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %sub = add i64 %call4, -1
  %arrayidx = getelementptr inbounds i8, ptr %buffer.i, i64 %sub
  %11 = load i8, ptr %arrayidx, align 1
  %cmp8.not = icmp eq i8 %11, 10
  br i1 %cmp8.not, label %if.else, label %if.then10

if.then10:                                        ; preds = %lor.lhs.false, %if.end
  %12 = load ptr, ptr %b, align 8
  %add.ptr = getelementptr inbounds i8, ptr %12, i64 %call4
  store ptr %add.ptr, ptr %b, align 8
  br label %for.cond

if.else:                                          ; preds = %lor.lhs.false
  %13 = load ptr, ptr %b, align 8
  %add.ptr14 = getelementptr inbounds i8, ptr %13, i64 %sub
  store ptr %add.ptr14, ptr %b, align 8
  %call.i10 = call fastcc i32 @emptybuffer(ptr noundef nonnull %b), !range !23
  %14 = load ptr, ptr %L1.i, align 8
  %15 = load i32, ptr %lvl.i, align 8
  call fastcc void @lua_concat(ptr noundef %14, i32 noundef %15)
  br label %return

return:                                           ; preds = %if.else, %lua_objlen.exit
  %retval.0 = phi i32 [ %conv, %lua_objlen.exit ], [ 1, %if.else ]
  ret i32 %retval.0
}

; Function Attrs: nofree nounwind memory(read)
declare noundef i32 @ferror(ptr nocapture noundef) local_unnamed_addr #24

; Function Attrs: nofree nounwind
declare noundef ptr @fgets(ptr noundef, i32 noundef, ptr nocapture noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define internal fastcc i32 @g_read(ptr noundef %L, ptr noundef %f, i32 noundef %first) unnamed_addr #0 {
entry:
  %d.i = alloca double, align 8
  %0 = getelementptr i8, ptr %L, i64 16
  %L.val = load ptr, ptr %0, align 8
  %1 = getelementptr i8, ptr %L, i64 24
  %L.val37 = load ptr, ptr %1, align 8
  %sub.ptr.lhs.cast.i = ptrtoint ptr %L.val to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %L.val37 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %sub.ptr.div.i = lshr exact i64 %sub.ptr.sub.i, 4
  %conv.i = trunc i64 %sub.ptr.div.i to i32
  tail call void @clearerr(ptr noundef %f) #35
  %cmp = icmp eq i32 %conv.i, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call1 = tail call fastcc i32 @read_line(ptr noundef nonnull %L, ptr noundef %f), !range !23
  %add = add nuw nsw i32 %first, 1
  br label %if.end26

if.else:                                          ; preds = %entry
  %add2 = add nsw i32 %conv.i, 19
  %cmp.i.i = icmp sgt i32 %conv.i, 7981
  br i1 %cmp.i.i, label %if.then.i, label %lor.lhs.false.i.i

lor.lhs.false.i.i:                                ; preds = %if.else
  %2 = load ptr, ptr %0, align 8
  %3 = load ptr, ptr %1, align 8
  %sub.ptr.lhs.cast.i.i = ptrtoint ptr %2 to i64
  %sub.ptr.rhs.cast.i.i = ptrtoint ptr %3 to i64
  %sub.ptr.sub.i.i = sub i64 %sub.ptr.lhs.cast.i.i, %sub.ptr.rhs.cast.i.i
  %sub.ptr.div.i.i = ashr exact i64 %sub.ptr.sub.i.i, 4
  %conv.i.i = sext i32 %add2 to i64
  %add.i.i = add nsw i64 %sub.ptr.div.i.i, %conv.i.i
  %cmp1.i.i = icmp sgt i64 %add.i.i, 8000
  br i1 %cmp1.i.i, label %if.then.i, label %if.else.i.i

if.else.i.i:                                      ; preds = %lor.lhs.false.i.i
  %cmp3.i.i = icmp sgt i32 %conv.i, -19
  br i1 %cmp3.i.i, label %if.then5.i.i, label %luaL_checkstack.exit

if.then5.i.i:                                     ; preds = %if.else.i.i
  %stack_last.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 9
  %4 = load ptr, ptr %stack_last.i.i, align 8
  %sub.ptr.lhs.cast7.i.i = ptrtoint ptr %4 to i64
  %sub.ptr.sub9.i.i = sub i64 %sub.ptr.lhs.cast7.i.i, %sub.ptr.lhs.cast.i.i
  %mul.i.i = shl nuw nsw i32 %add2, 4
  %conv10.i.i = zext nneg i32 %mul.i.i to i64
  %cmp11.not.i.i = icmp sgt i64 %sub.ptr.sub9.i.i, %conv10.i.i
  br i1 %cmp11.not.i.i, label %if.end.i.i, label %if.then13.i.i

if.then13.i.i:                                    ; preds = %if.then5.i.i
  %stacksize.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 13
  %5 = load i32, ptr %stacksize.i.i.i, align 8
  %cmp.not.i.i.i = icmp slt i32 %5, %add2
  %add.i.i.i = add nsw i32 %5, %add2
  %mul.i.i.i = shl nsw i32 %5, 1
  %add.sink.i.i.i = select i1 %cmp.not.i.i.i, i32 %add.i.i.i, i32 %mul.i.i.i
  tail call fastcc void @luaD_reallocstack(ptr noundef nonnull %L, i32 noundef %add.sink.i.i.i)
  %.pre.i.i = load ptr, ptr %0, align 8
  br label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then13.i.i, %if.then5.i.i
  %6 = phi ptr [ %2, %if.then5.i.i ], [ %.pre.i.i, %if.then13.i.i ]
  %ci.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %7 = load ptr, ptr %ci.i.i, align 8
  %top15.i.i = getelementptr inbounds %struct.CallInfo, ptr %7, i64 0, i32 2
  %8 = load ptr, ptr %top15.i.i, align 8
  %add.ptr.i.i = getelementptr inbounds %struct.lua_TValue, ptr %6, i64 %conv.i.i
  %cmp17.i.i = icmp ult ptr %8, %add.ptr.i.i
  br i1 %cmp17.i.i, label %if.then19.i.i, label %luaL_checkstack.exit

if.then19.i.i:                                    ; preds = %if.end.i.i
  store ptr %add.ptr.i.i, ptr %top15.i.i, align 8
  br label %luaL_checkstack.exit

if.then.i:                                        ; preds = %lor.lhs.false.i.i, %if.else
  tail call void (ptr, ptr, ...) @luaL_error(ptr noundef nonnull %L, ptr noundef nonnull @.str.193, ptr noundef nonnull @.str.209)
  unreachable

luaL_checkstack.exit:                             ; preds = %if.else.i.i, %if.end.i.i, %if.then19.i.i
  %dec71 = add nsw i32 %conv.i, -2
  %l_gt.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 22
  %ci.i.i39 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %env.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23
  %tt.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23, i32 1
  %l_G.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %9 = sext i32 %first to i64
  br label %for.body

for.body:                                         ; preds = %luaL_checkstack.exit, %for.inc
  %indvars.iv = phi i64 [ %9, %luaL_checkstack.exit ], [ %indvars.iv.next, %for.inc ]
  %dec73 = phi i32 [ %dec71, %luaL_checkstack.exit ], [ %dec, %for.inc ]
  %cmp.i.i38 = icmp sgt i64 %indvars.iv, 0
  br i1 %cmp.i.i38, label %if.then.i.i, label %if.else3.i.i

if.then.i.i:                                      ; preds = %for.body
  %10 = load ptr, ptr %1, align 8
  %11 = getelementptr %struct.lua_TValue, ptr %10, i64 %indvars.iv
  %add.ptr.i.i43 = getelementptr %struct.lua_TValue, ptr %11, i64 -1
  %12 = load ptr, ptr %0, align 8
  %cmp1.not.i.i = icmp ult ptr %add.ptr.i.i43, %12
  br i1 %cmp1.not.i.i, label %index2adr.exit.i, label %if.else11

if.else3.i.i:                                     ; preds = %for.body
  %cmp4.i.i = icmp sgt i64 %indvars.iv, -10000
  br i1 %cmp4.i.i, label %if.then5.i.i41, label %if.else9.i.i

if.then5.i.i41:                                   ; preds = %if.else3.i.i
  %13 = load ptr, ptr %0, align 8
  %add.ptr8.i.i = getelementptr inbounds %struct.lua_TValue, ptr %13, i64 %indvars.iv
  br label %index2adr.exit.i

if.else9.i.i:                                     ; preds = %if.else3.i.i
  %14 = trunc i64 %indvars.iv to i32
  switch i32 %14, label %sw.default.i.i [
    i32 -10000, label %sw.bb.i.i
    i32 -10001, label %sw.bb10.i.i
    i32 -10002, label %index2adr.exit.i
  ]

sw.bb.i.i:                                        ; preds = %if.else9.i.i
  %15 = load ptr, ptr %l_G.i.i, align 8
  %l_registry.i.i = getelementptr inbounds %struct.global_State, ptr %15, i64 0, i32 20
  br label %index2adr.exit.i

sw.bb10.i.i:                                      ; preds = %if.else9.i.i
  %16 = load ptr, ptr %ci.i.i39, align 8
  %func11.i.i = getelementptr inbounds %struct.CallInfo, ptr %16, i64 0, i32 1
  %17 = load ptr, ptr %func11.i.i, align 8
  %18 = load ptr, ptr %17, align 8
  %env12.i.i = getelementptr inbounds %struct.CClosure, ptr %18, i64 0, i32 6
  %19 = load ptr, ptr %env12.i.i, align 8
  store ptr %19, ptr %env.i.i, align 8
  store i32 5, ptr %tt.i.i, align 8
  br label %index2adr.exit.i

sw.default.i.i:                                   ; preds = %if.else9.i.i
  %20 = load ptr, ptr %ci.i.i39, align 8
  %func18.i.i = getelementptr inbounds %struct.CallInfo, ptr %20, i64 0, i32 1
  %21 = load ptr, ptr %func18.i.i, align 8
  %22 = load ptr, ptr %21, align 8
  %nupvalues.i.i = getelementptr inbounds %struct.CClosure, ptr %22, i64 0, i32 4
  %23 = load i8, ptr %nupvalues.i.i, align 1
  %conv.i.i40 = zext i8 %23 to i32
  %24 = trunc i64 %indvars.iv to i32
  %25 = sub i32 -10002, %24
  %cmp21.not.i.i = icmp ugt i32 %25, %conv.i.i40
  %26 = sub nuw nsw i64 -10003, %indvars.iv
  %arrayidx.i.i = getelementptr inbounds %struct.CClosure, ptr %22, i64 0, i32 8, i64 %26
  br i1 %cmp21.not.i.i, label %if.else11, label %index2adr.exit.i

index2adr.exit.i:                                 ; preds = %if.else9.i.i, %sw.default.i.i, %sw.bb10.i.i, %sw.bb.i.i, %if.then5.i.i41, %if.then.i.i
  %retval.0.i.i = phi ptr [ %add.ptr8.i.i, %if.then5.i.i41 ], [ %arrayidx.i.i, %sw.default.i.i ], [ %env.i.i, %sw.bb10.i.i ], [ %l_registry.i.i, %sw.bb.i.i ], [ %add.ptr.i.i43, %if.then.i.i ], [ %l_gt.i.i, %if.else9.i.i ]
  %cmp.i = icmp eq ptr %retval.0.i.i, @luaO_nilobject_
  br i1 %cmp.i, label %if.else11, label %lua_type.exit

lua_type.exit:                                    ; preds = %index2adr.exit.i
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i.i, i64 0, i32 1
  %27 = load i32, ptr %tt.i, align 8
  %cmp5 = icmp eq i32 %27, 3
  br i1 %cmp5, label %if.then6, label %if.else11

if.then6:                                         ; preds = %lua_type.exit
  %28 = trunc i64 %indvars.iv to i32
  %call7 = call fastcc i64 @lua_tointeger(ptr noundef %L, i32 noundef %28)
  %cmp8 = icmp eq i64 %call7, 0
  br i1 %cmp8, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then6
  %call.i = call i32 @getc(ptr noundef %f)
  %call1.i45 = call i32 @ungetc(i32 noundef %call.i, ptr noundef %f)
  %29 = load ptr, ptr %l_G.i.i, align 8
  %totalbytes.i.i = getelementptr inbounds %struct.global_State, ptr %29, i64 0, i32 14
  %30 = load i64, ptr %totalbytes.i.i, align 8
  %GCthreshold.i.i = getelementptr inbounds %struct.global_State, ptr %29, i64 0, i32 13
  %31 = load i64, ptr %GCthreshold.i.i, align 8
  %cmp.not.i.i = icmp ult i64 %30, %31
  br i1 %cmp.not.i.i, label %test_eof.exit, label %if.then.i.i47

if.then.i.i47:                                    ; preds = %cond.true
  %gcstepmul.i.i.i = getelementptr inbounds %struct.global_State, ptr %29, i64 0, i32 18
  %32 = load i32, ptr %gcstepmul.i.i.i, align 4
  %mul.i.i.i48 = mul i32 %32, 10
  %conv.i.i.i = zext i32 %mul.i.i.i48 to i64
  %cmp.i.i.i = icmp eq i32 %mul.i.i.i48, 0
  %spec.store.select.i.i.i = select i1 %cmp.i.i.i, i64 9223372036854775806, i64 %conv.i.i.i
  %sub.i.i.i = sub i64 %30, %31
  %gcdept.i.i.i = getelementptr inbounds %struct.global_State, ptr %29, i64 0, i32 16
  %33 = load i64, ptr %gcdept.i.i.i, align 8
  %add.i.i.i49 = add i64 %sub.i.i.i, %33
  store i64 %add.i.i.i49, ptr %gcdept.i.i.i, align 8
  %gcstate.i.i.i = getelementptr inbounds %struct.global_State, ptr %29, i64 0, i32 4
  br label %do.body.i.i.i

do.body.i.i.i:                                    ; preds = %do.body.i.i.i, %if.then.i.i47
  %lim.0.i.i.i = phi i64 [ %spec.store.select.i.i.i, %if.then.i.i47 ], [ %sub2.i.i.i, %do.body.i.i.i ]
  %call.i.i.i = call fastcc i64 @singlestep(ptr noundef %L)
  %sub2.i.i.i = sub nsw i64 %lim.0.i.i.i, %call.i.i.i
  %34 = load i8, ptr %gcstate.i.i.i, align 1
  %cmp4.i.i.i = icmp ne i8 %34, 0
  %cmp8.i.i.i = icmp sgt i64 %sub2.i.i.i, 0
  %or.cond.i.i.i = select i1 %cmp4.i.i.i, i1 %cmp8.i.i.i, i1 false
  br i1 %or.cond.i.i.i, label %do.body.i.i.i, label %do.end.i.i.i, !llvm.loop !6

do.end.i.i.i:                                     ; preds = %do.body.i.i.i
  br i1 %cmp4.i.i.i, label %if.then14.i.i.i, label %if.else27.i.i.i

if.then14.i.i.i:                                  ; preds = %do.end.i.i.i
  %35 = load i64, ptr %gcdept.i.i.i, align 8
  %cmp16.i.i.i = icmp ult i64 %35, 1024
  br i1 %cmp16.i.i.i, label %if.then18.i.i.i, label %if.else.i.i.i

if.then18.i.i.i:                                  ; preds = %if.then14.i.i.i
  %36 = load i64, ptr %totalbytes.i.i, align 8
  %add20.i.i.i = add i64 %36, 1024
  br label %luaC_step.exit.i.i

if.else.i.i.i:                                    ; preds = %if.then14.i.i.i
  %sub23.i.i.i = add i64 %35, -1024
  store i64 %sub23.i.i.i, ptr %gcdept.i.i.i, align 8
  %37 = load i64, ptr %totalbytes.i.i, align 8
  br label %luaC_step.exit.i.i

if.else27.i.i.i:                                  ; preds = %do.end.i.i.i
  %estimate.i.i.i = getelementptr inbounds %struct.global_State, ptr %29, i64 0, i32 15
  %38 = load i64, ptr %estimate.i.i.i, align 8
  %div.i.i.i = udiv i64 %38, 100
  %gcpause.i.i.i = getelementptr inbounds %struct.global_State, ptr %29, i64 0, i32 17
  %39 = load i32, ptr %gcpause.i.i.i, align 8
  %conv28.i.i.i = sext i32 %39 to i64
  %mul29.i.i.i = mul i64 %div.i.i.i, %conv28.i.i.i
  br label %luaC_step.exit.i.i

luaC_step.exit.i.i:                               ; preds = %if.else27.i.i.i, %if.else.i.i.i, %if.then18.i.i.i
  %add20.sink.i.i.i = phi i64 [ %add20.i.i.i, %if.then18.i.i.i ], [ %37, %if.else.i.i.i ], [ %mul29.i.i.i, %if.else27.i.i.i ]
  store i64 %add20.sink.i.i.i, ptr %GCthreshold.i.i, align 8
  br label %test_eof.exit

test_eof.exit:                                    ; preds = %cond.true, %luaC_step.exit.i.i
  %40 = load ptr, ptr %0, align 8
  %call.i.i = call fastcc ptr @luaS_newlstr(ptr noundef %L, ptr noundef null, i64 noundef 0)
  store ptr %call.i.i, ptr %40, align 8
  %tt.i.i51 = getelementptr inbounds %struct.lua_TValue, ptr %40, i64 0, i32 1
  store i32 4, ptr %tt.i.i51, align 8
  %41 = load ptr, ptr %0, align 8
  %incdec.ptr.i.i = getelementptr inbounds %struct.lua_TValue, ptr %41, i64 1
  store ptr %incdec.ptr.i.i, ptr %0, align 8
  %cmp.i52 = icmp ne i32 %call.i, -1
  %conv.i53 = zext i1 %cmp.i52 to i32
  br label %for.inc

cond.false:                                       ; preds = %if.then6
  %call10 = call fastcc i32 @read_chars(ptr noundef %L, ptr noundef %f, i64 noundef %call7), !range !23
  br label %for.inc

if.else11:                                        ; preds = %sw.default.i.i, %if.then.i.i, %index2adr.exit.i, %lua_type.exit
  %42 = trunc i64 %indvars.iv to i32
  %call12 = call fastcc ptr @lua_tolstring(ptr noundef %L, i32 noundef %42, ptr noundef null)
  %tobool13.not = icmp eq ptr %call12, null
  br i1 %tobool13.not, label %lor.rhs, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.else11
  %43 = load i8, ptr %call12, align 1
  %cmp14 = icmp eq i8 %43, 42
  br i1 %cmp14, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.lhs.true, %if.else11
  call fastcc void @luaL_argerror(ptr noundef %L, i32 noundef %42, ptr noundef nonnull @.str.210)
  unreachable

lor.end:                                          ; preds = %land.lhs.true
  %arrayidx18 = getelementptr inbounds i8, ptr %call12, i64 1
  %44 = load i8, ptr %arrayidx18, align 1
  %conv19 = sext i8 %44 to i32
  switch i32 %conv19, label %sw.default [
    i32 110, label %sw.bb
    i32 108, label %sw.bb21
    i32 97, label %sw.bb23
  ]

sw.bb:                                            ; preds = %lor.end
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %d.i)
  %call.i54 = call i32 (ptr, ptr, ...) @__isoc99_fscanf(ptr noundef %f, ptr noundef nonnull @.str.212, ptr noundef nonnull %d.i) #35
  %cmp.i55 = icmp eq i32 %call.i54, 1
  br i1 %cmp.i55, label %if.then.i56, label %if.else.i

if.then.i56:                                      ; preds = %sw.bb
  %45 = load double, ptr %d.i, align 8
  %46 = load ptr, ptr %0, align 8
  store double %45, ptr %46, align 8
  br label %read_number.exit

if.else.i:                                        ; preds = %sw.bb
  %47 = load ptr, ptr %0, align 8
  br label %read_number.exit

read_number.exit:                                 ; preds = %if.then.i56, %if.else.i
  %.sink6.i = phi ptr [ %47, %if.else.i ], [ %46, %if.then.i56 ]
  %.sink.i = phi i32 [ 0, %if.else.i ], [ 3, %if.then.i56 ]
  %retval.0.i = phi i32 [ 0, %if.else.i ], [ 1, %if.then.i56 ]
  %tt.i3.i = getelementptr inbounds %struct.lua_TValue, ptr %.sink6.i, i64 0, i32 1
  store i32 %.sink.i, ptr %tt.i3.i, align 8
  %48 = load ptr, ptr %0, align 8
  %incdec.ptr.i4.i = getelementptr inbounds %struct.lua_TValue, ptr %48, i64 1
  store ptr %incdec.ptr.i4.i, ptr %0, align 8
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %d.i)
  br label %for.inc

sw.bb21:                                          ; preds = %lor.end
  %call22 = call fastcc i32 @read_line(ptr noundef %L, ptr noundef %f), !range !23
  br label %for.inc

sw.bb23:                                          ; preds = %lor.end
  %call24 = call fastcc i32 @read_chars(ptr noundef %L, ptr noundef %f, i64 noundef -1), !range !23
  br label %for.inc

sw.default:                                       ; preds = %lor.end
  call fastcc void @luaL_argerror(ptr noundef %L, i32 noundef %42, ptr noundef nonnull @.str.211)
  unreachable

for.inc:                                          ; preds = %test_eof.exit, %cond.false, %sw.bb23, %sw.bb21, %read_number.exit
  %success.1 = phi i32 [ 1, %sw.bb23 ], [ %call22, %sw.bb21 ], [ %retval.0.i, %read_number.exit ], [ %conv.i53, %test_eof.exit ], [ %call10, %cond.false ]
  %indvars.iv.next = add nsw i64 %indvars.iv, 1
  %dec = add nsw i32 %dec73, -1
  %tobool = icmp ne i32 %dec73, 0
  %tobool3 = icmp ne i32 %success.1, 0
  %49 = select i1 %tobool, i1 %tobool3, i1 false
  br i1 %49, label %for.body, label %if.end26.loopexit, !llvm.loop !137

if.end26.loopexit:                                ; preds = %for.inc
  %50 = trunc i64 %indvars.iv.next to i32
  br label %if.end26

if.end26:                                         ; preds = %if.end26.loopexit, %if.then
  %success.2 = phi i32 [ %call1, %if.then ], [ %success.1, %if.end26.loopexit ]
  %n.1 = phi i32 [ %add, %if.then ], [ %50, %if.end26.loopexit ]
  %call27 = call i32 @ferror(ptr noundef %f) #35
  %tobool28.not = icmp eq i32 %call27, 0
  br i1 %tobool28.not, label %if.end31, label %if.then29

if.then29:                                        ; preds = %if.end26
  %call.i58 = tail call ptr @__errno_location() #39
  %51 = load i32, ptr %call.i58, align 4
  %52 = load ptr, ptr %0, align 8
  %tt.i9.i = getelementptr inbounds %struct.lua_TValue, ptr %52, i64 0, i32 1
  store i32 0, ptr %tt.i9.i, align 8
  %53 = load ptr, ptr %0, align 8
  %incdec.ptr.i10.i = getelementptr inbounds %struct.lua_TValue, ptr %53, i64 1
  store ptr %incdec.ptr.i10.i, ptr %0, align 8
  %call6.i = call ptr @strerror(i32 noundef %51) #35
  %call7.i = call ptr (ptr, ptr, ...) @lua_pushfstring(ptr noundef nonnull %L, ptr noundef nonnull @.str.113, ptr noundef %call6.i)
  %54 = load ptr, ptr %0, align 8
  %conv.i.i60 = sitofp i32 %51 to double
  store double %conv.i.i60, ptr %54, align 8
  %tt.i12.i = getelementptr inbounds %struct.lua_TValue, ptr %54, i64 0, i32 1
  store i32 3, ptr %tt.i12.i, align 8
  %55 = load ptr, ptr %0, align 8
  %incdec.ptr.i13.i = getelementptr inbounds %struct.lua_TValue, ptr %55, i64 1
  store ptr %incdec.ptr.i13.i, ptr %0, align 8
  br label %return

if.end31:                                         ; preds = %if.end26
  %tobool32.not = icmp eq i32 %success.2, 0
  br i1 %tobool32.not, label %if.then33, label %if.end34

if.then33:                                        ; preds = %if.end31
  %56 = load ptr, ptr %0, align 8
  %add.ptr9.i = getelementptr %struct.lua_TValue, ptr %56, i64 -1
  store ptr %add.ptr9.i, ptr %0, align 8
  %tt.i64 = getelementptr %struct.lua_TValue, ptr %56, i64 -1, i32 1
  store i32 0, ptr %tt.i64, align 8
  %57 = load ptr, ptr %0, align 8
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %57, i64 1
  store ptr %incdec.ptr.i, ptr %0, align 8
  br label %if.end34

if.end34:                                         ; preds = %if.then33, %if.end31
  %sub35 = sub nsw i32 %n.1, %first
  br label %return

return:                                           ; preds = %if.end34, %if.then29
  %retval.0 = phi i32 [ 3, %if.then29 ], [ %sub35, %if.end34 ]
  ret i32 %retval.0
}

; Function Attrs: nofree nounwind
declare void @clearerr(ptr nocapture noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define internal fastcc i32 @read_chars(ptr noundef %L, ptr nocapture noundef %f, i64 noundef %n) unnamed_addr #0 {
entry:
  %s.i.i = alloca [32 x i8], align 16
  %b = alloca %struct.luaL_Buffer, align 8
  %L1.i = getelementptr inbounds %struct.luaL_Buffer, ptr %b, i64 0, i32 2
  store ptr %L, ptr %L1.i, align 8
  %buffer.i = getelementptr inbounds %struct.luaL_Buffer, ptr %b, i64 0, i32 3
  store ptr %buffer.i, ptr %b, align 8
  %lvl.i = getelementptr inbounds %struct.luaL_Buffer, ptr %b, i64 0, i32 1
  store i32 0, ptr %lvl.i, align 8
  br label %do.body

do.body:                                          ; preds = %luaL_prepbuffer.exit, %entry
  %rlen.0 = phi i64 [ 8192, %entry ], [ %spec.select, %luaL_prepbuffer.exit ]
  %n.addr.0 = phi i64 [ %n, %entry ], [ %sub, %luaL_prepbuffer.exit ]
  %call.i = call fastcc i32 @emptybuffer(ptr noundef nonnull %b), !range !23
  %tobool.not.i = icmp eq i32 %call.i, 0
  br i1 %tobool.not.i, label %luaL_prepbuffer.exit, label %if.then.i

if.then.i:                                        ; preds = %do.body
  call fastcc void @adjuststack(ptr noundef nonnull %b)
  br label %luaL_prepbuffer.exit

luaL_prepbuffer.exit:                             ; preds = %do.body, %if.then.i
  %spec.select = call i64 @llvm.umin.i64(i64 %rlen.0, i64 %n.addr.0)
  %call1 = call i64 @fread(ptr noundef nonnull %buffer.i, i64 noundef 1, i64 noundef %spec.select, ptr noundef %f)
  %0 = load ptr, ptr %b, align 8
  %add.ptr = getelementptr inbounds i8, ptr %0, i64 %call1
  store ptr %add.ptr, ptr %b, align 8
  %sub = sub i64 %n.addr.0, %call1
  %cmp3 = icmp ne i64 %sub, 0
  %cmp4 = icmp eq i64 %call1, %spec.select
  %1 = and i1 %cmp4, %cmp3
  br i1 %1, label %do.body, label %do.end, !llvm.loop !138

do.end:                                           ; preds = %luaL_prepbuffer.exit
  %call.i11 = call fastcc i32 @emptybuffer(ptr noundef nonnull %b), !range !23
  %2 = load ptr, ptr %L1.i, align 8
  %3 = load i32, ptr %lvl.i, align 8
  call fastcc void @lua_concat(ptr noundef %2, i32 noundef %3)
  store i32 1, ptr %lvl.i, align 8
  %cmp5 = icmp eq i64 %sub, 0
  br i1 %cmp5, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %do.end
  %top6.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %4 = load ptr, ptr %top6.i.i, align 8
  %add.ptr8.i.i = getelementptr inbounds %struct.lua_TValue, ptr %4, i64 -1
  %tt.i = getelementptr %struct.lua_TValue, ptr %4, i64 -1, i32 1
  %5 = load i32, ptr %tt.i, align 8
  switch i32 %5, label %lua_objlen.exit [
    i32 4, label %sw.bb.i
    i32 7, label %sw.bb1.i
    i32 5, label %sw.bb4.i
    i32 3, label %cond.true.i
  ]

sw.bb.i:                                          ; preds = %lor.rhs
  %6 = load ptr, ptr %add.ptr8.i.i, align 8
  %len.i = getelementptr inbounds %struct.anon.0, ptr %6, i64 0, i32 5
  %7 = load i64, ptr %len.i, align 8
  br label %lua_objlen.exit

sw.bb1.i:                                         ; preds = %lor.rhs
  %8 = load ptr, ptr %add.ptr8.i.i, align 8
  %len3.i = getelementptr inbounds %struct.anon.1, ptr %8, i64 0, i32 5
  %9 = load i64, ptr %len3.i, align 8
  br label %lua_objlen.exit

sw.bb4.i:                                         ; preds = %lor.rhs
  %10 = load ptr, ptr %add.ptr8.i.i, align 8
  %call6.i = call fastcc i32 @luaH_getn(ptr noundef %10)
  %conv.i = sext i32 %call6.i to i64
  br label %lua_objlen.exit

cond.true.i:                                      ; preds = %lor.rhs
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %s.i.i)
  %11 = load double, ptr %add.ptr8.i.i, align 8
  %call.i.i = call i32 (ptr, ptr, ...) @sprintf(ptr noundef nonnull dereferenceable(1) %s.i.i, ptr noundef nonnull dereferenceable(1) @.str.16, double noundef %11) #35
  %call3.i.i = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %s.i.i) #34
  %call4.i.i = call fastcc ptr @luaS_newlstr(ptr noundef nonnull %L, ptr noundef nonnull %s.i.i, i64 noundef %call3.i.i)
  store ptr %call4.i.i, ptr %add.ptr8.i.i, align 8
  store i32 4, ptr %tt.i, align 8
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %s.i.i)
  %len10.i = getelementptr inbounds %struct.anon.0, ptr %call4.i.i, i64 0, i32 5
  %12 = load i64, ptr %len10.i, align 8
  br label %lua_objlen.exit

lua_objlen.exit:                                  ; preds = %lor.rhs, %sw.bb.i, %sw.bb1.i, %sw.bb4.i, %cond.true.i
  %retval.0.i = phi i64 [ %conv.i, %sw.bb4.i ], [ %9, %sw.bb1.i ], [ %7, %sw.bb.i ], [ %12, %cond.true.i ], [ 0, %lor.rhs ]
  %cmp7 = icmp ne i64 %retval.0.i, 0
  %13 = zext i1 %cmp7 to i32
  br label %lor.end

lor.end:                                          ; preds = %lua_objlen.exit, %do.end
  %lor.ext = phi i32 [ 1, %do.end ], [ %13, %lua_objlen.exit ]
  ret i32 %lor.ext
}

; Function Attrs: nofree nounwind
declare noundef i32 @getc(ptr nocapture noundef) local_unnamed_addr #1

; Function Attrs: nofree nounwind
declare noundef i32 @ungetc(i32 noundef, ptr nocapture noundef) local_unnamed_addr #1

; Function Attrs: nofree nounwind
declare noundef i64 @fread(ptr nocapture noundef, i64 noundef, i64 noundef, ptr nocapture noundef) local_unnamed_addr #1

declare i32 @__isoc99_fscanf(ptr noundef, ptr noundef, ...) local_unnamed_addr #25

; Function Attrs: nounwind uwtable
define internal fastcc i32 @g_write(ptr noundef %L, ptr nocapture noundef %f, i32 noundef %arg) unnamed_addr #0 {
entry:
  %l = alloca i64, align 8
  %0 = getelementptr i8, ptr %L, i64 16
  %L.val = load ptr, ptr %0, align 8
  %1 = getelementptr i8, ptr %L, i64 24
  %L.val11 = load ptr, ptr %1, align 8
  %sub.ptr.lhs.cast.i = ptrtoint ptr %L.val to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %L.val11 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %sub.ptr.div.i = lshr exact i64 %sub.ptr.sub.i, 4
  %conv.i = trunc i64 %sub.ptr.div.i to i32
  %nargs.020 = add nsw i32 %conv.i, -1
  %tobool.not21 = icmp eq i32 %nargs.020, 0
  br i1 %tobool.not21, label %if.then.i14, label %for.body.lr.ph

for.body.lr.ph:                                   ; preds = %entry
  %l_gt.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 22
  %ci.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %env.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23
  %tt.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23, i32 1
  %l_G.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %2 = sext i32 %arg to i64
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.inc
  %indvars.iv = phi i64 [ %2, %for.body.lr.ph ], [ %indvars.iv.next, %for.inc ]
  %nargs.024 = phi i32 [ %nargs.020, %for.body.lr.ph ], [ %nargs.0, %for.inc ]
  %status.022 = phi i32 [ 1, %for.body.lr.ph ], [ %status.1, %for.inc ]
  %cmp.i.i = icmp sgt i64 %indvars.iv, 0
  br i1 %cmp.i.i, label %if.then.i.i, label %if.else3.i.i

if.then.i.i:                                      ; preds = %for.body
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr %struct.lua_TValue, ptr %3, i64 %indvars.iv
  %add.ptr.i.i = getelementptr %struct.lua_TValue, ptr %4, i64 -1
  %5 = load ptr, ptr %0, align 8
  %cmp1.not.i.i = icmp ult ptr %add.ptr.i.i, %5
  br i1 %cmp1.not.i.i, label %index2adr.exit.i, label %if.else

if.else3.i.i:                                     ; preds = %for.body
  %cmp4.i.i = icmp sgt i64 %indvars.iv, -10000
  br i1 %cmp4.i.i, label %if.then5.i.i, label %if.else9.i.i

if.then5.i.i:                                     ; preds = %if.else3.i.i
  %6 = load ptr, ptr %0, align 8
  %add.ptr8.i.i = getelementptr inbounds %struct.lua_TValue, ptr %6, i64 %indvars.iv
  br label %index2adr.exit.i

if.else9.i.i:                                     ; preds = %if.else3.i.i
  %7 = trunc i64 %indvars.iv to i32
  switch i32 %7, label %sw.default.i.i [
    i32 -10000, label %sw.bb.i.i
    i32 -10001, label %sw.bb10.i.i
    i32 -10002, label %index2adr.exit.i
  ]

sw.bb.i.i:                                        ; preds = %if.else9.i.i
  %8 = load ptr, ptr %l_G.i.i, align 8
  %l_registry.i.i = getelementptr inbounds %struct.global_State, ptr %8, i64 0, i32 20
  br label %index2adr.exit.i

sw.bb10.i.i:                                      ; preds = %if.else9.i.i
  %9 = load ptr, ptr %ci.i.i, align 8
  %func11.i.i = getelementptr inbounds %struct.CallInfo, ptr %9, i64 0, i32 1
  %10 = load ptr, ptr %func11.i.i, align 8
  %11 = load ptr, ptr %10, align 8
  %env12.i.i = getelementptr inbounds %struct.CClosure, ptr %11, i64 0, i32 6
  %12 = load ptr, ptr %env12.i.i, align 8
  store ptr %12, ptr %env.i.i, align 8
  store i32 5, ptr %tt.i.i, align 8
  br label %index2adr.exit.i

sw.default.i.i:                                   ; preds = %if.else9.i.i
  %13 = load ptr, ptr %ci.i.i, align 8
  %func18.i.i = getelementptr inbounds %struct.CallInfo, ptr %13, i64 0, i32 1
  %14 = load ptr, ptr %func18.i.i, align 8
  %15 = load ptr, ptr %14, align 8
  %nupvalues.i.i = getelementptr inbounds %struct.CClosure, ptr %15, i64 0, i32 4
  %16 = load i8, ptr %nupvalues.i.i, align 1
  %conv.i.i = zext i8 %16 to i32
  %17 = trunc i64 %indvars.iv to i32
  %18 = sub i32 -10002, %17
  %cmp21.not.i.i = icmp ugt i32 %18, %conv.i.i
  %19 = sub nuw nsw i64 -10003, %indvars.iv
  %arrayidx.i.i = getelementptr inbounds %struct.CClosure, ptr %15, i64 0, i32 8, i64 %19
  br i1 %cmp21.not.i.i, label %if.else, label %index2adr.exit.i

index2adr.exit.i:                                 ; preds = %if.else9.i.i, %sw.default.i.i, %sw.bb10.i.i, %sw.bb.i.i, %if.then5.i.i, %if.then.i.i
  %retval.0.i.i = phi ptr [ %add.ptr8.i.i, %if.then5.i.i ], [ %arrayidx.i.i, %sw.default.i.i ], [ %env.i.i, %sw.bb10.i.i ], [ %l_registry.i.i, %sw.bb.i.i ], [ %add.ptr.i.i, %if.then.i.i ], [ %l_gt.i.i, %if.else9.i.i ]
  %cmp.i = icmp eq ptr %retval.0.i.i, @luaO_nilobject_
  br i1 %cmp.i, label %if.else, label %lua_type.exit

lua_type.exit:                                    ; preds = %index2adr.exit.i
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i.i, i64 0, i32 1
  %20 = load i32, ptr %tt.i, align 8
  %cmp = icmp eq i32 %20, 3
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %lua_type.exit
  %tobool2.not = icmp eq i32 %status.022, 0
  br i1 %tobool2.not, label %for.inc, label %land.rhs

land.rhs:                                         ; preds = %if.then
  %21 = trunc i64 %indvars.iv to i32
  %call3 = call fastcc double @lua_tonumber(ptr noundef %L, i32 noundef %21)
  %call4 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %f, ptr noundef nonnull @.str.16, double noundef %call3)
  %cmp5 = icmp sgt i32 %call4, 0
  br label %for.inc

if.else:                                          ; preds = %sw.default.i.i, %if.then.i.i, %index2adr.exit.i, %lua_type.exit
  %22 = trunc i64 %indvars.iv to i32
  %call.i = call fastcc ptr @lua_tolstring(ptr noundef %L, i32 noundef %22, ptr noundef nonnull %l)
  %tobool.not.i = icmp eq ptr %call.i, null
  br i1 %tobool.not.i, label %if.then.i, label %luaL_checklstring.exit

if.then.i:                                        ; preds = %if.else
  call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef %22, ptr noundef nonnull @.str.25)
  unreachable

luaL_checklstring.exit:                           ; preds = %if.else
  %tobool7.not = icmp eq i32 %status.022, 0
  br i1 %tobool7.not, label %for.inc, label %land.rhs8

land.rhs8:                                        ; preds = %luaL_checklstring.exit
  %23 = load i64, ptr %l, align 8
  %call9 = call i64 @fwrite(ptr noundef nonnull %call.i, i64 noundef 1, i64 noundef %23, ptr noundef %f)
  %24 = load i64, ptr %l, align 8
  %cmp10 = icmp eq i64 %call9, %24
  br label %for.inc

for.inc:                                          ; preds = %luaL_checklstring.exit, %land.rhs8, %if.then, %land.rhs
  %status.1.in = phi i1 [ false, %if.then ], [ %cmp5, %land.rhs ], [ false, %luaL_checklstring.exit ], [ %cmp10, %land.rhs8 ]
  %status.1 = zext i1 %status.1.in to i32
  %indvars.iv.next = add nsw i64 %indvars.iv, 1
  %nargs.0 = add nsw i32 %nargs.024, -1
  %tobool.not = icmp eq i32 %nargs.0, 0
  br i1 %tobool.not, label %for.end, label %for.body, !llvm.loop !139

for.end:                                          ; preds = %for.inc
  %.pre = load ptr, ptr %0, align 8
  br i1 %status.1.in, label %if.then.i14, label %if.else.i

if.then.i14:                                      ; preds = %entry, %for.end
  %25 = phi ptr [ %.pre, %for.end ], [ %L.val, %entry ]
  store i32 1, ptr %25, align 8
  br label %pushresult.exit

if.else.i:                                        ; preds = %for.end
  %call.i12 = tail call ptr @__errno_location() #39
  %26 = load i32, ptr %call.i12, align 4
  %tt.i9.i = getelementptr inbounds %struct.lua_TValue, ptr %.pre, i64 0, i32 1
  store i32 0, ptr %tt.i9.i, align 8
  %27 = load ptr, ptr %0, align 8
  %incdec.ptr.i10.i = getelementptr inbounds %struct.lua_TValue, ptr %27, i64 1
  store ptr %incdec.ptr.i10.i, ptr %0, align 8
  %call6.i = call ptr @strerror(i32 noundef %26) #35
  %call7.i = call ptr (ptr, ptr, ...) @lua_pushfstring(ptr noundef nonnull %L, ptr noundef nonnull @.str.113, ptr noundef %call6.i)
  %28 = load ptr, ptr %0, align 8
  %conv.i.i15 = sitofp i32 %26 to double
  store double %conv.i.i15, ptr %28, align 8
  br label %pushresult.exit

pushresult.exit:                                  ; preds = %if.then.i14, %if.else.i
  %.sink14.i = phi ptr [ %28, %if.else.i ], [ %25, %if.then.i14 ]
  %.sink.i = phi i32 [ 3, %if.else.i ], [ 1, %if.then.i14 ]
  %tt.i12.i = getelementptr inbounds %struct.lua_TValue, ptr %.sink14.i, i64 0, i32 1
  store i32 %.sink.i, ptr %tt.i12.i, align 8
  %29 = load ptr, ptr %0, align 8
  %incdec.ptr.i13.i = getelementptr inbounds %struct.lua_TValue, ptr %29, i64 1
  store ptr %incdec.ptr.i13.i, ptr %0, align 8
  ret i32 %.sink.i
}

; Function Attrs: nofree nounwind
declare noundef i64 @fwrite(ptr nocapture noundef, i64 noundef, i64 noundef, ptr nocapture noundef) local_unnamed_addr #1

; Function Attrs: nofree nounwind
declare noundef i32 @fclose(ptr nocapture noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define internal i32 @io_flush(ptr noundef %L) #0 {
entry:
  %ci.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %0 = load ptr, ptr %ci.i.i.i, align 8
  %func11.i.i.i = getelementptr inbounds %struct.CallInfo, ptr %0, i64 0, i32 1
  %1 = load ptr, ptr %func11.i.i.i, align 8
  %2 = load ptr, ptr %1, align 8
  %env.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23
  %env12.i.i.i = getelementptr inbounds %struct.CClosure, ptr %2, i64 0, i32 6
  %3 = load ptr, ptr %env12.i.i.i, align 8
  store ptr %3, ptr %env.i.i.i, align 8
  %tt.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23, i32 1
  store i32 5, ptr %tt.i.i.i, align 8
  %sizearray.i.i.i = getelementptr inbounds %struct.Table, ptr %3, i64 0, i32 10
  %4 = load i32, ptr %sizearray.i.i.i, align 8
  %cmp.i5.i.i = icmp ugt i32 %4, 1
  br i1 %cmp.i5.i.i, label %if.then.i9.i.i, label %if.else.i.i.i

if.then.i9.i.i:                                   ; preds = %entry
  %array.i.i.i = getelementptr inbounds %struct.Table, ptr %3, i64 0, i32 6
  %5 = load ptr, ptr %array.i.i.i, align 8
  %arrayidx.i11.i.i = getelementptr inbounds %struct.lua_TValue, ptr %5, i64 1
  br label %lua_rawgeti.exit.i

if.else.i.i.i:                                    ; preds = %entry
  %node4.i.i.i.i = getelementptr inbounds %struct.Table, ptr %3, i64 0, i32 7
  %6 = load ptr, ptr %node4.i.i.i.i, align 8
  %lsizenode.i.i.i.i = getelementptr inbounds %struct.Table, ptr %3, i64 0, i32 4
  %7 = load i8, ptr %lsizenode.i.i.i.i, align 1
  %sh_prom.i.i.i.i = zext nneg i8 %7 to i64
  %notmask.i.i.i.i = shl nsw i64 -1, %sh_prom.i.i.i.i
  %sub.i.i.i.i = xor i64 %notmask.i.i.i.i, -1
  %or.i.i.i.i = or i64 %sub.i.i.i.i, 1
  %rem.i.i.i.i = urem i64 1073741824, %or.i.i.i.i
  %arrayidx7.i.i.i.i = getelementptr inbounds %struct.Node, ptr %6, i64 %rem.i.i.i.i
  br label %do.body.i.i.i

do.body.i.i.i:                                    ; preds = %if.else8.i.i.i, %if.else.i.i.i
  %n.0.i.i.i = phi ptr [ %arrayidx7.i.i.i.i, %if.else.i.i.i ], [ %10, %if.else8.i.i.i ]
  %tt.i7.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i.i, i64 0, i32 1, i32 0, i32 1
  %8 = load i32, ptr %tt.i7.i.i, align 8
  %cmp2.i.i.i = icmp eq i32 %8, 3
  br i1 %cmp2.i.i.i, label %land.lhs.true.i.i.i, label %if.else8.i.i.i

land.lhs.true.i.i.i:                              ; preds = %do.body.i.i.i
  %i_key.i.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i.i, i64 0, i32 1
  %9 = load double, ptr %i_key.i.i.i, align 8
  %cmp5.i.i.i = fcmp oeq double %9, 2.000000e+00
  br i1 %cmp5.i.i.i, label %lua_rawgeti.exit.i, label %if.else8.i.i.i

if.else8.i.i.i:                                   ; preds = %land.lhs.true.i.i.i, %do.body.i.i.i
  %next.i.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i.i, i64 0, i32 1, i32 0, i32 2
  %10 = load ptr, ptr %next.i.i.i, align 8
  %tobool.not.i.i.i = icmp eq ptr %10, null
  br i1 %tobool.not.i.i.i, label %lua_rawgeti.exit.i, label %do.body.i.i.i, !llvm.loop !7

lua_rawgeti.exit.i:                               ; preds = %if.else8.i.i.i, %land.lhs.true.i.i.i, %if.then.i9.i.i
  %retval.0.i8.i.i = phi ptr [ %arrayidx.i11.i.i, %if.then.i9.i.i ], [ %n.0.i.i.i, %land.lhs.true.i.i.i ], [ @luaO_nilobject_, %if.else8.i.i.i ]
  %top.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %11 = load ptr, ptr %top.i.i, align 8
  %12 = load i64, ptr %retval.0.i8.i.i, align 8
  store i64 %12, ptr %11, align 8
  %tt.i.i = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i8.i.i, i64 0, i32 1
  %13 = load i32, ptr %tt.i.i, align 8
  %tt4.i.i = getelementptr inbounds %struct.lua_TValue, ptr %11, i64 0, i32 1
  store i32 %13, ptr %tt4.i.i, align 8
  %14 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i.i = getelementptr inbounds %struct.lua_TValue, ptr %14, i64 1
  store ptr %incdec.ptr.i.i, ptr %top.i.i, align 8
  %tt.i5.i = getelementptr inbounds %struct.lua_TValue, ptr %14, i64 0, i32 1
  %15 = load i32, ptr %tt.i5.i, align 8
  %switch.i = icmp eq i32 %15, 7
  %16 = load ptr, ptr %14, align 8
  %retval.0.i.idx.i = zext i1 %switch.i to i64
  %retval.0.i.i = getelementptr inbounds %union.Udata, ptr %16, i64 %retval.0.i.idx.i
  %17 = load ptr, ptr %retval.0.i.i, align 8
  %cmp.i = icmp eq ptr %17, null
  br i1 %cmp.i, label %if.then.i, label %getiofile.exit

if.then.i:                                        ; preds = %lua_rawgeti.exit.i
  tail call void (ptr, ptr, ...) @luaL_error(ptr noundef nonnull %L, ptr noundef nonnull @.str.217, ptr noundef nonnull @.str.216)
  unreachable

getiofile.exit:                                   ; preds = %lua_rawgeti.exit.i
  %call1 = tail call i32 @fflush(ptr noundef nonnull %17)
  %cmp.not = icmp eq i32 %call1, 0
  %18 = load ptr, ptr %top.i.i, align 8
  br i1 %cmp.not, label %if.then.i2, label %if.else.i

if.then.i2:                                       ; preds = %getiofile.exit
  store i32 1, ptr %18, align 8
  br label %pushresult.exit

if.else.i:                                        ; preds = %getiofile.exit
  %call.i = tail call ptr @__errno_location() #39
  %19 = load i32, ptr %call.i, align 4
  %tt.i9.i = getelementptr inbounds %struct.lua_TValue, ptr %18, i64 0, i32 1
  store i32 0, ptr %tt.i9.i, align 8
  %20 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i10.i = getelementptr inbounds %struct.lua_TValue, ptr %20, i64 1
  store ptr %incdec.ptr.i10.i, ptr %top.i.i, align 8
  %call6.i = tail call ptr @strerror(i32 noundef %19) #35
  %call7.i = tail call ptr (ptr, ptr, ...) @lua_pushfstring(ptr noundef nonnull %L, ptr noundef nonnull @.str.113, ptr noundef %call6.i)
  %21 = load ptr, ptr %top.i.i, align 8
  %conv.i.i = sitofp i32 %19 to double
  store double %conv.i.i, ptr %21, align 8
  br label %pushresult.exit

pushresult.exit:                                  ; preds = %if.then.i2, %if.else.i
  %.sink14.i = phi ptr [ %21, %if.else.i ], [ %18, %if.then.i2 ]
  %.sink.i = phi i32 [ 3, %if.else.i ], [ 1, %if.then.i2 ]
  %tt.i12.i = getelementptr inbounds %struct.lua_TValue, ptr %.sink14.i, i64 0, i32 1
  store i32 %.sink.i, ptr %tt.i12.i, align 8
  %22 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i13.i = getelementptr inbounds %struct.lua_TValue, ptr %22, i64 1
  store ptr %incdec.ptr.i13.i, ptr %top.i.i, align 8
  ret i32 %.sink.i
}

; Function Attrs: nounwind uwtable
define internal i32 @io_input(ptr noundef %L) #0 {
entry:
  tail call fastcc void @g_iofile(ptr noundef %L, i32 noundef 1, ptr noundef nonnull @.str.218)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @io_lines(ptr noundef %L) #0 {
entry:
  %key.i.i = alloca %struct.lua_TValue, align 8
  %base.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i, align 8
  %top.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i, align 8
  %cmp1.not.i.i = icmp uge ptr %0, %1
  %cmp.i = icmp eq ptr %0, @luaO_nilobject_
  %or.cond = or i1 %cmp.i, %cmp1.not.i.i
  br i1 %or.cond, label %if.then, label %lua_type.exit

lua_type.exit:                                    ; preds = %entry
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %0, i64 0, i32 1
  %2 = load i32, ptr %tt.i, align 8
  %cmp = icmp slt i32 %2, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry, %lua_type.exit
  %ci.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %3 = load ptr, ptr %ci.i.i, align 8
  %func11.i.i = getelementptr inbounds %struct.CallInfo, ptr %3, i64 0, i32 1
  %4 = load ptr, ptr %func11.i.i, align 8
  %5 = load ptr, ptr %4, align 8
  %env.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23
  %env12.i.i = getelementptr inbounds %struct.CClosure, ptr %5, i64 0, i32 6
  %6 = load ptr, ptr %env12.i.i, align 8
  store ptr %6, ptr %env.i.i, align 8
  %tt.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23, i32 1
  store i32 5, ptr %tt.i.i, align 8
  %sizearray.i.i = getelementptr inbounds %struct.Table, ptr %6, i64 0, i32 10
  %7 = load i32, ptr %sizearray.i.i, align 8
  %cmp.i5.i.not = icmp eq i32 %7, 0
  br i1 %cmp.i5.i.not, label %if.else.i.i, label %if.then.i9.i

if.then.i9.i:                                     ; preds = %if.then
  %array.i.i = getelementptr inbounds %struct.Table, ptr %6, i64 0, i32 6
  %8 = load ptr, ptr %array.i.i, align 8
  br label %lua_rawgeti.exit

if.else.i.i:                                      ; preds = %if.then
  %node4.i.i.i = getelementptr inbounds %struct.Table, ptr %6, i64 0, i32 7
  %9 = load ptr, ptr %node4.i.i.i, align 8
  %lsizenode.i.i.i = getelementptr inbounds %struct.Table, ptr %6, i64 0, i32 4
  %10 = load i8, ptr %lsizenode.i.i.i, align 1
  %sh_prom.i.i.i = zext nneg i8 %10 to i64
  %notmask.i.i.i = shl nsw i64 -1, %sh_prom.i.i.i
  %sub.i.i.i = xor i64 %notmask.i.i.i, -1
  %or.i.i.i = or i64 %sub.i.i.i, 1
  %rem.i.i.i = urem i64 1072693248, %or.i.i.i
  %arrayidx7.i.i.i = getelementptr inbounds %struct.Node, ptr %9, i64 %rem.i.i.i
  br label %do.body.i.i

do.body.i.i:                                      ; preds = %if.else8.i.i, %if.else.i.i
  %n.0.i.i = phi ptr [ %arrayidx7.i.i.i, %if.else.i.i ], [ %13, %if.else8.i.i ]
  %tt.i7.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1, i32 0, i32 1
  %11 = load i32, ptr %tt.i7.i, align 8
  %cmp2.i.i = icmp eq i32 %11, 3
  br i1 %cmp2.i.i, label %land.lhs.true.i.i, label %if.else8.i.i

land.lhs.true.i.i:                                ; preds = %do.body.i.i
  %i_key.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1
  %12 = load double, ptr %i_key.i.i, align 8
  %cmp5.i.i = fcmp oeq double %12, 1.000000e+00
  br i1 %cmp5.i.i, label %lua_rawgeti.exit, label %if.else8.i.i

if.else8.i.i:                                     ; preds = %land.lhs.true.i.i, %do.body.i.i
  %next.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1, i32 0, i32 2
  %13 = load ptr, ptr %next.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %13, null
  br i1 %tobool.not.i.i, label %lua_rawgeti.exit, label %do.body.i.i, !llvm.loop !7

lua_rawgeti.exit:                                 ; preds = %land.lhs.true.i.i, %if.else8.i.i, %if.then.i9.i
  %retval.0.i8.i = phi ptr [ %8, %if.then.i9.i ], [ @luaO_nilobject_, %if.else8.i.i ], [ %n.0.i.i, %land.lhs.true.i.i ]
  %14 = load i64, ptr %retval.0.i8.i, align 8
  store i64 %14, ptr %1, align 8
  %tt.i12 = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i8.i, i64 0, i32 1
  %15 = load i32, ptr %tt.i12, align 8
  %tt4.i = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 0, i32 1
  store i32 %15, ptr %tt4.i, align 8
  %16 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %16, i64 1
  store ptr %incdec.ptr.i, ptr %top.i.i, align 8
  %call.i.i = tail call fastcc ptr @luaL_checkudata(ptr noundef %L)
  %17 = load ptr, ptr %call.i.i, align 8
  %cmp.i.i = icmp eq ptr %17, null
  br i1 %cmp.i.i, label %if.then.i.i, label %f_lines.exit

if.then.i.i:                                      ; preds = %lua_rawgeti.exit
  tail call void (ptr, ptr, ...) @luaL_error(ptr noundef nonnull %L, ptr noundef nonnull @.str.205)
  unreachable

f_lines.exit:                                     ; preds = %lua_rawgeti.exit
  %18 = load ptr, ptr %base.i.i, align 8
  %19 = load ptr, ptr %top.i.i, align 8
  %cmp1.not.i.i.i.i = icmp ult ptr %18, %19
  %add.ptr.luaO_nilobject_.i.i.i.i = select i1 %cmp1.not.i.i.i.i, ptr %18, ptr @luaO_nilobject_
  %20 = load i64, ptr %add.ptr.luaO_nilobject_.i.i.i.i, align 8
  store i64 %20, ptr %19, align 8
  %tt.i.i.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i.i.i, i64 0, i32 1
  %21 = load i32, ptr %tt.i.i.i, align 8
  %tt2.i.i.i = getelementptr inbounds %struct.lua_TValue, ptr %19, i64 0, i32 1
  store i32 %21, ptr %tt2.i.i.i, align 8
  %22 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i.i.i = getelementptr inbounds %struct.lua_TValue, ptr %22, i64 1
  store ptr %incdec.ptr.i.i.i, ptr %top.i.i, align 8
  store i32 0, ptr %incdec.ptr.i.i.i, align 8
  br label %return

if.else:                                          ; preds = %lua_type.exit
  %call.i = tail call fastcc ptr @lua_tolstring(ptr noundef nonnull %L, i32 noundef 1, ptr noundef null)
  %tobool.not.i = icmp eq ptr %call.i, null
  br i1 %tobool.not.i, label %if.then.i, label %luaL_checklstring.exit

if.then.i:                                        ; preds = %if.else
  tail call fastcc void @luaL_typerror(ptr noundef nonnull %L, i32 noundef 1, ptr noundef nonnull @.str.25)
  unreachable

luaL_checklstring.exit:                           ; preds = %if.else
  %call.i14 = tail call fastcc ptr @lua_newuserdata(ptr noundef nonnull %L, i64 noundef 8)
  store ptr null, ptr %call.i14, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %key.i.i)
  %l_G.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %23 = load ptr, ptr %l_G.i.i.i, align 8
  %l_registry.i.i.i = getelementptr inbounds %struct.global_State, ptr %23, i64 0, i32 20
  %call2.i.i = tail call fastcc ptr @luaS_newlstr(ptr noundef nonnull %L, ptr noundef nonnull @.str.199, i64 noundef 5)
  store ptr %call2.i.i, ptr %key.i.i, align 8
  %tt.i.i15 = getelementptr inbounds %struct.lua_TValue, ptr %key.i.i, i64 0, i32 1
  store i32 4, ptr %tt.i.i15, align 8
  %24 = load ptr, ptr %top.i.i, align 8
  call fastcc void @luaV_gettable(ptr noundef nonnull %L, ptr noundef nonnull %l_registry.i.i.i, ptr noundef nonnull %key.i.i, ptr noundef %24)
  %25 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i.i = getelementptr inbounds %struct.lua_TValue, ptr %25, i64 1
  store ptr %incdec.ptr.i.i, ptr %top.i.i, align 8
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %key.i.i)
  tail call fastcc void @lua_setmetatable(ptr noundef nonnull %L, i32 noundef -2)
  %call4 = tail call noalias ptr @fopen(ptr noundef nonnull %call.i, ptr noundef nonnull @.str.218)
  store ptr %call4, ptr %call.i14, align 8
  %cmp5 = icmp eq ptr %call4, null
  br i1 %cmp5, label %if.then6, label %if.end

if.then6:                                         ; preds = %luaL_checklstring.exit
  %call.i17 = tail call ptr @__errno_location() #39
  %26 = load i32, ptr %call.i17, align 4
  %call1.i18 = tail call ptr @strerror(i32 noundef %26) #35
  %call2.i = tail call ptr (ptr, ptr, ...) @lua_pushfstring(ptr noundef nonnull %L, ptr noundef nonnull @.str.207, ptr noundef nonnull %call.i, ptr noundef %call1.i18)
  %call3.i = tail call fastcc ptr @lua_tolstring(ptr noundef nonnull %L, i32 noundef -1, ptr noundef null)
  tail call fastcc void @luaL_argerror(ptr noundef nonnull %L, i32 noundef 1, ptr noundef %call3.i)
  unreachable

if.end:                                           ; preds = %luaL_checklstring.exit
  %L.val = load ptr, ptr %top.i.i, align 8
  %L.val10 = load ptr, ptr %base.i.i, align 8
  %sub.ptr.lhs.cast.i = ptrtoint ptr %L.val to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %L.val10 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %sub.ptr.div.i = lshr exact i64 %sub.ptr.sub.i, 4
  %conv.i = trunc i64 %sub.ptr.div.i to i32
  %cmp.i.i.i = icmp sgt i32 %conv.i, 0
  br i1 %cmp.i.i.i, label %if.then.i.i.i, label %if.else3.i.i.i

if.then.i.i.i:                                    ; preds = %if.end
  %27 = and i64 %sub.ptr.div.i, 4294967295
  %28 = getelementptr %struct.lua_TValue, ptr %L.val10, i64 %27
  %add.ptr.i.i.i = getelementptr %struct.lua_TValue, ptr %28, i64 -1
  %cmp1.not.i.i.i = icmp ult ptr %add.ptr.i.i.i, %L.val
  %add.ptr.luaO_nilobject_.i.i.i = select i1 %cmp1.not.i.i.i, ptr %add.ptr.i.i.i, ptr @luaO_nilobject_
  br label %aux_lines.exit

if.else3.i.i.i:                                   ; preds = %if.end
  %cmp4.i.i.i = icmp sgt i32 %conv.i, -10000
  br i1 %cmp4.i.i.i, label %if.then5.i.i.i, label %if.else9.i.i.i

if.then5.i.i.i:                                   ; preds = %if.else3.i.i.i
  %sext = shl i64 %sub.ptr.sub.i, 28
  %idx.ext7.i.i.i = ashr i64 %sext, 32
  %add.ptr8.i.i.i = getelementptr inbounds %struct.lua_TValue, ptr %L.val, i64 %idx.ext7.i.i.i
  br label %aux_lines.exit

if.else9.i.i.i:                                   ; preds = %if.else3.i.i.i
  switch i32 %conv.i, label %sw.default.i.i.i [
    i32 -10000, label %sw.bb.i.i.i
    i32 -10001, label %sw.bb10.i.i.i
    i32 -10002, label %sw.bb15.i.i.i
  ]

sw.bb.i.i.i:                                      ; preds = %if.else9.i.i.i
  %29 = load ptr, ptr %l_G.i.i.i, align 8
  %l_registry.i.i.i24 = getelementptr inbounds %struct.global_State, ptr %29, i64 0, i32 20
  br label %aux_lines.exit

sw.bb10.i.i.i:                                    ; preds = %if.else9.i.i.i
  %ci.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %30 = load ptr, ptr %ci.i.i.i, align 8
  %func11.i.i.i = getelementptr inbounds %struct.CallInfo, ptr %30, i64 0, i32 1
  %31 = load ptr, ptr %func11.i.i.i, align 8
  %32 = load ptr, ptr %31, align 8
  %env.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23
  %env12.i.i.i = getelementptr inbounds %struct.CClosure, ptr %32, i64 0, i32 6
  %33 = load ptr, ptr %env12.i.i.i, align 8
  store ptr %33, ptr %env.i.i.i, align 8
  %tt.i.i.i22 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23, i32 1
  store i32 5, ptr %tt.i.i.i22, align 8
  br label %aux_lines.exit

sw.bb15.i.i.i:                                    ; preds = %if.else9.i.i.i
  %l_gt.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 22
  br label %aux_lines.exit

sw.default.i.i.i:                                 ; preds = %if.else9.i.i.i
  %ci17.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %34 = load ptr, ptr %ci17.i.i.i, align 8
  %func18.i.i.i = getelementptr inbounds %struct.CallInfo, ptr %34, i64 0, i32 1
  %35 = load ptr, ptr %func18.i.i.i, align 8
  %36 = load ptr, ptr %35, align 8
  %sub20.i.i.i = sub nuw nsw i32 -10002, %conv.i
  %nupvalues.i.i.i = getelementptr inbounds %struct.CClosure, ptr %36, i64 0, i32 4
  %37 = load i8, ptr %nupvalues.i.i.i, align 1
  %conv.i.i.i = zext i8 %37 to i32
  %cmp21.not.i.i.i = icmp ugt i32 %sub20.i.i.i, %conv.i.i.i
  %sub23.i.i.i = sub nsw i64 4294957293, %sub.ptr.div.i
  %idxprom.i.i.i = and i64 %sub23.i.i.i, 4294967295
  %arrayidx.i.i.i = getelementptr inbounds %struct.CClosure, ptr %36, i64 0, i32 8, i64 %idxprom.i.i.i
  %cond.i.i.i = select i1 %cmp21.not.i.i.i, ptr @luaO_nilobject_, ptr %arrayidx.i.i.i
  br label %aux_lines.exit

aux_lines.exit:                                   ; preds = %if.then.i.i.i, %if.then5.i.i.i, %sw.bb.i.i.i, %sw.bb10.i.i.i, %sw.bb15.i.i.i, %sw.default.i.i.i
  %retval.0.i.i.i = phi ptr [ %add.ptr8.i.i.i, %if.then5.i.i.i ], [ %cond.i.i.i, %sw.default.i.i.i ], [ %l_gt.i.i.i, %sw.bb15.i.i.i ], [ %env.i.i.i, %sw.bb10.i.i.i ], [ %l_registry.i.i.i24, %sw.bb.i.i.i ], [ %add.ptr.luaO_nilobject_.i.i.i, %if.then.i.i.i ]
  %38 = load i64, ptr %retval.0.i.i.i, align 8
  store i64 %38, ptr %L.val, align 8
  %tt.i.i20 = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i.i.i, i64 0, i32 1
  %39 = load i32, ptr %tt.i.i20, align 8
  %tt2.i.i = getelementptr inbounds %struct.lua_TValue, ptr %L.val, i64 0, i32 1
  store i32 %39, ptr %tt2.i.i, align 8
  %40 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i.i21 = getelementptr inbounds %struct.lua_TValue, ptr %40, i64 1
  store ptr %incdec.ptr.i.i21, ptr %top.i.i, align 8
  store i32 1, ptr %incdec.ptr.i.i21, align 8
  br label %return

return:                                           ; preds = %aux_lines.exit, %f_lines.exit
  %.sink = phi ptr [ %40, %aux_lines.exit ], [ %22, %f_lines.exit ]
  %tt.i4.i = getelementptr inbounds %struct.lua_TValue, ptr %.sink, i64 1, i32 1
  store i32 1, ptr %tt.i4.i, align 8
  %41 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i5.i = getelementptr inbounds %struct.lua_TValue, ptr %41, i64 1
  store ptr %incdec.ptr.i5.i, ptr %top.i.i, align 8
  tail call fastcc void @lua_pushcclosure(ptr noundef nonnull %L, ptr noundef nonnull @io_readline, i32 noundef 2)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @io_open(ptr noundef %L) #0 {
entry:
  %key.i.i = alloca %struct.lua_TValue, align 8
  %call.i = tail call fastcc ptr @lua_tolstring(ptr noundef %L, i32 noundef 1, ptr noundef null)
  %tobool.not.i = icmp eq ptr %call.i, null
  br i1 %tobool.not.i, label %if.then.i, label %luaL_checklstring.exit

if.then.i:                                        ; preds = %entry
  tail call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 1, ptr noundef nonnull @.str.25)
  unreachable

luaL_checklstring.exit:                           ; preds = %entry
  %base.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i.i, align 8
  %add.ptr.i.i.i = getelementptr %struct.lua_TValue, ptr %0, i64 1
  %top.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i.i = icmp uge ptr %add.ptr.i.i.i, %1
  %cmp.i.i = icmp eq ptr %add.ptr.i.i.i, @luaO_nilobject_
  %or.cond = or i1 %cmp1.not.i.i.i, %cmp.i.i
  br i1 %or.cond, label %luaL_optlstring.exit, label %lua_type.exit.i

lua_type.exit.i:                                  ; preds = %luaL_checklstring.exit
  %tt.i.i = getelementptr %struct.lua_TValue, ptr %0, i64 1, i32 1
  %2 = load i32, ptr %tt.i.i, align 8
  %cmp.i = icmp slt i32 %2, 1
  br i1 %cmp.i, label %luaL_optlstring.exit, label %if.else.i

if.else.i:                                        ; preds = %lua_type.exit.i
  %call.i.i = tail call fastcc ptr @lua_tolstring(ptr noundef nonnull %L, i32 noundef 2, ptr noundef null)
  %tobool.not.i.i = icmp eq ptr %call.i.i, null
  br i1 %tobool.not.i.i, label %if.then.i.i, label %luaL_optlstring.exit

if.then.i.i:                                      ; preds = %if.else.i
  tail call fastcc void @luaL_typerror(ptr noundef nonnull %L, i32 noundef 2, ptr noundef nonnull @.str.25)
  unreachable

luaL_optlstring.exit:                             ; preds = %luaL_checklstring.exit, %lua_type.exit.i, %if.else.i
  %retval.0.i = phi ptr [ %call.i.i, %if.else.i ], [ @.str.218, %lua_type.exit.i ], [ @.str.218, %luaL_checklstring.exit ]
  %call.i7 = tail call fastcc ptr @lua_newuserdata(ptr noundef nonnull %L, i64 noundef 8)
  store ptr null, ptr %call.i7, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %key.i.i)
  %l_G.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %3 = load ptr, ptr %l_G.i.i.i, align 8
  %l_registry.i.i.i = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 20
  %call2.i.i = tail call fastcc ptr @luaS_newlstr(ptr noundef nonnull %L, ptr noundef nonnull @.str.199, i64 noundef 5)
  store ptr %call2.i.i, ptr %key.i.i, align 8
  %tt.i.i8 = getelementptr inbounds %struct.lua_TValue, ptr %key.i.i, i64 0, i32 1
  store i32 4, ptr %tt.i.i8, align 8
  %4 = load ptr, ptr %top.i.i.i, align 8
  call fastcc void @luaV_gettable(ptr noundef nonnull %L, ptr noundef nonnull %l_registry.i.i.i, ptr noundef nonnull %key.i.i, ptr noundef %4)
  %5 = load ptr, ptr %top.i.i.i, align 8
  %incdec.ptr.i.i = getelementptr inbounds %struct.lua_TValue, ptr %5, i64 1
  store ptr %incdec.ptr.i.i, ptr %top.i.i.i, align 8
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %key.i.i)
  tail call fastcc void @lua_setmetatable(ptr noundef nonnull %L, i32 noundef -2)
  %call3 = tail call noalias ptr @fopen(ptr noundef nonnull %call.i, ptr noundef nonnull %retval.0.i)
  store ptr %call3, ptr %call.i7, align 8
  %cmp = icmp eq ptr %call3, null
  br i1 %cmp, label %pushresult.exit, label %cond.end

pushresult.exit:                                  ; preds = %luaL_optlstring.exit
  %call.i9 = tail call ptr @__errno_location() #39
  %6 = load i32, ptr %call.i9, align 4
  %7 = load ptr, ptr %top.i.i.i, align 8
  %tt.i9.i = getelementptr inbounds %struct.lua_TValue, ptr %7, i64 0, i32 1
  store i32 0, ptr %tt.i9.i, align 8
  %8 = load ptr, ptr %top.i.i.i, align 8
  %incdec.ptr.i10.i = getelementptr inbounds %struct.lua_TValue, ptr %8, i64 1
  store ptr %incdec.ptr.i10.i, ptr %top.i.i.i, align 8
  %call6.i = tail call ptr @strerror(i32 noundef %6) #35
  %call4.i = tail call ptr (ptr, ptr, ...) @lua_pushfstring(ptr noundef nonnull %L, ptr noundef nonnull @.str.207, ptr noundef nonnull %call.i, ptr noundef %call6.i)
  %9 = load ptr, ptr %top.i.i.i, align 8
  %conv.i.i = sitofp i32 %6 to double
  store double %conv.i.i, ptr %9, align 8
  %tt.i12.i = getelementptr inbounds %struct.lua_TValue, ptr %9, i64 0, i32 1
  store i32 3, ptr %tt.i12.i, align 8
  %10 = load ptr, ptr %top.i.i.i, align 8
  %incdec.ptr.i13.i = getelementptr inbounds %struct.lua_TValue, ptr %10, i64 1
  store ptr %incdec.ptr.i13.i, ptr %top.i.i.i, align 8
  br label %cond.end

cond.end:                                         ; preds = %luaL_optlstring.exit, %pushresult.exit
  %cond = phi i32 [ 3, %pushresult.exit ], [ 1, %luaL_optlstring.exit ]
  ret i32 %cond
}

; Function Attrs: nounwind uwtable
define internal i32 @io_output(ptr noundef %L) #0 {
entry:
  tail call fastcc void @g_iofile(ptr noundef %L, i32 noundef 2, ptr noundef nonnull @.str.219)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @io_read(ptr noundef %L) #0 {
entry:
  %ci.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %0 = load ptr, ptr %ci.i.i.i, align 8
  %func11.i.i.i = getelementptr inbounds %struct.CallInfo, ptr %0, i64 0, i32 1
  %1 = load ptr, ptr %func11.i.i.i, align 8
  %2 = load ptr, ptr %1, align 8
  %env.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23
  %env12.i.i.i = getelementptr inbounds %struct.CClosure, ptr %2, i64 0, i32 6
  %3 = load ptr, ptr %env12.i.i.i, align 8
  store ptr %3, ptr %env.i.i.i, align 8
  %tt.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23, i32 1
  store i32 5, ptr %tt.i.i.i, align 8
  %sizearray.i.i.i = getelementptr inbounds %struct.Table, ptr %3, i64 0, i32 10
  %4 = load i32, ptr %sizearray.i.i.i, align 8
  %cmp.i5.i.i.not = icmp eq i32 %4, 0
  br i1 %cmp.i5.i.i.not, label %if.else.i.i.i, label %if.then.i9.i.i

if.then.i9.i.i:                                   ; preds = %entry
  %array.i.i.i = getelementptr inbounds %struct.Table, ptr %3, i64 0, i32 6
  %5 = load ptr, ptr %array.i.i.i, align 8
  br label %lua_rawgeti.exit.i

if.else.i.i.i:                                    ; preds = %entry
  %node4.i.i.i.i = getelementptr inbounds %struct.Table, ptr %3, i64 0, i32 7
  %6 = load ptr, ptr %node4.i.i.i.i, align 8
  %lsizenode.i.i.i.i = getelementptr inbounds %struct.Table, ptr %3, i64 0, i32 4
  %7 = load i8, ptr %lsizenode.i.i.i.i, align 1
  %sh_prom.i.i.i.i = zext nneg i8 %7 to i64
  %notmask.i.i.i.i = shl nsw i64 -1, %sh_prom.i.i.i.i
  %sub.i.i.i.i = xor i64 %notmask.i.i.i.i, -1
  %or.i.i.i.i = or i64 %sub.i.i.i.i, 1
  %rem.i.i.i.i = urem i64 1072693248, %or.i.i.i.i
  %arrayidx7.i.i.i.i = getelementptr inbounds %struct.Node, ptr %6, i64 %rem.i.i.i.i
  br label %do.body.i.i.i

do.body.i.i.i:                                    ; preds = %if.else8.i.i.i, %if.else.i.i.i
  %n.0.i.i.i = phi ptr [ %arrayidx7.i.i.i.i, %if.else.i.i.i ], [ %10, %if.else8.i.i.i ]
  %tt.i7.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i.i, i64 0, i32 1, i32 0, i32 1
  %8 = load i32, ptr %tt.i7.i.i, align 8
  %cmp2.i.i.i = icmp eq i32 %8, 3
  br i1 %cmp2.i.i.i, label %land.lhs.true.i.i.i, label %if.else8.i.i.i

land.lhs.true.i.i.i:                              ; preds = %do.body.i.i.i
  %i_key.i.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i.i, i64 0, i32 1
  %9 = load double, ptr %i_key.i.i.i, align 8
  %cmp5.i.i.i = fcmp oeq double %9, 1.000000e+00
  br i1 %cmp5.i.i.i, label %lua_rawgeti.exit.i, label %if.else8.i.i.i

if.else8.i.i.i:                                   ; preds = %land.lhs.true.i.i.i, %do.body.i.i.i
  %next.i.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i.i, i64 0, i32 1, i32 0, i32 2
  %10 = load ptr, ptr %next.i.i.i, align 8
  %tobool.not.i.i.i = icmp eq ptr %10, null
  br i1 %tobool.not.i.i.i, label %lua_rawgeti.exit.i, label %do.body.i.i.i, !llvm.loop !7

lua_rawgeti.exit.i:                               ; preds = %if.else8.i.i.i, %land.lhs.true.i.i.i, %if.then.i9.i.i
  %retval.0.i8.i.i = phi ptr [ %5, %if.then.i9.i.i ], [ %n.0.i.i.i, %land.lhs.true.i.i.i ], [ @luaO_nilobject_, %if.else8.i.i.i ]
  %top.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %11 = load ptr, ptr %top.i.i, align 8
  %12 = load i64, ptr %retval.0.i8.i.i, align 8
  store i64 %12, ptr %11, align 8
  %tt.i.i = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i8.i.i, i64 0, i32 1
  %13 = load i32, ptr %tt.i.i, align 8
  %tt4.i.i = getelementptr inbounds %struct.lua_TValue, ptr %11, i64 0, i32 1
  store i32 %13, ptr %tt4.i.i, align 8
  %14 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i.i = getelementptr inbounds %struct.lua_TValue, ptr %14, i64 1
  store ptr %incdec.ptr.i.i, ptr %top.i.i, align 8
  %tt.i5.i = getelementptr inbounds %struct.lua_TValue, ptr %14, i64 0, i32 1
  %15 = load i32, ptr %tt.i5.i, align 8
  %switch.i = icmp eq i32 %15, 7
  %16 = load ptr, ptr %14, align 8
  %retval.0.i.idx.i = zext i1 %switch.i to i64
  %retval.0.i.i = getelementptr inbounds %union.Udata, ptr %16, i64 %retval.0.i.idx.i
  %17 = load ptr, ptr %retval.0.i.i, align 8
  %cmp.i = icmp eq ptr %17, null
  br i1 %cmp.i, label %if.then.i, label %getiofile.exit

if.then.i:                                        ; preds = %lua_rawgeti.exit.i
  tail call void (ptr, ptr, ...) @luaL_error(ptr noundef nonnull %L, ptr noundef nonnull @.str.217, ptr noundef nonnull @.str.214)
  unreachable

getiofile.exit:                                   ; preds = %lua_rawgeti.exit.i
  %call1 = tail call fastcc i32 @g_read(ptr noundef nonnull %L, ptr noundef nonnull %17, i32 noundef 1)
  ret i32 %call1
}

; Function Attrs: nounwind uwtable
define internal i32 @io_type(ptr noundef %L) #0 {
entry:
  %key.i = alloca %struct.lua_TValue, align 8
  %base.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i.i, align 8
  %top.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i.i = icmp uge ptr %0, %1
  %cmp.i.i = icmp eq ptr %0, @luaO_nilobject_
  %or.cond = or i1 %cmp.i.i, %cmp1.not.i.i.i
  br i1 %or.cond, label %if.then.i, label %lua_type.exit.i

lua_type.exit.i:                                  ; preds = %entry
  %tt.i.i = getelementptr inbounds %struct.lua_TValue, ptr %0, i64 0, i32 1
  %2 = load i32, ptr %tt.i.i, align 8
  switch i32 %2, label %lua_touserdata.exit [
    i32 -1, label %if.then.i
    i32 7, label %sw.bb.i
    i32 2, label %sw.bb1.i
  ]

if.then.i:                                        ; preds = %lua_type.exit.i, %entry
  tail call fastcc void @luaL_argerror(ptr noundef nonnull %L, i32 noundef 1, ptr noundef nonnull @.str.115)
  unreachable

sw.bb.i:                                          ; preds = %lua_type.exit.i
  %3 = load ptr, ptr %0, align 8
  %add.ptr.i = getelementptr inbounds %union.Udata, ptr %3, i64 1
  br label %lua_touserdata.exit

sw.bb1.i:                                         ; preds = %lua_type.exit.i
  %4 = load ptr, ptr %0, align 8
  br label %lua_touserdata.exit

lua_touserdata.exit:                              ; preds = %lua_type.exit.i, %sw.bb.i, %sw.bb1.i
  %retval.0.i = phi ptr [ %4, %sw.bb1.i ], [ %add.ptr.i, %sw.bb.i ], [ null, %lua_type.exit.i ]
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %key.i)
  %l_G.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %5 = load ptr, ptr %l_G.i.i, align 8
  %l_registry.i.i = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 20
  %call2.i = tail call fastcc ptr @luaS_newlstr(ptr noundef nonnull %L, ptr noundef nonnull @.str.199, i64 noundef 5)
  store ptr %call2.i, ptr %key.i, align 8
  %tt.i10 = getelementptr inbounds %struct.lua_TValue, ptr %key.i, i64 0, i32 1
  store i32 4, ptr %tt.i10, align 8
  %6 = load ptr, ptr %top.i.i.i, align 8
  call fastcc void @luaV_gettable(ptr noundef nonnull %L, ptr noundef nonnull %l_registry.i.i, ptr noundef nonnull %key.i, ptr noundef %6)
  %7 = load ptr, ptr %top.i.i.i, align 8
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %7, i64 1
  store ptr %incdec.ptr.i, ptr %top.i.i.i, align 8
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %key.i)
  %cmp = icmp eq ptr %retval.0.i, null
  br i1 %cmp, label %if.end8, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %lua_touserdata.exit
  %8 = load ptr, ptr %base.i.i.i, align 8
  %cmp1.not.i.i13 = icmp ult ptr %8, %incdec.ptr.i
  %add.ptr.luaO_nilobject_.i.i14 = select i1 %cmp1.not.i.i13, ptr %8, ptr @luaO_nilobject_
  %tt.i15 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i14, i64 0, i32 1
  %9 = load i32, ptr %tt.i15, align 8
  switch i32 %9, label %sw.default.i [
    i32 5, label %sw.bb.i19
    i32 7, label %sw.bb1.i16
  ]

sw.bb.i19:                                        ; preds = %lor.lhs.false
  %10 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i14, align 8
  %metatable.i = getelementptr inbounds %struct.Table, ptr %10, i64 0, i32 5
  br label %sw.epilog.i

sw.bb1.i16:                                       ; preds = %lor.lhs.false
  %11 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i14, align 8
  %metatable3.i = getelementptr inbounds %struct.anon.1, ptr %11, i64 0, i32 3
  br label %sw.epilog.i

sw.default.i:                                     ; preds = %lor.lhs.false
  %12 = load ptr, ptr %l_G.i.i, align 8
  %idxprom.i = sext i32 %9 to i64
  %arrayidx.i = getelementptr inbounds %struct.global_State, ptr %12, i64 0, i32 23, i64 %idxprom.i
  br label %sw.epilog.i

sw.epilog.i:                                      ; preds = %sw.default.i, %sw.bb1.i16, %sw.bb.i19
  %mt.0.in.i = phi ptr [ %arrayidx.i, %sw.default.i ], [ %metatable3.i, %sw.bb1.i16 ], [ %metatable.i, %sw.bb.i19 ]
  %mt.0.i = load ptr, ptr %mt.0.in.i, align 8
  %cmp.i17 = icmp eq ptr %mt.0.i, null
  br i1 %cmp.i17, label %if.end8, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %sw.epilog.i
  store ptr %mt.0.i, ptr %incdec.ptr.i, align 8
  %tt7.i = getelementptr inbounds %struct.lua_TValue, ptr %7, i64 1, i32 1
  store i32 5, ptr %tt7.i, align 8
  %13 = load ptr, ptr %top.i.i.i, align 8
  %incdec.ptr.i18 = getelementptr inbounds %struct.lua_TValue, ptr %13, i64 1
  store ptr %incdec.ptr.i18, ptr %top.i.i.i, align 8
  %add.ptr8.i.i = getelementptr inbounds %struct.lua_TValue, ptr %13, i64 -1
  %cmp.i20 = icmp eq ptr %add.ptr8.i.i, @luaO_nilobject_
  %cmp2.i = icmp eq ptr %13, @luaO_nilobject_
  %or.cond.i = or i1 %cmp2.i, %cmp.i20
  br i1 %or.cond.i, label %if.end8, label %cond.false.i

cond.false.i:                                     ; preds = %lor.lhs.false2
  %tt.i42.i = getelementptr %struct.lua_TValue, ptr %13, i64 -1, i32 1
  %14 = load i32, ptr %tt.i42.i, align 8
  %tt1.i.i = getelementptr inbounds %struct.lua_TValue, ptr %13, i64 0, i32 1
  %15 = load i32, ptr %tt1.i.i, align 8
  %cmp.not.i.i = icmp eq i32 %14, %15
  br i1 %cmp.not.i.i, label %if.else.i.i, label %if.end8

if.else.i.i:                                      ; preds = %cond.false.i
  switch i32 %14, label %sw.default.i44.i [
    i32 0, label %if.else
    i32 3, label %lua_rawequal.exit
    i32 1, label %sw.bb6.i.i
    i32 2, label %sw.bb11.i.i
  ]

sw.bb6.i.i:                                       ; preds = %if.else.i.i
  %16 = load i32, ptr %add.ptr8.i.i, align 8
  %17 = load i32, ptr %13, align 8
  %cmp9.i.i = icmp eq i32 %16, %17
  br i1 %cmp9.i.i, label %if.else, label %if.end8

sw.bb11.i.i:                                      ; preds = %if.else.i.i
  %18 = load ptr, ptr %add.ptr8.i.i, align 8
  %19 = load ptr, ptr %13, align 8
  %cmp14.i.i = icmp eq ptr %18, %19
  br i1 %cmp14.i.i, label %if.else, label %if.end8

sw.default.i44.i:                                 ; preds = %if.else.i.i
  %20 = load ptr, ptr %add.ptr8.i.i, align 8
  %21 = load ptr, ptr %13, align 8
  %cmp18.i.i = icmp eq ptr %20, %21
  br i1 %cmp18.i.i, label %if.else, label %if.end8

lua_rawequal.exit:                                ; preds = %if.else.i.i
  %22 = load double, ptr %add.ptr8.i.i, align 8
  %23 = load double, ptr %13, align 8
  %cmp5.i.i = fcmp oeq double %22, %23
  br i1 %cmp5.i.i, label %if.else, label %if.end8

if.else:                                          ; preds = %sw.bb6.i.i, %sw.bb11.i.i, %sw.default.i44.i, %if.else.i.i, %lua_rawequal.exit
  %24 = load ptr, ptr %retval.0.i, align 8
  %cmp5 = icmp eq ptr %24, null
  %25 = load ptr, ptr %l_G.i.i, align 8
  %totalbytes.i = getelementptr inbounds %struct.global_State, ptr %25, i64 0, i32 14
  %26 = load i64, ptr %totalbytes.i, align 8
  %GCthreshold.i = getelementptr inbounds %struct.global_State, ptr %25, i64 0, i32 13
  %27 = load i64, ptr %GCthreshold.i, align 8
  %cmp.not.i = icmp ult i64 %26, %27
  br i1 %cmp5, label %if.then6, label %if.else7

if.then6:                                         ; preds = %if.else
  br i1 %cmp.not.i, label %lua_pushlstring.exit, label %if.then.i25

if.then.i25:                                      ; preds = %if.then6
  %gcstepmul.i.i = getelementptr inbounds %struct.global_State, ptr %25, i64 0, i32 18
  %28 = load i32, ptr %gcstepmul.i.i, align 4
  %mul.i.i = mul i32 %28, 10
  %conv.i.i = zext i32 %mul.i.i to i64
  %cmp.i.i26 = icmp eq i32 %mul.i.i, 0
  %spec.store.select.i.i = select i1 %cmp.i.i26, i64 9223372036854775806, i64 %conv.i.i
  %sub.i.i = sub i64 %26, %27
  %gcdept.i.i = getelementptr inbounds %struct.global_State, ptr %25, i64 0, i32 16
  %29 = load i64, ptr %gcdept.i.i, align 8
  %add.i.i = add i64 %sub.i.i, %29
  store i64 %add.i.i, ptr %gcdept.i.i, align 8
  %gcstate.i.i = getelementptr inbounds %struct.global_State, ptr %25, i64 0, i32 4
  br label %do.body.i.i

do.body.i.i:                                      ; preds = %do.body.i.i, %if.then.i25
  %lim.0.i.i = phi i64 [ %spec.store.select.i.i, %if.then.i25 ], [ %sub2.i.i, %do.body.i.i ]
  %call.i.i = tail call fastcc i64 @singlestep(ptr noundef %L)
  %sub2.i.i = sub nsw i64 %lim.0.i.i, %call.i.i
  %30 = load i8, ptr %gcstate.i.i, align 1
  %cmp4.i.i = icmp ne i8 %30, 0
  %cmp8.i.i = icmp sgt i64 %sub2.i.i, 0
  %or.cond.i.i = select i1 %cmp4.i.i, i1 %cmp8.i.i, i1 false
  br i1 %or.cond.i.i, label %do.body.i.i, label %do.end.i.i, !llvm.loop !6

do.end.i.i:                                       ; preds = %do.body.i.i
  br i1 %cmp4.i.i, label %if.then14.i.i, label %if.else27.i.i

if.then14.i.i:                                    ; preds = %do.end.i.i
  %31 = load i64, ptr %gcdept.i.i, align 8
  %cmp16.i.i = icmp ult i64 %31, 1024
  br i1 %cmp16.i.i, label %if.then18.i.i, label %if.else.i.i30

if.then18.i.i:                                    ; preds = %if.then14.i.i
  %32 = load i64, ptr %totalbytes.i, align 8
  %add20.i.i = add i64 %32, 1024
  br label %luaC_step.exit.i

if.else.i.i30:                                    ; preds = %if.then14.i.i
  %sub23.i.i = add i64 %31, -1024
  store i64 %sub23.i.i, ptr %gcdept.i.i, align 8
  %33 = load i64, ptr %totalbytes.i, align 8
  br label %luaC_step.exit.i

if.else27.i.i:                                    ; preds = %do.end.i.i
  %estimate.i.i = getelementptr inbounds %struct.global_State, ptr %25, i64 0, i32 15
  %34 = load i64, ptr %estimate.i.i, align 8
  %div.i.i = udiv i64 %34, 100
  %gcpause.i.i = getelementptr inbounds %struct.global_State, ptr %25, i64 0, i32 17
  %35 = load i32, ptr %gcpause.i.i, align 8
  %conv28.i.i = sext i32 %35 to i64
  %mul29.i.i = mul i64 %div.i.i, %conv28.i.i
  br label %luaC_step.exit.i

luaC_step.exit.i:                                 ; preds = %if.else27.i.i, %if.else.i.i30, %if.then18.i.i
  %add20.sink.i.i = phi i64 [ %add20.i.i, %if.then18.i.i ], [ %33, %if.else.i.i30 ], [ %mul29.i.i, %if.else27.i.i ]
  store i64 %add20.sink.i.i, ptr %GCthreshold.i, align 8
  %.pre85 = load ptr, ptr %top.i.i.i, align 8
  br label %lua_pushlstring.exit

lua_pushlstring.exit:                             ; preds = %if.then6, %luaC_step.exit.i
  %36 = phi ptr [ %incdec.ptr.i18, %if.then6 ], [ %.pre85, %luaC_step.exit.i ]
  %call.i = tail call fastcc ptr @luaS_newlstr(ptr noundef nonnull %L, ptr noundef nonnull @.str.220, i64 noundef 11)
  store ptr %call.i, ptr %36, align 8
  br label %if.end8

if.else7:                                         ; preds = %if.else
  br i1 %cmp.not.i, label %lua_pushlstring.exit71, label %if.then.i35

if.then.i35:                                      ; preds = %if.else7
  %gcstepmul.i.i36 = getelementptr inbounds %struct.global_State, ptr %25, i64 0, i32 18
  %37 = load i32, ptr %gcstepmul.i.i36, align 4
  %mul.i.i37 = mul i32 %37, 10
  %conv.i.i38 = zext i32 %mul.i.i37 to i64
  %cmp.i.i39 = icmp eq i32 %mul.i.i37, 0
  %spec.store.select.i.i40 = select i1 %cmp.i.i39, i64 9223372036854775806, i64 %conv.i.i38
  %sub.i.i41 = sub i64 %26, %27
  %gcdept.i.i42 = getelementptr inbounds %struct.global_State, ptr %25, i64 0, i32 16
  %38 = load i64, ptr %gcdept.i.i42, align 8
  %add.i.i43 = add i64 %sub.i.i41, %38
  store i64 %add.i.i43, ptr %gcdept.i.i42, align 8
  %gcstate.i.i44 = getelementptr inbounds %struct.global_State, ptr %25, i64 0, i32 4
  br label %do.body.i.i45

do.body.i.i45:                                    ; preds = %do.body.i.i45, %if.then.i35
  %lim.0.i.i46 = phi i64 [ %spec.store.select.i.i40, %if.then.i35 ], [ %sub2.i.i48, %do.body.i.i45 ]
  %call.i.i47 = tail call fastcc i64 @singlestep(ptr noundef %L)
  %sub2.i.i48 = sub nsw i64 %lim.0.i.i46, %call.i.i47
  %39 = load i8, ptr %gcstate.i.i44, align 1
  %cmp4.i.i49 = icmp ne i8 %39, 0
  %cmp8.i.i50 = icmp sgt i64 %sub2.i.i48, 0
  %or.cond.i.i51 = select i1 %cmp4.i.i49, i1 %cmp8.i.i50, i1 false
  br i1 %or.cond.i.i51, label %do.body.i.i45, label %do.end.i.i52, !llvm.loop !6

do.end.i.i52:                                     ; preds = %do.body.i.i45
  br i1 %cmp4.i.i49, label %if.then14.i.i65, label %if.else27.i.i53

if.then14.i.i65:                                  ; preds = %do.end.i.i52
  %40 = load i64, ptr %gcdept.i.i42, align 8
  %cmp16.i.i66 = icmp ult i64 %40, 1024
  br i1 %cmp16.i.i66, label %if.then18.i.i69, label %if.else.i.i67

if.then18.i.i69:                                  ; preds = %if.then14.i.i65
  %41 = load i64, ptr %totalbytes.i, align 8
  %add20.i.i70 = add i64 %41, 1024
  br label %luaC_step.exit.i59

if.else.i.i67:                                    ; preds = %if.then14.i.i65
  %sub23.i.i68 = add i64 %40, -1024
  store i64 %sub23.i.i68, ptr %gcdept.i.i42, align 8
  %42 = load i64, ptr %totalbytes.i, align 8
  br label %luaC_step.exit.i59

if.else27.i.i53:                                  ; preds = %do.end.i.i52
  %estimate.i.i54 = getelementptr inbounds %struct.global_State, ptr %25, i64 0, i32 15
  %43 = load i64, ptr %estimate.i.i54, align 8
  %div.i.i55 = udiv i64 %43, 100
  %gcpause.i.i56 = getelementptr inbounds %struct.global_State, ptr %25, i64 0, i32 17
  %44 = load i32, ptr %gcpause.i.i56, align 8
  %conv28.i.i57 = sext i32 %44 to i64
  %mul29.i.i58 = mul i64 %div.i.i55, %conv28.i.i57
  br label %luaC_step.exit.i59

luaC_step.exit.i59:                               ; preds = %if.else27.i.i53, %if.else.i.i67, %if.then18.i.i69
  %add20.sink.i.i60 = phi i64 [ %add20.i.i70, %if.then18.i.i69 ], [ %42, %if.else.i.i67 ], [ %mul29.i.i58, %if.else27.i.i53 ]
  store i64 %add20.sink.i.i60, ptr %GCthreshold.i, align 8
  %.pre = load ptr, ptr %top.i.i.i, align 8
  br label %lua_pushlstring.exit71

lua_pushlstring.exit71:                           ; preds = %if.else7, %luaC_step.exit.i59
  %45 = phi ptr [ %incdec.ptr.i18, %if.else7 ], [ %.pre, %luaC_step.exit.i59 ]
  %call.i62 = tail call fastcc ptr @luaS_newlstr(ptr noundef nonnull %L, ptr noundef nonnull @.str.221, i64 noundef 4)
  store ptr %call.i62, ptr %45, align 8
  br label %if.end8

if.end8:                                          ; preds = %lua_touserdata.exit, %lua_rawequal.exit, %sw.epilog.i, %lor.lhs.false2, %cond.false.i, %sw.default.i44.i, %sw.bb11.i.i, %sw.bb6.i.i, %lua_pushlstring.exit, %lua_pushlstring.exit71
  %.sink86 = phi ptr [ %36, %lua_pushlstring.exit ], [ %45, %lua_pushlstring.exit71 ], [ %incdec.ptr.i18, %cond.false.i ], [ %incdec.ptr.i18, %lor.lhs.false2 ], [ %incdec.ptr.i, %sw.epilog.i ], [ %incdec.ptr.i18, %lua_rawequal.exit ], [ %incdec.ptr.i, %lua_touserdata.exit ], [ %incdec.ptr.i18, %sw.default.i44.i ], [ %incdec.ptr.i18, %sw.bb11.i.i ], [ %incdec.ptr.i18, %sw.bb6.i.i ]
  %.sink = phi i32 [ 4, %lua_pushlstring.exit ], [ 4, %lua_pushlstring.exit71 ], [ 0, %cond.false.i ], [ 0, %lor.lhs.false2 ], [ 0, %sw.epilog.i ], [ 0, %lua_rawequal.exit ], [ 0, %lua_touserdata.exit ], [ 0, %sw.default.i44.i ], [ 0, %sw.bb11.i.i ], [ 0, %sw.bb6.i.i ]
  %tt.i28 = getelementptr inbounds %struct.lua_TValue, ptr %.sink86, i64 0, i32 1
  store i32 %.sink, ptr %tt.i28, align 8
  %46 = load ptr, ptr %top.i.i.i, align 8
  %incdec.ptr.i29 = getelementptr inbounds %struct.lua_TValue, ptr %46, i64 1
  store ptr %incdec.ptr.i29, ptr %top.i.i.i, align 8
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @io_write(ptr noundef %L) #0 {
entry:
  %ci.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %0 = load ptr, ptr %ci.i.i.i, align 8
  %func11.i.i.i = getelementptr inbounds %struct.CallInfo, ptr %0, i64 0, i32 1
  %1 = load ptr, ptr %func11.i.i.i, align 8
  %2 = load ptr, ptr %1, align 8
  %env.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23
  %env12.i.i.i = getelementptr inbounds %struct.CClosure, ptr %2, i64 0, i32 6
  %3 = load ptr, ptr %env12.i.i.i, align 8
  store ptr %3, ptr %env.i.i.i, align 8
  %tt.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23, i32 1
  store i32 5, ptr %tt.i.i.i, align 8
  %sizearray.i.i.i = getelementptr inbounds %struct.Table, ptr %3, i64 0, i32 10
  %4 = load i32, ptr %sizearray.i.i.i, align 8
  %cmp.i5.i.i = icmp ugt i32 %4, 1
  br i1 %cmp.i5.i.i, label %if.then.i9.i.i, label %if.else.i.i.i

if.then.i9.i.i:                                   ; preds = %entry
  %array.i.i.i = getelementptr inbounds %struct.Table, ptr %3, i64 0, i32 6
  %5 = load ptr, ptr %array.i.i.i, align 8
  %arrayidx.i11.i.i = getelementptr inbounds %struct.lua_TValue, ptr %5, i64 1
  br label %lua_rawgeti.exit.i

if.else.i.i.i:                                    ; preds = %entry
  %node4.i.i.i.i = getelementptr inbounds %struct.Table, ptr %3, i64 0, i32 7
  %6 = load ptr, ptr %node4.i.i.i.i, align 8
  %lsizenode.i.i.i.i = getelementptr inbounds %struct.Table, ptr %3, i64 0, i32 4
  %7 = load i8, ptr %lsizenode.i.i.i.i, align 1
  %sh_prom.i.i.i.i = zext nneg i8 %7 to i64
  %notmask.i.i.i.i = shl nsw i64 -1, %sh_prom.i.i.i.i
  %sub.i.i.i.i = xor i64 %notmask.i.i.i.i, -1
  %or.i.i.i.i = or i64 %sub.i.i.i.i, 1
  %rem.i.i.i.i = urem i64 1073741824, %or.i.i.i.i
  %arrayidx7.i.i.i.i = getelementptr inbounds %struct.Node, ptr %6, i64 %rem.i.i.i.i
  br label %do.body.i.i.i

do.body.i.i.i:                                    ; preds = %if.else8.i.i.i, %if.else.i.i.i
  %n.0.i.i.i = phi ptr [ %arrayidx7.i.i.i.i, %if.else.i.i.i ], [ %10, %if.else8.i.i.i ]
  %tt.i7.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i.i, i64 0, i32 1, i32 0, i32 1
  %8 = load i32, ptr %tt.i7.i.i, align 8
  %cmp2.i.i.i = icmp eq i32 %8, 3
  br i1 %cmp2.i.i.i, label %land.lhs.true.i.i.i, label %if.else8.i.i.i

land.lhs.true.i.i.i:                              ; preds = %do.body.i.i.i
  %i_key.i.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i.i, i64 0, i32 1
  %9 = load double, ptr %i_key.i.i.i, align 8
  %cmp5.i.i.i = fcmp oeq double %9, 2.000000e+00
  br i1 %cmp5.i.i.i, label %lua_rawgeti.exit.i, label %if.else8.i.i.i

if.else8.i.i.i:                                   ; preds = %land.lhs.true.i.i.i, %do.body.i.i.i
  %next.i.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i.i, i64 0, i32 1, i32 0, i32 2
  %10 = load ptr, ptr %next.i.i.i, align 8
  %tobool.not.i.i.i = icmp eq ptr %10, null
  br i1 %tobool.not.i.i.i, label %lua_rawgeti.exit.i, label %do.body.i.i.i, !llvm.loop !7

lua_rawgeti.exit.i:                               ; preds = %if.else8.i.i.i, %land.lhs.true.i.i.i, %if.then.i9.i.i
  %retval.0.i8.i.i = phi ptr [ %arrayidx.i11.i.i, %if.then.i9.i.i ], [ %n.0.i.i.i, %land.lhs.true.i.i.i ], [ @luaO_nilobject_, %if.else8.i.i.i ]
  %top.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %11 = load ptr, ptr %top.i.i, align 8
  %12 = load i64, ptr %retval.0.i8.i.i, align 8
  store i64 %12, ptr %11, align 8
  %tt.i.i = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i8.i.i, i64 0, i32 1
  %13 = load i32, ptr %tt.i.i, align 8
  %tt4.i.i = getelementptr inbounds %struct.lua_TValue, ptr %11, i64 0, i32 1
  store i32 %13, ptr %tt4.i.i, align 8
  %14 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i.i = getelementptr inbounds %struct.lua_TValue, ptr %14, i64 1
  store ptr %incdec.ptr.i.i, ptr %top.i.i, align 8
  %tt.i5.i = getelementptr inbounds %struct.lua_TValue, ptr %14, i64 0, i32 1
  %15 = load i32, ptr %tt.i5.i, align 8
  %switch.i = icmp eq i32 %15, 7
  %16 = load ptr, ptr %14, align 8
  %retval.0.i.idx.i = zext i1 %switch.i to i64
  %retval.0.i.i = getelementptr inbounds %union.Udata, ptr %16, i64 %retval.0.i.idx.i
  %17 = load ptr, ptr %retval.0.i.i, align 8
  %cmp.i = icmp eq ptr %17, null
  br i1 %cmp.i, label %if.then.i, label %getiofile.exit

if.then.i:                                        ; preds = %lua_rawgeti.exit.i
  tail call void (ptr, ptr, ...) @luaL_error(ptr noundef nonnull %L, ptr noundef nonnull @.str.217, ptr noundef nonnull @.str.216)
  unreachable

getiofile.exit:                                   ; preds = %lua_rawgeti.exit.i
  %call1 = tail call fastcc i32 @g_write(ptr noundef nonnull %L, ptr noundef nonnull %17, i32 noundef 1), !range !136
  ret i32 %call1
}

; Function Attrs: nounwind uwtable
define internal fastcc void @g_iofile(ptr noundef %L, i32 noundef %f, ptr nocapture noundef readonly %mode) unnamed_addr #0 {
entry:
  %key.i.i = alloca %struct.lua_TValue, align 8
  %base.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i, align 8
  %top.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i, align 8
  %cmp1.not.i.i = icmp uge ptr %0, %1
  %cmp.i = icmp eq ptr %0, @luaO_nilobject_
  %or.cond = or i1 %cmp.i, %cmp1.not.i.i
  br i1 %or.cond, label %if.end9, label %lua_type.exit

lua_type.exit:                                    ; preds = %entry
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %0, i64 0, i32 1
  %2 = load i32, ptr %tt.i, align 8
  %cmp = icmp slt i32 %2, 1
  br i1 %cmp, label %if.end9, label %if.then

if.then:                                          ; preds = %lua_type.exit
  %call1 = tail call fastcc ptr @lua_tolstring(ptr noundef nonnull %L, i32 noundef 1, ptr noundef null)
  %tobool.not = icmp eq ptr %call1, null
  br i1 %tobool.not, label %if.else, label %if.then2

if.then2:                                         ; preds = %if.then
  %call.i = tail call fastcc ptr @lua_newuserdata(ptr noundef nonnull %L, i64 noundef 8)
  store ptr null, ptr %call.i, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %key.i.i)
  %l_G.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %3 = load ptr, ptr %l_G.i.i.i, align 8
  %l_registry.i.i.i = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 20
  %call2.i.i = tail call fastcc ptr @luaS_newlstr(ptr noundef nonnull %L, ptr noundef nonnull @.str.199, i64 noundef 5)
  store ptr %call2.i.i, ptr %key.i.i, align 8
  %tt.i.i = getelementptr inbounds %struct.lua_TValue, ptr %key.i.i, i64 0, i32 1
  store i32 4, ptr %tt.i.i, align 8
  %4 = load ptr, ptr %top.i.i, align 8
  call fastcc void @luaV_gettable(ptr noundef nonnull %L, ptr noundef nonnull %l_registry.i.i.i, ptr noundef nonnull %key.i.i, ptr noundef %4)
  %5 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i.i = getelementptr inbounds %struct.lua_TValue, ptr %5, i64 1
  store ptr %incdec.ptr.i.i, ptr %top.i.i, align 8
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %key.i.i)
  tail call fastcc void @lua_setmetatable(ptr noundef nonnull %L, i32 noundef -2)
  %call4 = tail call noalias ptr @fopen(ptr noundef nonnull %call1, ptr noundef %mode)
  store ptr %call4, ptr %call.i, align 8
  %cmp5 = icmp eq ptr %call4, null
  br i1 %cmp5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.then2
  %call.i13 = tail call ptr @__errno_location() #39
  %6 = load i32, ptr %call.i13, align 4
  %call1.i14 = tail call ptr @strerror(i32 noundef %6) #35
  %call2.i = tail call ptr (ptr, ptr, ...) @lua_pushfstring(ptr noundef nonnull %L, ptr noundef nonnull @.str.207, ptr noundef nonnull %call1, ptr noundef %call1.i14)
  %call3.i = tail call fastcc ptr @lua_tolstring(ptr noundef nonnull %L, i32 noundef -1, ptr noundef null)
  tail call fastcc void @luaL_argerror(ptr noundef nonnull %L, i32 noundef 1, ptr noundef %call3.i)
  unreachable

if.else:                                          ; preds = %if.then
  %call.i15 = tail call fastcc ptr @luaL_checkudata(ptr noundef nonnull %L)
  %7 = load ptr, ptr %call.i15, align 8
  %cmp.i16 = icmp eq ptr %7, null
  br i1 %cmp.i16, label %if.then.i, label %tofile.exit

if.then.i:                                        ; preds = %if.else
  tail call void (ptr, ptr, ...) @luaL_error(ptr noundef nonnull %L, ptr noundef nonnull @.str.205)
  unreachable

tofile.exit:                                      ; preds = %if.else
  %8 = load ptr, ptr %base.i.i, align 8
  %9 = load ptr, ptr %top.i.i, align 8
  %cmp1.not.i.i21 = icmp ult ptr %8, %9
  %add.ptr.luaO_nilobject_.i.i = select i1 %cmp1.not.i.i21, ptr %8, ptr @luaO_nilobject_
  %10 = load i64, ptr %add.ptr.luaO_nilobject_.i.i, align 8
  store i64 %10, ptr %9, align 8
  %tt.i23 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i, i64 0, i32 1
  %11 = load i32, ptr %tt.i23, align 8
  %tt2.i = getelementptr inbounds %struct.lua_TValue, ptr %9, i64 0, i32 1
  store i32 %11, ptr %tt2.i, align 8
  %12 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %12, i64 1
  store ptr %incdec.ptr.i, ptr %top.i.i, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.then2, %tofile.exit
  tail call fastcc void @lua_rawseti(ptr noundef nonnull %L, i32 noundef -10001, i32 noundef %f)
  br label %if.end9

if.end9:                                          ; preds = %entry, %if.end8, %lua_type.exit
  %ci.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %13 = load ptr, ptr %ci.i.i, align 8
  %func11.i.i = getelementptr inbounds %struct.CallInfo, ptr %13, i64 0, i32 1
  %14 = load ptr, ptr %func11.i.i, align 8
  %15 = load ptr, ptr %14, align 8
  %env.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23
  %env12.i.i = getelementptr inbounds %struct.CClosure, ptr %15, i64 0, i32 6
  %16 = load ptr, ptr %env12.i.i, align 8
  store ptr %16, ptr %env.i.i, align 8
  %tt.i.i24 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23, i32 1
  store i32 5, ptr %tt.i.i24, align 8
  %sub.i.i = add i32 %f, -1
  %sizearray.i.i = getelementptr inbounds %struct.Table, ptr %16, i64 0, i32 10
  %17 = load i32, ptr %sizearray.i.i, align 8
  %cmp.i5.i = icmp ult i32 %sub.i.i, %17
  br i1 %cmp.i5.i, label %if.then.i9.i, label %if.else.i.i

if.then.i9.i:                                     ; preds = %if.end9
  %array.i.i = getelementptr inbounds %struct.Table, ptr %16, i64 0, i32 6
  %18 = load ptr, ptr %array.i.i, align 8
  %idxprom.i10.i = sext i32 %sub.i.i to i64
  %arrayidx.i11.i = getelementptr inbounds %struct.lua_TValue, ptr %18, i64 %idxprom.i10.i
  br label %lua_rawgeti.exit

if.else.i.i:                                      ; preds = %if.end9
  %conv.i6.i = sitofp i32 %f to double
  %cmp.i.i.i = icmp eq i32 %f, 0
  br i1 %cmp.i.i.i, label %if.then.i.i.i, label %if.end.i.i.i

if.then.i.i.i:                                    ; preds = %if.else.i.i
  %node.i.i.i = getelementptr inbounds %struct.Table, ptr %16, i64 0, i32 7
  %19 = load ptr, ptr %node.i.i.i, align 8
  br label %do.body.i.i.preheader

if.end.i.i.i:                                     ; preds = %if.else.i.i
  %20 = bitcast double %conv.i6.i to i64
  %a.sroa.0.4.extract.shift.i.i.i = lshr i64 %20, 32
  %add.i.i.i = add i64 %a.sroa.0.4.extract.shift.i.i.i, %20
  %node4.i.i.i = getelementptr inbounds %struct.Table, ptr %16, i64 0, i32 7
  %21 = load ptr, ptr %node4.i.i.i, align 8
  %conv.i.i.i = and i64 %add.i.i.i, 4294967295
  %lsizenode.i.i.i = getelementptr inbounds %struct.Table, ptr %16, i64 0, i32 4
  %22 = load i8, ptr %lsizenode.i.i.i, align 1
  %sh_prom.i.i.i = zext nneg i8 %22 to i64
  %notmask.i.i.i = shl nsw i64 -1, %sh_prom.i.i.i
  %sub.i.i.i = xor i64 %notmask.i.i.i, -1
  %or.i.i.i = or i64 %sub.i.i.i, 1
  %rem.i.i.i = urem i64 %conv.i.i.i, %or.i.i.i
  %arrayidx7.i.i.i = getelementptr inbounds %struct.Node, ptr %21, i64 %rem.i.i.i
  br label %do.body.i.i.preheader

do.body.i.i.preheader:                            ; preds = %if.end.i.i.i, %if.then.i.i.i
  %n.0.i.i.ph = phi ptr [ %arrayidx7.i.i.i, %if.end.i.i.i ], [ %19, %if.then.i.i.i ]
  br label %do.body.i.i

do.body.i.i:                                      ; preds = %do.body.i.i.preheader, %if.else8.i.i
  %n.0.i.i = phi ptr [ %25, %if.else8.i.i ], [ %n.0.i.i.ph, %do.body.i.i.preheader ]
  %tt.i7.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1, i32 0, i32 1
  %23 = load i32, ptr %tt.i7.i, align 8
  %cmp2.i.i = icmp eq i32 %23, 3
  br i1 %cmp2.i.i, label %land.lhs.true.i.i, label %if.else8.i.i

land.lhs.true.i.i:                                ; preds = %do.body.i.i
  %i_key.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1
  %24 = load double, ptr %i_key.i.i, align 8
  %cmp5.i.i = fcmp oeq double %24, %conv.i6.i
  br i1 %cmp5.i.i, label %lua_rawgeti.exit, label %if.else8.i.i

if.else8.i.i:                                     ; preds = %land.lhs.true.i.i, %do.body.i.i
  %next.i.i = getelementptr inbounds %struct.Node, ptr %n.0.i.i, i64 0, i32 1, i32 0, i32 2
  %25 = load ptr, ptr %next.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %25, null
  br i1 %tobool.not.i.i, label %lua_rawgeti.exit, label %do.body.i.i, !llvm.loop !7

lua_rawgeti.exit:                                 ; preds = %land.lhs.true.i.i, %if.else8.i.i, %if.then.i9.i
  %retval.0.i8.i = phi ptr [ %arrayidx.i11.i, %if.then.i9.i ], [ @luaO_nilobject_, %if.else8.i.i ], [ %n.0.i.i, %land.lhs.true.i.i ]
  %26 = load ptr, ptr %top.i.i, align 8
  %27 = load i64, ptr %retval.0.i8.i, align 8
  store i64 %27, ptr %26, align 8
  %tt.i27 = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i8.i, i64 0, i32 1
  %28 = load i32, ptr %tt.i27, align 8
  %tt4.i = getelementptr inbounds %struct.lua_TValue, ptr %26, i64 0, i32 1
  store i32 %28, ptr %tt4.i, align 8
  %29 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i28 = getelementptr inbounds %struct.lua_TValue, ptr %29, i64 1
  store ptr %incdec.ptr.i28, ptr %top.i.i, align 8
  ret void
}

; Function Attrs: nofree nounwind
declare noalias noundef ptr @fopen(ptr nocapture noundef readonly, ptr nocapture noundef readonly) local_unnamed_addr #1

; Function Attrs: noreturn nounwind uwtable
define internal i32 @os_exit(ptr noundef %L) #7 {
entry:
  %call = tail call fastcc i64 @luaL_optinteger(ptr noundef %L, i32 noundef 1, i64 noundef 0)
  %conv = trunc i64 %call to i32
  tail call void @exit(i32 noundef %conv) #38
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @os_remove(ptr noundef %L) #0 {
entry:
  %call.i = tail call fastcc ptr @lua_tolstring(ptr noundef %L, i32 noundef 1, ptr noundef null)
  %tobool.not.i = icmp eq ptr %call.i, null
  br i1 %tobool.not.i, label %if.then.i, label %luaL_checklstring.exit

if.then.i:                                        ; preds = %entry
  tail call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 1, ptr noundef nonnull @.str.25)
  unreachable

luaL_checklstring.exit:                           ; preds = %entry
  %call1 = tail call i32 @remove(ptr noundef nonnull %call.i) #35
  %cmp.not = icmp eq i32 %call1, 0
  br i1 %cmp.not, label %if.then.i4, label %if.else.i

if.then.i4:                                       ; preds = %luaL_checklstring.exit
  %top.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %0 = load ptr, ptr %top.i.i, align 8
  store i32 1, ptr %0, align 8
  br label %os_pushresult.exit

if.else.i:                                        ; preds = %luaL_checklstring.exit
  %call.i5 = tail call ptr @__errno_location() #39
  %1 = load i32, ptr %call.i5, align 4
  %top.i5.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %2 = load ptr, ptr %top.i5.i, align 8
  %tt.i6.i = getelementptr inbounds %struct.lua_TValue, ptr %2, i64 0, i32 1
  store i32 0, ptr %tt.i6.i, align 8
  %3 = load ptr, ptr %top.i5.i, align 8
  %incdec.ptr.i7.i = getelementptr inbounds %struct.lua_TValue, ptr %3, i64 1
  store ptr %incdec.ptr.i7.i, ptr %top.i5.i, align 8
  %call1.i = tail call ptr @strerror(i32 noundef %1) #35
  %call2.i = tail call ptr (ptr, ptr, ...) @lua_pushfstring(ptr noundef %L, ptr noundef nonnull @.str.207, ptr noundef nonnull %call.i, ptr noundef %call1.i)
  %4 = load ptr, ptr %top.i5.i, align 8
  %conv.i.i = sitofp i32 %1 to double
  store double %conv.i.i, ptr %4, align 8
  br label %os_pushresult.exit

os_pushresult.exit:                               ; preds = %if.then.i4, %if.else.i
  %.sink12.i = phi ptr [ %4, %if.else.i ], [ %0, %if.then.i4 ]
  %.sink.i = phi i32 [ 3, %if.else.i ], [ 1, %if.then.i4 ]
  %top.i5.sink11.i = phi ptr [ %top.i5.i, %if.else.i ], [ %top.i.i, %if.then.i4 ]
  %tt.i9.i = getelementptr inbounds %struct.lua_TValue, ptr %.sink12.i, i64 0, i32 1
  store i32 %.sink.i, ptr %tt.i9.i, align 8
  %5 = load ptr, ptr %top.i5.sink11.i, align 8
  %incdec.ptr.i10.i = getelementptr inbounds %struct.lua_TValue, ptr %5, i64 1
  store ptr %incdec.ptr.i10.i, ptr %top.i5.sink11.i, align 8
  ret i32 %.sink.i
}

; Function Attrs: nofree nounwind
declare noundef i32 @remove(ptr nocapture noundef readonly) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define internal i32 @str_byte(ptr noundef %L) #0 {
entry:
  %endptr.i.i.i54 = alloca ptr, align 8
  %endptr.i.i.i = alloca ptr, align 8
  %l = alloca i64, align 8
  %call.i = call fastcc ptr @lua_tolstring(ptr noundef %L, i32 noundef 1, ptr noundef nonnull %l)
  %tobool.not.i = icmp eq ptr %call.i, null
  br i1 %tobool.not.i, label %if.then.i, label %luaL_checklstring.exit

if.then.i:                                        ; preds = %entry
  call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 1, ptr noundef nonnull @.str.25)
  unreachable

luaL_checklstring.exit:                           ; preds = %entry
  %base.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i.i, align 8
  %add.ptr.i.i.i = getelementptr %struct.lua_TValue, ptr %0, i64 1
  %top.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i.i = icmp uge ptr %add.ptr.i.i.i, %1
  %cmp.i.i = icmp eq ptr %add.ptr.i.i.i, @luaO_nilobject_
  %or.cond = or i1 %cmp1.not.i.i.i, %cmp.i.i
  br i1 %or.cond, label %luaL_optinteger.exit.thread, label %lua_type.exit.i

lua_type.exit.i:                                  ; preds = %luaL_checklstring.exit
  %tt.i.i = getelementptr %struct.lua_TValue, ptr %0, i64 1, i32 1
  %2 = load i32, ptr %tt.i.i, align 8
  %cmp.i = icmp slt i32 %2, 1
  br i1 %cmp.i, label %luaL_optinteger.exit.thread, label %cond.false.i

cond.false.i:                                     ; preds = %lua_type.exit.i
  %call.i.i = call fastcc i64 @lua_tointeger(ptr noundef nonnull %L, i32 noundef 2)
  %call.i.i.fr = freeze i64 %call.i.i
  %cmp.i3.i = icmp eq i64 %call.i.i.fr, 0
  br i1 %cmp.i3.i, label %land.lhs.true.i.i, label %luaL_optinteger.exit

land.lhs.true.i.i:                                ; preds = %cond.false.i
  %3 = load ptr, ptr %base.i.i.i, align 8
  %add.ptr.i.i50 = getelementptr %struct.lua_TValue, ptr %3, i64 1
  %4 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i = icmp ult ptr %add.ptr.i.i50, %4
  %add.ptr.luaO_nilobject_.i.i = select i1 %cmp1.not.i.i, ptr %add.ptr.i.i50, ptr @luaO_nilobject_
  %tt.i52 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i, i64 0, i32 1
  %5 = load i32, ptr %tt.i52, align 8
  switch i32 %5, label %if.then.i.i [
    i32 3, label %luaL_optinteger.exit.thread
    i32 4, label %land.lhs.true.i.i53
  ]

land.lhs.true.i.i53:                              ; preds = %land.lhs.true.i.i
  %6 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i, align 8
  %add.ptr.i3.i = getelementptr inbounds %union.TString, ptr %6, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i.i)
  %call.i.i.i = call double @strtod(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i) #35
  %7 = load ptr, ptr %endptr.i.i.i, align 8
  %cmp.i.i.i = icmp eq ptr %7, %add.ptr.i3.i
  br i1 %cmp.i.i.i, label %luaO_str2d.exit.thread.i.i, label %if.end.i.i.i

luaO_str2d.exit.thread.i.i:                       ; preds = %land.lhs.true.i.i53
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %if.then.i.i

if.end.i.i.i:                                     ; preds = %land.lhs.true.i.i53
  %8 = load i8, ptr %7, align 1
  switch i8 %8, label %if.end9.i.i.i [
    i8 120, label %if.then6.i.i.i
    i8 88, label %if.then6.i.i.i
  ]

if.then6.i.i.i:                                   ; preds = %if.end.i.i.i, %if.end.i.i.i
  %call7.i.i.i = call i64 @strtoul(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i, i32 noundef 16) #35
  %.pre.i.i.i = load ptr, ptr %endptr.i.i.i, align 8
  %.pre5.i.i.i = load i8, ptr %.pre.i.i.i, align 1
  br label %if.end9.i.i.i

if.end9.i.i.i:                                    ; preds = %if.then6.i.i.i, %if.end.i.i.i
  %9 = phi i8 [ %8, %if.end.i.i.i ], [ %.pre5.i.i.i, %if.then6.i.i.i ]
  %endptr.promoted.i.i.i = phi ptr [ %7, %if.end.i.i.i ], [ %.pre.i.i.i, %if.then6.i.i.i ]
  %cmp11.i.i.i = icmp eq i8 %9, 0
  br i1 %cmp11.i.i.i, label %luaO_str2d.exit.thread9.i.i, label %while.cond.preheader.i.i.i

luaO_str2d.exit.thread9.i.i:                      ; preds = %if.end9.i.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %luaL_optinteger.exit.thread

while.cond.preheader.i.i.i:                       ; preds = %if.end9.i.i.i
  %call15.i.i.i = tail call ptr @__ctype_b_loc() #39
  %10 = load ptr, ptr %call15.i.i.i, align 8
  br label %while.cond.i.i.i

while.cond.i.i.i:                                 ; preds = %while.cond.i.i.i, %while.cond.preheader.i.i.i
  %incdec.ptr4.i.i.i = phi ptr [ %endptr.promoted.i.i.i, %while.cond.preheader.i.i.i ], [ %incdec.ptr.i.i.i, %while.cond.i.i.i ]
  %11 = load i8, ptr %incdec.ptr4.i.i.i, align 1
  %idxprom.i.i.i = zext i8 %11 to i64
  %arrayidx.i.i.i = getelementptr inbounds i16, ptr %10, i64 %idxprom.i.i.i
  %12 = load i16, ptr %arrayidx.i.i.i, align 2
  %13 = and i16 %12, 8192
  %tobool.not.i.i.i = icmp eq i16 %13, 0
  %incdec.ptr.i.i.i = getelementptr inbounds i8, ptr %incdec.ptr4.i.i.i, i64 1
  br i1 %tobool.not.i.i.i, label %luaO_str2d.exit.i.i, label %while.cond.i.i.i, !llvm.loop !35

luaO_str2d.exit.i.i:                              ; preds = %while.cond.i.i.i
  %cmp19.not.i.not.i.i = icmp eq i8 %11, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br i1 %cmp19.not.i.not.i.i, label %luaL_optinteger.exit.thread, label %if.then.i.i

if.then.i.i:                                      ; preds = %land.lhs.true.i.i, %luaO_str2d.exit.i.i, %luaO_str2d.exit.thread.i.i
  call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 2, ptr noundef nonnull @.str.24)
  unreachable

luaL_optinteger.exit:                             ; preds = %cond.false.i
  %14 = load i64, ptr %l, align 8
  %cmp.i20 = icmp slt i64 %call.i.i.fr, 0
  %add.i = add nsw i64 %14, 1
  %spec.select105 = select i1 %cmp.i20, i64 %add.i, i64 0
  br label %luaL_optinteger.exit.thread

luaL_optinteger.exit.thread:                      ; preds = %luaL_optinteger.exit, %luaO_str2d.exit.thread9.i.i, %luaO_str2d.exit.i.i, %land.lhs.true.i.i, %luaL_checklstring.exit, %lua_type.exit.i
  %cond.i96 = phi i64 [ 0, %land.lhs.true.i.i ], [ 1, %luaL_checklstring.exit ], [ 1, %lua_type.exit.i ], [ 0, %luaO_str2d.exit.i.i ], [ 0, %luaO_str2d.exit.thread9.i.i ], [ %call.i.i.fr, %luaL_optinteger.exit ]
  %15 = phi i64 [ 0, %land.lhs.true.i.i ], [ 0, %luaL_checklstring.exit ], [ 0, %lua_type.exit.i ], [ 0, %luaO_str2d.exit.i.i ], [ 0, %luaO_str2d.exit.thread9.i.i ], [ %spec.select105, %luaL_optinteger.exit ]
  %pos.addr.0.i = add nsw i64 %15, %cond.i96
  %cond.i21 = call i64 @llvm.smax.i64(i64 %pos.addr.0.i, i64 0)
  %16 = load ptr, ptr %base.i.i.i, align 8
  %add.ptr.i.i.i23 = getelementptr %struct.lua_TValue, ptr %16, i64 2
  %17 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i.i25 = icmp uge ptr %add.ptr.i.i.i23, %17
  %cmp.i.i28 = icmp eq ptr %add.ptr.i.i.i23, @luaO_nilobject_
  %or.cond106 = or i1 %cmp1.not.i.i.i25, %cmp.i.i28
  br i1 %or.cond106, label %luaL_optinteger.exit40.thread, label %lua_type.exit.i29

lua_type.exit.i29:                                ; preds = %luaL_optinteger.exit.thread
  %tt.i.i30 = getelementptr %struct.lua_TValue, ptr %16, i64 2, i32 1
  %18 = load i32, ptr %tt.i.i30, align 8
  %cmp.i31 = icmp slt i32 %18, 1
  br i1 %cmp.i31, label %luaL_optinteger.exit40.thread, label %cond.false.i32

cond.false.i32:                                   ; preds = %lua_type.exit.i29
  %call.i.i33 = call fastcc i64 @lua_tointeger(ptr noundef nonnull %L, i32 noundef 3)
  %call.i.i33.fr = freeze i64 %call.i.i33
  %cmp.i3.i34 = icmp eq i64 %call.i.i33.fr, 0
  br i1 %cmp.i3.i34, label %land.lhs.true.i.i35, label %luaL_optinteger.exit40

land.lhs.true.i.i35:                              ; preds = %cond.false.i32
  %19 = load ptr, ptr %base.i.i.i, align 8
  %add.ptr.i.i57 = getelementptr %struct.lua_TValue, ptr %19, i64 2
  %20 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i59 = icmp ult ptr %add.ptr.i.i57, %20
  %add.ptr.luaO_nilobject_.i.i60 = select i1 %cmp1.not.i.i59, ptr %add.ptr.i.i57, ptr @luaO_nilobject_
  %tt.i61 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i60, i64 0, i32 1
  %21 = load i32, ptr %tt.i61, align 8
  switch i32 %21, label %if.then.i.i38 [
    i32 3, label %luaL_optinteger.exit40.thread
    i32 4, label %land.lhs.true.i.i62
  ]

land.lhs.true.i.i62:                              ; preds = %land.lhs.true.i.i35
  %22 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i60, align 8
  %add.ptr.i3.i63 = getelementptr inbounds %union.TString, ptr %22, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i.i54)
  %call.i.i.i64 = call double @strtod(ptr noundef nonnull %add.ptr.i3.i63, ptr noundef nonnull %endptr.i.i.i54) #35
  %23 = load ptr, ptr %endptr.i.i.i54, align 8
  %cmp.i.i.i65 = icmp eq ptr %23, %add.ptr.i3.i63
  br i1 %cmp.i.i.i65, label %luaO_str2d.exit.thread.i.i87, label %if.end.i.i.i66

luaO_str2d.exit.thread.i.i87:                     ; preds = %land.lhs.true.i.i62
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i54)
  br label %if.then.i.i38

if.end.i.i.i66:                                   ; preds = %land.lhs.true.i.i62
  %24 = load i8, ptr %23, align 1
  switch i8 %24, label %if.end9.i.i.i71 [
    i8 120, label %if.then6.i.i.i67
    i8 88, label %if.then6.i.i.i67
  ]

if.then6.i.i.i67:                                 ; preds = %if.end.i.i.i66, %if.end.i.i.i66
  %call7.i.i.i68 = call i64 @strtoul(ptr noundef nonnull %add.ptr.i3.i63, ptr noundef nonnull %endptr.i.i.i54, i32 noundef 16) #35
  %.pre.i.i.i69 = load ptr, ptr %endptr.i.i.i54, align 8
  %.pre5.i.i.i70 = load i8, ptr %.pre.i.i.i69, align 1
  br label %if.end9.i.i.i71

if.end9.i.i.i71:                                  ; preds = %if.then6.i.i.i67, %if.end.i.i.i66
  %25 = phi i8 [ %24, %if.end.i.i.i66 ], [ %.pre5.i.i.i70, %if.then6.i.i.i67 ]
  %endptr.promoted.i.i.i72 = phi ptr [ %23, %if.end.i.i.i66 ], [ %.pre.i.i.i69, %if.then6.i.i.i67 ]
  %cmp11.i.i.i73 = icmp eq i8 %25, 0
  br i1 %cmp11.i.i.i73, label %luaO_str2d.exit.thread9.i.i86, label %while.cond.preheader.i.i.i74

luaO_str2d.exit.thread9.i.i86:                    ; preds = %if.end9.i.i.i71
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i54)
  br label %luaL_optinteger.exit40.thread

while.cond.preheader.i.i.i74:                     ; preds = %if.end9.i.i.i71
  %call15.i.i.i75 = tail call ptr @__ctype_b_loc() #39
  %26 = load ptr, ptr %call15.i.i.i75, align 8
  br label %while.cond.i.i.i76

while.cond.i.i.i76:                               ; preds = %while.cond.i.i.i76, %while.cond.preheader.i.i.i74
  %incdec.ptr4.i.i.i77 = phi ptr [ %endptr.promoted.i.i.i72, %while.cond.preheader.i.i.i74 ], [ %incdec.ptr.i.i.i81, %while.cond.i.i.i76 ]
  %27 = load i8, ptr %incdec.ptr4.i.i.i77, align 1
  %idxprom.i.i.i78 = zext i8 %27 to i64
  %arrayidx.i.i.i79 = getelementptr inbounds i16, ptr %26, i64 %idxprom.i.i.i78
  %28 = load i16, ptr %arrayidx.i.i.i79, align 2
  %29 = and i16 %28, 8192
  %tobool.not.i.i.i80 = icmp eq i16 %29, 0
  %incdec.ptr.i.i.i81 = getelementptr inbounds i8, ptr %incdec.ptr4.i.i.i77, i64 1
  br i1 %tobool.not.i.i.i80, label %luaO_str2d.exit.i.i82, label %while.cond.i.i.i76, !llvm.loop !35

luaO_str2d.exit.i.i82:                            ; preds = %while.cond.i.i.i76
  %cmp19.not.i.not.i.i83 = icmp eq i8 %27, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i54)
  br i1 %cmp19.not.i.not.i.i83, label %luaL_optinteger.exit40.thread, label %if.then.i.i38

if.then.i.i38:                                    ; preds = %land.lhs.true.i.i35, %luaO_str2d.exit.i.i82, %luaO_str2d.exit.thread.i.i87
  call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 3, ptr noundef nonnull @.str.24)
  unreachable

luaL_optinteger.exit40.thread:                    ; preds = %lua_type.exit.i29, %luaL_optinteger.exit.thread, %land.lhs.true.i.i35, %luaO_str2d.exit.i.i82, %luaO_str2d.exit.thread9.i.i86
  %cond.i26.ph = phi i64 [ 0, %land.lhs.true.i.i35 ], [ %cond.i21, %luaL_optinteger.exit.thread ], [ %cond.i21, %lua_type.exit.i29 ], [ 0, %luaO_str2d.exit.i.i82 ], [ 0, %luaO_str2d.exit.thread9.i.i86 ]
  %30 = load i64, ptr %l, align 8
  br label %32

luaL_optinteger.exit40:                           ; preds = %cond.false.i32
  %31 = load i64, ptr %l, align 8
  %cmp.i41 = icmp slt i64 %call.i.i33.fr, 0
  %add.i42 = add nsw i64 %31, 1
  %spec.select107 = select i1 %cmp.i41, i64 %add.i42, i64 0
  br label %32

32:                                               ; preds = %luaL_optinteger.exit40, %luaL_optinteger.exit40.thread
  %33 = phi i64 [ %30, %luaL_optinteger.exit40.thread ], [ %31, %luaL_optinteger.exit40 ]
  %cond.i26104 = phi i64 [ %cond.i26.ph, %luaL_optinteger.exit40.thread ], [ %call.i.i33.fr, %luaL_optinteger.exit40 ]
  %34 = phi i64 [ 0, %luaL_optinteger.exit40.thread ], [ %spec.select107, %luaL_optinteger.exit40 ]
  %pos.addr.0.i44 = add nsw i64 %34, %cond.i26104
  %cond.i45 = call i64 @llvm.smax.i64(i64 %pos.addr.0.i44, i64 0)
  %spec.store.select = call i64 @llvm.smax.i64(i64 %pos.addr.0.i, i64 1)
  %spec.select = call i64 @llvm.umin.i64(i64 %cond.i45, i64 %33)
  %cmp8 = icmp ugt i64 %spec.store.select, %spec.select
  br i1 %cmp8, label %return, label %if.end10

if.end10:                                         ; preds = %32
  %sub = sub nsw i64 %spec.select, %spec.store.select
  %35 = trunc i64 %sub to i32
  %conv = add i32 %35, 1
  %conv11 = sext i32 %conv to i64
  %add12 = add nsw i64 %spec.store.select, %conv11
  %cmp13.not = icmp sgt i64 %add12, %spec.select
  br i1 %cmp13.not, label %if.end17, label %if.then15

if.then15:                                        ; preds = %if.end10
  call void (ptr, ptr, ...) @luaL_error(ptr noundef %L, ptr noundef nonnull @.str.235)
  unreachable

if.end17:                                         ; preds = %if.end10
  %cmp.i.i46 = icmp sgt i32 %conv, 8000
  br i1 %cmp.i.i46, label %if.then.i47, label %lor.lhs.false.i.i

lor.lhs.false.i.i:                                ; preds = %if.end17
  %36 = load ptr, ptr %top.i.i.i, align 8
  %37 = load ptr, ptr %base.i.i.i, align 8
  %sub.ptr.lhs.cast.i.i = ptrtoint ptr %36 to i64
  %sub.ptr.rhs.cast.i.i = ptrtoint ptr %37 to i64
  %sub.ptr.sub.i.i = sub i64 %sub.ptr.lhs.cast.i.i, %sub.ptr.rhs.cast.i.i
  %sub.ptr.div.i.i = ashr exact i64 %sub.ptr.sub.i.i, 4
  %add.i.i = add nsw i64 %sub.ptr.div.i.i, %conv11
  %cmp1.i.i = icmp sgt i64 %add.i.i, 8000
  br i1 %cmp1.i.i, label %if.then.i47, label %if.else.i.i

if.else.i.i:                                      ; preds = %lor.lhs.false.i.i
  %cmp3.i.i = icmp ult i32 %35, 2147483647
  br i1 %cmp3.i.i, label %if.then5.i.i, label %return

if.then5.i.i:                                     ; preds = %if.else.i.i
  %stack_last.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 9
  %38 = load ptr, ptr %stack_last.i.i, align 8
  %sub.ptr.lhs.cast7.i.i = ptrtoint ptr %38 to i64
  %sub.ptr.sub9.i.i = sub i64 %sub.ptr.lhs.cast7.i.i, %sub.ptr.lhs.cast.i.i
  %mul.i.i = shl nuw nsw i32 %conv, 4
  %conv10.i.i = zext nneg i32 %mul.i.i to i64
  %cmp11.not.i.i = icmp sgt i64 %sub.ptr.sub9.i.i, %conv10.i.i
  br i1 %cmp11.not.i.i, label %if.end.i.i, label %if.then13.i.i

if.then13.i.i:                                    ; preds = %if.then5.i.i
  %stacksize.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 13
  %39 = load i32, ptr %stacksize.i.i.i, align 8
  %cmp.not.i.i.i = icmp slt i32 %39, %conv
  %add.i.i.i = add nsw i32 %39, %conv
  %mul.i.i.i = shl nsw i32 %39, 1
  %add.sink.i.i.i = select i1 %cmp.not.i.i.i, i32 %add.i.i.i, i32 %mul.i.i.i
  call fastcc void @luaD_reallocstack(ptr noundef nonnull %L, i32 noundef %add.sink.i.i.i)
  %.pre.i.i = load ptr, ptr %top.i.i.i, align 8
  br label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then13.i.i, %if.then5.i.i
  %40 = phi ptr [ %36, %if.then5.i.i ], [ %.pre.i.i, %if.then13.i.i ]
  %ci.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %41 = load ptr, ptr %ci.i.i, align 8
  %top15.i.i = getelementptr inbounds %struct.CallInfo, ptr %41, i64 0, i32 2
  %42 = load ptr, ptr %top15.i.i, align 8
  %add.ptr.i.i = getelementptr inbounds %struct.lua_TValue, ptr %40, i64 %conv11
  %cmp17.i.i = icmp ult ptr %42, %add.ptr.i.i
  br i1 %cmp17.i.i, label %if.then19.i.i, label %for.body.lr.ph

if.then19.i.i:                                    ; preds = %if.end.i.i
  store ptr %add.ptr.i.i, ptr %top15.i.i, align 8
  br label %for.body.lr.ph

if.then.i47:                                      ; preds = %lor.lhs.false.i.i, %if.end17
  call void (ptr, ptr, ...) @luaL_error(ptr noundef %L, ptr noundef nonnull @.str.193, ptr noundef nonnull @.str.235)
  unreachable

for.body.lr.ph:                                   ; preds = %if.end.i.i, %if.then19.i.i
  %43 = getelementptr i8, ptr %call.i, i64 %spec.store.select
  %invariant.gep = getelementptr i8, ptr %43, i64 -1
  %wide.trip.count = zext nneg i32 %conv to i64
  %.pre = load ptr, ptr %top.i.i.i, align 8
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.body
  %44 = phi ptr [ %.pre, %for.body.lr.ph ], [ %incdec.ptr.i, %for.body ]
  %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ]
  %gep = getelementptr i8, ptr %invariant.gep, i64 %indvars.iv
  %45 = load i8, ptr %gep, align 1
  %conv.i = uitofp i8 %45 to double
  store double %conv.i, ptr %44, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %44, i64 0, i32 1
  store i32 3, ptr %tt.i, align 8
  %46 = load ptr, ptr %top.i.i.i, align 8
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %46, i64 1
  store ptr %incdec.ptr.i, ptr %top.i.i.i, align 8
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %return, label %for.body, !llvm.loop !140

return:                                           ; preds = %for.body, %if.else.i.i, %32
  %retval.0 = phi i32 [ 0, %32 ], [ %conv, %if.else.i.i ], [ %conv, %for.body ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @str_char(ptr noundef %L) #0 {
entry:
  %b = alloca %struct.luaL_Buffer, align 8
  %0 = getelementptr i8, ptr %L, i64 16
  %L.val = load ptr, ptr %0, align 8
  %1 = getelementptr i8, ptr %L, i64 24
  %L.val9 = load ptr, ptr %1, align 8
  %sub.ptr.lhs.cast.i = ptrtoint ptr %L.val to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %L.val9 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %sub.ptr.div.i = lshr exact i64 %sub.ptr.sub.i, 4
  %conv.i = trunc i64 %sub.ptr.div.i to i32
  %L1.i = getelementptr inbounds %struct.luaL_Buffer, ptr %b, i64 0, i32 2
  store ptr %L, ptr %L1.i, align 8
  %buffer.i = getelementptr inbounds %struct.luaL_Buffer, ptr %b, i64 0, i32 3
  store ptr %buffer.i, ptr %b, align 8
  %lvl.i = getelementptr inbounds %struct.luaL_Buffer, ptr %b, i64 0, i32 1
  store i32 0, ptr %lvl.i, align 8
  %cmp.not18 = icmp slt i32 %conv.i, 1
  br i1 %cmp.not18, label %for.end, label %for.body.lr.ph

for.body.lr.ph:                                   ; preds = %entry
  %add.ptr = getelementptr inbounds %struct.luaL_Buffer, ptr %b, i64 1
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %lor.end12
  %i.019 = phi i32 [ 1, %for.body.lr.ph ], [ %inc, %lor.end12 ]
  %call.i = call fastcc i64 @lua_tointeger(ptr noundef %L, i32 noundef %i.019)
  %cmp.i = icmp eq i64 %call.i, 0
  br i1 %cmp.i, label %land.lhs.true.i, label %luaL_checkinteger.exit

land.lhs.true.i:                                  ; preds = %for.body
  %call1.i = call fastcc i32 @lua_isnumber(ptr noundef %L, i32 noundef %i.019), !range !23
  %tobool.not.i = icmp eq i32 %call1.i, 0
  br i1 %tobool.not.i, label %if.then.i, label %lor.end

if.then.i:                                        ; preds = %land.lhs.true.i
  call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef %i.019, ptr noundef nonnull @.str.24)
  unreachable

luaL_checkinteger.exit:                           ; preds = %for.body
  %conv2 = trunc i64 %call.i to i8
  %2 = and i64 %call.i, 4294967040
  %cmp4 = icmp eq i64 %2, 0
  br i1 %cmp4, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %luaL_checkinteger.exit
  call fastcc void @luaL_argerror(ptr noundef %L, i32 noundef %i.019, ptr noundef nonnull @.str.236)
  unreachable

lor.end:                                          ; preds = %land.lhs.true.i, %luaL_checkinteger.exit
  %conv224 = phi i8 [ %conv2, %luaL_checkinteger.exit ], [ 0, %land.lhs.true.i ]
  %3 = load ptr, ptr %b, align 8
  %cmp7 = icmp ult ptr %3, %add.ptr
  br i1 %cmp7, label %lor.end12, label %lor.rhs9

lor.rhs9:                                         ; preds = %lor.end
  %call.i10 = call fastcc i32 @emptybuffer(ptr noundef nonnull %b), !range !23
  %tobool.not.i11 = icmp eq i32 %call.i10, 0
  br i1 %tobool.not.i11, label %lor.end12, label %if.then.i12

if.then.i12:                                      ; preds = %lor.rhs9
  call fastcc void @adjuststack(ptr noundef nonnull %b)
  br label %lor.end12

lor.end12:                                        ; preds = %if.then.i12, %lor.rhs9, %lor.end
  %4 = load ptr, ptr %b, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %4, i64 1
  store ptr %incdec.ptr, ptr %b, align 8
  store i8 %conv224, ptr %4, align 1
  %inc = add nuw i32 %i.019, 1
  %exitcond.not = icmp eq i32 %i.019, %conv.i
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !141

for.end:                                          ; preds = %lor.end12, %entry
  %call.i14 = call fastcc i32 @emptybuffer(ptr noundef nonnull %b), !range !23
  %5 = load ptr, ptr %L1.i, align 8
  %6 = load i32, ptr %lvl.i, align 8
  call fastcc void @lua_concat(ptr noundef %5, i32 noundef %6)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @str_find(ptr noundef %L) #0 {
entry:
  %call = tail call fastcc i32 @str_find_aux(ptr noundef %L, i32 noundef 1)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @str_format(ptr noundef %L) #0 {
entry:
  %vl.i = alloca i64, align 8
  %l.i = alloca i64, align 8
  %sfl = alloca i64, align 8
  %b = alloca %struct.luaL_Buffer, align 8
  %form = alloca [18 x i8], align 16
  %buff = alloca [512 x i8], align 16
  %l = alloca i64, align 8
  %0 = getelementptr i8, ptr %L, i64 16
  %L.val = load ptr, ptr %0, align 8
  %1 = getelementptr i8, ptr %L, i64 24
  %L.val30 = load ptr, ptr %1, align 8
  %sub.ptr.lhs.cast.i = ptrtoint ptr %L.val to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %L.val30 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %sub.ptr.div.i = lshr exact i64 %sub.ptr.sub.i, 4
  %conv.i = trunc i64 %sub.ptr.div.i to i32
  %call.i = call fastcc ptr @lua_tolstring(ptr noundef %L, i32 noundef 1, ptr noundef nonnull %sfl)
  %tobool.not.i = icmp eq ptr %call.i, null
  br i1 %tobool.not.i, label %if.then.i, label %luaL_checklstring.exit

if.then.i:                                        ; preds = %entry
  call fastcc void @luaL_typerror(ptr noundef nonnull %L, i32 noundef 1, ptr noundef nonnull @.str.25)
  unreachable

luaL_checklstring.exit:                           ; preds = %entry
  %2 = load i64, ptr %sfl, align 8
  %add.ptr = getelementptr inbounds i8, ptr %call.i, i64 %2
  %L1.i = getelementptr inbounds %struct.luaL_Buffer, ptr %b, i64 0, i32 2
  store ptr %L, ptr %L1.i, align 8
  %buffer.i = getelementptr inbounds %struct.luaL_Buffer, ptr %b, i64 0, i32 3
  store ptr %buffer.i, ptr %b, align 8
  %lvl.i = getelementptr inbounds %struct.luaL_Buffer, ptr %b, i64 0, i32 1
  store i32 0, ptr %lvl.i, align 8
  %cmp159 = icmp sgt i64 %2, 0
  br i1 %cmp159, label %while.body.lr.ph, label %while.end

while.body.lr.ph:                                 ; preds = %luaL_checklstring.exit
  %add.ptr4 = getelementptr inbounds %struct.luaL_Buffer, ptr %b, i64 1
  %incdec.ptr60.i = getelementptr inbounds i8, ptr %form, i64 1
  %l_gt.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 22
  %ci.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %env.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23
  %tt.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23, i32 1
  %l_G.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %sub.ptr.rhs.cast.i101 = ptrtoint ptr %buffer.i to i64
  %sub.ptr.sub.neg.i = add i64 %sub.ptr.rhs.cast.i101, 8192
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %while.cond.backedge
  %arg.0161 = phi i32 [ 1, %while.body.lr.ph ], [ %arg.0.be, %while.cond.backedge ]
  %strfrmt.0160 = phi ptr [ %call.i, %while.body.lr.ph ], [ %strfrmt.0.be, %while.cond.backedge ]
  %3 = load i8, ptr %strfrmt.0160, align 1
  %cmp2.not = icmp eq i8 %3, 37
  br i1 %cmp2.not, label %if.else, label %if.then

if.then:                                          ; preds = %while.body
  %4 = load ptr, ptr %b, align 8
  %cmp5 = icmp ult ptr %4, %add.ptr4
  br i1 %cmp5, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.then
  %call.i31 = call fastcc i32 @emptybuffer(ptr noundef nonnull %b), !range !23
  %tobool.not.i32 = icmp eq i32 %call.i31, 0
  br i1 %tobool.not.i32, label %lor.end, label %if.then.i33

if.then.i33:                                      ; preds = %lor.rhs
  call fastcc void @adjuststack(ptr noundef nonnull %b)
  br label %lor.end

lor.end:                                          ; preds = %if.then.i33, %lor.rhs, %if.then
  %incdec.ptr = getelementptr inbounds i8, ptr %strfrmt.0160, i64 1
  %5 = load i8, ptr %strfrmt.0160, align 1
  %6 = load ptr, ptr %b, align 8
  %incdec.ptr9 = getelementptr inbounds i8, ptr %6, i64 1
  store ptr %incdec.ptr9, ptr %b, align 8
  store i8 %5, ptr %6, align 1
  br label %while.cond.backedge

if.else:                                          ; preds = %while.body
  %incdec.ptr10 = getelementptr inbounds i8, ptr %strfrmt.0160, i64 1
  %7 = load i8, ptr %incdec.ptr10, align 1
  %cmp12 = icmp eq i8 %7, 37
  br i1 %cmp12, label %if.then14, label %if.else29

if.then14:                                        ; preds = %if.else
  %8 = load ptr, ptr %b, align 8
  %cmp19 = icmp ult ptr %8, %add.ptr4
  br i1 %cmp19, label %lor.end24, label %lor.rhs21

lor.rhs21:                                        ; preds = %if.then14
  %call.i35 = call fastcc i32 @emptybuffer(ptr noundef nonnull %b), !range !23
  %tobool.not.i36 = icmp eq i32 %call.i35, 0
  br i1 %tobool.not.i36, label %lor.end24, label %if.then.i37

if.then.i37:                                      ; preds = %lor.rhs21
  call fastcc void @adjuststack(ptr noundef nonnull %b)
  br label %lor.end24

lor.end24:                                        ; preds = %if.then.i37, %lor.rhs21, %if.then14
  %incdec.ptr26 = getelementptr inbounds i8, ptr %strfrmt.0160, i64 2
  %9 = load i8, ptr %incdec.ptr10, align 1
  %10 = load ptr, ptr %b, align 8
  %incdec.ptr28 = getelementptr inbounds i8, ptr %10, i64 1
  store ptr %incdec.ptr28, ptr %b, align 8
  store i8 %9, ptr %10, align 1
  br label %while.cond.backedge

if.else29:                                        ; preds = %if.else
  %inc = add nsw i32 %arg.0161, 1
  %cmp30.not = icmp slt i32 %arg.0161, %conv.i
  br i1 %cmp30.not, label %if.end, label %if.then32

if.then32:                                        ; preds = %if.else29
  call fastcc void @luaL_argerror(ptr noundef %L, i32 noundef %inc, ptr noundef nonnull @.str.131)
  unreachable

if.end:                                           ; preds = %if.else29
  %cmp.not31.i = icmp eq i8 %7, 0
  br i1 %cmp.not31.i, label %while.end.i, label %land.rhs.i

land.rhs.i:                                       ; preds = %if.end, %while.body.i
  %11 = phi i8 [ %14, %while.body.i ], [ %7, %if.end ]
  %p.032.i = phi ptr [ %incdec.ptr.i, %while.body.i ], [ %incdec.ptr10, %if.end ]
  %conv.i40 = zext nneg i8 %11 to i64
  %memchr.bounds.i = icmp ugt i8 %11, 63
  %12 = shl nuw i64 1, %conv.i40
  %13 = and i64 %12, 325494096527361
  %memchr.bits.i = icmp eq i64 %13, 0
  %memchr26.not.i = select i1 %memchr.bounds.i, i1 true, i1 %memchr.bits.i
  br i1 %memchr26.not.i, label %while.end.loopexit.i, label %while.body.i

while.body.i:                                     ; preds = %land.rhs.i
  %incdec.ptr.i = getelementptr inbounds i8, ptr %p.032.i, i64 1
  %14 = load i8, ptr %incdec.ptr.i, align 1
  %cmp.not.i = icmp eq i8 %14, 0
  br i1 %cmp.not.i, label %while.end.loopexit.i, label %land.rhs.i, !llvm.loop !142

while.end.loopexit.i:                             ; preds = %land.rhs.i, %while.body.i
  %15 = phi i8 [ 0, %while.body.i ], [ %11, %land.rhs.i ]
  %p.0.lcssa.ph.i = phi ptr [ %incdec.ptr.i, %while.body.i ], [ %p.032.i, %land.rhs.i ]
  %16 = zext i8 %15 to i64
  br label %while.end.i

while.end.i:                                      ; preds = %while.end.loopexit.i, %if.end
  %idxprom.i = phi i64 [ 0, %if.end ], [ %16, %while.end.loopexit.i ]
  %p.0.lcssa.i = phi ptr [ %incdec.ptr10, %if.end ], [ %p.0.lcssa.ph.i, %while.end.loopexit.i ]
  %sub.ptr.lhs.cast.i41 = ptrtoint ptr %p.0.lcssa.i to i64
  %sub.ptr.rhs.cast.i42 = ptrtoint ptr %incdec.ptr10 to i64
  %sub.ptr.sub.i43 = sub i64 %sub.ptr.lhs.cast.i41, %sub.ptr.rhs.cast.i42
  %cmp5.i = icmp ugt i64 %sub.ptr.sub.i43, 5
  br i1 %cmp5.i, label %if.then.i44, label %if.end.i

if.then.i44:                                      ; preds = %while.end.i
  call void (ptr, ptr, ...) @luaL_error(ptr noundef %L, ptr noundef nonnull @.str.248)
  unreachable

if.end.i:                                         ; preds = %while.end.i
  %call8.i = tail call ptr @__ctype_b_loc() #39
  %17 = load ptr, ptr %call8.i, align 8
  %arrayidx.i = getelementptr inbounds i16, ptr %17, i64 %idxprom.i
  %18 = load i16, ptr %arrayidx.i, align 2
  %19 = lshr i16 %18, 11
  %.lobit.i = and i16 %19, 1
  %spec.select.idx.i = zext nneg i16 %.lobit.i to i64
  %spec.select.i = getelementptr inbounds i8, ptr %p.0.lcssa.i, i64 %spec.select.idx.i
  %20 = load i8, ptr %spec.select.i, align 1
  %idxprom16.i = zext i8 %20 to i64
  %arrayidx17.i = getelementptr inbounds i16, ptr %17, i64 %idxprom16.i
  %21 = load i16, ptr %arrayidx17.i, align 2
  %22 = lshr i16 %21, 11
  %.lobit29.i = and i16 %22, 1
  %p.2.idx.i = zext nneg i16 %.lobit29.i to i64
  %p.2.i = getelementptr inbounds i8, ptr %spec.select.i, i64 %p.2.idx.i
  %23 = load i8, ptr %p.2.i, align 1
  %cmp25.i = icmp eq i8 %23, 46
  br i1 %cmp25.i, label %if.then27.i, label %if.end49.i

if.then27.i:                                      ; preds = %if.end.i
  %incdec.ptr28.i = getelementptr inbounds i8, ptr %p.2.i, i64 1
  %24 = load i8, ptr %incdec.ptr28.i, align 1
  %idxprom31.i = zext i8 %24 to i64
  %arrayidx32.i = getelementptr inbounds i16, ptr %17, i64 %idxprom31.i
  %25 = load i16, ptr %arrayidx32.i, align 2
  %26 = and i16 %25, 2048
  %tobool35.not.i = icmp eq i16 %26, 0
  %incdec.ptr37.i = getelementptr inbounds i8, ptr %p.2.i, i64 2
  %spec.select27.i = select i1 %tobool35.not.i, ptr %incdec.ptr28.i, ptr %incdec.ptr37.i
  %27 = load i8, ptr %spec.select27.i, align 1
  %idxprom41.i = zext i8 %27 to i64
  %arrayidx42.i = getelementptr inbounds i16, ptr %17, i64 %idxprom41.i
  %28 = load i16, ptr %arrayidx42.i, align 2
  %29 = lshr i16 %28, 11
  %.lobit30.i = and i16 %29, 1
  %spec.select28.idx.i = zext nneg i16 %.lobit30.i to i64
  %spec.select28.i = getelementptr inbounds i8, ptr %spec.select27.i, i64 %spec.select28.idx.i
  %.pre.i = load i8, ptr %spec.select28.i, align 1
  br label %if.end49.i

if.end49.i:                                       ; preds = %if.then27.i, %if.end.i
  %30 = phi i8 [ %23, %if.end.i ], [ %.pre.i, %if.then27.i ]
  %p.4.i = phi ptr [ %p.2.i, %if.end.i ], [ %spec.select28.i, %if.then27.i ]
  %idxprom52.i = zext i8 %30 to i64
  %arrayidx53.i = getelementptr inbounds i16, ptr %17, i64 %idxprom52.i
  %31 = load i16, ptr %arrayidx53.i, align 2
  %32 = and i16 %31, 2048
  %tobool56.not.i = icmp eq i16 %32, 0
  br i1 %tobool56.not.i, label %scanformat.exit, label %if.then57.i

if.then57.i:                                      ; preds = %if.end49.i
  call void (ptr, ptr, ...) @luaL_error(ptr noundef %L, ptr noundef nonnull @.str.249)
  unreachable

scanformat.exit:                                  ; preds = %if.end49.i
  store i8 37, ptr %form, align 16
  %sub.ptr.lhs.cast61.i = ptrtoint ptr %p.4.i to i64
  %sub.ptr.sub63.i = sub i64 %sub.ptr.lhs.cast61.i, %sub.ptr.rhs.cast.i42
  %add.i = add nsw i64 %sub.ptr.sub63.i, 1
  %call64.i = call ptr @strncpy(ptr noundef nonnull %incdec.ptr60.i, ptr noundef nonnull %incdec.ptr10, i64 noundef %add.i) #35
  %add.ptr.i = getelementptr inbounds i8, ptr %incdec.ptr60.i, i64 %add.i
  store i8 0, ptr %add.ptr.i, align 1
  %incdec.ptr36 = getelementptr inbounds i8, ptr %p.4.i, i64 1
  %33 = load i8, ptr %p.4.i, align 1
  %conv37 = sext i8 %33 to i32
  switch i32 %conv37, label %sw.default [
    i32 99, label %sw.bb
    i32 100, label %sw.bb43
    i32 105, label %sw.bb43
    i32 111, label %sw.bb50
    i32 117, label %sw.bb50
    i32 120, label %sw.bb50
    i32 88, label %sw.bb50
    i32 101, label %sw.bb57
    i32 69, label %sw.bb57
    i32 102, label %sw.bb57
    i32 103, label %sw.bb57
    i32 71, label %sw.bb57
    i32 113, label %sw.bb62
    i32 115, label %sw.bb63
  ]

sw.bb:                                            ; preds = %scanformat.exit
  %call.i45 = call fastcc double @lua_tonumber(ptr noundef %L, i32 noundef %inc)
  %cmp.i = fcmp oeq double %call.i45, 0.000000e+00
  br i1 %cmp.i, label %land.lhs.true.i, label %luaL_checknumber.exit

land.lhs.true.i:                                  ; preds = %sw.bb
  %call1.i = call fastcc i32 @lua_isnumber(ptr noundef %L, i32 noundef %inc), !range !23
  %tobool.not.i47 = icmp eq i32 %call1.i, 0
  br i1 %tobool.not.i47, label %if.then.i48, label %luaL_checknumber.exit

if.then.i48:                                      ; preds = %land.lhs.true.i
  call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef %inc, ptr noundef nonnull @.str.24)
  unreachable

luaL_checknumber.exit:                            ; preds = %sw.bb, %land.lhs.true.i
  %conv41 = fptosi double %call.i45 to i32
  %call42 = call i32 (ptr, ptr, ...) @sprintf(ptr noundef nonnull dereferenceable(1) %buff, ptr noundef nonnull dereferenceable(1) %form, i32 noundef %conv41) #35
  br label %sw.epilog

sw.bb43:                                          ; preds = %scanformat.exit, %scanformat.exit
  %call.i50 = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %form) #34
  %34 = getelementptr i8, ptr %form, i64 %call.i50
  %arrayidx.i51 = getelementptr i8, ptr %34, i64 -1
  %35 = load i8, ptr %arrayidx.i51, align 1
  store i16 108, ptr %arrayidx.i51, align 1
  store i8 %35, ptr %34, align 1
  %arrayidx7.i = getelementptr i8, ptr %34, i64 1
  store i8 0, ptr %arrayidx7.i, align 1
  %call.i52 = call fastcc double @lua_tonumber(ptr noundef %L, i32 noundef %inc)
  %cmp.i53 = fcmp oeq double %call.i52, 0.000000e+00
  br i1 %cmp.i53, label %land.lhs.true.i55, label %luaL_checknumber.exit60

land.lhs.true.i55:                                ; preds = %sw.bb43
  %call1.i56 = call fastcc i32 @lua_isnumber(ptr noundef %L, i32 noundef %inc), !range !23
  %tobool.not.i57 = icmp eq i32 %call1.i56, 0
  br i1 %tobool.not.i57, label %if.then.i58, label %luaL_checknumber.exit60

if.then.i58:                                      ; preds = %land.lhs.true.i55
  call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef %inc, ptr noundef nonnull @.str.24)
  unreachable

luaL_checknumber.exit60:                          ; preds = %sw.bb43, %land.lhs.true.i55
  %conv48 = fptosi double %call.i52 to i64
  %call49 = call i32 (ptr, ptr, ...) @sprintf(ptr noundef nonnull dereferenceable(1) %buff, ptr noundef nonnull dereferenceable(1) %form, i64 noundef %conv48) #35
  br label %sw.epilog

sw.bb50:                                          ; preds = %scanformat.exit, %scanformat.exit, %scanformat.exit, %scanformat.exit
  %call.i61 = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %form) #34
  %36 = getelementptr i8, ptr %form, i64 %call.i61
  %arrayidx.i62 = getelementptr i8, ptr %36, i64 -1
  %37 = load i8, ptr %arrayidx.i62, align 1
  store i16 108, ptr %arrayidx.i62, align 1
  store i8 %37, ptr %36, align 1
  %arrayidx7.i63 = getelementptr i8, ptr %36, i64 1
  store i8 0, ptr %arrayidx7.i63, align 1
  %call.i64 = call fastcc double @lua_tonumber(ptr noundef %L, i32 noundef %inc)
  %cmp.i65 = fcmp oeq double %call.i64, 0.000000e+00
  br i1 %cmp.i65, label %land.lhs.true.i67, label %luaL_checknumber.exit72

land.lhs.true.i67:                                ; preds = %sw.bb50
  %call1.i68 = call fastcc i32 @lua_isnumber(ptr noundef %L, i32 noundef %inc), !range !23
  %tobool.not.i69 = icmp eq i32 %call1.i68, 0
  br i1 %tobool.not.i69, label %if.then.i70, label %luaL_checknumber.exit72

if.then.i70:                                      ; preds = %land.lhs.true.i67
  call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef %inc, ptr noundef nonnull @.str.24)
  unreachable

luaL_checknumber.exit72:                          ; preds = %sw.bb50, %land.lhs.true.i67
  %conv55 = fptoui double %call.i64 to i64
  %call56 = call i32 (ptr, ptr, ...) @sprintf(ptr noundef nonnull dereferenceable(1) %buff, ptr noundef nonnull dereferenceable(1) %form, i64 noundef %conv55) #35
  br label %sw.epilog

sw.bb57:                                          ; preds = %scanformat.exit, %scanformat.exit, %scanformat.exit, %scanformat.exit, %scanformat.exit
  %call.i73 = call fastcc double @lua_tonumber(ptr noundef %L, i32 noundef %inc)
  %cmp.i74 = fcmp oeq double %call.i73, 0.000000e+00
  br i1 %cmp.i74, label %land.lhs.true.i76, label %luaL_checknumber.exit81

land.lhs.true.i76:                                ; preds = %sw.bb57
  %call1.i77 = call fastcc i32 @lua_isnumber(ptr noundef %L, i32 noundef %inc), !range !23
  %tobool.not.i78 = icmp eq i32 %call1.i77, 0
  br i1 %tobool.not.i78, label %if.then.i79, label %luaL_checknumber.exit81

if.then.i79:                                      ; preds = %land.lhs.true.i76
  call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef %inc, ptr noundef nonnull @.str.24)
  unreachable

luaL_checknumber.exit81:                          ; preds = %sw.bb57, %land.lhs.true.i76
  %call61 = call i32 (ptr, ptr, ...) @sprintf(ptr noundef nonnull dereferenceable(1) %buff, ptr noundef nonnull dereferenceable(1) %form, double noundef %call.i73) #35
  br label %sw.epilog

sw.bb62:                                          ; preds = %scanformat.exit
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %l.i)
  %call.i.i = call fastcc ptr @lua_tolstring(ptr noundef %L, i32 noundef %inc, ptr noundef nonnull %l.i)
  %tobool.not.i.i = icmp eq ptr %call.i.i, null
  br i1 %tobool.not.i.i, label %if.then.i.i, label %luaL_checklstring.exit.i

if.then.i.i:                                      ; preds = %sw.bb62
  call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef %inc, ptr noundef nonnull @.str.25)
  unreachable

luaL_checklstring.exit.i:                         ; preds = %sw.bb62
  %38 = load ptr, ptr %b, align 8
  %cmp.i83 = icmp ult ptr %38, %add.ptr4
  br i1 %cmp.i83, label %lor.end.i, label %lor.rhs.i

lor.rhs.i:                                        ; preds = %luaL_checklstring.exit.i
  %call.i25.i = call fastcc i32 @emptybuffer(ptr noundef nonnull %b), !range !23
  %tobool.not.i26.i = icmp eq i32 %call.i25.i, 0
  br i1 %tobool.not.i26.i, label %lor.end.i, label %if.then.i27.i

if.then.i27.i:                                    ; preds = %lor.rhs.i
  call fastcc void @adjuststack(ptr noundef nonnull %b)
  br label %lor.end.i

lor.end.i:                                        ; preds = %if.then.i27.i, %lor.rhs.i, %luaL_checklstring.exit.i
  %39 = load ptr, ptr %b, align 8
  %incdec.ptr.i84 = getelementptr inbounds i8, ptr %39, i64 1
  store ptr %incdec.ptr.i84, ptr %b, align 8
  store i8 34, ptr %39, align 1
  %40 = load i64, ptr %l.i, align 8
  %dec65.i = add i64 %40, -1
  store i64 %dec65.i, ptr %l.i, align 8
  %tobool3.not66.i = icmp eq i64 %40, 0
  br i1 %tobool3.not66.i, label %while.end.i87, label %while.body.i85

while.body.i85:                                   ; preds = %lor.end.i, %sw.epilog.i
  %s.067.i = phi ptr [ %incdec.ptr45.i, %sw.epilog.i ], [ %call.i.i, %lor.end.i ]
  %41 = load i8, ptr %s.067.i, align 1
  %conv.i86 = sext i8 %41 to i32
  switch i32 %conv.i86, label %sw.default.i [
    i32 34, label %sw.bb.i
    i32 92, label %sw.bb.i
    i32 10, label %sw.bb.i
    i32 13, label %while.body.i.i
    i32 0, label %while.body.i40.i
  ]

sw.bb.i:                                          ; preds = %while.body.i85, %while.body.i85, %while.body.i85
  %42 = load ptr, ptr %b, align 8
  %cmp8.i = icmp ult ptr %42, %add.ptr4
  br i1 %cmp8.i, label %lor.end13.i, label %lor.rhs10.i

lor.rhs10.i:                                      ; preds = %sw.bb.i
  %call.i28.i = call fastcc i32 @emptybuffer(ptr noundef nonnull %b), !range !23
  %tobool.not.i29.i = icmp eq i32 %call.i28.i, 0
  br i1 %tobool.not.i29.i, label %lor.end13.i, label %if.then.i30.i

if.then.i30.i:                                    ; preds = %lor.rhs10.i
  call fastcc void @adjuststack(ptr noundef nonnull %b)
  br label %lor.end13.i

lor.end13.i:                                      ; preds = %if.then.i30.i, %lor.rhs10.i, %sw.bb.i
  %43 = load ptr, ptr %b, align 8
  %incdec.ptr16.i = getelementptr inbounds i8, ptr %43, i64 1
  store ptr %incdec.ptr16.i, ptr %b, align 8
  store i8 92, ptr %43, align 1
  %44 = load ptr, ptr %b, align 8
  %cmp21.i = icmp ult ptr %44, %add.ptr4
  br i1 %cmp21.i, label %lor.end26.i, label %lor.rhs23.i

lor.rhs23.i:                                      ; preds = %lor.end13.i
  %call.i33.i = call fastcc i32 @emptybuffer(ptr noundef nonnull %b), !range !23
  %tobool.not.i34.i = icmp eq i32 %call.i33.i, 0
  br i1 %tobool.not.i34.i, label %lor.end26.i, label %if.then.i35.i

if.then.i35.i:                                    ; preds = %lor.rhs23.i
  call fastcc void @adjuststack(ptr noundef nonnull %b)
  br label %lor.end26.i

lor.end26.i:                                      ; preds = %if.then.i35.i, %lor.rhs23.i, %lor.end13.i
  %45 = load i8, ptr %s.067.i, align 1
  %46 = load ptr, ptr %b, align 8
  %incdec.ptr29.i = getelementptr inbounds i8, ptr %46, i64 1
  store ptr %incdec.ptr29.i, ptr %b, align 8
  store i8 %45, ptr %46, align 1
  br label %sw.epilog.i

while.body.i.i:                                   ; preds = %while.body.i85, %lor.end.i.i
  %dec7.in.i.i = phi i64 [ %dec7.i.i, %lor.end.i.i ], [ 2, %while.body.i85 ]
  %s.addr.06.i.i = phi ptr [ %incdec.ptr.i.i, %lor.end.i.i ], [ @.str.251, %while.body.i85 ]
  %dec7.i.i = add nsw i64 %dec7.in.i.i, -1
  %47 = load ptr, ptr %b, align 8
  %cmp.i.i = icmp ult ptr %47, %add.ptr4
  br i1 %cmp.i.i, label %lor.end.i.i, label %lor.rhs.i.i

lor.rhs.i.i:                                      ; preds = %while.body.i.i
  %call.i.i.i = call fastcc i32 @emptybuffer(ptr noundef nonnull %b), !range !23
  %tobool.not.i.i.i = icmp eq i32 %call.i.i.i, 0
  br i1 %tobool.not.i.i.i, label %lor.end.i.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %lor.rhs.i.i
  call fastcc void @adjuststack(ptr noundef nonnull %b)
  br label %lor.end.i.i

lor.end.i.i:                                      ; preds = %if.then.i.i.i, %lor.rhs.i.i, %while.body.i.i
  %incdec.ptr.i.i = getelementptr inbounds i8, ptr %s.addr.06.i.i, i64 1
  %48 = load i8, ptr %s.addr.06.i.i, align 1
  %49 = load ptr, ptr %b, align 8
  %incdec.ptr3.i.i = getelementptr inbounds i8, ptr %49, i64 1
  store ptr %incdec.ptr3.i.i, ptr %b, align 8
  store i8 %48, ptr %49, align 1
  %tobool.not.i38.i = icmp eq i64 %dec7.i.i, 0
  br i1 %tobool.not.i38.i, label %sw.epilog.i, label %while.body.i.i, !llvm.loop !129

while.body.i40.i:                                 ; preds = %while.body.i85, %lor.end.i49.i
  %dec7.in.i41.i = phi i64 [ %dec7.i43.i, %lor.end.i49.i ], [ 4, %while.body.i85 ]
  %s.addr.06.i42.i = phi ptr [ %incdec.ptr.i50.i, %lor.end.i49.i ], [ @.str.252, %while.body.i85 ]
  %dec7.i43.i = add nsw i64 %dec7.in.i41.i, -1
  %50 = load ptr, ptr %b, align 8
  %cmp.i44.i = icmp ult ptr %50, %add.ptr4
  br i1 %cmp.i44.i, label %lor.end.i49.i, label %lor.rhs.i45.i

lor.rhs.i45.i:                                    ; preds = %while.body.i40.i
  %call.i.i46.i = call fastcc i32 @emptybuffer(ptr noundef nonnull %b), !range !23
  %tobool.not.i.i47.i = icmp eq i32 %call.i.i46.i, 0
  br i1 %tobool.not.i.i47.i, label %lor.end.i49.i, label %if.then.i.i48.i

if.then.i.i48.i:                                  ; preds = %lor.rhs.i45.i
  call fastcc void @adjuststack(ptr noundef nonnull %b)
  br label %lor.end.i49.i

lor.end.i49.i:                                    ; preds = %if.then.i.i48.i, %lor.rhs.i45.i, %while.body.i40.i
  %incdec.ptr.i50.i = getelementptr inbounds i8, ptr %s.addr.06.i42.i, i64 1
  %51 = load i8, ptr %s.addr.06.i42.i, align 1
  %52 = load ptr, ptr %b, align 8
  %incdec.ptr3.i51.i = getelementptr inbounds i8, ptr %52, i64 1
  store ptr %incdec.ptr3.i51.i, ptr %b, align 8
  store i8 %51, ptr %52, align 1
  %tobool.not.i52.i = icmp eq i64 %dec7.i43.i, 0
  br i1 %tobool.not.i52.i, label %sw.epilog.i, label %while.body.i40.i, !llvm.loop !129

sw.default.i:                                     ; preds = %while.body.i85
  %53 = load ptr, ptr %b, align 8
  %cmp36.i = icmp ult ptr %53, %add.ptr4
  br i1 %cmp36.i, label %lor.end41.i, label %lor.rhs38.i

lor.rhs38.i:                                      ; preds = %sw.default.i
  %call.i54.i = call fastcc i32 @emptybuffer(ptr noundef nonnull %b), !range !23
  %tobool.not.i55.i = icmp eq i32 %call.i54.i, 0
  br i1 %tobool.not.i55.i, label %lor.end41.i, label %if.then.i56.i

if.then.i56.i:                                    ; preds = %lor.rhs38.i
  call fastcc void @adjuststack(ptr noundef nonnull %b)
  br label %lor.end41.i

lor.end41.i:                                      ; preds = %if.then.i56.i, %lor.rhs38.i, %sw.default.i
  %54 = load i8, ptr %s.067.i, align 1
  %55 = load ptr, ptr %b, align 8
  %incdec.ptr44.i = getelementptr inbounds i8, ptr %55, i64 1
  store ptr %incdec.ptr44.i, ptr %b, align 8
  store i8 %54, ptr %55, align 1
  br label %sw.epilog.i

sw.epilog.i:                                      ; preds = %lor.end.i49.i, %lor.end.i.i, %lor.end41.i, %lor.end26.i
  %incdec.ptr45.i = getelementptr inbounds i8, ptr %s.067.i, i64 1
  %56 = load i64, ptr %l.i, align 8
  %dec.i = add i64 %56, -1
  store i64 %dec.i, ptr %l.i, align 8
  %tobool3.not.i = icmp eq i64 %56, 0
  br i1 %tobool3.not.i, label %while.end.i87, label %while.body.i85, !llvm.loop !143

while.end.i87:                                    ; preds = %sw.epilog.i, %lor.end.i
  %57 = load ptr, ptr %b, align 8
  %cmp50.i = icmp ult ptr %57, %add.ptr4
  br i1 %cmp50.i, label %addquoted.exit, label %lor.rhs52.i

lor.rhs52.i:                                      ; preds = %while.end.i87
  %call.i59.i = call fastcc i32 @emptybuffer(ptr noundef nonnull %b), !range !23
  %tobool.not.i60.i = icmp eq i32 %call.i59.i, 0
  br i1 %tobool.not.i60.i, label %addquoted.exit, label %if.then.i61.i

if.then.i61.i:                                    ; preds = %lor.rhs52.i
  call fastcc void @adjuststack(ptr noundef nonnull %b)
  br label %addquoted.exit

addquoted.exit:                                   ; preds = %while.end.i87, %lor.rhs52.i, %if.then.i61.i
  %58 = load ptr, ptr %b, align 8
  %incdec.ptr58.i = getelementptr inbounds i8, ptr %58, i64 1
  store ptr %incdec.ptr58.i, ptr %b, align 8
  store i8 34, ptr %58, align 1
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %l.i)
  br label %while.cond.backedge

while.cond.backedge:                              ; preds = %lor.end.i118, %lor.end, %lor.end24, %sw.epilog, %addquoted.exit, %luaL_addvalue.exit
  %strfrmt.0.be = phi ptr [ %incdec.ptr36, %luaL_addvalue.exit ], [ %incdec.ptr36, %addquoted.exit ], [ %incdec.ptr, %lor.end ], [ %incdec.ptr26, %lor.end24 ], [ %incdec.ptr36, %sw.epilog ], [ %incdec.ptr36, %lor.end.i118 ]
  %arg.0.be = phi i32 [ %inc, %luaL_addvalue.exit ], [ %inc, %addquoted.exit ], [ %arg.0161, %lor.end ], [ %arg.0161, %lor.end24 ], [ %inc, %sw.epilog ], [ %inc, %lor.end.i118 ]
  %cmp = icmp ult ptr %strfrmt.0.be, %add.ptr
  br i1 %cmp, label %while.body, label %while.end, !llvm.loop !144

sw.bb63:                                          ; preds = %scanformat.exit
  %call.i88 = call fastcc ptr @lua_tolstring(ptr noundef %L, i32 noundef %inc, ptr noundef nonnull %l)
  %tobool.not.i89 = icmp eq ptr %call.i88, null
  br i1 %tobool.not.i89, label %if.then.i91, label %luaL_checklstring.exit93

if.then.i91:                                      ; preds = %sw.bb63
  call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef %inc, ptr noundef nonnull @.str.25)
  unreachable

luaL_checklstring.exit93:                         ; preds = %sw.bb63
  %call66 = call ptr @strchr(ptr noundef nonnull dereferenceable(1) %form, i32 noundef 46) #34
  %tobool67 = icmp eq ptr %call66, null
  %59 = load i64, ptr %l, align 8
  %cmp68 = icmp ugt i64 %59, 99
  %or.cond = select i1 %tobool67, i1 %cmp68, i1 false
  br i1 %or.cond, label %if.then70, label %if.else71

if.then70:                                        ; preds = %luaL_checklstring.exit93
  %cmp.i.i94 = icmp sgt i32 %arg.0161, -1
  br i1 %cmp.i.i94, label %if.then.i.i96, label %if.else3.i.i

if.then.i.i96:                                    ; preds = %if.then70
  %60 = load ptr, ptr %1, align 8
  %61 = zext nneg i32 %inc to i64
  %62 = getelementptr %struct.lua_TValue, ptr %60, i64 %61
  %add.ptr.i.i = getelementptr %struct.lua_TValue, ptr %62, i64 -1
  %63 = load ptr, ptr %0, align 8
  %cmp1.not.i.i = icmp ult ptr %add.ptr.i.i, %63
  %add.ptr.luaO_nilobject_.i.i = select i1 %cmp1.not.i.i, ptr %add.ptr.i.i, ptr @luaO_nilobject_
  br label %lua_pushvalue.exit

if.else3.i.i:                                     ; preds = %if.then70
  %cmp4.i.i = icmp ugt i32 %arg.0161, -10001
  br i1 %cmp4.i.i, label %if.then5.i.i, label %if.else9.i.i

if.then5.i.i:                                     ; preds = %if.else3.i.i
  %64 = load ptr, ptr %0, align 8
  %idx.ext7.i.i = sext i32 %inc to i64
  %add.ptr8.i.i = getelementptr inbounds %struct.lua_TValue, ptr %64, i64 %idx.ext7.i.i
  br label %lua_pushvalue.exit

if.else9.i.i:                                     ; preds = %if.else3.i.i
  switch i32 %arg.0161, label %sw.default.i.i [
    i32 -10001, label %sw.bb.i.i
    i32 -10002, label %sw.bb10.i.i
    i32 -10003, label %lua_pushvalue.exit
  ]

sw.bb.i.i:                                        ; preds = %if.else9.i.i
  %65 = load ptr, ptr %l_G.i.i, align 8
  %l_registry.i.i = getelementptr inbounds %struct.global_State, ptr %65, i64 0, i32 20
  br label %lua_pushvalue.exit

sw.bb10.i.i:                                      ; preds = %if.else9.i.i
  %66 = load ptr, ptr %ci.i.i, align 8
  %func11.i.i = getelementptr inbounds %struct.CallInfo, ptr %66, i64 0, i32 1
  %67 = load ptr, ptr %func11.i.i, align 8
  %68 = load ptr, ptr %67, align 8
  %env12.i.i = getelementptr inbounds %struct.CClosure, ptr %68, i64 0, i32 6
  %69 = load ptr, ptr %env12.i.i, align 8
  store ptr %69, ptr %env.i.i, align 8
  store i32 5, ptr %tt.i.i, align 8
  br label %lua_pushvalue.exit

sw.default.i.i:                                   ; preds = %if.else9.i.i
  %70 = load ptr, ptr %ci.i.i, align 8
  %func18.i.i = getelementptr inbounds %struct.CallInfo, ptr %70, i64 0, i32 1
  %71 = load ptr, ptr %func18.i.i, align 8
  %72 = load ptr, ptr %71, align 8
  %sub20.i.i = sub nuw nsw i32 -10003, %arg.0161
  %nupvalues.i.i = getelementptr inbounds %struct.CClosure, ptr %72, i64 0, i32 4
  %73 = load i8, ptr %nupvalues.i.i, align 1
  %conv.i.i = zext i8 %73 to i32
  %cmp21.not.i.i = icmp ugt i32 %sub20.i.i, %conv.i.i
  %sub23.i.i = sub nuw nsw i32 -10004, %arg.0161
  %idxprom.i.i = zext nneg i32 %sub23.i.i to i64
  %arrayidx.i.i = getelementptr inbounds %struct.CClosure, ptr %72, i64 0, i32 8, i64 %idxprom.i.i
  %cond.i.i = select i1 %cmp21.not.i.i, ptr @luaO_nilobject_, ptr %arrayidx.i.i
  br label %lua_pushvalue.exit

lua_pushvalue.exit:                               ; preds = %if.else9.i.i, %if.then.i.i96, %if.then5.i.i, %sw.bb.i.i, %sw.bb10.i.i, %sw.default.i.i
  %retval.0.i.i = phi ptr [ %add.ptr8.i.i, %if.then5.i.i ], [ %cond.i.i, %sw.default.i.i ], [ %env.i.i, %sw.bb10.i.i ], [ %l_registry.i.i, %sw.bb.i.i ], [ %add.ptr.luaO_nilobject_.i.i, %if.then.i.i96 ], [ %l_gt.i.i, %if.else9.i.i ]
  %74 = load ptr, ptr %0, align 8
  %75 = load i64, ptr %retval.0.i.i, align 8
  store i64 %75, ptr %74, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i.i, i64 0, i32 1
  %76 = load i32, ptr %tt.i, align 8
  %tt2.i = getelementptr inbounds %struct.lua_TValue, ptr %74, i64 0, i32 1
  store i32 %76, ptr %tt2.i, align 8
  %77 = load ptr, ptr %0, align 8
  %incdec.ptr.i95 = getelementptr inbounds %struct.lua_TValue, ptr %77, i64 1
  store ptr %incdec.ptr.i95, ptr %0, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %vl.i)
  %78 = load ptr, ptr %L1.i, align 8
  %call.i98 = call fastcc ptr @lua_tolstring(ptr noundef %78, i32 noundef -1, ptr noundef nonnull %vl.i)
  %79 = load i64, ptr %vl.i, align 8
  %80 = load ptr, ptr %b, align 8
  %sub.ptr.lhs.cast.i100 = ptrtoint ptr %80 to i64
  %sub.i = sub i64 %sub.ptr.sub.neg.i, %sub.ptr.lhs.cast.i100
  %cmp.not.i102 = icmp ugt i64 %79, %sub.i
  br i1 %cmp.not.i102, label %if.else.i, label %if.then.i103

if.then.i103:                                     ; preds = %lua_pushvalue.exit
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %80, ptr align 1 %call.i98, i64 %79, i1 false)
  %81 = load i64, ptr %vl.i, align 8
  %82 = load ptr, ptr %b, align 8
  %add.ptr.i104 = getelementptr inbounds i8, ptr %82, i64 %81
  store ptr %add.ptr.i104, ptr %b, align 8
  %top.i.i105 = getelementptr inbounds %struct.lua_State, ptr %78, i64 0, i32 4
  %83 = load ptr, ptr %top.i.i105, align 8
  %add.ptr9.i.i = getelementptr %struct.lua_TValue, ptr %83, i64 -1
  store ptr %add.ptr9.i.i, ptr %top.i.i105, align 8
  br label %luaL_addvalue.exit

if.else.i:                                        ; preds = %lua_pushvalue.exit
  %call4.i = call fastcc i32 @emptybuffer(ptr noundef nonnull %b), !range !23
  %tobool.not.i106 = icmp eq i32 %call4.i, 0
  br i1 %tobool.not.i106, label %if.end.i109, label %if.then5.i

if.then5.i:                                       ; preds = %if.else.i
  %top6.i.i.i = getelementptr inbounds %struct.lua_State, ptr %78, i64 0, i32 4
  %84 = load ptr, ptr %top6.i.i.i, align 8
  br label %for.body.i.i

for.body.i.i:                                     ; preds = %for.body.i.i, %if.then5.i
  %q.012.i.idx.i = phi i64 [ %q.012.i.add.i, %for.body.i.i ], [ 0, %if.then5.i ]
  %q.012.i.ptr.i = getelementptr inbounds i8, ptr %84, i64 %q.012.i.idx.i
  %q.012.i.add.i = add nsw i64 %q.012.i.idx.i, -16
  %add.ptr.i.ptr.i = getelementptr inbounds i8, ptr %84, i64 %q.012.i.add.i
  %85 = load i64, ptr %add.ptr.i.ptr.i, align 8
  store i64 %85, ptr %q.012.i.ptr.i, align 8
  %tt.i.i107 = getelementptr %struct.lua_TValue, ptr %q.012.i.ptr.i, i64 -1, i32 1
  %86 = load i32, ptr %tt.i.i107, align 8
  %tt2.i.i = getelementptr inbounds %struct.lua_TValue, ptr %q.012.i.ptr.i, i64 0, i32 1
  store i32 %86, ptr %tt2.i.i, align 8
  %cmp.i.i108 = icmp sgt i64 %q.012.i.idx.i, -16
  br i1 %cmp.i.i108, label %for.body.i.i, label %lua_insert.exit.i, !llvm.loop !86

lua_insert.exit.i:                                ; preds = %for.body.i.i
  %add.ptr8.i.i.i = getelementptr inbounds %struct.lua_TValue, ptr %84, i64 -2
  %.pre.i.i = load ptr, ptr %top6.i.i.i, align 8
  %87 = load i64, ptr %.pre.i.i, align 8
  store i64 %87, ptr %add.ptr8.i.i.i, align 8
  %tt8.i.i = getelementptr inbounds %struct.lua_TValue, ptr %.pre.i.i, i64 0, i32 1
  %88 = load i32, ptr %tt8.i.i, align 8
  %tt9.i.i = getelementptr %struct.lua_TValue, ptr %84, i64 -2, i32 1
  store i32 %88, ptr %tt9.i.i, align 8
  br label %if.end.i109

if.end.i109:                                      ; preds = %lua_insert.exit.i, %if.else.i
  %89 = load i32, ptr %lvl.i, align 8
  %inc.i = add nsw i32 %89, 1
  store i32 %inc.i, ptr %lvl.i, align 8
  call fastcc void @adjuststack(ptr noundef nonnull %b)
  br label %luaL_addvalue.exit

luaL_addvalue.exit:                               ; preds = %if.then.i103, %if.end.i109
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %vl.i)
  br label %while.cond.backedge

if.else71:                                        ; preds = %luaL_checklstring.exit93
  %call74 = call i32 (ptr, ptr, ...) @sprintf(ptr noundef nonnull dereferenceable(1) %buff, ptr noundef nonnull dereferenceable(1) %form, ptr noundef nonnull %call.i88) #35
  br label %sw.epilog

sw.default:                                       ; preds = %scanformat.exit
  call void (ptr, ptr, ...) @luaL_error(ptr noundef %L, ptr noundef nonnull @.str.246, i32 noundef %conv37)
  unreachable

sw.epilog:                                        ; preds = %if.else71, %luaL_checknumber.exit81, %luaL_checknumber.exit72, %luaL_checknumber.exit60, %luaL_checknumber.exit
  %call80 = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %buff) #34
  %tobool.not5.i = icmp eq i64 %call80, 0
  br i1 %tobool.not5.i, label %while.cond.backedge, label %while.body.i112

while.body.i112:                                  ; preds = %sw.epilog, %lor.end.i118
  %dec7.in.i = phi i64 [ %dec7.i, %lor.end.i118 ], [ %call80, %sw.epilog ]
  %s.addr.06.i = phi ptr [ %incdec.ptr.i119, %lor.end.i118 ], [ %buff, %sw.epilog ]
  %dec7.i = add i64 %dec7.in.i, -1
  %90 = load ptr, ptr %b, align 8
  %cmp.i113 = icmp ult ptr %90, %add.ptr4
  br i1 %cmp.i113, label %lor.end.i118, label %if.else.i126

if.else.i126:                                     ; preds = %while.body.i112
  %sub.ptr.lhs.cast.i128 = ptrtoint ptr %90 to i64
  %sub.ptr.sub.i129 = sub i64 %sub.ptr.lhs.cast.i128, %sub.ptr.rhs.cast.i101
  %91 = load ptr, ptr %L1.i, align 8
  %l_G.i.i131 = getelementptr inbounds %struct.lua_State, ptr %91, i64 0, i32 6
  %92 = load ptr, ptr %l_G.i.i131, align 8
  %totalbytes.i.i = getelementptr inbounds %struct.global_State, ptr %92, i64 0, i32 14
  %93 = load i64, ptr %totalbytes.i.i, align 8
  %GCthreshold.i.i = getelementptr inbounds %struct.global_State, ptr %92, i64 0, i32 13
  %94 = load i64, ptr %GCthreshold.i.i, align 8
  %cmp.not.i.i = icmp ult i64 %93, %94
  br i1 %cmp.not.i.i, label %if.then.i.i117, label %if.then.i.i132

if.then.i.i132:                                   ; preds = %if.else.i126
  %gcstepmul.i.i.i = getelementptr inbounds %struct.global_State, ptr %92, i64 0, i32 18
  %95 = load i32, ptr %gcstepmul.i.i.i, align 4
  %mul.i.i.i = mul i32 %95, 10
  %conv.i.i.i = zext i32 %mul.i.i.i to i64
  %cmp.i.i.i = icmp eq i32 %mul.i.i.i, 0
  %spec.store.select.i.i.i = select i1 %cmp.i.i.i, i64 9223372036854775806, i64 %conv.i.i.i
  %sub.i.i.i = sub i64 %93, %94
  %gcdept.i.i.i = getelementptr inbounds %struct.global_State, ptr %92, i64 0, i32 16
  %96 = load i64, ptr %gcdept.i.i.i, align 8
  %add.i.i.i = add i64 %sub.i.i.i, %96
  store i64 %add.i.i.i, ptr %gcdept.i.i.i, align 8
  %gcstate.i.i.i = getelementptr inbounds %struct.global_State, ptr %92, i64 0, i32 4
  br label %do.body.i.i.i

do.body.i.i.i:                                    ; preds = %do.body.i.i.i, %if.then.i.i132
  %lim.0.i.i.i = phi i64 [ %spec.store.select.i.i.i, %if.then.i.i132 ], [ %sub2.i.i.i, %do.body.i.i.i ]
  %call.i.i.i133 = call fastcc i64 @singlestep(ptr noundef %91)
  %sub2.i.i.i = sub nsw i64 %lim.0.i.i.i, %call.i.i.i133
  %97 = load i8, ptr %gcstate.i.i.i, align 1
  %cmp4.i.i.i = icmp ne i8 %97, 0
  %cmp8.i.i.i = icmp sgt i64 %sub2.i.i.i, 0
  %or.cond.i.i.i = select i1 %cmp4.i.i.i, i1 %cmp8.i.i.i, i1 false
  br i1 %or.cond.i.i.i, label %do.body.i.i.i, label %do.end.i.i.i, !llvm.loop !6

do.end.i.i.i:                                     ; preds = %do.body.i.i.i
  br i1 %cmp4.i.i.i, label %if.then14.i.i.i, label %if.else27.i.i.i

if.then14.i.i.i:                                  ; preds = %do.end.i.i.i
  %98 = load i64, ptr %gcdept.i.i.i, align 8
  %cmp16.i.i.i = icmp ult i64 %98, 1024
  br i1 %cmp16.i.i.i, label %if.then18.i.i.i, label %if.else.i.i.i

if.then18.i.i.i:                                  ; preds = %if.then14.i.i.i
  %99 = load i64, ptr %totalbytes.i.i, align 8
  %add20.i.i.i = add i64 %99, 1024
  br label %luaC_step.exit.i.i

if.else.i.i.i:                                    ; preds = %if.then14.i.i.i
  %sub23.i.i.i = add i64 %98, -1024
  store i64 %sub23.i.i.i, ptr %gcdept.i.i.i, align 8
  %100 = load i64, ptr %totalbytes.i.i, align 8
  br label %luaC_step.exit.i.i

if.else27.i.i.i:                                  ; preds = %do.end.i.i.i
  %estimate.i.i.i = getelementptr inbounds %struct.global_State, ptr %92, i64 0, i32 15
  %101 = load i64, ptr %estimate.i.i.i, align 8
  %div.i.i.i = udiv i64 %101, 100
  %gcpause.i.i.i = getelementptr inbounds %struct.global_State, ptr %92, i64 0, i32 17
  %102 = load i32, ptr %gcpause.i.i.i, align 8
  %conv28.i.i.i = sext i32 %102 to i64
  %mul29.i.i.i = mul i64 %div.i.i.i, %conv28.i.i.i
  br label %luaC_step.exit.i.i

luaC_step.exit.i.i:                               ; preds = %if.else27.i.i.i, %if.else.i.i.i, %if.then18.i.i.i
  %add20.sink.i.i.i = phi i64 [ %add20.i.i.i, %if.then18.i.i.i ], [ %100, %if.else.i.i.i ], [ %mul29.i.i.i, %if.else27.i.i.i ]
  store i64 %add20.sink.i.i.i, ptr %GCthreshold.i.i, align 8
  br label %if.then.i.i117

if.then.i.i117:                                   ; preds = %luaC_step.exit.i.i, %if.else.i126
  %top.i.i134 = getelementptr inbounds %struct.lua_State, ptr %91, i64 0, i32 4
  %103 = load ptr, ptr %top.i.i134, align 8
  %call.i.i135 = call fastcc ptr @luaS_newlstr(ptr noundef %91, ptr noundef nonnull %buffer.i, i64 noundef %sub.ptr.sub.i129)
  store ptr %call.i.i135, ptr %103, align 8
  %tt.i.i136 = getelementptr inbounds %struct.lua_TValue, ptr %103, i64 0, i32 1
  store i32 4, ptr %tt.i.i136, align 8
  %104 = load ptr, ptr %top.i.i134, align 8
  %incdec.ptr.i.i137 = getelementptr inbounds %struct.lua_TValue, ptr %104, i64 1
  store ptr %incdec.ptr.i.i137, ptr %top.i.i134, align 8
  store ptr %buffer.i, ptr %b, align 8
  %105 = load i32, ptr %lvl.i, align 8
  %inc.i139 = add nsw i32 %105, 1
  store i32 %inc.i139, ptr %lvl.i, align 8
  call fastcc void @adjuststack(ptr noundef nonnull %b)
  %.pre = load ptr, ptr %b, align 8
  br label %lor.end.i118

lor.end.i118:                                     ; preds = %if.then.i.i117, %while.body.i112
  %106 = phi ptr [ %.pre, %if.then.i.i117 ], [ %90, %while.body.i112 ]
  %incdec.ptr.i119 = getelementptr inbounds i8, ptr %s.addr.06.i, i64 1
  %107 = load i8, ptr %s.addr.06.i, align 1
  %incdec.ptr3.i = getelementptr inbounds i8, ptr %106, i64 1
  store ptr %incdec.ptr3.i, ptr %b, align 8
  store i8 %107, ptr %106, align 1
  %tobool.not.i120 = icmp eq i64 %dec7.i, 0
  br i1 %tobool.not.i120, label %while.cond.backedge, label %while.body.i112, !llvm.loop !129

while.end:                                        ; preds = %while.cond.backedge, %luaL_checklstring.exit
  %call.i122 = call fastcc i32 @emptybuffer(ptr noundef nonnull %b), !range !23
  %108 = load ptr, ptr %L1.i, align 8
  %109 = load i32, ptr %lvl.i, align 8
  call fastcc void @lua_concat(ptr noundef %108, i32 noundef %109)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @gmatch(ptr noundef %L) #0 {
entry:
  %call.i = tail call fastcc ptr @lua_tolstring(ptr noundef %L, i32 noundef 1, ptr noundef null)
  %tobool.not.i = icmp eq ptr %call.i, null
  br i1 %tobool.not.i, label %if.then.i, label %luaL_checklstring.exit

if.then.i:                                        ; preds = %entry
  tail call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 1, ptr noundef nonnull @.str.25)
  unreachable

luaL_checklstring.exit:                           ; preds = %entry
  %call.i5 = tail call fastcc ptr @lua_tolstring(ptr noundef %L, i32 noundef 2, ptr noundef null)
  %tobool.not.i6 = icmp eq ptr %call.i5, null
  br i1 %tobool.not.i6, label %if.then.i7, label %luaL_checklstring.exit9

if.then.i7:                                       ; preds = %luaL_checklstring.exit
  tail call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 2, ptr noundef nonnull @.str.25)
  unreachable

luaL_checklstring.exit9:                          ; preds = %luaL_checklstring.exit
  %top.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %base.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %top.i, align 8
  %1 = load ptr, ptr %base.i, align 8
  %add.ptr10.i = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 2
  %cmp111.i = icmp ult ptr %0, %add.ptr10.i
  br i1 %cmp111.i, label %while.body.i, label %lua_settop.exit

while.body.i:                                     ; preds = %luaL_checklstring.exit9, %while.body.i
  %2 = phi ptr [ %3, %while.body.i ], [ %0, %luaL_checklstring.exit9 ]
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %2, i64 1
  store ptr %incdec.ptr.i, ptr %top.i, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %2, i64 0, i32 1
  store i32 0, ptr %tt.i, align 8
  %3 = load ptr, ptr %top.i, align 8
  %4 = load ptr, ptr %base.i, align 8
  %add.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %4, i64 2
  %cmp1.i = icmp ult ptr %3, %add.ptr.i
  br i1 %cmp1.i, label %while.body.i, label %lua_settop.exit, !llvm.loop !13

lua_settop.exit:                                  ; preds = %while.body.i, %luaL_checklstring.exit9
  %add.ptr9.sink.i = phi ptr [ %add.ptr10.i, %luaL_checklstring.exit9 ], [ %add.ptr.i, %while.body.i ]
  store ptr %add.ptr9.sink.i, ptr %top.i, align 8
  store double 0.000000e+00, ptr %add.ptr9.sink.i, align 8
  %tt.i11 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr9.sink.i, i64 0, i32 1
  store i32 3, ptr %tt.i11, align 8
  %5 = load ptr, ptr %top.i, align 8
  %incdec.ptr.i12 = getelementptr inbounds %struct.lua_TValue, ptr %5, i64 1
  store ptr %incdec.ptr.i12, ptr %top.i, align 8
  tail call fastcc void @lua_pushcclosure(ptr noundef nonnull %L, ptr noundef nonnull @gmatch_aux, i32 noundef 3)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @str_gsub(ptr noundef %L) #0 {
entry:
  %endptr.i.i.i = alloca ptr, align 8
  %vl.i.i = alloca i64, align 8
  %vl.i.i.i = alloca i64, align 8
  %l.i.i = alloca i64, align 8
  %ar.i = alloca %struct.lua_Debug, align 8
  %srcl = alloca i64, align 8
  %ms = alloca %struct.MatchState, align 8
  %b = alloca %struct.luaL_Buffer, align 8
  %call.i = call fastcc ptr @lua_tolstring(ptr noundef %L, i32 noundef 1, ptr noundef nonnull %srcl)
  %tobool.not.i = icmp eq ptr %call.i, null
  br i1 %tobool.not.i, label %if.then.i, label %luaL_checklstring.exit

if.then.i:                                        ; preds = %entry
  call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 1, ptr noundef nonnull @.str.25)
  unreachable

luaL_checklstring.exit:                           ; preds = %entry
  %call.i29 = call fastcc ptr @lua_tolstring(ptr noundef %L, i32 noundef 2, ptr noundef null)
  %tobool.not.i30 = icmp eq ptr %call.i29, null
  br i1 %tobool.not.i30, label %if.then.i31, label %luaL_checklstring.exit33

if.then.i31:                                      ; preds = %luaL_checklstring.exit
  call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 2, ptr noundef nonnull @.str.25)
  unreachable

luaL_checklstring.exit33:                         ; preds = %luaL_checklstring.exit
  %base.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i, align 8
  %add.ptr.i.i = getelementptr %struct.lua_TValue, ptr %0, i64 2
  %top.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i, align 8
  %cmp1.not.i.i = icmp uge ptr %add.ptr.i.i, %1
  %cmp.i = icmp eq ptr %add.ptr.i.i, @luaO_nilobject_
  %or.cond95 = or i1 %cmp1.not.i.i, %cmp.i
  br i1 %or.cond95, label %lua_type.exit, label %cond.false.i

cond.false.i:                                     ; preds = %luaL_checklstring.exit33
  %tt.i = getelementptr %struct.lua_TValue, ptr %0, i64 2, i32 1
  %2 = load i32, ptr %tt.i, align 8
  %3 = add i32 %2, -3
  %4 = icmp ult i32 %3, 4
  br label %lua_type.exit

lua_type.exit:                                    ; preds = %luaL_checklstring.exit33, %cond.false.i
  %cond.i = phi i1 [ %4, %cond.false.i ], [ false, %luaL_checklstring.exit33 ]
  %5 = load i64, ptr %srcl, align 8
  %add = add i64 %5, 1
  %add.ptr.i.i.i = getelementptr %struct.lua_TValue, ptr %0, i64 3
  %cmp1.not.i.i.i = icmp uge ptr %add.ptr.i.i.i, %1
  %cmp.i.i = icmp eq ptr %add.ptr.i.i.i, @luaO_nilobject_
  %or.cond96 = or i1 %cmp1.not.i.i.i, %cmp.i.i
  br i1 %or.cond96, label %luaL_optinteger.exit, label %lua_type.exit.i

lua_type.exit.i:                                  ; preds = %lua_type.exit
  %tt.i.i = getelementptr %struct.lua_TValue, ptr %0, i64 3, i32 1
  %6 = load i32, ptr %tt.i.i, align 8
  %cmp.i35 = icmp slt i32 %6, 1
  br i1 %cmp.i35, label %luaL_optinteger.exit, label %cond.false.i36

cond.false.i36:                                   ; preds = %lua_type.exit.i
  %call.i.i = call fastcc i64 @lua_tointeger(ptr noundef nonnull %L, i32 noundef 4)
  %cmp.i3.i = icmp eq i64 %call.i.i, 0
  br i1 %cmp.i3.i, label %land.lhs.true.i.i, label %luaL_optinteger.exit

land.lhs.true.i.i:                                ; preds = %cond.false.i36
  %7 = load ptr, ptr %base.i.i, align 8
  %add.ptr.i.i74 = getelementptr %struct.lua_TValue, ptr %7, i64 3
  %8 = load ptr, ptr %top.i.i, align 8
  %cmp1.not.i.i76 = icmp ult ptr %add.ptr.i.i74, %8
  %add.ptr.luaO_nilobject_.i.i = select i1 %cmp1.not.i.i76, ptr %add.ptr.i.i74, ptr @luaO_nilobject_
  %tt.i78 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i, i64 0, i32 1
  %9 = load i32, ptr %tt.i78, align 8
  switch i32 %9, label %if.then.i.i [
    i32 3, label %luaL_optinteger.exit
    i32 4, label %land.lhs.true.i.i79
  ]

land.lhs.true.i.i79:                              ; preds = %land.lhs.true.i.i
  %10 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i, align 8
  %add.ptr.i3.i = getelementptr inbounds %union.TString, ptr %10, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i.i)
  %call.i.i.i80 = call double @strtod(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i) #35
  %11 = load ptr, ptr %endptr.i.i.i, align 8
  %cmp.i.i.i81 = icmp eq ptr %11, %add.ptr.i3.i
  br i1 %cmp.i.i.i81, label %luaO_str2d.exit.thread.i.i, label %if.end.i.i.i82

luaO_str2d.exit.thread.i.i:                       ; preds = %land.lhs.true.i.i79
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %if.then.i.i

if.end.i.i.i82:                                   ; preds = %land.lhs.true.i.i79
  %12 = load i8, ptr %11, align 1
  switch i8 %12, label %if.end9.i.i.i [
    i8 120, label %if.then6.i.i.i
    i8 88, label %if.then6.i.i.i
  ]

if.then6.i.i.i:                                   ; preds = %if.end.i.i.i82, %if.end.i.i.i82
  %call7.i.i.i = call i64 @strtoul(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i, i32 noundef 16) #35
  %.pre.i.i.i83 = load ptr, ptr %endptr.i.i.i, align 8
  %.pre5.i.i.i = load i8, ptr %.pre.i.i.i83, align 1
  br label %if.end9.i.i.i

if.end9.i.i.i:                                    ; preds = %if.then6.i.i.i, %if.end.i.i.i82
  %13 = phi i8 [ %12, %if.end.i.i.i82 ], [ %.pre5.i.i.i, %if.then6.i.i.i ]
  %endptr.promoted.i.i.i = phi ptr [ %11, %if.end.i.i.i82 ], [ %.pre.i.i.i83, %if.then6.i.i.i ]
  %cmp11.i.i.i = icmp eq i8 %13, 0
  br i1 %cmp11.i.i.i, label %luaO_str2d.exit.thread9.i.i, label %while.cond.preheader.i.i.i

luaO_str2d.exit.thread9.i.i:                      ; preds = %if.end9.i.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %luaL_optinteger.exit

while.cond.preheader.i.i.i:                       ; preds = %if.end9.i.i.i
  %call15.i.i.i = tail call ptr @__ctype_b_loc() #39
  %14 = load ptr, ptr %call15.i.i.i, align 8
  br label %while.cond.i.i.i

while.cond.i.i.i:                                 ; preds = %while.cond.i.i.i, %while.cond.preheader.i.i.i
  %incdec.ptr4.i.i.i = phi ptr [ %endptr.promoted.i.i.i, %while.cond.preheader.i.i.i ], [ %incdec.ptr.i.i.i85, %while.cond.i.i.i ]
  %15 = load i8, ptr %incdec.ptr4.i.i.i, align 1
  %idxprom.i.i.i = zext i8 %15 to i64
  %arrayidx.i.i.i = getelementptr inbounds i16, ptr %14, i64 %idxprom.i.i.i
  %16 = load i16, ptr %arrayidx.i.i.i, align 2
  %17 = and i16 %16, 8192
  %tobool.not.i.i.i84 = icmp eq i16 %17, 0
  %incdec.ptr.i.i.i85 = getelementptr inbounds i8, ptr %incdec.ptr4.i.i.i, i64 1
  br i1 %tobool.not.i.i.i84, label %luaO_str2d.exit.i.i, label %while.cond.i.i.i, !llvm.loop !35

luaO_str2d.exit.i.i:                              ; preds = %while.cond.i.i.i
  %cmp19.not.i.not.i.i = icmp eq i8 %15, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br i1 %cmp19.not.i.not.i.i, label %luaL_optinteger.exit, label %if.then.i.i

if.then.i.i:                                      ; preds = %land.lhs.true.i.i, %luaO_str2d.exit.i.i, %luaO_str2d.exit.thread.i.i
  call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 4, ptr noundef nonnull @.str.24)
  unreachable

luaL_optinteger.exit:                             ; preds = %luaO_str2d.exit.thread9.i.i, %luaO_str2d.exit.i.i, %land.lhs.true.i.i, %lua_type.exit, %lua_type.exit.i, %cond.false.i36
  %cond.i34 = phi i64 [ %add, %lua_type.exit.i ], [ %call.i.i, %cond.false.i36 ], [ %add, %lua_type.exit ], [ 0, %land.lhs.true.i.i ], [ 0, %luaO_str2d.exit.i.i ], [ 0, %luaO_str2d.exit.thread9.i.i ]
  %conv = trunc i64 %cond.i34 to i32
  %18 = load i8, ptr %call.i29, align 1
  %cmp.not = icmp eq i8 %18, 94
  %spec.select.idx = zext i1 %cmp.not to i64
  %spec.select = getelementptr inbounds i8, ptr %call.i29, i64 %spec.select.idx
  br i1 %cond.i, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %luaL_optinteger.exit
  call void @llvm.lifetime.start.p0(i64 120, ptr nonnull %ar.i)
  %ci1.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %19 = load ptr, ptr %ci1.i.i, align 8
  %base_ci4.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 12
  %20 = load ptr, ptr %base_ci4.i.i, align 8
  %cmp5.i.i = icmp ugt ptr %19, %20
  br i1 %cmp5.i.i, label %if.end.i, label %if.then.i38

if.then.i38:                                      ; preds = %lor.rhs
  call void (ptr, ptr, ...) @luaL_error(ptr noundef nonnull %L, ptr noundef nonnull @.str.116, i32 noundef 3, ptr noundef nonnull @.str.253)
  unreachable

if.end.i:                                         ; preds = %lor.rhs
  %sub.ptr.lhs.cast.i.i = ptrtoint ptr %19 to i64
  %sub.ptr.rhs.cast.i.i = ptrtoint ptr %20 to i64
  %sub.ptr.sub.i.i = sub i64 %sub.ptr.lhs.cast.i.i, %sub.ptr.rhs.cast.i.i
  %sub.ptr.div.i.i = sdiv exact i64 %sub.ptr.sub.i.i, 40
  %conv.i.i = trunc i64 %sub.ptr.div.i.i to i32
  %i_ci11.i.i = getelementptr inbounds %struct.lua_Debug, ptr %ar.i, i64 0, i32 10
  store i32 %conv.i.i, ptr %i_ci11.i.i, align 4
  call fastcc void @lua_getinfo(ptr noundef nonnull %L, ptr noundef nonnull @.str.117, ptr noundef nonnull %ar.i)
  %namewhat.i = getelementptr inbounds %struct.lua_Debug, ptr %ar.i, i64 0, i32 2
  %21 = load ptr, ptr %namewhat.i, align 8
  %call3.i = call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %21, ptr noundef nonnull dereferenceable(7) @.str.118) #34
  %name10.i = getelementptr inbounds %struct.lua_Debug, ptr %ar.i, i64 0, i32 1
  %22 = load ptr, ptr %name10.i, align 8
  %cmp11.i = icmp eq ptr %22, null
  br i1 %cmp11.i, label %if.then12.i, label %if.end14.i

if.then12.i:                                      ; preds = %if.end.i
  store ptr @.str.120, ptr %name10.i, align 8
  br label %if.end14.i

if.end14.i:                                       ; preds = %if.then12.i, %if.end.i
  %23 = phi ptr [ @.str.120, %if.then12.i ], [ %22, %if.end.i ]
  %cmp.i39 = icmp eq i32 %call3.i, 0
  %spec.select97 = select i1 %cmp.i39, i32 2, i32 3
  call void (ptr, ptr, ...) @luaL_error(ptr noundef nonnull %L, ptr noundef nonnull @.str.121, i32 noundef %spec.select97, ptr noundef nonnull %23, ptr noundef nonnull @.str.253)
  unreachable

lor.end:                                          ; preds = %luaL_optinteger.exit
  %L1.i = getelementptr inbounds %struct.luaL_Buffer, ptr %b, i64 0, i32 2
  store ptr %L, ptr %L1.i, align 8
  %buffer.i = getelementptr inbounds %struct.luaL_Buffer, ptr %b, i64 0, i32 3
  store ptr %buffer.i, ptr %b, align 8
  %lvl.i = getelementptr inbounds %struct.luaL_Buffer, ptr %b, i64 0, i32 1
  store i32 0, ptr %lvl.i, align 8
  %L17 = getelementptr inbounds %struct.MatchState, ptr %ms, i64 0, i32 2
  store ptr %L, ptr %L17, align 8
  store ptr %call.i, ptr %ms, align 8
  %24 = load i64, ptr %srcl, align 8
  %add.ptr = getelementptr inbounds i8, ptr %call.i, i64 %24
  %src_end = getelementptr inbounds %struct.MatchState, ptr %ms, i64 0, i32 1
  store ptr %add.ptr, ptr %src_end, align 8
  %level = getelementptr inbounds %struct.MatchState, ptr %ms, i64 0, i32 3
  %add.ptr.i.i52 = getelementptr inbounds %struct.luaL_Buffer, ptr %b, i64 1
  %sub.ptr.rhs.cast.i.i.i = ptrtoint ptr %buffer.i to i64
  %sub.ptr.sub.neg.i.i.i = add i64 %sub.ptr.rhs.cast.i.i.i, 8192
  br label %while.cond

while.cond:                                       ; preds = %if.end44, %lor.end
  %n.0 = phi i32 [ 0, %lor.end ], [ %n.194, %if.end44 ]
  %src.0 = phi ptr [ %call.i, %lor.end ], [ %src.1, %if.end44 ]
  %cmp18 = icmp slt i32 %n.0, %conv
  br i1 %cmp18, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  store i32 0, ptr %level, align 8
  %call20 = call fastcc ptr @match(ptr noundef nonnull %ms, ptr noundef %src.0, ptr noundef nonnull %spec.select)
  %tobool21.not.not = icmp eq ptr %call20, null
  br i1 %tobool21.not.not, label %if.else, label %if.then

if.then:                                          ; preds = %while.body
  %inc = add nsw i32 %n.0, 1
  %25 = load ptr, ptr %L17, align 8
  %base.i.i.i41 = getelementptr inbounds %struct.lua_State, ptr %25, i64 0, i32 5
  %26 = load ptr, ptr %base.i.i.i41, align 8
  %add.ptr.i.i.i42 = getelementptr %struct.lua_TValue, ptr %26, i64 2
  %top.i.i.i43 = getelementptr inbounds %struct.lua_State, ptr %25, i64 0, i32 4
  %27 = load ptr, ptr %top.i.i.i43, align 8
  %cmp1.not.i.i.i44 = icmp uge ptr %add.ptr.i.i.i42, %27
  %cmp.i.i45 = icmp eq ptr %add.ptr.i.i.i42, @luaO_nilobject_
  %or.cond.i = or i1 %cmp1.not.i.i.i44, %cmp.i.i45
  br i1 %or.cond.i, label %sw.epilog.i, label %lua_type.exit.i46

lua_type.exit.i46:                                ; preds = %if.then
  %tt.i.i47 = getelementptr %struct.lua_TValue, ptr %26, i64 2, i32 1
  %28 = load i32, ptr %tt.i.i47, align 8
  switch i32 %28, label %sw.epilog.i [
    i32 3, label %sw.bb.i
    i32 4, label %sw.bb.i
    i32 6, label %sw.bb2.i
    i32 5, label %sw.bb4.i
  ]

sw.bb.i:                                          ; preds = %lua_type.exit.i46, %lua_type.exit.i46
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %l.i.i)
  %call.i.i51 = call fastcc ptr @lua_tolstring(ptr noundef nonnull %25, i32 noundef 3, ptr noundef nonnull %l.i.i)
  %29 = load i64, ptr %l.i.i, align 8
  %cmp38.not.i.i = icmp eq i64 %29, 0
  br i1 %cmp38.not.i.i, label %add_s.exit.i, label %for.body.lr.ph.i.i

for.body.lr.ph.i.i:                               ; preds = %sw.bb.i
  %sub.ptr.lhs.cast.i.i53 = ptrtoint ptr %call20 to i64
  %sub.ptr.rhs.cast.i.i54 = ptrtoint ptr %src.0 to i64
  %sub.ptr.sub.i.i55 = sub i64 %sub.ptr.lhs.cast.i.i53, %sub.ptr.rhs.cast.i.i54
  %tobool.not5.i.i.i = icmp eq i64 %sub.ptr.sub.i.i55, 0
  br label %for.body.i.i

for.body.i.i:                                     ; preds = %for.inc.i.i, %for.body.lr.ph.i.i
  %i.039.i.i = phi i64 [ 0, %for.body.lr.ph.i.i ], [ %inc40.i.i, %for.inc.i.i ]
  %arrayidx.i.i = getelementptr inbounds i8, ptr %call.i.i51, i64 %i.039.i.i
  %30 = load i8, ptr %arrayidx.i.i, align 1
  %cmp1.not.i.i56 = icmp eq i8 %30, 37
  br i1 %cmp1.not.i.i56, label %if.else.i.i, label %if.then.i.i57

if.then.i.i57:                                    ; preds = %for.body.i.i
  %31 = load ptr, ptr %b, align 8
  %cmp3.i.i = icmp ult ptr %31, %add.ptr.i.i52
  br i1 %cmp3.i.i, label %lor.end.i.i, label %lor.rhs.i.i

lor.rhs.i.i:                                      ; preds = %if.then.i.i57
  %call.i.i.i = call fastcc i32 @emptybuffer(ptr noundef nonnull %b), !range !23
  %tobool.not.i.i.i = icmp eq i32 %call.i.i.i, 0
  br i1 %tobool.not.i.i.i, label %lor.end.i.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %lor.rhs.i.i
  call fastcc void @adjuststack(ptr noundef nonnull %b)
  br label %lor.end.i.i

lor.end.i.i:                                      ; preds = %if.then.i.i.i, %lor.rhs.i.i, %if.then.i.i57
  %32 = load i8, ptr %arrayidx.i.i, align 1
  %33 = load ptr, ptr %b, align 8
  %incdec.ptr.i.i = getelementptr inbounds i8, ptr %33, i64 1
  store ptr %incdec.ptr.i.i, ptr %b, align 8
  store i8 %32, ptr %33, align 1
  br label %for.inc.i.i

if.else.i.i:                                      ; preds = %for.body.i.i
  %inc.i.i = add nuw i64 %i.039.i.i, 1
  %call8.i.i = tail call ptr @__ctype_b_loc() #39
  %34 = load ptr, ptr %call8.i.i, align 8
  %arrayidx9.i.i = getelementptr inbounds i8, ptr %call.i.i51, i64 %inc.i.i
  %35 = load i8, ptr %arrayidx9.i.i, align 1
  %idxprom.i.i = zext i8 %35 to i64
  %arrayidx11.i.i = getelementptr inbounds i16, ptr %34, i64 %idxprom.i.i
  %36 = load i16, ptr %arrayidx11.i.i, align 2
  %37 = and i16 %36, 2048
  %tobool13.not.i.i = icmp eq i16 %37, 0
  br i1 %tobool13.not.i.i, label %if.then14.i.i, label %if.else29.i.i

if.then14.i.i:                                    ; preds = %if.else.i.i
  %38 = load ptr, ptr %b, align 8
  %cmp19.i.i = icmp ult ptr %38, %add.ptr.i.i52
  br i1 %cmp19.i.i, label %lor.end24.i.i, label %lor.rhs21.i.i

lor.rhs21.i.i:                                    ; preds = %if.then14.i.i
  %call.i27.i.i = call fastcc i32 @emptybuffer(ptr noundef nonnull %b), !range !23
  %tobool.not.i28.i.i = icmp eq i32 %call.i27.i.i, 0
  br i1 %tobool.not.i28.i.i, label %lor.end24.i.i, label %if.then.i29.i.i

if.then.i29.i.i:                                  ; preds = %lor.rhs21.i.i
  call fastcc void @adjuststack(ptr noundef nonnull %b)
  br label %lor.end24.i.i

lor.end24.i.i:                                    ; preds = %if.then.i29.i.i, %lor.rhs21.i.i, %if.then14.i.i
  %39 = load i8, ptr %arrayidx9.i.i, align 1
  %40 = load ptr, ptr %b, align 8
  %incdec.ptr28.i.i = getelementptr inbounds i8, ptr %40, i64 1
  store ptr %incdec.ptr28.i.i, ptr %b, align 8
  store i8 %39, ptr %40, align 1
  br label %for.inc.i.i

if.else29.i.i:                                    ; preds = %if.else.i.i
  %cmp32.i.i = icmp eq i8 %35, 48
  br i1 %cmp32.i.i, label %if.then34.i.i, label %if.else35.i.i

if.then34.i.i:                                    ; preds = %if.else29.i.i
  br i1 %tobool.not5.i.i.i, label %for.inc.i.i, label %while.body.i.i.i

while.body.i.i.i:                                 ; preds = %if.then34.i.i, %lor.end.i.i.i
  %dec7.in.i.i.i = phi i64 [ %dec7.i.i.i, %lor.end.i.i.i ], [ %sub.ptr.sub.i.i55, %if.then34.i.i ]
  %s.addr.06.i.i.i = phi ptr [ %incdec.ptr.i.i.i, %lor.end.i.i.i ], [ %src.0, %if.then34.i.i ]
  %dec7.i.i.i = add i64 %dec7.in.i.i.i, -1
  %41 = load ptr, ptr %b, align 8
  %cmp.i.i.i = icmp ult ptr %41, %add.ptr.i.i52
  br i1 %cmp.i.i.i, label %lor.end.i.i.i, label %lor.rhs.i.i.i

lor.rhs.i.i.i:                                    ; preds = %while.body.i.i.i
  %call.i.i.i.i = call fastcc i32 @emptybuffer(ptr noundef nonnull %b), !range !23
  %tobool.not.i.i.i.i = icmp eq i32 %call.i.i.i.i, 0
  br i1 %tobool.not.i.i.i.i, label %lor.end.i.i.i, label %if.then.i.i.i.i

if.then.i.i.i.i:                                  ; preds = %lor.rhs.i.i.i
  call fastcc void @adjuststack(ptr noundef nonnull %b)
  br label %lor.end.i.i.i

lor.end.i.i.i:                                    ; preds = %if.then.i.i.i.i, %lor.rhs.i.i.i, %while.body.i.i.i
  %incdec.ptr.i.i.i = getelementptr inbounds i8, ptr %s.addr.06.i.i.i, i64 1
  %42 = load i8, ptr %s.addr.06.i.i.i, align 1
  %43 = load ptr, ptr %b, align 8
  %incdec.ptr3.i.i.i = getelementptr inbounds i8, ptr %43, i64 1
  store ptr %incdec.ptr3.i.i.i, ptr %b, align 8
  store i8 %42, ptr %43, align 1
  %tobool.not.i32.i.i = icmp eq i64 %dec7.i.i.i, 0
  br i1 %tobool.not.i32.i.i, label %for.inc.i.i, label %while.body.i.i.i, !llvm.loop !129

if.else35.i.i:                                    ; preds = %if.else29.i.i
  %conv31.i.i = sext i8 %35 to i32
  %sub.i.i = add nsw i32 %conv31.i.i, -49
  call fastcc void @push_onecapture(ptr noundef nonnull %ms, i32 noundef %sub.i.i, ptr noundef %src.0, ptr noundef nonnull %call20)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %vl.i.i.i)
  %44 = load ptr, ptr %L1.i, align 8
  %call.i33.i.i = call fastcc ptr @lua_tolstring(ptr noundef %44, i32 noundef -1, ptr noundef nonnull %vl.i.i.i)
  %45 = load i64, ptr %vl.i.i.i, align 8
  %46 = load ptr, ptr %b, align 8
  %sub.ptr.lhs.cast.i.i.i = ptrtoint ptr %46 to i64
  %sub.i.i.i = sub i64 %sub.ptr.sub.neg.i.i.i, %sub.ptr.lhs.cast.i.i.i
  %cmp.not.i.i.i = icmp ugt i64 %45, %sub.i.i.i
  br i1 %cmp.not.i.i.i, label %if.else.i.i.i, label %if.then.i35.i.i

if.then.i35.i.i:                                  ; preds = %if.else35.i.i
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %46, ptr align 1 %call.i33.i.i, i64 %45, i1 false)
  %47 = load i64, ptr %vl.i.i.i, align 8
  %48 = load ptr, ptr %b, align 8
  %add.ptr.i36.i.i = getelementptr inbounds i8, ptr %48, i64 %47
  store ptr %add.ptr.i36.i.i, ptr %b, align 8
  %top.i.i.i.i = getelementptr inbounds %struct.lua_State, ptr %44, i64 0, i32 4
  %49 = load ptr, ptr %top.i.i.i.i, align 8
  %add.ptr9.i.i.i.i = getelementptr %struct.lua_TValue, ptr %49, i64 -1
  store ptr %add.ptr9.i.i.i.i, ptr %top.i.i.i.i, align 8
  br label %luaL_addvalue.exit.i.i

if.else.i.i.i:                                    ; preds = %if.else35.i.i
  %call4.i.i.i = call fastcc i32 @emptybuffer(ptr noundef nonnull %b), !range !23
  %tobool.not.i37.i.i = icmp eq i32 %call4.i.i.i, 0
  br i1 %tobool.not.i37.i.i, label %if.end.i.i.i, label %if.then5.i.i.i

if.then5.i.i.i:                                   ; preds = %if.else.i.i.i
  %top6.i.i.i.i.i = getelementptr inbounds %struct.lua_State, ptr %44, i64 0, i32 4
  %50 = load ptr, ptr %top6.i.i.i.i.i, align 8
  br label %for.body.i.i.i.i

for.body.i.i.i.i:                                 ; preds = %for.body.i.i.i.i, %if.then5.i.i.i
  %q.012.i.idx.i.i.i = phi i64 [ %q.012.i.add.i.i.i, %for.body.i.i.i.i ], [ 0, %if.then5.i.i.i ]
  %q.012.i.ptr.i.i.i = getelementptr inbounds i8, ptr %50, i64 %q.012.i.idx.i.i.i
  %q.012.i.add.i.i.i = add nsw i64 %q.012.i.idx.i.i.i, -16
  %add.ptr.i.ptr.i.i.i = getelementptr inbounds i8, ptr %50, i64 %q.012.i.add.i.i.i
  %51 = load i64, ptr %add.ptr.i.ptr.i.i.i, align 8
  store i64 %51, ptr %q.012.i.ptr.i.i.i, align 8
  %tt.i.i.i.i = getelementptr %struct.lua_TValue, ptr %q.012.i.ptr.i.i.i, i64 -1, i32 1
  %52 = load i32, ptr %tt.i.i.i.i, align 8
  %tt2.i.i.i.i = getelementptr inbounds %struct.lua_TValue, ptr %q.012.i.ptr.i.i.i, i64 0, i32 1
  store i32 %52, ptr %tt2.i.i.i.i, align 8
  %cmp.i.i.i.i = icmp sgt i64 %q.012.i.idx.i.i.i, -16
  br i1 %cmp.i.i.i.i, label %for.body.i.i.i.i, label %lua_insert.exit.i.i.i, !llvm.loop !86

lua_insert.exit.i.i.i:                            ; preds = %for.body.i.i.i.i
  %add.ptr8.i.i.i.i.i = getelementptr inbounds %struct.lua_TValue, ptr %50, i64 -2
  %.pre.i.i.i.i = load ptr, ptr %top6.i.i.i.i.i, align 8
  %53 = load i64, ptr %.pre.i.i.i.i, align 8
  store i64 %53, ptr %add.ptr8.i.i.i.i.i, align 8
  %tt8.i.i.i.i = getelementptr inbounds %struct.lua_TValue, ptr %.pre.i.i.i.i, i64 0, i32 1
  %54 = load i32, ptr %tt8.i.i.i.i, align 8
  %tt9.i.i.i.i = getelementptr %struct.lua_TValue, ptr %50, i64 -2, i32 1
  store i32 %54, ptr %tt9.i.i.i.i, align 8
  br label %if.end.i.i.i

if.end.i.i.i:                                     ; preds = %lua_insert.exit.i.i.i, %if.else.i.i.i
  %55 = load i32, ptr %lvl.i, align 8
  %inc.i.i.i = add nsw i32 %55, 1
  store i32 %inc.i.i.i, ptr %lvl.i, align 8
  call fastcc void @adjuststack(ptr noundef nonnull %b)
  br label %luaL_addvalue.exit.i.i

luaL_addvalue.exit.i.i:                           ; preds = %if.end.i.i.i, %if.then.i35.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %vl.i.i.i)
  br label %for.inc.i.i

for.inc.i.i:                                      ; preds = %lor.end.i.i.i, %luaL_addvalue.exit.i.i, %if.then34.i.i, %lor.end24.i.i, %lor.end.i.i
  %i.1.i.i = phi i64 [ %i.039.i.i, %lor.end.i.i ], [ %inc.i.i, %luaL_addvalue.exit.i.i ], [ %inc.i.i, %lor.end24.i.i ], [ %inc.i.i, %if.then34.i.i ], [ %inc.i.i, %lor.end.i.i.i ]
  %inc40.i.i = add i64 %i.1.i.i, 1
  %56 = load i64, ptr %l.i.i, align 8
  %cmp.i22.i = icmp ult i64 %inc40.i.i, %56
  br i1 %cmp.i22.i, label %for.body.i.i, label %add_s.exit.i, !llvm.loop !145

add_s.exit.i:                                     ; preds = %for.inc.i.i, %sw.bb.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %l.i.i)
  br label %if.end

sw.bb2.i:                                         ; preds = %lua_type.exit.i46
  %57 = load i64, ptr %add.ptr.i.i.i42, align 8
  store i64 %57, ptr %27, align 8
  %58 = load i32, ptr %tt.i.i47, align 8
  %tt2.i.i = getelementptr inbounds %struct.lua_TValue, ptr %27, i64 0, i32 1
  store i32 %58, ptr %tt2.i.i, align 8
  %59 = load ptr, ptr %top.i.i.i43, align 8
  %incdec.ptr.i30.i = getelementptr inbounds %struct.lua_TValue, ptr %59, i64 1
  store ptr %incdec.ptr.i30.i, ptr %top.i.i.i43, align 8
  %call3.i50 = call fastcc i32 @push_captures(ptr noundef nonnull %ms, ptr noundef %src.0, ptr noundef nonnull %call20)
  %60 = load ptr, ptr %top.i.i.i43, align 8
  %narrow.i.i = xor i32 %call3.i50, -1
  %idx.neg.i.i = sext i32 %narrow.i.i to i64
  %add.ptr.i32.i = getelementptr inbounds %struct.lua_TValue, ptr %60, i64 %idx.neg.i.i
  call fastcc void @luaD_call(ptr noundef nonnull %25, ptr noundef %add.ptr.i32.i, i32 noundef 1)
  br label %sw.epilog.i

sw.bb4.i:                                         ; preds = %lua_type.exit.i46
  call fastcc void @push_onecapture(ptr noundef nonnull %ms, i32 noundef 0, ptr noundef %src.0, ptr noundef nonnull %call20)
  %61 = load ptr, ptr %base.i.i.i41, align 8
  %add.ptr.i.i34.i = getelementptr %struct.lua_TValue, ptr %61, i64 2
  %62 = load ptr, ptr %top.i.i.i43, align 8
  %cmp1.not.i.i36.i = icmp ult ptr %add.ptr.i.i34.i, %62
  %add.ptr.luaO_nilobject_.i.i37.i = select i1 %cmp1.not.i.i36.i, ptr %add.ptr.i.i34.i, ptr @luaO_nilobject_
  %add.ptr.i38.i = getelementptr inbounds %struct.lua_TValue, ptr %62, i64 -1
  call fastcc void @luaV_gettable(ptr noundef nonnull %25, ptr noundef %add.ptr.luaO_nilobject_.i.i37.i, ptr noundef nonnull %add.ptr.i38.i, ptr noundef nonnull %add.ptr.i38.i)
  br label %sw.epilog.i

sw.epilog.i:                                      ; preds = %sw.bb4.i, %sw.bb2.i, %lua_type.exit.i46, %if.then
  %63 = load ptr, ptr %top.i.i.i43, align 8
  %add.ptr8.i.i.i = getelementptr %struct.lua_TValue, ptr %63, i64 -1
  %tt.i41.i = getelementptr %struct.lua_TValue, ptr %63, i64 -1, i32 1
  %64 = load i32, ptr %tt.i41.i, align 8
  switch i32 %64, label %if.else.i [
    i32 0, label %if.then.i49
    i32 1, label %lua_toboolean.exit.i
  ]

lua_toboolean.exit.i:                             ; preds = %sw.epilog.i
  %65 = load i32, ptr %add.ptr8.i.i.i, align 8
  %cmp3.i42.not.i = icmp eq i32 %65, 0
  br i1 %cmp3.i42.not.i, label %if.then.i49, label %if.else.i

if.then.i49:                                      ; preds = %lua_toboolean.exit.i, %sw.epilog.i
  store ptr %add.ptr8.i.i.i, ptr %top.i.i.i43, align 8
  %sub.ptr.lhs.cast.i = ptrtoint ptr %call20 to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %src.0 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %l_G.i.i = getelementptr inbounds %struct.lua_State, ptr %25, i64 0, i32 6
  %66 = load ptr, ptr %l_G.i.i, align 8
  %totalbytes.i.i = getelementptr inbounds %struct.global_State, ptr %66, i64 0, i32 14
  %67 = load i64, ptr %totalbytes.i.i, align 8
  %GCthreshold.i.i = getelementptr inbounds %struct.global_State, ptr %66, i64 0, i32 13
  %68 = load i64, ptr %GCthreshold.i.i, align 8
  %cmp.not.i.i = icmp ult i64 %67, %68
  br i1 %cmp.not.i.i, label %lua_pushlstring.exit.i, label %if.then.i46.i

if.then.i46.i:                                    ; preds = %if.then.i49
  %gcstepmul.i.i.i = getelementptr inbounds %struct.global_State, ptr %66, i64 0, i32 18
  %69 = load i32, ptr %gcstepmul.i.i.i, align 4
  %mul.i.i.i = mul i32 %69, 10
  %conv.i.i.i = zext i32 %mul.i.i.i to i64
  %cmp.i.i47.i = icmp eq i32 %mul.i.i.i, 0
  %spec.store.select.i.i.i = select i1 %cmp.i.i47.i, i64 9223372036854775806, i64 %conv.i.i.i
  %sub.i.i48.i = sub i64 %67, %68
  %gcdept.i.i.i = getelementptr inbounds %struct.global_State, ptr %66, i64 0, i32 16
  %70 = load i64, ptr %gcdept.i.i.i, align 8
  %add.i.i.i = add i64 %sub.i.i48.i, %70
  store i64 %add.i.i.i, ptr %gcdept.i.i.i, align 8
  %gcstate.i.i.i = getelementptr inbounds %struct.global_State, ptr %66, i64 0, i32 4
  br label %do.body.i.i.i

do.body.i.i.i:                                    ; preds = %do.body.i.i.i, %if.then.i46.i
  %lim.0.i.i.i = phi i64 [ %spec.store.select.i.i.i, %if.then.i46.i ], [ %sub2.i.i.i, %do.body.i.i.i ]
  %call.i.i49.i = call fastcc i64 @singlestep(ptr noundef %25)
  %sub2.i.i.i = sub nsw i64 %lim.0.i.i.i, %call.i.i49.i
  %71 = load i8, ptr %gcstate.i.i.i, align 1
  %cmp4.i.i.i = icmp ne i8 %71, 0
  %cmp8.i.i.i = icmp sgt i64 %sub2.i.i.i, 0
  %or.cond.i.i.i = select i1 %cmp4.i.i.i, i1 %cmp8.i.i.i, i1 false
  br i1 %or.cond.i.i.i, label %do.body.i.i.i, label %do.end.i.i.i, !llvm.loop !6

do.end.i.i.i:                                     ; preds = %do.body.i.i.i
  br i1 %cmp4.i.i.i, label %if.then14.i.i.i, label %if.else27.i.i.i

if.then14.i.i.i:                                  ; preds = %do.end.i.i.i
  %72 = load i64, ptr %gcdept.i.i.i, align 8
  %cmp16.i.i.i = icmp ult i64 %72, 1024
  br i1 %cmp16.i.i.i, label %if.then18.i.i.i, label %if.else.i.i54.i

if.then18.i.i.i:                                  ; preds = %if.then14.i.i.i
  %73 = load i64, ptr %totalbytes.i.i, align 8
  %add20.i.i.i = add i64 %73, 1024
  br label %luaC_step.exit.i.i

if.else.i.i54.i:                                  ; preds = %if.then14.i.i.i
  %sub23.i.i.i = add i64 %72, -1024
  store i64 %sub23.i.i.i, ptr %gcdept.i.i.i, align 8
  %74 = load i64, ptr %totalbytes.i.i, align 8
  br label %luaC_step.exit.i.i

if.else27.i.i.i:                                  ; preds = %do.end.i.i.i
  %estimate.i.i.i = getelementptr inbounds %struct.global_State, ptr %66, i64 0, i32 15
  %75 = load i64, ptr %estimate.i.i.i, align 8
  %div.i.i.i = udiv i64 %75, 100
  %gcpause.i.i.i = getelementptr inbounds %struct.global_State, ptr %66, i64 0, i32 17
  %76 = load i32, ptr %gcpause.i.i.i, align 8
  %conv28.i.i.i = sext i32 %76 to i64
  %mul29.i.i.i = mul i64 %div.i.i.i, %conv28.i.i.i
  br label %luaC_step.exit.i.i

luaC_step.exit.i.i:                               ; preds = %if.else27.i.i.i, %if.else.i.i54.i, %if.then18.i.i.i
  %add20.sink.i.i.i = phi i64 [ %add20.i.i.i, %if.then18.i.i.i ], [ %74, %if.else.i.i54.i ], [ %mul29.i.i.i, %if.else27.i.i.i ]
  store i64 %add20.sink.i.i.i, ptr %GCthreshold.i.i, align 8
  %.pre.i = load ptr, ptr %top.i.i.i43, align 8
  br label %lua_pushlstring.exit.i

lua_pushlstring.exit.i:                           ; preds = %luaC_step.exit.i.i, %if.then.i49
  %77 = phi ptr [ %add.ptr8.i.i.i, %if.then.i49 ], [ %.pre.i, %luaC_step.exit.i.i ]
  %call.i51.i = call fastcc ptr @luaS_newlstr(ptr noundef nonnull %25, ptr noundef %src.0, i64 noundef %sub.ptr.sub.i)
  store ptr %call.i51.i, ptr %77, align 8
  %tt.i52.i = getelementptr inbounds %struct.lua_TValue, ptr %77, i64 0, i32 1
  store i32 4, ptr %tt.i52.i, align 8
  %78 = load ptr, ptr %top.i.i.i43, align 8
  %incdec.ptr.i53.i = getelementptr inbounds %struct.lua_TValue, ptr %78, i64 1
  store ptr %incdec.ptr.i53.i, ptr %top.i.i.i43, align 8
  br label %if.end12.i

if.else.i:                                        ; preds = %lua_toboolean.exit.i, %sw.epilog.i
  %cmp.i.i55.i = icmp eq ptr %add.ptr8.i.i.i, @luaO_nilobject_
  br i1 %cmp.i.i55.i, label %lua_typename.exit.i, label %lua_isstring.exit.i

lua_isstring.exit.i:                              ; preds = %if.else.i
  %79 = add i32 %64, -5
  %80 = icmp ult i32 %79, -2
  br i1 %80, label %lua_type.exit64.i, label %if.end12.i

lua_type.exit64.i:                                ; preds = %lua_isstring.exit.i
  %cmp.i65.i = icmp eq i32 %64, -1
  br i1 %cmp.i65.i, label %lua_typename.exit.i, label %cond.false.i66.i

cond.false.i66.i:                                 ; preds = %lua_type.exit64.i
  %idxprom.i67.i = sext i32 %64 to i64
  %arrayidx.i68.i = getelementptr inbounds [11 x ptr], ptr @luaT_typenames, i64 0, i64 %idxprom.i67.i
  %81 = load ptr, ptr %arrayidx.i68.i, align 8
  br label %lua_typename.exit.i

lua_typename.exit.i:                              ; preds = %if.else.i, %cond.false.i66.i, %lua_type.exit64.i
  %cond.i69.i = phi ptr [ %81, %cond.false.i66.i ], [ @.str.131, %lua_type.exit64.i ], [ @.str.131, %if.else.i ]
  call void (ptr, ptr, ...) @luaL_error(ptr noundef nonnull %25, ptr noundef nonnull @.str.254, ptr noundef %cond.i69.i)
  unreachable

if.end12.i:                                       ; preds = %lua_isstring.exit.i, %lua_pushlstring.exit.i
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %vl.i.i)
  %82 = load ptr, ptr %L1.i, align 8
  %call.i70.i = call fastcc ptr @lua_tolstring(ptr noundef %82, i32 noundef -1, ptr noundef nonnull %vl.i.i)
  %83 = load i64, ptr %vl.i.i, align 8
  %84 = load ptr, ptr %b, align 8
  %sub.ptr.lhs.cast.i71.i = ptrtoint ptr %84 to i64
  %sub.i73.i = sub i64 %sub.ptr.sub.neg.i.i.i, %sub.ptr.lhs.cast.i71.i
  %cmp.not.i74.i = icmp ugt i64 %83, %sub.i73.i
  br i1 %cmp.not.i74.i, label %if.else.i78.i, label %if.then.i75.i

if.then.i75.i:                                    ; preds = %if.end12.i
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %84, ptr align 1 %call.i70.i, i64 %83, i1 false)
  %85 = load i64, ptr %vl.i.i, align 8
  %86 = load ptr, ptr %b, align 8
  %add.ptr.i76.i = getelementptr inbounds i8, ptr %86, i64 %85
  store ptr %add.ptr.i76.i, ptr %b, align 8
  %top.i.i77.i = getelementptr inbounds %struct.lua_State, ptr %82, i64 0, i32 4
  %87 = load ptr, ptr %top.i.i77.i, align 8
  %add.ptr9.i.i.i = getelementptr %struct.lua_TValue, ptr %87, i64 -1
  store ptr %add.ptr9.i.i.i, ptr %top.i.i77.i, align 8
  br label %luaL_addvalue.exit.i

if.else.i78.i:                                    ; preds = %if.end12.i
  %call4.i.i = call fastcc i32 @emptybuffer(ptr noundef nonnull %b), !range !23
  %tobool.not.i.i48 = icmp eq i32 %call4.i.i, 0
  br i1 %tobool.not.i.i48, label %if.end.i.i, label %if.then5.i.i

if.then5.i.i:                                     ; preds = %if.else.i78.i
  %top6.i.i.i79.i = getelementptr inbounds %struct.lua_State, ptr %82, i64 0, i32 4
  %88 = load ptr, ptr %top6.i.i.i79.i, align 8
  br label %for.body.i.i.i

for.body.i.i.i:                                   ; preds = %for.body.i.i.i, %if.then5.i.i
  %q.012.i.idx.i.i = phi i64 [ %q.012.i.add.i.i, %for.body.i.i.i ], [ 0, %if.then5.i.i ]
  %q.012.i.ptr.i.i = getelementptr inbounds i8, ptr %88, i64 %q.012.i.idx.i.i
  %q.012.i.add.i.i = add nsw i64 %q.012.i.idx.i.i, -16
  %add.ptr.i.ptr.i.i = getelementptr inbounds i8, ptr %88, i64 %q.012.i.add.i.i
  %89 = load i64, ptr %add.ptr.i.ptr.i.i, align 8
  store i64 %89, ptr %q.012.i.ptr.i.i, align 8
  %tt.i.i80.i = getelementptr %struct.lua_TValue, ptr %q.012.i.ptr.i.i, i64 -1, i32 1
  %90 = load i32, ptr %tt.i.i80.i, align 8
  %tt2.i.i.i = getelementptr inbounds %struct.lua_TValue, ptr %q.012.i.ptr.i.i, i64 0, i32 1
  store i32 %90, ptr %tt2.i.i.i, align 8
  %cmp.i.i81.i = icmp sgt i64 %q.012.i.idx.i.i, -16
  br i1 %cmp.i.i81.i, label %for.body.i.i.i, label %lua_insert.exit.i.i, !llvm.loop !86

lua_insert.exit.i.i:                              ; preds = %for.body.i.i.i
  %add.ptr8.i.i.i82.i = getelementptr inbounds %struct.lua_TValue, ptr %88, i64 -2
  %.pre.i.i.i = load ptr, ptr %top6.i.i.i79.i, align 8
  %91 = load i64, ptr %.pre.i.i.i, align 8
  store i64 %91, ptr %add.ptr8.i.i.i82.i, align 8
  %tt8.i.i.i = getelementptr inbounds %struct.lua_TValue, ptr %.pre.i.i.i, i64 0, i32 1
  %92 = load i32, ptr %tt8.i.i.i, align 8
  %tt9.i.i.i = getelementptr %struct.lua_TValue, ptr %88, i64 -2, i32 1
  store i32 %92, ptr %tt9.i.i.i, align 8
  br label %if.end.i.i

if.end.i.i:                                       ; preds = %lua_insert.exit.i.i, %if.else.i78.i
  %93 = load i32, ptr %lvl.i, align 8
  %inc.i83.i = add nsw i32 %93, 1
  store i32 %inc.i83.i, ptr %lvl.i, align 8
  call fastcc void @adjuststack(ptr noundef nonnull %b)
  br label %luaL_addvalue.exit.i

luaL_addvalue.exit.i:                             ; preds = %if.end.i.i, %if.then.i75.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %vl.i.i)
  br label %if.end

if.end:                                           ; preds = %luaL_addvalue.exit.i, %add_s.exit.i
  %cmp23 = icmp ugt ptr %call20, %src.0
  br i1 %cmp23, label %if.end44, label %if.else

if.else:                                          ; preds = %while.body, %if.end
  %n.193 = phi i32 [ %inc, %if.end ], [ %n.0, %while.body ]
  %94 = load ptr, ptr %src_end, align 8
  %cmp27 = icmp ult ptr %src.0, %94
  br i1 %cmp27, label %if.then29, label %while.end

if.then29:                                        ; preds = %if.else
  %95 = load ptr, ptr %b, align 8
  %cmp32 = icmp ult ptr %95, %add.ptr.i.i52
  br i1 %cmp32, label %lor.end37, label %lor.rhs34

lor.rhs34:                                        ; preds = %if.then29
  %call.i58 = call fastcc i32 @emptybuffer(ptr noundef nonnull %b), !range !23
  %tobool.not.i59 = icmp eq i32 %call.i58, 0
  br i1 %tobool.not.i59, label %lor.end37, label %if.then.i60

if.then.i60:                                      ; preds = %lor.rhs34
  call fastcc void @adjuststack(ptr noundef nonnull %b)
  br label %lor.end37

lor.end37:                                        ; preds = %if.then.i60, %lor.rhs34, %if.then29
  %incdec.ptr39 = getelementptr inbounds i8, ptr %src.0, i64 1
  %96 = load i8, ptr %src.0, align 1
  %97 = load ptr, ptr %b, align 8
  %incdec.ptr41 = getelementptr inbounds i8, ptr %97, i64 1
  store ptr %incdec.ptr41, ptr %b, align 8
  store i8 %96, ptr %97, align 1
  br label %if.end44

if.end44:                                         ; preds = %if.end, %lor.end37
  %n.194 = phi i32 [ %n.193, %lor.end37 ], [ %inc, %if.end ]
  %src.1 = phi ptr [ %incdec.ptr39, %lor.end37 ], [ %call20, %if.end ]
  br i1 %cmp.not, label %while.end, label %while.cond, !llvm.loop !146

while.end:                                        ; preds = %if.end44, %if.else, %while.cond
  %n.2 = phi i32 [ %n.194, %if.end44 ], [ %n.193, %if.else ], [ %n.0, %while.cond ]
  %src.2 = phi ptr [ %src.1, %if.end44 ], [ %src.0, %if.else ], [ %src.0, %while.cond ]
  %98 = load ptr, ptr %src_end, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %98 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %src.2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %tobool.not5.i = icmp eq i64 %sub.ptr.sub, 0
  br i1 %tobool.not5.i, label %luaL_addlstring.exit, label %while.body.i

while.body.i:                                     ; preds = %while.end, %lor.end.i
  %dec7.in.i = phi i64 [ %dec7.i, %lor.end.i ], [ %sub.ptr.sub, %while.end ]
  %s.addr.06.i = phi ptr [ %incdec.ptr.i, %lor.end.i ], [ %src.2, %while.end ]
  %dec7.i = add i64 %dec7.in.i, -1
  %99 = load ptr, ptr %b, align 8
  %cmp.i63 = icmp ult ptr %99, %add.ptr.i.i52
  br i1 %cmp.i63, label %lor.end.i, label %lor.rhs.i

lor.rhs.i:                                        ; preds = %while.body.i
  %call.i.i64 = call fastcc i32 @emptybuffer(ptr noundef nonnull %b), !range !23
  %tobool.not.i.i65 = icmp eq i32 %call.i.i64, 0
  br i1 %tobool.not.i.i65, label %lor.end.i, label %if.then.i.i66

if.then.i.i66:                                    ; preds = %lor.rhs.i
  call fastcc void @adjuststack(ptr noundef nonnull %b)
  br label %lor.end.i

lor.end.i:                                        ; preds = %if.then.i.i66, %lor.rhs.i, %while.body.i
  %incdec.ptr.i = getelementptr inbounds i8, ptr %s.addr.06.i, i64 1
  %100 = load i8, ptr %s.addr.06.i, align 1
  %101 = load ptr, ptr %b, align 8
  %incdec.ptr3.i = getelementptr inbounds i8, ptr %101, i64 1
  store ptr %incdec.ptr3.i, ptr %b, align 8
  store i8 %100, ptr %101, align 1
  %tobool.not.i67 = icmp eq i64 %dec7.i, 0
  br i1 %tobool.not.i67, label %luaL_addlstring.exit, label %while.body.i, !llvm.loop !129

luaL_addlstring.exit:                             ; preds = %lor.end.i, %while.end
  %call.i68 = call fastcc i32 @emptybuffer(ptr noundef nonnull %b), !range !23
  %102 = load ptr, ptr %L1.i, align 8
  %103 = load i32, ptr %lvl.i, align 8
  call fastcc void @lua_concat(ptr noundef %102, i32 noundef %103)
  %104 = load ptr, ptr %top.i.i, align 8
  %conv.i = sitofp i32 %n.2 to double
  store double %conv.i, ptr %104, align 8
  %tt.i70 = getelementptr inbounds %struct.lua_TValue, ptr %104, i64 0, i32 1
  store i32 3, ptr %tt.i70, align 8
  %105 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i71 = getelementptr inbounds %struct.lua_TValue, ptr %105, i64 1
  store ptr %incdec.ptr.i71, ptr %top.i.i, align 8
  ret i32 2
}

; Function Attrs: nounwind uwtable
define internal i32 @str_lower(ptr noundef %L) #0 {
entry:
  %l = alloca i64, align 8
  %b = alloca %struct.luaL_Buffer, align 8
  %call.i = call fastcc ptr @lua_tolstring(ptr noundef %L, i32 noundef 1, ptr noundef nonnull %l)
  %tobool.not.i = icmp eq ptr %call.i, null
  br i1 %tobool.not.i, label %if.then.i, label %luaL_checklstring.exit

if.then.i:                                        ; preds = %entry
  call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 1, ptr noundef nonnull @.str.25)
  unreachable

luaL_checklstring.exit:                           ; preds = %entry
  %L1.i = getelementptr inbounds %struct.luaL_Buffer, ptr %b, i64 0, i32 2
  store ptr %L, ptr %L1.i, align 8
  %buffer.i = getelementptr inbounds %struct.luaL_Buffer, ptr %b, i64 0, i32 3
  store ptr %buffer.i, ptr %b, align 8
  %lvl.i = getelementptr inbounds %struct.luaL_Buffer, ptr %b, i64 0, i32 1
  store i32 0, ptr %lvl.i, align 8
  %0 = load i64, ptr %l, align 8
  %cmp10.not = icmp eq i64 %0, 0
  br i1 %cmp10.not, label %for.end, label %for.body.lr.ph

for.body.lr.ph:                                   ; preds = %luaL_checklstring.exit
  %add.ptr = getelementptr inbounds %struct.luaL_Buffer, ptr %b, i64 1
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %lor.end
  %i.011 = phi i64 [ 0, %for.body.lr.ph ], [ %inc, %lor.end ]
  %1 = load ptr, ptr %b, align 8
  %cmp1 = icmp ult ptr %1, %add.ptr
  br i1 %cmp1, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %for.body
  %call.i4 = call fastcc i32 @emptybuffer(ptr noundef nonnull %b), !range !23
  %tobool.not.i5 = icmp eq i32 %call.i4, 0
  br i1 %tobool.not.i5, label %lor.end, label %if.then.i6

if.then.i6:                                       ; preds = %lor.rhs
  call fastcc void @adjuststack(ptr noundef nonnull %b)
  br label %lor.end

lor.end:                                          ; preds = %if.then.i6, %lor.rhs, %for.body
  %arrayidx = getelementptr inbounds i8, ptr %call.i, i64 %i.011
  %2 = load i8, ptr %arrayidx, align 1
  %conv = zext i8 %2 to i32
  %call3 = call i32 @tolower(i32 noundef %conv) #34
  %conv4 = trunc i32 %call3 to i8
  %3 = load ptr, ptr %b, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %3, i64 1
  store ptr %incdec.ptr, ptr %b, align 8
  store i8 %conv4, ptr %3, align 1
  %inc = add nuw i64 %i.011, 1
  %4 = load i64, ptr %l, align 8
  %cmp = icmp ult i64 %inc, %4
  br i1 %cmp, label %for.body, label %for.end, !llvm.loop !147

for.end:                                          ; preds = %lor.end, %luaL_checklstring.exit
  %call.i8 = call fastcc i32 @emptybuffer(ptr noundef nonnull %b), !range !23
  %5 = load ptr, ptr %L1.i, align 8
  %6 = load i32, ptr %lvl.i, align 8
  call fastcc void @lua_concat(ptr noundef %5, i32 noundef %6)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @str_match(ptr noundef %L) #0 {
entry:
  %call = tail call fastcc i32 @str_find_aux(ptr noundef %L, i32 noundef 0)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @str_rep(ptr noundef %L) #0 {
entry:
  %s.i.i = alloca [32 x i8], align 16
  %s.i.i.i = alloca [32 x i8], align 16
  %endptr.i.i.i = alloca ptr, align 8
  %l = alloca i64, align 8
  %b = alloca %struct.luaL_Buffer, align 8
  %call.i = call fastcc ptr @lua_tolstring(ptr noundef %L, i32 noundef 1, ptr noundef nonnull %l)
  %tobool.not.i = icmp eq ptr %call.i, null
  br i1 %tobool.not.i, label %if.then.i, label %luaL_checklstring.exit

if.then.i:                                        ; preds = %entry
  call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 1, ptr noundef nonnull @.str.25)
  unreachable

luaL_checklstring.exit:                           ; preds = %entry
  %call.i3 = call fastcc i64 @lua_tointeger(ptr noundef %L, i32 noundef 2)
  %cmp.i = icmp eq i64 %call.i3, 0
  br i1 %cmp.i, label %land.lhs.true.i, label %luaL_checkinteger.exit

land.lhs.true.i:                                  ; preds = %luaL_checklstring.exit
  %base.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i, align 8
  %add.ptr.i.i = getelementptr %struct.lua_TValue, ptr %0, i64 1
  %top.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i, align 8
  %cmp1.not.i.i = icmp ult ptr %add.ptr.i.i, %1
  %add.ptr.luaO_nilobject_.i.i = select i1 %cmp1.not.i.i, ptr %add.ptr.i.i, ptr @luaO_nilobject_
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i, i64 0, i32 1
  %2 = load i32, ptr %tt.i, align 8
  switch i32 %2, label %if.then.i5 [
    i32 3, label %luaL_checkinteger.exit.thread
    i32 4, label %land.lhs.true.i.i
  ]

land.lhs.true.i.i:                                ; preds = %land.lhs.true.i
  %3 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i, align 8
  %add.ptr.i3.i = getelementptr inbounds %union.TString, ptr %3, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i.i)
  %call.i.i.i = call double @strtod(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i) #35
  %4 = load ptr, ptr %endptr.i.i.i, align 8
  %cmp.i.i.i = icmp eq ptr %4, %add.ptr.i3.i
  br i1 %cmp.i.i.i, label %luaO_str2d.exit.thread.i.i, label %if.end.i.i.i

luaO_str2d.exit.thread.i.i:                       ; preds = %land.lhs.true.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %if.then.i5

if.end.i.i.i:                                     ; preds = %land.lhs.true.i.i
  %5 = load i8, ptr %4, align 1
  switch i8 %5, label %if.end9.i.i.i [
    i8 120, label %if.then6.i.i.i
    i8 88, label %if.then6.i.i.i
  ]

if.then6.i.i.i:                                   ; preds = %if.end.i.i.i, %if.end.i.i.i
  %call7.i.i.i = call i64 @strtoul(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i, i32 noundef 16) #35
  %.pre.i.i.i = load ptr, ptr %endptr.i.i.i, align 8
  %.pre5.i.i.i = load i8, ptr %.pre.i.i.i, align 1
  br label %if.end9.i.i.i

if.end9.i.i.i:                                    ; preds = %if.then6.i.i.i, %if.end.i.i.i
  %6 = phi i8 [ %5, %if.end.i.i.i ], [ %.pre5.i.i.i, %if.then6.i.i.i ]
  %endptr.promoted.i.i.i = phi ptr [ %4, %if.end.i.i.i ], [ %.pre.i.i.i, %if.then6.i.i.i ]
  %cmp11.i.i.i = icmp eq i8 %6, 0
  br i1 %cmp11.i.i.i, label %luaO_str2d.exit.thread9.i.i, label %while.cond.preheader.i.i.i

luaO_str2d.exit.thread9.i.i:                      ; preds = %if.end9.i.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %luaL_checkinteger.exit.thread

while.cond.preheader.i.i.i:                       ; preds = %if.end9.i.i.i
  %call15.i.i.i = tail call ptr @__ctype_b_loc() #39
  %7 = load ptr, ptr %call15.i.i.i, align 8
  br label %while.cond.i.i.i

while.cond.i.i.i:                                 ; preds = %while.cond.i.i.i, %while.cond.preheader.i.i.i
  %incdec.ptr4.i.i.i = phi ptr [ %endptr.promoted.i.i.i, %while.cond.preheader.i.i.i ], [ %incdec.ptr.i.i.i, %while.cond.i.i.i ]
  %8 = load i8, ptr %incdec.ptr4.i.i.i, align 1
  %idxprom.i.i.i = zext i8 %8 to i64
  %arrayidx.i.i.i = getelementptr inbounds i16, ptr %7, i64 %idxprom.i.i.i
  %9 = load i16, ptr %arrayidx.i.i.i, align 2
  %10 = and i16 %9, 8192
  %tobool.not.i.i.i = icmp eq i16 %10, 0
  %incdec.ptr.i.i.i = getelementptr inbounds i8, ptr %incdec.ptr4.i.i.i, i64 1
  br i1 %tobool.not.i.i.i, label %luaO_str2d.exit.i.i, label %while.cond.i.i.i, !llvm.loop !35

luaO_str2d.exit.i.i:                              ; preds = %while.cond.i.i.i
  %cmp19.not.i.not.i.i = icmp eq i8 %8, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br i1 %cmp19.not.i.not.i.i, label %luaL_checkinteger.exit, label %if.then.i5

if.then.i5:                                       ; preds = %land.lhs.true.i, %luaO_str2d.exit.i.i, %luaO_str2d.exit.thread.i.i
  call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 2, ptr noundef nonnull @.str.24)
  unreachable

luaL_checkinteger.exit.thread:                    ; preds = %luaO_str2d.exit.thread9.i.i, %land.lhs.true.i
  %L1.i70 = getelementptr inbounds %struct.luaL_Buffer, ptr %b, i64 0, i32 2
  store ptr %L, ptr %L1.i70, align 8
  %buffer.i71 = getelementptr inbounds %struct.luaL_Buffer, ptr %b, i64 0, i32 3
  store ptr %buffer.i71, ptr %b, align 8
  %lvl.i72 = getelementptr inbounds %struct.luaL_Buffer, ptr %b, i64 0, i32 1
  store i32 0, ptr %lvl.i72, align 8
  br label %while.end

luaL_checkinteger.exit:                           ; preds = %luaO_str2d.exit.i.i, %luaL_checklstring.exit
  %conv = trunc i64 %call.i3 to i32
  %L1.i = getelementptr inbounds %struct.luaL_Buffer, ptr %b, i64 0, i32 2
  store ptr %L, ptr %L1.i, align 8
  %buffer.i = getelementptr inbounds %struct.luaL_Buffer, ptr %b, i64 0, i32 3
  store ptr %buffer.i, ptr %b, align 8
  %lvl.i = getelementptr inbounds %struct.luaL_Buffer, ptr %b, i64 0, i32 1
  store i32 0, ptr %lvl.i, align 8
  %cmp59 = icmp sgt i32 %conv, 0
  br i1 %cmp59, label %while.body.lr.ph, label %while.end

while.body.lr.ph:                                 ; preds = %luaL_checkinteger.exit
  %add.ptr.i = getelementptr inbounds %struct.luaL_Buffer, ptr %b, i64 1
  %sub.ptr.rhs.cast.i = ptrtoint ptr %buffer.i to i64
  %11 = load i64, ptr %l, align 8
  %12 = icmp eq i64 %11, 0
  br i1 %12, label %while.end, label %while.body

while.bodythread-pre-split:                       ; preds = %luaL_addlstring.exit
  %.pr = load i64, ptr %l, align 8
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %while.bodythread-pre-split
  %13 = phi i64 [ %.pr, %while.bodythread-pre-split ], [ %11, %while.body.lr.ph ]
  %n.060 = phi i32 [ %dec, %while.bodythread-pre-split ], [ %conv, %while.body.lr.ph ]
  %dec = add nsw i32 %n.060, -1
  %tobool.not5.i = icmp eq i64 %13, 0
  br i1 %tobool.not5.i, label %luaL_addlstring.exit, label %while.body.i

while.body.i:                                     ; preds = %while.body, %lor.end.i
  %dec7.in.i = phi i64 [ %dec7.i, %lor.end.i ], [ %13, %while.body ]
  %s.addr.06.i = phi ptr [ %incdec.ptr.i, %lor.end.i ], [ %call.i, %while.body ]
  %dec7.i = add i64 %dec7.in.i, -1
  %14 = load ptr, ptr %b, align 8
  %cmp.i7 = icmp ult ptr %14, %add.ptr.i
  br i1 %cmp.i7, label %lor.end.i, label %if.else.i

if.else.i:                                        ; preds = %while.body.i
  %sub.ptr.lhs.cast.i = ptrtoint ptr %14 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %15 = load ptr, ptr %L1.i, align 8
  %l_G.i.i = getelementptr inbounds %struct.lua_State, ptr %15, i64 0, i32 6
  %16 = load ptr, ptr %l_G.i.i, align 8
  %totalbytes.i.i = getelementptr inbounds %struct.global_State, ptr %16, i64 0, i32 14
  %17 = load i64, ptr %totalbytes.i.i, align 8
  %GCthreshold.i.i = getelementptr inbounds %struct.global_State, ptr %16, i64 0, i32 13
  %18 = load i64, ptr %GCthreshold.i.i, align 8
  %cmp.not.i.i = icmp ult i64 %17, %18
  br i1 %cmp.not.i.i, label %if.then.i.i, label %if.then.i.i21

if.then.i.i21:                                    ; preds = %if.else.i
  %gcstepmul.i.i.i = getelementptr inbounds %struct.global_State, ptr %16, i64 0, i32 18
  %19 = load i32, ptr %gcstepmul.i.i.i, align 4
  %mul.i.i.i = mul i32 %19, 10
  %conv.i.i.i = zext i32 %mul.i.i.i to i64
  %cmp.i.i.i22 = icmp eq i32 %mul.i.i.i, 0
  %spec.store.select.i.i.i = select i1 %cmp.i.i.i22, i64 9223372036854775806, i64 %conv.i.i.i
  %sub.i.i.i = sub i64 %17, %18
  %gcdept.i.i.i = getelementptr inbounds %struct.global_State, ptr %16, i64 0, i32 16
  %20 = load i64, ptr %gcdept.i.i.i, align 8
  %add.i.i.i = add i64 %sub.i.i.i, %20
  store i64 %add.i.i.i, ptr %gcdept.i.i.i, align 8
  %gcstate.i.i.i = getelementptr inbounds %struct.global_State, ptr %16, i64 0, i32 4
  br label %do.body.i.i.i

do.body.i.i.i:                                    ; preds = %do.body.i.i.i, %if.then.i.i21
  %lim.0.i.i.i = phi i64 [ %spec.store.select.i.i.i, %if.then.i.i21 ], [ %sub2.i.i.i, %do.body.i.i.i ]
  %call.i.i.i23 = call fastcc i64 @singlestep(ptr noundef %15)
  %sub2.i.i.i = sub nsw i64 %lim.0.i.i.i, %call.i.i.i23
  %21 = load i8, ptr %gcstate.i.i.i, align 1
  %cmp4.i.i.i = icmp ne i8 %21, 0
  %cmp8.i.i.i = icmp sgt i64 %sub2.i.i.i, 0
  %or.cond.i.i.i = select i1 %cmp4.i.i.i, i1 %cmp8.i.i.i, i1 false
  br i1 %or.cond.i.i.i, label %do.body.i.i.i, label %do.end.i.i.i, !llvm.loop !6

do.end.i.i.i:                                     ; preds = %do.body.i.i.i
  br i1 %cmp4.i.i.i, label %if.then14.i.i.i, label %if.else27.i.i.i

if.then14.i.i.i:                                  ; preds = %do.end.i.i.i
  %22 = load i64, ptr %gcdept.i.i.i, align 8
  %cmp16.i.i.i = icmp ult i64 %22, 1024
  br i1 %cmp16.i.i.i, label %if.then18.i.i.i, label %if.else.i.i.i

if.then18.i.i.i:                                  ; preds = %if.then14.i.i.i
  %23 = load i64, ptr %totalbytes.i.i, align 8
  %add20.i.i.i = add i64 %23, 1024
  br label %luaC_step.exit.i.i

if.else.i.i.i:                                    ; preds = %if.then14.i.i.i
  %sub23.i.i.i = add i64 %22, -1024
  store i64 %sub23.i.i.i, ptr %gcdept.i.i.i, align 8
  %24 = load i64, ptr %totalbytes.i.i, align 8
  br label %luaC_step.exit.i.i

if.else27.i.i.i:                                  ; preds = %do.end.i.i.i
  %estimate.i.i.i = getelementptr inbounds %struct.global_State, ptr %16, i64 0, i32 15
  %25 = load i64, ptr %estimate.i.i.i, align 8
  %div.i.i.i = udiv i64 %25, 100
  %gcpause.i.i.i = getelementptr inbounds %struct.global_State, ptr %16, i64 0, i32 17
  %26 = load i32, ptr %gcpause.i.i.i, align 8
  %conv28.i.i.i = sext i32 %26 to i64
  %mul29.i.i.i = mul i64 %div.i.i.i, %conv28.i.i.i
  br label %luaC_step.exit.i.i

luaC_step.exit.i.i:                               ; preds = %if.else27.i.i.i, %if.else.i.i.i, %if.then18.i.i.i
  %add20.sink.i.i.i = phi i64 [ %add20.i.i.i, %if.then18.i.i.i ], [ %24, %if.else.i.i.i ], [ %mul29.i.i.i, %if.else27.i.i.i ]
  store i64 %add20.sink.i.i.i, ptr %GCthreshold.i.i, align 8
  br label %if.then.i.i

if.then.i.i:                                      ; preds = %luaC_step.exit.i.i, %if.else.i
  %top.i.i24 = getelementptr inbounds %struct.lua_State, ptr %15, i64 0, i32 4
  %27 = load ptr, ptr %top.i.i24, align 8
  %call.i.i25 = call fastcc ptr @luaS_newlstr(ptr noundef %15, ptr noundef nonnull %buffer.i, i64 noundef %sub.ptr.sub.i)
  store ptr %call.i.i25, ptr %27, align 8
  %tt.i.i26 = getelementptr inbounds %struct.lua_TValue, ptr %27, i64 0, i32 1
  store i32 4, ptr %tt.i.i26, align 8
  %28 = load ptr, ptr %top.i.i24, align 8
  %incdec.ptr.i.i = getelementptr inbounds %struct.lua_TValue, ptr %28, i64 1
  store ptr %incdec.ptr.i.i, ptr %top.i.i24, align 8
  store ptr %buffer.i, ptr %b, align 8
  %29 = load i32, ptr %lvl.i, align 8
  %inc.i = add nsw i32 %29, 1
  store i32 %inc.i, ptr %lvl.i, align 8
  %cmp.i14 = icmp sgt i32 %29, 0
  br i1 %cmp.i14, label %if.then.i15, label %lor.end.i

if.then.i15:                                      ; preds = %if.then.i.i
  %30 = load ptr, ptr %L1.i, align 8
  %top6.i.i.i = getelementptr inbounds %struct.lua_State, ptr %30, i64 0, i32 4
  %31 = load ptr, ptr %top6.i.i.i, align 8
  %add.ptr8.i.i.i = getelementptr inbounds %struct.lua_TValue, ptr %31, i64 -1
  %tt.i.i = getelementptr %struct.lua_TValue, ptr %31, i64 -1, i32 1
  %32 = load i32, ptr %tt.i.i, align 8
  switch i32 %32, label %lua_objlen.exit.i [
    i32 4, label %sw.bb.i.i
    i32 7, label %sw.bb1.i.i
    i32 5, label %sw.bb4.i.i
    i32 3, label %cond.true.i.i
  ]

sw.bb.i.i:                                        ; preds = %if.then.i15
  %33 = load ptr, ptr %add.ptr8.i.i.i, align 8
  %len.i.i = getelementptr inbounds %struct.anon.0, ptr %33, i64 0, i32 5
  %34 = load i64, ptr %len.i.i, align 8
  br label %lua_objlen.exit.i

sw.bb1.i.i:                                       ; preds = %if.then.i15
  %35 = load ptr, ptr %add.ptr8.i.i.i, align 8
  %len3.i.i = getelementptr inbounds %struct.anon.1, ptr %35, i64 0, i32 5
  %36 = load i64, ptr %len3.i.i, align 8
  br label %lua_objlen.exit.i

sw.bb4.i.i:                                       ; preds = %if.then.i15
  %37 = load ptr, ptr %add.ptr8.i.i.i, align 8
  %call6.i.i = call fastcc i32 @luaH_getn(ptr noundef %37)
  %conv.i.i = sext i32 %call6.i.i to i64
  br label %lua_objlen.exit.i

cond.true.i.i:                                    ; preds = %if.then.i15
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %s.i.i.i)
  %38 = load double, ptr %add.ptr8.i.i.i, align 8
  %call.i.i.i17 = call i32 (ptr, ptr, ...) @sprintf(ptr noundef nonnull dereferenceable(1) %s.i.i.i, ptr noundef nonnull dereferenceable(1) @.str.16, double noundef %38) #35
  %call3.i.i.i = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %s.i.i.i) #34
  %call4.i.i.i = call fastcc ptr @luaS_newlstr(ptr noundef nonnull %30, ptr noundef nonnull %s.i.i.i, i64 noundef %call3.i.i.i)
  store ptr %call4.i.i.i, ptr %add.ptr8.i.i.i, align 8
  store i32 4, ptr %tt.i.i, align 8
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %s.i.i.i)
  %len10.i.i = getelementptr inbounds %struct.anon.0, ptr %call4.i.i.i, i64 0, i32 5
  %39 = load i64, ptr %len10.i.i, align 8
  br label %lua_objlen.exit.i

lua_objlen.exit.i:                                ; preds = %cond.true.i.i, %sw.bb4.i.i, %sw.bb1.i.i, %sw.bb.i.i, %if.then.i15
  %retval.0.i.i = phi i64 [ %conv.i.i, %sw.bb4.i.i ], [ %36, %sw.bb1.i.i ], [ %34, %sw.bb.i.i ], [ %39, %cond.true.i.i ], [ 0, %if.then.i15 ]
  %l_gt.i.i = getelementptr inbounds %struct.lua_State, ptr %30, i64 0, i32 22
  %ci.i.i = getelementptr inbounds %struct.lua_State, ptr %30, i64 0, i32 7
  %env.i.i = getelementptr inbounds %struct.lua_State, ptr %30, i64 0, i32 23
  %tt.i.i44 = getelementptr inbounds %struct.lua_State, ptr %30, i64 0, i32 23, i32 1
  %l_G.i.i46 = getelementptr inbounds %struct.lua_State, ptr %30, i64 0, i32 6
  br label %do.body.i

do.body.i:                                        ; preds = %if.then8.i, %lua_objlen.exit.i
  %indvars.iv = phi i64 [ %indvars.iv.next, %if.then8.i ], [ 1, %lua_objlen.exit.i ]
  %toplen.0.i = phi i64 [ %add9.i, %if.then8.i ], [ %retval.0.i.i, %lua_objlen.exit.i ]
  %indvars66 = trunc i64 %indvars.iv to i32
  %40 = xor i64 %indvars.iv, -1
  %cmp4.i.i38 = icmp ult i64 %indvars.iv, 9999
  br i1 %cmp4.i.i38, label %if.then5.i.i, label %if.else9.i.i

if.then5.i.i:                                     ; preds = %do.body.i
  %41 = load ptr, ptr %top6.i.i.i, align 8
  %add.ptr8.i.i = getelementptr inbounds %struct.lua_TValue, ptr %41, i64 %40
  br label %index2adr.exit.i

if.else9.i.i:                                     ; preds = %do.body.i
  %42 = trunc i64 %40 to i32
  switch i32 %42, label %sw.default.i.i [
    i32 -10000, label %sw.bb.i.i45
    i32 -10001, label %sw.bb10.i.i
    i32 -10002, label %index2adr.exit.i
  ]

sw.bb.i.i45:                                      ; preds = %if.else9.i.i
  %43 = load ptr, ptr %l_G.i.i46, align 8
  %l_registry.i.i = getelementptr inbounds %struct.global_State, ptr %43, i64 0, i32 20
  br label %index2adr.exit.i

sw.bb10.i.i:                                      ; preds = %if.else9.i.i
  %44 = load ptr, ptr %ci.i.i, align 8
  %func11.i.i = getelementptr inbounds %struct.CallInfo, ptr %44, i64 0, i32 1
  %45 = load ptr, ptr %func11.i.i, align 8
  %46 = load ptr, ptr %45, align 8
  %env12.i.i = getelementptr inbounds %struct.CClosure, ptr %46, i64 0, i32 6
  %47 = load ptr, ptr %env12.i.i, align 8
  store ptr %47, ptr %env.i.i, align 8
  store i32 5, ptr %tt.i.i44, align 8
  br label %index2adr.exit.i

sw.default.i.i:                                   ; preds = %if.else9.i.i
  %48 = load ptr, ptr %ci.i.i, align 8
  %func18.i.i = getelementptr inbounds %struct.CallInfo, ptr %48, i64 0, i32 1
  %49 = load ptr, ptr %func18.i.i, align 8
  %50 = load ptr, ptr %49, align 8
  %nupvalues.i.i = getelementptr inbounds %struct.CClosure, ptr %50, i64 0, i32 4
  %51 = load i8, ptr %nupvalues.i.i, align 1
  %conv.i.i47 = zext i8 %51 to i32
  %52 = trunc i64 %indvars.iv to i32
  %53 = add i32 %52, -10001
  %cmp21.not.i.i = icmp ugt i32 %53, %conv.i.i47
  %54 = add nsw i64 %indvars.iv, -10002
  %arrayidx.i.i = getelementptr inbounds %struct.CClosure, ptr %50, i64 0, i32 8, i64 %54
  %cond.i.i = select i1 %cmp21.not.i.i, ptr @luaO_nilobject_, ptr %arrayidx.i.i
  br label %index2adr.exit.i

index2adr.exit.i:                                 ; preds = %if.else9.i.i, %sw.default.i.i, %sw.bb10.i.i, %sw.bb.i.i45, %if.then5.i.i
  %retval.0.i.i39 = phi ptr [ %add.ptr8.i.i, %if.then5.i.i ], [ %cond.i.i, %sw.default.i.i ], [ %env.i.i, %sw.bb10.i.i ], [ %l_registry.i.i, %sw.bb.i.i45 ], [ %l_gt.i.i, %if.else9.i.i ]
  %tt.i40 = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i.i39, i64 0, i32 1
  %55 = load i32, ptr %tt.i40, align 8
  switch i32 %55, label %lua_objlen.exit [
    i32 4, label %sw.bb.i
    i32 7, label %sw.bb1.i
    i32 5, label %sw.bb4.i
    i32 3, label %cond.true.i
  ]

sw.bb.i:                                          ; preds = %index2adr.exit.i
  %56 = load ptr, ptr %retval.0.i.i39, align 8
  %len.i = getelementptr inbounds %struct.anon.0, ptr %56, i64 0, i32 5
  %57 = load i64, ptr %len.i, align 8
  br label %lua_objlen.exit

sw.bb1.i:                                         ; preds = %index2adr.exit.i
  %58 = load ptr, ptr %retval.0.i.i39, align 8
  %len3.i = getelementptr inbounds %struct.anon.1, ptr %58, i64 0, i32 5
  %59 = load i64, ptr %len3.i, align 8
  br label %lua_objlen.exit

sw.bb4.i:                                         ; preds = %index2adr.exit.i
  %60 = load ptr, ptr %retval.0.i.i39, align 8
  %call6.i = call fastcc i32 @luaH_getn(ptr noundef %60)
  %conv.i43 = sext i32 %call6.i to i64
  br label %lua_objlen.exit

cond.true.i:                                      ; preds = %index2adr.exit.i
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %s.i.i)
  %61 = load double, ptr %retval.0.i.i39, align 8
  %call.i.i41 = call i32 (ptr, ptr, ...) @sprintf(ptr noundef nonnull dereferenceable(1) %s.i.i, ptr noundef nonnull dereferenceable(1) @.str.16, double noundef %61) #35
  %call3.i.i = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %s.i.i) #34
  %call4.i.i = call fastcc ptr @luaS_newlstr(ptr noundef %30, ptr noundef nonnull %s.i.i, i64 noundef %call3.i.i)
  store ptr %call4.i.i, ptr %retval.0.i.i39, align 8
  store i32 4, ptr %tt.i40, align 8
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %s.i.i)
  %len10.i = getelementptr inbounds %struct.anon.0, ptr %call4.i.i, i64 0, i32 5
  %62 = load i64, ptr %len10.i, align 8
  br label %lua_objlen.exit

lua_objlen.exit:                                  ; preds = %index2adr.exit.i, %sw.bb.i, %sw.bb1.i, %sw.bb4.i, %cond.true.i
  %retval.0.i42 = phi i64 [ %conv.i43, %sw.bb4.i ], [ %59, %sw.bb1.i ], [ %57, %sw.bb.i ], [ %62, %cond.true.i ], [ 0, %index2adr.exit.i ]
  %63 = load i32, ptr %lvl.i, align 8
  %sub4.i = sub i32 %63, %indvars66
  %cmp6.i = icmp sgt i32 %sub4.i, 8
  %cmp7.i = icmp ugt i64 %toplen.0.i, %retval.0.i42
  %or.cond.i = select i1 %cmp6.i, i1 true, i1 %cmp7.i
  br i1 %or.cond.i, label %if.then8.i, label %do.end.i

if.then8.i:                                       ; preds = %lua_objlen.exit
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %add9.i = add i64 %retval.0.i42, %toplen.0.i
  %64 = sext i32 %63 to i64
  %cmp11.i = icmp slt i64 %indvars.iv.next, %64
  br i1 %cmp11.i, label %do.body.i, label %if.then.i30.loopexit, !llvm.loop !128

do.end.i:                                         ; preds = %lua_objlen.exit
  %cmp.i28 = icmp ugt i32 %indvars66, 1
  br i1 %cmp.i28, label %if.then.i30, label %lua_concat.exit

if.then.i30.loopexit:                             ; preds = %if.then8.i
  %65 = trunc i64 %indvars.iv.next to i32
  br label %if.then.i30

if.then.i30:                                      ; preds = %if.then.i30.loopexit, %do.end.i
  %toget.1.i56 = phi i32 [ %indvars66, %do.end.i ], [ %65, %if.then.i30.loopexit ]
  %66 = load ptr, ptr %l_G.i.i46, align 8
  %totalbytes.i = getelementptr inbounds %struct.global_State, ptr %66, i64 0, i32 14
  %67 = load i64, ptr %totalbytes.i, align 8
  %GCthreshold.i = getelementptr inbounds %struct.global_State, ptr %66, i64 0, i32 13
  %68 = load i64, ptr %GCthreshold.i, align 8
  %cmp2.not.i = icmp ult i64 %67, %68
  br i1 %cmp2.not.i, label %if.end.i, label %if.then3.i

if.then3.i:                                       ; preds = %if.then.i30
  %gcstepmul.i.i = getelementptr inbounds %struct.global_State, ptr %66, i64 0, i32 18
  %69 = load i32, ptr %gcstepmul.i.i, align 4
  %mul.i.i = mul i32 %69, 10
  %conv.i.i31 = zext i32 %mul.i.i to i64
  %cmp.i.i = icmp eq i32 %mul.i.i, 0
  %spec.store.select.i.i = select i1 %cmp.i.i, i64 9223372036854775806, i64 %conv.i.i31
  %sub.i.i = sub i64 %67, %68
  %gcdept.i.i = getelementptr inbounds %struct.global_State, ptr %66, i64 0, i32 16
  %70 = load i64, ptr %gcdept.i.i, align 8
  %add.i.i = add i64 %sub.i.i, %70
  store i64 %add.i.i, ptr %gcdept.i.i, align 8
  %gcstate.i.i = getelementptr inbounds %struct.global_State, ptr %66, i64 0, i32 4
  br label %do.body.i.i

do.body.i.i:                                      ; preds = %do.body.i.i, %if.then3.i
  %lim.0.i.i = phi i64 [ %spec.store.select.i.i, %if.then3.i ], [ %sub2.i.i, %do.body.i.i ]
  %call.i.i = call fastcc i64 @singlestep(ptr noundef %30)
  %sub2.i.i = sub nsw i64 %lim.0.i.i, %call.i.i
  %71 = load i8, ptr %gcstate.i.i, align 1
  %cmp4.i.i = icmp ne i8 %71, 0
  %cmp8.i.i = icmp sgt i64 %sub2.i.i, 0
  %or.cond.i.i = select i1 %cmp4.i.i, i1 %cmp8.i.i, i1 false
  br i1 %or.cond.i.i, label %do.body.i.i, label %do.end.i.i, !llvm.loop !6

do.end.i.i:                                       ; preds = %do.body.i.i
  br i1 %cmp4.i.i, label %if.then14.i.i, label %if.else27.i.i

if.then14.i.i:                                    ; preds = %do.end.i.i
  %72 = load i64, ptr %gcdept.i.i, align 8
  %cmp16.i.i = icmp ult i64 %72, 1024
  br i1 %cmp16.i.i, label %if.then18.i.i, label %if.else.i.i

if.then18.i.i:                                    ; preds = %if.then14.i.i
  %73 = load i64, ptr %totalbytes.i, align 8
  %add20.i.i = add i64 %73, 1024
  br label %luaC_step.exit.i

if.else.i.i:                                      ; preds = %if.then14.i.i
  %sub23.i.i = add i64 %72, -1024
  store i64 %sub23.i.i, ptr %gcdept.i.i, align 8
  %74 = load i64, ptr %totalbytes.i, align 8
  br label %luaC_step.exit.i

if.else27.i.i:                                    ; preds = %do.end.i.i
  %estimate.i.i = getelementptr inbounds %struct.global_State, ptr %66, i64 0, i32 15
  %75 = load i64, ptr %estimate.i.i, align 8
  %div.i.i = udiv i64 %75, 100
  %gcpause.i.i = getelementptr inbounds %struct.global_State, ptr %66, i64 0, i32 17
  %76 = load i32, ptr %gcpause.i.i, align 8
  %conv28.i.i = sext i32 %76 to i64
  %mul29.i.i = mul i64 %div.i.i, %conv28.i.i
  br label %luaC_step.exit.i

luaC_step.exit.i:                                 ; preds = %if.else27.i.i, %if.else.i.i, %if.then18.i.i
  %add20.sink.i.i = phi i64 [ %add20.i.i, %if.then18.i.i ], [ %74, %if.else.i.i ], [ %mul29.i.i, %if.else27.i.i ]
  store i64 %add20.sink.i.i, ptr %GCthreshold.i, align 8
  br label %if.end.i

if.end.i:                                         ; preds = %luaC_step.exit.i, %if.then.i30
  %77 = load ptr, ptr %top6.i.i.i, align 8
  %base.i = getelementptr inbounds %struct.lua_State, ptr %30, i64 0, i32 5
  %78 = load ptr, ptr %base.i, align 8
  %sub.ptr.lhs.cast.i32 = ptrtoint ptr %77 to i64
  %sub.ptr.rhs.cast.i33 = ptrtoint ptr %78 to i64
  %sub.ptr.sub.i34 = sub i64 %sub.ptr.lhs.cast.i32, %sub.ptr.rhs.cast.i33
  %sub.ptr.div.i = lshr exact i64 %sub.ptr.sub.i34, 4
  %conv.i = trunc i64 %sub.ptr.div.i to i32
  %sub.i35 = add nsw i32 %conv.i, -1
  call fastcc void @luaV_concat(ptr noundef %30, i32 noundef %toget.1.i56, i32 noundef %sub.i35)
  %sub4.i36 = add nsw i32 %toget.1.i56, -1
  %79 = load ptr, ptr %top6.i.i.i, align 8
  %idx.ext.i = zext nneg i32 %sub4.i36 to i64
  %idx.neg.i = sub nsw i64 0, %idx.ext.i
  %add.ptr.i37 = getelementptr inbounds %struct.lua_TValue, ptr %79, i64 %idx.neg.i
  store ptr %add.ptr.i37, ptr %top6.i.i.i, align 8
  %.pre = load i32, ptr %lvl.i, align 8
  %.pre68 = sub i32 %.pre, %toget.1.i56
  br label %lua_concat.exit

lua_concat.exit:                                  ; preds = %do.end.i, %if.end.i
  %reass.sub.pre-phi = phi i32 [ %sub4.i, %do.end.i ], [ %.pre68, %if.end.i ]
  %add14.i = add i32 %reass.sub.pre-phi, 1
  store i32 %add14.i, ptr %lvl.i, align 8
  %.pre67 = load ptr, ptr %b, align 8
  br label %lor.end.i

lor.end.i:                                        ; preds = %lua_concat.exit, %if.then.i.i, %while.body.i
  %80 = phi ptr [ %.pre67, %lua_concat.exit ], [ %buffer.i, %if.then.i.i ], [ %14, %while.body.i ]
  %incdec.ptr.i = getelementptr inbounds i8, ptr %s.addr.06.i, i64 1
  %81 = load i8, ptr %s.addr.06.i, align 1
  %incdec.ptr3.i = getelementptr inbounds i8, ptr %80, i64 1
  store ptr %incdec.ptr3.i, ptr %b, align 8
  store i8 %81, ptr %80, align 1
  %tobool.not.i8 = icmp eq i64 %dec7.i, 0
  br i1 %tobool.not.i8, label %luaL_addlstring.exit, label %while.body.i, !llvm.loop !129

luaL_addlstring.exit:                             ; preds = %lor.end.i, %while.body
  %cmp = icmp sgt i32 %n.060, 1
  br i1 %cmp, label %while.bodythread-pre-split, label %while.end, !llvm.loop !148

while.end:                                        ; preds = %luaL_addlstring.exit, %while.body.lr.ph, %luaL_checkinteger.exit.thread, %luaL_checkinteger.exit
  %lvl.i75 = phi ptr [ %lvl.i72, %luaL_checkinteger.exit.thread ], [ %lvl.i, %luaL_checkinteger.exit ], [ %lvl.i, %while.body.lr.ph ], [ %lvl.i, %luaL_addlstring.exit ]
  %L1.i74 = phi ptr [ %L1.i70, %luaL_checkinteger.exit.thread ], [ %L1.i, %luaL_checkinteger.exit ], [ %L1.i, %while.body.lr.ph ], [ %L1.i, %luaL_addlstring.exit ]
  %call.i9 = call fastcc i32 @emptybuffer(ptr noundef nonnull %b), !range !23
  %82 = load ptr, ptr %L1.i74, align 8
  %83 = load i32, ptr %lvl.i75, align 8
  call fastcc void @lua_concat(ptr noundef %82, i32 noundef %83)
  store i32 1, ptr %lvl.i75, align 8
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @str_sub(ptr noundef %L) #0 {
entry:
  %endptr.i.i.i71 = alloca ptr, align 8
  %endptr.i.i.i = alloca ptr, align 8
  %l = alloca i64, align 8
  %call.i = call fastcc ptr @lua_tolstring(ptr noundef %L, i32 noundef 1, ptr noundef nonnull %l)
  %tobool.not.i = icmp eq ptr %call.i, null
  br i1 %tobool.not.i, label %if.then.i, label %luaL_checklstring.exit

if.then.i:                                        ; preds = %entry
  call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 1, ptr noundef nonnull @.str.25)
  unreachable

luaL_checklstring.exit:                           ; preds = %entry
  %call.i10 = call fastcc i64 @lua_tointeger(ptr noundef %L, i32 noundef 2)
  %cmp.i = icmp eq i64 %call.i10, 0
  br i1 %cmp.i, label %land.lhs.true.i, label %luaL_checkinteger.exit

land.lhs.true.i:                                  ; preds = %luaL_checklstring.exit
  %base.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i, align 8
  %add.ptr.i.i = getelementptr %struct.lua_TValue, ptr %0, i64 1
  %top.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i, align 8
  %cmp1.not.i.i = icmp ult ptr %add.ptr.i.i, %1
  %add.ptr.luaO_nilobject_.i.i = select i1 %cmp1.not.i.i, ptr %add.ptr.i.i, ptr @luaO_nilobject_
  %tt.i69 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i, i64 0, i32 1
  %2 = load i32, ptr %tt.i69, align 8
  switch i32 %2, label %if.then.i12 [
    i32 3, label %luaL_checkinteger.exit
    i32 4, label %land.lhs.true.i.i70
  ]

land.lhs.true.i.i70:                              ; preds = %land.lhs.true.i
  %3 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i, align 8
  %add.ptr.i3.i = getelementptr inbounds %union.TString, ptr %3, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i.i)
  %call.i.i.i = call double @strtod(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i) #35
  %4 = load ptr, ptr %endptr.i.i.i, align 8
  %cmp.i.i.i = icmp eq ptr %4, %add.ptr.i3.i
  br i1 %cmp.i.i.i, label %luaO_str2d.exit.thread.i.i, label %if.end.i.i.i

luaO_str2d.exit.thread.i.i:                       ; preds = %land.lhs.true.i.i70
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %if.then.i12

if.end.i.i.i:                                     ; preds = %land.lhs.true.i.i70
  %5 = load i8, ptr %4, align 1
  switch i8 %5, label %if.end9.i.i.i [
    i8 120, label %if.then6.i.i.i
    i8 88, label %if.then6.i.i.i
  ]

if.then6.i.i.i:                                   ; preds = %if.end.i.i.i, %if.end.i.i.i
  %call7.i.i.i = call i64 @strtoul(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i, i32 noundef 16) #35
  %.pre.i.i.i = load ptr, ptr %endptr.i.i.i, align 8
  %.pre5.i.i.i = load i8, ptr %.pre.i.i.i, align 1
  br label %if.end9.i.i.i

if.end9.i.i.i:                                    ; preds = %if.then6.i.i.i, %if.end.i.i.i
  %6 = phi i8 [ %5, %if.end.i.i.i ], [ %.pre5.i.i.i, %if.then6.i.i.i ]
  %endptr.promoted.i.i.i = phi ptr [ %4, %if.end.i.i.i ], [ %.pre.i.i.i, %if.then6.i.i.i ]
  %cmp11.i.i.i = icmp eq i8 %6, 0
  br i1 %cmp11.i.i.i, label %luaO_str2d.exit.thread9.i.i, label %while.cond.preheader.i.i.i

luaO_str2d.exit.thread9.i.i:                      ; preds = %if.end9.i.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %luaL_checkinteger.exit

while.cond.preheader.i.i.i:                       ; preds = %if.end9.i.i.i
  %call15.i.i.i = tail call ptr @__ctype_b_loc() #39
  %7 = load ptr, ptr %call15.i.i.i, align 8
  br label %while.cond.i.i.i

while.cond.i.i.i:                                 ; preds = %while.cond.i.i.i, %while.cond.preheader.i.i.i
  %incdec.ptr4.i.i.i = phi ptr [ %endptr.promoted.i.i.i, %while.cond.preheader.i.i.i ], [ %incdec.ptr.i.i.i, %while.cond.i.i.i ]
  %8 = load i8, ptr %incdec.ptr4.i.i.i, align 1
  %idxprom.i.i.i = zext i8 %8 to i64
  %arrayidx.i.i.i = getelementptr inbounds i16, ptr %7, i64 %idxprom.i.i.i
  %9 = load i16, ptr %arrayidx.i.i.i, align 2
  %10 = and i16 %9, 8192
  %tobool.not.i.i.i = icmp eq i16 %10, 0
  %incdec.ptr.i.i.i = getelementptr inbounds i8, ptr %incdec.ptr4.i.i.i, i64 1
  br i1 %tobool.not.i.i.i, label %luaO_str2d.exit.i.i, label %while.cond.i.i.i, !llvm.loop !35

luaO_str2d.exit.i.i:                              ; preds = %while.cond.i.i.i
  %cmp19.not.i.not.i.i = icmp eq i8 %8, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br i1 %cmp19.not.i.not.i.i, label %luaL_checkinteger.exit, label %if.then.i12

if.then.i12:                                      ; preds = %land.lhs.true.i, %luaO_str2d.exit.i.i, %luaO_str2d.exit.thread.i.i
  call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 2, ptr noundef nonnull @.str.24)
  unreachable

luaL_checkinteger.exit:                           ; preds = %luaO_str2d.exit.thread9.i.i, %luaO_str2d.exit.i.i, %land.lhs.true.i, %luaL_checklstring.exit
  %11 = load i64, ptr %l, align 8
  %cmp.i14 = icmp slt i64 %call.i10, 0
  %add.i = add nsw i64 %11, 1
  %add1.i = select i1 %cmp.i14, i64 %add.i, i64 0
  %pos.addr.0.i = add nsw i64 %add1.i, %call.i10
  %base.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %12 = load ptr, ptr %base.i.i.i, align 8
  %add.ptr.i.i.i = getelementptr %struct.lua_TValue, ptr %12, i64 2
  %top.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %13 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i.i = icmp uge ptr %add.ptr.i.i.i, %13
  %cmp.i.i = icmp eq ptr %add.ptr.i.i.i, @luaO_nilobject_
  %or.cond = or i1 %cmp1.not.i.i.i, %cmp.i.i
  br i1 %or.cond, label %luaL_optinteger.exit.thread, label %lua_type.exit.i

lua_type.exit.i:                                  ; preds = %luaL_checkinteger.exit
  %tt.i.i = getelementptr %struct.lua_TValue, ptr %12, i64 2, i32 1
  %14 = load i32, ptr %tt.i.i, align 8
  %cmp.i16 = icmp slt i32 %14, 1
  br i1 %cmp.i16, label %luaL_optinteger.exit.thread, label %cond.false.i

cond.false.i:                                     ; preds = %lua_type.exit.i
  %call.i.i = call fastcc i64 @lua_tointeger(ptr noundef nonnull %L, i32 noundef 3)
  %call.i.i.fr = freeze i64 %call.i.i
  %cmp.i3.i = icmp eq i64 %call.i.i.fr, 0
  br i1 %cmp.i3.i, label %land.lhs.true.i.i, label %luaL_optinteger.exit

land.lhs.true.i.i:                                ; preds = %cond.false.i
  %15 = load ptr, ptr %base.i.i.i, align 8
  %add.ptr.i.i74 = getelementptr %struct.lua_TValue, ptr %15, i64 2
  %16 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i76 = icmp ult ptr %add.ptr.i.i74, %16
  %add.ptr.luaO_nilobject_.i.i77 = select i1 %cmp1.not.i.i76, ptr %add.ptr.i.i74, ptr @luaO_nilobject_
  %tt.i78 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i77, i64 0, i32 1
  %17 = load i32, ptr %tt.i78, align 8
  switch i32 %17, label %if.then.i.i [
    i32 3, label %luaL_optinteger.exit.thread119
    i32 4, label %land.lhs.true.i.i79
  ]

land.lhs.true.i.i79:                              ; preds = %land.lhs.true.i.i
  %18 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i77, align 8
  %add.ptr.i3.i80 = getelementptr inbounds %union.TString, ptr %18, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i.i71)
  %call.i.i.i81 = call double @strtod(ptr noundef nonnull %add.ptr.i3.i80, ptr noundef nonnull %endptr.i.i.i71) #35
  %19 = load ptr, ptr %endptr.i.i.i71, align 8
  %cmp.i.i.i82 = icmp eq ptr %19, %add.ptr.i3.i80
  br i1 %cmp.i.i.i82, label %luaO_str2d.exit.thread.i.i104, label %if.end.i.i.i83

luaO_str2d.exit.thread.i.i104:                    ; preds = %land.lhs.true.i.i79
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i71)
  br label %if.then.i.i

if.end.i.i.i83:                                   ; preds = %land.lhs.true.i.i79
  %20 = load i8, ptr %19, align 1
  switch i8 %20, label %if.end9.i.i.i88 [
    i8 120, label %if.then6.i.i.i84
    i8 88, label %if.then6.i.i.i84
  ]

if.then6.i.i.i84:                                 ; preds = %if.end.i.i.i83, %if.end.i.i.i83
  %call7.i.i.i85 = call i64 @strtoul(ptr noundef nonnull %add.ptr.i3.i80, ptr noundef nonnull %endptr.i.i.i71, i32 noundef 16) #35
  %.pre.i.i.i86 = load ptr, ptr %endptr.i.i.i71, align 8
  %.pre5.i.i.i87 = load i8, ptr %.pre.i.i.i86, align 1
  br label %if.end9.i.i.i88

if.end9.i.i.i88:                                  ; preds = %if.then6.i.i.i84, %if.end.i.i.i83
  %21 = phi i8 [ %20, %if.end.i.i.i83 ], [ %.pre5.i.i.i87, %if.then6.i.i.i84 ]
  %endptr.promoted.i.i.i89 = phi ptr [ %19, %if.end.i.i.i83 ], [ %.pre.i.i.i86, %if.then6.i.i.i84 ]
  %cmp11.i.i.i90 = icmp eq i8 %21, 0
  br i1 %cmp11.i.i.i90, label %luaO_str2d.exit.thread9.i.i103, label %while.cond.preheader.i.i.i91

luaO_str2d.exit.thread9.i.i103:                   ; preds = %if.end9.i.i.i88
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i71)
  br label %luaL_optinteger.exit.thread119

while.cond.preheader.i.i.i91:                     ; preds = %if.end9.i.i.i88
  %call15.i.i.i92 = tail call ptr @__ctype_b_loc() #39
  %22 = load ptr, ptr %call15.i.i.i92, align 8
  br label %while.cond.i.i.i93

while.cond.i.i.i93:                               ; preds = %while.cond.i.i.i93, %while.cond.preheader.i.i.i91
  %incdec.ptr4.i.i.i94 = phi ptr [ %endptr.promoted.i.i.i89, %while.cond.preheader.i.i.i91 ], [ %incdec.ptr.i.i.i98, %while.cond.i.i.i93 ]
  %23 = load i8, ptr %incdec.ptr4.i.i.i94, align 1
  %idxprom.i.i.i95 = zext i8 %23 to i64
  %arrayidx.i.i.i96 = getelementptr inbounds i16, ptr %22, i64 %idxprom.i.i.i95
  %24 = load i16, ptr %arrayidx.i.i.i96, align 2
  %25 = and i16 %24, 8192
  %tobool.not.i.i.i97 = icmp eq i16 %25, 0
  %incdec.ptr.i.i.i98 = getelementptr inbounds i8, ptr %incdec.ptr4.i.i.i94, i64 1
  br i1 %tobool.not.i.i.i97, label %luaO_str2d.exit.i.i99, label %while.cond.i.i.i93, !llvm.loop !35

luaO_str2d.exit.i.i99:                            ; preds = %while.cond.i.i.i93
  %cmp19.not.i.not.i.i100 = icmp eq i8 %23, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i71)
  br i1 %cmp19.not.i.not.i.i100, label %luaL_optinteger.exit.thread119, label %if.then.i.i

if.then.i.i:                                      ; preds = %land.lhs.true.i.i, %luaO_str2d.exit.i.i99, %luaO_str2d.exit.thread.i.i104
  call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 3, ptr noundef nonnull @.str.24)
  unreachable

luaL_optinteger.exit.thread119:                   ; preds = %land.lhs.true.i.i, %luaO_str2d.exit.i.i99, %luaO_str2d.exit.thread9.i.i103
  %26 = load i64, ptr %l, align 8
  br label %luaL_optinteger.exit.thread

luaL_optinteger.exit:                             ; preds = %cond.false.i
  %27 = load i64, ptr %l, align 8
  %cmp.i18 = icmp slt i64 %call.i.i.fr, 0
  %add.i19 = add nsw i64 %27, 1
  %spec.select124 = select i1 %cmp.i18, i64 %add.i19, i64 0
  br label %luaL_optinteger.exit.thread

luaL_optinteger.exit.thread:                      ; preds = %luaL_checkinteger.exit, %lua_type.exit.i, %luaL_optinteger.exit, %luaL_optinteger.exit.thread119
  %28 = phi i64 [ %26, %luaL_optinteger.exit.thread119 ], [ %27, %luaL_optinteger.exit ], [ %11, %lua_type.exit.i ], [ %11, %luaL_checkinteger.exit ]
  %cond.i15115 = phi i64 [ 0, %luaL_optinteger.exit.thread119 ], [ %call.i.i.fr, %luaL_optinteger.exit ], [ -1, %lua_type.exit.i ], [ -1, %luaL_checkinteger.exit ]
  %29 = phi i64 [ 0, %luaL_optinteger.exit.thread119 ], [ %spec.select124, %luaL_optinteger.exit ], [ %add.i, %lua_type.exit.i ], [ %add.i, %luaL_checkinteger.exit ]
  %pos.addr.0.i21 = add nsw i64 %29, %cond.i15115
  %cond.i22 = call i64 @llvm.smax.i64(i64 %pos.addr.0.i21, i64 0)
  %spec.store.select = call i64 @llvm.smax.i64(i64 %pos.addr.0.i, i64 1)
  %spec.select = call i64 @llvm.smin.i64(i64 %cond.i22, i64 %28)
  %cmp8.not = icmp sgt i64 %spec.store.select, %spec.select
  br i1 %cmp8.not, label %if.else, label %if.then9

if.then9:                                         ; preds = %luaL_optinteger.exit.thread
  %add.ptr = getelementptr inbounds i8, ptr %call.i, i64 %spec.store.select
  %add.ptr10 = getelementptr inbounds i8, ptr %add.ptr, i64 -1
  %reass.sub = sub i64 %spec.select, %spec.store.select
  %add = add i64 %reass.sub, 1
  %l_G.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %30 = load ptr, ptr %l_G.i, align 8
  %totalbytes.i = getelementptr inbounds %struct.global_State, ptr %30, i64 0, i32 14
  %31 = load i64, ptr %totalbytes.i, align 8
  %GCthreshold.i = getelementptr inbounds %struct.global_State, ptr %30, i64 0, i32 13
  %32 = load i64, ptr %GCthreshold.i, align 8
  %cmp.not.i = icmp ult i64 %31, %32
  br i1 %cmp.not.i, label %lua_pushlstring.exit, label %if.then.i23

if.then.i23:                                      ; preds = %if.then9
  %gcstepmul.i.i = getelementptr inbounds %struct.global_State, ptr %30, i64 0, i32 18
  %33 = load i32, ptr %gcstepmul.i.i, align 4
  %mul.i.i = mul i32 %33, 10
  %conv.i.i = zext i32 %mul.i.i to i64
  %cmp.i.i24 = icmp eq i32 %mul.i.i, 0
  %spec.store.select.i.i = select i1 %cmp.i.i24, i64 9223372036854775806, i64 %conv.i.i
  %sub.i.i = sub i64 %31, %32
  %gcdept.i.i = getelementptr inbounds %struct.global_State, ptr %30, i64 0, i32 16
  %34 = load i64, ptr %gcdept.i.i, align 8
  %add.i.i = add i64 %sub.i.i, %34
  store i64 %add.i.i, ptr %gcdept.i.i, align 8
  %gcstate.i.i = getelementptr inbounds %struct.global_State, ptr %30, i64 0, i32 4
  br label %do.body.i.i

do.body.i.i:                                      ; preds = %do.body.i.i, %if.then.i23
  %lim.0.i.i = phi i64 [ %spec.store.select.i.i, %if.then.i23 ], [ %sub2.i.i, %do.body.i.i ]
  %call.i.i25 = call fastcc i64 @singlestep(ptr noundef %L)
  %sub2.i.i = sub nsw i64 %lim.0.i.i, %call.i.i25
  %35 = load i8, ptr %gcstate.i.i, align 1
  %cmp4.i.i = icmp ne i8 %35, 0
  %cmp8.i.i = icmp sgt i64 %sub2.i.i, 0
  %or.cond.i.i = select i1 %cmp4.i.i, i1 %cmp8.i.i, i1 false
  br i1 %or.cond.i.i, label %do.body.i.i, label %do.end.i.i, !llvm.loop !6

do.end.i.i:                                       ; preds = %do.body.i.i
  br i1 %cmp4.i.i, label %if.then14.i.i, label %if.else27.i.i

if.then14.i.i:                                    ; preds = %do.end.i.i
  %36 = load i64, ptr %gcdept.i.i, align 8
  %cmp16.i.i = icmp ult i64 %36, 1024
  br i1 %cmp16.i.i, label %if.then18.i.i, label %if.else.i.i

if.then18.i.i:                                    ; preds = %if.then14.i.i
  %37 = load i64, ptr %totalbytes.i, align 8
  %add20.i.i = add i64 %37, 1024
  br label %luaC_step.exit.i

if.else.i.i:                                      ; preds = %if.then14.i.i
  %sub23.i.i = add i64 %36, -1024
  store i64 %sub23.i.i, ptr %gcdept.i.i, align 8
  %38 = load i64, ptr %totalbytes.i, align 8
  br label %luaC_step.exit.i

if.else27.i.i:                                    ; preds = %do.end.i.i
  %estimate.i.i = getelementptr inbounds %struct.global_State, ptr %30, i64 0, i32 15
  %39 = load i64, ptr %estimate.i.i, align 8
  %div.i.i = udiv i64 %39, 100
  %gcpause.i.i = getelementptr inbounds %struct.global_State, ptr %30, i64 0, i32 17
  %40 = load i32, ptr %gcpause.i.i, align 8
  %conv28.i.i = sext i32 %40 to i64
  %mul29.i.i = mul i64 %div.i.i, %conv28.i.i
  br label %luaC_step.exit.i

luaC_step.exit.i:                                 ; preds = %if.else27.i.i, %if.else.i.i, %if.then18.i.i
  %add20.sink.i.i = phi i64 [ %add20.i.i, %if.then18.i.i ], [ %38, %if.else.i.i ], [ %mul29.i.i, %if.else27.i.i ]
  store i64 %add20.sink.i.i, ptr %GCthreshold.i, align 8
  br label %lua_pushlstring.exit

lua_pushlstring.exit:                             ; preds = %if.then9, %luaC_step.exit.i
  %41 = load ptr, ptr %top.i.i.i, align 8
  %call.i26 = call fastcc ptr @luaS_newlstr(ptr noundef %L, ptr noundef nonnull %add.ptr10, i64 noundef %add)
  store ptr %call.i26, ptr %41, align 8
  br label %if.end11

if.else:                                          ; preds = %luaL_optinteger.exit.thread
  %l_G.i27 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %42 = load ptr, ptr %l_G.i27, align 8
  %totalbytes.i28 = getelementptr inbounds %struct.global_State, ptr %42, i64 0, i32 14
  %43 = load i64, ptr %totalbytes.i28, align 8
  %GCthreshold.i29 = getelementptr inbounds %struct.global_State, ptr %42, i64 0, i32 13
  %44 = load i64, ptr %GCthreshold.i29, align 8
  %cmp.not.i30 = icmp ult i64 %43, %44
  br i1 %cmp.not.i30, label %lua_pushlstring.exit67, label %if.then.i31

if.then.i31:                                      ; preds = %if.else
  %gcstepmul.i.i32 = getelementptr inbounds %struct.global_State, ptr %42, i64 0, i32 18
  %45 = load i32, ptr %gcstepmul.i.i32, align 4
  %mul.i.i33 = mul i32 %45, 10
  %conv.i.i34 = zext i32 %mul.i.i33 to i64
  %cmp.i.i35 = icmp eq i32 %mul.i.i33, 0
  %spec.store.select.i.i36 = select i1 %cmp.i.i35, i64 9223372036854775806, i64 %conv.i.i34
  %sub.i.i37 = sub i64 %43, %44
  %gcdept.i.i38 = getelementptr inbounds %struct.global_State, ptr %42, i64 0, i32 16
  %46 = load i64, ptr %gcdept.i.i38, align 8
  %add.i.i39 = add i64 %sub.i.i37, %46
  store i64 %add.i.i39, ptr %gcdept.i.i38, align 8
  %gcstate.i.i40 = getelementptr inbounds %struct.global_State, ptr %42, i64 0, i32 4
  br label %do.body.i.i41

do.body.i.i41:                                    ; preds = %do.body.i.i41, %if.then.i31
  %lim.0.i.i42 = phi i64 [ %spec.store.select.i.i36, %if.then.i31 ], [ %sub2.i.i44, %do.body.i.i41 ]
  %call.i.i43 = call fastcc i64 @singlestep(ptr noundef %L)
  %sub2.i.i44 = sub nsw i64 %lim.0.i.i42, %call.i.i43
  %47 = load i8, ptr %gcstate.i.i40, align 1
  %cmp4.i.i45 = icmp ne i8 %47, 0
  %cmp8.i.i46 = icmp sgt i64 %sub2.i.i44, 0
  %or.cond.i.i47 = select i1 %cmp4.i.i45, i1 %cmp8.i.i46, i1 false
  br i1 %or.cond.i.i47, label %do.body.i.i41, label %do.end.i.i48, !llvm.loop !6

do.end.i.i48:                                     ; preds = %do.body.i.i41
  br i1 %cmp4.i.i45, label %if.then14.i.i61, label %if.else27.i.i49

if.then14.i.i61:                                  ; preds = %do.end.i.i48
  %48 = load i64, ptr %gcdept.i.i38, align 8
  %cmp16.i.i62 = icmp ult i64 %48, 1024
  br i1 %cmp16.i.i62, label %if.then18.i.i65, label %if.else.i.i63

if.then18.i.i65:                                  ; preds = %if.then14.i.i61
  %49 = load i64, ptr %totalbytes.i28, align 8
  %add20.i.i66 = add i64 %49, 1024
  br label %luaC_step.exit.i55

if.else.i.i63:                                    ; preds = %if.then14.i.i61
  %sub23.i.i64 = add i64 %48, -1024
  store i64 %sub23.i.i64, ptr %gcdept.i.i38, align 8
  %50 = load i64, ptr %totalbytes.i28, align 8
  br label %luaC_step.exit.i55

if.else27.i.i49:                                  ; preds = %do.end.i.i48
  %estimate.i.i50 = getelementptr inbounds %struct.global_State, ptr %42, i64 0, i32 15
  %51 = load i64, ptr %estimate.i.i50, align 8
  %div.i.i51 = udiv i64 %51, 100
  %gcpause.i.i52 = getelementptr inbounds %struct.global_State, ptr %42, i64 0, i32 17
  %52 = load i32, ptr %gcpause.i.i52, align 8
  %conv28.i.i53 = sext i32 %52 to i64
  %mul29.i.i54 = mul i64 %div.i.i51, %conv28.i.i53
  br label %luaC_step.exit.i55

luaC_step.exit.i55:                               ; preds = %if.else27.i.i49, %if.else.i.i63, %if.then18.i.i65
  %add20.sink.i.i56 = phi i64 [ %add20.i.i66, %if.then18.i.i65 ], [ %50, %if.else.i.i63 ], [ %mul29.i.i54, %if.else27.i.i49 ]
  store i64 %add20.sink.i.i56, ptr %GCthreshold.i29, align 8
  br label %lua_pushlstring.exit67

lua_pushlstring.exit67:                           ; preds = %if.else, %luaC_step.exit.i55
  %53 = load ptr, ptr %top.i.i.i, align 8
  %call.i58 = call fastcc ptr @luaS_newlstr(ptr noundef %L, ptr noundef nonnull @.str.7, i64 noundef 0)
  store ptr %call.i58, ptr %53, align 8
  br label %if.end11

if.end11:                                         ; preds = %lua_pushlstring.exit67, %lua_pushlstring.exit
  %.sink = phi ptr [ %53, %lua_pushlstring.exit67 ], [ %41, %lua_pushlstring.exit ]
  %tt.i59 = getelementptr inbounds %struct.lua_TValue, ptr %.sink, i64 0, i32 1
  store i32 4, ptr %tt.i59, align 8
  %.pn = load ptr, ptr %top.i.i.i, align 8
  %storemerge = getelementptr inbounds %struct.lua_TValue, ptr %.pn, i64 1
  store ptr %storemerge, ptr %top.i.i.i, align 8
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @str_upper(ptr noundef %L) #0 {
entry:
  %l = alloca i64, align 8
  %b = alloca %struct.luaL_Buffer, align 8
  %call.i = call fastcc ptr @lua_tolstring(ptr noundef %L, i32 noundef 1, ptr noundef nonnull %l)
  %tobool.not.i = icmp eq ptr %call.i, null
  br i1 %tobool.not.i, label %if.then.i, label %luaL_checklstring.exit

if.then.i:                                        ; preds = %entry
  call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 1, ptr noundef nonnull @.str.25)
  unreachable

luaL_checklstring.exit:                           ; preds = %entry
  %L1.i = getelementptr inbounds %struct.luaL_Buffer, ptr %b, i64 0, i32 2
  store ptr %L, ptr %L1.i, align 8
  %buffer.i = getelementptr inbounds %struct.luaL_Buffer, ptr %b, i64 0, i32 3
  store ptr %buffer.i, ptr %b, align 8
  %lvl.i = getelementptr inbounds %struct.luaL_Buffer, ptr %b, i64 0, i32 1
  store i32 0, ptr %lvl.i, align 8
  %0 = load i64, ptr %l, align 8
  %cmp10.not = icmp eq i64 %0, 0
  br i1 %cmp10.not, label %for.end, label %for.body.lr.ph

for.body.lr.ph:                                   ; preds = %luaL_checklstring.exit
  %add.ptr = getelementptr inbounds %struct.luaL_Buffer, ptr %b, i64 1
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %lor.end
  %i.011 = phi i64 [ 0, %for.body.lr.ph ], [ %inc, %lor.end ]
  %1 = load ptr, ptr %b, align 8
  %cmp1 = icmp ult ptr %1, %add.ptr
  br i1 %cmp1, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %for.body
  %call.i4 = call fastcc i32 @emptybuffer(ptr noundef nonnull %b), !range !23
  %tobool.not.i5 = icmp eq i32 %call.i4, 0
  br i1 %tobool.not.i5, label %lor.end, label %if.then.i6

if.then.i6:                                       ; preds = %lor.rhs
  call fastcc void @adjuststack(ptr noundef nonnull %b)
  br label %lor.end

lor.end:                                          ; preds = %if.then.i6, %lor.rhs, %for.body
  %arrayidx = getelementptr inbounds i8, ptr %call.i, i64 %i.011
  %2 = load i8, ptr %arrayidx, align 1
  %conv = zext i8 %2 to i32
  %call3 = call i32 @toupper(i32 noundef %conv) #34
  %conv4 = trunc i32 %call3 to i8
  %3 = load ptr, ptr %b, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %3, i64 1
  store ptr %incdec.ptr, ptr %b, align 8
  store i8 %conv4, ptr %3, align 1
  %inc = add nuw i64 %i.011, 1
  %4 = load i64, ptr %l, align 8
  %cmp = icmp ult i64 %inc, %4
  br i1 %cmp, label %for.body, label %for.end, !llvm.loop !150

for.end:                                          ; preds = %lor.end, %luaL_checklstring.exit
  %call.i8 = call fastcc i32 @emptybuffer(ptr noundef nonnull %b), !range !23
  %5 = load ptr, ptr %L1.i, align 8
  %6 = load i32, ptr %lvl.i, align 8
  call fastcc void @lua_concat(ptr noundef %5, i32 noundef %6)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @str_find_aux(ptr noundef %L, i32 noundef %find) unnamed_addr #0 {
entry:
  %endptr.i.i.i = alloca ptr, align 8
  %l1 = alloca i64, align 8
  %l2 = alloca i64, align 8
  %ms = alloca %struct.MatchState, align 8
  %call.i = call fastcc ptr @lua_tolstring(ptr noundef %L, i32 noundef 1, ptr noundef nonnull %l1)
  %tobool.not.i = icmp eq ptr %call.i, null
  br i1 %tobool.not.i, label %if.then.i, label %luaL_checklstring.exit

if.then.i:                                        ; preds = %entry
  call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 1, ptr noundef nonnull @.str.25)
  unreachable

luaL_checklstring.exit:                           ; preds = %entry
  %call.i33 = call fastcc ptr @lua_tolstring(ptr noundef %L, i32 noundef 2, ptr noundef nonnull %l2)
  %tobool.not.i34 = icmp eq ptr %call.i33, null
  br i1 %tobool.not.i34, label %if.then.i35, label %luaL_checklstring.exit37

if.then.i35:                                      ; preds = %luaL_checklstring.exit
  call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 2, ptr noundef nonnull @.str.25)
  unreachable

luaL_checklstring.exit37:                         ; preds = %luaL_checklstring.exit
  %base.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i.i, align 8
  %add.ptr.i.i.i = getelementptr %struct.lua_TValue, ptr %0, i64 2
  %top.i.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i.i = icmp uge ptr %add.ptr.i.i.i, %1
  %cmp.i.i = icmp eq ptr %add.ptr.i.i.i, @luaO_nilobject_
  %or.cond = or i1 %cmp1.not.i.i.i, %cmp.i.i
  br i1 %or.cond, label %luaL_optinteger.exit.thread, label %lua_type.exit.i

lua_type.exit.i:                                  ; preds = %luaL_checklstring.exit37
  %tt.i.i = getelementptr %struct.lua_TValue, ptr %0, i64 2, i32 1
  %2 = load i32, ptr %tt.i.i, align 8
  %cmp.i = icmp slt i32 %2, 1
  br i1 %cmp.i, label %luaL_optinteger.exit.thread, label %cond.false.i

cond.false.i:                                     ; preds = %lua_type.exit.i
  %call.i.i = call fastcc i64 @lua_tointeger(ptr noundef nonnull %L, i32 noundef 3)
  %call.i.i.fr = freeze i64 %call.i.i
  %cmp.i3.i = icmp eq i64 %call.i.i.fr, 0
  br i1 %cmp.i3.i, label %land.lhs.true.i.i, label %luaL_optinteger.exit

land.lhs.true.i.i:                                ; preds = %cond.false.i
  %3 = load ptr, ptr %base.i.i.i, align 8
  %add.ptr.i.i65 = getelementptr %struct.lua_TValue, ptr %3, i64 2
  %4 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i67 = icmp ult ptr %add.ptr.i.i65, %4
  %add.ptr.luaO_nilobject_.i.i68 = select i1 %cmp1.not.i.i67, ptr %add.ptr.i.i65, ptr @luaO_nilobject_
  %tt.i69 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i68, i64 0, i32 1
  %5 = load i32, ptr %tt.i69, align 8
  switch i32 %5, label %if.then.i.i [
    i32 3, label %luaL_optinteger.exit.thread
    i32 4, label %land.lhs.true.i.i70
  ]

land.lhs.true.i.i70:                              ; preds = %land.lhs.true.i.i
  %6 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i68, align 8
  %add.ptr.i3.i = getelementptr inbounds %union.TString, ptr %6, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i.i)
  %call.i.i.i = call double @strtod(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i) #35
  %7 = load ptr, ptr %endptr.i.i.i, align 8
  %cmp.i.i.i = icmp eq ptr %7, %add.ptr.i3.i
  br i1 %cmp.i.i.i, label %luaO_str2d.exit.thread.i.i, label %if.end.i.i.i

luaO_str2d.exit.thread.i.i:                       ; preds = %land.lhs.true.i.i70
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %if.then.i.i

if.end.i.i.i:                                     ; preds = %land.lhs.true.i.i70
  %8 = load i8, ptr %7, align 1
  switch i8 %8, label %if.end9.i.i.i [
    i8 120, label %if.then6.i.i.i
    i8 88, label %if.then6.i.i.i
  ]

if.then6.i.i.i:                                   ; preds = %if.end.i.i.i, %if.end.i.i.i
  %call7.i.i.i = call i64 @strtoul(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i, i32 noundef 16) #35
  %.pre.i.i.i = load ptr, ptr %endptr.i.i.i, align 8
  %.pre5.i.i.i = load i8, ptr %.pre.i.i.i, align 1
  br label %if.end9.i.i.i

if.end9.i.i.i:                                    ; preds = %if.then6.i.i.i, %if.end.i.i.i
  %9 = phi i8 [ %8, %if.end.i.i.i ], [ %.pre5.i.i.i, %if.then6.i.i.i ]
  %endptr.promoted.i.i.i = phi ptr [ %7, %if.end.i.i.i ], [ %.pre.i.i.i, %if.then6.i.i.i ]
  %cmp11.i.i.i = icmp eq i8 %9, 0
  br i1 %cmp11.i.i.i, label %luaO_str2d.exit.thread9.i.i, label %while.cond.preheader.i.i.i

luaO_str2d.exit.thread9.i.i:                      ; preds = %if.end9.i.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %luaL_optinteger.exit.thread

while.cond.preheader.i.i.i:                       ; preds = %if.end9.i.i.i
  %call15.i.i.i = tail call ptr @__ctype_b_loc() #39
  %10 = load ptr, ptr %call15.i.i.i, align 8
  br label %while.cond.i.i.i

while.cond.i.i.i:                                 ; preds = %while.cond.i.i.i, %while.cond.preheader.i.i.i
  %incdec.ptr4.i.i.i = phi ptr [ %endptr.promoted.i.i.i, %while.cond.preheader.i.i.i ], [ %incdec.ptr.i.i.i, %while.cond.i.i.i ]
  %11 = load i8, ptr %incdec.ptr4.i.i.i, align 1
  %idxprom.i.i.i = zext i8 %11 to i64
  %arrayidx.i.i.i = getelementptr inbounds i16, ptr %10, i64 %idxprom.i.i.i
  %12 = load i16, ptr %arrayidx.i.i.i, align 2
  %13 = and i16 %12, 8192
  %tobool.not.i.i.i = icmp eq i16 %13, 0
  %incdec.ptr.i.i.i = getelementptr inbounds i8, ptr %incdec.ptr4.i.i.i, i64 1
  br i1 %tobool.not.i.i.i, label %luaO_str2d.exit.i.i, label %while.cond.i.i.i, !llvm.loop !35

luaO_str2d.exit.i.i:                              ; preds = %while.cond.i.i.i
  %cmp19.not.i.not.i.i = icmp eq i8 %11, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br i1 %cmp19.not.i.not.i.i, label %luaL_optinteger.exit.thread, label %if.then.i.i

if.then.i.i:                                      ; preds = %land.lhs.true.i.i, %luaO_str2d.exit.i.i, %luaO_str2d.exit.thread.i.i
  call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 3, ptr noundef nonnull @.str.24)
  unreachable

luaL_optinteger.exit.thread:                      ; preds = %lua_type.exit.i, %luaL_checklstring.exit37, %land.lhs.true.i.i, %luaO_str2d.exit.i.i, %luaO_str2d.exit.thread9.i.i
  %cond.i.ph = phi i64 [ 0, %land.lhs.true.i.i ], [ 1, %luaL_checklstring.exit37 ], [ 1, %lua_type.exit.i ], [ 0, %luaO_str2d.exit.i.i ], [ 0, %luaO_str2d.exit.thread9.i.i ]
  %14 = load i64, ptr %l1, align 8
  br label %16

luaL_optinteger.exit:                             ; preds = %cond.false.i
  %15 = load i64, ptr %l1, align 8
  %cmp.i39 = icmp slt i64 %call.i.i.fr, 0
  %add.i = add nsw i64 %15, 1
  %spec.select89 = select i1 %cmp.i39, i64 %add.i, i64 0
  br label %16

16:                                               ; preds = %luaL_optinteger.exit, %luaL_optinteger.exit.thread
  %17 = phi i64 [ %14, %luaL_optinteger.exit.thread ], [ %15, %luaL_optinteger.exit ]
  %cond.i77 = phi i64 [ %cond.i.ph, %luaL_optinteger.exit.thread ], [ %call.i.i.fr, %luaL_optinteger.exit ]
  %18 = phi i64 [ 0, %luaL_optinteger.exit.thread ], [ %spec.select89, %luaL_optinteger.exit ]
  %pos.addr.0.i = add nsw i64 %18, %cond.i77
  %cond.i40 = call i64 @llvm.smax.i64(i64 %pos.addr.0.i, i64 0)
  %sub = add nsw i64 %cond.i40, -1
  %spec.select = call i64 @llvm.umin.i64(i64 %sub, i64 %17)
  %cmp.inv = icmp sgt i64 %pos.addr.0.i, 0
  %init.0 = select i1 %cmp.inv, i64 %spec.select, i64 0
  %tobool.not = icmp eq i32 %find, 0
  br i1 %tobool.not, label %if.else21, label %land.lhs.true

land.lhs.true:                                    ; preds = %16
  %19 = load ptr, ptr %base.i.i.i, align 8
  %add.ptr.i.i = getelementptr %struct.lua_TValue, ptr %19, i64 3
  %20 = load ptr, ptr %top.i.i.i, align 8
  %cmp1.not.i.i = icmp ult ptr %add.ptr.i.i, %20
  %add.ptr.luaO_nilobject_.i.i = select i1 %cmp1.not.i.i, ptr %add.ptr.i.i, ptr @luaO_nilobject_
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i, i64 0, i32 1
  %21 = load i32, ptr %tt.i, align 8
  switch i32 %21, label %if.then11 [
    i32 0, label %lor.lhs.false
    i32 1, label %lua_toboolean.exit
  ]

lua_toboolean.exit:                               ; preds = %land.lhs.true
  %22 = load i32, ptr %add.ptr.luaO_nilobject_.i.i, align 8
  %cmp3.i.not = icmp eq i32 %22, 0
  br i1 %cmp3.i.not, label %lor.lhs.false, label %if.then11

lor.lhs.false:                                    ; preds = %land.lhs.true, %lua_toboolean.exit
  %call9 = call ptr @strpbrk(ptr noundef nonnull %call.i33, ptr noundef nonnull @.str.237) #34
  %cmp10 = icmp eq ptr %call9, null
  br i1 %cmp10, label %if.then11, label %if.else21

if.then11:                                        ; preds = %land.lhs.true, %lor.lhs.false, %lua_toboolean.exit
  %add.ptr = getelementptr inbounds i8, ptr %call.i, i64 %init.0
  %sub12 = sub i64 %17, %init.0
  %23 = load i64, ptr %l2, align 8
  %cmp.i42 = icmp eq i64 %23, 0
  br i1 %cmp.i42, label %if.then15, label %if.else.i

if.else.i:                                        ; preds = %if.then11
  %cmp1.i = icmp ugt i64 %23, %sub12
  br i1 %cmp1.i, label %if.end50, label %if.else3.i

if.else3.i:                                       ; preds = %if.else.i
  %dec.i = add i64 %23, -1
  %sub.i = sub i64 %sub12, %dec.i
  %cmp4.not16.i = icmp eq i64 %sub.i, 0
  br i1 %cmp4.not16.i, label %if.end50, label %land.rhs.lr.ph.i

land.rhs.lr.ph.i:                                 ; preds = %if.else3.i
  %24 = load i8, ptr %call.i33, align 1
  %conv.i = sext i8 %24 to i32
  %add.ptr.i = getelementptr inbounds i8, ptr %call.i33, i64 1
  br label %land.rhs.i43

land.rhs.i43:                                     ; preds = %if.else12.i, %land.rhs.lr.ph.i
  %l1.addr.018.i = phi i64 [ %sub.i, %land.rhs.lr.ph.i ], [ %sub13.i, %if.else12.i ]
  %s1.addr.017.i = phi ptr [ %add.ptr, %land.rhs.lr.ph.i ], [ %incdec.ptr.i, %if.else12.i ]
  %call.i44 = call ptr @memchr(ptr noundef %s1.addr.017.i, i32 noundef %conv.i, i64 noundef %l1.addr.018.i) #34
  %cmp5.not.i = icmp eq ptr %call.i44, null
  br i1 %cmp5.not.i, label %if.end50, label %while.body.i

while.body.i:                                     ; preds = %land.rhs.i43
  %incdec.ptr.i = getelementptr inbounds i8, ptr %call.i44, i64 1
  %bcmp.i = call i32 @bcmp(ptr nonnull %incdec.ptr.i, ptr nonnull %add.ptr.i, i64 %dec.i)
  %cmp8.i = icmp eq i32 %bcmp.i, 0
  br i1 %cmp8.i, label %if.then15, label %if.else12.i

if.else12.i:                                      ; preds = %while.body.i
  %sub.ptr.lhs.cast.i = ptrtoint ptr %incdec.ptr.i to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %s1.addr.017.i to i64
  %sub.ptr.sub.neg.i = add i64 %l1.addr.018.i, %sub.ptr.rhs.cast.i
  %sub13.i = sub i64 %sub.ptr.sub.neg.i, %sub.ptr.lhs.cast.i
  %cmp4.not.i = icmp eq i64 %sub13.i, 0
  br i1 %cmp4.not.i, label %if.end50, label %land.rhs.i43, !llvm.loop !151

if.then15:                                        ; preds = %while.body.i, %if.then11
  %retval.0.i88 = phi ptr [ %add.ptr, %if.then11 ], [ %call.i44, %while.body.i ]
  %sub.ptr.lhs.cast = ptrtoint ptr %retval.0.i88 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %call.i to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %add = add nsw i64 %sub.ptr.sub, 1
  %conv.i45 = sitofp i64 %add to double
  store double %conv.i45, ptr %20, align 8
  %tt.i46 = getelementptr inbounds %struct.lua_TValue, ptr %20, i64 0, i32 1
  store i32 3, ptr %tt.i46, align 8
  %25 = load ptr, ptr %top.i.i.i, align 8
  %incdec.ptr.i47 = getelementptr inbounds %struct.lua_TValue, ptr %25, i64 1
  store ptr %incdec.ptr.i47, ptr %top.i.i.i, align 8
  %26 = load i64, ptr %l2, align 8
  %add19 = add i64 %26, %sub.ptr.sub
  %conv.i49 = sitofp i64 %add19 to double
  store double %conv.i49, ptr %incdec.ptr.i47, align 8
  %tt.i50 = getelementptr inbounds %struct.lua_TValue, ptr %25, i64 1, i32 1
  store i32 3, ptr %tt.i50, align 8
  %27 = load ptr, ptr %top.i.i.i, align 8
  %incdec.ptr.i51 = getelementptr inbounds %struct.lua_TValue, ptr %27, i64 1
  store ptr %incdec.ptr.i51, ptr %top.i.i.i, align 8
  br label %return

if.else21:                                        ; preds = %lor.lhs.false, %16
  %28 = load i8, ptr %call.i33, align 1
  %.fr = freeze i8 %28
  %cmp22.not = icmp eq i8 %.fr, 94
  %spec.select32.idx = zext i1 %cmp22.not to i64
  %spec.select32 = getelementptr inbounds i8, ptr %call.i33, i64 %spec.select32.idx
  %add.ptr24 = getelementptr inbounds i8, ptr %call.i, i64 %init.0
  %L25 = getelementptr inbounds %struct.MatchState, ptr %ms, i64 0, i32 2
  store ptr %L, ptr %L25, align 8
  store ptr %call.i, ptr %ms, align 8
  %add.ptr26 = getelementptr inbounds i8, ptr %call.i, i64 %17
  %src_end = getelementptr inbounds %struct.MatchState, ptr %ms, i64 0, i32 1
  store ptr %add.ptr26, ptr %src_end, align 8
  %level = getelementptr inbounds %struct.MatchState, ptr %ms, i64 0, i32 3
  br i1 %cmp22.not, label %do.body.us, label %do.body

do.body.us:                                       ; preds = %if.else21
  store i32 0, ptr %level, align 8
  %call27.us = call fastcc ptr @match(ptr noundef nonnull %ms, ptr noundef nonnull %add.ptr24, ptr noundef nonnull %spec.select32)
  %cmp28.not.us = icmp eq ptr %call27.us, null
  br i1 %cmp28.not.us, label %if.end50, label %if.then30

do.body:                                          ; preds = %if.else21, %do.cond
  %s1.0 = phi ptr [ %incdec.ptr45, %do.cond ], [ %add.ptr24, %if.else21 ]
  store i32 0, ptr %level, align 8
  %call27 = call fastcc ptr @match(ptr noundef nonnull %ms, ptr noundef %s1.0, ptr noundef nonnull %spec.select32)
  %cmp28.not = icmp eq ptr %call27, null
  br i1 %cmp28.not, label %do.cond, label %if.then30

if.then30:                                        ; preds = %do.body, %do.body.us
  %.us-phi = phi ptr [ %add.ptr24, %do.body.us ], [ %s1.0, %do.body ]
  %.us-phi94 = phi ptr [ %call27.us, %do.body.us ], [ %call27, %do.body ]
  br i1 %tobool.not, label %if.else42, label %if.then32

if.then32:                                        ; preds = %if.then30
  %sub.ptr.lhs.cast33 = ptrtoint ptr %.us-phi to i64
  %sub.ptr.rhs.cast34 = ptrtoint ptr %call.i to i64
  %reass.sub = sub i64 %sub.ptr.lhs.cast33, %sub.ptr.rhs.cast34
  %add36 = add i64 %reass.sub, 1
  %29 = load ptr, ptr %top.i.i.i, align 8
  %conv.i53 = sitofp i64 %add36 to double
  store double %conv.i53, ptr %29, align 8
  %tt.i54 = getelementptr inbounds %struct.lua_TValue, ptr %29, i64 0, i32 1
  store i32 3, ptr %tt.i54, align 8
  %30 = load ptr, ptr %top.i.i.i, align 8
  %incdec.ptr.i55 = getelementptr inbounds %struct.lua_TValue, ptr %30, i64 1
  store ptr %incdec.ptr.i55, ptr %top.i.i.i, align 8
  %sub.ptr.lhs.cast37 = ptrtoint ptr %.us-phi94 to i64
  %sub.ptr.sub39 = sub i64 %sub.ptr.lhs.cast37, %sub.ptr.rhs.cast34
  %conv.i57 = sitofp i64 %sub.ptr.sub39 to double
  store double %conv.i57, ptr %incdec.ptr.i55, align 8
  %tt.i58 = getelementptr inbounds %struct.lua_TValue, ptr %30, i64 1, i32 1
  store i32 3, ptr %tt.i58, align 8
  %31 = load ptr, ptr %top.i.i.i, align 8
  %incdec.ptr.i59 = getelementptr inbounds %struct.lua_TValue, ptr %31, i64 1
  store ptr %incdec.ptr.i59, ptr %top.i.i.i, align 8
  %call40 = call fastcc i32 @push_captures(ptr noundef nonnull %ms, ptr noundef null, ptr noundef null)
  %add41 = add nsw i32 %call40, 2
  br label %return

if.else42:                                        ; preds = %if.then30
  %call43 = call fastcc i32 @push_captures(ptr noundef nonnull %ms, ptr noundef %.us-phi, ptr noundef nonnull %.us-phi94)
  br label %return

do.cond:                                          ; preds = %do.body
  %incdec.ptr45 = getelementptr inbounds i8, ptr %s1.0, i64 1
  %32 = load ptr, ptr %src_end, align 8
  %cmp47 = icmp ult ptr %s1.0, %32
  br i1 %cmp47, label %do.body, label %if.end50, !llvm.loop !152

if.end50:                                         ; preds = %land.rhs.i43, %if.else12.i, %do.cond, %do.body.us, %if.else3.i, %if.else.i
  %33 = load ptr, ptr %top.i.i.i, align 8
  %tt.i61 = getelementptr inbounds %struct.lua_TValue, ptr %33, i64 0, i32 1
  store i32 0, ptr %tt.i61, align 8
  %34 = load ptr, ptr %top.i.i.i, align 8
  %incdec.ptr.i62 = getelementptr inbounds %struct.lua_TValue, ptr %34, i64 1
  store ptr %incdec.ptr.i62, ptr %top.i.i.i, align 8
  br label %return

return:                                           ; preds = %if.end50, %if.else42, %if.then32, %if.then15
  %retval.0 = phi i32 [ 2, %if.then15 ], [ 1, %if.end50 ], [ %add41, %if.then32 ], [ %call43, %if.else42 ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree nounwind willreturn memory(argmem: read)
declare ptr @strpbrk(ptr noundef, ptr nocapture noundef) local_unnamed_addr #11

; Function Attrs: nounwind uwtable
define internal fastcc ptr @match(ptr noundef %ms, ptr noundef %s, ptr noundef %p) unnamed_addr #0 {
entry:
  %src_end74 = getelementptr inbounds %struct.MatchState, ptr %ms, i64 0, i32 1
  %level.i.i = getelementptr inbounds %struct.MatchState, ptr %ms, i64 0, i32 3
  br label %init.outer

init.outer:                                       ; preds = %init.outer.backedge, %entry
  %p.addr.0.ph = phi ptr [ %p, %entry ], [ %p.addr.0.ph.be, %init.outer.backedge ]
  %s.addr.0.ph = phi ptr [ %s, %entry ], [ %s.addr.0.ph.be, %init.outer.backedge ]
  %add.ptr30 = getelementptr inbounds i8, ptr %s.addr.0.ph, i64 -1
  %add.ptr83 = getelementptr inbounds i8, ptr %s.addr.0.ph, i64 1
  br label %init

init:                                             ; preds = %init.backedge, %init.outer
  %p.addr.0 = phi ptr [ %p.addr.0.ph, %init.outer ], [ %p.addr.0.be, %init.backedge ]
  %0 = load i8, ptr %p.addr.0, align 1
  %conv = sext i8 %0 to i32
  switch i32 %conv, label %dflt [
    i32 40, label %sw.bb
    i32 41, label %sw.bb6
    i32 37, label %sw.bb9
    i32 0, label %return
    i32 36, label %sw.bb58
  ]

sw.bb:                                            ; preds = %init
  %add.ptr = getelementptr inbounds i8, ptr %p.addr.0, i64 1
  %1 = load i8, ptr %add.ptr, align 1
  %cmp = icmp eq i8 %1, 41
  %2 = load i32, ptr %level.i.i, align 8
  %cmp.i = icmp sgt i32 %2, 31
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb
  br i1 %cmp.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then
  %L.i = getelementptr inbounds %struct.MatchState, ptr %ms, i64 0, i32 2
  %3 = load ptr, ptr %L.i, align 8
  tail call void (ptr, ptr, ...) @luaL_error(ptr noundef %3, ptr noundef nonnull @.str.239)
  unreachable

if.end.i:                                         ; preds = %if.then
  %add.ptr3 = getelementptr inbounds i8, ptr %p.addr.0, i64 2
  %idxprom.i = sext i32 %2 to i64
  %arrayidx.i = getelementptr inbounds %struct.MatchState, ptr %ms, i64 0, i32 4, i64 %idxprom.i
  store ptr %s.addr.0.ph, ptr %arrayidx.i, align 8
  %len.i = getelementptr inbounds %struct.MatchState, ptr %ms, i64 0, i32 4, i64 %idxprom.i, i32 1
  store i64 -2, ptr %len.i, align 8
  %add.i = add nsw i32 %2, 1
  store i32 %add.i, ptr %level.i.i, align 8
  %call6.i = tail call fastcc ptr @match(ptr noundef nonnull %ms, ptr noundef %s.addr.0.ph, ptr noundef nonnull %add.ptr3)
  %cmp7.i = icmp eq ptr %call6.i, null
  br i1 %cmp7.i, label %if.then9.i, label %return

if.then9.i:                                       ; preds = %if.end.i
  %4 = load i32, ptr %level.i.i, align 8
  %dec.i = add nsw i32 %4, -1
  store i32 %dec.i, ptr %level.i.i, align 8
  br label %return

if.else:                                          ; preds = %sw.bb
  br i1 %cmp.i, label %if.then.i77, label %if.end.i68

if.then.i77:                                      ; preds = %if.else
  %L.i78 = getelementptr inbounds %struct.MatchState, ptr %ms, i64 0, i32 2
  %5 = load ptr, ptr %L.i78, align 8
  tail call void (ptr, ptr, ...) @luaL_error(ptr noundef %5, ptr noundef nonnull @.str.239)
  unreachable

if.end.i68:                                       ; preds = %if.else
  %idxprom.i69 = sext i32 %2 to i64
  %arrayidx.i70 = getelementptr inbounds %struct.MatchState, ptr %ms, i64 0, i32 4, i64 %idxprom.i69
  store ptr %s.addr.0.ph, ptr %arrayidx.i70, align 8
  %len.i71 = getelementptr inbounds %struct.MatchState, ptr %ms, i64 0, i32 4, i64 %idxprom.i69, i32 1
  store i64 -1, ptr %len.i71, align 8
  %add.i72 = add nsw i32 %2, 1
  store i32 %add.i72, ptr %level.i.i, align 8
  %call6.i73 = tail call fastcc ptr @match(ptr noundef nonnull %ms, ptr noundef %s.addr.0.ph, ptr noundef nonnull %add.ptr)
  %cmp7.i74 = icmp eq ptr %call6.i73, null
  br i1 %cmp7.i74, label %if.then9.i75, label %return

if.then9.i75:                                     ; preds = %if.end.i68
  %6 = load i32, ptr %level.i.i, align 8
  %dec.i76 = add nsw i32 %6, -1
  store i32 %dec.i76, ptr %level.i.i, align 8
  br label %return

sw.bb6:                                           ; preds = %init
  %add.ptr7 = getelementptr inbounds i8, ptr %p.addr.0, i64 1
  %7 = load i32, ptr %level.i.i, align 8
  %8 = zext i32 %7 to i64
  br label %for.cond.i251

for.cond.i251:                                    ; preds = %for.body.i, %sw.bb6
  %indvars.iv.i = phi i64 [ %10, %for.body.i ], [ %8, %sw.bb6 ]
  %9 = trunc i64 %indvars.iv.i to i32
  %cmp.i252 = icmp sgt i32 %9, 0
  br i1 %cmp.i252, label %for.body.i, label %for.end.i

for.body.i:                                       ; preds = %for.cond.i251
  %10 = add nsw i64 %indvars.iv.i, -1
  %len.i255 = getelementptr inbounds %struct.MatchState, ptr %ms, i64 0, i32 4, i64 %10, i32 1
  %11 = load i64, ptr %len.i255, align 8
  %cmp2.i = icmp eq i64 %11, -1
  br i1 %cmp2.i, label %capture_to_close.exit, label %for.cond.i251, !llvm.loop !153

for.end.i:                                        ; preds = %for.cond.i251
  %L.i253 = getelementptr inbounds %struct.MatchState, ptr %ms, i64 0, i32 2
  %12 = load ptr, ptr %L.i253, align 8
  tail call void (ptr, ptr, ...) @luaL_error(ptr noundef %12, ptr noundef nonnull @.str.240)
  unreachable

capture_to_close.exit:                            ; preds = %for.body.i
  %idxprom.i82 = and i64 %10, 4294967295
  %arrayidx.i83 = getelementptr inbounds %struct.MatchState, ptr %ms, i64 0, i32 4, i64 %idxprom.i82
  %13 = load ptr, ptr %arrayidx.i83, align 8
  %sub.ptr.lhs.cast.i = ptrtoint ptr %s.addr.0.ph to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %13 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %len.i84 = getelementptr inbounds %struct.MatchState, ptr %ms, i64 0, i32 4, i64 %idxprom.i82, i32 1
  store i64 %sub.ptr.sub.i, ptr %len.i84, align 8
  %call4.i = tail call fastcc ptr @match(ptr noundef nonnull %ms, ptr noundef %s.addr.0.ph, ptr noundef nonnull %add.ptr7)
  %cmp.i85 = icmp eq ptr %call4.i, null
  br i1 %cmp.i85, label %if.then.i87, label %return

if.then.i87:                                      ; preds = %capture_to_close.exit
  store i64 -1, ptr %len.i84, align 8
  br label %return

sw.bb9:                                           ; preds = %init
  %add.ptr10 = getelementptr inbounds i8, ptr %p.addr.0, i64 1
  %14 = load i8, ptr %add.ptr10, align 1
  %conv11 = sext i8 %14 to i32
  switch i32 %conv11, label %sw.default [
    i32 98, label %sw.bb12
    i32 102, label %sw.bb19
  ]

sw.bb12:                                          ; preds = %sw.bb9
  %add.ptr13 = getelementptr inbounds i8, ptr %p.addr.0, i64 2
  %s18.i = ptrtoint ptr %s.addr.0.ph to i64
  %15 = load i8, ptr %add.ptr13, align 1
  %cmp.i88 = icmp eq i8 %15, 0
  br i1 %cmp.i88, label %if.then.i91, label %lor.lhs.false.i

lor.lhs.false.i:                                  ; preds = %sw.bb12
  %add.ptr.i = getelementptr inbounds i8, ptr %p.addr.0, i64 3
  %16 = load i8, ptr %add.ptr.i, align 1
  %cmp3.i = icmp eq i8 %16, 0
  br i1 %cmp3.i, label %if.then.i91, label %if.end.i89

if.then.i91:                                      ; preds = %lor.lhs.false.i, %sw.bb12
  %L.i92 = getelementptr inbounds %struct.MatchState, ptr %ms, i64 0, i32 2
  %17 = load ptr, ptr %L.i92, align 8
  tail call void (ptr, ptr, ...) @luaL_error(ptr noundef %17, ptr noundef nonnull @.str.241)
  unreachable

if.end.i89:                                       ; preds = %lor.lhs.false.i
  %18 = load i8, ptr %s.addr.0.ph, align 1
  %cmp7.not.i = icmp eq i8 %18, %15
  br i1 %cmp7.not.i, label %if.else.i, label %return

if.else.i:                                        ; preds = %if.end.i89
  %19 = load ptr, ptr %src_end74, align 8
  %cmp1313.i = icmp ult ptr %add.ptr83, %19
  br i1 %cmp1313.i, label %while.body.preheader.i, label %return

while.body.preheader.i:                           ; preds = %if.else.i
  %20 = ptrtoint ptr %19 to i64
  %21 = sub i64 %20, %s18.i
  %scevgep.i = getelementptr i8, ptr %s.addr.0.ph, i64 %21
  br label %while.body.i

while.body.i:                                     ; preds = %if.end30.i, %while.body.preheader.i
  %incdec.ptr16.i = phi ptr [ %incdec.ptr.i, %if.end30.i ], [ %add.ptr83, %while.body.preheader.i ]
  %cont.015.i = phi i32 [ %cont.1.i, %if.end30.i ], [ 1, %while.body.preheader.i ]
  %s.addr.014.i = phi ptr [ %incdec.ptr16.i, %if.end30.i ], [ %s.addr.0.ph, %while.body.preheader.i ]
  %22 = load i8, ptr %incdec.ptr16.i, align 1
  %cmp16.i = icmp eq i8 %22, %16
  br i1 %cmp16.i, label %if.then18.i, label %if.else24.i

if.then18.i:                                      ; preds = %while.body.i
  %dec.i90 = add nsw i32 %cont.015.i, -1
  %cmp19.i = icmp eq i32 %dec.i90, 0
  br i1 %cmp19.i, label %if.end, label %if.end30.i

if.else24.i:                                      ; preds = %while.body.i
  %cmp26.i = icmp eq i8 %22, %15
  %inc.i = zext i1 %cmp26.i to i32
  %spec.select.i = add nsw i32 %cont.015.i, %inc.i
  br label %if.end30.i

if.end30.i:                                       ; preds = %if.else24.i, %if.then18.i
  %cont.1.i = phi i32 [ %dec.i90, %if.then18.i ], [ %spec.select.i, %if.else24.i ]
  %incdec.ptr.i = getelementptr inbounds i8, ptr %incdec.ptr16.i, i64 1
  %exitcond.not.i = icmp eq ptr %incdec.ptr.i, %scevgep.i
  br i1 %exitcond.not.i, label %return, label %while.body.i, !llvm.loop !154

if.end:                                           ; preds = %if.then18.i
  %add.ptr22.i = getelementptr inbounds i8, ptr %s.addr.014.i, i64 2
  %add.ptr18 = getelementptr inbounds i8, ptr %p.addr.0, i64 4
  br label %init.outer.backedge

sw.bb19:                                          ; preds = %sw.bb9
  %add.ptr20 = getelementptr inbounds i8, ptr %p.addr.0, i64 2
  %23 = load i8, ptr %add.ptr20, align 1
  %cmp22.not = icmp eq i8 %23, 91
  br i1 %cmp22.not, label %sw.bb3.i, label %if.then24

if.then24:                                        ; preds = %sw.bb19
  %L = getelementptr inbounds %struct.MatchState, ptr %ms, i64 0, i32 2
  %24 = load ptr, ptr %L, align 8
  tail call void (ptr, ptr, ...) @luaL_error(ptr noundef %24, ptr noundef nonnull @.str.238)
  unreachable

sw.bb3.i:                                         ; preds = %sw.bb19
  %incdec.ptr.i94 = getelementptr inbounds i8, ptr %p.addr.0, i64 3
  %25 = load i8, ptr %incdec.ptr.i94, align 1
  %cmp5.i = icmp eq i8 %25, 94
  %incdec.ptr8.i = getelementptr inbounds i8, ptr %p.addr.0, i64 4
  %spec.select.i95 = select i1 %cmp5.i, ptr %incdec.ptr8.i, ptr %incdec.ptr.i94
  %.pr.i = load i8, ptr %spec.select.i95, align 1
  br label %do.body.i

do.body.i:                                        ; preds = %do.cond.i, %sw.bb3.i
  %26 = phi i8 [ %29, %do.cond.i ], [ %.pr.i, %sw.bb3.i ]
  %p.addr.1.i = phi ptr [ %p.addr.2.i, %do.cond.i ], [ %spec.select.i95, %sw.bb3.i ]
  %cmp11.i = icmp eq i8 %26, 0
  br i1 %cmp11.i, label %if.then13.i, label %if.end16.i

if.then13.i:                                      ; preds = %do.body.i
  %L14.i = getelementptr inbounds %struct.MatchState, ptr %ms, i64 0, i32 2
  %27 = load ptr, ptr %L14.i, align 8
  tail call void (ptr, ptr, ...) @luaL_error(ptr noundef %27, ptr noundef nonnull @.str.243)
  unreachable

if.end16.i:                                       ; preds = %do.body.i
  %incdec.ptr17.i = getelementptr inbounds i8, ptr %p.addr.1.i, i64 1
  %cmp19.i96 = icmp eq i8 %26, 37
  br i1 %cmp19.i96, label %land.lhs.true.i, label %do.cond.i

land.lhs.true.i:                                  ; preds = %if.end16.i
  %28 = load i8, ptr %incdec.ptr17.i, align 1
  %cmp22.not.i = icmp eq i8 %28, 0
  %incdec.ptr25.i = getelementptr inbounds i8, ptr %p.addr.1.i, i64 2
  %spec.select13.i = select i1 %cmp22.not.i, ptr %incdec.ptr17.i, ptr %incdec.ptr25.i
  br label %do.cond.i

do.cond.i:                                        ; preds = %land.lhs.true.i, %if.end16.i
  %p.addr.2.i = phi ptr [ %incdec.ptr17.i, %if.end16.i ], [ %spec.select13.i, %land.lhs.true.i ]
  %29 = load i8, ptr %p.addr.2.i, align 1
  %cmp28.not.i = icmp eq i8 %29, 93
  br i1 %cmp28.not.i, label %classend.exit, label %do.body.i, !llvm.loop !155

classend.exit:                                    ; preds = %do.cond.i
  %30 = load ptr, ptr %ms, align 8
  %cmp28 = icmp eq ptr %s.addr.0.ph, %30
  br i1 %cmp28, label %cond.end, label %cond.false

cond.false:                                       ; preds = %classend.exit
  %31 = load i8, ptr %add.ptr30, align 1
  br label %cond.end

cond.end:                                         ; preds = %classend.exit, %cond.false
  %cond = phi i8 [ %31, %cond.false ], [ 0, %classend.exit ]
  %conv33 = zext i8 %cond to i32
  %32 = load i8, ptr %incdec.ptr.i94, align 1
  %cmp.i105 = icmp eq i8 %32, 94
  %spec.select.i106 = select i1 %cmp.i105, ptr %incdec.ptr.i94, ptr %add.ptr20
  %not.cmp.i = xor i1 %cmp.i105, true
  %incdec.ptr220.i = getelementptr inbounds i8, ptr %spec.select.i106, i64 1
  %cmp321.i = icmp ult ptr %incdec.ptr220.i, %p.addr.2.i
  br i1 %cmp321.i, label %while.body.i108, label %return

while.body.i108:                                  ; preds = %cond.end, %if.end39.i
  %incdec.ptr223.i = phi ptr [ %incdec.ptr2.i, %if.end39.i ], [ %incdec.ptr220.i, %cond.end ]
  %p.addr.122.i = phi ptr [ %p.addr.2.i110, %if.end39.i ], [ %spec.select.i106, %cond.end ]
  %33 = load i8, ptr %incdec.ptr223.i, align 1
  %cmp6.i = icmp eq i8 %33, 37
  %incdec.ptr9.i = getelementptr inbounds i8, ptr %p.addr.122.i, i64 2
  %34 = load i8, ptr %incdec.ptr9.i, align 1
  br i1 %cmp6.i, label %if.then8.i, label %if.else.i109

if.then8.i:                                       ; preds = %while.body.i108
  %conv10.i = zext i8 %34 to i32
  %call.i114 = tail call fastcc i32 @match_class(i32 noundef %conv33, i32 noundef %conv10.i), !range !156
  %tobool.not.i = icmp eq i32 %call.i114, 0
  br i1 %tobool.not.i, label %if.end39.i, label %matchbracketclass.exit

if.else.i109:                                     ; preds = %while.body.i108
  %cmp15.i = icmp eq i8 %34, 45
  br i1 %cmp15.i, label %land.lhs.true.i112, label %if.else32.i

land.lhs.true.i112:                               ; preds = %if.else.i109
  %add.ptr17.i = getelementptr inbounds i8, ptr %p.addr.122.i, i64 3
  %cmp18.i = icmp ult ptr %add.ptr17.i, %p.addr.2.i
  br i1 %cmp18.i, label %if.then20.i, label %if.else32.i

if.then20.i:                                      ; preds = %land.lhs.true.i112
  %cmp24.not.i = icmp ugt i8 %33, %cond
  br i1 %cmp24.not.i, label %if.end39.i, label %land.lhs.true26.i

land.lhs.true26.i:                                ; preds = %if.then20.i
  %35 = load i8, ptr %add.ptr17.i, align 1
  %cmp28.not.i113 = icmp ult i8 %35, %cond
  br i1 %cmp28.not.i113, label %if.end39.i, label %matchbracketclass.exit

if.else32.i:                                      ; preds = %land.lhs.true.i112, %if.else.i109
  %cmp34.i = icmp eq i8 %33, %cond
  br i1 %cmp34.i, label %matchbracketclass.exit, label %if.end39.i

if.end39.i:                                       ; preds = %if.else32.i, %land.lhs.true26.i, %if.then20.i, %if.then8.i
  %p.addr.2.i110 = phi ptr [ %incdec.ptr9.i, %if.then8.i ], [ %add.ptr17.i, %land.lhs.true26.i ], [ %add.ptr17.i, %if.then20.i ], [ %incdec.ptr223.i, %if.else32.i ]
  %incdec.ptr2.i = getelementptr inbounds i8, ptr %p.addr.2.i110, i64 1
  %cmp3.i111 = icmp ult ptr %incdec.ptr2.i, %p.addr.2.i
  br i1 %cmp3.i111, label %while.body.i108, label %matchbracketclass.exit, !llvm.loop !157

matchbracketclass.exit:                           ; preds = %if.then8.i, %land.lhs.true26.i, %if.else32.i, %if.end39.i
  %retval.0.in.i = phi i1 [ %cmp.i105, %if.end39.i ], [ %not.cmp.i, %if.else32.i ], [ %not.cmp.i, %land.lhs.true26.i ], [ %not.cmp.i, %if.then8.i ]
  br i1 %retval.0.in.i, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %matchbracketclass.exit
  %36 = load i8, ptr %s.addr.0.ph, align 1
  %conv36 = zext i8 %36 to i32
  br label %while.body.i123

while.body.i123:                                  ; preds = %lor.lhs.false, %if.end39.i133
  %incdec.ptr223.i124 = phi ptr [ %incdec.ptr2.i135, %if.end39.i133 ], [ %incdec.ptr220.i, %lor.lhs.false ]
  %p.addr.122.i125 = phi ptr [ %p.addr.2.i134, %if.end39.i133 ], [ %spec.select.i106, %lor.lhs.false ]
  %37 = load i8, ptr %incdec.ptr223.i124, align 1
  %cmp6.i126 = icmp eq i8 %37, 37
  %incdec.ptr9.i127 = getelementptr inbounds i8, ptr %p.addr.122.i125, i64 2
  %38 = load i8, ptr %incdec.ptr9.i127, align 1
  br i1 %cmp6.i126, label %if.then8.i146, label %if.else.i128

if.then8.i146:                                    ; preds = %while.body.i123
  %conv10.i147 = zext i8 %38 to i32
  %call.i148 = tail call fastcc i32 @match_class(i32 noundef %conv36, i32 noundef %conv10.i147), !range !156
  %tobool.not.i149 = icmp eq i32 %call.i148, 0
  br i1 %tobool.not.i149, label %if.end39.i133, label %matchbracketclass.exit150

if.else.i128:                                     ; preds = %while.body.i123
  %cmp15.i129 = icmp eq i8 %38, 45
  br i1 %cmp15.i129, label %land.lhs.true.i137, label %if.else32.i130

land.lhs.true.i137:                               ; preds = %if.else.i128
  %add.ptr17.i138 = getelementptr inbounds i8, ptr %p.addr.122.i125, i64 3
  %cmp18.i139 = icmp ult ptr %add.ptr17.i138, %p.addr.2.i
  br i1 %cmp18.i139, label %if.then20.i140, label %if.else32.i130

if.then20.i140:                                   ; preds = %land.lhs.true.i137
  %cmp24.not.i142 = icmp ugt i8 %37, %36
  br i1 %cmp24.not.i142, label %if.end39.i133, label %land.lhs.true26.i143

land.lhs.true26.i143:                             ; preds = %if.then20.i140
  %39 = load i8, ptr %add.ptr17.i138, align 1
  %cmp28.not.i145 = icmp ult i8 %39, %36
  br i1 %cmp28.not.i145, label %if.end39.i133, label %matchbracketclass.exit150

if.else32.i130:                                   ; preds = %land.lhs.true.i137, %if.else.i128
  %cmp34.i132 = icmp eq i8 %37, %36
  br i1 %cmp34.i132, label %matchbracketclass.exit150, label %if.end39.i133

if.end39.i133:                                    ; preds = %if.else32.i130, %land.lhs.true26.i143, %if.then20.i140, %if.then8.i146
  %p.addr.2.i134 = phi ptr [ %incdec.ptr9.i127, %if.then8.i146 ], [ %add.ptr17.i138, %land.lhs.true26.i143 ], [ %add.ptr17.i138, %if.then20.i140 ], [ %incdec.ptr223.i124, %if.else32.i130 ]
  %incdec.ptr2.i135 = getelementptr inbounds i8, ptr %p.addr.2.i134, i64 1
  %cmp3.i136 = icmp ult ptr %incdec.ptr2.i135, %p.addr.2.i
  br i1 %cmp3.i136, label %while.body.i123, label %matchbracketclass.exit150, !llvm.loop !157

matchbracketclass.exit150:                        ; preds = %if.then8.i146, %land.lhs.true26.i143, %if.else32.i130, %if.end39.i133
  %retval.0.in.i121 = phi i1 [ %cmp.i105, %if.end39.i133 ], [ %not.cmp.i, %if.else32.i130 ], [ %not.cmp.i, %land.lhs.true26.i143 ], [ %not.cmp.i, %if.then8.i146 ]
  br i1 %retval.0.in.i121, label %init.backedge, label %return

sw.default:                                       ; preds = %sw.bb9
  %call42 = tail call ptr @__ctype_b_loc() #39
  %40 = load ptr, ptr %call42, align 8
  %idxprom = zext i8 %14 to i64
  %arrayidx = getelementptr inbounds i16, ptr %40, i64 %idxprom
  %41 = load i16, ptr %arrayidx, align 2
  %42 = and i16 %41, 2048
  %tobool46.not = icmp eq i16 %42, 0
  br i1 %tobool46.not, label %dflt.thread414, label %if.then47

dflt.thread414:                                   ; preds = %sw.default
  %cmp.i188 = icmp eq i8 %14, 0
  br i1 %cmp.i188, label %if.then.i191, label %if.end.i189

if.then47:                                        ; preds = %sw.default
  %conv44 = zext i8 %14 to i32
  %sub.i.i = add nsw i32 %conv44, -49
  %cmp.i.i = icmp ult i8 %14, 49
  br i1 %cmp.i.i, label %if.then.i.i, label %lor.lhs.false.i.i

lor.lhs.false.i.i:                                ; preds = %if.then47
  %43 = load i32, ptr %level.i.i, align 8
  %cmp1.not.i.i = icmp slt i32 %sub.i.i, %43
  br i1 %cmp1.not.i.i, label %lor.lhs.false2.i.i, label %if.then.i.i

lor.lhs.false2.i.i:                               ; preds = %lor.lhs.false.i.i
  %idxprom.i.i = zext nneg i32 %sub.i.i to i64
  %len.i.i = getelementptr inbounds %struct.MatchState, ptr %ms, i64 0, i32 4, i64 %idxprom.i.i, i32 1
  %44 = load i64, ptr %len.i.i, align 8
  %cmp3.i.i = icmp eq i64 %44, -1
  br i1 %cmp3.i.i, label %if.then.i.i, label %check_capture.exit.i

if.then.i.i:                                      ; preds = %lor.lhs.false2.i.i, %lor.lhs.false.i.i, %if.then47
  %L.i.i = getelementptr inbounds %struct.MatchState, ptr %ms, i64 0, i32 2
  %45 = load ptr, ptr %L.i.i, align 8
  tail call void (ptr, ptr, ...) @luaL_error(ptr noundef %45, ptr noundef nonnull @.str.244)
  unreachable

check_capture.exit.i:                             ; preds = %lor.lhs.false2.i.i
  %46 = load ptr, ptr %src_end74, align 8
  %sub.ptr.lhs.cast.i152 = ptrtoint ptr %46 to i64
  %sub.ptr.rhs.cast.i153 = ptrtoint ptr %s.addr.0.ph to i64
  %sub.ptr.sub.i154 = sub i64 %sub.ptr.lhs.cast.i152, %sub.ptr.rhs.cast.i153
  %cmp.not.i = icmp ult i64 %sub.ptr.sub.i154, %44
  br i1 %cmp.not.i, label %return, label %land.lhs.true.i155

land.lhs.true.i155:                               ; preds = %check_capture.exit.i
  %arrayidx.i156 = getelementptr inbounds %struct.MatchState, ptr %ms, i64 0, i32 4, i64 %idxprom.i.i
  %47 = load ptr, ptr %arrayidx.i156, align 8
  %bcmp.i = tail call i32 @bcmp(ptr %47, ptr %s.addr.0.ph, i64 %44)
  %cmp6.i157 = icmp ne i32 %bcmp.i, 0
  %cmp51 = icmp eq ptr %s.addr.0.ph, null
  %or.cond = select i1 %cmp6.i157, i1 true, i1 %cmp51
  br i1 %or.cond, label %return, label %if.end54

if.end54:                                         ; preds = %land.lhs.true.i155
  %add.ptr.i158 = getelementptr inbounds i8, ptr %s.addr.0.ph, i64 %44
  %add.ptr55 = getelementptr inbounds i8, ptr %p.addr.0, i64 2
  br label %init.outer.backedge

sw.bb58:                                          ; preds = %init
  %add.ptr59 = getelementptr inbounds i8, ptr %p.addr.0, i64 1
  %48 = load i8, ptr %add.ptr59, align 1
  %cmp61 = icmp eq i8 %48, 0
  br i1 %cmp61, label %if.then63, label %classend.exit194

if.then63:                                        ; preds = %sw.bb58
  %49 = load ptr, ptr %src_end74, align 8
  %cmp64 = icmp eq ptr %s.addr.0.ph, %49
  %cond69 = select i1 %cmp64, ptr %s.addr.0.ph, ptr null
  br label %return

dflt:                                             ; preds = %init
  %incdec.ptr.i161 = getelementptr inbounds i8, ptr %p.addr.0, i64 1
  %cond423 = icmp eq i8 %0, 91
  br i1 %cond423, label %sw.bb3.i163, label %classend.exit194

if.then.i191:                                     ; preds = %dflt.thread414
  %L.i192 = getelementptr inbounds %struct.MatchState, ptr %ms, i64 0, i32 2
  %50 = load ptr, ptr %L.i192, align 8
  tail call void (ptr, ptr, ...) @luaL_error(ptr noundef %50, ptr noundef nonnull @.str.242)
  unreachable

if.end.i189:                                      ; preds = %dflt.thread414
  %add.ptr.i190 = getelementptr inbounds i8, ptr %p.addr.0, i64 2
  br label %classend.exit194

sw.bb3.i163:                                      ; preds = %dflt
  %51 = load i8, ptr %incdec.ptr.i161, align 1
  %cmp5.i164 = icmp eq i8 %51, 94
  %incdec.ptr8.i165 = getelementptr inbounds i8, ptr %p.addr.0, i64 2
  %spec.select.i166 = select i1 %cmp5.i164, ptr %incdec.ptr8.i165, ptr %incdec.ptr.i161
  %.pr.i167 = load i8, ptr %spec.select.i166, align 1
  br label %do.body.i168

do.body.i168:                                     ; preds = %do.cond.i174, %sw.bb3.i163
  %52 = phi i8 [ %55, %do.cond.i174 ], [ %.pr.i167, %sw.bb3.i163 ]
  %p.addr.1.i169 = phi ptr [ %p.addr.2.i175, %do.cond.i174 ], [ %spec.select.i166, %sw.bb3.i163 ]
  %cmp11.i170 = icmp eq i8 %52, 0
  br i1 %cmp11.i170, label %if.then13.i184, label %if.end16.i171

if.then13.i184:                                   ; preds = %do.body.i168
  %L14.i185 = getelementptr inbounds %struct.MatchState, ptr %ms, i64 0, i32 2
  %53 = load ptr, ptr %L14.i185, align 8
  tail call void (ptr, ptr, ...) @luaL_error(ptr noundef %53, ptr noundef nonnull @.str.243)
  unreachable

if.end16.i171:                                    ; preds = %do.body.i168
  %incdec.ptr17.i172 = getelementptr inbounds i8, ptr %p.addr.1.i169, i64 1
  %cmp19.i173 = icmp eq i8 %52, 37
  br i1 %cmp19.i173, label %land.lhs.true.i180, label %do.cond.i174

land.lhs.true.i180:                               ; preds = %if.end16.i171
  %54 = load i8, ptr %incdec.ptr17.i172, align 1
  %cmp22.not.i181 = icmp eq i8 %54, 0
  %incdec.ptr25.i182 = getelementptr inbounds i8, ptr %p.addr.1.i169, i64 2
  %spec.select13.i183 = select i1 %cmp22.not.i181, ptr %incdec.ptr17.i172, ptr %incdec.ptr25.i182
  br label %do.cond.i174

do.cond.i174:                                     ; preds = %land.lhs.true.i180, %if.end16.i171
  %p.addr.2.i175 = phi ptr [ %incdec.ptr17.i172, %if.end16.i171 ], [ %spec.select13.i183, %land.lhs.true.i180 ]
  %55 = load i8, ptr %p.addr.2.i175, align 1
  %cmp28.not.i176 = icmp eq i8 %55, 93
  br i1 %cmp28.not.i176, label %do.end.i177, label %do.body.i168, !llvm.loop !155

do.end.i177:                                      ; preds = %do.cond.i174
  %add.ptr30.i178 = getelementptr inbounds i8, ptr %p.addr.2.i175, i64 1
  br label %classend.exit194

classend.exit194:                                 ; preds = %sw.bb58, %dflt, %if.end.i189, %do.end.i177
  %incdec.ptr.i161412 = phi ptr [ %incdec.ptr.i161, %do.end.i177 ], [ %add.ptr10, %if.end.i189 ], [ %incdec.ptr.i161, %dflt ], [ %add.ptr59, %sw.bb58 ]
  %retval.0.i179 = phi ptr [ %add.ptr30.i178, %do.end.i177 ], [ %add.ptr.i190, %if.end.i189 ], [ %incdec.ptr.i161, %dflt ], [ %add.ptr59, %sw.bb58 ]
  %56 = load ptr, ptr %src_end74, align 8
  %cmp75 = icmp ult ptr %s.addr.0.ph, %56
  br i1 %cmp75, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %classend.exit194
  %57 = load i8, ptr %s.addr.0.ph, align 1
  %conv77 = zext i8 %57 to i32
  switch i32 %conv, label %sw.default.i [
    i32 46, label %singlematch.exit
    i32 37, label %sw.bb1.i
    i32 91, label %sw.bb3.i196
  ]

sw.bb1.i:                                         ; preds = %land.rhs
  %58 = load i8, ptr %incdec.ptr.i161412, align 1
  %conv2.i = zext i8 %58 to i32
  %call.i202 = tail call fastcc i32 @match_class(i32 noundef %conv77, i32 noundef %conv2.i), !range !156
  br label %singlematch.exit

sw.bb3.i196:                                      ; preds = %land.rhs
  %add.ptr4.i = getelementptr inbounds i8, ptr %retval.0.i179, i64 -1
  %59 = load i8, ptr %incdec.ptr.i161412, align 1
  %cmp.i.i197 = icmp eq i8 %59, 94
  %spec.select.i.i = select i1 %cmp.i.i197, ptr %incdec.ptr.i161412, ptr %p.addr.0
  %not.cmp.i.i = xor i1 %cmp.i.i197, true
  %incdec.ptr220.i.i = getelementptr inbounds i8, ptr %spec.select.i.i, i64 1
  %cmp321.i.i = icmp ult ptr %incdec.ptr220.i.i, %add.ptr4.i
  br i1 %cmp321.i.i, label %while.body.i.i, label %matchbracketclass.exit.i

while.body.i.i:                                   ; preds = %sw.bb3.i196, %if.end39.i.i
  %incdec.ptr223.i.i = phi ptr [ %incdec.ptr2.i.i, %if.end39.i.i ], [ %incdec.ptr220.i.i, %sw.bb3.i196 ]
  %p.addr.122.i.i = phi ptr [ %p.addr.2.i.i, %if.end39.i.i ], [ %spec.select.i.i, %sw.bb3.i196 ]
  %60 = load i8, ptr %incdec.ptr223.i.i, align 1
  %cmp6.i.i = icmp eq i8 %60, 37
  %incdec.ptr9.i.i = getelementptr inbounds i8, ptr %p.addr.122.i.i, i64 2
  %61 = load i8, ptr %incdec.ptr9.i.i, align 1
  br i1 %cmp6.i.i, label %if.then8.i.i, label %if.else.i.i

if.then8.i.i:                                     ; preds = %while.body.i.i
  %conv10.i.i = zext i8 %61 to i32
  %call.i.i200 = tail call fastcc i32 @match_class(i32 noundef %conv77, i32 noundef %conv10.i.i), !range !156
  %tobool.not.i.i = icmp eq i32 %call.i.i200, 0
  br i1 %tobool.not.i.i, label %if.end39.i.i, label %matchbracketclass.exit.i

if.else.i.i:                                      ; preds = %while.body.i.i
  %cmp15.i.i = icmp eq i8 %61, 45
  br i1 %cmp15.i.i, label %land.lhs.true.i.i, label %if.else32.i.i

land.lhs.true.i.i:                                ; preds = %if.else.i.i
  %add.ptr17.i.i = getelementptr inbounds i8, ptr %p.addr.122.i.i, i64 3
  %cmp18.i.i = icmp ult ptr %add.ptr17.i.i, %add.ptr4.i
  br i1 %cmp18.i.i, label %if.then20.i.i, label %if.else32.i.i

if.then20.i.i:                                    ; preds = %land.lhs.true.i.i
  %cmp24.not.i.i = icmp ugt i8 %60, %57
  br i1 %cmp24.not.i.i, label %if.end39.i.i, label %land.lhs.true26.i.i

land.lhs.true26.i.i:                              ; preds = %if.then20.i.i
  %62 = load i8, ptr %add.ptr17.i.i, align 1
  %cmp28.not.i.i = icmp ult i8 %62, %57
  br i1 %cmp28.not.i.i, label %if.end39.i.i, label %matchbracketclass.exit.i

if.else32.i.i:                                    ; preds = %land.lhs.true.i.i, %if.else.i.i
  %cmp34.i.i = icmp eq i8 %60, %57
  br i1 %cmp34.i.i, label %matchbracketclass.exit.i, label %if.end39.i.i

if.end39.i.i:                                     ; preds = %if.else32.i.i, %land.lhs.true26.i.i, %if.then20.i.i, %if.then8.i.i
  %p.addr.2.i.i = phi ptr [ %incdec.ptr9.i.i, %if.then8.i.i ], [ %add.ptr17.i.i, %land.lhs.true26.i.i ], [ %add.ptr17.i.i, %if.then20.i.i ], [ %incdec.ptr223.i.i, %if.else32.i.i ]
  %incdec.ptr2.i.i = getelementptr inbounds i8, ptr %p.addr.2.i.i, i64 1
  %cmp3.i.i199 = icmp ult ptr %incdec.ptr2.i.i, %add.ptr4.i
  br i1 %cmp3.i.i199, label %while.body.i.i, label %matchbracketclass.exit.i, !llvm.loop !157

matchbracketclass.exit.i:                         ; preds = %if.end39.i.i, %if.else32.i.i, %land.lhs.true26.i.i, %if.then8.i.i, %sw.bb3.i196
  %retval.0.in.i.i = phi i1 [ %cmp.i.i197, %sw.bb3.i196 ], [ %cmp.i.i197, %if.end39.i.i ], [ %not.cmp.i.i, %if.else32.i.i ], [ %not.cmp.i.i, %land.lhs.true26.i.i ], [ %not.cmp.i.i, %if.then8.i.i ]
  %retval.0.i.i = zext i1 %retval.0.in.i.i to i32
  br label %singlematch.exit

sw.default.i:                                     ; preds = %land.rhs
  %cmp.i203 = icmp eq i8 %0, %57
  %conv7.i = zext i1 %cmp.i203 to i32
  br label %singlematch.exit

singlematch.exit:                                 ; preds = %land.rhs, %sw.bb1.i, %matchbracketclass.exit.i, %sw.default.i
  %retval.0.i198 = phi i32 [ %conv7.i, %sw.default.i ], [ %retval.0.i.i, %matchbracketclass.exit.i ], [ %call.i202, %sw.bb1.i ], [ 1, %land.rhs ]
  %tobool79 = icmp ne i32 %retval.0.i198, 0
  br label %land.end

land.end:                                         ; preds = %singlematch.exit, %classend.exit194
  %63 = phi i1 [ false, %classend.exit194 ], [ %tobool79, %singlematch.exit ]
  %64 = load i8, ptr %retval.0.i179, align 1
  %conv80 = sext i8 %64 to i32
  switch i32 %conv80, label %sw.default103 [
    i32 63, label %sw.bb81
    i32 42, label %while.cond.i.preheader
    i32 43, label %sw.bb93
    i32 45, label %for.cond.i.preheader
  ]

for.cond.i.preheader:                             ; preds = %land.end
  %add.ptr.i240 = getelementptr inbounds i8, ptr %retval.0.i179, i64 1
  %call.i241514 = tail call fastcc ptr @match(ptr noundef %ms, ptr noundef %s.addr.0.ph, ptr noundef nonnull %add.ptr.i240)
  %cmp.not.i242515 = icmp eq ptr %call.i241514, null
  br i1 %cmp.not.i242515, label %if.else.i244.lr.ph, label %return

if.else.i244.lr.ph:                               ; preds = %for.cond.i.preheader
  %add.ptr4.i356 = getelementptr inbounds i8, ptr %retval.0.i179, i64 -1
  br label %if.else.i244

while.cond.i.preheader:                           ; preds = %land.end
  br i1 %cmp75, label %land.rhs.i.lr.ph, label %while.body5.i.lr.ph

land.rhs.i.lr.ph:                                 ; preds = %while.cond.i.preheader
  %.lcssa552628 = ptrtoint ptr %56 to i64
  %s.addr.0.ph.lcssa621627 = ptrtoint ptr %s.addr.0.ph to i64
  %add.ptr4.i258 = getelementptr inbounds i8, ptr %retval.0.i179, i64 -1
  %65 = sub i64 %.lcssa552628, %s.addr.0.ph.lcssa621627
  br label %land.rhs.i

sw.bb81:                                          ; preds = %land.end
  br i1 %63, label %land.lhs.true, label %init.backedge

land.lhs.true:                                    ; preds = %sw.bb81
  %add.ptr84 = getelementptr inbounds i8, ptr %retval.0.i179, i64 1
  %call85 = tail call fastcc ptr @match(ptr noundef %ms, ptr noundef nonnull %add.ptr83, ptr noundef nonnull %add.ptr84)
  %cmp86.not = icmp eq ptr %call85, null
  br i1 %cmp86.not, label %init.backedge, label %return

init.backedge:                                    ; preds = %sw.bb81, %land.lhs.true, %matchbracketclass.exit150
  %retval.0.i179.pn = phi ptr [ %p.addr.2.i, %matchbracketclass.exit150 ], [ %retval.0.i179, %land.lhs.true ], [ %retval.0.i179, %sw.bb81 ]
  %p.addr.0.be = getelementptr inbounds i8, ptr %retval.0.i179.pn, i64 1
  br label %init

land.rhs.i:                                       ; preds = %land.rhs.i.lr.ph, %while.body.i214
  %add.ptr.i204530 = phi ptr [ %s.addr.0.ph, %land.rhs.i.lr.ph ], [ %add.ptr.i204, %while.body.i214 ]
  %i.0.i529 = phi i64 [ 0, %land.rhs.i.lr.ph ], [ %inc.i215, %while.body.i214 ]
  %66 = load i8, ptr %add.ptr.i204530, align 1
  %conv.i211 = zext i8 %66 to i32
  switch i32 %conv, label %sw.default.i300 [
    i32 46, label %while.body.i214
    i32 37, label %sw.bb1.i296
    i32 91, label %sw.bb3.i257
  ]

sw.bb1.i296:                                      ; preds = %land.rhs.i
  %67 = load i8, ptr %incdec.ptr.i161412, align 1
  %conv2.i298 = zext i8 %67 to i32
  %call.i299 = tail call fastcc i32 @match_class(i32 noundef %conv.i211, i32 noundef %conv2.i298), !range !156
  br label %singlematch.exit304

sw.bb3.i257:                                      ; preds = %land.rhs.i
  %68 = load i8, ptr %incdec.ptr.i161412, align 1
  %cmp.i.i260 = icmp eq i8 %68, 94
  %spec.select.i.i261 = select i1 %cmp.i.i260, ptr %incdec.ptr.i161412, ptr %p.addr.0
  %not.cmp.i.i262 = xor i1 %cmp.i.i260, true
  %incdec.ptr220.i.i263 = getelementptr inbounds i8, ptr %spec.select.i.i261, i64 1
  %cmp321.i.i264 = icmp ult ptr %incdec.ptr220.i.i263, %add.ptr4.i258
  br i1 %cmp321.i.i264, label %while.body.i.i269, label %matchbracketclass.exit.i265

while.body.i.i269:                                ; preds = %sw.bb3.i257, %if.end39.i.i279
  %incdec.ptr223.i.i270 = phi ptr [ %incdec.ptr2.i.i281, %if.end39.i.i279 ], [ %incdec.ptr220.i.i263, %sw.bb3.i257 ]
  %p.addr.122.i.i271 = phi ptr [ %p.addr.2.i.i280, %if.end39.i.i279 ], [ %spec.select.i.i261, %sw.bb3.i257 ]
  %69 = load i8, ptr %incdec.ptr223.i.i270, align 1
  %cmp6.i.i272 = icmp eq i8 %69, 37
  %incdec.ptr9.i.i273 = getelementptr inbounds i8, ptr %p.addr.122.i.i271, i64 2
  %70 = load i8, ptr %incdec.ptr9.i.i273, align 1
  br i1 %cmp6.i.i272, label %if.then8.i.i292, label %if.else.i.i274

if.then8.i.i292:                                  ; preds = %while.body.i.i269
  %conv10.i.i293 = zext i8 %70 to i32
  %call.i.i294 = tail call fastcc i32 @match_class(i32 noundef %conv.i211, i32 noundef %conv10.i.i293), !range !156
  %tobool.not.i.i295 = icmp eq i32 %call.i.i294, 0
  br i1 %tobool.not.i.i295, label %if.end39.i.i279, label %matchbracketclass.exit.i265

if.else.i.i274:                                   ; preds = %while.body.i.i269
  %cmp15.i.i275 = icmp eq i8 %70, 45
  br i1 %cmp15.i.i275, label %land.lhs.true.i.i283, label %if.else32.i.i276

land.lhs.true.i.i283:                             ; preds = %if.else.i.i274
  %add.ptr17.i.i284 = getelementptr inbounds i8, ptr %p.addr.122.i.i271, i64 3
  %cmp18.i.i285 = icmp ult ptr %add.ptr17.i.i284, %add.ptr4.i258
  br i1 %cmp18.i.i285, label %if.then20.i.i286, label %if.else32.i.i276

if.then20.i.i286:                                 ; preds = %land.lhs.true.i.i283
  %cmp24.not.i.i288 = icmp ugt i8 %69, %66
  br i1 %cmp24.not.i.i288, label %if.end39.i.i279, label %land.lhs.true26.i.i289

land.lhs.true26.i.i289:                           ; preds = %if.then20.i.i286
  %71 = load i8, ptr %add.ptr17.i.i284, align 1
  %cmp28.not.i.i291 = icmp ult i8 %71, %66
  br i1 %cmp28.not.i.i291, label %if.end39.i.i279, label %matchbracketclass.exit.i265

if.else32.i.i276:                                 ; preds = %land.lhs.true.i.i283, %if.else.i.i274
  %cmp34.i.i278 = icmp eq i8 %69, %66
  br i1 %cmp34.i.i278, label %matchbracketclass.exit.i265, label %if.end39.i.i279

if.end39.i.i279:                                  ; preds = %if.else32.i.i276, %land.lhs.true26.i.i289, %if.then20.i.i286, %if.then8.i.i292
  %p.addr.2.i.i280 = phi ptr [ %incdec.ptr9.i.i273, %if.then8.i.i292 ], [ %add.ptr17.i.i284, %land.lhs.true26.i.i289 ], [ %add.ptr17.i.i284, %if.then20.i.i286 ], [ %incdec.ptr223.i.i270, %if.else32.i.i276 ]
  %incdec.ptr2.i.i281 = getelementptr inbounds i8, ptr %p.addr.2.i.i280, i64 1
  %cmp3.i.i282 = icmp ult ptr %incdec.ptr2.i.i281, %add.ptr4.i258
  br i1 %cmp3.i.i282, label %while.body.i.i269, label %matchbracketclass.exit.i265, !llvm.loop !157

matchbracketclass.exit.i265:                      ; preds = %if.end39.i.i279, %if.else32.i.i276, %land.lhs.true26.i.i289, %if.then8.i.i292, %sw.bb3.i257
  %retval.0.in.i.i266 = phi i1 [ %cmp.i.i260, %sw.bb3.i257 ], [ %cmp.i.i260, %if.end39.i.i279 ], [ %not.cmp.i.i262, %if.else32.i.i276 ], [ %not.cmp.i.i262, %land.lhs.true26.i.i289 ], [ %not.cmp.i.i262, %if.then8.i.i292 ]
  %retval.0.i.i267 = zext i1 %retval.0.in.i.i266 to i32
  br label %singlematch.exit304

sw.default.i300:                                  ; preds = %land.rhs.i
  %cmp.i302 = icmp eq i8 %0, %66
  %conv7.i303 = zext i1 %cmp.i302 to i32
  br label %singlematch.exit304

singlematch.exit304:                              ; preds = %sw.bb1.i296, %matchbracketclass.exit.i265, %sw.default.i300
  %retval.0.i268 = phi i32 [ %conv7.i303, %sw.default.i300 ], [ %retval.0.i.i267, %matchbracketclass.exit.i265 ], [ %call.i299, %sw.bb1.i296 ]
  %tobool.not.i213 = icmp eq i32 %retval.0.i268, 0
  br i1 %tobool.not.i213, label %while.end.i, label %while.body.i214

while.body.i214:                                  ; preds = %land.rhs.i, %singlematch.exit304
  %inc.i215 = add nuw i64 %i.0.i529, 1
  %add.ptr.i204 = getelementptr inbounds i8, ptr %s.addr.0.ph, i64 %inc.i215
  %exitcond629.not = icmp eq i64 %inc.i215, %65
  br i1 %exitcond629.not, label %while.end.i, label %land.rhs.i, !llvm.loop !158

while.end.i:                                      ; preds = %while.body.i214, %singlematch.exit304
  %i.0.i.lcssa = phi i64 [ %65, %while.body.i214 ], [ %i.0.i529, %singlematch.exit304 ]
  %cmp3.i207533 = icmp sgt i64 %i.0.i.lcssa, -1
  br i1 %cmp3.i207533, label %while.body5.i.lr.ph, label %return

while.body5.i.lr.ph:                              ; preds = %while.cond.i.preheader, %while.end.i
  %i.0.i.lcssa633 = phi i64 [ %i.0.i.lcssa, %while.end.i ], [ 0, %while.cond.i.preheader ]
  %add.ptr7.i = getelementptr inbounds i8, ptr %retval.0.i179, i64 1
  br label %while.body5.i

while.cond2.i:                                    ; preds = %while.body5.i
  %dec.i210 = add nsw i64 %i.1.i534, -1
  %cmp3.i207 = icmp sgt i64 %i.1.i534, 0
  br i1 %cmp3.i207, label %while.body5.i, label %return, !llvm.loop !159

while.body5.i:                                    ; preds = %while.body5.i.lr.ph, %while.cond2.i
  %i.1.i534 = phi i64 [ %i.0.i.lcssa633, %while.body5.i.lr.ph ], [ %dec.i210, %while.cond2.i ]
  %add.ptr6.i = getelementptr inbounds i8, ptr %s.addr.0.ph, i64 %i.1.i534
  %call8.i = tail call fastcc ptr @match(ptr noundef %ms, ptr noundef %add.ptr6.i, ptr noundef nonnull %add.ptr7.i)
  %tobool9.not.i = icmp eq ptr %call8.i, null
  br i1 %tobool9.not.i, label %while.cond2.i, label %return

sw.bb93:                                          ; preds = %land.end
  %s.addr.0.ph.lcssa622625 = ptrtoint ptr %s.addr.0.ph to i64
  %.lcssa553626 = ptrtoint ptr %56 to i64
  br i1 %63, label %cond.true95, label %return

cond.true95:                                      ; preds = %sw.bb93
  %cmp.i220519 = icmp ult ptr %add.ptr83, %56
  br i1 %cmp.i220519, label %land.rhs.i233.lr.ph, label %while.body5.i226.lr.ph

land.rhs.i233.lr.ph:                              ; preds = %cond.true95
  %add.ptr4.i307 = getelementptr inbounds i8, ptr %retval.0.i179, i64 -1
  %72 = xor i64 %s.addr.0.ph.lcssa622625, -1
  %73 = add i64 %72, %.lcssa553626
  br label %land.rhs.i233

land.rhs.i233:                                    ; preds = %land.rhs.i233.lr.ph, %while.body.i237
  %add.ptr.i218521 = phi ptr [ %add.ptr83, %land.rhs.i233.lr.ph ], [ %add.ptr.i218, %while.body.i237 ]
  %i.0.i217520 = phi i64 [ 0, %land.rhs.i233.lr.ph ], [ %inc.i238, %while.body.i237 ]
  %74 = load i8, ptr %add.ptr.i218521, align 1
  %conv.i234 = zext i8 %74 to i32
  switch i32 %conv, label %sw.default.i349 [
    i32 46, label %while.body.i237
    i32 37, label %sw.bb1.i345
    i32 91, label %sw.bb3.i306
  ]

sw.bb1.i345:                                      ; preds = %land.rhs.i233
  %75 = load i8, ptr %incdec.ptr.i161412, align 1
  %conv2.i347 = zext i8 %75 to i32
  %call.i348 = tail call fastcc i32 @match_class(i32 noundef %conv.i234, i32 noundef %conv2.i347), !range !156
  br label %singlematch.exit353

sw.bb3.i306:                                      ; preds = %land.rhs.i233
  %76 = load i8, ptr %incdec.ptr.i161412, align 1
  %cmp.i.i309 = icmp eq i8 %76, 94
  %spec.select.i.i310 = select i1 %cmp.i.i309, ptr %incdec.ptr.i161412, ptr %p.addr.0
  %not.cmp.i.i311 = xor i1 %cmp.i.i309, true
  %incdec.ptr220.i.i312 = getelementptr inbounds i8, ptr %spec.select.i.i310, i64 1
  %cmp321.i.i313 = icmp ult ptr %incdec.ptr220.i.i312, %add.ptr4.i307
  br i1 %cmp321.i.i313, label %while.body.i.i318, label %matchbracketclass.exit.i314

while.body.i.i318:                                ; preds = %sw.bb3.i306, %if.end39.i.i328
  %incdec.ptr223.i.i319 = phi ptr [ %incdec.ptr2.i.i330, %if.end39.i.i328 ], [ %incdec.ptr220.i.i312, %sw.bb3.i306 ]
  %p.addr.122.i.i320 = phi ptr [ %p.addr.2.i.i329, %if.end39.i.i328 ], [ %spec.select.i.i310, %sw.bb3.i306 ]
  %77 = load i8, ptr %incdec.ptr223.i.i319, align 1
  %cmp6.i.i321 = icmp eq i8 %77, 37
  %incdec.ptr9.i.i322 = getelementptr inbounds i8, ptr %p.addr.122.i.i320, i64 2
  %78 = load i8, ptr %incdec.ptr9.i.i322, align 1
  br i1 %cmp6.i.i321, label %if.then8.i.i341, label %if.else.i.i323

if.then8.i.i341:                                  ; preds = %while.body.i.i318
  %conv10.i.i342 = zext i8 %78 to i32
  %call.i.i343 = tail call fastcc i32 @match_class(i32 noundef %conv.i234, i32 noundef %conv10.i.i342), !range !156
  %tobool.not.i.i344 = icmp eq i32 %call.i.i343, 0
  br i1 %tobool.not.i.i344, label %if.end39.i.i328, label %matchbracketclass.exit.i314

if.else.i.i323:                                   ; preds = %while.body.i.i318
  %cmp15.i.i324 = icmp eq i8 %78, 45
  br i1 %cmp15.i.i324, label %land.lhs.true.i.i332, label %if.else32.i.i325

land.lhs.true.i.i332:                             ; preds = %if.else.i.i323
  %add.ptr17.i.i333 = getelementptr inbounds i8, ptr %p.addr.122.i.i320, i64 3
  %cmp18.i.i334 = icmp ult ptr %add.ptr17.i.i333, %add.ptr4.i307
  br i1 %cmp18.i.i334, label %if.then20.i.i335, label %if.else32.i.i325

if.then20.i.i335:                                 ; preds = %land.lhs.true.i.i332
  %cmp24.not.i.i337 = icmp ugt i8 %77, %74
  br i1 %cmp24.not.i.i337, label %if.end39.i.i328, label %land.lhs.true26.i.i338

land.lhs.true26.i.i338:                           ; preds = %if.then20.i.i335
  %79 = load i8, ptr %add.ptr17.i.i333, align 1
  %cmp28.not.i.i340 = icmp ult i8 %79, %74
  br i1 %cmp28.not.i.i340, label %if.end39.i.i328, label %matchbracketclass.exit.i314

if.else32.i.i325:                                 ; preds = %land.lhs.true.i.i332, %if.else.i.i323
  %cmp34.i.i327 = icmp eq i8 %77, %74
  br i1 %cmp34.i.i327, label %matchbracketclass.exit.i314, label %if.end39.i.i328

if.end39.i.i328:                                  ; preds = %if.else32.i.i325, %land.lhs.true26.i.i338, %if.then20.i.i335, %if.then8.i.i341
  %p.addr.2.i.i329 = phi ptr [ %incdec.ptr9.i.i322, %if.then8.i.i341 ], [ %add.ptr17.i.i333, %land.lhs.true26.i.i338 ], [ %add.ptr17.i.i333, %if.then20.i.i335 ], [ %incdec.ptr223.i.i319, %if.else32.i.i325 ]
  %incdec.ptr2.i.i330 = getelementptr inbounds i8, ptr %p.addr.2.i.i329, i64 1
  %cmp3.i.i331 = icmp ult ptr %incdec.ptr2.i.i330, %add.ptr4.i307
  br i1 %cmp3.i.i331, label %while.body.i.i318, label %matchbracketclass.exit.i314, !llvm.loop !157

matchbracketclass.exit.i314:                      ; preds = %if.end39.i.i328, %if.else32.i.i325, %land.lhs.true26.i.i338, %if.then8.i.i341, %sw.bb3.i306
  %retval.0.in.i.i315 = phi i1 [ %cmp.i.i309, %sw.bb3.i306 ], [ %cmp.i.i309, %if.end39.i.i328 ], [ %not.cmp.i.i311, %if.else32.i.i325 ], [ %not.cmp.i.i311, %land.lhs.true26.i.i338 ], [ %not.cmp.i.i311, %if.then8.i.i341 ]
  %retval.0.i.i316 = zext i1 %retval.0.in.i.i315 to i32
  br label %singlematch.exit353

sw.default.i349:                                  ; preds = %land.rhs.i233
  %cmp.i351 = icmp eq i8 %0, %74
  %conv7.i352 = zext i1 %cmp.i351 to i32
  br label %singlematch.exit353

singlematch.exit353:                              ; preds = %sw.bb1.i345, %matchbracketclass.exit.i314, %sw.default.i349
  %retval.0.i317 = phi i32 [ %conv7.i352, %sw.default.i349 ], [ %retval.0.i.i316, %matchbracketclass.exit.i314 ], [ %call.i348, %sw.bb1.i345 ]
  %tobool.not.i236 = icmp eq i32 %retval.0.i317, 0
  br i1 %tobool.not.i236, label %while.end.i221, label %while.body.i237

while.body.i237:                                  ; preds = %land.rhs.i233, %singlematch.exit353
  %inc.i238 = add nuw i64 %i.0.i217520, 1
  %add.ptr.i218 = getelementptr inbounds i8, ptr %add.ptr83, i64 %inc.i238
  %exitcond.not = icmp eq i64 %inc.i238, %73
  br i1 %exitcond.not, label %while.end.i221, label %land.rhs.i233, !llvm.loop !158

while.end.i221:                                   ; preds = %while.body.i237, %singlematch.exit353
  %i.0.i217.lcssa = phi i64 [ %73, %while.body.i237 ], [ %i.0.i217520, %singlematch.exit353 ]
  %cmp3.i224524 = icmp sgt i64 %i.0.i217.lcssa, -1
  br i1 %cmp3.i224524, label %while.body5.i226.lr.ph, label %return

while.body5.i226.lr.ph:                           ; preds = %cond.true95, %while.end.i221
  %i.0.i217.lcssa636 = phi i64 [ %i.0.i217.lcssa, %while.end.i221 ], [ 0, %cond.true95 ]
  %add.ptr7.i228 = getelementptr inbounds i8, ptr %retval.0.i179, i64 1
  br label %while.body5.i226

while.cond2.i222:                                 ; preds = %while.body5.i226
  %dec.i232 = add nsw i64 %i.1.i223525, -1
  %cmp3.i224 = icmp sgt i64 %i.1.i223525, 0
  br i1 %cmp3.i224, label %while.body5.i226, label %return, !llvm.loop !159

while.body5.i226:                                 ; preds = %while.body5.i226.lr.ph, %while.cond2.i222
  %i.1.i223525 = phi i64 [ %i.0.i217.lcssa636, %while.body5.i226.lr.ph ], [ %dec.i232, %while.cond2.i222 ]
  %add.ptr6.i227 = getelementptr inbounds i8, ptr %add.ptr83, i64 %i.1.i223525
  %call8.i229 = tail call fastcc ptr @match(ptr noundef %ms, ptr noundef nonnull %add.ptr6.i227, ptr noundef nonnull %add.ptr7.i228)
  %tobool9.not.i230 = icmp eq ptr %call8.i229, null
  br i1 %tobool9.not.i230, label %while.cond2.i222, label %return

if.else.i244:                                     ; preds = %if.else.i244.lr.ph, %if.then3.i
  %s.addr.0.i516 = phi ptr [ %s.addr.0.ph, %if.else.i244.lr.ph ], [ %incdec.ptr.i249, %if.then3.i ]
  %80 = load ptr, ptr %src_end74, align 8
  %cmp1.i = icmp ult ptr %s.addr.0.i516, %80
  br i1 %cmp1.i, label %land.lhs.true.i246, label %return

land.lhs.true.i246:                               ; preds = %if.else.i244
  %81 = load i8, ptr %s.addr.0.i516, align 1
  %conv.i247 = zext i8 %81 to i32
  %82 = load i8, ptr %p.addr.0, align 1
  %conv.i354 = sext i8 %82 to i32
  switch i32 %conv.i354, label %sw.default.i398 [
    i32 46, label %if.then3.i
    i32 37, label %sw.bb1.i394
    i32 91, label %sw.bb3.i355
  ]

sw.bb1.i394:                                      ; preds = %land.lhs.true.i246
  %83 = load i8, ptr %incdec.ptr.i161412, align 1
  %conv2.i396 = zext i8 %83 to i32
  %call.i397 = tail call fastcc i32 @match_class(i32 noundef %conv.i247, i32 noundef %conv2.i396), !range !156
  br label %singlematch.exit402

sw.bb3.i355:                                      ; preds = %land.lhs.true.i246
  %84 = load i8, ptr %incdec.ptr.i161412, align 1
  %cmp.i.i358 = icmp eq i8 %84, 94
  %spec.select.i.i359 = select i1 %cmp.i.i358, ptr %incdec.ptr.i161412, ptr %p.addr.0
  %not.cmp.i.i360 = xor i1 %cmp.i.i358, true
  %incdec.ptr220.i.i361 = getelementptr inbounds i8, ptr %spec.select.i.i359, i64 1
  %cmp321.i.i362 = icmp ult ptr %incdec.ptr220.i.i361, %add.ptr4.i356
  br i1 %cmp321.i.i362, label %while.body.i.i367, label %matchbracketclass.exit.i363

while.body.i.i367:                                ; preds = %sw.bb3.i355, %if.end39.i.i377
  %incdec.ptr223.i.i368 = phi ptr [ %incdec.ptr2.i.i379, %if.end39.i.i377 ], [ %incdec.ptr220.i.i361, %sw.bb3.i355 ]
  %p.addr.122.i.i369 = phi ptr [ %p.addr.2.i.i378, %if.end39.i.i377 ], [ %spec.select.i.i359, %sw.bb3.i355 ]
  %85 = load i8, ptr %incdec.ptr223.i.i368, align 1
  %cmp6.i.i370 = icmp eq i8 %85, 37
  %incdec.ptr9.i.i371 = getelementptr inbounds i8, ptr %p.addr.122.i.i369, i64 2
  %86 = load i8, ptr %incdec.ptr9.i.i371, align 1
  br i1 %cmp6.i.i370, label %if.then8.i.i390, label %if.else.i.i372

if.then8.i.i390:                                  ; preds = %while.body.i.i367
  %conv10.i.i391 = zext i8 %86 to i32
  %call.i.i392 = tail call fastcc i32 @match_class(i32 noundef %conv.i247, i32 noundef %conv10.i.i391), !range !156
  %tobool.not.i.i393 = icmp eq i32 %call.i.i392, 0
  br i1 %tobool.not.i.i393, label %if.end39.i.i377, label %matchbracketclass.exit.i363

if.else.i.i372:                                   ; preds = %while.body.i.i367
  %cmp15.i.i373 = icmp eq i8 %86, 45
  br i1 %cmp15.i.i373, label %land.lhs.true.i.i381, label %if.else32.i.i374

land.lhs.true.i.i381:                             ; preds = %if.else.i.i372
  %add.ptr17.i.i382 = getelementptr inbounds i8, ptr %p.addr.122.i.i369, i64 3
  %cmp18.i.i383 = icmp ult ptr %add.ptr17.i.i382, %add.ptr4.i356
  br i1 %cmp18.i.i383, label %if.then20.i.i384, label %if.else32.i.i374

if.then20.i.i384:                                 ; preds = %land.lhs.true.i.i381
  %cmp24.not.i.i386 = icmp ugt i8 %85, %81
  br i1 %cmp24.not.i.i386, label %if.end39.i.i377, label %land.lhs.true26.i.i387

land.lhs.true26.i.i387:                           ; preds = %if.then20.i.i384
  %87 = load i8, ptr %add.ptr17.i.i382, align 1
  %cmp28.not.i.i389 = icmp ult i8 %87, %81
  br i1 %cmp28.not.i.i389, label %if.end39.i.i377, label %matchbracketclass.exit.i363

if.else32.i.i374:                                 ; preds = %land.lhs.true.i.i381, %if.else.i.i372
  %cmp34.i.i376 = icmp eq i8 %85, %81
  br i1 %cmp34.i.i376, label %matchbracketclass.exit.i363, label %if.end39.i.i377

if.end39.i.i377:                                  ; preds = %if.else32.i.i374, %land.lhs.true26.i.i387, %if.then20.i.i384, %if.then8.i.i390
  %p.addr.2.i.i378 = phi ptr [ %incdec.ptr9.i.i371, %if.then8.i.i390 ], [ %add.ptr17.i.i382, %land.lhs.true26.i.i387 ], [ %add.ptr17.i.i382, %if.then20.i.i384 ], [ %incdec.ptr223.i.i368, %if.else32.i.i374 ]
  %incdec.ptr2.i.i379 = getelementptr inbounds i8, ptr %p.addr.2.i.i378, i64 1
  %cmp3.i.i380 = icmp ult ptr %incdec.ptr2.i.i379, %add.ptr4.i356
  br i1 %cmp3.i.i380, label %while.body.i.i367, label %matchbracketclass.exit.i363, !llvm.loop !157

matchbracketclass.exit.i363:                      ; preds = %if.end39.i.i377, %if.else32.i.i374, %land.lhs.true26.i.i387, %if.then8.i.i390, %sw.bb3.i355
  %retval.0.in.i.i364 = phi i1 [ %cmp.i.i358, %sw.bb3.i355 ], [ %cmp.i.i358, %if.end39.i.i377 ], [ %not.cmp.i.i360, %if.else32.i.i374 ], [ %not.cmp.i.i360, %land.lhs.true26.i.i387 ], [ %not.cmp.i.i360, %if.then8.i.i390 ]
  %retval.0.i.i365 = zext i1 %retval.0.in.i.i364 to i32
  br label %singlematch.exit402

sw.default.i398:                                  ; preds = %land.lhs.true.i246
  %cmp.i400 = icmp eq i8 %82, %81
  %conv7.i401 = zext i1 %cmp.i400 to i32
  br label %singlematch.exit402

singlematch.exit402:                              ; preds = %sw.bb1.i394, %matchbracketclass.exit.i363, %sw.default.i398
  %retval.0.i366 = phi i32 [ %conv7.i401, %sw.default.i398 ], [ %retval.0.i.i365, %matchbracketclass.exit.i363 ], [ %call.i397, %sw.bb1.i394 ]
  %tobool.not.i248 = icmp eq i32 %retval.0.i366, 0
  br i1 %tobool.not.i248, label %return, label %if.then3.i

if.then3.i:                                       ; preds = %land.lhs.true.i246, %singlematch.exit402
  %incdec.ptr.i249 = getelementptr inbounds i8, ptr %s.addr.0.i516, i64 1
  %call.i241 = tail call fastcc ptr @match(ptr noundef %ms, ptr noundef nonnull %incdec.ptr.i249, ptr noundef nonnull %add.ptr.i240)
  %cmp.not.i242 = icmp eq ptr %call.i241, null
  br i1 %cmp.not.i242, label %if.else.i244, label %return

sw.default103:                                    ; preds = %land.end
  br i1 %63, label %init.outer.backedge, label %return

init.outer.backedge:                              ; preds = %sw.default103, %if.end54, %if.end
  %p.addr.0.ph.be = phi ptr [ %add.ptr18, %if.end ], [ %add.ptr55, %if.end54 ], [ %retval.0.i179, %sw.default103 ]
  %s.addr.0.ph.be = phi ptr [ %add.ptr22.i, %if.end ], [ %add.ptr.i158, %if.end54 ], [ %add.ptr83, %sw.default103 ]
  br label %init.outer

return:                                           ; preds = %land.lhs.true.i155, %check_capture.exit.i, %if.else.i, %if.end.i89, %sw.default103, %land.lhs.true, %init, %matchbracketclass.exit, %matchbracketclass.exit150, %cond.end, %if.end30.i, %if.then3.i, %if.else.i244, %singlematch.exit402, %while.cond2.i222, %while.body5.i226, %while.cond2.i, %while.body5.i, %for.cond.i.preheader, %while.end.i221, %while.end.i, %if.then.i87, %capture_to_close.exit, %if.then9.i75, %if.end.i68, %if.then9.i, %if.end.i, %sw.bb93, %if.then63
  %retval.0 = phi ptr [ %cond69, %if.then63 ], [ null, %sw.bb93 ], [ %call6.i, %if.end.i ], [ null, %if.then9.i ], [ %call6.i73, %if.end.i68 ], [ null, %if.then9.i75 ], [ %call4.i, %capture_to_close.exit ], [ null, %if.then.i87 ], [ null, %while.end.i ], [ null, %while.end.i221 ], [ %call.i241514, %for.cond.i.preheader ], [ null, %while.cond2.i ], [ %call8.i, %while.body5.i ], [ null, %while.cond2.i222 ], [ %call8.i229, %while.body5.i226 ], [ %call.i241, %if.then3.i ], [ null, %if.else.i244 ], [ null, %singlematch.exit402 ], [ null, %if.end30.i ], [ null, %cond.end ], [ null, %matchbracketclass.exit150 ], [ null, %matchbracketclass.exit ], [ %s.addr.0.ph, %init ], [ %call85, %land.lhs.true ], [ null, %sw.default103 ], [ null, %if.end.i89 ], [ null, %if.else.i ], [ null, %check_capture.exit.i ], [ null, %land.lhs.true.i155 ]
  ret ptr %retval.0
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @push_captures(ptr nocapture noundef readonly %ms, ptr noundef %s, ptr noundef %e) unnamed_addr #0 {
entry:
  %level = getelementptr inbounds %struct.MatchState, ptr %ms, i64 0, i32 3
  %0 = load i32, ptr %level, align 8
  %cmp = icmp eq i32 %0, 0
  %tobool = icmp ne ptr %s, null
  %or.cond = and i1 %tobool, %cmp
  %spec.select = select i1 %or.cond, i32 1, i32 %0
  %L = getelementptr inbounds %struct.MatchState, ptr %ms, i64 0, i32 2
  %1 = load ptr, ptr %L, align 8
  %cmp.i.i = icmp sgt i32 %spec.select, 8000
  br i1 %cmp.i.i, label %if.then.i, label %lor.lhs.false.i.i

lor.lhs.false.i.i:                                ; preds = %entry
  %top.i.i = getelementptr inbounds %struct.lua_State, ptr %1, i64 0, i32 4
  %2 = load ptr, ptr %top.i.i, align 8
  %base.i.i = getelementptr inbounds %struct.lua_State, ptr %1, i64 0, i32 5
  %3 = load ptr, ptr %base.i.i, align 8
  %sub.ptr.lhs.cast.i.i = ptrtoint ptr %2 to i64
  %sub.ptr.rhs.cast.i.i = ptrtoint ptr %3 to i64
  %sub.ptr.sub.i.i = sub i64 %sub.ptr.lhs.cast.i.i, %sub.ptr.rhs.cast.i.i
  %sub.ptr.div.i.i = ashr exact i64 %sub.ptr.sub.i.i, 4
  %conv.i.i = sext i32 %spec.select to i64
  %add.i.i = add nsw i64 %sub.ptr.div.i.i, %conv.i.i
  %cmp1.i.i = icmp sgt i64 %add.i.i, 8000
  br i1 %cmp1.i.i, label %if.then.i, label %if.else.i.i

if.else.i.i:                                      ; preds = %lor.lhs.false.i.i
  %cmp3.i.i = icmp sgt i32 %spec.select, 0
  br i1 %cmp3.i.i, label %if.then5.i.i, label %for.end

if.then5.i.i:                                     ; preds = %if.else.i.i
  %stack_last.i.i = getelementptr inbounds %struct.lua_State, ptr %1, i64 0, i32 9
  %4 = load ptr, ptr %stack_last.i.i, align 8
  %sub.ptr.lhs.cast7.i.i = ptrtoint ptr %4 to i64
  %sub.ptr.sub9.i.i = sub i64 %sub.ptr.lhs.cast7.i.i, %sub.ptr.lhs.cast.i.i
  %mul.i.i = shl nuw nsw i32 %spec.select, 4
  %conv10.i.i = zext nneg i32 %mul.i.i to i64
  %cmp11.not.i.i = icmp sgt i64 %sub.ptr.sub9.i.i, %conv10.i.i
  br i1 %cmp11.not.i.i, label %if.end.i.i, label %if.then13.i.i

if.then13.i.i:                                    ; preds = %if.then5.i.i
  %stacksize.i.i.i = getelementptr inbounds %struct.lua_State, ptr %1, i64 0, i32 13
  %5 = load i32, ptr %stacksize.i.i.i, align 8
  %cmp.not.i.i.i = icmp slt i32 %5, %spec.select
  %add.i.i.i = add nsw i32 %5, %spec.select
  %mul.i.i.i = shl nsw i32 %5, 1
  %add.sink.i.i.i = select i1 %cmp.not.i.i.i, i32 %add.i.i.i, i32 %mul.i.i.i
  tail call fastcc void @luaD_reallocstack(ptr noundef nonnull %1, i32 noundef %add.sink.i.i.i)
  %.pre.i.i = load ptr, ptr %top.i.i, align 8
  br label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then13.i.i, %if.then5.i.i
  %6 = phi ptr [ %2, %if.then5.i.i ], [ %.pre.i.i, %if.then13.i.i ]
  %ci.i.i = getelementptr inbounds %struct.lua_State, ptr %1, i64 0, i32 7
  %7 = load ptr, ptr %ci.i.i, align 8
  %top15.i.i = getelementptr inbounds %struct.CallInfo, ptr %7, i64 0, i32 2
  %8 = load ptr, ptr %top15.i.i, align 8
  %add.ptr.i.i = getelementptr inbounds %struct.lua_TValue, ptr %6, i64 %conv.i.i
  %cmp17.i.i = icmp ult ptr %8, %add.ptr.i.i
  br i1 %cmp17.i.i, label %if.then19.i.i, label %for.body.preheader

if.then19.i.i:                                    ; preds = %if.end.i.i
  store ptr %add.ptr.i.i, ptr %top15.i.i, align 8
  br label %for.body.preheader

for.body.preheader:                               ; preds = %if.end.i.i, %if.then19.i.i
  br label %for.body

if.then.i:                                        ; preds = %lor.lhs.false.i.i, %entry
  tail call void (ptr, ptr, ...) @luaL_error(ptr noundef %1, ptr noundef nonnull @.str.193, ptr noundef nonnull @.str.239)
  unreachable

for.body:                                         ; preds = %for.body.preheader, %for.body
  %i.010 = phi i32 [ %inc, %for.body ], [ 0, %for.body.preheader ]
  tail call fastcc void @push_onecapture(ptr noundef %ms, i32 noundef %i.010, ptr noundef %s, ptr noundef %e)
  %inc = add nuw nsw i32 %i.010, 1
  %exitcond.not = icmp eq i32 %inc, %spec.select
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !160

for.end:                                          ; preds = %for.body, %if.else.i.i
  ret i32 %spec.select
}

; Function Attrs: mustprogress nofree nounwind willreturn memory(argmem: read)
declare ptr @memchr(ptr noundef, i32 noundef, i64 noundef) local_unnamed_addr #11

; Function Attrs: mustprogress nofree nounwind willreturn memory(read) uwtable
define internal fastcc i32 @match_class(i32 noundef %c, i32 noundef %cl) unnamed_addr #26 {
entry:
  %call = tail call i32 @tolower(i32 noundef %cl) #34
  switch i32 %call, label %sw.default [
    i32 97, label %sw.bb
    i32 99, label %sw.bb2
    i32 100, label %sw.bb8
    i32 108, label %sw.bb14
    i32 112, label %sw.bb20
    i32 115, label %sw.bb26
    i32 117, label %sw.bb32
    i32 119, label %sw.bb38
    i32 120, label %sw.bb44
    i32 122, label %sw.bb50
  ]

sw.bb:                                            ; preds = %entry
  %call1 = tail call ptr @__ctype_b_loc() #39
  %0 = load ptr, ptr %call1, align 8
  %idxprom = zext nneg i32 %c to i64
  %arrayidx = getelementptr inbounds i16, ptr %0, i64 %idxprom
  %1 = load i16, ptr %arrayidx, align 2
  %2 = and i16 %1, 1024
  %and = zext nneg i16 %2 to i32
  br label %sw.epilog

sw.bb2:                                           ; preds = %entry
  %call3 = tail call ptr @__ctype_b_loc() #39
  %3 = load ptr, ptr %call3, align 8
  %idxprom4 = zext nneg i32 %c to i64
  %arrayidx5 = getelementptr inbounds i16, ptr %3, i64 %idxprom4
  %4 = load i16, ptr %arrayidx5, align 2
  %5 = and i16 %4, 2
  %and7 = zext nneg i16 %5 to i32
  br label %sw.epilog

sw.bb8:                                           ; preds = %entry
  %call9 = tail call ptr @__ctype_b_loc() #39
  %6 = load ptr, ptr %call9, align 8
  %idxprom10 = zext nneg i32 %c to i64
  %arrayidx11 = getelementptr inbounds i16, ptr %6, i64 %idxprom10
  %7 = load i16, ptr %arrayidx11, align 2
  %8 = and i16 %7, 2048
  %and13 = zext nneg i16 %8 to i32
  br label %sw.epilog

sw.bb14:                                          ; preds = %entry
  %call15 = tail call ptr @__ctype_b_loc() #39
  %9 = load ptr, ptr %call15, align 8
  %idxprom16 = zext nneg i32 %c to i64
  %arrayidx17 = getelementptr inbounds i16, ptr %9, i64 %idxprom16
  %10 = load i16, ptr %arrayidx17, align 2
  %11 = and i16 %10, 512
  %and19 = zext nneg i16 %11 to i32
  br label %sw.epilog

sw.bb20:                                          ; preds = %entry
  %call21 = tail call ptr @__ctype_b_loc() #39
  %12 = load ptr, ptr %call21, align 8
  %idxprom22 = zext nneg i32 %c to i64
  %arrayidx23 = getelementptr inbounds i16, ptr %12, i64 %idxprom22
  %13 = load i16, ptr %arrayidx23, align 2
  %14 = and i16 %13, 4
  %and25 = zext nneg i16 %14 to i32
  br label %sw.epilog

sw.bb26:                                          ; preds = %entry
  %call27 = tail call ptr @__ctype_b_loc() #39
  %15 = load ptr, ptr %call27, align 8
  %idxprom28 = zext nneg i32 %c to i64
  %arrayidx29 = getelementptr inbounds i16, ptr %15, i64 %idxprom28
  %16 = load i16, ptr %arrayidx29, align 2
  %17 = and i16 %16, 8192
  %and31 = zext nneg i16 %17 to i32
  br label %sw.epilog

sw.bb32:                                          ; preds = %entry
  %call33 = tail call ptr @__ctype_b_loc() #39
  %18 = load ptr, ptr %call33, align 8
  %idxprom34 = zext nneg i32 %c to i64
  %arrayidx35 = getelementptr inbounds i16, ptr %18, i64 %idxprom34
  %19 = load i16, ptr %arrayidx35, align 2
  %20 = and i16 %19, 256
  %and37 = zext nneg i16 %20 to i32
  br label %sw.epilog

sw.bb38:                                          ; preds = %entry
  %call39 = tail call ptr @__ctype_b_loc() #39
  %21 = load ptr, ptr %call39, align 8
  %idxprom40 = zext nneg i32 %c to i64
  %arrayidx41 = getelementptr inbounds i16, ptr %21, i64 %idxprom40
  %22 = load i16, ptr %arrayidx41, align 2
  %23 = and i16 %22, 8
  %and43 = zext nneg i16 %23 to i32
  br label %sw.epilog

sw.bb44:                                          ; preds = %entry
  %call45 = tail call ptr @__ctype_b_loc() #39
  %24 = load ptr, ptr %call45, align 8
  %idxprom46 = zext nneg i32 %c to i64
  %arrayidx47 = getelementptr inbounds i16, ptr %24, i64 %idxprom46
  %25 = load i16, ptr %arrayidx47, align 2
  %26 = and i16 %25, 4096
  %and49 = zext nneg i16 %26 to i32
  br label %sw.epilog

sw.bb50:                                          ; preds = %entry
  %cmp = icmp eq i32 %c, 0
  %conv51 = zext i1 %cmp to i32
  %.pre = tail call ptr @__ctype_b_loc() #39
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %cmp52 = icmp eq i32 %cl, %c
  %conv53 = zext i1 %cmp52 to i32
  br label %return

sw.epilog:                                        ; preds = %sw.bb50, %sw.bb44, %sw.bb38, %sw.bb32, %sw.bb26, %sw.bb20, %sw.bb14, %sw.bb8, %sw.bb2, %sw.bb
  %call54.pre-phi = phi ptr [ %.pre, %sw.bb50 ], [ %call45, %sw.bb44 ], [ %call39, %sw.bb38 ], [ %call33, %sw.bb32 ], [ %call27, %sw.bb26 ], [ %call21, %sw.bb20 ], [ %call15, %sw.bb14 ], [ %call9, %sw.bb8 ], [ %call3, %sw.bb2 ], [ %call1, %sw.bb ]
  %res.0 = phi i32 [ %conv51, %sw.bb50 ], [ %and49, %sw.bb44 ], [ %and43, %sw.bb38 ], [ %and37, %sw.bb32 ], [ %and31, %sw.bb26 ], [ %and25, %sw.bb20 ], [ %and19, %sw.bb14 ], [ %and13, %sw.bb8 ], [ %and7, %sw.bb2 ], [ %and, %sw.bb ]
  %27 = load ptr, ptr %call54.pre-phi, align 8
  %idxprom55 = zext nneg i32 %cl to i64
  %arrayidx56 = getelementptr inbounds i16, ptr %27, i64 %idxprom55
  %28 = load i16, ptr %arrayidx56, align 2
  %29 = and i16 %28, 512
  %tobool.not = icmp eq i16 %29, 0
  %tobool59.not = icmp eq i32 %res.0, 0
  %lnot.ext = zext i1 %tobool59.not to i32
  %cond = select i1 %tobool.not, i32 %lnot.ext, i32 %res.0
  br label %return

return:                                           ; preds = %sw.epilog, %sw.default
  %retval.0 = phi i32 [ %conv53, %sw.default ], [ %cond, %sw.epilog ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree nounwind willreturn memory(read)
declare i32 @tolower(i32 noundef) local_unnamed_addr #15

; Function Attrs: nounwind uwtable
define internal fastcc void @push_onecapture(ptr nocapture noundef readonly %ms, i32 noundef %i, ptr noundef %s, ptr noundef %e) unnamed_addr #0 {
entry:
  %level = getelementptr inbounds %struct.MatchState, ptr %ms, i64 0, i32 3
  %0 = load i32, ptr %level, align 8
  %cmp.not = icmp sgt i32 %0, %i
  br i1 %cmp.not, label %if.else4, label %if.then

if.then:                                          ; preds = %entry
  %cmp1 = icmp eq i32 %i, 0
  %L = getelementptr inbounds %struct.MatchState, ptr %ms, i64 0, i32 2
  %1 = load ptr, ptr %L, align 8
  br i1 %cmp1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  %sub.ptr.lhs.cast = ptrtoint ptr %e to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %s to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %l_G.i = getelementptr inbounds %struct.lua_State, ptr %1, i64 0, i32 6
  %2 = load ptr, ptr %l_G.i, align 8
  %totalbytes.i = getelementptr inbounds %struct.global_State, ptr %2, i64 0, i32 14
  %3 = load i64, ptr %totalbytes.i, align 8
  %GCthreshold.i = getelementptr inbounds %struct.global_State, ptr %2, i64 0, i32 13
  %4 = load i64, ptr %GCthreshold.i, align 8
  %cmp.not.i = icmp ult i64 %3, %4
  br i1 %cmp.not.i, label %lua_pushlstring.exit, label %if.then.i

if.then.i:                                        ; preds = %if.then2
  %gcstepmul.i.i = getelementptr inbounds %struct.global_State, ptr %2, i64 0, i32 18
  %5 = load i32, ptr %gcstepmul.i.i, align 4
  %mul.i.i = mul i32 %5, 10
  %conv.i.i = zext i32 %mul.i.i to i64
  %cmp.i.i = icmp eq i32 %mul.i.i, 0
  %spec.store.select.i.i = select i1 %cmp.i.i, i64 9223372036854775806, i64 %conv.i.i
  %sub.i.i = sub i64 %3, %4
  %gcdept.i.i = getelementptr inbounds %struct.global_State, ptr %2, i64 0, i32 16
  %6 = load i64, ptr %gcdept.i.i, align 8
  %add.i.i = add i64 %sub.i.i, %6
  store i64 %add.i.i, ptr %gcdept.i.i, align 8
  %gcstate.i.i = getelementptr inbounds %struct.global_State, ptr %2, i64 0, i32 4
  br label %do.body.i.i

do.body.i.i:                                      ; preds = %do.body.i.i, %if.then.i
  %lim.0.i.i = phi i64 [ %spec.store.select.i.i, %if.then.i ], [ %sub2.i.i, %do.body.i.i ]
  %call.i.i = tail call fastcc i64 @singlestep(ptr noundef %1)
  %sub2.i.i = sub nsw i64 %lim.0.i.i, %call.i.i
  %7 = load i8, ptr %gcstate.i.i, align 1
  %cmp4.i.i = icmp ne i8 %7, 0
  %cmp8.i.i = icmp sgt i64 %sub2.i.i, 0
  %or.cond.i.i = select i1 %cmp4.i.i, i1 %cmp8.i.i, i1 false
  br i1 %or.cond.i.i, label %do.body.i.i, label %do.end.i.i, !llvm.loop !6

do.end.i.i:                                       ; preds = %do.body.i.i
  br i1 %cmp4.i.i, label %if.then14.i.i, label %if.else27.i.i

if.then14.i.i:                                    ; preds = %do.end.i.i
  %8 = load i64, ptr %gcdept.i.i, align 8
  %cmp16.i.i = icmp ult i64 %8, 1024
  br i1 %cmp16.i.i, label %if.then18.i.i, label %if.else.i.i

if.then18.i.i:                                    ; preds = %if.then14.i.i
  %9 = load i64, ptr %totalbytes.i, align 8
  %add20.i.i = add i64 %9, 1024
  br label %luaC_step.exit.i

if.else.i.i:                                      ; preds = %if.then14.i.i
  %sub23.i.i = add i64 %8, -1024
  store i64 %sub23.i.i, ptr %gcdept.i.i, align 8
  %10 = load i64, ptr %totalbytes.i, align 8
  br label %luaC_step.exit.i

if.else27.i.i:                                    ; preds = %do.end.i.i
  %estimate.i.i = getelementptr inbounds %struct.global_State, ptr %2, i64 0, i32 15
  %11 = load i64, ptr %estimate.i.i, align 8
  %div.i.i = udiv i64 %11, 100
  %gcpause.i.i = getelementptr inbounds %struct.global_State, ptr %2, i64 0, i32 17
  %12 = load i32, ptr %gcpause.i.i, align 8
  %conv28.i.i = sext i32 %12 to i64
  %mul29.i.i = mul i64 %div.i.i, %conv28.i.i
  br label %luaC_step.exit.i

luaC_step.exit.i:                                 ; preds = %if.else27.i.i, %if.else.i.i, %if.then18.i.i
  %add20.sink.i.i = phi i64 [ %add20.i.i, %if.then18.i.i ], [ %10, %if.else.i.i ], [ %mul29.i.i, %if.else27.i.i ]
  store i64 %add20.sink.i.i, ptr %GCthreshold.i, align 8
  br label %lua_pushlstring.exit

lua_pushlstring.exit:                             ; preds = %if.then2, %luaC_step.exit.i
  %top.i = getelementptr inbounds %struct.lua_State, ptr %1, i64 0, i32 4
  %13 = load ptr, ptr %top.i, align 8
  %call.i = tail call fastcc ptr @luaS_newlstr(ptr noundef %1, ptr noundef %s, i64 noundef %sub.ptr.sub)
  store ptr %call.i, ptr %13, align 8
  br label %if.end26

if.else:                                          ; preds = %if.then
  tail call void (ptr, ptr, ...) @luaL_error(ptr noundef %1, ptr noundef nonnull @.str.244)
  unreachable

if.else4:                                         ; preds = %entry
  %idxprom = sext i32 %i to i64
  %arrayidx = getelementptr inbounds %struct.MatchState, ptr %ms, i64 0, i32 4, i64 %idxprom
  %len = getelementptr inbounds %struct.MatchState, ptr %ms, i64 0, i32 4, i64 %idxprom, i32 1
  %14 = load i64, ptr %len, align 8
  %L20 = getelementptr inbounds %struct.MatchState, ptr %ms, i64 0, i32 2
  %15 = load ptr, ptr %L20, align 8
  switch i64 %14, label %if.else19 [
    i64 -1, label %if.then6
    i64 -2, label %if.then11
  ]

if.then6:                                         ; preds = %if.else4
  tail call void (ptr, ptr, ...) @luaL_error(ptr noundef %15, ptr noundef nonnull @.str.245)
  unreachable

if.then11:                                        ; preds = %if.else4
  %16 = load ptr, ptr %arrayidx, align 8
  %17 = load ptr, ptr %ms, align 8
  %sub.ptr.lhs.cast16 = ptrtoint ptr %16 to i64
  %sub.ptr.rhs.cast17 = ptrtoint ptr %17 to i64
  %sub.ptr.sub18 = add i64 %sub.ptr.lhs.cast16, 1
  %add = sub i64 %sub.ptr.sub18, %sub.ptr.rhs.cast17
  %top.i17 = getelementptr inbounds %struct.lua_State, ptr %15, i64 0, i32 4
  %18 = load ptr, ptr %top.i17, align 8
  %conv.i = sitofp i64 %add to double
  store double %conv.i, ptr %18, align 8
  br label %if.end26

if.else19:                                        ; preds = %if.else4
  %19 = load ptr, ptr %arrayidx, align 8
  %l_G.i20 = getelementptr inbounds %struct.lua_State, ptr %15, i64 0, i32 6
  %20 = load ptr, ptr %l_G.i20, align 8
  %totalbytes.i21 = getelementptr inbounds %struct.global_State, ptr %20, i64 0, i32 14
  %21 = load i64, ptr %totalbytes.i21, align 8
  %GCthreshold.i22 = getelementptr inbounds %struct.global_State, ptr %20, i64 0, i32 13
  %22 = load i64, ptr %GCthreshold.i22, align 8
  %cmp.not.i23 = icmp ult i64 %21, %22
  br i1 %cmp.not.i23, label %lua_pushlstring.exit60, label %if.then.i24

if.then.i24:                                      ; preds = %if.else19
  %gcstepmul.i.i25 = getelementptr inbounds %struct.global_State, ptr %20, i64 0, i32 18
  %23 = load i32, ptr %gcstepmul.i.i25, align 4
  %mul.i.i26 = mul i32 %23, 10
  %conv.i.i27 = zext i32 %mul.i.i26 to i64
  %cmp.i.i28 = icmp eq i32 %mul.i.i26, 0
  %spec.store.select.i.i29 = select i1 %cmp.i.i28, i64 9223372036854775806, i64 %conv.i.i27
  %sub.i.i30 = sub i64 %21, %22
  %gcdept.i.i31 = getelementptr inbounds %struct.global_State, ptr %20, i64 0, i32 16
  %24 = load i64, ptr %gcdept.i.i31, align 8
  %add.i.i32 = add i64 %sub.i.i30, %24
  store i64 %add.i.i32, ptr %gcdept.i.i31, align 8
  %gcstate.i.i33 = getelementptr inbounds %struct.global_State, ptr %20, i64 0, i32 4
  br label %do.body.i.i34

do.body.i.i34:                                    ; preds = %do.body.i.i34, %if.then.i24
  %lim.0.i.i35 = phi i64 [ %spec.store.select.i.i29, %if.then.i24 ], [ %sub2.i.i37, %do.body.i.i34 ]
  %call.i.i36 = tail call fastcc i64 @singlestep(ptr noundef %15)
  %sub2.i.i37 = sub nsw i64 %lim.0.i.i35, %call.i.i36
  %25 = load i8, ptr %gcstate.i.i33, align 1
  %cmp4.i.i38 = icmp ne i8 %25, 0
  %cmp8.i.i39 = icmp sgt i64 %sub2.i.i37, 0
  %or.cond.i.i40 = select i1 %cmp4.i.i38, i1 %cmp8.i.i39, i1 false
  br i1 %or.cond.i.i40, label %do.body.i.i34, label %do.end.i.i41, !llvm.loop !6

do.end.i.i41:                                     ; preds = %do.body.i.i34
  br i1 %cmp4.i.i38, label %if.then14.i.i54, label %if.else27.i.i42

if.then14.i.i54:                                  ; preds = %do.end.i.i41
  %26 = load i64, ptr %gcdept.i.i31, align 8
  %cmp16.i.i55 = icmp ult i64 %26, 1024
  br i1 %cmp16.i.i55, label %if.then18.i.i58, label %if.else.i.i56

if.then18.i.i58:                                  ; preds = %if.then14.i.i54
  %27 = load i64, ptr %totalbytes.i21, align 8
  %add20.i.i59 = add i64 %27, 1024
  br label %luaC_step.exit.i48

if.else.i.i56:                                    ; preds = %if.then14.i.i54
  %sub23.i.i57 = add i64 %26, -1024
  store i64 %sub23.i.i57, ptr %gcdept.i.i31, align 8
  %28 = load i64, ptr %totalbytes.i21, align 8
  br label %luaC_step.exit.i48

if.else27.i.i42:                                  ; preds = %do.end.i.i41
  %estimate.i.i43 = getelementptr inbounds %struct.global_State, ptr %20, i64 0, i32 15
  %29 = load i64, ptr %estimate.i.i43, align 8
  %div.i.i44 = udiv i64 %29, 100
  %gcpause.i.i45 = getelementptr inbounds %struct.global_State, ptr %20, i64 0, i32 17
  %30 = load i32, ptr %gcpause.i.i45, align 8
  %conv28.i.i46 = sext i32 %30 to i64
  %mul29.i.i47 = mul i64 %div.i.i44, %conv28.i.i46
  br label %luaC_step.exit.i48

luaC_step.exit.i48:                               ; preds = %if.else27.i.i42, %if.else.i.i56, %if.then18.i.i58
  %add20.sink.i.i49 = phi i64 [ %add20.i.i59, %if.then18.i.i58 ], [ %28, %if.else.i.i56 ], [ %mul29.i.i47, %if.else27.i.i42 ]
  store i64 %add20.sink.i.i49, ptr %GCthreshold.i22, align 8
  br label %lua_pushlstring.exit60

lua_pushlstring.exit60:                           ; preds = %if.else19, %luaC_step.exit.i48
  %top.i50 = getelementptr inbounds %struct.lua_State, ptr %15, i64 0, i32 4
  %31 = load ptr, ptr %top.i50, align 8
  %call.i51 = tail call fastcc ptr @luaS_newlstr(ptr noundef %15, ptr noundef %19, i64 noundef %14)
  store ptr %call.i51, ptr %31, align 8
  br label %if.end26

if.end26:                                         ; preds = %if.then11, %lua_pushlstring.exit60, %lua_pushlstring.exit
  %.sink63 = phi ptr [ %18, %if.then11 ], [ %31, %lua_pushlstring.exit60 ], [ %13, %lua_pushlstring.exit ]
  %.sink = phi i32 [ 3, %if.then11 ], [ 4, %lua_pushlstring.exit60 ], [ 4, %lua_pushlstring.exit ]
  %top.i17.sink62 = phi ptr [ %top.i17, %if.then11 ], [ %top.i50, %lua_pushlstring.exit60 ], [ %top.i, %lua_pushlstring.exit ]
  %tt.i18 = getelementptr inbounds %struct.lua_TValue, ptr %.sink63, i64 0, i32 1
  store i32 %.sink, ptr %tt.i18, align 8
  %32 = load ptr, ptr %top.i17.sink62, align 8
  %incdec.ptr.i19 = getelementptr inbounds %struct.lua_TValue, ptr %32, i64 1
  store ptr %incdec.ptr.i19, ptr %top.i17.sink62, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @gmatch_aux(ptr noundef %L) #0 {
entry:
  %ms = alloca %struct.MatchState, align 8
  %ls = alloca i64, align 8
  %call = call fastcc ptr @lua_tolstring(ptr noundef %L, i32 noundef -10003, ptr noundef nonnull %ls)
  %call1 = call fastcc ptr @lua_tolstring(ptr noundef %L, i32 noundef -10004, ptr noundef null)
  %L2 = getelementptr inbounds %struct.MatchState, ptr %ms, i64 0, i32 2
  store ptr %L, ptr %L2, align 8
  store ptr %call, ptr %ms, align 8
  %0 = load i64, ptr %ls, align 8
  %add.ptr = getelementptr inbounds i8, ptr %call, i64 %0
  %src_end = getelementptr inbounds %struct.MatchState, ptr %ms, i64 0, i32 1
  store ptr %add.ptr, ptr %src_end, align 8
  %call3 = call fastcc i64 @lua_tointeger(ptr noundef %L, i32 noundef -10005)
  %cmp.not18 = icmp sgt i64 %call3, %0
  br i1 %cmp.not18, label %return, label %for.body.lr.ph

for.body.lr.ph:                                   ; preds = %entry
  %add.ptr4 = getelementptr inbounds i8, ptr %call, i64 %call3
  %level = getelementptr inbounds %struct.MatchState, ptr %ms, i64 0, i32 3
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.inc
  %src.019 = phi ptr [ %add.ptr4, %for.body.lr.ph ], [ %incdec.ptr, %for.inc ]
  store i32 0, ptr %level, align 8
  %call6 = call fastcc ptr @match(ptr noundef nonnull %ms, ptr noundef %src.019, ptr noundef %call1)
  %cmp7.not = icmp eq ptr %call6, null
  br i1 %cmp7.not, label %for.inc, label %if.then

if.then:                                          ; preds = %for.body
  %sub.ptr.lhs.cast = ptrtoint ptr %call6 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %call to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp8 = icmp eq ptr %call6, %src.019
  %inc = zext i1 %cmp8 to i64
  %spec.select = add nsw i64 %sub.ptr.sub, %inc
  %top.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i, align 8
  %conv.i = sitofp i64 %spec.select to double
  store double %conv.i, ptr %1, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 0, i32 1
  store i32 3, ptr %tt.i, align 8
  %2 = load ptr, ptr %top.i, align 8
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %2, i64 1
  store ptr %incdec.ptr.i, ptr %top.i, align 8
  %ci17.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %3 = load ptr, ptr %ci17.i.i, align 8
  %func18.i.i = getelementptr inbounds %struct.CallInfo, ptr %3, i64 0, i32 1
  %4 = load ptr, ptr %func18.i.i, align 8
  %5 = load ptr, ptr %4, align 8
  %nupvalues.i.i = getelementptr inbounds %struct.CClosure, ptr %5, i64 0, i32 4
  %6 = load i8, ptr %nupvalues.i.i, align 1
  %cmp21.not.i.i = icmp ult i8 %6, 3
  %arrayidx.i.i = getelementptr inbounds %struct.CClosure, ptr %5, i64 0, i32 8, i64 2
  %cond.i.i = select i1 %cmp21.not.i.i, ptr @luaO_nilobject_, ptr %arrayidx.i.i
  %7 = load i64, ptr %2, align 8
  store i64 %7, ptr %cond.i.i, align 8
  %tt28.i = getelementptr %struct.lua_TValue, ptr %2, i64 0, i32 1
  %8 = load i32, ptr %tt28.i, align 8
  %tt29.i = getelementptr inbounds %struct.lua_TValue, ptr %cond.i.i, i64 0, i32 1
  store i32 %8, ptr %tt29.i, align 8
  %9 = load ptr, ptr %top.i, align 8
  %tt35.i = getelementptr %struct.lua_TValue, ptr %9, i64 -1, i32 1
  %10 = load i32, ptr %tt35.i, align 8
  %cmp36.i = icmp sgt i32 %10, 3
  br i1 %cmp36.i, label %land.lhs.true38.i, label %lua_replace.exit

land.lhs.true38.i:                                ; preds = %if.then
  %add.ptr34.i = getelementptr inbounds %struct.lua_TValue, ptr %9, i64 -1
  %11 = load ptr, ptr %add.ptr34.i, align 8
  %marked42.i = getelementptr inbounds %struct.GCheader, ptr %11, i64 0, i32 2
  %12 = load i8, ptr %marked42.i, align 1
  %13 = and i8 %12, 3
  %tobool45.not.i = icmp eq i8 %13, 0
  br i1 %tobool45.not.i, label %lua_replace.exit, label %land.lhs.true46.i

land.lhs.true46.i:                                ; preds = %land.lhs.true38.i
  %14 = load ptr, ptr %ci17.i.i, align 8
  %func48.i = getelementptr inbounds %struct.CallInfo, ptr %14, i64 0, i32 1
  %15 = load ptr, ptr %func48.i, align 8
  %16 = load ptr, ptr %15, align 8
  %marked50.i = getelementptr inbounds %struct.GCheader, ptr %16, i64 0, i32 2
  %17 = load i8, ptr %marked50.i, align 1
  %18 = and i8 %17, 4
  %tobool53.not.i = icmp eq i8 %18, 0
  br i1 %tobool53.not.i, label %lua_replace.exit, label %if.then54.i

if.then54.i:                                      ; preds = %land.lhs.true46.i
  %19 = getelementptr i8, ptr %L, i64 32
  %L.val.i = load ptr, ptr %19, align 8
  %gcstate.i28.i = getelementptr inbounds %struct.global_State, ptr %L.val.i, i64 0, i32 4
  %20 = load i8, ptr %gcstate.i28.i, align 1
  %cmp.i29.i = icmp eq i8 %20, 1
  br i1 %cmp.i29.i, label %if.then.i34.i, label %if.else.i30.i

if.then.i34.i:                                    ; preds = %if.then54.i
  call fastcc void @reallymarkobject(ptr noundef nonnull %L.val.i, ptr noundef nonnull %11)
  br label %lua_replace.exit

if.else.i30.i:                                    ; preds = %if.then54.i
  %21 = and i8 %17, -8
  %currentwhite.i32.i = getelementptr inbounds %struct.global_State, ptr %L.val.i, i64 0, i32 3
  %22 = load i8, ptr %currentwhite.i32.i, align 8
  %23 = and i8 %22, 3
  %or4.i33.i = or disjoint i8 %23, %21
  store i8 %or4.i33.i, ptr %marked50.i, align 1
  br label %lua_replace.exit

lua_replace.exit:                                 ; preds = %if.then, %land.lhs.true38.i, %land.lhs.true46.i, %if.then.i34.i, %if.else.i30.i
  %24 = load ptr, ptr %top.i, align 8
  %incdec.ptr.i16 = getelementptr inbounds %struct.lua_TValue, ptr %24, i64 -1
  store ptr %incdec.ptr.i16, ptr %top.i, align 8
  %call10 = call fastcc i32 @push_captures(ptr noundef nonnull %ms, ptr noundef %src.019, ptr noundef nonnull %call6)
  br label %return

for.inc:                                          ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i8, ptr %src.019, i64 1
  %25 = load ptr, ptr %src_end, align 8
  %cmp.not = icmp ugt ptr %incdec.ptr, %25
  br i1 %cmp.not, label %return, label %for.body, !llvm.loop !161

return:                                           ; preds = %for.inc, %entry, %lua_replace.exit
  %retval.0 = phi i32 [ %call10, %lua_replace.exit ], [ 0, %entry ], [ 0, %for.inc ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree nounwind willreturn memory(read)
declare i32 @toupper(i32 noundef) local_unnamed_addr #15

; Function Attrs: nounwind uwtable
define internal fastcc ptr @luaL_findtable(ptr noundef %L, i32 noundef %idx, ptr noundef %fname, i32 noundef %szhint) unnamed_addr #0 {
entry:
  %cmp.i.i = icmp sgt i32 %idx, 0
  br i1 %cmp.i.i, label %if.then.i.i, label %if.else3.i.i

if.then.i.i:                                      ; preds = %entry
  %base.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i, align 8
  %1 = zext nneg i32 %idx to i64
  %2 = getelementptr %struct.lua_TValue, ptr %0, i64 %1
  %add.ptr.i.i = getelementptr %struct.lua_TValue, ptr %2, i64 -1
  %top.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %3 = load ptr, ptr %top.i.i, align 8
  %cmp1.not.i.i = icmp ult ptr %add.ptr.i.i, %3
  %add.ptr.luaO_nilobject_.i.i = select i1 %cmp1.not.i.i, ptr %add.ptr.i.i, ptr @luaO_nilobject_
  br label %lua_pushvalue.exit

if.else3.i.i:                                     ; preds = %entry
  %cmp4.i.i = icmp sgt i32 %idx, -10000
  br i1 %cmp4.i.i, label %if.then5.i.i, label %if.else9.i.i

if.then5.i.i:                                     ; preds = %if.else3.i.i
  %top6.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %4 = load ptr, ptr %top6.i.i, align 8
  %idx.ext7.i.i = sext i32 %idx to i64
  %add.ptr8.i.i = getelementptr inbounds %struct.lua_TValue, ptr %4, i64 %idx.ext7.i.i
  br label %lua_pushvalue.exit

if.else9.i.i:                                     ; preds = %if.else3.i.i
  switch i32 %idx, label %sw.default.i.i [
    i32 -10000, label %sw.bb.i.i
    i32 -10001, label %sw.bb10.i.i
    i32 -10002, label %sw.bb15.i.i
  ]

sw.bb.i.i:                                        ; preds = %if.else9.i.i
  %l_G.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %5 = load ptr, ptr %l_G.i.i, align 8
  %l_registry.i.i = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 20
  br label %lua_pushvalue.exit

sw.bb10.i.i:                                      ; preds = %if.else9.i.i
  %ci.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %6 = load ptr, ptr %ci.i.i, align 8
  %func11.i.i = getelementptr inbounds %struct.CallInfo, ptr %6, i64 0, i32 1
  %7 = load ptr, ptr %func11.i.i, align 8
  %8 = load ptr, ptr %7, align 8
  %env.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23
  %env12.i.i = getelementptr inbounds %struct.CClosure, ptr %8, i64 0, i32 6
  %9 = load ptr, ptr %env12.i.i, align 8
  store ptr %9, ptr %env.i.i, align 8
  %tt.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23, i32 1
  store i32 5, ptr %tt.i.i, align 8
  br label %lua_pushvalue.exit

sw.bb15.i.i:                                      ; preds = %if.else9.i.i
  %l_gt.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 22
  br label %lua_pushvalue.exit

sw.default.i.i:                                   ; preds = %if.else9.i.i
  %ci17.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %10 = load ptr, ptr %ci17.i.i, align 8
  %func18.i.i = getelementptr inbounds %struct.CallInfo, ptr %10, i64 0, i32 1
  %11 = load ptr, ptr %func18.i.i, align 8
  %12 = load ptr, ptr %11, align 8
  %sub20.i.i = sub nuw nsw i32 -10002, %idx
  %nupvalues.i.i = getelementptr inbounds %struct.CClosure, ptr %12, i64 0, i32 4
  %13 = load i8, ptr %nupvalues.i.i, align 1
  %conv.i.i = zext i8 %13 to i32
  %cmp21.not.i.i = icmp ugt i32 %sub20.i.i, %conv.i.i
  %sub23.i.i = sub nuw nsw i32 -10003, %idx
  %idxprom.i.i = zext nneg i32 %sub23.i.i to i64
  %arrayidx.i.i = getelementptr inbounds %struct.CClosure, ptr %12, i64 0, i32 8, i64 %idxprom.i.i
  %cond.i.i = select i1 %cmp21.not.i.i, ptr @luaO_nilobject_, ptr %arrayidx.i.i
  br label %lua_pushvalue.exit

lua_pushvalue.exit:                               ; preds = %if.then.i.i, %if.then5.i.i, %sw.bb.i.i, %sw.bb10.i.i, %sw.bb15.i.i, %sw.default.i.i
  %retval.0.i.i = phi ptr [ %add.ptr8.i.i, %if.then5.i.i ], [ %cond.i.i, %sw.default.i.i ], [ %l_gt.i.i, %sw.bb15.i.i ], [ %env.i.i, %sw.bb10.i.i ], [ %l_registry.i.i, %sw.bb.i.i ], [ %add.ptr.luaO_nilobject_.i.i, %if.then.i.i ]
  %top.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %14 = load ptr, ptr %top.i, align 8
  %15 = load i64, ptr %retval.0.i.i, align 8
  store i64 %15, ptr %14, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i.i, i64 0, i32 1
  %16 = load i32, ptr %tt.i, align 8
  %tt2.i = getelementptr inbounds %struct.lua_TValue, ptr %14, i64 0, i32 1
  store i32 %16, ptr %tt2.i, align 8
  %17 = load ptr, ptr %top.i, align 8
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %17, i64 1
  store ptr %incdec.ptr.i, ptr %top.i, align 8
  %l_G.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  br label %do.body

do.body:                                          ; preds = %lua_remove.exit, %lua_pushvalue.exit
  %18 = phi ptr [ %incdec.ptr.i, %lua_pushvalue.exit ], [ %incdec.ptr4.i, %lua_remove.exit ]
  %fname.addr.0 = phi ptr [ %fname, %lua_pushvalue.exit ], [ %add.ptr16, %lua_remove.exit ]
  %call = tail call ptr @strchr(ptr noundef nonnull dereferenceable(1) %fname.addr.0, i32 noundef 46) #34
  %cmp = icmp eq ptr %call, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  %call1 = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %fname.addr.0) #34
  %add.ptr = getelementptr inbounds i8, ptr %fname.addr.0, i64 %call1
  br label %if.end

if.end:                                           ; preds = %if.then, %do.body
  %e.0 = phi ptr [ %add.ptr, %if.then ], [ %call, %do.body ]
  %sub.ptr.lhs.cast = ptrtoint ptr %e.0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %fname.addr.0 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %19 = load ptr, ptr %l_G.i, align 8
  %totalbytes.i = getelementptr inbounds %struct.global_State, ptr %19, i64 0, i32 14
  %20 = load i64, ptr %totalbytes.i, align 8
  %GCthreshold.i = getelementptr inbounds %struct.global_State, ptr %19, i64 0, i32 13
  %21 = load i64, ptr %GCthreshold.i, align 8
  %cmp.not.i = icmp ult i64 %20, %21
  br i1 %cmp.not.i, label %lua_pushlstring.exit, label %if.then.i

if.then.i:                                        ; preds = %if.end
  %gcstepmul.i.i = getelementptr inbounds %struct.global_State, ptr %19, i64 0, i32 18
  %22 = load i32, ptr %gcstepmul.i.i, align 4
  %mul.i.i = mul i32 %22, 10
  %conv.i.i24 = zext i32 %mul.i.i to i64
  %cmp.i.i25 = icmp eq i32 %mul.i.i, 0
  %spec.store.select.i.i = select i1 %cmp.i.i25, i64 9223372036854775806, i64 %conv.i.i24
  %sub.i.i = sub i64 %20, %21
  %gcdept.i.i = getelementptr inbounds %struct.global_State, ptr %19, i64 0, i32 16
  %23 = load i64, ptr %gcdept.i.i, align 8
  %add.i.i = add i64 %sub.i.i, %23
  store i64 %add.i.i, ptr %gcdept.i.i, align 8
  %gcstate.i.i = getelementptr inbounds %struct.global_State, ptr %19, i64 0, i32 4
  br label %do.body.i.i

do.body.i.i:                                      ; preds = %do.body.i.i, %if.then.i
  %lim.0.i.i = phi i64 [ %spec.store.select.i.i, %if.then.i ], [ %sub2.i.i, %do.body.i.i ]
  %call.i.i = tail call fastcc i64 @singlestep(ptr noundef %L)
  %sub2.i.i = sub nsw i64 %lim.0.i.i, %call.i.i
  %24 = load i8, ptr %gcstate.i.i, align 1
  %cmp4.i.i26 = icmp ne i8 %24, 0
  %cmp8.i.i = icmp sgt i64 %sub2.i.i, 0
  %or.cond.i.i = select i1 %cmp4.i.i26, i1 %cmp8.i.i, i1 false
  br i1 %or.cond.i.i, label %do.body.i.i, label %do.end.i.i, !llvm.loop !6

do.end.i.i:                                       ; preds = %do.body.i.i
  br i1 %cmp4.i.i26, label %if.then14.i.i, label %if.else27.i.i

if.then14.i.i:                                    ; preds = %do.end.i.i
  %25 = load i64, ptr %gcdept.i.i, align 8
  %cmp16.i.i = icmp ult i64 %25, 1024
  br i1 %cmp16.i.i, label %if.then18.i.i, label %if.else.i.i

if.then18.i.i:                                    ; preds = %if.then14.i.i
  %26 = load i64, ptr %totalbytes.i, align 8
  %add20.i.i = add i64 %26, 1024
  br label %luaC_step.exit.i

if.else.i.i:                                      ; preds = %if.then14.i.i
  %sub23.i.i30 = add i64 %25, -1024
  store i64 %sub23.i.i30, ptr %gcdept.i.i, align 8
  %27 = load i64, ptr %totalbytes.i, align 8
  br label %luaC_step.exit.i

if.else27.i.i:                                    ; preds = %do.end.i.i
  %estimate.i.i = getelementptr inbounds %struct.global_State, ptr %19, i64 0, i32 15
  %28 = load i64, ptr %estimate.i.i, align 8
  %div.i.i = udiv i64 %28, 100
  %gcpause.i.i = getelementptr inbounds %struct.global_State, ptr %19, i64 0, i32 17
  %29 = load i32, ptr %gcpause.i.i, align 8
  %conv28.i.i = sext i32 %29 to i64
  %mul29.i.i = mul i64 %div.i.i, %conv28.i.i
  br label %luaC_step.exit.i

luaC_step.exit.i:                                 ; preds = %if.else27.i.i, %if.else.i.i, %if.then18.i.i
  %add20.sink.i.i = phi i64 [ %add20.i.i, %if.then18.i.i ], [ %27, %if.else.i.i ], [ %mul29.i.i, %if.else27.i.i ]
  store i64 %add20.sink.i.i, ptr %GCthreshold.i, align 8
  %.pre = load ptr, ptr %top.i, align 8
  br label %lua_pushlstring.exit

lua_pushlstring.exit:                             ; preds = %if.end, %luaC_step.exit.i
  %30 = phi ptr [ %18, %if.end ], [ %.pre, %luaC_step.exit.i ]
  %call.i = tail call fastcc ptr @luaS_newlstr(ptr noundef nonnull %L, ptr noundef %fname.addr.0, i64 noundef %sub.ptr.sub)
  store ptr %call.i, ptr %30, align 8
  %tt.i28 = getelementptr inbounds %struct.lua_TValue, ptr %30, i64 0, i32 1
  store i32 4, ptr %tt.i28, align 8
  %31 = load ptr, ptr %top.i, align 8
  %incdec.ptr.i29 = getelementptr inbounds %struct.lua_TValue, ptr %31, i64 1
  store ptr %incdec.ptr.i29, ptr %top.i, align 8
  %add.ptr8.i.i34 = getelementptr inbounds %struct.lua_TValue, ptr %31, i64 -1
  %32 = load ptr, ptr %add.ptr8.i.i34, align 8
  %call1.i = tail call fastcc ptr @luaH_get(ptr noundef %32, ptr noundef nonnull %31)
  %33 = load i64, ptr %call1.i, align 8
  store i64 %33, ptr %31, align 8
  %tt.i37 = getelementptr inbounds %struct.lua_TValue, ptr %call1.i, i64 0, i32 1
  %34 = load i32, ptr %tt.i37, align 8
  %tt6.i = getelementptr %struct.lua_TValue, ptr %31, i64 0, i32 1
  store i32 %34, ptr %tt6.i, align 8
  %35 = load ptr, ptr %top.i, align 8
  %add.ptr8.i.i41 = getelementptr %struct.lua_TValue, ptr %35, i64 -1
  %cmp.i = icmp eq ptr %add.ptr8.i.i41, @luaO_nilobject_
  br i1 %cmp.i, label %if.then13, label %lua_type.exit

lua_type.exit:                                    ; preds = %lua_pushlstring.exit
  %tt.i43 = getelementptr %struct.lua_TValue, ptr %35, i64 -1, i32 1
  %36 = load i32, ptr %tt.i43, align 8
  switch i32 %36, label %if.then13 [
    i32 0, label %if.then4
    i32 5, label %if.end15
  ]

if.then4:                                         ; preds = %lua_type.exit
  store ptr %add.ptr8.i.i41, ptr %top.i, align 8
  %37 = load i8, ptr %e.0, align 1
  %cmp5 = icmp eq i8 %37, 46
  %cond = select i1 %cmp5, i32 1, i32 %szhint
  %38 = load ptr, ptr %l_G.i, align 8
  %totalbytes.i46 = getelementptr inbounds %struct.global_State, ptr %38, i64 0, i32 14
  %39 = load i64, ptr %totalbytes.i46, align 8
  %GCthreshold.i47 = getelementptr inbounds %struct.global_State, ptr %38, i64 0, i32 13
  %40 = load i64, ptr %GCthreshold.i47, align 8
  %cmp.not.i48 = icmp ult i64 %39, %40
  br i1 %cmp.not.i48, label %lua_createtable.exit, label %if.then.i49

if.then.i49:                                      ; preds = %if.then4
  %gcstepmul.i.i50 = getelementptr inbounds %struct.global_State, ptr %38, i64 0, i32 18
  %41 = load i32, ptr %gcstepmul.i.i50, align 4
  %mul.i.i51 = mul i32 %41, 10
  %conv.i.i52 = zext i32 %mul.i.i51 to i64
  %cmp.i.i53 = icmp eq i32 %mul.i.i51, 0
  %spec.store.select.i.i54 = select i1 %cmp.i.i53, i64 9223372036854775806, i64 %conv.i.i52
  %sub.i.i55 = sub i64 %39, %40
  %gcdept.i.i56 = getelementptr inbounds %struct.global_State, ptr %38, i64 0, i32 16
  %42 = load i64, ptr %gcdept.i.i56, align 8
  %add.i.i57 = add i64 %sub.i.i55, %42
  store i64 %add.i.i57, ptr %gcdept.i.i56, align 8
  %gcstate.i.i58 = getelementptr inbounds %struct.global_State, ptr %38, i64 0, i32 4
  br label %do.body.i.i59

do.body.i.i59:                                    ; preds = %do.body.i.i59, %if.then.i49
  %lim.0.i.i60 = phi i64 [ %spec.store.select.i.i54, %if.then.i49 ], [ %sub2.i.i62, %do.body.i.i59 ]
  %call.i.i61 = tail call fastcc i64 @singlestep(ptr noundef %L)
  %sub2.i.i62 = sub nsw i64 %lim.0.i.i60, %call.i.i61
  %43 = load i8, ptr %gcstate.i.i58, align 1
  %cmp4.i.i63 = icmp ne i8 %43, 0
  %cmp8.i.i64 = icmp sgt i64 %sub2.i.i62, 0
  %or.cond.i.i65 = select i1 %cmp4.i.i63, i1 %cmp8.i.i64, i1 false
  br i1 %or.cond.i.i65, label %do.body.i.i59, label %do.end.i.i66, !llvm.loop !6

do.end.i.i66:                                     ; preds = %do.body.i.i59
  br i1 %cmp4.i.i63, label %if.then14.i.i79, label %if.else27.i.i67

if.then14.i.i79:                                  ; preds = %do.end.i.i66
  %44 = load i64, ptr %gcdept.i.i56, align 8
  %cmp16.i.i80 = icmp ult i64 %44, 1024
  br i1 %cmp16.i.i80, label %if.then18.i.i83, label %if.else.i.i81

if.then18.i.i83:                                  ; preds = %if.then14.i.i79
  %45 = load i64, ptr %totalbytes.i46, align 8
  %add20.i.i84 = add i64 %45, 1024
  br label %luaC_step.exit.i73

if.else.i.i81:                                    ; preds = %if.then14.i.i79
  %sub23.i.i82 = add i64 %44, -1024
  store i64 %sub23.i.i82, ptr %gcdept.i.i56, align 8
  %46 = load i64, ptr %totalbytes.i46, align 8
  br label %luaC_step.exit.i73

if.else27.i.i67:                                  ; preds = %do.end.i.i66
  %estimate.i.i68 = getelementptr inbounds %struct.global_State, ptr %38, i64 0, i32 15
  %47 = load i64, ptr %estimate.i.i68, align 8
  %div.i.i69 = udiv i64 %47, 100
  %gcpause.i.i70 = getelementptr inbounds %struct.global_State, ptr %38, i64 0, i32 17
  %48 = load i32, ptr %gcpause.i.i70, align 8
  %conv28.i.i71 = sext i32 %48 to i64
  %mul29.i.i72 = mul i64 %div.i.i69, %conv28.i.i71
  br label %luaC_step.exit.i73

luaC_step.exit.i73:                               ; preds = %if.else27.i.i67, %if.else.i.i81, %if.then18.i.i83
  %add20.sink.i.i74 = phi i64 [ %add20.i.i84, %if.then18.i.i83 ], [ %46, %if.else.i.i81 ], [ %mul29.i.i72, %if.else27.i.i67 ]
  store i64 %add20.sink.i.i74, ptr %GCthreshold.i47, align 8
  %.pre172 = load ptr, ptr %top.i, align 8
  br label %lua_createtable.exit

lua_createtable.exit:                             ; preds = %if.then4, %luaC_step.exit.i73
  %49 = phi ptr [ %add.ptr8.i.i41, %if.then4 ], [ %.pre172, %luaC_step.exit.i73 ]
  %call.i76 = tail call fastcc ptr @luaH_new(ptr noundef nonnull %L, i32 noundef 0, i32 noundef %cond)
  store ptr %call.i76, ptr %49, align 8
  %tt.i77 = getelementptr inbounds %struct.lua_TValue, ptr %49, i64 0, i32 1
  store i32 5, ptr %tt.i77, align 8
  %50 = load ptr, ptr %top.i, align 8
  %incdec.ptr.i78 = getelementptr inbounds %struct.lua_TValue, ptr %50, i64 1
  store ptr %incdec.ptr.i78, ptr %top.i, align 8
  %51 = load ptr, ptr %l_G.i, align 8
  %totalbytes.i86 = getelementptr inbounds %struct.global_State, ptr %51, i64 0, i32 14
  %52 = load i64, ptr %totalbytes.i86, align 8
  %GCthreshold.i87 = getelementptr inbounds %struct.global_State, ptr %51, i64 0, i32 13
  %53 = load i64, ptr %GCthreshold.i87, align 8
  %cmp.not.i88 = icmp ult i64 %52, %53
  br i1 %cmp.not.i88, label %lua_pushlstring.exit125, label %if.then.i89

if.then.i89:                                      ; preds = %lua_createtable.exit
  %gcstepmul.i.i90 = getelementptr inbounds %struct.global_State, ptr %51, i64 0, i32 18
  %54 = load i32, ptr %gcstepmul.i.i90, align 4
  %mul.i.i91 = mul i32 %54, 10
  %conv.i.i92 = zext i32 %mul.i.i91 to i64
  %cmp.i.i93 = icmp eq i32 %mul.i.i91, 0
  %spec.store.select.i.i94 = select i1 %cmp.i.i93, i64 9223372036854775806, i64 %conv.i.i92
  %sub.i.i95 = sub i64 %52, %53
  %gcdept.i.i96 = getelementptr inbounds %struct.global_State, ptr %51, i64 0, i32 16
  %55 = load i64, ptr %gcdept.i.i96, align 8
  %add.i.i97 = add i64 %sub.i.i95, %55
  store i64 %add.i.i97, ptr %gcdept.i.i96, align 8
  %gcstate.i.i98 = getelementptr inbounds %struct.global_State, ptr %51, i64 0, i32 4
  br label %do.body.i.i99

do.body.i.i99:                                    ; preds = %do.body.i.i99, %if.then.i89
  %lim.0.i.i100 = phi i64 [ %spec.store.select.i.i94, %if.then.i89 ], [ %sub2.i.i102, %do.body.i.i99 ]
  %call.i.i101 = tail call fastcc i64 @singlestep(ptr noundef %L)
  %sub2.i.i102 = sub nsw i64 %lim.0.i.i100, %call.i.i101
  %56 = load i8, ptr %gcstate.i.i98, align 1
  %cmp4.i.i103 = icmp ne i8 %56, 0
  %cmp8.i.i104 = icmp sgt i64 %sub2.i.i102, 0
  %or.cond.i.i105 = select i1 %cmp4.i.i103, i1 %cmp8.i.i104, i1 false
  br i1 %or.cond.i.i105, label %do.body.i.i99, label %do.end.i.i106, !llvm.loop !6

do.end.i.i106:                                    ; preds = %do.body.i.i99
  br i1 %cmp4.i.i103, label %if.then14.i.i119, label %if.else27.i.i107

if.then14.i.i119:                                 ; preds = %do.end.i.i106
  %57 = load i64, ptr %gcdept.i.i96, align 8
  %cmp16.i.i120 = icmp ult i64 %57, 1024
  br i1 %cmp16.i.i120, label %if.then18.i.i123, label %if.else.i.i121

if.then18.i.i123:                                 ; preds = %if.then14.i.i119
  %58 = load i64, ptr %totalbytes.i86, align 8
  %add20.i.i124 = add i64 %58, 1024
  br label %luaC_step.exit.i113

if.else.i.i121:                                   ; preds = %if.then14.i.i119
  %sub23.i.i122 = add i64 %57, -1024
  store i64 %sub23.i.i122, ptr %gcdept.i.i96, align 8
  %59 = load i64, ptr %totalbytes.i86, align 8
  br label %luaC_step.exit.i113

if.else27.i.i107:                                 ; preds = %do.end.i.i106
  %estimate.i.i108 = getelementptr inbounds %struct.global_State, ptr %51, i64 0, i32 15
  %60 = load i64, ptr %estimate.i.i108, align 8
  %div.i.i109 = udiv i64 %60, 100
  %gcpause.i.i110 = getelementptr inbounds %struct.global_State, ptr %51, i64 0, i32 17
  %61 = load i32, ptr %gcpause.i.i110, align 8
  %conv28.i.i111 = sext i32 %61 to i64
  %mul29.i.i112 = mul i64 %div.i.i109, %conv28.i.i111
  br label %luaC_step.exit.i113

luaC_step.exit.i113:                              ; preds = %if.else27.i.i107, %if.else.i.i121, %if.then18.i.i123
  %add20.sink.i.i114 = phi i64 [ %add20.i.i124, %if.then18.i.i123 ], [ %59, %if.else.i.i121 ], [ %mul29.i.i112, %if.else27.i.i107 ]
  store i64 %add20.sink.i.i114, ptr %GCthreshold.i87, align 8
  %.pre173 = load ptr, ptr %top.i, align 8
  br label %lua_pushlstring.exit125

lua_pushlstring.exit125:                          ; preds = %lua_createtable.exit, %luaC_step.exit.i113
  %62 = phi ptr [ %incdec.ptr.i78, %lua_createtable.exit ], [ %.pre173, %luaC_step.exit.i113 ]
  %call.i116 = tail call fastcc ptr @luaS_newlstr(ptr noundef nonnull %L, ptr noundef %fname.addr.0, i64 noundef %sub.ptr.sub)
  store ptr %call.i116, ptr %62, align 8
  %tt.i117 = getelementptr inbounds %struct.lua_TValue, ptr %62, i64 0, i32 1
  store i32 4, ptr %tt.i117, align 8
  %63 = load ptr, ptr %top.i, align 8
  %incdec.ptr.i118 = getelementptr inbounds %struct.lua_TValue, ptr %63, i64 1
  store ptr %incdec.ptr.i118, ptr %top.i, align 8
  %add.ptr8.i.i129 = getelementptr inbounds %struct.lua_TValue, ptr %63, i64 -1
  %64 = load i64, ptr %add.ptr8.i.i129, align 8
  store i64 %64, ptr %incdec.ptr.i118, align 8
  %tt.i132 = getelementptr %struct.lua_TValue, ptr %63, i64 -1, i32 1
  %65 = load i32, ptr %tt.i132, align 8
  %tt2.i133 = getelementptr inbounds %struct.lua_TValue, ptr %63, i64 1, i32 1
  store i32 %65, ptr %tt2.i133, align 8
  %66 = load ptr, ptr %top.i, align 8
  %incdec.ptr.i134 = getelementptr inbounds %struct.lua_TValue, ptr %66, i64 1
  store ptr %incdec.ptr.i134, ptr %top.i, align 8
  %add.ptr8.i.i136 = getelementptr inbounds %struct.lua_TValue, ptr %66, i64 -3
  %add.ptr.i137 = getelementptr inbounds %struct.lua_TValue, ptr %66, i64 -1
  tail call fastcc void @luaV_settable(ptr noundef nonnull %L, ptr noundef nonnull %add.ptr8.i.i136, ptr noundef nonnull %add.ptr.i137, ptr noundef nonnull %66)
  %67 = load ptr, ptr %top.i, align 8
  %add.ptr4.i = getelementptr inbounds %struct.lua_TValue, ptr %67, i64 -2
  store ptr %add.ptr4.i, ptr %top.i, align 8
  br label %if.end15

if.then13:                                        ; preds = %lua_type.exit, %lua_pushlstring.exit
  %add.ptr9.i149 = getelementptr %struct.lua_TValue, ptr %35, i64 -2
  store ptr %add.ptr9.i149, ptr %top.i, align 8
  br label %return

if.end15:                                         ; preds = %lua_type.exit, %lua_pushlstring.exit125
  %68 = phi ptr [ %add.ptr4.i, %lua_pushlstring.exit125 ], [ %35, %lua_type.exit ]
  %add.ptr8.i.i153 = getelementptr inbounds %struct.lua_TValue, ptr %68, i64 -2
  %incdec.ptr7.i = getelementptr inbounds %struct.lua_TValue, ptr %68, i64 -1
  br label %while.body.i

while.body.i:                                     ; preds = %if.end15, %while.body.i
  %incdec.ptr10.i = phi ptr [ %incdec.ptr.i158, %while.body.i ], [ %incdec.ptr7.i, %if.end15 ]
  %p.09.i = phi ptr [ %incdec.ptr10.i, %while.body.i ], [ %add.ptr8.i.i153, %if.end15 ]
  %69 = load i64, ptr %incdec.ptr10.i, align 8
  store i64 %69, ptr %p.09.i, align 8
  %tt.i156 = getelementptr inbounds %struct.lua_TValue, ptr %p.09.i, i64 1, i32 1
  %70 = load i32, ptr %tt.i156, align 8
  %tt2.i157 = getelementptr inbounds %struct.lua_TValue, ptr %p.09.i, i64 0, i32 1
  store i32 %70, ptr %tt2.i157, align 8
  %incdec.ptr.i158 = getelementptr inbounds %struct.lua_TValue, ptr %incdec.ptr10.i, i64 1
  %71 = load ptr, ptr %top.i, align 8
  %cmp.i159 = icmp ult ptr %incdec.ptr.i158, %71
  br i1 %cmp.i159, label %while.body.i, label %lua_remove.exit, !llvm.loop !11

lua_remove.exit:                                  ; preds = %while.body.i
  %incdec.ptr4.i = getelementptr inbounds %struct.lua_TValue, ptr %71, i64 -1
  store ptr %incdec.ptr4.i, ptr %top.i, align 8
  %add.ptr16 = getelementptr inbounds i8, ptr %e.0, i64 1
  %72 = load i8, ptr %e.0, align 1
  %cmp18 = icmp eq i8 %72, 46
  br i1 %cmp18, label %do.body, label %return, !llvm.loop !162

return:                                           ; preds = %lua_remove.exit, %if.then13
  %retval.0 = phi ptr [ %fname.addr.0, %if.then13 ], [ null, %lua_remove.exit ]
  ret ptr %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @tobit(ptr noundef %L) #0 {
entry:
  %endptr.i.i.i = alloca ptr, align 8
  %call.i = tail call fastcc double @lua_tonumber(ptr noundef %L, i32 noundef 1)
  %add.i = fadd double %call.i, 0x4338000000000000
  %cmp.i = fcmp oeq double %add.i, 0.000000e+00
  br i1 %cmp.i, label %land.lhs.true.i, label %barg.exit

land.lhs.true.i:                                  ; preds = %entry
  %base.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i, align 8
  %top.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i, align 8
  %cmp1.not.i.i = icmp ult ptr %0, %1
  %add.ptr.luaO_nilobject_.i.i = select i1 %cmp1.not.i.i, ptr %0, ptr @luaO_nilobject_
  %tt.i2 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i, i64 0, i32 1
  %2 = load i32, ptr %tt.i2, align 8
  switch i32 %2, label %if.then.i [
    i32 3, label %barg.exit
    i32 4, label %land.lhs.true.i.i
  ]

land.lhs.true.i.i:                                ; preds = %land.lhs.true.i
  %3 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i, align 8
  %add.ptr.i3.i = getelementptr inbounds %union.TString, ptr %3, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i.i)
  %call.i.i.i = call double @strtod(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i) #35
  %4 = load ptr, ptr %endptr.i.i.i, align 8
  %cmp.i.i.i = icmp eq ptr %4, %add.ptr.i3.i
  br i1 %cmp.i.i.i, label %luaO_str2d.exit.thread.i.i, label %if.end.i.i.i

luaO_str2d.exit.thread.i.i:                       ; preds = %land.lhs.true.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %if.then.i

if.end.i.i.i:                                     ; preds = %land.lhs.true.i.i
  %5 = load i8, ptr %4, align 1
  switch i8 %5, label %if.end9.i.i.i [
    i8 120, label %if.then6.i.i.i
    i8 88, label %if.then6.i.i.i
  ]

if.then6.i.i.i:                                   ; preds = %if.end.i.i.i, %if.end.i.i.i
  %call7.i.i.i = call i64 @strtoul(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i, i32 noundef 16) #35
  %.pre.i.i.i = load ptr, ptr %endptr.i.i.i, align 8
  %.pre5.i.i.i = load i8, ptr %.pre.i.i.i, align 1
  br label %if.end9.i.i.i

if.end9.i.i.i:                                    ; preds = %if.then6.i.i.i, %if.end.i.i.i
  %6 = phi i8 [ %5, %if.end.i.i.i ], [ %.pre5.i.i.i, %if.then6.i.i.i ]
  %endptr.promoted.i.i.i = phi ptr [ %4, %if.end.i.i.i ], [ %.pre.i.i.i, %if.then6.i.i.i ]
  %cmp11.i.i.i = icmp eq i8 %6, 0
  br i1 %cmp11.i.i.i, label %luaO_str2d.exit.thread9.i.i, label %while.cond.preheader.i.i.i

luaO_str2d.exit.thread9.i.i:                      ; preds = %if.end9.i.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %barg.exit

while.cond.preheader.i.i.i:                       ; preds = %if.end9.i.i.i
  %call15.i.i.i = tail call ptr @__ctype_b_loc() #39
  %7 = load ptr, ptr %call15.i.i.i, align 8
  br label %while.cond.i.i.i

while.cond.i.i.i:                                 ; preds = %while.cond.i.i.i, %while.cond.preheader.i.i.i
  %incdec.ptr4.i.i.i = phi ptr [ %endptr.promoted.i.i.i, %while.cond.preheader.i.i.i ], [ %incdec.ptr.i.i.i, %while.cond.i.i.i ]
  %8 = load i8, ptr %incdec.ptr4.i.i.i, align 1
  %idxprom.i.i.i = zext i8 %8 to i64
  %arrayidx.i.i.i = getelementptr inbounds i16, ptr %7, i64 %idxprom.i.i.i
  %9 = load i16, ptr %arrayidx.i.i.i, align 2
  %10 = and i16 %9, 8192
  %tobool.not.i.i.i = icmp eq i16 %10, 0
  %incdec.ptr.i.i.i = getelementptr inbounds i8, ptr %incdec.ptr4.i.i.i, i64 1
  br i1 %tobool.not.i.i.i, label %luaO_str2d.exit.i.i, label %while.cond.i.i.i, !llvm.loop !35

luaO_str2d.exit.i.i:                              ; preds = %while.cond.i.i.i
  %cmp19.not.i.not.i.i = icmp eq i8 %8, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br i1 %cmp19.not.i.not.i.i, label %barg.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true.i, %luaO_str2d.exit.i.i, %luaO_str2d.exit.thread.i.i
  tail call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 1, ptr noundef nonnull @.str.24)
  unreachable

barg.exit:                                        ; preds = %luaO_str2d.exit.thread9.i.i, %luaO_str2d.exit.i.i, %land.lhs.true.i, %entry
  %11 = bitcast double %add.i to i64
  %conv.i = trunc i64 %11 to i32
  %conv = sitofp i32 %conv.i to double
  %top.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %12 = load ptr, ptr %top.i, align 8
  store double %conv, ptr %12, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %12, i64 0, i32 1
  store i32 3, ptr %tt.i, align 8
  %13 = load ptr, ptr %top.i, align 8
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %13, i64 1
  store ptr %incdec.ptr.i, ptr %top.i, align 8
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @bnot(ptr noundef %L) #0 {
entry:
  %endptr.i.i.i = alloca ptr, align 8
  %call.i = tail call fastcc double @lua_tonumber(ptr noundef %L, i32 noundef 1)
  %add.i = fadd double %call.i, 0x4338000000000000
  %cmp.i = fcmp oeq double %add.i, 0.000000e+00
  br i1 %cmp.i, label %land.lhs.true.i, label %barg.exit

land.lhs.true.i:                                  ; preds = %entry
  %base.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i, align 8
  %top.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i, align 8
  %cmp1.not.i.i = icmp ult ptr %0, %1
  %add.ptr.luaO_nilobject_.i.i = select i1 %cmp1.not.i.i, ptr %0, ptr @luaO_nilobject_
  %tt.i2 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i, i64 0, i32 1
  %2 = load i32, ptr %tt.i2, align 8
  switch i32 %2, label %if.then.i [
    i32 3, label %barg.exit
    i32 4, label %land.lhs.true.i.i
  ]

land.lhs.true.i.i:                                ; preds = %land.lhs.true.i
  %3 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i, align 8
  %add.ptr.i3.i = getelementptr inbounds %union.TString, ptr %3, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i.i)
  %call.i.i.i = call double @strtod(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i) #35
  %4 = load ptr, ptr %endptr.i.i.i, align 8
  %cmp.i.i.i = icmp eq ptr %4, %add.ptr.i3.i
  br i1 %cmp.i.i.i, label %luaO_str2d.exit.thread.i.i, label %if.end.i.i.i

luaO_str2d.exit.thread.i.i:                       ; preds = %land.lhs.true.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %if.then.i

if.end.i.i.i:                                     ; preds = %land.lhs.true.i.i
  %5 = load i8, ptr %4, align 1
  switch i8 %5, label %if.end9.i.i.i [
    i8 120, label %if.then6.i.i.i
    i8 88, label %if.then6.i.i.i
  ]

if.then6.i.i.i:                                   ; preds = %if.end.i.i.i, %if.end.i.i.i
  %call7.i.i.i = call i64 @strtoul(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i, i32 noundef 16) #35
  %.pre.i.i.i = load ptr, ptr %endptr.i.i.i, align 8
  %.pre5.i.i.i = load i8, ptr %.pre.i.i.i, align 1
  br label %if.end9.i.i.i

if.end9.i.i.i:                                    ; preds = %if.then6.i.i.i, %if.end.i.i.i
  %6 = phi i8 [ %5, %if.end.i.i.i ], [ %.pre5.i.i.i, %if.then6.i.i.i ]
  %endptr.promoted.i.i.i = phi ptr [ %4, %if.end.i.i.i ], [ %.pre.i.i.i, %if.then6.i.i.i ]
  %cmp11.i.i.i = icmp eq i8 %6, 0
  br i1 %cmp11.i.i.i, label %luaO_str2d.exit.thread9.i.i, label %while.cond.preheader.i.i.i

luaO_str2d.exit.thread9.i.i:                      ; preds = %if.end9.i.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %barg.exit

while.cond.preheader.i.i.i:                       ; preds = %if.end9.i.i.i
  %call15.i.i.i = tail call ptr @__ctype_b_loc() #39
  %7 = load ptr, ptr %call15.i.i.i, align 8
  br label %while.cond.i.i.i

while.cond.i.i.i:                                 ; preds = %while.cond.i.i.i, %while.cond.preheader.i.i.i
  %incdec.ptr4.i.i.i = phi ptr [ %endptr.promoted.i.i.i, %while.cond.preheader.i.i.i ], [ %incdec.ptr.i.i.i, %while.cond.i.i.i ]
  %8 = load i8, ptr %incdec.ptr4.i.i.i, align 1
  %idxprom.i.i.i = zext i8 %8 to i64
  %arrayidx.i.i.i = getelementptr inbounds i16, ptr %7, i64 %idxprom.i.i.i
  %9 = load i16, ptr %arrayidx.i.i.i, align 2
  %10 = and i16 %9, 8192
  %tobool.not.i.i.i = icmp eq i16 %10, 0
  %incdec.ptr.i.i.i = getelementptr inbounds i8, ptr %incdec.ptr4.i.i.i, i64 1
  br i1 %tobool.not.i.i.i, label %luaO_str2d.exit.i.i, label %while.cond.i.i.i, !llvm.loop !35

luaO_str2d.exit.i.i:                              ; preds = %while.cond.i.i.i
  %cmp19.not.i.not.i.i = icmp eq i8 %8, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br i1 %cmp19.not.i.not.i.i, label %barg.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true.i, %luaO_str2d.exit.i.i, %luaO_str2d.exit.thread.i.i
  tail call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 1, ptr noundef nonnull @.str.24)
  unreachable

barg.exit:                                        ; preds = %luaO_str2d.exit.thread9.i.i, %luaO_str2d.exit.i.i, %land.lhs.true.i, %entry
  %11 = bitcast double %add.i to i64
  %conv.i = trunc i64 %11 to i32
  %not = xor i32 %conv.i, -1
  %conv = sitofp i32 %not to double
  %top.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %12 = load ptr, ptr %top.i, align 8
  store double %conv, ptr %12, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %12, i64 0, i32 1
  store i32 3, ptr %tt.i, align 8
  %13 = load ptr, ptr %top.i, align 8
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %13, i64 1
  store ptr %incdec.ptr.i, ptr %top.i, align 8
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @band(ptr noundef %L) #0 {
entry:
  %endptr.i.i.i = alloca ptr, align 8
  %call.i = tail call fastcc double @lua_tonumber(ptr noundef %L, i32 noundef 1)
  %add.i = fadd double %call.i, 0x4338000000000000
  %cmp.i = fcmp oeq double %add.i, 0.000000e+00
  br i1 %cmp.i, label %land.lhs.true.i, label %barg.exit

land.lhs.true.i:                                  ; preds = %entry
  %base.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i, align 8
  %top.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i, align 8
  %cmp1.not.i.i = icmp ult ptr %0, %1
  %add.ptr.luaO_nilobject_.i.i = select i1 %cmp1.not.i.i, ptr %0, ptr @luaO_nilobject_
  %tt.i19 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i, i64 0, i32 1
  %2 = load i32, ptr %tt.i19, align 8
  switch i32 %2, label %if.then.i [
    i32 3, label %barg.exit
    i32 4, label %land.lhs.true.i.i
  ]

land.lhs.true.i.i:                                ; preds = %land.lhs.true.i
  %3 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i, align 8
  %add.ptr.i3.i = getelementptr inbounds %union.TString, ptr %3, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i.i)
  %call.i.i.i = call double @strtod(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i) #35
  %4 = load ptr, ptr %endptr.i.i.i, align 8
  %cmp.i.i.i = icmp eq ptr %4, %add.ptr.i3.i
  br i1 %cmp.i.i.i, label %luaO_str2d.exit.thread.i.i, label %if.end.i.i.i

luaO_str2d.exit.thread.i.i:                       ; preds = %land.lhs.true.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %if.then.i

if.end.i.i.i:                                     ; preds = %land.lhs.true.i.i
  %5 = load i8, ptr %4, align 1
  switch i8 %5, label %if.end9.i.i.i [
    i8 120, label %if.then6.i.i.i
    i8 88, label %if.then6.i.i.i
  ]

if.then6.i.i.i:                                   ; preds = %if.end.i.i.i, %if.end.i.i.i
  %call7.i.i.i = call i64 @strtoul(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i, i32 noundef 16) #35
  %.pre.i.i.i = load ptr, ptr %endptr.i.i.i, align 8
  %.pre5.i.i.i = load i8, ptr %.pre.i.i.i, align 1
  br label %if.end9.i.i.i

if.end9.i.i.i:                                    ; preds = %if.then6.i.i.i, %if.end.i.i.i
  %6 = phi i8 [ %5, %if.end.i.i.i ], [ %.pre5.i.i.i, %if.then6.i.i.i ]
  %endptr.promoted.i.i.i = phi ptr [ %4, %if.end.i.i.i ], [ %.pre.i.i.i, %if.then6.i.i.i ]
  %cmp11.i.i.i = icmp eq i8 %6, 0
  br i1 %cmp11.i.i.i, label %luaO_str2d.exit.thread9.i.i, label %while.cond.preheader.i.i.i

luaO_str2d.exit.thread9.i.i:                      ; preds = %if.end9.i.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %barg.exit

while.cond.preheader.i.i.i:                       ; preds = %if.end9.i.i.i
  %call15.i.i.i = tail call ptr @__ctype_b_loc() #39
  %7 = load ptr, ptr %call15.i.i.i, align 8
  br label %while.cond.i.i.i

while.cond.i.i.i:                                 ; preds = %while.cond.i.i.i, %while.cond.preheader.i.i.i
  %incdec.ptr4.i.i.i = phi ptr [ %endptr.promoted.i.i.i, %while.cond.preheader.i.i.i ], [ %incdec.ptr.i.i.i, %while.cond.i.i.i ]
  %8 = load i8, ptr %incdec.ptr4.i.i.i, align 1
  %idxprom.i.i.i = zext i8 %8 to i64
  %arrayidx.i.i.i = getelementptr inbounds i16, ptr %7, i64 %idxprom.i.i.i
  %9 = load i16, ptr %arrayidx.i.i.i, align 2
  %10 = and i16 %9, 8192
  %tobool.not.i.i.i = icmp eq i16 %10, 0
  %incdec.ptr.i.i.i = getelementptr inbounds i8, ptr %incdec.ptr4.i.i.i, i64 1
  br i1 %tobool.not.i.i.i, label %luaO_str2d.exit.i.i, label %while.cond.i.i.i, !llvm.loop !35

luaO_str2d.exit.i.i:                              ; preds = %while.cond.i.i.i
  %cmp19.not.i.not.i.i = icmp eq i8 %8, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br i1 %cmp19.not.i.not.i.i, label %barg.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true.i, %luaO_str2d.exit.i.i, %luaO_str2d.exit.thread.i.i
  tail call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 1, ptr noundef nonnull @.str.24)
  unreachable

barg.exit:                                        ; preds = %luaO_str2d.exit.thread9.i.i, %luaO_str2d.exit.i.i, %land.lhs.true.i, %entry
  %11 = bitcast double %add.i to i64
  %conv.i = trunc i64 %11 to i32
  %12 = getelementptr i8, ptr %L, i64 16
  %L.val = load ptr, ptr %12, align 8
  %13 = getelementptr i8, ptr %L, i64 24
  %L.val7 = load ptr, ptr %13, align 8
  %sub.ptr.lhs.cast.i = ptrtoint ptr %L.val to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %L.val7 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %sub.ptr.div.i = lshr exact i64 %sub.ptr.sub.i, 4
  %conv.i8 = trunc i64 %sub.ptr.div.i to i32
  %cmp24 = icmp sgt i32 %conv.i8, 1
  br i1 %cmp24, label %for.body, label %for.end

for.body:                                         ; preds = %barg.exit, %barg.exit18
  %b.026 = phi i32 [ %and, %barg.exit18 ], [ %conv.i, %barg.exit ]
  %i.025 = phi i32 [ %dec, %barg.exit18 ], [ %conv.i8, %barg.exit ]
  %call.i9 = tail call fastcc double @lua_tonumber(ptr noundef %L, i32 noundef %i.025)
  %add.i10 = fadd double %call.i9, 0x4338000000000000
  %cmp.i11 = fcmp oeq double %add.i10, 0.000000e+00
  br i1 %cmp.i11, label %land.lhs.true.i13, label %barg.exit18

land.lhs.true.i13:                                ; preds = %for.body
  %call1.i14 = tail call fastcc i32 @lua_isnumber(ptr noundef %L, i32 noundef %i.025), !range !23
  %tobool.not.i15 = icmp eq i32 %call1.i14, 0
  br i1 %tobool.not.i15, label %if.then.i16, label %barg.exit18

if.then.i16:                                      ; preds = %land.lhs.true.i13
  tail call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef %i.025, ptr noundef nonnull @.str.24)
  unreachable

barg.exit18:                                      ; preds = %for.body, %land.lhs.true.i13
  %14 = bitcast double %add.i10 to i64
  %conv.i12 = trunc i64 %14 to i32
  %and = and i32 %b.026, %conv.i12
  %dec = add nsw i32 %i.025, -1
  %cmp = icmp sgt i32 %i.025, 2
  br i1 %cmp, label %for.body, label %for.end.loopexit, !llvm.loop !163

for.end.loopexit:                                 ; preds = %barg.exit18
  %.pre = load ptr, ptr %12, align 8
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %barg.exit
  %15 = phi ptr [ %L.val, %barg.exit ], [ %.pre, %for.end.loopexit ]
  %b.0.lcssa = phi i32 [ %conv.i, %barg.exit ], [ %and, %for.end.loopexit ]
  %conv = sitofp i32 %b.0.lcssa to double
  store double %conv, ptr %15, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %15, i64 0, i32 1
  store i32 3, ptr %tt.i, align 8
  %16 = load ptr, ptr %12, align 8
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %16, i64 1
  store ptr %incdec.ptr.i, ptr %12, align 8
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @bor(ptr noundef %L) #0 {
entry:
  %endptr.i.i.i = alloca ptr, align 8
  %call.i = tail call fastcc double @lua_tonumber(ptr noundef %L, i32 noundef 1)
  %add.i = fadd double %call.i, 0x4338000000000000
  %cmp.i = fcmp oeq double %add.i, 0.000000e+00
  br i1 %cmp.i, label %land.lhs.true.i, label %barg.exit

land.lhs.true.i:                                  ; preds = %entry
  %base.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i, align 8
  %top.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i, align 8
  %cmp1.not.i.i = icmp ult ptr %0, %1
  %add.ptr.luaO_nilobject_.i.i = select i1 %cmp1.not.i.i, ptr %0, ptr @luaO_nilobject_
  %tt.i19 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i, i64 0, i32 1
  %2 = load i32, ptr %tt.i19, align 8
  switch i32 %2, label %if.then.i [
    i32 3, label %barg.exit
    i32 4, label %land.lhs.true.i.i
  ]

land.lhs.true.i.i:                                ; preds = %land.lhs.true.i
  %3 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i, align 8
  %add.ptr.i3.i = getelementptr inbounds %union.TString, ptr %3, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i.i)
  %call.i.i.i = call double @strtod(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i) #35
  %4 = load ptr, ptr %endptr.i.i.i, align 8
  %cmp.i.i.i = icmp eq ptr %4, %add.ptr.i3.i
  br i1 %cmp.i.i.i, label %luaO_str2d.exit.thread.i.i, label %if.end.i.i.i

luaO_str2d.exit.thread.i.i:                       ; preds = %land.lhs.true.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %if.then.i

if.end.i.i.i:                                     ; preds = %land.lhs.true.i.i
  %5 = load i8, ptr %4, align 1
  switch i8 %5, label %if.end9.i.i.i [
    i8 120, label %if.then6.i.i.i
    i8 88, label %if.then6.i.i.i
  ]

if.then6.i.i.i:                                   ; preds = %if.end.i.i.i, %if.end.i.i.i
  %call7.i.i.i = call i64 @strtoul(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i, i32 noundef 16) #35
  %.pre.i.i.i = load ptr, ptr %endptr.i.i.i, align 8
  %.pre5.i.i.i = load i8, ptr %.pre.i.i.i, align 1
  br label %if.end9.i.i.i

if.end9.i.i.i:                                    ; preds = %if.then6.i.i.i, %if.end.i.i.i
  %6 = phi i8 [ %5, %if.end.i.i.i ], [ %.pre5.i.i.i, %if.then6.i.i.i ]
  %endptr.promoted.i.i.i = phi ptr [ %4, %if.end.i.i.i ], [ %.pre.i.i.i, %if.then6.i.i.i ]
  %cmp11.i.i.i = icmp eq i8 %6, 0
  br i1 %cmp11.i.i.i, label %luaO_str2d.exit.thread9.i.i, label %while.cond.preheader.i.i.i

luaO_str2d.exit.thread9.i.i:                      ; preds = %if.end9.i.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %barg.exit

while.cond.preheader.i.i.i:                       ; preds = %if.end9.i.i.i
  %call15.i.i.i = tail call ptr @__ctype_b_loc() #39
  %7 = load ptr, ptr %call15.i.i.i, align 8
  br label %while.cond.i.i.i

while.cond.i.i.i:                                 ; preds = %while.cond.i.i.i, %while.cond.preheader.i.i.i
  %incdec.ptr4.i.i.i = phi ptr [ %endptr.promoted.i.i.i, %while.cond.preheader.i.i.i ], [ %incdec.ptr.i.i.i, %while.cond.i.i.i ]
  %8 = load i8, ptr %incdec.ptr4.i.i.i, align 1
  %idxprom.i.i.i = zext i8 %8 to i64
  %arrayidx.i.i.i = getelementptr inbounds i16, ptr %7, i64 %idxprom.i.i.i
  %9 = load i16, ptr %arrayidx.i.i.i, align 2
  %10 = and i16 %9, 8192
  %tobool.not.i.i.i = icmp eq i16 %10, 0
  %incdec.ptr.i.i.i = getelementptr inbounds i8, ptr %incdec.ptr4.i.i.i, i64 1
  br i1 %tobool.not.i.i.i, label %luaO_str2d.exit.i.i, label %while.cond.i.i.i, !llvm.loop !35

luaO_str2d.exit.i.i:                              ; preds = %while.cond.i.i.i
  %cmp19.not.i.not.i.i = icmp eq i8 %8, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br i1 %cmp19.not.i.not.i.i, label %barg.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true.i, %luaO_str2d.exit.i.i, %luaO_str2d.exit.thread.i.i
  tail call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 1, ptr noundef nonnull @.str.24)
  unreachable

barg.exit:                                        ; preds = %luaO_str2d.exit.thread9.i.i, %luaO_str2d.exit.i.i, %land.lhs.true.i, %entry
  %11 = bitcast double %add.i to i64
  %conv.i = trunc i64 %11 to i32
  %12 = getelementptr i8, ptr %L, i64 16
  %L.val = load ptr, ptr %12, align 8
  %13 = getelementptr i8, ptr %L, i64 24
  %L.val7 = load ptr, ptr %13, align 8
  %sub.ptr.lhs.cast.i = ptrtoint ptr %L.val to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %L.val7 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %sub.ptr.div.i = lshr exact i64 %sub.ptr.sub.i, 4
  %conv.i8 = trunc i64 %sub.ptr.div.i to i32
  %cmp24 = icmp sgt i32 %conv.i8, 1
  br i1 %cmp24, label %for.body, label %for.end

for.body:                                         ; preds = %barg.exit, %barg.exit18
  %b.026 = phi i32 [ %or, %barg.exit18 ], [ %conv.i, %barg.exit ]
  %i.025 = phi i32 [ %dec, %barg.exit18 ], [ %conv.i8, %barg.exit ]
  %call.i9 = tail call fastcc double @lua_tonumber(ptr noundef %L, i32 noundef %i.025)
  %add.i10 = fadd double %call.i9, 0x4338000000000000
  %cmp.i11 = fcmp oeq double %add.i10, 0.000000e+00
  br i1 %cmp.i11, label %land.lhs.true.i13, label %barg.exit18

land.lhs.true.i13:                                ; preds = %for.body
  %call1.i14 = tail call fastcc i32 @lua_isnumber(ptr noundef %L, i32 noundef %i.025), !range !23
  %tobool.not.i15 = icmp eq i32 %call1.i14, 0
  br i1 %tobool.not.i15, label %if.then.i16, label %barg.exit18

if.then.i16:                                      ; preds = %land.lhs.true.i13
  tail call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef %i.025, ptr noundef nonnull @.str.24)
  unreachable

barg.exit18:                                      ; preds = %for.body, %land.lhs.true.i13
  %14 = bitcast double %add.i10 to i64
  %conv.i12 = trunc i64 %14 to i32
  %or = or i32 %b.026, %conv.i12
  %dec = add nsw i32 %i.025, -1
  %cmp = icmp sgt i32 %i.025, 2
  br i1 %cmp, label %for.body, label %for.end.loopexit, !llvm.loop !164

for.end.loopexit:                                 ; preds = %barg.exit18
  %.pre = load ptr, ptr %12, align 8
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %barg.exit
  %15 = phi ptr [ %L.val, %barg.exit ], [ %.pre, %for.end.loopexit ]
  %b.0.lcssa = phi i32 [ %conv.i, %barg.exit ], [ %or, %for.end.loopexit ]
  %conv = sitofp i32 %b.0.lcssa to double
  store double %conv, ptr %15, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %15, i64 0, i32 1
  store i32 3, ptr %tt.i, align 8
  %16 = load ptr, ptr %12, align 8
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %16, i64 1
  store ptr %incdec.ptr.i, ptr %12, align 8
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @bxor(ptr noundef %L) #0 {
entry:
  %endptr.i.i.i = alloca ptr, align 8
  %call.i = tail call fastcc double @lua_tonumber(ptr noundef %L, i32 noundef 1)
  %add.i = fadd double %call.i, 0x4338000000000000
  %cmp.i = fcmp oeq double %add.i, 0.000000e+00
  br i1 %cmp.i, label %land.lhs.true.i, label %barg.exit

land.lhs.true.i:                                  ; preds = %entry
  %base.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i, align 8
  %top.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i, align 8
  %cmp1.not.i.i = icmp ult ptr %0, %1
  %add.ptr.luaO_nilobject_.i.i = select i1 %cmp1.not.i.i, ptr %0, ptr @luaO_nilobject_
  %tt.i19 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i, i64 0, i32 1
  %2 = load i32, ptr %tt.i19, align 8
  switch i32 %2, label %if.then.i [
    i32 3, label %barg.exit
    i32 4, label %land.lhs.true.i.i
  ]

land.lhs.true.i.i:                                ; preds = %land.lhs.true.i
  %3 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i, align 8
  %add.ptr.i3.i = getelementptr inbounds %union.TString, ptr %3, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i.i)
  %call.i.i.i = call double @strtod(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i) #35
  %4 = load ptr, ptr %endptr.i.i.i, align 8
  %cmp.i.i.i = icmp eq ptr %4, %add.ptr.i3.i
  br i1 %cmp.i.i.i, label %luaO_str2d.exit.thread.i.i, label %if.end.i.i.i

luaO_str2d.exit.thread.i.i:                       ; preds = %land.lhs.true.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %if.then.i

if.end.i.i.i:                                     ; preds = %land.lhs.true.i.i
  %5 = load i8, ptr %4, align 1
  switch i8 %5, label %if.end9.i.i.i [
    i8 120, label %if.then6.i.i.i
    i8 88, label %if.then6.i.i.i
  ]

if.then6.i.i.i:                                   ; preds = %if.end.i.i.i, %if.end.i.i.i
  %call7.i.i.i = call i64 @strtoul(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i, i32 noundef 16) #35
  %.pre.i.i.i = load ptr, ptr %endptr.i.i.i, align 8
  %.pre5.i.i.i = load i8, ptr %.pre.i.i.i, align 1
  br label %if.end9.i.i.i

if.end9.i.i.i:                                    ; preds = %if.then6.i.i.i, %if.end.i.i.i
  %6 = phi i8 [ %5, %if.end.i.i.i ], [ %.pre5.i.i.i, %if.then6.i.i.i ]
  %endptr.promoted.i.i.i = phi ptr [ %4, %if.end.i.i.i ], [ %.pre.i.i.i, %if.then6.i.i.i ]
  %cmp11.i.i.i = icmp eq i8 %6, 0
  br i1 %cmp11.i.i.i, label %luaO_str2d.exit.thread9.i.i, label %while.cond.preheader.i.i.i

luaO_str2d.exit.thread9.i.i:                      ; preds = %if.end9.i.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %barg.exit

while.cond.preheader.i.i.i:                       ; preds = %if.end9.i.i.i
  %call15.i.i.i = tail call ptr @__ctype_b_loc() #39
  %7 = load ptr, ptr %call15.i.i.i, align 8
  br label %while.cond.i.i.i

while.cond.i.i.i:                                 ; preds = %while.cond.i.i.i, %while.cond.preheader.i.i.i
  %incdec.ptr4.i.i.i = phi ptr [ %endptr.promoted.i.i.i, %while.cond.preheader.i.i.i ], [ %incdec.ptr.i.i.i, %while.cond.i.i.i ]
  %8 = load i8, ptr %incdec.ptr4.i.i.i, align 1
  %idxprom.i.i.i = zext i8 %8 to i64
  %arrayidx.i.i.i = getelementptr inbounds i16, ptr %7, i64 %idxprom.i.i.i
  %9 = load i16, ptr %arrayidx.i.i.i, align 2
  %10 = and i16 %9, 8192
  %tobool.not.i.i.i = icmp eq i16 %10, 0
  %incdec.ptr.i.i.i = getelementptr inbounds i8, ptr %incdec.ptr4.i.i.i, i64 1
  br i1 %tobool.not.i.i.i, label %luaO_str2d.exit.i.i, label %while.cond.i.i.i, !llvm.loop !35

luaO_str2d.exit.i.i:                              ; preds = %while.cond.i.i.i
  %cmp19.not.i.not.i.i = icmp eq i8 %8, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br i1 %cmp19.not.i.not.i.i, label %barg.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true.i, %luaO_str2d.exit.i.i, %luaO_str2d.exit.thread.i.i
  tail call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 1, ptr noundef nonnull @.str.24)
  unreachable

barg.exit:                                        ; preds = %luaO_str2d.exit.thread9.i.i, %luaO_str2d.exit.i.i, %land.lhs.true.i, %entry
  %11 = bitcast double %add.i to i64
  %conv.i = trunc i64 %11 to i32
  %12 = getelementptr i8, ptr %L, i64 16
  %L.val = load ptr, ptr %12, align 8
  %13 = getelementptr i8, ptr %L, i64 24
  %L.val7 = load ptr, ptr %13, align 8
  %sub.ptr.lhs.cast.i = ptrtoint ptr %L.val to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %L.val7 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %sub.ptr.div.i = lshr exact i64 %sub.ptr.sub.i, 4
  %conv.i8 = trunc i64 %sub.ptr.div.i to i32
  %cmp24 = icmp sgt i32 %conv.i8, 1
  br i1 %cmp24, label %for.body, label %for.end

for.body:                                         ; preds = %barg.exit, %barg.exit18
  %b.026 = phi i32 [ %xor, %barg.exit18 ], [ %conv.i, %barg.exit ]
  %i.025 = phi i32 [ %dec, %barg.exit18 ], [ %conv.i8, %barg.exit ]
  %call.i9 = tail call fastcc double @lua_tonumber(ptr noundef %L, i32 noundef %i.025)
  %add.i10 = fadd double %call.i9, 0x4338000000000000
  %cmp.i11 = fcmp oeq double %add.i10, 0.000000e+00
  br i1 %cmp.i11, label %land.lhs.true.i13, label %barg.exit18

land.lhs.true.i13:                                ; preds = %for.body
  %call1.i14 = tail call fastcc i32 @lua_isnumber(ptr noundef %L, i32 noundef %i.025), !range !23
  %tobool.not.i15 = icmp eq i32 %call1.i14, 0
  br i1 %tobool.not.i15, label %if.then.i16, label %barg.exit18

if.then.i16:                                      ; preds = %land.lhs.true.i13
  tail call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef %i.025, ptr noundef nonnull @.str.24)
  unreachable

barg.exit18:                                      ; preds = %for.body, %land.lhs.true.i13
  %14 = bitcast double %add.i10 to i64
  %conv.i12 = trunc i64 %14 to i32
  %xor = xor i32 %b.026, %conv.i12
  %dec = add nsw i32 %i.025, -1
  %cmp = icmp sgt i32 %i.025, 2
  br i1 %cmp, label %for.body, label %for.end.loopexit, !llvm.loop !165

for.end.loopexit:                                 ; preds = %barg.exit18
  %.pre = load ptr, ptr %12, align 8
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %barg.exit
  %15 = phi ptr [ %L.val, %barg.exit ], [ %.pre, %for.end.loopexit ]
  %b.0.lcssa = phi i32 [ %conv.i, %barg.exit ], [ %xor, %for.end.loopexit ]
  %conv = sitofp i32 %b.0.lcssa to double
  store double %conv, ptr %15, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %15, i64 0, i32 1
  store i32 3, ptr %tt.i, align 8
  %16 = load ptr, ptr %12, align 8
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %16, i64 1
  store ptr %incdec.ptr.i, ptr %12, align 8
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @lshift(ptr noundef %L) #0 {
entry:
  %endptr.i.i.i14 = alloca ptr, align 8
  %endptr.i.i.i = alloca ptr, align 8
  %call.i = tail call fastcc double @lua_tonumber(ptr noundef %L, i32 noundef 1)
  %add.i = fadd double %call.i, 0x4338000000000000
  %cmp.i = fcmp oeq double %add.i, 0.000000e+00
  br i1 %cmp.i, label %land.lhs.true.i, label %barg.exit

land.lhs.true.i:                                  ; preds = %entry
  %base.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i, align 8
  %top.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i, align 8
  %cmp1.not.i.i = icmp ult ptr %0, %1
  %add.ptr.luaO_nilobject_.i.i = select i1 %cmp1.not.i.i, ptr %0, ptr @luaO_nilobject_
  %tt.i13 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i, i64 0, i32 1
  %2 = load i32, ptr %tt.i13, align 8
  switch i32 %2, label %if.then.i [
    i32 3, label %barg.exit
    i32 4, label %land.lhs.true.i.i
  ]

land.lhs.true.i.i:                                ; preds = %land.lhs.true.i
  %3 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i, align 8
  %add.ptr.i3.i = getelementptr inbounds %union.TString, ptr %3, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i.i)
  %call.i.i.i = call double @strtod(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i) #35
  %4 = load ptr, ptr %endptr.i.i.i, align 8
  %cmp.i.i.i = icmp eq ptr %4, %add.ptr.i3.i
  br i1 %cmp.i.i.i, label %luaO_str2d.exit.thread.i.i, label %if.end.i.i.i

luaO_str2d.exit.thread.i.i:                       ; preds = %land.lhs.true.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %if.then.i

if.end.i.i.i:                                     ; preds = %land.lhs.true.i.i
  %5 = load i8, ptr %4, align 1
  switch i8 %5, label %if.end9.i.i.i [
    i8 120, label %if.then6.i.i.i
    i8 88, label %if.then6.i.i.i
  ]

if.then6.i.i.i:                                   ; preds = %if.end.i.i.i, %if.end.i.i.i
  %call7.i.i.i = call i64 @strtoul(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i, i32 noundef 16) #35
  %.pre.i.i.i = load ptr, ptr %endptr.i.i.i, align 8
  %.pre5.i.i.i = load i8, ptr %.pre.i.i.i, align 1
  br label %if.end9.i.i.i

if.end9.i.i.i:                                    ; preds = %if.then6.i.i.i, %if.end.i.i.i
  %6 = phi i8 [ %5, %if.end.i.i.i ], [ %.pre5.i.i.i, %if.then6.i.i.i ]
  %endptr.promoted.i.i.i = phi ptr [ %4, %if.end.i.i.i ], [ %.pre.i.i.i, %if.then6.i.i.i ]
  %cmp11.i.i.i = icmp eq i8 %6, 0
  br i1 %cmp11.i.i.i, label %luaO_str2d.exit.thread9.i.i, label %while.cond.preheader.i.i.i

luaO_str2d.exit.thread9.i.i:                      ; preds = %if.end9.i.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %barg.exit

while.cond.preheader.i.i.i:                       ; preds = %if.end9.i.i.i
  %call15.i.i.i = tail call ptr @__ctype_b_loc() #39
  %7 = load ptr, ptr %call15.i.i.i, align 8
  br label %while.cond.i.i.i

while.cond.i.i.i:                                 ; preds = %while.cond.i.i.i, %while.cond.preheader.i.i.i
  %incdec.ptr4.i.i.i = phi ptr [ %endptr.promoted.i.i.i, %while.cond.preheader.i.i.i ], [ %incdec.ptr.i.i.i, %while.cond.i.i.i ]
  %8 = load i8, ptr %incdec.ptr4.i.i.i, align 1
  %idxprom.i.i.i = zext i8 %8 to i64
  %arrayidx.i.i.i = getelementptr inbounds i16, ptr %7, i64 %idxprom.i.i.i
  %9 = load i16, ptr %arrayidx.i.i.i, align 2
  %10 = and i16 %9, 8192
  %tobool.not.i.i.i = icmp eq i16 %10, 0
  %incdec.ptr.i.i.i = getelementptr inbounds i8, ptr %incdec.ptr4.i.i.i, i64 1
  br i1 %tobool.not.i.i.i, label %luaO_str2d.exit.i.i, label %while.cond.i.i.i, !llvm.loop !35

luaO_str2d.exit.i.i:                              ; preds = %while.cond.i.i.i
  %cmp19.not.i.not.i.i = icmp eq i8 %8, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br i1 %cmp19.not.i.not.i.i, label %barg.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true.i, %luaO_str2d.exit.i.i, %luaO_str2d.exit.thread.i.i
  tail call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 1, ptr noundef nonnull @.str.24)
  unreachable

barg.exit:                                        ; preds = %luaO_str2d.exit.thread9.i.i, %luaO_str2d.exit.i.i, %land.lhs.true.i, %entry
  %call.i3 = tail call fastcc double @lua_tonumber(ptr noundef %L, i32 noundef 2)
  %add.i4 = fadd double %call.i3, 0x4338000000000000
  %cmp.i5 = fcmp oeq double %add.i4, 0.000000e+00
  br i1 %cmp.i5, label %land.lhs.true.i7, label %barg.exit12

land.lhs.true.i7:                                 ; preds = %barg.exit
  %base.i.i15 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %11 = load ptr, ptr %base.i.i15, align 8
  %add.ptr.i.i16 = getelementptr %struct.lua_TValue, ptr %11, i64 1
  %top.i.i17 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %12 = load ptr, ptr %top.i.i17, align 8
  %cmp1.not.i.i18 = icmp ult ptr %add.ptr.i.i16, %12
  %add.ptr.luaO_nilobject_.i.i19 = select i1 %cmp1.not.i.i18, ptr %add.ptr.i.i16, ptr @luaO_nilobject_
  %tt.i20 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i19, i64 0, i32 1
  %13 = load i32, ptr %tt.i20, align 8
  switch i32 %13, label %if.then.i10 [
    i32 3, label %barg.exit12
    i32 4, label %land.lhs.true.i.i21
  ]

land.lhs.true.i.i21:                              ; preds = %land.lhs.true.i7
  %14 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i19, align 8
  %add.ptr.i3.i22 = getelementptr inbounds %union.TString, ptr %14, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i.i14)
  %call.i.i.i23 = call double @strtod(ptr noundef nonnull %add.ptr.i3.i22, ptr noundef nonnull %endptr.i.i.i14) #35
  %15 = load ptr, ptr %endptr.i.i.i14, align 8
  %cmp.i.i.i24 = icmp eq ptr %15, %add.ptr.i3.i22
  br i1 %cmp.i.i.i24, label %luaO_str2d.exit.thread.i.i46, label %if.end.i.i.i25

luaO_str2d.exit.thread.i.i46:                     ; preds = %land.lhs.true.i.i21
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i14)
  br label %if.then.i10

if.end.i.i.i25:                                   ; preds = %land.lhs.true.i.i21
  %16 = load i8, ptr %15, align 1
  switch i8 %16, label %if.end9.i.i.i30 [
    i8 120, label %if.then6.i.i.i26
    i8 88, label %if.then6.i.i.i26
  ]

if.then6.i.i.i26:                                 ; preds = %if.end.i.i.i25, %if.end.i.i.i25
  %call7.i.i.i27 = call i64 @strtoul(ptr noundef nonnull %add.ptr.i3.i22, ptr noundef nonnull %endptr.i.i.i14, i32 noundef 16) #35
  %.pre.i.i.i28 = load ptr, ptr %endptr.i.i.i14, align 8
  %.pre5.i.i.i29 = load i8, ptr %.pre.i.i.i28, align 1
  br label %if.end9.i.i.i30

if.end9.i.i.i30:                                  ; preds = %if.then6.i.i.i26, %if.end.i.i.i25
  %17 = phi i8 [ %16, %if.end.i.i.i25 ], [ %.pre5.i.i.i29, %if.then6.i.i.i26 ]
  %endptr.promoted.i.i.i31 = phi ptr [ %15, %if.end.i.i.i25 ], [ %.pre.i.i.i28, %if.then6.i.i.i26 ]
  %cmp11.i.i.i32 = icmp eq i8 %17, 0
  br i1 %cmp11.i.i.i32, label %luaO_str2d.exit.thread9.i.i45, label %while.cond.preheader.i.i.i33

luaO_str2d.exit.thread9.i.i45:                    ; preds = %if.end9.i.i.i30
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i14)
  br label %barg.exit12

while.cond.preheader.i.i.i33:                     ; preds = %if.end9.i.i.i30
  %call15.i.i.i34 = tail call ptr @__ctype_b_loc() #39
  %18 = load ptr, ptr %call15.i.i.i34, align 8
  br label %while.cond.i.i.i35

while.cond.i.i.i35:                               ; preds = %while.cond.i.i.i35, %while.cond.preheader.i.i.i33
  %incdec.ptr4.i.i.i36 = phi ptr [ %endptr.promoted.i.i.i31, %while.cond.preheader.i.i.i33 ], [ %incdec.ptr.i.i.i40, %while.cond.i.i.i35 ]
  %19 = load i8, ptr %incdec.ptr4.i.i.i36, align 1
  %idxprom.i.i.i37 = zext i8 %19 to i64
  %arrayidx.i.i.i38 = getelementptr inbounds i16, ptr %18, i64 %idxprom.i.i.i37
  %20 = load i16, ptr %arrayidx.i.i.i38, align 2
  %21 = and i16 %20, 8192
  %tobool.not.i.i.i39 = icmp eq i16 %21, 0
  %incdec.ptr.i.i.i40 = getelementptr inbounds i8, ptr %incdec.ptr4.i.i.i36, i64 1
  br i1 %tobool.not.i.i.i39, label %luaO_str2d.exit.i.i41, label %while.cond.i.i.i35, !llvm.loop !35

luaO_str2d.exit.i.i41:                            ; preds = %while.cond.i.i.i35
  %cmp19.not.i.not.i.i42 = icmp eq i8 %19, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i14)
  br i1 %cmp19.not.i.not.i.i42, label %barg.exit12, label %if.then.i10

if.then.i10:                                      ; preds = %land.lhs.true.i7, %luaO_str2d.exit.i.i41, %luaO_str2d.exit.thread.i.i46
  tail call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 2, ptr noundef nonnull @.str.24)
  unreachable

barg.exit12:                                      ; preds = %luaO_str2d.exit.thread9.i.i45, %luaO_str2d.exit.i.i41, %land.lhs.true.i7, %barg.exit
  %22 = bitcast double %add.i to i64
  %conv.i = trunc i64 %22 to i32
  %23 = bitcast double %add.i4 to i64
  %conv.i6 = trunc i64 %23 to i32
  %and = and i32 %conv.i6, 31
  %shl = shl i32 %conv.i, %and
  %conv = sitofp i32 %shl to double
  %top.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %24 = load ptr, ptr %top.i, align 8
  store double %conv, ptr %24, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %24, i64 0, i32 1
  store i32 3, ptr %tt.i, align 8
  %25 = load ptr, ptr %top.i, align 8
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %25, i64 1
  store ptr %incdec.ptr.i, ptr %top.i, align 8
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @rshift(ptr noundef %L) #0 {
entry:
  %endptr.i.i.i14 = alloca ptr, align 8
  %endptr.i.i.i = alloca ptr, align 8
  %call.i = tail call fastcc double @lua_tonumber(ptr noundef %L, i32 noundef 1)
  %add.i = fadd double %call.i, 0x4338000000000000
  %cmp.i = fcmp oeq double %add.i, 0.000000e+00
  br i1 %cmp.i, label %land.lhs.true.i, label %barg.exit

land.lhs.true.i:                                  ; preds = %entry
  %base.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i, align 8
  %top.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i, align 8
  %cmp1.not.i.i = icmp ult ptr %0, %1
  %add.ptr.luaO_nilobject_.i.i = select i1 %cmp1.not.i.i, ptr %0, ptr @luaO_nilobject_
  %tt.i13 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i, i64 0, i32 1
  %2 = load i32, ptr %tt.i13, align 8
  switch i32 %2, label %if.then.i [
    i32 3, label %barg.exit
    i32 4, label %land.lhs.true.i.i
  ]

land.lhs.true.i.i:                                ; preds = %land.lhs.true.i
  %3 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i, align 8
  %add.ptr.i3.i = getelementptr inbounds %union.TString, ptr %3, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i.i)
  %call.i.i.i = call double @strtod(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i) #35
  %4 = load ptr, ptr %endptr.i.i.i, align 8
  %cmp.i.i.i = icmp eq ptr %4, %add.ptr.i3.i
  br i1 %cmp.i.i.i, label %luaO_str2d.exit.thread.i.i, label %if.end.i.i.i

luaO_str2d.exit.thread.i.i:                       ; preds = %land.lhs.true.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %if.then.i

if.end.i.i.i:                                     ; preds = %land.lhs.true.i.i
  %5 = load i8, ptr %4, align 1
  switch i8 %5, label %if.end9.i.i.i [
    i8 120, label %if.then6.i.i.i
    i8 88, label %if.then6.i.i.i
  ]

if.then6.i.i.i:                                   ; preds = %if.end.i.i.i, %if.end.i.i.i
  %call7.i.i.i = call i64 @strtoul(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i, i32 noundef 16) #35
  %.pre.i.i.i = load ptr, ptr %endptr.i.i.i, align 8
  %.pre5.i.i.i = load i8, ptr %.pre.i.i.i, align 1
  br label %if.end9.i.i.i

if.end9.i.i.i:                                    ; preds = %if.then6.i.i.i, %if.end.i.i.i
  %6 = phi i8 [ %5, %if.end.i.i.i ], [ %.pre5.i.i.i, %if.then6.i.i.i ]
  %endptr.promoted.i.i.i = phi ptr [ %4, %if.end.i.i.i ], [ %.pre.i.i.i, %if.then6.i.i.i ]
  %cmp11.i.i.i = icmp eq i8 %6, 0
  br i1 %cmp11.i.i.i, label %luaO_str2d.exit.thread9.i.i, label %while.cond.preheader.i.i.i

luaO_str2d.exit.thread9.i.i:                      ; preds = %if.end9.i.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %barg.exit

while.cond.preheader.i.i.i:                       ; preds = %if.end9.i.i.i
  %call15.i.i.i = tail call ptr @__ctype_b_loc() #39
  %7 = load ptr, ptr %call15.i.i.i, align 8
  br label %while.cond.i.i.i

while.cond.i.i.i:                                 ; preds = %while.cond.i.i.i, %while.cond.preheader.i.i.i
  %incdec.ptr4.i.i.i = phi ptr [ %endptr.promoted.i.i.i, %while.cond.preheader.i.i.i ], [ %incdec.ptr.i.i.i, %while.cond.i.i.i ]
  %8 = load i8, ptr %incdec.ptr4.i.i.i, align 1
  %idxprom.i.i.i = zext i8 %8 to i64
  %arrayidx.i.i.i = getelementptr inbounds i16, ptr %7, i64 %idxprom.i.i.i
  %9 = load i16, ptr %arrayidx.i.i.i, align 2
  %10 = and i16 %9, 8192
  %tobool.not.i.i.i = icmp eq i16 %10, 0
  %incdec.ptr.i.i.i = getelementptr inbounds i8, ptr %incdec.ptr4.i.i.i, i64 1
  br i1 %tobool.not.i.i.i, label %luaO_str2d.exit.i.i, label %while.cond.i.i.i, !llvm.loop !35

luaO_str2d.exit.i.i:                              ; preds = %while.cond.i.i.i
  %cmp19.not.i.not.i.i = icmp eq i8 %8, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br i1 %cmp19.not.i.not.i.i, label %barg.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true.i, %luaO_str2d.exit.i.i, %luaO_str2d.exit.thread.i.i
  tail call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 1, ptr noundef nonnull @.str.24)
  unreachable

barg.exit:                                        ; preds = %luaO_str2d.exit.thread9.i.i, %luaO_str2d.exit.i.i, %land.lhs.true.i, %entry
  %call.i3 = tail call fastcc double @lua_tonumber(ptr noundef %L, i32 noundef 2)
  %add.i4 = fadd double %call.i3, 0x4338000000000000
  %cmp.i5 = fcmp oeq double %add.i4, 0.000000e+00
  br i1 %cmp.i5, label %land.lhs.true.i7, label %barg.exit12

land.lhs.true.i7:                                 ; preds = %barg.exit
  %base.i.i15 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %11 = load ptr, ptr %base.i.i15, align 8
  %add.ptr.i.i16 = getelementptr %struct.lua_TValue, ptr %11, i64 1
  %top.i.i17 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %12 = load ptr, ptr %top.i.i17, align 8
  %cmp1.not.i.i18 = icmp ult ptr %add.ptr.i.i16, %12
  %add.ptr.luaO_nilobject_.i.i19 = select i1 %cmp1.not.i.i18, ptr %add.ptr.i.i16, ptr @luaO_nilobject_
  %tt.i20 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i19, i64 0, i32 1
  %13 = load i32, ptr %tt.i20, align 8
  switch i32 %13, label %if.then.i10 [
    i32 3, label %barg.exit12
    i32 4, label %land.lhs.true.i.i21
  ]

land.lhs.true.i.i21:                              ; preds = %land.lhs.true.i7
  %14 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i19, align 8
  %add.ptr.i3.i22 = getelementptr inbounds %union.TString, ptr %14, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i.i14)
  %call.i.i.i23 = call double @strtod(ptr noundef nonnull %add.ptr.i3.i22, ptr noundef nonnull %endptr.i.i.i14) #35
  %15 = load ptr, ptr %endptr.i.i.i14, align 8
  %cmp.i.i.i24 = icmp eq ptr %15, %add.ptr.i3.i22
  br i1 %cmp.i.i.i24, label %luaO_str2d.exit.thread.i.i46, label %if.end.i.i.i25

luaO_str2d.exit.thread.i.i46:                     ; preds = %land.lhs.true.i.i21
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i14)
  br label %if.then.i10

if.end.i.i.i25:                                   ; preds = %land.lhs.true.i.i21
  %16 = load i8, ptr %15, align 1
  switch i8 %16, label %if.end9.i.i.i30 [
    i8 120, label %if.then6.i.i.i26
    i8 88, label %if.then6.i.i.i26
  ]

if.then6.i.i.i26:                                 ; preds = %if.end.i.i.i25, %if.end.i.i.i25
  %call7.i.i.i27 = call i64 @strtoul(ptr noundef nonnull %add.ptr.i3.i22, ptr noundef nonnull %endptr.i.i.i14, i32 noundef 16) #35
  %.pre.i.i.i28 = load ptr, ptr %endptr.i.i.i14, align 8
  %.pre5.i.i.i29 = load i8, ptr %.pre.i.i.i28, align 1
  br label %if.end9.i.i.i30

if.end9.i.i.i30:                                  ; preds = %if.then6.i.i.i26, %if.end.i.i.i25
  %17 = phi i8 [ %16, %if.end.i.i.i25 ], [ %.pre5.i.i.i29, %if.then6.i.i.i26 ]
  %endptr.promoted.i.i.i31 = phi ptr [ %15, %if.end.i.i.i25 ], [ %.pre.i.i.i28, %if.then6.i.i.i26 ]
  %cmp11.i.i.i32 = icmp eq i8 %17, 0
  br i1 %cmp11.i.i.i32, label %luaO_str2d.exit.thread9.i.i45, label %while.cond.preheader.i.i.i33

luaO_str2d.exit.thread9.i.i45:                    ; preds = %if.end9.i.i.i30
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i14)
  br label %barg.exit12

while.cond.preheader.i.i.i33:                     ; preds = %if.end9.i.i.i30
  %call15.i.i.i34 = tail call ptr @__ctype_b_loc() #39
  %18 = load ptr, ptr %call15.i.i.i34, align 8
  br label %while.cond.i.i.i35

while.cond.i.i.i35:                               ; preds = %while.cond.i.i.i35, %while.cond.preheader.i.i.i33
  %incdec.ptr4.i.i.i36 = phi ptr [ %endptr.promoted.i.i.i31, %while.cond.preheader.i.i.i33 ], [ %incdec.ptr.i.i.i40, %while.cond.i.i.i35 ]
  %19 = load i8, ptr %incdec.ptr4.i.i.i36, align 1
  %idxprom.i.i.i37 = zext i8 %19 to i64
  %arrayidx.i.i.i38 = getelementptr inbounds i16, ptr %18, i64 %idxprom.i.i.i37
  %20 = load i16, ptr %arrayidx.i.i.i38, align 2
  %21 = and i16 %20, 8192
  %tobool.not.i.i.i39 = icmp eq i16 %21, 0
  %incdec.ptr.i.i.i40 = getelementptr inbounds i8, ptr %incdec.ptr4.i.i.i36, i64 1
  br i1 %tobool.not.i.i.i39, label %luaO_str2d.exit.i.i41, label %while.cond.i.i.i35, !llvm.loop !35

luaO_str2d.exit.i.i41:                            ; preds = %while.cond.i.i.i35
  %cmp19.not.i.not.i.i42 = icmp eq i8 %19, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i14)
  br i1 %cmp19.not.i.not.i.i42, label %barg.exit12, label %if.then.i10

if.then.i10:                                      ; preds = %land.lhs.true.i7, %luaO_str2d.exit.i.i41, %luaO_str2d.exit.thread.i.i46
  tail call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 2, ptr noundef nonnull @.str.24)
  unreachable

barg.exit12:                                      ; preds = %luaO_str2d.exit.thread9.i.i45, %luaO_str2d.exit.i.i41, %land.lhs.true.i7, %barg.exit
  %22 = bitcast double %add.i to i64
  %conv.i = trunc i64 %22 to i32
  %23 = bitcast double %add.i4 to i64
  %conv.i6 = trunc i64 %23 to i32
  %and = and i32 %conv.i6, 31
  %shr = lshr i32 %conv.i, %and
  %conv = sitofp i32 %shr to double
  %top.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %24 = load ptr, ptr %top.i, align 8
  store double %conv, ptr %24, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %24, i64 0, i32 1
  store i32 3, ptr %tt.i, align 8
  %25 = load ptr, ptr %top.i, align 8
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %25, i64 1
  store ptr %incdec.ptr.i, ptr %top.i, align 8
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @arshift(ptr noundef %L) #0 {
entry:
  %endptr.i.i.i14 = alloca ptr, align 8
  %endptr.i.i.i = alloca ptr, align 8
  %call.i = tail call fastcc double @lua_tonumber(ptr noundef %L, i32 noundef 1)
  %add.i = fadd double %call.i, 0x4338000000000000
  %cmp.i = fcmp oeq double %add.i, 0.000000e+00
  br i1 %cmp.i, label %land.lhs.true.i, label %barg.exit

land.lhs.true.i:                                  ; preds = %entry
  %base.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i, align 8
  %top.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i, align 8
  %cmp1.not.i.i = icmp ult ptr %0, %1
  %add.ptr.luaO_nilobject_.i.i = select i1 %cmp1.not.i.i, ptr %0, ptr @luaO_nilobject_
  %tt.i13 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i, i64 0, i32 1
  %2 = load i32, ptr %tt.i13, align 8
  switch i32 %2, label %if.then.i [
    i32 3, label %barg.exit
    i32 4, label %land.lhs.true.i.i
  ]

land.lhs.true.i.i:                                ; preds = %land.lhs.true.i
  %3 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i, align 8
  %add.ptr.i3.i = getelementptr inbounds %union.TString, ptr %3, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i.i)
  %call.i.i.i = call double @strtod(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i) #35
  %4 = load ptr, ptr %endptr.i.i.i, align 8
  %cmp.i.i.i = icmp eq ptr %4, %add.ptr.i3.i
  br i1 %cmp.i.i.i, label %luaO_str2d.exit.thread.i.i, label %if.end.i.i.i

luaO_str2d.exit.thread.i.i:                       ; preds = %land.lhs.true.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %if.then.i

if.end.i.i.i:                                     ; preds = %land.lhs.true.i.i
  %5 = load i8, ptr %4, align 1
  switch i8 %5, label %if.end9.i.i.i [
    i8 120, label %if.then6.i.i.i
    i8 88, label %if.then6.i.i.i
  ]

if.then6.i.i.i:                                   ; preds = %if.end.i.i.i, %if.end.i.i.i
  %call7.i.i.i = call i64 @strtoul(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i, i32 noundef 16) #35
  %.pre.i.i.i = load ptr, ptr %endptr.i.i.i, align 8
  %.pre5.i.i.i = load i8, ptr %.pre.i.i.i, align 1
  br label %if.end9.i.i.i

if.end9.i.i.i:                                    ; preds = %if.then6.i.i.i, %if.end.i.i.i
  %6 = phi i8 [ %5, %if.end.i.i.i ], [ %.pre5.i.i.i, %if.then6.i.i.i ]
  %endptr.promoted.i.i.i = phi ptr [ %4, %if.end.i.i.i ], [ %.pre.i.i.i, %if.then6.i.i.i ]
  %cmp11.i.i.i = icmp eq i8 %6, 0
  br i1 %cmp11.i.i.i, label %luaO_str2d.exit.thread9.i.i, label %while.cond.preheader.i.i.i

luaO_str2d.exit.thread9.i.i:                      ; preds = %if.end9.i.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %barg.exit

while.cond.preheader.i.i.i:                       ; preds = %if.end9.i.i.i
  %call15.i.i.i = tail call ptr @__ctype_b_loc() #39
  %7 = load ptr, ptr %call15.i.i.i, align 8
  br label %while.cond.i.i.i

while.cond.i.i.i:                                 ; preds = %while.cond.i.i.i, %while.cond.preheader.i.i.i
  %incdec.ptr4.i.i.i = phi ptr [ %endptr.promoted.i.i.i, %while.cond.preheader.i.i.i ], [ %incdec.ptr.i.i.i, %while.cond.i.i.i ]
  %8 = load i8, ptr %incdec.ptr4.i.i.i, align 1
  %idxprom.i.i.i = zext i8 %8 to i64
  %arrayidx.i.i.i = getelementptr inbounds i16, ptr %7, i64 %idxprom.i.i.i
  %9 = load i16, ptr %arrayidx.i.i.i, align 2
  %10 = and i16 %9, 8192
  %tobool.not.i.i.i = icmp eq i16 %10, 0
  %incdec.ptr.i.i.i = getelementptr inbounds i8, ptr %incdec.ptr4.i.i.i, i64 1
  br i1 %tobool.not.i.i.i, label %luaO_str2d.exit.i.i, label %while.cond.i.i.i, !llvm.loop !35

luaO_str2d.exit.i.i:                              ; preds = %while.cond.i.i.i
  %cmp19.not.i.not.i.i = icmp eq i8 %8, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br i1 %cmp19.not.i.not.i.i, label %barg.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true.i, %luaO_str2d.exit.i.i, %luaO_str2d.exit.thread.i.i
  tail call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 1, ptr noundef nonnull @.str.24)
  unreachable

barg.exit:                                        ; preds = %luaO_str2d.exit.thread9.i.i, %luaO_str2d.exit.i.i, %land.lhs.true.i, %entry
  %call.i3 = tail call fastcc double @lua_tonumber(ptr noundef %L, i32 noundef 2)
  %add.i4 = fadd double %call.i3, 0x4338000000000000
  %cmp.i5 = fcmp oeq double %add.i4, 0.000000e+00
  br i1 %cmp.i5, label %land.lhs.true.i7, label %barg.exit12

land.lhs.true.i7:                                 ; preds = %barg.exit
  %base.i.i15 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %11 = load ptr, ptr %base.i.i15, align 8
  %add.ptr.i.i16 = getelementptr %struct.lua_TValue, ptr %11, i64 1
  %top.i.i17 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %12 = load ptr, ptr %top.i.i17, align 8
  %cmp1.not.i.i18 = icmp ult ptr %add.ptr.i.i16, %12
  %add.ptr.luaO_nilobject_.i.i19 = select i1 %cmp1.not.i.i18, ptr %add.ptr.i.i16, ptr @luaO_nilobject_
  %tt.i20 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i19, i64 0, i32 1
  %13 = load i32, ptr %tt.i20, align 8
  switch i32 %13, label %if.then.i10 [
    i32 3, label %barg.exit12
    i32 4, label %land.lhs.true.i.i21
  ]

land.lhs.true.i.i21:                              ; preds = %land.lhs.true.i7
  %14 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i19, align 8
  %add.ptr.i3.i22 = getelementptr inbounds %union.TString, ptr %14, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i.i14)
  %call.i.i.i23 = call double @strtod(ptr noundef nonnull %add.ptr.i3.i22, ptr noundef nonnull %endptr.i.i.i14) #35
  %15 = load ptr, ptr %endptr.i.i.i14, align 8
  %cmp.i.i.i24 = icmp eq ptr %15, %add.ptr.i3.i22
  br i1 %cmp.i.i.i24, label %luaO_str2d.exit.thread.i.i46, label %if.end.i.i.i25

luaO_str2d.exit.thread.i.i46:                     ; preds = %land.lhs.true.i.i21
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i14)
  br label %if.then.i10

if.end.i.i.i25:                                   ; preds = %land.lhs.true.i.i21
  %16 = load i8, ptr %15, align 1
  switch i8 %16, label %if.end9.i.i.i30 [
    i8 120, label %if.then6.i.i.i26
    i8 88, label %if.then6.i.i.i26
  ]

if.then6.i.i.i26:                                 ; preds = %if.end.i.i.i25, %if.end.i.i.i25
  %call7.i.i.i27 = call i64 @strtoul(ptr noundef nonnull %add.ptr.i3.i22, ptr noundef nonnull %endptr.i.i.i14, i32 noundef 16) #35
  %.pre.i.i.i28 = load ptr, ptr %endptr.i.i.i14, align 8
  %.pre5.i.i.i29 = load i8, ptr %.pre.i.i.i28, align 1
  br label %if.end9.i.i.i30

if.end9.i.i.i30:                                  ; preds = %if.then6.i.i.i26, %if.end.i.i.i25
  %17 = phi i8 [ %16, %if.end.i.i.i25 ], [ %.pre5.i.i.i29, %if.then6.i.i.i26 ]
  %endptr.promoted.i.i.i31 = phi ptr [ %15, %if.end.i.i.i25 ], [ %.pre.i.i.i28, %if.then6.i.i.i26 ]
  %cmp11.i.i.i32 = icmp eq i8 %17, 0
  br i1 %cmp11.i.i.i32, label %luaO_str2d.exit.thread9.i.i45, label %while.cond.preheader.i.i.i33

luaO_str2d.exit.thread9.i.i45:                    ; preds = %if.end9.i.i.i30
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i14)
  br label %barg.exit12

while.cond.preheader.i.i.i33:                     ; preds = %if.end9.i.i.i30
  %call15.i.i.i34 = tail call ptr @__ctype_b_loc() #39
  %18 = load ptr, ptr %call15.i.i.i34, align 8
  br label %while.cond.i.i.i35

while.cond.i.i.i35:                               ; preds = %while.cond.i.i.i35, %while.cond.preheader.i.i.i33
  %incdec.ptr4.i.i.i36 = phi ptr [ %endptr.promoted.i.i.i31, %while.cond.preheader.i.i.i33 ], [ %incdec.ptr.i.i.i40, %while.cond.i.i.i35 ]
  %19 = load i8, ptr %incdec.ptr4.i.i.i36, align 1
  %idxprom.i.i.i37 = zext i8 %19 to i64
  %arrayidx.i.i.i38 = getelementptr inbounds i16, ptr %18, i64 %idxprom.i.i.i37
  %20 = load i16, ptr %arrayidx.i.i.i38, align 2
  %21 = and i16 %20, 8192
  %tobool.not.i.i.i39 = icmp eq i16 %21, 0
  %incdec.ptr.i.i.i40 = getelementptr inbounds i8, ptr %incdec.ptr4.i.i.i36, i64 1
  br i1 %tobool.not.i.i.i39, label %luaO_str2d.exit.i.i41, label %while.cond.i.i.i35, !llvm.loop !35

luaO_str2d.exit.i.i41:                            ; preds = %while.cond.i.i.i35
  %cmp19.not.i.not.i.i42 = icmp eq i8 %19, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i14)
  br i1 %cmp19.not.i.not.i.i42, label %barg.exit12, label %if.then.i10

if.then.i10:                                      ; preds = %land.lhs.true.i7, %luaO_str2d.exit.i.i41, %luaO_str2d.exit.thread.i.i46
  tail call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 2, ptr noundef nonnull @.str.24)
  unreachable

barg.exit12:                                      ; preds = %luaO_str2d.exit.thread9.i.i45, %luaO_str2d.exit.i.i41, %land.lhs.true.i7, %barg.exit
  %22 = bitcast double %add.i to i64
  %conv.i = trunc i64 %22 to i32
  %23 = bitcast double %add.i4 to i64
  %conv.i6 = trunc i64 %23 to i32
  %and = and i32 %conv.i6, 31
  %shr = ashr i32 %conv.i, %and
  %conv = sitofp i32 %shr to double
  %top.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %24 = load ptr, ptr %top.i, align 8
  store double %conv, ptr %24, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %24, i64 0, i32 1
  store i32 3, ptr %tt.i, align 8
  %25 = load ptr, ptr %top.i, align 8
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %25, i64 1
  store ptr %incdec.ptr.i, ptr %top.i, align 8
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @rol(ptr noundef %L) #0 {
entry:
  %endptr.i.i.i16 = alloca ptr, align 8
  %endptr.i.i.i = alloca ptr, align 8
  %call.i = tail call fastcc double @lua_tonumber(ptr noundef %L, i32 noundef 1)
  %add.i = fadd double %call.i, 0x4338000000000000
  %cmp.i = fcmp oeq double %add.i, 0.000000e+00
  br i1 %cmp.i, label %land.lhs.true.i, label %barg.exit

land.lhs.true.i:                                  ; preds = %entry
  %base.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i, align 8
  %top.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i, align 8
  %cmp1.not.i.i = icmp ult ptr %0, %1
  %add.ptr.luaO_nilobject_.i.i = select i1 %cmp1.not.i.i, ptr %0, ptr @luaO_nilobject_
  %tt.i15 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i, i64 0, i32 1
  %2 = load i32, ptr %tt.i15, align 8
  switch i32 %2, label %if.then.i [
    i32 3, label %barg.exit
    i32 4, label %land.lhs.true.i.i
  ]

land.lhs.true.i.i:                                ; preds = %land.lhs.true.i
  %3 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i, align 8
  %add.ptr.i3.i = getelementptr inbounds %union.TString, ptr %3, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i.i)
  %call.i.i.i = call double @strtod(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i) #35
  %4 = load ptr, ptr %endptr.i.i.i, align 8
  %cmp.i.i.i = icmp eq ptr %4, %add.ptr.i3.i
  br i1 %cmp.i.i.i, label %luaO_str2d.exit.thread.i.i, label %if.end.i.i.i

luaO_str2d.exit.thread.i.i:                       ; preds = %land.lhs.true.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %if.then.i

if.end.i.i.i:                                     ; preds = %land.lhs.true.i.i
  %5 = load i8, ptr %4, align 1
  switch i8 %5, label %if.end9.i.i.i [
    i8 120, label %if.then6.i.i.i
    i8 88, label %if.then6.i.i.i
  ]

if.then6.i.i.i:                                   ; preds = %if.end.i.i.i, %if.end.i.i.i
  %call7.i.i.i = call i64 @strtoul(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i, i32 noundef 16) #35
  %.pre.i.i.i = load ptr, ptr %endptr.i.i.i, align 8
  %.pre5.i.i.i = load i8, ptr %.pre.i.i.i, align 1
  br label %if.end9.i.i.i

if.end9.i.i.i:                                    ; preds = %if.then6.i.i.i, %if.end.i.i.i
  %6 = phi i8 [ %5, %if.end.i.i.i ], [ %.pre5.i.i.i, %if.then6.i.i.i ]
  %endptr.promoted.i.i.i = phi ptr [ %4, %if.end.i.i.i ], [ %.pre.i.i.i, %if.then6.i.i.i ]
  %cmp11.i.i.i = icmp eq i8 %6, 0
  br i1 %cmp11.i.i.i, label %luaO_str2d.exit.thread9.i.i, label %while.cond.preheader.i.i.i

luaO_str2d.exit.thread9.i.i:                      ; preds = %if.end9.i.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %barg.exit

while.cond.preheader.i.i.i:                       ; preds = %if.end9.i.i.i
  %call15.i.i.i = tail call ptr @__ctype_b_loc() #39
  %7 = load ptr, ptr %call15.i.i.i, align 8
  br label %while.cond.i.i.i

while.cond.i.i.i:                                 ; preds = %while.cond.i.i.i, %while.cond.preheader.i.i.i
  %incdec.ptr4.i.i.i = phi ptr [ %endptr.promoted.i.i.i, %while.cond.preheader.i.i.i ], [ %incdec.ptr.i.i.i, %while.cond.i.i.i ]
  %8 = load i8, ptr %incdec.ptr4.i.i.i, align 1
  %idxprom.i.i.i = zext i8 %8 to i64
  %arrayidx.i.i.i = getelementptr inbounds i16, ptr %7, i64 %idxprom.i.i.i
  %9 = load i16, ptr %arrayidx.i.i.i, align 2
  %10 = and i16 %9, 8192
  %tobool.not.i.i.i = icmp eq i16 %10, 0
  %incdec.ptr.i.i.i = getelementptr inbounds i8, ptr %incdec.ptr4.i.i.i, i64 1
  br i1 %tobool.not.i.i.i, label %luaO_str2d.exit.i.i, label %while.cond.i.i.i, !llvm.loop !35

luaO_str2d.exit.i.i:                              ; preds = %while.cond.i.i.i
  %cmp19.not.i.not.i.i = icmp eq i8 %8, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br i1 %cmp19.not.i.not.i.i, label %barg.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true.i, %luaO_str2d.exit.i.i, %luaO_str2d.exit.thread.i.i
  tail call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 1, ptr noundef nonnull @.str.24)
  unreachable

barg.exit:                                        ; preds = %luaO_str2d.exit.thread9.i.i, %luaO_str2d.exit.i.i, %land.lhs.true.i, %entry
  %call.i5 = tail call fastcc double @lua_tonumber(ptr noundef %L, i32 noundef 2)
  %add.i6 = fadd double %call.i5, 0x4338000000000000
  %cmp.i7 = fcmp oeq double %add.i6, 0.000000e+00
  br i1 %cmp.i7, label %land.lhs.true.i9, label %barg.exit14

land.lhs.true.i9:                                 ; preds = %barg.exit
  %base.i.i17 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %11 = load ptr, ptr %base.i.i17, align 8
  %add.ptr.i.i18 = getelementptr %struct.lua_TValue, ptr %11, i64 1
  %top.i.i19 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %12 = load ptr, ptr %top.i.i19, align 8
  %cmp1.not.i.i20 = icmp ult ptr %add.ptr.i.i18, %12
  %add.ptr.luaO_nilobject_.i.i21 = select i1 %cmp1.not.i.i20, ptr %add.ptr.i.i18, ptr @luaO_nilobject_
  %tt.i22 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i21, i64 0, i32 1
  %13 = load i32, ptr %tt.i22, align 8
  switch i32 %13, label %if.then.i12 [
    i32 3, label %barg.exit14
    i32 4, label %land.lhs.true.i.i23
  ]

land.lhs.true.i.i23:                              ; preds = %land.lhs.true.i9
  %14 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i21, align 8
  %add.ptr.i3.i24 = getelementptr inbounds %union.TString, ptr %14, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i.i16)
  %call.i.i.i25 = call double @strtod(ptr noundef nonnull %add.ptr.i3.i24, ptr noundef nonnull %endptr.i.i.i16) #35
  %15 = load ptr, ptr %endptr.i.i.i16, align 8
  %cmp.i.i.i26 = icmp eq ptr %15, %add.ptr.i3.i24
  br i1 %cmp.i.i.i26, label %luaO_str2d.exit.thread.i.i48, label %if.end.i.i.i27

luaO_str2d.exit.thread.i.i48:                     ; preds = %land.lhs.true.i.i23
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i16)
  br label %if.then.i12

if.end.i.i.i27:                                   ; preds = %land.lhs.true.i.i23
  %16 = load i8, ptr %15, align 1
  switch i8 %16, label %if.end9.i.i.i32 [
    i8 120, label %if.then6.i.i.i28
    i8 88, label %if.then6.i.i.i28
  ]

if.then6.i.i.i28:                                 ; preds = %if.end.i.i.i27, %if.end.i.i.i27
  %call7.i.i.i29 = call i64 @strtoul(ptr noundef nonnull %add.ptr.i3.i24, ptr noundef nonnull %endptr.i.i.i16, i32 noundef 16) #35
  %.pre.i.i.i30 = load ptr, ptr %endptr.i.i.i16, align 8
  %.pre5.i.i.i31 = load i8, ptr %.pre.i.i.i30, align 1
  br label %if.end9.i.i.i32

if.end9.i.i.i32:                                  ; preds = %if.then6.i.i.i28, %if.end.i.i.i27
  %17 = phi i8 [ %16, %if.end.i.i.i27 ], [ %.pre5.i.i.i31, %if.then6.i.i.i28 ]
  %endptr.promoted.i.i.i33 = phi ptr [ %15, %if.end.i.i.i27 ], [ %.pre.i.i.i30, %if.then6.i.i.i28 ]
  %cmp11.i.i.i34 = icmp eq i8 %17, 0
  br i1 %cmp11.i.i.i34, label %luaO_str2d.exit.thread9.i.i47, label %while.cond.preheader.i.i.i35

luaO_str2d.exit.thread9.i.i47:                    ; preds = %if.end9.i.i.i32
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i16)
  br label %barg.exit14

while.cond.preheader.i.i.i35:                     ; preds = %if.end9.i.i.i32
  %call15.i.i.i36 = tail call ptr @__ctype_b_loc() #39
  %18 = load ptr, ptr %call15.i.i.i36, align 8
  br label %while.cond.i.i.i37

while.cond.i.i.i37:                               ; preds = %while.cond.i.i.i37, %while.cond.preheader.i.i.i35
  %incdec.ptr4.i.i.i38 = phi ptr [ %endptr.promoted.i.i.i33, %while.cond.preheader.i.i.i35 ], [ %incdec.ptr.i.i.i42, %while.cond.i.i.i37 ]
  %19 = load i8, ptr %incdec.ptr4.i.i.i38, align 1
  %idxprom.i.i.i39 = zext i8 %19 to i64
  %arrayidx.i.i.i40 = getelementptr inbounds i16, ptr %18, i64 %idxprom.i.i.i39
  %20 = load i16, ptr %arrayidx.i.i.i40, align 2
  %21 = and i16 %20, 8192
  %tobool.not.i.i.i41 = icmp eq i16 %21, 0
  %incdec.ptr.i.i.i42 = getelementptr inbounds i8, ptr %incdec.ptr4.i.i.i38, i64 1
  br i1 %tobool.not.i.i.i41, label %luaO_str2d.exit.i.i43, label %while.cond.i.i.i37, !llvm.loop !35

luaO_str2d.exit.i.i43:                            ; preds = %while.cond.i.i.i37
  %cmp19.not.i.not.i.i44 = icmp eq i8 %19, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i16)
  br i1 %cmp19.not.i.not.i.i44, label %barg.exit14, label %if.then.i12

if.then.i12:                                      ; preds = %land.lhs.true.i9, %luaO_str2d.exit.i.i43, %luaO_str2d.exit.thread.i.i48
  tail call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 2, ptr noundef nonnull @.str.24)
  unreachable

barg.exit14:                                      ; preds = %luaO_str2d.exit.thread9.i.i47, %luaO_str2d.exit.i.i43, %land.lhs.true.i9, %barg.exit
  %22 = bitcast double %add.i to i64
  %conv.i = trunc i64 %22 to i32
  %23 = bitcast double %add.i6 to i64
  %conv.i8 = trunc i64 %23 to i32
  %or = tail call i32 @llvm.fshl.i32(i32 %conv.i, i32 %conv.i, i32 %conv.i8)
  %conv = sitofp i32 %or to double
  %top.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %24 = load ptr, ptr %top.i, align 8
  store double %conv, ptr %24, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %24, i64 0, i32 1
  store i32 3, ptr %tt.i, align 8
  %25 = load ptr, ptr %top.i, align 8
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %25, i64 1
  store ptr %incdec.ptr.i, ptr %top.i, align 8
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @ror(ptr noundef %L) #0 {
entry:
  %endptr.i.i.i16 = alloca ptr, align 8
  %endptr.i.i.i = alloca ptr, align 8
  %call.i = tail call fastcc double @lua_tonumber(ptr noundef %L, i32 noundef 1)
  %add.i = fadd double %call.i, 0x4338000000000000
  %cmp.i = fcmp oeq double %add.i, 0.000000e+00
  br i1 %cmp.i, label %land.lhs.true.i, label %barg.exit

land.lhs.true.i:                                  ; preds = %entry
  %base.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i, align 8
  %top.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i, align 8
  %cmp1.not.i.i = icmp ult ptr %0, %1
  %add.ptr.luaO_nilobject_.i.i = select i1 %cmp1.not.i.i, ptr %0, ptr @luaO_nilobject_
  %tt.i15 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i, i64 0, i32 1
  %2 = load i32, ptr %tt.i15, align 8
  switch i32 %2, label %if.then.i [
    i32 3, label %barg.exit
    i32 4, label %land.lhs.true.i.i
  ]

land.lhs.true.i.i:                                ; preds = %land.lhs.true.i
  %3 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i, align 8
  %add.ptr.i3.i = getelementptr inbounds %union.TString, ptr %3, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i.i)
  %call.i.i.i = call double @strtod(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i) #35
  %4 = load ptr, ptr %endptr.i.i.i, align 8
  %cmp.i.i.i = icmp eq ptr %4, %add.ptr.i3.i
  br i1 %cmp.i.i.i, label %luaO_str2d.exit.thread.i.i, label %if.end.i.i.i

luaO_str2d.exit.thread.i.i:                       ; preds = %land.lhs.true.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %if.then.i

if.end.i.i.i:                                     ; preds = %land.lhs.true.i.i
  %5 = load i8, ptr %4, align 1
  switch i8 %5, label %if.end9.i.i.i [
    i8 120, label %if.then6.i.i.i
    i8 88, label %if.then6.i.i.i
  ]

if.then6.i.i.i:                                   ; preds = %if.end.i.i.i, %if.end.i.i.i
  %call7.i.i.i = call i64 @strtoul(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i, i32 noundef 16) #35
  %.pre.i.i.i = load ptr, ptr %endptr.i.i.i, align 8
  %.pre5.i.i.i = load i8, ptr %.pre.i.i.i, align 1
  br label %if.end9.i.i.i

if.end9.i.i.i:                                    ; preds = %if.then6.i.i.i, %if.end.i.i.i
  %6 = phi i8 [ %5, %if.end.i.i.i ], [ %.pre5.i.i.i, %if.then6.i.i.i ]
  %endptr.promoted.i.i.i = phi ptr [ %4, %if.end.i.i.i ], [ %.pre.i.i.i, %if.then6.i.i.i ]
  %cmp11.i.i.i = icmp eq i8 %6, 0
  br i1 %cmp11.i.i.i, label %luaO_str2d.exit.thread9.i.i, label %while.cond.preheader.i.i.i

luaO_str2d.exit.thread9.i.i:                      ; preds = %if.end9.i.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %barg.exit

while.cond.preheader.i.i.i:                       ; preds = %if.end9.i.i.i
  %call15.i.i.i = tail call ptr @__ctype_b_loc() #39
  %7 = load ptr, ptr %call15.i.i.i, align 8
  br label %while.cond.i.i.i

while.cond.i.i.i:                                 ; preds = %while.cond.i.i.i, %while.cond.preheader.i.i.i
  %incdec.ptr4.i.i.i = phi ptr [ %endptr.promoted.i.i.i, %while.cond.preheader.i.i.i ], [ %incdec.ptr.i.i.i, %while.cond.i.i.i ]
  %8 = load i8, ptr %incdec.ptr4.i.i.i, align 1
  %idxprom.i.i.i = zext i8 %8 to i64
  %arrayidx.i.i.i = getelementptr inbounds i16, ptr %7, i64 %idxprom.i.i.i
  %9 = load i16, ptr %arrayidx.i.i.i, align 2
  %10 = and i16 %9, 8192
  %tobool.not.i.i.i = icmp eq i16 %10, 0
  %incdec.ptr.i.i.i = getelementptr inbounds i8, ptr %incdec.ptr4.i.i.i, i64 1
  br i1 %tobool.not.i.i.i, label %luaO_str2d.exit.i.i, label %while.cond.i.i.i, !llvm.loop !35

luaO_str2d.exit.i.i:                              ; preds = %while.cond.i.i.i
  %cmp19.not.i.not.i.i = icmp eq i8 %8, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br i1 %cmp19.not.i.not.i.i, label %barg.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true.i, %luaO_str2d.exit.i.i, %luaO_str2d.exit.thread.i.i
  tail call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 1, ptr noundef nonnull @.str.24)
  unreachable

barg.exit:                                        ; preds = %luaO_str2d.exit.thread9.i.i, %luaO_str2d.exit.i.i, %land.lhs.true.i, %entry
  %call.i5 = tail call fastcc double @lua_tonumber(ptr noundef %L, i32 noundef 2)
  %add.i6 = fadd double %call.i5, 0x4338000000000000
  %cmp.i7 = fcmp oeq double %add.i6, 0.000000e+00
  br i1 %cmp.i7, label %land.lhs.true.i9, label %barg.exit14

land.lhs.true.i9:                                 ; preds = %barg.exit
  %base.i.i17 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %11 = load ptr, ptr %base.i.i17, align 8
  %add.ptr.i.i18 = getelementptr %struct.lua_TValue, ptr %11, i64 1
  %top.i.i19 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %12 = load ptr, ptr %top.i.i19, align 8
  %cmp1.not.i.i20 = icmp ult ptr %add.ptr.i.i18, %12
  %add.ptr.luaO_nilobject_.i.i21 = select i1 %cmp1.not.i.i20, ptr %add.ptr.i.i18, ptr @luaO_nilobject_
  %tt.i22 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i21, i64 0, i32 1
  %13 = load i32, ptr %tt.i22, align 8
  switch i32 %13, label %if.then.i12 [
    i32 3, label %barg.exit14
    i32 4, label %land.lhs.true.i.i23
  ]

land.lhs.true.i.i23:                              ; preds = %land.lhs.true.i9
  %14 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i21, align 8
  %add.ptr.i3.i24 = getelementptr inbounds %union.TString, ptr %14, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i.i16)
  %call.i.i.i25 = call double @strtod(ptr noundef nonnull %add.ptr.i3.i24, ptr noundef nonnull %endptr.i.i.i16) #35
  %15 = load ptr, ptr %endptr.i.i.i16, align 8
  %cmp.i.i.i26 = icmp eq ptr %15, %add.ptr.i3.i24
  br i1 %cmp.i.i.i26, label %luaO_str2d.exit.thread.i.i48, label %if.end.i.i.i27

luaO_str2d.exit.thread.i.i48:                     ; preds = %land.lhs.true.i.i23
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i16)
  br label %if.then.i12

if.end.i.i.i27:                                   ; preds = %land.lhs.true.i.i23
  %16 = load i8, ptr %15, align 1
  switch i8 %16, label %if.end9.i.i.i32 [
    i8 120, label %if.then6.i.i.i28
    i8 88, label %if.then6.i.i.i28
  ]

if.then6.i.i.i28:                                 ; preds = %if.end.i.i.i27, %if.end.i.i.i27
  %call7.i.i.i29 = call i64 @strtoul(ptr noundef nonnull %add.ptr.i3.i24, ptr noundef nonnull %endptr.i.i.i16, i32 noundef 16) #35
  %.pre.i.i.i30 = load ptr, ptr %endptr.i.i.i16, align 8
  %.pre5.i.i.i31 = load i8, ptr %.pre.i.i.i30, align 1
  br label %if.end9.i.i.i32

if.end9.i.i.i32:                                  ; preds = %if.then6.i.i.i28, %if.end.i.i.i27
  %17 = phi i8 [ %16, %if.end.i.i.i27 ], [ %.pre5.i.i.i31, %if.then6.i.i.i28 ]
  %endptr.promoted.i.i.i33 = phi ptr [ %15, %if.end.i.i.i27 ], [ %.pre.i.i.i30, %if.then6.i.i.i28 ]
  %cmp11.i.i.i34 = icmp eq i8 %17, 0
  br i1 %cmp11.i.i.i34, label %luaO_str2d.exit.thread9.i.i47, label %while.cond.preheader.i.i.i35

luaO_str2d.exit.thread9.i.i47:                    ; preds = %if.end9.i.i.i32
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i16)
  br label %barg.exit14

while.cond.preheader.i.i.i35:                     ; preds = %if.end9.i.i.i32
  %call15.i.i.i36 = tail call ptr @__ctype_b_loc() #39
  %18 = load ptr, ptr %call15.i.i.i36, align 8
  br label %while.cond.i.i.i37

while.cond.i.i.i37:                               ; preds = %while.cond.i.i.i37, %while.cond.preheader.i.i.i35
  %incdec.ptr4.i.i.i38 = phi ptr [ %endptr.promoted.i.i.i33, %while.cond.preheader.i.i.i35 ], [ %incdec.ptr.i.i.i42, %while.cond.i.i.i37 ]
  %19 = load i8, ptr %incdec.ptr4.i.i.i38, align 1
  %idxprom.i.i.i39 = zext i8 %19 to i64
  %arrayidx.i.i.i40 = getelementptr inbounds i16, ptr %18, i64 %idxprom.i.i.i39
  %20 = load i16, ptr %arrayidx.i.i.i40, align 2
  %21 = and i16 %20, 8192
  %tobool.not.i.i.i41 = icmp eq i16 %21, 0
  %incdec.ptr.i.i.i42 = getelementptr inbounds i8, ptr %incdec.ptr4.i.i.i38, i64 1
  br i1 %tobool.not.i.i.i41, label %luaO_str2d.exit.i.i43, label %while.cond.i.i.i37, !llvm.loop !35

luaO_str2d.exit.i.i43:                            ; preds = %while.cond.i.i.i37
  %cmp19.not.i.not.i.i44 = icmp eq i8 %19, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i16)
  br i1 %cmp19.not.i.not.i.i44, label %barg.exit14, label %if.then.i12

if.then.i12:                                      ; preds = %land.lhs.true.i9, %luaO_str2d.exit.i.i43, %luaO_str2d.exit.thread.i.i48
  tail call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 2, ptr noundef nonnull @.str.24)
  unreachable

barg.exit14:                                      ; preds = %luaO_str2d.exit.thread9.i.i47, %luaO_str2d.exit.i.i43, %land.lhs.true.i9, %barg.exit
  %22 = bitcast double %add.i to i64
  %conv.i = trunc i64 %22 to i32
  %23 = bitcast double %add.i6 to i64
  %conv.i8 = trunc i64 %23 to i32
  %or = tail call i32 @llvm.fshr.i32(i32 %conv.i, i32 %conv.i, i32 %conv.i8)
  %conv = sitofp i32 %or to double
  %top.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %24 = load ptr, ptr %top.i, align 8
  store double %conv, ptr %24, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %24, i64 0, i32 1
  store i32 3, ptr %tt.i, align 8
  %25 = load ptr, ptr %top.i, align 8
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %25, i64 1
  store ptr %incdec.ptr.i, ptr %top.i, align 8
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @bswap(ptr noundef %L) #0 {
entry:
  %endptr.i.i.i = alloca ptr, align 8
  %call.i = tail call fastcc double @lua_tonumber(ptr noundef %L, i32 noundef 1)
  %add.i = fadd double %call.i, 0x4338000000000000
  %cmp.i = fcmp oeq double %add.i, 0.000000e+00
  br i1 %cmp.i, label %land.lhs.true.i, label %barg.exit

land.lhs.true.i:                                  ; preds = %entry
  %base.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i, align 8
  %top.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i, align 8
  %cmp1.not.i.i = icmp ult ptr %0, %1
  %add.ptr.luaO_nilobject_.i.i = select i1 %cmp1.not.i.i, ptr %0, ptr @luaO_nilobject_
  %tt.i6 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i, i64 0, i32 1
  %2 = load i32, ptr %tt.i6, align 8
  switch i32 %2, label %if.then.i [
    i32 3, label %barg.exit
    i32 4, label %land.lhs.true.i.i
  ]

land.lhs.true.i.i:                                ; preds = %land.lhs.true.i
  %3 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i, align 8
  %add.ptr.i3.i = getelementptr inbounds %union.TString, ptr %3, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i.i)
  %call.i.i.i = call double @strtod(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i) #35
  %4 = load ptr, ptr %endptr.i.i.i, align 8
  %cmp.i.i.i = icmp eq ptr %4, %add.ptr.i3.i
  br i1 %cmp.i.i.i, label %luaO_str2d.exit.thread.i.i, label %if.end.i.i.i

luaO_str2d.exit.thread.i.i:                       ; preds = %land.lhs.true.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %if.then.i

if.end.i.i.i:                                     ; preds = %land.lhs.true.i.i
  %5 = load i8, ptr %4, align 1
  switch i8 %5, label %if.end9.i.i.i [
    i8 120, label %if.then6.i.i.i
    i8 88, label %if.then6.i.i.i
  ]

if.then6.i.i.i:                                   ; preds = %if.end.i.i.i, %if.end.i.i.i
  %call7.i.i.i = call i64 @strtoul(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i, i32 noundef 16) #35
  %.pre.i.i.i = load ptr, ptr %endptr.i.i.i, align 8
  %.pre5.i.i.i = load i8, ptr %.pre.i.i.i, align 1
  br label %if.end9.i.i.i

if.end9.i.i.i:                                    ; preds = %if.then6.i.i.i, %if.end.i.i.i
  %6 = phi i8 [ %5, %if.end.i.i.i ], [ %.pre5.i.i.i, %if.then6.i.i.i ]
  %endptr.promoted.i.i.i = phi ptr [ %4, %if.end.i.i.i ], [ %.pre.i.i.i, %if.then6.i.i.i ]
  %cmp11.i.i.i = icmp eq i8 %6, 0
  br i1 %cmp11.i.i.i, label %luaO_str2d.exit.thread9.i.i, label %while.cond.preheader.i.i.i

luaO_str2d.exit.thread9.i.i:                      ; preds = %if.end9.i.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %barg.exit

while.cond.preheader.i.i.i:                       ; preds = %if.end9.i.i.i
  %call15.i.i.i = tail call ptr @__ctype_b_loc() #39
  %7 = load ptr, ptr %call15.i.i.i, align 8
  br label %while.cond.i.i.i

while.cond.i.i.i:                                 ; preds = %while.cond.i.i.i, %while.cond.preheader.i.i.i
  %incdec.ptr4.i.i.i = phi ptr [ %endptr.promoted.i.i.i, %while.cond.preheader.i.i.i ], [ %incdec.ptr.i.i.i, %while.cond.i.i.i ]
  %8 = load i8, ptr %incdec.ptr4.i.i.i, align 1
  %idxprom.i.i.i = zext i8 %8 to i64
  %arrayidx.i.i.i = getelementptr inbounds i16, ptr %7, i64 %idxprom.i.i.i
  %9 = load i16, ptr %arrayidx.i.i.i, align 2
  %10 = and i16 %9, 8192
  %tobool.not.i.i.i = icmp eq i16 %10, 0
  %incdec.ptr.i.i.i = getelementptr inbounds i8, ptr %incdec.ptr4.i.i.i, i64 1
  br i1 %tobool.not.i.i.i, label %luaO_str2d.exit.i.i, label %while.cond.i.i.i, !llvm.loop !35

luaO_str2d.exit.i.i:                              ; preds = %while.cond.i.i.i
  %cmp19.not.i.not.i.i = icmp eq i8 %8, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br i1 %cmp19.not.i.not.i.i, label %barg.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true.i, %luaO_str2d.exit.i.i, %luaO_str2d.exit.thread.i.i
  tail call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 1, ptr noundef nonnull @.str.24)
  unreachable

barg.exit:                                        ; preds = %luaO_str2d.exit.thread9.i.i, %luaO_str2d.exit.i.i, %land.lhs.true.i, %entry
  %11 = bitcast double %add.i to i64
  %conv.i = trunc i64 %11 to i32
  %or5 = tail call i32 @llvm.bswap.i32(i32 %conv.i)
  %conv = sitofp i32 %or5 to double
  %top.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %12 = load ptr, ptr %top.i, align 8
  store double %conv, ptr %12, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %12, i64 0, i32 1
  store i32 3, ptr %tt.i, align 8
  %13 = load ptr, ptr %top.i, align 8
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %13, i64 1
  store ptr %incdec.ptr.i, ptr %top.i, align 8
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @tohex(ptr noundef %L) #0 {
entry:
  %endptr.i.i.i31 = alloca ptr, align 8
  %endptr.i.i.i = alloca ptr, align 8
  %buf = alloca [8 x i8], align 1
  %call.i = tail call fastcc double @lua_tonumber(ptr noundef %L, i32 noundef 1)
  %add.i = fadd double %call.i, 0x4338000000000000
  %cmp.i = fcmp oeq double %add.i, 0.000000e+00
  br i1 %cmp.i, label %land.lhs.true.i, label %barg.exit

land.lhs.true.i:                                  ; preds = %entry
  %base.i.i25 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %0 = load ptr, ptr %base.i.i25, align 8
  %top.i.i27 = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %1 = load ptr, ptr %top.i.i27, align 8
  %cmp1.not.i.i28 = icmp ult ptr %0, %1
  %add.ptr.luaO_nilobject_.i.i = select i1 %cmp1.not.i.i28, ptr %0, ptr @luaO_nilobject_
  %tt.i30 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i, i64 0, i32 1
  %2 = load i32, ptr %tt.i30, align 8
  switch i32 %2, label %if.then.i [
    i32 3, label %barg.exit
    i32 4, label %land.lhs.true.i.i
  ]

land.lhs.true.i.i:                                ; preds = %land.lhs.true.i
  %3 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i, align 8
  %add.ptr.i3.i = getelementptr inbounds %union.TString, ptr %3, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i.i)
  %call.i.i.i = call double @strtod(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i) #35
  %4 = load ptr, ptr %endptr.i.i.i, align 8
  %cmp.i.i.i = icmp eq ptr %4, %add.ptr.i3.i
  br i1 %cmp.i.i.i, label %luaO_str2d.exit.thread.i.i, label %if.end.i.i.i

luaO_str2d.exit.thread.i.i:                       ; preds = %land.lhs.true.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %if.then.i

if.end.i.i.i:                                     ; preds = %land.lhs.true.i.i
  %5 = load i8, ptr %4, align 1
  switch i8 %5, label %if.end9.i.i.i [
    i8 120, label %if.then6.i.i.i
    i8 88, label %if.then6.i.i.i
  ]

if.then6.i.i.i:                                   ; preds = %if.end.i.i.i, %if.end.i.i.i
  %call7.i.i.i = call i64 @strtoul(ptr noundef nonnull %add.ptr.i3.i, ptr noundef nonnull %endptr.i.i.i, i32 noundef 16) #35
  %.pre.i.i.i = load ptr, ptr %endptr.i.i.i, align 8
  %.pre5.i.i.i = load i8, ptr %.pre.i.i.i, align 1
  br label %if.end9.i.i.i

if.end9.i.i.i:                                    ; preds = %if.then6.i.i.i, %if.end.i.i.i
  %6 = phi i8 [ %5, %if.end.i.i.i ], [ %.pre5.i.i.i, %if.then6.i.i.i ]
  %endptr.promoted.i.i.i = phi ptr [ %4, %if.end.i.i.i ], [ %.pre.i.i.i, %if.then6.i.i.i ]
  %cmp11.i.i.i = icmp eq i8 %6, 0
  br i1 %cmp11.i.i.i, label %luaO_str2d.exit.thread9.i.i, label %while.cond.preheader.i.i.i

luaO_str2d.exit.thread9.i.i:                      ; preds = %if.end9.i.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br label %barg.exit

while.cond.preheader.i.i.i:                       ; preds = %if.end9.i.i.i
  %call15.i.i.i = tail call ptr @__ctype_b_loc() #39
  %7 = load ptr, ptr %call15.i.i.i, align 8
  br label %while.cond.i.i.i

while.cond.i.i.i:                                 ; preds = %while.cond.i.i.i, %while.cond.preheader.i.i.i
  %incdec.ptr4.i.i.i = phi ptr [ %endptr.promoted.i.i.i, %while.cond.preheader.i.i.i ], [ %incdec.ptr.i.i.i, %while.cond.i.i.i ]
  %8 = load i8, ptr %incdec.ptr4.i.i.i, align 1
  %idxprom.i.i.i = zext i8 %8 to i64
  %arrayidx.i.i.i = getelementptr inbounds i16, ptr %7, i64 %idxprom.i.i.i
  %9 = load i16, ptr %arrayidx.i.i.i, align 2
  %10 = and i16 %9, 8192
  %tobool.not.i.i.i = icmp eq i16 %10, 0
  %incdec.ptr.i.i.i = getelementptr inbounds i8, ptr %incdec.ptr4.i.i.i, i64 1
  br i1 %tobool.not.i.i.i, label %luaO_str2d.exit.i.i, label %while.cond.i.i.i, !llvm.loop !35

luaO_str2d.exit.i.i:                              ; preds = %while.cond.i.i.i
  %cmp19.not.i.not.i.i = icmp eq i8 %8, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i)
  br i1 %cmp19.not.i.not.i.i, label %barg.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true.i, %luaO_str2d.exit.i.i, %luaO_str2d.exit.thread.i.i
  tail call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 1, ptr noundef nonnull @.str.24)
  unreachable

barg.exit:                                        ; preds = %luaO_str2d.exit.thread9.i.i, %luaO_str2d.exit.i.i, %land.lhs.true.i, %entry
  %11 = bitcast double %add.i to i64
  %conv.i = trunc i64 %11 to i32
  %base.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %12 = load ptr, ptr %base.i.i, align 8
  %add.ptr.i.i = getelementptr %struct.lua_TValue, ptr %12, i64 1
  %top.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %13 = load ptr, ptr %top.i.i, align 8
  %cmp1.not.i.i = icmp uge ptr %add.ptr.i.i, %13
  %cmp.i11 = icmp eq ptr %add.ptr.i.i, @luaO_nilobject_
  %or.cond = or i1 %cmp1.not.i.i, %cmp.i11
  br i1 %or.cond, label %for.body.preheader, label %lua_type.exit

lua_type.exit:                                    ; preds = %barg.exit
  %tt.i = getelementptr %struct.lua_TValue, ptr %12, i64 1, i32 1
  %14 = load i32, ptr %tt.i, align 8
  %cmp = icmp eq i32 %14, -1
  br i1 %cmp, label %for.body.preheader, label %cond.false

cond.false:                                       ; preds = %lua_type.exit
  %call.i12 = tail call fastcc double @lua_tonumber(ptr noundef nonnull %L, i32 noundef 2)
  %call.i12.fr = freeze double %call.i12
  %add.i13 = fadd double %call.i12.fr, 0x4338000000000000
  %cmp.i14 = fcmp oeq double %add.i13, 0.000000e+00
  br i1 %cmp.i14, label %land.lhs.true.i16, label %cond.end

land.lhs.true.i16:                                ; preds = %cond.false
  %15 = load ptr, ptr %base.i.i, align 8
  %add.ptr.i.i33 = getelementptr %struct.lua_TValue, ptr %15, i64 1
  %16 = load ptr, ptr %top.i.i, align 8
  %cmp1.not.i.i35 = icmp ult ptr %add.ptr.i.i33, %16
  %add.ptr.luaO_nilobject_.i.i36 = select i1 %cmp1.not.i.i35, ptr %add.ptr.i.i33, ptr @luaO_nilobject_
  %tt.i38 = getelementptr inbounds %struct.lua_TValue, ptr %add.ptr.luaO_nilobject_.i.i36, i64 0, i32 1
  %17 = load i32, ptr %tt.i38, align 8
  switch i32 %17, label %if.then.i19 [
    i32 3, label %cond.end
    i32 4, label %land.lhs.true.i.i39
  ]

land.lhs.true.i.i39:                              ; preds = %land.lhs.true.i16
  %18 = load ptr, ptr %add.ptr.luaO_nilobject_.i.i36, align 8
  %add.ptr.i3.i40 = getelementptr inbounds %union.TString, ptr %18, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %endptr.i.i.i31)
  %call.i.i.i41 = call double @strtod(ptr noundef nonnull %add.ptr.i3.i40, ptr noundef nonnull %endptr.i.i.i31) #35
  %19 = load ptr, ptr %endptr.i.i.i31, align 8
  %cmp.i.i.i42 = icmp eq ptr %19, %add.ptr.i3.i40
  br i1 %cmp.i.i.i42, label %luaO_str2d.exit.thread.i.i64, label %if.end.i.i.i43

luaO_str2d.exit.thread.i.i64:                     ; preds = %land.lhs.true.i.i39
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i31)
  br label %if.then.i19

if.end.i.i.i43:                                   ; preds = %land.lhs.true.i.i39
  %20 = load i8, ptr %19, align 1
  switch i8 %20, label %if.end9.i.i.i48 [
    i8 120, label %if.then6.i.i.i44
    i8 88, label %if.then6.i.i.i44
  ]

if.then6.i.i.i44:                                 ; preds = %if.end.i.i.i43, %if.end.i.i.i43
  %call7.i.i.i45 = call i64 @strtoul(ptr noundef nonnull %add.ptr.i3.i40, ptr noundef nonnull %endptr.i.i.i31, i32 noundef 16) #35
  %.pre.i.i.i46 = load ptr, ptr %endptr.i.i.i31, align 8
  %.pre5.i.i.i47 = load i8, ptr %.pre.i.i.i46, align 1
  br label %if.end9.i.i.i48

if.end9.i.i.i48:                                  ; preds = %if.then6.i.i.i44, %if.end.i.i.i43
  %21 = phi i8 [ %20, %if.end.i.i.i43 ], [ %.pre5.i.i.i47, %if.then6.i.i.i44 ]
  %endptr.promoted.i.i.i49 = phi ptr [ %19, %if.end.i.i.i43 ], [ %.pre.i.i.i46, %if.then6.i.i.i44 ]
  %cmp11.i.i.i50 = icmp eq i8 %21, 0
  br i1 %cmp11.i.i.i50, label %luaO_str2d.exit.thread9.i.i63, label %while.cond.preheader.i.i.i51

luaO_str2d.exit.thread9.i.i63:                    ; preds = %if.end9.i.i.i48
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i31)
  br label %cond.end

while.cond.preheader.i.i.i51:                     ; preds = %if.end9.i.i.i48
  %call15.i.i.i52 = tail call ptr @__ctype_b_loc() #39
  %22 = load ptr, ptr %call15.i.i.i52, align 8
  br label %while.cond.i.i.i53

while.cond.i.i.i53:                               ; preds = %while.cond.i.i.i53, %while.cond.preheader.i.i.i51
  %incdec.ptr4.i.i.i54 = phi ptr [ %endptr.promoted.i.i.i49, %while.cond.preheader.i.i.i51 ], [ %incdec.ptr.i.i.i58, %while.cond.i.i.i53 ]
  %23 = load i8, ptr %incdec.ptr4.i.i.i54, align 1
  %idxprom.i.i.i55 = zext i8 %23 to i64
  %arrayidx.i.i.i56 = getelementptr inbounds i16, ptr %22, i64 %idxprom.i.i.i55
  %24 = load i16, ptr %arrayidx.i.i.i56, align 2
  %25 = and i16 %24, 8192
  %tobool.not.i.i.i57 = icmp eq i16 %25, 0
  %incdec.ptr.i.i.i58 = getelementptr inbounds i8, ptr %incdec.ptr4.i.i.i54, i64 1
  br i1 %tobool.not.i.i.i57, label %luaO_str2d.exit.i.i59, label %while.cond.i.i.i53, !llvm.loop !35

luaO_str2d.exit.i.i59:                            ; preds = %while.cond.i.i.i53
  %cmp19.not.i.not.i.i60 = icmp eq i8 %23, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %endptr.i.i.i31)
  br i1 %cmp19.not.i.not.i.i60, label %cond.end, label %if.then.i19

if.then.i19:                                      ; preds = %land.lhs.true.i16, %luaO_str2d.exit.i.i59, %luaO_str2d.exit.thread.i.i64
  tail call fastcc void @luaL_typerror(ptr noundef %L, i32 noundef 2, ptr noundef nonnull @.str.24)
  unreachable

cond.end:                                         ; preds = %cond.false, %land.lhs.true.i16, %luaO_str2d.exit.i.i59, %luaO_str2d.exit.thread9.i.i63
  %26 = bitcast double %add.i13 to i64
  %conv.i15 = trunc i64 %26 to i32
  %cmp3 = icmp slt i32 %conv.i15, 0
  %spec.select88 = select i1 %cmp3, ptr @.str.270, ptr @.str.269
  %cmp774.not = icmp eq i32 %conv.i15, 0
  br i1 %cmp774.not, label %for.end, label %for.body.preheader

for.body.preheader:                               ; preds = %lua_type.exit, %barg.exit, %cond.end
  %27 = phi ptr [ %spec.select88, %cond.end ], [ @.str.269, %barg.exit ], [ @.str.269, %lua_type.exit ]
  %cond8285 = phi i32 [ %conv.i15, %cond.end ], [ 8, %barg.exit ], [ 8, %lua_type.exit ]
  %smax = tail call i32 @llvm.abs.i32(i32 %cond8285, i1 false)
  %smin = tail call i32 @llvm.smin.i32(i32 %smax, i32 8)
  %28 = zext i32 %smin to i64
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %for.body
  %indvars.iv = phi i64 [ %28, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %b.075 = phi i32 [ %conv.i, %for.body.preheader ], [ %shr, %for.body ]
  %indvars.iv.next = add nsw i64 %indvars.iv, -1
  %and = and i32 %b.075, 15
  %idxprom = zext nneg i32 %and to i64
  %arrayidx = getelementptr inbounds i8, ptr %27, i64 %idxprom
  %29 = load i8, ptr %arrayidx, align 1
  %idxprom8 = and i64 %indvars.iv.next, 4294967295
  %arrayidx9 = getelementptr inbounds [8 x i8], ptr %buf, i64 0, i64 %idxprom8
  store i8 %29, ptr %arrayidx9, align 1
  %shr = lshr i32 %b.075, 4
  %30 = trunc i64 %indvars.iv to i32
  %cmp7 = icmp sgt i32 %30, 1
  br i1 %cmp7, label %for.body, label %for.end, !llvm.loop !166

for.end:                                          ; preds = %for.body, %cond.end
  %cond8286 = phi i32 [ 0, %cond.end ], [ %cond8285, %for.body ]
  %l_G.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %31 = load ptr, ptr %l_G.i, align 8
  %totalbytes.i = getelementptr inbounds %struct.global_State, ptr %31, i64 0, i32 14
  %32 = load i64, ptr %totalbytes.i, align 8
  %GCthreshold.i = getelementptr inbounds %struct.global_State, ptr %31, i64 0, i32 13
  %33 = load i64, ptr %GCthreshold.i, align 8
  %cmp.not.i = icmp ult i64 %32, %33
  br i1 %cmp.not.i, label %lua_pushlstring.exit, label %if.then.i22

if.then.i22:                                      ; preds = %for.end
  %gcstepmul.i.i = getelementptr inbounds %struct.global_State, ptr %31, i64 0, i32 18
  %34 = load i32, ptr %gcstepmul.i.i, align 4
  %mul.i.i = mul i32 %34, 10
  %conv.i.i = zext i32 %mul.i.i to i64
  %cmp.i.i = icmp eq i32 %mul.i.i, 0
  %spec.store.select.i.i = select i1 %cmp.i.i, i64 9223372036854775806, i64 %conv.i.i
  %sub.i.i = sub i64 %32, %33
  %gcdept.i.i = getelementptr inbounds %struct.global_State, ptr %31, i64 0, i32 16
  %35 = load i64, ptr %gcdept.i.i, align 8
  %add.i.i = add i64 %sub.i.i, %35
  store i64 %add.i.i, ptr %gcdept.i.i, align 8
  %gcstate.i.i = getelementptr inbounds %struct.global_State, ptr %31, i64 0, i32 4
  br label %do.body.i.i

do.body.i.i:                                      ; preds = %do.body.i.i, %if.then.i22
  %lim.0.i.i = phi i64 [ %spec.store.select.i.i, %if.then.i22 ], [ %sub2.i.i, %do.body.i.i ]
  %call.i.i = tail call fastcc i64 @singlestep(ptr noundef %L)
  %sub2.i.i = sub nsw i64 %lim.0.i.i, %call.i.i
  %36 = load i8, ptr %gcstate.i.i, align 1
  %cmp4.i.i = icmp ne i8 %36, 0
  %cmp8.i.i = icmp sgt i64 %sub2.i.i, 0
  %or.cond.i.i = select i1 %cmp4.i.i, i1 %cmp8.i.i, i1 false
  br i1 %or.cond.i.i, label %do.body.i.i, label %do.end.i.i, !llvm.loop !6

do.end.i.i:                                       ; preds = %do.body.i.i
  br i1 %cmp4.i.i, label %if.then14.i.i, label %if.else27.i.i

if.then14.i.i:                                    ; preds = %do.end.i.i
  %37 = load i64, ptr %gcdept.i.i, align 8
  %cmp16.i.i = icmp ult i64 %37, 1024
  br i1 %cmp16.i.i, label %if.then18.i.i, label %if.else.i.i

if.then18.i.i:                                    ; preds = %if.then14.i.i
  %38 = load i64, ptr %totalbytes.i, align 8
  %add20.i.i = add i64 %38, 1024
  br label %luaC_step.exit.i

if.else.i.i:                                      ; preds = %if.then14.i.i
  %sub23.i.i = add i64 %37, -1024
  store i64 %sub23.i.i, ptr %gcdept.i.i, align 8
  %39 = load i64, ptr %totalbytes.i, align 8
  br label %luaC_step.exit.i

if.else27.i.i:                                    ; preds = %do.end.i.i
  %estimate.i.i = getelementptr inbounds %struct.global_State, ptr %31, i64 0, i32 15
  %40 = load i64, ptr %estimate.i.i, align 8
  %div.i.i = udiv i64 %40, 100
  %gcpause.i.i = getelementptr inbounds %struct.global_State, ptr %31, i64 0, i32 17
  %41 = load i32, ptr %gcpause.i.i, align 8
  %conv28.i.i = sext i32 %41 to i64
  %mul29.i.i = mul i64 %div.i.i, %conv28.i.i
  br label %luaC_step.exit.i

luaC_step.exit.i:                                 ; preds = %if.else27.i.i, %if.else.i.i, %if.then18.i.i
  %add20.sink.i.i = phi i64 [ %add20.i.i, %if.then18.i.i ], [ %39, %if.else.i.i ], [ %mul29.i.i, %if.else27.i.i ]
  store i64 %add20.sink.i.i, ptr %GCthreshold.i, align 8
  br label %lua_pushlstring.exit

lua_pushlstring.exit:                             ; preds = %for.end, %luaC_step.exit.i
  %spec.select = tail call i32 @llvm.abs.i32(i32 %cond8286, i1 true)
  %spec.store.select = tail call i32 @llvm.smin.i32(i32 %spec.select, i32 8)
  %conv = zext nneg i32 %spec.store.select to i64
  %42 = load ptr, ptr %top.i.i, align 8
  %call.i23 = call fastcc ptr @luaS_newlstr(ptr noundef %L, ptr noundef nonnull %buf, i64 noundef %conv)
  store ptr %call.i23, ptr %42, align 8
  %tt.i24 = getelementptr inbounds %struct.lua_TValue, ptr %42, i64 0, i32 1
  store i32 4, ptr %tt.i24, align 8
  %43 = load ptr, ptr %top.i.i, align 8
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %43, i64 1
  store ptr %incdec.ptr.i, ptr %top.i.i, align 8
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal fastcc void @errfile(ptr noundef %L, ptr noundef %what, i32 noundef %fnameindex) unnamed_addr #0 {
entry:
  %call = tail call ptr @__errno_location() #39
  %0 = load i32, ptr %call, align 4
  %call1 = tail call ptr @strerror(i32 noundef %0) #35
  %call2 = tail call fastcc ptr @lua_tolstring(ptr noundef %L, i32 noundef %fnameindex, ptr noundef null)
  %add.ptr = getelementptr inbounds i8, ptr %call2, i64 1
  %call3 = tail call ptr (ptr, ptr, ...) @lua_pushfstring(ptr noundef %L, ptr noundef nonnull @.str.276, ptr noundef %what, ptr noundef nonnull %add.ptr, ptr noundef %call1)
  %cmp.i.i = icmp sgt i32 %fnameindex, 0
  br i1 %cmp.i.i, label %if.then.i.i, label %if.else3.i.i

if.then.i.i:                                      ; preds = %entry
  %base.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 5
  %1 = load ptr, ptr %base.i.i, align 8
  %2 = zext nneg i32 %fnameindex to i64
  %3 = getelementptr %struct.lua_TValue, ptr %1, i64 %2
  %add.ptr.i.i = getelementptr %struct.lua_TValue, ptr %3, i64 -1
  %top.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %4 = load ptr, ptr %top.i.i, align 8
  %cmp1.not.i.i = icmp ult ptr %add.ptr.i.i, %4
  %add.ptr.luaO_nilobject_.i.i = select i1 %cmp1.not.i.i, ptr %add.ptr.i.i, ptr @luaO_nilobject_
  br label %index2adr.exit.i

if.else3.i.i:                                     ; preds = %entry
  %cmp4.i.i = icmp sgt i32 %fnameindex, -10000
  br i1 %cmp4.i.i, label %if.then5.i.i, label %if.else9.i.i

if.then5.i.i:                                     ; preds = %if.else3.i.i
  %top6.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %5 = load ptr, ptr %top6.i.i, align 8
  %idx.ext7.i.i = sext i32 %fnameindex to i64
  %add.ptr8.i.i = getelementptr inbounds %struct.lua_TValue, ptr %5, i64 %idx.ext7.i.i
  br label %index2adr.exit.i

if.else9.i.i:                                     ; preds = %if.else3.i.i
  switch i32 %fnameindex, label %sw.default.i.i [
    i32 -10000, label %sw.bb.i.i
    i32 -10001, label %sw.bb10.i.i
    i32 -10002, label %sw.bb15.i.i
  ]

sw.bb.i.i:                                        ; preds = %if.else9.i.i
  %l_G.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %6 = load ptr, ptr %l_G.i.i, align 8
  %l_registry.i.i = getelementptr inbounds %struct.global_State, ptr %6, i64 0, i32 20
  br label %index2adr.exit.i

sw.bb10.i.i:                                      ; preds = %if.else9.i.i
  %ci.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %7 = load ptr, ptr %ci.i.i, align 8
  %func11.i.i = getelementptr inbounds %struct.CallInfo, ptr %7, i64 0, i32 1
  %8 = load ptr, ptr %func11.i.i, align 8
  %9 = load ptr, ptr %8, align 8
  %env.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23
  %env12.i.i = getelementptr inbounds %struct.CClosure, ptr %9, i64 0, i32 6
  %10 = load ptr, ptr %env12.i.i, align 8
  store ptr %10, ptr %env.i.i, align 8
  %tt.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 23, i32 1
  store i32 5, ptr %tt.i.i, align 8
  br label %index2adr.exit.i

sw.bb15.i.i:                                      ; preds = %if.else9.i.i
  %l_gt.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 22
  br label %index2adr.exit.i

sw.default.i.i:                                   ; preds = %if.else9.i.i
  %ci17.i.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 7
  %11 = load ptr, ptr %ci17.i.i, align 8
  %func18.i.i = getelementptr inbounds %struct.CallInfo, ptr %11, i64 0, i32 1
  %12 = load ptr, ptr %func18.i.i, align 8
  %13 = load ptr, ptr %12, align 8
  %sub20.i.i = sub nuw nsw i32 -10002, %fnameindex
  %nupvalues.i.i = getelementptr inbounds %struct.CClosure, ptr %13, i64 0, i32 4
  %14 = load i8, ptr %nupvalues.i.i, align 1
  %conv.i.i = zext i8 %14 to i32
  %cmp21.not.i.i = icmp ugt i32 %sub20.i.i, %conv.i.i
  %sub23.i.i = sub nuw nsw i32 -10003, %fnameindex
  %idxprom.i.i = zext nneg i32 %sub23.i.i to i64
  %arrayidx.i.i = getelementptr inbounds %struct.CClosure, ptr %13, i64 0, i32 8, i64 %idxprom.i.i
  %cond.i.i = select i1 %cmp21.not.i.i, ptr @luaO_nilobject_, ptr %arrayidx.i.i
  br label %index2adr.exit.i

index2adr.exit.i:                                 ; preds = %sw.default.i.i, %sw.bb15.i.i, %sw.bb10.i.i, %sw.bb.i.i, %if.then5.i.i, %if.then.i.i
  %retval.0.i.i = phi ptr [ %add.ptr8.i.i, %if.then5.i.i ], [ %cond.i.i, %sw.default.i.i ], [ %l_gt.i.i, %sw.bb15.i.i ], [ %env.i.i, %sw.bb10.i.i ], [ %l_registry.i.i, %sw.bb.i.i ], [ %add.ptr.luaO_nilobject_.i.i, %if.then.i.i ]
  %top.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 4
  %incdec.ptr7.i = getelementptr inbounds %struct.lua_TValue, ptr %retval.0.i.i, i64 1
  %15 = load ptr, ptr %top.i, align 8
  %cmp8.i = icmp ult ptr %incdec.ptr7.i, %15
  br i1 %cmp8.i, label %while.body.i, label %lua_remove.exit

while.body.i:                                     ; preds = %index2adr.exit.i, %while.body.i
  %incdec.ptr10.i = phi ptr [ %incdec.ptr.i, %while.body.i ], [ %incdec.ptr7.i, %index2adr.exit.i ]
  %p.09.i = phi ptr [ %incdec.ptr10.i, %while.body.i ], [ %retval.0.i.i, %index2adr.exit.i ]
  %16 = load i64, ptr %incdec.ptr10.i, align 8
  store i64 %16, ptr %p.09.i, align 8
  %tt.i = getelementptr inbounds %struct.lua_TValue, ptr %p.09.i, i64 1, i32 1
  %17 = load i32, ptr %tt.i, align 8
  %tt2.i = getelementptr inbounds %struct.lua_TValue, ptr %p.09.i, i64 0, i32 1
  store i32 %17, ptr %tt2.i, align 8
  %incdec.ptr.i = getelementptr inbounds %struct.lua_TValue, ptr %incdec.ptr10.i, i64 1
  %18 = load ptr, ptr %top.i, align 8
  %cmp.i = icmp ult ptr %incdec.ptr.i, %18
  br i1 %cmp.i, label %while.body.i, label %lua_remove.exit, !llvm.loop !11

lua_remove.exit:                                  ; preds = %while.body.i, %index2adr.exit.i
  %.lcssa.i = phi ptr [ %15, %index2adr.exit.i ], [ %18, %while.body.i ]
  %incdec.ptr4.i = getelementptr inbounds %struct.lua_TValue, ptr %.lcssa.i, i64 -1
  store ptr %incdec.ptr4.i, ptr %top.i, align 8
  ret void
}

declare ptr @freopen(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #25

; Function Attrs: nofree nounwind uwtable
define internal ptr @getF(ptr nocapture readnone %L, ptr noundef %ud, ptr nocapture noundef writeonly %size) #21 {
entry:
  %0 = load i32, ptr %ud, align 8
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, ptr %ud, align 8
  store i64 1, ptr %size, align 8
  br label %return

if.end:                                           ; preds = %entry
  %f = getelementptr inbounds %struct.LoadF, ptr %ud, i64 0, i32 1
  %1 = load ptr, ptr %f, align 8
  %call = tail call i32 @feof(ptr noundef %1) #35
  %tobool2.not = icmp eq i32 %call, 0
  br i1 %tobool2.not, label %if.end4, label %return

if.end4:                                          ; preds = %if.end
  %buff = getelementptr inbounds %struct.LoadF, ptr %ud, i64 0, i32 2
  %2 = load ptr, ptr %f, align 8
  %call6 = tail call i64 @fread(ptr noundef nonnull %buff, i64 noundef 1, i64 noundef 8192, ptr noundef %2)
  store i64 %call6, ptr %size, align 8
  %cmp.not = icmp eq i64 %call6, 0
  %cond = select i1 %cmp.not, ptr null, ptr %buff
  br label %return

return:                                           ; preds = %if.end, %if.end4, %if.then
  %retval.0 = phi ptr [ @.str.277, %if.then ], [ %cond, %if.end4 ], [ null, %if.end ]
  ret ptr %retval.0
}

; Function Attrs: nofree nounwind
declare noundef i32 @feof(ptr nocapture noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define internal void @f_call(ptr noundef %L, ptr nocapture noundef readonly %ud) #0 {
entry:
  %0 = load ptr, ptr %ud, align 8
  %nresults = getelementptr inbounds %struct.CallS, ptr %ud, i64 0, i32 1
  %1 = load i32, ptr %nresults, align 8
  tail call fastcc void @luaD_call(ptr noundef %L, ptr noundef %0, i32 noundef %1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @callallgcTM(ptr noundef %L, ptr nocapture readnone %ud) #0 {
entry:
  %l_G.i = getelementptr inbounds %struct.lua_State, ptr %L, i64 0, i32 6
  %0 = load ptr, ptr %l_G.i, align 8
  %tmudata2.i = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 11
  %1 = load ptr, ptr %tmudata2.i, align 8
  %tobool.not3.i = icmp eq ptr %1, null
  br i1 %tobool.not3.i, label %luaC_callGCTM.exit, label %while.body.i

while.body.i:                                     ; preds = %entry, %while.body.i
  tail call fastcc void @GCTM(ptr noundef nonnull %L)
  %2 = load ptr, ptr %l_G.i, align 8
  %tmudata.i = getelementptr inbounds %struct.global_State, ptr %2, i64 0, i32 11
  %3 = load ptr, ptr %tmudata.i, align 8
  %tobool.not.i = icmp eq ptr %3, null
  br i1 %tobool.not.i, label %luaC_callGCTM.exit, label %while.body.i, !llvm.loop !167

luaC_callGCTM.exit:                               ; preds = %while.body.i, %entry
  ret void
}

; Function Attrs: nofree nounwind willreturn memory(argmem: read)
declare i32 @bcmp(ptr nocapture, ptr nocapture, i64) local_unnamed_addr #27

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.umax.i64(i64, i64) #28

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smax.i32(i32, i32) #28

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.smax.i64(i64, i64) #28

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.fshl.i32(i32, i32, i32) #28

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.fshr.i32(i32, i32, i32) #28

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.bswap.i32(i32) #28

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smin.i32(i32, i32) #28

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #29

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #30

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #30

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.umin.i64(i64, i64) #28

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write)
declare void @llvm.assume(i1 noundef) #31

; Function Attrs: nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite)
declare noalias noundef ptr @malloc(i64 noundef) local_unnamed_addr #32

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.smin.i64(i64, i64) #28

attributes #0 = { nounwind uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { nofree nounwind "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #2 = { mustprogress nounwind willreturn memory(argmem: readwrite, inaccessiblemem: readwrite) uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { nounwind returns_twice "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #4 = { noreturn nounwind "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #5 = { mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #6 = { nofree nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #7 = { noreturn nounwind uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #8 = { mustprogress nocallback nofree nosync nounwind willreturn }
attributes #9 = { mustprogress nofree nounwind willreturn memory(readwrite, inaccessiblemem: none) uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #10 = { mustprogress nofree nounwind willreturn memory(argmem: readwrite) "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #11 = { mustprogress nofree nounwind willreturn memory(argmem: read) "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #12 = { mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #13 = { mustprogress nofree nounwind willreturn memory(write) "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #14 = { nofree norecurse nosync nounwind memory(read, inaccessiblemem: none) uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #15 = { mustprogress nofree nounwind willreturn memory(read) "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #16 = { mustprogress nofree nounwind willreturn "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #17 = { mustprogress nofree nosync nounwind willreturn memory(none) "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #18 = { nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #19 = { mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite) "alloc-family"="malloc" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #20 = { mustprogress nounwind willreturn allockind("realloc") allocsize(1) memory(argmem: readwrite, inaccessiblemem: readwrite) "alloc-family"="malloc" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #21 = { nofree nounwind uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #22 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite) uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #23 = { nounwind "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #24 = { nofree nounwind memory(read) "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #25 = { "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #26 = { mustprogress nofree nounwind willreturn memory(read) uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #27 = { nofree nounwind willreturn memory(argmem: read) }
attributes #28 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #29 = { nocallback nofree nounwind willreturn memory(argmem: write) }
attributes #30 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #31 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write) }
attributes #32 = { nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite) "alloc-family"="malloc" }
attributes #33 = { cold }
attributes #34 = { nounwind willreturn memory(read) }
attributes #35 = { nounwind }
attributes #36 = { nounwind allocsize(1) }
attributes #37 = { nounwind returns_twice }
attributes #38 = { noreturn nounwind }
attributes #39 = { nounwind willreturn memory(none) }
attributes #40 = { "function-inline-cost-multiplier"="2" }

!llvm.module.flags = !{!0, !1, !2, !3}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = distinct !{!4, !5}
!5 = !{!"llvm.loop.mustprogress"}
!6 = distinct !{!6, !5}
!7 = distinct !{!7, !5}
!8 = distinct !{!8, !5}
!9 = distinct !{!9, !5}
!10 = distinct !{!10, !5}
!11 = distinct !{!11, !5}
!12 = distinct !{!12, !5}
!13 = distinct !{!13, !5}
!14 = !{ptr @callallgcTM, ptr @f_call, ptr @f_luaopen, ptr @f_parser}
!15 = distinct !{!15, !5}
!16 = distinct !{!16, !5}
!17 = distinct !{!17, !5}
!18 = distinct !{!18, !5}
!19 = distinct !{!19, !5}
!20 = distinct !{!20, !5}
!21 = distinct !{!21, !5}
!22 = distinct !{!22, !5}
!23 = !{i32 0, i32 2}
!24 = distinct !{!24, !5}
!25 = distinct !{!25, !5}
!26 = distinct !{!26, !5}
!27 = distinct !{!27, !5}
!28 = distinct !{!28, !5}
!29 = distinct !{!29, !5}
!30 = !{i32 0, i32 3}
!31 = distinct !{!31, !5}
!32 = distinct !{!32, !5}
!33 = distinct !{!33, !5}
!34 = distinct !{!34, !5}
!35 = distinct !{!35, !5}
!36 = distinct !{!36, !5}
!37 = distinct !{!37, !5}
!38 = distinct !{!38, !5}
!39 = distinct !{!39, !5}
!40 = distinct !{!40, !5}
!41 = distinct !{!41, !5}
!42 = distinct !{!42, !5}
!43 = distinct !{!43, !5}
!44 = distinct !{!44, !5}
!45 = distinct !{!45, !5}
!46 = distinct !{!46, !5}
!47 = distinct !{!47, !5}
!48 = distinct !{!48, !5}
!49 = distinct !{!49, !5}
!50 = distinct !{!50, !5}
!51 = distinct !{!51, !5}
!52 = distinct !{!52, !5}
!53 = distinct !{!53, !5}
!54 = distinct !{!54, !5}
!55 = distinct !{!55, !5}
!56 = distinct !{!56, !5}
!57 = distinct !{!57, !5}
!58 = distinct !{!58, !5}
!59 = distinct !{!59, !5}
!60 = distinct !{!60, !5}
!61 = distinct !{!61, !5}
!62 = distinct !{!62, !5}
!63 = distinct !{!63, !5}
!64 = distinct !{!64, !5}
!65 = distinct !{!65, !5}
!66 = distinct !{!66, !5}
!67 = distinct !{!67, !5}
!68 = distinct !{!68, !5}
!69 = distinct !{!69, !5}
!70 = distinct !{!70, !5}
!71 = distinct !{!71, !5}
!72 = distinct !{!72, !5}
!73 = distinct !{!73, !5}
!74 = distinct !{!74, !5}
!75 = distinct !{!75, !5}
!76 = distinct !{!76, !5}
!77 = distinct !{!77, !5}
!78 = distinct !{!78, !5}
!79 = distinct !{!79, !5}
!80 = distinct !{!80, !5}
!81 = distinct !{!81, !5}
!82 = distinct !{!82, !5}
!83 = distinct !{!83, !5}
!84 = distinct !{!84, !5}
!85 = distinct !{!85, !5}
!86 = distinct !{!86, !5}
!87 = distinct !{!87, !5}
!88 = distinct !{!88, !5}
!89 = distinct !{!89, !5}
!90 = distinct !{!90, !5}
!91 = distinct !{!91, !5}
!92 = distinct !{!92, !5}
!93 = !{i32 0, i32 16}
!94 = distinct !{!94, !5}
!95 = distinct !{!95, !5}
!96 = distinct !{!96, !5}
!97 = distinct !{!97, !5}
!98 = distinct !{!98, !5}
!99 = distinct !{!99, !5}
!100 = distinct !{!100, !5}
!101 = distinct !{!101, !5}
!102 = distinct !{!102, !5}
!103 = distinct !{!103, !5}
!104 = !{i32 -1, i32 256}
!105 = distinct !{!105, !5}
!106 = distinct !{!106, !5}
!107 = distinct !{!107, !5}
!108 = distinct !{!108, !5}
!109 = distinct !{!109, !5}
!110 = distinct !{!110, !5}
!111 = distinct !{!111, !5}
!112 = distinct !{!112, !5}
!113 = distinct !{!113, !5}
!114 = distinct !{!114, !5}
!115 = distinct !{!115, !5}
!116 = distinct !{!116, !5}
!117 = distinct !{!117, !5}
!118 = distinct !{!118, !5}
!119 = distinct !{!119, !5}
!120 = distinct !{!120, !5}
!121 = distinct !{!121, !5}
!122 = !{i32 6, i32 9}
!123 = distinct !{!123, !5}
!124 = distinct !{!124, !5}
!125 = distinct !{!125, !5}
!126 = distinct !{!126, !5}
!127 = distinct !{!127, !5}
!128 = distinct !{!128, !5}
!129 = distinct !{!129, !5}
!130 = distinct !{!130, !5}
!131 = distinct !{!131, !5}
!132 = distinct !{!132, !5}
!133 = distinct !{!133, !5}
!134 = distinct !{!134, !5}
!135 = distinct !{!135, !5}
!136 = !{i32 1, i32 4}
!137 = distinct !{!137, !5}
!138 = distinct !{!138, !5}
!139 = distinct !{!139, !5}
!140 = distinct !{!140, !5}
!141 = distinct !{!141, !5}
!142 = distinct !{!142, !5}
!143 = distinct !{!143, !5}
!144 = distinct !{!144, !5}
!145 = distinct !{!145, !5}
!146 = distinct !{!146, !5}
!147 = distinct !{!147, !5}
!148 = distinct !{!148, !5, !149}
!149 = !{!"llvm.loop.unswitch.partial.disable"}
!150 = distinct !{!150, !5}
!151 = distinct !{!151, !5}
!152 = distinct !{!152, !5}
!153 = distinct !{!153, !5}
!154 = distinct !{!154, !5}
!155 = distinct !{!155, !5}
!156 = !{i32 0, i32 8193}
!157 = distinct !{!157, !5}
!158 = distinct !{!158, !5}
!159 = distinct !{!159, !5}
!160 = distinct !{!160, !5}
!161 = distinct !{!161, !5}
!162 = distinct !{!162, !5}
!163 = distinct !{!163, !5}
!164 = distinct !{!164, !5}
!165 = distinct !{!165, !5}
!166 = distinct !{!166, !5}
!167 = distinct !{!167, !5}
