target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.pyruntimestate = type { %struct._Py_DebugOffsets, i32, i32, i32, i32, i32, ptr, i64, %struct.pyinterpreters, i64, %struct._xi_runtime_state, %struct._pymem_allocators, %struct._obmalloc_global_state, %struct.pyhash_runtime_state, %struct._pythread_runtime_state, %struct._signals_runtime_state, %struct._Py_tss_t, %struct._Py_tss_t, %struct.PyWideStringList, %struct._parser_runtime_state, %struct._atexit_runtime_state, %struct._import_runtime_state, %struct._ceval_runtime_state, %struct._gilstate_runtime_state, %struct._getargs_runtime_state, %struct._fileutils_state, %struct._faulthandler_runtime_state, %struct._tracemalloc_runtime_state, %struct.PyPreConfig, ptr, ptr, %struct.anon.43, %struct._py_object_runtime_state, %struct._Py_float_runtime_state, %struct._Py_unicode_runtime_state, %struct._types_runtime_state, %struct._Py_cached_objects, %struct._Py_static_objects, %struct._is }
%struct._Py_DebugOffsets = type { [8 x i8], i64, %struct._runtime_state, %struct._interpreter_state, %struct._thread_state, %struct._interpreter_frame, %struct._cframe, %struct._code_object, %struct._pyobject, %struct._type_object, %struct._tuple_object }
%struct._runtime_state = type { i64, i64 }
%struct._interpreter_state = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct._thread_state = type { i64, i64, i64, i64, i64, i64 }
%struct._interpreter_frame = type { i64, i64, i64, i64, i64 }
%struct._cframe = type { i64, i64 }
%struct._code_object = type { i64, i64, i64, i64, i64, i64, i64, i64 }
%struct._pyobject = type { i64 }
%struct._type_object = type { i64 }
%struct._tuple_object = type { i64 }
%struct.pyinterpreters = type { %struct._PyMutex, ptr, ptr, i64 }
%struct._PyMutex = type { i8 }
%struct._xi_runtime_state = type { %struct._xidregistry }
%struct._xidregistry = type { i32, i32, %struct._PyMutex, ptr }
%struct._pymem_allocators = type { %struct._PyMutex, %struct.anon.4, %struct.anon.5, %struct.PyObjectArenaAllocator }
%struct.anon.4 = type { %struct.PyMemAllocatorEx, %struct.PyMemAllocatorEx, %struct.PyMemAllocatorEx }
%struct.PyMemAllocatorEx = type { ptr, ptr, ptr, ptr, ptr }
%struct.anon.5 = type { %struct.debug_alloc_api_t, %struct.debug_alloc_api_t, %struct.debug_alloc_api_t }
%struct.debug_alloc_api_t = type { i8, %struct.PyMemAllocatorEx }
%struct.PyObjectArenaAllocator = type { ptr, ptr, ptr }
%struct._obmalloc_global_state = type { i32, i64 }
%struct.pyhash_runtime_state = type { %struct.anon.6 }
%struct.anon.6 = type { i32, i64, i64 }
%struct._pythread_runtime_state = type { i32, %struct.anon.7 }
%struct.anon.7 = type { ptr, %union.pthread_condattr_t }
%union.pthread_condattr_t = type { i32 }
%struct._signals_runtime_state = type { [65 x %struct.anon.8], %struct.anon.9, i32, ptr, ptr, i32 }
%struct.anon.8 = type { i32, ptr }
%struct.anon.9 = type { i32, i32 }
%struct._Py_tss_t = type { i32, i32 }
%struct.PyWideStringList = type { i64, ptr }
%struct._parser_runtime_state = type { i32, %struct._expr }
%struct._expr = type { i32, %union.anon.10, i32, i32, i32, i32 }
%union.anon.10 = type { %struct.anon.13 }
%struct.anon.13 = type { ptr, i32, ptr }
%struct._atexit_runtime_state = type { %struct._PyMutex, [32 x ptr], i32 }
%struct._import_runtime_state = type { ptr, i64, %struct.anon.38, ptr }
%struct.anon.38 = type { %struct._PyMutex, ptr }
%struct._ceval_runtime_state = type { %struct.anon.39, %struct._pending_calls }
%struct.anon.39 = type { i32, i64, ptr, %struct.trampoline_api_st, ptr, i64 }
%struct.trampoline_api_st = type { ptr, ptr, ptr, ptr }
%struct._pending_calls = type { i32, %struct._PyMutex, i32, [32 x %struct._pending_call], i32, i32 }
%struct._pending_call = type { ptr, ptr, i32 }
%struct._gilstate_runtime_state = type { i32, ptr }
%struct._getargs_runtime_state = type { ptr }
%struct._fileutils_state = type { i32 }
%struct._faulthandler_runtime_state = type { %struct.anon.40, %struct.anon.41, ptr, %struct.stack_t, %struct.stack_t }
%struct.anon.40 = type { i32, ptr, i32, i32, ptr }
%struct.anon.41 = type { ptr, i32, i64, i32, ptr, i32, ptr, i64, ptr, ptr }
%struct.stack_t = type { ptr, i32, i64 }
%struct._tracemalloc_runtime_state = type { %struct._PyTraceMalloc_Config, %struct.anon.42, ptr, i64, i64, ptr, ptr, ptr, ptr, ptr, %struct.tracemalloc_traceback, %struct._Py_tss_t }
%struct._PyTraceMalloc_Config = type { i32, i32, i32 }
%struct.anon.42 = type { %struct.PyMemAllocatorEx, %struct.PyMemAllocatorEx, %struct.PyMemAllocatorEx }
%struct.tracemalloc_traceback = type { i64, i16, i16, [1 x %struct.tracemalloc_frame] }
%struct.tracemalloc_frame = type <{ ptr, i32 }>
%struct.PyPreConfig = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.anon.43 = type { %struct._PyMutex, ptr }
%struct._py_object_runtime_state = type { i32 }
%struct._Py_float_runtime_state = type { i32, i32 }
%struct._Py_unicode_runtime_state = type { %struct._Py_unicode_runtime_ids }
%struct._Py_unicode_runtime_ids = type { %struct._PyMutex, i64 }
%struct._types_runtime_state = type { i32 }
%struct._Py_cached_objects = type { ptr }
%struct._Py_static_objects = type { %struct.anon.44 }
%struct.anon.44 = type { [262 x %struct._longobject], %struct.PyBytesObject, [256 x %struct.anon.45], %struct._Py_global_strings, %struct.PyGC_Head, %struct.PyTupleObject, %struct.PyGC_Head, %struct.PyHamtNode_Bitmap, %struct._PyContextTokenMissing }
%struct._longobject = type { %struct._object, %struct._PyLongValue }
%struct._object = type { %union.anon, ptr }
%union.anon = type { i64 }
%struct._PyLongValue = type { i64, [1 x i32] }
%struct.PyBytesObject = type { %struct.PyVarObject, i64, [1 x i8] }
%struct.PyVarObject = type { %struct._object, i64 }
%struct.anon.45 = type { %struct.PyBytesObject, i8 }
%struct._Py_global_strings = type { %struct.anon.46, %struct.anon.74, [128 x %struct.anon.767], [128 x %struct.anon.768] }
%struct.anon.46 = type { %struct.anon.47, %struct.anon.49, %struct.anon.50, %struct.anon.51, %struct.anon.52, %struct.anon.53, %struct.anon.54, %struct.anon.55, %struct.anon.56, %struct.anon.57, %struct.anon.58, %struct.anon.59, %struct.anon.60, %struct.anon.61, %struct.anon.62, %struct.anon.63, %struct.anon.64, %struct.anon.65, %struct.anon.66, %struct.anon.67, %struct.anon.68, %struct.anon.69, %struct.anon.70, %struct.anon.71, %struct.anon.72, %struct.anon.73 }
%struct.anon.47 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.PyASCIIObject = type { %struct._object, i64, i64, %struct.anon.48 }
%struct.anon.48 = type { i32 }
%struct.anon.49 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.50 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.51 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.52 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.53 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.54 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.55 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.56 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.57 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.58 = type { %struct.PyASCIIObject, [3 x i8] }
%struct.anon.59 = type { %struct.PyASCIIObject, [3 x i8] }
%struct.anon.60 = type { %struct.PyASCIIObject, [3 x i8] }
%struct.anon.61 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.62 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.63 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.64 = type { %struct.PyASCIIObject, [1 x i8] }
%struct.anon.65 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.66 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.67 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.68 = type { %struct.PyASCIIObject, [24 x i8] }
%struct.anon.69 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.70 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.71 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.72 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.73 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.74 = type { %struct.anon.75, %struct.anon.76, %struct.anon.77, %struct.anon.78, %struct.anon.79, %struct.anon.80, %struct.anon.81, %struct.anon.82, %struct.anon.83, %struct.anon.84, %struct.anon.85, %struct.anon.86, %struct.anon.87, %struct.anon.88, %struct.anon.89, %struct.anon.90, %struct.anon.91, %struct.anon.92, %struct.anon.93, %struct.anon.94, %struct.anon.95, %struct.anon.96, %struct.anon.97, %struct.anon.98, %struct.anon.99, %struct.anon.100, %struct.anon.101, %struct.anon.102, %struct.anon.103, %struct.anon.104, %struct.anon.105, %struct.anon.106, %struct.anon.107, %struct.anon.108, %struct.anon.109, %struct.anon.110, %struct.anon.111, %struct.anon.112, %struct.anon.113, %struct.anon.114, %struct.anon.115, %struct.anon.116, %struct.anon.117, %struct.anon.118, %struct.anon.119, %struct.anon.120, %struct.anon.121, %struct.anon.122, %struct.anon.123, %struct.anon.124, %struct.anon.125, %struct.anon.126, %struct.anon.127, %struct.anon.128, %struct.anon.129, %struct.anon.130, %struct.anon.131, %struct.anon.132, %struct.anon.133, %struct.anon.134, %struct.anon.135, %struct.anon.136, %struct.anon.137, %struct.anon.138, %struct.anon.139, %struct.anon.140, %struct.anon.141, %struct.anon.142, %struct.anon.143, %struct.anon.144, %struct.anon.145, %struct.anon.146, %struct.anon.147, %struct.anon.148, %struct.anon.149, %struct.anon.150, %struct.anon.151, %struct.anon.152, %struct.anon.153, %struct.anon.154, %struct.anon.155, %struct.anon.156, %struct.anon.157, %struct.anon.158, %struct.anon.159, %struct.anon.160, %struct.anon.161, %struct.anon.162, %struct.anon.163, %struct.anon.164, %struct.anon.165, %struct.anon.166, %struct.anon.167, %struct.anon.168, %struct.anon.169, %struct.anon.170, %struct.anon.171, %struct.anon.172, %struct.anon.173, %struct.anon.174, %struct.anon.175, %struct.anon.176, %struct.anon.177, %struct.anon.178, %struct.anon.179, %struct.anon.180, %struct.anon.181, %struct.anon.182, %struct.anon.183, %struct.anon.184, %struct.anon.185, %struct.anon.186, %struct.anon.187, %struct.anon.188, %struct.anon.189, %struct.anon.190, %struct.anon.191, %struct.anon.192, %struct.anon.193, %struct.anon.194, %struct.anon.195, %struct.anon.196, %struct.anon.197, %struct.anon.198, %struct.anon.199, %struct.anon.200, %struct.anon.201, %struct.anon.202, %struct.anon.203, %struct.anon.204, %struct.anon.205, %struct.anon.206, %struct.anon.207, %struct.anon.208, %struct.anon.209, %struct.anon.210, %struct.anon.211, %struct.anon.212, %struct.anon.213, %struct.anon.214, %struct.anon.215, %struct.anon.216, %struct.anon.217, %struct.anon.218, %struct.anon.219, %struct.anon.220, %struct.anon.221, %struct.anon.222, %struct.anon.223, %struct.anon.224, %struct.anon.225, %struct.anon.226, %struct.anon.227, %struct.anon.228, %struct.anon.229, %struct.anon.230, %struct.anon.231, %struct.anon.232, %struct.anon.233, %struct.anon.234, %struct.anon.235, %struct.anon.236, %struct.anon.237, %struct.anon.238, %struct.anon.239, %struct.anon.240, %struct.anon.241, %struct.anon.242, %struct.anon.243, %struct.anon.244, %struct.anon.245, %struct.anon.246, %struct.anon.247, %struct.anon.248, %struct.anon.249, %struct.anon.250, %struct.anon.251, %struct.anon.252, %struct.anon.253, %struct.anon.254, %struct.anon.255, %struct.anon.256, %struct.anon.257, %struct.anon.258, %struct.anon.259, %struct.anon.260, %struct.anon.261, %struct.anon.262, %struct.anon.263, %struct.anon.264, %struct.anon.265, %struct.anon.266, %struct.anon.267, %struct.anon.268, %struct.anon.269, %struct.anon.270, %struct.anon.271, %struct.anon.272, %struct.anon.273, %struct.anon.274, %struct.anon.275, %struct.anon.276, %struct.anon.277, %struct.anon.278, %struct.anon.279, %struct.anon.280, %struct.anon.281, %struct.anon.282, %struct.anon.283, %struct.anon.284, %struct.anon.285, %struct.anon.286, %struct.anon.287, %struct.anon.288, %struct.anon.289, %struct.anon.290, %struct.anon.291, %struct.anon.292, %struct.anon.293, %struct.anon.294, %struct.anon.295, %struct.anon.296, %struct.anon.297, %struct.anon.298, %struct.anon.299, %struct.anon.300, %struct.anon.301, %struct.anon.302, %struct.anon.303, %struct.anon.304, %struct.anon.305, %struct.anon.306, %struct.anon.307, %struct.anon.308, %struct.anon.309, %struct.anon.310, %struct.anon.311, %struct.anon.312, %struct.anon.313, %struct.anon.314, %struct.anon.315, %struct.anon.316, %struct.anon.317, %struct.anon.318, %struct.anon.319, %struct.anon.320, %struct.anon.321, %struct.anon.322, %struct.anon.323, %struct.anon.324, %struct.anon.325, %struct.anon.326, %struct.anon.327, %struct.anon.328, %struct.anon.329, %struct.anon.330, %struct.anon.331, %struct.anon.332, %struct.anon.333, %struct.anon.334, %struct.anon.335, %struct.anon.336, %struct.anon.337, %struct.anon.338, %struct.anon.339, %struct.anon.340, %struct.anon.341, %struct.anon.342, %struct.anon.343, %struct.anon.344, %struct.anon.345, %struct.anon.346, %struct.anon.347, %struct.anon.348, %struct.anon.349, %struct.anon.350, %struct.anon.351, %struct.anon.352, %struct.anon.353, %struct.anon.354, %struct.anon.355, %struct.anon.356, %struct.anon.357, %struct.anon.358, %struct.anon.359, %struct.anon.360, %struct.anon.361, %struct.anon.362, %struct.anon.363, %struct.anon.364, %struct.anon.365, %struct.anon.366, %struct.anon.367, %struct.anon.368, %struct.anon.369, %struct.anon.370, %struct.anon.371, %struct.anon.372, %struct.anon.373, %struct.anon.374, %struct.anon.375, %struct.anon.376, %struct.anon.377, %struct.anon.378, %struct.anon.379, %struct.anon.380, %struct.anon.381, %struct.anon.382, %struct.anon.383, %struct.anon.384, %struct.anon.385, %struct.anon.386, %struct.anon.387, %struct.anon.388, %struct.anon.389, %struct.anon.390, %struct.anon.391, %struct.anon.392, %struct.anon.393, %struct.anon.394, %struct.anon.395, %struct.anon.396, %struct.anon.397, %struct.anon.398, %struct.anon.399, %struct.anon.400, %struct.anon.401, %struct.anon.402, %struct.anon.403, %struct.anon.404, %struct.anon.405, %struct.anon.406, %struct.anon.407, %struct.anon.408, %struct.anon.409, %struct.anon.410, %struct.anon.411, %struct.anon.412, %struct.anon.413, %struct.anon.414, %struct.anon.415, %struct.anon.416, %struct.anon.417, %struct.anon.418, %struct.anon.419, %struct.anon.420, %struct.anon.421, %struct.anon.422, %struct.anon.423, %struct.anon.424, %struct.anon.425, %struct.anon.426, %struct.anon.427, %struct.anon.428, %struct.anon.429, %struct.anon.430, %struct.anon.431, %struct.anon.432, %struct.anon.433, %struct.anon.434, %struct.anon.435, %struct.anon.436, %struct.anon.437, %struct.anon.438, %struct.anon.439, %struct.anon.440, %struct.anon.441, %struct.anon.442, %struct.anon.443, %struct.anon.444, %struct.anon.445, %struct.anon.446, %struct.anon.447, %struct.anon.448, %struct.anon.449, %struct.anon.450, %struct.anon.451, %struct.anon.452, %struct.anon.453, %struct.anon.454, %struct.anon.455, %struct.anon.456, %struct.anon.457, %struct.anon.458, %struct.anon.459, %struct.anon.460, %struct.anon.461, %struct.anon.462, %struct.anon.463, %struct.anon.464, %struct.anon.465, %struct.anon.466, %struct.anon.467, %struct.anon.468, %struct.anon.469, %struct.anon.470, %struct.anon.471, %struct.anon.472, %struct.anon.473, %struct.anon.474, %struct.anon.475, %struct.anon.476, %struct.anon.477, %struct.anon.478, %struct.anon.479, %struct.anon.480, %struct.anon.481, %struct.anon.482, %struct.anon.483, %struct.anon.484, %struct.anon.485, %struct.anon.486, %struct.anon.487, %struct.anon.488, %struct.anon.489, %struct.anon.490, %struct.anon.491, %struct.anon.492, %struct.anon.493, %struct.anon.494, %struct.anon.495, %struct.anon.496, %struct.anon.497, %struct.anon.498, %struct.anon.499, %struct.anon.500, %struct.anon.501, %struct.anon.502, %struct.anon.503, %struct.anon.504, %struct.anon.505, %struct.anon.506, %struct.anon.507, %struct.anon.508, %struct.anon.509, %struct.anon.510, %struct.anon.511, %struct.anon.512, %struct.anon.513, %struct.anon.514, %struct.anon.515, %struct.anon.516, %struct.anon.517, %struct.anon.518, %struct.anon.519, %struct.anon.520, %struct.anon.521, %struct.anon.522, %struct.anon.523, %struct.anon.524, %struct.anon.525, %struct.anon.526, %struct.anon.527, %struct.anon.528, %struct.anon.529, %struct.anon.530, %struct.anon.531, %struct.anon.532, %struct.anon.533, %struct.anon.534, %struct.anon.535, %struct.anon.536, %struct.anon.537, %struct.anon.538, %struct.anon.539, %struct.anon.540, %struct.anon.541, %struct.anon.542, %struct.anon.543, %struct.anon.544, %struct.anon.545, %struct.anon.546, %struct.anon.547, %struct.anon.548, %struct.anon.549, %struct.anon.550, %struct.anon.551, %struct.anon.552, %struct.anon.553, %struct.anon.554, %struct.anon.555, %struct.anon.556, %struct.anon.557, %struct.anon.558, %struct.anon.559, %struct.anon.560, %struct.anon.561, %struct.anon.562, %struct.anon.563, %struct.anon.564, %struct.anon.565, %struct.anon.566, %struct.anon.567, %struct.anon.568, %struct.anon.569, %struct.anon.570, %struct.anon.571, %struct.anon.572, %struct.anon.573, %struct.anon.574, %struct.anon.575, %struct.anon.576, %struct.anon.577, %struct.anon.578, %struct.anon.579, %struct.anon.580, %struct.anon.581, %struct.anon.582, %struct.anon.583, %struct.anon.584, %struct.anon.585, %struct.anon.586, %struct.anon.587, %struct.anon.588, %struct.anon.589, %struct.anon.590, %struct.anon.591, %struct.anon.592, %struct.anon.593, %struct.anon.594, %struct.anon.595, %struct.anon.596, %struct.anon.597, %struct.anon.598, %struct.anon.599, %struct.anon.600, %struct.anon.601, %struct.anon.602, %struct.anon.603, %struct.anon.604, %struct.anon.605, %struct.anon.606, %struct.anon.607, %struct.anon.608, %struct.anon.609, %struct.anon.610, %struct.anon.611, %struct.anon.612, %struct.anon.613, %struct.anon.614, %struct.anon.615, %struct.anon.616, %struct.anon.617, %struct.anon.618, %struct.anon.619, %struct.anon.620, %struct.anon.621, %struct.anon.622, %struct.anon.623, %struct.anon.624, %struct.anon.625, %struct.anon.626, %struct.anon.627, %struct.anon.628, %struct.anon.629, %struct.anon.630, %struct.anon.631, %struct.anon.632, %struct.anon.633, %struct.anon.634, %struct.anon.635, %struct.anon.636, %struct.anon.637, %struct.anon.638, %struct.anon.639, %struct.anon.640, %struct.anon.641, %struct.anon.642, %struct.anon.643, %struct.anon.644, %struct.anon.645, %struct.anon.646, %struct.anon.647, %struct.anon.648, %struct.anon.649, %struct.anon.650, %struct.anon.651, %struct.anon.652, %struct.anon.653, %struct.anon.654, %struct.anon.655, %struct.anon.656, %struct.anon.657, %struct.anon.658, %struct.anon.659, %struct.anon.660, %struct.anon.661, %struct.anon.662, %struct.anon.663, %struct.anon.664, %struct.anon.665, %struct.anon.666, %struct.anon.667, %struct.anon.668, %struct.anon.669, %struct.anon.670, %struct.anon.671, %struct.anon.672, %struct.anon.673, %struct.anon.674, %struct.anon.675, %struct.anon.676, %struct.anon.677, %struct.anon.678, %struct.anon.679, %struct.anon.680, %struct.anon.681, %struct.anon.682, %struct.anon.683, %struct.anon.684, %struct.anon.685, %struct.anon.686, %struct.anon.687, %struct.anon.688, %struct.anon.689, %struct.anon.690, %struct.anon.691, %struct.anon.692, %struct.anon.693, %struct.anon.694, %struct.anon.695, %struct.anon.696, %struct.anon.697, %struct.anon.698, %struct.anon.699, %struct.anon.700, %struct.anon.701, %struct.anon.702, %struct.anon.703, %struct.anon.704, %struct.anon.705, %struct.anon.706, %struct.anon.707, %struct.anon.708, %struct.anon.709, %struct.anon.710, %struct.anon.711, %struct.anon.712, %struct.anon.713, %struct.anon.714, %struct.anon.715, %struct.anon.716, %struct.anon.717, %struct.anon.718, %struct.anon.719, %struct.anon.720, %struct.anon.721, %struct.anon.722, %struct.anon.723, %struct.anon.724, %struct.anon.725, %struct.anon.726, %struct.anon.727, %struct.anon.728, %struct.anon.729, %struct.anon.730, %struct.anon.731, %struct.anon.732, %struct.anon.733, %struct.anon.734, %struct.anon.735, %struct.anon.736, %struct.anon.737, %struct.anon.738, %struct.anon.739, %struct.anon.740, %struct.anon.741, %struct.anon.742, %struct.anon.743, %struct.anon.744, %struct.anon.745, %struct.anon.746, %struct.anon.747, %struct.anon.748, %struct.anon.749, %struct.anon.750, %struct.anon.751, %struct.anon.752, %struct.anon.753, %struct.anon.754, %struct.anon.755, %struct.anon.756, %struct.anon.757, %struct.anon.758, %struct.anon.759, %struct.anon.760, %struct.anon.761, %struct.anon.762, %struct.anon.763, %struct.anon.764, %struct.anon.765, %struct.anon.766 }
%struct.anon.75 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.76 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.77 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.78 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.79 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.80 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.81 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.82 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.83 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.84 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.85 = type { %struct.PyASCIIObject, [18 x i8] }
%struct.anon.86 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.87 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.88 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.89 = type { %struct.PyASCIIObject, [20 x i8] }
%struct.anon.90 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.91 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.92 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.93 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.94 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.95 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.96 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.97 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.98 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.99 = type { %struct.PyASCIIObject, [31 x i8] }
%struct.anon.100 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.101 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.102 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.103 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.104 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.105 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.106 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.107 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.108 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.109 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.110 = type { %struct.PyASCIIObject, [18 x i8] }
%struct.anon.111 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.112 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.113 = type { %struct.PyASCIIObject, [18 x i8] }
%struct.anon.114 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.115 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.116 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.117 = type { %struct.PyASCIIObject, [25 x i8] }
%struct.anon.118 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.119 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.120 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.121 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.122 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.123 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.124 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.125 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.126 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.127 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.128 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.129 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.130 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.131 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.132 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.133 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.134 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.135 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.136 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.137 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.138 = type { %struct.PyASCIIObject, [17 x i8] }
%struct.anon.139 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.140 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.141 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.142 = type { %struct.PyASCIIObject, [18 x i8] }
%struct.anon.143 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.144 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.145 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.146 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.147 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.148 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.149 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.150 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.151 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.152 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.153 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.154 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.155 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.156 = type { %struct.PyASCIIObject, [18 x i8] }
%struct.anon.157 = type { %struct.PyASCIIObject, [18 x i8] }
%struct.anon.158 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.159 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.160 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.161 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.162 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.163 = type { %struct.PyASCIIObject, [21 x i8] }
%struct.anon.164 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.165 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.166 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.167 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.168 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.169 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.170 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.171 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.172 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.173 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.174 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.175 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.176 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.177 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.178 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.179 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.180 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.181 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.182 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.183 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.184 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.185 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.186 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.187 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.188 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.189 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.190 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.191 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.192 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.193 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.194 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.195 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.196 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.197 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.198 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.199 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.200 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.201 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.202 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.203 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.204 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.205 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.206 = type { %struct.PyASCIIObject, [19 x i8] }
%struct.anon.207 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.208 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.209 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.210 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.211 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.212 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.213 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.214 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.215 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.216 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.217 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.218 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.219 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.220 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.221 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.222 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.223 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.224 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.225 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.226 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.227 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.228 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.229 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.230 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.231 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.232 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.233 = type { %struct.PyASCIIObject, [18 x i8] }
%struct.anon.234 = type { %struct.PyASCIIObject, [17 x i8] }
%struct.anon.235 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.236 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.237 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.238 = type { %struct.PyASCIIObject, [36 x i8] }
%struct.anon.239 = type { %struct.PyASCIIObject, [25 x i8] }
%struct.anon.240 = type { %struct.PyASCIIObject, [17 x i8] }
%struct.anon.241 = type { %struct.PyASCIIObject, [31 x i8] }
%struct.anon.242 = type { %struct.PyASCIIObject, [20 x i8] }
%struct.anon.243 = type { %struct.PyASCIIObject, [19 x i8] }
%struct.anon.244 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.245 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.246 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.247 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.248 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.249 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.250 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.251 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.252 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.253 = type { %struct.PyASCIIObject, [25 x i8] }
%struct.anon.254 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.255 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.256 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.257 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.258 = type { %struct.PyASCIIObject, [17 x i8] }
%struct.anon.259 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.260 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.261 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.262 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.263 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.264 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.265 = type { %struct.PyASCIIObject, [17 x i8] }
%struct.anon.266 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.267 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.268 = type { %struct.PyASCIIObject, [18 x i8] }
%struct.anon.269 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.270 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.271 = type { %struct.PyASCIIObject, [20 x i8] }
%struct.anon.272 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.273 = type { %struct.PyASCIIObject, [19 x i8] }
%struct.anon.274 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.275 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.276 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.277 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.278 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.279 = type { %struct.PyASCIIObject, [19 x i8] }
%struct.anon.280 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.281 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.282 = type { %struct.PyASCIIObject, [26 x i8] }
%struct.anon.283 = type { %struct.PyASCIIObject, [26 x i8] }
%struct.anon.284 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.285 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.286 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.287 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.288 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.289 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.290 = type { %struct.PyASCIIObject, [18 x i8] }
%struct.anon.291 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.292 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.293 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.294 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.295 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.296 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.297 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.298 = type { %struct.PyASCIIObject, [17 x i8] }
%struct.anon.299 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.300 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.301 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.302 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.303 = type { %struct.PyASCIIObject, [20 x i8] }
%struct.anon.304 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.305 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.306 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.307 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.308 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.309 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.310 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.311 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.312 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.313 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.314 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.315 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.316 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.317 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.318 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.319 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.320 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.321 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.322 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.323 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.324 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.325 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.326 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.327 = type { %struct.PyASCIIObject, [18 x i8] }
%struct.anon.328 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.329 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.330 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.331 = type { %struct.PyASCIIObject, [23 x i8] }
%struct.anon.332 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.333 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.334 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.335 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.336 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.337 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.338 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.339 = type { %struct.PyASCIIObject, [18 x i8] }
%struct.anon.340 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.341 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.342 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.343 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.344 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.345 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.346 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.347 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.348 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.349 = type { %struct.PyASCIIObject, [18 x i8] }
%struct.anon.350 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.351 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.352 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.353 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.354 = type { %struct.PyASCIIObject, [18 x i8] }
%struct.anon.355 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.356 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.357 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.358 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.359 = type { %struct.PyASCIIObject, [19 x i8] }
%struct.anon.360 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.361 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.362 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.363 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.364 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.365 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.366 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.367 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.368 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.369 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.370 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.371 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.372 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.373 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.374 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.375 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.376 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.377 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.378 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.379 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.380 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.381 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.382 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.383 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.384 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.385 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.386 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.387 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.388 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.389 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.390 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.391 = type { %struct.PyASCIIObject, [18 x i8] }
%struct.anon.392 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.393 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.394 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.395 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.396 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.397 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.398 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.399 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.400 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.401 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.402 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.403 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.404 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.405 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.406 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.407 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.408 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.409 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.410 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.411 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.412 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.413 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.414 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.415 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.416 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.417 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.418 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.419 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.420 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.421 = type { %struct.PyASCIIObject, [19 x i8] }
%struct.anon.422 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.423 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.424 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.425 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.426 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.427 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.428 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.429 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.430 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.431 = type { %struct.PyASCIIObject, [3 x i8] }
%struct.anon.432 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.433 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.434 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.435 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.436 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.437 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.438 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.439 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.440 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.441 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.442 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.443 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.444 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.445 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.446 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.447 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.448 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.449 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.450 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.451 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.452 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.453 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.454 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.455 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.456 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.457 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.458 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.459 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.460 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.461 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.462 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.463 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.464 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.465 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.466 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.467 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.468 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.469 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.470 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.471 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.472 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.473 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.474 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.475 = type { %struct.PyASCIIObject, [3 x i8] }
%struct.anon.476 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.477 = type { %struct.PyASCIIObject, [3 x i8] }
%struct.anon.478 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.479 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.480 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.481 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.482 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.483 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.484 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.485 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.486 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.487 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.488 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.489 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.490 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.491 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.492 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.493 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.494 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.495 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.496 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.497 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.498 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.499 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.500 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.501 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.502 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.503 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.504 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.505 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.506 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.507 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.508 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.509 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.510 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.511 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.512 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.513 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.514 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.515 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.516 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.517 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.518 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.519 = type { %struct.PyASCIIObject, [3 x i8] }
%struct.anon.520 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.521 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.522 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.523 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.524 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.525 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.526 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.527 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.528 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.529 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.530 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.531 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.532 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.533 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.534 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.535 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.536 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.537 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.538 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.539 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.540 = type { %struct.PyASCIIObject, [3 x i8] }
%struct.anon.541 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.542 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.543 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.544 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.545 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.546 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.547 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.548 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.549 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.550 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.551 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.552 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.553 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.554 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.555 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.556 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.557 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.558 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.559 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.560 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.561 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.562 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.563 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.564 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.565 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.566 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.567 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.568 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.569 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.570 = type { %struct.PyASCIIObject, [18 x i8] }
%struct.anon.571 = type { %struct.PyASCIIObject, [17 x i8] }
%struct.anon.572 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.573 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.574 = type { %struct.PyASCIIObject, [20 x i8] }
%struct.anon.575 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.576 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.577 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.578 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.579 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.580 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.581 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.582 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.583 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.584 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.585 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.586 = type { %struct.PyASCIIObject, [3 x i8] }
%struct.anon.587 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.588 = type { %struct.PyASCIIObject, [3 x i8] }
%struct.anon.589 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.590 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.591 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.592 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.593 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.594 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.595 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.596 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.597 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.598 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.599 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.600 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.601 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.602 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.603 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.604 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.605 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.606 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.607 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.608 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.609 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.610 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.611 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.612 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.613 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.614 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.615 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.616 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.617 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.618 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.619 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.620 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.621 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.622 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.623 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.624 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.625 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.626 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.627 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.628 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.629 = type { %struct.PyASCIIObject, [20 x i8] }
%struct.anon.630 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.631 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.632 = type { %struct.PyASCIIObject, [17 x i8] }
%struct.anon.633 = type { %struct.PyASCIIObject, [17 x i8] }
%struct.anon.634 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.635 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.636 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.637 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.638 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.639 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.640 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.641 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.642 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.643 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.644 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.645 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.646 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.647 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.648 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.649 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.650 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.651 = type { %struct.PyASCIIObject, [17 x i8] }
%struct.anon.652 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.653 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.654 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.655 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.656 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.657 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.658 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.659 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.660 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.661 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.662 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.663 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.664 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.665 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.666 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.667 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.668 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.669 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.670 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.671 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.672 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.673 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.674 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.675 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.676 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.677 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.678 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.679 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.680 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.681 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.682 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.683 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.684 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.685 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.686 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.687 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.688 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.689 = type { %struct.PyASCIIObject, [19 x i8] }
%struct.anon.690 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.691 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.692 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.693 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.694 = type { %struct.PyASCIIObject, [17 x i8] }
%struct.anon.695 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.696 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.697 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.698 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.699 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.700 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.701 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.702 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.703 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.704 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.705 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.706 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.707 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.708 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.709 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.710 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.711 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.712 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.713 = type { %struct.PyASCIIObject, [28 x i8] }
%struct.anon.714 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.715 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.716 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.717 = type { %struct.PyASCIIObject, [20 x i8] }
%struct.anon.718 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.719 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.720 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.721 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.722 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.723 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.724 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.725 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.726 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.727 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.728 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.729 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.730 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.731 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.732 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.733 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.734 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.735 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.736 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.737 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.738 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.739 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.740 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.741 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.742 = type { %struct.PyASCIIObject, [3 x i8] }
%struct.anon.743 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.744 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.745 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.746 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.747 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.748 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.749 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.750 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.751 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.752 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.753 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.754 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.755 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.756 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.757 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.758 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.759 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.760 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.761 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.762 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.763 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.764 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.765 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.766 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.767 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.768 = type { %struct.PyCompactUnicodeObject, [2 x i8] }
%struct.PyCompactUnicodeObject = type { %struct.PyASCIIObject, i64, ptr }
%struct.PyTupleObject = type { %struct.PyVarObject, [1 x ptr] }
%struct.PyGC_Head = type { i64, i64 }
%struct.PyHamtNode_Bitmap = type { %struct.PyVarObject, i32, [1 x ptr] }
%struct._PyContextTokenMissing = type { %struct._object }
%struct._is = type { %struct._ceval_state, ptr, i64, i64, i32, ptr, i32, i32, i64, %struct.pythreads, ptr, ptr, i64, %struct._gc_runtime_state, ptr, ptr, %struct._import_state, %struct._gil_runtime_state, ptr, ptr, ptr, i32, %struct.PyConfig, i64, ptr, ptr, ptr, ptr, [8 x ptr], i8, i64, [255 x ptr], %struct._xi_state, ptr, ptr, ptr, %struct._warnings_runtime_state, %struct.atexit_state, %struct._obmalloc_state, ptr, [8 x ptr], [8 x ptr], i8, %struct._py_object_state, %struct._Py_unicode_state, %struct._Py_float_state, %struct._Py_long_state, %struct._dtoa_state, %struct._py_func_state, ptr, %struct._Py_tuple_state, %struct._Py_list_state, %struct._Py_dict_state, %struct._Py_async_gen_state, %struct._Py_context_state, %struct._Py_exc_state, %struct.ast_state, %struct.types_state, %struct.callable_cache, ptr, ptr, i16, i16, i32, %struct._Py_GlobalMonitors, i8, i8, i64, i64, [8 x [17 x ptr]], [8 x ptr], %struct._Py_interp_cached_objects, %struct._Py_interp_static_objects, %struct._PyThreadStateImpl, i64 }
%struct._ceval_state = type { i64, [7 x i64], i32, ptr, i32, %struct._pending_calls }
%struct.pythreads = type { i64, ptr, ptr, i64, i64 }
%struct._gc_runtime_state = type { ptr, i32, i32, i32, [3 x %struct.gc_generation], ptr, %struct.gc_generation, [3 x %struct.gc_generation_stats], i32, ptr, ptr, i64, i64 }
%struct.gc_generation = type { %struct.PyGC_Head, i32, i32 }
%struct.gc_generation_stats = type { i64, i64, i64 }
%struct._import_state = type { ptr, ptr, ptr, i32, i32, i32, ptr, %struct.anon, %struct.anon.0 }
%struct.anon = type { ptr, i64, i32 }
%struct.anon.0 = type { i32, i64, i32 }
%struct._gil_runtime_state = type { i64, ptr, i32, i64, %union.pthread_cond_t, %union.pthread_mutex_t, %union.pthread_cond_t, %union.pthread_mutex_t }
%union.pthread_cond_t = type { %struct.__pthread_cond_s }
%struct.__pthread_cond_s = type { %union.__atomic_wide_counter, %union.__atomic_wide_counter, [2 x i32], [2 x i32], i32, i32, [2 x i32] }
%union.__atomic_wide_counter = type { i64 }
%union.pthread_mutex_t = type { %struct.__pthread_mutex_s }
%struct.__pthread_mutex_s = type { i32, i32, i32, i32, i32, i16, i16, %struct.__pthread_internal_list }
%struct.__pthread_internal_list = type { ptr, ptr }
%struct.PyConfig = type { i32, i32, i32, i32, i32, i32, i64, i32, i32, i32, i32, i32, i32, i32, ptr, i32, ptr, ptr, ptr, i32, %struct.PyWideStringList, %struct.PyWideStringList, %struct.PyWideStringList, %struct.PyWideStringList, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, ptr, ptr, ptr, i32, i32, i32, i32, i32, ptr, ptr, ptr, ptr, i32, %struct.PyWideStringList, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i32, ptr, ptr, ptr, ptr, i32, i32, i32 }
%struct._xi_state = type { %struct._xidregistry, ptr }
%struct._warnings_runtime_state = type { ptr, ptr, ptr, i64 }
%struct.atexit_state = type { ptr, ptr, ptr, i32, i32 }
%struct._obmalloc_state = type { %struct._obmalloc_pools, %struct._obmalloc_mgmt, %struct._obmalloc_usage }
%struct._obmalloc_pools = type { [64 x ptr] }
%struct._obmalloc_mgmt = type { ptr, i32, ptr, ptr, [65 x ptr], i64, i64, i64, i64 }
%struct._obmalloc_usage = type { %struct.arena_map_top, i32, i32 }
%struct.arena_map_top = type { [32768 x ptr] }
%struct._py_object_state = type { i32 }
%struct._Py_unicode_state = type { %struct._Py_unicode_fs_codec, ptr, %struct._Py_unicode_ids }
%struct._Py_unicode_fs_codec = type { ptr, i32, ptr, i32 }
%struct._Py_unicode_ids = type { i64, ptr }
%struct._Py_float_state = type { i32, ptr }
%struct._Py_long_state = type { i32 }
%struct._dtoa_state = type { [8 x ptr], [8 x ptr], [288 x double], ptr }
%struct._py_func_state = type { i32, [4096 x ptr] }
%struct._Py_tuple_state = type { [20 x ptr], [20 x i32] }
%struct._Py_list_state = type { [80 x ptr], i32 }
%struct._Py_dict_state = type { i64, i32, [80 x ptr], [80 x ptr], i32, i32, [8 x ptr] }
%struct._Py_async_gen_state = type { [80 x ptr], i32, [80 x ptr], i32 }
%struct._Py_context_state = type { ptr, i32 }
%struct._Py_exc_state = type { ptr, ptr, i32, ptr }
%struct.ast_state = type { %struct._PyOnceFlag, i32, i32, i32, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr }
%struct._PyOnceFlag = type { i8 }
%struct.types_state = type { i32, %struct.type_cache, i64, [200 x %struct.static_builtin_state] }
%struct.type_cache = type { [4096 x %struct.type_cache_entry] }
%struct.type_cache_entry = type { i32, ptr, ptr }
%struct.static_builtin_state = type { ptr, i32, i32, ptr, ptr, ptr }
%struct.callable_cache = type { ptr, ptr, ptr, ptr }
%struct._Py_GlobalMonitors = type { [15 x i8] }
%struct._Py_interp_cached_objects = type { ptr, ptr, ptr, ptr, [10 x ptr], ptr, ptr, ptr, ptr, ptr, ptr }
%struct._Py_interp_static_objects = type { %struct.anon.2 }
%struct.anon.2 = type { i32, %struct.PyGC_Head, %struct.PyHamtObject, %struct.PyBaseExceptionObject }
%struct.PyHamtObject = type { %struct._object, ptr, ptr, i64 }
%struct.PyBaseExceptionObject = type { %struct._object, ptr, ptr, ptr, ptr, ptr, ptr, i8 }
%struct._PyThreadStateImpl = type { %struct._ts }
%struct._ts = type { ptr, ptr, ptr, %struct.anon.3, i32, i32, i32, i32, i32, i32, i32, i32, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i32, ptr, i64, i64, %struct._py_trashcan, i64, ptr, ptr, i32, ptr, ptr, ptr, i64, i64, ptr, ptr, ptr, %struct._err_stackitem }
%struct.anon.3 = type { i32 }
%struct._py_trashcan = type { i32, ptr }
%struct._err_stackitem = type { ptr, ptr }
%struct.PyModuleDef = type { %struct.PyModuleDef_Base, ptr, ptr, i64, ptr, ptr, ptr, ptr, ptr }
%struct.PyModuleDef_Base = type { %struct._object, ptr, i64, ptr }
%struct.PyMethodDef = type { ptr, ptr, i32, ptr }
%struct.PyModuleDef_Slot = type { i32, ptr }
%struct.anon.769 = type { %struct.PyGC_Head, %struct.PyVarObject, [3 x ptr] }
%struct._typeobject = type { %struct.PyVarObject, ptr, i64, i64, ptr, i64, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i64, ptr, ptr, ptr, ptr, i64, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i64, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i32, ptr, ptr, i8 }
%struct._PyArg_Parser = type { ptr, ptr, ptr, ptr, %struct._PyOnceFlag, i32, i32, i32, i32, ptr, ptr }
%struct.path_t = type { ptr, ptr, i32, i32, ptr, ptr, i32, i64, ptr, ptr }
%struct.anon.770 = type { %struct.PyGC_Head, %struct.PyVarObject, [5 x ptr] }
%struct.anon.771 = type { %struct.PyGC_Head, %struct.PyVarObject, [1 x ptr] }
%struct.anon.772 = type { %struct.PyGC_Head, %struct.PyVarObject, [4 x ptr] }
%struct.anon.773 = type { %struct.PyGC_Head, %struct.PyVarObject, [2 x ptr] }
%struct.anon.774 = type { %struct.PyGC_Head, %struct.PyVarObject, [5 x ptr] }
%struct.anon.775 = type { %struct.PyGC_Head, %struct.PyVarObject, [3 x ptr] }
%struct.anon.776 = type { %struct.PyGC_Head, %struct.PyVarObject, [3 x ptr] }
%struct.anon.777 = type { %struct.PyGC_Head, %struct.PyVarObject, [1 x ptr] }
%struct.anon.778 = type { %struct.PyGC_Head, %struct.PyVarObject, [5 x ptr] }
%struct.anon.779 = type { %struct.PyGC_Head, %struct.PyVarObject, [1 x ptr] }
%struct.anon.780 = type { %struct.PyGC_Head, %struct.PyVarObject, [2 x ptr] }
%struct.anon.781 = type { %struct.PyGC_Head, %struct.PyVarObject, [3 x ptr] }
%struct.anon.782 = type { %struct.PyGC_Head, %struct.PyVarObject, [2 x ptr] }
%struct.anon.783 = type { %struct.PyGC_Head, %struct.PyVarObject, [3 x ptr] }
%struct.anon.784 = type { %struct.PyGC_Head, %struct.PyVarObject, [7 x ptr] }
%struct.anon.785 = type { %struct.PyGC_Head, %struct.PyVarObject, [7 x ptr] }
%struct.anon.786 = type { %struct.PyGC_Head, %struct.PyVarObject, [2 x ptr] }
%struct.anon.787 = type { %struct.PyGC_Head, %struct.PyVarObject, [5 x ptr] }
%struct.anon.788 = type { %struct.PyGC_Head, %struct.PyVarObject, [6 x ptr] }
%struct.anon.789 = type { %struct.PyGC_Head, %struct.PyVarObject, [4 x ptr] }
%struct.anon.790 = type { %struct.PyGC_Head, %struct.PyVarObject, [4 x ptr] }
%struct.anon.791 = type { %struct.PyGC_Head, %struct.PyVarObject, [2 x ptr] }
%struct.anon.792 = type { %struct.PyGC_Head, %struct.PyVarObject, [4 x ptr] }
%struct.anon.793 = type { %struct.PyGC_Head, %struct.PyVarObject, [1 x ptr] }
%struct.anon.794 = type { %struct.PyGC_Head, %struct.PyVarObject, [2 x ptr] }
%struct.anon.795 = type { %struct.PyGC_Head, %struct.PyVarObject, [2 x ptr] }
%struct.anon.796 = type { %struct.PyGC_Head, %struct.PyVarObject, [5 x ptr] }
%struct.anon.797 = type { %struct.PyGC_Head, %struct.PyVarObject, [1 x ptr] }
%struct.anon.798 = type { %struct.PyGC_Head, %struct.PyVarObject, [3 x ptr] }
%struct.anon.799 = type { %struct.PyGC_Head, %struct.PyVarObject, [3 x ptr] }
%struct.anon.800 = type { %struct.PyGC_Head, %struct.PyVarObject, [1 x ptr] }
%struct.anon.801 = type { %struct.PyGC_Head, %struct.PyVarObject, [1 x ptr] }
%struct.anon.802 = type { %struct.PyGC_Head, %struct.PyVarObject, [1 x ptr] }
%struct.anon.803 = type { %struct.PyGC_Head, %struct.PyVarObject, [1 x ptr] }
%struct.anon.818 = type { %struct.PyGC_Head, %struct.PyVarObject, [2 x ptr] }
%struct.anon.829 = type { %struct.PyGC_Head, %struct.PyVarObject, [2 x ptr] }
%struct.anon.830 = type { %struct.PyGC_Head, %struct.PyVarObject, [4 x ptr] }
%struct.anon.831 = type { %struct.PyGC_Head, %struct.PyVarObject, [1 x ptr] }
%struct.anon.832 = type { %struct.PyGC_Head, %struct.PyVarObject, [1 x ptr] }
%struct.anon.833 = type { %struct.PyGC_Head, %struct.PyVarObject, [3 x ptr] }
%struct.anon.834 = type { %struct.PyGC_Head, %struct.PyVarObject, [4 x ptr] }
%struct.anon.835 = type { %struct.PyGC_Head, %struct.PyVarObject, [1 x ptr] }
%struct.anon.836 = type { %struct.PyGC_Head, %struct.PyVarObject, [3 x ptr] }
%struct.anon.837 = type { %struct.PyGC_Head, %struct.PyVarObject, [4 x ptr] }
%struct.anon.838 = type { %struct.PyGC_Head, %struct.PyVarObject, [2 x ptr] }
%struct.anon.839 = type { %struct.PyGC_Head, %struct.PyVarObject, [1 x ptr] }
%struct.anon.840 = type { %struct.PyGC_Head, %struct.PyVarObject, [1 x ptr] }
%struct.anon.841 = type { %struct.PyGC_Head, %struct.PyVarObject, [1 x ptr] }
%struct.anon.842 = type { %struct.PyGC_Head, %struct.PyVarObject, [1 x ptr] }
%struct.anon.843 = type { %struct.PyGC_Head, %struct.PyVarObject, [1 x ptr] }
%struct.anon.844 = type { %struct.PyGC_Head, %struct.PyVarObject, [1 x ptr] }
%struct.anon.845 = type { %struct.PyGC_Head, %struct.PyVarObject, [1 x ptr] }
%struct.anon.846 = type { %struct.PyGC_Head, %struct.PyVarObject, [1 x ptr] }
%struct.anon.847 = type { %struct.PyGC_Head, %struct.PyVarObject, [1 x ptr] }
%struct.anon.848 = type { %struct.PyGC_Head, %struct.PyVarObject, [1 x ptr] }
%struct.anon.849 = type { %struct.PyGC_Head, %struct.PyVarObject, [1 x ptr] }
%struct.constdef = type { ptr, i32 }
%struct.anon.850 = type { %struct.PyGC_Head, %struct.PyVarObject, [2 x ptr] }
%struct.anon.851 = type { %struct.PyGC_Head, %struct.PyVarObject, [1 x ptr] }
%struct.anon.852 = type { %struct.PyGC_Head, %struct.PyVarObject, [3 x ptr] }
%struct.anon.853 = type { %struct.PyGC_Head, %struct.PyVarObject, [5 x ptr] }
%struct.anon.854 = type { %struct.PyGC_Head, %struct.PyVarObject, [3 x ptr] }
%struct.anon.855 = type { %struct.PyGC_Head, %struct.PyVarObject, [2 x ptr] }
%struct.anon.856 = type { %struct.PyGC_Head, %struct.PyVarObject, [1 x ptr] }
%struct.anon.857 = type { %struct.PyGC_Head, %struct.PyVarObject, [1 x ptr] }
%struct.anon.858 = type { %struct.PyGC_Head, %struct.PyVarObject, [2 x ptr] }
%struct.anon.859 = type { %struct.PyGC_Head, %struct.PyVarObject, [2 x ptr] }
%struct.anon.860 = type { %struct.PyGC_Head, %struct.PyVarObject, [2 x ptr] }
%struct.anon.861 = type { %struct.PyGC_Head, %struct.PyVarObject, [1 x ptr] }
%struct.anon.862 = type { %struct.PyGC_Head, %struct.PyVarObject, [2 x ptr] }
%struct.anon.863 = type { %struct.PyGC_Head, %struct.PyVarObject, [1 x ptr] }
%struct.anon.864 = type { %struct.PyGC_Head, %struct.PyVarObject, [2 x ptr] }
%struct.anon.865 = type { %struct.PyGC_Head, %struct.PyVarObject, [1 x ptr] }
%struct.anon.866 = type { %struct.PyGC_Head, %struct.PyVarObject, [1 x ptr] }
%struct.anon.867 = type { %struct.PyGC_Head, %struct.PyVarObject, [3 x ptr] }
%struct.anon.868 = type { %struct.PyGC_Head, %struct.PyVarObject, [3 x ptr] }
%struct.PyStructSequence_Desc = type { ptr, ptr, ptr, i32 }
%struct.PyType_Spec = type { ptr, i32, i32, i32, ptr }
%struct.have_function = type { ptr, ptr }
%struct.PyStructSequence_Field = type { ptr, ptr }
%struct.anon.869 = type { %struct.PyGC_Head, %struct.PyVarObject, [1 x ptr] }
%struct.PyType_Slot = type { i32, ptr }
%struct.PyMemberDef = type { ptr, i32, i64, i32, ptr }
%struct.anon.870 = type { %struct.PyGC_Head, %struct.PyVarObject, [1 x ptr] }
%struct.anon.871 = type { %struct.PyGC_Head, %struct.PyVarObject, [1 x ptr] }
%struct.anon.872 = type { %struct.PyGC_Head, %struct.PyVarObject, [1 x ptr] }
%struct.PyListObject = type { %struct.PyVarObject, ptr, i64 }
%struct.PyStatus = type { i32, ptr, ptr, i32 }
%struct._posixstate = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i64 }
%struct.Py_buffer = type { ptr, ptr, i64, i64, i32, i32, ptr, ptr, ptr, ptr, ptr }
%struct.stat = type { i64, i64, i64, i32, i32, i32, i32, i64, i64, i64, i64, %struct.timespec, %struct.timespec, %struct.timespec, [3 x i64] }
%struct.timespec = type { i64, i64 }
%struct.PyModuleObject = type { %struct._object, ptr, ptr, ptr, ptr, ptr }
%struct.dirent = type { i64, i64, i16, i8, [256 x i8] }
%struct.posix_spawn_file_actions_t = type { i32, i32, ptr, [16 x i32] }
%struct.posix_spawnattr_t = type { i16, i32, %struct.__sigset_t, %struct.__sigset_t, %struct.sched_param, i32, [16 x i32] }
%struct.__sigset_t = type { [16 x i64] }
%struct.sched_param = type { i32 }
%struct.PySequenceMethods = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr }
%struct.utsname = type { [65 x i8], [65 x i8], [65 x i8], [65 x i8], [65 x i8], [65 x i8] }
%struct.utime_t = type { i32, i64, i64, i64, i64 }
%struct.tms = type { i64, i64, i64, i64 }
%struct.cpu_set_t = type { [16 x i64] }
%struct.rusage = type { %struct.timeval, %struct.timeval, %union.anon.804, %union.anon.805, %union.anon.806, %union.anon.807, %union.anon.808, %union.anon.809, %union.anon.810, %union.anon.811, %union.anon.812, %union.anon.813, %union.anon.814, %union.anon.815, %union.anon.816, %union.anon.817 }
%struct.timeval = type { i64, i64 }
%union.anon.804 = type { i64 }
%union.anon.805 = type { i64 }
%union.anon.806 = type { i64 }
%union.anon.807 = type { i64 }
%union.anon.808 = type { i64 }
%union.anon.809 = type { i64 }
%union.anon.810 = type { i64 }
%union.anon.811 = type { i64 }
%union.anon.812 = type { i64 }
%union.anon.813 = type { i64 }
%union.anon.814 = type { i64 }
%union.anon.815 = type { i64 }
%union.anon.816 = type { i64 }
%union.anon.817 = type { i64 }
%struct.siginfo_t = type { i32, i32, i32, i32, %union.anon.819 }
%union.anon.819 = type { %struct.anon.823, [80 x i8] }
%struct.anon.823 = type { i32, i32, i32, i64, i64 }
%struct.anon.820 = type { i32, i32 }
%struct.iovec = type { ptr, i64 }
%struct.statvfs = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [6 x i32] }
%struct.winsize = type { i16, i16, i16, i16 }
%struct.ScandirIterator = type { %struct._object, %struct.path_t, ptr, i32 }
%struct.PyFloatObject = type { %struct._object, double }
%struct.itimerspec = type { %struct.timespec, %struct.timespec }
%struct.DirEntry = type { %struct._object, ptr, ptr, ptr, ptr, i8, i64, i32 }

@__func__.PyOS_AfterFork_Parent = private unnamed_addr constant [22 x i8] c"PyOS_AfterFork_Parent\00", align 1
@.str = private unnamed_addr constant [40 x i8] c"failed releasing import lock after fork\00", align 1
@_PyRuntime = external global %struct.pyruntimestate, align 8
@__func__.PyOS_AfterFork_Child = private unnamed_addr constant [21 x i8] c"PyOS_AfterFork_Child\00", align 1
@PyExc_TypeError = external global ptr, align 8
@.str.1 = private unnamed_addr constant [34 x i8] c"uid should be integer, not %.200s\00", align 1
@PyExc_OverflowError = external global ptr, align 8
@.str.2 = private unnamed_addr constant [25 x i8] c"uid is less than minimum\00", align 1
@.str.3 = private unnamed_addr constant [28 x i8] c"uid is greater than maximum\00", align 1
@.str.4 = private unnamed_addr constant [34 x i8] c"gid should be integer, not %.200s\00", align 1
@.str.5 = private unnamed_addr constant [25 x i8] c"gid is less than minimum\00", align 1
@.str.6 = private unnamed_addr constant [28 x i8] c"gid is greater than maximum\00", align 1
@PyExc_OSError = external global ptr, align 8
@PyExc_ValueError = external global ptr, align 8
@.str.7 = private unnamed_addr constant [39 x i8] c"signal number %ld out of range [1; %i]\00", align 1
@__const._Py_Sigset_Converter.msg = private unnamed_addr constant [54 x i8] c"invalid signal number %ld, please use valid_signals()\00", align 16
@PyExc_RuntimeWarning = external global ptr, align 8
@_Py_NoneStruct = external global %struct._object, align 8
@.str.8 = private unnamed_addr constant [54 x i8] c"expected str, bytes or os.PathLike object, not %.200s\00", align 1
@.str.9 = private unnamed_addr constant [64 x i8] c"expected %.200s.__fspath__() to return str or bytes, not %.200s\00", align 1
@posixmodule = internal global %struct.PyModuleDef { %struct.PyModuleDef_Base { %struct._object { %union.anon { i64 4294967295 }, ptr null }, ptr null, i64 0, ptr null }, ptr @.str.11, ptr @posix__doc__, i64 112, ptr @posix_methods, ptr @posixmodile_slots, ptr @_posix_traverse, ptr @_posix_clear, ptr @_posix_free }, align 8
@_Py_tss_tstate = external thread_local global ptr, align 8
@.str.10 = private unnamed_addr constant [173 x i8] c"the function must be called with the GIL held, after Python initialization and before Python finalization, but the GIL is released (the current Python thread state is NULL)\00", align 1
@.str.11 = private unnamed_addr constant [6 x i8] c"posix\00", align 1
@posix__doc__ = internal constant [259 x i8] c"This module provides access to operating system functionality that is\0Astandardized by the C Standard and the POSIX standard (a thinly\0Adisguised Unix interface).  Refer to the library manual and\0Acorresponding Unix manual entries for more information on calls.\00", align 16
@posix_methods = internal global [172 x %struct.PyMethodDef] [%struct.PyMethodDef { ptr @.str.12, ptr @os_stat, i32 130, ptr @os_stat__doc__ }, %struct.PyMethodDef { ptr @.str.13, ptr @os_access, i32 130, ptr @os_access__doc__ }, %struct.PyMethodDef { ptr @.str.14, ptr @os_ttyname, i32 8, ptr @os_ttyname__doc__ }, %struct.PyMethodDef { ptr @.str.15, ptr @os_chdir, i32 130, ptr @os_chdir__doc__ }, %struct.PyMethodDef { ptr @.str.16, ptr @os_chmod, i32 130, ptr @os_chmod__doc__ }, %struct.PyMethodDef { ptr @.str.17, ptr @os_fchmod, i32 130, ptr @os_fchmod__doc__ }, %struct.PyMethodDef { ptr @.str.18, ptr @os_chown, i32 130, ptr @os_chown__doc__ }, %struct.PyMethodDef { ptr @.str.19, ptr @os_fchown, i32 130, ptr @os_fchown__doc__ }, %struct.PyMethodDef { ptr @.str.20, ptr @os_lchown, i32 130, ptr @os_lchown__doc__ }, %struct.PyMethodDef { ptr @.str.21, ptr @os_chroot, i32 130, ptr @os_chroot__doc__ }, %struct.PyMethodDef { ptr @.str.22, ptr @os_ctermid, i32 4, ptr @os_ctermid__doc__ }, %struct.PyMethodDef { ptr @.str.23, ptr @os_getcwd, i32 4, ptr @os_getcwd__doc__ }, %struct.PyMethodDef { ptr @.str.24, ptr @os_getcwdb, i32 4, ptr @os_getcwdb__doc__ }, %struct.PyMethodDef { ptr @.str.25, ptr @os_link, i32 130, ptr @os_link__doc__ }, %struct.PyMethodDef { ptr @.str.26, ptr @os_listdir, i32 130, ptr @os_listdir__doc__ }, %struct.PyMethodDef { ptr @.str.27, ptr @os_lstat, i32 130, ptr @os_lstat__doc__ }, %struct.PyMethodDef { ptr @.str.28, ptr @os_mkdir, i32 130, ptr @os_mkdir__doc__ }, %struct.PyMethodDef { ptr @.str.29, ptr @os_nice, i32 8, ptr @os_nice__doc__ }, %struct.PyMethodDef { ptr @.str.30, ptr @os_getpriority, i32 130, ptr @os_getpriority__doc__ }, %struct.PyMethodDef { ptr @.str.31, ptr @os_setpriority, i32 130, ptr @os_setpriority__doc__ }, %struct.PyMethodDef { ptr @.str.32, ptr @os_posix_spawn, i32 130, ptr @os_posix_spawn__doc__ }, %struct.PyMethodDef { ptr @.str.33, ptr @os_posix_spawnp, i32 130, ptr @os_posix_spawnp__doc__ }, %struct.PyMethodDef { ptr @.str.34, ptr @os_readlink, i32 130, ptr @os_readlink__doc__ }, %struct.PyMethodDef { ptr @.str.35, ptr @os_copy_file_range, i32 130, ptr @os_copy_file_range__doc__ }, %struct.PyMethodDef { ptr @.str.36, ptr @os_splice, i32 130, ptr @os_splice__doc__ }, %struct.PyMethodDef { ptr @.str.37, ptr @os_rename, i32 130, ptr @os_rename__doc__ }, %struct.PyMethodDef { ptr @.str.38, ptr @os_replace, i32 130, ptr @os_replace__doc__ }, %struct.PyMethodDef { ptr @.str.39, ptr @os_rmdir, i32 130, ptr @os_rmdir__doc__ }, %struct.PyMethodDef { ptr @.str.40, ptr @os_symlink, i32 130, ptr @os_symlink__doc__ }, %struct.PyMethodDef { ptr @.str.41, ptr @os_system, i32 130, ptr @os_system__doc__ }, %struct.PyMethodDef { ptr @.str.42, ptr @os_umask, i32 8, ptr @os_umask__doc__ }, %struct.PyMethodDef { ptr @.str.43, ptr @os_uname, i32 4, ptr @os_uname__doc__ }, %struct.PyMethodDef { ptr @.str.44, ptr @os_unlink, i32 130, ptr @os_unlink__doc__ }, %struct.PyMethodDef { ptr @.str.45, ptr @os_remove, i32 130, ptr @os_remove__doc__ }, %struct.PyMethodDef { ptr @.str.46, ptr @os_utime, i32 130, ptr @os_utime__doc__ }, %struct.PyMethodDef { ptr @.str.47, ptr @os_times, i32 4, ptr @os_times__doc__ }, %struct.PyMethodDef { ptr @.str.48, ptr @os__exit, i32 130, ptr @os__exit__doc__ }, %struct.PyMethodDef { ptr @.str.49, ptr @os_execv, i32 128, ptr @os_execv__doc__ }, %struct.PyMethodDef { ptr @.str.50, ptr @os_execve, i32 130, ptr @os_execve__doc__ }, %struct.PyMethodDef { ptr @.str.51, ptr @os_fork, i32 4, ptr @os_fork__doc__ }, %struct.PyMethodDef { ptr @.str.52, ptr @os_register_at_fork, i32 130, ptr @os_register_at_fork__doc__ }, %struct.PyMethodDef { ptr @.str.53, ptr @os_sched_get_priority_max, i32 130, ptr @os_sched_get_priority_max__doc__ }, %struct.PyMethodDef { ptr @.str.54, ptr @os_sched_get_priority_min, i32 130, ptr @os_sched_get_priority_min__doc__ }, %struct.PyMethodDef { ptr @.str.55, ptr @os_sched_getparam, i32 8, ptr @os_sched_getparam__doc__ }, %struct.PyMethodDef { ptr @.str.56, ptr @os_sched_getscheduler, i32 8, ptr @os_sched_getscheduler__doc__ }, %struct.PyMethodDef { ptr @.str.57, ptr @os_sched_rr_get_interval, i32 8, ptr @os_sched_rr_get_interval__doc__ }, %struct.PyMethodDef { ptr @.str.58, ptr @os_sched_setparam, i32 128, ptr @os_sched_setparam__doc__ }, %struct.PyMethodDef { ptr @.str.59, ptr @os_sched_setscheduler, i32 128, ptr @os_sched_setscheduler__doc__ }, %struct.PyMethodDef { ptr @.str.60, ptr @os_sched_yield, i32 4, ptr @os_sched_yield__doc__ }, %struct.PyMethodDef { ptr @.str.61, ptr @os_sched_setaffinity, i32 128, ptr @os_sched_setaffinity__doc__ }, %struct.PyMethodDef { ptr @.str.62, ptr @os_sched_getaffinity, i32 8, ptr @os_sched_getaffinity__doc__ }, %struct.PyMethodDef { ptr @.str.63, ptr @os_openpty, i32 4, ptr @os_openpty__doc__ }, %struct.PyMethodDef { ptr @.str.64, ptr @os_login_tty, i32 8, ptr @os_login_tty__doc__ }, %struct.PyMethodDef { ptr @.str.65, ptr @os_forkpty, i32 4, ptr @os_forkpty__doc__ }, %struct.PyMethodDef { ptr @.str.66, ptr @os_getegid, i32 4, ptr @os_getegid__doc__ }, %struct.PyMethodDef { ptr @.str.67, ptr @os_geteuid, i32 4, ptr @os_geteuid__doc__ }, %struct.PyMethodDef { ptr @.str.68, ptr @os_getgid, i32 4, ptr @os_getgid__doc__ }, %struct.PyMethodDef { ptr @.str.69, ptr @os_getgrouplist, i32 128, ptr @os_getgrouplist__doc__ }, %struct.PyMethodDef { ptr @.str.70, ptr @os_getgroups, i32 4, ptr @os_getgroups__doc__ }, %struct.PyMethodDef { ptr @.str.71, ptr @os_getpid, i32 4, ptr @os_getpid__doc__ }, %struct.PyMethodDef { ptr @.str.72, ptr @os_getpgrp, i32 4, ptr @os_getpgrp__doc__ }, %struct.PyMethodDef { ptr @.str.73, ptr @os_getppid, i32 4, ptr @os_getppid__doc__ }, %struct.PyMethodDef { ptr @.str.74, ptr @os_getuid, i32 4, ptr @os_getuid__doc__ }, %struct.PyMethodDef { ptr @.str.75, ptr @os_getlogin, i32 4, ptr @os_getlogin__doc__ }, %struct.PyMethodDef { ptr @.str.76, ptr @os_kill, i32 128, ptr @os_kill__doc__ }, %struct.PyMethodDef { ptr @.str.77, ptr @os_killpg, i32 128, ptr @os_killpg__doc__ }, %struct.PyMethodDef { ptr @.str.78, ptr @os_setuid, i32 8, ptr @os_setuid__doc__ }, %struct.PyMethodDef { ptr @.str.79, ptr @os_seteuid, i32 8, ptr @os_seteuid__doc__ }, %struct.PyMethodDef { ptr @.str.80, ptr @os_setreuid, i32 128, ptr @os_setreuid__doc__ }, %struct.PyMethodDef { ptr @.str.81, ptr @os_setgid, i32 8, ptr @os_setgid__doc__ }, %struct.PyMethodDef { ptr @.str.82, ptr @os_setegid, i32 8, ptr @os_setegid__doc__ }, %struct.PyMethodDef { ptr @.str.83, ptr @os_setregid, i32 128, ptr @os_setregid__doc__ }, %struct.PyMethodDef { ptr @.str.84, ptr @os_setgroups, i32 8, ptr @os_setgroups__doc__ }, %struct.PyMethodDef { ptr @.str.85, ptr @os_initgroups, i32 128, ptr @os_initgroups__doc__ }, %struct.PyMethodDef { ptr @.str.86, ptr @os_getpgid, i32 130, ptr @os_getpgid__doc__ }, %struct.PyMethodDef { ptr @.str.87, ptr @os_setpgrp, i32 4, ptr @os_setpgrp__doc__ }, %struct.PyMethodDef { ptr @.str.88, ptr @os_wait, i32 4, ptr @os_wait__doc__ }, %struct.PyMethodDef { ptr @.str.89, ptr @os_wait3, i32 130, ptr @os_wait3__doc__ }, %struct.PyMethodDef { ptr @.str.90, ptr @os_wait4, i32 130, ptr @os_wait4__doc__ }, %struct.PyMethodDef { ptr @.str.91, ptr @os_waitid, i32 128, ptr @os_waitid__doc__ }, %struct.PyMethodDef { ptr @.str.92, ptr @os_waitpid, i32 128, ptr @os_waitpid__doc__ }, %struct.PyMethodDef { ptr @.str.93, ptr @os_pidfd_open, i32 130, ptr @os_pidfd_open__doc__ }, %struct.PyMethodDef { ptr @.str.94, ptr @os_getsid, i32 8, ptr @os_getsid__doc__ }, %struct.PyMethodDef { ptr @.str.95, ptr @os_setsid, i32 4, ptr @os_setsid__doc__ }, %struct.PyMethodDef { ptr @.str.96, ptr @os_setpgid, i32 128, ptr @os_setpgid__doc__ }, %struct.PyMethodDef { ptr @.str.97, ptr @os_tcgetpgrp, i32 8, ptr @os_tcgetpgrp__doc__ }, %struct.PyMethodDef { ptr @.str.98, ptr @os_tcsetpgrp, i32 128, ptr @os_tcsetpgrp__doc__ }, %struct.PyMethodDef { ptr @.str.99, ptr @os_open, i32 130, ptr @os_open__doc__ }, %struct.PyMethodDef { ptr @.str.100, ptr @os_close, i32 130, ptr @os_close__doc__ }, %struct.PyMethodDef { ptr @.str.101, ptr @os_closerange, i32 128, ptr @os_closerange__doc__ }, %struct.PyMethodDef { ptr @.str.102, ptr @os_device_encoding, i32 130, ptr @os_device_encoding__doc__ }, %struct.PyMethodDef { ptr @.str.103, ptr @os_dup, i32 8, ptr @os_dup__doc__ }, %struct.PyMethodDef { ptr @.str.104, ptr @os_dup2, i32 130, ptr @os_dup2__doc__ }, %struct.PyMethodDef { ptr @.str.105, ptr @os_lockf, i32 128, ptr @os_lockf__doc__ }, %struct.PyMethodDef { ptr @.str.106, ptr @os_lseek, i32 128, ptr @os_lseek__doc__ }, %struct.PyMethodDef { ptr @.str.107, ptr @os_read, i32 128, ptr @os_read__doc__ }, %struct.PyMethodDef { ptr @.str.108, ptr @os_readv, i32 128, ptr @os_readv__doc__ }, %struct.PyMethodDef { ptr @.str.109, ptr @os_pread, i32 128, ptr @os_pread__doc__ }, %struct.PyMethodDef { ptr @.str.110, ptr @os_preadv, i32 128, ptr @os_preadv__doc__ }, %struct.PyMethodDef { ptr @.str.111, ptr @os_write, i32 128, ptr @os_write__doc__ }, %struct.PyMethodDef { ptr @.str.112, ptr @os_writev, i32 128, ptr @os_writev__doc__ }, %struct.PyMethodDef { ptr @.str.113, ptr @os_pwrite, i32 128, ptr @os_pwrite__doc__ }, %struct.PyMethodDef { ptr @.str.114, ptr @os_pwritev, i32 128, ptr @os_pwritev__doc__ }, %struct.PyMethodDef { ptr @.str.115, ptr @os_sendfile, i32 130, ptr @os_sendfile__doc__ }, %struct.PyMethodDef { ptr @.str.116, ptr @os_fstat, i32 130, ptr @os_fstat__doc__ }, %struct.PyMethodDef { ptr @.str.117, ptr @os_isatty, i32 8, ptr @os_isatty__doc__ }, %struct.PyMethodDef { ptr @.str.118, ptr @os_pipe, i32 4, ptr @os_pipe__doc__ }, %struct.PyMethodDef { ptr @.str.119, ptr @os_pipe2, i32 8, ptr @os_pipe2__doc__ }, %struct.PyMethodDef { ptr @.str.120, ptr @os_mkfifo, i32 130, ptr @os_mkfifo__doc__ }, %struct.PyMethodDef { ptr @.str.121, ptr @os_mknod, i32 130, ptr @os_mknod__doc__ }, %struct.PyMethodDef { ptr @.str.122, ptr @os_major, i32 8, ptr @os_major__doc__ }, %struct.PyMethodDef { ptr @.str.123, ptr @os_minor, i32 8, ptr @os_minor__doc__ }, %struct.PyMethodDef { ptr @.str.124, ptr @os_makedev, i32 128, ptr @os_makedev__doc__ }, %struct.PyMethodDef { ptr @.str.125, ptr @os_ftruncate, i32 128, ptr @os_ftruncate__doc__ }, %struct.PyMethodDef { ptr @.str.126, ptr @os_truncate, i32 130, ptr @os_truncate__doc__ }, %struct.PyMethodDef { ptr @.str.127, ptr @os_posix_fallocate, i32 128, ptr @os_posix_fallocate__doc__ }, %struct.PyMethodDef { ptr @.str.128, ptr @os_posix_fadvise, i32 128, ptr @os_posix_fadvise__doc__ }, %struct.PyMethodDef { ptr @.str.129, ptr @os_putenv, i32 128, ptr @os_putenv__doc__ }, %struct.PyMethodDef { ptr @.str.130, ptr @os_unsetenv, i32 8, ptr @os_unsetenv__doc__ }, %struct.PyMethodDef { ptr @.str.131, ptr @os_strerror, i32 8, ptr @os_strerror__doc__ }, %struct.PyMethodDef { ptr @.str.132, ptr @os_fchdir, i32 130, ptr @os_fchdir__doc__ }, %struct.PyMethodDef { ptr @.str.133, ptr @os_fsync, i32 130, ptr @os_fsync__doc__ }, %struct.PyMethodDef { ptr @.str.134, ptr @os_sync, i32 4, ptr @os_sync__doc__ }, %struct.PyMethodDef { ptr @.str.135, ptr @os_fdatasync, i32 130, ptr @os_fdatasync__doc__ }, %struct.PyMethodDef { ptr @.str.136, ptr @os_WCOREDUMP, i32 8, ptr @os_WCOREDUMP__doc__ }, %struct.PyMethodDef { ptr @.str.137, ptr @os_WIFCONTINUED, i32 130, ptr @os_WIFCONTINUED__doc__ }, %struct.PyMethodDef { ptr @.str.138, ptr @os_WIFSTOPPED, i32 130, ptr @os_WIFSTOPPED__doc__ }, %struct.PyMethodDef { ptr @.str.139, ptr @os_WIFSIGNALED, i32 130, ptr @os_WIFSIGNALED__doc__ }, %struct.PyMethodDef { ptr @.str.140, ptr @os_WIFEXITED, i32 130, ptr @os_WIFEXITED__doc__ }, %struct.PyMethodDef { ptr @.str.141, ptr @os_WEXITSTATUS, i32 130, ptr @os_WEXITSTATUS__doc__ }, %struct.PyMethodDef { ptr @.str.142, ptr @os_WTERMSIG, i32 130, ptr @os_WTERMSIG__doc__ }, %struct.PyMethodDef { ptr @.str.143, ptr @os_WSTOPSIG, i32 130, ptr @os_WSTOPSIG__doc__ }, %struct.PyMethodDef { ptr @.str.144, ptr @os_fstatvfs, i32 8, ptr @os_fstatvfs__doc__ }, %struct.PyMethodDef { ptr @.str.145, ptr @os_statvfs, i32 130, ptr @os_statvfs__doc__ }, %struct.PyMethodDef { ptr @.str.146, ptr @os_confstr, i32 8, ptr @os_confstr__doc__ }, %struct.PyMethodDef { ptr @.str.147, ptr @os_sysconf, i32 8, ptr @os_sysconf__doc__ }, %struct.PyMethodDef { ptr @.str.148, ptr @os_fpathconf, i32 128, ptr @os_fpathconf__doc__ }, %struct.PyMethodDef { ptr @.str.149, ptr @os_pathconf, i32 130, ptr @os_pathconf__doc__ }, %struct.PyMethodDef { ptr @.str.150, ptr @os_abort, i32 4, ptr @os_abort__doc__ }, %struct.PyMethodDef { ptr @.str.151, ptr @os__path_normpath, i32 130, ptr @os__path_normpath__doc__ }, %struct.PyMethodDef { ptr @.str.152, ptr @os_getloadavg, i32 4, ptr @os_getloadavg__doc__ }, %struct.PyMethodDef { ptr @.str.153, ptr @os_urandom, i32 8, ptr @os_urandom__doc__ }, %struct.PyMethodDef { ptr @.str.154, ptr @os_setresuid, i32 128, ptr @os_setresuid__doc__ }, %struct.PyMethodDef { ptr @.str.155, ptr @os_setresgid, i32 128, ptr @os_setresgid__doc__ }, %struct.PyMethodDef { ptr @.str.156, ptr @os_getresuid, i32 4, ptr @os_getresuid__doc__ }, %struct.PyMethodDef { ptr @.str.157, ptr @os_getresgid, i32 4, ptr @os_getresgid__doc__ }, %struct.PyMethodDef { ptr @.str.158, ptr @os_getxattr, i32 130, ptr @os_getxattr__doc__ }, %struct.PyMethodDef { ptr @.str.159, ptr @os_setxattr, i32 130, ptr @os_setxattr__doc__ }, %struct.PyMethodDef { ptr @.str.160, ptr @os_removexattr, i32 130, ptr @os_removexattr__doc__ }, %struct.PyMethodDef { ptr @.str.161, ptr @os_listxattr, i32 130, ptr @os_listxattr__doc__ }, %struct.PyMethodDef { ptr @.str.162, ptr @os_get_terminal_size, i32 128, ptr @os_get_terminal_size__doc__ }, %struct.PyMethodDef { ptr @.str.163, ptr @os_cpu_count, i32 4, ptr @os_cpu_count__doc__ }, %struct.PyMethodDef { ptr @.str.164, ptr @os_get_inheritable, i32 8, ptr @os_get_inheritable__doc__ }, %struct.PyMethodDef { ptr @.str.165, ptr @os_set_inheritable, i32 128, ptr @os_set_inheritable__doc__ }, %struct.PyMethodDef { ptr @.str.166, ptr @os_get_blocking, i32 8, ptr @os_get_blocking__doc__ }, %struct.PyMethodDef { ptr @.str.167, ptr @os_set_blocking, i32 128, ptr @os_set_blocking__doc__ }, %struct.PyMethodDef { ptr @.str.168, ptr @os_scandir, i32 130, ptr @os_scandir__doc__ }, %struct.PyMethodDef { ptr @.str.169, ptr @os_fspath, i32 130, ptr @os_fspath__doc__ }, %struct.PyMethodDef { ptr @.str.170, ptr @os_getrandom, i32 130, ptr @os_getrandom__doc__ }, %struct.PyMethodDef { ptr @.str.171, ptr @os_memfd_create, i32 130, ptr @os_memfd_create__doc__ }, %struct.PyMethodDef { ptr @.str.172, ptr @os_eventfd, i32 130, ptr @os_eventfd__doc__ }, %struct.PyMethodDef { ptr @.str.173, ptr @os_eventfd_read, i32 130, ptr @os_eventfd_read__doc__ }, %struct.PyMethodDef { ptr @.str.174, ptr @os_eventfd_write, i32 130, ptr @os_eventfd_write__doc__ }, %struct.PyMethodDef { ptr @.str.175, ptr @os_waitstatus_to_exitcode, i32 130, ptr @os_waitstatus_to_exitcode__doc__ }, %struct.PyMethodDef { ptr @.str.176, ptr @os_setns, i32 130, ptr @os_setns__doc__ }, %struct.PyMethodDef { ptr @.str.177, ptr @os_unshare, i32 130, ptr @os_unshare__doc__ }, %struct.PyMethodDef { ptr @.str.178, ptr @os_timerfd_create, i32 130, ptr @os_timerfd_create__doc__ }, %struct.PyMethodDef { ptr @.str.179, ptr @os_timerfd_settime, i32 130, ptr @os_timerfd_settime__doc__ }, %struct.PyMethodDef { ptr @.str.180, ptr @os_timerfd_settime_ns, i32 130, ptr @os_timerfd_settime_ns__doc__ }, %struct.PyMethodDef { ptr @.str.181, ptr @os_timerfd_gettime, i32 8, ptr @os_timerfd_gettime__doc__ }, %struct.PyMethodDef { ptr @.str.182, ptr @os_timerfd_gettime_ns, i32 8, ptr @os_timerfd_gettime_ns__doc__ }, %struct.PyMethodDef zeroinitializer], align 16
@posixmodile_slots = internal global [3 x %struct.PyModuleDef_Slot] [%struct.PyModuleDef_Slot { i32 2, ptr @posixmodule_exec }, %struct.PyModuleDef_Slot { i32 3, ptr inttoptr (i64 2 to ptr) }, %struct.PyModuleDef_Slot zeroinitializer], align 16
@.str.12 = private unnamed_addr constant [5 x i8] c"stat\00", align 1
@os_stat__doc__ = internal constant [807 x i8] c"stat($module, /, path, *, dir_fd=None, follow_symlinks=True)\0A--\0A\0APerform a stat system call on the given path.\0A\0A  path\0A    Path to be examined; can be string, bytes, a path-like object or\0A    open-file-descriptor int.\0A  dir_fd\0A    If not None, it should be a file descriptor open to a directory,\0A    and path should be a relative string; path will then be relative to\0A    that directory.\0A  follow_symlinks\0A    If False, and the last element of the path is a symbolic link,\0A    stat will examine the symbolic link itself instead of the file\0A    the link points to.\0A\0Adir_fd and follow_symlinks may not be implemented\0A  on your platform.  If they are unavailable, using them will raise a\0A  NotImplementedError.\0A\0AIt's an error to use dir_fd or follow_symlinks when specifying path as\0A  an open file descriptor.\00", align 16
@.str.13 = private unnamed_addr constant [7 x i8] c"access\00", align 1
@os_access__doc__ = internal constant [1143 x i8] c"access($module, /, path, mode, *, dir_fd=None, effective_ids=False,\0A       follow_symlinks=True)\0A--\0A\0AUse the real uid/gid to test for access to a path.\0A\0A  path\0A    Path to be tested; can be string, bytes, or a path-like object.\0A  mode\0A    Operating-system mode bitfield.  Can be F_OK to test existence,\0A    or the inclusive-OR of R_OK, W_OK, and X_OK.\0A  dir_fd\0A    If not None, it should be a file descriptor open to a directory,\0A    and path should be relative; path will then be relative to that\0A    directory.\0A  effective_ids\0A    If True, access will use the effective uid/gid instead of\0A    the real uid/gid.\0A  follow_symlinks\0A    If False, and the last element of the path is a symbolic link,\0A    access will examine the symbolic link itself instead of the file\0A    the link points to.\0A\0Adir_fd, effective_ids, and follow_symlinks may not be implemented\0A  on your platform.  If they are unavailable, using them will raise a\0A  NotImplementedError.\0A\0ANote that most operations will use the effective uid/gid, therefore this\0A  routine can be used in a suid/sgid environment to test if the invoking user\0A  has the specified access to the path.\00", align 16
@.str.14 = private unnamed_addr constant [8 x i8] c"ttyname\00", align 1
@os_ttyname__doc__ = internal constant [128 x i8] c"ttyname($module, fd, /)\0A--\0A\0AReturn the name of the terminal device connected to 'fd'.\0A\0A  fd\0A    Integer file descriptor handle.\00", align 16
@.str.15 = private unnamed_addr constant [6 x i8] c"chdir\00", align 1
@os_chdir__doc__ = internal constant [275 x i8] c"chdir($module, /, path)\0A--\0A\0AChange the current working directory to the specified path.\0A\0Apath may always be specified as a string.\0AOn some platforms, path may also be specified as an open file descriptor.\0A  If this functionality is unavailable, using it raises an exception.\00", align 16
@.str.16 = private unnamed_addr constant [6 x i8] c"chmod\00", align 1
@os_chmod__doc__ = internal constant [1191 x i8] c"chmod($module, /, path, mode, *, dir_fd=None,\0A      follow_symlinks=(os.name != 'nt'))\0A--\0A\0AChange the access permissions of a file.\0A\0A  path\0A    Path to be modified.  May always be specified as a str, bytes, or a path-like object.\0A    On some platforms, path may also be specified as an open file descriptor.\0A    If this functionality is unavailable, using it raises an exception.\0A  mode\0A    Operating-system mode bitfield.\0A    Be careful when using number literals for *mode*. The conventional UNIX notation for\0A    numeric modes uses an octal base, which needs to be indicated with a ``0o`` prefix in\0A    Python.\0A  dir_fd\0A    If not None, it should be a file descriptor open to a directory,\0A    and path should be relative; path will then be relative to that\0A    directory.\0A  follow_symlinks\0A    If False, and the last element of the path is a symbolic link,\0A    chmod will modify the symbolic link itself instead of the file\0A    the link points to.\0A\0AIt is an error to use dir_fd or follow_symlinks when specifying path as\0A  an open file descriptor.\0Adir_fd and follow_symlinks may not be implemented on your platform.\0A  If they are unavailable, using them will raise a NotImplementedError.\00", align 16
@.str.17 = private unnamed_addr constant [7 x i8] c"fchmod\00", align 1
@os_fchmod__doc__ = internal constant [431 x i8] c"fchmod($module, /, fd, mode)\0A--\0A\0AChange the access permissions of the file given by file descriptor fd.\0A\0A  fd\0A    The file descriptor of the file to be modified.\0A  mode\0A    Operating-system mode bitfield.\0A    Be careful when using number literals for *mode*. The conventional UNIX notation for\0A    numeric modes uses an octal base, which needs to be indicated with a ``0o`` prefix in\0A    Python.\0A\0AEquivalent to os.chmod(fd, mode).\00", align 16
@.str.18 = private unnamed_addr constant [6 x i8] c"chown\00", align 1
@os_chown__doc__ = internal constant [1331 x i8] c"chown($module, /, path, uid, gid, *, dir_fd=None, follow_symlinks=True)\0A--\0A\0AChange the owner and group id of path to the numeric uid and gid.\\\0A\0A  path\0A    Path to be examined; can be string, bytes, a path-like object, or open-file-descriptor int.\0A  dir_fd\0A    If not None, it should be a file descriptor open to a directory,\0A    and path should be relative; path will then be relative to that\0A    directory.\0A  follow_symlinks\0A    If False, and the last element of the path is a symbolic link,\0A    stat will examine the symbolic link itself instead of the file\0A    the link points to.\0A\0Apath may always be specified as a string.\0AOn some platforms, path may also be specified as an open file descriptor.\0A  If this functionality is unavailable, using it raises an exception.\0AIf dir_fd is not None, it should be a file descriptor open to a directory,\0A  and path should be relative; path will then be relative to that directory.\0AIf follow_symlinks is False, and the last element of the path is a symbolic\0A  link, chown will modify the symbolic link itself instead of the file the\0A  link points to.\0AIt is an error to use dir_fd or follow_symlinks when specifying path as\0A  an open file descriptor.\0Adir_fd and follow_symlinks may not be implemented on your platform.\0A  If they are unavailable, using them will raise a NotImplementedError.\00", align 16
@.str.19 = private unnamed_addr constant [7 x i8] c"fchown\00", align 1
@os_fchown__doc__ = internal constant [148 x i8] c"fchown($module, /, fd, uid, gid)\0A--\0A\0AChange the owner and group id of the file specified by file descriptor.\0A\0AEquivalent to os.chown(fd, uid, gid).\00", align 16
@.str.20 = private unnamed_addr constant [7 x i8] c"lchown\00", align 1
@os_lchown__doc__ = internal constant [215 x i8] c"lchown($module, /, path, uid, gid)\0A--\0A\0AChange the owner and group id of path to the numeric uid and gid.\0A\0AThis function will not follow symbolic links.\0AEquivalent to os.chown(path, uid, gid, follow_symlinks=False).\00", align 16
@.str.21 = private unnamed_addr constant [7 x i8] c"chroot\00", align 1
@os_chroot__doc__ = internal constant [60 x i8] c"chroot($module, /, path)\0A--\0A\0AChange root directory to path.\00", align 16
@.str.22 = private unnamed_addr constant [8 x i8] c"ctermid\00", align 1
@os_ctermid__doc__ = internal constant [86 x i8] c"ctermid($module, /)\0A--\0A\0AReturn the name of the controlling terminal for this process.\00", align 16
@.str.23 = private unnamed_addr constant [7 x i8] c"getcwd\00", align 1
@os_getcwd__doc__ = internal constant [91 x i8] c"getcwd($module, /)\0A--\0A\0AReturn a unicode string representing the current working directory.\00", align 16
@.str.24 = private unnamed_addr constant [8 x i8] c"getcwdb\00", align 1
@os_getcwdb__doc__ = internal constant [90 x i8] c"getcwdb($module, /)\0A--\0A\0AReturn a bytes string representing the current working directory.\00", align 16
@.str.25 = private unnamed_addr constant [5 x i8] c"link\00", align 1
@os_link__doc__ = internal constant [677 x i8] c"link($module, /, src, dst, *, src_dir_fd=None, dst_dir_fd=None,\0A     follow_symlinks=True)\0A--\0A\0ACreate a hard link to a file.\0A\0AIf either src_dir_fd or dst_dir_fd is not None, it should be a file\0A  descriptor open to a directory, and the respective path string (src or dst)\0A  should be relative; the path will then be relative to that directory.\0AIf follow_symlinks is False, and the last element of src is a symbolic\0A  link, link will create a link to the symbolic link itself instead of the\0A  file the link points to.\0Asrc_dir_fd, dst_dir_fd, and follow_symlinks may not be implemented on your\0A  platform.  If they are unavailable, using them will raise a\0A  NotImplementedError.\00", align 16
@.str.26 = private unnamed_addr constant [8 x i8] c"listdir\00", align 1
@os_listdir__doc__ = internal constant [665 x i8] c"listdir($module, /, path=None)\0A--\0A\0AReturn a list containing the names of the files in the directory.\0A\0Apath can be specified as either str, bytes, or a path-like object.  If path is bytes,\0A  the filenames returned will also be bytes; in all other circumstances\0A  the filenames returned will be str.\0AIf path is None, uses the path='.'.\0AOn some platforms, path may also be specified as an open file descriptor;\\\0A  the file descriptor must refer to a directory.\0A  If this functionality is unavailable, using it raises NotImplementedError.\0A\0AThe list is in arbitrary order.  It does not include the special\0Aentries '.' and '..' even if they are present in the directory.\00", align 16
@.str.27 = private unnamed_addr constant [6 x i8] c"lstat\00", align 1
@os_lstat__doc__ = internal constant [221 x i8] c"lstat($module, /, path, *, dir_fd=None)\0A--\0A\0APerform a stat system call on the given path, without following symbolic links.\0A\0ALike stat(), but do not follow symbolic links.\0AEquivalent to stat(path, follow_symlinks=False).\00", align 16
@.str.28 = private unnamed_addr constant [6 x i8] c"mkdir\00", align 1
@os_mkdir__doc__ = internal constant [447 x i8] c"mkdir($module, /, path, mode=511, *, dir_fd=None)\0A--\0A\0ACreate a directory.\0A\0AIf dir_fd is not None, it should be a file descriptor open to a directory,\0A  and path should be relative; path will then be relative to that directory.\0Adir_fd may not be implemented on your platform.\0A  If it is unavailable, using it will raise a NotImplementedError.\0A\0AThe mode argument is ignored on Windows. Where it is used, the current umask\0Avalue is first masked out.\00", align 16
@.str.29 = private unnamed_addr constant [5 x i8] c"nice\00", align 1
@os_nice__doc__ = internal constant [102 x i8] c"nice($module, increment, /)\0A--\0A\0AAdd increment to the priority of process and return the new priority.\00", align 16
@.str.30 = private unnamed_addr constant [12 x i8] c"getpriority\00", align 1
@os_getpriority__doc__ = internal constant [76 x i8] c"getpriority($module, /, which, who)\0A--\0A\0AReturn program scheduling priority.\00", align 16
@.str.31 = private unnamed_addr constant [12 x i8] c"setpriority\00", align 1
@os_setpriority__doc__ = internal constant [83 x i8] c"setpriority($module, /, which, who, priority)\0A--\0A\0ASet program scheduling priority.\00", align 16
@.str.32 = private unnamed_addr constant [12 x i8] c"posix_spawn\00", align 1
@os_posix_spawn__doc__ = internal constant [920 x i8] c"posix_spawn($module, path, argv, env, /, *, file_actions=(),\0A            setpgroup=<unrepresentable>, resetids=False, setsid=False,\0A            setsigmask=(), setsigdef=(), scheduler=<unrepresentable>)\0A--\0A\0AExecute the program specified by path in a new process.\0A\0A  path\0A    Path of executable file.\0A  argv\0A    Tuple or list of strings.\0A  env\0A    Dictionary of strings mapping to strings.\0A  file_actions\0A    A sequence of file action tuples.\0A  setpgroup\0A    The pgroup to use with the POSIX_SPAWN_SETPGROUP flag.\0A  resetids\0A    If the value is `true` the POSIX_SPAWN_RESETIDS will be activated.\0A  setsid\0A    If the value is `true` the POSIX_SPAWN_SETSID or POSIX_SPAWN_SETSID_NP will be activated.\0A  setsigmask\0A    The sigmask to use with the POSIX_SPAWN_SETSIGMASK flag.\0A  setsigdef\0A    The sigmask to use with the POSIX_SPAWN_SETSIGDEF flag.\0A  scheduler\0A    A tuple with the scheduler policy (optional) and parameters.\00", align 16
@.str.33 = private unnamed_addr constant [13 x i8] c"posix_spawnp\00", align 1
@os_posix_spawnp__doc__ = internal constant [923 x i8] c"posix_spawnp($module, path, argv, env, /, *, file_actions=(),\0A             setpgroup=<unrepresentable>, resetids=False, setsid=False,\0A             setsigmask=(), setsigdef=(), scheduler=<unrepresentable>)\0A--\0A\0AExecute the program specified by path in a new process.\0A\0A  path\0A    Path of executable file.\0A  argv\0A    Tuple or list of strings.\0A  env\0A    Dictionary of strings mapping to strings.\0A  file_actions\0A    A sequence of file action tuples.\0A  setpgroup\0A    The pgroup to use with the POSIX_SPAWN_SETPGROUP flag.\0A  resetids\0A    If the value is `True` the POSIX_SPAWN_RESETIDS will be activated.\0A  setsid\0A    If the value is `True` the POSIX_SPAWN_SETSID or POSIX_SPAWN_SETSID_NP will be activated.\0A  setsigmask\0A    The sigmask to use with the POSIX_SPAWN_SETSIGMASK flag.\0A  setsigdef\0A    The sigmask to use with the POSIX_SPAWN_SETSIGDEF flag.\0A  scheduler\0A    A tuple with the scheduler policy (optional) and parameters.\00", align 16
@.str.34 = private unnamed_addr constant [9 x i8] c"readlink\00", align 1
@os_readlink__doc__ = internal constant [386 x i8] c"readlink($module, /, path, *, dir_fd=None)\0A--\0A\0AReturn a string representing the path to which the symbolic link points.\0A\0AIf dir_fd is not None, it should be a file descriptor open to a directory,\0Aand path should be relative; path will then be relative to that directory.\0A\0Adir_fd may not be implemented on your platform.  If it is unavailable,\0Ausing it will raise a NotImplementedError.\00", align 16
@.str.35 = private unnamed_addr constant [16 x i8] c"copy_file_range\00", align 1
@os_copy_file_range__doc__ = internal constant [443 x i8] c"copy_file_range($module, /, src, dst, count, offset_src=None,\0A                offset_dst=None)\0A--\0A\0ACopy count bytes from one file descriptor to another.\0A\0A  src\0A    Source file descriptor.\0A  dst\0A    Destination file descriptor.\0A  count\0A    Number of bytes to copy.\0A  offset_src\0A    Starting offset in src.\0A  offset_dst\0A    Starting offset in dst.\0A\0AIf offset_src is None, then src is read from the current position;\0Arespectively for offset_dst.\00", align 16
@.str.36 = private unnamed_addr constant [7 x i8] c"splice\00", align 1
@os_splice__doc__ = internal constant [582 x i8] c"splice($module, /, src, dst, count, offset_src=None, offset_dst=None,\0A       flags=0)\0A--\0A\0ATransfer count bytes from one pipe to a descriptor or vice versa.\0A\0A  src\0A    Source file descriptor.\0A  dst\0A    Destination file descriptor.\0A  count\0A    Number of bytes to copy.\0A  offset_src\0A    Starting offset in src.\0A  offset_dst\0A    Starting offset in dst.\0A  flags\0A    Flags to modify the semantics of the call.\0A\0AIf offset_src is None, then src is read from the current position;\0Arespectively for offset_dst. The offset associated to the file\0Adescriptor that refers to a pipe must be None.\00", align 16
@.str.37 = private unnamed_addr constant [7 x i8] c"rename\00", align 1
@os_rename__doc__ = internal constant [457 x i8] c"rename($module, /, src, dst, *, src_dir_fd=None, dst_dir_fd=None)\0A--\0A\0ARename a file or directory.\0A\0AIf either src_dir_fd or dst_dir_fd is not None, it should be a file\0A  descriptor open to a directory, and the respective path string (src or dst)\0A  should be relative; the path will then be relative to that directory.\0Asrc_dir_fd and dst_dir_fd, may not be implemented on your platform.\0A  If they are unavailable, using them will raise a NotImplementedError.\00", align 16
@.str.38 = private unnamed_addr constant [8 x i8] c"replace\00", align 1
@os_replace__doc__ = internal constant [487 x i8] c"replace($module, /, src, dst, *, src_dir_fd=None, dst_dir_fd=None)\0A--\0A\0ARename a file or directory, overwriting the destination.\0A\0AIf either src_dir_fd or dst_dir_fd is not None, it should be a file\0A  descriptor open to a directory, and the respective path string (src or dst)\0A  should be relative; the path will then be relative to that directory.\0Asrc_dir_fd and dst_dir_fd, may not be implemented on your platform.\0A  If they are unavailable, using them will raise a NotImplementedError.\00", align 16
@.str.39 = private unnamed_addr constant [6 x i8] c"rmdir\00", align 1
@os_rmdir__doc__ = internal constant [332 x i8] c"rmdir($module, /, path, *, dir_fd=None)\0A--\0A\0ARemove a directory.\0A\0AIf dir_fd is not None, it should be a file descriptor open to a directory,\0A  and path should be relative; path will then be relative to that directory.\0Adir_fd may not be implemented on your platform.\0A  If it is unavailable, using it will raise a NotImplementedError.\00", align 16
@.str.40 = private unnamed_addr constant [8 x i8] c"symlink\00", align 1
@os_symlink__doc__ = internal constant [653 x i8] c"symlink($module, /, src, dst, target_is_directory=False, *, dir_fd=None)\0A--\0A\0ACreate a symbolic link pointing to src named dst.\0A\0Atarget_is_directory is required on Windows if the target is to be\0A  interpreted as a directory.  (On Windows, symlink requires\0A  Windows 6.0 or greater, and raises a NotImplementedError otherwise.)\0A  target_is_directory is ignored on non-Windows platforms.\0A\0AIf dir_fd is not None, it should be a file descriptor open to a directory,\0A  and path should be relative; path will then be relative to that directory.\0Adir_fd may not be implemented on your platform.\0A  If it is unavailable, using it will raise a NotImplementedError.\00", align 16
@.str.41 = private unnamed_addr constant [7 x i8] c"system\00", align 1
@os_system__doc__ = internal constant [67 x i8] c"system($module, /, command)\0A--\0A\0AExecute the command in a subshell.\00", align 16
@.str.42 = private unnamed_addr constant [6 x i8] c"umask\00", align 1
@os_umask__doc__ = internal constant [89 x i8] c"umask($module, mask, /)\0A--\0A\0ASet the current numeric umask and return the previous umask.\00", align 16
@.str.43 = private unnamed_addr constant [6 x i8] c"uname\00", align 1
@os_uname__doc__ = internal constant [196 x i8] c"uname($module, /)\0A--\0A\0AReturn an object identifying the current operating system.\0A\0AThe object behaves like a named tuple with the following fields:\0A  (sysname, nodename, release, version, machine)\00", align 16
@.str.44 = private unnamed_addr constant [7 x i8] c"unlink\00", align 1
@os_unlink__doc__ = internal constant [347 x i8] c"unlink($module, /, path, *, dir_fd=None)\0A--\0A\0ARemove a file (same as remove()).\0A\0AIf dir_fd is not None, it should be a file descriptor open to a directory,\0A  and path should be relative; path will then be relative to that directory.\0Adir_fd may not be implemented on your platform.\0A  If it is unavailable, using it will raise a NotImplementedError.\00", align 16
@.str.45 = private unnamed_addr constant [7 x i8] c"remove\00", align 1
@os_remove__doc__ = internal constant [347 x i8] c"remove($module, /, path, *, dir_fd=None)\0A--\0A\0ARemove a file (same as unlink()).\0A\0AIf dir_fd is not None, it should be a file descriptor open to a directory,\0A  and path should be relative; path will then be relative to that directory.\0Adir_fd may not be implemented on your platform.\0A  If it is unavailable, using it will raise a NotImplementedError.\00", align 16
@.str.46 = private unnamed_addr constant [6 x i8] c"utime\00", align 1
@os_utime__doc__ = internal constant [1299 x i8] c"utime($module, /, path, times=None, *, ns=<unrepresentable>,\0A      dir_fd=None, follow_symlinks=True)\0A--\0A\0ASet the access and modified time of path.\0A\0Apath may always be specified as a string.\0AOn some platforms, path may also be specified as an open file descriptor.\0A  If this functionality is unavailable, using it raises an exception.\0A\0AIf times is not None, it must be a tuple (atime, mtime);\0A    atime and mtime should be expressed as float seconds since the epoch.\0AIf ns is specified, it must be a tuple (atime_ns, mtime_ns);\0A    atime_ns and mtime_ns should be expressed as integer nanoseconds\0A    since the epoch.\0AIf times is None and ns is unspecified, utime uses the current time.\0ASpecifying tuples for both times and ns is an error.\0A\0AIf dir_fd is not None, it should be a file descriptor open to a directory,\0A  and path should be relative; path will then be relative to that directory.\0AIf follow_symlinks is False, and the last element of the path is a symbolic\0A  link, utime will modify the symbolic link itself instead of the file the\0A  link points to.\0AIt is an error to use dir_fd or follow_symlinks when specifying path\0A  as an open file descriptor.\0Adir_fd and follow_symlinks may not be available on your platform.\0A  If they are unavailable, using them will raise a NotImplementedError.\00", align 16
@.str.47 = private unnamed_addr constant [6 x i8] c"times\00", align 1
@os_times__doc__ = internal constant [234 x i8] c"times($module, /)\0A--\0A\0AReturn a collection containing process timing information.\0A\0AThe object returned behaves like a named tuple with these fields:\0A  (utime, stime, cutime, cstime, elapsed_time)\0AAll fields are floating point numbers.\00", align 16
@.str.48 = private unnamed_addr constant [6 x i8] c"_exit\00", align 1
@os__exit__doc__ = internal constant [104 x i8] c"_exit($module, /, status)\0A--\0A\0AExit to the system with specified status, without normal exit processing.\00", align 16
@.str.49 = private unnamed_addr constant [6 x i8] c"execv\00", align 1
@os_execv__doc__ = internal constant [178 x i8] c"execv($module, path, argv, /)\0A--\0A\0AExecute an executable path with arguments, replacing current process.\0A\0A  path\0A    Path of executable file.\0A  argv\0A    Tuple or list of strings.\00", align 16
@.str.50 = private unnamed_addr constant [7 x i8] c"execve\00", align 1
@os_execve__doc__ = internal constant [236 x i8] c"execve($module, /, path, argv, env)\0A--\0A\0AExecute an executable path with arguments, replacing current process.\0A\0A  path\0A    Path of executable file.\0A  argv\0A    Tuple or list of strings.\0A  env\0A    Dictionary of strings mapping to strings.\00", align 16
@.str.51 = private unnamed_addr constant [5 x i8] c"fork\00", align 1
@os_fork__doc__ = internal constant [106 x i8] c"fork($module, /)\0A--\0A\0AFork a child process.\0A\0AReturn 0 to child process and PID of child to parent process.\00", align 16
@.str.52 = private unnamed_addr constant [17 x i8] c"register_at_fork\00", align 1
@os_register_at_fork__doc__ = internal constant [569 x i8] c"register_at_fork($module, /, *, before=<unrepresentable>,\0A                 after_in_child=<unrepresentable>,\0A                 after_in_parent=<unrepresentable>)\0A--\0A\0ARegister callables to be called when forking a new process.\0A\0A  before\0A    A callable to be called in the parent before the fork() syscall.\0A  after_in_child\0A    A callable to be called in the child after fork().\0A  after_in_parent\0A    A callable to be called in the parent after fork().\0A\0A'before' callbacks are called in reverse order.\0A'after_in_child' and 'after_in_parent' callbacks are called in order.\00", align 16
@.str.53 = private unnamed_addr constant [23 x i8] c"sched_get_priority_max\00", align 1
@os_sched_get_priority_max__doc__ = internal constant [95 x i8] c"sched_get_priority_max($module, /, policy)\0A--\0A\0AGet the maximum scheduling priority for policy.\00", align 16
@.str.54 = private unnamed_addr constant [23 x i8] c"sched_get_priority_min\00", align 1
@os_sched_get_priority_min__doc__ = internal constant [95 x i8] c"sched_get_priority_min($module, /, policy)\0A--\0A\0AGet the minimum scheduling priority for policy.\00", align 16
@.str.55 = private unnamed_addr constant [15 x i8] c"sched_getparam\00", align 1
@os_sched_getparam__doc__ = internal constant [203 x i8] c"sched_getparam($module, pid, /)\0A--\0A\0AReturns scheduling parameters for the process identified by pid.\0A\0AIf pid is 0, returns parameters for the calling process.\0AReturn value is an instance of sched_param.\00", align 16
@.str.56 = private unnamed_addr constant [19 x i8] c"sched_getscheduler\00", align 1
@os_sched_getscheduler__doc__ = internal constant [175 x i8] c"sched_getscheduler($module, pid, /)\0A--\0A\0AGet the scheduling policy for the process identified by pid.\0A\0APassing 0 for pid returns the scheduling policy for the calling process.\00", align 16
@.str.57 = private unnamed_addr constant [22 x i8] c"sched_rr_get_interval\00", align 1
@os_sched_rr_get_interval__doc__ = internal constant [149 x i8] c"sched_rr_get_interval($module, pid, /)\0A--\0A\0AReturn the round-robin quantum for the process identified by pid, in seconds.\0A\0AValue returned is a float.\00", align 16
@.str.58 = private unnamed_addr constant [15 x i8] c"sched_setparam\00", align 1
@os_sched_setparam__doc__ = internal constant [203 x i8] c"sched_setparam($module, pid, param, /)\0A--\0A\0ASet scheduling parameters for the process identified by pid.\0A\0AIf pid is 0, sets parameters for the calling process.\0Aparam should be an instance of sched_param.\00", align 16
@.str.59 = private unnamed_addr constant [19 x i8] c"sched_setscheduler\00", align 1
@os_sched_setscheduler__doc__ = internal constant [199 x i8] c"sched_setscheduler($module, pid, policy, param, /)\0A--\0A\0ASet the scheduling policy for the process identified by pid.\0A\0AIf pid is 0, the calling process is changed.\0Aparam is an instance of sched_param.\00", align 16
@.str.60 = private unnamed_addr constant [12 x i8] c"sched_yield\00", align 1
@os_sched_yield__doc__ = internal constant [60 x i8] c"sched_yield($module, /)\0A--\0A\0AVoluntarily relinquish the CPU.\00", align 16
@.str.61 = private unnamed_addr constant [18 x i8] c"sched_setaffinity\00", align 1
@os_sched_setaffinity__doc__ = internal constant [166 x i8] c"sched_setaffinity($module, pid, mask, /)\0A--\0A\0ASet the CPU affinity of the process identified by pid to mask.\0A\0Amask should be an iterable of integers identifying CPUs.\00", align 16
@.str.62 = private unnamed_addr constant [18 x i8] c"sched_getaffinity\00", align 1
@os_sched_getaffinity__doc__ = internal constant [181 x i8] c"sched_getaffinity($module, pid, /)\0A--\0A\0AReturn the affinity of the process identified by pid (or the current process if zero).\0A\0AThe affinity is returned as a set of CPU identifiers.\00", align 16
@.str.63 = private unnamed_addr constant [8 x i8] c"openpty\00", align 1
@os_openpty__doc__ = internal constant [158 x i8] c"openpty($module, /)\0A--\0A\0AOpen a pseudo-terminal.\0A\0AReturn a tuple of (master_fd, slave_fd) containing open file descriptors\0Afor both the master and slave ends.\00", align 16
@.str.64 = private unnamed_addr constant [10 x i8] c"login_tty\00", align 1
@os_login_tty__doc__ = internal constant [254 x i8] c"login_tty($module, fd, /)\0A--\0A\0APrepare the tty of which fd is a file descriptor for a new login session.\0A\0AMake the calling process a session leader; make the tty the\0Acontrolling tty, the stdin, the stdout, and the stderr of the\0Acalling process; close fd.\00", align 16
@.str.65 = private unnamed_addr constant [8 x i8] c"forkpty\00", align 1
@os_forkpty__doc__ = internal constant [271 x i8] c"forkpty($module, /)\0A--\0A\0AFork a new process with a new pseudo-terminal as controlling tty.\0A\0AReturns a tuple of (pid, master_fd).\0ALike fork(), return pid of 0 to the child process,\0Aand pid of child to the parent process.\0ATo both, return fd of newly opened pseudo-terminal.\00", align 16
@.str.66 = private unnamed_addr constant [8 x i8] c"getegid\00", align 1
@os_getegid__doc__ = internal constant [73 x i8] c"getegid($module, /)\0A--\0A\0AReturn the current process's effective group id.\00", align 16
@.str.67 = private unnamed_addr constant [8 x i8] c"geteuid\00", align 1
@os_geteuid__doc__ = internal constant [72 x i8] c"geteuid($module, /)\0A--\0A\0AReturn the current process's effective user id.\00", align 16
@.str.68 = private unnamed_addr constant [7 x i8] c"getgid\00", align 1
@os_getgid__doc__ = internal constant [62 x i8] c"getgid($module, /)\0A--\0A\0AReturn the current process's group id.\00", align 16
@.str.69 = private unnamed_addr constant [13 x i8] c"getgrouplist\00", align 1
@os_getgrouplist__doc__ = internal constant [161 x i8] c"getgrouplist($module, user, group, /)\0A--\0A\0AReturns a list of groups to which a user belongs.\0A\0A  user\0A    username to lookup\0A  group\0A    base group id of the user\00", align 16
@.str.70 = private unnamed_addr constant [10 x i8] c"getgroups\00", align 1
@os_getgroups__doc__ = internal constant [81 x i8] c"getgroups($module, /)\0A--\0A\0AReturn list of supplemental group IDs for the process.\00", align 16
@.str.71 = private unnamed_addr constant [7 x i8] c"getpid\00", align 1
@os_getpid__doc__ = internal constant [54 x i8] c"getpid($module, /)\0A--\0A\0AReturn the current process id.\00", align 16
@.str.72 = private unnamed_addr constant [8 x i8] c"getpgrp\00", align 1
@os_getpgrp__doc__ = internal constant [61 x i8] c"getpgrp($module, /)\0A--\0A\0AReturn the current process group id.\00", align 16
@.str.73 = private unnamed_addr constant [8 x i8] c"getppid\00", align 1
@os_getppid__doc__ = internal constant [203 x i8] c"getppid($module, /)\0A--\0A\0AReturn the parent's process id.\0A\0AIf the parent process has already exited, Windows machines will still\0Areturn its id; others systems will return the id of the 'init' process (1).\00", align 16
@.str.74 = private unnamed_addr constant [7 x i8] c"getuid\00", align 1
@os_getuid__doc__ = internal constant [61 x i8] c"getuid($module, /)\0A--\0A\0AReturn the current process's user id.\00", align 16
@.str.75 = private unnamed_addr constant [9 x i8] c"getlogin\00", align 1
@os_getlogin__doc__ = internal constant [55 x i8] c"getlogin($module, /)\0A--\0A\0AReturn the actual login name.\00", align 16
@.str.76 = private unnamed_addr constant [5 x i8] c"kill\00", align 1
@os_kill__doc__ = internal constant [64 x i8] c"kill($module, pid, signal, /)\0A--\0A\0AKill a process with a signal.\00", align 16
@.str.77 = private unnamed_addr constant [7 x i8] c"killpg\00", align 1
@os_killpg__doc__ = internal constant [73 x i8] c"killpg($module, pgid, signal, /)\0A--\0A\0AKill a process group with a signal.\00", align 16
@.str.78 = private unnamed_addr constant [7 x i8] c"setuid\00", align 1
@os_setuid__doc__ = internal constant [63 x i8] c"setuid($module, uid, /)\0A--\0A\0ASet the current process's user id.\00", align 16
@.str.79 = private unnamed_addr constant [8 x i8] c"seteuid\00", align 1
@os_seteuid__doc__ = internal constant [75 x i8] c"seteuid($module, euid, /)\0A--\0A\0ASet the current process's effective user id.\00", align 16
@.str.80 = private unnamed_addr constant [9 x i8] c"setreuid\00", align 1
@os_setreuid__doc__ = internal constant [92 x i8] c"setreuid($module, ruid, euid, /)\0A--\0A\0ASet the current process's real and effective user ids.\00", align 16
@.str.81 = private unnamed_addr constant [7 x i8] c"setgid\00", align 1
@os_setgid__doc__ = internal constant [64 x i8] c"setgid($module, gid, /)\0A--\0A\0ASet the current process's group id.\00", align 16
@.str.82 = private unnamed_addr constant [8 x i8] c"setegid\00", align 1
@os_setegid__doc__ = internal constant [76 x i8] c"setegid($module, egid, /)\0A--\0A\0ASet the current process's effective group id.\00", align 16
@.str.83 = private unnamed_addr constant [9 x i8] c"setregid\00", align 1
@os_setregid__doc__ = internal constant [93 x i8] c"setregid($module, rgid, egid, /)\0A--\0A\0ASet the current process's real and effective group ids.\00", align 16
@.str.84 = private unnamed_addr constant [10 x i8] c"setgroups\00", align 1
@os_setgroups__doc__ = internal constant [81 x i8] c"setgroups($module, groups, /)\0A--\0A\0ASet the groups of the current process to list.\00", align 16
@.str.85 = private unnamed_addr constant [11 x i8] c"initgroups\00", align 1
@os_initgroups__doc__ = internal constant [239 x i8] c"initgroups($module, username, gid, /)\0A--\0A\0AInitialize the group access list.\0A\0ACall the system initgroups() to initialize the group access list with all of\0Athe groups of which the specified username is a member, plus the specified\0Agroup id.\00", align 16
@.str.86 = private unnamed_addr constant [8 x i8] c"getpgid\00", align 1
@os_getpgid__doc__ = internal constant [84 x i8] c"getpgid($module, /, pid)\0A--\0A\0ACall the system call getpgid(), and return the result.\00", align 16
@.str.87 = private unnamed_addr constant [8 x i8] c"setpgrp\00", align 1
@os_setpgrp__doc__ = internal constant [82 x i8] c"setpgrp($module, /)\0A--\0A\0AMake the current process the leader of its process group.\00", align 16
@.str.88 = private unnamed_addr constant [5 x i8] c"wait\00", align 1
@os_wait__doc__ = internal constant [136 x i8] c"wait($module, /)\0A--\0A\0AWait for completion of a child process.\0A\0AReturns a tuple of information about the child process:\0A    (pid, status)\00", align 16
@.str.89 = private unnamed_addr constant [6 x i8] c"wait3\00", align 1
@os_wait3__doc__ = internal constant [152 x i8] c"wait3($module, /, options)\0A--\0A\0AWait for completion of a child process.\0A\0AReturns a tuple of information about the child process:\0A  (pid, status, rusage)\00", align 16
@.str.90 = private unnamed_addr constant [6 x i8] c"wait4\00", align 1
@os_wait4__doc__ = internal constant [166 x i8] c"wait4($module, /, pid, options)\0A--\0A\0AWait for completion of a specific child process.\0A\0AReturns a tuple of information about the child process:\0A  (pid, status, rusage)\00", align 16
@.str.91 = private unnamed_addr constant [7 x i8] c"waitid\00", align 1
@os_waitid__doc__ = internal constant [444 x i8] c"waitid($module, idtype, id, options, /)\0A--\0A\0AReturns the result of waiting for a process or processes.\0A\0A  idtype\0A    Must be one of be P_PID, P_PGID or P_ALL.\0A  id\0A    The id to wait on.\0A  options\0A    Constructed from the ORing of one or more of WEXITED, WSTOPPED\0A    or WCONTINUED and additionally may be ORed with WNOHANG or WNOWAIT.\0A\0AReturns either waitid_result or None if WNOHANG is specified and there are\0Ano children in a waitable state.\00", align 16
@.str.92 = private unnamed_addr constant [8 x i8] c"waitpid\00", align 1
@os_waitpid__doc__ = internal constant [208 x i8] c"waitpid($module, pid, options, /)\0A--\0A\0AWait for completion of a given child process.\0A\0AReturns a tuple of information regarding the child process:\0A    (pid, status)\0A\0AThe options argument is ignored on Windows.\00", align 16
@.str.93 = private unnamed_addr constant [11 x i8] c"pidfd_open\00", align 1
@os_pidfd_open__doc__ = internal constant [183 x i8] c"pidfd_open($module, /, pid, flags=0)\0A--\0A\0AReturn a file descriptor referring to the process *pid*.\0A\0AThe descriptor can be used to perform process management without races and\0Asignals.\00", align 16
@.str.94 = private unnamed_addr constant [7 x i8] c"getsid\00", align 1
@os_getsid__doc__ = internal constant [84 x i8] c"getsid($module, pid, /)\0A--\0A\0ACall the system call getsid(pid) and return the result.\00", align 16
@.str.95 = private unnamed_addr constant [7 x i8] c"setsid\00", align 1
@os_setsid__doc__ = internal constant [54 x i8] c"setsid($module, /)\0A--\0A\0ACall the system call setsid().\00", align 16
@.str.96 = private unnamed_addr constant [8 x i8] c"setpgid\00", align 1
@os_setpgid__doc__ = internal constant [76 x i8] c"setpgid($module, pid, pgrp, /)\0A--\0A\0ACall the system call setpgid(pid, pgrp).\00", align 16
@.str.97 = private unnamed_addr constant [10 x i8] c"tcgetpgrp\00", align 1
@os_tcgetpgrp__doc__ = internal constant [101 x i8] c"tcgetpgrp($module, fd, /)\0A--\0A\0AReturn the process group associated with the terminal specified by fd.\00", align 16
@.str.98 = private unnamed_addr constant [10 x i8] c"tcsetpgrp\00", align 1
@os_tcsetpgrp__doc__ = internal constant [104 x i8] c"tcsetpgrp($module, fd, pgid, /)\0A--\0A\0ASet the process group associated with the terminal specified by fd.\00", align 16
@.str.99 = private unnamed_addr constant [5 x i8] c"open\00", align 1
@os_open__doc__ = internal constant [396 x i8] c"open($module, /, path, flags, mode=511, *, dir_fd=None)\0A--\0A\0AOpen a file for low level IO.  Returns a file descriptor (integer).\0A\0AIf dir_fd is not None, it should be a file descriptor open to a directory,\0A  and path should be relative; path will then be relative to that directory.\0Adir_fd may not be implemented on your platform.\0A  If it is unavailable, using it will raise a NotImplementedError.\00", align 16
@.str.100 = private unnamed_addr constant [6 x i8] c"close\00", align 1
@os_close__doc__ = internal constant [51 x i8] c"close($module, /, fd)\0A--\0A\0AClose a file descriptor.\00", align 16
@.str.101 = private unnamed_addr constant [11 x i8] c"closerange\00", align 1
@os_closerange__doc__ = internal constant [111 x i8] c"closerange($module, fd_low, fd_high, /)\0A--\0A\0ACloses all file descriptors in [fd_low, fd_high), ignoring errors.\00", align 16
@.str.102 = private unnamed_addr constant [16 x i8] c"device_encoding\00", align 1
@os_device_encoding__doc__ = internal constant [208 x i8] c"device_encoding($module, /, fd)\0A--\0A\0AReturn a string describing the encoding of a terminal's file descriptor.\0A\0AThe file descriptor must be attached to a terminal.\0AIf the device is not a terminal, return None.\00", align 16
@.str.103 = private unnamed_addr constant [4 x i8] c"dup\00", align 1
@os_dup__doc__ = internal constant [65 x i8] c"dup($module, fd, /)\0A--\0A\0AReturn a duplicate of a file descriptor.\00", align 16
@.str.104 = private unnamed_addr constant [5 x i8] c"dup2\00", align 1
@os_dup2__doc__ = internal constant [75 x i8] c"dup2($module, /, fd, fd2, inheritable=True)\0A--\0A\0ADuplicate file descriptor.\00", align 16
@.str.105 = private unnamed_addr constant [6 x i8] c"lockf\00", align 1
@os_lockf__doc__ = internal constant [274 x i8] c"lockf($module, fd, command, length, /)\0A--\0A\0AApply, test or remove a POSIX lock on an open file descriptor.\0A\0A  fd\0A    An open file descriptor.\0A  command\0A    One of F_LOCK, F_TLOCK, F_ULOCK or F_TEST.\0A  length\0A    The number of bytes to lock, starting at the current position.\00", align 16
@.str.106 = private unnamed_addr constant [6 x i8] c"lseek\00", align 1
@os_lseek__doc__ = internal constant [525 x i8] c"lseek($module, fd, position, whence, /)\0A--\0A\0ASet the position of a file descriptor.  Return the new position.\0A\0A  fd\0A    An open file descriptor, as returned by os.open().\0A  position\0A    Position, interpreted relative to 'whence'.\0A  whence\0A    The relative position to seek from. Valid values are:\0A    - SEEK_SET: seek from the start of the file.\0A    - SEEK_CUR: seek from the current file position.\0A    - SEEK_END: seek from the end of the file.\0A\0AThe return value is the number of bytes relative to the beginning of the file.\00", align 16
@.str.107 = private unnamed_addr constant [5 x i8] c"read\00", align 1
@os_read__doc__ = internal constant [87 x i8] c"read($module, fd, length, /)\0A--\0A\0ARead from a file descriptor.  Returns a bytes object.\00", align 16
@.str.108 = private unnamed_addr constant [6 x i8] c"readv\00", align 1
@os_readv__doc__ = internal constant [401 x i8] c"readv($module, fd, buffers, /)\0A--\0A\0ARead from a file descriptor fd into an iterable of buffers.\0A\0AThe buffers should be mutable buffers accepting bytes.\0Areadv will transfer data into each buffer until it is full\0Aand then move on to the next buffer in the sequence to hold\0Athe rest of the data.\0A\0Areadv returns the total number of bytes read,\0Awhich may be less than the total capacity of all the buffers.\00", align 16
@.str.109 = private unnamed_addr constant [6 x i8] c"pread\00", align 1
@os_pread__doc__ = internal constant [258 x i8] c"pread($module, fd, length, offset, /)\0A--\0A\0ARead a number of bytes from a file descriptor starting at a particular offset.\0A\0ARead length bytes from file descriptor fd, starting at offset bytes from\0Athe beginning of the file.  The file offset remains unchanged.\00", align 16
@.str.110 = private unnamed_addr constant [7 x i8] c"preadv\00", align 1
@os_preadv__doc__ = internal constant [694 x i8] c"preadv($module, fd, buffers, offset, flags=0, /)\0A--\0A\0AReads from a file descriptor into a number of mutable bytes-like objects.\0A\0ACombines the functionality of readv() and pread(). As readv(), it will\0Atransfer data into each buffer until it is full and then move on to the next\0Abuffer in the sequence to hold the rest of the data. Its fourth argument,\0Aspecifies the file offset at which the input operation is to be performed. It\0Awill return the total number of bytes read (which can be less than the total\0Acapacity of all the objects).\0A\0AThe flags argument contains a bitwise OR of zero or more of the following flags:\0A\0A- RWF_HIPRI\0A- RWF_NOWAIT\0A\0AUsing non-zero flags requires Linux 4.6 or newer.\00", align 16
@.str.111 = private unnamed_addr constant [6 x i8] c"write\00", align 1
@os_write__doc__ = internal constant [75 x i8] c"write($module, fd, data, /)\0A--\0A\0AWrite a bytes object to a file descriptor.\00", align 16
@.str.112 = private unnamed_addr constant [7 x i8] c"writev\00", align 1
@os_writev__doc__ = internal constant [205 x i8] c"writev($module, fd, buffers, /)\0A--\0A\0AIterate over buffers, and write the contents of each to a file descriptor.\0A\0AReturns the total number of bytes written.\0Abuffers must be a sequence of bytes-like objects.\00", align 16
@.str.113 = private unnamed_addr constant [7 x i8] c"pwrite\00", align 1
@os_pwrite__doc__ = internal constant [267 x i8] c"pwrite($module, fd, buffer, offset, /)\0A--\0A\0AWrite bytes to a file descriptor starting at a particular offset.\0A\0AWrite buffer to fd, starting at offset bytes from the beginning of\0Athe file.  Returns the number of bytes written.  Does not change the\0Acurrent file offset.\00", align 16
@.str.114 = private unnamed_addr constant [8 x i8] c"pwritev\00", align 1
@os_pwritev__doc__ = internal constant [763 x i8] c"pwritev($module, fd, buffers, offset, flags=0, /)\0A--\0A\0AWrites the contents of bytes-like objects to a file descriptor at a given offset.\0A\0ACombines the functionality of writev() and pwrite(). All buffers must be a sequence\0Aof bytes-like objects. Buffers are processed in array order. Entire contents of first\0Abuffer is written before proceeding to second, and so on. The operating system may\0Aset a limit (sysconf() value SC_IOV_MAX) on the number of buffers that can be used.\0AThis function writes the contents of each object to the file descriptor and returns\0Athe total number of bytes written.\0A\0AThe flags argument contains a bitwise OR of zero or more of the following flags:\0A\0A- RWF_DSYNC\0A- RWF_SYNC\0A- RWF_APPEND\0A\0AUsing non-zero flags requires Linux 4.7 or newer.\00", align 16
@.str.115 = private unnamed_addr constant [9 x i8] c"sendfile\00", align 1
@os_sendfile__doc__ = internal constant [126 x i8] c"sendfile($module, /, out_fd, in_fd, offset, count)\0A--\0A\0ACopy count bytes from file descriptor in_fd to file descriptor out_fd.\00", align 16
@.str.116 = private unnamed_addr constant [6 x i8] c"fstat\00", align 1
@os_fstat__doc__ = internal constant [157 x i8] c"fstat($module, /, fd)\0A--\0A\0APerform a stat system call on the given file descriptor.\0A\0ALike stat(), but for an open file descriptor.\0AEquivalent to os.stat(fd).\00", align 16
@.str.117 = private unnamed_addr constant [7 x i8] c"isatty\00", align 1
@os_isatty__doc__ = internal constant [182 x i8] c"isatty($module, fd, /)\0A--\0A\0AReturn True if the fd is connected to a terminal.\0A\0AReturn True if the file descriptor is an open file descriptor\0Aconnected to the slave end of a terminal.\00", align 16
@.str.118 = private unnamed_addr constant [5 x i8] c"pipe\00", align 1
@os_pipe__doc__ = internal constant [100 x i8] c"pipe($module, /)\0A--\0A\0ACreate a pipe.\0A\0AReturns a tuple of two file descriptors:\0A  (read_fd, write_fd)\00", align 16
@.str.119 = private unnamed_addr constant [6 x i8] c"pipe2\00", align 1
@os_pipe2__doc__ = internal constant [230 x i8] c"pipe2($module, flags, /)\0A--\0A\0ACreate a pipe with flags set atomically.\0A\0AReturns a tuple of two file descriptors:\0A  (read_fd, write_fd)\0A\0Aflags can be constructed by ORing together one or more of these values:\0AO_NONBLOCK, O_CLOEXEC.\00", align 16
@.str.120 = private unnamed_addr constant [7 x i8] c"mkfifo\00", align 1
@os_mkfifo__doc__ = internal constant [361 x i8] c"mkfifo($module, /, path, mode=438, *, dir_fd=None)\0A--\0A\0ACreate a \22fifo\22 (a POSIX named pipe).\0A\0AIf dir_fd is not None, it should be a file descriptor open to a directory,\0A  and path should be relative; path will then be relative to that directory.\0Adir_fd may not be implemented on your platform.\0A  If it is unavailable, using it will raise a NotImplementedError.\00", align 16
@.str.121 = private unnamed_addr constant [6 x i8] c"mknod\00", align 1
@os_mknod__doc__ = internal constant [764 x i8] c"mknod($module, /, path, mode=384, device=0, *, dir_fd=None)\0A--\0A\0ACreate a node in the file system.\0A\0ACreate a node in the file system (file, device special file or named pipe)\0Aat path.  mode specifies both the permissions to use and the\0Atype of node to be created, being combined (bitwise OR) with one of\0AS_IFREG, S_IFCHR, S_IFBLK, and S_IFIFO.  If S_IFCHR or S_IFBLK is set on mode,\0Adevice defines the newly created device special file (probably using\0Aos.makedev()).  Otherwise device is ignored.\0A\0AIf dir_fd is not None, it should be a file descriptor open to a directory,\0A  and path should be relative; path will then be relative to that directory.\0Adir_fd may not be implemented on your platform.\0A  If it is unavailable, using it will raise a NotImplementedError.\00", align 16
@.str.122 = private unnamed_addr constant [6 x i8] c"major\00", align 1
@os_major__doc__ = internal constant [87 x i8] c"major($module, device, /)\0A--\0A\0AExtracts a device major number from a raw device number.\00", align 16
@.str.123 = private unnamed_addr constant [6 x i8] c"minor\00", align 1
@os_minor__doc__ = internal constant [87 x i8] c"minor($module, device, /)\0A--\0A\0AExtracts a device minor number from a raw device number.\00", align 16
@.str.124 = private unnamed_addr constant [8 x i8] c"makedev\00", align 1
@os_makedev__doc__ = internal constant [108 x i8] c"makedev($module, major, minor, /)\0A--\0A\0AComposes a raw device number from the major and minor device numbers.\00", align 16
@.str.125 = private unnamed_addr constant [10 x i8] c"ftruncate\00", align 1
@os_ftruncate__doc__ = internal constant [107 x i8] c"ftruncate($module, fd, length, /)\0A--\0A\0ATruncate a file, specified by file descriptor, to a specific length.\00", align 16
@.str.126 = private unnamed_addr constant [9 x i8] c"truncate\00", align 1
@os_truncate__doc__ = internal constant [242 x i8] c"truncate($module, /, path, length)\0A--\0A\0ATruncate a file, specified by path, to a specific length.\0A\0AOn some platforms, path may also be specified as an open file descriptor.\0A  If this functionality is unavailable, using it raises an exception.\00", align 16
@.str.127 = private unnamed_addr constant [16 x i8] c"posix_fallocate\00", align 1
@os_posix_fallocate__doc__ = internal constant [271 x i8] c"posix_fallocate($module, fd, offset, length, /)\0A--\0A\0AEnsure a file has allocated at least a particular number of bytes on disk.\0A\0AEnsure that the file specified by fd encompasses a range of bytes\0Astarting at offset bytes from the beginning and continuing for length bytes.\00", align 16
@.str.128 = private unnamed_addr constant [14 x i8] c"posix_fadvise\00", align 1
@os_posix_fadvise__doc__ = internal constant [483 x i8] c"posix_fadvise($module, fd, offset, length, advice, /)\0A--\0A\0AAnnounce an intention to access data in a specific pattern.\0A\0AAnnounce an intention to access data in a specific pattern, thus allowing\0Athe kernel to make optimizations.\0AThe advice applies to the region of the file specified by fd starting at\0Aoffset and continuing for length bytes.\0Aadvice is one of POSIX_FADV_NORMAL, POSIX_FADV_SEQUENTIAL,\0APOSIX_FADV_RANDOM, POSIX_FADV_NOREUSE, POSIX_FADV_WILLNEED, or\0APOSIX_FADV_DONTNEED.\00", align 16
@.str.129 = private unnamed_addr constant [7 x i8] c"putenv\00", align 1
@os_putenv__doc__ = internal constant [75 x i8] c"putenv($module, name, value, /)\0A--\0A\0AChange or add an environment variable.\00", align 16
@.str.130 = private unnamed_addr constant [9 x i8] c"unsetenv\00", align 1
@os_unsetenv__doc__ = internal constant [63 x i8] c"unsetenv($module, name, /)\0A--\0A\0ADelete an environment variable.\00", align 16
@.str.131 = private unnamed_addr constant [9 x i8] c"strerror\00", align 1
@os_strerror__doc__ = internal constant [76 x i8] c"strerror($module, code, /)\0A--\0A\0ATranslate an error code to a message string.\00", align 16
@.str.132 = private unnamed_addr constant [7 x i8] c"fchdir\00", align 1
@os_fchdir__doc__ = internal constant [156 x i8] c"fchdir($module, /, fd)\0A--\0A\0AChange to the directory of the given file descriptor.\0A\0Afd must be opened on a directory, not a file.\0AEquivalent to os.chdir(fd).\00", align 16
@.str.133 = private unnamed_addr constant [6 x i8] c"fsync\00", align 1
@os_fsync__doc__ = internal constant [53 x i8] c"fsync($module, /, fd)\0A--\0A\0AForce write of fd to disk.\00", align 16
@.str.134 = private unnamed_addr constant [5 x i8] c"sync\00", align 1
@os_sync__doc__ = internal constant [56 x i8] c"sync($module, /)\0A--\0A\0AForce write of everything to disk.\00", align 16
@.str.135 = private unnamed_addr constant [10 x i8] c"fdatasync\00", align 1
@os_fdatasync__doc__ = internal constant [92 x i8] c"fdatasync($module, /, fd)\0A--\0A\0AForce write of fd to disk without forcing update of metadata.\00", align 16
@.str.136 = private unnamed_addr constant [10 x i8] c"WCOREDUMP\00", align 1
@os_WCOREDUMP__doc__ = internal constant [105 x i8] c"WCOREDUMP($module, status, /)\0A--\0A\0AReturn True if the process returning status was dumped to a core file.\00", align 16
@.str.137 = private unnamed_addr constant [13 x i8] c"WIFCONTINUED\00", align 1
@os_WIFCONTINUED__doc__ = internal constant [196 x i8] c"WIFCONTINUED($module, /, status)\0A--\0A\0AReturn True if a particular process was continued from a job control stop.\0A\0AReturn True if the process returning status was continued from a\0Ajob control stop.\00", align 16
@.str.138 = private unnamed_addr constant [11 x i8] c"WIFSTOPPED\00", align 1
@os_WIFSTOPPED__doc__ = internal constant [92 x i8] c"WIFSTOPPED($module, /, status)\0A--\0A\0AReturn True if the process returning status was stopped.\00", align 16
@.str.139 = private unnamed_addr constant [12 x i8] c"WIFSIGNALED\00", align 1
@os_WIFSIGNALED__doc__ = internal constant [108 x i8] c"WIFSIGNALED($module, /, status)\0A--\0A\0AReturn True if the process returning status was terminated by a signal.\00", align 16
@.str.140 = private unnamed_addr constant [10 x i8] c"WIFEXITED\00", align 1
@os_WIFEXITED__doc__ = internal constant [113 x i8] c"WIFEXITED($module, /, status)\0A--\0A\0AReturn True if the process returning status exited via the exit() system call.\00", align 16
@.str.141 = private unnamed_addr constant [12 x i8] c"WEXITSTATUS\00", align 1
@os_WEXITSTATUS__doc__ = internal constant [80 x i8] c"WEXITSTATUS($module, /, status)\0A--\0A\0AReturn the process return code from status.\00", align 16
@.str.142 = private unnamed_addr constant [9 x i8] c"WTERMSIG\00", align 1
@os_WTERMSIG__doc__ = internal constant [111 x i8] c"WTERMSIG($module, /, status)\0A--\0A\0AReturn the signal that terminated the process that provided the status value.\00", align 16
@.str.143 = private unnamed_addr constant [9 x i8] c"WSTOPSIG\00", align 1
@os_WSTOPSIG__doc__ = internal constant [108 x i8] c"WSTOPSIG($module, /, status)\0A--\0A\0AReturn the signal that stopped the process that provided the status value.\00", align 16
@.str.144 = private unnamed_addr constant [9 x i8] c"fstatvfs\00", align 1
@os_fstatvfs__doc__ = internal constant [106 x i8] c"fstatvfs($module, fd, /)\0A--\0A\0APerform an fstatvfs system call on the given fd.\0A\0AEquivalent to statvfs(fd).\00", align 16
@.str.145 = private unnamed_addr constant [8 x i8] c"statvfs\00", align 1
@os_statvfs__doc__ = internal constant [266 x i8] c"statvfs($module, /, path)\0A--\0A\0APerform a statvfs system call on the given path.\0A\0Apath may always be specified as a string.\0AOn some platforms, path may also be specified as an open file descriptor.\0A  If this functionality is unavailable, using it raises an exception.\00", align 16
@.str.146 = private unnamed_addr constant [8 x i8] c"confstr\00", align 1
@os_confstr__doc__ = internal constant [84 x i8] c"confstr($module, name, /)\0A--\0A\0AReturn a string-valued system configuration variable.\00", align 16
@.str.147 = private unnamed_addr constant [8 x i8] c"sysconf\00", align 1
@os_sysconf__doc__ = internal constant [86 x i8] c"sysconf($module, name, /)\0A--\0A\0AReturn an integer-valued system configuration variable.\00", align 16
@.str.148 = private unnamed_addr constant [10 x i8] c"fpathconf\00", align 1
@os_fpathconf__doc__ = internal constant [134 x i8] c"fpathconf($module, fd, name, /)\0A--\0A\0AReturn the configuration limit name for the file descriptor fd.\0A\0AIf there is no limit, return -1.\00", align 16
@.str.149 = private unnamed_addr constant [9 x i8] c"pathconf\00", align 1
@os_pathconf__doc__ = internal constant [283 x i8] c"pathconf($module, /, path, name)\0A--\0A\0AReturn the configuration limit name for the file or directory path.\0A\0AIf there is no limit, return -1.\0AOn some platforms, path may also be specified as an open file descriptor.\0A  If this functionality is unavailable, using it raises an exception.\00", align 16
@.str.150 = private unnamed_addr constant [6 x i8] c"abort\00", align 1
@os_abort__doc__ = internal constant [195 x i8] c"abort($module, /)\0A--\0A\0AAbort the interpreter immediately.\0A\0AThis function 'dumps core' or otherwise fails in the hardest way possible\0Aon the hosting operating system.  This function never returns.\00", align 16
@.str.151 = private unnamed_addr constant [15 x i8] c"_path_normpath\00", align 1
@os__path_normpath__doc__ = internal constant [63 x i8] c"_path_normpath($module, /, path)\0A--\0A\0ABasic path normalization.\00", align 16
@.str.152 = private unnamed_addr constant [11 x i8] c"getloadavg\00", align 1
@os_getloadavg__doc__ = internal constant [255 x i8] c"getloadavg($module, /)\0A--\0A\0AReturn average recent system load information.\0A\0AReturn the number of processes in the system run queue averaged over\0Athe last 1, 5, and 15 minutes as a tuple of three floats.\0ARaises OSError if the load average was unobtainable.\00", align 16
@.str.153 = private unnamed_addr constant [8 x i8] c"urandom\00", align 1
@os_urandom__doc__ = internal constant [108 x i8] c"urandom($module, size, /)\0A--\0A\0AReturn a bytes object containing random bytes suitable for cryptographic use.\00", align 16
@.str.154 = private unnamed_addr constant [10 x i8] c"setresuid\00", align 1
@os_setresuid__doc__ = internal constant [107 x i8] c"setresuid($module, ruid, euid, suid, /)\0A--\0A\0ASet the current process's real, effective, and saved user ids.\00", align 16
@.str.155 = private unnamed_addr constant [10 x i8] c"setresgid\00", align 1
@os_setresgid__doc__ = internal constant [108 x i8] c"setresgid($module, rgid, egid, sgid, /)\0A--\0A\0ASet the current process's real, effective, and saved group ids.\00", align 16
@.str.156 = private unnamed_addr constant [10 x i8] c"getresuid\00", align 1
@os_getresuid__doc__ = internal constant [103 x i8] c"getresuid($module, /)\0A--\0A\0AReturn a tuple of the current process's real, effective, and saved user ids.\00", align 16
@.str.157 = private unnamed_addr constant [10 x i8] c"getresgid\00", align 1
@os_getresgid__doc__ = internal constant [104 x i8] c"getresgid($module, /)\0A--\0A\0AReturn a tuple of the current process's real, effective, and saved group ids.\00", align 16
@.str.158 = private unnamed_addr constant [9 x i8] c"getxattr\00", align 1
@os_getxattr__doc__ = internal constant [376 x i8] c"getxattr($module, /, path, attribute, *, follow_symlinks=True)\0A--\0A\0AReturn the value of extended attribute attribute on path.\0A\0Apath may be either a string, a path-like object, or an open file descriptor.\0AIf follow_symlinks is False, and the last element of the path is a symbolic\0A  link, getxattr will examine the symbolic link itself instead of the file\0A  the link points to.\00", align 16
@.str.159 = private unnamed_addr constant [9 x i8] c"setxattr\00", align 1
@os_setxattr__doc__ = internal constant [394 x i8] c"setxattr($module, /, path, attribute, value, flags=0, *,\0A         follow_symlinks=True)\0A--\0A\0ASet extended attribute attribute on path to value.\0A\0Apath may be either a string, a path-like object,  or an open file descriptor.\0AIf follow_symlinks is False, and the last element of the path is a symbolic\0A  link, setxattr will modify the symbolic link itself instead of the file\0A  the link points to.\00", align 16
@.str.160 = private unnamed_addr constant [12 x i8] c"removexattr\00", align 1
@os_removexattr__doc__ = internal constant [368 x i8] c"removexattr($module, /, path, attribute, *, follow_symlinks=True)\0A--\0A\0ARemove extended attribute attribute on path.\0A\0Apath may be either a string, a path-like object, or an open file descriptor.\0AIf follow_symlinks is False, and the last element of the path is a symbolic\0A  link, removexattr will modify the symbolic link itself instead of the file\0A  the link points to.\00", align 16
@.str.161 = private unnamed_addr constant [10 x i8] c"listxattr\00", align 1
@os_listxattr__doc__ = internal constant [429 x i8] c"listxattr($module, /, path=None, *, follow_symlinks=True)\0A--\0A\0AReturn a list of extended attributes on path.\0A\0Apath may be either None, a string, a path-like object, or an open file descriptor.\0Aif path is None, listxattr will examine the current directory.\0AIf follow_symlinks is False, and the last element of the path is a symbolic\0A  link, listxattr will examine the symbolic link itself instead of the file\0A  the link points to.\00", align 16
@.str.162 = private unnamed_addr constant [18 x i8] c"get_terminal_size\00", align 1
@os_get_terminal_size__doc__ = internal constant [522 x i8] c"get_terminal_size($module, fd=<unrepresentable>, /)\0A--\0A\0AReturn the size of the terminal window as (columns, lines).\0A\0AThe optional argument fd (default standard output) specifies\0Awhich file descriptor should be queried.\0A\0AIf the file descriptor is not connected to a terminal, an OSError\0Ais thrown.\0A\0AThis function will only be defined if an implementation is\0Aavailable for this system.\0A\0Ashutil.get_terminal_size is the high-level function which should\0Anormally be used, os.get_terminal_size is the low-level implementation.\00", align 16
@.str.163 = private unnamed_addr constant [10 x i8] c"cpu_count\00", align 1
@os_cpu_count__doc__ = internal constant [107 x i8] c"cpu_count($module, /)\0A--\0A\0AReturn the number of logical CPUs in the system.\0A\0AReturn None if indeterminable.\00", align 16
@.str.164 = private unnamed_addr constant [16 x i8] c"get_inheritable\00", align 1
@os_get_inheritable__doc__ = internal constant [96 x i8] c"get_inheritable($module, fd, /)\0A--\0A\0AGet the close-on-exe flag of the specified file descriptor.\00", align 16
@.str.165 = private unnamed_addr constant [16 x i8] c"set_inheritable\00", align 1
@os_set_inheritable__doc__ = internal constant [108 x i8] c"set_inheritable($module, fd, inheritable, /)\0A--\0A\0ASet the inheritable flag of the specified file descriptor.\00", align 16
@.str.166 = private unnamed_addr constant [13 x i8] c"get_blocking\00", align 1
@os_get_blocking__doc__ = internal constant [153 x i8] c"get_blocking($module, fd, /)\0A--\0A\0AGet the blocking mode of the file descriptor.\0A\0AReturn False if the O_NONBLOCK flag is set, True if the flag is cleared.\00", align 16
@.str.167 = private unnamed_addr constant [13 x i8] c"set_blocking\00", align 1
@os_set_blocking__doc__ = internal constant [183 x i8] c"set_blocking($module, fd, blocking, /)\0A--\0A\0ASet the blocking mode of the specified file descriptor.\0A\0ASet the O_NONBLOCK flag if blocking is False,\0Aclear the O_NONBLOCK flag otherwise.\00", align 16
@.str.168 = private unnamed_addr constant [8 x i8] c"scandir\00", align 1
@os_scandir__doc__ = internal constant [317 x i8] c"scandir($module, /, path=None)\0A--\0A\0AReturn an iterator of DirEntry objects for given path.\0A\0Apath can be specified as either str, bytes, or a path-like object.  If path\0Ais bytes, the names of yielded DirEntry objects will also be bytes; in\0Aall other circumstances they will be str.\0A\0AIf path is None, uses the path='.'.\00", align 16
@.str.169 = private unnamed_addr constant [7 x i8] c"fspath\00", align 1
@os_fspath__doc__ = internal constant [266 x i8] c"fspath($module, /, path)\0A--\0A\0AReturn the file system path representation of the object.\0A\0AIf the object is str or bytes, then allow it to pass through as-is. If the\0Aobject defines __fspath__(), then return the result of that method. All other\0Atypes raise a TypeError.\00", align 16
@.str.170 = private unnamed_addr constant [10 x i8] c"getrandom\00", align 1
@os_getrandom__doc__ = internal constant [74 x i8] c"getrandom($module, /, size, flags=0)\0A--\0A\0AObtain a series of random bytes.\00", align 16
@.str.171 = private unnamed_addr constant [13 x i8] c"memfd_create\00", align 1
@os_memfd_create__doc__ = internal constant [55 x i8] c"memfd_create($module, /, name, flags=MFD_CLOEXEC)\0A--\0A\0A\00", align 16
@.str.172 = private unnamed_addr constant [8 x i8] c"eventfd\00", align 1
@os_eventfd__doc__ = internal constant [111 x i8] c"eventfd($module, /, initval, flags=EFD_CLOEXEC)\0A--\0A\0ACreates and returns an event notification file descriptor.\00", align 16
@.str.173 = private unnamed_addr constant [13 x i8] c"eventfd_read\00", align 1
@os_eventfd_read__doc__ = internal constant [52 x i8] c"eventfd_read($module, /, fd)\0A--\0A\0ARead eventfd value\00", align 16
@.str.174 = private unnamed_addr constant [14 x i8] c"eventfd_write\00", align 1
@os_eventfd_write__doc__ = internal constant [62 x i8] c"eventfd_write($module, /, fd, value)\0A--\0A\0AWrite eventfd value.\00", align 16
@.str.175 = private unnamed_addr constant [23 x i8] c"waitstatus_to_exitcode\00", align 1
@os_waitstatus_to_exitcode__doc__ = internal constant [516 x i8] c"waitstatus_to_exitcode($module, /, status)\0A--\0A\0AConvert a wait status to an exit code.\0A\0AOn Unix:\0A\0A* If WIFEXITED(status) is true, return WEXITSTATUS(status).\0A* If WIFSIGNALED(status) is true, return -WTERMSIG(status).\0A* Otherwise, raise a ValueError.\0A\0AOn Windows, return status shifted right by 8 bits.\0A\0AOn Unix, if the process is being traced or if waitpid() was called with\0AWUNTRACED option, the caller must first check if WIFSTOPPED(status) is true.\0AThis function must not be called if WIFSTOPPED(status) is true.\00", align 16
@.str.176 = private unnamed_addr constant [6 x i8] c"setns\00", align 1
@os_setns__doc__ = internal constant [163 x i8] c"setns($module, /, fd, nstype=0)\0A--\0A\0AMove the calling thread into different namespaces.\0A\0A  fd\0A    A file descriptor to a namespace.\0A  nstype\0A    Type of namespace.\00", align 16
@.str.177 = private unnamed_addr constant [8 x i8] c"unshare\00", align 1
@os_unshare__doc__ = internal constant [134 x i8] c"unshare($module, /, flags)\0A--\0A\0ADisassociate parts of a process (or thread) execution context.\0A\0A  flags\0A    Namespaces to be unshared.\00", align 16
@.str.178 = private unnamed_addr constant [15 x i8] c"timerfd_create\00", align 1
@os_timerfd_create__doc__ = internal constant [563 x i8] c"timerfd_create($module, clockid, /, *, flags=0)\0A--\0A\0ACreate and return a timer file descriptor.\0A\0A  clockid\0A    A valid clock ID constant as timer file descriptor.\0A\0A    time.CLOCK_REALTIME\0A    time.CLOCK_MONOTONIC\0A    time.CLOCK_BOOTTIME\0A  flags\0A    0 or a bit mask of os.TFD_NONBLOCK or os.TFD_CLOEXEC.\0A\0A    os.TFD_NONBLOCK\0A        If *TFD_NONBLOCK* is set as a flag, read doesn't blocks.\0A        If *TFD_NONBLOCK* is not set as a flag, read block until the timer fires.\0A\0A    os.TFD_CLOEXEC\0A        If *TFD_CLOEXEC* is set as a flag, enable the close-on-exec flag\00", align 16
@.str.179 = private unnamed_addr constant [16 x i8] c"timerfd_settime\00", align 1
@os_timerfd_settime__doc__ = internal constant [350 x i8] c"timerfd_settime($module, fd, /, *, flags=0, initial=0.0, interval=0.0)\0A--\0A\0AAlter a timer file descriptor's internal timer in seconds.\0A\0A  fd\0A    A timer file descriptor.\0A  flags\0A    0 or a bit mask of TFD_TIMER_ABSTIME or TFD_TIMER_CANCEL_ON_SET.\0A  initial\0A    The initial expiration time, in seconds.\0A  interval\0A    The timer's interval, in seconds.\00", align 16
@.str.180 = private unnamed_addr constant [19 x i8] c"timerfd_settime_ns\00", align 1
@os_timerfd_settime_ns__doc__ = internal constant [351 x i8] c"timerfd_settime_ns($module, fd, /, *, flags=0, initial=0, interval=0)\0A--\0A\0AAlter a timer file descriptor's internal timer in nanoseconds.\0A\0A  fd\0A    A timer file descriptor.\0A  flags\0A    0 or a bit mask of TFD_TIMER_ABSTIME or TFD_TIMER_CANCEL_ON_SET.\0A  initial\0A    initial expiration timing in seconds.\0A  interval\0A    interval for the timer in seconds.\00", align 16
@.str.181 = private unnamed_addr constant [16 x i8] c"timerfd_gettime\00", align 1
@os_timerfd_gettime__doc__ = internal constant [161 x i8] c"timerfd_gettime($module, fd, /)\0A--\0A\0AReturn a tuple of a timer file descriptor's (interval, next expiration) in float seconds.\0A\0A  fd\0A    A timer file descriptor.\00", align 16
@.str.182 = private unnamed_addr constant [19 x i8] c"timerfd_gettime_ns\00", align 1
@os_timerfd_gettime_ns__doc__ = internal constant [162 x i8] c"timerfd_gettime_ns($module, fd, /)\0A--\0A\0AReturn a tuple of a timer file descriptor's (interval, next expiration) in nanoseconds.\0A\0A  fd\0A    A timer file descriptor.\00", align 16
@os_stat._kwtuple = internal global %struct.anon.769 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 3 }, [3 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 54680), ptr getelementptr (i8, ptr @_PyRuntime, i64 43272), ptr getelementptr (i8, ptr @_PyRuntime, i64 45960)] }, align 8
@PyTuple_Type = external global %struct._typeobject, align 8
@os_stat._keywords = internal constant [4 x ptr] [ptr @.str.183, ptr @.str.184, ptr @.str.185, ptr null], align 16
@.str.183 = private unnamed_addr constant [5 x i8] c"path\00", align 1
@.str.184 = private unnamed_addr constant [7 x i8] c"dir_fd\00", align 1
@.str.185 = private unnamed_addr constant [16 x i8] c"follow_symlinks\00", align 1
@os_stat._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_stat._keywords, ptr @.str.12, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_stat._kwtuple, i64 16), ptr null }, align 8
@__const.os_stat.path = private unnamed_addr constant %struct.path_t { ptr @.str.12, ptr @.str.183, i32 0, i32 1, ptr null, ptr null, i32 -1, i64 0, ptr null, ptr null }, align 8
@.str.186 = private unnamed_addr constant [32 x i8] c"%s%s%s should be %s, not %.200s\00", align 1
@.str.187 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.188 = private unnamed_addr constant [3 x i8] c": \00", align 1
@.str.189 = private unnamed_addr constant [44 x i8] c"string, bytes, os.PathLike, integer or None\00", align 1
@.str.190 = private unnamed_addr constant [38 x i8] c"string, bytes, os.PathLike or integer\00", align 1
@.str.191 = private unnamed_addr constant [35 x i8] c"string, bytes, os.PathLike or None\00", align 1
@.str.192 = private unnamed_addr constant [29 x i8] c"string, bytes or os.PathLike\00", align 1
@.str.193 = private unnamed_addr constant [34 x i8] c"%s%sembedded null character in %s\00", align 1
@.str.194 = private unnamed_addr constant [27 x i8] c"fd is greater than maximum\00", align 1
@.str.195 = private unnamed_addr constant [24 x i8] c"fd is less than minimum\00", align 1
@.str.196 = private unnamed_addr constant [47 x i8] c"argument should be integer or None, not %.200s\00", align 1
@.str.197 = private unnamed_addr constant [47 x i8] c"%s: can't specify dir_fd without matching path\00", align 1
@.str.198 = private unnamed_addr constant [37 x i8] c"%s: can't specify both dir_fd and fd\00", align 1
@.str.199 = private unnamed_addr constant [47 x i8] c"%s: cannot use fd and follow_symlinks together\00", align 1
@PyExc_NotImplementedError = external global ptr, align 8
@.str.200 = private unnamed_addr constant [36 x i8] c"%s%s%s unavailable on this platform\00", align 1
@os_access._kwtuple = internal global %struct.anon.770 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 5 }, [5 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 54680), ptr getelementptr (i8, ptr @_PyRuntime, i64 51792), ptr getelementptr (i8, ptr @_PyRuntime, i64 43272), ptr getelementptr (i8, ptr @_PyRuntime, i64 43840), ptr getelementptr (i8, ptr @_PyRuntime, i64 45960)] }, align 8
@os_access._keywords = internal constant [6 x ptr] [ptr @.str.183, ptr @.str.201, ptr @.str.184, ptr @.str.202, ptr @.str.185, ptr null], align 16
@.str.201 = private unnamed_addr constant [5 x i8] c"mode\00", align 1
@.str.202 = private unnamed_addr constant [14 x i8] c"effective_ids\00", align 1
@os_access._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_access._keywords, ptr @.str.13, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_access._kwtuple, i64 16), ptr null }, align 8
@__const.os_access.path = private unnamed_addr constant %struct.path_t { ptr @.str.13, ptr @.str.183, i32 0, i32 0, ptr null, ptr null, i32 -1, i64 0, ptr null, ptr null }, align 8
@os_chdir._kwtuple = internal global %struct.anon.771 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 1 }, [1 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 54680)] }, align 8
@os_chdir._keywords = internal constant [2 x ptr] [ptr @.str.183, ptr null], align 16
@os_chdir._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_chdir._keywords, ptr @.str.15, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_chdir._kwtuple, i64 16), ptr null }, align 8
@__const.os_chdir.path = private unnamed_addr constant %struct.path_t { ptr @.str.15, ptr @.str.183, i32 0, i32 1, ptr null, ptr null, i32 -1, i64 0, ptr null, ptr null }, align 8
@.str.203 = private unnamed_addr constant [9 x i8] c"os.chdir\00", align 1
@.str.204 = private unnamed_addr constant [4 x i8] c"(O)\00", align 1
@os_chmod._kwtuple = internal global %struct.anon.772 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 4 }, [4 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 54680), ptr getelementptr (i8, ptr @_PyRuntime, i64 51792), ptr getelementptr (i8, ptr @_PyRuntime, i64 43272), ptr getelementptr (i8, ptr @_PyRuntime, i64 45960)] }, align 8
@os_chmod._keywords = internal constant [5 x ptr] [ptr @.str.183, ptr @.str.201, ptr @.str.184, ptr @.str.185, ptr null], align 16
@os_chmod._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_chmod._keywords, ptr @.str.16, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_chmod._kwtuple, i64 16), ptr null }, align 8
@__const.os_chmod.path = private unnamed_addr constant %struct.path_t { ptr @.str.16, ptr @.str.183, i32 0, i32 1, ptr null, ptr null, i32 -1, i64 0, ptr null, ptr null }, align 8
@.str.205 = private unnamed_addr constant [9 x i8] c"os.chmod\00", align 1
@.str.206 = private unnamed_addr constant [4 x i8] c"Oii\00", align 1
@.str.207 = private unnamed_addr constant [51 x i8] c"%s: cannot use dir_fd and follow_symlinks together\00", align 1
@os_fchmod._kwtuple = internal global %struct.anon.773 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 2 }, [2 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 45144), ptr getelementptr (i8, ptr @_PyRuntime, i64 51792)] }, align 8
@os_fchmod._keywords = internal constant [3 x ptr] [ptr @.str.208, ptr @.str.201, ptr null], align 16
@.str.208 = private unnamed_addr constant [3 x i8] c"fd\00", align 1
@os_fchmod._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_fchmod._keywords, ptr @.str.17, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_fchmod._kwtuple, i64 16), ptr null }, align 8
@.str.209 = private unnamed_addr constant [4 x i8] c"iii\00", align 1
@os_chown._kwtuple = internal global %struct.anon.774 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 5 }, [5 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 54680), ptr getelementptr (i8, ptr @_PyRuntime, i64 61336), ptr getelementptr (i8, ptr @_PyRuntime, i64 46952), ptr getelementptr (i8, ptr @_PyRuntime, i64 43272), ptr getelementptr (i8, ptr @_PyRuntime, i64 45960)] }, align 8
@os_chown._keywords = internal constant [6 x ptr] [ptr @.str.183, ptr @.str.210, ptr @.str.211, ptr @.str.184, ptr @.str.185, ptr null], align 16
@.str.210 = private unnamed_addr constant [4 x i8] c"uid\00", align 1
@.str.211 = private unnamed_addr constant [4 x i8] c"gid\00", align 1
@os_chown._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_chown._keywords, ptr @.str.18, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_chown._kwtuple, i64 16), ptr null }, align 8
@__const.os_chown.path = private unnamed_addr constant %struct.path_t { ptr @.str.18, ptr @.str.183, i32 0, i32 1, ptr null, ptr null, i32 -1, i64 0, ptr null, ptr null }, align 8
@.str.212 = private unnamed_addr constant [9 x i8] c"os.chown\00", align 1
@.str.213 = private unnamed_addr constant [5 x i8] c"OIIi\00", align 1
@os_fchown._kwtuple = internal global %struct.anon.775 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 3 }, [3 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 45144), ptr getelementptr (i8, ptr @_PyRuntime, i64 61336), ptr getelementptr (i8, ptr @_PyRuntime, i64 46952)] }, align 8
@os_fchown._keywords = internal constant [4 x ptr] [ptr @.str.208, ptr @.str.210, ptr @.str.211, ptr null], align 16
@os_fchown._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_fchown._keywords, ptr @.str.19, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_fchown._kwtuple, i64 16), ptr null }, align 8
@.str.214 = private unnamed_addr constant [5 x i8] c"iIIi\00", align 1
@os_lchown._kwtuple = internal global %struct.anon.776 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 3 }, [3 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 54680), ptr getelementptr (i8, ptr @_PyRuntime, i64 61336), ptr getelementptr (i8, ptr @_PyRuntime, i64 46952)] }, align 8
@os_lchown._keywords = internal constant [4 x ptr] [ptr @.str.183, ptr @.str.210, ptr @.str.211, ptr null], align 16
@os_lchown._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_lchown._keywords, ptr @.str.20, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_lchown._kwtuple, i64 16), ptr null }, align 8
@__const.os_lchown.path = private unnamed_addr constant %struct.path_t { ptr @.str.20, ptr @.str.183, i32 0, i32 0, ptr null, ptr null, i32 -1, i64 0, ptr null, ptr null }, align 8
@os_chroot._kwtuple = internal global %struct.anon.777 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 1 }, [1 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 54680)] }, align 8
@os_chroot._keywords = internal constant [2 x ptr] [ptr @.str.183, ptr null], align 16
@os_chroot._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_chroot._keywords, ptr @.str.21, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_chroot._kwtuple, i64 16), ptr null }, align 8
@__const.os_chroot.path = private unnamed_addr constant %struct.path_t { ptr @.str.21, ptr @.str.183, i32 0, i32 0, ptr null, ptr null, i32 -1, i64 0, ptr null, ptr null }, align 8
@os_link._kwtuple = internal global %struct.anon.778 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 5 }, [5 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 58800), ptr getelementptr (i8, ptr @_PyRuntime, i64 43632), ptr getelementptr (i8, ptr @_PyRuntime, i64 58848), ptr getelementptr (i8, ptr @_PyRuntime, i64 43680), ptr getelementptr (i8, ptr @_PyRuntime, i64 45960)] }, align 8
@os_link._keywords = internal constant [6 x ptr] [ptr @.str.215, ptr @.str.216, ptr @.str.217, ptr @.str.218, ptr @.str.185, ptr null], align 16
@.str.215 = private unnamed_addr constant [4 x i8] c"src\00", align 1
@.str.216 = private unnamed_addr constant [4 x i8] c"dst\00", align 1
@.str.217 = private unnamed_addr constant [11 x i8] c"src_dir_fd\00", align 1
@.str.218 = private unnamed_addr constant [11 x i8] c"dst_dir_fd\00", align 1
@os_link._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_link._keywords, ptr @.str.25, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_link._kwtuple, i64 16), ptr null }, align 8
@__const.os_link.src = private unnamed_addr constant %struct.path_t { ptr @.str.25, ptr @.str.215, i32 0, i32 0, ptr null, ptr null, i32 -1, i64 0, ptr null, ptr null }, align 8
@__const.os_link.dst = private unnamed_addr constant %struct.path_t { ptr @.str.25, ptr @.str.216, i32 0, i32 0, ptr null, ptr null, i32 -1, i64 0, ptr null, ptr null }, align 8
@.str.219 = private unnamed_addr constant [40 x i8] c"link: src and dst must be the same type\00", align 1
@.str.220 = private unnamed_addr constant [8 x i8] c"os.link\00", align 1
@.str.221 = private unnamed_addr constant [5 x i8] c"OOii\00", align 1
@os_listdir._kwtuple = internal global %struct.anon.779 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 1 }, [1 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 54680)] }, align 8
@os_listdir._keywords = internal constant [2 x ptr] [ptr @.str.183, ptr null], align 16
@os_listdir._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_listdir._keywords, ptr @.str.26, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_listdir._kwtuple, i64 16), ptr null }, align 8
@__const.os_listdir.path = private unnamed_addr constant %struct.path_t { ptr @.str.26, ptr @.str.183, i32 1, i32 1, ptr null, ptr null, i32 -1, i64 0, ptr null, ptr null }, align 8
@.str.222 = private unnamed_addr constant [11 x i8] c"os.listdir\00", align 1
@.str.223 = private unnamed_addr constant [2 x i8] c"O\00", align 1
@.str.224 = private unnamed_addr constant [2 x i8] c".\00", align 1
@os_lstat._kwtuple = internal global %struct.anon.780 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 2 }, [2 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 54680), ptr getelementptr (i8, ptr @_PyRuntime, i64 43272)] }, align 8
@os_lstat._keywords = internal constant [3 x ptr] [ptr @.str.183, ptr @.str.184, ptr null], align 16
@os_lstat._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_lstat._keywords, ptr @.str.27, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_lstat._kwtuple, i64 16), ptr null }, align 8
@__const.os_lstat.path = private unnamed_addr constant %struct.path_t { ptr @.str.27, ptr @.str.183, i32 0, i32 0, ptr null, ptr null, i32 -1, i64 0, ptr null, ptr null }, align 8
@os_mkdir._kwtuple = internal global %struct.anon.781 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 3 }, [3 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 54680), ptr getelementptr (i8, ptr @_PyRuntime, i64 51792), ptr getelementptr (i8, ptr @_PyRuntime, i64 43272)] }, align 8
@os_mkdir._keywords = internal constant [4 x ptr] [ptr @.str.183, ptr @.str.201, ptr @.str.184, ptr null], align 16
@os_mkdir._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_mkdir._keywords, ptr @.str.28, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_mkdir._kwtuple, i64 16), ptr null }, align 8
@__const.os_mkdir.path = private unnamed_addr constant %struct.path_t { ptr @.str.28, ptr @.str.183, i32 0, i32 0, ptr null, ptr null, i32 -1, i64 0, ptr null, ptr null }, align 8
@.str.225 = private unnamed_addr constant [9 x i8] c"os.mkdir\00", align 1
@os_getpriority._kwtuple = internal global %struct.anon.782 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 2 }, [2 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 62040), ptr getelementptr (i8, ptr @_PyRuntime, i64 62088)] }, align 8
@os_getpriority._keywords = internal constant [3 x ptr] [ptr @.str.226, ptr @.str.227, ptr null], align 16
@.str.226 = private unnamed_addr constant [6 x i8] c"which\00", align 1
@.str.227 = private unnamed_addr constant [4 x i8] c"who\00", align 1
@os_getpriority._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_getpriority._keywords, ptr @.str.30, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_getpriority._kwtuple, i64 16), ptr null }, align 8
@os_setpriority._kwtuple = internal global %struct.anon.783 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 3 }, [3 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 62040), ptr getelementptr (i8, ptr @_PyRuntime, i64 62088), ptr getelementptr (i8, ptr @_PyRuntime, i64 55392)] }, align 8
@os_setpriority._keywords = internal constant [4 x ptr] [ptr @.str.226, ptr @.str.227, ptr @.str.228, ptr null], align 16
@.str.228 = private unnamed_addr constant [9 x i8] c"priority\00", align 1
@os_setpriority._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_setpriority._keywords, ptr @.str.31, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_setpriority._kwtuple, i64 16), ptr null }, align 8
@os_posix_spawn._kwtuple = internal global %struct.anon.784 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 7 }, [7 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 45384), ptr getelementptr (i8, ptr @_PyRuntime, i64 57952), ptr getelementptr (i8, ptr @_PyRuntime, i64 56968), ptr getelementptr (i8, ptr @_PyRuntime, i64 58008), ptr getelementptr (i8, ptr @_PyRuntime, i64 58112), ptr getelementptr (i8, ptr @_PyRuntime, i64 58056), ptr getelementptr (i8, ptr @_PyRuntime, i64 57328)] }, align 8
@os_posix_spawn._keywords = internal constant [11 x ptr] [ptr @.str.187, ptr @.str.187, ptr @.str.187, ptr @.str.229, ptr @.str.230, ptr @.str.231, ptr @.str.95, ptr @.str.232, ptr @.str.233, ptr @.str.234, ptr null], align 16
@.str.229 = private unnamed_addr constant [13 x i8] c"file_actions\00", align 1
@.str.230 = private unnamed_addr constant [10 x i8] c"setpgroup\00", align 1
@.str.231 = private unnamed_addr constant [9 x i8] c"resetids\00", align 1
@.str.232 = private unnamed_addr constant [11 x i8] c"setsigmask\00", align 1
@.str.233 = private unnamed_addr constant [10 x i8] c"setsigdef\00", align 1
@.str.234 = private unnamed_addr constant [10 x i8] c"scheduler\00", align 1
@os_posix_spawn._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_posix_spawn._keywords, ptr @.str.32, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_posix_spawn._kwtuple, i64 16), ptr null }, align 8
@__const.os_posix_spawn.path = private unnamed_addr constant %struct.path_t { ptr @.str.32, ptr @.str.183, i32 0, i32 0, ptr null, ptr null, i32 -1, i64 0, ptr null, ptr null }, align 8
@.str.235 = private unnamed_addr constant [33 x i8] c"%s: argv must be a tuple or list\00", align 1
@.str.236 = private unnamed_addr constant [27 x i8] c"%s: argv must not be empty\00", align 1
@.str.237 = private unnamed_addr constant [49 x i8] c"%s: environment must be a mapping object or None\00", align 1
@.str.238 = private unnamed_addr constant [39 x i8] c"%s: argv first element cannot be empty\00", align 1
@environ = external global ptr, align 8
@.str.239 = private unnamed_addr constant [15 x i8] c"os.posix_spawn\00", align 1
@.str.240 = private unnamed_addr constant [4 x i8] c"OOO\00", align 1
@.str.241 = private unnamed_addr constant [41 x i8] c"env.keys() or env.values() is not a list\00", align 1
@.str.242 = private unnamed_addr constant [34 x i8] c"illegal environment variable name\00", align 1
@.str.243 = private unnamed_addr constant [6 x i8] c"%s=%s\00", align 1
@.str.244 = private unnamed_addr constant [40 x i8] c"file_actions must be a sequence or None\00", align 1
@.str.245 = private unnamed_addr constant [52 x i8] c"Each file_actions element must be a non-empty tuple\00", align 1
@.str.246 = private unnamed_addr constant [53 x i8] c"OiO&ik;A open file_action tuple must have 5 elements\00", align 1
@.str.247 = private unnamed_addr constant [50 x i8] c"Oi;A close file_action tuple must have 2 elements\00", align 1
@.str.248 = private unnamed_addr constant [50 x i8] c"Oii;A dup2 file_action tuple must have 3 elements\00", align 1
@.str.249 = private unnamed_addr constant [32 x i8] c"Unknown file_actions identifier\00", align 1
@.str.250 = private unnamed_addr constant [44 x i8] c"OO;A scheduler tuple must have two elements\00", align 1
@.str.251 = private unnamed_addr constant [31 x i8] c"must have a sched_param object\00", align 1
@.str.252 = private unnamed_addr constant [28 x i8] c"sched_priority out of range\00", align 1
@os_posix_spawnp._kwtuple = internal global %struct.anon.785 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 7 }, [7 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 45384), ptr getelementptr (i8, ptr @_PyRuntime, i64 57952), ptr getelementptr (i8, ptr @_PyRuntime, i64 56968), ptr getelementptr (i8, ptr @_PyRuntime, i64 58008), ptr getelementptr (i8, ptr @_PyRuntime, i64 58112), ptr getelementptr (i8, ptr @_PyRuntime, i64 58056), ptr getelementptr (i8, ptr @_PyRuntime, i64 57328)] }, align 8
@os_posix_spawnp._keywords = internal constant [11 x ptr] [ptr @.str.187, ptr @.str.187, ptr @.str.187, ptr @.str.229, ptr @.str.230, ptr @.str.231, ptr @.str.95, ptr @.str.232, ptr @.str.233, ptr @.str.234, ptr null], align 16
@os_posix_spawnp._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_posix_spawnp._keywords, ptr @.str.33, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_posix_spawnp._kwtuple, i64 16), ptr null }, align 8
@__const.os_posix_spawnp.path = private unnamed_addr constant %struct.path_t { ptr @.str.33, ptr @.str.183, i32 0, i32 0, ptr null, ptr null, i32 -1, i64 0, ptr null, ptr null }, align 8
@os_readlink._kwtuple = internal global %struct.anon.786 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 2 }, [2 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 54680), ptr getelementptr (i8, ptr @_PyRuntime, i64 43272)] }, align 8
@os_readlink._keywords = internal constant [3 x ptr] [ptr @.str.183, ptr @.str.184, ptr null], align 16
@os_readlink._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_readlink._keywords, ptr @.str.34, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_readlink._kwtuple, i64 16), ptr null }, align 8
@__const.os_readlink.path = private unnamed_addr constant %struct.path_t { ptr @.str.34, ptr @.str.183, i32 0, i32 0, ptr null, ptr null, i32 -1, i64 0, ptr null, ptr null }, align 8
@os_copy_file_range._kwtuple = internal global %struct.anon.787 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 5 }, [5 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 58800), ptr getelementptr (i8, ptr @_PyRuntime, i64 43632), ptr getelementptr (i8, ptr @_PyRuntime, i64 42184), ptr getelementptr (i8, ptr @_PyRuntime, i64 53600), ptr getelementptr (i8, ptr @_PyRuntime, i64 53544)] }, align 8
@os_copy_file_range._keywords = internal constant [6 x ptr] [ptr @.str.215, ptr @.str.216, ptr @.str.253, ptr @.str.254, ptr @.str.255, ptr null], align 16
@.str.253 = private unnamed_addr constant [6 x i8] c"count\00", align 1
@.str.254 = private unnamed_addr constant [11 x i8] c"offset_src\00", align 1
@.str.255 = private unnamed_addr constant [11 x i8] c"offset_dst\00", align 1
@os_copy_file_range._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_copy_file_range._keywords, ptr @.str.35, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_copy_file_range._kwtuple, i64 16), ptr null }, align 8
@.str.256 = private unnamed_addr constant [39 x i8] c"negative value for 'count' not allowed\00", align 1
@os_splice._kwtuple = internal global %struct.anon.788 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 6 }, [6 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 58800), ptr getelementptr (i8, ptr @_PyRuntime, i64 43632), ptr getelementptr (i8, ptr @_PyRuntime, i64 42184), ptr getelementptr (i8, ptr @_PyRuntime, i64 53600), ptr getelementptr (i8, ptr @_PyRuntime, i64 53544), ptr getelementptr (i8, ptr @_PyRuntime, i64 45864)] }, align 8
@os_splice._keywords = internal constant [7 x ptr] [ptr @.str.215, ptr @.str.216, ptr @.str.253, ptr @.str.254, ptr @.str.255, ptr @.str.257, ptr null], align 16
@.str.257 = private unnamed_addr constant [6 x i8] c"flags\00", align 1
@os_splice._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_splice._keywords, ptr @.str.36, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_splice._kwtuple, i64 16), ptr null }, align 8
@os_rename._kwtuple = internal global %struct.anon.789 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 4 }, [4 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 58800), ptr getelementptr (i8, ptr @_PyRuntime, i64 43632), ptr getelementptr (i8, ptr @_PyRuntime, i64 58848), ptr getelementptr (i8, ptr @_PyRuntime, i64 43680)] }, align 8
@os_rename._keywords = internal constant [5 x ptr] [ptr @.str.215, ptr @.str.216, ptr @.str.217, ptr @.str.218, ptr null], align 16
@os_rename._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_rename._keywords, ptr @.str.37, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_rename._kwtuple, i64 16), ptr null }, align 8
@__const.os_rename.src = private unnamed_addr constant %struct.path_t { ptr @.str.37, ptr @.str.215, i32 0, i32 0, ptr null, ptr null, i32 -1, i64 0, ptr null, ptr null }, align 8
@__const.os_rename.dst = private unnamed_addr constant %struct.path_t { ptr @.str.37, ptr @.str.216, i32 0, i32 0, ptr null, ptr null, i32 -1, i64 0, ptr null, ptr null }, align 8
@.str.258 = private unnamed_addr constant [10 x i8] c"os.rename\00", align 1
@.str.259 = private unnamed_addr constant [38 x i8] c"%s: src and dst must be the same type\00", align 1
@.str.260 = private unnamed_addr constant [26 x i8] c"src_dir_fd and dst_dir_fd\00", align 1
@os_replace._kwtuple = internal global %struct.anon.790 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 4 }, [4 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 58800), ptr getelementptr (i8, ptr @_PyRuntime, i64 43632), ptr getelementptr (i8, ptr @_PyRuntime, i64 58848), ptr getelementptr (i8, ptr @_PyRuntime, i64 43680)] }, align 8
@os_replace._keywords = internal constant [5 x ptr] [ptr @.str.215, ptr @.str.216, ptr @.str.217, ptr @.str.218, ptr null], align 16
@os_replace._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_replace._keywords, ptr @.str.38, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_replace._kwtuple, i64 16), ptr null }, align 8
@__const.os_replace.src = private unnamed_addr constant %struct.path_t { ptr @.str.38, ptr @.str.215, i32 0, i32 0, ptr null, ptr null, i32 -1, i64 0, ptr null, ptr null }, align 8
@__const.os_replace.dst = private unnamed_addr constant %struct.path_t { ptr @.str.38, ptr @.str.216, i32 0, i32 0, ptr null, ptr null, i32 -1, i64 0, ptr null, ptr null }, align 8
@os_rmdir._kwtuple = internal global %struct.anon.791 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 2 }, [2 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 54680), ptr getelementptr (i8, ptr @_PyRuntime, i64 43272)] }, align 8
@os_rmdir._keywords = internal constant [3 x ptr] [ptr @.str.183, ptr @.str.184, ptr null], align 16
@os_rmdir._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_rmdir._keywords, ptr @.str.39, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_rmdir._kwtuple, i64 16), ptr null }, align 8
@__const.os_rmdir.path = private unnamed_addr constant %struct.path_t { ptr @.str.39, ptr @.str.183, i32 0, i32 0, ptr null, ptr null, i32 -1, i64 0, ptr null, ptr null }, align 8
@.str.261 = private unnamed_addr constant [9 x i8] c"os.rmdir\00", align 1
@.str.262 = private unnamed_addr constant [3 x i8] c"Oi\00", align 1
@os_symlink._kwtuple = internal global %struct.anon.792 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 4 }, [4 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 58800), ptr getelementptr (i8, ptr @_PyRuntime, i64 43632), ptr getelementptr (i8, ptr @_PyRuntime, i64 59936), ptr getelementptr (i8, ptr @_PyRuntime, i64 43272)] }, align 8
@os_symlink._keywords = internal constant [5 x ptr] [ptr @.str.215, ptr @.str.216, ptr @.str.263, ptr @.str.184, ptr null], align 16
@.str.263 = private unnamed_addr constant [20 x i8] c"target_is_directory\00", align 1
@os_symlink._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_symlink._keywords, ptr @.str.40, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_symlink._kwtuple, i64 16), ptr null }, align 8
@__const.os_symlink.src = private unnamed_addr constant %struct.path_t { ptr @.str.40, ptr @.str.215, i32 0, i32 0, ptr null, ptr null, i32 -1, i64 0, ptr null, ptr null }, align 8
@__const.os_symlink.dst = private unnamed_addr constant %struct.path_t { ptr @.str.40, ptr @.str.216, i32 0, i32 0, ptr null, ptr null, i32 -1, i64 0, ptr null, ptr null }, align 8
@.str.264 = private unnamed_addr constant [11 x i8] c"os.symlink\00", align 1
@.str.265 = private unnamed_addr constant [4 x i8] c"OOi\00", align 1
@.str.266 = private unnamed_addr constant [43 x i8] c"symlink: src and dst must be the same type\00", align 1
@os_system._kwtuple = internal global %struct.anon.793 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 1 }, [1 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 41680)] }, align 8
@os_system._keywords = internal constant [2 x ptr] [ptr @.str.267, ptr null], align 16
@.str.267 = private unnamed_addr constant [8 x i8] c"command\00", align 1
@os_system._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_system._keywords, ptr @.str.41, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_system._kwtuple, i64 16), ptr null }, align 8
@.str.268 = private unnamed_addr constant [10 x i8] c"os.system\00", align 1
@os_unlink._kwtuple = internal global %struct.anon.794 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 2 }, [2 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 54680), ptr getelementptr (i8, ptr @_PyRuntime, i64 43272)] }, align 8
@os_unlink._keywords = internal constant [3 x ptr] [ptr @.str.183, ptr @.str.184, ptr null], align 16
@os_unlink._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_unlink._keywords, ptr @.str.44, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_unlink._kwtuple, i64 16), ptr null }, align 8
@__const.os_unlink.path = private unnamed_addr constant %struct.path_t { ptr @.str.44, ptr @.str.183, i32 0, i32 0, ptr null, ptr null, i32 -1, i64 0, ptr null, ptr null }, align 8
@.str.269 = private unnamed_addr constant [10 x i8] c"os.remove\00", align 1
@os_remove._kwtuple = internal global %struct.anon.795 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 2 }, [2 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 54680), ptr getelementptr (i8, ptr @_PyRuntime, i64 43272)] }, align 8
@os_remove._keywords = internal constant [3 x ptr] [ptr @.str.183, ptr @.str.184, ptr null], align 16
@os_remove._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_remove._keywords, ptr @.str.45, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_remove._kwtuple, i64 16), ptr null }, align 8
@__const.os_remove.path = private unnamed_addr constant %struct.path_t { ptr @.str.45, ptr @.str.183, i32 0, i32 0, ptr null, ptr null, i32 -1, i64 0, ptr null, ptr null }, align 8
@os_utime._kwtuple = internal global %struct.anon.796 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 5 }, [5 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 54680), ptr getelementptr (i8, ptr @_PyRuntime, i64 60616), ptr getelementptr (i8, ptr @_PyRuntime, i64 53160), ptr getelementptr (i8, ptr @_PyRuntime, i64 43272), ptr getelementptr (i8, ptr @_PyRuntime, i64 45960)] }, align 8
@os_utime._keywords = internal constant [6 x ptr] [ptr @.str.183, ptr @.str.47, ptr @.str.270, ptr @.str.184, ptr @.str.185, ptr null], align 16
@.str.270 = private unnamed_addr constant [3 x i8] c"ns\00", align 1
@os_utime._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_utime._keywords, ptr @.str.46, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_utime._kwtuple, i64 16), ptr null }, align 8
@__const.os_utime.path = private unnamed_addr constant %struct.path_t { ptr @.str.46, ptr @.str.183, i32 0, i32 1, ptr null, ptr null, i32 -1, i64 0, ptr null, ptr null }, align 8
@.str.271 = private unnamed_addr constant [59 x i8] c"utime: you may specify either 'times' or 'ns' but not both\00", align 1
@.str.272 = private unnamed_addr constant [58 x i8] c"utime: 'times' must be either a tuple of two ints or None\00", align 1
@.str.273 = private unnamed_addr constant [40 x i8] c"utime: 'ns' must be a tuple of two ints\00", align 1
@.str.274 = private unnamed_addr constant [9 x i8] c"os.utime\00", align 1
@.str.275 = private unnamed_addr constant [5 x i8] c"OOOi\00", align 1
@.str.276 = private unnamed_addr constant [54 x i8] c"%.200s.__divmod__() must return a 2-tuple, not %.200s\00", align 1
@os__exit._kwtuple = internal global %struct.anon.797 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 1 }, [1 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 59064)] }, align 8
@os__exit._keywords = internal constant [2 x ptr] [ptr @.str.277, ptr null], align 16
@.str.277 = private unnamed_addr constant [7 x i8] c"status\00", align 1
@os__exit._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os__exit._keywords, ptr @.str.48, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os__exit._kwtuple, i64 16), ptr null }, align 8
@__const.os_execv.path = private unnamed_addr constant %struct.path_t { ptr @.str.49, ptr @.str.183, i32 0, i32 0, ptr null, ptr null, i32 -1, i64 0, ptr null, ptr null }, align 8
@PyExc_RuntimeError = external global ptr, align 8
@.str.278 = private unnamed_addr constant [48 x i8] c"exec not supported for isolated subinterpreters\00", align 1
@.str.279 = private unnamed_addr constant [38 x i8] c"execv() arg 2 must be a tuple or list\00", align 1
@.str.280 = private unnamed_addr constant [32 x i8] c"execv() arg 2 must not be empty\00", align 1
@.str.281 = private unnamed_addr constant [44 x i8] c"execv() arg 2 first element cannot be empty\00", align 1
@.str.282 = private unnamed_addr constant [8 x i8] c"os.exec\00", align 1
@os_execve._kwtuple = internal global %struct.anon.798 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 3 }, [3 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 54680), ptr getelementptr (i8, ptr @_PyRuntime, i64 38104), ptr getelementptr (i8, ptr @_PyRuntime, i64 44320)] }, align 8
@os_execve._keywords = internal constant [4 x ptr] [ptr @.str.183, ptr @.str.283, ptr @.str.284, ptr null], align 16
@.str.283 = private unnamed_addr constant [5 x i8] c"argv\00", align 1
@.str.284 = private unnamed_addr constant [4 x i8] c"env\00", align 1
@os_execve._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_execve._keywords, ptr @.str.50, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_execve._kwtuple, i64 16), ptr null }, align 8
@__const.os_execve.path = private unnamed_addr constant %struct.path_t { ptr @.str.50, ptr @.str.183, i32 0, i32 1, ptr null, ptr null, i32 -1, i64 0, ptr null, ptr null }, align 8
@.str.285 = private unnamed_addr constant [37 x i8] c"execve: argv must be a tuple or list\00", align 1
@.str.286 = private unnamed_addr constant [31 x i8] c"execve: argv must not be empty\00", align 1
@.str.287 = private unnamed_addr constant [45 x i8] c"execve: environment must be a mapping object\00", align 1
@.str.288 = private unnamed_addr constant [43 x i8] c"execve: argv first element cannot be empty\00", align 1
@.str.289 = private unnamed_addr constant [35 x i8] c"can't fork at interpreter shutdown\00", align 1
@.str.290 = private unnamed_addr constant [48 x i8] c"fork not supported for isolated subinterpreters\00", align 1
@.str.291 = private unnamed_addr constant [8 x i8] c"os.fork\00", align 1
@.str.292 = private unnamed_addr constant [16 x i8] c"/proc/self/stat\00", align 1
@.str.293 = private unnamed_addr constant [2 x i8] c"r\00", align 1
@.str.294 = private unnamed_addr constant [2 x i8] c" \00", align 1
@PyExc_DeprecationWarning = external global ptr, align 8
@.str.295 = private unnamed_addr constant [89 x i8] c"This process (pid=%d) is multi-threaded, use of %s() may lead to deadlocks in the child.\00", align 1
@os_register_at_fork._kwtuple = internal global %struct.anon.799 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 3 }, [3 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 38688), ptr getelementptr (i8, ptr @_PyRuntime, i64 37784), ptr getelementptr (i8, ptr @_PyRuntime, i64 37840)] }, align 8
@os_register_at_fork._keywords = internal constant [4 x ptr] [ptr @.str.296, ptr @.str.297, ptr @.str.298, ptr null], align 16
@.str.296 = private unnamed_addr constant [7 x i8] c"before\00", align 1
@.str.297 = private unnamed_addr constant [15 x i8] c"after_in_child\00", align 1
@.str.298 = private unnamed_addr constant [16 x i8] c"after_in_parent\00", align 1
@os_register_at_fork._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_register_at_fork._keywords, ptr @.str.52, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_register_at_fork._kwtuple, i64 16), ptr null }, align 8
@.str.299 = private unnamed_addr constant [35 x i8] c"At least one argument is required.\00", align 1
@.str.300 = private unnamed_addr constant [30 x i8] c"'%s' must be callable, not %s\00", align 1
@os_sched_get_priority_max._kwtuple = internal global %struct.anon.800 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 1 }, [1 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 55088)] }, align 8
@os_sched_get_priority_max._keywords = internal constant [2 x ptr] [ptr @.str.301, ptr null], align 16
@.str.301 = private unnamed_addr constant [7 x i8] c"policy\00", align 1
@os_sched_get_priority_max._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_sched_get_priority_max._keywords, ptr @.str.53, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_sched_get_priority_max._kwtuple, i64 16), ptr null }, align 8
@os_sched_get_priority_min._kwtuple = internal global %struct.anon.801 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 1 }, [1 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 55088)] }, align 8
@os_sched_get_priority_min._keywords = internal constant [2 x ptr] [ptr @.str.301, ptr null], align 16
@os_sched_get_priority_min._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_sched_get_priority_min._keywords, ptr @.str.54, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_sched_get_priority_min._kwtuple, i64 16), ptr null }, align 8
@.str.302 = private unnamed_addr constant [17 x i8] c"i:sched_getparam\00", align 1
@.str.303 = private unnamed_addr constant [21 x i8] c"i:sched_getscheduler\00", align 1
@.str.304 = private unnamed_addr constant [24 x i8] c"i:sched_rr_get_interval\00", align 1
@.str.305 = private unnamed_addr constant [18 x i8] c"iO:sched_setparam\00", align 1
@.str.306 = private unnamed_addr constant [23 x i8] c"iiO:sched_setscheduler\00", align 1
@.str.307 = private unnamed_addr constant [21 x i8] c"iO:sched_setaffinity\00", align 1
@.str.308 = private unnamed_addr constant [54 x i8] c"expected an iterator of ints, but iterator yielded %R\00", align 1
@.str.309 = private unnamed_addr constant [20 x i8] c"negative CPU number\00", align 1
@.str.310 = private unnamed_addr constant [21 x i8] c"CPU number too large\00", align 1
@.str.311 = private unnamed_addr constant [20 x i8] c"i:sched_getaffinity\00", align 1
@.str.312 = private unnamed_addr constant [42 x i8] c"could not allocate a large enough CPU set\00", align 1
@.str.313 = private unnamed_addr constant [5 x i8] c"(ii)\00", align 1
@.str.314 = private unnamed_addr constant [39 x i8] c"fork not supported for subinterpreters\00", align 1
@.str.315 = private unnamed_addr constant [11 x i8] c"os.forkpty\00", align 1
@.str.316 = private unnamed_addr constant [5 x i8] c"(Ni)\00", align 1
@.str.317 = private unnamed_addr constant [11 x i8] c"argument 1\00", align 1
@.str.318 = private unnamed_addr constant [4 x i8] c"str\00", align 1
@.str.319 = private unnamed_addr constant [24 x i8] c"embedded null character\00", align 1
@.str.320 = private unnamed_addr constant [31 x i8] c"unable to determine login name\00", align 1
@.str.321 = private unnamed_addr constant [8 x i8] c"in:kill\00", align 1
@.str.322 = private unnamed_addr constant [8 x i8] c"os.kill\00", align 1
@.str.323 = private unnamed_addr constant [3 x i8] c"in\00", align 1
@.str.324 = private unnamed_addr constant [10 x i8] c"ii:killpg\00", align 1
@.str.325 = private unnamed_addr constant [10 x i8] c"os.killpg\00", align 1
@.str.326 = private unnamed_addr constant [3 x i8] c"ii\00", align 1
@.str.327 = private unnamed_addr constant [38 x i8] c"setgroups argument must be a sequence\00", align 1
@.str.328 = private unnamed_addr constant [16 x i8] c"too many groups\00", align 1
@.str.329 = private unnamed_addr constant [24 x i8] c"groups must be integers\00", align 1
@os_getpgid._kwtuple = internal global %struct.anon.802 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 1 }, [1 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 55040)] }, align 8
@os_getpgid._keywords = internal constant [2 x ptr] [ptr @.str.330, ptr null], align 16
@.str.330 = private unnamed_addr constant [4 x i8] c"pid\00", align 1
@os_getpgid._parser = internal global %struct._PyArg_Parser { ptr @.str.331, ptr @os_getpgid._keywords, ptr null, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_getpgid._kwtuple, i64 16), ptr null }, align 8
@.str.331 = private unnamed_addr constant [10 x i8] c"i:getpgid\00", align 1
@.str.332 = private unnamed_addr constant [3 x i8] c"Ni\00", align 1
@os_wait3._kwtuple = internal global %struct.anon.803 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 1 }, [1 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 54128)] }, align 8
@os_wait3._keywords = internal constant [2 x ptr] [ptr @.str.333, ptr null], align 16
@.str.333 = private unnamed_addr constant [8 x i8] c"options\00", align 1
@os_wait3._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_wait3._keywords, ptr @.str.89, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_wait3._kwtuple, i64 16), ptr null }, align 8
@.str.334 = private unnamed_addr constant [9 x i8] c"resource\00", align 1
@.str.335 = private unnamed_addr constant [14 x i8] c"struct_rusage\00", align 1
@.str.336 = private unnamed_addr constant [4 x i8] c"NiN\00", align 1
@os_wait4._kwtuple = internal global %struct.anon.818 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 2 }, [2 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 55040), ptr getelementptr (i8, ptr @_PyRuntime, i64 54128)] }, align 8
@os_wait4._keywords = internal constant [3 x ptr] [ptr @.str.330, ptr @.str.333, ptr null], align 16
@os_wait4._parser = internal global %struct._PyArg_Parser { ptr @.str.337, ptr @os_wait4._keywords, ptr null, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_wait4._kwtuple, i64 16), ptr null }, align 8
@.str.337 = private unnamed_addr constant [9 x i8] c"ii:wait4\00", align 1
@.str.338 = private unnamed_addr constant [11 x i8] c"iii:waitid\00", align 1
@.str.339 = private unnamed_addr constant [11 x i8] c"ii:waitpid\00", align 1
@os_pidfd_open._kwtuple = internal global %struct.anon.829 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 2 }, [2 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 55040), ptr getelementptr (i8, ptr @_PyRuntime, i64 45864)] }, align 8
@os_pidfd_open._keywords = internal constant [3 x ptr] [ptr @.str.330, ptr @.str.257, ptr null], align 16
@os_pidfd_open._parser = internal global %struct._PyArg_Parser { ptr @.str.340, ptr @os_pidfd_open._keywords, ptr null, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_pidfd_open._kwtuple, i64 16), ptr null }, align 8
@.str.340 = private unnamed_addr constant [16 x i8] c"i|O&:pidfd_open\00", align 1
@.str.341 = private unnamed_addr constant [9 x i8] c"i:getsid\00", align 1
@.str.342 = private unnamed_addr constant [11 x i8] c"ii:setpgid\00", align 1
@.str.343 = private unnamed_addr constant [13 x i8] c"ii:tcsetpgrp\00", align 1
@os_open._kwtuple = internal global %struct.anon.830 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 4 }, [4 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 54680), ptr getelementptr (i8, ptr @_PyRuntime, i64 45864), ptr getelementptr (i8, ptr @_PyRuntime, i64 51792), ptr getelementptr (i8, ptr @_PyRuntime, i64 43272)] }, align 8
@os_open._keywords = internal constant [5 x ptr] [ptr @.str.183, ptr @.str.257, ptr @.str.201, ptr @.str.184, ptr null], align 16
@os_open._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_open._keywords, ptr @.str.99, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_open._kwtuple, i64 16), ptr null }, align 8
@__const.os_open.path = private unnamed_addr constant %struct.path_t { ptr @.str.99, ptr @.str.183, i32 0, i32 0, ptr null, ptr null, i32 -1, i64 0, ptr null, ptr null }, align 8
@_Py_open_cloexec_works = external global i32, align 4
@os_close._kwtuple = internal global %struct.anon.831 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 1 }, [1 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 45144)] }, align 8
@os_close._keywords = internal constant [2 x ptr] [ptr @.str.208, ptr null], align 16
@os_close._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_close._keywords, ptr @.str.100, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_close._kwtuple, i64 16), ptr null }, align 8
@os_device_encoding._kwtuple = internal global %struct.anon.832 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 1 }, [1 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 45144)] }, align 8
@os_device_encoding._keywords = internal constant [2 x ptr] [ptr @.str.208, ptr null], align 16
@os_device_encoding._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_device_encoding._keywords, ptr @.str.102, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_device_encoding._kwtuple, i64 16), ptr null }, align 8
@os_dup2._kwtuple = internal global %struct.anon.833 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 3 }, [3 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 45144), ptr getelementptr (i8, ptr @_PyRuntime, i64 45192), ptr getelementptr (i8, ptr @_PyRuntime, i64 48064)] }, align 8
@os_dup2._keywords = internal constant [4 x ptr] [ptr @.str.208, ptr @.str.344, ptr @.str.345, ptr null], align 16
@.str.344 = private unnamed_addr constant [4 x i8] c"fd2\00", align 1
@.str.345 = private unnamed_addr constant [12 x i8] c"inheritable\00", align 1
@os_dup2._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_dup2._keywords, ptr @.str.104, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_dup2._kwtuple, i64 16), ptr null }, align 8
@os_dup2_impl.dup3_works = internal global i32 -1, align 4
@.str.346 = private unnamed_addr constant [9 x i8] c"os.lockf\00", align 1
@.str.347 = private unnamed_addr constant [4 x i8] c"iiL\00", align 1
@.str.348 = private unnamed_addr constant [33 x i8] c"readv() arg 2 must be a sequence\00", align 1
@.str.349 = private unnamed_addr constant [35 x i8] c"preadv2() arg 2 must be a sequence\00", align 1
@.str.350 = private unnamed_addr constant [34 x i8] c"writev() arg 2 must be a sequence\00", align 1
@.str.351 = private unnamed_addr constant [35 x i8] c"pwritev() arg 2 must be a sequence\00", align 1
@os_sendfile._kwtuple = internal global %struct.anon.834 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 4 }, [4 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 54272), ptr getelementptr (i8, ptr @_PyRuntime, i64 47800), ptr getelementptr (i8, ptr @_PyRuntime, i64 53496), ptr getelementptr (i8, ptr @_PyRuntime, i64 42184)] }, align 8
@os_sendfile._keywords = internal constant [5 x ptr] [ptr @.str.352, ptr @.str.353, ptr @.str.354, ptr @.str.253, ptr null], align 16
@.str.352 = private unnamed_addr constant [7 x i8] c"out_fd\00", align 1
@.str.353 = private unnamed_addr constant [6 x i8] c"in_fd\00", align 1
@.str.354 = private unnamed_addr constant [7 x i8] c"offset\00", align 1
@os_sendfile._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_sendfile._keywords, ptr @.str.115, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_sendfile._kwtuple, i64 16), ptr null }, align 8
@os_fstat._kwtuple = internal global %struct.anon.835 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 1 }, [1 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 45144)] }, align 8
@os_fstat._keywords = internal constant [2 x ptr] [ptr @.str.208, ptr null], align 16
@os_fstat._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_fstat._keywords, ptr @.str.116, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_fstat._kwtuple, i64 16), ptr null }, align 8
@os_mkfifo._kwtuple = internal global %struct.anon.836 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 3 }, [3 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 54680), ptr getelementptr (i8, ptr @_PyRuntime, i64 51792), ptr getelementptr (i8, ptr @_PyRuntime, i64 43272)] }, align 8
@os_mkfifo._keywords = internal constant [4 x ptr] [ptr @.str.183, ptr @.str.201, ptr @.str.184, ptr null], align 16
@os_mkfifo._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_mkfifo._keywords, ptr @.str.120, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_mkfifo._kwtuple, i64 16), ptr null }, align 8
@__const.os_mkfifo.path = private unnamed_addr constant %struct.path_t { ptr @.str.120, ptr @.str.183, i32 0, i32 0, ptr null, ptr null, i32 -1, i64 0, ptr null, ptr null }, align 8
@os_mknod._kwtuple = internal global %struct.anon.837 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 4 }, [4 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 54680), ptr getelementptr (i8, ptr @_PyRuntime, i64 51792), ptr getelementptr (i8, ptr @_PyRuntime, i64 42896), ptr getelementptr (i8, ptr @_PyRuntime, i64 43272)] }, align 8
@os_mknod._keywords = internal constant [5 x ptr] [ptr @.str.183, ptr @.str.201, ptr @.str.355, ptr @.str.184, ptr null], align 16
@.str.355 = private unnamed_addr constant [7 x i8] c"device\00", align 1
@os_mknod._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_mknod._keywords, ptr @.str.121, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_mknod._kwtuple, i64 16), ptr null }, align 8
@__const.os_mknod.path = private unnamed_addr constant %struct.path_t { ptr @.str.121, ptr @.str.183, i32 0, i32 0, ptr null, ptr null, i32 -1, i64 0, ptr null, ptr null }, align 8
@.str.356 = private unnamed_addr constant [12 x i8] c"os.truncate\00", align 1
@os_truncate._kwtuple = internal global %struct.anon.838 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 2 }, [2 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 54680), ptr getelementptr (i8, ptr @_PyRuntime, i64 50352)] }, align 8
@os_truncate._keywords = internal constant [3 x ptr] [ptr @.str.183, ptr @.str.357, ptr null], align 16
@.str.357 = private unnamed_addr constant [7 x i8] c"length\00", align 1
@os_truncate._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_truncate._keywords, ptr @.str.126, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_truncate._kwtuple, i64 16), ptr null }, align 8
@__const.os_truncate.path = private unnamed_addr constant %struct.path_t { ptr @.str.126, ptr @.str.183, i32 0, i32 1, ptr null, ptr null, i32 -1, i64 0, ptr null, ptr null }, align 8
@.str.358 = private unnamed_addr constant [3 x i8] c"On\00", align 1
@.str.359 = private unnamed_addr constant [10 x i8] c"os.putenv\00", align 1
@.str.360 = private unnamed_addr constant [3 x i8] c"OO\00", align 1
@.str.361 = private unnamed_addr constant [12 x i8] c"os.unsetenv\00", align 1
@.str.362 = private unnamed_addr constant [33 x i8] c"strerror() argument out of range\00", align 1
@.str.363 = private unnamed_addr constant [16 x i8] c"surrogateescape\00", align 1
@os_fchdir._kwtuple = internal global %struct.anon.839 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 1 }, [1 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 45144)] }, align 8
@os_fchdir._keywords = internal constant [2 x ptr] [ptr @.str.208, ptr null], align 16
@os_fchdir._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_fchdir._keywords, ptr @.str.132, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_fchdir._kwtuple, i64 16), ptr null }, align 8
@.str.364 = private unnamed_addr constant [4 x i8] c"(i)\00", align 1
@os_fsync._kwtuple = internal global %struct.anon.840 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 1 }, [1 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 45144)] }, align 8
@os_fsync._keywords = internal constant [2 x ptr] [ptr @.str.208, ptr null], align 16
@os_fsync._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_fsync._keywords, ptr @.str.133, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_fsync._kwtuple, i64 16), ptr null }, align 8
@os_fdatasync._kwtuple = internal global %struct.anon.841 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 1 }, [1 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 45144)] }, align 8
@os_fdatasync._keywords = internal constant [2 x ptr] [ptr @.str.208, ptr null], align 16
@os_fdatasync._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_fdatasync._keywords, ptr @.str.135, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_fdatasync._kwtuple, i64 16), ptr null }, align 8
@os_WIFCONTINUED._kwtuple = internal global %struct.anon.842 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 1 }, [1 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 59064)] }, align 8
@os_WIFCONTINUED._keywords = internal constant [2 x ptr] [ptr @.str.277, ptr null], align 16
@os_WIFCONTINUED._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_WIFCONTINUED._keywords, ptr @.str.137, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_WIFCONTINUED._kwtuple, i64 16), ptr null }, align 8
@os_WIFSTOPPED._kwtuple = internal global %struct.anon.843 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 1 }, [1 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 59064)] }, align 8
@os_WIFSTOPPED._keywords = internal constant [2 x ptr] [ptr @.str.277, ptr null], align 16
@os_WIFSTOPPED._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_WIFSTOPPED._keywords, ptr @.str.138, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_WIFSTOPPED._kwtuple, i64 16), ptr null }, align 8
@os_WIFSIGNALED._kwtuple = internal global %struct.anon.844 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 1 }, [1 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 59064)] }, align 8
@os_WIFSIGNALED._keywords = internal constant [2 x ptr] [ptr @.str.277, ptr null], align 16
@os_WIFSIGNALED._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_WIFSIGNALED._keywords, ptr @.str.139, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_WIFSIGNALED._kwtuple, i64 16), ptr null }, align 8
@os_WIFEXITED._kwtuple = internal global %struct.anon.845 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 1 }, [1 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 59064)] }, align 8
@os_WIFEXITED._keywords = internal constant [2 x ptr] [ptr @.str.277, ptr null], align 16
@os_WIFEXITED._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_WIFEXITED._keywords, ptr @.str.140, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_WIFEXITED._kwtuple, i64 16), ptr null }, align 8
@os_WEXITSTATUS._kwtuple = internal global %struct.anon.846 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 1 }, [1 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 59064)] }, align 8
@os_WEXITSTATUS._keywords = internal constant [2 x ptr] [ptr @.str.277, ptr null], align 16
@os_WEXITSTATUS._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_WEXITSTATUS._keywords, ptr @.str.141, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_WEXITSTATUS._kwtuple, i64 16), ptr null }, align 8
@os_WTERMSIG._kwtuple = internal global %struct.anon.847 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 1 }, [1 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 59064)] }, align 8
@os_WTERMSIG._keywords = internal constant [2 x ptr] [ptr @.str.277, ptr null], align 16
@os_WTERMSIG._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_WTERMSIG._keywords, ptr @.str.142, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_WTERMSIG._kwtuple, i64 16), ptr null }, align 8
@os_WSTOPSIG._kwtuple = internal global %struct.anon.848 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 1 }, [1 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 59064)] }, align 8
@os_WSTOPSIG._keywords = internal constant [2 x ptr] [ptr @.str.277, ptr null], align 16
@os_WSTOPSIG._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_WSTOPSIG._keywords, ptr @.str.143, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_WSTOPSIG._kwtuple, i64 16), ptr null }, align 8
@os_statvfs._kwtuple = internal global %struct.anon.849 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 1 }, [1 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 54680)] }, align 8
@os_statvfs._keywords = internal constant [2 x ptr] [ptr @.str.183, ptr null], align 16
@os_statvfs._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_statvfs._keywords, ptr @.str.145, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_statvfs._kwtuple, i64 16), ptr null }, align 8
@__const.os_statvfs.path = private unnamed_addr constant %struct.path_t { ptr @.str.145, ptr @.str.183, i32 0, i32 1, ptr null, ptr null, i32 -1, i64 0, ptr null, ptr null }, align 8
@posix_constants_confstr = internal global [27 x %struct.constdef] [%struct.constdef { ptr @.str.367, i32 2 }, %struct.constdef { ptr @.str.368, i32 3 }, %struct.constdef { ptr @.str.369, i32 1004 }, %struct.constdef { ptr @.str.370, i32 1005 }, %struct.constdef { ptr @.str.371, i32 1006 }, %struct.constdef { ptr @.str.372, i32 1007 }, %struct.constdef { ptr @.str.373, i32 1000 }, %struct.constdef { ptr @.str.374, i32 1001 }, %struct.constdef { ptr @.str.375, i32 1002 }, %struct.constdef { ptr @.str.376, i32 1003 }, %struct.constdef { ptr @.str.377, i32 0 }, %struct.constdef { ptr @.str.378, i32 1100 }, %struct.constdef { ptr @.str.379, i32 1101 }, %struct.constdef { ptr @.str.380, i32 1102 }, %struct.constdef { ptr @.str.381, i32 1103 }, %struct.constdef { ptr @.str.382, i32 1104 }, %struct.constdef { ptr @.str.383, i32 1105 }, %struct.constdef { ptr @.str.384, i32 1106 }, %struct.constdef { ptr @.str.385, i32 1107 }, %struct.constdef { ptr @.str.386, i32 1108 }, %struct.constdef { ptr @.str.387, i32 1109 }, %struct.constdef { ptr @.str.388, i32 1110 }, %struct.constdef { ptr @.str.389, i32 1111 }, %struct.constdef { ptr @.str.390, i32 1112 }, %struct.constdef { ptr @.str.391, i32 1113 }, %struct.constdef { ptr @.str.392, i32 1114 }, %struct.constdef { ptr @.str.393, i32 1115 }], align 16
@.str.365 = private unnamed_addr constant [48 x i8] c"configuration names must be strings or integers\00", align 1
@.str.366 = private unnamed_addr constant [32 x i8] c"unrecognized configuration name\00", align 1
@.str.367 = private unnamed_addr constant [20 x i8] c"CS_GNU_LIBC_VERSION\00", align 1
@.str.368 = private unnamed_addr constant [26 x i8] c"CS_GNU_LIBPTHREAD_VERSION\00", align 1
@.str.369 = private unnamed_addr constant [16 x i8] c"CS_LFS64_CFLAGS\00", align 1
@.str.370 = private unnamed_addr constant [17 x i8] c"CS_LFS64_LDFLAGS\00", align 1
@.str.371 = private unnamed_addr constant [14 x i8] c"CS_LFS64_LIBS\00", align 1
@.str.372 = private unnamed_addr constant [19 x i8] c"CS_LFS64_LINTFLAGS\00", align 1
@.str.373 = private unnamed_addr constant [14 x i8] c"CS_LFS_CFLAGS\00", align 1
@.str.374 = private unnamed_addr constant [15 x i8] c"CS_LFS_LDFLAGS\00", align 1
@.str.375 = private unnamed_addr constant [12 x i8] c"CS_LFS_LIBS\00", align 1
@.str.376 = private unnamed_addr constant [17 x i8] c"CS_LFS_LINTFLAGS\00", align 1
@.str.377 = private unnamed_addr constant [8 x i8] c"CS_PATH\00", align 1
@.str.378 = private unnamed_addr constant [27 x i8] c"CS_XBS5_ILP32_OFF32_CFLAGS\00", align 1
@.str.379 = private unnamed_addr constant [28 x i8] c"CS_XBS5_ILP32_OFF32_LDFLAGS\00", align 1
@.str.380 = private unnamed_addr constant [25 x i8] c"CS_XBS5_ILP32_OFF32_LIBS\00", align 1
@.str.381 = private unnamed_addr constant [30 x i8] c"CS_XBS5_ILP32_OFF32_LINTFLAGS\00", align 1
@.str.382 = private unnamed_addr constant [28 x i8] c"CS_XBS5_ILP32_OFFBIG_CFLAGS\00", align 1
@.str.383 = private unnamed_addr constant [29 x i8] c"CS_XBS5_ILP32_OFFBIG_LDFLAGS\00", align 1
@.str.384 = private unnamed_addr constant [26 x i8] c"CS_XBS5_ILP32_OFFBIG_LIBS\00", align 1
@.str.385 = private unnamed_addr constant [31 x i8] c"CS_XBS5_ILP32_OFFBIG_LINTFLAGS\00", align 1
@.str.386 = private unnamed_addr constant [26 x i8] c"CS_XBS5_LP64_OFF64_CFLAGS\00", align 1
@.str.387 = private unnamed_addr constant [27 x i8] c"CS_XBS5_LP64_OFF64_LDFLAGS\00", align 1
@.str.388 = private unnamed_addr constant [24 x i8] c"CS_XBS5_LP64_OFF64_LIBS\00", align 1
@.str.389 = private unnamed_addr constant [29 x i8] c"CS_XBS5_LP64_OFF64_LINTFLAGS\00", align 1
@.str.390 = private unnamed_addr constant [28 x i8] c"CS_XBS5_LPBIG_OFFBIG_CFLAGS\00", align 1
@.str.391 = private unnamed_addr constant [29 x i8] c"CS_XBS5_LPBIG_OFFBIG_LDFLAGS\00", align 1
@.str.392 = private unnamed_addr constant [26 x i8] c"CS_XBS5_LPBIG_OFFBIG_LIBS\00", align 1
@.str.393 = private unnamed_addr constant [31 x i8] c"CS_XBS5_LPBIG_OFFBIG_LINTFLAGS\00", align 1
@posix_constants_sysconf = internal global [135 x %struct.constdef] [%struct.constdef { ptr @.str.394, i32 95 }, %struct.constdef { ptr @.str.395, i32 47 }, %struct.constdef { ptr @.str.396, i32 48 }, %struct.constdef { ptr @.str.397, i32 96 }, %struct.constdef { ptr @.str.398, i32 49 }, %struct.constdef { ptr @.str.399, i32 50 }, %struct.constdef { ptr @.str.400, i32 52 }, %struct.constdef { ptr @.str.401, i32 51 }, %struct.constdef { ptr @.str.402, i32 97 }, %struct.constdef { ptr @.str.403, i32 46 }, %struct.constdef { ptr @.str.404, i32 23 }, %struct.constdef { ptr @.str.405, i32 24 }, %struct.constdef { ptr @.str.406, i32 25 }, %struct.constdef { ptr @.str.407, i32 0 }, %struct.constdef { ptr @.str.408, i32 12 }, %struct.constdef { ptr @.str.409, i32 87 }, %struct.constdef { ptr @.str.410, i32 86 }, %struct.constdef { ptr @.str.411, i32 36 }, %struct.constdef { ptr @.str.412, i32 37 }, %struct.constdef { ptr @.str.413, i32 38 }, %struct.constdef { ptr @.str.414, i32 39 }, %struct.constdef { ptr @.str.415, i32 45 }, %struct.constdef { ptr @.str.416, i32 101 }, %struct.constdef { ptr @.str.417, i32 102 }, %struct.constdef { ptr @.str.418, i32 103 }, %struct.constdef { ptr @.str.419, i32 1 }, %struct.constdef { ptr @.str.420, i32 2 }, %struct.constdef { ptr @.str.421, i32 40 }, %struct.constdef { ptr @.str.422, i32 26 }, %struct.constdef { ptr @.str.423, i32 41 }, %struct.constdef { ptr @.str.424, i32 42 }, %struct.constdef { ptr @.str.425, i32 15 }, %struct.constdef { ptr @.str.426, i32 69 }, %struct.constdef { ptr @.str.427, i32 70 }, %struct.constdef { ptr @.str.428, i32 104 }, %struct.constdef { ptr @.str.429, i32 105 }, %struct.constdef { ptr @.str.430, i32 60 }, %struct.constdef { ptr @.str.431, i32 7 }, %struct.constdef { ptr @.str.432, i32 43 }, %struct.constdef { ptr @.str.433, i32 71 }, %struct.constdef { ptr @.str.434, i32 106 }, %struct.constdef { ptr @.str.435, i32 16 }, %struct.constdef { ptr @.str.436, i32 108 }, %struct.constdef { ptr @.str.437, i32 17 }, %struct.constdef { ptr @.str.438, i32 18 }, %struct.constdef { ptr @.str.439, i32 19 }, %struct.constdef { ptr @.str.440, i32 20 }, %struct.constdef { ptr @.str.441, i32 27 }, %struct.constdef { ptr @.str.442, i32 28 }, %struct.constdef { ptr @.str.443, i32 3 }, %struct.constdef { ptr @.str.444, i32 119 }, %struct.constdef { ptr @.str.445, i32 120 }, %struct.constdef { ptr @.str.446, i32 121 }, %struct.constdef { ptr @.str.447, i32 122 }, %struct.constdef { ptr @.str.448, i32 123 }, %struct.constdef { ptr @.str.449, i32 124 }, %struct.constdef { ptr @.str.450, i32 83 }, %struct.constdef { ptr @.str.451, i32 84 }, %struct.constdef { ptr @.str.452, i32 109 }, %struct.constdef { ptr @.str.453, i32 4 }, %struct.constdef { ptr @.str.454, i32 30 }, %struct.constdef { ptr @.str.455, i32 30 }, %struct.constdef { ptr @.str.456, i32 88 }, %struct.constdef { ptr @.str.457, i32 85 }, %struct.constdef { ptr @.str.458, i32 53 }, %struct.constdef { ptr @.str.459, i32 56 }, %struct.constdef { ptr @.str.460, i32 62 }, %struct.constdef { ptr @.str.461, i32 61 }, %struct.constdef { ptr @.str.462, i32 57 }, %struct.constdef { ptr @.str.463, i32 64 }, %struct.constdef { ptr @.str.464, i32 63 }, %struct.constdef { ptr @.str.465, i32 65 }, %struct.constdef { ptr @.str.466, i32 55 }, %struct.constdef { ptr @.str.467, i32 54 }, %struct.constdef { ptr @.str.468, i32 58 }, %struct.constdef { ptr @.str.469, i32 13 }, %struct.constdef { ptr @.str.470, i32 10 }, %struct.constdef { ptr @.str.471, i32 9 }, %struct.constdef { ptr @.str.472, i32 44 }, %struct.constdef { ptr @.str.473, i32 31 }, %struct.constdef { ptr @.str.474, i32 8 }, %struct.constdef { ptr @.str.475, i32 111 }, %struct.constdef { ptr @.str.476, i32 112 }, %struct.constdef { ptr @.str.477, i32 59 }, %struct.constdef { ptr @.str.478, i32 21 }, %struct.constdef { ptr @.str.479, i32 32 }, %struct.constdef { ptr @.str.480, i32 33 }, %struct.constdef { ptr @.str.481, i32 22 }, %struct.constdef { ptr @.str.482, i32 113 }, %struct.constdef { ptr @.str.483, i32 114 }, %struct.constdef { ptr @.str.484, i32 34 }, %struct.constdef { ptr @.str.485, i32 110 }, %struct.constdef { ptr @.str.486, i32 5 }, %struct.constdef { ptr @.str.487, i32 14 }, %struct.constdef { ptr @.str.488, i32 67 }, %struct.constdef { ptr @.str.489, i32 77 }, %struct.constdef { ptr @.str.490, i32 78 }, %struct.constdef { ptr @.str.491, i32 73 }, %struct.constdef { ptr @.str.492, i32 74 }, %struct.constdef { ptr @.str.493, i32 79 }, %struct.constdef { ptr @.str.494, i32 80 }, %struct.constdef { ptr @.str.495, i32 81 }, %struct.constdef { ptr @.str.496, i32 82 }, %struct.constdef { ptr @.str.497, i32 68 }, %struct.constdef { ptr @.str.498, i32 75 }, %struct.constdef { ptr @.str.499, i32 76 }, %struct.constdef { ptr @.str.500, i32 11 }, %struct.constdef { ptr @.str.501, i32 35 }, %struct.constdef { ptr @.str.502, i32 72 }, %struct.constdef { ptr @.str.503, i32 6 }, %struct.constdef { ptr @.str.504, i32 66 }, %struct.constdef { ptr @.str.505, i32 115 }, %struct.constdef { ptr @.str.506, i32 116 }, %struct.constdef { ptr @.str.507, i32 60 }, %struct.constdef { ptr @.str.508, i32 117 }, %struct.constdef { ptr @.str.509, i32 118 }, %struct.constdef { ptr @.str.510, i32 29 }, %struct.constdef { ptr @.str.511, i32 107 }, %struct.constdef { ptr @.str.512, i32 125 }, %struct.constdef { ptr @.str.513, i32 126 }, %struct.constdef { ptr @.str.514, i32 127 }, %struct.constdef { ptr @.str.515, i32 128 }, %struct.constdef { ptr @.str.516, i32 92 }, %struct.constdef { ptr @.str.517, i32 93 }, %struct.constdef { ptr @.str.518, i32 129 }, %struct.constdef { ptr @.str.519, i32 130 }, %struct.constdef { ptr @.str.520, i32 131 }, %struct.constdef { ptr @.str.521, i32 94 }, %struct.constdef { ptr @.str.522, i32 91 }, %struct.constdef { ptr @.str.523, i32 89 }, %struct.constdef { ptr @.str.524, i32 90 }, %struct.constdef { ptr @.str.525, i32 98 }, %struct.constdef { ptr @.str.526, i32 99 }, %struct.constdef { ptr @.str.527, i32 100 }, %struct.constdef { ptr @.str.528, i32 249 }], align 16
@.str.394 = private unnamed_addr constant [15 x i8] c"SC_2_CHAR_TERM\00", align 1
@.str.395 = private unnamed_addr constant [12 x i8] c"SC_2_C_BIND\00", align 1
@.str.396 = private unnamed_addr constant [11 x i8] c"SC_2_C_DEV\00", align 1
@.str.397 = private unnamed_addr constant [15 x i8] c"SC_2_C_VERSION\00", align 1
@.str.398 = private unnamed_addr constant [14 x i8] c"SC_2_FORT_DEV\00", align 1
@.str.399 = private unnamed_addr constant [14 x i8] c"SC_2_FORT_RUN\00", align 1
@.str.400 = private unnamed_addr constant [15 x i8] c"SC_2_LOCALEDEF\00", align 1
@.str.401 = private unnamed_addr constant [12 x i8] c"SC_2_SW_DEV\00", align 1
@.str.402 = private unnamed_addr constant [9 x i8] c"SC_2_UPE\00", align 1
@.str.403 = private unnamed_addr constant [13 x i8] c"SC_2_VERSION\00", align 1
@.str.404 = private unnamed_addr constant [18 x i8] c"SC_AIO_LISTIO_MAX\00", align 1
@.str.405 = private unnamed_addr constant [11 x i8] c"SC_AIO_MAX\00", align 1
@.str.406 = private unnamed_addr constant [22 x i8] c"SC_AIO_PRIO_DELTA_MAX\00", align 1
@.str.407 = private unnamed_addr constant [11 x i8] c"SC_ARG_MAX\00", align 1
@.str.408 = private unnamed_addr constant [19 x i8] c"SC_ASYNCHRONOUS_IO\00", align 1
@.str.409 = private unnamed_addr constant [14 x i8] c"SC_ATEXIT_MAX\00", align 1
@.str.410 = private unnamed_addr constant [16 x i8] c"SC_AVPHYS_PAGES\00", align 1
@.str.411 = private unnamed_addr constant [15 x i8] c"SC_BC_BASE_MAX\00", align 1
@.str.412 = private unnamed_addr constant [14 x i8] c"SC_BC_DIM_MAX\00", align 1
@.str.413 = private unnamed_addr constant [16 x i8] c"SC_BC_SCALE_MAX\00", align 1
@.str.414 = private unnamed_addr constant [17 x i8] c"SC_BC_STRING_MAX\00", align 1
@.str.415 = private unnamed_addr constant [22 x i8] c"SC_CHARCLASS_NAME_MAX\00", align 1
@.str.416 = private unnamed_addr constant [12 x i8] c"SC_CHAR_BIT\00", align 1
@.str.417 = private unnamed_addr constant [12 x i8] c"SC_CHAR_MAX\00", align 1
@.str.418 = private unnamed_addr constant [12 x i8] c"SC_CHAR_MIN\00", align 1
@.str.419 = private unnamed_addr constant [13 x i8] c"SC_CHILD_MAX\00", align 1
@.str.420 = private unnamed_addr constant [11 x i8] c"SC_CLK_TCK\00", align 1
@.str.421 = private unnamed_addr constant [20 x i8] c"SC_COLL_WEIGHTS_MAX\00", align 1
@.str.422 = private unnamed_addr constant [18 x i8] c"SC_DELAYTIMER_MAX\00", align 1
@.str.423 = private unnamed_addr constant [19 x i8] c"SC_EQUIV_CLASS_MAX\00", align 1
@.str.424 = private unnamed_addr constant [17 x i8] c"SC_EXPR_NEST_MAX\00", align 1
@.str.425 = private unnamed_addr constant [9 x i8] c"SC_FSYNC\00", align 1
@.str.426 = private unnamed_addr constant [20 x i8] c"SC_GETGR_R_SIZE_MAX\00", align 1
@.str.427 = private unnamed_addr constant [20 x i8] c"SC_GETPW_R_SIZE_MAX\00", align 1
@.str.428 = private unnamed_addr constant [11 x i8] c"SC_INT_MAX\00", align 1
@.str.429 = private unnamed_addr constant [11 x i8] c"SC_INT_MIN\00", align 1
@.str.430 = private unnamed_addr constant [11 x i8] c"SC_IOV_MAX\00", align 1
@.str.431 = private unnamed_addr constant [15 x i8] c"SC_JOB_CONTROL\00", align 1
@.str.432 = private unnamed_addr constant [12 x i8] c"SC_LINE_MAX\00", align 1
@.str.433 = private unnamed_addr constant [18 x i8] c"SC_LOGIN_NAME_MAX\00", align 1
@.str.434 = private unnamed_addr constant [12 x i8] c"SC_LONG_BIT\00", align 1
@.str.435 = private unnamed_addr constant [16 x i8] c"SC_MAPPED_FILES\00", align 1
@.str.436 = private unnamed_addr constant [14 x i8] c"SC_MB_LEN_MAX\00", align 1
@.str.437 = private unnamed_addr constant [11 x i8] c"SC_MEMLOCK\00", align 1
@.str.438 = private unnamed_addr constant [17 x i8] c"SC_MEMLOCK_RANGE\00", align 1
@.str.439 = private unnamed_addr constant [21 x i8] c"SC_MEMORY_PROTECTION\00", align 1
@.str.440 = private unnamed_addr constant [19 x i8] c"SC_MESSAGE_PASSING\00", align 1
@.str.441 = private unnamed_addr constant [15 x i8] c"SC_MQ_OPEN_MAX\00", align 1
@.str.442 = private unnamed_addr constant [15 x i8] c"SC_MQ_PRIO_MAX\00", align 1
@.str.443 = private unnamed_addr constant [15 x i8] c"SC_NGROUPS_MAX\00", align 1
@.str.444 = private unnamed_addr constant [13 x i8] c"SC_NL_ARGMAX\00", align 1
@.str.445 = private unnamed_addr constant [14 x i8] c"SC_NL_LANGMAX\00", align 1
@.str.446 = private unnamed_addr constant [13 x i8] c"SC_NL_MSGMAX\00", align 1
@.str.447 = private unnamed_addr constant [11 x i8] c"SC_NL_NMAX\00", align 1
@.str.448 = private unnamed_addr constant [13 x i8] c"SC_NL_SETMAX\00", align 1
@.str.449 = private unnamed_addr constant [14 x i8] c"SC_NL_TEXTMAX\00", align 1
@.str.450 = private unnamed_addr constant [20 x i8] c"SC_NPROCESSORS_CONF\00", align 1
@.str.451 = private unnamed_addr constant [20 x i8] c"SC_NPROCESSORS_ONLN\00", align 1
@.str.452 = private unnamed_addr constant [9 x i8] c"SC_NZERO\00", align 1
@.str.453 = private unnamed_addr constant [12 x i8] c"SC_OPEN_MAX\00", align 1
@.str.454 = private unnamed_addr constant [12 x i8] c"SC_PAGESIZE\00", align 1
@.str.455 = private unnamed_addr constant [13 x i8] c"SC_PAGE_SIZE\00", align 1
@.str.456 = private unnamed_addr constant [12 x i8] c"SC_PASS_MAX\00", align 1
@.str.457 = private unnamed_addr constant [14 x i8] c"SC_PHYS_PAGES\00", align 1
@.str.458 = private unnamed_addr constant [7 x i8] c"SC_PII\00", align 1
@.str.459 = private unnamed_addr constant [16 x i8] c"SC_PII_INTERNET\00", align 1
@.str.460 = private unnamed_addr constant [22 x i8] c"SC_PII_INTERNET_DGRAM\00", align 1
@.str.461 = private unnamed_addr constant [23 x i8] c"SC_PII_INTERNET_STREAM\00", align 1
@.str.462 = private unnamed_addr constant [11 x i8] c"SC_PII_OSI\00", align 1
@.str.463 = private unnamed_addr constant [16 x i8] c"SC_PII_OSI_CLTS\00", align 1
@.str.464 = private unnamed_addr constant [16 x i8] c"SC_PII_OSI_COTS\00", align 1
@.str.465 = private unnamed_addr constant [13 x i8] c"SC_PII_OSI_M\00", align 1
@.str.466 = private unnamed_addr constant [14 x i8] c"SC_PII_SOCKET\00", align 1
@.str.467 = private unnamed_addr constant [11 x i8] c"SC_PII_XTI\00", align 1
@.str.468 = private unnamed_addr constant [8 x i8] c"SC_POLL\00", align 1
@.str.469 = private unnamed_addr constant [18 x i8] c"SC_PRIORITIZED_IO\00", align 1
@.str.470 = private unnamed_addr constant [23 x i8] c"SC_PRIORITY_SCHEDULING\00", align 1
@.str.471 = private unnamed_addr constant [20 x i8] c"SC_REALTIME_SIGNALS\00", align 1
@.str.472 = private unnamed_addr constant [14 x i8] c"SC_RE_DUP_MAX\00", align 1
@.str.473 = private unnamed_addr constant [13 x i8] c"SC_RTSIG_MAX\00", align 1
@.str.474 = private unnamed_addr constant [13 x i8] c"SC_SAVED_IDS\00", align 1
@.str.475 = private unnamed_addr constant [13 x i8] c"SC_SCHAR_MAX\00", align 1
@.str.476 = private unnamed_addr constant [13 x i8] c"SC_SCHAR_MIN\00", align 1
@.str.477 = private unnamed_addr constant [10 x i8] c"SC_SELECT\00", align 1
@.str.478 = private unnamed_addr constant [14 x i8] c"SC_SEMAPHORES\00", align 1
@.str.479 = private unnamed_addr constant [17 x i8] c"SC_SEM_NSEMS_MAX\00", align 1
@.str.480 = private unnamed_addr constant [17 x i8] c"SC_SEM_VALUE_MAX\00", align 1
@.str.481 = private unnamed_addr constant [25 x i8] c"SC_SHARED_MEMORY_OBJECTS\00", align 1
@.str.482 = private unnamed_addr constant [12 x i8] c"SC_SHRT_MAX\00", align 1
@.str.483 = private unnamed_addr constant [12 x i8] c"SC_SHRT_MIN\00", align 1
@.str.484 = private unnamed_addr constant [16 x i8] c"SC_SIGQUEUE_MAX\00", align 1
@.str.485 = private unnamed_addr constant [13 x i8] c"SC_SSIZE_MAX\00", align 1
@.str.486 = private unnamed_addr constant [14 x i8] c"SC_STREAM_MAX\00", align 1
@.str.487 = private unnamed_addr constant [19 x i8] c"SC_SYNCHRONIZED_IO\00", align 1
@.str.488 = private unnamed_addr constant [11 x i8] c"SC_THREADS\00", align 1
@.str.489 = private unnamed_addr constant [25 x i8] c"SC_THREAD_ATTR_STACKADDR\00", align 1
@.str.490 = private unnamed_addr constant [25 x i8] c"SC_THREAD_ATTR_STACKSIZE\00", align 1
@.str.491 = private unnamed_addr constant [32 x i8] c"SC_THREAD_DESTRUCTOR_ITERATIONS\00", align 1
@.str.492 = private unnamed_addr constant [19 x i8] c"SC_THREAD_KEYS_MAX\00", align 1
@.str.493 = private unnamed_addr constant [30 x i8] c"SC_THREAD_PRIORITY_SCHEDULING\00", align 1
@.str.494 = private unnamed_addr constant [23 x i8] c"SC_THREAD_PRIO_INHERIT\00", align 1
@.str.495 = private unnamed_addr constant [23 x i8] c"SC_THREAD_PRIO_PROTECT\00", align 1
@.str.496 = private unnamed_addr constant [25 x i8] c"SC_THREAD_PROCESS_SHARED\00", align 1
@.str.497 = private unnamed_addr constant [25 x i8] c"SC_THREAD_SAFE_FUNCTIONS\00", align 1
@.str.498 = private unnamed_addr constant [20 x i8] c"SC_THREAD_STACK_MIN\00", align 1
@.str.499 = private unnamed_addr constant [22 x i8] c"SC_THREAD_THREADS_MAX\00", align 1
@.str.500 = private unnamed_addr constant [10 x i8] c"SC_TIMERS\00", align 1
@.str.501 = private unnamed_addr constant [13 x i8] c"SC_TIMER_MAX\00", align 1
@.str.502 = private unnamed_addr constant [16 x i8] c"SC_TTY_NAME_MAX\00", align 1
@.str.503 = private unnamed_addr constant [14 x i8] c"SC_TZNAME_MAX\00", align 1
@.str.504 = private unnamed_addr constant [13 x i8] c"SC_T_IOV_MAX\00", align 1
@.str.505 = private unnamed_addr constant [13 x i8] c"SC_UCHAR_MAX\00", align 1
@.str.506 = private unnamed_addr constant [12 x i8] c"SC_UINT_MAX\00", align 1
@.str.507 = private unnamed_addr constant [14 x i8] c"SC_UIO_MAXIOV\00", align 1
@.str.508 = private unnamed_addr constant [13 x i8] c"SC_ULONG_MAX\00", align 1
@.str.509 = private unnamed_addr constant [13 x i8] c"SC_USHRT_MAX\00", align 1
@.str.510 = private unnamed_addr constant [11 x i8] c"SC_VERSION\00", align 1
@.str.511 = private unnamed_addr constant [12 x i8] c"SC_WORD_BIT\00", align 1
@.str.512 = private unnamed_addr constant [20 x i8] c"SC_XBS5_ILP32_OFF32\00", align 1
@.str.513 = private unnamed_addr constant [21 x i8] c"SC_XBS5_ILP32_OFFBIG\00", align 1
@.str.514 = private unnamed_addr constant [19 x i8] c"SC_XBS5_LP64_OFF64\00", align 1
@.str.515 = private unnamed_addr constant [21 x i8] c"SC_XBS5_LPBIG_OFFBIG\00", align 1
@.str.516 = private unnamed_addr constant [15 x i8] c"SC_XOPEN_CRYPT\00", align 1
@.str.517 = private unnamed_addr constant [18 x i8] c"SC_XOPEN_ENH_I18N\00", align 1
@.str.518 = private unnamed_addr constant [16 x i8] c"SC_XOPEN_LEGACY\00", align 1
@.str.519 = private unnamed_addr constant [18 x i8] c"SC_XOPEN_REALTIME\00", align 1
@.str.520 = private unnamed_addr constant [26 x i8] c"SC_XOPEN_REALTIME_THREADS\00", align 1
@.str.521 = private unnamed_addr constant [13 x i8] c"SC_XOPEN_SHM\00", align 1
@.str.522 = private unnamed_addr constant [14 x i8] c"SC_XOPEN_UNIX\00", align 1
@.str.523 = private unnamed_addr constant [17 x i8] c"SC_XOPEN_VERSION\00", align 1
@.str.524 = private unnamed_addr constant [21 x i8] c"SC_XOPEN_XCU_VERSION\00", align 1
@.str.525 = private unnamed_addr constant [14 x i8] c"SC_XOPEN_XPG2\00", align 1
@.str.526 = private unnamed_addr constant [14 x i8] c"SC_XOPEN_XPG3\00", align 1
@.str.527 = private unnamed_addr constant [14 x i8] c"SC_XOPEN_XPG4\00", align 1
@.str.528 = private unnamed_addr constant [15 x i8] c"SC_MINSIGSTKSZ\00", align 1
@posix_constants_pathconf = internal global [20 x %struct.constdef] [%struct.constdef { ptr @.str.529, i32 10 }, %struct.constdef { ptr @.str.530, i32 6 }, %struct.constdef { ptr @.str.531, i32 13 }, %struct.constdef { ptr @.str.532, i32 0 }, %struct.constdef { ptr @.str.533, i32 1 }, %struct.constdef { ptr @.str.534, i32 2 }, %struct.constdef { ptr @.str.535, i32 3 }, %struct.constdef { ptr @.str.536, i32 7 }, %struct.constdef { ptr @.str.537, i32 4 }, %struct.constdef { ptr @.str.538, i32 5 }, %struct.constdef { ptr @.str.539, i32 11 }, %struct.constdef { ptr @.str.540, i32 12 }, %struct.constdef { ptr @.str.541, i32 9 }, %struct.constdef { ptr @.str.542, i32 8 }, %struct.constdef { ptr @.str.543, i32 18 }, %struct.constdef { ptr @.str.544, i32 14 }, %struct.constdef { ptr @.str.545, i32 15 }, %struct.constdef { ptr @.str.546, i32 16 }, %struct.constdef { ptr @.str.547, i32 17 }, %struct.constdef { ptr @.str.548, i32 19 }], align 16
@.str.529 = private unnamed_addr constant [12 x i8] c"PC_ASYNC_IO\00", align 1
@.str.530 = private unnamed_addr constant [20 x i8] c"PC_CHOWN_RESTRICTED\00", align 1
@.str.531 = private unnamed_addr constant [16 x i8] c"PC_FILESIZEBITS\00", align 1
@.str.532 = private unnamed_addr constant [12 x i8] c"PC_LINK_MAX\00", align 1
@.str.533 = private unnamed_addr constant [13 x i8] c"PC_MAX_CANON\00", align 1
@.str.534 = private unnamed_addr constant [13 x i8] c"PC_MAX_INPUT\00", align 1
@.str.535 = private unnamed_addr constant [12 x i8] c"PC_NAME_MAX\00", align 1
@.str.536 = private unnamed_addr constant [12 x i8] c"PC_NO_TRUNC\00", align 1
@.str.537 = private unnamed_addr constant [12 x i8] c"PC_PATH_MAX\00", align 1
@.str.538 = private unnamed_addr constant [12 x i8] c"PC_PIPE_BUF\00", align 1
@.str.539 = private unnamed_addr constant [11 x i8] c"PC_PRIO_IO\00", align 1
@.str.540 = private unnamed_addr constant [15 x i8] c"PC_SOCK_MAXBUF\00", align 1
@.str.541 = private unnamed_addr constant [11 x i8] c"PC_SYNC_IO\00", align 1
@.str.542 = private unnamed_addr constant [12 x i8] c"PC_VDISABLE\00", align 1
@.str.543 = private unnamed_addr constant [18 x i8] c"PC_ALLOC_SIZE_MIN\00", align 1
@.str.544 = private unnamed_addr constant [22 x i8] c"PC_REC_INCR_XFER_SIZE\00", align 1
@.str.545 = private unnamed_addr constant [21 x i8] c"PC_REC_MAX_XFER_SIZE\00", align 1
@.str.546 = private unnamed_addr constant [21 x i8] c"PC_REC_MIN_XFER_SIZE\00", align 1
@.str.547 = private unnamed_addr constant [18 x i8] c"PC_REC_XFER_ALIGN\00", align 1
@.str.548 = private unnamed_addr constant [15 x i8] c"PC_SYMLINK_MAX\00", align 1
@os_pathconf._kwtuple = internal global %struct.anon.850 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 2 }, [2 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 54680), ptr getelementptr (i8, ptr @_PyRuntime, i64 52416)] }, align 8
@os_pathconf._keywords = internal constant [3 x ptr] [ptr @.str.183, ptr @.str.549, ptr null], align 16
@.str.549 = private unnamed_addr constant [5 x i8] c"name\00", align 1
@os_pathconf._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_pathconf._keywords, ptr @.str.149, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_pathconf._kwtuple, i64 16), ptr null }, align 8
@__const.os_pathconf.path = private unnamed_addr constant %struct.path_t { ptr @.str.149, ptr @.str.183, i32 0, i32 1, ptr null, ptr null, i32 -1, i64 0, ptr null, ptr null }, align 8
@os__path_normpath._kwtuple = internal global %struct.anon.851 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 1 }, [1 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 54680)] }, align 8
@os__path_normpath._keywords = internal constant [2 x ptr] [ptr @.str.183, ptr null], align 16
@os__path_normpath._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os__path_normpath._keywords, ptr @.str.151, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os__path_normpath._kwtuple, i64 16), ptr null }, align 8
@.str.550 = private unnamed_addr constant [29 x i8] c"expected 'str', not '%.200s'\00", align 1
@.str.551 = private unnamed_addr constant [31 x i8] c"Load averages are unobtainable\00", align 1
@.str.552 = private unnamed_addr constant [4 x i8] c"ddd\00", align 1
@.str.553 = private unnamed_addr constant [30 x i8] c"negative argument not allowed\00", align 1
@.str.554 = private unnamed_addr constant [6 x i8] c"(NNN)\00", align 1
@os_getxattr._kwtuple = internal global %struct.anon.852 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 3 }, [3 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 54680), ptr getelementptr (i8, ptr @_PyRuntime, i64 38360), ptr getelementptr (i8, ptr @_PyRuntime, i64 45960)] }, align 8
@os_getxattr._keywords = internal constant [4 x ptr] [ptr @.str.183, ptr @.str.555, ptr @.str.185, ptr null], align 16
@.str.555 = private unnamed_addr constant [10 x i8] c"attribute\00", align 1
@os_getxattr._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_getxattr._keywords, ptr @.str.158, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_getxattr._kwtuple, i64 16), ptr null }, align 8
@__const.os_getxattr.path = private unnamed_addr constant %struct.path_t { ptr @.str.158, ptr @.str.183, i32 0, i32 1, ptr null, ptr null, i32 -1, i64 0, ptr null, ptr null }, align 8
@__const.os_getxattr.attribute = private unnamed_addr constant %struct.path_t { ptr @.str.158, ptr @.str.555, i32 0, i32 0, ptr null, ptr null, i32 -1, i64 0, ptr null, ptr null }, align 8
@.str.556 = private unnamed_addr constant [12 x i8] c"os.getxattr\00", align 1
@os_getxattr_impl.buffer_sizes = internal constant [3 x i64] [i64 128, i64 65536, i64 0], align 16
@os_setxattr._kwtuple = internal global %struct.anon.853 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 5 }, [5 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 54680), ptr getelementptr (i8, ptr @_PyRuntime, i64 38360), ptr getelementptr (i8, ptr @_PyRuntime, i64 61592), ptr getelementptr (i8, ptr @_PyRuntime, i64 45864), ptr getelementptr (i8, ptr @_PyRuntime, i64 45960)] }, align 8
@os_setxattr._keywords = internal constant [6 x ptr] [ptr @.str.183, ptr @.str.555, ptr @.str.557, ptr @.str.257, ptr @.str.185, ptr null], align 16
@.str.557 = private unnamed_addr constant [6 x i8] c"value\00", align 1
@os_setxattr._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_setxattr._keywords, ptr @.str.159, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_setxattr._kwtuple, i64 16), ptr null }, align 8
@__const.os_setxattr.path = private unnamed_addr constant %struct.path_t { ptr @.str.159, ptr @.str.183, i32 0, i32 1, ptr null, ptr null, i32 -1, i64 0, ptr null, ptr null }, align 8
@__const.os_setxattr.attribute = private unnamed_addr constant %struct.path_t { ptr @.str.159, ptr @.str.555, i32 0, i32 0, ptr null, ptr null, i32 -1, i64 0, ptr null, ptr null }, align 8
@.str.558 = private unnamed_addr constant [12 x i8] c"os.setxattr\00", align 1
@.str.559 = private unnamed_addr constant [6 x i8] c"OOy#i\00", align 1
@os_removexattr._kwtuple = internal global %struct.anon.854 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 3 }, [3 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 54680), ptr getelementptr (i8, ptr @_PyRuntime, i64 38360), ptr getelementptr (i8, ptr @_PyRuntime, i64 45960)] }, align 8
@os_removexattr._keywords = internal constant [4 x ptr] [ptr @.str.183, ptr @.str.555, ptr @.str.185, ptr null], align 16
@os_removexattr._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_removexattr._keywords, ptr @.str.160, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_removexattr._kwtuple, i64 16), ptr null }, align 8
@__const.os_removexattr.path = private unnamed_addr constant %struct.path_t { ptr @.str.160, ptr @.str.183, i32 0, i32 1, ptr null, ptr null, i32 -1, i64 0, ptr null, ptr null }, align 8
@__const.os_removexattr.attribute = private unnamed_addr constant %struct.path_t { ptr @.str.160, ptr @.str.555, i32 0, i32 0, ptr null, ptr null, i32 -1, i64 0, ptr null, ptr null }, align 8
@.str.560 = private unnamed_addr constant [15 x i8] c"os.removexattr\00", align 1
@os_listxattr._kwtuple = internal global %struct.anon.855 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 2 }, [2 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 54680), ptr getelementptr (i8, ptr @_PyRuntime, i64 45960)] }, align 8
@os_listxattr._keywords = internal constant [3 x ptr] [ptr @.str.183, ptr @.str.185, ptr null], align 16
@os_listxattr._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_listxattr._keywords, ptr @.str.161, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_listxattr._kwtuple, i64 16), ptr null }, align 8
@__const.os_listxattr.path = private unnamed_addr constant %struct.path_t { ptr @.str.161, ptr @.str.183, i32 1, i32 1, ptr null, ptr null, i32 -1, i64 0, ptr null, ptr null }, align 8
@.str.561 = private unnamed_addr constant [13 x i8] c"os.listxattr\00", align 1
@os_listxattr_impl.buffer_sizes = internal constant [3 x i64] [i64 256, i64 65536, i64 0], align 16
@stdout = external global ptr, align 8
@os_scandir._kwtuple = internal global %struct.anon.856 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 1 }, [1 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 54680)] }, align 8
@os_scandir._keywords = internal constant [2 x ptr] [ptr @.str.183, ptr null], align 16
@os_scandir._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_scandir._keywords, ptr @.str.168, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_scandir._kwtuple, i64 16), ptr null }, align 8
@__const.os_scandir.path = private unnamed_addr constant %struct.path_t { ptr @.str.168, ptr @.str.183, i32 1, i32 1, ptr null, ptr null, i32 -1, i64 0, ptr null, ptr null }, align 8
@.str.562 = private unnamed_addr constant [11 x i8] c"os.scandir\00", align 1
@os_fspath._kwtuple = internal global %struct.anon.857 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 1 }, [1 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 54680)] }, align 8
@os_fspath._keywords = internal constant [2 x ptr] [ptr @.str.183, ptr null], align 16
@os_fspath._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_fspath._keywords, ptr @.str.169, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_fspath._kwtuple, i64 16), ptr null }, align 8
@os_getrandom._kwtuple = internal global %struct.anon.858 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 2 }, [2 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 58376), ptr getelementptr (i8, ptr @_PyRuntime, i64 45864)] }, align 8
@os_getrandom._keywords = internal constant [3 x ptr] [ptr @.str.563, ptr @.str.257, ptr null], align 16
@.str.563 = private unnamed_addr constant [5 x i8] c"size\00", align 1
@os_getrandom._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_getrandom._keywords, ptr @.str.170, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_getrandom._kwtuple, i64 16), ptr null }, align 8
@os_memfd_create._kwtuple = internal global %struct.anon.859 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 2 }, [2 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 52416), ptr getelementptr (i8, ptr @_PyRuntime, i64 45864)] }, align 8
@os_memfd_create._keywords = internal constant [3 x ptr] [ptr @.str.549, ptr @.str.257, ptr null], align 16
@os_memfd_create._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_memfd_create._keywords, ptr @.str.171, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_memfd_create._kwtuple, i64 16), ptr null }, align 8
@os_eventfd._kwtuple = internal global %struct.anon.860 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 2 }, [2 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 48280), ptr getelementptr (i8, ptr @_PyRuntime, i64 45864)] }, align 8
@os_eventfd._keywords = internal constant [3 x ptr] [ptr @.str.564, ptr @.str.257, ptr null], align 16
@.str.564 = private unnamed_addr constant [8 x i8] c"initval\00", align 1
@os_eventfd._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_eventfd._keywords, ptr @.str.172, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_eventfd._kwtuple, i64 16), ptr null }, align 8
@os_eventfd_read._kwtuple = internal global %struct.anon.861 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 1 }, [1 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 45144)] }, align 8
@os_eventfd_read._keywords = internal constant [2 x ptr] [ptr @.str.208, ptr null], align 16
@os_eventfd_read._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_eventfd_read._keywords, ptr @.str.173, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_eventfd_read._kwtuple, i64 16), ptr null }, align 8
@os_eventfd_write._kwtuple = internal global %struct.anon.862 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 2 }, [2 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 45144), ptr getelementptr (i8, ptr @_PyRuntime, i64 61592)] }, align 8
@os_eventfd_write._keywords = internal constant [3 x ptr] [ptr @.str.208, ptr @.str.557, ptr null], align 16
@os_eventfd_write._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_eventfd_write._keywords, ptr @.str.174, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_eventfd_write._kwtuple, i64 16), ptr null }, align 8
@os_waitstatus_to_exitcode._kwtuple = internal global %struct.anon.863 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 1 }, [1 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 59064)] }, align 8
@os_waitstatus_to_exitcode._keywords = internal constant [2 x ptr] [ptr @.str.277, ptr null], align 16
@os_waitstatus_to_exitcode._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_waitstatus_to_exitcode._keywords, ptr @.str.175, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_waitstatus_to_exitcode._kwtuple, i64 16), ptr null }, align 8
@.str.565 = private unnamed_addr constant [24 x i8] c"invalid WEXITSTATUS: %i\00", align 1
@.str.566 = private unnamed_addr constant [21 x i8] c"invalid WTERMSIG: %i\00", align 1
@.str.567 = private unnamed_addr constant [41 x i8] c"process stopped by delivery of signal %i\00", align 1
@.str.568 = private unnamed_addr constant [24 x i8] c"invalid wait status: %i\00", align 1
@os_setns._kwtuple = internal global %struct.anon.864 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 2 }, [2 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 45144), ptr getelementptr (i8, ptr @_PyRuntime, i64 53208)] }, align 8
@os_setns._keywords = internal constant [3 x ptr] [ptr @.str.208, ptr @.str.569, ptr null], align 16
@.str.569 = private unnamed_addr constant [7 x i8] c"nstype\00", align 1
@os_setns._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_setns._keywords, ptr @.str.176, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_setns._kwtuple, i64 16), ptr null }, align 8
@os_unshare._kwtuple = internal global %struct.anon.865 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 1 }, [1 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 45864)] }, align 8
@os_unshare._keywords = internal constant [2 x ptr] [ptr @.str.257, ptr null], align 16
@os_unshare._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_unshare._keywords, ptr @.str.177, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_unshare._kwtuple, i64 16), ptr null }, align 8
@os_timerfd_create._kwtuple = internal global %struct.anon.866 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 1 }, [1 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 45864)] }, align 8
@os_timerfd_create._keywords = internal constant [3 x ptr] [ptr @.str.187, ptr @.str.257, ptr null], align 16
@os_timerfd_create._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_timerfd_create._keywords, ptr @.str.178, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_timerfd_create._kwtuple, i64 16), ptr null }, align 8
@os_timerfd_settime._kwtuple = internal global %struct.anon.867 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 3 }, [3 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 45864), ptr getelementptr (i8, ptr @_PyRuntime, i64 48120), ptr getelementptr (i8, ptr @_PyRuntime, i64 48704)] }, align 8
@os_timerfd_settime._keywords = internal constant [5 x ptr] [ptr @.str.187, ptr @.str.257, ptr @.str.570, ptr @.str.571, ptr null], align 16
@.str.570 = private unnamed_addr constant [8 x i8] c"initial\00", align 1
@.str.571 = private unnamed_addr constant [9 x i8] c"interval\00", align 1
@os_timerfd_settime._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_timerfd_settime._keywords, ptr @.str.179, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_timerfd_settime._kwtuple, i64 16), ptr null }, align 8
@PyFloat_Type = external global %struct._typeobject, align 8
@.str.572 = private unnamed_addr constant [22 x i8] c"invalid initial value\00", align 1
@.str.573 = private unnamed_addr constant [23 x i8] c"invalid interval value\00", align 1
@os_timerfd_settime_ns._kwtuple = internal global %struct.anon.868 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 3 }, [3 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 45864), ptr getelementptr (i8, ptr @_PyRuntime, i64 48120), ptr getelementptr (i8, ptr @_PyRuntime, i64 48704)] }, align 8
@os_timerfd_settime_ns._keywords = internal constant [5 x ptr] [ptr @.str.187, ptr @.str.257, ptr @.str.570, ptr @.str.571, ptr null], align 16
@os_timerfd_settime_ns._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_timerfd_settime_ns._keywords, ptr @.str.180, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_timerfd_settime_ns._kwtuple, i64 16), ptr null }, align 8
@.str.574 = private unnamed_addr constant [3 x i8] c"LL\00", align 1
@.str.575 = private unnamed_addr constant [8 x i8] c"environ\00", align 1
@.str.576 = private unnamed_addr constant [6 x i8] c"error\00", align 1
@.str.577 = private unnamed_addr constant [20 x i8] c"posix.waitid_result\00", align 1
@waitid_result_desc = internal global %struct.PyStructSequence_Desc { ptr @.str.578, ptr @waitid_result__doc__, ptr @waitid_result_fields, i32 5 }, align 8
@.str.578 = private unnamed_addr constant [14 x i8] c"waitid_result\00", align 1
@.str.579 = private unnamed_addr constant [15 x i8] c"os.stat_result\00", align 1
@stat_result_desc = internal global %struct.PyStructSequence_Desc { ptr @.str.580, ptr @stat_result__doc__, ptr @stat_result_fields, i32 10 }, align 8
@PyStructSequence_UnnamedField = external constant ptr, align 8
@.str.580 = private unnamed_addr constant [12 x i8] c"stat_result\00", align 1
@.str.581 = private unnamed_addr constant [18 x i8] c"os.statvfs_result\00", align 1
@statvfs_result_desc = internal global %struct.PyStructSequence_Desc { ptr @.str.582, ptr @statvfs_result__doc__, ptr @statvfs_result_fields, i32 10 }, align 8
@.str.582 = private unnamed_addr constant [15 x i8] c"statvfs_result\00", align 1
@.str.583 = private unnamed_addr constant [18 x i8] c"posix.sched_param\00", align 1
@sched_param_desc = internal global %struct.PyStructSequence_Desc { ptr @.str.584, ptr @os_sched_param__doc__, ptr @sched_param_fields, i32 1 }, align 8
@.str.584 = private unnamed_addr constant [12 x i8] c"sched_param\00", align 1
@TerminalSize_desc = internal global %struct.PyStructSequence_Desc { ptr @.str.801, ptr @TerminalSize_docstring, ptr @TerminalSize_fields, i32 2 }, align 8
@.str.585 = private unnamed_addr constant [14 x i8] c"terminal_size\00", align 1
@ScandirIteratorType_spec = internal global %struct.PyType_Spec { ptr @.str.806, i32 104, i32 0, i32 129, ptr @ScandirIteratorType_slots }, align 8
@DirEntryType_spec = internal global %struct.PyType_Spec { ptr @.str.810, i32 72, i32 0, i32 128, ptr @DirEntryType_slots }, align 8
@.str.586 = private unnamed_addr constant [9 x i8] c"DirEntry\00", align 1
@.str.587 = private unnamed_addr constant [19 x i8] c"posix.times_result\00", align 1
@times_result_desc = internal global %struct.PyStructSequence_Desc { ptr @.str.588, ptr @times_result__doc__, ptr @times_result_fields, i32 5 }, align 8
@.str.588 = private unnamed_addr constant [13 x i8] c"times_result\00", align 1
@uname_result_desc = internal global %struct.PyStructSequence_Desc { ptr @.str.831, ptr @uname_result__doc__, ptr @uname_result_fields, i32 5 }, align 8
@.str.589 = private unnamed_addr constant [13 x i8] c"uname_result\00", align 1
@.str.590 = private unnamed_addr constant [8 x i8] c"st_mode\00", align 1
@have_functions = internal constant [32 x %struct.have_function] [%struct.have_function { ptr @.str.842, ptr null }, %struct.have_function { ptr @.str.843, ptr null }, %struct.have_function { ptr @.str.844, ptr @probe_faccessat }, %struct.have_function { ptr @.str.845, ptr null }, %struct.have_function { ptr @.str.846, ptr null }, %struct.have_function { ptr @.str.847, ptr @probe_fchmodat }, %struct.have_function { ptr @.str.848, ptr null }, %struct.have_function { ptr @.str.849, ptr @probe_fchownat }, %struct.have_function { ptr @.str.850, ptr null }, %struct.have_function { ptr @.str.851, ptr @probe_fdopendir }, %struct.have_function { ptr @.str.852, ptr null }, %struct.have_function { ptr @.str.853, ptr @probe_fstatat }, %struct.have_function { ptr @.str.854, ptr null }, %struct.have_function { ptr @.str.855, ptr null }, %struct.have_function { ptr @.str.856, ptr @probe_futimens }, %struct.have_function { ptr @.str.857, ptr null }, %struct.have_function { ptr @.str.858, ptr null }, %struct.have_function { ptr @.str.859, ptr @probe_linkat }, %struct.have_function { ptr @.str.860, ptr null }, %struct.have_function { ptr @.str.861, ptr null }, %struct.have_function { ptr @.str.862, ptr null }, %struct.have_function { ptr @.str.863, ptr null }, %struct.have_function { ptr @.str.864, ptr @probe_mkdirat }, %struct.have_function { ptr @.str.865, ptr @probe_mkfifoat }, %struct.have_function { ptr @.str.866, ptr @probe_mknodat }, %struct.have_function { ptr @.str.867, ptr @probe_openat }, %struct.have_function { ptr @.str.868, ptr @probe_readlinkat }, %struct.have_function { ptr @.str.869, ptr @probe_renameat }, %struct.have_function { ptr @.str.870, ptr @probe_symlinkat }, %struct.have_function { ptr @.str.871, ptr @probe_unlinkat }, %struct.have_function { ptr @.str.872, ptr @probe_utimensat }, %struct.have_function zeroinitializer], align 16
@.str.591 = private unnamed_addr constant [29 x i8] c"cannot read ticks_per_second\00", align 1
@.str.592 = private unnamed_addr constant [16 x i8] c"_have_functions\00", align 1
@.str.593 = private unnamed_addr constant [5 x i8] c"F_OK\00", align 1
@.str.594 = private unnamed_addr constant [5 x i8] c"R_OK\00", align 1
@.str.595 = private unnamed_addr constant [5 x i8] c"W_OK\00", align 1
@.str.596 = private unnamed_addr constant [5 x i8] c"X_OK\00", align 1
@.str.597 = private unnamed_addr constant [12 x i8] c"NGROUPS_MAX\00", align 1
@.str.598 = private unnamed_addr constant [8 x i8] c"TMP_MAX\00", align 1
@.str.599 = private unnamed_addr constant [11 x i8] c"WCONTINUED\00", align 1
@.str.600 = private unnamed_addr constant [8 x i8] c"WNOHANG\00", align 1
@.str.601 = private unnamed_addr constant [10 x i8] c"WUNTRACED\00", align 1
@.str.602 = private unnamed_addr constant [9 x i8] c"O_RDONLY\00", align 1
@.str.603 = private unnamed_addr constant [9 x i8] c"O_WRONLY\00", align 1
@.str.604 = private unnamed_addr constant [7 x i8] c"O_RDWR\00", align 1
@.str.605 = private unnamed_addr constant [9 x i8] c"O_NDELAY\00", align 1
@.str.606 = private unnamed_addr constant [11 x i8] c"O_NONBLOCK\00", align 1
@.str.607 = private unnamed_addr constant [9 x i8] c"O_APPEND\00", align 1
@.str.608 = private unnamed_addr constant [8 x i8] c"O_DSYNC\00", align 1
@.str.609 = private unnamed_addr constant [8 x i8] c"O_RSYNC\00", align 1
@.str.610 = private unnamed_addr constant [7 x i8] c"O_SYNC\00", align 1
@.str.611 = private unnamed_addr constant [9 x i8] c"O_NOCTTY\00", align 1
@.str.612 = private unnamed_addr constant [8 x i8] c"O_CREAT\00", align 1
@.str.613 = private unnamed_addr constant [7 x i8] c"O_EXCL\00", align 1
@.str.614 = private unnamed_addr constant [8 x i8] c"O_TRUNC\00", align 1
@.str.615 = private unnamed_addr constant [12 x i8] c"O_LARGEFILE\00", align 1
@.str.616 = private unnamed_addr constant [7 x i8] c"O_PATH\00", align 1
@.str.617 = private unnamed_addr constant [10 x i8] c"O_TMPFILE\00", align 1
@.str.618 = private unnamed_addr constant [13 x i8] c"PRIO_PROCESS\00", align 1
@.str.619 = private unnamed_addr constant [10 x i8] c"PRIO_PGRP\00", align 1
@.str.620 = private unnamed_addr constant [10 x i8] c"PRIO_USER\00", align 1
@.str.621 = private unnamed_addr constant [10 x i8] c"O_CLOEXEC\00", align 1
@.str.622 = private unnamed_addr constant [10 x i8] c"O_ACCMODE\00", align 1
@.str.623 = private unnamed_addr constant [8 x i8] c"O_FSYNC\00", align 1
@.str.624 = private unnamed_addr constant [10 x i8] c"SEEK_HOLE\00", align 1
@.str.625 = private unnamed_addr constant [10 x i8] c"SEEK_DATA\00", align 1
@.str.626 = private unnamed_addr constant [8 x i8] c"O_ASYNC\00", align 1
@.str.627 = private unnamed_addr constant [9 x i8] c"O_DIRECT\00", align 1
@.str.628 = private unnamed_addr constant [12 x i8] c"O_DIRECTORY\00", align 1
@.str.629 = private unnamed_addr constant [11 x i8] c"O_NOFOLLOW\00", align 1
@.str.630 = private unnamed_addr constant [10 x i8] c"O_NOATIME\00", align 1
@.str.631 = private unnamed_addr constant [6 x i8] c"EX_OK\00", align 1
@.str.632 = private unnamed_addr constant [9 x i8] c"EX_USAGE\00", align 1
@.str.633 = private unnamed_addr constant [11 x i8] c"EX_DATAERR\00", align 1
@.str.634 = private unnamed_addr constant [11 x i8] c"EX_NOINPUT\00", align 1
@.str.635 = private unnamed_addr constant [10 x i8] c"EX_NOUSER\00", align 1
@.str.636 = private unnamed_addr constant [10 x i8] c"EX_NOHOST\00", align 1
@.str.637 = private unnamed_addr constant [15 x i8] c"EX_UNAVAILABLE\00", align 1
@.str.638 = private unnamed_addr constant [12 x i8] c"EX_SOFTWARE\00", align 1
@.str.639 = private unnamed_addr constant [9 x i8] c"EX_OSERR\00", align 1
@.str.640 = private unnamed_addr constant [10 x i8] c"EX_OSFILE\00", align 1
@.str.641 = private unnamed_addr constant [13 x i8] c"EX_CANTCREAT\00", align 1
@.str.642 = private unnamed_addr constant [9 x i8] c"EX_IOERR\00", align 1
@.str.643 = private unnamed_addr constant [12 x i8] c"EX_TEMPFAIL\00", align 1
@.str.644 = private unnamed_addr constant [12 x i8] c"EX_PROTOCOL\00", align 1
@.str.645 = private unnamed_addr constant [10 x i8] c"EX_NOPERM\00", align 1
@.str.646 = private unnamed_addr constant [10 x i8] c"EX_CONFIG\00", align 1
@.str.647 = private unnamed_addr constant [10 x i8] c"ST_RDONLY\00", align 1
@.str.648 = private unnamed_addr constant [10 x i8] c"ST_NOSUID\00", align 1
@.str.649 = private unnamed_addr constant [9 x i8] c"ST_NODEV\00", align 1
@.str.650 = private unnamed_addr constant [10 x i8] c"ST_NOEXEC\00", align 1
@.str.651 = private unnamed_addr constant [15 x i8] c"ST_SYNCHRONOUS\00", align 1
@.str.652 = private unnamed_addr constant [12 x i8] c"ST_MANDLOCK\00", align 1
@.str.653 = private unnamed_addr constant [9 x i8] c"ST_WRITE\00", align 1
@.str.654 = private unnamed_addr constant [10 x i8] c"ST_APPEND\00", align 1
@.str.655 = private unnamed_addr constant [11 x i8] c"ST_NOATIME\00", align 1
@.str.656 = private unnamed_addr constant [14 x i8] c"ST_NODIRATIME\00", align 1
@.str.657 = private unnamed_addr constant [12 x i8] c"ST_RELATIME\00", align 1
@.str.658 = private unnamed_addr constant [13 x i8] c"TFD_NONBLOCK\00", align 1
@.str.659 = private unnamed_addr constant [12 x i8] c"TFD_CLOEXEC\00", align 1
@.str.660 = private unnamed_addr constant [18 x i8] c"TFD_TIMER_ABSTIME\00", align 1
@.str.661 = private unnamed_addr constant [24 x i8] c"TFD_TIMER_CANCEL_ON_SET\00", align 1
@.str.662 = private unnamed_addr constant [18 x i8] c"POSIX_FADV_NORMAL\00", align 1
@.str.663 = private unnamed_addr constant [22 x i8] c"POSIX_FADV_SEQUENTIAL\00", align 1
@.str.664 = private unnamed_addr constant [18 x i8] c"POSIX_FADV_RANDOM\00", align 1
@.str.665 = private unnamed_addr constant [19 x i8] c"POSIX_FADV_NOREUSE\00", align 1
@.str.666 = private unnamed_addr constant [20 x i8] c"POSIX_FADV_WILLNEED\00", align 1
@.str.667 = private unnamed_addr constant [20 x i8] c"POSIX_FADV_DONTNEED\00", align 1
@.str.668 = private unnamed_addr constant [6 x i8] c"P_PID\00", align 1
@.str.669 = private unnamed_addr constant [7 x i8] c"P_PGID\00", align 1
@.str.670 = private unnamed_addr constant [6 x i8] c"P_ALL\00", align 1
@.str.671 = private unnamed_addr constant [8 x i8] c"P_PIDFD\00", align 1
@.str.672 = private unnamed_addr constant [8 x i8] c"WEXITED\00", align 1
@.str.673 = private unnamed_addr constant [8 x i8] c"WNOWAIT\00", align 1
@.str.674 = private unnamed_addr constant [9 x i8] c"WSTOPPED\00", align 1
@.str.675 = private unnamed_addr constant [11 x i8] c"CLD_EXITED\00", align 1
@.str.676 = private unnamed_addr constant [11 x i8] c"CLD_KILLED\00", align 1
@.str.677 = private unnamed_addr constant [11 x i8] c"CLD_DUMPED\00", align 1
@.str.678 = private unnamed_addr constant [12 x i8] c"CLD_TRAPPED\00", align 1
@.str.679 = private unnamed_addr constant [12 x i8] c"CLD_STOPPED\00", align 1
@.str.680 = private unnamed_addr constant [14 x i8] c"CLD_CONTINUED\00", align 1
@.str.681 = private unnamed_addr constant [7 x i8] c"F_LOCK\00", align 1
@.str.682 = private unnamed_addr constant [8 x i8] c"F_TLOCK\00", align 1
@.str.683 = private unnamed_addr constant [8 x i8] c"F_ULOCK\00", align 1
@.str.684 = private unnamed_addr constant [7 x i8] c"F_TEST\00", align 1
@.str.685 = private unnamed_addr constant [10 x i8] c"RWF_DSYNC\00", align 1
@.str.686 = private unnamed_addr constant [10 x i8] c"RWF_HIPRI\00", align 1
@.str.687 = private unnamed_addr constant [9 x i8] c"RWF_SYNC\00", align 1
@.str.688 = private unnamed_addr constant [11 x i8] c"RWF_NOWAIT\00", align 1
@.str.689 = private unnamed_addr constant [11 x i8] c"RWF_APPEND\00", align 1
@.str.690 = private unnamed_addr constant [14 x i8] c"SPLICE_F_MOVE\00", align 1
@.str.691 = private unnamed_addr constant [18 x i8] c"SPLICE_F_NONBLOCK\00", align 1
@.str.692 = private unnamed_addr constant [14 x i8] c"SPLICE_F_MORE\00", align 1
@.str.693 = private unnamed_addr constant [17 x i8] c"POSIX_SPAWN_OPEN\00", align 1
@.str.694 = private unnamed_addr constant [18 x i8] c"POSIX_SPAWN_CLOSE\00", align 1
@.str.695 = private unnamed_addr constant [17 x i8] c"POSIX_SPAWN_DUP2\00", align 1
@.str.696 = private unnamed_addr constant [12 x i8] c"SCHED_OTHER\00", align 1
@.str.697 = private unnamed_addr constant [11 x i8] c"SCHED_FIFO\00", align 1
@.str.698 = private unnamed_addr constant [9 x i8] c"SCHED_RR\00", align 1
@.str.699 = private unnamed_addr constant [12 x i8] c"SCHED_BATCH\00", align 1
@.str.700 = private unnamed_addr constant [11 x i8] c"SCHED_IDLE\00", align 1
@.str.701 = private unnamed_addr constant [20 x i8] c"SCHED_RESET_ON_FORK\00", align 1
@.str.702 = private unnamed_addr constant [9 x i8] c"CLONE_FS\00", align 1
@.str.703 = private unnamed_addr constant [12 x i8] c"CLONE_FILES\00", align 1
@.str.704 = private unnamed_addr constant [12 x i8] c"CLONE_NEWNS\00", align 1
@.str.705 = private unnamed_addr constant [16 x i8] c"CLONE_NEWCGROUP\00", align 1
@.str.706 = private unnamed_addr constant [13 x i8] c"CLONE_NEWUTS\00", align 1
@.str.707 = private unnamed_addr constant [13 x i8] c"CLONE_NEWIPC\00", align 1
@.str.708 = private unnamed_addr constant [14 x i8] c"CLONE_NEWUSER\00", align 1
@.str.709 = private unnamed_addr constant [13 x i8] c"CLONE_NEWPID\00", align 1
@.str.710 = private unnamed_addr constant [13 x i8] c"CLONE_NEWNET\00", align 1
@.str.711 = private unnamed_addr constant [14 x i8] c"CLONE_SYSVSEM\00", align 1
@.str.712 = private unnamed_addr constant [13 x i8] c"CLONE_THREAD\00", align 1
@.str.713 = private unnamed_addr constant [14 x i8] c"CLONE_SIGHAND\00", align 1
@.str.714 = private unnamed_addr constant [9 x i8] c"CLONE_VM\00", align 1
@.str.715 = private unnamed_addr constant [13 x i8] c"XATTR_CREATE\00", align 1
@.str.716 = private unnamed_addr constant [14 x i8] c"XATTR_REPLACE\00", align 1
@.str.717 = private unnamed_addr constant [15 x i8] c"XATTR_SIZE_MAX\00", align 1
@.str.718 = private unnamed_addr constant [10 x i8] c"RTLD_LAZY\00", align 1
@.str.719 = private unnamed_addr constant [9 x i8] c"RTLD_NOW\00", align 1
@.str.720 = private unnamed_addr constant [12 x i8] c"RTLD_GLOBAL\00", align 1
@.str.721 = private unnamed_addr constant [11 x i8] c"RTLD_LOCAL\00", align 1
@.str.722 = private unnamed_addr constant [14 x i8] c"RTLD_NODELETE\00", align 1
@.str.723 = private unnamed_addr constant [12 x i8] c"RTLD_NOLOAD\00", align 1
@.str.724 = private unnamed_addr constant [14 x i8] c"RTLD_DEEPBIND\00", align 1
@.str.725 = private unnamed_addr constant [12 x i8] c"GRND_RANDOM\00", align 1
@.str.726 = private unnamed_addr constant [14 x i8] c"GRND_NONBLOCK\00", align 1
@.str.727 = private unnamed_addr constant [12 x i8] c"MFD_CLOEXEC\00", align 1
@.str.728 = private unnamed_addr constant [18 x i8] c"MFD_ALLOW_SEALING\00", align 1
@.str.729 = private unnamed_addr constant [12 x i8] c"MFD_HUGETLB\00", align 1
@.str.730 = private unnamed_addr constant [15 x i8] c"MFD_HUGE_SHIFT\00", align 1
@.str.731 = private unnamed_addr constant [14 x i8] c"MFD_HUGE_MASK\00", align 1
@.str.732 = private unnamed_addr constant [14 x i8] c"MFD_HUGE_64KB\00", align 1
@.str.733 = private unnamed_addr constant [15 x i8] c"MFD_HUGE_512KB\00", align 1
@.str.734 = private unnamed_addr constant [13 x i8] c"MFD_HUGE_1MB\00", align 1
@.str.735 = private unnamed_addr constant [13 x i8] c"MFD_HUGE_2MB\00", align 1
@.str.736 = private unnamed_addr constant [13 x i8] c"MFD_HUGE_8MB\00", align 1
@.str.737 = private unnamed_addr constant [14 x i8] c"MFD_HUGE_16MB\00", align 1
@.str.738 = private unnamed_addr constant [14 x i8] c"MFD_HUGE_32MB\00", align 1
@.str.739 = private unnamed_addr constant [15 x i8] c"MFD_HUGE_256MB\00", align 1
@.str.740 = private unnamed_addr constant [15 x i8] c"MFD_HUGE_512MB\00", align 1
@.str.741 = private unnamed_addr constant [13 x i8] c"MFD_HUGE_1GB\00", align 1
@.str.742 = private unnamed_addr constant [13 x i8] c"MFD_HUGE_2GB\00", align 1
@.str.743 = private unnamed_addr constant [14 x i8] c"MFD_HUGE_16GB\00", align 1
@.str.744 = private unnamed_addr constant [12 x i8] c"EFD_CLOEXEC\00", align 1
@.str.745 = private unnamed_addr constant [13 x i8] c"EFD_NONBLOCK\00", align 1
@.str.746 = private unnamed_addr constant [14 x i8] c"EFD_SEMAPHORE\00", align 1
@.str.747 = private unnamed_addr constant [15 x i8] c"pathconf_names\00", align 1
@.str.748 = private unnamed_addr constant [14 x i8] c"confstr_names\00", align 1
@.str.749 = private unnamed_addr constant [14 x i8] c"sysconf_names\00", align 1
@waitid_result__doc__ = internal constant [221 x i8] c"waitid_result: Result from waitid.\0A\0AThis object may be accessed either as a tuple of\0A  (si_pid, si_uid, si_signo, si_status, si_code),\0Aor via the attributes si_pid, si_uid, and so on.\0A\0ASee os.waitid for more information.\00", align 16
@waitid_result_fields = internal global [6 x %struct.PyStructSequence_Field] [%struct.PyStructSequence_Field { ptr @.str.750, ptr null }, %struct.PyStructSequence_Field { ptr @.str.751, ptr null }, %struct.PyStructSequence_Field { ptr @.str.752, ptr null }, %struct.PyStructSequence_Field { ptr @.str.753, ptr null }, %struct.PyStructSequence_Field { ptr @.str.754, ptr null }, %struct.PyStructSequence_Field zeroinitializer], align 16
@.str.750 = private unnamed_addr constant [7 x i8] c"si_pid\00", align 1
@.str.751 = private unnamed_addr constant [7 x i8] c"si_uid\00", align 1
@.str.752 = private unnamed_addr constant [9 x i8] c"si_signo\00", align 1
@.str.753 = private unnamed_addr constant [10 x i8] c"si_status\00", align 1
@.str.754 = private unnamed_addr constant [8 x i8] c"si_code\00", align 1
@stat_result__doc__ = internal constant [398 x i8] c"stat_result: Result from stat, fstat, or lstat.\0A\0AThis object may be accessed either as a tuple of\0A  (mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime)\0Aor via the attributes st_mode, st_ino, st_dev, st_nlink, st_uid, and so on.\0A\0APosix/windows: If your platform supports st_blksize, st_blocks, st_rdev,\0Aor st_flags, they are available as attributes only.\0A\0ASee os.stat for more information.\00", align 16
@stat_result_fields = internal global [20 x %struct.PyStructSequence_Field] [%struct.PyStructSequence_Field { ptr @.str.590, ptr @.str.755 }, %struct.PyStructSequence_Field { ptr @.str.756, ptr @.str.757 }, %struct.PyStructSequence_Field { ptr @.str.758, ptr @.str.355 }, %struct.PyStructSequence_Field { ptr @.str.759, ptr @.str.760 }, %struct.PyStructSequence_Field { ptr @.str.761, ptr @.str.762 }, %struct.PyStructSequence_Field { ptr @.str.763, ptr @.str.764 }, %struct.PyStructSequence_Field { ptr @.str.765, ptr @.str.766 }, %struct.PyStructSequence_Field { ptr null, ptr @.str.767 }, %struct.PyStructSequence_Field { ptr null, ptr @.str.768 }, %struct.PyStructSequence_Field { ptr null, ptr @.str.769 }, %struct.PyStructSequence_Field { ptr @.str.770, ptr @.str.771 }, %struct.PyStructSequence_Field { ptr @.str.772, ptr @.str.773 }, %struct.PyStructSequence_Field { ptr @.str.774, ptr @.str.775 }, %struct.PyStructSequence_Field { ptr @.str.776, ptr @.str.777 }, %struct.PyStructSequence_Field { ptr @.str.778, ptr @.str.779 }, %struct.PyStructSequence_Field { ptr @.str.780, ptr @.str.781 }, %struct.PyStructSequence_Field { ptr @.str.782, ptr @.str.783 }, %struct.PyStructSequence_Field { ptr @.str.784, ptr @.str.785 }, %struct.PyStructSequence_Field { ptr @.str.786, ptr @.str.787 }, %struct.PyStructSequence_Field zeroinitializer], align 16
@.str.755 = private unnamed_addr constant [16 x i8] c"protection bits\00", align 1
@.str.756 = private unnamed_addr constant [7 x i8] c"st_ino\00", align 1
@.str.757 = private unnamed_addr constant [6 x i8] c"inode\00", align 1
@.str.758 = private unnamed_addr constant [7 x i8] c"st_dev\00", align 1
@.str.759 = private unnamed_addr constant [9 x i8] c"st_nlink\00", align 1
@.str.760 = private unnamed_addr constant [21 x i8] c"number of hard links\00", align 1
@.str.761 = private unnamed_addr constant [7 x i8] c"st_uid\00", align 1
@.str.762 = private unnamed_addr constant [17 x i8] c"user ID of owner\00", align 1
@.str.763 = private unnamed_addr constant [7 x i8] c"st_gid\00", align 1
@.str.764 = private unnamed_addr constant [18 x i8] c"group ID of owner\00", align 1
@.str.765 = private unnamed_addr constant [8 x i8] c"st_size\00", align 1
@.str.766 = private unnamed_addr constant [21 x i8] c"total size, in bytes\00", align 1
@.str.767 = private unnamed_addr constant [28 x i8] c"integer time of last access\00", align 1
@.str.768 = private unnamed_addr constant [34 x i8] c"integer time of last modification\00", align 1
@.str.769 = private unnamed_addr constant [28 x i8] c"integer time of last change\00", align 1
@.str.770 = private unnamed_addr constant [9 x i8] c"st_atime\00", align 1
@.str.771 = private unnamed_addr constant [20 x i8] c"time of last access\00", align 1
@.str.772 = private unnamed_addr constant [9 x i8] c"st_mtime\00", align 1
@.str.773 = private unnamed_addr constant [26 x i8] c"time of last modification\00", align 1
@.str.774 = private unnamed_addr constant [9 x i8] c"st_ctime\00", align 1
@.str.775 = private unnamed_addr constant [20 x i8] c"time of last change\00", align 1
@.str.776 = private unnamed_addr constant [12 x i8] c"st_atime_ns\00", align 1
@.str.777 = private unnamed_addr constant [35 x i8] c"time of last access in nanoseconds\00", align 1
@.str.778 = private unnamed_addr constant [12 x i8] c"st_mtime_ns\00", align 1
@.str.779 = private unnamed_addr constant [41 x i8] c"time of last modification in nanoseconds\00", align 1
@.str.780 = private unnamed_addr constant [12 x i8] c"st_ctime_ns\00", align 1
@.str.781 = private unnamed_addr constant [35 x i8] c"time of last change in nanoseconds\00", align 1
@.str.782 = private unnamed_addr constant [11 x i8] c"st_blksize\00", align 1
@.str.783 = private unnamed_addr constant [29 x i8] c"blocksize for filesystem I/O\00", align 1
@.str.784 = private unnamed_addr constant [10 x i8] c"st_blocks\00", align 1
@.str.785 = private unnamed_addr constant [27 x i8] c"number of blocks allocated\00", align 1
@.str.786 = private unnamed_addr constant [8 x i8] c"st_rdev\00", align 1
@.str.787 = private unnamed_addr constant [30 x i8] c"device type (if inode device)\00", align 1
@statvfs_result__doc__ = internal constant [287 x i8] c"statvfs_result: Result from statvfs or fstatvfs.\0A\0AThis object may be accessed either as a tuple of\0A  (bsize, frsize, blocks, bfree, bavail, files, ffree, favail, flag, namemax),\0Aor via the attributes f_bsize, f_frsize, f_blocks, f_bfree, and so on.\0A\0ASee os.statvfs for more information.\00", align 16
@statvfs_result_fields = internal global [12 x %struct.PyStructSequence_Field] [%struct.PyStructSequence_Field { ptr @.str.788, ptr null }, %struct.PyStructSequence_Field { ptr @.str.789, ptr null }, %struct.PyStructSequence_Field { ptr @.str.790, ptr null }, %struct.PyStructSequence_Field { ptr @.str.791, ptr null }, %struct.PyStructSequence_Field { ptr @.str.792, ptr null }, %struct.PyStructSequence_Field { ptr @.str.793, ptr null }, %struct.PyStructSequence_Field { ptr @.str.794, ptr null }, %struct.PyStructSequence_Field { ptr @.str.795, ptr null }, %struct.PyStructSequence_Field { ptr @.str.796, ptr null }, %struct.PyStructSequence_Field { ptr @.str.797, ptr null }, %struct.PyStructSequence_Field { ptr @.str.798, ptr null }, %struct.PyStructSequence_Field zeroinitializer], align 16
@.str.788 = private unnamed_addr constant [8 x i8] c"f_bsize\00", align 1
@.str.789 = private unnamed_addr constant [9 x i8] c"f_frsize\00", align 1
@.str.790 = private unnamed_addr constant [9 x i8] c"f_blocks\00", align 1
@.str.791 = private unnamed_addr constant [8 x i8] c"f_bfree\00", align 1
@.str.792 = private unnamed_addr constant [9 x i8] c"f_bavail\00", align 1
@.str.793 = private unnamed_addr constant [8 x i8] c"f_files\00", align 1
@.str.794 = private unnamed_addr constant [8 x i8] c"f_ffree\00", align 1
@.str.795 = private unnamed_addr constant [9 x i8] c"f_favail\00", align 1
@.str.796 = private unnamed_addr constant [7 x i8] c"f_flag\00", align 1
@.str.797 = private unnamed_addr constant [10 x i8] c"f_namemax\00", align 1
@.str.798 = private unnamed_addr constant [7 x i8] c"f_fsid\00", align 1
@os_sched_param__doc__ = internal constant [123 x i8] c"sched_param(sched_priority)\0A--\0A\0ACurrently has only one field: sched_priority\0A\0A  sched_priority\0A    A scheduling parameter.\00", align 16
@sched_param_fields = internal global [2 x %struct.PyStructSequence_Field] [%struct.PyStructSequence_Field { ptr @.str.799, ptr @.str.800 }, %struct.PyStructSequence_Field zeroinitializer], align 16
@.str.799 = private unnamed_addr constant [15 x i8] c"sched_priority\00", align 1
@.str.800 = private unnamed_addr constant [24 x i8] c"the scheduling priority\00", align 1
@os_sched_param._kwtuple = internal global %struct.anon.869 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 1 }, [1 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 57272)] }, align 8
@os_sched_param._keywords = internal constant [2 x ptr] [ptr @.str.799, ptr null], align 16
@os_sched_param._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_sched_param._keywords, ptr @.str.584, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_sched_param._kwtuple, i64 16), ptr null }, align 8
@.str.801 = private unnamed_addr constant [17 x i8] c"os.terminal_size\00", align 1
@TerminalSize_docstring = internal constant [61 x i8] c"A tuple of (columns, lines) for holding terminal window size\00", align 16
@TerminalSize_fields = internal global [3 x %struct.PyStructSequence_Field] [%struct.PyStructSequence_Field { ptr @.str.802, ptr @.str.803 }, %struct.PyStructSequence_Field { ptr @.str.804, ptr @.str.805 }, %struct.PyStructSequence_Field zeroinitializer], align 16
@.str.802 = private unnamed_addr constant [8 x i8] c"columns\00", align 1
@.str.803 = private unnamed_addr constant [43 x i8] c"width of the terminal window in characters\00", align 1
@.str.804 = private unnamed_addr constant [6 x i8] c"lines\00", align 1
@.str.805 = private unnamed_addr constant [44 x i8] c"height of the terminal window in characters\00", align 1
@.str.806 = private unnamed_addr constant [22 x i8] c"posix.ScandirIterator\00", align 1
@ScandirIteratorType_slots = internal global [6 x %struct.PyType_Slot] [%struct.PyType_Slot { i32 52, ptr @ScandirIterator_dealloc }, %struct.PyType_Slot { i32 80, ptr @ScandirIterator_finalize }, %struct.PyType_Slot { i32 62, ptr @PyObject_SelfIter }, %struct.PyType_Slot { i32 63, ptr @ScandirIterator_iternext }, %struct.PyType_Slot { i32 64, ptr @ScandirIterator_methods }, %struct.PyType_Slot zeroinitializer], align 16
@ScandirIterator_methods = internal global [4 x %struct.PyMethodDef] [%struct.PyMethodDef { ptr @.str.808, ptr @ScandirIterator_enter, i32 4, ptr null }, %struct.PyMethodDef { ptr @.str.809, ptr @ScandirIterator_exit, i32 1, ptr null }, %struct.PyMethodDef { ptr @.str.100, ptr @ScandirIterator_close, i32 4, ptr null }, %struct.PyMethodDef zeroinitializer], align 16
@.str.807 = private unnamed_addr constant [29 x i8] c"unclosed scandir iterator %R\00", align 1
@PyExc_Warning = external global ptr, align 8
@.str.808 = private unnamed_addr constant [10 x i8] c"__enter__\00", align 1
@.str.809 = private unnamed_addr constant [9 x i8] c"__exit__\00", align 1
@.str.810 = private unnamed_addr constant [15 x i8] c"posix.DirEntry\00", align 1
@DirEntryType_slots = internal global [5 x %struct.PyType_Slot] [%struct.PyType_Slot { i32 52, ptr @DirEntry_dealloc }, %struct.PyType_Slot { i32 66, ptr @DirEntry_repr }, %struct.PyType_Slot { i32 64, ptr @DirEntry_methods }, %struct.PyType_Slot { i32 72, ptr @DirEntry_members }, %struct.PyType_Slot zeroinitializer], align 16
@DirEntry_methods = internal global [9 x %struct.PyMethodDef] [%struct.PyMethodDef { ptr @.str.812, ptr @os_DirEntry_is_dir, i32 642, ptr @os_DirEntry_is_dir__doc__ }, %struct.PyMethodDef { ptr @.str.813, ptr @os_DirEntry_is_file, i32 642, ptr @os_DirEntry_is_file__doc__ }, %struct.PyMethodDef { ptr @.str.814, ptr @os_DirEntry_is_symlink, i32 642, ptr @os_DirEntry_is_symlink__doc__ }, %struct.PyMethodDef { ptr @.str.815, ptr @os_DirEntry_is_junction, i32 4, ptr @os_DirEntry_is_junction__doc__ }, %struct.PyMethodDef { ptr @.str.12, ptr @os_DirEntry_stat, i32 642, ptr @os_DirEntry_stat__doc__ }, %struct.PyMethodDef { ptr @.str.757, ptr @os_DirEntry_inode, i32 4, ptr @os_DirEntry_inode__doc__ }, %struct.PyMethodDef { ptr @.str.816, ptr @os_DirEntry___fspath__, i32 4, ptr @os_DirEntry___fspath____doc__ }, %struct.PyMethodDef { ptr @.str.817, ptr @Py_GenericAlias, i32 24, ptr @.str.818 }, %struct.PyMethodDef zeroinitializer], align 16
@DirEntry_members = internal global [3 x %struct.PyMemberDef] [%struct.PyMemberDef { ptr @.str.549, i32 16, i64 16, i32 1, ptr @.str.820 }, %struct.PyMemberDef { ptr @.str.183, i32 16, i64 24, i32 1, ptr @.str.821 }, %struct.PyMemberDef zeroinitializer], align 16
@.str.811 = private unnamed_addr constant [14 x i8] c"<DirEntry %R>\00", align 1
@.str.812 = private unnamed_addr constant [7 x i8] c"is_dir\00", align 1
@os_DirEntry_is_dir__doc__ = internal constant [105 x i8] c"is_dir($self, /, *, follow_symlinks=True)\0A--\0A\0AReturn True if the entry is a directory; cached per entry.\00", align 16
@.str.813 = private unnamed_addr constant [8 x i8] c"is_file\00", align 1
@os_DirEntry_is_file__doc__ = internal constant [101 x i8] c"is_file($self, /, *, follow_symlinks=True)\0A--\0A\0AReturn True if the entry is a file; cached per entry.\00", align 16
@.str.814 = private unnamed_addr constant [11 x i8] c"is_symlink\00", align 1
@os_DirEntry_is_symlink__doc__ = internal constant [88 x i8] c"is_symlink($self, /)\0A--\0A\0AReturn True if the entry is a symbolic link; cached per entry.\00", align 16
@.str.815 = private unnamed_addr constant [12 x i8] c"is_junction\00", align 1
@os_DirEntry_is_junction__doc__ = internal constant [84 x i8] c"is_junction($self, /)\0A--\0A\0AReturn True if the entry is a junction; cached per entry.\00", align 16
@os_DirEntry_stat__doc__ = internal constant [103 x i8] c"stat($self, /, *, follow_symlinks=True)\0A--\0A\0AReturn stat_result object for the entry; cached per entry.\00", align 16
@os_DirEntry_inode__doc__ = internal constant [65 x i8] c"inode($self, /)\0A--\0A\0AReturn inode of the entry; cached per entry.\00", align 16
@.str.816 = private unnamed_addr constant [11 x i8] c"__fspath__\00", align 1
@os_DirEntry___fspath____doc__ = internal constant [57 x i8] c"__fspath__($self, /)\0A--\0A\0AReturns the path for the entry.\00", align 16
@.str.817 = private unnamed_addr constant [18 x i8] c"__class_getitem__\00", align 1
@.str.818 = private unnamed_addr constant [12 x i8] c"See PEP 585\00", align 1
@os_DirEntry_is_dir._kwtuple = internal global %struct.anon.870 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 1 }, [1 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 45960)] }, align 8
@os_DirEntry_is_dir._keywords = internal constant [2 x ptr] [ptr @.str.185, ptr null], align 16
@os_DirEntry_is_dir._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_DirEntry_is_dir._keywords, ptr @.str.812, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_DirEntry_is_dir._kwtuple, i64 16), ptr null }, align 8
@PyExc_FileNotFoundError = external global ptr, align 8
@os_DirEntry_is_file._kwtuple = internal global %struct.anon.871 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 1 }, [1 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 45960)] }, align 8
@os_DirEntry_is_file._keywords = internal constant [2 x ptr] [ptr @.str.185, ptr null], align 16
@os_DirEntry_is_file._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_DirEntry_is_file._keywords, ptr @.str.813, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_DirEntry_is_file._kwtuple, i64 16), ptr null }, align 8
@.str.819 = private unnamed_addr constant [32 x i8] c"is_symlink() takes no arguments\00", align 1
@os_DirEntry_stat._kwtuple = internal global %struct.anon.872 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon { i64 4294967295 }, ptr @PyTuple_Type }, i64 1 }, [1 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 45960)] }, align 8
@os_DirEntry_stat._keywords = internal constant [2 x ptr] [ptr @.str.185, ptr null], align 16
@os_DirEntry_stat._parser = internal global %struct._PyArg_Parser { ptr null, ptr @os_DirEntry_stat._keywords, ptr @.str.12, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @os_DirEntry_stat._kwtuple, i64 16), ptr null }, align 8
@.str.820 = private unnamed_addr constant [65 x i8] c"the entry's base filename, relative to scandir() \22path\22 argument\00", align 1
@.str.821 = private unnamed_addr constant [81 x i8] c"the entry's full path name; equivalent to os.path.join(scandir_path, entry.name)\00", align 1
@times_result__doc__ = internal constant [264 x i8] c"times_result: Result from os.times().\0A\0AThis object may be accessed either as a tuple of\0A  (user, system, children_user, children_system, elapsed),\0Aor via the attributes user, system, children_user, children_system,\0Aand elapsed.\0A\0ASee os.times for more information.\00", align 16
@times_result_fields = internal global [6 x %struct.PyStructSequence_Field] [%struct.PyStructSequence_Field { ptr @.str.822, ptr @.str.823 }, %struct.PyStructSequence_Field { ptr @.str.41, ptr @.str.824 }, %struct.PyStructSequence_Field { ptr @.str.825, ptr @.str.826 }, %struct.PyStructSequence_Field { ptr @.str.827, ptr @.str.828 }, %struct.PyStructSequence_Field { ptr @.str.829, ptr @.str.830 }, %struct.PyStructSequence_Field zeroinitializer], align 16
@.str.822 = private unnamed_addr constant [5 x i8] c"user\00", align 1
@.str.823 = private unnamed_addr constant [10 x i8] c"user time\00", align 1
@.str.824 = private unnamed_addr constant [12 x i8] c"system time\00", align 1
@.str.825 = private unnamed_addr constant [14 x i8] c"children_user\00", align 1
@.str.826 = private unnamed_addr constant [22 x i8] c"user time of children\00", align 1
@.str.827 = private unnamed_addr constant [16 x i8] c"children_system\00", align 1
@.str.828 = private unnamed_addr constant [24 x i8] c"system time of children\00", align 1
@.str.829 = private unnamed_addr constant [8 x i8] c"elapsed\00", align 1
@.str.830 = private unnamed_addr constant [50 x i8] c"elapsed time since an arbitrary point in the past\00", align 1
@.str.831 = private unnamed_addr constant [19 x i8] c"posix.uname_result\00", align 1
@uname_result__doc__ = internal constant [246 x i8] c"uname_result: Result from os.uname().\0A\0AThis object may be accessed either as a tuple of\0A  (sysname, nodename, release, version, machine),\0Aor via the attributes sysname, nodename, release, version, and machine.\0A\0ASee os.uname for more information.\00", align 16
@uname_result_fields = internal global [6 x %struct.PyStructSequence_Field] [%struct.PyStructSequence_Field { ptr @.str.832, ptr @.str.833 }, %struct.PyStructSequence_Field { ptr @.str.834, ptr @.str.835 }, %struct.PyStructSequence_Field { ptr @.str.836, ptr @.str.837 }, %struct.PyStructSequence_Field { ptr @.str.838, ptr @.str.839 }, %struct.PyStructSequence_Field { ptr @.str.840, ptr @.str.841 }, %struct.PyStructSequence_Field zeroinitializer], align 16
@.str.832 = private unnamed_addr constant [8 x i8] c"sysname\00", align 1
@.str.833 = private unnamed_addr constant [22 x i8] c"operating system name\00", align 1
@.str.834 = private unnamed_addr constant [9 x i8] c"nodename\00", align 1
@.str.835 = private unnamed_addr constant [52 x i8] c"name of machine on network (implementation-defined)\00", align 1
@.str.836 = private unnamed_addr constant [8 x i8] c"release\00", align 1
@.str.837 = private unnamed_addr constant [25 x i8] c"operating system release\00", align 1
@.str.838 = private unnamed_addr constant [8 x i8] c"version\00", align 1
@.str.839 = private unnamed_addr constant [25 x i8] c"operating system version\00", align 1
@.str.840 = private unnamed_addr constant [8 x i8] c"machine\00", align 1
@.str.841 = private unnamed_addr constant [20 x i8] c"hardware identifier\00", align 1
@.str.842 = private unnamed_addr constant [13 x i8] c"HAVE_EVENTFD\00", align 1
@.str.843 = private unnamed_addr constant [20 x i8] c"HAVE_TIMERFD_CREATE\00", align 1
@.str.844 = private unnamed_addr constant [15 x i8] c"HAVE_FACCESSAT\00", align 1
@.str.845 = private unnamed_addr constant [12 x i8] c"HAVE_FCHDIR\00", align 1
@.str.846 = private unnamed_addr constant [12 x i8] c"HAVE_FCHMOD\00", align 1
@.str.847 = private unnamed_addr constant [14 x i8] c"HAVE_FCHMODAT\00", align 1
@.str.848 = private unnamed_addr constant [12 x i8] c"HAVE_FCHOWN\00", align 1
@.str.849 = private unnamed_addr constant [14 x i8] c"HAVE_FCHOWNAT\00", align 1
@.str.850 = private unnamed_addr constant [13 x i8] c"HAVE_FEXECVE\00", align 1
@.str.851 = private unnamed_addr constant [15 x i8] c"HAVE_FDOPENDIR\00", align 1
@.str.852 = private unnamed_addr constant [15 x i8] c"HAVE_FPATHCONF\00", align 1
@.str.853 = private unnamed_addr constant [13 x i8] c"HAVE_FSTATAT\00", align 1
@.str.854 = private unnamed_addr constant [14 x i8] c"HAVE_FSTATVFS\00", align 1
@.str.855 = private unnamed_addr constant [15 x i8] c"HAVE_FTRUNCATE\00", align 1
@.str.856 = private unnamed_addr constant [14 x i8] c"HAVE_FUTIMENS\00", align 1
@.str.857 = private unnamed_addr constant [13 x i8] c"HAVE_FUTIMES\00", align 1
@.str.858 = private unnamed_addr constant [15 x i8] c"HAVE_FUTIMESAT\00", align 1
@.str.859 = private unnamed_addr constant [12 x i8] c"HAVE_LINKAT\00", align 1
@.str.860 = private unnamed_addr constant [12 x i8] c"HAVE_LCHOWN\00", align 1
@.str.861 = private unnamed_addr constant [11 x i8] c"HAVE_LSTAT\00", align 1
@.str.862 = private unnamed_addr constant [13 x i8] c"HAVE_LUTIMES\00", align 1
@.str.863 = private unnamed_addr constant [18 x i8] c"HAVE_MEMFD_CREATE\00", align 1
@.str.864 = private unnamed_addr constant [13 x i8] c"HAVE_MKDIRAT\00", align 1
@.str.865 = private unnamed_addr constant [14 x i8] c"HAVE_MKFIFOAT\00", align 1
@.str.866 = private unnamed_addr constant [13 x i8] c"HAVE_MKNODAT\00", align 1
@.str.867 = private unnamed_addr constant [12 x i8] c"HAVE_OPENAT\00", align 1
@.str.868 = private unnamed_addr constant [16 x i8] c"HAVE_READLINKAT\00", align 1
@.str.869 = private unnamed_addr constant [14 x i8] c"HAVE_RENAMEAT\00", align 1
@.str.870 = private unnamed_addr constant [15 x i8] c"HAVE_SYMLINKAT\00", align 1
@.str.871 = private unnamed_addr constant [14 x i8] c"HAVE_UNLINKAT\00", align 1
@.str.872 = private unnamed_addr constant [15 x i8] c"HAVE_UTIMENSAT\00", align 1

; Function Attrs: nounwind uwtable
define dso_local void @PyOS_BeforeFork() #0 {
entry:
  %interp = alloca ptr, align 8
  %call = call ptr @_PyInterpreterState_GET()
  store ptr %call, ptr %interp, align 8
  %0 = load ptr, ptr %interp, align 8
  %before_forkers = getelementptr inbounds %struct._is, ptr %0, i32 0, i32 33
  %1 = load ptr, ptr %before_forkers, align 8
  call void @run_at_forkers(ptr noundef %1, i32 noundef 1)
  %2 = load ptr, ptr %interp, align 8
  call void @_PyImport_AcquireLock(ptr noundef %2)
  ret void
}

; Function Attrs: nounwind uwtable
define internal ptr @_PyInterpreterState_GET() #0 {
entry:
  %tstate = alloca ptr, align 8
  %call = call ptr @_PyThreadState_GET()
  store ptr %call, ptr %tstate, align 8
  %0 = load ptr, ptr %tstate, align 8
  %interp = getelementptr inbounds %struct._ts, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %interp, align 8
  ret ptr %1
}

; Function Attrs: nounwind uwtable
define internal void @run_at_forkers(ptr noundef %lst, i32 noundef %reverse) #0 {
entry:
  %op.addr.i26 = alloca ptr, align 8
  %op.addr.i24 = alloca ptr, align 8
  %op.addr.i15 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %lst.addr = alloca ptr, align 8
  %reverse.addr = alloca i32, align 4
  %i = alloca i64, align 8
  %cpy = alloca ptr, align 8
  %func = alloca ptr, align 8
  %res = alloca ptr, align 8
  store ptr %lst, ptr %lst.addr, align 8
  store i32 %reverse, ptr %reverse.addr, align 4
  %0 = load ptr, ptr %lst.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %if.then, label %if.end14

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %lst.addr, align 8
  %2 = load ptr, ptr %lst.addr, align 8
  %call = call i64 @PyList_GET_SIZE(ptr noundef %2)
  %call1 = call ptr @PyList_GetSlice(ptr noundef %1, i64 noundef 0, i64 noundef %call)
  store ptr %call1, ptr %cpy, align 8
  %3 = load ptr, ptr %cpy, align 8
  %cmp2 = icmp eq ptr %3, null
  br i1 %cmp2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.then
  %4 = load ptr, ptr %lst.addr, align 8
  call void @PyErr_WriteUnraisable(ptr noundef %4)
  br label %if.end13

if.else:                                          ; preds = %if.then
  %5 = load i32, ptr %reverse.addr, align 4
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.else
  %6 = load ptr, ptr %cpy, align 8
  %call5 = call i32 @PyList_Reverse(ptr noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.else
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %7 = load i64, ptr %i, align 8
  %8 = load ptr, ptr %cpy, align 8
  %call6 = call i64 @PyList_GET_SIZE(ptr noundef %8)
  %cmp7 = icmp slt i64 %7, %call6
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load ptr, ptr %cpy, align 8
  %ob_item = getelementptr inbounds %struct.PyListObject, ptr %9, i32 0, i32 1
  %10 = load ptr, ptr %ob_item, align 8
  %11 = load i64, ptr %i, align 8
  %arrayidx = getelementptr ptr, ptr %10, i64 %11
  %12 = load ptr, ptr %arrayidx, align 8
  store ptr %12, ptr %func, align 8
  %13 = load ptr, ptr %func, align 8
  %call8 = call ptr @_PyObject_CallNoArgs(ptr noundef %13)
  store ptr %call8, ptr %res, align 8
  %14 = load ptr, ptr %res, align 8
  %cmp9 = icmp eq ptr %14, null
  br i1 %cmp9, label %if.then10, label %if.else11

if.then10:                                        ; preds = %for.body
  %15 = load ptr, ptr %func, align 8
  call void @PyErr_WriteUnraisable(ptr noundef %15)
  br label %if.end12

if.else11:                                        ; preds = %for.body
  %16 = load ptr, ptr %res, align 8
  store ptr %16, ptr %op.addr.i15, align 8
  %17 = load ptr, ptr %op.addr.i15, align 8
  store ptr %17, ptr %op.addr.i24, align 8
  %18 = load ptr, ptr %op.addr.i24, align 8
  %19 = load i64, ptr %18, align 8
  %conv.i = trunc i64 %19 to i32
  %cmp.i25 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i25 to i32
  %tobool.i17 = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i17, label %if.then.i22, label %if.end.i18

if.then.i22:                                      ; preds = %if.else11
  br label %Py_DECREF.exit23

if.end.i18:                                       ; preds = %if.else11
  %20 = load ptr, ptr %op.addr.i15, align 8
  %21 = load i64, ptr %20, align 8
  %dec.i19 = add i64 %21, -1
  store i64 %dec.i19, ptr %20, align 8
  %cmp.i20 = icmp eq i64 %dec.i19, 0
  br i1 %cmp.i20, label %if.then1.i21, label %Py_DECREF.exit23

if.then1.i21:                                     ; preds = %if.end.i18
  %22 = load ptr, ptr %op.addr.i15, align 8
  call void @_Py_Dealloc(ptr noundef %22) #10
  br label %Py_DECREF.exit23

Py_DECREF.exit23:                                 ; preds = %if.then1.i21, %if.end.i18, %if.then.i22
  br label %if.end12

if.end12:                                         ; preds = %Py_DECREF.exit23, %if.then10
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %23 = load i64, ptr %i, align 8
  %inc = add i64 %23, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !5

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %cpy, align 8
  store ptr %24, ptr %op.addr.i, align 8
  %25 = load ptr, ptr %op.addr.i, align 8
  store ptr %25, ptr %op.addr.i26, align 8
  %26 = load ptr, ptr %op.addr.i26, align 8
  %27 = load i64, ptr %26, align 8
  %conv.i27 = trunc i64 %27 to i32
  %cmp.i28 = icmp slt i32 %conv.i27, 0
  %conv1.i29 = zext i1 %cmp.i28 to i32
  %tobool.i = icmp ne i32 %conv1.i29, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %for.end
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %for.end
  %28 = load ptr, ptr %op.addr.i, align 8
  %29 = load i64, ptr %28, align 8
  %dec.i = add i64 %29, -1
  store i64 %dec.i, ptr %28, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %30 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %30) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  br label %if.end13

if.end13:                                         ; preds = %Py_DECREF.exit, %if.then3
  br label %if.end14

if.end14:                                         ; preds = %if.end13, %entry
  ret void
}

declare void @_PyImport_AcquireLock(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @PyOS_AfterFork_Parent() #0 {
entry:
  %interp = alloca ptr, align 8
  %call = call ptr @_PyInterpreterState_GET()
  store ptr %call, ptr %interp, align 8
  %0 = load ptr, ptr %interp, align 8
  %call1 = call i32 @_PyImport_ReleaseLock(ptr noundef %0)
  %cmp = icmp sle i32 %call1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @_Py_FatalErrorFunc(ptr noundef @__func__.PyOS_AfterFork_Parent, ptr noundef @.str) #11
  unreachable

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %interp, align 8
  %after_forkers_parent = getelementptr inbounds %struct._is, ptr %1, i32 0, i32 34
  %2 = load ptr, ptr %after_forkers_parent, align 8
  call void @run_at_forkers(ptr noundef %2, i32 noundef 0)
  ret void
}

declare i32 @_PyImport_ReleaseLock(ptr noundef) #1

; Function Attrs: noreturn
declare void @_Py_FatalErrorFunc(ptr noundef, ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @PyOS_AfterFork_Child() #0 {
entry:
  %status = alloca %struct.PyStatus, align 8
  %runtime = alloca ptr, align 8
  %tmp = alloca %struct.PyStatus, align 8
  %tstate = alloca ptr, align 8
  %tmp2 = alloca %struct.PyStatus, align 8
  %tmp7 = alloca %struct.PyStatus, align 8
  %tmp12 = alloca %struct.PyStatus, align 8
  %tmp17 = alloca %struct.PyStatus, align 8
  store ptr @_PyRuntime, ptr %runtime, align 8
  %0 = load ptr, ptr %runtime, align 8
  call void @_PyRuntimeState_ReInitThreads(ptr sret(%struct.PyStatus) align 8 %tmp, ptr noundef %0)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %status, ptr align 8 %tmp, i64 32, i1 false)
  %_type = getelementptr inbounds %struct.PyStatus, ptr %status, i32 0, i32 0
  %1 = load i32, ptr %_type, align 8
  %cmp = icmp ne i32 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %fatal_error

if.end:                                           ; preds = %entry
  %call = call ptr @_PyThreadState_GET()
  store ptr %call, ptr %tstate, align 8
  %2 = load ptr, ptr %tstate, align 8
  call void @_Py_EnsureFuncTstateNotNULL(ptr noundef @__func__.PyOS_AfterFork_Child, ptr noundef %2)
  %call1 = call i64 @PyThread_get_thread_native_id()
  %3 = load ptr, ptr %tstate, align 8
  %native_thread_id = getelementptr inbounds %struct._ts, ptr %3, i32 0, i32 23
  store i64 %call1, ptr %native_thread_id, align 8
  %4 = load ptr, ptr %tstate, align 8
  call void @_PyEval_ReInitThreads(ptr sret(%struct.PyStatus) align 8 %tmp2, ptr noundef %4)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %status, ptr align 8 %tmp2, i64 32, i1 false)
  %_type3 = getelementptr inbounds %struct.PyStatus, ptr %status, i32 0, i32 0
  %5 = load i32, ptr %_type3, align 8
  %cmp4 = icmp ne i32 %5, 0
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end
  br label %fatal_error

if.end6:                                          ; preds = %if.end
  %6 = load ptr, ptr %tstate, align 8
  %interp = getelementptr inbounds %struct._ts, ptr %6, i32 0, i32 2
  %7 = load ptr, ptr %interp, align 8
  call void @_PyImport_ReInitLock(ptr sret(%struct.PyStatus) align 8 %tmp7, ptr noundef %7)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %status, ptr align 8 %tmp7, i64 32, i1 false)
  %_type8 = getelementptr inbounds %struct.PyStatus, ptr %status, i32 0, i32 0
  %8 = load i32, ptr %_type8, align 8
  %cmp9 = icmp ne i32 %8, 0
  br i1 %cmp9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end6
  br label %fatal_error

if.end11:                                         ; preds = %if.end6
  call void @_PySignal_AfterFork()
  %9 = load ptr, ptr %runtime, align 8
  call void @_PyInterpreterState_DeleteExceptMain(ptr sret(%struct.PyStatus) align 8 %tmp12, ptr noundef %9)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %status, ptr align 8 %tmp12, i64 32, i1 false)
  %_type13 = getelementptr inbounds %struct.PyStatus, ptr %status, i32 0, i32 0
  %10 = load i32, ptr %_type13, align 8
  %cmp14 = icmp ne i32 %10, 0
  br i1 %cmp14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.end11
  br label %fatal_error

if.end16:                                         ; preds = %if.end11
  call void @_PyPerfTrampoline_AfterFork_Child(ptr sret(%struct.PyStatus) align 8 %tmp17)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %status, ptr align 8 %tmp17, i64 32, i1 false)
  %_type18 = getelementptr inbounds %struct.PyStatus, ptr %status, i32 0, i32 0
  %11 = load i32, ptr %_type18, align 8
  %cmp19 = icmp ne i32 %11, 0
  br i1 %cmp19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %if.end16
  br label %fatal_error

if.end21:                                         ; preds = %if.end16
  %12 = load ptr, ptr %tstate, align 8
  %interp22 = getelementptr inbounds %struct._ts, ptr %12, i32 0, i32 2
  %13 = load ptr, ptr %interp22, align 8
  %after_forkers_child = getelementptr inbounds %struct._is, ptr %13, i32 0, i32 35
  %14 = load ptr, ptr %after_forkers_child, align 8
  call void @run_at_forkers(ptr noundef %14, i32 noundef 0)
  ret void

fatal_error:                                      ; preds = %if.then20, %if.then15, %if.then10, %if.then5, %if.then
  call void @Py_ExitStatusException(ptr noundef byval(%struct.PyStatus) align 8 %status) #11
  unreachable
}

declare void @_PyRuntimeState_ReInitThreads(ptr sret(%struct.PyStatus) align 8, ptr noundef) #1

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #3

; Function Attrs: nounwind uwtable
define internal ptr @_PyThreadState_GET() #0 {
entry:
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @_Py_tss_tstate)
  %1 = load ptr, ptr %0, align 8
  ret ptr %1
}

; Function Attrs: nounwind uwtable
define internal void @_Py_EnsureFuncTstateNotNULL(ptr noundef %func, ptr noundef %tstate) #0 {
entry:
  %func.addr = alloca ptr, align 8
  %tstate.addr = alloca ptr, align 8
  store ptr %func, ptr %func.addr, align 8
  store ptr %tstate, ptr %tstate.addr, align 8
  %0 = load ptr, ptr %tstate.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %func.addr, align 8
  call void @_Py_FatalErrorFunc(ptr noundef %1, ptr noundef @.str.10) #11
  unreachable

if.end:                                           ; preds = %entry
  ret void
}

declare i64 @PyThread_get_thread_native_id() #1

declare void @_PyEval_ReInitThreads(ptr sret(%struct.PyStatus) align 8, ptr noundef) #1

declare void @_PyImport_ReInitLock(ptr sret(%struct.PyStatus) align 8, ptr noundef) #1

declare void @_PySignal_AfterFork() #1

declare void @_PyInterpreterState_DeleteExceptMain(ptr sret(%struct.PyStatus) align 8, ptr noundef) #1

declare void @_PyPerfTrampoline_AfterFork_Child(ptr sret(%struct.PyStatus) align 8) #1

; Function Attrs: noreturn
declare void @Py_ExitStatusException(ptr noundef byval(%struct.PyStatus) align 8) #2

; Function Attrs: nounwind uwtable
define dso_local void @PyOS_AfterFork() #0 {
entry:
  call void @PyOS_AfterFork_Child()
  ret void
}

; Function Attrs: nounwind uwtable
define hidden ptr @_PyLong_FromUid(i32 noundef %uid) #0 {
entry:
  %retval = alloca ptr, align 8
  %uid.addr = alloca i32, align 4
  store i32 %uid, ptr %uid.addr, align 4
  %0 = load i32, ptr %uid.addr, align 4
  %cmp = icmp eq i32 %0, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call ptr @PyLong_FromLong(i64 noundef -1)
  store ptr %call, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, ptr %uid.addr, align 4
  %conv = zext i32 %1 to i64
  %call1 = call ptr @PyLong_FromUnsignedLong(i64 noundef %conv)
  store ptr %call1, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load ptr, ptr %retval, align 8
  ret ptr %2
}

declare ptr @PyLong_FromLong(i64 noundef) #1

declare ptr @PyLong_FromUnsignedLong(i64 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @_PyLong_FromGid(i32 noundef %gid) #0 {
entry:
  %retval = alloca ptr, align 8
  %gid.addr = alloca i32, align 4
  store i32 %gid, ptr %gid.addr, align 4
  %0 = load i32, ptr %gid.addr, align 4
  %cmp = icmp eq i32 %0, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call ptr @PyLong_FromLong(i64 noundef -1)
  store ptr %call, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, ptr %gid.addr, align 4
  %conv = zext i32 %1 to i64
  %call1 = call ptr @PyLong_FromUnsignedLong(i64 noundef %conv)
  store ptr %call1, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load ptr, ptr %retval, align 8
  ret ptr %2
}

; Function Attrs: nounwind uwtable
define dso_local i32 @_Py_Uid_Converter(ptr noundef %obj, ptr noundef %p) #0 {
entry:
  %op.addr.i59 = alloca ptr, align 8
  %op.addr.i57 = alloca ptr, align 8
  %op.addr.i48 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca i32, align 4
  %obj.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %uid = alloca i32, align 4
  %index = alloca ptr, align 8
  %overflow = alloca i32, align 4
  %result = alloca i64, align 8
  %uresult = alloca i64, align 8
  store ptr %obj, ptr %obj.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %obj.addr, align 8
  %call = call ptr @_PyNumber_Index(ptr noundef %0)
  store ptr %call, ptr %index, align 8
  %1 = load ptr, ptr %index, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr @PyExc_TypeError, align 8
  %3 = load ptr, ptr %obj.addr, align 8
  %call1 = call ptr @Py_TYPE(ptr noundef %3)
  %call2 = call ptr @_PyType_Name(ptr noundef %call1)
  %call3 = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %2, ptr noundef @.str.1, ptr noundef %call2)
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %index, align 8
  %call4 = call i64 @PyLong_AsLongAndOverflow(ptr noundef %4, ptr noundef %overflow)
  store i64 %call4, ptr %result, align 8
  %5 = load i32, ptr %overflow, align 4
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %if.end23, label %if.then5

if.then5:                                         ; preds = %if.end
  %6 = load i64, ptr %result, align 8
  %conv = trunc i64 %6 to i32
  store i32 %conv, ptr %uid, align 4
  %7 = load i64, ptr %result, align 8
  %cmp6 = icmp eq i64 %7, -1
  br i1 %cmp6, label %if.then8, label %if.end13

if.then8:                                         ; preds = %if.then5
  %call9 = call ptr @PyErr_Occurred()
  %tobool10 = icmp ne ptr %call9, null
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.then8
  br label %fail

if.end12:                                         ; preds = %if.then8
  br label %success

if.end13:                                         ; preds = %if.then5
  %8 = load i64, ptr %result, align 8
  %cmp14 = icmp slt i64 %8, 0
  br i1 %cmp14, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.end13
  br label %underflow

if.end17:                                         ; preds = %if.end13
  %9 = load i32, ptr %uid, align 4
  %conv18 = zext i32 %9 to i64
  %10 = load i64, ptr %result, align 8
  %cmp19 = icmp ne i64 %conv18, %10
  br i1 %cmp19, label %if.then21, label %if.end22

if.then21:                                        ; preds = %if.end17
  br label %underflow

if.end22:                                         ; preds = %if.end17
  br label %success

if.end23:                                         ; preds = %if.end
  %11 = load i32, ptr %overflow, align 4
  %cmp24 = icmp slt i32 %11, 0
  br i1 %cmp24, label %if.then26, label %if.end27

if.then26:                                        ; preds = %if.end23
  br label %underflow

if.end27:                                         ; preds = %if.end23
  %12 = load ptr, ptr %index, align 8
  %call28 = call i64 @PyLong_AsUnsignedLong(ptr noundef %12)
  store i64 %call28, ptr %uresult, align 8
  %call29 = call ptr @PyErr_Occurred()
  %tobool30 = icmp ne ptr %call29, null
  br i1 %tobool30, label %if.then31, label %if.end36

if.then31:                                        ; preds = %if.end27
  %13 = load ptr, ptr @PyExc_OverflowError, align 8
  %call32 = call i32 @PyErr_ExceptionMatches(ptr noundef %13)
  %tobool33 = icmp ne i32 %call32, 0
  br i1 %tobool33, label %if.then34, label %if.end35

if.then34:                                        ; preds = %if.then31
  br label %overflow47

if.end35:                                         ; preds = %if.then31
  br label %fail

if.end36:                                         ; preds = %if.end27
  %14 = load i64, ptr %uresult, align 8
  %conv37 = trunc i64 %14 to i32
  store i32 %conv37, ptr %uid, align 4
  %15 = load i32, ptr %uid, align 4
  %cmp38 = icmp eq i32 %15, -1
  br i1 %cmp38, label %if.then40, label %if.end41

if.then40:                                        ; preds = %if.end36
  br label %overflow47

if.end41:                                         ; preds = %if.end36
  %16 = load i32, ptr %uid, align 4
  %conv42 = zext i32 %16 to i64
  %17 = load i64, ptr %uresult, align 8
  %cmp43 = icmp ne i64 %conv42, %17
  br i1 %cmp43, label %if.then45, label %if.end46

if.then45:                                        ; preds = %if.end41
  br label %overflow47

if.end46:                                         ; preds = %if.end41
  br label %success

success:                                          ; preds = %if.end46, %if.end22, %if.end12
  %18 = load ptr, ptr %index, align 8
  store ptr %18, ptr %op.addr.i48, align 8
  %19 = load ptr, ptr %op.addr.i48, align 8
  store ptr %19, ptr %op.addr.i57, align 8
  %20 = load ptr, ptr %op.addr.i57, align 8
  %21 = load i64, ptr %20, align 8
  %conv.i = trunc i64 %21 to i32
  %cmp.i58 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i58 to i32
  %tobool.i50 = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i50, label %if.then.i55, label %if.end.i51

if.then.i55:                                      ; preds = %success
  br label %Py_DECREF.exit56

if.end.i51:                                       ; preds = %success
  %22 = load ptr, ptr %op.addr.i48, align 8
  %23 = load i64, ptr %22, align 8
  %dec.i52 = add i64 %23, -1
  store i64 %dec.i52, ptr %22, align 8
  %cmp.i53 = icmp eq i64 %dec.i52, 0
  br i1 %cmp.i53, label %if.then1.i54, label %Py_DECREF.exit56

if.then1.i54:                                     ; preds = %if.end.i51
  %24 = load ptr, ptr %op.addr.i48, align 8
  call void @_Py_Dealloc(ptr noundef %24) #10
  br label %Py_DECREF.exit56

Py_DECREF.exit56:                                 ; preds = %if.then1.i54, %if.end.i51, %if.then.i55
  %25 = load i32, ptr %uid, align 4
  %26 = load ptr, ptr %p.addr, align 8
  store i32 %25, ptr %26, align 4
  store i32 1, ptr %retval, align 4
  br label %return

underflow:                                        ; preds = %if.then26, %if.then21, %if.then16
  %27 = load ptr, ptr @PyExc_OverflowError, align 8
  call void @PyErr_SetString(ptr noundef %27, ptr noundef @.str.2)
  br label %fail

overflow47:                                       ; preds = %if.then45, %if.then40, %if.then34
  %28 = load ptr, ptr @PyExc_OverflowError, align 8
  call void @PyErr_SetString(ptr noundef %28, ptr noundef @.str.3)
  br label %fail

fail:                                             ; preds = %overflow47, %underflow, %if.end35, %if.then11
  %29 = load ptr, ptr %index, align 8
  store ptr %29, ptr %op.addr.i, align 8
  %30 = load ptr, ptr %op.addr.i, align 8
  store ptr %30, ptr %op.addr.i59, align 8
  %31 = load ptr, ptr %op.addr.i59, align 8
  %32 = load i64, ptr %31, align 8
  %conv.i60 = trunc i64 %32 to i32
  %cmp.i61 = icmp slt i32 %conv.i60, 0
  %conv1.i62 = zext i1 %cmp.i61 to i32
  %tobool.i = icmp ne i32 %conv1.i62, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %fail
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %fail
  %33 = load ptr, ptr %op.addr.i, align 8
  %34 = load i64, ptr %33, align 8
  %dec.i = add i64 %34, -1
  store i64 %dec.i, ptr %33, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %35 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %35) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %Py_DECREF.exit, %Py_DECREF.exit56, %if.then
  %36 = load i32, ptr %retval, align 4
  ret i32 %36
}

declare ptr @_PyNumber_Index(ptr noundef) #1

declare ptr @PyErr_Format(ptr noundef, ptr noundef, ...) #1

declare ptr @_PyType_Name(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @Py_TYPE(ptr noundef %ob) #0 {
entry:
  %ob.addr = alloca ptr, align 8
  store ptr %ob, ptr %ob.addr, align 8
  %0 = load ptr, ptr %ob.addr, align 8
  %ob_type = getelementptr inbounds %struct._object, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %ob_type, align 8
  ret ptr %1
}

declare i64 @PyLong_AsLongAndOverflow(ptr noundef, ptr noundef) #1

declare ptr @PyErr_Occurred() #1

declare i64 @PyLong_AsUnsignedLong(ptr noundef) #1

declare i32 @PyErr_ExceptionMatches(ptr noundef) #1

declare void @PyErr_SetString(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @_Py_Gid_Converter(ptr noundef %obj, ptr noundef %p) #0 {
entry:
  %op.addr.i59 = alloca ptr, align 8
  %op.addr.i57 = alloca ptr, align 8
  %op.addr.i48 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca i32, align 4
  %obj.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %gid = alloca i32, align 4
  %index = alloca ptr, align 8
  %overflow = alloca i32, align 4
  %result = alloca i64, align 8
  %uresult = alloca i64, align 8
  store ptr %obj, ptr %obj.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %obj.addr, align 8
  %call = call ptr @_PyNumber_Index(ptr noundef %0)
  store ptr %call, ptr %index, align 8
  %1 = load ptr, ptr %index, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr @PyExc_TypeError, align 8
  %3 = load ptr, ptr %obj.addr, align 8
  %call1 = call ptr @Py_TYPE(ptr noundef %3)
  %call2 = call ptr @_PyType_Name(ptr noundef %call1)
  %call3 = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %2, ptr noundef @.str.4, ptr noundef %call2)
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %index, align 8
  %call4 = call i64 @PyLong_AsLongAndOverflow(ptr noundef %4, ptr noundef %overflow)
  store i64 %call4, ptr %result, align 8
  %5 = load i32, ptr %overflow, align 4
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %if.end23, label %if.then5

if.then5:                                         ; preds = %if.end
  %6 = load i64, ptr %result, align 8
  %conv = trunc i64 %6 to i32
  store i32 %conv, ptr %gid, align 4
  %7 = load i64, ptr %result, align 8
  %cmp6 = icmp eq i64 %7, -1
  br i1 %cmp6, label %if.then8, label %if.end13

if.then8:                                         ; preds = %if.then5
  %call9 = call ptr @PyErr_Occurred()
  %tobool10 = icmp ne ptr %call9, null
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.then8
  br label %fail

if.end12:                                         ; preds = %if.then8
  br label %success

if.end13:                                         ; preds = %if.then5
  %8 = load i64, ptr %result, align 8
  %cmp14 = icmp slt i64 %8, 0
  br i1 %cmp14, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.end13
  br label %underflow

if.end17:                                         ; preds = %if.end13
  %9 = load i32, ptr %gid, align 4
  %conv18 = zext i32 %9 to i64
  %10 = load i64, ptr %result, align 8
  %cmp19 = icmp ne i64 %conv18, %10
  br i1 %cmp19, label %if.then21, label %if.end22

if.then21:                                        ; preds = %if.end17
  br label %underflow

if.end22:                                         ; preds = %if.end17
  br label %success

if.end23:                                         ; preds = %if.end
  %11 = load i32, ptr %overflow, align 4
  %cmp24 = icmp slt i32 %11, 0
  br i1 %cmp24, label %if.then26, label %if.end27

if.then26:                                        ; preds = %if.end23
  br label %underflow

if.end27:                                         ; preds = %if.end23
  %12 = load ptr, ptr %index, align 8
  %call28 = call i64 @PyLong_AsUnsignedLong(ptr noundef %12)
  store i64 %call28, ptr %uresult, align 8
  %call29 = call ptr @PyErr_Occurred()
  %tobool30 = icmp ne ptr %call29, null
  br i1 %tobool30, label %if.then31, label %if.end36

if.then31:                                        ; preds = %if.end27
  %13 = load ptr, ptr @PyExc_OverflowError, align 8
  %call32 = call i32 @PyErr_ExceptionMatches(ptr noundef %13)
  %tobool33 = icmp ne i32 %call32, 0
  br i1 %tobool33, label %if.then34, label %if.end35

if.then34:                                        ; preds = %if.then31
  br label %overflow47

if.end35:                                         ; preds = %if.then31
  br label %fail

if.end36:                                         ; preds = %if.end27
  %14 = load i64, ptr %uresult, align 8
  %conv37 = trunc i64 %14 to i32
  store i32 %conv37, ptr %gid, align 4
  %15 = load i32, ptr %gid, align 4
  %cmp38 = icmp eq i32 %15, -1
  br i1 %cmp38, label %if.then40, label %if.end41

if.then40:                                        ; preds = %if.end36
  br label %overflow47

if.end41:                                         ; preds = %if.end36
  %16 = load i32, ptr %gid, align 4
  %conv42 = zext i32 %16 to i64
  %17 = load i64, ptr %uresult, align 8
  %cmp43 = icmp ne i64 %conv42, %17
  br i1 %cmp43, label %if.then45, label %if.end46

if.then45:                                        ; preds = %if.end41
  br label %overflow47

if.end46:                                         ; preds = %if.end41
  br label %success

success:                                          ; preds = %if.end46, %if.end22, %if.end12
  %18 = load ptr, ptr %index, align 8
  store ptr %18, ptr %op.addr.i48, align 8
  %19 = load ptr, ptr %op.addr.i48, align 8
  store ptr %19, ptr %op.addr.i57, align 8
  %20 = load ptr, ptr %op.addr.i57, align 8
  %21 = load i64, ptr %20, align 8
  %conv.i = trunc i64 %21 to i32
  %cmp.i58 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i58 to i32
  %tobool.i50 = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i50, label %if.then.i55, label %if.end.i51

if.then.i55:                                      ; preds = %success
  br label %Py_DECREF.exit56

if.end.i51:                                       ; preds = %success
  %22 = load ptr, ptr %op.addr.i48, align 8
  %23 = load i64, ptr %22, align 8
  %dec.i52 = add i64 %23, -1
  store i64 %dec.i52, ptr %22, align 8
  %cmp.i53 = icmp eq i64 %dec.i52, 0
  br i1 %cmp.i53, label %if.then1.i54, label %Py_DECREF.exit56

if.then1.i54:                                     ; preds = %if.end.i51
  %24 = load ptr, ptr %op.addr.i48, align 8
  call void @_Py_Dealloc(ptr noundef %24) #10
  br label %Py_DECREF.exit56

Py_DECREF.exit56:                                 ; preds = %if.then1.i54, %if.end.i51, %if.then.i55
  %25 = load i32, ptr %gid, align 4
  %26 = load ptr, ptr %p.addr, align 8
  store i32 %25, ptr %26, align 4
  store i32 1, ptr %retval, align 4
  br label %return

underflow:                                        ; preds = %if.then26, %if.then21, %if.then16
  %27 = load ptr, ptr @PyExc_OverflowError, align 8
  call void @PyErr_SetString(ptr noundef %27, ptr noundef @.str.5)
  br label %fail

overflow47:                                       ; preds = %if.then45, %if.then40, %if.then34
  %28 = load ptr, ptr @PyExc_OverflowError, align 8
  call void @PyErr_SetString(ptr noundef %28, ptr noundef @.str.6)
  br label %fail

fail:                                             ; preds = %overflow47, %underflow, %if.end35, %if.then11
  %29 = load ptr, ptr %index, align 8
  store ptr %29, ptr %op.addr.i, align 8
  %30 = load ptr, ptr %op.addr.i, align 8
  store ptr %30, ptr %op.addr.i59, align 8
  %31 = load ptr, ptr %op.addr.i59, align 8
  %32 = load i64, ptr %31, align 8
  %conv.i60 = trunc i64 %32 to i32
  %cmp.i61 = icmp slt i32 %conv.i60, 0
  %conv1.i62 = zext i1 %cmp.i61 to i32
  %tobool.i = icmp ne i32 %conv1.i62, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %fail
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %fail
  %33 = load ptr, ptr %op.addr.i, align 8
  %34 = load i64, ptr %33, align 8
  %dec.i = add i64 %34, -1
  store i64 %dec.i, ptr %33, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %35 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %35) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %Py_DECREF.exit, %Py_DECREF.exit56, %if.then
  %36 = load i32, ptr %retval, align 4
  ret i32 %36
}

; Function Attrs: nounwind uwtable
define hidden i32 @_Py_Sigset_Converter(ptr noundef %obj, ptr noundef %addr) #0 {
entry:
  %op.addr.i63 = alloca ptr, align 8
  %op.addr.i59 = alloca ptr, align 8
  %op.addr.i57 = alloca ptr, align 8
  %op.addr.i48 = alloca ptr, align 8
  %op.addr.i39 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca i32, align 4
  %obj.addr = alloca ptr, align 8
  %addr.addr = alloca ptr, align 8
  %mask = alloca ptr, align 8
  %iterator = alloca ptr, align 8
  %item = alloca ptr, align 8
  %signum = alloca i64, align 8
  %overflow = alloca i32, align 4
  %msg = alloca [54 x i8], align 16
  store ptr %obj, ptr %obj.addr, align 8
  store ptr %addr, ptr %addr.addr, align 8
  %0 = load ptr, ptr %addr.addr, align 8
  store ptr %0, ptr %mask, align 8
  %1 = load ptr, ptr %mask, align 8
  %call = call i32 @sigemptyset(ptr noundef %1) #10
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr @PyExc_OSError, align 8
  %call1 = call ptr @PyErr_SetFromErrno(ptr noundef %2)
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %obj.addr, align 8
  %call2 = call ptr @PyObject_GetIter(ptr noundef %3)
  store ptr %call2, ptr %iterator, align 8
  %4 = load ptr, ptr %iterator, align 8
  %cmp3 = icmp eq ptr %4, null
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  br label %while.cond

while.cond:                                       ; preds = %if.end34, %if.end5
  %5 = load ptr, ptr %iterator, align 8
  %call6 = call ptr @PyIter_Next(ptr noundef %5)
  store ptr %call6, ptr %item, align 8
  %cmp7 = icmp ne ptr %call6, null
  br i1 %cmp7, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %6 = load ptr, ptr %item, align 8
  %call8 = call i64 @PyLong_AsLongAndOverflow(ptr noundef %6, ptr noundef %overflow)
  store i64 %call8, ptr %signum, align 8
  %7 = load ptr, ptr %item, align 8
  store ptr %7, ptr %op.addr.i48, align 8
  %8 = load ptr, ptr %op.addr.i48, align 8
  store ptr %8, ptr %op.addr.i57, align 8
  %9 = load ptr, ptr %op.addr.i57, align 8
  %10 = load i64, ptr %9, align 8
  %conv.i = trunc i64 %10 to i32
  %cmp.i58 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i58 to i32
  %tobool.i50 = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i50, label %if.then.i55, label %if.end.i51

if.then.i55:                                      ; preds = %while.body
  br label %Py_DECREF.exit56

if.end.i51:                                       ; preds = %while.body
  %11 = load ptr, ptr %op.addr.i48, align 8
  %12 = load i64, ptr %11, align 8
  %dec.i52 = add i64 %12, -1
  store i64 %dec.i52, ptr %11, align 8
  %cmp.i53 = icmp eq i64 %dec.i52, 0
  br i1 %cmp.i53, label %if.then1.i54, label %Py_DECREF.exit56

if.then1.i54:                                     ; preds = %if.end.i51
  %13 = load ptr, ptr %op.addr.i48, align 8
  call void @_Py_Dealloc(ptr noundef %13) #10
  br label %Py_DECREF.exit56

Py_DECREF.exit56:                                 ; preds = %if.then1.i54, %if.end.i51, %if.then.i55
  %14 = load i64, ptr %signum, align 8
  %cmp9 = icmp sle i64 %14, 0
  br i1 %cmp9, label %if.then11, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %Py_DECREF.exit56
  %15 = load i64, ptr %signum, align 8
  %cmp10 = icmp sge i64 %15, 65
  br i1 %cmp10, label %if.then11, label %if.end20

if.then11:                                        ; preds = %lor.lhs.false, %Py_DECREF.exit56
  %16 = load i32, ptr %overflow, align 4
  %tobool = icmp ne i32 %16, 0
  br i1 %tobool, label %if.then17, label %lor.lhs.false12

lor.lhs.false12:                                  ; preds = %if.then11
  %17 = load i64, ptr %signum, align 8
  %cmp13 = icmp ne i64 %17, -1
  br i1 %cmp13, label %if.then17, label %lor.lhs.false14

lor.lhs.false14:                                  ; preds = %lor.lhs.false12
  %call15 = call ptr @PyErr_Occurred()
  %tobool16 = icmp ne ptr %call15, null
  br i1 %tobool16, label %if.end19, label %if.then17

if.then17:                                        ; preds = %lor.lhs.false14, %lor.lhs.false12, %if.then11
  %18 = load ptr, ptr @PyExc_ValueError, align 8
  %19 = load i64, ptr %signum, align 8
  %call18 = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %18, ptr noundef @.str.7, i64 noundef %19, i32 noundef 64)
  br label %if.end19

if.end19:                                         ; preds = %if.then17, %lor.lhs.false14
  br label %error

if.end20:                                         ; preds = %lor.lhs.false
  %20 = load ptr, ptr %mask, align 8
  %21 = load i64, ptr %signum, align 8
  %conv = trunc i64 %21 to i32
  %call21 = call i32 @sigaddset(ptr noundef %20, i32 noundef %conv) #10
  %tobool22 = icmp ne i32 %call21, 0
  br i1 %tobool22, label %if.then23, label %if.end34

if.then23:                                        ; preds = %if.end20
  %call24 = call ptr @__errno_location() #12
  %22 = load i32, ptr %call24, align 4
  %cmp25 = icmp ne i32 %22, 22
  br i1 %cmp25, label %if.then27, label %if.end29

if.then27:                                        ; preds = %if.then23
  %23 = load ptr, ptr @PyExc_OSError, align 8
  %call28 = call ptr @PyErr_SetFromErrno(ptr noundef %23)
  br label %error

if.end29:                                         ; preds = %if.then23
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %msg, ptr align 16 @__const._Py_Sigset_Converter.msg, i64 54, i1 false)
  %24 = load ptr, ptr @PyExc_RuntimeWarning, align 8
  %arraydecay = getelementptr inbounds [54 x i8], ptr %msg, i64 0, i64 0
  %25 = load i64, ptr %signum, align 8
  %call30 = call i32 (ptr, i64, ptr, ...) @PyErr_WarnFormat(ptr noundef %24, i64 noundef 1, ptr noundef %arraydecay, i64 noundef %25)
  %tobool31 = icmp ne i32 %call30, 0
  br i1 %tobool31, label %if.then32, label %if.end33

if.then32:                                        ; preds = %if.end29
  br label %error

if.end33:                                         ; preds = %if.end29
  br label %if.end34

if.end34:                                         ; preds = %if.end33, %if.end20
  br label %while.cond, !llvm.loop !7

while.end:                                        ; preds = %while.cond
  %call35 = call ptr @PyErr_Occurred()
  %tobool36 = icmp ne ptr %call35, null
  br i1 %tobool36, label %if.end38, label %if.then37

if.then37:                                        ; preds = %while.end
  %26 = load ptr, ptr %iterator, align 8
  store ptr %26, ptr %op.addr.i39, align 8
  %27 = load ptr, ptr %op.addr.i39, align 8
  store ptr %27, ptr %op.addr.i59, align 8
  %28 = load ptr, ptr %op.addr.i59, align 8
  %29 = load i64, ptr %28, align 8
  %conv.i60 = trunc i64 %29 to i32
  %cmp.i61 = icmp slt i32 %conv.i60, 0
  %conv1.i62 = zext i1 %cmp.i61 to i32
  %tobool.i41 = icmp ne i32 %conv1.i62, 0
  br i1 %tobool.i41, label %if.then.i46, label %if.end.i42

if.then.i46:                                      ; preds = %if.then37
  br label %Py_DECREF.exit47

if.end.i42:                                       ; preds = %if.then37
  %30 = load ptr, ptr %op.addr.i39, align 8
  %31 = load i64, ptr %30, align 8
  %dec.i43 = add i64 %31, -1
  store i64 %dec.i43, ptr %30, align 8
  %cmp.i44 = icmp eq i64 %dec.i43, 0
  br i1 %cmp.i44, label %if.then1.i45, label %Py_DECREF.exit47

if.then1.i45:                                     ; preds = %if.end.i42
  %32 = load ptr, ptr %op.addr.i39, align 8
  call void @_Py_Dealloc(ptr noundef %32) #10
  br label %Py_DECREF.exit47

Py_DECREF.exit47:                                 ; preds = %if.then1.i45, %if.end.i42, %if.then.i46
  store i32 1, ptr %retval, align 4
  br label %return

if.end38:                                         ; preds = %while.end
  br label %error

error:                                            ; preds = %if.end38, %if.then32, %if.then27, %if.end19
  %33 = load ptr, ptr %iterator, align 8
  store ptr %33, ptr %op.addr.i, align 8
  %34 = load ptr, ptr %op.addr.i, align 8
  store ptr %34, ptr %op.addr.i63, align 8
  %35 = load ptr, ptr %op.addr.i63, align 8
  %36 = load i64, ptr %35, align 8
  %conv.i64 = trunc i64 %36 to i32
  %cmp.i65 = icmp slt i32 %conv.i64, 0
  %conv1.i66 = zext i1 %cmp.i65 to i32
  %tobool.i = icmp ne i32 %conv1.i66, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %error
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %error
  %37 = load ptr, ptr %op.addr.i, align 8
  %38 = load i64, ptr %37, align 8
  %dec.i = add i64 %38, -1
  store i64 %dec.i, ptr %37, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %39 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %39) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %Py_DECREF.exit, %Py_DECREF.exit47, %if.then4, %if.then
  %40 = load i32, ptr %retval, align 4
  ret i32 %40
}

; Function Attrs: nounwind
declare i32 @sigemptyset(ptr noundef) #4

declare ptr @PyErr_SetFromErrno(ptr noundef) #1

declare ptr @PyObject_GetIter(ptr noundef) #1

declare ptr @PyIter_Next(ptr noundef) #1

; Function Attrs: nounwind
declare i32 @sigaddset(ptr noundef, i32 noundef) #4

; Function Attrs: nounwind willreturn memory(none)
declare ptr @__errno_location() #5

declare i32 @PyErr_WarnFormat(ptr noundef, i64 noundef, ptr noundef, ...) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @PyOS_FSPath(ptr noundef %path) #0 {
entry:
  %op.addr.i43 = alloca ptr, align 8
  %op.addr.i41 = alloca ptr, align 8
  %op.addr.i32 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %path.addr = alloca ptr, align 8
  %func = alloca ptr, align 8
  %path_repr = alloca ptr, align 8
  store ptr %path, ptr %path.addr, align 8
  store ptr null, ptr %func, align 8
  store ptr null, ptr %path_repr, align 8
  %0 = load ptr, ptr %path.addr, align 8
  %call = call ptr @Py_TYPE(ptr noundef %0)
  %call1 = call i32 @PyType_HasFeature(ptr noundef %call, i64 noundef 268435456)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %path.addr, align 8
  %call2 = call ptr @Py_TYPE(ptr noundef %1)
  %call3 = call i32 @PyType_HasFeature(ptr noundef %call2, i64 noundef 134217728)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %2 = load ptr, ptr %path.addr, align 8
  %call5 = call ptr @_Py_NewRef(ptr noundef %2)
  store ptr %call5, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %3 = load ptr, ptr %path.addr, align 8
  %call6 = call ptr @_PyObject_LookupSpecial(ptr noundef %3, ptr noundef getelementptr inbounds (%struct.anon.44, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 37), i32 0, i32 3, i32 1, i32 59))
  store ptr %call6, ptr %func, align 8
  %4 = load ptr, ptr %func, align 8
  %cmp = icmp eq ptr null, %4
  br i1 %cmp, label %if.then9, label %lor.lhs.false7

lor.lhs.false7:                                   ; preds = %if.end
  %5 = load ptr, ptr %func, align 8
  %cmp8 = icmp eq ptr %5, @_Py_NoneStruct
  br i1 %cmp8, label %if.then9, label %if.end13

if.then9:                                         ; preds = %lor.lhs.false7, %if.end
  %6 = load ptr, ptr @PyExc_TypeError, align 8
  %7 = load ptr, ptr %path.addr, align 8
  %call10 = call ptr @Py_TYPE(ptr noundef %7)
  %call11 = call ptr @_PyType_Name(ptr noundef %call10)
  %call12 = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %6, ptr noundef @.str.8, ptr noundef %call11)
  store ptr %call12, ptr %retval, align 8
  br label %return

if.end13:                                         ; preds = %lor.lhs.false7
  %8 = load ptr, ptr %func, align 8
  %call14 = call ptr @_PyObject_CallNoArgs(ptr noundef %8)
  store ptr %call14, ptr %path_repr, align 8
  %9 = load ptr, ptr %func, align 8
  store ptr %9, ptr %op.addr.i32, align 8
  %10 = load ptr, ptr %op.addr.i32, align 8
  store ptr %10, ptr %op.addr.i41, align 8
  %11 = load ptr, ptr %op.addr.i41, align 8
  %12 = load i64, ptr %11, align 8
  %conv.i = trunc i64 %12 to i32
  %cmp.i42 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i42 to i32
  %tobool.i34 = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i34, label %if.then.i39, label %if.end.i35

if.then.i39:                                      ; preds = %if.end13
  br label %Py_DECREF.exit40

if.end.i35:                                       ; preds = %if.end13
  %13 = load ptr, ptr %op.addr.i32, align 8
  %14 = load i64, ptr %13, align 8
  %dec.i36 = add i64 %14, -1
  store i64 %dec.i36, ptr %13, align 8
  %cmp.i37 = icmp eq i64 %dec.i36, 0
  br i1 %cmp.i37, label %if.then1.i38, label %Py_DECREF.exit40

if.then1.i38:                                     ; preds = %if.end.i35
  %15 = load ptr, ptr %op.addr.i32, align 8
  call void @_Py_Dealloc(ptr noundef %15) #10
  br label %Py_DECREF.exit40

Py_DECREF.exit40:                                 ; preds = %if.then1.i38, %if.end.i35, %if.then.i39
  %16 = load ptr, ptr %path_repr, align 8
  %cmp15 = icmp eq ptr null, %16
  br i1 %cmp15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %Py_DECREF.exit40
  store ptr null, ptr %retval, align 8
  br label %return

if.end17:                                         ; preds = %Py_DECREF.exit40
  %17 = load ptr, ptr %path_repr, align 8
  %call18 = call ptr @Py_TYPE(ptr noundef %17)
  %call19 = call i32 @PyType_HasFeature(ptr noundef %call18, i64 noundef 268435456)
  %tobool20 = icmp ne i32 %call19, 0
  br i1 %tobool20, label %if.end31, label %lor.lhs.false21

lor.lhs.false21:                                  ; preds = %if.end17
  %18 = load ptr, ptr %path_repr, align 8
  %call22 = call ptr @Py_TYPE(ptr noundef %18)
  %call23 = call i32 @PyType_HasFeature(ptr noundef %call22, i64 noundef 134217728)
  %tobool24 = icmp ne i32 %call23, 0
  br i1 %tobool24, label %if.end31, label %if.then25

if.then25:                                        ; preds = %lor.lhs.false21
  %19 = load ptr, ptr @PyExc_TypeError, align 8
  %20 = load ptr, ptr %path.addr, align 8
  %call26 = call ptr @Py_TYPE(ptr noundef %20)
  %call27 = call ptr @_PyType_Name(ptr noundef %call26)
  %21 = load ptr, ptr %path_repr, align 8
  %call28 = call ptr @Py_TYPE(ptr noundef %21)
  %call29 = call ptr @_PyType_Name(ptr noundef %call28)
  %call30 = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %19, ptr noundef @.str.9, ptr noundef %call27, ptr noundef %call29)
  %22 = load ptr, ptr %path_repr, align 8
  store ptr %22, ptr %op.addr.i, align 8
  %23 = load ptr, ptr %op.addr.i, align 8
  store ptr %23, ptr %op.addr.i43, align 8
  %24 = load ptr, ptr %op.addr.i43, align 8
  %25 = load i64, ptr %24, align 8
  %conv.i44 = trunc i64 %25 to i32
  %cmp.i45 = icmp slt i32 %conv.i44, 0
  %conv1.i46 = zext i1 %cmp.i45 to i32
  %tobool.i = icmp ne i32 %conv1.i46, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then25
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.then25
  %26 = load ptr, ptr %op.addr.i, align 8
  %27 = load i64, ptr %26, align 8
  %dec.i = add i64 %27, -1
  store i64 %dec.i, ptr %26, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %28 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %28) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  store ptr null, ptr %retval, align 8
  br label %return

if.end31:                                         ; preds = %lor.lhs.false21, %if.end17
  %29 = load ptr, ptr %path_repr, align 8
  store ptr %29, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end31, %Py_DECREF.exit, %if.then16, %if.then9, %if.then
  %30 = load ptr, ptr %retval, align 8
  ret ptr %30
}

; Function Attrs: nounwind uwtable
define internal i32 @PyType_HasFeature(ptr noundef %type, i64 noundef %feature) #0 {
entry:
  %type.addr = alloca ptr, align 8
  %feature.addr = alloca i64, align 8
  %flags = alloca i64, align 8
  store ptr %type, ptr %type.addr, align 8
  store i64 %feature, ptr %feature.addr, align 8
  %0 = load ptr, ptr %type.addr, align 8
  %tp_flags = getelementptr inbounds %struct._typeobject, ptr %0, i32 0, i32 19
  %1 = load i64, ptr %tp_flags, align 8
  store i64 %1, ptr %flags, align 8
  %2 = load i64, ptr %flags, align 8
  %3 = load i64, ptr %feature.addr, align 8
  %and = and i64 %2, %3
  %cmp = icmp ne i64 %and, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define internal ptr @_Py_NewRef(ptr noundef %obj) #0 {
entry:
  %op.addr.i = alloca ptr, align 8
  %cur_refcnt.i = alloca i32, align 4
  %new_refcnt.i = alloca i32, align 4
  %obj.addr = alloca ptr, align 8
  store ptr %obj, ptr %obj.addr, align 8
  %0 = load ptr, ptr %obj.addr, align 8
  store ptr %0, ptr %op.addr.i, align 8
  %1 = load ptr, ptr %op.addr.i, align 8
  %2 = load i32, ptr %1, align 8
  store i32 %2, ptr %cur_refcnt.i, align 4
  %3 = load i32, ptr %cur_refcnt.i, align 4
  %add.i = add i32 %3, 1
  store i32 %add.i, ptr %new_refcnt.i, align 4
  %4 = load i32, ptr %new_refcnt.i, align 4
  %cmp.i = icmp eq i32 %4, 0
  br i1 %cmp.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %entry
  br label %Py_INCREF.exit

if.end.i:                                         ; preds = %entry
  %5 = load i32, ptr %new_refcnt.i, align 4
  %6 = load ptr, ptr %op.addr.i, align 8
  store i32 %5, ptr %6, align 8
  br label %Py_INCREF.exit

Py_INCREF.exit:                                   ; preds = %if.end.i, %if.then.i
  %7 = load ptr, ptr %obj.addr, align 8
  ret ptr %7
}

declare ptr @_PyObject_LookupSpecial(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @_PyObject_CallNoArgs(ptr noundef %func) #0 {
entry:
  %func.addr = alloca ptr, align 8
  %tstate = alloca ptr, align 8
  store ptr %func, ptr %func.addr, align 8
  %call = call ptr @_PyThreadState_GET()
  store ptr %call, ptr %tstate, align 8
  %0 = load ptr, ptr %tstate, align 8
  %1 = load ptr, ptr %func.addr, align 8
  %call1 = call ptr @_PyObject_VectorcallTstate(ptr noundef %0, ptr noundef %1, ptr noundef null, i64 noundef 0, ptr noundef null)
  ret ptr %call1
}

; Function Attrs: nounwind uwtable
define dso_local ptr @PyInit_posix() #0 {
entry:
  %call = call ptr @PyModuleDef_Init(ptr noundef @posixmodule)
  ret ptr %call
}

declare ptr @PyModuleDef_Init(ptr noundef) #1

declare ptr @PyList_GetSlice(ptr noundef, i64 noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define internal i64 @PyList_GET_SIZE(ptr noundef %op) #0 {
entry:
  %op.addr = alloca ptr, align 8
  %list = alloca ptr, align 8
  store ptr %op, ptr %op.addr, align 8
  %0 = load ptr, ptr %op.addr, align 8
  store ptr %0, ptr %list, align 8
  %1 = load ptr, ptr %list, align 8
  %call = call i64 @Py_SIZE(ptr noundef %1)
  ret i64 %call
}

declare void @PyErr_WriteUnraisable(ptr noundef) #1

declare i32 @PyList_Reverse(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal i64 @Py_SIZE(ptr noundef %ob) #0 {
entry:
  %ob.addr = alloca ptr, align 8
  %var_ob = alloca ptr, align 8
  store ptr %ob, ptr %ob.addr, align 8
  %0 = load ptr, ptr %ob.addr, align 8
  store ptr %0, ptr %var_ob, align 8
  %1 = load ptr, ptr %var_ob, align 8
  %ob_size = getelementptr inbounds %struct.PyVarObject, ptr %1, i32 0, i32 1
  %2 = load i64, ptr %ob_size, align 8
  ret i64 %2
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare nonnull ptr @llvm.threadlocal.address.p0(ptr nonnull) #6

declare void @_Py_Dealloc(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @_PyObject_VectorcallTstate(ptr noundef %tstate, ptr noundef %callable, ptr noundef %args, i64 noundef %nargsf, ptr noundef %kwnames) #0 {
entry:
  %retval = alloca ptr, align 8
  %tstate.addr = alloca ptr, align 8
  %callable.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargsf.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %func = alloca ptr, align 8
  %res = alloca ptr, align 8
  %nargs = alloca i64, align 8
  store ptr %tstate, ptr %tstate.addr, align 8
  store ptr %callable, ptr %callable.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargsf, ptr %nargsf.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  %0 = load ptr, ptr %callable.addr, align 8
  %call = call ptr @_PyVectorcall_FunctionInline(ptr noundef %0)
  store ptr %call, ptr %func, align 8
  %1 = load ptr, ptr %func, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i64, ptr %nargsf.addr, align 8
  %call1 = call i64 @_PyVectorcall_NARGS(i64 noundef %2)
  store i64 %call1, ptr %nargs, align 8
  %3 = load ptr, ptr %tstate.addr, align 8
  %4 = load ptr, ptr %callable.addr, align 8
  %5 = load ptr, ptr %args.addr, align 8
  %6 = load i64, ptr %nargs, align 8
  %7 = load ptr, ptr %kwnames.addr, align 8
  %call2 = call ptr @_PyObject_MakeTpCall(ptr noundef %3, ptr noundef %4, ptr noundef %5, i64 noundef %6, ptr noundef %7)
  store ptr %call2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %func, align 8
  %9 = load ptr, ptr %callable.addr, align 8
  %10 = load ptr, ptr %args.addr, align 8
  %11 = load i64, ptr %nargsf.addr, align 8
  %12 = load ptr, ptr %kwnames.addr, align 8
  %call3 = call ptr %8(ptr noundef %9, ptr noundef %10, i64 noundef %11, ptr noundef %12)
  store ptr %call3, ptr %res, align 8
  %13 = load ptr, ptr %tstate.addr, align 8
  %14 = load ptr, ptr %callable.addr, align 8
  %15 = load ptr, ptr %res, align 8
  %call4 = call ptr @_Py_CheckFunctionResult(ptr noundef %13, ptr noundef %14, ptr noundef %15, ptr noundef null)
  store ptr %call4, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %16 = load ptr, ptr %retval, align 8
  ret ptr %16
}

; Function Attrs: nounwind uwtable
define internal ptr @_PyVectorcall_FunctionInline(ptr noundef %callable) #0 {
entry:
  %retval = alloca ptr, align 8
  %callable.addr = alloca ptr, align 8
  %tp = alloca ptr, align 8
  %offset = alloca i64, align 8
  %ptr = alloca ptr, align 8
  store ptr %callable, ptr %callable.addr, align 8
  %0 = load ptr, ptr %callable.addr, align 8
  %call = call ptr @Py_TYPE(ptr noundef %0)
  store ptr %call, ptr %tp, align 8
  %1 = load ptr, ptr %tp, align 8
  %call1 = call i32 @PyType_HasFeature(ptr noundef %1, i64 noundef 2048)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %tp, align 8
  %tp_vectorcall_offset = getelementptr inbounds %struct._typeobject, ptr %2, i32 0, i32 5
  %3 = load i64, ptr %tp_vectorcall_offset, align 8
  store i64 %3, ptr %offset, align 8
  %4 = load ptr, ptr %callable.addr, align 8
  %5 = load i64, ptr %offset, align 8
  %add.ptr = getelementptr i8, ptr %4, i64 %5
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %ptr, ptr align 1 %add.ptr, i64 8, i1 false)
  %6 = load ptr, ptr %ptr, align 8
  store ptr %6, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load ptr, ptr %retval, align 8
  ret ptr %7
}

; Function Attrs: nounwind uwtable
define internal i64 @_PyVectorcall_NARGS(i64 noundef %n) #0 {
entry:
  %n.addr = alloca i64, align 8
  store i64 %n, ptr %n.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %and = and i64 %0, 9223372036854775807
  ret i64 %and
}

declare ptr @_PyObject_MakeTpCall(ptr noundef, ptr noundef, ptr noundef, i64 noundef, ptr noundef) #1

declare ptr @_Py_CheckFunctionResult(ptr noundef, ptr noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal i32 @_posix_traverse(ptr noundef %module, ptr noundef %visit, ptr noundef %arg) #0 {
entry:
  %retval = alloca i32, align 4
  %module.addr = alloca ptr, align 8
  %visit.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %state = alloca ptr, align 8
  %vret = alloca i32, align 4
  %vret9 = alloca i32, align 4
  %vret20 = alloca i32, align 4
  %vret31 = alloca i32, align 4
  %vret42 = alloca i32, align 4
  %vret53 = alloca i32, align 4
  %vret64 = alloca i32, align 4
  %vret75 = alloca i32, align 4
  %vret86 = alloca i32, align 4
  %vret97 = alloca i32, align 4
  %vret108 = alloca i32, align 4
  %vret119 = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %visit, ptr %visit.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %call = call ptr @get_posix_state(ptr noundef %0)
  store ptr %call, ptr %state, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %1 = load ptr, ptr %state, align 8
  %billion = getelementptr inbounds %struct._posixstate, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %billion, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.then, label %if.end5

if.then:                                          ; preds = %do.body
  %3 = load ptr, ptr %visit.addr, align 8
  %4 = load ptr, ptr %state, align 8
  %billion1 = getelementptr inbounds %struct._posixstate, ptr %4, i32 0, i32 0
  %5 = load ptr, ptr %billion1, align 8
  %6 = load ptr, ptr %arg.addr, align 8
  %call2 = call i32 %3(ptr noundef %5, ptr noundef %6)
  store i32 %call2, ptr %vret, align 4
  %7 = load i32, ptr %vret, align 4
  %tobool3 = icmp ne i32 %7, 0
  br i1 %tobool3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  %8 = load i32, ptr %vret, align 4
  store i32 %8, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  br label %if.end5

if.end5:                                          ; preds = %if.end, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end5
  br label %do.body6

do.body6:                                         ; preds = %do.end
  %9 = load ptr, ptr %state, align 8
  %DirEntryType = getelementptr inbounds %struct._posixstate, ptr %9, i32 0, i32 1
  %10 = load ptr, ptr %DirEntryType, align 8
  %tobool7 = icmp ne ptr %10, null
  br i1 %tobool7, label %if.then8, label %if.end15

if.then8:                                         ; preds = %do.body6
  %11 = load ptr, ptr %visit.addr, align 8
  %12 = load ptr, ptr %state, align 8
  %DirEntryType10 = getelementptr inbounds %struct._posixstate, ptr %12, i32 0, i32 1
  %13 = load ptr, ptr %DirEntryType10, align 8
  %14 = load ptr, ptr %arg.addr, align 8
  %call11 = call i32 %11(ptr noundef %13, ptr noundef %14)
  store i32 %call11, ptr %vret9, align 4
  %15 = load i32, ptr %vret9, align 4
  %tobool12 = icmp ne i32 %15, 0
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.then8
  %16 = load i32, ptr %vret9, align 4
  store i32 %16, ptr %retval, align 4
  br label %return

if.end14:                                         ; preds = %if.then8
  br label %if.end15

if.end15:                                         ; preds = %if.end14, %do.body6
  br label %do.end16

do.end16:                                         ; preds = %if.end15
  br label %do.body17

do.body17:                                        ; preds = %do.end16
  %17 = load ptr, ptr %state, align 8
  %ScandirIteratorType = getelementptr inbounds %struct._posixstate, ptr %17, i32 0, i32 2
  %18 = load ptr, ptr %ScandirIteratorType, align 8
  %tobool18 = icmp ne ptr %18, null
  br i1 %tobool18, label %if.then19, label %if.end26

if.then19:                                        ; preds = %do.body17
  %19 = load ptr, ptr %visit.addr, align 8
  %20 = load ptr, ptr %state, align 8
  %ScandirIteratorType21 = getelementptr inbounds %struct._posixstate, ptr %20, i32 0, i32 2
  %21 = load ptr, ptr %ScandirIteratorType21, align 8
  %22 = load ptr, ptr %arg.addr, align 8
  %call22 = call i32 %19(ptr noundef %21, ptr noundef %22)
  store i32 %call22, ptr %vret20, align 4
  %23 = load i32, ptr %vret20, align 4
  %tobool23 = icmp ne i32 %23, 0
  br i1 %tobool23, label %if.then24, label %if.end25

if.then24:                                        ; preds = %if.then19
  %24 = load i32, ptr %vret20, align 4
  store i32 %24, ptr %retval, align 4
  br label %return

if.end25:                                         ; preds = %if.then19
  br label %if.end26

if.end26:                                         ; preds = %if.end25, %do.body17
  br label %do.end27

do.end27:                                         ; preds = %if.end26
  br label %do.body28

do.body28:                                        ; preds = %do.end27
  %25 = load ptr, ptr %state, align 8
  %SchedParamType = getelementptr inbounds %struct._posixstate, ptr %25, i32 0, i32 3
  %26 = load ptr, ptr %SchedParamType, align 8
  %tobool29 = icmp ne ptr %26, null
  br i1 %tobool29, label %if.then30, label %if.end37

if.then30:                                        ; preds = %do.body28
  %27 = load ptr, ptr %visit.addr, align 8
  %28 = load ptr, ptr %state, align 8
  %SchedParamType32 = getelementptr inbounds %struct._posixstate, ptr %28, i32 0, i32 3
  %29 = load ptr, ptr %SchedParamType32, align 8
  %30 = load ptr, ptr %arg.addr, align 8
  %call33 = call i32 %27(ptr noundef %29, ptr noundef %30)
  store i32 %call33, ptr %vret31, align 4
  %31 = load i32, ptr %vret31, align 4
  %tobool34 = icmp ne i32 %31, 0
  br i1 %tobool34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %if.then30
  %32 = load i32, ptr %vret31, align 4
  store i32 %32, ptr %retval, align 4
  br label %return

if.end36:                                         ; preds = %if.then30
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %do.body28
  br label %do.end38

do.end38:                                         ; preds = %if.end37
  br label %do.body39

do.body39:                                        ; preds = %do.end38
  %33 = load ptr, ptr %state, align 8
  %StatResultType = getelementptr inbounds %struct._posixstate, ptr %33, i32 0, i32 5
  %34 = load ptr, ptr %StatResultType, align 8
  %tobool40 = icmp ne ptr %34, null
  br i1 %tobool40, label %if.then41, label %if.end48

if.then41:                                        ; preds = %do.body39
  %35 = load ptr, ptr %visit.addr, align 8
  %36 = load ptr, ptr %state, align 8
  %StatResultType43 = getelementptr inbounds %struct._posixstate, ptr %36, i32 0, i32 5
  %37 = load ptr, ptr %StatResultType43, align 8
  %38 = load ptr, ptr %arg.addr, align 8
  %call44 = call i32 %35(ptr noundef %37, ptr noundef %38)
  store i32 %call44, ptr %vret42, align 4
  %39 = load i32, ptr %vret42, align 4
  %tobool45 = icmp ne i32 %39, 0
  br i1 %tobool45, label %if.then46, label %if.end47

if.then46:                                        ; preds = %if.then41
  %40 = load i32, ptr %vret42, align 4
  store i32 %40, ptr %retval, align 4
  br label %return

if.end47:                                         ; preds = %if.then41
  br label %if.end48

if.end48:                                         ; preds = %if.end47, %do.body39
  br label %do.end49

do.end49:                                         ; preds = %if.end48
  br label %do.body50

do.body50:                                        ; preds = %do.end49
  %41 = load ptr, ptr %state, align 8
  %StatVFSResultType = getelementptr inbounds %struct._posixstate, ptr %41, i32 0, i32 6
  %42 = load ptr, ptr %StatVFSResultType, align 8
  %tobool51 = icmp ne ptr %42, null
  br i1 %tobool51, label %if.then52, label %if.end59

if.then52:                                        ; preds = %do.body50
  %43 = load ptr, ptr %visit.addr, align 8
  %44 = load ptr, ptr %state, align 8
  %StatVFSResultType54 = getelementptr inbounds %struct._posixstate, ptr %44, i32 0, i32 6
  %45 = load ptr, ptr %StatVFSResultType54, align 8
  %46 = load ptr, ptr %arg.addr, align 8
  %call55 = call i32 %43(ptr noundef %45, ptr noundef %46)
  store i32 %call55, ptr %vret53, align 4
  %47 = load i32, ptr %vret53, align 4
  %tobool56 = icmp ne i32 %47, 0
  br i1 %tobool56, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.then52
  %48 = load i32, ptr %vret53, align 4
  store i32 %48, ptr %retval, align 4
  br label %return

if.end58:                                         ; preds = %if.then52
  br label %if.end59

if.end59:                                         ; preds = %if.end58, %do.body50
  br label %do.end60

do.end60:                                         ; preds = %if.end59
  br label %do.body61

do.body61:                                        ; preds = %do.end60
  %49 = load ptr, ptr %state, align 8
  %TerminalSizeType = getelementptr inbounds %struct._posixstate, ptr %49, i32 0, i32 7
  %50 = load ptr, ptr %TerminalSizeType, align 8
  %tobool62 = icmp ne ptr %50, null
  br i1 %tobool62, label %if.then63, label %if.end70

if.then63:                                        ; preds = %do.body61
  %51 = load ptr, ptr %visit.addr, align 8
  %52 = load ptr, ptr %state, align 8
  %TerminalSizeType65 = getelementptr inbounds %struct._posixstate, ptr %52, i32 0, i32 7
  %53 = load ptr, ptr %TerminalSizeType65, align 8
  %54 = load ptr, ptr %arg.addr, align 8
  %call66 = call i32 %51(ptr noundef %53, ptr noundef %54)
  store i32 %call66, ptr %vret64, align 4
  %55 = load i32, ptr %vret64, align 4
  %tobool67 = icmp ne i32 %55, 0
  br i1 %tobool67, label %if.then68, label %if.end69

if.then68:                                        ; preds = %if.then63
  %56 = load i32, ptr %vret64, align 4
  store i32 %56, ptr %retval, align 4
  br label %return

if.end69:                                         ; preds = %if.then63
  br label %if.end70

if.end70:                                         ; preds = %if.end69, %do.body61
  br label %do.end71

do.end71:                                         ; preds = %if.end70
  br label %do.body72

do.body72:                                        ; preds = %do.end71
  %57 = load ptr, ptr %state, align 8
  %TimesResultType = getelementptr inbounds %struct._posixstate, ptr %57, i32 0, i32 8
  %58 = load ptr, ptr %TimesResultType, align 8
  %tobool73 = icmp ne ptr %58, null
  br i1 %tobool73, label %if.then74, label %if.end81

if.then74:                                        ; preds = %do.body72
  %59 = load ptr, ptr %visit.addr, align 8
  %60 = load ptr, ptr %state, align 8
  %TimesResultType76 = getelementptr inbounds %struct._posixstate, ptr %60, i32 0, i32 8
  %61 = load ptr, ptr %TimesResultType76, align 8
  %62 = load ptr, ptr %arg.addr, align 8
  %call77 = call i32 %59(ptr noundef %61, ptr noundef %62)
  store i32 %call77, ptr %vret75, align 4
  %63 = load i32, ptr %vret75, align 4
  %tobool78 = icmp ne i32 %63, 0
  br i1 %tobool78, label %if.then79, label %if.end80

if.then79:                                        ; preds = %if.then74
  %64 = load i32, ptr %vret75, align 4
  store i32 %64, ptr %retval, align 4
  br label %return

if.end80:                                         ; preds = %if.then74
  br label %if.end81

if.end81:                                         ; preds = %if.end80, %do.body72
  br label %do.end82

do.end82:                                         ; preds = %if.end81
  br label %do.body83

do.body83:                                        ; preds = %do.end82
  %65 = load ptr, ptr %state, align 8
  %UnameResultType = getelementptr inbounds %struct._posixstate, ptr %65, i32 0, i32 9
  %66 = load ptr, ptr %UnameResultType, align 8
  %tobool84 = icmp ne ptr %66, null
  br i1 %tobool84, label %if.then85, label %if.end92

if.then85:                                        ; preds = %do.body83
  %67 = load ptr, ptr %visit.addr, align 8
  %68 = load ptr, ptr %state, align 8
  %UnameResultType87 = getelementptr inbounds %struct._posixstate, ptr %68, i32 0, i32 9
  %69 = load ptr, ptr %UnameResultType87, align 8
  %70 = load ptr, ptr %arg.addr, align 8
  %call88 = call i32 %67(ptr noundef %69, ptr noundef %70)
  store i32 %call88, ptr %vret86, align 4
  %71 = load i32, ptr %vret86, align 4
  %tobool89 = icmp ne i32 %71, 0
  br i1 %tobool89, label %if.then90, label %if.end91

if.then90:                                        ; preds = %if.then85
  %72 = load i32, ptr %vret86, align 4
  store i32 %72, ptr %retval, align 4
  br label %return

if.end91:                                         ; preds = %if.then85
  br label %if.end92

if.end92:                                         ; preds = %if.end91, %do.body83
  br label %do.end93

do.end93:                                         ; preds = %if.end92
  br label %do.body94

do.body94:                                        ; preds = %do.end93
  %73 = load ptr, ptr %state, align 8
  %WaitidResultType = getelementptr inbounds %struct._posixstate, ptr %73, i32 0, i32 10
  %74 = load ptr, ptr %WaitidResultType, align 8
  %tobool95 = icmp ne ptr %74, null
  br i1 %tobool95, label %if.then96, label %if.end103

if.then96:                                        ; preds = %do.body94
  %75 = load ptr, ptr %visit.addr, align 8
  %76 = load ptr, ptr %state, align 8
  %WaitidResultType98 = getelementptr inbounds %struct._posixstate, ptr %76, i32 0, i32 10
  %77 = load ptr, ptr %WaitidResultType98, align 8
  %78 = load ptr, ptr %arg.addr, align 8
  %call99 = call i32 %75(ptr noundef %77, ptr noundef %78)
  store i32 %call99, ptr %vret97, align 4
  %79 = load i32, ptr %vret97, align 4
  %tobool100 = icmp ne i32 %79, 0
  br i1 %tobool100, label %if.then101, label %if.end102

if.then101:                                       ; preds = %if.then96
  %80 = load i32, ptr %vret97, align 4
  store i32 %80, ptr %retval, align 4
  br label %return

if.end102:                                        ; preds = %if.then96
  br label %if.end103

if.end103:                                        ; preds = %if.end102, %do.body94
  br label %do.end104

do.end104:                                        ; preds = %if.end103
  br label %do.body105

do.body105:                                       ; preds = %do.end104
  %81 = load ptr, ptr %state, align 8
  %struct_rusage = getelementptr inbounds %struct._posixstate, ptr %81, i32 0, i32 11
  %82 = load ptr, ptr %struct_rusage, align 8
  %tobool106 = icmp ne ptr %82, null
  br i1 %tobool106, label %if.then107, label %if.end114

if.then107:                                       ; preds = %do.body105
  %83 = load ptr, ptr %visit.addr, align 8
  %84 = load ptr, ptr %state, align 8
  %struct_rusage109 = getelementptr inbounds %struct._posixstate, ptr %84, i32 0, i32 11
  %85 = load ptr, ptr %struct_rusage109, align 8
  %86 = load ptr, ptr %arg.addr, align 8
  %call110 = call i32 %83(ptr noundef %85, ptr noundef %86)
  store i32 %call110, ptr %vret108, align 4
  %87 = load i32, ptr %vret108, align 4
  %tobool111 = icmp ne i32 %87, 0
  br i1 %tobool111, label %if.then112, label %if.end113

if.then112:                                       ; preds = %if.then107
  %88 = load i32, ptr %vret108, align 4
  store i32 %88, ptr %retval, align 4
  br label %return

if.end113:                                        ; preds = %if.then107
  br label %if.end114

if.end114:                                        ; preds = %if.end113, %do.body105
  br label %do.end115

do.end115:                                        ; preds = %if.end114
  br label %do.body116

do.body116:                                       ; preds = %do.end115
  %89 = load ptr, ptr %state, align 8
  %st_mode = getelementptr inbounds %struct._posixstate, ptr %89, i32 0, i32 12
  %90 = load ptr, ptr %st_mode, align 8
  %tobool117 = icmp ne ptr %90, null
  br i1 %tobool117, label %if.then118, label %if.end125

if.then118:                                       ; preds = %do.body116
  %91 = load ptr, ptr %visit.addr, align 8
  %92 = load ptr, ptr %state, align 8
  %st_mode120 = getelementptr inbounds %struct._posixstate, ptr %92, i32 0, i32 12
  %93 = load ptr, ptr %st_mode120, align 8
  %94 = load ptr, ptr %arg.addr, align 8
  %call121 = call i32 %91(ptr noundef %93, ptr noundef %94)
  store i32 %call121, ptr %vret119, align 4
  %95 = load i32, ptr %vret119, align 4
  %tobool122 = icmp ne i32 %95, 0
  br i1 %tobool122, label %if.then123, label %if.end124

if.then123:                                       ; preds = %if.then118
  %96 = load i32, ptr %vret119, align 4
  store i32 %96, ptr %retval, align 4
  br label %return

if.end124:                                        ; preds = %if.then118
  br label %if.end125

if.end125:                                        ; preds = %if.end124, %do.body116
  br label %do.end126

do.end126:                                        ; preds = %if.end125
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %do.end126, %if.then123, %if.then112, %if.then101, %if.then90, %if.then79, %if.then68, %if.then57, %if.then46, %if.then35, %if.then24, %if.then13, %if.then4
  %97 = load i32, ptr %retval, align 4
  ret i32 %97
}

; Function Attrs: nounwind uwtable
define internal i32 @_posix_clear(ptr noundef %module) #0 {
entry:
  %op.addr.i219 = alloca ptr, align 8
  %op.addr.i215 = alloca ptr, align 8
  %op.addr.i211 = alloca ptr, align 8
  %op.addr.i207 = alloca ptr, align 8
  %op.addr.i203 = alloca ptr, align 8
  %op.addr.i199 = alloca ptr, align 8
  %op.addr.i195 = alloca ptr, align 8
  %op.addr.i191 = alloca ptr, align 8
  %op.addr.i187 = alloca ptr, align 8
  %op.addr.i183 = alloca ptr, align 8
  %op.addr.i179 = alloca ptr, align 8
  %op.addr.i177 = alloca ptr, align 8
  %op.addr.i168 = alloca ptr, align 8
  %op.addr.i159 = alloca ptr, align 8
  %op.addr.i150 = alloca ptr, align 8
  %op.addr.i141 = alloca ptr, align 8
  %op.addr.i132 = alloca ptr, align 8
  %op.addr.i123 = alloca ptr, align 8
  %op.addr.i114 = alloca ptr, align 8
  %op.addr.i105 = alloca ptr, align 8
  %op.addr.i96 = alloca ptr, align 8
  %op.addr.i87 = alloca ptr, align 8
  %op.addr.i78 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %state = alloca ptr, align 8
  %_tmp_op_ptr = alloca ptr, align 8
  %_tmp_old_op = alloca ptr, align 8
  %_tmp_op_ptr2 = alloca ptr, align 8
  %_tmp_old_op3 = alloca ptr, align 8
  %_tmp_op_ptr9 = alloca ptr, align 8
  %_tmp_old_op10 = alloca ptr, align 8
  %_tmp_op_ptr16 = alloca ptr, align 8
  %_tmp_old_op17 = alloca ptr, align 8
  %_tmp_op_ptr23 = alloca ptr, align 8
  %_tmp_old_op24 = alloca ptr, align 8
  %_tmp_op_ptr30 = alloca ptr, align 8
  %_tmp_old_op31 = alloca ptr, align 8
  %_tmp_op_ptr37 = alloca ptr, align 8
  %_tmp_old_op38 = alloca ptr, align 8
  %_tmp_op_ptr44 = alloca ptr, align 8
  %_tmp_old_op45 = alloca ptr, align 8
  %_tmp_op_ptr51 = alloca ptr, align 8
  %_tmp_old_op52 = alloca ptr, align 8
  %_tmp_op_ptr58 = alloca ptr, align 8
  %_tmp_old_op59 = alloca ptr, align 8
  %_tmp_op_ptr65 = alloca ptr, align 8
  %_tmp_old_op66 = alloca ptr, align 8
  %_tmp_op_ptr72 = alloca ptr, align 8
  %_tmp_old_op73 = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %call = call ptr @get_posix_state(ptr noundef %0)
  store ptr %call, ptr %state, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %1 = load ptr, ptr %state, align 8
  %billion = getelementptr inbounds %struct._posixstate, ptr %1, i32 0, i32 0
  store ptr %billion, ptr %_tmp_op_ptr, align 8
  %2 = load ptr, ptr %_tmp_op_ptr, align 8
  %3 = load ptr, ptr %2, align 8
  store ptr %3, ptr %_tmp_old_op, align 8
  %4 = load ptr, ptr %_tmp_old_op, align 8
  %cmp = icmp ne ptr %4, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  %5 = load ptr, ptr %_tmp_op_ptr, align 8
  store ptr null, ptr %5, align 8
  %6 = load ptr, ptr %_tmp_old_op, align 8
  store ptr %6, ptr %op.addr.i168, align 8
  %7 = load ptr, ptr %op.addr.i168, align 8
  store ptr %7, ptr %op.addr.i177, align 8
  %8 = load ptr, ptr %op.addr.i177, align 8
  %9 = load i64, ptr %8, align 8
  %conv.i = trunc i64 %9 to i32
  %cmp.i178 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i178 to i32
  %tobool.i170 = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i170, label %if.then.i175, label %if.end.i171

if.then.i175:                                     ; preds = %if.then
  br label %Py_DECREF.exit176

if.end.i171:                                      ; preds = %if.then
  %10 = load ptr, ptr %op.addr.i168, align 8
  %11 = load i64, ptr %10, align 8
  %dec.i172 = add i64 %11, -1
  store i64 %dec.i172, ptr %10, align 8
  %cmp.i173 = icmp eq i64 %dec.i172, 0
  br i1 %cmp.i173, label %if.then1.i174, label %Py_DECREF.exit176

if.then1.i174:                                    ; preds = %if.end.i171
  %12 = load ptr, ptr %op.addr.i168, align 8
  call void @_Py_Dealloc(ptr noundef %12) #10
  br label %Py_DECREF.exit176

Py_DECREF.exit176:                                ; preds = %if.then1.i174, %if.end.i171, %if.then.i175
  br label %if.end

if.end:                                           ; preds = %Py_DECREF.exit176, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  br label %do.body1

do.body1:                                         ; preds = %do.end
  %13 = load ptr, ptr %state, align 8
  %DirEntryType = getelementptr inbounds %struct._posixstate, ptr %13, i32 0, i32 1
  store ptr %DirEntryType, ptr %_tmp_op_ptr2, align 8
  %14 = load ptr, ptr %_tmp_op_ptr2, align 8
  %15 = load ptr, ptr %14, align 8
  store ptr %15, ptr %_tmp_old_op3, align 8
  %16 = load ptr, ptr %_tmp_old_op3, align 8
  %cmp4 = icmp ne ptr %16, null
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %do.body1
  %17 = load ptr, ptr %_tmp_op_ptr2, align 8
  store ptr null, ptr %17, align 8
  %18 = load ptr, ptr %_tmp_old_op3, align 8
  store ptr %18, ptr %op.addr.i159, align 8
  %19 = load ptr, ptr %op.addr.i159, align 8
  store ptr %19, ptr %op.addr.i179, align 8
  %20 = load ptr, ptr %op.addr.i179, align 8
  %21 = load i64, ptr %20, align 8
  %conv.i180 = trunc i64 %21 to i32
  %cmp.i181 = icmp slt i32 %conv.i180, 0
  %conv1.i182 = zext i1 %cmp.i181 to i32
  %tobool.i161 = icmp ne i32 %conv1.i182, 0
  br i1 %tobool.i161, label %if.then.i166, label %if.end.i162

if.then.i166:                                     ; preds = %if.then5
  br label %Py_DECREF.exit167

if.end.i162:                                      ; preds = %if.then5
  %22 = load ptr, ptr %op.addr.i159, align 8
  %23 = load i64, ptr %22, align 8
  %dec.i163 = add i64 %23, -1
  store i64 %dec.i163, ptr %22, align 8
  %cmp.i164 = icmp eq i64 %dec.i163, 0
  br i1 %cmp.i164, label %if.then1.i165, label %Py_DECREF.exit167

if.then1.i165:                                    ; preds = %if.end.i162
  %24 = load ptr, ptr %op.addr.i159, align 8
  call void @_Py_Dealloc(ptr noundef %24) #10
  br label %Py_DECREF.exit167

Py_DECREF.exit167:                                ; preds = %if.then1.i165, %if.end.i162, %if.then.i166
  br label %if.end6

if.end6:                                          ; preds = %Py_DECREF.exit167, %do.body1
  br label %do.end7

do.end7:                                          ; preds = %if.end6
  br label %do.body8

do.body8:                                         ; preds = %do.end7
  %25 = load ptr, ptr %state, align 8
  %ScandirIteratorType = getelementptr inbounds %struct._posixstate, ptr %25, i32 0, i32 2
  store ptr %ScandirIteratorType, ptr %_tmp_op_ptr9, align 8
  %26 = load ptr, ptr %_tmp_op_ptr9, align 8
  %27 = load ptr, ptr %26, align 8
  store ptr %27, ptr %_tmp_old_op10, align 8
  %28 = load ptr, ptr %_tmp_old_op10, align 8
  %cmp11 = icmp ne ptr %28, null
  br i1 %cmp11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %do.body8
  %29 = load ptr, ptr %_tmp_op_ptr9, align 8
  store ptr null, ptr %29, align 8
  %30 = load ptr, ptr %_tmp_old_op10, align 8
  store ptr %30, ptr %op.addr.i150, align 8
  %31 = load ptr, ptr %op.addr.i150, align 8
  store ptr %31, ptr %op.addr.i183, align 8
  %32 = load ptr, ptr %op.addr.i183, align 8
  %33 = load i64, ptr %32, align 8
  %conv.i184 = trunc i64 %33 to i32
  %cmp.i185 = icmp slt i32 %conv.i184, 0
  %conv1.i186 = zext i1 %cmp.i185 to i32
  %tobool.i152 = icmp ne i32 %conv1.i186, 0
  br i1 %tobool.i152, label %if.then.i157, label %if.end.i153

if.then.i157:                                     ; preds = %if.then12
  br label %Py_DECREF.exit158

if.end.i153:                                      ; preds = %if.then12
  %34 = load ptr, ptr %op.addr.i150, align 8
  %35 = load i64, ptr %34, align 8
  %dec.i154 = add i64 %35, -1
  store i64 %dec.i154, ptr %34, align 8
  %cmp.i155 = icmp eq i64 %dec.i154, 0
  br i1 %cmp.i155, label %if.then1.i156, label %Py_DECREF.exit158

if.then1.i156:                                    ; preds = %if.end.i153
  %36 = load ptr, ptr %op.addr.i150, align 8
  call void @_Py_Dealloc(ptr noundef %36) #10
  br label %Py_DECREF.exit158

Py_DECREF.exit158:                                ; preds = %if.then1.i156, %if.end.i153, %if.then.i157
  br label %if.end13

if.end13:                                         ; preds = %Py_DECREF.exit158, %do.body8
  br label %do.end14

do.end14:                                         ; preds = %if.end13
  br label %do.body15

do.body15:                                        ; preds = %do.end14
  %37 = load ptr, ptr %state, align 8
  %SchedParamType = getelementptr inbounds %struct._posixstate, ptr %37, i32 0, i32 3
  store ptr %SchedParamType, ptr %_tmp_op_ptr16, align 8
  %38 = load ptr, ptr %_tmp_op_ptr16, align 8
  %39 = load ptr, ptr %38, align 8
  store ptr %39, ptr %_tmp_old_op17, align 8
  %40 = load ptr, ptr %_tmp_old_op17, align 8
  %cmp18 = icmp ne ptr %40, null
  br i1 %cmp18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %do.body15
  %41 = load ptr, ptr %_tmp_op_ptr16, align 8
  store ptr null, ptr %41, align 8
  %42 = load ptr, ptr %_tmp_old_op17, align 8
  store ptr %42, ptr %op.addr.i141, align 8
  %43 = load ptr, ptr %op.addr.i141, align 8
  store ptr %43, ptr %op.addr.i187, align 8
  %44 = load ptr, ptr %op.addr.i187, align 8
  %45 = load i64, ptr %44, align 8
  %conv.i188 = trunc i64 %45 to i32
  %cmp.i189 = icmp slt i32 %conv.i188, 0
  %conv1.i190 = zext i1 %cmp.i189 to i32
  %tobool.i143 = icmp ne i32 %conv1.i190, 0
  br i1 %tobool.i143, label %if.then.i148, label %if.end.i144

if.then.i148:                                     ; preds = %if.then19
  br label %Py_DECREF.exit149

if.end.i144:                                      ; preds = %if.then19
  %46 = load ptr, ptr %op.addr.i141, align 8
  %47 = load i64, ptr %46, align 8
  %dec.i145 = add i64 %47, -1
  store i64 %dec.i145, ptr %46, align 8
  %cmp.i146 = icmp eq i64 %dec.i145, 0
  br i1 %cmp.i146, label %if.then1.i147, label %Py_DECREF.exit149

if.then1.i147:                                    ; preds = %if.end.i144
  %48 = load ptr, ptr %op.addr.i141, align 8
  call void @_Py_Dealloc(ptr noundef %48) #10
  br label %Py_DECREF.exit149

Py_DECREF.exit149:                                ; preds = %if.then1.i147, %if.end.i144, %if.then.i148
  br label %if.end20

if.end20:                                         ; preds = %Py_DECREF.exit149, %do.body15
  br label %do.end21

do.end21:                                         ; preds = %if.end20
  br label %do.body22

do.body22:                                        ; preds = %do.end21
  %49 = load ptr, ptr %state, align 8
  %StatResultType = getelementptr inbounds %struct._posixstate, ptr %49, i32 0, i32 5
  store ptr %StatResultType, ptr %_tmp_op_ptr23, align 8
  %50 = load ptr, ptr %_tmp_op_ptr23, align 8
  %51 = load ptr, ptr %50, align 8
  store ptr %51, ptr %_tmp_old_op24, align 8
  %52 = load ptr, ptr %_tmp_old_op24, align 8
  %cmp25 = icmp ne ptr %52, null
  br i1 %cmp25, label %if.then26, label %if.end27

if.then26:                                        ; preds = %do.body22
  %53 = load ptr, ptr %_tmp_op_ptr23, align 8
  store ptr null, ptr %53, align 8
  %54 = load ptr, ptr %_tmp_old_op24, align 8
  store ptr %54, ptr %op.addr.i132, align 8
  %55 = load ptr, ptr %op.addr.i132, align 8
  store ptr %55, ptr %op.addr.i191, align 8
  %56 = load ptr, ptr %op.addr.i191, align 8
  %57 = load i64, ptr %56, align 8
  %conv.i192 = trunc i64 %57 to i32
  %cmp.i193 = icmp slt i32 %conv.i192, 0
  %conv1.i194 = zext i1 %cmp.i193 to i32
  %tobool.i134 = icmp ne i32 %conv1.i194, 0
  br i1 %tobool.i134, label %if.then.i139, label %if.end.i135

if.then.i139:                                     ; preds = %if.then26
  br label %Py_DECREF.exit140

if.end.i135:                                      ; preds = %if.then26
  %58 = load ptr, ptr %op.addr.i132, align 8
  %59 = load i64, ptr %58, align 8
  %dec.i136 = add i64 %59, -1
  store i64 %dec.i136, ptr %58, align 8
  %cmp.i137 = icmp eq i64 %dec.i136, 0
  br i1 %cmp.i137, label %if.then1.i138, label %Py_DECREF.exit140

if.then1.i138:                                    ; preds = %if.end.i135
  %60 = load ptr, ptr %op.addr.i132, align 8
  call void @_Py_Dealloc(ptr noundef %60) #10
  br label %Py_DECREF.exit140

Py_DECREF.exit140:                                ; preds = %if.then1.i138, %if.end.i135, %if.then.i139
  br label %if.end27

if.end27:                                         ; preds = %Py_DECREF.exit140, %do.body22
  br label %do.end28

do.end28:                                         ; preds = %if.end27
  br label %do.body29

do.body29:                                        ; preds = %do.end28
  %61 = load ptr, ptr %state, align 8
  %StatVFSResultType = getelementptr inbounds %struct._posixstate, ptr %61, i32 0, i32 6
  store ptr %StatVFSResultType, ptr %_tmp_op_ptr30, align 8
  %62 = load ptr, ptr %_tmp_op_ptr30, align 8
  %63 = load ptr, ptr %62, align 8
  store ptr %63, ptr %_tmp_old_op31, align 8
  %64 = load ptr, ptr %_tmp_old_op31, align 8
  %cmp32 = icmp ne ptr %64, null
  br i1 %cmp32, label %if.then33, label %if.end34

if.then33:                                        ; preds = %do.body29
  %65 = load ptr, ptr %_tmp_op_ptr30, align 8
  store ptr null, ptr %65, align 8
  %66 = load ptr, ptr %_tmp_old_op31, align 8
  store ptr %66, ptr %op.addr.i123, align 8
  %67 = load ptr, ptr %op.addr.i123, align 8
  store ptr %67, ptr %op.addr.i195, align 8
  %68 = load ptr, ptr %op.addr.i195, align 8
  %69 = load i64, ptr %68, align 8
  %conv.i196 = trunc i64 %69 to i32
  %cmp.i197 = icmp slt i32 %conv.i196, 0
  %conv1.i198 = zext i1 %cmp.i197 to i32
  %tobool.i125 = icmp ne i32 %conv1.i198, 0
  br i1 %tobool.i125, label %if.then.i130, label %if.end.i126

if.then.i130:                                     ; preds = %if.then33
  br label %Py_DECREF.exit131

if.end.i126:                                      ; preds = %if.then33
  %70 = load ptr, ptr %op.addr.i123, align 8
  %71 = load i64, ptr %70, align 8
  %dec.i127 = add i64 %71, -1
  store i64 %dec.i127, ptr %70, align 8
  %cmp.i128 = icmp eq i64 %dec.i127, 0
  br i1 %cmp.i128, label %if.then1.i129, label %Py_DECREF.exit131

if.then1.i129:                                    ; preds = %if.end.i126
  %72 = load ptr, ptr %op.addr.i123, align 8
  call void @_Py_Dealloc(ptr noundef %72) #10
  br label %Py_DECREF.exit131

Py_DECREF.exit131:                                ; preds = %if.then1.i129, %if.end.i126, %if.then.i130
  br label %if.end34

if.end34:                                         ; preds = %Py_DECREF.exit131, %do.body29
  br label %do.end35

do.end35:                                         ; preds = %if.end34
  br label %do.body36

do.body36:                                        ; preds = %do.end35
  %73 = load ptr, ptr %state, align 8
  %TerminalSizeType = getelementptr inbounds %struct._posixstate, ptr %73, i32 0, i32 7
  store ptr %TerminalSizeType, ptr %_tmp_op_ptr37, align 8
  %74 = load ptr, ptr %_tmp_op_ptr37, align 8
  %75 = load ptr, ptr %74, align 8
  store ptr %75, ptr %_tmp_old_op38, align 8
  %76 = load ptr, ptr %_tmp_old_op38, align 8
  %cmp39 = icmp ne ptr %76, null
  br i1 %cmp39, label %if.then40, label %if.end41

if.then40:                                        ; preds = %do.body36
  %77 = load ptr, ptr %_tmp_op_ptr37, align 8
  store ptr null, ptr %77, align 8
  %78 = load ptr, ptr %_tmp_old_op38, align 8
  store ptr %78, ptr %op.addr.i114, align 8
  %79 = load ptr, ptr %op.addr.i114, align 8
  store ptr %79, ptr %op.addr.i199, align 8
  %80 = load ptr, ptr %op.addr.i199, align 8
  %81 = load i64, ptr %80, align 8
  %conv.i200 = trunc i64 %81 to i32
  %cmp.i201 = icmp slt i32 %conv.i200, 0
  %conv1.i202 = zext i1 %cmp.i201 to i32
  %tobool.i116 = icmp ne i32 %conv1.i202, 0
  br i1 %tobool.i116, label %if.then.i121, label %if.end.i117

if.then.i121:                                     ; preds = %if.then40
  br label %Py_DECREF.exit122

if.end.i117:                                      ; preds = %if.then40
  %82 = load ptr, ptr %op.addr.i114, align 8
  %83 = load i64, ptr %82, align 8
  %dec.i118 = add i64 %83, -1
  store i64 %dec.i118, ptr %82, align 8
  %cmp.i119 = icmp eq i64 %dec.i118, 0
  br i1 %cmp.i119, label %if.then1.i120, label %Py_DECREF.exit122

if.then1.i120:                                    ; preds = %if.end.i117
  %84 = load ptr, ptr %op.addr.i114, align 8
  call void @_Py_Dealloc(ptr noundef %84) #10
  br label %Py_DECREF.exit122

Py_DECREF.exit122:                                ; preds = %if.then1.i120, %if.end.i117, %if.then.i121
  br label %if.end41

if.end41:                                         ; preds = %Py_DECREF.exit122, %do.body36
  br label %do.end42

do.end42:                                         ; preds = %if.end41
  br label %do.body43

do.body43:                                        ; preds = %do.end42
  %85 = load ptr, ptr %state, align 8
  %TimesResultType = getelementptr inbounds %struct._posixstate, ptr %85, i32 0, i32 8
  store ptr %TimesResultType, ptr %_tmp_op_ptr44, align 8
  %86 = load ptr, ptr %_tmp_op_ptr44, align 8
  %87 = load ptr, ptr %86, align 8
  store ptr %87, ptr %_tmp_old_op45, align 8
  %88 = load ptr, ptr %_tmp_old_op45, align 8
  %cmp46 = icmp ne ptr %88, null
  br i1 %cmp46, label %if.then47, label %if.end48

if.then47:                                        ; preds = %do.body43
  %89 = load ptr, ptr %_tmp_op_ptr44, align 8
  store ptr null, ptr %89, align 8
  %90 = load ptr, ptr %_tmp_old_op45, align 8
  store ptr %90, ptr %op.addr.i105, align 8
  %91 = load ptr, ptr %op.addr.i105, align 8
  store ptr %91, ptr %op.addr.i203, align 8
  %92 = load ptr, ptr %op.addr.i203, align 8
  %93 = load i64, ptr %92, align 8
  %conv.i204 = trunc i64 %93 to i32
  %cmp.i205 = icmp slt i32 %conv.i204, 0
  %conv1.i206 = zext i1 %cmp.i205 to i32
  %tobool.i107 = icmp ne i32 %conv1.i206, 0
  br i1 %tobool.i107, label %if.then.i112, label %if.end.i108

if.then.i112:                                     ; preds = %if.then47
  br label %Py_DECREF.exit113

if.end.i108:                                      ; preds = %if.then47
  %94 = load ptr, ptr %op.addr.i105, align 8
  %95 = load i64, ptr %94, align 8
  %dec.i109 = add i64 %95, -1
  store i64 %dec.i109, ptr %94, align 8
  %cmp.i110 = icmp eq i64 %dec.i109, 0
  br i1 %cmp.i110, label %if.then1.i111, label %Py_DECREF.exit113

if.then1.i111:                                    ; preds = %if.end.i108
  %96 = load ptr, ptr %op.addr.i105, align 8
  call void @_Py_Dealloc(ptr noundef %96) #10
  br label %Py_DECREF.exit113

Py_DECREF.exit113:                                ; preds = %if.then1.i111, %if.end.i108, %if.then.i112
  br label %if.end48

if.end48:                                         ; preds = %Py_DECREF.exit113, %do.body43
  br label %do.end49

do.end49:                                         ; preds = %if.end48
  br label %do.body50

do.body50:                                        ; preds = %do.end49
  %97 = load ptr, ptr %state, align 8
  %UnameResultType = getelementptr inbounds %struct._posixstate, ptr %97, i32 0, i32 9
  store ptr %UnameResultType, ptr %_tmp_op_ptr51, align 8
  %98 = load ptr, ptr %_tmp_op_ptr51, align 8
  %99 = load ptr, ptr %98, align 8
  store ptr %99, ptr %_tmp_old_op52, align 8
  %100 = load ptr, ptr %_tmp_old_op52, align 8
  %cmp53 = icmp ne ptr %100, null
  br i1 %cmp53, label %if.then54, label %if.end55

if.then54:                                        ; preds = %do.body50
  %101 = load ptr, ptr %_tmp_op_ptr51, align 8
  store ptr null, ptr %101, align 8
  %102 = load ptr, ptr %_tmp_old_op52, align 8
  store ptr %102, ptr %op.addr.i96, align 8
  %103 = load ptr, ptr %op.addr.i96, align 8
  store ptr %103, ptr %op.addr.i207, align 8
  %104 = load ptr, ptr %op.addr.i207, align 8
  %105 = load i64, ptr %104, align 8
  %conv.i208 = trunc i64 %105 to i32
  %cmp.i209 = icmp slt i32 %conv.i208, 0
  %conv1.i210 = zext i1 %cmp.i209 to i32
  %tobool.i98 = icmp ne i32 %conv1.i210, 0
  br i1 %tobool.i98, label %if.then.i103, label %if.end.i99

if.then.i103:                                     ; preds = %if.then54
  br label %Py_DECREF.exit104

if.end.i99:                                       ; preds = %if.then54
  %106 = load ptr, ptr %op.addr.i96, align 8
  %107 = load i64, ptr %106, align 8
  %dec.i100 = add i64 %107, -1
  store i64 %dec.i100, ptr %106, align 8
  %cmp.i101 = icmp eq i64 %dec.i100, 0
  br i1 %cmp.i101, label %if.then1.i102, label %Py_DECREF.exit104

if.then1.i102:                                    ; preds = %if.end.i99
  %108 = load ptr, ptr %op.addr.i96, align 8
  call void @_Py_Dealloc(ptr noundef %108) #10
  br label %Py_DECREF.exit104

Py_DECREF.exit104:                                ; preds = %if.then1.i102, %if.end.i99, %if.then.i103
  br label %if.end55

if.end55:                                         ; preds = %Py_DECREF.exit104, %do.body50
  br label %do.end56

do.end56:                                         ; preds = %if.end55
  br label %do.body57

do.body57:                                        ; preds = %do.end56
  %109 = load ptr, ptr %state, align 8
  %WaitidResultType = getelementptr inbounds %struct._posixstate, ptr %109, i32 0, i32 10
  store ptr %WaitidResultType, ptr %_tmp_op_ptr58, align 8
  %110 = load ptr, ptr %_tmp_op_ptr58, align 8
  %111 = load ptr, ptr %110, align 8
  store ptr %111, ptr %_tmp_old_op59, align 8
  %112 = load ptr, ptr %_tmp_old_op59, align 8
  %cmp60 = icmp ne ptr %112, null
  br i1 %cmp60, label %if.then61, label %if.end62

if.then61:                                        ; preds = %do.body57
  %113 = load ptr, ptr %_tmp_op_ptr58, align 8
  store ptr null, ptr %113, align 8
  %114 = load ptr, ptr %_tmp_old_op59, align 8
  store ptr %114, ptr %op.addr.i87, align 8
  %115 = load ptr, ptr %op.addr.i87, align 8
  store ptr %115, ptr %op.addr.i211, align 8
  %116 = load ptr, ptr %op.addr.i211, align 8
  %117 = load i64, ptr %116, align 8
  %conv.i212 = trunc i64 %117 to i32
  %cmp.i213 = icmp slt i32 %conv.i212, 0
  %conv1.i214 = zext i1 %cmp.i213 to i32
  %tobool.i89 = icmp ne i32 %conv1.i214, 0
  br i1 %tobool.i89, label %if.then.i94, label %if.end.i90

if.then.i94:                                      ; preds = %if.then61
  br label %Py_DECREF.exit95

if.end.i90:                                       ; preds = %if.then61
  %118 = load ptr, ptr %op.addr.i87, align 8
  %119 = load i64, ptr %118, align 8
  %dec.i91 = add i64 %119, -1
  store i64 %dec.i91, ptr %118, align 8
  %cmp.i92 = icmp eq i64 %dec.i91, 0
  br i1 %cmp.i92, label %if.then1.i93, label %Py_DECREF.exit95

if.then1.i93:                                     ; preds = %if.end.i90
  %120 = load ptr, ptr %op.addr.i87, align 8
  call void @_Py_Dealloc(ptr noundef %120) #10
  br label %Py_DECREF.exit95

Py_DECREF.exit95:                                 ; preds = %if.then1.i93, %if.end.i90, %if.then.i94
  br label %if.end62

if.end62:                                         ; preds = %Py_DECREF.exit95, %do.body57
  br label %do.end63

do.end63:                                         ; preds = %if.end62
  br label %do.body64

do.body64:                                        ; preds = %do.end63
  %121 = load ptr, ptr %state, align 8
  %struct_rusage = getelementptr inbounds %struct._posixstate, ptr %121, i32 0, i32 11
  store ptr %struct_rusage, ptr %_tmp_op_ptr65, align 8
  %122 = load ptr, ptr %_tmp_op_ptr65, align 8
  %123 = load ptr, ptr %122, align 8
  store ptr %123, ptr %_tmp_old_op66, align 8
  %124 = load ptr, ptr %_tmp_old_op66, align 8
  %cmp67 = icmp ne ptr %124, null
  br i1 %cmp67, label %if.then68, label %if.end69

if.then68:                                        ; preds = %do.body64
  %125 = load ptr, ptr %_tmp_op_ptr65, align 8
  store ptr null, ptr %125, align 8
  %126 = load ptr, ptr %_tmp_old_op66, align 8
  store ptr %126, ptr %op.addr.i78, align 8
  %127 = load ptr, ptr %op.addr.i78, align 8
  store ptr %127, ptr %op.addr.i215, align 8
  %128 = load ptr, ptr %op.addr.i215, align 8
  %129 = load i64, ptr %128, align 8
  %conv.i216 = trunc i64 %129 to i32
  %cmp.i217 = icmp slt i32 %conv.i216, 0
  %conv1.i218 = zext i1 %cmp.i217 to i32
  %tobool.i80 = icmp ne i32 %conv1.i218, 0
  br i1 %tobool.i80, label %if.then.i85, label %if.end.i81

if.then.i85:                                      ; preds = %if.then68
  br label %Py_DECREF.exit86

if.end.i81:                                       ; preds = %if.then68
  %130 = load ptr, ptr %op.addr.i78, align 8
  %131 = load i64, ptr %130, align 8
  %dec.i82 = add i64 %131, -1
  store i64 %dec.i82, ptr %130, align 8
  %cmp.i83 = icmp eq i64 %dec.i82, 0
  br i1 %cmp.i83, label %if.then1.i84, label %Py_DECREF.exit86

if.then1.i84:                                     ; preds = %if.end.i81
  %132 = load ptr, ptr %op.addr.i78, align 8
  call void @_Py_Dealloc(ptr noundef %132) #10
  br label %Py_DECREF.exit86

Py_DECREF.exit86:                                 ; preds = %if.then1.i84, %if.end.i81, %if.then.i85
  br label %if.end69

if.end69:                                         ; preds = %Py_DECREF.exit86, %do.body64
  br label %do.end70

do.end70:                                         ; preds = %if.end69
  br label %do.body71

do.body71:                                        ; preds = %do.end70
  %133 = load ptr, ptr %state, align 8
  %st_mode = getelementptr inbounds %struct._posixstate, ptr %133, i32 0, i32 12
  store ptr %st_mode, ptr %_tmp_op_ptr72, align 8
  %134 = load ptr, ptr %_tmp_op_ptr72, align 8
  %135 = load ptr, ptr %134, align 8
  store ptr %135, ptr %_tmp_old_op73, align 8
  %136 = load ptr, ptr %_tmp_old_op73, align 8
  %cmp74 = icmp ne ptr %136, null
  br i1 %cmp74, label %if.then75, label %if.end76

if.then75:                                        ; preds = %do.body71
  %137 = load ptr, ptr %_tmp_op_ptr72, align 8
  store ptr null, ptr %137, align 8
  %138 = load ptr, ptr %_tmp_old_op73, align 8
  store ptr %138, ptr %op.addr.i, align 8
  %139 = load ptr, ptr %op.addr.i, align 8
  store ptr %139, ptr %op.addr.i219, align 8
  %140 = load ptr, ptr %op.addr.i219, align 8
  %141 = load i64, ptr %140, align 8
  %conv.i220 = trunc i64 %141 to i32
  %cmp.i221 = icmp slt i32 %conv.i220, 0
  %conv1.i222 = zext i1 %cmp.i221 to i32
  %tobool.i = icmp ne i32 %conv1.i222, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then75
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.then75
  %142 = load ptr, ptr %op.addr.i, align 8
  %143 = load i64, ptr %142, align 8
  %dec.i = add i64 %143, -1
  store i64 %dec.i, ptr %142, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %144 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %144) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  br label %if.end76

if.end76:                                         ; preds = %Py_DECREF.exit, %do.body71
  br label %do.end77

do.end77:                                         ; preds = %if.end76
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal void @_posix_free(ptr noundef %module) #0 {
entry:
  %module.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %call = call i32 @_posix_clear(ptr noundef %0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal ptr @os_stat(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [3 x ptr], align 16
  %noptargs = alloca i64, align 8
  %path = alloca %struct.path_t, align 8
  %dir_fd = alloca i32, align 4
  %follow_symlinks = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 1
  store i64 %sub, ptr %noptargs, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %path, ptr align 8 @__const.os_stat.path, i64 72, i1 false)
  store i32 -100, ptr %dir_fd, align 4
  store i32 1, ptr %follow_symlinks, align 4
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 1, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 1
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [3 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @os_stat._parser, i32 noundef 1, i32 noundef 1, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %12, i64 0
  %13 = load ptr, ptr %arrayidx, align 8
  %call12 = call i32 @path_converter(ptr noundef %13, ptr noundef %path)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end
  br label %exit

if.end15:                                         ; preds = %if.end
  %14 = load i64, ptr %noptargs, align 8
  %tobool16 = icmp ne i64 %14, 0
  br i1 %tobool16, label %if.end18, label %if.then17

if.then17:                                        ; preds = %if.end15
  br label %skip_optional_kwonly

if.end18:                                         ; preds = %if.end15
  %15 = load ptr, ptr %args.addr, align 8
  %arrayidx19 = getelementptr ptr, ptr %15, i64 1
  %16 = load ptr, ptr %arrayidx19, align 8
  %tobool20 = icmp ne ptr %16, null
  br i1 %tobool20, label %if.then21, label %if.end30

if.then21:                                        ; preds = %if.end18
  %17 = load ptr, ptr %args.addr, align 8
  %arrayidx22 = getelementptr ptr, ptr %17, i64 1
  %18 = load ptr, ptr %arrayidx22, align 8
  %call23 = call i32 @dir_fd_converter(ptr noundef %18, ptr noundef %dir_fd)
  %tobool24 = icmp ne i32 %call23, 0
  br i1 %tobool24, label %if.end26, label %if.then25

if.then25:                                        ; preds = %if.then21
  br label %exit

if.end26:                                         ; preds = %if.then21
  %19 = load i64, ptr %noptargs, align 8
  %dec = add i64 %19, -1
  store i64 %dec, ptr %noptargs, align 8
  %tobool27 = icmp ne i64 %dec, 0
  br i1 %tobool27, label %if.end29, label %if.then28

if.then28:                                        ; preds = %if.end26
  br label %skip_optional_kwonly

if.end29:                                         ; preds = %if.end26
  br label %if.end30

if.end30:                                         ; preds = %if.end29, %if.end18
  %20 = load ptr, ptr %args.addr, align 8
  %arrayidx31 = getelementptr ptr, ptr %20, i64 2
  %21 = load ptr, ptr %arrayidx31, align 8
  %call32 = call i32 @PyObject_IsTrue(ptr noundef %21)
  store i32 %call32, ptr %follow_symlinks, align 4
  %22 = load i32, ptr %follow_symlinks, align 4
  %cmp33 = icmp slt i32 %22, 0
  br i1 %cmp33, label %if.then34, label %if.end35

if.then34:                                        ; preds = %if.end30
  br label %exit

if.end35:                                         ; preds = %if.end30
  br label %skip_optional_kwonly

skip_optional_kwonly:                             ; preds = %if.end35, %if.then28, %if.then17
  %23 = load ptr, ptr %module.addr, align 8
  %24 = load i32, ptr %dir_fd, align 4
  %25 = load i32, ptr %follow_symlinks, align 4
  %call36 = call ptr @os_stat_impl(ptr noundef %23, ptr noundef %path, i32 noundef %24, i32 noundef %25)
  store ptr %call36, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional_kwonly, %if.then34, %if.then25, %if.then14, %if.then
  call void @path_cleanup(ptr noundef %path)
  %26 = load ptr, ptr %return_value, align 8
  ret ptr %26
}

; Function Attrs: nounwind uwtable
define internal ptr @os_access(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [5 x ptr], align 16
  %noptargs = alloca i64, align 8
  %path = alloca %struct.path_t, align 8
  %mode = alloca i32, align 4
  %dir_fd = alloca i32, align 4
  %effective_ids = alloca i32, align 4
  %follow_symlinks = alloca i32, align 4
  %_return_value = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 2
  store i64 %sub, ptr %noptargs, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %path, ptr align 8 @__const.os_access.path, i64 72, i1 false)
  store i32 -100, ptr %dir_fd, align 4
  store i32 0, ptr %effective_ids, align 4
  store i32 1, ptr %follow_symlinks, align 4
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 2, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 2
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [5 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @os_access._parser, i32 noundef 2, i32 noundef 2, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %12, i64 0
  %13 = load ptr, ptr %arrayidx, align 8
  %call12 = call i32 @path_converter(ptr noundef %13, ptr noundef %path)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end
  br label %exit

if.end15:                                         ; preds = %if.end
  %14 = load ptr, ptr %args.addr, align 8
  %arrayidx16 = getelementptr ptr, ptr %14, i64 1
  %15 = load ptr, ptr %arrayidx16, align 8
  %call17 = call i32 @PyLong_AsInt(ptr noundef %15)
  store i32 %call17, ptr %mode, align 4
  %16 = load i32, ptr %mode, align 4
  %cmp18 = icmp eq i32 %16, -1
  br i1 %cmp18, label %land.lhs.true19, label %if.end23

land.lhs.true19:                                  ; preds = %if.end15
  %call20 = call ptr @PyErr_Occurred()
  %tobool21 = icmp ne ptr %call20, null
  br i1 %tobool21, label %if.then22, label %if.end23

if.then22:                                        ; preds = %land.lhs.true19
  br label %exit

if.end23:                                         ; preds = %land.lhs.true19, %if.end15
  %17 = load i64, ptr %noptargs, align 8
  %tobool24 = icmp ne i64 %17, 0
  br i1 %tobool24, label %if.end26, label %if.then25

if.then25:                                        ; preds = %if.end23
  br label %skip_optional_kwonly

if.end26:                                         ; preds = %if.end23
  %18 = load ptr, ptr %args.addr, align 8
  %arrayidx27 = getelementptr ptr, ptr %18, i64 2
  %19 = load ptr, ptr %arrayidx27, align 8
  %tobool28 = icmp ne ptr %19, null
  br i1 %tobool28, label %if.then29, label %if.end38

if.then29:                                        ; preds = %if.end26
  %20 = load ptr, ptr %args.addr, align 8
  %arrayidx30 = getelementptr ptr, ptr %20, i64 2
  %21 = load ptr, ptr %arrayidx30, align 8
  %call31 = call i32 @dir_fd_converter(ptr noundef %21, ptr noundef %dir_fd)
  %tobool32 = icmp ne i32 %call31, 0
  br i1 %tobool32, label %if.end34, label %if.then33

if.then33:                                        ; preds = %if.then29
  br label %exit

if.end34:                                         ; preds = %if.then29
  %22 = load i64, ptr %noptargs, align 8
  %dec = add i64 %22, -1
  store i64 %dec, ptr %noptargs, align 8
  %tobool35 = icmp ne i64 %dec, 0
  br i1 %tobool35, label %if.end37, label %if.then36

if.then36:                                        ; preds = %if.end34
  br label %skip_optional_kwonly

if.end37:                                         ; preds = %if.end34
  br label %if.end38

if.end38:                                         ; preds = %if.end37, %if.end26
  %23 = load ptr, ptr %args.addr, align 8
  %arrayidx39 = getelementptr ptr, ptr %23, i64 3
  %24 = load ptr, ptr %arrayidx39, align 8
  %tobool40 = icmp ne ptr %24, null
  br i1 %tobool40, label %if.then41, label %if.end51

if.then41:                                        ; preds = %if.end38
  %25 = load ptr, ptr %args.addr, align 8
  %arrayidx42 = getelementptr ptr, ptr %25, i64 3
  %26 = load ptr, ptr %arrayidx42, align 8
  %call43 = call i32 @PyObject_IsTrue(ptr noundef %26)
  store i32 %call43, ptr %effective_ids, align 4
  %27 = load i32, ptr %effective_ids, align 4
  %cmp44 = icmp slt i32 %27, 0
  br i1 %cmp44, label %if.then45, label %if.end46

if.then45:                                        ; preds = %if.then41
  br label %exit

if.end46:                                         ; preds = %if.then41
  %28 = load i64, ptr %noptargs, align 8
  %dec47 = add i64 %28, -1
  store i64 %dec47, ptr %noptargs, align 8
  %tobool48 = icmp ne i64 %dec47, 0
  br i1 %tobool48, label %if.end50, label %if.then49

if.then49:                                        ; preds = %if.end46
  br label %skip_optional_kwonly

if.end50:                                         ; preds = %if.end46
  br label %if.end51

if.end51:                                         ; preds = %if.end50, %if.end38
  %29 = load ptr, ptr %args.addr, align 8
  %arrayidx52 = getelementptr ptr, ptr %29, i64 4
  %30 = load ptr, ptr %arrayidx52, align 8
  %call53 = call i32 @PyObject_IsTrue(ptr noundef %30)
  store i32 %call53, ptr %follow_symlinks, align 4
  %31 = load i32, ptr %follow_symlinks, align 4
  %cmp54 = icmp slt i32 %31, 0
  br i1 %cmp54, label %if.then55, label %if.end56

if.then55:                                        ; preds = %if.end51
  br label %exit

if.end56:                                         ; preds = %if.end51
  br label %skip_optional_kwonly

skip_optional_kwonly:                             ; preds = %if.end56, %if.then49, %if.then36, %if.then25
  %32 = load ptr, ptr %module.addr, align 8
  %33 = load i32, ptr %mode, align 4
  %34 = load i32, ptr %dir_fd, align 4
  %35 = load i32, ptr %effective_ids, align 4
  %36 = load i32, ptr %follow_symlinks, align 4
  %call57 = call i32 @os_access_impl(ptr noundef %32, ptr noundef %path, i32 noundef %33, i32 noundef %34, i32 noundef %35, i32 noundef %36)
  store i32 %call57, ptr %_return_value, align 4
  %37 = load i32, ptr %_return_value, align 4
  %cmp58 = icmp eq i32 %37, -1
  br i1 %cmp58, label %land.lhs.true59, label %if.end63

land.lhs.true59:                                  ; preds = %skip_optional_kwonly
  %call60 = call ptr @PyErr_Occurred()
  %tobool61 = icmp ne ptr %call60, null
  br i1 %tobool61, label %if.then62, label %if.end63

if.then62:                                        ; preds = %land.lhs.true59
  br label %exit

if.end63:                                         ; preds = %land.lhs.true59, %skip_optional_kwonly
  %38 = load i32, ptr %_return_value, align 4
  %conv = sext i32 %38 to i64
  %call64 = call ptr @PyBool_FromLong(i64 noundef %conv)
  store ptr %call64, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end63, %if.then62, %if.then55, %if.then45, %if.then33, %if.then22, %if.then14, %if.then
  call void @path_cleanup(ptr noundef %path)
  %39 = load ptr, ptr %return_value, align 8
  ret ptr %39
}

; Function Attrs: nounwind uwtable
define internal ptr @os_ttyname(ptr noundef %module, ptr noundef %arg) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %fd = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %call = call i32 @PyLong_AsInt(ptr noundef %0)
  store i32 %call, ptr %fd, align 4
  %1 = load i32, ptr %fd, align 4
  %cmp = icmp eq i32 %1, -1
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %call1 = call ptr @PyErr_Occurred()
  %tobool = icmp ne ptr %call1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  br label %exit

if.end:                                           ; preds = %land.lhs.true, %entry
  %2 = load ptr, ptr %module.addr, align 8
  %3 = load i32, ptr %fd, align 4
  %call2 = call ptr @os_ttyname_impl(ptr noundef %2, i32 noundef %3)
  store ptr %call2, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end, %if.then
  %4 = load ptr, ptr %return_value, align 8
  ret ptr %4
}

; Function Attrs: nounwind uwtable
define internal ptr @os_chdir(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [1 x ptr], align 8
  %path = alloca %struct.path_t, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %path, ptr align 8 @__const.os_chdir.path, i64 72, i1 false)
  %0 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 1, %1
  br i1 %cmp1, label %land.lhs.true2, label %cond.false

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %2, 1
  br i1 %cmp3, label %land.lhs.true4, label %cond.false

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %3 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %3, null
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true4
  %4 = load ptr, ptr %args.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  %5 = load ptr, ptr %args.addr, align 8
  %6 = load i64, ptr %nargs.addr, align 8
  %7 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [1 x ptr], ptr %argsbuf, i64 0, i64 0
  %call = call ptr @_PyArg_UnpackKeywords(ptr noundef %5, i64 noundef %6, ptr noundef null, ptr noundef %7, ptr noundef @os_chdir._parser, i32 noundef 1, i32 noundef 1, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %4, %cond.true ], [ %call, %cond.false ]
  store ptr %cond, ptr %args.addr, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  br label %exit

if.end:                                           ; preds = %cond.end
  %9 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %9, i64 0
  %10 = load ptr, ptr %arrayidx, align 8
  %call6 = call i32 @path_converter(ptr noundef %10, ptr noundef %path)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %if.end
  br label %exit

if.end9:                                          ; preds = %if.end
  %11 = load ptr, ptr %module.addr, align 8
  %call10 = call ptr @os_chdir_impl(ptr noundef %11, ptr noundef %path)
  store ptr %call10, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end9, %if.then8, %if.then
  call void @path_cleanup(ptr noundef %path)
  %12 = load ptr, ptr %return_value, align 8
  ret ptr %12
}

; Function Attrs: nounwind uwtable
define internal ptr @os_chmod(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [4 x ptr], align 16
  %noptargs = alloca i64, align 8
  %path = alloca %struct.path_t, align 8
  %mode = alloca i32, align 4
  %dir_fd = alloca i32, align 4
  %follow_symlinks = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 2
  store i64 %sub, ptr %noptargs, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %path, ptr align 8 @__const.os_chmod.path, i64 72, i1 false)
  store i32 -100, ptr %dir_fd, align 4
  store i32 1, ptr %follow_symlinks, align 4
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 2, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 2
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [4 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @os_chmod._parser, i32 noundef 2, i32 noundef 2, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %12, i64 0
  %13 = load ptr, ptr %arrayidx, align 8
  %call12 = call i32 @path_converter(ptr noundef %13, ptr noundef %path)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end
  br label %exit

if.end15:                                         ; preds = %if.end
  %14 = load ptr, ptr %args.addr, align 8
  %arrayidx16 = getelementptr ptr, ptr %14, i64 1
  %15 = load ptr, ptr %arrayidx16, align 8
  %call17 = call i32 @PyLong_AsInt(ptr noundef %15)
  store i32 %call17, ptr %mode, align 4
  %16 = load i32, ptr %mode, align 4
  %cmp18 = icmp eq i32 %16, -1
  br i1 %cmp18, label %land.lhs.true19, label %if.end23

land.lhs.true19:                                  ; preds = %if.end15
  %call20 = call ptr @PyErr_Occurred()
  %tobool21 = icmp ne ptr %call20, null
  br i1 %tobool21, label %if.then22, label %if.end23

if.then22:                                        ; preds = %land.lhs.true19
  br label %exit

if.end23:                                         ; preds = %land.lhs.true19, %if.end15
  %17 = load i64, ptr %noptargs, align 8
  %tobool24 = icmp ne i64 %17, 0
  br i1 %tobool24, label %if.end26, label %if.then25

if.then25:                                        ; preds = %if.end23
  br label %skip_optional_kwonly

if.end26:                                         ; preds = %if.end23
  %18 = load ptr, ptr %args.addr, align 8
  %arrayidx27 = getelementptr ptr, ptr %18, i64 2
  %19 = load ptr, ptr %arrayidx27, align 8
  %tobool28 = icmp ne ptr %19, null
  br i1 %tobool28, label %if.then29, label %if.end38

if.then29:                                        ; preds = %if.end26
  %20 = load ptr, ptr %args.addr, align 8
  %arrayidx30 = getelementptr ptr, ptr %20, i64 2
  %21 = load ptr, ptr %arrayidx30, align 8
  %call31 = call i32 @dir_fd_converter(ptr noundef %21, ptr noundef %dir_fd)
  %tobool32 = icmp ne i32 %call31, 0
  br i1 %tobool32, label %if.end34, label %if.then33

if.then33:                                        ; preds = %if.then29
  br label %exit

if.end34:                                         ; preds = %if.then29
  %22 = load i64, ptr %noptargs, align 8
  %dec = add i64 %22, -1
  store i64 %dec, ptr %noptargs, align 8
  %tobool35 = icmp ne i64 %dec, 0
  br i1 %tobool35, label %if.end37, label %if.then36

if.then36:                                        ; preds = %if.end34
  br label %skip_optional_kwonly

if.end37:                                         ; preds = %if.end34
  br label %if.end38

if.end38:                                         ; preds = %if.end37, %if.end26
  %23 = load ptr, ptr %args.addr, align 8
  %arrayidx39 = getelementptr ptr, ptr %23, i64 3
  %24 = load ptr, ptr %arrayidx39, align 8
  %call40 = call i32 @PyObject_IsTrue(ptr noundef %24)
  store i32 %call40, ptr %follow_symlinks, align 4
  %25 = load i32, ptr %follow_symlinks, align 4
  %cmp41 = icmp slt i32 %25, 0
  br i1 %cmp41, label %if.then42, label %if.end43

if.then42:                                        ; preds = %if.end38
  br label %exit

if.end43:                                         ; preds = %if.end38
  br label %skip_optional_kwonly

skip_optional_kwonly:                             ; preds = %if.end43, %if.then36, %if.then25
  %26 = load ptr, ptr %module.addr, align 8
  %27 = load i32, ptr %mode, align 4
  %28 = load i32, ptr %dir_fd, align 4
  %29 = load i32, ptr %follow_symlinks, align 4
  %call44 = call ptr @os_chmod_impl(ptr noundef %26, ptr noundef %path, i32 noundef %27, i32 noundef %28, i32 noundef %29)
  store ptr %call44, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional_kwonly, %if.then42, %if.then33, %if.then22, %if.then14, %if.then
  call void @path_cleanup(ptr noundef %path)
  %30 = load ptr, ptr %return_value, align 8
  ret ptr %30
}

; Function Attrs: nounwind uwtable
define internal ptr @os_fchmod(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [2 x ptr], align 16
  %fd = alloca i32, align 4
  %mode = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 2, %1
  br i1 %cmp1, label %land.lhs.true2, label %cond.false

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %2, 2
  br i1 %cmp3, label %land.lhs.true4, label %cond.false

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %3 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %3, null
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true4
  %4 = load ptr, ptr %args.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  %5 = load ptr, ptr %args.addr, align 8
  %6 = load i64, ptr %nargs.addr, align 8
  %7 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [2 x ptr], ptr %argsbuf, i64 0, i64 0
  %call = call ptr @_PyArg_UnpackKeywords(ptr noundef %5, i64 noundef %6, ptr noundef null, ptr noundef %7, ptr noundef @os_fchmod._parser, i32 noundef 2, i32 noundef 2, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %4, %cond.true ], [ %call, %cond.false ]
  store ptr %cond, ptr %args.addr, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  br label %exit

if.end:                                           ; preds = %cond.end
  %9 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %9, i64 0
  %10 = load ptr, ptr %arrayidx, align 8
  %call6 = call i32 @PyLong_AsInt(ptr noundef %10)
  store i32 %call6, ptr %fd, align 4
  %11 = load i32, ptr %fd, align 4
  %cmp7 = icmp eq i32 %11, -1
  br i1 %cmp7, label %land.lhs.true8, label %if.end12

land.lhs.true8:                                   ; preds = %if.end
  %call9 = call ptr @PyErr_Occurred()
  %tobool10 = icmp ne ptr %call9, null
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %land.lhs.true8
  br label %exit

if.end12:                                         ; preds = %land.lhs.true8, %if.end
  %12 = load ptr, ptr %args.addr, align 8
  %arrayidx13 = getelementptr ptr, ptr %12, i64 1
  %13 = load ptr, ptr %arrayidx13, align 8
  %call14 = call i32 @PyLong_AsInt(ptr noundef %13)
  store i32 %call14, ptr %mode, align 4
  %14 = load i32, ptr %mode, align 4
  %cmp15 = icmp eq i32 %14, -1
  br i1 %cmp15, label %land.lhs.true16, label %if.end20

land.lhs.true16:                                  ; preds = %if.end12
  %call17 = call ptr @PyErr_Occurred()
  %tobool18 = icmp ne ptr %call17, null
  br i1 %tobool18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %land.lhs.true16
  br label %exit

if.end20:                                         ; preds = %land.lhs.true16, %if.end12
  %15 = load ptr, ptr %module.addr, align 8
  %16 = load i32, ptr %fd, align 4
  %17 = load i32, ptr %mode, align 4
  %call21 = call ptr @os_fchmod_impl(ptr noundef %15, i32 noundef %16, i32 noundef %17)
  store ptr %call21, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end20, %if.then19, %if.then11, %if.then
  %18 = load ptr, ptr %return_value, align 8
  ret ptr %18
}

; Function Attrs: nounwind uwtable
define internal ptr @os_chown(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [5 x ptr], align 16
  %noptargs = alloca i64, align 8
  %path = alloca %struct.path_t, align 8
  %uid = alloca i32, align 4
  %gid = alloca i32, align 4
  %dir_fd = alloca i32, align 4
  %follow_symlinks = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 3
  store i64 %sub, ptr %noptargs, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %path, ptr align 8 @__const.os_chown.path, i64 72, i1 false)
  store i32 -100, ptr %dir_fd, align 4
  store i32 1, ptr %follow_symlinks, align 4
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 3, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 3
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [5 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @os_chown._parser, i32 noundef 3, i32 noundef 3, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %12, i64 0
  %13 = load ptr, ptr %arrayidx, align 8
  %call12 = call i32 @path_converter(ptr noundef %13, ptr noundef %path)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end
  br label %exit

if.end15:                                         ; preds = %if.end
  %14 = load ptr, ptr %args.addr, align 8
  %arrayidx16 = getelementptr ptr, ptr %14, i64 1
  %15 = load ptr, ptr %arrayidx16, align 8
  %call17 = call i32 @_Py_Uid_Converter(ptr noundef %15, ptr noundef %uid)
  %tobool18 = icmp ne i32 %call17, 0
  br i1 %tobool18, label %if.end20, label %if.then19

if.then19:                                        ; preds = %if.end15
  br label %exit

if.end20:                                         ; preds = %if.end15
  %16 = load ptr, ptr %args.addr, align 8
  %arrayidx21 = getelementptr ptr, ptr %16, i64 2
  %17 = load ptr, ptr %arrayidx21, align 8
  %call22 = call i32 @_Py_Gid_Converter(ptr noundef %17, ptr noundef %gid)
  %tobool23 = icmp ne i32 %call22, 0
  br i1 %tobool23, label %if.end25, label %if.then24

if.then24:                                        ; preds = %if.end20
  br label %exit

if.end25:                                         ; preds = %if.end20
  %18 = load i64, ptr %noptargs, align 8
  %tobool26 = icmp ne i64 %18, 0
  br i1 %tobool26, label %if.end28, label %if.then27

if.then27:                                        ; preds = %if.end25
  br label %skip_optional_kwonly

if.end28:                                         ; preds = %if.end25
  %19 = load ptr, ptr %args.addr, align 8
  %arrayidx29 = getelementptr ptr, ptr %19, i64 3
  %20 = load ptr, ptr %arrayidx29, align 8
  %tobool30 = icmp ne ptr %20, null
  br i1 %tobool30, label %if.then31, label %if.end40

if.then31:                                        ; preds = %if.end28
  %21 = load ptr, ptr %args.addr, align 8
  %arrayidx32 = getelementptr ptr, ptr %21, i64 3
  %22 = load ptr, ptr %arrayidx32, align 8
  %call33 = call i32 @dir_fd_converter(ptr noundef %22, ptr noundef %dir_fd)
  %tobool34 = icmp ne i32 %call33, 0
  br i1 %tobool34, label %if.end36, label %if.then35

if.then35:                                        ; preds = %if.then31
  br label %exit

if.end36:                                         ; preds = %if.then31
  %23 = load i64, ptr %noptargs, align 8
  %dec = add i64 %23, -1
  store i64 %dec, ptr %noptargs, align 8
  %tobool37 = icmp ne i64 %dec, 0
  br i1 %tobool37, label %if.end39, label %if.then38

if.then38:                                        ; preds = %if.end36
  br label %skip_optional_kwonly

if.end39:                                         ; preds = %if.end36
  br label %if.end40

if.end40:                                         ; preds = %if.end39, %if.end28
  %24 = load ptr, ptr %args.addr, align 8
  %arrayidx41 = getelementptr ptr, ptr %24, i64 4
  %25 = load ptr, ptr %arrayidx41, align 8
  %call42 = call i32 @PyObject_IsTrue(ptr noundef %25)
  store i32 %call42, ptr %follow_symlinks, align 4
  %26 = load i32, ptr %follow_symlinks, align 4
  %cmp43 = icmp slt i32 %26, 0
  br i1 %cmp43, label %if.then44, label %if.end45

if.then44:                                        ; preds = %if.end40
  br label %exit

if.end45:                                         ; preds = %if.end40
  br label %skip_optional_kwonly

skip_optional_kwonly:                             ; preds = %if.end45, %if.then38, %if.then27
  %27 = load ptr, ptr %module.addr, align 8
  %28 = load i32, ptr %uid, align 4
  %29 = load i32, ptr %gid, align 4
  %30 = load i32, ptr %dir_fd, align 4
  %31 = load i32, ptr %follow_symlinks, align 4
  %call46 = call ptr @os_chown_impl(ptr noundef %27, ptr noundef %path, i32 noundef %28, i32 noundef %29, i32 noundef %30, i32 noundef %31)
  store ptr %call46, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional_kwonly, %if.then44, %if.then35, %if.then24, %if.then19, %if.then14, %if.then
  call void @path_cleanup(ptr noundef %path)
  %32 = load ptr, ptr %return_value, align 8
  ret ptr %32
}

; Function Attrs: nounwind uwtable
define internal ptr @os_fchown(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [3 x ptr], align 16
  %fd = alloca i32, align 4
  %uid = alloca i32, align 4
  %gid = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 3, %1
  br i1 %cmp1, label %land.lhs.true2, label %cond.false

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %2, 3
  br i1 %cmp3, label %land.lhs.true4, label %cond.false

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %3 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %3, null
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true4
  %4 = load ptr, ptr %args.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  %5 = load ptr, ptr %args.addr, align 8
  %6 = load i64, ptr %nargs.addr, align 8
  %7 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [3 x ptr], ptr %argsbuf, i64 0, i64 0
  %call = call ptr @_PyArg_UnpackKeywords(ptr noundef %5, i64 noundef %6, ptr noundef null, ptr noundef %7, ptr noundef @os_fchown._parser, i32 noundef 3, i32 noundef 3, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %4, %cond.true ], [ %call, %cond.false ]
  store ptr %cond, ptr %args.addr, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  br label %exit

if.end:                                           ; preds = %cond.end
  %9 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %9, i64 0
  %10 = load ptr, ptr %arrayidx, align 8
  %call6 = call i32 @PyLong_AsInt(ptr noundef %10)
  store i32 %call6, ptr %fd, align 4
  %11 = load i32, ptr %fd, align 4
  %cmp7 = icmp eq i32 %11, -1
  br i1 %cmp7, label %land.lhs.true8, label %if.end12

land.lhs.true8:                                   ; preds = %if.end
  %call9 = call ptr @PyErr_Occurred()
  %tobool10 = icmp ne ptr %call9, null
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %land.lhs.true8
  br label %exit

if.end12:                                         ; preds = %land.lhs.true8, %if.end
  %12 = load ptr, ptr %args.addr, align 8
  %arrayidx13 = getelementptr ptr, ptr %12, i64 1
  %13 = load ptr, ptr %arrayidx13, align 8
  %call14 = call i32 @_Py_Uid_Converter(ptr noundef %13, ptr noundef %uid)
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %if.end17, label %if.then16

if.then16:                                        ; preds = %if.end12
  br label %exit

if.end17:                                         ; preds = %if.end12
  %14 = load ptr, ptr %args.addr, align 8
  %arrayidx18 = getelementptr ptr, ptr %14, i64 2
  %15 = load ptr, ptr %arrayidx18, align 8
  %call19 = call i32 @_Py_Gid_Converter(ptr noundef %15, ptr noundef %gid)
  %tobool20 = icmp ne i32 %call19, 0
  br i1 %tobool20, label %if.end22, label %if.then21

if.then21:                                        ; preds = %if.end17
  br label %exit

if.end22:                                         ; preds = %if.end17
  %16 = load ptr, ptr %module.addr, align 8
  %17 = load i32, ptr %fd, align 4
  %18 = load i32, ptr %uid, align 4
  %19 = load i32, ptr %gid, align 4
  %call23 = call ptr @os_fchown_impl(ptr noundef %16, i32 noundef %17, i32 noundef %18, i32 noundef %19)
  store ptr %call23, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end22, %if.then21, %if.then16, %if.then11, %if.then
  %20 = load ptr, ptr %return_value, align 8
  ret ptr %20
}

; Function Attrs: nounwind uwtable
define internal ptr @os_lchown(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [3 x ptr], align 16
  %path = alloca %struct.path_t, align 8
  %uid = alloca i32, align 4
  %gid = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %path, ptr align 8 @__const.os_lchown.path, i64 72, i1 false)
  %0 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 3, %1
  br i1 %cmp1, label %land.lhs.true2, label %cond.false

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %2, 3
  br i1 %cmp3, label %land.lhs.true4, label %cond.false

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %3 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %3, null
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true4
  %4 = load ptr, ptr %args.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  %5 = load ptr, ptr %args.addr, align 8
  %6 = load i64, ptr %nargs.addr, align 8
  %7 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [3 x ptr], ptr %argsbuf, i64 0, i64 0
  %call = call ptr @_PyArg_UnpackKeywords(ptr noundef %5, i64 noundef %6, ptr noundef null, ptr noundef %7, ptr noundef @os_lchown._parser, i32 noundef 3, i32 noundef 3, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %4, %cond.true ], [ %call, %cond.false ]
  store ptr %cond, ptr %args.addr, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  br label %exit

if.end:                                           ; preds = %cond.end
  %9 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %9, i64 0
  %10 = load ptr, ptr %arrayidx, align 8
  %call6 = call i32 @path_converter(ptr noundef %10, ptr noundef %path)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %if.end
  br label %exit

if.end9:                                          ; preds = %if.end
  %11 = load ptr, ptr %args.addr, align 8
  %arrayidx10 = getelementptr ptr, ptr %11, i64 1
  %12 = load ptr, ptr %arrayidx10, align 8
  %call11 = call i32 @_Py_Uid_Converter(ptr noundef %12, ptr noundef %uid)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %if.end14, label %if.then13

if.then13:                                        ; preds = %if.end9
  br label %exit

if.end14:                                         ; preds = %if.end9
  %13 = load ptr, ptr %args.addr, align 8
  %arrayidx15 = getelementptr ptr, ptr %13, i64 2
  %14 = load ptr, ptr %arrayidx15, align 8
  %call16 = call i32 @_Py_Gid_Converter(ptr noundef %14, ptr noundef %gid)
  %tobool17 = icmp ne i32 %call16, 0
  br i1 %tobool17, label %if.end19, label %if.then18

if.then18:                                        ; preds = %if.end14
  br label %exit

if.end19:                                         ; preds = %if.end14
  %15 = load ptr, ptr %module.addr, align 8
  %16 = load i32, ptr %uid, align 4
  %17 = load i32, ptr %gid, align 4
  %call20 = call ptr @os_lchown_impl(ptr noundef %15, ptr noundef %path, i32 noundef %16, i32 noundef %17)
  store ptr %call20, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end19, %if.then18, %if.then13, %if.then8, %if.then
  call void @path_cleanup(ptr noundef %path)
  %18 = load ptr, ptr %return_value, align 8
  ret ptr %18
}

; Function Attrs: nounwind uwtable
define internal ptr @os_chroot(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [1 x ptr], align 8
  %path = alloca %struct.path_t, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %path, ptr align 8 @__const.os_chroot.path, i64 72, i1 false)
  %0 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 1, %1
  br i1 %cmp1, label %land.lhs.true2, label %cond.false

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %2, 1
  br i1 %cmp3, label %land.lhs.true4, label %cond.false

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %3 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %3, null
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true4
  %4 = load ptr, ptr %args.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  %5 = load ptr, ptr %args.addr, align 8
  %6 = load i64, ptr %nargs.addr, align 8
  %7 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [1 x ptr], ptr %argsbuf, i64 0, i64 0
  %call = call ptr @_PyArg_UnpackKeywords(ptr noundef %5, i64 noundef %6, ptr noundef null, ptr noundef %7, ptr noundef @os_chroot._parser, i32 noundef 1, i32 noundef 1, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %4, %cond.true ], [ %call, %cond.false ]
  store ptr %cond, ptr %args.addr, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  br label %exit

if.end:                                           ; preds = %cond.end
  %9 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %9, i64 0
  %10 = load ptr, ptr %arrayidx, align 8
  %call6 = call i32 @path_converter(ptr noundef %10, ptr noundef %path)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %if.end
  br label %exit

if.end9:                                          ; preds = %if.end
  %11 = load ptr, ptr %module.addr, align 8
  %call10 = call ptr @os_chroot_impl(ptr noundef %11, ptr noundef %path)
  store ptr %call10, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end9, %if.then8, %if.then
  call void @path_cleanup(ptr noundef %path)
  %12 = load ptr, ptr %return_value, align 8
  ret ptr %12
}

; Function Attrs: nounwind uwtable
define internal ptr @os_ctermid(ptr noundef %module, ptr noundef %_unused_ignored) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %call = call ptr @os_ctermid_impl(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @os_getcwd(ptr noundef %module, ptr noundef %_unused_ignored) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %call = call ptr @os_getcwd_impl(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @os_getcwdb(ptr noundef %module, ptr noundef %_unused_ignored) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %call = call ptr @os_getcwdb_impl(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @os_link(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [5 x ptr], align 16
  %noptargs = alloca i64, align 8
  %src = alloca %struct.path_t, align 8
  %dst = alloca %struct.path_t, align 8
  %src_dir_fd = alloca i32, align 4
  %dst_dir_fd = alloca i32, align 4
  %follow_symlinks = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 2
  store i64 %sub, ptr %noptargs, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %src, ptr align 8 @__const.os_link.src, i64 72, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %dst, ptr align 8 @__const.os_link.dst, i64 72, i1 false)
  store i32 -100, ptr %src_dir_fd, align 4
  store i32 -100, ptr %dst_dir_fd, align 4
  store i32 1, ptr %follow_symlinks, align 4
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 2, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 2
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [5 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @os_link._parser, i32 noundef 2, i32 noundef 2, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %12, i64 0
  %13 = load ptr, ptr %arrayidx, align 8
  %call12 = call i32 @path_converter(ptr noundef %13, ptr noundef %src)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end
  br label %exit

if.end15:                                         ; preds = %if.end
  %14 = load ptr, ptr %args.addr, align 8
  %arrayidx16 = getelementptr ptr, ptr %14, i64 1
  %15 = load ptr, ptr %arrayidx16, align 8
  %call17 = call i32 @path_converter(ptr noundef %15, ptr noundef %dst)
  %tobool18 = icmp ne i32 %call17, 0
  br i1 %tobool18, label %if.end20, label %if.then19

if.then19:                                        ; preds = %if.end15
  br label %exit

if.end20:                                         ; preds = %if.end15
  %16 = load i64, ptr %noptargs, align 8
  %tobool21 = icmp ne i64 %16, 0
  br i1 %tobool21, label %if.end23, label %if.then22

if.then22:                                        ; preds = %if.end20
  br label %skip_optional_kwonly

if.end23:                                         ; preds = %if.end20
  %17 = load ptr, ptr %args.addr, align 8
  %arrayidx24 = getelementptr ptr, ptr %17, i64 2
  %18 = load ptr, ptr %arrayidx24, align 8
  %tobool25 = icmp ne ptr %18, null
  br i1 %tobool25, label %if.then26, label %if.end35

if.then26:                                        ; preds = %if.end23
  %19 = load ptr, ptr %args.addr, align 8
  %arrayidx27 = getelementptr ptr, ptr %19, i64 2
  %20 = load ptr, ptr %arrayidx27, align 8
  %call28 = call i32 @dir_fd_converter(ptr noundef %20, ptr noundef %src_dir_fd)
  %tobool29 = icmp ne i32 %call28, 0
  br i1 %tobool29, label %if.end31, label %if.then30

if.then30:                                        ; preds = %if.then26
  br label %exit

if.end31:                                         ; preds = %if.then26
  %21 = load i64, ptr %noptargs, align 8
  %dec = add i64 %21, -1
  store i64 %dec, ptr %noptargs, align 8
  %tobool32 = icmp ne i64 %dec, 0
  br i1 %tobool32, label %if.end34, label %if.then33

if.then33:                                        ; preds = %if.end31
  br label %skip_optional_kwonly

if.end34:                                         ; preds = %if.end31
  br label %if.end35

if.end35:                                         ; preds = %if.end34, %if.end23
  %22 = load ptr, ptr %args.addr, align 8
  %arrayidx36 = getelementptr ptr, ptr %22, i64 3
  %23 = load ptr, ptr %arrayidx36, align 8
  %tobool37 = icmp ne ptr %23, null
  br i1 %tobool37, label %if.then38, label %if.end48

if.then38:                                        ; preds = %if.end35
  %24 = load ptr, ptr %args.addr, align 8
  %arrayidx39 = getelementptr ptr, ptr %24, i64 3
  %25 = load ptr, ptr %arrayidx39, align 8
  %call40 = call i32 @dir_fd_converter(ptr noundef %25, ptr noundef %dst_dir_fd)
  %tobool41 = icmp ne i32 %call40, 0
  br i1 %tobool41, label %if.end43, label %if.then42

if.then42:                                        ; preds = %if.then38
  br label %exit

if.end43:                                         ; preds = %if.then38
  %26 = load i64, ptr %noptargs, align 8
  %dec44 = add i64 %26, -1
  store i64 %dec44, ptr %noptargs, align 8
  %tobool45 = icmp ne i64 %dec44, 0
  br i1 %tobool45, label %if.end47, label %if.then46

if.then46:                                        ; preds = %if.end43
  br label %skip_optional_kwonly

if.end47:                                         ; preds = %if.end43
  br label %if.end48

if.end48:                                         ; preds = %if.end47, %if.end35
  %27 = load ptr, ptr %args.addr, align 8
  %arrayidx49 = getelementptr ptr, ptr %27, i64 4
  %28 = load ptr, ptr %arrayidx49, align 8
  %call50 = call i32 @PyObject_IsTrue(ptr noundef %28)
  store i32 %call50, ptr %follow_symlinks, align 4
  %29 = load i32, ptr %follow_symlinks, align 4
  %cmp51 = icmp slt i32 %29, 0
  br i1 %cmp51, label %if.then52, label %if.end53

if.then52:                                        ; preds = %if.end48
  br label %exit

if.end53:                                         ; preds = %if.end48
  br label %skip_optional_kwonly

skip_optional_kwonly:                             ; preds = %if.end53, %if.then46, %if.then33, %if.then22
  %30 = load ptr, ptr %module.addr, align 8
  %31 = load i32, ptr %src_dir_fd, align 4
  %32 = load i32, ptr %dst_dir_fd, align 4
  %33 = load i32, ptr %follow_symlinks, align 4
  %call54 = call ptr @os_link_impl(ptr noundef %30, ptr noundef %src, ptr noundef %dst, i32 noundef %31, i32 noundef %32, i32 noundef %33)
  store ptr %call54, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional_kwonly, %if.then52, %if.then42, %if.then30, %if.then19, %if.then14, %if.then
  call void @path_cleanup(ptr noundef %src)
  call void @path_cleanup(ptr noundef %dst)
  %34 = load ptr, ptr %return_value, align 8
  ret ptr %34
}

; Function Attrs: nounwind uwtable
define internal ptr @os_listdir(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [1 x ptr], align 8
  %noptargs = alloca i64, align 8
  %path = alloca %struct.path_t, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 0
  store i64 %sub, ptr %noptargs, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %path, ptr align 8 @__const.os_listdir.path, i64 72, i1 false)
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 0, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 1
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [1 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @os_listdir._parser, i32 noundef 0, i32 noundef 1, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load i64, ptr %noptargs, align 8
  %tobool12 = icmp ne i64 %12, 0
  br i1 %tobool12, label %if.end14, label %if.then13

if.then13:                                        ; preds = %if.end
  br label %skip_optional_pos

if.end14:                                         ; preds = %if.end
  %13 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %13, i64 0
  %14 = load ptr, ptr %arrayidx, align 8
  %call15 = call i32 @path_converter(ptr noundef %14, ptr noundef %path)
  %tobool16 = icmp ne i32 %call15, 0
  br i1 %tobool16, label %if.end18, label %if.then17

if.then17:                                        ; preds = %if.end14
  br label %exit

if.end18:                                         ; preds = %if.end14
  br label %skip_optional_pos

skip_optional_pos:                                ; preds = %if.end18, %if.then13
  %15 = load ptr, ptr %module.addr, align 8
  %call19 = call ptr @os_listdir_impl(ptr noundef %15, ptr noundef %path)
  store ptr %call19, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional_pos, %if.then17, %if.then
  call void @path_cleanup(ptr noundef %path)
  %16 = load ptr, ptr %return_value, align 8
  ret ptr %16
}

; Function Attrs: nounwind uwtable
define internal ptr @os_lstat(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [2 x ptr], align 16
  %noptargs = alloca i64, align 8
  %path = alloca %struct.path_t, align 8
  %dir_fd = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 1
  store i64 %sub, ptr %noptargs, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %path, ptr align 8 @__const.os_lstat.path, i64 72, i1 false)
  store i32 -100, ptr %dir_fd, align 4
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 1, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 1
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [2 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @os_lstat._parser, i32 noundef 1, i32 noundef 1, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %12, i64 0
  %13 = load ptr, ptr %arrayidx, align 8
  %call12 = call i32 @path_converter(ptr noundef %13, ptr noundef %path)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end
  br label %exit

if.end15:                                         ; preds = %if.end
  %14 = load i64, ptr %noptargs, align 8
  %tobool16 = icmp ne i64 %14, 0
  br i1 %tobool16, label %if.end18, label %if.then17

if.then17:                                        ; preds = %if.end15
  br label %skip_optional_kwonly

if.end18:                                         ; preds = %if.end15
  %15 = load ptr, ptr %args.addr, align 8
  %arrayidx19 = getelementptr ptr, ptr %15, i64 1
  %16 = load ptr, ptr %arrayidx19, align 8
  %call20 = call i32 @dir_fd_converter(ptr noundef %16, ptr noundef %dir_fd)
  %tobool21 = icmp ne i32 %call20, 0
  br i1 %tobool21, label %if.end23, label %if.then22

if.then22:                                        ; preds = %if.end18
  br label %exit

if.end23:                                         ; preds = %if.end18
  br label %skip_optional_kwonly

skip_optional_kwonly:                             ; preds = %if.end23, %if.then17
  %17 = load ptr, ptr %module.addr, align 8
  %18 = load i32, ptr %dir_fd, align 4
  %call24 = call ptr @os_lstat_impl(ptr noundef %17, ptr noundef %path, i32 noundef %18)
  store ptr %call24, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional_kwonly, %if.then22, %if.then14, %if.then
  call void @path_cleanup(ptr noundef %path)
  %19 = load ptr, ptr %return_value, align 8
  ret ptr %19
}

; Function Attrs: nounwind uwtable
define internal ptr @os_mkdir(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [3 x ptr], align 16
  %noptargs = alloca i64, align 8
  %path = alloca %struct.path_t, align 8
  %mode = alloca i32, align 4
  %dir_fd = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 1
  store i64 %sub, ptr %noptargs, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %path, ptr align 8 @__const.os_mkdir.path, i64 72, i1 false)
  store i32 511, ptr %mode, align 4
  store i32 -100, ptr %dir_fd, align 4
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 1, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 2
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [3 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @os_mkdir._parser, i32 noundef 1, i32 noundef 2, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %12, i64 0
  %13 = load ptr, ptr %arrayidx, align 8
  %call12 = call i32 @path_converter(ptr noundef %13, ptr noundef %path)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end
  br label %exit

if.end15:                                         ; preds = %if.end
  %14 = load i64, ptr %noptargs, align 8
  %tobool16 = icmp ne i64 %14, 0
  br i1 %tobool16, label %if.end18, label %if.then17

if.then17:                                        ; preds = %if.end15
  br label %skip_optional_pos

if.end18:                                         ; preds = %if.end15
  %15 = load ptr, ptr %args.addr, align 8
  %arrayidx19 = getelementptr ptr, ptr %15, i64 1
  %16 = load ptr, ptr %arrayidx19, align 8
  %tobool20 = icmp ne ptr %16, null
  br i1 %tobool20, label %if.then21, label %if.end33

if.then21:                                        ; preds = %if.end18
  %17 = load ptr, ptr %args.addr, align 8
  %arrayidx22 = getelementptr ptr, ptr %17, i64 1
  %18 = load ptr, ptr %arrayidx22, align 8
  %call23 = call i32 @PyLong_AsInt(ptr noundef %18)
  store i32 %call23, ptr %mode, align 4
  %19 = load i32, ptr %mode, align 4
  %cmp24 = icmp eq i32 %19, -1
  br i1 %cmp24, label %land.lhs.true25, label %if.end29

land.lhs.true25:                                  ; preds = %if.then21
  %call26 = call ptr @PyErr_Occurred()
  %tobool27 = icmp ne ptr %call26, null
  br i1 %tobool27, label %if.then28, label %if.end29

if.then28:                                        ; preds = %land.lhs.true25
  br label %exit

if.end29:                                         ; preds = %land.lhs.true25, %if.then21
  %20 = load i64, ptr %noptargs, align 8
  %dec = add i64 %20, -1
  store i64 %dec, ptr %noptargs, align 8
  %tobool30 = icmp ne i64 %dec, 0
  br i1 %tobool30, label %if.end32, label %if.then31

if.then31:                                        ; preds = %if.end29
  br label %skip_optional_pos

if.end32:                                         ; preds = %if.end29
  br label %if.end33

if.end33:                                         ; preds = %if.end32, %if.end18
  br label %skip_optional_pos

skip_optional_pos:                                ; preds = %if.end33, %if.then31, %if.then17
  %21 = load i64, ptr %noptargs, align 8
  %tobool34 = icmp ne i64 %21, 0
  br i1 %tobool34, label %if.end36, label %if.then35

if.then35:                                        ; preds = %skip_optional_pos
  br label %skip_optional_kwonly

if.end36:                                         ; preds = %skip_optional_pos
  %22 = load ptr, ptr %args.addr, align 8
  %arrayidx37 = getelementptr ptr, ptr %22, i64 2
  %23 = load ptr, ptr %arrayidx37, align 8
  %call38 = call i32 @dir_fd_converter(ptr noundef %23, ptr noundef %dir_fd)
  %tobool39 = icmp ne i32 %call38, 0
  br i1 %tobool39, label %if.end41, label %if.then40

if.then40:                                        ; preds = %if.end36
  br label %exit

if.end41:                                         ; preds = %if.end36
  br label %skip_optional_kwonly

skip_optional_kwonly:                             ; preds = %if.end41, %if.then35
  %24 = load ptr, ptr %module.addr, align 8
  %25 = load i32, ptr %mode, align 4
  %26 = load i32, ptr %dir_fd, align 4
  %call42 = call ptr @os_mkdir_impl(ptr noundef %24, ptr noundef %path, i32 noundef %25, i32 noundef %26)
  store ptr %call42, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional_kwonly, %if.then40, %if.then28, %if.then14, %if.then
  call void @path_cleanup(ptr noundef %path)
  %27 = load ptr, ptr %return_value, align 8
  ret ptr %27
}

; Function Attrs: nounwind uwtable
define internal ptr @os_nice(ptr noundef %module, ptr noundef %arg) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %increment = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %call = call i32 @PyLong_AsInt(ptr noundef %0)
  store i32 %call, ptr %increment, align 4
  %1 = load i32, ptr %increment, align 4
  %cmp = icmp eq i32 %1, -1
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %call1 = call ptr @PyErr_Occurred()
  %tobool = icmp ne ptr %call1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  br label %exit

if.end:                                           ; preds = %land.lhs.true, %entry
  %2 = load ptr, ptr %module.addr, align 8
  %3 = load i32, ptr %increment, align 4
  %call2 = call ptr @os_nice_impl(ptr noundef %2, i32 noundef %3)
  store ptr %call2, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end, %if.then
  %4 = load ptr, ptr %return_value, align 8
  ret ptr %4
}

; Function Attrs: nounwind uwtable
define internal ptr @os_getpriority(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [2 x ptr], align 16
  %which = alloca i32, align 4
  %who = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 2, %1
  br i1 %cmp1, label %land.lhs.true2, label %cond.false

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %2, 2
  br i1 %cmp3, label %land.lhs.true4, label %cond.false

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %3 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %3, null
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true4
  %4 = load ptr, ptr %args.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  %5 = load ptr, ptr %args.addr, align 8
  %6 = load i64, ptr %nargs.addr, align 8
  %7 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [2 x ptr], ptr %argsbuf, i64 0, i64 0
  %call = call ptr @_PyArg_UnpackKeywords(ptr noundef %5, i64 noundef %6, ptr noundef null, ptr noundef %7, ptr noundef @os_getpriority._parser, i32 noundef 2, i32 noundef 2, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %4, %cond.true ], [ %call, %cond.false ]
  store ptr %cond, ptr %args.addr, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  br label %exit

if.end:                                           ; preds = %cond.end
  %9 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %9, i64 0
  %10 = load ptr, ptr %arrayidx, align 8
  %call6 = call i32 @PyLong_AsInt(ptr noundef %10)
  store i32 %call6, ptr %which, align 4
  %11 = load i32, ptr %which, align 4
  %cmp7 = icmp eq i32 %11, -1
  br i1 %cmp7, label %land.lhs.true8, label %if.end12

land.lhs.true8:                                   ; preds = %if.end
  %call9 = call ptr @PyErr_Occurred()
  %tobool10 = icmp ne ptr %call9, null
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %land.lhs.true8
  br label %exit

if.end12:                                         ; preds = %land.lhs.true8, %if.end
  %12 = load ptr, ptr %args.addr, align 8
  %arrayidx13 = getelementptr ptr, ptr %12, i64 1
  %13 = load ptr, ptr %arrayidx13, align 8
  %call14 = call i32 @PyLong_AsInt(ptr noundef %13)
  store i32 %call14, ptr %who, align 4
  %14 = load i32, ptr %who, align 4
  %cmp15 = icmp eq i32 %14, -1
  br i1 %cmp15, label %land.lhs.true16, label %if.end20

land.lhs.true16:                                  ; preds = %if.end12
  %call17 = call ptr @PyErr_Occurred()
  %tobool18 = icmp ne ptr %call17, null
  br i1 %tobool18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %land.lhs.true16
  br label %exit

if.end20:                                         ; preds = %land.lhs.true16, %if.end12
  %15 = load ptr, ptr %module.addr, align 8
  %16 = load i32, ptr %which, align 4
  %17 = load i32, ptr %who, align 4
  %call21 = call ptr @os_getpriority_impl(ptr noundef %15, i32 noundef %16, i32 noundef %17)
  store ptr %call21, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end20, %if.then19, %if.then11, %if.then
  %18 = load ptr, ptr %return_value, align 8
  ret ptr %18
}

; Function Attrs: nounwind uwtable
define internal ptr @os_setpriority(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [3 x ptr], align 16
  %which = alloca i32, align 4
  %who = alloca i32, align 4
  %priority = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 3, %1
  br i1 %cmp1, label %land.lhs.true2, label %cond.false

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %2, 3
  br i1 %cmp3, label %land.lhs.true4, label %cond.false

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %3 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %3, null
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true4
  %4 = load ptr, ptr %args.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  %5 = load ptr, ptr %args.addr, align 8
  %6 = load i64, ptr %nargs.addr, align 8
  %7 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [3 x ptr], ptr %argsbuf, i64 0, i64 0
  %call = call ptr @_PyArg_UnpackKeywords(ptr noundef %5, i64 noundef %6, ptr noundef null, ptr noundef %7, ptr noundef @os_setpriority._parser, i32 noundef 3, i32 noundef 3, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %4, %cond.true ], [ %call, %cond.false ]
  store ptr %cond, ptr %args.addr, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  br label %exit

if.end:                                           ; preds = %cond.end
  %9 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %9, i64 0
  %10 = load ptr, ptr %arrayidx, align 8
  %call6 = call i32 @PyLong_AsInt(ptr noundef %10)
  store i32 %call6, ptr %which, align 4
  %11 = load i32, ptr %which, align 4
  %cmp7 = icmp eq i32 %11, -1
  br i1 %cmp7, label %land.lhs.true8, label %if.end12

land.lhs.true8:                                   ; preds = %if.end
  %call9 = call ptr @PyErr_Occurred()
  %tobool10 = icmp ne ptr %call9, null
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %land.lhs.true8
  br label %exit

if.end12:                                         ; preds = %land.lhs.true8, %if.end
  %12 = load ptr, ptr %args.addr, align 8
  %arrayidx13 = getelementptr ptr, ptr %12, i64 1
  %13 = load ptr, ptr %arrayidx13, align 8
  %call14 = call i32 @PyLong_AsInt(ptr noundef %13)
  store i32 %call14, ptr %who, align 4
  %14 = load i32, ptr %who, align 4
  %cmp15 = icmp eq i32 %14, -1
  br i1 %cmp15, label %land.lhs.true16, label %if.end20

land.lhs.true16:                                  ; preds = %if.end12
  %call17 = call ptr @PyErr_Occurred()
  %tobool18 = icmp ne ptr %call17, null
  br i1 %tobool18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %land.lhs.true16
  br label %exit

if.end20:                                         ; preds = %land.lhs.true16, %if.end12
  %15 = load ptr, ptr %args.addr, align 8
  %arrayidx21 = getelementptr ptr, ptr %15, i64 2
  %16 = load ptr, ptr %arrayidx21, align 8
  %call22 = call i32 @PyLong_AsInt(ptr noundef %16)
  store i32 %call22, ptr %priority, align 4
  %17 = load i32, ptr %priority, align 4
  %cmp23 = icmp eq i32 %17, -1
  br i1 %cmp23, label %land.lhs.true24, label %if.end28

land.lhs.true24:                                  ; preds = %if.end20
  %call25 = call ptr @PyErr_Occurred()
  %tobool26 = icmp ne ptr %call25, null
  br i1 %tobool26, label %if.then27, label %if.end28

if.then27:                                        ; preds = %land.lhs.true24
  br label %exit

if.end28:                                         ; preds = %land.lhs.true24, %if.end20
  %18 = load ptr, ptr %module.addr, align 8
  %19 = load i32, ptr %which, align 4
  %20 = load i32, ptr %who, align 4
  %21 = load i32, ptr %priority, align 4
  %call29 = call ptr @os_setpriority_impl(ptr noundef %18, i32 noundef %19, i32 noundef %20, i32 noundef %21)
  store ptr %call29, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end28, %if.then27, %if.then19, %if.then11, %if.then
  %22 = load ptr, ptr %return_value, align 8
  ret ptr %22
}

; Function Attrs: nounwind uwtable
define internal ptr @os_posix_spawn(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [10 x ptr], align 16
  %noptargs = alloca i64, align 8
  %path = alloca %struct.path_t, align 8
  %argv = alloca ptr, align 8
  %env = alloca ptr, align 8
  %file_actions = alloca ptr, align 8
  %setpgroup = alloca ptr, align 8
  %resetids = alloca i32, align 4
  %setsid = alloca i32, align 4
  %setsigmask = alloca ptr, align 8
  %setsigdef = alloca ptr, align 8
  %scheduler = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 3
  store i64 %sub, ptr %noptargs, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %path, ptr align 8 @__const.os_posix_spawn.path, i64 72, i1 false)
  store ptr null, ptr %file_actions, align 8
  store ptr null, ptr %setpgroup, align 8
  store i32 0, ptr %resetids, align 4
  store i32 0, ptr %setsid, align 4
  store ptr null, ptr %setsigmask, align 8
  store ptr null, ptr %setsigdef, align 8
  store ptr null, ptr %scheduler, align 8
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 3, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 3
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [10 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @os_posix_spawn._parser, i32 noundef 3, i32 noundef 3, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %12, i64 0
  %13 = load ptr, ptr %arrayidx, align 8
  %call12 = call i32 @path_converter(ptr noundef %13, ptr noundef %path)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end
  br label %exit

if.end15:                                         ; preds = %if.end
  %14 = load ptr, ptr %args.addr, align 8
  %arrayidx16 = getelementptr ptr, ptr %14, i64 1
  %15 = load ptr, ptr %arrayidx16, align 8
  store ptr %15, ptr %argv, align 8
  %16 = load ptr, ptr %args.addr, align 8
  %arrayidx17 = getelementptr ptr, ptr %16, i64 2
  %17 = load ptr, ptr %arrayidx17, align 8
  store ptr %17, ptr %env, align 8
  %18 = load i64, ptr %noptargs, align 8
  %tobool18 = icmp ne i64 %18, 0
  br i1 %tobool18, label %if.end20, label %if.then19

if.then19:                                        ; preds = %if.end15
  br label %skip_optional_kwonly

if.end20:                                         ; preds = %if.end15
  %19 = load ptr, ptr %args.addr, align 8
  %arrayidx21 = getelementptr ptr, ptr %19, i64 3
  %20 = load ptr, ptr %arrayidx21, align 8
  %tobool22 = icmp ne ptr %20, null
  br i1 %tobool22, label %if.then23, label %if.end28

if.then23:                                        ; preds = %if.end20
  %21 = load ptr, ptr %args.addr, align 8
  %arrayidx24 = getelementptr ptr, ptr %21, i64 3
  %22 = load ptr, ptr %arrayidx24, align 8
  store ptr %22, ptr %file_actions, align 8
  %23 = load i64, ptr %noptargs, align 8
  %dec = add i64 %23, -1
  store i64 %dec, ptr %noptargs, align 8
  %tobool25 = icmp ne i64 %dec, 0
  br i1 %tobool25, label %if.end27, label %if.then26

if.then26:                                        ; preds = %if.then23
  br label %skip_optional_kwonly

if.end27:                                         ; preds = %if.then23
  br label %if.end28

if.end28:                                         ; preds = %if.end27, %if.end20
  %24 = load ptr, ptr %args.addr, align 8
  %arrayidx29 = getelementptr ptr, ptr %24, i64 4
  %25 = load ptr, ptr %arrayidx29, align 8
  %tobool30 = icmp ne ptr %25, null
  br i1 %tobool30, label %if.then31, label %if.end37

if.then31:                                        ; preds = %if.end28
  %26 = load ptr, ptr %args.addr, align 8
  %arrayidx32 = getelementptr ptr, ptr %26, i64 4
  %27 = load ptr, ptr %arrayidx32, align 8
  store ptr %27, ptr %setpgroup, align 8
  %28 = load i64, ptr %noptargs, align 8
  %dec33 = add i64 %28, -1
  store i64 %dec33, ptr %noptargs, align 8
  %tobool34 = icmp ne i64 %dec33, 0
  br i1 %tobool34, label %if.end36, label %if.then35

if.then35:                                        ; preds = %if.then31
  br label %skip_optional_kwonly

if.end36:                                         ; preds = %if.then31
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %if.end28
  %29 = load ptr, ptr %args.addr, align 8
  %arrayidx38 = getelementptr ptr, ptr %29, i64 5
  %30 = load ptr, ptr %arrayidx38, align 8
  %tobool39 = icmp ne ptr %30, null
  br i1 %tobool39, label %if.then40, label %if.end50

if.then40:                                        ; preds = %if.end37
  %31 = load ptr, ptr %args.addr, align 8
  %arrayidx41 = getelementptr ptr, ptr %31, i64 5
  %32 = load ptr, ptr %arrayidx41, align 8
  %call42 = call i32 @PyObject_IsTrue(ptr noundef %32)
  store i32 %call42, ptr %resetids, align 4
  %33 = load i32, ptr %resetids, align 4
  %cmp43 = icmp slt i32 %33, 0
  br i1 %cmp43, label %if.then44, label %if.end45

if.then44:                                        ; preds = %if.then40
  br label %exit

if.end45:                                         ; preds = %if.then40
  %34 = load i64, ptr %noptargs, align 8
  %dec46 = add i64 %34, -1
  store i64 %dec46, ptr %noptargs, align 8
  %tobool47 = icmp ne i64 %dec46, 0
  br i1 %tobool47, label %if.end49, label %if.then48

if.then48:                                        ; preds = %if.end45
  br label %skip_optional_kwonly

if.end49:                                         ; preds = %if.end45
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.end37
  %35 = load ptr, ptr %args.addr, align 8
  %arrayidx51 = getelementptr ptr, ptr %35, i64 6
  %36 = load ptr, ptr %arrayidx51, align 8
  %tobool52 = icmp ne ptr %36, null
  br i1 %tobool52, label %if.then53, label %if.end63

if.then53:                                        ; preds = %if.end50
  %37 = load ptr, ptr %args.addr, align 8
  %arrayidx54 = getelementptr ptr, ptr %37, i64 6
  %38 = load ptr, ptr %arrayidx54, align 8
  %call55 = call i32 @PyObject_IsTrue(ptr noundef %38)
  store i32 %call55, ptr %setsid, align 4
  %39 = load i32, ptr %setsid, align 4
  %cmp56 = icmp slt i32 %39, 0
  br i1 %cmp56, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.then53
  br label %exit

if.end58:                                         ; preds = %if.then53
  %40 = load i64, ptr %noptargs, align 8
  %dec59 = add i64 %40, -1
  store i64 %dec59, ptr %noptargs, align 8
  %tobool60 = icmp ne i64 %dec59, 0
  br i1 %tobool60, label %if.end62, label %if.then61

if.then61:                                        ; preds = %if.end58
  br label %skip_optional_kwonly

if.end62:                                         ; preds = %if.end58
  br label %if.end63

if.end63:                                         ; preds = %if.end62, %if.end50
  %41 = load ptr, ptr %args.addr, align 8
  %arrayidx64 = getelementptr ptr, ptr %41, i64 7
  %42 = load ptr, ptr %arrayidx64, align 8
  %tobool65 = icmp ne ptr %42, null
  br i1 %tobool65, label %if.then66, label %if.end72

if.then66:                                        ; preds = %if.end63
  %43 = load ptr, ptr %args.addr, align 8
  %arrayidx67 = getelementptr ptr, ptr %43, i64 7
  %44 = load ptr, ptr %arrayidx67, align 8
  store ptr %44, ptr %setsigmask, align 8
  %45 = load i64, ptr %noptargs, align 8
  %dec68 = add i64 %45, -1
  store i64 %dec68, ptr %noptargs, align 8
  %tobool69 = icmp ne i64 %dec68, 0
  br i1 %tobool69, label %if.end71, label %if.then70

if.then70:                                        ; preds = %if.then66
  br label %skip_optional_kwonly

if.end71:                                         ; preds = %if.then66
  br label %if.end72

if.end72:                                         ; preds = %if.end71, %if.end63
  %46 = load ptr, ptr %args.addr, align 8
  %arrayidx73 = getelementptr ptr, ptr %46, i64 8
  %47 = load ptr, ptr %arrayidx73, align 8
  %tobool74 = icmp ne ptr %47, null
  br i1 %tobool74, label %if.then75, label %if.end81

if.then75:                                        ; preds = %if.end72
  %48 = load ptr, ptr %args.addr, align 8
  %arrayidx76 = getelementptr ptr, ptr %48, i64 8
  %49 = load ptr, ptr %arrayidx76, align 8
  store ptr %49, ptr %setsigdef, align 8
  %50 = load i64, ptr %noptargs, align 8
  %dec77 = add i64 %50, -1
  store i64 %dec77, ptr %noptargs, align 8
  %tobool78 = icmp ne i64 %dec77, 0
  br i1 %tobool78, label %if.end80, label %if.then79

if.then79:                                        ; preds = %if.then75
  br label %skip_optional_kwonly

if.end80:                                         ; preds = %if.then75
  br label %if.end81

if.end81:                                         ; preds = %if.end80, %if.end72
  %51 = load ptr, ptr %args.addr, align 8
  %arrayidx82 = getelementptr ptr, ptr %51, i64 9
  %52 = load ptr, ptr %arrayidx82, align 8
  store ptr %52, ptr %scheduler, align 8
  br label %skip_optional_kwonly

skip_optional_kwonly:                             ; preds = %if.end81, %if.then79, %if.then70, %if.then61, %if.then48, %if.then35, %if.then26, %if.then19
  %53 = load ptr, ptr %module.addr, align 8
  %54 = load ptr, ptr %argv, align 8
  %55 = load ptr, ptr %env, align 8
  %56 = load ptr, ptr %file_actions, align 8
  %57 = load ptr, ptr %setpgroup, align 8
  %58 = load i32, ptr %resetids, align 4
  %59 = load i32, ptr %setsid, align 4
  %60 = load ptr, ptr %setsigmask, align 8
  %61 = load ptr, ptr %setsigdef, align 8
  %62 = load ptr, ptr %scheduler, align 8
  %call83 = call ptr @os_posix_spawn_impl(ptr noundef %53, ptr noundef %path, ptr noundef %54, ptr noundef %55, ptr noundef %56, ptr noundef %57, i32 noundef %58, i32 noundef %59, ptr noundef %60, ptr noundef %61, ptr noundef %62)
  store ptr %call83, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional_kwonly, %if.then57, %if.then44, %if.then14, %if.then
  call void @path_cleanup(ptr noundef %path)
  %63 = load ptr, ptr %return_value, align 8
  ret ptr %63
}

; Function Attrs: nounwind uwtable
define internal ptr @os_posix_spawnp(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [10 x ptr], align 16
  %noptargs = alloca i64, align 8
  %path = alloca %struct.path_t, align 8
  %argv = alloca ptr, align 8
  %env = alloca ptr, align 8
  %file_actions = alloca ptr, align 8
  %setpgroup = alloca ptr, align 8
  %resetids = alloca i32, align 4
  %setsid = alloca i32, align 4
  %setsigmask = alloca ptr, align 8
  %setsigdef = alloca ptr, align 8
  %scheduler = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 3
  store i64 %sub, ptr %noptargs, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %path, ptr align 8 @__const.os_posix_spawnp.path, i64 72, i1 false)
  store ptr null, ptr %file_actions, align 8
  store ptr null, ptr %setpgroup, align 8
  store i32 0, ptr %resetids, align 4
  store i32 0, ptr %setsid, align 4
  store ptr null, ptr %setsigmask, align 8
  store ptr null, ptr %setsigdef, align 8
  store ptr null, ptr %scheduler, align 8
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 3, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 3
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [10 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @os_posix_spawnp._parser, i32 noundef 3, i32 noundef 3, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %12, i64 0
  %13 = load ptr, ptr %arrayidx, align 8
  %call12 = call i32 @path_converter(ptr noundef %13, ptr noundef %path)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end
  br label %exit

if.end15:                                         ; preds = %if.end
  %14 = load ptr, ptr %args.addr, align 8
  %arrayidx16 = getelementptr ptr, ptr %14, i64 1
  %15 = load ptr, ptr %arrayidx16, align 8
  store ptr %15, ptr %argv, align 8
  %16 = load ptr, ptr %args.addr, align 8
  %arrayidx17 = getelementptr ptr, ptr %16, i64 2
  %17 = load ptr, ptr %arrayidx17, align 8
  store ptr %17, ptr %env, align 8
  %18 = load i64, ptr %noptargs, align 8
  %tobool18 = icmp ne i64 %18, 0
  br i1 %tobool18, label %if.end20, label %if.then19

if.then19:                                        ; preds = %if.end15
  br label %skip_optional_kwonly

if.end20:                                         ; preds = %if.end15
  %19 = load ptr, ptr %args.addr, align 8
  %arrayidx21 = getelementptr ptr, ptr %19, i64 3
  %20 = load ptr, ptr %arrayidx21, align 8
  %tobool22 = icmp ne ptr %20, null
  br i1 %tobool22, label %if.then23, label %if.end28

if.then23:                                        ; preds = %if.end20
  %21 = load ptr, ptr %args.addr, align 8
  %arrayidx24 = getelementptr ptr, ptr %21, i64 3
  %22 = load ptr, ptr %arrayidx24, align 8
  store ptr %22, ptr %file_actions, align 8
  %23 = load i64, ptr %noptargs, align 8
  %dec = add i64 %23, -1
  store i64 %dec, ptr %noptargs, align 8
  %tobool25 = icmp ne i64 %dec, 0
  br i1 %tobool25, label %if.end27, label %if.then26

if.then26:                                        ; preds = %if.then23
  br label %skip_optional_kwonly

if.end27:                                         ; preds = %if.then23
  br label %if.end28

if.end28:                                         ; preds = %if.end27, %if.end20
  %24 = load ptr, ptr %args.addr, align 8
  %arrayidx29 = getelementptr ptr, ptr %24, i64 4
  %25 = load ptr, ptr %arrayidx29, align 8
  %tobool30 = icmp ne ptr %25, null
  br i1 %tobool30, label %if.then31, label %if.end37

if.then31:                                        ; preds = %if.end28
  %26 = load ptr, ptr %args.addr, align 8
  %arrayidx32 = getelementptr ptr, ptr %26, i64 4
  %27 = load ptr, ptr %arrayidx32, align 8
  store ptr %27, ptr %setpgroup, align 8
  %28 = load i64, ptr %noptargs, align 8
  %dec33 = add i64 %28, -1
  store i64 %dec33, ptr %noptargs, align 8
  %tobool34 = icmp ne i64 %dec33, 0
  br i1 %tobool34, label %if.end36, label %if.then35

if.then35:                                        ; preds = %if.then31
  br label %skip_optional_kwonly

if.end36:                                         ; preds = %if.then31
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %if.end28
  %29 = load ptr, ptr %args.addr, align 8
  %arrayidx38 = getelementptr ptr, ptr %29, i64 5
  %30 = load ptr, ptr %arrayidx38, align 8
  %tobool39 = icmp ne ptr %30, null
  br i1 %tobool39, label %if.then40, label %if.end50

if.then40:                                        ; preds = %if.end37
  %31 = load ptr, ptr %args.addr, align 8
  %arrayidx41 = getelementptr ptr, ptr %31, i64 5
  %32 = load ptr, ptr %arrayidx41, align 8
  %call42 = call i32 @PyObject_IsTrue(ptr noundef %32)
  store i32 %call42, ptr %resetids, align 4
  %33 = load i32, ptr %resetids, align 4
  %cmp43 = icmp slt i32 %33, 0
  br i1 %cmp43, label %if.then44, label %if.end45

if.then44:                                        ; preds = %if.then40
  br label %exit

if.end45:                                         ; preds = %if.then40
  %34 = load i64, ptr %noptargs, align 8
  %dec46 = add i64 %34, -1
  store i64 %dec46, ptr %noptargs, align 8
  %tobool47 = icmp ne i64 %dec46, 0
  br i1 %tobool47, label %if.end49, label %if.then48

if.then48:                                        ; preds = %if.end45
  br label %skip_optional_kwonly

if.end49:                                         ; preds = %if.end45
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.end37
  %35 = load ptr, ptr %args.addr, align 8
  %arrayidx51 = getelementptr ptr, ptr %35, i64 6
  %36 = load ptr, ptr %arrayidx51, align 8
  %tobool52 = icmp ne ptr %36, null
  br i1 %tobool52, label %if.then53, label %if.end63

if.then53:                                        ; preds = %if.end50
  %37 = load ptr, ptr %args.addr, align 8
  %arrayidx54 = getelementptr ptr, ptr %37, i64 6
  %38 = load ptr, ptr %arrayidx54, align 8
  %call55 = call i32 @PyObject_IsTrue(ptr noundef %38)
  store i32 %call55, ptr %setsid, align 4
  %39 = load i32, ptr %setsid, align 4
  %cmp56 = icmp slt i32 %39, 0
  br i1 %cmp56, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.then53
  br label %exit

if.end58:                                         ; preds = %if.then53
  %40 = load i64, ptr %noptargs, align 8
  %dec59 = add i64 %40, -1
  store i64 %dec59, ptr %noptargs, align 8
  %tobool60 = icmp ne i64 %dec59, 0
  br i1 %tobool60, label %if.end62, label %if.then61

if.then61:                                        ; preds = %if.end58
  br label %skip_optional_kwonly

if.end62:                                         ; preds = %if.end58
  br label %if.end63

if.end63:                                         ; preds = %if.end62, %if.end50
  %41 = load ptr, ptr %args.addr, align 8
  %arrayidx64 = getelementptr ptr, ptr %41, i64 7
  %42 = load ptr, ptr %arrayidx64, align 8
  %tobool65 = icmp ne ptr %42, null
  br i1 %tobool65, label %if.then66, label %if.end72

if.then66:                                        ; preds = %if.end63
  %43 = load ptr, ptr %args.addr, align 8
  %arrayidx67 = getelementptr ptr, ptr %43, i64 7
  %44 = load ptr, ptr %arrayidx67, align 8
  store ptr %44, ptr %setsigmask, align 8
  %45 = load i64, ptr %noptargs, align 8
  %dec68 = add i64 %45, -1
  store i64 %dec68, ptr %noptargs, align 8
  %tobool69 = icmp ne i64 %dec68, 0
  br i1 %tobool69, label %if.end71, label %if.then70

if.then70:                                        ; preds = %if.then66
  br label %skip_optional_kwonly

if.end71:                                         ; preds = %if.then66
  br label %if.end72

if.end72:                                         ; preds = %if.end71, %if.end63
  %46 = load ptr, ptr %args.addr, align 8
  %arrayidx73 = getelementptr ptr, ptr %46, i64 8
  %47 = load ptr, ptr %arrayidx73, align 8
  %tobool74 = icmp ne ptr %47, null
  br i1 %tobool74, label %if.then75, label %if.end81

if.then75:                                        ; preds = %if.end72
  %48 = load ptr, ptr %args.addr, align 8
  %arrayidx76 = getelementptr ptr, ptr %48, i64 8
  %49 = load ptr, ptr %arrayidx76, align 8
  store ptr %49, ptr %setsigdef, align 8
  %50 = load i64, ptr %noptargs, align 8
  %dec77 = add i64 %50, -1
  store i64 %dec77, ptr %noptargs, align 8
  %tobool78 = icmp ne i64 %dec77, 0
  br i1 %tobool78, label %if.end80, label %if.then79

if.then79:                                        ; preds = %if.then75
  br label %skip_optional_kwonly

if.end80:                                         ; preds = %if.then75
  br label %if.end81

if.end81:                                         ; preds = %if.end80, %if.end72
  %51 = load ptr, ptr %args.addr, align 8
  %arrayidx82 = getelementptr ptr, ptr %51, i64 9
  %52 = load ptr, ptr %arrayidx82, align 8
  store ptr %52, ptr %scheduler, align 8
  br label %skip_optional_kwonly

skip_optional_kwonly:                             ; preds = %if.end81, %if.then79, %if.then70, %if.then61, %if.then48, %if.then35, %if.then26, %if.then19
  %53 = load ptr, ptr %module.addr, align 8
  %54 = load ptr, ptr %argv, align 8
  %55 = load ptr, ptr %env, align 8
  %56 = load ptr, ptr %file_actions, align 8
  %57 = load ptr, ptr %setpgroup, align 8
  %58 = load i32, ptr %resetids, align 4
  %59 = load i32, ptr %setsid, align 4
  %60 = load ptr, ptr %setsigmask, align 8
  %61 = load ptr, ptr %setsigdef, align 8
  %62 = load ptr, ptr %scheduler, align 8
  %call83 = call ptr @os_posix_spawnp_impl(ptr noundef %53, ptr noundef %path, ptr noundef %54, ptr noundef %55, ptr noundef %56, ptr noundef %57, i32 noundef %58, i32 noundef %59, ptr noundef %60, ptr noundef %61, ptr noundef %62)
  store ptr %call83, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional_kwonly, %if.then57, %if.then44, %if.then14, %if.then
  call void @path_cleanup(ptr noundef %path)
  %63 = load ptr, ptr %return_value, align 8
  ret ptr %63
}

; Function Attrs: nounwind uwtable
define internal ptr @os_readlink(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [2 x ptr], align 16
  %noptargs = alloca i64, align 8
  %path = alloca %struct.path_t, align 8
  %dir_fd = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 1
  store i64 %sub, ptr %noptargs, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %path, ptr align 8 @__const.os_readlink.path, i64 72, i1 false)
  store i32 -100, ptr %dir_fd, align 4
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 1, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 1
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [2 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @os_readlink._parser, i32 noundef 1, i32 noundef 1, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %12, i64 0
  %13 = load ptr, ptr %arrayidx, align 8
  %call12 = call i32 @path_converter(ptr noundef %13, ptr noundef %path)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end
  br label %exit

if.end15:                                         ; preds = %if.end
  %14 = load i64, ptr %noptargs, align 8
  %tobool16 = icmp ne i64 %14, 0
  br i1 %tobool16, label %if.end18, label %if.then17

if.then17:                                        ; preds = %if.end15
  br label %skip_optional_kwonly

if.end18:                                         ; preds = %if.end15
  %15 = load ptr, ptr %args.addr, align 8
  %arrayidx19 = getelementptr ptr, ptr %15, i64 1
  %16 = load ptr, ptr %arrayidx19, align 8
  %call20 = call i32 @dir_fd_converter(ptr noundef %16, ptr noundef %dir_fd)
  %tobool21 = icmp ne i32 %call20, 0
  br i1 %tobool21, label %if.end23, label %if.then22

if.then22:                                        ; preds = %if.end18
  br label %exit

if.end23:                                         ; preds = %if.end18
  br label %skip_optional_kwonly

skip_optional_kwonly:                             ; preds = %if.end23, %if.then17
  %17 = load ptr, ptr %module.addr, align 8
  %18 = load i32, ptr %dir_fd, align 4
  %call24 = call ptr @os_readlink_impl(ptr noundef %17, ptr noundef %path, i32 noundef %18)
  store ptr %call24, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional_kwonly, %if.then22, %if.then14, %if.then
  call void @path_cleanup(ptr noundef %path)
  %19 = load ptr, ptr %return_value, align 8
  ret ptr %19
}

; Function Attrs: nounwind uwtable
define internal ptr @os_copy_file_range(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %op.addr.i52 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [5 x ptr], align 16
  %noptargs = alloca i64, align 8
  %src = alloca i32, align 4
  %dst = alloca i32, align 4
  %count = alloca i64, align 8
  %offset_src = alloca ptr, align 8
  %offset_dst = alloca ptr, align 8
  %ival = alloca i64, align 8
  %iobj = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 3
  store i64 %sub, ptr %noptargs, align 8
  store ptr @_Py_NoneStruct, ptr %offset_src, align 8
  store ptr @_Py_NoneStruct, ptr %offset_dst, align 8
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 3, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 5
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [5 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @os_copy_file_range._parser, i32 noundef 3, i32 noundef 5, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %12, i64 0
  %13 = load ptr, ptr %arrayidx, align 8
  %call12 = call i32 @PyLong_AsInt(ptr noundef %13)
  store i32 %call12, ptr %src, align 4
  %14 = load i32, ptr %src, align 4
  %cmp13 = icmp eq i32 %14, -1
  br i1 %cmp13, label %land.lhs.true14, label %if.end18

land.lhs.true14:                                  ; preds = %if.end
  %call15 = call ptr @PyErr_Occurred()
  %tobool16 = icmp ne ptr %call15, null
  br i1 %tobool16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %land.lhs.true14
  br label %exit

if.end18:                                         ; preds = %land.lhs.true14, %if.end
  %15 = load ptr, ptr %args.addr, align 8
  %arrayidx19 = getelementptr ptr, ptr %15, i64 1
  %16 = load ptr, ptr %arrayidx19, align 8
  %call20 = call i32 @PyLong_AsInt(ptr noundef %16)
  store i32 %call20, ptr %dst, align 4
  %17 = load i32, ptr %dst, align 4
  %cmp21 = icmp eq i32 %17, -1
  br i1 %cmp21, label %land.lhs.true22, label %if.end26

land.lhs.true22:                                  ; preds = %if.end18
  %call23 = call ptr @PyErr_Occurred()
  %tobool24 = icmp ne ptr %call23, null
  br i1 %tobool24, label %if.then25, label %if.end26

if.then25:                                        ; preds = %land.lhs.true22
  br label %exit

if.end26:                                         ; preds = %land.lhs.true22, %if.end18
  store i64 -1, ptr %ival, align 8
  %18 = load ptr, ptr %args.addr, align 8
  %arrayidx27 = getelementptr ptr, ptr %18, i64 2
  %19 = load ptr, ptr %arrayidx27, align 8
  %call28 = call ptr @_PyNumber_Index(ptr noundef %19)
  store ptr %call28, ptr %iobj, align 8
  %20 = load ptr, ptr %iobj, align 8
  %cmp29 = icmp ne ptr %20, null
  br i1 %cmp29, label %if.then30, label %if.end32

if.then30:                                        ; preds = %if.end26
  %21 = load ptr, ptr %iobj, align 8
  %call31 = call i64 @PyLong_AsSsize_t(ptr noundef %21)
  store i64 %call31, ptr %ival, align 8
  %22 = load ptr, ptr %iobj, align 8
  store ptr %22, ptr %op.addr.i, align 8
  %23 = load ptr, ptr %op.addr.i, align 8
  store ptr %23, ptr %op.addr.i52, align 8
  %24 = load ptr, ptr %op.addr.i52, align 8
  %25 = load i64, ptr %24, align 8
  %conv.i = trunc i64 %25 to i32
  %cmp.i53 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i53 to i32
  %tobool.i = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then30
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.then30
  %26 = load ptr, ptr %op.addr.i, align 8
  %27 = load i64, ptr %26, align 8
  %dec.i = add i64 %27, -1
  store i64 %dec.i, ptr %26, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %28 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %28) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  br label %if.end32

if.end32:                                         ; preds = %Py_DECREF.exit, %if.end26
  %29 = load i64, ptr %ival, align 8
  %cmp33 = icmp eq i64 %29, -1
  br i1 %cmp33, label %land.lhs.true34, label %if.end38

land.lhs.true34:                                  ; preds = %if.end32
  %call35 = call ptr @PyErr_Occurred()
  %tobool36 = icmp ne ptr %call35, null
  br i1 %tobool36, label %if.then37, label %if.end38

if.then37:                                        ; preds = %land.lhs.true34
  br label %exit

if.end38:                                         ; preds = %land.lhs.true34, %if.end32
  %30 = load i64, ptr %ival, align 8
  store i64 %30, ptr %count, align 8
  %31 = load i64, ptr %noptargs, align 8
  %tobool39 = icmp ne i64 %31, 0
  br i1 %tobool39, label %if.end41, label %if.then40

if.then40:                                        ; preds = %if.end38
  br label %skip_optional_pos

if.end41:                                         ; preds = %if.end38
  %32 = load ptr, ptr %args.addr, align 8
  %arrayidx42 = getelementptr ptr, ptr %32, i64 3
  %33 = load ptr, ptr %arrayidx42, align 8
  %tobool43 = icmp ne ptr %33, null
  br i1 %tobool43, label %if.then44, label %if.end49

if.then44:                                        ; preds = %if.end41
  %34 = load ptr, ptr %args.addr, align 8
  %arrayidx45 = getelementptr ptr, ptr %34, i64 3
  %35 = load ptr, ptr %arrayidx45, align 8
  store ptr %35, ptr %offset_src, align 8
  %36 = load i64, ptr %noptargs, align 8
  %dec = add i64 %36, -1
  store i64 %dec, ptr %noptargs, align 8
  %tobool46 = icmp ne i64 %dec, 0
  br i1 %tobool46, label %if.end48, label %if.then47

if.then47:                                        ; preds = %if.then44
  br label %skip_optional_pos

if.end48:                                         ; preds = %if.then44
  br label %if.end49

if.end49:                                         ; preds = %if.end48, %if.end41
  %37 = load ptr, ptr %args.addr, align 8
  %arrayidx50 = getelementptr ptr, ptr %37, i64 4
  %38 = load ptr, ptr %arrayidx50, align 8
  store ptr %38, ptr %offset_dst, align 8
  br label %skip_optional_pos

skip_optional_pos:                                ; preds = %if.end49, %if.then47, %if.then40
  %39 = load ptr, ptr %module.addr, align 8
  %40 = load i32, ptr %src, align 4
  %41 = load i32, ptr %dst, align 4
  %42 = load i64, ptr %count, align 8
  %43 = load ptr, ptr %offset_src, align 8
  %44 = load ptr, ptr %offset_dst, align 8
  %call51 = call ptr @os_copy_file_range_impl(ptr noundef %39, i32 noundef %40, i32 noundef %41, i64 noundef %42, ptr noundef %43, ptr noundef %44)
  store ptr %call51, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional_pos, %if.then37, %if.then25, %if.then17, %if.then
  %45 = load ptr, ptr %return_value, align 8
  ret ptr %45
}

; Function Attrs: nounwind uwtable
define internal ptr @os_splice(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %op.addr.i65 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [6 x ptr], align 16
  %noptargs = alloca i64, align 8
  %src = alloca i32, align 4
  %dst = alloca i32, align 4
  %count = alloca i64, align 8
  %offset_src = alloca ptr, align 8
  %offset_dst = alloca ptr, align 8
  %flags = alloca i32, align 4
  %ival = alloca i64, align 8
  %iobj = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 3
  store i64 %sub, ptr %noptargs, align 8
  store ptr @_Py_NoneStruct, ptr %offset_src, align 8
  store ptr @_Py_NoneStruct, ptr %offset_dst, align 8
  store i32 0, ptr %flags, align 4
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 3, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 6
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [6 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @os_splice._parser, i32 noundef 3, i32 noundef 6, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %12, i64 0
  %13 = load ptr, ptr %arrayidx, align 8
  %call12 = call i32 @PyLong_AsInt(ptr noundef %13)
  store i32 %call12, ptr %src, align 4
  %14 = load i32, ptr %src, align 4
  %cmp13 = icmp eq i32 %14, -1
  br i1 %cmp13, label %land.lhs.true14, label %if.end18

land.lhs.true14:                                  ; preds = %if.end
  %call15 = call ptr @PyErr_Occurred()
  %tobool16 = icmp ne ptr %call15, null
  br i1 %tobool16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %land.lhs.true14
  br label %exit

if.end18:                                         ; preds = %land.lhs.true14, %if.end
  %15 = load ptr, ptr %args.addr, align 8
  %arrayidx19 = getelementptr ptr, ptr %15, i64 1
  %16 = load ptr, ptr %arrayidx19, align 8
  %call20 = call i32 @PyLong_AsInt(ptr noundef %16)
  store i32 %call20, ptr %dst, align 4
  %17 = load i32, ptr %dst, align 4
  %cmp21 = icmp eq i32 %17, -1
  br i1 %cmp21, label %land.lhs.true22, label %if.end26

land.lhs.true22:                                  ; preds = %if.end18
  %call23 = call ptr @PyErr_Occurred()
  %tobool24 = icmp ne ptr %call23, null
  br i1 %tobool24, label %if.then25, label %if.end26

if.then25:                                        ; preds = %land.lhs.true22
  br label %exit

if.end26:                                         ; preds = %land.lhs.true22, %if.end18
  store i64 -1, ptr %ival, align 8
  %18 = load ptr, ptr %args.addr, align 8
  %arrayidx27 = getelementptr ptr, ptr %18, i64 2
  %19 = load ptr, ptr %arrayidx27, align 8
  %call28 = call ptr @_PyNumber_Index(ptr noundef %19)
  store ptr %call28, ptr %iobj, align 8
  %20 = load ptr, ptr %iobj, align 8
  %cmp29 = icmp ne ptr %20, null
  br i1 %cmp29, label %if.then30, label %if.end32

if.then30:                                        ; preds = %if.end26
  %21 = load ptr, ptr %iobj, align 8
  %call31 = call i64 @PyLong_AsSsize_t(ptr noundef %21)
  store i64 %call31, ptr %ival, align 8
  %22 = load ptr, ptr %iobj, align 8
  store ptr %22, ptr %op.addr.i, align 8
  %23 = load ptr, ptr %op.addr.i, align 8
  store ptr %23, ptr %op.addr.i65, align 8
  %24 = load ptr, ptr %op.addr.i65, align 8
  %25 = load i64, ptr %24, align 8
  %conv.i = trunc i64 %25 to i32
  %cmp.i66 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i66 to i32
  %tobool.i = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then30
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.then30
  %26 = load ptr, ptr %op.addr.i, align 8
  %27 = load i64, ptr %26, align 8
  %dec.i = add i64 %27, -1
  store i64 %dec.i, ptr %26, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %28 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %28) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  br label %if.end32

if.end32:                                         ; preds = %Py_DECREF.exit, %if.end26
  %29 = load i64, ptr %ival, align 8
  %cmp33 = icmp eq i64 %29, -1
  br i1 %cmp33, label %land.lhs.true34, label %if.end38

land.lhs.true34:                                  ; preds = %if.end32
  %call35 = call ptr @PyErr_Occurred()
  %tobool36 = icmp ne ptr %call35, null
  br i1 %tobool36, label %if.then37, label %if.end38

if.then37:                                        ; preds = %land.lhs.true34
  br label %exit

if.end38:                                         ; preds = %land.lhs.true34, %if.end32
  %30 = load i64, ptr %ival, align 8
  store i64 %30, ptr %count, align 8
  %31 = load i64, ptr %noptargs, align 8
  %tobool39 = icmp ne i64 %31, 0
  br i1 %tobool39, label %if.end41, label %if.then40

if.then40:                                        ; preds = %if.end38
  br label %skip_optional_pos

if.end41:                                         ; preds = %if.end38
  %32 = load ptr, ptr %args.addr, align 8
  %arrayidx42 = getelementptr ptr, ptr %32, i64 3
  %33 = load ptr, ptr %arrayidx42, align 8
  %tobool43 = icmp ne ptr %33, null
  br i1 %tobool43, label %if.then44, label %if.end49

if.then44:                                        ; preds = %if.end41
  %34 = load ptr, ptr %args.addr, align 8
  %arrayidx45 = getelementptr ptr, ptr %34, i64 3
  %35 = load ptr, ptr %arrayidx45, align 8
  store ptr %35, ptr %offset_src, align 8
  %36 = load i64, ptr %noptargs, align 8
  %dec = add i64 %36, -1
  store i64 %dec, ptr %noptargs, align 8
  %tobool46 = icmp ne i64 %dec, 0
  br i1 %tobool46, label %if.end48, label %if.then47

if.then47:                                        ; preds = %if.then44
  br label %skip_optional_pos

if.end48:                                         ; preds = %if.then44
  br label %if.end49

if.end49:                                         ; preds = %if.end48, %if.end41
  %37 = load ptr, ptr %args.addr, align 8
  %arrayidx50 = getelementptr ptr, ptr %37, i64 4
  %38 = load ptr, ptr %arrayidx50, align 8
  %tobool51 = icmp ne ptr %38, null
  br i1 %tobool51, label %if.then52, label %if.end58

if.then52:                                        ; preds = %if.end49
  %39 = load ptr, ptr %args.addr, align 8
  %arrayidx53 = getelementptr ptr, ptr %39, i64 4
  %40 = load ptr, ptr %arrayidx53, align 8
  store ptr %40, ptr %offset_dst, align 8
  %41 = load i64, ptr %noptargs, align 8
  %dec54 = add i64 %41, -1
  store i64 %dec54, ptr %noptargs, align 8
  %tobool55 = icmp ne i64 %dec54, 0
  br i1 %tobool55, label %if.end57, label %if.then56

if.then56:                                        ; preds = %if.then52
  br label %skip_optional_pos

if.end57:                                         ; preds = %if.then52
  br label %if.end58

if.end58:                                         ; preds = %if.end57, %if.end49
  %42 = load ptr, ptr %args.addr, align 8
  %arrayidx59 = getelementptr ptr, ptr %42, i64 5
  %43 = load ptr, ptr %arrayidx59, align 8
  %call60 = call i32 @_PyLong_UnsignedInt_Converter(ptr noundef %43, ptr noundef %flags)
  %tobool61 = icmp ne i32 %call60, 0
  br i1 %tobool61, label %if.end63, label %if.then62

if.then62:                                        ; preds = %if.end58
  br label %exit

if.end63:                                         ; preds = %if.end58
  br label %skip_optional_pos

skip_optional_pos:                                ; preds = %if.end63, %if.then56, %if.then47, %if.then40
  %44 = load ptr, ptr %module.addr, align 8
  %45 = load i32, ptr %src, align 4
  %46 = load i32, ptr %dst, align 4
  %47 = load i64, ptr %count, align 8
  %48 = load ptr, ptr %offset_src, align 8
  %49 = load ptr, ptr %offset_dst, align 8
  %50 = load i32, ptr %flags, align 4
  %call64 = call ptr @os_splice_impl(ptr noundef %44, i32 noundef %45, i32 noundef %46, i64 noundef %47, ptr noundef %48, ptr noundef %49, i32 noundef %50)
  store ptr %call64, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional_pos, %if.then62, %if.then37, %if.then25, %if.then17, %if.then
  %51 = load ptr, ptr %return_value, align 8
  ret ptr %51
}

; Function Attrs: nounwind uwtable
define internal ptr @os_rename(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [4 x ptr], align 16
  %noptargs = alloca i64, align 8
  %src = alloca %struct.path_t, align 8
  %dst = alloca %struct.path_t, align 8
  %src_dir_fd = alloca i32, align 4
  %dst_dir_fd = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 2
  store i64 %sub, ptr %noptargs, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %src, ptr align 8 @__const.os_rename.src, i64 72, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %dst, ptr align 8 @__const.os_rename.dst, i64 72, i1 false)
  store i32 -100, ptr %src_dir_fd, align 4
  store i32 -100, ptr %dst_dir_fd, align 4
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 2, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 2
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [4 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @os_rename._parser, i32 noundef 2, i32 noundef 2, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %12, i64 0
  %13 = load ptr, ptr %arrayidx, align 8
  %call12 = call i32 @path_converter(ptr noundef %13, ptr noundef %src)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end
  br label %exit

if.end15:                                         ; preds = %if.end
  %14 = load ptr, ptr %args.addr, align 8
  %arrayidx16 = getelementptr ptr, ptr %14, i64 1
  %15 = load ptr, ptr %arrayidx16, align 8
  %call17 = call i32 @path_converter(ptr noundef %15, ptr noundef %dst)
  %tobool18 = icmp ne i32 %call17, 0
  br i1 %tobool18, label %if.end20, label %if.then19

if.then19:                                        ; preds = %if.end15
  br label %exit

if.end20:                                         ; preds = %if.end15
  %16 = load i64, ptr %noptargs, align 8
  %tobool21 = icmp ne i64 %16, 0
  br i1 %tobool21, label %if.end23, label %if.then22

if.then22:                                        ; preds = %if.end20
  br label %skip_optional_kwonly

if.end23:                                         ; preds = %if.end20
  %17 = load ptr, ptr %args.addr, align 8
  %arrayidx24 = getelementptr ptr, ptr %17, i64 2
  %18 = load ptr, ptr %arrayidx24, align 8
  %tobool25 = icmp ne ptr %18, null
  br i1 %tobool25, label %if.then26, label %if.end35

if.then26:                                        ; preds = %if.end23
  %19 = load ptr, ptr %args.addr, align 8
  %arrayidx27 = getelementptr ptr, ptr %19, i64 2
  %20 = load ptr, ptr %arrayidx27, align 8
  %call28 = call i32 @dir_fd_converter(ptr noundef %20, ptr noundef %src_dir_fd)
  %tobool29 = icmp ne i32 %call28, 0
  br i1 %tobool29, label %if.end31, label %if.then30

if.then30:                                        ; preds = %if.then26
  br label %exit

if.end31:                                         ; preds = %if.then26
  %21 = load i64, ptr %noptargs, align 8
  %dec = add i64 %21, -1
  store i64 %dec, ptr %noptargs, align 8
  %tobool32 = icmp ne i64 %dec, 0
  br i1 %tobool32, label %if.end34, label %if.then33

if.then33:                                        ; preds = %if.end31
  br label %skip_optional_kwonly

if.end34:                                         ; preds = %if.end31
  br label %if.end35

if.end35:                                         ; preds = %if.end34, %if.end23
  %22 = load ptr, ptr %args.addr, align 8
  %arrayidx36 = getelementptr ptr, ptr %22, i64 3
  %23 = load ptr, ptr %arrayidx36, align 8
  %call37 = call i32 @dir_fd_converter(ptr noundef %23, ptr noundef %dst_dir_fd)
  %tobool38 = icmp ne i32 %call37, 0
  br i1 %tobool38, label %if.end40, label %if.then39

if.then39:                                        ; preds = %if.end35
  br label %exit

if.end40:                                         ; preds = %if.end35
  br label %skip_optional_kwonly

skip_optional_kwonly:                             ; preds = %if.end40, %if.then33, %if.then22
  %24 = load ptr, ptr %module.addr, align 8
  %25 = load i32, ptr %src_dir_fd, align 4
  %26 = load i32, ptr %dst_dir_fd, align 4
  %call41 = call ptr @os_rename_impl(ptr noundef %24, ptr noundef %src, ptr noundef %dst, i32 noundef %25, i32 noundef %26)
  store ptr %call41, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional_kwonly, %if.then39, %if.then30, %if.then19, %if.then14, %if.then
  call void @path_cleanup(ptr noundef %src)
  call void @path_cleanup(ptr noundef %dst)
  %27 = load ptr, ptr %return_value, align 8
  ret ptr %27
}

; Function Attrs: nounwind uwtable
define internal ptr @os_replace(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [4 x ptr], align 16
  %noptargs = alloca i64, align 8
  %src = alloca %struct.path_t, align 8
  %dst = alloca %struct.path_t, align 8
  %src_dir_fd = alloca i32, align 4
  %dst_dir_fd = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 2
  store i64 %sub, ptr %noptargs, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %src, ptr align 8 @__const.os_replace.src, i64 72, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %dst, ptr align 8 @__const.os_replace.dst, i64 72, i1 false)
  store i32 -100, ptr %src_dir_fd, align 4
  store i32 -100, ptr %dst_dir_fd, align 4
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 2, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 2
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [4 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @os_replace._parser, i32 noundef 2, i32 noundef 2, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %12, i64 0
  %13 = load ptr, ptr %arrayidx, align 8
  %call12 = call i32 @path_converter(ptr noundef %13, ptr noundef %src)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end
  br label %exit

if.end15:                                         ; preds = %if.end
  %14 = load ptr, ptr %args.addr, align 8
  %arrayidx16 = getelementptr ptr, ptr %14, i64 1
  %15 = load ptr, ptr %arrayidx16, align 8
  %call17 = call i32 @path_converter(ptr noundef %15, ptr noundef %dst)
  %tobool18 = icmp ne i32 %call17, 0
  br i1 %tobool18, label %if.end20, label %if.then19

if.then19:                                        ; preds = %if.end15
  br label %exit

if.end20:                                         ; preds = %if.end15
  %16 = load i64, ptr %noptargs, align 8
  %tobool21 = icmp ne i64 %16, 0
  br i1 %tobool21, label %if.end23, label %if.then22

if.then22:                                        ; preds = %if.end20
  br label %skip_optional_kwonly

if.end23:                                         ; preds = %if.end20
  %17 = load ptr, ptr %args.addr, align 8
  %arrayidx24 = getelementptr ptr, ptr %17, i64 2
  %18 = load ptr, ptr %arrayidx24, align 8
  %tobool25 = icmp ne ptr %18, null
  br i1 %tobool25, label %if.then26, label %if.end35

if.then26:                                        ; preds = %if.end23
  %19 = load ptr, ptr %args.addr, align 8
  %arrayidx27 = getelementptr ptr, ptr %19, i64 2
  %20 = load ptr, ptr %arrayidx27, align 8
  %call28 = call i32 @dir_fd_converter(ptr noundef %20, ptr noundef %src_dir_fd)
  %tobool29 = icmp ne i32 %call28, 0
  br i1 %tobool29, label %if.end31, label %if.then30

if.then30:                                        ; preds = %if.then26
  br label %exit

if.end31:                                         ; preds = %if.then26
  %21 = load i64, ptr %noptargs, align 8
  %dec = add i64 %21, -1
  store i64 %dec, ptr %noptargs, align 8
  %tobool32 = icmp ne i64 %dec, 0
  br i1 %tobool32, label %if.end34, label %if.then33

if.then33:                                        ; preds = %if.end31
  br label %skip_optional_kwonly

if.end34:                                         ; preds = %if.end31
  br label %if.end35

if.end35:                                         ; preds = %if.end34, %if.end23
  %22 = load ptr, ptr %args.addr, align 8
  %arrayidx36 = getelementptr ptr, ptr %22, i64 3
  %23 = load ptr, ptr %arrayidx36, align 8
  %call37 = call i32 @dir_fd_converter(ptr noundef %23, ptr noundef %dst_dir_fd)
  %tobool38 = icmp ne i32 %call37, 0
  br i1 %tobool38, label %if.end40, label %if.then39

if.then39:                                        ; preds = %if.end35
  br label %exit

if.end40:                                         ; preds = %if.end35
  br label %skip_optional_kwonly

skip_optional_kwonly:                             ; preds = %if.end40, %if.then33, %if.then22
  %24 = load ptr, ptr %module.addr, align 8
  %25 = load i32, ptr %src_dir_fd, align 4
  %26 = load i32, ptr %dst_dir_fd, align 4
  %call41 = call ptr @os_replace_impl(ptr noundef %24, ptr noundef %src, ptr noundef %dst, i32 noundef %25, i32 noundef %26)
  store ptr %call41, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional_kwonly, %if.then39, %if.then30, %if.then19, %if.then14, %if.then
  call void @path_cleanup(ptr noundef %src)
  call void @path_cleanup(ptr noundef %dst)
  %27 = load ptr, ptr %return_value, align 8
  ret ptr %27
}

; Function Attrs: nounwind uwtable
define internal ptr @os_rmdir(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [2 x ptr], align 16
  %noptargs = alloca i64, align 8
  %path = alloca %struct.path_t, align 8
  %dir_fd = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 1
  store i64 %sub, ptr %noptargs, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %path, ptr align 8 @__const.os_rmdir.path, i64 72, i1 false)
  store i32 -100, ptr %dir_fd, align 4
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 1, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 1
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [2 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @os_rmdir._parser, i32 noundef 1, i32 noundef 1, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %12, i64 0
  %13 = load ptr, ptr %arrayidx, align 8
  %call12 = call i32 @path_converter(ptr noundef %13, ptr noundef %path)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end
  br label %exit

if.end15:                                         ; preds = %if.end
  %14 = load i64, ptr %noptargs, align 8
  %tobool16 = icmp ne i64 %14, 0
  br i1 %tobool16, label %if.end18, label %if.then17

if.then17:                                        ; preds = %if.end15
  br label %skip_optional_kwonly

if.end18:                                         ; preds = %if.end15
  %15 = load ptr, ptr %args.addr, align 8
  %arrayidx19 = getelementptr ptr, ptr %15, i64 1
  %16 = load ptr, ptr %arrayidx19, align 8
  %call20 = call i32 @dir_fd_converter(ptr noundef %16, ptr noundef %dir_fd)
  %tobool21 = icmp ne i32 %call20, 0
  br i1 %tobool21, label %if.end23, label %if.then22

if.then22:                                        ; preds = %if.end18
  br label %exit

if.end23:                                         ; preds = %if.end18
  br label %skip_optional_kwonly

skip_optional_kwonly:                             ; preds = %if.end23, %if.then17
  %17 = load ptr, ptr %module.addr, align 8
  %18 = load i32, ptr %dir_fd, align 4
  %call24 = call ptr @os_rmdir_impl(ptr noundef %17, ptr noundef %path, i32 noundef %18)
  store ptr %call24, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional_kwonly, %if.then22, %if.then14, %if.then
  call void @path_cleanup(ptr noundef %path)
  %19 = load ptr, ptr %return_value, align 8
  ret ptr %19
}

; Function Attrs: nounwind uwtable
define internal ptr @os_symlink(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [4 x ptr], align 16
  %noptargs = alloca i64, align 8
  %src = alloca %struct.path_t, align 8
  %dst = alloca %struct.path_t, align 8
  %target_is_directory = alloca i32, align 4
  %dir_fd = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 2
  store i64 %sub, ptr %noptargs, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %src, ptr align 8 @__const.os_symlink.src, i64 72, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %dst, ptr align 8 @__const.os_symlink.dst, i64 72, i1 false)
  store i32 0, ptr %target_is_directory, align 4
  store i32 -100, ptr %dir_fd, align 4
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 2, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 3
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [4 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @os_symlink._parser, i32 noundef 2, i32 noundef 3, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %12, i64 0
  %13 = load ptr, ptr %arrayidx, align 8
  %call12 = call i32 @path_converter(ptr noundef %13, ptr noundef %src)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end
  br label %exit

if.end15:                                         ; preds = %if.end
  %14 = load ptr, ptr %args.addr, align 8
  %arrayidx16 = getelementptr ptr, ptr %14, i64 1
  %15 = load ptr, ptr %arrayidx16, align 8
  %call17 = call i32 @path_converter(ptr noundef %15, ptr noundef %dst)
  %tobool18 = icmp ne i32 %call17, 0
  br i1 %tobool18, label %if.end20, label %if.then19

if.then19:                                        ; preds = %if.end15
  br label %exit

if.end20:                                         ; preds = %if.end15
  %16 = load i64, ptr %noptargs, align 8
  %tobool21 = icmp ne i64 %16, 0
  br i1 %tobool21, label %if.end23, label %if.then22

if.then22:                                        ; preds = %if.end20
  br label %skip_optional_pos

if.end23:                                         ; preds = %if.end20
  %17 = load ptr, ptr %args.addr, align 8
  %arrayidx24 = getelementptr ptr, ptr %17, i64 2
  %18 = load ptr, ptr %arrayidx24, align 8
  %tobool25 = icmp ne ptr %18, null
  br i1 %tobool25, label %if.then26, label %if.end35

if.then26:                                        ; preds = %if.end23
  %19 = load ptr, ptr %args.addr, align 8
  %arrayidx27 = getelementptr ptr, ptr %19, i64 2
  %20 = load ptr, ptr %arrayidx27, align 8
  %call28 = call i32 @PyObject_IsTrue(ptr noundef %20)
  store i32 %call28, ptr %target_is_directory, align 4
  %21 = load i32, ptr %target_is_directory, align 4
  %cmp29 = icmp slt i32 %21, 0
  br i1 %cmp29, label %if.then30, label %if.end31

if.then30:                                        ; preds = %if.then26
  br label %exit

if.end31:                                         ; preds = %if.then26
  %22 = load i64, ptr %noptargs, align 8
  %dec = add i64 %22, -1
  store i64 %dec, ptr %noptargs, align 8
  %tobool32 = icmp ne i64 %dec, 0
  br i1 %tobool32, label %if.end34, label %if.then33

if.then33:                                        ; preds = %if.end31
  br label %skip_optional_pos

if.end34:                                         ; preds = %if.end31
  br label %if.end35

if.end35:                                         ; preds = %if.end34, %if.end23
  br label %skip_optional_pos

skip_optional_pos:                                ; preds = %if.end35, %if.then33, %if.then22
  %23 = load i64, ptr %noptargs, align 8
  %tobool36 = icmp ne i64 %23, 0
  br i1 %tobool36, label %if.end38, label %if.then37

if.then37:                                        ; preds = %skip_optional_pos
  br label %skip_optional_kwonly

if.end38:                                         ; preds = %skip_optional_pos
  %24 = load ptr, ptr %args.addr, align 8
  %arrayidx39 = getelementptr ptr, ptr %24, i64 3
  %25 = load ptr, ptr %arrayidx39, align 8
  %call40 = call i32 @dir_fd_converter(ptr noundef %25, ptr noundef %dir_fd)
  %tobool41 = icmp ne i32 %call40, 0
  br i1 %tobool41, label %if.end43, label %if.then42

if.then42:                                        ; preds = %if.end38
  br label %exit

if.end43:                                         ; preds = %if.end38
  br label %skip_optional_kwonly

skip_optional_kwonly:                             ; preds = %if.end43, %if.then37
  %26 = load ptr, ptr %module.addr, align 8
  %27 = load i32, ptr %target_is_directory, align 4
  %28 = load i32, ptr %dir_fd, align 4
  %call44 = call ptr @os_symlink_impl(ptr noundef %26, ptr noundef %src, ptr noundef %dst, i32 noundef %27, i32 noundef %28)
  store ptr %call44, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional_kwonly, %if.then42, %if.then30, %if.then19, %if.then14, %if.then
  call void @path_cleanup(ptr noundef %src)
  call void @path_cleanup(ptr noundef %dst)
  %29 = load ptr, ptr %return_value, align 8
  ret ptr %29
}

; Function Attrs: nounwind uwtable
define internal ptr @os_system(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [1 x ptr], align 8
  %command = alloca ptr, align 8
  %_return_value = alloca i64, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  store ptr null, ptr %command, align 8
  %0 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 1, %1
  br i1 %cmp1, label %land.lhs.true2, label %cond.false

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %2, 1
  br i1 %cmp3, label %land.lhs.true4, label %cond.false

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %3 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %3, null
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true4
  %4 = load ptr, ptr %args.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  %5 = load ptr, ptr %args.addr, align 8
  %6 = load i64, ptr %nargs.addr, align 8
  %7 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [1 x ptr], ptr %argsbuf, i64 0, i64 0
  %call = call ptr @_PyArg_UnpackKeywords(ptr noundef %5, i64 noundef %6, ptr noundef null, ptr noundef %7, ptr noundef @os_system._parser, i32 noundef 1, i32 noundef 1, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %4, %cond.true ], [ %call, %cond.false ]
  store ptr %cond, ptr %args.addr, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  br label %exit

if.end:                                           ; preds = %cond.end
  %9 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %9, i64 0
  %10 = load ptr, ptr %arrayidx, align 8
  %call6 = call i32 @PyUnicode_FSConverter(ptr noundef %10, ptr noundef %command)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %if.end
  br label %exit

if.end9:                                          ; preds = %if.end
  %11 = load ptr, ptr %module.addr, align 8
  %12 = load ptr, ptr %command, align 8
  %call10 = call i64 @os_system_impl(ptr noundef %11, ptr noundef %12)
  store i64 %call10, ptr %_return_value, align 8
  %13 = load i64, ptr %_return_value, align 8
  %cmp11 = icmp eq i64 %13, -1
  br i1 %cmp11, label %land.lhs.true12, label %if.end16

land.lhs.true12:                                  ; preds = %if.end9
  %call13 = call ptr @PyErr_Occurred()
  %tobool14 = icmp ne ptr %call13, null
  br i1 %tobool14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %land.lhs.true12
  br label %exit

if.end16:                                         ; preds = %land.lhs.true12, %if.end9
  %14 = load i64, ptr %_return_value, align 8
  %call17 = call ptr @PyLong_FromLong(i64 noundef %14)
  store ptr %call17, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end16, %if.then15, %if.then8, %if.then
  %15 = load ptr, ptr %command, align 8
  call void @Py_XDECREF(ptr noundef %15)
  %16 = load ptr, ptr %return_value, align 8
  ret ptr %16
}

; Function Attrs: nounwind uwtable
define internal ptr @os_umask(ptr noundef %module, ptr noundef %arg) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %mask = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %call = call i32 @PyLong_AsInt(ptr noundef %0)
  store i32 %call, ptr %mask, align 4
  %1 = load i32, ptr %mask, align 4
  %cmp = icmp eq i32 %1, -1
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %call1 = call ptr @PyErr_Occurred()
  %tobool = icmp ne ptr %call1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  br label %exit

if.end:                                           ; preds = %land.lhs.true, %entry
  %2 = load ptr, ptr %module.addr, align 8
  %3 = load i32, ptr %mask, align 4
  %call2 = call ptr @os_umask_impl(ptr noundef %2, i32 noundef %3)
  store ptr %call2, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end, %if.then
  %4 = load ptr, ptr %return_value, align 8
  ret ptr %4
}

; Function Attrs: nounwind uwtable
define internal ptr @os_uname(ptr noundef %module, ptr noundef %_unused_ignored) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %call = call ptr @os_uname_impl(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @os_unlink(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [2 x ptr], align 16
  %noptargs = alloca i64, align 8
  %path = alloca %struct.path_t, align 8
  %dir_fd = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 1
  store i64 %sub, ptr %noptargs, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %path, ptr align 8 @__const.os_unlink.path, i64 72, i1 false)
  store i32 -100, ptr %dir_fd, align 4
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 1, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 1
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [2 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @os_unlink._parser, i32 noundef 1, i32 noundef 1, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %12, i64 0
  %13 = load ptr, ptr %arrayidx, align 8
  %call12 = call i32 @path_converter(ptr noundef %13, ptr noundef %path)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end
  br label %exit

if.end15:                                         ; preds = %if.end
  %14 = load i64, ptr %noptargs, align 8
  %tobool16 = icmp ne i64 %14, 0
  br i1 %tobool16, label %if.end18, label %if.then17

if.then17:                                        ; preds = %if.end15
  br label %skip_optional_kwonly

if.end18:                                         ; preds = %if.end15
  %15 = load ptr, ptr %args.addr, align 8
  %arrayidx19 = getelementptr ptr, ptr %15, i64 1
  %16 = load ptr, ptr %arrayidx19, align 8
  %call20 = call i32 @dir_fd_converter(ptr noundef %16, ptr noundef %dir_fd)
  %tobool21 = icmp ne i32 %call20, 0
  br i1 %tobool21, label %if.end23, label %if.then22

if.then22:                                        ; preds = %if.end18
  br label %exit

if.end23:                                         ; preds = %if.end18
  br label %skip_optional_kwonly

skip_optional_kwonly:                             ; preds = %if.end23, %if.then17
  %17 = load ptr, ptr %module.addr, align 8
  %18 = load i32, ptr %dir_fd, align 4
  %call24 = call ptr @os_unlink_impl(ptr noundef %17, ptr noundef %path, i32 noundef %18)
  store ptr %call24, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional_kwonly, %if.then22, %if.then14, %if.then
  call void @path_cleanup(ptr noundef %path)
  %19 = load ptr, ptr %return_value, align 8
  ret ptr %19
}

; Function Attrs: nounwind uwtable
define internal ptr @os_remove(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [2 x ptr], align 16
  %noptargs = alloca i64, align 8
  %path = alloca %struct.path_t, align 8
  %dir_fd = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 1
  store i64 %sub, ptr %noptargs, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %path, ptr align 8 @__const.os_remove.path, i64 72, i1 false)
  store i32 -100, ptr %dir_fd, align 4
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 1, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 1
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [2 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @os_remove._parser, i32 noundef 1, i32 noundef 1, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %12, i64 0
  %13 = load ptr, ptr %arrayidx, align 8
  %call12 = call i32 @path_converter(ptr noundef %13, ptr noundef %path)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end
  br label %exit

if.end15:                                         ; preds = %if.end
  %14 = load i64, ptr %noptargs, align 8
  %tobool16 = icmp ne i64 %14, 0
  br i1 %tobool16, label %if.end18, label %if.then17

if.then17:                                        ; preds = %if.end15
  br label %skip_optional_kwonly

if.end18:                                         ; preds = %if.end15
  %15 = load ptr, ptr %args.addr, align 8
  %arrayidx19 = getelementptr ptr, ptr %15, i64 1
  %16 = load ptr, ptr %arrayidx19, align 8
  %call20 = call i32 @dir_fd_converter(ptr noundef %16, ptr noundef %dir_fd)
  %tobool21 = icmp ne i32 %call20, 0
  br i1 %tobool21, label %if.end23, label %if.then22

if.then22:                                        ; preds = %if.end18
  br label %exit

if.end23:                                         ; preds = %if.end18
  br label %skip_optional_kwonly

skip_optional_kwonly:                             ; preds = %if.end23, %if.then17
  %17 = load ptr, ptr %module.addr, align 8
  %18 = load i32, ptr %dir_fd, align 4
  %call24 = call ptr @os_remove_impl(ptr noundef %17, ptr noundef %path, i32 noundef %18)
  store ptr %call24, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional_kwonly, %if.then22, %if.then14, %if.then
  call void @path_cleanup(ptr noundef %path)
  %19 = load ptr, ptr %return_value, align 8
  ret ptr %19
}

; Function Attrs: nounwind uwtable
define internal ptr @os_utime(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [5 x ptr], align 16
  %noptargs = alloca i64, align 8
  %path = alloca %struct.path_t, align 8
  %times = alloca ptr, align 8
  %ns = alloca ptr, align 8
  %dir_fd = alloca i32, align 4
  %follow_symlinks = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 1
  store i64 %sub, ptr %noptargs, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %path, ptr align 8 @__const.os_utime.path, i64 72, i1 false)
  store ptr @_Py_NoneStruct, ptr %times, align 8
  store ptr null, ptr %ns, align 8
  store i32 -100, ptr %dir_fd, align 4
  store i32 1, ptr %follow_symlinks, align 4
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 1, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 2
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [5 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @os_utime._parser, i32 noundef 1, i32 noundef 2, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %12, i64 0
  %13 = load ptr, ptr %arrayidx, align 8
  %call12 = call i32 @path_converter(ptr noundef %13, ptr noundef %path)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end
  br label %exit

if.end15:                                         ; preds = %if.end
  %14 = load i64, ptr %noptargs, align 8
  %tobool16 = icmp ne i64 %14, 0
  br i1 %tobool16, label %if.end18, label %if.then17

if.then17:                                        ; preds = %if.end15
  br label %skip_optional_pos

if.end18:                                         ; preds = %if.end15
  %15 = load ptr, ptr %args.addr, align 8
  %arrayidx19 = getelementptr ptr, ptr %15, i64 1
  %16 = load ptr, ptr %arrayidx19, align 8
  %tobool20 = icmp ne ptr %16, null
  br i1 %tobool20, label %if.then21, label %if.end26

if.then21:                                        ; preds = %if.end18
  %17 = load ptr, ptr %args.addr, align 8
  %arrayidx22 = getelementptr ptr, ptr %17, i64 1
  %18 = load ptr, ptr %arrayidx22, align 8
  store ptr %18, ptr %times, align 8
  %19 = load i64, ptr %noptargs, align 8
  %dec = add i64 %19, -1
  store i64 %dec, ptr %noptargs, align 8
  %tobool23 = icmp ne i64 %dec, 0
  br i1 %tobool23, label %if.end25, label %if.then24

if.then24:                                        ; preds = %if.then21
  br label %skip_optional_pos

if.end25:                                         ; preds = %if.then21
  br label %if.end26

if.end26:                                         ; preds = %if.end25, %if.end18
  br label %skip_optional_pos

skip_optional_pos:                                ; preds = %if.end26, %if.then24, %if.then17
  %20 = load i64, ptr %noptargs, align 8
  %tobool27 = icmp ne i64 %20, 0
  br i1 %tobool27, label %if.end29, label %if.then28

if.then28:                                        ; preds = %skip_optional_pos
  br label %skip_optional_kwonly

if.end29:                                         ; preds = %skip_optional_pos
  %21 = load ptr, ptr %args.addr, align 8
  %arrayidx30 = getelementptr ptr, ptr %21, i64 2
  %22 = load ptr, ptr %arrayidx30, align 8
  %tobool31 = icmp ne ptr %22, null
  br i1 %tobool31, label %if.then32, label %if.end38

if.then32:                                        ; preds = %if.end29
  %23 = load ptr, ptr %args.addr, align 8
  %arrayidx33 = getelementptr ptr, ptr %23, i64 2
  %24 = load ptr, ptr %arrayidx33, align 8
  store ptr %24, ptr %ns, align 8
  %25 = load i64, ptr %noptargs, align 8
  %dec34 = add i64 %25, -1
  store i64 %dec34, ptr %noptargs, align 8
  %tobool35 = icmp ne i64 %dec34, 0
  br i1 %tobool35, label %if.end37, label %if.then36

if.then36:                                        ; preds = %if.then32
  br label %skip_optional_kwonly

if.end37:                                         ; preds = %if.then32
  br label %if.end38

if.end38:                                         ; preds = %if.end37, %if.end29
  %26 = load ptr, ptr %args.addr, align 8
  %arrayidx39 = getelementptr ptr, ptr %26, i64 3
  %27 = load ptr, ptr %arrayidx39, align 8
  %tobool40 = icmp ne ptr %27, null
  br i1 %tobool40, label %if.then41, label %if.end51

if.then41:                                        ; preds = %if.end38
  %28 = load ptr, ptr %args.addr, align 8
  %arrayidx42 = getelementptr ptr, ptr %28, i64 3
  %29 = load ptr, ptr %arrayidx42, align 8
  %call43 = call i32 @dir_fd_converter(ptr noundef %29, ptr noundef %dir_fd)
  %tobool44 = icmp ne i32 %call43, 0
  br i1 %tobool44, label %if.end46, label %if.then45

if.then45:                                        ; preds = %if.then41
  br label %exit

if.end46:                                         ; preds = %if.then41
  %30 = load i64, ptr %noptargs, align 8
  %dec47 = add i64 %30, -1
  store i64 %dec47, ptr %noptargs, align 8
  %tobool48 = icmp ne i64 %dec47, 0
  br i1 %tobool48, label %if.end50, label %if.then49

if.then49:                                        ; preds = %if.end46
  br label %skip_optional_kwonly

if.end50:                                         ; preds = %if.end46
  br label %if.end51

if.end51:                                         ; preds = %if.end50, %if.end38
  %31 = load ptr, ptr %args.addr, align 8
  %arrayidx52 = getelementptr ptr, ptr %31, i64 4
  %32 = load ptr, ptr %arrayidx52, align 8
  %call53 = call i32 @PyObject_IsTrue(ptr noundef %32)
  store i32 %call53, ptr %follow_symlinks, align 4
  %33 = load i32, ptr %follow_symlinks, align 4
  %cmp54 = icmp slt i32 %33, 0
  br i1 %cmp54, label %if.then55, label %if.end56

if.then55:                                        ; preds = %if.end51
  br label %exit

if.end56:                                         ; preds = %if.end51
  br label %skip_optional_kwonly

skip_optional_kwonly:                             ; preds = %if.end56, %if.then49, %if.then36, %if.then28
  %34 = load ptr, ptr %module.addr, align 8
  %35 = load ptr, ptr %times, align 8
  %36 = load ptr, ptr %ns, align 8
  %37 = load i32, ptr %dir_fd, align 4
  %38 = load i32, ptr %follow_symlinks, align 4
  %call57 = call ptr @os_utime_impl(ptr noundef %34, ptr noundef %path, ptr noundef %35, ptr noundef %36, i32 noundef %37, i32 noundef %38)
  store ptr %call57, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional_kwonly, %if.then55, %if.then45, %if.then14, %if.then
  call void @path_cleanup(ptr noundef %path)
  %39 = load ptr, ptr %return_value, align 8
  ret ptr %39
}

; Function Attrs: nounwind uwtable
define internal ptr @os_times(ptr noundef %module, ptr noundef %_unused_ignored) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %call = call ptr @os_times_impl(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @os__exit(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [1 x ptr], align 8
  %status = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 1, %1
  br i1 %cmp1, label %land.lhs.true2, label %cond.false

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %2, 1
  br i1 %cmp3, label %land.lhs.true4, label %cond.false

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %3 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %3, null
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true4
  %4 = load ptr, ptr %args.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  %5 = load ptr, ptr %args.addr, align 8
  %6 = load i64, ptr %nargs.addr, align 8
  %7 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [1 x ptr], ptr %argsbuf, i64 0, i64 0
  %call = call ptr @_PyArg_UnpackKeywords(ptr noundef %5, i64 noundef %6, ptr noundef null, ptr noundef %7, ptr noundef @os__exit._parser, i32 noundef 1, i32 noundef 1, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %4, %cond.true ], [ %call, %cond.false ]
  store ptr %cond, ptr %args.addr, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  br label %exit

if.end:                                           ; preds = %cond.end
  %9 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %9, i64 0
  %10 = load ptr, ptr %arrayidx, align 8
  %call6 = call i32 @PyLong_AsInt(ptr noundef %10)
  store i32 %call6, ptr %status, align 4
  %11 = load i32, ptr %status, align 4
  %cmp7 = icmp eq i32 %11, -1
  br i1 %cmp7, label %land.lhs.true8, label %if.end12

land.lhs.true8:                                   ; preds = %if.end
  %call9 = call ptr @PyErr_Occurred()
  %tobool10 = icmp ne ptr %call9, null
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %land.lhs.true8
  br label %exit

if.end12:                                         ; preds = %land.lhs.true8, %if.end
  %12 = load ptr, ptr %module.addr, align 8
  %13 = load i32, ptr %status, align 4
  %call13 = call ptr @os__exit_impl(ptr noundef %12, i32 noundef %13)
  store ptr %call13, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end12, %if.then11, %if.then
  %14 = load ptr, ptr %return_value, align 8
  ret ptr %14
}

; Function Attrs: nounwind uwtable
define internal ptr @os_execv(ptr noundef %module, ptr noundef %args, i64 noundef %nargs) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %return_value = alloca ptr, align 8
  %path = alloca %struct.path_t, align 8
  %argv = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %path, ptr align 8 @__const.os_execv.path, i64 72, i1 false)
  %0 = load i64, ptr %nargs.addr, align 8
  %cmp = icmp sle i64 2, %0
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 %1, 2
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %2 = load i64, ptr %nargs.addr, align 8
  %call = call i32 @_PyArg_CheckPositional(ptr noundef @.str.49, i64 noundef %2, i64 noundef 2, i64 noundef 2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false
  br label %exit

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %3 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %3, i64 0
  %4 = load ptr, ptr %arrayidx, align 8
  %call2 = call i32 @path_converter(ptr noundef %4, ptr noundef %path)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.end
  br label %exit

if.end5:                                          ; preds = %if.end
  %5 = load ptr, ptr %args.addr, align 8
  %arrayidx6 = getelementptr ptr, ptr %5, i64 1
  %6 = load ptr, ptr %arrayidx6, align 8
  store ptr %6, ptr %argv, align 8
  %7 = load ptr, ptr %module.addr, align 8
  %8 = load ptr, ptr %argv, align 8
  %call7 = call ptr @os_execv_impl(ptr noundef %7, ptr noundef %path, ptr noundef %8)
  store ptr %call7, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end5, %if.then4, %if.then
  call void @path_cleanup(ptr noundef %path)
  %9 = load ptr, ptr %return_value, align 8
  ret ptr %9
}

; Function Attrs: nounwind uwtable
define internal ptr @os_execve(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [3 x ptr], align 16
  %path = alloca %struct.path_t, align 8
  %argv = alloca ptr, align 8
  %env = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %path, ptr align 8 @__const.os_execve.path, i64 72, i1 false)
  %0 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 3, %1
  br i1 %cmp1, label %land.lhs.true2, label %cond.false

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %2, 3
  br i1 %cmp3, label %land.lhs.true4, label %cond.false

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %3 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %3, null
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true4
  %4 = load ptr, ptr %args.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  %5 = load ptr, ptr %args.addr, align 8
  %6 = load i64, ptr %nargs.addr, align 8
  %7 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [3 x ptr], ptr %argsbuf, i64 0, i64 0
  %call = call ptr @_PyArg_UnpackKeywords(ptr noundef %5, i64 noundef %6, ptr noundef null, ptr noundef %7, ptr noundef @os_execve._parser, i32 noundef 3, i32 noundef 3, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %4, %cond.true ], [ %call, %cond.false ]
  store ptr %cond, ptr %args.addr, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  br label %exit

if.end:                                           ; preds = %cond.end
  %9 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %9, i64 0
  %10 = load ptr, ptr %arrayidx, align 8
  %call6 = call i32 @path_converter(ptr noundef %10, ptr noundef %path)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %if.end
  br label %exit

if.end9:                                          ; preds = %if.end
  %11 = load ptr, ptr %args.addr, align 8
  %arrayidx10 = getelementptr ptr, ptr %11, i64 1
  %12 = load ptr, ptr %arrayidx10, align 8
  store ptr %12, ptr %argv, align 8
  %13 = load ptr, ptr %args.addr, align 8
  %arrayidx11 = getelementptr ptr, ptr %13, i64 2
  %14 = load ptr, ptr %arrayidx11, align 8
  store ptr %14, ptr %env, align 8
  %15 = load ptr, ptr %module.addr, align 8
  %16 = load ptr, ptr %argv, align 8
  %17 = load ptr, ptr %env, align 8
  %call12 = call ptr @os_execve_impl(ptr noundef %15, ptr noundef %path, ptr noundef %16, ptr noundef %17)
  store ptr %call12, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end9, %if.then8, %if.then
  call void @path_cleanup(ptr noundef %path)
  %18 = load ptr, ptr %return_value, align 8
  ret ptr %18
}

; Function Attrs: nounwind uwtable
define internal ptr @os_fork(ptr noundef %module, ptr noundef %_unused_ignored) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %call = call ptr @os_fork_impl(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @os_register_at_fork(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [3 x ptr], align 16
  %noptargs = alloca i64, align 8
  %before = alloca ptr, align 8
  %after_in_child = alloca ptr, align 8
  %after_in_parent = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 0
  store i64 %sub, ptr %noptargs, align 8
  store ptr null, ptr %before, align 8
  store ptr null, ptr %after_in_child, align 8
  store ptr null, ptr %after_in_parent, align 8
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 0, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 0
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [3 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @os_register_at_fork._parser, i32 noundef 0, i32 noundef 0, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load i64, ptr %noptargs, align 8
  %tobool12 = icmp ne i64 %12, 0
  br i1 %tobool12, label %if.end14, label %if.then13

if.then13:                                        ; preds = %if.end
  br label %skip_optional_kwonly

if.end14:                                         ; preds = %if.end
  %13 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %13, i64 0
  %14 = load ptr, ptr %arrayidx, align 8
  %tobool15 = icmp ne ptr %14, null
  br i1 %tobool15, label %if.then16, label %if.end21

if.then16:                                        ; preds = %if.end14
  %15 = load ptr, ptr %args.addr, align 8
  %arrayidx17 = getelementptr ptr, ptr %15, i64 0
  %16 = load ptr, ptr %arrayidx17, align 8
  store ptr %16, ptr %before, align 8
  %17 = load i64, ptr %noptargs, align 8
  %dec = add i64 %17, -1
  store i64 %dec, ptr %noptargs, align 8
  %tobool18 = icmp ne i64 %dec, 0
  br i1 %tobool18, label %if.end20, label %if.then19

if.then19:                                        ; preds = %if.then16
  br label %skip_optional_kwonly

if.end20:                                         ; preds = %if.then16
  br label %if.end21

if.end21:                                         ; preds = %if.end20, %if.end14
  %18 = load ptr, ptr %args.addr, align 8
  %arrayidx22 = getelementptr ptr, ptr %18, i64 1
  %19 = load ptr, ptr %arrayidx22, align 8
  %tobool23 = icmp ne ptr %19, null
  br i1 %tobool23, label %if.then24, label %if.end30

if.then24:                                        ; preds = %if.end21
  %20 = load ptr, ptr %args.addr, align 8
  %arrayidx25 = getelementptr ptr, ptr %20, i64 1
  %21 = load ptr, ptr %arrayidx25, align 8
  store ptr %21, ptr %after_in_child, align 8
  %22 = load i64, ptr %noptargs, align 8
  %dec26 = add i64 %22, -1
  store i64 %dec26, ptr %noptargs, align 8
  %tobool27 = icmp ne i64 %dec26, 0
  br i1 %tobool27, label %if.end29, label %if.then28

if.then28:                                        ; preds = %if.then24
  br label %skip_optional_kwonly

if.end29:                                         ; preds = %if.then24
  br label %if.end30

if.end30:                                         ; preds = %if.end29, %if.end21
  %23 = load ptr, ptr %args.addr, align 8
  %arrayidx31 = getelementptr ptr, ptr %23, i64 2
  %24 = load ptr, ptr %arrayidx31, align 8
  store ptr %24, ptr %after_in_parent, align 8
  br label %skip_optional_kwonly

skip_optional_kwonly:                             ; preds = %if.end30, %if.then28, %if.then19, %if.then13
  %25 = load ptr, ptr %module.addr, align 8
  %26 = load ptr, ptr %before, align 8
  %27 = load ptr, ptr %after_in_child, align 8
  %28 = load ptr, ptr %after_in_parent, align 8
  %call32 = call ptr @os_register_at_fork_impl(ptr noundef %25, ptr noundef %26, ptr noundef %27, ptr noundef %28)
  store ptr %call32, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional_kwonly, %if.then
  %29 = load ptr, ptr %return_value, align 8
  ret ptr %29
}

; Function Attrs: nounwind uwtable
define internal ptr @os_sched_get_priority_max(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [1 x ptr], align 8
  %policy = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 1, %1
  br i1 %cmp1, label %land.lhs.true2, label %cond.false

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %2, 1
  br i1 %cmp3, label %land.lhs.true4, label %cond.false

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %3 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %3, null
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true4
  %4 = load ptr, ptr %args.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  %5 = load ptr, ptr %args.addr, align 8
  %6 = load i64, ptr %nargs.addr, align 8
  %7 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [1 x ptr], ptr %argsbuf, i64 0, i64 0
  %call = call ptr @_PyArg_UnpackKeywords(ptr noundef %5, i64 noundef %6, ptr noundef null, ptr noundef %7, ptr noundef @os_sched_get_priority_max._parser, i32 noundef 1, i32 noundef 1, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %4, %cond.true ], [ %call, %cond.false ]
  store ptr %cond, ptr %args.addr, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  br label %exit

if.end:                                           ; preds = %cond.end
  %9 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %9, i64 0
  %10 = load ptr, ptr %arrayidx, align 8
  %call6 = call i32 @PyLong_AsInt(ptr noundef %10)
  store i32 %call6, ptr %policy, align 4
  %11 = load i32, ptr %policy, align 4
  %cmp7 = icmp eq i32 %11, -1
  br i1 %cmp7, label %land.lhs.true8, label %if.end12

land.lhs.true8:                                   ; preds = %if.end
  %call9 = call ptr @PyErr_Occurred()
  %tobool10 = icmp ne ptr %call9, null
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %land.lhs.true8
  br label %exit

if.end12:                                         ; preds = %land.lhs.true8, %if.end
  %12 = load ptr, ptr %module.addr, align 8
  %13 = load i32, ptr %policy, align 4
  %call13 = call ptr @os_sched_get_priority_max_impl(ptr noundef %12, i32 noundef %13)
  store ptr %call13, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end12, %if.then11, %if.then
  %14 = load ptr, ptr %return_value, align 8
  ret ptr %14
}

; Function Attrs: nounwind uwtable
define internal ptr @os_sched_get_priority_min(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [1 x ptr], align 8
  %policy = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 1, %1
  br i1 %cmp1, label %land.lhs.true2, label %cond.false

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %2, 1
  br i1 %cmp3, label %land.lhs.true4, label %cond.false

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %3 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %3, null
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true4
  %4 = load ptr, ptr %args.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  %5 = load ptr, ptr %args.addr, align 8
  %6 = load i64, ptr %nargs.addr, align 8
  %7 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [1 x ptr], ptr %argsbuf, i64 0, i64 0
  %call = call ptr @_PyArg_UnpackKeywords(ptr noundef %5, i64 noundef %6, ptr noundef null, ptr noundef %7, ptr noundef @os_sched_get_priority_min._parser, i32 noundef 1, i32 noundef 1, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %4, %cond.true ], [ %call, %cond.false ]
  store ptr %cond, ptr %args.addr, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  br label %exit

if.end:                                           ; preds = %cond.end
  %9 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %9, i64 0
  %10 = load ptr, ptr %arrayidx, align 8
  %call6 = call i32 @PyLong_AsInt(ptr noundef %10)
  store i32 %call6, ptr %policy, align 4
  %11 = load i32, ptr %policy, align 4
  %cmp7 = icmp eq i32 %11, -1
  br i1 %cmp7, label %land.lhs.true8, label %if.end12

land.lhs.true8:                                   ; preds = %if.end
  %call9 = call ptr @PyErr_Occurred()
  %tobool10 = icmp ne ptr %call9, null
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %land.lhs.true8
  br label %exit

if.end12:                                         ; preds = %land.lhs.true8, %if.end
  %12 = load ptr, ptr %module.addr, align 8
  %13 = load i32, ptr %policy, align 4
  %call13 = call ptr @os_sched_get_priority_min_impl(ptr noundef %12, i32 noundef %13)
  store ptr %call13, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end12, %if.then11, %if.then
  %14 = load ptr, ptr %return_value, align 8
  ret ptr %14
}

; Function Attrs: nounwind uwtable
define internal ptr @os_sched_getparam(ptr noundef %module, ptr noundef %arg) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %pid = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %call = call i32 (ptr, ptr, ...) @PyArg_Parse(ptr noundef %0, ptr noundef @.str.302, ptr noundef %pid)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %exit

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %module.addr, align 8
  %2 = load i32, ptr %pid, align 4
  %call1 = call ptr @os_sched_getparam_impl(ptr noundef %1, i32 noundef %2)
  store ptr %call1, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end, %if.then
  %3 = load ptr, ptr %return_value, align 8
  ret ptr %3
}

; Function Attrs: nounwind uwtable
define internal ptr @os_sched_getscheduler(ptr noundef %module, ptr noundef %arg) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %pid = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %call = call i32 (ptr, ptr, ...) @PyArg_Parse(ptr noundef %0, ptr noundef @.str.303, ptr noundef %pid)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %exit

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %module.addr, align 8
  %2 = load i32, ptr %pid, align 4
  %call1 = call ptr @os_sched_getscheduler_impl(ptr noundef %1, i32 noundef %2)
  store ptr %call1, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end, %if.then
  %3 = load ptr, ptr %return_value, align 8
  ret ptr %3
}

; Function Attrs: nounwind uwtable
define internal ptr @os_sched_rr_get_interval(ptr noundef %module, ptr noundef %arg) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %pid = alloca i32, align 4
  %_return_value = alloca double, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %call = call i32 (ptr, ptr, ...) @PyArg_Parse(ptr noundef %0, ptr noundef @.str.304, ptr noundef %pid)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %exit

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %module.addr, align 8
  %2 = load i32, ptr %pid, align 4
  %call1 = call double @os_sched_rr_get_interval_impl(ptr noundef %1, i32 noundef %2)
  store double %call1, ptr %_return_value, align 8
  %3 = load double, ptr %_return_value, align 8
  %cmp = fcmp oeq double %3, -1.000000e+00
  br i1 %cmp, label %land.lhs.true, label %if.end5

land.lhs.true:                                    ; preds = %if.end
  %call2 = call ptr @PyErr_Occurred()
  %tobool3 = icmp ne ptr %call2, null
  br i1 %tobool3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %land.lhs.true
  br label %exit

if.end5:                                          ; preds = %land.lhs.true, %if.end
  %4 = load double, ptr %_return_value, align 8
  %call6 = call ptr @PyFloat_FromDouble(double noundef %4)
  store ptr %call6, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end5, %if.then4, %if.then
  %5 = load ptr, ptr %return_value, align 8
  ret ptr %5
}

; Function Attrs: nounwind uwtable
define internal ptr @os_sched_setparam(ptr noundef %module, ptr noundef %args, i64 noundef %nargs) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %return_value = alloca ptr, align 8
  %pid = alloca i32, align 4
  %param_obj = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %args.addr, align 8
  %1 = load i64, ptr %nargs.addr, align 8
  %call = call i32 (ptr, i64, ptr, ...) @_PyArg_ParseStack(ptr noundef %0, i64 noundef %1, ptr noundef @.str.305, ptr noundef %pid, ptr noundef %param_obj)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %exit

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %module.addr, align 8
  %3 = load i32, ptr %pid, align 4
  %4 = load ptr, ptr %param_obj, align 8
  %call1 = call ptr @os_sched_setparam_impl(ptr noundef %2, i32 noundef %3, ptr noundef %4)
  store ptr %call1, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end, %if.then
  %5 = load ptr, ptr %return_value, align 8
  ret ptr %5
}

; Function Attrs: nounwind uwtable
define internal ptr @os_sched_setscheduler(ptr noundef %module, ptr noundef %args, i64 noundef %nargs) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %return_value = alloca ptr, align 8
  %pid = alloca i32, align 4
  %policy = alloca i32, align 4
  %param_obj = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %args.addr, align 8
  %1 = load i64, ptr %nargs.addr, align 8
  %call = call i32 (ptr, i64, ptr, ...) @_PyArg_ParseStack(ptr noundef %0, i64 noundef %1, ptr noundef @.str.306, ptr noundef %pid, ptr noundef %policy, ptr noundef %param_obj)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %exit

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %module.addr, align 8
  %3 = load i32, ptr %pid, align 4
  %4 = load i32, ptr %policy, align 4
  %5 = load ptr, ptr %param_obj, align 8
  %call1 = call ptr @os_sched_setscheduler_impl(ptr noundef %2, i32 noundef %3, i32 noundef %4, ptr noundef %5)
  store ptr %call1, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end, %if.then
  %6 = load ptr, ptr %return_value, align 8
  ret ptr %6
}

; Function Attrs: nounwind uwtable
define internal ptr @os_sched_yield(ptr noundef %module, ptr noundef %_unused_ignored) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %call = call ptr @os_sched_yield_impl(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @os_sched_setaffinity(ptr noundef %module, ptr noundef %args, i64 noundef %nargs) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %return_value = alloca ptr, align 8
  %pid = alloca i32, align 4
  %mask = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %args.addr, align 8
  %1 = load i64, ptr %nargs.addr, align 8
  %call = call i32 (ptr, i64, ptr, ...) @_PyArg_ParseStack(ptr noundef %0, i64 noundef %1, ptr noundef @.str.307, ptr noundef %pid, ptr noundef %mask)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %exit

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %module.addr, align 8
  %3 = load i32, ptr %pid, align 4
  %4 = load ptr, ptr %mask, align 8
  %call1 = call ptr @os_sched_setaffinity_impl(ptr noundef %2, i32 noundef %3, ptr noundef %4)
  store ptr %call1, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end, %if.then
  %5 = load ptr, ptr %return_value, align 8
  ret ptr %5
}

; Function Attrs: nounwind uwtable
define internal ptr @os_sched_getaffinity(ptr noundef %module, ptr noundef %arg) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %pid = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %call = call i32 (ptr, ptr, ...) @PyArg_Parse(ptr noundef %0, ptr noundef @.str.311, ptr noundef %pid)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %exit

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %module.addr, align 8
  %2 = load i32, ptr %pid, align 4
  %call1 = call ptr @os_sched_getaffinity_impl(ptr noundef %1, i32 noundef %2)
  store ptr %call1, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end, %if.then
  %3 = load ptr, ptr %return_value, align 8
  ret ptr %3
}

; Function Attrs: nounwind uwtable
define internal ptr @os_openpty(ptr noundef %module, ptr noundef %_unused_ignored) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %call = call ptr @os_openpty_impl(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @os_login_tty(ptr noundef %module, ptr noundef %arg) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %fd = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %call = call i32 @_PyLong_FileDescriptor_Converter(ptr noundef %0, ptr noundef %fd)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %exit

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %module.addr, align 8
  %2 = load i32, ptr %fd, align 4
  %call1 = call ptr @os_login_tty_impl(ptr noundef %1, i32 noundef %2)
  store ptr %call1, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end, %if.then
  %3 = load ptr, ptr %return_value, align 8
  ret ptr %3
}

; Function Attrs: nounwind uwtable
define internal ptr @os_forkpty(ptr noundef %module, ptr noundef %_unused_ignored) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %call = call ptr @os_forkpty_impl(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @os_getegid(ptr noundef %module, ptr noundef %_unused_ignored) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %call = call ptr @os_getegid_impl(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @os_geteuid(ptr noundef %module, ptr noundef %_unused_ignored) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %call = call ptr @os_geteuid_impl(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @os_getgid(ptr noundef %module, ptr noundef %_unused_ignored) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %call = call ptr @os_getgid_impl(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @os_getgrouplist(ptr noundef %module, ptr noundef %args, i64 noundef %nargs) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %return_value = alloca ptr, align 8
  %user = alloca ptr, align 8
  %basegid = alloca i32, align 4
  %user_length = alloca i64, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %cmp = icmp sle i64 2, %0
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 %1, 2
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %2 = load i64, ptr %nargs.addr, align 8
  %call = call i32 @_PyArg_CheckPositional(ptr noundef @.str.69, i64 noundef %2, i64 noundef 2, i64 noundef 2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false
  br label %exit

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %3 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %3, i64 0
  %4 = load ptr, ptr %arrayidx, align 8
  %call2 = call ptr @Py_TYPE(ptr noundef %4)
  %call3 = call i32 @PyType_HasFeature(ptr noundef %call2, i64 noundef 268435456)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.end7, label %if.then5

if.then5:                                         ; preds = %if.end
  %5 = load ptr, ptr %args.addr, align 8
  %arrayidx6 = getelementptr ptr, ptr %5, i64 0
  %6 = load ptr, ptr %arrayidx6, align 8
  call void @_PyArg_BadArgument(ptr noundef @.str.69, ptr noundef @.str.317, ptr noundef @.str.318, ptr noundef %6)
  br label %exit

if.end7:                                          ; preds = %if.end
  %7 = load ptr, ptr %args.addr, align 8
  %arrayidx8 = getelementptr ptr, ptr %7, i64 0
  %8 = load ptr, ptr %arrayidx8, align 8
  %call9 = call ptr @PyUnicode_AsUTF8AndSize(ptr noundef %8, ptr noundef %user_length)
  store ptr %call9, ptr %user, align 8
  %9 = load ptr, ptr %user, align 8
  %cmp10 = icmp eq ptr %9, null
  br i1 %cmp10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end7
  br label %exit

if.end12:                                         ; preds = %if.end7
  %10 = load ptr, ptr %user, align 8
  %call13 = call i64 @strlen(ptr noundef %10) #13
  %11 = load i64, ptr %user_length, align 8
  %cmp14 = icmp ne i64 %call13, %11
  br i1 %cmp14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.end12
  %12 = load ptr, ptr @PyExc_ValueError, align 8
  call void @PyErr_SetString(ptr noundef %12, ptr noundef @.str.319)
  br label %exit

if.end16:                                         ; preds = %if.end12
  %13 = load ptr, ptr %args.addr, align 8
  %arrayidx17 = getelementptr ptr, ptr %13, i64 1
  %14 = load ptr, ptr %arrayidx17, align 8
  %call18 = call i32 @_Py_Gid_Converter(ptr noundef %14, ptr noundef %basegid)
  %tobool19 = icmp ne i32 %call18, 0
  br i1 %tobool19, label %if.end21, label %if.then20

if.then20:                                        ; preds = %if.end16
  br label %exit

if.end21:                                         ; preds = %if.end16
  %15 = load ptr, ptr %module.addr, align 8
  %16 = load ptr, ptr %user, align 8
  %17 = load i32, ptr %basegid, align 4
  %call22 = call ptr @os_getgrouplist_impl(ptr noundef %15, ptr noundef %16, i32 noundef %17)
  store ptr %call22, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end21, %if.then20, %if.then15, %if.then11, %if.then5, %if.then
  %18 = load ptr, ptr %return_value, align 8
  ret ptr %18
}

; Function Attrs: nounwind uwtable
define internal ptr @os_getgroups(ptr noundef %module, ptr noundef %_unused_ignored) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %call = call ptr @os_getgroups_impl(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @os_getpid(ptr noundef %module, ptr noundef %_unused_ignored) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %call = call ptr @os_getpid_impl(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @os_getpgrp(ptr noundef %module, ptr noundef %_unused_ignored) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %call = call ptr @os_getpgrp_impl(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @os_getppid(ptr noundef %module, ptr noundef %_unused_ignored) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %call = call ptr @os_getppid_impl(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @os_getuid(ptr noundef %module, ptr noundef %_unused_ignored) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %call = call ptr @os_getuid_impl(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @os_getlogin(ptr noundef %module, ptr noundef %_unused_ignored) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %call = call ptr @os_getlogin_impl(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @os_kill(ptr noundef %module, ptr noundef %args, i64 noundef %nargs) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %return_value = alloca ptr, align 8
  %pid = alloca i32, align 4
  %signal = alloca i64, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %args.addr, align 8
  %1 = load i64, ptr %nargs.addr, align 8
  %call = call i32 (ptr, i64, ptr, ...) @_PyArg_ParseStack(ptr noundef %0, i64 noundef %1, ptr noundef @.str.321, ptr noundef %pid, ptr noundef %signal)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %exit

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %module.addr, align 8
  %3 = load i32, ptr %pid, align 4
  %4 = load i64, ptr %signal, align 8
  %call1 = call ptr @os_kill_impl(ptr noundef %2, i32 noundef %3, i64 noundef %4)
  store ptr %call1, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end, %if.then
  %5 = load ptr, ptr %return_value, align 8
  ret ptr %5
}

; Function Attrs: nounwind uwtable
define internal ptr @os_killpg(ptr noundef %module, ptr noundef %args, i64 noundef %nargs) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %return_value = alloca ptr, align 8
  %pgid = alloca i32, align 4
  %signal = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %args.addr, align 8
  %1 = load i64, ptr %nargs.addr, align 8
  %call = call i32 (ptr, i64, ptr, ...) @_PyArg_ParseStack(ptr noundef %0, i64 noundef %1, ptr noundef @.str.324, ptr noundef %pgid, ptr noundef %signal)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %exit

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %module.addr, align 8
  %3 = load i32, ptr %pgid, align 4
  %4 = load i32, ptr %signal, align 4
  %call1 = call ptr @os_killpg_impl(ptr noundef %2, i32 noundef %3, i32 noundef %4)
  store ptr %call1, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end, %if.then
  %5 = load ptr, ptr %return_value, align 8
  ret ptr %5
}

; Function Attrs: nounwind uwtable
define internal ptr @os_setuid(ptr noundef %module, ptr noundef %arg) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %uid = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %call = call i32 @_Py_Uid_Converter(ptr noundef %0, ptr noundef %uid)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %exit

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %module.addr, align 8
  %2 = load i32, ptr %uid, align 4
  %call1 = call ptr @os_setuid_impl(ptr noundef %1, i32 noundef %2)
  store ptr %call1, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end, %if.then
  %3 = load ptr, ptr %return_value, align 8
  ret ptr %3
}

; Function Attrs: nounwind uwtable
define internal ptr @os_seteuid(ptr noundef %module, ptr noundef %arg) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %euid = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %call = call i32 @_Py_Uid_Converter(ptr noundef %0, ptr noundef %euid)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %exit

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %module.addr, align 8
  %2 = load i32, ptr %euid, align 4
  %call1 = call ptr @os_seteuid_impl(ptr noundef %1, i32 noundef %2)
  store ptr %call1, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end, %if.then
  %3 = load ptr, ptr %return_value, align 8
  ret ptr %3
}

; Function Attrs: nounwind uwtable
define internal ptr @os_setreuid(ptr noundef %module, ptr noundef %args, i64 noundef %nargs) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %return_value = alloca ptr, align 8
  %ruid = alloca i32, align 4
  %euid = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %cmp = icmp sle i64 2, %0
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 %1, 2
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %2 = load i64, ptr %nargs.addr, align 8
  %call = call i32 @_PyArg_CheckPositional(ptr noundef @.str.80, i64 noundef %2, i64 noundef 2, i64 noundef 2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false
  br label %exit

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %3 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %3, i64 0
  %4 = load ptr, ptr %arrayidx, align 8
  %call2 = call i32 @_Py_Uid_Converter(ptr noundef %4, ptr noundef %ruid)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.end
  br label %exit

if.end5:                                          ; preds = %if.end
  %5 = load ptr, ptr %args.addr, align 8
  %arrayidx6 = getelementptr ptr, ptr %5, i64 1
  %6 = load ptr, ptr %arrayidx6, align 8
  %call7 = call i32 @_Py_Uid_Converter(ptr noundef %6, ptr noundef %euid)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end10, label %if.then9

if.then9:                                         ; preds = %if.end5
  br label %exit

if.end10:                                         ; preds = %if.end5
  %7 = load ptr, ptr %module.addr, align 8
  %8 = load i32, ptr %ruid, align 4
  %9 = load i32, ptr %euid, align 4
  %call11 = call ptr @os_setreuid_impl(ptr noundef %7, i32 noundef %8, i32 noundef %9)
  store ptr %call11, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end10, %if.then9, %if.then4, %if.then
  %10 = load ptr, ptr %return_value, align 8
  ret ptr %10
}

; Function Attrs: nounwind uwtable
define internal ptr @os_setgid(ptr noundef %module, ptr noundef %arg) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %gid = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %call = call i32 @_Py_Gid_Converter(ptr noundef %0, ptr noundef %gid)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %exit

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %module.addr, align 8
  %2 = load i32, ptr %gid, align 4
  %call1 = call ptr @os_setgid_impl(ptr noundef %1, i32 noundef %2)
  store ptr %call1, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end, %if.then
  %3 = load ptr, ptr %return_value, align 8
  ret ptr %3
}

; Function Attrs: nounwind uwtable
define internal ptr @os_setegid(ptr noundef %module, ptr noundef %arg) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %egid = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %call = call i32 @_Py_Gid_Converter(ptr noundef %0, ptr noundef %egid)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %exit

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %module.addr, align 8
  %2 = load i32, ptr %egid, align 4
  %call1 = call ptr @os_setegid_impl(ptr noundef %1, i32 noundef %2)
  store ptr %call1, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end, %if.then
  %3 = load ptr, ptr %return_value, align 8
  ret ptr %3
}

; Function Attrs: nounwind uwtable
define internal ptr @os_setregid(ptr noundef %module, ptr noundef %args, i64 noundef %nargs) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %return_value = alloca ptr, align 8
  %rgid = alloca i32, align 4
  %egid = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %cmp = icmp sle i64 2, %0
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 %1, 2
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %2 = load i64, ptr %nargs.addr, align 8
  %call = call i32 @_PyArg_CheckPositional(ptr noundef @.str.83, i64 noundef %2, i64 noundef 2, i64 noundef 2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false
  br label %exit

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %3 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %3, i64 0
  %4 = load ptr, ptr %arrayidx, align 8
  %call2 = call i32 @_Py_Gid_Converter(ptr noundef %4, ptr noundef %rgid)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.end
  br label %exit

if.end5:                                          ; preds = %if.end
  %5 = load ptr, ptr %args.addr, align 8
  %arrayidx6 = getelementptr ptr, ptr %5, i64 1
  %6 = load ptr, ptr %arrayidx6, align 8
  %call7 = call i32 @_Py_Gid_Converter(ptr noundef %6, ptr noundef %egid)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end10, label %if.then9

if.then9:                                         ; preds = %if.end5
  br label %exit

if.end10:                                         ; preds = %if.end5
  %7 = load ptr, ptr %module.addr, align 8
  %8 = load i32, ptr %rgid, align 4
  %9 = load i32, ptr %egid, align 4
  %call11 = call ptr @os_setregid_impl(ptr noundef %7, i32 noundef %8, i32 noundef %9)
  store ptr %call11, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end10, %if.then9, %if.then4, %if.then
  %10 = load ptr, ptr %return_value, align 8
  ret ptr %10
}

; Function Attrs: nounwind uwtable
define internal ptr @os_setgroups(ptr noundef %module, ptr noundef %groups) #0 {
entry:
  %op.addr.i56 = alloca ptr, align 8
  %op.addr.i52 = alloca ptr, align 8
  %op.addr.i50 = alloca ptr, align 8
  %op.addr.i41 = alloca ptr, align 8
  %op.addr.i32 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %groups.addr = alloca ptr, align 8
  %len = alloca i64, align 8
  %grouplist = alloca ptr, align 8
  %i = alloca i64, align 8
  %elem = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %groups, ptr %groups.addr, align 8
  %0 = load ptr, ptr %groups.addr, align 8
  %call = call i32 @PySequence_Check(ptr noundef %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr @PyExc_TypeError, align 8
  call void @PyErr_SetString(ptr noundef %1, ptr noundef @.str.327)
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %groups.addr, align 8
  %call1 = call i64 @PySequence_Size(ptr noundef %2)
  store i64 %call1, ptr %len, align 8
  %3 = load i64, ptr %len, align 8
  %cmp = icmp slt i64 %3, 0
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end3:                                          ; preds = %if.end
  %4 = load i64, ptr %len, align 8
  %cmp4 = icmp sgt i64 %4, 65536
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end3
  %5 = load ptr, ptr @PyExc_ValueError, align 8
  call void @PyErr_SetString(ptr noundef %5, ptr noundef @.str.328)
  store ptr null, ptr %retval, align 8
  br label %return

if.end6:                                          ; preds = %if.end3
  %6 = load i64, ptr %len, align 8
  %cmp7 = icmp ugt i64 %6, 2305843009213693951
  br i1 %cmp7, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end6
  br label %cond.end

cond.false:                                       ; preds = %if.end6
  %7 = load i64, ptr %len, align 8
  %mul = mul i64 %7, 4
  %call8 = call ptr @PyMem_Malloc(i64 noundef %mul)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ null, %cond.true ], [ %call8, %cond.false ]
  store ptr %cond, ptr %grouplist, align 8
  %8 = load ptr, ptr %grouplist, align 8
  %cmp9 = icmp eq ptr %8, null
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %cond.end
  %call11 = call ptr @PyErr_NoMemory()
  store ptr null, ptr %retval, align 8
  br label %return

if.end12:                                         ; preds = %cond.end
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end12
  %9 = load i64, ptr %i, align 8
  %10 = load i64, ptr %len, align 8
  %cmp13 = icmp slt i64 %9, %10
  br i1 %cmp13, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %groups.addr, align 8
  %12 = load i64, ptr %i, align 8
  %call14 = call ptr @PySequence_GetItem(ptr noundef %11, i64 noundef %12)
  store ptr %call14, ptr %elem, align 8
  %13 = load ptr, ptr %elem, align 8
  %tobool15 = icmp ne ptr %13, null
  br i1 %tobool15, label %if.end17, label %if.then16

if.then16:                                        ; preds = %for.body
  %14 = load ptr, ptr %grouplist, align 8
  call void @PyMem_Free(ptr noundef %14)
  store ptr null, ptr %retval, align 8
  br label %return

if.end17:                                         ; preds = %for.body
  %15 = load ptr, ptr %elem, align 8
  %call18 = call ptr @Py_TYPE(ptr noundef %15)
  %call19 = call i32 @PyType_HasFeature(ptr noundef %call18, i64 noundef 16777216)
  %tobool20 = icmp ne i32 %call19, 0
  br i1 %tobool20, label %if.else, label %if.then21

if.then21:                                        ; preds = %if.end17
  %16 = load ptr, ptr @PyExc_TypeError, align 8
  call void @PyErr_SetString(ptr noundef %16, ptr noundef @.str.329)
  %17 = load ptr, ptr %elem, align 8
  store ptr %17, ptr %op.addr.i41, align 8
  %18 = load ptr, ptr %op.addr.i41, align 8
  store ptr %18, ptr %op.addr.i50, align 8
  %19 = load ptr, ptr %op.addr.i50, align 8
  %20 = load i64, ptr %19, align 8
  %conv.i = trunc i64 %20 to i32
  %cmp.i51 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i51 to i32
  %tobool.i43 = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i43, label %if.then.i48, label %if.end.i44

if.then.i48:                                      ; preds = %if.then21
  br label %Py_DECREF.exit49

if.end.i44:                                       ; preds = %if.then21
  %21 = load ptr, ptr %op.addr.i41, align 8
  %22 = load i64, ptr %21, align 8
  %dec.i45 = add i64 %22, -1
  store i64 %dec.i45, ptr %21, align 8
  %cmp.i46 = icmp eq i64 %dec.i45, 0
  br i1 %cmp.i46, label %if.then1.i47, label %Py_DECREF.exit49

if.then1.i47:                                     ; preds = %if.end.i44
  %23 = load ptr, ptr %op.addr.i41, align 8
  call void @_Py_Dealloc(ptr noundef %23) #10
  br label %Py_DECREF.exit49

Py_DECREF.exit49:                                 ; preds = %if.then1.i47, %if.end.i44, %if.then.i48
  %24 = load ptr, ptr %grouplist, align 8
  call void @PyMem_Free(ptr noundef %24)
  store ptr null, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %if.end17
  %25 = load ptr, ptr %elem, align 8
  %26 = load ptr, ptr %grouplist, align 8
  %27 = load i64, ptr %i, align 8
  %arrayidx = getelementptr i32, ptr %26, i64 %27
  %call22 = call i32 @_Py_Gid_Converter(ptr noundef %25, ptr noundef %arrayidx)
  %tobool23 = icmp ne i32 %call22, 0
  br i1 %tobool23, label %if.end25, label %if.then24

if.then24:                                        ; preds = %if.else
  %28 = load ptr, ptr %elem, align 8
  store ptr %28, ptr %op.addr.i32, align 8
  %29 = load ptr, ptr %op.addr.i32, align 8
  store ptr %29, ptr %op.addr.i52, align 8
  %30 = load ptr, ptr %op.addr.i52, align 8
  %31 = load i64, ptr %30, align 8
  %conv.i53 = trunc i64 %31 to i32
  %cmp.i54 = icmp slt i32 %conv.i53, 0
  %conv1.i55 = zext i1 %cmp.i54 to i32
  %tobool.i34 = icmp ne i32 %conv1.i55, 0
  br i1 %tobool.i34, label %if.then.i39, label %if.end.i35

if.then.i39:                                      ; preds = %if.then24
  br label %Py_DECREF.exit40

if.end.i35:                                       ; preds = %if.then24
  %32 = load ptr, ptr %op.addr.i32, align 8
  %33 = load i64, ptr %32, align 8
  %dec.i36 = add i64 %33, -1
  store i64 %dec.i36, ptr %32, align 8
  %cmp.i37 = icmp eq i64 %dec.i36, 0
  br i1 %cmp.i37, label %if.then1.i38, label %Py_DECREF.exit40

if.then1.i38:                                     ; preds = %if.end.i35
  %34 = load ptr, ptr %op.addr.i32, align 8
  call void @_Py_Dealloc(ptr noundef %34) #10
  br label %Py_DECREF.exit40

Py_DECREF.exit40:                                 ; preds = %if.then1.i38, %if.end.i35, %if.then.i39
  %35 = load ptr, ptr %grouplist, align 8
  call void @PyMem_Free(ptr noundef %35)
  store ptr null, ptr %retval, align 8
  br label %return

if.end25:                                         ; preds = %if.else
  br label %if.end26

if.end26:                                         ; preds = %if.end25
  %36 = load ptr, ptr %elem, align 8
  store ptr %36, ptr %op.addr.i, align 8
  %37 = load ptr, ptr %op.addr.i, align 8
  store ptr %37, ptr %op.addr.i56, align 8
  %38 = load ptr, ptr %op.addr.i56, align 8
  %39 = load i64, ptr %38, align 8
  %conv.i57 = trunc i64 %39 to i32
  %cmp.i58 = icmp slt i32 %conv.i57, 0
  %conv1.i59 = zext i1 %cmp.i58 to i32
  %tobool.i = icmp ne i32 %conv1.i59, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.end26
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.end26
  %40 = load ptr, ptr %op.addr.i, align 8
  %41 = load i64, ptr %40, align 8
  %dec.i = add i64 %41, -1
  store i64 %dec.i, ptr %40, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %42 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %42) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  br label %for.inc

for.inc:                                          ; preds = %Py_DECREF.exit
  %43 = load i64, ptr %i, align 8
  %inc = add i64 %43, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !8

for.end:                                          ; preds = %for.cond
  %44 = load i64, ptr %len, align 8
  %45 = load ptr, ptr %grouplist, align 8
  %call27 = call i32 @setgroups(i64 noundef %44, ptr noundef %45) #10
  %cmp28 = icmp slt i32 %call27, 0
  br i1 %cmp28, label %if.then29, label %if.end31

if.then29:                                        ; preds = %for.end
  %call30 = call ptr @posix_error()
  %46 = load ptr, ptr %grouplist, align 8
  call void @PyMem_Free(ptr noundef %46)
  store ptr null, ptr %retval, align 8
  br label %return

if.end31:                                         ; preds = %for.end
  %47 = load ptr, ptr %grouplist, align 8
  call void @PyMem_Free(ptr noundef %47)
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end31, %if.then29, %Py_DECREF.exit40, %Py_DECREF.exit49, %if.then16, %if.then10, %if.then5, %if.then2, %if.then
  %48 = load ptr, ptr %retval, align 8
  ret ptr %48
}

; Function Attrs: nounwind uwtable
define internal ptr @os_initgroups(ptr noundef %module, ptr noundef %args, i64 noundef %nargs) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %return_value = alloca ptr, align 8
  %oname = alloca ptr, align 8
  %gid = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  store ptr null, ptr %oname, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %cmp = icmp sle i64 2, %0
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 %1, 2
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %2 = load i64, ptr %nargs.addr, align 8
  %call = call i32 @_PyArg_CheckPositional(ptr noundef @.str.85, i64 noundef %2, i64 noundef 2, i64 noundef 2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false
  br label %exit

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %3 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %3, i64 0
  %4 = load ptr, ptr %arrayidx, align 8
  %call2 = call i32 @PyUnicode_FSConverter(ptr noundef %4, ptr noundef %oname)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.end
  br label %exit

if.end5:                                          ; preds = %if.end
  %5 = load ptr, ptr %args.addr, align 8
  %arrayidx6 = getelementptr ptr, ptr %5, i64 1
  %6 = load ptr, ptr %arrayidx6, align 8
  %call7 = call i32 @_Py_Gid_Converter(ptr noundef %6, ptr noundef %gid)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end10, label %if.then9

if.then9:                                         ; preds = %if.end5
  br label %exit

if.end10:                                         ; preds = %if.end5
  %7 = load ptr, ptr %module.addr, align 8
  %8 = load ptr, ptr %oname, align 8
  %9 = load i32, ptr %gid, align 4
  %call11 = call ptr @os_initgroups_impl(ptr noundef %7, ptr noundef %8, i32 noundef %9)
  store ptr %call11, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end10, %if.then9, %if.then4, %if.then
  %10 = load ptr, ptr %oname, align 8
  call void @Py_XDECREF(ptr noundef %10)
  %11 = load ptr, ptr %return_value, align 8
  ret ptr %11
}

; Function Attrs: nounwind uwtable
define internal ptr @os_getpgid(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %pid = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %args.addr, align 8
  %1 = load i64, ptr %nargs.addr, align 8
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i32 (ptr, i64, ptr, ptr, ...) @_PyArg_ParseStackAndKeywords(ptr noundef %0, i64 noundef %1, ptr noundef %2, ptr noundef @os_getpgid._parser, ptr noundef %pid)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %exit

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %module.addr, align 8
  %4 = load i32, ptr %pid, align 4
  %call1 = call ptr @os_getpgid_impl(ptr noundef %3, i32 noundef %4)
  store ptr %call1, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end, %if.then
  %5 = load ptr, ptr %return_value, align 8
  ret ptr %5
}

; Function Attrs: nounwind uwtable
define internal ptr @os_setpgrp(ptr noundef %module, ptr noundef %_unused_ignored) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %call = call ptr @os_setpgrp_impl(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @os_wait(ptr noundef %module, ptr noundef %_unused_ignored) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %call = call ptr @os_wait_impl(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @os_wait3(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [1 x ptr], align 8
  %options = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 1, %1
  br i1 %cmp1, label %land.lhs.true2, label %cond.false

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %2, 1
  br i1 %cmp3, label %land.lhs.true4, label %cond.false

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %3 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %3, null
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true4
  %4 = load ptr, ptr %args.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  %5 = load ptr, ptr %args.addr, align 8
  %6 = load i64, ptr %nargs.addr, align 8
  %7 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [1 x ptr], ptr %argsbuf, i64 0, i64 0
  %call = call ptr @_PyArg_UnpackKeywords(ptr noundef %5, i64 noundef %6, ptr noundef null, ptr noundef %7, ptr noundef @os_wait3._parser, i32 noundef 1, i32 noundef 1, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %4, %cond.true ], [ %call, %cond.false ]
  store ptr %cond, ptr %args.addr, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  br label %exit

if.end:                                           ; preds = %cond.end
  %9 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %9, i64 0
  %10 = load ptr, ptr %arrayidx, align 8
  %call6 = call i32 @PyLong_AsInt(ptr noundef %10)
  store i32 %call6, ptr %options, align 4
  %11 = load i32, ptr %options, align 4
  %cmp7 = icmp eq i32 %11, -1
  br i1 %cmp7, label %land.lhs.true8, label %if.end12

land.lhs.true8:                                   ; preds = %if.end
  %call9 = call ptr @PyErr_Occurred()
  %tobool10 = icmp ne ptr %call9, null
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %land.lhs.true8
  br label %exit

if.end12:                                         ; preds = %land.lhs.true8, %if.end
  %12 = load ptr, ptr %module.addr, align 8
  %13 = load i32, ptr %options, align 4
  %call13 = call ptr @os_wait3_impl(ptr noundef %12, i32 noundef %13)
  store ptr %call13, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end12, %if.then11, %if.then
  %14 = load ptr, ptr %return_value, align 8
  ret ptr %14
}

; Function Attrs: nounwind uwtable
define internal ptr @os_wait4(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %pid = alloca i32, align 4
  %options = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %args.addr, align 8
  %1 = load i64, ptr %nargs.addr, align 8
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i32 (ptr, i64, ptr, ptr, ...) @_PyArg_ParseStackAndKeywords(ptr noundef %0, i64 noundef %1, ptr noundef %2, ptr noundef @os_wait4._parser, ptr noundef %pid, ptr noundef %options)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %exit

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %module.addr, align 8
  %4 = load i32, ptr %pid, align 4
  %5 = load i32, ptr %options, align 4
  %call1 = call ptr @os_wait4_impl(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store ptr %call1, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end, %if.then
  %6 = load ptr, ptr %return_value, align 8
  ret ptr %6
}

; Function Attrs: nounwind uwtable
define internal ptr @os_waitid(ptr noundef %module, ptr noundef %args, i64 noundef %nargs) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %return_value = alloca ptr, align 8
  %idtype = alloca i32, align 4
  %id = alloca i32, align 4
  %options = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %args.addr, align 8
  %1 = load i64, ptr %nargs.addr, align 8
  %call = call i32 (ptr, i64, ptr, ...) @_PyArg_ParseStack(ptr noundef %0, i64 noundef %1, ptr noundef @.str.338, ptr noundef %idtype, ptr noundef %id, ptr noundef %options)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %exit

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %module.addr, align 8
  %3 = load i32, ptr %idtype, align 4
  %4 = load i32, ptr %id, align 4
  %5 = load i32, ptr %options, align 4
  %call1 = call ptr @os_waitid_impl(ptr noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5)
  store ptr %call1, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end, %if.then
  %6 = load ptr, ptr %return_value, align 8
  ret ptr %6
}

; Function Attrs: nounwind uwtable
define internal ptr @os_waitpid(ptr noundef %module, ptr noundef %args, i64 noundef %nargs) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %return_value = alloca ptr, align 8
  %pid = alloca i32, align 4
  %options = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %args.addr, align 8
  %1 = load i64, ptr %nargs.addr, align 8
  %call = call i32 (ptr, i64, ptr, ...) @_PyArg_ParseStack(ptr noundef %0, i64 noundef %1, ptr noundef @.str.339, ptr noundef %pid, ptr noundef %options)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %exit

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %module.addr, align 8
  %3 = load i32, ptr %pid, align 4
  %4 = load i32, ptr %options, align 4
  %call1 = call ptr @os_waitpid_impl(ptr noundef %2, i32 noundef %3, i32 noundef %4)
  store ptr %call1, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end, %if.then
  %5 = load ptr, ptr %return_value, align 8
  ret ptr %5
}

; Function Attrs: nounwind uwtable
define internal ptr @os_pidfd_open(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %pid = alloca i32, align 4
  %flags = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  store i32 0, ptr %flags, align 4
  %0 = load ptr, ptr %args.addr, align 8
  %1 = load i64, ptr %nargs.addr, align 8
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i32 (ptr, i64, ptr, ptr, ...) @_PyArg_ParseStackAndKeywords(ptr noundef %0, i64 noundef %1, ptr noundef %2, ptr noundef @os_pidfd_open._parser, ptr noundef %pid, ptr noundef @_PyLong_UnsignedInt_Converter, ptr noundef %flags)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %exit

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %module.addr, align 8
  %4 = load i32, ptr %pid, align 4
  %5 = load i32, ptr %flags, align 4
  %call1 = call ptr @os_pidfd_open_impl(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store ptr %call1, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end, %if.then
  %6 = load ptr, ptr %return_value, align 8
  ret ptr %6
}

; Function Attrs: nounwind uwtable
define internal ptr @os_getsid(ptr noundef %module, ptr noundef %arg) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %pid = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %call = call i32 (ptr, ptr, ...) @PyArg_Parse(ptr noundef %0, ptr noundef @.str.341, ptr noundef %pid)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %exit

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %module.addr, align 8
  %2 = load i32, ptr %pid, align 4
  %call1 = call ptr @os_getsid_impl(ptr noundef %1, i32 noundef %2)
  store ptr %call1, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end, %if.then
  %3 = load ptr, ptr %return_value, align 8
  ret ptr %3
}

; Function Attrs: nounwind uwtable
define internal ptr @os_setsid(ptr noundef %module, ptr noundef %_unused_ignored) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %call = call ptr @os_setsid_impl(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @os_setpgid(ptr noundef %module, ptr noundef %args, i64 noundef %nargs) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %return_value = alloca ptr, align 8
  %pid = alloca i32, align 4
  %pgrp = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %args.addr, align 8
  %1 = load i64, ptr %nargs.addr, align 8
  %call = call i32 (ptr, i64, ptr, ...) @_PyArg_ParseStack(ptr noundef %0, i64 noundef %1, ptr noundef @.str.342, ptr noundef %pid, ptr noundef %pgrp)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %exit

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %module.addr, align 8
  %3 = load i32, ptr %pid, align 4
  %4 = load i32, ptr %pgrp, align 4
  %call1 = call ptr @os_setpgid_impl(ptr noundef %2, i32 noundef %3, i32 noundef %4)
  store ptr %call1, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end, %if.then
  %5 = load ptr, ptr %return_value, align 8
  ret ptr %5
}

; Function Attrs: nounwind uwtable
define internal ptr @os_tcgetpgrp(ptr noundef %module, ptr noundef %arg) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %fd = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %call = call i32 @PyLong_AsInt(ptr noundef %0)
  store i32 %call, ptr %fd, align 4
  %1 = load i32, ptr %fd, align 4
  %cmp = icmp eq i32 %1, -1
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %call1 = call ptr @PyErr_Occurred()
  %tobool = icmp ne ptr %call1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  br label %exit

if.end:                                           ; preds = %land.lhs.true, %entry
  %2 = load ptr, ptr %module.addr, align 8
  %3 = load i32, ptr %fd, align 4
  %call2 = call ptr @os_tcgetpgrp_impl(ptr noundef %2, i32 noundef %3)
  store ptr %call2, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end, %if.then
  %4 = load ptr, ptr %return_value, align 8
  ret ptr %4
}

; Function Attrs: nounwind uwtable
define internal ptr @os_tcsetpgrp(ptr noundef %module, ptr noundef %args, i64 noundef %nargs) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %return_value = alloca ptr, align 8
  %fd = alloca i32, align 4
  %pgid = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %args.addr, align 8
  %1 = load i64, ptr %nargs.addr, align 8
  %call = call i32 (ptr, i64, ptr, ...) @_PyArg_ParseStack(ptr noundef %0, i64 noundef %1, ptr noundef @.str.343, ptr noundef %fd, ptr noundef %pgid)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %exit

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %module.addr, align 8
  %3 = load i32, ptr %fd, align 4
  %4 = load i32, ptr %pgid, align 4
  %call1 = call ptr @os_tcsetpgrp_impl(ptr noundef %2, i32 noundef %3, i32 noundef %4)
  store ptr %call1, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end, %if.then
  %5 = load ptr, ptr %return_value, align 8
  ret ptr %5
}

; Function Attrs: nounwind uwtable
define internal ptr @os_open(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [4 x ptr], align 16
  %noptargs = alloca i64, align 8
  %path = alloca %struct.path_t, align 8
  %flags = alloca i32, align 4
  %mode = alloca i32, align 4
  %dir_fd = alloca i32, align 4
  %_return_value = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 2
  store i64 %sub, ptr %noptargs, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %path, ptr align 8 @__const.os_open.path, i64 72, i1 false)
  store i32 511, ptr %mode, align 4
  store i32 -100, ptr %dir_fd, align 4
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 2, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 3
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [4 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @os_open._parser, i32 noundef 2, i32 noundef 3, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %12, i64 0
  %13 = load ptr, ptr %arrayidx, align 8
  %call12 = call i32 @path_converter(ptr noundef %13, ptr noundef %path)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end
  br label %exit

if.end15:                                         ; preds = %if.end
  %14 = load ptr, ptr %args.addr, align 8
  %arrayidx16 = getelementptr ptr, ptr %14, i64 1
  %15 = load ptr, ptr %arrayidx16, align 8
  %call17 = call i32 @PyLong_AsInt(ptr noundef %15)
  store i32 %call17, ptr %flags, align 4
  %16 = load i32, ptr %flags, align 4
  %cmp18 = icmp eq i32 %16, -1
  br i1 %cmp18, label %land.lhs.true19, label %if.end23

land.lhs.true19:                                  ; preds = %if.end15
  %call20 = call ptr @PyErr_Occurred()
  %tobool21 = icmp ne ptr %call20, null
  br i1 %tobool21, label %if.then22, label %if.end23

if.then22:                                        ; preds = %land.lhs.true19
  br label %exit

if.end23:                                         ; preds = %land.lhs.true19, %if.end15
  %17 = load i64, ptr %noptargs, align 8
  %tobool24 = icmp ne i64 %17, 0
  br i1 %tobool24, label %if.end26, label %if.then25

if.then25:                                        ; preds = %if.end23
  br label %skip_optional_pos

if.end26:                                         ; preds = %if.end23
  %18 = load ptr, ptr %args.addr, align 8
  %arrayidx27 = getelementptr ptr, ptr %18, i64 2
  %19 = load ptr, ptr %arrayidx27, align 8
  %tobool28 = icmp ne ptr %19, null
  br i1 %tobool28, label %if.then29, label %if.end41

if.then29:                                        ; preds = %if.end26
  %20 = load ptr, ptr %args.addr, align 8
  %arrayidx30 = getelementptr ptr, ptr %20, i64 2
  %21 = load ptr, ptr %arrayidx30, align 8
  %call31 = call i32 @PyLong_AsInt(ptr noundef %21)
  store i32 %call31, ptr %mode, align 4
  %22 = load i32, ptr %mode, align 4
  %cmp32 = icmp eq i32 %22, -1
  br i1 %cmp32, label %land.lhs.true33, label %if.end37

land.lhs.true33:                                  ; preds = %if.then29
  %call34 = call ptr @PyErr_Occurred()
  %tobool35 = icmp ne ptr %call34, null
  br i1 %tobool35, label %if.then36, label %if.end37

if.then36:                                        ; preds = %land.lhs.true33
  br label %exit

if.end37:                                         ; preds = %land.lhs.true33, %if.then29
  %23 = load i64, ptr %noptargs, align 8
  %dec = add i64 %23, -1
  store i64 %dec, ptr %noptargs, align 8
  %tobool38 = icmp ne i64 %dec, 0
  br i1 %tobool38, label %if.end40, label %if.then39

if.then39:                                        ; preds = %if.end37
  br label %skip_optional_pos

if.end40:                                         ; preds = %if.end37
  br label %if.end41

if.end41:                                         ; preds = %if.end40, %if.end26
  br label %skip_optional_pos

skip_optional_pos:                                ; preds = %if.end41, %if.then39, %if.then25
  %24 = load i64, ptr %noptargs, align 8
  %tobool42 = icmp ne i64 %24, 0
  br i1 %tobool42, label %if.end44, label %if.then43

if.then43:                                        ; preds = %skip_optional_pos
  br label %skip_optional_kwonly

if.end44:                                         ; preds = %skip_optional_pos
  %25 = load ptr, ptr %args.addr, align 8
  %arrayidx45 = getelementptr ptr, ptr %25, i64 3
  %26 = load ptr, ptr %arrayidx45, align 8
  %call46 = call i32 @dir_fd_converter(ptr noundef %26, ptr noundef %dir_fd)
  %tobool47 = icmp ne i32 %call46, 0
  br i1 %tobool47, label %if.end49, label %if.then48

if.then48:                                        ; preds = %if.end44
  br label %exit

if.end49:                                         ; preds = %if.end44
  br label %skip_optional_kwonly

skip_optional_kwonly:                             ; preds = %if.end49, %if.then43
  %27 = load ptr, ptr %module.addr, align 8
  %28 = load i32, ptr %flags, align 4
  %29 = load i32, ptr %mode, align 4
  %30 = load i32, ptr %dir_fd, align 4
  %call50 = call i32 @os_open_impl(ptr noundef %27, ptr noundef %path, i32 noundef %28, i32 noundef %29, i32 noundef %30)
  store i32 %call50, ptr %_return_value, align 4
  %31 = load i32, ptr %_return_value, align 4
  %cmp51 = icmp eq i32 %31, -1
  br i1 %cmp51, label %land.lhs.true52, label %if.end56

land.lhs.true52:                                  ; preds = %skip_optional_kwonly
  %call53 = call ptr @PyErr_Occurred()
  %tobool54 = icmp ne ptr %call53, null
  br i1 %tobool54, label %if.then55, label %if.end56

if.then55:                                        ; preds = %land.lhs.true52
  br label %exit

if.end56:                                         ; preds = %land.lhs.true52, %skip_optional_kwonly
  %32 = load i32, ptr %_return_value, align 4
  %conv = sext i32 %32 to i64
  %call57 = call ptr @PyLong_FromLong(i64 noundef %conv)
  store ptr %call57, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end56, %if.then55, %if.then48, %if.then36, %if.then22, %if.then14, %if.then
  call void @path_cleanup(ptr noundef %path)
  %33 = load ptr, ptr %return_value, align 8
  ret ptr %33
}

; Function Attrs: nounwind uwtable
define internal ptr @os_close(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [1 x ptr], align 8
  %fd = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 1, %1
  br i1 %cmp1, label %land.lhs.true2, label %cond.false

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %2, 1
  br i1 %cmp3, label %land.lhs.true4, label %cond.false

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %3 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %3, null
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true4
  %4 = load ptr, ptr %args.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  %5 = load ptr, ptr %args.addr, align 8
  %6 = load i64, ptr %nargs.addr, align 8
  %7 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [1 x ptr], ptr %argsbuf, i64 0, i64 0
  %call = call ptr @_PyArg_UnpackKeywords(ptr noundef %5, i64 noundef %6, ptr noundef null, ptr noundef %7, ptr noundef @os_close._parser, i32 noundef 1, i32 noundef 1, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %4, %cond.true ], [ %call, %cond.false ]
  store ptr %cond, ptr %args.addr, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  br label %exit

if.end:                                           ; preds = %cond.end
  %9 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %9, i64 0
  %10 = load ptr, ptr %arrayidx, align 8
  %call6 = call i32 @PyLong_AsInt(ptr noundef %10)
  store i32 %call6, ptr %fd, align 4
  %11 = load i32, ptr %fd, align 4
  %cmp7 = icmp eq i32 %11, -1
  br i1 %cmp7, label %land.lhs.true8, label %if.end12

land.lhs.true8:                                   ; preds = %if.end
  %call9 = call ptr @PyErr_Occurred()
  %tobool10 = icmp ne ptr %call9, null
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %land.lhs.true8
  br label %exit

if.end12:                                         ; preds = %land.lhs.true8, %if.end
  %12 = load ptr, ptr %module.addr, align 8
  %13 = load i32, ptr %fd, align 4
  %call13 = call ptr @os_close_impl(ptr noundef %12, i32 noundef %13)
  store ptr %call13, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end12, %if.then11, %if.then
  %14 = load ptr, ptr %return_value, align 8
  ret ptr %14
}

; Function Attrs: nounwind uwtable
define internal ptr @os_closerange(ptr noundef %module, ptr noundef %args, i64 noundef %nargs) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %return_value = alloca ptr, align 8
  %fd_low = alloca i32, align 4
  %fd_high = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %cmp = icmp sle i64 2, %0
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 %1, 2
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %2 = load i64, ptr %nargs.addr, align 8
  %call = call i32 @_PyArg_CheckPositional(ptr noundef @.str.101, i64 noundef %2, i64 noundef 2, i64 noundef 2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false
  br label %exit

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %3 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %3, i64 0
  %4 = load ptr, ptr %arrayidx, align 8
  %call2 = call i32 @PyLong_AsInt(ptr noundef %4)
  store i32 %call2, ptr %fd_low, align 4
  %5 = load i32, ptr %fd_low, align 4
  %cmp3 = icmp eq i32 %5, -1
  br i1 %cmp3, label %land.lhs.true4, label %if.end8

land.lhs.true4:                                   ; preds = %if.end
  %call5 = call ptr @PyErr_Occurred()
  %tobool6 = icmp ne ptr %call5, null
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %land.lhs.true4
  br label %exit

if.end8:                                          ; preds = %land.lhs.true4, %if.end
  %6 = load ptr, ptr %args.addr, align 8
  %arrayidx9 = getelementptr ptr, ptr %6, i64 1
  %7 = load ptr, ptr %arrayidx9, align 8
  %call10 = call i32 @PyLong_AsInt(ptr noundef %7)
  store i32 %call10, ptr %fd_high, align 4
  %8 = load i32, ptr %fd_high, align 4
  %cmp11 = icmp eq i32 %8, -1
  br i1 %cmp11, label %land.lhs.true12, label %if.end16

land.lhs.true12:                                  ; preds = %if.end8
  %call13 = call ptr @PyErr_Occurred()
  %tobool14 = icmp ne ptr %call13, null
  br i1 %tobool14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %land.lhs.true12
  br label %exit

if.end16:                                         ; preds = %land.lhs.true12, %if.end8
  %9 = load ptr, ptr %module.addr, align 8
  %10 = load i32, ptr %fd_low, align 4
  %11 = load i32, ptr %fd_high, align 4
  %call17 = call ptr @os_closerange_impl(ptr noundef %9, i32 noundef %10, i32 noundef %11)
  store ptr %call17, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end16, %if.then15, %if.then7, %if.then
  %12 = load ptr, ptr %return_value, align 8
  ret ptr %12
}

; Function Attrs: nounwind uwtable
define internal ptr @os_device_encoding(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [1 x ptr], align 8
  %fd = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 1, %1
  br i1 %cmp1, label %land.lhs.true2, label %cond.false

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %2, 1
  br i1 %cmp3, label %land.lhs.true4, label %cond.false

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %3 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %3, null
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true4
  %4 = load ptr, ptr %args.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  %5 = load ptr, ptr %args.addr, align 8
  %6 = load i64, ptr %nargs.addr, align 8
  %7 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [1 x ptr], ptr %argsbuf, i64 0, i64 0
  %call = call ptr @_PyArg_UnpackKeywords(ptr noundef %5, i64 noundef %6, ptr noundef null, ptr noundef %7, ptr noundef @os_device_encoding._parser, i32 noundef 1, i32 noundef 1, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %4, %cond.true ], [ %call, %cond.false ]
  store ptr %cond, ptr %args.addr, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  br label %exit

if.end:                                           ; preds = %cond.end
  %9 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %9, i64 0
  %10 = load ptr, ptr %arrayidx, align 8
  %call6 = call i32 @PyLong_AsInt(ptr noundef %10)
  store i32 %call6, ptr %fd, align 4
  %11 = load i32, ptr %fd, align 4
  %cmp7 = icmp eq i32 %11, -1
  br i1 %cmp7, label %land.lhs.true8, label %if.end12

land.lhs.true8:                                   ; preds = %if.end
  %call9 = call ptr @PyErr_Occurred()
  %tobool10 = icmp ne ptr %call9, null
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %land.lhs.true8
  br label %exit

if.end12:                                         ; preds = %land.lhs.true8, %if.end
  %12 = load ptr, ptr %module.addr, align 8
  %13 = load i32, ptr %fd, align 4
  %call13 = call ptr @os_device_encoding_impl(ptr noundef %12, i32 noundef %13)
  store ptr %call13, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end12, %if.then11, %if.then
  %14 = load ptr, ptr %return_value, align 8
  ret ptr %14
}

; Function Attrs: nounwind uwtable
define internal ptr @os_dup(ptr noundef %module, ptr noundef %arg) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %fd = alloca i32, align 4
  %_return_value = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %call = call i32 @PyLong_AsInt(ptr noundef %0)
  store i32 %call, ptr %fd, align 4
  %1 = load i32, ptr %fd, align 4
  %cmp = icmp eq i32 %1, -1
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %call1 = call ptr @PyErr_Occurred()
  %tobool = icmp ne ptr %call1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  br label %exit

if.end:                                           ; preds = %land.lhs.true, %entry
  %2 = load ptr, ptr %module.addr, align 8
  %3 = load i32, ptr %fd, align 4
  %call2 = call i32 @os_dup_impl(ptr noundef %2, i32 noundef %3)
  store i32 %call2, ptr %_return_value, align 4
  %4 = load i32, ptr %_return_value, align 4
  %cmp3 = icmp eq i32 %4, -1
  br i1 %cmp3, label %land.lhs.true4, label %if.end8

land.lhs.true4:                                   ; preds = %if.end
  %call5 = call ptr @PyErr_Occurred()
  %tobool6 = icmp ne ptr %call5, null
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %land.lhs.true4
  br label %exit

if.end8:                                          ; preds = %land.lhs.true4, %if.end
  %5 = load i32, ptr %_return_value, align 4
  %conv = sext i32 %5 to i64
  %call9 = call ptr @PyLong_FromLong(i64 noundef %conv)
  store ptr %call9, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end8, %if.then7, %if.then
  %6 = load ptr, ptr %return_value, align 8
  ret ptr %6
}

; Function Attrs: nounwind uwtable
define internal ptr @os_dup2(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [3 x ptr], align 16
  %noptargs = alloca i64, align 8
  %fd = alloca i32, align 4
  %fd2 = alloca i32, align 4
  %inheritable = alloca i32, align 4
  %_return_value = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 2
  store i64 %sub, ptr %noptargs, align 8
  store i32 1, ptr %inheritable, align 4
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 2, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 3
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [3 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @os_dup2._parser, i32 noundef 2, i32 noundef 3, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %12, i64 0
  %13 = load ptr, ptr %arrayidx, align 8
  %call12 = call i32 @PyLong_AsInt(ptr noundef %13)
  store i32 %call12, ptr %fd, align 4
  %14 = load i32, ptr %fd, align 4
  %cmp13 = icmp eq i32 %14, -1
  br i1 %cmp13, label %land.lhs.true14, label %if.end18

land.lhs.true14:                                  ; preds = %if.end
  %call15 = call ptr @PyErr_Occurred()
  %tobool16 = icmp ne ptr %call15, null
  br i1 %tobool16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %land.lhs.true14
  br label %exit

if.end18:                                         ; preds = %land.lhs.true14, %if.end
  %15 = load ptr, ptr %args.addr, align 8
  %arrayidx19 = getelementptr ptr, ptr %15, i64 1
  %16 = load ptr, ptr %arrayidx19, align 8
  %call20 = call i32 @PyLong_AsInt(ptr noundef %16)
  store i32 %call20, ptr %fd2, align 4
  %17 = load i32, ptr %fd2, align 4
  %cmp21 = icmp eq i32 %17, -1
  br i1 %cmp21, label %land.lhs.true22, label %if.end26

land.lhs.true22:                                  ; preds = %if.end18
  %call23 = call ptr @PyErr_Occurred()
  %tobool24 = icmp ne ptr %call23, null
  br i1 %tobool24, label %if.then25, label %if.end26

if.then25:                                        ; preds = %land.lhs.true22
  br label %exit

if.end26:                                         ; preds = %land.lhs.true22, %if.end18
  %18 = load i64, ptr %noptargs, align 8
  %tobool27 = icmp ne i64 %18, 0
  br i1 %tobool27, label %if.end29, label %if.then28

if.then28:                                        ; preds = %if.end26
  br label %skip_optional_pos

if.end29:                                         ; preds = %if.end26
  %19 = load ptr, ptr %args.addr, align 8
  %arrayidx30 = getelementptr ptr, ptr %19, i64 2
  %20 = load ptr, ptr %arrayidx30, align 8
  %call31 = call i32 @PyObject_IsTrue(ptr noundef %20)
  store i32 %call31, ptr %inheritable, align 4
  %21 = load i32, ptr %inheritable, align 4
  %cmp32 = icmp slt i32 %21, 0
  br i1 %cmp32, label %if.then33, label %if.end34

if.then33:                                        ; preds = %if.end29
  br label %exit

if.end34:                                         ; preds = %if.end29
  br label %skip_optional_pos

skip_optional_pos:                                ; preds = %if.end34, %if.then28
  %22 = load ptr, ptr %module.addr, align 8
  %23 = load i32, ptr %fd, align 4
  %24 = load i32, ptr %fd2, align 4
  %25 = load i32, ptr %inheritable, align 4
  %call35 = call i32 @os_dup2_impl(ptr noundef %22, i32 noundef %23, i32 noundef %24, i32 noundef %25)
  store i32 %call35, ptr %_return_value, align 4
  %26 = load i32, ptr %_return_value, align 4
  %cmp36 = icmp eq i32 %26, -1
  br i1 %cmp36, label %land.lhs.true37, label %if.end41

land.lhs.true37:                                  ; preds = %skip_optional_pos
  %call38 = call ptr @PyErr_Occurred()
  %tobool39 = icmp ne ptr %call38, null
  br i1 %tobool39, label %if.then40, label %if.end41

if.then40:                                        ; preds = %land.lhs.true37
  br label %exit

if.end41:                                         ; preds = %land.lhs.true37, %skip_optional_pos
  %27 = load i32, ptr %_return_value, align 4
  %conv = sext i32 %27 to i64
  %call42 = call ptr @PyLong_FromLong(i64 noundef %conv)
  store ptr %call42, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end41, %if.then40, %if.then33, %if.then25, %if.then17, %if.then
  %28 = load ptr, ptr %return_value, align 8
  ret ptr %28
}

; Function Attrs: nounwind uwtable
define internal ptr @os_lockf(ptr noundef %module, ptr noundef %args, i64 noundef %nargs) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %return_value = alloca ptr, align 8
  %fd = alloca i32, align 4
  %command = alloca i32, align 4
  %length = alloca i64, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %cmp = icmp sle i64 3, %0
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 %1, 3
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %2 = load i64, ptr %nargs.addr, align 8
  %call = call i32 @_PyArg_CheckPositional(ptr noundef @.str.105, i64 noundef %2, i64 noundef 3, i64 noundef 3)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false
  br label %exit

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %3 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %3, i64 0
  %4 = load ptr, ptr %arrayidx, align 8
  %call2 = call i32 @PyLong_AsInt(ptr noundef %4)
  store i32 %call2, ptr %fd, align 4
  %5 = load i32, ptr %fd, align 4
  %cmp3 = icmp eq i32 %5, -1
  br i1 %cmp3, label %land.lhs.true4, label %if.end8

land.lhs.true4:                                   ; preds = %if.end
  %call5 = call ptr @PyErr_Occurred()
  %tobool6 = icmp ne ptr %call5, null
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %land.lhs.true4
  br label %exit

if.end8:                                          ; preds = %land.lhs.true4, %if.end
  %6 = load ptr, ptr %args.addr, align 8
  %arrayidx9 = getelementptr ptr, ptr %6, i64 1
  %7 = load ptr, ptr %arrayidx9, align 8
  %call10 = call i32 @PyLong_AsInt(ptr noundef %7)
  store i32 %call10, ptr %command, align 4
  %8 = load i32, ptr %command, align 4
  %cmp11 = icmp eq i32 %8, -1
  br i1 %cmp11, label %land.lhs.true12, label %if.end16

land.lhs.true12:                                  ; preds = %if.end8
  %call13 = call ptr @PyErr_Occurred()
  %tobool14 = icmp ne ptr %call13, null
  br i1 %tobool14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %land.lhs.true12
  br label %exit

if.end16:                                         ; preds = %land.lhs.true12, %if.end8
  %9 = load ptr, ptr %args.addr, align 8
  %arrayidx17 = getelementptr ptr, ptr %9, i64 2
  %10 = load ptr, ptr %arrayidx17, align 8
  %call18 = call i32 @Py_off_t_converter(ptr noundef %10, ptr noundef %length)
  %tobool19 = icmp ne i32 %call18, 0
  br i1 %tobool19, label %if.end21, label %if.then20

if.then20:                                        ; preds = %if.end16
  br label %exit

if.end21:                                         ; preds = %if.end16
  %11 = load ptr, ptr %module.addr, align 8
  %12 = load i32, ptr %fd, align 4
  %13 = load i32, ptr %command, align 4
  %14 = load i64, ptr %length, align 8
  %call22 = call ptr @os_lockf_impl(ptr noundef %11, i32 noundef %12, i32 noundef %13, i64 noundef %14)
  store ptr %call22, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end21, %if.then20, %if.then15, %if.then7, %if.then
  %15 = load ptr, ptr %return_value, align 8
  ret ptr %15
}

; Function Attrs: nounwind uwtable
define internal ptr @os_lseek(ptr noundef %module, ptr noundef %args, i64 noundef %nargs) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %return_value = alloca ptr, align 8
  %fd = alloca i32, align 4
  %position = alloca i64, align 8
  %how = alloca i32, align 4
  %_return_value = alloca i64, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %cmp = icmp sle i64 3, %0
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 %1, 3
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %2 = load i64, ptr %nargs.addr, align 8
  %call = call i32 @_PyArg_CheckPositional(ptr noundef @.str.106, i64 noundef %2, i64 noundef 3, i64 noundef 3)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false
  br label %exit

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %3 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %3, i64 0
  %4 = load ptr, ptr %arrayidx, align 8
  %call2 = call i32 @PyLong_AsInt(ptr noundef %4)
  store i32 %call2, ptr %fd, align 4
  %5 = load i32, ptr %fd, align 4
  %cmp3 = icmp eq i32 %5, -1
  br i1 %cmp3, label %land.lhs.true4, label %if.end8

land.lhs.true4:                                   ; preds = %if.end
  %call5 = call ptr @PyErr_Occurred()
  %tobool6 = icmp ne ptr %call5, null
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %land.lhs.true4
  br label %exit

if.end8:                                          ; preds = %land.lhs.true4, %if.end
  %6 = load ptr, ptr %args.addr, align 8
  %arrayidx9 = getelementptr ptr, ptr %6, i64 1
  %7 = load ptr, ptr %arrayidx9, align 8
  %call10 = call i32 @Py_off_t_converter(ptr noundef %7, ptr noundef %position)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end13, label %if.then12

if.then12:                                        ; preds = %if.end8
  br label %exit

if.end13:                                         ; preds = %if.end8
  %8 = load ptr, ptr %args.addr, align 8
  %arrayidx14 = getelementptr ptr, ptr %8, i64 2
  %9 = load ptr, ptr %arrayidx14, align 8
  %call15 = call i32 @PyLong_AsInt(ptr noundef %9)
  store i32 %call15, ptr %how, align 4
  %10 = load i32, ptr %how, align 4
  %cmp16 = icmp eq i32 %10, -1
  br i1 %cmp16, label %land.lhs.true17, label %if.end21

land.lhs.true17:                                  ; preds = %if.end13
  %call18 = call ptr @PyErr_Occurred()
  %tobool19 = icmp ne ptr %call18, null
  br i1 %tobool19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %land.lhs.true17
  br label %exit

if.end21:                                         ; preds = %land.lhs.true17, %if.end13
  %11 = load ptr, ptr %module.addr, align 8
  %12 = load i32, ptr %fd, align 4
  %13 = load i64, ptr %position, align 8
  %14 = load i32, ptr %how, align 4
  %call22 = call i64 @os_lseek_impl(ptr noundef %11, i32 noundef %12, i64 noundef %13, i32 noundef %14)
  store i64 %call22, ptr %_return_value, align 8
  %15 = load i64, ptr %_return_value, align 8
  %cmp23 = icmp eq i64 %15, -1
  br i1 %cmp23, label %land.lhs.true24, label %if.end28

land.lhs.true24:                                  ; preds = %if.end21
  %call25 = call ptr @PyErr_Occurred()
  %tobool26 = icmp ne ptr %call25, null
  br i1 %tobool26, label %if.then27, label %if.end28

if.then27:                                        ; preds = %land.lhs.true24
  br label %exit

if.end28:                                         ; preds = %land.lhs.true24, %if.end21
  %16 = load i64, ptr %_return_value, align 8
  %call29 = call ptr @PyLong_FromPy_off_t(i64 noundef %16)
  store ptr %call29, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end28, %if.then27, %if.then20, %if.then12, %if.then7, %if.then
  %17 = load ptr, ptr %return_value, align 8
  ret ptr %17
}

; Function Attrs: nounwind uwtable
define internal ptr @os_read(ptr noundef %module, ptr noundef %args, i64 noundef %nargs) #0 {
entry:
  %op.addr.i22 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %return_value = alloca ptr, align 8
  %fd = alloca i32, align 4
  %length = alloca i64, align 8
  %ival = alloca i64, align 8
  %iobj = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %cmp = icmp sle i64 2, %0
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 %1, 2
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %2 = load i64, ptr %nargs.addr, align 8
  %call = call i32 @_PyArg_CheckPositional(ptr noundef @.str.107, i64 noundef %2, i64 noundef 2, i64 noundef 2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false
  br label %exit

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %3 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %3, i64 0
  %4 = load ptr, ptr %arrayidx, align 8
  %call2 = call i32 @PyLong_AsInt(ptr noundef %4)
  store i32 %call2, ptr %fd, align 4
  %5 = load i32, ptr %fd, align 4
  %cmp3 = icmp eq i32 %5, -1
  br i1 %cmp3, label %land.lhs.true4, label %if.end8

land.lhs.true4:                                   ; preds = %if.end
  %call5 = call ptr @PyErr_Occurred()
  %tobool6 = icmp ne ptr %call5, null
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %land.lhs.true4
  br label %exit

if.end8:                                          ; preds = %land.lhs.true4, %if.end
  store i64 -1, ptr %ival, align 8
  %6 = load ptr, ptr %args.addr, align 8
  %arrayidx9 = getelementptr ptr, ptr %6, i64 1
  %7 = load ptr, ptr %arrayidx9, align 8
  %call10 = call ptr @_PyNumber_Index(ptr noundef %7)
  store ptr %call10, ptr %iobj, align 8
  %8 = load ptr, ptr %iobj, align 8
  %cmp11 = icmp ne ptr %8, null
  br i1 %cmp11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %if.end8
  %9 = load ptr, ptr %iobj, align 8
  %call13 = call i64 @PyLong_AsSsize_t(ptr noundef %9)
  store i64 %call13, ptr %ival, align 8
  %10 = load ptr, ptr %iobj, align 8
  store ptr %10, ptr %op.addr.i, align 8
  %11 = load ptr, ptr %op.addr.i, align 8
  store ptr %11, ptr %op.addr.i22, align 8
  %12 = load ptr, ptr %op.addr.i22, align 8
  %13 = load i64, ptr %12, align 8
  %conv.i = trunc i64 %13 to i32
  %cmp.i23 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i23 to i32
  %tobool.i = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then12
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.then12
  %14 = load ptr, ptr %op.addr.i, align 8
  %15 = load i64, ptr %14, align 8
  %dec.i = add i64 %15, -1
  store i64 %dec.i, ptr %14, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %16 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %16) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  br label %if.end14

if.end14:                                         ; preds = %Py_DECREF.exit, %if.end8
  %17 = load i64, ptr %ival, align 8
  %cmp15 = icmp eq i64 %17, -1
  br i1 %cmp15, label %land.lhs.true16, label %if.end20

land.lhs.true16:                                  ; preds = %if.end14
  %call17 = call ptr @PyErr_Occurred()
  %tobool18 = icmp ne ptr %call17, null
  br i1 %tobool18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %land.lhs.true16
  br label %exit

if.end20:                                         ; preds = %land.lhs.true16, %if.end14
  %18 = load i64, ptr %ival, align 8
  store i64 %18, ptr %length, align 8
  %19 = load ptr, ptr %module.addr, align 8
  %20 = load i32, ptr %fd, align 4
  %21 = load i64, ptr %length, align 8
  %call21 = call ptr @os_read_impl(ptr noundef %19, i32 noundef %20, i64 noundef %21)
  store ptr %call21, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end20, %if.then19, %if.then7, %if.then
  %22 = load ptr, ptr %return_value, align 8
  ret ptr %22
}

; Function Attrs: nounwind uwtable
define internal ptr @os_readv(ptr noundef %module, ptr noundef %args, i64 noundef %nargs) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %return_value = alloca ptr, align 8
  %fd = alloca i32, align 4
  %buffers = alloca ptr, align 8
  %_return_value = alloca i64, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %cmp = icmp sle i64 2, %0
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 %1, 2
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %2 = load i64, ptr %nargs.addr, align 8
  %call = call i32 @_PyArg_CheckPositional(ptr noundef @.str.108, i64 noundef %2, i64 noundef 2, i64 noundef 2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false
  br label %exit

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %3 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %3, i64 0
  %4 = load ptr, ptr %arrayidx, align 8
  %call2 = call i32 @PyLong_AsInt(ptr noundef %4)
  store i32 %call2, ptr %fd, align 4
  %5 = load i32, ptr %fd, align 4
  %cmp3 = icmp eq i32 %5, -1
  br i1 %cmp3, label %land.lhs.true4, label %if.end8

land.lhs.true4:                                   ; preds = %if.end
  %call5 = call ptr @PyErr_Occurred()
  %tobool6 = icmp ne ptr %call5, null
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %land.lhs.true4
  br label %exit

if.end8:                                          ; preds = %land.lhs.true4, %if.end
  %6 = load ptr, ptr %args.addr, align 8
  %arrayidx9 = getelementptr ptr, ptr %6, i64 1
  %7 = load ptr, ptr %arrayidx9, align 8
  store ptr %7, ptr %buffers, align 8
  %8 = load ptr, ptr %module.addr, align 8
  %9 = load i32, ptr %fd, align 4
  %10 = load ptr, ptr %buffers, align 8
  %call10 = call i64 @os_readv_impl(ptr noundef %8, i32 noundef %9, ptr noundef %10)
  store i64 %call10, ptr %_return_value, align 8
  %11 = load i64, ptr %_return_value, align 8
  %cmp11 = icmp eq i64 %11, -1
  br i1 %cmp11, label %land.lhs.true12, label %if.end16

land.lhs.true12:                                  ; preds = %if.end8
  %call13 = call ptr @PyErr_Occurred()
  %tobool14 = icmp ne ptr %call13, null
  br i1 %tobool14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %land.lhs.true12
  br label %exit

if.end16:                                         ; preds = %land.lhs.true12, %if.end8
  %12 = load i64, ptr %_return_value, align 8
  %call17 = call ptr @PyLong_FromSsize_t(i64 noundef %12)
  store ptr %call17, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end16, %if.then15, %if.then7, %if.then
  %13 = load ptr, ptr %return_value, align 8
  ret ptr %13
}

; Function Attrs: nounwind uwtable
define internal ptr @os_pread(ptr noundef %module, ptr noundef %args, i64 noundef %nargs) #0 {
entry:
  %op.addr.i27 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %return_value = alloca ptr, align 8
  %fd = alloca i32, align 4
  %length = alloca i64, align 8
  %offset = alloca i64, align 8
  %ival = alloca i64, align 8
  %iobj = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %cmp = icmp sle i64 3, %0
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 %1, 3
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %2 = load i64, ptr %nargs.addr, align 8
  %call = call i32 @_PyArg_CheckPositional(ptr noundef @.str.109, i64 noundef %2, i64 noundef 3, i64 noundef 3)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false
  br label %exit

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %3 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %3, i64 0
  %4 = load ptr, ptr %arrayidx, align 8
  %call2 = call i32 @PyLong_AsInt(ptr noundef %4)
  store i32 %call2, ptr %fd, align 4
  %5 = load i32, ptr %fd, align 4
  %cmp3 = icmp eq i32 %5, -1
  br i1 %cmp3, label %land.lhs.true4, label %if.end8

land.lhs.true4:                                   ; preds = %if.end
  %call5 = call ptr @PyErr_Occurred()
  %tobool6 = icmp ne ptr %call5, null
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %land.lhs.true4
  br label %exit

if.end8:                                          ; preds = %land.lhs.true4, %if.end
  store i64 -1, ptr %ival, align 8
  %6 = load ptr, ptr %args.addr, align 8
  %arrayidx9 = getelementptr ptr, ptr %6, i64 1
  %7 = load ptr, ptr %arrayidx9, align 8
  %call10 = call ptr @_PyNumber_Index(ptr noundef %7)
  store ptr %call10, ptr %iobj, align 8
  %8 = load ptr, ptr %iobj, align 8
  %cmp11 = icmp ne ptr %8, null
  br i1 %cmp11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %if.end8
  %9 = load ptr, ptr %iobj, align 8
  %call13 = call i64 @PyLong_AsSsize_t(ptr noundef %9)
  store i64 %call13, ptr %ival, align 8
  %10 = load ptr, ptr %iobj, align 8
  store ptr %10, ptr %op.addr.i, align 8
  %11 = load ptr, ptr %op.addr.i, align 8
  store ptr %11, ptr %op.addr.i27, align 8
  %12 = load ptr, ptr %op.addr.i27, align 8
  %13 = load i64, ptr %12, align 8
  %conv.i = trunc i64 %13 to i32
  %cmp.i28 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i28 to i32
  %tobool.i = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then12
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.then12
  %14 = load ptr, ptr %op.addr.i, align 8
  %15 = load i64, ptr %14, align 8
  %dec.i = add i64 %15, -1
  store i64 %dec.i, ptr %14, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %16 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %16) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  br label %if.end14

if.end14:                                         ; preds = %Py_DECREF.exit, %if.end8
  %17 = load i64, ptr %ival, align 8
  %cmp15 = icmp eq i64 %17, -1
  br i1 %cmp15, label %land.lhs.true16, label %if.end20

land.lhs.true16:                                  ; preds = %if.end14
  %call17 = call ptr @PyErr_Occurred()
  %tobool18 = icmp ne ptr %call17, null
  br i1 %tobool18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %land.lhs.true16
  br label %exit

if.end20:                                         ; preds = %land.lhs.true16, %if.end14
  %18 = load i64, ptr %ival, align 8
  store i64 %18, ptr %length, align 8
  %19 = load ptr, ptr %args.addr, align 8
  %arrayidx21 = getelementptr ptr, ptr %19, i64 2
  %20 = load ptr, ptr %arrayidx21, align 8
  %call22 = call i32 @Py_off_t_converter(ptr noundef %20, ptr noundef %offset)
  %tobool23 = icmp ne i32 %call22, 0
  br i1 %tobool23, label %if.end25, label %if.then24

if.then24:                                        ; preds = %if.end20
  br label %exit

if.end25:                                         ; preds = %if.end20
  %21 = load ptr, ptr %module.addr, align 8
  %22 = load i32, ptr %fd, align 4
  %23 = load i64, ptr %length, align 8
  %24 = load i64, ptr %offset, align 8
  %call26 = call ptr @os_pread_impl(ptr noundef %21, i32 noundef %22, i64 noundef %23, i64 noundef %24)
  store ptr %call26, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end25, %if.then24, %if.then19, %if.then7, %if.then
  %25 = load ptr, ptr %return_value, align 8
  ret ptr %25
}

; Function Attrs: nounwind uwtable
define internal ptr @os_preadv(ptr noundef %module, ptr noundef %args, i64 noundef %nargs) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %return_value = alloca ptr, align 8
  %fd = alloca i32, align 4
  %buffers = alloca ptr, align 8
  %offset = alloca i64, align 8
  %flags = alloca i32, align 4
  %_return_value = alloca i64, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  store i32 0, ptr %flags, align 4
  %0 = load i64, ptr %nargs.addr, align 8
  %cmp = icmp sle i64 3, %0
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 %1, 4
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %2 = load i64, ptr %nargs.addr, align 8
  %call = call i32 @_PyArg_CheckPositional(ptr noundef @.str.110, i64 noundef %2, i64 noundef 3, i64 noundef 4)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false
  br label %exit

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %3 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %3, i64 0
  %4 = load ptr, ptr %arrayidx, align 8
  %call2 = call i32 @PyLong_AsInt(ptr noundef %4)
  store i32 %call2, ptr %fd, align 4
  %5 = load i32, ptr %fd, align 4
  %cmp3 = icmp eq i32 %5, -1
  br i1 %cmp3, label %land.lhs.true4, label %if.end8

land.lhs.true4:                                   ; preds = %if.end
  %call5 = call ptr @PyErr_Occurred()
  %tobool6 = icmp ne ptr %call5, null
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %land.lhs.true4
  br label %exit

if.end8:                                          ; preds = %land.lhs.true4, %if.end
  %6 = load ptr, ptr %args.addr, align 8
  %arrayidx9 = getelementptr ptr, ptr %6, i64 1
  %7 = load ptr, ptr %arrayidx9, align 8
  store ptr %7, ptr %buffers, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %arrayidx10 = getelementptr ptr, ptr %8, i64 2
  %9 = load ptr, ptr %arrayidx10, align 8
  %call11 = call i32 @Py_off_t_converter(ptr noundef %9, ptr noundef %offset)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %if.end14, label %if.then13

if.then13:                                        ; preds = %if.end8
  br label %exit

if.end14:                                         ; preds = %if.end8
  %10 = load i64, ptr %nargs.addr, align 8
  %cmp15 = icmp slt i64 %10, 4
  br i1 %cmp15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.end14
  br label %skip_optional

if.end17:                                         ; preds = %if.end14
  %11 = load ptr, ptr %args.addr, align 8
  %arrayidx18 = getelementptr ptr, ptr %11, i64 3
  %12 = load ptr, ptr %arrayidx18, align 8
  %call19 = call i32 @PyLong_AsInt(ptr noundef %12)
  store i32 %call19, ptr %flags, align 4
  %13 = load i32, ptr %flags, align 4
  %cmp20 = icmp eq i32 %13, -1
  br i1 %cmp20, label %land.lhs.true21, label %if.end25

land.lhs.true21:                                  ; preds = %if.end17
  %call22 = call ptr @PyErr_Occurred()
  %tobool23 = icmp ne ptr %call22, null
  br i1 %tobool23, label %if.then24, label %if.end25

if.then24:                                        ; preds = %land.lhs.true21
  br label %exit

if.end25:                                         ; preds = %land.lhs.true21, %if.end17
  br label %skip_optional

skip_optional:                                    ; preds = %if.end25, %if.then16
  %14 = load ptr, ptr %module.addr, align 8
  %15 = load i32, ptr %fd, align 4
  %16 = load ptr, ptr %buffers, align 8
  %17 = load i64, ptr %offset, align 8
  %18 = load i32, ptr %flags, align 4
  %call26 = call i64 @os_preadv_impl(ptr noundef %14, i32 noundef %15, ptr noundef %16, i64 noundef %17, i32 noundef %18)
  store i64 %call26, ptr %_return_value, align 8
  %19 = load i64, ptr %_return_value, align 8
  %cmp27 = icmp eq i64 %19, -1
  br i1 %cmp27, label %land.lhs.true28, label %if.end32

land.lhs.true28:                                  ; preds = %skip_optional
  %call29 = call ptr @PyErr_Occurred()
  %tobool30 = icmp ne ptr %call29, null
  br i1 %tobool30, label %if.then31, label %if.end32

if.then31:                                        ; preds = %land.lhs.true28
  br label %exit

if.end32:                                         ; preds = %land.lhs.true28, %skip_optional
  %20 = load i64, ptr %_return_value, align 8
  %call33 = call ptr @PyLong_FromSsize_t(i64 noundef %20)
  store ptr %call33, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end32, %if.then31, %if.then24, %if.then13, %if.then7, %if.then
  %21 = load ptr, ptr %return_value, align 8
  ret ptr %21
}

; Function Attrs: nounwind uwtable
define internal ptr @os_write(ptr noundef %module, ptr noundef %args, i64 noundef %nargs) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %return_value = alloca ptr, align 8
  %fd = alloca i32, align 4
  %data = alloca %struct.Py_buffer, align 8
  %_return_value = alloca i64, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %data, i8 0, i64 80, i1 false)
  %0 = load i64, ptr %nargs.addr, align 8
  %cmp = icmp sle i64 2, %0
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 %1, 2
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %2 = load i64, ptr %nargs.addr, align 8
  %call = call i32 @_PyArg_CheckPositional(ptr noundef @.str.111, i64 noundef %2, i64 noundef 2, i64 noundef 2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false
  br label %exit

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %3 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %3, i64 0
  %4 = load ptr, ptr %arrayidx, align 8
  %call2 = call i32 @PyLong_AsInt(ptr noundef %4)
  store i32 %call2, ptr %fd, align 4
  %5 = load i32, ptr %fd, align 4
  %cmp3 = icmp eq i32 %5, -1
  br i1 %cmp3, label %land.lhs.true4, label %if.end8

land.lhs.true4:                                   ; preds = %if.end
  %call5 = call ptr @PyErr_Occurred()
  %tobool6 = icmp ne ptr %call5, null
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %land.lhs.true4
  br label %exit

if.end8:                                          ; preds = %land.lhs.true4, %if.end
  %6 = load ptr, ptr %args.addr, align 8
  %arrayidx9 = getelementptr ptr, ptr %6, i64 1
  %7 = load ptr, ptr %arrayidx9, align 8
  %call10 = call i32 @PyObject_GetBuffer(ptr noundef %7, ptr noundef %data, i32 noundef 0)
  %cmp11 = icmp ne i32 %call10, 0
  br i1 %cmp11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end8
  br label %exit

if.end13:                                         ; preds = %if.end8
  %8 = load ptr, ptr %module.addr, align 8
  %9 = load i32, ptr %fd, align 4
  %call14 = call i64 @os_write_impl(ptr noundef %8, i32 noundef %9, ptr noundef %data)
  store i64 %call14, ptr %_return_value, align 8
  %10 = load i64, ptr %_return_value, align 8
  %cmp15 = icmp eq i64 %10, -1
  br i1 %cmp15, label %land.lhs.true16, label %if.end20

land.lhs.true16:                                  ; preds = %if.end13
  %call17 = call ptr @PyErr_Occurred()
  %tobool18 = icmp ne ptr %call17, null
  br i1 %tobool18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %land.lhs.true16
  br label %exit

if.end20:                                         ; preds = %land.lhs.true16, %if.end13
  %11 = load i64, ptr %_return_value, align 8
  %call21 = call ptr @PyLong_FromSsize_t(i64 noundef %11)
  store ptr %call21, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end20, %if.then19, %if.then12, %if.then7, %if.then
  %obj = getelementptr inbounds %struct.Py_buffer, ptr %data, i32 0, i32 1
  %12 = load ptr, ptr %obj, align 8
  %tobool22 = icmp ne ptr %12, null
  br i1 %tobool22, label %if.then23, label %if.end24

if.then23:                                        ; preds = %exit
  call void @PyBuffer_Release(ptr noundef %data)
  br label %if.end24

if.end24:                                         ; preds = %if.then23, %exit
  %13 = load ptr, ptr %return_value, align 8
  ret ptr %13
}

; Function Attrs: nounwind uwtable
define internal ptr @os_writev(ptr noundef %module, ptr noundef %args, i64 noundef %nargs) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %return_value = alloca ptr, align 8
  %fd = alloca i32, align 4
  %buffers = alloca ptr, align 8
  %_return_value = alloca i64, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %cmp = icmp sle i64 2, %0
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 %1, 2
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %2 = load i64, ptr %nargs.addr, align 8
  %call = call i32 @_PyArg_CheckPositional(ptr noundef @.str.112, i64 noundef %2, i64 noundef 2, i64 noundef 2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false
  br label %exit

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %3 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %3, i64 0
  %4 = load ptr, ptr %arrayidx, align 8
  %call2 = call i32 @PyLong_AsInt(ptr noundef %4)
  store i32 %call2, ptr %fd, align 4
  %5 = load i32, ptr %fd, align 4
  %cmp3 = icmp eq i32 %5, -1
  br i1 %cmp3, label %land.lhs.true4, label %if.end8

land.lhs.true4:                                   ; preds = %if.end
  %call5 = call ptr @PyErr_Occurred()
  %tobool6 = icmp ne ptr %call5, null
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %land.lhs.true4
  br label %exit

if.end8:                                          ; preds = %land.lhs.true4, %if.end
  %6 = load ptr, ptr %args.addr, align 8
  %arrayidx9 = getelementptr ptr, ptr %6, i64 1
  %7 = load ptr, ptr %arrayidx9, align 8
  store ptr %7, ptr %buffers, align 8
  %8 = load ptr, ptr %module.addr, align 8
  %9 = load i32, ptr %fd, align 4
  %10 = load ptr, ptr %buffers, align 8
  %call10 = call i64 @os_writev_impl(ptr noundef %8, i32 noundef %9, ptr noundef %10)
  store i64 %call10, ptr %_return_value, align 8
  %11 = load i64, ptr %_return_value, align 8
  %cmp11 = icmp eq i64 %11, -1
  br i1 %cmp11, label %land.lhs.true12, label %if.end16

land.lhs.true12:                                  ; preds = %if.end8
  %call13 = call ptr @PyErr_Occurred()
  %tobool14 = icmp ne ptr %call13, null
  br i1 %tobool14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %land.lhs.true12
  br label %exit

if.end16:                                         ; preds = %land.lhs.true12, %if.end8
  %12 = load i64, ptr %_return_value, align 8
  %call17 = call ptr @PyLong_FromSsize_t(i64 noundef %12)
  store ptr %call17, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end16, %if.then15, %if.then7, %if.then
  %13 = load ptr, ptr %return_value, align 8
  ret ptr %13
}

; Function Attrs: nounwind uwtable
define internal ptr @os_pwrite(ptr noundef %module, ptr noundef %args, i64 noundef %nargs) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %return_value = alloca ptr, align 8
  %fd = alloca i32, align 4
  %buffer = alloca %struct.Py_buffer, align 8
  %offset = alloca i64, align 8
  %_return_value = alloca i64, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %buffer, i8 0, i64 80, i1 false)
  %0 = load i64, ptr %nargs.addr, align 8
  %cmp = icmp sle i64 3, %0
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 %1, 3
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %2 = load i64, ptr %nargs.addr, align 8
  %call = call i32 @_PyArg_CheckPositional(ptr noundef @.str.113, i64 noundef %2, i64 noundef 3, i64 noundef 3)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false
  br label %exit

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %3 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %3, i64 0
  %4 = load ptr, ptr %arrayidx, align 8
  %call2 = call i32 @PyLong_AsInt(ptr noundef %4)
  store i32 %call2, ptr %fd, align 4
  %5 = load i32, ptr %fd, align 4
  %cmp3 = icmp eq i32 %5, -1
  br i1 %cmp3, label %land.lhs.true4, label %if.end8

land.lhs.true4:                                   ; preds = %if.end
  %call5 = call ptr @PyErr_Occurred()
  %tobool6 = icmp ne ptr %call5, null
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %land.lhs.true4
  br label %exit

if.end8:                                          ; preds = %land.lhs.true4, %if.end
  %6 = load ptr, ptr %args.addr, align 8
  %arrayidx9 = getelementptr ptr, ptr %6, i64 1
  %7 = load ptr, ptr %arrayidx9, align 8
  %call10 = call i32 @PyObject_GetBuffer(ptr noundef %7, ptr noundef %buffer, i32 noundef 0)
  %cmp11 = icmp ne i32 %call10, 0
  br i1 %cmp11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end8
  br label %exit

if.end13:                                         ; preds = %if.end8
  %8 = load ptr, ptr %args.addr, align 8
  %arrayidx14 = getelementptr ptr, ptr %8, i64 2
  %9 = load ptr, ptr %arrayidx14, align 8
  %call15 = call i32 @Py_off_t_converter(ptr noundef %9, ptr noundef %offset)
  %tobool16 = icmp ne i32 %call15, 0
  br i1 %tobool16, label %if.end18, label %if.then17

if.then17:                                        ; preds = %if.end13
  br label %exit

if.end18:                                         ; preds = %if.end13
  %10 = load ptr, ptr %module.addr, align 8
  %11 = load i32, ptr %fd, align 4
  %12 = load i64, ptr %offset, align 8
  %call19 = call i64 @os_pwrite_impl(ptr noundef %10, i32 noundef %11, ptr noundef %buffer, i64 noundef %12)
  store i64 %call19, ptr %_return_value, align 8
  %13 = load i64, ptr %_return_value, align 8
  %cmp20 = icmp eq i64 %13, -1
  br i1 %cmp20, label %land.lhs.true21, label %if.end25

land.lhs.true21:                                  ; preds = %if.end18
  %call22 = call ptr @PyErr_Occurred()
  %tobool23 = icmp ne ptr %call22, null
  br i1 %tobool23, label %if.then24, label %if.end25

if.then24:                                        ; preds = %land.lhs.true21
  br label %exit

if.end25:                                         ; preds = %land.lhs.true21, %if.end18
  %14 = load i64, ptr %_return_value, align 8
  %call26 = call ptr @PyLong_FromSsize_t(i64 noundef %14)
  store ptr %call26, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end25, %if.then24, %if.then17, %if.then12, %if.then7, %if.then
  %obj = getelementptr inbounds %struct.Py_buffer, ptr %buffer, i32 0, i32 1
  %15 = load ptr, ptr %obj, align 8
  %tobool27 = icmp ne ptr %15, null
  br i1 %tobool27, label %if.then28, label %if.end29

if.then28:                                        ; preds = %exit
  call void @PyBuffer_Release(ptr noundef %buffer)
  br label %if.end29

if.end29:                                         ; preds = %if.then28, %exit
  %16 = load ptr, ptr %return_value, align 8
  ret ptr %16
}

; Function Attrs: nounwind uwtable
define internal ptr @os_pwritev(ptr noundef %module, ptr noundef %args, i64 noundef %nargs) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %return_value = alloca ptr, align 8
  %fd = alloca i32, align 4
  %buffers = alloca ptr, align 8
  %offset = alloca i64, align 8
  %flags = alloca i32, align 4
  %_return_value = alloca i64, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  store i32 0, ptr %flags, align 4
  %0 = load i64, ptr %nargs.addr, align 8
  %cmp = icmp sle i64 3, %0
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 %1, 4
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %2 = load i64, ptr %nargs.addr, align 8
  %call = call i32 @_PyArg_CheckPositional(ptr noundef @.str.114, i64 noundef %2, i64 noundef 3, i64 noundef 4)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false
  br label %exit

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %3 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %3, i64 0
  %4 = load ptr, ptr %arrayidx, align 8
  %call2 = call i32 @PyLong_AsInt(ptr noundef %4)
  store i32 %call2, ptr %fd, align 4
  %5 = load i32, ptr %fd, align 4
  %cmp3 = icmp eq i32 %5, -1
  br i1 %cmp3, label %land.lhs.true4, label %if.end8

land.lhs.true4:                                   ; preds = %if.end
  %call5 = call ptr @PyErr_Occurred()
  %tobool6 = icmp ne ptr %call5, null
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %land.lhs.true4
  br label %exit

if.end8:                                          ; preds = %land.lhs.true4, %if.end
  %6 = load ptr, ptr %args.addr, align 8
  %arrayidx9 = getelementptr ptr, ptr %6, i64 1
  %7 = load ptr, ptr %arrayidx9, align 8
  store ptr %7, ptr %buffers, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %arrayidx10 = getelementptr ptr, ptr %8, i64 2
  %9 = load ptr, ptr %arrayidx10, align 8
  %call11 = call i32 @Py_off_t_converter(ptr noundef %9, ptr noundef %offset)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %if.end14, label %if.then13

if.then13:                                        ; preds = %if.end8
  br label %exit

if.end14:                                         ; preds = %if.end8
  %10 = load i64, ptr %nargs.addr, align 8
  %cmp15 = icmp slt i64 %10, 4
  br i1 %cmp15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.end14
  br label %skip_optional

if.end17:                                         ; preds = %if.end14
  %11 = load ptr, ptr %args.addr, align 8
  %arrayidx18 = getelementptr ptr, ptr %11, i64 3
  %12 = load ptr, ptr %arrayidx18, align 8
  %call19 = call i32 @PyLong_AsInt(ptr noundef %12)
  store i32 %call19, ptr %flags, align 4
  %13 = load i32, ptr %flags, align 4
  %cmp20 = icmp eq i32 %13, -1
  br i1 %cmp20, label %land.lhs.true21, label %if.end25

land.lhs.true21:                                  ; preds = %if.end17
  %call22 = call ptr @PyErr_Occurred()
  %tobool23 = icmp ne ptr %call22, null
  br i1 %tobool23, label %if.then24, label %if.end25

if.then24:                                        ; preds = %land.lhs.true21
  br label %exit

if.end25:                                         ; preds = %land.lhs.true21, %if.end17
  br label %skip_optional

skip_optional:                                    ; preds = %if.end25, %if.then16
  %14 = load ptr, ptr %module.addr, align 8
  %15 = load i32, ptr %fd, align 4
  %16 = load ptr, ptr %buffers, align 8
  %17 = load i64, ptr %offset, align 8
  %18 = load i32, ptr %flags, align 4
  %call26 = call i64 @os_pwritev_impl(ptr noundef %14, i32 noundef %15, ptr noundef %16, i64 noundef %17, i32 noundef %18)
  store i64 %call26, ptr %_return_value, align 8
  %19 = load i64, ptr %_return_value, align 8
  %cmp27 = icmp eq i64 %19, -1
  br i1 %cmp27, label %land.lhs.true28, label %if.end32

land.lhs.true28:                                  ; preds = %skip_optional
  %call29 = call ptr @PyErr_Occurred()
  %tobool30 = icmp ne ptr %call29, null
  br i1 %tobool30, label %if.then31, label %if.end32

if.then31:                                        ; preds = %land.lhs.true28
  br label %exit

if.end32:                                         ; preds = %land.lhs.true28, %skip_optional
  %20 = load i64, ptr %_return_value, align 8
  %call33 = call ptr @PyLong_FromSsize_t(i64 noundef %20)
  store ptr %call33, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end32, %if.then31, %if.then24, %if.then13, %if.then7, %if.then
  %21 = load ptr, ptr %return_value, align 8
  ret ptr %21
}

; Function Attrs: nounwind uwtable
define internal ptr @os_sendfile(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %op.addr.i35 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [4 x ptr], align 16
  %out_fd = alloca i32, align 4
  %in_fd = alloca i32, align 4
  %offobj = alloca ptr, align 8
  %count = alloca i64, align 8
  %ival = alloca i64, align 8
  %iobj = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 4, %1
  br i1 %cmp1, label %land.lhs.true2, label %cond.false

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %2, 4
  br i1 %cmp3, label %land.lhs.true4, label %cond.false

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %3 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %3, null
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true4
  %4 = load ptr, ptr %args.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  %5 = load ptr, ptr %args.addr, align 8
  %6 = load i64, ptr %nargs.addr, align 8
  %7 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [4 x ptr], ptr %argsbuf, i64 0, i64 0
  %call = call ptr @_PyArg_UnpackKeywords(ptr noundef %5, i64 noundef %6, ptr noundef null, ptr noundef %7, ptr noundef @os_sendfile._parser, i32 noundef 4, i32 noundef 4, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %4, %cond.true ], [ %call, %cond.false ]
  store ptr %cond, ptr %args.addr, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  br label %exit

if.end:                                           ; preds = %cond.end
  %9 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %9, i64 0
  %10 = load ptr, ptr %arrayidx, align 8
  %call6 = call i32 @PyLong_AsInt(ptr noundef %10)
  store i32 %call6, ptr %out_fd, align 4
  %11 = load i32, ptr %out_fd, align 4
  %cmp7 = icmp eq i32 %11, -1
  br i1 %cmp7, label %land.lhs.true8, label %if.end12

land.lhs.true8:                                   ; preds = %if.end
  %call9 = call ptr @PyErr_Occurred()
  %tobool10 = icmp ne ptr %call9, null
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %land.lhs.true8
  br label %exit

if.end12:                                         ; preds = %land.lhs.true8, %if.end
  %12 = load ptr, ptr %args.addr, align 8
  %arrayidx13 = getelementptr ptr, ptr %12, i64 1
  %13 = load ptr, ptr %arrayidx13, align 8
  %call14 = call i32 @PyLong_AsInt(ptr noundef %13)
  store i32 %call14, ptr %in_fd, align 4
  %14 = load i32, ptr %in_fd, align 4
  %cmp15 = icmp eq i32 %14, -1
  br i1 %cmp15, label %land.lhs.true16, label %if.end20

land.lhs.true16:                                  ; preds = %if.end12
  %call17 = call ptr @PyErr_Occurred()
  %tobool18 = icmp ne ptr %call17, null
  br i1 %tobool18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %land.lhs.true16
  br label %exit

if.end20:                                         ; preds = %land.lhs.true16, %if.end12
  %15 = load ptr, ptr %args.addr, align 8
  %arrayidx21 = getelementptr ptr, ptr %15, i64 2
  %16 = load ptr, ptr %arrayidx21, align 8
  store ptr %16, ptr %offobj, align 8
  store i64 -1, ptr %ival, align 8
  %17 = load ptr, ptr %args.addr, align 8
  %arrayidx22 = getelementptr ptr, ptr %17, i64 3
  %18 = load ptr, ptr %arrayidx22, align 8
  %call23 = call ptr @_PyNumber_Index(ptr noundef %18)
  store ptr %call23, ptr %iobj, align 8
  %19 = load ptr, ptr %iobj, align 8
  %cmp24 = icmp ne ptr %19, null
  br i1 %cmp24, label %if.then25, label %if.end27

if.then25:                                        ; preds = %if.end20
  %20 = load ptr, ptr %iobj, align 8
  %call26 = call i64 @PyLong_AsSsize_t(ptr noundef %20)
  store i64 %call26, ptr %ival, align 8
  %21 = load ptr, ptr %iobj, align 8
  store ptr %21, ptr %op.addr.i, align 8
  %22 = load ptr, ptr %op.addr.i, align 8
  store ptr %22, ptr %op.addr.i35, align 8
  %23 = load ptr, ptr %op.addr.i35, align 8
  %24 = load i64, ptr %23, align 8
  %conv.i = trunc i64 %24 to i32
  %cmp.i36 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i36 to i32
  %tobool.i = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then25
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.then25
  %25 = load ptr, ptr %op.addr.i, align 8
  %26 = load i64, ptr %25, align 8
  %dec.i = add i64 %26, -1
  store i64 %dec.i, ptr %25, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %27 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %27) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  br label %if.end27

if.end27:                                         ; preds = %Py_DECREF.exit, %if.end20
  %28 = load i64, ptr %ival, align 8
  %cmp28 = icmp eq i64 %28, -1
  br i1 %cmp28, label %land.lhs.true29, label %if.end33

land.lhs.true29:                                  ; preds = %if.end27
  %call30 = call ptr @PyErr_Occurred()
  %tobool31 = icmp ne ptr %call30, null
  br i1 %tobool31, label %if.then32, label %if.end33

if.then32:                                        ; preds = %land.lhs.true29
  br label %exit

if.end33:                                         ; preds = %land.lhs.true29, %if.end27
  %29 = load i64, ptr %ival, align 8
  store i64 %29, ptr %count, align 8
  %30 = load ptr, ptr %module.addr, align 8
  %31 = load i32, ptr %out_fd, align 4
  %32 = load i32, ptr %in_fd, align 4
  %33 = load ptr, ptr %offobj, align 8
  %34 = load i64, ptr %count, align 8
  %call34 = call ptr @os_sendfile_impl(ptr noundef %30, i32 noundef %31, i32 noundef %32, ptr noundef %33, i64 noundef %34)
  store ptr %call34, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end33, %if.then32, %if.then19, %if.then11, %if.then
  %35 = load ptr, ptr %return_value, align 8
  ret ptr %35
}

; Function Attrs: nounwind uwtable
define internal ptr @os_fstat(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [1 x ptr], align 8
  %fd = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 1, %1
  br i1 %cmp1, label %land.lhs.true2, label %cond.false

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %2, 1
  br i1 %cmp3, label %land.lhs.true4, label %cond.false

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %3 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %3, null
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true4
  %4 = load ptr, ptr %args.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  %5 = load ptr, ptr %args.addr, align 8
  %6 = load i64, ptr %nargs.addr, align 8
  %7 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [1 x ptr], ptr %argsbuf, i64 0, i64 0
  %call = call ptr @_PyArg_UnpackKeywords(ptr noundef %5, i64 noundef %6, ptr noundef null, ptr noundef %7, ptr noundef @os_fstat._parser, i32 noundef 1, i32 noundef 1, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %4, %cond.true ], [ %call, %cond.false ]
  store ptr %cond, ptr %args.addr, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  br label %exit

if.end:                                           ; preds = %cond.end
  %9 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %9, i64 0
  %10 = load ptr, ptr %arrayidx, align 8
  %call6 = call i32 @PyLong_AsInt(ptr noundef %10)
  store i32 %call6, ptr %fd, align 4
  %11 = load i32, ptr %fd, align 4
  %cmp7 = icmp eq i32 %11, -1
  br i1 %cmp7, label %land.lhs.true8, label %if.end12

land.lhs.true8:                                   ; preds = %if.end
  %call9 = call ptr @PyErr_Occurred()
  %tobool10 = icmp ne ptr %call9, null
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %land.lhs.true8
  br label %exit

if.end12:                                         ; preds = %land.lhs.true8, %if.end
  %12 = load ptr, ptr %module.addr, align 8
  %13 = load i32, ptr %fd, align 4
  %call13 = call ptr @os_fstat_impl(ptr noundef %12, i32 noundef %13)
  store ptr %call13, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end12, %if.then11, %if.then
  %14 = load ptr, ptr %return_value, align 8
  ret ptr %14
}

; Function Attrs: nounwind uwtable
define internal ptr @os_isatty(ptr noundef %module, ptr noundef %arg) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %fd = alloca i32, align 4
  %_return_value = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %call = call i32 @PyLong_AsInt(ptr noundef %0)
  store i32 %call, ptr %fd, align 4
  %1 = load i32, ptr %fd, align 4
  %cmp = icmp eq i32 %1, -1
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %call1 = call ptr @PyErr_Occurred()
  %tobool = icmp ne ptr %call1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  br label %exit

if.end:                                           ; preds = %land.lhs.true, %entry
  %2 = load ptr, ptr %module.addr, align 8
  %3 = load i32, ptr %fd, align 4
  %call2 = call i32 @os_isatty_impl(ptr noundef %2, i32 noundef %3)
  store i32 %call2, ptr %_return_value, align 4
  %4 = load i32, ptr %_return_value, align 4
  %cmp3 = icmp eq i32 %4, -1
  br i1 %cmp3, label %land.lhs.true4, label %if.end8

land.lhs.true4:                                   ; preds = %if.end
  %call5 = call ptr @PyErr_Occurred()
  %tobool6 = icmp ne ptr %call5, null
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %land.lhs.true4
  br label %exit

if.end8:                                          ; preds = %land.lhs.true4, %if.end
  %5 = load i32, ptr %_return_value, align 4
  %conv = sext i32 %5 to i64
  %call9 = call ptr @PyBool_FromLong(i64 noundef %conv)
  store ptr %call9, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end8, %if.then7, %if.then
  %6 = load ptr, ptr %return_value, align 8
  ret ptr %6
}

; Function Attrs: nounwind uwtable
define internal ptr @os_pipe(ptr noundef %module, ptr noundef %_unused_ignored) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %call = call ptr @os_pipe_impl(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @os_pipe2(ptr noundef %module, ptr noundef %arg) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %flags = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %call = call i32 @PyLong_AsInt(ptr noundef %0)
  store i32 %call, ptr %flags, align 4
  %1 = load i32, ptr %flags, align 4
  %cmp = icmp eq i32 %1, -1
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %call1 = call ptr @PyErr_Occurred()
  %tobool = icmp ne ptr %call1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  br label %exit

if.end:                                           ; preds = %land.lhs.true, %entry
  %2 = load ptr, ptr %module.addr, align 8
  %3 = load i32, ptr %flags, align 4
  %call2 = call ptr @os_pipe2_impl(ptr noundef %2, i32 noundef %3)
  store ptr %call2, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end, %if.then
  %4 = load ptr, ptr %return_value, align 8
  ret ptr %4
}

; Function Attrs: nounwind uwtable
define internal ptr @os_mkfifo(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [3 x ptr], align 16
  %noptargs = alloca i64, align 8
  %path = alloca %struct.path_t, align 8
  %mode = alloca i32, align 4
  %dir_fd = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 1
  store i64 %sub, ptr %noptargs, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %path, ptr align 8 @__const.os_mkfifo.path, i64 72, i1 false)
  store i32 438, ptr %mode, align 4
  store i32 -100, ptr %dir_fd, align 4
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 1, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 2
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [3 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @os_mkfifo._parser, i32 noundef 1, i32 noundef 2, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %12, i64 0
  %13 = load ptr, ptr %arrayidx, align 8
  %call12 = call i32 @path_converter(ptr noundef %13, ptr noundef %path)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end
  br label %exit

if.end15:                                         ; preds = %if.end
  %14 = load i64, ptr %noptargs, align 8
  %tobool16 = icmp ne i64 %14, 0
  br i1 %tobool16, label %if.end18, label %if.then17

if.then17:                                        ; preds = %if.end15
  br label %skip_optional_pos

if.end18:                                         ; preds = %if.end15
  %15 = load ptr, ptr %args.addr, align 8
  %arrayidx19 = getelementptr ptr, ptr %15, i64 1
  %16 = load ptr, ptr %arrayidx19, align 8
  %tobool20 = icmp ne ptr %16, null
  br i1 %tobool20, label %if.then21, label %if.end33

if.then21:                                        ; preds = %if.end18
  %17 = load ptr, ptr %args.addr, align 8
  %arrayidx22 = getelementptr ptr, ptr %17, i64 1
  %18 = load ptr, ptr %arrayidx22, align 8
  %call23 = call i32 @PyLong_AsInt(ptr noundef %18)
  store i32 %call23, ptr %mode, align 4
  %19 = load i32, ptr %mode, align 4
  %cmp24 = icmp eq i32 %19, -1
  br i1 %cmp24, label %land.lhs.true25, label %if.end29

land.lhs.true25:                                  ; preds = %if.then21
  %call26 = call ptr @PyErr_Occurred()
  %tobool27 = icmp ne ptr %call26, null
  br i1 %tobool27, label %if.then28, label %if.end29

if.then28:                                        ; preds = %land.lhs.true25
  br label %exit

if.end29:                                         ; preds = %land.lhs.true25, %if.then21
  %20 = load i64, ptr %noptargs, align 8
  %dec = add i64 %20, -1
  store i64 %dec, ptr %noptargs, align 8
  %tobool30 = icmp ne i64 %dec, 0
  br i1 %tobool30, label %if.end32, label %if.then31

if.then31:                                        ; preds = %if.end29
  br label %skip_optional_pos

if.end32:                                         ; preds = %if.end29
  br label %if.end33

if.end33:                                         ; preds = %if.end32, %if.end18
  br label %skip_optional_pos

skip_optional_pos:                                ; preds = %if.end33, %if.then31, %if.then17
  %21 = load i64, ptr %noptargs, align 8
  %tobool34 = icmp ne i64 %21, 0
  br i1 %tobool34, label %if.end36, label %if.then35

if.then35:                                        ; preds = %skip_optional_pos
  br label %skip_optional_kwonly

if.end36:                                         ; preds = %skip_optional_pos
  %22 = load ptr, ptr %args.addr, align 8
  %arrayidx37 = getelementptr ptr, ptr %22, i64 2
  %23 = load ptr, ptr %arrayidx37, align 8
  %call38 = call i32 @dir_fd_converter(ptr noundef %23, ptr noundef %dir_fd)
  %tobool39 = icmp ne i32 %call38, 0
  br i1 %tobool39, label %if.end41, label %if.then40

if.then40:                                        ; preds = %if.end36
  br label %exit

if.end41:                                         ; preds = %if.end36
  br label %skip_optional_kwonly

skip_optional_kwonly:                             ; preds = %if.end41, %if.then35
  %24 = load ptr, ptr %module.addr, align 8
  %25 = load i32, ptr %mode, align 4
  %26 = load i32, ptr %dir_fd, align 4
  %call42 = call ptr @os_mkfifo_impl(ptr noundef %24, ptr noundef %path, i32 noundef %25, i32 noundef %26)
  store ptr %call42, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional_kwonly, %if.then40, %if.then28, %if.then14, %if.then
  call void @path_cleanup(ptr noundef %path)
  %27 = load ptr, ptr %return_value, align 8
  ret ptr %27
}

; Function Attrs: nounwind uwtable
define internal ptr @os_mknod(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [4 x ptr], align 16
  %noptargs = alloca i64, align 8
  %path = alloca %struct.path_t, align 8
  %mode = alloca i32, align 4
  %device = alloca i64, align 8
  %dir_fd = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 1
  store i64 %sub, ptr %noptargs, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %path, ptr align 8 @__const.os_mknod.path, i64 72, i1 false)
  store i32 384, ptr %mode, align 4
  store i64 0, ptr %device, align 8
  store i32 -100, ptr %dir_fd, align 4
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 1, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 3
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [4 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @os_mknod._parser, i32 noundef 1, i32 noundef 3, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %12, i64 0
  %13 = load ptr, ptr %arrayidx, align 8
  %call12 = call i32 @path_converter(ptr noundef %13, ptr noundef %path)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end
  br label %exit

if.end15:                                         ; preds = %if.end
  %14 = load i64, ptr %noptargs, align 8
  %tobool16 = icmp ne i64 %14, 0
  br i1 %tobool16, label %if.end18, label %if.then17

if.then17:                                        ; preds = %if.end15
  br label %skip_optional_pos

if.end18:                                         ; preds = %if.end15
  %15 = load ptr, ptr %args.addr, align 8
  %arrayidx19 = getelementptr ptr, ptr %15, i64 1
  %16 = load ptr, ptr %arrayidx19, align 8
  %tobool20 = icmp ne ptr %16, null
  br i1 %tobool20, label %if.then21, label %if.end33

if.then21:                                        ; preds = %if.end18
  %17 = load ptr, ptr %args.addr, align 8
  %arrayidx22 = getelementptr ptr, ptr %17, i64 1
  %18 = load ptr, ptr %arrayidx22, align 8
  %call23 = call i32 @PyLong_AsInt(ptr noundef %18)
  store i32 %call23, ptr %mode, align 4
  %19 = load i32, ptr %mode, align 4
  %cmp24 = icmp eq i32 %19, -1
  br i1 %cmp24, label %land.lhs.true25, label %if.end29

land.lhs.true25:                                  ; preds = %if.then21
  %call26 = call ptr @PyErr_Occurred()
  %tobool27 = icmp ne ptr %call26, null
  br i1 %tobool27, label %if.then28, label %if.end29

if.then28:                                        ; preds = %land.lhs.true25
  br label %exit

if.end29:                                         ; preds = %land.lhs.true25, %if.then21
  %20 = load i64, ptr %noptargs, align 8
  %dec = add i64 %20, -1
  store i64 %dec, ptr %noptargs, align 8
  %tobool30 = icmp ne i64 %dec, 0
  br i1 %tobool30, label %if.end32, label %if.then31

if.then31:                                        ; preds = %if.end29
  br label %skip_optional_pos

if.end32:                                         ; preds = %if.end29
  br label %if.end33

if.end33:                                         ; preds = %if.end32, %if.end18
  %21 = load ptr, ptr %args.addr, align 8
  %arrayidx34 = getelementptr ptr, ptr %21, i64 2
  %22 = load ptr, ptr %arrayidx34, align 8
  %tobool35 = icmp ne ptr %22, null
  br i1 %tobool35, label %if.then36, label %if.end46

if.then36:                                        ; preds = %if.end33
  %23 = load ptr, ptr %args.addr, align 8
  %arrayidx37 = getelementptr ptr, ptr %23, i64 2
  %24 = load ptr, ptr %arrayidx37, align 8
  %call38 = call i32 @_Py_Dev_Converter(ptr noundef %24, ptr noundef %device)
  %tobool39 = icmp ne i32 %call38, 0
  br i1 %tobool39, label %if.end41, label %if.then40

if.then40:                                        ; preds = %if.then36
  br label %exit

if.end41:                                         ; preds = %if.then36
  %25 = load i64, ptr %noptargs, align 8
  %dec42 = add i64 %25, -1
  store i64 %dec42, ptr %noptargs, align 8
  %tobool43 = icmp ne i64 %dec42, 0
  br i1 %tobool43, label %if.end45, label %if.then44

if.then44:                                        ; preds = %if.end41
  br label %skip_optional_pos

if.end45:                                         ; preds = %if.end41
  br label %if.end46

if.end46:                                         ; preds = %if.end45, %if.end33
  br label %skip_optional_pos

skip_optional_pos:                                ; preds = %if.end46, %if.then44, %if.then31, %if.then17
  %26 = load i64, ptr %noptargs, align 8
  %tobool47 = icmp ne i64 %26, 0
  br i1 %tobool47, label %if.end49, label %if.then48

if.then48:                                        ; preds = %skip_optional_pos
  br label %skip_optional_kwonly

if.end49:                                         ; preds = %skip_optional_pos
  %27 = load ptr, ptr %args.addr, align 8
  %arrayidx50 = getelementptr ptr, ptr %27, i64 3
  %28 = load ptr, ptr %arrayidx50, align 8
  %call51 = call i32 @dir_fd_converter(ptr noundef %28, ptr noundef %dir_fd)
  %tobool52 = icmp ne i32 %call51, 0
  br i1 %tobool52, label %if.end54, label %if.then53

if.then53:                                        ; preds = %if.end49
  br label %exit

if.end54:                                         ; preds = %if.end49
  br label %skip_optional_kwonly

skip_optional_kwonly:                             ; preds = %if.end54, %if.then48
  %29 = load ptr, ptr %module.addr, align 8
  %30 = load i32, ptr %mode, align 4
  %31 = load i64, ptr %device, align 8
  %32 = load i32, ptr %dir_fd, align 4
  %call55 = call ptr @os_mknod_impl(ptr noundef %29, ptr noundef %path, i32 noundef %30, i64 noundef %31, i32 noundef %32)
  store ptr %call55, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional_kwonly, %if.then53, %if.then40, %if.then28, %if.then14, %if.then
  call void @path_cleanup(ptr noundef %path)
  %33 = load ptr, ptr %return_value, align 8
  ret ptr %33
}

; Function Attrs: nounwind uwtable
define internal ptr @os_major(ptr noundef %module, ptr noundef %arg) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %device = alloca i64, align 8
  %_return_value = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %call = call i32 @_Py_Dev_Converter(ptr noundef %0, ptr noundef %device)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %exit

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %module.addr, align 8
  %2 = load i64, ptr %device, align 8
  %call1 = call i32 @os_major_impl(ptr noundef %1, i64 noundef %2)
  store i32 %call1, ptr %_return_value, align 4
  %3 = load i32, ptr %_return_value, align 4
  %cmp = icmp eq i32 %3, -1
  br i1 %cmp, label %land.lhs.true, label %if.end5

land.lhs.true:                                    ; preds = %if.end
  %call2 = call ptr @PyErr_Occurred()
  %tobool3 = icmp ne ptr %call2, null
  br i1 %tobool3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %land.lhs.true
  br label %exit

if.end5:                                          ; preds = %land.lhs.true, %if.end
  %4 = load i32, ptr %_return_value, align 4
  %conv = zext i32 %4 to i64
  %call6 = call ptr @PyLong_FromUnsignedLong(i64 noundef %conv)
  store ptr %call6, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end5, %if.then4, %if.then
  %5 = load ptr, ptr %return_value, align 8
  ret ptr %5
}

; Function Attrs: nounwind uwtable
define internal ptr @os_minor(ptr noundef %module, ptr noundef %arg) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %device = alloca i64, align 8
  %_return_value = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %call = call i32 @_Py_Dev_Converter(ptr noundef %0, ptr noundef %device)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %exit

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %module.addr, align 8
  %2 = load i64, ptr %device, align 8
  %call1 = call i32 @os_minor_impl(ptr noundef %1, i64 noundef %2)
  store i32 %call1, ptr %_return_value, align 4
  %3 = load i32, ptr %_return_value, align 4
  %cmp = icmp eq i32 %3, -1
  br i1 %cmp, label %land.lhs.true, label %if.end5

land.lhs.true:                                    ; preds = %if.end
  %call2 = call ptr @PyErr_Occurred()
  %tobool3 = icmp ne ptr %call2, null
  br i1 %tobool3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %land.lhs.true
  br label %exit

if.end5:                                          ; preds = %land.lhs.true, %if.end
  %4 = load i32, ptr %_return_value, align 4
  %conv = zext i32 %4 to i64
  %call6 = call ptr @PyLong_FromUnsignedLong(i64 noundef %conv)
  store ptr %call6, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end5, %if.then4, %if.then
  %5 = load ptr, ptr %return_value, align 8
  ret ptr %5
}

; Function Attrs: nounwind uwtable
define internal ptr @os_makedev(ptr noundef %module, ptr noundef %args, i64 noundef %nargs) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %return_value = alloca ptr, align 8
  %major = alloca i32, align 4
  %minor = alloca i32, align 4
  %_return_value = alloca i64, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %cmp = icmp sle i64 2, %0
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 %1, 2
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %2 = load i64, ptr %nargs.addr, align 8
  %call = call i32 @_PyArg_CheckPositional(ptr noundef @.str.124, i64 noundef %2, i64 noundef 2, i64 noundef 2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false
  br label %exit

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %3 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %3, i64 0
  %4 = load ptr, ptr %arrayidx, align 8
  %call2 = call i32 @PyLong_AsInt(ptr noundef %4)
  store i32 %call2, ptr %major, align 4
  %5 = load i32, ptr %major, align 4
  %cmp3 = icmp eq i32 %5, -1
  br i1 %cmp3, label %land.lhs.true4, label %if.end8

land.lhs.true4:                                   ; preds = %if.end
  %call5 = call ptr @PyErr_Occurred()
  %tobool6 = icmp ne ptr %call5, null
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %land.lhs.true4
  br label %exit

if.end8:                                          ; preds = %land.lhs.true4, %if.end
  %6 = load ptr, ptr %args.addr, align 8
  %arrayidx9 = getelementptr ptr, ptr %6, i64 1
  %7 = load ptr, ptr %arrayidx9, align 8
  %call10 = call i32 @PyLong_AsInt(ptr noundef %7)
  store i32 %call10, ptr %minor, align 4
  %8 = load i32, ptr %minor, align 4
  %cmp11 = icmp eq i32 %8, -1
  br i1 %cmp11, label %land.lhs.true12, label %if.end16

land.lhs.true12:                                  ; preds = %if.end8
  %call13 = call ptr @PyErr_Occurred()
  %tobool14 = icmp ne ptr %call13, null
  br i1 %tobool14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %land.lhs.true12
  br label %exit

if.end16:                                         ; preds = %land.lhs.true12, %if.end8
  %9 = load ptr, ptr %module.addr, align 8
  %10 = load i32, ptr %major, align 4
  %11 = load i32, ptr %minor, align 4
  %call17 = call i64 @os_makedev_impl(ptr noundef %9, i32 noundef %10, i32 noundef %11)
  store i64 %call17, ptr %_return_value, align 8
  %12 = load i64, ptr %_return_value, align 8
  %cmp18 = icmp eq i64 %12, -1
  br i1 %cmp18, label %land.lhs.true19, label %if.end23

land.lhs.true19:                                  ; preds = %if.end16
  %call20 = call ptr @PyErr_Occurred()
  %tobool21 = icmp ne ptr %call20, null
  br i1 %tobool21, label %if.then22, label %if.end23

if.then22:                                        ; preds = %land.lhs.true19
  br label %exit

if.end23:                                         ; preds = %land.lhs.true19, %if.end16
  %13 = load i64, ptr %_return_value, align 8
  %call24 = call ptr @PyLong_FromLongLong(i64 noundef %13)
  store ptr %call24, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end23, %if.then22, %if.then15, %if.then7, %if.then
  %14 = load ptr, ptr %return_value, align 8
  ret ptr %14
}

; Function Attrs: nounwind uwtable
define internal ptr @os_ftruncate(ptr noundef %module, ptr noundef %args, i64 noundef %nargs) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %return_value = alloca ptr, align 8
  %fd = alloca i32, align 4
  %length = alloca i64, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %cmp = icmp sle i64 2, %0
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 %1, 2
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %2 = load i64, ptr %nargs.addr, align 8
  %call = call i32 @_PyArg_CheckPositional(ptr noundef @.str.125, i64 noundef %2, i64 noundef 2, i64 noundef 2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false
  br label %exit

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %3 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %3, i64 0
  %4 = load ptr, ptr %arrayidx, align 8
  %call2 = call i32 @PyLong_AsInt(ptr noundef %4)
  store i32 %call2, ptr %fd, align 4
  %5 = load i32, ptr %fd, align 4
  %cmp3 = icmp eq i32 %5, -1
  br i1 %cmp3, label %land.lhs.true4, label %if.end8

land.lhs.true4:                                   ; preds = %if.end
  %call5 = call ptr @PyErr_Occurred()
  %tobool6 = icmp ne ptr %call5, null
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %land.lhs.true4
  br label %exit

if.end8:                                          ; preds = %land.lhs.true4, %if.end
  %6 = load ptr, ptr %args.addr, align 8
  %arrayidx9 = getelementptr ptr, ptr %6, i64 1
  %7 = load ptr, ptr %arrayidx9, align 8
  %call10 = call i32 @Py_off_t_converter(ptr noundef %7, ptr noundef %length)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end13, label %if.then12

if.then12:                                        ; preds = %if.end8
  br label %exit

if.end13:                                         ; preds = %if.end8
  %8 = load ptr, ptr %module.addr, align 8
  %9 = load i32, ptr %fd, align 4
  %10 = load i64, ptr %length, align 8
  %call14 = call ptr @os_ftruncate_impl(ptr noundef %8, i32 noundef %9, i64 noundef %10)
  store ptr %call14, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end13, %if.then12, %if.then7, %if.then
  %11 = load ptr, ptr %return_value, align 8
  ret ptr %11
}

; Function Attrs: nounwind uwtable
define internal ptr @os_truncate(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [2 x ptr], align 16
  %path = alloca %struct.path_t, align 8
  %length = alloca i64, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %path, ptr align 8 @__const.os_truncate.path, i64 72, i1 false)
  %0 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 2, %1
  br i1 %cmp1, label %land.lhs.true2, label %cond.false

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %2, 2
  br i1 %cmp3, label %land.lhs.true4, label %cond.false

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %3 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %3, null
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true4
  %4 = load ptr, ptr %args.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  %5 = load ptr, ptr %args.addr, align 8
  %6 = load i64, ptr %nargs.addr, align 8
  %7 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [2 x ptr], ptr %argsbuf, i64 0, i64 0
  %call = call ptr @_PyArg_UnpackKeywords(ptr noundef %5, i64 noundef %6, ptr noundef null, ptr noundef %7, ptr noundef @os_truncate._parser, i32 noundef 2, i32 noundef 2, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %4, %cond.true ], [ %call, %cond.false ]
  store ptr %cond, ptr %args.addr, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  br label %exit

if.end:                                           ; preds = %cond.end
  %9 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %9, i64 0
  %10 = load ptr, ptr %arrayidx, align 8
  %call6 = call i32 @path_converter(ptr noundef %10, ptr noundef %path)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %if.end
  br label %exit

if.end9:                                          ; preds = %if.end
  %11 = load ptr, ptr %args.addr, align 8
  %arrayidx10 = getelementptr ptr, ptr %11, i64 1
  %12 = load ptr, ptr %arrayidx10, align 8
  %call11 = call i32 @Py_off_t_converter(ptr noundef %12, ptr noundef %length)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %if.end14, label %if.then13

if.then13:                                        ; preds = %if.end9
  br label %exit

if.end14:                                         ; preds = %if.end9
  %13 = load ptr, ptr %module.addr, align 8
  %14 = load i64, ptr %length, align 8
  %call15 = call ptr @os_truncate_impl(ptr noundef %13, ptr noundef %path, i64 noundef %14)
  store ptr %call15, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end14, %if.then13, %if.then8, %if.then
  call void @path_cleanup(ptr noundef %path)
  %15 = load ptr, ptr %return_value, align 8
  ret ptr %15
}

; Function Attrs: nounwind uwtable
define internal ptr @os_posix_fallocate(ptr noundef %module, ptr noundef %args, i64 noundef %nargs) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %return_value = alloca ptr, align 8
  %fd = alloca i32, align 4
  %offset = alloca i64, align 8
  %length = alloca i64, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %cmp = icmp sle i64 3, %0
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 %1, 3
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %2 = load i64, ptr %nargs.addr, align 8
  %call = call i32 @_PyArg_CheckPositional(ptr noundef @.str.127, i64 noundef %2, i64 noundef 3, i64 noundef 3)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false
  br label %exit

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %3 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %3, i64 0
  %4 = load ptr, ptr %arrayidx, align 8
  %call2 = call i32 @PyLong_AsInt(ptr noundef %4)
  store i32 %call2, ptr %fd, align 4
  %5 = load i32, ptr %fd, align 4
  %cmp3 = icmp eq i32 %5, -1
  br i1 %cmp3, label %land.lhs.true4, label %if.end8

land.lhs.true4:                                   ; preds = %if.end
  %call5 = call ptr @PyErr_Occurred()
  %tobool6 = icmp ne ptr %call5, null
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %land.lhs.true4
  br label %exit

if.end8:                                          ; preds = %land.lhs.true4, %if.end
  %6 = load ptr, ptr %args.addr, align 8
  %arrayidx9 = getelementptr ptr, ptr %6, i64 1
  %7 = load ptr, ptr %arrayidx9, align 8
  %call10 = call i32 @Py_off_t_converter(ptr noundef %7, ptr noundef %offset)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end13, label %if.then12

if.then12:                                        ; preds = %if.end8
  br label %exit

if.end13:                                         ; preds = %if.end8
  %8 = load ptr, ptr %args.addr, align 8
  %arrayidx14 = getelementptr ptr, ptr %8, i64 2
  %9 = load ptr, ptr %arrayidx14, align 8
  %call15 = call i32 @Py_off_t_converter(ptr noundef %9, ptr noundef %length)
  %tobool16 = icmp ne i32 %call15, 0
  br i1 %tobool16, label %if.end18, label %if.then17

if.then17:                                        ; preds = %if.end13
  br label %exit

if.end18:                                         ; preds = %if.end13
  %10 = load ptr, ptr %module.addr, align 8
  %11 = load i32, ptr %fd, align 4
  %12 = load i64, ptr %offset, align 8
  %13 = load i64, ptr %length, align 8
  %call19 = call ptr @os_posix_fallocate_impl(ptr noundef %10, i32 noundef %11, i64 noundef %12, i64 noundef %13)
  store ptr %call19, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end18, %if.then17, %if.then12, %if.then7, %if.then
  %14 = load ptr, ptr %return_value, align 8
  ret ptr %14
}

; Function Attrs: nounwind uwtable
define internal ptr @os_posix_fadvise(ptr noundef %module, ptr noundef %args, i64 noundef %nargs) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %return_value = alloca ptr, align 8
  %fd = alloca i32, align 4
  %offset = alloca i64, align 8
  %length = alloca i64, align 8
  %advice = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %cmp = icmp sle i64 4, %0
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 %1, 4
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %2 = load i64, ptr %nargs.addr, align 8
  %call = call i32 @_PyArg_CheckPositional(ptr noundef @.str.128, i64 noundef %2, i64 noundef 4, i64 noundef 4)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false
  br label %exit

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %3 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %3, i64 0
  %4 = load ptr, ptr %arrayidx, align 8
  %call2 = call i32 @PyLong_AsInt(ptr noundef %4)
  store i32 %call2, ptr %fd, align 4
  %5 = load i32, ptr %fd, align 4
  %cmp3 = icmp eq i32 %5, -1
  br i1 %cmp3, label %land.lhs.true4, label %if.end8

land.lhs.true4:                                   ; preds = %if.end
  %call5 = call ptr @PyErr_Occurred()
  %tobool6 = icmp ne ptr %call5, null
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %land.lhs.true4
  br label %exit

if.end8:                                          ; preds = %land.lhs.true4, %if.end
  %6 = load ptr, ptr %args.addr, align 8
  %arrayidx9 = getelementptr ptr, ptr %6, i64 1
  %7 = load ptr, ptr %arrayidx9, align 8
  %call10 = call i32 @Py_off_t_converter(ptr noundef %7, ptr noundef %offset)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end13, label %if.then12

if.then12:                                        ; preds = %if.end8
  br label %exit

if.end13:                                         ; preds = %if.end8
  %8 = load ptr, ptr %args.addr, align 8
  %arrayidx14 = getelementptr ptr, ptr %8, i64 2
  %9 = load ptr, ptr %arrayidx14, align 8
  %call15 = call i32 @Py_off_t_converter(ptr noundef %9, ptr noundef %length)
  %tobool16 = icmp ne i32 %call15, 0
  br i1 %tobool16, label %if.end18, label %if.then17

if.then17:                                        ; preds = %if.end13
  br label %exit

if.end18:                                         ; preds = %if.end13
  %10 = load ptr, ptr %args.addr, align 8
  %arrayidx19 = getelementptr ptr, ptr %10, i64 3
  %11 = load ptr, ptr %arrayidx19, align 8
  %call20 = call i32 @PyLong_AsInt(ptr noundef %11)
  store i32 %call20, ptr %advice, align 4
  %12 = load i32, ptr %advice, align 4
  %cmp21 = icmp eq i32 %12, -1
  br i1 %cmp21, label %land.lhs.true22, label %if.end26

land.lhs.true22:                                  ; preds = %if.end18
  %call23 = call ptr @PyErr_Occurred()
  %tobool24 = icmp ne ptr %call23, null
  br i1 %tobool24, label %if.then25, label %if.end26

if.then25:                                        ; preds = %land.lhs.true22
  br label %exit

if.end26:                                         ; preds = %land.lhs.true22, %if.end18
  %13 = load ptr, ptr %module.addr, align 8
  %14 = load i32, ptr %fd, align 4
  %15 = load i64, ptr %offset, align 8
  %16 = load i64, ptr %length, align 8
  %17 = load i32, ptr %advice, align 4
  %call27 = call ptr @os_posix_fadvise_impl(ptr noundef %13, i32 noundef %14, i64 noundef %15, i64 noundef %16, i32 noundef %17)
  store ptr %call27, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end26, %if.then25, %if.then17, %if.then12, %if.then7, %if.then
  %18 = load ptr, ptr %return_value, align 8
  ret ptr %18
}

; Function Attrs: nounwind uwtable
define internal ptr @os_putenv(ptr noundef %module, ptr noundef %args, i64 noundef %nargs) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %return_value = alloca ptr, align 8
  %name = alloca ptr, align 8
  %value = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  store ptr null, ptr %name, align 8
  store ptr null, ptr %value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %cmp = icmp sle i64 2, %0
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 %1, 2
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %2 = load i64, ptr %nargs.addr, align 8
  %call = call i32 @_PyArg_CheckPositional(ptr noundef @.str.129, i64 noundef %2, i64 noundef 2, i64 noundef 2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false
  br label %exit

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %3 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %3, i64 0
  %4 = load ptr, ptr %arrayidx, align 8
  %call2 = call i32 @PyUnicode_FSConverter(ptr noundef %4, ptr noundef %name)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.end
  br label %exit

if.end5:                                          ; preds = %if.end
  %5 = load ptr, ptr %args.addr, align 8
  %arrayidx6 = getelementptr ptr, ptr %5, i64 1
  %6 = load ptr, ptr %arrayidx6, align 8
  %call7 = call i32 @PyUnicode_FSConverter(ptr noundef %6, ptr noundef %value)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end10, label %if.then9

if.then9:                                         ; preds = %if.end5
  br label %exit

if.end10:                                         ; preds = %if.end5
  %7 = load ptr, ptr %module.addr, align 8
  %8 = load ptr, ptr %name, align 8
  %9 = load ptr, ptr %value, align 8
  %call11 = call ptr @os_putenv_impl(ptr noundef %7, ptr noundef %8, ptr noundef %9)
  store ptr %call11, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end10, %if.then9, %if.then4, %if.then
  %10 = load ptr, ptr %name, align 8
  call void @Py_XDECREF(ptr noundef %10)
  %11 = load ptr, ptr %value, align 8
  call void @Py_XDECREF(ptr noundef %11)
  %12 = load ptr, ptr %return_value, align 8
  ret ptr %12
}

; Function Attrs: nounwind uwtable
define internal ptr @os_unsetenv(ptr noundef %module, ptr noundef %arg) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %name = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr null, ptr %return_value, align 8
  store ptr null, ptr %name, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %call = call i32 @PyUnicode_FSConverter(ptr noundef %0, ptr noundef %name)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %exit

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %module.addr, align 8
  %2 = load ptr, ptr %name, align 8
  %call1 = call ptr @os_unsetenv_impl(ptr noundef %1, ptr noundef %2)
  store ptr %call1, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end, %if.then
  %3 = load ptr, ptr %name, align 8
  call void @Py_XDECREF(ptr noundef %3)
  %4 = load ptr, ptr %return_value, align 8
  ret ptr %4
}

; Function Attrs: nounwind uwtable
define internal ptr @os_strerror(ptr noundef %module, ptr noundef %arg) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %code = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %call = call i32 @PyLong_AsInt(ptr noundef %0)
  store i32 %call, ptr %code, align 4
  %1 = load i32, ptr %code, align 4
  %cmp = icmp eq i32 %1, -1
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %call1 = call ptr @PyErr_Occurred()
  %tobool = icmp ne ptr %call1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  br label %exit

if.end:                                           ; preds = %land.lhs.true, %entry
  %2 = load ptr, ptr %module.addr, align 8
  %3 = load i32, ptr %code, align 4
  %call2 = call ptr @os_strerror_impl(ptr noundef %2, i32 noundef %3)
  store ptr %call2, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end, %if.then
  %4 = load ptr, ptr %return_value, align 8
  ret ptr %4
}

; Function Attrs: nounwind uwtable
define internal ptr @os_fchdir(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [1 x ptr], align 8
  %fd = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 1, %1
  br i1 %cmp1, label %land.lhs.true2, label %cond.false

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %2, 1
  br i1 %cmp3, label %land.lhs.true4, label %cond.false

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %3 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %3, null
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true4
  %4 = load ptr, ptr %args.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  %5 = load ptr, ptr %args.addr, align 8
  %6 = load i64, ptr %nargs.addr, align 8
  %7 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [1 x ptr], ptr %argsbuf, i64 0, i64 0
  %call = call ptr @_PyArg_UnpackKeywords(ptr noundef %5, i64 noundef %6, ptr noundef null, ptr noundef %7, ptr noundef @os_fchdir._parser, i32 noundef 1, i32 noundef 1, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %4, %cond.true ], [ %call, %cond.false ]
  store ptr %cond, ptr %args.addr, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  br label %exit

if.end:                                           ; preds = %cond.end
  %9 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %9, i64 0
  %10 = load ptr, ptr %arrayidx, align 8
  %call6 = call i32 @_PyLong_FileDescriptor_Converter(ptr noundef %10, ptr noundef %fd)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %if.end
  br label %exit

if.end9:                                          ; preds = %if.end
  %11 = load ptr, ptr %module.addr, align 8
  %12 = load i32, ptr %fd, align 4
  %call10 = call ptr @os_fchdir_impl(ptr noundef %11, i32 noundef %12)
  store ptr %call10, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end9, %if.then8, %if.then
  %13 = load ptr, ptr %return_value, align 8
  ret ptr %13
}

; Function Attrs: nounwind uwtable
define internal ptr @os_fsync(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [1 x ptr], align 8
  %fd = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 1, %1
  br i1 %cmp1, label %land.lhs.true2, label %cond.false

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %2, 1
  br i1 %cmp3, label %land.lhs.true4, label %cond.false

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %3 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %3, null
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true4
  %4 = load ptr, ptr %args.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  %5 = load ptr, ptr %args.addr, align 8
  %6 = load i64, ptr %nargs.addr, align 8
  %7 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [1 x ptr], ptr %argsbuf, i64 0, i64 0
  %call = call ptr @_PyArg_UnpackKeywords(ptr noundef %5, i64 noundef %6, ptr noundef null, ptr noundef %7, ptr noundef @os_fsync._parser, i32 noundef 1, i32 noundef 1, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %4, %cond.true ], [ %call, %cond.false ]
  store ptr %cond, ptr %args.addr, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  br label %exit

if.end:                                           ; preds = %cond.end
  %9 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %9, i64 0
  %10 = load ptr, ptr %arrayidx, align 8
  %call6 = call i32 @_PyLong_FileDescriptor_Converter(ptr noundef %10, ptr noundef %fd)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %if.end
  br label %exit

if.end9:                                          ; preds = %if.end
  %11 = load ptr, ptr %module.addr, align 8
  %12 = load i32, ptr %fd, align 4
  %call10 = call ptr @os_fsync_impl(ptr noundef %11, i32 noundef %12)
  store ptr %call10, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end9, %if.then8, %if.then
  %13 = load ptr, ptr %return_value, align 8
  ret ptr %13
}

; Function Attrs: nounwind uwtable
define internal ptr @os_sync(ptr noundef %module, ptr noundef %_unused_ignored) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %call = call ptr @os_sync_impl(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @os_fdatasync(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [1 x ptr], align 8
  %fd = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 1, %1
  br i1 %cmp1, label %land.lhs.true2, label %cond.false

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %2, 1
  br i1 %cmp3, label %land.lhs.true4, label %cond.false

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %3 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %3, null
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true4
  %4 = load ptr, ptr %args.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  %5 = load ptr, ptr %args.addr, align 8
  %6 = load i64, ptr %nargs.addr, align 8
  %7 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [1 x ptr], ptr %argsbuf, i64 0, i64 0
  %call = call ptr @_PyArg_UnpackKeywords(ptr noundef %5, i64 noundef %6, ptr noundef null, ptr noundef %7, ptr noundef @os_fdatasync._parser, i32 noundef 1, i32 noundef 1, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %4, %cond.true ], [ %call, %cond.false ]
  store ptr %cond, ptr %args.addr, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  br label %exit

if.end:                                           ; preds = %cond.end
  %9 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %9, i64 0
  %10 = load ptr, ptr %arrayidx, align 8
  %call6 = call i32 @_PyLong_FileDescriptor_Converter(ptr noundef %10, ptr noundef %fd)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %if.end
  br label %exit

if.end9:                                          ; preds = %if.end
  %11 = load ptr, ptr %module.addr, align 8
  %12 = load i32, ptr %fd, align 4
  %call10 = call ptr @os_fdatasync_impl(ptr noundef %11, i32 noundef %12)
  store ptr %call10, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end9, %if.then8, %if.then
  %13 = load ptr, ptr %return_value, align 8
  ret ptr %13
}

; Function Attrs: nounwind uwtable
define internal ptr @os_WCOREDUMP(ptr noundef %module, ptr noundef %arg) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %status = alloca i32, align 4
  %_return_value = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %call = call i32 @PyLong_AsInt(ptr noundef %0)
  store i32 %call, ptr %status, align 4
  %1 = load i32, ptr %status, align 4
  %cmp = icmp eq i32 %1, -1
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %call1 = call ptr @PyErr_Occurred()
  %tobool = icmp ne ptr %call1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  br label %exit

if.end:                                           ; preds = %land.lhs.true, %entry
  %2 = load ptr, ptr %module.addr, align 8
  %3 = load i32, ptr %status, align 4
  %call2 = call i32 @os_WCOREDUMP_impl(ptr noundef %2, i32 noundef %3)
  store i32 %call2, ptr %_return_value, align 4
  %4 = load i32, ptr %_return_value, align 4
  %cmp3 = icmp eq i32 %4, -1
  br i1 %cmp3, label %land.lhs.true4, label %if.end8

land.lhs.true4:                                   ; preds = %if.end
  %call5 = call ptr @PyErr_Occurred()
  %tobool6 = icmp ne ptr %call5, null
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %land.lhs.true4
  br label %exit

if.end8:                                          ; preds = %land.lhs.true4, %if.end
  %5 = load i32, ptr %_return_value, align 4
  %conv = sext i32 %5 to i64
  %call9 = call ptr @PyBool_FromLong(i64 noundef %conv)
  store ptr %call9, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end8, %if.then7, %if.then
  %6 = load ptr, ptr %return_value, align 8
  ret ptr %6
}

; Function Attrs: nounwind uwtable
define internal ptr @os_WIFCONTINUED(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [1 x ptr], align 8
  %status = alloca i32, align 4
  %_return_value = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 1, %1
  br i1 %cmp1, label %land.lhs.true2, label %cond.false

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %2, 1
  br i1 %cmp3, label %land.lhs.true4, label %cond.false

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %3 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %3, null
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true4
  %4 = load ptr, ptr %args.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  %5 = load ptr, ptr %args.addr, align 8
  %6 = load i64, ptr %nargs.addr, align 8
  %7 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [1 x ptr], ptr %argsbuf, i64 0, i64 0
  %call = call ptr @_PyArg_UnpackKeywords(ptr noundef %5, i64 noundef %6, ptr noundef null, ptr noundef %7, ptr noundef @os_WIFCONTINUED._parser, i32 noundef 1, i32 noundef 1, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %4, %cond.true ], [ %call, %cond.false ]
  store ptr %cond, ptr %args.addr, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  br label %exit

if.end:                                           ; preds = %cond.end
  %9 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %9, i64 0
  %10 = load ptr, ptr %arrayidx, align 8
  %call6 = call i32 @PyLong_AsInt(ptr noundef %10)
  store i32 %call6, ptr %status, align 4
  %11 = load i32, ptr %status, align 4
  %cmp7 = icmp eq i32 %11, -1
  br i1 %cmp7, label %land.lhs.true8, label %if.end12

land.lhs.true8:                                   ; preds = %if.end
  %call9 = call ptr @PyErr_Occurred()
  %tobool10 = icmp ne ptr %call9, null
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %land.lhs.true8
  br label %exit

if.end12:                                         ; preds = %land.lhs.true8, %if.end
  %12 = load ptr, ptr %module.addr, align 8
  %13 = load i32, ptr %status, align 4
  %call13 = call i32 @os_WIFCONTINUED_impl(ptr noundef %12, i32 noundef %13)
  store i32 %call13, ptr %_return_value, align 4
  %14 = load i32, ptr %_return_value, align 4
  %cmp14 = icmp eq i32 %14, -1
  br i1 %cmp14, label %land.lhs.true15, label %if.end19

land.lhs.true15:                                  ; preds = %if.end12
  %call16 = call ptr @PyErr_Occurred()
  %tobool17 = icmp ne ptr %call16, null
  br i1 %tobool17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %land.lhs.true15
  br label %exit

if.end19:                                         ; preds = %land.lhs.true15, %if.end12
  %15 = load i32, ptr %_return_value, align 4
  %conv = sext i32 %15 to i64
  %call20 = call ptr @PyBool_FromLong(i64 noundef %conv)
  store ptr %call20, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end19, %if.then18, %if.then11, %if.then
  %16 = load ptr, ptr %return_value, align 8
  ret ptr %16
}

; Function Attrs: nounwind uwtable
define internal ptr @os_WIFSTOPPED(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [1 x ptr], align 8
  %status = alloca i32, align 4
  %_return_value = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 1, %1
  br i1 %cmp1, label %land.lhs.true2, label %cond.false

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %2, 1
  br i1 %cmp3, label %land.lhs.true4, label %cond.false

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %3 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %3, null
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true4
  %4 = load ptr, ptr %args.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  %5 = load ptr, ptr %args.addr, align 8
  %6 = load i64, ptr %nargs.addr, align 8
  %7 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [1 x ptr], ptr %argsbuf, i64 0, i64 0
  %call = call ptr @_PyArg_UnpackKeywords(ptr noundef %5, i64 noundef %6, ptr noundef null, ptr noundef %7, ptr noundef @os_WIFSTOPPED._parser, i32 noundef 1, i32 noundef 1, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %4, %cond.true ], [ %call, %cond.false ]
  store ptr %cond, ptr %args.addr, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  br label %exit

if.end:                                           ; preds = %cond.end
  %9 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %9, i64 0
  %10 = load ptr, ptr %arrayidx, align 8
  %call6 = call i32 @PyLong_AsInt(ptr noundef %10)
  store i32 %call6, ptr %status, align 4
  %11 = load i32, ptr %status, align 4
  %cmp7 = icmp eq i32 %11, -1
  br i1 %cmp7, label %land.lhs.true8, label %if.end12

land.lhs.true8:                                   ; preds = %if.end
  %call9 = call ptr @PyErr_Occurred()
  %tobool10 = icmp ne ptr %call9, null
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %land.lhs.true8
  br label %exit

if.end12:                                         ; preds = %land.lhs.true8, %if.end
  %12 = load ptr, ptr %module.addr, align 8
  %13 = load i32, ptr %status, align 4
  %call13 = call i32 @os_WIFSTOPPED_impl(ptr noundef %12, i32 noundef %13)
  store i32 %call13, ptr %_return_value, align 4
  %14 = load i32, ptr %_return_value, align 4
  %cmp14 = icmp eq i32 %14, -1
  br i1 %cmp14, label %land.lhs.true15, label %if.end19

land.lhs.true15:                                  ; preds = %if.end12
  %call16 = call ptr @PyErr_Occurred()
  %tobool17 = icmp ne ptr %call16, null
  br i1 %tobool17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %land.lhs.true15
  br label %exit

if.end19:                                         ; preds = %land.lhs.true15, %if.end12
  %15 = load i32, ptr %_return_value, align 4
  %conv = sext i32 %15 to i64
  %call20 = call ptr @PyBool_FromLong(i64 noundef %conv)
  store ptr %call20, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end19, %if.then18, %if.then11, %if.then
  %16 = load ptr, ptr %return_value, align 8
  ret ptr %16
}

; Function Attrs: nounwind uwtable
define internal ptr @os_WIFSIGNALED(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [1 x ptr], align 8
  %status = alloca i32, align 4
  %_return_value = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 1, %1
  br i1 %cmp1, label %land.lhs.true2, label %cond.false

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %2, 1
  br i1 %cmp3, label %land.lhs.true4, label %cond.false

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %3 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %3, null
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true4
  %4 = load ptr, ptr %args.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  %5 = load ptr, ptr %args.addr, align 8
  %6 = load i64, ptr %nargs.addr, align 8
  %7 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [1 x ptr], ptr %argsbuf, i64 0, i64 0
  %call = call ptr @_PyArg_UnpackKeywords(ptr noundef %5, i64 noundef %6, ptr noundef null, ptr noundef %7, ptr noundef @os_WIFSIGNALED._parser, i32 noundef 1, i32 noundef 1, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %4, %cond.true ], [ %call, %cond.false ]
  store ptr %cond, ptr %args.addr, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  br label %exit

if.end:                                           ; preds = %cond.end
  %9 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %9, i64 0
  %10 = load ptr, ptr %arrayidx, align 8
  %call6 = call i32 @PyLong_AsInt(ptr noundef %10)
  store i32 %call6, ptr %status, align 4
  %11 = load i32, ptr %status, align 4
  %cmp7 = icmp eq i32 %11, -1
  br i1 %cmp7, label %land.lhs.true8, label %if.end12

land.lhs.true8:                                   ; preds = %if.end
  %call9 = call ptr @PyErr_Occurred()
  %tobool10 = icmp ne ptr %call9, null
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %land.lhs.true8
  br label %exit

if.end12:                                         ; preds = %land.lhs.true8, %if.end
  %12 = load ptr, ptr %module.addr, align 8
  %13 = load i32, ptr %status, align 4
  %call13 = call i32 @os_WIFSIGNALED_impl(ptr noundef %12, i32 noundef %13)
  store i32 %call13, ptr %_return_value, align 4
  %14 = load i32, ptr %_return_value, align 4
  %cmp14 = icmp eq i32 %14, -1
  br i1 %cmp14, label %land.lhs.true15, label %if.end19

land.lhs.true15:                                  ; preds = %if.end12
  %call16 = call ptr @PyErr_Occurred()
  %tobool17 = icmp ne ptr %call16, null
  br i1 %tobool17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %land.lhs.true15
  br label %exit

if.end19:                                         ; preds = %land.lhs.true15, %if.end12
  %15 = load i32, ptr %_return_value, align 4
  %conv = sext i32 %15 to i64
  %call20 = call ptr @PyBool_FromLong(i64 noundef %conv)
  store ptr %call20, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end19, %if.then18, %if.then11, %if.then
  %16 = load ptr, ptr %return_value, align 8
  ret ptr %16
}

; Function Attrs: nounwind uwtable
define internal ptr @os_WIFEXITED(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [1 x ptr], align 8
  %status = alloca i32, align 4
  %_return_value = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 1, %1
  br i1 %cmp1, label %land.lhs.true2, label %cond.false

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %2, 1
  br i1 %cmp3, label %land.lhs.true4, label %cond.false

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %3 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %3, null
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true4
  %4 = load ptr, ptr %args.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  %5 = load ptr, ptr %args.addr, align 8
  %6 = load i64, ptr %nargs.addr, align 8
  %7 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [1 x ptr], ptr %argsbuf, i64 0, i64 0
  %call = call ptr @_PyArg_UnpackKeywords(ptr noundef %5, i64 noundef %6, ptr noundef null, ptr noundef %7, ptr noundef @os_WIFEXITED._parser, i32 noundef 1, i32 noundef 1, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %4, %cond.true ], [ %call, %cond.false ]
  store ptr %cond, ptr %args.addr, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  br label %exit

if.end:                                           ; preds = %cond.end
  %9 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %9, i64 0
  %10 = load ptr, ptr %arrayidx, align 8
  %call6 = call i32 @PyLong_AsInt(ptr noundef %10)
  store i32 %call6, ptr %status, align 4
  %11 = load i32, ptr %status, align 4
  %cmp7 = icmp eq i32 %11, -1
  br i1 %cmp7, label %land.lhs.true8, label %if.end12

land.lhs.true8:                                   ; preds = %if.end
  %call9 = call ptr @PyErr_Occurred()
  %tobool10 = icmp ne ptr %call9, null
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %land.lhs.true8
  br label %exit

if.end12:                                         ; preds = %land.lhs.true8, %if.end
  %12 = load ptr, ptr %module.addr, align 8
  %13 = load i32, ptr %status, align 4
  %call13 = call i32 @os_WIFEXITED_impl(ptr noundef %12, i32 noundef %13)
  store i32 %call13, ptr %_return_value, align 4
  %14 = load i32, ptr %_return_value, align 4
  %cmp14 = icmp eq i32 %14, -1
  br i1 %cmp14, label %land.lhs.true15, label %if.end19

land.lhs.true15:                                  ; preds = %if.end12
  %call16 = call ptr @PyErr_Occurred()
  %tobool17 = icmp ne ptr %call16, null
  br i1 %tobool17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %land.lhs.true15
  br label %exit

if.end19:                                         ; preds = %land.lhs.true15, %if.end12
  %15 = load i32, ptr %_return_value, align 4
  %conv = sext i32 %15 to i64
  %call20 = call ptr @PyBool_FromLong(i64 noundef %conv)
  store ptr %call20, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end19, %if.then18, %if.then11, %if.then
  %16 = load ptr, ptr %return_value, align 8
  ret ptr %16
}

; Function Attrs: nounwind uwtable
define internal ptr @os_WEXITSTATUS(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [1 x ptr], align 8
  %status = alloca i32, align 4
  %_return_value = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 1, %1
  br i1 %cmp1, label %land.lhs.true2, label %cond.false

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %2, 1
  br i1 %cmp3, label %land.lhs.true4, label %cond.false

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %3 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %3, null
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true4
  %4 = load ptr, ptr %args.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  %5 = load ptr, ptr %args.addr, align 8
  %6 = load i64, ptr %nargs.addr, align 8
  %7 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [1 x ptr], ptr %argsbuf, i64 0, i64 0
  %call = call ptr @_PyArg_UnpackKeywords(ptr noundef %5, i64 noundef %6, ptr noundef null, ptr noundef %7, ptr noundef @os_WEXITSTATUS._parser, i32 noundef 1, i32 noundef 1, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %4, %cond.true ], [ %call, %cond.false ]
  store ptr %cond, ptr %args.addr, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  br label %exit

if.end:                                           ; preds = %cond.end
  %9 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %9, i64 0
  %10 = load ptr, ptr %arrayidx, align 8
  %call6 = call i32 @PyLong_AsInt(ptr noundef %10)
  store i32 %call6, ptr %status, align 4
  %11 = load i32, ptr %status, align 4
  %cmp7 = icmp eq i32 %11, -1
  br i1 %cmp7, label %land.lhs.true8, label %if.end12

land.lhs.true8:                                   ; preds = %if.end
  %call9 = call ptr @PyErr_Occurred()
  %tobool10 = icmp ne ptr %call9, null
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %land.lhs.true8
  br label %exit

if.end12:                                         ; preds = %land.lhs.true8, %if.end
  %12 = load ptr, ptr %module.addr, align 8
  %13 = load i32, ptr %status, align 4
  %call13 = call i32 @os_WEXITSTATUS_impl(ptr noundef %12, i32 noundef %13)
  store i32 %call13, ptr %_return_value, align 4
  %14 = load i32, ptr %_return_value, align 4
  %cmp14 = icmp eq i32 %14, -1
  br i1 %cmp14, label %land.lhs.true15, label %if.end19

land.lhs.true15:                                  ; preds = %if.end12
  %call16 = call ptr @PyErr_Occurred()
  %tobool17 = icmp ne ptr %call16, null
  br i1 %tobool17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %land.lhs.true15
  br label %exit

if.end19:                                         ; preds = %land.lhs.true15, %if.end12
  %15 = load i32, ptr %_return_value, align 4
  %conv = sext i32 %15 to i64
  %call20 = call ptr @PyLong_FromLong(i64 noundef %conv)
  store ptr %call20, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end19, %if.then18, %if.then11, %if.then
  %16 = load ptr, ptr %return_value, align 8
  ret ptr %16
}

; Function Attrs: nounwind uwtable
define internal ptr @os_WTERMSIG(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [1 x ptr], align 8
  %status = alloca i32, align 4
  %_return_value = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 1, %1
  br i1 %cmp1, label %land.lhs.true2, label %cond.false

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %2, 1
  br i1 %cmp3, label %land.lhs.true4, label %cond.false

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %3 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %3, null
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true4
  %4 = load ptr, ptr %args.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  %5 = load ptr, ptr %args.addr, align 8
  %6 = load i64, ptr %nargs.addr, align 8
  %7 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [1 x ptr], ptr %argsbuf, i64 0, i64 0
  %call = call ptr @_PyArg_UnpackKeywords(ptr noundef %5, i64 noundef %6, ptr noundef null, ptr noundef %7, ptr noundef @os_WTERMSIG._parser, i32 noundef 1, i32 noundef 1, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %4, %cond.true ], [ %call, %cond.false ]
  store ptr %cond, ptr %args.addr, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  br label %exit

if.end:                                           ; preds = %cond.end
  %9 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %9, i64 0
  %10 = load ptr, ptr %arrayidx, align 8
  %call6 = call i32 @PyLong_AsInt(ptr noundef %10)
  store i32 %call6, ptr %status, align 4
  %11 = load i32, ptr %status, align 4
  %cmp7 = icmp eq i32 %11, -1
  br i1 %cmp7, label %land.lhs.true8, label %if.end12

land.lhs.true8:                                   ; preds = %if.end
  %call9 = call ptr @PyErr_Occurred()
  %tobool10 = icmp ne ptr %call9, null
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %land.lhs.true8
  br label %exit

if.end12:                                         ; preds = %land.lhs.true8, %if.end
  %12 = load ptr, ptr %module.addr, align 8
  %13 = load i32, ptr %status, align 4
  %call13 = call i32 @os_WTERMSIG_impl(ptr noundef %12, i32 noundef %13)
  store i32 %call13, ptr %_return_value, align 4
  %14 = load i32, ptr %_return_value, align 4
  %cmp14 = icmp eq i32 %14, -1
  br i1 %cmp14, label %land.lhs.true15, label %if.end19

land.lhs.true15:                                  ; preds = %if.end12
  %call16 = call ptr @PyErr_Occurred()
  %tobool17 = icmp ne ptr %call16, null
  br i1 %tobool17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %land.lhs.true15
  br label %exit

if.end19:                                         ; preds = %land.lhs.true15, %if.end12
  %15 = load i32, ptr %_return_value, align 4
  %conv = sext i32 %15 to i64
  %call20 = call ptr @PyLong_FromLong(i64 noundef %conv)
  store ptr %call20, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end19, %if.then18, %if.then11, %if.then
  %16 = load ptr, ptr %return_value, align 8
  ret ptr %16
}

; Function Attrs: nounwind uwtable
define internal ptr @os_WSTOPSIG(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [1 x ptr], align 8
  %status = alloca i32, align 4
  %_return_value = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 1, %1
  br i1 %cmp1, label %land.lhs.true2, label %cond.false

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %2, 1
  br i1 %cmp3, label %land.lhs.true4, label %cond.false

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %3 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %3, null
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true4
  %4 = load ptr, ptr %args.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  %5 = load ptr, ptr %args.addr, align 8
  %6 = load i64, ptr %nargs.addr, align 8
  %7 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [1 x ptr], ptr %argsbuf, i64 0, i64 0
  %call = call ptr @_PyArg_UnpackKeywords(ptr noundef %5, i64 noundef %6, ptr noundef null, ptr noundef %7, ptr noundef @os_WSTOPSIG._parser, i32 noundef 1, i32 noundef 1, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %4, %cond.true ], [ %call, %cond.false ]
  store ptr %cond, ptr %args.addr, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  br label %exit

if.end:                                           ; preds = %cond.end
  %9 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %9, i64 0
  %10 = load ptr, ptr %arrayidx, align 8
  %call6 = call i32 @PyLong_AsInt(ptr noundef %10)
  store i32 %call6, ptr %status, align 4
  %11 = load i32, ptr %status, align 4
  %cmp7 = icmp eq i32 %11, -1
  br i1 %cmp7, label %land.lhs.true8, label %if.end12

land.lhs.true8:                                   ; preds = %if.end
  %call9 = call ptr @PyErr_Occurred()
  %tobool10 = icmp ne ptr %call9, null
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %land.lhs.true8
  br label %exit

if.end12:                                         ; preds = %land.lhs.true8, %if.end
  %12 = load ptr, ptr %module.addr, align 8
  %13 = load i32, ptr %status, align 4
  %call13 = call i32 @os_WSTOPSIG_impl(ptr noundef %12, i32 noundef %13)
  store i32 %call13, ptr %_return_value, align 4
  %14 = load i32, ptr %_return_value, align 4
  %cmp14 = icmp eq i32 %14, -1
  br i1 %cmp14, label %land.lhs.true15, label %if.end19

land.lhs.true15:                                  ; preds = %if.end12
  %call16 = call ptr @PyErr_Occurred()
  %tobool17 = icmp ne ptr %call16, null
  br i1 %tobool17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %land.lhs.true15
  br label %exit

if.end19:                                         ; preds = %land.lhs.true15, %if.end12
  %15 = load i32, ptr %_return_value, align 4
  %conv = sext i32 %15 to i64
  %call20 = call ptr @PyLong_FromLong(i64 noundef %conv)
  store ptr %call20, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end19, %if.then18, %if.then11, %if.then
  %16 = load ptr, ptr %return_value, align 8
  ret ptr %16
}

; Function Attrs: nounwind uwtable
define internal ptr @os_fstatvfs(ptr noundef %module, ptr noundef %arg) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %fd = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %call = call i32 @PyLong_AsInt(ptr noundef %0)
  store i32 %call, ptr %fd, align 4
  %1 = load i32, ptr %fd, align 4
  %cmp = icmp eq i32 %1, -1
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %call1 = call ptr @PyErr_Occurred()
  %tobool = icmp ne ptr %call1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  br label %exit

if.end:                                           ; preds = %land.lhs.true, %entry
  %2 = load ptr, ptr %module.addr, align 8
  %3 = load i32, ptr %fd, align 4
  %call2 = call ptr @os_fstatvfs_impl(ptr noundef %2, i32 noundef %3)
  store ptr %call2, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end, %if.then
  %4 = load ptr, ptr %return_value, align 8
  ret ptr %4
}

; Function Attrs: nounwind uwtable
define internal ptr @os_statvfs(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [1 x ptr], align 8
  %path = alloca %struct.path_t, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %path, ptr align 8 @__const.os_statvfs.path, i64 72, i1 false)
  %0 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 1, %1
  br i1 %cmp1, label %land.lhs.true2, label %cond.false

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %2, 1
  br i1 %cmp3, label %land.lhs.true4, label %cond.false

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %3 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %3, null
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true4
  %4 = load ptr, ptr %args.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  %5 = load ptr, ptr %args.addr, align 8
  %6 = load i64, ptr %nargs.addr, align 8
  %7 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [1 x ptr], ptr %argsbuf, i64 0, i64 0
  %call = call ptr @_PyArg_UnpackKeywords(ptr noundef %5, i64 noundef %6, ptr noundef null, ptr noundef %7, ptr noundef @os_statvfs._parser, i32 noundef 1, i32 noundef 1, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %4, %cond.true ], [ %call, %cond.false ]
  store ptr %cond, ptr %args.addr, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  br label %exit

if.end:                                           ; preds = %cond.end
  %9 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %9, i64 0
  %10 = load ptr, ptr %arrayidx, align 8
  %call6 = call i32 @path_converter(ptr noundef %10, ptr noundef %path)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %if.end
  br label %exit

if.end9:                                          ; preds = %if.end
  %11 = load ptr, ptr %module.addr, align 8
  %call10 = call ptr @os_statvfs_impl(ptr noundef %11, ptr noundef %path)
  store ptr %call10, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end9, %if.then8, %if.then
  call void @path_cleanup(ptr noundef %path)
  %12 = load ptr, ptr %return_value, align 8
  ret ptr %12
}

; Function Attrs: nounwind uwtable
define internal ptr @os_confstr(ptr noundef %module, ptr noundef %arg) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %name = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %call = call i32 @conv_confstr_confname(ptr noundef %0, ptr noundef %name)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %exit

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %module.addr, align 8
  %2 = load i32, ptr %name, align 4
  %call1 = call ptr @os_confstr_impl(ptr noundef %1, i32 noundef %2)
  store ptr %call1, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end, %if.then
  %3 = load ptr, ptr %return_value, align 8
  ret ptr %3
}

; Function Attrs: nounwind uwtable
define internal ptr @os_sysconf(ptr noundef %module, ptr noundef %arg) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %name = alloca i32, align 4
  %_return_value = alloca i64, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %call = call i32 @conv_sysconf_confname(ptr noundef %0, ptr noundef %name)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %exit

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %module.addr, align 8
  %2 = load i32, ptr %name, align 4
  %call1 = call i64 @os_sysconf_impl(ptr noundef %1, i32 noundef %2)
  store i64 %call1, ptr %_return_value, align 8
  %3 = load i64, ptr %_return_value, align 8
  %cmp = icmp eq i64 %3, -1
  br i1 %cmp, label %land.lhs.true, label %if.end5

land.lhs.true:                                    ; preds = %if.end
  %call2 = call ptr @PyErr_Occurred()
  %tobool3 = icmp ne ptr %call2, null
  br i1 %tobool3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %land.lhs.true
  br label %exit

if.end5:                                          ; preds = %land.lhs.true, %if.end
  %4 = load i64, ptr %_return_value, align 8
  %call6 = call ptr @PyLong_FromLong(i64 noundef %4)
  store ptr %call6, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end5, %if.then4, %if.then
  %5 = load ptr, ptr %return_value, align 8
  ret ptr %5
}

; Function Attrs: nounwind uwtable
define internal ptr @os_fpathconf(ptr noundef %module, ptr noundef %args, i64 noundef %nargs) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %return_value = alloca ptr, align 8
  %fd = alloca i32, align 4
  %name = alloca i32, align 4
  %_return_value = alloca i64, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %cmp = icmp sle i64 2, %0
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 %1, 2
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %2 = load i64, ptr %nargs.addr, align 8
  %call = call i32 @_PyArg_CheckPositional(ptr noundef @.str.148, i64 noundef %2, i64 noundef 2, i64 noundef 2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false
  br label %exit

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %3 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %3, i64 0
  %4 = load ptr, ptr %arrayidx, align 8
  %call2 = call i32 @_PyLong_FileDescriptor_Converter(ptr noundef %4, ptr noundef %fd)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.end
  br label %exit

if.end5:                                          ; preds = %if.end
  %5 = load ptr, ptr %args.addr, align 8
  %arrayidx6 = getelementptr ptr, ptr %5, i64 1
  %6 = load ptr, ptr %arrayidx6, align 8
  %call7 = call i32 @conv_path_confname(ptr noundef %6, ptr noundef %name)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end10, label %if.then9

if.then9:                                         ; preds = %if.end5
  br label %exit

if.end10:                                         ; preds = %if.end5
  %7 = load ptr, ptr %module.addr, align 8
  %8 = load i32, ptr %fd, align 4
  %9 = load i32, ptr %name, align 4
  %call11 = call i64 @os_fpathconf_impl(ptr noundef %7, i32 noundef %8, i32 noundef %9)
  store i64 %call11, ptr %_return_value, align 8
  %10 = load i64, ptr %_return_value, align 8
  %cmp12 = icmp eq i64 %10, -1
  br i1 %cmp12, label %land.lhs.true13, label %if.end17

land.lhs.true13:                                  ; preds = %if.end10
  %call14 = call ptr @PyErr_Occurred()
  %tobool15 = icmp ne ptr %call14, null
  br i1 %tobool15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %land.lhs.true13
  br label %exit

if.end17:                                         ; preds = %land.lhs.true13, %if.end10
  %11 = load i64, ptr %_return_value, align 8
  %call18 = call ptr @PyLong_FromLong(i64 noundef %11)
  store ptr %call18, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end17, %if.then16, %if.then9, %if.then4, %if.then
  %12 = load ptr, ptr %return_value, align 8
  ret ptr %12
}

; Function Attrs: nounwind uwtable
define internal ptr @os_pathconf(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [2 x ptr], align 16
  %path = alloca %struct.path_t, align 8
  %name = alloca i32, align 4
  %_return_value = alloca i64, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %path, ptr align 8 @__const.os_pathconf.path, i64 72, i1 false)
  %0 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 2, %1
  br i1 %cmp1, label %land.lhs.true2, label %cond.false

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %2, 2
  br i1 %cmp3, label %land.lhs.true4, label %cond.false

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %3 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %3, null
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true4
  %4 = load ptr, ptr %args.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  %5 = load ptr, ptr %args.addr, align 8
  %6 = load i64, ptr %nargs.addr, align 8
  %7 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [2 x ptr], ptr %argsbuf, i64 0, i64 0
  %call = call ptr @_PyArg_UnpackKeywords(ptr noundef %5, i64 noundef %6, ptr noundef null, ptr noundef %7, ptr noundef @os_pathconf._parser, i32 noundef 2, i32 noundef 2, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %4, %cond.true ], [ %call, %cond.false ]
  store ptr %cond, ptr %args.addr, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  br label %exit

if.end:                                           ; preds = %cond.end
  %9 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %9, i64 0
  %10 = load ptr, ptr %arrayidx, align 8
  %call6 = call i32 @path_converter(ptr noundef %10, ptr noundef %path)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %if.end
  br label %exit

if.end9:                                          ; preds = %if.end
  %11 = load ptr, ptr %args.addr, align 8
  %arrayidx10 = getelementptr ptr, ptr %11, i64 1
  %12 = load ptr, ptr %arrayidx10, align 8
  %call11 = call i32 @conv_path_confname(ptr noundef %12, ptr noundef %name)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %if.end14, label %if.then13

if.then13:                                        ; preds = %if.end9
  br label %exit

if.end14:                                         ; preds = %if.end9
  %13 = load ptr, ptr %module.addr, align 8
  %14 = load i32, ptr %name, align 4
  %call15 = call i64 @os_pathconf_impl(ptr noundef %13, ptr noundef %path, i32 noundef %14)
  store i64 %call15, ptr %_return_value, align 8
  %15 = load i64, ptr %_return_value, align 8
  %cmp16 = icmp eq i64 %15, -1
  br i1 %cmp16, label %land.lhs.true17, label %if.end21

land.lhs.true17:                                  ; preds = %if.end14
  %call18 = call ptr @PyErr_Occurred()
  %tobool19 = icmp ne ptr %call18, null
  br i1 %tobool19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %land.lhs.true17
  br label %exit

if.end21:                                         ; preds = %land.lhs.true17, %if.end14
  %16 = load i64, ptr %_return_value, align 8
  %call22 = call ptr @PyLong_FromLong(i64 noundef %16)
  store ptr %call22, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end21, %if.then20, %if.then13, %if.then8, %if.then
  call void @path_cleanup(ptr noundef %path)
  %17 = load ptr, ptr %return_value, align 8
  ret ptr %17
}

; Function Attrs: nounwind uwtable
define internal ptr @os_abort(ptr noundef %module, ptr noundef %_unused_ignored) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %call = call ptr @os_abort_impl(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @os__path_normpath(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [1 x ptr], align 8
  %path = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 1, %1
  br i1 %cmp1, label %land.lhs.true2, label %cond.false

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %2, 1
  br i1 %cmp3, label %land.lhs.true4, label %cond.false

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %3 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %3, null
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true4
  %4 = load ptr, ptr %args.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  %5 = load ptr, ptr %args.addr, align 8
  %6 = load i64, ptr %nargs.addr, align 8
  %7 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [1 x ptr], ptr %argsbuf, i64 0, i64 0
  %call = call ptr @_PyArg_UnpackKeywords(ptr noundef %5, i64 noundef %6, ptr noundef null, ptr noundef %7, ptr noundef @os__path_normpath._parser, i32 noundef 1, i32 noundef 1, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %4, %cond.true ], [ %call, %cond.false ]
  store ptr %cond, ptr %args.addr, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  br label %exit

if.end:                                           ; preds = %cond.end
  %9 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %9, i64 0
  %10 = load ptr, ptr %arrayidx, align 8
  store ptr %10, ptr %path, align 8
  %11 = load ptr, ptr %module.addr, align 8
  %12 = load ptr, ptr %path, align 8
  %call6 = call ptr @os__path_normpath_impl(ptr noundef %11, ptr noundef %12)
  store ptr %call6, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end, %if.then
  %13 = load ptr, ptr %return_value, align 8
  ret ptr %13
}

; Function Attrs: nounwind uwtable
define internal ptr @os_getloadavg(ptr noundef %module, ptr noundef %_unused_ignored) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %call = call ptr @os_getloadavg_impl(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @os_urandom(ptr noundef %module, ptr noundef %arg) #0 {
entry:
  %op.addr.i7 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %size = alloca i64, align 8
  %ival = alloca i64, align 8
  %iobj = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr null, ptr %return_value, align 8
  store i64 -1, ptr %ival, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %call = call ptr @_PyNumber_Index(ptr noundef %0)
  store ptr %call, ptr %iobj, align 8
  %1 = load ptr, ptr %iobj, align 8
  %cmp = icmp ne ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %iobj, align 8
  %call1 = call i64 @PyLong_AsSsize_t(ptr noundef %2)
  store i64 %call1, ptr %ival, align 8
  %3 = load ptr, ptr %iobj, align 8
  store ptr %3, ptr %op.addr.i, align 8
  %4 = load ptr, ptr %op.addr.i, align 8
  store ptr %4, ptr %op.addr.i7, align 8
  %5 = load ptr, ptr %op.addr.i7, align 8
  %6 = load i64, ptr %5, align 8
  %conv.i = trunc i64 %6 to i32
  %cmp.i8 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i8 to i32
  %tobool.i = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.then
  %7 = load ptr, ptr %op.addr.i, align 8
  %8 = load i64, ptr %7, align 8
  %dec.i = add i64 %8, -1
  store i64 %dec.i, ptr %7, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %9 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %9) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  br label %if.end

if.end:                                           ; preds = %Py_DECREF.exit, %entry
  %10 = load i64, ptr %ival, align 8
  %cmp2 = icmp eq i64 %10, -1
  br i1 %cmp2, label %land.lhs.true, label %if.end5

land.lhs.true:                                    ; preds = %if.end
  %call3 = call ptr @PyErr_Occurred()
  %tobool = icmp ne ptr %call3, null
  br i1 %tobool, label %if.then4, label %if.end5

if.then4:                                         ; preds = %land.lhs.true
  br label %exit

if.end5:                                          ; preds = %land.lhs.true, %if.end
  %11 = load i64, ptr %ival, align 8
  store i64 %11, ptr %size, align 8
  %12 = load ptr, ptr %module.addr, align 8
  %13 = load i64, ptr %size, align 8
  %call6 = call ptr @os_urandom_impl(ptr noundef %12, i64 noundef %13)
  store ptr %call6, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end5, %if.then4
  %14 = load ptr, ptr %return_value, align 8
  ret ptr %14
}

; Function Attrs: nounwind uwtable
define internal ptr @os_setresuid(ptr noundef %module, ptr noundef %args, i64 noundef %nargs) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %return_value = alloca ptr, align 8
  %ruid = alloca i32, align 4
  %euid = alloca i32, align 4
  %suid = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %cmp = icmp sle i64 3, %0
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 %1, 3
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %2 = load i64, ptr %nargs.addr, align 8
  %call = call i32 @_PyArg_CheckPositional(ptr noundef @.str.154, i64 noundef %2, i64 noundef 3, i64 noundef 3)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false
  br label %exit

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %3 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %3, i64 0
  %4 = load ptr, ptr %arrayidx, align 8
  %call2 = call i32 @_Py_Uid_Converter(ptr noundef %4, ptr noundef %ruid)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.end
  br label %exit

if.end5:                                          ; preds = %if.end
  %5 = load ptr, ptr %args.addr, align 8
  %arrayidx6 = getelementptr ptr, ptr %5, i64 1
  %6 = load ptr, ptr %arrayidx6, align 8
  %call7 = call i32 @_Py_Uid_Converter(ptr noundef %6, ptr noundef %euid)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end10, label %if.then9

if.then9:                                         ; preds = %if.end5
  br label %exit

if.end10:                                         ; preds = %if.end5
  %7 = load ptr, ptr %args.addr, align 8
  %arrayidx11 = getelementptr ptr, ptr %7, i64 2
  %8 = load ptr, ptr %arrayidx11, align 8
  %call12 = call i32 @_Py_Uid_Converter(ptr noundef %8, ptr noundef %suid)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end10
  br label %exit

if.end15:                                         ; preds = %if.end10
  %9 = load ptr, ptr %module.addr, align 8
  %10 = load i32, ptr %ruid, align 4
  %11 = load i32, ptr %euid, align 4
  %12 = load i32, ptr %suid, align 4
  %call16 = call ptr @os_setresuid_impl(ptr noundef %9, i32 noundef %10, i32 noundef %11, i32 noundef %12)
  store ptr %call16, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end15, %if.then14, %if.then9, %if.then4, %if.then
  %13 = load ptr, ptr %return_value, align 8
  ret ptr %13
}

; Function Attrs: nounwind uwtable
define internal ptr @os_setresgid(ptr noundef %module, ptr noundef %args, i64 noundef %nargs) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %return_value = alloca ptr, align 8
  %rgid = alloca i32, align 4
  %egid = alloca i32, align 4
  %sgid = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %cmp = icmp sle i64 3, %0
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 %1, 3
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %2 = load i64, ptr %nargs.addr, align 8
  %call = call i32 @_PyArg_CheckPositional(ptr noundef @.str.155, i64 noundef %2, i64 noundef 3, i64 noundef 3)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false
  br label %exit

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %3 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %3, i64 0
  %4 = load ptr, ptr %arrayidx, align 8
  %call2 = call i32 @_Py_Gid_Converter(ptr noundef %4, ptr noundef %rgid)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.end
  br label %exit

if.end5:                                          ; preds = %if.end
  %5 = load ptr, ptr %args.addr, align 8
  %arrayidx6 = getelementptr ptr, ptr %5, i64 1
  %6 = load ptr, ptr %arrayidx6, align 8
  %call7 = call i32 @_Py_Gid_Converter(ptr noundef %6, ptr noundef %egid)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end10, label %if.then9

if.then9:                                         ; preds = %if.end5
  br label %exit

if.end10:                                         ; preds = %if.end5
  %7 = load ptr, ptr %args.addr, align 8
  %arrayidx11 = getelementptr ptr, ptr %7, i64 2
  %8 = load ptr, ptr %arrayidx11, align 8
  %call12 = call i32 @_Py_Gid_Converter(ptr noundef %8, ptr noundef %sgid)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end10
  br label %exit

if.end15:                                         ; preds = %if.end10
  %9 = load ptr, ptr %module.addr, align 8
  %10 = load i32, ptr %rgid, align 4
  %11 = load i32, ptr %egid, align 4
  %12 = load i32, ptr %sgid, align 4
  %call16 = call ptr @os_setresgid_impl(ptr noundef %9, i32 noundef %10, i32 noundef %11, i32 noundef %12)
  store ptr %call16, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end15, %if.then14, %if.then9, %if.then4, %if.then
  %13 = load ptr, ptr %return_value, align 8
  ret ptr %13
}

; Function Attrs: nounwind uwtable
define internal ptr @os_getresuid(ptr noundef %module, ptr noundef %_unused_ignored) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %call = call ptr @os_getresuid_impl(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @os_getresgid(ptr noundef %module, ptr noundef %_unused_ignored) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %call = call ptr @os_getresgid_impl(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @os_getxattr(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [3 x ptr], align 16
  %noptargs = alloca i64, align 8
  %path = alloca %struct.path_t, align 8
  %attribute = alloca %struct.path_t, align 8
  %follow_symlinks = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 2
  store i64 %sub, ptr %noptargs, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %path, ptr align 8 @__const.os_getxattr.path, i64 72, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %attribute, ptr align 8 @__const.os_getxattr.attribute, i64 72, i1 false)
  store i32 1, ptr %follow_symlinks, align 4
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 2, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 2
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [3 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @os_getxattr._parser, i32 noundef 2, i32 noundef 2, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %12, i64 0
  %13 = load ptr, ptr %arrayidx, align 8
  %call12 = call i32 @path_converter(ptr noundef %13, ptr noundef %path)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end
  br label %exit

if.end15:                                         ; preds = %if.end
  %14 = load ptr, ptr %args.addr, align 8
  %arrayidx16 = getelementptr ptr, ptr %14, i64 1
  %15 = load ptr, ptr %arrayidx16, align 8
  %call17 = call i32 @path_converter(ptr noundef %15, ptr noundef %attribute)
  %tobool18 = icmp ne i32 %call17, 0
  br i1 %tobool18, label %if.end20, label %if.then19

if.then19:                                        ; preds = %if.end15
  br label %exit

if.end20:                                         ; preds = %if.end15
  %16 = load i64, ptr %noptargs, align 8
  %tobool21 = icmp ne i64 %16, 0
  br i1 %tobool21, label %if.end23, label %if.then22

if.then22:                                        ; preds = %if.end20
  br label %skip_optional_kwonly

if.end23:                                         ; preds = %if.end20
  %17 = load ptr, ptr %args.addr, align 8
  %arrayidx24 = getelementptr ptr, ptr %17, i64 2
  %18 = load ptr, ptr %arrayidx24, align 8
  %call25 = call i32 @PyObject_IsTrue(ptr noundef %18)
  store i32 %call25, ptr %follow_symlinks, align 4
  %19 = load i32, ptr %follow_symlinks, align 4
  %cmp26 = icmp slt i32 %19, 0
  br i1 %cmp26, label %if.then27, label %if.end28

if.then27:                                        ; preds = %if.end23
  br label %exit

if.end28:                                         ; preds = %if.end23
  br label %skip_optional_kwonly

skip_optional_kwonly:                             ; preds = %if.end28, %if.then22
  %20 = load ptr, ptr %module.addr, align 8
  %21 = load i32, ptr %follow_symlinks, align 4
  %call29 = call ptr @os_getxattr_impl(ptr noundef %20, ptr noundef %path, ptr noundef %attribute, i32 noundef %21)
  store ptr %call29, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional_kwonly, %if.then27, %if.then19, %if.then14, %if.then
  call void @path_cleanup(ptr noundef %path)
  call void @path_cleanup(ptr noundef %attribute)
  %22 = load ptr, ptr %return_value, align 8
  ret ptr %22
}

; Function Attrs: nounwind uwtable
define internal ptr @os_setxattr(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [5 x ptr], align 16
  %noptargs = alloca i64, align 8
  %path = alloca %struct.path_t, align 8
  %attribute = alloca %struct.path_t, align 8
  %value = alloca %struct.Py_buffer, align 8
  %flags = alloca i32, align 4
  %follow_symlinks = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 3
  store i64 %sub, ptr %noptargs, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %path, ptr align 8 @__const.os_setxattr.path, i64 72, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %attribute, ptr align 8 @__const.os_setxattr.attribute, i64 72, i1 false)
  call void @llvm.memset.p0.i64(ptr align 8 %value, i8 0, i64 80, i1 false)
  store i32 0, ptr %flags, align 4
  store i32 1, ptr %follow_symlinks, align 4
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 3, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 4
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [5 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @os_setxattr._parser, i32 noundef 3, i32 noundef 4, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %12, i64 0
  %13 = load ptr, ptr %arrayidx, align 8
  %call12 = call i32 @path_converter(ptr noundef %13, ptr noundef %path)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end
  br label %exit

if.end15:                                         ; preds = %if.end
  %14 = load ptr, ptr %args.addr, align 8
  %arrayidx16 = getelementptr ptr, ptr %14, i64 1
  %15 = load ptr, ptr %arrayidx16, align 8
  %call17 = call i32 @path_converter(ptr noundef %15, ptr noundef %attribute)
  %tobool18 = icmp ne i32 %call17, 0
  br i1 %tobool18, label %if.end20, label %if.then19

if.then19:                                        ; preds = %if.end15
  br label %exit

if.end20:                                         ; preds = %if.end15
  %16 = load ptr, ptr %args.addr, align 8
  %arrayidx21 = getelementptr ptr, ptr %16, i64 2
  %17 = load ptr, ptr %arrayidx21, align 8
  %call22 = call i32 @PyObject_GetBuffer(ptr noundef %17, ptr noundef %value, i32 noundef 0)
  %cmp23 = icmp ne i32 %call22, 0
  br i1 %cmp23, label %if.then24, label %if.end25

if.then24:                                        ; preds = %if.end20
  br label %exit

if.end25:                                         ; preds = %if.end20
  %18 = load i64, ptr %noptargs, align 8
  %tobool26 = icmp ne i64 %18, 0
  br i1 %tobool26, label %if.end28, label %if.then27

if.then27:                                        ; preds = %if.end25
  br label %skip_optional_pos

if.end28:                                         ; preds = %if.end25
  %19 = load ptr, ptr %args.addr, align 8
  %arrayidx29 = getelementptr ptr, ptr %19, i64 3
  %20 = load ptr, ptr %arrayidx29, align 8
  %tobool30 = icmp ne ptr %20, null
  br i1 %tobool30, label %if.then31, label %if.end43

if.then31:                                        ; preds = %if.end28
  %21 = load ptr, ptr %args.addr, align 8
  %arrayidx32 = getelementptr ptr, ptr %21, i64 3
  %22 = load ptr, ptr %arrayidx32, align 8
  %call33 = call i32 @PyLong_AsInt(ptr noundef %22)
  store i32 %call33, ptr %flags, align 4
  %23 = load i32, ptr %flags, align 4
  %cmp34 = icmp eq i32 %23, -1
  br i1 %cmp34, label %land.lhs.true35, label %if.end39

land.lhs.true35:                                  ; preds = %if.then31
  %call36 = call ptr @PyErr_Occurred()
  %tobool37 = icmp ne ptr %call36, null
  br i1 %tobool37, label %if.then38, label %if.end39

if.then38:                                        ; preds = %land.lhs.true35
  br label %exit

if.end39:                                         ; preds = %land.lhs.true35, %if.then31
  %24 = load i64, ptr %noptargs, align 8
  %dec = add i64 %24, -1
  store i64 %dec, ptr %noptargs, align 8
  %tobool40 = icmp ne i64 %dec, 0
  br i1 %tobool40, label %if.end42, label %if.then41

if.then41:                                        ; preds = %if.end39
  br label %skip_optional_pos

if.end42:                                         ; preds = %if.end39
  br label %if.end43

if.end43:                                         ; preds = %if.end42, %if.end28
  br label %skip_optional_pos

skip_optional_pos:                                ; preds = %if.end43, %if.then41, %if.then27
  %25 = load i64, ptr %noptargs, align 8
  %tobool44 = icmp ne i64 %25, 0
  br i1 %tobool44, label %if.end46, label %if.then45

if.then45:                                        ; preds = %skip_optional_pos
  br label %skip_optional_kwonly

if.end46:                                         ; preds = %skip_optional_pos
  %26 = load ptr, ptr %args.addr, align 8
  %arrayidx47 = getelementptr ptr, ptr %26, i64 4
  %27 = load ptr, ptr %arrayidx47, align 8
  %call48 = call i32 @PyObject_IsTrue(ptr noundef %27)
  store i32 %call48, ptr %follow_symlinks, align 4
  %28 = load i32, ptr %follow_symlinks, align 4
  %cmp49 = icmp slt i32 %28, 0
  br i1 %cmp49, label %if.then50, label %if.end51

if.then50:                                        ; preds = %if.end46
  br label %exit

if.end51:                                         ; preds = %if.end46
  br label %skip_optional_kwonly

skip_optional_kwonly:                             ; preds = %if.end51, %if.then45
  %29 = load ptr, ptr %module.addr, align 8
  %30 = load i32, ptr %flags, align 4
  %31 = load i32, ptr %follow_symlinks, align 4
  %call52 = call ptr @os_setxattr_impl(ptr noundef %29, ptr noundef %path, ptr noundef %attribute, ptr noundef %value, i32 noundef %30, i32 noundef %31)
  store ptr %call52, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional_kwonly, %if.then50, %if.then38, %if.then24, %if.then19, %if.then14, %if.then
  call void @path_cleanup(ptr noundef %path)
  call void @path_cleanup(ptr noundef %attribute)
  %obj = getelementptr inbounds %struct.Py_buffer, ptr %value, i32 0, i32 1
  %32 = load ptr, ptr %obj, align 8
  %tobool53 = icmp ne ptr %32, null
  br i1 %tobool53, label %if.then54, label %if.end55

if.then54:                                        ; preds = %exit
  call void @PyBuffer_Release(ptr noundef %value)
  br label %if.end55

if.end55:                                         ; preds = %if.then54, %exit
  %33 = load ptr, ptr %return_value, align 8
  ret ptr %33
}

; Function Attrs: nounwind uwtable
define internal ptr @os_removexattr(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [3 x ptr], align 16
  %noptargs = alloca i64, align 8
  %path = alloca %struct.path_t, align 8
  %attribute = alloca %struct.path_t, align 8
  %follow_symlinks = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 2
  store i64 %sub, ptr %noptargs, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %path, ptr align 8 @__const.os_removexattr.path, i64 72, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %attribute, ptr align 8 @__const.os_removexattr.attribute, i64 72, i1 false)
  store i32 1, ptr %follow_symlinks, align 4
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 2, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 2
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [3 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @os_removexattr._parser, i32 noundef 2, i32 noundef 2, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %12, i64 0
  %13 = load ptr, ptr %arrayidx, align 8
  %call12 = call i32 @path_converter(ptr noundef %13, ptr noundef %path)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end
  br label %exit

if.end15:                                         ; preds = %if.end
  %14 = load ptr, ptr %args.addr, align 8
  %arrayidx16 = getelementptr ptr, ptr %14, i64 1
  %15 = load ptr, ptr %arrayidx16, align 8
  %call17 = call i32 @path_converter(ptr noundef %15, ptr noundef %attribute)
  %tobool18 = icmp ne i32 %call17, 0
  br i1 %tobool18, label %if.end20, label %if.then19

if.then19:                                        ; preds = %if.end15
  br label %exit

if.end20:                                         ; preds = %if.end15
  %16 = load i64, ptr %noptargs, align 8
  %tobool21 = icmp ne i64 %16, 0
  br i1 %tobool21, label %if.end23, label %if.then22

if.then22:                                        ; preds = %if.end20
  br label %skip_optional_kwonly

if.end23:                                         ; preds = %if.end20
  %17 = load ptr, ptr %args.addr, align 8
  %arrayidx24 = getelementptr ptr, ptr %17, i64 2
  %18 = load ptr, ptr %arrayidx24, align 8
  %call25 = call i32 @PyObject_IsTrue(ptr noundef %18)
  store i32 %call25, ptr %follow_symlinks, align 4
  %19 = load i32, ptr %follow_symlinks, align 4
  %cmp26 = icmp slt i32 %19, 0
  br i1 %cmp26, label %if.then27, label %if.end28

if.then27:                                        ; preds = %if.end23
  br label %exit

if.end28:                                         ; preds = %if.end23
  br label %skip_optional_kwonly

skip_optional_kwonly:                             ; preds = %if.end28, %if.then22
  %20 = load ptr, ptr %module.addr, align 8
  %21 = load i32, ptr %follow_symlinks, align 4
  %call29 = call ptr @os_removexattr_impl(ptr noundef %20, ptr noundef %path, ptr noundef %attribute, i32 noundef %21)
  store ptr %call29, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional_kwonly, %if.then27, %if.then19, %if.then14, %if.then
  call void @path_cleanup(ptr noundef %path)
  call void @path_cleanup(ptr noundef %attribute)
  %22 = load ptr, ptr %return_value, align 8
  ret ptr %22
}

; Function Attrs: nounwind uwtable
define internal ptr @os_listxattr(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [2 x ptr], align 16
  %noptargs = alloca i64, align 8
  %path = alloca %struct.path_t, align 8
  %follow_symlinks = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 0
  store i64 %sub, ptr %noptargs, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %path, ptr align 8 @__const.os_listxattr.path, i64 72, i1 false)
  store i32 1, ptr %follow_symlinks, align 4
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 0, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 1
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [2 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @os_listxattr._parser, i32 noundef 0, i32 noundef 1, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load i64, ptr %noptargs, align 8
  %tobool12 = icmp ne i64 %12, 0
  br i1 %tobool12, label %if.end14, label %if.then13

if.then13:                                        ; preds = %if.end
  br label %skip_optional_pos

if.end14:                                         ; preds = %if.end
  %13 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %13, i64 0
  %14 = load ptr, ptr %arrayidx, align 8
  %tobool15 = icmp ne ptr %14, null
  br i1 %tobool15, label %if.then16, label %if.end25

if.then16:                                        ; preds = %if.end14
  %15 = load ptr, ptr %args.addr, align 8
  %arrayidx17 = getelementptr ptr, ptr %15, i64 0
  %16 = load ptr, ptr %arrayidx17, align 8
  %call18 = call i32 @path_converter(ptr noundef %16, ptr noundef %path)
  %tobool19 = icmp ne i32 %call18, 0
  br i1 %tobool19, label %if.end21, label %if.then20

if.then20:                                        ; preds = %if.then16
  br label %exit

if.end21:                                         ; preds = %if.then16
  %17 = load i64, ptr %noptargs, align 8
  %dec = add i64 %17, -1
  store i64 %dec, ptr %noptargs, align 8
  %tobool22 = icmp ne i64 %dec, 0
  br i1 %tobool22, label %if.end24, label %if.then23

if.then23:                                        ; preds = %if.end21
  br label %skip_optional_pos

if.end24:                                         ; preds = %if.end21
  br label %if.end25

if.end25:                                         ; preds = %if.end24, %if.end14
  br label %skip_optional_pos

skip_optional_pos:                                ; preds = %if.end25, %if.then23, %if.then13
  %18 = load i64, ptr %noptargs, align 8
  %tobool26 = icmp ne i64 %18, 0
  br i1 %tobool26, label %if.end28, label %if.then27

if.then27:                                        ; preds = %skip_optional_pos
  br label %skip_optional_kwonly

if.end28:                                         ; preds = %skip_optional_pos
  %19 = load ptr, ptr %args.addr, align 8
  %arrayidx29 = getelementptr ptr, ptr %19, i64 1
  %20 = load ptr, ptr %arrayidx29, align 8
  %call30 = call i32 @PyObject_IsTrue(ptr noundef %20)
  store i32 %call30, ptr %follow_symlinks, align 4
  %21 = load i32, ptr %follow_symlinks, align 4
  %cmp31 = icmp slt i32 %21, 0
  br i1 %cmp31, label %if.then32, label %if.end33

if.then32:                                        ; preds = %if.end28
  br label %exit

if.end33:                                         ; preds = %if.end28
  br label %skip_optional_kwonly

skip_optional_kwonly:                             ; preds = %if.end33, %if.then27
  %22 = load ptr, ptr %module.addr, align 8
  %23 = load i32, ptr %follow_symlinks, align 4
  %call34 = call ptr @os_listxattr_impl(ptr noundef %22, ptr noundef %path, i32 noundef %23)
  store ptr %call34, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional_kwonly, %if.then32, %if.then20, %if.then
  call void @path_cleanup(ptr noundef %path)
  %24 = load ptr, ptr %return_value, align 8
  ret ptr %24
}

; Function Attrs: nounwind uwtable
define internal ptr @os_get_terminal_size(ptr noundef %module, ptr noundef %args, i64 noundef %nargs) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %return_value = alloca ptr, align 8
  %fd = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr @stdout, align 8
  %call = call i32 @fileno(ptr noundef %0) #10
  store i32 %call, ptr %fd, align 4
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp = icmp sle i64 0, %1
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %2 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 %2, 1
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %3 = load i64, ptr %nargs.addr, align 8
  %call2 = call i32 @_PyArg_CheckPositional(ptr noundef @.str.162, i64 noundef %3, i64 noundef 0, i64 noundef 1)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false
  br label %exit

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp slt i64 %4, 1
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  br label %skip_optional

if.end5:                                          ; preds = %if.end
  %5 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %5, i64 0
  %6 = load ptr, ptr %arrayidx, align 8
  %call6 = call i32 @PyLong_AsInt(ptr noundef %6)
  store i32 %call6, ptr %fd, align 4
  %7 = load i32, ptr %fd, align 4
  %cmp7 = icmp eq i32 %7, -1
  br i1 %cmp7, label %land.lhs.true8, label %if.end12

land.lhs.true8:                                   ; preds = %if.end5
  %call9 = call ptr @PyErr_Occurred()
  %tobool10 = icmp ne ptr %call9, null
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %land.lhs.true8
  br label %exit

if.end12:                                         ; preds = %land.lhs.true8, %if.end5
  br label %skip_optional

skip_optional:                                    ; preds = %if.end12, %if.then4
  %8 = load ptr, ptr %module.addr, align 8
  %9 = load i32, ptr %fd, align 4
  %call13 = call ptr @os_get_terminal_size_impl(ptr noundef %8, i32 noundef %9)
  store ptr %call13, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional, %if.then11, %if.then
  %10 = load ptr, ptr %return_value, align 8
  ret ptr %10
}

; Function Attrs: nounwind uwtable
define internal ptr @os_cpu_count(ptr noundef %module, ptr noundef %_unused_ignored) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %call = call ptr @os_cpu_count_impl(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @os_get_inheritable(ptr noundef %module, ptr noundef %arg) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %fd = alloca i32, align 4
  %_return_value = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %call = call i32 @PyLong_AsInt(ptr noundef %0)
  store i32 %call, ptr %fd, align 4
  %1 = load i32, ptr %fd, align 4
  %cmp = icmp eq i32 %1, -1
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %call1 = call ptr @PyErr_Occurred()
  %tobool = icmp ne ptr %call1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  br label %exit

if.end:                                           ; preds = %land.lhs.true, %entry
  %2 = load ptr, ptr %module.addr, align 8
  %3 = load i32, ptr %fd, align 4
  %call2 = call i32 @os_get_inheritable_impl(ptr noundef %2, i32 noundef %3)
  store i32 %call2, ptr %_return_value, align 4
  %4 = load i32, ptr %_return_value, align 4
  %cmp3 = icmp eq i32 %4, -1
  br i1 %cmp3, label %land.lhs.true4, label %if.end8

land.lhs.true4:                                   ; preds = %if.end
  %call5 = call ptr @PyErr_Occurred()
  %tobool6 = icmp ne ptr %call5, null
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %land.lhs.true4
  br label %exit

if.end8:                                          ; preds = %land.lhs.true4, %if.end
  %5 = load i32, ptr %_return_value, align 4
  %conv = sext i32 %5 to i64
  %call9 = call ptr @PyBool_FromLong(i64 noundef %conv)
  store ptr %call9, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end8, %if.then7, %if.then
  %6 = load ptr, ptr %return_value, align 8
  ret ptr %6
}

; Function Attrs: nounwind uwtable
define internal ptr @os_set_inheritable(ptr noundef %module, ptr noundef %args, i64 noundef %nargs) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %return_value = alloca ptr, align 8
  %fd = alloca i32, align 4
  %inheritable = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %cmp = icmp sle i64 2, %0
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 %1, 2
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %2 = load i64, ptr %nargs.addr, align 8
  %call = call i32 @_PyArg_CheckPositional(ptr noundef @.str.165, i64 noundef %2, i64 noundef 2, i64 noundef 2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false
  br label %exit

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %3 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %3, i64 0
  %4 = load ptr, ptr %arrayidx, align 8
  %call2 = call i32 @PyLong_AsInt(ptr noundef %4)
  store i32 %call2, ptr %fd, align 4
  %5 = load i32, ptr %fd, align 4
  %cmp3 = icmp eq i32 %5, -1
  br i1 %cmp3, label %land.lhs.true4, label %if.end8

land.lhs.true4:                                   ; preds = %if.end
  %call5 = call ptr @PyErr_Occurred()
  %tobool6 = icmp ne ptr %call5, null
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %land.lhs.true4
  br label %exit

if.end8:                                          ; preds = %land.lhs.true4, %if.end
  %6 = load ptr, ptr %args.addr, align 8
  %arrayidx9 = getelementptr ptr, ptr %6, i64 1
  %7 = load ptr, ptr %arrayidx9, align 8
  %call10 = call i32 @PyLong_AsInt(ptr noundef %7)
  store i32 %call10, ptr %inheritable, align 4
  %8 = load i32, ptr %inheritable, align 4
  %cmp11 = icmp eq i32 %8, -1
  br i1 %cmp11, label %land.lhs.true12, label %if.end16

land.lhs.true12:                                  ; preds = %if.end8
  %call13 = call ptr @PyErr_Occurred()
  %tobool14 = icmp ne ptr %call13, null
  br i1 %tobool14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %land.lhs.true12
  br label %exit

if.end16:                                         ; preds = %land.lhs.true12, %if.end8
  %9 = load ptr, ptr %module.addr, align 8
  %10 = load i32, ptr %fd, align 4
  %11 = load i32, ptr %inheritable, align 4
  %call17 = call ptr @os_set_inheritable_impl(ptr noundef %9, i32 noundef %10, i32 noundef %11)
  store ptr %call17, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end16, %if.then15, %if.then7, %if.then
  %12 = load ptr, ptr %return_value, align 8
  ret ptr %12
}

; Function Attrs: nounwind uwtable
define internal ptr @os_get_blocking(ptr noundef %module, ptr noundef %arg) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %fd = alloca i32, align 4
  %_return_value = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %call = call i32 @PyLong_AsInt(ptr noundef %0)
  store i32 %call, ptr %fd, align 4
  %1 = load i32, ptr %fd, align 4
  %cmp = icmp eq i32 %1, -1
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %call1 = call ptr @PyErr_Occurred()
  %tobool = icmp ne ptr %call1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  br label %exit

if.end:                                           ; preds = %land.lhs.true, %entry
  %2 = load ptr, ptr %module.addr, align 8
  %3 = load i32, ptr %fd, align 4
  %call2 = call i32 @os_get_blocking_impl(ptr noundef %2, i32 noundef %3)
  store i32 %call2, ptr %_return_value, align 4
  %4 = load i32, ptr %_return_value, align 4
  %cmp3 = icmp eq i32 %4, -1
  br i1 %cmp3, label %land.lhs.true4, label %if.end8

land.lhs.true4:                                   ; preds = %if.end
  %call5 = call ptr @PyErr_Occurred()
  %tobool6 = icmp ne ptr %call5, null
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %land.lhs.true4
  br label %exit

if.end8:                                          ; preds = %land.lhs.true4, %if.end
  %5 = load i32, ptr %_return_value, align 4
  %conv = sext i32 %5 to i64
  %call9 = call ptr @PyBool_FromLong(i64 noundef %conv)
  store ptr %call9, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end8, %if.then7, %if.then
  %6 = load ptr, ptr %return_value, align 8
  ret ptr %6
}

; Function Attrs: nounwind uwtable
define internal ptr @os_set_blocking(ptr noundef %module, ptr noundef %args, i64 noundef %nargs) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %return_value = alloca ptr, align 8
  %fd = alloca i32, align 4
  %blocking = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %cmp = icmp sle i64 2, %0
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 %1, 2
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %2 = load i64, ptr %nargs.addr, align 8
  %call = call i32 @_PyArg_CheckPositional(ptr noundef @.str.167, i64 noundef %2, i64 noundef 2, i64 noundef 2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false
  br label %exit

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %3 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %3, i64 0
  %4 = load ptr, ptr %arrayidx, align 8
  %call2 = call i32 @PyLong_AsInt(ptr noundef %4)
  store i32 %call2, ptr %fd, align 4
  %5 = load i32, ptr %fd, align 4
  %cmp3 = icmp eq i32 %5, -1
  br i1 %cmp3, label %land.lhs.true4, label %if.end8

land.lhs.true4:                                   ; preds = %if.end
  %call5 = call ptr @PyErr_Occurred()
  %tobool6 = icmp ne ptr %call5, null
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %land.lhs.true4
  br label %exit

if.end8:                                          ; preds = %land.lhs.true4, %if.end
  %6 = load ptr, ptr %args.addr, align 8
  %arrayidx9 = getelementptr ptr, ptr %6, i64 1
  %7 = load ptr, ptr %arrayidx9, align 8
  %call10 = call i32 @PyObject_IsTrue(ptr noundef %7)
  store i32 %call10, ptr %blocking, align 4
  %8 = load i32, ptr %blocking, align 4
  %cmp11 = icmp slt i32 %8, 0
  br i1 %cmp11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end8
  br label %exit

if.end13:                                         ; preds = %if.end8
  %9 = load ptr, ptr %module.addr, align 8
  %10 = load i32, ptr %fd, align 4
  %11 = load i32, ptr %blocking, align 4
  %call14 = call ptr @os_set_blocking_impl(ptr noundef %9, i32 noundef %10, i32 noundef %11)
  store ptr %call14, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end13, %if.then12, %if.then7, %if.then
  %12 = load ptr, ptr %return_value, align 8
  ret ptr %12
}

; Function Attrs: nounwind uwtable
define internal ptr @os_scandir(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [1 x ptr], align 8
  %noptargs = alloca i64, align 8
  %path = alloca %struct.path_t, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 0
  store i64 %sub, ptr %noptargs, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %path, ptr align 8 @__const.os_scandir.path, i64 72, i1 false)
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 0, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 1
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [1 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @os_scandir._parser, i32 noundef 0, i32 noundef 1, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load i64, ptr %noptargs, align 8
  %tobool12 = icmp ne i64 %12, 0
  br i1 %tobool12, label %if.end14, label %if.then13

if.then13:                                        ; preds = %if.end
  br label %skip_optional_pos

if.end14:                                         ; preds = %if.end
  %13 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %13, i64 0
  %14 = load ptr, ptr %arrayidx, align 8
  %call15 = call i32 @path_converter(ptr noundef %14, ptr noundef %path)
  %tobool16 = icmp ne i32 %call15, 0
  br i1 %tobool16, label %if.end18, label %if.then17

if.then17:                                        ; preds = %if.end14
  br label %exit

if.end18:                                         ; preds = %if.end14
  br label %skip_optional_pos

skip_optional_pos:                                ; preds = %if.end18, %if.then13
  %15 = load ptr, ptr %module.addr, align 8
  %call19 = call ptr @os_scandir_impl(ptr noundef %15, ptr noundef %path)
  store ptr %call19, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional_pos, %if.then17, %if.then
  call void @path_cleanup(ptr noundef %path)
  %16 = load ptr, ptr %return_value, align 8
  ret ptr %16
}

; Function Attrs: nounwind uwtable
define internal ptr @os_fspath(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [1 x ptr], align 8
  %path = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 1, %1
  br i1 %cmp1, label %land.lhs.true2, label %cond.false

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %2, 1
  br i1 %cmp3, label %land.lhs.true4, label %cond.false

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %3 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %3, null
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true4
  %4 = load ptr, ptr %args.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  %5 = load ptr, ptr %args.addr, align 8
  %6 = load i64, ptr %nargs.addr, align 8
  %7 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [1 x ptr], ptr %argsbuf, i64 0, i64 0
  %call = call ptr @_PyArg_UnpackKeywords(ptr noundef %5, i64 noundef %6, ptr noundef null, ptr noundef %7, ptr noundef @os_fspath._parser, i32 noundef 1, i32 noundef 1, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %4, %cond.true ], [ %call, %cond.false ]
  store ptr %cond, ptr %args.addr, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  br label %exit

if.end:                                           ; preds = %cond.end
  %9 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %9, i64 0
  %10 = load ptr, ptr %arrayidx, align 8
  store ptr %10, ptr %path, align 8
  %11 = load ptr, ptr %module.addr, align 8
  %12 = load ptr, ptr %path, align 8
  %call6 = call ptr @os_fspath_impl(ptr noundef %11, ptr noundef %12)
  store ptr %call6, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end, %if.then
  %13 = load ptr, ptr %return_value, align 8
  ret ptr %13
}

; Function Attrs: nounwind uwtable
define internal ptr @os_getrandom(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %op.addr.i35 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [2 x ptr], align 16
  %noptargs = alloca i64, align 8
  %size = alloca i64, align 8
  %flags = alloca i32, align 4
  %ival = alloca i64, align 8
  %iobj = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 1
  store i64 %sub, ptr %noptargs, align 8
  store i32 0, ptr %flags, align 4
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 1, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 2
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [2 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @os_getrandom._parser, i32 noundef 1, i32 noundef 2, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  store i64 -1, ptr %ival, align 8
  %12 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %12, i64 0
  %13 = load ptr, ptr %arrayidx, align 8
  %call12 = call ptr @_PyNumber_Index(ptr noundef %13)
  store ptr %call12, ptr %iobj, align 8
  %14 = load ptr, ptr %iobj, align 8
  %cmp13 = icmp ne ptr %14, null
  br i1 %cmp13, label %if.then14, label %if.end16

if.then14:                                        ; preds = %if.end
  %15 = load ptr, ptr %iobj, align 8
  %call15 = call i64 @PyLong_AsSsize_t(ptr noundef %15)
  store i64 %call15, ptr %ival, align 8
  %16 = load ptr, ptr %iobj, align 8
  store ptr %16, ptr %op.addr.i, align 8
  %17 = load ptr, ptr %op.addr.i, align 8
  store ptr %17, ptr %op.addr.i35, align 8
  %18 = load ptr, ptr %op.addr.i35, align 8
  %19 = load i64, ptr %18, align 8
  %conv.i = trunc i64 %19 to i32
  %cmp.i36 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i36 to i32
  %tobool.i = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then14
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.then14
  %20 = load ptr, ptr %op.addr.i, align 8
  %21 = load i64, ptr %20, align 8
  %dec.i = add i64 %21, -1
  store i64 %dec.i, ptr %20, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %22 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %22) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  br label %if.end16

if.end16:                                         ; preds = %Py_DECREF.exit, %if.end
  %23 = load i64, ptr %ival, align 8
  %cmp17 = icmp eq i64 %23, -1
  br i1 %cmp17, label %land.lhs.true18, label %if.end22

land.lhs.true18:                                  ; preds = %if.end16
  %call19 = call ptr @PyErr_Occurred()
  %tobool20 = icmp ne ptr %call19, null
  br i1 %tobool20, label %if.then21, label %if.end22

if.then21:                                        ; preds = %land.lhs.true18
  br label %exit

if.end22:                                         ; preds = %land.lhs.true18, %if.end16
  %24 = load i64, ptr %ival, align 8
  store i64 %24, ptr %size, align 8
  %25 = load i64, ptr %noptargs, align 8
  %tobool23 = icmp ne i64 %25, 0
  br i1 %tobool23, label %if.end25, label %if.then24

if.then24:                                        ; preds = %if.end22
  br label %skip_optional_pos

if.end25:                                         ; preds = %if.end22
  %26 = load ptr, ptr %args.addr, align 8
  %arrayidx26 = getelementptr ptr, ptr %26, i64 1
  %27 = load ptr, ptr %arrayidx26, align 8
  %call27 = call i32 @PyLong_AsInt(ptr noundef %27)
  store i32 %call27, ptr %flags, align 4
  %28 = load i32, ptr %flags, align 4
  %cmp28 = icmp eq i32 %28, -1
  br i1 %cmp28, label %land.lhs.true29, label %if.end33

land.lhs.true29:                                  ; preds = %if.end25
  %call30 = call ptr @PyErr_Occurred()
  %tobool31 = icmp ne ptr %call30, null
  br i1 %tobool31, label %if.then32, label %if.end33

if.then32:                                        ; preds = %land.lhs.true29
  br label %exit

if.end33:                                         ; preds = %land.lhs.true29, %if.end25
  br label %skip_optional_pos

skip_optional_pos:                                ; preds = %if.end33, %if.then24
  %29 = load ptr, ptr %module.addr, align 8
  %30 = load i64, ptr %size, align 8
  %31 = load i32, ptr %flags, align 4
  %call34 = call ptr @os_getrandom_impl(ptr noundef %29, i64 noundef %30, i32 noundef %31)
  store ptr %call34, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional_pos, %if.then32, %if.then21, %if.then
  %32 = load ptr, ptr %return_value, align 8
  ret ptr %32
}

; Function Attrs: nounwind uwtable
define internal ptr @os_memfd_create(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [2 x ptr], align 16
  %noptargs = alloca i64, align 8
  %name = alloca ptr, align 8
  %flags = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 1
  store i64 %sub, ptr %noptargs, align 8
  store ptr null, ptr %name, align 8
  store i32 1, ptr %flags, align 4
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 1, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 2
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [2 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @os_memfd_create._parser, i32 noundef 1, i32 noundef 2, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %12, i64 0
  %13 = load ptr, ptr %arrayidx, align 8
  %call12 = call i32 @PyUnicode_FSConverter(ptr noundef %13, ptr noundef %name)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end
  br label %exit

if.end15:                                         ; preds = %if.end
  %14 = load i64, ptr %noptargs, align 8
  %tobool16 = icmp ne i64 %14, 0
  br i1 %tobool16, label %if.end18, label %if.then17

if.then17:                                        ; preds = %if.end15
  br label %skip_optional_pos

if.end18:                                         ; preds = %if.end15
  %15 = load ptr, ptr %args.addr, align 8
  %arrayidx19 = getelementptr ptr, ptr %15, i64 1
  %16 = load ptr, ptr %arrayidx19, align 8
  %call20 = call i64 @PyLong_AsUnsignedLongMask(ptr noundef %16)
  %conv = trunc i64 %call20 to i32
  store i32 %conv, ptr %flags, align 4
  %17 = load i32, ptr %flags, align 4
  %cmp21 = icmp eq i32 %17, -1
  br i1 %cmp21, label %land.lhs.true23, label %if.end27

land.lhs.true23:                                  ; preds = %if.end18
  %call24 = call ptr @PyErr_Occurred()
  %tobool25 = icmp ne ptr %call24, null
  br i1 %tobool25, label %if.then26, label %if.end27

if.then26:                                        ; preds = %land.lhs.true23
  br label %exit

if.end27:                                         ; preds = %land.lhs.true23, %if.end18
  br label %skip_optional_pos

skip_optional_pos:                                ; preds = %if.end27, %if.then17
  %18 = load ptr, ptr %module.addr, align 8
  %19 = load ptr, ptr %name, align 8
  %20 = load i32, ptr %flags, align 4
  %call28 = call ptr @os_memfd_create_impl(ptr noundef %18, ptr noundef %19, i32 noundef %20)
  store ptr %call28, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional_pos, %if.then26, %if.then14, %if.then
  %21 = load ptr, ptr %name, align 8
  call void @Py_XDECREF(ptr noundef %21)
  %22 = load ptr, ptr %return_value, align 8
  ret ptr %22
}

; Function Attrs: nounwind uwtable
define internal ptr @os_eventfd(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [2 x ptr], align 16
  %noptargs = alloca i64, align 8
  %initval = alloca i32, align 4
  %flags = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 1
  store i64 %sub, ptr %noptargs, align 8
  store i32 524288, ptr %flags, align 4
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 1, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 2
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [2 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @os_eventfd._parser, i32 noundef 1, i32 noundef 2, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %12, i64 0
  %13 = load ptr, ptr %arrayidx, align 8
  %call12 = call i32 @_PyLong_UnsignedInt_Converter(ptr noundef %13, ptr noundef %initval)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end
  br label %exit

if.end15:                                         ; preds = %if.end
  %14 = load i64, ptr %noptargs, align 8
  %tobool16 = icmp ne i64 %14, 0
  br i1 %tobool16, label %if.end18, label %if.then17

if.then17:                                        ; preds = %if.end15
  br label %skip_optional_pos

if.end18:                                         ; preds = %if.end15
  %15 = load ptr, ptr %args.addr, align 8
  %arrayidx19 = getelementptr ptr, ptr %15, i64 1
  %16 = load ptr, ptr %arrayidx19, align 8
  %call20 = call i32 @PyLong_AsInt(ptr noundef %16)
  store i32 %call20, ptr %flags, align 4
  %17 = load i32, ptr %flags, align 4
  %cmp21 = icmp eq i32 %17, -1
  br i1 %cmp21, label %land.lhs.true22, label %if.end26

land.lhs.true22:                                  ; preds = %if.end18
  %call23 = call ptr @PyErr_Occurred()
  %tobool24 = icmp ne ptr %call23, null
  br i1 %tobool24, label %if.then25, label %if.end26

if.then25:                                        ; preds = %land.lhs.true22
  br label %exit

if.end26:                                         ; preds = %land.lhs.true22, %if.end18
  br label %skip_optional_pos

skip_optional_pos:                                ; preds = %if.end26, %if.then17
  %18 = load ptr, ptr %module.addr, align 8
  %19 = load i32, ptr %initval, align 4
  %20 = load i32, ptr %flags, align 4
  %call27 = call ptr @os_eventfd_impl(ptr noundef %18, i32 noundef %19, i32 noundef %20)
  store ptr %call27, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional_pos, %if.then25, %if.then14, %if.then
  %21 = load ptr, ptr %return_value, align 8
  ret ptr %21
}

; Function Attrs: nounwind uwtable
define internal ptr @os_eventfd_read(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [1 x ptr], align 8
  %fd = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 1, %1
  br i1 %cmp1, label %land.lhs.true2, label %cond.false

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %2, 1
  br i1 %cmp3, label %land.lhs.true4, label %cond.false

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %3 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %3, null
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true4
  %4 = load ptr, ptr %args.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  %5 = load ptr, ptr %args.addr, align 8
  %6 = load i64, ptr %nargs.addr, align 8
  %7 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [1 x ptr], ptr %argsbuf, i64 0, i64 0
  %call = call ptr @_PyArg_UnpackKeywords(ptr noundef %5, i64 noundef %6, ptr noundef null, ptr noundef %7, ptr noundef @os_eventfd_read._parser, i32 noundef 1, i32 noundef 1, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %4, %cond.true ], [ %call, %cond.false ]
  store ptr %cond, ptr %args.addr, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  br label %exit

if.end:                                           ; preds = %cond.end
  %9 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %9, i64 0
  %10 = load ptr, ptr %arrayidx, align 8
  %call6 = call i32 @_PyLong_FileDescriptor_Converter(ptr noundef %10, ptr noundef %fd)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %if.end
  br label %exit

if.end9:                                          ; preds = %if.end
  %11 = load ptr, ptr %module.addr, align 8
  %12 = load i32, ptr %fd, align 4
  %call10 = call ptr @os_eventfd_read_impl(ptr noundef %11, i32 noundef %12)
  store ptr %call10, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end9, %if.then8, %if.then
  %13 = load ptr, ptr %return_value, align 8
  ret ptr %13
}

; Function Attrs: nounwind uwtable
define internal ptr @os_eventfd_write(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [2 x ptr], align 16
  %fd = alloca i32, align 4
  %value = alloca i64, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 2, %1
  br i1 %cmp1, label %land.lhs.true2, label %cond.false

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %2, 2
  br i1 %cmp3, label %land.lhs.true4, label %cond.false

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %3 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %3, null
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true4
  %4 = load ptr, ptr %args.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  %5 = load ptr, ptr %args.addr, align 8
  %6 = load i64, ptr %nargs.addr, align 8
  %7 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [2 x ptr], ptr %argsbuf, i64 0, i64 0
  %call = call ptr @_PyArg_UnpackKeywords(ptr noundef %5, i64 noundef %6, ptr noundef null, ptr noundef %7, ptr noundef @os_eventfd_write._parser, i32 noundef 2, i32 noundef 2, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %4, %cond.true ], [ %call, %cond.false ]
  store ptr %cond, ptr %args.addr, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  br label %exit

if.end:                                           ; preds = %cond.end
  %9 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %9, i64 0
  %10 = load ptr, ptr %arrayidx, align 8
  %call6 = call i32 @_PyLong_FileDescriptor_Converter(ptr noundef %10, ptr noundef %fd)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %if.end
  br label %exit

if.end9:                                          ; preds = %if.end
  %11 = load ptr, ptr %args.addr, align 8
  %arrayidx10 = getelementptr ptr, ptr %11, i64 1
  %12 = load ptr, ptr %arrayidx10, align 8
  %call11 = call i32 @_PyLong_UnsignedLongLong_Converter(ptr noundef %12, ptr noundef %value)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %if.end14, label %if.then13

if.then13:                                        ; preds = %if.end9
  br label %exit

if.end14:                                         ; preds = %if.end9
  %13 = load ptr, ptr %module.addr, align 8
  %14 = load i32, ptr %fd, align 4
  %15 = load i64, ptr %value, align 8
  %call15 = call ptr @os_eventfd_write_impl(ptr noundef %13, i32 noundef %14, i64 noundef %15)
  store ptr %call15, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end14, %if.then13, %if.then8, %if.then
  %16 = load ptr, ptr %return_value, align 8
  ret ptr %16
}

; Function Attrs: nounwind uwtable
define internal ptr @os_waitstatus_to_exitcode(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [1 x ptr], align 8
  %status_obj = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 1, %1
  br i1 %cmp1, label %land.lhs.true2, label %cond.false

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %2, 1
  br i1 %cmp3, label %land.lhs.true4, label %cond.false

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %3 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %3, null
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true4
  %4 = load ptr, ptr %args.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  %5 = load ptr, ptr %args.addr, align 8
  %6 = load i64, ptr %nargs.addr, align 8
  %7 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [1 x ptr], ptr %argsbuf, i64 0, i64 0
  %call = call ptr @_PyArg_UnpackKeywords(ptr noundef %5, i64 noundef %6, ptr noundef null, ptr noundef %7, ptr noundef @os_waitstatus_to_exitcode._parser, i32 noundef 1, i32 noundef 1, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %4, %cond.true ], [ %call, %cond.false ]
  store ptr %cond, ptr %args.addr, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  br label %exit

if.end:                                           ; preds = %cond.end
  %9 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %9, i64 0
  %10 = load ptr, ptr %arrayidx, align 8
  store ptr %10, ptr %status_obj, align 8
  %11 = load ptr, ptr %module.addr, align 8
  %12 = load ptr, ptr %status_obj, align 8
  %call6 = call ptr @os_waitstatus_to_exitcode_impl(ptr noundef %11, ptr noundef %12)
  store ptr %call6, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end, %if.then
  %13 = load ptr, ptr %return_value, align 8
  ret ptr %13
}

; Function Attrs: nounwind uwtable
define internal ptr @os_setns(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [2 x ptr], align 16
  %noptargs = alloca i64, align 8
  %fd = alloca i32, align 4
  %nstype = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 1
  store i64 %sub, ptr %noptargs, align 8
  store i32 0, ptr %nstype, align 4
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 1, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 2
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [2 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @os_setns._parser, i32 noundef 1, i32 noundef 2, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %12, i64 0
  %13 = load ptr, ptr %arrayidx, align 8
  %call12 = call i32 @_PyLong_FileDescriptor_Converter(ptr noundef %13, ptr noundef %fd)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end
  br label %exit

if.end15:                                         ; preds = %if.end
  %14 = load i64, ptr %noptargs, align 8
  %tobool16 = icmp ne i64 %14, 0
  br i1 %tobool16, label %if.end18, label %if.then17

if.then17:                                        ; preds = %if.end15
  br label %skip_optional_pos

if.end18:                                         ; preds = %if.end15
  %15 = load ptr, ptr %args.addr, align 8
  %arrayidx19 = getelementptr ptr, ptr %15, i64 1
  %16 = load ptr, ptr %arrayidx19, align 8
  %call20 = call i32 @PyLong_AsInt(ptr noundef %16)
  store i32 %call20, ptr %nstype, align 4
  %17 = load i32, ptr %nstype, align 4
  %cmp21 = icmp eq i32 %17, -1
  br i1 %cmp21, label %land.lhs.true22, label %if.end26

land.lhs.true22:                                  ; preds = %if.end18
  %call23 = call ptr @PyErr_Occurred()
  %tobool24 = icmp ne ptr %call23, null
  br i1 %tobool24, label %if.then25, label %if.end26

if.then25:                                        ; preds = %land.lhs.true22
  br label %exit

if.end26:                                         ; preds = %land.lhs.true22, %if.end18
  br label %skip_optional_pos

skip_optional_pos:                                ; preds = %if.end26, %if.then17
  %18 = load ptr, ptr %module.addr, align 8
  %19 = load i32, ptr %fd, align 4
  %20 = load i32, ptr %nstype, align 4
  %call27 = call ptr @os_setns_impl(ptr noundef %18, i32 noundef %19, i32 noundef %20)
  store ptr %call27, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional_pos, %if.then25, %if.then14, %if.then
  %21 = load ptr, ptr %return_value, align 8
  ret ptr %21
}

; Function Attrs: nounwind uwtable
define internal ptr @os_unshare(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [1 x ptr], align 8
  %flags = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 1, %1
  br i1 %cmp1, label %land.lhs.true2, label %cond.false

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %2, 1
  br i1 %cmp3, label %land.lhs.true4, label %cond.false

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %3 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %3, null
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true4
  %4 = load ptr, ptr %args.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  %5 = load ptr, ptr %args.addr, align 8
  %6 = load i64, ptr %nargs.addr, align 8
  %7 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [1 x ptr], ptr %argsbuf, i64 0, i64 0
  %call = call ptr @_PyArg_UnpackKeywords(ptr noundef %5, i64 noundef %6, ptr noundef null, ptr noundef %7, ptr noundef @os_unshare._parser, i32 noundef 1, i32 noundef 1, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %4, %cond.true ], [ %call, %cond.false ]
  store ptr %cond, ptr %args.addr, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  br label %exit

if.end:                                           ; preds = %cond.end
  %9 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %9, i64 0
  %10 = load ptr, ptr %arrayidx, align 8
  %call6 = call i32 @PyLong_AsInt(ptr noundef %10)
  store i32 %call6, ptr %flags, align 4
  %11 = load i32, ptr %flags, align 4
  %cmp7 = icmp eq i32 %11, -1
  br i1 %cmp7, label %land.lhs.true8, label %if.end12

land.lhs.true8:                                   ; preds = %if.end
  %call9 = call ptr @PyErr_Occurred()
  %tobool10 = icmp ne ptr %call9, null
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %land.lhs.true8
  br label %exit

if.end12:                                         ; preds = %land.lhs.true8, %if.end
  %12 = load ptr, ptr %module.addr, align 8
  %13 = load i32, ptr %flags, align 4
  %call13 = call ptr @os_unshare_impl(ptr noundef %12, i32 noundef %13)
  store ptr %call13, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end12, %if.then11, %if.then
  %14 = load ptr, ptr %return_value, align 8
  ret ptr %14
}

; Function Attrs: nounwind uwtable
define internal ptr @os_timerfd_create(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [2 x ptr], align 16
  %noptargs = alloca i64, align 8
  %clockid = alloca i32, align 4
  %flags = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 1
  store i64 %sub, ptr %noptargs, align 8
  store i32 0, ptr %flags, align 4
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 1, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 1
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [2 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @os_timerfd_create._parser, i32 noundef 1, i32 noundef 1, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %12, i64 0
  %13 = load ptr, ptr %arrayidx, align 8
  %call12 = call i32 @PyLong_AsInt(ptr noundef %13)
  store i32 %call12, ptr %clockid, align 4
  %14 = load i32, ptr %clockid, align 4
  %cmp13 = icmp eq i32 %14, -1
  br i1 %cmp13, label %land.lhs.true14, label %if.end18

land.lhs.true14:                                  ; preds = %if.end
  %call15 = call ptr @PyErr_Occurred()
  %tobool16 = icmp ne ptr %call15, null
  br i1 %tobool16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %land.lhs.true14
  br label %exit

if.end18:                                         ; preds = %land.lhs.true14, %if.end
  %15 = load i64, ptr %noptargs, align 8
  %tobool19 = icmp ne i64 %15, 0
  br i1 %tobool19, label %if.end21, label %if.then20

if.then20:                                        ; preds = %if.end18
  br label %skip_optional_kwonly

if.end21:                                         ; preds = %if.end18
  %16 = load ptr, ptr %args.addr, align 8
  %arrayidx22 = getelementptr ptr, ptr %16, i64 1
  %17 = load ptr, ptr %arrayidx22, align 8
  %call23 = call i32 @PyLong_AsInt(ptr noundef %17)
  store i32 %call23, ptr %flags, align 4
  %18 = load i32, ptr %flags, align 4
  %cmp24 = icmp eq i32 %18, -1
  br i1 %cmp24, label %land.lhs.true25, label %if.end29

land.lhs.true25:                                  ; preds = %if.end21
  %call26 = call ptr @PyErr_Occurred()
  %tobool27 = icmp ne ptr %call26, null
  br i1 %tobool27, label %if.then28, label %if.end29

if.then28:                                        ; preds = %land.lhs.true25
  br label %exit

if.end29:                                         ; preds = %land.lhs.true25, %if.end21
  br label %skip_optional_kwonly

skip_optional_kwonly:                             ; preds = %if.end29, %if.then20
  %19 = load ptr, ptr %module.addr, align 8
  %20 = load i32, ptr %clockid, align 4
  %21 = load i32, ptr %flags, align 4
  %call30 = call ptr @os_timerfd_create_impl(ptr noundef %19, i32 noundef %20, i32 noundef %21)
  store ptr %call30, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional_kwonly, %if.then28, %if.then17, %if.then
  %22 = load ptr, ptr %return_value, align 8
  ret ptr %22
}

; Function Attrs: nounwind uwtable
define internal ptr @os_timerfd_settime(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [4 x ptr], align 16
  %noptargs = alloca i64, align 8
  %fd = alloca i32, align 4
  %flags = alloca i32, align 4
  %initial = alloca double, align 8
  %interval = alloca double, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 1
  store i64 %sub, ptr %noptargs, align 8
  store i32 0, ptr %flags, align 4
  store double 0.000000e+00, ptr %initial, align 8
  store double 0.000000e+00, ptr %interval, align 8
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 1, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 1
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [4 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @os_timerfd_settime._parser, i32 noundef 1, i32 noundef 1, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %12, i64 0
  %13 = load ptr, ptr %arrayidx, align 8
  %call12 = call i32 @_PyLong_FileDescriptor_Converter(ptr noundef %13, ptr noundef %fd)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end
  br label %exit

if.end15:                                         ; preds = %if.end
  %14 = load i64, ptr %noptargs, align 8
  %tobool16 = icmp ne i64 %14, 0
  br i1 %tobool16, label %if.end18, label %if.then17

if.then17:                                        ; preds = %if.end15
  br label %skip_optional_kwonly

if.end18:                                         ; preds = %if.end15
  %15 = load ptr, ptr %args.addr, align 8
  %arrayidx19 = getelementptr ptr, ptr %15, i64 1
  %16 = load ptr, ptr %arrayidx19, align 8
  %tobool20 = icmp ne ptr %16, null
  br i1 %tobool20, label %if.then21, label %if.end33

if.then21:                                        ; preds = %if.end18
  %17 = load ptr, ptr %args.addr, align 8
  %arrayidx22 = getelementptr ptr, ptr %17, i64 1
  %18 = load ptr, ptr %arrayidx22, align 8
  %call23 = call i32 @PyLong_AsInt(ptr noundef %18)
  store i32 %call23, ptr %flags, align 4
  %19 = load i32, ptr %flags, align 4
  %cmp24 = icmp eq i32 %19, -1
  br i1 %cmp24, label %land.lhs.true25, label %if.end29

land.lhs.true25:                                  ; preds = %if.then21
  %call26 = call ptr @PyErr_Occurred()
  %tobool27 = icmp ne ptr %call26, null
  br i1 %tobool27, label %if.then28, label %if.end29

if.then28:                                        ; preds = %land.lhs.true25
  br label %exit

if.end29:                                         ; preds = %land.lhs.true25, %if.then21
  %20 = load i64, ptr %noptargs, align 8
  %dec = add i64 %20, -1
  store i64 %dec, ptr %noptargs, align 8
  %tobool30 = icmp ne i64 %dec, 0
  br i1 %tobool30, label %if.end32, label %if.then31

if.then31:                                        ; preds = %if.end29
  br label %skip_optional_kwonly

if.end32:                                         ; preds = %if.end29
  br label %if.end33

if.end33:                                         ; preds = %if.end32, %if.end18
  %21 = load ptr, ptr %args.addr, align 8
  %arrayidx34 = getelementptr ptr, ptr %21, i64 2
  %22 = load ptr, ptr %arrayidx34, align 8
  %tobool35 = icmp ne ptr %22, null
  br i1 %tobool35, label %if.then36, label %if.end56

if.then36:                                        ; preds = %if.end33
  %23 = load ptr, ptr %args.addr, align 8
  %arrayidx37 = getelementptr ptr, ptr %23, i64 2
  %24 = load ptr, ptr %arrayidx37, align 8
  %call38 = call i32 @Py_IS_TYPE(ptr noundef %24, ptr noundef @PyFloat_Type)
  %tobool39 = icmp ne i32 %call38, 0
  br i1 %tobool39, label %if.then40, label %if.else

if.then40:                                        ; preds = %if.then36
  %25 = load ptr, ptr %args.addr, align 8
  %arrayidx41 = getelementptr ptr, ptr %25, i64 2
  %26 = load ptr, ptr %arrayidx41, align 8
  %call42 = call double @PyFloat_AS_DOUBLE(ptr noundef %26)
  store double %call42, ptr %initial, align 8
  br label %if.end51

if.else:                                          ; preds = %if.then36
  %27 = load ptr, ptr %args.addr, align 8
  %arrayidx43 = getelementptr ptr, ptr %27, i64 2
  %28 = load ptr, ptr %arrayidx43, align 8
  %call44 = call double @PyFloat_AsDouble(ptr noundef %28)
  store double %call44, ptr %initial, align 8
  %29 = load double, ptr %initial, align 8
  %cmp45 = fcmp oeq double %29, -1.000000e+00
  br i1 %cmp45, label %land.lhs.true46, label %if.end50

land.lhs.true46:                                  ; preds = %if.else
  %call47 = call ptr @PyErr_Occurred()
  %tobool48 = icmp ne ptr %call47, null
  br i1 %tobool48, label %if.then49, label %if.end50

if.then49:                                        ; preds = %land.lhs.true46
  br label %exit

if.end50:                                         ; preds = %land.lhs.true46, %if.else
  br label %if.end51

if.end51:                                         ; preds = %if.end50, %if.then40
  %30 = load i64, ptr %noptargs, align 8
  %dec52 = add i64 %30, -1
  store i64 %dec52, ptr %noptargs, align 8
  %tobool53 = icmp ne i64 %dec52, 0
  br i1 %tobool53, label %if.end55, label %if.then54

if.then54:                                        ; preds = %if.end51
  br label %skip_optional_kwonly

if.end55:                                         ; preds = %if.end51
  br label %if.end56

if.end56:                                         ; preds = %if.end55, %if.end33
  %31 = load ptr, ptr %args.addr, align 8
  %arrayidx57 = getelementptr ptr, ptr %31, i64 3
  %32 = load ptr, ptr %arrayidx57, align 8
  %call58 = call i32 @Py_IS_TYPE(ptr noundef %32, ptr noundef @PyFloat_Type)
  %tobool59 = icmp ne i32 %call58, 0
  br i1 %tobool59, label %if.then60, label %if.else63

if.then60:                                        ; preds = %if.end56
  %33 = load ptr, ptr %args.addr, align 8
  %arrayidx61 = getelementptr ptr, ptr %33, i64 3
  %34 = load ptr, ptr %arrayidx61, align 8
  %call62 = call double @PyFloat_AS_DOUBLE(ptr noundef %34)
  store double %call62, ptr %interval, align 8
  br label %if.end72

if.else63:                                        ; preds = %if.end56
  %35 = load ptr, ptr %args.addr, align 8
  %arrayidx64 = getelementptr ptr, ptr %35, i64 3
  %36 = load ptr, ptr %arrayidx64, align 8
  %call65 = call double @PyFloat_AsDouble(ptr noundef %36)
  store double %call65, ptr %interval, align 8
  %37 = load double, ptr %interval, align 8
  %cmp66 = fcmp oeq double %37, -1.000000e+00
  br i1 %cmp66, label %land.lhs.true67, label %if.end71

land.lhs.true67:                                  ; preds = %if.else63
  %call68 = call ptr @PyErr_Occurred()
  %tobool69 = icmp ne ptr %call68, null
  br i1 %tobool69, label %if.then70, label %if.end71

if.then70:                                        ; preds = %land.lhs.true67
  br label %exit

if.end71:                                         ; preds = %land.lhs.true67, %if.else63
  br label %if.end72

if.end72:                                         ; preds = %if.end71, %if.then60
  br label %skip_optional_kwonly

skip_optional_kwonly:                             ; preds = %if.end72, %if.then54, %if.then31, %if.then17
  %38 = load ptr, ptr %module.addr, align 8
  %39 = load i32, ptr %fd, align 4
  %40 = load i32, ptr %flags, align 4
  %41 = load double, ptr %initial, align 8
  %42 = load double, ptr %interval, align 8
  %call73 = call ptr @os_timerfd_settime_impl(ptr noundef %38, i32 noundef %39, i32 noundef %40, double noundef %41, double noundef %42)
  store ptr %call73, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional_kwonly, %if.then70, %if.then49, %if.then28, %if.then14, %if.then
  %43 = load ptr, ptr %return_value, align 8
  ret ptr %43
}

; Function Attrs: nounwind uwtable
define internal ptr @os_timerfd_settime_ns(ptr noundef %module, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [4 x ptr], align 16
  %noptargs = alloca i64, align 8
  %fd = alloca i32, align 4
  %flags = alloca i32, align 4
  %initial = alloca i64, align 8
  %interval = alloca i64, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 1
  store i64 %sub, ptr %noptargs, align 8
  store i32 0, ptr %flags, align 4
  store i64 0, ptr %initial, align 8
  store i64 0, ptr %interval, align 8
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 1, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 1
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [4 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @os_timerfd_settime_ns._parser, i32 noundef 1, i32 noundef 1, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %12, i64 0
  %13 = load ptr, ptr %arrayidx, align 8
  %call12 = call i32 @_PyLong_FileDescriptor_Converter(ptr noundef %13, ptr noundef %fd)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end
  br label %exit

if.end15:                                         ; preds = %if.end
  %14 = load i64, ptr %noptargs, align 8
  %tobool16 = icmp ne i64 %14, 0
  br i1 %tobool16, label %if.end18, label %if.then17

if.then17:                                        ; preds = %if.end15
  br label %skip_optional_kwonly

if.end18:                                         ; preds = %if.end15
  %15 = load ptr, ptr %args.addr, align 8
  %arrayidx19 = getelementptr ptr, ptr %15, i64 1
  %16 = load ptr, ptr %arrayidx19, align 8
  %tobool20 = icmp ne ptr %16, null
  br i1 %tobool20, label %if.then21, label %if.end33

if.then21:                                        ; preds = %if.end18
  %17 = load ptr, ptr %args.addr, align 8
  %arrayidx22 = getelementptr ptr, ptr %17, i64 1
  %18 = load ptr, ptr %arrayidx22, align 8
  %call23 = call i32 @PyLong_AsInt(ptr noundef %18)
  store i32 %call23, ptr %flags, align 4
  %19 = load i32, ptr %flags, align 4
  %cmp24 = icmp eq i32 %19, -1
  br i1 %cmp24, label %land.lhs.true25, label %if.end29

land.lhs.true25:                                  ; preds = %if.then21
  %call26 = call ptr @PyErr_Occurred()
  %tobool27 = icmp ne ptr %call26, null
  br i1 %tobool27, label %if.then28, label %if.end29

if.then28:                                        ; preds = %land.lhs.true25
  br label %exit

if.end29:                                         ; preds = %land.lhs.true25, %if.then21
  %20 = load i64, ptr %noptargs, align 8
  %dec = add i64 %20, -1
  store i64 %dec, ptr %noptargs, align 8
  %tobool30 = icmp ne i64 %dec, 0
  br i1 %tobool30, label %if.end32, label %if.then31

if.then31:                                        ; preds = %if.end29
  br label %skip_optional_kwonly

if.end32:                                         ; preds = %if.end29
  br label %if.end33

if.end33:                                         ; preds = %if.end32, %if.end18
  %21 = load ptr, ptr %args.addr, align 8
  %arrayidx34 = getelementptr ptr, ptr %21, i64 2
  %22 = load ptr, ptr %arrayidx34, align 8
  %tobool35 = icmp ne ptr %22, null
  br i1 %tobool35, label %if.then36, label %if.end49

if.then36:                                        ; preds = %if.end33
  %23 = load ptr, ptr %args.addr, align 8
  %arrayidx37 = getelementptr ptr, ptr %23, i64 2
  %24 = load ptr, ptr %arrayidx37, align 8
  %call38 = call i64 @PyLong_AsLongLong(ptr noundef %24)
  store i64 %call38, ptr %initial, align 8
  %25 = load i64, ptr %initial, align 8
  %cmp39 = icmp eq i64 %25, -1
  br i1 %cmp39, label %land.lhs.true40, label %if.end44

land.lhs.true40:                                  ; preds = %if.then36
  %call41 = call ptr @PyErr_Occurred()
  %tobool42 = icmp ne ptr %call41, null
  br i1 %tobool42, label %if.then43, label %if.end44

if.then43:                                        ; preds = %land.lhs.true40
  br label %exit

if.end44:                                         ; preds = %land.lhs.true40, %if.then36
  %26 = load i64, ptr %noptargs, align 8
  %dec45 = add i64 %26, -1
  store i64 %dec45, ptr %noptargs, align 8
  %tobool46 = icmp ne i64 %dec45, 0
  br i1 %tobool46, label %if.end48, label %if.then47

if.then47:                                        ; preds = %if.end44
  br label %skip_optional_kwonly

if.end48:                                         ; preds = %if.end44
  br label %if.end49

if.end49:                                         ; preds = %if.end48, %if.end33
  %27 = load ptr, ptr %args.addr, align 8
  %arrayidx50 = getelementptr ptr, ptr %27, i64 3
  %28 = load ptr, ptr %arrayidx50, align 8
  %call51 = call i64 @PyLong_AsLongLong(ptr noundef %28)
  store i64 %call51, ptr %interval, align 8
  %29 = load i64, ptr %interval, align 8
  %cmp52 = icmp eq i64 %29, -1
  br i1 %cmp52, label %land.lhs.true53, label %if.end57

land.lhs.true53:                                  ; preds = %if.end49
  %call54 = call ptr @PyErr_Occurred()
  %tobool55 = icmp ne ptr %call54, null
  br i1 %tobool55, label %if.then56, label %if.end57

if.then56:                                        ; preds = %land.lhs.true53
  br label %exit

if.end57:                                         ; preds = %land.lhs.true53, %if.end49
  br label %skip_optional_kwonly

skip_optional_kwonly:                             ; preds = %if.end57, %if.then47, %if.then31, %if.then17
  %30 = load ptr, ptr %module.addr, align 8
  %31 = load i32, ptr %fd, align 4
  %32 = load i32, ptr %flags, align 4
  %33 = load i64, ptr %initial, align 8
  %34 = load i64, ptr %interval, align 8
  %call58 = call ptr @os_timerfd_settime_ns_impl(ptr noundef %30, i32 noundef %31, i32 noundef %32, i64 noundef %33, i64 noundef %34)
  store ptr %call58, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional_kwonly, %if.then56, %if.then43, %if.then28, %if.then14, %if.then
  %35 = load ptr, ptr %return_value, align 8
  ret ptr %35
}

; Function Attrs: nounwind uwtable
define internal ptr @os_timerfd_gettime(ptr noundef %module, ptr noundef %arg) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %fd = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %call = call i32 @_PyLong_FileDescriptor_Converter(ptr noundef %0, ptr noundef %fd)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %exit

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %module.addr, align 8
  %2 = load i32, ptr %fd, align 4
  %call1 = call ptr @os_timerfd_gettime_impl(ptr noundef %1, i32 noundef %2)
  store ptr %call1, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end, %if.then
  %3 = load ptr, ptr %return_value, align 8
  ret ptr %3
}

; Function Attrs: nounwind uwtable
define internal ptr @os_timerfd_gettime_ns(ptr noundef %module, ptr noundef %arg) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %fd = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %call = call i32 @_PyLong_FileDescriptor_Converter(ptr noundef %0, ptr noundef %fd)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %exit

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %module.addr, align 8
  %2 = load i32, ptr %fd, align 4
  %call1 = call ptr @os_timerfd_gettime_ns_impl(ptr noundef %1, i32 noundef %2)
  store ptr %call1, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end, %if.then
  %3 = load ptr, ptr %return_value, align 8
  ret ptr %3
}

; Function Attrs: nounwind uwtable
define internal i64 @PyTuple_GET_SIZE(ptr noundef %op) #0 {
entry:
  %op.addr = alloca ptr, align 8
  %tuple = alloca ptr, align 8
  store ptr %op, ptr %op.addr, align 8
  %0 = load ptr, ptr %op.addr, align 8
  store ptr %0, ptr %tuple, align 8
  %1 = load ptr, ptr %tuple, align 8
  %call = call i64 @Py_SIZE(ptr noundef %1)
  ret i64 %call
}

declare ptr @_PyArg_UnpackKeywords(ptr noundef, i64 noundef, ptr noundef, ptr noundef, ptr noundef, i32 noundef, i32 noundef, i32 noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal i32 @path_converter(ptr noundef %o, ptr noundef %p) #0 {
entry:
  %op.addr.i174 = alloca ptr, align 8
  %cur_refcnt.i = alloca i32, align 4
  %new_refcnt.i = alloca i32, align 4
  %op.addr.i170 = alloca ptr, align 8
  %op.addr.i166 = alloca ptr, align 8
  %op.addr.i162 = alloca ptr, align 8
  %op.addr.i160 = alloca ptr, align 8
  %op.addr.i151 = alloca ptr, align 8
  %op.addr.i142 = alloca ptr, align 8
  %op.addr.i133 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca i32, align 4
  %o.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %path = alloca ptr, align 8
  %bytes = alloca ptr, align 8
  %length = alloca i64, align 8
  %is_index = alloca i32, align 4
  %is_bytes = alloca i32, align 4
  %is_unicode = alloca i32, align 4
  %narrow = alloca ptr, align 8
  %func = alloca ptr, align 8
  %res = alloca ptr, align 8
  %_tmp_dst_ptr = alloca ptr, align 8
  %_tmp_old_dst = alloca ptr, align 8
  store ptr %o, ptr %o.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  store ptr %0, ptr %path, align 8
  store ptr null, ptr %bytes, align 8
  store i64 0, ptr %length, align 8
  %1 = load ptr, ptr %o.addr, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %path, align 8
  call void @path_cleanup(ptr noundef %2)
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %path, align 8
  %cleanup = getelementptr inbounds %struct.path_t, ptr %3, i32 0, i32 9
  store ptr null, ptr %cleanup, align 8
  %4 = load ptr, ptr %path, align 8
  %object = getelementptr inbounds %struct.path_t, ptr %4, i32 0, i32 8
  store ptr null, ptr %object, align 8
  %5 = load ptr, ptr %o.addr, align 8
  store ptr %5, ptr %op.addr.i174, align 8
  %6 = load ptr, ptr %op.addr.i174, align 8
  %7 = load i32, ptr %6, align 8
  store i32 %7, ptr %cur_refcnt.i, align 4
  %8 = load i32, ptr %cur_refcnt.i, align 4
  %add.i = add i32 %8, 1
  store i32 %add.i, ptr %new_refcnt.i, align 4
  %9 = load i32, ptr %new_refcnt.i, align 4
  %cmp.i175 = icmp eq i32 %9, 0
  br i1 %cmp.i175, label %if.then.i177, label %if.end.i176

if.then.i177:                                     ; preds = %if.end
  br label %Py_INCREF.exit

if.end.i176:                                      ; preds = %if.end
  %10 = load i32, ptr %new_refcnt.i, align 4
  %11 = load ptr, ptr %op.addr.i174, align 8
  store i32 %10, ptr %11, align 8
  br label %Py_INCREF.exit

Py_INCREF.exit:                                   ; preds = %if.end.i176, %if.then.i177
  %12 = load ptr, ptr %o.addr, align 8
  %cmp1 = icmp eq ptr %12, @_Py_NoneStruct
  br i1 %cmp1, label %land.lhs.true, label %if.end4

land.lhs.true:                                    ; preds = %Py_INCREF.exit
  %13 = load ptr, ptr %path, align 8
  %nullable = getelementptr inbounds %struct.path_t, ptr %13, i32 0, i32 2
  %14 = load i32, ptr %nullable, align 8
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.then2, label %if.end4

if.then2:                                         ; preds = %land.lhs.true
  %15 = load ptr, ptr %path, align 8
  %wide = getelementptr inbounds %struct.path_t, ptr %15, i32 0, i32 4
  store ptr null, ptr %wide, align 8
  %16 = load ptr, ptr %path, align 8
  %narrow3 = getelementptr inbounds %struct.path_t, ptr %16, i32 0, i32 5
  store ptr null, ptr %narrow3, align 8
  %17 = load ptr, ptr %path, align 8
  %fd = getelementptr inbounds %struct.path_t, ptr %17, i32 0, i32 6
  store i32 -1, ptr %fd, align 8
  br label %success_exit

if.end4:                                          ; preds = %land.lhs.true, %Py_INCREF.exit
  %18 = load ptr, ptr %path, align 8
  %allow_fd = getelementptr inbounds %struct.path_t, ptr %18, i32 0, i32 3
  %19 = load i32, ptr %allow_fd, align 4
  %tobool5 = icmp ne i32 %19, 0
  br i1 %tobool5, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end4
  %20 = load ptr, ptr %o.addr, align 8
  %call = call i32 @PyIndex_Check(ptr noundef %20)
  %tobool6 = icmp ne i32 %call, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end4
  %21 = phi i1 [ false, %if.end4 ], [ %tobool6, %land.rhs ]
  %land.ext = zext i1 %21 to i32
  store i32 %land.ext, ptr %is_index, align 4
  %22 = load ptr, ptr %o.addr, align 8
  %call7 = call ptr @Py_TYPE(ptr noundef %22)
  %call8 = call i32 @PyType_HasFeature(ptr noundef %call7, i64 noundef 134217728)
  store i32 %call8, ptr %is_bytes, align 4
  %23 = load ptr, ptr %o.addr, align 8
  %call9 = call ptr @Py_TYPE(ptr noundef %23)
  %call10 = call i32 @PyType_HasFeature(ptr noundef %call9, i64 noundef 268435456)
  store i32 %call10, ptr %is_unicode, align 4
  %24 = load i32, ptr %is_index, align 4
  %tobool11 = icmp ne i32 %24, 0
  br i1 %tobool11, label %if.end43, label %land.lhs.true12

land.lhs.true12:                                  ; preds = %land.end
  %25 = load i32, ptr %is_unicode, align 4
  %tobool13 = icmp ne i32 %25, 0
  br i1 %tobool13, label %if.end43, label %land.lhs.true14

land.lhs.true14:                                  ; preds = %land.lhs.true12
  %26 = load i32, ptr %is_bytes, align 4
  %tobool15 = icmp ne i32 %26, 0
  br i1 %tobool15, label %if.end43, label %if.then16

if.then16:                                        ; preds = %land.lhs.true14
  %27 = load ptr, ptr %o.addr, align 8
  %call17 = call ptr @_PyObject_LookupSpecial(ptr noundef %27, ptr noundef getelementptr inbounds (%struct.anon.44, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 37), i32 0, i32 3, i32 1, i32 59))
  store ptr %call17, ptr %func, align 8
  %28 = load ptr, ptr %func, align 8
  %cmp18 = icmp eq ptr null, %28
  br i1 %cmp18, label %if.then20, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then16
  %29 = load ptr, ptr %func, align 8
  %cmp19 = icmp eq ptr %29, @_Py_NoneStruct
  br i1 %cmp19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %lor.lhs.false, %if.then16
  br label %error_format

if.end21:                                         ; preds = %lor.lhs.false
  %30 = load ptr, ptr %func, align 8
  %call22 = call ptr @_PyObject_CallNoArgs(ptr noundef %30)
  store ptr %call22, ptr %res, align 8
  %31 = load ptr, ptr %func, align 8
  store ptr %31, ptr %op.addr.i151, align 8
  %32 = load ptr, ptr %op.addr.i151, align 8
  store ptr %32, ptr %op.addr.i160, align 8
  %33 = load ptr, ptr %op.addr.i160, align 8
  %34 = load i64, ptr %33, align 8
  %conv.i = trunc i64 %34 to i32
  %cmp.i161 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i161 to i32
  %tobool.i153 = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i153, label %if.then.i158, label %if.end.i154

if.then.i158:                                     ; preds = %if.end21
  br label %Py_DECREF.exit159

if.end.i154:                                      ; preds = %if.end21
  %35 = load ptr, ptr %op.addr.i151, align 8
  %36 = load i64, ptr %35, align 8
  %dec.i155 = add i64 %36, -1
  store i64 %dec.i155, ptr %35, align 8
  %cmp.i156 = icmp eq i64 %dec.i155, 0
  br i1 %cmp.i156, label %if.then1.i157, label %Py_DECREF.exit159

if.then1.i157:                                    ; preds = %if.end.i154
  %37 = load ptr, ptr %op.addr.i151, align 8
  call void @_Py_Dealloc(ptr noundef %37) #10
  br label %Py_DECREF.exit159

Py_DECREF.exit159:                                ; preds = %if.then1.i157, %if.end.i154, %if.then.i158
  %38 = load ptr, ptr %res, align 8
  %cmp23 = icmp eq ptr null, %38
  br i1 %cmp23, label %if.then24, label %if.else

if.then24:                                        ; preds = %Py_DECREF.exit159
  br label %error_exit

if.else:                                          ; preds = %Py_DECREF.exit159
  %39 = load ptr, ptr %res, align 8
  %call25 = call ptr @Py_TYPE(ptr noundef %39)
  %call26 = call i32 @PyType_HasFeature(ptr noundef %call25, i64 noundef 268435456)
  %tobool27 = icmp ne i32 %call26, 0
  br i1 %tobool27, label %if.then28, label %if.else29

if.then28:                                        ; preds = %if.else
  store i32 1, ptr %is_unicode, align 4
  br label %if.end41

if.else29:                                        ; preds = %if.else
  %40 = load ptr, ptr %res, align 8
  %call30 = call ptr @Py_TYPE(ptr noundef %40)
  %call31 = call i32 @PyType_HasFeature(ptr noundef %call30, i64 noundef 134217728)
  %tobool32 = icmp ne i32 %call31, 0
  br i1 %tobool32, label %if.then33, label %if.else34

if.then33:                                        ; preds = %if.else29
  store i32 1, ptr %is_bytes, align 4
  br label %if.end40

if.else34:                                        ; preds = %if.else29
  %41 = load ptr, ptr @PyExc_TypeError, align 8
  %42 = load ptr, ptr %o.addr, align 8
  %call35 = call ptr @Py_TYPE(ptr noundef %42)
  %call36 = call ptr @_PyType_Name(ptr noundef %call35)
  %43 = load ptr, ptr %res, align 8
  %call37 = call ptr @Py_TYPE(ptr noundef %43)
  %call38 = call ptr @_PyType_Name(ptr noundef %call37)
  %call39 = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %41, ptr noundef @.str.9, ptr noundef %call36, ptr noundef %call38)
  %44 = load ptr, ptr %res, align 8
  store ptr %44, ptr %op.addr.i142, align 8
  %45 = load ptr, ptr %op.addr.i142, align 8
  store ptr %45, ptr %op.addr.i162, align 8
  %46 = load ptr, ptr %op.addr.i162, align 8
  %47 = load i64, ptr %46, align 8
  %conv.i163 = trunc i64 %47 to i32
  %cmp.i164 = icmp slt i32 %conv.i163, 0
  %conv1.i165 = zext i1 %cmp.i164 to i32
  %tobool.i144 = icmp ne i32 %conv1.i165, 0
  br i1 %tobool.i144, label %if.then.i149, label %if.end.i145

if.then.i149:                                     ; preds = %if.else34
  br label %Py_DECREF.exit150

if.end.i145:                                      ; preds = %if.else34
  %48 = load ptr, ptr %op.addr.i142, align 8
  %49 = load i64, ptr %48, align 8
  %dec.i146 = add i64 %49, -1
  store i64 %dec.i146, ptr %48, align 8
  %cmp.i147 = icmp eq i64 %dec.i146, 0
  br i1 %cmp.i147, label %if.then1.i148, label %Py_DECREF.exit150

if.then1.i148:                                    ; preds = %if.end.i145
  %50 = load ptr, ptr %op.addr.i142, align 8
  call void @_Py_Dealloc(ptr noundef %50) #10
  br label %Py_DECREF.exit150

Py_DECREF.exit150:                                ; preds = %if.then1.i148, %if.end.i145, %if.then.i149
  br label %error_exit

if.end40:                                         ; preds = %if.then33
  br label %if.end41

if.end41:                                         ; preds = %if.end40, %if.then28
  br label %if.end42

if.end42:                                         ; preds = %if.end41
  br label %do.body

do.body:                                          ; preds = %if.end42
  store ptr %o.addr, ptr %_tmp_dst_ptr, align 8
  %51 = load ptr, ptr %_tmp_dst_ptr, align 8
  %52 = load ptr, ptr %51, align 8
  store ptr %52, ptr %_tmp_old_dst, align 8
  %53 = load ptr, ptr %res, align 8
  %54 = load ptr, ptr %_tmp_dst_ptr, align 8
  store ptr %53, ptr %54, align 8
  %55 = load ptr, ptr %_tmp_old_dst, align 8
  store ptr %55, ptr %op.addr.i133, align 8
  %56 = load ptr, ptr %op.addr.i133, align 8
  store ptr %56, ptr %op.addr.i166, align 8
  %57 = load ptr, ptr %op.addr.i166, align 8
  %58 = load i64, ptr %57, align 8
  %conv.i167 = trunc i64 %58 to i32
  %cmp.i168 = icmp slt i32 %conv.i167, 0
  %conv1.i169 = zext i1 %cmp.i168 to i32
  %tobool.i135 = icmp ne i32 %conv1.i169, 0
  br i1 %tobool.i135, label %if.then.i140, label %if.end.i136

if.then.i140:                                     ; preds = %do.body
  br label %Py_DECREF.exit141

if.end.i136:                                      ; preds = %do.body
  %59 = load ptr, ptr %op.addr.i133, align 8
  %60 = load i64, ptr %59, align 8
  %dec.i137 = add i64 %60, -1
  store i64 %dec.i137, ptr %59, align 8
  %cmp.i138 = icmp eq i64 %dec.i137, 0
  br i1 %cmp.i138, label %if.then1.i139, label %Py_DECREF.exit141

if.then1.i139:                                    ; preds = %if.end.i136
  %61 = load ptr, ptr %op.addr.i133, align 8
  call void @_Py_Dealloc(ptr noundef %61) #10
  br label %Py_DECREF.exit141

Py_DECREF.exit141:                                ; preds = %if.then1.i139, %if.end.i136, %if.then.i140
  br label %do.end

do.end:                                           ; preds = %Py_DECREF.exit141
  br label %if.end43

if.end43:                                         ; preds = %do.end, %land.lhs.true14, %land.lhs.true12, %land.end
  %62 = load i32, ptr %is_unicode, align 4
  %tobool44 = icmp ne i32 %62, 0
  br i1 %tobool44, label %if.then45, label %if.else50

if.then45:                                        ; preds = %if.end43
  %63 = load ptr, ptr %o.addr, align 8
  %call46 = call i32 @PyUnicode_FSConverter(ptr noundef %63, ptr noundef %bytes)
  %tobool47 = icmp ne i32 %call46, 0
  br i1 %tobool47, label %if.end49, label %if.then48

if.then48:                                        ; preds = %if.then45
  br label %error_exit

if.end49:                                         ; preds = %if.then45
  br label %if.end98

if.else50:                                        ; preds = %if.end43
  %64 = load i32, ptr %is_bytes, align 4
  %tobool51 = icmp ne i32 %64, 0
  br i1 %tobool51, label %if.then52, label %if.else54

if.then52:                                        ; preds = %if.else50
  %65 = load ptr, ptr %o.addr, align 8
  %call53 = call ptr @_Py_NewRef(ptr noundef %65)
  store ptr %call53, ptr %bytes, align 8
  br label %if.end97

if.else54:                                        ; preds = %if.else50
  %66 = load i32, ptr %is_index, align 4
  %tobool55 = icmp ne i32 %66, 0
  br i1 %tobool55, label %if.then56, label %if.else64

if.then56:                                        ; preds = %if.else54
  %67 = load ptr, ptr %o.addr, align 8
  %68 = load ptr, ptr %path, align 8
  %fd57 = getelementptr inbounds %struct.path_t, ptr %68, i32 0, i32 6
  %call58 = call i32 @_fd_converter(ptr noundef %67, ptr noundef %fd57)
  %tobool59 = icmp ne i32 %call58, 0
  br i1 %tobool59, label %if.end61, label %if.then60

if.then60:                                        ; preds = %if.then56
  br label %error_exit

if.end61:                                         ; preds = %if.then56
  %69 = load ptr, ptr %path, align 8
  %wide62 = getelementptr inbounds %struct.path_t, ptr %69, i32 0, i32 4
  store ptr null, ptr %wide62, align 8
  %70 = load ptr, ptr %path, align 8
  %narrow63 = getelementptr inbounds %struct.path_t, ptr %70, i32 0, i32 5
  store ptr null, ptr %narrow63, align 8
  br label %success_exit

if.else64:                                        ; preds = %if.else54
  br label %error_format

error_format:                                     ; preds = %if.else64, %if.then20
  %71 = load ptr, ptr @PyExc_TypeError, align 8
  %72 = load ptr, ptr %path, align 8
  %function_name = getelementptr inbounds %struct.path_t, ptr %72, i32 0, i32 0
  %73 = load ptr, ptr %function_name, align 8
  %tobool65 = icmp ne ptr %73, null
  br i1 %tobool65, label %cond.true, label %cond.false

cond.true:                                        ; preds = %error_format
  %74 = load ptr, ptr %path, align 8
  %function_name66 = getelementptr inbounds %struct.path_t, ptr %74, i32 0, i32 0
  %75 = load ptr, ptr %function_name66, align 8
  br label %cond.end

cond.false:                                       ; preds = %error_format
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %75, %cond.true ], [ @.str.187, %cond.false ]
  %76 = load ptr, ptr %path, align 8
  %function_name67 = getelementptr inbounds %struct.path_t, ptr %76, i32 0, i32 0
  %77 = load ptr, ptr %function_name67, align 8
  %tobool68 = icmp ne ptr %77, null
  %cond69 = select i1 %tobool68, ptr @.str.188, ptr @.str.187
  %78 = load ptr, ptr %path, align 8
  %argument_name = getelementptr inbounds %struct.path_t, ptr %78, i32 0, i32 1
  %79 = load ptr, ptr %argument_name, align 8
  %tobool70 = icmp ne ptr %79, null
  br i1 %tobool70, label %cond.true71, label %cond.false73

cond.true71:                                      ; preds = %cond.end
  %80 = load ptr, ptr %path, align 8
  %argument_name72 = getelementptr inbounds %struct.path_t, ptr %80, i32 0, i32 1
  %81 = load ptr, ptr %argument_name72, align 8
  br label %cond.end74

cond.false73:                                     ; preds = %cond.end
  br label %cond.end74

cond.end74:                                       ; preds = %cond.false73, %cond.true71
  %cond75 = phi ptr [ %81, %cond.true71 ], [ @.str.183, %cond.false73 ]
  %82 = load ptr, ptr %path, align 8
  %allow_fd76 = getelementptr inbounds %struct.path_t, ptr %82, i32 0, i32 3
  %83 = load i32, ptr %allow_fd76, align 4
  %tobool77 = icmp ne i32 %83, 0
  br i1 %tobool77, label %land.lhs.true78, label %cond.false82

land.lhs.true78:                                  ; preds = %cond.end74
  %84 = load ptr, ptr %path, align 8
  %nullable79 = getelementptr inbounds %struct.path_t, ptr %84, i32 0, i32 2
  %85 = load i32, ptr %nullable79, align 8
  %tobool80 = icmp ne i32 %85, 0
  br i1 %tobool80, label %cond.true81, label %cond.false82

cond.true81:                                      ; preds = %land.lhs.true78
  br label %cond.end92

cond.false82:                                     ; preds = %land.lhs.true78, %cond.end74
  %86 = load ptr, ptr %path, align 8
  %allow_fd83 = getelementptr inbounds %struct.path_t, ptr %86, i32 0, i32 3
  %87 = load i32, ptr %allow_fd83, align 4
  %tobool84 = icmp ne i32 %87, 0
  br i1 %tobool84, label %cond.true85, label %cond.false86

cond.true85:                                      ; preds = %cond.false82
  br label %cond.end90

cond.false86:                                     ; preds = %cond.false82
  %88 = load ptr, ptr %path, align 8
  %nullable87 = getelementptr inbounds %struct.path_t, ptr %88, i32 0, i32 2
  %89 = load i32, ptr %nullable87, align 8
  %tobool88 = icmp ne i32 %89, 0
  %cond89 = select i1 %tobool88, ptr @.str.191, ptr @.str.192
  br label %cond.end90

cond.end90:                                       ; preds = %cond.false86, %cond.true85
  %cond91 = phi ptr [ @.str.190, %cond.true85 ], [ %cond89, %cond.false86 ]
  br label %cond.end92

cond.end92:                                       ; preds = %cond.end90, %cond.true81
  %cond93 = phi ptr [ @.str.189, %cond.true81 ], [ %cond91, %cond.end90 ]
  %90 = load ptr, ptr %o.addr, align 8
  %call94 = call ptr @Py_TYPE(ptr noundef %90)
  %call95 = call ptr @_PyType_Name(ptr noundef %call94)
  %call96 = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %71, ptr noundef @.str.186, ptr noundef %cond, ptr noundef %cond69, ptr noundef %cond75, ptr noundef %cond93, ptr noundef %call95)
  br label %error_exit

if.end97:                                         ; preds = %if.then52
  br label %if.end98

if.end98:                                         ; preds = %if.end97, %if.end49
  %91 = load ptr, ptr %bytes, align 8
  %call99 = call i64 @PyBytes_GET_SIZE(ptr noundef %91)
  store i64 %call99, ptr %length, align 8
  %92 = load ptr, ptr %bytes, align 8
  %call100 = call ptr @PyBytes_AS_STRING(ptr noundef %92)
  store ptr %call100, ptr %narrow, align 8
  %93 = load i64, ptr %length, align 8
  %94 = load ptr, ptr %narrow, align 8
  %call101 = call i64 @strlen(ptr noundef %94) #13
  %cmp102 = icmp ne i64 %93, %call101
  br i1 %cmp102, label %if.then103, label %if.end122

if.then103:                                       ; preds = %if.end98
  %95 = load ptr, ptr @PyExc_ValueError, align 8
  %96 = load ptr, ptr %path, align 8
  %function_name104 = getelementptr inbounds %struct.path_t, ptr %96, i32 0, i32 0
  %97 = load ptr, ptr %function_name104, align 8
  %tobool105 = icmp ne ptr %97, null
  br i1 %tobool105, label %cond.true106, label %cond.false108

cond.true106:                                     ; preds = %if.then103
  %98 = load ptr, ptr %path, align 8
  %function_name107 = getelementptr inbounds %struct.path_t, ptr %98, i32 0, i32 0
  %99 = load ptr, ptr %function_name107, align 8
  br label %cond.end109

cond.false108:                                    ; preds = %if.then103
  br label %cond.end109

cond.end109:                                      ; preds = %cond.false108, %cond.true106
  %cond110 = phi ptr [ %99, %cond.true106 ], [ @.str.187, %cond.false108 ]
  %100 = load ptr, ptr %path, align 8
  %function_name111 = getelementptr inbounds %struct.path_t, ptr %100, i32 0, i32 0
  %101 = load ptr, ptr %function_name111, align 8
  %tobool112 = icmp ne ptr %101, null
  %cond113 = select i1 %tobool112, ptr @.str.188, ptr @.str.187
  %102 = load ptr, ptr %path, align 8
  %argument_name114 = getelementptr inbounds %struct.path_t, ptr %102, i32 0, i32 1
  %103 = load ptr, ptr %argument_name114, align 8
  %tobool115 = icmp ne ptr %103, null
  br i1 %tobool115, label %cond.true116, label %cond.false118

cond.true116:                                     ; preds = %cond.end109
  %104 = load ptr, ptr %path, align 8
  %argument_name117 = getelementptr inbounds %struct.path_t, ptr %104, i32 0, i32 1
  %105 = load ptr, ptr %argument_name117, align 8
  br label %cond.end119

cond.false118:                                    ; preds = %cond.end109
  br label %cond.end119

cond.end119:                                      ; preds = %cond.false118, %cond.true116
  %cond120 = phi ptr [ %105, %cond.true116 ], [ @.str.183, %cond.false118 ]
  %call121 = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %95, ptr noundef @.str.193, ptr noundef %cond110, ptr noundef %cond113, ptr noundef %cond120)
  br label %error_exit

if.end122:                                        ; preds = %if.end98
  %106 = load ptr, ptr %path, align 8
  %wide123 = getelementptr inbounds %struct.path_t, ptr %106, i32 0, i32 4
  store ptr null, ptr %wide123, align 8
  %107 = load ptr, ptr %narrow, align 8
  %108 = load ptr, ptr %path, align 8
  %narrow124 = getelementptr inbounds %struct.path_t, ptr %108, i32 0, i32 5
  store ptr %107, ptr %narrow124, align 8
  %109 = load ptr, ptr %bytes, align 8
  %110 = load ptr, ptr %o.addr, align 8
  %cmp125 = icmp eq ptr %109, %110
  br i1 %cmp125, label %if.then126, label %if.else127

if.then126:                                       ; preds = %if.end122
  %111 = load ptr, ptr %bytes, align 8
  store ptr %111, ptr %op.addr.i, align 8
  %112 = load ptr, ptr %op.addr.i, align 8
  store ptr %112, ptr %op.addr.i170, align 8
  %113 = load ptr, ptr %op.addr.i170, align 8
  %114 = load i64, ptr %113, align 8
  %conv.i171 = trunc i64 %114 to i32
  %cmp.i172 = icmp slt i32 %conv.i171, 0
  %conv1.i173 = zext i1 %cmp.i172 to i32
  %tobool.i = icmp ne i32 %conv1.i173, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then126
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.then126
  %115 = load ptr, ptr %op.addr.i, align 8
  %116 = load i64, ptr %115, align 8
  %dec.i = add i64 %116, -1
  store i64 %dec.i, ptr %115, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %117 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %117) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  br label %if.end129

if.else127:                                       ; preds = %if.end122
  %118 = load ptr, ptr %bytes, align 8
  %119 = load ptr, ptr %path, align 8
  %cleanup128 = getelementptr inbounds %struct.path_t, ptr %119, i32 0, i32 9
  store ptr %118, ptr %cleanup128, align 8
  br label %if.end129

if.end129:                                        ; preds = %if.else127, %Py_DECREF.exit
  %120 = load ptr, ptr %path, align 8
  %fd130 = getelementptr inbounds %struct.path_t, ptr %120, i32 0, i32 6
  store i32 -1, ptr %fd130, align 8
  br label %success_exit

success_exit:                                     ; preds = %if.end129, %if.end61, %if.then2
  %121 = load i64, ptr %length, align 8
  %122 = load ptr, ptr %path, align 8
  %length131 = getelementptr inbounds %struct.path_t, ptr %122, i32 0, i32 7
  store i64 %121, ptr %length131, align 8
  %123 = load ptr, ptr %o.addr, align 8
  %124 = load ptr, ptr %path, align 8
  %object132 = getelementptr inbounds %struct.path_t, ptr %124, i32 0, i32 8
  store ptr %123, ptr %object132, align 8
  store i32 131072, ptr %retval, align 4
  br label %return

error_exit:                                       ; preds = %cond.end119, %cond.end92, %if.then60, %if.then48, %Py_DECREF.exit150, %if.then24
  %125 = load ptr, ptr %o.addr, align 8
  call void @Py_XDECREF(ptr noundef %125)
  %126 = load ptr, ptr %bytes, align 8
  call void @Py_XDECREF(ptr noundef %126)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %error_exit, %success_exit, %if.then
  %127 = load i32, ptr %retval, align 4
  ret i32 %127
}

; Function Attrs: nounwind uwtable
define internal i32 @dir_fd_converter(ptr noundef %o, ptr noundef %p) #0 {
entry:
  %retval = alloca i32, align 4
  %o.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  store ptr %o, ptr %o.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %o.addr, align 8
  %cmp = icmp eq ptr %0, @_Py_NoneStruct
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %p.addr, align 8
  store i32 -100, ptr %1, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %2 = load ptr, ptr %o.addr, align 8
  %call = call i32 @PyIndex_Check(ptr noundef %2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then1, label %if.else3

if.then1:                                         ; preds = %if.else
  %3 = load ptr, ptr %o.addr, align 8
  %4 = load ptr, ptr %p.addr, align 8
  %call2 = call i32 @_fd_converter(ptr noundef %3, ptr noundef %4)
  store i32 %call2, ptr %retval, align 4
  br label %return

if.else3:                                         ; preds = %if.else
  %5 = load ptr, ptr @PyExc_TypeError, align 8
  %6 = load ptr, ptr %o.addr, align 8
  %call4 = call ptr @Py_TYPE(ptr noundef %6)
  %call5 = call ptr @_PyType_Name(ptr noundef %call4)
  %call6 = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %5, ptr noundef @.str.196, ptr noundef %call5)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.else3, %if.then1, %if.then
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

declare i32 @PyObject_IsTrue(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @os_stat_impl(ptr noundef %module, ptr noundef %path, i32 noundef %dir_fd, i32 noundef %follow_symlinks) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %path.addr = alloca ptr, align 8
  %dir_fd.addr = alloca i32, align 4
  %follow_symlinks.addr = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %path, ptr %path.addr, align 8
  store i32 %dir_fd, ptr %dir_fd.addr, align 4
  store i32 %follow_symlinks, ptr %follow_symlinks.addr, align 4
  %0 = load ptr, ptr %module.addr, align 8
  %1 = load ptr, ptr %path.addr, align 8
  %2 = load i32, ptr %dir_fd.addr, align 4
  %3 = load i32, ptr %follow_symlinks.addr, align 4
  %call = call ptr @posix_do_stat(ptr noundef %0, ptr noundef @.str.12, ptr noundef %1, i32 noundef %2, i32 noundef %3)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal void @path_cleanup(ptr noundef %path) #0 {
entry:
  %op.addr.i21 = alloca ptr, align 8
  %op.addr.i19 = alloca ptr, align 8
  %op.addr.i10 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %path.addr = alloca ptr, align 8
  %wide = alloca ptr, align 8
  %_tmp_op_ptr = alloca ptr, align 8
  %_tmp_old_op = alloca ptr, align 8
  %_tmp_op_ptr4 = alloca ptr, align 8
  %_tmp_old_op5 = alloca ptr, align 8
  store ptr %path, ptr %path.addr, align 8
  %0 = load ptr, ptr %path.addr, align 8
  %wide1 = getelementptr inbounds %struct.path_t, ptr %0, i32 0, i32 4
  %1 = load ptr, ptr %wide1, align 8
  store ptr %1, ptr %wide, align 8
  %2 = load ptr, ptr %path.addr, align 8
  %wide2 = getelementptr inbounds %struct.path_t, ptr %2, i32 0, i32 4
  store ptr null, ptr %wide2, align 8
  %3 = load ptr, ptr %wide, align 8
  call void @PyMem_Free(ptr noundef %3)
  br label %do.body

do.body:                                          ; preds = %entry
  %4 = load ptr, ptr %path.addr, align 8
  %object = getelementptr inbounds %struct.path_t, ptr %4, i32 0, i32 8
  store ptr %object, ptr %_tmp_op_ptr, align 8
  %5 = load ptr, ptr %_tmp_op_ptr, align 8
  %6 = load ptr, ptr %5, align 8
  store ptr %6, ptr %_tmp_old_op, align 8
  %7 = load ptr, ptr %_tmp_old_op, align 8
  %cmp = icmp ne ptr %7, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  %8 = load ptr, ptr %_tmp_op_ptr, align 8
  store ptr null, ptr %8, align 8
  %9 = load ptr, ptr %_tmp_old_op, align 8
  store ptr %9, ptr %op.addr.i10, align 8
  %10 = load ptr, ptr %op.addr.i10, align 8
  store ptr %10, ptr %op.addr.i19, align 8
  %11 = load ptr, ptr %op.addr.i19, align 8
  %12 = load i64, ptr %11, align 8
  %conv.i = trunc i64 %12 to i32
  %cmp.i20 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i20 to i32
  %tobool.i12 = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i12, label %if.then.i17, label %if.end.i13

if.then.i17:                                      ; preds = %if.then
  br label %Py_DECREF.exit18

if.end.i13:                                       ; preds = %if.then
  %13 = load ptr, ptr %op.addr.i10, align 8
  %14 = load i64, ptr %13, align 8
  %dec.i14 = add i64 %14, -1
  store i64 %dec.i14, ptr %13, align 8
  %cmp.i15 = icmp eq i64 %dec.i14, 0
  br i1 %cmp.i15, label %if.then1.i16, label %Py_DECREF.exit18

if.then1.i16:                                     ; preds = %if.end.i13
  %15 = load ptr, ptr %op.addr.i10, align 8
  call void @_Py_Dealloc(ptr noundef %15) #10
  br label %Py_DECREF.exit18

Py_DECREF.exit18:                                 ; preds = %if.then1.i16, %if.end.i13, %if.then.i17
  br label %if.end

if.end:                                           ; preds = %Py_DECREF.exit18, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  br label %do.body3

do.body3:                                         ; preds = %do.end
  %16 = load ptr, ptr %path.addr, align 8
  %cleanup = getelementptr inbounds %struct.path_t, ptr %16, i32 0, i32 9
  store ptr %cleanup, ptr %_tmp_op_ptr4, align 8
  %17 = load ptr, ptr %_tmp_op_ptr4, align 8
  %18 = load ptr, ptr %17, align 8
  store ptr %18, ptr %_tmp_old_op5, align 8
  %19 = load ptr, ptr %_tmp_old_op5, align 8
  %cmp6 = icmp ne ptr %19, null
  br i1 %cmp6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %do.body3
  %20 = load ptr, ptr %_tmp_op_ptr4, align 8
  store ptr null, ptr %20, align 8
  %21 = load ptr, ptr %_tmp_old_op5, align 8
  store ptr %21, ptr %op.addr.i, align 8
  %22 = load ptr, ptr %op.addr.i, align 8
  store ptr %22, ptr %op.addr.i21, align 8
  %23 = load ptr, ptr %op.addr.i21, align 8
  %24 = load i64, ptr %23, align 8
  %conv.i22 = trunc i64 %24 to i32
  %cmp.i23 = icmp slt i32 %conv.i22, 0
  %conv1.i24 = zext i1 %cmp.i23 to i32
  %tobool.i = icmp ne i32 %conv1.i24, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then7
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.then7
  %25 = load ptr, ptr %op.addr.i, align 8
  %26 = load i64, ptr %25, align 8
  %dec.i = add i64 %26, -1
  store i64 %dec.i, ptr %25, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %27 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %27) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  br label %if.end8

if.end8:                                          ; preds = %Py_DECREF.exit, %do.body3
  br label %do.end9

do.end9:                                          ; preds = %if.end8
  ret void
}

declare i32 @PyIndex_Check(ptr noundef) #1

declare i32 @PyUnicode_FSConverter(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal i32 @_fd_converter(ptr noundef %o, ptr noundef %p) #0 {
entry:
  %op.addr.i11 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca i32, align 4
  %o.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %overflow = alloca i32, align 4
  %long_value = alloca i64, align 8
  %index = alloca ptr, align 8
  store ptr %o, ptr %o.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %o.addr, align 8
  %call = call ptr @_PyNumber_Index(ptr noundef %0)
  store ptr %call, ptr %index, align 8
  %1 = load ptr, ptr %index, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %index, align 8
  %call1 = call i64 @PyLong_AsLongAndOverflow(ptr noundef %2, ptr noundef %overflow)
  store i64 %call1, ptr %long_value, align 8
  %3 = load ptr, ptr %index, align 8
  store ptr %3, ptr %op.addr.i, align 8
  %4 = load ptr, ptr %op.addr.i, align 8
  store ptr %4, ptr %op.addr.i11, align 8
  %5 = load ptr, ptr %op.addr.i11, align 8
  %6 = load i64, ptr %5, align 8
  %conv.i = trunc i64 %6 to i32
  %cmp.i12 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i12 to i32
  %tobool.i = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.end
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.end
  %7 = load ptr, ptr %op.addr.i, align 8
  %8 = load i64, ptr %7, align 8
  %dec.i = add i64 %8, -1
  store i64 %dec.i, ptr %7, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %9 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %9) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  %10 = load i32, ptr %overflow, align 4
  %cmp2 = icmp sgt i32 %10, 0
  br i1 %cmp2, label %if.then4, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %Py_DECREF.exit
  %11 = load i64, ptr %long_value, align 8
  %cmp3 = icmp sgt i64 %11, 2147483647
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %lor.lhs.false, %Py_DECREF.exit
  %12 = load ptr, ptr @PyExc_OverflowError, align 8
  call void @PyErr_SetString(ptr noundef %12, ptr noundef @.str.194)
  store i32 0, ptr %retval, align 4
  br label %return

if.end5:                                          ; preds = %lor.lhs.false
  %13 = load i32, ptr %overflow, align 4
  %cmp6 = icmp slt i32 %13, 0
  br i1 %cmp6, label %if.then9, label %lor.lhs.false7

lor.lhs.false7:                                   ; preds = %if.end5
  %14 = load i64, ptr %long_value, align 8
  %cmp8 = icmp slt i64 %14, -2147483648
  br i1 %cmp8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %lor.lhs.false7, %if.end5
  %15 = load ptr, ptr @PyExc_OverflowError, align 8
  call void @PyErr_SetString(ptr noundef %15, ptr noundef @.str.195)
  store i32 0, ptr %retval, align 4
  br label %return

if.end10:                                         ; preds = %lor.lhs.false7
  %16 = load i64, ptr %long_value, align 8
  %conv = trunc i64 %16 to i32
  %17 = load ptr, ptr %p.addr, align 8
  store i32 %conv, ptr %17, align 4
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end10, %if.then9, %if.then4, %if.then
  %18 = load i32, ptr %retval, align 4
  ret i32 %18
}

; Function Attrs: nounwind uwtable
define internal i64 @PyBytes_GET_SIZE(ptr noundef %op) #0 {
entry:
  %op.addr = alloca ptr, align 8
  %self = alloca ptr, align 8
  store ptr %op, ptr %op.addr, align 8
  %0 = load ptr, ptr %op.addr, align 8
  store ptr %0, ptr %self, align 8
  %1 = load ptr, ptr %self, align 8
  %call = call i64 @Py_SIZE(ptr noundef %1)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define internal ptr @PyBytes_AS_STRING(ptr noundef %op) #0 {
entry:
  %op.addr = alloca ptr, align 8
  store ptr %op, ptr %op.addr, align 8
  %0 = load ptr, ptr %op.addr, align 8
  %ob_sval = getelementptr inbounds %struct.PyBytesObject, ptr %0, i32 0, i32 2
  %arraydecay = getelementptr inbounds [1 x i8], ptr %ob_sval, i64 0, i64 0
  ret ptr %arraydecay
}

; Function Attrs: nounwind willreturn memory(read)
declare i64 @strlen(ptr noundef) #7

; Function Attrs: nounwind uwtable
define internal void @Py_XDECREF(ptr noundef %op) #0 {
entry:
  %op.addr.i1 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %op.addr = alloca ptr, align 8
  store ptr %op, ptr %op.addr, align 8
  %0 = load ptr, ptr %op.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %op.addr, align 8
  store ptr %1, ptr %op.addr.i, align 8
  %2 = load ptr, ptr %op.addr.i, align 8
  store ptr %2, ptr %op.addr.i1, align 8
  %3 = load ptr, ptr %op.addr.i1, align 8
  %4 = load i64, ptr %3, align 8
  %conv.i = trunc i64 %4 to i32
  %cmp.i2 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i2 to i32
  %tobool.i = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.then
  %5 = load ptr, ptr %op.addr.i, align 8
  %6 = load i64, ptr %5, align 8
  %dec.i = add i64 %6, -1
  store i64 %dec.i, ptr %5, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %7 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %7) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  br label %if.end

if.end:                                           ; preds = %Py_DECREF.exit, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal ptr @posix_do_stat(ptr noundef %module, ptr noundef %function_name, ptr noundef %path, i32 noundef %dir_fd, i32 noundef %follow_symlinks) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %function_name.addr = alloca ptr, align 8
  %path.addr = alloca ptr, align 8
  %dir_fd.addr = alloca i32, align 4
  %follow_symlinks.addr = alloca i32, align 4
  %st = alloca %struct.stat, align 8
  %result = alloca i32, align 4
  %fstatat_unavailable = alloca i32, align 4
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %function_name, ptr %function_name.addr, align 8
  store ptr %path, ptr %path.addr, align 8
  store i32 %dir_fd, ptr %dir_fd.addr, align 4
  store i32 %follow_symlinks, ptr %follow_symlinks.addr, align 4
  store i32 0, ptr %fstatat_unavailable, align 4
  %0 = load ptr, ptr %path.addr, align 8
  %1 = load i32, ptr %dir_fd.addr, align 4
  %call = call i32 @path_and_dir_fd_invalid(ptr noundef @.str.12, ptr noundef %0, i32 noundef %1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load i32, ptr %dir_fd.addr, align 4
  %3 = load ptr, ptr %path.addr, align 8
  %fd = getelementptr inbounds %struct.path_t, ptr %3, i32 0, i32 6
  %4 = load i32, ptr %fd, align 8
  %call1 = call i32 @dir_fd_and_fd_invalid(ptr noundef @.str.12, i32 noundef %2, i32 noundef %4)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then, label %lor.lhs.false3

lor.lhs.false3:                                   ; preds = %lor.lhs.false
  %5 = load ptr, ptr %path.addr, align 8
  %fd4 = getelementptr inbounds %struct.path_t, ptr %5, i32 0, i32 6
  %6 = load i32, ptr %fd4, align 8
  %7 = load i32, ptr %follow_symlinks.addr, align 4
  %call5 = call i32 @fd_and_follow_symlinks_invalid(ptr noundef @.str.12, i32 noundef %6, i32 noundef %7)
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false3, %lor.lhs.false, %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false3
  %call7 = call ptr @PyEval_SaveThread()
  store ptr %call7, ptr %_save, align 8
  %8 = load ptr, ptr %path.addr, align 8
  %fd8 = getelementptr inbounds %struct.path_t, ptr %8, i32 0, i32 6
  %9 = load i32, ptr %fd8, align 8
  %cmp = icmp ne i32 %9, -1
  br i1 %cmp, label %if.then9, label %if.else

if.then9:                                         ; preds = %if.end
  %10 = load ptr, ptr %path.addr, align 8
  %fd10 = getelementptr inbounds %struct.path_t, ptr %10, i32 0, i32 6
  %11 = load i32, ptr %fd10, align 8
  %call11 = call i32 @fstat64(i32 noundef %11, ptr noundef %st) #10
  store i32 %call11, ptr %result, align 4
  br label %if.end29

if.else:                                          ; preds = %if.end
  %12 = load i32, ptr %follow_symlinks.addr, align 4
  %tobool12 = icmp ne i32 %12, 0
  br i1 %tobool12, label %if.else16, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.else
  %13 = load i32, ptr %dir_fd.addr, align 4
  %cmp13 = icmp eq i32 %13, -100
  br i1 %cmp13, label %if.then14, label %if.else16

if.then14:                                        ; preds = %land.lhs.true
  %14 = load ptr, ptr %path.addr, align 8
  %narrow = getelementptr inbounds %struct.path_t, ptr %14, i32 0, i32 5
  %15 = load ptr, ptr %narrow, align 8
  %call15 = call i32 @lstat64(ptr noundef %15, ptr noundef %st) #10
  store i32 %call15, ptr %result, align 4
  br label %if.end28

if.else16:                                        ; preds = %land.lhs.true, %if.else
  %16 = load i32, ptr %dir_fd.addr, align 4
  %cmp17 = icmp ne i32 %16, -100
  br i1 %cmp17, label %if.then20, label %lor.lhs.false18

lor.lhs.false18:                                  ; preds = %if.else16
  %17 = load i32, ptr %follow_symlinks.addr, align 4
  %tobool19 = icmp ne i32 %17, 0
  br i1 %tobool19, label %if.else24, label %if.then20

if.then20:                                        ; preds = %lor.lhs.false18, %if.else16
  %18 = load i32, ptr %dir_fd.addr, align 4
  %19 = load ptr, ptr %path.addr, align 8
  %narrow21 = getelementptr inbounds %struct.path_t, ptr %19, i32 0, i32 5
  %20 = load ptr, ptr %narrow21, align 8
  %21 = load i32, ptr %follow_symlinks.addr, align 4
  %tobool22 = icmp ne i32 %21, 0
  %cond = select i1 %tobool22, i32 0, i32 256
  %call23 = call i32 @fstatat64(i32 noundef %18, ptr noundef %20, ptr noundef %st, i32 noundef %cond) #10
  store i32 %call23, ptr %result, align 4
  br label %if.end27

if.else24:                                        ; preds = %lor.lhs.false18
  %22 = load ptr, ptr %path.addr, align 8
  %narrow25 = getelementptr inbounds %struct.path_t, ptr %22, i32 0, i32 5
  %23 = load ptr, ptr %narrow25, align 8
  %call26 = call i32 @stat64(ptr noundef %23, ptr noundef %st) #10
  store i32 %call26, ptr %result, align 4
  br label %if.end27

if.end27:                                         ; preds = %if.else24, %if.then20
  br label %if.end28

if.end28:                                         ; preds = %if.end27, %if.then14
  br label %if.end29

if.end29:                                         ; preds = %if.end28, %if.then9
  %24 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %24)
  %25 = load i32, ptr %fstatat_unavailable, align 4
  %tobool30 = icmp ne i32 %25, 0
  br i1 %tobool30, label %if.then31, label %if.end32

if.then31:                                        ; preds = %if.end29
  call void @argument_unavailable_error(ptr noundef @.str.12, ptr noundef @.str.184)
  store ptr null, ptr %retval, align 8
  br label %return

if.end32:                                         ; preds = %if.end29
  %26 = load i32, ptr %result, align 4
  %cmp33 = icmp ne i32 %26, 0
  br i1 %cmp33, label %if.then34, label %if.end36

if.then34:                                        ; preds = %if.end32
  %27 = load ptr, ptr %path.addr, align 8
  %call35 = call ptr @path_error(ptr noundef %27)
  store ptr %call35, ptr %retval, align 8
  br label %return

if.end36:                                         ; preds = %if.end32
  %28 = load ptr, ptr %module.addr, align 8
  %call37 = call ptr @_pystat_fromstructstat(ptr noundef %28, ptr noundef %st)
  store ptr %call37, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end36, %if.then34, %if.then31, %if.then
  %29 = load ptr, ptr %retval, align 8
  ret ptr %29
}

; Function Attrs: nounwind uwtable
define internal i32 @path_and_dir_fd_invalid(ptr noundef %function_name, ptr noundef %path, i32 noundef %dir_fd) #0 {
entry:
  %retval = alloca i32, align 4
  %function_name.addr = alloca ptr, align 8
  %path.addr = alloca ptr, align 8
  %dir_fd.addr = alloca i32, align 4
  store ptr %function_name, ptr %function_name.addr, align 8
  store ptr %path, ptr %path.addr, align 8
  store i32 %dir_fd, ptr %dir_fd.addr, align 4
  %0 = load ptr, ptr %path.addr, align 8
  %wide = getelementptr inbounds %struct.path_t, ptr %0, i32 0, i32 4
  %1 = load ptr, ptr %wide, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %2 = load i32, ptr %dir_fd.addr, align 4
  %cmp = icmp ne i32 %2, -100
  br i1 %cmp, label %land.lhs.true1, label %if.end

land.lhs.true1:                                   ; preds = %land.lhs.true
  %3 = load ptr, ptr %path.addr, align 8
  %narrow = getelementptr inbounds %struct.path_t, ptr %3, i32 0, i32 5
  %4 = load ptr, ptr %narrow, align 8
  %tobool2 = icmp ne ptr %4, null
  br i1 %tobool2, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true1
  %5 = load ptr, ptr @PyExc_ValueError, align 8
  %6 = load ptr, ptr %function_name.addr, align 8
  %call = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %5, ptr noundef @.str.197, ptr noundef %6)
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true1, %land.lhs.true, %entry
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal i32 @dir_fd_and_fd_invalid(ptr noundef %function_name, i32 noundef %dir_fd, i32 noundef %fd) #0 {
entry:
  %retval = alloca i32, align 4
  %function_name.addr = alloca ptr, align 8
  %dir_fd.addr = alloca i32, align 4
  %fd.addr = alloca i32, align 4
  store ptr %function_name, ptr %function_name.addr, align 8
  store i32 %dir_fd, ptr %dir_fd.addr, align 4
  store i32 %fd, ptr %fd.addr, align 4
  %0 = load i32, ptr %dir_fd.addr, align 4
  %cmp = icmp ne i32 %0, -100
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load i32, ptr %fd.addr, align 4
  %cmp1 = icmp ne i32 %1, -1
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %2 = load ptr, ptr @PyExc_ValueError, align 8
  %3 = load ptr, ptr %function_name.addr, align 8
  %call = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %2, ptr noundef @.str.198, ptr noundef %3)
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load i32, ptr %retval, align 4
  ret i32 %4
}

; Function Attrs: nounwind uwtable
define internal i32 @fd_and_follow_symlinks_invalid(ptr noundef %function_name, i32 noundef %fd, i32 noundef %follow_symlinks) #0 {
entry:
  %retval = alloca i32, align 4
  %function_name.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %follow_symlinks.addr = alloca i32, align 4
  store ptr %function_name, ptr %function_name.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i32 %follow_symlinks, ptr %follow_symlinks.addr, align 4
  %0 = load i32, ptr %fd.addr, align 4
  %cmp = icmp sgt i32 %0, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load i32, ptr %follow_symlinks.addr, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %2 = load ptr, ptr @PyExc_ValueError, align 8
  %3 = load ptr, ptr %function_name.addr, align 8
  %call = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %2, ptr noundef @.str.199, ptr noundef %3)
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load i32, ptr %retval, align 4
  ret i32 %4
}

declare ptr @PyEval_SaveThread() #1

; Function Attrs: nounwind
declare i32 @fstat64(i32 noundef, ptr noundef) #4

; Function Attrs: nounwind
declare i32 @lstat64(ptr noundef, ptr noundef) #4

; Function Attrs: nounwind
declare i32 @fstatat64(i32 noundef, ptr noundef, ptr noundef, i32 noundef) #4

; Function Attrs: nounwind
declare i32 @stat64(ptr noundef, ptr noundef) #4

declare void @PyEval_RestoreThread(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal void @argument_unavailable_error(ptr noundef %function_name, ptr noundef %argument_name) #0 {
entry:
  %function_name.addr = alloca ptr, align 8
  %argument_name.addr = alloca ptr, align 8
  store ptr %function_name, ptr %function_name.addr, align 8
  store ptr %argument_name, ptr %argument_name.addr, align 8
  %0 = load ptr, ptr @PyExc_NotImplementedError, align 8
  %1 = load ptr, ptr %function_name.addr, align 8
  %cmp = icmp ne ptr %1, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %function_name.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %2, %cond.true ], [ @.str.187, %cond.false ]
  %3 = load ptr, ptr %function_name.addr, align 8
  %cmp1 = icmp ne ptr %3, null
  %cond2 = select i1 %cmp1, ptr @.str.188, ptr @.str.187
  %4 = load ptr, ptr %argument_name.addr, align 8
  %call = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %0, ptr noundef @.str.200, ptr noundef %cond, ptr noundef %cond2, ptr noundef %4)
  ret void
}

; Function Attrs: nounwind uwtable
define internal ptr @path_error(ptr noundef %path) #0 {
entry:
  %path.addr = alloca ptr, align 8
  store ptr %path, ptr %path.addr, align 8
  %0 = load ptr, ptr %path.addr, align 8
  %object = getelementptr inbounds %struct.path_t, ptr %0, i32 0, i32 8
  %1 = load ptr, ptr %object, align 8
  %call = call ptr @path_object_error(ptr noundef %1)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @_pystat_fromstructstat(ptr noundef %module, ptr noundef %st) #0 {
entry:
  %op.addr.i102 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %st.addr = alloca ptr, align 8
  %StatResultType = alloca ptr, align 8
  %v = alloca ptr, align 8
  %obj = alloca ptr, align 8
  %obj9 = alloca ptr, align 8
  %obj17 = alloca ptr, align 8
  %obj25 = alloca ptr, align 8
  %obj33 = alloca ptr, align 8
  %obj41 = alloca ptr, align 8
  %obj49 = alloca ptr, align 8
  %ansec = alloca i64, align 8
  %mnsec = alloca i64, align 8
  %cnsec = alloca i64, align 8
  %obj79 = alloca ptr, align 8
  %obj87 = alloca ptr, align 8
  %obj95 = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %st, ptr %st.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %call = call ptr @get_posix_state(ptr noundef %0)
  %StatResultType1 = getelementptr inbounds %struct._posixstate, ptr %call, i32 0, i32 5
  %1 = load ptr, ptr %StatResultType1, align 8
  store ptr %1, ptr %StatResultType, align 8
  %2 = load ptr, ptr %StatResultType, align 8
  %call2 = call ptr @PyStructSequence_New(ptr noundef %2)
  store ptr %call2, ptr %v, align 8
  %3 = load ptr, ptr %v, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.end
  %4 = load ptr, ptr %st.addr, align 8
  %st_mode = getelementptr inbounds %struct.stat, ptr %4, i32 0, i32 3
  %5 = load i32, ptr %st_mode, align 8
  %conv = zext i32 %5 to i64
  %call3 = call ptr @PyLong_FromLong(i64 noundef %conv)
  store ptr %call3, ptr %obj, align 8
  %6 = load ptr, ptr %obj, align 8
  %cmp4 = icmp eq ptr %6, null
  br i1 %cmp4, label %if.then6, label %if.end7

if.then6:                                         ; preds = %do.body
  br label %error

if.end7:                                          ; preds = %do.body
  %7 = load ptr, ptr %v, align 8
  %8 = load ptr, ptr %obj, align 8
  call void @PyStructSequence_SetItem(ptr noundef %7, i64 noundef 0, ptr noundef %8)
  br label %do.end

do.end:                                           ; preds = %if.end7
  br label %do.body8

do.body8:                                         ; preds = %do.end
  %9 = load ptr, ptr %st.addr, align 8
  %st_ino = getelementptr inbounds %struct.stat, ptr %9, i32 0, i32 1
  %10 = load i64, ptr %st_ino, align 8
  %call10 = call ptr @PyLong_FromUnsignedLongLong(i64 noundef %10)
  store ptr %call10, ptr %obj9, align 8
  %11 = load ptr, ptr %obj9, align 8
  %cmp11 = icmp eq ptr %11, null
  br i1 %cmp11, label %if.then13, label %if.end14

if.then13:                                        ; preds = %do.body8
  br label %error

if.end14:                                         ; preds = %do.body8
  %12 = load ptr, ptr %v, align 8
  %13 = load ptr, ptr %obj9, align 8
  call void @PyStructSequence_SetItem(ptr noundef %12, i64 noundef 1, ptr noundef %13)
  br label %do.end15

do.end15:                                         ; preds = %if.end14
  br label %do.body16

do.body16:                                        ; preds = %do.end15
  %14 = load ptr, ptr %st.addr, align 8
  %st_dev = getelementptr inbounds %struct.stat, ptr %14, i32 0, i32 0
  %15 = load i64, ptr %st_dev, align 8
  %call18 = call ptr @PyLong_FromLongLong(i64 noundef %15)
  store ptr %call18, ptr %obj17, align 8
  %16 = load ptr, ptr %obj17, align 8
  %cmp19 = icmp eq ptr %16, null
  br i1 %cmp19, label %if.then21, label %if.end22

if.then21:                                        ; preds = %do.body16
  br label %error

if.end22:                                         ; preds = %do.body16
  %17 = load ptr, ptr %v, align 8
  %18 = load ptr, ptr %obj17, align 8
  call void @PyStructSequence_SetItem(ptr noundef %17, i64 noundef 2, ptr noundef %18)
  br label %do.end23

do.end23:                                         ; preds = %if.end22
  br label %do.body24

do.body24:                                        ; preds = %do.end23
  %19 = load ptr, ptr %st.addr, align 8
  %st_nlink = getelementptr inbounds %struct.stat, ptr %19, i32 0, i32 2
  %20 = load i64, ptr %st_nlink, align 8
  %call26 = call ptr @PyLong_FromLong(i64 noundef %20)
  store ptr %call26, ptr %obj25, align 8
  %21 = load ptr, ptr %obj25, align 8
  %cmp27 = icmp eq ptr %21, null
  br i1 %cmp27, label %if.then29, label %if.end30

if.then29:                                        ; preds = %do.body24
  br label %error

if.end30:                                         ; preds = %do.body24
  %22 = load ptr, ptr %v, align 8
  %23 = load ptr, ptr %obj25, align 8
  call void @PyStructSequence_SetItem(ptr noundef %22, i64 noundef 3, ptr noundef %23)
  br label %do.end31

do.end31:                                         ; preds = %if.end30
  br label %do.body32

do.body32:                                        ; preds = %do.end31
  %24 = load ptr, ptr %st.addr, align 8
  %st_uid = getelementptr inbounds %struct.stat, ptr %24, i32 0, i32 4
  %25 = load i32, ptr %st_uid, align 4
  %call34 = call ptr @_PyLong_FromUid(i32 noundef %25)
  store ptr %call34, ptr %obj33, align 8
  %26 = load ptr, ptr %obj33, align 8
  %cmp35 = icmp eq ptr %26, null
  br i1 %cmp35, label %if.then37, label %if.end38

if.then37:                                        ; preds = %do.body32
  br label %error

if.end38:                                         ; preds = %do.body32
  %27 = load ptr, ptr %v, align 8
  %28 = load ptr, ptr %obj33, align 8
  call void @PyStructSequence_SetItem(ptr noundef %27, i64 noundef 4, ptr noundef %28)
  br label %do.end39

do.end39:                                         ; preds = %if.end38
  br label %do.body40

do.body40:                                        ; preds = %do.end39
  %29 = load ptr, ptr %st.addr, align 8
  %st_gid = getelementptr inbounds %struct.stat, ptr %29, i32 0, i32 5
  %30 = load i32, ptr %st_gid, align 8
  %call42 = call ptr @_PyLong_FromGid(i32 noundef %30)
  store ptr %call42, ptr %obj41, align 8
  %31 = load ptr, ptr %obj41, align 8
  %cmp43 = icmp eq ptr %31, null
  br i1 %cmp43, label %if.then45, label %if.end46

if.then45:                                        ; preds = %do.body40
  br label %error

if.end46:                                         ; preds = %do.body40
  %32 = load ptr, ptr %v, align 8
  %33 = load ptr, ptr %obj41, align 8
  call void @PyStructSequence_SetItem(ptr noundef %32, i64 noundef 5, ptr noundef %33)
  br label %do.end47

do.end47:                                         ; preds = %if.end46
  br label %do.body48

do.body48:                                        ; preds = %do.end47
  %34 = load ptr, ptr %st.addr, align 8
  %st_size = getelementptr inbounds %struct.stat, ptr %34, i32 0, i32 8
  %35 = load i64, ptr %st_size, align 8
  %call50 = call ptr @PyLong_FromLongLong(i64 noundef %35)
  store ptr %call50, ptr %obj49, align 8
  %36 = load ptr, ptr %obj49, align 8
  %cmp51 = icmp eq ptr %36, null
  br i1 %cmp51, label %if.then53, label %if.end54

if.then53:                                        ; preds = %do.body48
  br label %error

if.end54:                                         ; preds = %do.body48
  %37 = load ptr, ptr %v, align 8
  %38 = load ptr, ptr %obj49, align 8
  call void @PyStructSequence_SetItem(ptr noundef %37, i64 noundef 6, ptr noundef %38)
  br label %do.end55

do.end55:                                         ; preds = %if.end54
  %39 = load ptr, ptr %st.addr, align 8
  %st_atim = getelementptr inbounds %struct.stat, ptr %39, i32 0, i32 11
  %tv_nsec = getelementptr inbounds %struct.timespec, ptr %st_atim, i32 0, i32 1
  %40 = load i64, ptr %tv_nsec, align 8
  store i64 %40, ptr %ansec, align 8
  %41 = load ptr, ptr %st.addr, align 8
  %st_mtim = getelementptr inbounds %struct.stat, ptr %41, i32 0, i32 12
  %tv_nsec56 = getelementptr inbounds %struct.timespec, ptr %st_mtim, i32 0, i32 1
  %42 = load i64, ptr %tv_nsec56, align 8
  store i64 %42, ptr %mnsec, align 8
  %43 = load ptr, ptr %st.addr, align 8
  %st_ctim = getelementptr inbounds %struct.stat, ptr %43, i32 0, i32 13
  %tv_nsec57 = getelementptr inbounds %struct.timespec, ptr %st_ctim, i32 0, i32 1
  %44 = load i64, ptr %tv_nsec57, align 8
  store i64 %44, ptr %cnsec, align 8
  %45 = load ptr, ptr %module.addr, align 8
  %46 = load ptr, ptr %v, align 8
  %47 = load ptr, ptr %st.addr, align 8
  %st_atim58 = getelementptr inbounds %struct.stat, ptr %47, i32 0, i32 11
  %tv_sec = getelementptr inbounds %struct.timespec, ptr %st_atim58, i32 0, i32 0
  %48 = load i64, ptr %tv_sec, align 8
  %49 = load i64, ptr %ansec, align 8
  %call59 = call i32 @fill_time(ptr noundef %45, ptr noundef %46, i32 noundef 7, i32 noundef 10, i32 noundef 13, i64 noundef %48, i64 noundef %49)
  %cmp60 = icmp slt i32 %call59, 0
  br i1 %cmp60, label %if.then62, label %if.end63

if.then62:                                        ; preds = %do.end55
  br label %error

if.end63:                                         ; preds = %do.end55
  %50 = load ptr, ptr %module.addr, align 8
  %51 = load ptr, ptr %v, align 8
  %52 = load ptr, ptr %st.addr, align 8
  %st_mtim64 = getelementptr inbounds %struct.stat, ptr %52, i32 0, i32 12
  %tv_sec65 = getelementptr inbounds %struct.timespec, ptr %st_mtim64, i32 0, i32 0
  %53 = load i64, ptr %tv_sec65, align 8
  %54 = load i64, ptr %mnsec, align 8
  %call66 = call i32 @fill_time(ptr noundef %50, ptr noundef %51, i32 noundef 8, i32 noundef 11, i32 noundef 14, i64 noundef %53, i64 noundef %54)
  %cmp67 = icmp slt i32 %call66, 0
  br i1 %cmp67, label %if.then69, label %if.end70

if.then69:                                        ; preds = %if.end63
  br label %error

if.end70:                                         ; preds = %if.end63
  %55 = load ptr, ptr %module.addr, align 8
  %56 = load ptr, ptr %v, align 8
  %57 = load ptr, ptr %st.addr, align 8
  %st_ctim71 = getelementptr inbounds %struct.stat, ptr %57, i32 0, i32 13
  %tv_sec72 = getelementptr inbounds %struct.timespec, ptr %st_ctim71, i32 0, i32 0
  %58 = load i64, ptr %tv_sec72, align 8
  %59 = load i64, ptr %cnsec, align 8
  %call73 = call i32 @fill_time(ptr noundef %55, ptr noundef %56, i32 noundef 9, i32 noundef 12, i32 noundef 15, i64 noundef %58, i64 noundef %59)
  %cmp74 = icmp slt i32 %call73, 0
  br i1 %cmp74, label %if.then76, label %if.end77

if.then76:                                        ; preds = %if.end70
  br label %error

if.end77:                                         ; preds = %if.end70
  br label %do.body78

do.body78:                                        ; preds = %if.end77
  %60 = load ptr, ptr %st.addr, align 8
  %st_blksize = getelementptr inbounds %struct.stat, ptr %60, i32 0, i32 9
  %61 = load i64, ptr %st_blksize, align 8
  %call80 = call ptr @PyLong_FromLong(i64 noundef %61)
  store ptr %call80, ptr %obj79, align 8
  %62 = load ptr, ptr %obj79, align 8
  %cmp81 = icmp eq ptr %62, null
  br i1 %cmp81, label %if.then83, label %if.end84

if.then83:                                        ; preds = %do.body78
  br label %error

if.end84:                                         ; preds = %do.body78
  %63 = load ptr, ptr %v, align 8
  %64 = load ptr, ptr %obj79, align 8
  call void @PyStructSequence_SetItem(ptr noundef %63, i64 noundef 16, ptr noundef %64)
  br label %do.end85

do.end85:                                         ; preds = %if.end84
  br label %do.body86

do.body86:                                        ; preds = %do.end85
  %65 = load ptr, ptr %st.addr, align 8
  %st_blocks = getelementptr inbounds %struct.stat, ptr %65, i32 0, i32 10
  %66 = load i64, ptr %st_blocks, align 8
  %call88 = call ptr @PyLong_FromLong(i64 noundef %66)
  store ptr %call88, ptr %obj87, align 8
  %67 = load ptr, ptr %obj87, align 8
  %cmp89 = icmp eq ptr %67, null
  br i1 %cmp89, label %if.then91, label %if.end92

if.then91:                                        ; preds = %do.body86
  br label %error

if.end92:                                         ; preds = %do.body86
  %68 = load ptr, ptr %v, align 8
  %69 = load ptr, ptr %obj87, align 8
  call void @PyStructSequence_SetItem(ptr noundef %68, i64 noundef 17, ptr noundef %69)
  br label %do.end93

do.end93:                                         ; preds = %if.end92
  br label %do.body94

do.body94:                                        ; preds = %do.end93
  %70 = load ptr, ptr %st.addr, align 8
  %st_rdev = getelementptr inbounds %struct.stat, ptr %70, i32 0, i32 7
  %71 = load i64, ptr %st_rdev, align 8
  %call96 = call ptr @PyLong_FromLong(i64 noundef %71)
  store ptr %call96, ptr %obj95, align 8
  %72 = load ptr, ptr %obj95, align 8
  %cmp97 = icmp eq ptr %72, null
  br i1 %cmp97, label %if.then99, label %if.end100

if.then99:                                        ; preds = %do.body94
  br label %error

if.end100:                                        ; preds = %do.body94
  %73 = load ptr, ptr %v, align 8
  %74 = load ptr, ptr %obj95, align 8
  call void @PyStructSequence_SetItem(ptr noundef %73, i64 noundef 18, ptr noundef %74)
  br label %do.end101

do.end101:                                        ; preds = %if.end100
  %75 = load ptr, ptr %v, align 8
  store ptr %75, ptr %retval, align 8
  br label %return

error:                                            ; preds = %if.then99, %if.then91, %if.then83, %if.then76, %if.then69, %if.then62, %if.then53, %if.then45, %if.then37, %if.then29, %if.then21, %if.then13, %if.then6
  %76 = load ptr, ptr %v, align 8
  store ptr %76, ptr %op.addr.i, align 8
  %77 = load ptr, ptr %op.addr.i, align 8
  store ptr %77, ptr %op.addr.i102, align 8
  %78 = load ptr, ptr %op.addr.i102, align 8
  %79 = load i64, ptr %78, align 8
  %conv.i = trunc i64 %79 to i32
  %cmp.i103 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i103 to i32
  %tobool.i = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %error
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %error
  %80 = load ptr, ptr %op.addr.i, align 8
  %81 = load i64, ptr %80, align 8
  %dec.i = add i64 %81, -1
  store i64 %dec.i, ptr %80, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %82 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %82) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %Py_DECREF.exit, %do.end101, %if.then
  %83 = load ptr, ptr %retval, align 8
  ret ptr %83
}

; Function Attrs: nounwind uwtable
define internal ptr @path_object_error(ptr noundef %path) #0 {
entry:
  %path.addr = alloca ptr, align 8
  store ptr %path, ptr %path.addr, align 8
  %0 = load ptr, ptr %path.addr, align 8
  %call = call ptr @posix_path_object_error(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @posix_path_object_error(ptr noundef %path) #0 {
entry:
  %path.addr = alloca ptr, align 8
  store ptr %path, ptr %path.addr, align 8
  %0 = load ptr, ptr @PyExc_OSError, align 8
  %1 = load ptr, ptr %path.addr, align 8
  %call = call ptr @PyErr_SetFromErrnoWithFilenameObject(ptr noundef %0, ptr noundef %1)
  ret ptr %call
}

declare ptr @PyErr_SetFromErrnoWithFilenameObject(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @get_posix_state(ptr noundef %module) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %state = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %call = call ptr @_PyModule_GetState(ptr noundef %0)
  store ptr %call, ptr %state, align 8
  %1 = load ptr, ptr %state, align 8
  ret ptr %1
}

declare ptr @PyStructSequence_New(ptr noundef) #1

declare void @PyStructSequence_SetItem(ptr noundef, i64 noundef, ptr noundef) #1

declare ptr @PyLong_FromUnsignedLongLong(i64 noundef) #1

declare ptr @PyLong_FromLongLong(i64 noundef) #1

; Function Attrs: nounwind uwtable
define internal i32 @fill_time(ptr noundef %module, ptr noundef %v, i32 noundef %s_index, i32 noundef %f_index, i32 noundef %ns_index, i64 noundef %sec, i64 noundef %nsec) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %v.addr = alloca ptr, align 8
  %s_index.addr = alloca i32, align 4
  %f_index.addr = alloca i32, align 4
  %ns_index.addr = alloca i32, align 4
  %sec.addr = alloca i64, align 8
  %nsec.addr = alloca i64, align 8
  %res = alloca i32, align 4
  %s_in_ns = alloca ptr, align 8
  %ns_total = alloca ptr, align 8
  %float_s = alloca ptr, align 8
  %s = alloca ptr, align 8
  %ns_fractional = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %v, ptr %v.addr, align 8
  store i32 %s_index, ptr %s_index.addr, align 4
  store i32 %f_index, ptr %f_index.addr, align 4
  store i32 %ns_index, ptr %ns_index.addr, align 4
  store i64 %sec, ptr %sec.addr, align 8
  store i64 %nsec, ptr %nsec.addr, align 8
  store i32 -1, ptr %res, align 4
  store ptr null, ptr %s_in_ns, align 8
  store ptr null, ptr %ns_total, align 8
  store ptr null, ptr %float_s, align 8
  %0 = load i64, ptr %sec.addr, align 8
  %call = call ptr @_PyLong_FromTime_t(i64 noundef %0)
  store ptr %call, ptr %s, align 8
  %1 = load i64, ptr %nsec.addr, align 8
  %call1 = call ptr @PyLong_FromUnsignedLong(i64 noundef %1)
  store ptr %call1, ptr %ns_fractional, align 8
  %2 = load ptr, ptr %s, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %entry
  %3 = load ptr, ptr %ns_fractional, align 8
  %tobool2 = icmp ne ptr %3, null
  br i1 %tobool2, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true, %entry
  br label %exit

if.end:                                           ; preds = %land.lhs.true
  %4 = load ptr, ptr %s, align 8
  %5 = load ptr, ptr %module.addr, align 8
  %call3 = call ptr @get_posix_state(ptr noundef %5)
  %billion = getelementptr inbounds %struct._posixstate, ptr %call3, i32 0, i32 0
  %6 = load ptr, ptr %billion, align 8
  %call4 = call ptr @PyNumber_Multiply(ptr noundef %4, ptr noundef %6)
  store ptr %call4, ptr %s_in_ns, align 8
  %7 = load ptr, ptr %s_in_ns, align 8
  %tobool5 = icmp ne ptr %7, null
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %if.end
  br label %exit

if.end7:                                          ; preds = %if.end
  %8 = load ptr, ptr %s_in_ns, align 8
  %9 = load ptr, ptr %ns_fractional, align 8
  %call8 = call ptr @PyNumber_Add(ptr noundef %8, ptr noundef %9)
  store ptr %call8, ptr %ns_total, align 8
  %10 = load ptr, ptr %ns_total, align 8
  %tobool9 = icmp ne ptr %10, null
  br i1 %tobool9, label %if.end11, label %if.then10

if.then10:                                        ; preds = %if.end7
  br label %exit

if.end11:                                         ; preds = %if.end7
  %11 = load i64, ptr %sec.addr, align 8
  %conv = sitofp i64 %11 to double
  %12 = load i64, ptr %nsec.addr, align 8
  %conv12 = uitofp i64 %12 to double
  %13 = call double @llvm.fmuladd.f64(double 1.000000e-09, double %conv12, double %conv)
  %call13 = call ptr @PyFloat_FromDouble(double noundef %13)
  store ptr %call13, ptr %float_s, align 8
  %14 = load ptr, ptr %float_s, align 8
  %tobool14 = icmp ne ptr %14, null
  br i1 %tobool14, label %if.end16, label %if.then15

if.then15:                                        ; preds = %if.end11
  br label %exit

if.end16:                                         ; preds = %if.end11
  %15 = load i32, ptr %s_index.addr, align 4
  %cmp = icmp sge i32 %15, 0
  br i1 %cmp, label %if.then18, label %if.end20

if.then18:                                        ; preds = %if.end16
  %16 = load ptr, ptr %v.addr, align 8
  %17 = load i32, ptr %s_index.addr, align 4
  %conv19 = sext i32 %17 to i64
  %18 = load ptr, ptr %s, align 8
  call void @PyStructSequence_SetItem(ptr noundef %16, i64 noundef %conv19, ptr noundef %18)
  store ptr null, ptr %s, align 8
  br label %if.end20

if.end20:                                         ; preds = %if.then18, %if.end16
  %19 = load i32, ptr %f_index.addr, align 4
  %cmp21 = icmp sge i32 %19, 0
  br i1 %cmp21, label %if.then23, label %if.end25

if.then23:                                        ; preds = %if.end20
  %20 = load ptr, ptr %v.addr, align 8
  %21 = load i32, ptr %f_index.addr, align 4
  %conv24 = sext i32 %21 to i64
  %22 = load ptr, ptr %float_s, align 8
  call void @PyStructSequence_SetItem(ptr noundef %20, i64 noundef %conv24, ptr noundef %22)
  store ptr null, ptr %float_s, align 8
  br label %if.end25

if.end25:                                         ; preds = %if.then23, %if.end20
  %23 = load i32, ptr %ns_index.addr, align 4
  %cmp26 = icmp sge i32 %23, 0
  br i1 %cmp26, label %if.then28, label %if.end30

if.then28:                                        ; preds = %if.end25
  %24 = load ptr, ptr %v.addr, align 8
  %25 = load i32, ptr %ns_index.addr, align 4
  %conv29 = sext i32 %25 to i64
  %26 = load ptr, ptr %ns_total, align 8
  call void @PyStructSequence_SetItem(ptr noundef %24, i64 noundef %conv29, ptr noundef %26)
  store ptr null, ptr %ns_total, align 8
  br label %if.end30

if.end30:                                         ; preds = %if.then28, %if.end25
  store i32 0, ptr %res, align 4
  br label %exit

exit:                                             ; preds = %if.end30, %if.then15, %if.then10, %if.then6, %if.then
  %27 = load ptr, ptr %s, align 8
  call void @Py_XDECREF(ptr noundef %27)
  %28 = load ptr, ptr %ns_fractional, align 8
  call void @Py_XDECREF(ptr noundef %28)
  %29 = load ptr, ptr %s_in_ns, align 8
  call void @Py_XDECREF(ptr noundef %29)
  %30 = load ptr, ptr %ns_total, align 8
  call void @Py_XDECREF(ptr noundef %30)
  %31 = load ptr, ptr %float_s, align 8
  call void @Py_XDECREF(ptr noundef %31)
  %32 = load i32, ptr %res, align 4
  ret i32 %32
}

; Function Attrs: nounwind uwtable
define internal ptr @_PyModule_GetState(ptr noundef %mod) #0 {
entry:
  %mod.addr = alloca ptr, align 8
  store ptr %mod, ptr %mod.addr, align 8
  %0 = load ptr, ptr %mod.addr, align 8
  %md_state = getelementptr inbounds %struct.PyModuleObject, ptr %0, i32 0, i32 3
  %1 = load ptr, ptr %md_state, align 8
  ret ptr %1
}

declare ptr @_PyLong_FromTime_t(i64 noundef) #1

declare ptr @PyNumber_Multiply(ptr noundef, ptr noundef) #1

declare ptr @PyNumber_Add(ptr noundef, ptr noundef) #1

declare ptr @PyFloat_FromDouble(double noundef) #1

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.fmuladd.f64(double, double, double) #6

declare void @PyMem_Free(ptr noundef) #1

declare i32 @PyLong_AsInt(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal i32 @os_access_impl(ptr noundef %module, ptr noundef %path, i32 noundef %mode, i32 noundef %dir_fd, i32 noundef %effective_ids, i32 noundef %follow_symlinks) #0 {
entry:
  %retval = alloca i32, align 4
  %module.addr = alloca ptr, align 8
  %path.addr = alloca ptr, align 8
  %mode.addr = alloca i32, align 4
  %dir_fd.addr = alloca i32, align 4
  %effective_ids.addr = alloca i32, align 4
  %follow_symlinks.addr = alloca i32, align 4
  %return_value = alloca i32, align 4
  %result = alloca i32, align 4
  %faccessat_unavailable = alloca i32, align 4
  %_save = alloca ptr, align 8
  %flags = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %path, ptr %path.addr, align 8
  store i32 %mode, ptr %mode.addr, align 4
  store i32 %dir_fd, ptr %dir_fd.addr, align 4
  store i32 %effective_ids, ptr %effective_ids.addr, align 4
  store i32 %follow_symlinks, ptr %follow_symlinks.addr, align 4
  store i32 0, ptr %faccessat_unavailable, align 4
  %call = call ptr @PyEval_SaveThread()
  store ptr %call, ptr %_save, align 8
  %0 = load i32, ptr %dir_fd.addr, align 4
  %cmp = icmp ne i32 %0, -100
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, ptr %effective_ids.addr, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %lor.lhs.false1

lor.lhs.false1:                                   ; preds = %lor.lhs.false
  %2 = load i32, ptr %follow_symlinks.addr, align 4
  %tobool2 = icmp ne i32 %2, 0
  br i1 %tobool2, label %if.else, label %if.then

if.then:                                          ; preds = %lor.lhs.false1, %lor.lhs.false, %entry
  store i32 0, ptr %flags, align 4
  %3 = load i32, ptr %follow_symlinks.addr, align 4
  %tobool3 = icmp ne i32 %3, 0
  br i1 %tobool3, label %if.end, label %if.then4

if.then4:                                         ; preds = %if.then
  %4 = load i32, ptr %flags, align 4
  %or = or i32 %4, 256
  store i32 %or, ptr %flags, align 4
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then
  %5 = load i32, ptr %effective_ids.addr, align 4
  %tobool5 = icmp ne i32 %5, 0
  br i1 %tobool5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end
  %6 = load i32, ptr %flags, align 4
  %or7 = or i32 %6, 512
  store i32 %or7, ptr %flags, align 4
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %if.end
  %7 = load i32, ptr %dir_fd.addr, align 4
  %8 = load ptr, ptr %path.addr, align 8
  %narrow = getelementptr inbounds %struct.path_t, ptr %8, i32 0, i32 5
  %9 = load ptr, ptr %narrow, align 8
  %10 = load i32, ptr %mode.addr, align 4
  %11 = load i32, ptr %flags, align 4
  %call9 = call i32 @faccessat(i32 noundef %7, ptr noundef %9, i32 noundef %10, i32 noundef %11) #10
  store i32 %call9, ptr %result, align 4
  br label %if.end12

if.else:                                          ; preds = %lor.lhs.false1
  %12 = load ptr, ptr %path.addr, align 8
  %narrow10 = getelementptr inbounds %struct.path_t, ptr %12, i32 0, i32 5
  %13 = load ptr, ptr %narrow10, align 8
  %14 = load i32, ptr %mode.addr, align 4
  %call11 = call i32 @access(ptr noundef %13, i32 noundef %14) #10
  store i32 %call11, ptr %result, align 4
  br label %if.end12

if.end12:                                         ; preds = %if.else, %if.end8
  %15 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %15)
  %16 = load i32, ptr %faccessat_unavailable, align 4
  %tobool13 = icmp ne i32 %16, 0
  br i1 %tobool13, label %if.then14, label %if.end25

if.then14:                                        ; preds = %if.end12
  %17 = load i32, ptr %dir_fd.addr, align 4
  %cmp15 = icmp ne i32 %17, -100
  br i1 %cmp15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.then14
  call void @argument_unavailable_error(ptr noundef @.str.13, ptr noundef @.str.184)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end17:                                         ; preds = %if.then14
  %18 = load i32, ptr %follow_symlinks.addr, align 4
  %call18 = call i32 @follow_symlinks_specified(ptr noundef @.str.13, i32 noundef %18)
  %tobool19 = icmp ne i32 %call18, 0
  br i1 %tobool19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %if.end17
  store i32 -1, ptr %retval, align 4
  br label %return

if.end21:                                         ; preds = %if.end17
  %19 = load i32, ptr %effective_ids.addr, align 4
  %tobool22 = icmp ne i32 %19, 0
  br i1 %tobool22, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.end21
  call void @argument_unavailable_error(ptr noundef @.str.13, ptr noundef @.str.202)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end24:                                         ; preds = %if.end21
  store i32 -1, ptr %retval, align 4
  br label %return

if.end25:                                         ; preds = %if.end12
  %20 = load i32, ptr %result, align 4
  %tobool26 = icmp ne i32 %20, 0
  %lnot = xor i1 %tobool26, true
  %lnot.ext = zext i1 %lnot to i32
  store i32 %lnot.ext, ptr %return_value, align 4
  %21 = load i32, ptr %return_value, align 4
  store i32 %21, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end25, %if.end24, %if.then23, %if.then20, %if.then16
  %22 = load i32, ptr %retval, align 4
  ret i32 %22
}

declare ptr @PyBool_FromLong(i64 noundef) #1

; Function Attrs: nounwind
declare i32 @faccessat(i32 noundef, ptr noundef, i32 noundef, i32 noundef) #4

; Function Attrs: nounwind
declare i32 @access(ptr noundef, i32 noundef) #4

; Function Attrs: nounwind uwtable
define internal i32 @follow_symlinks_specified(ptr noundef %function_name, i32 noundef %follow_symlinks) #0 {
entry:
  %retval = alloca i32, align 4
  %function_name.addr = alloca ptr, align 8
  %follow_symlinks.addr = alloca i32, align 4
  store ptr %function_name, ptr %function_name.addr, align 8
  store i32 %follow_symlinks, ptr %follow_symlinks.addr, align 4
  %0 = load i32, ptr %follow_symlinks.addr, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %function_name.addr, align 8
  call void @argument_unavailable_error(ptr noundef %1, ptr noundef @.str.185)
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load i32, ptr %retval, align 4
  ret i32 %2
}

; Function Attrs: nounwind uwtable
define internal ptr @os_ttyname_impl(ptr noundef %module, i32 noundef %fd) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %size = alloca i64, align 8
  %buffer = alloca ptr, align 8
  %ret = alloca i32, align 4
  %res = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  %call = call i64 @sysconf(i32 noundef 72) #10
  store i64 %call, ptr %size, align 8
  %0 = load i64, ptr %size, align 8
  %cmp = icmp eq i64 %0, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call ptr @posix_error()
  store ptr %call1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, ptr %size, align 8
  %call2 = call ptr @PyMem_RawMalloc(i64 noundef %1)
  store ptr %call2, ptr %buffer, align 8
  %2 = load ptr, ptr %buffer, align 8
  %cmp3 = icmp eq ptr %2, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call ptr @PyErr_NoMemory()
  store ptr %call5, ptr %retval, align 8
  br label %return

if.end6:                                          ; preds = %if.end
  %3 = load i32, ptr %fd.addr, align 4
  %4 = load ptr, ptr %buffer, align 8
  %5 = load i64, ptr %size, align 8
  %call7 = call i32 @ttyname_r(i32 noundef %3, ptr noundef %4, i64 noundef %5) #10
  store i32 %call7, ptr %ret, align 4
  %6 = load i32, ptr %ret, align 4
  %cmp8 = icmp ne i32 %6, 0
  br i1 %cmp8, label %if.then9, label %if.end12

if.then9:                                         ; preds = %if.end6
  %7 = load ptr, ptr %buffer, align 8
  call void @PyMem_RawFree(ptr noundef %7)
  %8 = load i32, ptr %ret, align 4
  %call10 = call ptr @__errno_location() #12
  store i32 %8, ptr %call10, align 4
  %call11 = call ptr @posix_error()
  store ptr %call11, ptr %retval, align 8
  br label %return

if.end12:                                         ; preds = %if.end6
  %9 = load ptr, ptr %buffer, align 8
  %call13 = call ptr @PyUnicode_DecodeFSDefault(ptr noundef %9)
  store ptr %call13, ptr %res, align 8
  %10 = load ptr, ptr %buffer, align 8
  call void @PyMem_RawFree(ptr noundef %10)
  %11 = load ptr, ptr %res, align 8
  store ptr %11, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end12, %if.then9, %if.then4, %if.then
  %12 = load ptr, ptr %retval, align 8
  ret ptr %12
}

; Function Attrs: nounwind
declare i64 @sysconf(i32 noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @posix_error() #0 {
entry:
  %0 = load ptr, ptr @PyExc_OSError, align 8
  %call = call ptr @PyErr_SetFromErrno(ptr noundef %0)
  ret ptr %call
}

declare ptr @PyMem_RawMalloc(i64 noundef) #1

declare ptr @PyErr_NoMemory() #1

; Function Attrs: nounwind
declare i32 @ttyname_r(i32 noundef, ptr noundef, i64 noundef) #4

declare void @PyMem_RawFree(ptr noundef) #1

declare ptr @PyUnicode_DecodeFSDefault(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @os_chdir_impl(ptr noundef %module, ptr noundef %path) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %path.addr = alloca ptr, align 8
  %result = alloca i32, align 4
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %path, ptr %path.addr, align 8
  %0 = load ptr, ptr %path.addr, align 8
  %object = getelementptr inbounds %struct.path_t, ptr %0, i32 0, i32 8
  %1 = load ptr, ptr %object, align 8
  %call = call i32 (ptr, ptr, ...) @PySys_Audit(ptr noundef @.str.203, ptr noundef @.str.204, ptr noundef %1)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call ptr @PyEval_SaveThread()
  store ptr %call1, ptr %_save, align 8
  %2 = load ptr, ptr %path.addr, align 8
  %fd = getelementptr inbounds %struct.path_t, ptr %2, i32 0, i32 6
  %3 = load i32, ptr %fd, align 8
  %cmp2 = icmp ne i32 %3, -1
  br i1 %cmp2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  %4 = load ptr, ptr %path.addr, align 8
  %fd4 = getelementptr inbounds %struct.path_t, ptr %4, i32 0, i32 6
  %5 = load i32, ptr %fd4, align 8
  %call5 = call i32 @fchdir(i32 noundef %5) #10
  store i32 %call5, ptr %result, align 4
  br label %if.end7

if.else:                                          ; preds = %if.end
  %6 = load ptr, ptr %path.addr, align 8
  %narrow = getelementptr inbounds %struct.path_t, ptr %6, i32 0, i32 5
  %7 = load ptr, ptr %narrow, align 8
  %call6 = call i32 @chdir(ptr noundef %7) #10
  store i32 %call6, ptr %result, align 4
  br label %if.end7

if.end7:                                          ; preds = %if.else, %if.then3
  %8 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %8)
  %9 = load i32, ptr %result, align 4
  %tobool = icmp ne i32 %9, 0
  br i1 %tobool, label %if.then8, label %if.end10

if.then8:                                         ; preds = %if.end7
  %10 = load ptr, ptr %path.addr, align 8
  %call9 = call ptr @path_error(ptr noundef %10)
  store ptr %call9, ptr %retval, align 8
  br label %return

if.end10:                                         ; preds = %if.end7
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end10, %if.then8, %if.then
  %11 = load ptr, ptr %retval, align 8
  ret ptr %11
}

declare i32 @PySys_Audit(ptr noundef, ptr noundef, ...) #1

; Function Attrs: nounwind
declare i32 @fchdir(i32 noundef) #4

; Function Attrs: nounwind
declare i32 @chdir(ptr noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_chmod_impl(ptr noundef %module, ptr noundef %path, i32 noundef %mode, i32 noundef %dir_fd, i32 noundef %follow_symlinks) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %path.addr = alloca ptr, align 8
  %mode.addr = alloca i32, align 4
  %dir_fd.addr = alloca i32, align 4
  %follow_symlinks.addr = alloca i32, align 4
  %result = alloca i32, align 4
  %fchmodat_nofollow_unsupported = alloca i32, align 4
  %fchmodat_unsupported = alloca i32, align 4
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %path, ptr %path.addr, align 8
  store i32 %mode, ptr %mode.addr, align 4
  store i32 %dir_fd, ptr %dir_fd.addr, align 4
  store i32 %follow_symlinks, ptr %follow_symlinks.addr, align 4
  store i32 0, ptr %fchmodat_nofollow_unsupported, align 4
  store i32 0, ptr %fchmodat_unsupported, align 4
  %0 = load ptr, ptr %path.addr, align 8
  %object = getelementptr inbounds %struct.path_t, ptr %0, i32 0, i32 8
  %1 = load ptr, ptr %object, align 8
  %2 = load i32, ptr %mode.addr, align 4
  %3 = load i32, ptr %dir_fd.addr, align 4
  %cmp = icmp eq i32 %3, -100
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %4 = load i32, ptr %dir_fd.addr, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ -1, %cond.true ], [ %4, %cond.false ]
  %call = call i32 (ptr, ptr, ...) @PySys_Audit(ptr noundef @.str.205, ptr noundef @.str.206, ptr noundef %1, i32 noundef %2, i32 noundef %cond)
  %cmp1 = icmp slt i32 %call, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end
  %call2 = call ptr @PyEval_SaveThread()
  store ptr %call2, ptr %_save, align 8
  %5 = load ptr, ptr %path.addr, align 8
  %fd = getelementptr inbounds %struct.path_t, ptr %5, i32 0, i32 6
  %6 = load i32, ptr %fd, align 8
  %cmp3 = icmp ne i32 %6, -1
  br i1 %cmp3, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.end
  %7 = load ptr, ptr %path.addr, align 8
  %fd5 = getelementptr inbounds %struct.path_t, ptr %7, i32 0, i32 6
  %8 = load i32, ptr %fd5, align 8
  %9 = load i32, ptr %mode.addr, align 4
  %call6 = call i32 @fchmod(i32 noundef %8, i32 noundef %9) #10
  store i32 %call6, ptr %result, align 4
  br label %if.end23

if.else:                                          ; preds = %if.end
  %10 = load i32, ptr %dir_fd.addr, align 4
  %cmp7 = icmp ne i32 %10, -100
  br i1 %cmp7, label %if.then8, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else
  %11 = load i32, ptr %follow_symlinks.addr, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.else19, label %if.then8

if.then8:                                         ; preds = %lor.lhs.false, %if.else
  %12 = load i32, ptr %dir_fd.addr, align 4
  %13 = load ptr, ptr %path.addr, align 8
  %narrow = getelementptr inbounds %struct.path_t, ptr %13, i32 0, i32 5
  %14 = load ptr, ptr %narrow, align 8
  %15 = load i32, ptr %mode.addr, align 4
  %16 = load i32, ptr %follow_symlinks.addr, align 4
  %tobool9 = icmp ne i32 %16, 0
  %cond10 = select i1 %tobool9, i32 0, i32 256
  %call11 = call i32 @fchmodat(i32 noundef %12, ptr noundef %14, i32 noundef %15, i32 noundef %cond10) #10
  store i32 %call11, ptr %result, align 4
  %17 = load i32, ptr %result, align 4
  %tobool12 = icmp ne i32 %17, 0
  br i1 %tobool12, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %if.then8
  %call13 = call ptr @__errno_location() #12
  %18 = load i32, ptr %call13, align 4
  %cmp14 = icmp eq i32 %18, 95
  br i1 %cmp14, label %land.rhs, label %lor.lhs.false15

lor.lhs.false15:                                  ; preds = %land.lhs.true
  %call16 = call ptr @__errno_location() #12
  %19 = load i32, ptr %call16, align 4
  %cmp17 = icmp eq i32 %19, 95
  br i1 %cmp17, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %lor.lhs.false15, %land.lhs.true
  %20 = load i32, ptr %follow_symlinks.addr, align 4
  %tobool18 = icmp ne i32 %20, 0
  %lnot = xor i1 %tobool18, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %lor.lhs.false15, %if.then8
  %21 = phi i1 [ false, %lor.lhs.false15 ], [ false, %if.then8 ], [ %lnot, %land.rhs ]
  %land.ext = zext i1 %21 to i32
  store i32 %land.ext, ptr %fchmodat_nofollow_unsupported, align 4
  br label %if.end22

if.else19:                                        ; preds = %lor.lhs.false
  %22 = load ptr, ptr %path.addr, align 8
  %narrow20 = getelementptr inbounds %struct.path_t, ptr %22, i32 0, i32 5
  %23 = load ptr, ptr %narrow20, align 8
  %24 = load i32, ptr %mode.addr, align 4
  %call21 = call i32 @chmod(ptr noundef %23, i32 noundef %24) #10
  store i32 %call21, ptr %result, align 4
  br label %if.end22

if.end22:                                         ; preds = %if.else19, %land.end
  br label %if.end23

if.end23:                                         ; preds = %if.end22, %if.then4
  %25 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %25)
  %26 = load i32, ptr %result, align 4
  %tobool24 = icmp ne i32 %26, 0
  br i1 %tobool24, label %if.then25, label %if.end42

if.then25:                                        ; preds = %if.end23
  %27 = load i32, ptr %fchmodat_unsupported, align 4
  %tobool26 = icmp ne i32 %27, 0
  br i1 %tobool26, label %if.then27, label %if.end31

if.then27:                                        ; preds = %if.then25
  %28 = load i32, ptr %dir_fd.addr, align 4
  %cmp28 = icmp ne i32 %28, -100
  br i1 %cmp28, label %if.then29, label %if.end30

if.then29:                                        ; preds = %if.then27
  call void @argument_unavailable_error(ptr noundef @.str.16, ptr noundef @.str.184)
  store ptr null, ptr %retval, align 8
  br label %return

if.end30:                                         ; preds = %if.then27
  br label %if.end31

if.end31:                                         ; preds = %if.end30, %if.then25
  %29 = load i32, ptr %fchmodat_nofollow_unsupported, align 4
  %tobool32 = icmp ne i32 %29, 0
  br i1 %tobool32, label %if.then33, label %if.else40

if.then33:                                        ; preds = %if.end31
  %30 = load i32, ptr %dir_fd.addr, align 4
  %cmp34 = icmp ne i32 %30, -100
  br i1 %cmp34, label %if.then35, label %if.else37

if.then35:                                        ; preds = %if.then33
  %31 = load i32, ptr %dir_fd.addr, align 4
  %32 = load i32, ptr %follow_symlinks.addr, align 4
  %call36 = call i32 @dir_fd_and_follow_symlinks_invalid(ptr noundef @.str.16, i32 noundef %31, i32 noundef %32)
  br label %if.end39

if.else37:                                        ; preds = %if.then33
  %33 = load i32, ptr %follow_symlinks.addr, align 4
  %call38 = call i32 @follow_symlinks_specified(ptr noundef @.str.16, i32 noundef %33)
  br label %if.end39

if.end39:                                         ; preds = %if.else37, %if.then35
  store ptr null, ptr %retval, align 8
  br label %return

if.else40:                                        ; preds = %if.end31
  %34 = load ptr, ptr %path.addr, align 8
  %call41 = call ptr @path_error(ptr noundef %34)
  store ptr %call41, ptr %retval, align 8
  br label %return

if.end42:                                         ; preds = %if.end23
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end42, %if.else40, %if.end39, %if.then29, %if.then
  %35 = load ptr, ptr %retval, align 8
  ret ptr %35
}

; Function Attrs: nounwind
declare i32 @fchmod(i32 noundef, i32 noundef) #4

; Function Attrs: nounwind
declare i32 @fchmodat(i32 noundef, ptr noundef, i32 noundef, i32 noundef) #4

; Function Attrs: nounwind
declare i32 @chmod(ptr noundef, i32 noundef) #4

; Function Attrs: nounwind uwtable
define internal i32 @dir_fd_and_follow_symlinks_invalid(ptr noundef %function_name, i32 noundef %dir_fd, i32 noundef %follow_symlinks) #0 {
entry:
  %retval = alloca i32, align 4
  %function_name.addr = alloca ptr, align 8
  %dir_fd.addr = alloca i32, align 4
  %follow_symlinks.addr = alloca i32, align 4
  store ptr %function_name, ptr %function_name.addr, align 8
  store i32 %dir_fd, ptr %dir_fd.addr, align 4
  store i32 %follow_symlinks, ptr %follow_symlinks.addr, align 4
  %0 = load i32, ptr %dir_fd.addr, align 4
  %cmp = icmp ne i32 %0, -100
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load i32, ptr %follow_symlinks.addr, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %2 = load ptr, ptr @PyExc_ValueError, align 8
  %3 = load ptr, ptr %function_name.addr, align 8
  %call = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %2, ptr noundef @.str.207, ptr noundef %3)
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load i32, ptr %retval, align 4
  ret i32 %4
}

; Function Attrs: nounwind uwtable
define internal ptr @os_fchmod_impl(ptr noundef %module, i32 noundef %fd, i32 noundef %mode) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %mode.addr = alloca i32, align 4
  %res = alloca i32, align 4
  %async_err = alloca i32, align 4
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i32 %mode, ptr %mode.addr, align 4
  store i32 0, ptr %async_err, align 4
  %0 = load i32, ptr %fd.addr, align 4
  %1 = load i32, ptr %mode.addr, align 4
  %call = call i32 (ptr, ptr, ...) @PySys_Audit(ptr noundef @.str.205, ptr noundef @.str.209, i32 noundef %0, i32 noundef %1, i32 noundef -1)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %land.end, %if.end
  %call1 = call ptr @PyEval_SaveThread()
  store ptr %call1, ptr %_save, align 8
  %2 = load i32, ptr %fd.addr, align 4
  %3 = load i32, ptr %mode.addr, align 4
  %call2 = call i32 @fchmod(i32 noundef %2, i32 noundef %3) #10
  store i32 %call2, ptr %res, align 4
  %4 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %4)
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %5 = load i32, ptr %res, align 4
  %cmp3 = icmp ne i32 %5, 0
  br i1 %cmp3, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %do.cond
  %call4 = call ptr @__errno_location() #12
  %6 = load i32, ptr %call4, align 4
  %cmp5 = icmp eq i32 %6, 4
  br i1 %cmp5, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %call6 = call i32 @PyErr_CheckSignals()
  store i32 %call6, ptr %async_err, align 4
  %tobool = icmp ne i32 %call6, 0
  %lnot = xor i1 %tobool, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %do.cond
  %7 = phi i1 [ false, %land.lhs.true ], [ false, %do.cond ], [ %lnot, %land.rhs ]
  br i1 %7, label %do.body, label %do.end, !llvm.loop !9

do.end:                                           ; preds = %land.end
  %8 = load i32, ptr %res, align 4
  %cmp7 = icmp ne i32 %8, 0
  br i1 %cmp7, label %if.then8, label %if.end11

if.then8:                                         ; preds = %do.end
  %9 = load i32, ptr %async_err, align 4
  %tobool9 = icmp ne i32 %9, 0
  br i1 %tobool9, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then8
  %call10 = call ptr @posix_error()
  br label %cond.end

cond.false:                                       ; preds = %if.then8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call10, %cond.true ], [ null, %cond.false ]
  store ptr %cond, ptr %retval, align 8
  br label %return

if.end11:                                         ; preds = %do.end
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end11, %cond.end, %if.then
  %10 = load ptr, ptr %retval, align 8
  ret ptr %10
}

declare i32 @PyErr_CheckSignals() #1

; Function Attrs: nounwind uwtable
define internal ptr @os_chown_impl(ptr noundef %module, ptr noundef %path, i32 noundef %uid, i32 noundef %gid, i32 noundef %dir_fd, i32 noundef %follow_symlinks) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %path.addr = alloca ptr, align 8
  %uid.addr = alloca i32, align 4
  %gid.addr = alloca i32, align 4
  %dir_fd.addr = alloca i32, align 4
  %follow_symlinks.addr = alloca i32, align 4
  %result = alloca i32, align 4
  %fchownat_unsupported = alloca i32, align 4
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %path, ptr %path.addr, align 8
  store i32 %uid, ptr %uid.addr, align 4
  store i32 %gid, ptr %gid.addr, align 4
  store i32 %dir_fd, ptr %dir_fd.addr, align 4
  store i32 %follow_symlinks, ptr %follow_symlinks.addr, align 4
  store i32 0, ptr %fchownat_unsupported, align 4
  %0 = load i32, ptr %dir_fd.addr, align 4
  %1 = load ptr, ptr %path.addr, align 8
  %fd = getelementptr inbounds %struct.path_t, ptr %1, i32 0, i32 6
  %2 = load i32, ptr %fd, align 8
  %call = call i32 @dir_fd_and_fd_invalid(ptr noundef @.str.18, i32 noundef %0, i32 noundef %2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %3 = load ptr, ptr %path.addr, align 8
  %fd1 = getelementptr inbounds %struct.path_t, ptr %3, i32 0, i32 6
  %4 = load i32, ptr %fd1, align 8
  %5 = load i32, ptr %follow_symlinks.addr, align 4
  %call2 = call i32 @fd_and_follow_symlinks_invalid(ptr noundef @.str.18, i32 noundef %4, i32 noundef %5)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %6 = load ptr, ptr %path.addr, align 8
  %object = getelementptr inbounds %struct.path_t, ptr %6, i32 0, i32 8
  %7 = load ptr, ptr %object, align 8
  %8 = load i32, ptr %uid.addr, align 4
  %9 = load i32, ptr %gid.addr, align 4
  %10 = load i32, ptr %dir_fd.addr, align 4
  %cmp = icmp eq i32 %10, -100
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %11 = load i32, ptr %dir_fd.addr, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ -1, %cond.true ], [ %11, %cond.false ]
  %call4 = call i32 (ptr, ptr, ...) @PySys_Audit(ptr noundef @.str.212, ptr noundef @.str.213, ptr noundef %7, i32 noundef %8, i32 noundef %9, i32 noundef %cond)
  %cmp5 = icmp slt i32 %call4, 0
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %cond.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end7:                                          ; preds = %cond.end
  %call8 = call ptr @PyEval_SaveThread()
  store ptr %call8, ptr %_save, align 8
  %12 = load ptr, ptr %path.addr, align 8
  %fd9 = getelementptr inbounds %struct.path_t, ptr %12, i32 0, i32 6
  %13 = load i32, ptr %fd9, align 8
  %cmp10 = icmp ne i32 %13, -1
  br i1 %cmp10, label %if.then11, label %if.else

if.then11:                                        ; preds = %if.end7
  %14 = load ptr, ptr %path.addr, align 8
  %fd12 = getelementptr inbounds %struct.path_t, ptr %14, i32 0, i32 6
  %15 = load i32, ptr %fd12, align 8
  %16 = load i32, ptr %uid.addr, align 4
  %17 = load i32, ptr %gid.addr, align 4
  %call13 = call i32 @fchown(i32 noundef %15, i32 noundef %16, i32 noundef %17) #10
  store i32 %call13, ptr %result, align 4
  br label %if.end32

if.else:                                          ; preds = %if.end7
  %18 = load i32, ptr %follow_symlinks.addr, align 4
  %tobool14 = icmp ne i32 %18, 0
  br i1 %tobool14, label %if.else18, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.else
  %19 = load i32, ptr %dir_fd.addr, align 4
  %cmp15 = icmp eq i32 %19, -100
  br i1 %cmp15, label %if.then16, label %if.else18

if.then16:                                        ; preds = %land.lhs.true
  %20 = load ptr, ptr %path.addr, align 8
  %narrow = getelementptr inbounds %struct.path_t, ptr %20, i32 0, i32 5
  %21 = load ptr, ptr %narrow, align 8
  %22 = load i32, ptr %uid.addr, align 4
  %23 = load i32, ptr %gid.addr, align 4
  %call17 = call i32 @lchown(ptr noundef %21, i32 noundef %22, i32 noundef %23) #10
  store i32 %call17, ptr %result, align 4
  br label %if.end31

if.else18:                                        ; preds = %land.lhs.true, %if.else
  %24 = load i32, ptr %dir_fd.addr, align 4
  %cmp19 = icmp ne i32 %24, -100
  br i1 %cmp19, label %if.then22, label %lor.lhs.false20

lor.lhs.false20:                                  ; preds = %if.else18
  %25 = load i32, ptr %follow_symlinks.addr, align 4
  %tobool21 = icmp ne i32 %25, 0
  br i1 %tobool21, label %if.else27, label %if.then22

if.then22:                                        ; preds = %lor.lhs.false20, %if.else18
  %26 = load i32, ptr %dir_fd.addr, align 4
  %27 = load ptr, ptr %path.addr, align 8
  %narrow23 = getelementptr inbounds %struct.path_t, ptr %27, i32 0, i32 5
  %28 = load ptr, ptr %narrow23, align 8
  %29 = load i32, ptr %uid.addr, align 4
  %30 = load i32, ptr %gid.addr, align 4
  %31 = load i32, ptr %follow_symlinks.addr, align 4
  %tobool24 = icmp ne i32 %31, 0
  %cond25 = select i1 %tobool24, i32 0, i32 256
  %call26 = call i32 @fchownat(i32 noundef %26, ptr noundef %28, i32 noundef %29, i32 noundef %30, i32 noundef %cond25) #10
  store i32 %call26, ptr %result, align 4
  br label %if.end30

if.else27:                                        ; preds = %lor.lhs.false20
  %32 = load ptr, ptr %path.addr, align 8
  %narrow28 = getelementptr inbounds %struct.path_t, ptr %32, i32 0, i32 5
  %33 = load ptr, ptr %narrow28, align 8
  %34 = load i32, ptr %uid.addr, align 4
  %35 = load i32, ptr %gid.addr, align 4
  %call29 = call i32 @chown(ptr noundef %33, i32 noundef %34, i32 noundef %35) #10
  store i32 %call29, ptr %result, align 4
  br label %if.end30

if.end30:                                         ; preds = %if.else27, %if.then22
  br label %if.end31

if.end31:                                         ; preds = %if.end30, %if.then16
  br label %if.end32

if.end32:                                         ; preds = %if.end31, %if.then11
  %36 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %36)
  %37 = load i32, ptr %fchownat_unsupported, align 4
  %tobool33 = icmp ne i32 %37, 0
  br i1 %tobool33, label %if.then34, label %if.end35

if.then34:                                        ; preds = %if.end32
  call void @argument_unavailable_error(ptr noundef null, ptr noundef @.str.184)
  store ptr null, ptr %retval, align 8
  br label %return

if.end35:                                         ; preds = %if.end32
  %38 = load i32, ptr %result, align 4
  %tobool36 = icmp ne i32 %38, 0
  br i1 %tobool36, label %if.then37, label %if.end39

if.then37:                                        ; preds = %if.end35
  %39 = load ptr, ptr %path.addr, align 8
  %call38 = call ptr @path_error(ptr noundef %39)
  store ptr %call38, ptr %retval, align 8
  br label %return

if.end39:                                         ; preds = %if.end35
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end39, %if.then37, %if.then34, %if.then6, %if.then
  %40 = load ptr, ptr %retval, align 8
  ret ptr %40
}

; Function Attrs: nounwind
declare i32 @fchown(i32 noundef, i32 noundef, i32 noundef) #4

; Function Attrs: nounwind
declare i32 @lchown(ptr noundef, i32 noundef, i32 noundef) #4

; Function Attrs: nounwind
declare i32 @fchownat(i32 noundef, ptr noundef, i32 noundef, i32 noundef, i32 noundef) #4

; Function Attrs: nounwind
declare i32 @chown(ptr noundef, i32 noundef, i32 noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_fchown_impl(ptr noundef %module, i32 noundef %fd, i32 noundef %uid, i32 noundef %gid) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %uid.addr = alloca i32, align 4
  %gid.addr = alloca i32, align 4
  %res = alloca i32, align 4
  %async_err = alloca i32, align 4
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i32 %uid, ptr %uid.addr, align 4
  store i32 %gid, ptr %gid.addr, align 4
  store i32 0, ptr %async_err, align 4
  %0 = load i32, ptr %fd.addr, align 4
  %1 = load i32, ptr %uid.addr, align 4
  %2 = load i32, ptr %gid.addr, align 4
  %call = call i32 (ptr, ptr, ...) @PySys_Audit(ptr noundef @.str.212, ptr noundef @.str.214, i32 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef -1)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %land.end, %if.end
  %call1 = call ptr @PyEval_SaveThread()
  store ptr %call1, ptr %_save, align 8
  %3 = load i32, ptr %fd.addr, align 4
  %4 = load i32, ptr %uid.addr, align 4
  %5 = load i32, ptr %gid.addr, align 4
  %call2 = call i32 @fchown(i32 noundef %3, i32 noundef %4, i32 noundef %5) #10
  store i32 %call2, ptr %res, align 4
  %6 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %6)
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %7 = load i32, ptr %res, align 4
  %cmp3 = icmp ne i32 %7, 0
  br i1 %cmp3, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %do.cond
  %call4 = call ptr @__errno_location() #12
  %8 = load i32, ptr %call4, align 4
  %cmp5 = icmp eq i32 %8, 4
  br i1 %cmp5, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %call6 = call i32 @PyErr_CheckSignals()
  store i32 %call6, ptr %async_err, align 4
  %tobool = icmp ne i32 %call6, 0
  %lnot = xor i1 %tobool, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %do.cond
  %9 = phi i1 [ false, %land.lhs.true ], [ false, %do.cond ], [ %lnot, %land.rhs ]
  br i1 %9, label %do.body, label %do.end, !llvm.loop !10

do.end:                                           ; preds = %land.end
  %10 = load i32, ptr %res, align 4
  %cmp7 = icmp ne i32 %10, 0
  br i1 %cmp7, label %if.then8, label %if.end11

if.then8:                                         ; preds = %do.end
  %11 = load i32, ptr %async_err, align 4
  %tobool9 = icmp ne i32 %11, 0
  br i1 %tobool9, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then8
  %call10 = call ptr @posix_error()
  br label %cond.end

cond.false:                                       ; preds = %if.then8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call10, %cond.true ], [ null, %cond.false ]
  store ptr %cond, ptr %retval, align 8
  br label %return

if.end11:                                         ; preds = %do.end
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end11, %cond.end, %if.then
  %12 = load ptr, ptr %retval, align 8
  ret ptr %12
}

; Function Attrs: nounwind uwtable
define internal ptr @os_lchown_impl(ptr noundef %module, ptr noundef %path, i32 noundef %uid, i32 noundef %gid) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %path.addr = alloca ptr, align 8
  %uid.addr = alloca i32, align 4
  %gid.addr = alloca i32, align 4
  %res = alloca i32, align 4
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %path, ptr %path.addr, align 8
  store i32 %uid, ptr %uid.addr, align 4
  store i32 %gid, ptr %gid.addr, align 4
  %0 = load ptr, ptr %path.addr, align 8
  %object = getelementptr inbounds %struct.path_t, ptr %0, i32 0, i32 8
  %1 = load ptr, ptr %object, align 8
  %2 = load i32, ptr %uid.addr, align 4
  %3 = load i32, ptr %gid.addr, align 4
  %call = call i32 (ptr, ptr, ...) @PySys_Audit(ptr noundef @.str.212, ptr noundef @.str.213, ptr noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef -1)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call ptr @PyEval_SaveThread()
  store ptr %call1, ptr %_save, align 8
  %4 = load ptr, ptr %path.addr, align 8
  %narrow = getelementptr inbounds %struct.path_t, ptr %4, i32 0, i32 5
  %5 = load ptr, ptr %narrow, align 8
  %6 = load i32, ptr %uid.addr, align 4
  %7 = load i32, ptr %gid.addr, align 4
  %call2 = call i32 @lchown(ptr noundef %5, i32 noundef %6, i32 noundef %7) #10
  store i32 %call2, ptr %res, align 4
  %8 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %8)
  %9 = load i32, ptr %res, align 4
  %cmp3 = icmp slt i32 %9, 0
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %10 = load ptr, ptr %path.addr, align 8
  %call5 = call ptr @path_error(ptr noundef %10)
  store ptr %call5, ptr %retval, align 8
  br label %return

if.end6:                                          ; preds = %if.end
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end6, %if.then4, %if.then
  %11 = load ptr, ptr %retval, align 8
  ret ptr %11
}

; Function Attrs: nounwind uwtable
define internal ptr @os_chroot_impl(ptr noundef %module, ptr noundef %path) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %path.addr = alloca ptr, align 8
  %res = alloca i32, align 4
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %path, ptr %path.addr, align 8
  %call = call ptr @PyEval_SaveThread()
  store ptr %call, ptr %_save, align 8
  %0 = load ptr, ptr %path.addr, align 8
  %narrow = getelementptr inbounds %struct.path_t, ptr %0, i32 0, i32 5
  %1 = load ptr, ptr %narrow, align 8
  %call1 = call i32 @chroot(ptr noundef %1) #10
  store i32 %call1, ptr %res, align 4
  %2 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %2)
  %3 = load i32, ptr %res, align 4
  %cmp = icmp slt i32 %3, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr %path.addr, align 8
  %call2 = call ptr @path_error(ptr noundef %4)
  store ptr %call2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %5 = load ptr, ptr %retval, align 8
  ret ptr %5
}

; Function Attrs: nounwind
declare i32 @chroot(ptr noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_ctermid_impl(ptr noundef %module) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %ret = alloca ptr, align 8
  %buffer = alloca [9 x i8], align 1
  store ptr %module, ptr %module.addr, align 8
  %arraydecay = getelementptr inbounds [9 x i8], ptr %buffer, i64 0, i64 0
  %call = call ptr @ctermid(ptr noundef %arraydecay) #10
  store ptr %call, ptr %ret, align 8
  %0 = load ptr, ptr %ret, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call ptr @posix_error()
  store ptr %call1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %arraydecay2 = getelementptr inbounds [9 x i8], ptr %buffer, i64 0, i64 0
  %call3 = call ptr @PyUnicode_DecodeFSDefault(ptr noundef %arraydecay2)
  store ptr %call3, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %1 = load ptr, ptr %retval, align 8
  ret ptr %1
}

; Function Attrs: nounwind
declare ptr @ctermid(ptr noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_getcwd_impl(ptr noundef %module) #0 {
entry:
  %module.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  %call = call ptr @posix_getcwd(i32 noundef 0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @posix_getcwd(i32 noundef %use_bytes) #0 {
entry:
  %retval = alloca ptr, align 8
  %use_bytes.addr = alloca i32, align 4
  %chunk = alloca i64, align 8
  %buf = alloca ptr, align 8
  %cwd = alloca ptr, align 8
  %buflen = alloca i64, align 8
  %_save = alloca ptr, align 8
  %newbuf = alloca ptr, align 8
  %obj = alloca ptr, align 8
  store i32 %use_bytes, ptr %use_bytes.addr, align 4
  store i64 1024, ptr %chunk, align 8
  store ptr null, ptr %buf, align 8
  store ptr null, ptr %cwd, align 8
  store i64 0, ptr %buflen, align 8
  %call = call ptr @PyEval_SaveThread()
  store ptr %call, ptr %_save, align 8
  br label %do.body

do.body:                                          ; preds = %land.end, %entry
  %0 = load i64, ptr %buflen, align 8
  %cmp = icmp ule i64 %0, 9223372036854774783
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  %1 = load i64, ptr %buflen, align 8
  %add = add i64 %1, 1024
  store i64 %add, ptr %buflen, align 8
  %2 = load ptr, ptr %buf, align 8
  %3 = load i64, ptr %buflen, align 8
  %call1 = call ptr @PyMem_RawRealloc(ptr noundef %2, i64 noundef %3)
  store ptr %call1, ptr %newbuf, align 8
  br label %if.end

if.else:                                          ; preds = %do.body
  store ptr null, ptr %newbuf, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %4 = load ptr, ptr %newbuf, align 8
  %cmp2 = icmp eq ptr %4, null
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %5 = load ptr, ptr %buf, align 8
  call void @PyMem_RawFree(ptr noundef %5)
  store ptr null, ptr %buf, align 8
  br label %do.end

if.end4:                                          ; preds = %if.end
  %6 = load ptr, ptr %newbuf, align 8
  store ptr %6, ptr %buf, align 8
  %7 = load ptr, ptr %buf, align 8
  %8 = load i64, ptr %buflen, align 8
  %call5 = call ptr @getcwd(ptr noundef %7, i64 noundef %8) #10
  store ptr %call5, ptr %cwd, align 8
  br label %do.cond

do.cond:                                          ; preds = %if.end4
  %9 = load ptr, ptr %cwd, align 8
  %cmp6 = icmp eq ptr %9, null
  br i1 %cmp6, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %do.cond
  %call7 = call ptr @__errno_location() #12
  %10 = load i32, ptr %call7, align 4
  %cmp8 = icmp eq i32 %10, 34
  br label %land.end

land.end:                                         ; preds = %land.rhs, %do.cond
  %11 = phi i1 [ false, %do.cond ], [ %cmp8, %land.rhs ]
  br i1 %11, label %do.body, label %do.end, !llvm.loop !11

do.end:                                           ; preds = %land.end, %if.then3
  %12 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %12)
  %13 = load ptr, ptr %buf, align 8
  %cmp9 = icmp eq ptr %13, null
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %do.end
  %call11 = call ptr @PyErr_NoMemory()
  store ptr %call11, ptr %retval, align 8
  br label %return

if.end12:                                         ; preds = %do.end
  %14 = load ptr, ptr %cwd, align 8
  %cmp13 = icmp eq ptr %14, null
  br i1 %cmp13, label %if.then14, label %if.end16

if.then14:                                        ; preds = %if.end12
  %call15 = call ptr @posix_error()
  %15 = load ptr, ptr %buf, align 8
  call void @PyMem_RawFree(ptr noundef %15)
  store ptr null, ptr %retval, align 8
  br label %return

if.end16:                                         ; preds = %if.end12
  %16 = load i32, ptr %use_bytes.addr, align 4
  %tobool = icmp ne i32 %16, 0
  br i1 %tobool, label %if.then17, label %if.else20

if.then17:                                        ; preds = %if.end16
  %17 = load ptr, ptr %buf, align 8
  %18 = load ptr, ptr %buf, align 8
  %call18 = call i64 @strlen(ptr noundef %18) #13
  %call19 = call ptr @PyBytes_FromStringAndSize(ptr noundef %17, i64 noundef %call18)
  store ptr %call19, ptr %obj, align 8
  br label %if.end22

if.else20:                                        ; preds = %if.end16
  %19 = load ptr, ptr %buf, align 8
  %call21 = call ptr @PyUnicode_DecodeFSDefault(ptr noundef %19)
  store ptr %call21, ptr %obj, align 8
  br label %if.end22

if.end22:                                         ; preds = %if.else20, %if.then17
  %20 = load ptr, ptr %buf, align 8
  call void @PyMem_RawFree(ptr noundef %20)
  %21 = load ptr, ptr %obj, align 8
  store ptr %21, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end22, %if.then14, %if.then10
  %22 = load ptr, ptr %retval, align 8
  ret ptr %22
}

declare ptr @PyMem_RawRealloc(ptr noundef, i64 noundef) #1

; Function Attrs: nounwind
declare ptr @getcwd(ptr noundef, i64 noundef) #4

declare ptr @PyBytes_FromStringAndSize(ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @os_getcwdb_impl(ptr noundef %module) #0 {
entry:
  %module.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  %call = call ptr @posix_getcwd(i32 noundef 1)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @os_link_impl(ptr noundef %module, ptr noundef %src, ptr noundef %dst, i32 noundef %src_dir_fd, i32 noundef %dst_dir_fd, i32 noundef %follow_symlinks) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %src.addr = alloca ptr, align 8
  %dst.addr = alloca ptr, align 8
  %src_dir_fd.addr = alloca i32, align 4
  %dst_dir_fd.addr = alloca i32, align 4
  %follow_symlinks.addr = alloca i32, align 4
  %result = alloca i32, align 4
  %linkat_unavailable = alloca i32, align 4
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %src, ptr %src.addr, align 8
  store ptr %dst, ptr %dst.addr, align 8
  store i32 %src_dir_fd, ptr %src_dir_fd.addr, align 4
  store i32 %dst_dir_fd, ptr %dst_dir_fd.addr, align 4
  store i32 %follow_symlinks, ptr %follow_symlinks.addr, align 4
  store i32 0, ptr %linkat_unavailable, align 4
  %0 = load ptr, ptr %src.addr, align 8
  %narrow = getelementptr inbounds %struct.path_t, ptr %0, i32 0, i32 5
  %1 = load ptr, ptr %narrow, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %2 = load ptr, ptr %dst.addr, align 8
  %wide = getelementptr inbounds %struct.path_t, ptr %2, i32 0, i32 4
  %3 = load ptr, ptr %wide, align 8
  %tobool1 = icmp ne ptr %3, null
  br i1 %tobool1, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %4 = load ptr, ptr %src.addr, align 8
  %wide2 = getelementptr inbounds %struct.path_t, ptr %4, i32 0, i32 4
  %5 = load ptr, ptr %wide2, align 8
  %tobool3 = icmp ne ptr %5, null
  br i1 %tobool3, label %land.lhs.true4, label %if.end

land.lhs.true4:                                   ; preds = %lor.lhs.false
  %6 = load ptr, ptr %dst.addr, align 8
  %narrow5 = getelementptr inbounds %struct.path_t, ptr %6, i32 0, i32 5
  %7 = load ptr, ptr %narrow5, align 8
  %tobool6 = icmp ne ptr %7, null
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true4, %land.lhs.true
  %8 = load ptr, ptr @PyExc_NotImplementedError, align 8
  call void @PyErr_SetString(ptr noundef %8, ptr noundef @.str.219)
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %land.lhs.true4, %lor.lhs.false
  %9 = load ptr, ptr %src.addr, align 8
  %object = getelementptr inbounds %struct.path_t, ptr %9, i32 0, i32 8
  %10 = load ptr, ptr %object, align 8
  %11 = load ptr, ptr %dst.addr, align 8
  %object7 = getelementptr inbounds %struct.path_t, ptr %11, i32 0, i32 8
  %12 = load ptr, ptr %object7, align 8
  %13 = load i32, ptr %src_dir_fd.addr, align 4
  %cmp = icmp eq i32 %13, -100
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %14 = load i32, ptr %src_dir_fd.addr, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ -1, %cond.true ], [ %14, %cond.false ]
  %15 = load i32, ptr %dst_dir_fd.addr, align 4
  %cmp8 = icmp eq i32 %15, -100
  br i1 %cmp8, label %cond.true9, label %cond.false10

cond.true9:                                       ; preds = %cond.end
  br label %cond.end11

cond.false10:                                     ; preds = %cond.end
  %16 = load i32, ptr %dst_dir_fd.addr, align 4
  br label %cond.end11

cond.end11:                                       ; preds = %cond.false10, %cond.true9
  %cond12 = phi i32 [ -1, %cond.true9 ], [ %16, %cond.false10 ]
  %call = call i32 (ptr, ptr, ...) @PySys_Audit(ptr noundef @.str.220, ptr noundef @.str.221, ptr noundef %10, ptr noundef %12, i32 noundef %cond, i32 noundef %cond12)
  %cmp13 = icmp slt i32 %call, 0
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %cond.end11
  store ptr null, ptr %retval, align 8
  br label %return

if.end15:                                         ; preds = %cond.end11
  %call16 = call ptr @PyEval_SaveThread()
  store ptr %call16, ptr %_save, align 8
  %17 = load i32, ptr %src_dir_fd.addr, align 4
  %cmp17 = icmp ne i32 %17, -100
  br i1 %cmp17, label %if.then22, label %lor.lhs.false18

lor.lhs.false18:                                  ; preds = %if.end15
  %18 = load i32, ptr %dst_dir_fd.addr, align 4
  %cmp19 = icmp ne i32 %18, -100
  br i1 %cmp19, label %if.then22, label %lor.lhs.false20

lor.lhs.false20:                                  ; preds = %lor.lhs.false18
  %19 = load i32, ptr %follow_symlinks.addr, align 4
  %tobool21 = icmp ne i32 %19, 0
  br i1 %tobool21, label %if.else, label %if.then22

if.then22:                                        ; preds = %lor.lhs.false20, %lor.lhs.false18, %if.end15
  %20 = load i32, ptr %src_dir_fd.addr, align 4
  %21 = load ptr, ptr %src.addr, align 8
  %narrow23 = getelementptr inbounds %struct.path_t, ptr %21, i32 0, i32 5
  %22 = load ptr, ptr %narrow23, align 8
  %23 = load i32, ptr %dst_dir_fd.addr, align 4
  %24 = load ptr, ptr %dst.addr, align 8
  %narrow24 = getelementptr inbounds %struct.path_t, ptr %24, i32 0, i32 5
  %25 = load ptr, ptr %narrow24, align 8
  %26 = load i32, ptr %follow_symlinks.addr, align 4
  %tobool25 = icmp ne i32 %26, 0
  %cond26 = select i1 %tobool25, i32 1024, i32 0
  %call27 = call i32 @linkat(i32 noundef %20, ptr noundef %22, i32 noundef %23, ptr noundef %25, i32 noundef %cond26) #10
  store i32 %call27, ptr %result, align 4
  br label %if.end31

if.else:                                          ; preds = %lor.lhs.false20
  %27 = load ptr, ptr %src.addr, align 8
  %narrow28 = getelementptr inbounds %struct.path_t, ptr %27, i32 0, i32 5
  %28 = load ptr, ptr %narrow28, align 8
  %29 = load ptr, ptr %dst.addr, align 8
  %narrow29 = getelementptr inbounds %struct.path_t, ptr %29, i32 0, i32 5
  %30 = load ptr, ptr %narrow29, align 8
  %call30 = call i32 @link(ptr noundef %28, ptr noundef %30) #10
  store i32 %call30, ptr %result, align 4
  br label %if.end31

if.end31:                                         ; preds = %if.else, %if.then22
  %31 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %31)
  %32 = load i32, ptr %linkat_unavailable, align 4
  %tobool32 = icmp ne i32 %32, 0
  br i1 %tobool32, label %if.then33, label %if.end38

if.then33:                                        ; preds = %if.end31
  %33 = load i32, ptr %src_dir_fd.addr, align 4
  %cmp34 = icmp ne i32 %33, -100
  br i1 %cmp34, label %if.then35, label %if.else36

if.then35:                                        ; preds = %if.then33
  call void @argument_unavailable_error(ptr noundef @.str.25, ptr noundef @.str.217)
  br label %if.end37

if.else36:                                        ; preds = %if.then33
  call void @argument_unavailable_error(ptr noundef @.str.25, ptr noundef @.str.218)
  br label %if.end37

if.end37:                                         ; preds = %if.else36, %if.then35
  store ptr null, ptr %retval, align 8
  br label %return

if.end38:                                         ; preds = %if.end31
  %34 = load i32, ptr %result, align 4
  %tobool39 = icmp ne i32 %34, 0
  br i1 %tobool39, label %if.then40, label %if.end42

if.then40:                                        ; preds = %if.end38
  %35 = load ptr, ptr %src.addr, align 8
  %36 = load ptr, ptr %dst.addr, align 8
  %call41 = call ptr @path_error2(ptr noundef %35, ptr noundef %36)
  store ptr %call41, ptr %retval, align 8
  br label %return

if.end42:                                         ; preds = %if.end38
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end42, %if.then40, %if.end37, %if.then14, %if.then
  %37 = load ptr, ptr %retval, align 8
  ret ptr %37
}

; Function Attrs: nounwind
declare i32 @linkat(i32 noundef, ptr noundef, i32 noundef, ptr noundef, i32 noundef) #4

; Function Attrs: nounwind
declare i32 @link(ptr noundef, ptr noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @path_error2(ptr noundef %path, ptr noundef %path2) #0 {
entry:
  %path.addr = alloca ptr, align 8
  %path2.addr = alloca ptr, align 8
  store ptr %path, ptr %path.addr, align 8
  store ptr %path2, ptr %path2.addr, align 8
  %0 = load ptr, ptr %path.addr, align 8
  %object = getelementptr inbounds %struct.path_t, ptr %0, i32 0, i32 8
  %1 = load ptr, ptr %object, align 8
  %2 = load ptr, ptr %path2.addr, align 8
  %object1 = getelementptr inbounds %struct.path_t, ptr %2, i32 0, i32 8
  %3 = load ptr, ptr %object1, align 8
  %call = call ptr @path_object_error2(ptr noundef %1, ptr noundef %3)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @path_object_error2(ptr noundef %path, ptr noundef %path2) #0 {
entry:
  %path.addr = alloca ptr, align 8
  %path2.addr = alloca ptr, align 8
  store ptr %path, ptr %path.addr, align 8
  store ptr %path2, ptr %path2.addr, align 8
  %0 = load ptr, ptr @PyExc_OSError, align 8
  %1 = load ptr, ptr %path.addr, align 8
  %2 = load ptr, ptr %path2.addr, align 8
  %call = call ptr @PyErr_SetFromErrnoWithFilenameObjects(ptr noundef %0, ptr noundef %1, ptr noundef %2)
  ret ptr %call
}

declare ptr @PyErr_SetFromErrnoWithFilenameObjects(ptr noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @os_listdir_impl(ptr noundef %module, ptr noundef %path) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %path.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %path, ptr %path.addr, align 8
  %0 = load ptr, ptr %path.addr, align 8
  %object = getelementptr inbounds %struct.path_t, ptr %0, i32 0, i32 8
  %1 = load ptr, ptr %object, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %path.addr, align 8
  %object1 = getelementptr inbounds %struct.path_t, ptr %2, i32 0, i32 8
  %3 = load ptr, ptr %object1, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %3, %cond.true ], [ @_Py_NoneStruct, %cond.false ]
  %call = call i32 (ptr, ptr, ...) @PySys_Audit(ptr noundef @.str.222, ptr noundef @.str.223, ptr noundef %cond)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end
  %4 = load ptr, ptr %path.addr, align 8
  %call2 = call ptr @_posix_listdir(ptr noundef %4, ptr noundef null)
  store ptr %call2, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %5 = load ptr, ptr %retval, align 8
  ret ptr %5
}

; Function Attrs: nounwind uwtable
define internal ptr @_posix_listdir(ptr noundef %path, ptr noundef %list) #0 {
entry:
  %op.addr.i169 = alloca ptr, align 8
  %op.addr.i165 = alloca ptr, align 8
  %op.addr.i161 = alloca ptr, align 8
  %op.addr.i157 = alloca ptr, align 8
  %op.addr.i155 = alloca ptr, align 8
  %op.addr.i146 = alloca ptr, align 8
  %op.addr.i137 = alloca ptr, align 8
  %op.addr.i128 = alloca ptr, align 8
  %op.addr.i119 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %path.addr = alloca ptr, align 8
  %list.addr = alloca ptr, align 8
  %v = alloca ptr, align 8
  %dirp = alloca ptr, align 8
  %ep = alloca ptr, align 8
  %return_str = alloca i32, align 4
  %fd = alloca i32, align 4
  %_save = alloca ptr, align 8
  %name = alloca ptr, align 8
  %_save15 = alloca ptr, align 8
  %_save24 = alloca ptr, align 8
  %_save34 = alloca ptr, align 8
  %_tmp_op_ptr = alloca ptr, align 8
  %_tmp_old_op = alloca ptr, align 8
  %_tmp_op_ptr87 = alloca ptr, align 8
  %_tmp_old_op88 = alloca ptr, align 8
  %_tmp_op_ptr100 = alloca ptr, align 8
  %_tmp_old_op101 = alloca ptr, align 8
  %_save111 = alloca ptr, align 8
  store ptr %path, ptr %path.addr, align 8
  store ptr %list, ptr %list.addr, align 8
  store ptr null, ptr %dirp, align 8
  store i32 -1, ptr %fd, align 4
  %call = call ptr @__errno_location() #12
  store i32 0, ptr %call, align 4
  %0 = load ptr, ptr %path.addr, align 8
  %fd1 = getelementptr inbounds %struct.path_t, ptr %0, i32 0, i32 6
  %1 = load i32, ptr %fd1, align 8
  %cmp = icmp ne i32 %1, -1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %path.addr, align 8
  %fd2 = getelementptr inbounds %struct.path_t, ptr %2, i32 0, i32 6
  %3 = load i32, ptr %fd2, align 8
  %call3 = call i32 @_Py_dup(i32 noundef %3)
  store i32 %call3, ptr %fd, align 4
  %4 = load i32, ptr %fd, align 4
  %cmp4 = icmp eq i32 %4, -1
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.then
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %if.then
  store i32 1, ptr %return_str, align 4
  %call6 = call ptr @PyEval_SaveThread()
  store ptr %call6, ptr %_save, align 8
  %5 = load i32, ptr %fd, align 4
  %call7 = call ptr @fdopendir(i32 noundef %5)
  store ptr %call7, ptr %dirp, align 8
  %6 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %6)
  br label %if.end18

if.else:                                          ; preds = %entry
  %7 = load ptr, ptr %path.addr, align 8
  %narrow = getelementptr inbounds %struct.path_t, ptr %7, i32 0, i32 5
  %8 = load ptr, ptr %narrow, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.then8, label %if.else13

if.then8:                                         ; preds = %if.else
  %9 = load ptr, ptr %path.addr, align 8
  %narrow9 = getelementptr inbounds %struct.path_t, ptr %9, i32 0, i32 5
  %10 = load ptr, ptr %narrow9, align 8
  store ptr %10, ptr %name, align 8
  %11 = load ptr, ptr %path.addr, align 8
  %object = getelementptr inbounds %struct.path_t, ptr %11, i32 0, i32 8
  %12 = load ptr, ptr %object, align 8
  %call10 = call ptr @Py_TYPE(ptr noundef %12)
  %call11 = call i32 @PyType_HasFeature(ptr noundef %call10, i64 noundef 134217728)
  %tobool12 = icmp ne i32 %call11, 0
  %lnot = xor i1 %tobool12, true
  %lnot.ext = zext i1 %lnot to i32
  store i32 %lnot.ext, ptr %return_str, align 4
  br label %if.end14

if.else13:                                        ; preds = %if.else
  store ptr @.str.224, ptr %name, align 8
  store i32 1, ptr %return_str, align 4
  br label %if.end14

if.end14:                                         ; preds = %if.else13, %if.then8
  %call16 = call ptr @PyEval_SaveThread()
  store ptr %call16, ptr %_save15, align 8
  %13 = load ptr, ptr %name, align 8
  %call17 = call ptr @opendir(ptr noundef %13)
  store ptr %call17, ptr %dirp, align 8
  %14 = load ptr, ptr %_save15, align 8
  call void @PyEval_RestoreThread(ptr noundef %14)
  br label %if.end18

if.end18:                                         ; preds = %if.end14, %if.end
  %15 = load ptr, ptr %dirp, align 8
  %cmp19 = icmp eq ptr %15, null
  br i1 %cmp19, label %if.then20, label %if.end28

if.then20:                                        ; preds = %if.end18
  %16 = load ptr, ptr %path.addr, align 8
  %call21 = call ptr @path_error(ptr noundef %16)
  store ptr null, ptr %list.addr, align 8
  %17 = load i32, ptr %fd, align 4
  %cmp22 = icmp ne i32 %17, -1
  br i1 %cmp22, label %if.then23, label %if.end27

if.then23:                                        ; preds = %if.then20
  %call25 = call ptr @PyEval_SaveThread()
  store ptr %call25, ptr %_save24, align 8
  %18 = load i32, ptr %fd, align 4
  %call26 = call i32 @close(i32 noundef %18)
  %19 = load ptr, ptr %_save24, align 8
  call void @PyEval_RestoreThread(ptr noundef %19)
  br label %if.end27

if.end27:                                         ; preds = %if.then23, %if.then20
  br label %exit

if.end28:                                         ; preds = %if.end18
  %call29 = call ptr @PyList_New(i64 noundef 0)
  store ptr %call29, ptr %list.addr, align 8
  %cmp30 = icmp eq ptr %call29, null
  br i1 %cmp30, label %if.then31, label %if.end32

if.then31:                                        ; preds = %if.end28
  br label %exit

if.end32:                                         ; preds = %if.end28
  br label %for.cond

for.cond:                                         ; preds = %Py_DECREF.exit, %if.then65, %if.end32
  %call33 = call ptr @__errno_location() #12
  store i32 0, ptr %call33, align 4
  %call35 = call ptr @PyEval_SaveThread()
  store ptr %call35, ptr %_save34, align 8
  %20 = load ptr, ptr %dirp, align 8
  %call36 = call ptr @readdir64(ptr noundef %20)
  store ptr %call36, ptr %ep, align 8
  %21 = load ptr, ptr %_save34, align 8
  call void @PyEval_RestoreThread(ptr noundef %21)
  %22 = load ptr, ptr %ep, align 8
  %cmp37 = icmp eq ptr %22, null
  br i1 %cmp37, label %if.then38, label %if.end47

if.then38:                                        ; preds = %for.cond
  %call39 = call ptr @__errno_location() #12
  %23 = load i32, ptr %call39, align 4
  %cmp40 = icmp eq i32 %23, 0
  br i1 %cmp40, label %if.then41, label %if.else42

if.then41:                                        ; preds = %if.then38
  br label %for.end

if.else42:                                        ; preds = %if.then38
  %24 = load ptr, ptr %path.addr, align 8
  %call43 = call ptr @path_error(ptr noundef %24)
  br label %do.body

do.body:                                          ; preds = %if.else42
  store ptr %list.addr, ptr %_tmp_op_ptr, align 8
  %25 = load ptr, ptr %_tmp_op_ptr, align 8
  %26 = load ptr, ptr %25, align 8
  store ptr %26, ptr %_tmp_old_op, align 8
  %27 = load ptr, ptr %_tmp_old_op, align 8
  %cmp44 = icmp ne ptr %27, null
  br i1 %cmp44, label %if.then45, label %if.end46

if.then45:                                        ; preds = %do.body
  %28 = load ptr, ptr %_tmp_op_ptr, align 8
  store ptr null, ptr %28, align 8
  %29 = load ptr, ptr %_tmp_old_op, align 8
  store ptr %29, ptr %op.addr.i146, align 8
  %30 = load ptr, ptr %op.addr.i146, align 8
  store ptr %30, ptr %op.addr.i155, align 8
  %31 = load ptr, ptr %op.addr.i155, align 8
  %32 = load i64, ptr %31, align 8
  %conv.i = trunc i64 %32 to i32
  %cmp.i156 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i156 to i32
  %tobool.i148 = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i148, label %if.then.i153, label %if.end.i149

if.then.i153:                                     ; preds = %if.then45
  br label %Py_DECREF.exit154

if.end.i149:                                      ; preds = %if.then45
  %33 = load ptr, ptr %op.addr.i146, align 8
  %34 = load i64, ptr %33, align 8
  %dec.i150 = add i64 %34, -1
  store i64 %dec.i150, ptr %33, align 8
  %cmp.i151 = icmp eq i64 %dec.i150, 0
  br i1 %cmp.i151, label %if.then1.i152, label %Py_DECREF.exit154

if.then1.i152:                                    ; preds = %if.end.i149
  %35 = load ptr, ptr %op.addr.i146, align 8
  call void @_Py_Dealloc(ptr noundef %35) #10
  br label %Py_DECREF.exit154

Py_DECREF.exit154:                                ; preds = %if.then1.i152, %if.end.i149, %if.then.i153
  br label %if.end46

if.end46:                                         ; preds = %Py_DECREF.exit154, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end46
  br label %exit

if.end47:                                         ; preds = %for.cond
  %36 = load ptr, ptr %ep, align 8
  %d_name = getelementptr inbounds %struct.dirent, ptr %36, i32 0, i32 4
  %arrayidx = getelementptr [256 x i8], ptr %d_name, i64 0, i64 0
  %37 = load i8, ptr %arrayidx, align 1
  %conv = sext i8 %37 to i32
  %cmp48 = icmp eq i32 %conv, 46
  br i1 %cmp48, label %land.lhs.true, label %if.end66

land.lhs.true:                                    ; preds = %if.end47
  %38 = load ptr, ptr %ep, align 8
  %d_name50 = getelementptr inbounds %struct.dirent, ptr %38, i32 0, i32 4
  %arraydecay = getelementptr inbounds [256 x i8], ptr %d_name50, i64 0, i64 0
  %call51 = call i64 @strlen(ptr noundef %arraydecay) #13
  %cmp52 = icmp eq i64 %call51, 1
  br i1 %cmp52, label %if.then65, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %39 = load ptr, ptr %ep, align 8
  %d_name54 = getelementptr inbounds %struct.dirent, ptr %39, i32 0, i32 4
  %arrayidx55 = getelementptr [256 x i8], ptr %d_name54, i64 0, i64 1
  %40 = load i8, ptr %arrayidx55, align 1
  %conv56 = sext i8 %40 to i32
  %cmp57 = icmp eq i32 %conv56, 46
  br i1 %cmp57, label %land.lhs.true59, label %if.end66

land.lhs.true59:                                  ; preds = %lor.lhs.false
  %41 = load ptr, ptr %ep, align 8
  %d_name60 = getelementptr inbounds %struct.dirent, ptr %41, i32 0, i32 4
  %arraydecay61 = getelementptr inbounds [256 x i8], ptr %d_name60, i64 0, i64 0
  %call62 = call i64 @strlen(ptr noundef %arraydecay61) #13
  %cmp63 = icmp eq i64 %call62, 2
  br i1 %cmp63, label %if.then65, label %if.end66

if.then65:                                        ; preds = %land.lhs.true59, %land.lhs.true
  br label %for.cond

if.end66:                                         ; preds = %land.lhs.true59, %lor.lhs.false, %if.end47
  %42 = load i32, ptr %return_str, align 4
  %tobool67 = icmp ne i32 %42, 0
  br i1 %tobool67, label %if.then68, label %if.else75

if.then68:                                        ; preds = %if.end66
  %43 = load ptr, ptr %ep, align 8
  %d_name69 = getelementptr inbounds %struct.dirent, ptr %43, i32 0, i32 4
  %arraydecay70 = getelementptr inbounds [256 x i8], ptr %d_name69, i64 0, i64 0
  %44 = load ptr, ptr %ep, align 8
  %d_name71 = getelementptr inbounds %struct.dirent, ptr %44, i32 0, i32 4
  %arraydecay72 = getelementptr inbounds [256 x i8], ptr %d_name71, i64 0, i64 0
  %call73 = call i64 @strlen(ptr noundef %arraydecay72) #13
  %call74 = call ptr @PyUnicode_DecodeFSDefaultAndSize(ptr noundef %arraydecay70, i64 noundef %call73)
  store ptr %call74, ptr %v, align 8
  br label %if.end82

if.else75:                                        ; preds = %if.end66
  %45 = load ptr, ptr %ep, align 8
  %d_name76 = getelementptr inbounds %struct.dirent, ptr %45, i32 0, i32 4
  %arraydecay77 = getelementptr inbounds [256 x i8], ptr %d_name76, i64 0, i64 0
  %46 = load ptr, ptr %ep, align 8
  %d_name78 = getelementptr inbounds %struct.dirent, ptr %46, i32 0, i32 4
  %arraydecay79 = getelementptr inbounds [256 x i8], ptr %d_name78, i64 0, i64 0
  %call80 = call i64 @strlen(ptr noundef %arraydecay79) #13
  %call81 = call ptr @PyBytes_FromStringAndSize(ptr noundef %arraydecay77, i64 noundef %call80)
  store ptr %call81, ptr %v, align 8
  br label %if.end82

if.end82:                                         ; preds = %if.else75, %if.then68
  %47 = load ptr, ptr %v, align 8
  %cmp83 = icmp eq ptr %47, null
  br i1 %cmp83, label %if.then85, label %if.end94

if.then85:                                        ; preds = %if.end82
  br label %do.body86

do.body86:                                        ; preds = %if.then85
  store ptr %list.addr, ptr %_tmp_op_ptr87, align 8
  %48 = load ptr, ptr %_tmp_op_ptr87, align 8
  %49 = load ptr, ptr %48, align 8
  store ptr %49, ptr %_tmp_old_op88, align 8
  %50 = load ptr, ptr %_tmp_old_op88, align 8
  %cmp89 = icmp ne ptr %50, null
  br i1 %cmp89, label %if.then91, label %if.end92

if.then91:                                        ; preds = %do.body86
  %51 = load ptr, ptr %_tmp_op_ptr87, align 8
  store ptr null, ptr %51, align 8
  %52 = load ptr, ptr %_tmp_old_op88, align 8
  store ptr %52, ptr %op.addr.i137, align 8
  %53 = load ptr, ptr %op.addr.i137, align 8
  store ptr %53, ptr %op.addr.i157, align 8
  %54 = load ptr, ptr %op.addr.i157, align 8
  %55 = load i64, ptr %54, align 8
  %conv.i158 = trunc i64 %55 to i32
  %cmp.i159 = icmp slt i32 %conv.i158, 0
  %conv1.i160 = zext i1 %cmp.i159 to i32
  %tobool.i139 = icmp ne i32 %conv1.i160, 0
  br i1 %tobool.i139, label %if.then.i144, label %if.end.i140

if.then.i144:                                     ; preds = %if.then91
  br label %Py_DECREF.exit145

if.end.i140:                                      ; preds = %if.then91
  %56 = load ptr, ptr %op.addr.i137, align 8
  %57 = load i64, ptr %56, align 8
  %dec.i141 = add i64 %57, -1
  store i64 %dec.i141, ptr %56, align 8
  %cmp.i142 = icmp eq i64 %dec.i141, 0
  br i1 %cmp.i142, label %if.then1.i143, label %Py_DECREF.exit145

if.then1.i143:                                    ; preds = %if.end.i140
  %58 = load ptr, ptr %op.addr.i137, align 8
  call void @_Py_Dealloc(ptr noundef %58) #10
  br label %Py_DECREF.exit145

Py_DECREF.exit145:                                ; preds = %if.then1.i143, %if.end.i140, %if.then.i144
  br label %if.end92

if.end92:                                         ; preds = %Py_DECREF.exit145, %do.body86
  br label %do.end93

do.end93:                                         ; preds = %if.end92
  br label %for.end

if.end94:                                         ; preds = %if.end82
  %59 = load ptr, ptr %list.addr, align 8
  %60 = load ptr, ptr %v, align 8
  %call95 = call i32 @PyList_Append(ptr noundef %59, ptr noundef %60)
  %cmp96 = icmp ne i32 %call95, 0
  br i1 %cmp96, label %if.then98, label %if.end107

if.then98:                                        ; preds = %if.end94
  %61 = load ptr, ptr %v, align 8
  store ptr %61, ptr %op.addr.i128, align 8
  %62 = load ptr, ptr %op.addr.i128, align 8
  store ptr %62, ptr %op.addr.i161, align 8
  %63 = load ptr, ptr %op.addr.i161, align 8
  %64 = load i64, ptr %63, align 8
  %conv.i162 = trunc i64 %64 to i32
  %cmp.i163 = icmp slt i32 %conv.i162, 0
  %conv1.i164 = zext i1 %cmp.i163 to i32
  %tobool.i130 = icmp ne i32 %conv1.i164, 0
  br i1 %tobool.i130, label %if.then.i135, label %if.end.i131

if.then.i135:                                     ; preds = %if.then98
  br label %Py_DECREF.exit136

if.end.i131:                                      ; preds = %if.then98
  %65 = load ptr, ptr %op.addr.i128, align 8
  %66 = load i64, ptr %65, align 8
  %dec.i132 = add i64 %66, -1
  store i64 %dec.i132, ptr %65, align 8
  %cmp.i133 = icmp eq i64 %dec.i132, 0
  br i1 %cmp.i133, label %if.then1.i134, label %Py_DECREF.exit136

if.then1.i134:                                    ; preds = %if.end.i131
  %67 = load ptr, ptr %op.addr.i128, align 8
  call void @_Py_Dealloc(ptr noundef %67) #10
  br label %Py_DECREF.exit136

Py_DECREF.exit136:                                ; preds = %if.then1.i134, %if.end.i131, %if.then.i135
  br label %do.body99

do.body99:                                        ; preds = %Py_DECREF.exit136
  store ptr %list.addr, ptr %_tmp_op_ptr100, align 8
  %68 = load ptr, ptr %_tmp_op_ptr100, align 8
  %69 = load ptr, ptr %68, align 8
  store ptr %69, ptr %_tmp_old_op101, align 8
  %70 = load ptr, ptr %_tmp_old_op101, align 8
  %cmp102 = icmp ne ptr %70, null
  br i1 %cmp102, label %if.then104, label %if.end105

if.then104:                                       ; preds = %do.body99
  %71 = load ptr, ptr %_tmp_op_ptr100, align 8
  store ptr null, ptr %71, align 8
  %72 = load ptr, ptr %_tmp_old_op101, align 8
  store ptr %72, ptr %op.addr.i119, align 8
  %73 = load ptr, ptr %op.addr.i119, align 8
  store ptr %73, ptr %op.addr.i165, align 8
  %74 = load ptr, ptr %op.addr.i165, align 8
  %75 = load i64, ptr %74, align 8
  %conv.i166 = trunc i64 %75 to i32
  %cmp.i167 = icmp slt i32 %conv.i166, 0
  %conv1.i168 = zext i1 %cmp.i167 to i32
  %tobool.i121 = icmp ne i32 %conv1.i168, 0
  br i1 %tobool.i121, label %if.then.i126, label %if.end.i122

if.then.i126:                                     ; preds = %if.then104
  br label %Py_DECREF.exit127

if.end.i122:                                      ; preds = %if.then104
  %76 = load ptr, ptr %op.addr.i119, align 8
  %77 = load i64, ptr %76, align 8
  %dec.i123 = add i64 %77, -1
  store i64 %dec.i123, ptr %76, align 8
  %cmp.i124 = icmp eq i64 %dec.i123, 0
  br i1 %cmp.i124, label %if.then1.i125, label %Py_DECREF.exit127

if.then1.i125:                                    ; preds = %if.end.i122
  %78 = load ptr, ptr %op.addr.i119, align 8
  call void @_Py_Dealloc(ptr noundef %78) #10
  br label %Py_DECREF.exit127

Py_DECREF.exit127:                                ; preds = %if.then1.i125, %if.end.i122, %if.then.i126
  br label %if.end105

if.end105:                                        ; preds = %Py_DECREF.exit127, %do.body99
  br label %do.end106

do.end106:                                        ; preds = %if.end105
  br label %for.end

if.end107:                                        ; preds = %if.end94
  %79 = load ptr, ptr %v, align 8
  store ptr %79, ptr %op.addr.i, align 8
  %80 = load ptr, ptr %op.addr.i, align 8
  store ptr %80, ptr %op.addr.i169, align 8
  %81 = load ptr, ptr %op.addr.i169, align 8
  %82 = load i64, ptr %81, align 8
  %conv.i170 = trunc i64 %82 to i32
  %cmp.i171 = icmp slt i32 %conv.i170, 0
  %conv1.i172 = zext i1 %cmp.i171 to i32
  %tobool.i = icmp ne i32 %conv1.i172, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.end107
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.end107
  %83 = load ptr, ptr %op.addr.i, align 8
  %84 = load i64, ptr %83, align 8
  %dec.i = add i64 %84, -1
  store i64 %dec.i, ptr %83, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %85 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %85) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  br label %for.cond

for.end:                                          ; preds = %do.end106, %do.end93, %if.then41
  br label %exit

exit:                                             ; preds = %for.end, %do.end, %if.then31, %if.end27
  %86 = load ptr, ptr %dirp, align 8
  %cmp108 = icmp ne ptr %86, null
  br i1 %cmp108, label %if.then110, label %if.end118

if.then110:                                       ; preds = %exit
  %call112 = call ptr @PyEval_SaveThread()
  store ptr %call112, ptr %_save111, align 8
  %87 = load i32, ptr %fd, align 4
  %cmp113 = icmp sgt i32 %87, -1
  br i1 %cmp113, label %if.then115, label %if.end116

if.then115:                                       ; preds = %if.then110
  %88 = load ptr, ptr %dirp, align 8
  call void @rewinddir(ptr noundef %88) #10
  br label %if.end116

if.end116:                                        ; preds = %if.then115, %if.then110
  %89 = load ptr, ptr %dirp, align 8
  %call117 = call i32 @closedir(ptr noundef %89)
  %90 = load ptr, ptr %_save111, align 8
  call void @PyEval_RestoreThread(ptr noundef %90)
  br label %if.end118

if.end118:                                        ; preds = %if.end116, %exit
  %91 = load ptr, ptr %list.addr, align 8
  store ptr %91, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end118, %if.then5
  %92 = load ptr, ptr %retval, align 8
  ret ptr %92
}

declare i32 @_Py_dup(i32 noundef) #1

declare ptr @fdopendir(i32 noundef) #1

declare ptr @opendir(ptr noundef) #1

declare i32 @close(i32 noundef) #1

declare ptr @PyList_New(i64 noundef) #1

declare ptr @readdir64(ptr noundef) #1

declare ptr @PyUnicode_DecodeFSDefaultAndSize(ptr noundef, i64 noundef) #1

declare i32 @PyList_Append(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind
declare void @rewinddir(ptr noundef) #4

declare i32 @closedir(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @os_lstat_impl(ptr noundef %module, ptr noundef %path, i32 noundef %dir_fd) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %path.addr = alloca ptr, align 8
  %dir_fd.addr = alloca i32, align 4
  %follow_symlinks = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %path, ptr %path.addr, align 8
  store i32 %dir_fd, ptr %dir_fd.addr, align 4
  store i32 0, ptr %follow_symlinks, align 4
  %0 = load ptr, ptr %module.addr, align 8
  %1 = load ptr, ptr %path.addr, align 8
  %2 = load i32, ptr %dir_fd.addr, align 4
  %3 = load i32, ptr %follow_symlinks, align 4
  %call = call ptr @posix_do_stat(ptr noundef %0, ptr noundef @.str.27, ptr noundef %1, i32 noundef %2, i32 noundef %3)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @os_mkdir_impl(ptr noundef %module, ptr noundef %path, i32 noundef %mode, i32 noundef %dir_fd) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %path.addr = alloca ptr, align 8
  %mode.addr = alloca i32, align 4
  %dir_fd.addr = alloca i32, align 4
  %result = alloca i32, align 4
  %mkdirat_unavailable = alloca i32, align 4
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %path, ptr %path.addr, align 8
  store i32 %mode, ptr %mode.addr, align 4
  store i32 %dir_fd, ptr %dir_fd.addr, align 4
  store i32 0, ptr %mkdirat_unavailable, align 4
  %0 = load ptr, ptr %path.addr, align 8
  %object = getelementptr inbounds %struct.path_t, ptr %0, i32 0, i32 8
  %1 = load ptr, ptr %object, align 8
  %2 = load i32, ptr %mode.addr, align 4
  %3 = load i32, ptr %dir_fd.addr, align 4
  %cmp = icmp eq i32 %3, -100
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %4 = load i32, ptr %dir_fd.addr, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ -1, %cond.true ], [ %4, %cond.false ]
  %call = call i32 (ptr, ptr, ...) @PySys_Audit(ptr noundef @.str.225, ptr noundef @.str.206, ptr noundef %1, i32 noundef %2, i32 noundef %cond)
  %cmp1 = icmp slt i32 %call, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end
  %call2 = call ptr @PyEval_SaveThread()
  store ptr %call2, ptr %_save, align 8
  %5 = load i32, ptr %dir_fd.addr, align 4
  %cmp3 = icmp ne i32 %5, -100
  br i1 %cmp3, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.end
  %6 = load i32, ptr %dir_fd.addr, align 4
  %7 = load ptr, ptr %path.addr, align 8
  %narrow = getelementptr inbounds %struct.path_t, ptr %7, i32 0, i32 5
  %8 = load ptr, ptr %narrow, align 8
  %9 = load i32, ptr %mode.addr, align 4
  %call5 = call i32 @mkdirat(i32 noundef %6, ptr noundef %8, i32 noundef %9) #10
  store i32 %call5, ptr %result, align 4
  br label %if.end8

if.else:                                          ; preds = %if.end
  %10 = load ptr, ptr %path.addr, align 8
  %narrow6 = getelementptr inbounds %struct.path_t, ptr %10, i32 0, i32 5
  %11 = load ptr, ptr %narrow6, align 8
  %12 = load i32, ptr %mode.addr, align 4
  %call7 = call i32 @mkdir(ptr noundef %11, i32 noundef %12) #10
  store i32 %call7, ptr %result, align 4
  br label %if.end8

if.end8:                                          ; preds = %if.else, %if.then4
  %13 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %13)
  %14 = load i32, ptr %mkdirat_unavailable, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end8
  call void @argument_unavailable_error(ptr noundef null, ptr noundef @.str.184)
  store ptr null, ptr %retval, align 8
  br label %return

if.end10:                                         ; preds = %if.end8
  %15 = load i32, ptr %result, align 4
  %cmp11 = icmp slt i32 %15, 0
  br i1 %cmp11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %if.end10
  %16 = load ptr, ptr %path.addr, align 8
  %call13 = call ptr @path_error(ptr noundef %16)
  store ptr %call13, ptr %retval, align 8
  br label %return

if.end14:                                         ; preds = %if.end10
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end14, %if.then12, %if.then9, %if.then
  %17 = load ptr, ptr %retval, align 8
  ret ptr %17
}

; Function Attrs: nounwind
declare i32 @mkdirat(i32 noundef, ptr noundef, i32 noundef) #4

; Function Attrs: nounwind
declare i32 @mkdir(ptr noundef, i32 noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_nice_impl(ptr noundef %module, i32 noundef %increment) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %increment.addr = alloca i32, align 4
  %value = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %increment, ptr %increment.addr, align 4
  %call = call ptr @__errno_location() #12
  store i32 0, ptr %call, align 4
  %0 = load i32, ptr %increment.addr, align 4
  %call1 = call i32 @nice(i32 noundef %0) #10
  store i32 %call1, ptr %value, align 4
  %1 = load i32, ptr %value, align 4
  %cmp = icmp eq i32 %1, -1
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %call2 = call ptr @__errno_location() #12
  %2 = load i32, ptr %call2, align 4
  %cmp3 = icmp ne i32 %2, 0
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %call4 = call ptr @posix_error()
  store ptr %call4, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %3 = load i32, ptr %value, align 4
  %conv = sext i32 %3 to i64
  %call5 = call ptr @PyLong_FromLong(i64 noundef %conv)
  store ptr %call5, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load ptr, ptr %retval, align 8
  ret ptr %4
}

; Function Attrs: nounwind
declare i32 @nice(i32 noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_getpriority_impl(ptr noundef %module, i32 noundef %which, i32 noundef %who) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %which.addr = alloca i32, align 4
  %who.addr = alloca i32, align 4
  %retval1 = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %which, ptr %which.addr, align 4
  store i32 %who, ptr %who.addr, align 4
  %call = call ptr @__errno_location() #12
  store i32 0, ptr %call, align 4
  %0 = load i32, ptr %which.addr, align 4
  %1 = load i32, ptr %who.addr, align 4
  %call2 = call i32 @getpriority(i32 noundef %0, i32 noundef %1) #10
  store i32 %call2, ptr %retval1, align 4
  %call3 = call ptr @__errno_location() #12
  %2 = load i32, ptr %call3, align 4
  %cmp = icmp ne i32 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call4 = call ptr @posix_error()
  store ptr %call4, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load i32, ptr %retval1, align 4
  %conv = sext i32 %3 to i64
  %call5 = call ptr @PyLong_FromLong(i64 noundef %conv)
  store ptr %call5, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load ptr, ptr %retval, align 8
  ret ptr %4
}

; Function Attrs: nounwind
declare i32 @getpriority(i32 noundef, i32 noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_setpriority_impl(ptr noundef %module, i32 noundef %which, i32 noundef %who, i32 noundef %priority) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %which.addr = alloca i32, align 4
  %who.addr = alloca i32, align 4
  %priority.addr = alloca i32, align 4
  %retval1 = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %which, ptr %which.addr, align 4
  store i32 %who, ptr %who.addr, align 4
  store i32 %priority, ptr %priority.addr, align 4
  %0 = load i32, ptr %which.addr, align 4
  %1 = load i32, ptr %who.addr, align 4
  %2 = load i32, ptr %priority.addr, align 4
  %call = call i32 @setpriority(i32 noundef %0, i32 noundef %1, i32 noundef %2) #10
  store i32 %call, ptr %retval1, align 4
  %3 = load i32, ptr %retval1, align 4
  %cmp = icmp eq i32 %3, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call2 = call ptr @posix_error()
  store ptr %call2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load ptr, ptr %retval, align 8
  ret ptr %4
}

; Function Attrs: nounwind
declare i32 @setpriority(i32 noundef, i32 noundef, i32 noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_posix_spawn_impl(ptr noundef %module, ptr noundef %path, ptr noundef %argv, ptr noundef %env, ptr noundef %file_actions, ptr noundef %setpgroup, i32 noundef %resetids, i32 noundef %setsid, ptr noundef %setsigmask, ptr noundef %setsigdef, ptr noundef %scheduler) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %path.addr = alloca ptr, align 8
  %argv.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %file_actions.addr = alloca ptr, align 8
  %setpgroup.addr = alloca ptr, align 8
  %resetids.addr = alloca i32, align 4
  %setsid.addr = alloca i32, align 4
  %setsigmask.addr = alloca ptr, align 8
  %setsigdef.addr = alloca ptr, align 8
  %scheduler.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %path, ptr %path.addr, align 8
  store ptr %argv, ptr %argv.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store ptr %file_actions, ptr %file_actions.addr, align 8
  store ptr %setpgroup, ptr %setpgroup.addr, align 8
  store i32 %resetids, ptr %resetids.addr, align 4
  store i32 %setsid, ptr %setsid.addr, align 4
  store ptr %setsigmask, ptr %setsigmask.addr, align 8
  store ptr %setsigdef, ptr %setsigdef.addr, align 8
  store ptr %scheduler, ptr %scheduler.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %1 = load ptr, ptr %path.addr, align 8
  %2 = load ptr, ptr %argv.addr, align 8
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load ptr, ptr %file_actions.addr, align 8
  %5 = load ptr, ptr %setpgroup.addr, align 8
  %6 = load i32, ptr %resetids.addr, align 4
  %7 = load i32, ptr %setsid.addr, align 4
  %8 = load ptr, ptr %setsigmask.addr, align 8
  %9 = load ptr, ptr %setsigdef.addr, align 8
  %10 = load ptr, ptr %scheduler.addr, align 8
  %call = call ptr @py_posix_spawn(i32 noundef 0, ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, ptr noundef %5, i32 noundef %6, i32 noundef %7, ptr noundef %8, ptr noundef %9, ptr noundef %10)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @py_posix_spawn(i32 noundef %use_posix_spawnp, ptr noundef %module, ptr noundef %path, ptr noundef %argv, ptr noundef %env, ptr noundef %file_actions, ptr noundef %setpgroup, i32 noundef %resetids, i32 noundef %setsid, ptr noundef %setsigmask, ptr noundef %setsigdef, ptr noundef %scheduler) #0 {
entry:
  %retval = alloca ptr, align 8
  %use_posix_spawnp.addr = alloca i32, align 4
  %module.addr = alloca ptr, align 8
  %path.addr = alloca ptr, align 8
  %argv.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %file_actions.addr = alloca ptr, align 8
  %setpgroup.addr = alloca ptr, align 8
  %resetids.addr = alloca i32, align 4
  %setsid.addr = alloca i32, align 4
  %setsigmask.addr = alloca ptr, align 8
  %setsigdef.addr = alloca ptr, align 8
  %scheduler.addr = alloca ptr, align 8
  %func_name = alloca ptr, align 8
  %argvlist = alloca ptr, align 8
  %envlist = alloca ptr, align 8
  %file_actions_buf = alloca %struct.posix_spawn_file_actions_t, align 8
  %file_actionsp = alloca ptr, align 8
  %attr = alloca %struct.posix_spawnattr_t, align 8
  %attrp = alloca ptr, align 8
  %argc = alloca i64, align 8
  %envc = alloca i64, align 8
  %result = alloca ptr, align 8
  %temp_buffer = alloca ptr, align 8
  %pid = alloca i32, align 4
  %err_code = alloca i32, align 4
  store i32 %use_posix_spawnp, ptr %use_posix_spawnp.addr, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %path, ptr %path.addr, align 8
  store ptr %argv, ptr %argv.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store ptr %file_actions, ptr %file_actions.addr, align 8
  store ptr %setpgroup, ptr %setpgroup.addr, align 8
  store i32 %resetids, ptr %resetids.addr, align 4
  store i32 %setsid, ptr %setsid.addr, align 4
  store ptr %setsigmask, ptr %setsigmask.addr, align 8
  store ptr %setsigdef, ptr %setsigdef.addr, align 8
  store ptr %scheduler, ptr %scheduler.addr, align 8
  %0 = load i32, ptr %use_posix_spawnp.addr, align 4
  %tobool = icmp ne i32 %0, 0
  %cond = select i1 %tobool, ptr @.str.33, ptr @.str.32
  store ptr %cond, ptr %func_name, align 8
  store ptr null, ptr %argvlist, align 8
  store ptr null, ptr %envlist, align 8
  store ptr null, ptr %file_actionsp, align 8
  store ptr null, ptr %attrp, align 8
  store ptr null, ptr %result, align 8
  store ptr null, ptr %temp_buffer, align 8
  %1 = load ptr, ptr %argv.addr, align 8
  %call = call ptr @Py_TYPE(ptr noundef %1)
  %call1 = call i32 @PyType_HasFeature(ptr noundef %call, i64 noundef 33554432)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %2 = load ptr, ptr %argv.addr, align 8
  %call3 = call ptr @Py_TYPE(ptr noundef %2)
  %call4 = call i32 @PyType_HasFeature(ptr noundef %call3, i64 noundef 67108864)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %3 = load ptr, ptr @PyExc_TypeError, align 8
  %4 = load ptr, ptr %func_name, align 8
  %call6 = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %3, ptr noundef @.str.235, ptr noundef %4)
  br label %exit

if.end:                                           ; preds = %land.lhs.true, %entry
  %5 = load ptr, ptr %argv.addr, align 8
  %call7 = call i64 @PySequence_Size(ptr noundef %5)
  store i64 %call7, ptr %argc, align 8
  %6 = load i64, ptr %argc, align 8
  %cmp = icmp slt i64 %6, 1
  br i1 %cmp, label %if.then8, label %if.end10

if.then8:                                         ; preds = %if.end
  %7 = load ptr, ptr @PyExc_ValueError, align 8
  %8 = load ptr, ptr %func_name, align 8
  %call9 = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %7, ptr noundef @.str.236, ptr noundef %8)
  store ptr null, ptr %retval, align 8
  br label %return

if.end10:                                         ; preds = %if.end
  %9 = load ptr, ptr %env.addr, align 8
  %call11 = call i32 @PyMapping_Check(ptr noundef %9)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %if.end17, label %land.lhs.true13

land.lhs.true13:                                  ; preds = %if.end10
  %10 = load ptr, ptr %env.addr, align 8
  %cmp14 = icmp ne ptr %10, @_Py_NoneStruct
  br i1 %cmp14, label %if.then15, label %if.end17

if.then15:                                        ; preds = %land.lhs.true13
  %11 = load ptr, ptr @PyExc_TypeError, align 8
  %12 = load ptr, ptr %func_name, align 8
  %call16 = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %11, ptr noundef @.str.237, ptr noundef %12)
  br label %exit

if.end17:                                         ; preds = %land.lhs.true13, %if.end10
  %13 = load ptr, ptr %argv.addr, align 8
  %call18 = call ptr @parse_arglist(ptr noundef %13, ptr noundef %argc)
  store ptr %call18, ptr %argvlist, align 8
  %14 = load ptr, ptr %argvlist, align 8
  %cmp19 = icmp eq ptr %14, null
  br i1 %cmp19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %if.end17
  br label %exit

if.end21:                                         ; preds = %if.end17
  %15 = load ptr, ptr %argvlist, align 8
  %arrayidx = getelementptr ptr, ptr %15, i64 0
  %16 = load ptr, ptr %arrayidx, align 8
  %arrayidx22 = getelementptr i8, ptr %16, i64 0
  %17 = load i8, ptr %arrayidx22, align 1
  %tobool23 = icmp ne i8 %17, 0
  br i1 %tobool23, label %if.end26, label %if.then24

if.then24:                                        ; preds = %if.end21
  %18 = load ptr, ptr @PyExc_ValueError, align 8
  %19 = load ptr, ptr %func_name, align 8
  %call25 = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %18, ptr noundef @.str.238, ptr noundef %19)
  br label %exit

if.end26:                                         ; preds = %if.end21
  %20 = load ptr, ptr %env.addr, align 8
  %cmp27 = icmp eq ptr %20, @_Py_NoneStruct
  br i1 %cmp27, label %if.then28, label %if.else

if.then28:                                        ; preds = %if.end26
  %21 = load ptr, ptr @environ, align 8
  store ptr %21, ptr %envlist, align 8
  br label %if.end33

if.else:                                          ; preds = %if.end26
  %22 = load ptr, ptr %env.addr, align 8
  %call29 = call ptr @parse_envlist(ptr noundef %22, ptr noundef %envc)
  store ptr %call29, ptr %envlist, align 8
  %23 = load ptr, ptr %envlist, align 8
  %cmp30 = icmp eq ptr %23, null
  br i1 %cmp30, label %if.then31, label %if.end32

if.then31:                                        ; preds = %if.else
  br label %exit

if.end32:                                         ; preds = %if.else
  br label %if.end33

if.end33:                                         ; preds = %if.end32, %if.then28
  %24 = load ptr, ptr %file_actions.addr, align 8
  %cmp34 = icmp ne ptr %24, null
  br i1 %cmp34, label %land.lhs.true35, label %if.end46

land.lhs.true35:                                  ; preds = %if.end33
  %25 = load ptr, ptr %file_actions.addr, align 8
  %cmp36 = icmp ne ptr %25, @_Py_NoneStruct
  br i1 %cmp36, label %if.then37, label %if.end46

if.then37:                                        ; preds = %land.lhs.true35
  %call38 = call ptr @PyList_New(i64 noundef 0)
  store ptr %call38, ptr %temp_buffer, align 8
  %26 = load ptr, ptr %temp_buffer, align 8
  %tobool39 = icmp ne ptr %26, null
  br i1 %tobool39, label %if.end41, label %if.then40

if.then40:                                        ; preds = %if.then37
  br label %exit

if.end41:                                         ; preds = %if.then37
  %27 = load ptr, ptr %file_actions.addr, align 8
  %28 = load ptr, ptr %temp_buffer, align 8
  %call42 = call i32 @parse_file_actions(ptr noundef %27, ptr noundef %file_actions_buf, ptr noundef %28)
  %tobool43 = icmp ne i32 %call42, 0
  br i1 %tobool43, label %if.then44, label %if.end45

if.then44:                                        ; preds = %if.end41
  br label %exit

if.end45:                                         ; preds = %if.end41
  store ptr %file_actions_buf, ptr %file_actionsp, align 8
  br label %if.end46

if.end46:                                         ; preds = %if.end45, %land.lhs.true35, %if.end33
  %29 = load ptr, ptr %module.addr, align 8
  %30 = load ptr, ptr %func_name, align 8
  %31 = load ptr, ptr %setpgroup.addr, align 8
  %32 = load i32, ptr %resetids.addr, align 4
  %33 = load i32, ptr %setsid.addr, align 4
  %34 = load ptr, ptr %setsigmask.addr, align 8
  %35 = load ptr, ptr %setsigdef.addr, align 8
  %36 = load ptr, ptr %scheduler.addr, align 8
  %call47 = call i32 @parse_posix_spawn_flags(ptr noundef %29, ptr noundef %30, ptr noundef %31, i32 noundef %32, i32 noundef %33, ptr noundef %34, ptr noundef %35, ptr noundef %36, ptr noundef %attr)
  %tobool48 = icmp ne i32 %call47, 0
  br i1 %tobool48, label %if.then49, label %if.end50

if.then49:                                        ; preds = %if.end46
  br label %exit

if.end50:                                         ; preds = %if.end46
  store ptr %attr, ptr %attrp, align 8
  %37 = load ptr, ptr %path.addr, align 8
  %object = getelementptr inbounds %struct.path_t, ptr %37, i32 0, i32 8
  %38 = load ptr, ptr %object, align 8
  %39 = load ptr, ptr %argv.addr, align 8
  %40 = load ptr, ptr %env.addr, align 8
  %call51 = call i32 (ptr, ptr, ...) @PySys_Audit(ptr noundef @.str.239, ptr noundef @.str.240, ptr noundef %38, ptr noundef %39, ptr noundef %40)
  %cmp52 = icmp slt i32 %call51, 0
  br i1 %cmp52, label %if.then53, label %if.end54

if.then53:                                        ; preds = %if.end50
  br label %exit

if.end54:                                         ; preds = %if.end50
  %41 = load i32, ptr %use_posix_spawnp.addr, align 4
  %tobool55 = icmp ne i32 %41, 0
  br i1 %tobool55, label %if.then56, label %if.else58

if.then56:                                        ; preds = %if.end54
  %42 = load ptr, ptr %path.addr, align 8
  %narrow = getelementptr inbounds %struct.path_t, ptr %42, i32 0, i32 5
  %43 = load ptr, ptr %narrow, align 8
  %44 = load ptr, ptr %file_actionsp, align 8
  %45 = load ptr, ptr %attrp, align 8
  %46 = load ptr, ptr %argvlist, align 8
  %47 = load ptr, ptr %envlist, align 8
  %call57 = call i32 @posix_spawnp(ptr noundef %pid, ptr noundef %43, ptr noundef %44, ptr noundef %45, ptr noundef %46, ptr noundef %47)
  store i32 %call57, ptr %err_code, align 4
  br label %if.end61

if.else58:                                        ; preds = %if.end54
  %48 = load ptr, ptr %path.addr, align 8
  %narrow59 = getelementptr inbounds %struct.path_t, ptr %48, i32 0, i32 5
  %49 = load ptr, ptr %narrow59, align 8
  %50 = load ptr, ptr %file_actionsp, align 8
  %51 = load ptr, ptr %attrp, align 8
  %52 = load ptr, ptr %argvlist, align 8
  %53 = load ptr, ptr %envlist, align 8
  %call60 = call i32 @posix_spawn(ptr noundef %pid, ptr noundef %49, ptr noundef %50, ptr noundef %51, ptr noundef %52, ptr noundef %53)
  store i32 %call60, ptr %err_code, align 4
  br label %if.end61

if.end61:                                         ; preds = %if.else58, %if.then56
  %54 = load i32, ptr %err_code, align 4
  %tobool62 = icmp ne i32 %54, 0
  br i1 %tobool62, label %if.then63, label %if.end67

if.then63:                                        ; preds = %if.end61
  %55 = load i32, ptr %err_code, align 4
  %call64 = call ptr @__errno_location() #12
  store i32 %55, ptr %call64, align 4
  %56 = load ptr, ptr @PyExc_OSError, align 8
  %57 = load ptr, ptr %path.addr, align 8
  %object65 = getelementptr inbounds %struct.path_t, ptr %57, i32 0, i32 8
  %58 = load ptr, ptr %object65, align 8
  %call66 = call ptr @PyErr_SetFromErrnoWithFilenameObject(ptr noundef %56, ptr noundef %58)
  br label %exit

if.end67:                                         ; preds = %if.end61
  %59 = load i32, ptr %pid, align 4
  %conv = sext i32 %59 to i64
  %call68 = call ptr @PyLong_FromLong(i64 noundef %conv)
  store ptr %call68, ptr %result, align 8
  br label %exit

exit:                                             ; preds = %if.end67, %if.then63, %if.then53, %if.then49, %if.then44, %if.then40, %if.then31, %if.then24, %if.then20, %if.then15, %if.then
  %60 = load ptr, ptr %file_actionsp, align 8
  %tobool69 = icmp ne ptr %60, null
  br i1 %tobool69, label %if.then70, label %if.end72

if.then70:                                        ; preds = %exit
  %61 = load ptr, ptr %file_actionsp, align 8
  %call71 = call i32 @posix_spawn_file_actions_destroy(ptr noundef %61) #10
  br label %if.end72

if.end72:                                         ; preds = %if.then70, %exit
  %62 = load ptr, ptr %attrp, align 8
  %tobool73 = icmp ne ptr %62, null
  br i1 %tobool73, label %if.then74, label %if.end76

if.then74:                                        ; preds = %if.end72
  %63 = load ptr, ptr %attrp, align 8
  %call75 = call i32 @posix_spawnattr_destroy(ptr noundef %63) #10
  br label %if.end76

if.end76:                                         ; preds = %if.then74, %if.end72
  %64 = load ptr, ptr %envlist, align 8
  %tobool77 = icmp ne ptr %64, null
  br i1 %tobool77, label %land.lhs.true78, label %if.end82

land.lhs.true78:                                  ; preds = %if.end76
  %65 = load ptr, ptr %envlist, align 8
  %66 = load ptr, ptr @environ, align 8
  %cmp79 = icmp ne ptr %65, %66
  br i1 %cmp79, label %if.then81, label %if.end82

if.then81:                                        ; preds = %land.lhs.true78
  %67 = load ptr, ptr %envlist, align 8
  %68 = load i64, ptr %envc, align 8
  call void @free_string_array(ptr noundef %67, i64 noundef %68)
  br label %if.end82

if.end82:                                         ; preds = %if.then81, %land.lhs.true78, %if.end76
  %69 = load ptr, ptr %argvlist, align 8
  %tobool83 = icmp ne ptr %69, null
  br i1 %tobool83, label %if.then84, label %if.end85

if.then84:                                        ; preds = %if.end82
  %70 = load ptr, ptr %argvlist, align 8
  %71 = load i64, ptr %argc, align 8
  call void @free_string_array(ptr noundef %70, i64 noundef %71)
  br label %if.end85

if.end85:                                         ; preds = %if.then84, %if.end82
  %72 = load ptr, ptr %temp_buffer, align 8
  call void @Py_XDECREF(ptr noundef %72)
  %73 = load ptr, ptr %result, align 8
  store ptr %73, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end85, %if.then8
  %74 = load ptr, ptr %retval, align 8
  ret ptr %74
}

declare i64 @PySequence_Size(ptr noundef) #1

declare i32 @PyMapping_Check(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @parse_arglist(ptr noundef %argv, ptr noundef %argc) #0 {
entry:
  %op.addr.i29 = alloca ptr, align 8
  %op.addr.i27 = alloca ptr, align 8
  %op.addr.i18 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %argv.addr = alloca ptr, align 8
  %argc.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  %argvlist = alloca ptr, align 8
  %item = alloca ptr, align 8
  store ptr %argv, ptr %argv.addr, align 8
  store ptr %argc, ptr %argc.addr, align 8
  %0 = load ptr, ptr %argc.addr, align 8
  %1 = load i64, ptr %0, align 8
  %add = add i64 %1, 1
  %cmp = icmp ugt i64 %add, 1152921504606846975
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %2 = load ptr, ptr %argc.addr, align 8
  %3 = load i64, ptr %2, align 8
  %add1 = add i64 %3, 1
  %mul = mul i64 %add1, 8
  %call = call ptr @PyMem_Malloc(i64 noundef %mul)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ null, %cond.true ], [ %call, %cond.false ]
  store ptr %cond, ptr %argvlist, align 8
  %4 = load ptr, ptr %argvlist, align 8
  %cmp2 = icmp eq ptr %4, null
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  %call3 = call ptr @PyErr_NoMemory()
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %5 = load i32, ptr %i, align 4
  %conv = sext i32 %5 to i64
  %6 = load ptr, ptr %argc.addr, align 8
  %7 = load i64, ptr %6, align 8
  %cmp4 = icmp slt i64 %conv, %7
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load ptr, ptr %argv.addr, align 8
  %call6 = call ptr @Py_TYPE(ptr noundef %8)
  %tp_as_sequence = getelementptr inbounds %struct._typeobject, ptr %call6, i32 0, i32 11
  %9 = load ptr, ptr %tp_as_sequence, align 8
  %sq_item = getelementptr inbounds %struct.PySequenceMethods, ptr %9, i32 0, i32 3
  %10 = load ptr, ptr %sq_item, align 8
  %11 = load ptr, ptr %argv.addr, align 8
  %12 = load i32, ptr %i, align 4
  %conv7 = sext i32 %12 to i64
  %call8 = call ptr %10(ptr noundef %11, i64 noundef %conv7)
  store ptr %call8, ptr %item, align 8
  %13 = load ptr, ptr %item, align 8
  %cmp9 = icmp eq ptr %13, null
  br i1 %cmp9, label %if.then11, label %if.end12

if.then11:                                        ; preds = %for.body
  br label %fail

if.end12:                                         ; preds = %for.body
  %14 = load ptr, ptr %item, align 8
  %15 = load ptr, ptr %argvlist, align 8
  %16 = load i32, ptr %i, align 4
  %idxprom = sext i32 %16 to i64
  %arrayidx = getelementptr ptr, ptr %15, i64 %idxprom
  %call13 = call i32 @fsconvert_strdup(ptr noundef %14, ptr noundef %arrayidx)
  %tobool = icmp ne i32 %call13, 0
  br i1 %tobool, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end12
  %17 = load ptr, ptr %item, align 8
  store ptr %17, ptr %op.addr.i18, align 8
  %18 = load ptr, ptr %op.addr.i18, align 8
  store ptr %18, ptr %op.addr.i27, align 8
  %19 = load ptr, ptr %op.addr.i27, align 8
  %20 = load i64, ptr %19, align 8
  %conv.i = trunc i64 %20 to i32
  %cmp.i28 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i28 to i32
  %tobool.i20 = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i20, label %if.then.i25, label %if.end.i21

if.then.i25:                                      ; preds = %if.then14
  br label %Py_DECREF.exit26

if.end.i21:                                       ; preds = %if.then14
  %21 = load ptr, ptr %op.addr.i18, align 8
  %22 = load i64, ptr %21, align 8
  %dec.i22 = add i64 %22, -1
  store i64 %dec.i22, ptr %21, align 8
  %cmp.i23 = icmp eq i64 %dec.i22, 0
  br i1 %cmp.i23, label %if.then1.i24, label %Py_DECREF.exit26

if.then1.i24:                                     ; preds = %if.end.i21
  %23 = load ptr, ptr %op.addr.i18, align 8
  call void @_Py_Dealloc(ptr noundef %23) #10
  br label %Py_DECREF.exit26

Py_DECREF.exit26:                                 ; preds = %if.then1.i24, %if.end.i21, %if.then.i25
  br label %fail

if.end15:                                         ; preds = %if.end12
  %24 = load ptr, ptr %item, align 8
  store ptr %24, ptr %op.addr.i, align 8
  %25 = load ptr, ptr %op.addr.i, align 8
  store ptr %25, ptr %op.addr.i29, align 8
  %26 = load ptr, ptr %op.addr.i29, align 8
  %27 = load i64, ptr %26, align 8
  %conv.i30 = trunc i64 %27 to i32
  %cmp.i31 = icmp slt i32 %conv.i30, 0
  %conv1.i32 = zext i1 %cmp.i31 to i32
  %tobool.i = icmp ne i32 %conv1.i32, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.end15
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.end15
  %28 = load ptr, ptr %op.addr.i, align 8
  %29 = load i64, ptr %28, align 8
  %dec.i = add i64 %29, -1
  store i64 %dec.i, ptr %28, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %30 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %30) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  br label %for.inc

for.inc:                                          ; preds = %Py_DECREF.exit
  %31 = load i32, ptr %i, align 4
  %inc = add i32 %31, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !12

for.end:                                          ; preds = %for.cond
  %32 = load ptr, ptr %argvlist, align 8
  %33 = load ptr, ptr %argc.addr, align 8
  %34 = load i64, ptr %33, align 8
  %arrayidx16 = getelementptr ptr, ptr %32, i64 %34
  store ptr null, ptr %arrayidx16, align 8
  %35 = load ptr, ptr %argvlist, align 8
  store ptr %35, ptr %retval, align 8
  br label %return

fail:                                             ; preds = %Py_DECREF.exit26, %if.then11
  %36 = load i32, ptr %i, align 4
  %conv17 = sext i32 %36 to i64
  %37 = load ptr, ptr %argc.addr, align 8
  store i64 %conv17, ptr %37, align 8
  %38 = load ptr, ptr %argvlist, align 8
  %39 = load ptr, ptr %argc.addr, align 8
  %40 = load i64, ptr %39, align 8
  call void @free_string_array(ptr noundef %38, i64 noundef %40)
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %fail, %for.end, %if.then
  %41 = load ptr, ptr %retval, align 8
  ret ptr %41
}

; Function Attrs: nounwind uwtable
define internal ptr @parse_envlist(ptr noundef %env, ptr noundef %envc_ptr) #0 {
entry:
  %op.addr.i163 = alloca ptr, align 8
  %op.addr.i159 = alloca ptr, align 8
  %op.addr.i155 = alloca ptr, align 8
  %op.addr.i151 = alloca ptr, align 8
  %op.addr.i147 = alloca ptr, align 8
  %op.addr.i143 = alloca ptr, align 8
  %op.addr.i139 = alloca ptr, align 8
  %op.addr.i135 = alloca ptr, align 8
  %op.addr.i133 = alloca ptr, align 8
  %op.addr.i124 = alloca ptr, align 8
  %op.addr.i115 = alloca ptr, align 8
  %op.addr.i106 = alloca ptr, align 8
  %op.addr.i97 = alloca ptr, align 8
  %op.addr.i88 = alloca ptr, align 8
  %op.addr.i79 = alloca ptr, align 8
  %op.addr.i70 = alloca ptr, align 8
  %op.addr.i61 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %envc_ptr.addr = alloca ptr, align 8
  %i = alloca i64, align 8
  %pos = alloca i64, align 8
  %envc = alloca i64, align 8
  %keys = alloca ptr, align 8
  %vals = alloca ptr, align 8
  %key2 = alloca ptr, align 8
  %val2 = alloca ptr, align 8
  %keyval = alloca ptr, align 8
  %envlist = alloca ptr, align 8
  %key = alloca ptr, align 8
  %val = alloca ptr, align 8
  store ptr %env, ptr %env.addr, align 8
  store ptr %envc_ptr, ptr %envc_ptr.addr, align 8
  store ptr null, ptr %keys, align 8
  store ptr null, ptr %vals, align 8
  %0 = load ptr, ptr %env.addr, align 8
  %call = call i64 @PyMapping_Size(ptr noundef %0)
  store i64 %call, ptr %i, align 8
  %1 = load i64, ptr %i, align 8
  %cmp = icmp slt i64 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i64, ptr %i, align 8
  %add = add i64 %2, 1
  %cmp1 = icmp ugt i64 %add, 1152921504606846975
  br i1 %cmp1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %3 = load i64, ptr %i, align 8
  %add2 = add i64 %3, 1
  %mul = mul i64 %add2, 8
  %call3 = call ptr @PyMem_Malloc(i64 noundef %mul)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ null, %cond.true ], [ %call3, %cond.false ]
  store ptr %cond, ptr %envlist, align 8
  %4 = load ptr, ptr %envlist, align 8
  %cmp4 = icmp eq ptr %4, null
  br i1 %cmp4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %cond.end
  %call6 = call ptr @PyErr_NoMemory()
  store ptr null, ptr %retval, align 8
  br label %return

if.end7:                                          ; preds = %cond.end
  store i64 0, ptr %envc, align 8
  %5 = load ptr, ptr %env.addr, align 8
  %call8 = call ptr @PyMapping_Keys(ptr noundef %5)
  store ptr %call8, ptr %keys, align 8
  %6 = load ptr, ptr %keys, align 8
  %tobool = icmp ne ptr %6, null
  br i1 %tobool, label %if.end10, label %if.then9

if.then9:                                         ; preds = %if.end7
  br label %error

if.end10:                                         ; preds = %if.end7
  %7 = load ptr, ptr %env.addr, align 8
  %call11 = call ptr @PyMapping_Values(ptr noundef %7)
  store ptr %call11, ptr %vals, align 8
  %8 = load ptr, ptr %vals, align 8
  %tobool12 = icmp ne ptr %8, null
  br i1 %tobool12, label %if.end14, label %if.then13

if.then13:                                        ; preds = %if.end10
  br label %error

if.end14:                                         ; preds = %if.end10
  %9 = load ptr, ptr %keys, align 8
  %call15 = call ptr @Py_TYPE(ptr noundef %9)
  %call16 = call i32 @PyType_HasFeature(ptr noundef %call15, i64 noundef 33554432)
  %tobool17 = icmp ne i32 %call16, 0
  br i1 %tobool17, label %lor.lhs.false, label %if.then21

lor.lhs.false:                                    ; preds = %if.end14
  %10 = load ptr, ptr %vals, align 8
  %call18 = call ptr @Py_TYPE(ptr noundef %10)
  %call19 = call i32 @PyType_HasFeature(ptr noundef %call18, i64 noundef 33554432)
  %tobool20 = icmp ne i32 %call19, 0
  br i1 %tobool20, label %if.end23, label %if.then21

if.then21:                                        ; preds = %lor.lhs.false, %if.end14
  %11 = load ptr, ptr @PyExc_TypeError, align 8
  %call22 = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %11, ptr noundef @.str.241)
  br label %error

if.end23:                                         ; preds = %lor.lhs.false
  store i64 0, ptr %pos, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end23
  %12 = load i64, ptr %pos, align 8
  %13 = load i64, ptr %i, align 8
  %cmp24 = icmp slt i64 %12, %13
  br i1 %cmp24, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %14 = load ptr, ptr %keys, align 8
  %15 = load i64, ptr %pos, align 8
  %call25 = call ptr @PyList_GetItem(ptr noundef %14, i64 noundef %15)
  store ptr %call25, ptr %key, align 8
  %16 = load ptr, ptr %key, align 8
  %cmp26 = icmp eq ptr %16, null
  br i1 %cmp26, label %if.then27, label %if.end28

if.then27:                                        ; preds = %for.body
  br label %error

if.end28:                                         ; preds = %for.body
  %17 = load ptr, ptr %vals, align 8
  %18 = load i64, ptr %pos, align 8
  %call29 = call ptr @PyList_GetItem(ptr noundef %17, i64 noundef %18)
  store ptr %call29, ptr %val, align 8
  %19 = load ptr, ptr %val, align 8
  %cmp30 = icmp eq ptr %19, null
  br i1 %cmp30, label %if.then31, label %if.end32

if.then31:                                        ; preds = %if.end28
  br label %error

if.end32:                                         ; preds = %if.end28
  %20 = load ptr, ptr %key, align 8
  %call33 = call i32 @PyUnicode_FSConverter(ptr noundef %20, ptr noundef %key2)
  %tobool34 = icmp ne i32 %call33, 0
  br i1 %tobool34, label %if.end36, label %if.then35

if.then35:                                        ; preds = %if.end32
  br label %error

if.end36:                                         ; preds = %if.end32
  %21 = load ptr, ptr %val, align 8
  %call37 = call i32 @PyUnicode_FSConverter(ptr noundef %21, ptr noundef %val2)
  %tobool38 = icmp ne i32 %call37, 0
  br i1 %tobool38, label %if.end40, label %if.then39

if.then39:                                        ; preds = %if.end36
  %22 = load ptr, ptr %key2, align 8
  store ptr %22, ptr %op.addr.i124, align 8
  %23 = load ptr, ptr %op.addr.i124, align 8
  store ptr %23, ptr %op.addr.i133, align 8
  %24 = load ptr, ptr %op.addr.i133, align 8
  %25 = load i64, ptr %24, align 8
  %conv.i = trunc i64 %25 to i32
  %cmp.i134 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i134 to i32
  %tobool.i126 = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i126, label %if.then.i131, label %if.end.i127

if.then.i131:                                     ; preds = %if.then39
  br label %Py_DECREF.exit132

if.end.i127:                                      ; preds = %if.then39
  %26 = load ptr, ptr %op.addr.i124, align 8
  %27 = load i64, ptr %26, align 8
  %dec.i128 = add i64 %27, -1
  store i64 %dec.i128, ptr %26, align 8
  %cmp.i129 = icmp eq i64 %dec.i128, 0
  br i1 %cmp.i129, label %if.then1.i130, label %Py_DECREF.exit132

if.then1.i130:                                    ; preds = %if.end.i127
  %28 = load ptr, ptr %op.addr.i124, align 8
  call void @_Py_Dealloc(ptr noundef %28) #10
  br label %Py_DECREF.exit132

Py_DECREF.exit132:                                ; preds = %if.then1.i130, %if.end.i127, %if.then.i131
  br label %error

if.end40:                                         ; preds = %if.end36
  %29 = load ptr, ptr %key2, align 8
  %call41 = call i64 @PyBytes_GET_SIZE(ptr noundef %29)
  %cmp42 = icmp eq i64 %call41, 0
  br i1 %cmp42, label %if.then47, label %lor.lhs.false43

lor.lhs.false43:                                  ; preds = %if.end40
  %30 = load ptr, ptr %key2, align 8
  %call44 = call ptr @PyBytes_AS_STRING(ptr noundef %30)
  %add.ptr = getelementptr i8, ptr %call44, i64 1
  %call45 = call ptr @strchr(ptr noundef %add.ptr, i32 noundef 61) #13
  %cmp46 = icmp ne ptr %call45, null
  br i1 %cmp46, label %if.then47, label %if.end48

if.then47:                                        ; preds = %lor.lhs.false43, %if.end40
  %31 = load ptr, ptr @PyExc_ValueError, align 8
  call void @PyErr_SetString(ptr noundef %31, ptr noundef @.str.242)
  %32 = load ptr, ptr %key2, align 8
  store ptr %32, ptr %op.addr.i115, align 8
  %33 = load ptr, ptr %op.addr.i115, align 8
  store ptr %33, ptr %op.addr.i135, align 8
  %34 = load ptr, ptr %op.addr.i135, align 8
  %35 = load i64, ptr %34, align 8
  %conv.i136 = trunc i64 %35 to i32
  %cmp.i137 = icmp slt i32 %conv.i136, 0
  %conv1.i138 = zext i1 %cmp.i137 to i32
  %tobool.i117 = icmp ne i32 %conv1.i138, 0
  br i1 %tobool.i117, label %if.then.i122, label %if.end.i118

if.then.i122:                                     ; preds = %if.then47
  br label %Py_DECREF.exit123

if.end.i118:                                      ; preds = %if.then47
  %36 = load ptr, ptr %op.addr.i115, align 8
  %37 = load i64, ptr %36, align 8
  %dec.i119 = add i64 %37, -1
  store i64 %dec.i119, ptr %36, align 8
  %cmp.i120 = icmp eq i64 %dec.i119, 0
  br i1 %cmp.i120, label %if.then1.i121, label %Py_DECREF.exit123

if.then1.i121:                                    ; preds = %if.end.i118
  %38 = load ptr, ptr %op.addr.i115, align 8
  call void @_Py_Dealloc(ptr noundef %38) #10
  br label %Py_DECREF.exit123

Py_DECREF.exit123:                                ; preds = %if.then1.i121, %if.end.i118, %if.then.i122
  %39 = load ptr, ptr %val2, align 8
  store ptr %39, ptr %op.addr.i106, align 8
  %40 = load ptr, ptr %op.addr.i106, align 8
  store ptr %40, ptr %op.addr.i139, align 8
  %41 = load ptr, ptr %op.addr.i139, align 8
  %42 = load i64, ptr %41, align 8
  %conv.i140 = trunc i64 %42 to i32
  %cmp.i141 = icmp slt i32 %conv.i140, 0
  %conv1.i142 = zext i1 %cmp.i141 to i32
  %tobool.i108 = icmp ne i32 %conv1.i142, 0
  br i1 %tobool.i108, label %if.then.i113, label %if.end.i109

if.then.i113:                                     ; preds = %Py_DECREF.exit123
  br label %Py_DECREF.exit114

if.end.i109:                                      ; preds = %Py_DECREF.exit123
  %43 = load ptr, ptr %op.addr.i106, align 8
  %44 = load i64, ptr %43, align 8
  %dec.i110 = add i64 %44, -1
  store i64 %dec.i110, ptr %43, align 8
  %cmp.i111 = icmp eq i64 %dec.i110, 0
  br i1 %cmp.i111, label %if.then1.i112, label %Py_DECREF.exit114

if.then1.i112:                                    ; preds = %if.end.i109
  %45 = load ptr, ptr %op.addr.i106, align 8
  call void @_Py_Dealloc(ptr noundef %45) #10
  br label %Py_DECREF.exit114

Py_DECREF.exit114:                                ; preds = %if.then1.i112, %if.end.i109, %if.then.i113
  br label %error

if.end48:                                         ; preds = %lor.lhs.false43
  %46 = load ptr, ptr %key2, align 8
  %call49 = call ptr @PyBytes_AS_STRING(ptr noundef %46)
  %47 = load ptr, ptr %val2, align 8
  %call50 = call ptr @PyBytes_AS_STRING(ptr noundef %47)
  %call51 = call ptr (ptr, ...) @PyBytes_FromFormat(ptr noundef @.str.243, ptr noundef %call49, ptr noundef %call50)
  store ptr %call51, ptr %keyval, align 8
  %48 = load ptr, ptr %key2, align 8
  store ptr %48, ptr %op.addr.i97, align 8
  %49 = load ptr, ptr %op.addr.i97, align 8
  store ptr %49, ptr %op.addr.i143, align 8
  %50 = load ptr, ptr %op.addr.i143, align 8
  %51 = load i64, ptr %50, align 8
  %conv.i144 = trunc i64 %51 to i32
  %cmp.i145 = icmp slt i32 %conv.i144, 0
  %conv1.i146 = zext i1 %cmp.i145 to i32
  %tobool.i99 = icmp ne i32 %conv1.i146, 0
  br i1 %tobool.i99, label %if.then.i104, label %if.end.i100

if.then.i104:                                     ; preds = %if.end48
  br label %Py_DECREF.exit105

if.end.i100:                                      ; preds = %if.end48
  %52 = load ptr, ptr %op.addr.i97, align 8
  %53 = load i64, ptr %52, align 8
  %dec.i101 = add i64 %53, -1
  store i64 %dec.i101, ptr %52, align 8
  %cmp.i102 = icmp eq i64 %dec.i101, 0
  br i1 %cmp.i102, label %if.then1.i103, label %Py_DECREF.exit105

if.then1.i103:                                    ; preds = %if.end.i100
  %54 = load ptr, ptr %op.addr.i97, align 8
  call void @_Py_Dealloc(ptr noundef %54) #10
  br label %Py_DECREF.exit105

Py_DECREF.exit105:                                ; preds = %if.then1.i103, %if.end.i100, %if.then.i104
  %55 = load ptr, ptr %val2, align 8
  store ptr %55, ptr %op.addr.i88, align 8
  %56 = load ptr, ptr %op.addr.i88, align 8
  store ptr %56, ptr %op.addr.i147, align 8
  %57 = load ptr, ptr %op.addr.i147, align 8
  %58 = load i64, ptr %57, align 8
  %conv.i148 = trunc i64 %58 to i32
  %cmp.i149 = icmp slt i32 %conv.i148, 0
  %conv1.i150 = zext i1 %cmp.i149 to i32
  %tobool.i90 = icmp ne i32 %conv1.i150, 0
  br i1 %tobool.i90, label %if.then.i95, label %if.end.i91

if.then.i95:                                      ; preds = %Py_DECREF.exit105
  br label %Py_DECREF.exit96

if.end.i91:                                       ; preds = %Py_DECREF.exit105
  %59 = load ptr, ptr %op.addr.i88, align 8
  %60 = load i64, ptr %59, align 8
  %dec.i92 = add i64 %60, -1
  store i64 %dec.i92, ptr %59, align 8
  %cmp.i93 = icmp eq i64 %dec.i92, 0
  br i1 %cmp.i93, label %if.then1.i94, label %Py_DECREF.exit96

if.then1.i94:                                     ; preds = %if.end.i91
  %61 = load ptr, ptr %op.addr.i88, align 8
  call void @_Py_Dealloc(ptr noundef %61) #10
  br label %Py_DECREF.exit96

Py_DECREF.exit96:                                 ; preds = %if.then1.i94, %if.end.i91, %if.then.i95
  %62 = load ptr, ptr %keyval, align 8
  %tobool52 = icmp ne ptr %62, null
  br i1 %tobool52, label %if.end54, label %if.then53

if.then53:                                        ; preds = %Py_DECREF.exit96
  br label %error

if.end54:                                         ; preds = %Py_DECREF.exit96
  %63 = load ptr, ptr %keyval, align 8
  %64 = load ptr, ptr %envlist, align 8
  %65 = load i64, ptr %envc, align 8
  %inc = add i64 %65, 1
  store i64 %inc, ptr %envc, align 8
  %arrayidx = getelementptr ptr, ptr %64, i64 %65
  %call55 = call i32 @fsconvert_strdup(ptr noundef %63, ptr noundef %arrayidx)
  %tobool56 = icmp ne i32 %call55, 0
  br i1 %tobool56, label %if.end58, label %if.then57

if.then57:                                        ; preds = %if.end54
  %66 = load ptr, ptr %keyval, align 8
  store ptr %66, ptr %op.addr.i79, align 8
  %67 = load ptr, ptr %op.addr.i79, align 8
  store ptr %67, ptr %op.addr.i151, align 8
  %68 = load ptr, ptr %op.addr.i151, align 8
  %69 = load i64, ptr %68, align 8
  %conv.i152 = trunc i64 %69 to i32
  %cmp.i153 = icmp slt i32 %conv.i152, 0
  %conv1.i154 = zext i1 %cmp.i153 to i32
  %tobool.i81 = icmp ne i32 %conv1.i154, 0
  br i1 %tobool.i81, label %if.then.i86, label %if.end.i82

if.then.i86:                                      ; preds = %if.then57
  br label %Py_DECREF.exit87

if.end.i82:                                       ; preds = %if.then57
  %70 = load ptr, ptr %op.addr.i79, align 8
  %71 = load i64, ptr %70, align 8
  %dec.i83 = add i64 %71, -1
  store i64 %dec.i83, ptr %70, align 8
  %cmp.i84 = icmp eq i64 %dec.i83, 0
  br i1 %cmp.i84, label %if.then1.i85, label %Py_DECREF.exit87

if.then1.i85:                                     ; preds = %if.end.i82
  %72 = load ptr, ptr %op.addr.i79, align 8
  call void @_Py_Dealloc(ptr noundef %72) #10
  br label %Py_DECREF.exit87

Py_DECREF.exit87:                                 ; preds = %if.then1.i85, %if.end.i82, %if.then.i86
  br label %error

if.end58:                                         ; preds = %if.end54
  %73 = load ptr, ptr %keyval, align 8
  store ptr %73, ptr %op.addr.i70, align 8
  %74 = load ptr, ptr %op.addr.i70, align 8
  store ptr %74, ptr %op.addr.i155, align 8
  %75 = load ptr, ptr %op.addr.i155, align 8
  %76 = load i64, ptr %75, align 8
  %conv.i156 = trunc i64 %76 to i32
  %cmp.i157 = icmp slt i32 %conv.i156, 0
  %conv1.i158 = zext i1 %cmp.i157 to i32
  %tobool.i72 = icmp ne i32 %conv1.i158, 0
  br i1 %tobool.i72, label %if.then.i77, label %if.end.i73

if.then.i77:                                      ; preds = %if.end58
  br label %Py_DECREF.exit78

if.end.i73:                                       ; preds = %if.end58
  %77 = load ptr, ptr %op.addr.i70, align 8
  %78 = load i64, ptr %77, align 8
  %dec.i74 = add i64 %78, -1
  store i64 %dec.i74, ptr %77, align 8
  %cmp.i75 = icmp eq i64 %dec.i74, 0
  br i1 %cmp.i75, label %if.then1.i76, label %Py_DECREF.exit78

if.then1.i76:                                     ; preds = %if.end.i73
  %79 = load ptr, ptr %op.addr.i70, align 8
  call void @_Py_Dealloc(ptr noundef %79) #10
  br label %Py_DECREF.exit78

Py_DECREF.exit78:                                 ; preds = %if.then1.i76, %if.end.i73, %if.then.i77
  br label %for.inc

for.inc:                                          ; preds = %Py_DECREF.exit78
  %80 = load i64, ptr %pos, align 8
  %inc59 = add i64 %80, 1
  store i64 %inc59, ptr %pos, align 8
  br label %for.cond, !llvm.loop !13

for.end:                                          ; preds = %for.cond
  %81 = load ptr, ptr %vals, align 8
  store ptr %81, ptr %op.addr.i61, align 8
  %82 = load ptr, ptr %op.addr.i61, align 8
  store ptr %82, ptr %op.addr.i159, align 8
  %83 = load ptr, ptr %op.addr.i159, align 8
  %84 = load i64, ptr %83, align 8
  %conv.i160 = trunc i64 %84 to i32
  %cmp.i161 = icmp slt i32 %conv.i160, 0
  %conv1.i162 = zext i1 %cmp.i161 to i32
  %tobool.i63 = icmp ne i32 %conv1.i162, 0
  br i1 %tobool.i63, label %if.then.i68, label %if.end.i64

if.then.i68:                                      ; preds = %for.end
  br label %Py_DECREF.exit69

if.end.i64:                                       ; preds = %for.end
  %85 = load ptr, ptr %op.addr.i61, align 8
  %86 = load i64, ptr %85, align 8
  %dec.i65 = add i64 %86, -1
  store i64 %dec.i65, ptr %85, align 8
  %cmp.i66 = icmp eq i64 %dec.i65, 0
  br i1 %cmp.i66, label %if.then1.i67, label %Py_DECREF.exit69

if.then1.i67:                                     ; preds = %if.end.i64
  %87 = load ptr, ptr %op.addr.i61, align 8
  call void @_Py_Dealloc(ptr noundef %87) #10
  br label %Py_DECREF.exit69

Py_DECREF.exit69:                                 ; preds = %if.then1.i67, %if.end.i64, %if.then.i68
  %88 = load ptr, ptr %keys, align 8
  store ptr %88, ptr %op.addr.i, align 8
  %89 = load ptr, ptr %op.addr.i, align 8
  store ptr %89, ptr %op.addr.i163, align 8
  %90 = load ptr, ptr %op.addr.i163, align 8
  %91 = load i64, ptr %90, align 8
  %conv.i164 = trunc i64 %91 to i32
  %cmp.i165 = icmp slt i32 %conv.i164, 0
  %conv1.i166 = zext i1 %cmp.i165 to i32
  %tobool.i = icmp ne i32 %conv1.i166, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %Py_DECREF.exit69
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %Py_DECREF.exit69
  %92 = load ptr, ptr %op.addr.i, align 8
  %93 = load i64, ptr %92, align 8
  %dec.i = add i64 %93, -1
  store i64 %dec.i, ptr %92, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %94 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %94) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  %95 = load ptr, ptr %envlist, align 8
  %96 = load i64, ptr %envc, align 8
  %arrayidx60 = getelementptr ptr, ptr %95, i64 %96
  store ptr null, ptr %arrayidx60, align 8
  %97 = load i64, ptr %envc, align 8
  %98 = load ptr, ptr %envc_ptr.addr, align 8
  store i64 %97, ptr %98, align 8
  %99 = load ptr, ptr %envlist, align 8
  store ptr %99, ptr %retval, align 8
  br label %return

error:                                            ; preds = %Py_DECREF.exit87, %if.then53, %Py_DECREF.exit114, %Py_DECREF.exit132, %if.then35, %if.then31, %if.then27, %if.then21, %if.then13, %if.then9
  %100 = load ptr, ptr %keys, align 8
  call void @Py_XDECREF(ptr noundef %100)
  %101 = load ptr, ptr %vals, align 8
  call void @Py_XDECREF(ptr noundef %101)
  %102 = load ptr, ptr %envlist, align 8
  %103 = load i64, ptr %envc, align 8
  call void @free_string_array(ptr noundef %102, i64 noundef %103)
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %error, %Py_DECREF.exit, %if.then5, %if.then
  %104 = load ptr, ptr %retval, align 8
  ret ptr %104
}

; Function Attrs: nounwind uwtable
define internal i32 @parse_file_actions(ptr noundef %file_actions, ptr noundef %file_actionsp, ptr noundef %temp_buffer) #0 {
entry:
  %op.addr.i172 = alloca ptr, align 8
  %cur_refcnt.i = alloca i32, align 4
  %new_refcnt.i = alloca i32, align 4
  %op.addr.i168 = alloca ptr, align 8
  %op.addr.i164 = alloca ptr, align 8
  %op.addr.i160 = alloca ptr, align 8
  %op.addr.i156 = alloca ptr, align 8
  %op.addr.i152 = alloca ptr, align 8
  %op.addr.i148 = alloca ptr, align 8
  %op.addr.i144 = alloca ptr, align 8
  %op.addr.i142 = alloca ptr, align 8
  %op.addr.i133 = alloca ptr, align 8
  %op.addr.i124 = alloca ptr, align 8
  %op.addr.i115 = alloca ptr, align 8
  %op.addr.i106 = alloca ptr, align 8
  %op.addr.i97 = alloca ptr, align 8
  %op.addr.i88 = alloca ptr, align 8
  %op.addr.i79 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca i32, align 4
  %file_actions.addr = alloca ptr, align 8
  %file_actionsp.addr = alloca ptr, align 8
  %temp_buffer.addr = alloca ptr, align 8
  %seq = alloca ptr, align 8
  %file_action = alloca ptr, align 8
  %tag_obj = alloca ptr, align 8
  %i = alloca i64, align 8
  %tag = alloca i64, align 8
  %fd = alloca i32, align 4
  %oflag = alloca i32, align 4
  %path = alloca ptr, align 8
  %mode = alloca i64, align 8
  %fd54 = alloca i32, align 4
  %fd1 = alloca i32, align 4
  %fd2 = alloca i32, align 4
  store ptr %file_actions, ptr %file_actions.addr, align 8
  store ptr %file_actionsp, ptr %file_actionsp.addr, align 8
  store ptr %temp_buffer, ptr %temp_buffer.addr, align 8
  store ptr null, ptr %file_action, align 8
  %0 = load ptr, ptr %file_actions.addr, align 8
  %call = call ptr @PySequence_Fast(ptr noundef %0, ptr noundef @.str.244)
  store ptr %call, ptr %seq, align 8
  %1 = load ptr, ptr %seq, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %file_actionsp.addr, align 8
  %call1 = call i32 @posix_spawn_file_actions_init(ptr noundef %2) #10
  %call2 = call ptr @__errno_location() #12
  store i32 %call1, ptr %call2, align 4
  %call3 = call ptr @__errno_location() #12
  %3 = load i32, ptr %call3, align 4
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call ptr @posix_error()
  %4 = load ptr, ptr %seq, align 8
  store ptr %4, ptr %op.addr.i133, align 8
  %5 = load ptr, ptr %op.addr.i133, align 8
  store ptr %5, ptr %op.addr.i142, align 8
  %6 = load ptr, ptr %op.addr.i142, align 8
  %7 = load i64, ptr %6, align 8
  %conv.i = trunc i64 %7 to i32
  %cmp.i143 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i143 to i32
  %tobool.i135 = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i135, label %if.then.i140, label %if.end.i136

if.then.i140:                                     ; preds = %if.then4
  br label %Py_DECREF.exit141

if.end.i136:                                      ; preds = %if.then4
  %8 = load ptr, ptr %op.addr.i133, align 8
  %9 = load i64, ptr %8, align 8
  %dec.i137 = add i64 %9, -1
  store i64 %dec.i137, ptr %8, align 8
  %cmp.i138 = icmp eq i64 %dec.i137, 0
  br i1 %cmp.i138, label %if.then1.i139, label %Py_DECREF.exit141

if.then1.i139:                                    ; preds = %if.end.i136
  %10 = load ptr, ptr %op.addr.i133, align 8
  call void @_Py_Dealloc(ptr noundef %10) #10
  br label %Py_DECREF.exit141

Py_DECREF.exit141:                                ; preds = %if.then1.i139, %if.end.i136, %if.then.i140
  store i32 -1, ptr %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.end
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %11 = load i64, ptr %i, align 8
  %12 = load ptr, ptr %seq, align 8
  %call7 = call ptr @Py_TYPE(ptr noundef %12)
  %call8 = call i32 @PyType_HasFeature(ptr noundef %call7, i64 noundef 33554432)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.cond
  %13 = load ptr, ptr %seq, align 8
  %call10 = call i64 @PyList_GET_SIZE(ptr noundef %13)
  br label %cond.end

cond.false:                                       ; preds = %for.cond
  %14 = load ptr, ptr %seq, align 8
  %call11 = call i64 @PyTuple_GET_SIZE(ptr noundef %14)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call10, %cond.true ], [ %call11, %cond.false ]
  %cmp12 = icmp slt i64 %11, %cond
  br i1 %cmp12, label %for.body, label %for.end

for.body:                                         ; preds = %cond.end
  %15 = load ptr, ptr %seq, align 8
  %call13 = call ptr @Py_TYPE(ptr noundef %15)
  %call14 = call i32 @PyType_HasFeature(ptr noundef %call13, i64 noundef 33554432)
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %cond.true16, label %cond.false17

cond.true16:                                      ; preds = %for.body
  %16 = load ptr, ptr %seq, align 8
  %ob_item = getelementptr inbounds %struct.PyListObject, ptr %16, i32 0, i32 1
  %17 = load ptr, ptr %ob_item, align 8
  %18 = load i64, ptr %i, align 8
  %arrayidx = getelementptr ptr, ptr %17, i64 %18
  %19 = load ptr, ptr %arrayidx, align 8
  br label %cond.end20

cond.false17:                                     ; preds = %for.body
  %20 = load ptr, ptr %seq, align 8
  %ob_item18 = getelementptr inbounds %struct.PyTupleObject, ptr %20, i32 0, i32 1
  %21 = load i64, ptr %i, align 8
  %arrayidx19 = getelementptr [1 x ptr], ptr %ob_item18, i64 0, i64 %21
  %22 = load ptr, ptr %arrayidx19, align 8
  br label %cond.end20

cond.end20:                                       ; preds = %cond.false17, %cond.true16
  %cond21 = phi ptr [ %19, %cond.true16 ], [ %22, %cond.false17 ]
  store ptr %cond21, ptr %file_action, align 8
  %23 = load ptr, ptr %file_action, align 8
  store ptr %23, ptr %op.addr.i172, align 8
  %24 = load ptr, ptr %op.addr.i172, align 8
  %25 = load i32, ptr %24, align 8
  store i32 %25, ptr %cur_refcnt.i, align 4
  %26 = load i32, ptr %cur_refcnt.i, align 4
  %add.i = add i32 %26, 1
  store i32 %add.i, ptr %new_refcnt.i, align 4
  %27 = load i32, ptr %new_refcnt.i, align 4
  %cmp.i173 = icmp eq i32 %27, 0
  br i1 %cmp.i173, label %if.then.i175, label %if.end.i174

if.then.i175:                                     ; preds = %cond.end20
  br label %Py_INCREF.exit

if.end.i174:                                      ; preds = %cond.end20
  %28 = load i32, ptr %new_refcnt.i, align 4
  %29 = load ptr, ptr %op.addr.i172, align 8
  store i32 %28, ptr %29, align 8
  br label %Py_INCREF.exit

Py_INCREF.exit:                                   ; preds = %if.end.i174, %if.then.i175
  %30 = load ptr, ptr %file_action, align 8
  %call22 = call ptr @Py_TYPE(ptr noundef %30)
  %call23 = call i32 @PyType_HasFeature(ptr noundef %call22, i64 noundef 67108864)
  %tobool24 = icmp ne i32 %call23, 0
  br i1 %tobool24, label %lor.lhs.false, label %if.then27

lor.lhs.false:                                    ; preds = %Py_INCREF.exit
  %31 = load ptr, ptr %file_action, align 8
  %call25 = call i64 @PyTuple_GET_SIZE(ptr noundef %31)
  %tobool26 = icmp ne i64 %call25, 0
  br i1 %tobool26, label %if.end28, label %if.then27

if.then27:                                        ; preds = %lor.lhs.false, %Py_INCREF.exit
  %32 = load ptr, ptr @PyExc_TypeError, align 8
  call void @PyErr_SetString(ptr noundef %32, ptr noundef @.str.245)
  br label %fail

if.end28:                                         ; preds = %lor.lhs.false
  %33 = load ptr, ptr %file_action, align 8
  %ob_item29 = getelementptr inbounds %struct.PyTupleObject, ptr %33, i32 0, i32 1
  %arrayidx30 = getelementptr [1 x ptr], ptr %ob_item29, i64 0, i64 0
  %34 = load ptr, ptr %arrayidx30, align 8
  %call31 = call i64 @PyLong_AsLong(ptr noundef %34)
  store i64 %call31, ptr %tag, align 8
  %35 = load i64, ptr %tag, align 8
  %cmp32 = icmp eq i64 %35, -1
  br i1 %cmp32, label %land.lhs.true, label %if.end36

land.lhs.true:                                    ; preds = %if.end28
  %call33 = call ptr @PyErr_Occurred()
  %tobool34 = icmp ne ptr %call33, null
  br i1 %tobool34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %land.lhs.true
  br label %fail

if.end36:                                         ; preds = %land.lhs.true, %if.end28
  %36 = load i64, ptr %tag, align 8
  switch i64 %36, label %sw.default [
    i64 0, label %sw.bb
    i64 1, label %sw.bb53
    i64 2, label %sw.bb66
  ]

sw.bb:                                            ; preds = %if.end36
  %37 = load ptr, ptr %file_action, align 8
  %call37 = call i32 (ptr, ptr, ...) @PyArg_ParseTuple(ptr noundef %37, ptr noundef @.str.246, ptr noundef %tag_obj, ptr noundef %fd, ptr noundef @PyUnicode_FSConverter, ptr noundef %path, ptr noundef %oflag, ptr noundef %mode)
  %tobool38 = icmp ne i32 %call37, 0
  br i1 %tobool38, label %if.end40, label %if.then39

if.then39:                                        ; preds = %sw.bb
  br label %fail

if.end40:                                         ; preds = %sw.bb
  %38 = load ptr, ptr %temp_buffer.addr, align 8
  %39 = load ptr, ptr %path, align 8
  %call41 = call i32 @PyList_Append(ptr noundef %38, ptr noundef %39)
  %tobool42 = icmp ne i32 %call41, 0
  br i1 %tobool42, label %if.then43, label %if.end44

if.then43:                                        ; preds = %if.end40
  %40 = load ptr, ptr %path, align 8
  store ptr %40, ptr %op.addr.i124, align 8
  %41 = load ptr, ptr %op.addr.i124, align 8
  store ptr %41, ptr %op.addr.i144, align 8
  %42 = load ptr, ptr %op.addr.i144, align 8
  %43 = load i64, ptr %42, align 8
  %conv.i145 = trunc i64 %43 to i32
  %cmp.i146 = icmp slt i32 %conv.i145, 0
  %conv1.i147 = zext i1 %cmp.i146 to i32
  %tobool.i126 = icmp ne i32 %conv1.i147, 0
  br i1 %tobool.i126, label %if.then.i131, label %if.end.i127

if.then.i131:                                     ; preds = %if.then43
  br label %Py_DECREF.exit132

if.end.i127:                                      ; preds = %if.then43
  %44 = load ptr, ptr %op.addr.i124, align 8
  %45 = load i64, ptr %44, align 8
  %dec.i128 = add i64 %45, -1
  store i64 %dec.i128, ptr %44, align 8
  %cmp.i129 = icmp eq i64 %dec.i128, 0
  br i1 %cmp.i129, label %if.then1.i130, label %Py_DECREF.exit132

if.then1.i130:                                    ; preds = %if.end.i127
  %46 = load ptr, ptr %op.addr.i124, align 8
  call void @_Py_Dealloc(ptr noundef %46) #10
  br label %Py_DECREF.exit132

Py_DECREF.exit132:                                ; preds = %if.then1.i130, %if.end.i127, %if.then.i131
  br label %fail

if.end44:                                         ; preds = %if.end40
  %47 = load ptr, ptr %file_actionsp.addr, align 8
  %48 = load i32, ptr %fd, align 4
  %49 = load ptr, ptr %path, align 8
  %call45 = call ptr @PyBytes_AS_STRING(ptr noundef %49)
  %50 = load i32, ptr %oflag, align 4
  %51 = load i64, ptr %mode, align 8
  %conv = trunc i64 %51 to i32
  %call46 = call i32 @posix_spawn_file_actions_addopen(ptr noundef %47, i32 noundef %48, ptr noundef %call45, i32 noundef %50, i32 noundef %conv) #10
  %call47 = call ptr @__errno_location() #12
  store i32 %call46, ptr %call47, align 4
  %call48 = call ptr @__errno_location() #12
  %52 = load i32, ptr %call48, align 4
  %tobool49 = icmp ne i32 %52, 0
  br i1 %tobool49, label %if.then50, label %if.end52

if.then50:                                        ; preds = %if.end44
  %call51 = call ptr @posix_error()
  %53 = load ptr, ptr %path, align 8
  store ptr %53, ptr %op.addr.i115, align 8
  %54 = load ptr, ptr %op.addr.i115, align 8
  store ptr %54, ptr %op.addr.i148, align 8
  %55 = load ptr, ptr %op.addr.i148, align 8
  %56 = load i64, ptr %55, align 8
  %conv.i149 = trunc i64 %56 to i32
  %cmp.i150 = icmp slt i32 %conv.i149, 0
  %conv1.i151 = zext i1 %cmp.i150 to i32
  %tobool.i117 = icmp ne i32 %conv1.i151, 0
  br i1 %tobool.i117, label %if.then.i122, label %if.end.i118

if.then.i122:                                     ; preds = %if.then50
  br label %Py_DECREF.exit123

if.end.i118:                                      ; preds = %if.then50
  %57 = load ptr, ptr %op.addr.i115, align 8
  %58 = load i64, ptr %57, align 8
  %dec.i119 = add i64 %58, -1
  store i64 %dec.i119, ptr %57, align 8
  %cmp.i120 = icmp eq i64 %dec.i119, 0
  br i1 %cmp.i120, label %if.then1.i121, label %Py_DECREF.exit123

if.then1.i121:                                    ; preds = %if.end.i118
  %59 = load ptr, ptr %op.addr.i115, align 8
  call void @_Py_Dealloc(ptr noundef %59) #10
  br label %Py_DECREF.exit123

Py_DECREF.exit123:                                ; preds = %if.then1.i121, %if.end.i118, %if.then.i122
  br label %fail

if.end52:                                         ; preds = %if.end44
  %60 = load ptr, ptr %path, align 8
  store ptr %60, ptr %op.addr.i106, align 8
  %61 = load ptr, ptr %op.addr.i106, align 8
  store ptr %61, ptr %op.addr.i152, align 8
  %62 = load ptr, ptr %op.addr.i152, align 8
  %63 = load i64, ptr %62, align 8
  %conv.i153 = trunc i64 %63 to i32
  %cmp.i154 = icmp slt i32 %conv.i153, 0
  %conv1.i155 = zext i1 %cmp.i154 to i32
  %tobool.i108 = icmp ne i32 %conv1.i155, 0
  br i1 %tobool.i108, label %if.then.i113, label %if.end.i109

if.then.i113:                                     ; preds = %if.end52
  br label %Py_DECREF.exit114

if.end.i109:                                      ; preds = %if.end52
  %64 = load ptr, ptr %op.addr.i106, align 8
  %65 = load i64, ptr %64, align 8
  %dec.i110 = add i64 %65, -1
  store i64 %dec.i110, ptr %64, align 8
  %cmp.i111 = icmp eq i64 %dec.i110, 0
  br i1 %cmp.i111, label %if.then1.i112, label %Py_DECREF.exit114

if.then1.i112:                                    ; preds = %if.end.i109
  %66 = load ptr, ptr %op.addr.i106, align 8
  call void @_Py_Dealloc(ptr noundef %66) #10
  br label %Py_DECREF.exit114

Py_DECREF.exit114:                                ; preds = %if.then1.i112, %if.end.i109, %if.then.i113
  br label %sw.epilog

sw.bb53:                                          ; preds = %if.end36
  %67 = load ptr, ptr %file_action, align 8
  %call55 = call i32 (ptr, ptr, ...) @PyArg_ParseTuple(ptr noundef %67, ptr noundef @.str.247, ptr noundef %tag_obj, ptr noundef %fd54)
  %tobool56 = icmp ne i32 %call55, 0
  br i1 %tobool56, label %if.end58, label %if.then57

if.then57:                                        ; preds = %sw.bb53
  br label %fail

if.end58:                                         ; preds = %sw.bb53
  %68 = load ptr, ptr %file_actionsp.addr, align 8
  %69 = load i32, ptr %fd54, align 4
  %call59 = call i32 @posix_spawn_file_actions_addclose(ptr noundef %68, i32 noundef %69) #10
  %call60 = call ptr @__errno_location() #12
  store i32 %call59, ptr %call60, align 4
  %call61 = call ptr @__errno_location() #12
  %70 = load i32, ptr %call61, align 4
  %tobool62 = icmp ne i32 %70, 0
  br i1 %tobool62, label %if.then63, label %if.end65

if.then63:                                        ; preds = %if.end58
  %call64 = call ptr @posix_error()
  br label %fail

if.end65:                                         ; preds = %if.end58
  br label %sw.epilog

sw.bb66:                                          ; preds = %if.end36
  %71 = load ptr, ptr %file_action, align 8
  %call67 = call i32 (ptr, ptr, ...) @PyArg_ParseTuple(ptr noundef %71, ptr noundef @.str.248, ptr noundef %tag_obj, ptr noundef %fd1, ptr noundef %fd2)
  %tobool68 = icmp ne i32 %call67, 0
  br i1 %tobool68, label %if.end70, label %if.then69

if.then69:                                        ; preds = %sw.bb66
  br label %fail

if.end70:                                         ; preds = %sw.bb66
  %72 = load ptr, ptr %file_actionsp.addr, align 8
  %73 = load i32, ptr %fd1, align 4
  %74 = load i32, ptr %fd2, align 4
  %call71 = call i32 @posix_spawn_file_actions_adddup2(ptr noundef %72, i32 noundef %73, i32 noundef %74) #10
  %call72 = call ptr @__errno_location() #12
  store i32 %call71, ptr %call72, align 4
  %call73 = call ptr @__errno_location() #12
  %75 = load i32, ptr %call73, align 4
  %tobool74 = icmp ne i32 %75, 0
  br i1 %tobool74, label %if.then75, label %if.end77

if.then75:                                        ; preds = %if.end70
  %call76 = call ptr @posix_error()
  br label %fail

if.end77:                                         ; preds = %if.end70
  br label %sw.epilog

sw.default:                                       ; preds = %if.end36
  %76 = load ptr, ptr @PyExc_TypeError, align 8
  call void @PyErr_SetString(ptr noundef %76, ptr noundef @.str.249)
  br label %fail

sw.epilog:                                        ; preds = %if.end77, %if.end65, %Py_DECREF.exit114
  %77 = load ptr, ptr %file_action, align 8
  store ptr %77, ptr %op.addr.i97, align 8
  %78 = load ptr, ptr %op.addr.i97, align 8
  store ptr %78, ptr %op.addr.i156, align 8
  %79 = load ptr, ptr %op.addr.i156, align 8
  %80 = load i64, ptr %79, align 8
  %conv.i157 = trunc i64 %80 to i32
  %cmp.i158 = icmp slt i32 %conv.i157, 0
  %conv1.i159 = zext i1 %cmp.i158 to i32
  %tobool.i99 = icmp ne i32 %conv1.i159, 0
  br i1 %tobool.i99, label %if.then.i104, label %if.end.i100

if.then.i104:                                     ; preds = %sw.epilog
  br label %Py_DECREF.exit105

if.end.i100:                                      ; preds = %sw.epilog
  %81 = load ptr, ptr %op.addr.i97, align 8
  %82 = load i64, ptr %81, align 8
  %dec.i101 = add i64 %82, -1
  store i64 %dec.i101, ptr %81, align 8
  %cmp.i102 = icmp eq i64 %dec.i101, 0
  br i1 %cmp.i102, label %if.then1.i103, label %Py_DECREF.exit105

if.then1.i103:                                    ; preds = %if.end.i100
  %83 = load ptr, ptr %op.addr.i97, align 8
  call void @_Py_Dealloc(ptr noundef %83) #10
  br label %Py_DECREF.exit105

Py_DECREF.exit105:                                ; preds = %if.then1.i103, %if.end.i100, %if.then.i104
  br label %for.inc

for.inc:                                          ; preds = %Py_DECREF.exit105
  %84 = load i64, ptr %i, align 8
  %inc = add i64 %84, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !14

for.end:                                          ; preds = %cond.end
  %85 = load ptr, ptr %seq, align 8
  store ptr %85, ptr %op.addr.i88, align 8
  %86 = load ptr, ptr %op.addr.i88, align 8
  store ptr %86, ptr %op.addr.i160, align 8
  %87 = load ptr, ptr %op.addr.i160, align 8
  %88 = load i64, ptr %87, align 8
  %conv.i161 = trunc i64 %88 to i32
  %cmp.i162 = icmp slt i32 %conv.i161, 0
  %conv1.i163 = zext i1 %cmp.i162 to i32
  %tobool.i90 = icmp ne i32 %conv1.i163, 0
  br i1 %tobool.i90, label %if.then.i95, label %if.end.i91

if.then.i95:                                      ; preds = %for.end
  br label %Py_DECREF.exit96

if.end.i91:                                       ; preds = %for.end
  %89 = load ptr, ptr %op.addr.i88, align 8
  %90 = load i64, ptr %89, align 8
  %dec.i92 = add i64 %90, -1
  store i64 %dec.i92, ptr %89, align 8
  %cmp.i93 = icmp eq i64 %dec.i92, 0
  br i1 %cmp.i93, label %if.then1.i94, label %Py_DECREF.exit96

if.then1.i94:                                     ; preds = %if.end.i91
  %91 = load ptr, ptr %op.addr.i88, align 8
  call void @_Py_Dealloc(ptr noundef %91) #10
  br label %Py_DECREF.exit96

Py_DECREF.exit96:                                 ; preds = %if.then1.i94, %if.end.i91, %if.then.i95
  store i32 0, ptr %retval, align 4
  br label %return

fail:                                             ; preds = %sw.default, %if.then75, %if.then69, %if.then63, %if.then57, %Py_DECREF.exit123, %Py_DECREF.exit132, %if.then39, %if.then35, %if.then27
  %92 = load ptr, ptr %seq, align 8
  store ptr %92, ptr %op.addr.i79, align 8
  %93 = load ptr, ptr %op.addr.i79, align 8
  store ptr %93, ptr %op.addr.i164, align 8
  %94 = load ptr, ptr %op.addr.i164, align 8
  %95 = load i64, ptr %94, align 8
  %conv.i165 = trunc i64 %95 to i32
  %cmp.i166 = icmp slt i32 %conv.i165, 0
  %conv1.i167 = zext i1 %cmp.i166 to i32
  %tobool.i81 = icmp ne i32 %conv1.i167, 0
  br i1 %tobool.i81, label %if.then.i86, label %if.end.i82

if.then.i86:                                      ; preds = %fail
  br label %Py_DECREF.exit87

if.end.i82:                                       ; preds = %fail
  %96 = load ptr, ptr %op.addr.i79, align 8
  %97 = load i64, ptr %96, align 8
  %dec.i83 = add i64 %97, -1
  store i64 %dec.i83, ptr %96, align 8
  %cmp.i84 = icmp eq i64 %dec.i83, 0
  br i1 %cmp.i84, label %if.then1.i85, label %Py_DECREF.exit87

if.then1.i85:                                     ; preds = %if.end.i82
  %98 = load ptr, ptr %op.addr.i79, align 8
  call void @_Py_Dealloc(ptr noundef %98) #10
  br label %Py_DECREF.exit87

Py_DECREF.exit87:                                 ; preds = %if.then1.i85, %if.end.i82, %if.then.i86
  %99 = load ptr, ptr %file_action, align 8
  store ptr %99, ptr %op.addr.i, align 8
  %100 = load ptr, ptr %op.addr.i, align 8
  store ptr %100, ptr %op.addr.i168, align 8
  %101 = load ptr, ptr %op.addr.i168, align 8
  %102 = load i64, ptr %101, align 8
  %conv.i169 = trunc i64 %102 to i32
  %cmp.i170 = icmp slt i32 %conv.i169, 0
  %conv1.i171 = zext i1 %cmp.i170 to i32
  %tobool.i = icmp ne i32 %conv1.i171, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %Py_DECREF.exit87
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %Py_DECREF.exit87
  %103 = load ptr, ptr %op.addr.i, align 8
  %104 = load i64, ptr %103, align 8
  %dec.i = add i64 %104, -1
  store i64 %dec.i, ptr %103, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %105 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %105) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  %106 = load ptr, ptr %file_actionsp.addr, align 8
  %call78 = call i32 @posix_spawn_file_actions_destroy(ptr noundef %106) #10
  store i32 -1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %Py_DECREF.exit, %Py_DECREF.exit96, %Py_DECREF.exit141, %if.then
  %107 = load i32, ptr %retval, align 4
  ret i32 %107
}

; Function Attrs: nounwind uwtable
define internal i32 @parse_posix_spawn_flags(ptr noundef %module, ptr noundef %func_name, ptr noundef %setpgroup, i32 noundef %resetids, i32 noundef %setsid, ptr noundef %setsigmask, ptr noundef %setsigdef, ptr noundef %scheduler, ptr noundef %attrp) #0 {
entry:
  %retval = alloca i32, align 4
  %module.addr = alloca ptr, align 8
  %func_name.addr = alloca ptr, align 8
  %setpgroup.addr = alloca ptr, align 8
  %resetids.addr = alloca i32, align 4
  %setsid.addr = alloca i32, align 4
  %setsigmask.addr = alloca ptr, align 8
  %setsigdef.addr = alloca ptr, align 8
  %scheduler.addr = alloca ptr, align 8
  %attrp.addr = alloca ptr, align 8
  %all_flags = alloca i64, align 8
  %pgid = alloca i32, align 4
  %set = alloca %struct.__sigset_t, align 8
  %set45 = alloca %struct.__sigset_t, align 8
  %py_schedpolicy = alloca ptr, align 8
  %schedparam_obj = alloca ptr, align 8
  %schedparam = alloca %struct.sched_param, align 4
  %schedpolicy = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %func_name, ptr %func_name.addr, align 8
  store ptr %setpgroup, ptr %setpgroup.addr, align 8
  store i32 %resetids, ptr %resetids.addr, align 4
  store i32 %setsid, ptr %setsid.addr, align 4
  store ptr %setsigmask, ptr %setsigmask.addr, align 8
  store ptr %setsigdef, ptr %setsigdef.addr, align 8
  store ptr %scheduler, ptr %scheduler.addr, align 8
  store ptr %attrp, ptr %attrp.addr, align 8
  store i64 0, ptr %all_flags, align 8
  %0 = load ptr, ptr %attrp.addr, align 8
  %call = call i32 @posix_spawnattr_init(ptr noundef %0) #10
  %call1 = call ptr @__errno_location() #12
  store i32 %call, ptr %call1, align 4
  %call2 = call ptr @__errno_location() #12
  %1 = load i32, ptr %call2, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call3 = call ptr @posix_error()
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %setpgroup.addr, align 8
  %tobool4 = icmp ne ptr %2, null
  br i1 %tobool4, label %if.then5, label %if.end19

if.then5:                                         ; preds = %if.end
  %3 = load ptr, ptr %setpgroup.addr, align 8
  %call6 = call i64 @PyLong_AsLong(ptr noundef %3)
  %conv = trunc i64 %call6 to i32
  store i32 %conv, ptr %pgid, align 4
  %4 = load i32, ptr %pgid, align 4
  %cmp = icmp eq i32 %4, -1
  br i1 %cmp, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %if.then5
  %call8 = call ptr @PyErr_Occurred()
  %tobool9 = icmp ne ptr %call8, null
  br i1 %tobool9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %land.lhs.true
  br label %fail

if.end11:                                         ; preds = %land.lhs.true, %if.then5
  %5 = load ptr, ptr %attrp.addr, align 8
  %6 = load i32, ptr %pgid, align 4
  %call12 = call i32 @posix_spawnattr_setpgroup(ptr noundef %5, i32 noundef %6) #10
  %call13 = call ptr @__errno_location() #12
  store i32 %call12, ptr %call13, align 4
  %call14 = call ptr @__errno_location() #12
  %7 = load i32, ptr %call14, align 4
  %tobool15 = icmp ne i32 %7, 0
  br i1 %tobool15, label %if.then16, label %if.end18

if.then16:                                        ; preds = %if.end11
  %call17 = call ptr @posix_error()
  br label %fail

if.end18:                                         ; preds = %if.end11
  %8 = load i64, ptr %all_flags, align 8
  %or = or i64 %8, 2
  store i64 %or, ptr %all_flags, align 8
  br label %if.end19

if.end19:                                         ; preds = %if.end18, %if.end
  %9 = load i32, ptr %resetids.addr, align 4
  %tobool20 = icmp ne i32 %9, 0
  br i1 %tobool20, label %if.then21, label %if.end23

if.then21:                                        ; preds = %if.end19
  %10 = load i64, ptr %all_flags, align 8
  %or22 = or i64 %10, 1
  store i64 %or22, ptr %all_flags, align 8
  br label %if.end23

if.end23:                                         ; preds = %if.then21, %if.end19
  %11 = load i32, ptr %setsid.addr, align 4
  %tobool24 = icmp ne i32 %11, 0
  br i1 %tobool24, label %if.then25, label %if.end27

if.then25:                                        ; preds = %if.end23
  %12 = load i64, ptr %all_flags, align 8
  %or26 = or i64 %12, 128
  store i64 %or26, ptr %all_flags, align 8
  br label %if.end27

if.end27:                                         ; preds = %if.then25, %if.end23
  %13 = load ptr, ptr %setsigmask.addr, align 8
  %tobool28 = icmp ne ptr %13, null
  br i1 %tobool28, label %if.then29, label %if.end42

if.then29:                                        ; preds = %if.end27
  %14 = load ptr, ptr %setsigmask.addr, align 8
  %call30 = call i32 @_Py_Sigset_Converter(ptr noundef %14, ptr noundef %set)
  %tobool31 = icmp ne i32 %call30, 0
  br i1 %tobool31, label %if.end33, label %if.then32

if.then32:                                        ; preds = %if.then29
  br label %fail

if.end33:                                         ; preds = %if.then29
  %15 = load ptr, ptr %attrp.addr, align 8
  %call34 = call i32 @posix_spawnattr_setsigmask(ptr noundef %15, ptr noundef %set) #10
  %call35 = call ptr @__errno_location() #12
  store i32 %call34, ptr %call35, align 4
  %call36 = call ptr @__errno_location() #12
  %16 = load i32, ptr %call36, align 4
  %tobool37 = icmp ne i32 %16, 0
  br i1 %tobool37, label %if.then38, label %if.end40

if.then38:                                        ; preds = %if.end33
  %call39 = call ptr @posix_error()
  br label %fail

if.end40:                                         ; preds = %if.end33
  %17 = load i64, ptr %all_flags, align 8
  %or41 = or i64 %17, 8
  store i64 %or41, ptr %all_flags, align 8
  br label %if.end42

if.end42:                                         ; preds = %if.end40, %if.end27
  %18 = load ptr, ptr %setsigdef.addr, align 8
  %tobool43 = icmp ne ptr %18, null
  br i1 %tobool43, label %if.then44, label %if.end58

if.then44:                                        ; preds = %if.end42
  %19 = load ptr, ptr %setsigdef.addr, align 8
  %call46 = call i32 @_Py_Sigset_Converter(ptr noundef %19, ptr noundef %set45)
  %tobool47 = icmp ne i32 %call46, 0
  br i1 %tobool47, label %if.end49, label %if.then48

if.then48:                                        ; preds = %if.then44
  br label %fail

if.end49:                                         ; preds = %if.then44
  %20 = load ptr, ptr %attrp.addr, align 8
  %call50 = call i32 @posix_spawnattr_setsigdefault(ptr noundef %20, ptr noundef %set45) #10
  %call51 = call ptr @__errno_location() #12
  store i32 %call50, ptr %call51, align 4
  %call52 = call ptr @__errno_location() #12
  %21 = load i32, ptr %call52, align 4
  %tobool53 = icmp ne i32 %21, 0
  br i1 %tobool53, label %if.then54, label %if.end56

if.then54:                                        ; preds = %if.end49
  %call55 = call ptr @posix_error()
  br label %fail

if.end56:                                         ; preds = %if.end49
  %22 = load i64, ptr %all_flags, align 8
  %or57 = or i64 %22, 4
  store i64 %or57, ptr %all_flags, align 8
  br label %if.end58

if.end58:                                         ; preds = %if.end56, %if.end42
  %23 = load ptr, ptr %scheduler.addr, align 8
  %tobool59 = icmp ne ptr %23, null
  br i1 %tobool59, label %if.then60, label %if.end97

if.then60:                                        ; preds = %if.end58
  %24 = load ptr, ptr %scheduler.addr, align 8
  %call61 = call i32 (ptr, ptr, ...) @PyArg_ParseTuple(ptr noundef %24, ptr noundef @.str.250, ptr noundef %py_schedpolicy, ptr noundef %schedparam_obj)
  %tobool62 = icmp ne i32 %call61, 0
  br i1 %tobool62, label %if.end64, label %if.then63

if.then63:                                        ; preds = %if.then60
  br label %fail

if.end64:                                         ; preds = %if.then60
  %25 = load ptr, ptr %module.addr, align 8
  %26 = load ptr, ptr %schedparam_obj, align 8
  %call65 = call i32 @convert_sched_param(ptr noundef %25, ptr noundef %26, ptr noundef %schedparam)
  %tobool66 = icmp ne i32 %call65, 0
  br i1 %tobool66, label %if.end68, label %if.then67

if.then67:                                        ; preds = %if.end64
  br label %fail

if.end68:                                         ; preds = %if.end64
  %27 = load ptr, ptr %py_schedpolicy, align 8
  %cmp69 = icmp ne ptr %27, @_Py_NoneStruct
  br i1 %cmp69, label %if.then71, label %if.end88

if.then71:                                        ; preds = %if.end68
  %28 = load ptr, ptr %py_schedpolicy, align 8
  %call72 = call i32 @PyLong_AsInt(ptr noundef %28)
  store i32 %call72, ptr %schedpolicy, align 4
  %29 = load i32, ptr %schedpolicy, align 4
  %cmp73 = icmp eq i32 %29, -1
  br i1 %cmp73, label %land.lhs.true75, label %if.end79

land.lhs.true75:                                  ; preds = %if.then71
  %call76 = call ptr @PyErr_Occurred()
  %tobool77 = icmp ne ptr %call76, null
  br i1 %tobool77, label %if.then78, label %if.end79

if.then78:                                        ; preds = %land.lhs.true75
  br label %fail

if.end79:                                         ; preds = %land.lhs.true75, %if.then71
  %30 = load ptr, ptr %attrp.addr, align 8
  %31 = load i32, ptr %schedpolicy, align 4
  %call80 = call i32 @posix_spawnattr_setschedpolicy(ptr noundef %30, i32 noundef %31) #10
  %call81 = call ptr @__errno_location() #12
  store i32 %call80, ptr %call81, align 4
  %call82 = call ptr @__errno_location() #12
  %32 = load i32, ptr %call82, align 4
  %tobool83 = icmp ne i32 %32, 0
  br i1 %tobool83, label %if.then84, label %if.end86

if.then84:                                        ; preds = %if.end79
  %call85 = call ptr @posix_error()
  br label %fail

if.end86:                                         ; preds = %if.end79
  %33 = load i64, ptr %all_flags, align 8
  %or87 = or i64 %33, 32
  store i64 %or87, ptr %all_flags, align 8
  br label %if.end88

if.end88:                                         ; preds = %if.end86, %if.end68
  %34 = load ptr, ptr %attrp.addr, align 8
  %call89 = call i32 @posix_spawnattr_setschedparam(ptr noundef %34, ptr noundef %schedparam) #10
  %call90 = call ptr @__errno_location() #12
  store i32 %call89, ptr %call90, align 4
  %call91 = call ptr @__errno_location() #12
  %35 = load i32, ptr %call91, align 4
  %tobool92 = icmp ne i32 %35, 0
  br i1 %tobool92, label %if.then93, label %if.end95

if.then93:                                        ; preds = %if.end88
  %call94 = call ptr @posix_error()
  br label %fail

if.end95:                                         ; preds = %if.end88
  %36 = load i64, ptr %all_flags, align 8
  %or96 = or i64 %36, 16
  store i64 %or96, ptr %all_flags, align 8
  br label %if.end97

if.end97:                                         ; preds = %if.end95, %if.end58
  %37 = load ptr, ptr %attrp.addr, align 8
  %38 = load i64, ptr %all_flags, align 8
  %conv98 = trunc i64 %38 to i16
  %call99 = call i32 @posix_spawnattr_setflags(ptr noundef %37, i16 noundef signext %conv98) #10
  %call100 = call ptr @__errno_location() #12
  store i32 %call99, ptr %call100, align 4
  %call101 = call ptr @__errno_location() #12
  %39 = load i32, ptr %call101, align 4
  %tobool102 = icmp ne i32 %39, 0
  br i1 %tobool102, label %if.then103, label %if.end105

if.then103:                                       ; preds = %if.end97
  %call104 = call ptr @posix_error()
  br label %fail

if.end105:                                        ; preds = %if.end97
  store i32 0, ptr %retval, align 4
  br label %return

fail:                                             ; preds = %if.then103, %if.then93, %if.then84, %if.then78, %if.then67, %if.then63, %if.then54, %if.then48, %if.then38, %if.then32, %if.then16, %if.then10
  %40 = load ptr, ptr %attrp.addr, align 8
  %call106 = call i32 @posix_spawnattr_destroy(ptr noundef %40) #10
  store i32 -1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %fail, %if.end105, %if.then
  %41 = load i32, ptr %retval, align 4
  ret i32 %41
}

declare i32 @posix_spawnp(ptr noundef, ptr noundef, ptr noundef, ptr noundef, ptr noundef, ptr noundef) #1

declare i32 @posix_spawn(ptr noundef, ptr noundef, ptr noundef, ptr noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind
declare i32 @posix_spawn_file_actions_destroy(ptr noundef) #4

; Function Attrs: nounwind
declare i32 @posix_spawnattr_destroy(ptr noundef) #4

; Function Attrs: nounwind uwtable
define internal void @free_string_array(ptr noundef %array, i64 noundef %count) #0 {
entry:
  %array.addr = alloca ptr, align 8
  %count.addr = alloca i64, align 8
  %i = alloca i64, align 8
  store ptr %array, ptr %array.addr, align 8
  store i64 %count, ptr %count.addr, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8
  %1 = load i64, ptr %count.addr, align 8
  %cmp = icmp slt i64 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr %array.addr, align 8
  %3 = load i64, ptr %i, align 8
  %arrayidx = getelementptr ptr, ptr %2, i64 %3
  %4 = load ptr, ptr %arrayidx, align 8
  call void @PyMem_Free(ptr noundef %4)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %5 = load i64, ptr %i, align 8
  %inc = add i64 %5, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !15

for.end:                                          ; preds = %for.cond
  %6 = load ptr, ptr %array.addr, align 8
  call void @PyMem_Free(ptr noundef %6)
  ret void
}

declare ptr @PyMem_Malloc(i64 noundef) #1

; Function Attrs: nounwind uwtable
define internal i32 @fsconvert_strdup(ptr noundef %o, ptr noundef %out) #0 {
entry:
  %op.addr.i9 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca i32, align 4
  %o.addr = alloca ptr, align 8
  %out.addr = alloca ptr, align 8
  %size = alloca i64, align 8
  %ub = alloca ptr, align 8
  %result = alloca i32, align 4
  store ptr %o, ptr %o.addr, align 8
  store ptr %out, ptr %out.addr, align 8
  store i32 0, ptr %result, align 4
  %0 = load ptr, ptr %o.addr, align 8
  %call = call i32 @PyUnicode_FSConverter(ptr noundef %0, ptr noundef %ub)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %ub, align 8
  %call1 = call i64 @PyBytes_GET_SIZE(ptr noundef %1)
  store i64 %call1, ptr %size, align 8
  %2 = load i64, ptr %size, align 8
  %add = add i64 %2, 1
  %call2 = call ptr @PyMem_Malloc(i64 noundef %add)
  %3 = load ptr, ptr %out.addr, align 8
  store ptr %call2, ptr %3, align 8
  %4 = load ptr, ptr %out.addr, align 8
  %5 = load ptr, ptr %4, align 8
  %tobool3 = icmp ne ptr %5, null
  br i1 %tobool3, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.end
  %6 = load ptr, ptr %out.addr, align 8
  %7 = load ptr, ptr %6, align 8
  %8 = load ptr, ptr %ub, align 8
  %call5 = call ptr @PyBytes_AS_STRING(ptr noundef %8)
  %9 = load i64, ptr %size, align 8
  %add6 = add i64 %9, 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %7, ptr align 1 %call5, i64 %add6, i1 false)
  store i32 1, ptr %result, align 4
  br label %if.end8

if.else:                                          ; preds = %if.end
  %call7 = call ptr @PyErr_NoMemory()
  br label %if.end8

if.end8:                                          ; preds = %if.else, %if.then4
  %10 = load ptr, ptr %ub, align 8
  store ptr %10, ptr %op.addr.i, align 8
  %11 = load ptr, ptr %op.addr.i, align 8
  store ptr %11, ptr %op.addr.i9, align 8
  %12 = load ptr, ptr %op.addr.i9, align 8
  %13 = load i64, ptr %12, align 8
  %conv.i = trunc i64 %13 to i32
  %cmp.i10 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i10 to i32
  %tobool.i = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.end8
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.end8
  %14 = load ptr, ptr %op.addr.i, align 8
  %15 = load i64, ptr %14, align 8
  %dec.i = add i64 %15, -1
  store i64 %dec.i, ptr %14, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %16 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %16) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  %17 = load i32, ptr %result, align 4
  store i32 %17, ptr %retval, align 4
  br label %return

return:                                           ; preds = %Py_DECREF.exit, %if.then
  %18 = load i32, ptr %retval, align 4
  ret i32 %18
}

declare i64 @PyMapping_Size(ptr noundef) #1

declare ptr @PyMapping_Keys(ptr noundef) #1

declare ptr @PyMapping_Values(ptr noundef) #1

declare ptr @PyList_GetItem(ptr noundef, i64 noundef) #1

; Function Attrs: nounwind willreturn memory(read)
declare ptr @strchr(ptr noundef, i32 noundef) #7

declare ptr @PyBytes_FromFormat(ptr noundef, ...) #1

declare ptr @PySequence_Fast(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind
declare i32 @posix_spawn_file_actions_init(ptr noundef) #4

declare i64 @PyLong_AsLong(ptr noundef) #1

declare i32 @PyArg_ParseTuple(ptr noundef, ptr noundef, ...) #1

; Function Attrs: nounwind
declare i32 @posix_spawn_file_actions_addopen(ptr noundef, i32 noundef, ptr noundef, i32 noundef, i32 noundef) #4

; Function Attrs: nounwind
declare i32 @posix_spawn_file_actions_addclose(ptr noundef, i32 noundef) #4

; Function Attrs: nounwind
declare i32 @posix_spawn_file_actions_adddup2(ptr noundef, i32 noundef, i32 noundef) #4

; Function Attrs: nounwind
declare i32 @posix_spawnattr_init(ptr noundef) #4

; Function Attrs: nounwind
declare i32 @posix_spawnattr_setpgroup(ptr noundef, i32 noundef) #4

; Function Attrs: nounwind
declare i32 @posix_spawnattr_setsigmask(ptr noundef, ptr noundef) #4

; Function Attrs: nounwind
declare i32 @posix_spawnattr_setsigdefault(ptr noundef, ptr noundef) #4

; Function Attrs: nounwind uwtable
define internal i32 @convert_sched_param(ptr noundef %module, ptr noundef %param, ptr noundef %res) #0 {
entry:
  %retval = alloca i32, align 4
  %module.addr = alloca ptr, align 8
  %param.addr = alloca ptr, align 8
  %res.addr = alloca ptr, align 8
  %priority = alloca i64, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %param, ptr %param.addr, align 8
  store ptr %res, ptr %res.addr, align 8
  %0 = load ptr, ptr %param.addr, align 8
  %1 = load ptr, ptr %module.addr, align 8
  %call = call ptr @get_posix_state(ptr noundef %1)
  %SchedParamType = getelementptr inbounds %struct._posixstate, ptr %call, i32 0, i32 3
  %2 = load ptr, ptr %SchedParamType, align 8
  %call1 = call i32 @Py_IS_TYPE(ptr noundef %0, ptr noundef %2)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr @PyExc_TypeError, align 8
  call void @PyErr_SetString(ptr noundef %3, ptr noundef @.str.251)
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %param.addr, align 8
  %call2 = call ptr @PyStructSequence_GetItem(ptr noundef %4, i64 noundef 0)
  %call3 = call i64 @PyLong_AsLong(ptr noundef %call2)
  store i64 %call3, ptr %priority, align 8
  %5 = load i64, ptr %priority, align 8
  %cmp = icmp eq i64 %5, -1
  br i1 %cmp, label %land.lhs.true, label %if.end7

land.lhs.true:                                    ; preds = %if.end
  %call4 = call ptr @PyErr_Occurred()
  %tobool5 = icmp ne ptr %call4, null
  br i1 %tobool5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %land.lhs.true
  store i32 0, ptr %retval, align 4
  br label %return

if.end7:                                          ; preds = %land.lhs.true, %if.end
  %6 = load i64, ptr %priority, align 8
  %cmp8 = icmp sgt i64 %6, 2147483647
  br i1 %cmp8, label %if.then10, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end7
  %7 = load i64, ptr %priority, align 8
  %cmp9 = icmp slt i64 %7, -2147483648
  br i1 %cmp9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %lor.lhs.false, %if.end7
  %8 = load ptr, ptr @PyExc_OverflowError, align 8
  call void @PyErr_SetString(ptr noundef %8, ptr noundef @.str.252)
  store i32 0, ptr %retval, align 4
  br label %return

if.end11:                                         ; preds = %lor.lhs.false
  %9 = load i64, ptr %priority, align 8
  %conv = trunc i64 %9 to i32
  %10 = load ptr, ptr %res.addr, align 8
  %sched_priority = getelementptr inbounds %struct.sched_param, ptr %10, i32 0, i32 0
  store i32 %conv, ptr %sched_priority, align 4
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end11, %if.then10, %if.then6, %if.then
  %11 = load i32, ptr %retval, align 4
  ret i32 %11
}

; Function Attrs: nounwind
declare i32 @posix_spawnattr_setschedpolicy(ptr noundef, i32 noundef) #4

; Function Attrs: nounwind
declare i32 @posix_spawnattr_setschedparam(ptr noundef, ptr noundef) #4

; Function Attrs: nounwind
declare i32 @posix_spawnattr_setflags(ptr noundef, i16 noundef signext) #4

; Function Attrs: nounwind uwtable
define internal i32 @Py_IS_TYPE(ptr noundef %ob, ptr noundef %type) #0 {
entry:
  %ob.addr = alloca ptr, align 8
  %type.addr = alloca ptr, align 8
  store ptr %ob, ptr %ob.addr, align 8
  store ptr %type, ptr %type.addr, align 8
  %0 = load ptr, ptr %ob.addr, align 8
  %call = call ptr @Py_TYPE(ptr noundef %0)
  %1 = load ptr, ptr %type.addr, align 8
  %cmp = icmp eq ptr %call, %1
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

declare ptr @PyStructSequence_GetItem(ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @os_posix_spawnp_impl(ptr noundef %module, ptr noundef %path, ptr noundef %argv, ptr noundef %env, ptr noundef %file_actions, ptr noundef %setpgroup, i32 noundef %resetids, i32 noundef %setsid, ptr noundef %setsigmask, ptr noundef %setsigdef, ptr noundef %scheduler) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %path.addr = alloca ptr, align 8
  %argv.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %file_actions.addr = alloca ptr, align 8
  %setpgroup.addr = alloca ptr, align 8
  %resetids.addr = alloca i32, align 4
  %setsid.addr = alloca i32, align 4
  %setsigmask.addr = alloca ptr, align 8
  %setsigdef.addr = alloca ptr, align 8
  %scheduler.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %path, ptr %path.addr, align 8
  store ptr %argv, ptr %argv.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store ptr %file_actions, ptr %file_actions.addr, align 8
  store ptr %setpgroup, ptr %setpgroup.addr, align 8
  store i32 %resetids, ptr %resetids.addr, align 4
  store i32 %setsid, ptr %setsid.addr, align 4
  store ptr %setsigmask, ptr %setsigmask.addr, align 8
  store ptr %setsigdef, ptr %setsigdef.addr, align 8
  store ptr %scheduler, ptr %scheduler.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %1 = load ptr, ptr %path.addr, align 8
  %2 = load ptr, ptr %argv.addr, align 8
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load ptr, ptr %file_actions.addr, align 8
  %5 = load ptr, ptr %setpgroup.addr, align 8
  %6 = load i32, ptr %resetids.addr, align 4
  %7 = load i32, ptr %setsid.addr, align 4
  %8 = load ptr, ptr %setsigmask.addr, align 8
  %9 = load ptr, ptr %setsigdef.addr, align 8
  %10 = load ptr, ptr %scheduler.addr, align 8
  %call = call ptr @py_posix_spawn(i32 noundef 1, ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, ptr noundef %5, i32 noundef %6, i32 noundef %7, ptr noundef %8, ptr noundef %9, ptr noundef %10)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @os_readlink_impl(ptr noundef %module, ptr noundef %path, i32 noundef %dir_fd) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %path.addr = alloca ptr, align 8
  %dir_fd.addr = alloca i32, align 4
  %buffer = alloca [4097 x i8], align 16
  %length = alloca i64, align 8
  %readlinkat_unavailable = alloca i32, align 4
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %path, ptr %path.addr, align 8
  store i32 %dir_fd, ptr %dir_fd.addr, align 4
  store i32 0, ptr %readlinkat_unavailable, align 4
  %call = call ptr @PyEval_SaveThread()
  store ptr %call, ptr %_save, align 8
  %0 = load i32, ptr %dir_fd.addr, align 4
  %cmp = icmp ne i32 %0, -100
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i32, ptr %dir_fd.addr, align 4
  %2 = load ptr, ptr %path.addr, align 8
  %narrow = getelementptr inbounds %struct.path_t, ptr %2, i32 0, i32 5
  %3 = load ptr, ptr %narrow, align 8
  %arraydecay = getelementptr inbounds [4097 x i8], ptr %buffer, i64 0, i64 0
  %call1 = call i64 @readlinkat(i32 noundef %1, ptr noundef %3, ptr noundef %arraydecay, i64 noundef 4096) #10
  store i64 %call1, ptr %length, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %4 = load ptr, ptr %path.addr, align 8
  %narrow2 = getelementptr inbounds %struct.path_t, ptr %4, i32 0, i32 5
  %5 = load ptr, ptr %narrow2, align 8
  %arraydecay3 = getelementptr inbounds [4097 x i8], ptr %buffer, i64 0, i64 0
  %call4 = call i64 @readlink(ptr noundef %5, ptr noundef %arraydecay3, i64 noundef 4096) #10
  store i64 %call4, ptr %length, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %6 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %6)
  %7 = load i32, ptr %readlinkat_unavailable, align 4
  %tobool = icmp ne i32 %7, 0
  br i1 %tobool, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end
  call void @argument_unavailable_error(ptr noundef null, ptr noundef @.str.184)
  store ptr null, ptr %retval, align 8
  br label %return

if.end6:                                          ; preds = %if.end
  %8 = load i64, ptr %length, align 8
  %cmp7 = icmp slt i64 %8, 0
  br i1 %cmp7, label %if.then8, label %if.end10

if.then8:                                         ; preds = %if.end6
  %9 = load ptr, ptr %path.addr, align 8
  %call9 = call ptr @path_error(ptr noundef %9)
  store ptr %call9, ptr %retval, align 8
  br label %return

if.end10:                                         ; preds = %if.end6
  %10 = load i64, ptr %length, align 8
  %arrayidx = getelementptr [4097 x i8], ptr %buffer, i64 0, i64 %10
  store i8 0, ptr %arrayidx, align 1
  %11 = load ptr, ptr %path.addr, align 8
  %object = getelementptr inbounds %struct.path_t, ptr %11, i32 0, i32 8
  %12 = load ptr, ptr %object, align 8
  %call11 = call ptr @Py_TYPE(ptr noundef %12)
  %call12 = call i32 @PyType_HasFeature(ptr noundef %call11, i64 noundef 268435456)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.then14, label %if.else17

if.then14:                                        ; preds = %if.end10
  %arraydecay15 = getelementptr inbounds [4097 x i8], ptr %buffer, i64 0, i64 0
  %13 = load i64, ptr %length, align 8
  %call16 = call ptr @PyUnicode_DecodeFSDefaultAndSize(ptr noundef %arraydecay15, i64 noundef %13)
  store ptr %call16, ptr %retval, align 8
  br label %return

if.else17:                                        ; preds = %if.end10
  %arraydecay18 = getelementptr inbounds [4097 x i8], ptr %buffer, i64 0, i64 0
  %14 = load i64, ptr %length, align 8
  %call19 = call ptr @PyBytes_FromStringAndSize(ptr noundef %arraydecay18, i64 noundef %14)
  store ptr %call19, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else17, %if.then14, %if.then8, %if.then5
  %15 = load ptr, ptr %retval, align 8
  ret ptr %15
}

; Function Attrs: nounwind
declare i64 @readlinkat(i32 noundef, ptr noundef, ptr noundef, i64 noundef) #4

; Function Attrs: nounwind
declare i64 @readlink(ptr noundef, ptr noundef, i64 noundef) #4

declare i64 @PyLong_AsSsize_t(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @os_copy_file_range_impl(ptr noundef %module, i32 noundef %src, i32 noundef %dst, i64 noundef %count, ptr noundef %offset_src, ptr noundef %offset_dst) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %src.addr = alloca i32, align 4
  %dst.addr = alloca i32, align 4
  %count.addr = alloca i64, align 8
  %offset_src.addr = alloca ptr, align 8
  %offset_dst.addr = alloca ptr, align 8
  %offset_src_val = alloca i64, align 8
  %offset_dst_val = alloca i64, align 8
  %p_offset_src = alloca ptr, align 8
  %p_offset_dst = alloca ptr, align 8
  %ret = alloca i64, align 8
  %async_err = alloca i32, align 4
  %flags = alloca i32, align 4
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %src, ptr %src.addr, align 4
  store i32 %dst, ptr %dst.addr, align 4
  store i64 %count, ptr %count.addr, align 8
  store ptr %offset_src, ptr %offset_src.addr, align 8
  store ptr %offset_dst, ptr %offset_dst.addr, align 8
  store ptr null, ptr %p_offset_src, align 8
  store ptr null, ptr %p_offset_dst, align 8
  store i32 0, ptr %async_err, align 4
  store i32 0, ptr %flags, align 4
  %0 = load i64, ptr %count.addr, align 8
  %cmp = icmp slt i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr @PyExc_ValueError, align 8
  call void @PyErr_SetString(ptr noundef %1, ptr noundef @.str.256)
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %offset_src.addr, align 8
  %cmp1 = icmp ne ptr %2, @_Py_NoneStruct
  br i1 %cmp1, label %if.then2, label %if.end5

if.then2:                                         ; preds = %if.end
  %3 = load ptr, ptr %offset_src.addr, align 8
  %call = call i32 @Py_off_t_converter(ptr noundef %3, ptr noundef %offset_src_val)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end4, label %if.then3

if.then3:                                         ; preds = %if.then2
  store ptr null, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %if.then2
  store ptr %offset_src_val, ptr %p_offset_src, align 8
  br label %if.end5

if.end5:                                          ; preds = %if.end4, %if.end
  %4 = load ptr, ptr %offset_dst.addr, align 8
  %cmp6 = icmp ne ptr %4, @_Py_NoneStruct
  br i1 %cmp6, label %if.then7, label %if.end12

if.then7:                                         ; preds = %if.end5
  %5 = load ptr, ptr %offset_dst.addr, align 8
  %call8 = call i32 @Py_off_t_converter(ptr noundef %5, ptr noundef %offset_dst_val)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end11, label %if.then10

if.then10:                                        ; preds = %if.then7
  store ptr null, ptr %retval, align 8
  br label %return

if.end11:                                         ; preds = %if.then7
  store ptr %offset_dst_val, ptr %p_offset_dst, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %if.end5
  br label %do.body

do.body:                                          ; preds = %land.end, %if.end12
  %call13 = call ptr @PyEval_SaveThread()
  store ptr %call13, ptr %_save, align 8
  %6 = load i32, ptr %src.addr, align 4
  %7 = load ptr, ptr %p_offset_src, align 8
  %8 = load i32, ptr %dst.addr, align 4
  %9 = load ptr, ptr %p_offset_dst, align 8
  %10 = load i64, ptr %count.addr, align 8
  %11 = load i32, ptr %flags, align 4
  %call14 = call i64 @copy_file_range(i32 noundef %6, ptr noundef %7, i32 noundef %8, ptr noundef %9, i64 noundef %10, i32 noundef %11)
  store i64 %call14, ptr %ret, align 8
  %12 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %12)
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %13 = load i64, ptr %ret, align 8
  %cmp15 = icmp slt i64 %13, 0
  br i1 %cmp15, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %do.cond
  %call16 = call ptr @__errno_location() #12
  %14 = load i32, ptr %call16, align 4
  %cmp17 = icmp eq i32 %14, 4
  br i1 %cmp17, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %call18 = call i32 @PyErr_CheckSignals()
  store i32 %call18, ptr %async_err, align 4
  %tobool19 = icmp ne i32 %call18, 0
  %lnot = xor i1 %tobool19, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %do.cond
  %15 = phi i1 [ false, %land.lhs.true ], [ false, %do.cond ], [ %lnot, %land.rhs ]
  br i1 %15, label %do.body, label %do.end, !llvm.loop !16

do.end:                                           ; preds = %land.end
  %16 = load i64, ptr %ret, align 8
  %cmp20 = icmp slt i64 %16, 0
  br i1 %cmp20, label %if.then21, label %if.end24

if.then21:                                        ; preds = %do.end
  %17 = load i32, ptr %async_err, align 4
  %tobool22 = icmp ne i32 %17, 0
  br i1 %tobool22, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then21
  %call23 = call ptr @posix_error()
  br label %cond.end

cond.false:                                       ; preds = %if.then21
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call23, %cond.true ], [ null, %cond.false ]
  store ptr %cond, ptr %retval, align 8
  br label %return

if.end24:                                         ; preds = %do.end
  %18 = load i64, ptr %ret, align 8
  %call25 = call ptr @PyLong_FromSsize_t(i64 noundef %18)
  store ptr %call25, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end24, %cond.end, %if.then10, %if.then3, %if.then
  %19 = load ptr, ptr %retval, align 8
  ret ptr %19
}

; Function Attrs: nounwind uwtable
define internal i32 @Py_off_t_converter(ptr noundef %arg, ptr noundef %addr) #0 {
entry:
  %retval = alloca i32, align 4
  %arg.addr = alloca ptr, align 8
  %addr.addr = alloca ptr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr %addr, ptr %addr.addr, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %call = call i64 @PyLong_AsLong(ptr noundef %0)
  %1 = load ptr, ptr %addr.addr, align 8
  store i64 %call, ptr %1, align 8
  %call1 = call ptr @PyErr_Occurred()
  %tobool = icmp ne ptr %call1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load i32, ptr %retval, align 4
  ret i32 %2
}

declare i64 @copy_file_range(i32 noundef, ptr noundef, i32 noundef, ptr noundef, i64 noundef, i32 noundef) #1

declare ptr @PyLong_FromSsize_t(i64 noundef) #1

declare i32 @_PyLong_UnsignedInt_Converter(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @os_splice_impl(ptr noundef %module, i32 noundef %src, i32 noundef %dst, i64 noundef %count, ptr noundef %offset_src, ptr noundef %offset_dst, i32 noundef %flags) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %src.addr = alloca i32, align 4
  %dst.addr = alloca i32, align 4
  %count.addr = alloca i64, align 8
  %offset_src.addr = alloca ptr, align 8
  %offset_dst.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %offset_src_val = alloca i64, align 8
  %offset_dst_val = alloca i64, align 8
  %p_offset_src = alloca ptr, align 8
  %p_offset_dst = alloca ptr, align 8
  %ret = alloca i64, align 8
  %async_err = alloca i32, align 4
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %src, ptr %src.addr, align 4
  store i32 %dst, ptr %dst.addr, align 4
  store i64 %count, ptr %count.addr, align 8
  store ptr %offset_src, ptr %offset_src.addr, align 8
  store ptr %offset_dst, ptr %offset_dst.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  store ptr null, ptr %p_offset_src, align 8
  store ptr null, ptr %p_offset_dst, align 8
  store i32 0, ptr %async_err, align 4
  %0 = load i64, ptr %count.addr, align 8
  %cmp = icmp slt i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr @PyExc_ValueError, align 8
  call void @PyErr_SetString(ptr noundef %1, ptr noundef @.str.256)
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %offset_src.addr, align 8
  %cmp1 = icmp ne ptr %2, @_Py_NoneStruct
  br i1 %cmp1, label %if.then2, label %if.end5

if.then2:                                         ; preds = %if.end
  %3 = load ptr, ptr %offset_src.addr, align 8
  %call = call i32 @Py_off_t_converter(ptr noundef %3, ptr noundef %offset_src_val)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end4, label %if.then3

if.then3:                                         ; preds = %if.then2
  store ptr null, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %if.then2
  store ptr %offset_src_val, ptr %p_offset_src, align 8
  br label %if.end5

if.end5:                                          ; preds = %if.end4, %if.end
  %4 = load ptr, ptr %offset_dst.addr, align 8
  %cmp6 = icmp ne ptr %4, @_Py_NoneStruct
  br i1 %cmp6, label %if.then7, label %if.end12

if.then7:                                         ; preds = %if.end5
  %5 = load ptr, ptr %offset_dst.addr, align 8
  %call8 = call i32 @Py_off_t_converter(ptr noundef %5, ptr noundef %offset_dst_val)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end11, label %if.then10

if.then10:                                        ; preds = %if.then7
  store ptr null, ptr %retval, align 8
  br label %return

if.end11:                                         ; preds = %if.then7
  store ptr %offset_dst_val, ptr %p_offset_dst, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %if.end5
  br label %do.body

do.body:                                          ; preds = %land.end, %if.end12
  %call13 = call ptr @PyEval_SaveThread()
  store ptr %call13, ptr %_save, align 8
  %6 = load i32, ptr %src.addr, align 4
  %7 = load ptr, ptr %p_offset_src, align 8
  %8 = load i32, ptr %dst.addr, align 4
  %9 = load ptr, ptr %p_offset_dst, align 8
  %10 = load i64, ptr %count.addr, align 8
  %11 = load i32, ptr %flags.addr, align 4
  %call14 = call i64 @splice(i32 noundef %6, ptr noundef %7, i32 noundef %8, ptr noundef %9, i64 noundef %10, i32 noundef %11)
  store i64 %call14, ptr %ret, align 8
  %12 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %12)
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %13 = load i64, ptr %ret, align 8
  %cmp15 = icmp slt i64 %13, 0
  br i1 %cmp15, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %do.cond
  %call16 = call ptr @__errno_location() #12
  %14 = load i32, ptr %call16, align 4
  %cmp17 = icmp eq i32 %14, 4
  br i1 %cmp17, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %call18 = call i32 @PyErr_CheckSignals()
  store i32 %call18, ptr %async_err, align 4
  %tobool19 = icmp ne i32 %call18, 0
  %lnot = xor i1 %tobool19, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %do.cond
  %15 = phi i1 [ false, %land.lhs.true ], [ false, %do.cond ], [ %lnot, %land.rhs ]
  br i1 %15, label %do.body, label %do.end, !llvm.loop !17

do.end:                                           ; preds = %land.end
  %16 = load i64, ptr %ret, align 8
  %cmp20 = icmp slt i64 %16, 0
  br i1 %cmp20, label %if.then21, label %if.end24

if.then21:                                        ; preds = %do.end
  %17 = load i32, ptr %async_err, align 4
  %tobool22 = icmp ne i32 %17, 0
  br i1 %tobool22, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then21
  %call23 = call ptr @posix_error()
  br label %cond.end

cond.false:                                       ; preds = %if.then21
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call23, %cond.true ], [ null, %cond.false ]
  store ptr %cond, ptr %retval, align 8
  br label %return

if.end24:                                         ; preds = %do.end
  %18 = load i64, ptr %ret, align 8
  %call25 = call ptr @PyLong_FromSsize_t(i64 noundef %18)
  store ptr %call25, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end24, %cond.end, %if.then10, %if.then3, %if.then
  %19 = load ptr, ptr %retval, align 8
  ret ptr %19
}

declare i64 @splice(i32 noundef, ptr noundef, i32 noundef, ptr noundef, i64 noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @os_rename_impl(ptr noundef %module, ptr noundef %src, ptr noundef %dst, i32 noundef %src_dir_fd, i32 noundef %dst_dir_fd) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %src.addr = alloca ptr, align 8
  %dst.addr = alloca ptr, align 8
  %src_dir_fd.addr = alloca i32, align 4
  %dst_dir_fd.addr = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %src, ptr %src.addr, align 8
  store ptr %dst, ptr %dst.addr, align 8
  store i32 %src_dir_fd, ptr %src_dir_fd.addr, align 4
  store i32 %dst_dir_fd, ptr %dst_dir_fd.addr, align 4
  %0 = load ptr, ptr %src.addr, align 8
  %1 = load ptr, ptr %dst.addr, align 8
  %2 = load i32, ptr %src_dir_fd.addr, align 4
  %3 = load i32, ptr %dst_dir_fd.addr, align 4
  %call = call ptr @internal_rename(ptr noundef %0, ptr noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef 0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @internal_rename(ptr noundef %src, ptr noundef %dst, i32 noundef %src_dir_fd, i32 noundef %dst_dir_fd, i32 noundef %is_replace) #0 {
entry:
  %retval = alloca ptr, align 8
  %src.addr = alloca ptr, align 8
  %dst.addr = alloca ptr, align 8
  %src_dir_fd.addr = alloca i32, align 4
  %dst_dir_fd.addr = alloca i32, align 4
  %is_replace.addr = alloca i32, align 4
  %function_name = alloca ptr, align 8
  %dir_fd_specified = alloca i32, align 4
  %renameat_unavailable = alloca i32, align 4
  %result = alloca i32, align 4
  %_save = alloca ptr, align 8
  store ptr %src, ptr %src.addr, align 8
  store ptr %dst, ptr %dst.addr, align 8
  store i32 %src_dir_fd, ptr %src_dir_fd.addr, align 4
  store i32 %dst_dir_fd, ptr %dst_dir_fd.addr, align 4
  store i32 %is_replace, ptr %is_replace.addr, align 4
  %0 = load i32, ptr %is_replace.addr, align 4
  %tobool = icmp ne i32 %0, 0
  %cond = select i1 %tobool, ptr @.str.38, ptr @.str.37
  store ptr %cond, ptr %function_name, align 8
  store i32 0, ptr %renameat_unavailable, align 4
  %1 = load i32, ptr %src_dir_fd.addr, align 4
  %cmp = icmp ne i32 %1, -100
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %2 = load i32, ptr %dst_dir_fd.addr, align 4
  %cmp1 = icmp ne i32 %2, -100
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %3 = phi i1 [ true, %entry ], [ %cmp1, %lor.rhs ]
  %lor.ext = zext i1 %3 to i32
  store i32 %lor.ext, ptr %dir_fd_specified, align 4
  %4 = load ptr, ptr %src.addr, align 8
  %object = getelementptr inbounds %struct.path_t, ptr %4, i32 0, i32 8
  %5 = load ptr, ptr %object, align 8
  %6 = load ptr, ptr %dst.addr, align 8
  %object2 = getelementptr inbounds %struct.path_t, ptr %6, i32 0, i32 8
  %7 = load ptr, ptr %object2, align 8
  %8 = load i32, ptr %src_dir_fd.addr, align 4
  %cmp3 = icmp eq i32 %8, -100
  br i1 %cmp3, label %cond.true, label %cond.false

cond.true:                                        ; preds = %lor.end
  br label %cond.end

cond.false:                                       ; preds = %lor.end
  %9 = load i32, ptr %src_dir_fd.addr, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond4 = phi i32 [ -1, %cond.true ], [ %9, %cond.false ]
  %10 = load i32, ptr %dst_dir_fd.addr, align 4
  %cmp5 = icmp eq i32 %10, -100
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.end
  br label %cond.end8

cond.false7:                                      ; preds = %cond.end
  %11 = load i32, ptr %dst_dir_fd.addr, align 4
  br label %cond.end8

cond.end8:                                        ; preds = %cond.false7, %cond.true6
  %cond9 = phi i32 [ -1, %cond.true6 ], [ %11, %cond.false7 ]
  %call = call i32 (ptr, ptr, ...) @PySys_Audit(ptr noundef @.str.258, ptr noundef @.str.221, ptr noundef %5, ptr noundef %7, i32 noundef %cond4, i32 noundef %cond9)
  %cmp10 = icmp slt i32 %call, 0
  br i1 %cmp10, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end8
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end8
  %12 = load ptr, ptr %src.addr, align 8
  %narrow = getelementptr inbounds %struct.path_t, ptr %12, i32 0, i32 5
  %13 = load ptr, ptr %narrow, align 8
  %tobool11 = icmp ne ptr %13, null
  br i1 %tobool11, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %if.end
  %14 = load ptr, ptr %dst.addr, align 8
  %wide = getelementptr inbounds %struct.path_t, ptr %14, i32 0, i32 4
  %15 = load ptr, ptr %wide, align 8
  %tobool12 = icmp ne ptr %15, null
  br i1 %tobool12, label %if.then18, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %if.end
  %16 = load ptr, ptr %src.addr, align 8
  %wide13 = getelementptr inbounds %struct.path_t, ptr %16, i32 0, i32 4
  %17 = load ptr, ptr %wide13, align 8
  %tobool14 = icmp ne ptr %17, null
  br i1 %tobool14, label %land.lhs.true15, label %if.end20

land.lhs.true15:                                  ; preds = %lor.lhs.false
  %18 = load ptr, ptr %dst.addr, align 8
  %narrow16 = getelementptr inbounds %struct.path_t, ptr %18, i32 0, i32 5
  %19 = load ptr, ptr %narrow16, align 8
  %tobool17 = icmp ne ptr %19, null
  br i1 %tobool17, label %if.then18, label %if.end20

if.then18:                                        ; preds = %land.lhs.true15, %land.lhs.true
  %20 = load ptr, ptr @PyExc_ValueError, align 8
  %21 = load ptr, ptr %function_name, align 8
  %call19 = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %20, ptr noundef @.str.259, ptr noundef %21)
  store ptr null, ptr %retval, align 8
  br label %return

if.end20:                                         ; preds = %land.lhs.true15, %lor.lhs.false
  %call21 = call ptr @PyEval_SaveThread()
  store ptr %call21, ptr %_save, align 8
  %22 = load i32, ptr %dir_fd_specified, align 4
  %tobool22 = icmp ne i32 %22, 0
  br i1 %tobool22, label %if.then23, label %if.else

if.then23:                                        ; preds = %if.end20
  %23 = load i32, ptr %src_dir_fd.addr, align 4
  %24 = load ptr, ptr %src.addr, align 8
  %narrow24 = getelementptr inbounds %struct.path_t, ptr %24, i32 0, i32 5
  %25 = load ptr, ptr %narrow24, align 8
  %26 = load i32, ptr %dst_dir_fd.addr, align 4
  %27 = load ptr, ptr %dst.addr, align 8
  %narrow25 = getelementptr inbounds %struct.path_t, ptr %27, i32 0, i32 5
  %28 = load ptr, ptr %narrow25, align 8
  %call26 = call i32 @renameat(i32 noundef %23, ptr noundef %25, i32 noundef %26, ptr noundef %28) #10
  store i32 %call26, ptr %result, align 4
  br label %if.end30

if.else:                                          ; preds = %if.end20
  %29 = load ptr, ptr %src.addr, align 8
  %narrow27 = getelementptr inbounds %struct.path_t, ptr %29, i32 0, i32 5
  %30 = load ptr, ptr %narrow27, align 8
  %31 = load ptr, ptr %dst.addr, align 8
  %narrow28 = getelementptr inbounds %struct.path_t, ptr %31, i32 0, i32 5
  %32 = load ptr, ptr %narrow28, align 8
  %call29 = call i32 @rename(ptr noundef %30, ptr noundef %32) #10
  store i32 %call29, ptr %result, align 4
  br label %if.end30

if.end30:                                         ; preds = %if.else, %if.then23
  %33 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %33)
  %34 = load i32, ptr %renameat_unavailable, align 4
  %tobool31 = icmp ne i32 %34, 0
  br i1 %tobool31, label %if.then32, label %if.end33

if.then32:                                        ; preds = %if.end30
  %35 = load ptr, ptr %function_name, align 8
  call void @argument_unavailable_error(ptr noundef %35, ptr noundef @.str.260)
  store ptr null, ptr %retval, align 8
  br label %return

if.end33:                                         ; preds = %if.end30
  %36 = load i32, ptr %result, align 4
  %tobool34 = icmp ne i32 %36, 0
  br i1 %tobool34, label %if.then35, label %if.end37

if.then35:                                        ; preds = %if.end33
  %37 = load ptr, ptr %src.addr, align 8
  %38 = load ptr, ptr %dst.addr, align 8
  %call36 = call ptr @path_error2(ptr noundef %37, ptr noundef %38)
  store ptr %call36, ptr %retval, align 8
  br label %return

if.end37:                                         ; preds = %if.end33
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end37, %if.then35, %if.then32, %if.then18, %if.then
  %39 = load ptr, ptr %retval, align 8
  ret ptr %39
}

; Function Attrs: nounwind
declare i32 @renameat(i32 noundef, ptr noundef, i32 noundef, ptr noundef) #4

; Function Attrs: nounwind
declare i32 @rename(ptr noundef, ptr noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_replace_impl(ptr noundef %module, ptr noundef %src, ptr noundef %dst, i32 noundef %src_dir_fd, i32 noundef %dst_dir_fd) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %src.addr = alloca ptr, align 8
  %dst.addr = alloca ptr, align 8
  %src_dir_fd.addr = alloca i32, align 4
  %dst_dir_fd.addr = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %src, ptr %src.addr, align 8
  store ptr %dst, ptr %dst.addr, align 8
  store i32 %src_dir_fd, ptr %src_dir_fd.addr, align 4
  store i32 %dst_dir_fd, ptr %dst_dir_fd.addr, align 4
  %0 = load ptr, ptr %src.addr, align 8
  %1 = load ptr, ptr %dst.addr, align 8
  %2 = load i32, ptr %src_dir_fd.addr, align 4
  %3 = load i32, ptr %dst_dir_fd.addr, align 4
  %call = call ptr @internal_rename(ptr noundef %0, ptr noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef 1)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @os_rmdir_impl(ptr noundef %module, ptr noundef %path, i32 noundef %dir_fd) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %path.addr = alloca ptr, align 8
  %dir_fd.addr = alloca i32, align 4
  %result = alloca i32, align 4
  %unlinkat_unavailable = alloca i32, align 4
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %path, ptr %path.addr, align 8
  store i32 %dir_fd, ptr %dir_fd.addr, align 4
  store i32 0, ptr %unlinkat_unavailable, align 4
  %0 = load ptr, ptr %path.addr, align 8
  %object = getelementptr inbounds %struct.path_t, ptr %0, i32 0, i32 8
  %1 = load ptr, ptr %object, align 8
  %2 = load i32, ptr %dir_fd.addr, align 4
  %cmp = icmp eq i32 %2, -100
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %3 = load i32, ptr %dir_fd.addr, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ -1, %cond.true ], [ %3, %cond.false ]
  %call = call i32 (ptr, ptr, ...) @PySys_Audit(ptr noundef @.str.261, ptr noundef @.str.262, ptr noundef %1, i32 noundef %cond)
  %cmp1 = icmp slt i32 %call, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end
  %call2 = call ptr @PyEval_SaveThread()
  store ptr %call2, ptr %_save, align 8
  %4 = load i32, ptr %dir_fd.addr, align 4
  %cmp3 = icmp ne i32 %4, -100
  br i1 %cmp3, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.end
  %5 = load i32, ptr %dir_fd.addr, align 4
  %6 = load ptr, ptr %path.addr, align 8
  %narrow = getelementptr inbounds %struct.path_t, ptr %6, i32 0, i32 5
  %7 = load ptr, ptr %narrow, align 8
  %call5 = call i32 @unlinkat(i32 noundef %5, ptr noundef %7, i32 noundef 512) #10
  store i32 %call5, ptr %result, align 4
  br label %if.end8

if.else:                                          ; preds = %if.end
  %8 = load ptr, ptr %path.addr, align 8
  %narrow6 = getelementptr inbounds %struct.path_t, ptr %8, i32 0, i32 5
  %9 = load ptr, ptr %narrow6, align 8
  %call7 = call i32 @rmdir(ptr noundef %9) #10
  store i32 %call7, ptr %result, align 4
  br label %if.end8

if.end8:                                          ; preds = %if.else, %if.then4
  %10 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %10)
  %11 = load i32, ptr %unlinkat_unavailable, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end8
  call void @argument_unavailable_error(ptr noundef @.str.39, ptr noundef @.str.184)
  store ptr null, ptr %retval, align 8
  br label %return

if.end10:                                         ; preds = %if.end8
  %12 = load i32, ptr %result, align 4
  %tobool11 = icmp ne i32 %12, 0
  br i1 %tobool11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %if.end10
  %13 = load ptr, ptr %path.addr, align 8
  %call13 = call ptr @path_error(ptr noundef %13)
  store ptr %call13, ptr %retval, align 8
  br label %return

if.end14:                                         ; preds = %if.end10
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end14, %if.then12, %if.then9, %if.then
  %14 = load ptr, ptr %retval, align 8
  ret ptr %14
}

; Function Attrs: nounwind
declare i32 @unlinkat(i32 noundef, ptr noundef, i32 noundef) #4

; Function Attrs: nounwind
declare i32 @rmdir(ptr noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_symlink_impl(ptr noundef %module, ptr noundef %src, ptr noundef %dst, i32 noundef %target_is_directory, i32 noundef %dir_fd) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %src.addr = alloca ptr, align 8
  %dst.addr = alloca ptr, align 8
  %target_is_directory.addr = alloca i32, align 4
  %dir_fd.addr = alloca i32, align 4
  %result = alloca i32, align 4
  %symlinkat_unavailable = alloca i32, align 4
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %src, ptr %src.addr, align 8
  store ptr %dst, ptr %dst.addr, align 8
  store i32 %target_is_directory, ptr %target_is_directory.addr, align 4
  store i32 %dir_fd, ptr %dir_fd.addr, align 4
  store i32 0, ptr %symlinkat_unavailable, align 4
  %0 = load ptr, ptr %src.addr, align 8
  %object = getelementptr inbounds %struct.path_t, ptr %0, i32 0, i32 8
  %1 = load ptr, ptr %object, align 8
  %2 = load ptr, ptr %dst.addr, align 8
  %object1 = getelementptr inbounds %struct.path_t, ptr %2, i32 0, i32 8
  %3 = load ptr, ptr %object1, align 8
  %4 = load i32, ptr %dir_fd.addr, align 4
  %cmp = icmp eq i32 %4, -100
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %5 = load i32, ptr %dir_fd.addr, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ -1, %cond.true ], [ %5, %cond.false ]
  %call = call i32 (ptr, ptr, ...) @PySys_Audit(ptr noundef @.str.264, ptr noundef @.str.265, ptr noundef %1, ptr noundef %3, i32 noundef %cond)
  %cmp2 = icmp slt i32 %call, 0
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end
  %6 = load ptr, ptr %src.addr, align 8
  %narrow = getelementptr inbounds %struct.path_t, ptr %6, i32 0, i32 5
  %7 = load ptr, ptr %narrow, align 8
  %tobool = icmp ne ptr %7, null
  br i1 %tobool, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %if.end
  %8 = load ptr, ptr %dst.addr, align 8
  %wide = getelementptr inbounds %struct.path_t, ptr %8, i32 0, i32 4
  %9 = load ptr, ptr %wide, align 8
  %tobool3 = icmp ne ptr %9, null
  br i1 %tobool3, label %if.then9, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %if.end
  %10 = load ptr, ptr %src.addr, align 8
  %wide4 = getelementptr inbounds %struct.path_t, ptr %10, i32 0, i32 4
  %11 = load ptr, ptr %wide4, align 8
  %tobool5 = icmp ne ptr %11, null
  br i1 %tobool5, label %land.lhs.true6, label %if.end10

land.lhs.true6:                                   ; preds = %lor.lhs.false
  %12 = load ptr, ptr %dst.addr, align 8
  %narrow7 = getelementptr inbounds %struct.path_t, ptr %12, i32 0, i32 5
  %13 = load ptr, ptr %narrow7, align 8
  %tobool8 = icmp ne ptr %13, null
  br i1 %tobool8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %land.lhs.true6, %land.lhs.true
  %14 = load ptr, ptr @PyExc_ValueError, align 8
  call void @PyErr_SetString(ptr noundef %14, ptr noundef @.str.266)
  store ptr null, ptr %retval, align 8
  br label %return

if.end10:                                         ; preds = %land.lhs.true6, %lor.lhs.false
  %call11 = call ptr @PyEval_SaveThread()
  store ptr %call11, ptr %_save, align 8
  %15 = load i32, ptr %dir_fd.addr, align 4
  %cmp12 = icmp ne i32 %15, -100
  br i1 %cmp12, label %if.then13, label %if.else

if.then13:                                        ; preds = %if.end10
  %16 = load ptr, ptr %src.addr, align 8
  %narrow14 = getelementptr inbounds %struct.path_t, ptr %16, i32 0, i32 5
  %17 = load ptr, ptr %narrow14, align 8
  %18 = load i32, ptr %dir_fd.addr, align 4
  %19 = load ptr, ptr %dst.addr, align 8
  %narrow15 = getelementptr inbounds %struct.path_t, ptr %19, i32 0, i32 5
  %20 = load ptr, ptr %narrow15, align 8
  %call16 = call i32 @symlinkat(ptr noundef %17, i32 noundef %18, ptr noundef %20) #10
  store i32 %call16, ptr %result, align 4
  br label %if.end20

if.else:                                          ; preds = %if.end10
  %21 = load ptr, ptr %src.addr, align 8
  %narrow17 = getelementptr inbounds %struct.path_t, ptr %21, i32 0, i32 5
  %22 = load ptr, ptr %narrow17, align 8
  %23 = load ptr, ptr %dst.addr, align 8
  %narrow18 = getelementptr inbounds %struct.path_t, ptr %23, i32 0, i32 5
  %24 = load ptr, ptr %narrow18, align 8
  %call19 = call i32 @symlink(ptr noundef %22, ptr noundef %24) #10
  store i32 %call19, ptr %result, align 4
  br label %if.end20

if.end20:                                         ; preds = %if.else, %if.then13
  %25 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %25)
  %26 = load i32, ptr %symlinkat_unavailable, align 4
  %tobool21 = icmp ne i32 %26, 0
  br i1 %tobool21, label %if.then22, label %if.end23

if.then22:                                        ; preds = %if.end20
  call void @argument_unavailable_error(ptr noundef null, ptr noundef @.str.184)
  store ptr null, ptr %retval, align 8
  br label %return

if.end23:                                         ; preds = %if.end20
  %27 = load i32, ptr %result, align 4
  %tobool24 = icmp ne i32 %27, 0
  br i1 %tobool24, label %if.then25, label %if.end27

if.then25:                                        ; preds = %if.end23
  %28 = load ptr, ptr %src.addr, align 8
  %29 = load ptr, ptr %dst.addr, align 8
  %call26 = call ptr @path_error2(ptr noundef %28, ptr noundef %29)
  store ptr %call26, ptr %retval, align 8
  br label %return

if.end27:                                         ; preds = %if.end23
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end27, %if.then25, %if.then22, %if.then9, %if.then
  %30 = load ptr, ptr %retval, align 8
  ret ptr %30
}

; Function Attrs: nounwind
declare i32 @symlinkat(ptr noundef, i32 noundef, ptr noundef) #4

; Function Attrs: nounwind
declare i32 @symlink(ptr noundef, ptr noundef) #4

; Function Attrs: nounwind uwtable
define internal i64 @os_system_impl(ptr noundef %module, ptr noundef %command) #0 {
entry:
  %retval = alloca i64, align 8
  %module.addr = alloca ptr, align 8
  %command.addr = alloca ptr, align 8
  %result = alloca i64, align 8
  %bytes = alloca ptr, align 8
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %command, ptr %command.addr, align 8
  %0 = load ptr, ptr %command.addr, align 8
  %call = call ptr @PyBytes_AsString(ptr noundef %0)
  store ptr %call, ptr %bytes, align 8
  %1 = load ptr, ptr %command.addr, align 8
  %call1 = call i32 (ptr, ptr, ...) @PySys_Audit(ptr noundef @.str.268, ptr noundef @.str.204, ptr noundef %1)
  %cmp = icmp slt i32 %call1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 -1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %call2 = call ptr @PyEval_SaveThread()
  store ptr %call2, ptr %_save, align 8
  %2 = load ptr, ptr %bytes, align 8
  %call3 = call i32 @system(ptr noundef %2)
  %conv = sext i32 %call3 to i64
  store i64 %conv, ptr %result, align 8
  %3 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %3)
  %4 = load i64, ptr %result, align 8
  store i64 %4, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %5 = load i64, ptr %retval, align 8
  ret i64 %5
}

declare ptr @PyBytes_AsString(ptr noundef) #1

declare i32 @system(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @os_umask_impl(ptr noundef %module, i32 noundef %mask) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %mask.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %mask, ptr %mask.addr, align 4
  %0 = load i32, ptr %mask.addr, align 4
  %call = call i32 @umask(i32 noundef %0) #10
  store i32 %call, ptr %i, align 4
  %1 = load i32, ptr %i, align 4
  %cmp = icmp slt i32 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call ptr @posix_error()
  store ptr %call1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %i, align 4
  %conv = sext i32 %2 to i64
  %call2 = call ptr @PyLong_FromLong(i64 noundef %conv)
  store ptr %call2, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load ptr, ptr %retval, align 8
  ret ptr %3
}

; Function Attrs: nounwind
declare i32 @umask(i32 noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_uname_impl(ptr noundef %module) #0 {
entry:
  %op.addr.i86 = alloca ptr, align 8
  %op.addr.i82 = alloca ptr, align 8
  %op.addr.i78 = alloca ptr, align 8
  %op.addr.i74 = alloca ptr, align 8
  %op.addr.i72 = alloca ptr, align 8
  %op.addr.i63 = alloca ptr, align 8
  %op.addr.i54 = alloca ptr, align 8
  %op.addr.i45 = alloca ptr, align 8
  %op.addr.i36 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %u = alloca %struct.utsname, align 1
  %res = alloca i32, align 4
  %value = alloca ptr, align 8
  %_save = alloca ptr, align 8
  %UnameResultType = alloca ptr, align 8
  %o = alloca ptr, align 8
  %o12 = alloca ptr, align 8
  %o18 = alloca ptr, align 8
  %o24 = alloca ptr, align 8
  %o30 = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  %call = call ptr @PyEval_SaveThread()
  store ptr %call, ptr %_save, align 8
  %call1 = call i32 @uname(ptr noundef %u) #10
  store i32 %call1, ptr %res, align 4
  %0 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %0)
  %1 = load i32, ptr %res, align 4
  %cmp = icmp slt i32 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call2 = call ptr @posix_error()
  store ptr %call2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %module.addr, align 8
  %call3 = call ptr @get_posix_state(ptr noundef %2)
  %UnameResultType4 = getelementptr inbounds %struct._posixstate, ptr %call3, i32 0, i32 9
  %3 = load ptr, ptr %UnameResultType4, align 8
  store ptr %3, ptr %UnameResultType, align 8
  %4 = load ptr, ptr %UnameResultType, align 8
  %call5 = call ptr @PyStructSequence_New(ptr noundef %4)
  store ptr %call5, ptr %value, align 8
  %5 = load ptr, ptr %value, align 8
  %cmp6 = icmp eq ptr %5, null
  br i1 %cmp6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end8:                                          ; preds = %if.end
  %sysname = getelementptr inbounds %struct.utsname, ptr %u, i32 0, i32 0
  %arraydecay = getelementptr inbounds [65 x i8], ptr %sysname, i64 0, i64 0
  %call9 = call ptr @PyUnicode_DecodeFSDefault(ptr noundef %arraydecay)
  store ptr %call9, ptr %o, align 8
  %6 = load ptr, ptr %o, align 8
  %tobool = icmp ne ptr %6, null
  br i1 %tobool, label %if.end11, label %if.then10

if.then10:                                        ; preds = %if.end8
  %7 = load ptr, ptr %value, align 8
  store ptr %7, ptr %op.addr.i63, align 8
  %8 = load ptr, ptr %op.addr.i63, align 8
  store ptr %8, ptr %op.addr.i72, align 8
  %9 = load ptr, ptr %op.addr.i72, align 8
  %10 = load i64, ptr %9, align 8
  %conv.i = trunc i64 %10 to i32
  %cmp.i73 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i73 to i32
  %tobool.i65 = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i65, label %if.then.i70, label %if.end.i66

if.then.i70:                                      ; preds = %if.then10
  br label %Py_DECREF.exit71

if.end.i66:                                       ; preds = %if.then10
  %11 = load ptr, ptr %op.addr.i63, align 8
  %12 = load i64, ptr %11, align 8
  %dec.i67 = add i64 %12, -1
  store i64 %dec.i67, ptr %11, align 8
  %cmp.i68 = icmp eq i64 %dec.i67, 0
  br i1 %cmp.i68, label %if.then1.i69, label %Py_DECREF.exit71

if.then1.i69:                                     ; preds = %if.end.i66
  %13 = load ptr, ptr %op.addr.i63, align 8
  call void @_Py_Dealloc(ptr noundef %13) #10
  br label %Py_DECREF.exit71

Py_DECREF.exit71:                                 ; preds = %if.then1.i69, %if.end.i66, %if.then.i70
  store ptr null, ptr %retval, align 8
  br label %return

if.end11:                                         ; preds = %if.end8
  %14 = load ptr, ptr %value, align 8
  %15 = load ptr, ptr %o, align 8
  call void @PyStructSequence_SetItem(ptr noundef %14, i64 noundef 0, ptr noundef %15)
  %nodename = getelementptr inbounds %struct.utsname, ptr %u, i32 0, i32 1
  %arraydecay13 = getelementptr inbounds [65 x i8], ptr %nodename, i64 0, i64 0
  %call14 = call ptr @PyUnicode_DecodeFSDefault(ptr noundef %arraydecay13)
  store ptr %call14, ptr %o12, align 8
  %16 = load ptr, ptr %o12, align 8
  %tobool15 = icmp ne ptr %16, null
  br i1 %tobool15, label %if.end17, label %if.then16

if.then16:                                        ; preds = %if.end11
  %17 = load ptr, ptr %value, align 8
  store ptr %17, ptr %op.addr.i54, align 8
  %18 = load ptr, ptr %op.addr.i54, align 8
  store ptr %18, ptr %op.addr.i74, align 8
  %19 = load ptr, ptr %op.addr.i74, align 8
  %20 = load i64, ptr %19, align 8
  %conv.i75 = trunc i64 %20 to i32
  %cmp.i76 = icmp slt i32 %conv.i75, 0
  %conv1.i77 = zext i1 %cmp.i76 to i32
  %tobool.i56 = icmp ne i32 %conv1.i77, 0
  br i1 %tobool.i56, label %if.then.i61, label %if.end.i57

if.then.i61:                                      ; preds = %if.then16
  br label %Py_DECREF.exit62

if.end.i57:                                       ; preds = %if.then16
  %21 = load ptr, ptr %op.addr.i54, align 8
  %22 = load i64, ptr %21, align 8
  %dec.i58 = add i64 %22, -1
  store i64 %dec.i58, ptr %21, align 8
  %cmp.i59 = icmp eq i64 %dec.i58, 0
  br i1 %cmp.i59, label %if.then1.i60, label %Py_DECREF.exit62

if.then1.i60:                                     ; preds = %if.end.i57
  %23 = load ptr, ptr %op.addr.i54, align 8
  call void @_Py_Dealloc(ptr noundef %23) #10
  br label %Py_DECREF.exit62

Py_DECREF.exit62:                                 ; preds = %if.then1.i60, %if.end.i57, %if.then.i61
  store ptr null, ptr %retval, align 8
  br label %return

if.end17:                                         ; preds = %if.end11
  %24 = load ptr, ptr %value, align 8
  %25 = load ptr, ptr %o12, align 8
  call void @PyStructSequence_SetItem(ptr noundef %24, i64 noundef 1, ptr noundef %25)
  %release = getelementptr inbounds %struct.utsname, ptr %u, i32 0, i32 2
  %arraydecay19 = getelementptr inbounds [65 x i8], ptr %release, i64 0, i64 0
  %call20 = call ptr @PyUnicode_DecodeFSDefault(ptr noundef %arraydecay19)
  store ptr %call20, ptr %o18, align 8
  %26 = load ptr, ptr %o18, align 8
  %tobool21 = icmp ne ptr %26, null
  br i1 %tobool21, label %if.end23, label %if.then22

if.then22:                                        ; preds = %if.end17
  %27 = load ptr, ptr %value, align 8
  store ptr %27, ptr %op.addr.i45, align 8
  %28 = load ptr, ptr %op.addr.i45, align 8
  store ptr %28, ptr %op.addr.i78, align 8
  %29 = load ptr, ptr %op.addr.i78, align 8
  %30 = load i64, ptr %29, align 8
  %conv.i79 = trunc i64 %30 to i32
  %cmp.i80 = icmp slt i32 %conv.i79, 0
  %conv1.i81 = zext i1 %cmp.i80 to i32
  %tobool.i47 = icmp ne i32 %conv1.i81, 0
  br i1 %tobool.i47, label %if.then.i52, label %if.end.i48

if.then.i52:                                      ; preds = %if.then22
  br label %Py_DECREF.exit53

if.end.i48:                                       ; preds = %if.then22
  %31 = load ptr, ptr %op.addr.i45, align 8
  %32 = load i64, ptr %31, align 8
  %dec.i49 = add i64 %32, -1
  store i64 %dec.i49, ptr %31, align 8
  %cmp.i50 = icmp eq i64 %dec.i49, 0
  br i1 %cmp.i50, label %if.then1.i51, label %Py_DECREF.exit53

if.then1.i51:                                     ; preds = %if.end.i48
  %33 = load ptr, ptr %op.addr.i45, align 8
  call void @_Py_Dealloc(ptr noundef %33) #10
  br label %Py_DECREF.exit53

Py_DECREF.exit53:                                 ; preds = %if.then1.i51, %if.end.i48, %if.then.i52
  store ptr null, ptr %retval, align 8
  br label %return

if.end23:                                         ; preds = %if.end17
  %34 = load ptr, ptr %value, align 8
  %35 = load ptr, ptr %o18, align 8
  call void @PyStructSequence_SetItem(ptr noundef %34, i64 noundef 2, ptr noundef %35)
  %version = getelementptr inbounds %struct.utsname, ptr %u, i32 0, i32 3
  %arraydecay25 = getelementptr inbounds [65 x i8], ptr %version, i64 0, i64 0
  %call26 = call ptr @PyUnicode_DecodeFSDefault(ptr noundef %arraydecay25)
  store ptr %call26, ptr %o24, align 8
  %36 = load ptr, ptr %o24, align 8
  %tobool27 = icmp ne ptr %36, null
  br i1 %tobool27, label %if.end29, label %if.then28

if.then28:                                        ; preds = %if.end23
  %37 = load ptr, ptr %value, align 8
  store ptr %37, ptr %op.addr.i36, align 8
  %38 = load ptr, ptr %op.addr.i36, align 8
  store ptr %38, ptr %op.addr.i82, align 8
  %39 = load ptr, ptr %op.addr.i82, align 8
  %40 = load i64, ptr %39, align 8
  %conv.i83 = trunc i64 %40 to i32
  %cmp.i84 = icmp slt i32 %conv.i83, 0
  %conv1.i85 = zext i1 %cmp.i84 to i32
  %tobool.i38 = icmp ne i32 %conv1.i85, 0
  br i1 %tobool.i38, label %if.then.i43, label %if.end.i39

if.then.i43:                                      ; preds = %if.then28
  br label %Py_DECREF.exit44

if.end.i39:                                       ; preds = %if.then28
  %41 = load ptr, ptr %op.addr.i36, align 8
  %42 = load i64, ptr %41, align 8
  %dec.i40 = add i64 %42, -1
  store i64 %dec.i40, ptr %41, align 8
  %cmp.i41 = icmp eq i64 %dec.i40, 0
  br i1 %cmp.i41, label %if.then1.i42, label %Py_DECREF.exit44

if.then1.i42:                                     ; preds = %if.end.i39
  %43 = load ptr, ptr %op.addr.i36, align 8
  call void @_Py_Dealloc(ptr noundef %43) #10
  br label %Py_DECREF.exit44

Py_DECREF.exit44:                                 ; preds = %if.then1.i42, %if.end.i39, %if.then.i43
  store ptr null, ptr %retval, align 8
  br label %return

if.end29:                                         ; preds = %if.end23
  %44 = load ptr, ptr %value, align 8
  %45 = load ptr, ptr %o24, align 8
  call void @PyStructSequence_SetItem(ptr noundef %44, i64 noundef 3, ptr noundef %45)
  %machine = getelementptr inbounds %struct.utsname, ptr %u, i32 0, i32 4
  %arraydecay31 = getelementptr inbounds [65 x i8], ptr %machine, i64 0, i64 0
  %call32 = call ptr @PyUnicode_DecodeFSDefault(ptr noundef %arraydecay31)
  store ptr %call32, ptr %o30, align 8
  %46 = load ptr, ptr %o30, align 8
  %tobool33 = icmp ne ptr %46, null
  br i1 %tobool33, label %if.end35, label %if.then34

if.then34:                                        ; preds = %if.end29
  %47 = load ptr, ptr %value, align 8
  store ptr %47, ptr %op.addr.i, align 8
  %48 = load ptr, ptr %op.addr.i, align 8
  store ptr %48, ptr %op.addr.i86, align 8
  %49 = load ptr, ptr %op.addr.i86, align 8
  %50 = load i64, ptr %49, align 8
  %conv.i87 = trunc i64 %50 to i32
  %cmp.i88 = icmp slt i32 %conv.i87, 0
  %conv1.i89 = zext i1 %cmp.i88 to i32
  %tobool.i = icmp ne i32 %conv1.i89, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then34
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.then34
  %51 = load ptr, ptr %op.addr.i, align 8
  %52 = load i64, ptr %51, align 8
  %dec.i = add i64 %52, -1
  store i64 %dec.i, ptr %51, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %53 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %53) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  store ptr null, ptr %retval, align 8
  br label %return

if.end35:                                         ; preds = %if.end29
  %54 = load ptr, ptr %value, align 8
  %55 = load ptr, ptr %o30, align 8
  call void @PyStructSequence_SetItem(ptr noundef %54, i64 noundef 4, ptr noundef %55)
  %56 = load ptr, ptr %value, align 8
  store ptr %56, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end35, %Py_DECREF.exit, %Py_DECREF.exit44, %Py_DECREF.exit53, %Py_DECREF.exit62, %Py_DECREF.exit71, %if.then7, %if.then
  %57 = load ptr, ptr %retval, align 8
  ret ptr %57
}

; Function Attrs: nounwind
declare i32 @uname(ptr noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_unlink_impl(ptr noundef %module, ptr noundef %path, i32 noundef %dir_fd) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %path.addr = alloca ptr, align 8
  %dir_fd.addr = alloca i32, align 4
  %result = alloca i32, align 4
  %unlinkat_unavailable = alloca i32, align 4
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %path, ptr %path.addr, align 8
  store i32 %dir_fd, ptr %dir_fd.addr, align 4
  store i32 0, ptr %unlinkat_unavailable, align 4
  %0 = load ptr, ptr %path.addr, align 8
  %object = getelementptr inbounds %struct.path_t, ptr %0, i32 0, i32 8
  %1 = load ptr, ptr %object, align 8
  %2 = load i32, ptr %dir_fd.addr, align 4
  %cmp = icmp eq i32 %2, -100
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %3 = load i32, ptr %dir_fd.addr, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ -1, %cond.true ], [ %3, %cond.false ]
  %call = call i32 (ptr, ptr, ...) @PySys_Audit(ptr noundef @.str.269, ptr noundef @.str.262, ptr noundef %1, i32 noundef %cond)
  %cmp1 = icmp slt i32 %call, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end
  %call2 = call ptr @PyEval_SaveThread()
  store ptr %call2, ptr %_save, align 8
  %4 = load i32, ptr %dir_fd.addr, align 4
  %cmp3 = icmp ne i32 %4, -100
  br i1 %cmp3, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.end
  %5 = load i32, ptr %dir_fd.addr, align 4
  %6 = load ptr, ptr %path.addr, align 8
  %narrow = getelementptr inbounds %struct.path_t, ptr %6, i32 0, i32 5
  %7 = load ptr, ptr %narrow, align 8
  %call5 = call i32 @unlinkat(i32 noundef %5, ptr noundef %7, i32 noundef 0) #10
  store i32 %call5, ptr %result, align 4
  br label %if.end8

if.else:                                          ; preds = %if.end
  %8 = load ptr, ptr %path.addr, align 8
  %narrow6 = getelementptr inbounds %struct.path_t, ptr %8, i32 0, i32 5
  %9 = load ptr, ptr %narrow6, align 8
  %call7 = call i32 @unlink(ptr noundef %9) #10
  store i32 %call7, ptr %result, align 4
  br label %if.end8

if.end8:                                          ; preds = %if.else, %if.then4
  %10 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %10)
  %11 = load i32, ptr %unlinkat_unavailable, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end8
  call void @argument_unavailable_error(ptr noundef null, ptr noundef @.str.184)
  store ptr null, ptr %retval, align 8
  br label %return

if.end10:                                         ; preds = %if.end8
  %12 = load i32, ptr %result, align 4
  %tobool11 = icmp ne i32 %12, 0
  br i1 %tobool11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %if.end10
  %13 = load ptr, ptr %path.addr, align 8
  %call13 = call ptr @path_error(ptr noundef %13)
  store ptr %call13, ptr %retval, align 8
  br label %return

if.end14:                                         ; preds = %if.end10
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end14, %if.then12, %if.then9, %if.then
  %14 = load ptr, ptr %retval, align 8
  ret ptr %14
}

; Function Attrs: nounwind
declare i32 @unlink(ptr noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_remove_impl(ptr noundef %module, ptr noundef %path, i32 noundef %dir_fd) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %path.addr = alloca ptr, align 8
  %dir_fd.addr = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %path, ptr %path.addr, align 8
  store i32 %dir_fd, ptr %dir_fd.addr, align 4
  %0 = load ptr, ptr %module.addr, align 8
  %1 = load ptr, ptr %path.addr, align 8
  %2 = load i32, ptr %dir_fd.addr, align 4
  %call = call ptr @os_unlink_impl(ptr noundef %0, ptr noundef %1, i32 noundef %2)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @os_utime_impl(ptr noundef %module, ptr noundef %path, ptr noundef %times, ptr noundef %ns, i32 noundef %dir_fd, i32 noundef %follow_symlinks) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %path.addr = alloca ptr, align 8
  %times.addr = alloca ptr, align 8
  %ns.addr = alloca ptr, align 8
  %dir_fd.addr = alloca i32, align 4
  %follow_symlinks.addr = alloca i32, align 4
  %result = alloca i32, align 4
  %utime = alloca %struct.utime_t, align 8
  %a_sec = alloca i64, align 8
  %m_sec = alloca i64, align 8
  %a_nsec = alloca i64, align 8
  %m_nsec = alloca i64, align 8
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %path, ptr %path.addr, align 8
  store ptr %times, ptr %times.addr, align 8
  store ptr %ns, ptr %ns.addr, align 8
  store i32 %dir_fd, ptr %dir_fd.addr, align 4
  store i32 %follow_symlinks, ptr %follow_symlinks.addr, align 4
  call void @llvm.memset.p0.i64(ptr align 8 %utime, i8 0, i64 40, i1 false)
  %0 = load ptr, ptr %times.addr, align 8
  %cmp = icmp ne ptr %0, @_Py_NoneStruct
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %ns.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %2 = load ptr, ptr @PyExc_ValueError, align 8
  call void @PyErr_SetString(ptr noundef %2, ptr noundef @.str.271)
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %3 = load ptr, ptr %times.addr, align 8
  %cmp1 = icmp ne ptr %3, @_Py_NoneStruct
  br i1 %cmp1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.end
  %4 = load ptr, ptr %times.addr, align 8
  %call = call i32 @Py_IS_TYPE(ptr noundef %4, ptr noundef @PyTuple_Type)
  %tobool3 = icmp ne i32 %call, 0
  br i1 %tobool3, label %lor.lhs.false, label %if.then6

lor.lhs.false:                                    ; preds = %if.then2
  %5 = load ptr, ptr %times.addr, align 8
  %call4 = call i64 @PyTuple_Size(ptr noundef %5)
  %cmp5 = icmp ne i64 %call4, 2
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %lor.lhs.false, %if.then2
  %6 = load ptr, ptr @PyExc_TypeError, align 8
  call void @PyErr_SetString(ptr noundef %6, ptr noundef @.str.272)
  store ptr null, ptr %retval, align 8
  br label %return

if.end7:                                          ; preds = %lor.lhs.false
  %now = getelementptr inbounds %struct.utime_t, ptr %utime, i32 0, i32 0
  store i32 0, ptr %now, align 8
  %7 = load ptr, ptr %times.addr, align 8
  %ob_item = getelementptr inbounds %struct.PyTupleObject, ptr %7, i32 0, i32 1
  %arrayidx = getelementptr [1 x ptr], ptr %ob_item, i64 0, i64 0
  %8 = load ptr, ptr %arrayidx, align 8
  %call8 = call i32 @_PyTime_ObjectToTimespec(ptr noundef %8, ptr noundef %a_sec, ptr noundef %a_nsec, i32 noundef 0)
  %cmp9 = icmp eq i32 %call8, -1
  br i1 %cmp9, label %if.then15, label %lor.lhs.false10

lor.lhs.false10:                                  ; preds = %if.end7
  %9 = load ptr, ptr %times.addr, align 8
  %ob_item11 = getelementptr inbounds %struct.PyTupleObject, ptr %9, i32 0, i32 1
  %arrayidx12 = getelementptr [1 x ptr], ptr %ob_item11, i64 0, i64 1
  %10 = load ptr, ptr %arrayidx12, align 8
  %call13 = call i32 @_PyTime_ObjectToTimespec(ptr noundef %10, ptr noundef %m_sec, ptr noundef %m_nsec, i32 noundef 0)
  %cmp14 = icmp eq i32 %call13, -1
  br i1 %cmp14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %lor.lhs.false10, %if.end7
  store ptr null, ptr %retval, align 8
  br label %return

if.end16:                                         ; preds = %lor.lhs.false10
  %11 = load i64, ptr %a_sec, align 8
  %atime_s = getelementptr inbounds %struct.utime_t, ptr %utime, i32 0, i32 1
  store i64 %11, ptr %atime_s, align 8
  %12 = load i64, ptr %a_nsec, align 8
  %atime_ns = getelementptr inbounds %struct.utime_t, ptr %utime, i32 0, i32 2
  store i64 %12, ptr %atime_ns, align 8
  %13 = load i64, ptr %m_sec, align 8
  %mtime_s = getelementptr inbounds %struct.utime_t, ptr %utime, i32 0, i32 3
  store i64 %13, ptr %mtime_s, align 8
  %14 = load i64, ptr %m_nsec, align 8
  %mtime_ns = getelementptr inbounds %struct.utime_t, ptr %utime, i32 0, i32 4
  store i64 %14, ptr %mtime_ns, align 8
  br label %if.end45

if.else:                                          ; preds = %if.end
  %15 = load ptr, ptr %ns.addr, align 8
  %tobool17 = icmp ne ptr %15, null
  br i1 %tobool17, label %if.then18, label %if.else42

if.then18:                                        ; preds = %if.else
  %16 = load ptr, ptr %ns.addr, align 8
  %call19 = call i32 @Py_IS_TYPE(ptr noundef %16, ptr noundef @PyTuple_Type)
  %tobool20 = icmp ne i32 %call19, 0
  br i1 %tobool20, label %lor.lhs.false21, label %if.then24

lor.lhs.false21:                                  ; preds = %if.then18
  %17 = load ptr, ptr %ns.addr, align 8
  %call22 = call i64 @PyTuple_Size(ptr noundef %17)
  %cmp23 = icmp ne i64 %call22, 2
  br i1 %cmp23, label %if.then24, label %if.end25

if.then24:                                        ; preds = %lor.lhs.false21, %if.then18
  %18 = load ptr, ptr @PyExc_TypeError, align 8
  call void @PyErr_SetString(ptr noundef %18, ptr noundef @.str.273)
  store ptr null, ptr %retval, align 8
  br label %return

if.end25:                                         ; preds = %lor.lhs.false21
  %now26 = getelementptr inbounds %struct.utime_t, ptr %utime, i32 0, i32 0
  store i32 0, ptr %now26, align 8
  %19 = load ptr, ptr %module.addr, align 8
  %20 = load ptr, ptr %ns.addr, align 8
  %ob_item27 = getelementptr inbounds %struct.PyTupleObject, ptr %20, i32 0, i32 1
  %arrayidx28 = getelementptr [1 x ptr], ptr %ob_item27, i64 0, i64 0
  %21 = load ptr, ptr %arrayidx28, align 8
  %atime_s29 = getelementptr inbounds %struct.utime_t, ptr %utime, i32 0, i32 1
  %atime_ns30 = getelementptr inbounds %struct.utime_t, ptr %utime, i32 0, i32 2
  %call31 = call i32 @split_py_long_to_s_and_ns(ptr noundef %19, ptr noundef %21, ptr noundef %atime_s29, ptr noundef %atime_ns30)
  %tobool32 = icmp ne i32 %call31, 0
  br i1 %tobool32, label %lor.lhs.false33, label %if.then40

lor.lhs.false33:                                  ; preds = %if.end25
  %22 = load ptr, ptr %module.addr, align 8
  %23 = load ptr, ptr %ns.addr, align 8
  %ob_item34 = getelementptr inbounds %struct.PyTupleObject, ptr %23, i32 0, i32 1
  %arrayidx35 = getelementptr [1 x ptr], ptr %ob_item34, i64 0, i64 1
  %24 = load ptr, ptr %arrayidx35, align 8
  %mtime_s36 = getelementptr inbounds %struct.utime_t, ptr %utime, i32 0, i32 3
  %mtime_ns37 = getelementptr inbounds %struct.utime_t, ptr %utime, i32 0, i32 4
  %call38 = call i32 @split_py_long_to_s_and_ns(ptr noundef %22, ptr noundef %24, ptr noundef %mtime_s36, ptr noundef %mtime_ns37)
  %tobool39 = icmp ne i32 %call38, 0
  br i1 %tobool39, label %if.end41, label %if.then40

if.then40:                                        ; preds = %lor.lhs.false33, %if.end25
  store ptr null, ptr %retval, align 8
  br label %return

if.end41:                                         ; preds = %lor.lhs.false33
  br label %if.end44

if.else42:                                        ; preds = %if.else
  %now43 = getelementptr inbounds %struct.utime_t, ptr %utime, i32 0, i32 0
  store i32 1, ptr %now43, align 8
  br label %if.end44

if.end44:                                         ; preds = %if.else42, %if.end41
  br label %if.end45

if.end45:                                         ; preds = %if.end44, %if.end16
  %25 = load ptr, ptr %path.addr, align 8
  %26 = load i32, ptr %dir_fd.addr, align 4
  %call46 = call i32 @path_and_dir_fd_invalid(ptr noundef @.str.46, ptr noundef %25, i32 noundef %26)
  %tobool47 = icmp ne i32 %call46, 0
  br i1 %tobool47, label %if.then55, label %lor.lhs.false48

lor.lhs.false48:                                  ; preds = %if.end45
  %27 = load i32, ptr %dir_fd.addr, align 4
  %28 = load ptr, ptr %path.addr, align 8
  %fd = getelementptr inbounds %struct.path_t, ptr %28, i32 0, i32 6
  %29 = load i32, ptr %fd, align 8
  %call49 = call i32 @dir_fd_and_fd_invalid(ptr noundef @.str.46, i32 noundef %27, i32 noundef %29)
  %tobool50 = icmp ne i32 %call49, 0
  br i1 %tobool50, label %if.then55, label %lor.lhs.false51

lor.lhs.false51:                                  ; preds = %lor.lhs.false48
  %30 = load ptr, ptr %path.addr, align 8
  %fd52 = getelementptr inbounds %struct.path_t, ptr %30, i32 0, i32 6
  %31 = load i32, ptr %fd52, align 8
  %32 = load i32, ptr %follow_symlinks.addr, align 4
  %call53 = call i32 @fd_and_follow_symlinks_invalid(ptr noundef @.str.46, i32 noundef %31, i32 noundef %32)
  %tobool54 = icmp ne i32 %call53, 0
  br i1 %tobool54, label %if.then55, label %if.end56

if.then55:                                        ; preds = %lor.lhs.false51, %lor.lhs.false48, %if.end45
  store ptr null, ptr %retval, align 8
  br label %return

if.end56:                                         ; preds = %lor.lhs.false51
  %33 = load ptr, ptr %path.addr, align 8
  %object = getelementptr inbounds %struct.path_t, ptr %33, i32 0, i32 8
  %34 = load ptr, ptr %object, align 8
  %35 = load ptr, ptr %times.addr, align 8
  %36 = load ptr, ptr %ns.addr, align 8
  %tobool57 = icmp ne ptr %36, null
  br i1 %tobool57, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end56
  %37 = load ptr, ptr %ns.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end56
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %37, %cond.true ], [ @_Py_NoneStruct, %cond.false ]
  %38 = load i32, ptr %dir_fd.addr, align 4
  %cmp58 = icmp eq i32 %38, -100
  br i1 %cmp58, label %cond.true59, label %cond.false60

cond.true59:                                      ; preds = %cond.end
  br label %cond.end61

cond.false60:                                     ; preds = %cond.end
  %39 = load i32, ptr %dir_fd.addr, align 4
  br label %cond.end61

cond.end61:                                       ; preds = %cond.false60, %cond.true59
  %cond62 = phi i32 [ -1, %cond.true59 ], [ %39, %cond.false60 ]
  %call63 = call i32 (ptr, ptr, ...) @PySys_Audit(ptr noundef @.str.274, ptr noundef @.str.275, ptr noundef %34, ptr noundef %35, ptr noundef %cond, i32 noundef %cond62)
  %cmp64 = icmp slt i32 %call63, 0
  br i1 %cmp64, label %if.then65, label %if.end66

if.then65:                                        ; preds = %cond.end61
  store ptr null, ptr %retval, align 8
  br label %return

if.end66:                                         ; preds = %cond.end61
  %call67 = call ptr @PyEval_SaveThread()
  store ptr %call67, ptr %_save, align 8
  %40 = load i32, ptr %follow_symlinks.addr, align 4
  %tobool68 = icmp ne i32 %40, 0
  br i1 %tobool68, label %if.else73, label %land.lhs.true69

land.lhs.true69:                                  ; preds = %if.end66
  %41 = load i32, ptr %dir_fd.addr, align 4
  %cmp70 = icmp eq i32 %41, -100
  br i1 %cmp70, label %if.then71, label %if.else73

if.then71:                                        ; preds = %land.lhs.true69
  %42 = load ptr, ptr %path.addr, align 8
  %narrow = getelementptr inbounds %struct.path_t, ptr %42, i32 0, i32 5
  %43 = load ptr, ptr %narrow, align 8
  %call72 = call i32 @utime_nofollow_symlinks(ptr noundef %utime, ptr noundef %43)
  store i32 %call72, ptr %result, align 4
  br label %if.end91

if.else73:                                        ; preds = %land.lhs.true69, %if.end66
  %44 = load i32, ptr %dir_fd.addr, align 4
  %cmp74 = icmp ne i32 %44, -100
  br i1 %cmp74, label %if.then77, label %lor.lhs.false75

lor.lhs.false75:                                  ; preds = %if.else73
  %45 = load i32, ptr %follow_symlinks.addr, align 4
  %tobool76 = icmp ne i32 %45, 0
  br i1 %tobool76, label %if.else80, label %if.then77

if.then77:                                        ; preds = %lor.lhs.false75, %if.else73
  %46 = load i32, ptr %dir_fd.addr, align 4
  %47 = load ptr, ptr %path.addr, align 8
  %narrow78 = getelementptr inbounds %struct.path_t, ptr %47, i32 0, i32 5
  %48 = load ptr, ptr %narrow78, align 8
  %49 = load i32, ptr %follow_symlinks.addr, align 4
  %call79 = call i32 @utime_dir_fd(ptr noundef %utime, i32 noundef %46, ptr noundef %48, i32 noundef %49)
  store i32 %call79, ptr %result, align 4
  br label %if.end90

if.else80:                                        ; preds = %lor.lhs.false75
  %50 = load ptr, ptr %path.addr, align 8
  %fd81 = getelementptr inbounds %struct.path_t, ptr %50, i32 0, i32 6
  %51 = load i32, ptr %fd81, align 8
  %cmp82 = icmp ne i32 %51, -1
  br i1 %cmp82, label %if.then83, label %if.else86

if.then83:                                        ; preds = %if.else80
  %52 = load ptr, ptr %path.addr, align 8
  %fd84 = getelementptr inbounds %struct.path_t, ptr %52, i32 0, i32 6
  %53 = load i32, ptr %fd84, align 8
  %call85 = call i32 @utime_fd(ptr noundef %utime, i32 noundef %53)
  store i32 %call85, ptr %result, align 4
  br label %if.end89

if.else86:                                        ; preds = %if.else80
  %54 = load ptr, ptr %path.addr, align 8
  %narrow87 = getelementptr inbounds %struct.path_t, ptr %54, i32 0, i32 5
  %55 = load ptr, ptr %narrow87, align 8
  %call88 = call i32 @utime_default(ptr noundef %utime, ptr noundef %55)
  store i32 %call88, ptr %result, align 4
  br label %if.end89

if.end89:                                         ; preds = %if.else86, %if.then83
  br label %if.end90

if.end90:                                         ; preds = %if.end89, %if.then77
  br label %if.end91

if.end91:                                         ; preds = %if.end90, %if.then71
  %56 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %56)
  %57 = load i32, ptr %result, align 4
  %cmp92 = icmp slt i32 %57, 0
  br i1 %cmp92, label %if.then93, label %if.end95

if.then93:                                        ; preds = %if.end91
  %58 = load ptr, ptr %path.addr, align 8
  %call94 = call ptr @path_error(ptr noundef %58)
  store ptr null, ptr %retval, align 8
  br label %return

if.end95:                                         ; preds = %if.end91
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end95, %if.then93, %if.then65, %if.then55, %if.then40, %if.then24, %if.then15, %if.then6, %if.then
  %59 = load ptr, ptr %retval, align 8
  ret ptr %59
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #8

declare i64 @PyTuple_Size(ptr noundef) #1

declare i32 @_PyTime_ObjectToTimespec(ptr noundef, ptr noundef, ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define internal i32 @split_py_long_to_s_and_ns(ptr noundef %module, ptr noundef %py_long, ptr noundef %s, ptr noundef %ns) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %py_long.addr = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %ns.addr = alloca ptr, align 8
  %result = alloca i32, align 4
  %divmod = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %py_long, ptr %py_long.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %ns, ptr %ns.addr, align 8
  store i32 0, ptr %result, align 4
  %0 = load ptr, ptr %py_long.addr, align 8
  %1 = load ptr, ptr %module.addr, align 8
  %call = call ptr @get_posix_state(ptr noundef %1)
  %billion = getelementptr inbounds %struct._posixstate, ptr %call, i32 0, i32 0
  %2 = load ptr, ptr %billion, align 8
  %call1 = call ptr @PyNumber_Divmod(ptr noundef %0, ptr noundef %2)
  store ptr %call1, ptr %divmod, align 8
  %3 = load ptr, ptr %divmod, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %exit

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %divmod, align 8
  %call2 = call ptr @Py_TYPE(ptr noundef %4)
  %call3 = call i32 @PyType_HasFeature(ptr noundef %call2, i64 noundef 67108864)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %lor.lhs.false, label %if.then6

lor.lhs.false:                                    ; preds = %if.end
  %5 = load ptr, ptr %divmod, align 8
  %call5 = call i64 @PyTuple_GET_SIZE(ptr noundef %5)
  %cmp = icmp ne i64 %call5, 2
  br i1 %cmp, label %if.then6, label %if.end12

if.then6:                                         ; preds = %lor.lhs.false, %if.end
  %6 = load ptr, ptr @PyExc_TypeError, align 8
  %7 = load ptr, ptr %py_long.addr, align 8
  %call7 = call ptr @Py_TYPE(ptr noundef %7)
  %call8 = call ptr @_PyType_Name(ptr noundef %call7)
  %8 = load ptr, ptr %divmod, align 8
  %call9 = call ptr @Py_TYPE(ptr noundef %8)
  %call10 = call ptr @_PyType_Name(ptr noundef %call9)
  %call11 = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %6, ptr noundef @.str.276, ptr noundef %call8, ptr noundef %call10)
  br label %exit

if.end12:                                         ; preds = %lor.lhs.false
  %9 = load ptr, ptr %divmod, align 8
  %ob_item = getelementptr inbounds %struct.PyTupleObject, ptr %9, i32 0, i32 1
  %arrayidx = getelementptr [1 x ptr], ptr %ob_item, i64 0, i64 0
  %10 = load ptr, ptr %arrayidx, align 8
  %call13 = call i64 @_PyLong_AsTime_t(ptr noundef %10)
  %11 = load ptr, ptr %s.addr, align 8
  store i64 %call13, ptr %11, align 8
  %12 = load ptr, ptr %s.addr, align 8
  %13 = load i64, ptr %12, align 8
  %cmp14 = icmp eq i64 %13, -1
  br i1 %cmp14, label %land.lhs.true, label %if.end18

land.lhs.true:                                    ; preds = %if.end12
  %call15 = call ptr @PyErr_Occurred()
  %tobool16 = icmp ne ptr %call15, null
  br i1 %tobool16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %land.lhs.true
  br label %exit

if.end18:                                         ; preds = %land.lhs.true, %if.end12
  %14 = load ptr, ptr %divmod, align 8
  %ob_item19 = getelementptr inbounds %struct.PyTupleObject, ptr %14, i32 0, i32 1
  %arrayidx20 = getelementptr [1 x ptr], ptr %ob_item19, i64 0, i64 1
  %15 = load ptr, ptr %arrayidx20, align 8
  %call21 = call i64 @PyLong_AsLong(ptr noundef %15)
  %16 = load ptr, ptr %ns.addr, align 8
  store i64 %call21, ptr %16, align 8
  %17 = load ptr, ptr %ns.addr, align 8
  %18 = load i64, ptr %17, align 8
  %cmp22 = icmp eq i64 %18, -1
  br i1 %cmp22, label %land.lhs.true23, label %if.end27

land.lhs.true23:                                  ; preds = %if.end18
  %call24 = call ptr @PyErr_Occurred()
  %tobool25 = icmp ne ptr %call24, null
  br i1 %tobool25, label %if.then26, label %if.end27

if.then26:                                        ; preds = %land.lhs.true23
  br label %exit

if.end27:                                         ; preds = %land.lhs.true23, %if.end18
  store i32 1, ptr %result, align 4
  br label %exit

exit:                                             ; preds = %if.end27, %if.then26, %if.then17, %if.then6, %if.then
  %19 = load ptr, ptr %divmod, align 8
  call void @Py_XDECREF(ptr noundef %19)
  %20 = load i32, ptr %result, align 4
  ret i32 %20
}

; Function Attrs: nounwind uwtable
define internal i32 @utime_nofollow_symlinks(ptr noundef %ut, ptr noundef %path) #0 {
entry:
  %ut.addr = alloca ptr, align 8
  %path.addr = alloca ptr, align 8
  %ts = alloca [2 x %struct.timespec], align 16
  %time = alloca ptr, align 8
  store ptr %ut, ptr %ut.addr, align 8
  store ptr %path, ptr %path.addr, align 8
  %0 = load ptr, ptr %ut.addr, align 8
  %now = getelementptr inbounds %struct.utime_t, ptr %0, i32 0, i32 0
  %1 = load i32, ptr %now, align 8
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store ptr null, ptr %time, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %2 = load ptr, ptr %ut.addr, align 8
  %atime_s = getelementptr inbounds %struct.utime_t, ptr %2, i32 0, i32 1
  %3 = load i64, ptr %atime_s, align 8
  %arrayidx = getelementptr [2 x %struct.timespec], ptr %ts, i64 0, i64 0
  %tv_sec = getelementptr inbounds %struct.timespec, ptr %arrayidx, i32 0, i32 0
  store i64 %3, ptr %tv_sec, align 16
  %4 = load ptr, ptr %ut.addr, align 8
  %atime_ns = getelementptr inbounds %struct.utime_t, ptr %4, i32 0, i32 2
  %5 = load i64, ptr %atime_ns, align 8
  %arrayidx1 = getelementptr [2 x %struct.timespec], ptr %ts, i64 0, i64 0
  %tv_nsec = getelementptr inbounds %struct.timespec, ptr %arrayidx1, i32 0, i32 1
  store i64 %5, ptr %tv_nsec, align 8
  %6 = load ptr, ptr %ut.addr, align 8
  %mtime_s = getelementptr inbounds %struct.utime_t, ptr %6, i32 0, i32 3
  %7 = load i64, ptr %mtime_s, align 8
  %arrayidx2 = getelementptr [2 x %struct.timespec], ptr %ts, i64 0, i64 1
  %tv_sec3 = getelementptr inbounds %struct.timespec, ptr %arrayidx2, i32 0, i32 0
  store i64 %7, ptr %tv_sec3, align 16
  %8 = load ptr, ptr %ut.addr, align 8
  %mtime_ns = getelementptr inbounds %struct.utime_t, ptr %8, i32 0, i32 4
  %9 = load i64, ptr %mtime_ns, align 8
  %arrayidx4 = getelementptr [2 x %struct.timespec], ptr %ts, i64 0, i64 1
  %tv_nsec5 = getelementptr inbounds %struct.timespec, ptr %arrayidx4, i32 0, i32 1
  store i64 %9, ptr %tv_nsec5, align 8
  %arraydecay = getelementptr inbounds [2 x %struct.timespec], ptr %ts, i64 0, i64 0
  store ptr %arraydecay, ptr %time, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %10 = load ptr, ptr %path.addr, align 8
  %11 = load ptr, ptr %time, align 8
  %call = call i32 @utimensat(i32 noundef -100, ptr noundef %10, ptr noundef %11, i32 noundef 256) #10
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @utime_dir_fd(ptr noundef %ut, i32 noundef %dir_fd, ptr noundef %path, i32 noundef %follow_symlinks) #0 {
entry:
  %ut.addr = alloca ptr, align 8
  %dir_fd.addr = alloca i32, align 4
  %path.addr = alloca ptr, align 8
  %follow_symlinks.addr = alloca i32, align 4
  %flags = alloca i32, align 4
  %ts = alloca [2 x %struct.timespec], align 16
  %time = alloca ptr, align 8
  store ptr %ut, ptr %ut.addr, align 8
  store i32 %dir_fd, ptr %dir_fd.addr, align 4
  store ptr %path, ptr %path.addr, align 8
  store i32 %follow_symlinks, ptr %follow_symlinks.addr, align 4
  %0 = load i32, ptr %follow_symlinks.addr, align 4
  %tobool = icmp ne i32 %0, 0
  %cond = select i1 %tobool, i32 0, i32 256
  store i32 %cond, ptr %flags, align 4
  %1 = load ptr, ptr %ut.addr, align 8
  %now = getelementptr inbounds %struct.utime_t, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %now, align 8
  %tobool1 = icmp ne i32 %2, 0
  br i1 %tobool1, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store ptr null, ptr %time, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %3 = load ptr, ptr %ut.addr, align 8
  %atime_s = getelementptr inbounds %struct.utime_t, ptr %3, i32 0, i32 1
  %4 = load i64, ptr %atime_s, align 8
  %arrayidx = getelementptr [2 x %struct.timespec], ptr %ts, i64 0, i64 0
  %tv_sec = getelementptr inbounds %struct.timespec, ptr %arrayidx, i32 0, i32 0
  store i64 %4, ptr %tv_sec, align 16
  %5 = load ptr, ptr %ut.addr, align 8
  %atime_ns = getelementptr inbounds %struct.utime_t, ptr %5, i32 0, i32 2
  %6 = load i64, ptr %atime_ns, align 8
  %arrayidx2 = getelementptr [2 x %struct.timespec], ptr %ts, i64 0, i64 0
  %tv_nsec = getelementptr inbounds %struct.timespec, ptr %arrayidx2, i32 0, i32 1
  store i64 %6, ptr %tv_nsec, align 8
  %7 = load ptr, ptr %ut.addr, align 8
  %mtime_s = getelementptr inbounds %struct.utime_t, ptr %7, i32 0, i32 3
  %8 = load i64, ptr %mtime_s, align 8
  %arrayidx3 = getelementptr [2 x %struct.timespec], ptr %ts, i64 0, i64 1
  %tv_sec4 = getelementptr inbounds %struct.timespec, ptr %arrayidx3, i32 0, i32 0
  store i64 %8, ptr %tv_sec4, align 16
  %9 = load ptr, ptr %ut.addr, align 8
  %mtime_ns = getelementptr inbounds %struct.utime_t, ptr %9, i32 0, i32 4
  %10 = load i64, ptr %mtime_ns, align 8
  %arrayidx5 = getelementptr [2 x %struct.timespec], ptr %ts, i64 0, i64 1
  %tv_nsec6 = getelementptr inbounds %struct.timespec, ptr %arrayidx5, i32 0, i32 1
  store i64 %10, ptr %tv_nsec6, align 8
  %arraydecay = getelementptr inbounds [2 x %struct.timespec], ptr %ts, i64 0, i64 0
  store ptr %arraydecay, ptr %time, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %11 = load i32, ptr %dir_fd.addr, align 4
  %12 = load ptr, ptr %path.addr, align 8
  %13 = load ptr, ptr %time, align 8
  %14 = load i32, ptr %flags, align 4
  %call = call i32 @utimensat(i32 noundef %11, ptr noundef %12, ptr noundef %13, i32 noundef %14) #10
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @utime_fd(ptr noundef %ut, i32 noundef %fd) #0 {
entry:
  %ut.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %ts = alloca [2 x %struct.timespec], align 16
  %time = alloca ptr, align 8
  store ptr %ut, ptr %ut.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  %0 = load ptr, ptr %ut.addr, align 8
  %now = getelementptr inbounds %struct.utime_t, ptr %0, i32 0, i32 0
  %1 = load i32, ptr %now, align 8
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store ptr null, ptr %time, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %2 = load ptr, ptr %ut.addr, align 8
  %atime_s = getelementptr inbounds %struct.utime_t, ptr %2, i32 0, i32 1
  %3 = load i64, ptr %atime_s, align 8
  %arrayidx = getelementptr [2 x %struct.timespec], ptr %ts, i64 0, i64 0
  %tv_sec = getelementptr inbounds %struct.timespec, ptr %arrayidx, i32 0, i32 0
  store i64 %3, ptr %tv_sec, align 16
  %4 = load ptr, ptr %ut.addr, align 8
  %atime_ns = getelementptr inbounds %struct.utime_t, ptr %4, i32 0, i32 2
  %5 = load i64, ptr %atime_ns, align 8
  %arrayidx1 = getelementptr [2 x %struct.timespec], ptr %ts, i64 0, i64 0
  %tv_nsec = getelementptr inbounds %struct.timespec, ptr %arrayidx1, i32 0, i32 1
  store i64 %5, ptr %tv_nsec, align 8
  %6 = load ptr, ptr %ut.addr, align 8
  %mtime_s = getelementptr inbounds %struct.utime_t, ptr %6, i32 0, i32 3
  %7 = load i64, ptr %mtime_s, align 8
  %arrayidx2 = getelementptr [2 x %struct.timespec], ptr %ts, i64 0, i64 1
  %tv_sec3 = getelementptr inbounds %struct.timespec, ptr %arrayidx2, i32 0, i32 0
  store i64 %7, ptr %tv_sec3, align 16
  %8 = load ptr, ptr %ut.addr, align 8
  %mtime_ns = getelementptr inbounds %struct.utime_t, ptr %8, i32 0, i32 4
  %9 = load i64, ptr %mtime_ns, align 8
  %arrayidx4 = getelementptr [2 x %struct.timespec], ptr %ts, i64 0, i64 1
  %tv_nsec5 = getelementptr inbounds %struct.timespec, ptr %arrayidx4, i32 0, i32 1
  store i64 %9, ptr %tv_nsec5, align 8
  %arraydecay = getelementptr inbounds [2 x %struct.timespec], ptr %ts, i64 0, i64 0
  store ptr %arraydecay, ptr %time, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %10 = load i32, ptr %fd.addr, align 4
  %11 = load ptr, ptr %time, align 8
  %call = call i32 @futimens(i32 noundef %10, ptr noundef %11) #10
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @utime_default(ptr noundef %ut, ptr noundef %path) #0 {
entry:
  %ut.addr = alloca ptr, align 8
  %path.addr = alloca ptr, align 8
  %ts = alloca [2 x %struct.timespec], align 16
  %time = alloca ptr, align 8
  store ptr %ut, ptr %ut.addr, align 8
  store ptr %path, ptr %path.addr, align 8
  %0 = load ptr, ptr %ut.addr, align 8
  %now = getelementptr inbounds %struct.utime_t, ptr %0, i32 0, i32 0
  %1 = load i32, ptr %now, align 8
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store ptr null, ptr %time, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %2 = load ptr, ptr %ut.addr, align 8
  %atime_s = getelementptr inbounds %struct.utime_t, ptr %2, i32 0, i32 1
  %3 = load i64, ptr %atime_s, align 8
  %arrayidx = getelementptr [2 x %struct.timespec], ptr %ts, i64 0, i64 0
  %tv_sec = getelementptr inbounds %struct.timespec, ptr %arrayidx, i32 0, i32 0
  store i64 %3, ptr %tv_sec, align 16
  %4 = load ptr, ptr %ut.addr, align 8
  %atime_ns = getelementptr inbounds %struct.utime_t, ptr %4, i32 0, i32 2
  %5 = load i64, ptr %atime_ns, align 8
  %arrayidx1 = getelementptr [2 x %struct.timespec], ptr %ts, i64 0, i64 0
  %tv_nsec = getelementptr inbounds %struct.timespec, ptr %arrayidx1, i32 0, i32 1
  store i64 %5, ptr %tv_nsec, align 8
  %6 = load ptr, ptr %ut.addr, align 8
  %mtime_s = getelementptr inbounds %struct.utime_t, ptr %6, i32 0, i32 3
  %7 = load i64, ptr %mtime_s, align 8
  %arrayidx2 = getelementptr [2 x %struct.timespec], ptr %ts, i64 0, i64 1
  %tv_sec3 = getelementptr inbounds %struct.timespec, ptr %arrayidx2, i32 0, i32 0
  store i64 %7, ptr %tv_sec3, align 16
  %8 = load ptr, ptr %ut.addr, align 8
  %mtime_ns = getelementptr inbounds %struct.utime_t, ptr %8, i32 0, i32 4
  %9 = load i64, ptr %mtime_ns, align 8
  %arrayidx4 = getelementptr [2 x %struct.timespec], ptr %ts, i64 0, i64 1
  %tv_nsec5 = getelementptr inbounds %struct.timespec, ptr %arrayidx4, i32 0, i32 1
  store i64 %9, ptr %tv_nsec5, align 8
  %arraydecay = getelementptr inbounds [2 x %struct.timespec], ptr %ts, i64 0, i64 0
  store ptr %arraydecay, ptr %time, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %10 = load ptr, ptr %path.addr, align 8
  %11 = load ptr, ptr %time, align 8
  %call = call i32 @utimensat(i32 noundef -100, ptr noundef %10, ptr noundef %11, i32 noundef 0) #10
  ret i32 %call
}

declare ptr @PyNumber_Divmod(ptr noundef, ptr noundef) #1

declare i64 @_PyLong_AsTime_t(ptr noundef) #1

; Function Attrs: nounwind
declare i32 @utimensat(i32 noundef, ptr noundef, ptr noundef, i32 noundef) #4

; Function Attrs: nounwind
declare i32 @futimens(i32 noundef, ptr noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_times_impl(ptr noundef %module) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %state = alloca ptr, align 8
  %ticks_per_second = alloca i64, align 8
  %process = alloca %struct.tms, align 8
  %elapsed = alloca i64, align 8
  store ptr %module, ptr %module.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %call = call ptr @get_posix_state(ptr noundef %0)
  store ptr %call, ptr %state, align 8
  %1 = load ptr, ptr %state, align 8
  %ticks_per_second1 = getelementptr inbounds %struct._posixstate, ptr %1, i32 0, i32 13
  %2 = load i64, ptr %ticks_per_second1, align 8
  store i64 %2, ptr %ticks_per_second, align 8
  %call2 = call ptr @__errno_location() #12
  store i32 0, ptr %call2, align 4
  %call3 = call i64 @times(ptr noundef %process) #10
  store i64 %call3, ptr %elapsed, align 8
  %3 = load i64, ptr %elapsed, align 8
  %cmp = icmp eq i64 %3, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call4 = call ptr @posix_error()
  store ptr %call4, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %module.addr, align 8
  %tms_utime = getelementptr inbounds %struct.tms, ptr %process, i32 0, i32 0
  %5 = load i64, ptr %tms_utime, align 8
  %conv = sitofp i64 %5 to double
  %6 = load i64, ptr %ticks_per_second, align 8
  %conv5 = sitofp i64 %6 to double
  %div = fdiv double %conv, %conv5
  %tms_stime = getelementptr inbounds %struct.tms, ptr %process, i32 0, i32 1
  %7 = load i64, ptr %tms_stime, align 8
  %conv6 = sitofp i64 %7 to double
  %8 = load i64, ptr %ticks_per_second, align 8
  %conv7 = sitofp i64 %8 to double
  %div8 = fdiv double %conv6, %conv7
  %tms_cutime = getelementptr inbounds %struct.tms, ptr %process, i32 0, i32 2
  %9 = load i64, ptr %tms_cutime, align 8
  %conv9 = sitofp i64 %9 to double
  %10 = load i64, ptr %ticks_per_second, align 8
  %conv10 = sitofp i64 %10 to double
  %div11 = fdiv double %conv9, %conv10
  %tms_cstime = getelementptr inbounds %struct.tms, ptr %process, i32 0, i32 3
  %11 = load i64, ptr %tms_cstime, align 8
  %conv12 = sitofp i64 %11 to double
  %12 = load i64, ptr %ticks_per_second, align 8
  %conv13 = sitofp i64 %12 to double
  %div14 = fdiv double %conv12, %conv13
  %13 = load i64, ptr %elapsed, align 8
  %conv15 = sitofp i64 %13 to double
  %14 = load i64, ptr %ticks_per_second, align 8
  %conv16 = sitofp i64 %14 to double
  %div17 = fdiv double %conv15, %conv16
  %call18 = call ptr @build_times_result(ptr noundef %4, double noundef %div, double noundef %div8, double noundef %div11, double noundef %div14, double noundef %div17)
  store ptr %call18, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %15 = load ptr, ptr %retval, align 8
  ret ptr %15
}

; Function Attrs: nounwind
declare i64 @times(ptr noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @build_times_result(ptr noundef %module, double noundef %user, double noundef %system, double noundef %children_user, double noundef %children_system, double noundef %elapsed) #0 {
entry:
  %op.addr.i76 = alloca ptr, align 8
  %op.addr.i72 = alloca ptr, align 8
  %op.addr.i68 = alloca ptr, align 8
  %op.addr.i64 = alloca ptr, align 8
  %op.addr.i62 = alloca ptr, align 8
  %op.addr.i53 = alloca ptr, align 8
  %op.addr.i44 = alloca ptr, align 8
  %op.addr.i35 = alloca ptr, align 8
  %op.addr.i26 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %user.addr = alloca double, align 8
  %system.addr = alloca double, align 8
  %children_user.addr = alloca double, align 8
  %children_system.addr = alloca double, align 8
  %elapsed.addr = alloca double, align 8
  %TimesResultType = alloca ptr, align 8
  %value = alloca ptr, align 8
  %o = alloca ptr, align 8
  %o6 = alloca ptr, align 8
  %o11 = alloca ptr, align 8
  %o16 = alloca ptr, align 8
  %o21 = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store double %user, ptr %user.addr, align 8
  store double %system, ptr %system.addr, align 8
  store double %children_user, ptr %children_user.addr, align 8
  store double %children_system, ptr %children_system.addr, align 8
  store double %elapsed, ptr %elapsed.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %call = call ptr @get_posix_state(ptr noundef %0)
  %TimesResultType1 = getelementptr inbounds %struct._posixstate, ptr %call, i32 0, i32 8
  %1 = load ptr, ptr %TimesResultType1, align 8
  store ptr %1, ptr %TimesResultType, align 8
  %2 = load ptr, ptr %TimesResultType, align 8
  %call2 = call ptr @PyStructSequence_New(ptr noundef %2)
  store ptr %call2, ptr %value, align 8
  %3 = load ptr, ptr %value, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %4 = load double, ptr %user.addr, align 8
  %call3 = call ptr @PyFloat_FromDouble(double noundef %4)
  store ptr %call3, ptr %o, align 8
  %5 = load ptr, ptr %o, align 8
  %tobool = icmp ne ptr %5, null
  br i1 %tobool, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.end
  %6 = load ptr, ptr %value, align 8
  store ptr %6, ptr %op.addr.i53, align 8
  %7 = load ptr, ptr %op.addr.i53, align 8
  store ptr %7, ptr %op.addr.i62, align 8
  %8 = load ptr, ptr %op.addr.i62, align 8
  %9 = load i64, ptr %8, align 8
  %conv.i = trunc i64 %9 to i32
  %cmp.i63 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i63 to i32
  %tobool.i55 = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i55, label %if.then.i60, label %if.end.i56

if.then.i60:                                      ; preds = %if.then4
  br label %Py_DECREF.exit61

if.end.i56:                                       ; preds = %if.then4
  %10 = load ptr, ptr %op.addr.i53, align 8
  %11 = load i64, ptr %10, align 8
  %dec.i57 = add i64 %11, -1
  store i64 %dec.i57, ptr %10, align 8
  %cmp.i58 = icmp eq i64 %dec.i57, 0
  br i1 %cmp.i58, label %if.then1.i59, label %Py_DECREF.exit61

if.then1.i59:                                     ; preds = %if.end.i56
  %12 = load ptr, ptr %op.addr.i53, align 8
  call void @_Py_Dealloc(ptr noundef %12) #10
  br label %Py_DECREF.exit61

Py_DECREF.exit61:                                 ; preds = %if.then1.i59, %if.end.i56, %if.then.i60
  store ptr null, ptr %retval, align 8
  br label %return

if.end5:                                          ; preds = %if.end
  %13 = load ptr, ptr %value, align 8
  %14 = load ptr, ptr %o, align 8
  call void @PyStructSequence_SetItem(ptr noundef %13, i64 noundef 0, ptr noundef %14)
  %15 = load double, ptr %system.addr, align 8
  %call7 = call ptr @PyFloat_FromDouble(double noundef %15)
  store ptr %call7, ptr %o6, align 8
  %16 = load ptr, ptr %o6, align 8
  %tobool8 = icmp ne ptr %16, null
  br i1 %tobool8, label %if.end10, label %if.then9

if.then9:                                         ; preds = %if.end5
  %17 = load ptr, ptr %value, align 8
  store ptr %17, ptr %op.addr.i44, align 8
  %18 = load ptr, ptr %op.addr.i44, align 8
  store ptr %18, ptr %op.addr.i64, align 8
  %19 = load ptr, ptr %op.addr.i64, align 8
  %20 = load i64, ptr %19, align 8
  %conv.i65 = trunc i64 %20 to i32
  %cmp.i66 = icmp slt i32 %conv.i65, 0
  %conv1.i67 = zext i1 %cmp.i66 to i32
  %tobool.i46 = icmp ne i32 %conv1.i67, 0
  br i1 %tobool.i46, label %if.then.i51, label %if.end.i47

if.then.i51:                                      ; preds = %if.then9
  br label %Py_DECREF.exit52

if.end.i47:                                       ; preds = %if.then9
  %21 = load ptr, ptr %op.addr.i44, align 8
  %22 = load i64, ptr %21, align 8
  %dec.i48 = add i64 %22, -1
  store i64 %dec.i48, ptr %21, align 8
  %cmp.i49 = icmp eq i64 %dec.i48, 0
  br i1 %cmp.i49, label %if.then1.i50, label %Py_DECREF.exit52

if.then1.i50:                                     ; preds = %if.end.i47
  %23 = load ptr, ptr %op.addr.i44, align 8
  call void @_Py_Dealloc(ptr noundef %23) #10
  br label %Py_DECREF.exit52

Py_DECREF.exit52:                                 ; preds = %if.then1.i50, %if.end.i47, %if.then.i51
  store ptr null, ptr %retval, align 8
  br label %return

if.end10:                                         ; preds = %if.end5
  %24 = load ptr, ptr %value, align 8
  %25 = load ptr, ptr %o6, align 8
  call void @PyStructSequence_SetItem(ptr noundef %24, i64 noundef 1, ptr noundef %25)
  %26 = load double, ptr %children_user.addr, align 8
  %call12 = call ptr @PyFloat_FromDouble(double noundef %26)
  store ptr %call12, ptr %o11, align 8
  %27 = load ptr, ptr %o11, align 8
  %tobool13 = icmp ne ptr %27, null
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end10
  %28 = load ptr, ptr %value, align 8
  store ptr %28, ptr %op.addr.i35, align 8
  %29 = load ptr, ptr %op.addr.i35, align 8
  store ptr %29, ptr %op.addr.i68, align 8
  %30 = load ptr, ptr %op.addr.i68, align 8
  %31 = load i64, ptr %30, align 8
  %conv.i69 = trunc i64 %31 to i32
  %cmp.i70 = icmp slt i32 %conv.i69, 0
  %conv1.i71 = zext i1 %cmp.i70 to i32
  %tobool.i37 = icmp ne i32 %conv1.i71, 0
  br i1 %tobool.i37, label %if.then.i42, label %if.end.i38

if.then.i42:                                      ; preds = %if.then14
  br label %Py_DECREF.exit43

if.end.i38:                                       ; preds = %if.then14
  %32 = load ptr, ptr %op.addr.i35, align 8
  %33 = load i64, ptr %32, align 8
  %dec.i39 = add i64 %33, -1
  store i64 %dec.i39, ptr %32, align 8
  %cmp.i40 = icmp eq i64 %dec.i39, 0
  br i1 %cmp.i40, label %if.then1.i41, label %Py_DECREF.exit43

if.then1.i41:                                     ; preds = %if.end.i38
  %34 = load ptr, ptr %op.addr.i35, align 8
  call void @_Py_Dealloc(ptr noundef %34) #10
  br label %Py_DECREF.exit43

Py_DECREF.exit43:                                 ; preds = %if.then1.i41, %if.end.i38, %if.then.i42
  store ptr null, ptr %retval, align 8
  br label %return

if.end15:                                         ; preds = %if.end10
  %35 = load ptr, ptr %value, align 8
  %36 = load ptr, ptr %o11, align 8
  call void @PyStructSequence_SetItem(ptr noundef %35, i64 noundef 2, ptr noundef %36)
  %37 = load double, ptr %children_system.addr, align 8
  %call17 = call ptr @PyFloat_FromDouble(double noundef %37)
  store ptr %call17, ptr %o16, align 8
  %38 = load ptr, ptr %o16, align 8
  %tobool18 = icmp ne ptr %38, null
  br i1 %tobool18, label %if.end20, label %if.then19

if.then19:                                        ; preds = %if.end15
  %39 = load ptr, ptr %value, align 8
  store ptr %39, ptr %op.addr.i26, align 8
  %40 = load ptr, ptr %op.addr.i26, align 8
  store ptr %40, ptr %op.addr.i72, align 8
  %41 = load ptr, ptr %op.addr.i72, align 8
  %42 = load i64, ptr %41, align 8
  %conv.i73 = trunc i64 %42 to i32
  %cmp.i74 = icmp slt i32 %conv.i73, 0
  %conv1.i75 = zext i1 %cmp.i74 to i32
  %tobool.i28 = icmp ne i32 %conv1.i75, 0
  br i1 %tobool.i28, label %if.then.i33, label %if.end.i29

if.then.i33:                                      ; preds = %if.then19
  br label %Py_DECREF.exit34

if.end.i29:                                       ; preds = %if.then19
  %43 = load ptr, ptr %op.addr.i26, align 8
  %44 = load i64, ptr %43, align 8
  %dec.i30 = add i64 %44, -1
  store i64 %dec.i30, ptr %43, align 8
  %cmp.i31 = icmp eq i64 %dec.i30, 0
  br i1 %cmp.i31, label %if.then1.i32, label %Py_DECREF.exit34

if.then1.i32:                                     ; preds = %if.end.i29
  %45 = load ptr, ptr %op.addr.i26, align 8
  call void @_Py_Dealloc(ptr noundef %45) #10
  br label %Py_DECREF.exit34

Py_DECREF.exit34:                                 ; preds = %if.then1.i32, %if.end.i29, %if.then.i33
  store ptr null, ptr %retval, align 8
  br label %return

if.end20:                                         ; preds = %if.end15
  %46 = load ptr, ptr %value, align 8
  %47 = load ptr, ptr %o16, align 8
  call void @PyStructSequence_SetItem(ptr noundef %46, i64 noundef 3, ptr noundef %47)
  %48 = load double, ptr %elapsed.addr, align 8
  %call22 = call ptr @PyFloat_FromDouble(double noundef %48)
  store ptr %call22, ptr %o21, align 8
  %49 = load ptr, ptr %o21, align 8
  %tobool23 = icmp ne ptr %49, null
  br i1 %tobool23, label %if.end25, label %if.then24

if.then24:                                        ; preds = %if.end20
  %50 = load ptr, ptr %value, align 8
  store ptr %50, ptr %op.addr.i, align 8
  %51 = load ptr, ptr %op.addr.i, align 8
  store ptr %51, ptr %op.addr.i76, align 8
  %52 = load ptr, ptr %op.addr.i76, align 8
  %53 = load i64, ptr %52, align 8
  %conv.i77 = trunc i64 %53 to i32
  %cmp.i78 = icmp slt i32 %conv.i77, 0
  %conv1.i79 = zext i1 %cmp.i78 to i32
  %tobool.i = icmp ne i32 %conv1.i79, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then24
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.then24
  %54 = load ptr, ptr %op.addr.i, align 8
  %55 = load i64, ptr %54, align 8
  %dec.i = add i64 %55, -1
  store i64 %dec.i, ptr %54, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %56 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %56) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  store ptr null, ptr %retval, align 8
  br label %return

if.end25:                                         ; preds = %if.end20
  %57 = load ptr, ptr %value, align 8
  %58 = load ptr, ptr %o21, align 8
  call void @PyStructSequence_SetItem(ptr noundef %57, i64 noundef 4, ptr noundef %58)
  %59 = load ptr, ptr %value, align 8
  store ptr %59, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end25, %Py_DECREF.exit, %Py_DECREF.exit34, %Py_DECREF.exit43, %Py_DECREF.exit52, %Py_DECREF.exit61, %if.then
  %60 = load ptr, ptr %retval, align 8
  ret ptr %60
}

; Function Attrs: nounwind uwtable
define internal ptr @os__exit_impl(ptr noundef %module, i32 noundef %status) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %status.addr = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %status, ptr %status.addr, align 4
  %0 = load i32, ptr %status.addr, align 4
  call void @_exit(i32 noundef %0) #11
  unreachable
}

; Function Attrs: noreturn
declare void @_exit(i32 noundef) #2

declare i32 @_PyArg_CheckPositional(ptr noundef, i64 noundef, i64 noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @os_execv_impl(ptr noundef %module, ptr noundef %path, ptr noundef %argv) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %path.addr = alloca ptr, align 8
  %argv.addr = alloca ptr, align 8
  %argvlist = alloca ptr, align 8
  %argc = alloca i64, align 8
  %interp = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %path, ptr %path.addr, align 8
  store ptr %argv, ptr %argv.addr, align 8
  %call = call ptr @_PyInterpreterState_GET()
  store ptr %call, ptr %interp, align 8
  %0 = load ptr, ptr %interp, align 8
  %call1 = call i32 @_PyInterpreterState_HasFeature(ptr noundef %0, i64 noundef 65536)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr @PyExc_RuntimeError, align 8
  call void @PyErr_SetString(ptr noundef %1, ptr noundef @.str.278)
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %argv.addr, align 8
  %call2 = call ptr @Py_TYPE(ptr noundef %2)
  %call3 = call i32 @PyType_HasFeature(ptr noundef %call2, i64 noundef 33554432)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.end9, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %3 = load ptr, ptr %argv.addr, align 8
  %call5 = call ptr @Py_TYPE(ptr noundef %3)
  %call6 = call i32 @PyType_HasFeature(ptr noundef %call5, i64 noundef 67108864)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %land.lhs.true
  %4 = load ptr, ptr @PyExc_TypeError, align 8
  call void @PyErr_SetString(ptr noundef %4, ptr noundef @.str.279)
  store ptr null, ptr %retval, align 8
  br label %return

if.end9:                                          ; preds = %land.lhs.true, %if.end
  %5 = load ptr, ptr %argv.addr, align 8
  %call10 = call i64 @PySequence_Size(ptr noundef %5)
  store i64 %call10, ptr %argc, align 8
  %6 = load i64, ptr %argc, align 8
  %cmp = icmp slt i64 %6, 1
  br i1 %cmp, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end9
  %7 = load ptr, ptr @PyExc_ValueError, align 8
  call void @PyErr_SetString(ptr noundef %7, ptr noundef @.str.280)
  store ptr null, ptr %retval, align 8
  br label %return

if.end12:                                         ; preds = %if.end9
  %8 = load ptr, ptr %argv.addr, align 8
  %call13 = call ptr @parse_arglist(ptr noundef %8, ptr noundef %argc)
  store ptr %call13, ptr %argvlist, align 8
  %9 = load ptr, ptr %argvlist, align 8
  %cmp14 = icmp eq ptr %9, null
  br i1 %cmp14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.end12
  store ptr null, ptr %retval, align 8
  br label %return

if.end16:                                         ; preds = %if.end12
  %10 = load ptr, ptr %argvlist, align 8
  %arrayidx = getelementptr ptr, ptr %10, i64 0
  %11 = load ptr, ptr %arrayidx, align 8
  %arrayidx17 = getelementptr i8, ptr %11, i64 0
  %12 = load i8, ptr %arrayidx17, align 1
  %tobool18 = icmp ne i8 %12, 0
  br i1 %tobool18, label %if.end20, label %if.then19

if.then19:                                        ; preds = %if.end16
  %13 = load ptr, ptr @PyExc_ValueError, align 8
  call void @PyErr_SetString(ptr noundef %13, ptr noundef @.str.281)
  %14 = load ptr, ptr %argvlist, align 8
  %15 = load i64, ptr %argc, align 8
  call void @free_string_array(ptr noundef %14, i64 noundef %15)
  store ptr null, ptr %retval, align 8
  br label %return

if.end20:                                         ; preds = %if.end16
  %16 = load ptr, ptr %path.addr, align 8
  %object = getelementptr inbounds %struct.path_t, ptr %16, i32 0, i32 8
  %17 = load ptr, ptr %object, align 8
  %18 = load ptr, ptr %argv.addr, align 8
  %call21 = call i32 (ptr, ptr, ...) @PySys_Audit(ptr noundef @.str.282, ptr noundef @.str.240, ptr noundef %17, ptr noundef %18, ptr noundef @_Py_NoneStruct)
  %cmp22 = icmp slt i32 %call21, 0
  br i1 %cmp22, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.end20
  %19 = load ptr, ptr %argvlist, align 8
  %20 = load i64, ptr %argc, align 8
  call void @free_string_array(ptr noundef %19, i64 noundef %20)
  store ptr null, ptr %retval, align 8
  br label %return

if.end24:                                         ; preds = %if.end20
  %21 = load ptr, ptr %path.addr, align 8
  %narrow = getelementptr inbounds %struct.path_t, ptr %21, i32 0, i32 5
  %22 = load ptr, ptr %narrow, align 8
  %23 = load ptr, ptr %argvlist, align 8
  %call25 = call i32 @execv(ptr noundef %22, ptr noundef %23) #10
  %call26 = call ptr @posix_error()
  %24 = load ptr, ptr %argvlist, align 8
  %25 = load i64, ptr %argc, align 8
  call void @free_string_array(ptr noundef %24, i64 noundef %25)
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end24, %if.then23, %if.then19, %if.then15, %if.then11, %if.then8, %if.then
  %26 = load ptr, ptr %retval, align 8
  ret ptr %26
}

declare i32 @_PyInterpreterState_HasFeature(ptr noundef, i64 noundef) #1

; Function Attrs: nounwind
declare i32 @execv(ptr noundef, ptr noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_execve_impl(ptr noundef %module, ptr noundef %path, ptr noundef %argv, ptr noundef %env) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %path.addr = alloca ptr, align 8
  %argv.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %argvlist = alloca ptr, align 8
  %envlist = alloca ptr, align 8
  %argc = alloca i64, align 8
  %envc = alloca i64, align 8
  %interp = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %path, ptr %path.addr, align 8
  store ptr %argv, ptr %argv.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store ptr null, ptr %argvlist, align 8
  %call = call ptr @_PyInterpreterState_GET()
  store ptr %call, ptr %interp, align 8
  %0 = load ptr, ptr %interp, align 8
  %call1 = call i32 @_PyInterpreterState_HasFeature(ptr noundef %0, i64 noundef 65536)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr @PyExc_RuntimeError, align 8
  call void @PyErr_SetString(ptr noundef %1, ptr noundef @.str.278)
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %argv.addr, align 8
  %call2 = call ptr @Py_TYPE(ptr noundef %2)
  %call3 = call i32 @PyType_HasFeature(ptr noundef %call2, i64 noundef 33554432)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.end9, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %3 = load ptr, ptr %argv.addr, align 8
  %call5 = call ptr @Py_TYPE(ptr noundef %3)
  %call6 = call i32 @PyType_HasFeature(ptr noundef %call5, i64 noundef 67108864)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %land.lhs.true
  %4 = load ptr, ptr @PyExc_TypeError, align 8
  call void @PyErr_SetString(ptr noundef %4, ptr noundef @.str.285)
  br label %fail_0

if.end9:                                          ; preds = %land.lhs.true, %if.end
  %5 = load ptr, ptr %argv.addr, align 8
  %call10 = call i64 @PySequence_Size(ptr noundef %5)
  store i64 %call10, ptr %argc, align 8
  %6 = load i64, ptr %argc, align 8
  %cmp = icmp slt i64 %6, 1
  br i1 %cmp, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end9
  %7 = load ptr, ptr @PyExc_ValueError, align 8
  call void @PyErr_SetString(ptr noundef %7, ptr noundef @.str.286)
  store ptr null, ptr %retval, align 8
  br label %return

if.end12:                                         ; preds = %if.end9
  %8 = load ptr, ptr %env.addr, align 8
  %call13 = call i32 @PyMapping_Check(ptr noundef %8)
  %tobool14 = icmp ne i32 %call13, 0
  br i1 %tobool14, label %if.end16, label %if.then15

if.then15:                                        ; preds = %if.end12
  %9 = load ptr, ptr @PyExc_TypeError, align 8
  call void @PyErr_SetString(ptr noundef %9, ptr noundef @.str.287)
  br label %fail_0

if.end16:                                         ; preds = %if.end12
  %10 = load ptr, ptr %argv.addr, align 8
  %call17 = call ptr @parse_arglist(ptr noundef %10, ptr noundef %argc)
  store ptr %call17, ptr %argvlist, align 8
  %11 = load ptr, ptr %argvlist, align 8
  %cmp18 = icmp eq ptr %11, null
  br i1 %cmp18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %if.end16
  br label %fail_0

if.end20:                                         ; preds = %if.end16
  %12 = load ptr, ptr %argvlist, align 8
  %arrayidx = getelementptr ptr, ptr %12, i64 0
  %13 = load ptr, ptr %arrayidx, align 8
  %arrayidx21 = getelementptr i8, ptr %13, i64 0
  %14 = load i8, ptr %arrayidx21, align 1
  %tobool22 = icmp ne i8 %14, 0
  br i1 %tobool22, label %if.end24, label %if.then23

if.then23:                                        ; preds = %if.end20
  %15 = load ptr, ptr @PyExc_ValueError, align 8
  call void @PyErr_SetString(ptr noundef %15, ptr noundef @.str.288)
  br label %fail_0

if.end24:                                         ; preds = %if.end20
  %16 = load ptr, ptr %env.addr, align 8
  %call25 = call ptr @parse_envlist(ptr noundef %16, ptr noundef %envc)
  store ptr %call25, ptr %envlist, align 8
  %17 = load ptr, ptr %envlist, align 8
  %cmp26 = icmp eq ptr %17, null
  br i1 %cmp26, label %if.then27, label %if.end28

if.then27:                                        ; preds = %if.end24
  br label %fail_0

if.end28:                                         ; preds = %if.end24
  %18 = load ptr, ptr %path.addr, align 8
  %object = getelementptr inbounds %struct.path_t, ptr %18, i32 0, i32 8
  %19 = load ptr, ptr %object, align 8
  %20 = load ptr, ptr %argv.addr, align 8
  %21 = load ptr, ptr %env.addr, align 8
  %call29 = call i32 (ptr, ptr, ...) @PySys_Audit(ptr noundef @.str.282, ptr noundef @.str.240, ptr noundef %19, ptr noundef %20, ptr noundef %21)
  %cmp30 = icmp slt i32 %call29, 0
  br i1 %cmp30, label %if.then31, label %if.end32

if.then31:                                        ; preds = %if.end28
  br label %fail_1

if.end32:                                         ; preds = %if.end28
  %22 = load ptr, ptr %path.addr, align 8
  %fd = getelementptr inbounds %struct.path_t, ptr %22, i32 0, i32 6
  %23 = load i32, ptr %fd, align 8
  %cmp33 = icmp sgt i32 %23, -1
  br i1 %cmp33, label %if.then34, label %if.else

if.then34:                                        ; preds = %if.end32
  %24 = load ptr, ptr %path.addr, align 8
  %fd35 = getelementptr inbounds %struct.path_t, ptr %24, i32 0, i32 6
  %25 = load i32, ptr %fd35, align 8
  %26 = load ptr, ptr %argvlist, align 8
  %27 = load ptr, ptr %envlist, align 8
  %call36 = call i32 @fexecve(i32 noundef %25, ptr noundef %26, ptr noundef %27) #10
  br label %if.end38

if.else:                                          ; preds = %if.end32
  %28 = load ptr, ptr %path.addr, align 8
  %narrow = getelementptr inbounds %struct.path_t, ptr %28, i32 0, i32 5
  %29 = load ptr, ptr %narrow, align 8
  %30 = load ptr, ptr %argvlist, align 8
  %31 = load ptr, ptr %envlist, align 8
  %call37 = call i32 @execve(ptr noundef %29, ptr noundef %30, ptr noundef %31) #10
  br label %if.end38

if.end38:                                         ; preds = %if.else, %if.then34
  %32 = load ptr, ptr %path.addr, align 8
  %call39 = call ptr @posix_path_error(ptr noundef %32)
  br label %fail_1

fail_1:                                           ; preds = %if.end38, %if.then31
  %33 = load ptr, ptr %envlist, align 8
  %34 = load i64, ptr %envc, align 8
  call void @free_string_array(ptr noundef %33, i64 noundef %34)
  br label %fail_0

fail_0:                                           ; preds = %fail_1, %if.then27, %if.then23, %if.then19, %if.then15, %if.then8
  %35 = load ptr, ptr %argvlist, align 8
  %tobool40 = icmp ne ptr %35, null
  br i1 %tobool40, label %if.then41, label %if.end42

if.then41:                                        ; preds = %fail_0
  %36 = load ptr, ptr %argvlist, align 8
  %37 = load i64, ptr %argc, align 8
  call void @free_string_array(ptr noundef %36, i64 noundef %37)
  br label %if.end42

if.end42:                                         ; preds = %if.then41, %fail_0
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end42, %if.then11, %if.then
  %38 = load ptr, ptr %retval, align 8
  ret ptr %38
}

; Function Attrs: nounwind
declare i32 @fexecve(i32 noundef, ptr noundef, ptr noundef) #4

; Function Attrs: nounwind
declare i32 @execve(ptr noundef, ptr noundef, ptr noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @posix_path_error(ptr noundef %path) #0 {
entry:
  %path.addr = alloca ptr, align 8
  store ptr %path, ptr %path.addr, align 8
  %0 = load ptr, ptr %path.addr, align 8
  %object = getelementptr inbounds %struct.path_t, ptr %0, i32 0, i32 8
  %1 = load ptr, ptr %object, align 8
  %call = call ptr @posix_path_object_error(ptr noundef %1)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @os_fork_impl(ptr noundef %module) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %pid = alloca i32, align 4
  %interp = alloca ptr, align 8
  %saved_errno = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  %call = call ptr @_PyInterpreterState_GET()
  store ptr %call, ptr %interp, align 8
  %0 = load ptr, ptr %interp, align 8
  %finalizing = getelementptr inbounds %struct._is, ptr %0, i32 0, i32 7
  %1 = load i32, ptr %finalizing, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr @PyExc_RuntimeError, align 8
  call void @PyErr_SetString(ptr noundef %2, ptr noundef @.str.289)
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %interp, align 8
  %call1 = call i32 @_PyInterpreterState_HasFeature(ptr noundef %3, i64 noundef 32768)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.end4, label %if.then3

if.then3:                                         ; preds = %if.end
  %4 = load ptr, ptr @PyExc_RuntimeError, align 8
  call void @PyErr_SetString(ptr noundef %4, ptr noundef @.str.290)
  store ptr null, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  %call5 = call i32 (ptr, ptr, ...) @PySys_Audit(ptr noundef @.str.291, ptr noundef null)
  %cmp = icmp slt i32 %call5, 0
  br i1 %cmp, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end4
  store ptr null, ptr %retval, align 8
  br label %return

if.end7:                                          ; preds = %if.end4
  call void @PyOS_BeforeFork()
  %call8 = call i32 @fork() #10
  store i32 %call8, ptr %pid, align 4
  %call9 = call ptr @__errno_location() #12
  %5 = load i32, ptr %call9, align 4
  store i32 %5, ptr %saved_errno, align 4
  %6 = load i32, ptr %pid, align 4
  %cmp10 = icmp eq i32 %6, 0
  br i1 %cmp10, label %if.then11, label %if.else

if.then11:                                        ; preds = %if.end7
  call void @PyOS_AfterFork_Child()
  br label %if.end12

if.else:                                          ; preds = %if.end7
  call void @warn_about_fork_with_threads(ptr noundef @.str.51)
  call void @PyOS_AfterFork_Parent()
  br label %if.end12

if.end12:                                         ; preds = %if.else, %if.then11
  %7 = load i32, ptr %pid, align 4
  %cmp13 = icmp eq i32 %7, -1
  br i1 %cmp13, label %if.then14, label %if.end17

if.then14:                                        ; preds = %if.end12
  %8 = load i32, ptr %saved_errno, align 4
  %call15 = call ptr @__errno_location() #12
  store i32 %8, ptr %call15, align 4
  %call16 = call ptr @posix_error()
  store ptr %call16, ptr %retval, align 8
  br label %return

if.end17:                                         ; preds = %if.end12
  %9 = load i32, ptr %pid, align 4
  %conv = sext i32 %9 to i64
  %call18 = call ptr @PyLong_FromLong(i64 noundef %conv)
  store ptr %call18, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end17, %if.then14, %if.then6, %if.then3, %if.then
  %10 = load ptr, ptr %retval, align 8
  ret ptr %10
}

; Function Attrs: nounwind
declare i32 @fork() #4

; Function Attrs: nounwind uwtable
define internal void @warn_about_fork_with_threads(ptr noundef %name) #0 {
entry:
  %op.addr.i98 = alloca ptr, align 8
  %op.addr.i94 = alloca ptr, align 8
  %op.addr.i90 = alloca ptr, align 8
  %op.addr.i86 = alloca ptr, align 8
  %op.addr.i82 = alloca ptr, align 8
  %op.addr.i80 = alloca ptr, align 8
  %op.addr.i71 = alloca ptr, align 8
  %op.addr.i62 = alloca ptr, align 8
  %op.addr.i53 = alloca ptr, align 8
  %op.addr.i44 = alloca ptr, align 8
  %op.addr.i35 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %name.addr = alloca ptr, align 8
  %num_python_threads = alloca i64, align 8
  %proc_stat = alloca ptr, align 8
  %n = alloca i64, align 8
  %stat_line = alloca [160 x i8], align 16
  %saveptr = alloca ptr, align 8
  %field = alloca ptr, align 8
  %idx = alloca i32, align 4
  %threading = alloca ptr, align 8
  %threading_active = alloca ptr, align 8
  %threading_limbo = alloca ptr, align 8
  store ptr %name, ptr %name.addr, align 8
  store i64 0, ptr %num_python_threads, align 8
  %call = call noalias ptr @fopen64(ptr noundef @.str.292, ptr noundef @.str.293)
  store ptr %call, ptr %proc_stat, align 8
  %0 = load ptr, ptr %proc_stat, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end10

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %proc_stat, align 8
  %call1 = call i64 @fread(ptr noundef %stat_line, i64 noundef 1, i64 noundef 159, ptr noundef %1)
  store i64 %call1, ptr %n, align 8
  %2 = load i64, ptr %n, align 8
  %arrayidx = getelementptr [160 x i8], ptr %stat_line, i64 0, i64 %2
  store i8 0, ptr %arrayidx, align 1
  %3 = load ptr, ptr %proc_stat, align 8
  %call2 = call i32 @fclose(ptr noundef %3)
  store ptr null, ptr %saveptr, align 8
  %arraydecay = getelementptr inbounds [160 x i8], ptr %stat_line, i64 0, i64 0
  %call3 = call ptr @strtok_r(ptr noundef %arraydecay, ptr noundef @.str.294, ptr noundef %saveptr) #10
  store ptr %call3, ptr %field, align 8
  store i32 19, ptr %idx, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %4 = load i32, ptr %idx, align 4
  %tobool4 = icmp ne i32 %4, 0
  br i1 %tobool4, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %5 = load ptr, ptr %field, align 8
  %tobool5 = icmp ne ptr %5, null
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %6 = phi i1 [ false, %for.cond ], [ %tobool5, %land.rhs ]
  br i1 %6, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %call6 = call ptr @strtok_r(ptr noundef null, ptr noundef @.str.294, ptr noundef %saveptr) #10
  store ptr %call6, ptr %field, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %7 = load i32, ptr %idx, align 4
  %dec = add i32 %7, -1
  store i32 %dec, ptr %idx, align 4
  br label %for.cond, !llvm.loop !18

for.end:                                          ; preds = %land.end
  %8 = load i32, ptr %idx, align 4
  %cmp = icmp eq i32 %8, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.end
  %9 = load ptr, ptr %field, align 8
  %tobool7 = icmp ne ptr %9, null
  br i1 %tobool7, label %if.then8, label %if.end

if.then8:                                         ; preds = %land.lhs.true
  %10 = load ptr, ptr %field, align 8
  %call9 = call i32 @atoi(ptr noundef %10) #13
  %conv = sext i32 %call9 to i64
  store i64 %conv, ptr %num_python_threads, align 8
  br label %if.end

if.end:                                           ; preds = %if.then8, %land.lhs.true, %for.end
  br label %if.end10

if.end10:                                         ; preds = %if.end, %entry
  %11 = load i64, ptr %num_python_threads, align 8
  %cmp11 = icmp sle i64 %11, 0
  br i1 %cmp11, label %if.then13, label %if.end28

if.then13:                                        ; preds = %if.end10
  %call14 = call ptr @PyImport_GetModule(ptr noundef getelementptr inbounds (%struct.anon.44, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 37), i32 0, i32 3, i32 1, i32 652))
  store ptr %call14, ptr %threading, align 8
  %12 = load ptr, ptr %threading, align 8
  %tobool15 = icmp ne ptr %12, null
  br i1 %tobool15, label %if.end17, label %if.then16

if.then16:                                        ; preds = %if.then13
  call void @PyErr_Clear()
  br label %if.end34

if.end17:                                         ; preds = %if.then13
  %13 = load ptr, ptr %threading, align 8
  %call18 = call ptr @PyObject_GetAttr(ptr noundef %13, ptr noundef getelementptr inbounds (%struct.anon.44, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 37), i32 0, i32 3, i32 1, i32 173))
  store ptr %call18, ptr %threading_active, align 8
  %14 = load ptr, ptr %threading_active, align 8
  %tobool19 = icmp ne ptr %14, null
  br i1 %tobool19, label %if.end21, label %if.then20

if.then20:                                        ; preds = %if.end17
  call void @PyErr_Clear()
  %15 = load ptr, ptr %threading, align 8
  store ptr %15, ptr %op.addr.i71, align 8
  %16 = load ptr, ptr %op.addr.i71, align 8
  store ptr %16, ptr %op.addr.i80, align 8
  %17 = load ptr, ptr %op.addr.i80, align 8
  %18 = load i64, ptr %17, align 8
  %conv.i = trunc i64 %18 to i32
  %cmp.i81 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i81 to i32
  %tobool.i73 = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i73, label %if.then.i78, label %if.end.i74

if.then.i78:                                      ; preds = %if.then20
  br label %Py_DECREF.exit79

if.end.i74:                                       ; preds = %if.then20
  %19 = load ptr, ptr %op.addr.i71, align 8
  %20 = load i64, ptr %19, align 8
  %dec.i75 = add i64 %20, -1
  store i64 %dec.i75, ptr %19, align 8
  %cmp.i76 = icmp eq i64 %dec.i75, 0
  br i1 %cmp.i76, label %if.then1.i77, label %Py_DECREF.exit79

if.then1.i77:                                     ; preds = %if.end.i74
  %21 = load ptr, ptr %op.addr.i71, align 8
  call void @_Py_Dealloc(ptr noundef %21) #10
  br label %Py_DECREF.exit79

Py_DECREF.exit79:                                 ; preds = %if.then1.i77, %if.end.i74, %if.then.i78
  br label %if.end34

if.end21:                                         ; preds = %if.end17
  %22 = load ptr, ptr %threading, align 8
  %call22 = call ptr @PyObject_GetAttr(ptr noundef %22, ptr noundef getelementptr inbounds (%struct.anon.44, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 37), i32 0, i32 3, i32 1, i32 195))
  store ptr %call22, ptr %threading_limbo, align 8
  %23 = load ptr, ptr %threading_limbo, align 8
  %tobool23 = icmp ne ptr %23, null
  br i1 %tobool23, label %if.end25, label %if.then24

if.then24:                                        ; preds = %if.end21
  call void @PyErr_Clear()
  %24 = load ptr, ptr %threading, align 8
  store ptr %24, ptr %op.addr.i62, align 8
  %25 = load ptr, ptr %op.addr.i62, align 8
  store ptr %25, ptr %op.addr.i82, align 8
  %26 = load ptr, ptr %op.addr.i82, align 8
  %27 = load i64, ptr %26, align 8
  %conv.i83 = trunc i64 %27 to i32
  %cmp.i84 = icmp slt i32 %conv.i83, 0
  %conv1.i85 = zext i1 %cmp.i84 to i32
  %tobool.i64 = icmp ne i32 %conv1.i85, 0
  br i1 %tobool.i64, label %if.then.i69, label %if.end.i65

if.then.i69:                                      ; preds = %if.then24
  br label %Py_DECREF.exit70

if.end.i65:                                       ; preds = %if.then24
  %28 = load ptr, ptr %op.addr.i62, align 8
  %29 = load i64, ptr %28, align 8
  %dec.i66 = add i64 %29, -1
  store i64 %dec.i66, ptr %28, align 8
  %cmp.i67 = icmp eq i64 %dec.i66, 0
  br i1 %cmp.i67, label %if.then1.i68, label %Py_DECREF.exit70

if.then1.i68:                                     ; preds = %if.end.i65
  %30 = load ptr, ptr %op.addr.i62, align 8
  call void @_Py_Dealloc(ptr noundef %30) #10
  br label %Py_DECREF.exit70

Py_DECREF.exit70:                                 ; preds = %if.then1.i68, %if.end.i65, %if.then.i69
  %31 = load ptr, ptr %threading_active, align 8
  store ptr %31, ptr %op.addr.i53, align 8
  %32 = load ptr, ptr %op.addr.i53, align 8
  store ptr %32, ptr %op.addr.i86, align 8
  %33 = load ptr, ptr %op.addr.i86, align 8
  %34 = load i64, ptr %33, align 8
  %conv.i87 = trunc i64 %34 to i32
  %cmp.i88 = icmp slt i32 %conv.i87, 0
  %conv1.i89 = zext i1 %cmp.i88 to i32
  %tobool.i55 = icmp ne i32 %conv1.i89, 0
  br i1 %tobool.i55, label %if.then.i60, label %if.end.i56

if.then.i60:                                      ; preds = %Py_DECREF.exit70
  br label %Py_DECREF.exit61

if.end.i56:                                       ; preds = %Py_DECREF.exit70
  %35 = load ptr, ptr %op.addr.i53, align 8
  %36 = load i64, ptr %35, align 8
  %dec.i57 = add i64 %36, -1
  store i64 %dec.i57, ptr %35, align 8
  %cmp.i58 = icmp eq i64 %dec.i57, 0
  br i1 %cmp.i58, label %if.then1.i59, label %Py_DECREF.exit61

if.then1.i59:                                     ; preds = %if.end.i56
  %37 = load ptr, ptr %op.addr.i53, align 8
  call void @_Py_Dealloc(ptr noundef %37) #10
  br label %Py_DECREF.exit61

Py_DECREF.exit61:                                 ; preds = %if.then1.i59, %if.end.i56, %if.then.i60
  br label %if.end34

if.end25:                                         ; preds = %if.end21
  %38 = load ptr, ptr %threading, align 8
  store ptr %38, ptr %op.addr.i44, align 8
  %39 = load ptr, ptr %op.addr.i44, align 8
  store ptr %39, ptr %op.addr.i90, align 8
  %40 = load ptr, ptr %op.addr.i90, align 8
  %41 = load i64, ptr %40, align 8
  %conv.i91 = trunc i64 %41 to i32
  %cmp.i92 = icmp slt i32 %conv.i91, 0
  %conv1.i93 = zext i1 %cmp.i92 to i32
  %tobool.i46 = icmp ne i32 %conv1.i93, 0
  br i1 %tobool.i46, label %if.then.i51, label %if.end.i47

if.then.i51:                                      ; preds = %if.end25
  br label %Py_DECREF.exit52

if.end.i47:                                       ; preds = %if.end25
  %42 = load ptr, ptr %op.addr.i44, align 8
  %43 = load i64, ptr %42, align 8
  %dec.i48 = add i64 %43, -1
  store i64 %dec.i48, ptr %42, align 8
  %cmp.i49 = icmp eq i64 %dec.i48, 0
  br i1 %cmp.i49, label %if.then1.i50, label %Py_DECREF.exit52

if.then1.i50:                                     ; preds = %if.end.i47
  %44 = load ptr, ptr %op.addr.i44, align 8
  call void @_Py_Dealloc(ptr noundef %44) #10
  br label %Py_DECREF.exit52

Py_DECREF.exit52:                                 ; preds = %if.then1.i50, %if.end.i47, %if.then.i51
  %45 = load ptr, ptr %threading_active, align 8
  %call26 = call i64 @PyMapping_Size(ptr noundef %45)
  %46 = load ptr, ptr %threading_limbo, align 8
  %call27 = call i64 @PyMapping_Size(ptr noundef %46)
  %add = add i64 %call26, %call27
  store i64 %add, ptr %num_python_threads, align 8
  call void @PyErr_Clear()
  %47 = load ptr, ptr %threading_active, align 8
  store ptr %47, ptr %op.addr.i35, align 8
  %48 = load ptr, ptr %op.addr.i35, align 8
  store ptr %48, ptr %op.addr.i94, align 8
  %49 = load ptr, ptr %op.addr.i94, align 8
  %50 = load i64, ptr %49, align 8
  %conv.i95 = trunc i64 %50 to i32
  %cmp.i96 = icmp slt i32 %conv.i95, 0
  %conv1.i97 = zext i1 %cmp.i96 to i32
  %tobool.i37 = icmp ne i32 %conv1.i97, 0
  br i1 %tobool.i37, label %if.then.i42, label %if.end.i38

if.then.i42:                                      ; preds = %Py_DECREF.exit52
  br label %Py_DECREF.exit43

if.end.i38:                                       ; preds = %Py_DECREF.exit52
  %51 = load ptr, ptr %op.addr.i35, align 8
  %52 = load i64, ptr %51, align 8
  %dec.i39 = add i64 %52, -1
  store i64 %dec.i39, ptr %51, align 8
  %cmp.i40 = icmp eq i64 %dec.i39, 0
  br i1 %cmp.i40, label %if.then1.i41, label %Py_DECREF.exit43

if.then1.i41:                                     ; preds = %if.end.i38
  %53 = load ptr, ptr %op.addr.i35, align 8
  call void @_Py_Dealloc(ptr noundef %53) #10
  br label %Py_DECREF.exit43

Py_DECREF.exit43:                                 ; preds = %if.then1.i41, %if.end.i38, %if.then.i42
  %54 = load ptr, ptr %threading_limbo, align 8
  store ptr %54, ptr %op.addr.i, align 8
  %55 = load ptr, ptr %op.addr.i, align 8
  store ptr %55, ptr %op.addr.i98, align 8
  %56 = load ptr, ptr %op.addr.i98, align 8
  %57 = load i64, ptr %56, align 8
  %conv.i99 = trunc i64 %57 to i32
  %cmp.i100 = icmp slt i32 %conv.i99, 0
  %conv1.i101 = zext i1 %cmp.i100 to i32
  %tobool.i = icmp ne i32 %conv1.i101, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %Py_DECREF.exit43
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %Py_DECREF.exit43
  %58 = load ptr, ptr %op.addr.i, align 8
  %59 = load i64, ptr %58, align 8
  %dec.i = add i64 %59, -1
  store i64 %dec.i, ptr %58, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %60 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %60) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  br label %if.end28

if.end28:                                         ; preds = %Py_DECREF.exit, %if.end10
  %61 = load i64, ptr %num_python_threads, align 8
  %cmp29 = icmp sgt i64 %61, 1
  br i1 %cmp29, label %if.then31, label %if.end34

if.then31:                                        ; preds = %if.end28
  %62 = load ptr, ptr @PyExc_DeprecationWarning, align 8
  %call32 = call i32 @getpid() #10
  %63 = load ptr, ptr %name.addr, align 8
  %call33 = call i32 (ptr, i64, ptr, ...) @PyErr_WarnFormat(ptr noundef %62, i64 noundef 1, ptr noundef @.str.295, i32 noundef %call32, ptr noundef %63)
  call void @PyErr_Clear()
  br label %if.end34

if.end34:                                         ; preds = %if.then31, %if.end28, %Py_DECREF.exit61, %Py_DECREF.exit79, %if.then16
  ret void
}

declare noalias ptr @fopen64(ptr noundef, ptr noundef) #1

declare i64 @fread(ptr noundef, i64 noundef, i64 noundef, ptr noundef) #1

declare i32 @fclose(ptr noundef) #1

; Function Attrs: nounwind
declare ptr @strtok_r(ptr noundef, ptr noundef, ptr noundef) #4

; Function Attrs: nounwind willreturn memory(read)
declare i32 @atoi(ptr noundef) #7

declare ptr @PyImport_GetModule(ptr noundef) #1

declare void @PyErr_Clear() #1

declare ptr @PyObject_GetAttr(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind
declare i32 @getpid() #4

; Function Attrs: nounwind uwtable
define internal ptr @os_register_at_fork_impl(ptr noundef %module, ptr noundef %before, ptr noundef %after_in_child, ptr noundef %after_in_parent) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %before.addr = alloca ptr, align 8
  %after_in_child.addr = alloca ptr, align 8
  %after_in_parent.addr = alloca ptr, align 8
  %interp = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %before, ptr %before.addr, align 8
  store ptr %after_in_child, ptr %after_in_child.addr, align 8
  store ptr %after_in_parent, ptr %after_in_parent.addr, align 8
  %0 = load ptr, ptr %before.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %after_in_child.addr, align 8
  %tobool1 = icmp ne ptr %1, null
  br i1 %tobool1, label %if.end, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load ptr, ptr %after_in_parent.addr, align 8
  %tobool3 = icmp ne ptr %2, null
  br i1 %tobool3, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true2
  %3 = load ptr, ptr @PyExc_TypeError, align 8
  call void @PyErr_SetString(ptr noundef %3, ptr noundef @.str.299)
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %land.lhs.true2, %land.lhs.true, %entry
  %4 = load ptr, ptr %before.addr, align 8
  %call = call i32 @check_null_or_callable(ptr noundef %4, ptr noundef @.str.296)
  %tobool4 = icmp ne i32 %call, 0
  br i1 %tobool4, label %if.then10, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %5 = load ptr, ptr %after_in_child.addr, align 8
  %call5 = call i32 @check_null_or_callable(ptr noundef %5, ptr noundef @.str.297)
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %if.then10, label %lor.lhs.false7

lor.lhs.false7:                                   ; preds = %lor.lhs.false
  %6 = load ptr, ptr %after_in_parent.addr, align 8
  %call8 = call i32 @check_null_or_callable(ptr noundef %6, ptr noundef @.str.298)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %lor.lhs.false7, %lor.lhs.false, %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end11:                                         ; preds = %lor.lhs.false7
  %call12 = call ptr @_PyInterpreterState_GET()
  store ptr %call12, ptr %interp, align 8
  %7 = load ptr, ptr %interp, align 8
  %before_forkers = getelementptr inbounds %struct._is, ptr %7, i32 0, i32 33
  %8 = load ptr, ptr %before.addr, align 8
  %call13 = call i32 @register_at_forker(ptr noundef %before_forkers, ptr noundef %8)
  %tobool14 = icmp ne i32 %call13, 0
  br i1 %tobool14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.end11
  store ptr null, ptr %retval, align 8
  br label %return

if.end16:                                         ; preds = %if.end11
  %9 = load ptr, ptr %interp, align 8
  %after_forkers_child = getelementptr inbounds %struct._is, ptr %9, i32 0, i32 35
  %10 = load ptr, ptr %after_in_child.addr, align 8
  %call17 = call i32 @register_at_forker(ptr noundef %after_forkers_child, ptr noundef %10)
  %tobool18 = icmp ne i32 %call17, 0
  br i1 %tobool18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %if.end16
  store ptr null, ptr %retval, align 8
  br label %return

if.end20:                                         ; preds = %if.end16
  %11 = load ptr, ptr %interp, align 8
  %after_forkers_parent = getelementptr inbounds %struct._is, ptr %11, i32 0, i32 34
  %12 = load ptr, ptr %after_in_parent.addr, align 8
  %call21 = call i32 @register_at_forker(ptr noundef %after_forkers_parent, ptr noundef %12)
  %tobool22 = icmp ne i32 %call21, 0
  br i1 %tobool22, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.end20
  store ptr null, ptr %retval, align 8
  br label %return

if.end24:                                         ; preds = %if.end20
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end24, %if.then23, %if.then19, %if.then15, %if.then10, %if.then
  %13 = load ptr, ptr %retval, align 8
  ret ptr %13
}

; Function Attrs: nounwind uwtable
define internal i32 @check_null_or_callable(ptr noundef %obj, ptr noundef %obj_name) #0 {
entry:
  %retval = alloca i32, align 4
  %obj.addr = alloca ptr, align 8
  %obj_name.addr = alloca ptr, align 8
  store ptr %obj, ptr %obj.addr, align 8
  store ptr %obj_name, ptr %obj_name.addr, align 8
  %0 = load ptr, ptr %obj.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %obj.addr, align 8
  %call = call i32 @PyCallable_Check(ptr noundef %1)
  %tobool1 = icmp ne i32 %call, 0
  br i1 %tobool1, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %2 = load ptr, ptr @PyExc_TypeError, align 8
  %3 = load ptr, ptr %obj_name.addr, align 8
  %4 = load ptr, ptr %obj.addr, align 8
  %call2 = call ptr @Py_TYPE(ptr noundef %4)
  %call3 = call ptr @_PyType_Name(ptr noundef %call2)
  %call4 = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %2, ptr noundef @.str.300, ptr noundef %3, ptr noundef %call3)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %5 = load i32, ptr %retval, align 4
  ret i32 %5
}

; Function Attrs: nounwind uwtable
define internal i32 @register_at_forker(ptr noundef %lst, ptr noundef %func) #0 {
entry:
  %retval = alloca i32, align 4
  %lst.addr = alloca ptr, align 8
  %func.addr = alloca ptr, align 8
  store ptr %lst, ptr %lst.addr, align 8
  store ptr %func, ptr %func.addr, align 8
  %0 = load ptr, ptr %func.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %lst.addr, align 8
  %2 = load ptr, ptr %1, align 8
  %cmp1 = icmp eq ptr %2, null
  br i1 %cmp1, label %if.then2, label %if.end6

if.then2:                                         ; preds = %if.end
  %call = call ptr @PyList_New(i64 noundef 0)
  %3 = load ptr, ptr %lst.addr, align 8
  store ptr %call, ptr %3, align 8
  %4 = load ptr, ptr %lst.addr, align 8
  %5 = load ptr, ptr %4, align 8
  %cmp3 = icmp eq ptr %5, null
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.then2
  store i32 -1, ptr %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.then2
  br label %if.end6

if.end6:                                          ; preds = %if.end5, %if.end
  %6 = load ptr, ptr %lst.addr, align 8
  %7 = load ptr, ptr %6, align 8
  %8 = load ptr, ptr %func.addr, align 8
  %call7 = call i32 @PyList_Append(ptr noundef %7, ptr noundef %8)
  store i32 %call7, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end6, %if.then4, %if.then
  %9 = load i32, ptr %retval, align 4
  ret i32 %9
}

declare i32 @PyCallable_Check(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @os_sched_get_priority_max_impl(ptr noundef %module, i32 noundef %policy) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %policy.addr = alloca i32, align 4
  %max = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %policy, ptr %policy.addr, align 4
  %0 = load i32, ptr %policy.addr, align 4
  %call = call i32 @sched_get_priority_max(i32 noundef %0) #10
  store i32 %call, ptr %max, align 4
  %1 = load i32, ptr %max, align 4
  %cmp = icmp slt i32 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call ptr @posix_error()
  store ptr %call1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %max, align 4
  %conv = sext i32 %2 to i64
  %call2 = call ptr @PyLong_FromLong(i64 noundef %conv)
  store ptr %call2, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load ptr, ptr %retval, align 8
  ret ptr %3
}

; Function Attrs: nounwind
declare i32 @sched_get_priority_max(i32 noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_sched_get_priority_min_impl(ptr noundef %module, i32 noundef %policy) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %policy.addr = alloca i32, align 4
  %min = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %policy, ptr %policy.addr, align 4
  %0 = load i32, ptr %policy.addr, align 4
  %call = call i32 @sched_get_priority_min(i32 noundef %0) #10
  store i32 %call, ptr %min, align 4
  %1 = load i32, ptr %min, align 4
  %cmp = icmp slt i32 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call ptr @posix_error()
  store ptr %call1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %min, align 4
  %conv = sext i32 %2 to i64
  %call2 = call ptr @PyLong_FromLong(i64 noundef %conv)
  store ptr %call2, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load ptr, ptr %retval, align 8
  ret ptr %3
}

; Function Attrs: nounwind
declare i32 @sched_get_priority_min(i32 noundef) #4

declare i32 @PyArg_Parse(ptr noundef, ptr noundef, ...) #1

; Function Attrs: nounwind uwtable
define internal ptr @os_sched_getparam_impl(ptr noundef %module, i32 noundef %pid) #0 {
entry:
  %op.addr.i12 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %pid.addr = alloca i32, align 4
  %param = alloca %struct.sched_param, align 4
  %result = alloca ptr, align 8
  %priority = alloca ptr, align 8
  %SchedParamType = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %pid, ptr %pid.addr, align 4
  %0 = load i32, ptr %pid.addr, align 4
  %call = call i32 @sched_getparam(i32 noundef %0, ptr noundef %param) #10
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call ptr @posix_error()
  store ptr %call1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %module.addr, align 8
  %call2 = call ptr @get_posix_state(ptr noundef %1)
  %SchedParamType3 = getelementptr inbounds %struct._posixstate, ptr %call2, i32 0, i32 3
  %2 = load ptr, ptr %SchedParamType3, align 8
  store ptr %2, ptr %SchedParamType, align 8
  %3 = load ptr, ptr %SchedParamType, align 8
  %call4 = call ptr @PyStructSequence_New(ptr noundef %3)
  store ptr %call4, ptr %result, align 8
  %4 = load ptr, ptr %result, align 8
  %tobool5 = icmp ne ptr %4, null
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end7:                                          ; preds = %if.end
  %sched_priority = getelementptr inbounds %struct.sched_param, ptr %param, i32 0, i32 0
  %5 = load i32, ptr %sched_priority, align 4
  %conv = sext i32 %5 to i64
  %call8 = call ptr @PyLong_FromLong(i64 noundef %conv)
  store ptr %call8, ptr %priority, align 8
  %6 = load ptr, ptr %priority, align 8
  %tobool9 = icmp ne ptr %6, null
  br i1 %tobool9, label %if.end11, label %if.then10

if.then10:                                        ; preds = %if.end7
  %7 = load ptr, ptr %result, align 8
  store ptr %7, ptr %op.addr.i, align 8
  %8 = load ptr, ptr %op.addr.i, align 8
  store ptr %8, ptr %op.addr.i12, align 8
  %9 = load ptr, ptr %op.addr.i12, align 8
  %10 = load i64, ptr %9, align 8
  %conv.i = trunc i64 %10 to i32
  %cmp.i13 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i13 to i32
  %tobool.i = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then10
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.then10
  %11 = load ptr, ptr %op.addr.i, align 8
  %12 = load i64, ptr %11, align 8
  %dec.i = add i64 %12, -1
  store i64 %dec.i, ptr %11, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %13 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %13) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  store ptr null, ptr %retval, align 8
  br label %return

if.end11:                                         ; preds = %if.end7
  %14 = load ptr, ptr %result, align 8
  %15 = load ptr, ptr %priority, align 8
  call void @PyStructSequence_SetItem(ptr noundef %14, i64 noundef 0, ptr noundef %15)
  %16 = load ptr, ptr %result, align 8
  store ptr %16, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end11, %Py_DECREF.exit, %if.then6, %if.then
  %17 = load ptr, ptr %retval, align 8
  ret ptr %17
}

; Function Attrs: nounwind
declare i32 @sched_getparam(i32 noundef, ptr noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_sched_getscheduler_impl(ptr noundef %module, i32 noundef %pid) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %pid.addr = alloca i32, align 4
  %policy = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %pid, ptr %pid.addr, align 4
  %0 = load i32, ptr %pid.addr, align 4
  %call = call i32 @sched_getscheduler(i32 noundef %0) #10
  store i32 %call, ptr %policy, align 4
  %1 = load i32, ptr %policy, align 4
  %cmp = icmp slt i32 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call ptr @posix_error()
  store ptr %call1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %policy, align 4
  %conv = sext i32 %2 to i64
  %call2 = call ptr @PyLong_FromLong(i64 noundef %conv)
  store ptr %call2, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load ptr, ptr %retval, align 8
  ret ptr %3
}

; Function Attrs: nounwind
declare i32 @sched_getscheduler(i32 noundef) #4

; Function Attrs: nounwind uwtable
define internal double @os_sched_rr_get_interval_impl(ptr noundef %module, i32 noundef %pid) #0 {
entry:
  %retval = alloca double, align 8
  %module.addr = alloca ptr, align 8
  %pid.addr = alloca i32, align 4
  %interval = alloca %struct.timespec, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %pid, ptr %pid.addr, align 4
  %0 = load i32, ptr %pid.addr, align 4
  %call = call i32 @sched_rr_get_interval(i32 noundef %0, ptr noundef %interval) #10
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call ptr @posix_error()
  store double -1.000000e+00, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %tv_sec = getelementptr inbounds %struct.timespec, ptr %interval, i32 0, i32 0
  %1 = load i64, ptr %tv_sec, align 8
  %conv = sitofp i64 %1 to double
  %tv_nsec = getelementptr inbounds %struct.timespec, ptr %interval, i32 0, i32 1
  %2 = load i64, ptr %tv_nsec, align 8
  %conv2 = sitofp i64 %2 to double
  %3 = call double @llvm.fmuladd.f64(double 1.000000e-09, double %conv2, double %conv)
  store double %3, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load double, ptr %retval, align 8
  ret double %4
}

; Function Attrs: nounwind
declare i32 @sched_rr_get_interval(i32 noundef, ptr noundef) #4

declare i32 @_PyArg_ParseStack(ptr noundef, i64 noundef, ptr noundef, ...) #1

; Function Attrs: nounwind uwtable
define internal ptr @os_sched_setparam_impl(ptr noundef %module, i32 noundef %pid, ptr noundef %param_obj) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %pid.addr = alloca i32, align 4
  %param_obj.addr = alloca ptr, align 8
  %param = alloca %struct.sched_param, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %pid, ptr %pid.addr, align 4
  store ptr %param_obj, ptr %param_obj.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %1 = load ptr, ptr %param_obj.addr, align 8
  %call = call i32 @convert_sched_param(ptr noundef %0, ptr noundef %1, ptr noundef %param)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %pid.addr, align 4
  %call1 = call i32 @sched_setparam(i32 noundef %2, ptr noundef %param) #10
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %call4 = call ptr @posix_error()
  store ptr %call4, ptr %retval, align 8
  br label %return

if.end5:                                          ; preds = %if.end
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end5, %if.then3, %if.then
  %3 = load ptr, ptr %retval, align 8
  ret ptr %3
}

; Function Attrs: nounwind
declare i32 @sched_setparam(i32 noundef, ptr noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_sched_setscheduler_impl(ptr noundef %module, i32 noundef %pid, i32 noundef %policy, ptr noundef %param_obj) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %pid.addr = alloca i32, align 4
  %policy.addr = alloca i32, align 4
  %param_obj.addr = alloca ptr, align 8
  %param = alloca %struct.sched_param, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %pid, ptr %pid.addr, align 4
  store i32 %policy, ptr %policy.addr, align 4
  store ptr %param_obj, ptr %param_obj.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %1 = load ptr, ptr %param_obj.addr, align 8
  %call = call i32 @convert_sched_param(ptr noundef %0, ptr noundef %1, ptr noundef %param)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %pid.addr, align 4
  %3 = load i32, ptr %policy.addr, align 4
  %call1 = call i32 @sched_setscheduler(i32 noundef %2, i32 noundef %3, ptr noundef %param) #10
  %cmp = icmp eq i32 %call1, -1
  br i1 %cmp, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %call3 = call ptr @posix_error()
  store ptr %call3, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end4, %if.then2, %if.then
  %4 = load ptr, ptr %retval, align 8
  ret ptr %4
}

; Function Attrs: nounwind
declare i32 @sched_setscheduler(i32 noundef, i32 noundef, ptr noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_sched_yield_impl(ptr noundef %module) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %result = alloca i32, align 4
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  %call = call ptr @PyEval_SaveThread()
  store ptr %call, ptr %_save, align 8
  %call1 = call i32 @sched_yield() #10
  store i32 %call1, ptr %result, align 4
  %0 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %0)
  %1 = load i32, ptr %result, align 4
  %cmp = icmp slt i32 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call2 = call ptr @posix_error()
  store ptr %call2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load ptr, ptr %retval, align 8
  ret ptr %2
}

; Function Attrs: nounwind
declare i32 @sched_yield() #4

; Function Attrs: nounwind uwtable
define internal ptr @os_sched_setaffinity_impl(ptr noundef %module, i32 noundef %pid, ptr noundef %mask) #0 {
entry:
  %op.addr.i107 = alloca ptr, align 8
  %op.addr.i103 = alloca ptr, align 8
  %op.addr.i101 = alloca ptr, align 8
  %op.addr.i92 = alloca ptr, align 8
  %op.addr.i83 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %pid.addr = alloca i32, align 4
  %mask.addr = alloca ptr, align 8
  %ncpus = alloca i32, align 4
  %setsize = alloca i64, align 8
  %cpu_set = alloca ptr, align 8
  %iterator = alloca ptr, align 8
  %item = alloca ptr, align 8
  %cpu = alloca i64, align 8
  %newncpus = alloca i32, align 4
  %newmask = alloca ptr, align 8
  %newsetsize = alloca i64, align 8
  %__cpu = alloca i64, align 8
  %tmp = alloca i64, align 8
  %_tmp_op_ptr = alloca ptr, align 8
  %_tmp_old_op = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %pid, ptr %pid.addr, align 4
  store ptr %mask, ptr %mask.addr, align 8
  store ptr null, ptr %cpu_set, align 8
  store ptr null, ptr %iterator, align 8
  %0 = load ptr, ptr %mask.addr, align 8
  %call = call ptr @PyObject_GetIter(ptr noundef %0)
  store ptr %call, ptr %iterator, align 8
  %1 = load ptr, ptr %iterator, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store i32 64, ptr %ncpus, align 4
  %2 = load i32, ptr %ncpus, align 4
  %conv = sext i32 %2 to i64
  %add = add i64 %conv, 64
  %sub = sub i64 %add, 1
  %div = udiv i64 %sub, 64
  %mul = mul i64 %div, 8
  store i64 %mul, ptr %setsize, align 8
  %3 = load i32, ptr %ncpus, align 4
  %conv1 = sext i32 %3 to i64
  %call2 = call ptr @__sched_cpualloc(i64 noundef %conv1) #10
  store ptr %call2, ptr %cpu_set, align 8
  %4 = load ptr, ptr %cpu_set, align 8
  %cmp3 = icmp eq ptr %4, null
  br i1 %cmp3, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  %call6 = call ptr @PyErr_NoMemory()
  br label %error

if.end7:                                          ; preds = %if.end
  br label %do.body

do.body:                                          ; preds = %if.end7
  %5 = load ptr, ptr %cpu_set, align 8
  %6 = load i64, ptr %setsize, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %5, i8 0, i64 %6, i1 false)
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %while.cond

while.cond:                                       ; preds = %cond.end, %do.end
  %7 = load ptr, ptr %iterator, align 8
  %call8 = call ptr @PyIter_Next(ptr noundef %7)
  store ptr %call8, ptr %item, align 8
  %tobool = icmp ne ptr %call8, null
  br i1 %tobool, label %while.body, label %while.end64

while.body:                                       ; preds = %while.cond
  %8 = load ptr, ptr %item, align 8
  %call9 = call ptr @Py_TYPE(ptr noundef %8)
  %call10 = call i32 @PyType_HasFeature(ptr noundef %call9, i64 noundef 16777216)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end15, label %if.then12

if.then12:                                        ; preds = %while.body
  %9 = load ptr, ptr @PyExc_TypeError, align 8
  %10 = load ptr, ptr %item, align 8
  %call13 = call ptr @Py_TYPE(ptr noundef %10)
  %call14 = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %9, ptr noundef @.str.308, ptr noundef %call13)
  %11 = load ptr, ptr %item, align 8
  store ptr %11, ptr %op.addr.i92, align 8
  %12 = load ptr, ptr %op.addr.i92, align 8
  store ptr %12, ptr %op.addr.i101, align 8
  %13 = load ptr, ptr %op.addr.i101, align 8
  %14 = load i64, ptr %13, align 8
  %conv.i = trunc i64 %14 to i32
  %cmp.i102 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i102 to i32
  %tobool.i94 = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i94, label %if.then.i99, label %if.end.i95

if.then.i99:                                      ; preds = %if.then12
  br label %Py_DECREF.exit100

if.end.i95:                                       ; preds = %if.then12
  %15 = load ptr, ptr %op.addr.i92, align 8
  %16 = load i64, ptr %15, align 8
  %dec.i96 = add i64 %16, -1
  store i64 %dec.i96, ptr %15, align 8
  %cmp.i97 = icmp eq i64 %dec.i96, 0
  br i1 %cmp.i97, label %if.then1.i98, label %Py_DECREF.exit100

if.then1.i98:                                     ; preds = %if.end.i95
  %17 = load ptr, ptr %op.addr.i92, align 8
  call void @_Py_Dealloc(ptr noundef %17) #10
  br label %Py_DECREF.exit100

Py_DECREF.exit100:                                ; preds = %if.then1.i98, %if.end.i95, %if.then.i99
  br label %error

if.end15:                                         ; preds = %while.body
  %18 = load ptr, ptr %item, align 8
  %call16 = call i64 @PyLong_AsLong(ptr noundef %18)
  store i64 %call16, ptr %cpu, align 8
  %19 = load ptr, ptr %item, align 8
  store ptr %19, ptr %op.addr.i83, align 8
  %20 = load ptr, ptr %op.addr.i83, align 8
  store ptr %20, ptr %op.addr.i103, align 8
  %21 = load ptr, ptr %op.addr.i103, align 8
  %22 = load i64, ptr %21, align 8
  %conv.i104 = trunc i64 %22 to i32
  %cmp.i105 = icmp slt i32 %conv.i104, 0
  %conv1.i106 = zext i1 %cmp.i105 to i32
  %tobool.i85 = icmp ne i32 %conv1.i106, 0
  br i1 %tobool.i85, label %if.then.i90, label %if.end.i86

if.then.i90:                                      ; preds = %if.end15
  br label %Py_DECREF.exit91

if.end.i86:                                       ; preds = %if.end15
  %23 = load ptr, ptr %op.addr.i83, align 8
  %24 = load i64, ptr %23, align 8
  %dec.i87 = add i64 %24, -1
  store i64 %dec.i87, ptr %23, align 8
  %cmp.i88 = icmp eq i64 %dec.i87, 0
  br i1 %cmp.i88, label %if.then1.i89, label %Py_DECREF.exit91

if.then1.i89:                                     ; preds = %if.end.i86
  %25 = load ptr, ptr %op.addr.i83, align 8
  call void @_Py_Dealloc(ptr noundef %25) #10
  br label %Py_DECREF.exit91

Py_DECREF.exit91:                                 ; preds = %if.then1.i89, %if.end.i86, %if.then.i90
  %26 = load i64, ptr %cpu, align 8
  %cmp17 = icmp slt i64 %26, 0
  br i1 %cmp17, label %if.then19, label %if.end24

if.then19:                                        ; preds = %Py_DECREF.exit91
  %call20 = call ptr @PyErr_Occurred()
  %tobool21 = icmp ne ptr %call20, null
  br i1 %tobool21, label %if.end23, label %if.then22

if.then22:                                        ; preds = %if.then19
  %27 = load ptr, ptr @PyExc_ValueError, align 8
  call void @PyErr_SetString(ptr noundef %27, ptr noundef @.str.309)
  br label %if.end23

if.end23:                                         ; preds = %if.then22, %if.then19
  br label %error

if.end24:                                         ; preds = %Py_DECREF.exit91
  %28 = load i64, ptr %cpu, align 8
  %cmp25 = icmp sgt i64 %28, 2147483646
  br i1 %cmp25, label %if.then27, label %if.end28

if.then27:                                        ; preds = %if.end24
  %29 = load ptr, ptr @PyExc_OverflowError, align 8
  call void @PyErr_SetString(ptr noundef %29, ptr noundef @.str.310)
  br label %error

if.end28:                                         ; preds = %if.end24
  %30 = load i64, ptr %cpu, align 8
  %31 = load i32, ptr %ncpus, align 4
  %conv29 = sext i32 %31 to i64
  %cmp30 = icmp sge i64 %30, %conv29
  br i1 %cmp30, label %if.then32, label %if.end59

if.then32:                                        ; preds = %if.end28
  %32 = load i32, ptr %ncpus, align 4
  store i32 %32, ptr %newncpus, align 4
  br label %while.cond33

while.cond33:                                     ; preds = %if.end44, %if.then32
  %33 = load i32, ptr %newncpus, align 4
  %conv34 = sext i32 %33 to i64
  %34 = load i64, ptr %cpu, align 8
  %cmp35 = icmp sle i64 %conv34, %34
  br i1 %cmp35, label %while.body37, label %while.end

while.body37:                                     ; preds = %while.cond33
  %35 = load i32, ptr %newncpus, align 4
  %cmp38 = icmp sgt i32 %35, 1073741823
  br i1 %cmp38, label %if.then40, label %if.else

if.then40:                                        ; preds = %while.body37
  %36 = load i64, ptr %cpu, align 8
  %add41 = add i64 %36, 1
  %conv42 = trunc i64 %add41 to i32
  store i32 %conv42, ptr %newncpus, align 4
  br label %if.end44

if.else:                                          ; preds = %while.body37
  %37 = load i32, ptr %newncpus, align 4
  %mul43 = mul i32 %37, 2
  store i32 %mul43, ptr %newncpus, align 4
  br label %if.end44

if.end44:                                         ; preds = %if.else, %if.then40
  br label %while.cond33, !llvm.loop !19

while.end:                                        ; preds = %while.cond33
  %38 = load i32, ptr %newncpus, align 4
  %conv45 = sext i32 %38 to i64
  %call46 = call ptr @__sched_cpualloc(i64 noundef %conv45) #10
  store ptr %call46, ptr %newmask, align 8
  %39 = load ptr, ptr %newmask, align 8
  %cmp47 = icmp eq ptr %39, null
  br i1 %cmp47, label %if.then49, label %if.end51

if.then49:                                        ; preds = %while.end
  %call50 = call ptr @PyErr_NoMemory()
  br label %error

if.end51:                                         ; preds = %while.end
  %40 = load i32, ptr %newncpus, align 4
  %conv52 = sext i32 %40 to i64
  %add53 = add i64 %conv52, 64
  %sub54 = sub i64 %add53, 1
  %div55 = udiv i64 %sub54, 64
  %mul56 = mul i64 %div55, 8
  store i64 %mul56, ptr %newsetsize, align 8
  br label %do.body57

do.body57:                                        ; preds = %if.end51
  %41 = load ptr, ptr %newmask, align 8
  %42 = load i64, ptr %newsetsize, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %41, i8 0, i64 %42, i1 false)
  br label %do.end58

do.end58:                                         ; preds = %do.body57
  %43 = load ptr, ptr %newmask, align 8
  %44 = load ptr, ptr %cpu_set, align 8
  %45 = load i64, ptr %setsize, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %43, ptr align 8 %44, i64 %45, i1 false)
  %46 = load ptr, ptr %cpu_set, align 8
  call void @__sched_cpufree(ptr noundef %46) #10
  %47 = load i64, ptr %newsetsize, align 8
  store i64 %47, ptr %setsize, align 8
  %48 = load ptr, ptr %newmask, align 8
  store ptr %48, ptr %cpu_set, align 8
  %49 = load i32, ptr %newncpus, align 4
  store i32 %49, ptr %ncpus, align 4
  br label %if.end59

if.end59:                                         ; preds = %do.end58, %if.end28
  %50 = load i64, ptr %cpu, align 8
  store i64 %50, ptr %__cpu, align 8
  %51 = load i64, ptr %__cpu, align 8
  %div60 = udiv i64 %51, 8
  %52 = load i64, ptr %setsize, align 8
  %cmp61 = icmp ult i64 %div60, %52
  br i1 %cmp61, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end59
  %53 = load i64, ptr %__cpu, align 8
  %rem = urem i64 %53, 64
  %shl = shl i64 1, %rem
  %54 = load ptr, ptr %cpu_set, align 8
  %__bits = getelementptr inbounds %struct.cpu_set_t, ptr %54, i32 0, i32 0
  %arraydecay = getelementptr inbounds [16 x i64], ptr %__bits, i64 0, i64 0
  %55 = load i64, ptr %__cpu, align 8
  %div63 = udiv i64 %55, 64
  %arrayidx = getelementptr i64, ptr %arraydecay, i64 %div63
  %56 = load i64, ptr %arrayidx, align 8
  %or = or i64 %56, %shl
  store i64 %or, ptr %arrayidx, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end59
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %or, %cond.true ], [ 0, %cond.false ]
  store i64 %cond, ptr %tmp, align 8
  br label %while.cond, !llvm.loop !20

while.end64:                                      ; preds = %while.cond
  %call65 = call ptr @PyErr_Occurred()
  %tobool66 = icmp ne ptr %call65, null
  br i1 %tobool66, label %if.then67, label %if.end68

if.then67:                                        ; preds = %while.end64
  br label %error

if.end68:                                         ; preds = %while.end64
  br label %do.body69

do.body69:                                        ; preds = %if.end68
  store ptr %iterator, ptr %_tmp_op_ptr, align 8
  %57 = load ptr, ptr %_tmp_op_ptr, align 8
  %58 = load ptr, ptr %57, align 8
  store ptr %58, ptr %_tmp_old_op, align 8
  %59 = load ptr, ptr %_tmp_old_op, align 8
  %cmp70 = icmp ne ptr %59, null
  br i1 %cmp70, label %if.then72, label %if.end73

if.then72:                                        ; preds = %do.body69
  %60 = load ptr, ptr %_tmp_op_ptr, align 8
  store ptr null, ptr %60, align 8
  %61 = load ptr, ptr %_tmp_old_op, align 8
  store ptr %61, ptr %op.addr.i, align 8
  %62 = load ptr, ptr %op.addr.i, align 8
  store ptr %62, ptr %op.addr.i107, align 8
  %63 = load ptr, ptr %op.addr.i107, align 8
  %64 = load i64, ptr %63, align 8
  %conv.i108 = trunc i64 %64 to i32
  %cmp.i109 = icmp slt i32 %conv.i108, 0
  %conv1.i110 = zext i1 %cmp.i109 to i32
  %tobool.i = icmp ne i32 %conv1.i110, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then72
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.then72
  %65 = load ptr, ptr %op.addr.i, align 8
  %66 = load i64, ptr %65, align 8
  %dec.i = add i64 %66, -1
  store i64 %dec.i, ptr %65, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %67 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %67) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  br label %if.end73

if.end73:                                         ; preds = %Py_DECREF.exit, %do.body69
  br label %do.end74

do.end74:                                         ; preds = %if.end73
  %68 = load i32, ptr %pid.addr, align 4
  %69 = load i64, ptr %setsize, align 8
  %70 = load ptr, ptr %cpu_set, align 8
  %call75 = call i32 @sched_setaffinity(i32 noundef %68, i64 noundef %69, ptr noundef %70) #10
  %tobool76 = icmp ne i32 %call75, 0
  br i1 %tobool76, label %if.then77, label %if.end79

if.then77:                                        ; preds = %do.end74
  %call78 = call ptr @posix_error()
  br label %error

if.end79:                                         ; preds = %do.end74
  %71 = load ptr, ptr %cpu_set, align 8
  call void @__sched_cpufree(ptr noundef %71) #10
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

error:                                            ; preds = %if.then77, %if.then67, %if.then49, %if.then27, %if.end23, %Py_DECREF.exit100, %if.then5
  %72 = load ptr, ptr %cpu_set, align 8
  %tobool80 = icmp ne ptr %72, null
  br i1 %tobool80, label %if.then81, label %if.end82

if.then81:                                        ; preds = %error
  %73 = load ptr, ptr %cpu_set, align 8
  call void @__sched_cpufree(ptr noundef %73) #10
  br label %if.end82

if.end82:                                         ; preds = %if.then81, %error
  %74 = load ptr, ptr %iterator, align 8
  call void @Py_XDECREF(ptr noundef %74)
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end82, %if.end79, %if.then
  %75 = load ptr, ptr %retval, align 8
  ret ptr %75
}

; Function Attrs: nounwind
declare ptr @__sched_cpualloc(i64 noundef) #4

; Function Attrs: nounwind
declare void @__sched_cpufree(ptr noundef) #4

; Function Attrs: nounwind
declare i32 @sched_setaffinity(i32 noundef, i64 noundef, ptr noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_sched_getaffinity_impl(ptr noundef %module, i32 noundef %pid) #0 {
entry:
  %op.addr.i60 = alloca ptr, align 8
  %op.addr.i58 = alloca ptr, align 8
  %op.addr.i49 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %pid.addr = alloca i32, align 4
  %ncpus = alloca i32, align 4
  %setsize = alloca i64, align 8
  %mask = alloca ptr, align 8
  %res = alloca ptr, align 8
  %cpu = alloca i32, align 4
  %count = alloca i32, align 4
  %__cpu = alloca i64, align 8
  %tmp = alloca i32, align 4
  %cpu_num = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %pid, ptr %pid.addr, align 4
  store i32 64, ptr %ncpus, align 4
  br label %while.body

while.body:                                       ; preds = %if.end18, %entry
  %0 = load i32, ptr %ncpus, align 4
  %conv = sext i32 %0 to i64
  %add = add i64 %conv, 64
  %sub = sub i64 %add, 1
  %div = udiv i64 %sub, 64
  %mul = mul i64 %div, 8
  store i64 %mul, ptr %setsize, align 8
  %1 = load i32, ptr %ncpus, align 4
  %conv1 = sext i32 %1 to i64
  %call = call ptr @__sched_cpualloc(i64 noundef %conv1) #10
  store ptr %call, ptr %mask, align 8
  %2 = load ptr, ptr %mask, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %call3 = call ptr @PyErr_NoMemory()
  store ptr %call3, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %while.body
  %3 = load i32, ptr %pid.addr, align 4
  %4 = load i64, ptr %setsize, align 8
  %5 = load ptr, ptr %mask, align 8
  %call4 = call i32 @sched_getaffinity(i32 noundef %3, i64 noundef %4, ptr noundef %5) #10
  %cmp5 = icmp eq i32 %call4, 0
  br i1 %cmp5, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end
  br label %while.end

if.end8:                                          ; preds = %if.end
  %6 = load ptr, ptr %mask, align 8
  call void @__sched_cpufree(ptr noundef %6) #10
  %call9 = call ptr @__errno_location() #12
  %7 = load i32, ptr %call9, align 4
  %cmp10 = icmp ne i32 %7, 22
  br i1 %cmp10, label %if.then12, label %if.end14

if.then12:                                        ; preds = %if.end8
  %call13 = call ptr @posix_error()
  store ptr %call13, ptr %retval, align 8
  br label %return

if.end14:                                         ; preds = %if.end8
  %8 = load i32, ptr %ncpus, align 4
  %cmp15 = icmp sgt i32 %8, 1073741823
  br i1 %cmp15, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end14
  %9 = load ptr, ptr @PyExc_OverflowError, align 8
  call void @PyErr_SetString(ptr noundef %9, ptr noundef @.str.312)
  store ptr null, ptr %retval, align 8
  br label %return

if.end18:                                         ; preds = %if.end14
  %10 = load i32, ptr %ncpus, align 4
  %mul19 = mul i32 %10, 2
  store i32 %mul19, ptr %ncpus, align 4
  br label %while.body

while.end:                                        ; preds = %if.then7
  %call20 = call ptr @PySet_New(ptr noundef null)
  store ptr %call20, ptr %res, align 8
  %11 = load ptr, ptr %res, align 8
  %cmp21 = icmp eq ptr %11, null
  br i1 %cmp21, label %if.then23, label %if.end24

if.then23:                                        ; preds = %while.end
  br label %error

if.end24:                                         ; preds = %while.end
  store i32 0, ptr %cpu, align 4
  %12 = load i64, ptr %setsize, align 8
  %13 = load ptr, ptr %mask, align 8
  %call25 = call i32 @__sched_cpucount(i64 noundef %12, ptr noundef %13) #10
  store i32 %call25, ptr %count, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end24
  %14 = load i32, ptr %count, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %15 = load i32, ptr %cpu, align 4
  %conv26 = sext i32 %15 to i64
  store i64 %conv26, ptr %__cpu, align 8
  %16 = load i64, ptr %__cpu, align 8
  %div27 = udiv i64 %16, 8
  %17 = load i64, ptr %setsize, align 8
  %cmp28 = icmp ult i64 %div27, %17
  br i1 %cmp28, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  %18 = load ptr, ptr %mask, align 8
  %__bits = getelementptr inbounds %struct.cpu_set_t, ptr %18, i32 0, i32 0
  %arraydecay = getelementptr inbounds [16 x i64], ptr %__bits, i64 0, i64 0
  %19 = load i64, ptr %__cpu, align 8
  %div30 = udiv i64 %19, 64
  %arrayidx = getelementptr i64, ptr %arraydecay, i64 %div30
  %20 = load i64, ptr %arrayidx, align 8
  %21 = load i64, ptr %__cpu, align 8
  %rem = urem i64 %21, 64
  %shl = shl i64 1, %rem
  %and = and i64 %20, %shl
  %cmp31 = icmp ne i64 %and, 0
  %conv32 = zext i1 %cmp31 to i32
  br label %cond.end

cond.false:                                       ; preds = %for.body
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv32, %cond.true ], [ 0, %cond.false ]
  store i32 %cond, ptr %tmp, align 4
  %22 = load i32, ptr %tmp, align 4
  %tobool33 = icmp ne i32 %22, 0
  br i1 %tobool33, label %if.then34, label %if.end45

if.then34:                                        ; preds = %cond.end
  %23 = load i32, ptr %cpu, align 4
  %conv35 = sext i32 %23 to i64
  %call36 = call ptr @PyLong_FromLong(i64 noundef %conv35)
  store ptr %call36, ptr %cpu_num, align 8
  %24 = load i32, ptr %count, align 4
  %dec = add i32 %24, -1
  store i32 %dec, ptr %count, align 4
  %25 = load ptr, ptr %cpu_num, align 8
  %cmp37 = icmp eq ptr %25, null
  br i1 %cmp37, label %if.then39, label %if.end40

if.then39:                                        ; preds = %if.then34
  br label %error

if.end40:                                         ; preds = %if.then34
  %26 = load ptr, ptr %res, align 8
  %27 = load ptr, ptr %cpu_num, align 8
  %call41 = call i32 @PySet_Add(ptr noundef %26, ptr noundef %27)
  %tobool42 = icmp ne i32 %call41, 0
  br i1 %tobool42, label %if.then43, label %if.end44

if.then43:                                        ; preds = %if.end40
  %28 = load ptr, ptr %cpu_num, align 8
  store ptr %28, ptr %op.addr.i49, align 8
  %29 = load ptr, ptr %op.addr.i49, align 8
  store ptr %29, ptr %op.addr.i58, align 8
  %30 = load ptr, ptr %op.addr.i58, align 8
  %31 = load i64, ptr %30, align 8
  %conv.i = trunc i64 %31 to i32
  %cmp.i59 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i59 to i32
  %tobool.i51 = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i51, label %if.then.i56, label %if.end.i52

if.then.i56:                                      ; preds = %if.then43
  br label %Py_DECREF.exit57

if.end.i52:                                       ; preds = %if.then43
  %32 = load ptr, ptr %op.addr.i49, align 8
  %33 = load i64, ptr %32, align 8
  %dec.i53 = add i64 %33, -1
  store i64 %dec.i53, ptr %32, align 8
  %cmp.i54 = icmp eq i64 %dec.i53, 0
  br i1 %cmp.i54, label %if.then1.i55, label %Py_DECREF.exit57

if.then1.i55:                                     ; preds = %if.end.i52
  %34 = load ptr, ptr %op.addr.i49, align 8
  call void @_Py_Dealloc(ptr noundef %34) #10
  br label %Py_DECREF.exit57

Py_DECREF.exit57:                                 ; preds = %if.then1.i55, %if.end.i52, %if.then.i56
  br label %error

if.end44:                                         ; preds = %if.end40
  %35 = load ptr, ptr %cpu_num, align 8
  store ptr %35, ptr %op.addr.i, align 8
  %36 = load ptr, ptr %op.addr.i, align 8
  store ptr %36, ptr %op.addr.i60, align 8
  %37 = load ptr, ptr %op.addr.i60, align 8
  %38 = load i64, ptr %37, align 8
  %conv.i61 = trunc i64 %38 to i32
  %cmp.i62 = icmp slt i32 %conv.i61, 0
  %conv1.i63 = zext i1 %cmp.i62 to i32
  %tobool.i = icmp ne i32 %conv1.i63, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.end44
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.end44
  %39 = load ptr, ptr %op.addr.i, align 8
  %40 = load i64, ptr %39, align 8
  %dec.i = add i64 %40, -1
  store i64 %dec.i, ptr %39, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %41 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %41) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  br label %if.end45

if.end45:                                         ; preds = %Py_DECREF.exit, %cond.end
  br label %for.inc

for.inc:                                          ; preds = %if.end45
  %42 = load i32, ptr %cpu, align 4
  %inc = add i32 %42, 1
  store i32 %inc, ptr %cpu, align 4
  br label %for.cond, !llvm.loop !21

for.end:                                          ; preds = %for.cond
  %43 = load ptr, ptr %mask, align 8
  call void @__sched_cpufree(ptr noundef %43) #10
  %44 = load ptr, ptr %res, align 8
  store ptr %44, ptr %retval, align 8
  br label %return

error:                                            ; preds = %Py_DECREF.exit57, %if.then39, %if.then23
  %45 = load ptr, ptr %mask, align 8
  %tobool46 = icmp ne ptr %45, null
  br i1 %tobool46, label %if.then47, label %if.end48

if.then47:                                        ; preds = %error
  %46 = load ptr, ptr %mask, align 8
  call void @__sched_cpufree(ptr noundef %46) #10
  br label %if.end48

if.end48:                                         ; preds = %if.then47, %error
  %47 = load ptr, ptr %res, align 8
  call void @Py_XDECREF(ptr noundef %47)
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end48, %for.end, %if.then17, %if.then12, %if.then
  %48 = load ptr, ptr %retval, align 8
  ret ptr %48
}

; Function Attrs: nounwind
declare i32 @sched_getaffinity(i32 noundef, i64 noundef, ptr noundef) #4

declare ptr @PySet_New(ptr noundef) #1

; Function Attrs: nounwind
declare i32 @__sched_cpucount(i64 noundef, ptr noundef) #4

declare i32 @PySet_Add(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @os_openpty_impl(ptr noundef %module) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %master_fd = alloca i32, align 4
  %slave_fd = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 -1, ptr %master_fd, align 4
  store i32 -1, ptr %slave_fd, align 4
  %call = call i32 @openpty(ptr noundef %master_fd, ptr noundef %slave_fd, ptr noundef null, ptr noundef null, ptr noundef null) #10
  %cmp = icmp ne i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %posix_error

if.end:                                           ; preds = %entry
  %0 = load i32, ptr %master_fd, align 4
  %call1 = call i32 @_Py_set_inheritable(i32 noundef %0, i32 noundef 0, ptr noundef null)
  %cmp2 = icmp slt i32 %call1, 0
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  br label %error

if.end4:                                          ; preds = %if.end
  %1 = load i32, ptr %slave_fd, align 4
  %call5 = call i32 @_Py_set_inheritable(i32 noundef %1, i32 noundef 0, ptr noundef null)
  %cmp6 = icmp slt i32 %call5, 0
  br i1 %cmp6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end4
  br label %error

if.end8:                                          ; preds = %if.end4
  %2 = load i32, ptr %master_fd, align 4
  %3 = load i32, ptr %slave_fd, align 4
  %call9 = call ptr (ptr, ...) @Py_BuildValue(ptr noundef @.str.313, i32 noundef %2, i32 noundef %3)
  store ptr %call9, ptr %retval, align 8
  br label %return

posix_error:                                      ; preds = %if.then
  %call10 = call ptr @posix_error()
  br label %error

error:                                            ; preds = %posix_error, %if.then7, %if.then3
  %4 = load i32, ptr %master_fd, align 4
  %cmp11 = icmp ne i32 %4, -1
  br i1 %cmp11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %error
  %5 = load i32, ptr %master_fd, align 4
  %call13 = call i32 @close(i32 noundef %5)
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %error
  %6 = load i32, ptr %slave_fd, align 4
  %cmp15 = icmp ne i32 %6, -1
  br i1 %cmp15, label %if.then16, label %if.end18

if.then16:                                        ; preds = %if.end14
  %7 = load i32, ptr %slave_fd, align 4
  %call17 = call i32 @close(i32 noundef %7)
  br label %if.end18

if.end18:                                         ; preds = %if.then16, %if.end14
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end18, %if.end8
  %8 = load ptr, ptr %retval, align 8
  ret ptr %8
}

; Function Attrs: nounwind
declare i32 @openpty(ptr noundef, ptr noundef, ptr noundef, ptr noundef, ptr noundef) #4

declare i32 @_Py_set_inheritable(i32 noundef, i32 noundef, ptr noundef) #1

declare ptr @Py_BuildValue(ptr noundef, ...) #1

declare i32 @_PyLong_FileDescriptor_Converter(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @os_login_tty_impl(ptr noundef %module, i32 noundef %fd) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  %0 = load i32, ptr %fd.addr, align 4
  %call = call i32 @login_tty(i32 noundef %0) #10
  %cmp = icmp eq i32 %call, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call ptr @posix_error()
  store ptr %call1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %1 = load ptr, ptr %retval, align 8
  ret ptr %1
}

; Function Attrs: nounwind
declare i32 @login_tty(i32 noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_forkpty_impl(ptr noundef %module) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %master_fd = alloca i32, align 4
  %pid = alloca i32, align 4
  %interp = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 -1, ptr %master_fd, align 4
  %call = call ptr @_PyInterpreterState_GET()
  store ptr %call, ptr %interp, align 8
  %0 = load ptr, ptr %interp, align 8
  %finalizing = getelementptr inbounds %struct._is, ptr %0, i32 0, i32 7
  %1 = load i32, ptr %finalizing, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr @PyExc_RuntimeError, align 8
  call void @PyErr_SetString(ptr noundef %2, ptr noundef @.str.289)
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %interp, align 8
  %call1 = call i32 @_Py_IsMainInterpreter(ptr noundef %3)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.end4, label %if.then3

if.then3:                                         ; preds = %if.end
  %4 = load ptr, ptr @PyExc_RuntimeError, align 8
  call void @PyErr_SetString(ptr noundef %4, ptr noundef @.str.314)
  store ptr null, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  %call5 = call i32 (ptr, ptr, ...) @PySys_Audit(ptr noundef @.str.315, ptr noundef null)
  %cmp = icmp slt i32 %call5, 0
  br i1 %cmp, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end4
  store ptr null, ptr %retval, align 8
  br label %return

if.end7:                                          ; preds = %if.end4
  call void @PyOS_BeforeFork()
  %call8 = call i32 @forkpty(ptr noundef %master_fd, ptr noundef null, ptr noundef null, ptr noundef null) #10
  store i32 %call8, ptr %pid, align 4
  %5 = load i32, ptr %pid, align 4
  %cmp9 = icmp eq i32 %5, 0
  br i1 %cmp9, label %if.then10, label %if.else

if.then10:                                        ; preds = %if.end7
  call void @PyOS_AfterFork_Child()
  br label %if.end11

if.else:                                          ; preds = %if.end7
  call void @warn_about_fork_with_threads(ptr noundef @.str.65)
  call void @PyOS_AfterFork_Parent()
  br label %if.end11

if.end11:                                         ; preds = %if.else, %if.then10
  %6 = load i32, ptr %pid, align 4
  %cmp12 = icmp eq i32 %6, -1
  br i1 %cmp12, label %if.then13, label %if.end15

if.then13:                                        ; preds = %if.end11
  %call14 = call ptr @posix_error()
  store ptr %call14, ptr %retval, align 8
  br label %return

if.end15:                                         ; preds = %if.end11
  %7 = load i32, ptr %pid, align 4
  %conv = sext i32 %7 to i64
  %call16 = call ptr @PyLong_FromLong(i64 noundef %conv)
  %8 = load i32, ptr %master_fd, align 4
  %call17 = call ptr (ptr, ...) @Py_BuildValue(ptr noundef @.str.316, ptr noundef %call16, i32 noundef %8)
  store ptr %call17, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end15, %if.then13, %if.then6, %if.then3, %if.then
  %9 = load ptr, ptr %retval, align 8
  ret ptr %9
}

; Function Attrs: nounwind uwtable
define internal i32 @_Py_IsMainInterpreter(ptr noundef %interp) #0 {
entry:
  %interp.addr = alloca ptr, align 8
  store ptr %interp, ptr %interp.addr, align 8
  %0 = load ptr, ptr %interp.addr, align 8
  %call = call ptr @_PyInterpreterState_Main()
  %cmp = icmp eq ptr %0, %call
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind
declare i32 @forkpty(ptr noundef, ptr noundef, ptr noundef, ptr noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @_PyInterpreterState_Main() #0 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 8, i32 2), align 8
  ret ptr %0
}

; Function Attrs: nounwind uwtable
define internal ptr @os_getegid_impl(ptr noundef %module) #0 {
entry:
  %module.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  %call = call i32 @getegid() #10
  %call1 = call ptr @_PyLong_FromGid(i32 noundef %call)
  ret ptr %call1
}

; Function Attrs: nounwind
declare i32 @getegid() #4

; Function Attrs: nounwind uwtable
define internal ptr @os_geteuid_impl(ptr noundef %module) #0 {
entry:
  %module.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  %call = call i32 @geteuid() #10
  %call1 = call ptr @_PyLong_FromUid(i32 noundef %call)
  ret ptr %call1
}

; Function Attrs: nounwind
declare i32 @geteuid() #4

; Function Attrs: nounwind uwtable
define internal ptr @os_getgid_impl(ptr noundef %module) #0 {
entry:
  %module.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  %call = call i32 @getgid() #10
  %call1 = call ptr @_PyLong_FromGid(i32 noundef %call)
  ret ptr %call1
}

; Function Attrs: nounwind
declare i32 @getgid() #4

declare void @_PyArg_BadArgument(ptr noundef, ptr noundef, ptr noundef, ptr noundef) #1

declare ptr @PyUnicode_AsUTF8AndSize(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @os_getgrouplist_impl(ptr noundef %module, ptr noundef %user, i32 noundef %basegid) #0 {
entry:
  %op.addr.i35 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %user.addr = alloca ptr, align 8
  %basegid.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %ngroups = alloca i32, align 4
  %list = alloca ptr, align 8
  %groups = alloca ptr, align 8
  %old_ngroups = alloca i32, align 4
  %o = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %user, ptr %user.addr, align 8
  store i32 %basegid, ptr %basegid.addr, align 4
  store i32 65537, ptr %ngroups, align 4
  br label %while.body

while.body:                                       ; preds = %if.end20, %entry
  %0 = load i32, ptr %ngroups, align 4
  %conv = sext i32 %0 to i64
  %cmp = icmp ugt i64 %conv, 2305843009213693951
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %while.body
  br label %cond.end

cond.false:                                       ; preds = %while.body
  %1 = load i32, ptr %ngroups, align 4
  %conv2 = sext i32 %1 to i64
  %mul = mul i64 %conv2, 4
  %call = call ptr @PyMem_Malloc(i64 noundef %mul)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ null, %cond.true ], [ %call, %cond.false ]
  store ptr %cond, ptr %groups, align 8
  %2 = load ptr, ptr %groups, align 8
  %cmp3 = icmp eq ptr %2, null
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  %call5 = call ptr @PyErr_NoMemory()
  store ptr %call5, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end
  %3 = load i32, ptr %ngroups, align 4
  store i32 %3, ptr %old_ngroups, align 4
  %4 = load ptr, ptr %user.addr, align 8
  %5 = load i32, ptr %basegid.addr, align 4
  %6 = load ptr, ptr %groups, align 8
  %call6 = call i32 @getgrouplist(ptr noundef %4, i32 noundef %5, ptr noundef %6, ptr noundef %ngroups)
  %cmp7 = icmp ne i32 %call6, -1
  br i1 %cmp7, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end
  br label %while.end

if.end10:                                         ; preds = %if.end
  %7 = load ptr, ptr %groups, align 8
  call void @PyMem_Free(ptr noundef %7)
  %8 = load i32, ptr %ngroups, align 4
  %9 = load i32, ptr %old_ngroups, align 4
  %cmp11 = icmp sgt i32 %8, %9
  br i1 %cmp11, label %if.then13, label %if.else

if.then13:                                        ; preds = %if.end10
  br label %if.end20

if.else:                                          ; preds = %if.end10
  %10 = load i32, ptr %ngroups, align 4
  %cmp14 = icmp sgt i32 %10, 1073741823
  br i1 %cmp14, label %if.then16, label %if.end18

if.then16:                                        ; preds = %if.else
  %call17 = call ptr @PyErr_NoMemory()
  store ptr %call17, ptr %retval, align 8
  br label %return

if.end18:                                         ; preds = %if.else
  %11 = load i32, ptr %ngroups, align 4
  %mul19 = mul i32 %11, 2
  store i32 %mul19, ptr %ngroups, align 4
  br label %if.end20

if.end20:                                         ; preds = %if.end18, %if.then13
  br label %while.body

while.end:                                        ; preds = %if.then9
  %12 = load i32, ptr %ngroups, align 4
  %conv21 = sext i32 %12 to i64
  %call22 = call ptr @PyList_New(i64 noundef %conv21)
  store ptr %call22, ptr %list, align 8
  %13 = load ptr, ptr %list, align 8
  %cmp23 = icmp eq ptr %13, null
  br i1 %cmp23, label %if.then25, label %if.end26

if.then25:                                        ; preds = %while.end
  %14 = load ptr, ptr %groups, align 8
  call void @PyMem_Free(ptr noundef %14)
  store ptr null, ptr %retval, align 8
  br label %return

if.end26:                                         ; preds = %while.end
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end26
  %15 = load i32, ptr %i, align 4
  %16 = load i32, ptr %ngroups, align 4
  %cmp27 = icmp slt i32 %15, %16
  br i1 %cmp27, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %17 = load ptr, ptr %groups, align 8
  %18 = load i32, ptr %i, align 4
  %idxprom = sext i32 %18 to i64
  %arrayidx = getelementptr i32, ptr %17, i64 %idxprom
  %19 = load i32, ptr %arrayidx, align 4
  %call29 = call ptr @_PyLong_FromGid(i32 noundef %19)
  store ptr %call29, ptr %o, align 8
  %20 = load ptr, ptr %o, align 8
  %cmp30 = icmp eq ptr %20, null
  br i1 %cmp30, label %if.then32, label %if.end33

if.then32:                                        ; preds = %for.body
  %21 = load ptr, ptr %list, align 8
  store ptr %21, ptr %op.addr.i, align 8
  %22 = load ptr, ptr %op.addr.i, align 8
  store ptr %22, ptr %op.addr.i35, align 8
  %23 = load ptr, ptr %op.addr.i35, align 8
  %24 = load i64, ptr %23, align 8
  %conv.i = trunc i64 %24 to i32
  %cmp.i36 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i36 to i32
  %tobool.i = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then32
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.then32
  %25 = load ptr, ptr %op.addr.i, align 8
  %26 = load i64, ptr %25, align 8
  %dec.i = add i64 %26, -1
  store i64 %dec.i, ptr %25, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %27 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %27) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  %28 = load ptr, ptr %groups, align 8
  call void @PyMem_Free(ptr noundef %28)
  store ptr null, ptr %retval, align 8
  br label %return

if.end33:                                         ; preds = %for.body
  %29 = load ptr, ptr %list, align 8
  %30 = load i32, ptr %i, align 4
  %conv34 = sext i32 %30 to i64
  %31 = load ptr, ptr %o, align 8
  call void @PyList_SET_ITEM(ptr noundef %29, i64 noundef %conv34, ptr noundef %31)
  br label %for.inc

for.inc:                                          ; preds = %if.end33
  %32 = load i32, ptr %i, align 4
  %inc = add i32 %32, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !22

for.end:                                          ; preds = %for.cond
  %33 = load ptr, ptr %groups, align 8
  call void @PyMem_Free(ptr noundef %33)
  %34 = load ptr, ptr %list, align 8
  store ptr %34, ptr %retval, align 8
  br label %return

return:                                           ; preds = %for.end, %Py_DECREF.exit, %if.then25, %if.then16, %if.then
  %35 = load ptr, ptr %retval, align 8
  ret ptr %35
}

declare i32 @getgrouplist(ptr noundef, i32 noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal void @PyList_SET_ITEM(ptr noundef %op, i64 noundef %index, ptr noundef %value) #0 {
entry:
  %op.addr = alloca ptr, align 8
  %index.addr = alloca i64, align 8
  %value.addr = alloca ptr, align 8
  %list = alloca ptr, align 8
  store ptr %op, ptr %op.addr, align 8
  store i64 %index, ptr %index.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  %0 = load ptr, ptr %op.addr, align 8
  store ptr %0, ptr %list, align 8
  %1 = load ptr, ptr %value.addr, align 8
  %2 = load ptr, ptr %list, align 8
  %ob_item = getelementptr inbounds %struct.PyListObject, ptr %2, i32 0, i32 1
  %3 = load ptr, ptr %ob_item, align 8
  %4 = load i64, ptr %index.addr, align 8
  %arrayidx = getelementptr ptr, ptr %3, i64 %4
  store ptr %1, ptr %arrayidx, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal ptr @os_getgroups_impl(ptr noundef %module) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %n = alloca i32, align 4
  %grouplist = alloca ptr, align 8
  %result = alloca ptr, align 8
  %i = alloca i32, align 4
  %group = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  %call = call i32 @getgroups(i32 noundef 0, ptr noundef null) #10
  store i32 %call, ptr %n, align 4
  %0 = load i32, ptr %n, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call ptr @posix_error()
  store ptr %call1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, ptr %n, align 4
  %cmp2 = icmp eq i32 %1, 0
  br i1 %cmp2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %call4 = call ptr @PyList_New(i64 noundef 0)
  store ptr %call4, ptr %retval, align 8
  br label %return

if.end5:                                          ; preds = %if.end
  %2 = load i32, ptr %n, align 4
  %conv = sext i32 %2 to i64
  %cmp6 = icmp ugt i64 %conv, 2305843009213693951
  br i1 %cmp6, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end5
  br label %cond.end

cond.false:                                       ; preds = %if.end5
  %3 = load i32, ptr %n, align 4
  %conv8 = sext i32 %3 to i64
  %mul = mul i64 %conv8, 4
  %call9 = call ptr @PyMem_Malloc(i64 noundef %mul)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ null, %cond.true ], [ %call9, %cond.false ]
  store ptr %cond, ptr %grouplist, align 8
  %4 = load ptr, ptr %grouplist, align 8
  %cmp10 = icmp eq ptr %4, null
  br i1 %cmp10, label %if.then12, label %if.end14

if.then12:                                        ; preds = %cond.end
  %call13 = call ptr @PyErr_NoMemory()
  store ptr %call13, ptr %retval, align 8
  br label %return

if.end14:                                         ; preds = %cond.end
  %5 = load i32, ptr %n, align 4
  %6 = load ptr, ptr %grouplist, align 8
  %call15 = call i32 @getgroups(i32 noundef %5, ptr noundef %6) #10
  store i32 %call15, ptr %n, align 4
  %7 = load i32, ptr %n, align 4
  %cmp16 = icmp eq i32 %7, -1
  br i1 %cmp16, label %if.then18, label %if.end20

if.then18:                                        ; preds = %if.end14
  %call19 = call ptr @posix_error()
  %8 = load ptr, ptr %grouplist, align 8
  call void @PyMem_Free(ptr noundef %8)
  store ptr null, ptr %retval, align 8
  br label %return

if.end20:                                         ; preds = %if.end14
  %9 = load i32, ptr %n, align 4
  %conv21 = sext i32 %9 to i64
  %call22 = call ptr @PyList_New(i64 noundef %conv21)
  store ptr %call22, ptr %result, align 8
  %10 = load ptr, ptr %result, align 8
  %cmp23 = icmp eq ptr %10, null
  br i1 %cmp23, label %if.then25, label %if.end26

if.then25:                                        ; preds = %if.end20
  br label %error

if.end26:                                         ; preds = %if.end20
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end26
  %11 = load i32, ptr %i, align 4
  %12 = load i32, ptr %n, align 4
  %cmp27 = icmp slt i32 %11, %12
  br i1 %cmp27, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %13 = load ptr, ptr %grouplist, align 8
  %14 = load i32, ptr %i, align 4
  %idxprom = sext i32 %14 to i64
  %arrayidx = getelementptr i32, ptr %13, i64 %idxprom
  %15 = load i32, ptr %arrayidx, align 4
  %call29 = call ptr @_PyLong_FromGid(i32 noundef %15)
  store ptr %call29, ptr %group, align 8
  %16 = load ptr, ptr %group, align 8
  %cmp30 = icmp eq ptr %16, null
  br i1 %cmp30, label %if.then32, label %if.end33

if.then32:                                        ; preds = %for.body
  br label %error

if.end33:                                         ; preds = %for.body
  %17 = load ptr, ptr %result, align 8
  %18 = load i32, ptr %i, align 4
  %conv34 = sext i32 %18 to i64
  %19 = load ptr, ptr %group, align 8
  call void @PyList_SET_ITEM(ptr noundef %17, i64 noundef %conv34, ptr noundef %19)
  br label %for.inc

for.inc:                                          ; preds = %if.end33
  %20 = load i32, ptr %i, align 4
  %inc = add i32 %20, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !23

for.end:                                          ; preds = %for.cond
  %21 = load ptr, ptr %grouplist, align 8
  call void @PyMem_Free(ptr noundef %21)
  %22 = load ptr, ptr %result, align 8
  store ptr %22, ptr %retval, align 8
  br label %return

error:                                            ; preds = %if.then32, %if.then25
  %23 = load ptr, ptr %grouplist, align 8
  call void @PyMem_Free(ptr noundef %23)
  %24 = load ptr, ptr %result, align 8
  call void @Py_XDECREF(ptr noundef %24)
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %error, %for.end, %if.then18, %if.then12, %if.then3, %if.then
  %25 = load ptr, ptr %retval, align 8
  ret ptr %25
}

; Function Attrs: nounwind
declare i32 @getgroups(i32 noundef, ptr noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_getpid_impl(ptr noundef %module) #0 {
entry:
  %module.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  %call = call i32 @getpid() #10
  %conv = sext i32 %call to i64
  %call1 = call ptr @PyLong_FromLong(i64 noundef %conv)
  ret ptr %call1
}

; Function Attrs: nounwind uwtable
define internal ptr @os_getpgrp_impl(ptr noundef %module) #0 {
entry:
  %module.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  %call = call i32 @getpgrp() #10
  %conv = sext i32 %call to i64
  %call1 = call ptr @PyLong_FromLong(i64 noundef %conv)
  ret ptr %call1
}

; Function Attrs: nounwind
declare i32 @getpgrp() #4

; Function Attrs: nounwind uwtable
define internal ptr @os_getppid_impl(ptr noundef %module) #0 {
entry:
  %module.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  %call = call i32 @getppid() #10
  %conv = sext i32 %call to i64
  %call1 = call ptr @PyLong_FromLong(i64 noundef %conv)
  ret ptr %call1
}

; Function Attrs: nounwind
declare i32 @getppid() #4

; Function Attrs: nounwind uwtable
define internal ptr @os_getuid_impl(ptr noundef %module) #0 {
entry:
  %module.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  %call = call i32 @getuid() #10
  %call1 = call ptr @_PyLong_FromUid(i32 noundef %call)
  ret ptr %call1
}

; Function Attrs: nounwind
declare i32 @getuid() #4

; Function Attrs: nounwind uwtable
define internal ptr @os_getlogin_impl(ptr noundef %module) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %result = alloca ptr, align 8
  %name = alloca ptr, align 8
  %old_errno = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr null, ptr %result, align 8
  %call = call ptr @__errno_location() #12
  %0 = load i32, ptr %call, align 4
  store i32 %0, ptr %old_errno, align 4
  %call1 = call ptr @__errno_location() #12
  store i32 0, ptr %call1, align 4
  %call2 = call ptr @getlogin()
  store ptr %call2, ptr %name, align 8
  %1 = load ptr, ptr %name, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.else6

if.then:                                          ; preds = %entry
  %call3 = call ptr @__errno_location() #12
  %2 = load i32, ptr %call3, align 4
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.then
  %call5 = call ptr @posix_error()
  br label %if.end

if.else:                                          ; preds = %if.then
  %3 = load ptr, ptr @PyExc_OSError, align 8
  call void @PyErr_SetString(ptr noundef %3, ptr noundef @.str.320)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then4
  br label %if.end8

if.else6:                                         ; preds = %entry
  %4 = load ptr, ptr %name, align 8
  %call7 = call ptr @PyUnicode_DecodeFSDefault(ptr noundef %4)
  store ptr %call7, ptr %result, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.else6, %if.end
  %5 = load i32, ptr %old_errno, align 4
  %call9 = call ptr @__errno_location() #12
  store i32 %5, ptr %call9, align 4
  %6 = load ptr, ptr %result, align 8
  ret ptr %6
}

declare ptr @getlogin() #1

; Function Attrs: nounwind uwtable
define internal ptr @os_kill_impl(ptr noundef %module, i32 noundef %pid, i64 noundef %signal) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %pid.addr = alloca i32, align 4
  %signal.addr = alloca i64, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %pid, ptr %pid.addr, align 4
  store i64 %signal, ptr %signal.addr, align 8
  %0 = load i32, ptr %pid.addr, align 4
  %1 = load i64, ptr %signal.addr, align 8
  %call = call i32 (ptr, ptr, ...) @PySys_Audit(ptr noundef @.str.322, ptr noundef @.str.323, i32 noundef %0, i64 noundef %1)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %pid.addr, align 4
  %3 = load i64, ptr %signal.addr, align 8
  %conv = trunc i64 %3 to i32
  %call1 = call i32 @kill(i32 noundef %2, i32 noundef %conv) #10
  %cmp2 = icmp eq i32 %call1, -1
  br i1 %cmp2, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call ptr @posix_error()
  store ptr %call5, ptr %retval, align 8
  br label %return

if.end6:                                          ; preds = %if.end
  %call7 = call i32 @PyErr_CheckSignals()
  %tobool = icmp ne i32 %call7, 0
  br i1 %tobool, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end6
  store ptr null, ptr %retval, align 8
  br label %return

if.end9:                                          ; preds = %if.end6
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end9, %if.then8, %if.then4, %if.then
  %4 = load ptr, ptr %retval, align 8
  ret ptr %4
}

; Function Attrs: nounwind
declare i32 @kill(i32 noundef, i32 noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_killpg_impl(ptr noundef %module, i32 noundef %pgid, i32 noundef %signal) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %pgid.addr = alloca i32, align 4
  %signal.addr = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %pgid, ptr %pgid.addr, align 4
  store i32 %signal, ptr %signal.addr, align 4
  %0 = load i32, ptr %pgid.addr, align 4
  %1 = load i32, ptr %signal.addr, align 4
  %call = call i32 (ptr, ptr, ...) @PySys_Audit(ptr noundef @.str.325, ptr noundef @.str.326, i32 noundef %0, i32 noundef %1)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %pgid.addr, align 4
  %3 = load i32, ptr %signal.addr, align 4
  %call1 = call i32 @killpg(i32 noundef %2, i32 noundef %3) #10
  %cmp2 = icmp eq i32 %call1, -1
  br i1 %cmp2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %call4 = call ptr @posix_error()
  store ptr %call4, ptr %retval, align 8
  br label %return

if.end5:                                          ; preds = %if.end
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end5, %if.then3, %if.then
  %4 = load ptr, ptr %retval, align 8
  ret ptr %4
}

; Function Attrs: nounwind
declare i32 @killpg(i32 noundef, i32 noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_setuid_impl(ptr noundef %module, i32 noundef %uid) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %uid.addr = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %uid, ptr %uid.addr, align 4
  %0 = load i32, ptr %uid.addr, align 4
  %call = call i32 @setuid(i32 noundef %0) #10
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call ptr @posix_error()
  store ptr %call1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %1 = load ptr, ptr %retval, align 8
  ret ptr %1
}

; Function Attrs: nounwind
declare i32 @setuid(i32 noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_seteuid_impl(ptr noundef %module, i32 noundef %euid) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %euid.addr = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %euid, ptr %euid.addr, align 4
  %0 = load i32, ptr %euid.addr, align 4
  %call = call i32 @seteuid(i32 noundef %0) #10
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call ptr @posix_error()
  store ptr %call1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %1 = load ptr, ptr %retval, align 8
  ret ptr %1
}

; Function Attrs: nounwind
declare i32 @seteuid(i32 noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_setreuid_impl(ptr noundef %module, i32 noundef %ruid, i32 noundef %euid) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %ruid.addr = alloca i32, align 4
  %euid.addr = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %ruid, ptr %ruid.addr, align 4
  store i32 %euid, ptr %euid.addr, align 4
  %0 = load i32, ptr %ruid.addr, align 4
  %1 = load i32, ptr %euid.addr, align 4
  %call = call i32 @setreuid(i32 noundef %0, i32 noundef %1) #10
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call1 = call ptr @posix_error()
  store ptr %call1, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %2 = load ptr, ptr %retval, align 8
  ret ptr %2
}

; Function Attrs: nounwind
declare i32 @setreuid(i32 noundef, i32 noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_setgid_impl(ptr noundef %module, i32 noundef %gid) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %gid.addr = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %gid, ptr %gid.addr, align 4
  %0 = load i32, ptr %gid.addr, align 4
  %call = call i32 @setgid(i32 noundef %0) #10
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call ptr @posix_error()
  store ptr %call1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %1 = load ptr, ptr %retval, align 8
  ret ptr %1
}

; Function Attrs: nounwind
declare i32 @setgid(i32 noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_setegid_impl(ptr noundef %module, i32 noundef %egid) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %egid.addr = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %egid, ptr %egid.addr, align 4
  %0 = load i32, ptr %egid.addr, align 4
  %call = call i32 @setegid(i32 noundef %0) #10
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call ptr @posix_error()
  store ptr %call1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %1 = load ptr, ptr %retval, align 8
  ret ptr %1
}

; Function Attrs: nounwind
declare i32 @setegid(i32 noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_setregid_impl(ptr noundef %module, i32 noundef %rgid, i32 noundef %egid) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %rgid.addr = alloca i32, align 4
  %egid.addr = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %rgid, ptr %rgid.addr, align 4
  store i32 %egid, ptr %egid.addr, align 4
  %0 = load i32, ptr %rgid.addr, align 4
  %1 = load i32, ptr %egid.addr, align 4
  %call = call i32 @setregid(i32 noundef %0, i32 noundef %1) #10
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call ptr @posix_error()
  store ptr %call1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load ptr, ptr %retval, align 8
  ret ptr %2
}

; Function Attrs: nounwind
declare i32 @setregid(i32 noundef, i32 noundef) #4

declare i32 @PySequence_Check(ptr noundef) #1

declare ptr @PySequence_GetItem(ptr noundef, i64 noundef) #1

; Function Attrs: nounwind
declare i32 @setgroups(i64 noundef, ptr noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_initgroups_impl(ptr noundef %module, ptr noundef %oname, i32 noundef %gid) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %oname.addr = alloca ptr, align 8
  %gid.addr = alloca i32, align 4
  %username = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %oname, ptr %oname.addr, align 8
  store i32 %gid, ptr %gid.addr, align 4
  %0 = load ptr, ptr %oname.addr, align 8
  %call = call ptr @PyBytes_AS_STRING(ptr noundef %0)
  store ptr %call, ptr %username, align 8
  %1 = load ptr, ptr %username, align 8
  %2 = load i32, ptr %gid.addr, align 4
  %call1 = call i32 @initgroups(ptr noundef %1, i32 noundef %2)
  %cmp = icmp eq i32 %call1, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr @PyExc_OSError, align 8
  %call2 = call ptr @PyErr_SetFromErrno(ptr noundef %3)
  store ptr %call2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load ptr, ptr %retval, align 8
  ret ptr %4
}

declare i32 @initgroups(ptr noundef, i32 noundef) #1

declare i32 @_PyArg_ParseStackAndKeywords(ptr noundef, i64 noundef, ptr noundef, ptr noundef, ...) #1

; Function Attrs: nounwind uwtable
define internal ptr @os_getpgid_impl(ptr noundef %module, i32 noundef %pid) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %pid.addr = alloca i32, align 4
  %pgid = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %pid, ptr %pid.addr, align 4
  %0 = load i32, ptr %pid.addr, align 4
  %call = call i32 @getpgid(i32 noundef %0) #10
  store i32 %call, ptr %pgid, align 4
  %1 = load i32, ptr %pgid, align 4
  %cmp = icmp slt i32 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call ptr @posix_error()
  store ptr %call1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %pgid, align 4
  %conv = sext i32 %2 to i64
  %call2 = call ptr @PyLong_FromLong(i64 noundef %conv)
  store ptr %call2, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load ptr, ptr %retval, align 8
  ret ptr %3
}

; Function Attrs: nounwind
declare i32 @getpgid(i32 noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_setpgrp_impl(ptr noundef %module) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  %call = call i32 @setpgrp() #10
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call ptr @posix_error()
  store ptr %call1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %0 = load ptr, ptr %retval, align 8
  ret ptr %0
}

; Function Attrs: nounwind
declare i32 @setpgrp() #4

; Function Attrs: nounwind uwtable
define internal ptr @os_wait_impl(ptr noundef %module) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %pid = alloca i32, align 4
  %async_err = alloca i32, align 4
  %status = alloca i32, align 4
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 0, ptr %async_err, align 4
  store i32 0, ptr %status, align 4
  br label %do.body

do.body:                                          ; preds = %land.end, %entry
  %call = call ptr @PyEval_SaveThread()
  store ptr %call, ptr %_save, align 8
  %call1 = call i32 @wait(ptr noundef %status)
  store i32 %call1, ptr %pid, align 4
  %0 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %0)
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %1 = load i32, ptr %pid, align 4
  %cmp = icmp slt i32 %1, 0
  br i1 %cmp, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %do.cond
  %call2 = call ptr @__errno_location() #12
  %2 = load i32, ptr %call2, align 4
  %cmp3 = icmp eq i32 %2, 4
  br i1 %cmp3, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %call4 = call i32 @PyErr_CheckSignals()
  store i32 %call4, ptr %async_err, align 4
  %tobool = icmp ne i32 %call4, 0
  %lnot = xor i1 %tobool, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %do.cond
  %3 = phi i1 [ false, %land.lhs.true ], [ false, %do.cond ], [ %lnot, %land.rhs ]
  br i1 %3, label %do.body, label %do.end, !llvm.loop !24

do.end:                                           ; preds = %land.end
  %4 = load i32, ptr %pid, align 4
  %cmp5 = icmp slt i32 %4, 0
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %do.end
  %5 = load i32, ptr %async_err, align 4
  %tobool6 = icmp ne i32 %5, 0
  br i1 %tobool6, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then
  %call7 = call ptr @posix_error()
  br label %cond.end

cond.false:                                       ; preds = %if.then
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call7, %cond.true ], [ null, %cond.false ]
  store ptr %cond, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %do.end
  %6 = load i32, ptr %pid, align 4
  %conv = sext i32 %6 to i64
  %call8 = call ptr @PyLong_FromLong(i64 noundef %conv)
  %7 = load i32, ptr %status, align 4
  %call9 = call ptr (ptr, ...) @Py_BuildValue(ptr noundef @.str.332, ptr noundef %call8, i32 noundef %7)
  store ptr %call9, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %cond.end
  %8 = load ptr, ptr %retval, align 8
  ret ptr %8
}

declare i32 @wait(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @os_wait3_impl(ptr noundef %module, i32 noundef %options) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %options.addr = alloca i32, align 4
  %pid = alloca i32, align 4
  %ru = alloca %struct.rusage, align 8
  %async_err = alloca i32, align 4
  %status = alloca i32, align 4
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %options, ptr %options.addr, align 4
  store i32 0, ptr %async_err, align 4
  store i32 0, ptr %status, align 4
  br label %do.body

do.body:                                          ; preds = %land.end, %entry
  %call = call ptr @PyEval_SaveThread()
  store ptr %call, ptr %_save, align 8
  %0 = load i32, ptr %options.addr, align 4
  %call1 = call i32 @wait3(ptr noundef %status, i32 noundef %0, ptr noundef %ru) #10
  store i32 %call1, ptr %pid, align 4
  %1 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %1)
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %2 = load i32, ptr %pid, align 4
  %cmp = icmp slt i32 %2, 0
  br i1 %cmp, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %do.cond
  %call2 = call ptr @__errno_location() #12
  %3 = load i32, ptr %call2, align 4
  %cmp3 = icmp eq i32 %3, 4
  br i1 %cmp3, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %call4 = call i32 @PyErr_CheckSignals()
  store i32 %call4, ptr %async_err, align 4
  %tobool = icmp ne i32 %call4, 0
  %lnot = xor i1 %tobool, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %do.cond
  %4 = phi i1 [ false, %land.lhs.true ], [ false, %do.cond ], [ %lnot, %land.rhs ]
  br i1 %4, label %do.body, label %do.end, !llvm.loop !25

do.end:                                           ; preds = %land.end
  %5 = load i32, ptr %pid, align 4
  %cmp5 = icmp slt i32 %5, 0
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %do.end
  %6 = load i32, ptr %async_err, align 4
  %tobool6 = icmp ne i32 %6, 0
  br i1 %tobool6, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then
  %call7 = call ptr @posix_error()
  br label %cond.end

cond.false:                                       ; preds = %if.then
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call7, %cond.true ], [ null, %cond.false ]
  store ptr %cond, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %do.end
  %7 = load ptr, ptr %module.addr, align 8
  %8 = load i32, ptr %pid, align 4
  %9 = load i32, ptr %status, align 4
  %call8 = call ptr @wait_helper(ptr noundef %7, i32 noundef %8, i32 noundef %9, ptr noundef %ru)
  store ptr %call8, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %cond.end
  %10 = load ptr, ptr %retval, align 8
  ret ptr %10
}

; Function Attrs: nounwind
declare i32 @wait3(ptr noundef, i32 noundef, ptr noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @wait_helper(ptr noundef %module, i32 noundef %pid, i32 noundef %status, ptr noundef %ru) #0 {
entry:
  %op.addr.i52 = alloca ptr, align 8
  %op.addr.i50 = alloca ptr, align 8
  %op.addr.i41 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %pid.addr = alloca i32, align 4
  %status.addr = alloca i32, align 4
  %ru.addr = alloca ptr, align 8
  %result = alloca ptr, align 8
  %struct_rusage = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %pid, ptr %pid.addr, align 4
  store i32 %status, ptr %status.addr, align 4
  store ptr %ru, ptr %ru.addr, align 8
  %0 = load i32, ptr %pid.addr, align 4
  %cmp = icmp eq i32 %0, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call ptr @posix_error()
  store ptr %call, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, ptr %pid.addr, align 4
  %cmp1 = icmp eq i32 %1, 0
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %2 = load ptr, ptr %ru.addr, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %2, i8 0, i64 144, i1 false)
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end
  %call4 = call ptr @_PyImport_GetModuleAttrString(ptr noundef @.str.334, ptr noundef @.str.335)
  store ptr %call4, ptr %struct_rusage, align 8
  %3 = load ptr, ptr %struct_rusage, align 8
  %cmp5 = icmp eq ptr %3, null
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end3
  store ptr null, ptr %retval, align 8
  br label %return

if.end7:                                          ; preds = %if.end3
  %4 = load ptr, ptr %struct_rusage, align 8
  %call8 = call ptr @PyStructSequence_New(ptr noundef %4)
  store ptr %call8, ptr %result, align 8
  %5 = load ptr, ptr %struct_rusage, align 8
  store ptr %5, ptr %op.addr.i41, align 8
  %6 = load ptr, ptr %op.addr.i41, align 8
  store ptr %6, ptr %op.addr.i50, align 8
  %7 = load ptr, ptr %op.addr.i50, align 8
  %8 = load i64, ptr %7, align 8
  %conv.i = trunc i64 %8 to i32
  %cmp.i51 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i51 to i32
  %tobool.i43 = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i43, label %if.then.i48, label %if.end.i44

if.then.i48:                                      ; preds = %if.end7
  br label %Py_DECREF.exit49

if.end.i44:                                       ; preds = %if.end7
  %9 = load ptr, ptr %op.addr.i41, align 8
  %10 = load i64, ptr %9, align 8
  %dec.i45 = add i64 %10, -1
  store i64 %dec.i45, ptr %9, align 8
  %cmp.i46 = icmp eq i64 %dec.i45, 0
  br i1 %cmp.i46, label %if.then1.i47, label %Py_DECREF.exit49

if.then1.i47:                                     ; preds = %if.end.i44
  %11 = load ptr, ptr %op.addr.i41, align 8
  call void @_Py_Dealloc(ptr noundef %11) #10
  br label %Py_DECREF.exit49

Py_DECREF.exit49:                                 ; preds = %if.then1.i47, %if.end.i44, %if.then.i48
  %12 = load ptr, ptr %result, align 8
  %tobool = icmp ne ptr %12, null
  br i1 %tobool, label %if.end10, label %if.then9

if.then9:                                         ; preds = %Py_DECREF.exit49
  store ptr null, ptr %retval, align 8
  br label %return

if.end10:                                         ; preds = %Py_DECREF.exit49
  %13 = load ptr, ptr %result, align 8
  %14 = load ptr, ptr %ru.addr, align 8
  %ru_utime = getelementptr inbounds %struct.rusage, ptr %14, i32 0, i32 0
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %ru_utime, i32 0, i32 0
  %15 = load i64, ptr %tv_sec, align 8
  %conv = sitofp i64 %15 to double
  %16 = load ptr, ptr %ru.addr, align 8
  %ru_utime11 = getelementptr inbounds %struct.rusage, ptr %16, i32 0, i32 0
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %ru_utime11, i32 0, i32 1
  %17 = load i64, ptr %tv_usec, align 8
  %conv12 = sitofp i64 %17 to double
  %18 = call double @llvm.fmuladd.f64(double %conv12, double 0x3EB0C6F7A0B5ED8D, double %conv)
  %call13 = call ptr @PyFloat_FromDouble(double noundef %18)
  call void @PyStructSequence_SetItem(ptr noundef %13, i64 noundef 0, ptr noundef %call13)
  %19 = load ptr, ptr %result, align 8
  %20 = load ptr, ptr %ru.addr, align 8
  %ru_stime = getelementptr inbounds %struct.rusage, ptr %20, i32 0, i32 1
  %tv_sec14 = getelementptr inbounds %struct.timeval, ptr %ru_stime, i32 0, i32 0
  %21 = load i64, ptr %tv_sec14, align 8
  %conv15 = sitofp i64 %21 to double
  %22 = load ptr, ptr %ru.addr, align 8
  %ru_stime16 = getelementptr inbounds %struct.rusage, ptr %22, i32 0, i32 1
  %tv_usec17 = getelementptr inbounds %struct.timeval, ptr %ru_stime16, i32 0, i32 1
  %23 = load i64, ptr %tv_usec17, align 8
  %conv18 = sitofp i64 %23 to double
  %24 = call double @llvm.fmuladd.f64(double %conv18, double 0x3EB0C6F7A0B5ED8D, double %conv15)
  %call19 = call ptr @PyFloat_FromDouble(double noundef %24)
  call void @PyStructSequence_SetItem(ptr noundef %19, i64 noundef 1, ptr noundef %call19)
  %25 = load ptr, ptr %result, align 8
  %26 = load ptr, ptr %ru.addr, align 8
  %27 = getelementptr inbounds %struct.rusage, ptr %26, i32 0, i32 2
  %28 = load i64, ptr %27, align 8
  %call20 = call ptr @PyLong_FromLong(i64 noundef %28)
  call void @PyStructSequence_SetItem(ptr noundef %25, i64 noundef 2, ptr noundef %call20)
  %29 = load ptr, ptr %result, align 8
  %30 = load ptr, ptr %ru.addr, align 8
  %31 = getelementptr inbounds %struct.rusage, ptr %30, i32 0, i32 3
  %32 = load i64, ptr %31, align 8
  %call21 = call ptr @PyLong_FromLong(i64 noundef %32)
  call void @PyStructSequence_SetItem(ptr noundef %29, i64 noundef 3, ptr noundef %call21)
  %33 = load ptr, ptr %result, align 8
  %34 = load ptr, ptr %ru.addr, align 8
  %35 = getelementptr inbounds %struct.rusage, ptr %34, i32 0, i32 4
  %36 = load i64, ptr %35, align 8
  %call22 = call ptr @PyLong_FromLong(i64 noundef %36)
  call void @PyStructSequence_SetItem(ptr noundef %33, i64 noundef 4, ptr noundef %call22)
  %37 = load ptr, ptr %result, align 8
  %38 = load ptr, ptr %ru.addr, align 8
  %39 = getelementptr inbounds %struct.rusage, ptr %38, i32 0, i32 5
  %40 = load i64, ptr %39, align 8
  %call23 = call ptr @PyLong_FromLong(i64 noundef %40)
  call void @PyStructSequence_SetItem(ptr noundef %37, i64 noundef 5, ptr noundef %call23)
  %41 = load ptr, ptr %result, align 8
  %42 = load ptr, ptr %ru.addr, align 8
  %43 = getelementptr inbounds %struct.rusage, ptr %42, i32 0, i32 6
  %44 = load i64, ptr %43, align 8
  %call24 = call ptr @PyLong_FromLong(i64 noundef %44)
  call void @PyStructSequence_SetItem(ptr noundef %41, i64 noundef 6, ptr noundef %call24)
  %45 = load ptr, ptr %result, align 8
  %46 = load ptr, ptr %ru.addr, align 8
  %47 = getelementptr inbounds %struct.rusage, ptr %46, i32 0, i32 7
  %48 = load i64, ptr %47, align 8
  %call25 = call ptr @PyLong_FromLong(i64 noundef %48)
  call void @PyStructSequence_SetItem(ptr noundef %45, i64 noundef 7, ptr noundef %call25)
  %49 = load ptr, ptr %result, align 8
  %50 = load ptr, ptr %ru.addr, align 8
  %51 = getelementptr inbounds %struct.rusage, ptr %50, i32 0, i32 8
  %52 = load i64, ptr %51, align 8
  %call26 = call ptr @PyLong_FromLong(i64 noundef %52)
  call void @PyStructSequence_SetItem(ptr noundef %49, i64 noundef 8, ptr noundef %call26)
  %53 = load ptr, ptr %result, align 8
  %54 = load ptr, ptr %ru.addr, align 8
  %55 = getelementptr inbounds %struct.rusage, ptr %54, i32 0, i32 9
  %56 = load i64, ptr %55, align 8
  %call27 = call ptr @PyLong_FromLong(i64 noundef %56)
  call void @PyStructSequence_SetItem(ptr noundef %53, i64 noundef 9, ptr noundef %call27)
  %57 = load ptr, ptr %result, align 8
  %58 = load ptr, ptr %ru.addr, align 8
  %59 = getelementptr inbounds %struct.rusage, ptr %58, i32 0, i32 10
  %60 = load i64, ptr %59, align 8
  %call28 = call ptr @PyLong_FromLong(i64 noundef %60)
  call void @PyStructSequence_SetItem(ptr noundef %57, i64 noundef 10, ptr noundef %call28)
  %61 = load ptr, ptr %result, align 8
  %62 = load ptr, ptr %ru.addr, align 8
  %63 = getelementptr inbounds %struct.rusage, ptr %62, i32 0, i32 11
  %64 = load i64, ptr %63, align 8
  %call29 = call ptr @PyLong_FromLong(i64 noundef %64)
  call void @PyStructSequence_SetItem(ptr noundef %61, i64 noundef 11, ptr noundef %call29)
  %65 = load ptr, ptr %result, align 8
  %66 = load ptr, ptr %ru.addr, align 8
  %67 = getelementptr inbounds %struct.rusage, ptr %66, i32 0, i32 12
  %68 = load i64, ptr %67, align 8
  %call30 = call ptr @PyLong_FromLong(i64 noundef %68)
  call void @PyStructSequence_SetItem(ptr noundef %65, i64 noundef 12, ptr noundef %call30)
  %69 = load ptr, ptr %result, align 8
  %70 = load ptr, ptr %ru.addr, align 8
  %71 = getelementptr inbounds %struct.rusage, ptr %70, i32 0, i32 13
  %72 = load i64, ptr %71, align 8
  %call31 = call ptr @PyLong_FromLong(i64 noundef %72)
  call void @PyStructSequence_SetItem(ptr noundef %69, i64 noundef 13, ptr noundef %call31)
  %73 = load ptr, ptr %result, align 8
  %74 = load ptr, ptr %ru.addr, align 8
  %75 = getelementptr inbounds %struct.rusage, ptr %74, i32 0, i32 14
  %76 = load i64, ptr %75, align 8
  %call32 = call ptr @PyLong_FromLong(i64 noundef %76)
  call void @PyStructSequence_SetItem(ptr noundef %73, i64 noundef 14, ptr noundef %call32)
  %77 = load ptr, ptr %result, align 8
  %78 = load ptr, ptr %ru.addr, align 8
  %79 = getelementptr inbounds %struct.rusage, ptr %78, i32 0, i32 15
  %80 = load i64, ptr %79, align 8
  %call33 = call ptr @PyLong_FromLong(i64 noundef %80)
  call void @PyStructSequence_SetItem(ptr noundef %77, i64 noundef 15, ptr noundef %call33)
  %call34 = call ptr @PyErr_Occurred()
  %tobool35 = icmp ne ptr %call34, null
  br i1 %tobool35, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.end10
  %81 = load ptr, ptr %result, align 8
  store ptr %81, ptr %op.addr.i, align 8
  %82 = load ptr, ptr %op.addr.i, align 8
  store ptr %82, ptr %op.addr.i52, align 8
  %83 = load ptr, ptr %op.addr.i52, align 8
  %84 = load i64, ptr %83, align 8
  %conv.i53 = trunc i64 %84 to i32
  %cmp.i54 = icmp slt i32 %conv.i53, 0
  %conv1.i55 = zext i1 %cmp.i54 to i32
  %tobool.i = icmp ne i32 %conv1.i55, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then36
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.then36
  %85 = load ptr, ptr %op.addr.i, align 8
  %86 = load i64, ptr %85, align 8
  %dec.i = add i64 %86, -1
  store i64 %dec.i, ptr %85, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %87 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %87) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  store ptr null, ptr %retval, align 8
  br label %return

if.end37:                                         ; preds = %if.end10
  %88 = load i32, ptr %pid.addr, align 4
  %conv38 = sext i32 %88 to i64
  %call39 = call ptr @PyLong_FromLong(i64 noundef %conv38)
  %89 = load i32, ptr %status.addr, align 4
  %90 = load ptr, ptr %result, align 8
  %call40 = call ptr (ptr, ...) @Py_BuildValue(ptr noundef @.str.336, ptr noundef %call39, i32 noundef %89, ptr noundef %90)
  store ptr %call40, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end37, %Py_DECREF.exit, %if.then9, %if.then6, %if.then
  %91 = load ptr, ptr %retval, align 8
  ret ptr %91
}

declare ptr @_PyImport_GetModuleAttrString(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @os_wait4_impl(ptr noundef %module, i32 noundef %pid, i32 noundef %options) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %pid.addr = alloca i32, align 4
  %options.addr = alloca i32, align 4
  %res = alloca i32, align 4
  %ru = alloca %struct.rusage, align 8
  %async_err = alloca i32, align 4
  %status = alloca i32, align 4
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %pid, ptr %pid.addr, align 4
  store i32 %options, ptr %options.addr, align 4
  store i32 0, ptr %async_err, align 4
  store i32 0, ptr %status, align 4
  br label %do.body

do.body:                                          ; preds = %land.end, %entry
  %call = call ptr @PyEval_SaveThread()
  store ptr %call, ptr %_save, align 8
  %0 = load i32, ptr %pid.addr, align 4
  %1 = load i32, ptr %options.addr, align 4
  %call1 = call i32 @wait4(i32 noundef %0, ptr noundef %status, i32 noundef %1, ptr noundef %ru) #10
  store i32 %call1, ptr %res, align 4
  %2 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %2)
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %3 = load i32, ptr %res, align 4
  %cmp = icmp slt i32 %3, 0
  br i1 %cmp, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %do.cond
  %call2 = call ptr @__errno_location() #12
  %4 = load i32, ptr %call2, align 4
  %cmp3 = icmp eq i32 %4, 4
  br i1 %cmp3, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %call4 = call i32 @PyErr_CheckSignals()
  store i32 %call4, ptr %async_err, align 4
  %tobool = icmp ne i32 %call4, 0
  %lnot = xor i1 %tobool, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %do.cond
  %5 = phi i1 [ false, %land.lhs.true ], [ false, %do.cond ], [ %lnot, %land.rhs ]
  br i1 %5, label %do.body, label %do.end, !llvm.loop !26

do.end:                                           ; preds = %land.end
  %6 = load i32, ptr %res, align 4
  %cmp5 = icmp slt i32 %6, 0
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %do.end
  %7 = load i32, ptr %async_err, align 4
  %tobool6 = icmp ne i32 %7, 0
  br i1 %tobool6, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then
  %call7 = call ptr @posix_error()
  br label %cond.end

cond.false:                                       ; preds = %if.then
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call7, %cond.true ], [ null, %cond.false ]
  store ptr %cond, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %do.end
  %8 = load ptr, ptr %module.addr, align 8
  %9 = load i32, ptr %res, align 4
  %10 = load i32, ptr %status, align 4
  %call8 = call ptr @wait_helper(ptr noundef %8, i32 noundef %9, i32 noundef %10, ptr noundef %ru)
  store ptr %call8, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %cond.end
  %11 = load ptr, ptr %retval, align 8
  ret ptr %11
}

; Function Attrs: nounwind
declare i32 @wait4(i32 noundef, ptr noundef, i32 noundef, ptr noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_waitid_impl(ptr noundef %module, i32 noundef %idtype, i32 noundef %id, i32 noundef %options) #0 {
entry:
  %op.addr.i35 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %idtype.addr = alloca i32, align 4
  %id.addr = alloca i32, align 4
  %options.addr = alloca i32, align 4
  %result = alloca ptr, align 8
  %res = alloca i32, align 4
  %async_err = alloca i32, align 4
  %si = alloca %struct.siginfo_t, align 8
  %_save = alloca ptr, align 8
  %WaitidResultType = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %idtype, ptr %idtype.addr, align 4
  store i32 %id, ptr %id.addr, align 4
  store i32 %options, ptr %options.addr, align 4
  store i32 0, ptr %async_err, align 4
  %_sifields = getelementptr inbounds %struct.siginfo_t, ptr %si, i32 0, i32 4
  %si_pid = getelementptr inbounds %struct.anon.820, ptr %_sifields, i32 0, i32 0
  store i32 0, ptr %si_pid, align 8
  br label %do.body

do.body:                                          ; preds = %land.end, %entry
  %call = call ptr @PyEval_SaveThread()
  store ptr %call, ptr %_save, align 8
  %0 = load i32, ptr %idtype.addr, align 4
  %1 = load i32, ptr %id.addr, align 4
  %2 = load i32, ptr %options.addr, align 4
  %call1 = call i32 @waitid(i32 noundef %0, i32 noundef %1, ptr noundef %si, i32 noundef %2)
  store i32 %call1, ptr %res, align 4
  %3 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %3)
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %4 = load i32, ptr %res, align 4
  %cmp = icmp slt i32 %4, 0
  br i1 %cmp, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %do.cond
  %call2 = call ptr @__errno_location() #12
  %5 = load i32, ptr %call2, align 4
  %cmp3 = icmp eq i32 %5, 4
  br i1 %cmp3, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %call4 = call i32 @PyErr_CheckSignals()
  store i32 %call4, ptr %async_err, align 4
  %tobool = icmp ne i32 %call4, 0
  %lnot = xor i1 %tobool, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %do.cond
  %6 = phi i1 [ false, %land.lhs.true ], [ false, %do.cond ], [ %lnot, %land.rhs ]
  br i1 %6, label %do.body, label %do.end, !llvm.loop !27

do.end:                                           ; preds = %land.end
  %7 = load i32, ptr %res, align 4
  %cmp5 = icmp slt i32 %7, 0
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %do.end
  %8 = load i32, ptr %async_err, align 4
  %tobool6 = icmp ne i32 %8, 0
  br i1 %tobool6, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then
  %call7 = call ptr @posix_error()
  br label %cond.end

cond.false:                                       ; preds = %if.then
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call7, %cond.true ], [ null, %cond.false ]
  store ptr %cond, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %do.end
  %_sifields8 = getelementptr inbounds %struct.siginfo_t, ptr %si, i32 0, i32 4
  %si_pid9 = getelementptr inbounds %struct.anon.820, ptr %_sifields8, i32 0, i32 0
  %9 = load i32, ptr %si_pid9, align 8
  %cmp10 = icmp eq i32 %9, 0
  br i1 %cmp10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

if.end12:                                         ; preds = %if.end
  %10 = load ptr, ptr %module.addr, align 8
  %call13 = call ptr @get_posix_state(ptr noundef %10)
  %WaitidResultType14 = getelementptr inbounds %struct._posixstate, ptr %call13, i32 0, i32 10
  %11 = load ptr, ptr %WaitidResultType14, align 8
  store ptr %11, ptr %WaitidResultType, align 8
  %12 = load ptr, ptr %WaitidResultType, align 8
  %call15 = call ptr @PyStructSequence_New(ptr noundef %12)
  store ptr %call15, ptr %result, align 8
  %13 = load ptr, ptr %result, align 8
  %tobool16 = icmp ne ptr %13, null
  br i1 %tobool16, label %if.end18, label %if.then17

if.then17:                                        ; preds = %if.end12
  store ptr null, ptr %retval, align 8
  br label %return

if.end18:                                         ; preds = %if.end12
  %14 = load ptr, ptr %result, align 8
  %_sifields19 = getelementptr inbounds %struct.siginfo_t, ptr %si, i32 0, i32 4
  %si_pid20 = getelementptr inbounds %struct.anon.820, ptr %_sifields19, i32 0, i32 0
  %15 = load i32, ptr %si_pid20, align 8
  %conv = sext i32 %15 to i64
  %call21 = call ptr @PyLong_FromLong(i64 noundef %conv)
  call void @PyStructSequence_SetItem(ptr noundef %14, i64 noundef 0, ptr noundef %call21)
  %16 = load ptr, ptr %result, align 8
  %_sifields22 = getelementptr inbounds %struct.siginfo_t, ptr %si, i32 0, i32 4
  %si_uid = getelementptr inbounds %struct.anon.820, ptr %_sifields22, i32 0, i32 1
  %17 = load i32, ptr %si_uid, align 4
  %call23 = call ptr @_PyLong_FromUid(i32 noundef %17)
  call void @PyStructSequence_SetItem(ptr noundef %16, i64 noundef 1, ptr noundef %call23)
  %18 = load ptr, ptr %result, align 8
  %si_signo = getelementptr inbounds %struct.siginfo_t, ptr %si, i32 0, i32 0
  %19 = load i32, ptr %si_signo, align 8
  %conv24 = sext i32 %19 to i64
  %call25 = call ptr @PyLong_FromLong(i64 noundef %conv24)
  call void @PyStructSequence_SetItem(ptr noundef %18, i64 noundef 2, ptr noundef %call25)
  %20 = load ptr, ptr %result, align 8
  %_sifields26 = getelementptr inbounds %struct.siginfo_t, ptr %si, i32 0, i32 4
  %si_status = getelementptr inbounds %struct.anon.823, ptr %_sifields26, i32 0, i32 2
  %21 = load i32, ptr %si_status, align 8
  %conv27 = sext i32 %21 to i64
  %call28 = call ptr @PyLong_FromLong(i64 noundef %conv27)
  call void @PyStructSequence_SetItem(ptr noundef %20, i64 noundef 3, ptr noundef %call28)
  %22 = load ptr, ptr %result, align 8
  %si_code = getelementptr inbounds %struct.siginfo_t, ptr %si, i32 0, i32 2
  %23 = load i32, ptr %si_code, align 8
  %conv29 = sext i32 %23 to i64
  %call30 = call ptr @PyLong_FromLong(i64 noundef %conv29)
  call void @PyStructSequence_SetItem(ptr noundef %22, i64 noundef 4, ptr noundef %call30)
  %call31 = call ptr @PyErr_Occurred()
  %tobool32 = icmp ne ptr %call31, null
  br i1 %tobool32, label %if.then33, label %if.end34

if.then33:                                        ; preds = %if.end18
  %24 = load ptr, ptr %result, align 8
  store ptr %24, ptr %op.addr.i, align 8
  %25 = load ptr, ptr %op.addr.i, align 8
  store ptr %25, ptr %op.addr.i35, align 8
  %26 = load ptr, ptr %op.addr.i35, align 8
  %27 = load i64, ptr %26, align 8
  %conv.i = trunc i64 %27 to i32
  %cmp.i36 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i36 to i32
  %tobool.i = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then33
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.then33
  %28 = load ptr, ptr %op.addr.i, align 8
  %29 = load i64, ptr %28, align 8
  %dec.i = add i64 %29, -1
  store i64 %dec.i, ptr %28, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %30 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %30) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  store ptr null, ptr %retval, align 8
  br label %return

if.end34:                                         ; preds = %if.end18
  %31 = load ptr, ptr %result, align 8
  store ptr %31, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end34, %Py_DECREF.exit, %if.then17, %if.then11, %cond.end
  %32 = load ptr, ptr %retval, align 8
  ret ptr %32
}

declare i32 @waitid(i32 noundef, i32 noundef, ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @os_waitpid_impl(ptr noundef %module, i32 noundef %pid, i32 noundef %options) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %pid.addr = alloca i32, align 4
  %options.addr = alloca i32, align 4
  %res = alloca i32, align 4
  %async_err = alloca i32, align 4
  %status = alloca i32, align 4
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %pid, ptr %pid.addr, align 4
  store i32 %options, ptr %options.addr, align 4
  store i32 0, ptr %async_err, align 4
  store i32 0, ptr %status, align 4
  br label %do.body

do.body:                                          ; preds = %land.end, %entry
  %call = call ptr @PyEval_SaveThread()
  store ptr %call, ptr %_save, align 8
  %0 = load i32, ptr %pid.addr, align 4
  %1 = load i32, ptr %options.addr, align 4
  %call1 = call i32 @waitpid(i32 noundef %0, ptr noundef %status, i32 noundef %1)
  store i32 %call1, ptr %res, align 4
  %2 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %2)
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %3 = load i32, ptr %res, align 4
  %cmp = icmp slt i32 %3, 0
  br i1 %cmp, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %do.cond
  %call2 = call ptr @__errno_location() #12
  %4 = load i32, ptr %call2, align 4
  %cmp3 = icmp eq i32 %4, 4
  br i1 %cmp3, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %call4 = call i32 @PyErr_CheckSignals()
  store i32 %call4, ptr %async_err, align 4
  %tobool = icmp ne i32 %call4, 0
  %lnot = xor i1 %tobool, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %do.cond
  %5 = phi i1 [ false, %land.lhs.true ], [ false, %do.cond ], [ %lnot, %land.rhs ]
  br i1 %5, label %do.body, label %do.end, !llvm.loop !28

do.end:                                           ; preds = %land.end
  %6 = load i32, ptr %res, align 4
  %cmp5 = icmp slt i32 %6, 0
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %do.end
  %7 = load i32, ptr %async_err, align 4
  %tobool6 = icmp ne i32 %7, 0
  br i1 %tobool6, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then
  %call7 = call ptr @posix_error()
  br label %cond.end

cond.false:                                       ; preds = %if.then
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call7, %cond.true ], [ null, %cond.false ]
  store ptr %cond, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %do.end
  %8 = load i32, ptr %res, align 4
  %conv = sext i32 %8 to i64
  %call8 = call ptr @PyLong_FromLong(i64 noundef %conv)
  %9 = load i32, ptr %status, align 4
  %call9 = call ptr (ptr, ...) @Py_BuildValue(ptr noundef @.str.332, ptr noundef %call8, i32 noundef %9)
  store ptr %call9, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %cond.end
  %10 = load ptr, ptr %retval, align 8
  ret ptr %10
}

declare i32 @waitpid(i32 noundef, ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @os_pidfd_open_impl(ptr noundef %module, i32 noundef %pid, i32 noundef %flags) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %pid.addr = alloca i32, align 4
  %flags.addr = alloca i32, align 4
  %fd = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %pid, ptr %pid.addr, align 4
  store i32 %flags, ptr %flags.addr, align 4
  %0 = load i32, ptr %pid.addr, align 4
  %1 = load i32, ptr %flags.addr, align 4
  %call = call i64 (i64, ...) @syscall(i64 noundef 434, i32 noundef %0, i32 noundef %1) #10
  %conv = trunc i64 %call to i32
  store i32 %conv, ptr %fd, align 4
  %2 = load i32, ptr %fd, align 4
  %cmp = icmp slt i32 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call2 = call ptr @posix_error()
  store ptr %call2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load i32, ptr %fd, align 4
  %conv3 = sext i32 %3 to i64
  %call4 = call ptr @PyLong_FromLong(i64 noundef %conv3)
  store ptr %call4, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load ptr, ptr %retval, align 8
  ret ptr %4
}

; Function Attrs: nounwind
declare i64 @syscall(i64 noundef, ...) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_getsid_impl(ptr noundef %module, i32 noundef %pid) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %pid.addr = alloca i32, align 4
  %sid = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %pid, ptr %pid.addr, align 4
  %0 = load i32, ptr %pid.addr, align 4
  %call = call i32 @getsid(i32 noundef %0) #10
  store i32 %call, ptr %sid, align 4
  %1 = load i32, ptr %sid, align 4
  %cmp = icmp slt i32 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call ptr @posix_error()
  store ptr %call1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %sid, align 4
  %conv = sext i32 %2 to i64
  %call2 = call ptr @PyLong_FromLong(i64 noundef %conv)
  store ptr %call2, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load ptr, ptr %retval, align 8
  ret ptr %3
}

; Function Attrs: nounwind
declare i32 @getsid(i32 noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_setsid_impl(ptr noundef %module) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  %call = call i32 @setsid() #10
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call ptr @posix_error()
  store ptr %call1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %0 = load ptr, ptr %retval, align 8
  ret ptr %0
}

; Function Attrs: nounwind
declare i32 @setsid() #4

; Function Attrs: nounwind uwtable
define internal ptr @os_setpgid_impl(ptr noundef %module, i32 noundef %pid, i32 noundef %pgrp) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %pid.addr = alloca i32, align 4
  %pgrp.addr = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %pid, ptr %pid.addr, align 4
  store i32 %pgrp, ptr %pgrp.addr, align 4
  %0 = load i32, ptr %pid.addr, align 4
  %1 = load i32, ptr %pgrp.addr, align 4
  %call = call i32 @setpgid(i32 noundef %0, i32 noundef %1) #10
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call ptr @posix_error()
  store ptr %call1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load ptr, ptr %retval, align 8
  ret ptr %2
}

; Function Attrs: nounwind
declare i32 @setpgid(i32 noundef, i32 noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_tcgetpgrp_impl(ptr noundef %module, i32 noundef %fd) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %pgid = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  %0 = load i32, ptr %fd.addr, align 4
  %call = call i32 @tcgetpgrp(i32 noundef %0) #10
  store i32 %call, ptr %pgid, align 4
  %1 = load i32, ptr %pgid, align 4
  %cmp = icmp slt i32 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call ptr @posix_error()
  store ptr %call1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %pgid, align 4
  %conv = sext i32 %2 to i64
  %call2 = call ptr @PyLong_FromLong(i64 noundef %conv)
  store ptr %call2, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load ptr, ptr %retval, align 8
  ret ptr %3
}

; Function Attrs: nounwind
declare i32 @tcgetpgrp(i32 noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_tcsetpgrp_impl(ptr noundef %module, i32 noundef %fd, i32 noundef %pgid) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %pgid.addr = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i32 %pgid, ptr %pgid.addr, align 4
  %0 = load i32, ptr %fd.addr, align 4
  %1 = load i32, ptr %pgid.addr, align 4
  %call = call i32 @tcsetpgrp(i32 noundef %0, i32 noundef %1) #10
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call ptr @posix_error()
  store ptr %call1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load ptr, ptr %retval, align 8
  ret ptr %2
}

; Function Attrs: nounwind
declare i32 @tcsetpgrp(i32 noundef, i32 noundef) #4

; Function Attrs: nounwind uwtable
define internal i32 @os_open_impl(ptr noundef %module, ptr noundef %path, i32 noundef %flags, i32 noundef %mode, i32 noundef %dir_fd) #0 {
entry:
  %retval = alloca i32, align 4
  %module.addr = alloca ptr, align 8
  %path.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %mode.addr = alloca i32, align 4
  %dir_fd.addr = alloca i32, align 4
  %fd = alloca i32, align 4
  %async_err = alloca i32, align 4
  %openat_unavailable = alloca i32, align 4
  %atomic_flag_works = alloca ptr, align 8
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %path, ptr %path.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  store i32 %mode, ptr %mode.addr, align 4
  store i32 %dir_fd, ptr %dir_fd.addr, align 4
  store i32 0, ptr %async_err, align 4
  store i32 0, ptr %openat_unavailable, align 4
  store ptr @_Py_open_cloexec_works, ptr %atomic_flag_works, align 8
  %0 = load i32, ptr %flags.addr, align 4
  %or = or i32 %0, 524288
  store i32 %or, ptr %flags.addr, align 4
  %1 = load ptr, ptr %path.addr, align 8
  %object = getelementptr inbounds %struct.path_t, ptr %1, i32 0, i32 8
  %2 = load ptr, ptr %object, align 8
  %3 = load i32, ptr %flags.addr, align 4
  %call = call i32 (ptr, ptr, ...) @PySys_Audit(ptr noundef @.str.99, ptr noundef @.str.265, ptr noundef %2, ptr noundef @_Py_NoneStruct, i32 noundef %3)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %land.end, %if.end
  %call1 = call ptr @PyEval_SaveThread()
  store ptr %call1, ptr %_save, align 8
  %4 = load i32, ptr %dir_fd.addr, align 4
  %cmp2 = icmp ne i32 %4, -100
  br i1 %cmp2, label %if.then3, label %if.else

if.then3:                                         ; preds = %do.body
  %5 = load i32, ptr %dir_fd.addr, align 4
  %6 = load ptr, ptr %path.addr, align 8
  %narrow = getelementptr inbounds %struct.path_t, ptr %6, i32 0, i32 5
  %7 = load ptr, ptr %narrow, align 8
  %8 = load i32, ptr %flags.addr, align 4
  %9 = load i32, ptr %mode.addr, align 4
  %call4 = call i32 (i32, ptr, i32, ...) @openat64(i32 noundef %5, ptr noundef %7, i32 noundef %8, i32 noundef %9)
  store i32 %call4, ptr %fd, align 4
  br label %if.end7

if.else:                                          ; preds = %do.body
  %10 = load ptr, ptr %path.addr, align 8
  %narrow5 = getelementptr inbounds %struct.path_t, ptr %10, i32 0, i32 5
  %11 = load ptr, ptr %narrow5, align 8
  %12 = load i32, ptr %flags.addr, align 4
  %13 = load i32, ptr %mode.addr, align 4
  %call6 = call i32 (ptr, i32, ...) @open64(ptr noundef %11, i32 noundef %12, i32 noundef %13)
  store i32 %call6, ptr %fd, align 4
  br label %if.end7

if.end7:                                          ; preds = %if.else, %if.then3
  %14 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %14)
  br label %do.cond

do.cond:                                          ; preds = %if.end7
  %15 = load i32, ptr %fd, align 4
  %cmp8 = icmp slt i32 %15, 0
  br i1 %cmp8, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %do.cond
  %call9 = call ptr @__errno_location() #12
  %16 = load i32, ptr %call9, align 4
  %cmp10 = icmp eq i32 %16, 4
  br i1 %cmp10, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %call11 = call i32 @PyErr_CheckSignals()
  store i32 %call11, ptr %async_err, align 4
  %tobool = icmp ne i32 %call11, 0
  %lnot = xor i1 %tobool, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %do.cond
  %17 = phi i1 [ false, %land.lhs.true ], [ false, %do.cond ], [ %lnot, %land.rhs ]
  br i1 %17, label %do.body, label %do.end, !llvm.loop !29

do.end:                                           ; preds = %land.end
  %18 = load i32, ptr %openat_unavailable, align 4
  %tobool12 = icmp ne i32 %18, 0
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %do.end
  call void @argument_unavailable_error(ptr noundef null, ptr noundef @.str.184)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end14:                                         ; preds = %do.end
  %19 = load i32, ptr %fd, align 4
  %cmp15 = icmp slt i32 %19, 0
  br i1 %cmp15, label %if.then16, label %if.end22

if.then16:                                        ; preds = %if.end14
  %20 = load i32, ptr %async_err, align 4
  %tobool17 = icmp ne i32 %20, 0
  br i1 %tobool17, label %if.end21, label %if.then18

if.then18:                                        ; preds = %if.then16
  %21 = load ptr, ptr @PyExc_OSError, align 8
  %22 = load ptr, ptr %path.addr, align 8
  %object19 = getelementptr inbounds %struct.path_t, ptr %22, i32 0, i32 8
  %23 = load ptr, ptr %object19, align 8
  %call20 = call ptr @PyErr_SetFromErrnoWithFilenameObject(ptr noundef %21, ptr noundef %23)
  br label %if.end21

if.end21:                                         ; preds = %if.then18, %if.then16
  store i32 -1, ptr %retval, align 4
  br label %return

if.end22:                                         ; preds = %if.end14
  %24 = load i32, ptr %fd, align 4
  %25 = load ptr, ptr %atomic_flag_works, align 8
  %call23 = call i32 @_Py_set_inheritable(i32 noundef %24, i32 noundef 0, ptr noundef %25)
  %cmp24 = icmp slt i32 %call23, 0
  br i1 %cmp24, label %if.then25, label %if.end27

if.then25:                                        ; preds = %if.end22
  %26 = load i32, ptr %fd, align 4
  %call26 = call i32 @close(i32 noundef %26)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end27:                                         ; preds = %if.end22
  %27 = load i32, ptr %fd, align 4
  store i32 %27, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end27, %if.then25, %if.end21, %if.then13, %if.then
  %28 = load i32, ptr %retval, align 4
  ret i32 %28
}

declare i32 @openat64(i32 noundef, ptr noundef, i32 noundef, ...) #1

declare i32 @open64(ptr noundef, i32 noundef, ...) #1

; Function Attrs: nounwind uwtable
define internal ptr @os_close_impl(ptr noundef %module, i32 noundef %fd) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %res = alloca i32, align 4
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  %call = call ptr @PyEval_SaveThread()
  store ptr %call, ptr %_save, align 8
  %0 = load i32, ptr %fd.addr, align 4
  %call1 = call i32 @close(i32 noundef %0)
  store i32 %call1, ptr %res, align 4
  %1 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %1)
  %2 = load i32, ptr %res, align 4
  %cmp = icmp slt i32 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call2 = call ptr @posix_error()
  store ptr %call2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load ptr, ptr %retval, align 8
  ret ptr %3
}

; Function Attrs: nounwind uwtable
define internal ptr @os_closerange_impl(ptr noundef %module, i32 noundef %fd_low, i32 noundef %fd_high) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %fd_low.addr = alloca i32, align 4
  %fd_high.addr = alloca i32, align 4
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %fd_low, ptr %fd_low.addr, align 4
  store i32 %fd_high, ptr %fd_high.addr, align 4
  %call = call ptr @PyEval_SaveThread()
  store ptr %call, ptr %_save, align 8
  %0 = load i32, ptr %fd_low.addr, align 4
  %1 = load i32, ptr %fd_high.addr, align 4
  %sub = sub i32 %1, 1
  call void @_Py_closerange(i32 noundef %0, i32 noundef %sub)
  %2 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %2)
  ret ptr @_Py_NoneStruct
}

declare void @_Py_closerange(i32 noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @os_device_encoding_impl(ptr noundef %module, i32 noundef %fd) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  %0 = load i32, ptr %fd.addr, align 4
  %call = call ptr @_Py_device_encoding(i32 noundef %0)
  ret ptr %call
}

declare ptr @_Py_device_encoding(i32 noundef) #1

; Function Attrs: nounwind uwtable
define internal i32 @os_dup_impl(ptr noundef %module, i32 noundef %fd) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  %0 = load i32, ptr %fd.addr, align 4
  %call = call i32 @_Py_dup(i32 noundef %0)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @os_dup2_impl(ptr noundef %module, i32 noundef %fd, i32 noundef %fd2, i32 noundef %inheritable) #0 {
entry:
  %retval = alloca i32, align 4
  %module.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %fd2.addr = alloca i32, align 4
  %inheritable.addr = alloca i32, align 4
  %res = alloca i32, align 4
  %_save = alloca ptr, align 8
  %_save18 = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i32 %fd2, ptr %fd2.addr, align 4
  store i32 %inheritable, ptr %inheritable.addr, align 4
  store i32 0, ptr %res, align 4
  %0 = load i32, ptr %inheritable.addr, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %1 = load i32, ptr @os_dup2_impl.dup3_works, align 4
  %cmp = icmp ne i32 %1, 0
  br i1 %cmp, label %if.then, label %if.end13

if.then:                                          ; preds = %land.lhs.true
  %call = call ptr @PyEval_SaveThread()
  store ptr %call, ptr %_save, align 8
  %2 = load i32, ptr %fd.addr, align 4
  %3 = load i32, ptr %fd2.addr, align 4
  %call1 = call i32 @dup3(i32 noundef %2, i32 noundef %3, i32 noundef 524288) #10
  store i32 %call1, ptr %res, align 4
  %4 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %4)
  %5 = load i32, ptr %res, align 4
  %cmp2 = icmp slt i32 %5, 0
  br i1 %cmp2, label %if.then3, label %if.end12

if.then3:                                         ; preds = %if.then
  %6 = load i32, ptr @os_dup2_impl.dup3_works, align 4
  %cmp4 = icmp eq i32 %6, -1
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.then3
  %call6 = call ptr @__errno_location() #12
  %7 = load i32, ptr %call6, align 4
  %cmp7 = icmp ne i32 %7, 38
  %conv = zext i1 %cmp7 to i32
  store i32 %conv, ptr @os_dup2_impl.dup3_works, align 4
  br label %if.end

if.end:                                           ; preds = %if.then5, %if.then3
  %8 = load i32, ptr @os_dup2_impl.dup3_works, align 4
  %tobool8 = icmp ne i32 %8, 0
  br i1 %tobool8, label %if.then9, label %if.end11

if.then9:                                         ; preds = %if.end
  %call10 = call ptr @posix_error()
  store i32 -1, ptr %retval, align 4
  br label %return

if.end11:                                         ; preds = %if.end
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %if.then
  br label %if.end13

if.end13:                                         ; preds = %if.end12, %land.lhs.true, %entry
  %9 = load i32, ptr %inheritable.addr, align 4
  %tobool14 = icmp ne i32 %9, 0
  br i1 %tobool14, label %if.then17, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end13
  %10 = load i32, ptr @os_dup2_impl.dup3_works, align 4
  %cmp15 = icmp eq i32 %10, 0
  br i1 %cmp15, label %if.then17, label %if.end34

if.then17:                                        ; preds = %lor.lhs.false, %if.end13
  %call19 = call ptr @PyEval_SaveThread()
  store ptr %call19, ptr %_save18, align 8
  %11 = load i32, ptr %fd.addr, align 4
  %12 = load i32, ptr %fd2.addr, align 4
  %call20 = call i32 @dup2(i32 noundef %11, i32 noundef %12) #10
  store i32 %call20, ptr %res, align 4
  %13 = load ptr, ptr %_save18, align 8
  call void @PyEval_RestoreThread(ptr noundef %13)
  %14 = load i32, ptr %res, align 4
  %cmp21 = icmp slt i32 %14, 0
  br i1 %cmp21, label %if.then23, label %if.end25

if.then23:                                        ; preds = %if.then17
  %call24 = call ptr @posix_error()
  store i32 -1, ptr %retval, align 4
  br label %return

if.end25:                                         ; preds = %if.then17
  %15 = load i32, ptr %inheritable.addr, align 4
  %tobool26 = icmp ne i32 %15, 0
  br i1 %tobool26, label %if.end33, label %land.lhs.true27

land.lhs.true27:                                  ; preds = %if.end25
  %16 = load i32, ptr %fd2.addr, align 4
  %call28 = call i32 @_Py_set_inheritable(i32 noundef %16, i32 noundef 0, ptr noundef null)
  %cmp29 = icmp slt i32 %call28, 0
  br i1 %cmp29, label %if.then31, label %if.end33

if.then31:                                        ; preds = %land.lhs.true27
  %17 = load i32, ptr %fd2.addr, align 4
  %call32 = call i32 @close(i32 noundef %17)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end33:                                         ; preds = %land.lhs.true27, %if.end25
  br label %if.end34

if.end34:                                         ; preds = %if.end33, %lor.lhs.false
  %18 = load i32, ptr %res, align 4
  store i32 %18, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end34, %if.then31, %if.then23, %if.then9
  %19 = load i32, ptr %retval, align 4
  ret i32 %19
}

; Function Attrs: nounwind
declare i32 @dup3(i32 noundef, i32 noundef, i32 noundef) #4

; Function Attrs: nounwind
declare i32 @dup2(i32 noundef, i32 noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_lockf_impl(ptr noundef %module, i32 noundef %fd, i32 noundef %command, i64 noundef %length) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %command.addr = alloca i32, align 4
  %length.addr = alloca i64, align 8
  %res = alloca i32, align 4
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i32 %command, ptr %command.addr, align 4
  store i64 %length, ptr %length.addr, align 8
  %0 = load i32, ptr %fd.addr, align 4
  %1 = load i32, ptr %command.addr, align 4
  %2 = load i64, ptr %length.addr, align 8
  %call = call i32 (ptr, ptr, ...) @PySys_Audit(ptr noundef @.str.346, ptr noundef @.str.347, i32 noundef %0, i32 noundef %1, i64 noundef %2)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call ptr @PyEval_SaveThread()
  store ptr %call1, ptr %_save, align 8
  %3 = load i32, ptr %fd.addr, align 4
  %4 = load i32, ptr %command.addr, align 4
  %5 = load i64, ptr %length.addr, align 8
  %call2 = call i32 @lockf64(i32 noundef %3, i32 noundef %4, i64 noundef %5)
  store i32 %call2, ptr %res, align 4
  %6 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %6)
  %7 = load i32, ptr %res, align 4
  %cmp3 = icmp slt i32 %7, 0
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call ptr @posix_error()
  store ptr %call5, ptr %retval, align 8
  br label %return

if.end6:                                          ; preds = %if.end
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end6, %if.then4, %if.then
  %8 = load ptr, ptr %retval, align 8
  ret ptr %8
}

declare i32 @lockf64(i32 noundef, i32 noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define internal i64 @os_lseek_impl(ptr noundef %module, i32 noundef %fd, i64 noundef %position, i32 noundef %how) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %position.addr = alloca i64, align 8
  %how.addr = alloca i32, align 4
  %result = alloca i64, align 8
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i64 %position, ptr %position.addr, align 8
  store i32 %how, ptr %how.addr, align 4
  %0 = load i32, ptr %how.addr, align 4
  switch i32 %0, label %sw.epilog [
    i32 0, label %sw.bb
    i32 1, label %sw.bb1
    i32 2, label %sw.bb2
  ]

sw.bb:                                            ; preds = %entry
  store i32 0, ptr %how.addr, align 4
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry
  store i32 1, ptr %how.addr, align 4
  br label %sw.epilog

sw.bb2:                                           ; preds = %entry
  store i32 2, ptr %how.addr, align 4
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb2, %sw.bb1, %sw.bb, %entry
  %call = call ptr @PyEval_SaveThread()
  store ptr %call, ptr %_save, align 8
  %1 = load i32, ptr %fd.addr, align 4
  %2 = load i64, ptr %position.addr, align 8
  %3 = load i32, ptr %how.addr, align 4
  %call3 = call i64 @lseek64(i32 noundef %1, i64 noundef %2, i32 noundef %3) #10
  store i64 %call3, ptr %result, align 8
  %4 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %4)
  %5 = load i64, ptr %result, align 8
  %cmp = icmp slt i64 %5, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %sw.epilog
  %call4 = call ptr @posix_error()
  br label %if.end

if.end:                                           ; preds = %if.then, %sw.epilog
  %6 = load i64, ptr %result, align 8
  ret i64 %6
}

; Function Attrs: nounwind uwtable
define internal ptr @PyLong_FromPy_off_t(i64 noundef %offset) #0 {
entry:
  %offset.addr = alloca i64, align 8
  store i64 %offset, ptr %offset.addr, align 8
  %0 = load i64, ptr %offset.addr, align 8
  %call = call ptr @PyLong_FromLong(i64 noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind
declare i64 @lseek64(i32 noundef, i64 noundef, i32 noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_read_impl(ptr noundef %module, i32 noundef %fd, i64 noundef %length) #0 {
entry:
  %op.addr.i16 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %length.addr = alloca i64, align 8
  %n = alloca i64, align 8
  %buffer = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i64 %length, ptr %length.addr, align 8
  %0 = load i64, ptr %length.addr, align 8
  %cmp = icmp slt i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call ptr @__errno_location() #12
  store i32 22, ptr %call, align 4
  %call1 = call ptr @posix_error()
  store ptr %call1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, ptr %length.addr, align 8
  %cmp2 = icmp sgt i64 %1, 9223372036854775807
  br i1 %cmp2, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %2 = load i64, ptr %length.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ 9223372036854775807, %cond.true ], [ %2, %cond.false ]
  store i64 %cond, ptr %length.addr, align 8
  %3 = load i64, ptr %length.addr, align 8
  %call3 = call ptr @PyBytes_FromStringAndSize(ptr noundef null, i64 noundef %3)
  store ptr %call3, ptr %buffer, align 8
  %4 = load ptr, ptr %buffer, align 8
  %cmp4 = icmp eq ptr %4, null
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %cond.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end6:                                          ; preds = %cond.end
  %5 = load i32, ptr %fd.addr, align 4
  %6 = load ptr, ptr %buffer, align 8
  %call7 = call ptr @PyBytes_AS_STRING(ptr noundef %6)
  %7 = load i64, ptr %length.addr, align 8
  %call8 = call i64 @_Py_read(i32 noundef %5, ptr noundef %call7, i64 noundef %7)
  store i64 %call8, ptr %n, align 8
  %8 = load i64, ptr %n, align 8
  %cmp9 = icmp eq i64 %8, -1
  br i1 %cmp9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end6
  %9 = load ptr, ptr %buffer, align 8
  store ptr %9, ptr %op.addr.i, align 8
  %10 = load ptr, ptr %op.addr.i, align 8
  store ptr %10, ptr %op.addr.i16, align 8
  %11 = load ptr, ptr %op.addr.i16, align 8
  %12 = load i64, ptr %11, align 8
  %conv.i = trunc i64 %12 to i32
  %cmp.i17 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i17 to i32
  %tobool.i = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then10
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.then10
  %13 = load ptr, ptr %op.addr.i, align 8
  %14 = load i64, ptr %13, align 8
  %dec.i = add i64 %14, -1
  store i64 %dec.i, ptr %13, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %15 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %15) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  store ptr null, ptr %retval, align 8
  br label %return

if.end11:                                         ; preds = %if.end6
  %16 = load i64, ptr %n, align 8
  %17 = load i64, ptr %length.addr, align 8
  %cmp12 = icmp ne i64 %16, %17
  br i1 %cmp12, label %if.then13, label %if.end15

if.then13:                                        ; preds = %if.end11
  %18 = load i64, ptr %n, align 8
  %call14 = call i32 @_PyBytes_Resize(ptr noundef %buffer, i64 noundef %18)
  br label %if.end15

if.end15:                                         ; preds = %if.then13, %if.end11
  %19 = load ptr, ptr %buffer, align 8
  store ptr %19, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end15, %Py_DECREF.exit, %if.then5, %if.then
  %20 = load ptr, ptr %retval, align 8
  ret ptr %20
}

declare i64 @_Py_read(i32 noundef, ptr noundef, i64 noundef) #1

declare i32 @_PyBytes_Resize(ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define internal i64 @os_readv_impl(ptr noundef %module, i32 noundef %fd, ptr noundef %buffers) #0 {
entry:
  %retval = alloca i64, align 8
  %module.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %buffers.addr = alloca ptr, align 8
  %cnt = alloca i64, align 8
  %n = alloca i64, align 8
  %async_err = alloca i32, align 4
  %iov = alloca ptr, align 8
  %buf = alloca ptr, align 8
  %_save = alloca ptr, align 8
  %saved_errno = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store ptr %buffers, ptr %buffers.addr, align 8
  store i32 0, ptr %async_err, align 4
  %0 = load ptr, ptr %buffers.addr, align 8
  %call = call i32 @PySequence_Check(ptr noundef %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr @PyExc_TypeError, align 8
  call void @PyErr_SetString(ptr noundef %1, ptr noundef @.str.348)
  store i64 -1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %buffers.addr, align 8
  %call1 = call i64 @PySequence_Size(ptr noundef %2)
  store i64 %call1, ptr %cnt, align 8
  %3 = load i64, ptr %cnt, align 8
  %cmp = icmp slt i64 %3, 0
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i64 -1, ptr %retval, align 8
  br label %return

if.end3:                                          ; preds = %if.end
  %4 = load ptr, ptr %buffers.addr, align 8
  %5 = load i64, ptr %cnt, align 8
  %call4 = call i32 @iov_setup(ptr noundef %iov, ptr noundef %buf, ptr noundef %4, i64 noundef %5, i32 noundef 1)
  %cmp5 = icmp slt i32 %call4, 0
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end3
  store i64 -1, ptr %retval, align 8
  br label %return

if.end7:                                          ; preds = %if.end3
  br label %do.body

do.body:                                          ; preds = %land.end, %if.end7
  %call8 = call ptr @PyEval_SaveThread()
  store ptr %call8, ptr %_save, align 8
  %6 = load i32, ptr %fd.addr, align 4
  %7 = load ptr, ptr %iov, align 8
  %8 = load i64, ptr %cnt, align 8
  %conv = trunc i64 %8 to i32
  %call9 = call i64 @readv(i32 noundef %6, ptr noundef %7, i32 noundef %conv)
  store i64 %call9, ptr %n, align 8
  %9 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %9)
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %10 = load i64, ptr %n, align 8
  %cmp10 = icmp slt i64 %10, 0
  br i1 %cmp10, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %do.cond
  %call12 = call ptr @__errno_location() #12
  %11 = load i32, ptr %call12, align 4
  %cmp13 = icmp eq i32 %11, 4
  br i1 %cmp13, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %call15 = call i32 @PyErr_CheckSignals()
  store i32 %call15, ptr %async_err, align 4
  %tobool16 = icmp ne i32 %call15, 0
  %lnot = xor i1 %tobool16, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %do.cond
  %12 = phi i1 [ false, %land.lhs.true ], [ false, %do.cond ], [ %lnot, %land.rhs ]
  br i1 %12, label %do.body, label %do.end, !llvm.loop !30

do.end:                                           ; preds = %land.end
  %call17 = call ptr @__errno_location() #12
  %13 = load i32, ptr %call17, align 4
  store i32 %13, ptr %saved_errno, align 4
  %14 = load ptr, ptr %iov, align 8
  %15 = load ptr, ptr %buf, align 8
  %16 = load i64, ptr %cnt, align 8
  %conv18 = trunc i64 %16 to i32
  call void @iov_cleanup(ptr noundef %14, ptr noundef %15, i32 noundef %conv18)
  %17 = load i64, ptr %n, align 8
  %cmp19 = icmp slt i64 %17, 0
  br i1 %cmp19, label %if.then21, label %if.end27

if.then21:                                        ; preds = %do.end
  %18 = load i32, ptr %async_err, align 4
  %tobool22 = icmp ne i32 %18, 0
  br i1 %tobool22, label %if.end26, label %if.then23

if.then23:                                        ; preds = %if.then21
  %19 = load i32, ptr %saved_errno, align 4
  %call24 = call ptr @__errno_location() #12
  store i32 %19, ptr %call24, align 4
  %call25 = call ptr @posix_error()
  br label %if.end26

if.end26:                                         ; preds = %if.then23, %if.then21
  store i64 -1, ptr %retval, align 8
  br label %return

if.end27:                                         ; preds = %do.end
  %20 = load i64, ptr %n, align 8
  store i64 %20, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end27, %if.end26, %if.then6, %if.then2, %if.then
  %21 = load i64, ptr %retval, align 8
  ret i64 %21
}

; Function Attrs: nounwind uwtable
define internal i32 @iov_setup(ptr noundef %iov, ptr noundef %buf, ptr noundef %seq, i64 noundef %cnt, i32 noundef %type) #0 {
entry:
  %op.addr.i46 = alloca ptr, align 8
  %op.addr.i44 = alloca ptr, align 8
  %op.addr.i35 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca i32, align 4
  %iov.addr = alloca ptr, align 8
  %buf.addr = alloca ptr, align 8
  %seq.addr = alloca ptr, align 8
  %cnt.addr = alloca i64, align 8
  %type.addr = alloca i32, align 4
  %i = alloca i64, align 8
  %j = alloca i64, align 8
  %item = alloca ptr, align 8
  store ptr %iov, ptr %iov.addr, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store ptr %seq, ptr %seq.addr, align 8
  store i64 %cnt, ptr %cnt.addr, align 8
  store i32 %type, ptr %type.addr, align 4
  %0 = load i64, ptr %cnt.addr, align 8
  %cmp = icmp ugt i64 %0, 576460752303423487
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %1 = load i64, ptr %cnt.addr, align 8
  %mul = mul i64 %1, 16
  %call = call ptr @PyMem_Malloc(i64 noundef %mul)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ null, %cond.true ], [ %call, %cond.false ]
  %2 = load ptr, ptr %iov.addr, align 8
  store ptr %cond, ptr %2, align 8
  %3 = load ptr, ptr %iov.addr, align 8
  %4 = load ptr, ptr %3, align 8
  %cmp1 = icmp eq ptr %4, null
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  %call2 = call ptr @PyErr_NoMemory()
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end
  %5 = load i64, ptr %cnt.addr, align 8
  %cmp3 = icmp ugt i64 %5, 115292150460684697
  br i1 %cmp3, label %cond.true4, label %cond.false5

cond.true4:                                       ; preds = %if.end
  br label %cond.end8

cond.false5:                                      ; preds = %if.end
  %6 = load i64, ptr %cnt.addr, align 8
  %mul6 = mul i64 %6, 80
  %call7 = call ptr @PyMem_Malloc(i64 noundef %mul6)
  br label %cond.end8

cond.end8:                                        ; preds = %cond.false5, %cond.true4
  %cond9 = phi ptr [ null, %cond.true4 ], [ %call7, %cond.false5 ]
  %7 = load ptr, ptr %buf.addr, align 8
  store ptr %cond9, ptr %7, align 8
  %8 = load ptr, ptr %buf.addr, align 8
  %9 = load ptr, ptr %8, align 8
  %cmp10 = icmp eq ptr %9, null
  br i1 %cmp10, label %if.then11, label %if.end13

if.then11:                                        ; preds = %cond.end8
  %10 = load ptr, ptr %iov.addr, align 8
  %11 = load ptr, ptr %10, align 8
  call void @PyMem_Free(ptr noundef %11)
  %call12 = call ptr @PyErr_NoMemory()
  store i32 -1, ptr %retval, align 4
  br label %return

if.end13:                                         ; preds = %cond.end8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end13
  %12 = load i64, ptr %i, align 8
  %13 = load i64, ptr %cnt.addr, align 8
  %cmp14 = icmp slt i64 %12, %13
  br i1 %cmp14, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %14 = load ptr, ptr %seq.addr, align 8
  %15 = load i64, ptr %i, align 8
  %call15 = call ptr @PySequence_GetItem(ptr noundef %14, i64 noundef %15)
  store ptr %call15, ptr %item, align 8
  %16 = load ptr, ptr %item, align 8
  %cmp16 = icmp eq ptr %16, null
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %for.body
  br label %fail

if.end18:                                         ; preds = %for.body
  %17 = load ptr, ptr %item, align 8
  %18 = load ptr, ptr %buf.addr, align 8
  %19 = load ptr, ptr %18, align 8
  %20 = load i64, ptr %i, align 8
  %arrayidx = getelementptr %struct.Py_buffer, ptr %19, i64 %20
  %21 = load i32, ptr %type.addr, align 4
  %call19 = call i32 @PyObject_GetBuffer(ptr noundef %17, ptr noundef %arrayidx, i32 noundef %21)
  %cmp20 = icmp eq i32 %call19, -1
  br i1 %cmp20, label %if.then21, label %if.end22

if.then21:                                        ; preds = %if.end18
  %22 = load ptr, ptr %item, align 8
  store ptr %22, ptr %op.addr.i35, align 8
  %23 = load ptr, ptr %op.addr.i35, align 8
  store ptr %23, ptr %op.addr.i44, align 8
  %24 = load ptr, ptr %op.addr.i44, align 8
  %25 = load i64, ptr %24, align 8
  %conv.i = trunc i64 %25 to i32
  %cmp.i45 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i45 to i32
  %tobool.i37 = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i37, label %if.then.i42, label %if.end.i38

if.then.i42:                                      ; preds = %if.then21
  br label %Py_DECREF.exit43

if.end.i38:                                       ; preds = %if.then21
  %26 = load ptr, ptr %op.addr.i35, align 8
  %27 = load i64, ptr %26, align 8
  %dec.i39 = add i64 %27, -1
  store i64 %dec.i39, ptr %26, align 8
  %cmp.i40 = icmp eq i64 %dec.i39, 0
  br i1 %cmp.i40, label %if.then1.i41, label %Py_DECREF.exit43

if.then1.i41:                                     ; preds = %if.end.i38
  %28 = load ptr, ptr %op.addr.i35, align 8
  call void @_Py_Dealloc(ptr noundef %28) #10
  br label %Py_DECREF.exit43

Py_DECREF.exit43:                                 ; preds = %if.then1.i41, %if.end.i38, %if.then.i42
  br label %fail

if.end22:                                         ; preds = %if.end18
  %29 = load ptr, ptr %item, align 8
  store ptr %29, ptr %op.addr.i, align 8
  %30 = load ptr, ptr %op.addr.i, align 8
  store ptr %30, ptr %op.addr.i46, align 8
  %31 = load ptr, ptr %op.addr.i46, align 8
  %32 = load i64, ptr %31, align 8
  %conv.i47 = trunc i64 %32 to i32
  %cmp.i48 = icmp slt i32 %conv.i47, 0
  %conv1.i49 = zext i1 %cmp.i48 to i32
  %tobool.i = icmp ne i32 %conv1.i49, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.end22
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.end22
  %33 = load ptr, ptr %op.addr.i, align 8
  %34 = load i64, ptr %33, align 8
  %dec.i = add i64 %34, -1
  store i64 %dec.i, ptr %33, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %35 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %35) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  %36 = load ptr, ptr %buf.addr, align 8
  %37 = load ptr, ptr %36, align 8
  %38 = load i64, ptr %i, align 8
  %arrayidx23 = getelementptr %struct.Py_buffer, ptr %37, i64 %38
  %buf24 = getelementptr inbounds %struct.Py_buffer, ptr %arrayidx23, i32 0, i32 0
  %39 = load ptr, ptr %buf24, align 8
  %40 = load ptr, ptr %iov.addr, align 8
  %41 = load ptr, ptr %40, align 8
  %42 = load i64, ptr %i, align 8
  %arrayidx25 = getelementptr %struct.iovec, ptr %41, i64 %42
  %iov_base = getelementptr inbounds %struct.iovec, ptr %arrayidx25, i32 0, i32 0
  store ptr %39, ptr %iov_base, align 8
  %43 = load ptr, ptr %buf.addr, align 8
  %44 = load ptr, ptr %43, align 8
  %45 = load i64, ptr %i, align 8
  %arrayidx26 = getelementptr %struct.Py_buffer, ptr %44, i64 %45
  %len = getelementptr inbounds %struct.Py_buffer, ptr %arrayidx26, i32 0, i32 2
  %46 = load i64, ptr %len, align 8
  %47 = load ptr, ptr %iov.addr, align 8
  %48 = load ptr, ptr %47, align 8
  %49 = load i64, ptr %i, align 8
  %arrayidx27 = getelementptr %struct.iovec, ptr %48, i64 %49
  %iov_len = getelementptr inbounds %struct.iovec, ptr %arrayidx27, i32 0, i32 1
  store i64 %46, ptr %iov_len, align 8
  br label %for.inc

for.inc:                                          ; preds = %Py_DECREF.exit
  %50 = load i64, ptr %i, align 8
  %inc = add i64 %50, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !31

for.end:                                          ; preds = %for.cond
  store i32 0, ptr %retval, align 4
  br label %return

fail:                                             ; preds = %Py_DECREF.exit43, %if.then17
  %51 = load ptr, ptr %iov.addr, align 8
  %52 = load ptr, ptr %51, align 8
  call void @PyMem_Free(ptr noundef %52)
  store i64 0, ptr %j, align 8
  br label %for.cond28

for.cond28:                                       ; preds = %for.inc32, %fail
  %53 = load i64, ptr %j, align 8
  %54 = load i64, ptr %i, align 8
  %cmp29 = icmp slt i64 %53, %54
  br i1 %cmp29, label %for.body30, label %for.end34

for.body30:                                       ; preds = %for.cond28
  %55 = load ptr, ptr %buf.addr, align 8
  %56 = load ptr, ptr %55, align 8
  %57 = load i64, ptr %j, align 8
  %arrayidx31 = getelementptr %struct.Py_buffer, ptr %56, i64 %57
  call void @PyBuffer_Release(ptr noundef %arrayidx31)
  br label %for.inc32

for.inc32:                                        ; preds = %for.body30
  %58 = load i64, ptr %j, align 8
  %inc33 = add i64 %58, 1
  store i64 %inc33, ptr %j, align 8
  br label %for.cond28, !llvm.loop !32

for.end34:                                        ; preds = %for.cond28
  %59 = load ptr, ptr %buf.addr, align 8
  %60 = load ptr, ptr %59, align 8
  call void @PyMem_Free(ptr noundef %60)
  store i32 -1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end34, %for.end, %if.then11, %if.then
  %61 = load i32, ptr %retval, align 4
  ret i32 %61
}

declare i64 @readv(i32 noundef, ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define internal void @iov_cleanup(ptr noundef %iov, ptr noundef %buf, i32 noundef %cnt) #0 {
entry:
  %iov.addr = alloca ptr, align 8
  %buf.addr = alloca ptr, align 8
  %cnt.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %iov, ptr %iov.addr, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store i32 %cnt, ptr %cnt.addr, align 4
  %0 = load ptr, ptr %iov.addr, align 8
  call void @PyMem_Free(ptr noundef %0)
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, ptr %i, align 4
  %2 = load i32, ptr %cnt.addr, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %buf.addr, align 8
  %4 = load i32, ptr %i, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr %struct.Py_buffer, ptr %3, i64 %idxprom
  call void @PyBuffer_Release(ptr noundef %arrayidx)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %5 = load i32, ptr %i, align 4
  %inc = add i32 %5, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !33

for.end:                                          ; preds = %for.cond
  %6 = load ptr, ptr %buf.addr, align 8
  call void @PyMem_Free(ptr noundef %6)
  ret void
}

declare i32 @PyObject_GetBuffer(ptr noundef, ptr noundef, i32 noundef) #1

declare void @PyBuffer_Release(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @os_pread_impl(ptr noundef %module, i32 noundef %fd, i64 noundef %length, i64 noundef %offset) #0 {
entry:
  %op.addr.i24 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %length.addr = alloca i64, align 8
  %offset.addr = alloca i64, align 8
  %n = alloca i64, align 8
  %async_err = alloca i32, align 4
  %buffer = alloca ptr, align 8
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i64 %length, ptr %length.addr, align 8
  store i64 %offset, ptr %offset.addr, align 8
  store i32 0, ptr %async_err, align 4
  %0 = load i64, ptr %length.addr, align 8
  %cmp = icmp slt i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call ptr @__errno_location() #12
  store i32 22, ptr %call, align 4
  %call1 = call ptr @posix_error()
  store ptr %call1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, ptr %length.addr, align 8
  %call2 = call ptr @PyBytes_FromStringAndSize(ptr noundef null, i64 noundef %1)
  store ptr %call2, ptr %buffer, align 8
  %2 = load ptr, ptr %buffer, align 8
  %cmp3 = icmp eq ptr %2, null
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end5:                                          ; preds = %if.end
  br label %do.body

do.body:                                          ; preds = %land.end, %if.end5
  %call6 = call ptr @PyEval_SaveThread()
  store ptr %call6, ptr %_save, align 8
  %3 = load i32, ptr %fd.addr, align 4
  %4 = load ptr, ptr %buffer, align 8
  %call7 = call ptr @PyBytes_AS_STRING(ptr noundef %4)
  %5 = load i64, ptr %length.addr, align 8
  %6 = load i64, ptr %offset.addr, align 8
  %call8 = call i64 @pread64(i32 noundef %3, ptr noundef %call7, i64 noundef %5, i64 noundef %6)
  store i64 %call8, ptr %n, align 8
  %7 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %7)
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %8 = load i64, ptr %n, align 8
  %cmp9 = icmp slt i64 %8, 0
  br i1 %cmp9, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %do.cond
  %call10 = call ptr @__errno_location() #12
  %9 = load i32, ptr %call10, align 4
  %cmp11 = icmp eq i32 %9, 4
  br i1 %cmp11, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %call12 = call i32 @PyErr_CheckSignals()
  store i32 %call12, ptr %async_err, align 4
  %tobool = icmp ne i32 %call12, 0
  %lnot = xor i1 %tobool, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %do.cond
  %10 = phi i1 [ false, %land.lhs.true ], [ false, %do.cond ], [ %lnot, %land.rhs ]
  br i1 %10, label %do.body, label %do.end, !llvm.loop !34

do.end:                                           ; preds = %land.end
  %11 = load i64, ptr %n, align 8
  %cmp13 = icmp slt i64 %11, 0
  br i1 %cmp13, label %if.then14, label %if.end19

if.then14:                                        ; preds = %do.end
  %12 = load i32, ptr %async_err, align 4
  %tobool15 = icmp ne i32 %12, 0
  br i1 %tobool15, label %if.end18, label %if.then16

if.then16:                                        ; preds = %if.then14
  %call17 = call ptr @posix_error()
  br label %if.end18

if.end18:                                         ; preds = %if.then16, %if.then14
  %13 = load ptr, ptr %buffer, align 8
  store ptr %13, ptr %op.addr.i, align 8
  %14 = load ptr, ptr %op.addr.i, align 8
  store ptr %14, ptr %op.addr.i24, align 8
  %15 = load ptr, ptr %op.addr.i24, align 8
  %16 = load i64, ptr %15, align 8
  %conv.i = trunc i64 %16 to i32
  %cmp.i25 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i25 to i32
  %tobool.i = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.end18
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.end18
  %17 = load ptr, ptr %op.addr.i, align 8
  %18 = load i64, ptr %17, align 8
  %dec.i = add i64 %18, -1
  store i64 %dec.i, ptr %17, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %19 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %19) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  store ptr null, ptr %retval, align 8
  br label %return

if.end19:                                         ; preds = %do.end
  %20 = load i64, ptr %n, align 8
  %21 = load i64, ptr %length.addr, align 8
  %cmp20 = icmp ne i64 %20, %21
  br i1 %cmp20, label %if.then21, label %if.end23

if.then21:                                        ; preds = %if.end19
  %22 = load i64, ptr %n, align 8
  %call22 = call i32 @_PyBytes_Resize(ptr noundef %buffer, i64 noundef %22)
  br label %if.end23

if.end23:                                         ; preds = %if.then21, %if.end19
  %23 = load ptr, ptr %buffer, align 8
  store ptr %23, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end23, %Py_DECREF.exit, %if.then4, %if.then
  %24 = load ptr, ptr %retval, align 8
  ret ptr %24
}

declare i64 @pread64(i32 noundef, ptr noundef, i64 noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define internal i64 @os_preadv_impl(ptr noundef %module, i32 noundef %fd, ptr noundef %buffers, i64 noundef %offset, i32 noundef %flags) #0 {
entry:
  %retval = alloca i64, align 8
  %module.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %buffers.addr = alloca ptr, align 8
  %offset.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  %cnt = alloca i64, align 8
  %n = alloca i64, align 8
  %async_err = alloca i32, align 4
  %iov = alloca ptr, align 8
  %buf = alloca ptr, align 8
  %_save = alloca ptr, align 8
  %saved_errno = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store ptr %buffers, ptr %buffers.addr, align 8
  store i64 %offset, ptr %offset.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  store i32 0, ptr %async_err, align 4
  %0 = load ptr, ptr %buffers.addr, align 8
  %call = call i32 @PySequence_Check(ptr noundef %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr @PyExc_TypeError, align 8
  call void @PyErr_SetString(ptr noundef %1, ptr noundef @.str.349)
  store i64 -1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %buffers.addr, align 8
  %call1 = call i64 @PySequence_Size(ptr noundef %2)
  store i64 %call1, ptr %cnt, align 8
  %3 = load i64, ptr %cnt, align 8
  %cmp = icmp slt i64 %3, 0
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i64 -1, ptr %retval, align 8
  br label %return

if.end3:                                          ; preds = %if.end
  %4 = load ptr, ptr %buffers.addr, align 8
  %5 = load i64, ptr %cnt, align 8
  %call4 = call i32 @iov_setup(ptr noundef %iov, ptr noundef %buf, ptr noundef %4, i64 noundef %5, i32 noundef 1)
  %cmp5 = icmp slt i32 %call4, 0
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end3
  store i64 -1, ptr %retval, align 8
  br label %return

if.end7:                                          ; preds = %if.end3
  br label %do.body

do.body:                                          ; preds = %land.end, %if.end7
  %call8 = call ptr @PyEval_SaveThread()
  store ptr %call8, ptr %_save, align 8
  %6 = load i32, ptr %fd.addr, align 4
  %7 = load ptr, ptr %iov, align 8
  %8 = load i64, ptr %cnt, align 8
  %conv = trunc i64 %8 to i32
  %9 = load i64, ptr %offset.addr, align 8
  %10 = load i32, ptr %flags.addr, align 4
  %call9 = call i64 @preadv64v2(i32 noundef %6, ptr noundef %7, i32 noundef %conv, i64 noundef %9, i32 noundef %10)
  store i64 %call9, ptr %n, align 8
  %11 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %11)
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %12 = load i64, ptr %n, align 8
  %cmp10 = icmp slt i64 %12, 0
  br i1 %cmp10, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %do.cond
  %call12 = call ptr @__errno_location() #12
  %13 = load i32, ptr %call12, align 4
  %cmp13 = icmp eq i32 %13, 4
  br i1 %cmp13, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %call15 = call i32 @PyErr_CheckSignals()
  store i32 %call15, ptr %async_err, align 4
  %tobool16 = icmp ne i32 %call15, 0
  %lnot = xor i1 %tobool16, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %do.cond
  %14 = phi i1 [ false, %land.lhs.true ], [ false, %do.cond ], [ %lnot, %land.rhs ]
  br i1 %14, label %do.body, label %do.end, !llvm.loop !35

do.end:                                           ; preds = %land.end
  %call17 = call ptr @__errno_location() #12
  %15 = load i32, ptr %call17, align 4
  store i32 %15, ptr %saved_errno, align 4
  %16 = load ptr, ptr %iov, align 8
  %17 = load ptr, ptr %buf, align 8
  %18 = load i64, ptr %cnt, align 8
  %conv18 = trunc i64 %18 to i32
  call void @iov_cleanup(ptr noundef %16, ptr noundef %17, i32 noundef %conv18)
  %19 = load i64, ptr %n, align 8
  %cmp19 = icmp slt i64 %19, 0
  br i1 %cmp19, label %if.then21, label %if.end27

if.then21:                                        ; preds = %do.end
  %20 = load i32, ptr %async_err, align 4
  %tobool22 = icmp ne i32 %20, 0
  br i1 %tobool22, label %if.end26, label %if.then23

if.then23:                                        ; preds = %if.then21
  %21 = load i32, ptr %saved_errno, align 4
  %call24 = call ptr @__errno_location() #12
  store i32 %21, ptr %call24, align 4
  %call25 = call ptr @posix_error()
  br label %if.end26

if.end26:                                         ; preds = %if.then23, %if.then21
  store i64 -1, ptr %retval, align 8
  br label %return

if.end27:                                         ; preds = %do.end
  %22 = load i64, ptr %n, align 8
  store i64 %22, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end27, %if.end26, %if.then6, %if.then2, %if.then
  %23 = load i64, ptr %retval, align 8
  ret i64 %23
}

declare i64 @preadv64v2(i32 noundef, ptr noundef, i32 noundef, i64 noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define internal i64 @os_write_impl(ptr noundef %module, i32 noundef %fd, ptr noundef %data) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %data.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store ptr %data, ptr %data.addr, align 8
  %0 = load i32, ptr %fd.addr, align 4
  %1 = load ptr, ptr %data.addr, align 8
  %buf = getelementptr inbounds %struct.Py_buffer, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %buf, align 8
  %3 = load ptr, ptr %data.addr, align 8
  %len = getelementptr inbounds %struct.Py_buffer, ptr %3, i32 0, i32 2
  %4 = load i64, ptr %len, align 8
  %call = call i64 @_Py_write(i32 noundef %0, ptr noundef %2, i64 noundef %4)
  ret i64 %call
}

declare i64 @_Py_write(i32 noundef, ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define internal i64 @os_writev_impl(ptr noundef %module, i32 noundef %fd, ptr noundef %buffers) #0 {
entry:
  %retval = alloca i64, align 8
  %module.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %buffers.addr = alloca ptr, align 8
  %cnt = alloca i64, align 8
  %result = alloca i64, align 8
  %async_err = alloca i32, align 4
  %iov = alloca ptr, align 8
  %buf = alloca ptr, align 8
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store ptr %buffers, ptr %buffers.addr, align 8
  store i32 0, ptr %async_err, align 4
  %0 = load ptr, ptr %buffers.addr, align 8
  %call = call i32 @PySequence_Check(ptr noundef %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr @PyExc_TypeError, align 8
  call void @PyErr_SetString(ptr noundef %1, ptr noundef @.str.350)
  store i64 -1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %buffers.addr, align 8
  %call1 = call i64 @PySequence_Size(ptr noundef %2)
  store i64 %call1, ptr %cnt, align 8
  %3 = load i64, ptr %cnt, align 8
  %cmp = icmp slt i64 %3, 0
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i64 -1, ptr %retval, align 8
  br label %return

if.end3:                                          ; preds = %if.end
  %4 = load ptr, ptr %buffers.addr, align 8
  %5 = load i64, ptr %cnt, align 8
  %call4 = call i32 @iov_setup(ptr noundef %iov, ptr noundef %buf, ptr noundef %4, i64 noundef %5, i32 noundef 0)
  %cmp5 = icmp slt i32 %call4, 0
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end3
  store i64 -1, ptr %retval, align 8
  br label %return

if.end7:                                          ; preds = %if.end3
  br label %do.body

do.body:                                          ; preds = %land.end, %if.end7
  %call8 = call ptr @PyEval_SaveThread()
  store ptr %call8, ptr %_save, align 8
  %6 = load i32, ptr %fd.addr, align 4
  %7 = load ptr, ptr %iov, align 8
  %8 = load i64, ptr %cnt, align 8
  %conv = trunc i64 %8 to i32
  %call9 = call i64 @writev(i32 noundef %6, ptr noundef %7, i32 noundef %conv)
  store i64 %call9, ptr %result, align 8
  %9 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %9)
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %10 = load i64, ptr %result, align 8
  %cmp10 = icmp slt i64 %10, 0
  br i1 %cmp10, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %do.cond
  %call12 = call ptr @__errno_location() #12
  %11 = load i32, ptr %call12, align 4
  %cmp13 = icmp eq i32 %11, 4
  br i1 %cmp13, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %call15 = call i32 @PyErr_CheckSignals()
  store i32 %call15, ptr %async_err, align 4
  %tobool16 = icmp ne i32 %call15, 0
  %lnot = xor i1 %tobool16, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %do.cond
  %12 = phi i1 [ false, %land.lhs.true ], [ false, %do.cond ], [ %lnot, %land.rhs ]
  br i1 %12, label %do.body, label %do.end, !llvm.loop !36

do.end:                                           ; preds = %land.end
  %13 = load i64, ptr %result, align 8
  %cmp17 = icmp slt i64 %13, 0
  br i1 %cmp17, label %land.lhs.true19, label %if.end23

land.lhs.true19:                                  ; preds = %do.end
  %14 = load i32, ptr %async_err, align 4
  %tobool20 = icmp ne i32 %14, 0
  br i1 %tobool20, label %if.end23, label %if.then21

if.then21:                                        ; preds = %land.lhs.true19
  %call22 = call ptr @posix_error()
  br label %if.end23

if.end23:                                         ; preds = %if.then21, %land.lhs.true19, %do.end
  %15 = load ptr, ptr %iov, align 8
  %16 = load ptr, ptr %buf, align 8
  %17 = load i64, ptr %cnt, align 8
  %conv24 = trunc i64 %17 to i32
  call void @iov_cleanup(ptr noundef %15, ptr noundef %16, i32 noundef %conv24)
  %18 = load i64, ptr %result, align 8
  store i64 %18, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end23, %if.then6, %if.then2, %if.then
  %19 = load i64, ptr %retval, align 8
  ret i64 %19
}

declare i64 @writev(i32 noundef, ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define internal i64 @os_pwrite_impl(ptr noundef %module, i32 noundef %fd, ptr noundef %buffer, i64 noundef %offset) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %buffer.addr = alloca ptr, align 8
  %offset.addr = alloca i64, align 8
  %size = alloca i64, align 8
  %async_err = alloca i32, align 4
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store ptr %buffer, ptr %buffer.addr, align 8
  store i64 %offset, ptr %offset.addr, align 8
  store i32 0, ptr %async_err, align 4
  br label %do.body

do.body:                                          ; preds = %land.end, %entry
  %call = call ptr @PyEval_SaveThread()
  store ptr %call, ptr %_save, align 8
  %0 = load i32, ptr %fd.addr, align 4
  %1 = load ptr, ptr %buffer.addr, align 8
  %buf = getelementptr inbounds %struct.Py_buffer, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %buf, align 8
  %3 = load ptr, ptr %buffer.addr, align 8
  %len = getelementptr inbounds %struct.Py_buffer, ptr %3, i32 0, i32 2
  %4 = load i64, ptr %len, align 8
  %5 = load i64, ptr %offset.addr, align 8
  %call1 = call i64 @pwrite64(i32 noundef %0, ptr noundef %2, i64 noundef %4, i64 noundef %5)
  store i64 %call1, ptr %size, align 8
  %6 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %6)
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %7 = load i64, ptr %size, align 8
  %cmp = icmp slt i64 %7, 0
  br i1 %cmp, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %do.cond
  %call2 = call ptr @__errno_location() #12
  %8 = load i32, ptr %call2, align 4
  %cmp3 = icmp eq i32 %8, 4
  br i1 %cmp3, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %call4 = call i32 @PyErr_CheckSignals()
  store i32 %call4, ptr %async_err, align 4
  %tobool = icmp ne i32 %call4, 0
  %lnot = xor i1 %tobool, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %do.cond
  %9 = phi i1 [ false, %land.lhs.true ], [ false, %do.cond ], [ %lnot, %land.rhs ]
  br i1 %9, label %do.body, label %do.end, !llvm.loop !37

do.end:                                           ; preds = %land.end
  %10 = load i64, ptr %size, align 8
  %cmp5 = icmp slt i64 %10, 0
  br i1 %cmp5, label %land.lhs.true6, label %if.end

land.lhs.true6:                                   ; preds = %do.end
  %11 = load i32, ptr %async_err, align 4
  %tobool7 = icmp ne i32 %11, 0
  br i1 %tobool7, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true6
  %call8 = call ptr @posix_error()
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true6, %do.end
  %12 = load i64, ptr %size, align 8
  ret i64 %12
}

declare i64 @pwrite64(i32 noundef, ptr noundef, i64 noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define internal i64 @os_pwritev_impl(ptr noundef %module, i32 noundef %fd, ptr noundef %buffers, i64 noundef %offset, i32 noundef %flags) #0 {
entry:
  %retval = alloca i64, align 8
  %module.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %buffers.addr = alloca ptr, align 8
  %offset.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  %cnt = alloca i64, align 8
  %result = alloca i64, align 8
  %async_err = alloca i32, align 4
  %iov = alloca ptr, align 8
  %buf = alloca ptr, align 8
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store ptr %buffers, ptr %buffers.addr, align 8
  store i64 %offset, ptr %offset.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  store i32 0, ptr %async_err, align 4
  %0 = load ptr, ptr %buffers.addr, align 8
  %call = call i32 @PySequence_Check(ptr noundef %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr @PyExc_TypeError, align 8
  call void @PyErr_SetString(ptr noundef %1, ptr noundef @.str.351)
  store i64 -1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %buffers.addr, align 8
  %call1 = call i64 @PySequence_Size(ptr noundef %2)
  store i64 %call1, ptr %cnt, align 8
  %3 = load i64, ptr %cnt, align 8
  %cmp = icmp slt i64 %3, 0
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i64 -1, ptr %retval, align 8
  br label %return

if.end3:                                          ; preds = %if.end
  %4 = load ptr, ptr %buffers.addr, align 8
  %5 = load i64, ptr %cnt, align 8
  %call4 = call i32 @iov_setup(ptr noundef %iov, ptr noundef %buf, ptr noundef %4, i64 noundef %5, i32 noundef 0)
  %cmp5 = icmp slt i32 %call4, 0
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end3
  store i64 -1, ptr %retval, align 8
  br label %return

if.end7:                                          ; preds = %if.end3
  br label %do.body

do.body:                                          ; preds = %land.end, %if.end7
  %call8 = call ptr @PyEval_SaveThread()
  store ptr %call8, ptr %_save, align 8
  %6 = load i32, ptr %fd.addr, align 4
  %7 = load ptr, ptr %iov, align 8
  %8 = load i64, ptr %cnt, align 8
  %conv = trunc i64 %8 to i32
  %9 = load i64, ptr %offset.addr, align 8
  %10 = load i32, ptr %flags.addr, align 4
  %call9 = call i64 @pwritev64v2(i32 noundef %6, ptr noundef %7, i32 noundef %conv, i64 noundef %9, i32 noundef %10)
  store i64 %call9, ptr %result, align 8
  %11 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %11)
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %12 = load i64, ptr %result, align 8
  %cmp10 = icmp slt i64 %12, 0
  br i1 %cmp10, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %do.cond
  %call12 = call ptr @__errno_location() #12
  %13 = load i32, ptr %call12, align 4
  %cmp13 = icmp eq i32 %13, 4
  br i1 %cmp13, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %call15 = call i32 @PyErr_CheckSignals()
  store i32 %call15, ptr %async_err, align 4
  %tobool16 = icmp ne i32 %call15, 0
  %lnot = xor i1 %tobool16, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %do.cond
  %14 = phi i1 [ false, %land.lhs.true ], [ false, %do.cond ], [ %lnot, %land.rhs ]
  br i1 %14, label %do.body, label %do.end, !llvm.loop !38

do.end:                                           ; preds = %land.end
  %15 = load i64, ptr %result, align 8
  %cmp17 = icmp slt i64 %15, 0
  br i1 %cmp17, label %if.then19, label %if.end24

if.then19:                                        ; preds = %do.end
  %16 = load i32, ptr %async_err, align 4
  %tobool20 = icmp ne i32 %16, 0
  br i1 %tobool20, label %if.end23, label %if.then21

if.then21:                                        ; preds = %if.then19
  %call22 = call ptr @posix_error()
  br label %if.end23

if.end23:                                         ; preds = %if.then21, %if.then19
  store i64 -1, ptr %result, align 8
  br label %if.end24

if.end24:                                         ; preds = %if.end23, %do.end
  %17 = load ptr, ptr %iov, align 8
  %18 = load ptr, ptr %buf, align 8
  %19 = load i64, ptr %cnt, align 8
  %conv25 = trunc i64 %19 to i32
  call void @iov_cleanup(ptr noundef %17, ptr noundef %18, i32 noundef %conv25)
  %20 = load i64, ptr %result, align 8
  store i64 %20, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end24, %if.then6, %if.then2, %if.then
  %21 = load i64, ptr %retval, align 8
  ret i64 %21
}

declare i64 @pwritev64v2(i32 noundef, ptr noundef, i32 noundef, i64 noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @os_sendfile_impl(ptr noundef %module, i32 noundef %out_fd, i32 noundef %in_fd, ptr noundef %offobj, i64 noundef %count) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %out_fd.addr = alloca i32, align 4
  %in_fd.addr = alloca i32, align 4
  %offobj.addr = alloca ptr, align 8
  %count.addr = alloca i64, align 8
  %ret = alloca i64, align 8
  %async_err = alloca i32, align 4
  %_save = alloca ptr, align 8
  %offset = alloca i64, align 8
  %_save17 = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %out_fd, ptr %out_fd.addr, align 4
  store i32 %in_fd, ptr %in_fd.addr, align 4
  store ptr %offobj, ptr %offobj.addr, align 8
  store i64 %count, ptr %count.addr, align 8
  store i32 0, ptr %async_err, align 4
  %0 = load ptr, ptr %offobj.addr, align 8
  %cmp = icmp eq ptr %0, @_Py_NoneStruct
  br i1 %cmp, label %if.then, label %if.end11

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %land.end, %if.then
  %call = call ptr @PyEval_SaveThread()
  store ptr %call, ptr %_save, align 8
  %1 = load i32, ptr %out_fd.addr, align 4
  %2 = load i32, ptr %in_fd.addr, align 4
  %3 = load i64, ptr %count.addr, align 8
  %call1 = call i64 @sendfile64(i32 noundef %1, i32 noundef %2, ptr noundef null, i64 noundef %3) #10
  store i64 %call1, ptr %ret, align 8
  %4 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %4)
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %5 = load i64, ptr %ret, align 8
  %cmp2 = icmp slt i64 %5, 0
  br i1 %cmp2, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %do.cond
  %call3 = call ptr @__errno_location() #12
  %6 = load i32, ptr %call3, align 4
  %cmp4 = icmp eq i32 %6, 4
  br i1 %cmp4, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %call5 = call i32 @PyErr_CheckSignals()
  store i32 %call5, ptr %async_err, align 4
  %tobool = icmp ne i32 %call5, 0
  %lnot = xor i1 %tobool, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %do.cond
  %7 = phi i1 [ false, %land.lhs.true ], [ false, %do.cond ], [ %lnot, %land.rhs ]
  br i1 %7, label %do.body, label %do.end, !llvm.loop !39

do.end:                                           ; preds = %land.end
  %8 = load i64, ptr %ret, align 8
  %cmp6 = icmp slt i64 %8, 0
  br i1 %cmp6, label %if.then7, label %if.end

if.then7:                                         ; preds = %do.end
  %9 = load i32, ptr %async_err, align 4
  %tobool8 = icmp ne i32 %9, 0
  br i1 %tobool8, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then7
  %call9 = call ptr @posix_error()
  br label %cond.end

cond.false:                                       ; preds = %if.then7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call9, %cond.true ], [ null, %cond.false ]
  store ptr %cond, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %do.end
  %10 = load i64, ptr %ret, align 8
  %call10 = call ptr @PyLong_FromSsize_t(i64 noundef %10)
  store ptr %call10, ptr %retval, align 8
  br label %return

if.end11:                                         ; preds = %entry
  %11 = load ptr, ptr %offobj.addr, align 8
  %call12 = call i32 @Py_off_t_converter(ptr noundef %11, ptr noundef %offset)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end11
  store ptr null, ptr %retval, align 8
  br label %return

if.end15:                                         ; preds = %if.end11
  br label %do.body16

do.body16:                                        ; preds = %land.end29, %if.end15
  %call18 = call ptr @PyEval_SaveThread()
  store ptr %call18, ptr %_save17, align 8
  %12 = load i32, ptr %out_fd.addr, align 4
  %13 = load i32, ptr %in_fd.addr, align 4
  %14 = load i64, ptr %count.addr, align 8
  %call19 = call i64 @sendfile64(i32 noundef %12, i32 noundef %13, ptr noundef %offset, i64 noundef %14) #10
  store i64 %call19, ptr %ret, align 8
  %15 = load ptr, ptr %_save17, align 8
  call void @PyEval_RestoreThread(ptr noundef %15)
  br label %do.cond20

do.cond20:                                        ; preds = %do.body16
  %16 = load i64, ptr %ret, align 8
  %cmp21 = icmp slt i64 %16, 0
  br i1 %cmp21, label %land.lhs.true22, label %land.end29

land.lhs.true22:                                  ; preds = %do.cond20
  %call23 = call ptr @__errno_location() #12
  %17 = load i32, ptr %call23, align 4
  %cmp24 = icmp eq i32 %17, 4
  br i1 %cmp24, label %land.rhs25, label %land.end29

land.rhs25:                                       ; preds = %land.lhs.true22
  %call26 = call i32 @PyErr_CheckSignals()
  store i32 %call26, ptr %async_err, align 4
  %tobool27 = icmp ne i32 %call26, 0
  %lnot28 = xor i1 %tobool27, true
  br label %land.end29

land.end29:                                       ; preds = %land.rhs25, %land.lhs.true22, %do.cond20
  %18 = phi i1 [ false, %land.lhs.true22 ], [ false, %do.cond20 ], [ %lnot28, %land.rhs25 ]
  br i1 %18, label %do.body16, label %do.end30, !llvm.loop !40

do.end30:                                         ; preds = %land.end29
  %19 = load i64, ptr %ret, align 8
  %cmp31 = icmp slt i64 %19, 0
  br i1 %cmp31, label %if.then32, label %if.end39

if.then32:                                        ; preds = %do.end30
  %20 = load i32, ptr %async_err, align 4
  %tobool33 = icmp ne i32 %20, 0
  br i1 %tobool33, label %cond.false36, label %cond.true34

cond.true34:                                      ; preds = %if.then32
  %call35 = call ptr @posix_error()
  br label %cond.end37

cond.false36:                                     ; preds = %if.then32
  br label %cond.end37

cond.end37:                                       ; preds = %cond.false36, %cond.true34
  %cond38 = phi ptr [ %call35, %cond.true34 ], [ null, %cond.false36 ]
  store ptr %cond38, ptr %retval, align 8
  br label %return

if.end39:                                         ; preds = %do.end30
  %21 = load i64, ptr %ret, align 8
  %call40 = call ptr @PyLong_FromSsize_t(i64 noundef %21)
  store ptr %call40, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end39, %cond.end37, %if.then14, %if.end, %cond.end
  %22 = load ptr, ptr %retval, align 8
  ret ptr %22
}

; Function Attrs: nounwind
declare i64 @sendfile64(i32 noundef, i32 noundef, ptr noundef, i64 noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_fstat_impl(ptr noundef %module, i32 noundef %fd) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %st = alloca %struct.stat, align 8
  %res = alloca i32, align 4
  %async_err = alloca i32, align 4
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i32 0, ptr %async_err, align 4
  br label %do.body

do.body:                                          ; preds = %land.end, %entry
  %call = call ptr @PyEval_SaveThread()
  store ptr %call, ptr %_save, align 8
  %0 = load i32, ptr %fd.addr, align 4
  %call1 = call i32 @fstat64(i32 noundef %0, ptr noundef %st) #10
  store i32 %call1, ptr %res, align 4
  %1 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %1)
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %2 = load i32, ptr %res, align 4
  %cmp = icmp ne i32 %2, 0
  br i1 %cmp, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %do.cond
  %call2 = call ptr @__errno_location() #12
  %3 = load i32, ptr %call2, align 4
  %cmp3 = icmp eq i32 %3, 4
  br i1 %cmp3, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %call4 = call i32 @PyErr_CheckSignals()
  store i32 %call4, ptr %async_err, align 4
  %tobool = icmp ne i32 %call4, 0
  %lnot = xor i1 %tobool, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %do.cond
  %4 = phi i1 [ false, %land.lhs.true ], [ false, %do.cond ], [ %lnot, %land.rhs ]
  br i1 %4, label %do.body, label %do.end, !llvm.loop !41

do.end:                                           ; preds = %land.end
  %5 = load i32, ptr %res, align 4
  %cmp5 = icmp ne i32 %5, 0
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %do.end
  %6 = load i32, ptr %async_err, align 4
  %tobool6 = icmp ne i32 %6, 0
  br i1 %tobool6, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then
  %call7 = call ptr @posix_error()
  br label %cond.end

cond.false:                                       ; preds = %if.then
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call7, %cond.true ], [ null, %cond.false ]
  store ptr %cond, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %do.end
  %7 = load ptr, ptr %module.addr, align 8
  %call8 = call ptr @_pystat_fromstructstat(ptr noundef %7, ptr noundef %st)
  store ptr %call8, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %cond.end
  %8 = load ptr, ptr %retval, align 8
  ret ptr %8
}

; Function Attrs: nounwind uwtable
define internal i32 @os_isatty_impl(ptr noundef %module, i32 noundef %fd) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %return_value = alloca i32, align 4
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  %call = call ptr @PyEval_SaveThread()
  store ptr %call, ptr %_save, align 8
  %0 = load i32, ptr %fd.addr, align 4
  %call1 = call i32 @isatty(i32 noundef %0) #10
  store i32 %call1, ptr %return_value, align 4
  %1 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %1)
  %2 = load i32, ptr %return_value, align 4
  ret i32 %2
}

; Function Attrs: nounwind
declare i32 @isatty(i32 noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_pipe_impl(ptr noundef %module) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %fds = alloca [2 x i32], align 4
  %res = alloca i32, align 4
  %_save = alloca ptr, align 8
  %_save4 = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  %call = call ptr @PyEval_SaveThread()
  store ptr %call, ptr %_save, align 8
  %arraydecay = getelementptr inbounds [2 x i32], ptr %fds, i64 0, i64 0
  %call1 = call i32 @pipe2(ptr noundef %arraydecay, i32 noundef 524288) #10
  store i32 %call1, ptr %res, align 4
  %0 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %0)
  %1 = load i32, ptr %res, align 4
  %cmp = icmp ne i32 %1, 0
  br i1 %cmp, label %land.lhs.true, label %if.end27

land.lhs.true:                                    ; preds = %entry
  %call2 = call ptr @__errno_location() #12
  %2 = load i32, ptr %call2, align 4
  %cmp3 = icmp eq i32 %2, 38
  br i1 %cmp3, label %if.then, label %if.end27

if.then:                                          ; preds = %land.lhs.true
  %call5 = call ptr @PyEval_SaveThread()
  store ptr %call5, ptr %_save4, align 8
  %arraydecay6 = getelementptr inbounds [2 x i32], ptr %fds, i64 0, i64 0
  %call7 = call i32 @pipe(ptr noundef %arraydecay6) #10
  store i32 %call7, ptr %res, align 4
  %3 = load ptr, ptr %_save4, align 8
  call void @PyEval_RestoreThread(ptr noundef %3)
  %4 = load i32, ptr %res, align 4
  %cmp8 = icmp eq i32 %4, 0
  br i1 %cmp8, label %if.then9, label %if.end26

if.then9:                                         ; preds = %if.then
  %arrayidx = getelementptr [2 x i32], ptr %fds, i64 0, i64 0
  %5 = load i32, ptr %arrayidx, align 4
  %call10 = call i32 @_Py_set_inheritable(i32 noundef %5, i32 noundef 0, ptr noundef null)
  %cmp11 = icmp slt i32 %call10, 0
  br i1 %cmp11, label %if.then12, label %if.end

if.then12:                                        ; preds = %if.then9
  %arrayidx13 = getelementptr [2 x i32], ptr %fds, i64 0, i64 0
  %6 = load i32, ptr %arrayidx13, align 4
  %call14 = call i32 @close(i32 noundef %6)
  %arrayidx15 = getelementptr [2 x i32], ptr %fds, i64 0, i64 1
  %7 = load i32, ptr %arrayidx15, align 4
  %call16 = call i32 @close(i32 noundef %7)
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %if.then9
  %arrayidx17 = getelementptr [2 x i32], ptr %fds, i64 0, i64 1
  %8 = load i32, ptr %arrayidx17, align 4
  %call18 = call i32 @_Py_set_inheritable(i32 noundef %8, i32 noundef 0, ptr noundef null)
  %cmp19 = icmp slt i32 %call18, 0
  br i1 %cmp19, label %if.then20, label %if.end25

if.then20:                                        ; preds = %if.end
  %arrayidx21 = getelementptr [2 x i32], ptr %fds, i64 0, i64 0
  %9 = load i32, ptr %arrayidx21, align 4
  %call22 = call i32 @close(i32 noundef %9)
  %arrayidx23 = getelementptr [2 x i32], ptr %fds, i64 0, i64 1
  %10 = load i32, ptr %arrayidx23, align 4
  %call24 = call i32 @close(i32 noundef %10)
  store ptr null, ptr %retval, align 8
  br label %return

if.end25:                                         ; preds = %if.end
  br label %if.end26

if.end26:                                         ; preds = %if.end25, %if.then
  br label %if.end27

if.end27:                                         ; preds = %if.end26, %land.lhs.true, %entry
  %11 = load i32, ptr %res, align 4
  %cmp28 = icmp ne i32 %11, 0
  br i1 %cmp28, label %if.then29, label %if.end31

if.then29:                                        ; preds = %if.end27
  %12 = load ptr, ptr @PyExc_OSError, align 8
  %call30 = call ptr @PyErr_SetFromErrno(ptr noundef %12)
  store ptr %call30, ptr %retval, align 8
  br label %return

if.end31:                                         ; preds = %if.end27
  %arrayidx32 = getelementptr [2 x i32], ptr %fds, i64 0, i64 0
  %13 = load i32, ptr %arrayidx32, align 4
  %arrayidx33 = getelementptr [2 x i32], ptr %fds, i64 0, i64 1
  %14 = load i32, ptr %arrayidx33, align 4
  %call34 = call ptr (ptr, ...) @Py_BuildValue(ptr noundef @.str.313, i32 noundef %13, i32 noundef %14)
  store ptr %call34, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end31, %if.then29, %if.then20, %if.then12
  %15 = load ptr, ptr %retval, align 8
  ret ptr %15
}

; Function Attrs: nounwind
declare i32 @pipe2(ptr noundef, i32 noundef) #4

; Function Attrs: nounwind
declare i32 @pipe(ptr noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_pipe2_impl(ptr noundef %module, i32 noundef %flags) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %fds = alloca [2 x i32], align 4
  %res = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  %arraydecay = getelementptr inbounds [2 x i32], ptr %fds, i64 0, i64 0
  %0 = load i32, ptr %flags.addr, align 4
  %call = call i32 @pipe2(ptr noundef %arraydecay, i32 noundef %0) #10
  store i32 %call, ptr %res, align 4
  %1 = load i32, ptr %res, align 4
  %cmp = icmp ne i32 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call ptr @posix_error()
  store ptr %call1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %arrayidx = getelementptr [2 x i32], ptr %fds, i64 0, i64 0
  %2 = load i32, ptr %arrayidx, align 4
  %arrayidx2 = getelementptr [2 x i32], ptr %fds, i64 0, i64 1
  %3 = load i32, ptr %arrayidx2, align 4
  %call3 = call ptr (ptr, ...) @Py_BuildValue(ptr noundef @.str.313, i32 noundef %2, i32 noundef %3)
  store ptr %call3, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load ptr, ptr %retval, align 8
  ret ptr %4
}

; Function Attrs: nounwind uwtable
define internal ptr @os_mkfifo_impl(ptr noundef %module, ptr noundef %path, i32 noundef %mode, i32 noundef %dir_fd) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %path.addr = alloca ptr, align 8
  %mode.addr = alloca i32, align 4
  %dir_fd.addr = alloca i32, align 4
  %result = alloca i32, align 4
  %async_err = alloca i32, align 4
  %mkfifoat_unavailable = alloca i32, align 4
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %path, ptr %path.addr, align 8
  store i32 %mode, ptr %mode.addr, align 4
  store i32 %dir_fd, ptr %dir_fd.addr, align 4
  store i32 0, ptr %async_err, align 4
  store i32 0, ptr %mkfifoat_unavailable, align 4
  br label %do.body

do.body:                                          ; preds = %land.end, %entry
  %call = call ptr @PyEval_SaveThread()
  store ptr %call, ptr %_save, align 8
  %0 = load i32, ptr %dir_fd.addr, align 4
  %cmp = icmp ne i32 %0, -100
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  %1 = load i32, ptr %dir_fd.addr, align 4
  %2 = load ptr, ptr %path.addr, align 8
  %narrow = getelementptr inbounds %struct.path_t, ptr %2, i32 0, i32 5
  %3 = load ptr, ptr %narrow, align 8
  %4 = load i32, ptr %mode.addr, align 4
  %call1 = call i32 @mkfifoat(i32 noundef %1, ptr noundef %3, i32 noundef %4) #10
  store i32 %call1, ptr %result, align 4
  br label %if.end

if.else:                                          ; preds = %do.body
  %5 = load ptr, ptr %path.addr, align 8
  %narrow2 = getelementptr inbounds %struct.path_t, ptr %5, i32 0, i32 5
  %6 = load ptr, ptr %narrow2, align 8
  %7 = load i32, ptr %mode.addr, align 4
  %call3 = call i32 @mkfifo(ptr noundef %6, i32 noundef %7) #10
  store i32 %call3, ptr %result, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %8 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %8)
  br label %do.cond

do.cond:                                          ; preds = %if.end
  %9 = load i32, ptr %result, align 4
  %cmp4 = icmp ne i32 %9, 0
  br i1 %cmp4, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %do.cond
  %call5 = call ptr @__errno_location() #12
  %10 = load i32, ptr %call5, align 4
  %cmp6 = icmp eq i32 %10, 4
  br i1 %cmp6, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %call7 = call i32 @PyErr_CheckSignals()
  store i32 %call7, ptr %async_err, align 4
  %tobool = icmp ne i32 %call7, 0
  %lnot = xor i1 %tobool, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %do.cond
  %11 = phi i1 [ false, %land.lhs.true ], [ false, %do.cond ], [ %lnot, %land.rhs ]
  br i1 %11, label %do.body, label %do.end, !llvm.loop !42

do.end:                                           ; preds = %land.end
  %12 = load i32, ptr %mkfifoat_unavailable, align 4
  %tobool8 = icmp ne i32 %12, 0
  br i1 %tobool8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %do.end
  call void @argument_unavailable_error(ptr noundef null, ptr noundef @.str.184)
  store ptr null, ptr %retval, align 8
  br label %return

if.end10:                                         ; preds = %do.end
  %13 = load i32, ptr %result, align 4
  %cmp11 = icmp ne i32 %13, 0
  br i1 %cmp11, label %if.then12, label %if.end15

if.then12:                                        ; preds = %if.end10
  %14 = load i32, ptr %async_err, align 4
  %tobool13 = icmp ne i32 %14, 0
  br i1 %tobool13, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then12
  %call14 = call ptr @posix_error()
  br label %cond.end

cond.false:                                       ; preds = %if.then12
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call14, %cond.true ], [ null, %cond.false ]
  store ptr %cond, ptr %retval, align 8
  br label %return

if.end15:                                         ; preds = %if.end10
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end15, %cond.end, %if.then9
  %15 = load ptr, ptr %retval, align 8
  ret ptr %15
}

; Function Attrs: nounwind
declare i32 @mkfifoat(i32 noundef, ptr noundef, i32 noundef) #4

; Function Attrs: nounwind
declare i32 @mkfifo(ptr noundef, i32 noundef) #4

; Function Attrs: nounwind uwtable
define internal i32 @_Py_Dev_Converter(ptr noundef %obj, ptr noundef %p) #0 {
entry:
  %retval = alloca i32, align 4
  %obj.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  store ptr %obj, ptr %obj.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %obj.addr, align 8
  %call = call i64 @PyLong_AsUnsignedLongLong(ptr noundef %0)
  %1 = load ptr, ptr %p.addr, align 8
  store i64 %call, ptr %1, align 8
  %call1 = call ptr @PyErr_Occurred()
  %tobool = icmp ne ptr %call1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load i32, ptr %retval, align 4
  ret i32 %2
}

; Function Attrs: nounwind uwtable
define internal ptr @os_mknod_impl(ptr noundef %module, ptr noundef %path, i32 noundef %mode, i64 noundef %device, i32 noundef %dir_fd) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %path.addr = alloca ptr, align 8
  %mode.addr = alloca i32, align 4
  %device.addr = alloca i64, align 8
  %dir_fd.addr = alloca i32, align 4
  %result = alloca i32, align 4
  %async_err = alloca i32, align 4
  %mknodat_unavailable = alloca i32, align 4
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %path, ptr %path.addr, align 8
  store i32 %mode, ptr %mode.addr, align 4
  store i64 %device, ptr %device.addr, align 8
  store i32 %dir_fd, ptr %dir_fd.addr, align 4
  store i32 0, ptr %async_err, align 4
  store i32 0, ptr %mknodat_unavailable, align 4
  br label %do.body

do.body:                                          ; preds = %land.end, %entry
  %call = call ptr @PyEval_SaveThread()
  store ptr %call, ptr %_save, align 8
  %0 = load i32, ptr %dir_fd.addr, align 4
  %cmp = icmp ne i32 %0, -100
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  %1 = load i32, ptr %dir_fd.addr, align 4
  %2 = load ptr, ptr %path.addr, align 8
  %narrow = getelementptr inbounds %struct.path_t, ptr %2, i32 0, i32 5
  %3 = load ptr, ptr %narrow, align 8
  %4 = load i32, ptr %mode.addr, align 4
  %5 = load i64, ptr %device.addr, align 8
  %call1 = call i32 @mknodat(i32 noundef %1, ptr noundef %3, i32 noundef %4, i64 noundef %5) #10
  store i32 %call1, ptr %result, align 4
  br label %if.end

if.else:                                          ; preds = %do.body
  %6 = load ptr, ptr %path.addr, align 8
  %narrow2 = getelementptr inbounds %struct.path_t, ptr %6, i32 0, i32 5
  %7 = load ptr, ptr %narrow2, align 8
  %8 = load i32, ptr %mode.addr, align 4
  %9 = load i64, ptr %device.addr, align 8
  %call3 = call i32 @mknod(ptr noundef %7, i32 noundef %8, i64 noundef %9) #10
  store i32 %call3, ptr %result, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %10 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %10)
  br label %do.cond

do.cond:                                          ; preds = %if.end
  %11 = load i32, ptr %result, align 4
  %cmp4 = icmp ne i32 %11, 0
  br i1 %cmp4, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %do.cond
  %call5 = call ptr @__errno_location() #12
  %12 = load i32, ptr %call5, align 4
  %cmp6 = icmp eq i32 %12, 4
  br i1 %cmp6, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %call7 = call i32 @PyErr_CheckSignals()
  store i32 %call7, ptr %async_err, align 4
  %tobool = icmp ne i32 %call7, 0
  %lnot = xor i1 %tobool, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %do.cond
  %13 = phi i1 [ false, %land.lhs.true ], [ false, %do.cond ], [ %lnot, %land.rhs ]
  br i1 %13, label %do.body, label %do.end, !llvm.loop !43

do.end:                                           ; preds = %land.end
  %14 = load i32, ptr %mknodat_unavailable, align 4
  %tobool8 = icmp ne i32 %14, 0
  br i1 %tobool8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %do.end
  call void @argument_unavailable_error(ptr noundef null, ptr noundef @.str.184)
  store ptr null, ptr %retval, align 8
  br label %return

if.end10:                                         ; preds = %do.end
  %15 = load i32, ptr %result, align 4
  %cmp11 = icmp ne i32 %15, 0
  br i1 %cmp11, label %if.then12, label %if.end15

if.then12:                                        ; preds = %if.end10
  %16 = load i32, ptr %async_err, align 4
  %tobool13 = icmp ne i32 %16, 0
  br i1 %tobool13, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then12
  %call14 = call ptr @posix_error()
  br label %cond.end

cond.false:                                       ; preds = %if.then12
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call14, %cond.true ], [ null, %cond.false ]
  store ptr %cond, ptr %retval, align 8
  br label %return

if.end15:                                         ; preds = %if.end10
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end15, %cond.end, %if.then9
  %17 = load ptr, ptr %retval, align 8
  ret ptr %17
}

declare i64 @PyLong_AsUnsignedLongLong(ptr noundef) #1

; Function Attrs: nounwind
declare i32 @mknodat(i32 noundef, ptr noundef, i32 noundef, i64 noundef) #4

; Function Attrs: nounwind
declare i32 @mknod(ptr noundef, i32 noundef, i64 noundef) #4

; Function Attrs: nounwind uwtable
define internal i32 @os_major_impl(ptr noundef %module, i64 noundef %device) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %device.addr = alloca i64, align 8
  store ptr %module, ptr %module.addr, align 8
  store i64 %device, ptr %device.addr, align 8
  %0 = load i64, ptr %device.addr, align 8
  %call = call i32 @gnu_dev_major(i64 noundef %0) #12
  ret i32 %call
}

; Function Attrs: nounwind willreturn memory(none)
declare i32 @gnu_dev_major(i64 noundef) #5

; Function Attrs: nounwind uwtable
define internal i32 @os_minor_impl(ptr noundef %module, i64 noundef %device) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %device.addr = alloca i64, align 8
  store ptr %module, ptr %module.addr, align 8
  store i64 %device, ptr %device.addr, align 8
  %0 = load i64, ptr %device.addr, align 8
  %call = call i32 @gnu_dev_minor(i64 noundef %0) #12
  ret i32 %call
}

; Function Attrs: nounwind willreturn memory(none)
declare i32 @gnu_dev_minor(i64 noundef) #5

; Function Attrs: nounwind uwtable
define internal i64 @os_makedev_impl(ptr noundef %module, i32 noundef %major, i32 noundef %minor) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %major.addr = alloca i32, align 4
  %minor.addr = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %major, ptr %major.addr, align 4
  store i32 %minor, ptr %minor.addr, align 4
  %0 = load i32, ptr %major.addr, align 4
  %1 = load i32, ptr %minor.addr, align 4
  %call = call i64 @gnu_dev_makedev(i32 noundef %0, i32 noundef %1) #12
  ret i64 %call
}

; Function Attrs: nounwind willreturn memory(none)
declare i64 @gnu_dev_makedev(i32 noundef, i32 noundef) #5

; Function Attrs: nounwind uwtable
define internal ptr @os_ftruncate_impl(ptr noundef %module, i32 noundef %fd, i64 noundef %length) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %length.addr = alloca i64, align 8
  %result = alloca i32, align 4
  %async_err = alloca i32, align 4
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i64 %length, ptr %length.addr, align 8
  store i32 0, ptr %async_err, align 4
  %0 = load i32, ptr %fd.addr, align 4
  %1 = load i64, ptr %length.addr, align 8
  %call = call i32 (ptr, ptr, ...) @PySys_Audit(ptr noundef @.str.356, ptr noundef @.str.323, i32 noundef %0, i64 noundef %1)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %land.end, %if.end
  %call1 = call ptr @PyEval_SaveThread()
  store ptr %call1, ptr %_save, align 8
  %2 = load i32, ptr %fd.addr, align 4
  %3 = load i64, ptr %length.addr, align 8
  %call2 = call i32 @ftruncate64(i32 noundef %2, i64 noundef %3) #10
  store i32 %call2, ptr %result, align 4
  %4 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %4)
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %5 = load i32, ptr %result, align 4
  %cmp3 = icmp ne i32 %5, 0
  br i1 %cmp3, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %do.cond
  %call4 = call ptr @__errno_location() #12
  %6 = load i32, ptr %call4, align 4
  %cmp5 = icmp eq i32 %6, 4
  br i1 %cmp5, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %call6 = call i32 @PyErr_CheckSignals()
  store i32 %call6, ptr %async_err, align 4
  %tobool = icmp ne i32 %call6, 0
  %lnot = xor i1 %tobool, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %do.cond
  %7 = phi i1 [ false, %land.lhs.true ], [ false, %do.cond ], [ %lnot, %land.rhs ]
  br i1 %7, label %do.body, label %do.end, !llvm.loop !44

do.end:                                           ; preds = %land.end
  %8 = load i32, ptr %result, align 4
  %cmp7 = icmp ne i32 %8, 0
  br i1 %cmp7, label %if.then8, label %if.end11

if.then8:                                         ; preds = %do.end
  %9 = load i32, ptr %async_err, align 4
  %tobool9 = icmp ne i32 %9, 0
  br i1 %tobool9, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then8
  %call10 = call ptr @posix_error()
  br label %cond.end

cond.false:                                       ; preds = %if.then8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call10, %cond.true ], [ null, %cond.false ]
  store ptr %cond, ptr %retval, align 8
  br label %return

if.end11:                                         ; preds = %do.end
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end11, %cond.end, %if.then
  %10 = load ptr, ptr %retval, align 8
  ret ptr %10
}

; Function Attrs: nounwind
declare i32 @ftruncate64(i32 noundef, i64 noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_truncate_impl(ptr noundef %module, ptr noundef %path, i64 noundef %length) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %path.addr = alloca ptr, align 8
  %length.addr = alloca i64, align 8
  %result = alloca i32, align 4
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %path, ptr %path.addr, align 8
  store i64 %length, ptr %length.addr, align 8
  %0 = load ptr, ptr %path.addr, align 8
  %fd = getelementptr inbounds %struct.path_t, ptr %0, i32 0, i32 6
  %1 = load i32, ptr %fd, align 8
  %cmp = icmp ne i32 %1, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %module.addr, align 8
  %3 = load ptr, ptr %path.addr, align 8
  %fd1 = getelementptr inbounds %struct.path_t, ptr %3, i32 0, i32 6
  %4 = load i32, ptr %fd1, align 8
  %5 = load i64, ptr %length.addr, align 8
  %call = call ptr @os_ftruncate_impl(ptr noundef %2, i32 noundef %4, i64 noundef %5)
  store ptr %call, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %6 = load ptr, ptr %path.addr, align 8
  %object = getelementptr inbounds %struct.path_t, ptr %6, i32 0, i32 8
  %7 = load ptr, ptr %object, align 8
  %8 = load i64, ptr %length.addr, align 8
  %call2 = call i32 (ptr, ptr, ...) @PySys_Audit(ptr noundef @.str.356, ptr noundef @.str.358, ptr noundef %7, i64 noundef %8)
  %cmp3 = icmp slt i32 %call2, 0
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end5:                                          ; preds = %if.end
  %call6 = call ptr @PyEval_SaveThread()
  store ptr %call6, ptr %_save, align 8
  %9 = load ptr, ptr %path.addr, align 8
  %narrow = getelementptr inbounds %struct.path_t, ptr %9, i32 0, i32 5
  %10 = load ptr, ptr %narrow, align 8
  %11 = load i64, ptr %length.addr, align 8
  %call7 = call i32 @truncate64(ptr noundef %10, i64 noundef %11) #10
  store i32 %call7, ptr %result, align 4
  %12 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %12)
  %13 = load i32, ptr %result, align 4
  %cmp8 = icmp slt i32 %13, 0
  br i1 %cmp8, label %if.then9, label %if.end11

if.then9:                                         ; preds = %if.end5
  %14 = load ptr, ptr %path.addr, align 8
  %call10 = call ptr @posix_path_error(ptr noundef %14)
  store ptr %call10, ptr %retval, align 8
  br label %return

if.end11:                                         ; preds = %if.end5
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end11, %if.then9, %if.then4, %if.then
  %15 = load ptr, ptr %retval, align 8
  ret ptr %15
}

; Function Attrs: nounwind
declare i32 @truncate64(ptr noundef, i64 noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_posix_fallocate_impl(ptr noundef %module, i32 noundef %fd, i64 noundef %offset, i64 noundef %length) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %offset.addr = alloca i64, align 8
  %length.addr = alloca i64, align 8
  %result = alloca i32, align 4
  %async_err = alloca i32, align 4
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i64 %offset, ptr %offset.addr, align 8
  store i64 %length, ptr %length.addr, align 8
  store i32 0, ptr %async_err, align 4
  br label %do.body

do.body:                                          ; preds = %land.end, %entry
  %call = call ptr @PyEval_SaveThread()
  store ptr %call, ptr %_save, align 8
  %0 = load i32, ptr %fd.addr, align 4
  %1 = load i64, ptr %offset.addr, align 8
  %2 = load i64, ptr %length.addr, align 8
  %call1 = call i32 @posix_fallocate64(i32 noundef %0, i64 noundef %1, i64 noundef %2)
  store i32 %call1, ptr %result, align 4
  %3 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %3)
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %4 = load i32, ptr %result, align 4
  %cmp = icmp eq i32 %4, 4
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %do.cond
  %call2 = call i32 @PyErr_CheckSignals()
  store i32 %call2, ptr %async_err, align 4
  %tobool = icmp ne i32 %call2, 0
  %lnot = xor i1 %tobool, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %do.cond
  %5 = phi i1 [ false, %do.cond ], [ %lnot, %land.rhs ]
  br i1 %5, label %do.body, label %do.end, !llvm.loop !45

do.end:                                           ; preds = %land.end
  %6 = load i32, ptr %result, align 4
  %cmp3 = icmp eq i32 %6, 0
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %do.end
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %do.end
  %7 = load i32, ptr %async_err, align 4
  %tobool4 = icmp ne i32 %7, 0
  br i1 %tobool4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end6:                                          ; preds = %if.end
  %8 = load i32, ptr %result, align 4
  %call7 = call ptr @__errno_location() #12
  store i32 %8, ptr %call7, align 4
  %call8 = call ptr @posix_error()
  store ptr %call8, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end6, %if.then5, %if.then
  %9 = load ptr, ptr %retval, align 8
  ret ptr %9
}

declare i32 @posix_fallocate64(i32 noundef, i64 noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @os_posix_fadvise_impl(ptr noundef %module, i32 noundef %fd, i64 noundef %offset, i64 noundef %length, i32 noundef %advice) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %offset.addr = alloca i64, align 8
  %length.addr = alloca i64, align 8
  %advice.addr = alloca i32, align 4
  %result = alloca i32, align 4
  %async_err = alloca i32, align 4
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i64 %offset, ptr %offset.addr, align 8
  store i64 %length, ptr %length.addr, align 8
  store i32 %advice, ptr %advice.addr, align 4
  store i32 0, ptr %async_err, align 4
  br label %do.body

do.body:                                          ; preds = %land.end, %entry
  %call = call ptr @PyEval_SaveThread()
  store ptr %call, ptr %_save, align 8
  %0 = load i32, ptr %fd.addr, align 4
  %1 = load i64, ptr %offset.addr, align 8
  %2 = load i64, ptr %length.addr, align 8
  %3 = load i32, ptr %advice.addr, align 4
  %call1 = call i32 @posix_fadvise64(i32 noundef %0, i64 noundef %1, i64 noundef %2, i32 noundef %3) #10
  store i32 %call1, ptr %result, align 4
  %4 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %4)
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %5 = load i32, ptr %result, align 4
  %cmp = icmp eq i32 %5, 4
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %do.cond
  %call2 = call i32 @PyErr_CheckSignals()
  store i32 %call2, ptr %async_err, align 4
  %tobool = icmp ne i32 %call2, 0
  %lnot = xor i1 %tobool, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %do.cond
  %6 = phi i1 [ false, %do.cond ], [ %lnot, %land.rhs ]
  br i1 %6, label %do.body, label %do.end, !llvm.loop !46

do.end:                                           ; preds = %land.end
  %7 = load i32, ptr %result, align 4
  %cmp3 = icmp eq i32 %7, 0
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %do.end
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %do.end
  %8 = load i32, ptr %async_err, align 4
  %tobool4 = icmp ne i32 %8, 0
  br i1 %tobool4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end6:                                          ; preds = %if.end
  %9 = load i32, ptr %result, align 4
  %call7 = call ptr @__errno_location() #12
  store i32 %9, ptr %call7, align 4
  %call8 = call ptr @posix_error()
  store ptr %call8, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end6, %if.then5, %if.then
  %10 = load ptr, ptr %retval, align 8
  ret ptr %10
}

; Function Attrs: nounwind
declare i32 @posix_fadvise64(i32 noundef, i64 noundef, i64 noundef, i32 noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_putenv_impl(ptr noundef %module, ptr noundef %name, ptr noundef %value) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %name.addr = alloca ptr, align 8
  %value.addr = alloca ptr, align 8
  %name_string = alloca ptr, align 8
  %value_string = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %name, ptr %name.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  %0 = load ptr, ptr %name.addr, align 8
  %call = call ptr @PyBytes_AS_STRING(ptr noundef %0)
  store ptr %call, ptr %name_string, align 8
  %1 = load ptr, ptr %value.addr, align 8
  %call1 = call ptr @PyBytes_AS_STRING(ptr noundef %1)
  store ptr %call1, ptr %value_string, align 8
  %2 = load ptr, ptr %name_string, align 8
  %call2 = call ptr @strchr(ptr noundef %2, i32 noundef 61) #13
  %cmp = icmp ne ptr %call2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr @PyExc_ValueError, align 8
  call void @PyErr_SetString(ptr noundef %3, ptr noundef @.str.242)
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %name.addr, align 8
  %5 = load ptr, ptr %value.addr, align 8
  %call3 = call i32 (ptr, ptr, ...) @PySys_Audit(ptr noundef @.str.359, ptr noundef @.str.360, ptr noundef %4, ptr noundef %5)
  %cmp4 = icmp slt i32 %call3, 0
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end6:                                          ; preds = %if.end
  %6 = load ptr, ptr %name_string, align 8
  %7 = load ptr, ptr %value_string, align 8
  %call7 = call i32 @setenv(ptr noundef %6, ptr noundef %7, i32 noundef 1) #10
  %tobool = icmp ne i32 %call7, 0
  br i1 %tobool, label %if.then8, label %if.end10

if.then8:                                         ; preds = %if.end6
  %call9 = call ptr @posix_error()
  store ptr %call9, ptr %retval, align 8
  br label %return

if.end10:                                         ; preds = %if.end6
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end10, %if.then8, %if.then5, %if.then
  %8 = load ptr, ptr %retval, align 8
  ret ptr %8
}

; Function Attrs: nounwind
declare i32 @setenv(ptr noundef, ptr noundef, i32 noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_unsetenv_impl(ptr noundef %module, ptr noundef %name) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %name.addr = alloca ptr, align 8
  %err = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %name, ptr %name.addr, align 8
  %0 = load ptr, ptr %name.addr, align 8
  %call = call i32 (ptr, ptr, ...) @PySys_Audit(ptr noundef @.str.361, ptr noundef @.str.204, ptr noundef %0)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %name.addr, align 8
  %call1 = call ptr @PyBytes_AS_STRING(ptr noundef %1)
  %call2 = call i32 @unsetenv(ptr noundef %call1) #10
  store i32 %call2, ptr %err, align 4
  %2 = load i32, ptr %err, align 4
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %call4 = call ptr @posix_error()
  store ptr %call4, ptr %retval, align 8
  br label %return

if.end5:                                          ; preds = %if.end
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end5, %if.then3, %if.then
  %3 = load ptr, ptr %retval, align 8
  ret ptr %3
}

; Function Attrs: nounwind
declare i32 @unsetenv(ptr noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_strerror_impl(ptr noundef %module, i32 noundef %code) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %code.addr = alloca i32, align 4
  %message = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %code, ptr %code.addr, align 4
  %0 = load i32, ptr %code.addr, align 4
  %call = call ptr @strerror(i32 noundef %0) #10
  store ptr %call, ptr %message, align 8
  %1 = load ptr, ptr %message, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr @PyExc_ValueError, align 8
  call void @PyErr_SetString(ptr noundef %2, ptr noundef @.str.362)
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %message, align 8
  %call1 = call ptr @PyUnicode_DecodeLocale(ptr noundef %3, ptr noundef @.str.363)
  store ptr %call1, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load ptr, ptr %retval, align 8
  ret ptr %4
}

; Function Attrs: nounwind
declare ptr @strerror(i32 noundef) #4

declare ptr @PyUnicode_DecodeLocale(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @os_fchdir_impl(ptr noundef %module, i32 noundef %fd) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  %0 = load i32, ptr %fd.addr, align 4
  %call = call i32 (ptr, ptr, ...) @PySys_Audit(ptr noundef @.str.203, ptr noundef @.str.364, i32 noundef %0)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, ptr %fd.addr, align 4
  %call1 = call ptr @posix_fildes_fd(i32 noundef %1, ptr noundef @fchdir)
  store ptr %call1, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load ptr, ptr %retval, align 8
  ret ptr %2
}

; Function Attrs: nounwind uwtable
define internal ptr @posix_fildes_fd(i32 noundef %fd, ptr noundef %func) #0 {
entry:
  %retval = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %func.addr = alloca ptr, align 8
  %res = alloca i32, align 4
  %async_err = alloca i32, align 4
  %_save = alloca ptr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store ptr %func, ptr %func.addr, align 8
  store i32 0, ptr %async_err, align 4
  br label %do.body

do.body:                                          ; preds = %land.end, %entry
  %call = call ptr @PyEval_SaveThread()
  store ptr %call, ptr %_save, align 8
  %0 = load ptr, ptr %func.addr, align 8
  %1 = load i32, ptr %fd.addr, align 4
  %call1 = call i32 %0(i32 noundef %1)
  store i32 %call1, ptr %res, align 4
  %2 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %2)
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %3 = load i32, ptr %res, align 4
  %cmp = icmp ne i32 %3, 0
  br i1 %cmp, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %do.cond
  %call2 = call ptr @__errno_location() #12
  %4 = load i32, ptr %call2, align 4
  %cmp3 = icmp eq i32 %4, 4
  br i1 %cmp3, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %call4 = call i32 @PyErr_CheckSignals()
  store i32 %call4, ptr %async_err, align 4
  %tobool = icmp ne i32 %call4, 0
  %lnot = xor i1 %tobool, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %do.cond
  %5 = phi i1 [ false, %land.lhs.true ], [ false, %do.cond ], [ %lnot, %land.rhs ]
  br i1 %5, label %do.body, label %do.end, !llvm.loop !47

do.end:                                           ; preds = %land.end
  %6 = load i32, ptr %res, align 4
  %cmp5 = icmp ne i32 %6, 0
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %do.end
  %7 = load i32, ptr %async_err, align 4
  %tobool6 = icmp ne i32 %7, 0
  br i1 %tobool6, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then
  %call7 = call ptr @posix_error()
  br label %cond.end

cond.false:                                       ; preds = %if.then
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call7, %cond.true ], [ null, %cond.false ]
  store ptr %cond, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %do.end
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %cond.end
  %8 = load ptr, ptr %retval, align 8
  ret ptr %8
}

; Function Attrs: nounwind uwtable
define internal ptr @os_fsync_impl(ptr noundef %module, i32 noundef %fd) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  %0 = load i32, ptr %fd.addr, align 4
  %call = call ptr @posix_fildes_fd(i32 noundef %0, ptr noundef @fsync)
  ret ptr %call
}

declare i32 @fsync(i32 noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @os_sync_impl(ptr noundef %module) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  %call = call ptr @PyEval_SaveThread()
  store ptr %call, ptr %_save, align 8
  call void @sync() #10
  %0 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %0)
  ret ptr @_Py_NoneStruct
}

; Function Attrs: nounwind
declare void @sync() #4

; Function Attrs: nounwind uwtable
define internal ptr @os_fdatasync_impl(ptr noundef %module, i32 noundef %fd) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  %0 = load i32, ptr %fd.addr, align 4
  %call = call ptr @posix_fildes_fd(i32 noundef %0, ptr noundef @fdatasync)
  ret ptr %call
}

declare i32 @fdatasync(i32 noundef) #1

; Function Attrs: nounwind uwtable
define internal i32 @os_WCOREDUMP_impl(ptr noundef %module, i32 noundef %status) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %status.addr = alloca i32, align 4
  %wait_status = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %status, ptr %status.addr, align 4
  %0 = load i32, ptr %status.addr, align 4
  store i32 %0, ptr %wait_status, align 4
  %1 = load i32, ptr %wait_status, align 4
  %and = and i32 %1, 128
  ret i32 %and
}

; Function Attrs: nounwind uwtable
define internal i32 @os_WIFCONTINUED_impl(ptr noundef %module, i32 noundef %status) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %status.addr = alloca i32, align 4
  %wait_status = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %status, ptr %status.addr, align 4
  %0 = load i32, ptr %status.addr, align 4
  store i32 %0, ptr %wait_status, align 4
  %1 = load i32, ptr %wait_status, align 4
  %cmp = icmp eq i32 %1, 65535
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define internal i32 @os_WIFSTOPPED_impl(ptr noundef %module, i32 noundef %status) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %status.addr = alloca i32, align 4
  %wait_status = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %status, ptr %status.addr, align 4
  %0 = load i32, ptr %status.addr, align 4
  store i32 %0, ptr %wait_status, align 4
  %1 = load i32, ptr %wait_status, align 4
  %and = and i32 %1, 255
  %cmp = icmp eq i32 %and, 127
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define internal i32 @os_WIFSIGNALED_impl(ptr noundef %module, i32 noundef %status) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %status.addr = alloca i32, align 4
  %wait_status = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %status, ptr %status.addr, align 4
  %0 = load i32, ptr %status.addr, align 4
  store i32 %0, ptr %wait_status, align 4
  %1 = load i32, ptr %wait_status, align 4
  %and = and i32 %1, 127
  %add = add i32 %and, 1
  %conv = trunc i32 %add to i8
  %conv1 = sext i8 %conv to i32
  %shr = ashr i32 %conv1, 1
  %cmp = icmp sgt i32 %shr, 0
  %conv2 = zext i1 %cmp to i32
  ret i32 %conv2
}

; Function Attrs: nounwind uwtable
define internal i32 @os_WIFEXITED_impl(ptr noundef %module, i32 noundef %status) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %status.addr = alloca i32, align 4
  %wait_status = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %status, ptr %status.addr, align 4
  %0 = load i32, ptr %status.addr, align 4
  store i32 %0, ptr %wait_status, align 4
  %1 = load i32, ptr %wait_status, align 4
  %and = and i32 %1, 127
  %cmp = icmp eq i32 %and, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define internal i32 @os_WEXITSTATUS_impl(ptr noundef %module, i32 noundef %status) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %status.addr = alloca i32, align 4
  %wait_status = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %status, ptr %status.addr, align 4
  %0 = load i32, ptr %status.addr, align 4
  store i32 %0, ptr %wait_status, align 4
  %1 = load i32, ptr %wait_status, align 4
  %and = and i32 %1, 65280
  %shr = ashr i32 %and, 8
  ret i32 %shr
}

; Function Attrs: nounwind uwtable
define internal i32 @os_WTERMSIG_impl(ptr noundef %module, i32 noundef %status) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %status.addr = alloca i32, align 4
  %wait_status = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %status, ptr %status.addr, align 4
  %0 = load i32, ptr %status.addr, align 4
  store i32 %0, ptr %wait_status, align 4
  %1 = load i32, ptr %wait_status, align 4
  %and = and i32 %1, 127
  ret i32 %and
}

; Function Attrs: nounwind uwtable
define internal i32 @os_WSTOPSIG_impl(ptr noundef %module, i32 noundef %status) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %status.addr = alloca i32, align 4
  %wait_status = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %status, ptr %status.addr, align 4
  %0 = load i32, ptr %status.addr, align 4
  store i32 %0, ptr %wait_status, align 4
  %1 = load i32, ptr %wait_status, align 4
  %and = and i32 %1, 65280
  %shr = ashr i32 %and, 8
  ret i32 %shr
}

; Function Attrs: nounwind uwtable
define internal ptr @os_fstatvfs_impl(ptr noundef %module, i32 noundef %fd) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %result = alloca i32, align 4
  %async_err = alloca i32, align 4
  %st = alloca %struct.statvfs, align 8
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i32 0, ptr %async_err, align 4
  br label %do.body

do.body:                                          ; preds = %land.end, %entry
  %call = call ptr @PyEval_SaveThread()
  store ptr %call, ptr %_save, align 8
  %0 = load i32, ptr %fd.addr, align 4
  %call1 = call i32 @fstatvfs64(i32 noundef %0, ptr noundef %st) #10
  store i32 %call1, ptr %result, align 4
  %1 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %1)
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %2 = load i32, ptr %result, align 4
  %cmp = icmp ne i32 %2, 0
  br i1 %cmp, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %do.cond
  %call2 = call ptr @__errno_location() #12
  %3 = load i32, ptr %call2, align 4
  %cmp3 = icmp eq i32 %3, 4
  br i1 %cmp3, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %call4 = call i32 @PyErr_CheckSignals()
  store i32 %call4, ptr %async_err, align 4
  %tobool = icmp ne i32 %call4, 0
  %lnot = xor i1 %tobool, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %do.cond
  %4 = phi i1 [ false, %land.lhs.true ], [ false, %do.cond ], [ %lnot, %land.rhs ]
  br i1 %4, label %do.body, label %do.end, !llvm.loop !48

do.end:                                           ; preds = %land.end
  %5 = load i32, ptr %result, align 4
  %cmp5 = icmp ne i32 %5, 0
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %do.end
  %6 = load i32, ptr %async_err, align 4
  %tobool6 = icmp ne i32 %6, 0
  br i1 %tobool6, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then
  %call7 = call ptr @posix_error()
  br label %cond.end

cond.false:                                       ; preds = %if.then
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call7, %cond.true ], [ null, %cond.false ]
  store ptr %cond, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %do.end
  %7 = load ptr, ptr %module.addr, align 8
  %call8 = call ptr @_pystatvfs_fromstructstatvfs(ptr noundef %7, ptr noundef byval(%struct.statvfs) align 8 %st)
  store ptr %call8, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %cond.end
  %8 = load ptr, ptr %retval, align 8
  ret ptr %8
}

; Function Attrs: nounwind
declare i32 @fstatvfs64(i32 noundef, ptr noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @_pystatvfs_fromstructstatvfs(ptr noundef %module, ptr noundef byval(%struct.statvfs) align 8 %st) #0 {
entry:
  %op.addr.i17 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %StatVFSResultType = alloca ptr, align 8
  %v = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %call = call ptr @get_posix_state(ptr noundef %0)
  %StatVFSResultType1 = getelementptr inbounds %struct._posixstate, ptr %call, i32 0, i32 6
  %1 = load ptr, ptr %StatVFSResultType1, align 8
  store ptr %1, ptr %StatVFSResultType, align 8
  %2 = load ptr, ptr %StatVFSResultType, align 8
  %call2 = call ptr @PyStructSequence_New(ptr noundef %2)
  store ptr %call2, ptr %v, align 8
  %3 = load ptr, ptr %v, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %v, align 8
  %f_bsize = getelementptr inbounds %struct.statvfs, ptr %st, i32 0, i32 0
  %5 = load i64, ptr %f_bsize, align 8
  %call3 = call ptr @PyLong_FromLong(i64 noundef %5)
  call void @PyStructSequence_SetItem(ptr noundef %4, i64 noundef 0, ptr noundef %call3)
  %6 = load ptr, ptr %v, align 8
  %f_frsize = getelementptr inbounds %struct.statvfs, ptr %st, i32 0, i32 1
  %7 = load i64, ptr %f_frsize, align 8
  %call4 = call ptr @PyLong_FromLong(i64 noundef %7)
  call void @PyStructSequence_SetItem(ptr noundef %6, i64 noundef 1, ptr noundef %call4)
  %8 = load ptr, ptr %v, align 8
  %f_blocks = getelementptr inbounds %struct.statvfs, ptr %st, i32 0, i32 2
  %9 = load i64, ptr %f_blocks, align 8
  %call5 = call ptr @PyLong_FromLong(i64 noundef %9)
  call void @PyStructSequence_SetItem(ptr noundef %8, i64 noundef 2, ptr noundef %call5)
  %10 = load ptr, ptr %v, align 8
  %f_bfree = getelementptr inbounds %struct.statvfs, ptr %st, i32 0, i32 3
  %11 = load i64, ptr %f_bfree, align 8
  %call6 = call ptr @PyLong_FromLong(i64 noundef %11)
  call void @PyStructSequence_SetItem(ptr noundef %10, i64 noundef 3, ptr noundef %call6)
  %12 = load ptr, ptr %v, align 8
  %f_bavail = getelementptr inbounds %struct.statvfs, ptr %st, i32 0, i32 4
  %13 = load i64, ptr %f_bavail, align 8
  %call7 = call ptr @PyLong_FromLong(i64 noundef %13)
  call void @PyStructSequence_SetItem(ptr noundef %12, i64 noundef 4, ptr noundef %call7)
  %14 = load ptr, ptr %v, align 8
  %f_files = getelementptr inbounds %struct.statvfs, ptr %st, i32 0, i32 5
  %15 = load i64, ptr %f_files, align 8
  %call8 = call ptr @PyLong_FromLong(i64 noundef %15)
  call void @PyStructSequence_SetItem(ptr noundef %14, i64 noundef 5, ptr noundef %call8)
  %16 = load ptr, ptr %v, align 8
  %f_ffree = getelementptr inbounds %struct.statvfs, ptr %st, i32 0, i32 6
  %17 = load i64, ptr %f_ffree, align 8
  %call9 = call ptr @PyLong_FromLong(i64 noundef %17)
  call void @PyStructSequence_SetItem(ptr noundef %16, i64 noundef 6, ptr noundef %call9)
  %18 = load ptr, ptr %v, align 8
  %f_favail = getelementptr inbounds %struct.statvfs, ptr %st, i32 0, i32 7
  %19 = load i64, ptr %f_favail, align 8
  %call10 = call ptr @PyLong_FromLong(i64 noundef %19)
  call void @PyStructSequence_SetItem(ptr noundef %18, i64 noundef 7, ptr noundef %call10)
  %20 = load ptr, ptr %v, align 8
  %f_flag = getelementptr inbounds %struct.statvfs, ptr %st, i32 0, i32 9
  %21 = load i64, ptr %f_flag, align 8
  %call11 = call ptr @PyLong_FromLong(i64 noundef %21)
  call void @PyStructSequence_SetItem(ptr noundef %20, i64 noundef 8, ptr noundef %call11)
  %22 = load ptr, ptr %v, align 8
  %f_namemax = getelementptr inbounds %struct.statvfs, ptr %st, i32 0, i32 10
  %23 = load i64, ptr %f_namemax, align 8
  %call12 = call ptr @PyLong_FromLong(i64 noundef %23)
  call void @PyStructSequence_SetItem(ptr noundef %22, i64 noundef 9, ptr noundef %call12)
  %24 = load ptr, ptr %v, align 8
  %f_fsid = getelementptr inbounds %struct.statvfs, ptr %st, i32 0, i32 8
  %25 = load i64, ptr %f_fsid, align 8
  %call13 = call ptr @PyLong_FromUnsignedLong(i64 noundef %25)
  call void @PyStructSequence_SetItem(ptr noundef %24, i64 noundef 10, ptr noundef %call13)
  %call14 = call ptr @PyErr_Occurred()
  %tobool = icmp ne ptr %call14, null
  br i1 %tobool, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.end
  %26 = load ptr, ptr %v, align 8
  store ptr %26, ptr %op.addr.i, align 8
  %27 = load ptr, ptr %op.addr.i, align 8
  store ptr %27, ptr %op.addr.i17, align 8
  %28 = load ptr, ptr %op.addr.i17, align 8
  %29 = load i64, ptr %28, align 8
  %conv.i = trunc i64 %29 to i32
  %cmp.i18 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i18 to i32
  %tobool.i = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then15
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.then15
  %30 = load ptr, ptr %op.addr.i, align 8
  %31 = load i64, ptr %30, align 8
  %dec.i = add i64 %31, -1
  store i64 %dec.i, ptr %30, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %32 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %32) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  store ptr null, ptr %retval, align 8
  br label %return

if.end16:                                         ; preds = %if.end
  %33 = load ptr, ptr %v, align 8
  store ptr %33, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end16, %Py_DECREF.exit, %if.then
  %34 = load ptr, ptr %retval, align 8
  ret ptr %34
}

; Function Attrs: nounwind uwtable
define internal ptr @os_statvfs_impl(ptr noundef %module, ptr noundef %path) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %path.addr = alloca ptr, align 8
  %result = alloca i32, align 4
  %st = alloca %struct.statvfs, align 8
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %path, ptr %path.addr, align 8
  %call = call ptr @PyEval_SaveThread()
  store ptr %call, ptr %_save, align 8
  %0 = load ptr, ptr %path.addr, align 8
  %fd = getelementptr inbounds %struct.path_t, ptr %0, i32 0, i32 6
  %1 = load i32, ptr %fd, align 8
  %cmp = icmp ne i32 %1, -1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %path.addr, align 8
  %fd1 = getelementptr inbounds %struct.path_t, ptr %2, i32 0, i32 6
  %3 = load i32, ptr %fd1, align 8
  %call2 = call i32 @fstatvfs64(i32 noundef %3, ptr noundef %st) #10
  store i32 %call2, ptr %result, align 4
  br label %if.end

if.else:                                          ; preds = %entry
  %4 = load ptr, ptr %path.addr, align 8
  %narrow = getelementptr inbounds %struct.path_t, ptr %4, i32 0, i32 5
  %5 = load ptr, ptr %narrow, align 8
  %call3 = call i32 @statvfs64(ptr noundef %5, ptr noundef %st) #10
  store i32 %call3, ptr %result, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %6 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %6)
  %7 = load i32, ptr %result, align 4
  %tobool = icmp ne i32 %7, 0
  br i1 %tobool, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %8 = load ptr, ptr %path.addr, align 8
  %call5 = call ptr @path_error(ptr noundef %8)
  store ptr %call5, ptr %retval, align 8
  br label %return

if.end6:                                          ; preds = %if.end
  %9 = load ptr, ptr %module.addr, align 8
  %call7 = call ptr @_pystatvfs_fromstructstatvfs(ptr noundef %9, ptr noundef byval(%struct.statvfs) align 8 %st)
  store ptr %call7, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end6, %if.then4
  %10 = load ptr, ptr %retval, align 8
  ret ptr %10
}

; Function Attrs: nounwind
declare i32 @statvfs64(ptr noundef, ptr noundef) #4

; Function Attrs: nounwind uwtable
define internal i32 @conv_confstr_confname(ptr noundef %arg, ptr noundef %valuep) #0 {
entry:
  %arg.addr = alloca ptr, align 8
  %valuep.addr = alloca ptr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr %valuep, ptr %valuep.addr, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %1 = load ptr, ptr %valuep.addr, align 8
  %call = call i32 @conv_confname(ptr noundef %0, ptr noundef %1, ptr noundef @posix_constants_confstr, i64 noundef 27)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal ptr @os_confstr_impl(ptr noundef %module, i32 noundef %name) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %name.addr = alloca i32, align 4
  %result = alloca ptr, align 8
  %buffer = alloca [255 x i8], align 16
  %len = alloca i64, align 8
  %len2 = alloca i64, align 8
  %buf = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %name, ptr %name.addr, align 4
  store ptr null, ptr %result, align 8
  %call = call ptr @__errno_location() #12
  store i32 0, ptr %call, align 4
  %0 = load i32, ptr %name.addr, align 4
  %arraydecay = getelementptr inbounds [255 x i8], ptr %buffer, i64 0, i64 0
  %call1 = call i64 @confstr(i32 noundef %0, ptr noundef %arraydecay, i64 noundef 255) #10
  store i64 %call1, ptr %len, align 8
  %1 = load i64, ptr %len, align 8
  %cmp = icmp eq i64 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call2 = call ptr @__errno_location() #12
  %2 = load i32, ptr %call2, align 4
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.then
  %call4 = call ptr @posix_error()
  store ptr null, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %if.then
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load i64, ptr %len, align 8
  %cmp5 = icmp uge i64 %3, 255
  br i1 %cmp5, label %if.then6, label %if.else14

if.then6:                                         ; preds = %if.end
  %4 = load i64, ptr %len, align 8
  %call7 = call ptr @PyMem_Malloc(i64 noundef %4)
  store ptr %call7, ptr %buf, align 8
  %5 = load ptr, ptr %buf, align 8
  %cmp8 = icmp eq ptr %5, null
  br i1 %cmp8, label %if.then9, label %if.end11

if.then9:                                         ; preds = %if.then6
  %call10 = call ptr @PyErr_NoMemory()
  store ptr %call10, ptr %retval, align 8
  br label %return

if.end11:                                         ; preds = %if.then6
  %6 = load i32, ptr %name.addr, align 4
  %7 = load ptr, ptr %buf, align 8
  %8 = load i64, ptr %len, align 8
  %call12 = call i64 @confstr(i32 noundef %6, ptr noundef %7, i64 noundef %8) #10
  store i64 %call12, ptr %len2, align 8
  %9 = load ptr, ptr %buf, align 8
  %10 = load i64, ptr %len2, align 8
  %sub = sub i64 %10, 1
  %call13 = call ptr @PyUnicode_DecodeFSDefaultAndSize(ptr noundef %9, i64 noundef %sub)
  store ptr %call13, ptr %result, align 8
  %11 = load ptr, ptr %buf, align 8
  call void @PyMem_Free(ptr noundef %11)
  br label %if.end18

if.else14:                                        ; preds = %if.end
  %arraydecay15 = getelementptr inbounds [255 x i8], ptr %buffer, i64 0, i64 0
  %12 = load i64, ptr %len, align 8
  %sub16 = sub i64 %12, 1
  %call17 = call ptr @PyUnicode_DecodeFSDefaultAndSize(ptr noundef %arraydecay15, i64 noundef %sub16)
  store ptr %call17, ptr %result, align 8
  br label %if.end18

if.end18:                                         ; preds = %if.else14, %if.end11
  %13 = load ptr, ptr %result, align 8
  store ptr %13, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end18, %if.then9, %if.else, %if.then3
  %14 = load ptr, ptr %retval, align 8
  ret ptr %14
}

; Function Attrs: nounwind uwtable
define internal i32 @conv_confname(ptr noundef %arg, ptr noundef %valuep, ptr noundef %table, i64 noundef %tablesize) #0 {
entry:
  %retval = alloca i32, align 4
  %arg.addr = alloca ptr, align 8
  %valuep.addr = alloca ptr, align 8
  %table.addr = alloca ptr, align 8
  %tablesize.addr = alloca i64, align 8
  %value = alloca i32, align 4
  %lo = alloca i64, align 8
  %mid = alloca i64, align 8
  %hi = alloca i64, align 8
  %cmp6 = alloca i32, align 4
  %confname = alloca ptr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr %valuep, ptr %valuep.addr, align 8
  store ptr %table, ptr %table.addr, align 8
  store i64 %tablesize, ptr %tablesize.addr, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %call = call ptr @Py_TYPE(ptr noundef %0)
  %call1 = call i32 @PyType_HasFeature(ptr noundef %call, i64 noundef 16777216)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %arg.addr, align 8
  %call2 = call i32 @PyLong_AsInt(ptr noundef %1)
  store i32 %call2, ptr %value, align 4
  %2 = load i32, ptr %value, align 4
  %cmp = icmp eq i32 %2, -1
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then
  %call3 = call ptr @PyErr_Occurred()
  %tobool4 = icmp ne ptr %call3, null
  br i1 %tobool4, label %if.then5, label %if.end

if.then5:                                         ; preds = %land.lhs.true
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %if.then
  %3 = load i32, ptr %value, align 4
  %4 = load ptr, ptr %valuep.addr, align 8
  store i32 %3, ptr %4, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  store i64 0, ptr %lo, align 8
  %5 = load i64, ptr %tablesize.addr, align 8
  store i64 %5, ptr %hi, align 8
  %6 = load ptr, ptr %arg.addr, align 8
  %call7 = call ptr @Py_TYPE(ptr noundef %6)
  %call8 = call i32 @PyType_HasFeature(ptr noundef %call7, i64 noundef 268435456)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end11, label %if.then10

if.then10:                                        ; preds = %if.else
  %7 = load ptr, ptr @PyExc_TypeError, align 8
  call void @PyErr_SetString(ptr noundef %7, ptr noundef @.str.365)
  store i32 0, ptr %retval, align 4
  br label %return

if.end11:                                         ; preds = %if.else
  %8 = load ptr, ptr %arg.addr, align 8
  %call12 = call ptr @PyUnicode_AsUTF8(ptr noundef %8)
  store ptr %call12, ptr %confname, align 8
  %9 = load ptr, ptr %confname, align 8
  %cmp13 = icmp eq ptr %9, null
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end11
  store i32 0, ptr %retval, align 4
  br label %return

if.end15:                                         ; preds = %if.end11
  br label %while.cond

while.cond:                                       ; preds = %if.end28, %if.end15
  %10 = load i64, ptr %lo, align 8
  %11 = load i64, ptr %hi, align 8
  %cmp16 = icmp ult i64 %10, %11
  br i1 %cmp16, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %12 = load i64, ptr %lo, align 8
  %13 = load i64, ptr %hi, align 8
  %add = add i64 %12, %13
  %div = udiv i64 %add, 2
  store i64 %div, ptr %mid, align 8
  %14 = load ptr, ptr %confname, align 8
  %15 = load ptr, ptr %table.addr, align 8
  %16 = load i64, ptr %mid, align 8
  %arrayidx = getelementptr %struct.constdef, ptr %15, i64 %16
  %name = getelementptr inbounds %struct.constdef, ptr %arrayidx, i32 0, i32 0
  %17 = load ptr, ptr %name, align 8
  %call17 = call i32 @strcmp(ptr noundef %14, ptr noundef %17) #13
  store i32 %call17, ptr %cmp6, align 4
  %18 = load i32, ptr %cmp6, align 4
  %cmp18 = icmp slt i32 %18, 0
  br i1 %cmp18, label %if.then19, label %if.else20

if.then19:                                        ; preds = %while.body
  %19 = load i64, ptr %mid, align 8
  store i64 %19, ptr %hi, align 8
  br label %if.end28

if.else20:                                        ; preds = %while.body
  %20 = load i32, ptr %cmp6, align 4
  %cmp21 = icmp sgt i32 %20, 0
  br i1 %cmp21, label %if.then22, label %if.else24

if.then22:                                        ; preds = %if.else20
  %21 = load i64, ptr %mid, align 8
  %add23 = add i64 %21, 1
  store i64 %add23, ptr %lo, align 8
  br label %if.end27

if.else24:                                        ; preds = %if.else20
  %22 = load ptr, ptr %table.addr, align 8
  %23 = load i64, ptr %mid, align 8
  %arrayidx25 = getelementptr %struct.constdef, ptr %22, i64 %23
  %value26 = getelementptr inbounds %struct.constdef, ptr %arrayidx25, i32 0, i32 1
  %24 = load i32, ptr %value26, align 8
  %25 = load ptr, ptr %valuep.addr, align 8
  store i32 %24, ptr %25, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.end27:                                         ; preds = %if.then22
  br label %if.end28

if.end28:                                         ; preds = %if.end27, %if.then19
  br label %while.cond, !llvm.loop !49

while.end:                                        ; preds = %while.cond
  %26 = load ptr, ptr @PyExc_ValueError, align 8
  call void @PyErr_SetString(ptr noundef %26, ptr noundef @.str.366)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %while.end, %if.else24, %if.then14, %if.then10, %if.end, %if.then5
  %27 = load i32, ptr %retval, align 4
  ret i32 %27
}

declare ptr @PyUnicode_AsUTF8(ptr noundef) #1

; Function Attrs: nounwind willreturn memory(read)
declare i32 @strcmp(ptr noundef, ptr noundef) #7

; Function Attrs: nounwind
declare i64 @confstr(i32 noundef, ptr noundef, i64 noundef) #4

; Function Attrs: nounwind uwtable
define internal i32 @conv_sysconf_confname(ptr noundef %arg, ptr noundef %valuep) #0 {
entry:
  %arg.addr = alloca ptr, align 8
  %valuep.addr = alloca ptr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr %valuep, ptr %valuep.addr, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %1 = load ptr, ptr %valuep.addr, align 8
  %call = call i32 @conv_confname(ptr noundef %0, ptr noundef %1, ptr noundef @posix_constants_sysconf, i64 noundef 135)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i64 @os_sysconf_impl(ptr noundef %module, i32 noundef %name) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %name.addr = alloca i32, align 4
  %value = alloca i64, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %name, ptr %name.addr, align 4
  %call = call ptr @__errno_location() #12
  store i32 0, ptr %call, align 4
  %0 = load i32, ptr %name.addr, align 4
  %call1 = call i64 @sysconf(i32 noundef %0) #10
  store i64 %call1, ptr %value, align 8
  %1 = load i64, ptr %value, align 8
  %cmp = icmp eq i64 %1, -1
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %call2 = call ptr @__errno_location() #12
  %2 = load i32, ptr %call2, align 4
  %cmp3 = icmp ne i32 %2, 0
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %call4 = call ptr @posix_error()
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %3 = load i64, ptr %value, align 8
  ret i64 %3
}

; Function Attrs: nounwind uwtable
define internal i32 @conv_path_confname(ptr noundef %arg, ptr noundef %valuep) #0 {
entry:
  %arg.addr = alloca ptr, align 8
  %valuep.addr = alloca ptr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr %valuep, ptr %valuep.addr, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %1 = load ptr, ptr %valuep.addr, align 8
  %call = call i32 @conv_confname(ptr noundef %0, ptr noundef %1, ptr noundef @posix_constants_pathconf, i64 noundef 20)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i64 @os_fpathconf_impl(ptr noundef %module, i32 noundef %fd, i32 noundef %name) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %name.addr = alloca i32, align 4
  %limit = alloca i64, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i32 %name, ptr %name.addr, align 4
  %call = call ptr @__errno_location() #12
  store i32 0, ptr %call, align 4
  %0 = load i32, ptr %fd.addr, align 4
  %1 = load i32, ptr %name.addr, align 4
  %call1 = call i64 @fpathconf(i32 noundef %0, i32 noundef %1) #10
  store i64 %call1, ptr %limit, align 8
  %2 = load i64, ptr %limit, align 8
  %cmp = icmp eq i64 %2, -1
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %call2 = call ptr @__errno_location() #12
  %3 = load i32, ptr %call2, align 4
  %cmp3 = icmp ne i32 %3, 0
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %call4 = call ptr @posix_error()
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %4 = load i64, ptr %limit, align 8
  ret i64 %4
}

; Function Attrs: nounwind
declare i64 @fpathconf(i32 noundef, i32 noundef) #4

; Function Attrs: nounwind uwtable
define internal i64 @os_pathconf_impl(ptr noundef %module, ptr noundef %path, i32 noundef %name) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %path.addr = alloca ptr, align 8
  %name.addr = alloca i32, align 4
  %limit = alloca i64, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %path, ptr %path.addr, align 8
  store i32 %name, ptr %name.addr, align 4
  %call = call ptr @__errno_location() #12
  store i32 0, ptr %call, align 4
  %0 = load ptr, ptr %path.addr, align 8
  %fd = getelementptr inbounds %struct.path_t, ptr %0, i32 0, i32 6
  %1 = load i32, ptr %fd, align 8
  %cmp = icmp ne i32 %1, -1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %path.addr, align 8
  %fd1 = getelementptr inbounds %struct.path_t, ptr %2, i32 0, i32 6
  %3 = load i32, ptr %fd1, align 8
  %4 = load i32, ptr %name.addr, align 4
  %call2 = call i64 @fpathconf(i32 noundef %3, i32 noundef %4) #10
  store i64 %call2, ptr %limit, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %5 = load ptr, ptr %path.addr, align 8
  %narrow = getelementptr inbounds %struct.path_t, ptr %5, i32 0, i32 5
  %6 = load ptr, ptr %narrow, align 8
  %7 = load i32, ptr %name.addr, align 4
  %call3 = call i64 @pathconf(ptr noundef %6, i32 noundef %7) #10
  store i64 %call3, ptr %limit, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %8 = load i64, ptr %limit, align 8
  %cmp4 = icmp eq i64 %8, -1
  br i1 %cmp4, label %land.lhs.true, label %if.end15

land.lhs.true:                                    ; preds = %if.end
  %call5 = call ptr @__errno_location() #12
  %9 = load i32, ptr %call5, align 4
  %cmp6 = icmp ne i32 %9, 0
  br i1 %cmp6, label %if.then7, label %if.end15

if.then7:                                         ; preds = %land.lhs.true
  %call8 = call ptr @__errno_location() #12
  %10 = load i32, ptr %call8, align 4
  %cmp9 = icmp eq i32 %10, 22
  br i1 %cmp9, label %if.then10, label %if.else12

if.then10:                                        ; preds = %if.then7
  %call11 = call ptr @posix_error()
  br label %if.end14

if.else12:                                        ; preds = %if.then7
  %11 = load ptr, ptr %path.addr, align 8
  %call13 = call ptr @path_error(ptr noundef %11)
  br label %if.end14

if.end14:                                         ; preds = %if.else12, %if.then10
  br label %if.end15

if.end15:                                         ; preds = %if.end14, %land.lhs.true, %if.end
  %12 = load i64, ptr %limit, align 8
  ret i64 %12
}

; Function Attrs: nounwind
declare i64 @pathconf(ptr noundef, i32 noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_abort_impl(ptr noundef %module) #0 {
entry:
  %module.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  call void @abort() #14
  unreachable
}

; Function Attrs: noreturn nounwind
declare void @abort() #9

; Function Attrs: nounwind uwtable
define internal ptr @os__path_normpath_impl(ptr noundef %module, ptr noundef %path) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %path.addr = alloca ptr, align 8
  %len = alloca i64, align 8
  %buffer = alloca ptr, align 8
  %norm_len = alloca i64, align 8
  %norm_path = alloca ptr, align 8
  %result = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %path, ptr %path.addr, align 8
  %0 = load ptr, ptr %path.addr, align 8
  %call = call ptr @Py_TYPE(ptr noundef %0)
  %call1 = call i32 @PyType_HasFeature(ptr noundef %call, i64 noundef 268435456)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr @PyExc_TypeError, align 8
  %2 = load ptr, ptr %path.addr, align 8
  %call2 = call ptr @Py_TYPE(ptr noundef %2)
  %tp_name = getelementptr inbounds %struct._typeobject, ptr %call2, i32 0, i32 1
  %3 = load ptr, ptr %tp_name, align 8
  %call3 = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %1, ptr noundef @.str.550, ptr noundef %3)
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %path.addr, align 8
  %call4 = call ptr @PyUnicode_AsWideCharString(ptr noundef %4, ptr noundef %len)
  store ptr %call4, ptr %buffer, align 8
  %5 = load ptr, ptr %buffer, align 8
  %tobool5 = icmp ne ptr %5, null
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end7:                                          ; preds = %if.end
  %6 = load ptr, ptr %buffer, align 8
  %7 = load i64, ptr %len, align 8
  %call8 = call ptr @_Py_normpath_and_size(ptr noundef %6, i64 noundef %7, ptr noundef %norm_len)
  store ptr %call8, ptr %norm_path, align 8
  %8 = load ptr, ptr %norm_path, align 8
  %9 = load i64, ptr %norm_len, align 8
  %call9 = call ptr @PyUnicode_FromWideChar(ptr noundef %8, i64 noundef %9)
  store ptr %call9, ptr %result, align 8
  %10 = load ptr, ptr %buffer, align 8
  call void @PyMem_Free(ptr noundef %10)
  %11 = load ptr, ptr %result, align 8
  store ptr %11, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end7, %if.then6, %if.then
  %12 = load ptr, ptr %retval, align 8
  ret ptr %12
}

declare ptr @PyUnicode_AsWideCharString(ptr noundef, ptr noundef) #1

declare ptr @_Py_normpath_and_size(ptr noundef, i64 noundef, ptr noundef) #1

declare ptr @PyUnicode_FromWideChar(ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @os_getloadavg_impl(ptr noundef %module) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %loadavg = alloca [3 x double], align 16
  store ptr %module, ptr %module.addr, align 8
  %arraydecay = getelementptr inbounds [3 x double], ptr %loadavg, i64 0, i64 0
  %call = call i32 @getloadavg(ptr noundef %arraydecay, i32 noundef 3) #10
  %cmp = icmp ne i32 %call, 3
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %0 = load ptr, ptr @PyExc_OSError, align 8
  call void @PyErr_SetString(ptr noundef %0, ptr noundef @.str.551)
  store ptr null, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %arrayidx = getelementptr [3 x double], ptr %loadavg, i64 0, i64 0
  %1 = load double, ptr %arrayidx, align 16
  %arrayidx1 = getelementptr [3 x double], ptr %loadavg, i64 0, i64 1
  %2 = load double, ptr %arrayidx1, align 8
  %arrayidx2 = getelementptr [3 x double], ptr %loadavg, i64 0, i64 2
  %3 = load double, ptr %arrayidx2, align 16
  %call3 = call ptr (ptr, ...) @Py_BuildValue(ptr noundef @.str.552, double noundef %1, double noundef %2, double noundef %3)
  store ptr %call3, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %4 = load ptr, ptr %retval, align 8
  ret ptr %4
}

; Function Attrs: nounwind
declare i32 @getloadavg(ptr noundef, i32 noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_urandom_impl(ptr noundef %module, i64 noundef %size) #0 {
entry:
  %op.addr.i11 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %bytes = alloca ptr, align 8
  %result = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load i64, ptr %size.addr, align 8
  %cmp = icmp slt i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr @PyExc_ValueError, align 8
  %call = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %1, ptr noundef @.str.553)
  store ptr %call, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i64, ptr %size.addr, align 8
  %call1 = call ptr @PyBytes_FromStringAndSize(ptr noundef null, i64 noundef %2)
  store ptr %call1, ptr %bytes, align 8
  %3 = load ptr, ptr %bytes, align 8
  %cmp2 = icmp eq ptr %3, null
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  %4 = load ptr, ptr %bytes, align 8
  %call5 = call ptr @PyBytes_AS_STRING(ptr noundef %4)
  %5 = load ptr, ptr %bytes, align 8
  %call6 = call i64 @PyBytes_GET_SIZE(ptr noundef %5)
  %call7 = call i32 @_PyOS_URandom(ptr noundef %call5, i64 noundef %call6)
  store i32 %call7, ptr %result, align 4
  %6 = load i32, ptr %result, align 4
  %cmp8 = icmp eq i32 %6, -1
  br i1 %cmp8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end4
  %7 = load ptr, ptr %bytes, align 8
  store ptr %7, ptr %op.addr.i, align 8
  %8 = load ptr, ptr %op.addr.i, align 8
  store ptr %8, ptr %op.addr.i11, align 8
  %9 = load ptr, ptr %op.addr.i11, align 8
  %10 = load i64, ptr %9, align 8
  %conv.i = trunc i64 %10 to i32
  %cmp.i12 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i12 to i32
  %tobool.i = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then9
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.then9
  %11 = load ptr, ptr %op.addr.i, align 8
  %12 = load i64, ptr %11, align 8
  %dec.i = add i64 %12, -1
  store i64 %dec.i, ptr %11, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %13 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %13) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  store ptr null, ptr %retval, align 8
  br label %return

if.end10:                                         ; preds = %if.end4
  %14 = load ptr, ptr %bytes, align 8
  store ptr %14, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end10, %Py_DECREF.exit, %if.then3, %if.then
  %15 = load ptr, ptr %retval, align 8
  ret ptr %15
}

declare i32 @_PyOS_URandom(ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @os_setresuid_impl(ptr noundef %module, i32 noundef %ruid, i32 noundef %euid, i32 noundef %suid) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %ruid.addr = alloca i32, align 4
  %euid.addr = alloca i32, align 4
  %suid.addr = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %ruid, ptr %ruid.addr, align 4
  store i32 %euid, ptr %euid.addr, align 4
  store i32 %suid, ptr %suid.addr, align 4
  %0 = load i32, ptr %ruid.addr, align 4
  %1 = load i32, ptr %euid.addr, align 4
  %2 = load i32, ptr %suid.addr, align 4
  %call = call i32 @setresuid(i32 noundef %0, i32 noundef %1, i32 noundef %2) #10
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call ptr @posix_error()
  store ptr %call1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load ptr, ptr %retval, align 8
  ret ptr %3
}

; Function Attrs: nounwind
declare i32 @setresuid(i32 noundef, i32 noundef, i32 noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_setresgid_impl(ptr noundef %module, i32 noundef %rgid, i32 noundef %egid, i32 noundef %sgid) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %rgid.addr = alloca i32, align 4
  %egid.addr = alloca i32, align 4
  %sgid.addr = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %rgid, ptr %rgid.addr, align 4
  store i32 %egid, ptr %egid.addr, align 4
  store i32 %sgid, ptr %sgid.addr, align 4
  %0 = load i32, ptr %rgid.addr, align 4
  %1 = load i32, ptr %egid.addr, align 4
  %2 = load i32, ptr %sgid.addr, align 4
  %call = call i32 @setresgid(i32 noundef %0, i32 noundef %1, i32 noundef %2) #10
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call ptr @posix_error()
  store ptr %call1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load ptr, ptr %retval, align 8
  ret ptr %3
}

; Function Attrs: nounwind
declare i32 @setresgid(i32 noundef, i32 noundef, i32 noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_getresuid_impl(ptr noundef %module) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %ruid = alloca i32, align 4
  %euid = alloca i32, align 4
  %suid = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  %call = call i32 @getresuid(ptr noundef %ruid, ptr noundef %euid, ptr noundef %suid) #10
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call ptr @posix_error()
  store ptr %call1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %0 = load i32, ptr %ruid, align 4
  %call2 = call ptr @_PyLong_FromUid(i32 noundef %0)
  %1 = load i32, ptr %euid, align 4
  %call3 = call ptr @_PyLong_FromUid(i32 noundef %1)
  %2 = load i32, ptr %suid, align 4
  %call4 = call ptr @_PyLong_FromUid(i32 noundef %2)
  %call5 = call ptr (ptr, ...) @Py_BuildValue(ptr noundef @.str.554, ptr noundef %call2, ptr noundef %call3, ptr noundef %call4)
  store ptr %call5, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load ptr, ptr %retval, align 8
  ret ptr %3
}

; Function Attrs: nounwind
declare i32 @getresuid(ptr noundef, ptr noundef, ptr noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_getresgid_impl(ptr noundef %module) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %rgid = alloca i32, align 4
  %egid = alloca i32, align 4
  %sgid = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  %call = call i32 @getresgid(ptr noundef %rgid, ptr noundef %egid, ptr noundef %sgid) #10
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call ptr @posix_error()
  store ptr %call1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %0 = load i32, ptr %rgid, align 4
  %call2 = call ptr @_PyLong_FromGid(i32 noundef %0)
  %1 = load i32, ptr %egid, align 4
  %call3 = call ptr @_PyLong_FromGid(i32 noundef %1)
  %2 = load i32, ptr %sgid, align 4
  %call4 = call ptr @_PyLong_FromGid(i32 noundef %2)
  %call5 = call ptr (ptr, ...) @Py_BuildValue(ptr noundef @.str.554, ptr noundef %call2, ptr noundef %call3, ptr noundef %call4)
  store ptr %call5, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load ptr, ptr %retval, align 8
  ret ptr %3
}

; Function Attrs: nounwind
declare i32 @getresgid(ptr noundef, ptr noundef, ptr noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_getxattr_impl(ptr noundef %module, ptr noundef %path, ptr noundef %attribute, i32 noundef %follow_symlinks) #0 {
entry:
  %op.addr.i54 = alloca ptr, align 8
  %op.addr.i52 = alloca ptr, align 8
  %op.addr.i43 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %path.addr = alloca ptr, align 8
  %attribute.addr = alloca ptr, align 8
  %follow_symlinks.addr = alloca i32, align 4
  %i = alloca i64, align 8
  %buffer = alloca ptr, align 8
  %ptr = alloca ptr, align 8
  %result = alloca i64, align 8
  %buffer_size = alloca i64, align 8
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %path, ptr %path.addr, align 8
  store ptr %attribute, ptr %attribute.addr, align 8
  store i32 %follow_symlinks, ptr %follow_symlinks.addr, align 4
  store ptr null, ptr %buffer, align 8
  %0 = load ptr, ptr %path.addr, align 8
  %fd = getelementptr inbounds %struct.path_t, ptr %0, i32 0, i32 6
  %1 = load i32, ptr %fd, align 8
  %2 = load i32, ptr %follow_symlinks.addr, align 4
  %call = call i32 @fd_and_follow_symlinks_invalid(ptr noundef @.str.158, i32 noundef %1, i32 noundef %2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %path.addr, align 8
  %object = getelementptr inbounds %struct.path_t, ptr %3, i32 0, i32 8
  %4 = load ptr, ptr %object, align 8
  %5 = load ptr, ptr %attribute.addr, align 8
  %object1 = getelementptr inbounds %struct.path_t, ptr %5, i32 0, i32 8
  %6 = load ptr, ptr %object1, align 8
  %call2 = call i32 (ptr, ptr, ...) @PySys_Audit(ptr noundef @.str.556, ptr noundef @.str.360, ptr noundef %4, ptr noundef %6)
  %cmp = icmp slt i32 %call2, 0
  br i1 %cmp, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end4
  %7 = load i64, ptr %i, align 8
  %arrayidx = getelementptr [3 x i64], ptr @os_getxattr_impl.buffer_sizes, i64 0, i64 %7
  %8 = load i64, ptr %arrayidx, align 8
  store i64 %8, ptr %buffer_size, align 8
  %9 = load i64, ptr %buffer_size, align 8
  %tobool5 = icmp ne i64 %9, 0
  br i1 %tobool5, label %if.end8, label %if.then6

if.then6:                                         ; preds = %for.cond
  %10 = load ptr, ptr %path.addr, align 8
  %call7 = call ptr @path_error(ptr noundef %10)
  store ptr null, ptr %retval, align 8
  br label %return

if.end8:                                          ; preds = %for.cond
  %11 = load i64, ptr %buffer_size, align 8
  %call9 = call ptr @PyBytes_FromStringAndSize(ptr noundef null, i64 noundef %11)
  store ptr %call9, ptr %buffer, align 8
  %12 = load ptr, ptr %buffer, align 8
  %tobool10 = icmp ne ptr %12, null
  br i1 %tobool10, label %if.end12, label %if.then11

if.then11:                                        ; preds = %if.end8
  store ptr null, ptr %retval, align 8
  br label %return

if.end12:                                         ; preds = %if.end8
  %13 = load ptr, ptr %buffer, align 8
  %call13 = call ptr @PyBytes_AS_STRING(ptr noundef %13)
  store ptr %call13, ptr %ptr, align 8
  %call14 = call ptr @PyEval_SaveThread()
  store ptr %call14, ptr %_save, align 8
  %14 = load ptr, ptr %path.addr, align 8
  %fd15 = getelementptr inbounds %struct.path_t, ptr %14, i32 0, i32 6
  %15 = load i32, ptr %fd15, align 8
  %cmp16 = icmp sge i32 %15, 0
  br i1 %cmp16, label %if.then17, label %if.else

if.then17:                                        ; preds = %if.end12
  %16 = load ptr, ptr %path.addr, align 8
  %fd18 = getelementptr inbounds %struct.path_t, ptr %16, i32 0, i32 6
  %17 = load i32, ptr %fd18, align 8
  %18 = load ptr, ptr %attribute.addr, align 8
  %narrow = getelementptr inbounds %struct.path_t, ptr %18, i32 0, i32 5
  %19 = load ptr, ptr %narrow, align 8
  %20 = load ptr, ptr %ptr, align 8
  %21 = load i64, ptr %buffer_size, align 8
  %call19 = call i64 @fgetxattr(i32 noundef %17, ptr noundef %19, ptr noundef %20, i64 noundef %21) #10
  store i64 %call19, ptr %result, align 8
  br label %if.end30

if.else:                                          ; preds = %if.end12
  %22 = load i32, ptr %follow_symlinks.addr, align 4
  %tobool20 = icmp ne i32 %22, 0
  br i1 %tobool20, label %if.then21, label %if.else25

if.then21:                                        ; preds = %if.else
  %23 = load ptr, ptr %path.addr, align 8
  %narrow22 = getelementptr inbounds %struct.path_t, ptr %23, i32 0, i32 5
  %24 = load ptr, ptr %narrow22, align 8
  %25 = load ptr, ptr %attribute.addr, align 8
  %narrow23 = getelementptr inbounds %struct.path_t, ptr %25, i32 0, i32 5
  %26 = load ptr, ptr %narrow23, align 8
  %27 = load ptr, ptr %ptr, align 8
  %28 = load i64, ptr %buffer_size, align 8
  %call24 = call i64 @getxattr(ptr noundef %24, ptr noundef %26, ptr noundef %27, i64 noundef %28) #10
  store i64 %call24, ptr %result, align 8
  br label %if.end29

if.else25:                                        ; preds = %if.else
  %29 = load ptr, ptr %path.addr, align 8
  %narrow26 = getelementptr inbounds %struct.path_t, ptr %29, i32 0, i32 5
  %30 = load ptr, ptr %narrow26, align 8
  %31 = load ptr, ptr %attribute.addr, align 8
  %narrow27 = getelementptr inbounds %struct.path_t, ptr %31, i32 0, i32 5
  %32 = load ptr, ptr %narrow27, align 8
  %33 = load ptr, ptr %ptr, align 8
  %34 = load i64, ptr %buffer_size, align 8
  %call28 = call i64 @lgetxattr(ptr noundef %30, ptr noundef %32, ptr noundef %33, i64 noundef %34) #10
  store i64 %call28, ptr %result, align 8
  br label %if.end29

if.end29:                                         ; preds = %if.else25, %if.then21
  br label %if.end30

if.end30:                                         ; preds = %if.end29, %if.then17
  %35 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %35)
  %36 = load i64, ptr %result, align 8
  %cmp31 = icmp slt i64 %36, 0
  br i1 %cmp31, label %if.then32, label %if.end38

if.then32:                                        ; preds = %if.end30
  %call33 = call ptr @__errno_location() #12
  %37 = load i32, ptr %call33, align 4
  %cmp34 = icmp eq i32 %37, 34
  br i1 %cmp34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %if.then32
  %38 = load ptr, ptr %buffer, align 8
  store ptr %38, ptr %op.addr.i43, align 8
  %39 = load ptr, ptr %op.addr.i43, align 8
  store ptr %39, ptr %op.addr.i52, align 8
  %40 = load ptr, ptr %op.addr.i52, align 8
  %41 = load i64, ptr %40, align 8
  %conv.i = trunc i64 %41 to i32
  %cmp.i53 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i53 to i32
  %tobool.i45 = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i45, label %if.then.i50, label %if.end.i46

if.then.i50:                                      ; preds = %if.then35
  br label %Py_DECREF.exit51

if.end.i46:                                       ; preds = %if.then35
  %42 = load ptr, ptr %op.addr.i43, align 8
  %43 = load i64, ptr %42, align 8
  %dec.i47 = add i64 %43, -1
  store i64 %dec.i47, ptr %42, align 8
  %cmp.i48 = icmp eq i64 %dec.i47, 0
  br i1 %cmp.i48, label %if.then1.i49, label %Py_DECREF.exit51

if.then1.i49:                                     ; preds = %if.end.i46
  %44 = load ptr, ptr %op.addr.i43, align 8
  call void @_Py_Dealloc(ptr noundef %44) #10
  br label %Py_DECREF.exit51

Py_DECREF.exit51:                                 ; preds = %if.then1.i49, %if.end.i46, %if.then.i50
  br label %for.inc

if.end36:                                         ; preds = %if.then32
  %45 = load ptr, ptr %path.addr, align 8
  %call37 = call ptr @path_error(ptr noundef %45)
  %46 = load ptr, ptr %buffer, align 8
  store ptr %46, ptr %op.addr.i, align 8
  %47 = load ptr, ptr %op.addr.i, align 8
  store ptr %47, ptr %op.addr.i54, align 8
  %48 = load ptr, ptr %op.addr.i54, align 8
  %49 = load i64, ptr %48, align 8
  %conv.i55 = trunc i64 %49 to i32
  %cmp.i56 = icmp slt i32 %conv.i55, 0
  %conv1.i57 = zext i1 %cmp.i56 to i32
  %tobool.i = icmp ne i32 %conv1.i57, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.end36
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.end36
  %50 = load ptr, ptr %op.addr.i, align 8
  %51 = load i64, ptr %50, align 8
  %dec.i = add i64 %51, -1
  store i64 %dec.i, ptr %50, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %52 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %52) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  store ptr null, ptr %retval, align 8
  br label %return

if.end38:                                         ; preds = %if.end30
  %53 = load i64, ptr %result, align 8
  %54 = load i64, ptr %buffer_size, align 8
  %cmp39 = icmp ne i64 %53, %54
  br i1 %cmp39, label %if.then40, label %if.end42

if.then40:                                        ; preds = %if.end38
  %55 = load i64, ptr %result, align 8
  %call41 = call i32 @_PyBytes_Resize(ptr noundef %buffer, i64 noundef %55)
  br label %if.end42

if.end42:                                         ; preds = %if.then40, %if.end38
  br label %for.end

for.inc:                                          ; preds = %Py_DECREF.exit51
  %56 = load i64, ptr %i, align 8
  %inc = add i64 %56, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond

for.end:                                          ; preds = %if.end42
  %57 = load ptr, ptr %buffer, align 8
  store ptr %57, ptr %retval, align 8
  br label %return

return:                                           ; preds = %for.end, %Py_DECREF.exit, %if.then11, %if.then6, %if.then3, %if.then
  %58 = load ptr, ptr %retval, align 8
  ret ptr %58
}

; Function Attrs: nounwind
declare i64 @fgetxattr(i32 noundef, ptr noundef, ptr noundef, i64 noundef) #4

; Function Attrs: nounwind
declare i64 @getxattr(ptr noundef, ptr noundef, ptr noundef, i64 noundef) #4

; Function Attrs: nounwind
declare i64 @lgetxattr(ptr noundef, ptr noundef, ptr noundef, i64 noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_setxattr_impl(ptr noundef %module, ptr noundef %path, ptr noundef %attribute, ptr noundef %value, i32 noundef %flags, i32 noundef %follow_symlinks) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %path.addr = alloca ptr, align 8
  %attribute.addr = alloca ptr, align 8
  %value.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %follow_symlinks.addr = alloca i32, align 4
  %result = alloca i64, align 8
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %path, ptr %path.addr, align 8
  store ptr %attribute, ptr %attribute.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  store i32 %follow_symlinks, ptr %follow_symlinks.addr, align 4
  %0 = load ptr, ptr %path.addr, align 8
  %fd = getelementptr inbounds %struct.path_t, ptr %0, i32 0, i32 6
  %1 = load i32, ptr %fd, align 8
  %2 = load i32, ptr %follow_symlinks.addr, align 4
  %call = call i32 @fd_and_follow_symlinks_invalid(ptr noundef @.str.159, i32 noundef %1, i32 noundef %2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %path.addr, align 8
  %object = getelementptr inbounds %struct.path_t, ptr %3, i32 0, i32 8
  %4 = load ptr, ptr %object, align 8
  %5 = load ptr, ptr %attribute.addr, align 8
  %object1 = getelementptr inbounds %struct.path_t, ptr %5, i32 0, i32 8
  %6 = load ptr, ptr %object1, align 8
  %7 = load ptr, ptr %value.addr, align 8
  %buf = getelementptr inbounds %struct.Py_buffer, ptr %7, i32 0, i32 0
  %8 = load ptr, ptr %buf, align 8
  %9 = load ptr, ptr %value.addr, align 8
  %len = getelementptr inbounds %struct.Py_buffer, ptr %9, i32 0, i32 2
  %10 = load i64, ptr %len, align 8
  %11 = load i32, ptr %flags.addr, align 4
  %call2 = call i32 (ptr, ptr, ...) @PySys_Audit(ptr noundef @.str.558, ptr noundef @.str.559, ptr noundef %4, ptr noundef %6, ptr noundef %8, i64 noundef %10, i32 noundef %11)
  %cmp = icmp slt i32 %call2, 0
  br i1 %cmp, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  %call5 = call ptr @PyEval_SaveThread()
  store ptr %call5, ptr %_save, align 8
  %12 = load ptr, ptr %path.addr, align 8
  %fd6 = getelementptr inbounds %struct.path_t, ptr %12, i32 0, i32 6
  %13 = load i32, ptr %fd6, align 8
  %cmp7 = icmp sgt i32 %13, -1
  br i1 %cmp7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.end4
  %14 = load ptr, ptr %path.addr, align 8
  %fd9 = getelementptr inbounds %struct.path_t, ptr %14, i32 0, i32 6
  %15 = load i32, ptr %fd9, align 8
  %16 = load ptr, ptr %attribute.addr, align 8
  %narrow = getelementptr inbounds %struct.path_t, ptr %16, i32 0, i32 5
  %17 = load ptr, ptr %narrow, align 8
  %18 = load ptr, ptr %value.addr, align 8
  %buf10 = getelementptr inbounds %struct.Py_buffer, ptr %18, i32 0, i32 0
  %19 = load ptr, ptr %buf10, align 8
  %20 = load ptr, ptr %value.addr, align 8
  %len11 = getelementptr inbounds %struct.Py_buffer, ptr %20, i32 0, i32 2
  %21 = load i64, ptr %len11, align 8
  %22 = load i32, ptr %flags.addr, align 4
  %call12 = call i32 @fsetxattr(i32 noundef %15, ptr noundef %17, ptr noundef %19, i64 noundef %21, i32 noundef %22) #10
  %conv = sext i32 %call12 to i64
  store i64 %conv, ptr %result, align 8
  br label %if.end29

if.else:                                          ; preds = %if.end4
  %23 = load i32, ptr %follow_symlinks.addr, align 4
  %tobool13 = icmp ne i32 %23, 0
  br i1 %tobool13, label %if.then14, label %if.else21

if.then14:                                        ; preds = %if.else
  %24 = load ptr, ptr %path.addr, align 8
  %narrow15 = getelementptr inbounds %struct.path_t, ptr %24, i32 0, i32 5
  %25 = load ptr, ptr %narrow15, align 8
  %26 = load ptr, ptr %attribute.addr, align 8
  %narrow16 = getelementptr inbounds %struct.path_t, ptr %26, i32 0, i32 5
  %27 = load ptr, ptr %narrow16, align 8
  %28 = load ptr, ptr %value.addr, align 8
  %buf17 = getelementptr inbounds %struct.Py_buffer, ptr %28, i32 0, i32 0
  %29 = load ptr, ptr %buf17, align 8
  %30 = load ptr, ptr %value.addr, align 8
  %len18 = getelementptr inbounds %struct.Py_buffer, ptr %30, i32 0, i32 2
  %31 = load i64, ptr %len18, align 8
  %32 = load i32, ptr %flags.addr, align 4
  %call19 = call i32 @setxattr(ptr noundef %25, ptr noundef %27, ptr noundef %29, i64 noundef %31, i32 noundef %32) #10
  %conv20 = sext i32 %call19 to i64
  store i64 %conv20, ptr %result, align 8
  br label %if.end28

if.else21:                                        ; preds = %if.else
  %33 = load ptr, ptr %path.addr, align 8
  %narrow22 = getelementptr inbounds %struct.path_t, ptr %33, i32 0, i32 5
  %34 = load ptr, ptr %narrow22, align 8
  %35 = load ptr, ptr %attribute.addr, align 8
  %narrow23 = getelementptr inbounds %struct.path_t, ptr %35, i32 0, i32 5
  %36 = load ptr, ptr %narrow23, align 8
  %37 = load ptr, ptr %value.addr, align 8
  %buf24 = getelementptr inbounds %struct.Py_buffer, ptr %37, i32 0, i32 0
  %38 = load ptr, ptr %buf24, align 8
  %39 = load ptr, ptr %value.addr, align 8
  %len25 = getelementptr inbounds %struct.Py_buffer, ptr %39, i32 0, i32 2
  %40 = load i64, ptr %len25, align 8
  %41 = load i32, ptr %flags.addr, align 4
  %call26 = call i32 @lsetxattr(ptr noundef %34, ptr noundef %36, ptr noundef %38, i64 noundef %40, i32 noundef %41) #10
  %conv27 = sext i32 %call26 to i64
  store i64 %conv27, ptr %result, align 8
  br label %if.end28

if.end28:                                         ; preds = %if.else21, %if.then14
  br label %if.end29

if.end29:                                         ; preds = %if.end28, %if.then8
  %42 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %42)
  %43 = load i64, ptr %result, align 8
  %tobool30 = icmp ne i64 %43, 0
  br i1 %tobool30, label %if.then31, label %if.end33

if.then31:                                        ; preds = %if.end29
  %44 = load ptr, ptr %path.addr, align 8
  %call32 = call ptr @path_error(ptr noundef %44)
  store ptr null, ptr %retval, align 8
  br label %return

if.end33:                                         ; preds = %if.end29
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end33, %if.then31, %if.then3, %if.then
  %45 = load ptr, ptr %retval, align 8
  ret ptr %45
}

; Function Attrs: nounwind
declare i32 @fsetxattr(i32 noundef, ptr noundef, ptr noundef, i64 noundef, i32 noundef) #4

; Function Attrs: nounwind
declare i32 @setxattr(ptr noundef, ptr noundef, ptr noundef, i64 noundef, i32 noundef) #4

; Function Attrs: nounwind
declare i32 @lsetxattr(ptr noundef, ptr noundef, ptr noundef, i64 noundef, i32 noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_removexattr_impl(ptr noundef %module, ptr noundef %path, ptr noundef %attribute, i32 noundef %follow_symlinks) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %path.addr = alloca ptr, align 8
  %attribute.addr = alloca ptr, align 8
  %follow_symlinks.addr = alloca i32, align 4
  %result = alloca i64, align 8
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %path, ptr %path.addr, align 8
  store ptr %attribute, ptr %attribute.addr, align 8
  store i32 %follow_symlinks, ptr %follow_symlinks.addr, align 4
  %0 = load ptr, ptr %path.addr, align 8
  %fd = getelementptr inbounds %struct.path_t, ptr %0, i32 0, i32 6
  %1 = load i32, ptr %fd, align 8
  %2 = load i32, ptr %follow_symlinks.addr, align 4
  %call = call i32 @fd_and_follow_symlinks_invalid(ptr noundef @.str.160, i32 noundef %1, i32 noundef %2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %path.addr, align 8
  %object = getelementptr inbounds %struct.path_t, ptr %3, i32 0, i32 8
  %4 = load ptr, ptr %object, align 8
  %5 = load ptr, ptr %attribute.addr, align 8
  %object1 = getelementptr inbounds %struct.path_t, ptr %5, i32 0, i32 8
  %6 = load ptr, ptr %object1, align 8
  %call2 = call i32 (ptr, ptr, ...) @PySys_Audit(ptr noundef @.str.560, ptr noundef @.str.360, ptr noundef %4, ptr noundef %6)
  %cmp = icmp slt i32 %call2, 0
  br i1 %cmp, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  %call5 = call ptr @PyEval_SaveThread()
  store ptr %call5, ptr %_save, align 8
  %7 = load ptr, ptr %path.addr, align 8
  %fd6 = getelementptr inbounds %struct.path_t, ptr %7, i32 0, i32 6
  %8 = load i32, ptr %fd6, align 8
  %cmp7 = icmp sgt i32 %8, -1
  br i1 %cmp7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.end4
  %9 = load ptr, ptr %path.addr, align 8
  %fd9 = getelementptr inbounds %struct.path_t, ptr %9, i32 0, i32 6
  %10 = load i32, ptr %fd9, align 8
  %11 = load ptr, ptr %attribute.addr, align 8
  %narrow = getelementptr inbounds %struct.path_t, ptr %11, i32 0, i32 5
  %12 = load ptr, ptr %narrow, align 8
  %call10 = call i32 @fremovexattr(i32 noundef %10, ptr noundef %12) #10
  %conv = sext i32 %call10 to i64
  store i64 %conv, ptr %result, align 8
  br label %if.end23

if.else:                                          ; preds = %if.end4
  %13 = load i32, ptr %follow_symlinks.addr, align 4
  %tobool11 = icmp ne i32 %13, 0
  br i1 %tobool11, label %if.then12, label %if.else17

if.then12:                                        ; preds = %if.else
  %14 = load ptr, ptr %path.addr, align 8
  %narrow13 = getelementptr inbounds %struct.path_t, ptr %14, i32 0, i32 5
  %15 = load ptr, ptr %narrow13, align 8
  %16 = load ptr, ptr %attribute.addr, align 8
  %narrow14 = getelementptr inbounds %struct.path_t, ptr %16, i32 0, i32 5
  %17 = load ptr, ptr %narrow14, align 8
  %call15 = call i32 @removexattr(ptr noundef %15, ptr noundef %17) #10
  %conv16 = sext i32 %call15 to i64
  store i64 %conv16, ptr %result, align 8
  br label %if.end22

if.else17:                                        ; preds = %if.else
  %18 = load ptr, ptr %path.addr, align 8
  %narrow18 = getelementptr inbounds %struct.path_t, ptr %18, i32 0, i32 5
  %19 = load ptr, ptr %narrow18, align 8
  %20 = load ptr, ptr %attribute.addr, align 8
  %narrow19 = getelementptr inbounds %struct.path_t, ptr %20, i32 0, i32 5
  %21 = load ptr, ptr %narrow19, align 8
  %call20 = call i32 @lremovexattr(ptr noundef %19, ptr noundef %21) #10
  %conv21 = sext i32 %call20 to i64
  store i64 %conv21, ptr %result, align 8
  br label %if.end22

if.end22:                                         ; preds = %if.else17, %if.then12
  br label %if.end23

if.end23:                                         ; preds = %if.end22, %if.then8
  %22 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %22)
  %23 = load i64, ptr %result, align 8
  %tobool24 = icmp ne i64 %23, 0
  br i1 %tobool24, label %if.then25, label %if.end27

if.then25:                                        ; preds = %if.end23
  %24 = load ptr, ptr %path.addr, align 8
  %call26 = call ptr @path_error(ptr noundef %24)
  store ptr %call26, ptr %retval, align 8
  br label %return

if.end27:                                         ; preds = %if.end23
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end27, %if.then25, %if.then3, %if.then
  %25 = load ptr, ptr %retval, align 8
  ret ptr %25
}

; Function Attrs: nounwind
declare i32 @fremovexattr(i32 noundef, ptr noundef) #4

; Function Attrs: nounwind
declare i32 @removexattr(ptr noundef, ptr noundef) #4

; Function Attrs: nounwind
declare i32 @lremovexattr(ptr noundef, ptr noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_listxattr_impl(ptr noundef %module, ptr noundef %path, i32 noundef %follow_symlinks) #0 {
entry:
  %op.addr.i93 = alloca ptr, align 8
  %op.addr.i89 = alloca ptr, align 8
  %op.addr.i87 = alloca ptr, align 8
  %op.addr.i78 = alloca ptr, align 8
  %op.addr.i69 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %path.addr = alloca ptr, align 8
  %follow_symlinks.addr = alloca i32, align 4
  %i = alloca i64, align 8
  %result = alloca ptr, align 8
  %name = alloca ptr, align 8
  %buffer = alloca ptr, align 8
  %start = alloca ptr, align 8
  %trace = alloca ptr, align 8
  %end = alloca ptr, align 8
  %length = alloca i64, align 8
  %buffer_size = alloca i64, align 8
  %_save = alloca ptr, align 8
  %error = alloca i32, align 4
  %attribute = alloca ptr, align 8
  %_tmp_dst_ptr = alloca ptr, align 8
  %_tmp_old_dst = alloca ptr, align 8
  %_tmp_dst_ptr58 = alloca ptr, align 8
  %_tmp_old_dst59 = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %path, ptr %path.addr, align 8
  store i32 %follow_symlinks, ptr %follow_symlinks.addr, align 4
  store ptr null, ptr %result, align 8
  store ptr null, ptr %buffer, align 8
  %0 = load ptr, ptr %path.addr, align 8
  %fd = getelementptr inbounds %struct.path_t, ptr %0, i32 0, i32 6
  %1 = load i32, ptr %fd, align 8
  %2 = load i32, ptr %follow_symlinks.addr, align 4
  %call = call i32 @fd_and_follow_symlinks_invalid(ptr noundef @.str.161, i32 noundef %1, i32 noundef %2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %exit

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %path.addr, align 8
  %object = getelementptr inbounds %struct.path_t, ptr %3, i32 0, i32 8
  %4 = load ptr, ptr %object, align 8
  %tobool1 = icmp ne ptr %4, null
  br i1 %tobool1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %5 = load ptr, ptr %path.addr, align 8
  %object2 = getelementptr inbounds %struct.path_t, ptr %5, i32 0, i32 8
  %6 = load ptr, ptr %object2, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %6, %cond.true ], [ @_Py_NoneStruct, %cond.false ]
  %call3 = call i32 (ptr, ptr, ...) @PySys_Audit(ptr noundef @.str.561, ptr noundef @.str.204, ptr noundef %cond)
  %cmp = icmp slt i32 %call3, 0
  br i1 %cmp, label %if.then4, label %if.end5

if.then4:                                         ; preds = %cond.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end5:                                          ; preds = %cond.end
  %7 = load ptr, ptr %path.addr, align 8
  %narrow = getelementptr inbounds %struct.path_t, ptr %7, i32 0, i32 5
  %8 = load ptr, ptr %narrow, align 8
  %tobool6 = icmp ne ptr %8, null
  br i1 %tobool6, label %cond.true7, label %cond.false9

cond.true7:                                       ; preds = %if.end5
  %9 = load ptr, ptr %path.addr, align 8
  %narrow8 = getelementptr inbounds %struct.path_t, ptr %9, i32 0, i32 5
  %10 = load ptr, ptr %narrow8, align 8
  br label %cond.end10

cond.false9:                                      ; preds = %if.end5
  br label %cond.end10

cond.end10:                                       ; preds = %cond.false9, %cond.true7
  %cond11 = phi ptr [ %10, %cond.true7 ], [ @.str.224, %cond.false9 ]
  store ptr %cond11, ptr %name, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc64, %cond.end10
  %11 = load i64, ptr %i, align 8
  %arrayidx = getelementptr [3 x i64], ptr @os_listxattr_impl.buffer_sizes, i64 0, i64 %11
  %12 = load i64, ptr %arrayidx, align 8
  store i64 %12, ptr %buffer_size, align 8
  %13 = load i64, ptr %buffer_size, align 8
  %tobool12 = icmp ne i64 %13, 0
  br i1 %tobool12, label %if.end15, label %if.then13

if.then13:                                        ; preds = %for.cond
  %14 = load ptr, ptr %path.addr, align 8
  %call14 = call ptr @path_error(ptr noundef %14)
  br label %for.end65

if.end15:                                         ; preds = %for.cond
  %15 = load i64, ptr %buffer_size, align 8
  %call16 = call ptr @PyMem_Malloc(i64 noundef %15)
  store ptr %call16, ptr %buffer, align 8
  %16 = load ptr, ptr %buffer, align 8
  %tobool17 = icmp ne ptr %16, null
  br i1 %tobool17, label %if.end20, label %if.then18

if.then18:                                        ; preds = %if.end15
  %call19 = call ptr @PyErr_NoMemory()
  br label %for.end65

if.end20:                                         ; preds = %if.end15
  %call21 = call ptr @PyEval_SaveThread()
  store ptr %call21, ptr %_save, align 8
  %17 = load ptr, ptr %path.addr, align 8
  %fd22 = getelementptr inbounds %struct.path_t, ptr %17, i32 0, i32 6
  %18 = load i32, ptr %fd22, align 8
  %cmp23 = icmp sgt i32 %18, -1
  br i1 %cmp23, label %if.then24, label %if.else

if.then24:                                        ; preds = %if.end20
  %19 = load ptr, ptr %path.addr, align 8
  %fd25 = getelementptr inbounds %struct.path_t, ptr %19, i32 0, i32 6
  %20 = load i32, ptr %fd25, align 8
  %21 = load ptr, ptr %buffer, align 8
  %22 = load i64, ptr %buffer_size, align 8
  %call26 = call i64 @flistxattr(i32 noundef %20, ptr noundef %21, i64 noundef %22) #10
  store i64 %call26, ptr %length, align 8
  br label %if.end33

if.else:                                          ; preds = %if.end20
  %23 = load i32, ptr %follow_symlinks.addr, align 4
  %tobool27 = icmp ne i32 %23, 0
  br i1 %tobool27, label %if.then28, label %if.else30

if.then28:                                        ; preds = %if.else
  %24 = load ptr, ptr %name, align 8
  %25 = load ptr, ptr %buffer, align 8
  %26 = load i64, ptr %buffer_size, align 8
  %call29 = call i64 @listxattr(ptr noundef %24, ptr noundef %25, i64 noundef %26) #10
  store i64 %call29, ptr %length, align 8
  br label %if.end32

if.else30:                                        ; preds = %if.else
  %27 = load ptr, ptr %name, align 8
  %28 = load ptr, ptr %buffer, align 8
  %29 = load i64, ptr %buffer_size, align 8
  %call31 = call i64 @llistxattr(ptr noundef %27, ptr noundef %28, i64 noundef %29) #10
  store i64 %call31, ptr %length, align 8
  br label %if.end32

if.end32:                                         ; preds = %if.else30, %if.then28
  br label %if.end33

if.end33:                                         ; preds = %if.end32, %if.then24
  %30 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %30)
  %31 = load i64, ptr %length, align 8
  %cmp34 = icmp slt i64 %31, 0
  br i1 %cmp34, label %if.then35, label %if.end41

if.then35:                                        ; preds = %if.end33
  %call36 = call ptr @__errno_location() #12
  %32 = load i32, ptr %call36, align 4
  %cmp37 = icmp eq i32 %32, 34
  br i1 %cmp37, label %if.then38, label %if.end39

if.then38:                                        ; preds = %if.then35
  %33 = load ptr, ptr %buffer, align 8
  call void @PyMem_Free(ptr noundef %33)
  store ptr null, ptr %buffer, align 8
  br label %for.inc64

if.end39:                                         ; preds = %if.then35
  %34 = load ptr, ptr %path.addr, align 8
  %call40 = call ptr @path_error(ptr noundef %34)
  br label %for.end65

if.end41:                                         ; preds = %if.end33
  %call42 = call ptr @PyList_New(i64 noundef 0)
  store ptr %call42, ptr %result, align 8
  %35 = load ptr, ptr %result, align 8
  %tobool43 = icmp ne ptr %35, null
  br i1 %tobool43, label %if.end45, label %if.then44

if.then44:                                        ; preds = %if.end41
  br label %exit

if.end45:                                         ; preds = %if.end41
  %36 = load ptr, ptr %buffer, align 8
  %37 = load i64, ptr %length, align 8
  %add.ptr = getelementptr i8, ptr %36, i64 %37
  store ptr %add.ptr, ptr %end, align 8
  %38 = load ptr, ptr %buffer, align 8
  store ptr %38, ptr %start, align 8
  store ptr %38, ptr %trace, align 8
  br label %for.cond46

for.cond46:                                       ; preds = %for.inc, %if.end45
  %39 = load ptr, ptr %trace, align 8
  %40 = load ptr, ptr %end, align 8
  %cmp47 = icmp ne ptr %39, %40
  br i1 %cmp47, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond46
  %41 = load ptr, ptr %trace, align 8
  %42 = load i8, ptr %41, align 1
  %tobool48 = icmp ne i8 %42, 0
  br i1 %tobool48, label %if.end63, label %if.then49

if.then49:                                        ; preds = %for.body
  %43 = load ptr, ptr %start, align 8
  %44 = load ptr, ptr %trace, align 8
  %45 = load ptr, ptr %start, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %44 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %45 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %call50 = call ptr @PyUnicode_DecodeFSDefaultAndSize(ptr noundef %43, i64 noundef %sub.ptr.sub)
  store ptr %call50, ptr %attribute, align 8
  %46 = load ptr, ptr %attribute, align 8
  %tobool51 = icmp ne ptr %46, null
  br i1 %tobool51, label %if.end53, label %if.then52

if.then52:                                        ; preds = %if.then49
  br label %do.body

do.body:                                          ; preds = %if.then52
  store ptr %result, ptr %_tmp_dst_ptr, align 8
  %47 = load ptr, ptr %_tmp_dst_ptr, align 8
  %48 = load ptr, ptr %47, align 8
  store ptr %48, ptr %_tmp_old_dst, align 8
  %49 = load ptr, ptr %_tmp_dst_ptr, align 8
  store ptr null, ptr %49, align 8
  %50 = load ptr, ptr %_tmp_old_dst, align 8
  store ptr %50, ptr %op.addr.i78, align 8
  %51 = load ptr, ptr %op.addr.i78, align 8
  store ptr %51, ptr %op.addr.i87, align 8
  %52 = load ptr, ptr %op.addr.i87, align 8
  %53 = load i64, ptr %52, align 8
  %conv.i = trunc i64 %53 to i32
  %cmp.i88 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i88 to i32
  %tobool.i80 = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i80, label %if.then.i85, label %if.end.i81

if.then.i85:                                      ; preds = %do.body
  br label %Py_DECREF.exit86

if.end.i81:                                       ; preds = %do.body
  %54 = load ptr, ptr %op.addr.i78, align 8
  %55 = load i64, ptr %54, align 8
  %dec.i82 = add i64 %55, -1
  store i64 %dec.i82, ptr %54, align 8
  %cmp.i83 = icmp eq i64 %dec.i82, 0
  br i1 %cmp.i83, label %if.then1.i84, label %Py_DECREF.exit86

if.then1.i84:                                     ; preds = %if.end.i81
  %56 = load ptr, ptr %op.addr.i78, align 8
  call void @_Py_Dealloc(ptr noundef %56) #10
  br label %Py_DECREF.exit86

Py_DECREF.exit86:                                 ; preds = %if.then1.i84, %if.end.i81, %if.then.i85
  br label %do.end

do.end:                                           ; preds = %Py_DECREF.exit86
  br label %exit

if.end53:                                         ; preds = %if.then49
  %57 = load ptr, ptr %result, align 8
  %58 = load ptr, ptr %attribute, align 8
  %call54 = call i32 @PyList_Append(ptr noundef %57, ptr noundef %58)
  store i32 %call54, ptr %error, align 4
  %59 = load ptr, ptr %attribute, align 8
  store ptr %59, ptr %op.addr.i69, align 8
  %60 = load ptr, ptr %op.addr.i69, align 8
  store ptr %60, ptr %op.addr.i89, align 8
  %61 = load ptr, ptr %op.addr.i89, align 8
  %62 = load i64, ptr %61, align 8
  %conv.i90 = trunc i64 %62 to i32
  %cmp.i91 = icmp slt i32 %conv.i90, 0
  %conv1.i92 = zext i1 %cmp.i91 to i32
  %tobool.i71 = icmp ne i32 %conv1.i92, 0
  br i1 %tobool.i71, label %if.then.i76, label %if.end.i72

if.then.i76:                                      ; preds = %if.end53
  br label %Py_DECREF.exit77

if.end.i72:                                       ; preds = %if.end53
  %63 = load ptr, ptr %op.addr.i69, align 8
  %64 = load i64, ptr %63, align 8
  %dec.i73 = add i64 %64, -1
  store i64 %dec.i73, ptr %63, align 8
  %cmp.i74 = icmp eq i64 %dec.i73, 0
  br i1 %cmp.i74, label %if.then1.i75, label %Py_DECREF.exit77

if.then1.i75:                                     ; preds = %if.end.i72
  %65 = load ptr, ptr %op.addr.i69, align 8
  call void @_Py_Dealloc(ptr noundef %65) #10
  br label %Py_DECREF.exit77

Py_DECREF.exit77:                                 ; preds = %if.then1.i75, %if.end.i72, %if.then.i76
  %66 = load i32, ptr %error, align 4
  %tobool55 = icmp ne i32 %66, 0
  br i1 %tobool55, label %if.then56, label %if.end61

if.then56:                                        ; preds = %Py_DECREF.exit77
  br label %do.body57

do.body57:                                        ; preds = %if.then56
  store ptr %result, ptr %_tmp_dst_ptr58, align 8
  %67 = load ptr, ptr %_tmp_dst_ptr58, align 8
  %68 = load ptr, ptr %67, align 8
  store ptr %68, ptr %_tmp_old_dst59, align 8
  %69 = load ptr, ptr %_tmp_dst_ptr58, align 8
  store ptr null, ptr %69, align 8
  %70 = load ptr, ptr %_tmp_old_dst59, align 8
  store ptr %70, ptr %op.addr.i, align 8
  %71 = load ptr, ptr %op.addr.i, align 8
  store ptr %71, ptr %op.addr.i93, align 8
  %72 = load ptr, ptr %op.addr.i93, align 8
  %73 = load i64, ptr %72, align 8
  %conv.i94 = trunc i64 %73 to i32
  %cmp.i95 = icmp slt i32 %conv.i94, 0
  %conv1.i96 = zext i1 %cmp.i95 to i32
  %tobool.i = icmp ne i32 %conv1.i96, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %do.body57
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %do.body57
  %74 = load ptr, ptr %op.addr.i, align 8
  %75 = load i64, ptr %74, align 8
  %dec.i = add i64 %75, -1
  store i64 %dec.i, ptr %74, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %76 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %76) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  br label %do.end60

do.end60:                                         ; preds = %Py_DECREF.exit
  br label %exit

if.end61:                                         ; preds = %Py_DECREF.exit77
  %77 = load ptr, ptr %trace, align 8
  %add.ptr62 = getelementptr i8, ptr %77, i64 1
  store ptr %add.ptr62, ptr %start, align 8
  br label %if.end63

if.end63:                                         ; preds = %if.end61, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end63
  %78 = load ptr, ptr %trace, align 8
  %incdec.ptr = getelementptr i8, ptr %78, i32 1
  store ptr %incdec.ptr, ptr %trace, align 8
  br label %for.cond46, !llvm.loop !50

for.end:                                          ; preds = %for.cond46
  br label %for.end65

for.inc64:                                        ; preds = %if.then38
  %79 = load i64, ptr %i, align 8
  %inc = add i64 %79, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond

for.end65:                                        ; preds = %for.end, %if.end39, %if.then18, %if.then13
  br label %exit

exit:                                             ; preds = %for.end65, %do.end60, %do.end, %if.then44, %if.then
  %80 = load ptr, ptr %buffer, align 8
  %tobool66 = icmp ne ptr %80, null
  br i1 %tobool66, label %if.then67, label %if.end68

if.then67:                                        ; preds = %exit
  %81 = load ptr, ptr %buffer, align 8
  call void @PyMem_Free(ptr noundef %81)
  br label %if.end68

if.end68:                                         ; preds = %if.then67, %exit
  %82 = load ptr, ptr %result, align 8
  store ptr %82, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end68, %if.then4
  %83 = load ptr, ptr %retval, align 8
  ret ptr %83
}

; Function Attrs: nounwind
declare i64 @flistxattr(i32 noundef, ptr noundef, i64 noundef) #4

; Function Attrs: nounwind
declare i64 @listxattr(ptr noundef, ptr noundef, i64 noundef) #4

; Function Attrs: nounwind
declare i64 @llistxattr(ptr noundef, ptr noundef, i64 noundef) #4

; Function Attrs: nounwind
declare i32 @fileno(ptr noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_get_terminal_size_impl(ptr noundef %module, i32 noundef %fd) #0 {
entry:
  %op.addr.i17 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %columns = alloca i32, align 4
  %lines = alloca i32, align 4
  %termsize = alloca ptr, align 8
  %w = alloca %struct.winsize, align 2
  %TerminalSizeType = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  %0 = load i32, ptr %fd.addr, align 4
  %call = call i32 (i32, i64, ...) @ioctl(i32 noundef %0, i64 noundef 21523, ptr noundef %w) #10
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr @PyExc_OSError, align 8
  %call1 = call ptr @PyErr_SetFromErrno(ptr noundef %1)
  store ptr %call1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %ws_col = getelementptr inbounds %struct.winsize, ptr %w, i32 0, i32 1
  %2 = load i16, ptr %ws_col, align 2
  %conv = zext i16 %2 to i32
  store i32 %conv, ptr %columns, align 4
  %ws_row = getelementptr inbounds %struct.winsize, ptr %w, i32 0, i32 0
  %3 = load i16, ptr %ws_row, align 2
  %conv2 = zext i16 %3 to i32
  store i32 %conv2, ptr %lines, align 4
  %4 = load ptr, ptr %module.addr, align 8
  %call3 = call ptr @get_posix_state(ptr noundef %4)
  %TerminalSizeType4 = getelementptr inbounds %struct._posixstate, ptr %call3, i32 0, i32 7
  %5 = load ptr, ptr %TerminalSizeType4, align 8
  store ptr %5, ptr %TerminalSizeType, align 8
  %6 = load ptr, ptr %TerminalSizeType, align 8
  %call5 = call ptr @PyStructSequence_New(ptr noundef %6)
  store ptr %call5, ptr %termsize, align 8
  %7 = load ptr, ptr %termsize, align 8
  %cmp = icmp eq ptr %7, null
  br i1 %cmp, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end8:                                          ; preds = %if.end
  %8 = load ptr, ptr %termsize, align 8
  %9 = load i32, ptr %columns, align 4
  %conv9 = sext i32 %9 to i64
  %call10 = call ptr @PyLong_FromLong(i64 noundef %conv9)
  call void @PyStructSequence_SetItem(ptr noundef %8, i64 noundef 0, ptr noundef %call10)
  %10 = load ptr, ptr %termsize, align 8
  %11 = load i32, ptr %lines, align 4
  %conv11 = sext i32 %11 to i64
  %call12 = call ptr @PyLong_FromLong(i64 noundef %conv11)
  call void @PyStructSequence_SetItem(ptr noundef %10, i64 noundef 1, ptr noundef %call12)
  %call13 = call ptr @PyErr_Occurred()
  %tobool14 = icmp ne ptr %call13, null
  br i1 %tobool14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.end8
  %12 = load ptr, ptr %termsize, align 8
  store ptr %12, ptr %op.addr.i, align 8
  %13 = load ptr, ptr %op.addr.i, align 8
  store ptr %13, ptr %op.addr.i17, align 8
  %14 = load ptr, ptr %op.addr.i17, align 8
  %15 = load i64, ptr %14, align 8
  %conv.i = trunc i64 %15 to i32
  %cmp.i18 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i18 to i32
  %tobool.i = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then15
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.then15
  %16 = load ptr, ptr %op.addr.i, align 8
  %17 = load i64, ptr %16, align 8
  %dec.i = add i64 %17, -1
  store i64 %dec.i, ptr %16, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %18 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %18) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  store ptr null, ptr %retval, align 8
  br label %return

if.end16:                                         ; preds = %if.end8
  %19 = load ptr, ptr %termsize, align 8
  store ptr %19, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end16, %Py_DECREF.exit, %if.then7, %if.then
  %20 = load ptr, ptr %retval, align 8
  ret ptr %20
}

; Function Attrs: nounwind
declare i32 @ioctl(i32 noundef, i64 noundef, ...) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_cpu_count_impl(ptr noundef %module) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %config = alloca ptr, align 8
  %ncpu = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  %call = call ptr @_Py_GetConfig()
  store ptr %call, ptr %config, align 8
  %0 = load ptr, ptr %config, align 8
  %cpu_count = getelementptr inbounds %struct.PyConfig, ptr %0, i32 0, i32 43
  %1 = load i32, ptr %cpu_count, align 4
  %cmp = icmp sgt i32 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %config, align 8
  %cpu_count1 = getelementptr inbounds %struct.PyConfig, ptr %2, i32 0, i32 43
  %3 = load i32, ptr %cpu_count1, align 4
  %conv = sext i32 %3 to i64
  %call2 = call ptr @PyLong_FromLong(i64 noundef %conv)
  store ptr %call2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, ptr %ncpu, align 4
  %call3 = call i64 @sysconf(i32 noundef 84) #10
  %conv4 = trunc i64 %call3 to i32
  store i32 %conv4, ptr %ncpu, align 4
  %4 = load i32, ptr %ncpu, align 4
  %cmp5 = icmp slt i32 %4, 1
  br i1 %cmp5, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

if.end8:                                          ; preds = %if.end
  %5 = load i32, ptr %ncpu, align 4
  %conv9 = sext i32 %5 to i64
  %call10 = call ptr @PyLong_FromLong(i64 noundef %conv9)
  store ptr %call10, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end8, %if.then7, %if.then
  %6 = load ptr, ptr %retval, align 8
  ret ptr %6
}

declare ptr @_Py_GetConfig() #1

; Function Attrs: nounwind uwtable
define internal i32 @os_get_inheritable_impl(ptr noundef %module, i32 noundef %fd) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %return_value = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  %0 = load i32, ptr %fd.addr, align 4
  %call = call i32 @_Py_get_inheritable(i32 noundef %0)
  store i32 %call, ptr %return_value, align 4
  %1 = load i32, ptr %return_value, align 4
  ret i32 %1
}

declare i32 @_Py_get_inheritable(i32 noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @os_set_inheritable_impl(ptr noundef %module, i32 noundef %fd, i32 noundef %inheritable) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %inheritable.addr = alloca i32, align 4
  %result = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i32 %inheritable, ptr %inheritable.addr, align 4
  %0 = load i32, ptr %fd.addr, align 4
  %1 = load i32, ptr %inheritable.addr, align 4
  %call = call i32 @_Py_set_inheritable(i32 noundef %0, i32 noundef %1, ptr noundef null)
  store i32 %call, ptr %result, align 4
  %2 = load i32, ptr %result, align 4
  %cmp = icmp slt i32 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load ptr, ptr %retval, align 8
  ret ptr %3
}

; Function Attrs: nounwind uwtable
define internal i32 @os_get_blocking_impl(ptr noundef %module, i32 noundef %fd) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %blocking = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  %0 = load i32, ptr %fd.addr, align 4
  %call = call i32 @_Py_get_blocking(i32 noundef %0)
  store i32 %call, ptr %blocking, align 4
  %1 = load i32, ptr %blocking, align 4
  ret i32 %1
}

declare i32 @_Py_get_blocking(i32 noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @os_set_blocking_impl(ptr noundef %module, i32 noundef %fd, i32 noundef %blocking) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %blocking.addr = alloca i32, align 4
  %result = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i32 %blocking, ptr %blocking.addr, align 4
  %0 = load i32, ptr %fd.addr, align 4
  %1 = load i32, ptr %blocking.addr, align 4
  %call = call i32 @_Py_set_blocking(i32 noundef %0, i32 noundef %1)
  store i32 %call, ptr %result, align 4
  %2 = load i32, ptr %result, align 4
  %cmp = icmp slt i32 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load ptr, ptr %retval, align 8
  ret ptr %3
}

declare i32 @_Py_set_blocking(i32 noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @os_scandir_impl(ptr noundef %module, ptr noundef %path) #0 {
entry:
  %op.addr.i47 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %path.addr = alloca ptr, align 8
  %iterator = alloca ptr, align 8
  %path_str = alloca ptr, align 8
  %fd = alloca i32, align 4
  %ScandirIteratorType = alloca ptr, align 8
  %_save = alloca ptr, align 8
  %_save30 = alloca ptr, align 8
  %_save42 = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %path, ptr %path.addr, align 8
  store i32 -1, ptr %fd, align 4
  %0 = load ptr, ptr %path.addr, align 8
  %object = getelementptr inbounds %struct.path_t, ptr %0, i32 0, i32 8
  %1 = load ptr, ptr %object, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %path.addr, align 8
  %object1 = getelementptr inbounds %struct.path_t, ptr %2, i32 0, i32 8
  %3 = load ptr, ptr %object1, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %3, %cond.true ], [ @_Py_NoneStruct, %cond.false ]
  %call = call i32 (ptr, ptr, ...) @PySys_Audit(ptr noundef @.str.562, ptr noundef @.str.223, ptr noundef %cond)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end
  %4 = load ptr, ptr %module.addr, align 8
  %call2 = call ptr @get_posix_state(ptr noundef %4)
  %ScandirIteratorType3 = getelementptr inbounds %struct._posixstate, ptr %call2, i32 0, i32 2
  %5 = load ptr, ptr %ScandirIteratorType3, align 8
  store ptr %5, ptr %ScandirIteratorType, align 8
  %6 = load ptr, ptr %ScandirIteratorType, align 8
  %call4 = call ptr @_PyObject_New(ptr noundef %6)
  store ptr %call4, ptr %iterator, align 8
  %7 = load ptr, ptr %iterator, align 8
  %tobool5 = icmp ne ptr %7, null
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end7:                                          ; preds = %if.end
  %8 = load ptr, ptr %iterator, align 8
  %dirp = getelementptr inbounds %struct.ScandirIterator, ptr %8, i32 0, i32 2
  store ptr null, ptr %dirp, align 8
  %9 = load ptr, ptr %iterator, align 8
  %path8 = getelementptr inbounds %struct.ScandirIterator, ptr %9, i32 0, i32 1
  %10 = load ptr, ptr %path.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %path8, ptr align 8 %10, i64 72, i1 false)
  %11 = load ptr, ptr %path.addr, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %11, i8 0, i64 72, i1 false)
  %call9 = call ptr @__errno_location() #12
  store i32 0, ptr %call9, align 4
  %12 = load ptr, ptr %iterator, align 8
  %path10 = getelementptr inbounds %struct.ScandirIterator, ptr %12, i32 0, i32 1
  %fd11 = getelementptr inbounds %struct.path_t, ptr %path10, i32 0, i32 6
  %13 = load i32, ptr %fd11, align 8
  %cmp12 = icmp ne i32 %13, -1
  br i1 %cmp12, label %if.then13, label %if.else

if.then13:                                        ; preds = %if.end7
  %14 = load ptr, ptr %iterator, align 8
  %path14 = getelementptr inbounds %struct.ScandirIterator, ptr %14, i32 0, i32 1
  %fd15 = getelementptr inbounds %struct.path_t, ptr %path14, i32 0, i32 6
  %15 = load i32, ptr %fd15, align 8
  %call16 = call i32 @_Py_dup(i32 noundef %15)
  store i32 %call16, ptr %fd, align 4
  %16 = load i32, ptr %fd, align 4
  %cmp17 = icmp eq i32 %16, -1
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.then13
  br label %error

if.end19:                                         ; preds = %if.then13
  %call20 = call ptr @PyEval_SaveThread()
  store ptr %call20, ptr %_save, align 8
  %17 = load i32, ptr %fd, align 4
  %call21 = call ptr @fdopendir(i32 noundef %17)
  %18 = load ptr, ptr %iterator, align 8
  %dirp22 = getelementptr inbounds %struct.ScandirIterator, ptr %18, i32 0, i32 2
  store ptr %call21, ptr %dirp22, align 8
  %19 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %19)
  br label %if.end34

if.else:                                          ; preds = %if.end7
  %20 = load ptr, ptr %iterator, align 8
  %path23 = getelementptr inbounds %struct.ScandirIterator, ptr %20, i32 0, i32 1
  %narrow = getelementptr inbounds %struct.path_t, ptr %path23, i32 0, i32 5
  %21 = load ptr, ptr %narrow, align 8
  %tobool24 = icmp ne ptr %21, null
  br i1 %tobool24, label %if.then25, label %if.else28

if.then25:                                        ; preds = %if.else
  %22 = load ptr, ptr %iterator, align 8
  %path26 = getelementptr inbounds %struct.ScandirIterator, ptr %22, i32 0, i32 1
  %narrow27 = getelementptr inbounds %struct.path_t, ptr %path26, i32 0, i32 5
  %23 = load ptr, ptr %narrow27, align 8
  store ptr %23, ptr %path_str, align 8
  br label %if.end29

if.else28:                                        ; preds = %if.else
  store ptr @.str.224, ptr %path_str, align 8
  br label %if.end29

if.end29:                                         ; preds = %if.else28, %if.then25
  %call31 = call ptr @PyEval_SaveThread()
  store ptr %call31, ptr %_save30, align 8
  %24 = load ptr, ptr %path_str, align 8
  %call32 = call ptr @opendir(ptr noundef %24)
  %25 = load ptr, ptr %iterator, align 8
  %dirp33 = getelementptr inbounds %struct.ScandirIterator, ptr %25, i32 0, i32 2
  store ptr %call32, ptr %dirp33, align 8
  %26 = load ptr, ptr %_save30, align 8
  call void @PyEval_RestoreThread(ptr noundef %26)
  br label %if.end34

if.end34:                                         ; preds = %if.end29, %if.end19
  %27 = load ptr, ptr %iterator, align 8
  %dirp35 = getelementptr inbounds %struct.ScandirIterator, ptr %27, i32 0, i32 2
  %28 = load ptr, ptr %dirp35, align 8
  %tobool36 = icmp ne ptr %28, null
  br i1 %tobool36, label %if.end46, label %if.then37

if.then37:                                        ; preds = %if.end34
  %29 = load ptr, ptr %iterator, align 8
  %path38 = getelementptr inbounds %struct.ScandirIterator, ptr %29, i32 0, i32 1
  %call39 = call ptr @path_error(ptr noundef %path38)
  %30 = load i32, ptr %fd, align 4
  %cmp40 = icmp ne i32 %30, -1
  br i1 %cmp40, label %if.then41, label %if.end45

if.then41:                                        ; preds = %if.then37
  %call43 = call ptr @PyEval_SaveThread()
  store ptr %call43, ptr %_save42, align 8
  %31 = load i32, ptr %fd, align 4
  %call44 = call i32 @close(i32 noundef %31)
  %32 = load ptr, ptr %_save42, align 8
  call void @PyEval_RestoreThread(ptr noundef %32)
  br label %if.end45

if.end45:                                         ; preds = %if.then41, %if.then37
  br label %error

if.end46:                                         ; preds = %if.end34
  %33 = load ptr, ptr %iterator, align 8
  store ptr %33, ptr %retval, align 8
  br label %return

error:                                            ; preds = %if.end45, %if.then18
  %34 = load ptr, ptr %iterator, align 8
  store ptr %34, ptr %op.addr.i, align 8
  %35 = load ptr, ptr %op.addr.i, align 8
  store ptr %35, ptr %op.addr.i47, align 8
  %36 = load ptr, ptr %op.addr.i47, align 8
  %37 = load i64, ptr %36, align 8
  %conv.i = trunc i64 %37 to i32
  %cmp.i48 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i48 to i32
  %tobool.i = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %error
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %error
  %38 = load ptr, ptr %op.addr.i, align 8
  %39 = load i64, ptr %38, align 8
  %dec.i = add i64 %39, -1
  store i64 %dec.i, ptr %38, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %40 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %40) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %Py_DECREF.exit, %if.end46, %if.then6, %if.then
  %41 = load ptr, ptr %retval, align 8
  ret ptr %41
}

declare ptr @_PyObject_New(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @os_fspath_impl(ptr noundef %module, ptr noundef %path) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %path.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %path, ptr %path.addr, align 8
  %0 = load ptr, ptr %path.addr, align 8
  %call = call ptr @PyOS_FSPath(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @os_getrandom_impl(ptr noundef %module, i64 noundef %size, i32 noundef %flags) #0 {
entry:
  %op.addr.i27 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  %bytes = alloca ptr, align 8
  %n = alloca i64, align 8
  store ptr %module, ptr %module.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  %0 = load i64, ptr %size.addr, align 8
  %cmp = icmp slt i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call ptr @__errno_location() #12
  store i32 22, ptr %call, align 4
  %call1 = call ptr @posix_error()
  store ptr %call1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, ptr %size.addr, align 8
  %call2 = call ptr @PyBytes_FromStringAndSize(ptr noundef null, i64 noundef %1)
  store ptr %call2, ptr %bytes, align 8
  %2 = load ptr, ptr %bytes, align 8
  %cmp3 = icmp eq ptr %2, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call ptr @PyErr_NoMemory()
  store ptr null, ptr %retval, align 8
  br label %return

if.end6:                                          ; preds = %if.end
  br label %while.body

while.body:                                       ; preds = %if.end17, %if.end6
  %3 = load ptr, ptr %bytes, align 8
  %call7 = call ptr @PyBytes_AS_STRING(ptr noundef %3)
  %4 = load ptr, ptr %bytes, align 8
  %call8 = call i64 @PyBytes_GET_SIZE(ptr noundef %4)
  %5 = load i32, ptr %flags.addr, align 4
  %call9 = call i64 (i64, ...) @syscall(i64 noundef 318, ptr noundef %call7, i64 noundef %call8, i32 noundef %5) #10
  store i64 %call9, ptr %n, align 8
  %6 = load i64, ptr %n, align 8
  %cmp10 = icmp slt i64 %6, 0
  br i1 %cmp10, label %land.lhs.true, label %if.end18

land.lhs.true:                                    ; preds = %while.body
  %call11 = call ptr @__errno_location() #12
  %7 = load i32, ptr %call11, align 4
  %cmp12 = icmp eq i32 %7, 4
  br i1 %cmp12, label %if.then13, label %if.end18

if.then13:                                        ; preds = %land.lhs.true
  %call14 = call i32 @PyErr_CheckSignals()
  %cmp15 = icmp slt i32 %call14, 0
  br i1 %cmp15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.then13
  br label %error

if.end17:                                         ; preds = %if.then13
  br label %while.body

if.end18:                                         ; preds = %land.lhs.true, %while.body
  br label %while.end

while.end:                                        ; preds = %if.end18
  %8 = load i64, ptr %n, align 8
  %cmp19 = icmp slt i64 %8, 0
  br i1 %cmp19, label %if.then20, label %if.end22

if.then20:                                        ; preds = %while.end
  %9 = load ptr, ptr @PyExc_OSError, align 8
  %call21 = call ptr @PyErr_SetFromErrno(ptr noundef %9)
  br label %error

if.end22:                                         ; preds = %while.end
  %10 = load i64, ptr %n, align 8
  %11 = load i64, ptr %size.addr, align 8
  %cmp23 = icmp ne i64 %10, %11
  br i1 %cmp23, label %if.then24, label %if.end26

if.then24:                                        ; preds = %if.end22
  %12 = load i64, ptr %n, align 8
  %call25 = call i32 @_PyBytes_Resize(ptr noundef %bytes, i64 noundef %12)
  br label %if.end26

if.end26:                                         ; preds = %if.then24, %if.end22
  %13 = load ptr, ptr %bytes, align 8
  store ptr %13, ptr %retval, align 8
  br label %return

error:                                            ; preds = %if.then20, %if.then16
  %14 = load ptr, ptr %bytes, align 8
  store ptr %14, ptr %op.addr.i, align 8
  %15 = load ptr, ptr %op.addr.i, align 8
  store ptr %15, ptr %op.addr.i27, align 8
  %16 = load ptr, ptr %op.addr.i27, align 8
  %17 = load i64, ptr %16, align 8
  %conv.i = trunc i64 %17 to i32
  %cmp.i28 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i28 to i32
  %tobool.i = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %error
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %error
  %18 = load ptr, ptr %op.addr.i, align 8
  %19 = load i64, ptr %18, align 8
  %dec.i = add i64 %19, -1
  store i64 %dec.i, ptr %18, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %20 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %20) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %Py_DECREF.exit, %if.end26, %if.then4, %if.then
  %21 = load ptr, ptr %retval, align 8
  ret ptr %21
}

declare i64 @PyLong_AsUnsignedLongMask(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @os_memfd_create_impl(ptr noundef %module, ptr noundef %name, i32 noundef %flags) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %name.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %fd = alloca i32, align 4
  %bytes = alloca ptr, align 8
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %name, ptr %name.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  %0 = load ptr, ptr %name.addr, align 8
  %call = call ptr @PyBytes_AS_STRING(ptr noundef %0)
  store ptr %call, ptr %bytes, align 8
  %call1 = call ptr @PyEval_SaveThread()
  store ptr %call1, ptr %_save, align 8
  %1 = load ptr, ptr %bytes, align 8
  %2 = load i32, ptr %flags.addr, align 4
  %call2 = call i32 @memfd_create(ptr noundef %1, i32 noundef %2) #10
  store i32 %call2, ptr %fd, align 4
  %3 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %3)
  %4 = load i32, ptr %fd, align 4
  %cmp = icmp eq i32 %4, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load ptr, ptr @PyExc_OSError, align 8
  %call3 = call ptr @PyErr_SetFromErrno(ptr noundef %5)
  store ptr %call3, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %6 = load i32, ptr %fd, align 4
  %conv = sext i32 %6 to i64
  %call4 = call ptr @PyLong_FromLong(i64 noundef %conv)
  store ptr %call4, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load ptr, ptr %retval, align 8
  ret ptr %7
}

; Function Attrs: nounwind
declare i32 @memfd_create(ptr noundef, i32 noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_eventfd_impl(ptr noundef %module, i32 noundef %initval, i32 noundef %flags) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %initval.addr = alloca i32, align 4
  %flags.addr = alloca i32, align 4
  %fd = alloca i32, align 4
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %initval, ptr %initval.addr, align 4
  store i32 %flags, ptr %flags.addr, align 4
  %call = call ptr @PyEval_SaveThread()
  store ptr %call, ptr %_save, align 8
  %0 = load i32, ptr %initval.addr, align 4
  %1 = load i32, ptr %flags.addr, align 4
  %call1 = call i32 @eventfd(i32 noundef %0, i32 noundef %1) #10
  store i32 %call1, ptr %fd, align 4
  %2 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %2)
  %3 = load i32, ptr %fd, align 4
  %cmp = icmp eq i32 %3, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr @PyExc_OSError, align 8
  %call2 = call ptr @PyErr_SetFromErrno(ptr noundef %4)
  store ptr %call2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i32, ptr %fd, align 4
  %conv = sext i32 %5 to i64
  %call3 = call ptr @PyLong_FromLong(i64 noundef %conv)
  store ptr %call3, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load ptr, ptr %retval, align 8
  ret ptr %6
}

; Function Attrs: nounwind
declare i32 @eventfd(i32 noundef, i32 noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_eventfd_read_impl(ptr noundef %module, i32 noundef %fd) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %value = alloca i64, align 8
  %result = alloca i32, align 4
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  %call = call ptr @PyEval_SaveThread()
  store ptr %call, ptr %_save, align 8
  %0 = load i32, ptr %fd.addr, align 4
  %call1 = call i32 @eventfd_read(i32 noundef %0, ptr noundef %value)
  store i32 %call1, ptr %result, align 4
  %1 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %1)
  %2 = load i32, ptr %result, align 4
  %cmp = icmp eq i32 %2, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr @PyExc_OSError, align 8
  %call2 = call ptr @PyErr_SetFromErrno(ptr noundef %3)
  store ptr %call2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %4 = load i64, ptr %value, align 8
  %call3 = call ptr @PyLong_FromUnsignedLongLong(i64 noundef %4)
  store ptr %call3, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %5 = load ptr, ptr %retval, align 8
  ret ptr %5
}

declare i32 @eventfd_read(i32 noundef, ptr noundef) #1

declare i32 @_PyLong_UnsignedLongLong_Converter(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @os_eventfd_write_impl(ptr noundef %module, i32 noundef %fd, i64 noundef %value) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %value.addr = alloca i64, align 8
  %result = alloca i32, align 4
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i64 %value, ptr %value.addr, align 8
  %call = call ptr @PyEval_SaveThread()
  store ptr %call, ptr %_save, align 8
  %0 = load i32, ptr %fd.addr, align 4
  %1 = load i64, ptr %value.addr, align 8
  %call1 = call i32 @eventfd_write(i32 noundef %0, i64 noundef %1)
  store i32 %call1, ptr %result, align 4
  %2 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %2)
  %3 = load i32, ptr %result, align 4
  %cmp = icmp eq i32 %3, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr @PyExc_OSError, align 8
  %call2 = call ptr @PyErr_SetFromErrno(ptr noundef %4)
  store ptr %call2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %5 = load ptr, ptr %retval, align 8
  ret ptr %5
}

declare i32 @eventfd_write(i32 noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @os_waitstatus_to_exitcode_impl(ptr noundef %module, ptr noundef %status_obj) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %status_obj.addr = alloca ptr, align 8
  %status = alloca i32, align 4
  %wait_status = alloca i32, align 4
  %exitcode = alloca i32, align 4
  %signum = alloca i32, align 4
  %signum26 = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %status_obj, ptr %status_obj.addr, align 8
  %0 = load ptr, ptr %status_obj.addr, align 8
  %call = call i32 @PyLong_AsInt(ptr noundef %0)
  store i32 %call, ptr %status, align 4
  %1 = load i32, ptr %status, align 4
  %cmp = icmp eq i32 %1, -1
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %call1 = call ptr @PyErr_Occurred()
  %tobool = icmp ne ptr %call1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %2 = load i32, ptr %status, align 4
  store i32 %2, ptr %wait_status, align 4
  %3 = load i32, ptr %wait_status, align 4
  %and = and i32 %3, 127
  %cmp2 = icmp eq i32 %and, 0
  br i1 %cmp2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  %4 = load i32, ptr %wait_status, align 4
  %and4 = and i32 %4, 65280
  %shr = ashr i32 %and4, 8
  store i32 %shr, ptr %exitcode, align 4
  %5 = load i32, ptr %exitcode, align 4
  %cmp5 = icmp slt i32 %5, 0
  br i1 %cmp5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.then3
  %6 = load ptr, ptr @PyExc_ValueError, align 8
  %7 = load i32, ptr %exitcode, align 4
  %call7 = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %6, ptr noundef @.str.565, i32 noundef %7)
  store ptr null, ptr %retval, align 8
  br label %return

if.end8:                                          ; preds = %if.then3
  br label %if.end33

if.else:                                          ; preds = %if.end
  %8 = load i32, ptr %wait_status, align 4
  %and9 = and i32 %8, 127
  %add = add i32 %and9, 1
  %conv = trunc i32 %add to i8
  %conv10 = sext i8 %conv to i32
  %shr11 = ashr i32 %conv10, 1
  %cmp12 = icmp sgt i32 %shr11, 0
  br i1 %cmp12, label %if.then14, label %if.else21

if.then14:                                        ; preds = %if.else
  %9 = load i32, ptr %wait_status, align 4
  %and15 = and i32 %9, 127
  store i32 %and15, ptr %signum, align 4
  %10 = load i32, ptr %signum, align 4
  %cmp16 = icmp sle i32 %10, 0
  br i1 %cmp16, label %if.then18, label %if.end20

if.then18:                                        ; preds = %if.then14
  %11 = load ptr, ptr @PyExc_ValueError, align 8
  %12 = load i32, ptr %signum, align 4
  %call19 = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %11, ptr noundef @.str.566, i32 noundef %12)
  store ptr null, ptr %retval, align 8
  br label %return

if.end20:                                         ; preds = %if.then14
  %13 = load i32, ptr %signum, align 4
  %sub = sub i32 0, %13
  store i32 %sub, ptr %exitcode, align 4
  br label %if.end32

if.else21:                                        ; preds = %if.else
  %14 = load i32, ptr %wait_status, align 4
  %and22 = and i32 %14, 255
  %cmp23 = icmp eq i32 %and22, 127
  br i1 %cmp23, label %if.then25, label %if.else30

if.then25:                                        ; preds = %if.else21
  %15 = load i32, ptr %wait_status, align 4
  %and27 = and i32 %15, 65280
  %shr28 = ashr i32 %and27, 8
  store i32 %shr28, ptr %signum26, align 4
  %16 = load ptr, ptr @PyExc_ValueError, align 8
  %17 = load i32, ptr %signum26, align 4
  %call29 = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %16, ptr noundef @.str.567, i32 noundef %17)
  store ptr null, ptr %retval, align 8
  br label %return

if.else30:                                        ; preds = %if.else21
  %18 = load ptr, ptr @PyExc_ValueError, align 8
  %19 = load i32, ptr %status, align 4
  %call31 = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %18, ptr noundef @.str.568, i32 noundef %19)
  store ptr null, ptr %retval, align 8
  br label %return

if.end32:                                         ; preds = %if.end20
  br label %if.end33

if.end33:                                         ; preds = %if.end32, %if.end8
  %20 = load i32, ptr %exitcode, align 4
  %conv34 = sext i32 %20 to i64
  %call35 = call ptr @PyLong_FromLong(i64 noundef %conv34)
  store ptr %call35, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end33, %if.else30, %if.then25, %if.then18, %if.then6, %if.then
  %21 = load ptr, ptr %retval, align 8
  ret ptr %21
}

; Function Attrs: nounwind uwtable
define internal ptr @os_setns_impl(ptr noundef %module, i32 noundef %fd, i32 noundef %nstype) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %nstype.addr = alloca i32, align 4
  %res = alloca i32, align 4
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i32 %nstype, ptr %nstype.addr, align 4
  %call = call ptr @PyEval_SaveThread()
  store ptr %call, ptr %_save, align 8
  %0 = load i32, ptr %fd.addr, align 4
  %1 = load i32, ptr %nstype.addr, align 4
  %call1 = call i32 @setns(i32 noundef %0, i32 noundef %1) #10
  store i32 %call1, ptr %res, align 4
  %2 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %2)
  %3 = load i32, ptr %res, align 4
  %cmp = icmp ne i32 %3, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call2 = call ptr @posix_error()
  store ptr %call2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load ptr, ptr %retval, align 8
  ret ptr %4
}

; Function Attrs: nounwind
declare i32 @setns(i32 noundef, i32 noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_unshare_impl(ptr noundef %module, i32 noundef %flags) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %res = alloca i32, align 4
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  %call = call ptr @PyEval_SaveThread()
  store ptr %call, ptr %_save, align 8
  %0 = load i32, ptr %flags.addr, align 4
  %call1 = call i32 @unshare(i32 noundef %0) #10
  store i32 %call1, ptr %res, align 4
  %1 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %1)
  %2 = load i32, ptr %res, align 4
  %cmp = icmp ne i32 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call2 = call ptr @posix_error()
  store ptr %call2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load ptr, ptr %retval, align 8
  ret ptr %3
}

; Function Attrs: nounwind
declare i32 @unshare(i32 noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_timerfd_create_impl(ptr noundef %module, i32 noundef %clockid, i32 noundef %flags) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %clockid.addr = alloca i32, align 4
  %flags.addr = alloca i32, align 4
  %fd = alloca i32, align 4
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %clockid, ptr %clockid.addr, align 4
  store i32 %flags, ptr %flags.addr, align 4
  %call = call ptr @PyEval_SaveThread()
  store ptr %call, ptr %_save, align 8
  %0 = load i32, ptr %flags.addr, align 4
  %or = or i32 %0, 524288
  store i32 %or, ptr %flags.addr, align 4
  %1 = load i32, ptr %clockid.addr, align 4
  %2 = load i32, ptr %flags.addr, align 4
  %call1 = call i32 @timerfd_create(i32 noundef %1, i32 noundef %2) #10
  store i32 %call1, ptr %fd, align 4
  %3 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %3)
  %4 = load i32, ptr %fd, align 4
  %cmp = icmp eq i32 %4, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load ptr, ptr @PyExc_OSError, align 8
  %call2 = call ptr @PyErr_SetFromErrno(ptr noundef %5)
  store ptr %call2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %6 = load i32, ptr %fd, align 4
  %conv = sext i32 %6 to i64
  %call3 = call ptr @PyLong_FromLong(i64 noundef %conv)
  store ptr %call3, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load ptr, ptr %retval, align 8
  ret ptr %7
}

; Function Attrs: nounwind
declare i32 @timerfd_create(i32 noundef, i32 noundef) #4

; Function Attrs: nounwind uwtable
define internal double @PyFloat_AS_DOUBLE(ptr noundef %op) #0 {
entry:
  %op.addr = alloca ptr, align 8
  store ptr %op, ptr %op.addr, align 8
  %0 = load ptr, ptr %op.addr, align 8
  %ob_fval = getelementptr inbounds %struct.PyFloatObject, ptr %0, i32 0, i32 1
  %1 = load double, ptr %ob_fval, align 8
  ret double %1
}

declare double @PyFloat_AsDouble(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @os_timerfd_settime_impl(ptr noundef %module, i32 noundef %fd, i32 noundef %flags, double noundef %initial, double noundef %interval) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %flags.addr = alloca i32, align 4
  %initial.addr = alloca double, align 8
  %interval.addr = alloca double, align 8
  %new_value = alloca %struct.itimerspec, align 8
  %old_value = alloca %struct.itimerspec, align 8
  %result = alloca i32, align 4
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i32 %flags, ptr %flags.addr, align 4
  store double %initial, ptr %initial.addr, align 8
  store double %interval, ptr %interval.addr, align 8
  %0 = load double, ptr %initial.addr, align 8
  %call = call i64 @_PyTime_FromSecondsDouble(double noundef %0, i32 noundef 0)
  %it_value = getelementptr inbounds %struct.itimerspec, ptr %new_value, i32 0, i32 1
  %call1 = call i32 @_PyTime_AsTimespec(i64 noundef %call, ptr noundef %it_value)
  %cmp = icmp slt i32 %call1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr @PyExc_ValueError, align 8
  call void @PyErr_SetString(ptr noundef %1, ptr noundef @.str.572)
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load double, ptr %interval.addr, align 8
  %call2 = call i64 @_PyTime_FromSecondsDouble(double noundef %2, i32 noundef 0)
  %it_interval = getelementptr inbounds %struct.itimerspec, ptr %new_value, i32 0, i32 0
  %call3 = call i32 @_PyTime_AsTimespec(i64 noundef %call2, ptr noundef %it_interval)
  %cmp4 = icmp slt i32 %call3, 0
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end
  %3 = load ptr, ptr @PyExc_ValueError, align 8
  call void @PyErr_SetString(ptr noundef %3, ptr noundef @.str.573)
  store ptr null, ptr %retval, align 8
  br label %return

if.end6:                                          ; preds = %if.end
  %call7 = call ptr @PyEval_SaveThread()
  store ptr %call7, ptr %_save, align 8
  %4 = load i32, ptr %fd.addr, align 4
  %5 = load i32, ptr %flags.addr, align 4
  %call8 = call i32 @timerfd_settime(i32 noundef %4, i32 noundef %5, ptr noundef %new_value, ptr noundef %old_value) #10
  store i32 %call8, ptr %result, align 4
  %6 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %6)
  %7 = load i32, ptr %result, align 4
  %cmp9 = icmp eq i32 %7, -1
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %if.end6
  %8 = load ptr, ptr @PyExc_OSError, align 8
  %call11 = call ptr @PyErr_SetFromErrno(ptr noundef %8)
  store ptr %call11, ptr %retval, align 8
  br label %return

if.end12:                                         ; preds = %if.end6
  %call13 = call ptr @build_itimerspec(ptr noundef %old_value)
  store ptr %call13, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end12, %if.then10, %if.then5, %if.then
  %9 = load ptr, ptr %retval, align 8
  ret ptr %9
}

declare i32 @_PyTime_AsTimespec(i64 noundef, ptr noundef) #1

declare i64 @_PyTime_FromSecondsDouble(double noundef, i32 noundef) #1

; Function Attrs: nounwind
declare i32 @timerfd_settime(i32 noundef, i32 noundef, ptr noundef, ptr noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @build_itimerspec(ptr noundef %curr_value) #0 {
entry:
  %op.addr.i39 = alloca ptr, align 8
  %op.addr.i35 = alloca ptr, align 8
  %op.addr.i33 = alloca ptr, align 8
  %op.addr.i24 = alloca ptr, align 8
  %op.addr.i15 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %curr_value.addr = alloca ptr, align 8
  %_value = alloca double, align 8
  %value = alloca ptr, align 8
  %_interval = alloca double, align 8
  %interval = alloca ptr, align 8
  %tuple = alloca ptr, align 8
  store ptr %curr_value, ptr %curr_value.addr, align 8
  %0 = load ptr, ptr %curr_value.addr, align 8
  %it_value = getelementptr inbounds %struct.itimerspec, ptr %0, i32 0, i32 1
  %tv_sec = getelementptr inbounds %struct.timespec, ptr %it_value, i32 0, i32 0
  %1 = load i64, ptr %tv_sec, align 8
  %conv = sitofp i64 %1 to double
  %2 = load ptr, ptr %curr_value.addr, align 8
  %it_value1 = getelementptr inbounds %struct.itimerspec, ptr %2, i32 0, i32 1
  %tv_nsec = getelementptr inbounds %struct.timespec, ptr %it_value1, i32 0, i32 1
  %3 = load i64, ptr %tv_nsec, align 8
  %conv2 = sitofp i64 %3 to double
  %4 = call double @llvm.fmuladd.f64(double %conv2, double 1.000000e-09, double %conv)
  store double %4, ptr %_value, align 8
  %5 = load double, ptr %_value, align 8
  %call = call ptr @PyFloat_FromDouble(double noundef %5)
  store ptr %call, ptr %value, align 8
  %6 = load ptr, ptr %value, align 8
  %cmp = icmp eq ptr %6, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %7 = load ptr, ptr %curr_value.addr, align 8
  %it_interval = getelementptr inbounds %struct.itimerspec, ptr %7, i32 0, i32 0
  %tv_sec4 = getelementptr inbounds %struct.timespec, ptr %it_interval, i32 0, i32 0
  %8 = load i64, ptr %tv_sec4, align 8
  %conv5 = sitofp i64 %8 to double
  %9 = load ptr, ptr %curr_value.addr, align 8
  %it_interval6 = getelementptr inbounds %struct.itimerspec, ptr %9, i32 0, i32 0
  %tv_nsec7 = getelementptr inbounds %struct.timespec, ptr %it_interval6, i32 0, i32 1
  %10 = load i64, ptr %tv_nsec7, align 8
  %conv8 = sitofp i64 %10 to double
  %11 = call double @llvm.fmuladd.f64(double %conv8, double 1.000000e-09, double %conv5)
  store double %11, ptr %_interval, align 8
  %12 = load double, ptr %_interval, align 8
  %call9 = call ptr @PyFloat_FromDouble(double noundef %12)
  store ptr %call9, ptr %interval, align 8
  %13 = load ptr, ptr %interval, align 8
  %cmp10 = icmp eq ptr %13, null
  br i1 %cmp10, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end
  %14 = load ptr, ptr %value, align 8
  store ptr %14, ptr %op.addr.i24, align 8
  %15 = load ptr, ptr %op.addr.i24, align 8
  store ptr %15, ptr %op.addr.i33, align 8
  %16 = load ptr, ptr %op.addr.i33, align 8
  %17 = load i64, ptr %16, align 8
  %conv.i = trunc i64 %17 to i32
  %cmp.i34 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i34 to i32
  %tobool.i26 = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i26, label %if.then.i31, label %if.end.i27

if.then.i31:                                      ; preds = %if.then12
  br label %Py_DECREF.exit32

if.end.i27:                                       ; preds = %if.then12
  %18 = load ptr, ptr %op.addr.i24, align 8
  %19 = load i64, ptr %18, align 8
  %dec.i28 = add i64 %19, -1
  store i64 %dec.i28, ptr %18, align 8
  %cmp.i29 = icmp eq i64 %dec.i28, 0
  br i1 %cmp.i29, label %if.then1.i30, label %Py_DECREF.exit32

if.then1.i30:                                     ; preds = %if.end.i27
  %20 = load ptr, ptr %op.addr.i24, align 8
  call void @_Py_Dealloc(ptr noundef %20) #10
  br label %Py_DECREF.exit32

Py_DECREF.exit32:                                 ; preds = %if.then1.i30, %if.end.i27, %if.then.i31
  store ptr null, ptr %retval, align 8
  br label %return

if.end13:                                         ; preds = %if.end
  %21 = load ptr, ptr %value, align 8
  %22 = load ptr, ptr %interval, align 8
  %call14 = call ptr (i64, ...) @PyTuple_Pack(i64 noundef 2, ptr noundef %21, ptr noundef %22)
  store ptr %call14, ptr %tuple, align 8
  %23 = load ptr, ptr %interval, align 8
  store ptr %23, ptr %op.addr.i15, align 8
  %24 = load ptr, ptr %op.addr.i15, align 8
  store ptr %24, ptr %op.addr.i35, align 8
  %25 = load ptr, ptr %op.addr.i35, align 8
  %26 = load i64, ptr %25, align 8
  %conv.i36 = trunc i64 %26 to i32
  %cmp.i37 = icmp slt i32 %conv.i36, 0
  %conv1.i38 = zext i1 %cmp.i37 to i32
  %tobool.i17 = icmp ne i32 %conv1.i38, 0
  br i1 %tobool.i17, label %if.then.i22, label %if.end.i18

if.then.i22:                                      ; preds = %if.end13
  br label %Py_DECREF.exit23

if.end.i18:                                       ; preds = %if.end13
  %27 = load ptr, ptr %op.addr.i15, align 8
  %28 = load i64, ptr %27, align 8
  %dec.i19 = add i64 %28, -1
  store i64 %dec.i19, ptr %27, align 8
  %cmp.i20 = icmp eq i64 %dec.i19, 0
  br i1 %cmp.i20, label %if.then1.i21, label %Py_DECREF.exit23

if.then1.i21:                                     ; preds = %if.end.i18
  %29 = load ptr, ptr %op.addr.i15, align 8
  call void @_Py_Dealloc(ptr noundef %29) #10
  br label %Py_DECREF.exit23

Py_DECREF.exit23:                                 ; preds = %if.then1.i21, %if.end.i18, %if.then.i22
  %30 = load ptr, ptr %value, align 8
  store ptr %30, ptr %op.addr.i, align 8
  %31 = load ptr, ptr %op.addr.i, align 8
  store ptr %31, ptr %op.addr.i39, align 8
  %32 = load ptr, ptr %op.addr.i39, align 8
  %33 = load i64, ptr %32, align 8
  %conv.i40 = trunc i64 %33 to i32
  %cmp.i41 = icmp slt i32 %conv.i40, 0
  %conv1.i42 = zext i1 %cmp.i41 to i32
  %tobool.i = icmp ne i32 %conv1.i42, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %Py_DECREF.exit23
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %Py_DECREF.exit23
  %34 = load ptr, ptr %op.addr.i, align 8
  %35 = load i64, ptr %34, align 8
  %dec.i = add i64 %35, -1
  store i64 %dec.i, ptr %34, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %36 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %36) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  %37 = load ptr, ptr %tuple, align 8
  store ptr %37, ptr %retval, align 8
  br label %return

return:                                           ; preds = %Py_DECREF.exit, %Py_DECREF.exit32, %if.then
  %38 = load ptr, ptr %retval, align 8
  ret ptr %38
}

declare ptr @PyTuple_Pack(i64 noundef, ...) #1

declare i64 @PyLong_AsLongLong(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @os_timerfd_settime_ns_impl(ptr noundef %module, i32 noundef %fd, i32 noundef %flags, i64 noundef %initial, i64 noundef %interval) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %flags.addr = alloca i32, align 4
  %initial.addr = alloca i64, align 8
  %interval.addr = alloca i64, align 8
  %new_value = alloca %struct.itimerspec, align 8
  %old_value = alloca %struct.itimerspec, align 8
  %result = alloca i32, align 4
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i32 %flags, ptr %flags.addr, align 4
  store i64 %initial, ptr %initial.addr, align 8
  store i64 %interval, ptr %interval.addr, align 8
  %0 = load i64, ptr %initial.addr, align 8
  %it_value = getelementptr inbounds %struct.itimerspec, ptr %new_value, i32 0, i32 1
  %call = call i32 @_PyTime_AsTimespec(i64 noundef %0, ptr noundef %it_value)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr @PyExc_ValueError, align 8
  call void @PyErr_SetString(ptr noundef %1, ptr noundef @.str.572)
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i64, ptr %interval.addr, align 8
  %it_interval = getelementptr inbounds %struct.itimerspec, ptr %new_value, i32 0, i32 0
  %call1 = call i32 @_PyTime_AsTimespec(i64 noundef %2, ptr noundef %it_interval)
  %cmp2 = icmp slt i32 %call1, 0
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %3 = load ptr, ptr @PyExc_ValueError, align 8
  call void @PyErr_SetString(ptr noundef %3, ptr noundef @.str.573)
  store ptr null, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  %call5 = call ptr @PyEval_SaveThread()
  store ptr %call5, ptr %_save, align 8
  %4 = load i32, ptr %fd.addr, align 4
  %5 = load i32, ptr %flags.addr, align 4
  %call6 = call i32 @timerfd_settime(i32 noundef %4, i32 noundef %5, ptr noundef %new_value, ptr noundef %old_value) #10
  store i32 %call6, ptr %result, align 4
  %6 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %6)
  %7 = load i32, ptr %result, align 4
  %cmp7 = icmp eq i32 %7, -1
  br i1 %cmp7, label %if.then8, label %if.end10

if.then8:                                         ; preds = %if.end4
  %8 = load ptr, ptr @PyExc_OSError, align 8
  %call9 = call ptr @PyErr_SetFromErrno(ptr noundef %8)
  store ptr %call9, ptr %retval, align 8
  br label %return

if.end10:                                         ; preds = %if.end4
  %call11 = call ptr @build_itimerspec_ns(ptr noundef %old_value)
  store ptr %call11, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end10, %if.then8, %if.then3, %if.then
  %9 = load ptr, ptr %retval, align 8
  ret ptr %9
}

; Function Attrs: nounwind uwtable
define internal ptr @build_itimerspec_ns(ptr noundef %curr_value) #0 {
entry:
  %retval = alloca ptr, align 8
  %curr_value.addr = alloca ptr, align 8
  %value = alloca i64, align 8
  %interval = alloca i64, align 8
  store ptr %curr_value, ptr %curr_value.addr, align 8
  %0 = load ptr, ptr %curr_value.addr, align 8
  %it_value = getelementptr inbounds %struct.itimerspec, ptr %0, i32 0, i32 1
  %call = call i32 @_PyTime_FromTimespec(ptr noundef %value, ptr noundef %it_value)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %curr_value.addr, align 8
  %it_interval = getelementptr inbounds %struct.itimerspec, ptr %1, i32 0, i32 0
  %call1 = call i32 @_PyTime_FromTimespec(ptr noundef %interval, ptr noundef %it_interval)
  %cmp2 = icmp slt i32 %call1, 0
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  %2 = load i64, ptr %value, align 8
  %3 = load i64, ptr %interval, align 8
  %call5 = call ptr (ptr, ...) @Py_BuildValue(ptr noundef @.str.574, i64 noundef %2, i64 noundef %3)
  store ptr %call5, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end4, %if.then3, %if.then
  %4 = load ptr, ptr %retval, align 8
  ret ptr %4
}

declare i32 @_PyTime_FromTimespec(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @os_timerfd_gettime_impl(ptr noundef %module, i32 noundef %fd) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %curr_value = alloca %struct.itimerspec, align 8
  %result = alloca i32, align 4
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  %call = call ptr @PyEval_SaveThread()
  store ptr %call, ptr %_save, align 8
  %0 = load i32, ptr %fd.addr, align 4
  %call1 = call i32 @timerfd_gettime(i32 noundef %0, ptr noundef %curr_value) #10
  store i32 %call1, ptr %result, align 4
  %1 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %1)
  %2 = load i32, ptr %result, align 4
  %cmp = icmp eq i32 %2, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr @PyExc_OSError, align 8
  %call2 = call ptr @PyErr_SetFromErrno(ptr noundef %3)
  store ptr %call2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %call3 = call ptr @build_itimerspec(ptr noundef %curr_value)
  store ptr %call3, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load ptr, ptr %retval, align 8
  ret ptr %4
}

; Function Attrs: nounwind
declare i32 @timerfd_gettime(i32 noundef, ptr noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @os_timerfd_gettime_ns_impl(ptr noundef %module, i32 noundef %fd) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %curr_value = alloca %struct.itimerspec, align 8
  %result = alloca i32, align 4
  %_save = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  %call = call ptr @PyEval_SaveThread()
  store ptr %call, ptr %_save, align 8
  %0 = load i32, ptr %fd.addr, align 4
  %call1 = call i32 @timerfd_gettime(i32 noundef %0, ptr noundef %curr_value) #10
  store i32 %call1, ptr %result, align 4
  %1 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %1)
  %2 = load i32, ptr %result, align 4
  %cmp = icmp eq i32 %2, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr @PyExc_OSError, align 8
  %call2 = call ptr @PyErr_SetFromErrno(ptr noundef %3)
  store ptr %call2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %call3 = call ptr @build_itimerspec_ns(ptr noundef %curr_value)
  store ptr %call3, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load ptr, ptr %retval, align 8
  ret ptr %4
}

; Function Attrs: nounwind uwtable
define internal i32 @posixmodule_exec(ptr noundef %m) #0 {
entry:
  %op.addr.i122 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca i32, align 4
  %m.addr = alloca ptr, align 8
  %state = alloca ptr, align 8
  %ScandirIteratorType = alloca ptr, align 8
  %ignored = alloca i32, align 4
  %list = alloca ptr, align 8
  %trace = alloca ptr, align 8
  %unicode = alloca ptr, align 8
  store ptr %m, ptr %m.addr, align 8
  %0 = load ptr, ptr %m.addr, align 8
  %call = call ptr @get_posix_state(ptr noundef %0)
  store ptr %call, ptr %state, align 8
  %1 = load ptr, ptr %m.addr, align 8
  %call1 = call ptr @convertenviron()
  %call2 = call i32 @PyModule_Add(ptr noundef %1, ptr noundef @.str.575, ptr noundef %call1)
  %cmp = icmp ne i32 %call2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %m.addr, align 8
  %call3 = call i32 @all_ins(ptr noundef %2)
  %tobool = icmp ne i32 %call3, 0
  br i1 %tobool, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  store i32 -1, ptr %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  %3 = load ptr, ptr %m.addr, align 8
  %call6 = call i32 @setup_confname_tables(ptr noundef %3)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end5
  store i32 -1, ptr %retval, align 4
  br label %return

if.end9:                                          ; preds = %if.end5
  %4 = load ptr, ptr %m.addr, align 8
  %5 = load ptr, ptr @PyExc_OSError, align 8
  %call10 = call i32 @PyModule_AddObjectRef(ptr noundef %4, ptr noundef @.str.576, ptr noundef %5)
  %cmp11 = icmp slt i32 %call10, 0
  br i1 %cmp11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end9
  store i32 -1, ptr %retval, align 4
  br label %return

if.end13:                                         ; preds = %if.end9
  store ptr @.str.577, ptr @waitid_result_desc, align 8
  %call14 = call ptr @PyStructSequence_NewType(ptr noundef @waitid_result_desc)
  %6 = load ptr, ptr %state, align 8
  %WaitidResultType = getelementptr inbounds %struct._posixstate, ptr %6, i32 0, i32 10
  store ptr %call14, ptr %WaitidResultType, align 8
  %7 = load ptr, ptr %m.addr, align 8
  %8 = load ptr, ptr %state, align 8
  %WaitidResultType15 = getelementptr inbounds %struct._posixstate, ptr %8, i32 0, i32 10
  %9 = load ptr, ptr %WaitidResultType15, align 8
  %call16 = call i32 @PyModule_AddObjectRef(ptr noundef %7, ptr noundef @.str.578, ptr noundef %9)
  %cmp17 = icmp slt i32 %call16, 0
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end13
  store i32 -1, ptr %retval, align 4
  br label %return

if.end19:                                         ; preds = %if.end13
  store ptr @.str.579, ptr @stat_result_desc, align 8
  %10 = load ptr, ptr @PyStructSequence_UnnamedField, align 8
  %11 = load ptr, ptr getelementptr inbounds (%struct.PyStructSequence_Desc, ptr @stat_result_desc, i32 0, i32 2), align 8
  %arrayidx = getelementptr %struct.PyStructSequence_Field, ptr %11, i64 7
  %name = getelementptr inbounds %struct.PyStructSequence_Field, ptr %arrayidx, i32 0, i32 0
  store ptr %10, ptr %name, align 8
  %12 = load ptr, ptr @PyStructSequence_UnnamedField, align 8
  %13 = load ptr, ptr getelementptr inbounds (%struct.PyStructSequence_Desc, ptr @stat_result_desc, i32 0, i32 2), align 8
  %arrayidx20 = getelementptr %struct.PyStructSequence_Field, ptr %13, i64 8
  %name21 = getelementptr inbounds %struct.PyStructSequence_Field, ptr %arrayidx20, i32 0, i32 0
  store ptr %12, ptr %name21, align 8
  %14 = load ptr, ptr @PyStructSequence_UnnamedField, align 8
  %15 = load ptr, ptr getelementptr inbounds (%struct.PyStructSequence_Desc, ptr @stat_result_desc, i32 0, i32 2), align 8
  %arrayidx22 = getelementptr %struct.PyStructSequence_Field, ptr %15, i64 9
  %name23 = getelementptr inbounds %struct.PyStructSequence_Field, ptr %arrayidx22, i32 0, i32 0
  store ptr %14, ptr %name23, align 8
  %call24 = call ptr @PyStructSequence_NewType(ptr noundef @stat_result_desc)
  %16 = load ptr, ptr %state, align 8
  %StatResultType = getelementptr inbounds %struct._posixstate, ptr %16, i32 0, i32 5
  store ptr %call24, ptr %StatResultType, align 8
  %17 = load ptr, ptr %m.addr, align 8
  %18 = load ptr, ptr %state, align 8
  %StatResultType25 = getelementptr inbounds %struct._posixstate, ptr %18, i32 0, i32 5
  %19 = load ptr, ptr %StatResultType25, align 8
  %call26 = call i32 @PyModule_AddObjectRef(ptr noundef %17, ptr noundef @.str.580, ptr noundef %19)
  %cmp27 = icmp slt i32 %call26, 0
  br i1 %cmp27, label %if.then28, label %if.end29

if.then28:                                        ; preds = %if.end19
  store i32 -1, ptr %retval, align 4
  br label %return

if.end29:                                         ; preds = %if.end19
  %20 = load ptr, ptr %state, align 8
  %StatResultType30 = getelementptr inbounds %struct._posixstate, ptr %20, i32 0, i32 5
  %21 = load ptr, ptr %StatResultType30, align 8
  %tp_new = getelementptr inbounds %struct._typeobject, ptr %21, i32 0, i32 37
  %22 = load ptr, ptr %tp_new, align 8
  %23 = load ptr, ptr %state, align 8
  %statresult_new_orig = getelementptr inbounds %struct._posixstate, ptr %23, i32 0, i32 4
  store ptr %22, ptr %statresult_new_orig, align 8
  %24 = load ptr, ptr %state, align 8
  %StatResultType31 = getelementptr inbounds %struct._posixstate, ptr %24, i32 0, i32 5
  %25 = load ptr, ptr %StatResultType31, align 8
  %tp_new32 = getelementptr inbounds %struct._typeobject, ptr %25, i32 0, i32 37
  store ptr @statresult_new, ptr %tp_new32, align 8
  store ptr @.str.581, ptr @statvfs_result_desc, align 8
  %call33 = call ptr @PyStructSequence_NewType(ptr noundef @statvfs_result_desc)
  %26 = load ptr, ptr %state, align 8
  %StatVFSResultType = getelementptr inbounds %struct._posixstate, ptr %26, i32 0, i32 6
  store ptr %call33, ptr %StatVFSResultType, align 8
  %27 = load ptr, ptr %m.addr, align 8
  %28 = load ptr, ptr %state, align 8
  %StatVFSResultType34 = getelementptr inbounds %struct._posixstate, ptr %28, i32 0, i32 6
  %29 = load ptr, ptr %StatVFSResultType34, align 8
  %call35 = call i32 @PyModule_AddObjectRef(ptr noundef %27, ptr noundef @.str.582, ptr noundef %29)
  %cmp36 = icmp slt i32 %call35, 0
  br i1 %cmp36, label %if.then37, label %if.end38

if.then37:                                        ; preds = %if.end29
  store i32 -1, ptr %retval, align 4
  br label %return

if.end38:                                         ; preds = %if.end29
  store ptr @.str.583, ptr @sched_param_desc, align 8
  %call39 = call ptr @PyStructSequence_NewType(ptr noundef @sched_param_desc)
  %30 = load ptr, ptr %state, align 8
  %SchedParamType = getelementptr inbounds %struct._posixstate, ptr %30, i32 0, i32 3
  store ptr %call39, ptr %SchedParamType, align 8
  %31 = load ptr, ptr %m.addr, align 8
  %32 = load ptr, ptr %state, align 8
  %SchedParamType40 = getelementptr inbounds %struct._posixstate, ptr %32, i32 0, i32 3
  %33 = load ptr, ptr %SchedParamType40, align 8
  %call41 = call i32 @PyModule_AddObjectRef(ptr noundef %31, ptr noundef @.str.584, ptr noundef %33)
  %cmp42 = icmp slt i32 %call41, 0
  br i1 %cmp42, label %if.then43, label %if.end44

if.then43:                                        ; preds = %if.end38
  store i32 -1, ptr %retval, align 4
  br label %return

if.end44:                                         ; preds = %if.end38
  %34 = load ptr, ptr %state, align 8
  %SchedParamType45 = getelementptr inbounds %struct._posixstate, ptr %34, i32 0, i32 3
  %35 = load ptr, ptr %SchedParamType45, align 8
  %tp_new46 = getelementptr inbounds %struct._typeobject, ptr %35, i32 0, i32 37
  store ptr @os_sched_param, ptr %tp_new46, align 8
  %call47 = call ptr @PyStructSequence_NewType(ptr noundef @TerminalSize_desc)
  %36 = load ptr, ptr %state, align 8
  %TerminalSizeType = getelementptr inbounds %struct._posixstate, ptr %36, i32 0, i32 7
  store ptr %call47, ptr %TerminalSizeType, align 8
  %37 = load ptr, ptr %m.addr, align 8
  %38 = load ptr, ptr %state, align 8
  %TerminalSizeType48 = getelementptr inbounds %struct._posixstate, ptr %38, i32 0, i32 7
  %39 = load ptr, ptr %TerminalSizeType48, align 8
  %call49 = call i32 @PyModule_AddObjectRef(ptr noundef %37, ptr noundef @.str.585, ptr noundef %39)
  %cmp50 = icmp slt i32 %call49, 0
  br i1 %cmp50, label %if.then51, label %if.end52

if.then51:                                        ; preds = %if.end44
  store i32 -1, ptr %retval, align 4
  br label %return

if.end52:                                         ; preds = %if.end44
  %40 = load ptr, ptr %m.addr, align 8
  %call53 = call ptr @PyType_FromModuleAndSpec(ptr noundef %40, ptr noundef @ScandirIteratorType_spec, ptr noundef null)
  store ptr %call53, ptr %ScandirIteratorType, align 8
  %41 = load ptr, ptr %ScandirIteratorType, align 8
  %cmp54 = icmp eq ptr %41, null
  br i1 %cmp54, label %if.then55, label %if.end56

if.then55:                                        ; preds = %if.end52
  store i32 -1, ptr %retval, align 4
  br label %return

if.end56:                                         ; preds = %if.end52
  %42 = load ptr, ptr %ScandirIteratorType, align 8
  %43 = load ptr, ptr %state, align 8
  %ScandirIteratorType57 = getelementptr inbounds %struct._posixstate, ptr %43, i32 0, i32 2
  store ptr %42, ptr %ScandirIteratorType57, align 8
  %44 = load ptr, ptr %m.addr, align 8
  %call58 = call ptr @PyType_FromModuleAndSpec(ptr noundef %44, ptr noundef @DirEntryType_spec, ptr noundef null)
  %45 = load ptr, ptr %state, align 8
  %DirEntryType = getelementptr inbounds %struct._posixstate, ptr %45, i32 0, i32 1
  store ptr %call58, ptr %DirEntryType, align 8
  %46 = load ptr, ptr %m.addr, align 8
  %47 = load ptr, ptr %state, align 8
  %DirEntryType59 = getelementptr inbounds %struct._posixstate, ptr %47, i32 0, i32 1
  %48 = load ptr, ptr %DirEntryType59, align 8
  %call60 = call i32 @PyModule_AddObjectRef(ptr noundef %46, ptr noundef @.str.586, ptr noundef %48)
  %cmp61 = icmp slt i32 %call60, 0
  br i1 %cmp61, label %if.then62, label %if.end63

if.then62:                                        ; preds = %if.end56
  store i32 -1, ptr %retval, align 4
  br label %return

if.end63:                                         ; preds = %if.end56
  store ptr @.str.587, ptr @times_result_desc, align 8
  %call64 = call ptr @PyStructSequence_NewType(ptr noundef @times_result_desc)
  %49 = load ptr, ptr %state, align 8
  %TimesResultType = getelementptr inbounds %struct._posixstate, ptr %49, i32 0, i32 8
  store ptr %call64, ptr %TimesResultType, align 8
  %50 = load ptr, ptr %m.addr, align 8
  %51 = load ptr, ptr %state, align 8
  %TimesResultType65 = getelementptr inbounds %struct._posixstate, ptr %51, i32 0, i32 8
  %52 = load ptr, ptr %TimesResultType65, align 8
  %call66 = call i32 @PyModule_AddObjectRef(ptr noundef %50, ptr noundef @.str.588, ptr noundef %52)
  %cmp67 = icmp slt i32 %call66, 0
  br i1 %cmp67, label %if.then68, label %if.end69

if.then68:                                        ; preds = %if.end63
  store i32 -1, ptr %retval, align 4
  br label %return

if.end69:                                         ; preds = %if.end63
  %call70 = call ptr @PyStructSequence_NewType(ptr noundef @uname_result_desc)
  %53 = load ptr, ptr %state, align 8
  %UnameResultType = getelementptr inbounds %struct._posixstate, ptr %53, i32 0, i32 9
  store ptr %call70, ptr %UnameResultType, align 8
  %54 = load ptr, ptr %m.addr, align 8
  %55 = load ptr, ptr %state, align 8
  %UnameResultType71 = getelementptr inbounds %struct._posixstate, ptr %55, i32 0, i32 9
  %56 = load ptr, ptr %UnameResultType71, align 8
  %call72 = call i32 @PyModule_AddObjectRef(ptr noundef %54, ptr noundef @.str.589, ptr noundef %56)
  %cmp73 = icmp slt i32 %call72, 0
  br i1 %cmp73, label %if.then74, label %if.end75

if.then74:                                        ; preds = %if.end69
  store i32 -1, ptr %retval, align 4
  br label %return

if.end75:                                         ; preds = %if.end69
  %call76 = call ptr @PyLong_FromLong(i64 noundef 1000000000)
  %57 = load ptr, ptr %state, align 8
  %billion = getelementptr inbounds %struct._posixstate, ptr %57, i32 0, i32 0
  store ptr %call76, ptr %billion, align 8
  %cmp77 = icmp eq ptr %call76, null
  br i1 %cmp77, label %if.then78, label %if.end79

if.then78:                                        ; preds = %if.end75
  store i32 -1, ptr %retval, align 4
  br label %return

if.end79:                                         ; preds = %if.end75
  %call80 = call ptr @PyUnicode_InternFromString(ptr noundef @.str.335)
  %58 = load ptr, ptr %state, align 8
  %struct_rusage = getelementptr inbounds %struct._posixstate, ptr %58, i32 0, i32 11
  store ptr %call80, ptr %struct_rusage, align 8
  %59 = load ptr, ptr %state, align 8
  %struct_rusage81 = getelementptr inbounds %struct._posixstate, ptr %59, i32 0, i32 11
  %60 = load ptr, ptr %struct_rusage81, align 8
  %cmp82 = icmp eq ptr %60, null
  br i1 %cmp82, label %if.then83, label %if.end84

if.then83:                                        ; preds = %if.end79
  store i32 -1, ptr %retval, align 4
  br label %return

if.end84:                                         ; preds = %if.end79
  %call85 = call ptr @PyUnicode_InternFromString(ptr noundef @.str.590)
  %61 = load ptr, ptr %state, align 8
  %st_mode = getelementptr inbounds %struct._posixstate, ptr %61, i32 0, i32 12
  store ptr %call85, ptr %st_mode, align 8
  %62 = load ptr, ptr %state, align 8
  %st_mode86 = getelementptr inbounds %struct._posixstate, ptr %62, i32 0, i32 12
  %63 = load ptr, ptr %st_mode86, align 8
  %cmp87 = icmp eq ptr %63, null
  br i1 %cmp87, label %if.then88, label %if.end89

if.then88:                                        ; preds = %if.end84
  store i32 -1, ptr %retval, align 4
  br label %return

if.end89:                                         ; preds = %if.end84
  %call90 = call i32 @fd_specified(ptr noundef @.str.187, i32 noundef -1)
  %call91 = call i32 @follow_symlinks_specified(ptr noundef @.str.187, i32 noundef 1)
  %call92 = call i32 @dir_fd_and_follow_symlinks_invalid(ptr noundef @.str.16, i32 noundef -100, i32 noundef 1)
  %call93 = call i32 @dir_fd_converter(ptr noundef @_Py_NoneStruct, ptr noundef %ignored)
  %call94 = call i32 @dir_fd_unavailable(ptr noundef @_Py_NoneStruct, ptr noundef %ignored)
  %call95 = call ptr @PyList_New(i64 noundef 0)
  store ptr %call95, ptr %list, align 8
  %64 = load ptr, ptr %list, align 8
  %tobool96 = icmp ne ptr %64, null
  br i1 %tobool96, label %if.end98, label %if.then97

if.then97:                                        ; preds = %if.end89
  store i32 -1, ptr %retval, align 4
  br label %return

if.end98:                                         ; preds = %if.end89
  store ptr @have_functions, ptr %trace, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end98
  %65 = load ptr, ptr %trace, align 8
  %label = getelementptr inbounds %struct.have_function, ptr %65, i32 0, i32 0
  %66 = load ptr, ptr %label, align 8
  %tobool99 = icmp ne ptr %66, null
  br i1 %tobool99, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %67 = load ptr, ptr %trace, align 8
  %probe = getelementptr inbounds %struct.have_function, ptr %67, i32 0, i32 1
  %68 = load ptr, ptr %probe, align 8
  %tobool100 = icmp ne ptr %68, null
  br i1 %tobool100, label %land.lhs.true, label %if.end105

land.lhs.true:                                    ; preds = %for.body
  %69 = load ptr, ptr %trace, align 8
  %probe101 = getelementptr inbounds %struct.have_function, ptr %69, i32 0, i32 1
  %70 = load ptr, ptr %probe101, align 8
  %call102 = call i32 %70()
  %tobool103 = icmp ne i32 %call102, 0
  br i1 %tobool103, label %if.end105, label %if.then104

if.then104:                                       ; preds = %land.lhs.true
  br label %for.inc

if.end105:                                        ; preds = %land.lhs.true, %for.body
  %71 = load ptr, ptr %trace, align 8
  %label106 = getelementptr inbounds %struct.have_function, ptr %71, i32 0, i32 0
  %72 = load ptr, ptr %label106, align 8
  %73 = load ptr, ptr %trace, align 8
  %label107 = getelementptr inbounds %struct.have_function, ptr %73, i32 0, i32 0
  %74 = load ptr, ptr %label107, align 8
  %call108 = call i64 @strlen(ptr noundef %74) #13
  %call109 = call ptr @PyUnicode_DecodeASCII(ptr noundef %72, i64 noundef %call108, ptr noundef null)
  store ptr %call109, ptr %unicode, align 8
  %75 = load ptr, ptr %unicode, align 8
  %tobool110 = icmp ne ptr %75, null
  br i1 %tobool110, label %if.end112, label %if.then111

if.then111:                                       ; preds = %if.end105
  store i32 -1, ptr %retval, align 4
  br label %return

if.end112:                                        ; preds = %if.end105
  %76 = load ptr, ptr %list, align 8
  %77 = load ptr, ptr %unicode, align 8
  %call113 = call i32 @PyList_Append(ptr noundef %76, ptr noundef %77)
  %tobool114 = icmp ne i32 %call113, 0
  br i1 %tobool114, label %if.then115, label %if.end116

if.then115:                                       ; preds = %if.end112
  store i32 -1, ptr %retval, align 4
  br label %return

if.end116:                                        ; preds = %if.end112
  %78 = load ptr, ptr %unicode, align 8
  store ptr %78, ptr %op.addr.i, align 8
  %79 = load ptr, ptr %op.addr.i, align 8
  store ptr %79, ptr %op.addr.i122, align 8
  %80 = load ptr, ptr %op.addr.i122, align 8
  %81 = load i64, ptr %80, align 8
  %conv.i = trunc i64 %81 to i32
  %cmp.i123 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i123 to i32
  %tobool.i = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.end116
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.end116
  %82 = load ptr, ptr %op.addr.i, align 8
  %83 = load i64, ptr %82, align 8
  %dec.i = add i64 %83, -1
  store i64 %dec.i, ptr %82, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %84 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %84) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  br label %for.inc

for.inc:                                          ; preds = %Py_DECREF.exit, %if.then104
  %85 = load ptr, ptr %trace, align 8
  %incdec.ptr = getelementptr %struct.have_function, ptr %85, i32 1
  store ptr %incdec.ptr, ptr %trace, align 8
  br label %for.cond, !llvm.loop !51

for.end:                                          ; preds = %for.cond
  %86 = load ptr, ptr %state, align 8
  %ticks_per_second = getelementptr inbounds %struct._posixstate, ptr %86, i32 0, i32 13
  %call117 = call i32 @_Py_GetTicksPerSecond(ptr noundef %ticks_per_second)
  %cmp118 = icmp slt i32 %call117, 0
  br i1 %cmp118, label %if.then119, label %if.end120

if.then119:                                       ; preds = %for.end
  %87 = load ptr, ptr @PyExc_RuntimeError, align 8
  call void @PyErr_SetString(ptr noundef %87, ptr noundef @.str.591)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end120:                                        ; preds = %for.end
  %88 = load ptr, ptr %m.addr, align 8
  %89 = load ptr, ptr %list, align 8
  %call121 = call i32 @PyModule_Add(ptr noundef %88, ptr noundef @.str.592, ptr noundef %89)
  store i32 %call121, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end120, %if.then119, %if.then115, %if.then111, %if.then97, %if.then88, %if.then83, %if.then78, %if.then74, %if.then68, %if.then62, %if.then55, %if.then51, %if.then43, %if.then37, %if.then28, %if.then18, %if.then12, %if.then8, %if.then4, %if.then
  %90 = load i32, ptr %retval, align 4
  ret i32 %90
}

declare i32 @PyModule_Add(ptr noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @convertenviron() #0 {
entry:
  %op.addr.i116 = alloca ptr, align 8
  %op.addr.i112 = alloca ptr, align 8
  %op.addr.i108 = alloca ptr, align 8
  %op.addr.i104 = alloca ptr, align 8
  %op.addr.i100 = alloca ptr, align 8
  %op.addr.i96 = alloca ptr, align 8
  %op.addr.i92 = alloca ptr, align 8
  %op.addr.i90 = alloca ptr, align 8
  %op.addr.i81 = alloca ptr, align 8
  %op.addr.i72 = alloca ptr, align 8
  %op.addr.i63 = alloca ptr, align 8
  %op.addr.i54 = alloca ptr, align 8
  %op.addr.i45 = alloca ptr, align 8
  %op.addr.i36 = alloca ptr, align 8
  %op.addr.i27 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %d = alloca ptr, align 8
  %e = alloca ptr, align 8
  %k = alloca ptr, align 8
  %v = alloca ptr, align 8
  %p = alloca ptr, align 8
  %call = call ptr @PyDict_New()
  store ptr %call, ptr %d, align 8
  %0 = load ptr, ptr %d, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr @environ, align 8
  store ptr %1, ptr %e, align 8
  %2 = load ptr, ptr %e, align 8
  %cmp1 = icmp eq ptr %2, null
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %3 = load ptr, ptr %d, align 8
  store ptr %3, ptr %retval, align 8
  br label %return

if.end3:                                          ; preds = %if.end
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end3
  %4 = load ptr, ptr %e, align 8
  %5 = load ptr, ptr %4, align 8
  %cmp4 = icmp ne ptr %5, null
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load ptr, ptr %e, align 8
  %7 = load ptr, ptr %6, align 8
  %call5 = call ptr @strchr(ptr noundef %7, i32 noundef 61) #13
  store ptr %call5, ptr %p, align 8
  %8 = load ptr, ptr %p, align 8
  %cmp6 = icmp eq ptr %8, null
  br i1 %cmp6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %for.body
  br label %for.inc

if.end8:                                          ; preds = %for.body
  %9 = load ptr, ptr %e, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %p, align 8
  %12 = load ptr, ptr %e, align 8
  %13 = load ptr, ptr %12, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %11 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %13 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv = trunc i64 %sub.ptr.sub to i32
  %conv9 = sext i32 %conv to i64
  %call10 = call ptr @PyBytes_FromStringAndSize(ptr noundef %10, i64 noundef %conv9)
  store ptr %call10, ptr %k, align 8
  %14 = load ptr, ptr %k, align 8
  %cmp11 = icmp eq ptr %14, null
  br i1 %cmp11, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end8
  %15 = load ptr, ptr %d, align 8
  store ptr %15, ptr %op.addr.i81, align 8
  %16 = load ptr, ptr %op.addr.i81, align 8
  store ptr %16, ptr %op.addr.i90, align 8
  %17 = load ptr, ptr %op.addr.i90, align 8
  %18 = load i64, ptr %17, align 8
  %conv.i = trunc i64 %18 to i32
  %cmp.i91 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i91 to i32
  %tobool.i83 = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i83, label %if.then.i88, label %if.end.i84

if.then.i88:                                      ; preds = %if.then13
  br label %Py_DECREF.exit89

if.end.i84:                                       ; preds = %if.then13
  %19 = load ptr, ptr %op.addr.i81, align 8
  %20 = load i64, ptr %19, align 8
  %dec.i85 = add i64 %20, -1
  store i64 %dec.i85, ptr %19, align 8
  %cmp.i86 = icmp eq i64 %dec.i85, 0
  br i1 %cmp.i86, label %if.then1.i87, label %Py_DECREF.exit89

if.then1.i87:                                     ; preds = %if.end.i84
  %21 = load ptr, ptr %op.addr.i81, align 8
  call void @_Py_Dealloc(ptr noundef %21) #10
  br label %Py_DECREF.exit89

Py_DECREF.exit89:                                 ; preds = %if.then1.i87, %if.end.i84, %if.then.i88
  store ptr null, ptr %retval, align 8
  br label %return

if.end14:                                         ; preds = %if.end8
  %22 = load ptr, ptr %p, align 8
  %add.ptr = getelementptr i8, ptr %22, i64 1
  %23 = load ptr, ptr %p, align 8
  %add.ptr15 = getelementptr i8, ptr %23, i64 1
  %call16 = call i64 @strlen(ptr noundef %add.ptr15) #13
  %call17 = call ptr @PyBytes_FromStringAndSize(ptr noundef %add.ptr, i64 noundef %call16)
  store ptr %call17, ptr %v, align 8
  %24 = load ptr, ptr %v, align 8
  %cmp18 = icmp eq ptr %24, null
  br i1 %cmp18, label %if.then20, label %if.end21

if.then20:                                        ; preds = %if.end14
  %25 = load ptr, ptr %k, align 8
  store ptr %25, ptr %op.addr.i72, align 8
  %26 = load ptr, ptr %op.addr.i72, align 8
  store ptr %26, ptr %op.addr.i92, align 8
  %27 = load ptr, ptr %op.addr.i92, align 8
  %28 = load i64, ptr %27, align 8
  %conv.i93 = trunc i64 %28 to i32
  %cmp.i94 = icmp slt i32 %conv.i93, 0
  %conv1.i95 = zext i1 %cmp.i94 to i32
  %tobool.i74 = icmp ne i32 %conv1.i95, 0
  br i1 %tobool.i74, label %if.then.i79, label %if.end.i75

if.then.i79:                                      ; preds = %if.then20
  br label %Py_DECREF.exit80

if.end.i75:                                       ; preds = %if.then20
  %29 = load ptr, ptr %op.addr.i72, align 8
  %30 = load i64, ptr %29, align 8
  %dec.i76 = add i64 %30, -1
  store i64 %dec.i76, ptr %29, align 8
  %cmp.i77 = icmp eq i64 %dec.i76, 0
  br i1 %cmp.i77, label %if.then1.i78, label %Py_DECREF.exit80

if.then1.i78:                                     ; preds = %if.end.i75
  %31 = load ptr, ptr %op.addr.i72, align 8
  call void @_Py_Dealloc(ptr noundef %31) #10
  br label %Py_DECREF.exit80

Py_DECREF.exit80:                                 ; preds = %if.then1.i78, %if.end.i75, %if.then.i79
  %32 = load ptr, ptr %d, align 8
  store ptr %32, ptr %op.addr.i63, align 8
  %33 = load ptr, ptr %op.addr.i63, align 8
  store ptr %33, ptr %op.addr.i96, align 8
  %34 = load ptr, ptr %op.addr.i96, align 8
  %35 = load i64, ptr %34, align 8
  %conv.i97 = trunc i64 %35 to i32
  %cmp.i98 = icmp slt i32 %conv.i97, 0
  %conv1.i99 = zext i1 %cmp.i98 to i32
  %tobool.i65 = icmp ne i32 %conv1.i99, 0
  br i1 %tobool.i65, label %if.then.i70, label %if.end.i66

if.then.i70:                                      ; preds = %Py_DECREF.exit80
  br label %Py_DECREF.exit71

if.end.i66:                                       ; preds = %Py_DECREF.exit80
  %36 = load ptr, ptr %op.addr.i63, align 8
  %37 = load i64, ptr %36, align 8
  %dec.i67 = add i64 %37, -1
  store i64 %dec.i67, ptr %36, align 8
  %cmp.i68 = icmp eq i64 %dec.i67, 0
  br i1 %cmp.i68, label %if.then1.i69, label %Py_DECREF.exit71

if.then1.i69:                                     ; preds = %if.end.i66
  %38 = load ptr, ptr %op.addr.i63, align 8
  call void @_Py_Dealloc(ptr noundef %38) #10
  br label %Py_DECREF.exit71

Py_DECREF.exit71:                                 ; preds = %if.then1.i69, %if.end.i66, %if.then.i70
  store ptr null, ptr %retval, align 8
  br label %return

if.end21:                                         ; preds = %if.end14
  %39 = load ptr, ptr %d, align 8
  %40 = load ptr, ptr %k, align 8
  %41 = load ptr, ptr %v, align 8
  %call22 = call ptr @PyDict_SetDefault(ptr noundef %39, ptr noundef %40, ptr noundef %41)
  %cmp23 = icmp eq ptr %call22, null
  br i1 %cmp23, label %if.then25, label %if.end26

if.then25:                                        ; preds = %if.end21
  %42 = load ptr, ptr %v, align 8
  store ptr %42, ptr %op.addr.i54, align 8
  %43 = load ptr, ptr %op.addr.i54, align 8
  store ptr %43, ptr %op.addr.i100, align 8
  %44 = load ptr, ptr %op.addr.i100, align 8
  %45 = load i64, ptr %44, align 8
  %conv.i101 = trunc i64 %45 to i32
  %cmp.i102 = icmp slt i32 %conv.i101, 0
  %conv1.i103 = zext i1 %cmp.i102 to i32
  %tobool.i56 = icmp ne i32 %conv1.i103, 0
  br i1 %tobool.i56, label %if.then.i61, label %if.end.i57

if.then.i61:                                      ; preds = %if.then25
  br label %Py_DECREF.exit62

if.end.i57:                                       ; preds = %if.then25
  %46 = load ptr, ptr %op.addr.i54, align 8
  %47 = load i64, ptr %46, align 8
  %dec.i58 = add i64 %47, -1
  store i64 %dec.i58, ptr %46, align 8
  %cmp.i59 = icmp eq i64 %dec.i58, 0
  br i1 %cmp.i59, label %if.then1.i60, label %Py_DECREF.exit62

if.then1.i60:                                     ; preds = %if.end.i57
  %48 = load ptr, ptr %op.addr.i54, align 8
  call void @_Py_Dealloc(ptr noundef %48) #10
  br label %Py_DECREF.exit62

Py_DECREF.exit62:                                 ; preds = %if.then1.i60, %if.end.i57, %if.then.i61
  %49 = load ptr, ptr %k, align 8
  store ptr %49, ptr %op.addr.i45, align 8
  %50 = load ptr, ptr %op.addr.i45, align 8
  store ptr %50, ptr %op.addr.i104, align 8
  %51 = load ptr, ptr %op.addr.i104, align 8
  %52 = load i64, ptr %51, align 8
  %conv.i105 = trunc i64 %52 to i32
  %cmp.i106 = icmp slt i32 %conv.i105, 0
  %conv1.i107 = zext i1 %cmp.i106 to i32
  %tobool.i47 = icmp ne i32 %conv1.i107, 0
  br i1 %tobool.i47, label %if.then.i52, label %if.end.i48

if.then.i52:                                      ; preds = %Py_DECREF.exit62
  br label %Py_DECREF.exit53

if.end.i48:                                       ; preds = %Py_DECREF.exit62
  %53 = load ptr, ptr %op.addr.i45, align 8
  %54 = load i64, ptr %53, align 8
  %dec.i49 = add i64 %54, -1
  store i64 %dec.i49, ptr %53, align 8
  %cmp.i50 = icmp eq i64 %dec.i49, 0
  br i1 %cmp.i50, label %if.then1.i51, label %Py_DECREF.exit53

if.then1.i51:                                     ; preds = %if.end.i48
  %55 = load ptr, ptr %op.addr.i45, align 8
  call void @_Py_Dealloc(ptr noundef %55) #10
  br label %Py_DECREF.exit53

Py_DECREF.exit53:                                 ; preds = %if.then1.i51, %if.end.i48, %if.then.i52
  %56 = load ptr, ptr %d, align 8
  store ptr %56, ptr %op.addr.i36, align 8
  %57 = load ptr, ptr %op.addr.i36, align 8
  store ptr %57, ptr %op.addr.i108, align 8
  %58 = load ptr, ptr %op.addr.i108, align 8
  %59 = load i64, ptr %58, align 8
  %conv.i109 = trunc i64 %59 to i32
  %cmp.i110 = icmp slt i32 %conv.i109, 0
  %conv1.i111 = zext i1 %cmp.i110 to i32
  %tobool.i38 = icmp ne i32 %conv1.i111, 0
  br i1 %tobool.i38, label %if.then.i43, label %if.end.i39

if.then.i43:                                      ; preds = %Py_DECREF.exit53
  br label %Py_DECREF.exit44

if.end.i39:                                       ; preds = %Py_DECREF.exit53
  %60 = load ptr, ptr %op.addr.i36, align 8
  %61 = load i64, ptr %60, align 8
  %dec.i40 = add i64 %61, -1
  store i64 %dec.i40, ptr %60, align 8
  %cmp.i41 = icmp eq i64 %dec.i40, 0
  br i1 %cmp.i41, label %if.then1.i42, label %Py_DECREF.exit44

if.then1.i42:                                     ; preds = %if.end.i39
  %62 = load ptr, ptr %op.addr.i36, align 8
  call void @_Py_Dealloc(ptr noundef %62) #10
  br label %Py_DECREF.exit44

Py_DECREF.exit44:                                 ; preds = %if.then1.i42, %if.end.i39, %if.then.i43
  store ptr null, ptr %retval, align 8
  br label %return

if.end26:                                         ; preds = %if.end21
  %63 = load ptr, ptr %k, align 8
  store ptr %63, ptr %op.addr.i27, align 8
  %64 = load ptr, ptr %op.addr.i27, align 8
  store ptr %64, ptr %op.addr.i112, align 8
  %65 = load ptr, ptr %op.addr.i112, align 8
  %66 = load i64, ptr %65, align 8
  %conv.i113 = trunc i64 %66 to i32
  %cmp.i114 = icmp slt i32 %conv.i113, 0
  %conv1.i115 = zext i1 %cmp.i114 to i32
  %tobool.i29 = icmp ne i32 %conv1.i115, 0
  br i1 %tobool.i29, label %if.then.i34, label %if.end.i30

if.then.i34:                                      ; preds = %if.end26
  br label %Py_DECREF.exit35

if.end.i30:                                       ; preds = %if.end26
  %67 = load ptr, ptr %op.addr.i27, align 8
  %68 = load i64, ptr %67, align 8
  %dec.i31 = add i64 %68, -1
  store i64 %dec.i31, ptr %67, align 8
  %cmp.i32 = icmp eq i64 %dec.i31, 0
  br i1 %cmp.i32, label %if.then1.i33, label %Py_DECREF.exit35

if.then1.i33:                                     ; preds = %if.end.i30
  %69 = load ptr, ptr %op.addr.i27, align 8
  call void @_Py_Dealloc(ptr noundef %69) #10
  br label %Py_DECREF.exit35

Py_DECREF.exit35:                                 ; preds = %if.then1.i33, %if.end.i30, %if.then.i34
  %70 = load ptr, ptr %v, align 8
  store ptr %70, ptr %op.addr.i, align 8
  %71 = load ptr, ptr %op.addr.i, align 8
  store ptr %71, ptr %op.addr.i116, align 8
  %72 = load ptr, ptr %op.addr.i116, align 8
  %73 = load i64, ptr %72, align 8
  %conv.i117 = trunc i64 %73 to i32
  %cmp.i118 = icmp slt i32 %conv.i117, 0
  %conv1.i119 = zext i1 %cmp.i118 to i32
  %tobool.i = icmp ne i32 %conv1.i119, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %Py_DECREF.exit35
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %Py_DECREF.exit35
  %74 = load ptr, ptr %op.addr.i, align 8
  %75 = load i64, ptr %74, align 8
  %dec.i = add i64 %75, -1
  store i64 %dec.i, ptr %74, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %76 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %76) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  br label %for.inc

for.inc:                                          ; preds = %Py_DECREF.exit, %if.then7
  %77 = load ptr, ptr %e, align 8
  %incdec.ptr = getelementptr ptr, ptr %77, i32 1
  store ptr %incdec.ptr, ptr %e, align 8
  br label %for.cond, !llvm.loop !52

for.end:                                          ; preds = %for.cond
  %78 = load ptr, ptr %d, align 8
  store ptr %78, ptr %retval, align 8
  br label %return

return:                                           ; preds = %for.end, %Py_DECREF.exit44, %Py_DECREF.exit71, %Py_DECREF.exit89, %if.then2, %if.then
  %79 = load ptr, ptr %retval, align 8
  ret ptr %79
}

; Function Attrs: nounwind uwtable
define internal i32 @all_ins(ptr noundef %m) #0 {
entry:
  %retval = alloca i32, align 4
  %m.addr = alloca ptr, align 8
  store ptr %m, ptr %m.addr, align 8
  %0 = load ptr, ptr %m.addr, align 8
  %call = call i32 @PyModule_AddIntConstant(ptr noundef %0, ptr noundef @.str.593, i64 noundef 0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %m.addr, align 8
  %call1 = call i32 @PyModule_AddIntConstant(ptr noundef %1, ptr noundef @.str.594, i64 noundef 4)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store i32 -1, ptr %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  %2 = load ptr, ptr %m.addr, align 8
  %call5 = call i32 @PyModule_AddIntConstant(ptr noundef %2, ptr noundef @.str.595, i64 noundef 2)
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end4
  store i32 -1, ptr %retval, align 4
  br label %return

if.end8:                                          ; preds = %if.end4
  %3 = load ptr, ptr %m.addr, align 8
  %call9 = call i32 @PyModule_AddIntConstant(ptr noundef %3, ptr noundef @.str.596, i64 noundef 1)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end8
  store i32 -1, ptr %retval, align 4
  br label %return

if.end12:                                         ; preds = %if.end8
  %4 = load ptr, ptr %m.addr, align 8
  %call13 = call i32 @PyModule_AddIntConstant(ptr noundef %4, ptr noundef @.str.597, i64 noundef 65536)
  %tobool14 = icmp ne i32 %call13, 0
  br i1 %tobool14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.end12
  store i32 -1, ptr %retval, align 4
  br label %return

if.end16:                                         ; preds = %if.end12
  %5 = load ptr, ptr %m.addr, align 8
  %call17 = call i32 @PyModule_AddIntConstant(ptr noundef %5, ptr noundef @.str.598, i64 noundef 238328)
  %tobool18 = icmp ne i32 %call17, 0
  br i1 %tobool18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %if.end16
  store i32 -1, ptr %retval, align 4
  br label %return

if.end20:                                         ; preds = %if.end16
  %6 = load ptr, ptr %m.addr, align 8
  %call21 = call i32 @PyModule_AddIntConstant(ptr noundef %6, ptr noundef @.str.599, i64 noundef 8)
  %tobool22 = icmp ne i32 %call21, 0
  br i1 %tobool22, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.end20
  store i32 -1, ptr %retval, align 4
  br label %return

if.end24:                                         ; preds = %if.end20
  %7 = load ptr, ptr %m.addr, align 8
  %call25 = call i32 @PyModule_AddIntConstant(ptr noundef %7, ptr noundef @.str.600, i64 noundef 1)
  %tobool26 = icmp ne i32 %call25, 0
  br i1 %tobool26, label %if.then27, label %if.end28

if.then27:                                        ; preds = %if.end24
  store i32 -1, ptr %retval, align 4
  br label %return

if.end28:                                         ; preds = %if.end24
  %8 = load ptr, ptr %m.addr, align 8
  %call29 = call i32 @PyModule_AddIntConstant(ptr noundef %8, ptr noundef @.str.601, i64 noundef 2)
  %tobool30 = icmp ne i32 %call29, 0
  br i1 %tobool30, label %if.then31, label %if.end32

if.then31:                                        ; preds = %if.end28
  store i32 -1, ptr %retval, align 4
  br label %return

if.end32:                                         ; preds = %if.end28
  %9 = load ptr, ptr %m.addr, align 8
  %call33 = call i32 @PyModule_AddIntConstant(ptr noundef %9, ptr noundef @.str.602, i64 noundef 0)
  %tobool34 = icmp ne i32 %call33, 0
  br i1 %tobool34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %if.end32
  store i32 -1, ptr %retval, align 4
  br label %return

if.end36:                                         ; preds = %if.end32
  %10 = load ptr, ptr %m.addr, align 8
  %call37 = call i32 @PyModule_AddIntConstant(ptr noundef %10, ptr noundef @.str.603, i64 noundef 1)
  %tobool38 = icmp ne i32 %call37, 0
  br i1 %tobool38, label %if.then39, label %if.end40

if.then39:                                        ; preds = %if.end36
  store i32 -1, ptr %retval, align 4
  br label %return

if.end40:                                         ; preds = %if.end36
  %11 = load ptr, ptr %m.addr, align 8
  %call41 = call i32 @PyModule_AddIntConstant(ptr noundef %11, ptr noundef @.str.604, i64 noundef 2)
  %tobool42 = icmp ne i32 %call41, 0
  br i1 %tobool42, label %if.then43, label %if.end44

if.then43:                                        ; preds = %if.end40
  store i32 -1, ptr %retval, align 4
  br label %return

if.end44:                                         ; preds = %if.end40
  %12 = load ptr, ptr %m.addr, align 8
  %call45 = call i32 @PyModule_AddIntConstant(ptr noundef %12, ptr noundef @.str.605, i64 noundef 2048)
  %tobool46 = icmp ne i32 %call45, 0
  br i1 %tobool46, label %if.then47, label %if.end48

if.then47:                                        ; preds = %if.end44
  store i32 -1, ptr %retval, align 4
  br label %return

if.end48:                                         ; preds = %if.end44
  %13 = load ptr, ptr %m.addr, align 8
  %call49 = call i32 @PyModule_AddIntConstant(ptr noundef %13, ptr noundef @.str.606, i64 noundef 2048)
  %tobool50 = icmp ne i32 %call49, 0
  br i1 %tobool50, label %if.then51, label %if.end52

if.then51:                                        ; preds = %if.end48
  store i32 -1, ptr %retval, align 4
  br label %return

if.end52:                                         ; preds = %if.end48
  %14 = load ptr, ptr %m.addr, align 8
  %call53 = call i32 @PyModule_AddIntConstant(ptr noundef %14, ptr noundef @.str.607, i64 noundef 1024)
  %tobool54 = icmp ne i32 %call53, 0
  br i1 %tobool54, label %if.then55, label %if.end56

if.then55:                                        ; preds = %if.end52
  store i32 -1, ptr %retval, align 4
  br label %return

if.end56:                                         ; preds = %if.end52
  %15 = load ptr, ptr %m.addr, align 8
  %call57 = call i32 @PyModule_AddIntConstant(ptr noundef %15, ptr noundef @.str.608, i64 noundef 4096)
  %tobool58 = icmp ne i32 %call57, 0
  br i1 %tobool58, label %if.then59, label %if.end60

if.then59:                                        ; preds = %if.end56
  store i32 -1, ptr %retval, align 4
  br label %return

if.end60:                                         ; preds = %if.end56
  %16 = load ptr, ptr %m.addr, align 8
  %call61 = call i32 @PyModule_AddIntConstant(ptr noundef %16, ptr noundef @.str.609, i64 noundef 1052672)
  %tobool62 = icmp ne i32 %call61, 0
  br i1 %tobool62, label %if.then63, label %if.end64

if.then63:                                        ; preds = %if.end60
  store i32 -1, ptr %retval, align 4
  br label %return

if.end64:                                         ; preds = %if.end60
  %17 = load ptr, ptr %m.addr, align 8
  %call65 = call i32 @PyModule_AddIntConstant(ptr noundef %17, ptr noundef @.str.610, i64 noundef 1052672)
  %tobool66 = icmp ne i32 %call65, 0
  br i1 %tobool66, label %if.then67, label %if.end68

if.then67:                                        ; preds = %if.end64
  store i32 -1, ptr %retval, align 4
  br label %return

if.end68:                                         ; preds = %if.end64
  %18 = load ptr, ptr %m.addr, align 8
  %call69 = call i32 @PyModule_AddIntConstant(ptr noundef %18, ptr noundef @.str.611, i64 noundef 256)
  %tobool70 = icmp ne i32 %call69, 0
  br i1 %tobool70, label %if.then71, label %if.end72

if.then71:                                        ; preds = %if.end68
  store i32 -1, ptr %retval, align 4
  br label %return

if.end72:                                         ; preds = %if.end68
  %19 = load ptr, ptr %m.addr, align 8
  %call73 = call i32 @PyModule_AddIntConstant(ptr noundef %19, ptr noundef @.str.612, i64 noundef 64)
  %tobool74 = icmp ne i32 %call73, 0
  br i1 %tobool74, label %if.then75, label %if.end76

if.then75:                                        ; preds = %if.end72
  store i32 -1, ptr %retval, align 4
  br label %return

if.end76:                                         ; preds = %if.end72
  %20 = load ptr, ptr %m.addr, align 8
  %call77 = call i32 @PyModule_AddIntConstant(ptr noundef %20, ptr noundef @.str.613, i64 noundef 128)
  %tobool78 = icmp ne i32 %call77, 0
  br i1 %tobool78, label %if.then79, label %if.end80

if.then79:                                        ; preds = %if.end76
  store i32 -1, ptr %retval, align 4
  br label %return

if.end80:                                         ; preds = %if.end76
  %21 = load ptr, ptr %m.addr, align 8
  %call81 = call i32 @PyModule_AddIntConstant(ptr noundef %21, ptr noundef @.str.614, i64 noundef 512)
  %tobool82 = icmp ne i32 %call81, 0
  br i1 %tobool82, label %if.then83, label %if.end84

if.then83:                                        ; preds = %if.end80
  store i32 -1, ptr %retval, align 4
  br label %return

if.end84:                                         ; preds = %if.end80
  %22 = load ptr, ptr %m.addr, align 8
  %call85 = call i32 @PyModule_AddIntConstant(ptr noundef %22, ptr noundef @.str.615, i64 noundef 0)
  %tobool86 = icmp ne i32 %call85, 0
  br i1 %tobool86, label %if.then87, label %if.end88

if.then87:                                        ; preds = %if.end84
  store i32 -1, ptr %retval, align 4
  br label %return

if.end88:                                         ; preds = %if.end84
  %23 = load ptr, ptr %m.addr, align 8
  %call89 = call i32 @PyModule_AddIntConstant(ptr noundef %23, ptr noundef @.str.616, i64 noundef 2097152)
  %tobool90 = icmp ne i32 %call89, 0
  br i1 %tobool90, label %if.then91, label %if.end92

if.then91:                                        ; preds = %if.end88
  store i32 -1, ptr %retval, align 4
  br label %return

if.end92:                                         ; preds = %if.end88
  %24 = load ptr, ptr %m.addr, align 8
  %call93 = call i32 @PyModule_AddIntConstant(ptr noundef %24, ptr noundef @.str.617, i64 noundef 4259840)
  %tobool94 = icmp ne i32 %call93, 0
  br i1 %tobool94, label %if.then95, label %if.end96

if.then95:                                        ; preds = %if.end92
  store i32 -1, ptr %retval, align 4
  br label %return

if.end96:                                         ; preds = %if.end92
  %25 = load ptr, ptr %m.addr, align 8
  %call97 = call i32 @PyModule_AddIntConstant(ptr noundef %25, ptr noundef @.str.618, i64 noundef 0)
  %tobool98 = icmp ne i32 %call97, 0
  br i1 %tobool98, label %if.then99, label %if.end100

if.then99:                                        ; preds = %if.end96
  store i32 -1, ptr %retval, align 4
  br label %return

if.end100:                                        ; preds = %if.end96
  %26 = load ptr, ptr %m.addr, align 8
  %call101 = call i32 @PyModule_AddIntConstant(ptr noundef %26, ptr noundef @.str.619, i64 noundef 1)
  %tobool102 = icmp ne i32 %call101, 0
  br i1 %tobool102, label %if.then103, label %if.end104

if.then103:                                       ; preds = %if.end100
  store i32 -1, ptr %retval, align 4
  br label %return

if.end104:                                        ; preds = %if.end100
  %27 = load ptr, ptr %m.addr, align 8
  %call105 = call i32 @PyModule_AddIntConstant(ptr noundef %27, ptr noundef @.str.620, i64 noundef 2)
  %tobool106 = icmp ne i32 %call105, 0
  br i1 %tobool106, label %if.then107, label %if.end108

if.then107:                                       ; preds = %if.end104
  store i32 -1, ptr %retval, align 4
  br label %return

if.end108:                                        ; preds = %if.end104
  %28 = load ptr, ptr %m.addr, align 8
  %call109 = call i32 @PyModule_AddIntConstant(ptr noundef %28, ptr noundef @.str.621, i64 noundef 524288)
  %tobool110 = icmp ne i32 %call109, 0
  br i1 %tobool110, label %if.then111, label %if.end112

if.then111:                                       ; preds = %if.end108
  store i32 -1, ptr %retval, align 4
  br label %return

if.end112:                                        ; preds = %if.end108
  %29 = load ptr, ptr %m.addr, align 8
  %call113 = call i32 @PyModule_AddIntConstant(ptr noundef %29, ptr noundef @.str.622, i64 noundef 3)
  %tobool114 = icmp ne i32 %call113, 0
  br i1 %tobool114, label %if.then115, label %if.end116

if.then115:                                       ; preds = %if.end112
  store i32 -1, ptr %retval, align 4
  br label %return

if.end116:                                        ; preds = %if.end112
  %30 = load ptr, ptr %m.addr, align 8
  %call117 = call i32 @PyModule_AddIntConstant(ptr noundef %30, ptr noundef @.str.623, i64 noundef 1052672)
  %tobool118 = icmp ne i32 %call117, 0
  br i1 %tobool118, label %if.then119, label %if.end120

if.then119:                                       ; preds = %if.end116
  store i32 -1, ptr %retval, align 4
  br label %return

if.end120:                                        ; preds = %if.end116
  %31 = load ptr, ptr %m.addr, align 8
  %call121 = call i32 @PyModule_AddIntConstant(ptr noundef %31, ptr noundef @.str.624, i64 noundef 4)
  %tobool122 = icmp ne i32 %call121, 0
  br i1 %tobool122, label %if.then123, label %if.end124

if.then123:                                       ; preds = %if.end120
  store i32 -1, ptr %retval, align 4
  br label %return

if.end124:                                        ; preds = %if.end120
  %32 = load ptr, ptr %m.addr, align 8
  %call125 = call i32 @PyModule_AddIntConstant(ptr noundef %32, ptr noundef @.str.625, i64 noundef 3)
  %tobool126 = icmp ne i32 %call125, 0
  br i1 %tobool126, label %if.then127, label %if.end128

if.then127:                                       ; preds = %if.end124
  store i32 -1, ptr %retval, align 4
  br label %return

if.end128:                                        ; preds = %if.end124
  %33 = load ptr, ptr %m.addr, align 8
  %call129 = call i32 @PyModule_AddIntConstant(ptr noundef %33, ptr noundef @.str.626, i64 noundef 8192)
  %tobool130 = icmp ne i32 %call129, 0
  br i1 %tobool130, label %if.then131, label %if.end132

if.then131:                                       ; preds = %if.end128
  store i32 -1, ptr %retval, align 4
  br label %return

if.end132:                                        ; preds = %if.end128
  %34 = load ptr, ptr %m.addr, align 8
  %call133 = call i32 @PyModule_AddIntConstant(ptr noundef %34, ptr noundef @.str.627, i64 noundef 16384)
  %tobool134 = icmp ne i32 %call133, 0
  br i1 %tobool134, label %if.then135, label %if.end136

if.then135:                                       ; preds = %if.end132
  store i32 -1, ptr %retval, align 4
  br label %return

if.end136:                                        ; preds = %if.end132
  %35 = load ptr, ptr %m.addr, align 8
  %call137 = call i32 @PyModule_AddIntConstant(ptr noundef %35, ptr noundef @.str.628, i64 noundef 65536)
  %tobool138 = icmp ne i32 %call137, 0
  br i1 %tobool138, label %if.then139, label %if.end140

if.then139:                                       ; preds = %if.end136
  store i32 -1, ptr %retval, align 4
  br label %return

if.end140:                                        ; preds = %if.end136
  %36 = load ptr, ptr %m.addr, align 8
  %call141 = call i32 @PyModule_AddIntConstant(ptr noundef %36, ptr noundef @.str.629, i64 noundef 131072)
  %tobool142 = icmp ne i32 %call141, 0
  br i1 %tobool142, label %if.then143, label %if.end144

if.then143:                                       ; preds = %if.end140
  store i32 -1, ptr %retval, align 4
  br label %return

if.end144:                                        ; preds = %if.end140
  %37 = load ptr, ptr %m.addr, align 8
  %call145 = call i32 @PyModule_AddIntConstant(ptr noundef %37, ptr noundef @.str.630, i64 noundef 262144)
  %tobool146 = icmp ne i32 %call145, 0
  br i1 %tobool146, label %if.then147, label %if.end148

if.then147:                                       ; preds = %if.end144
  store i32 -1, ptr %retval, align 4
  br label %return

if.end148:                                        ; preds = %if.end144
  %38 = load ptr, ptr %m.addr, align 8
  %call149 = call i32 @PyModule_AddIntConstant(ptr noundef %38, ptr noundef @.str.631, i64 noundef 0)
  %tobool150 = icmp ne i32 %call149, 0
  br i1 %tobool150, label %if.then151, label %if.end152

if.then151:                                       ; preds = %if.end148
  store i32 -1, ptr %retval, align 4
  br label %return

if.end152:                                        ; preds = %if.end148
  %39 = load ptr, ptr %m.addr, align 8
  %call153 = call i32 @PyModule_AddIntConstant(ptr noundef %39, ptr noundef @.str.632, i64 noundef 64)
  %tobool154 = icmp ne i32 %call153, 0
  br i1 %tobool154, label %if.then155, label %if.end156

if.then155:                                       ; preds = %if.end152
  store i32 -1, ptr %retval, align 4
  br label %return

if.end156:                                        ; preds = %if.end152
  %40 = load ptr, ptr %m.addr, align 8
  %call157 = call i32 @PyModule_AddIntConstant(ptr noundef %40, ptr noundef @.str.633, i64 noundef 65)
  %tobool158 = icmp ne i32 %call157, 0
  br i1 %tobool158, label %if.then159, label %if.end160

if.then159:                                       ; preds = %if.end156
  store i32 -1, ptr %retval, align 4
  br label %return

if.end160:                                        ; preds = %if.end156
  %41 = load ptr, ptr %m.addr, align 8
  %call161 = call i32 @PyModule_AddIntConstant(ptr noundef %41, ptr noundef @.str.634, i64 noundef 66)
  %tobool162 = icmp ne i32 %call161, 0
  br i1 %tobool162, label %if.then163, label %if.end164

if.then163:                                       ; preds = %if.end160
  store i32 -1, ptr %retval, align 4
  br label %return

if.end164:                                        ; preds = %if.end160
  %42 = load ptr, ptr %m.addr, align 8
  %call165 = call i32 @PyModule_AddIntConstant(ptr noundef %42, ptr noundef @.str.635, i64 noundef 67)
  %tobool166 = icmp ne i32 %call165, 0
  br i1 %tobool166, label %if.then167, label %if.end168

if.then167:                                       ; preds = %if.end164
  store i32 -1, ptr %retval, align 4
  br label %return

if.end168:                                        ; preds = %if.end164
  %43 = load ptr, ptr %m.addr, align 8
  %call169 = call i32 @PyModule_AddIntConstant(ptr noundef %43, ptr noundef @.str.636, i64 noundef 68)
  %tobool170 = icmp ne i32 %call169, 0
  br i1 %tobool170, label %if.then171, label %if.end172

if.then171:                                       ; preds = %if.end168
  store i32 -1, ptr %retval, align 4
  br label %return

if.end172:                                        ; preds = %if.end168
  %44 = load ptr, ptr %m.addr, align 8
  %call173 = call i32 @PyModule_AddIntConstant(ptr noundef %44, ptr noundef @.str.637, i64 noundef 69)
  %tobool174 = icmp ne i32 %call173, 0
  br i1 %tobool174, label %if.then175, label %if.end176

if.then175:                                       ; preds = %if.end172
  store i32 -1, ptr %retval, align 4
  br label %return

if.end176:                                        ; preds = %if.end172
  %45 = load ptr, ptr %m.addr, align 8
  %call177 = call i32 @PyModule_AddIntConstant(ptr noundef %45, ptr noundef @.str.638, i64 noundef 70)
  %tobool178 = icmp ne i32 %call177, 0
  br i1 %tobool178, label %if.then179, label %if.end180

if.then179:                                       ; preds = %if.end176
  store i32 -1, ptr %retval, align 4
  br label %return

if.end180:                                        ; preds = %if.end176
  %46 = load ptr, ptr %m.addr, align 8
  %call181 = call i32 @PyModule_AddIntConstant(ptr noundef %46, ptr noundef @.str.639, i64 noundef 71)
  %tobool182 = icmp ne i32 %call181, 0
  br i1 %tobool182, label %if.then183, label %if.end184

if.then183:                                       ; preds = %if.end180
  store i32 -1, ptr %retval, align 4
  br label %return

if.end184:                                        ; preds = %if.end180
  %47 = load ptr, ptr %m.addr, align 8
  %call185 = call i32 @PyModule_AddIntConstant(ptr noundef %47, ptr noundef @.str.640, i64 noundef 72)
  %tobool186 = icmp ne i32 %call185, 0
  br i1 %tobool186, label %if.then187, label %if.end188

if.then187:                                       ; preds = %if.end184
  store i32 -1, ptr %retval, align 4
  br label %return

if.end188:                                        ; preds = %if.end184
  %48 = load ptr, ptr %m.addr, align 8
  %call189 = call i32 @PyModule_AddIntConstant(ptr noundef %48, ptr noundef @.str.641, i64 noundef 73)
  %tobool190 = icmp ne i32 %call189, 0
  br i1 %tobool190, label %if.then191, label %if.end192

if.then191:                                       ; preds = %if.end188
  store i32 -1, ptr %retval, align 4
  br label %return

if.end192:                                        ; preds = %if.end188
  %49 = load ptr, ptr %m.addr, align 8
  %call193 = call i32 @PyModule_AddIntConstant(ptr noundef %49, ptr noundef @.str.642, i64 noundef 74)
  %tobool194 = icmp ne i32 %call193, 0
  br i1 %tobool194, label %if.then195, label %if.end196

if.then195:                                       ; preds = %if.end192
  store i32 -1, ptr %retval, align 4
  br label %return

if.end196:                                        ; preds = %if.end192
  %50 = load ptr, ptr %m.addr, align 8
  %call197 = call i32 @PyModule_AddIntConstant(ptr noundef %50, ptr noundef @.str.643, i64 noundef 75)
  %tobool198 = icmp ne i32 %call197, 0
  br i1 %tobool198, label %if.then199, label %if.end200

if.then199:                                       ; preds = %if.end196
  store i32 -1, ptr %retval, align 4
  br label %return

if.end200:                                        ; preds = %if.end196
  %51 = load ptr, ptr %m.addr, align 8
  %call201 = call i32 @PyModule_AddIntConstant(ptr noundef %51, ptr noundef @.str.644, i64 noundef 76)
  %tobool202 = icmp ne i32 %call201, 0
  br i1 %tobool202, label %if.then203, label %if.end204

if.then203:                                       ; preds = %if.end200
  store i32 -1, ptr %retval, align 4
  br label %return

if.end204:                                        ; preds = %if.end200
  %52 = load ptr, ptr %m.addr, align 8
  %call205 = call i32 @PyModule_AddIntConstant(ptr noundef %52, ptr noundef @.str.645, i64 noundef 77)
  %tobool206 = icmp ne i32 %call205, 0
  br i1 %tobool206, label %if.then207, label %if.end208

if.then207:                                       ; preds = %if.end204
  store i32 -1, ptr %retval, align 4
  br label %return

if.end208:                                        ; preds = %if.end204
  %53 = load ptr, ptr %m.addr, align 8
  %call209 = call i32 @PyModule_AddIntConstant(ptr noundef %53, ptr noundef @.str.646, i64 noundef 78)
  %tobool210 = icmp ne i32 %call209, 0
  br i1 %tobool210, label %if.then211, label %if.end212

if.then211:                                       ; preds = %if.end208
  store i32 -1, ptr %retval, align 4
  br label %return

if.end212:                                        ; preds = %if.end208
  %54 = load ptr, ptr %m.addr, align 8
  %call213 = call i32 @PyModule_AddIntConstant(ptr noundef %54, ptr noundef @.str.647, i64 noundef 1)
  %tobool214 = icmp ne i32 %call213, 0
  br i1 %tobool214, label %if.then215, label %if.end216

if.then215:                                       ; preds = %if.end212
  store i32 -1, ptr %retval, align 4
  br label %return

if.end216:                                        ; preds = %if.end212
  %55 = load ptr, ptr %m.addr, align 8
  %call217 = call i32 @PyModule_AddIntConstant(ptr noundef %55, ptr noundef @.str.648, i64 noundef 2)
  %tobool218 = icmp ne i32 %call217, 0
  br i1 %tobool218, label %if.then219, label %if.end220

if.then219:                                       ; preds = %if.end216
  store i32 -1, ptr %retval, align 4
  br label %return

if.end220:                                        ; preds = %if.end216
  %56 = load ptr, ptr %m.addr, align 8
  %call221 = call i32 @PyModule_AddIntConstant(ptr noundef %56, ptr noundef @.str.649, i64 noundef 4)
  %tobool222 = icmp ne i32 %call221, 0
  br i1 %tobool222, label %if.then223, label %if.end224

if.then223:                                       ; preds = %if.end220
  store i32 -1, ptr %retval, align 4
  br label %return

if.end224:                                        ; preds = %if.end220
  %57 = load ptr, ptr %m.addr, align 8
  %call225 = call i32 @PyModule_AddIntConstant(ptr noundef %57, ptr noundef @.str.650, i64 noundef 8)
  %tobool226 = icmp ne i32 %call225, 0
  br i1 %tobool226, label %if.then227, label %if.end228

if.then227:                                       ; preds = %if.end224
  store i32 -1, ptr %retval, align 4
  br label %return

if.end228:                                        ; preds = %if.end224
  %58 = load ptr, ptr %m.addr, align 8
  %call229 = call i32 @PyModule_AddIntConstant(ptr noundef %58, ptr noundef @.str.651, i64 noundef 16)
  %tobool230 = icmp ne i32 %call229, 0
  br i1 %tobool230, label %if.then231, label %if.end232

if.then231:                                       ; preds = %if.end228
  store i32 -1, ptr %retval, align 4
  br label %return

if.end232:                                        ; preds = %if.end228
  %59 = load ptr, ptr %m.addr, align 8
  %call233 = call i32 @PyModule_AddIntConstant(ptr noundef %59, ptr noundef @.str.652, i64 noundef 64)
  %tobool234 = icmp ne i32 %call233, 0
  br i1 %tobool234, label %if.then235, label %if.end236

if.then235:                                       ; preds = %if.end232
  store i32 -1, ptr %retval, align 4
  br label %return

if.end236:                                        ; preds = %if.end232
  %60 = load ptr, ptr %m.addr, align 8
  %call237 = call i32 @PyModule_AddIntConstant(ptr noundef %60, ptr noundef @.str.653, i64 noundef 128)
  %tobool238 = icmp ne i32 %call237, 0
  br i1 %tobool238, label %if.then239, label %if.end240

if.then239:                                       ; preds = %if.end236
  store i32 -1, ptr %retval, align 4
  br label %return

if.end240:                                        ; preds = %if.end236
  %61 = load ptr, ptr %m.addr, align 8
  %call241 = call i32 @PyModule_AddIntConstant(ptr noundef %61, ptr noundef @.str.654, i64 noundef 256)
  %tobool242 = icmp ne i32 %call241, 0
  br i1 %tobool242, label %if.then243, label %if.end244

if.then243:                                       ; preds = %if.end240
  store i32 -1, ptr %retval, align 4
  br label %return

if.end244:                                        ; preds = %if.end240
  %62 = load ptr, ptr %m.addr, align 8
  %call245 = call i32 @PyModule_AddIntConstant(ptr noundef %62, ptr noundef @.str.655, i64 noundef 1024)
  %tobool246 = icmp ne i32 %call245, 0
  br i1 %tobool246, label %if.then247, label %if.end248

if.then247:                                       ; preds = %if.end244
  store i32 -1, ptr %retval, align 4
  br label %return

if.end248:                                        ; preds = %if.end244
  %63 = load ptr, ptr %m.addr, align 8
  %call249 = call i32 @PyModule_AddIntConstant(ptr noundef %63, ptr noundef @.str.656, i64 noundef 2048)
  %tobool250 = icmp ne i32 %call249, 0
  br i1 %tobool250, label %if.then251, label %if.end252

if.then251:                                       ; preds = %if.end248
  store i32 -1, ptr %retval, align 4
  br label %return

if.end252:                                        ; preds = %if.end248
  %64 = load ptr, ptr %m.addr, align 8
  %call253 = call i32 @PyModule_AddIntConstant(ptr noundef %64, ptr noundef @.str.657, i64 noundef 4096)
  %tobool254 = icmp ne i32 %call253, 0
  br i1 %tobool254, label %if.then255, label %if.end256

if.then255:                                       ; preds = %if.end252
  store i32 -1, ptr %retval, align 4
  br label %return

if.end256:                                        ; preds = %if.end252
  %65 = load ptr, ptr %m.addr, align 8
  %call257 = call i32 @PyModule_AddIntConstant(ptr noundef %65, ptr noundef @.str.658, i64 noundef 2048)
  %tobool258 = icmp ne i32 %call257, 0
  br i1 %tobool258, label %if.then259, label %if.end260

if.then259:                                       ; preds = %if.end256
  store i32 -1, ptr %retval, align 4
  br label %return

if.end260:                                        ; preds = %if.end256
  %66 = load ptr, ptr %m.addr, align 8
  %call261 = call i32 @PyModule_AddIntConstant(ptr noundef %66, ptr noundef @.str.659, i64 noundef 524288)
  %tobool262 = icmp ne i32 %call261, 0
  br i1 %tobool262, label %if.then263, label %if.end264

if.then263:                                       ; preds = %if.end260
  store i32 -1, ptr %retval, align 4
  br label %return

if.end264:                                        ; preds = %if.end260
  %67 = load ptr, ptr %m.addr, align 8
  %call265 = call i32 @PyModule_AddIntConstant(ptr noundef %67, ptr noundef @.str.660, i64 noundef 1)
  %tobool266 = icmp ne i32 %call265, 0
  br i1 %tobool266, label %if.then267, label %if.end268

if.then267:                                       ; preds = %if.end264
  store i32 -1, ptr %retval, align 4
  br label %return

if.end268:                                        ; preds = %if.end264
  %68 = load ptr, ptr %m.addr, align 8
  %call269 = call i32 @PyModule_AddIntConstant(ptr noundef %68, ptr noundef @.str.661, i64 noundef 2)
  %tobool270 = icmp ne i32 %call269, 0
  br i1 %tobool270, label %if.then271, label %if.end272

if.then271:                                       ; preds = %if.end268
  store i32 -1, ptr %retval, align 4
  br label %return

if.end272:                                        ; preds = %if.end268
  %69 = load ptr, ptr %m.addr, align 8
  %call273 = call i32 @PyModule_AddIntConstant(ptr noundef %69, ptr noundef @.str.662, i64 noundef 0)
  %tobool274 = icmp ne i32 %call273, 0
  br i1 %tobool274, label %if.then275, label %if.end276

if.then275:                                       ; preds = %if.end272
  store i32 -1, ptr %retval, align 4
  br label %return

if.end276:                                        ; preds = %if.end272
  %70 = load ptr, ptr %m.addr, align 8
  %call277 = call i32 @PyModule_AddIntConstant(ptr noundef %70, ptr noundef @.str.663, i64 noundef 2)
  %tobool278 = icmp ne i32 %call277, 0
  br i1 %tobool278, label %if.then279, label %if.end280

if.then279:                                       ; preds = %if.end276
  store i32 -1, ptr %retval, align 4
  br label %return

if.end280:                                        ; preds = %if.end276
  %71 = load ptr, ptr %m.addr, align 8
  %call281 = call i32 @PyModule_AddIntConstant(ptr noundef %71, ptr noundef @.str.664, i64 noundef 1)
  %tobool282 = icmp ne i32 %call281, 0
  br i1 %tobool282, label %if.then283, label %if.end284

if.then283:                                       ; preds = %if.end280
  store i32 -1, ptr %retval, align 4
  br label %return

if.end284:                                        ; preds = %if.end280
  %72 = load ptr, ptr %m.addr, align 8
  %call285 = call i32 @PyModule_AddIntConstant(ptr noundef %72, ptr noundef @.str.665, i64 noundef 5)
  %tobool286 = icmp ne i32 %call285, 0
  br i1 %tobool286, label %if.then287, label %if.end288

if.then287:                                       ; preds = %if.end284
  store i32 -1, ptr %retval, align 4
  br label %return

if.end288:                                        ; preds = %if.end284
  %73 = load ptr, ptr %m.addr, align 8
  %call289 = call i32 @PyModule_AddIntConstant(ptr noundef %73, ptr noundef @.str.666, i64 noundef 3)
  %tobool290 = icmp ne i32 %call289, 0
  br i1 %tobool290, label %if.then291, label %if.end292

if.then291:                                       ; preds = %if.end288
  store i32 -1, ptr %retval, align 4
  br label %return

if.end292:                                        ; preds = %if.end288
  %74 = load ptr, ptr %m.addr, align 8
  %call293 = call i32 @PyModule_AddIntConstant(ptr noundef %74, ptr noundef @.str.667, i64 noundef 4)
  %tobool294 = icmp ne i32 %call293, 0
  br i1 %tobool294, label %if.then295, label %if.end296

if.then295:                                       ; preds = %if.end292
  store i32 -1, ptr %retval, align 4
  br label %return

if.end296:                                        ; preds = %if.end292
  %75 = load ptr, ptr %m.addr, align 8
  %call297 = call i32 @PyModule_AddIntConstant(ptr noundef %75, ptr noundef @.str.668, i64 noundef 1)
  %tobool298 = icmp ne i32 %call297, 0
  br i1 %tobool298, label %if.then299, label %if.end300

if.then299:                                       ; preds = %if.end296
  store i32 -1, ptr %retval, align 4
  br label %return

if.end300:                                        ; preds = %if.end296
  %76 = load ptr, ptr %m.addr, align 8
  %call301 = call i32 @PyModule_AddIntConstant(ptr noundef %76, ptr noundef @.str.669, i64 noundef 2)
  %tobool302 = icmp ne i32 %call301, 0
  br i1 %tobool302, label %if.then303, label %if.end304

if.then303:                                       ; preds = %if.end300
  store i32 -1, ptr %retval, align 4
  br label %return

if.end304:                                        ; preds = %if.end300
  %77 = load ptr, ptr %m.addr, align 8
  %call305 = call i32 @PyModule_AddIntConstant(ptr noundef %77, ptr noundef @.str.670, i64 noundef 0)
  %tobool306 = icmp ne i32 %call305, 0
  br i1 %tobool306, label %if.then307, label %if.end308

if.then307:                                       ; preds = %if.end304
  store i32 -1, ptr %retval, align 4
  br label %return

if.end308:                                        ; preds = %if.end304
  %78 = load ptr, ptr %m.addr, align 8
  %call309 = call i32 @PyModule_AddIntConstant(ptr noundef %78, ptr noundef @.str.671, i64 noundef 3)
  %tobool310 = icmp ne i32 %call309, 0
  br i1 %tobool310, label %if.then311, label %if.end312

if.then311:                                       ; preds = %if.end308
  store i32 -1, ptr %retval, align 4
  br label %return

if.end312:                                        ; preds = %if.end308
  %79 = load ptr, ptr %m.addr, align 8
  %call313 = call i32 @PyModule_AddIntConstant(ptr noundef %79, ptr noundef @.str.672, i64 noundef 4)
  %tobool314 = icmp ne i32 %call313, 0
  br i1 %tobool314, label %if.then315, label %if.end316

if.then315:                                       ; preds = %if.end312
  store i32 -1, ptr %retval, align 4
  br label %return

if.end316:                                        ; preds = %if.end312
  %80 = load ptr, ptr %m.addr, align 8
  %call317 = call i32 @PyModule_AddIntConstant(ptr noundef %80, ptr noundef @.str.673, i64 noundef 16777216)
  %tobool318 = icmp ne i32 %call317, 0
  br i1 %tobool318, label %if.then319, label %if.end320

if.then319:                                       ; preds = %if.end316
  store i32 -1, ptr %retval, align 4
  br label %return

if.end320:                                        ; preds = %if.end316
  %81 = load ptr, ptr %m.addr, align 8
  %call321 = call i32 @PyModule_AddIntConstant(ptr noundef %81, ptr noundef @.str.674, i64 noundef 2)
  %tobool322 = icmp ne i32 %call321, 0
  br i1 %tobool322, label %if.then323, label %if.end324

if.then323:                                       ; preds = %if.end320
  store i32 -1, ptr %retval, align 4
  br label %return

if.end324:                                        ; preds = %if.end320
  %82 = load ptr, ptr %m.addr, align 8
  %call325 = call i32 @PyModule_AddIntConstant(ptr noundef %82, ptr noundef @.str.675, i64 noundef 1)
  %tobool326 = icmp ne i32 %call325, 0
  br i1 %tobool326, label %if.then327, label %if.end328

if.then327:                                       ; preds = %if.end324
  store i32 -1, ptr %retval, align 4
  br label %return

if.end328:                                        ; preds = %if.end324
  %83 = load ptr, ptr %m.addr, align 8
  %call329 = call i32 @PyModule_AddIntConstant(ptr noundef %83, ptr noundef @.str.676, i64 noundef 2)
  %tobool330 = icmp ne i32 %call329, 0
  br i1 %tobool330, label %if.then331, label %if.end332

if.then331:                                       ; preds = %if.end328
  store i32 -1, ptr %retval, align 4
  br label %return

if.end332:                                        ; preds = %if.end328
  %84 = load ptr, ptr %m.addr, align 8
  %call333 = call i32 @PyModule_AddIntConstant(ptr noundef %84, ptr noundef @.str.677, i64 noundef 3)
  %tobool334 = icmp ne i32 %call333, 0
  br i1 %tobool334, label %if.then335, label %if.end336

if.then335:                                       ; preds = %if.end332
  store i32 -1, ptr %retval, align 4
  br label %return

if.end336:                                        ; preds = %if.end332
  %85 = load ptr, ptr %m.addr, align 8
  %call337 = call i32 @PyModule_AddIntConstant(ptr noundef %85, ptr noundef @.str.678, i64 noundef 4)
  %tobool338 = icmp ne i32 %call337, 0
  br i1 %tobool338, label %if.then339, label %if.end340

if.then339:                                       ; preds = %if.end336
  store i32 -1, ptr %retval, align 4
  br label %return

if.end340:                                        ; preds = %if.end336
  %86 = load ptr, ptr %m.addr, align 8
  %call341 = call i32 @PyModule_AddIntConstant(ptr noundef %86, ptr noundef @.str.679, i64 noundef 5)
  %tobool342 = icmp ne i32 %call341, 0
  br i1 %tobool342, label %if.then343, label %if.end344

if.then343:                                       ; preds = %if.end340
  store i32 -1, ptr %retval, align 4
  br label %return

if.end344:                                        ; preds = %if.end340
  %87 = load ptr, ptr %m.addr, align 8
  %call345 = call i32 @PyModule_AddIntConstant(ptr noundef %87, ptr noundef @.str.680, i64 noundef 6)
  %tobool346 = icmp ne i32 %call345, 0
  br i1 %tobool346, label %if.then347, label %if.end348

if.then347:                                       ; preds = %if.end344
  store i32 -1, ptr %retval, align 4
  br label %return

if.end348:                                        ; preds = %if.end344
  %88 = load ptr, ptr %m.addr, align 8
  %call349 = call i32 @PyModule_AddIntConstant(ptr noundef %88, ptr noundef @.str.681, i64 noundef 1)
  %tobool350 = icmp ne i32 %call349, 0
  br i1 %tobool350, label %if.then351, label %if.end352

if.then351:                                       ; preds = %if.end348
  store i32 -1, ptr %retval, align 4
  br label %return

if.end352:                                        ; preds = %if.end348
  %89 = load ptr, ptr %m.addr, align 8
  %call353 = call i32 @PyModule_AddIntConstant(ptr noundef %89, ptr noundef @.str.682, i64 noundef 2)
  %tobool354 = icmp ne i32 %call353, 0
  br i1 %tobool354, label %if.then355, label %if.end356

if.then355:                                       ; preds = %if.end352
  store i32 -1, ptr %retval, align 4
  br label %return

if.end356:                                        ; preds = %if.end352
  %90 = load ptr, ptr %m.addr, align 8
  %call357 = call i32 @PyModule_AddIntConstant(ptr noundef %90, ptr noundef @.str.683, i64 noundef 0)
  %tobool358 = icmp ne i32 %call357, 0
  br i1 %tobool358, label %if.then359, label %if.end360

if.then359:                                       ; preds = %if.end356
  store i32 -1, ptr %retval, align 4
  br label %return

if.end360:                                        ; preds = %if.end356
  %91 = load ptr, ptr %m.addr, align 8
  %call361 = call i32 @PyModule_AddIntConstant(ptr noundef %91, ptr noundef @.str.684, i64 noundef 3)
  %tobool362 = icmp ne i32 %call361, 0
  br i1 %tobool362, label %if.then363, label %if.end364

if.then363:                                       ; preds = %if.end360
  store i32 -1, ptr %retval, align 4
  br label %return

if.end364:                                        ; preds = %if.end360
  %92 = load ptr, ptr %m.addr, align 8
  %call365 = call i32 @PyModule_AddIntConstant(ptr noundef %92, ptr noundef @.str.685, i64 noundef 2)
  %tobool366 = icmp ne i32 %call365, 0
  br i1 %tobool366, label %if.then367, label %if.end368

if.then367:                                       ; preds = %if.end364
  store i32 -1, ptr %retval, align 4
  br label %return

if.end368:                                        ; preds = %if.end364
  %93 = load ptr, ptr %m.addr, align 8
  %call369 = call i32 @PyModule_AddIntConstant(ptr noundef %93, ptr noundef @.str.686, i64 noundef 1)
  %tobool370 = icmp ne i32 %call369, 0
  br i1 %tobool370, label %if.then371, label %if.end372

if.then371:                                       ; preds = %if.end368
  store i32 -1, ptr %retval, align 4
  br label %return

if.end372:                                        ; preds = %if.end368
  %94 = load ptr, ptr %m.addr, align 8
  %call373 = call i32 @PyModule_AddIntConstant(ptr noundef %94, ptr noundef @.str.687, i64 noundef 4)
  %tobool374 = icmp ne i32 %call373, 0
  br i1 %tobool374, label %if.then375, label %if.end376

if.then375:                                       ; preds = %if.end372
  store i32 -1, ptr %retval, align 4
  br label %return

if.end376:                                        ; preds = %if.end372
  %95 = load ptr, ptr %m.addr, align 8
  %call377 = call i32 @PyModule_AddIntConstant(ptr noundef %95, ptr noundef @.str.688, i64 noundef 8)
  %tobool378 = icmp ne i32 %call377, 0
  br i1 %tobool378, label %if.then379, label %if.end380

if.then379:                                       ; preds = %if.end376
  store i32 -1, ptr %retval, align 4
  br label %return

if.end380:                                        ; preds = %if.end376
  %96 = load ptr, ptr %m.addr, align 8
  %call381 = call i32 @PyModule_AddIntConstant(ptr noundef %96, ptr noundef @.str.689, i64 noundef 16)
  %tobool382 = icmp ne i32 %call381, 0
  br i1 %tobool382, label %if.then383, label %if.end384

if.then383:                                       ; preds = %if.end380
  store i32 -1, ptr %retval, align 4
  br label %return

if.end384:                                        ; preds = %if.end380
  %97 = load ptr, ptr %m.addr, align 8
  %call385 = call i32 @PyModule_AddIntConstant(ptr noundef %97, ptr noundef @.str.690, i64 noundef 1)
  %tobool386 = icmp ne i32 %call385, 0
  br i1 %tobool386, label %if.then387, label %if.end388

if.then387:                                       ; preds = %if.end384
  store i32 -1, ptr %retval, align 4
  br label %return

if.end388:                                        ; preds = %if.end384
  %98 = load ptr, ptr %m.addr, align 8
  %call389 = call i32 @PyModule_AddIntConstant(ptr noundef %98, ptr noundef @.str.691, i64 noundef 2)
  %tobool390 = icmp ne i32 %call389, 0
  br i1 %tobool390, label %if.then391, label %if.end392

if.then391:                                       ; preds = %if.end388
  store i32 -1, ptr %retval, align 4
  br label %return

if.end392:                                        ; preds = %if.end388
  %99 = load ptr, ptr %m.addr, align 8
  %call393 = call i32 @PyModule_AddIntConstant(ptr noundef %99, ptr noundef @.str.692, i64 noundef 4)
  %tobool394 = icmp ne i32 %call393, 0
  br i1 %tobool394, label %if.then395, label %if.end396

if.then395:                                       ; preds = %if.end392
  store i32 -1, ptr %retval, align 4
  br label %return

if.end396:                                        ; preds = %if.end392
  %100 = load ptr, ptr %m.addr, align 8
  %call397 = call i32 @PyModule_AddIntConstant(ptr noundef %100, ptr noundef @.str.693, i64 noundef 0)
  %tobool398 = icmp ne i32 %call397, 0
  br i1 %tobool398, label %if.then399, label %if.end400

if.then399:                                       ; preds = %if.end396
  store i32 -1, ptr %retval, align 4
  br label %return

if.end400:                                        ; preds = %if.end396
  %101 = load ptr, ptr %m.addr, align 8
  %call401 = call i32 @PyModule_AddIntConstant(ptr noundef %101, ptr noundef @.str.694, i64 noundef 1)
  %tobool402 = icmp ne i32 %call401, 0
  br i1 %tobool402, label %if.then403, label %if.end404

if.then403:                                       ; preds = %if.end400
  store i32 -1, ptr %retval, align 4
  br label %return

if.end404:                                        ; preds = %if.end400
  %102 = load ptr, ptr %m.addr, align 8
  %call405 = call i32 @PyModule_AddIntConstant(ptr noundef %102, ptr noundef @.str.695, i64 noundef 2)
  %tobool406 = icmp ne i32 %call405, 0
  br i1 %tobool406, label %if.then407, label %if.end408

if.then407:                                       ; preds = %if.end404
  store i32 -1, ptr %retval, align 4
  br label %return

if.end408:                                        ; preds = %if.end404
  %103 = load ptr, ptr %m.addr, align 8
  %call409 = call i32 @PyModule_AddIntConstant(ptr noundef %103, ptr noundef @.str.696, i64 noundef 0)
  %tobool410 = icmp ne i32 %call409, 0
  br i1 %tobool410, label %if.then411, label %if.end412

if.then411:                                       ; preds = %if.end408
  store i32 -1, ptr %retval, align 4
  br label %return

if.end412:                                        ; preds = %if.end408
  %104 = load ptr, ptr %m.addr, align 8
  %call413 = call i32 @PyModule_AddIntConstant(ptr noundef %104, ptr noundef @.str.697, i64 noundef 1)
  %tobool414 = icmp ne i32 %call413, 0
  br i1 %tobool414, label %if.then415, label %if.end416

if.then415:                                       ; preds = %if.end412
  store i32 -1, ptr %retval, align 4
  br label %return

if.end416:                                        ; preds = %if.end412
  %105 = load ptr, ptr %m.addr, align 8
  %call417 = call i32 @PyModule_AddIntConstant(ptr noundef %105, ptr noundef @.str.698, i64 noundef 2)
  %tobool418 = icmp ne i32 %call417, 0
  br i1 %tobool418, label %if.then419, label %if.end420

if.then419:                                       ; preds = %if.end416
  store i32 -1, ptr %retval, align 4
  br label %return

if.end420:                                        ; preds = %if.end416
  %106 = load ptr, ptr %m.addr, align 8
  %call421 = call i32 @PyModule_AddIntConstant(ptr noundef %106, ptr noundef @.str.699, i64 noundef 3)
  %tobool422 = icmp ne i32 %call421, 0
  br i1 %tobool422, label %if.then423, label %if.end424

if.then423:                                       ; preds = %if.end420
  store i32 -1, ptr %retval, align 4
  br label %return

if.end424:                                        ; preds = %if.end420
  %107 = load ptr, ptr %m.addr, align 8
  %call425 = call i32 @PyModule_AddIntConstant(ptr noundef %107, ptr noundef @.str.700, i64 noundef 5)
  %tobool426 = icmp ne i32 %call425, 0
  br i1 %tobool426, label %if.then427, label %if.end428

if.then427:                                       ; preds = %if.end424
  store i32 -1, ptr %retval, align 4
  br label %return

if.end428:                                        ; preds = %if.end424
  %108 = load ptr, ptr %m.addr, align 8
  %call429 = call i32 @PyModule_AddIntConstant(ptr noundef %108, ptr noundef @.str.701, i64 noundef 1073741824)
  %tobool430 = icmp ne i32 %call429, 0
  br i1 %tobool430, label %if.then431, label %if.end432

if.then431:                                       ; preds = %if.end428
  store i32 -1, ptr %retval, align 4
  br label %return

if.end432:                                        ; preds = %if.end428
  %109 = load ptr, ptr %m.addr, align 8
  %call433 = call i32 @PyModule_AddIntConstant(ptr noundef %109, ptr noundef @.str.702, i64 noundef 512)
  %tobool434 = icmp ne i32 %call433, 0
  br i1 %tobool434, label %if.then435, label %if.end436

if.then435:                                       ; preds = %if.end432
  store i32 -1, ptr %retval, align 4
  br label %return

if.end436:                                        ; preds = %if.end432
  %110 = load ptr, ptr %m.addr, align 8
  %call437 = call i32 @PyModule_AddIntConstant(ptr noundef %110, ptr noundef @.str.703, i64 noundef 1024)
  %tobool438 = icmp ne i32 %call437, 0
  br i1 %tobool438, label %if.then439, label %if.end440

if.then439:                                       ; preds = %if.end436
  store i32 -1, ptr %retval, align 4
  br label %return

if.end440:                                        ; preds = %if.end436
  %111 = load ptr, ptr %m.addr, align 8
  %call441 = call i32 @PyModule_AddIntConstant(ptr noundef %111, ptr noundef @.str.704, i64 noundef 131072)
  %tobool442 = icmp ne i32 %call441, 0
  br i1 %tobool442, label %if.then443, label %if.end444

if.then443:                                       ; preds = %if.end440
  store i32 -1, ptr %retval, align 4
  br label %return

if.end444:                                        ; preds = %if.end440
  %112 = load ptr, ptr %m.addr, align 8
  %call445 = call i32 @PyModule_AddIntConstant(ptr noundef %112, ptr noundef @.str.705, i64 noundef 33554432)
  %tobool446 = icmp ne i32 %call445, 0
  br i1 %tobool446, label %if.then447, label %if.end448

if.then447:                                       ; preds = %if.end444
  store i32 -1, ptr %retval, align 4
  br label %return

if.end448:                                        ; preds = %if.end444
  %113 = load ptr, ptr %m.addr, align 8
  %call449 = call i32 @PyModule_AddIntConstant(ptr noundef %113, ptr noundef @.str.706, i64 noundef 67108864)
  %tobool450 = icmp ne i32 %call449, 0
  br i1 %tobool450, label %if.then451, label %if.end452

if.then451:                                       ; preds = %if.end448
  store i32 -1, ptr %retval, align 4
  br label %return

if.end452:                                        ; preds = %if.end448
  %114 = load ptr, ptr %m.addr, align 8
  %call453 = call i32 @PyModule_AddIntConstant(ptr noundef %114, ptr noundef @.str.707, i64 noundef 134217728)
  %tobool454 = icmp ne i32 %call453, 0
  br i1 %tobool454, label %if.then455, label %if.end456

if.then455:                                       ; preds = %if.end452
  store i32 -1, ptr %retval, align 4
  br label %return

if.end456:                                        ; preds = %if.end452
  %115 = load ptr, ptr %m.addr, align 8
  %call457 = call i32 @PyModule_AddIntConstant(ptr noundef %115, ptr noundef @.str.708, i64 noundef 268435456)
  %tobool458 = icmp ne i32 %call457, 0
  br i1 %tobool458, label %if.then459, label %if.end460

if.then459:                                       ; preds = %if.end456
  store i32 -1, ptr %retval, align 4
  br label %return

if.end460:                                        ; preds = %if.end456
  %116 = load ptr, ptr %m.addr, align 8
  %call461 = call i32 @PyModule_AddIntConstant(ptr noundef %116, ptr noundef @.str.709, i64 noundef 536870912)
  %tobool462 = icmp ne i32 %call461, 0
  br i1 %tobool462, label %if.then463, label %if.end464

if.then463:                                       ; preds = %if.end460
  store i32 -1, ptr %retval, align 4
  br label %return

if.end464:                                        ; preds = %if.end460
  %117 = load ptr, ptr %m.addr, align 8
  %call465 = call i32 @PyModule_AddIntConstant(ptr noundef %117, ptr noundef @.str.710, i64 noundef 1073741824)
  %tobool466 = icmp ne i32 %call465, 0
  br i1 %tobool466, label %if.then467, label %if.end468

if.then467:                                       ; preds = %if.end464
  store i32 -1, ptr %retval, align 4
  br label %return

if.end468:                                        ; preds = %if.end464
  %118 = load ptr, ptr %m.addr, align 8
  %call469 = call i32 @PyModule_AddIntConstant(ptr noundef %118, ptr noundef @.str.711, i64 noundef 262144)
  %tobool470 = icmp ne i32 %call469, 0
  br i1 %tobool470, label %if.then471, label %if.end472

if.then471:                                       ; preds = %if.end468
  store i32 -1, ptr %retval, align 4
  br label %return

if.end472:                                        ; preds = %if.end468
  %119 = load ptr, ptr %m.addr, align 8
  %call473 = call i32 @PyModule_AddIntConstant(ptr noundef %119, ptr noundef @.str.712, i64 noundef 65536)
  %tobool474 = icmp ne i32 %call473, 0
  br i1 %tobool474, label %if.then475, label %if.end476

if.then475:                                       ; preds = %if.end472
  store i32 -1, ptr %retval, align 4
  br label %return

if.end476:                                        ; preds = %if.end472
  %120 = load ptr, ptr %m.addr, align 8
  %call477 = call i32 @PyModule_AddIntConstant(ptr noundef %120, ptr noundef @.str.713, i64 noundef 2048)
  %tobool478 = icmp ne i32 %call477, 0
  br i1 %tobool478, label %if.then479, label %if.end480

if.then479:                                       ; preds = %if.end476
  store i32 -1, ptr %retval, align 4
  br label %return

if.end480:                                        ; preds = %if.end476
  %121 = load ptr, ptr %m.addr, align 8
  %call481 = call i32 @PyModule_AddIntConstant(ptr noundef %121, ptr noundef @.str.714, i64 noundef 256)
  %tobool482 = icmp ne i32 %call481, 0
  br i1 %tobool482, label %if.then483, label %if.end484

if.then483:                                       ; preds = %if.end480
  store i32 -1, ptr %retval, align 4
  br label %return

if.end484:                                        ; preds = %if.end480
  %122 = load ptr, ptr %m.addr, align 8
  %call485 = call i32 @PyModule_AddIntConstant(ptr noundef %122, ptr noundef @.str.715, i64 noundef 1)
  %tobool486 = icmp ne i32 %call485, 0
  br i1 %tobool486, label %if.then487, label %if.end488

if.then487:                                       ; preds = %if.end484
  store i32 -1, ptr %retval, align 4
  br label %return

if.end488:                                        ; preds = %if.end484
  %123 = load ptr, ptr %m.addr, align 8
  %call489 = call i32 @PyModule_AddIntConstant(ptr noundef %123, ptr noundef @.str.716, i64 noundef 2)
  %tobool490 = icmp ne i32 %call489, 0
  br i1 %tobool490, label %if.then491, label %if.end492

if.then491:                                       ; preds = %if.end488
  store i32 -1, ptr %retval, align 4
  br label %return

if.end492:                                        ; preds = %if.end488
  %124 = load ptr, ptr %m.addr, align 8
  %call493 = call i32 @PyModule_AddIntConstant(ptr noundef %124, ptr noundef @.str.717, i64 noundef 65536)
  %tobool494 = icmp ne i32 %call493, 0
  br i1 %tobool494, label %if.then495, label %if.end496

if.then495:                                       ; preds = %if.end492
  store i32 -1, ptr %retval, align 4
  br label %return

if.end496:                                        ; preds = %if.end492
  %125 = load ptr, ptr %m.addr, align 8
  %call497 = call i32 @PyModule_AddIntConstant(ptr noundef %125, ptr noundef @.str.718, i64 noundef 1)
  %tobool498 = icmp ne i32 %call497, 0
  br i1 %tobool498, label %if.then499, label %if.end500

if.then499:                                       ; preds = %if.end496
  store i32 -1, ptr %retval, align 4
  br label %return

if.end500:                                        ; preds = %if.end496
  %126 = load ptr, ptr %m.addr, align 8
  %call501 = call i32 @PyModule_AddIntConstant(ptr noundef %126, ptr noundef @.str.719, i64 noundef 2)
  %tobool502 = icmp ne i32 %call501, 0
  br i1 %tobool502, label %if.then503, label %if.end504

if.then503:                                       ; preds = %if.end500
  store i32 -1, ptr %retval, align 4
  br label %return

if.end504:                                        ; preds = %if.end500
  %127 = load ptr, ptr %m.addr, align 8
  %call505 = call i32 @PyModule_AddIntConstant(ptr noundef %127, ptr noundef @.str.720, i64 noundef 256)
  %tobool506 = icmp ne i32 %call505, 0
  br i1 %tobool506, label %if.then507, label %if.end508

if.then507:                                       ; preds = %if.end504
  store i32 -1, ptr %retval, align 4
  br label %return

if.end508:                                        ; preds = %if.end504
  %128 = load ptr, ptr %m.addr, align 8
  %call509 = call i32 @PyModule_AddIntConstant(ptr noundef %128, ptr noundef @.str.721, i64 noundef 0)
  %tobool510 = icmp ne i32 %call509, 0
  br i1 %tobool510, label %if.then511, label %if.end512

if.then511:                                       ; preds = %if.end508
  store i32 -1, ptr %retval, align 4
  br label %return

if.end512:                                        ; preds = %if.end508
  %129 = load ptr, ptr %m.addr, align 8
  %call513 = call i32 @PyModule_AddIntConstant(ptr noundef %129, ptr noundef @.str.722, i64 noundef 4096)
  %tobool514 = icmp ne i32 %call513, 0
  br i1 %tobool514, label %if.then515, label %if.end516

if.then515:                                       ; preds = %if.end512
  store i32 -1, ptr %retval, align 4
  br label %return

if.end516:                                        ; preds = %if.end512
  %130 = load ptr, ptr %m.addr, align 8
  %call517 = call i32 @PyModule_AddIntConstant(ptr noundef %130, ptr noundef @.str.723, i64 noundef 4)
  %tobool518 = icmp ne i32 %call517, 0
  br i1 %tobool518, label %if.then519, label %if.end520

if.then519:                                       ; preds = %if.end516
  store i32 -1, ptr %retval, align 4
  br label %return

if.end520:                                        ; preds = %if.end516
  %131 = load ptr, ptr %m.addr, align 8
  %call521 = call i32 @PyModule_AddIntConstant(ptr noundef %131, ptr noundef @.str.724, i64 noundef 8)
  %tobool522 = icmp ne i32 %call521, 0
  br i1 %tobool522, label %if.then523, label %if.end524

if.then523:                                       ; preds = %if.end520
  store i32 -1, ptr %retval, align 4
  br label %return

if.end524:                                        ; preds = %if.end520
  %132 = load ptr, ptr %m.addr, align 8
  %call525 = call i32 @PyModule_AddIntConstant(ptr noundef %132, ptr noundef @.str.725, i64 noundef 2)
  %tobool526 = icmp ne i32 %call525, 0
  br i1 %tobool526, label %if.then527, label %if.end528

if.then527:                                       ; preds = %if.end524
  store i32 -1, ptr %retval, align 4
  br label %return

if.end528:                                        ; preds = %if.end524
  %133 = load ptr, ptr %m.addr, align 8
  %call529 = call i32 @PyModule_AddIntConstant(ptr noundef %133, ptr noundef @.str.726, i64 noundef 1)
  %tobool530 = icmp ne i32 %call529, 0
  br i1 %tobool530, label %if.then531, label %if.end532

if.then531:                                       ; preds = %if.end528
  store i32 -1, ptr %retval, align 4
  br label %return

if.end532:                                        ; preds = %if.end528
  %134 = load ptr, ptr %m.addr, align 8
  %call533 = call i32 @PyModule_AddIntConstant(ptr noundef %134, ptr noundef @.str.727, i64 noundef 1)
  %tobool534 = icmp ne i32 %call533, 0
  br i1 %tobool534, label %if.then535, label %if.end536

if.then535:                                       ; preds = %if.end532
  store i32 -1, ptr %retval, align 4
  br label %return

if.end536:                                        ; preds = %if.end532
  %135 = load ptr, ptr %m.addr, align 8
  %call537 = call i32 @PyModule_AddIntConstant(ptr noundef %135, ptr noundef @.str.728, i64 noundef 2)
  %tobool538 = icmp ne i32 %call537, 0
  br i1 %tobool538, label %if.then539, label %if.end540

if.then539:                                       ; preds = %if.end536
  store i32 -1, ptr %retval, align 4
  br label %return

if.end540:                                        ; preds = %if.end536
  %136 = load ptr, ptr %m.addr, align 8
  %call541 = call i32 @PyModule_AddIntConstant(ptr noundef %136, ptr noundef @.str.729, i64 noundef 4)
  %tobool542 = icmp ne i32 %call541, 0
  br i1 %tobool542, label %if.then543, label %if.end544

if.then543:                                       ; preds = %if.end540
  store i32 -1, ptr %retval, align 4
  br label %return

if.end544:                                        ; preds = %if.end540
  %137 = load ptr, ptr %m.addr, align 8
  %call545 = call i32 @PyModule_AddIntConstant(ptr noundef %137, ptr noundef @.str.730, i64 noundef 26)
  %tobool546 = icmp ne i32 %call545, 0
  br i1 %tobool546, label %if.then547, label %if.end548

if.then547:                                       ; preds = %if.end544
  store i32 -1, ptr %retval, align 4
  br label %return

if.end548:                                        ; preds = %if.end544
  %138 = load ptr, ptr %m.addr, align 8
  %call549 = call i32 @PyModule_AddIntConstant(ptr noundef %138, ptr noundef @.str.731, i64 noundef 63)
  %tobool550 = icmp ne i32 %call549, 0
  br i1 %tobool550, label %if.then551, label %if.end552

if.then551:                                       ; preds = %if.end548
  store i32 -1, ptr %retval, align 4
  br label %return

if.end552:                                        ; preds = %if.end548
  %139 = load ptr, ptr %m.addr, align 8
  %call553 = call i32 @PyModule_AddIntConstant(ptr noundef %139, ptr noundef @.str.732, i64 noundef 1073741824)
  %tobool554 = icmp ne i32 %call553, 0
  br i1 %tobool554, label %if.then555, label %if.end556

if.then555:                                       ; preds = %if.end552
  store i32 -1, ptr %retval, align 4
  br label %return

if.end556:                                        ; preds = %if.end552
  %140 = load ptr, ptr %m.addr, align 8
  %call557 = call i32 @PyModule_AddIntConstant(ptr noundef %140, ptr noundef @.str.733, i64 noundef 1275068416)
  %tobool558 = icmp ne i32 %call557, 0
  br i1 %tobool558, label %if.then559, label %if.end560

if.then559:                                       ; preds = %if.end556
  store i32 -1, ptr %retval, align 4
  br label %return

if.end560:                                        ; preds = %if.end556
  %141 = load ptr, ptr %m.addr, align 8
  %call561 = call i32 @PyModule_AddIntConstant(ptr noundef %141, ptr noundef @.str.734, i64 noundef 1342177280)
  %tobool562 = icmp ne i32 %call561, 0
  br i1 %tobool562, label %if.then563, label %if.end564

if.then563:                                       ; preds = %if.end560
  store i32 -1, ptr %retval, align 4
  br label %return

if.end564:                                        ; preds = %if.end560
  %142 = load ptr, ptr %m.addr, align 8
  %call565 = call i32 @PyModule_AddIntConstant(ptr noundef %142, ptr noundef @.str.735, i64 noundef 1409286144)
  %tobool566 = icmp ne i32 %call565, 0
  br i1 %tobool566, label %if.then567, label %if.end568

if.then567:                                       ; preds = %if.end564
  store i32 -1, ptr %retval, align 4
  br label %return

if.end568:                                        ; preds = %if.end564
  %143 = load ptr, ptr %m.addr, align 8
  %call569 = call i32 @PyModule_AddIntConstant(ptr noundef %143, ptr noundef @.str.736, i64 noundef 1543503872)
  %tobool570 = icmp ne i32 %call569, 0
  br i1 %tobool570, label %if.then571, label %if.end572

if.then571:                                       ; preds = %if.end568
  store i32 -1, ptr %retval, align 4
  br label %return

if.end572:                                        ; preds = %if.end568
  %144 = load ptr, ptr %m.addr, align 8
  %call573 = call i32 @PyModule_AddIntConstant(ptr noundef %144, ptr noundef @.str.737, i64 noundef 1610612736)
  %tobool574 = icmp ne i32 %call573, 0
  br i1 %tobool574, label %if.then575, label %if.end576

if.then575:                                       ; preds = %if.end572
  store i32 -1, ptr %retval, align 4
  br label %return

if.end576:                                        ; preds = %if.end572
  %145 = load ptr, ptr %m.addr, align 8
  %call577 = call i32 @PyModule_AddIntConstant(ptr noundef %145, ptr noundef @.str.738, i64 noundef 1677721600)
  %tobool578 = icmp ne i32 %call577, 0
  br i1 %tobool578, label %if.then579, label %if.end580

if.then579:                                       ; preds = %if.end576
  store i32 -1, ptr %retval, align 4
  br label %return

if.end580:                                        ; preds = %if.end576
  %146 = load ptr, ptr %m.addr, align 8
  %call581 = call i32 @PyModule_AddIntConstant(ptr noundef %146, ptr noundef @.str.739, i64 noundef 1879048192)
  %tobool582 = icmp ne i32 %call581, 0
  br i1 %tobool582, label %if.then583, label %if.end584

if.then583:                                       ; preds = %if.end580
  store i32 -1, ptr %retval, align 4
  br label %return

if.end584:                                        ; preds = %if.end580
  %147 = load ptr, ptr %m.addr, align 8
  %call585 = call i32 @PyModule_AddIntConstant(ptr noundef %147, ptr noundef @.str.740, i64 noundef 1946157056)
  %tobool586 = icmp ne i32 %call585, 0
  br i1 %tobool586, label %if.then587, label %if.end588

if.then587:                                       ; preds = %if.end584
  store i32 -1, ptr %retval, align 4
  br label %return

if.end588:                                        ; preds = %if.end584
  %148 = load ptr, ptr %m.addr, align 8
  %call589 = call i32 @PyModule_AddIntConstant(ptr noundef %148, ptr noundef @.str.741, i64 noundef 2013265920)
  %tobool590 = icmp ne i32 %call589, 0
  br i1 %tobool590, label %if.then591, label %if.end592

if.then591:                                       ; preds = %if.end588
  store i32 -1, ptr %retval, align 4
  br label %return

if.end592:                                        ; preds = %if.end588
  %149 = load ptr, ptr %m.addr, align 8
  %call593 = call i32 @PyModule_AddIntConstant(ptr noundef %149, ptr noundef @.str.742, i64 noundef 2080374784)
  %tobool594 = icmp ne i32 %call593, 0
  br i1 %tobool594, label %if.then595, label %if.end596

if.then595:                                       ; preds = %if.end592
  store i32 -1, ptr %retval, align 4
  br label %return

if.end596:                                        ; preds = %if.end592
  %150 = load ptr, ptr %m.addr, align 8
  %call597 = call i32 @PyModule_AddIntConstant(ptr noundef %150, ptr noundef @.str.743, i64 noundef -2013265920)
  %tobool598 = icmp ne i32 %call597, 0
  br i1 %tobool598, label %if.then599, label %if.end600

if.then599:                                       ; preds = %if.end596
  store i32 -1, ptr %retval, align 4
  br label %return

if.end600:                                        ; preds = %if.end596
  %151 = load ptr, ptr %m.addr, align 8
  %call601 = call i32 @PyModule_AddIntConstant(ptr noundef %151, ptr noundef @.str.744, i64 noundef 524288)
  %tobool602 = icmp ne i32 %call601, 0
  br i1 %tobool602, label %if.then603, label %if.end604

if.then603:                                       ; preds = %if.end600
  store i32 -1, ptr %retval, align 4
  br label %return

if.end604:                                        ; preds = %if.end600
  %152 = load ptr, ptr %m.addr, align 8
  %call605 = call i32 @PyModule_AddIntConstant(ptr noundef %152, ptr noundef @.str.745, i64 noundef 2048)
  %tobool606 = icmp ne i32 %call605, 0
  br i1 %tobool606, label %if.then607, label %if.end608

if.then607:                                       ; preds = %if.end604
  store i32 -1, ptr %retval, align 4
  br label %return

if.end608:                                        ; preds = %if.end604
  %153 = load ptr, ptr %m.addr, align 8
  %call609 = call i32 @PyModule_AddIntConstant(ptr noundef %153, ptr noundef @.str.746, i64 noundef 1)
  %tobool610 = icmp ne i32 %call609, 0
  br i1 %tobool610, label %if.then611, label %if.end612

if.then611:                                       ; preds = %if.end608
  store i32 -1, ptr %retval, align 4
  br label %return

if.end612:                                        ; preds = %if.end608
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end612, %if.then611, %if.then607, %if.then603, %if.then599, %if.then595, %if.then591, %if.then587, %if.then583, %if.then579, %if.then575, %if.then571, %if.then567, %if.then563, %if.then559, %if.then555, %if.then551, %if.then547, %if.then543, %if.then539, %if.then535, %if.then531, %if.then527, %if.then523, %if.then519, %if.then515, %if.then511, %if.then507, %if.then503, %if.then499, %if.then495, %if.then491, %if.then487, %if.then483, %if.then479, %if.then475, %if.then471, %if.then467, %if.then463, %if.then459, %if.then455, %if.then451, %if.then447, %if.then443, %if.then439, %if.then435, %if.then431, %if.then427, %if.then423, %if.then419, %if.then415, %if.then411, %if.then407, %if.then403, %if.then399, %if.then395, %if.then391, %if.then387, %if.then383, %if.then379, %if.then375, %if.then371, %if.then367, %if.then363, %if.then359, %if.then355, %if.then351, %if.then347, %if.then343, %if.then339, %if.then335, %if.then331, %if.then327, %if.then323, %if.then319, %if.then315, %if.then311, %if.then307, %if.then303, %if.then299, %if.then295, %if.then291, %if.then287, %if.then283, %if.then279, %if.then275, %if.then271, %if.then267, %if.then263, %if.then259, %if.then255, %if.then251, %if.then247, %if.then243, %if.then239, %if.then235, %if.then231, %if.then227, %if.then223, %if.then219, %if.then215, %if.then211, %if.then207, %if.then203, %if.then199, %if.then195, %if.then191, %if.then187, %if.then183, %if.then179, %if.then175, %if.then171, %if.then167, %if.then163, %if.then159, %if.then155, %if.then151, %if.then147, %if.then143, %if.then139, %if.then135, %if.then131, %if.then127, %if.then123, %if.then119, %if.then115, %if.then111, %if.then107, %if.then103, %if.then99, %if.then95, %if.then91, %if.then87, %if.then83, %if.then79, %if.then75, %if.then71, %if.then67, %if.then63, %if.then59, %if.then55, %if.then51, %if.then47, %if.then43, %if.then39, %if.then35, %if.then31, %if.then27, %if.then23, %if.then19, %if.then15, %if.then11, %if.then7, %if.then3, %if.then
  %154 = load i32, ptr %retval, align 4
  ret i32 %154
}

; Function Attrs: nounwind uwtable
define internal i32 @setup_confname_tables(ptr noundef %module) #0 {
entry:
  %retval = alloca i32, align 4
  %module.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %call = call i32 @setup_confname_table(ptr noundef @posix_constants_pathconf, i64 noundef 20, ptr noundef @.str.747, ptr noundef %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %module.addr, align 8
  %call1 = call i32 @setup_confname_table(ptr noundef @posix_constants_confstr, i64 noundef 27, ptr noundef @.str.748, ptr noundef %1)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store i32 -1, ptr %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  %2 = load ptr, ptr %module.addr, align 8
  %call5 = call i32 @setup_confname_table(ptr noundef @posix_constants_sysconf, i64 noundef 135, ptr noundef @.str.749, ptr noundef %2)
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end4
  store i32 -1, ptr %retval, align 4
  br label %return

if.end8:                                          ; preds = %if.end4
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end8, %if.then7, %if.then3, %if.then
  %3 = load i32, ptr %retval, align 4
  ret i32 %3
}

declare i32 @PyModule_AddObjectRef(ptr noundef, ptr noundef, ptr noundef) #1

declare ptr @PyStructSequence_NewType(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @statresult_new(ptr noundef %type, ptr noundef %args, ptr noundef %kwds) #0 {
entry:
  %op.addr.i31 = alloca ptr, align 8
  %op.addr.i29 = alloca ptr, align 8
  %op.addr.i20 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %type.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %kwds.addr = alloca ptr, align 8
  %result = alloca ptr, align 8
  %i = alloca i32, align 4
  %mod = alloca ptr, align 8
  %state = alloca ptr, align 8
  store ptr %type, ptr %type.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store ptr %kwds, ptr %kwds.addr, align 8
  %call = call ptr @PyImport_GetModule(ptr noundef getelementptr inbounds (%struct.anon.44, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 37), i32 0, i32 3, i32 1, i32 553))
  store ptr %call, ptr %mod, align 8
  %0 = load ptr, ptr %mod, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %mod, align 8
  %call1 = call ptr @get_posix_state(ptr noundef %1)
  store ptr %call1, ptr %state, align 8
  %2 = load ptr, ptr %mod, align 8
  store ptr %2, ptr %op.addr.i20, align 8
  %3 = load ptr, ptr %op.addr.i20, align 8
  store ptr %3, ptr %op.addr.i29, align 8
  %4 = load ptr, ptr %op.addr.i29, align 8
  %5 = load i64, ptr %4, align 8
  %conv.i = trunc i64 %5 to i32
  %cmp.i30 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i30 to i32
  %tobool.i22 = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i22, label %if.then.i27, label %if.end.i23

if.then.i27:                                      ; preds = %if.end
  br label %Py_DECREF.exit28

if.end.i23:                                       ; preds = %if.end
  %6 = load ptr, ptr %op.addr.i20, align 8
  %7 = load i64, ptr %6, align 8
  %dec.i24 = add i64 %7, -1
  store i64 %dec.i24, ptr %6, align 8
  %cmp.i25 = icmp eq i64 %dec.i24, 0
  br i1 %cmp.i25, label %if.then1.i26, label %Py_DECREF.exit28

if.then1.i26:                                     ; preds = %if.end.i23
  %8 = load ptr, ptr %op.addr.i20, align 8
  call void @_Py_Dealloc(ptr noundef %8) #10
  br label %Py_DECREF.exit28

Py_DECREF.exit28:                                 ; preds = %if.then1.i26, %if.end.i23, %if.then.i27
  %9 = load ptr, ptr %state, align 8
  %cmp2 = icmp eq ptr %9, null
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %Py_DECREF.exit28
  store ptr null, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %Py_DECREF.exit28
  %10 = load ptr, ptr %state, align 8
  %statresult_new_orig = getelementptr inbounds %struct._posixstate, ptr %10, i32 0, i32 4
  %11 = load ptr, ptr %statresult_new_orig, align 8
  %12 = load ptr, ptr %type.addr, align 8
  %13 = load ptr, ptr %args.addr, align 8
  %14 = load ptr, ptr %kwds.addr, align 8
  %call5 = call ptr %11(ptr noundef %12, ptr noundef %13, ptr noundef %14)
  store ptr %call5, ptr %result, align 8
  %15 = load ptr, ptr %result, align 8
  %tobool = icmp ne ptr %15, null
  br i1 %tobool, label %if.end7, label %if.then6

if.then6:                                         ; preds = %if.end4
  store ptr null, ptr %retval, align 8
  br label %return

if.end7:                                          ; preds = %if.end4
  store i32 7, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end7
  %16 = load i32, ptr %i, align 4
  %cmp8 = icmp sle i32 %16, 9
  br i1 %cmp8, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %17 = load ptr, ptr %result, align 8
  %ob_item = getelementptr inbounds %struct.PyTupleObject, ptr %17, i32 0, i32 1
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 3
  %idxprom = sext i32 %add to i64
  %arrayidx = getelementptr [1 x ptr], ptr %ob_item, i64 0, i64 %idxprom
  %19 = load ptr, ptr %arrayidx, align 8
  %cmp9 = icmp eq ptr %19, @_Py_NoneStruct
  br i1 %cmp9, label %if.then10, label %if.end19

if.then10:                                        ; preds = %for.body
  store ptr @_Py_NoneStruct, ptr %op.addr.i, align 8
  %20 = load ptr, ptr %op.addr.i, align 8
  store ptr %20, ptr %op.addr.i31, align 8
  %21 = load ptr, ptr %op.addr.i31, align 8
  %22 = load i64, ptr %21, align 8
  %conv.i32 = trunc i64 %22 to i32
  %cmp.i33 = icmp slt i32 %conv.i32, 0
  %conv1.i34 = zext i1 %cmp.i33 to i32
  %tobool.i = icmp ne i32 %conv1.i34, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then10
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.then10
  %23 = load ptr, ptr %op.addr.i, align 8
  %24 = load i64, ptr %23, align 8
  %dec.i = add i64 %24, -1
  store i64 %dec.i, ptr %23, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %25 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %25) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  %26 = load ptr, ptr %result, align 8
  %ob_item11 = getelementptr inbounds %struct.PyTupleObject, ptr %26, i32 0, i32 1
  %27 = load i32, ptr %i, align 4
  %idxprom12 = sext i32 %27 to i64
  %arrayidx13 = getelementptr [1 x ptr], ptr %ob_item11, i64 0, i64 %idxprom12
  %28 = load ptr, ptr %arrayidx13, align 8
  %call14 = call ptr @_Py_NewRef(ptr noundef %28)
  %29 = load ptr, ptr %result, align 8
  %ob_item15 = getelementptr inbounds %struct.PyTupleObject, ptr %29, i32 0, i32 1
  %30 = load i32, ptr %i, align 4
  %add16 = add i32 %30, 3
  %idxprom17 = sext i32 %add16 to i64
  %arrayidx18 = getelementptr [1 x ptr], ptr %ob_item15, i64 0, i64 %idxprom17
  store ptr %call14, ptr %arrayidx18, align 8
  br label %if.end19

if.end19:                                         ; preds = %Py_DECREF.exit, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end19
  %31 = load i32, ptr %i, align 4
  %inc = add i32 %31, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !53

for.end:                                          ; preds = %for.cond
  %32 = load ptr, ptr %result, align 8
  store ptr %32, ptr %retval, align 8
  br label %return

return:                                           ; preds = %for.end, %if.then6, %if.then3, %if.then
  %33 = load ptr, ptr %retval, align 8
  ret ptr %33
}

; Function Attrs: nounwind uwtable
define internal ptr @os_sched_param(ptr noundef %type, ptr noundef %args, ptr noundef %kwargs) #0 {
entry:
  %type.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %kwargs.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [1 x ptr], align 8
  %fastargs = alloca ptr, align 8
  %nargs = alloca i64, align 8
  %sched_priority = alloca ptr, align 8
  store ptr %type, ptr %type.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store ptr %kwargs, ptr %kwargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %args.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %0)
  store i64 %call, ptr %nargs, align 8
  %1 = load ptr, ptr %kwargs.addr, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %2 = load i64, ptr %nargs, align 8
  %cmp1 = icmp sle i64 1, %2
  br i1 %cmp1, label %land.lhs.true2, label %cond.false

land.lhs.true2:                                   ; preds = %land.lhs.true
  %3 = load i64, ptr %nargs, align 8
  %cmp3 = icmp sle i64 %3, 1
  br i1 %cmp3, label %land.lhs.true4, label %cond.false

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %4 = load ptr, ptr %args.addr, align 8
  %ob_item = getelementptr inbounds %struct.PyTupleObject, ptr %4, i32 0, i32 1
  %arraydecay = getelementptr inbounds [1 x ptr], ptr %ob_item, i64 0, i64 0
  %cmp5 = icmp ne ptr %arraydecay, null
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true4
  %5 = load ptr, ptr %args.addr, align 8
  %ob_item6 = getelementptr inbounds %struct.PyTupleObject, ptr %5, i32 0, i32 1
  %arraydecay7 = getelementptr inbounds [1 x ptr], ptr %ob_item6, i64 0, i64 0
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  %6 = load ptr, ptr %args.addr, align 8
  %ob_item8 = getelementptr inbounds %struct.PyTupleObject, ptr %6, i32 0, i32 1
  %arraydecay9 = getelementptr inbounds [1 x ptr], ptr %ob_item8, i64 0, i64 0
  %7 = load i64, ptr %nargs, align 8
  %8 = load ptr, ptr %kwargs.addr, align 8
  %arraydecay10 = getelementptr inbounds [1 x ptr], ptr %argsbuf, i64 0, i64 0
  %call11 = call ptr @_PyArg_UnpackKeywords(ptr noundef %arraydecay9, i64 noundef %7, ptr noundef %8, ptr noundef null, ptr noundef @os_sched_param._parser, i32 noundef 1, i32 noundef 1, i32 noundef 0, ptr noundef %arraydecay10)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %arraydecay7, %cond.true ], [ %call11, %cond.false ]
  store ptr %cond, ptr %fastargs, align 8
  %9 = load ptr, ptr %fastargs, align 8
  %tobool = icmp ne ptr %9, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  br label %exit

if.end:                                           ; preds = %cond.end
  %10 = load ptr, ptr %fastargs, align 8
  %arrayidx = getelementptr ptr, ptr %10, i64 0
  %11 = load ptr, ptr %arrayidx, align 8
  store ptr %11, ptr %sched_priority, align 8
  %12 = load ptr, ptr %type.addr, align 8
  %13 = load ptr, ptr %sched_priority, align 8
  %call12 = call ptr @os_sched_param_impl(ptr noundef %12, ptr noundef %13)
  store ptr %call12, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end, %if.then
  %14 = load ptr, ptr %return_value, align 8
  ret ptr %14
}

declare ptr @PyType_FromModuleAndSpec(ptr noundef, ptr noundef, ptr noundef) #1

declare ptr @PyUnicode_InternFromString(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal i32 @fd_specified(ptr noundef %function_name, i32 noundef %fd) #0 {
entry:
  %retval = alloca i32, align 4
  %function_name.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  store ptr %function_name, ptr %function_name.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  %0 = load i32, ptr %fd.addr, align 4
  %cmp = icmp eq i32 %0, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %function_name.addr, align 8
  call void @argument_unavailable_error(ptr noundef %1, ptr noundef @.str.208)
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load i32, ptr %retval, align 4
  ret i32 %2
}

; Function Attrs: nounwind uwtable
define internal i32 @dir_fd_unavailable(ptr noundef %o, ptr noundef %p) #0 {
entry:
  %retval = alloca i32, align 4
  %o.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %dir_fd = alloca i32, align 4
  store ptr %o, ptr %o.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %o.addr, align 8
  %call = call i32 @dir_fd_converter(ptr noundef %0, ptr noundef %dir_fd)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, ptr %dir_fd, align 4
  %cmp = icmp ne i32 %1, -100
  br i1 %cmp, label %if.then1, label %if.end2

if.then1:                                         ; preds = %if.end
  call void @argument_unavailable_error(ptr noundef null, ptr noundef @.str.184)
  store i32 0, ptr %retval, align 4
  br label %return

if.end2:                                          ; preds = %if.end
  %2 = load i32, ptr %dir_fd, align 4
  %3 = load ptr, ptr %p.addr, align 8
  store i32 %2, ptr %3, align 4
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end2, %if.then1, %if.then
  %4 = load i32, ptr %retval, align 4
  ret i32 %4
}

declare ptr @PyUnicode_DecodeASCII(ptr noundef, i64 noundef, ptr noundef) #1

declare i32 @_Py_GetTicksPerSecond(ptr noundef) #1

declare ptr @PyDict_New() #1

declare ptr @PyDict_SetDefault(ptr noundef, ptr noundef, ptr noundef) #1

declare i32 @PyModule_AddIntConstant(ptr noundef, ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define internal i32 @setup_confname_table(ptr noundef %table, i64 noundef %tablesize, ptr noundef %tablename, ptr noundef %module) #0 {
entry:
  %op.addr.i23 = alloca ptr, align 8
  %op.addr.i21 = alloca ptr, align 8
  %op.addr.i12 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca i32, align 4
  %table.addr = alloca ptr, align 8
  %tablesize.addr = alloca i64, align 8
  %tablename.addr = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %d = alloca ptr, align 8
  %i = alloca i64, align 8
  %o = alloca ptr, align 8
  store ptr %table, ptr %table.addr, align 8
  store i64 %tablesize, ptr %tablesize.addr, align 8
  store ptr %tablename, ptr %tablename.addr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr null, ptr %d, align 8
  %0 = load ptr, ptr %table.addr, align 8
  %1 = load i64, ptr %tablesize.addr, align 8
  call void @qsort(ptr noundef %0, i64 noundef %1, i64 noundef 16, ptr noundef @cmp_constdefs)
  %call = call ptr @PyDict_New()
  store ptr %call, ptr %d, align 8
  %2 = load ptr, ptr %d, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %3 = load i64, ptr %i, align 8
  %4 = load i64, ptr %tablesize.addr, align 8
  %cmp1 = icmp ult i64 %3, %4
  br i1 %cmp1, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load ptr, ptr %table.addr, align 8
  %6 = load i64, ptr %i, align 8
  %arrayidx = getelementptr %struct.constdef, ptr %5, i64 %6
  %value = getelementptr inbounds %struct.constdef, ptr %arrayidx, i32 0, i32 1
  %7 = load i32, ptr %value, align 8
  %conv = sext i32 %7 to i64
  %call2 = call ptr @PyLong_FromLong(i64 noundef %conv)
  store ptr %call2, ptr %o, align 8
  %8 = load ptr, ptr %o, align 8
  %cmp3 = icmp eq ptr %8, null
  br i1 %cmp3, label %if.then9, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %9 = load ptr, ptr %d, align 8
  %10 = load ptr, ptr %table.addr, align 8
  %11 = load i64, ptr %i, align 8
  %arrayidx5 = getelementptr %struct.constdef, ptr %10, i64 %11
  %name = getelementptr inbounds %struct.constdef, ptr %arrayidx5, i32 0, i32 0
  %12 = load ptr, ptr %name, align 8
  %13 = load ptr, ptr %o, align 8
  %call6 = call i32 @PyDict_SetItemString(ptr noundef %9, ptr noundef %12, ptr noundef %13)
  %cmp7 = icmp eq i32 %call6, -1
  br i1 %cmp7, label %if.then9, label %if.end10

if.then9:                                         ; preds = %lor.lhs.false, %for.body
  %14 = load ptr, ptr %o, align 8
  call void @Py_XDECREF(ptr noundef %14)
  %15 = load ptr, ptr %d, align 8
  store ptr %15, ptr %op.addr.i12, align 8
  %16 = load ptr, ptr %op.addr.i12, align 8
  store ptr %16, ptr %op.addr.i21, align 8
  %17 = load ptr, ptr %op.addr.i21, align 8
  %18 = load i64, ptr %17, align 8
  %conv.i = trunc i64 %18 to i32
  %cmp.i22 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i22 to i32
  %tobool.i14 = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i14, label %if.then.i19, label %if.end.i15

if.then.i19:                                      ; preds = %if.then9
  br label %Py_DECREF.exit20

if.end.i15:                                       ; preds = %if.then9
  %19 = load ptr, ptr %op.addr.i12, align 8
  %20 = load i64, ptr %19, align 8
  %dec.i16 = add i64 %20, -1
  store i64 %dec.i16, ptr %19, align 8
  %cmp.i17 = icmp eq i64 %dec.i16, 0
  br i1 %cmp.i17, label %if.then1.i18, label %Py_DECREF.exit20

if.then1.i18:                                     ; preds = %if.end.i15
  %21 = load ptr, ptr %op.addr.i12, align 8
  call void @_Py_Dealloc(ptr noundef %21) #10
  br label %Py_DECREF.exit20

Py_DECREF.exit20:                                 ; preds = %if.then1.i18, %if.end.i15, %if.then.i19
  store i32 -1, ptr %retval, align 4
  br label %return

if.end10:                                         ; preds = %lor.lhs.false
  %22 = load ptr, ptr %o, align 8
  store ptr %22, ptr %op.addr.i, align 8
  %23 = load ptr, ptr %op.addr.i, align 8
  store ptr %23, ptr %op.addr.i23, align 8
  %24 = load ptr, ptr %op.addr.i23, align 8
  %25 = load i64, ptr %24, align 8
  %conv.i24 = trunc i64 %25 to i32
  %cmp.i25 = icmp slt i32 %conv.i24, 0
  %conv1.i26 = zext i1 %cmp.i25 to i32
  %tobool.i = icmp ne i32 %conv1.i26, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.end10
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.end10
  %26 = load ptr, ptr %op.addr.i, align 8
  %27 = load i64, ptr %26, align 8
  %dec.i = add i64 %27, -1
  store i64 %dec.i, ptr %26, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %28 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %28) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  br label %for.inc

for.inc:                                          ; preds = %Py_DECREF.exit
  %29 = load i64, ptr %i, align 8
  %inc = add i64 %29, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !54

for.end:                                          ; preds = %for.cond
  %30 = load ptr, ptr %module.addr, align 8
  %31 = load ptr, ptr %tablename.addr, align 8
  %32 = load ptr, ptr %d, align 8
  %call11 = call i32 @PyModule_Add(ptr noundef %30, ptr noundef %31, ptr noundef %32)
  store i32 %call11, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %Py_DECREF.exit20, %if.then
  %33 = load i32, ptr %retval, align 4
  ret i32 %33
}

declare void @qsort(ptr noundef, i64 noundef, i64 noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal i32 @cmp_constdefs(ptr noundef %v1, ptr noundef %v2) #0 {
entry:
  %v1.addr = alloca ptr, align 8
  %v2.addr = alloca ptr, align 8
  %c1 = alloca ptr, align 8
  %c2 = alloca ptr, align 8
  store ptr %v1, ptr %v1.addr, align 8
  store ptr %v2, ptr %v2.addr, align 8
  %0 = load ptr, ptr %v1.addr, align 8
  store ptr %0, ptr %c1, align 8
  %1 = load ptr, ptr %v2.addr, align 8
  store ptr %1, ptr %c2, align 8
  %2 = load ptr, ptr %c1, align 8
  %name = getelementptr inbounds %struct.constdef, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %name, align 8
  %4 = load ptr, ptr %c2, align 8
  %name1 = getelementptr inbounds %struct.constdef, ptr %4, i32 0, i32 0
  %5 = load ptr, ptr %name1, align 8
  %call = call i32 @strcmp(ptr noundef %3, ptr noundef %5) #13
  ret i32 %call
}

declare i32 @PyDict_SetItemString(ptr noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @os_sched_param_impl(ptr noundef %type, ptr noundef %sched_priority) #0 {
entry:
  %retval = alloca ptr, align 8
  %type.addr = alloca ptr, align 8
  %sched_priority.addr = alloca ptr, align 8
  %res = alloca ptr, align 8
  store ptr %type, ptr %type.addr, align 8
  store ptr %sched_priority, ptr %sched_priority.addr, align 8
  %0 = load ptr, ptr %type.addr, align 8
  %call = call ptr @PyStructSequence_New(ptr noundef %0)
  store ptr %call, ptr %res, align 8
  %1 = load ptr, ptr %res, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %res, align 8
  %3 = load ptr, ptr %sched_priority.addr, align 8
  %call1 = call ptr @_Py_NewRef(ptr noundef %3)
  call void @PyStructSequence_SetItem(ptr noundef %2, i64 noundef 0, ptr noundef %call1)
  %4 = load ptr, ptr %res, align 8
  store ptr %4, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %5 = load ptr, ptr %retval, align 8
  ret ptr %5
}

; Function Attrs: nounwind uwtable
define internal void @ScandirIterator_dealloc(ptr noundef %iterator) #0 {
entry:
  %op.addr.i3 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %iterator.addr = alloca ptr, align 8
  %tp = alloca ptr, align 8
  %free_func = alloca ptr, align 8
  store ptr %iterator, ptr %iterator.addr, align 8
  %0 = load ptr, ptr %iterator.addr, align 8
  %call = call ptr @Py_TYPE(ptr noundef %0)
  store ptr %call, ptr %tp, align 8
  %1 = load ptr, ptr %iterator.addr, align 8
  %call1 = call i32 @PyObject_CallFinalizerFromDealloc(ptr noundef %1)
  %cmp = icmp slt i32 %call1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %tp, align 8
  %call2 = call ptr @PyType_GetSlot(ptr noundef %2, i32 noundef 74)
  store ptr %call2, ptr %free_func, align 8
  %3 = load ptr, ptr %free_func, align 8
  %4 = load ptr, ptr %iterator.addr, align 8
  call void %3(ptr noundef %4)
  %5 = load ptr, ptr %tp, align 8
  store ptr %5, ptr %op.addr.i, align 8
  %6 = load ptr, ptr %op.addr.i, align 8
  store ptr %6, ptr %op.addr.i3, align 8
  %7 = load ptr, ptr %op.addr.i3, align 8
  %8 = load i64, ptr %7, align 8
  %conv.i = trunc i64 %8 to i32
  %cmp.i4 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i4 to i32
  %tobool.i = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.end
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.end
  %9 = load ptr, ptr %op.addr.i, align 8
  %10 = load i64, ptr %9, align 8
  %dec.i = add i64 %10, -1
  store i64 %dec.i, ptr %9, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %11 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %11) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  br label %return

return:                                           ; preds = %Py_DECREF.exit, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @ScandirIterator_finalize(ptr noundef %iterator) #0 {
entry:
  %iterator.addr = alloca ptr, align 8
  %exc = alloca ptr, align 8
  store ptr %iterator, ptr %iterator.addr, align 8
  %call = call ptr @PyErr_GetRaisedException()
  store ptr %call, ptr %exc, align 8
  %0 = load ptr, ptr %iterator.addr, align 8
  %call1 = call i32 @ScandirIterator_is_closed(ptr noundef %0)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.end9, label %if.then

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %iterator.addr, align 8
  call void @ScandirIterator_closedir(ptr noundef %1)
  %2 = load ptr, ptr %iterator.addr, align 8
  %3 = load ptr, ptr %iterator.addr, align 8
  %call2 = call i32 (ptr, i64, ptr, ...) @PyErr_ResourceWarning(ptr noundef %2, i64 noundef 1, ptr noundef @.str.807, ptr noundef %3)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %if.then4, label %if.end8

if.then4:                                         ; preds = %if.then
  %4 = load ptr, ptr @PyExc_Warning, align 8
  %call5 = call i32 @PyErr_ExceptionMatches(ptr noundef %4)
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %if.then7, label %if.end

if.then7:                                         ; preds = %if.then4
  %5 = load ptr, ptr %iterator.addr, align 8
  call void @PyErr_WriteUnraisable(ptr noundef %5)
  br label %if.end

if.end:                                           ; preds = %if.then7, %if.then4
  br label %if.end8

if.end8:                                          ; preds = %if.end, %if.then
  br label %if.end9

if.end9:                                          ; preds = %if.end8, %entry
  %6 = load ptr, ptr %iterator.addr, align 8
  %path = getelementptr inbounds %struct.ScandirIterator, ptr %6, i32 0, i32 1
  call void @path_cleanup(ptr noundef %path)
  %7 = load ptr, ptr %exc, align 8
  call void @PyErr_SetRaisedException(ptr noundef %7)
  ret void
}

declare ptr @PyObject_SelfIter(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @ScandirIterator_iternext(ptr noundef %iterator) #0 {
entry:
  %retval = alloca ptr, align 8
  %iterator.addr = alloca ptr, align 8
  %direntp = alloca ptr, align 8
  %name_len = alloca i64, align 8
  %is_dot = alloca i32, align 4
  %entry1 = alloca ptr, align 8
  %_save = alloca ptr, align 8
  %module = alloca ptr, align 8
  store ptr %iterator, ptr %iterator.addr, align 8
  %0 = load ptr, ptr %iterator.addr, align 8
  %dirp = getelementptr inbounds %struct.ScandirIterator, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %dirp, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  br label %while.body

while.body:                                       ; preds = %if.end38, %if.end
  %call = call ptr @__errno_location() #12
  store i32 0, ptr %call, align 4
  %call2 = call ptr @PyEval_SaveThread()
  store ptr %call2, ptr %_save, align 8
  %2 = load ptr, ptr %iterator.addr, align 8
  %dirp3 = getelementptr inbounds %struct.ScandirIterator, ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %dirp3, align 8
  %call4 = call ptr @readdir64(ptr noundef %3)
  store ptr %call4, ptr %direntp, align 8
  %4 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %4)
  %5 = load ptr, ptr %direntp, align 8
  %tobool5 = icmp ne ptr %5, null
  br i1 %tobool5, label %if.end11, label %if.then6

if.then6:                                         ; preds = %while.body
  %call7 = call ptr @__errno_location() #12
  %6 = load i32, ptr %call7, align 4
  %cmp = icmp ne i32 %6, 0
  br i1 %cmp, label %if.then8, label %if.end10

if.then8:                                         ; preds = %if.then6
  %7 = load ptr, ptr %iterator.addr, align 8
  %path = getelementptr inbounds %struct.ScandirIterator, ptr %7, i32 0, i32 1
  %call9 = call ptr @path_error(ptr noundef %path)
  br label %if.end10

if.end10:                                         ; preds = %if.then8, %if.then6
  br label %while.end

if.end11:                                         ; preds = %while.body
  %8 = load ptr, ptr %direntp, align 8
  %d_name = getelementptr inbounds %struct.dirent, ptr %8, i32 0, i32 4
  %arraydecay = getelementptr inbounds [256 x i8], ptr %d_name, i64 0, i64 0
  %call12 = call i64 @strlen(ptr noundef %arraydecay) #13
  store i64 %call12, ptr %name_len, align 8
  %9 = load ptr, ptr %direntp, align 8
  %d_name13 = getelementptr inbounds %struct.dirent, ptr %9, i32 0, i32 4
  %arrayidx = getelementptr [256 x i8], ptr %d_name13, i64 0, i64 0
  %10 = load i8, ptr %arrayidx, align 1
  %conv = sext i8 %10 to i32
  %cmp14 = icmp eq i32 %conv, 46
  br i1 %cmp14, label %land.rhs, label %land.end26

land.rhs:                                         ; preds = %if.end11
  %11 = load i64, ptr %name_len, align 8
  %cmp16 = icmp eq i64 %11, 1
  br i1 %cmp16, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.rhs
  %12 = load ptr, ptr %direntp, align 8
  %d_name18 = getelementptr inbounds %struct.dirent, ptr %12, i32 0, i32 4
  %arrayidx19 = getelementptr [256 x i8], ptr %d_name18, i64 0, i64 1
  %13 = load i8, ptr %arrayidx19, align 1
  %conv20 = sext i8 %13 to i32
  %cmp21 = icmp eq i32 %conv20, 46
  br i1 %cmp21, label %land.rhs23, label %land.end

land.rhs23:                                       ; preds = %lor.rhs
  %14 = load i64, ptr %name_len, align 8
  %cmp24 = icmp eq i64 %14, 2
  br label %land.end

land.end:                                         ; preds = %land.rhs23, %lor.rhs
  %15 = phi i1 [ false, %lor.rhs ], [ %cmp24, %land.rhs23 ]
  br label %lor.end

lor.end:                                          ; preds = %land.end, %land.rhs
  %16 = phi i1 [ true, %land.rhs ], [ %15, %land.end ]
  br label %land.end26

land.end26:                                       ; preds = %lor.end, %if.end11
  %17 = phi i1 [ false, %if.end11 ], [ %16, %lor.end ]
  %land.ext = zext i1 %17 to i32
  store i32 %land.ext, ptr %is_dot, align 4
  %18 = load i32, ptr %is_dot, align 4
  %tobool27 = icmp ne i32 %18, 0
  br i1 %tobool27, label %if.end38, label %if.then28

if.then28:                                        ; preds = %land.end26
  %19 = load ptr, ptr %iterator.addr, align 8
  %call29 = call ptr @Py_TYPE(ptr noundef %19)
  %call30 = call ptr @PyType_GetModule(ptr noundef %call29)
  store ptr %call30, ptr %module, align 8
  %20 = load ptr, ptr %module, align 8
  %21 = load ptr, ptr %iterator.addr, align 8
  %path31 = getelementptr inbounds %struct.ScandirIterator, ptr %21, i32 0, i32 1
  %22 = load ptr, ptr %direntp, align 8
  %d_name32 = getelementptr inbounds %struct.dirent, ptr %22, i32 0, i32 4
  %arraydecay33 = getelementptr inbounds [256 x i8], ptr %d_name32, i64 0, i64 0
  %23 = load i64, ptr %name_len, align 8
  %24 = load ptr, ptr %direntp, align 8
  %d_ino = getelementptr inbounds %struct.dirent, ptr %24, i32 0, i32 0
  %25 = load i64, ptr %d_ino, align 8
  %26 = load ptr, ptr %direntp, align 8
  %d_type = getelementptr inbounds %struct.dirent, ptr %26, i32 0, i32 3
  %27 = load i8, ptr %d_type, align 2
  %call34 = call ptr @DirEntry_from_posix_info(ptr noundef %20, ptr noundef %path31, ptr noundef %arraydecay33, i64 noundef %23, i64 noundef %25, i8 noundef zeroext %27)
  store ptr %call34, ptr %entry1, align 8
  %28 = load ptr, ptr %entry1, align 8
  %tobool35 = icmp ne ptr %28, null
  br i1 %tobool35, label %if.end37, label %if.then36

if.then36:                                        ; preds = %if.then28
  br label %while.end

if.end37:                                         ; preds = %if.then28
  %29 = load ptr, ptr %entry1, align 8
  store ptr %29, ptr %retval, align 8
  br label %return

if.end38:                                         ; preds = %land.end26
  br label %while.body

while.end:                                        ; preds = %if.then36, %if.end10
  %30 = load ptr, ptr %iterator.addr, align 8
  call void @ScandirIterator_closedir(ptr noundef %30)
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %while.end, %if.end37, %if.then
  %31 = load ptr, ptr %retval, align 8
  ret ptr %31
}

declare i32 @PyObject_CallFinalizerFromDealloc(ptr noundef) #1

declare ptr @PyType_GetSlot(ptr noundef, i32 noundef) #1

declare ptr @PyErr_GetRaisedException() #1

; Function Attrs: nounwind uwtable
define internal i32 @ScandirIterator_is_closed(ptr noundef %iterator) #0 {
entry:
  %iterator.addr = alloca ptr, align 8
  store ptr %iterator, ptr %iterator.addr, align 8
  %0 = load ptr, ptr %iterator.addr, align 8
  %dirp = getelementptr inbounds %struct.ScandirIterator, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %dirp, align 8
  %tobool = icmp ne ptr %1, null
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  ret i32 %lnot.ext
}

; Function Attrs: nounwind uwtable
define internal void @ScandirIterator_closedir(ptr noundef %iterator) #0 {
entry:
  %iterator.addr = alloca ptr, align 8
  %dirp = alloca ptr, align 8
  %_save = alloca ptr, align 8
  store ptr %iterator, ptr %iterator.addr, align 8
  %0 = load ptr, ptr %iterator.addr, align 8
  %dirp1 = getelementptr inbounds %struct.ScandirIterator, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %dirp1, align 8
  store ptr %1, ptr %dirp, align 8
  %2 = load ptr, ptr %dirp, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %iterator.addr, align 8
  %dirp2 = getelementptr inbounds %struct.ScandirIterator, ptr %3, i32 0, i32 2
  store ptr null, ptr %dirp2, align 8
  %call = call ptr @PyEval_SaveThread()
  store ptr %call, ptr %_save, align 8
  %4 = load ptr, ptr %iterator.addr, align 8
  %path = getelementptr inbounds %struct.ScandirIterator, ptr %4, i32 0, i32 1
  %fd = getelementptr inbounds %struct.path_t, ptr %path, i32 0, i32 6
  %5 = load i32, ptr %fd, align 8
  %cmp = icmp ne i32 %5, -1
  br i1 %cmp, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %6 = load ptr, ptr %dirp, align 8
  call void @rewinddir(ptr noundef %6) #10
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end
  %7 = load ptr, ptr %dirp, align 8
  %call5 = call i32 @closedir(ptr noundef %7)
  %8 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %8)
  br label %return

return:                                           ; preds = %if.end4, %if.then
  ret void
}

declare i32 @PyErr_ResourceWarning(ptr noundef, i64 noundef, ptr noundef, ...) #1

declare void @PyErr_SetRaisedException(ptr noundef) #1

declare ptr @PyType_GetModule(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @DirEntry_from_posix_info(ptr noundef %module, ptr noundef %path, ptr noundef %name, i64 noundef %name_len, i64 noundef %d_ino, i8 noundef zeroext %d_type) #0 {
entry:
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %path.addr = alloca ptr, align 8
  %name.addr = alloca ptr, align 8
  %name_len.addr = alloca i64, align 8
  %d_ino.addr = alloca i64, align 8
  %d_type.addr = alloca i8, align 1
  %entry1 = alloca ptr, align 8
  %joined_path = alloca ptr, align 8
  %DirEntryType = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %path, ptr %path.addr, align 8
  store ptr %name, ptr %name.addr, align 8
  store i64 %name_len, ptr %name_len.addr, align 8
  store i64 %d_ino, ptr %d_ino.addr, align 8
  store i8 %d_type, ptr %d_type.addr, align 1
  %0 = load ptr, ptr %module.addr, align 8
  %call = call ptr @get_posix_state(ptr noundef %0)
  %DirEntryType2 = getelementptr inbounds %struct._posixstate, ptr %call, i32 0, i32 1
  %1 = load ptr, ptr %DirEntryType2, align 8
  store ptr %1, ptr %DirEntryType, align 8
  %2 = load ptr, ptr %DirEntryType, align 8
  %call3 = call ptr @_PyObject_New(ptr noundef %2)
  store ptr %call3, ptr %entry1, align 8
  %3 = load ptr, ptr %entry1, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %entry1, align 8
  %name4 = getelementptr inbounds %struct.DirEntry, ptr %4, i32 0, i32 1
  store ptr null, ptr %name4, align 8
  %5 = load ptr, ptr %entry1, align 8
  %path5 = getelementptr inbounds %struct.DirEntry, ptr %5, i32 0, i32 2
  store ptr null, ptr %path5, align 8
  %6 = load ptr, ptr %entry1, align 8
  %stat = getelementptr inbounds %struct.DirEntry, ptr %6, i32 0, i32 3
  store ptr null, ptr %stat, align 8
  %7 = load ptr, ptr %entry1, align 8
  %lstat = getelementptr inbounds %struct.DirEntry, ptr %7, i32 0, i32 4
  store ptr null, ptr %lstat, align 8
  %8 = load ptr, ptr %path.addr, align 8
  %fd = getelementptr inbounds %struct.path_t, ptr %8, i32 0, i32 6
  %9 = load i32, ptr %fd, align 8
  %cmp = icmp ne i32 %9, -1
  br i1 %cmp, label %if.then6, label %if.else

if.then6:                                         ; preds = %if.end
  %10 = load ptr, ptr %path.addr, align 8
  %fd7 = getelementptr inbounds %struct.path_t, ptr %10, i32 0, i32 6
  %11 = load i32, ptr %fd7, align 8
  %12 = load ptr, ptr %entry1, align 8
  %dir_fd = getelementptr inbounds %struct.DirEntry, ptr %12, i32 0, i32 7
  store i32 %11, ptr %dir_fd, align 8
  store ptr null, ptr %joined_path, align 8
  br label %if.end13

if.else:                                          ; preds = %if.end
  %13 = load ptr, ptr %entry1, align 8
  %dir_fd8 = getelementptr inbounds %struct.DirEntry, ptr %13, i32 0, i32 7
  store i32 -100, ptr %dir_fd8, align 8
  %14 = load ptr, ptr %path.addr, align 8
  %narrow = getelementptr inbounds %struct.path_t, ptr %14, i32 0, i32 5
  %15 = load ptr, ptr %narrow, align 8
  %16 = load ptr, ptr %name.addr, align 8
  %17 = load i64, ptr %name_len.addr, align 8
  %call9 = call ptr @join_path_filename(ptr noundef %15, ptr noundef %16, i64 noundef %17)
  store ptr %call9, ptr %joined_path, align 8
  %18 = load ptr, ptr %joined_path, align 8
  %tobool10 = icmp ne ptr %18, null
  br i1 %tobool10, label %if.end12, label %if.then11

if.then11:                                        ; preds = %if.else
  br label %error

if.end12:                                         ; preds = %if.else
  br label %if.end13

if.end13:                                         ; preds = %if.end12, %if.then6
  %19 = load ptr, ptr %path.addr, align 8
  %narrow14 = getelementptr inbounds %struct.path_t, ptr %19, i32 0, i32 5
  %20 = load ptr, ptr %narrow14, align 8
  %tobool15 = icmp ne ptr %20, null
  br i1 %tobool15, label %lor.lhs.false, label %if.then19

lor.lhs.false:                                    ; preds = %if.end13
  %21 = load ptr, ptr %path.addr, align 8
  %object = getelementptr inbounds %struct.path_t, ptr %21, i32 0, i32 8
  %22 = load ptr, ptr %object, align 8
  %call16 = call ptr @Py_TYPE(ptr noundef %22)
  %call17 = call i32 @PyType_HasFeature(ptr noundef %call16, i64 noundef 134217728)
  %tobool18 = icmp ne i32 %call17, 0
  br i1 %tobool18, label %if.else27, label %if.then19

if.then19:                                        ; preds = %lor.lhs.false, %if.end13
  %23 = load ptr, ptr %name.addr, align 8
  %24 = load i64, ptr %name_len.addr, align 8
  %call20 = call ptr @PyUnicode_DecodeFSDefaultAndSize(ptr noundef %23, i64 noundef %24)
  %25 = load ptr, ptr %entry1, align 8
  %name21 = getelementptr inbounds %struct.DirEntry, ptr %25, i32 0, i32 1
  store ptr %call20, ptr %name21, align 8
  %26 = load ptr, ptr %joined_path, align 8
  %tobool22 = icmp ne ptr %26, null
  br i1 %tobool22, label %if.then23, label %if.end26

if.then23:                                        ; preds = %if.then19
  %27 = load ptr, ptr %joined_path, align 8
  %call24 = call ptr @PyUnicode_DecodeFSDefault(ptr noundef %27)
  %28 = load ptr, ptr %entry1, align 8
  %path25 = getelementptr inbounds %struct.DirEntry, ptr %28, i32 0, i32 2
  store ptr %call24, ptr %path25, align 8
  br label %if.end26

if.end26:                                         ; preds = %if.then23, %if.then19
  br label %if.end35

if.else27:                                        ; preds = %lor.lhs.false
  %29 = load ptr, ptr %name.addr, align 8
  %30 = load i64, ptr %name_len.addr, align 8
  %call28 = call ptr @PyBytes_FromStringAndSize(ptr noundef %29, i64 noundef %30)
  %31 = load ptr, ptr %entry1, align 8
  %name29 = getelementptr inbounds %struct.DirEntry, ptr %31, i32 0, i32 1
  store ptr %call28, ptr %name29, align 8
  %32 = load ptr, ptr %joined_path, align 8
  %tobool30 = icmp ne ptr %32, null
  br i1 %tobool30, label %if.then31, label %if.end34

if.then31:                                        ; preds = %if.else27
  %33 = load ptr, ptr %joined_path, align 8
  %call32 = call ptr @PyBytes_FromString(ptr noundef %33)
  %34 = load ptr, ptr %entry1, align 8
  %path33 = getelementptr inbounds %struct.DirEntry, ptr %34, i32 0, i32 2
  store ptr %call32, ptr %path33, align 8
  br label %if.end34

if.end34:                                         ; preds = %if.then31, %if.else27
  br label %if.end35

if.end35:                                         ; preds = %if.end34, %if.end26
  %35 = load ptr, ptr %joined_path, align 8
  call void @PyMem_Free(ptr noundef %35)
  %36 = load ptr, ptr %entry1, align 8
  %name36 = getelementptr inbounds %struct.DirEntry, ptr %36, i32 0, i32 1
  %37 = load ptr, ptr %name36, align 8
  %tobool37 = icmp ne ptr %37, null
  br i1 %tobool37, label %if.end39, label %if.then38

if.then38:                                        ; preds = %if.end35
  br label %error

if.end39:                                         ; preds = %if.end35
  %38 = load ptr, ptr %path.addr, align 8
  %fd40 = getelementptr inbounds %struct.path_t, ptr %38, i32 0, i32 6
  %39 = load i32, ptr %fd40, align 8
  %cmp41 = icmp ne i32 %39, -1
  br i1 %cmp41, label %if.then42, label %if.else46

if.then42:                                        ; preds = %if.end39
  %40 = load ptr, ptr %entry1, align 8
  %name43 = getelementptr inbounds %struct.DirEntry, ptr %40, i32 0, i32 1
  %41 = load ptr, ptr %name43, align 8
  %call44 = call ptr @_Py_NewRef(ptr noundef %41)
  %42 = load ptr, ptr %entry1, align 8
  %path45 = getelementptr inbounds %struct.DirEntry, ptr %42, i32 0, i32 2
  store ptr %call44, ptr %path45, align 8
  br label %if.end51

if.else46:                                        ; preds = %if.end39
  %43 = load ptr, ptr %entry1, align 8
  %path47 = getelementptr inbounds %struct.DirEntry, ptr %43, i32 0, i32 2
  %44 = load ptr, ptr %path47, align 8
  %tobool48 = icmp ne ptr %44, null
  br i1 %tobool48, label %if.end50, label %if.then49

if.then49:                                        ; preds = %if.else46
  br label %error

if.end50:                                         ; preds = %if.else46
  br label %if.end51

if.end51:                                         ; preds = %if.end50, %if.then42
  %45 = load i8, ptr %d_type.addr, align 1
  %46 = load ptr, ptr %entry1, align 8
  %d_type52 = getelementptr inbounds %struct.DirEntry, ptr %46, i32 0, i32 5
  store i8 %45, ptr %d_type52, align 8
  %47 = load i64, ptr %d_ino.addr, align 8
  %48 = load ptr, ptr %entry1, align 8
  %d_ino53 = getelementptr inbounds %struct.DirEntry, ptr %48, i32 0, i32 6
  store i64 %47, ptr %d_ino53, align 8
  %49 = load ptr, ptr %entry1, align 8
  store ptr %49, ptr %retval, align 8
  br label %return

error:                                            ; preds = %if.then49, %if.then38, %if.then11
  %50 = load ptr, ptr %entry1, align 8
  call void @Py_XDECREF(ptr noundef %50)
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %error, %if.end51, %if.then
  %51 = load ptr, ptr %retval, align 8
  ret ptr %51
}

; Function Attrs: nounwind uwtable
define internal ptr @join_path_filename(ptr noundef %path_narrow, ptr noundef %filename, i64 noundef %filename_len) #0 {
entry:
  %retval = alloca ptr, align 8
  %path_narrow.addr = alloca ptr, align 8
  %filename.addr = alloca ptr, align 8
  %filename_len.addr = alloca i64, align 8
  %path_len = alloca i64, align 8
  %size = alloca i64, align 8
  %result = alloca ptr, align 8
  store ptr %path_narrow, ptr %path_narrow.addr, align 8
  store ptr %filename, ptr %filename.addr, align 8
  store i64 %filename_len, ptr %filename_len.addr, align 8
  %0 = load ptr, ptr %path_narrow.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  store ptr @.str.224, ptr %path_narrow.addr, align 8
  store i64 1, ptr %path_len, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %1 = load ptr, ptr %path_narrow.addr, align 8
  %call = call i64 @strlen(ptr noundef %1) #13
  store i64 %call, ptr %path_len, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %2 = load i64, ptr %filename_len.addr, align 8
  %cmp = icmp eq i64 %2, -1
  br i1 %cmp, label %if.then1, label %if.end3

if.then1:                                         ; preds = %if.end
  %3 = load ptr, ptr %filename.addr, align 8
  %call2 = call i64 @strlen(ptr noundef %3) #13
  store i64 %call2, ptr %filename_len.addr, align 8
  br label %if.end3

if.end3:                                          ; preds = %if.then1, %if.end
  %4 = load i64, ptr %path_len, align 8
  %add = add i64 %4, 1
  %5 = load i64, ptr %filename_len.addr, align 8
  %add4 = add i64 %add, %5
  %add5 = add i64 %add4, 1
  store i64 %add5, ptr %size, align 8
  %6 = load i64, ptr %size, align 8
  %cmp6 = icmp ugt i64 %6, 9223372036854775807
  br i1 %cmp6, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end3
  br label %cond.end

cond.false:                                       ; preds = %if.end3
  %7 = load i64, ptr %size, align 8
  %mul = mul i64 %7, 1
  %call7 = call ptr @PyMem_Malloc(i64 noundef %mul)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ null, %cond.true ], [ %call7, %cond.false ]
  store ptr %cond, ptr %result, align 8
  %8 = load ptr, ptr %result, align 8
  %tobool8 = icmp ne ptr %8, null
  br i1 %tobool8, label %if.end11, label %if.then9

if.then9:                                         ; preds = %cond.end
  %call10 = call ptr @PyErr_NoMemory()
  store ptr null, ptr %retval, align 8
  br label %return

if.end11:                                         ; preds = %cond.end
  %9 = load ptr, ptr %result, align 8
  %10 = load ptr, ptr %path_narrow.addr, align 8
  %call12 = call ptr @strcpy(ptr noundef %9, ptr noundef %10) #10
  %11 = load i64, ptr %path_len, align 8
  %cmp13 = icmp sgt i64 %11, 0
  br i1 %cmp13, label %land.lhs.true, label %if.end18

land.lhs.true:                                    ; preds = %if.end11
  %12 = load ptr, ptr %result, align 8
  %13 = load i64, ptr %path_len, align 8
  %sub = sub i64 %13, 1
  %arrayidx = getelementptr i8, ptr %12, i64 %sub
  %14 = load i8, ptr %arrayidx, align 1
  %conv = sext i8 %14 to i32
  %cmp14 = icmp ne i32 %conv, 47
  br i1 %cmp14, label %if.then16, label %if.end18

if.then16:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %result, align 8
  %16 = load i64, ptr %path_len, align 8
  %inc = add i64 %16, 1
  store i64 %inc, ptr %path_len, align 8
  %arrayidx17 = getelementptr i8, ptr %15, i64 %16
  store i8 47, ptr %arrayidx17, align 1
  br label %if.end18

if.end18:                                         ; preds = %if.then16, %land.lhs.true, %if.end11
  %17 = load ptr, ptr %result, align 8
  %18 = load i64, ptr %path_len, align 8
  %add.ptr = getelementptr i8, ptr %17, i64 %18
  %19 = load ptr, ptr %filename.addr, align 8
  %call19 = call ptr @strcpy(ptr noundef %add.ptr, ptr noundef %19) #10
  %20 = load ptr, ptr %result, align 8
  store ptr %20, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end18, %if.then9
  %21 = load ptr, ptr %retval, align 8
  ret ptr %21
}

declare ptr @PyBytes_FromString(ptr noundef) #1

; Function Attrs: nounwind
declare ptr @strcpy(ptr noundef, ptr noundef) #4

; Function Attrs: nounwind uwtable
define internal ptr @ScandirIterator_enter(ptr noundef %self, ptr noundef %args) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %call = call ptr @_Py_NewRef(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @ScandirIterator_exit(ptr noundef %self, ptr noundef %args) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  call void @ScandirIterator_closedir(ptr noundef %0)
  ret ptr @_Py_NoneStruct
}

; Function Attrs: nounwind uwtable
define internal ptr @ScandirIterator_close(ptr noundef %self, ptr noundef %args) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  call void @ScandirIterator_closedir(ptr noundef %0)
  ret ptr @_Py_NoneStruct
}

; Function Attrs: nounwind uwtable
define internal void @DirEntry_dealloc(ptr noundef %entry1) #0 {
entry:
  %op.addr.i3 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %entry.addr = alloca ptr, align 8
  %tp = alloca ptr, align 8
  %free_func = alloca ptr, align 8
  store ptr %entry1, ptr %entry.addr, align 8
  %0 = load ptr, ptr %entry.addr, align 8
  %call = call ptr @Py_TYPE(ptr noundef %0)
  store ptr %call, ptr %tp, align 8
  %1 = load ptr, ptr %entry.addr, align 8
  %name = getelementptr inbounds %struct.DirEntry, ptr %1, i32 0, i32 1
  %2 = load ptr, ptr %name, align 8
  call void @Py_XDECREF(ptr noundef %2)
  %3 = load ptr, ptr %entry.addr, align 8
  %path = getelementptr inbounds %struct.DirEntry, ptr %3, i32 0, i32 2
  %4 = load ptr, ptr %path, align 8
  call void @Py_XDECREF(ptr noundef %4)
  %5 = load ptr, ptr %entry.addr, align 8
  %stat = getelementptr inbounds %struct.DirEntry, ptr %5, i32 0, i32 3
  %6 = load ptr, ptr %stat, align 8
  call void @Py_XDECREF(ptr noundef %6)
  %7 = load ptr, ptr %entry.addr, align 8
  %lstat = getelementptr inbounds %struct.DirEntry, ptr %7, i32 0, i32 4
  %8 = load ptr, ptr %lstat, align 8
  call void @Py_XDECREF(ptr noundef %8)
  %9 = load ptr, ptr %tp, align 8
  %call2 = call ptr @PyType_GetSlot(ptr noundef %9, i32 noundef 74)
  store ptr %call2, ptr %free_func, align 8
  %10 = load ptr, ptr %free_func, align 8
  %11 = load ptr, ptr %entry.addr, align 8
  call void %10(ptr noundef %11)
  %12 = load ptr, ptr %tp, align 8
  store ptr %12, ptr %op.addr.i, align 8
  %13 = load ptr, ptr %op.addr.i, align 8
  store ptr %13, ptr %op.addr.i3, align 8
  %14 = load ptr, ptr %op.addr.i3, align 8
  %15 = load i64, ptr %14, align 8
  %conv.i = trunc i64 %15 to i32
  %cmp.i4 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i4 to i32
  %tobool.i = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %entry
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %entry
  %16 = load ptr, ptr %op.addr.i, align 8
  %17 = load i64, ptr %16, align 8
  %dec.i = add i64 %17, -1
  store i64 %dec.i, ptr %16, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %18 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %18) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  ret void
}

; Function Attrs: nounwind uwtable
define internal ptr @DirEntry_repr(ptr noundef %self) #0 {
entry:
  %self.addr = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %name = getelementptr inbounds %struct.DirEntry, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %name, align 8
  %call = call ptr (ptr, ...) @PyUnicode_FromFormat(ptr noundef @.str.811, ptr noundef %1)
  ret ptr %call
}

declare ptr @PyUnicode_FromFormat(ptr noundef, ...) #1

; Function Attrs: nounwind uwtable
define internal ptr @os_DirEntry_is_dir(ptr noundef %self, ptr noundef %defining_class, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %defining_class.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [1 x ptr], align 8
  %noptargs = alloca i64, align 8
  %follow_symlinks = alloca i32, align 4
  %_return_value = alloca i32, align 4
  store ptr %self, ptr %self.addr, align 8
  store ptr %defining_class, ptr %defining_class.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 0
  store i64 %sub, ptr %noptargs, align 8
  store i32 1, ptr %follow_symlinks, align 4
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 0, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 0
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [1 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @os_DirEntry_is_dir._parser, i32 noundef 0, i32 noundef 0, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load i64, ptr %noptargs, align 8
  %tobool12 = icmp ne i64 %12, 0
  br i1 %tobool12, label %if.end14, label %if.then13

if.then13:                                        ; preds = %if.end
  br label %skip_optional_kwonly

if.end14:                                         ; preds = %if.end
  %13 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %13, i64 0
  %14 = load ptr, ptr %arrayidx, align 8
  %call15 = call i32 @PyObject_IsTrue(ptr noundef %14)
  store i32 %call15, ptr %follow_symlinks, align 4
  %15 = load i32, ptr %follow_symlinks, align 4
  %cmp16 = icmp slt i32 %15, 0
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end14
  br label %exit

if.end18:                                         ; preds = %if.end14
  br label %skip_optional_kwonly

skip_optional_kwonly:                             ; preds = %if.end18, %if.then13
  %16 = load ptr, ptr %self.addr, align 8
  %17 = load ptr, ptr %defining_class.addr, align 8
  %18 = load i32, ptr %follow_symlinks, align 4
  %call19 = call i32 @os_DirEntry_is_dir_impl(ptr noundef %16, ptr noundef %17, i32 noundef %18)
  store i32 %call19, ptr %_return_value, align 4
  %19 = load i32, ptr %_return_value, align 4
  %cmp20 = icmp eq i32 %19, -1
  br i1 %cmp20, label %land.lhs.true21, label %if.end25

land.lhs.true21:                                  ; preds = %skip_optional_kwonly
  %call22 = call ptr @PyErr_Occurred()
  %tobool23 = icmp ne ptr %call22, null
  br i1 %tobool23, label %if.then24, label %if.end25

if.then24:                                        ; preds = %land.lhs.true21
  br label %exit

if.end25:                                         ; preds = %land.lhs.true21, %skip_optional_kwonly
  %20 = load i32, ptr %_return_value, align 4
  %conv = sext i32 %20 to i64
  %call26 = call ptr @PyBool_FromLong(i64 noundef %conv)
  store ptr %call26, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end25, %if.then24, %if.then17, %if.then
  %21 = load ptr, ptr %return_value, align 8
  ret ptr %21
}

; Function Attrs: nounwind uwtable
define internal ptr @os_DirEntry_is_file(ptr noundef %self, ptr noundef %defining_class, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %defining_class.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [1 x ptr], align 8
  %noptargs = alloca i64, align 8
  %follow_symlinks = alloca i32, align 4
  %_return_value = alloca i32, align 4
  store ptr %self, ptr %self.addr, align 8
  store ptr %defining_class, ptr %defining_class.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 0
  store i64 %sub, ptr %noptargs, align 8
  store i32 1, ptr %follow_symlinks, align 4
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 0, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 0
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [1 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @os_DirEntry_is_file._parser, i32 noundef 0, i32 noundef 0, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load i64, ptr %noptargs, align 8
  %tobool12 = icmp ne i64 %12, 0
  br i1 %tobool12, label %if.end14, label %if.then13

if.then13:                                        ; preds = %if.end
  br label %skip_optional_kwonly

if.end14:                                         ; preds = %if.end
  %13 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %13, i64 0
  %14 = load ptr, ptr %arrayidx, align 8
  %call15 = call i32 @PyObject_IsTrue(ptr noundef %14)
  store i32 %call15, ptr %follow_symlinks, align 4
  %15 = load i32, ptr %follow_symlinks, align 4
  %cmp16 = icmp slt i32 %15, 0
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end14
  br label %exit

if.end18:                                         ; preds = %if.end14
  br label %skip_optional_kwonly

skip_optional_kwonly:                             ; preds = %if.end18, %if.then13
  %16 = load ptr, ptr %self.addr, align 8
  %17 = load ptr, ptr %defining_class.addr, align 8
  %18 = load i32, ptr %follow_symlinks, align 4
  %call19 = call i32 @os_DirEntry_is_file_impl(ptr noundef %16, ptr noundef %17, i32 noundef %18)
  store i32 %call19, ptr %_return_value, align 4
  %19 = load i32, ptr %_return_value, align 4
  %cmp20 = icmp eq i32 %19, -1
  br i1 %cmp20, label %land.lhs.true21, label %if.end25

land.lhs.true21:                                  ; preds = %skip_optional_kwonly
  %call22 = call ptr @PyErr_Occurred()
  %tobool23 = icmp ne ptr %call22, null
  br i1 %tobool23, label %if.then24, label %if.end25

if.then24:                                        ; preds = %land.lhs.true21
  br label %exit

if.end25:                                         ; preds = %land.lhs.true21, %skip_optional_kwonly
  %20 = load i32, ptr %_return_value, align 4
  %conv = sext i32 %20 to i64
  %call26 = call ptr @PyBool_FromLong(i64 noundef %conv)
  store ptr %call26, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end25, %if.then24, %if.then17, %if.then
  %21 = load ptr, ptr %return_value, align 8
  ret ptr %21
}

; Function Attrs: nounwind uwtable
define internal ptr @os_DirEntry_is_symlink(ptr noundef %self, ptr noundef %defining_class, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %defining_class.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %_return_value = alloca i32, align 4
  store ptr %self, ptr %self.addr, align 8
  store ptr %defining_class, ptr %defining_class.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %tobool = icmp ne i64 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr @PyExc_TypeError, align 8
  call void @PyErr_SetString(ptr noundef %1, ptr noundef @.str.819)
  br label %exit

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %self.addr, align 8
  %3 = load ptr, ptr %defining_class.addr, align 8
  %call = call i32 @os_DirEntry_is_symlink_impl(ptr noundef %2, ptr noundef %3)
  store i32 %call, ptr %_return_value, align 4
  %4 = load i32, ptr %_return_value, align 4
  %cmp = icmp eq i32 %4, -1
  br i1 %cmp, label %land.lhs.true, label %if.end4

land.lhs.true:                                    ; preds = %if.end
  %call1 = call ptr @PyErr_Occurred()
  %tobool2 = icmp ne ptr %call1, null
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %land.lhs.true
  br label %exit

if.end4:                                          ; preds = %land.lhs.true, %if.end
  %5 = load i32, ptr %_return_value, align 4
  %conv = sext i32 %5 to i64
  %call5 = call ptr @PyBool_FromLong(i64 noundef %conv)
  store ptr %call5, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end4, %if.then3, %if.then
  %6 = load ptr, ptr %return_value, align 8
  ret ptr %6
}

; Function Attrs: nounwind uwtable
define internal ptr @os_DirEntry_is_junction(ptr noundef %self, ptr noundef %_unused_ignored) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %_return_value = alloca i32, align 4
  store ptr %self, ptr %self.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %call = call i32 @os_DirEntry_is_junction_impl(ptr noundef %0)
  store i32 %call, ptr %_return_value, align 4
  %1 = load i32, ptr %_return_value, align 4
  %cmp = icmp eq i32 %1, -1
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %call1 = call ptr @PyErr_Occurred()
  %tobool = icmp ne ptr %call1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  br label %exit

if.end:                                           ; preds = %land.lhs.true, %entry
  %2 = load i32, ptr %_return_value, align 4
  %conv = sext i32 %2 to i64
  %call2 = call ptr @PyBool_FromLong(i64 noundef %conv)
  store ptr %call2, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end, %if.then
  %3 = load ptr, ptr %return_value, align 8
  ret ptr %3
}

; Function Attrs: nounwind uwtable
define internal ptr @os_DirEntry_stat(ptr noundef %self, ptr noundef %defining_class, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %defining_class.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [1 x ptr], align 8
  %noptargs = alloca i64, align 8
  %follow_symlinks = alloca i32, align 4
  store ptr %self, ptr %self.addr, align 8
  store ptr %defining_class, ptr %defining_class.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 0
  store i64 %sub, ptr %noptargs, align 8
  store i32 1, ptr %follow_symlinks, align 4
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 0, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 0
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [1 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @os_DirEntry_stat._parser, i32 noundef 0, i32 noundef 0, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load i64, ptr %noptargs, align 8
  %tobool12 = icmp ne i64 %12, 0
  br i1 %tobool12, label %if.end14, label %if.then13

if.then13:                                        ; preds = %if.end
  br label %skip_optional_kwonly

if.end14:                                         ; preds = %if.end
  %13 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %13, i64 0
  %14 = load ptr, ptr %arrayidx, align 8
  %call15 = call i32 @PyObject_IsTrue(ptr noundef %14)
  store i32 %call15, ptr %follow_symlinks, align 4
  %15 = load i32, ptr %follow_symlinks, align 4
  %cmp16 = icmp slt i32 %15, 0
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end14
  br label %exit

if.end18:                                         ; preds = %if.end14
  br label %skip_optional_kwonly

skip_optional_kwonly:                             ; preds = %if.end18, %if.then13
  %16 = load ptr, ptr %self.addr, align 8
  %17 = load ptr, ptr %defining_class.addr, align 8
  %18 = load i32, ptr %follow_symlinks, align 4
  %call19 = call ptr @os_DirEntry_stat_impl(ptr noundef %16, ptr noundef %17, i32 noundef %18)
  store ptr %call19, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional_kwonly, %if.then17, %if.then
  %19 = load ptr, ptr %return_value, align 8
  ret ptr %19
}

; Function Attrs: nounwind uwtable
define internal ptr @os_DirEntry_inode(ptr noundef %self, ptr noundef %_unused_ignored) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %call = call ptr @os_DirEntry_inode_impl(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @os_DirEntry___fspath__(ptr noundef %self, ptr noundef %_unused_ignored) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %call = call ptr @os_DirEntry___fspath___impl(ptr noundef %0)
  ret ptr %call
}

declare ptr @Py_GenericAlias(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal i32 @os_DirEntry_is_dir_impl(ptr noundef %self, ptr noundef %defining_class, i32 noundef %follow_symlinks) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %defining_class.addr = alloca ptr, align 8
  %follow_symlinks.addr = alloca i32, align 4
  store ptr %self, ptr %self.addr, align 8
  store ptr %defining_class, ptr %defining_class.addr, align 8
  store i32 %follow_symlinks, ptr %follow_symlinks.addr, align 4
  %0 = load ptr, ptr %defining_class.addr, align 8
  %1 = load ptr, ptr %self.addr, align 8
  %2 = load i32, ptr %follow_symlinks.addr, align 4
  %call = call i32 @DirEntry_test_mode(ptr noundef %0, ptr noundef %1, i32 noundef %2, i16 noundef zeroext 16384)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @DirEntry_test_mode(ptr noundef %defining_class, ptr noundef %self, i32 noundef %follow_symlinks, i16 noundef zeroext %mode_bits) #0 {
entry:
  %op.addr.i73 = alloca ptr, align 8
  %op.addr.i71 = alloca ptr, align 8
  %op.addr.i62 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca i32, align 4
  %defining_class.addr = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  %follow_symlinks.addr = alloca i32, align 4
  %mode_bits.addr = alloca i16, align 2
  %stat = alloca ptr, align 8
  %st_mode = alloca ptr, align 8
  %mode = alloca i64, align 8
  %result = alloca i32, align 4
  %is_symlink = alloca i32, align 4
  %need_stat = alloca i32, align 4
  %state = alloca ptr, align 8
  %_tmp_op_ptr = alloca ptr, align 8
  %_tmp_old_op = alloca ptr, align 8
  %_tmp_op_ptr33 = alloca ptr, align 8
  %_tmp_old_op34 = alloca ptr, align 8
  store ptr %defining_class, ptr %defining_class.addr, align 8
  store ptr %self, ptr %self.addr, align 8
  store i32 %follow_symlinks, ptr %follow_symlinks.addr, align 4
  store i16 %mode_bits, ptr %mode_bits.addr, align 2
  store ptr null, ptr %stat, align 8
  store ptr null, ptr %st_mode, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %d_type = getelementptr inbounds %struct.DirEntry, ptr %0, i32 0, i32 5
  %1 = load i8, ptr %d_type, align 8
  %conv = zext i8 %1 to i32
  %cmp = icmp eq i32 %conv, 10
  %conv1 = zext i1 %cmp to i32
  store i32 %conv1, ptr %is_symlink, align 4
  %2 = load ptr, ptr %self.addr, align 8
  %d_type2 = getelementptr inbounds %struct.DirEntry, ptr %2, i32 0, i32 5
  %3 = load i8, ptr %d_type2, align 8
  %conv3 = zext i8 %3 to i32
  %cmp4 = icmp eq i32 %conv3, 0
  br i1 %cmp4, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %4 = load i32, ptr %follow_symlinks.addr, align 4
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %lor.rhs
  %5 = load i32, ptr %is_symlink, align 4
  %tobool6 = icmp ne i32 %5, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %lor.rhs
  %6 = phi i1 [ false, %lor.rhs ], [ %tobool6, %land.rhs ]
  br label %lor.end

lor.end:                                          ; preds = %land.end, %entry
  %7 = phi i1 [ true, %entry ], [ %6, %land.end ]
  %lor.ext = zext i1 %7 to i32
  store i32 %lor.ext, ptr %need_stat, align 4
  %8 = load i32, ptr %need_stat, align 4
  %tobool7 = icmp ne i32 %8, 0
  br i1 %tobool7, label %if.then, label %if.else

if.then:                                          ; preds = %lor.end
  %9 = load ptr, ptr %self.addr, align 8
  %10 = load ptr, ptr %defining_class.addr, align 8
  %11 = load i32, ptr %follow_symlinks.addr, align 4
  %call = call ptr @os_DirEntry_stat_impl(ptr noundef %9, ptr noundef %10, i32 noundef %11)
  store ptr %call, ptr %stat, align 8
  %12 = load ptr, ptr %stat, align 8
  %tobool8 = icmp ne ptr %12, null
  br i1 %tobool8, label %if.end13, label %if.then9

if.then9:                                         ; preds = %if.then
  %13 = load ptr, ptr @PyExc_FileNotFoundError, align 8
  %call10 = call i32 @PyErr_ExceptionMatches(ptr noundef %13)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.then12, label %if.end

if.then12:                                        ; preds = %if.then9
  call void @PyErr_Clear()
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then9
  br label %error

if.end13:                                         ; preds = %if.then
  %14 = load ptr, ptr %defining_class.addr, align 8
  %call14 = call ptr @PyType_GetModule(ptr noundef %14)
  %call15 = call ptr @get_posix_state(ptr noundef %call14)
  store ptr %call15, ptr %state, align 8
  %15 = load ptr, ptr %stat, align 8
  %16 = load ptr, ptr %state, align 8
  %st_mode16 = getelementptr inbounds %struct._posixstate, ptr %16, i32 0, i32 12
  %17 = load ptr, ptr %st_mode16, align 8
  %call17 = call ptr @PyObject_GetAttr(ptr noundef %15, ptr noundef %17)
  store ptr %call17, ptr %st_mode, align 8
  %18 = load ptr, ptr %st_mode, align 8
  %tobool18 = icmp ne ptr %18, null
  br i1 %tobool18, label %if.end20, label %if.then19

if.then19:                                        ; preds = %if.end13
  br label %error

if.end20:                                         ; preds = %if.end13
  %19 = load ptr, ptr %st_mode, align 8
  %call21 = call i64 @PyLong_AsLong(ptr noundef %19)
  store i64 %call21, ptr %mode, align 8
  %20 = load i64, ptr %mode, align 8
  %cmp22 = icmp eq i64 %20, -1
  br i1 %cmp22, label %land.lhs.true, label %if.end27

land.lhs.true:                                    ; preds = %if.end20
  %call24 = call ptr @PyErr_Occurred()
  %tobool25 = icmp ne ptr %call24, null
  br i1 %tobool25, label %if.then26, label %if.end27

if.then26:                                        ; preds = %land.lhs.true
  br label %error

if.end27:                                         ; preds = %land.lhs.true, %if.end20
  br label %do.body

do.body:                                          ; preds = %if.end27
  store ptr %st_mode, ptr %_tmp_op_ptr, align 8
  %21 = load ptr, ptr %_tmp_op_ptr, align 8
  %22 = load ptr, ptr %21, align 8
  store ptr %22, ptr %_tmp_old_op, align 8
  %23 = load ptr, ptr %_tmp_old_op, align 8
  %cmp28 = icmp ne ptr %23, null
  br i1 %cmp28, label %if.then30, label %if.end31

if.then30:                                        ; preds = %do.body
  %24 = load ptr, ptr %_tmp_op_ptr, align 8
  store ptr null, ptr %24, align 8
  %25 = load ptr, ptr %_tmp_old_op, align 8
  store ptr %25, ptr %op.addr.i62, align 8
  %26 = load ptr, ptr %op.addr.i62, align 8
  store ptr %26, ptr %op.addr.i71, align 8
  %27 = load ptr, ptr %op.addr.i71, align 8
  %28 = load i64, ptr %27, align 8
  %conv.i = trunc i64 %28 to i32
  %cmp.i72 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i72 to i32
  %tobool.i64 = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i64, label %if.then.i69, label %if.end.i65

if.then.i69:                                      ; preds = %if.then30
  br label %Py_DECREF.exit70

if.end.i65:                                       ; preds = %if.then30
  %29 = load ptr, ptr %op.addr.i62, align 8
  %30 = load i64, ptr %29, align 8
  %dec.i66 = add i64 %30, -1
  store i64 %dec.i66, ptr %29, align 8
  %cmp.i67 = icmp eq i64 %dec.i66, 0
  br i1 %cmp.i67, label %if.then1.i68, label %Py_DECREF.exit70

if.then1.i68:                                     ; preds = %if.end.i65
  %31 = load ptr, ptr %op.addr.i62, align 8
  call void @_Py_Dealloc(ptr noundef %31) #10
  br label %Py_DECREF.exit70

Py_DECREF.exit70:                                 ; preds = %if.then1.i68, %if.end.i65, %if.then.i69
  br label %if.end31

if.end31:                                         ; preds = %Py_DECREF.exit70, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end31
  br label %do.body32

do.body32:                                        ; preds = %do.end
  store ptr %stat, ptr %_tmp_op_ptr33, align 8
  %32 = load ptr, ptr %_tmp_op_ptr33, align 8
  %33 = load ptr, ptr %32, align 8
  store ptr %33, ptr %_tmp_old_op34, align 8
  %34 = load ptr, ptr %_tmp_old_op34, align 8
  %cmp35 = icmp ne ptr %34, null
  br i1 %cmp35, label %if.then37, label %if.end38

if.then37:                                        ; preds = %do.body32
  %35 = load ptr, ptr %_tmp_op_ptr33, align 8
  store ptr null, ptr %35, align 8
  %36 = load ptr, ptr %_tmp_old_op34, align 8
  store ptr %36, ptr %op.addr.i, align 8
  %37 = load ptr, ptr %op.addr.i, align 8
  store ptr %37, ptr %op.addr.i73, align 8
  %38 = load ptr, ptr %op.addr.i73, align 8
  %39 = load i64, ptr %38, align 8
  %conv.i74 = trunc i64 %39 to i32
  %cmp.i75 = icmp slt i32 %conv.i74, 0
  %conv1.i76 = zext i1 %cmp.i75 to i32
  %tobool.i = icmp ne i32 %conv1.i76, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then37
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.then37
  %40 = load ptr, ptr %op.addr.i, align 8
  %41 = load i64, ptr %40, align 8
  %dec.i = add i64 %41, -1
  store i64 %dec.i, ptr %40, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %42 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %42) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  br label %if.end38

if.end38:                                         ; preds = %Py_DECREF.exit, %do.body32
  br label %do.end39

do.end39:                                         ; preds = %if.end38
  %43 = load i64, ptr %mode, align 8
  %and = and i64 %43, 61440
  %44 = load i16, ptr %mode_bits.addr, align 2
  %conv40 = zext i16 %44 to i64
  %cmp41 = icmp eq i64 %and, %conv40
  %conv42 = zext i1 %cmp41 to i32
  store i32 %conv42, ptr %result, align 4
  br label %if.end61

if.else:                                          ; preds = %lor.end
  %45 = load i32, ptr %is_symlink, align 4
  %tobool43 = icmp ne i32 %45, 0
  br i1 %tobool43, label %if.then44, label %if.else45

if.then44:                                        ; preds = %if.else
  store i32 0, ptr %result, align 4
  br label %if.end60

if.else45:                                        ; preds = %if.else
  %46 = load i16, ptr %mode_bits.addr, align 2
  %conv46 = zext i16 %46 to i32
  %cmp47 = icmp eq i32 %conv46, 16384
  br i1 %cmp47, label %if.then49, label %if.else54

if.then49:                                        ; preds = %if.else45
  %47 = load ptr, ptr %self.addr, align 8
  %d_type50 = getelementptr inbounds %struct.DirEntry, ptr %47, i32 0, i32 5
  %48 = load i8, ptr %d_type50, align 8
  %conv51 = zext i8 %48 to i32
  %cmp52 = icmp eq i32 %conv51, 4
  %conv53 = zext i1 %cmp52 to i32
  store i32 %conv53, ptr %result, align 4
  br label %if.end59

if.else54:                                        ; preds = %if.else45
  %49 = load ptr, ptr %self.addr, align 8
  %d_type55 = getelementptr inbounds %struct.DirEntry, ptr %49, i32 0, i32 5
  %50 = load i8, ptr %d_type55, align 8
  %conv56 = zext i8 %50 to i32
  %cmp57 = icmp eq i32 %conv56, 8
  %conv58 = zext i1 %cmp57 to i32
  store i32 %conv58, ptr %result, align 4
  br label %if.end59

if.end59:                                         ; preds = %if.else54, %if.then49
  br label %if.end60

if.end60:                                         ; preds = %if.end59, %if.then44
  br label %if.end61

if.end61:                                         ; preds = %if.end60, %do.end39
  %51 = load i32, ptr %result, align 4
  store i32 %51, ptr %retval, align 4
  br label %return

error:                                            ; preds = %if.then26, %if.then19, %if.end
  %52 = load ptr, ptr %st_mode, align 8
  call void @Py_XDECREF(ptr noundef %52)
  %53 = load ptr, ptr %stat, align 8
  call void @Py_XDECREF(ptr noundef %53)
  store i32 -1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %error, %if.end61, %if.then12
  %54 = load i32, ptr %retval, align 4
  ret i32 %54
}

; Function Attrs: nounwind uwtable
define internal ptr @os_DirEntry_stat_impl(ptr noundef %self, ptr noundef %defining_class, i32 noundef %follow_symlinks) #0 {
entry:
  %retval = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  %defining_class.addr = alloca ptr, align 8
  %follow_symlinks.addr = alloca i32, align 4
  %result = alloca i32, align 4
  %module = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %defining_class, ptr %defining_class.addr, align 8
  store i32 %follow_symlinks, ptr %follow_symlinks.addr, align 4
  %0 = load i32, ptr %follow_symlinks.addr, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %defining_class.addr, align 8
  %2 = load ptr, ptr %self.addr, align 8
  %call = call ptr @DirEntry_get_lstat(ptr noundef %1, ptr noundef %2)
  store ptr %call, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %self.addr, align 8
  %stat = getelementptr inbounds %struct.DirEntry, ptr %3, i32 0, i32 3
  %4 = load ptr, ptr %stat, align 8
  %tobool1 = icmp ne ptr %4, null
  br i1 %tobool1, label %if.end14, label %if.then2

if.then2:                                         ; preds = %if.end
  %5 = load ptr, ptr %self.addr, align 8
  %6 = load ptr, ptr %defining_class.addr, align 8
  %call3 = call i32 @os_DirEntry_is_symlink_impl(ptr noundef %5, ptr noundef %6)
  store i32 %call3, ptr %result, align 4
  %7 = load i32, ptr %result, align 4
  %cmp = icmp eq i32 %7, -1
  br i1 %cmp, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.then2
  store ptr null, ptr %retval, align 8
  br label %return

if.end5:                                          ; preds = %if.then2
  %8 = load i32, ptr %result, align 4
  %tobool6 = icmp ne i32 %8, 0
  br i1 %tobool6, label %if.then7, label %if.else

if.then7:                                         ; preds = %if.end5
  %9 = load ptr, ptr %defining_class.addr, align 8
  %call8 = call ptr @PyType_GetModule(ptr noundef %9)
  store ptr %call8, ptr %module, align 8
  %10 = load ptr, ptr %module, align 8
  %11 = load ptr, ptr %self.addr, align 8
  %call9 = call ptr @DirEntry_fetch_stat(ptr noundef %10, ptr noundef %11, i32 noundef 1)
  %12 = load ptr, ptr %self.addr, align 8
  %stat10 = getelementptr inbounds %struct.DirEntry, ptr %12, i32 0, i32 3
  store ptr %call9, ptr %stat10, align 8
  br label %if.end13

if.else:                                          ; preds = %if.end5
  %13 = load ptr, ptr %defining_class.addr, align 8
  %14 = load ptr, ptr %self.addr, align 8
  %call11 = call ptr @DirEntry_get_lstat(ptr noundef %13, ptr noundef %14)
  %15 = load ptr, ptr %self.addr, align 8
  %stat12 = getelementptr inbounds %struct.DirEntry, ptr %15, i32 0, i32 3
  store ptr %call11, ptr %stat12, align 8
  br label %if.end13

if.end13:                                         ; preds = %if.else, %if.then7
  br label %if.end14

if.end14:                                         ; preds = %if.end13, %if.end
  %16 = load ptr, ptr %self.addr, align 8
  %stat15 = getelementptr inbounds %struct.DirEntry, ptr %16, i32 0, i32 3
  %17 = load ptr, ptr %stat15, align 8
  %call16 = call ptr @_Py_XNewRef(ptr noundef %17)
  store ptr %call16, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end14, %if.then4, %if.then
  %18 = load ptr, ptr %retval, align 8
  ret ptr %18
}

; Function Attrs: nounwind uwtable
define internal ptr @DirEntry_get_lstat(ptr noundef %defining_class, ptr noundef %self) #0 {
entry:
  %defining_class.addr = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  %module = alloca ptr, align 8
  store ptr %defining_class, ptr %defining_class.addr, align 8
  store ptr %self, ptr %self.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %lstat = getelementptr inbounds %struct.DirEntry, ptr %0, i32 0, i32 4
  %1 = load ptr, ptr %lstat, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %defining_class.addr, align 8
  %call = call ptr @PyType_GetModule(ptr noundef %2)
  store ptr %call, ptr %module, align 8
  %3 = load ptr, ptr %module, align 8
  %4 = load ptr, ptr %self.addr, align 8
  %call1 = call ptr @DirEntry_fetch_stat(ptr noundef %3, ptr noundef %4, i32 noundef 0)
  %5 = load ptr, ptr %self.addr, align 8
  %lstat2 = getelementptr inbounds %struct.DirEntry, ptr %5, i32 0, i32 4
  store ptr %call1, ptr %lstat2, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load ptr, ptr %self.addr, align 8
  %lstat3 = getelementptr inbounds %struct.DirEntry, ptr %6, i32 0, i32 4
  %7 = load ptr, ptr %lstat3, align 8
  %call4 = call ptr @_Py_XNewRef(ptr noundef %7)
  ret ptr %call4
}

; Function Attrs: nounwind uwtable
define internal i32 @os_DirEntry_is_symlink_impl(ptr noundef %self, ptr noundef %defining_class) #0 {
entry:
  %retval = alloca i32, align 4
  %self.addr = alloca ptr, align 8
  %defining_class.addr = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %defining_class, ptr %defining_class.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %d_type = getelementptr inbounds %struct.DirEntry, ptr %0, i32 0, i32 5
  %1 = load i8, ptr %d_type, align 8
  %conv = zext i8 %1 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %self.addr, align 8
  %d_type2 = getelementptr inbounds %struct.DirEntry, ptr %2, i32 0, i32 5
  %3 = load i8, ptr %d_type2, align 8
  %conv3 = zext i8 %3 to i32
  %cmp4 = icmp eq i32 %conv3, 10
  %conv5 = zext i1 %cmp4 to i32
  store i32 %conv5, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %4 = load ptr, ptr %defining_class.addr, align 8
  %5 = load ptr, ptr %self.addr, align 8
  %call = call i32 @DirEntry_test_mode(ptr noundef %4, ptr noundef %5, i32 noundef 0, i16 noundef zeroext -24576)
  store i32 %call, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.else, %if.then
  %6 = load i32, ptr %retval, align 4
  ret i32 %6
}

; Function Attrs: nounwind uwtable
define internal ptr @DirEntry_fetch_stat(ptr noundef %module, ptr noundef %self, i32 noundef %follow_symlinks) #0 {
entry:
  %op.addr.i25 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  %follow_symlinks.addr = alloca i32, align 4
  %result = alloca i32, align 4
  %st = alloca %struct.stat, align 8
  %ub = alloca ptr, align 8
  %path1 = alloca ptr, align 8
  %_save = alloca ptr, align 8
  %_save8 = alloca ptr, align 8
  %saved_errno = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %self, ptr %self.addr, align 8
  store i32 %follow_symlinks, ptr %follow_symlinks.addr, align 4
  %0 = load ptr, ptr %self.addr, align 8
  %path = getelementptr inbounds %struct.DirEntry, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %path, align 8
  %call = call i32 @PyUnicode_FSConverter(ptr noundef %1, ptr noundef %ub)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %ub, align 8
  %call2 = call ptr @PyBytes_AS_STRING(ptr noundef %2)
  store ptr %call2, ptr %path1, align 8
  %3 = load ptr, ptr %self.addr, align 8
  %dir_fd = getelementptr inbounds %struct.DirEntry, ptr %3, i32 0, i32 7
  %4 = load i32, ptr %dir_fd, align 8
  %cmp = icmp ne i32 %4, -100
  br i1 %cmp, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  %call4 = call ptr @PyEval_SaveThread()
  store ptr %call4, ptr %_save, align 8
  %5 = load ptr, ptr %self.addr, align 8
  %dir_fd5 = getelementptr inbounds %struct.DirEntry, ptr %5, i32 0, i32 7
  %6 = load i32, ptr %dir_fd5, align 8
  %7 = load ptr, ptr %path1, align 8
  %8 = load i32, ptr %follow_symlinks.addr, align 4
  %tobool6 = icmp ne i32 %8, 0
  %cond = select i1 %tobool6, i32 0, i32 256
  %call7 = call i32 @fstatat64(i32 noundef %6, ptr noundef %7, ptr noundef %st, i32 noundef %cond) #10
  store i32 %call7, ptr %result, align 4
  %9 = load ptr, ptr %_save, align 8
  call void @PyEval_RestoreThread(ptr noundef %9)
  br label %if.end16

if.else:                                          ; preds = %if.end
  %call9 = call ptr @PyEval_SaveThread()
  store ptr %call9, ptr %_save8, align 8
  %10 = load i32, ptr %follow_symlinks.addr, align 4
  %tobool10 = icmp ne i32 %10, 0
  br i1 %tobool10, label %if.then11, label %if.else13

if.then11:                                        ; preds = %if.else
  %11 = load ptr, ptr %path1, align 8
  %call12 = call i32 @stat64(ptr noundef %11, ptr noundef %st) #10
  store i32 %call12, ptr %result, align 4
  br label %if.end15

if.else13:                                        ; preds = %if.else
  %12 = load ptr, ptr %path1, align 8
  %call14 = call i32 @lstat64(ptr noundef %12, ptr noundef %st) #10
  store i32 %call14, ptr %result, align 4
  br label %if.end15

if.end15:                                         ; preds = %if.else13, %if.then11
  %13 = load ptr, ptr %_save8, align 8
  call void @PyEval_RestoreThread(ptr noundef %13)
  br label %if.end16

if.end16:                                         ; preds = %if.end15, %if.then3
  %call17 = call ptr @__errno_location() #12
  %14 = load i32, ptr %call17, align 4
  store i32 %14, ptr %saved_errno, align 4
  %15 = load ptr, ptr %ub, align 8
  store ptr %15, ptr %op.addr.i, align 8
  %16 = load ptr, ptr %op.addr.i, align 8
  store ptr %16, ptr %op.addr.i25, align 8
  %17 = load ptr, ptr %op.addr.i25, align 8
  %18 = load i64, ptr %17, align 8
  %conv.i = trunc i64 %18 to i32
  %cmp.i26 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i26 to i32
  %tobool.i = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.end16
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.end16
  %19 = load ptr, ptr %op.addr.i, align 8
  %20 = load i64, ptr %19, align 8
  %dec.i = add i64 %20, -1
  store i64 %dec.i, ptr %19, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %21 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %21) #10
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  %22 = load i32, ptr %result, align 4
  %cmp18 = icmp ne i32 %22, 0
  br i1 %cmp18, label %if.then19, label %if.end23

if.then19:                                        ; preds = %Py_DECREF.exit
  %23 = load i32, ptr %saved_errno, align 4
  %call20 = call ptr @__errno_location() #12
  store i32 %23, ptr %call20, align 4
  %24 = load ptr, ptr %self.addr, align 8
  %path21 = getelementptr inbounds %struct.DirEntry, ptr %24, i32 0, i32 2
  %25 = load ptr, ptr %path21, align 8
  %call22 = call ptr @path_object_error(ptr noundef %25)
  store ptr null, ptr %retval, align 8
  br label %return

if.end23:                                         ; preds = %Py_DECREF.exit
  %26 = load ptr, ptr %module.addr, align 8
  %call24 = call ptr @_pystat_fromstructstat(ptr noundef %26, ptr noundef %st)
  store ptr %call24, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end23, %if.then19, %if.then
  %27 = load ptr, ptr %retval, align 8
  ret ptr %27
}

; Function Attrs: nounwind uwtable
define internal ptr @_Py_XNewRef(ptr noundef %obj) #0 {
entry:
  %obj.addr = alloca ptr, align 8
  store ptr %obj, ptr %obj.addr, align 8
  %0 = load ptr, ptr %obj.addr, align 8
  call void @Py_XINCREF(ptr noundef %0)
  %1 = load ptr, ptr %obj.addr, align 8
  ret ptr %1
}

; Function Attrs: nounwind uwtable
define internal void @Py_XINCREF(ptr noundef %op) #0 {
entry:
  %op.addr.i = alloca ptr, align 8
  %cur_refcnt.i = alloca i32, align 4
  %new_refcnt.i = alloca i32, align 4
  %op.addr = alloca ptr, align 8
  store ptr %op, ptr %op.addr, align 8
  %0 = load ptr, ptr %op.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %op.addr, align 8
  store ptr %1, ptr %op.addr.i, align 8
  %2 = load ptr, ptr %op.addr.i, align 8
  %3 = load i32, ptr %2, align 8
  store i32 %3, ptr %cur_refcnt.i, align 4
  %4 = load i32, ptr %cur_refcnt.i, align 4
  %add.i = add i32 %4, 1
  store i32 %add.i, ptr %new_refcnt.i, align 4
  %5 = load i32, ptr %new_refcnt.i, align 4
  %cmp.i = icmp eq i32 %5, 0
  br i1 %cmp.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then
  br label %Py_INCREF.exit

if.end.i:                                         ; preds = %if.then
  %6 = load i32, ptr %new_refcnt.i, align 4
  %7 = load ptr, ptr %op.addr.i, align 8
  store i32 %6, ptr %7, align 8
  br label %Py_INCREF.exit

Py_INCREF.exit:                                   ; preds = %if.end.i, %if.then.i
  br label %if.end

if.end:                                           ; preds = %Py_INCREF.exit, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @os_DirEntry_is_file_impl(ptr noundef %self, ptr noundef %defining_class, i32 noundef %follow_symlinks) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %defining_class.addr = alloca ptr, align 8
  %follow_symlinks.addr = alloca i32, align 4
  store ptr %self, ptr %self.addr, align 8
  store ptr %defining_class, ptr %defining_class.addr, align 8
  store i32 %follow_symlinks, ptr %follow_symlinks.addr, align 4
  %0 = load ptr, ptr %defining_class.addr, align 8
  %1 = load ptr, ptr %self.addr, align 8
  %2 = load i32, ptr %follow_symlinks.addr, align 4
  %call = call i32 @DirEntry_test_mode(ptr noundef %0, ptr noundef %1, i32 noundef %2, i16 noundef zeroext -32768)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @os_DirEntry_is_junction_impl(ptr noundef %self) #0 {
entry:
  %self.addr = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal ptr @os_DirEntry_inode_impl(ptr noundef %self) #0 {
entry:
  %self.addr = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %d_ino = getelementptr inbounds %struct.DirEntry, ptr %0, i32 0, i32 6
  %1 = load i64, ptr %d_ino, align 8
  %call = call ptr @PyLong_FromUnsignedLongLong(i64 noundef %1)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @os_DirEntry___fspath___impl(ptr noundef %self) #0 {
entry:
  %self.addr = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %path = getelementptr inbounds %struct.DirEntry, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %path, align 8
  %call = call ptr @_Py_NewRef(ptr noundef %1)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal i32 @probe_faccessat() #0 {
entry:
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @probe_fchmodat() #0 {
entry:
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @probe_fchownat() #0 {
entry:
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @probe_fdopendir() #0 {
entry:
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @probe_fstatat() #0 {
entry:
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @probe_futimens() #0 {
entry:
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @probe_linkat() #0 {
entry:
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @probe_mkdirat() #0 {
entry:
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @probe_mkfifoat() #0 {
entry:
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @probe_mknodat() #0 {
entry:
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @probe_openat() #0 {
entry:
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @probe_readlinkat() #0 {
entry:
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @probe_renameat() #0 {
entry:
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @probe_symlinkat() #0 {
entry:
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @probe_unlinkat() #0 {
entry:
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @probe_utimensat() #0 {
entry:
  ret i32 1
}

attributes #0 = { nounwind uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #2 = { noreturn "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #4 = { nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #5 = { nounwind willreturn memory(none) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #6 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #7 = { nounwind willreturn memory(read) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #8 = { nocallback nofree nounwind willreturn memory(argmem: write) }
attributes #9 = { noreturn nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #10 = { nounwind }
attributes #11 = { noreturn }
attributes #12 = { nounwind willreturn memory(none) }
attributes #13 = { nounwind willreturn memory(read) }
attributes #14 = { noreturn nounwind }

!llvm.module.flags = !{!0, !1, !2, !3, !4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = distinct !{!5, !6}
!6 = !{!"llvm.loop.mustprogress"}
!7 = distinct !{!7, !6}
!8 = distinct !{!8, !6}
!9 = distinct !{!9, !6}
!10 = distinct !{!10, !6}
!11 = distinct !{!11, !6}
!12 = distinct !{!12, !6}
!13 = distinct !{!13, !6}
!14 = distinct !{!14, !6}
!15 = distinct !{!15, !6}
!16 = distinct !{!16, !6}
!17 = distinct !{!17, !6}
!18 = distinct !{!18, !6}
!19 = distinct !{!19, !6}
!20 = distinct !{!20, !6}
!21 = distinct !{!21, !6}
!22 = distinct !{!22, !6}
!23 = distinct !{!23, !6}
!24 = distinct !{!24, !6}
!25 = distinct !{!25, !6}
!26 = distinct !{!26, !6}
!27 = distinct !{!27, !6}
!28 = distinct !{!28, !6}
!29 = distinct !{!29, !6}
!30 = distinct !{!30, !6}
!31 = distinct !{!31, !6}
!32 = distinct !{!32, !6}
!33 = distinct !{!33, !6}
!34 = distinct !{!34, !6}
!35 = distinct !{!35, !6}
!36 = distinct !{!36, !6}
!37 = distinct !{!37, !6}
!38 = distinct !{!38, !6}
!39 = distinct !{!39, !6}
!40 = distinct !{!40, !6}
!41 = distinct !{!41, !6}
!42 = distinct !{!42, !6}
!43 = distinct !{!43, !6}
!44 = distinct !{!44, !6}
!45 = distinct !{!45, !6}
!46 = distinct !{!46, !6}
!47 = distinct !{!47, !6}
!48 = distinct !{!48, !6}
!49 = distinct !{!49, !6}
!50 = distinct !{!50, !6}
!51 = distinct !{!51, !6}
!52 = distinct !{!52, !6}
!53 = distinct !{!53, !6}
!54 = distinct !{!54, !6}
