target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.mi_stats_s = type { %struct.mi_stat_count_s, %struct.mi_stat_count_s, %struct.mi_stat_count_s, %struct.mi_stat_count_s, %struct.mi_stat_count_s, %struct.mi_stat_count_s, %struct.mi_stat_count_s, %struct.mi_stat_count_s, %struct.mi_stat_count_s, %struct.mi_stat_count_s, %struct.mi_stat_count_s, %struct.mi_stat_count_s, %struct.mi_stat_count_s, %struct.mi_stat_count_s, %struct.mi_stat_count_s, %struct.mi_stat_counter_s, %struct.mi_stat_counter_s, %struct.mi_stat_counter_s, %struct.mi_stat_counter_s, %struct.mi_stat_counter_s, %struct.mi_stat_counter_s, %struct.mi_stat_counter_s, %struct.mi_stat_counter_s, %struct.mi_stat_counter_s, %struct.mi_stat_counter_s }
%struct.mi_stat_count_s = type { i64, i64, i64, i64 }
%struct.mi_stat_counter_s = type { i64, i64 }
%struct.mi_heap_s = type { ptr, [129 x ptr], [75 x %struct.mi_page_queue_s], ptr, i64, i32, i64, [2 x i64], %struct.mi_random_cxt_s, i64, i64, i64, ptr, i8 }
%struct.mi_page_queue_s = type { ptr, ptr, i64 }
%struct.mi_random_cxt_s = type { [16 x i32], [16 x i32], i32, i8 }
%struct.mi_page_s = type { i32, i32, i8, i16, i16, %union.mi_page_flags_s, i8, ptr, i32, i32, ptr, i64, i64, ptr, ptr, [1 x i64] }
%union.mi_page_flags_s = type { i8 }
%struct.mi_tld_s = type { i64, i8, ptr, ptr, %struct.mi_segments_tld_s, %struct.mi_os_tld_s, %struct.mi_stats_s }
%struct.mi_segments_tld_s = type { [36 x %struct.mi_span_queue_s], i64, i64, i64, i64, ptr, ptr }
%struct.mi_span_queue_s = type { ptr, ptr, i64 }
%struct.mi_os_tld_s = type { i64, ptr }
%struct.mi_option_desc_s = type { i64, i32, i32, ptr, ptr }
%struct.mi_os_mem_config_s = type { i64, i64, i64, i8, i8, i8 }
%struct.pyruntimestate = type { %struct._Py_DebugOffsets, i32, i32, i32, i32, i32, ptr, i64, %struct.pyinterpreters, i64, %struct._xi_runtime_state, %struct._pymem_allocators, %struct._obmalloc_global_state, %struct.pyhash_runtime_state, %struct._pythread_runtime_state, %struct._signals_runtime_state, %struct._Py_tss_t, %struct._Py_tss_t, %struct.PyWideStringList, %struct._parser_runtime_state, %struct._atexit_runtime_state, %struct._import_runtime_state, %struct._ceval_runtime_state, %struct._gilstate_runtime_state, %struct._getargs_runtime_state, %struct._fileutils_state, %struct._faulthandler_runtime_state, %struct._tracemalloc_runtime_state, %struct.PyPreConfig, ptr, ptr, %struct.anon.53, %struct._py_object_runtime_state, %struct._Py_float_runtime_state, %struct._Py_unicode_runtime_state, %struct._types_runtime_state, %struct._Py_cached_objects, %struct._Py_static_objects, %struct._is }
%struct._Py_DebugOffsets = type { [8 x i8], i64, %struct._runtime_state, %struct._interpreter_state, %struct._thread_state, %struct._interpreter_frame, %struct._cframe, %struct._code_object, %struct._pyobject, %struct._type_object, %struct._tuple_object }
%struct._runtime_state = type { i64, i64 }
%struct._interpreter_state = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct._thread_state = type { i64, i64, i64, i64, i64, i64 }
%struct._interpreter_frame = type { i64, i64, i64, i64, i64 }
%struct._cframe = type { i64, i64 }
%struct._code_object = type { i64, i64, i64, i64, i64, i64, i64, i64 }
%struct._pyobject = type { i64 }
%struct._type_object = type { i64 }
%struct._tuple_object = type { i64 }
%struct.pyinterpreters = type { %struct._PyMutex, ptr, ptr, i64 }
%struct._PyMutex = type { i8 }
%struct._xi_runtime_state = type { %struct._xidregistry }
%struct._xidregistry = type { i32, i32, %struct._PyMutex, ptr }
%struct._pymem_allocators = type { %struct._PyMutex, %struct.anon.14, %struct.anon.15, %struct.PyObjectArenaAllocator }
%struct.anon.14 = type { %struct.PyMemAllocatorEx, %struct.PyMemAllocatorEx, %struct.PyMemAllocatorEx }
%struct.PyMemAllocatorEx = type { ptr, ptr, ptr, ptr, ptr }
%struct.anon.15 = type { %struct.debug_alloc_api_t, %struct.debug_alloc_api_t, %struct.debug_alloc_api_t }
%struct.debug_alloc_api_t = type { i8, %struct.PyMemAllocatorEx }
%struct.PyObjectArenaAllocator = type { ptr, ptr, ptr }
%struct._obmalloc_global_state = type { i32, i64 }
%struct.pyhash_runtime_state = type { %struct.anon.16 }
%struct.anon.16 = type { i32, i64, i64 }
%struct._pythread_runtime_state = type { i32, %struct.anon.17 }
%struct.anon.17 = type { ptr, %union.pthread_condattr_t }
%union.pthread_condattr_t = type { i32 }
%struct._signals_runtime_state = type { [65 x %struct.anon.18], %struct.anon.19, i32, ptr, ptr, i32 }
%struct.anon.18 = type { i32, ptr }
%struct.anon.19 = type { i32, i32 }
%struct._Py_tss_t = type { i32, i32 }
%struct.PyWideStringList = type { i64, ptr }
%struct._parser_runtime_state = type { i32, %struct._expr }
%struct._expr = type { i32, %union.anon.20, i32, i32, i32, i32 }
%union.anon.20 = type { %struct.anon.23 }
%struct.anon.23 = type { ptr, i32, ptr }
%struct._atexit_runtime_state = type { %struct._PyMutex, [32 x ptr], i32 }
%struct._import_runtime_state = type { ptr, i64, %struct.anon.48, ptr }
%struct.anon.48 = type { %struct._PyMutex, ptr }
%struct._ceval_runtime_state = type { %struct.anon.49, %struct._pending_calls }
%struct.anon.49 = type { i32, i64, ptr, %struct.trampoline_api_st, ptr, i64 }
%struct.trampoline_api_st = type { ptr, ptr, ptr, ptr }
%struct._pending_calls = type { i32, %struct._PyMutex, i32, [32 x %struct._pending_call], i32, i32 }
%struct._pending_call = type { ptr, ptr, i32 }
%struct._gilstate_runtime_state = type { i32, ptr }
%struct._getargs_runtime_state = type { ptr }
%struct._fileutils_state = type { i32 }
%struct._faulthandler_runtime_state = type { %struct.anon.50, %struct.anon.51, ptr, %struct.stack_t, %struct.stack_t }
%struct.anon.50 = type { i32, ptr, i32, i32, ptr }
%struct.anon.51 = type { ptr, i32, i64, i32, ptr, i32, ptr, i64, ptr, ptr }
%struct.stack_t = type { ptr, i32, i64 }
%struct._tracemalloc_runtime_state = type { %struct._PyTraceMalloc_Config, %struct.anon.52, ptr, i64, i64, ptr, ptr, ptr, ptr, ptr, %struct.tracemalloc_traceback, %struct._Py_tss_t }
%struct._PyTraceMalloc_Config = type { i32, i32, i32 }
%struct.anon.52 = type { %struct.PyMemAllocatorEx, %struct.PyMemAllocatorEx, %struct.PyMemAllocatorEx }
%struct.tracemalloc_traceback = type { i64, i16, i16, [1 x %struct.tracemalloc_frame] }
%struct.tracemalloc_frame = type <{ ptr, i32 }>
%struct.PyPreConfig = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.anon.53 = type { %struct._PyMutex, ptr }
%struct._py_object_runtime_state = type { i32 }
%struct._Py_float_runtime_state = type { i32, i32 }
%struct._Py_unicode_runtime_state = type { %struct._Py_unicode_runtime_ids }
%struct._Py_unicode_runtime_ids = type { %struct._PyMutex, i64 }
%struct._types_runtime_state = type { i32 }
%struct._Py_cached_objects = type { ptr }
%struct._Py_static_objects = type { %struct.anon.54 }
%struct.anon.54 = type { [262 x %struct._longobject], %struct.PyBytesObject, [256 x %struct.anon.56], %struct._Py_global_strings, %struct.PyGC_Head, %struct.PyTupleObject, %struct.PyGC_Head, %struct.PyHamtNode_Bitmap, %struct._PyContextTokenMissing }
%struct._longobject = type { %struct._object, %struct._PyLongValue }
%struct._object = type { %union.anon.55, ptr }
%union.anon.55 = type { i64 }
%struct._PyLongValue = type { i64, [1 x i32] }
%struct.PyBytesObject = type { %struct.PyVarObject, i64, [1 x i8] }
%struct.PyVarObject = type { %struct._object, i64 }
%struct.anon.56 = type { %struct.PyBytesObject, i8 }
%struct._Py_global_strings = type { %struct.anon.57, %struct.anon.85, [128 x %struct.anon.778], [128 x %struct.anon.779] }
%struct.anon.57 = type { %struct.anon.58, %struct.anon.60, %struct.anon.61, %struct.anon.62, %struct.anon.63, %struct.anon.64, %struct.anon.65, %struct.anon.66, %struct.anon.67, %struct.anon.68, %struct.anon.69, %struct.anon.70, %struct.anon.71, %struct.anon.72, %struct.anon.73, %struct.anon.74, %struct.anon.75, %struct.anon.76, %struct.anon.77, %struct.anon.78, %struct.anon.79, %struct.anon.80, %struct.anon.81, %struct.anon.82, %struct.anon.83, %struct.anon.84 }
%struct.anon.58 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.PyASCIIObject = type { %struct._object, i64, i64, %struct.anon.59 }
%struct.anon.59 = type { i32 }
%struct.anon.60 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.61 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.62 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.63 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.64 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.65 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.66 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.67 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.68 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.69 = type { %struct.PyASCIIObject, [3 x i8] }
%struct.anon.70 = type { %struct.PyASCIIObject, [3 x i8] }
%struct.anon.71 = type { %struct.PyASCIIObject, [3 x i8] }
%struct.anon.72 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.73 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.74 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.75 = type { %struct.PyASCIIObject, [1 x i8] }
%struct.anon.76 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.77 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.78 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.79 = type { %struct.PyASCIIObject, [24 x i8] }
%struct.anon.80 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.81 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.82 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.83 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.84 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.85 = type { %struct.anon.86, %struct.anon.87, %struct.anon.88, %struct.anon.89, %struct.anon.90, %struct.anon.91, %struct.anon.92, %struct.anon.93, %struct.anon.94, %struct.anon.95, %struct.anon.96, %struct.anon.97, %struct.anon.98, %struct.anon.99, %struct.anon.100, %struct.anon.101, %struct.anon.102, %struct.anon.103, %struct.anon.104, %struct.anon.105, %struct.anon.106, %struct.anon.107, %struct.anon.108, %struct.anon.109, %struct.anon.110, %struct.anon.111, %struct.anon.112, %struct.anon.113, %struct.anon.114, %struct.anon.115, %struct.anon.116, %struct.anon.117, %struct.anon.118, %struct.anon.119, %struct.anon.120, %struct.anon.121, %struct.anon.122, %struct.anon.123, %struct.anon.124, %struct.anon.125, %struct.anon.126, %struct.anon.127, %struct.anon.128, %struct.anon.129, %struct.anon.130, %struct.anon.131, %struct.anon.132, %struct.anon.133, %struct.anon.134, %struct.anon.135, %struct.anon.136, %struct.anon.137, %struct.anon.138, %struct.anon.139, %struct.anon.140, %struct.anon.141, %struct.anon.142, %struct.anon.143, %struct.anon.144, %struct.anon.145, %struct.anon.146, %struct.anon.147, %struct.anon.148, %struct.anon.149, %struct.anon.150, %struct.anon.151, %struct.anon.152, %struct.anon.153, %struct.anon.154, %struct.anon.155, %struct.anon.156, %struct.anon.157, %struct.anon.158, %struct.anon.159, %struct.anon.160, %struct.anon.161, %struct.anon.162, %struct.anon.163, %struct.anon.164, %struct.anon.165, %struct.anon.166, %struct.anon.167, %struct.anon.168, %struct.anon.169, %struct.anon.170, %struct.anon.171, %struct.anon.172, %struct.anon.173, %struct.anon.174, %struct.anon.175, %struct.anon.176, %struct.anon.177, %struct.anon.178, %struct.anon.179, %struct.anon.180, %struct.anon.181, %struct.anon.182, %struct.anon.183, %struct.anon.184, %struct.anon.185, %struct.anon.186, %struct.anon.187, %struct.anon.188, %struct.anon.189, %struct.anon.190, %struct.anon.191, %struct.anon.192, %struct.anon.193, %struct.anon.194, %struct.anon.195, %struct.anon.196, %struct.anon.197, %struct.anon.198, %struct.anon.199, %struct.anon.200, %struct.anon.201, %struct.anon.202, %struct.anon.203, %struct.anon.204, %struct.anon.205, %struct.anon.206, %struct.anon.207, %struct.anon.208, %struct.anon.209, %struct.anon.210, %struct.anon.211, %struct.anon.212, %struct.anon.213, %struct.anon.214, %struct.anon.215, %struct.anon.216, %struct.anon.217, %struct.anon.218, %struct.anon.219, %struct.anon.220, %struct.anon.221, %struct.anon.222, %struct.anon.223, %struct.anon.224, %struct.anon.225, %struct.anon.226, %struct.anon.227, %struct.anon.228, %struct.anon.229, %struct.anon.230, %struct.anon.231, %struct.anon.232, %struct.anon.233, %struct.anon.234, %struct.anon.235, %struct.anon.236, %struct.anon.237, %struct.anon.238, %struct.anon.239, %struct.anon.240, %struct.anon.241, %struct.anon.242, %struct.anon.243, %struct.anon.244, %struct.anon.245, %struct.anon.246, %struct.anon.247, %struct.anon.248, %struct.anon.249, %struct.anon.250, %struct.anon.251, %struct.anon.252, %struct.anon.253, %struct.anon.254, %struct.anon.255, %struct.anon.256, %struct.anon.257, %struct.anon.258, %struct.anon.259, %struct.anon.260, %struct.anon.261, %struct.anon.262, %struct.anon.263, %struct.anon.264, %struct.anon.265, %struct.anon.266, %struct.anon.267, %struct.anon.268, %struct.anon.269, %struct.anon.270, %struct.anon.271, %struct.anon.272, %struct.anon.273, %struct.anon.274, %struct.anon.275, %struct.anon.276, %struct.anon.277, %struct.anon.278, %struct.anon.279, %struct.anon.280, %struct.anon.281, %struct.anon.282, %struct.anon.283, %struct.anon.284, %struct.anon.285, %struct.anon.286, %struct.anon.287, %struct.anon.288, %struct.anon.289, %struct.anon.290, %struct.anon.291, %struct.anon.292, %struct.anon.293, %struct.anon.294, %struct.anon.295, %struct.anon.296, %struct.anon.297, %struct.anon.298, %struct.anon.299, %struct.anon.300, %struct.anon.301, %struct.anon.302, %struct.anon.303, %struct.anon.304, %struct.anon.305, %struct.anon.306, %struct.anon.307, %struct.anon.308, %struct.anon.309, %struct.anon.310, %struct.anon.311, %struct.anon.312, %struct.anon.313, %struct.anon.314, %struct.anon.315, %struct.anon.316, %struct.anon.317, %struct.anon.318, %struct.anon.319, %struct.anon.320, %struct.anon.321, %struct.anon.322, %struct.anon.323, %struct.anon.324, %struct.anon.325, %struct.anon.326, %struct.anon.327, %struct.anon.328, %struct.anon.329, %struct.anon.330, %struct.anon.331, %struct.anon.332, %struct.anon.333, %struct.anon.334, %struct.anon.335, %struct.anon.336, %struct.anon.337, %struct.anon.338, %struct.anon.339, %struct.anon.340, %struct.anon.341, %struct.anon.342, %struct.anon.343, %struct.anon.344, %struct.anon.345, %struct.anon.346, %struct.anon.347, %struct.anon.348, %struct.anon.349, %struct.anon.350, %struct.anon.351, %struct.anon.352, %struct.anon.353, %struct.anon.354, %struct.anon.355, %struct.anon.356, %struct.anon.357, %struct.anon.358, %struct.anon.359, %struct.anon.360, %struct.anon.361, %struct.anon.362, %struct.anon.363, %struct.anon.364, %struct.anon.365, %struct.anon.366, %struct.anon.367, %struct.anon.368, %struct.anon.369, %struct.anon.370, %struct.anon.371, %struct.anon.372, %struct.anon.373, %struct.anon.374, %struct.anon.375, %struct.anon.376, %struct.anon.377, %struct.anon.378, %struct.anon.379, %struct.anon.380, %struct.anon.381, %struct.anon.382, %struct.anon.383, %struct.anon.384, %struct.anon.385, %struct.anon.386, %struct.anon.387, %struct.anon.388, %struct.anon.389, %struct.anon.390, %struct.anon.391, %struct.anon.392, %struct.anon.393, %struct.anon.394, %struct.anon.395, %struct.anon.396, %struct.anon.397, %struct.anon.398, %struct.anon.399, %struct.anon.400, %struct.anon.401, %struct.anon.402, %struct.anon.403, %struct.anon.404, %struct.anon.405, %struct.anon.406, %struct.anon.407, %struct.anon.408, %struct.anon.409, %struct.anon.410, %struct.anon.411, %struct.anon.412, %struct.anon.413, %struct.anon.414, %struct.anon.415, %struct.anon.416, %struct.anon.417, %struct.anon.418, %struct.anon.419, %struct.anon.420, %struct.anon.421, %struct.anon.422, %struct.anon.423, %struct.anon.424, %struct.anon.425, %struct.anon.426, %struct.anon.427, %struct.anon.428, %struct.anon.429, %struct.anon.430, %struct.anon.431, %struct.anon.432, %struct.anon.433, %struct.anon.434, %struct.anon.435, %struct.anon.436, %struct.anon.437, %struct.anon.438, %struct.anon.439, %struct.anon.440, %struct.anon.441, %struct.anon.442, %struct.anon.443, %struct.anon.444, %struct.anon.445, %struct.anon.446, %struct.anon.447, %struct.anon.448, %struct.anon.449, %struct.anon.450, %struct.anon.451, %struct.anon.452, %struct.anon.453, %struct.anon.454, %struct.anon.455, %struct.anon.456, %struct.anon.457, %struct.anon.458, %struct.anon.459, %struct.anon.460, %struct.anon.461, %struct.anon.462, %struct.anon.463, %struct.anon.464, %struct.anon.465, %struct.anon.466, %struct.anon.467, %struct.anon.468, %struct.anon.469, %struct.anon.470, %struct.anon.471, %struct.anon.472, %struct.anon.473, %struct.anon.474, %struct.anon.475, %struct.anon.476, %struct.anon.477, %struct.anon.478, %struct.anon.479, %struct.anon.480, %struct.anon.481, %struct.anon.482, %struct.anon.483, %struct.anon.484, %struct.anon.485, %struct.anon.486, %struct.anon.487, %struct.anon.488, %struct.anon.489, %struct.anon.490, %struct.anon.491, %struct.anon.492, %struct.anon.493, %struct.anon.494, %struct.anon.495, %struct.anon.496, %struct.anon.497, %struct.anon.498, %struct.anon.499, %struct.anon.500, %struct.anon.501, %struct.anon.502, %struct.anon.503, %struct.anon.504, %struct.anon.505, %struct.anon.506, %struct.anon.507, %struct.anon.508, %struct.anon.509, %struct.anon.510, %struct.anon.511, %struct.anon.512, %struct.anon.513, %struct.anon.514, %struct.anon.515, %struct.anon.516, %struct.anon.517, %struct.anon.518, %struct.anon.519, %struct.anon.520, %struct.anon.521, %struct.anon.522, %struct.anon.523, %struct.anon.524, %struct.anon.525, %struct.anon.526, %struct.anon.527, %struct.anon.528, %struct.anon.529, %struct.anon.530, %struct.anon.531, %struct.anon.532, %struct.anon.533, %struct.anon.534, %struct.anon.535, %struct.anon.536, %struct.anon.537, %struct.anon.538, %struct.anon.539, %struct.anon.540, %struct.anon.541, %struct.anon.542, %struct.anon.543, %struct.anon.544, %struct.anon.545, %struct.anon.546, %struct.anon.547, %struct.anon.548, %struct.anon.549, %struct.anon.550, %struct.anon.551, %struct.anon.552, %struct.anon.553, %struct.anon.554, %struct.anon.555, %struct.anon.556, %struct.anon.557, %struct.anon.558, %struct.anon.559, %struct.anon.560, %struct.anon.561, %struct.anon.562, %struct.anon.563, %struct.anon.564, %struct.anon.565, %struct.anon.566, %struct.anon.567, %struct.anon.568, %struct.anon.569, %struct.anon.570, %struct.anon.571, %struct.anon.572, %struct.anon.573, %struct.anon.574, %struct.anon.575, %struct.anon.576, %struct.anon.577, %struct.anon.578, %struct.anon.579, %struct.anon.580, %struct.anon.581, %struct.anon.582, %struct.anon.583, %struct.anon.584, %struct.anon.585, %struct.anon.586, %struct.anon.587, %struct.anon.588, %struct.anon.589, %struct.anon.590, %struct.anon.591, %struct.anon.592, %struct.anon.593, %struct.anon.594, %struct.anon.595, %struct.anon.596, %struct.anon.597, %struct.anon.598, %struct.anon.599, %struct.anon.600, %struct.anon.601, %struct.anon.602, %struct.anon.603, %struct.anon.604, %struct.anon.605, %struct.anon.606, %struct.anon.607, %struct.anon.608, %struct.anon.609, %struct.anon.610, %struct.anon.611, %struct.anon.612, %struct.anon.613, %struct.anon.614, %struct.anon.615, %struct.anon.616, %struct.anon.617, %struct.anon.618, %struct.anon.619, %struct.anon.620, %struct.anon.621, %struct.anon.622, %struct.anon.623, %struct.anon.624, %struct.anon.625, %struct.anon.626, %struct.anon.627, %struct.anon.628, %struct.anon.629, %struct.anon.630, %struct.anon.631, %struct.anon.632, %struct.anon.633, %struct.anon.634, %struct.anon.635, %struct.anon.636, %struct.anon.637, %struct.anon.638, %struct.anon.639, %struct.anon.640, %struct.anon.641, %struct.anon.642, %struct.anon.643, %struct.anon.644, %struct.anon.645, %struct.anon.646, %struct.anon.647, %struct.anon.648, %struct.anon.649, %struct.anon.650, %struct.anon.651, %struct.anon.652, %struct.anon.653, %struct.anon.654, %struct.anon.655, %struct.anon.656, %struct.anon.657, %struct.anon.658, %struct.anon.659, %struct.anon.660, %struct.anon.661, %struct.anon.662, %struct.anon.663, %struct.anon.664, %struct.anon.665, %struct.anon.666, %struct.anon.667, %struct.anon.668, %struct.anon.669, %struct.anon.670, %struct.anon.671, %struct.anon.672, %struct.anon.673, %struct.anon.674, %struct.anon.675, %struct.anon.676, %struct.anon.677, %struct.anon.678, %struct.anon.679, %struct.anon.680, %struct.anon.681, %struct.anon.682, %struct.anon.683, %struct.anon.684, %struct.anon.685, %struct.anon.686, %struct.anon.687, %struct.anon.688, %struct.anon.689, %struct.anon.690, %struct.anon.691, %struct.anon.692, %struct.anon.693, %struct.anon.694, %struct.anon.695, %struct.anon.696, %struct.anon.697, %struct.anon.698, %struct.anon.699, %struct.anon.700, %struct.anon.701, %struct.anon.702, %struct.anon.703, %struct.anon.704, %struct.anon.705, %struct.anon.706, %struct.anon.707, %struct.anon.708, %struct.anon.709, %struct.anon.710, %struct.anon.711, %struct.anon.712, %struct.anon.713, %struct.anon.714, %struct.anon.715, %struct.anon.716, %struct.anon.717, %struct.anon.718, %struct.anon.719, %struct.anon.720, %struct.anon.721, %struct.anon.722, %struct.anon.723, %struct.anon.724, %struct.anon.725, %struct.anon.726, %struct.anon.727, %struct.anon.728, %struct.anon.729, %struct.anon.730, %struct.anon.731, %struct.anon.732, %struct.anon.733, %struct.anon.734, %struct.anon.735, %struct.anon.736, %struct.anon.737, %struct.anon.738, %struct.anon.739, %struct.anon.740, %struct.anon.741, %struct.anon.742, %struct.anon.743, %struct.anon.744, %struct.anon.745, %struct.anon.746, %struct.anon.747, %struct.anon.748, %struct.anon.749, %struct.anon.750, %struct.anon.751, %struct.anon.752, %struct.anon.753, %struct.anon.754, %struct.anon.755, %struct.anon.756, %struct.anon.757, %struct.anon.758, %struct.anon.759, %struct.anon.760, %struct.anon.761, %struct.anon.762, %struct.anon.763, %struct.anon.764, %struct.anon.765, %struct.anon.766, %struct.anon.767, %struct.anon.768, %struct.anon.769, %struct.anon.770, %struct.anon.771, %struct.anon.772, %struct.anon.773, %struct.anon.774, %struct.anon.775, %struct.anon.776, %struct.anon.777 }
%struct.anon.86 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.87 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.88 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.89 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.90 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.91 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.92 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.93 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.94 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.95 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.96 = type { %struct.PyASCIIObject, [18 x i8] }
%struct.anon.97 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.98 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.99 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.100 = type { %struct.PyASCIIObject, [20 x i8] }
%struct.anon.101 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.102 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.103 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.104 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.105 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.106 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.107 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.108 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.109 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.110 = type { %struct.PyASCIIObject, [31 x i8] }
%struct.anon.111 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.112 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.113 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.114 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.115 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.116 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.117 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.118 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.119 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.120 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.121 = type { %struct.PyASCIIObject, [18 x i8] }
%struct.anon.122 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.123 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.124 = type { %struct.PyASCIIObject, [18 x i8] }
%struct.anon.125 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.126 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.127 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.128 = type { %struct.PyASCIIObject, [25 x i8] }
%struct.anon.129 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.130 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.131 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.132 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.133 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.134 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.135 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.136 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.137 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.138 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.139 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.140 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.141 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.142 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.143 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.144 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.145 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.146 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.147 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.148 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.149 = type { %struct.PyASCIIObject, [17 x i8] }
%struct.anon.150 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.151 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.152 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.153 = type { %struct.PyASCIIObject, [18 x i8] }
%struct.anon.154 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.155 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.156 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.157 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.158 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.159 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.160 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.161 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.162 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.163 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.164 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.165 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.166 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.167 = type { %struct.PyASCIIObject, [18 x i8] }
%struct.anon.168 = type { %struct.PyASCIIObject, [18 x i8] }
%struct.anon.169 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.170 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.171 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.172 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.173 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.174 = type { %struct.PyASCIIObject, [21 x i8] }
%struct.anon.175 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.176 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.177 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.178 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.179 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.180 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.181 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.182 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.183 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.184 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.185 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.186 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.187 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.188 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.189 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.190 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.191 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.192 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.193 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.194 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.195 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.196 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.197 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.198 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.199 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.200 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.201 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.202 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.203 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.204 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.205 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.206 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.207 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.208 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.209 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.210 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.211 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.212 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.213 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.214 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.215 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.216 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.217 = type { %struct.PyASCIIObject, [19 x i8] }
%struct.anon.218 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.219 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.220 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.221 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.222 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.223 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.224 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.225 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.226 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.227 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.228 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.229 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.230 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.231 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.232 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.233 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.234 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.235 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.236 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.237 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.238 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.239 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.240 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.241 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.242 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.243 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.244 = type { %struct.PyASCIIObject, [18 x i8] }
%struct.anon.245 = type { %struct.PyASCIIObject, [17 x i8] }
%struct.anon.246 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.247 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.248 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.249 = type { %struct.PyASCIIObject, [36 x i8] }
%struct.anon.250 = type { %struct.PyASCIIObject, [25 x i8] }
%struct.anon.251 = type { %struct.PyASCIIObject, [17 x i8] }
%struct.anon.252 = type { %struct.PyASCIIObject, [31 x i8] }
%struct.anon.253 = type { %struct.PyASCIIObject, [20 x i8] }
%struct.anon.254 = type { %struct.PyASCIIObject, [19 x i8] }
%struct.anon.255 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.256 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.257 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.258 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.259 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.260 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.261 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.262 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.263 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.264 = type { %struct.PyASCIIObject, [25 x i8] }
%struct.anon.265 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.266 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.267 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.268 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.269 = type { %struct.PyASCIIObject, [17 x i8] }
%struct.anon.270 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.271 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.272 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.273 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.274 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.275 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.276 = type { %struct.PyASCIIObject, [17 x i8] }
%struct.anon.277 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.278 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.279 = type { %struct.PyASCIIObject, [18 x i8] }
%struct.anon.280 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.281 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.282 = type { %struct.PyASCIIObject, [20 x i8] }
%struct.anon.283 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.284 = type { %struct.PyASCIIObject, [19 x i8] }
%struct.anon.285 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.286 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.287 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.288 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.289 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.290 = type { %struct.PyASCIIObject, [19 x i8] }
%struct.anon.291 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.292 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.293 = type { %struct.PyASCIIObject, [26 x i8] }
%struct.anon.294 = type { %struct.PyASCIIObject, [26 x i8] }
%struct.anon.295 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.296 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.297 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.298 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.299 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.300 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.301 = type { %struct.PyASCIIObject, [18 x i8] }
%struct.anon.302 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.303 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.304 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.305 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.306 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.307 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.308 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.309 = type { %struct.PyASCIIObject, [17 x i8] }
%struct.anon.310 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.311 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.312 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.313 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.314 = type { %struct.PyASCIIObject, [20 x i8] }
%struct.anon.315 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.316 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.317 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.318 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.319 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.320 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.321 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.322 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.323 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.324 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.325 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.326 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.327 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.328 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.329 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.330 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.331 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.332 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.333 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.334 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.335 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.336 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.337 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.338 = type { %struct.PyASCIIObject, [18 x i8] }
%struct.anon.339 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.340 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.341 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.342 = type { %struct.PyASCIIObject, [23 x i8] }
%struct.anon.343 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.344 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.345 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.346 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.347 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.348 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.349 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.350 = type { %struct.PyASCIIObject, [18 x i8] }
%struct.anon.351 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.352 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.353 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.354 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.355 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.356 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.357 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.358 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.359 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.360 = type { %struct.PyASCIIObject, [18 x i8] }
%struct.anon.361 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.362 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.363 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.364 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.365 = type { %struct.PyASCIIObject, [18 x i8] }
%struct.anon.366 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.367 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.368 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.369 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.370 = type { %struct.PyASCIIObject, [19 x i8] }
%struct.anon.371 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.372 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.373 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.374 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.375 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.376 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.377 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.378 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.379 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.380 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.381 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.382 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.383 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.384 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.385 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.386 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.387 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.388 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.389 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.390 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.391 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.392 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.393 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.394 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.395 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.396 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.397 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.398 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.399 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.400 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.401 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.402 = type { %struct.PyASCIIObject, [18 x i8] }
%struct.anon.403 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.404 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.405 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.406 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.407 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.408 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.409 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.410 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.411 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.412 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.413 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.414 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.415 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.416 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.417 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.418 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.419 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.420 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.421 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.422 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.423 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.424 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.425 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.426 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.427 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.428 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.429 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.430 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.431 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.432 = type { %struct.PyASCIIObject, [19 x i8] }
%struct.anon.433 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.434 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.435 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.436 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.437 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.438 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.439 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.440 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.441 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.442 = type { %struct.PyASCIIObject, [3 x i8] }
%struct.anon.443 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.444 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.445 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.446 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.447 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.448 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.449 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.450 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.451 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.452 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.453 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.454 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.455 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.456 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.457 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.458 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.459 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.460 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.461 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.462 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.463 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.464 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.465 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.466 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.467 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.468 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.469 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.470 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.471 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.472 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.473 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.474 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.475 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.476 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.477 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.478 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.479 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.480 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.481 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.482 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.483 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.484 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.485 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.486 = type { %struct.PyASCIIObject, [3 x i8] }
%struct.anon.487 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.488 = type { %struct.PyASCIIObject, [3 x i8] }
%struct.anon.489 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.490 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.491 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.492 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.493 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.494 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.495 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.496 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.497 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.498 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.499 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.500 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.501 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.502 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.503 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.504 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.505 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.506 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.507 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.508 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.509 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.510 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.511 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.512 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.513 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.514 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.515 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.516 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.517 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.518 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.519 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.520 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.521 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.522 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.523 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.524 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.525 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.526 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.527 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.528 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.529 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.530 = type { %struct.PyASCIIObject, [3 x i8] }
%struct.anon.531 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.532 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.533 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.534 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.535 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.536 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.537 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.538 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.539 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.540 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.541 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.542 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.543 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.544 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.545 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.546 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.547 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.548 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.549 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.550 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.551 = type { %struct.PyASCIIObject, [3 x i8] }
%struct.anon.552 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.553 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.554 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.555 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.556 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.557 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.558 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.559 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.560 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.561 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.562 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.563 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.564 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.565 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.566 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.567 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.568 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.569 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.570 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.571 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.572 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.573 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.574 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.575 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.576 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.577 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.578 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.579 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.580 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.581 = type { %struct.PyASCIIObject, [18 x i8] }
%struct.anon.582 = type { %struct.PyASCIIObject, [17 x i8] }
%struct.anon.583 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.584 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.585 = type { %struct.PyASCIIObject, [20 x i8] }
%struct.anon.586 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.587 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.588 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.589 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.590 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.591 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.592 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.593 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.594 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.595 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.596 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.597 = type { %struct.PyASCIIObject, [3 x i8] }
%struct.anon.598 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.599 = type { %struct.PyASCIIObject, [3 x i8] }
%struct.anon.600 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.601 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.602 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.603 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.604 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.605 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.606 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.607 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.608 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.609 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.610 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.611 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.612 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.613 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.614 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.615 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.616 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.617 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.618 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.619 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.620 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.621 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.622 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.623 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.624 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.625 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.626 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.627 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.628 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.629 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.630 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.631 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.632 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.633 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.634 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.635 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.636 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.637 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.638 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.639 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.640 = type { %struct.PyASCIIObject, [20 x i8] }
%struct.anon.641 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.642 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.643 = type { %struct.PyASCIIObject, [17 x i8] }
%struct.anon.644 = type { %struct.PyASCIIObject, [17 x i8] }
%struct.anon.645 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.646 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.647 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.648 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.649 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.650 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.651 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.652 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.653 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.654 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.655 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.656 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.657 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.658 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.659 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.660 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.661 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.662 = type { %struct.PyASCIIObject, [17 x i8] }
%struct.anon.663 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.664 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.665 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.666 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.667 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.668 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.669 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.670 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.671 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.672 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.673 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.674 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.675 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.676 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.677 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.678 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.679 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.680 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.681 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.682 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.683 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.684 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.685 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.686 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.687 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.688 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.689 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.690 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.691 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.692 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.693 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.694 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.695 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.696 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.697 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.698 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.699 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.700 = type { %struct.PyASCIIObject, [19 x i8] }
%struct.anon.701 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.702 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.703 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.704 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.705 = type { %struct.PyASCIIObject, [17 x i8] }
%struct.anon.706 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.707 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.708 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.709 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.710 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.711 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.712 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.713 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.714 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.715 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.716 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.717 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.718 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.719 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.720 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.721 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.722 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.723 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.724 = type { %struct.PyASCIIObject, [28 x i8] }
%struct.anon.725 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.726 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.727 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.728 = type { %struct.PyASCIIObject, [20 x i8] }
%struct.anon.729 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.730 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.731 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.732 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.733 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.734 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.735 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.736 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.737 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.738 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.739 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.740 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.741 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.742 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.743 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.744 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.745 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.746 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.747 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.748 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.749 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.750 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.751 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.752 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.753 = type { %struct.PyASCIIObject, [3 x i8] }
%struct.anon.754 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.755 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.756 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.757 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.758 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.759 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.760 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.761 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.762 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.763 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.764 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.765 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.766 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.767 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.768 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.769 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.770 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.771 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.772 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.773 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.774 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.775 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.776 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.777 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.778 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.779 = type { %struct.PyCompactUnicodeObject, [2 x i8] }
%struct.PyCompactUnicodeObject = type { %struct.PyASCIIObject, i64, ptr }
%struct.PyTupleObject = type { %struct.PyVarObject, [1 x ptr] }
%struct.PyGC_Head = type { i64, i64 }
%struct.PyHamtNode_Bitmap = type { %struct.PyVarObject, i32, [1 x ptr] }
%struct._PyContextTokenMissing = type { %struct._object }
%struct._is = type { %struct._ceval_state, ptr, i64, i64, i32, ptr, i32, i32, i64, %struct.pythreads, ptr, ptr, i64, %struct._gc_runtime_state, ptr, ptr, %struct._import_state, %struct._gil_runtime_state, ptr, ptr, ptr, i32, %struct.PyConfig, i64, ptr, ptr, ptr, ptr, [8 x ptr], i8, i64, [255 x ptr], %struct._xi_state, ptr, ptr, ptr, %struct._warnings_runtime_state, %struct.atexit_state, %struct._obmalloc_state, ptr, [8 x ptr], [8 x ptr], i8, %struct._py_object_state, %struct._Py_unicode_state, %struct._Py_float_state, %struct._Py_long_state, %struct._dtoa_state, %struct._py_func_state, ptr, %struct._Py_tuple_state, %struct._Py_list_state, %struct._Py_dict_state, %struct._Py_async_gen_state, %struct._Py_context_state, %struct._Py_exc_state, %struct.ast_state, %struct.types_state, %struct.callable_cache, ptr, ptr, i16, i16, i32, %struct._Py_GlobalMonitors, i8, i8, i64, i64, [8 x [17 x ptr]], [8 x ptr], %struct._Py_interp_cached_objects, %struct._Py_interp_static_objects, %struct._PyThreadStateImpl, i64 }
%struct._ceval_state = type { i64, [7 x i64], i32, ptr, i32, %struct._pending_calls }
%struct.pythreads = type { i64, ptr, ptr, i64, i64 }
%struct._gc_runtime_state = type { ptr, i32, i32, i32, [3 x %struct.gc_generation], ptr, %struct.gc_generation, [3 x %struct.gc_generation_stats], i32, ptr, ptr, i64, i64 }
%struct.gc_generation = type { %struct.PyGC_Head, i32, i32 }
%struct.gc_generation_stats = type { i64, i64, i64 }
%struct._import_state = type { ptr, ptr, ptr, i32, i32, i32, ptr, %struct.anon.780, %struct.anon.781 }
%struct.anon.780 = type { ptr, i64, i32 }
%struct.anon.781 = type { i32, i64, i32 }
%struct._gil_runtime_state = type { i64, ptr, i32, i64, %union.pthread_cond_t, %union.pthread_mutex_t, %union.pthread_cond_t, %union.pthread_mutex_t }
%union.pthread_cond_t = type { %struct.__pthread_cond_s }
%struct.__pthread_cond_s = type { %union.__atomic_wide_counter, %union.__atomic_wide_counter, [2 x i32], [2 x i32], i32, i32, [2 x i32] }
%union.__atomic_wide_counter = type { i64 }
%union.pthread_mutex_t = type { %struct.__pthread_mutex_s }
%struct.__pthread_mutex_s = type { i32, i32, i32, i32, i32, i16, i16, %struct.__pthread_internal_list }
%struct.__pthread_internal_list = type { ptr, ptr }
%struct.PyConfig = type { i32, i32, i32, i32, i32, i32, i64, i32, i32, i32, i32, i32, i32, i32, ptr, i32, ptr, ptr, ptr, i32, %struct.PyWideStringList, %struct.PyWideStringList, %struct.PyWideStringList, %struct.PyWideStringList, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, ptr, ptr, ptr, i32, i32, i32, i32, i32, ptr, ptr, ptr, ptr, i32, %struct.PyWideStringList, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i32, ptr, ptr, ptr, ptr, i32, i32, i32 }
%struct._xi_state = type { %struct._xidregistry, ptr }
%struct._warnings_runtime_state = type { ptr, ptr, ptr, i64 }
%struct.atexit_state = type { ptr, ptr, ptr, i32, i32 }
%struct._obmalloc_state = type { %struct._obmalloc_pools, %struct._obmalloc_mgmt, %struct._obmalloc_usage }
%struct._obmalloc_pools = type { [64 x ptr] }
%struct._obmalloc_mgmt = type { ptr, i32, ptr, ptr, [65 x ptr], i64, i64, i64, i64 }
%struct._obmalloc_usage = type { %struct.arena_map_top, i32, i32 }
%struct.arena_map_top = type { [32768 x ptr] }
%struct._py_object_state = type { i32 }
%struct._Py_unicode_state = type { %struct._Py_unicode_fs_codec, ptr, %struct._Py_unicode_ids }
%struct._Py_unicode_fs_codec = type { ptr, i32, ptr, i32 }
%struct._Py_unicode_ids = type { i64, ptr }
%struct._Py_float_state = type { i32, ptr }
%struct._Py_long_state = type { i32 }
%struct._dtoa_state = type { [8 x ptr], [8 x ptr], [288 x double], ptr }
%struct._py_func_state = type { i32, [4096 x ptr] }
%struct._Py_tuple_state = type { [20 x ptr], [20 x i32] }
%struct._Py_list_state = type { [80 x ptr], i32 }
%struct._Py_dict_state = type { i64, i32, [80 x ptr], [80 x ptr], i32, i32, [8 x ptr] }
%struct._Py_async_gen_state = type { [80 x ptr], i32, [80 x ptr], i32 }
%struct._Py_context_state = type { ptr, i32 }
%struct._Py_exc_state = type { ptr, ptr, i32, ptr }
%struct.ast_state = type { %struct._PyOnceFlag, i32, i32, i32, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr }
%struct._PyOnceFlag = type { i8 }
%struct.types_state = type { i32, %struct.type_cache, i64, [200 x %struct.static_builtin_state] }
%struct.type_cache = type { [4096 x %struct.type_cache_entry] }
%struct.type_cache_entry = type { i32, ptr, ptr }
%struct.static_builtin_state = type { ptr, i32, i32, ptr, ptr, ptr }
%struct.callable_cache = type { ptr, ptr, ptr, ptr }
%struct._Py_GlobalMonitors = type { [15 x i8] }
%struct._Py_interp_cached_objects = type { ptr, ptr, ptr, ptr, [10 x ptr], ptr, ptr, ptr, ptr, ptr, ptr }
%struct._Py_interp_static_objects = type { %struct.anon.783 }
%struct.anon.783 = type { i32, %struct.PyGC_Head, %struct.PyHamtObject, %struct.PyBaseExceptionObject }
%struct.PyHamtObject = type { %struct._object, ptr, ptr, i64 }
%struct.PyBaseExceptionObject = type { %struct._object, ptr, ptr, ptr, ptr, ptr, ptr, i8 }
%struct._PyThreadStateImpl = type { %struct._ts }
%struct._ts = type { ptr, ptr, ptr, %struct.anon.784, i32, i32, i32, i32, i32, i32, i32, i32, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i32, ptr, i64, i64, %struct._py_trashcan, i64, ptr, ptr, i32, ptr, ptr, ptr, i64, i64, ptr, ptr, ptr, %struct._err_stackitem }
%struct.anon.784 = type { i32 }
%struct._py_trashcan = type { i32, ptr }
%struct._err_stackitem = type { ptr, ptr }
%struct.mi_block_s = type { i64 }
%struct.mi_segment_s = type { %struct.mi_memid_s, i8, i8, i64, i64, %struct.mi_commit_mask_s, %struct.mi_commit_mask_s, ptr, ptr, i64, i64, i64, i64, i64, i64, i32, i64, i64, [513 x %struct.mi_page_s] }
%struct.mi_memid_s = type { %union.anon, i8, i8, i8, i32 }
%union.anon = type { %struct.mi_memid_os_info }
%struct.mi_memid_os_info = type { ptr, i64 }
%struct.mi_commit_mask_s = type { [8 x i64] }
%struct.mi_memid_arena_info = type { i64, i32, i8 }
%struct.mi_arena_s = type { i32, %struct.mi_memid_s, ptr, i64, i64, i64, %struct.mi_memid_s, i32, i8, i8, i64, i64, ptr, ptr, ptr, [1 x i64] }
%struct.__va_list_tag = type { i32, i32, ptr, ptr }
%struct.mi_visit_blocks_args_s = type { i8, ptr, ptr }
%struct.mi_heap_area_ex_s = type { %struct.mi_heap_area_s, ptr }
%struct.mi_heap_area_s = type { ptr, i64, i64, i64, i64, i64 }
%struct.mi_thread_data_s = type { %struct.mi_heap_s, %struct.mi_tld_s, %struct.mi_memid_s }
%struct.timespec = type { i64, i64 }
%struct.buffered_s = type { ptr, ptr, ptr, i64, i64 }
%struct.mi_process_info_s = type { i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.rusage = type { %struct.timeval, %struct.timeval, %union.anon.0, %union.anon.1, %union.anon.2, %union.anon.3, %union.anon.4, %union.anon.5, %union.anon.6, %union.anon.7, %union.anon.8, %union.anon.9, %union.anon.10, %union.anon.11, %union.anon.12, %union.anon.13 }
%struct.timeval = type { i64, i64 }
%union.anon.0 = type { i64 }
%union.anon.1 = type { i64 }
%union.anon.2 = type { i64 }
%union.anon.3 = type { i64 }
%union.anon.4 = type { i64 }
%union.anon.5 = type { i64 }
%union.anon.6 = type { i64 }
%union.anon.7 = type { i64 }
%union.anon.8 = type { i64 }
%union.anon.9 = type { i64 }
%union.anon.10 = type { i64 }
%union.anon.11 = type { i64 }
%union.anon.12 = type { i64 }
%union.anon.13 = type { i64 }
%struct.arena_object = type { i64, ptr, i32, i32, ptr, ptr, ptr }
%struct.pool_header = type { %union.anon.785, ptr, ptr, ptr, i32, i32, i32, i32 }
%union.anon.785 = type { ptr }
%struct._alloc_stats = type { i64, i64, i64, i64, i64 }
%struct.arena_map_bot = type { [16384 x %struct.arena_coverage_t] }
%struct.arena_coverage_t = type { i32, i32 }

@.str = private unnamed_addr constant [8 x i8] c"mi_free\00", align 1
@.str.1 = private unnamed_addr constant [15 x i8] c"mi_usable_size\00", align 1
@.str.2 = private unnamed_addr constant [10 x i8] c"mi_expand\00", align 1
@.str.3 = private unnamed_addr constant [11 x i8] c"mi_realloc\00", align 1
@mi_arenas = internal global [112 x ptr] zeroinitializer, align 64
@.str.4 = private unnamed_addr constant [68 x i8] c"trying to free from non-existent arena: %p, size %zu, memid: 0x%zx\0A\00", align 1
@.str.5 = private unnamed_addr constant [74 x i8] c"trying to free from non-existent arena block: %p, size %zu, memid: 0x%zx\0A\00", align 1
@.str.6 = private unnamed_addr constant [59 x i8] c"trying to free an already freed arena block: %p, size %zu\0A\00", align 1
@mi_arena_count = internal global i64 0, align 64
@_mi_stats_main = hidden global %struct.mi_stats_s zeroinitializer, align 64
@.str.7 = private unnamed_addr constant [32 x i8] c"failed to reserve %zu k memory\0A\00", align 1
@.str.8 = private unnamed_addr constant [27 x i8] c"reserved %zu KiB memory%s\0A\00", align 1
@.str.9 = private unnamed_addr constant [21 x i8] c" (in large os pages)\00", align 1
@.str.10 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.11 = private unnamed_addr constant [39 x i8] c"arena %zu: %zu blocks with %zu fields\0A\00", align 1
@.str.12 = private unnamed_addr constant [3 x i8] c"  \00", align 1
@.str.13 = private unnamed_addr constant [28 x i8] c"  blocks in use ('x'): %zu\0A\00", align 1
@.str.14 = private unnamed_addr constant [38 x i8] c"failed to reserve %zu GiB huge pages\0A\00", align 1
@.str.15 = private unnamed_addr constant [70 x i8] c"numa node %i: reserved %zu GiB huge pages (of the %zu GiB requested)\0A\00", align 1
@.str.16 = private unnamed_addr constant [92 x i8] c"mi_reserve_huge_os_pages is deprecated: use mi_reserve_huge_os_pages_interleave/at instead\0A\00", align 1
@_mi_heap_empty = hidden constant %struct.mi_heap_s { ptr null, [129 x ptr] [ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty], [75 x %struct.mi_page_queue_s] [%struct.mi_page_queue_s { ptr null, ptr null, i64 8 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 8 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 16 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 24 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 32 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 40 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 48 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 56 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 64 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 80 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 96 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 112 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 128 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 160 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 192 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 224 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 256 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 320 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 384 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 448 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 512 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 640 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 768 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 896 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 1024 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 1280 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 1536 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 1792 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 2048 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 2560 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 3072 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 3584 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 4096 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 5120 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 6144 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 7168 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 8192 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 10240 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 12288 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 14336 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 16384 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 20480 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 24576 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 28672 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 32768 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 40960 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 49152 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 57344 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 65536 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 81920 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 98304 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 114688 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 131072 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 163840 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 196608 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 229376 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 262144 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 327680 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 393216 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 458752 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 524288 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 655360 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 786432 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 917504 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 1048576 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 1310720 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 1572864 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 1835008 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 2097152 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 2621440 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 3145728 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 3670016 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 4194304 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 131080 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 131088 }], ptr null, i64 0, i32 0, i64 0, [2 x i64] zeroinitializer, %struct.mi_random_cxt_s { [16 x i32] zeroinitializer, [16 x i32] zeroinitializer, i32 0, i8 1 }, i64 0, i64 74, i64 0, ptr null, i8 0 }, align 64
@_mi_page_empty = hidden constant %struct.mi_page_s zeroinitializer, align 64
@_mi_heap_default = hidden thread_local global ptr @_mi_heap_empty, align 8
@tld_main = internal global %struct.mi_tld_s { i64 0, i8 0, ptr @_mi_heap_main, ptr @_mi_heap_main, %struct.mi_segments_tld_s { [36 x %struct.mi_span_queue_s] [%struct.mi_span_queue_s { ptr null, ptr null, i64 1 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 1 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 2 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 3 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 4 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 5 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 6 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 7 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 10 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 12 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 14 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 16 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 20 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 24 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 28 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 32 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 40 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 48 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 56 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 64 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 80 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 96 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 112 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 128 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 160 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 192 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 224 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 256 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 320 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 384 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 448 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 512 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 640 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 768 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 896 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 1024 }], i64 0, i64 0, i64 0, i64 0, ptr getelementptr (i8, ptr @tld_main, i64 960), ptr getelementptr (i8, ptr @tld_main, i64 944) }, %struct.mi_os_tld_s { i64 0, ptr getelementptr (i8, ptr @tld_main, i64 960) }, %struct.mi_stats_s zeroinitializer }, align 8
@_mi_heap_main = hidden global { ptr, [129 x ptr], [75 x %struct.mi_page_queue_s], ptr, i64, i32, i64, [2 x i64], { <{ i32, [15 x i32] }>, [16 x i32], i32, i8 }, i64, i64, i64, ptr, i8 } { ptr @tld_main, [129 x ptr] [ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty, ptr @_mi_page_empty], [75 x %struct.mi_page_queue_s] [%struct.mi_page_queue_s { ptr null, ptr null, i64 8 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 8 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 16 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 24 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 32 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 40 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 48 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 56 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 64 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 80 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 96 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 112 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 128 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 160 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 192 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 224 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 256 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 320 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 384 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 448 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 512 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 640 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 768 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 896 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 1024 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 1280 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 1536 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 1792 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 2048 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 2560 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 3072 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 3584 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 4096 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 5120 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 6144 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 7168 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 8192 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 10240 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 12288 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 14336 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 16384 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 20480 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 24576 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 28672 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 32768 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 40960 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 49152 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 57344 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 65536 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 81920 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 98304 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 114688 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 131072 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 163840 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 196608 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 229376 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 262144 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 327680 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 393216 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 458752 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 524288 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 655360 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 786432 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 917504 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 1048576 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 1310720 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 1572864 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 1835008 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 2097152 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 2621440 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 3145728 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 3670016 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 4194304 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 131080 }, %struct.mi_page_queue_s { ptr null, ptr null, i64 131088 }], ptr null, i64 0, i32 0, i64 0, [2 x i64] zeroinitializer, { <{ i32, [15 x i32] }>, [16 x i32], i32, i8 } { <{ i32, [15 x i32] }> <{ i32 -2073254261, [15 x i32] zeroinitializer }>, [16 x i32] zeroinitializer, i32 0, i8 1 }, i64 0, i64 74, i64 0, ptr null, i8 0 }, align 8
@_mi_process_is_initialized = hidden global i8 0, align 1
@td_cache = internal global [16 x ptr] zeroinitializer, align 16
@thread_count = internal global i64 1, align 8
@os_preloading = internal global i8 1, align 1
@mi_redirected = internal global i8 0, align 1
@mi_process_init.process_init = internal global i64 0, align 8
@.str.17 = private unnamed_addr constant [21 x i8] c"process init: 0x%zx\0A\00", align 1
@.str.18 = private unnamed_addr constant [18 x i8] c"secure level: %d\0A\00", align 1
@.str.19 = private unnamed_addr constant [18 x i8] c"mem tracking: %s\0A\00", align 1
@.str.20 = private unnamed_addr constant [5 x i8] c"none\00", align 1
@options = internal global [26 x %struct.mi_option_desc_s] [%struct.mi_option_desc_s { i64 0, i32 0, i32 0, ptr @.str.50, ptr null }, %struct.mi_option_desc_s { i64 0, i32 0, i32 1, ptr @.str.51, ptr null }, %struct.mi_option_desc_s { i64 0, i32 0, i32 2, ptr @.str.52, ptr null }, %struct.mi_option_desc_s { i64 1, i32 0, i32 3, ptr @.str.53, ptr null }, %struct.mi_option_desc_s { i64 2, i32 0, i32 4, ptr @.str.54, ptr @.str.55 }, %struct.mi_option_desc_s { i64 1, i32 0, i32 5, ptr @.str.56, ptr @.str.57 }, %struct.mi_option_desc_s { i64 0, i32 0, i32 6, ptr @.str.58, ptr @.str.59 }, %struct.mi_option_desc_s { i64 0, i32 0, i32 7, ptr @.str.60, ptr null }, %struct.mi_option_desc_s { i64 -1, i32 0, i32 8, ptr @.str.61, ptr null }, %struct.mi_option_desc_s { i64 0, i32 0, i32 9, ptr @.str.62, ptr null }, %struct.mi_option_desc_s { i64 0, i32 0, i32 10, ptr @.str.63, ptr null }, %struct.mi_option_desc_s { i64 0, i32 0, i32 11, ptr @.str.64, ptr null }, %struct.mi_option_desc_s { i64 0, i32 0, i32 12, ptr @.str.65, ptr @.str.66 }, %struct.mi_option_desc_s { i64 0, i32 0, i32 13, ptr @.str.67, ptr null }, %struct.mi_option_desc_s { i64 1, i32 0, i32 14, ptr @.str.68, ptr null }, %struct.mi_option_desc_s { i64 10, i32 0, i32 15, ptr @.str.69, ptr @.str.70 }, %struct.mi_option_desc_s { i64 0, i32 0, i32 16, ptr @.str.71, ptr null }, %struct.mi_option_desc_s { i64 0, i32 0, i32 17, ptr @.str.72, ptr null }, %struct.mi_option_desc_s { i64 100, i32 0, i32 18, ptr @.str.73, ptr null }, %struct.mi_option_desc_s { i64 16, i32 0, i32 19, ptr @.str.74, ptr null }, %struct.mi_option_desc_s { i64 16, i32 0, i32 20, ptr @.str.75, ptr null }, %struct.mi_option_desc_s { i64 8, i32 0, i32 21, ptr @.str.76, ptr null }, %struct.mi_option_desc_s { i64 0, i32 0, i32 22, ptr @.str.77, ptr null }, %struct.mi_option_desc_s { i64 1048576, i32 0, i32 23, ptr @.str.78, ptr null }, %struct.mi_option_desc_s { i64 10, i32 0, i32 24, ptr @.str.79, ptr null }, %struct.mi_option_desc_s { i64 1, i32 0, i32 25, ptr @.str.80, ptr @.str.81 }], align 16
@.str.21 = private unnamed_addr constant [18 x i8] c"option '%s': %ld\0A\00", align 1
@mi_max_error_count = internal global i64 16, align 8
@mi_max_warning_count = internal global i64 16, align 8
@mi_out_default = internal global ptr null, align 8
@mi_out_arg = internal global ptr null, align 8
@stdout = external global ptr, align 8
@stderr = external global ptr, align 8
@.str.22 = private unnamed_addr constant [11 x i8] c"mimalloc: \00", align 1
@warning_count = internal global i64 0, align 8
@.str.23 = private unnamed_addr constant [20 x i8] c"mimalloc: warning: \00", align 1
@mi_error_handler = internal global ptr null, align 8
@mi_error_arg = internal global ptr null, align 8
@mi_os_mem_config = internal global %struct.mi_os_mem_config_s { i64 4096, i64 0, i64 4096, i8 1, i8 0, i8 1 }, align 8
@aligned_base = internal global i64 0, align 64
@.str.24 = private unnamed_addr constant [76 x i8] c"cannot commit OS memory (error: %d (0x%x), address: %p, size: 0x%zx bytes)\0A\00", align 1
@.str.25 = private unnamed_addr constant [75 x i8] c"cannot reset OS memory (error: %d (0x%x), address: %p, size: 0x%zx bytes)\0A\00", align 1
@.str.26 = private unnamed_addr constant [82 x i8] c"unable to allocate huge OS page (error: %d (0x%x), address: %p, size: %zx bytes)\0A\00", align 1
@.str.27 = private unnamed_addr constant [54 x i8] c"could not allocate contiguous huge OS page %zu at %p\0A\00", align 1
@.str.28 = private unnamed_addr constant [66 x i8] c"huge OS page allocation timed out (after allocating %zu page(s))\0A\00", align 1
@_mi_numa_node_count = hidden global i64 0, align 8
@.str.29 = private unnamed_addr constant [24 x i8] c"using %zd numa regions\0A\00", align 1
@deferred_free = internal global ptr null, align 8
@deferred_arg = internal global ptr null, align 8
@.str.30 = private unnamed_addr constant [39 x i8] c"unable to allocate memory (%zu bytes)\0A\00", align 1
@abandoned_readers = internal global i64 0, align 64
@mi_segment_map = internal global [20481 x i64] zeroinitializer, align 16
@mi_process_start = internal global i64 0, align 8
@mi_clock_diff = internal global i64 0, align 8
@_mi_prim_reset.advice = internal global i64 8, align 8
@.str.31 = private unnamed_addr constant [69 x i8] c"failed to bind huge (1GiB) pages to numa node %d (error: %d (0x%x))\0A\00", align 1
@.str.32 = private unnamed_addr constant [32 x i8] c"/sys/devices/system/node/node%u\00", align 1
@_mi_prim_random_buf.no_getrandom = internal global i64 0, align 8
@.str.33 = private unnamed_addr constant [13 x i8] c"/dev/urandom\00", align 1
@_mi_heap_default_key = hidden global i32 -1, align 4
@_PyRuntime = external global %struct.pyruntimestate, align 8
@.str.34 = private unnamed_addr constant [8 x i8] c"default\00", align 1
@.str.35 = private unnamed_addr constant [6 x i8] c"debug\00", align 1
@.str.36 = private unnamed_addr constant [9 x i8] c"pymalloc\00", align 1
@.str.37 = private unnamed_addr constant [15 x i8] c"pymalloc_debug\00", align 1
@.str.38 = private unnamed_addr constant [9 x i8] c"mimalloc\00", align 1
@.str.39 = private unnamed_addr constant [15 x i8] c"mimalloc_debug\00", align 1
@.str.40 = private unnamed_addr constant [7 x i8] c"malloc\00", align 1
@.str.41 = private unnamed_addr constant [13 x i8] c"malloc_debug\00", align 1
@__func__._PyInterpreterState_GetAllocatedBlocks = private unnamed_addr constant [39 x i8] c"_PyInterpreterState_GetAllocatedBlocks\00", align 1
@.str.42 = private unnamed_addr constant [47 x i8] c"the interpreter doesn't have its own allocator\00", align 1
@last_final_leaks = internal global i64 0, align 8
@__func__._PyMem_DebugRawFree = private unnamed_addr constant [20 x i8] c"_PyMem_DebugRawFree\00", align 1
@__func__._PyMem_DebugRawRealloc = private unnamed_addr constant [23 x i8] c"_PyMem_DebugRawRealloc\00", align 1
@__func__._PyMem_DebugMalloc = private unnamed_addr constant [19 x i8] c"_PyMem_DebugMalloc\00", align 1
@__func__._PyMem_DebugCalloc = private unnamed_addr constant [19 x i8] c"_PyMem_DebugCalloc\00", align 1
@__func__._PyMem_DebugFree = private unnamed_addr constant [17 x i8] c"_PyMem_DebugFree\00", align 1
@__func__._PyMem_DebugRealloc = private unnamed_addr constant [20 x i8] c"_PyMem_DebugRealloc\00", align 1
@.str.43 = private unnamed_addr constant [24 x i8] c"%d %ss * %zd bytes each\00", align 1
@.str.44 = private unnamed_addr constant [6 x i8] c"%48s \00", align 1
@.str.45 = private unnamed_addr constant [23 x i8] c"out of memory in 'new'\00", align 1
@mi_arenas_try_purge.purge_guard = internal global i64 0, align 8
@mi_arena_static_top = internal global i64 0, align 8
@mi_arena_static = internal global [8192 x i8] zeroinitializer, align 16
@.str.46 = private unnamed_addr constant [6 x i8] c"%s%s\0A\00", align 1
@tld_empty = internal constant %struct.mi_tld_s { i64 0, i8 0, ptr null, ptr null, %struct.mi_segments_tld_s { [36 x %struct.mi_span_queue_s] [%struct.mi_span_queue_s { ptr null, ptr null, i64 1 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 1 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 2 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 3 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 4 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 5 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 6 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 7 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 10 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 12 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 14 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 16 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 20 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 24 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 28 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 32 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 40 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 48 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 56 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 64 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 80 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 96 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 112 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 128 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 160 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 192 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 224 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 256 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 320 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 384 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 448 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 512 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 640 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 768 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 896 }, %struct.mi_span_queue_s { ptr null, ptr null, i64 1024 }], i64 0, i64 0, i64 0, i64 0, ptr getelementptr (i8, ptr @tld_empty, i64 960), ptr getelementptr (i8, ptr @tld_empty, i64 944) }, %struct.mi_os_tld_s { i64 0, ptr getelementptr (i8, ptr @tld_empty, i64 960) }, %struct.mi_stats_s zeroinitializer }, align 64
@.str.47 = private unnamed_addr constant [59 x i8] c"unable to allocate thread local heap metadata (%zu bytes)\0A\00", align 1
@mi_process_setup_auto_thread_done.tls_initialized = internal global i8 0, align 1
@.str.48 = private unnamed_addr constant [23 x i8] c"malloc is redirected.\0A\00", align 1
@mi_process_done.process_done = internal global i8 0, align 1
@.str.49 = private unnamed_addr constant [21 x i8] c"process done: 0x%zx\0A\00", align 1
@.str.50 = private unnamed_addr constant [12 x i8] c"show_errors\00", align 1
@.str.51 = private unnamed_addr constant [11 x i8] c"show_stats\00", align 1
@.str.52 = private unnamed_addr constant [8 x i8] c"verbose\00", align 1
@.str.53 = private unnamed_addr constant [13 x i8] c"eager_commit\00", align 1
@.str.54 = private unnamed_addr constant [19 x i8] c"arena_eager_commit\00", align 1
@.str.55 = private unnamed_addr constant [20 x i8] c"eager_region_commit\00", align 1
@.str.56 = private unnamed_addr constant [16 x i8] c"purge_decommits\00", align 1
@.str.57 = private unnamed_addr constant [16 x i8] c"reset_decommits\00", align 1
@.str.58 = private unnamed_addr constant [21 x i8] c"allow_large_os_pages\00", align 1
@.str.59 = private unnamed_addr constant [15 x i8] c"large_os_pages\00", align 1
@.str.60 = private unnamed_addr constant [22 x i8] c"reserve_huge_os_pages\00", align 1
@.str.61 = private unnamed_addr constant [25 x i8] c"reserve_huge_os_pages_at\00", align 1
@.str.62 = private unnamed_addr constant [18 x i8] c"reserve_os_memory\00", align 1
@.str.63 = private unnamed_addr constant [25 x i8] c"deprecated_segment_cache\00", align 1
@.str.64 = private unnamed_addr constant [22 x i8] c"deprecated_page_reset\00", align 1
@.str.65 = private unnamed_addr constant [21 x i8] c"abandoned_page_purge\00", align 1
@.str.66 = private unnamed_addr constant [21 x i8] c"abandoned_page_reset\00", align 1
@.str.67 = private unnamed_addr constant [25 x i8] c"deprecated_segment_reset\00", align 1
@.str.68 = private unnamed_addr constant [19 x i8] c"eager_commit_delay\00", align 1
@.str.69 = private unnamed_addr constant [12 x i8] c"purge_delay\00", align 1
@.str.70 = private unnamed_addr constant [12 x i8] c"reset_delay\00", align 1
@.str.71 = private unnamed_addr constant [15 x i8] c"use_numa_nodes\00", align 1
@.str.72 = private unnamed_addr constant [15 x i8] c"limit_os_alloc\00", align 1
@.str.73 = private unnamed_addr constant [7 x i8] c"os_tag\00", align 1
@.str.74 = private unnamed_addr constant [11 x i8] c"max_errors\00", align 1
@.str.75 = private unnamed_addr constant [13 x i8] c"max_warnings\00", align 1
@.str.76 = private unnamed_addr constant [20 x i8] c"max_segment_reclaim\00", align 1
@.str.77 = private unnamed_addr constant [16 x i8] c"destroy_on_exit\00", align 1
@.str.78 = private unnamed_addr constant [14 x i8] c"arena_reserve\00", align 1
@.str.79 = private unnamed_addr constant [17 x i8] c"arena_purge_mult\00", align 1
@.str.80 = private unnamed_addr constant [19 x i8] c"purge_extend_delay\00", align 1
@.str.81 = private unnamed_addr constant [22 x i8] c"decommit_extend_delay\00", align 1
@out_len = internal global i64 0, align 8
@out_buf = internal global [32769 x i8] zeroinitializer, align 16
@recurse = internal thread_local global i8 0, align 1
@.str.82 = private unnamed_addr constant [18 x i8] c"%sthread 0x%llx: \00", align 1
@error_count = internal global i64 0, align 8
@.str.83 = private unnamed_addr constant [18 x i8] c"mimalloc: error: \00", align 1
@.str.84 = private unnamed_addr constant [10 x i8] c"mimalloc_\00", align 1
@.str.85 = private unnamed_addr constant [78 x i8] c"environment option \22mimalloc_%s\22 is deprecated -- use \22mimalloc_%s\22 instead.\0A\00", align 1
@.str.86 = private unnamed_addr constant [14 x i8] c"1;TRUE;YES;ON\00", align 1
@.str.87 = private unnamed_addr constant [15 x i8] c"0;FALSE;NO;OFF\00", align 1
@.str.88 = private unnamed_addr constant [54 x i8] c"environment option mimalloc_%s has an invalid value.\0A\00", align 1
@.str.89 = private unnamed_addr constant [77 x i8] c"unable to free OS memory (error: %d (0x%x), size: 0x%zx bytes, address: %p)\0A\00", align 1
@.str.90 = private unnamed_addr constant [111 x i8] c"unable to allocate OS memory (error: %d (0x%x), size: 0x%zx bytes, align: 0x%zx, commit: %d, allow large: %d)\0A\00", align 1
@.str.91 = private unnamed_addr constant [78 x i8] c"cannot decommit OS memory (error: %d (0x%x), address: %p, size: 0x%zx bytes)\0A\00", align 1
@.str.92 = private unnamed_addr constant [72 x i8] c"cannot %s OS memory (error: %d (0x%x), address: %p, size: 0x%zx bytes)\0A\00", align 1
@.str.93 = private unnamed_addr constant [8 x i8] c"protect\00", align 1
@.str.94 = private unnamed_addr constant [10 x i8] c"unprotect\00", align 1
@mi_huge_start = internal global i64 0, align 64
@.str.95 = private unnamed_addr constant [28 x i8] c"corrupted thread-free list\0A\00", align 1
@.str.96 = private unnamed_addr constant [45 x i8] c"allocation request is too large (%zu bytes)\0A\00", align 1
@.str.97 = private unnamed_addr constant [33 x i8] c"unable to use secure randomness\0A\00", align 1
@.str.98 = private unnamed_addr constant [17 x i8] c"expand 32-byte k\00", align 1
@.str.99 = private unnamed_addr constant [88 x i8] c"commit mask overflow: idx=%zu count=%zu start=%zx end=%zx p=0x%p size=%zu fullsize=%zu\0A\00", align 1
@abandoned = internal global i64 0, align 64
@abandoned_count = internal global i64 0, align 64
@abandoned_visited = internal global ptr null, align 64
@abandoned_visited_count = internal global i64 0, align 64
@.str.100 = private unnamed_addr constant [9 x i8] c"reserved\00", align 1
@.str.101 = private unnamed_addr constant [10 x i8] c"committed\00", align 1
@.str.102 = private unnamed_addr constant [6 x i8] c"reset\00", align 1
@.str.103 = private unnamed_addr constant [7 x i8] c"purged\00", align 1
@.str.104 = private unnamed_addr constant [8 x i8] c"touched\00", align 1
@.str.105 = private unnamed_addr constant [9 x i8] c"segments\00", align 1
@.str.106 = private unnamed_addr constant [11 x i8] c"-abandoned\00", align 1
@.str.107 = private unnamed_addr constant [8 x i8] c"-cached\00", align 1
@.str.108 = private unnamed_addr constant [6 x i8] c"pages\00", align 1
@.str.109 = private unnamed_addr constant [10 x i8] c"-extended\00", align 1
@.str.110 = private unnamed_addr constant [10 x i8] c"-noretire\00", align 1
@.str.111 = private unnamed_addr constant [6 x i8] c"mmaps\00", align 1
@.str.112 = private unnamed_addr constant [8 x i8] c"commits\00", align 1
@.str.113 = private unnamed_addr constant [7 x i8] c"resets\00", align 1
@.str.114 = private unnamed_addr constant [7 x i8] c"purges\00", align 1
@.str.115 = private unnamed_addr constant [8 x i8] c"threads\00", align 1
@.str.116 = private unnamed_addr constant [9 x i8] c"searches\00", align 1
@.str.117 = private unnamed_addr constant [12 x i8] c"%10s: %5zu\0A\00", align 1
@.str.118 = private unnamed_addr constant [11 x i8] c"numa nodes\00", align 1
@.str.119 = private unnamed_addr constant [20 x i8] c"%10s: %5ld.%03ld s\0A\00", align 1
@.str.120 = private unnamed_addr constant [8 x i8] c"elapsed\00", align 1
@.str.121 = private unnamed_addr constant [65 x i8] c"%10s: user: %ld.%03ld s, system: %ld.%03ld s, faults: %lu, rss: \00", align 1
@.str.122 = private unnamed_addr constant [8 x i8] c"process\00", align 1
@.str.123 = private unnamed_addr constant [3 x i8] c"%s\00", align 1
@.str.124 = private unnamed_addr constant [11 x i8] c", commit: \00", align 1
@.str.125 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.126 = private unnamed_addr constant [37 x i8] c"%10s: %11s %11s %11s %11s %11s %11s\0A\00", align 1
@.str.127 = private unnamed_addr constant [11 x i8] c"heap stats\00", align 1
@.str.128 = private unnamed_addr constant [8 x i8] c"peak   \00", align 1
@.str.129 = private unnamed_addr constant [9 x i8] c"total   \00", align 1
@.str.130 = private unnamed_addr constant [9 x i8] c"freed   \00", align 1
@.str.131 = private unnamed_addr constant [11 x i8] c"current   \00", align 1
@.str.132 = private unnamed_addr constant [8 x i8] c"unit   \00", align 1
@.str.133 = private unnamed_addr constant [9 x i8] c"count   \00", align 1
@.str.134 = private unnamed_addr constant [6 x i8] c"%10s:\00", align 1
@.str.135 = private unnamed_addr constant [14 x i8] c"not all freed\00", align 1
@.str.136 = private unnamed_addr constant [6 x i8] c"  ok\0A\00", align 1
@.str.137 = private unnamed_addr constant [5 x i8] c"%24s\00", align 1
@.str.138 = private unnamed_addr constant [18 x i8] c"  not all freed!\0A\00", align 1
@.str.139 = private unnamed_addr constant [5 x i8] c"%11s\00", align 1
@.str.140 = private unnamed_addr constant [2 x i8] c" \00", align 1
@.str.141 = private unnamed_addr constant [5 x i8] c"%12s\00", align 1
@.str.142 = private unnamed_addr constant [20 x i8] c"%10s: %5ld.%ld avg\0A\00", align 1
@.str.143 = private unnamed_addr constant [2 x i8] c"B\00", align 1
@.str.144 = private unnamed_addr constant [10 x i8] c"%d   %-3s\00", align 1
@.str.145 = private unnamed_addr constant [2 x i8] c"K\00", align 1
@.str.146 = private unnamed_addr constant [2 x i8] c"M\00", align 1
@.str.147 = private unnamed_addr constant [2 x i8] c"G\00", align 1
@.str.148 = private unnamed_addr constant [7 x i8] c"%s%s%s\00", align 1
@.str.149 = private unnamed_addr constant [2 x i8] c"i\00", align 1
@.str.150 = private unnamed_addr constant [13 x i8] c"%ld.%ld %-3s\00", align 1
@.str.151 = private unnamed_addr constant [31 x i8] c"/proc/sys/vm/overcommit_memory\00", align 1
@unix_mmap.large_page_try_ok = internal global i64 0, align 8
@unix_mmap.mi_huge_pages_available = internal global i8 1, align 1
@.str.152 = private unnamed_addr constant [84 x i8] c"unable to allocate huge (1GiB) page, trying large (2MiB) pages instead (errno: %i)\0A\00", align 1
@.str.153 = private unnamed_addr constant [127 x i8] c"unable to directly request hinted aligned OS memory (error: %d (0x%x), size: 0x%zx bytes, alignment: 0x%zx, hint address: %p)\0A\00", align 1
@environ = external global ptr, align 8
@__const.set_up_allocators_unlocked.malloc_alloc = private unnamed_addr constant %struct.PyMemAllocatorEx { ptr null, ptr @_PyMem_RawMalloc, ptr @_PyMem_RawCalloc, ptr @_PyMem_RawRealloc, ptr @_PyMem_RawFree }, align 8
@__const.set_up_allocators_unlocked.pymalloc = private unnamed_addr constant %struct.PyMemAllocatorEx { ptr null, ptr @_PyObject_Malloc, ptr @_PyObject_Calloc, ptr @_PyObject_Realloc, ptr @_PyObject_Free }, align 8
@__const.set_up_allocators_unlocked.malloc_alloc.154 = private unnamed_addr constant %struct.PyMemAllocatorEx { ptr null, ptr @_PyMem_RawMalloc, ptr @_PyMem_RawCalloc, ptr @_PyMem_RawRealloc, ptr @_PyMem_RawFree }, align 8
@__const.set_up_allocators_unlocked.pymalloc.155 = private unnamed_addr constant %struct.PyMemAllocatorEx { ptr null, ptr @_PyMem_MiMalloc, ptr @_PyMem_MiCalloc, ptr @_PyMem_MiRealloc, ptr @_PyMem_MiFree }, align 8
@__const.set_up_allocators_unlocked.objmalloc = private unnamed_addr constant %struct.PyMemAllocatorEx { ptr null, ptr @_PyObject_MiMalloc, ptr @_PyObject_MiCalloc, ptr @_PyObject_MiRealloc, ptr @_PyObject_MiFree }, align 8
@__const.set_up_allocators_unlocked.malloc_alloc.156 = private unnamed_addr constant %struct.PyMemAllocatorEx { ptr null, ptr @_PyMem_RawMalloc, ptr @_PyMem_RawCalloc, ptr @_PyMem_RawRealloc, ptr @_PyMem_RawFree }, align 8
@__const.get_current_allocator_name_unlocked.malloc_alloc = private unnamed_addr constant %struct.PyMemAllocatorEx { ptr null, ptr @_PyMem_RawMalloc, ptr @_PyMem_RawCalloc, ptr @_PyMem_RawRealloc, ptr @_PyMem_RawFree }, align 8
@__const.get_current_allocator_name_unlocked.pymalloc = private unnamed_addr constant %struct.PyMemAllocatorEx { ptr null, ptr @_PyObject_Malloc, ptr @_PyObject_Calloc, ptr @_PyObject_Realloc, ptr @_PyObject_Free }, align 8
@__const.get_current_allocator_name_unlocked.mimalloc = private unnamed_addr constant %struct.PyMemAllocatorEx { ptr null, ptr @_PyMem_MiMalloc, ptr @_PyMem_MiCalloc, ptr @_PyMem_MiRealloc, ptr @_PyMem_MiFree }, align 8
@__const.get_current_allocator_name_unlocked.mimalloc_obj = private unnamed_addr constant %struct.PyMemAllocatorEx { ptr null, ptr @_PyObject_MiMalloc, ptr @_PyObject_MiCalloc, ptr @_PyObject_MiRealloc, ptr @_PyObject_MiFree }, align 8
@__const.get_current_allocator_name_unlocked.dbg_raw = private unnamed_addr constant %struct.PyMemAllocatorEx { ptr getelementptr (i8, ptr @_PyRuntime, i64 528), ptr @_PyMem_DebugRawMalloc, ptr @_PyMem_DebugRawCalloc, ptr @_PyMem_DebugRawRealloc, ptr @_PyMem_DebugRawFree }, align 8
@__const.get_current_allocator_name_unlocked.dbg_mem = private unnamed_addr constant %struct.PyMemAllocatorEx { ptr getelementptr (i8, ptr @_PyRuntime, i64 576), ptr @_PyMem_DebugMalloc, ptr @_PyMem_DebugCalloc, ptr @_PyMem_DebugRealloc, ptr @_PyMem_DebugFree }, align 8
@__const.get_current_allocator_name_unlocked.dbg_obj = private unnamed_addr constant %struct.PyMemAllocatorEx { ptr getelementptr (i8, ptr @_PyRuntime, i64 624), ptr @_PyMem_DebugMalloc, ptr @_PyMem_DebugCalloc, ptr @_PyMem_DebugRealloc, ptr @_PyMem_DebugFree }, align 8
@_Py_tss_tstate = external thread_local global ptr, align 8
@.str.157 = private unnamed_addr constant [18 x i8] c"PYTHONMALLOCSTATS\00", align 1
@.str.158 = private unnamed_addr constant [55 x i8] c"Python memory allocator called without holding the GIL\00", align 1
@.str.159 = private unnamed_addr constant [58 x i8] c"bad ID: Allocated using API '%c', verified using API '%c'\00", align 1
@.str.160 = private unnamed_addr constant [21 x i8] c"bad leading pad byte\00", align 1
@.str.161 = private unnamed_addr constant [22 x i8] c"bad trailing pad byte\00", align 1
@.str.162 = private unnamed_addr constant [36 x i8] c"Debug memory block at address p=%p:\00", align 1
@.str.163 = private unnamed_addr constant [11 x i8] c" API '%c'\0A\00", align 1
@.str.164 = private unnamed_addr constant [36 x i8] c"    %zu bytes originally requested\0A\00", align 1
@.str.165 = private unnamed_addr constant [34 x i8] c"    The %d pad bytes at p-%d are \00", align 1
@.str.166 = private unnamed_addr constant [29 x i8] c"FORBIDDENBYTE, as expected.\0A\00", align 1
@.str.167 = private unnamed_addr constant [33 x i8] c"not all FORBIDDENBYTE (0x%02x):\0A\00", align 1
@.str.168 = private unnamed_addr constant [24 x i8] c"        at p-%d: 0x%02x\00", align 1
@.str.169 = private unnamed_addr constant [10 x i8] c" *** OUCH\00", align 1
@.str.170 = private unnamed_addr constant [147 x i8] c"    Because memory is corrupted at the start, the count of bytes requested\0A       may be bogus, and checking the trailing pad bytes may segfault.\0A\00", align 1
@.str.171 = private unnamed_addr constant [37 x i8] c"    The %d pad bytes at tail=%p are \00", align 1
@.str.172 = private unnamed_addr constant [27 x i8] c"        at tail+%d: 0x%02x\00", align 1
@.str.173 = private unnamed_addr constant [15 x i8] c"    Data at p:\00", align 1
@.str.174 = private unnamed_addr constant [6 x i8] c" %02x\00", align 1
@.str.175 = private unnamed_addr constant [5 x i8] c" ...\00", align 1
@.str.176 = private unnamed_addr constant [50 x i8] c"Small block threshold = %zd, in %u size classes.\0A\00", align 1
@.str.177 = private unnamed_addr constant [30 x i8] c"Medium block threshold = %zd\0A\00", align 1
@.str.178 = private unnamed_addr constant [29 x i8] c"Large object max size = %zd\0A\00", align 1
@.str.179 = private unnamed_addr constant [27 x i8] c"    Allocated Blocks: %zd\0A\00", align 1
@.str.180 = private unnamed_addr constant [26 x i8] c"    Allocated Bytes: %zd\0A\00", align 1
@.str.181 = private unnamed_addr constant [38 x i8] c"    Allocated Bytes w/ Overhead: %zd\0A\00", align 1
@.str.182 = private unnamed_addr constant [25 x i8] c"    Bytes Reserved: %zd\0A\00", align 1
@.str.183 = private unnamed_addr constant [26 x i8] c"    Bytes Committed: %zd\0A\00", align 1
@.str.184 = private unnamed_addr constant [49 x i8] c"Small block threshold = %d, in %u size classes.\0A\00", align 1
@.str.185 = private unnamed_addr constant [111 x i8] c"class   size   num pools   blocks in use  avail blocks\0A-----   ----   ---------   -------------  ------------\0A\00", align 1
@.str.186 = private unnamed_addr constant [27 x i8] c"%5u %6u %11zu %15zu %13zu\0A\00", align 1
@.str.187 = private unnamed_addr constant [25 x i8] c"# arenas allocated total\00", align 1
@.str.188 = private unnamed_addr constant [19 x i8] c"# arenas reclaimed\00", align 1
@.str.189 = private unnamed_addr constant [24 x i8] c"# arenas highwater mark\00", align 1
@.str.190 = private unnamed_addr constant [27 x i8] c"# arenas allocated current\00", align 1
@.str.191 = private unnamed_addr constant [28 x i8] c"%zu arenas * %d bytes/arena\00", align 1
@.str.192 = private unnamed_addr constant [28 x i8] c"# bytes in allocated blocks\00", align 1
@.str.193 = private unnamed_addr constant [28 x i8] c"# bytes in available blocks\00", align 1
@.str.194 = private unnamed_addr constant [27 x i8] c"%u unused pools * %d bytes\00", align 1
@.str.195 = private unnamed_addr constant [29 x i8] c"# bytes lost to pool headers\00", align 1
@.str.196 = private unnamed_addr constant [29 x i8] c"# bytes lost to quantization\00", align 1
@.str.197 = private unnamed_addr constant [32 x i8] c"# bytes lost to arena alignment\00", align 1
@.str.198 = private unnamed_addr constant [6 x i8] c"Total\00", align 1
@.str.199 = private unnamed_addr constant [19 x i8] c"\0Aarena map counts\0A\00", align 1
@.str.200 = private unnamed_addr constant [22 x i8] c"# arena map mid nodes\00", align 1
@.str.201 = private unnamed_addr constant [22 x i8] c"# arena map bot nodes\00", align 1
@.str.202 = private unnamed_addr constant [31 x i8] c"# bytes lost to arena map root\00", align 1
@.str.203 = private unnamed_addr constant [30 x i8] c"# bytes lost to arena map mid\00", align 1
@.str.204 = private unnamed_addr constant [30 x i8] c"# bytes lost to arena map bot\00", align 1
@llvm.global_ctors = appending global [1 x { i32, ptr, ptr }] [{ i32, ptr, ptr } { i32 65535, ptr @_mi_process_init, ptr null }]

; Function Attrs: nounwind uwtable
define hidden ptr @_mi_page_malloc(ptr noundef %heap, ptr noundef %page, i64 noundef %size, i1 noundef zeroext %zero) #0 {
entry:
  %retval = alloca ptr, align 8
  %heap.addr = alloca ptr, align 8
  %page.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %zero.addr = alloca i8, align 1
  %block = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store ptr %page, ptr %page.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %frombool = zext i1 %zero to i8
  store i8 %frombool, ptr %zero.addr, align 1
  %0 = load ptr, ptr %page.addr, align 8
  %free = getelementptr inbounds %struct.mi_page_s, ptr %0, i32 0, i32 7
  %1 = load ptr, ptr %free, align 8
  store ptr %1, ptr %block, align 8
  %2 = load ptr, ptr %block, align 8
  %cmp = icmp eq ptr %2, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %heap.addr, align 8
  %4 = load i64, ptr %size.addr, align 8
  %5 = load i8, ptr %zero.addr, align 1
  %tobool2 = trunc i8 %5 to i1
  %call = call noalias ptr @_mi_malloc_generic(ptr noundef %3, i64 noundef %4, i1 noundef zeroext %tobool2, i64 noundef 0)
  store ptr %call, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %6 = load ptr, ptr %page.addr, align 8
  %used = getelementptr inbounds %struct.mi_page_s, ptr %6, i32 0, i32 8
  %7 = load i32, ptr %used, align 8
  %inc = add i32 %7, 1
  store i32 %inc, ptr %used, align 8
  %8 = load ptr, ptr %page.addr, align 8
  %9 = load ptr, ptr %block, align 8
  %call3 = call ptr @mi_block_next(ptr noundef %8, ptr noundef %9)
  %10 = load ptr, ptr %page.addr, align 8
  %free4 = getelementptr inbounds %struct.mi_page_s, ptr %10, i32 0, i32 7
  store ptr %call3, ptr %free4, align 8
  %11 = load i8, ptr %zero.addr, align 1
  %tobool5 = trunc i8 %11 to i1
  %lnot6 = xor i1 %tobool5, true
  %lnot8 = xor i1 %lnot6, true
  %lnot.ext9 = zext i1 %lnot8 to i32
  %conv10 = sext i32 %lnot.ext9 to i64
  %tobool11 = icmp ne i64 %conv10, 0
  br i1 %tobool11, label %if.then12, label %if.end17

if.then12:                                        ; preds = %if.end
  %12 = load ptr, ptr %page.addr, align 8
  %free_is_zero = getelementptr inbounds %struct.mi_page_s, ptr %12, i32 0, i32 6
  %bf.load = load i8, ptr %free_is_zero, align 1
  %bf.clear = and i8 %bf.load, 1
  %tobool13 = icmp ne i8 %bf.clear, 0
  br i1 %tobool13, label %if.then14, label %if.else

if.then14:                                        ; preds = %if.then12
  %13 = load ptr, ptr %block, align 8
  %next = getelementptr inbounds %struct.mi_block_s, ptr %13, i32 0, i32 0
  store i64 0, ptr %next, align 8
  br label %if.end16

if.else:                                          ; preds = %if.then12
  %14 = load ptr, ptr %block, align 8
  %15 = load ptr, ptr %page.addr, align 8
  %xblock_size = getelementptr inbounds %struct.mi_page_s, ptr %15, i32 0, i32 9
  %16 = load i32, ptr %xblock_size, align 4
  %sub = sub i32 %16, 0
  %conv15 = zext i32 %sub to i64
  call void @_mi_memzero_aligned(ptr noundef %14, i64 noundef %conv15)
  br label %if.end16

if.end16:                                         ; preds = %if.else, %if.then14
  br label %if.end17

if.end17:                                         ; preds = %if.end16, %if.end
  %17 = load ptr, ptr %block, align 8
  store ptr %17, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end17, %if.then
  %18 = load ptr, ptr %retval, align 8
  ret ptr %18
}

; Function Attrs: nounwind uwtable
define hidden noalias ptr @_mi_malloc_generic(ptr noundef %heap, i64 noundef %size, i1 noundef zeroext %zero, i64 noundef %huge_alignment) #0 {
entry:
  %retval = alloca ptr, align 8
  %heap.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %zero.addr = alloca i8, align 1
  %huge_alignment.addr = alloca i64, align 8
  %page = alloca ptr, align 8
  %req_size = alloca i64, align 8
  %p = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %frombool = zext i1 %zero to i8
  store i8 %frombool, ptr %zero.addr, align 1
  store i64 %huge_alignment, ptr %huge_alignment.addr, align 8
  %0 = load ptr, ptr %heap.addr, align 8
  %call = call zeroext i1 @mi_heap_is_initialized(ptr noundef %0)
  %lnot = xor i1 %call, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %if.then, label %if.end14

if.then:                                          ; preds = %entry
  %call3 = call ptr @mi_heap_get_default()
  store ptr %call3, ptr %heap.addr, align 8
  %1 = load ptr, ptr %heap.addr, align 8
  %call4 = call zeroext i1 @mi_heap_is_initialized(ptr noundef %1)
  %lnot5 = xor i1 %call4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot9 = xor i1 %lnot7, true
  %lnot.ext10 = zext i1 %lnot9 to i32
  %conv11 = sext i32 %lnot.ext10 to i64
  %tobool12 = icmp ne i64 %conv11, 0
  br i1 %tobool12, label %if.then13, label %if.end

if.then13:                                        ; preds = %if.then
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %if.then
  br label %if.end14

if.end14:                                         ; preds = %if.end, %entry
  %2 = load ptr, ptr %heap.addr, align 8
  call void @_mi_deferred_free(ptr noundef %2, i1 noundef zeroext false)
  %3 = load ptr, ptr %heap.addr, align 8
  %call15 = call zeroext i1 @_mi_heap_delayed_free_partial(ptr noundef %3)
  %4 = load ptr, ptr %heap.addr, align 8
  %5 = load i64, ptr %size.addr, align 8
  %6 = load i64, ptr %huge_alignment.addr, align 8
  %call16 = call ptr @mi_find_page(ptr noundef %4, i64 noundef %5, i64 noundef %6)
  store ptr %call16, ptr %page, align 8
  %7 = load ptr, ptr %page, align 8
  %cmp = icmp eq ptr %7, null
  %lnot18 = xor i1 %cmp, true
  %lnot20 = xor i1 %lnot18, true
  %lnot.ext21 = zext i1 %lnot20 to i32
  %conv22 = sext i32 %lnot.ext21 to i64
  %tobool23 = icmp ne i64 %conv22, 0
  br i1 %tobool23, label %if.then24, label %if.end26

if.then24:                                        ; preds = %if.end14
  %8 = load ptr, ptr %heap.addr, align 8
  call void @mi_heap_collect(ptr noundef %8, i1 noundef zeroext true)
  %9 = load ptr, ptr %heap.addr, align 8
  %10 = load i64, ptr %size.addr, align 8
  %11 = load i64, ptr %huge_alignment.addr, align 8
  %call25 = call ptr @mi_find_page(ptr noundef %9, i64 noundef %10, i64 noundef %11)
  store ptr %call25, ptr %page, align 8
  br label %if.end26

if.end26:                                         ; preds = %if.then24, %if.end14
  %12 = load ptr, ptr %page, align 8
  %cmp27 = icmp eq ptr %12, null
  %lnot29 = xor i1 %cmp27, true
  %lnot31 = xor i1 %lnot29, true
  %lnot.ext32 = zext i1 %lnot31 to i32
  %conv33 = sext i32 %lnot.ext32 to i64
  %tobool34 = icmp ne i64 %conv33, 0
  br i1 %tobool34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %if.end26
  %13 = load i64, ptr %size.addr, align 8
  %sub = sub i64 %13, 0
  store i64 %sub, ptr %req_size, align 8
  %14 = load i64, ptr %req_size, align 8
  call void (i32, ptr, ...) @_mi_error_message(i32 noundef 12, ptr noundef @.str.30, i64 noundef %14)
  store ptr null, ptr %retval, align 8
  br label %return

if.end36:                                         ; preds = %if.end26
  %15 = load i8, ptr %zero.addr, align 1
  %tobool37 = trunc i8 %15 to i1
  br i1 %tobool37, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end36
  %16 = load ptr, ptr %page, align 8
  %xblock_size = getelementptr inbounds %struct.mi_page_s, ptr %16, i32 0, i32 9
  %17 = load i32, ptr %xblock_size, align 4
  %cmp39 = icmp eq i32 %17, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end36
  %18 = phi i1 [ false, %if.end36 ], [ %cmp39, %land.rhs ]
  %lnot41 = xor i1 %18, true
  %lnot43 = xor i1 %lnot41, true
  %lnot.ext44 = zext i1 %lnot43 to i32
  %conv45 = sext i32 %lnot.ext44 to i64
  %tobool46 = icmp ne i64 %conv45, 0
  br i1 %tobool46, label %if.then47, label %if.else

if.then47:                                        ; preds = %land.end
  %19 = load ptr, ptr %heap.addr, align 8
  %20 = load ptr, ptr %page, align 8
  %21 = load i64, ptr %size.addr, align 8
  %call48 = call ptr @_mi_page_malloc(ptr noundef %19, ptr noundef %20, i64 noundef %21, i1 noundef zeroext false)
  store ptr %call48, ptr %p, align 8
  %22 = load ptr, ptr %p, align 8
  %23 = load ptr, ptr %page, align 8
  %call49 = call i64 @mi_page_usable_block_size(ptr noundef %23)
  call void @_mi_memzero_aligned(ptr noundef %22, i64 noundef %call49)
  %24 = load ptr, ptr %p, align 8
  store ptr %24, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %land.end
  %25 = load ptr, ptr %heap.addr, align 8
  %26 = load ptr, ptr %page, align 8
  %27 = load i64, ptr %size.addr, align 8
  %28 = load i8, ptr %zero.addr, align 1
  %tobool50 = trunc i8 %28 to i1
  %call51 = call ptr @_mi_page_malloc(ptr noundef %25, ptr noundef %26, i64 noundef %27, i1 noundef zeroext %tobool50)
  store ptr %call51, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then47, %if.then35, %if.then13
  %29 = load ptr, ptr %retval, align 8
  ret ptr %29
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_block_next(ptr noundef %page, ptr noundef %block) #0 {
entry:
  %page.addr = alloca ptr, align 8
  %block.addr = alloca ptr, align 8
  store ptr %page, ptr %page.addr, align 8
  store ptr %block, ptr %block.addr, align 8
  %0 = load ptr, ptr %page.addr, align 8
  %1 = load ptr, ptr %block.addr, align 8
  %call = call ptr @mi_block_nextx(ptr noundef %0, ptr noundef %1, ptr noundef null)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal void @_mi_memzero_aligned(ptr noundef %dst, i64 noundef %n) #0 {
entry:
  %dst.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %adst = alloca ptr, align 8
  store ptr %dst, ptr %dst.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %0 = load ptr, ptr %dst.addr, align 8
  call void @llvm.assume(i1 true) [ "align"(ptr %0, i64 8) ]
  store ptr %0, ptr %adst, align 8
  %1 = load ptr, ptr %adst, align 8
  %2 = load i64, ptr %n.addr, align 8
  call void @_mi_memzero(ptr noundef %1, i64 noundef %2)
  ret void
}

; Function Attrs: nounwind uwtable
define hidden noalias ptr @mi_heap_malloc_small(ptr noundef %heap, i64 noundef %size) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load ptr, ptr %heap.addr, align 8
  %1 = load i64, ptr %size.addr, align 8
  %call = call ptr @mi_heap_malloc_small_zero(ptr noundef %0, i64 noundef %1, i1 noundef zeroext false)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_heap_malloc_small_zero(ptr noundef %heap, i64 noundef %size, i1 noundef zeroext %zero) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %zero.addr = alloca i8, align 1
  %page = alloca ptr, align 8
  %p = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %frombool = zext i1 %zero to i8
  store i8 %frombool, ptr %zero.addr, align 1
  %0 = load ptr, ptr %heap.addr, align 8
  %1 = load i64, ptr %size.addr, align 8
  %add = add i64 %1, 0
  %call = call ptr @_mi_heap_get_free_small_page(ptr noundef %0, i64 noundef %add)
  store ptr %call, ptr %page, align 8
  %2 = load ptr, ptr %heap.addr, align 8
  %3 = load ptr, ptr %page, align 8
  %4 = load i64, ptr %size.addr, align 8
  %add1 = add i64 %4, 0
  %5 = load i8, ptr %zero.addr, align 1
  %tobool = trunc i8 %5 to i1
  %call2 = call ptr @_mi_page_malloc(ptr noundef %2, ptr noundef %3, i64 noundef %add1, i1 noundef zeroext %tobool)
  store ptr %call2, ptr %p, align 8
  %6 = load ptr, ptr %p, align 8
  %cmp = icmp ne ptr %6, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %7 = load ptr, ptr %p, align 8
  ret ptr %7
}

; Function Attrs: nounwind uwtable
define hidden noalias ptr @mi_malloc_small(i64 noundef %size) #0 {
entry:
  %size.addr = alloca i64, align 8
  store i64 %size, ptr %size.addr, align 8
  %call = call ptr @mi_prim_get_default_heap()
  %0 = load i64, ptr %size.addr, align 8
  %call1 = call noalias ptr @mi_heap_malloc_small(ptr noundef %call, i64 noundef %0)
  ret ptr %call1
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_prim_get_default_heap() #0 {
entry:
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @_mi_heap_default)
  %1 = load ptr, ptr %0, align 8
  ret ptr %1
}

; Function Attrs: nounwind uwtable
define hidden ptr @_mi_heap_malloc_zero_ex(ptr noundef %heap, i64 noundef %size, i1 noundef zeroext %zero, i64 noundef %huge_alignment) #0 {
entry:
  %retval = alloca ptr, align 8
  %heap.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %zero.addr = alloca i8, align 1
  %huge_alignment.addr = alloca i64, align 8
  %p = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %frombool = zext i1 %zero to i8
  store i8 %frombool, ptr %zero.addr, align 1
  store i64 %huge_alignment, ptr %huge_alignment.addr, align 8
  %0 = load i64, ptr %size.addr, align 8
  %cmp = icmp ule i64 %0, 1024
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %heap.addr, align 8
  %2 = load i64, ptr %size.addr, align 8
  %3 = load i8, ptr %zero.addr, align 1
  %tobool2 = trunc i8 %3 to i1
  %call = call ptr @mi_heap_malloc_small_zero(ptr noundef %1, i64 noundef %2, i1 noundef zeroext %tobool2)
  store ptr %call, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %4 = load ptr, ptr %heap.addr, align 8
  %5 = load i64, ptr %size.addr, align 8
  %add = add i64 %5, 0
  %6 = load i8, ptr %zero.addr, align 1
  %tobool3 = trunc i8 %6 to i1
  %7 = load i64, ptr %huge_alignment.addr, align 8
  %call4 = call noalias ptr @_mi_malloc_generic(ptr noundef %4, i64 noundef %add, i1 noundef zeroext %tobool3, i64 noundef %7)
  store ptr %call4, ptr %p, align 8
  %8 = load ptr, ptr %p, align 8
  %cmp5 = icmp ne ptr %8, null
  br i1 %cmp5, label %if.then7, label %if.end

if.then7:                                         ; preds = %if.else
  br label %if.end

if.end:                                           ; preds = %if.then7, %if.else
  %9 = load ptr, ptr %p, align 8
  store ptr %9, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %10 = load ptr, ptr %retval, align 8
  ret ptr %10
}

; Function Attrs: nounwind uwtable
define hidden ptr @_mi_heap_malloc_zero(ptr noundef %heap, i64 noundef %size, i1 noundef zeroext %zero) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %zero.addr = alloca i8, align 1
  store ptr %heap, ptr %heap.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %frombool = zext i1 %zero to i8
  store i8 %frombool, ptr %zero.addr, align 1
  %0 = load ptr, ptr %heap.addr, align 8
  %1 = load i64, ptr %size.addr, align 8
  %2 = load i8, ptr %zero.addr, align 1
  %tobool = trunc i8 %2 to i1
  %call = call ptr @_mi_heap_malloc_zero_ex(ptr noundef %0, i64 noundef %1, i1 noundef zeroext %tobool, i64 noundef 0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define hidden noalias ptr @mi_heap_malloc(ptr noundef %heap, i64 noundef %size) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load ptr, ptr %heap.addr, align 8
  %1 = load i64, ptr %size.addr, align 8
  %call = call ptr @_mi_heap_malloc_zero(ptr noundef %0, i64 noundef %1, i1 noundef zeroext false)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define hidden noalias ptr @mi_malloc(i64 noundef %size) #0 {
entry:
  %size.addr = alloca i64, align 8
  store i64 %size, ptr %size.addr, align 8
  %call = call ptr @mi_prim_get_default_heap()
  %0 = load i64, ptr %size.addr, align 8
  %call1 = call noalias ptr @mi_heap_malloc(ptr noundef %call, i64 noundef %0)
  ret ptr %call1
}

; Function Attrs: nounwind uwtable
define hidden noalias ptr @mi_zalloc_small(i64 noundef %size) #0 {
entry:
  %size.addr = alloca i64, align 8
  store i64 %size, ptr %size.addr, align 8
  %call = call ptr @mi_prim_get_default_heap()
  %0 = load i64, ptr %size.addr, align 8
  %call1 = call ptr @mi_heap_malloc_small_zero(ptr noundef %call, i64 noundef %0, i1 noundef zeroext true)
  ret ptr %call1
}

; Function Attrs: nounwind uwtable
define hidden noalias ptr @mi_heap_zalloc(ptr noundef %heap, i64 noundef %size) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load ptr, ptr %heap.addr, align 8
  %1 = load i64, ptr %size.addr, align 8
  %call = call ptr @_mi_heap_malloc_zero(ptr noundef %0, i64 noundef %1, i1 noundef zeroext true)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define hidden noalias ptr @mi_zalloc(i64 noundef %size) #0 {
entry:
  %size.addr = alloca i64, align 8
  store i64 %size, ptr %size.addr, align 8
  %call = call ptr @mi_prim_get_default_heap()
  %0 = load i64, ptr %size.addr, align 8
  %call1 = call noalias ptr @mi_heap_zalloc(ptr noundef %call, i64 noundef %0)
  ret ptr %call1
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_padding_shrink(ptr noundef %page, ptr noundef %block, i64 noundef %min_size) #0 {
entry:
  %page.addr = alloca ptr, align 8
  %block.addr = alloca ptr, align 8
  %min_size.addr = alloca i64, align 8
  store ptr %page, ptr %page.addr, align 8
  store ptr %block, ptr %block.addr, align 8
  store i64 %min_size, ptr %min_size.addr, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define hidden ptr @_mi_page_ptr_unalign(ptr noundef %segment, ptr noundef %page, ptr noundef %p) #0 {
entry:
  %segment.addr = alloca ptr, align 8
  %page.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %diff = alloca i64, align 8
  %adjust = alloca i64, align 8
  store ptr %segment, ptr %segment.addr, align 8
  store ptr %page, ptr %page.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %1 = load ptr, ptr %segment.addr, align 8
  %2 = load ptr, ptr %page.addr, align 8
  %call = call ptr @_mi_page_start(ptr noundef %1, ptr noundef %2, ptr noundef null)
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %call to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, ptr %diff, align 8
  %3 = load i64, ptr %diff, align 8
  %4 = load ptr, ptr %page.addr, align 8
  %call1 = call i64 @mi_page_block_size(ptr noundef %4)
  %rem = urem i64 %3, %call1
  store i64 %rem, ptr %adjust, align 8
  %5 = load ptr, ptr %p.addr, align 8
  %6 = ptrtoint ptr %5 to i64
  %7 = load i64, ptr %adjust, align 8
  %sub = sub i64 %6, %7
  %8 = inttoptr i64 %sub to ptr
  ret ptr %8
}

; Function Attrs: nounwind uwtable
define internal ptr @_mi_page_start(ptr noundef %segment, ptr noundef %page, ptr noundef %page_size) #0 {
entry:
  %segment.addr = alloca ptr, align 8
  %page.addr = alloca ptr, align 8
  %page_size.addr = alloca ptr, align 8
  store ptr %segment, ptr %segment.addr, align 8
  store ptr %page, ptr %page.addr, align 8
  store ptr %page_size, ptr %page_size.addr, align 8
  %0 = load ptr, ptr %segment.addr, align 8
  %1 = load ptr, ptr %page.addr, align 8
  %2 = load ptr, ptr %page_size.addr, align 8
  %call = call ptr @_mi_segment_page_start(ptr noundef %0, ptr noundef %1, ptr noundef %2)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal i64 @mi_page_block_size(ptr noundef %page) #0 {
entry:
  %retval = alloca i64, align 8
  %page.addr = alloca ptr, align 8
  %bsize = alloca i64, align 8
  %psize = alloca i64, align 8
  store ptr %page, ptr %page.addr, align 8
  %0 = load ptr, ptr %page.addr, align 8
  %xblock_size = getelementptr inbounds %struct.mi_page_s, ptr %0, i32 0, i32 9
  %1 = load i32, ptr %xblock_size, align 4
  %conv = zext i32 %1 to i64
  store i64 %conv, ptr %bsize, align 8
  %2 = load i64, ptr %bsize, align 8
  %cmp = icmp ult i64 %2, 2147483648
  %lnot = xor i1 %cmp, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv3 = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv3, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load i64, ptr %bsize, align 8
  store i64 %3, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %4 = load ptr, ptr %page.addr, align 8
  %call = call ptr @_mi_page_segment(ptr noundef %4)
  %5 = load ptr, ptr %page.addr, align 8
  %call4 = call ptr @_mi_segment_page_start(ptr noundef %call, ptr noundef %5, ptr noundef %psize)
  %6 = load i64, ptr %psize, align 8
  store i64 %6, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %7 = load i64, ptr %retval, align 8
  ret i64 %7
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_free_generic(ptr noundef %segment, ptr noundef %page, i1 noundef zeroext %is_local, ptr noundef %p) #0 {
entry:
  %segment.addr = alloca ptr, align 8
  %page.addr = alloca ptr, align 8
  %is_local.addr = alloca i8, align 1
  %p.addr = alloca ptr, align 8
  %block = alloca ptr, align 8
  store ptr %segment, ptr %segment.addr, align 8
  store ptr %page, ptr %page.addr, align 8
  %frombool = zext i1 %is_local to i8
  store i8 %frombool, ptr %is_local.addr, align 1
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %page.addr, align 8
  %call = call zeroext i1 @mi_page_has_aligned(ptr noundef %0)
  br i1 %call, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load ptr, ptr %segment.addr, align 8
  %2 = load ptr, ptr %page.addr, align 8
  %3 = load ptr, ptr %p.addr, align 8
  %call1 = call ptr @_mi_page_ptr_unalign(ptr noundef %1, ptr noundef %2, ptr noundef %3)
  br label %cond.end

cond.false:                                       ; preds = %entry
  %4 = load ptr, ptr %p.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call1, %cond.true ], [ %4, %cond.false ]
  store ptr %cond, ptr %block, align 8
  %5 = load ptr, ptr %page.addr, align 8
  %6 = load ptr, ptr %block, align 8
  call void @mi_stat_free(ptr noundef %5, ptr noundef %6)
  %7 = load ptr, ptr %page.addr, align 8
  %8 = load i8, ptr %is_local.addr, align 1
  %tobool = trunc i8 %8 to i1
  %9 = load ptr, ptr %block, align 8
  call void @_mi_free_block(ptr noundef %7, i1 noundef zeroext %tobool, ptr noundef %9)
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_page_has_aligned(ptr noundef %page) #0 {
entry:
  %page.addr = alloca ptr, align 8
  store ptr %page, ptr %page.addr, align 8
  %0 = load ptr, ptr %page.addr, align 8
  %flags = getelementptr inbounds %struct.mi_page_s, ptr %0, i32 0, i32 5
  %bf.load = load i8, ptr %flags, align 2
  %bf.lshr = lshr i8 %bf.load, 1
  %bf.clear = and i8 %bf.lshr, 1
  %tobool = icmp ne i8 %bf.clear, 0
  ret i1 %tobool
}

; Function Attrs: nounwind uwtable
define internal void @mi_stat_free(ptr noundef %page, ptr noundef %block) #0 {
entry:
  %page.addr = alloca ptr, align 8
  %block.addr = alloca ptr, align 8
  store ptr %page, ptr %page.addr, align 8
  store ptr %block, ptr %block.addr, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @_mi_free_block(ptr noundef %page, i1 noundef zeroext %local, ptr noundef %block) #0 {
entry:
  %page.addr = alloca ptr, align 8
  %local.addr = alloca i8, align 1
  %block.addr = alloca ptr, align 8
  store ptr %page, ptr %page.addr, align 8
  %frombool = zext i1 %local to i8
  store i8 %frombool, ptr %local.addr, align 1
  store ptr %block, ptr %block.addr, align 8
  %0 = load i8, ptr %local.addr, align 1
  %tobool = trunc i8 %0 to i1
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %if.then, label %if.else29

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %page.addr, align 8
  %2 = load ptr, ptr %block.addr, align 8
  %call = call zeroext i1 @mi_check_is_double_free(ptr noundef %1, ptr noundef %2)
  %lnot3 = xor i1 %call, true
  %lnot5 = xor i1 %lnot3, true
  %lnot.ext6 = zext i1 %lnot5 to i32
  %conv7 = sext i32 %lnot.ext6 to i64
  %tobool8 = icmp ne i64 %conv7, 0
  br i1 %tobool8, label %if.then9, label %if.end

if.then9:                                         ; preds = %if.then
  br label %if.end30

if.end:                                           ; preds = %if.then
  %3 = load ptr, ptr %page.addr, align 8
  %4 = load ptr, ptr %block.addr, align 8
  call void @mi_check_padding(ptr noundef %3, ptr noundef %4)
  %5 = load ptr, ptr %page.addr, align 8
  %6 = load ptr, ptr %block.addr, align 8
  %7 = load ptr, ptr %page.addr, align 8
  %local_free = getelementptr inbounds %struct.mi_page_s, ptr %7, i32 0, i32 10
  %8 = load ptr, ptr %local_free, align 8
  call void @mi_block_set_next(ptr noundef %5, ptr noundef %6, ptr noundef %8)
  %9 = load ptr, ptr %block.addr, align 8
  %10 = load ptr, ptr %page.addr, align 8
  %local_free10 = getelementptr inbounds %struct.mi_page_s, ptr %10, i32 0, i32 10
  store ptr %9, ptr %local_free10, align 8
  %11 = load ptr, ptr %page.addr, align 8
  %used = getelementptr inbounds %struct.mi_page_s, ptr %11, i32 0, i32 8
  %12 = load i32, ptr %used, align 8
  %dec = add i32 %12, -1
  store i32 %dec, ptr %used, align 8
  %13 = load ptr, ptr %page.addr, align 8
  %call11 = call zeroext i1 @mi_page_all_free(ptr noundef %13)
  %lnot12 = xor i1 %call11, true
  %lnot14 = xor i1 %lnot12, true
  %lnot.ext15 = zext i1 %lnot14 to i32
  %conv16 = sext i32 %lnot.ext15 to i64
  %tobool17 = icmp ne i64 %conv16, 0
  br i1 %tobool17, label %if.then18, label %if.else

if.then18:                                        ; preds = %if.end
  %14 = load ptr, ptr %page.addr, align 8
  call void @_mi_page_retire(ptr noundef %14)
  br label %if.end28

if.else:                                          ; preds = %if.end
  %15 = load ptr, ptr %page.addr, align 8
  %call19 = call zeroext i1 @mi_page_is_in_full(ptr noundef %15)
  %lnot20 = xor i1 %call19, true
  %lnot22 = xor i1 %lnot20, true
  %lnot.ext23 = zext i1 %lnot22 to i32
  %conv24 = sext i32 %lnot.ext23 to i64
  %tobool25 = icmp ne i64 %conv24, 0
  br i1 %tobool25, label %if.then26, label %if.end27

if.then26:                                        ; preds = %if.else
  %16 = load ptr, ptr %page.addr, align 8
  call void @_mi_page_unfull(ptr noundef %16)
  br label %if.end27

if.end27:                                         ; preds = %if.then26, %if.else
  br label %if.end28

if.end28:                                         ; preds = %if.end27, %if.then18
  br label %if.end30

if.else29:                                        ; preds = %entry
  %17 = load ptr, ptr %page.addr, align 8
  %18 = load ptr, ptr %block.addr, align 8
  call void @_mi_free_block_mt(ptr noundef %17, ptr noundef %18)
  br label %if.end30

if.end30:                                         ; preds = %if.else29, %if.end28, %if.then9
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @mi_free(ptr noundef %p) #0 {
entry:
  %p.addr = alloca ptr, align 8
  %segment = alloca ptr, align 8
  %is_local = alloca i8, align 1
  %atomic-temp = alloca i64, align 8
  %page = alloca ptr, align 8
  %block = alloca ptr, align 8
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %cmp = icmp eq ptr %0, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end46

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %p.addr, align 8
  %call = call ptr @mi_checked_ptr_segment(ptr noundef %1, ptr noundef @.str)
  store ptr %call, ptr %segment, align 8
  %call2 = call i64 @_mi_prim_thread_id()
  %2 = load ptr, ptr %segment, align 8
  %thread_id = getelementptr inbounds %struct.mi_segment_s, ptr %2, i32 0, i32 17
  %3 = load atomic i64, ptr %thread_id monotonic, align 8
  store i64 %3, ptr %atomic-temp, align 8
  %4 = load i64, ptr %atomic-temp, align 8
  %cmp3 = icmp eq i64 %call2, %4
  %frombool = zext i1 %cmp3 to i8
  store i8 %frombool, ptr %is_local, align 1
  %5 = load ptr, ptr %segment, align 8
  %6 = load ptr, ptr %p.addr, align 8
  %call5 = call ptr @_mi_segment_page_of(ptr noundef %5, ptr noundef %6)
  store ptr %call5, ptr %page, align 8
  %7 = load i8, ptr %is_local, align 1
  %tobool6 = trunc i8 %7 to i1
  %lnot7 = xor i1 %tobool6, true
  %lnot9 = xor i1 %lnot7, true
  %lnot.ext10 = zext i1 %lnot9 to i32
  %conv11 = sext i32 %lnot.ext10 to i64
  %tobool12 = icmp ne i64 %conv11, 0
  br i1 %tobool12, label %if.then13, label %if.else45

if.then13:                                        ; preds = %if.end
  %8 = load ptr, ptr %page, align 8
  %flags = getelementptr inbounds %struct.mi_page_s, ptr %8, i32 0, i32 5
  %9 = load i8, ptr %flags, align 2
  %conv14 = zext i8 %9 to i32
  %cmp15 = icmp eq i32 %conv14, 0
  %lnot17 = xor i1 %cmp15, true
  %lnot19 = xor i1 %lnot17, true
  %lnot.ext20 = zext i1 %lnot19 to i32
  %conv21 = sext i32 %lnot.ext20 to i64
  %tobool22 = icmp ne i64 %conv21, 0
  br i1 %tobool22, label %if.then23, label %if.else

if.then23:                                        ; preds = %if.then13
  %10 = load ptr, ptr %p.addr, align 8
  store ptr %10, ptr %block, align 8
  %11 = load ptr, ptr %page, align 8
  %12 = load ptr, ptr %block, align 8
  %call24 = call zeroext i1 @mi_check_is_double_free(ptr noundef %11, ptr noundef %12)
  %lnot25 = xor i1 %call24, true
  %lnot27 = xor i1 %lnot25, true
  %lnot.ext28 = zext i1 %lnot27 to i32
  %conv29 = sext i32 %lnot.ext28 to i64
  %tobool30 = icmp ne i64 %conv29, 0
  br i1 %tobool30, label %if.then31, label %if.end32

if.then31:                                        ; preds = %if.then23
  br label %if.end46

if.end32:                                         ; preds = %if.then23
  %13 = load ptr, ptr %page, align 8
  %14 = load ptr, ptr %block, align 8
  call void @mi_check_padding(ptr noundef %13, ptr noundef %14)
  %15 = load ptr, ptr %page, align 8
  %16 = load ptr, ptr %block, align 8
  call void @mi_stat_free(ptr noundef %15, ptr noundef %16)
  %17 = load ptr, ptr %page, align 8
  %18 = load ptr, ptr %block, align 8
  %19 = load ptr, ptr %page, align 8
  %local_free = getelementptr inbounds %struct.mi_page_s, ptr %19, i32 0, i32 10
  %20 = load ptr, ptr %local_free, align 8
  call void @mi_block_set_next(ptr noundef %17, ptr noundef %18, ptr noundef %20)
  %21 = load ptr, ptr %block, align 8
  %22 = load ptr, ptr %page, align 8
  %local_free33 = getelementptr inbounds %struct.mi_page_s, ptr %22, i32 0, i32 10
  store ptr %21, ptr %local_free33, align 8
  %23 = load ptr, ptr %page, align 8
  %used = getelementptr inbounds %struct.mi_page_s, ptr %23, i32 0, i32 8
  %24 = load i32, ptr %used, align 8
  %dec = add i32 %24, -1
  store i32 %dec, ptr %used, align 8
  %cmp34 = icmp eq i32 %dec, 0
  %lnot36 = xor i1 %cmp34, true
  %lnot38 = xor i1 %lnot36, true
  %lnot.ext39 = zext i1 %lnot38 to i32
  %conv40 = sext i32 %lnot.ext39 to i64
  %tobool41 = icmp ne i64 %conv40, 0
  br i1 %tobool41, label %if.then42, label %if.end43

if.then42:                                        ; preds = %if.end32
  %25 = load ptr, ptr %page, align 8
  call void @_mi_page_retire(ptr noundef %25)
  br label %if.end43

if.end43:                                         ; preds = %if.then42, %if.end32
  br label %if.end44

if.else:                                          ; preds = %if.then13
  %26 = load ptr, ptr %segment, align 8
  %27 = load ptr, ptr %page, align 8
  %28 = load ptr, ptr %p.addr, align 8
  call void @_mi_free_generic(ptr noundef %26, ptr noundef %27, i1 noundef zeroext true, ptr noundef %28)
  br label %if.end44

if.end44:                                         ; preds = %if.else, %if.end43
  br label %if.end46

if.else45:                                        ; preds = %if.end
  %29 = load ptr, ptr %segment, align 8
  %30 = load ptr, ptr %page, align 8
  %31 = load ptr, ptr %p.addr, align 8
  call void @_mi_free_generic(ptr noundef %29, ptr noundef %30, i1 noundef zeroext false, ptr noundef %31)
  br label %if.end46

if.end46:                                         ; preds = %if.else45, %if.end44, %if.then31, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_checked_ptr_segment(ptr noundef %p, ptr noundef %msg) #0 {
entry:
  %p.addr = alloca ptr, align 8
  %msg.addr = alloca ptr, align 8
  %segment = alloca ptr, align 8
  store ptr %p, ptr %p.addr, align 8
  store ptr %msg, ptr %msg.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %call = call ptr @_mi_ptr_segment(ptr noundef %0)
  store ptr %call, ptr %segment, align 8
  %1 = load ptr, ptr %segment, align 8
  ret ptr %1
}

; Function Attrs: nounwind uwtable
define internal i64 @_mi_prim_thread_id() #0 {
entry:
  %call = call ptr @mi_prim_tls_slot(i64 noundef 0)
  %0 = ptrtoint ptr %call to i64
  ret i64 %0
}

; Function Attrs: nounwind uwtable
define internal ptr @_mi_segment_page_of(ptr noundef %segment, ptr noundef %p) #0 {
entry:
  %segment.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %diff = alloca i64, align 8
  %idx = alloca i64, align 8
  %slice0 = alloca ptr, align 8
  %slice = alloca ptr, align 8
  store ptr %segment, ptr %segment.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %1 = load ptr, ptr %segment.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, ptr %diff, align 8
  %2 = load i64, ptr %diff, align 8
  %shr = lshr i64 %2, 16
  store i64 %shr, ptr %idx, align 8
  %3 = load ptr, ptr %segment.addr, align 8
  %slices = getelementptr inbounds %struct.mi_segment_s, ptr %3, i32 0, i32 18
  %4 = load i64, ptr %idx, align 8
  %arrayidx = getelementptr [513 x %struct.mi_page_s], ptr %slices, i64 0, i64 %4
  store ptr %arrayidx, ptr %slice0, align 8
  %5 = load ptr, ptr %slice0, align 8
  %call = call ptr @mi_slice_first(ptr noundef %5)
  store ptr %call, ptr %slice, align 8
  %6 = load ptr, ptr %slice, align 8
  %call1 = call ptr @mi_slice_to_page(ptr noundef %6)
  ret ptr %call1
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_check_is_double_free(ptr noundef %page, ptr noundef %block) #0 {
entry:
  %page.addr = alloca ptr, align 8
  %block.addr = alloca ptr, align 8
  store ptr %page, ptr %page.addr, align 8
  store ptr %block, ptr %block.addr, align 8
  ret i1 false
}

; Function Attrs: nounwind uwtable
define internal void @mi_check_padding(ptr noundef %page, ptr noundef %block) #0 {
entry:
  %page.addr = alloca ptr, align 8
  %block.addr = alloca ptr, align 8
  store ptr %page, ptr %page.addr, align 8
  store ptr %block, ptr %block.addr, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_block_set_next(ptr noundef %page, ptr noundef %block, ptr noundef %next) #0 {
entry:
  %page.addr = alloca ptr, align 8
  %block.addr = alloca ptr, align 8
  %next.addr = alloca ptr, align 8
  store ptr %page, ptr %page.addr, align 8
  store ptr %block, ptr %block.addr, align 8
  store ptr %next, ptr %next.addr, align 8
  %0 = load ptr, ptr %page.addr, align 8
  %1 = load ptr, ptr %block.addr, align 8
  %2 = load ptr, ptr %next.addr, align 8
  call void @mi_block_set_nextx(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef null)
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_page_retire(ptr noundef %page) #0 {
entry:
  %page.addr = alloca ptr, align 8
  %pq = alloca ptr, align 8
  %heap = alloca ptr, align 8
  %index = alloca i64, align 8
  store ptr %page, ptr %page.addr, align 8
  %0 = load ptr, ptr %page.addr, align 8
  call void @mi_page_set_has_aligned(ptr noundef %0, i1 noundef zeroext false)
  %1 = load ptr, ptr %page.addr, align 8
  %call = call ptr @mi_page_queue_of(ptr noundef %1)
  store ptr %call, ptr %pq, align 8
  %2 = load ptr, ptr %page.addr, align 8
  %xblock_size = getelementptr inbounds %struct.mi_page_s, ptr %2, i32 0, i32 9
  %3 = load i32, ptr %xblock_size, align 4
  %conv = zext i32 %3 to i64
  %cmp = icmp ule i64 %conv, 131072
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %4 = load ptr, ptr %pq, align 8
  %call2 = call zeroext i1 @mi_page_queue_is_special(ptr noundef %4)
  %lnot = xor i1 %call2, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %5 = phi i1 [ false, %entry ], [ %lnot, %land.rhs ]
  %lnot3 = xor i1 %5, true
  %lnot4 = xor i1 %lnot3, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv5 = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv5, 0
  br i1 %tobool, label %if.then, label %if.end27

if.then:                                          ; preds = %land.end
  %6 = load ptr, ptr %pq, align 8
  %last = getelementptr inbounds %struct.mi_page_queue_s, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %last, align 8
  %8 = load ptr, ptr %page.addr, align 8
  %cmp6 = icmp eq ptr %7, %8
  br i1 %cmp6, label %land.lhs.true, label %if.end26

land.lhs.true:                                    ; preds = %if.then
  %9 = load ptr, ptr %pq, align 8
  %first = getelementptr inbounds %struct.mi_page_queue_s, ptr %9, i32 0, i32 0
  %10 = load ptr, ptr %first, align 8
  %11 = load ptr, ptr %page.addr, align 8
  %cmp8 = icmp eq ptr %10, %11
  br i1 %cmp8, label %if.then10, label %if.end26

if.then10:                                        ; preds = %land.lhs.true
  %12 = load ptr, ptr %page.addr, align 8
  %xblock_size11 = getelementptr inbounds %struct.mi_page_s, ptr %12, i32 0, i32 9
  %13 = load i32, ptr %xblock_size11, align 4
  %conv12 = zext i32 %13 to i64
  %cmp13 = icmp ule i64 %conv12, 16384
  %cond = select i1 %cmp13, i32 16, i32 4
  %add = add i32 1, %cond
  %conv15 = trunc i32 %add to i8
  %14 = load ptr, ptr %page.addr, align 8
  %retire_expire = getelementptr inbounds %struct.mi_page_s, ptr %14, i32 0, i32 6
  %bf.load = load i8, ptr %retire_expire, align 1
  %bf.value = and i8 %conv15, 127
  %bf.shl = shl i8 %bf.value, 1
  %bf.clear = and i8 %bf.load, 1
  %bf.set = or i8 %bf.clear, %bf.shl
  store i8 %bf.set, ptr %retire_expire, align 1
  %15 = load ptr, ptr %page.addr, align 8
  %call16 = call ptr @mi_page_heap(ptr noundef %15)
  store ptr %call16, ptr %heap, align 8
  %16 = load ptr, ptr %pq, align 8
  %17 = load ptr, ptr %heap, align 8
  %pages = getelementptr inbounds %struct.mi_heap_s, ptr %17, i32 0, i32 2
  %arraydecay = getelementptr inbounds [75 x %struct.mi_page_queue_s], ptr %pages, i64 0, i64 0
  %sub.ptr.lhs.cast = ptrtoint ptr %16 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %arraydecay to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 24
  store i64 %sub.ptr.div, ptr %index, align 8
  %18 = load i64, ptr %index, align 8
  %19 = load ptr, ptr %heap, align 8
  %page_retired_min = getelementptr inbounds %struct.mi_heap_s, ptr %19, i32 0, i32 10
  %20 = load i64, ptr %page_retired_min, align 8
  %cmp17 = icmp ult i64 %18, %20
  br i1 %cmp17, label %if.then19, label %if.end

if.then19:                                        ; preds = %if.then10
  %21 = load i64, ptr %index, align 8
  %22 = load ptr, ptr %heap, align 8
  %page_retired_min20 = getelementptr inbounds %struct.mi_heap_s, ptr %22, i32 0, i32 10
  store i64 %21, ptr %page_retired_min20, align 8
  br label %if.end

if.end:                                           ; preds = %if.then19, %if.then10
  %23 = load i64, ptr %index, align 8
  %24 = load ptr, ptr %heap, align 8
  %page_retired_max = getelementptr inbounds %struct.mi_heap_s, ptr %24, i32 0, i32 11
  %25 = load i64, ptr %page_retired_max, align 8
  %cmp21 = icmp ugt i64 %23, %25
  br i1 %cmp21, label %if.then23, label %if.end25

if.then23:                                        ; preds = %if.end
  %26 = load i64, ptr %index, align 8
  %27 = load ptr, ptr %heap, align 8
  %page_retired_max24 = getelementptr inbounds %struct.mi_heap_s, ptr %27, i32 0, i32 11
  store i64 %26, ptr %page_retired_max24, align 8
  br label %if.end25

if.end25:                                         ; preds = %if.then23, %if.end
  br label %return

if.end26:                                         ; preds = %land.lhs.true, %if.then
  br label %if.end27

if.end27:                                         ; preds = %if.end26, %land.end
  %28 = load ptr, ptr %page.addr, align 8
  %29 = load ptr, ptr %pq, align 8
  call void @_mi_page_free(ptr noundef %28, ptr noundef %29, i1 noundef zeroext false)
  br label %return

return:                                           ; preds = %if.end27, %if.end25
  ret void
}

; Function Attrs: nounwind uwtable
define hidden zeroext i1 @_mi_free_delayed_block(ptr noundef %block) #0 {
entry:
  %retval = alloca i1, align 1
  %block.addr = alloca ptr, align 8
  %segment = alloca ptr, align 8
  %page = alloca ptr, align 8
  store ptr %block, ptr %block.addr, align 8
  %0 = load ptr, ptr %block.addr, align 8
  %call = call ptr @_mi_ptr_segment(ptr noundef %0)
  store ptr %call, ptr %segment, align 8
  %1 = load ptr, ptr %segment, align 8
  %2 = load ptr, ptr %block.addr, align 8
  %call1 = call ptr @_mi_segment_page_of(ptr noundef %1, ptr noundef %2)
  store ptr %call1, ptr %page, align 8
  %3 = load ptr, ptr %page, align 8
  %call2 = call zeroext i1 @_mi_page_try_use_delayed_free(ptr noundef %3, i32 noundef 0, i1 noundef zeroext false)
  br i1 %call2, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %page, align 8
  call void @_mi_page_free_collect(ptr noundef %4, i1 noundef zeroext false)
  %5 = load ptr, ptr %page, align 8
  %6 = load ptr, ptr %block.addr, align 8
  call void @_mi_free_block(ptr noundef %5, i1 noundef zeroext true, ptr noundef %6)
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i1, ptr %retval, align 1
  ret i1 %7
}

; Function Attrs: nounwind uwtable
define internal ptr @_mi_ptr_segment(ptr noundef %p) #0 {
entry:
  %p.addr = alloca ptr, align 8
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %1 = ptrtoint ptr %0 to i64
  %sub = sub i64 %1, 1
  %and = and i64 %sub, -33554432
  %2 = inttoptr i64 %and to ptr
  ret ptr %2
}

; Function Attrs: nounwind uwtable
define hidden zeroext i1 @_mi_page_try_use_delayed_free(ptr noundef %page, i32 noundef %delay, i1 noundef zeroext %override_never) #0 {
entry:
  %retval = alloca i1, align 1
  %page.addr = alloca ptr, align 8
  %delay.addr = alloca i32, align 4
  %override_never.addr = alloca i8, align 1
  %tfreex = alloca i64, align 8
  %old_delay = alloca i32, align 4
  %tfree = alloca i64, align 8
  %yield_count = alloca i64, align 8
  %atomic-temp = alloca i64, align 8
  %.atomictmp = alloca i64, align 8
  %cmpxchg.bool = alloca i8, align 1
  store ptr %page, ptr %page.addr, align 8
  store i32 %delay, ptr %delay.addr, align 4
  %frombool = zext i1 %override_never to i8
  store i8 %frombool, ptr %override_never.addr, align 1
  store i64 0, ptr %yield_count, align 8
  br label %do.body

do.body:                                          ; preds = %lor.end, %entry
  %0 = load ptr, ptr %page.addr, align 8
  %xthread_free = getelementptr inbounds %struct.mi_page_s, ptr %0, i32 0, i32 11
  %1 = load atomic i64, ptr %xthread_free acquire, align 8
  store i64 %1, ptr %atomic-temp, align 8
  %2 = load i64, ptr %atomic-temp, align 8
  store i64 %2, ptr %tfree, align 8
  %3 = load i64, ptr %tfree, align 8
  %4 = load i32, ptr %delay.addr, align 4
  %call = call i64 @mi_tf_set_delayed(i64 noundef %3, i32 noundef %4)
  store i64 %call, ptr %tfreex, align 8
  %5 = load i64, ptr %tfree, align 8
  %call1 = call i32 @mi_tf_delayed(i64 noundef %5)
  store i32 %call1, ptr %old_delay, align 4
  %6 = load i32, ptr %old_delay, align 4
  %cmp = icmp eq i32 %6, 1
  %lnot = xor i1 %cmp, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  %7 = load i64, ptr %yield_count, align 8
  %cmp3 = icmp uge i64 %7, 4
  br i1 %cmp3, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.then
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %if.then
  %8 = load i64, ptr %yield_count, align 8
  %inc = add i64 %8, 1
  store i64 %inc, ptr %yield_count, align 8
  call void @mi_atomic_yield()
  br label %if.end16

if.else:                                          ; preds = %do.body
  %9 = load i32, ptr %delay.addr, align 4
  %10 = load i32, ptr %old_delay, align 4
  %cmp6 = icmp eq i32 %9, %10
  br i1 %cmp6, label %if.then8, label %if.else9

if.then8:                                         ; preds = %if.else
  br label %do.end

if.else9:                                         ; preds = %if.else
  %11 = load i8, ptr %override_never.addr, align 1
  %tobool10 = trunc i8 %11 to i1
  br i1 %tobool10, label %if.end14, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.else9
  %12 = load i32, ptr %old_delay, align 4
  %cmp11 = icmp eq i32 %12, 3
  br i1 %cmp11, label %if.then13, label %if.end14

if.then13:                                        ; preds = %land.lhs.true
  br label %do.end

if.end14:                                         ; preds = %land.lhs.true, %if.else9
  br label %if.end15

if.end15:                                         ; preds = %if.end14
  br label %if.end16

if.end16:                                         ; preds = %if.end15, %if.end
  br label %do.cond

do.cond:                                          ; preds = %if.end16
  %13 = load i32, ptr %old_delay, align 4
  %cmp17 = icmp eq i32 %13, 1
  br i1 %cmp17, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %do.cond
  %14 = load ptr, ptr %page.addr, align 8
  %xthread_free19 = getelementptr inbounds %struct.mi_page_s, ptr %14, i32 0, i32 11
  %15 = load i64, ptr %tfreex, align 8
  store i64 %15, ptr %.atomictmp, align 8
  %16 = load i64, ptr %tfree, align 8
  %17 = load i64, ptr %.atomictmp, align 8
  %18 = cmpxchg weak ptr %xthread_free19, i64 %16, i64 %17 release monotonic, align 8
  %19 = extractvalue { i64, i1 } %18, 0
  %20 = extractvalue { i64, i1 } %18, 1
  br i1 %20, label %cmpxchg.continue, label %cmpxchg.store_expected

cmpxchg.store_expected:                           ; preds = %lor.rhs
  store i64 %19, ptr %tfree, align 8
  br label %cmpxchg.continue

cmpxchg.continue:                                 ; preds = %cmpxchg.store_expected, %lor.rhs
  %frombool20 = zext i1 %20 to i8
  store i8 %frombool20, ptr %cmpxchg.bool, align 1
  %21 = load i8, ptr %cmpxchg.bool, align 1
  %tobool21 = trunc i8 %21 to i1
  %lnot22 = xor i1 %tobool21, true
  br label %lor.end

lor.end:                                          ; preds = %cmpxchg.continue, %do.cond
  %22 = phi i1 [ true, %do.cond ], [ %lnot22, %cmpxchg.continue ]
  br i1 %22, label %do.body, label %do.end, !llvm.loop !5

do.end:                                           ; preds = %lor.end, %if.then13, %if.then8
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %do.end, %if.then5
  %23 = load i1, ptr %retval, align 1
  ret i1 %23
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_page_free_collect(ptr noundef %page, i1 noundef zeroext %force) #0 {
entry:
  %page.addr = alloca ptr, align 8
  %force.addr = alloca i8, align 1
  %tail = alloca ptr, align 8
  %next = alloca ptr, align 8
  store ptr %page, ptr %page.addr, align 8
  %frombool = zext i1 %force to i8
  store i8 %frombool, ptr %force.addr, align 1
  %0 = load i8, ptr %force.addr, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %page.addr, align 8
  %call = call ptr @mi_page_thread_free(ptr noundef %1)
  %cmp = icmp ne ptr %call, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %2 = load ptr, ptr %page.addr, align 8
  call void @_mi_page_thread_free_collect(ptr noundef %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  %3 = load ptr, ptr %page.addr, align 8
  %local_free = getelementptr inbounds %struct.mi_page_s, ptr %3, i32 0, i32 10
  %4 = load ptr, ptr %local_free, align 8
  %cmp1 = icmp ne ptr %4, null
  br i1 %cmp1, label %if.then2, label %if.end26

if.then2:                                         ; preds = %if.end
  %5 = load ptr, ptr %page.addr, align 8
  %free = getelementptr inbounds %struct.mi_page_s, ptr %5, i32 0, i32 7
  %6 = load ptr, ptr %free, align 8
  %cmp3 = icmp eq ptr %6, null
  %lnot = xor i1 %cmp3, true
  %lnot4 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool5 = icmp ne i64 %conv, 0
  br i1 %tobool5, label %if.then6, label %if.else

if.then6:                                         ; preds = %if.then2
  %7 = load ptr, ptr %page.addr, align 8
  %local_free7 = getelementptr inbounds %struct.mi_page_s, ptr %7, i32 0, i32 10
  %8 = load ptr, ptr %local_free7, align 8
  %9 = load ptr, ptr %page.addr, align 8
  %free8 = getelementptr inbounds %struct.mi_page_s, ptr %9, i32 0, i32 7
  store ptr %8, ptr %free8, align 8
  %10 = load ptr, ptr %page.addr, align 8
  %local_free9 = getelementptr inbounds %struct.mi_page_s, ptr %10, i32 0, i32 10
  store ptr null, ptr %local_free9, align 8
  %11 = load ptr, ptr %page.addr, align 8
  %free_is_zero = getelementptr inbounds %struct.mi_page_s, ptr %11, i32 0, i32 6
  %bf.load = load i8, ptr %free_is_zero, align 1
  %bf.clear = and i8 %bf.load, -2
  %bf.set = or i8 %bf.clear, 0
  store i8 %bf.set, ptr %free_is_zero, align 1
  br label %if.end25

if.else:                                          ; preds = %if.then2
  %12 = load i8, ptr %force.addr, align 1
  %tobool10 = trunc i8 %12 to i1
  br i1 %tobool10, label %if.then11, label %if.end24

if.then11:                                        ; preds = %if.else
  %13 = load ptr, ptr %page.addr, align 8
  %local_free12 = getelementptr inbounds %struct.mi_page_s, ptr %13, i32 0, i32 10
  %14 = load ptr, ptr %local_free12, align 8
  store ptr %14, ptr %tail, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then11
  %15 = load ptr, ptr %page.addr, align 8
  %16 = load ptr, ptr %tail, align 8
  %call13 = call ptr @mi_block_next(ptr noundef %15, ptr noundef %16)
  store ptr %call13, ptr %next, align 8
  %cmp14 = icmp ne ptr %call13, null
  br i1 %cmp14, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %17 = load ptr, ptr %next, align 8
  store ptr %17, ptr %tail, align 8
  br label %while.cond, !llvm.loop !7

while.end:                                        ; preds = %while.cond
  %18 = load ptr, ptr %page.addr, align 8
  %19 = load ptr, ptr %tail, align 8
  %20 = load ptr, ptr %page.addr, align 8
  %free16 = getelementptr inbounds %struct.mi_page_s, ptr %20, i32 0, i32 7
  %21 = load ptr, ptr %free16, align 8
  call void @mi_block_set_next(ptr noundef %18, ptr noundef %19, ptr noundef %21)
  %22 = load ptr, ptr %page.addr, align 8
  %local_free17 = getelementptr inbounds %struct.mi_page_s, ptr %22, i32 0, i32 10
  %23 = load ptr, ptr %local_free17, align 8
  %24 = load ptr, ptr %page.addr, align 8
  %free18 = getelementptr inbounds %struct.mi_page_s, ptr %24, i32 0, i32 7
  store ptr %23, ptr %free18, align 8
  %25 = load ptr, ptr %page.addr, align 8
  %local_free19 = getelementptr inbounds %struct.mi_page_s, ptr %25, i32 0, i32 10
  store ptr null, ptr %local_free19, align 8
  %26 = load ptr, ptr %page.addr, align 8
  %free_is_zero20 = getelementptr inbounds %struct.mi_page_s, ptr %26, i32 0, i32 6
  %bf.load21 = load i8, ptr %free_is_zero20, align 1
  %bf.clear22 = and i8 %bf.load21, -2
  %bf.set23 = or i8 %bf.clear22, 0
  store i8 %bf.set23, ptr %free_is_zero20, align 1
  br label %if.end24

if.end24:                                         ; preds = %while.end, %if.else
  br label %if.end25

if.end25:                                         ; preds = %if.end24, %if.then6
  br label %if.end26

if.end26:                                         ; preds = %if.end25, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define hidden i64 @mi_usable_size(ptr noundef %p) #0 {
entry:
  %p.addr = alloca ptr, align 8
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %call = call i64 @_mi_usable_size(ptr noundef %0, ptr noundef @.str.1)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define internal i64 @_mi_usable_size(ptr noundef %p, ptr noundef %msg) #0 {
entry:
  %retval = alloca i64, align 8
  %p.addr = alloca ptr, align 8
  %msg.addr = alloca ptr, align 8
  %segment = alloca ptr, align 8
  %page = alloca ptr, align 8
  %block = alloca ptr, align 8
  store ptr %p, ptr %p.addr, align 8
  store ptr %msg, ptr %msg.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 0, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %p.addr, align 8
  %2 = load ptr, ptr %msg.addr, align 8
  %call = call ptr @mi_checked_ptr_segment(ptr noundef %1, ptr noundef %2)
  store ptr %call, ptr %segment, align 8
  %3 = load ptr, ptr %segment, align 8
  %4 = load ptr, ptr %p.addr, align 8
  %call1 = call ptr @_mi_segment_page_of(ptr noundef %3, ptr noundef %4)
  store ptr %call1, ptr %page, align 8
  %5 = load ptr, ptr %page, align 8
  %call2 = call zeroext i1 @mi_page_has_aligned(ptr noundef %5)
  %lnot = xor i1 %call2, true
  %lnot3 = xor i1 %lnot, true
  %lnot4 = xor i1 %lnot3, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %if.then5, label %if.else

if.then5:                                         ; preds = %if.end
  %6 = load ptr, ptr %p.addr, align 8
  store ptr %6, ptr %block, align 8
  %7 = load ptr, ptr %page, align 8
  %8 = load ptr, ptr %block, align 8
  %call6 = call i64 @mi_page_usable_size_of(ptr noundef %7, ptr noundef %8)
  store i64 %call6, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %if.end
  %9 = load ptr, ptr %segment, align 8
  %10 = load ptr, ptr %page, align 8
  %11 = load ptr, ptr %p.addr, align 8
  %call7 = call i64 @mi_page_usable_aligned_size_of(ptr noundef %9, ptr noundef %10, ptr noundef %11)
  store i64 %call7, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then5, %if.then
  %12 = load i64, ptr %retval, align 8
  ret i64 %12
}

; Function Attrs: nounwind uwtable
define hidden void @mi_free_size(ptr noundef %p, i64 noundef %size) #0 {
entry:
  %p.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  call void @mi_free(ptr noundef %0)
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @mi_free_size_aligned(ptr noundef %p, i64 noundef %size, i64 noundef %alignment) #0 {
entry:
  %p.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %1 = load i64, ptr %size.addr, align 8
  call void @mi_free_size(ptr noundef %0, i64 noundef %1)
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @mi_free_aligned(ptr noundef %p, i64 noundef %alignment) #0 {
entry:
  %p.addr = alloca ptr, align 8
  %alignment.addr = alloca i64, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  call void @mi_free(ptr noundef %0)
  ret void
}

; Function Attrs: nounwind uwtable
define hidden noalias ptr @mi_heap_calloc(ptr noundef %heap, i64 noundef %count, i64 noundef %size) #0 {
entry:
  %retval = alloca ptr, align 8
  %heap.addr = alloca ptr, align 8
  %count.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %total = alloca i64, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store i64 %count, ptr %count.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load i64, ptr %count.addr, align 8
  %1 = load i64, ptr %size.addr, align 8
  %call = call zeroext i1 @mi_count_size_overflow(i64 noundef %0, i64 noundef %1, ptr noundef %total)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %heap.addr, align 8
  %3 = load i64, ptr %total, align 8
  %call1 = call noalias ptr @mi_heap_zalloc(ptr noundef %2, i64 noundef %3)
  store ptr %call1, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load ptr, ptr %retval, align 8
  ret ptr %4
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_count_size_overflow(i64 noundef %count, i64 noundef %size, ptr noundef %total) #0 {
entry:
  %retval = alloca i1, align 1
  %count.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %total.addr = alloca ptr, align 8
  store i64 %count, ptr %count.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store ptr %total, ptr %total.addr, align 8
  %0 = load i64, ptr %count.addr, align 8
  %cmp = icmp eq i64 %0, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i64, ptr %size.addr, align 8
  %2 = load ptr, ptr %total.addr, align 8
  store i64 %1, ptr %2, align 8
  store i1 false, ptr %retval, align 1
  br label %return

if.else:                                          ; preds = %entry
  %3 = load i64, ptr %count.addr, align 8
  %4 = load i64, ptr %size.addr, align 8
  %5 = load ptr, ptr %total.addr, align 8
  %call = call zeroext i1 @mi_mul_overflow(i64 noundef %3, i64 noundef %4, ptr noundef %5)
  %lnot = xor i1 %call, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %if.then2, label %if.else3

if.then2:                                         ; preds = %if.else
  %6 = load ptr, ptr %total.addr, align 8
  store i64 -1, ptr %6, align 8
  store i1 true, ptr %retval, align 1
  br label %return

if.else3:                                         ; preds = %if.else
  store i1 false, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.else3, %if.then2, %if.then
  %7 = load i1, ptr %retval, align 1
  ret i1 %7
}

; Function Attrs: nounwind uwtable
define hidden noalias ptr @mi_calloc(i64 noundef %count, i64 noundef %size) #0 {
entry:
  %count.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  store i64 %count, ptr %count.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %call = call ptr @mi_prim_get_default_heap()
  %0 = load i64, ptr %count.addr, align 8
  %1 = load i64, ptr %size.addr, align 8
  %call1 = call noalias ptr @mi_heap_calloc(ptr noundef %call, i64 noundef %0, i64 noundef %1)
  ret ptr %call1
}

; Function Attrs: nounwind uwtable
define hidden noalias ptr @mi_heap_mallocn(ptr noundef %heap, i64 noundef %count, i64 noundef %size) #0 {
entry:
  %retval = alloca ptr, align 8
  %heap.addr = alloca ptr, align 8
  %count.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %total = alloca i64, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store i64 %count, ptr %count.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load i64, ptr %count.addr, align 8
  %1 = load i64, ptr %size.addr, align 8
  %call = call zeroext i1 @mi_count_size_overflow(i64 noundef %0, i64 noundef %1, ptr noundef %total)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %heap.addr, align 8
  %3 = load i64, ptr %total, align 8
  %call1 = call noalias ptr @mi_heap_malloc(ptr noundef %2, i64 noundef %3)
  store ptr %call1, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load ptr, ptr %retval, align 8
  ret ptr %4
}

; Function Attrs: nounwind uwtable
define hidden noalias ptr @mi_mallocn(i64 noundef %count, i64 noundef %size) #0 {
entry:
  %count.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  store i64 %count, ptr %count.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %call = call ptr @mi_prim_get_default_heap()
  %0 = load i64, ptr %count.addr, align 8
  %1 = load i64, ptr %size.addr, align 8
  %call1 = call noalias ptr @mi_heap_mallocn(ptr noundef %call, i64 noundef %0, i64 noundef %1)
  ret ptr %call1
}

; Function Attrs: nounwind uwtable
define hidden ptr @mi_expand(ptr noundef %p, i64 noundef %newsize) #0 {
entry:
  %retval = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %newsize.addr = alloca i64, align 8
  %size = alloca i64, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %newsize, ptr %newsize.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %p.addr, align 8
  %call = call i64 @_mi_usable_size(ptr noundef %1, ptr noundef @.str.2)
  store i64 %call, ptr %size, align 8
  %2 = load i64, ptr %newsize.addr, align 8
  %3 = load i64, ptr %size, align 8
  %cmp1 = icmp ugt i64 %2, %3
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end3:                                          ; preds = %if.end
  %4 = load ptr, ptr %p.addr, align 8
  store ptr %4, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end3, %if.then2, %if.then
  %5 = load ptr, ptr %retval, align 8
  ret ptr %5
}

; Function Attrs: nounwind uwtable
define hidden ptr @_mi_heap_realloc_zero(ptr noundef %heap, ptr noundef %p, i64 noundef %newsize, i1 noundef zeroext %zero) #0 {
entry:
  %retval = alloca ptr, align 8
  %heap.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %newsize.addr = alloca i64, align 8
  %zero.addr = alloca i8, align 1
  %size = alloca i64, align 8
  %newp = alloca ptr, align 8
  %start = alloca i64, align 8
  %copysize = alloca i64, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %newsize, ptr %newsize.addr, align 8
  %frombool = zext i1 %zero to i8
  store i8 %frombool, ptr %zero.addr, align 1
  %0 = load ptr, ptr %p.addr, align 8
  %call = call i64 @_mi_usable_size(ptr noundef %0, ptr noundef @.str.3)
  store i64 %call, ptr %size, align 8
  %1 = load i64, ptr %newsize.addr, align 8
  %2 = load i64, ptr %size, align 8
  %cmp = icmp ule i64 %1, %2
  br i1 %cmp, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %3 = load i64, ptr %newsize.addr, align 8
  %4 = load i64, ptr %size, align 8
  %div = udiv i64 %4, 2
  %cmp1 = icmp uge i64 %3, %div
  br i1 %cmp1, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %5 = load i64, ptr %newsize.addr, align 8
  %cmp2 = icmp ugt i64 %5, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %entry
  %6 = phi i1 [ false, %land.lhs.true ], [ false, %entry ], [ %cmp2, %land.rhs ]
  %lnot = xor i1 %6, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %land.end
  %7 = load ptr, ptr %p.addr, align 8
  store ptr %7, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %land.end
  %8 = load ptr, ptr %heap.addr, align 8
  %9 = load i64, ptr %newsize.addr, align 8
  %call4 = call noalias ptr @mi_heap_malloc(ptr noundef %8, i64 noundef %9)
  store ptr %call4, ptr %newp, align 8
  %10 = load ptr, ptr %newp, align 8
  %cmp5 = icmp ne ptr %10, null
  %lnot7 = xor i1 %cmp5, true
  %lnot9 = xor i1 %lnot7, true
  %lnot.ext10 = zext i1 %lnot9 to i32
  %conv11 = sext i32 %lnot.ext10 to i64
  %tobool12 = icmp ne i64 %conv11, 0
  br i1 %tobool12, label %if.then13, label %if.end44

if.then13:                                        ; preds = %if.end
  %11 = load i8, ptr %zero.addr, align 1
  %tobool14 = trunc i8 %11 to i1
  br i1 %tobool14, label %land.lhs.true16, label %if.else

land.lhs.true16:                                  ; preds = %if.then13
  %12 = load i64, ptr %newsize.addr, align 8
  %13 = load i64, ptr %size, align 8
  %cmp17 = icmp ugt i64 %12, %13
  br i1 %cmp17, label %if.then19, label %if.else

if.then19:                                        ; preds = %land.lhs.true16
  %14 = load i64, ptr %size, align 8
  %cmp20 = icmp uge i64 %14, 8
  br i1 %cmp20, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then19
  %15 = load i64, ptr %size, align 8
  %sub = sub i64 %15, 8
  br label %cond.end

cond.false:                                       ; preds = %if.then19
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %sub, %cond.true ], [ 0, %cond.false ]
  store i64 %cond, ptr %start, align 8
  %16 = load ptr, ptr %newp, align 8
  %17 = load i64, ptr %start, align 8
  %add.ptr = getelementptr i8, ptr %16, i64 %17
  %18 = load i64, ptr %newsize.addr, align 8
  %19 = load i64, ptr %start, align 8
  %sub22 = sub i64 %18, %19
  call void @_mi_memzero(ptr noundef %add.ptr, i64 noundef %sub22)
  br label %if.end27

if.else:                                          ; preds = %land.lhs.true16, %if.then13
  %20 = load i64, ptr %newsize.addr, align 8
  %cmp23 = icmp eq i64 %20, 0
  br i1 %cmp23, label %if.then25, label %if.end26

if.then25:                                        ; preds = %if.else
  %21 = load ptr, ptr %newp, align 8
  %arrayidx = getelementptr i8, ptr %21, i64 0
  store i8 0, ptr %arrayidx, align 1
  br label %if.end26

if.end26:                                         ; preds = %if.then25, %if.else
  br label %if.end27

if.end27:                                         ; preds = %if.end26, %cond.end
  %22 = load ptr, ptr %p.addr, align 8
  %cmp28 = icmp ne ptr %22, null
  %lnot30 = xor i1 %cmp28, true
  %lnot32 = xor i1 %lnot30, true
  %lnot.ext33 = zext i1 %lnot32 to i32
  %conv34 = sext i32 %lnot.ext33 to i64
  %tobool35 = icmp ne i64 %conv34, 0
  br i1 %tobool35, label %if.then36, label %if.end43

if.then36:                                        ; preds = %if.end27
  %23 = load i64, ptr %newsize.addr, align 8
  %24 = load i64, ptr %size, align 8
  %cmp37 = icmp ugt i64 %23, %24
  br i1 %cmp37, label %cond.true39, label %cond.false40

cond.true39:                                      ; preds = %if.then36
  %25 = load i64, ptr %size, align 8
  br label %cond.end41

cond.false40:                                     ; preds = %if.then36
  %26 = load i64, ptr %newsize.addr, align 8
  br label %cond.end41

cond.end41:                                       ; preds = %cond.false40, %cond.true39
  %cond42 = phi i64 [ %25, %cond.true39 ], [ %26, %cond.false40 ]
  store i64 %cond42, ptr %copysize, align 8
  %27 = load ptr, ptr %newp, align 8
  %28 = load ptr, ptr %p.addr, align 8
  %29 = load i64, ptr %copysize, align 8
  call void @_mi_memcpy(ptr noundef %27, ptr noundef %28, i64 noundef %29)
  %30 = load ptr, ptr %p.addr, align 8
  call void @mi_free(ptr noundef %30)
  br label %if.end43

if.end43:                                         ; preds = %cond.end41, %if.end27
  br label %if.end44

if.end44:                                         ; preds = %if.end43, %if.end
  %31 = load ptr, ptr %newp, align 8
  store ptr %31, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end44, %if.then
  %32 = load ptr, ptr %retval, align 8
  ret ptr %32
}

; Function Attrs: nounwind uwtable
define internal void @_mi_memzero(ptr noundef %dst, i64 noundef %n) #0 {
entry:
  %dst.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %dst, ptr %dst.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %0 = load ptr, ptr %dst.addr, align 8
  %1 = load i64, ptr %n.addr, align 8
  call void @llvm.memset.p0.i64(ptr align 1 %0, i8 0, i64 %1, i1 false)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @_mi_memcpy(ptr noundef %dst, ptr noundef %src, i64 noundef %n) #0 {
entry:
  %dst.addr = alloca ptr, align 8
  %src.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %dst, ptr %dst.addr, align 8
  store ptr %src, ptr %src.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %0 = load ptr, ptr %dst.addr, align 8
  %1 = load ptr, ptr %src.addr, align 8
  %2 = load i64, ptr %n.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %0, ptr align 1 %1, i64 %2, i1 false)
  ret void
}

; Function Attrs: nounwind uwtable
define hidden ptr @mi_heap_realloc(ptr noundef %heap, ptr noundef %p, i64 noundef %newsize) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %newsize.addr = alloca i64, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %newsize, ptr %newsize.addr, align 8
  %0 = load ptr, ptr %heap.addr, align 8
  %1 = load ptr, ptr %p.addr, align 8
  %2 = load i64, ptr %newsize.addr, align 8
  %call = call ptr @_mi_heap_realloc_zero(ptr noundef %0, ptr noundef %1, i64 noundef %2, i1 noundef zeroext false)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define hidden ptr @mi_heap_reallocn(ptr noundef %heap, ptr noundef %p, i64 noundef %count, i64 noundef %size) #0 {
entry:
  %retval = alloca ptr, align 8
  %heap.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %count.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %total = alloca i64, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %count, ptr %count.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load i64, ptr %count.addr, align 8
  %1 = load i64, ptr %size.addr, align 8
  %call = call zeroext i1 @mi_count_size_overflow(i64 noundef %0, i64 noundef %1, ptr noundef %total)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %heap.addr, align 8
  %3 = load ptr, ptr %p.addr, align 8
  %4 = load i64, ptr %total, align 8
  %call1 = call ptr @mi_heap_realloc(ptr noundef %2, ptr noundef %3, i64 noundef %4)
  store ptr %call1, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %5 = load ptr, ptr %retval, align 8
  ret ptr %5
}

; Function Attrs: nounwind uwtable
define hidden ptr @mi_heap_reallocf(ptr noundef %heap, ptr noundef %p, i64 noundef %newsize) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %newsize.addr = alloca i64, align 8
  %newp = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %newsize, ptr %newsize.addr, align 8
  %0 = load ptr, ptr %heap.addr, align 8
  %1 = load ptr, ptr %p.addr, align 8
  %2 = load i64, ptr %newsize.addr, align 8
  %call = call ptr @mi_heap_realloc(ptr noundef %0, ptr noundef %1, i64 noundef %2)
  store ptr %call, ptr %newp, align 8
  %3 = load ptr, ptr %newp, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %4 = load ptr, ptr %p.addr, align 8
  %cmp1 = icmp ne ptr %4, null
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %5 = load ptr, ptr %p.addr, align 8
  call void @mi_free(ptr noundef %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %6 = load ptr, ptr %newp, align 8
  ret ptr %6
}

; Function Attrs: nounwind uwtable
define hidden ptr @mi_heap_rezalloc(ptr noundef %heap, ptr noundef %p, i64 noundef %newsize) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %newsize.addr = alloca i64, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %newsize, ptr %newsize.addr, align 8
  %0 = load ptr, ptr %heap.addr, align 8
  %1 = load ptr, ptr %p.addr, align 8
  %2 = load i64, ptr %newsize.addr, align 8
  %call = call ptr @_mi_heap_realloc_zero(ptr noundef %0, ptr noundef %1, i64 noundef %2, i1 noundef zeroext true)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define hidden ptr @mi_heap_recalloc(ptr noundef %heap, ptr noundef %p, i64 noundef %count, i64 noundef %size) #0 {
entry:
  %retval = alloca ptr, align 8
  %heap.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %count.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %total = alloca i64, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %count, ptr %count.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load i64, ptr %count.addr, align 8
  %1 = load i64, ptr %size.addr, align 8
  %call = call zeroext i1 @mi_count_size_overflow(i64 noundef %0, i64 noundef %1, ptr noundef %total)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %heap.addr, align 8
  %3 = load ptr, ptr %p.addr, align 8
  %4 = load i64, ptr %total, align 8
  %call1 = call ptr @mi_heap_rezalloc(ptr noundef %2, ptr noundef %3, i64 noundef %4)
  store ptr %call1, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %5 = load ptr, ptr %retval, align 8
  ret ptr %5
}

; Function Attrs: nounwind uwtable
define hidden ptr @mi_realloc(ptr noundef %p, i64 noundef %newsize) #0 {
entry:
  %p.addr = alloca ptr, align 8
  %newsize.addr = alloca i64, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %newsize, ptr %newsize.addr, align 8
  %call = call ptr @mi_prim_get_default_heap()
  %0 = load ptr, ptr %p.addr, align 8
  %1 = load i64, ptr %newsize.addr, align 8
  %call1 = call ptr @mi_heap_realloc(ptr noundef %call, ptr noundef %0, i64 noundef %1)
  ret ptr %call1
}

; Function Attrs: nounwind uwtable
define hidden ptr @mi_reallocn(ptr noundef %p, i64 noundef %count, i64 noundef %size) #0 {
entry:
  %p.addr = alloca ptr, align 8
  %count.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %count, ptr %count.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %call = call ptr @mi_prim_get_default_heap()
  %0 = load ptr, ptr %p.addr, align 8
  %1 = load i64, ptr %count.addr, align 8
  %2 = load i64, ptr %size.addr, align 8
  %call1 = call ptr @mi_heap_reallocn(ptr noundef %call, ptr noundef %0, i64 noundef %1, i64 noundef %2)
  ret ptr %call1
}

; Function Attrs: nounwind uwtable
define hidden ptr @mi_reallocf(ptr noundef %p, i64 noundef %newsize) #0 {
entry:
  %p.addr = alloca ptr, align 8
  %newsize.addr = alloca i64, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %newsize, ptr %newsize.addr, align 8
  %call = call ptr @mi_prim_get_default_heap()
  %0 = load ptr, ptr %p.addr, align 8
  %1 = load i64, ptr %newsize.addr, align 8
  %call1 = call ptr @mi_heap_reallocf(ptr noundef %call, ptr noundef %0, i64 noundef %1)
  ret ptr %call1
}

; Function Attrs: nounwind uwtable
define hidden ptr @mi_rezalloc(ptr noundef %p, i64 noundef %newsize) #0 {
entry:
  %p.addr = alloca ptr, align 8
  %newsize.addr = alloca i64, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %newsize, ptr %newsize.addr, align 8
  %call = call ptr @mi_prim_get_default_heap()
  %0 = load ptr, ptr %p.addr, align 8
  %1 = load i64, ptr %newsize.addr, align 8
  %call1 = call ptr @mi_heap_rezalloc(ptr noundef %call, ptr noundef %0, i64 noundef %1)
  ret ptr %call1
}

; Function Attrs: nounwind uwtable
define hidden ptr @mi_recalloc(ptr noundef %p, i64 noundef %count, i64 noundef %size) #0 {
entry:
  %p.addr = alloca ptr, align 8
  %count.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %count, ptr %count.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %call = call ptr @mi_prim_get_default_heap()
  %0 = load ptr, ptr %p.addr, align 8
  %1 = load i64, ptr %count.addr, align 8
  %2 = load i64, ptr %size.addr, align 8
  %call1 = call ptr @mi_heap_recalloc(ptr noundef %call, ptr noundef %0, i64 noundef %1, i64 noundef %2)
  ret ptr %call1
}

; Function Attrs: nounwind uwtable
define hidden noalias ptr @mi_heap_strdup(ptr noundef %heap, ptr noundef %s) #0 {
entry:
  %retval = alloca ptr, align 8
  %heap.addr = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %n = alloca i64, align 8
  %t = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %call = call i64 @strlen(ptr noundef %1) #16
  store i64 %call, ptr %n, align 8
  %2 = load ptr, ptr %heap.addr, align 8
  %3 = load i64, ptr %n, align 8
  %add = add i64 %3, 1
  %call1 = call noalias ptr @mi_heap_malloc(ptr noundef %2, i64 noundef %add)
  store ptr %call1, ptr %t, align 8
  %4 = load ptr, ptr %t, align 8
  %cmp2 = icmp eq ptr %4, null
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  %5 = load ptr, ptr %t, align 8
  %6 = load ptr, ptr %s.addr, align 8
  %7 = load i64, ptr %n, align 8
  call void @_mi_memcpy(ptr noundef %5, ptr noundef %6, i64 noundef %7)
  %8 = load ptr, ptr %t, align 8
  %9 = load i64, ptr %n, align 8
  %arrayidx = getelementptr i8, ptr %8, i64 %9
  store i8 0, ptr %arrayidx, align 1
  %10 = load ptr, ptr %t, align 8
  store ptr %10, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end4, %if.then3, %if.then
  %11 = load ptr, ptr %retval, align 8
  ret ptr %11
}

; Function Attrs: nounwind willreturn memory(read)
declare i64 @strlen(ptr noundef) #1

; Function Attrs: nounwind uwtable
define hidden noalias ptr @mi_strdup(ptr noundef %s) #0 {
entry:
  %s.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %call = call ptr @mi_prim_get_default_heap()
  %0 = load ptr, ptr %s.addr, align 8
  %call1 = call noalias ptr @mi_heap_strdup(ptr noundef %call, ptr noundef %0)
  ret ptr %call1
}

; Function Attrs: nounwind uwtable
define hidden noalias ptr @mi_heap_strndup(ptr noundef %heap, ptr noundef %s, i64 noundef %n) #0 {
entry:
  %retval = alloca ptr, align 8
  %heap.addr = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %end = alloca ptr, align 8
  %m = alloca i64, align 8
  %t = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %2 = load i64, ptr %n.addr, align 8
  %call = call ptr @memchr(ptr noundef %1, i32 noundef 0, i64 noundef %2) #16
  store ptr %call, ptr %end, align 8
  %3 = load ptr, ptr %end, align 8
  %cmp1 = icmp ne ptr %3, null
  br i1 %cmp1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %4 = load ptr, ptr %end, align 8
  %5 = load ptr, ptr %s.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %4 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %5 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %6 = load i64, ptr %n.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %sub.ptr.sub, %cond.true ], [ %6, %cond.false ]
  store i64 %cond, ptr %m, align 8
  %7 = load ptr, ptr %heap.addr, align 8
  %8 = load i64, ptr %m, align 8
  %add = add i64 %8, 1
  %call2 = call noalias ptr @mi_heap_malloc(ptr noundef %7, i64 noundef %add)
  store ptr %call2, ptr %t, align 8
  %9 = load ptr, ptr %t, align 8
  %cmp3 = icmp eq ptr %9, null
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %cond.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end5:                                          ; preds = %cond.end
  %10 = load ptr, ptr %t, align 8
  %11 = load ptr, ptr %s.addr, align 8
  %12 = load i64, ptr %m, align 8
  call void @_mi_memcpy(ptr noundef %10, ptr noundef %11, i64 noundef %12)
  %13 = load ptr, ptr %t, align 8
  %14 = load i64, ptr %m, align 8
  %arrayidx = getelementptr i8, ptr %13, i64 %14
  store i8 0, ptr %arrayidx, align 1
  %15 = load ptr, ptr %t, align 8
  store ptr %15, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end5, %if.then4, %if.then
  %16 = load ptr, ptr %retval, align 8
  ret ptr %16
}

; Function Attrs: nounwind willreturn memory(read)
declare ptr @memchr(ptr noundef, i32 noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define hidden noalias ptr @mi_strndup(ptr noundef %s, i64 noundef %n) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %s, ptr %s.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %call = call ptr @mi_prim_get_default_heap()
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load i64, ptr %n.addr, align 8
  %call1 = call noalias ptr @mi_heap_strndup(ptr noundef %call, ptr noundef %0, i64 noundef %1)
  ret ptr %call1
}

; Function Attrs: nounwind uwtable
define hidden noalias ptr @mi_heap_realpath(ptr noundef %heap, ptr noundef %fname, ptr noundef %resolved_name) #0 {
entry:
  %retval = alloca ptr, align 8
  %heap.addr = alloca ptr, align 8
  %fname.addr = alloca ptr, align 8
  %resolved_name.addr = alloca ptr, align 8
  %rname = alloca ptr, align 8
  %result = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store ptr %fname, ptr %fname.addr, align 8
  store ptr %resolved_name, ptr %resolved_name.addr, align 8
  %0 = load ptr, ptr %resolved_name.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %fname.addr, align 8
  %2 = load ptr, ptr %resolved_name.addr, align 8
  %call = call ptr @realpath(ptr noundef %1, ptr noundef %2) #15
  store ptr %call, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %3 = load ptr, ptr %fname.addr, align 8
  %call1 = call ptr @realpath(ptr noundef %3, ptr noundef null) #15
  store ptr %call1, ptr %rname, align 8
  %4 = load ptr, ptr %rname, align 8
  %cmp2 = icmp eq ptr %4, null
  br i1 %cmp2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.else
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %if.else
  %5 = load ptr, ptr %heap.addr, align 8
  %6 = load ptr, ptr %rname, align 8
  %call4 = call noalias ptr @mi_heap_strdup(ptr noundef %5, ptr noundef %6)
  store ptr %call4, ptr %result, align 8
  %7 = load ptr, ptr %rname, align 8
  call void @free(ptr noundef %7) #15
  %8 = load ptr, ptr %result, align 8
  store ptr %8, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then3, %if.then
  %9 = load ptr, ptr %retval, align 8
  ret ptr %9
}

; Function Attrs: nounwind
declare ptr @realpath(ptr noundef, ptr noundef) #2

; Function Attrs: nounwind
declare void @free(ptr noundef) #2

; Function Attrs: nounwind uwtable
define hidden noalias ptr @mi_realpath(ptr noundef %fname, ptr noundef %resolved_name) #0 {
entry:
  %fname.addr = alloca ptr, align 8
  %resolved_name.addr = alloca ptr, align 8
  store ptr %fname, ptr %fname.addr, align 8
  store ptr %resolved_name, ptr %resolved_name.addr, align 8
  %call = call ptr @mi_prim_get_default_heap()
  %0 = load ptr, ptr %fname.addr, align 8
  %1 = load ptr, ptr %resolved_name.addr, align 8
  %call1 = call noalias ptr @mi_heap_realpath(ptr noundef %call, ptr noundef %0, ptr noundef %1)
  ret ptr %call1
}

; Function Attrs: nounwind uwtable
define weak hidden ptr @_Py__ZSt15get_new_handlerv() #0 {
entry:
  ret ptr null
}

; Function Attrs: nounwind uwtable
define hidden ptr @mi_heap_try_new(ptr noundef %heap, i64 noundef %size, i1 noundef zeroext %nothrow) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %nothrow.addr = alloca i8, align 1
  %p = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %frombool = zext i1 %nothrow to i8
  store i8 %frombool, ptr %nothrow.addr, align 1
  store ptr null, ptr %p, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load ptr, ptr %p, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %1 = load i8, ptr %nothrow.addr, align 1
  %tobool = trunc i8 %1 to i1
  %call = call zeroext i1 @mi_try_new_handler(i1 noundef zeroext %tobool)
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %2 = phi i1 [ false, %while.cond ], [ %call, %land.rhs ]
  br i1 %2, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %3 = load ptr, ptr %heap.addr, align 8
  %4 = load i64, ptr %size.addr, align 8
  %call1 = call noalias ptr @mi_heap_malloc(ptr noundef %3, i64 noundef %4)
  store ptr %call1, ptr %p, align 8
  br label %while.cond, !llvm.loop !8

while.end:                                        ; preds = %land.end
  %5 = load ptr, ptr %p, align 8
  ret ptr %5
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_try_new_handler(i1 noundef zeroext %nothrow) #0 {
entry:
  %retval = alloca i1, align 1
  %nothrow.addr = alloca i8, align 1
  %h = alloca ptr, align 8
  %frombool = zext i1 %nothrow to i8
  store i8 %frombool, ptr %nothrow.addr, align 1
  %call = call ptr @mi_get_new_handler()
  store ptr %call, ptr %h, align 8
  %0 = load ptr, ptr %h, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  call void (i32, ptr, ...) @_mi_error_message(i32 noundef 12, ptr noundef @.str.45)
  %1 = load i8, ptr %nothrow.addr, align 1
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %if.end, label %if.then1

if.then1:                                         ; preds = %if.then
  call void @abort() #17
  unreachable

if.end:                                           ; preds = %if.then
  store i1 false, ptr %retval, align 1
  br label %return

if.else:                                          ; preds = %entry
  %2 = load ptr, ptr %h, align 8
  call void %2()
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.else, %if.end
  %3 = load i1, ptr %retval, align 1
  ret i1 %3
}

; Function Attrs: nounwind uwtable
define hidden noalias ptr @mi_heap_alloc_new(ptr noundef %heap, i64 noundef %size) #0 {
entry:
  %retval = alloca ptr, align 8
  %heap.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %p = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load ptr, ptr %heap.addr, align 8
  %1 = load i64, ptr %size.addr, align 8
  %call = call noalias ptr @mi_heap_malloc(ptr noundef %0, i64 noundef %1)
  store ptr %call, ptr %p, align 8
  %2 = load ptr, ptr %p, align 8
  %cmp = icmp eq ptr %2, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %heap.addr, align 8
  %4 = load i64, ptr %size.addr, align 8
  %call2 = call ptr @mi_heap_try_new(ptr noundef %3, i64 noundef %4, i1 noundef zeroext false)
  store ptr %call2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %5 = load ptr, ptr %p, align 8
  store ptr %5, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load ptr, ptr %retval, align 8
  ret ptr %6
}

; Function Attrs: nounwind uwtable
define hidden noalias ptr @mi_new(i64 noundef %size) #0 {
entry:
  %size.addr = alloca i64, align 8
  store i64 %size, ptr %size.addr, align 8
  %call = call ptr @mi_prim_get_default_heap()
  %0 = load i64, ptr %size.addr, align 8
  %call1 = call noalias ptr @mi_heap_alloc_new(ptr noundef %call, i64 noundef %0)
  ret ptr %call1
}

; Function Attrs: nounwind uwtable
define hidden noalias ptr @mi_heap_alloc_new_n(ptr noundef %heap, i64 noundef %count, i64 noundef %size) #0 {
entry:
  %retval = alloca ptr, align 8
  %heap.addr = alloca ptr, align 8
  %count.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %total = alloca i64, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store i64 %count, ptr %count.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load i64, ptr %count.addr, align 8
  %1 = load i64, ptr %size.addr, align 8
  %call = call zeroext i1 @mi_count_size_overflow(i64 noundef %0, i64 noundef %1, ptr noundef %total)
  %lnot = xor i1 %call, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call2 = call zeroext i1 @mi_try_new_handler(i1 noundef zeroext false)
  store ptr null, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %2 = load ptr, ptr %heap.addr, align 8
  %3 = load i64, ptr %total, align 8
  %call3 = call noalias ptr @mi_heap_alloc_new(ptr noundef %2, i64 noundef %3)
  store ptr %call3, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %4 = load ptr, ptr %retval, align 8
  ret ptr %4
}

; Function Attrs: nounwind uwtable
define hidden noalias ptr @mi_new_n(i64 noundef %count, i64 noundef %size) #0 {
entry:
  %count.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  store i64 %count, ptr %count.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %call = call ptr @mi_prim_get_default_heap()
  %0 = load i64, ptr %size.addr, align 8
  %1 = load i64, ptr %count.addr, align 8
  %call1 = call noalias ptr @mi_heap_alloc_new_n(ptr noundef %call, i64 noundef %0, i64 noundef %1)
  ret ptr %call1
}

; Function Attrs: nounwind uwtable
define hidden noalias ptr @mi_new_nothrow(i64 noundef %size) #0 {
entry:
  %retval = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %p = alloca ptr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load i64, ptr %size.addr, align 8
  %call = call noalias ptr @mi_malloc(i64 noundef %0)
  store ptr %call, ptr %p, align 8
  %1 = load ptr, ptr %p, align 8
  %cmp = icmp eq ptr %1, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i64, ptr %size.addr, align 8
  %call2 = call ptr @mi_try_new(i64 noundef %2, i1 noundef zeroext true)
  store ptr %call2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %p, align 8
  store ptr %3, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load ptr, ptr %retval, align 8
  ret ptr %4
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_try_new(i64 noundef %size, i1 noundef zeroext %nothrow) #0 {
entry:
  %size.addr = alloca i64, align 8
  %nothrow.addr = alloca i8, align 1
  store i64 %size, ptr %size.addr, align 8
  %frombool = zext i1 %nothrow to i8
  store i8 %frombool, ptr %nothrow.addr, align 1
  %call = call ptr @mi_prim_get_default_heap()
  %0 = load i64, ptr %size.addr, align 8
  %1 = load i8, ptr %nothrow.addr, align 1
  %tobool = trunc i8 %1 to i1
  %call1 = call ptr @mi_heap_try_new(ptr noundef %call, i64 noundef %0, i1 noundef zeroext %tobool)
  ret ptr %call1
}

; Function Attrs: nounwind uwtable
define hidden noalias ptr @mi_new_aligned(i64 noundef %size, i64 noundef %alignment) #0 {
entry:
  %size.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  %p = alloca ptr, align 8
  store i64 %size, ptr %size.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  br label %do.body

do.body:                                          ; preds = %land.end, %entry
  %0 = load i64, ptr %size.addr, align 8
  %1 = load i64, ptr %alignment.addr, align 8
  %call = call noalias ptr @mi_malloc_aligned(i64 noundef %0, i64 noundef %1)
  store ptr %call, ptr %p, align 8
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %2 = load ptr, ptr %p, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %do.cond
  %call1 = call zeroext i1 @mi_try_new_handler(i1 noundef zeroext false)
  br label %land.end

land.end:                                         ; preds = %land.rhs, %do.cond
  %3 = phi i1 [ false, %do.cond ], [ %call1, %land.rhs ]
  br i1 %3, label %do.body, label %do.end, !llvm.loop !9

do.end:                                           ; preds = %land.end
  %4 = load ptr, ptr %p, align 8
  ret ptr %4
}

; Function Attrs: nounwind uwtable
define hidden noalias ptr @mi_malloc_aligned(i64 noundef %size, i64 noundef %alignment) #0 {
entry:
  %size.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  store i64 %size, ptr %size.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  %call = call ptr @mi_prim_get_default_heap()
  %0 = load i64, ptr %size.addr, align 8
  %1 = load i64, ptr %alignment.addr, align 8
  %call1 = call noalias ptr @mi_heap_malloc_aligned(ptr noundef %call, i64 noundef %0, i64 noundef %1)
  ret ptr %call1
}

; Function Attrs: nounwind uwtable
define hidden noalias ptr @mi_new_aligned_nothrow(i64 noundef %size, i64 noundef %alignment) #0 {
entry:
  %size.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  %p = alloca ptr, align 8
  store i64 %size, ptr %size.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  br label %do.body

do.body:                                          ; preds = %land.end, %entry
  %0 = load i64, ptr %size.addr, align 8
  %1 = load i64, ptr %alignment.addr, align 8
  %call = call noalias ptr @mi_malloc_aligned(i64 noundef %0, i64 noundef %1)
  store ptr %call, ptr %p, align 8
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %2 = load ptr, ptr %p, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %do.cond
  %call1 = call zeroext i1 @mi_try_new_handler(i1 noundef zeroext true)
  br label %land.end

land.end:                                         ; preds = %land.rhs, %do.cond
  %3 = phi i1 [ false, %do.cond ], [ %call1, %land.rhs ]
  br i1 %3, label %do.body, label %do.end, !llvm.loop !10

do.end:                                           ; preds = %land.end
  %4 = load ptr, ptr %p, align 8
  ret ptr %4
}

; Function Attrs: nounwind uwtable
define hidden ptr @mi_new_realloc(ptr noundef %p, i64 noundef %newsize) #0 {
entry:
  %p.addr = alloca ptr, align 8
  %newsize.addr = alloca i64, align 8
  %q = alloca ptr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %newsize, ptr %newsize.addr, align 8
  br label %do.body

do.body:                                          ; preds = %land.end, %entry
  %0 = load ptr, ptr %p.addr, align 8
  %1 = load i64, ptr %newsize.addr, align 8
  %call = call ptr @mi_realloc(ptr noundef %0, i64 noundef %1)
  store ptr %call, ptr %q, align 8
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %2 = load ptr, ptr %q, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %do.cond
  %call1 = call zeroext i1 @mi_try_new_handler(i1 noundef zeroext false)
  br label %land.end

land.end:                                         ; preds = %land.rhs, %do.cond
  %3 = phi i1 [ false, %do.cond ], [ %call1, %land.rhs ]
  br i1 %3, label %do.body, label %do.end, !llvm.loop !11

do.end:                                           ; preds = %land.end
  %4 = load ptr, ptr %q, align 8
  ret ptr %4
}

; Function Attrs: nounwind uwtable
define hidden ptr @mi_new_reallocn(ptr noundef %p, i64 noundef %newcount, i64 noundef %size) #0 {
entry:
  %retval = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %newcount.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %total = alloca i64, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %newcount, ptr %newcount.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load i64, ptr %newcount.addr, align 8
  %1 = load i64, ptr %size.addr, align 8
  %call = call zeroext i1 @mi_count_size_overflow(i64 noundef %0, i64 noundef %1, ptr noundef %total)
  %lnot = xor i1 %call, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call2 = call zeroext i1 @mi_try_new_handler(i1 noundef zeroext false)
  store ptr null, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %2 = load ptr, ptr %p.addr, align 8
  %3 = load i64, ptr %total, align 8
  %call3 = call ptr @mi_new_realloc(ptr noundef %2, i64 noundef %3)
  store ptr %call3, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %4 = load ptr, ptr %retval, align 8
  ret ptr %4
}

; Function Attrs: nounwind uwtable
define hidden noalias ptr @mi_heap_malloc_aligned_at(ptr noundef %heap, i64 noundef %size, i64 noundef %alignment, i64 noundef %offset) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  %offset.addr = alloca i64, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  store i64 %offset, ptr %offset.addr, align 8
  %0 = load ptr, ptr %heap.addr, align 8
  %1 = load i64, ptr %size.addr, align 8
  %2 = load i64, ptr %alignment.addr, align 8
  %3 = load i64, ptr %offset.addr, align 8
  %call = call ptr @mi_heap_malloc_zero_aligned_at(ptr noundef %0, i64 noundef %1, i64 noundef %2, i64 noundef %3, i1 noundef zeroext false)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_heap_malloc_zero_aligned_at(ptr noundef %heap, i64 noundef %size, i64 noundef %alignment, i64 noundef %offset, i1 noundef zeroext %zero) #0 {
entry:
  %retval = alloca ptr, align 8
  %heap.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  %offset.addr = alloca i64, align 8
  %zero.addr = alloca i8, align 1
  %align_mask = alloca i64, align 8
  %padsize = alloca i64, align 8
  %page = alloca ptr, align 8
  %is_aligned = alloca i8, align 1
  %p = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  store i64 %offset, ptr %offset.addr, align 8
  %frombool = zext i1 %zero to i8
  store i8 %frombool, ptr %zero.addr, align 1
  %0 = load i64, ptr %alignment.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %1 = load i64, ptr %alignment.addr, align 8
  %call = call zeroext i1 @_mi_is_power_of_two(i64 noundef %1)
  %lnot = xor i1 %call, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %2 = phi i1 [ true, %entry ], [ %lnot, %lor.rhs ]
  %lnot1 = xor i1 %2, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %lor.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.end
  %3 = load i64, ptr %size.addr, align 8
  %cmp3 = icmp ugt i64 %3, 9223372036854775807
  %lnot5 = xor i1 %cmp3, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv9 = sext i32 %lnot.ext8 to i64
  %tobool10 = icmp ne i64 %conv9, 0
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end12:                                         ; preds = %if.end
  %4 = load i64, ptr %alignment.addr, align 8
  %sub = sub i64 %4, 1
  store i64 %sub, ptr %align_mask, align 8
  %5 = load i64, ptr %size.addr, align 8
  %add = add i64 %5, 0
  store i64 %add, ptr %padsize, align 8
  %6 = load i64, ptr %padsize, align 8
  %cmp13 = icmp ule i64 %6, 1024
  br i1 %cmp13, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end12
  %7 = load i64, ptr %alignment.addr, align 8
  %8 = load i64, ptr %padsize, align 8
  %cmp15 = icmp ule i64 %7, %8
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end12
  %9 = phi i1 [ false, %if.end12 ], [ %cmp15, %land.rhs ]
  %lnot17 = xor i1 %9, true
  %lnot19 = xor i1 %lnot17, true
  %lnot.ext20 = zext i1 %lnot19 to i32
  %conv21 = sext i32 %lnot.ext20 to i64
  %tobool22 = icmp ne i64 %conv21, 0
  br i1 %tobool22, label %if.then23, label %if.end50

if.then23:                                        ; preds = %land.end
  %10 = load ptr, ptr %heap.addr, align 8
  %11 = load i64, ptr %padsize, align 8
  %call24 = call ptr @_mi_heap_get_free_small_page(ptr noundef %10, i64 noundef %11)
  store ptr %call24, ptr %page, align 8
  %12 = load ptr, ptr %page, align 8
  %free = getelementptr inbounds %struct.mi_page_s, ptr %12, i32 0, i32 7
  %13 = load ptr, ptr %free, align 8
  %14 = ptrtoint ptr %13 to i64
  %15 = load i64, ptr %offset.addr, align 8
  %add25 = add i64 %14, %15
  %16 = load i64, ptr %align_mask, align 8
  %and = and i64 %add25, %16
  %cmp26 = icmp eq i64 %and, 0
  %frombool28 = zext i1 %cmp26 to i8
  store i8 %frombool28, ptr %is_aligned, align 1
  %17 = load ptr, ptr %page, align 8
  %free29 = getelementptr inbounds %struct.mi_page_s, ptr %17, i32 0, i32 7
  %18 = load ptr, ptr %free29, align 8
  %cmp30 = icmp ne ptr %18, null
  br i1 %cmp30, label %land.rhs32, label %land.end35

land.rhs32:                                       ; preds = %if.then23
  %19 = load i8, ptr %is_aligned, align 1
  %tobool33 = trunc i8 %19 to i1
  br label %land.end35

land.end35:                                       ; preds = %land.rhs32, %if.then23
  %20 = phi i1 [ false, %if.then23 ], [ %tobool33, %land.rhs32 ]
  %lnot36 = xor i1 %20, true
  %lnot38 = xor i1 %lnot36, true
  %lnot.ext39 = zext i1 %lnot38 to i32
  %conv40 = sext i32 %lnot.ext39 to i64
  %tobool41 = icmp ne i64 %conv40, 0
  br i1 %tobool41, label %if.then42, label %if.end49

if.then42:                                        ; preds = %land.end35
  %21 = load ptr, ptr %heap.addr, align 8
  %22 = load ptr, ptr %page, align 8
  %23 = load i64, ptr %padsize, align 8
  %24 = load i8, ptr %zero.addr, align 1
  %tobool43 = trunc i8 %24 to i1
  %call44 = call ptr @_mi_page_malloc(ptr noundef %21, ptr noundef %22, i64 noundef %23, i1 noundef zeroext %tobool43)
  store ptr %call44, ptr %p, align 8
  %25 = load ptr, ptr %p, align 8
  %cmp45 = icmp ne ptr %25, null
  br i1 %cmp45, label %if.then47, label %if.end48

if.then47:                                        ; preds = %if.then42
  br label %if.end48

if.end48:                                         ; preds = %if.then47, %if.then42
  %26 = load ptr, ptr %p, align 8
  store ptr %26, ptr %retval, align 8
  br label %return

if.end49:                                         ; preds = %land.end35
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %land.end
  %27 = load ptr, ptr %heap.addr, align 8
  %28 = load i64, ptr %size.addr, align 8
  %29 = load i64, ptr %alignment.addr, align 8
  %30 = load i64, ptr %offset.addr, align 8
  %31 = load i8, ptr %zero.addr, align 1
  %tobool51 = trunc i8 %31 to i1
  %call52 = call ptr @mi_heap_malloc_zero_aligned_at_fallback(ptr noundef %27, i64 noundef %28, i64 noundef %29, i64 noundef %30, i1 noundef zeroext %tobool51)
  store ptr %call52, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end50, %if.end48, %if.then11, %if.then
  %32 = load ptr, ptr %retval, align 8
  ret ptr %32
}

; Function Attrs: nounwind uwtable
define hidden noalias ptr @mi_heap_malloc_aligned(ptr noundef %heap, i64 noundef %size, i64 noundef %alignment) #0 {
entry:
  %retval = alloca ptr, align 8
  %heap.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  %0 = load i64, ptr %alignment.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %1 = load i64, ptr %alignment.addr, align 8
  %call = call zeroext i1 @_mi_is_power_of_two(i64 noundef %1)
  %lnot = xor i1 %call, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %2 = phi i1 [ true, %entry ], [ %lnot, %lor.rhs ]
  %lnot1 = xor i1 %2, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %lor.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.end
  %3 = load i64, ptr %size.addr, align 8
  %call3 = call zeroext i1 @_mi_is_power_of_two(i64 noundef %3)
  br i1 %call3, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %if.end
  %4 = load i64, ptr %size.addr, align 8
  %5 = load i64, ptr %alignment.addr, align 8
  %cmp5 = icmp uge i64 %4, %5
  br i1 %cmp5, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %6 = load i64, ptr %size.addr, align 8
  %cmp7 = icmp ule i64 %6, 1024
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %if.end
  %7 = phi i1 [ false, %land.lhs.true ], [ false, %if.end ], [ %cmp7, %land.rhs ]
  %lnot9 = xor i1 %7, true
  %lnot11 = xor i1 %lnot9, true
  %lnot.ext12 = zext i1 %lnot11 to i32
  %conv13 = sext i32 %lnot.ext12 to i64
  %tobool14 = icmp ne i64 %conv13, 0
  br i1 %tobool14, label %if.then15, label %if.else

if.then15:                                        ; preds = %land.end
  %8 = load ptr, ptr %heap.addr, align 8
  %9 = load i64, ptr %size.addr, align 8
  %call16 = call noalias ptr @mi_heap_malloc_small(ptr noundef %8, i64 noundef %9)
  store ptr %call16, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %land.end
  %10 = load ptr, ptr %heap.addr, align 8
  %11 = load i64, ptr %size.addr, align 8
  %12 = load i64, ptr %alignment.addr, align 8
  %call17 = call noalias ptr @mi_heap_malloc_aligned_at(ptr noundef %10, i64 noundef %11, i64 noundef %12, i64 noundef 0)
  store ptr %call17, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then15, %if.then
  %13 = load ptr, ptr %retval, align 8
  ret ptr %13
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @_mi_is_power_of_two(i64 noundef %x) #0 {
entry:
  %x.addr = alloca i64, align 8
  store i64 %x, ptr %x.addr, align 8
  %0 = load i64, ptr %x.addr, align 8
  %1 = load i64, ptr %x.addr, align 8
  %sub = sub i64 %1, 1
  %and = and i64 %0, %sub
  %cmp = icmp eq i64 %and, 0
  ret i1 %cmp
}

; Function Attrs: nounwind uwtable
define hidden noalias ptr @mi_heap_zalloc_aligned_at(ptr noundef %heap, i64 noundef %size, i64 noundef %alignment, i64 noundef %offset) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  %offset.addr = alloca i64, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  store i64 %offset, ptr %offset.addr, align 8
  %0 = load ptr, ptr %heap.addr, align 8
  %1 = load i64, ptr %size.addr, align 8
  %2 = load i64, ptr %alignment.addr, align 8
  %3 = load i64, ptr %offset.addr, align 8
  %call = call ptr @mi_heap_malloc_zero_aligned_at(ptr noundef %0, i64 noundef %1, i64 noundef %2, i64 noundef %3, i1 noundef zeroext true)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define hidden noalias ptr @mi_heap_zalloc_aligned(ptr noundef %heap, i64 noundef %size, i64 noundef %alignment) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  %0 = load ptr, ptr %heap.addr, align 8
  %1 = load i64, ptr %size.addr, align 8
  %2 = load i64, ptr %alignment.addr, align 8
  %call = call noalias ptr @mi_heap_zalloc_aligned_at(ptr noundef %0, i64 noundef %1, i64 noundef %2, i64 noundef 0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define hidden noalias ptr @mi_heap_calloc_aligned_at(ptr noundef %heap, i64 noundef %count, i64 noundef %size, i64 noundef %alignment, i64 noundef %offset) #0 {
entry:
  %retval = alloca ptr, align 8
  %heap.addr = alloca ptr, align 8
  %count.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  %offset.addr = alloca i64, align 8
  %total = alloca i64, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store i64 %count, ptr %count.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  store i64 %offset, ptr %offset.addr, align 8
  %0 = load i64, ptr %count.addr, align 8
  %1 = load i64, ptr %size.addr, align 8
  %call = call zeroext i1 @mi_count_size_overflow(i64 noundef %0, i64 noundef %1, ptr noundef %total)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %heap.addr, align 8
  %3 = load i64, ptr %total, align 8
  %4 = load i64, ptr %alignment.addr, align 8
  %5 = load i64, ptr %offset.addr, align 8
  %call1 = call noalias ptr @mi_heap_zalloc_aligned_at(ptr noundef %2, i64 noundef %3, i64 noundef %4, i64 noundef %5)
  store ptr %call1, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load ptr, ptr %retval, align 8
  ret ptr %6
}

; Function Attrs: nounwind uwtable
define hidden noalias ptr @mi_heap_calloc_aligned(ptr noundef %heap, i64 noundef %count, i64 noundef %size, i64 noundef %alignment) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %count.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store i64 %count, ptr %count.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  %0 = load ptr, ptr %heap.addr, align 8
  %1 = load i64, ptr %count.addr, align 8
  %2 = load i64, ptr %size.addr, align 8
  %3 = load i64, ptr %alignment.addr, align 8
  %call = call noalias ptr @mi_heap_calloc_aligned_at(ptr noundef %0, i64 noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef 0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define hidden noalias ptr @mi_malloc_aligned_at(i64 noundef %size, i64 noundef %alignment, i64 noundef %offset) #0 {
entry:
  %size.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  %offset.addr = alloca i64, align 8
  store i64 %size, ptr %size.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  store i64 %offset, ptr %offset.addr, align 8
  %call = call ptr @mi_prim_get_default_heap()
  %0 = load i64, ptr %size.addr, align 8
  %1 = load i64, ptr %alignment.addr, align 8
  %2 = load i64, ptr %offset.addr, align 8
  %call1 = call noalias ptr @mi_heap_malloc_aligned_at(ptr noundef %call, i64 noundef %0, i64 noundef %1, i64 noundef %2)
  ret ptr %call1
}

; Function Attrs: nounwind uwtable
define hidden noalias ptr @mi_zalloc_aligned_at(i64 noundef %size, i64 noundef %alignment, i64 noundef %offset) #0 {
entry:
  %size.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  %offset.addr = alloca i64, align 8
  store i64 %size, ptr %size.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  store i64 %offset, ptr %offset.addr, align 8
  %call = call ptr @mi_prim_get_default_heap()
  %0 = load i64, ptr %size.addr, align 8
  %1 = load i64, ptr %alignment.addr, align 8
  %2 = load i64, ptr %offset.addr, align 8
  %call1 = call noalias ptr @mi_heap_zalloc_aligned_at(ptr noundef %call, i64 noundef %0, i64 noundef %1, i64 noundef %2)
  ret ptr %call1
}

; Function Attrs: nounwind uwtable
define hidden noalias ptr @mi_zalloc_aligned(i64 noundef %size, i64 noundef %alignment) #0 {
entry:
  %size.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  store i64 %size, ptr %size.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  %call = call ptr @mi_prim_get_default_heap()
  %0 = load i64, ptr %size.addr, align 8
  %1 = load i64, ptr %alignment.addr, align 8
  %call1 = call noalias ptr @mi_heap_zalloc_aligned(ptr noundef %call, i64 noundef %0, i64 noundef %1)
  ret ptr %call1
}

; Function Attrs: nounwind uwtable
define hidden noalias ptr @mi_calloc_aligned_at(i64 noundef %count, i64 noundef %size, i64 noundef %alignment, i64 noundef %offset) #0 {
entry:
  %count.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  %offset.addr = alloca i64, align 8
  store i64 %count, ptr %count.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  store i64 %offset, ptr %offset.addr, align 8
  %call = call ptr @mi_prim_get_default_heap()
  %0 = load i64, ptr %count.addr, align 8
  %1 = load i64, ptr %size.addr, align 8
  %2 = load i64, ptr %alignment.addr, align 8
  %3 = load i64, ptr %offset.addr, align 8
  %call1 = call noalias ptr @mi_heap_calloc_aligned_at(ptr noundef %call, i64 noundef %0, i64 noundef %1, i64 noundef %2, i64 noundef %3)
  ret ptr %call1
}

; Function Attrs: nounwind uwtable
define hidden noalias ptr @mi_calloc_aligned(i64 noundef %count, i64 noundef %size, i64 noundef %alignment) #0 {
entry:
  %count.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  store i64 %count, ptr %count.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  %call = call ptr @mi_prim_get_default_heap()
  %0 = load i64, ptr %count.addr, align 8
  %1 = load i64, ptr %size.addr, align 8
  %2 = load i64, ptr %alignment.addr, align 8
  %call1 = call noalias ptr @mi_heap_calloc_aligned(ptr noundef %call, i64 noundef %0, i64 noundef %1, i64 noundef %2)
  ret ptr %call1
}

; Function Attrs: nounwind uwtable
define hidden ptr @mi_heap_realloc_aligned_at(ptr noundef %heap, ptr noundef %p, i64 noundef %newsize, i64 noundef %alignment, i64 noundef %offset) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %newsize.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  %offset.addr = alloca i64, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %newsize, ptr %newsize.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  store i64 %offset, ptr %offset.addr, align 8
  %0 = load ptr, ptr %heap.addr, align 8
  %1 = load ptr, ptr %p.addr, align 8
  %2 = load i64, ptr %newsize.addr, align 8
  %3 = load i64, ptr %alignment.addr, align 8
  %4 = load i64, ptr %offset.addr, align 8
  %call = call ptr @mi_heap_realloc_zero_aligned_at(ptr noundef %0, ptr noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4, i1 noundef zeroext false)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_heap_realloc_zero_aligned_at(ptr noundef %heap, ptr noundef %p, i64 noundef %newsize, i64 noundef %alignment, i64 noundef %offset, i1 noundef zeroext %zero) #0 {
entry:
  %retval = alloca ptr, align 8
  %heap.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %newsize.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  %offset.addr = alloca i64, align 8
  %zero.addr = alloca i8, align 1
  %size = alloca i64, align 8
  %newp = alloca ptr, align 8
  %start = alloca i64, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %newsize, ptr %newsize.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  store i64 %offset, ptr %offset.addr, align 8
  %frombool = zext i1 %zero to i8
  store i8 %frombool, ptr %zero.addr, align 1
  %0 = load i64, ptr %alignment.addr, align 8
  %cmp = icmp ule i64 %0, 8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %heap.addr, align 8
  %2 = load ptr, ptr %p.addr, align 8
  %3 = load i64, ptr %newsize.addr, align 8
  %4 = load i8, ptr %zero.addr, align 1
  %tobool = trunc i8 %4 to i1
  %call = call ptr @_mi_heap_realloc_zero(ptr noundef %1, ptr noundef %2, i64 noundef %3, i1 noundef zeroext %tobool)
  store ptr %call, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %5 = load ptr, ptr %p.addr, align 8
  %cmp1 = icmp eq ptr %5, null
  br i1 %cmp1, label %if.then2, label %if.end5

if.then2:                                         ; preds = %if.end
  %6 = load ptr, ptr %heap.addr, align 8
  %7 = load i64, ptr %newsize.addr, align 8
  %8 = load i64, ptr %alignment.addr, align 8
  %9 = load i64, ptr %offset.addr, align 8
  %10 = load i8, ptr %zero.addr, align 1
  %tobool3 = trunc i8 %10 to i1
  %call4 = call ptr @mi_heap_malloc_zero_aligned_at(ptr noundef %6, i64 noundef %7, i64 noundef %8, i64 noundef %9, i1 noundef zeroext %tobool3)
  store ptr %call4, ptr %retval, align 8
  br label %return

if.end5:                                          ; preds = %if.end
  %11 = load ptr, ptr %p.addr, align 8
  %call6 = call i64 @mi_usable_size(ptr noundef %11)
  store i64 %call6, ptr %size, align 8
  %12 = load i64, ptr %newsize.addr, align 8
  %13 = load i64, ptr %size, align 8
  %cmp7 = icmp ule i64 %12, %13
  br i1 %cmp7, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.end5
  %14 = load i64, ptr %newsize.addr, align 8
  %15 = load i64, ptr %size, align 8
  %16 = load i64, ptr %size, align 8
  %div = udiv i64 %16, 2
  %sub = sub i64 %15, %div
  %cmp8 = icmp uge i64 %14, %sub
  br i1 %cmp8, label %land.lhs.true9, label %if.else

land.lhs.true9:                                   ; preds = %land.lhs.true
  %17 = load ptr, ptr %p.addr, align 8
  %18 = ptrtoint ptr %17 to i64
  %19 = load i64, ptr %offset.addr, align 8
  %add = add i64 %18, %19
  %20 = load i64, ptr %alignment.addr, align 8
  %rem = urem i64 %add, %20
  %cmp10 = icmp eq i64 %rem, 0
  br i1 %cmp10, label %if.then11, label %if.else

if.then11:                                        ; preds = %land.lhs.true9
  %21 = load ptr, ptr %p.addr, align 8
  store ptr %21, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %land.lhs.true9, %land.lhs.true, %if.end5
  %22 = load ptr, ptr %heap.addr, align 8
  %23 = load i64, ptr %newsize.addr, align 8
  %24 = load i64, ptr %alignment.addr, align 8
  %25 = load i64, ptr %offset.addr, align 8
  %call12 = call noalias ptr @mi_heap_malloc_aligned_at(ptr noundef %22, i64 noundef %23, i64 noundef %24, i64 noundef %25)
  store ptr %call12, ptr %newp, align 8
  %26 = load ptr, ptr %newp, align 8
  %cmp13 = icmp ne ptr %26, null
  br i1 %cmp13, label %if.then14, label %if.end28

if.then14:                                        ; preds = %if.else
  %27 = load i8, ptr %zero.addr, align 1
  %tobool15 = trunc i8 %27 to i1
  br i1 %tobool15, label %land.lhs.true16, label %if.end22

land.lhs.true16:                                  ; preds = %if.then14
  %28 = load i64, ptr %newsize.addr, align 8
  %29 = load i64, ptr %size, align 8
  %cmp17 = icmp ugt i64 %28, %29
  br i1 %cmp17, label %if.then18, label %if.end22

if.then18:                                        ; preds = %land.lhs.true16
  %30 = load i64, ptr %size, align 8
  %cmp19 = icmp uge i64 %30, 8
  br i1 %cmp19, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then18
  %31 = load i64, ptr %size, align 8
  %sub20 = sub i64 %31, 8
  br label %cond.end

cond.false:                                       ; preds = %if.then18
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %sub20, %cond.true ], [ 0, %cond.false ]
  store i64 %cond, ptr %start, align 8
  %32 = load ptr, ptr %newp, align 8
  %33 = load i64, ptr %start, align 8
  %add.ptr = getelementptr i8, ptr %32, i64 %33
  %34 = load i64, ptr %newsize.addr, align 8
  %35 = load i64, ptr %start, align 8
  %sub21 = sub i64 %34, %35
  call void @_mi_memzero(ptr noundef %add.ptr, i64 noundef %sub21)
  br label %if.end22

if.end22:                                         ; preds = %cond.end, %land.lhs.true16, %if.then14
  %36 = load ptr, ptr %newp, align 8
  %37 = load ptr, ptr %p.addr, align 8
  %38 = load i64, ptr %newsize.addr, align 8
  %39 = load i64, ptr %size, align 8
  %cmp23 = icmp ugt i64 %38, %39
  br i1 %cmp23, label %cond.true24, label %cond.false25

cond.true24:                                      ; preds = %if.end22
  %40 = load i64, ptr %size, align 8
  br label %cond.end26

cond.false25:                                     ; preds = %if.end22
  %41 = load i64, ptr %newsize.addr, align 8
  br label %cond.end26

cond.end26:                                       ; preds = %cond.false25, %cond.true24
  %cond27 = phi i64 [ %40, %cond.true24 ], [ %41, %cond.false25 ]
  call void @_mi_memcpy_aligned(ptr noundef %36, ptr noundef %37, i64 noundef %cond27)
  %42 = load ptr, ptr %p.addr, align 8
  call void @mi_free(ptr noundef %42)
  br label %if.end28

if.end28:                                         ; preds = %cond.end26, %if.else
  %43 = load ptr, ptr %newp, align 8
  store ptr %43, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end28, %if.then11, %if.then2, %if.then
  %44 = load ptr, ptr %retval, align 8
  ret ptr %44
}

; Function Attrs: nounwind uwtable
define hidden ptr @mi_heap_realloc_aligned(ptr noundef %heap, ptr noundef %p, i64 noundef %newsize, i64 noundef %alignment) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %newsize.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %newsize, ptr %newsize.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  %0 = load ptr, ptr %heap.addr, align 8
  %1 = load ptr, ptr %p.addr, align 8
  %2 = load i64, ptr %newsize.addr, align 8
  %3 = load i64, ptr %alignment.addr, align 8
  %call = call ptr @mi_heap_realloc_zero_aligned(ptr noundef %0, ptr noundef %1, i64 noundef %2, i64 noundef %3, i1 noundef zeroext false)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_heap_realloc_zero_aligned(ptr noundef %heap, ptr noundef %p, i64 noundef %newsize, i64 noundef %alignment, i1 noundef zeroext %zero) #0 {
entry:
  %retval = alloca ptr, align 8
  %heap.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %newsize.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  %zero.addr = alloca i8, align 1
  %offset = alloca i64, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %newsize, ptr %newsize.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  %frombool = zext i1 %zero to i8
  store i8 %frombool, ptr %zero.addr, align 1
  %0 = load i64, ptr %alignment.addr, align 8
  %cmp = icmp ule i64 %0, 8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %heap.addr, align 8
  %2 = load ptr, ptr %p.addr, align 8
  %3 = load i64, ptr %newsize.addr, align 8
  %4 = load i8, ptr %zero.addr, align 1
  %tobool = trunc i8 %4 to i1
  %call = call ptr @_mi_heap_realloc_zero(ptr noundef %1, ptr noundef %2, i64 noundef %3, i1 noundef zeroext %tobool)
  store ptr %call, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %5 = load ptr, ptr %p.addr, align 8
  %6 = ptrtoint ptr %5 to i64
  %7 = load i64, ptr %alignment.addr, align 8
  %rem = urem i64 %6, %7
  store i64 %rem, ptr %offset, align 8
  %8 = load ptr, ptr %heap.addr, align 8
  %9 = load ptr, ptr %p.addr, align 8
  %10 = load i64, ptr %newsize.addr, align 8
  %11 = load i64, ptr %alignment.addr, align 8
  %12 = load i64, ptr %offset, align 8
  %13 = load i8, ptr %zero.addr, align 1
  %tobool1 = trunc i8 %13 to i1
  %call2 = call ptr @mi_heap_realloc_zero_aligned_at(ptr noundef %8, ptr noundef %9, i64 noundef %10, i64 noundef %11, i64 noundef %12, i1 noundef zeroext %tobool1)
  store ptr %call2, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %14 = load ptr, ptr %retval, align 8
  ret ptr %14
}

; Function Attrs: nounwind uwtable
define hidden ptr @mi_heap_rezalloc_aligned_at(ptr noundef %heap, ptr noundef %p, i64 noundef %newsize, i64 noundef %alignment, i64 noundef %offset) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %newsize.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  %offset.addr = alloca i64, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %newsize, ptr %newsize.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  store i64 %offset, ptr %offset.addr, align 8
  %0 = load ptr, ptr %heap.addr, align 8
  %1 = load ptr, ptr %p.addr, align 8
  %2 = load i64, ptr %newsize.addr, align 8
  %3 = load i64, ptr %alignment.addr, align 8
  %4 = load i64, ptr %offset.addr, align 8
  %call = call ptr @mi_heap_realloc_zero_aligned_at(ptr noundef %0, ptr noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4, i1 noundef zeroext true)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define hidden ptr @mi_heap_rezalloc_aligned(ptr noundef %heap, ptr noundef %p, i64 noundef %newsize, i64 noundef %alignment) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %newsize.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %newsize, ptr %newsize.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  %0 = load ptr, ptr %heap.addr, align 8
  %1 = load ptr, ptr %p.addr, align 8
  %2 = load i64, ptr %newsize.addr, align 8
  %3 = load i64, ptr %alignment.addr, align 8
  %call = call ptr @mi_heap_realloc_zero_aligned(ptr noundef %0, ptr noundef %1, i64 noundef %2, i64 noundef %3, i1 noundef zeroext true)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define hidden ptr @mi_heap_recalloc_aligned_at(ptr noundef %heap, ptr noundef %p, i64 noundef %newcount, i64 noundef %size, i64 noundef %alignment, i64 noundef %offset) #0 {
entry:
  %retval = alloca ptr, align 8
  %heap.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %newcount.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  %offset.addr = alloca i64, align 8
  %total = alloca i64, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %newcount, ptr %newcount.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  store i64 %offset, ptr %offset.addr, align 8
  %0 = load i64, ptr %newcount.addr, align 8
  %1 = load i64, ptr %size.addr, align 8
  %call = call zeroext i1 @mi_count_size_overflow(i64 noundef %0, i64 noundef %1, ptr noundef %total)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %heap.addr, align 8
  %3 = load ptr, ptr %p.addr, align 8
  %4 = load i64, ptr %total, align 8
  %5 = load i64, ptr %alignment.addr, align 8
  %6 = load i64, ptr %offset.addr, align 8
  %call1 = call ptr @mi_heap_rezalloc_aligned_at(ptr noundef %2, ptr noundef %3, i64 noundef %4, i64 noundef %5, i64 noundef %6)
  store ptr %call1, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load ptr, ptr %retval, align 8
  ret ptr %7
}

; Function Attrs: nounwind uwtable
define hidden ptr @mi_heap_recalloc_aligned(ptr noundef %heap, ptr noundef %p, i64 noundef %newcount, i64 noundef %size, i64 noundef %alignment) #0 {
entry:
  %retval = alloca ptr, align 8
  %heap.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %newcount.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  %total = alloca i64, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %newcount, ptr %newcount.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  %0 = load i64, ptr %newcount.addr, align 8
  %1 = load i64, ptr %size.addr, align 8
  %call = call zeroext i1 @mi_count_size_overflow(i64 noundef %0, i64 noundef %1, ptr noundef %total)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %heap.addr, align 8
  %3 = load ptr, ptr %p.addr, align 8
  %4 = load i64, ptr %total, align 8
  %5 = load i64, ptr %alignment.addr, align 8
  %call1 = call ptr @mi_heap_rezalloc_aligned(ptr noundef %2, ptr noundef %3, i64 noundef %4, i64 noundef %5)
  store ptr %call1, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load ptr, ptr %retval, align 8
  ret ptr %6
}

; Function Attrs: nounwind uwtable
define hidden ptr @mi_realloc_aligned_at(ptr noundef %p, i64 noundef %newsize, i64 noundef %alignment, i64 noundef %offset) #0 {
entry:
  %p.addr = alloca ptr, align 8
  %newsize.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  %offset.addr = alloca i64, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %newsize, ptr %newsize.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  store i64 %offset, ptr %offset.addr, align 8
  %call = call ptr @mi_prim_get_default_heap()
  %0 = load ptr, ptr %p.addr, align 8
  %1 = load i64, ptr %newsize.addr, align 8
  %2 = load i64, ptr %alignment.addr, align 8
  %3 = load i64, ptr %offset.addr, align 8
  %call1 = call ptr @mi_heap_realloc_aligned_at(ptr noundef %call, ptr noundef %0, i64 noundef %1, i64 noundef %2, i64 noundef %3)
  ret ptr %call1
}

; Function Attrs: nounwind uwtable
define hidden ptr @mi_realloc_aligned(ptr noundef %p, i64 noundef %newsize, i64 noundef %alignment) #0 {
entry:
  %p.addr = alloca ptr, align 8
  %newsize.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %newsize, ptr %newsize.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  %call = call ptr @mi_prim_get_default_heap()
  %0 = load ptr, ptr %p.addr, align 8
  %1 = load i64, ptr %newsize.addr, align 8
  %2 = load i64, ptr %alignment.addr, align 8
  %call1 = call ptr @mi_heap_realloc_aligned(ptr noundef %call, ptr noundef %0, i64 noundef %1, i64 noundef %2)
  ret ptr %call1
}

; Function Attrs: nounwind uwtable
define hidden ptr @mi_rezalloc_aligned_at(ptr noundef %p, i64 noundef %newsize, i64 noundef %alignment, i64 noundef %offset) #0 {
entry:
  %p.addr = alloca ptr, align 8
  %newsize.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  %offset.addr = alloca i64, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %newsize, ptr %newsize.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  store i64 %offset, ptr %offset.addr, align 8
  %call = call ptr @mi_prim_get_default_heap()
  %0 = load ptr, ptr %p.addr, align 8
  %1 = load i64, ptr %newsize.addr, align 8
  %2 = load i64, ptr %alignment.addr, align 8
  %3 = load i64, ptr %offset.addr, align 8
  %call1 = call ptr @mi_heap_rezalloc_aligned_at(ptr noundef %call, ptr noundef %0, i64 noundef %1, i64 noundef %2, i64 noundef %3)
  ret ptr %call1
}

; Function Attrs: nounwind uwtable
define hidden ptr @mi_rezalloc_aligned(ptr noundef %p, i64 noundef %newsize, i64 noundef %alignment) #0 {
entry:
  %p.addr = alloca ptr, align 8
  %newsize.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %newsize, ptr %newsize.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  %call = call ptr @mi_prim_get_default_heap()
  %0 = load ptr, ptr %p.addr, align 8
  %1 = load i64, ptr %newsize.addr, align 8
  %2 = load i64, ptr %alignment.addr, align 8
  %call1 = call ptr @mi_heap_rezalloc_aligned(ptr noundef %call, ptr noundef %0, i64 noundef %1, i64 noundef %2)
  ret ptr %call1
}

; Function Attrs: nounwind uwtable
define hidden ptr @mi_recalloc_aligned_at(ptr noundef %p, i64 noundef %newcount, i64 noundef %size, i64 noundef %alignment, i64 noundef %offset) #0 {
entry:
  %p.addr = alloca ptr, align 8
  %newcount.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  %offset.addr = alloca i64, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %newcount, ptr %newcount.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  store i64 %offset, ptr %offset.addr, align 8
  %call = call ptr @mi_prim_get_default_heap()
  %0 = load ptr, ptr %p.addr, align 8
  %1 = load i64, ptr %newcount.addr, align 8
  %2 = load i64, ptr %size.addr, align 8
  %3 = load i64, ptr %alignment.addr, align 8
  %4 = load i64, ptr %offset.addr, align 8
  %call1 = call ptr @mi_heap_recalloc_aligned_at(ptr noundef %call, ptr noundef %0, i64 noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4)
  ret ptr %call1
}

; Function Attrs: nounwind uwtable
define hidden ptr @mi_recalloc_aligned(ptr noundef %p, i64 noundef %newcount, i64 noundef %size, i64 noundef %alignment) #0 {
entry:
  %p.addr = alloca ptr, align 8
  %newcount.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %newcount, ptr %newcount.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  %call = call ptr @mi_prim_get_default_heap()
  %0 = load ptr, ptr %p.addr, align 8
  %1 = load i64, ptr %newcount.addr, align 8
  %2 = load i64, ptr %size.addr, align 8
  %3 = load i64, ptr %alignment.addr, align 8
  %call1 = call ptr @mi_heap_recalloc_aligned(ptr noundef %call, ptr noundef %0, i64 noundef %1, i64 noundef %2, i64 noundef %3)
  ret ptr %call1
}

; Function Attrs: nounwind uwtable
define hidden i64 @mi_malloc_size(ptr noundef %p) #0 {
entry:
  %p.addr = alloca ptr, align 8
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %call = call i64 @mi_usable_size(ptr noundef %0)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define hidden i64 @mi_malloc_usable_size(ptr noundef %p) #0 {
entry:
  %p.addr = alloca ptr, align 8
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %call = call i64 @mi_usable_size(ptr noundef %0)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define hidden i64 @mi_malloc_good_size(i64 noundef %size) #0 {
entry:
  %size.addr = alloca i64, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load i64, ptr %size.addr, align 8
  %call = call i64 @mi_good_size(i64 noundef %0)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define hidden i64 @mi_good_size(i64 noundef %size) #0 {
entry:
  %retval = alloca i64, align 8
  %size.addr = alloca i64, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load i64, ptr %size.addr, align 8
  %cmp = icmp ule i64 %0, 131072
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i64, ptr %size.addr, align 8
  %call = call zeroext i8 @mi_bin(i64 noundef %1)
  %call1 = call i64 @_mi_bin_size(i8 noundef zeroext %call)
  store i64 %call1, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %2 = load i64, ptr %size.addr, align 8
  %call2 = call i64 @_mi_os_page_size()
  %call3 = call i64 @_mi_align_up(i64 noundef %2, i64 noundef %call2)
  store i64 %call3, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %3 = load i64, ptr %retval, align 8
  ret i64 %3
}

; Function Attrs: nounwind uwtable
define hidden void @mi_cfree(ptr noundef %p) #0 {
entry:
  %p.addr = alloca ptr, align 8
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %call = call zeroext i1 @mi_is_in_heap_region(ptr noundef %0)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %p.addr, align 8
  call void @mi_free(ptr noundef %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define hidden zeroext i1 @mi_is_in_heap_region(ptr noundef %p) #0 {
entry:
  %p.addr = alloca ptr, align 8
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %call = call zeroext i1 @mi_is_valid_pointer(ptr noundef %0)
  ret i1 %call
}

; Function Attrs: nounwind uwtable
define hidden i32 @mi_posix_memalign(ptr noundef %p, i64 noundef %alignment, i64 noundef %size) #0 {
entry:
  %retval = alloca i32, align 4
  %p.addr = alloca ptr, align 8
  %alignment.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %q = alloca ptr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 22, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, ptr %alignment.addr, align 8
  %rem = urem i64 %1, 8
  %cmp1 = icmp ne i64 %rem, 0
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i32 22, ptr %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  %2 = load i64, ptr %alignment.addr, align 8
  %cmp4 = icmp eq i64 %2, 0
  br i1 %cmp4, label %if.then5, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end3
  %3 = load i64, ptr %alignment.addr, align 8
  %call = call zeroext i1 @_mi_is_power_of_two(i64 noundef %3)
  br i1 %call, label %if.end6, label %if.then5

if.then5:                                         ; preds = %lor.lhs.false, %if.end3
  store i32 22, ptr %retval, align 4
  br label %return

if.end6:                                          ; preds = %lor.lhs.false
  %4 = load i64, ptr %size.addr, align 8
  %5 = load i64, ptr %alignment.addr, align 8
  %call7 = call noalias ptr @mi_malloc_aligned(i64 noundef %4, i64 noundef %5)
  store ptr %call7, ptr %q, align 8
  %6 = load ptr, ptr %q, align 8
  %cmp8 = icmp eq ptr %6, null
  br i1 %cmp8, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %if.end6
  %7 = load i64, ptr %size.addr, align 8
  %cmp9 = icmp ne i64 %7, 0
  br i1 %cmp9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %land.lhs.true
  store i32 12, ptr %retval, align 4
  br label %return

if.end11:                                         ; preds = %land.lhs.true, %if.end6
  %8 = load ptr, ptr %q, align 8
  %9 = load ptr, ptr %p.addr, align 8
  store ptr %8, ptr %9, align 8
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end11, %if.then10, %if.then5, %if.then2, %if.then
  %10 = load i32, ptr %retval, align 4
  ret i32 %10
}

; Function Attrs: nounwind uwtable
define hidden noalias ptr @mi_memalign(i64 noundef %alignment, i64 noundef %size) #0 {
entry:
  %alignment.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %p = alloca ptr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load i64, ptr %size.addr, align 8
  %1 = load i64, ptr %alignment.addr, align 8
  %call = call noalias ptr @mi_malloc_aligned(i64 noundef %0, i64 noundef %1)
  store ptr %call, ptr %p, align 8
  %2 = load ptr, ptr %p, align 8
  ret ptr %2
}

; Function Attrs: nounwind uwtable
define hidden noalias ptr @mi_valloc(i64 noundef %size) #0 {
entry:
  %size.addr = alloca i64, align 8
  store i64 %size, ptr %size.addr, align 8
  %call = call i64 @_mi_os_page_size()
  %0 = load i64, ptr %size.addr, align 8
  %call1 = call noalias ptr @mi_memalign(i64 noundef %call, i64 noundef %0)
  ret ptr %call1
}

; Function Attrs: nounwind uwtable
define hidden i64 @_mi_os_page_size() #0 {
entry:
  %0 = load i64, ptr @mi_os_mem_config, align 8
  ret i64 %0
}

; Function Attrs: nounwind uwtable
define hidden noalias ptr @mi_pvalloc(i64 noundef %size) #0 {
entry:
  %retval = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %psize = alloca i64, align 8
  %asize = alloca i64, align 8
  store i64 %size, ptr %size.addr, align 8
  %call = call i64 @_mi_os_page_size()
  store i64 %call, ptr %psize, align 8
  %0 = load i64, ptr %size.addr, align 8
  %1 = load i64, ptr %psize, align 8
  %sub = sub i64 -1, %1
  %cmp = icmp uge i64 %0, %sub
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i64, ptr %size.addr, align 8
  %3 = load i64, ptr %psize, align 8
  %call1 = call i64 @_mi_align_up(i64 noundef %2, i64 noundef %3)
  store i64 %call1, ptr %asize, align 8
  %4 = load i64, ptr %asize, align 8
  %5 = load i64, ptr %psize, align 8
  %call2 = call noalias ptr @mi_malloc_aligned(i64 noundef %4, i64 noundef %5)
  store ptr %call2, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load ptr, ptr %retval, align 8
  ret ptr %6
}

; Function Attrs: nounwind uwtable
define internal i64 @_mi_align_up(i64 noundef %sz, i64 noundef %alignment) #0 {
entry:
  %retval = alloca i64, align 8
  %sz.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  %mask = alloca i64, align 8
  store i64 %sz, ptr %sz.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  %0 = load i64, ptr %alignment.addr, align 8
  %sub = sub i64 %0, 1
  store i64 %sub, ptr %mask, align 8
  %1 = load i64, ptr %alignment.addr, align 8
  %2 = load i64, ptr %mask, align 8
  %and = and i64 %1, %2
  %cmp = icmp eq i64 %and, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load i64, ptr %sz.addr, align 8
  %4 = load i64, ptr %mask, align 8
  %add = add i64 %3, %4
  %5 = load i64, ptr %mask, align 8
  %not = xor i64 %5, -1
  %and1 = and i64 %add, %not
  store i64 %and1, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %6 = load i64, ptr %sz.addr, align 8
  %7 = load i64, ptr %mask, align 8
  %add2 = add i64 %6, %7
  %8 = load i64, ptr %alignment.addr, align 8
  %div = udiv i64 %add2, %8
  %9 = load i64, ptr %alignment.addr, align 8
  %mul = mul i64 %div, %9
  store i64 %mul, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %10 = load i64, ptr %retval, align 8
  ret i64 %10
}

; Function Attrs: nounwind uwtable
define hidden noalias ptr @mi_aligned_alloc(i64 noundef %alignment, i64 noundef %size) #0 {
entry:
  %alignment.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %p = alloca ptr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load i64, ptr %size.addr, align 8
  %1 = load i64, ptr %alignment.addr, align 8
  %call = call noalias ptr @mi_malloc_aligned(i64 noundef %0, i64 noundef %1)
  store ptr %call, ptr %p, align 8
  %2 = load ptr, ptr %p, align 8
  ret ptr %2
}

; Function Attrs: nounwind uwtable
define hidden ptr @mi_reallocarray(ptr noundef %p, i64 noundef %count, i64 noundef %size) #0 {
entry:
  %p.addr = alloca ptr, align 8
  %count.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %newp = alloca ptr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %count, ptr %count.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %1 = load i64, ptr %count.addr, align 8
  %2 = load i64, ptr %size.addr, align 8
  %call = call ptr @mi_reallocn(ptr noundef %0, i64 noundef %1, i64 noundef %2)
  store ptr %call, ptr %newp, align 8
  %3 = load ptr, ptr %newp, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call ptr @__errno_location() #18
  store i32 12, ptr %call1, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load ptr, ptr %newp, align 8
  ret ptr %4
}

; Function Attrs: nounwind willreturn memory(none)
declare ptr @__errno_location() #3

; Function Attrs: nounwind uwtable
define hidden i32 @mi_reallocarr(ptr noundef %p, i64 noundef %count, i64 noundef %size) #0 {
entry:
  %retval = alloca i32, align 4
  %p.addr = alloca ptr, align 8
  %count.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %op = alloca ptr, align 8
  %newp = alloca ptr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %count, ptr %count.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call ptr @__errno_location() #18
  store i32 22, ptr %call, align 4
  store i32 22, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %p.addr, align 8
  store ptr %1, ptr %op, align 8
  %2 = load ptr, ptr %op, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = load i64, ptr %count.addr, align 8
  %5 = load i64, ptr %size.addr, align 8
  %call1 = call ptr @mi_reallocarray(ptr noundef %3, i64 noundef %4, i64 noundef %5)
  store ptr %call1, ptr %newp, align 8
  %6 = load ptr, ptr %newp, align 8
  %cmp2 = icmp eq ptr %6, null
  %lnot = xor i1 %cmp2, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call ptr @__errno_location() #18
  %7 = load i32, ptr %call5, align 4
  store i32 %7, ptr %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.end
  %8 = load ptr, ptr %newp, align 8
  %9 = load ptr, ptr %op, align 8
  store ptr %8, ptr %9, align 8
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end6, %if.then4, %if.then
  %10 = load i32, ptr %retval, align 4
  ret i32 %10
}

; Function Attrs: nounwind uwtable
define hidden ptr @mi__expand(ptr noundef %p, i64 noundef %newsize) #0 {
entry:
  %p.addr = alloca ptr, align 8
  %newsize.addr = alloca i64, align 8
  %res = alloca ptr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %newsize, ptr %newsize.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %1 = load i64, ptr %newsize.addr, align 8
  %call = call ptr @mi_expand(ptr noundef %0, i64 noundef %1)
  store ptr %call, ptr %res, align 8
  %2 = load ptr, ptr %res, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call ptr @__errno_location() #18
  store i32 12, ptr %call1, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load ptr, ptr %res, align 8
  ret ptr %3
}

; Function Attrs: nounwind uwtable
define hidden noalias ptr @mi_wcsdup(ptr noundef %s) #0 {
entry:
  %retval = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %len = alloca i64, align 8
  %size = alloca i64, align 8
  %p = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store i64 0, ptr %len, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %1 = load ptr, ptr %s.addr, align 8
  %2 = load i64, ptr %len, align 8
  %arrayidx = getelementptr i16, ptr %1, i64 %2
  %3 = load i16, ptr %arrayidx, align 2
  %conv = zext i16 %3 to i32
  %cmp1 = icmp ne i32 %conv, 0
  br i1 %cmp1, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %4 = load i64, ptr %len, align 8
  %inc = add i64 %4, 1
  store i64 %inc, ptr %len, align 8
  br label %for.cond, !llvm.loop !12

for.end:                                          ; preds = %for.cond
  %5 = load i64, ptr %len, align 8
  %add = add i64 %5, 1
  %mul = mul i64 %add, 2
  store i64 %mul, ptr %size, align 8
  %6 = load i64, ptr %size, align 8
  %call = call noalias ptr @mi_malloc(i64 noundef %6)
  store ptr %call, ptr %p, align 8
  %7 = load ptr, ptr %p, align 8
  %cmp3 = icmp ne ptr %7, null
  br i1 %cmp3, label %if.then5, label %if.end6

if.then5:                                         ; preds = %for.end
  %8 = load ptr, ptr %p, align 8
  %9 = load ptr, ptr %s.addr, align 8
  %10 = load i64, ptr %size, align 8
  call void @_mi_memcpy(ptr noundef %8, ptr noundef %9, i64 noundef %10)
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %for.end
  %11 = load ptr, ptr %p, align 8
  store ptr %11, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end6, %if.then
  %12 = load ptr, ptr %retval, align 8
  ret ptr %12
}

; Function Attrs: nounwind uwtable
define hidden noalias ptr @mi_mbsdup(ptr noundef %s) #0 {
entry:
  %s.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %call = call noalias ptr @mi_strdup(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define hidden i32 @mi_dupenv_s(ptr noundef %buf, ptr noundef %size, ptr noundef %name) #0 {
entry:
  %retval = alloca i32, align 4
  %buf.addr = alloca ptr, align 8
  %size.addr = alloca ptr, align 8
  %name.addr = alloca ptr, align 8
  %p = alloca ptr, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store ptr %size, ptr %size.addr, align 8
  store ptr %name, ptr %name.addr, align 8
  %0 = load ptr, ptr %buf.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %name.addr, align 8
  %cmp1 = icmp eq ptr %1, null
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 22, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %2 = load ptr, ptr %size.addr, align 8
  %cmp2 = icmp ne ptr %2, null
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %3 = load ptr, ptr %size.addr, align 8
  store i64 0, ptr %3, align 8
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end
  %4 = load ptr, ptr %name.addr, align 8
  %call = call ptr @getenv(ptr noundef %4) #15
  store ptr %call, ptr %p, align 8
  %5 = load ptr, ptr %p, align 8
  %cmp5 = icmp eq ptr %5, null
  br i1 %cmp5, label %if.then6, label %if.else

if.then6:                                         ; preds = %if.end4
  %6 = load ptr, ptr %buf.addr, align 8
  store ptr null, ptr %6, align 8
  br label %if.end15

if.else:                                          ; preds = %if.end4
  %7 = load ptr, ptr %p, align 8
  %call7 = call noalias ptr @mi_strdup(ptr noundef %7)
  %8 = load ptr, ptr %buf.addr, align 8
  store ptr %call7, ptr %8, align 8
  %9 = load ptr, ptr %buf.addr, align 8
  %10 = load ptr, ptr %9, align 8
  %cmp8 = icmp eq ptr %10, null
  br i1 %cmp8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.else
  store i32 12, ptr %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.else
  %11 = load ptr, ptr %size.addr, align 8
  %cmp11 = icmp ne ptr %11, null
  br i1 %cmp11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %if.end10
  %12 = load ptr, ptr %p, align 8
  %call13 = call i64 @_mi_strlen(ptr noundef %12)
  %13 = load ptr, ptr %size.addr, align 8
  store i64 %call13, ptr %13, align 8
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %if.end10
  br label %if.end15

if.end15:                                         ; preds = %if.end14, %if.then6
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end15, %if.then9, %if.then
  %14 = load i32, ptr %retval, align 4
  ret i32 %14
}

; Function Attrs: nounwind
declare ptr @getenv(ptr noundef) #2

; Function Attrs: nounwind uwtable
define hidden i64 @_mi_strlen(ptr noundef %s) #0 {
entry:
  %retval = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  %len = alloca i64, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 0, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store i64 0, ptr %len, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end
  %1 = load ptr, ptr %s.addr, align 8
  %2 = load i64, ptr %len, align 8
  %arrayidx = getelementptr i8, ptr %1, i64 %2
  %3 = load i8, ptr %arrayidx, align 1
  %conv = sext i8 %3 to i32
  %cmp1 = icmp ne i32 %conv, 0
  br i1 %cmp1, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %4 = load i64, ptr %len, align 8
  %inc = add i64 %4, 1
  store i64 %inc, ptr %len, align 8
  br label %while.cond, !llvm.loop !13

while.end:                                        ; preds = %while.cond
  %5 = load i64, ptr %len, align 8
  store i64 %5, ptr %retval, align 8
  br label %return

return:                                           ; preds = %while.end, %if.then
  %6 = load i64, ptr %retval, align 8
  ret i64 %6
}

; Function Attrs: nounwind uwtable
define hidden i32 @mi_wdupenv_s(ptr noundef %buf, ptr noundef %size, ptr noundef %name) #0 {
entry:
  %retval = alloca i32, align 4
  %buf.addr = alloca ptr, align 8
  %size.addr = alloca ptr, align 8
  %name.addr = alloca ptr, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store ptr %size, ptr %size.addr, align 8
  store ptr %name, ptr %name.addr, align 8
  %0 = load ptr, ptr %buf.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %name.addr, align 8
  %cmp1 = icmp eq ptr %1, null
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 22, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %2 = load ptr, ptr %size.addr, align 8
  %cmp2 = icmp ne ptr %2, null
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %3 = load ptr, ptr %size.addr, align 8
  store i64 0, ptr %3, align 8
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end
  %4 = load ptr, ptr %buf.addr, align 8
  store ptr null, ptr %4, align 8
  store i32 22, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end4, %if.then
  %5 = load i32, ptr %retval, align 4
  ret i32 %5
}

; Function Attrs: nounwind uwtable
define hidden ptr @mi_aligned_offset_recalloc(ptr noundef %p, i64 noundef %newcount, i64 noundef %size, i64 noundef %alignment, i64 noundef %offset) #0 {
entry:
  %p.addr = alloca ptr, align 8
  %newcount.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  %offset.addr = alloca i64, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %newcount, ptr %newcount.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  store i64 %offset, ptr %offset.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %1 = load i64, ptr %newcount.addr, align 8
  %2 = load i64, ptr %size.addr, align 8
  %3 = load i64, ptr %alignment.addr, align 8
  %4 = load i64, ptr %offset.addr, align 8
  %call = call ptr @mi_recalloc_aligned_at(ptr noundef %0, i64 noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define hidden ptr @mi_aligned_recalloc(ptr noundef %p, i64 noundef %newcount, i64 noundef %size, i64 noundef %alignment) #0 {
entry:
  %p.addr = alloca ptr, align 8
  %newcount.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %newcount, ptr %newcount.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %1 = load i64, ptr %newcount.addr, align 8
  %2 = load i64, ptr %size.addr, align 8
  %3 = load i64, ptr %alignment.addr, align 8
  %call = call ptr @mi_recalloc_aligned(ptr noundef %0, i64 noundef %1, i64 noundef %2, i64 noundef %3)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define hidden i32 @_mi_arena_id_none() #0 {
entry:
  ret i32 0
}

; Function Attrs: nounwind uwtable
define hidden zeroext i1 @_mi_arena_memid_is_suitable(ptr noundef byval(%struct.mi_memid_s) align 8 %memid, i32 noundef %request_arena_id) #0 {
entry:
  %retval = alloca i1, align 1
  %request_arena_id.addr = alloca i32, align 4
  store i32 %request_arena_id, ptr %request_arena_id.addr, align 4
  %memkind = getelementptr inbounds %struct.mi_memid_s, ptr %memid, i32 0, i32 4
  %0 = load i32, ptr %memkind, align 4
  %cmp = icmp eq i32 %0, 6
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %mem = getelementptr inbounds %struct.mi_memid_s, ptr %memid, i32 0, i32 0
  %id = getelementptr inbounds %struct.mi_memid_arena_info, ptr %mem, i32 0, i32 1
  %1 = load i32, ptr %id, align 8
  %mem1 = getelementptr inbounds %struct.mi_memid_s, ptr %memid, i32 0, i32 0
  %is_exclusive = getelementptr inbounds %struct.mi_memid_arena_info, ptr %mem1, i32 0, i32 2
  %2 = load i8, ptr %is_exclusive, align 4
  %tobool = trunc i8 %2 to i1
  %3 = load i32, ptr %request_arena_id.addr, align 4
  %call = call zeroext i1 @mi_arena_id_is_suitable(i32 noundef %1, i1 noundef zeroext %tobool, i32 noundef %3)
  store i1 %call, ptr %retval, align 1
  br label %return

if.else:                                          ; preds = %entry
  %4 = load i32, ptr %request_arena_id.addr, align 4
  %call2 = call zeroext i1 @mi_arena_id_is_suitable(i32 noundef 0, i1 noundef zeroext false, i32 noundef %4)
  store i1 %call2, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.else, %if.then
  %5 = load i1, ptr %retval, align 1
  ret i1 %5
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_arena_id_is_suitable(i32 noundef %arena_id, i1 noundef zeroext %arena_is_exclusive, i32 noundef %req_arena_id) #0 {
entry:
  %arena_id.addr = alloca i32, align 4
  %arena_is_exclusive.addr = alloca i8, align 1
  %req_arena_id.addr = alloca i32, align 4
  store i32 %arena_id, ptr %arena_id.addr, align 4
  %frombool = zext i1 %arena_is_exclusive to i8
  store i8 %frombool, ptr %arena_is_exclusive.addr, align 1
  store i32 %req_arena_id, ptr %req_arena_id.addr, align 4
  %0 = load i8, ptr %arena_is_exclusive.addr, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %lor.rhs, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %1 = load i32, ptr %req_arena_id.addr, align 4
  %call = call i32 @_mi_arena_id_none()
  %cmp = icmp eq i32 %1, %call
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.lhs.true, %entry
  %2 = load i32, ptr %arena_id.addr, align 4
  %3 = load i32, ptr %req_arena_id.addr, align 4
  %cmp1 = icmp eq i32 %2, %3
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.lhs.true
  %4 = phi i1 [ true, %land.lhs.true ], [ %cmp1, %lor.rhs ]
  ret i1 %4
}

; Function Attrs: nounwind uwtable
define hidden zeroext i1 @_mi_arena_memid_is_os_allocated(ptr noundef byval(%struct.mi_memid_s) align 8 %memid) #0 {
entry:
  %memkind = getelementptr inbounds %struct.mi_memid_s, ptr %memid, i32 0, i32 4
  %0 = load i32, ptr %memkind, align 4
  %cmp = icmp eq i32 %0, 3
  ret i1 %cmp
}

; Function Attrs: nounwind uwtable
define hidden ptr @_mi_arena_alloc_aligned(i64 noundef %size, i64 noundef %alignment, i64 noundef %align_offset, i1 noundef zeroext %commit, i1 noundef zeroext %allow_large, i32 noundef %req_arena_id, ptr noundef %memid, ptr noundef %tld) #0 {
entry:
  %retval = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  %align_offset.addr = alloca i64, align 8
  %commit.addr = alloca i8, align 1
  %allow_large.addr = alloca i8, align 1
  %req_arena_id.addr = alloca i32, align 4
  %memid.addr = alloca ptr, align 8
  %tld.addr = alloca ptr, align 8
  %tmp = alloca %struct.mi_memid_s, align 8
  %numa_node = alloca i32, align 4
  %p = alloca ptr, align 8
  %arena_id = alloca i32, align 4
  store i64 %size, ptr %size.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  store i64 %align_offset, ptr %align_offset.addr, align 8
  %frombool = zext i1 %commit to i8
  store i8 %frombool, ptr %commit.addr, align 1
  %frombool1 = zext i1 %allow_large to i8
  store i8 %frombool1, ptr %allow_large.addr, align 1
  store i32 %req_arena_id, ptr %req_arena_id.addr, align 4
  store ptr %memid, ptr %memid.addr, align 8
  store ptr %tld, ptr %tld.addr, align 8
  %0 = load ptr, ptr %memid.addr, align 8
  call void @_mi_memid_none(ptr sret(%struct.mi_memid_s) align 8 %tmp)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %0, ptr align 8 %tmp, i64 24, i1 false)
  %1 = load ptr, ptr %tld.addr, align 8
  %call = call i32 @_mi_os_numa_node(ptr noundef %1)
  store i32 %call, ptr %numa_node, align 4
  %2 = load i64, ptr %size.addr, align 8
  %cmp = icmp uge i64 %2, 16777216
  br i1 %cmp, label %land.lhs.true, label %if.end23

land.lhs.true:                                    ; preds = %entry
  %3 = load i64, ptr %alignment.addr, align 8
  %cmp2 = icmp ule i64 %3, 33554432
  br i1 %cmp2, label %land.lhs.true3, label %if.end23

land.lhs.true3:                                   ; preds = %land.lhs.true
  %4 = load i64, ptr %align_offset.addr, align 8
  %cmp4 = icmp eq i64 %4, 0
  br i1 %cmp4, label %if.then, label %if.end23

if.then:                                          ; preds = %land.lhs.true3
  %5 = load i32, ptr %numa_node, align 4
  %6 = load i64, ptr %size.addr, align 8
  %7 = load i64, ptr %alignment.addr, align 8
  %8 = load i8, ptr %commit.addr, align 1
  %tobool = trunc i8 %8 to i1
  %9 = load i8, ptr %allow_large.addr, align 1
  %tobool5 = trunc i8 %9 to i1
  %10 = load i32, ptr %req_arena_id.addr, align 4
  %11 = load ptr, ptr %memid.addr, align 8
  %12 = load ptr, ptr %tld.addr, align 8
  %call6 = call ptr @mi_arena_try_alloc(i32 noundef %5, i64 noundef %6, i64 noundef %7, i1 noundef zeroext %tobool, i1 noundef zeroext %tobool5, i32 noundef %10, ptr noundef %11, ptr noundef %12)
  store ptr %call6, ptr %p, align 8
  %13 = load ptr, ptr %p, align 8
  %cmp7 = icmp ne ptr %13, null
  br i1 %cmp7, label %if.then8, label %if.end

if.then8:                                         ; preds = %if.then
  %14 = load ptr, ptr %p, align 8
  store ptr %14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %if.then
  %15 = load i32, ptr %req_arena_id.addr, align 4
  %call9 = call i32 @_mi_arena_id_none()
  %cmp10 = icmp eq i32 %15, %call9
  br i1 %cmp10, label %if.then11, label %if.end22

if.then11:                                        ; preds = %if.end
  store i32 0, ptr %arena_id, align 4
  %16 = load i64, ptr %size.addr, align 8
  %17 = load i8, ptr %allow_large.addr, align 1
  %tobool12 = trunc i8 %17 to i1
  %18 = load i32, ptr %req_arena_id.addr, align 4
  %call13 = call zeroext i1 @mi_arena_reserve(i64 noundef %16, i1 noundef zeroext %tobool12, i32 noundef %18, ptr noundef %arena_id)
  br i1 %call13, label %if.then14, label %if.end21

if.then14:                                        ; preds = %if.then11
  %19 = load i32, ptr %arena_id, align 4
  %20 = load i32, ptr %numa_node, align 4
  %21 = load i64, ptr %size.addr, align 8
  %22 = load i64, ptr %alignment.addr, align 8
  %23 = load i8, ptr %commit.addr, align 1
  %tobool15 = trunc i8 %23 to i1
  %24 = load i8, ptr %allow_large.addr, align 1
  %tobool16 = trunc i8 %24 to i1
  %25 = load i32, ptr %req_arena_id.addr, align 4
  %26 = load ptr, ptr %memid.addr, align 8
  %27 = load ptr, ptr %tld.addr, align 8
  %call17 = call ptr @mi_arena_try_alloc_at_id(i32 noundef %19, i1 noundef zeroext true, i32 noundef %20, i64 noundef %21, i64 noundef %22, i1 noundef zeroext %tobool15, i1 noundef zeroext %tobool16, i32 noundef %25, ptr noundef %26, ptr noundef %27)
  store ptr %call17, ptr %p, align 8
  %28 = load ptr, ptr %p, align 8
  %cmp18 = icmp ne ptr %28, null
  br i1 %cmp18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %if.then14
  %29 = load ptr, ptr %p, align 8
  store ptr %29, ptr %retval, align 8
  br label %return

if.end20:                                         ; preds = %if.then14
  br label %if.end21

if.end21:                                         ; preds = %if.end20, %if.then11
  br label %if.end22

if.end22:                                         ; preds = %if.end21, %if.end
  br label %if.end23

if.end23:                                         ; preds = %if.end22, %land.lhs.true3, %land.lhs.true, %entry
  %call24 = call zeroext i1 @mi_option_is_enabled(i32 noundef 17)
  br i1 %call24, label %if.then27, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end23
  %30 = load i32, ptr %req_arena_id.addr, align 4
  %call25 = call i32 @_mi_arena_id_none()
  %cmp26 = icmp ne i32 %30, %call25
  br i1 %cmp26, label %if.then27, label %if.end29

if.then27:                                        ; preds = %lor.lhs.false, %if.end23
  %call28 = call ptr @__errno_location() #18
  store i32 12, ptr %call28, align 4
  store ptr null, ptr %retval, align 8
  br label %return

if.end29:                                         ; preds = %lor.lhs.false
  %31 = load i64, ptr %align_offset.addr, align 8
  %cmp30 = icmp ugt i64 %31, 0
  br i1 %cmp30, label %if.then31, label %if.else

if.then31:                                        ; preds = %if.end29
  %32 = load i64, ptr %size.addr, align 8
  %33 = load i64, ptr %alignment.addr, align 8
  %34 = load i64, ptr %align_offset.addr, align 8
  %35 = load i8, ptr %commit.addr, align 1
  %tobool32 = trunc i8 %35 to i1
  %36 = load i8, ptr %allow_large.addr, align 1
  %tobool33 = trunc i8 %36 to i1
  %37 = load ptr, ptr %memid.addr, align 8
  %38 = load ptr, ptr %tld.addr, align 8
  %stats = getelementptr inbounds %struct.mi_os_tld_s, ptr %38, i32 0, i32 1
  %39 = load ptr, ptr %stats, align 8
  %call34 = call ptr @_mi_os_alloc_aligned_at_offset(i64 noundef %32, i64 noundef %33, i64 noundef %34, i1 noundef zeroext %tobool32, i1 noundef zeroext %tobool33, ptr noundef %37, ptr noundef %39)
  store ptr %call34, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %if.end29
  %40 = load i64, ptr %size.addr, align 8
  %41 = load i64, ptr %alignment.addr, align 8
  %42 = load i8, ptr %commit.addr, align 1
  %tobool35 = trunc i8 %42 to i1
  %43 = load i8, ptr %allow_large.addr, align 1
  %tobool36 = trunc i8 %43 to i1
  %44 = load ptr, ptr %memid.addr, align 8
  %45 = load ptr, ptr %tld.addr, align 8
  %stats37 = getelementptr inbounds %struct.mi_os_tld_s, ptr %45, i32 0, i32 1
  %46 = load ptr, ptr %stats37, align 8
  %call38 = call ptr @_mi_os_alloc_aligned(i64 noundef %40, i64 noundef %41, i1 noundef zeroext %tobool35, i1 noundef zeroext %tobool36, ptr noundef %44, ptr noundef %46)
  store ptr %call38, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then31, %if.then27, %if.then19, %if.then8
  %47 = load ptr, ptr %retval, align 8
  ret ptr %47
}

; Function Attrs: nounwind uwtable
define internal void @_mi_memid_none(ptr noalias sret(%struct.mi_memid_s) align 8 %agg.result) #0 {
entry:
  call void @_mi_memid_create(ptr sret(%struct.mi_memid_s) align 8 %agg.result, i32 noundef 0)
  ret void
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #4

; Function Attrs: nounwind uwtable
define internal i32 @_mi_os_numa_node(ptr noundef %tld) #0 {
entry:
  %retval = alloca i32, align 4
  %tld.addr = alloca ptr, align 8
  %atomic-temp = alloca i64, align 8
  store ptr %tld, ptr %tld.addr, align 8
  %0 = load atomic i64, ptr @_mi_numa_node_count monotonic, align 8
  store i64 %0, ptr %atomic-temp, align 8
  %1 = load i64, ptr %atomic-temp, align 8
  %cmp = icmp eq i64 %1, 1
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %2 = load ptr, ptr %tld.addr, align 8
  %call = call i32 @_mi_os_numa_node_get(ptr noundef %2)
  store i32 %call, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.else, %if.then
  %3 = load i32, ptr %retval, align 4
  ret i32 %3
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_arena_try_alloc(i32 noundef %numa_node, i64 noundef %size, i64 noundef %alignment, i1 noundef zeroext %commit, i1 noundef zeroext %allow_large, i32 noundef %req_arena_id, ptr noundef %memid, ptr noundef %tld) #0 {
entry:
  %retval = alloca ptr, align 8
  %numa_node.addr = alloca i32, align 4
  %size.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  %commit.addr = alloca i8, align 1
  %allow_large.addr = alloca i8, align 1
  %req_arena_id.addr = alloca i32, align 4
  %memid.addr = alloca ptr, align 8
  %tld.addr = alloca ptr, align 8
  %max_arena = alloca i64, align 8
  %atomic-temp = alloca i64, align 8
  %p = alloca ptr, align 8
  %i = alloca i64, align 8
  %p20 = alloca ptr, align 8
  %i32 = alloca i64, align 8
  %p37 = alloca ptr, align 8
  store i32 %numa_node, ptr %numa_node.addr, align 4
  store i64 %size, ptr %size.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  %frombool = zext i1 %commit to i8
  store i8 %frombool, ptr %commit.addr, align 1
  %frombool1 = zext i1 %allow_large to i8
  store i8 %frombool1, ptr %allow_large.addr, align 1
  store i32 %req_arena_id, ptr %req_arena_id.addr, align 4
  store ptr %memid, ptr %memid.addr, align 8
  store ptr %tld, ptr %tld.addr, align 8
  %0 = load atomic i64, ptr @mi_arena_count monotonic, align 64
  store i64 %0, ptr %atomic-temp, align 8
  %1 = load i64, ptr %atomic-temp, align 8
  store i64 %1, ptr %max_arena, align 8
  %2 = load i64, ptr %max_arena, align 8
  %cmp = icmp eq i64 %2, 0
  %lnot = xor i1 %cmp, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load i32, ptr %req_arena_id.addr, align 4
  %call = call i32 @_mi_arena_id_none()
  %cmp3 = icmp ne i32 %3, %call
  br i1 %cmp3, label %if.then5, label %if.else

if.then5:                                         ; preds = %if.end
  %4 = load i32, ptr %req_arena_id.addr, align 4
  %call6 = call i64 @mi_arena_id_index(i32 noundef %4)
  %5 = load i64, ptr %max_arena, align 8
  %cmp7 = icmp ult i64 %call6, %5
  br i1 %cmp7, label %if.then9, label %if.end17

if.then9:                                         ; preds = %if.then5
  %6 = load i32, ptr %req_arena_id.addr, align 4
  %7 = load i32, ptr %numa_node.addr, align 4
  %8 = load i64, ptr %size.addr, align 8
  %9 = load i64, ptr %alignment.addr, align 8
  %10 = load i8, ptr %commit.addr, align 1
  %tobool10 = trunc i8 %10 to i1
  %11 = load i8, ptr %allow_large.addr, align 1
  %tobool11 = trunc i8 %11 to i1
  %12 = load i32, ptr %req_arena_id.addr, align 4
  %13 = load ptr, ptr %memid.addr, align 8
  %14 = load ptr, ptr %tld.addr, align 8
  %call12 = call ptr @mi_arena_try_alloc_at_id(i32 noundef %6, i1 noundef zeroext true, i32 noundef %7, i64 noundef %8, i64 noundef %9, i1 noundef zeroext %tobool10, i1 noundef zeroext %tobool11, i32 noundef %12, ptr noundef %13, ptr noundef %14)
  store ptr %call12, ptr %p, align 8
  %15 = load ptr, ptr %p, align 8
  %cmp13 = icmp ne ptr %15, null
  br i1 %cmp13, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.then9
  %16 = load ptr, ptr %p, align 8
  store ptr %16, ptr %retval, align 8
  br label %return

if.end16:                                         ; preds = %if.then9
  br label %if.end17

if.end17:                                         ; preds = %if.end16, %if.then5
  br label %if.end50

if.else:                                          ; preds = %if.end
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.else
  %17 = load i64, ptr %i, align 8
  %18 = load i64, ptr %max_arena, align 8
  %cmp18 = icmp ult i64 %17, %18
  br i1 %cmp18, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %19 = load i64, ptr %i, align 8
  %call21 = call i32 @mi_arena_id_create(i64 noundef %19)
  %20 = load i32, ptr %numa_node.addr, align 4
  %21 = load i64, ptr %size.addr, align 8
  %22 = load i64, ptr %alignment.addr, align 8
  %23 = load i8, ptr %commit.addr, align 1
  %tobool22 = trunc i8 %23 to i1
  %24 = load i8, ptr %allow_large.addr, align 1
  %tobool23 = trunc i8 %24 to i1
  %25 = load i32, ptr %req_arena_id.addr, align 4
  %26 = load ptr, ptr %memid.addr, align 8
  %27 = load ptr, ptr %tld.addr, align 8
  %call24 = call ptr @mi_arena_try_alloc_at_id(i32 noundef %call21, i1 noundef zeroext true, i32 noundef %20, i64 noundef %21, i64 noundef %22, i1 noundef zeroext %tobool22, i1 noundef zeroext %tobool23, i32 noundef %25, ptr noundef %26, ptr noundef %27)
  store ptr %call24, ptr %p20, align 8
  %28 = load ptr, ptr %p20, align 8
  %cmp25 = icmp ne ptr %28, null
  br i1 %cmp25, label %if.then27, label %if.end28

if.then27:                                        ; preds = %for.body
  %29 = load ptr, ptr %p20, align 8
  store ptr %29, ptr %retval, align 8
  br label %return

if.end28:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end28
  %30 = load i64, ptr %i, align 8
  %inc = add i64 %30, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !14

for.end:                                          ; preds = %for.cond
  %31 = load i32, ptr %numa_node.addr, align 4
  %cmp29 = icmp sge i32 %31, 0
  br i1 %cmp29, label %if.then31, label %if.end49

if.then31:                                        ; preds = %for.end
  store i64 0, ptr %i32, align 8
  br label %for.cond33

for.cond33:                                       ; preds = %for.inc46, %if.then31
  %32 = load i64, ptr %i32, align 8
  %33 = load i64, ptr %max_arena, align 8
  %cmp34 = icmp ult i64 %32, %33
  br i1 %cmp34, label %for.body36, label %for.end48

for.body36:                                       ; preds = %for.cond33
  %34 = load i64, ptr %i32, align 8
  %call38 = call i32 @mi_arena_id_create(i64 noundef %34)
  %35 = load i32, ptr %numa_node.addr, align 4
  %36 = load i64, ptr %size.addr, align 8
  %37 = load i64, ptr %alignment.addr, align 8
  %38 = load i8, ptr %commit.addr, align 1
  %tobool39 = trunc i8 %38 to i1
  %39 = load i8, ptr %allow_large.addr, align 1
  %tobool40 = trunc i8 %39 to i1
  %40 = load i32, ptr %req_arena_id.addr, align 4
  %41 = load ptr, ptr %memid.addr, align 8
  %42 = load ptr, ptr %tld.addr, align 8
  %call41 = call ptr @mi_arena_try_alloc_at_id(i32 noundef %call38, i1 noundef zeroext false, i32 noundef %35, i64 noundef %36, i64 noundef %37, i1 noundef zeroext %tobool39, i1 noundef zeroext %tobool40, i32 noundef %40, ptr noundef %41, ptr noundef %42)
  store ptr %call41, ptr %p37, align 8
  %43 = load ptr, ptr %p37, align 8
  %cmp42 = icmp ne ptr %43, null
  br i1 %cmp42, label %if.then44, label %if.end45

if.then44:                                        ; preds = %for.body36
  %44 = load ptr, ptr %p37, align 8
  store ptr %44, ptr %retval, align 8
  br label %return

if.end45:                                         ; preds = %for.body36
  br label %for.inc46

for.inc46:                                        ; preds = %if.end45
  %45 = load i64, ptr %i32, align 8
  %inc47 = add i64 %45, 1
  store i64 %inc47, ptr %i32, align 8
  br label %for.cond33, !llvm.loop !15

for.end48:                                        ; preds = %for.cond33
  br label %if.end49

if.end49:                                         ; preds = %for.end48, %for.end
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.end17
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end50, %if.then44, %if.then27, %if.then15, %if.then
  %46 = load ptr, ptr %retval, align 8
  ret ptr %46
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_arena_reserve(i64 noundef %req_size, i1 noundef zeroext %allow_large, i32 noundef %req_arena_id, ptr noundef %arena_id) #0 {
entry:
  %retval = alloca i1, align 1
  %req_size.addr = alloca i64, align 8
  %allow_large.addr = alloca i8, align 1
  %req_arena_id.addr = alloca i32, align 4
  %arena_id.addr = alloca ptr, align 8
  %arena_count = alloca i64, align 8
  %atomic-temp = alloca i64, align 8
  %arena_reserve = alloca i64, align 8
  %arena_commit = alloca i8, align 1
  store i64 %req_size, ptr %req_size.addr, align 8
  %frombool = zext i1 %allow_large to i8
  store i8 %frombool, ptr %allow_large.addr, align 1
  store i32 %req_arena_id, ptr %req_arena_id.addr, align 4
  store ptr %arena_id, ptr %arena_id.addr, align 8
  %call = call zeroext i1 @_mi_preloading()
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %0 = load i32, ptr %req_arena_id.addr, align 4
  %call1 = call i32 @_mi_arena_id_none()
  %cmp = icmp ne i32 %0, %call1
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i1 false, ptr %retval, align 1
  br label %return

if.end3:                                          ; preds = %if.end
  %1 = load atomic i64, ptr @mi_arena_count acquire, align 64
  store i64 %1, ptr %atomic-temp, align 8
  %2 = load i64, ptr %atomic-temp, align 8
  store i64 %2, ptr %arena_count, align 8
  %3 = load i64, ptr %arena_count, align 8
  %cmp4 = icmp ugt i64 %3, 108
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end3
  store i1 false, ptr %retval, align 1
  br label %return

if.end6:                                          ; preds = %if.end3
  %call7 = call i64 @mi_option_get_size(i32 noundef 23)
  store i64 %call7, ptr %arena_reserve, align 8
  %4 = load i64, ptr %arena_reserve, align 8
  %cmp8 = icmp eq i64 %4, 0
  br i1 %cmp8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end6
  store i1 false, ptr %retval, align 1
  br label %return

if.end10:                                         ; preds = %if.end6
  %call11 = call zeroext i1 @_mi_os_has_virtual_reserve()
  br i1 %call11, label %if.end13, label %if.then12

if.then12:                                        ; preds = %if.end10
  %5 = load i64, ptr %arena_reserve, align 8
  %div = udiv i64 %5, 4
  store i64 %div, ptr %arena_reserve, align 8
  br label %if.end13

if.end13:                                         ; preds = %if.then12, %if.end10
  %6 = load i64, ptr %arena_reserve, align 8
  %call14 = call i64 @_mi_align_up(i64 noundef %6, i64 noundef 33554432)
  store i64 %call14, ptr %arena_reserve, align 8
  %7 = load i64, ptr %arena_count, align 8
  %cmp15 = icmp uge i64 %7, 8
  br i1 %cmp15, label %land.lhs.true, label %if.end19

land.lhs.true:                                    ; preds = %if.end13
  %8 = load i64, ptr %arena_count, align 8
  %cmp16 = icmp ule i64 %8, 128
  br i1 %cmp16, label %if.then17, label %if.end19

if.then17:                                        ; preds = %land.lhs.true
  %9 = load i64, ptr %arena_count, align 8
  %div18 = udiv i64 %9, 8
  %shl = shl i64 1, %div18
  %10 = load i64, ptr %arena_reserve, align 8
  %mul = mul i64 %shl, %10
  store i64 %mul, ptr %arena_reserve, align 8
  br label %if.end19

if.end19:                                         ; preds = %if.then17, %land.lhs.true, %if.end13
  %11 = load i64, ptr %arena_reserve, align 8
  %12 = load i64, ptr %req_size.addr, align 8
  %cmp20 = icmp ult i64 %11, %12
  br i1 %cmp20, label %if.then21, label %if.end22

if.then21:                                        ; preds = %if.end19
  store i1 false, ptr %retval, align 1
  br label %return

if.end22:                                         ; preds = %if.end19
  store i8 0, ptr %arena_commit, align 1
  %call23 = call i64 @mi_option_get(i32 noundef 4)
  %cmp24 = icmp eq i64 %call23, 2
  br i1 %cmp24, label %if.then25, label %if.else

if.then25:                                        ; preds = %if.end22
  %call26 = call zeroext i1 @_mi_os_has_overcommit()
  %frombool27 = zext i1 %call26 to i8
  store i8 %frombool27, ptr %arena_commit, align 1
  br label %if.end32

if.else:                                          ; preds = %if.end22
  %call28 = call i64 @mi_option_get(i32 noundef 4)
  %cmp29 = icmp eq i64 %call28, 1
  br i1 %cmp29, label %if.then30, label %if.end31

if.then30:                                        ; preds = %if.else
  store i8 1, ptr %arena_commit, align 1
  br label %if.end31

if.end31:                                         ; preds = %if.then30, %if.else
  br label %if.end32

if.end32:                                         ; preds = %if.end31, %if.then25
  %13 = load i64, ptr %arena_reserve, align 8
  %14 = load i8, ptr %arena_commit, align 1
  %tobool = trunc i8 %14 to i1
  %15 = load i8, ptr %allow_large.addr, align 1
  %tobool33 = trunc i8 %15 to i1
  %16 = load ptr, ptr %arena_id.addr, align 8
  %call34 = call i32 @mi_reserve_os_memory_ex(i64 noundef %13, i1 noundef zeroext %tobool, i1 noundef zeroext %tobool33, i1 noundef zeroext false, ptr noundef %16)
  %cmp35 = icmp eq i32 %call34, 0
  store i1 %cmp35, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end32, %if.then21, %if.then9, %if.then5, %if.then2, %if.then
  %17 = load i1, ptr %retval, align 1
  ret i1 %17
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_arena_try_alloc_at_id(i32 noundef %arena_id, i1 noundef zeroext %match_numa_node, i32 noundef %numa_node, i64 noundef %size, i64 noundef %alignment, i1 noundef zeroext %commit, i1 noundef zeroext %allow_large, i32 noundef %req_arena_id, ptr noundef %memid, ptr noundef %tld) #0 {
entry:
  %retval = alloca ptr, align 8
  %arena_id.addr = alloca i32, align 4
  %match_numa_node.addr = alloca i8, align 1
  %numa_node.addr = alloca i32, align 4
  %size.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  %commit.addr = alloca i8, align 1
  %allow_large.addr = alloca i8, align 1
  %req_arena_id.addr = alloca i32, align 4
  %memid.addr = alloca ptr, align 8
  %tld.addr = alloca ptr, align 8
  %bcount = alloca i64, align 8
  %arena_index = alloca i64, align 8
  %arena = alloca ptr, align 8
  %atomic-temp = alloca ptr, align 8
  %numa_suitable = alloca i8, align 1
  %p = alloca ptr, align 8
  store i32 %arena_id, ptr %arena_id.addr, align 4
  %frombool = zext i1 %match_numa_node to i8
  store i8 %frombool, ptr %match_numa_node.addr, align 1
  store i32 %numa_node, ptr %numa_node.addr, align 4
  store i64 %size, ptr %size.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  %frombool1 = zext i1 %commit to i8
  store i8 %frombool1, ptr %commit.addr, align 1
  %frombool2 = zext i1 %allow_large to i8
  store i8 %frombool2, ptr %allow_large.addr, align 1
  store i32 %req_arena_id, ptr %req_arena_id.addr, align 4
  store ptr %memid, ptr %memid.addr, align 8
  store ptr %tld, ptr %tld.addr, align 8
  %0 = load i64, ptr %size.addr, align 8
  %call = call i64 @mi_block_count_of_size(i64 noundef %0)
  store i64 %call, ptr %bcount, align 8
  %1 = load i32, ptr %arena_id.addr, align 4
  %call3 = call i64 @mi_arena_id_index(i32 noundef %1)
  store i64 %call3, ptr %arena_index, align 8
  %2 = load i64, ptr %arena_index, align 8
  %arrayidx = getelementptr [112 x ptr], ptr @mi_arenas, i64 0, i64 %2
  %3 = load atomic i64, ptr %arrayidx acquire, align 8
  store i64 %3, ptr %atomic-temp, align 8
  %4 = load ptr, ptr %atomic-temp, align 8
  store ptr %4, ptr %arena, align 8
  %5 = load ptr, ptr %arena, align 8
  %cmp = icmp eq ptr %5, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %6 = load i8, ptr %allow_large.addr, align 1
  %tobool = trunc i8 %6 to i1
  br i1 %tobool, label %if.end6, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %7 = load ptr, ptr %arena, align 8
  %is_large = getelementptr inbounds %struct.mi_arena_s, ptr %7, i32 0, i32 9
  %8 = load i8, ptr %is_large, align 1
  %tobool4 = trunc i8 %8 to i1
  br i1 %tobool4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %land.lhs.true
  store ptr null, ptr %retval, align 8
  br label %return

if.end6:                                          ; preds = %land.lhs.true, %if.end
  %9 = load ptr, ptr %arena, align 8
  %id = getelementptr inbounds %struct.mi_arena_s, ptr %9, i32 0, i32 0
  %10 = load i32, ptr %id, align 8
  %11 = load ptr, ptr %arena, align 8
  %exclusive = getelementptr inbounds %struct.mi_arena_s, ptr %11, i32 0, i32 8
  %12 = load i8, ptr %exclusive, align 4
  %tobool7 = trunc i8 %12 to i1
  %13 = load i32, ptr %req_arena_id.addr, align 4
  %call8 = call zeroext i1 @mi_arena_id_is_suitable(i32 noundef %10, i1 noundef zeroext %tobool7, i32 noundef %13)
  br i1 %call8, label %if.end10, label %if.then9

if.then9:                                         ; preds = %if.end6
  store ptr null, ptr %retval, align 8
  br label %return

if.end10:                                         ; preds = %if.end6
  %14 = load i32, ptr %req_arena_id.addr, align 4
  %call11 = call i32 @_mi_arena_id_none()
  %cmp12 = icmp eq i32 %14, %call11
  br i1 %cmp12, label %if.then13, label %if.end29

if.then13:                                        ; preds = %if.end10
  %15 = load i32, ptr %numa_node.addr, align 4
  %cmp14 = icmp slt i32 %15, 0
  br i1 %cmp14, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then13
  %16 = load ptr, ptr %arena, align 8
  %numa_node15 = getelementptr inbounds %struct.mi_arena_s, ptr %16, i32 0, i32 7
  %17 = load i32, ptr %numa_node15, align 8
  %cmp16 = icmp slt i32 %17, 0
  br i1 %cmp16, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false
  %18 = load ptr, ptr %arena, align 8
  %numa_node17 = getelementptr inbounds %struct.mi_arena_s, ptr %18, i32 0, i32 7
  %19 = load i32, ptr %numa_node17, align 8
  %20 = load i32, ptr %numa_node.addr, align 4
  %cmp18 = icmp eq i32 %19, %20
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false, %if.then13
  %21 = phi i1 [ true, %lor.lhs.false ], [ true, %if.then13 ], [ %cmp18, %lor.rhs ]
  %frombool19 = zext i1 %21 to i8
  store i8 %frombool19, ptr %numa_suitable, align 1
  %22 = load i8, ptr %match_numa_node.addr, align 1
  %tobool20 = trunc i8 %22 to i1
  br i1 %tobool20, label %if.then21, label %if.else

if.then21:                                        ; preds = %lor.end
  %23 = load i8, ptr %numa_suitable, align 1
  %tobool22 = trunc i8 %23 to i1
  br i1 %tobool22, label %if.end24, label %if.then23

if.then23:                                        ; preds = %if.then21
  store ptr null, ptr %retval, align 8
  br label %return

if.end24:                                         ; preds = %if.then21
  br label %if.end28

if.else:                                          ; preds = %lor.end
  %24 = load i8, ptr %numa_suitable, align 1
  %tobool25 = trunc i8 %24 to i1
  br i1 %tobool25, label %if.then26, label %if.end27

if.then26:                                        ; preds = %if.else
  store ptr null, ptr %retval, align 8
  br label %return

if.end27:                                         ; preds = %if.else
  br label %if.end28

if.end28:                                         ; preds = %if.end27, %if.end24
  br label %if.end29

if.end29:                                         ; preds = %if.end28, %if.end10
  %25 = load ptr, ptr %arena, align 8
  %26 = load i64, ptr %arena_index, align 8
  %27 = load i64, ptr %bcount, align 8
  %28 = load i8, ptr %commit.addr, align 1
  %tobool30 = trunc i8 %28 to i1
  %29 = load ptr, ptr %memid.addr, align 8
  %30 = load ptr, ptr %tld.addr, align 8
  %call31 = call ptr @mi_arena_try_alloc_at(ptr noundef %25, i64 noundef %26, i64 noundef %27, i1 noundef zeroext %tobool30, ptr noundef %29, ptr noundef %30)
  store ptr %call31, ptr %p, align 8
  %31 = load ptr, ptr %p, align 8
  store ptr %31, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end29, %if.then26, %if.then23, %if.then9, %if.then5, %if.then
  %32 = load ptr, ptr %retval, align 8
  ret ptr %32
}

; Function Attrs: nounwind uwtable
define hidden zeroext i1 @mi_option_is_enabled(i32 noundef %option) #0 {
entry:
  %option.addr = alloca i32, align 4
  store i32 %option, ptr %option.addr, align 4
  %0 = load i32, ptr %option.addr, align 4
  %call = call i64 @mi_option_get(i32 noundef %0)
  %cmp = icmp ne i64 %call, 0
  ret i1 %cmp
}

; Function Attrs: nounwind uwtable
define hidden ptr @_mi_os_alloc_aligned_at_offset(i64 noundef %size, i64 noundef %alignment, i64 noundef %offset, i1 noundef zeroext %commit, i1 noundef zeroext %allow_large, ptr noundef %memid, ptr noundef %tld_stats) #0 {
entry:
  %retval = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  %offset.addr = alloca i64, align 8
  %commit.addr = alloca i8, align 1
  %allow_large.addr = alloca i8, align 1
  %memid.addr = alloca ptr, align 8
  %tld_stats.addr = alloca ptr, align 8
  %tmp = alloca %struct.mi_memid_s, align 8
  %extra = alloca i64, align 8
  %oversize = alloca i64, align 8
  %start = alloca ptr, align 8
  %p = alloca ptr, align 8
  store i64 %size, ptr %size.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  store i64 %offset, ptr %offset.addr, align 8
  %frombool = zext i1 %commit to i8
  store i8 %frombool, ptr %commit.addr, align 1
  %frombool1 = zext i1 %allow_large to i8
  store i8 %frombool1, ptr %allow_large.addr, align 1
  store ptr %memid, ptr %memid.addr, align 8
  store ptr %tld_stats, ptr %tld_stats.addr, align 8
  %0 = load ptr, ptr %memid.addr, align 8
  call void @_mi_memid_none(ptr sret(%struct.mi_memid_s) align 8 %tmp)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %0, ptr align 8 %tmp, i64 24, i1 false)
  %1 = load i64, ptr %offset.addr, align 8
  %cmp = icmp ugt i64 %1, 33554432
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i64, ptr %offset.addr, align 8
  %cmp2 = icmp eq i64 %2, 0
  br i1 %cmp2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  %3 = load i64, ptr %size.addr, align 8
  %4 = load i64, ptr %alignment.addr, align 8
  %5 = load i8, ptr %commit.addr, align 1
  %tobool = trunc i8 %5 to i1
  %6 = load i8, ptr %allow_large.addr, align 1
  %tobool4 = trunc i8 %6 to i1
  %7 = load ptr, ptr %memid.addr, align 8
  %8 = load ptr, ptr %tld_stats.addr, align 8
  %call = call ptr @_mi_os_alloc_aligned(i64 noundef %3, i64 noundef %4, i1 noundef zeroext %tobool, i1 noundef zeroext %tobool4, ptr noundef %7, ptr noundef %8)
  store ptr %call, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %if.end
  %9 = load i64, ptr %offset.addr, align 8
  %10 = load i64, ptr %alignment.addr, align 8
  %call5 = call i64 @_mi_align_up(i64 noundef %9, i64 noundef %10)
  %11 = load i64, ptr %offset.addr, align 8
  %sub = sub i64 %call5, %11
  store i64 %sub, ptr %extra, align 8
  %12 = load i64, ptr %size.addr, align 8
  %13 = load i64, ptr %extra, align 8
  %add = add i64 %12, %13
  store i64 %add, ptr %oversize, align 8
  %14 = load i64, ptr %oversize, align 8
  %15 = load i64, ptr %alignment.addr, align 8
  %16 = load i8, ptr %commit.addr, align 1
  %tobool6 = trunc i8 %16 to i1
  %17 = load i8, ptr %allow_large.addr, align 1
  %tobool7 = trunc i8 %17 to i1
  %18 = load ptr, ptr %memid.addr, align 8
  %19 = load ptr, ptr %tld_stats.addr, align 8
  %call8 = call ptr @_mi_os_alloc_aligned(i64 noundef %14, i64 noundef %15, i1 noundef zeroext %tobool6, i1 noundef zeroext %tobool7, ptr noundef %18, ptr noundef %19)
  store ptr %call8, ptr %start, align 8
  %20 = load ptr, ptr %start, align 8
  %cmp9 = icmp eq ptr %20, null
  br i1 %cmp9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.else
  store ptr null, ptr %retval, align 8
  br label %return

if.end11:                                         ; preds = %if.else
  %21 = load ptr, ptr %start, align 8
  %22 = load i64, ptr %extra, align 8
  %add.ptr = getelementptr i8, ptr %21, i64 %22
  store ptr %add.ptr, ptr %p, align 8
  %23 = load i8, ptr %commit.addr, align 1
  %tobool12 = trunc i8 %23 to i1
  br i1 %tobool12, label %land.lhs.true, label %if.end17

land.lhs.true:                                    ; preds = %if.end11
  %24 = load i64, ptr %extra, align 8
  %call13 = call i64 @_mi_os_page_size()
  %cmp14 = icmp ugt i64 %24, %call13
  br i1 %cmp14, label %if.then15, label %if.end17

if.then15:                                        ; preds = %land.lhs.true
  %25 = load ptr, ptr %start, align 8
  %26 = load i64, ptr %extra, align 8
  %27 = load ptr, ptr %tld_stats.addr, align 8
  %call16 = call zeroext i1 @_mi_os_decommit(ptr noundef %25, i64 noundef %26, ptr noundef %27)
  br label %if.end17

if.end17:                                         ; preds = %if.then15, %land.lhs.true, %if.end11
  %28 = load ptr, ptr %p, align 8
  store ptr %28, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end17, %if.then10, %if.then3, %if.then
  %29 = load ptr, ptr %retval, align 8
  ret ptr %29
}

; Function Attrs: nounwind uwtable
define hidden ptr @_mi_os_alloc_aligned(i64 noundef %size, i64 noundef %alignment, i1 noundef zeroext %commit, i1 noundef zeroext %allow_large, ptr noundef %memid, ptr noundef %tld_stats) #0 {
entry:
  %retval = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  %commit.addr = alloca i8, align 1
  %allow_large.addr = alloca i8, align 1
  %memid.addr = alloca ptr, align 8
  %tld_stats.addr = alloca ptr, align 8
  %tmp = alloca %struct.mi_memid_s, align 8
  %os_is_large = alloca i8, align 1
  %os_is_zero = alloca i8, align 1
  %os_base = alloca ptr, align 8
  %p = alloca ptr, align 8
  %tmp8 = alloca %struct.mi_memid_s, align 8
  store i64 %size, ptr %size.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  %frombool = zext i1 %commit to i8
  store i8 %frombool, ptr %commit.addr, align 1
  %frombool1 = zext i1 %allow_large to i8
  store i8 %frombool1, ptr %allow_large.addr, align 1
  store ptr %memid, ptr %memid.addr, align 8
  store ptr %tld_stats, ptr %tld_stats.addr, align 8
  %0 = load ptr, ptr %memid.addr, align 8
  call void @_mi_memid_none(ptr sret(%struct.mi_memid_s) align 8 %tmp)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %0, ptr align 8 %tmp, i64 24, i1 false)
  %1 = load i64, ptr %size.addr, align 8
  %cmp = icmp eq i64 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i64, ptr %size.addr, align 8
  %call = call i64 @_mi_os_good_alloc_size(i64 noundef %2)
  store i64 %call, ptr %size.addr, align 8
  %3 = load i64, ptr %alignment.addr, align 8
  %call2 = call i64 @_mi_os_page_size()
  %call3 = call i64 @_mi_align_up(i64 noundef %3, i64 noundef %call2)
  store i64 %call3, ptr %alignment.addr, align 8
  store i8 0, ptr %os_is_large, align 1
  store i8 0, ptr %os_is_zero, align 1
  store ptr null, ptr %os_base, align 8
  %4 = load i64, ptr %size.addr, align 8
  %5 = load i64, ptr %alignment.addr, align 8
  %6 = load i8, ptr %commit.addr, align 1
  %tobool = trunc i8 %6 to i1
  %7 = load i8, ptr %allow_large.addr, align 1
  %tobool4 = trunc i8 %7 to i1
  %call5 = call ptr @mi_os_prim_alloc_aligned(i64 noundef %4, i64 noundef %5, i1 noundef zeroext %tobool, i1 noundef zeroext %tobool4, ptr noundef %os_is_large, ptr noundef %os_is_zero, ptr noundef %os_base, ptr noundef @_mi_stats_main)
  store ptr %call5, ptr %p, align 8
  %8 = load ptr, ptr %p, align 8
  %cmp6 = icmp ne ptr %8, null
  br i1 %cmp6, label %if.then7, label %if.end14

if.then7:                                         ; preds = %if.end
  %9 = load ptr, ptr %memid.addr, align 8
  %10 = load i8, ptr %commit.addr, align 1
  %tobool9 = trunc i8 %10 to i1
  %11 = load i8, ptr %os_is_zero, align 1
  %tobool10 = trunc i8 %11 to i1
  %12 = load i8, ptr %os_is_large, align 1
  %tobool11 = trunc i8 %12 to i1
  call void @_mi_memid_create_os(ptr sret(%struct.mi_memid_s) align 8 %tmp8, i1 noundef zeroext %tobool9, i1 noundef zeroext %tobool10, i1 noundef zeroext %tobool11)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %9, ptr align 8 %tmp8, i64 24, i1 false)
  %13 = load ptr, ptr %os_base, align 8
  %14 = load ptr, ptr %memid.addr, align 8
  %mem = getelementptr inbounds %struct.mi_memid_s, ptr %14, i32 0, i32 0
  %base = getelementptr inbounds %struct.mi_memid_os_info, ptr %mem, i32 0, i32 0
  store ptr %13, ptr %base, align 8
  %15 = load i64, ptr %alignment.addr, align 8
  %16 = load ptr, ptr %memid.addr, align 8
  %mem12 = getelementptr inbounds %struct.mi_memid_s, ptr %16, i32 0, i32 0
  %alignment13 = getelementptr inbounds %struct.mi_memid_os_info, ptr %mem12, i32 0, i32 1
  store i64 %15, ptr %alignment13, align 8
  br label %if.end14

if.end14:                                         ; preds = %if.then7, %if.end
  %17 = load ptr, ptr %p, align 8
  store ptr %17, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end14, %if.then
  %18 = load ptr, ptr %retval, align 8
  ret ptr %18
}

; Function Attrs: nounwind uwtable
define hidden ptr @_mi_arena_alloc(i64 noundef %size, i1 noundef zeroext %commit, i1 noundef zeroext %allow_large, i32 noundef %req_arena_id, ptr noundef %memid, ptr noundef %tld) #0 {
entry:
  %size.addr = alloca i64, align 8
  %commit.addr = alloca i8, align 1
  %allow_large.addr = alloca i8, align 1
  %req_arena_id.addr = alloca i32, align 4
  %memid.addr = alloca ptr, align 8
  %tld.addr = alloca ptr, align 8
  store i64 %size, ptr %size.addr, align 8
  %frombool = zext i1 %commit to i8
  store i8 %frombool, ptr %commit.addr, align 1
  %frombool1 = zext i1 %allow_large to i8
  store i8 %frombool1, ptr %allow_large.addr, align 1
  store i32 %req_arena_id, ptr %req_arena_id.addr, align 4
  store ptr %memid, ptr %memid.addr, align 8
  store ptr %tld, ptr %tld.addr, align 8
  %0 = load i64, ptr %size.addr, align 8
  %1 = load i8, ptr %commit.addr, align 1
  %tobool = trunc i8 %1 to i1
  %2 = load i8, ptr %allow_large.addr, align 1
  %tobool2 = trunc i8 %2 to i1
  %3 = load i32, ptr %req_arena_id.addr, align 4
  %4 = load ptr, ptr %memid.addr, align 8
  %5 = load ptr, ptr %tld.addr, align 8
  %call = call ptr @_mi_arena_alloc_aligned(i64 noundef %0, i64 noundef 33554432, i64 noundef 0, i1 noundef zeroext %tobool, i1 noundef zeroext %tobool2, i32 noundef %3, ptr noundef %4, ptr noundef %5)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define hidden ptr @mi_arena_area(i32 noundef %arena_id, ptr noundef %size) #0 {
entry:
  %retval = alloca ptr, align 8
  %arena_id.addr = alloca i32, align 4
  %size.addr = alloca ptr, align 8
  %arena_index = alloca i64, align 8
  %arena = alloca ptr, align 8
  %atomic-temp = alloca ptr, align 8
  store i32 %arena_id, ptr %arena_id.addr, align 4
  store ptr %size, ptr %size.addr, align 8
  %0 = load ptr, ptr %size.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %size.addr, align 8
  store i64 0, ptr %1, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i32, ptr %arena_id.addr, align 4
  %call = call i64 @mi_arena_id_index(i32 noundef %2)
  store i64 %call, ptr %arena_index, align 8
  %3 = load i64, ptr %arena_index, align 8
  %cmp1 = icmp uge i64 %3, 112
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end3:                                          ; preds = %if.end
  %4 = load i64, ptr %arena_index, align 8
  %arrayidx = getelementptr [112 x ptr], ptr @mi_arenas, i64 0, i64 %4
  %5 = load atomic i64, ptr %arrayidx acquire, align 8
  store i64 %5, ptr %atomic-temp, align 8
  %6 = load ptr, ptr %atomic-temp, align 8
  store ptr %6, ptr %arena, align 8
  %7 = load ptr, ptr %arena, align 8
  %cmp4 = icmp eq ptr %7, null
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end3
  store ptr null, ptr %retval, align 8
  br label %return

if.end6:                                          ; preds = %if.end3
  %8 = load ptr, ptr %size.addr, align 8
  %cmp7 = icmp ne ptr %8, null
  br i1 %cmp7, label %if.then8, label %if.end10

if.then8:                                         ; preds = %if.end6
  %9 = load ptr, ptr %arena, align 8
  %block_count = getelementptr inbounds %struct.mi_arena_s, ptr %9, i32 0, i32 3
  %10 = load i64, ptr %block_count, align 8
  %call9 = call i64 @mi_arena_block_size(i64 noundef %10)
  %11 = load ptr, ptr %size.addr, align 8
  store i64 %call9, ptr %11, align 8
  br label %if.end10

if.end10:                                         ; preds = %if.then8, %if.end6
  %12 = load ptr, ptr %arena, align 8
  %start = getelementptr inbounds %struct.mi_arena_s, ptr %12, i32 0, i32 2
  %atomic-load = load atomic i64, ptr %start seq_cst, align 8
  %13 = inttoptr i64 %atomic-load to ptr
  store ptr %13, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end10, %if.then5, %if.then2
  %14 = load ptr, ptr %retval, align 8
  ret ptr %14
}

; Function Attrs: nounwind uwtable
define internal i64 @mi_arena_id_index(i32 noundef %id) #0 {
entry:
  %id.addr = alloca i32, align 4
  store i32 %id, ptr %id.addr, align 4
  %0 = load i32, ptr %id.addr, align 4
  %cmp = icmp sle i32 %0, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %1 = load i32, ptr %id.addr, align 4
  %sub = sub i32 %1, 1
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 112, %cond.true ], [ %sub, %cond.false ]
  %conv = sext i32 %cond to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @mi_arena_block_size(i64 noundef %bcount) #0 {
entry:
  %bcount.addr = alloca i64, align 8
  store i64 %bcount, ptr %bcount.addr, align 8
  %0 = load i64, ptr %bcount.addr, align 8
  %mul = mul i64 %0, 33554432
  ret i64 %mul
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_arena_free(ptr noundef %p, i64 noundef %size, i64 noundef %committed_size, ptr noundef byval(%struct.mi_memid_s) align 8 %memid, ptr noundef %stats) #0 {
entry:
  %p.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %committed_size.addr = alloca i64, align 8
  %stats.addr = alloca ptr, align 8
  %all_committed = alloca i8, align 1
  %arena_idx = alloca i64, align 8
  %bitmap_idx = alloca i64, align 8
  %arena = alloca ptr, align 8
  %atomic-temp = alloca ptr, align 8
  %blocks = alloca i64, align 8
  %all_inuse = alloca i8, align 1
  store ptr %p, ptr %p.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store i64 %committed_size, ptr %committed_size.addr, align 8
  store ptr %stats, ptr %stats.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, ptr %size.addr, align 8
  %cmp1 = icmp eq i64 %1, 0
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  br label %return

if.end3:                                          ; preds = %if.end
  %2 = load i64, ptr %committed_size.addr, align 8
  %3 = load i64, ptr %size.addr, align 8
  %cmp4 = icmp eq i64 %2, %3
  %frombool = zext i1 %cmp4 to i8
  store i8 %frombool, ptr %all_committed, align 1
  %memkind = getelementptr inbounds %struct.mi_memid_s, ptr %memid, i32 0, i32 4
  %4 = load i32, ptr %memkind, align 4
  %call = call zeroext i1 @mi_memkind_is_os(i32 noundef %4)
  br i1 %call, label %if.then5, label %if.else

if.then5:                                         ; preds = %if.end3
  %5 = load i8, ptr %all_committed, align 1
  %tobool = trunc i8 %5 to i1
  br i1 %tobool, label %if.end8, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then5
  %6 = load i64, ptr %committed_size.addr, align 8
  %cmp6 = icmp ugt i64 %6, 0
  br i1 %cmp6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %land.lhs.true
  %7 = load ptr, ptr %stats.addr, align 8
  %committed = getelementptr inbounds %struct.mi_stats_s, ptr %7, i32 0, i32 3
  %8 = load i64, ptr %committed_size.addr, align 8
  call void @_mi_stat_decrease(ptr noundef %committed, i64 noundef %8)
  br label %if.end8

if.end8:                                          ; preds = %if.then7, %land.lhs.true, %if.then5
  %9 = load ptr, ptr %p.addr, align 8
  %10 = load i64, ptr %size.addr, align 8
  %11 = load ptr, ptr %stats.addr, align 8
  call void @_mi_os_free(ptr noundef %9, i64 noundef %10, ptr noundef byval(%struct.mi_memid_s) align 8 %memid, ptr noundef %11)
  br label %if.end45

if.else:                                          ; preds = %if.end3
  %memkind9 = getelementptr inbounds %struct.mi_memid_s, ptr %memid, i32 0, i32 4
  %12 = load i32, ptr %memkind9, align 4
  %cmp10 = icmp eq i32 %12, 6
  br i1 %cmp10, label %if.then11, label %if.else43

if.then11:                                        ; preds = %if.else
  %call12 = call zeroext i1 @mi_arena_memid_indices(ptr noundef byval(%struct.mi_memid_s) align 8 %memid, ptr noundef %arena_idx, ptr noundef %bitmap_idx)
  %13 = load i64, ptr %arena_idx, align 8
  %arrayidx = getelementptr [112 x ptr], ptr @mi_arenas, i64 0, i64 %13
  %14 = load atomic i64, ptr %arrayidx acquire, align 8
  store i64 %14, ptr %atomic-temp, align 8
  %15 = load ptr, ptr %atomic-temp, align 8
  store ptr %15, ptr %arena, align 8
  %16 = load i64, ptr %size.addr, align 8
  %call13 = call i64 @mi_block_count_of_size(i64 noundef %16)
  store i64 %call13, ptr %blocks, align 8
  %17 = load ptr, ptr %arena, align 8
  %cmp14 = icmp eq ptr %17, null
  br i1 %cmp14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.then11
  %18 = load ptr, ptr %p.addr, align 8
  %19 = load i64, ptr %size.addr, align 8
  call void (i32, ptr, ...) @_mi_error_message(i32 noundef 22, ptr noundef @.str.4, ptr noundef %18, i64 noundef %19, ptr noundef byval(%struct.mi_memid_s) align 8 %memid)
  br label %return

if.end16:                                         ; preds = %if.then11
  %20 = load ptr, ptr %arena, align 8
  %field_count = getelementptr inbounds %struct.mi_arena_s, ptr %20, i32 0, i32 4
  %21 = load i64, ptr %field_count, align 8
  %22 = load i64, ptr %bitmap_idx, align 8
  %call17 = call i64 @mi_bitmap_index_field(i64 noundef %22)
  %cmp18 = icmp ule i64 %21, %call17
  br i1 %cmp18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %if.end16
  %23 = load ptr, ptr %p.addr, align 8
  %24 = load i64, ptr %size.addr, align 8
  call void (i32, ptr, ...) @_mi_error_message(i32 noundef 22, ptr noundef @.str.5, ptr noundef %23, i64 noundef %24, ptr noundef byval(%struct.mi_memid_s) align 8 %memid)
  br label %return

if.end20:                                         ; preds = %if.end16
  %25 = load ptr, ptr %arena, align 8
  %memid21 = getelementptr inbounds %struct.mi_arena_s, ptr %25, i32 0, i32 1
  %is_pinned = getelementptr inbounds %struct.mi_memid_s, ptr %memid21, i32 0, i32 1
  %26 = load i8, ptr %is_pinned, align 8
  %tobool22 = trunc i8 %26 to i1
  br i1 %tobool22, label %if.then24, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end20
  %27 = load ptr, ptr %arena, align 8
  %blocks_committed = getelementptr inbounds %struct.mi_arena_s, ptr %27, i32 0, i32 13
  %28 = load ptr, ptr %blocks_committed, align 8
  %cmp23 = icmp eq ptr %28, null
  br i1 %cmp23, label %if.then24, label %if.else25

if.then24:                                        ; preds = %lor.lhs.false, %if.end20
  br label %if.end36

if.else25:                                        ; preds = %lor.lhs.false
  %29 = load i8, ptr %all_committed, align 1
  %tobool26 = trunc i8 %29 to i1
  br i1 %tobool26, label %if.end35, label %if.then27

if.then27:                                        ; preds = %if.else25
  %30 = load ptr, ptr %arena, align 8
  %blocks_committed28 = getelementptr inbounds %struct.mi_arena_s, ptr %30, i32 0, i32 13
  %31 = load ptr, ptr %blocks_committed28, align 8
  %32 = load ptr, ptr %arena, align 8
  %field_count29 = getelementptr inbounds %struct.mi_arena_s, ptr %32, i32 0, i32 4
  %33 = load i64, ptr %field_count29, align 8
  %34 = load i64, ptr %blocks, align 8
  %35 = load i64, ptr %bitmap_idx, align 8
  %call30 = call zeroext i1 @_mi_bitmap_unclaim_across(ptr noundef %31, i64 noundef %33, i64 noundef %34, i64 noundef %35)
  %36 = load i64, ptr %committed_size.addr, align 8
  %cmp31 = icmp ugt i64 %36, 0
  br i1 %cmp31, label %if.then32, label %if.end34

if.then32:                                        ; preds = %if.then27
  %37 = load ptr, ptr %stats.addr, align 8
  %committed33 = getelementptr inbounds %struct.mi_stats_s, ptr %37, i32 0, i32 3
  %38 = load i64, ptr %committed_size.addr, align 8
  call void @_mi_stat_decrease(ptr noundef %committed33, i64 noundef %38)
  br label %if.end34

if.end34:                                         ; preds = %if.then32, %if.then27
  br label %if.end35

if.end35:                                         ; preds = %if.end34, %if.else25
  %39 = load ptr, ptr %arena, align 8
  %40 = load i64, ptr %bitmap_idx, align 8
  %41 = load i64, ptr %blocks, align 8
  %42 = load ptr, ptr %stats.addr, align 8
  call void @mi_arena_schedule_purge(ptr noundef %39, i64 noundef %40, i64 noundef %41, ptr noundef %42)
  br label %if.end36

if.end36:                                         ; preds = %if.end35, %if.then24
  %43 = load ptr, ptr %arena, align 8
  %blocks_inuse = getelementptr inbounds %struct.mi_arena_s, ptr %43, i32 0, i32 15
  %arraydecay = getelementptr inbounds [1 x i64], ptr %blocks_inuse, i64 0, i64 0
  %44 = load ptr, ptr %arena, align 8
  %field_count37 = getelementptr inbounds %struct.mi_arena_s, ptr %44, i32 0, i32 4
  %45 = load i64, ptr %field_count37, align 8
  %46 = load i64, ptr %blocks, align 8
  %47 = load i64, ptr %bitmap_idx, align 8
  %call38 = call zeroext i1 @_mi_bitmap_unclaim_across(ptr noundef %arraydecay, i64 noundef %45, i64 noundef %46, i64 noundef %47)
  %frombool39 = zext i1 %call38 to i8
  store i8 %frombool39, ptr %all_inuse, align 1
  %48 = load i8, ptr %all_inuse, align 1
  %tobool40 = trunc i8 %48 to i1
  br i1 %tobool40, label %if.end42, label %if.then41

if.then41:                                        ; preds = %if.end36
  %49 = load ptr, ptr %p.addr, align 8
  %50 = load i64, ptr %size.addr, align 8
  call void (i32, ptr, ...) @_mi_error_message(i32 noundef 11, ptr noundef @.str.6, ptr noundef %49, i64 noundef %50)
  br label %return

if.end42:                                         ; preds = %if.end36
  br label %if.end44

if.else43:                                        ; preds = %if.else
  br label %if.end44

if.end44:                                         ; preds = %if.else43, %if.end42
  br label %if.end45

if.end45:                                         ; preds = %if.end44, %if.end8
  %51 = load ptr, ptr %stats.addr, align 8
  call void @mi_arenas_try_purge(i1 noundef zeroext false, i1 noundef zeroext false, ptr noundef %51)
  br label %return

return:                                           ; preds = %if.end45, %if.then41, %if.then19, %if.then15, %if.then2, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_memkind_is_os(i32 noundef %memkind) #0 {
entry:
  %memkind.addr = alloca i32, align 4
  store i32 %memkind, ptr %memkind.addr, align 4
  %0 = load i32, ptr %memkind.addr, align 4
  %cmp = icmp uge i32 %0, 3
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %1 = load i32, ptr %memkind.addr, align 4
  %cmp1 = icmp ule i32 %1, 5
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %2 = phi i1 [ false, %entry ], [ %cmp1, %land.rhs ]
  ret i1 %2
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_stat_decrease(ptr noundef %stat, i64 noundef %amount) #0 {
entry:
  %stat.addr = alloca ptr, align 8
  %amount.addr = alloca i64, align 8
  store ptr %stat, ptr %stat.addr, align 8
  store i64 %amount, ptr %amount.addr, align 8
  %0 = load ptr, ptr %stat.addr, align 8
  %1 = load i64, ptr %amount.addr, align 8
  %sub = sub i64 0, %1
  call void @mi_stat_update(ptr noundef %0, i64 noundef %sub)
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_os_free(ptr noundef %p, i64 noundef %size, ptr noundef byval(%struct.mi_memid_s) align 8 %memid, ptr noundef %tld_stats) #0 {
entry:
  %p.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %tld_stats.addr = alloca ptr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store ptr %tld_stats, ptr %tld_stats.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %1 = load i64, ptr %size.addr, align 8
  %2 = load ptr, ptr %tld_stats.addr, align 8
  call void @_mi_os_free_ex(ptr noundef %0, i64 noundef %1, i1 noundef zeroext true, ptr noundef byval(%struct.mi_memid_s) align 8 %memid, ptr noundef %2)
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_arena_memid_indices(ptr noundef byval(%struct.mi_memid_s) align 8 %memid, ptr noundef %arena_index, ptr noundef %bitmap_index) #0 {
entry:
  %arena_index.addr = alloca ptr, align 8
  %bitmap_index.addr = alloca ptr, align 8
  store ptr %arena_index, ptr %arena_index.addr, align 8
  store ptr %bitmap_index, ptr %bitmap_index.addr, align 8
  %mem = getelementptr inbounds %struct.mi_memid_s, ptr %memid, i32 0, i32 0
  %id = getelementptr inbounds %struct.mi_memid_arena_info, ptr %mem, i32 0, i32 1
  %0 = load i32, ptr %id, align 8
  %call = call i64 @mi_arena_id_index(i32 noundef %0)
  %1 = load ptr, ptr %arena_index.addr, align 8
  store i64 %call, ptr %1, align 8
  %mem1 = getelementptr inbounds %struct.mi_memid_s, ptr %memid, i32 0, i32 0
  %block_index = getelementptr inbounds %struct.mi_memid_arena_info, ptr %mem1, i32 0, i32 0
  %2 = load i64, ptr %block_index, align 8
  %3 = load ptr, ptr %bitmap_index.addr, align 8
  store i64 %2, ptr %3, align 8
  %mem2 = getelementptr inbounds %struct.mi_memid_s, ptr %memid, i32 0, i32 0
  %is_exclusive = getelementptr inbounds %struct.mi_memid_arena_info, ptr %mem2, i32 0, i32 2
  %4 = load i8, ptr %is_exclusive, align 4
  %tobool = trunc i8 %4 to i1
  ret i1 %tobool
}

; Function Attrs: nounwind uwtable
define internal i64 @mi_block_count_of_size(i64 noundef %size) #0 {
entry:
  %size.addr = alloca i64, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load i64, ptr %size.addr, align 8
  %call = call i64 @_mi_divide_up(i64 noundef %0, i64 noundef 33554432)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_error_message(i32 noundef %err, ptr noundef %fmt, ...) #0 {
entry:
  %err.addr = alloca i32, align 4
  %fmt.addr = alloca ptr, align 8
  %args = alloca [1 x %struct.__va_list_tag], align 16
  %atomic-temp = alloca ptr, align 8
  store i32 %err, ptr %err.addr, align 4
  store ptr %fmt, ptr %fmt.addr, align 8
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %args, i64 0, i64 0
  call void @llvm.va_start(ptr %arraydecay)
  %0 = load ptr, ptr %fmt.addr, align 8
  %arraydecay1 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %args, i64 0, i64 0
  call void @mi_show_error_message(ptr noundef %0, ptr noundef %arraydecay1)
  %arraydecay2 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %args, i64 0, i64 0
  call void @llvm.va_end(ptr %arraydecay2)
  %1 = load volatile ptr, ptr @mi_error_handler, align 8
  %cmp = icmp ne ptr %1, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load volatile ptr, ptr @mi_error_handler, align 8
  %3 = load i32, ptr %err.addr, align 4
  %4 = load atomic i64, ptr @mi_error_arg acquire, align 8
  store i64 %4, ptr %atomic-temp, align 8
  %5 = load ptr, ptr %atomic-temp, align 8
  call void %2(i32 noundef %3, ptr noundef %5)
  br label %if.end

if.else:                                          ; preds = %entry
  %6 = load i32, ptr %err.addr, align 4
  call void @mi_error_default(i32 noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @mi_bitmap_index_field(i64 noundef %bitmap_idx) #0 {
entry:
  %bitmap_idx.addr = alloca i64, align 8
  store i64 %bitmap_idx, ptr %bitmap_idx.addr, align 8
  %0 = load i64, ptr %bitmap_idx.addr, align 8
  %div = udiv i64 %0, 64
  ret i64 %div
}

; Function Attrs: nounwind uwtable
define hidden zeroext i1 @_mi_bitmap_unclaim_across(ptr noundef %bitmap, i64 noundef %bitmap_fields, i64 noundef %count, i64 noundef %bitmap_idx) #0 {
entry:
  %bitmap.addr = alloca ptr, align 8
  %bitmap_fields.addr = alloca i64, align 8
  %count.addr = alloca i64, align 8
  %bitmap_idx.addr = alloca i64, align 8
  %idx = alloca i64, align 8
  %pre_mask = alloca i64, align 8
  %mid_mask = alloca i64, align 8
  %post_mask = alloca i64, align 8
  %mid_count = alloca i64, align 8
  %all_one = alloca i8, align 1
  %field = alloca ptr, align 8
  %prev = alloca i64, align 8
  %.atomictmp = alloca i64, align 8
  %atomic-temp = alloca i64, align 8
  %.atomictmp4 = alloca i64, align 8
  %atomic-temp6 = alloca i64, align 8
  %.atomictmp13 = alloca i64, align 8
  %atomic-temp15 = alloca i64, align 8
  store ptr %bitmap, ptr %bitmap.addr, align 8
  store i64 %bitmap_fields, ptr %bitmap_fields.addr, align 8
  store i64 %count, ptr %count.addr, align 8
  store i64 %bitmap_idx, ptr %bitmap_idx.addr, align 8
  %0 = load i64, ptr %bitmap_idx.addr, align 8
  %call = call i64 @mi_bitmap_index_field(i64 noundef %0)
  store i64 %call, ptr %idx, align 8
  %1 = load i64, ptr %bitmap_idx.addr, align 8
  %2 = load i64, ptr %bitmap_fields.addr, align 8
  %3 = load i64, ptr %count.addr, align 8
  %call1 = call i64 @mi_bitmap_mask_across(i64 noundef %1, i64 noundef %2, i64 noundef %3, ptr noundef %pre_mask, ptr noundef %mid_mask, ptr noundef %post_mask)
  store i64 %call1, ptr %mid_count, align 8
  store i8 1, ptr %all_one, align 1
  %4 = load ptr, ptr %bitmap.addr, align 8
  %5 = load i64, ptr %idx, align 8
  %arrayidx = getelementptr i64, ptr %4, i64 %5
  store ptr %arrayidx, ptr %field, align 8
  %6 = load ptr, ptr %field, align 8
  %incdec.ptr = getelementptr i64, ptr %6, i32 1
  store ptr %incdec.ptr, ptr %field, align 8
  %7 = load i64, ptr %pre_mask, align 8
  %not = xor i64 %7, -1
  store i64 %not, ptr %.atomictmp, align 8
  %8 = load i64, ptr %.atomictmp, align 8
  %9 = atomicrmw and ptr %6, i64 %8 acq_rel, align 8
  store i64 %9, ptr %atomic-temp, align 8
  %10 = load i64, ptr %atomic-temp, align 8
  store i64 %10, ptr %prev, align 8
  %11 = load i64, ptr %prev, align 8
  %12 = load i64, ptr %pre_mask, align 8
  %and = and i64 %11, %12
  %13 = load i64, ptr %pre_mask, align 8
  %cmp = icmp ne i64 %and, %13
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i8 0, ptr %all_one, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  br label %while.cond

while.cond:                                       ; preds = %if.end10, %if.end
  %14 = load i64, ptr %mid_count, align 8
  %dec = add i64 %14, -1
  store i64 %dec, ptr %mid_count, align 8
  %cmp2 = icmp ugt i64 %14, 0
  br i1 %cmp2, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %15 = load ptr, ptr %field, align 8
  %incdec.ptr3 = getelementptr i64, ptr %15, i32 1
  store ptr %incdec.ptr3, ptr %field, align 8
  %16 = load i64, ptr %mid_mask, align 8
  %not5 = xor i64 %16, -1
  store i64 %not5, ptr %.atomictmp4, align 8
  %17 = load i64, ptr %.atomictmp4, align 8
  %18 = atomicrmw and ptr %15, i64 %17 acq_rel, align 8
  store i64 %18, ptr %atomic-temp6, align 8
  %19 = load i64, ptr %atomic-temp6, align 8
  store i64 %19, ptr %prev, align 8
  %20 = load i64, ptr %prev, align 8
  %21 = load i64, ptr %mid_mask, align 8
  %and7 = and i64 %20, %21
  %22 = load i64, ptr %mid_mask, align 8
  %cmp8 = icmp ne i64 %and7, %22
  br i1 %cmp8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %while.body
  store i8 0, ptr %all_one, align 1
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %while.body
  br label %while.cond, !llvm.loop !16

while.end:                                        ; preds = %while.cond
  %23 = load i64, ptr %post_mask, align 8
  %cmp11 = icmp ne i64 %23, 0
  br i1 %cmp11, label %if.then12, label %if.end20

if.then12:                                        ; preds = %while.end
  %24 = load ptr, ptr %field, align 8
  %25 = load i64, ptr %post_mask, align 8
  %not14 = xor i64 %25, -1
  store i64 %not14, ptr %.atomictmp13, align 8
  %26 = load i64, ptr %.atomictmp13, align 8
  %27 = atomicrmw and ptr %24, i64 %26 acq_rel, align 8
  store i64 %27, ptr %atomic-temp15, align 8
  %28 = load i64, ptr %atomic-temp15, align 8
  store i64 %28, ptr %prev, align 8
  %29 = load i64, ptr %prev, align 8
  %30 = load i64, ptr %post_mask, align 8
  %and16 = and i64 %29, %30
  %31 = load i64, ptr %post_mask, align 8
  %cmp17 = icmp ne i64 %and16, %31
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.then12
  store i8 0, ptr %all_one, align 1
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.then12
  br label %if.end20

if.end20:                                         ; preds = %if.end19, %while.end
  %32 = load i8, ptr %all_one, align 1
  %tobool = trunc i8 %32 to i1
  ret i1 %tobool
}

; Function Attrs: nounwind uwtable
define internal void @mi_arena_schedule_purge(ptr noundef %arena, i64 noundef %bitmap_idx, i64 noundef %blocks, ptr noundef %stats) #0 {
entry:
  %arena.addr = alloca ptr, align 8
  %bitmap_idx.addr = alloca i64, align 8
  %blocks.addr = alloca i64, align 8
  %stats.addr = alloca ptr, align 8
  %delay = alloca i64, align 8
  %expire = alloca i64, align 8
  %atomic-temp = alloca i64, align 8
  %.atomictmp = alloca i64, align 8
  %atomic-temp7 = alloca i64, align 8
  %.atomictmp10 = alloca i64, align 8
  store ptr %arena, ptr %arena.addr, align 8
  store i64 %bitmap_idx, ptr %bitmap_idx.addr, align 8
  store i64 %blocks, ptr %blocks.addr, align 8
  store ptr %stats, ptr %stats.addr, align 8
  %call = call i64 @mi_arena_purge_delay()
  store i64 %call, ptr %delay, align 8
  %0 = load i64, ptr %delay, align 8
  %cmp = icmp slt i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end14

if.end:                                           ; preds = %entry
  %call1 = call zeroext i1 @_mi_preloading()
  br i1 %call1, label %if.then3, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %1 = load i64, ptr %delay, align 8
  %cmp2 = icmp eq i64 %1, 0
  br i1 %cmp2, label %if.then3, label %if.else

if.then3:                                         ; preds = %lor.lhs.false, %if.end
  %2 = load ptr, ptr %arena.addr, align 8
  %3 = load i64, ptr %bitmap_idx.addr, align 8
  %4 = load i64, ptr %blocks.addr, align 8
  %5 = load ptr, ptr %stats.addr, align 8
  call void @mi_arena_purge(ptr noundef %2, i64 noundef %3, i64 noundef %4, ptr noundef %5)
  br label %if.end14

if.else:                                          ; preds = %lor.lhs.false
  %6 = load ptr, ptr %arena.addr, align 8
  %purge_expire = getelementptr inbounds %struct.mi_arena_s, ptr %6, i32 0, i32 11
  %7 = load atomic i64, ptr %purge_expire monotonic, align 8
  store i64 %7, ptr %atomic-temp, align 8
  %8 = load i64, ptr %atomic-temp, align 8
  store i64 %8, ptr %expire, align 8
  %9 = load i64, ptr %expire, align 8
  %cmp4 = icmp ne i64 %9, 0
  br i1 %cmp4, label %if.then5, label %if.else8

if.then5:                                         ; preds = %if.else
  %10 = load ptr, ptr %arena.addr, align 8
  %purge_expire6 = getelementptr inbounds %struct.mi_arena_s, ptr %10, i32 0, i32 11
  %11 = load i64, ptr %delay, align 8
  %div = sdiv i64 %11, 10
  store i64 %div, ptr %.atomictmp, align 8
  %12 = load i64, ptr %.atomictmp, align 8
  %13 = atomicrmw add ptr %purge_expire6, i64 %12 acq_rel, align 8
  store i64 %13, ptr %atomic-temp7, align 8
  br label %if.end12

if.else8:                                         ; preds = %if.else
  %14 = load ptr, ptr %arena.addr, align 8
  %purge_expire9 = getelementptr inbounds %struct.mi_arena_s, ptr %14, i32 0, i32 11
  %call11 = call i64 @_mi_clock_now()
  %15 = load i64, ptr %delay, align 8
  %add = add i64 %call11, %15
  store i64 %add, ptr %.atomictmp10, align 8
  %16 = load i64, ptr %.atomictmp10, align 8
  store atomic i64 %16, ptr %purge_expire9 release, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.else8, %if.then5
  %17 = load ptr, ptr %arena.addr, align 8
  %blocks_purge = getelementptr inbounds %struct.mi_arena_s, ptr %17, i32 0, i32 14
  %18 = load ptr, ptr %blocks_purge, align 8
  %19 = load ptr, ptr %arena.addr, align 8
  %field_count = getelementptr inbounds %struct.mi_arena_s, ptr %19, i32 0, i32 4
  %20 = load i64, ptr %field_count, align 8
  %21 = load i64, ptr %blocks.addr, align 8
  %22 = load i64, ptr %bitmap_idx.addr, align 8
  %call13 = call zeroext i1 @_mi_bitmap_claim_across(ptr noundef %18, i64 noundef %20, i64 noundef %21, i64 noundef %22, ptr noundef null)
  br label %if.end14

if.end14:                                         ; preds = %if.end12, %if.then3, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_arenas_try_purge(i1 noundef zeroext %force, i1 noundef zeroext %visit_all, ptr noundef %stats) #0 {
entry:
  %force.addr = alloca i8, align 1
  %visit_all.addr = alloca i8, align 1
  %stats.addr = alloca ptr, align 8
  %max_arena = alloca i64, align 8
  %atomic-temp = alloca i64, align 8
  %_mi_guard_expected = alloca i64, align 8
  %_mi_guard_once = alloca i8, align 1
  %.atomictmp = alloca i64, align 8
  %cmpxchg.bool = alloca i8, align 1
  %now = alloca i64, align 8
  %max_purge_count = alloca i64, align 8
  %i = alloca i64, align 8
  %arena = alloca ptr, align 8
  %atomic-temp13 = alloca ptr, align 8
  %.atomictmp25 = alloca i64, align 8
  %frombool = zext i1 %force to i8
  store i8 %frombool, ptr %force.addr, align 1
  %frombool1 = zext i1 %visit_all to i8
  store i8 %frombool1, ptr %visit_all.addr, align 1
  store ptr %stats, ptr %stats.addr, align 8
  %call = call zeroext i1 @_mi_preloading()
  br i1 %call, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %call2 = call i64 @mi_arena_purge_delay()
  %cmp = icmp sle i64 %call2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %for.end26

if.end:                                           ; preds = %lor.lhs.false
  %0 = load atomic i64, ptr @mi_arena_count acquire, align 64
  store i64 %0, ptr %atomic-temp, align 8
  %1 = load i64, ptr %atomic-temp, align 8
  store i64 %1, ptr %max_arena, align 8
  %2 = load i64, ptr %max_arena, align 8
  %cmp3 = icmp eq i64 %2, 0
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  br label %for.end26

if.end5:                                          ; preds = %if.end
  store i64 0, ptr %_mi_guard_expected, align 8
  store i8 1, ptr %_mi_guard_once, align 1
  br label %for.cond

for.cond:                                         ; preds = %for.inc24, %if.end5
  %3 = load i8, ptr %_mi_guard_once, align 1
  %tobool = trunc i8 %3 to i1
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  store i64 1, ptr %.atomictmp, align 8
  %4 = load i64, ptr %_mi_guard_expected, align 8
  %5 = load i64, ptr %.atomictmp, align 8
  %6 = cmpxchg ptr @mi_arenas_try_purge.purge_guard, i64 %4, i64 %5 acq_rel acquire, align 8
  %7 = extractvalue { i64, i1 } %6, 0
  %8 = extractvalue { i64, i1 } %6, 1
  br i1 %8, label %cmpxchg.continue, label %cmpxchg.store_expected

cmpxchg.store_expected:                           ; preds = %land.rhs
  store i64 %7, ptr %_mi_guard_expected, align 8
  br label %cmpxchg.continue

cmpxchg.continue:                                 ; preds = %cmpxchg.store_expected, %land.rhs
  %frombool6 = zext i1 %8 to i8
  store i8 %frombool6, ptr %cmpxchg.bool, align 1
  %9 = load i8, ptr %cmpxchg.bool, align 1
  %tobool7 = trunc i8 %9 to i1
  br label %land.end

land.end:                                         ; preds = %cmpxchg.continue, %for.cond
  %10 = phi i1 [ false, %for.cond ], [ %tobool7, %cmpxchg.continue ]
  br i1 %10, label %for.body, label %for.end26

for.body:                                         ; preds = %land.end
  %call8 = call i64 @_mi_clock_now()
  store i64 %call8, ptr %now, align 8
  %11 = load i8, ptr %visit_all.addr, align 1
  %tobool9 = trunc i8 %11 to i1
  br i1 %tobool9, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  %12 = load i64, ptr %max_arena, align 8
  br label %cond.end

cond.false:                                       ; preds = %for.body
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %12, %cond.true ], [ 1, %cond.false ]
  store i64 %cond, ptr %max_purge_count, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond10

for.cond10:                                       ; preds = %for.inc, %cond.end
  %13 = load i64, ptr %i, align 8
  %14 = load i64, ptr %max_arena, align 8
  %cmp11 = icmp ult i64 %13, %14
  br i1 %cmp11, label %for.body12, label %for.end

for.body12:                                       ; preds = %for.cond10
  %15 = load i64, ptr %i, align 8
  %arrayidx = getelementptr [112 x ptr], ptr @mi_arenas, i64 0, i64 %15
  %16 = load atomic i64, ptr %arrayidx acquire, align 8
  store i64 %16, ptr %atomic-temp13, align 8
  %17 = load ptr, ptr %atomic-temp13, align 8
  store ptr %17, ptr %arena, align 8
  %18 = load ptr, ptr %arena, align 8
  %cmp14 = icmp ne ptr %18, null
  br i1 %cmp14, label %if.then15, label %if.end23

if.then15:                                        ; preds = %for.body12
  %19 = load ptr, ptr %arena, align 8
  %20 = load i64, ptr %now, align 8
  %21 = load i8, ptr %force.addr, align 1
  %tobool16 = trunc i8 %21 to i1
  %22 = load ptr, ptr %stats.addr, align 8
  %call17 = call zeroext i1 @mi_arena_try_purge(ptr noundef %19, i64 noundef %20, i1 noundef zeroext %tobool16, ptr noundef %22)
  br i1 %call17, label %if.then18, label %if.end22

if.then18:                                        ; preds = %if.then15
  %23 = load i64, ptr %max_purge_count, align 8
  %cmp19 = icmp ule i64 %23, 1
  br i1 %cmp19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %if.then18
  br label %for.end

if.end21:                                         ; preds = %if.then18
  %24 = load i64, ptr %max_purge_count, align 8
  %dec = add i64 %24, -1
  store i64 %dec, ptr %max_purge_count, align 8
  br label %if.end22

if.end22:                                         ; preds = %if.end21, %if.then15
  br label %if.end23

if.end23:                                         ; preds = %if.end22, %for.body12
  br label %for.inc

for.inc:                                          ; preds = %if.end23
  %25 = load i64, ptr %i, align 8
  %inc = add i64 %25, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond10, !llvm.loop !17

for.end:                                          ; preds = %if.then20, %for.cond10
  br label %for.inc24

for.inc24:                                        ; preds = %for.end
  store i64 0, ptr %.atomictmp25, align 8
  %26 = load i64, ptr %.atomictmp25, align 8
  store atomic i64 %26, ptr @mi_arenas_try_purge.purge_guard release, align 8
  store i8 0, ptr %_mi_guard_once, align 1
  br label %for.cond, !llvm.loop !18

for.end26:                                        ; preds = %land.end, %if.then4, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_arena_collect(i1 noundef zeroext %force_purge, ptr noundef %stats) #0 {
entry:
  %force_purge.addr = alloca i8, align 1
  %stats.addr = alloca ptr, align 8
  %frombool = zext i1 %force_purge to i8
  store i8 %frombool, ptr %force_purge.addr, align 1
  store ptr %stats, ptr %stats.addr, align 8
  %0 = load i8, ptr %force_purge.addr, align 1
  %tobool = trunc i8 %0 to i1
  %1 = load ptr, ptr %stats.addr, align 8
  call void @mi_arenas_try_purge(i1 noundef zeroext %tobool, i1 noundef zeroext true, ptr noundef %1)
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_arena_unsafe_destroy_all(ptr noundef %stats) #0 {
entry:
  %stats.addr = alloca ptr, align 8
  store ptr %stats, ptr %stats.addr, align 8
  call void @mi_arenas_unsafe_destroy()
  %0 = load ptr, ptr %stats.addr, align 8
  call void @_mi_arena_collect(i1 noundef zeroext true, ptr noundef %0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_arenas_unsafe_destroy() #0 {
entry:
  %max_arena = alloca i64, align 8
  %atomic-temp = alloca i64, align 8
  %new_max_arena = alloca i64, align 8
  %i = alloca i64, align 8
  %arena = alloca ptr, align 8
  %atomic-temp1 = alloca ptr, align 8
  %.atomictmp = alloca ptr, align 8
  %expected = alloca i64, align 8
  %.atomictmp11 = alloca i64, align 8
  %cmpxchg.bool = alloca i8, align 1
  %0 = load atomic i64, ptr @mi_arena_count monotonic, align 64
  store i64 %0, ptr %atomic-temp, align 8
  %1 = load i64, ptr %atomic-temp, align 8
  store i64 %1, ptr %max_arena, align 8
  store i64 0, ptr %new_max_arena, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i64, ptr %i, align 8
  %3 = load i64, ptr %max_arena, align 8
  %cmp = icmp ult i64 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load i64, ptr %i, align 8
  %arrayidx = getelementptr [112 x ptr], ptr @mi_arenas, i64 0, i64 %4
  %5 = load atomic i64, ptr %arrayidx acquire, align 8
  store i64 %5, ptr %atomic-temp1, align 8
  %6 = load ptr, ptr %atomic-temp1, align 8
  store ptr %6, ptr %arena, align 8
  %7 = load ptr, ptr %arena, align 8
  %cmp2 = icmp ne ptr %7, null
  br i1 %cmp2, label %if.then, label %if.end10

if.then:                                          ; preds = %for.body
  %8 = load ptr, ptr %arena, align 8
  %start = getelementptr inbounds %struct.mi_arena_s, ptr %8, i32 0, i32 2
  %atomic-load = load atomic i64, ptr %start seq_cst, align 8
  %9 = inttoptr i64 %atomic-load to ptr
  %cmp3 = icmp ne ptr %9, null
  br i1 %cmp3, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.then
  %10 = load ptr, ptr %arena, align 8
  %memid = getelementptr inbounds %struct.mi_arena_s, ptr %10, i32 0, i32 1
  %memkind = getelementptr inbounds %struct.mi_memid_s, ptr %memid, i32 0, i32 4
  %11 = load i32, ptr %memkind, align 4
  %call = call zeroext i1 @mi_memkind_is_os(i32 noundef %11)
  br i1 %call, label %if.then4, label %if.else

if.then4:                                         ; preds = %land.lhs.true
  %12 = load i64, ptr %i, align 8
  %arrayidx5 = getelementptr [112 x ptr], ptr @mi_arenas, i64 0, i64 %12
  store ptr null, ptr %.atomictmp, align 8
  %13 = load i64, ptr %.atomictmp, align 8
  store atomic i64 %13, ptr %arrayidx5 release, align 8
  %14 = load ptr, ptr %arena, align 8
  %start6 = getelementptr inbounds %struct.mi_arena_s, ptr %14, i32 0, i32 2
  %atomic-load7 = load atomic i64, ptr %start6 seq_cst, align 8
  %15 = inttoptr i64 %atomic-load7 to ptr
  %16 = load ptr, ptr %arena, align 8
  %call8 = call i64 @mi_arena_size(ptr noundef %16)
  %17 = load ptr, ptr %arena, align 8
  %memid9 = getelementptr inbounds %struct.mi_arena_s, ptr %17, i32 0, i32 1
  call void @_mi_os_free(ptr noundef %15, i64 noundef %call8, ptr noundef byval(%struct.mi_memid_s) align 8 %memid9, ptr noundef @_mi_stats_main)
  br label %if.end

if.else:                                          ; preds = %land.lhs.true, %if.then
  %18 = load i64, ptr %i, align 8
  store i64 %18, ptr %new_max_arena, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then4
  %19 = load ptr, ptr %arena, align 8
  %20 = load ptr, ptr %arena, align 8
  %meta_memid = getelementptr inbounds %struct.mi_arena_s, ptr %20, i32 0, i32 6
  %21 = load ptr, ptr %arena, align 8
  %meta_size = getelementptr inbounds %struct.mi_arena_s, ptr %21, i32 0, i32 5
  %22 = load i64, ptr %meta_size, align 8
  call void @mi_arena_meta_free(ptr noundef %19, ptr noundef byval(%struct.mi_memid_s) align 8 %meta_memid, i64 noundef %22, ptr noundef @_mi_stats_main)
  br label %if.end10

if.end10:                                         ; preds = %if.end, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end10
  %23 = load i64, ptr %i, align 8
  %inc = add i64 %23, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !19

for.end:                                          ; preds = %for.cond
  %24 = load i64, ptr %max_arena, align 8
  store i64 %24, ptr %expected, align 8
  %25 = load i64, ptr %new_max_arena, align 8
  store i64 %25, ptr %.atomictmp11, align 8
  %26 = load i64, ptr %expected, align 8
  %27 = load i64, ptr %.atomictmp11, align 8
  %28 = cmpxchg ptr @mi_arena_count, i64 %26, i64 %27 acq_rel acquire, align 64
  %29 = extractvalue { i64, i1 } %28, 0
  %30 = extractvalue { i64, i1 } %28, 1
  br i1 %30, label %cmpxchg.continue, label %cmpxchg.store_expected

cmpxchg.store_expected:                           ; preds = %for.end
  store i64 %29, ptr %expected, align 8
  br label %cmpxchg.continue

cmpxchg.continue:                                 ; preds = %cmpxchg.store_expected, %for.end
  %frombool = zext i1 %30 to i8
  store i8 %frombool, ptr %cmpxchg.bool, align 1
  ret void
}

; Function Attrs: nounwind uwtable
define hidden zeroext i1 @_mi_arena_contains(ptr noundef %p) #0 {
entry:
  %retval = alloca i1, align 1
  %p.addr = alloca ptr, align 8
  %max_arena = alloca i64, align 8
  %atomic-temp = alloca i64, align 8
  %i = alloca i64, align 8
  %arena = alloca ptr, align 8
  %atomic-temp1 = alloca ptr, align 8
  store ptr %p, ptr %p.addr, align 8
  %0 = load atomic i64, ptr @mi_arena_count monotonic, align 64
  store i64 %0, ptr %atomic-temp, align 8
  %1 = load i64, ptr %atomic-temp, align 8
  store i64 %1, ptr %max_arena, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i64, ptr %i, align 8
  %3 = load i64, ptr %max_arena, align 8
  %cmp = icmp ult i64 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load i64, ptr %i, align 8
  %arrayidx = getelementptr [112 x ptr], ptr @mi_arenas, i64 0, i64 %4
  %5 = load atomic i64, ptr %arrayidx acquire, align 8
  store i64 %5, ptr %atomic-temp1, align 8
  %6 = load ptr, ptr %atomic-temp1, align 8
  store ptr %6, ptr %arena, align 8
  %7 = load ptr, ptr %arena, align 8
  %cmp2 = icmp ne ptr %7, null
  br i1 %cmp2, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.body
  %8 = load ptr, ptr %arena, align 8
  %start = getelementptr inbounds %struct.mi_arena_s, ptr %8, i32 0, i32 2
  %atomic-load = load atomic i64, ptr %start seq_cst, align 8
  %9 = inttoptr i64 %atomic-load to ptr
  %10 = load ptr, ptr %p.addr, align 8
  %cmp3 = icmp ule ptr %9, %10
  br i1 %cmp3, label %land.lhs.true4, label %if.end

land.lhs.true4:                                   ; preds = %land.lhs.true
  %11 = load ptr, ptr %arena, align 8
  %start5 = getelementptr inbounds %struct.mi_arena_s, ptr %11, i32 0, i32 2
  %atomic-load6 = load atomic i64, ptr %start5 seq_cst, align 8
  %12 = inttoptr i64 %atomic-load6 to ptr
  %13 = load ptr, ptr %arena, align 8
  %block_count = getelementptr inbounds %struct.mi_arena_s, ptr %13, i32 0, i32 3
  %14 = load i64, ptr %block_count, align 8
  %call = call i64 @mi_arena_block_size(i64 noundef %14)
  %add.ptr = getelementptr i8, ptr %12, i64 %call
  %15 = load ptr, ptr %p.addr, align 8
  %cmp7 = icmp ugt ptr %add.ptr, %15
  br i1 %cmp7, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true4
  store i1 true, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %land.lhs.true4, %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %16 = load i64, ptr %i, align 8
  %inc = add i64 %16, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !20

for.end:                                          ; preds = %for.cond
  store i1 false, ptr %retval, align 1
  br label %return

return:                                           ; preds = %for.end, %if.then
  %17 = load i1, ptr %retval, align 1
  ret i1 %17
}

; Function Attrs: nounwind uwtable
define hidden zeroext i1 @mi_manage_os_memory_ex(ptr noundef %start, i64 noundef %size, i1 noundef zeroext %is_committed, i1 noundef zeroext %is_large, i1 noundef zeroext %is_zero, i32 noundef %numa_node, i1 noundef zeroext %exclusive, ptr noundef %arena_id) #0 {
entry:
  %start.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %is_committed.addr = alloca i8, align 1
  %is_large.addr = alloca i8, align 1
  %is_zero.addr = alloca i8, align 1
  %numa_node.addr = alloca i32, align 4
  %exclusive.addr = alloca i8, align 1
  %arena_id.addr = alloca ptr, align 8
  %memid = alloca %struct.mi_memid_s, align 8
  store ptr %start, ptr %start.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %frombool = zext i1 %is_committed to i8
  store i8 %frombool, ptr %is_committed.addr, align 1
  %frombool1 = zext i1 %is_large to i8
  store i8 %frombool1, ptr %is_large.addr, align 1
  %frombool2 = zext i1 %is_zero to i8
  store i8 %frombool2, ptr %is_zero.addr, align 1
  store i32 %numa_node, ptr %numa_node.addr, align 4
  %frombool3 = zext i1 %exclusive to i8
  store i8 %frombool3, ptr %exclusive.addr, align 1
  store ptr %arena_id, ptr %arena_id.addr, align 8
  call void @_mi_memid_create(ptr sret(%struct.mi_memid_s) align 8 %memid, i32 noundef 1)
  %0 = load i8, ptr %is_committed.addr, align 1
  %tobool = trunc i8 %0 to i1
  %initially_committed = getelementptr inbounds %struct.mi_memid_s, ptr %memid, i32 0, i32 2
  %frombool4 = zext i1 %tobool to i8
  store i8 %frombool4, ptr %initially_committed, align 1
  %1 = load i8, ptr %is_zero.addr, align 1
  %tobool5 = trunc i8 %1 to i1
  %initially_zero = getelementptr inbounds %struct.mi_memid_s, ptr %memid, i32 0, i32 3
  %frombool6 = zext i1 %tobool5 to i8
  store i8 %frombool6, ptr %initially_zero, align 2
  %2 = load i8, ptr %is_large.addr, align 1
  %tobool7 = trunc i8 %2 to i1
  %is_pinned = getelementptr inbounds %struct.mi_memid_s, ptr %memid, i32 0, i32 1
  %frombool8 = zext i1 %tobool7 to i8
  store i8 %frombool8, ptr %is_pinned, align 8
  %3 = load ptr, ptr %start.addr, align 8
  %4 = load i64, ptr %size.addr, align 8
  %5 = load i8, ptr %is_large.addr, align 1
  %tobool9 = trunc i8 %5 to i1
  %6 = load i32, ptr %numa_node.addr, align 4
  %7 = load i8, ptr %exclusive.addr, align 1
  %tobool10 = trunc i8 %7 to i1
  %8 = load ptr, ptr %arena_id.addr, align 8
  %call = call zeroext i1 @mi_manage_os_memory_ex2(ptr noundef %3, i64 noundef %4, i1 noundef zeroext %tobool9, i32 noundef %6, i1 noundef zeroext %tobool10, ptr noundef byval(%struct.mi_memid_s) align 8 %memid, ptr noundef %8)
  ret i1 %call
}

; Function Attrs: nounwind uwtable
define internal void @_mi_memid_create(ptr noalias sret(%struct.mi_memid_s) align 8 %agg.result, i32 noundef %memkind) #0 {
entry:
  %memkind.addr = alloca i32, align 4
  store i32 %memkind, ptr %memkind.addr, align 4
  call void @llvm.memset.p0.i64(ptr align 8 %agg.result, i8 0, i64 24, i1 false)
  %0 = load i32, ptr %memkind.addr, align 4
  %memkind1 = getelementptr inbounds %struct.mi_memid_s, ptr %agg.result, i32 0, i32 4
  store i32 %0, ptr %memkind1, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_manage_os_memory_ex2(ptr noundef %start, i64 noundef %size, i1 noundef zeroext %is_large, i32 noundef %numa_node, i1 noundef zeroext %exclusive, ptr noundef byval(%struct.mi_memid_s) align 8 %memid, ptr noundef %arena_id) #0 {
entry:
  %retval = alloca i1, align 1
  %start.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %is_large.addr = alloca i8, align 1
  %numa_node.addr = alloca i32, align 4
  %exclusive.addr = alloca i8, align 1
  %arena_id.addr = alloca ptr, align 8
  %bcount = alloca i64, align 8
  %fields = alloca i64, align 8
  %bitmaps = alloca i64, align 8
  %asize = alloca i64, align 8
  %meta_memid = alloca %struct.mi_memid_s, align 8
  %arena = alloca ptr, align 8
  %post = alloca i64, align 8
  %postidx = alloca i64, align 8
  store ptr %start, ptr %start.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %frombool = zext i1 %is_large to i8
  store i8 %frombool, ptr %is_large.addr, align 1
  store i32 %numa_node, ptr %numa_node.addr, align 4
  %frombool1 = zext i1 %exclusive to i8
  store i8 %frombool1, ptr %exclusive.addr, align 1
  store ptr %arena_id, ptr %arena_id.addr, align 8
  %0 = load ptr, ptr %arena_id.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @_mi_arena_id_none()
  %1 = load ptr, ptr %arena_id.addr, align 8
  store i32 %call, ptr %1, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i64, ptr %size.addr, align 8
  %cmp2 = icmp ult i64 %2, 33554432
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store i1 false, ptr %retval, align 1
  br label %return

if.end4:                                          ; preds = %if.end
  %3 = load i8, ptr %is_large.addr, align 1
  %tobool = trunc i8 %3 to i1
  br i1 %tobool, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end4
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %if.end4
  %4 = load i64, ptr %size.addr, align 8
  %div = udiv i64 %4, 33554432
  store i64 %div, ptr %bcount, align 8
  %5 = load i64, ptr %bcount, align 8
  %call7 = call i64 @_mi_divide_up(i64 noundef %5, i64 noundef 64)
  store i64 %call7, ptr %fields, align 8
  %is_pinned = getelementptr inbounds %struct.mi_memid_s, ptr %memid, i32 0, i32 1
  %6 = load i8, ptr %is_pinned, align 8
  %tobool8 = trunc i8 %6 to i1
  %cond = select i1 %tobool8, i32 2, i32 4
  %conv = sext i32 %cond to i64
  store i64 %conv, ptr %bitmaps, align 8
  %7 = load i64, ptr %bitmaps, align 8
  %8 = load i64, ptr %fields, align 8
  %mul = mul i64 %7, %8
  %mul9 = mul i64 %mul, 8
  %add = add i64 144, %mul9
  store i64 %add, ptr %asize, align 8
  %9 = load i64, ptr %asize, align 8
  %call10 = call ptr @mi_arena_meta_zalloc(i64 noundef %9, ptr noundef %meta_memid, ptr noundef @_mi_stats_main)
  store ptr %call10, ptr %arena, align 8
  %10 = load ptr, ptr %arena, align 8
  %cmp11 = icmp eq ptr %10, null
  br i1 %cmp11, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end6
  store i1 false, ptr %retval, align 1
  br label %return

if.end14:                                         ; preds = %if.end6
  %call15 = call i32 @_mi_arena_id_none()
  %11 = load ptr, ptr %arena, align 8
  %id = getelementptr inbounds %struct.mi_arena_s, ptr %11, i32 0, i32 0
  store i32 %call15, ptr %id, align 8
  %12 = load ptr, ptr %arena, align 8
  %memid16 = getelementptr inbounds %struct.mi_arena_s, ptr %12, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %memid16, ptr align 8 %memid, i64 24, i1 false)
  %13 = load i8, ptr %exclusive.addr, align 1
  %tobool17 = trunc i8 %13 to i1
  %14 = load ptr, ptr %arena, align 8
  %exclusive18 = getelementptr inbounds %struct.mi_arena_s, ptr %14, i32 0, i32 8
  %frombool19 = zext i1 %tobool17 to i8
  store i8 %frombool19, ptr %exclusive18, align 4
  %15 = load i64, ptr %asize, align 8
  %16 = load ptr, ptr %arena, align 8
  %meta_size = getelementptr inbounds %struct.mi_arena_s, ptr %16, i32 0, i32 5
  store i64 %15, ptr %meta_size, align 8
  %17 = load ptr, ptr %arena, align 8
  %meta_memid20 = getelementptr inbounds %struct.mi_arena_s, ptr %17, i32 0, i32 6
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %meta_memid20, ptr align 8 %meta_memid, i64 24, i1 false)
  %18 = load i64, ptr %bcount, align 8
  %19 = load ptr, ptr %arena, align 8
  %block_count = getelementptr inbounds %struct.mi_arena_s, ptr %19, i32 0, i32 3
  store i64 %18, ptr %block_count, align 8
  %20 = load i64, ptr %fields, align 8
  %21 = load ptr, ptr %arena, align 8
  %field_count = getelementptr inbounds %struct.mi_arena_s, ptr %21, i32 0, i32 4
  store i64 %20, ptr %field_count, align 8
  %22 = load ptr, ptr %start.addr, align 8
  %23 = load ptr, ptr %arena, align 8
  %start21 = getelementptr inbounds %struct.mi_arena_s, ptr %23, i32 0, i32 2
  %24 = ptrtoint ptr %22 to i64
  store atomic i64 %24, ptr %start21 seq_cst, align 8
  %25 = load i32, ptr %numa_node.addr, align 4
  %26 = load ptr, ptr %arena, align 8
  %numa_node22 = getelementptr inbounds %struct.mi_arena_s, ptr %26, i32 0, i32 7
  store i32 %25, ptr %numa_node22, align 8
  %27 = load i8, ptr %is_large.addr, align 1
  %tobool23 = trunc i8 %27 to i1
  %28 = load ptr, ptr %arena, align 8
  %is_large24 = getelementptr inbounds %struct.mi_arena_s, ptr %28, i32 0, i32 9
  %frombool25 = zext i1 %tobool23 to i8
  store i8 %frombool25, ptr %is_large24, align 1
  %29 = load ptr, ptr %arena, align 8
  %purge_expire = getelementptr inbounds %struct.mi_arena_s, ptr %29, i32 0, i32 11
  store atomic i64 0, ptr %purge_expire seq_cst, align 8
  %30 = load ptr, ptr %arena, align 8
  %search_idx = getelementptr inbounds %struct.mi_arena_s, ptr %30, i32 0, i32 10
  store atomic i64 0, ptr %search_idx seq_cst, align 8
  %31 = load ptr, ptr %arena, align 8
  %blocks_inuse = getelementptr inbounds %struct.mi_arena_s, ptr %31, i32 0, i32 15
  %32 = load i64, ptr %fields, align 8
  %arrayidx = getelementptr [1 x i64], ptr %blocks_inuse, i64 0, i64 %32
  %33 = load ptr, ptr %arena, align 8
  %blocks_dirty = getelementptr inbounds %struct.mi_arena_s, ptr %33, i32 0, i32 12
  store ptr %arrayidx, ptr %blocks_dirty, align 8
  %34 = load ptr, ptr %arena, align 8
  %memid26 = getelementptr inbounds %struct.mi_arena_s, ptr %34, i32 0, i32 1
  %is_pinned27 = getelementptr inbounds %struct.mi_memid_s, ptr %memid26, i32 0, i32 1
  %35 = load i8, ptr %is_pinned27, align 8
  %tobool28 = trunc i8 %35 to i1
  br i1 %tobool28, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end14
  br label %cond.end

cond.false:                                       ; preds = %if.end14
  %36 = load ptr, ptr %arena, align 8
  %blocks_inuse30 = getelementptr inbounds %struct.mi_arena_s, ptr %36, i32 0, i32 15
  %37 = load i64, ptr %fields, align 8
  %mul31 = mul i64 2, %37
  %arrayidx32 = getelementptr [1 x i64], ptr %blocks_inuse30, i64 0, i64 %mul31
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond33 = phi ptr [ null, %cond.true ], [ %arrayidx32, %cond.false ]
  %38 = load ptr, ptr %arena, align 8
  %blocks_committed = getelementptr inbounds %struct.mi_arena_s, ptr %38, i32 0, i32 13
  store ptr %cond33, ptr %blocks_committed, align 8
  %39 = load ptr, ptr %arena, align 8
  %memid34 = getelementptr inbounds %struct.mi_arena_s, ptr %39, i32 0, i32 1
  %is_pinned35 = getelementptr inbounds %struct.mi_memid_s, ptr %memid34, i32 0, i32 1
  %40 = load i8, ptr %is_pinned35, align 8
  %tobool36 = trunc i8 %40 to i1
  br i1 %tobool36, label %cond.true38, label %cond.false39

cond.true38:                                      ; preds = %cond.end
  br label %cond.end43

cond.false39:                                     ; preds = %cond.end
  %41 = load ptr, ptr %arena, align 8
  %blocks_inuse40 = getelementptr inbounds %struct.mi_arena_s, ptr %41, i32 0, i32 15
  %42 = load i64, ptr %fields, align 8
  %mul41 = mul i64 3, %42
  %arrayidx42 = getelementptr [1 x i64], ptr %blocks_inuse40, i64 0, i64 %mul41
  br label %cond.end43

cond.end43:                                       ; preds = %cond.false39, %cond.true38
  %cond44 = phi ptr [ null, %cond.true38 ], [ %arrayidx42, %cond.false39 ]
  %43 = load ptr, ptr %arena, align 8
  %blocks_purge = getelementptr inbounds %struct.mi_arena_s, ptr %43, i32 0, i32 14
  store ptr %cond44, ptr %blocks_purge, align 8
  %44 = load ptr, ptr %arena, align 8
  %blocks_committed45 = getelementptr inbounds %struct.mi_arena_s, ptr %44, i32 0, i32 13
  %45 = load ptr, ptr %blocks_committed45, align 8
  %cmp46 = icmp ne ptr %45, null
  br i1 %cmp46, label %land.lhs.true, label %if.end54

land.lhs.true:                                    ; preds = %cond.end43
  %46 = load ptr, ptr %arena, align 8
  %memid48 = getelementptr inbounds %struct.mi_arena_s, ptr %46, i32 0, i32 1
  %initially_committed = getelementptr inbounds %struct.mi_memid_s, ptr %memid48, i32 0, i32 2
  %47 = load i8, ptr %initially_committed, align 1
  %tobool49 = trunc i8 %47 to i1
  br i1 %tobool49, label %if.then51, label %if.end54

if.then51:                                        ; preds = %land.lhs.true
  %48 = load ptr, ptr %arena, align 8
  %blocks_committed52 = getelementptr inbounds %struct.mi_arena_s, ptr %48, i32 0, i32 13
  %49 = load ptr, ptr %blocks_committed52, align 8
  %50 = load i64, ptr %fields, align 8
  %mul53 = mul i64 %50, 8
  call void @llvm.memset.p0.i64(ptr align 1 %49, i8 -1, i64 %mul53, i1 false)
  br label %if.end54

if.end54:                                         ; preds = %if.then51, %land.lhs.true, %cond.end43
  %51 = load i64, ptr %fields, align 8
  %mul55 = mul i64 %51, 64
  %52 = load i64, ptr %bcount, align 8
  %sub = sub i64 %mul55, %52
  store i64 %sub, ptr %post, align 8
  %53 = load i64, ptr %post, align 8
  %cmp56 = icmp sgt i64 %53, 0
  br i1 %cmp56, label %if.then58, label %if.end64

if.then58:                                        ; preds = %if.end54
  %54 = load i64, ptr %fields, align 8
  %sub59 = sub i64 %54, 1
  %55 = load i64, ptr %post, align 8
  %sub60 = sub i64 64, %55
  %call61 = call i64 @mi_bitmap_index_create(i64 noundef %sub59, i64 noundef %sub60)
  store i64 %call61, ptr %postidx, align 8
  %56 = load ptr, ptr %arena, align 8
  %blocks_inuse62 = getelementptr inbounds %struct.mi_arena_s, ptr %56, i32 0, i32 15
  %arraydecay = getelementptr inbounds [1 x i64], ptr %blocks_inuse62, i64 0, i64 0
  %57 = load i64, ptr %fields, align 8
  %58 = load i64, ptr %post, align 8
  %59 = load i64, ptr %postidx, align 8
  %call63 = call zeroext i1 @_mi_bitmap_claim(ptr noundef %arraydecay, i64 noundef %57, i64 noundef %58, i64 noundef %59, ptr noundef null)
  br label %if.end64

if.end64:                                         ; preds = %if.then58, %if.end54
  %60 = load ptr, ptr %arena, align 8
  %61 = load ptr, ptr %arena_id.addr, align 8
  %call65 = call zeroext i1 @mi_arena_add(ptr noundef %60, ptr noundef %61)
  store i1 %call65, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end64, %if.then13, %if.then3
  %62 = load i1, ptr %retval, align 1
  ret i1 %62
}

; Function Attrs: nounwind uwtable
define hidden i32 @mi_reserve_os_memory_ex(i64 noundef %size, i1 noundef zeroext %commit, i1 noundef zeroext %allow_large, i1 noundef zeroext %exclusive, ptr noundef %arena_id) #0 {
entry:
  %retval = alloca i32, align 4
  %size.addr = alloca i64, align 8
  %commit.addr = alloca i8, align 1
  %allow_large.addr = alloca i8, align 1
  %exclusive.addr = alloca i8, align 1
  %arena_id.addr = alloca ptr, align 8
  %memid = alloca %struct.mi_memid_s, align 8
  %start = alloca ptr, align 8
  %is_large = alloca i8, align 1
  store i64 %size, ptr %size.addr, align 8
  %frombool = zext i1 %commit to i8
  store i8 %frombool, ptr %commit.addr, align 1
  %frombool1 = zext i1 %allow_large to i8
  store i8 %frombool1, ptr %allow_large.addr, align 1
  %frombool2 = zext i1 %exclusive to i8
  store i8 %frombool2, ptr %exclusive.addr, align 1
  store ptr %arena_id, ptr %arena_id.addr, align 8
  %0 = load ptr, ptr %arena_id.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @_mi_arena_id_none()
  %1 = load ptr, ptr %arena_id.addr, align 8
  store i32 %call, ptr %1, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i64, ptr %size.addr, align 8
  %call3 = call i64 @_mi_align_up(i64 noundef %2, i64 noundef 33554432)
  store i64 %call3, ptr %size.addr, align 8
  %3 = load i64, ptr %size.addr, align 8
  %4 = load i8, ptr %commit.addr, align 1
  %tobool = trunc i8 %4 to i1
  %5 = load i8, ptr %allow_large.addr, align 1
  %tobool4 = trunc i8 %5 to i1
  %call5 = call ptr @_mi_os_alloc_aligned(i64 noundef %3, i64 noundef 33554432, i1 noundef zeroext %tobool, i1 noundef zeroext %tobool4, ptr noundef %memid, ptr noundef @_mi_stats_main)
  store ptr %call5, ptr %start, align 8
  %6 = load ptr, ptr %start, align 8
  %cmp6 = icmp eq ptr %6, null
  br i1 %cmp6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end
  store i32 12, ptr %retval, align 4
  br label %return

if.end8:                                          ; preds = %if.end
  %is_pinned = getelementptr inbounds %struct.mi_memid_s, ptr %memid, i32 0, i32 1
  %7 = load i8, ptr %is_pinned, align 8
  %tobool9 = trunc i8 %7 to i1
  %frombool10 = zext i1 %tobool9 to i8
  store i8 %frombool10, ptr %is_large, align 1
  %8 = load ptr, ptr %start, align 8
  %9 = load i64, ptr %size.addr, align 8
  %10 = load i8, ptr %is_large, align 1
  %tobool11 = trunc i8 %10 to i1
  %11 = load i8, ptr %exclusive.addr, align 1
  %tobool12 = trunc i8 %11 to i1
  %12 = load ptr, ptr %arena_id.addr, align 8
  %call13 = call zeroext i1 @mi_manage_os_memory_ex2(ptr noundef %8, i64 noundef %9, i1 noundef zeroext %tobool11, i32 noundef -1, i1 noundef zeroext %tobool12, ptr noundef byval(%struct.mi_memid_s) align 8 %memid, ptr noundef %12)
  br i1 %call13, label %if.end17, label %if.then14

if.then14:                                        ; preds = %if.end8
  %13 = load ptr, ptr %start, align 8
  %14 = load i64, ptr %size.addr, align 8
  %15 = load i8, ptr %commit.addr, align 1
  %tobool15 = trunc i8 %15 to i1
  call void @_mi_os_free_ex(ptr noundef %13, i64 noundef %14, i1 noundef zeroext %tobool15, ptr noundef byval(%struct.mi_memid_s) align 8 %memid, ptr noundef @_mi_stats_main)
  %16 = load i64, ptr %size.addr, align 8
  %call16 = call i64 @_mi_divide_up(i64 noundef %16, i64 noundef 1024)
  call void (ptr, ...) @_mi_verbose_message(ptr noundef @.str.7, i64 noundef %call16)
  store i32 12, ptr %retval, align 4
  br label %return

if.end17:                                         ; preds = %if.end8
  %17 = load i64, ptr %size.addr, align 8
  %call18 = call i64 @_mi_divide_up(i64 noundef %17, i64 noundef 1024)
  %18 = load i8, ptr %is_large, align 1
  %tobool19 = trunc i8 %18 to i1
  %cond = select i1 %tobool19, ptr @.str.9, ptr @.str.10
  call void (ptr, ...) @_mi_verbose_message(ptr noundef @.str.8, i64 noundef %call18, ptr noundef %cond)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end17, %if.then14, %if.then7
  %19 = load i32, ptr %retval, align 4
  ret i32 %19
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_os_free_ex(ptr noundef %addr, i64 noundef %size, i1 noundef zeroext %still_committed, ptr noundef byval(%struct.mi_memid_s) align 8 %memid, ptr noundef %tld_stats) #0 {
entry:
  %addr.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %still_committed.addr = alloca i8, align 1
  %tld_stats.addr = alloca ptr, align 8
  %csize = alloca i64, align 8
  %base = alloca ptr, align 8
  store ptr %addr, ptr %addr.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %frombool = zext i1 %still_committed to i8
  store i8 %frombool, ptr %still_committed.addr, align 1
  store ptr %tld_stats, ptr %tld_stats.addr, align 8
  %memkind = getelementptr inbounds %struct.mi_memid_s, ptr %memid, i32 0, i32 4
  %0 = load i32, ptr %memkind, align 4
  %call = call zeroext i1 @mi_memkind_is_os(i32 noundef %0)
  br i1 %call, label %if.then, label %if.else12

if.then:                                          ; preds = %entry
  %1 = load i64, ptr %size.addr, align 8
  %call1 = call i64 @_mi_os_good_alloc_size(i64 noundef %1)
  store i64 %call1, ptr %csize, align 8
  %2 = load ptr, ptr %addr.addr, align 8
  store ptr %2, ptr %base, align 8
  %mem = getelementptr inbounds %struct.mi_memid_s, ptr %memid, i32 0, i32 0
  %base2 = getelementptr inbounds %struct.mi_memid_os_info, ptr %mem, i32 0, i32 0
  %3 = load ptr, ptr %base2, align 8
  %cmp = icmp ne ptr %3, null
  br i1 %cmp, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %mem4 = getelementptr inbounds %struct.mi_memid_s, ptr %memid, i32 0, i32 0
  %base5 = getelementptr inbounds %struct.mi_memid_os_info, ptr %mem4, i32 0, i32 0
  %4 = load ptr, ptr %base5, align 8
  store ptr %4, ptr %base, align 8
  %5 = load ptr, ptr %addr.addr, align 8
  %mem6 = getelementptr inbounds %struct.mi_memid_s, ptr %memid, i32 0, i32 0
  %base7 = getelementptr inbounds %struct.mi_memid_os_info, ptr %mem6, i32 0, i32 0
  %6 = load ptr, ptr %base7, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %5 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %6 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %7 = load i64, ptr %csize, align 8
  %add = add i64 %7, %sub.ptr.sub
  store i64 %add, ptr %csize, align 8
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.then
  %memkind8 = getelementptr inbounds %struct.mi_memid_s, ptr %memid, i32 0, i32 4
  %8 = load i32, ptr %memkind8, align 4
  %cmp9 = icmp eq i32 %8, 4
  br i1 %cmp9, label %if.then10, label %if.else

if.then10:                                        ; preds = %if.end
  %9 = load ptr, ptr %base, align 8
  %10 = load i64, ptr %csize, align 8
  %11 = load ptr, ptr %tld_stats.addr, align 8
  call void @mi_os_free_huge_os_pages(ptr noundef %9, i64 noundef %10, ptr noundef %11)
  br label %if.end11

if.else:                                          ; preds = %if.end
  %12 = load ptr, ptr %base, align 8
  %13 = load i64, ptr %csize, align 8
  %14 = load i8, ptr %still_committed.addr, align 1
  %tobool = trunc i8 %14 to i1
  %15 = load ptr, ptr %tld_stats.addr, align 8
  call void @mi_os_prim_free(ptr noundef %12, i64 noundef %13, i1 noundef zeroext %tobool, ptr noundef %15)
  br label %if.end11

if.end11:                                         ; preds = %if.else, %if.then10
  br label %if.end13

if.else12:                                        ; preds = %entry
  br label %if.end13

if.end13:                                         ; preds = %if.else12, %if.end11
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_verbose_message(ptr noundef %fmt, ...) #0 {
entry:
  %fmt.addr = alloca ptr, align 8
  %args = alloca [1 x %struct.__va_list_tag], align 16
  store ptr %fmt, ptr %fmt.addr, align 8
  %call = call zeroext i1 @mi_option_is_enabled(i32 noundef 2)
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %args, i64 0, i64 0
  call void @llvm.va_start(ptr %arraydecay)
  %0 = load ptr, ptr %fmt.addr, align 8
  %arraydecay1 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %args, i64 0, i64 0
  call void @mi_vfprintf(ptr noundef null, ptr noundef null, ptr noundef @.str.22, ptr noundef %0, ptr noundef %arraydecay1)
  %arraydecay2 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %args, i64 0, i64 0
  call void @llvm.va_end(ptr %arraydecay2)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @_mi_divide_up(i64 noundef %size, i64 noundef %divider) #0 {
entry:
  %size.addr = alloca i64, align 8
  %divider.addr = alloca i64, align 8
  store i64 %size, ptr %size.addr, align 8
  store i64 %divider, ptr %divider.addr, align 8
  %0 = load i64, ptr %divider.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load i64, ptr %size.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %2 = load i64, ptr %size.addr, align 8
  %3 = load i64, ptr %divider.addr, align 8
  %add = add i64 %2, %3
  %sub = sub i64 %add, 1
  %4 = load i64, ptr %divider.addr, align 8
  %div = udiv i64 %sub, %4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %1, %cond.true ], [ %div, %cond.false ]
  ret i64 %cond
}

; Function Attrs: nounwind uwtable
define hidden zeroext i1 @mi_manage_os_memory(ptr noundef %start, i64 noundef %size, i1 noundef zeroext %is_committed, i1 noundef zeroext %is_large, i1 noundef zeroext %is_zero, i32 noundef %numa_node) #0 {
entry:
  %start.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %is_committed.addr = alloca i8, align 1
  %is_large.addr = alloca i8, align 1
  %is_zero.addr = alloca i8, align 1
  %numa_node.addr = alloca i32, align 4
  store ptr %start, ptr %start.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %frombool = zext i1 %is_committed to i8
  store i8 %frombool, ptr %is_committed.addr, align 1
  %frombool1 = zext i1 %is_large to i8
  store i8 %frombool1, ptr %is_large.addr, align 1
  %frombool2 = zext i1 %is_zero to i8
  store i8 %frombool2, ptr %is_zero.addr, align 1
  store i32 %numa_node, ptr %numa_node.addr, align 4
  %0 = load ptr, ptr %start.addr, align 8
  %1 = load i64, ptr %size.addr, align 8
  %2 = load i8, ptr %is_committed.addr, align 1
  %tobool = trunc i8 %2 to i1
  %3 = load i8, ptr %is_large.addr, align 1
  %tobool3 = trunc i8 %3 to i1
  %4 = load i8, ptr %is_zero.addr, align 1
  %tobool4 = trunc i8 %4 to i1
  %5 = load i32, ptr %numa_node.addr, align 4
  %call = call zeroext i1 @mi_manage_os_memory_ex(ptr noundef %0, i64 noundef %1, i1 noundef zeroext %tobool, i1 noundef zeroext %tobool3, i1 noundef zeroext %tobool4, i32 noundef %5, i1 noundef zeroext false, ptr noundef null)
  ret i1 %call
}

; Function Attrs: nounwind uwtable
define hidden i32 @mi_reserve_os_memory(i64 noundef %size, i1 noundef zeroext %commit, i1 noundef zeroext %allow_large) #0 {
entry:
  %size.addr = alloca i64, align 8
  %commit.addr = alloca i8, align 1
  %allow_large.addr = alloca i8, align 1
  store i64 %size, ptr %size.addr, align 8
  %frombool = zext i1 %commit to i8
  store i8 %frombool, ptr %commit.addr, align 1
  %frombool1 = zext i1 %allow_large to i8
  store i8 %frombool1, ptr %allow_large.addr, align 1
  %0 = load i64, ptr %size.addr, align 8
  %1 = load i8, ptr %commit.addr, align 1
  %tobool = trunc i8 %1 to i1
  %2 = load i8, ptr %allow_large.addr, align 1
  %tobool2 = trunc i8 %2 to i1
  %call = call i32 @mi_reserve_os_memory_ex(i64 noundef %0, i1 noundef zeroext %tobool, i1 noundef zeroext %tobool2, i1 noundef zeroext false, ptr noundef null)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define hidden void @mi_debug_show_arenas() #0 {
entry:
  %max_arenas = alloca i64, align 8
  %atomic-temp = alloca i64, align 8
  %i = alloca i64, align 8
  %arena = alloca ptr, align 8
  %atomic-temp1 = alloca ptr, align 8
  %inuse_count = alloca i64, align 8
  %0 = load atomic i64, ptr @mi_arena_count monotonic, align 64
  store i64 %0, ptr %atomic-temp, align 8
  %1 = load i64, ptr %atomic-temp, align 8
  store i64 %1, ptr %max_arenas, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i64, ptr %i, align 8
  %3 = load i64, ptr %max_arenas, align 8
  %cmp = icmp ult i64 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load i64, ptr %i, align 8
  %arrayidx = getelementptr [112 x ptr], ptr @mi_arenas, i64 0, i64 %4
  %5 = load atomic i64, ptr %arrayidx monotonic, align 8
  store i64 %5, ptr %atomic-temp1, align 8
  %6 = load ptr, ptr %atomic-temp1, align 8
  store ptr %6, ptr %arena, align 8
  %7 = load ptr, ptr %arena, align 8
  %cmp2 = icmp eq ptr %7, null
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %for.end

if.end:                                           ; preds = %for.body
  store i64 0, ptr %inuse_count, align 8
  %8 = load i64, ptr %i, align 8
  %9 = load ptr, ptr %arena, align 8
  %block_count = getelementptr inbounds %struct.mi_arena_s, ptr %9, i32 0, i32 3
  %10 = load i64, ptr %block_count, align 8
  %11 = load ptr, ptr %arena, align 8
  %field_count = getelementptr inbounds %struct.mi_arena_s, ptr %11, i32 0, i32 4
  %12 = load i64, ptr %field_count, align 8
  call void (ptr, ...) @_mi_verbose_message(ptr noundef @.str.11, i64 noundef %8, i64 noundef %10, i64 noundef %12)
  %13 = load ptr, ptr %arena, align 8
  %blocks_inuse = getelementptr inbounds %struct.mi_arena_s, ptr %13, i32 0, i32 15
  %arraydecay = getelementptr inbounds [1 x i64], ptr %blocks_inuse, i64 0, i64 0
  %14 = load ptr, ptr %arena, align 8
  %field_count3 = getelementptr inbounds %struct.mi_arena_s, ptr %14, i32 0, i32 4
  %15 = load i64, ptr %field_count3, align 8
  %call = call i64 @mi_debug_show_bitmap(ptr noundef @.str.12, ptr noundef %arraydecay, i64 noundef %15)
  %16 = load i64, ptr %inuse_count, align 8
  %add = add i64 %16, %call
  store i64 %add, ptr %inuse_count, align 8
  %17 = load i64, ptr %inuse_count, align 8
  call void (ptr, ...) @_mi_verbose_message(ptr noundef @.str.13, i64 noundef %17)
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %18 = load i64, ptr %i, align 8
  %inc = add i64 %18, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !21

for.end:                                          ; preds = %if.then, %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @mi_debug_show_bitmap(ptr noundef %prefix, ptr noundef %fields, i64 noundef %field_count) #0 {
entry:
  %prefix.addr = alloca ptr, align 8
  %fields.addr = alloca ptr, align 8
  %field_count.addr = alloca i64, align 8
  %inuse_count = alloca i64, align 8
  %i = alloca i64, align 8
  %buf = alloca [65 x i8], align 16
  %field = alloca i64, align 8
  %atomic-temp = alloca i64, align 8
  %bit = alloca i64, align 8
  %inuse = alloca i8, align 1
  store ptr %prefix, ptr %prefix.addr, align 8
  store ptr %fields, ptr %fields.addr, align 8
  store i64 %field_count, ptr %field_count.addr, align 8
  store i64 0, ptr %inuse_count, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc9, %entry
  %0 = load i64, ptr %i, align 8
  %1 = load i64, ptr %field_count.addr, align 8
  %cmp = icmp ult i64 %0, %1
  br i1 %cmp, label %for.body, label %for.end11

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr %fields.addr, align 8
  %3 = load i64, ptr %i, align 8
  %arrayidx = getelementptr i64, ptr %2, i64 %3
  %4 = load atomic i64, ptr %arrayidx monotonic, align 8
  store i64 %4, ptr %atomic-temp, align 8
  %5 = load i64, ptr %atomic-temp, align 8
  store i64 %5, ptr %field, align 8
  store i64 0, ptr %bit, align 8
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %6 = load i64, ptr %bit, align 8
  %cmp2 = icmp ult i64 %6, 64
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %7 = load i64, ptr %bit, align 8
  %shl = shl i64 1, %7
  %8 = load i64, ptr %field, align 8
  %and = and i64 %shl, %8
  %cmp4 = icmp ne i64 %and, 0
  %frombool = zext i1 %cmp4 to i8
  store i8 %frombool, ptr %inuse, align 1
  %9 = load i8, ptr %inuse, align 1
  %tobool = trunc i8 %9 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body3
  %10 = load i64, ptr %inuse_count, align 8
  %inc = add i64 %10, 1
  store i64 %inc, ptr %inuse_count, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body3
  %11 = load i8, ptr %inuse, align 1
  %tobool5 = trunc i8 %11 to i1
  %cond = select i1 %tobool5, i32 120, i32 46
  %conv = trunc i32 %cond to i8
  %12 = load i64, ptr %bit, align 8
  %sub = sub i64 63, %12
  %arrayidx6 = getelementptr [65 x i8], ptr %buf, i64 0, i64 %sub
  store i8 %conv, ptr %arrayidx6, align 1
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %13 = load i64, ptr %bit, align 8
  %inc7 = add i64 %13, 1
  store i64 %inc7, ptr %bit, align 8
  br label %for.cond1, !llvm.loop !22

for.end:                                          ; preds = %for.cond1
  %arrayidx8 = getelementptr [65 x i8], ptr %buf, i64 0, i64 64
  store i8 0, ptr %arrayidx8, align 16
  %14 = load ptr, ptr %prefix.addr, align 8
  %arraydecay = getelementptr inbounds [65 x i8], ptr %buf, i64 0, i64 0
  call void (ptr, ...) @_mi_verbose_message(ptr noundef @.str.46, ptr noundef %14, ptr noundef %arraydecay)
  br label %for.inc9

for.inc9:                                         ; preds = %for.end
  %15 = load i64, ptr %i, align 8
  %inc10 = add i64 %15, 1
  store i64 %inc10, ptr %i, align 8
  br label %for.cond, !llvm.loop !23

for.end11:                                        ; preds = %for.cond
  %16 = load i64, ptr %inuse_count, align 8
  ret i64 %16
}

; Function Attrs: nounwind uwtable
define hidden i32 @mi_reserve_huge_os_pages_at_ex(i64 noundef %pages, i32 noundef %numa_node, i64 noundef %timeout_msecs, i1 noundef zeroext %exclusive, ptr noundef %arena_id) #0 {
entry:
  %retval = alloca i32, align 4
  %pages.addr = alloca i64, align 8
  %numa_node.addr = alloca i32, align 4
  %timeout_msecs.addr = alloca i64, align 8
  %exclusive.addr = alloca i8, align 1
  %arena_id.addr = alloca ptr, align 8
  %hsize = alloca i64, align 8
  %pages_reserved = alloca i64, align 8
  %memid = alloca %struct.mi_memid_s, align 8
  %p = alloca ptr, align 8
  store i64 %pages, ptr %pages.addr, align 8
  store i32 %numa_node, ptr %numa_node.addr, align 4
  store i64 %timeout_msecs, ptr %timeout_msecs.addr, align 8
  %frombool = zext i1 %exclusive to i8
  store i8 %frombool, ptr %exclusive.addr, align 1
  store ptr %arena_id, ptr %arena_id.addr, align 8
  %0 = load ptr, ptr %arena_id.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %arena_id.addr, align 8
  store i32 -1, ptr %1, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i64, ptr %pages.addr, align 8
  %cmp1 = icmp eq i64 %2, 0
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  %3 = load i32, ptr %numa_node.addr, align 4
  %cmp4 = icmp slt i32 %3, -1
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end3
  store i32 -1, ptr %numa_node.addr, align 4
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %if.end3
  %4 = load i32, ptr %numa_node.addr, align 4
  %cmp7 = icmp sge i32 %4, 0
  br i1 %cmp7, label %if.then8, label %if.end10

if.then8:                                         ; preds = %if.end6
  %5 = load i32, ptr %numa_node.addr, align 4
  %conv = sext i32 %5 to i64
  %call = call i64 @_mi_os_numa_node_count()
  %rem = urem i64 %conv, %call
  %conv9 = trunc i64 %rem to i32
  store i32 %conv9, ptr %numa_node.addr, align 4
  br label %if.end10

if.end10:                                         ; preds = %if.then8, %if.end6
  store i64 0, ptr %hsize, align 8
  store i64 0, ptr %pages_reserved, align 8
  %6 = load i64, ptr %pages.addr, align 8
  %7 = load i32, ptr %numa_node.addr, align 4
  %8 = load i64, ptr %timeout_msecs.addr, align 8
  %call11 = call ptr @_mi_os_alloc_huge_os_pages(i64 noundef %6, i32 noundef %7, i64 noundef %8, ptr noundef %pages_reserved, ptr noundef %hsize, ptr noundef %memid)
  store ptr %call11, ptr %p, align 8
  %9 = load ptr, ptr %p, align 8
  %cmp12 = icmp eq ptr %9, null
  br i1 %cmp12, label %if.then16, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end10
  %10 = load i64, ptr %pages_reserved, align 8
  %cmp14 = icmp eq i64 %10, 0
  br i1 %cmp14, label %if.then16, label %if.end17

if.then16:                                        ; preds = %lor.lhs.false, %if.end10
  %11 = load i64, ptr %pages.addr, align 8
  call void (ptr, ...) @_mi_warning_message(ptr noundef @.str.14, i64 noundef %11)
  store i32 12, ptr %retval, align 4
  br label %return

if.end17:                                         ; preds = %lor.lhs.false
  %12 = load i32, ptr %numa_node.addr, align 4
  %13 = load i64, ptr %pages_reserved, align 8
  %14 = load i64, ptr %pages.addr, align 8
  call void (ptr, ...) @_mi_verbose_message(ptr noundef @.str.15, i32 noundef %12, i64 noundef %13, i64 noundef %14)
  %15 = load ptr, ptr %p, align 8
  %16 = load i64, ptr %hsize, align 8
  %17 = load i32, ptr %numa_node.addr, align 4
  %18 = load i8, ptr %exclusive.addr, align 1
  %tobool = trunc i8 %18 to i1
  %19 = load ptr, ptr %arena_id.addr, align 8
  %call18 = call zeroext i1 @mi_manage_os_memory_ex2(ptr noundef %15, i64 noundef %16, i1 noundef zeroext true, i32 noundef %17, i1 noundef zeroext %tobool, ptr noundef byval(%struct.mi_memid_s) align 8 %memid, ptr noundef %19)
  br i1 %call18, label %if.end20, label %if.then19

if.then19:                                        ; preds = %if.end17
  %20 = load ptr, ptr %p, align 8
  %21 = load i64, ptr %hsize, align 8
  call void @_mi_os_free(ptr noundef %20, i64 noundef %21, ptr noundef byval(%struct.mi_memid_s) align 8 %memid, ptr noundef @_mi_stats_main)
  store i32 12, ptr %retval, align 4
  br label %return

if.end20:                                         ; preds = %if.end17
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end20, %if.then19, %if.then16, %if.then2
  %22 = load i32, ptr %retval, align 4
  ret i32 %22
}

; Function Attrs: nounwind uwtable
define internal i64 @_mi_os_numa_node_count() #0 {
entry:
  %retval = alloca i64, align 8
  %count = alloca i64, align 8
  %atomic-temp = alloca i64, align 8
  %0 = load atomic i64, ptr @_mi_numa_node_count monotonic, align 8
  store i64 %0, ptr %atomic-temp, align 8
  %1 = load i64, ptr %atomic-temp, align 8
  store i64 %1, ptr %count, align 8
  %2 = load i64, ptr %count, align 8
  %cmp = icmp ugt i64 %2, 0
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load i64, ptr %count, align 8
  store i64 %3, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %call = call i64 @_mi_os_numa_node_count_get()
  store i64 %call, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %4 = load i64, ptr %retval, align 8
  ret i64 %4
}

; Function Attrs: nounwind uwtable
define hidden ptr @_mi_os_alloc_huge_os_pages(i64 noundef %pages, i32 noundef %numa_node, i64 noundef %max_msecs, ptr noundef %pages_reserved, ptr noundef %psize, ptr noundef %memid) #0 {
entry:
  %retval = alloca ptr, align 8
  %pages.addr = alloca i64, align 8
  %numa_node.addr = alloca i32, align 4
  %max_msecs.addr = alloca i64, align 8
  %pages_reserved.addr = alloca ptr, align 8
  %psize.addr = alloca ptr, align 8
  %memid.addr = alloca ptr, align 8
  %tmp = alloca %struct.mi_memid_s, align 8
  %size = alloca i64, align 8
  %start = alloca ptr, align 8
  %start_t = alloca i64, align 8
  %page = alloca i64, align 8
  %all_zero = alloca i8, align 1
  %is_zero = alloca i8, align 1
  %addr = alloca ptr, align 8
  %p = alloca ptr, align 8
  %err = alloca i32, align 4
  %elapsed = alloca i64, align 8
  %estimate = alloca i64, align 8
  %tmp46 = alloca %struct.mi_memid_s, align 8
  store i64 %pages, ptr %pages.addr, align 8
  store i32 %numa_node, ptr %numa_node.addr, align 4
  store i64 %max_msecs, ptr %max_msecs.addr, align 8
  store ptr %pages_reserved, ptr %pages_reserved.addr, align 8
  store ptr %psize, ptr %psize.addr, align 8
  store ptr %memid, ptr %memid.addr, align 8
  %0 = load ptr, ptr %memid.addr, align 8
  call void @_mi_memid_none(ptr sret(%struct.mi_memid_s) align 8 %tmp)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %0, ptr align 8 %tmp, i64 24, i1 false)
  %1 = load ptr, ptr %psize.addr, align 8
  %cmp = icmp ne ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %psize.addr, align 8
  store i64 0, ptr %2, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load ptr, ptr %pages_reserved.addr, align 8
  %cmp1 = icmp ne ptr %3, null
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %4 = load ptr, ptr %pages_reserved.addr, align 8
  store i64 0, ptr %4, align 8
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end
  store i64 0, ptr %size, align 8
  %5 = load i64, ptr %pages.addr, align 8
  %call = call ptr @mi_os_claim_huge_pages(i64 noundef %5, ptr noundef %size)
  store ptr %call, ptr %start, align 8
  %6 = load ptr, ptr %start, align 8
  %cmp4 = icmp eq ptr %6, null
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end3
  store ptr null, ptr %retval, align 8
  br label %return

if.end6:                                          ; preds = %if.end3
  %call7 = call i64 @_mi_clock_start()
  store i64 %call7, ptr %start_t, align 8
  store i64 0, ptr %page, align 8
  store i8 1, ptr %all_zero, align 1
  br label %while.cond

while.cond:                                       ; preds = %if.end36, %if.end6
  %7 = load i64, ptr %page, align 8
  %8 = load i64, ptr %pages.addr, align 8
  %cmp8 = icmp ult i64 %7, %8
  br i1 %cmp8, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  store i8 0, ptr %is_zero, align 1
  %9 = load ptr, ptr %start, align 8
  %10 = load i64, ptr %page, align 8
  %mul = mul i64 %10, 1073741824
  %add.ptr = getelementptr i8, ptr %9, i64 %mul
  store ptr %add.ptr, ptr %addr, align 8
  store ptr null, ptr %p, align 8
  %11 = load ptr, ptr %addr, align 8
  %12 = load i32, ptr %numa_node.addr, align 4
  %call9 = call i32 @_mi_prim_alloc_huge_os_pages(ptr noundef %11, i64 noundef 1073741824, i32 noundef %12, ptr noundef %is_zero, ptr noundef %p)
  store i32 %call9, ptr %err, align 4
  %13 = load i8, ptr %is_zero, align 1
  %tobool = trunc i8 %13 to i1
  br i1 %tobool, label %if.end11, label %if.then10

if.then10:                                        ; preds = %while.body
  store i8 0, ptr %all_zero, align 1
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %while.body
  %14 = load i32, ptr %err, align 4
  %cmp12 = icmp ne i32 %14, 0
  br i1 %cmp12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end11
  %15 = load i32, ptr %err, align 4
  %16 = load i32, ptr %err, align 4
  %17 = load ptr, ptr %addr, align 8
  call void (ptr, ...) @_mi_warning_message(ptr noundef @.str.26, i32 noundef %15, i32 noundef %16, ptr noundef %17, i64 noundef 1073741824)
  br label %while.end

if.end14:                                         ; preds = %if.end11
  %18 = load ptr, ptr %p, align 8
  %19 = load ptr, ptr %addr, align 8
  %cmp15 = icmp ne ptr %18, %19
  br i1 %cmp15, label %if.then16, label %if.end20

if.then16:                                        ; preds = %if.end14
  %20 = load ptr, ptr %p, align 8
  %cmp17 = icmp ne ptr %20, null
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.then16
  %21 = load i64, ptr %page, align 8
  %22 = load ptr, ptr %addr, align 8
  call void (ptr, ...) @_mi_warning_message(ptr noundef @.str.27, i64 noundef %21, ptr noundef %22)
  %23 = load ptr, ptr %p, align 8
  call void @mi_os_prim_free(ptr noundef %23, i64 noundef 1073741824, i1 noundef zeroext true, ptr noundef @_mi_stats_main)
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.then16
  br label %while.end

if.end20:                                         ; preds = %if.end14
  %24 = load i64, ptr %page, align 8
  %inc = add i64 %24, 1
  store i64 %inc, ptr %page, align 8
  call void @_mi_stat_increase(ptr noundef getelementptr inbounds (%struct.mi_stats_s, ptr @_mi_stats_main, i32 0, i32 3), i64 noundef 1073741824)
  call void @_mi_stat_increase(ptr noundef getelementptr inbounds (%struct.mi_stats_s, ptr @_mi_stats_main, i32 0, i32 2), i64 noundef 1073741824)
  %25 = load i64, ptr %max_msecs.addr, align 8
  %cmp21 = icmp sgt i64 %25, 0
  br i1 %cmp21, label %if.then22, label %if.end36

if.then22:                                        ; preds = %if.end20
  %26 = load i64, ptr %start_t, align 8
  %call23 = call i64 @_mi_clock_end(i64 noundef %26)
  store i64 %call23, ptr %elapsed, align 8
  %27 = load i64, ptr %page, align 8
  %cmp24 = icmp uge i64 %27, 1
  br i1 %cmp24, label %if.then25, label %if.end32

if.then25:                                        ; preds = %if.then22
  %28 = load i64, ptr %elapsed, align 8
  %29 = load i64, ptr %page, align 8
  %add = add i64 %29, 1
  %div = udiv i64 %28, %add
  %30 = load i64, ptr %pages.addr, align 8
  %mul26 = mul i64 %div, %30
  store i64 %mul26, ptr %estimate, align 8
  %31 = load i64, ptr %estimate, align 8
  %32 = load i64, ptr %max_msecs.addr, align 8
  %mul27 = mul i64 2, %32
  %cmp28 = icmp sgt i64 %31, %mul27
  br i1 %cmp28, label %if.then29, label %if.end31

if.then29:                                        ; preds = %if.then25
  %33 = load i64, ptr %max_msecs.addr, align 8
  %add30 = add i64 %33, 1
  store i64 %add30, ptr %elapsed, align 8
  br label %if.end31

if.end31:                                         ; preds = %if.then29, %if.then25
  br label %if.end32

if.end32:                                         ; preds = %if.end31, %if.then22
  %34 = load i64, ptr %elapsed, align 8
  %35 = load i64, ptr %max_msecs.addr, align 8
  %cmp33 = icmp sgt i64 %34, %35
  br i1 %cmp33, label %if.then34, label %if.end35

if.then34:                                        ; preds = %if.end32
  %36 = load i64, ptr %page, align 8
  call void (ptr, ...) @_mi_warning_message(ptr noundef @.str.28, i64 noundef %36)
  br label %while.end

if.end35:                                         ; preds = %if.end32
  br label %if.end36

if.end36:                                         ; preds = %if.end35, %if.end20
  br label %while.cond, !llvm.loop !24

while.end:                                        ; preds = %if.then34, %if.end19, %if.then13, %while.cond
  %37 = load ptr, ptr %pages_reserved.addr, align 8
  %cmp37 = icmp ne ptr %37, null
  br i1 %cmp37, label %if.then38, label %if.end39

if.then38:                                        ; preds = %while.end
  %38 = load i64, ptr %page, align 8
  %39 = load ptr, ptr %pages_reserved.addr, align 8
  store i64 %38, ptr %39, align 8
  br label %if.end39

if.end39:                                         ; preds = %if.then38, %while.end
  %40 = load ptr, ptr %psize.addr, align 8
  %cmp40 = icmp ne ptr %40, null
  br i1 %cmp40, label %if.then41, label %if.end43

if.then41:                                        ; preds = %if.end39
  %41 = load i64, ptr %page, align 8
  %mul42 = mul i64 %41, 1073741824
  %42 = load ptr, ptr %psize.addr, align 8
  store i64 %mul42, ptr %42, align 8
  br label %if.end43

if.end43:                                         ; preds = %if.then41, %if.end39
  %43 = load i64, ptr %page, align 8
  %cmp44 = icmp ne i64 %43, 0
  br i1 %cmp44, label %if.then45, label %if.end48

if.then45:                                        ; preds = %if.end43
  %44 = load ptr, ptr %memid.addr, align 8
  %45 = load i8, ptr %all_zero, align 1
  %tobool47 = trunc i8 %45 to i1
  call void @_mi_memid_create_os(ptr sret(%struct.mi_memid_s) align 8 %tmp46, i1 noundef zeroext true, i1 noundef zeroext %tobool47, i1 noundef zeroext true)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %44, ptr align 8 %tmp46, i64 24, i1 false)
  %46 = load ptr, ptr %memid.addr, align 8
  %memkind = getelementptr inbounds %struct.mi_memid_s, ptr %46, i32 0, i32 4
  store i32 4, ptr %memkind, align 4
  br label %if.end48

if.end48:                                         ; preds = %if.then45, %if.end43
  %47 = load i64, ptr %page, align 8
  %cmp49 = icmp eq i64 %47, 0
  br i1 %cmp49, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end48
  br label %cond.end

cond.false:                                       ; preds = %if.end48
  %48 = load ptr, ptr %start, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ null, %cond.true ], [ %48, %cond.false ]
  store ptr %cond, ptr %retval, align 8
  br label %return

return:                                           ; preds = %cond.end, %if.then5
  %49 = load ptr, ptr %retval, align 8
  ret ptr %49
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_warning_message(ptr noundef %fmt, ...) #0 {
entry:
  %fmt.addr = alloca ptr, align 8
  %.atomictmp = alloca i64, align 8
  %atomic-temp = alloca i64, align 8
  %args = alloca [1 x %struct.__va_list_tag], align 16
  store ptr %fmt, ptr %fmt.addr, align 8
  %call = call zeroext i1 @mi_option_is_enabled(i32 noundef 2)
  br i1 %call, label %if.end6, label %if.then

if.then:                                          ; preds = %entry
  %call1 = call zeroext i1 @mi_option_is_enabled(i32 noundef 0)
  br i1 %call1, label %if.end, label %if.then2

if.then2:                                         ; preds = %if.then
  br label %return

if.end:                                           ; preds = %if.then
  %0 = load i64, ptr @mi_max_warning_count, align 8
  %cmp = icmp sge i64 %0, 0
  br i1 %cmp, label %land.lhs.true, label %if.end5

land.lhs.true:                                    ; preds = %if.end
  store i64 1, ptr %.atomictmp, align 8
  %1 = load i64, ptr %.atomictmp, align 8
  %2 = atomicrmw add ptr @warning_count, i64 %1 acq_rel, align 8
  store i64 %2, ptr %atomic-temp, align 8
  %3 = load i64, ptr %atomic-temp, align 8
  %4 = load i64, ptr @mi_max_warning_count, align 8
  %cmp3 = icmp sgt i64 %3, %4
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %land.lhs.true
  br label %return

if.end5:                                          ; preds = %land.lhs.true, %if.end
  br label %if.end6

if.end6:                                          ; preds = %if.end5, %entry
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %args, i64 0, i64 0
  call void @llvm.va_start(ptr %arraydecay)
  %5 = load ptr, ptr %fmt.addr, align 8
  %arraydecay7 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %args, i64 0, i64 0
  call void @mi_vfprintf_thread(ptr noundef null, ptr noundef null, ptr noundef @.str.23, ptr noundef %5, ptr noundef %arraydecay7)
  %arraydecay8 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %args, i64 0, i64 0
  call void @llvm.va_end(ptr %arraydecay8)
  br label %return

return:                                           ; preds = %if.end6, %if.then4, %if.then2
  ret void
}

; Function Attrs: nounwind uwtable
define hidden i32 @mi_reserve_huge_os_pages_at(i64 noundef %pages, i32 noundef %numa_node, i64 noundef %timeout_msecs) #0 {
entry:
  %pages.addr = alloca i64, align 8
  %numa_node.addr = alloca i32, align 4
  %timeout_msecs.addr = alloca i64, align 8
  store i64 %pages, ptr %pages.addr, align 8
  store i32 %numa_node, ptr %numa_node.addr, align 4
  store i64 %timeout_msecs, ptr %timeout_msecs.addr, align 8
  %0 = load i64, ptr %pages.addr, align 8
  %1 = load i32, ptr %numa_node.addr, align 4
  %2 = load i64, ptr %timeout_msecs.addr, align 8
  %call = call i32 @mi_reserve_huge_os_pages_at_ex(i64 noundef %0, i32 noundef %1, i64 noundef %2, i1 noundef zeroext false, ptr noundef null)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define hidden i32 @mi_reserve_huge_os_pages_interleave(i64 noundef %pages, i64 noundef %numa_nodes, i64 noundef %timeout_msecs) #0 {
entry:
  %retval = alloca i32, align 4
  %pages.addr = alloca i64, align 8
  %numa_nodes.addr = alloca i64, align 8
  %timeout_msecs.addr = alloca i64, align 8
  %numa_count = alloca i64, align 8
  %pages_per = alloca i64, align 8
  %pages_mod = alloca i64, align 8
  %timeout_per = alloca i64, align 8
  %numa_node = alloca i64, align 8
  %node_pages = alloca i64, align 8
  %err = alloca i32, align 4
  store i64 %pages, ptr %pages.addr, align 8
  store i64 %numa_nodes, ptr %numa_nodes.addr, align 8
  store i64 %timeout_msecs, ptr %timeout_msecs.addr, align 8
  %0 = load i64, ptr %pages.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, ptr %numa_nodes.addr, align 8
  %cmp1 = icmp ugt i64 %1, 0
  br i1 %cmp1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %2 = load i64, ptr %numa_nodes.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %call = call i64 @_mi_os_numa_node_count()
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %2, %cond.true ], [ %call, %cond.false ]
  store i64 %cond, ptr %numa_count, align 8
  %3 = load i64, ptr %numa_count, align 8
  %cmp2 = icmp ule i64 %3, 0
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %cond.end
  store i64 1, ptr %numa_count, align 8
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %cond.end
  %4 = load i64, ptr %pages.addr, align 8
  %5 = load i64, ptr %numa_count, align 8
  %div = udiv i64 %4, %5
  store i64 %div, ptr %pages_per, align 8
  %6 = load i64, ptr %pages.addr, align 8
  %7 = load i64, ptr %numa_count, align 8
  %rem = urem i64 %6, %7
  store i64 %rem, ptr %pages_mod, align 8
  %8 = load i64, ptr %timeout_msecs.addr, align 8
  %cmp5 = icmp eq i64 %8, 0
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %if.end4
  br label %cond.end9

cond.false7:                                      ; preds = %if.end4
  %9 = load i64, ptr %timeout_msecs.addr, align 8
  %10 = load i64, ptr %numa_count, align 8
  %div8 = udiv i64 %9, %10
  %add = add i64 %div8, 50
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi i64 [ 0, %cond.true6 ], [ %add, %cond.false7 ]
  store i64 %cond10, ptr %timeout_per, align 8
  store i64 0, ptr %numa_node, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end9
  %11 = load i64, ptr %numa_node, align 8
  %12 = load i64, ptr %numa_count, align 8
  %cmp11 = icmp ult i64 %11, %12
  br i1 %cmp11, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %13 = load i64, ptr %pages.addr, align 8
  %cmp12 = icmp ugt i64 %13, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %14 = phi i1 [ false, %for.cond ], [ %cmp12, %land.rhs ]
  br i1 %14, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %15 = load i64, ptr %pages_per, align 8
  store i64 %15, ptr %node_pages, align 8
  %16 = load i64, ptr %numa_node, align 8
  %17 = load i64, ptr %pages_mod, align 8
  %cmp13 = icmp ult i64 %16, %17
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %for.body
  %18 = load i64, ptr %node_pages, align 8
  %inc = add i64 %18, 1
  store i64 %inc, ptr %node_pages, align 8
  br label %if.end15

if.end15:                                         ; preds = %if.then14, %for.body
  %19 = load i64, ptr %node_pages, align 8
  %20 = load i64, ptr %numa_node, align 8
  %conv = trunc i64 %20 to i32
  %21 = load i64, ptr %timeout_per, align 8
  %call16 = call i32 @mi_reserve_huge_os_pages_at(i64 noundef %19, i32 noundef %conv, i64 noundef %21)
  store i32 %call16, ptr %err, align 4
  %22 = load i32, ptr %err, align 4
  %tobool = icmp ne i32 %22, 0
  br i1 %tobool, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end15
  %23 = load i32, ptr %err, align 4
  store i32 %23, ptr %retval, align 4
  br label %return

if.end18:                                         ; preds = %if.end15
  %24 = load i64, ptr %pages.addr, align 8
  %25 = load i64, ptr %node_pages, align 8
  %cmp19 = icmp ult i64 %24, %25
  br i1 %cmp19, label %if.then21, label %if.else

if.then21:                                        ; preds = %if.end18
  store i64 0, ptr %pages.addr, align 8
  br label %if.end22

if.else:                                          ; preds = %if.end18
  %26 = load i64, ptr %node_pages, align 8
  %27 = load i64, ptr %pages.addr, align 8
  %sub = sub i64 %27, %26
  store i64 %sub, ptr %pages.addr, align 8
  br label %if.end22

if.end22:                                         ; preds = %if.else, %if.then21
  br label %for.inc

for.inc:                                          ; preds = %if.end22
  %28 = load i64, ptr %numa_node, align 8
  %inc23 = add i64 %28, 1
  store i64 %inc23, ptr %numa_node, align 8
  br label %for.cond, !llvm.loop !25

for.end:                                          ; preds = %land.end
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then17, %if.then
  %29 = load i32, ptr %retval, align 4
  ret i32 %29
}

; Function Attrs: nounwind uwtable
define hidden i32 @mi_reserve_huge_os_pages(i64 noundef %pages, double noundef %max_secs, ptr noundef %pages_reserved) #0 {
entry:
  %pages.addr = alloca i64, align 8
  %max_secs.addr = alloca double, align 8
  %pages_reserved.addr = alloca ptr, align 8
  %err = alloca i32, align 4
  store i64 %pages, ptr %pages.addr, align 8
  store double %max_secs, ptr %max_secs.addr, align 8
  store ptr %pages_reserved, ptr %pages_reserved.addr, align 8
  call void (ptr, ...) @_mi_warning_message(ptr noundef @.str.16)
  %0 = load ptr, ptr %pages_reserved.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %pages_reserved.addr, align 8
  store i64 0, ptr %1, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i64, ptr %pages.addr, align 8
  %3 = load double, ptr %max_secs.addr, align 8
  %mul = fmul double %3, 1.000000e+03
  %conv = fptoui double %mul to i64
  %call = call i32 @mi_reserve_huge_os_pages_interleave(i64 noundef %2, i64 noundef 0, i64 noundef %conv)
  store i32 %call, ptr %err, align 4
  %4 = load i32, ptr %err, align 4
  %cmp1 = icmp eq i32 %4, 0
  br i1 %cmp1, label %land.lhs.true, label %if.end6

land.lhs.true:                                    ; preds = %if.end
  %5 = load ptr, ptr %pages_reserved.addr, align 8
  %cmp3 = icmp ne ptr %5, null
  br i1 %cmp3, label %if.then5, label %if.end6

if.then5:                                         ; preds = %land.lhs.true
  %6 = load i64, ptr %pages.addr, align 8
  %7 = load ptr, ptr %pages_reserved.addr, align 8
  store i64 %6, ptr %7, align 8
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %land.lhs.true, %if.end
  %8 = load i32, ptr %err, align 4
  ret i32 %8
}

; Function Attrs: nounwind uwtable
define hidden zeroext i1 @_mi_bitmap_try_find_claim_field(ptr noundef %bitmap, i64 noundef %idx, i64 noundef %count, ptr noundef %bitmap_idx) #0 {
entry:
  %retval = alloca i1, align 1
  %bitmap.addr = alloca ptr, align 8
  %idx.addr = alloca i64, align 8
  %count.addr = alloca i64, align 8
  %bitmap_idx.addr = alloca ptr, align 8
  %field = alloca ptr, align 8
  %map = alloca i64, align 8
  %atomic-temp = alloca i64, align 8
  %mask = alloca i64, align 8
  %bitidx_max = alloca i64, align 8
  %bitidx = alloca i64, align 8
  %m = alloca i64, align 8
  %mapm = alloca i64, align 8
  %newmap = alloca i64, align 8
  %.atomictmp = alloca i64, align 8
  %cmpxchg.bool = alloca i8, align 1
  %shift = alloca i64, align 8
  store ptr %bitmap, ptr %bitmap.addr, align 8
  store i64 %idx, ptr %idx.addr, align 8
  store i64 %count, ptr %count.addr, align 8
  store ptr %bitmap_idx, ptr %bitmap_idx.addr, align 8
  %0 = load ptr, ptr %bitmap.addr, align 8
  %1 = load i64, ptr %idx.addr, align 8
  %arrayidx = getelementptr i64, ptr %0, i64 %1
  store ptr %arrayidx, ptr %field, align 8
  %2 = load ptr, ptr %field, align 8
  %3 = load atomic i64, ptr %2 monotonic, align 8
  store i64 %3, ptr %atomic-temp, align 8
  %4 = load i64, ptr %atomic-temp, align 8
  store i64 %4, ptr %map, align 8
  %5 = load i64, ptr %map, align 8
  %cmp = icmp eq i64 %5, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %6 = load i64, ptr %count.addr, align 8
  %call = call i64 @mi_bitmap_mask_(i64 noundef %6, i64 noundef 0)
  store i64 %call, ptr %mask, align 8
  %7 = load i64, ptr %count.addr, align 8
  %sub = sub i64 64, %7
  store i64 %sub, ptr %bitidx_max, align 8
  %8 = load i64, ptr %map, align 8
  %not = xor i64 %8, -1
  %call1 = call i64 @mi_ctz(i64 noundef %not)
  store i64 %call1, ptr %bitidx, align 8
  %9 = load i64, ptr %mask, align 8
  %10 = load i64, ptr %bitidx, align 8
  %shl = shl i64 %9, %10
  store i64 %shl, ptr %m, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end13, %if.then5, %if.end
  %11 = load i64, ptr %bitidx, align 8
  %12 = load i64, ptr %bitidx_max, align 8
  %cmp2 = icmp ule i64 %11, %12
  br i1 %cmp2, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %13 = load i64, ptr %map, align 8
  %14 = load i64, ptr %m, align 8
  %and = and i64 %13, %14
  store i64 %and, ptr %mapm, align 8
  %15 = load i64, ptr %mapm, align 8
  %cmp3 = icmp eq i64 %15, 0
  br i1 %cmp3, label %if.then4, label %if.else7

if.then4:                                         ; preds = %while.body
  %16 = load i64, ptr %map, align 8
  %17 = load i64, ptr %m, align 8
  %or = or i64 %16, %17
  store i64 %or, ptr %newmap, align 8
  %18 = load ptr, ptr %field, align 8
  %19 = load i64, ptr %newmap, align 8
  store i64 %19, ptr %.atomictmp, align 8
  %20 = load i64, ptr %map, align 8
  %21 = load i64, ptr %.atomictmp, align 8
  %22 = cmpxchg ptr %18, i64 %20, i64 %21 acq_rel acquire, align 8
  %23 = extractvalue { i64, i1 } %22, 0
  %24 = extractvalue { i64, i1 } %22, 1
  br i1 %24, label %cmpxchg.continue, label %cmpxchg.store_expected

cmpxchg.store_expected:                           ; preds = %if.then4
  store i64 %23, ptr %map, align 8
  br label %cmpxchg.continue

cmpxchg.continue:                                 ; preds = %cmpxchg.store_expected, %if.then4
  %frombool = zext i1 %24 to i8
  store i8 %frombool, ptr %cmpxchg.bool, align 1
  %25 = load i8, ptr %cmpxchg.bool, align 1
  %tobool = trunc i8 %25 to i1
  br i1 %tobool, label %if.else, label %if.then5

if.then5:                                         ; preds = %cmpxchg.continue
  br label %while.cond, !llvm.loop !26

if.else:                                          ; preds = %cmpxchg.continue
  %26 = load i64, ptr %idx.addr, align 8
  %27 = load i64, ptr %bitidx, align 8
  %call6 = call i64 @mi_bitmap_index_create(i64 noundef %26, i64 noundef %27)
  %28 = load ptr, ptr %bitmap_idx.addr, align 8
  store i64 %call6, ptr %28, align 8
  store i1 true, ptr %retval, align 1
  br label %return

if.else7:                                         ; preds = %while.body
  %29 = load i64, ptr %count.addr, align 8
  %cmp8 = icmp eq i64 %29, 1
  br i1 %cmp8, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.else7
  br label %cond.end

cond.false:                                       ; preds = %if.else7
  %30 = load i64, ptr %mapm, align 8
  %call9 = call i64 @mi_clz(i64 noundef %30)
  %sub10 = sub i64 64, %call9
  %31 = load i64, ptr %bitidx, align 8
  %sub11 = sub i64 %sub10, %31
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ 1, %cond.true ], [ %sub11, %cond.false ]
  store i64 %cond, ptr %shift, align 8
  %32 = load i64, ptr %shift, align 8
  %33 = load i64, ptr %bitidx, align 8
  %add = add i64 %33, %32
  store i64 %add, ptr %bitidx, align 8
  %34 = load i64, ptr %shift, align 8
  %35 = load i64, ptr %m, align 8
  %shl12 = shl i64 %35, %34
  store i64 %shl12, ptr %m, align 8
  br label %if.end13

if.end13:                                         ; preds = %cond.end
  br label %while.cond, !llvm.loop !26

while.end:                                        ; preds = %while.cond
  store i1 false, ptr %retval, align 1
  br label %return

return:                                           ; preds = %while.end, %if.else, %if.then
  %36 = load i1, ptr %retval, align 1
  ret i1 %36
}

; Function Attrs: nounwind uwtable
define internal i64 @mi_bitmap_mask_(i64 noundef %count, i64 noundef %bitidx) #0 {
entry:
  %retval = alloca i64, align 8
  %count.addr = alloca i64, align 8
  %bitidx.addr = alloca i64, align 8
  store i64 %count, ptr %count.addr, align 8
  store i64 %bitidx, ptr %bitidx.addr, align 8
  %0 = load i64, ptr %count.addr, align 8
  %cmp = icmp uge i64 %0, 64
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 -1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, ptr %count.addr, align 8
  %cmp1 = icmp eq i64 %1, 0
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i64 0, ptr %retval, align 8
  br label %return

if.end3:                                          ; preds = %if.end
  %2 = load i64, ptr %count.addr, align 8
  %shl = shl i64 1, %2
  %sub = sub i64 %shl, 1
  %3 = load i64, ptr %bitidx.addr, align 8
  %shl4 = shl i64 %sub, %3
  store i64 %shl4, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end3, %if.then2, %if.then
  %4 = load i64, ptr %retval, align 8
  ret i64 %4
}

; Function Attrs: nounwind uwtable
define internal i64 @mi_ctz(i64 noundef %x) #0 {
entry:
  %retval = alloca i64, align 8
  %x.addr = alloca i64, align 8
  store i64 %x, ptr %x.addr, align 8
  %0 = load i64, ptr %x.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 64, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, ptr %x.addr, align 8
  %2 = call i64 @llvm.cttz.i64(i64 %1, i1 true)
  %cast = trunc i64 %2 to i32
  %conv = sext i32 %cast to i64
  store i64 %conv, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load i64, ptr %retval, align 8
  ret i64 %3
}

; Function Attrs: nounwind uwtable
define internal i64 @mi_bitmap_index_create(i64 noundef %idx, i64 noundef %bitidx) #0 {
entry:
  %idx.addr = alloca i64, align 8
  %bitidx.addr = alloca i64, align 8
  store i64 %idx, ptr %idx.addr, align 8
  store i64 %bitidx, ptr %bitidx.addr, align 8
  %0 = load i64, ptr %idx.addr, align 8
  %mul = mul i64 %0, 64
  %1 = load i64, ptr %bitidx.addr, align 8
  %add = add i64 %mul, %1
  ret i64 %add
}

; Function Attrs: nounwind uwtable
define internal i64 @mi_clz(i64 noundef %x) #0 {
entry:
  %retval = alloca i64, align 8
  %x.addr = alloca i64, align 8
  store i64 %x, ptr %x.addr, align 8
  %0 = load i64, ptr %x.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 64, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, ptr %x.addr, align 8
  %2 = call i64 @llvm.ctlz.i64(i64 %1, i1 true)
  %cast = trunc i64 %2 to i32
  %conv = sext i32 %cast to i64
  store i64 %conv, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load i64, ptr %retval, align 8
  ret i64 %3
}

; Function Attrs: nounwind uwtable
define hidden zeroext i1 @_mi_bitmap_try_find_from_claim(ptr noundef %bitmap, i64 noundef %bitmap_fields, i64 noundef %start_field_idx, i64 noundef %count, ptr noundef %bitmap_idx) #0 {
entry:
  %retval = alloca i1, align 1
  %bitmap.addr = alloca ptr, align 8
  %bitmap_fields.addr = alloca i64, align 8
  %start_field_idx.addr = alloca i64, align 8
  %count.addr = alloca i64, align 8
  %bitmap_idx.addr = alloca ptr, align 8
  %idx = alloca i64, align 8
  %visited = alloca i64, align 8
  store ptr %bitmap, ptr %bitmap.addr, align 8
  store i64 %bitmap_fields, ptr %bitmap_fields.addr, align 8
  store i64 %start_field_idx, ptr %start_field_idx.addr, align 8
  store i64 %count, ptr %count.addr, align 8
  store ptr %bitmap_idx, ptr %bitmap_idx.addr, align 8
  %0 = load i64, ptr %start_field_idx.addr, align 8
  store i64 %0, ptr %idx, align 8
  store i64 0, ptr %visited, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i64, ptr %visited, align 8
  %2 = load i64, ptr %bitmap_fields.addr, align 8
  %cmp = icmp ult i64 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i64, ptr %idx, align 8
  %4 = load i64, ptr %bitmap_fields.addr, align 8
  %cmp1 = icmp uge i64 %3, %4
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  store i64 0, ptr %idx, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  %5 = load ptr, ptr %bitmap.addr, align 8
  %6 = load i64, ptr %idx, align 8
  %7 = load i64, ptr %count.addr, align 8
  %8 = load ptr, ptr %bitmap_idx.addr, align 8
  %call = call zeroext i1 @_mi_bitmap_try_find_claim_field(ptr noundef %5, i64 noundef %6, i64 noundef %7, ptr noundef %8)
  br i1 %call, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i1 true, ptr %retval, align 1
  br label %return

if.end3:                                          ; preds = %if.end
  br label %for.inc

for.inc:                                          ; preds = %if.end3
  %9 = load i64, ptr %visited, align 8
  %inc = add i64 %9, 1
  store i64 %inc, ptr %visited, align 8
  %10 = load i64, ptr %idx, align 8
  %inc4 = add i64 %10, 1
  store i64 %inc4, ptr %idx, align 8
  br label %for.cond, !llvm.loop !27

for.end:                                          ; preds = %for.cond
  store i1 false, ptr %retval, align 1
  br label %return

return:                                           ; preds = %for.end, %if.then2
  %11 = load i1, ptr %retval, align 1
  ret i1 %11
}

; Function Attrs: nounwind uwtable
define hidden zeroext i1 @_mi_bitmap_try_find_from_claim_pred(ptr noundef %bitmap, i64 noundef %bitmap_fields, i64 noundef %start_field_idx, i64 noundef %count, ptr noundef %pred_fun, ptr noundef %pred_arg, ptr noundef %bitmap_idx) #0 {
entry:
  %retval = alloca i1, align 1
  %bitmap.addr = alloca ptr, align 8
  %bitmap_fields.addr = alloca i64, align 8
  %start_field_idx.addr = alloca i64, align 8
  %count.addr = alloca i64, align 8
  %pred_fun.addr = alloca ptr, align 8
  %pred_arg.addr = alloca ptr, align 8
  %bitmap_idx.addr = alloca ptr, align 8
  %idx = alloca i64, align 8
  %visited = alloca i64, align 8
  store ptr %bitmap, ptr %bitmap.addr, align 8
  store i64 %bitmap_fields, ptr %bitmap_fields.addr, align 8
  store i64 %start_field_idx, ptr %start_field_idx.addr, align 8
  store i64 %count, ptr %count.addr, align 8
  store ptr %pred_fun, ptr %pred_fun.addr, align 8
  store ptr %pred_arg, ptr %pred_arg.addr, align 8
  store ptr %bitmap_idx, ptr %bitmap_idx.addr, align 8
  %0 = load i64, ptr %start_field_idx.addr, align 8
  store i64 %0, ptr %idx, align 8
  store i64 0, ptr %visited, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i64, ptr %visited, align 8
  %2 = load i64, ptr %bitmap_fields.addr, align 8
  %cmp = icmp ult i64 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i64, ptr %idx, align 8
  %4 = load i64, ptr %bitmap_fields.addr, align 8
  %cmp1 = icmp uge i64 %3, %4
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  store i64 0, ptr %idx, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  %5 = load ptr, ptr %bitmap.addr, align 8
  %6 = load i64, ptr %idx, align 8
  %7 = load i64, ptr %count.addr, align 8
  %8 = load ptr, ptr %bitmap_idx.addr, align 8
  %call = call zeroext i1 @_mi_bitmap_try_find_claim_field(ptr noundef %5, i64 noundef %6, i64 noundef %7, ptr noundef %8)
  br i1 %call, label %if.then2, label %if.end8

if.then2:                                         ; preds = %if.end
  %9 = load ptr, ptr %pred_fun.addr, align 8
  %cmp3 = icmp eq ptr %9, null
  br i1 %cmp3, label %if.then5, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then2
  %10 = load ptr, ptr %pred_fun.addr, align 8
  %11 = load ptr, ptr %bitmap_idx.addr, align 8
  %12 = load i64, ptr %11, align 8
  %13 = load ptr, ptr %pred_arg.addr, align 8
  %call4 = call zeroext i1 %10(i64 noundef %12, ptr noundef %13)
  br i1 %call4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %lor.lhs.false, %if.then2
  store i1 true, ptr %retval, align 1
  br label %return

if.end6:                                          ; preds = %lor.lhs.false
  %14 = load ptr, ptr %bitmap.addr, align 8
  %15 = load i64, ptr %bitmap_fields.addr, align 8
  %16 = load i64, ptr %count.addr, align 8
  %17 = load ptr, ptr %bitmap_idx.addr, align 8
  %18 = load i64, ptr %17, align 8
  %call7 = call zeroext i1 @_mi_bitmap_unclaim(ptr noundef %14, i64 noundef %15, i64 noundef %16, i64 noundef %18)
  br label %if.end8

if.end8:                                          ; preds = %if.end6, %if.end
  br label %for.inc

for.inc:                                          ; preds = %if.end8
  %19 = load i64, ptr %visited, align 8
  %inc = add i64 %19, 1
  store i64 %inc, ptr %visited, align 8
  %20 = load i64, ptr %idx, align 8
  %inc9 = add i64 %20, 1
  store i64 %inc9, ptr %idx, align 8
  br label %for.cond, !llvm.loop !28

for.end:                                          ; preds = %for.cond
  store i1 false, ptr %retval, align 1
  br label %return

return:                                           ; preds = %for.end, %if.then5
  %21 = load i1, ptr %retval, align 1
  ret i1 %21
}

; Function Attrs: nounwind uwtable
define hidden zeroext i1 @_mi_bitmap_unclaim(ptr noundef %bitmap, i64 noundef %bitmap_fields, i64 noundef %count, i64 noundef %bitmap_idx) #0 {
entry:
  %bitmap.addr = alloca ptr, align 8
  %bitmap_fields.addr = alloca i64, align 8
  %count.addr = alloca i64, align 8
  %bitmap_idx.addr = alloca i64, align 8
  %idx = alloca i64, align 8
  %bitidx = alloca i64, align 8
  %mask = alloca i64, align 8
  %prev = alloca i64, align 8
  %.atomictmp = alloca i64, align 8
  %atomic-temp = alloca i64, align 8
  store ptr %bitmap, ptr %bitmap.addr, align 8
  store i64 %bitmap_fields, ptr %bitmap_fields.addr, align 8
  store i64 %count, ptr %count.addr, align 8
  store i64 %bitmap_idx, ptr %bitmap_idx.addr, align 8
  %0 = load i64, ptr %bitmap_idx.addr, align 8
  %call = call i64 @mi_bitmap_index_field(i64 noundef %0)
  store i64 %call, ptr %idx, align 8
  %1 = load i64, ptr %bitmap_idx.addr, align 8
  %call1 = call i64 @mi_bitmap_index_bit_in_field(i64 noundef %1)
  store i64 %call1, ptr %bitidx, align 8
  %2 = load i64, ptr %count.addr, align 8
  %3 = load i64, ptr %bitidx, align 8
  %call2 = call i64 @mi_bitmap_mask_(i64 noundef %2, i64 noundef %3)
  store i64 %call2, ptr %mask, align 8
  %4 = load ptr, ptr %bitmap.addr, align 8
  %5 = load i64, ptr %idx, align 8
  %arrayidx = getelementptr i64, ptr %4, i64 %5
  %6 = load i64, ptr %mask, align 8
  %not = xor i64 %6, -1
  store i64 %not, ptr %.atomictmp, align 8
  %7 = load i64, ptr %.atomictmp, align 8
  %8 = atomicrmw and ptr %arrayidx, i64 %7 acq_rel, align 8
  store i64 %8, ptr %atomic-temp, align 8
  %9 = load i64, ptr %atomic-temp, align 8
  store i64 %9, ptr %prev, align 8
  %10 = load i64, ptr %prev, align 8
  %11 = load i64, ptr %mask, align 8
  %and = and i64 %10, %11
  %12 = load i64, ptr %mask, align 8
  %cmp = icmp eq i64 %and, %12
  ret i1 %cmp
}

; Function Attrs: nounwind uwtable
define internal i64 @mi_bitmap_index_bit_in_field(i64 noundef %bitmap_idx) #0 {
entry:
  %bitmap_idx.addr = alloca i64, align 8
  store i64 %bitmap_idx, ptr %bitmap_idx.addr, align 8
  %0 = load i64, ptr %bitmap_idx.addr, align 8
  %rem = urem i64 %0, 64
  ret i64 %rem
}

; Function Attrs: nounwind uwtable
define hidden zeroext i1 @_mi_bitmap_claim(ptr noundef %bitmap, i64 noundef %bitmap_fields, i64 noundef %count, i64 noundef %bitmap_idx, ptr noundef %any_zero) #0 {
entry:
  %bitmap.addr = alloca ptr, align 8
  %bitmap_fields.addr = alloca i64, align 8
  %count.addr = alloca i64, align 8
  %bitmap_idx.addr = alloca i64, align 8
  %any_zero.addr = alloca ptr, align 8
  %idx = alloca i64, align 8
  %bitidx = alloca i64, align 8
  %mask = alloca i64, align 8
  %prev = alloca i64, align 8
  %.atomictmp = alloca i64, align 8
  %atomic-temp = alloca i64, align 8
  store ptr %bitmap, ptr %bitmap.addr, align 8
  store i64 %bitmap_fields, ptr %bitmap_fields.addr, align 8
  store i64 %count, ptr %count.addr, align 8
  store i64 %bitmap_idx, ptr %bitmap_idx.addr, align 8
  store ptr %any_zero, ptr %any_zero.addr, align 8
  %0 = load i64, ptr %bitmap_idx.addr, align 8
  %call = call i64 @mi_bitmap_index_field(i64 noundef %0)
  store i64 %call, ptr %idx, align 8
  %1 = load i64, ptr %bitmap_idx.addr, align 8
  %call1 = call i64 @mi_bitmap_index_bit_in_field(i64 noundef %1)
  store i64 %call1, ptr %bitidx, align 8
  %2 = load i64, ptr %count.addr, align 8
  %3 = load i64, ptr %bitidx, align 8
  %call2 = call i64 @mi_bitmap_mask_(i64 noundef %2, i64 noundef %3)
  store i64 %call2, ptr %mask, align 8
  %4 = load ptr, ptr %bitmap.addr, align 8
  %5 = load i64, ptr %idx, align 8
  %arrayidx = getelementptr i64, ptr %4, i64 %5
  %6 = load i64, ptr %mask, align 8
  store i64 %6, ptr %.atomictmp, align 8
  %7 = load i64, ptr %.atomictmp, align 8
  %8 = atomicrmw or ptr %arrayidx, i64 %7 acq_rel, align 8
  store i64 %8, ptr %atomic-temp, align 8
  %9 = load i64, ptr %atomic-temp, align 8
  store i64 %9, ptr %prev, align 8
  %10 = load ptr, ptr %any_zero.addr, align 8
  %cmp = icmp ne ptr %10, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %11 = load i64, ptr %prev, align 8
  %12 = load i64, ptr %mask, align 8
  %and = and i64 %11, %12
  %13 = load i64, ptr %mask, align 8
  %cmp3 = icmp ne i64 %and, %13
  %14 = load ptr, ptr %any_zero.addr, align 8
  %frombool = zext i1 %cmp3 to i8
  store i8 %frombool, ptr %14, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %15 = load i64, ptr %prev, align 8
  %16 = load i64, ptr %mask, align 8
  %and4 = and i64 %15, %16
  %cmp5 = icmp eq i64 %and4, 0
  ret i1 %cmp5
}

; Function Attrs: nounwind uwtable
define hidden zeroext i1 @_mi_bitmap_try_claim(ptr noundef %bitmap, i64 noundef %bitmap_fields, i64 noundef %count, i64 noundef %bitmap_idx) #0 {
entry:
  %retval = alloca i1, align 1
  %bitmap.addr = alloca ptr, align 8
  %bitmap_fields.addr = alloca i64, align 8
  %count.addr = alloca i64, align 8
  %bitmap_idx.addr = alloca i64, align 8
  %idx = alloca i64, align 8
  %bitidx = alloca i64, align 8
  %mask = alloca i64, align 8
  %expected = alloca i64, align 8
  %atomic-temp = alloca i64, align 8
  %.atomictmp = alloca i64, align 8
  %cmpxchg.bool = alloca i8, align 1
  store ptr %bitmap, ptr %bitmap.addr, align 8
  store i64 %bitmap_fields, ptr %bitmap_fields.addr, align 8
  store i64 %count, ptr %count.addr, align 8
  store i64 %bitmap_idx, ptr %bitmap_idx.addr, align 8
  %0 = load i64, ptr %bitmap_idx.addr, align 8
  %call = call i64 @mi_bitmap_index_field(i64 noundef %0)
  store i64 %call, ptr %idx, align 8
  %1 = load i64, ptr %bitmap_idx.addr, align 8
  %call1 = call i64 @mi_bitmap_index_bit_in_field(i64 noundef %1)
  store i64 %call1, ptr %bitidx, align 8
  %2 = load i64, ptr %count.addr, align 8
  %3 = load i64, ptr %bitidx, align 8
  %call2 = call i64 @mi_bitmap_mask_(i64 noundef %2, i64 noundef %3)
  store i64 %call2, ptr %mask, align 8
  %4 = load ptr, ptr %bitmap.addr, align 8
  %5 = load i64, ptr %idx, align 8
  %arrayidx = getelementptr i64, ptr %4, i64 %5
  %6 = load atomic i64, ptr %arrayidx monotonic, align 8
  store i64 %6, ptr %atomic-temp, align 8
  %7 = load i64, ptr %atomic-temp, align 8
  store i64 %7, ptr %expected, align 8
  br label %do.body

do.body:                                          ; preds = %cmpxchg.continue, %entry
  %8 = load i64, ptr %expected, align 8
  %9 = load i64, ptr %mask, align 8
  %and = and i64 %8, %9
  %cmp = icmp ne i64 %and, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  %10 = load ptr, ptr %bitmap.addr, align 8
  %11 = load i64, ptr %idx, align 8
  %arrayidx3 = getelementptr i64, ptr %10, i64 %11
  %12 = load i64, ptr %expected, align 8
  %13 = load i64, ptr %mask, align 8
  %or = or i64 %12, %13
  store i64 %or, ptr %.atomictmp, align 8
  %14 = load i64, ptr %expected, align 8
  %15 = load i64, ptr %.atomictmp, align 8
  %16 = cmpxchg ptr %arrayidx3, i64 %14, i64 %15 acq_rel acquire, align 8
  %17 = extractvalue { i64, i1 } %16, 0
  %18 = extractvalue { i64, i1 } %16, 1
  br i1 %18, label %cmpxchg.continue, label %cmpxchg.store_expected

cmpxchg.store_expected:                           ; preds = %do.cond
  store i64 %17, ptr %expected, align 8
  br label %cmpxchg.continue

cmpxchg.continue:                                 ; preds = %cmpxchg.store_expected, %do.cond
  %frombool = zext i1 %18 to i8
  store i8 %frombool, ptr %cmpxchg.bool, align 1
  %19 = load i8, ptr %cmpxchg.bool, align 1
  %tobool = trunc i8 %19 to i1
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %do.body, label %do.end, !llvm.loop !29

do.end:                                           ; preds = %cmpxchg.continue
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %do.end, %if.then
  %20 = load i1, ptr %retval, align 1
  ret i1 %20
}

; Function Attrs: nounwind uwtable
define hidden zeroext i1 @_mi_bitmap_is_claimed(ptr noundef %bitmap, i64 noundef %bitmap_fields, i64 noundef %count, i64 noundef %bitmap_idx) #0 {
entry:
  %bitmap.addr = alloca ptr, align 8
  %bitmap_fields.addr = alloca i64, align 8
  %count.addr = alloca i64, align 8
  %bitmap_idx.addr = alloca i64, align 8
  store ptr %bitmap, ptr %bitmap.addr, align 8
  store i64 %bitmap_fields, ptr %bitmap_fields.addr, align 8
  store i64 %count, ptr %count.addr, align 8
  store i64 %bitmap_idx, ptr %bitmap_idx.addr, align 8
  %0 = load ptr, ptr %bitmap.addr, align 8
  %1 = load i64, ptr %bitmap_fields.addr, align 8
  %2 = load i64, ptr %count.addr, align 8
  %3 = load i64, ptr %bitmap_idx.addr, align 8
  %call = call zeroext i1 @mi_bitmap_is_claimedx(ptr noundef %0, i64 noundef %1, i64 noundef %2, i64 noundef %3, ptr noundef null)
  ret i1 %call
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_bitmap_is_claimedx(ptr noundef %bitmap, i64 noundef %bitmap_fields, i64 noundef %count, i64 noundef %bitmap_idx, ptr noundef %any_ones) #0 {
entry:
  %bitmap.addr = alloca ptr, align 8
  %bitmap_fields.addr = alloca i64, align 8
  %count.addr = alloca i64, align 8
  %bitmap_idx.addr = alloca i64, align 8
  %any_ones.addr = alloca ptr, align 8
  %idx = alloca i64, align 8
  %bitidx = alloca i64, align 8
  %mask = alloca i64, align 8
  %field = alloca i64, align 8
  %atomic-temp = alloca i64, align 8
  store ptr %bitmap, ptr %bitmap.addr, align 8
  store i64 %bitmap_fields, ptr %bitmap_fields.addr, align 8
  store i64 %count, ptr %count.addr, align 8
  store i64 %bitmap_idx, ptr %bitmap_idx.addr, align 8
  store ptr %any_ones, ptr %any_ones.addr, align 8
  %0 = load i64, ptr %bitmap_idx.addr, align 8
  %call = call i64 @mi_bitmap_index_field(i64 noundef %0)
  store i64 %call, ptr %idx, align 8
  %1 = load i64, ptr %bitmap_idx.addr, align 8
  %call1 = call i64 @mi_bitmap_index_bit_in_field(i64 noundef %1)
  store i64 %call1, ptr %bitidx, align 8
  %2 = load i64, ptr %count.addr, align 8
  %3 = load i64, ptr %bitidx, align 8
  %call2 = call i64 @mi_bitmap_mask_(i64 noundef %2, i64 noundef %3)
  store i64 %call2, ptr %mask, align 8
  %4 = load ptr, ptr %bitmap.addr, align 8
  %5 = load i64, ptr %idx, align 8
  %arrayidx = getelementptr i64, ptr %4, i64 %5
  %6 = load atomic i64, ptr %arrayidx monotonic, align 8
  store i64 %6, ptr %atomic-temp, align 8
  %7 = load i64, ptr %atomic-temp, align 8
  store i64 %7, ptr %field, align 8
  %8 = load ptr, ptr %any_ones.addr, align 8
  %cmp = icmp ne ptr %8, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %9 = load i64, ptr %field, align 8
  %10 = load i64, ptr %mask, align 8
  %and = and i64 %9, %10
  %cmp3 = icmp ne i64 %and, 0
  %11 = load ptr, ptr %any_ones.addr, align 8
  %frombool = zext i1 %cmp3 to i8
  store i8 %frombool, ptr %11, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %12 = load i64, ptr %field, align 8
  %13 = load i64, ptr %mask, align 8
  %and4 = and i64 %12, %13
  %14 = load i64, ptr %mask, align 8
  %cmp5 = icmp eq i64 %and4, %14
  ret i1 %cmp5
}

; Function Attrs: nounwind uwtable
define hidden zeroext i1 @_mi_bitmap_is_any_claimed(ptr noundef %bitmap, i64 noundef %bitmap_fields, i64 noundef %count, i64 noundef %bitmap_idx) #0 {
entry:
  %bitmap.addr = alloca ptr, align 8
  %bitmap_fields.addr = alloca i64, align 8
  %count.addr = alloca i64, align 8
  %bitmap_idx.addr = alloca i64, align 8
  %any_ones = alloca i8, align 1
  store ptr %bitmap, ptr %bitmap.addr, align 8
  store i64 %bitmap_fields, ptr %bitmap_fields.addr, align 8
  store i64 %count, ptr %count.addr, align 8
  store i64 %bitmap_idx, ptr %bitmap_idx.addr, align 8
  %0 = load ptr, ptr %bitmap.addr, align 8
  %1 = load i64, ptr %bitmap_fields.addr, align 8
  %2 = load i64, ptr %count.addr, align 8
  %3 = load i64, ptr %bitmap_idx.addr, align 8
  %call = call zeroext i1 @mi_bitmap_is_claimedx(ptr noundef %0, i64 noundef %1, i64 noundef %2, i64 noundef %3, ptr noundef %any_ones)
  %4 = load i8, ptr %any_ones, align 1
  %tobool = trunc i8 %4 to i1
  ret i1 %tobool
}

; Function Attrs: nounwind uwtable
define hidden zeroext i1 @_mi_bitmap_try_find_from_claim_across(ptr noundef %bitmap, i64 noundef %bitmap_fields, i64 noundef %start_field_idx, i64 noundef %count, ptr noundef %bitmap_idx) #0 {
entry:
  %retval = alloca i1, align 1
  %bitmap.addr = alloca ptr, align 8
  %bitmap_fields.addr = alloca i64, align 8
  %start_field_idx.addr = alloca i64, align 8
  %count.addr = alloca i64, align 8
  %bitmap_idx.addr = alloca ptr, align 8
  %idx = alloca i64, align 8
  %visited = alloca i64, align 8
  store ptr %bitmap, ptr %bitmap.addr, align 8
  store i64 %bitmap_fields, ptr %bitmap_fields.addr, align 8
  store i64 %start_field_idx, ptr %start_field_idx.addr, align 8
  store i64 %count, ptr %count.addr, align 8
  store ptr %bitmap_idx, ptr %bitmap_idx.addr, align 8
  %0 = load i64, ptr %count.addr, align 8
  %cmp = icmp ule i64 %0, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %bitmap.addr, align 8
  %2 = load i64, ptr %bitmap_fields.addr, align 8
  %3 = load i64, ptr %start_field_idx.addr, align 8
  %4 = load i64, ptr %count.addr, align 8
  %5 = load ptr, ptr %bitmap_idx.addr, align 8
  %call = call zeroext i1 @_mi_bitmap_try_find_from_claim(ptr noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4, ptr noundef %5)
  store i1 %call, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %6 = load i64, ptr %start_field_idx.addr, align 8
  store i64 %6, ptr %idx, align 8
  store i64 0, ptr %visited, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %7 = load i64, ptr %visited, align 8
  %8 = load i64, ptr %bitmap_fields.addr, align 8
  %cmp1 = icmp ult i64 %7, %8
  br i1 %cmp1, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load i64, ptr %idx, align 8
  %10 = load i64, ptr %bitmap_fields.addr, align 8
  %cmp2 = icmp uge i64 %9, %10
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %for.body
  store i64 0, ptr %idx, align 8
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %for.body
  %11 = load i64, ptr %count.addr, align 8
  %cmp5 = icmp ule i64 %11, 64
  br i1 %cmp5, label %if.then6, label %if.end10

if.then6:                                         ; preds = %if.end4
  %12 = load ptr, ptr %bitmap.addr, align 8
  %13 = load i64, ptr %idx, align 8
  %14 = load i64, ptr %count.addr, align 8
  %15 = load ptr, ptr %bitmap_idx.addr, align 8
  %call7 = call zeroext i1 @_mi_bitmap_try_find_claim_field(ptr noundef %12, i64 noundef %13, i64 noundef %14, ptr noundef %15)
  br i1 %call7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.then6
  store i1 true, ptr %retval, align 1
  br label %return

if.end9:                                          ; preds = %if.then6
  br label %if.end10

if.end10:                                         ; preds = %if.end9, %if.end4
  %16 = load ptr, ptr %bitmap.addr, align 8
  %17 = load i64, ptr %bitmap_fields.addr, align 8
  %18 = load i64, ptr %idx, align 8
  %19 = load i64, ptr %count.addr, align 8
  %20 = load ptr, ptr %bitmap_idx.addr, align 8
  %call11 = call zeroext i1 @mi_bitmap_try_find_claim_field_across(ptr noundef %16, i64 noundef %17, i64 noundef %18, i64 noundef %19, i64 noundef 0, ptr noundef %20)
  br i1 %call11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end10
  store i1 true, ptr %retval, align 1
  br label %return

if.end13:                                         ; preds = %if.end10
  br label %for.inc

for.inc:                                          ; preds = %if.end13
  %21 = load i64, ptr %visited, align 8
  %inc = add i64 %21, 1
  store i64 %inc, ptr %visited, align 8
  %22 = load i64, ptr %idx, align 8
  %inc14 = add i64 %22, 1
  store i64 %inc14, ptr %idx, align 8
  br label %for.cond, !llvm.loop !30

for.end:                                          ; preds = %for.cond
  store i1 false, ptr %retval, align 1
  br label %return

return:                                           ; preds = %for.end, %if.then12, %if.then8, %if.then
  %23 = load i1, ptr %retval, align 1
  ret i1 %23
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_bitmap_try_find_claim_field_across(ptr noundef %bitmap, i64 noundef %bitmap_fields, i64 noundef %idx, i64 noundef %count, i64 noundef %retries, ptr noundef %bitmap_idx) #0 {
entry:
  %retval = alloca i1, align 1
  %bitmap.addr = alloca ptr, align 8
  %bitmap_fields.addr = alloca i64, align 8
  %idx.addr = alloca i64, align 8
  %count.addr = alloca i64, align 8
  %retries.addr = alloca i64, align 8
  %bitmap_idx.addr = alloca ptr, align 8
  %field = alloca ptr, align 8
  %map = alloca i64, align 8
  %atomic-temp = alloca i64, align 8
  %initial = alloca i64, align 8
  %found = alloca i64, align 8
  %mask = alloca i64, align 8
  %atomic-temp11 = alloca i64, align 8
  %mask_bits = alloca i64, align 8
  %final_field = alloca ptr, align 8
  %final_mask = alloca i64, align 8
  %initial_field = alloca ptr, align 8
  %initial_idx = alloca i64, align 8
  %initial_mask = alloca i64, align 8
  %newmap = alloca i64, align 8
  %atomic-temp22 = alloca i64, align 8
  %.atomictmp = alloca i64, align 8
  %cmpxchg.bool = alloca i8, align 1
  %.atomictmp31 = alloca i64, align 8
  %cmpxchg.bool32 = alloca i8, align 1
  %atomic-temp40 = alloca i64, align 8
  %.atomictmp48 = alloca i64, align 8
  %cmpxchg.bool49 = alloca i8, align 1
  %.atomictmp61 = alloca i64, align 8
  %atomic-temp65 = alloca i64, align 8
  %.atomictmp69 = alloca i64, align 8
  %cmpxchg.bool70 = alloca i8, align 1
  store ptr %bitmap, ptr %bitmap.addr, align 8
  store i64 %bitmap_fields, ptr %bitmap_fields.addr, align 8
  store i64 %idx, ptr %idx.addr, align 8
  store i64 %count, ptr %count.addr, align 8
  store i64 %retries, ptr %retries.addr, align 8
  store ptr %bitmap_idx, ptr %bitmap_idx.addr, align 8
  %0 = load ptr, ptr %bitmap.addr, align 8
  %1 = load i64, ptr %idx.addr, align 8
  %arrayidx = getelementptr i64, ptr %0, i64 %1
  store ptr %arrayidx, ptr %field, align 8
  %2 = load ptr, ptr %field, align 8
  %3 = load atomic i64, ptr %2 monotonic, align 8
  store i64 %3, ptr %atomic-temp, align 8
  %4 = load i64, ptr %atomic-temp, align 8
  store i64 %4, ptr %map, align 8
  %5 = load i64, ptr %map, align 8
  %call = call i64 @mi_clz(i64 noundef %5)
  store i64 %call, ptr %initial, align 8
  %6 = load i64, ptr %initial, align 8
  %cmp = icmp eq i64 %6, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %7 = load i64, ptr %initial, align 8
  %8 = load i64, ptr %count.addr, align 8
  %cmp1 = icmp uge i64 %7, %8
  br i1 %cmp1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %9 = load ptr, ptr %bitmap.addr, align 8
  %10 = load i64, ptr %idx.addr, align 8
  %11 = load i64, ptr %count.addr, align 8
  %12 = load ptr, ptr %bitmap_idx.addr, align 8
  %call3 = call zeroext i1 @_mi_bitmap_try_find_claim_field(ptr noundef %9, i64 noundef %10, i64 noundef %11, ptr noundef %12)
  store i1 %call3, ptr %retval, align 1
  br label %return

if.end4:                                          ; preds = %if.end
  %13 = load i64, ptr %count.addr, align 8
  %14 = load i64, ptr %initial, align 8
  %sub = sub i64 %13, %14
  %call5 = call i64 @_mi_divide_up(i64 noundef %sub, i64 noundef 64)
  %15 = load i64, ptr %bitmap_fields.addr, align 8
  %16 = load i64, ptr %idx.addr, align 8
  %sub6 = sub i64 %15, %16
  %cmp7 = icmp uge i64 %call5, %sub6
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end4
  store i1 false, ptr %retval, align 1
  br label %return

if.end9:                                          ; preds = %if.end4
  %17 = load i64, ptr %initial, align 8
  store i64 %17, ptr %found, align 8
  store i64 0, ptr %mask, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end17, %if.end9
  %18 = load i64, ptr %found, align 8
  %19 = load i64, ptr %count.addr, align 8
  %cmp10 = icmp ult i64 %18, %19
  br i1 %cmp10, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %20 = load ptr, ptr %field, align 8
  %incdec.ptr = getelementptr i64, ptr %20, i32 1
  store ptr %incdec.ptr, ptr %field, align 8
  %21 = load ptr, ptr %field, align 8
  %22 = load atomic i64, ptr %21 monotonic, align 8
  store i64 %22, ptr %atomic-temp11, align 8
  %23 = load i64, ptr %atomic-temp11, align 8
  store i64 %23, ptr %map, align 8
  %24 = load i64, ptr %found, align 8
  %add = add i64 %24, 64
  %25 = load i64, ptr %count.addr, align 8
  %cmp12 = icmp ule i64 %add, %25
  br i1 %cmp12, label %cond.true, label %cond.false

cond.true:                                        ; preds = %while.body
  br label %cond.end

cond.false:                                       ; preds = %while.body
  %26 = load i64, ptr %count.addr, align 8
  %27 = load i64, ptr %found, align 8
  %sub13 = sub i64 %26, %27
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ 64, %cond.true ], [ %sub13, %cond.false ]
  store i64 %cond, ptr %mask_bits, align 8
  %28 = load i64, ptr %mask_bits, align 8
  %call14 = call i64 @mi_bitmap_mask_(i64 noundef %28, i64 noundef 0)
  store i64 %call14, ptr %mask, align 8
  %29 = load i64, ptr %map, align 8
  %30 = load i64, ptr %mask, align 8
  %and = and i64 %29, %30
  %cmp15 = icmp ne i64 %and, 0
  br i1 %cmp15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %cond.end
  store i1 false, ptr %retval, align 1
  br label %return

if.end17:                                         ; preds = %cond.end
  %31 = load i64, ptr %mask_bits, align 8
  %32 = load i64, ptr %found, align 8
  %add18 = add i64 %32, %31
  store i64 %add18, ptr %found, align 8
  br label %while.cond, !llvm.loop !31

while.end:                                        ; preds = %while.cond
  %33 = load ptr, ptr %field, align 8
  store ptr %33, ptr %final_field, align 8
  %34 = load i64, ptr %mask, align 8
  store i64 %34, ptr %final_mask, align 8
  %35 = load ptr, ptr %bitmap.addr, align 8
  %36 = load i64, ptr %idx.addr, align 8
  %arrayidx19 = getelementptr i64, ptr %35, i64 %36
  store ptr %arrayidx19, ptr %initial_field, align 8
  %37 = load i64, ptr %initial, align 8
  %sub20 = sub i64 64, %37
  store i64 %sub20, ptr %initial_idx, align 8
  %38 = load i64, ptr %initial, align 8
  %39 = load i64, ptr %initial_idx, align 8
  %call21 = call i64 @mi_bitmap_mask_(i64 noundef %38, i64 noundef %39)
  store i64 %call21, ptr %initial_mask, align 8
  %40 = load ptr, ptr %initial_field, align 8
  store ptr %40, ptr %field, align 8
  %41 = load ptr, ptr %field, align 8
  %42 = load atomic i64, ptr %41 monotonic, align 8
  store i64 %42, ptr %atomic-temp22, align 8
  %43 = load i64, ptr %atomic-temp22, align 8
  store i64 %43, ptr %map, align 8
  br label %do.body

do.body:                                          ; preds = %cmpxchg.continue, %while.end
  %44 = load i64, ptr %map, align 8
  %45 = load i64, ptr %initial_mask, align 8
  %or = or i64 %44, %45
  store i64 %or, ptr %newmap, align 8
  %46 = load i64, ptr %map, align 8
  %47 = load i64, ptr %initial_mask, align 8
  %and23 = and i64 %46, %47
  %cmp24 = icmp ne i64 %and23, 0
  br i1 %cmp24, label %if.then25, label %if.end26

if.then25:                                        ; preds = %do.body
  br label %rollback

if.end26:                                         ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end26
  %48 = load ptr, ptr %field, align 8
  %49 = load i64, ptr %newmap, align 8
  store i64 %49, ptr %.atomictmp, align 8
  %50 = load i64, ptr %map, align 8
  %51 = load i64, ptr %.atomictmp, align 8
  %52 = cmpxchg ptr %48, i64 %50, i64 %51 acq_rel acquire, align 8
  %53 = extractvalue { i64, i1 } %52, 0
  %54 = extractvalue { i64, i1 } %52, 1
  br i1 %54, label %cmpxchg.continue, label %cmpxchg.store_expected

cmpxchg.store_expected:                           ; preds = %do.cond
  store i64 %53, ptr %map, align 8
  br label %cmpxchg.continue

cmpxchg.continue:                                 ; preds = %cmpxchg.store_expected, %do.cond
  %frombool = zext i1 %54 to i8
  store i8 %frombool, ptr %cmpxchg.bool, align 1
  %55 = load i8, ptr %cmpxchg.bool, align 1
  %tobool = trunc i8 %55 to i1
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %do.body, label %do.end, !llvm.loop !32

do.end:                                           ; preds = %cmpxchg.continue
  br label %while.cond27

while.cond27:                                     ; preds = %if.end38, %do.end
  %56 = load ptr, ptr %field, align 8
  %incdec.ptr28 = getelementptr i64, ptr %56, i32 1
  store ptr %incdec.ptr28, ptr %field, align 8
  %57 = load ptr, ptr %final_field, align 8
  %cmp29 = icmp ult ptr %incdec.ptr28, %57
  br i1 %cmp29, label %while.body30, label %while.end39

while.body30:                                     ; preds = %while.cond27
  store i64 -1, ptr %newmap, align 8
  store i64 0, ptr %map, align 8
  %58 = load ptr, ptr %field, align 8
  %59 = load i64, ptr %newmap, align 8
  store i64 %59, ptr %.atomictmp31, align 8
  %60 = load i64, ptr %map, align 8
  %61 = load i64, ptr %.atomictmp31, align 8
  %62 = cmpxchg ptr %58, i64 %60, i64 %61 acq_rel acquire, align 8
  %63 = extractvalue { i64, i1 } %62, 0
  %64 = extractvalue { i64, i1 } %62, 1
  br i1 %64, label %cmpxchg.continue34, label %cmpxchg.store_expected33

cmpxchg.store_expected33:                         ; preds = %while.body30
  store i64 %63, ptr %map, align 8
  br label %cmpxchg.continue34

cmpxchg.continue34:                               ; preds = %cmpxchg.store_expected33, %while.body30
  %frombool35 = zext i1 %64 to i8
  store i8 %frombool35, ptr %cmpxchg.bool32, align 1
  %65 = load i8, ptr %cmpxchg.bool32, align 1
  %tobool36 = trunc i8 %65 to i1
  br i1 %tobool36, label %if.end38, label %if.then37

if.then37:                                        ; preds = %cmpxchg.continue34
  br label %rollback

if.end38:                                         ; preds = %cmpxchg.continue34
  br label %while.cond27, !llvm.loop !33

while.end39:                                      ; preds = %while.cond27
  %66 = load ptr, ptr %field, align 8
  %67 = load atomic i64, ptr %66 monotonic, align 8
  store i64 %67, ptr %atomic-temp40, align 8
  %68 = load i64, ptr %atomic-temp40, align 8
  store i64 %68, ptr %map, align 8
  br label %do.body41

do.body41:                                        ; preds = %cmpxchg.continue51, %while.end39
  %69 = load i64, ptr %map, align 8
  %70 = load i64, ptr %final_mask, align 8
  %or42 = or i64 %69, %70
  store i64 %or42, ptr %newmap, align 8
  %71 = load i64, ptr %map, align 8
  %72 = load i64, ptr %final_mask, align 8
  %and43 = and i64 %71, %72
  %cmp44 = icmp ne i64 %and43, 0
  br i1 %cmp44, label %if.then45, label %if.end46

if.then45:                                        ; preds = %do.body41
  br label %rollback

if.end46:                                         ; preds = %do.body41
  br label %do.cond47

do.cond47:                                        ; preds = %if.end46
  %73 = load ptr, ptr %field, align 8
  %74 = load i64, ptr %newmap, align 8
  store i64 %74, ptr %.atomictmp48, align 8
  %75 = load i64, ptr %map, align 8
  %76 = load i64, ptr %.atomictmp48, align 8
  %77 = cmpxchg ptr %73, i64 %75, i64 %76 acq_rel acquire, align 8
  %78 = extractvalue { i64, i1 } %77, 0
  %79 = extractvalue { i64, i1 } %77, 1
  br i1 %79, label %cmpxchg.continue51, label %cmpxchg.store_expected50

cmpxchg.store_expected50:                         ; preds = %do.cond47
  store i64 %78, ptr %map, align 8
  br label %cmpxchg.continue51

cmpxchg.continue51:                               ; preds = %cmpxchg.store_expected50, %do.cond47
  %frombool52 = zext i1 %79 to i8
  store i8 %frombool52, ptr %cmpxchg.bool49, align 1
  %80 = load i8, ptr %cmpxchg.bool49, align 1
  %tobool53 = trunc i8 %80 to i1
  %lnot54 = xor i1 %tobool53, true
  br i1 %lnot54, label %do.body41, label %do.end55, !llvm.loop !34

do.end55:                                         ; preds = %cmpxchg.continue51
  %81 = load i64, ptr %idx.addr, align 8
  %82 = load i64, ptr %initial_idx, align 8
  %call56 = call i64 @mi_bitmap_index_create(i64 noundef %81, i64 noundef %82)
  %83 = load ptr, ptr %bitmap_idx.addr, align 8
  store i64 %call56, ptr %83, align 8
  store i1 true, ptr %retval, align 1
  br label %return

rollback:                                         ; preds = %if.then45, %if.then37, %if.then25
  br label %while.cond57

while.cond57:                                     ; preds = %while.body60, %rollback
  %84 = load ptr, ptr %field, align 8
  %incdec.ptr58 = getelementptr i64, ptr %84, i32 -1
  store ptr %incdec.ptr58, ptr %field, align 8
  %85 = load ptr, ptr %initial_field, align 8
  %cmp59 = icmp ugt ptr %incdec.ptr58, %85
  br i1 %cmp59, label %while.body60, label %while.end62

while.body60:                                     ; preds = %while.cond57
  store i64 0, ptr %newmap, align 8
  store i64 -1, ptr %map, align 8
  %86 = load ptr, ptr %field, align 8
  %87 = load i64, ptr %newmap, align 8
  store i64 %87, ptr %.atomictmp61, align 8
  %88 = load i64, ptr %.atomictmp61, align 8
  store atomic i64 %88, ptr %86 release, align 8
  br label %while.cond57, !llvm.loop !35

while.end62:                                      ; preds = %while.cond57
  %89 = load ptr, ptr %field, align 8
  %90 = load ptr, ptr %initial_field, align 8
  %cmp63 = icmp eq ptr %89, %90
  br i1 %cmp63, label %if.then64, label %if.end77

if.then64:                                        ; preds = %while.end62
  %91 = load ptr, ptr %field, align 8
  %92 = load atomic i64, ptr %91 monotonic, align 8
  store i64 %92, ptr %atomic-temp65, align 8
  %93 = load i64, ptr %atomic-temp65, align 8
  store i64 %93, ptr %map, align 8
  br label %do.body66

do.body66:                                        ; preds = %cmpxchg.continue72, %if.then64
  %94 = load i64, ptr %map, align 8
  %95 = load i64, ptr %initial_mask, align 8
  %not = xor i64 %95, -1
  %and67 = and i64 %94, %not
  store i64 %and67, ptr %newmap, align 8
  br label %do.cond68

do.cond68:                                        ; preds = %do.body66
  %96 = load ptr, ptr %field, align 8
  %97 = load i64, ptr %newmap, align 8
  store i64 %97, ptr %.atomictmp69, align 8
  %98 = load i64, ptr %map, align 8
  %99 = load i64, ptr %.atomictmp69, align 8
  %100 = cmpxchg ptr %96, i64 %98, i64 %99 acq_rel acquire, align 8
  %101 = extractvalue { i64, i1 } %100, 0
  %102 = extractvalue { i64, i1 } %100, 1
  br i1 %102, label %cmpxchg.continue72, label %cmpxchg.store_expected71

cmpxchg.store_expected71:                         ; preds = %do.cond68
  store i64 %101, ptr %map, align 8
  br label %cmpxchg.continue72

cmpxchg.continue72:                               ; preds = %cmpxchg.store_expected71, %do.cond68
  %frombool73 = zext i1 %102 to i8
  store i8 %frombool73, ptr %cmpxchg.bool70, align 1
  %103 = load i8, ptr %cmpxchg.bool70, align 1
  %tobool74 = trunc i8 %103 to i1
  %lnot75 = xor i1 %tobool74, true
  br i1 %lnot75, label %do.body66, label %do.end76, !llvm.loop !36

do.end76:                                         ; preds = %cmpxchg.continue72
  br label %if.end77

if.end77:                                         ; preds = %do.end76, %while.end62
  %104 = load i64, ptr %retries.addr, align 8
  %cmp78 = icmp ule i64 %104, 2
  br i1 %cmp78, label %if.then79, label %if.else

if.then79:                                        ; preds = %if.end77
  %105 = load ptr, ptr %bitmap.addr, align 8
  %106 = load i64, ptr %bitmap_fields.addr, align 8
  %107 = load i64, ptr %idx.addr, align 8
  %108 = load i64, ptr %count.addr, align 8
  %109 = load i64, ptr %retries.addr, align 8
  %add80 = add i64 %109, 1
  %110 = load ptr, ptr %bitmap_idx.addr, align 8
  %call81 = call zeroext i1 @mi_bitmap_try_find_claim_field_across(ptr noundef %105, i64 noundef %106, i64 noundef %107, i64 noundef %108, i64 noundef %add80, ptr noundef %110)
  store i1 %call81, ptr %retval, align 1
  br label %return

if.else:                                          ; preds = %if.end77
  store i1 false, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.else, %if.then79, %do.end55, %if.then16, %if.then8, %if.then2, %if.then
  %111 = load i1, ptr %retval, align 1
  ret i1 %111
}

; Function Attrs: nounwind uwtable
define internal i64 @mi_bitmap_mask_across(i64 noundef %bitmap_idx, i64 noundef %bitmap_fields, i64 noundef %count, ptr noundef %pre_mask, ptr noundef %mid_mask, ptr noundef %post_mask) #0 {
entry:
  %retval = alloca i64, align 8
  %bitmap_idx.addr = alloca i64, align 8
  %bitmap_fields.addr = alloca i64, align 8
  %count.addr = alloca i64, align 8
  %pre_mask.addr = alloca ptr, align 8
  %mid_mask.addr = alloca ptr, align 8
  %post_mask.addr = alloca ptr, align 8
  %bitidx = alloca i64, align 8
  %pre_bits = alloca i64, align 8
  %mid_count = alloca i64, align 8
  store i64 %bitmap_idx, ptr %bitmap_idx.addr, align 8
  store i64 %bitmap_fields, ptr %bitmap_fields.addr, align 8
  store i64 %count, ptr %count.addr, align 8
  store ptr %pre_mask, ptr %pre_mask.addr, align 8
  store ptr %mid_mask, ptr %mid_mask.addr, align 8
  store ptr %post_mask, ptr %post_mask.addr, align 8
  %0 = load i64, ptr %bitmap_idx.addr, align 8
  %call = call i64 @mi_bitmap_index_bit_in_field(i64 noundef %0)
  store i64 %call, ptr %bitidx, align 8
  %1 = load i64, ptr %bitidx, align 8
  %2 = load i64, ptr %count.addr, align 8
  %add = add i64 %1, %2
  %cmp = icmp ule i64 %add, 64
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load i64, ptr %count.addr, align 8
  %4 = load i64, ptr %bitidx, align 8
  %call2 = call i64 @mi_bitmap_mask_(i64 noundef %3, i64 noundef %4)
  %5 = load ptr, ptr %pre_mask.addr, align 8
  store i64 %call2, ptr %5, align 8
  %6 = load ptr, ptr %mid_mask.addr, align 8
  store i64 0, ptr %6, align 8
  %7 = load ptr, ptr %post_mask.addr, align 8
  store i64 0, ptr %7, align 8
  store i64 0, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %8 = load i64, ptr %bitidx, align 8
  %sub = sub i64 64, %8
  store i64 %sub, ptr %pre_bits, align 8
  %9 = load i64, ptr %pre_bits, align 8
  %10 = load i64, ptr %bitidx, align 8
  %call3 = call i64 @mi_bitmap_mask_(i64 noundef %9, i64 noundef %10)
  %11 = load ptr, ptr %pre_mask.addr, align 8
  store i64 %call3, ptr %11, align 8
  %12 = load i64, ptr %pre_bits, align 8
  %13 = load i64, ptr %count.addr, align 8
  %sub4 = sub i64 %13, %12
  store i64 %sub4, ptr %count.addr, align 8
  %14 = load i64, ptr %count.addr, align 8
  %div = udiv i64 %14, 64
  store i64 %div, ptr %mid_count, align 8
  %15 = load ptr, ptr %mid_mask.addr, align 8
  store i64 -1, ptr %15, align 8
  %16 = load i64, ptr %count.addr, align 8
  %rem = urem i64 %16, 64
  store i64 %rem, ptr %count.addr, align 8
  %17 = load i64, ptr %count.addr, align 8
  %cmp5 = icmp eq i64 %17, 0
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.else
  br label %cond.end

cond.false:                                       ; preds = %if.else
  %18 = load i64, ptr %count.addr, align 8
  %call7 = call i64 @mi_bitmap_mask_(i64 noundef %18, i64 noundef 0)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ 0, %cond.true ], [ %call7, %cond.false ]
  %19 = load ptr, ptr %post_mask.addr, align 8
  store i64 %cond, ptr %19, align 8
  %20 = load i64, ptr %mid_count, align 8
  store i64 %20, ptr %retval, align 8
  br label %return

return:                                           ; preds = %cond.end, %if.then
  %21 = load i64, ptr %retval, align 8
  ret i64 %21
}

; Function Attrs: nounwind uwtable
define hidden zeroext i1 @_mi_bitmap_claim_across(ptr noundef %bitmap, i64 noundef %bitmap_fields, i64 noundef %count, i64 noundef %bitmap_idx, ptr noundef %pany_zero) #0 {
entry:
  %bitmap.addr = alloca ptr, align 8
  %bitmap_fields.addr = alloca i64, align 8
  %count.addr = alloca i64, align 8
  %bitmap_idx.addr = alloca i64, align 8
  %pany_zero.addr = alloca ptr, align 8
  %idx = alloca i64, align 8
  %pre_mask = alloca i64, align 8
  %mid_mask = alloca i64, align 8
  %post_mask = alloca i64, align 8
  %mid_count = alloca i64, align 8
  %all_zero = alloca i8, align 1
  %any_zero = alloca i8, align 1
  %field = alloca ptr, align 8
  %prev = alloca i64, align 8
  %.atomictmp = alloca i64, align 8
  %atomic-temp = alloca i64, align 8
  %.atomictmp8 = alloca i64, align 8
  %atomic-temp9 = alloca i64, align 8
  %.atomictmp20 = alloca i64, align 8
  %atomic-temp21 = alloca i64, align 8
  store ptr %bitmap, ptr %bitmap.addr, align 8
  store i64 %bitmap_fields, ptr %bitmap_fields.addr, align 8
  store i64 %count, ptr %count.addr, align 8
  store i64 %bitmap_idx, ptr %bitmap_idx.addr, align 8
  store ptr %pany_zero, ptr %pany_zero.addr, align 8
  %0 = load i64, ptr %bitmap_idx.addr, align 8
  %call = call i64 @mi_bitmap_index_field(i64 noundef %0)
  store i64 %call, ptr %idx, align 8
  %1 = load i64, ptr %bitmap_idx.addr, align 8
  %2 = load i64, ptr %bitmap_fields.addr, align 8
  %3 = load i64, ptr %count.addr, align 8
  %call1 = call i64 @mi_bitmap_mask_across(i64 noundef %1, i64 noundef %2, i64 noundef %3, ptr noundef %pre_mask, ptr noundef %mid_mask, ptr noundef %post_mask)
  store i64 %call1, ptr %mid_count, align 8
  store i8 1, ptr %all_zero, align 1
  store i8 0, ptr %any_zero, align 1
  %4 = load ptr, ptr %bitmap.addr, align 8
  %5 = load i64, ptr %idx, align 8
  %arrayidx = getelementptr i64, ptr %4, i64 %5
  store ptr %arrayidx, ptr %field, align 8
  %6 = load ptr, ptr %field, align 8
  %incdec.ptr = getelementptr i64, ptr %6, i32 1
  store ptr %incdec.ptr, ptr %field, align 8
  %7 = load i64, ptr %pre_mask, align 8
  store i64 %7, ptr %.atomictmp, align 8
  %8 = load i64, ptr %.atomictmp, align 8
  %9 = atomicrmw or ptr %6, i64 %8 acq_rel, align 8
  store i64 %9, ptr %atomic-temp, align 8
  %10 = load i64, ptr %atomic-temp, align 8
  store i64 %10, ptr %prev, align 8
  %11 = load i64, ptr %prev, align 8
  %12 = load i64, ptr %pre_mask, align 8
  %and = and i64 %11, %12
  %cmp = icmp ne i64 %and, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i8 0, ptr %all_zero, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %13 = load i64, ptr %prev, align 8
  %14 = load i64, ptr %pre_mask, align 8
  %and2 = and i64 %13, %14
  %15 = load i64, ptr %pre_mask, align 8
  %cmp3 = icmp ne i64 %and2, %15
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  store i8 1, ptr %any_zero, align 1
  br label %if.end5

if.end5:                                          ; preds = %if.then4, %if.end
  br label %while.cond

while.cond:                                       ; preds = %if.end17, %if.end5
  %16 = load i64, ptr %mid_count, align 8
  %dec = add i64 %16, -1
  store i64 %dec, ptr %mid_count, align 8
  %cmp6 = icmp ugt i64 %16, 0
  br i1 %cmp6, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %17 = load ptr, ptr %field, align 8
  %incdec.ptr7 = getelementptr i64, ptr %17, i32 1
  store ptr %incdec.ptr7, ptr %field, align 8
  %18 = load i64, ptr %mid_mask, align 8
  store i64 %18, ptr %.atomictmp8, align 8
  %19 = load i64, ptr %.atomictmp8, align 8
  %20 = atomicrmw or ptr %17, i64 %19 acq_rel, align 8
  store i64 %20, ptr %atomic-temp9, align 8
  %21 = load i64, ptr %atomic-temp9, align 8
  store i64 %21, ptr %prev, align 8
  %22 = load i64, ptr %prev, align 8
  %23 = load i64, ptr %mid_mask, align 8
  %and10 = and i64 %22, %23
  %cmp11 = icmp ne i64 %and10, 0
  br i1 %cmp11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %while.body
  store i8 0, ptr %all_zero, align 1
  br label %if.end13

if.end13:                                         ; preds = %if.then12, %while.body
  %24 = load i64, ptr %prev, align 8
  %25 = load i64, ptr %mid_mask, align 8
  %and14 = and i64 %24, %25
  %26 = load i64, ptr %mid_mask, align 8
  %cmp15 = icmp ne i64 %and14, %26
  br i1 %cmp15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.end13
  store i8 1, ptr %any_zero, align 1
  br label %if.end17

if.end17:                                         ; preds = %if.then16, %if.end13
  br label %while.cond, !llvm.loop !37

while.end:                                        ; preds = %while.cond
  %27 = load i64, ptr %post_mask, align 8
  %cmp18 = icmp ne i64 %27, 0
  br i1 %cmp18, label %if.then19, label %if.end30

if.then19:                                        ; preds = %while.end
  %28 = load ptr, ptr %field, align 8
  %29 = load i64, ptr %post_mask, align 8
  store i64 %29, ptr %.atomictmp20, align 8
  %30 = load i64, ptr %.atomictmp20, align 8
  %31 = atomicrmw or ptr %28, i64 %30 acq_rel, align 8
  store i64 %31, ptr %atomic-temp21, align 8
  %32 = load i64, ptr %atomic-temp21, align 8
  store i64 %32, ptr %prev, align 8
  %33 = load i64, ptr %prev, align 8
  %34 = load i64, ptr %post_mask, align 8
  %and22 = and i64 %33, %34
  %cmp23 = icmp ne i64 %and22, 0
  br i1 %cmp23, label %if.then24, label %if.end25

if.then24:                                        ; preds = %if.then19
  store i8 0, ptr %all_zero, align 1
  br label %if.end25

if.end25:                                         ; preds = %if.then24, %if.then19
  %35 = load i64, ptr %prev, align 8
  %36 = load i64, ptr %post_mask, align 8
  %and26 = and i64 %35, %36
  %37 = load i64, ptr %post_mask, align 8
  %cmp27 = icmp ne i64 %and26, %37
  br i1 %cmp27, label %if.then28, label %if.end29

if.then28:                                        ; preds = %if.end25
  store i8 1, ptr %any_zero, align 1
  br label %if.end29

if.end29:                                         ; preds = %if.then28, %if.end25
  br label %if.end30

if.end30:                                         ; preds = %if.end29, %while.end
  %38 = load ptr, ptr %pany_zero.addr, align 8
  %cmp31 = icmp ne ptr %38, null
  br i1 %cmp31, label %if.then32, label %if.end33

if.then32:                                        ; preds = %if.end30
  %39 = load i8, ptr %any_zero, align 1
  %tobool = trunc i8 %39 to i1
  %40 = load ptr, ptr %pany_zero.addr, align 8
  %frombool = zext i1 %tobool to i8
  store i8 %frombool, ptr %40, align 1
  br label %if.end33

if.end33:                                         ; preds = %if.then32, %if.end30
  %41 = load i8, ptr %all_zero, align 1
  %tobool34 = trunc i8 %41 to i1
  ret i1 %tobool34
}

; Function Attrs: nounwind uwtable
define hidden zeroext i1 @_mi_bitmap_is_claimed_across(ptr noundef %bitmap, i64 noundef %bitmap_fields, i64 noundef %count, i64 noundef %bitmap_idx) #0 {
entry:
  %bitmap.addr = alloca ptr, align 8
  %bitmap_fields.addr = alloca i64, align 8
  %count.addr = alloca i64, align 8
  %bitmap_idx.addr = alloca i64, align 8
  store ptr %bitmap, ptr %bitmap.addr, align 8
  store i64 %bitmap_fields, ptr %bitmap_fields.addr, align 8
  store i64 %count, ptr %count.addr, align 8
  store i64 %bitmap_idx, ptr %bitmap_idx.addr, align 8
  %0 = load ptr, ptr %bitmap.addr, align 8
  %1 = load i64, ptr %bitmap_fields.addr, align 8
  %2 = load i64, ptr %count.addr, align 8
  %3 = load i64, ptr %bitmap_idx.addr, align 8
  %call = call zeroext i1 @mi_bitmap_is_claimedx_across(ptr noundef %0, i64 noundef %1, i64 noundef %2, i64 noundef %3, ptr noundef null)
  ret i1 %call
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_bitmap_is_claimedx_across(ptr noundef %bitmap, i64 noundef %bitmap_fields, i64 noundef %count, i64 noundef %bitmap_idx, ptr noundef %pany_ones) #0 {
entry:
  %bitmap.addr = alloca ptr, align 8
  %bitmap_fields.addr = alloca i64, align 8
  %count.addr = alloca i64, align 8
  %bitmap_idx.addr = alloca i64, align 8
  %pany_ones.addr = alloca ptr, align 8
  %idx = alloca i64, align 8
  %pre_mask = alloca i64, align 8
  %mid_mask = alloca i64, align 8
  %post_mask = alloca i64, align 8
  %mid_count = alloca i64, align 8
  %all_ones = alloca i8, align 1
  %any_ones = alloca i8, align 1
  %field = alloca ptr, align 8
  %prev = alloca i64, align 8
  %atomic-temp = alloca i64, align 8
  %atomic-temp8 = alloca i64, align 8
  %atomic-temp19 = alloca i64, align 8
  store ptr %bitmap, ptr %bitmap.addr, align 8
  store i64 %bitmap_fields, ptr %bitmap_fields.addr, align 8
  store i64 %count, ptr %count.addr, align 8
  store i64 %bitmap_idx, ptr %bitmap_idx.addr, align 8
  store ptr %pany_ones, ptr %pany_ones.addr, align 8
  %0 = load i64, ptr %bitmap_idx.addr, align 8
  %call = call i64 @mi_bitmap_index_field(i64 noundef %0)
  store i64 %call, ptr %idx, align 8
  %1 = load i64, ptr %bitmap_idx.addr, align 8
  %2 = load i64, ptr %bitmap_fields.addr, align 8
  %3 = load i64, ptr %count.addr, align 8
  %call1 = call i64 @mi_bitmap_mask_across(i64 noundef %1, i64 noundef %2, i64 noundef %3, ptr noundef %pre_mask, ptr noundef %mid_mask, ptr noundef %post_mask)
  store i64 %call1, ptr %mid_count, align 8
  store i8 1, ptr %all_ones, align 1
  store i8 0, ptr %any_ones, align 1
  %4 = load ptr, ptr %bitmap.addr, align 8
  %5 = load i64, ptr %idx, align 8
  %arrayidx = getelementptr i64, ptr %4, i64 %5
  store ptr %arrayidx, ptr %field, align 8
  %6 = load ptr, ptr %field, align 8
  %incdec.ptr = getelementptr i64, ptr %6, i32 1
  store ptr %incdec.ptr, ptr %field, align 8
  %7 = load atomic i64, ptr %6 monotonic, align 8
  store i64 %7, ptr %atomic-temp, align 8
  %8 = load i64, ptr %atomic-temp, align 8
  store i64 %8, ptr %prev, align 8
  %9 = load i64, ptr %prev, align 8
  %10 = load i64, ptr %pre_mask, align 8
  %and = and i64 %9, %10
  %11 = load i64, ptr %pre_mask, align 8
  %cmp = icmp ne i64 %and, %11
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i8 0, ptr %all_ones, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %12 = load i64, ptr %prev, align 8
  %13 = load i64, ptr %pre_mask, align 8
  %and2 = and i64 %12, %13
  %cmp3 = icmp ne i64 %and2, 0
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  store i8 1, ptr %any_ones, align 1
  br label %if.end5

if.end5:                                          ; preds = %if.then4, %if.end
  br label %while.cond

while.cond:                                       ; preds = %if.end16, %if.end5
  %14 = load i64, ptr %mid_count, align 8
  %dec = add i64 %14, -1
  store i64 %dec, ptr %mid_count, align 8
  %cmp6 = icmp ugt i64 %14, 0
  br i1 %cmp6, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %15 = load ptr, ptr %field, align 8
  %incdec.ptr7 = getelementptr i64, ptr %15, i32 1
  store ptr %incdec.ptr7, ptr %field, align 8
  %16 = load atomic i64, ptr %15 monotonic, align 8
  store i64 %16, ptr %atomic-temp8, align 8
  %17 = load i64, ptr %atomic-temp8, align 8
  store i64 %17, ptr %prev, align 8
  %18 = load i64, ptr %prev, align 8
  %19 = load i64, ptr %mid_mask, align 8
  %and9 = and i64 %18, %19
  %20 = load i64, ptr %mid_mask, align 8
  %cmp10 = icmp ne i64 %and9, %20
  br i1 %cmp10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %while.body
  store i8 0, ptr %all_ones, align 1
  br label %if.end12

if.end12:                                         ; preds = %if.then11, %while.body
  %21 = load i64, ptr %prev, align 8
  %22 = load i64, ptr %mid_mask, align 8
  %and13 = and i64 %21, %22
  %cmp14 = icmp ne i64 %and13, 0
  br i1 %cmp14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.end12
  store i8 1, ptr %any_ones, align 1
  br label %if.end16

if.end16:                                         ; preds = %if.then15, %if.end12
  br label %while.cond, !llvm.loop !38

while.end:                                        ; preds = %while.cond
  %23 = load i64, ptr %post_mask, align 8
  %cmp17 = icmp ne i64 %23, 0
  br i1 %cmp17, label %if.then18, label %if.end28

if.then18:                                        ; preds = %while.end
  %24 = load ptr, ptr %field, align 8
  %25 = load atomic i64, ptr %24 monotonic, align 8
  store i64 %25, ptr %atomic-temp19, align 8
  %26 = load i64, ptr %atomic-temp19, align 8
  store i64 %26, ptr %prev, align 8
  %27 = load i64, ptr %prev, align 8
  %28 = load i64, ptr %post_mask, align 8
  %and20 = and i64 %27, %28
  %29 = load i64, ptr %post_mask, align 8
  %cmp21 = icmp ne i64 %and20, %29
  br i1 %cmp21, label %if.then22, label %if.end23

if.then22:                                        ; preds = %if.then18
  store i8 0, ptr %all_ones, align 1
  br label %if.end23

if.end23:                                         ; preds = %if.then22, %if.then18
  %30 = load i64, ptr %prev, align 8
  %31 = load i64, ptr %post_mask, align 8
  %and24 = and i64 %30, %31
  %cmp25 = icmp ne i64 %and24, 0
  br i1 %cmp25, label %if.then26, label %if.end27

if.then26:                                        ; preds = %if.end23
  store i8 1, ptr %any_ones, align 1
  br label %if.end27

if.end27:                                         ; preds = %if.then26, %if.end23
  br label %if.end28

if.end28:                                         ; preds = %if.end27, %while.end
  %32 = load ptr, ptr %pany_ones.addr, align 8
  %cmp29 = icmp ne ptr %32, null
  br i1 %cmp29, label %if.then30, label %if.end31

if.then30:                                        ; preds = %if.end28
  %33 = load i8, ptr %any_ones, align 1
  %tobool = trunc i8 %33 to i1
  %34 = load ptr, ptr %pany_ones.addr, align 8
  %frombool = zext i1 %tobool to i8
  store i8 %frombool, ptr %34, align 1
  br label %if.end31

if.end31:                                         ; preds = %if.then30, %if.end28
  %35 = load i8, ptr %all_ones, align 1
  %tobool32 = trunc i8 %35 to i1
  ret i1 %tobool32
}

; Function Attrs: nounwind uwtable
define hidden zeroext i1 @_mi_bitmap_is_any_claimed_across(ptr noundef %bitmap, i64 noundef %bitmap_fields, i64 noundef %count, i64 noundef %bitmap_idx) #0 {
entry:
  %bitmap.addr = alloca ptr, align 8
  %bitmap_fields.addr = alloca i64, align 8
  %count.addr = alloca i64, align 8
  %bitmap_idx.addr = alloca i64, align 8
  %any_ones = alloca i8, align 1
  store ptr %bitmap, ptr %bitmap.addr, align 8
  store i64 %bitmap_fields, ptr %bitmap_fields.addr, align 8
  store i64 %count, ptr %count.addr, align 8
  store i64 %bitmap_idx, ptr %bitmap_idx.addr, align 8
  %0 = load ptr, ptr %bitmap.addr, align 8
  %1 = load i64, ptr %bitmap_fields.addr, align 8
  %2 = load i64, ptr %count.addr, align 8
  %3 = load i64, ptr %bitmap_idx.addr, align 8
  %call = call zeroext i1 @mi_bitmap_is_claimedx_across(ptr noundef %0, i64 noundef %1, i64 noundef %2, i64 noundef %3, ptr noundef %any_ones)
  %4 = load i8, ptr %any_ones, align 1
  %tobool = trunc i8 %4 to i1
  ret i1 %tobool
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_heap_collect_abandon(ptr noundef %heap) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  %0 = load ptr, ptr %heap.addr, align 8
  call void @mi_heap_collect_ex(ptr noundef %0, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_heap_collect_ex(ptr noundef %heap, i32 noundef %collect) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %collect.addr = alloca i32, align 4
  %force = alloca i8, align 1
  %force_main = alloca i8, align 1
  store ptr %heap, ptr %heap.addr, align 8
  store i32 %collect, ptr %collect.addr, align 4
  %0 = load ptr, ptr %heap.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %heap.addr, align 8
  %call = call zeroext i1 @mi_heap_is_initialized(ptr noundef %1)
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %if.end32

if.end:                                           ; preds = %lor.lhs.false
  %2 = load i32, ptr %collect.addr, align 4
  %cmp1 = icmp uge i32 %2, 1
  %frombool = zext i1 %cmp1 to i8
  store i8 %frombool, ptr %force, align 1
  %3 = load ptr, ptr %heap.addr, align 8
  %4 = load i8, ptr %force, align 1
  %tobool = trunc i8 %4 to i1
  call void @_mi_deferred_free(ptr noundef %3, i1 noundef zeroext %tobool)
  %5 = load i32, ptr %collect.addr, align 4
  %cmp2 = icmp eq i32 %5, 1
  br i1 %cmp2, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %if.end
  %call3 = call zeroext i1 @_mi_is_main_thread()
  br i1 %call3, label %land.lhs.true4, label %land.end

land.lhs.true4:                                   ; preds = %land.lhs.true
  %6 = load ptr, ptr %heap.addr, align 8
  %call5 = call zeroext i1 @mi_heap_is_backing(ptr noundef %6)
  br i1 %call5, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true4
  %7 = load ptr, ptr %heap.addr, align 8
  %no_reclaim = getelementptr inbounds %struct.mi_heap_s, ptr %7, i32 0, i32 13
  %8 = load i8, ptr %no_reclaim, align 8
  %tobool6 = trunc i8 %8 to i1
  %lnot = xor i1 %tobool6, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true4, %land.lhs.true, %if.end
  %9 = phi i1 [ false, %land.lhs.true4 ], [ false, %land.lhs.true ], [ false, %if.end ], [ %lnot, %land.rhs ]
  %frombool7 = zext i1 %9 to i8
  store i8 %frombool7, ptr %force_main, align 1
  %10 = load i8, ptr %force_main, align 1
  %tobool8 = trunc i8 %10 to i1
  br i1 %tobool8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %land.end
  %11 = load ptr, ptr %heap.addr, align 8
  %12 = load ptr, ptr %heap.addr, align 8
  %tld = getelementptr inbounds %struct.mi_heap_s, ptr %12, i32 0, i32 0
  %13 = load ptr, ptr %tld, align 8
  %segments = getelementptr inbounds %struct.mi_tld_s, ptr %13, i32 0, i32 4
  call void @_mi_abandoned_reclaim_all(ptr noundef %11, ptr noundef %segments)
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %land.end
  %14 = load i32, ptr %collect.addr, align 4
  %cmp11 = icmp eq i32 %14, 2
  br i1 %cmp11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %if.end10
  %15 = load ptr, ptr %heap.addr, align 8
  %call13 = call zeroext i1 @mi_heap_visit_pages(ptr noundef %15, ptr noundef @mi_heap_page_never_delayed_free, ptr noundef null, ptr noundef null)
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %if.end10
  %16 = load ptr, ptr %heap.addr, align 8
  call void @_mi_heap_delayed_free_all(ptr noundef %16)
  %17 = load ptr, ptr %heap.addr, align 8
  %18 = load i8, ptr %force, align 1
  %tobool15 = trunc i8 %18 to i1
  call void @_mi_heap_collect_retired(ptr noundef %17, i1 noundef zeroext %tobool15)
  %19 = load ptr, ptr %heap.addr, align 8
  %call16 = call zeroext i1 @mi_heap_visit_pages(ptr noundef %19, ptr noundef @mi_heap_page_collect, ptr noundef %collect.addr, ptr noundef null)
  %20 = load ptr, ptr %heap.addr, align 8
  %21 = load i32, ptr %collect.addr, align 4
  %cmp17 = icmp eq i32 %21, 1
  %22 = load ptr, ptr %heap.addr, align 8
  %tld18 = getelementptr inbounds %struct.mi_heap_s, ptr %22, i32 0, i32 0
  %23 = load ptr, ptr %tld18, align 8
  %segments19 = getelementptr inbounds %struct.mi_tld_s, ptr %23, i32 0, i32 4
  call void @_mi_abandoned_collect(ptr noundef %20, i1 noundef zeroext %cmp17, ptr noundef %segments19)
  %24 = load i8, ptr %force, align 1
  %tobool20 = trunc i8 %24 to i1
  br i1 %tobool20, label %if.then21, label %if.end24

if.then21:                                        ; preds = %if.end14
  %25 = load ptr, ptr %heap.addr, align 8
  %tld22 = getelementptr inbounds %struct.mi_heap_s, ptr %25, i32 0, i32 0
  %26 = load ptr, ptr %tld22, align 8
  %segments23 = getelementptr inbounds %struct.mi_tld_s, ptr %26, i32 0, i32 4
  call void @_mi_segment_thread_collect(ptr noundef %segments23)
  br label %if.end24

if.end24:                                         ; preds = %if.then21, %if.end14
  %27 = load i8, ptr %force, align 1
  %tobool25 = trunc i8 %27 to i1
  br i1 %tobool25, label %land.lhs.true26, label %if.end32

land.lhs.true26:                                  ; preds = %if.end24
  %call27 = call zeroext i1 @_mi_is_main_thread()
  br i1 %call27, label %land.lhs.true28, label %if.end32

land.lhs.true28:                                  ; preds = %land.lhs.true26
  %28 = load ptr, ptr %heap.addr, align 8
  %call29 = call zeroext i1 @mi_heap_is_backing(ptr noundef %28)
  br i1 %call29, label %if.then30, label %if.end32

if.then30:                                        ; preds = %land.lhs.true28
  call void @_mi_thread_data_collect()
  %29 = load ptr, ptr %heap.addr, align 8
  %tld31 = getelementptr inbounds %struct.mi_heap_s, ptr %29, i32 0, i32 0
  %30 = load ptr, ptr %tld31, align 8
  %stats = getelementptr inbounds %struct.mi_tld_s, ptr %30, i32 0, i32 6
  call void @_mi_arena_collect(i1 noundef zeroext true, ptr noundef %stats)
  br label %if.end32

if.end32:                                         ; preds = %if.then30, %land.lhs.true28, %land.lhs.true26, %if.end24, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @mi_heap_collect(ptr noundef %heap, i1 noundef zeroext %force) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %force.addr = alloca i8, align 1
  store ptr %heap, ptr %heap.addr, align 8
  %frombool = zext i1 %force to i8
  store i8 %frombool, ptr %force.addr, align 1
  %0 = load ptr, ptr %heap.addr, align 8
  %1 = load i8, ptr %force.addr, align 1
  %tobool = trunc i8 %1 to i1
  %cond = select i1 %tobool, i32 1, i32 0
  call void @mi_heap_collect_ex(ptr noundef %0, i32 noundef %cond)
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @mi_collect(i1 noundef zeroext %force) #0 {
entry:
  %force.addr = alloca i8, align 1
  %frombool = zext i1 %force to i8
  store i8 %frombool, ptr %force.addr, align 1
  %call = call ptr @mi_prim_get_default_heap()
  %0 = load i8, ptr %force.addr, align 1
  %tobool = trunc i8 %0 to i1
  call void @mi_heap_collect(ptr noundef %call, i1 noundef zeroext %tobool)
  ret void
}

; Function Attrs: nounwind uwtable
define hidden ptr @mi_heap_get_default() #0 {
entry:
  call void @mi_thread_init()
  %call = call ptr @mi_prim_get_default_heap()
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define hidden void @mi_thread_init() #0 {
entry:
  %.atomictmp = alloca i64, align 8
  %atomic-temp = alloca i64, align 8
  call void @mi_process_init()
  %call = call zeroext i1 @_mi_heap_init()
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  call void @_mi_stat_increase(ptr noundef getelementptr inbounds (%struct.mi_stats_s, ptr @_mi_stats_main, i32 0, i32 9), i64 noundef 1)
  store i64 1, ptr %.atomictmp, align 8
  %0 = load i64, ptr %.atomictmp, align 8
  %1 = atomicrmw add ptr @thread_count, i64 %0 monotonic, align 8
  store i64 %1, ptr %atomic-temp, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define hidden ptr @mi_heap_get_backing() #0 {
entry:
  %heap = alloca ptr, align 8
  %bheap = alloca ptr, align 8
  %call = call ptr @mi_heap_get_default()
  store ptr %call, ptr %heap, align 8
  %0 = load ptr, ptr %heap, align 8
  %tld = getelementptr inbounds %struct.mi_heap_s, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %tld, align 8
  %heap_backing = getelementptr inbounds %struct.mi_tld_s, ptr %1, i32 0, i32 2
  %2 = load ptr, ptr %heap_backing, align 8
  store ptr %2, ptr %bheap, align 8
  %3 = load ptr, ptr %bheap, align 8
  ret ptr %3
}

; Function Attrs: nounwind uwtable
define hidden ptr @mi_heap_new_in_arena(i32 noundef %arena_id) #0 {
entry:
  %retval = alloca ptr, align 8
  %arena_id.addr = alloca i32, align 4
  %bheap = alloca ptr, align 8
  %heap = alloca ptr, align 8
  store i32 %arena_id, ptr %arena_id.addr, align 4
  %call = call ptr @mi_heap_get_backing()
  store ptr %call, ptr %bheap, align 8
  %0 = load ptr, ptr %bheap, align 8
  %call1 = call noalias ptr @mi_heap_malloc(ptr noundef %0, i64 noundef 3064)
  store ptr %call1, ptr %heap, align 8
  %1 = load ptr, ptr %heap, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %heap, align 8
  call void @_mi_memcpy_aligned(ptr noundef %2, ptr noundef @_mi_heap_empty, i64 noundef 3064)
  %3 = load ptr, ptr %bheap, align 8
  %tld = getelementptr inbounds %struct.mi_heap_s, ptr %3, i32 0, i32 0
  %4 = load ptr, ptr %tld, align 8
  %5 = load ptr, ptr %heap, align 8
  %tld2 = getelementptr inbounds %struct.mi_heap_s, ptr %5, i32 0, i32 0
  store ptr %4, ptr %tld2, align 8
  %call3 = call i64 @_mi_thread_id()
  %6 = load ptr, ptr %heap, align 8
  %thread_id = getelementptr inbounds %struct.mi_heap_s, ptr %6, i32 0, i32 4
  store i64 %call3, ptr %thread_id, align 8
  %7 = load i32, ptr %arena_id.addr, align 4
  %8 = load ptr, ptr %heap, align 8
  %arena_id4 = getelementptr inbounds %struct.mi_heap_s, ptr %8, i32 0, i32 5
  store i32 %7, ptr %arena_id4, align 8
  %9 = load ptr, ptr %bheap, align 8
  %random = getelementptr inbounds %struct.mi_heap_s, ptr %9, i32 0, i32 8
  %10 = load ptr, ptr %heap, align 8
  %random5 = getelementptr inbounds %struct.mi_heap_s, ptr %10, i32 0, i32 8
  call void @_mi_random_split(ptr noundef %random, ptr noundef %random5)
  %11 = load ptr, ptr %heap, align 8
  %call6 = call i64 @_mi_heap_random_next(ptr noundef %11)
  %or = or i64 %call6, 1
  %12 = load ptr, ptr %heap, align 8
  %cookie = getelementptr inbounds %struct.mi_heap_s, ptr %12, i32 0, i32 6
  store i64 %or, ptr %cookie, align 8
  %13 = load ptr, ptr %heap, align 8
  %call7 = call i64 @_mi_heap_random_next(ptr noundef %13)
  %14 = load ptr, ptr %heap, align 8
  %keys = getelementptr inbounds %struct.mi_heap_s, ptr %14, i32 0, i32 7
  %arrayidx = getelementptr [2 x i64], ptr %keys, i64 0, i64 0
  store i64 %call7, ptr %arrayidx, align 8
  %15 = load ptr, ptr %heap, align 8
  %call8 = call i64 @_mi_heap_random_next(ptr noundef %15)
  %16 = load ptr, ptr %heap, align 8
  %keys9 = getelementptr inbounds %struct.mi_heap_s, ptr %16, i32 0, i32 7
  %arrayidx10 = getelementptr [2 x i64], ptr %keys9, i64 0, i64 1
  store i64 %call8, ptr %arrayidx10, align 8
  %17 = load ptr, ptr %heap, align 8
  %no_reclaim = getelementptr inbounds %struct.mi_heap_s, ptr %17, i32 0, i32 13
  store i8 1, ptr %no_reclaim, align 8
  %18 = load ptr, ptr %heap, align 8
  %tld11 = getelementptr inbounds %struct.mi_heap_s, ptr %18, i32 0, i32 0
  %19 = load ptr, ptr %tld11, align 8
  %heaps = getelementptr inbounds %struct.mi_tld_s, ptr %19, i32 0, i32 3
  %20 = load ptr, ptr %heaps, align 8
  %21 = load ptr, ptr %heap, align 8
  %next = getelementptr inbounds %struct.mi_heap_s, ptr %21, i32 0, i32 12
  store ptr %20, ptr %next, align 8
  %22 = load ptr, ptr %heap, align 8
  %23 = load ptr, ptr %heap, align 8
  %tld12 = getelementptr inbounds %struct.mi_heap_s, ptr %23, i32 0, i32 0
  %24 = load ptr, ptr %tld12, align 8
  %heaps13 = getelementptr inbounds %struct.mi_tld_s, ptr %24, i32 0, i32 3
  store ptr %22, ptr %heaps13, align 8
  %25 = load ptr, ptr %heap, align 8
  store ptr %25, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %26 = load ptr, ptr %retval, align 8
  ret ptr %26
}

; Function Attrs: nounwind uwtable
define internal void @_mi_memcpy_aligned(ptr noundef %dst, ptr noundef %src, i64 noundef %n) #0 {
entry:
  %dst.addr = alloca ptr, align 8
  %src.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %adst = alloca ptr, align 8
  %asrc = alloca ptr, align 8
  store ptr %dst, ptr %dst.addr, align 8
  store ptr %src, ptr %src.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %0 = load ptr, ptr %dst.addr, align 8
  call void @llvm.assume(i1 true) [ "align"(ptr %0, i64 8) ]
  store ptr %0, ptr %adst, align 8
  %1 = load ptr, ptr %src.addr, align 8
  call void @llvm.assume(i1 true) [ "align"(ptr %1, i64 8) ]
  store ptr %1, ptr %asrc, align 8
  %2 = load ptr, ptr %adst, align 8
  %3 = load ptr, ptr %asrc, align 8
  %4 = load i64, ptr %n.addr, align 8
  call void @_mi_memcpy(ptr noundef %2, ptr noundef %3, i64 noundef %4)
  ret void
}

; Function Attrs: nounwind uwtable
define hidden i64 @_mi_thread_id() #0 {
entry:
  %call = call i64 @_mi_prim_thread_id()
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_random_split(ptr noundef %ctx, ptr noundef %ctx_new) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %ctx_new.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %ctx_new, ptr %ctx_new.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %1 = load ptr, ptr %ctx_new.addr, align 8
  %2 = ptrtoint ptr %1 to i64
  %3 = load ptr, ptr %ctx_new.addr, align 8
  call void @chacha_split(ptr noundef %0, i64 noundef %2, ptr noundef %3)
  ret void
}

; Function Attrs: nounwind uwtable
define hidden i64 @_mi_heap_random_next(ptr noundef %heap) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  %0 = load ptr, ptr %heap.addr, align 8
  %random = getelementptr inbounds %struct.mi_heap_s, ptr %0, i32 0, i32 8
  %call = call i64 @_mi_random_next(ptr noundef %random)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define hidden ptr @mi_heap_new() #0 {
entry:
  %call = call i32 @_mi_arena_id_none()
  %call1 = call ptr @mi_heap_new_in_arena(i32 noundef %call)
  ret ptr %call1
}

; Function Attrs: nounwind uwtable
define hidden zeroext i1 @_mi_heap_memid_is_suitable(ptr noundef %heap, ptr noundef byval(%struct.mi_memid_s) align 8 %memid) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  %0 = load ptr, ptr %heap.addr, align 8
  %arena_id = getelementptr inbounds %struct.mi_heap_s, ptr %0, i32 0, i32 5
  %1 = load i32, ptr %arena_id, align 8
  %call = call zeroext i1 @_mi_arena_memid_is_suitable(ptr noundef byval(%struct.mi_memid_s) align 8 %memid, i32 noundef %1)
  ret i1 %call
}

; Function Attrs: nounwind uwtable
define hidden i64 @_mi_random_next(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %call = call i32 @chacha_next32(ptr noundef %0)
  %conv = zext i32 %call to i64
  %shl = shl i64 %conv, 32
  %1 = load ptr, ptr %ctx.addr, align 8
  %call1 = call i32 @chacha_next32(ptr noundef %1)
  %conv2 = zext i32 %call1 to i64
  %or = or i64 %shl, %conv2
  ret i64 %or
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_heap_destroy_pages(ptr noundef %heap) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  %0 = load ptr, ptr %heap.addr, align 8
  %call = call zeroext i1 @mi_heap_visit_pages(ptr noundef %0, ptr noundef @_mi_heap_page_destroy, ptr noundef null, ptr noundef null)
  %1 = load ptr, ptr %heap.addr, align 8
  call void @mi_heap_reset_pages(ptr noundef %1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_heap_visit_pages(ptr noundef %heap, ptr noundef %fn, ptr noundef %arg1, ptr noundef %arg2) #0 {
entry:
  %retval = alloca i1, align 1
  %heap.addr = alloca ptr, align 8
  %fn.addr = alloca ptr, align 8
  %arg1.addr = alloca ptr, align 8
  %arg2.addr = alloca ptr, align 8
  %i = alloca i64, align 8
  %pq = alloca ptr, align 8
  %page = alloca ptr, align 8
  %next = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store ptr %fn, ptr %fn.addr, align 8
  store ptr %arg1, ptr %arg1.addr, align 8
  store ptr %arg2, ptr %arg2.addr, align 8
  %0 = load ptr, ptr %heap.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %heap.addr, align 8
  %page_count = getelementptr inbounds %struct.mi_heap_s, ptr %1, i32 0, i32 9
  %2 = load i64, ptr %page_count, align 8
  %cmp1 = icmp eq i64 %2, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %3 = load i64, ptr %i, align 8
  %cmp2 = icmp ule i64 %3, 74
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load ptr, ptr %heap.addr, align 8
  %pages = getelementptr inbounds %struct.mi_heap_s, ptr %4, i32 0, i32 2
  %5 = load i64, ptr %i, align 8
  %arrayidx = getelementptr [75 x %struct.mi_page_queue_s], ptr %pages, i64 0, i64 %5
  store ptr %arrayidx, ptr %pq, align 8
  %6 = load ptr, ptr %pq, align 8
  %first = getelementptr inbounds %struct.mi_page_queue_s, ptr %6, i32 0, i32 0
  %7 = load ptr, ptr %first, align 8
  store ptr %7, ptr %page, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end6, %for.body
  %8 = load ptr, ptr %page, align 8
  %cmp3 = icmp ne ptr %8, null
  br i1 %cmp3, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %9 = load ptr, ptr %page, align 8
  %next4 = getelementptr inbounds %struct.mi_page_s, ptr %9, i32 0, i32 13
  %10 = load ptr, ptr %next4, align 8
  store ptr %10, ptr %next, align 8
  %11 = load ptr, ptr %fn.addr, align 8
  %12 = load ptr, ptr %heap.addr, align 8
  %13 = load ptr, ptr %pq, align 8
  %14 = load ptr, ptr %page, align 8
  %15 = load ptr, ptr %arg1.addr, align 8
  %16 = load ptr, ptr %arg2.addr, align 8
  %call = call zeroext i1 %11(ptr noundef %12, ptr noundef %13, ptr noundef %14, ptr noundef %15, ptr noundef %16)
  br i1 %call, label %if.end6, label %if.then5

if.then5:                                         ; preds = %while.body
  store i1 false, ptr %retval, align 1
  br label %return

if.end6:                                          ; preds = %while.body
  %17 = load ptr, ptr %next, align 8
  store ptr %17, ptr %page, align 8
  br label %while.cond, !llvm.loop !39

while.end:                                        ; preds = %while.cond
  br label %for.inc

for.inc:                                          ; preds = %while.end
  %18 = load i64, ptr %i, align 8
  %inc = add i64 %18, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !40

for.end:                                          ; preds = %for.cond
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %for.end, %if.then5, %if.then
  %19 = load i1, ptr %retval, align 1
  ret i1 %19
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @_mi_heap_page_destroy(ptr noundef %heap, ptr noundef %pq, ptr noundef %page, ptr noundef %arg1, ptr noundef %arg2) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %pq.addr = alloca ptr, align 8
  %page.addr = alloca ptr, align 8
  %arg1.addr = alloca ptr, align 8
  %arg2.addr = alloca ptr, align 8
  %bsize = alloca i64, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store ptr %pq, ptr %pq.addr, align 8
  store ptr %page, ptr %page.addr, align 8
  store ptr %arg1, ptr %arg1.addr, align 8
  store ptr %arg2, ptr %arg2.addr, align 8
  %0 = load ptr, ptr %page.addr, align 8
  call void @_mi_page_use_delayed_free(ptr noundef %0, i32 noundef 3, i1 noundef zeroext false)
  %1 = load ptr, ptr %page.addr, align 8
  %call = call i64 @mi_page_block_size(ptr noundef %1)
  store i64 %call, ptr %bsize, align 8
  %2 = load i64, ptr %bsize, align 8
  %cmp = icmp ugt i64 %2, 131072
  br i1 %cmp, label %if.then, label %if.end3

if.then:                                          ; preds = %entry
  %3 = load i64, ptr %bsize, align 8
  %cmp1 = icmp ule i64 %3, 16777216
  br i1 %cmp1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  br label %if.end

if.else:                                          ; preds = %if.then
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then2
  br label %if.end3

if.end3:                                          ; preds = %if.end, %entry
  %4 = load ptr, ptr %page.addr, align 8
  %used = getelementptr inbounds %struct.mi_page_s, ptr %4, i32 0, i32 8
  store i32 0, ptr %used, align 8
  %5 = load ptr, ptr %page.addr, align 8
  %next = getelementptr inbounds %struct.mi_page_s, ptr %5, i32 0, i32 13
  store ptr null, ptr %next, align 8
  %6 = load ptr, ptr %page.addr, align 8
  %prev = getelementptr inbounds %struct.mi_page_s, ptr %6, i32 0, i32 14
  store ptr null, ptr %prev, align 8
  %7 = load ptr, ptr %page.addr, align 8
  %8 = load ptr, ptr %heap.addr, align 8
  %tld = getelementptr inbounds %struct.mi_heap_s, ptr %8, i32 0, i32 0
  %9 = load ptr, ptr %tld, align 8
  %segments = getelementptr inbounds %struct.mi_tld_s, ptr %9, i32 0, i32 4
  call void @_mi_segment_page_free(ptr noundef %7, i1 noundef zeroext false, ptr noundef %segments)
  ret i1 true
}

; Function Attrs: nounwind uwtable
define internal void @mi_heap_reset_pages(ptr noundef %heap) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  %0 = load ptr, ptr %heap.addr, align 8
  %pages_free_direct = getelementptr inbounds %struct.mi_heap_s, ptr %0, i32 0, i32 1
  call void @llvm.memset.p0.i64(ptr align 8 %pages_free_direct, i8 0, i64 1032, i1 false)
  %1 = load ptr, ptr %heap.addr, align 8
  %pages = getelementptr inbounds %struct.mi_heap_s, ptr %1, i32 0, i32 2
  call void @_mi_memcpy_aligned(ptr noundef %pages, ptr noundef getelementptr inbounds (%struct.mi_heap_s, ptr @_mi_heap_empty, i32 0, i32 2), i64 noundef 1800)
  %2 = load ptr, ptr %heap.addr, align 8
  %thread_delayed_free = getelementptr inbounds %struct.mi_heap_s, ptr %2, i32 0, i32 3
  store atomic i64 0, ptr %thread_delayed_free seq_cst, align 8
  %3 = load ptr, ptr %heap.addr, align 8
  %page_count = getelementptr inbounds %struct.mi_heap_s, ptr %3, i32 0, i32 9
  store i64 0, ptr %page_count, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @mi_heap_destroy(ptr noundef %heap) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  %0 = load ptr, ptr %heap.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %heap.addr, align 8
  %call = call zeroext i1 @mi_heap_is_initialized(ptr noundef %1)
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %if.end2

if.end:                                           ; preds = %lor.lhs.false
  %2 = load ptr, ptr %heap.addr, align 8
  %no_reclaim = getelementptr inbounds %struct.mi_heap_s, ptr %2, i32 0, i32 13
  %3 = load i8, ptr %no_reclaim, align 8
  %tobool = trunc i8 %3 to i1
  br i1 %tobool, label %if.else, label %if.then1

if.then1:                                         ; preds = %if.end
  %4 = load ptr, ptr %heap.addr, align 8
  call void @mi_heap_delete(ptr noundef %4)
  br label %if.end2

if.else:                                          ; preds = %if.end
  %5 = load ptr, ptr %heap.addr, align 8
  call void @_mi_heap_destroy_pages(ptr noundef %5)
  %6 = load ptr, ptr %heap.addr, align 8
  call void @mi_heap_free(ptr noundef %6)
  br label %if.end2

if.end2:                                          ; preds = %if.else, %if.then1, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_heap_is_initialized(ptr noundef %heap) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  %0 = load ptr, ptr %heap.addr, align 8
  %cmp = icmp ne ptr %0, @_mi_heap_empty
  ret i1 %cmp
}

; Function Attrs: nounwind uwtable
define hidden void @mi_heap_delete(ptr noundef %heap) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  %0 = load ptr, ptr %heap.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %heap.addr, align 8
  %call = call zeroext i1 @mi_heap_is_initialized(ptr noundef %1)
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %2 = load ptr, ptr %heap.addr, align 8
  %call1 = call zeroext i1 @mi_heap_is_backing(ptr noundef %2)
  br i1 %call1, label %if.else, label %if.then2

if.then2:                                         ; preds = %if.end
  %3 = load ptr, ptr %heap.addr, align 8
  %tld = getelementptr inbounds %struct.mi_heap_s, ptr %3, i32 0, i32 0
  %4 = load ptr, ptr %tld, align 8
  %heap_backing = getelementptr inbounds %struct.mi_tld_s, ptr %4, i32 0, i32 2
  %5 = load ptr, ptr %heap_backing, align 8
  %6 = load ptr, ptr %heap.addr, align 8
  call void @mi_heap_absorb(ptr noundef %5, ptr noundef %6)
  br label %if.end3

if.else:                                          ; preds = %if.end
  %7 = load ptr, ptr %heap.addr, align 8
  call void @_mi_heap_collect_abandon(ptr noundef %7)
  br label %if.end3

if.end3:                                          ; preds = %if.else, %if.then2
  %8 = load ptr, ptr %heap.addr, align 8
  call void @mi_heap_free(ptr noundef %8)
  br label %return

return:                                           ; preds = %if.end3, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_heap_free(ptr noundef %heap) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %prev = alloca ptr, align 8
  %curr = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  %0 = load ptr, ptr %heap.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %heap.addr, align 8
  %call = call zeroext i1 @mi_heap_is_initialized(ptr noundef %1)
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %2 = load ptr, ptr %heap.addr, align 8
  %call1 = call zeroext i1 @mi_heap_is_backing(ptr noundef %2)
  br i1 %call1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  br label %return

if.end3:                                          ; preds = %if.end
  %3 = load ptr, ptr %heap.addr, align 8
  %call4 = call zeroext i1 @mi_heap_is_default(ptr noundef %3)
  br i1 %call4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end3
  %4 = load ptr, ptr %heap.addr, align 8
  %tld = getelementptr inbounds %struct.mi_heap_s, ptr %4, i32 0, i32 0
  %5 = load ptr, ptr %tld, align 8
  %heap_backing = getelementptr inbounds %struct.mi_tld_s, ptr %5, i32 0, i32 2
  %6 = load ptr, ptr %heap_backing, align 8
  call void @_mi_heap_set_default_direct(ptr noundef %6)
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %if.end3
  store ptr null, ptr %prev, align 8
  %7 = load ptr, ptr %heap.addr, align 8
  %tld7 = getelementptr inbounds %struct.mi_heap_s, ptr %7, i32 0, i32 0
  %8 = load ptr, ptr %tld7, align 8
  %heaps = getelementptr inbounds %struct.mi_tld_s, ptr %8, i32 0, i32 3
  %9 = load ptr, ptr %heaps, align 8
  store ptr %9, ptr %curr, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end6
  %10 = load ptr, ptr %curr, align 8
  %11 = load ptr, ptr %heap.addr, align 8
  %cmp8 = icmp ne ptr %10, %11
  br i1 %cmp8, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %12 = load ptr, ptr %curr, align 8
  %cmp9 = icmp ne ptr %12, null
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %13 = phi i1 [ false, %while.cond ], [ %cmp9, %land.rhs ]
  br i1 %13, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %14 = load ptr, ptr %curr, align 8
  store ptr %14, ptr %prev, align 8
  %15 = load ptr, ptr %curr, align 8
  %next = getelementptr inbounds %struct.mi_heap_s, ptr %15, i32 0, i32 12
  %16 = load ptr, ptr %next, align 8
  store ptr %16, ptr %curr, align 8
  br label %while.cond, !llvm.loop !41

while.end:                                        ; preds = %land.end
  %17 = load ptr, ptr %curr, align 8
  %18 = load ptr, ptr %heap.addr, align 8
  %cmp10 = icmp eq ptr %17, %18
  br i1 %cmp10, label %if.then11, label %if.end20

if.then11:                                        ; preds = %while.end
  %19 = load ptr, ptr %prev, align 8
  %cmp12 = icmp ne ptr %19, null
  br i1 %cmp12, label %if.then13, label %if.else

if.then13:                                        ; preds = %if.then11
  %20 = load ptr, ptr %heap.addr, align 8
  %next14 = getelementptr inbounds %struct.mi_heap_s, ptr %20, i32 0, i32 12
  %21 = load ptr, ptr %next14, align 8
  %22 = load ptr, ptr %prev, align 8
  %next15 = getelementptr inbounds %struct.mi_heap_s, ptr %22, i32 0, i32 12
  store ptr %21, ptr %next15, align 8
  br label %if.end19

if.else:                                          ; preds = %if.then11
  %23 = load ptr, ptr %heap.addr, align 8
  %next16 = getelementptr inbounds %struct.mi_heap_s, ptr %23, i32 0, i32 12
  %24 = load ptr, ptr %next16, align 8
  %25 = load ptr, ptr %heap.addr, align 8
  %tld17 = getelementptr inbounds %struct.mi_heap_s, ptr %25, i32 0, i32 0
  %26 = load ptr, ptr %tld17, align 8
  %heaps18 = getelementptr inbounds %struct.mi_tld_s, ptr %26, i32 0, i32 3
  store ptr %24, ptr %heaps18, align 8
  br label %if.end19

if.end19:                                         ; preds = %if.else, %if.then13
  br label %if.end20

if.end20:                                         ; preds = %if.end19, %while.end
  %27 = load ptr, ptr %heap.addr, align 8
  call void @mi_free(ptr noundef %27)
  br label %return

return:                                           ; preds = %if.end20, %if.then2, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_heap_unsafe_destroy_all() #0 {
entry:
  %bheap = alloca ptr, align 8
  %curr = alloca ptr, align 8
  %next = alloca ptr, align 8
  %call = call ptr @mi_heap_get_backing()
  store ptr %call, ptr %bheap, align 8
  %0 = load ptr, ptr %bheap, align 8
  %tld = getelementptr inbounds %struct.mi_heap_s, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %tld, align 8
  %heaps = getelementptr inbounds %struct.mi_tld_s, ptr %1, i32 0, i32 3
  %2 = load ptr, ptr %heaps, align 8
  store ptr %2, ptr %curr, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %3 = load ptr, ptr %curr, align 8
  %cmp = icmp ne ptr %3, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %4 = load ptr, ptr %curr, align 8
  %next1 = getelementptr inbounds %struct.mi_heap_s, ptr %4, i32 0, i32 12
  %5 = load ptr, ptr %next1, align 8
  store ptr %5, ptr %next, align 8
  %6 = load ptr, ptr %curr, align 8
  %no_reclaim = getelementptr inbounds %struct.mi_heap_s, ptr %6, i32 0, i32 13
  %7 = load i8, ptr %no_reclaim, align 8
  %tobool = trunc i8 %7 to i1
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %while.body
  %8 = load ptr, ptr %curr, align 8
  call void @mi_heap_destroy(ptr noundef %8)
  br label %if.end

if.else:                                          ; preds = %while.body
  %9 = load ptr, ptr %curr, align 8
  call void @_mi_heap_destroy_pages(ptr noundef %9)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %10 = load ptr, ptr %next, align 8
  store ptr %10, ptr %curr, align 8
  br label %while.cond, !llvm.loop !42

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_heap_is_backing(ptr noundef %heap) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  %0 = load ptr, ptr %heap.addr, align 8
  %tld = getelementptr inbounds %struct.mi_heap_s, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %tld, align 8
  %heap_backing = getelementptr inbounds %struct.mi_tld_s, ptr %1, i32 0, i32 2
  %2 = load ptr, ptr %heap_backing, align 8
  %3 = load ptr, ptr %heap.addr, align 8
  %cmp = icmp eq ptr %2, %3
  ret i1 %cmp
}

; Function Attrs: nounwind uwtable
define internal void @mi_heap_absorb(ptr noundef %heap, ptr noundef %from) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %from.addr = alloca ptr, align 8
  %i = alloca i64, align 8
  %pq = alloca ptr, align 8
  %append = alloca ptr, align 8
  %pcount = alloca i64, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store ptr %from, ptr %from.addr, align 8
  %0 = load ptr, ptr %from.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %from.addr, align 8
  %page_count = getelementptr inbounds %struct.mi_heap_s, ptr %1, i32 0, i32 9
  %2 = load i64, ptr %page_count, align 8
  %cmp1 = icmp eq i64 %2, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %3 = load ptr, ptr %from.addr, align 8
  %call = call zeroext i1 @_mi_heap_delayed_free_partial(ptr noundef %3)
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %4 = load i64, ptr %i, align 8
  %cmp2 = icmp ule i64 %4, 74
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load ptr, ptr %heap.addr, align 8
  %pages = getelementptr inbounds %struct.mi_heap_s, ptr %5, i32 0, i32 2
  %6 = load i64, ptr %i, align 8
  %arrayidx = getelementptr [75 x %struct.mi_page_queue_s], ptr %pages, i64 0, i64 %6
  store ptr %arrayidx, ptr %pq, align 8
  %7 = load ptr, ptr %from.addr, align 8
  %pages3 = getelementptr inbounds %struct.mi_heap_s, ptr %7, i32 0, i32 2
  %8 = load i64, ptr %i, align 8
  %arrayidx4 = getelementptr [75 x %struct.mi_page_queue_s], ptr %pages3, i64 0, i64 %8
  store ptr %arrayidx4, ptr %append, align 8
  %9 = load ptr, ptr %heap.addr, align 8
  %10 = load ptr, ptr %pq, align 8
  %11 = load ptr, ptr %append, align 8
  %call5 = call i64 @_mi_page_queue_append(ptr noundef %9, ptr noundef %10, ptr noundef %11)
  store i64 %call5, ptr %pcount, align 8
  %12 = load i64, ptr %pcount, align 8
  %13 = load ptr, ptr %heap.addr, align 8
  %page_count6 = getelementptr inbounds %struct.mi_heap_s, ptr %13, i32 0, i32 9
  %14 = load i64, ptr %page_count6, align 8
  %add = add i64 %14, %12
  store i64 %add, ptr %page_count6, align 8
  %15 = load i64, ptr %pcount, align 8
  %16 = load ptr, ptr %from.addr, align 8
  %page_count7 = getelementptr inbounds %struct.mi_heap_s, ptr %16, i32 0, i32 9
  %17 = load i64, ptr %page_count7, align 8
  %sub = sub i64 %17, %15
  store i64 %sub, ptr %page_count7, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %18 = load i64, ptr %i, align 8
  %inc = add i64 %18, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !43

for.end:                                          ; preds = %for.cond
  %19 = load ptr, ptr %from.addr, align 8
  call void @_mi_heap_delayed_free_all(ptr noundef %19)
  %20 = load ptr, ptr %from.addr, align 8
  call void @mi_heap_reset_pages(ptr noundef %20)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define hidden ptr @mi_heap_set_default(ptr noundef %heap) #0 {
entry:
  %retval = alloca ptr, align 8
  %heap.addr = alloca ptr, align 8
  %old = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  %0 = load ptr, ptr %heap.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %heap.addr, align 8
  %call = call zeroext i1 @mi_heap_is_initialized(ptr noundef %1)
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %call1 = call ptr @mi_prim_get_default_heap()
  store ptr %call1, ptr %old, align 8
  %2 = load ptr, ptr %heap.addr, align 8
  call void @_mi_heap_set_default_direct(ptr noundef %2)
  %3 = load ptr, ptr %old, align 8
  store ptr %3, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load ptr, ptr %retval, align 8
  ret ptr %4
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_heap_set_default_direct(ptr noundef %heap) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  %0 = load ptr, ptr %heap.addr, align 8
  %1 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @_mi_heap_default)
  store ptr %0, ptr %1, align 8
  %2 = load ptr, ptr %heap.addr, align 8
  call void @_mi_prim_thread_associate_default_heap(ptr noundef %2)
  ret void
}

; Function Attrs: nounwind uwtable
define hidden zeroext i1 @mi_heap_contains_block(ptr noundef %heap, ptr noundef %p) #0 {
entry:
  %retval = alloca i1, align 1
  %heap.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %heap.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %heap.addr, align 8
  %call = call zeroext i1 @mi_heap_is_initialized(ptr noundef %1)
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %2 = load ptr, ptr %heap.addr, align 8
  %3 = load ptr, ptr %p.addr, align 8
  %call1 = call ptr @mi_heap_of_block(ptr noundef %3)
  %cmp2 = icmp eq ptr %2, %call1
  store i1 %cmp2, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load i1, ptr %retval, align 1
  ret i1 %4
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_heap_of_block(ptr noundef %p) #0 {
entry:
  %retval = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %segment = alloca ptr, align 8
  %valid = alloca i8, align 1
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %p.addr, align 8
  %call = call ptr @_mi_ptr_segment(ptr noundef %1)
  store ptr %call, ptr %segment, align 8
  %2 = load ptr, ptr %segment, align 8
  %call1 = call i64 @_mi_ptr_cookie(ptr noundef %2)
  %3 = load ptr, ptr %segment, align 8
  %cookie = getelementptr inbounds %struct.mi_segment_s, ptr %3, i32 0, i32 12
  %4 = load i64, ptr %cookie, align 8
  %cmp2 = icmp eq i64 %call1, %4
  %frombool = zext i1 %cmp2 to i8
  store i8 %frombool, ptr %valid, align 1
  %5 = load i8, ptr %valid, align 1
  %tobool = trunc i8 %5 to i1
  %lnot = xor i1 %tobool, true
  %lnot3 = xor i1 %lnot, true
  %lnot4 = xor i1 %lnot3, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool5 = icmp ne i64 %conv, 0
  br i1 %tobool5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end7:                                          ; preds = %if.end
  %6 = load ptr, ptr %segment, align 8
  %7 = load ptr, ptr %p.addr, align 8
  %call8 = call ptr @_mi_segment_page_of(ptr noundef %6, ptr noundef %7)
  %call9 = call ptr @mi_page_heap(ptr noundef %call8)
  store ptr %call9, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end7, %if.then6, %if.then
  %8 = load ptr, ptr %retval, align 8
  ret ptr %8
}

; Function Attrs: nounwind uwtable
define hidden zeroext i1 @mi_heap_check_owned(ptr noundef %heap, ptr noundef %p) #0 {
entry:
  %retval = alloca i1, align 1
  %heap.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %found = alloca i8, align 1
  store ptr %heap, ptr %heap.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %heap.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %heap.addr, align 8
  %call = call zeroext i1 @mi_heap_is_initialized(ptr noundef %1)
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %2 = load ptr, ptr %p.addr, align 8
  %3 = ptrtoint ptr %2 to i64
  %and = and i64 %3, 7
  %cmp1 = icmp ne i64 %and, 0
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i1 false, ptr %retval, align 1
  br label %return

if.end3:                                          ; preds = %if.end
  store i8 0, ptr %found, align 1
  %4 = load ptr, ptr %heap.addr, align 8
  %5 = load ptr, ptr %p.addr, align 8
  %call4 = call zeroext i1 @mi_heap_visit_pages(ptr noundef %4, ptr noundef @mi_heap_page_check_owned, ptr noundef %5, ptr noundef %found)
  %6 = load i8, ptr %found, align 1
  %tobool = trunc i8 %6 to i1
  store i1 %tobool, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end3, %if.then2, %if.then
  %7 = load i1, ptr %retval, align 1
  ret i1 %7
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_heap_page_check_owned(ptr noundef %heap, ptr noundef %pq, ptr noundef %page, ptr noundef %p, ptr noundef %vfound) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %pq.addr = alloca ptr, align 8
  %page.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %vfound.addr = alloca ptr, align 8
  %found = alloca ptr, align 8
  %segment = alloca ptr, align 8
  %start = alloca ptr, align 8
  %end = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store ptr %pq, ptr %pq.addr, align 8
  store ptr %page, ptr %page.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store ptr %vfound, ptr %vfound.addr, align 8
  %0 = load ptr, ptr %vfound.addr, align 8
  store ptr %0, ptr %found, align 8
  %1 = load ptr, ptr %page.addr, align 8
  %call = call ptr @_mi_page_segment(ptr noundef %1)
  store ptr %call, ptr %segment, align 8
  %2 = load ptr, ptr %segment, align 8
  %3 = load ptr, ptr %page.addr, align 8
  %call1 = call ptr @_mi_page_start(ptr noundef %2, ptr noundef %3, ptr noundef null)
  store ptr %call1, ptr %start, align 8
  %4 = load ptr, ptr %start, align 8
  %5 = load ptr, ptr %page.addr, align 8
  %capacity = getelementptr inbounds %struct.mi_page_s, ptr %5, i32 0, i32 3
  %6 = load i16, ptr %capacity, align 2
  %conv = zext i16 %6 to i64
  %7 = load ptr, ptr %page.addr, align 8
  %call2 = call i64 @mi_page_block_size(ptr noundef %7)
  %mul = mul i64 %conv, %call2
  %add.ptr = getelementptr i8, ptr %4, i64 %mul
  store ptr %add.ptr, ptr %end, align 8
  %8 = load ptr, ptr %p.addr, align 8
  %9 = load ptr, ptr %start, align 8
  %cmp = icmp uge ptr %8, %9
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %10 = load ptr, ptr %p.addr, align 8
  %11 = load ptr, ptr %end, align 8
  %cmp4 = icmp ult ptr %10, %11
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %12 = phi i1 [ false, %entry ], [ %cmp4, %land.rhs ]
  %13 = load ptr, ptr %found, align 8
  %frombool = zext i1 %12 to i8
  store i8 %frombool, ptr %13, align 1
  %14 = load ptr, ptr %found, align 8
  %15 = load i8, ptr %14, align 1
  %tobool = trunc i8 %15 to i1
  %lnot = xor i1 %tobool, true
  ret i1 %lnot
}

; Function Attrs: nounwind uwtable
define hidden zeroext i1 @mi_check_owned(ptr noundef %p) #0 {
entry:
  %p.addr = alloca ptr, align 8
  store ptr %p, ptr %p.addr, align 8
  %call = call ptr @mi_prim_get_default_heap()
  %0 = load ptr, ptr %p.addr, align 8
  %call1 = call zeroext i1 @mi_heap_check_owned(ptr noundef %call, ptr noundef %0)
  ret i1 %call1
}

; Function Attrs: nounwind uwtable
define hidden zeroext i1 @mi_heap_visit_blocks(ptr noundef %heap, i1 noundef zeroext %visit_blocks, ptr noundef %visitor, ptr noundef %arg) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %visit_blocks.addr = alloca i8, align 1
  %visitor.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %args = alloca %struct.mi_visit_blocks_args_s, align 8
  store ptr %heap, ptr %heap.addr, align 8
  %frombool = zext i1 %visit_blocks to i8
  store i8 %frombool, ptr %visit_blocks.addr, align 1
  store ptr %visitor, ptr %visitor.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %visit_blocks1 = getelementptr inbounds %struct.mi_visit_blocks_args_s, ptr %args, i32 0, i32 0
  %0 = load i8, ptr %visit_blocks.addr, align 1
  %tobool = trunc i8 %0 to i1
  %frombool2 = zext i1 %tobool to i8
  store i8 %frombool2, ptr %visit_blocks1, align 8
  %visitor3 = getelementptr inbounds %struct.mi_visit_blocks_args_s, ptr %args, i32 0, i32 1
  %1 = load ptr, ptr %visitor.addr, align 8
  store ptr %1, ptr %visitor3, align 8
  %arg4 = getelementptr inbounds %struct.mi_visit_blocks_args_s, ptr %args, i32 0, i32 2
  %2 = load ptr, ptr %arg.addr, align 8
  store ptr %2, ptr %arg4, align 8
  %3 = load ptr, ptr %heap.addr, align 8
  %call = call zeroext i1 @mi_heap_visit_areas(ptr noundef %3, ptr noundef @mi_heap_area_visitor, ptr noundef %args)
  ret i1 %call
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_heap_visit_areas(ptr noundef %heap, ptr noundef %visitor, ptr noundef %arg) #0 {
entry:
  %retval = alloca i1, align 1
  %heap.addr = alloca ptr, align 8
  %visitor.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store ptr %visitor, ptr %visitor.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %visitor.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %heap.addr, align 8
  %2 = load ptr, ptr %visitor.addr, align 8
  %3 = load ptr, ptr %arg.addr, align 8
  %call = call zeroext i1 @mi_heap_visit_pages(ptr noundef %1, ptr noundef @mi_heap_visit_areas_page, ptr noundef %2, ptr noundef %3)
  store i1 %call, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load i1, ptr %retval, align 1
  ret i1 %4
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_heap_area_visitor(ptr noundef %heap, ptr noundef %xarea, ptr noundef %arg) #0 {
entry:
  %retval = alloca i1, align 1
  %heap.addr = alloca ptr, align 8
  %xarea.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %args = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store ptr %xarea, ptr %xarea.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  store ptr %0, ptr %args, align 8
  %1 = load ptr, ptr %args, align 8
  %visitor = getelementptr inbounds %struct.mi_visit_blocks_args_s, ptr %1, i32 0, i32 1
  %2 = load ptr, ptr %visitor, align 8
  %3 = load ptr, ptr %heap.addr, align 8
  %4 = load ptr, ptr %xarea.addr, align 8
  %area = getelementptr inbounds %struct.mi_heap_area_ex_s, ptr %4, i32 0, i32 0
  %5 = load ptr, ptr %xarea.addr, align 8
  %area1 = getelementptr inbounds %struct.mi_heap_area_ex_s, ptr %5, i32 0, i32 0
  %block_size = getelementptr inbounds %struct.mi_heap_area_s, ptr %area1, i32 0, i32 4
  %6 = load i64, ptr %block_size, align 8
  %7 = load ptr, ptr %args, align 8
  %arg2 = getelementptr inbounds %struct.mi_visit_blocks_args_s, ptr %7, i32 0, i32 2
  %8 = load ptr, ptr %arg2, align 8
  %call = call zeroext i1 %2(ptr noundef %3, ptr noundef %area, ptr noundef null, i64 noundef %6, ptr noundef %8)
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %9 = load ptr, ptr %args, align 8
  %visit_blocks = getelementptr inbounds %struct.mi_visit_blocks_args_s, ptr %9, i32 0, i32 0
  %10 = load i8, ptr %visit_blocks, align 8
  %tobool = trunc i8 %10 to i1
  br i1 %tobool, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  %11 = load ptr, ptr %xarea.addr, align 8
  %12 = load ptr, ptr %args, align 8
  %visitor4 = getelementptr inbounds %struct.mi_visit_blocks_args_s, ptr %12, i32 0, i32 1
  %13 = load ptr, ptr %visitor4, align 8
  %14 = load ptr, ptr %args, align 8
  %arg5 = getelementptr inbounds %struct.mi_visit_blocks_args_s, ptr %14, i32 0, i32 2
  %15 = load ptr, ptr %arg5, align 8
  %call6 = call zeroext i1 @mi_heap_area_visit_blocks(ptr noundef %11, ptr noundef %13, ptr noundef %15)
  store i1 %call6, ptr %retval, align 1
  br label %return

if.else:                                          ; preds = %if.end
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.else, %if.then3, %if.then
  %16 = load i1, ptr %retval, align 1
  ret i1 %16
}

; Function Attrs: nounwind uwtable
define hidden ptr @_mi_heap_main_get() #0 {
entry:
  call void @mi_heap_main_init()
  ret ptr @_mi_heap_main
}

; Function Attrs: nounwind uwtable
define internal void @mi_heap_main_init() #0 {
entry:
  %0 = load i64, ptr getelementptr inbounds (%struct.mi_heap_s, ptr @_mi_heap_main, i32 0, i32 6), align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i64 @_mi_thread_id()
  store i64 %call, ptr getelementptr inbounds (%struct.mi_heap_s, ptr @_mi_heap_main, i32 0, i32 4), align 8
  store i64 1, ptr getelementptr inbounds (%struct.mi_heap_s, ptr @_mi_heap_main, i32 0, i32 6), align 8
  call void @_mi_random_init(ptr noundef getelementptr inbounds (%struct.mi_heap_s, ptr @_mi_heap_main, i32 0, i32 8))
  %call1 = call i64 @_mi_heap_random_next(ptr noundef @_mi_heap_main)
  store i64 %call1, ptr getelementptr inbounds (%struct.mi_heap_s, ptr @_mi_heap_main, i32 0, i32 6), align 8
  %call2 = call i64 @_mi_heap_random_next(ptr noundef @_mi_heap_main)
  store i64 %call2, ptr getelementptr inbounds (%struct.mi_heap_s, ptr @_mi_heap_main, i32 0, i32 7), align 8
  %call3 = call i64 @_mi_heap_random_next(ptr noundef @_mi_heap_main)
  store i64 %call3, ptr getelementptr (%struct.mi_heap_s, ptr @_mi_heap_main, i32 0, i32 7, i64 1), align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_thread_data_collect() #0 {
entry:
  %i = alloca i32, align 4
  %td = alloca ptr, align 8
  %atomic-temp = alloca ptr, align 8
  %.atomictmp = alloca ptr, align 8
  %atomic-temp4 = alloca ptr, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %i, align 4
  %cmp = icmp slt i32 %0, 16
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load i32, ptr %i, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr [16 x ptr], ptr @td_cache, i64 0, i64 %idxprom
  %2 = load atomic i64, ptr %arrayidx monotonic, align 8
  store i64 %2, ptr %atomic-temp, align 8
  %3 = load ptr, ptr %atomic-temp, align 8
  store ptr %3, ptr %td, align 8
  %4 = load ptr, ptr %td, align 8
  %cmp1 = icmp ne ptr %4, null
  br i1 %cmp1, label %if.then, label %if.end7

if.then:                                          ; preds = %for.body
  %5 = load i32, ptr %i, align 4
  %idxprom2 = sext i32 %5 to i64
  %arrayidx3 = getelementptr [16 x ptr], ptr @td_cache, i64 0, i64 %idxprom2
  store ptr null, ptr %.atomictmp, align 8
  %6 = load i64, ptr %.atomictmp, align 8
  %7 = atomicrmw xchg ptr %arrayidx3, i64 %6 acq_rel, align 8
  store i64 %7, ptr %atomic-temp4, align 8
  %8 = load ptr, ptr %atomic-temp4, align 8
  store ptr %8, ptr %td, align 8
  %9 = load ptr, ptr %td, align 8
  %cmp5 = icmp ne ptr %9, null
  br i1 %cmp5, label %if.then6, label %if.end

if.then6:                                         ; preds = %if.then
  %10 = load ptr, ptr %td, align 8
  %11 = load ptr, ptr %td, align 8
  %memid = getelementptr inbounds %struct.mi_thread_data_s, ptr %11, i32 0, i32 2
  call void @_mi_os_free(ptr noundef %10, i64 noundef 4688, ptr noundef byval(%struct.mi_memid_s) align 8 %memid, ptr noundef @_mi_stats_main)
  br label %if.end

if.end:                                           ; preds = %if.then6, %if.then
  br label %if.end7

if.end7:                                          ; preds = %if.end, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end7
  %12 = load i32, ptr %i, align 4
  %inc = add i32 %12, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !44

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define hidden zeroext i1 @_mi_is_main_thread() #0 {
entry:
  %0 = load i64, ptr getelementptr inbounds (%struct.mi_heap_s, ptr @_mi_heap_main, i32 0, i32 4), align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %1 = load i64, ptr getelementptr inbounds (%struct.mi_heap_s, ptr @_mi_heap_main, i32 0, i32 4), align 8
  %call = call i64 @_mi_thread_id()
  %cmp1 = icmp eq i64 %1, %call
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %2 = phi i1 [ true, %entry ], [ %cmp1, %lor.rhs ]
  ret i1 %2
}

; Function Attrs: nounwind uwtable
define hidden i64 @_mi_current_thread_count() #0 {
entry:
  %atomic-temp = alloca i64, align 8
  %0 = load atomic i64, ptr @thread_count monotonic, align 8
  store i64 %0, ptr %atomic-temp, align 8
  %1 = load i64, ptr %atomic-temp, align 8
  ret i64 %1
}

; Function Attrs: nounwind uwtable
define hidden void @mi_process_init() #0 {
entry:
  %pages = alloca i64, align 8
  %reserve_at = alloca i64, align 8
  %ksize = alloca i64, align 8
  call void @mi_heap_main_init()
  %call = call zeroext i1 @mi_atomic_once(ptr noundef @mi_process_init.process_init)
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %if.end21

if.end:                                           ; preds = %entry
  store i8 1, ptr @_mi_process_is_initialized, align 1
  %call1 = call i64 @_mi_thread_id()
  call void (ptr, ...) @_mi_verbose_message(ptr noundef @.str.17, i64 noundef %call1)
  call void @mi_process_setup_auto_thread_done()
  call void @mi_detect_cpu_features()
  call void @_mi_os_init()
  call void @mi_heap_main_init()
  call void (ptr, ...) @_mi_verbose_message(ptr noundef @.str.18, i32 noundef 0)
  call void (ptr, ...) @_mi_verbose_message(ptr noundef @.str.19, ptr noundef @.str.20)
  call void @mi_thread_init()
  call void @mi_stats_reset()
  %call2 = call zeroext i1 @mi_option_is_enabled(i32 noundef 7)
  br i1 %call2, label %if.then3, label %if.end11

if.then3:                                         ; preds = %if.end
  %call4 = call i64 @mi_option_get_clamp(i32 noundef 7, i64 noundef 0, i64 noundef 131072)
  store i64 %call4, ptr %pages, align 8
  %call5 = call i64 @mi_option_get(i32 noundef 8)
  store i64 %call5, ptr %reserve_at, align 8
  %0 = load i64, ptr %reserve_at, align 8
  %cmp = icmp ne i64 %0, -1
  br i1 %cmp, label %if.then6, label %if.else

if.then6:                                         ; preds = %if.then3
  %1 = load i64, ptr %pages, align 8
  %2 = load i64, ptr %reserve_at, align 8
  %conv = trunc i64 %2 to i32
  %3 = load i64, ptr %pages, align 8
  %mul = mul i64 %3, 500
  %call7 = call i32 @mi_reserve_huge_os_pages_at(i64 noundef %1, i32 noundef %conv, i64 noundef %mul)
  br label %if.end10

if.else:                                          ; preds = %if.then3
  %4 = load i64, ptr %pages, align 8
  %5 = load i64, ptr %pages, align 8
  %mul8 = mul i64 %5, 500
  %call9 = call i32 @mi_reserve_huge_os_pages_interleave(i64 noundef %4, i64 noundef 0, i64 noundef %mul8)
  br label %if.end10

if.end10:                                         ; preds = %if.else, %if.then6
  br label %if.end11

if.end11:                                         ; preds = %if.end10, %if.end
  %call12 = call zeroext i1 @mi_option_is_enabled(i32 noundef 9)
  br i1 %call12, label %if.then13, label %if.end21

if.then13:                                        ; preds = %if.end11
  %call14 = call i64 @mi_option_get(i32 noundef 9)
  store i64 %call14, ptr %ksize, align 8
  %6 = load i64, ptr %ksize, align 8
  %cmp15 = icmp sgt i64 %6, 0
  br i1 %cmp15, label %if.then17, label %if.end20

if.then17:                                        ; preds = %if.then13
  %7 = load i64, ptr %ksize, align 8
  %mul18 = mul i64 %7, 1024
  %call19 = call i32 @mi_reserve_os_memory(i64 noundef %mul18, i1 noundef zeroext true, i1 noundef zeroext true)
  br label %if.end20

if.end20:                                         ; preds = %if.then17, %if.then13
  br label %if.end21

if.end21:                                         ; preds = %if.end20, %if.end11, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @_mi_heap_init() #0 {
entry:
  %retval = alloca i1, align 1
  %td = alloca ptr, align 8
  %tld = alloca ptr, align 8
  %heap = alloca ptr, align 8
  %call = call ptr @mi_prim_get_default_heap()
  %call1 = call zeroext i1 @mi_heap_is_initialized(ptr noundef %call)
  br i1 %call1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %call2 = call zeroext i1 @_mi_is_main_thread()
  br i1 %call2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  call void @mi_heap_main_init()
  call void @_mi_heap_set_default_direct(ptr noundef @_mi_heap_main)
  br label %if.end22

if.else:                                          ; preds = %if.end
  %call4 = call ptr @mi_thread_data_zalloc()
  store ptr %call4, ptr %td, align 8
  %0 = load ptr, ptr %td, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.else
  store i1 false, ptr %retval, align 1
  br label %return

if.end6:                                          ; preds = %if.else
  %1 = load ptr, ptr %td, align 8
  %tld7 = getelementptr inbounds %struct.mi_thread_data_s, ptr %1, i32 0, i32 1
  store ptr %tld7, ptr %tld, align 8
  %2 = load ptr, ptr %td, align 8
  %heap8 = getelementptr inbounds %struct.mi_thread_data_s, ptr %2, i32 0, i32 0
  store ptr %heap8, ptr %heap, align 8
  %3 = load ptr, ptr %tld, align 8
  call void @_mi_memcpy_aligned(ptr noundef %3, ptr noundef @tld_empty, i64 noundef 1600)
  %4 = load ptr, ptr %heap, align 8
  call void @_mi_memcpy_aligned(ptr noundef %4, ptr noundef @_mi_heap_empty, i64 noundef 3064)
  %call9 = call i64 @_mi_thread_id()
  %5 = load ptr, ptr %heap, align 8
  %thread_id = getelementptr inbounds %struct.mi_heap_s, ptr %5, i32 0, i32 4
  store i64 %call9, ptr %thread_id, align 8
  %6 = load ptr, ptr %heap, align 8
  %random = getelementptr inbounds %struct.mi_heap_s, ptr %6, i32 0, i32 8
  call void @_mi_random_init(ptr noundef %random)
  %7 = load ptr, ptr %heap, align 8
  %call10 = call i64 @_mi_heap_random_next(ptr noundef %7)
  %or = or i64 %call10, 1
  %8 = load ptr, ptr %heap, align 8
  %cookie = getelementptr inbounds %struct.mi_heap_s, ptr %8, i32 0, i32 6
  store i64 %or, ptr %cookie, align 8
  %9 = load ptr, ptr %heap, align 8
  %call11 = call i64 @_mi_heap_random_next(ptr noundef %9)
  %10 = load ptr, ptr %heap, align 8
  %keys = getelementptr inbounds %struct.mi_heap_s, ptr %10, i32 0, i32 7
  %arrayidx = getelementptr [2 x i64], ptr %keys, i64 0, i64 0
  store i64 %call11, ptr %arrayidx, align 8
  %11 = load ptr, ptr %heap, align 8
  %call12 = call i64 @_mi_heap_random_next(ptr noundef %11)
  %12 = load ptr, ptr %heap, align 8
  %keys13 = getelementptr inbounds %struct.mi_heap_s, ptr %12, i32 0, i32 7
  %arrayidx14 = getelementptr [2 x i64], ptr %keys13, i64 0, i64 1
  store i64 %call12, ptr %arrayidx14, align 8
  %13 = load ptr, ptr %tld, align 8
  %14 = load ptr, ptr %heap, align 8
  %tld15 = getelementptr inbounds %struct.mi_heap_s, ptr %14, i32 0, i32 0
  store ptr %13, ptr %tld15, align 8
  %15 = load ptr, ptr %heap, align 8
  %16 = load ptr, ptr %tld, align 8
  %heap_backing = getelementptr inbounds %struct.mi_tld_s, ptr %16, i32 0, i32 2
  store ptr %15, ptr %heap_backing, align 8
  %17 = load ptr, ptr %heap, align 8
  %18 = load ptr, ptr %tld, align 8
  %heaps = getelementptr inbounds %struct.mi_tld_s, ptr %18, i32 0, i32 3
  store ptr %17, ptr %heaps, align 8
  %19 = load ptr, ptr %tld, align 8
  %stats = getelementptr inbounds %struct.mi_tld_s, ptr %19, i32 0, i32 6
  %20 = load ptr, ptr %tld, align 8
  %segments = getelementptr inbounds %struct.mi_tld_s, ptr %20, i32 0, i32 4
  %stats16 = getelementptr inbounds %struct.mi_segments_tld_s, ptr %segments, i32 0, i32 5
  store ptr %stats, ptr %stats16, align 8
  %21 = load ptr, ptr %tld, align 8
  %os = getelementptr inbounds %struct.mi_tld_s, ptr %21, i32 0, i32 5
  %22 = load ptr, ptr %tld, align 8
  %segments17 = getelementptr inbounds %struct.mi_tld_s, ptr %22, i32 0, i32 4
  %os18 = getelementptr inbounds %struct.mi_segments_tld_s, ptr %segments17, i32 0, i32 6
  store ptr %os, ptr %os18, align 8
  %23 = load ptr, ptr %tld, align 8
  %stats19 = getelementptr inbounds %struct.mi_tld_s, ptr %23, i32 0, i32 6
  %24 = load ptr, ptr %tld, align 8
  %os20 = getelementptr inbounds %struct.mi_tld_s, ptr %24, i32 0, i32 5
  %stats21 = getelementptr inbounds %struct.mi_os_tld_s, ptr %os20, i32 0, i32 1
  store ptr %stats19, ptr %stats21, align 8
  %25 = load ptr, ptr %heap, align 8
  call void @_mi_heap_set_default_direct(ptr noundef %25)
  br label %if.end22

if.end22:                                         ; preds = %if.end6, %if.then3
  store i1 false, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end22, %if.then5, %if.then
  %26 = load i1, ptr %retval, align 1
  ret i1 %26
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_stat_increase(ptr noundef %stat, i64 noundef %amount) #0 {
entry:
  %stat.addr = alloca ptr, align 8
  %amount.addr = alloca i64, align 8
  store ptr %stat, ptr %stat.addr, align 8
  store i64 %amount, ptr %amount.addr, align 8
  %0 = load ptr, ptr %stat.addr, align 8
  %1 = load i64, ptr %amount.addr, align 8
  call void @mi_stat_update(ptr noundef %0, i64 noundef %1)
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @mi_thread_done() #0 {
entry:
  call void @_mi_thread_done(ptr noundef null)
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_thread_done(ptr noundef %heap) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %.atomictmp = alloca i64, align 8
  %atomic-temp = alloca i64, align 8
  store ptr %heap, ptr %heap.addr, align 8
  %0 = load ptr, ptr %heap.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end3

if.then:                                          ; preds = %entry
  %call = call ptr @mi_prim_get_default_heap()
  store ptr %call, ptr %heap.addr, align 8
  %1 = load ptr, ptr %heap.addr, align 8
  %cmp1 = icmp eq ptr %1, null
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  br label %if.end13

if.end:                                           ; preds = %if.then
  br label %if.end3

if.end3:                                          ; preds = %if.end, %entry
  %2 = load ptr, ptr %heap.addr, align 8
  %call4 = call zeroext i1 @mi_heap_is_initialized(ptr noundef %2)
  br i1 %call4, label %if.end6, label %if.then5

if.then5:                                         ; preds = %if.end3
  br label %if.end13

if.end6:                                          ; preds = %if.end3
  store i64 1, ptr %.atomictmp, align 8
  %3 = load i64, ptr %.atomictmp, align 8
  %4 = atomicrmw sub ptr @thread_count, i64 %3 monotonic, align 8
  store i64 %4, ptr %atomic-temp, align 8
  call void @_mi_stat_decrease(ptr noundef getelementptr inbounds (%struct.mi_stats_s, ptr @_mi_stats_main, i32 0, i32 9), i64 noundef 1)
  %5 = load ptr, ptr %heap.addr, align 8
  %thread_id = getelementptr inbounds %struct.mi_heap_s, ptr %5, i32 0, i32 4
  %6 = load i64, ptr %thread_id, align 8
  %call7 = call i64 @_mi_thread_id()
  %cmp8 = icmp ne i64 %6, %call7
  br i1 %cmp8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end6
  br label %if.end13

if.end10:                                         ; preds = %if.end6
  %7 = load ptr, ptr %heap.addr, align 8
  %call11 = call zeroext i1 @_mi_heap_done(ptr noundef %7)
  br i1 %call11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end10
  br label %if.end13

if.end13:                                         ; preds = %if.then12, %if.end10, %if.then9, %if.then5, %if.then2
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @_mi_heap_done(ptr noundef %heap) #0 {
entry:
  %retval = alloca i1, align 1
  %heap.addr = alloca ptr, align 8
  %curr = alloca ptr, align 8
  %next = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  %0 = load ptr, ptr %heap.addr, align 8
  %call = call zeroext i1 @mi_heap_is_initialized(ptr noundef %0)
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call zeroext i1 @_mi_is_main_thread()
  %cond = select i1 %call1, ptr @_mi_heap_main, ptr @_mi_heap_empty
  call void @_mi_heap_set_default_direct(ptr noundef %cond)
  %1 = load ptr, ptr %heap.addr, align 8
  %tld = getelementptr inbounds %struct.mi_heap_s, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %tld, align 8
  %heap_backing = getelementptr inbounds %struct.mi_tld_s, ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %heap_backing, align 8
  store ptr %3, ptr %heap.addr, align 8
  %4 = load ptr, ptr %heap.addr, align 8
  %call2 = call zeroext i1 @mi_heap_is_initialized(ptr noundef %4)
  br i1 %call2, label %if.end4, label %if.then3

if.then3:                                         ; preds = %if.end
  store i1 false, ptr %retval, align 1
  br label %return

if.end4:                                          ; preds = %if.end
  %5 = load ptr, ptr %heap.addr, align 8
  %tld5 = getelementptr inbounds %struct.mi_heap_s, ptr %5, i32 0, i32 0
  %6 = load ptr, ptr %tld5, align 8
  %heaps = getelementptr inbounds %struct.mi_tld_s, ptr %6, i32 0, i32 3
  %7 = load ptr, ptr %heaps, align 8
  store ptr %7, ptr %curr, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end9, %if.end4
  %8 = load ptr, ptr %curr, align 8
  %cmp = icmp ne ptr %8, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %9 = load ptr, ptr %curr, align 8
  %next6 = getelementptr inbounds %struct.mi_heap_s, ptr %9, i32 0, i32 12
  %10 = load ptr, ptr %next6, align 8
  store ptr %10, ptr %next, align 8
  %11 = load ptr, ptr %curr, align 8
  %12 = load ptr, ptr %heap.addr, align 8
  %cmp7 = icmp ne ptr %11, %12
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %while.body
  %13 = load ptr, ptr %curr, align 8
  call void @mi_heap_delete(ptr noundef %13)
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %while.body
  %14 = load ptr, ptr %next, align 8
  store ptr %14, ptr %curr, align 8
  br label %while.cond, !llvm.loop !45

while.end:                                        ; preds = %while.cond
  %15 = load ptr, ptr %heap.addr, align 8
  %cmp10 = icmp ne ptr %15, @_mi_heap_main
  br i1 %cmp10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %while.end
  %16 = load ptr, ptr %heap.addr, align 8
  call void @_mi_heap_collect_abandon(ptr noundef %16)
  br label %if.end12

if.end12:                                         ; preds = %if.then11, %while.end
  %17 = load ptr, ptr %heap.addr, align 8
  %tld13 = getelementptr inbounds %struct.mi_heap_s, ptr %17, i32 0, i32 0
  %18 = load ptr, ptr %tld13, align 8
  %stats = getelementptr inbounds %struct.mi_tld_s, ptr %18, i32 0, i32 6
  call void @_mi_stats_done(ptr noundef %stats)
  %19 = load ptr, ptr %heap.addr, align 8
  %cmp14 = icmp ne ptr %19, @_mi_heap_main
  br i1 %cmp14, label %if.then15, label %if.else

if.then15:                                        ; preds = %if.end12
  %20 = load ptr, ptr %heap.addr, align 8
  call void @mi_thread_data_free(ptr noundef %20)
  br label %if.end16

if.else:                                          ; preds = %if.end12
  br label %if.end16

if.end16:                                         ; preds = %if.else, %if.then15
  store i1 false, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end16, %if.then3, %if.then
  %21 = load i1, ptr %retval, align 1
  ret i1 %21
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare nonnull ptr @llvm.threadlocal.address.p0(ptr nonnull) #5

; Function Attrs: nounwind uwtable
define hidden void @_mi_prim_thread_associate_default_heap(ptr noundef %heap) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  %0 = load i32, ptr @_mi_heap_default_key, align 4
  %cmp = icmp ne i32 %0, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i32, ptr @_mi_heap_default_key, align 4
  %2 = load ptr, ptr %heap.addr, align 8
  %call = call i32 @pthread_setspecific(i32 noundef %1, ptr noundef %2) #15
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define hidden zeroext i1 @_mi_preloading() #0 {
entry:
  %0 = load i8, ptr @os_preloading, align 1
  %tobool = trunc i8 %0 to i1
  ret i1 %tobool
}

; Function Attrs: nounwind uwtable
define hidden zeroext i1 @mi_is_redirected() #0 {
entry:
  %0 = load i8, ptr @mi_redirected, align 1
  %tobool = trunc i8 %0 to i1
  ret i1 %tobool
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_atomic_once(ptr noundef %once) #0 {
entry:
  %retval = alloca i1, align 1
  %once.addr = alloca ptr, align 8
  %atomic-temp = alloca i64, align 8
  %expected = alloca i64, align 8
  %.atomictmp = alloca i64, align 8
  %cmpxchg.bool = alloca i8, align 1
  store ptr %once, ptr %once.addr, align 8
  %0 = load ptr, ptr %once.addr, align 8
  %1 = load atomic i64, ptr %0 monotonic, align 8
  store i64 %1, ptr %atomic-temp, align 8
  %2 = load i64, ptr %atomic-temp, align 8
  %cmp = icmp ne i64 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  store i64 0, ptr %expected, align 8
  %3 = load ptr, ptr %once.addr, align 8
  store i64 1, ptr %.atomictmp, align 8
  %4 = load i64, ptr %expected, align 8
  %5 = load i64, ptr %.atomictmp, align 8
  %6 = cmpxchg ptr %3, i64 %4, i64 %5 acq_rel acquire, align 8
  %7 = extractvalue { i64, i1 } %6, 0
  %8 = extractvalue { i64, i1 } %6, 1
  br i1 %8, label %cmpxchg.continue, label %cmpxchg.store_expected

cmpxchg.store_expected:                           ; preds = %if.end
  store i64 %7, ptr %expected, align 8
  br label %cmpxchg.continue

cmpxchg.continue:                                 ; preds = %cmpxchg.store_expected, %if.end
  %frombool = zext i1 %8 to i8
  store i8 %frombool, ptr %cmpxchg.bool, align 1
  %9 = load i8, ptr %cmpxchg.bool, align 1
  %tobool = trunc i8 %9 to i1
  store i1 %tobool, ptr %retval, align 1
  br label %return

return:                                           ; preds = %cmpxchg.continue, %if.then
  %10 = load i1, ptr %retval, align 1
  ret i1 %10
}

; Function Attrs: nounwind uwtable
define internal void @mi_process_setup_auto_thread_done() #0 {
entry:
  %0 = load i8, ptr @mi_process_setup_auto_thread_done.tls_initialized, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  store i8 1, ptr @mi_process_setup_auto_thread_done.tls_initialized, align 1
  call void @_mi_prim_thread_init_auto_done()
  call void @_mi_heap_set_default_direct(ptr noundef @_mi_heap_main)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_detect_cpu_features() #0 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_os_init() #0 {
entry:
  call void @_mi_prim_mem_init(ptr noundef @mi_os_mem_config)
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @mi_stats_reset() #0 {
entry:
  %stats = alloca ptr, align 8
  %call = call ptr @mi_stats_get_default()
  store ptr %call, ptr %stats, align 8
  %0 = load ptr, ptr %stats, align 8
  %cmp = icmp ne ptr %0, @_mi_stats_main
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %stats, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %1, i8 0, i64 640, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  call void @llvm.memset.p0.i64(ptr align 64 @_mi_stats_main, i8 0, i64 640, i1 false)
  %2 = load i64, ptr @mi_process_start, align 8
  %cmp1 = icmp eq i64 %2, 0
  br i1 %cmp1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %call3 = call i64 @_mi_clock_start()
  store i64 %call3, ptr @mi_process_start, align 8
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define hidden i64 @mi_option_get_clamp(i32 noundef %option, i64 noundef %min, i64 noundef %max) #0 {
entry:
  %option.addr = alloca i32, align 4
  %min.addr = alloca i64, align 8
  %max.addr = alloca i64, align 8
  %x = alloca i64, align 8
  store i32 %option, ptr %option.addr, align 4
  store i64 %min, ptr %min.addr, align 8
  store i64 %max, ptr %max.addr, align 8
  %0 = load i32, ptr %option.addr, align 4
  %call = call i64 @mi_option_get(i32 noundef %0)
  store i64 %call, ptr %x, align 8
  %1 = load i64, ptr %x, align 8
  %2 = load i64, ptr %min.addr, align 8
  %cmp = icmp slt i64 %1, %2
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load i64, ptr %min.addr, align 8
  br label %cond.end4

cond.false:                                       ; preds = %entry
  %4 = load i64, ptr %x, align 8
  %5 = load i64, ptr %max.addr, align 8
  %cmp1 = icmp sgt i64 %4, %5
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %6 = load i64, ptr %max.addr, align 8
  br label %cond.end

cond.false3:                                      ; preds = %cond.false
  %7 = load i64, ptr %x, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false3, %cond.true2
  %cond = phi i64 [ %6, %cond.true2 ], [ %7, %cond.false3 ]
  br label %cond.end4

cond.end4:                                        ; preds = %cond.end, %cond.true
  %cond5 = phi i64 [ %3, %cond.true ], [ %cond, %cond.end ]
  ret i64 %cond5
}

; Function Attrs: nounwind uwtable
define hidden i64 @mi_option_get(i32 noundef %option) #0 {
entry:
  %retval = alloca i64, align 8
  %option.addr = alloca i32, align 4
  %desc = alloca ptr, align 8
  store i32 %option, ptr %option.addr, align 4
  %0 = load i32, ptr %option.addr, align 4
  %cmp = icmp ult i32 %0, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, ptr %option.addr, align 4
  %cmp1 = icmp uge i32 %1, 26
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i64 0, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %2 = load i32, ptr %option.addr, align 4
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr [26 x %struct.mi_option_desc_s], ptr @options, i64 0, i64 %idxprom
  store ptr %arrayidx, ptr %desc, align 8
  %3 = load ptr, ptr %desc, align 8
  %init = getelementptr inbounds %struct.mi_option_desc_s, ptr %3, i32 0, i32 1
  %4 = load i32, ptr %init, align 8
  %cmp2 = icmp eq i32 %4, 0
  %lnot = xor i1 %cmp2, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  %5 = load ptr, ptr %desc, align 8
  call void @mi_option_init(ptr noundef %5)
  br label %if.end5

if.end5:                                          ; preds = %if.then4, %if.end
  %6 = load ptr, ptr %desc, align 8
  %value = getelementptr inbounds %struct.mi_option_desc_s, ptr %6, i32 0, i32 0
  %7 = load i64, ptr %value, align 8
  store i64 %7, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end5, %if.then
  %8 = load i64, ptr %retval, align 8
  ret i64 %8
}

; Function Attrs: nounwind uwtable
define internal void @_mi_process_init() #0 {
entry:
  call void @mi_process_load()
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_process_load() #0 {
entry:
  %msg = alloca ptr, align 8
  call void @mi_heap_main_init()
  store i8 0, ptr @os_preloading, align 1
  %call = call i32 @atexit(ptr noundef @mi_process_done) #15
  call void @_mi_options_init()
  call void @mi_process_setup_auto_thread_done()
  call void @mi_process_init()
  %0 = load i8, ptr @mi_redirected, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void (ptr, ...) @_mi_verbose_message(ptr noundef @.str.48)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  store ptr null, ptr %msg, align 8
  %call1 = call zeroext i1 @mi_allocator_init(ptr noundef %msg)
  %1 = load ptr, ptr %msg, align 8
  %cmp = icmp ne ptr %1, null
  br i1 %cmp, label %land.lhs.true, label %if.end5

land.lhs.true:                                    ; preds = %if.end
  %call2 = call zeroext i1 @mi_option_is_enabled(i32 noundef 2)
  br i1 %call2, label %if.then4, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %call3 = call zeroext i1 @mi_option_is_enabled(i32 noundef 0)
  br i1 %call3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %lor.lhs.false, %land.lhs.true
  %2 = load ptr, ptr %msg, align 8
  call void @_mi_fputs(ptr noundef null, ptr noundef null, ptr noundef null, ptr noundef %2)
  br label %if.end5

if.end5:                                          ; preds = %if.then4, %lor.lhs.false, %if.end
  call void @_mi_random_reinit_if_weak(ptr noundef getelementptr inbounds (%struct.mi_heap_s, ptr @_mi_heap_main, i32 0, i32 8))
  ret void
}

; Function Attrs: nounwind uwtable
define hidden i32 @mi_version() #0 {
entry:
  ret i32 212
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_options_init() #0 {
entry:
  %i = alloca i32, align 4
  %option = alloca i32, align 4
  %l = alloca i64, align 8
  %desc = alloca ptr, align 8
  call void @mi_add_stderr_output()
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %i, align 4
  %cmp = icmp slt i32 %0, 26
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load i32, ptr %i, align 4
  store i32 %1, ptr %option, align 4
  %2 = load i32, ptr %option, align 4
  %call = call i64 @mi_option_get(i32 noundef %2)
  store i64 %call, ptr %l, align 8
  %3 = load i32, ptr %option, align 4
  %idxprom = zext i32 %3 to i64
  %arrayidx = getelementptr [26 x %struct.mi_option_desc_s], ptr @options, i64 0, i64 %idxprom
  store ptr %arrayidx, ptr %desc, align 8
  %4 = load ptr, ptr %desc, align 8
  %name = getelementptr inbounds %struct.mi_option_desc_s, ptr %4, i32 0, i32 3
  %5 = load ptr, ptr %name, align 8
  %6 = load ptr, ptr %desc, align 8
  %value = getelementptr inbounds %struct.mi_option_desc_s, ptr %6, i32 0, i32 0
  %7 = load i64, ptr %value, align 8
  call void (ptr, ...) @_mi_verbose_message(ptr noundef @.str.21, ptr noundef %5, i64 noundef %7)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %8 = load i32, ptr %i, align 4
  %inc = add i32 %8, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !46

for.end:                                          ; preds = %for.cond
  %call1 = call i64 @mi_option_get(i32 noundef 19)
  store i64 %call1, ptr @mi_max_error_count, align 8
  %call2 = call i64 @mi_option_get(i32 noundef 20)
  store i64 %call2, ptr @mi_max_warning_count, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_add_stderr_output() #0 {
entry:
  call void @mi_out_buf_flush(ptr noundef @mi_out_stderr, i1 noundef zeroext false, ptr noundef null)
  store volatile ptr @mi_out_buf_stderr, ptr @mi_out_default, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_option_init(ptr noundef %desc) #0 {
entry:
  %desc.addr = alloca ptr, align 8
  %s = alloca [65 x i8], align 16
  %buf = alloca [65 x i8], align 16
  %found = alloca i8, align 1
  %len = alloca i64, align 8
  %i = alloca i64, align 8
  %end = alloca ptr, align 8
  %value41 = alloca i64, align 8
  store ptr %desc, ptr %desc.addr, align 8
  %arraydecay = getelementptr inbounds [65 x i8], ptr %buf, i64 0, i64 0
  call void @_mi_strlcpy(ptr noundef %arraydecay, ptr noundef @.str.84, i64 noundef 65)
  %arraydecay1 = getelementptr inbounds [65 x i8], ptr %buf, i64 0, i64 0
  %0 = load ptr, ptr %desc.addr, align 8
  %name = getelementptr inbounds %struct.mi_option_desc_s, ptr %0, i32 0, i32 3
  %1 = load ptr, ptr %name, align 8
  call void @_mi_strlcat(ptr noundef %arraydecay1, ptr noundef %1, i64 noundef 65)
  %arraydecay2 = getelementptr inbounds [65 x i8], ptr %buf, i64 0, i64 0
  %arraydecay3 = getelementptr inbounds [65 x i8], ptr %s, i64 0, i64 0
  %call = call zeroext i1 @mi_getenv(ptr noundef %arraydecay2, ptr noundef %arraydecay3, i64 noundef 65)
  %frombool = zext i1 %call to i8
  store i8 %frombool, ptr %found, align 1
  %2 = load i8, ptr %found, align 1
  %tobool = trunc i8 %2 to i1
  br i1 %tobool, label %if.end15, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %3 = load ptr, ptr %desc.addr, align 8
  %legacy_name = getelementptr inbounds %struct.mi_option_desc_s, ptr %3, i32 0, i32 4
  %4 = load ptr, ptr %legacy_name, align 8
  %cmp = icmp ne ptr %4, null
  br i1 %cmp, label %if.then, label %if.end15

if.then:                                          ; preds = %land.lhs.true
  %arraydecay4 = getelementptr inbounds [65 x i8], ptr %buf, i64 0, i64 0
  call void @_mi_strlcpy(ptr noundef %arraydecay4, ptr noundef @.str.84, i64 noundef 65)
  %arraydecay5 = getelementptr inbounds [65 x i8], ptr %buf, i64 0, i64 0
  %5 = load ptr, ptr %desc.addr, align 8
  %legacy_name6 = getelementptr inbounds %struct.mi_option_desc_s, ptr %5, i32 0, i32 4
  %6 = load ptr, ptr %legacy_name6, align 8
  call void @_mi_strlcat(ptr noundef %arraydecay5, ptr noundef %6, i64 noundef 65)
  %arraydecay7 = getelementptr inbounds [65 x i8], ptr %buf, i64 0, i64 0
  %arraydecay8 = getelementptr inbounds [65 x i8], ptr %s, i64 0, i64 0
  %call9 = call zeroext i1 @mi_getenv(ptr noundef %arraydecay7, ptr noundef %arraydecay8, i64 noundef 65)
  %frombool10 = zext i1 %call9 to i8
  store i8 %frombool10, ptr %found, align 1
  %7 = load i8, ptr %found, align 1
  %tobool11 = trunc i8 %7 to i1
  br i1 %tobool11, label %if.then12, label %if.end

if.then12:                                        ; preds = %if.then
  %8 = load ptr, ptr %desc.addr, align 8
  %legacy_name13 = getelementptr inbounds %struct.mi_option_desc_s, ptr %8, i32 0, i32 4
  %9 = load ptr, ptr %legacy_name13, align 8
  %10 = load ptr, ptr %desc.addr, align 8
  %name14 = getelementptr inbounds %struct.mi_option_desc_s, ptr %10, i32 0, i32 3
  %11 = load ptr, ptr %name14, align 8
  call void (ptr, ...) @_mi_warning_message(ptr noundef @.str.85, ptr noundef %9, ptr noundef %11)
  br label %if.end

if.end:                                           ; preds = %if.then12, %if.then
  br label %if.end15

if.end15:                                         ; preds = %if.end, %land.lhs.true, %entry
  %12 = load i8, ptr %found, align 1
  %tobool16 = trunc i8 %12 to i1
  br i1 %tobool16, label %if.then17, label %if.else116

if.then17:                                        ; preds = %if.end15
  %arraydecay18 = getelementptr inbounds [65 x i8], ptr %s, i64 0, i64 0
  %call19 = call i64 @_mi_strnlen(ptr noundef %arraydecay18, i64 noundef 64)
  store i64 %call19, ptr %len, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then17
  %13 = load i64, ptr %i, align 8
  %14 = load i64, ptr %len, align 8
  %cmp20 = icmp ult i64 %13, %14
  br i1 %cmp20, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %15 = load i64, ptr %i, align 8
  %arrayidx = getelementptr [65 x i8], ptr %s, i64 0, i64 %15
  %16 = load i8, ptr %arrayidx, align 1
  %call21 = call signext i8 @_mi_toupper(i8 noundef signext %16)
  %17 = load i64, ptr %i, align 8
  %arrayidx22 = getelementptr [65 x i8], ptr %buf, i64 0, i64 %17
  store i8 %call21, ptr %arrayidx22, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %18 = load i64, ptr %i, align 8
  %inc = add i64 %18, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !47

for.end:                                          ; preds = %for.cond
  %19 = load i64, ptr %len, align 8
  %arrayidx23 = getelementptr [65 x i8], ptr %buf, i64 0, i64 %19
  store i8 0, ptr %arrayidx23, align 1
  %arrayidx24 = getelementptr [65 x i8], ptr %buf, i64 0, i64 0
  %20 = load i8, ptr %arrayidx24, align 16
  %conv = sext i8 %20 to i32
  %cmp25 = icmp eq i32 %conv, 0
  br i1 %cmp25, label %if.then31, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.end
  %arraydecay27 = getelementptr inbounds [65 x i8], ptr %buf, i64 0, i64 0
  %call28 = call ptr @strstr(ptr noundef @.str.86, ptr noundef %arraydecay27) #16
  %cmp29 = icmp ne ptr %call28, null
  br i1 %cmp29, label %if.then31, label %if.else

if.then31:                                        ; preds = %lor.lhs.false, %for.end
  %21 = load ptr, ptr %desc.addr, align 8
  %value = getelementptr inbounds %struct.mi_option_desc_s, ptr %21, i32 0, i32 0
  store i64 1, ptr %value, align 8
  %22 = load ptr, ptr %desc.addr, align 8
  %init = getelementptr inbounds %struct.mi_option_desc_s, ptr %22, i32 0, i32 1
  store i32 2, ptr %init, align 8
  br label %if.end115

if.else:                                          ; preds = %lor.lhs.false
  %arraydecay32 = getelementptr inbounds [65 x i8], ptr %buf, i64 0, i64 0
  %call33 = call ptr @strstr(ptr noundef @.str.87, ptr noundef %arraydecay32) #16
  %cmp34 = icmp ne ptr %call33, null
  br i1 %cmp34, label %if.then36, label %if.else39

if.then36:                                        ; preds = %if.else
  %23 = load ptr, ptr %desc.addr, align 8
  %value37 = getelementptr inbounds %struct.mi_option_desc_s, ptr %23, i32 0, i32 0
  store i64 0, ptr %value37, align 8
  %24 = load ptr, ptr %desc.addr, align 8
  %init38 = getelementptr inbounds %struct.mi_option_desc_s, ptr %24, i32 0, i32 1
  store i32 2, ptr %init38, align 8
  br label %if.end114

if.else39:                                        ; preds = %if.else
  %arraydecay40 = getelementptr inbounds [65 x i8], ptr %buf, i64 0, i64 0
  store ptr %arraydecay40, ptr %end, align 8
  %arraydecay42 = getelementptr inbounds [65 x i8], ptr %buf, i64 0, i64 0
  %call43 = call i64 @strtol(ptr noundef %arraydecay42, ptr noundef %end, i32 noundef 10) #15
  store i64 %call43, ptr %value41, align 8
  %25 = load ptr, ptr %desc.addr, align 8
  %option = getelementptr inbounds %struct.mi_option_desc_s, ptr %25, i32 0, i32 2
  %26 = load i32, ptr %option, align 4
  %cmp44 = icmp eq i32 %26, 9
  br i1 %cmp44, label %if.then50, label %lor.lhs.false46

lor.lhs.false46:                                  ; preds = %if.else39
  %27 = load ptr, ptr %desc.addr, align 8
  %option47 = getelementptr inbounds %struct.mi_option_desc_s, ptr %27, i32 0, i32 2
  %28 = load i32, ptr %option47, align 4
  %cmp48 = icmp eq i32 %28, 23
  br i1 %cmp48, label %if.then50, label %if.end90

if.then50:                                        ; preds = %lor.lhs.false46, %if.else39
  %29 = load ptr, ptr %end, align 8
  %30 = load i8, ptr %29, align 1
  %conv51 = sext i8 %30 to i32
  %cmp52 = icmp eq i32 %conv51, 75
  br i1 %cmp52, label %if.then54, label %if.else55

if.then54:                                        ; preds = %if.then50
  %31 = load ptr, ptr %end, align 8
  %incdec.ptr = getelementptr i8, ptr %31, i32 1
  store ptr %incdec.ptr, ptr %end, align 8
  br label %if.end71

if.else55:                                        ; preds = %if.then50
  %32 = load ptr, ptr %end, align 8
  %33 = load i8, ptr %32, align 1
  %conv56 = sext i8 %33 to i32
  %cmp57 = icmp eq i32 %conv56, 77
  br i1 %cmp57, label %if.then59, label %if.else61

if.then59:                                        ; preds = %if.else55
  %34 = load i64, ptr %value41, align 8
  %mul = mul i64 %34, 1024
  store i64 %mul, ptr %value41, align 8
  %35 = load ptr, ptr %end, align 8
  %incdec.ptr60 = getelementptr i8, ptr %35, i32 1
  store ptr %incdec.ptr60, ptr %end, align 8
  br label %if.end70

if.else61:                                        ; preds = %if.else55
  %36 = load ptr, ptr %end, align 8
  %37 = load i8, ptr %36, align 1
  %conv62 = sext i8 %37 to i32
  %cmp63 = icmp eq i32 %conv62, 71
  br i1 %cmp63, label %if.then65, label %if.else68

if.then65:                                        ; preds = %if.else61
  %38 = load i64, ptr %value41, align 8
  %mul66 = mul i64 %38, 1048576
  store i64 %mul66, ptr %value41, align 8
  %39 = load ptr, ptr %end, align 8
  %incdec.ptr67 = getelementptr i8, ptr %39, i32 1
  store ptr %incdec.ptr67, ptr %end, align 8
  br label %if.end69

if.else68:                                        ; preds = %if.else61
  %40 = load i64, ptr %value41, align 8
  %add = add i64 %40, 1024
  %sub = sub i64 %add, 1
  %div = udiv i64 %sub, 1024
  store i64 %div, ptr %value41, align 8
  br label %if.end69

if.end69:                                         ; preds = %if.else68, %if.then65
  br label %if.end70

if.end70:                                         ; preds = %if.end69, %if.then59
  br label %if.end71

if.end71:                                         ; preds = %if.end70, %if.then54
  %41 = load ptr, ptr %end, align 8
  %arrayidx72 = getelementptr i8, ptr %41, i64 0
  %42 = load i8, ptr %arrayidx72, align 1
  %conv73 = sext i8 %42 to i32
  %cmp74 = icmp eq i32 %conv73, 73
  br i1 %cmp74, label %land.lhs.true76, label %if.else82

land.lhs.true76:                                  ; preds = %if.end71
  %43 = load ptr, ptr %end, align 8
  %arrayidx77 = getelementptr i8, ptr %43, i64 1
  %44 = load i8, ptr %arrayidx77, align 1
  %conv78 = sext i8 %44 to i32
  %cmp79 = icmp eq i32 %conv78, 66
  br i1 %cmp79, label %if.then81, label %if.else82

if.then81:                                        ; preds = %land.lhs.true76
  %45 = load ptr, ptr %end, align 8
  %add.ptr = getelementptr i8, ptr %45, i64 2
  store ptr %add.ptr, ptr %end, align 8
  br label %if.end89

if.else82:                                        ; preds = %land.lhs.true76, %if.end71
  %46 = load ptr, ptr %end, align 8
  %47 = load i8, ptr %46, align 1
  %conv83 = sext i8 %47 to i32
  %cmp84 = icmp eq i32 %conv83, 66
  br i1 %cmp84, label %if.then86, label %if.end88

if.then86:                                        ; preds = %if.else82
  %48 = load ptr, ptr %end, align 8
  %incdec.ptr87 = getelementptr i8, ptr %48, i32 1
  store ptr %incdec.ptr87, ptr %end, align 8
  br label %if.end88

if.end88:                                         ; preds = %if.then86, %if.else82
  br label %if.end89

if.end89:                                         ; preds = %if.end88, %if.then81
  br label %if.end90

if.end90:                                         ; preds = %if.end89, %lor.lhs.false46
  %49 = load ptr, ptr %end, align 8
  %50 = load i8, ptr %49, align 1
  %conv91 = sext i8 %50 to i32
  %cmp92 = icmp eq i32 %conv91, 0
  br i1 %cmp92, label %if.then94, label %if.else97

if.then94:                                        ; preds = %if.end90
  %51 = load i64, ptr %value41, align 8
  %52 = load ptr, ptr %desc.addr, align 8
  %value95 = getelementptr inbounds %struct.mi_option_desc_s, ptr %52, i32 0, i32 0
  store i64 %51, ptr %value95, align 8
  %53 = load ptr, ptr %desc.addr, align 8
  %init96 = getelementptr inbounds %struct.mi_option_desc_s, ptr %53, i32 0, i32 1
  store i32 2, ptr %init96, align 8
  br label %if.end113

if.else97:                                        ; preds = %if.end90
  %54 = load ptr, ptr %desc.addr, align 8
  %init98 = getelementptr inbounds %struct.mi_option_desc_s, ptr %54, i32 0, i32 1
  store i32 1, ptr %init98, align 8
  %55 = load ptr, ptr %desc.addr, align 8
  %option99 = getelementptr inbounds %struct.mi_option_desc_s, ptr %55, i32 0, i32 2
  %56 = load i32, ptr %option99, align 4
  %cmp100 = icmp eq i32 %56, 2
  br i1 %cmp100, label %land.lhs.true102, label %if.else110

land.lhs.true102:                                 ; preds = %if.else97
  %57 = load ptr, ptr %desc.addr, align 8
  %value103 = getelementptr inbounds %struct.mi_option_desc_s, ptr %57, i32 0, i32 0
  %58 = load i64, ptr %value103, align 8
  %cmp104 = icmp eq i64 %58, 0
  br i1 %cmp104, label %if.then106, label %if.else110

if.then106:                                       ; preds = %land.lhs.true102
  %59 = load ptr, ptr %desc.addr, align 8
  %value107 = getelementptr inbounds %struct.mi_option_desc_s, ptr %59, i32 0, i32 0
  store i64 1, ptr %value107, align 8
  %60 = load ptr, ptr %desc.addr, align 8
  %name108 = getelementptr inbounds %struct.mi_option_desc_s, ptr %60, i32 0, i32 3
  %61 = load ptr, ptr %name108, align 8
  call void (ptr, ...) @_mi_warning_message(ptr noundef @.str.88, ptr noundef %61)
  %62 = load ptr, ptr %desc.addr, align 8
  %value109 = getelementptr inbounds %struct.mi_option_desc_s, ptr %62, i32 0, i32 0
  store i64 0, ptr %value109, align 8
  br label %if.end112

if.else110:                                       ; preds = %land.lhs.true102, %if.else97
  %63 = load ptr, ptr %desc.addr, align 8
  %name111 = getelementptr inbounds %struct.mi_option_desc_s, ptr %63, i32 0, i32 3
  %64 = load ptr, ptr %name111, align 8
  call void (ptr, ...) @_mi_warning_message(ptr noundef @.str.88, ptr noundef %64)
  br label %if.end112

if.end112:                                        ; preds = %if.else110, %if.then106
  br label %if.end113

if.end113:                                        ; preds = %if.end112, %if.then94
  br label %if.end114

if.end114:                                        ; preds = %if.end113, %if.then36
  br label %if.end115

if.end115:                                        ; preds = %if.end114, %if.then31
  br label %if.end121

if.else116:                                       ; preds = %if.end15
  %call117 = call zeroext i1 @_mi_preloading()
  br i1 %call117, label %if.end120, label %if.then118

if.then118:                                       ; preds = %if.else116
  %65 = load ptr, ptr %desc.addr, align 8
  %init119 = getelementptr inbounds %struct.mi_option_desc_s, ptr %65, i32 0, i32 1
  store i32 1, ptr %init119, align 8
  br label %if.end120

if.end120:                                        ; preds = %if.then118, %if.else116
  br label %if.end121

if.end121:                                        ; preds = %if.end120, %if.end115
  ret void
}

; Function Attrs: nounwind uwtable
define hidden i64 @mi_option_get_size(i32 noundef %option) #0 {
entry:
  %option.addr = alloca i32, align 4
  %x = alloca i64, align 8
  store i32 %option, ptr %option.addr, align 4
  %0 = load i32, ptr %option.addr, align 4
  %call = call i64 @mi_option_get(i32 noundef %0)
  store i64 %call, ptr %x, align 8
  %1 = load i64, ptr %x, align 8
  %cmp = icmp slt i64 %1, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %2 = load i64, ptr %x, align 8
  %mul = mul i64 %2, 1024
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ 0, %cond.true ], [ %mul, %cond.false ]
  ret i64 %cond
}

; Function Attrs: nounwind uwtable
define hidden void @mi_option_set(i32 noundef %option, i64 noundef %value) #0 {
entry:
  %option.addr = alloca i32, align 4
  %value.addr = alloca i64, align 8
  %desc = alloca ptr, align 8
  store i32 %option, ptr %option.addr, align 4
  store i64 %value, ptr %value.addr, align 8
  %0 = load i32, ptr %option.addr, align 4
  %cmp = icmp ult i32 %0, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, ptr %option.addr, align 4
  %cmp1 = icmp uge i32 %1, 26
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %2 = load i32, ptr %option.addr, align 4
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr [26 x %struct.mi_option_desc_s], ptr @options, i64 0, i64 %idxprom
  store ptr %arrayidx, ptr %desc, align 8
  %3 = load i64, ptr %value.addr, align 8
  %4 = load ptr, ptr %desc, align 8
  %value2 = getelementptr inbounds %struct.mi_option_desc_s, ptr %4, i32 0, i32 0
  store i64 %3, ptr %value2, align 8
  %5 = load ptr, ptr %desc, align 8
  %init = getelementptr inbounds %struct.mi_option_desc_s, ptr %5, i32 0, i32 1
  store i32 2, ptr %init, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @mi_option_set_default(i32 noundef %option, i64 noundef %value) #0 {
entry:
  %option.addr = alloca i32, align 4
  %value.addr = alloca i64, align 8
  %desc = alloca ptr, align 8
  store i32 %option, ptr %option.addr, align 4
  store i64 %value, ptr %value.addr, align 8
  %0 = load i32, ptr %option.addr, align 4
  %cmp = icmp ult i32 %0, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, ptr %option.addr, align 4
  %cmp1 = icmp uge i32 %1, 26
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %if.end5

if.end:                                           ; preds = %lor.lhs.false
  %2 = load i32, ptr %option.addr, align 4
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr [26 x %struct.mi_option_desc_s], ptr @options, i64 0, i64 %idxprom
  store ptr %arrayidx, ptr %desc, align 8
  %3 = load ptr, ptr %desc, align 8
  %init = getelementptr inbounds %struct.mi_option_desc_s, ptr %3, i32 0, i32 1
  %4 = load i32, ptr %init, align 8
  %cmp2 = icmp ne i32 %4, 2
  br i1 %cmp2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %5 = load i64, ptr %value.addr, align 8
  %6 = load ptr, ptr %desc, align 8
  %value4 = getelementptr inbounds %struct.mi_option_desc_s, ptr %6, i32 0, i32 0
  store i64 %5, ptr %value4, align 8
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @mi_option_set_enabled(i32 noundef %option, i1 noundef zeroext %enable) #0 {
entry:
  %option.addr = alloca i32, align 4
  %enable.addr = alloca i8, align 1
  store i32 %option, ptr %option.addr, align 4
  %frombool = zext i1 %enable to i8
  store i8 %frombool, ptr %enable.addr, align 1
  %0 = load i32, ptr %option.addr, align 4
  %1 = load i8, ptr %enable.addr, align 1
  %tobool = trunc i8 %1 to i1
  %cond = select i1 %tobool, i32 1, i32 0
  %conv = sext i32 %cond to i64
  call void @mi_option_set(i32 noundef %0, i64 noundef %conv)
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @mi_option_set_enabled_default(i32 noundef %option, i1 noundef zeroext %enable) #0 {
entry:
  %option.addr = alloca i32, align 4
  %enable.addr = alloca i8, align 1
  store i32 %option, ptr %option.addr, align 4
  %frombool = zext i1 %enable to i8
  store i8 %frombool, ptr %enable.addr, align 1
  %0 = load i32, ptr %option.addr, align 4
  %1 = load i8, ptr %enable.addr, align 1
  %tobool = trunc i8 %1 to i1
  %cond = select i1 %tobool, i32 1, i32 0
  %conv = sext i32 %cond to i64
  call void @mi_option_set_default(i32 noundef %0, i64 noundef %conv)
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @mi_option_enable(i32 noundef %option) #0 {
entry:
  %option.addr = alloca i32, align 4
  store i32 %option, ptr %option.addr, align 4
  %0 = load i32, ptr %option.addr, align 4
  call void @mi_option_set_enabled(i32 noundef %0, i1 noundef zeroext true)
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @mi_option_disable(i32 noundef %option) #0 {
entry:
  %option.addr = alloca i32, align 4
  store i32 %option, ptr %option.addr, align 4
  %0 = load i32, ptr %option.addr, align 4
  call void @mi_option_set_enabled(i32 noundef %0, i1 noundef zeroext false)
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @mi_register_output(ptr noundef %out, ptr noundef %arg) #0 {
entry:
  %out.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %.atomictmp = alloca ptr, align 8
  store ptr %out, ptr %out.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %out.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %out.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ @mi_out_stderr, %cond.true ], [ %1, %cond.false ]
  store volatile ptr %cond, ptr @mi_out_default, align 8
  %2 = load ptr, ptr %arg.addr, align 8
  store ptr %2, ptr %.atomictmp, align 8
  %3 = load i64, ptr %.atomictmp, align 8
  store atomic i64 %3, ptr @mi_out_arg release, align 8
  %4 = load ptr, ptr %out.addr, align 8
  %cmp1 = icmp ne ptr %4, null
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  %5 = load ptr, ptr %out.addr, align 8
  %6 = load ptr, ptr %arg.addr, align 8
  call void @mi_out_buf_flush(ptr noundef %5, i1 noundef zeroext true, ptr noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_out_stderr(ptr noundef %msg, ptr noundef %arg) #0 {
entry:
  %msg.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  store ptr %msg, ptr %msg.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %msg.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %msg.addr, align 8
  %arrayidx = getelementptr i8, ptr %1, i64 0
  %2 = load i8, ptr %arrayidx, align 1
  %conv = sext i8 %2 to i32
  %cmp1 = icmp ne i32 %conv, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %3 = load ptr, ptr %msg.addr, align 8
  call void @_mi_prim_out_stderr(ptr noundef %3)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_out_buf_flush(ptr noundef %out, i1 noundef zeroext %no_more_buf, ptr noundef %arg) #0 {
entry:
  %out.addr = alloca ptr, align 8
  %no_more_buf.addr = alloca i8, align 1
  %arg.addr = alloca ptr, align 8
  %count = alloca i64, align 8
  %.atomictmp = alloca i64, align 8
  %atomic-temp = alloca i64, align 8
  store ptr %out, ptr %out.addr, align 8
  %frombool = zext i1 %no_more_buf to i8
  store i8 %frombool, ptr %no_more_buf.addr, align 1
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %out.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end7

if.end:                                           ; preds = %entry
  %1 = load i8, ptr %no_more_buf.addr, align 1
  %tobool = trunc i8 %1 to i1
  %cond = select i1 %tobool, i64 32768, i64 1
  store i64 %cond, ptr %.atomictmp, align 8
  %2 = load i64, ptr %.atomictmp, align 8
  %3 = atomicrmw add ptr @out_len, i64 %2 acq_rel, align 8
  store i64 %3, ptr %atomic-temp, align 8
  %4 = load i64, ptr %atomic-temp, align 8
  store i64 %4, ptr %count, align 8
  %5 = load i64, ptr %count, align 8
  %cmp1 = icmp ugt i64 %5, 32768
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i64 32768, ptr %count, align 8
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end
  %6 = load i64, ptr %count, align 8
  %arrayidx = getelementptr [32769 x i8], ptr @out_buf, i64 0, i64 %6
  store i8 0, ptr %arrayidx, align 1
  %7 = load ptr, ptr %out.addr, align 8
  %8 = load ptr, ptr %arg.addr, align 8
  call void %7(ptr noundef @out_buf, ptr noundef %8)
  %9 = load i8, ptr %no_more_buf.addr, align 1
  %tobool4 = trunc i8 %9 to i1
  br i1 %tobool4, label %if.end7, label %if.then5

if.then5:                                         ; preds = %if.end3
  %10 = load i64, ptr %count, align 8
  %arrayidx6 = getelementptr [32769 x i8], ptr @out_buf, i64 0, i64 %10
  store i8 10, ptr %arrayidx6, align 1
  br label %if.end7

if.end7:                                          ; preds = %if.then5, %if.end3, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_fputs(ptr noundef %out, ptr noundef %arg, ptr noundef %prefix, ptr noundef %message) #0 {
entry:
  %out.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %prefix.addr = alloca ptr, align 8
  %message.addr = alloca ptr, align 8
  store ptr %out, ptr %out.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr %prefix, ptr %prefix.addr, align 8
  store ptr %message, ptr %message.addr, align 8
  %0 = load ptr, ptr %out.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %out.addr, align 8
  %2 = load ptr, ptr @stdout, align 8
  %cmp1 = icmp eq ptr %1, %2
  br i1 %cmp1, label %if.then, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %3 = load ptr, ptr %out.addr, align 8
  %4 = load ptr, ptr @stderr, align 8
  %cmp3 = icmp eq ptr %3, %4
  br i1 %cmp3, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false2, %lor.lhs.false, %entry
  %call = call zeroext i1 @mi_recurse_enter()
  br i1 %call, label %if.end, label %if.then4

if.then4:                                         ; preds = %if.then
  br label %if.end12

if.end:                                           ; preds = %if.then
  %call5 = call ptr @mi_out_get_default(ptr noundef %arg.addr)
  store ptr %call5, ptr %out.addr, align 8
  %5 = load ptr, ptr %prefix.addr, align 8
  %cmp6 = icmp ne ptr %5, null
  br i1 %cmp6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end
  %6 = load ptr, ptr %out.addr, align 8
  %7 = load ptr, ptr %prefix.addr, align 8
  %8 = load ptr, ptr %arg.addr, align 8
  call void %6(ptr noundef %7, ptr noundef %8)
  br label %if.end8

if.end8:                                          ; preds = %if.then7, %if.end
  %9 = load ptr, ptr %out.addr, align 8
  %10 = load ptr, ptr %message.addr, align 8
  %11 = load ptr, ptr %arg.addr, align 8
  call void %9(ptr noundef %10, ptr noundef %11)
  call void @mi_recurse_exit()
  br label %if.end12

if.else:                                          ; preds = %lor.lhs.false2
  %12 = load ptr, ptr %prefix.addr, align 8
  %cmp9 = icmp ne ptr %12, null
  br i1 %cmp9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.else
  %13 = load ptr, ptr %out.addr, align 8
  %14 = load ptr, ptr %prefix.addr, align 8
  %15 = load ptr, ptr %arg.addr, align 8
  call void %13(ptr noundef %14, ptr noundef %15)
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %if.else
  %16 = load ptr, ptr %out.addr, align 8
  %17 = load ptr, ptr %message.addr, align 8
  %18 = load ptr, ptr %arg.addr, align 8
  call void %16(ptr noundef %17, ptr noundef %18)
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %if.end8, %if.then4
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_recurse_enter() #0 {
entry:
  %call = call zeroext i1 @mi_recurse_enter_prim()
  ret i1 %call
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_out_get_default(ptr noundef %parg) #0 {
entry:
  %parg.addr = alloca ptr, align 8
  %atomic-temp = alloca ptr, align 8
  %out = alloca ptr, align 8
  store ptr %parg, ptr %parg.addr, align 8
  %0 = load ptr, ptr %parg.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load atomic i64, ptr @mi_out_arg acquire, align 8
  store i64 %1, ptr %atomic-temp, align 8
  %2 = load ptr, ptr %atomic-temp, align 8
  %3 = load ptr, ptr %parg.addr, align 8
  store ptr %2, ptr %3, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load volatile ptr, ptr @mi_out_default, align 8
  store ptr %4, ptr %out, align 8
  %5 = load ptr, ptr %out, align 8
  %cmp1 = icmp eq ptr %5, null
  br i1 %cmp1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %6 = load ptr, ptr %out, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ @mi_out_buf, %cond.true ], [ %6, %cond.false ]
  ret ptr %cond
}

; Function Attrs: nounwind uwtable
define internal void @mi_recurse_exit() #0 {
entry:
  call void @mi_recurse_exit_prim()
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_fprintf(ptr noundef %out, ptr noundef %arg, ptr noundef %fmt, ...) #0 {
entry:
  %out.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %fmt.addr = alloca ptr, align 8
  %args = alloca [1 x %struct.__va_list_tag], align 16
  store ptr %out, ptr %out.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr %fmt, ptr %fmt.addr, align 8
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %args, i64 0, i64 0
  call void @llvm.va_start(ptr %arraydecay)
  %0 = load ptr, ptr %out.addr, align 8
  %1 = load ptr, ptr %arg.addr, align 8
  %2 = load ptr, ptr %fmt.addr, align 8
  %arraydecay1 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %args, i64 0, i64 0
  call void @mi_vfprintf(ptr noundef %0, ptr noundef %1, ptr noundef null, ptr noundef %2, ptr noundef %arraydecay1)
  %arraydecay2 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %args, i64 0, i64 0
  call void @llvm.va_end(ptr %arraydecay2)
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare void @llvm.va_start(ptr) #6

; Function Attrs: nounwind uwtable
define internal void @mi_vfprintf(ptr noundef %out, ptr noundef %arg, ptr noundef %prefix, ptr noundef %fmt, ptr noundef %args) #0 {
entry:
  %out.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %prefix.addr = alloca ptr, align 8
  %fmt.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %buf = alloca [512 x i8], align 16
  store ptr %out, ptr %out.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr %prefix, ptr %prefix.addr, align 8
  store ptr %fmt, ptr %fmt.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  %0 = load ptr, ptr %fmt.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %call = call zeroext i1 @mi_recurse_enter()
  br i1 %call, label %if.end2, label %if.then1

if.then1:                                         ; preds = %if.end
  br label %return

if.end2:                                          ; preds = %if.end
  %arraydecay = getelementptr inbounds [512 x i8], ptr %buf, i64 0, i64 0
  %1 = load ptr, ptr %fmt.addr, align 8
  %2 = load ptr, ptr %args.addr, align 8
  %call3 = call i32 @vsnprintf(ptr noundef %arraydecay, i64 noundef 511, ptr noundef %1, ptr noundef %2) #15
  call void @mi_recurse_exit()
  %3 = load ptr, ptr %out.addr, align 8
  %4 = load ptr, ptr %arg.addr, align 8
  %5 = load ptr, ptr %prefix.addr, align 8
  %arraydecay4 = getelementptr inbounds [512 x i8], ptr %buf, i64 0, i64 0
  call void @_mi_fputs(ptr noundef %3, ptr noundef %4, ptr noundef %5, ptr noundef %arraydecay4)
  br label %return

return:                                           ; preds = %if.end2, %if.then1, %if.then
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare void @llvm.va_end(ptr) #6

; Function Attrs: nounwind uwtable
define hidden void @_mi_trace_message(ptr noundef %fmt, ...) #0 {
entry:
  %fmt.addr = alloca ptr, align 8
  %args = alloca [1 x %struct.__va_list_tag], align 16
  store ptr %fmt, ptr %fmt.addr, align 8
  %call = call i64 @mi_option_get(i32 noundef 2)
  %cmp = icmp sle i64 %call, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %args, i64 0, i64 0
  call void @llvm.va_start(ptr %arraydecay)
  %0 = load ptr, ptr %fmt.addr, align 8
  %arraydecay1 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %args, i64 0, i64 0
  call void @mi_vfprintf_thread(ptr noundef null, ptr noundef null, ptr noundef @.str.22, ptr noundef %0, ptr noundef %arraydecay1)
  %arraydecay2 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %args, i64 0, i64 0
  call void @llvm.va_end(ptr %arraydecay2)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_vfprintf_thread(ptr noundef %out, ptr noundef %arg, ptr noundef %prefix, ptr noundef %fmt, ptr noundef %args) #0 {
entry:
  %out.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %prefix.addr = alloca ptr, align 8
  %fmt.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %tprefix = alloca [64 x i8], align 16
  store ptr %out, ptr %out.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr %prefix, ptr %prefix.addr, align 8
  store ptr %fmt, ptr %fmt.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  %0 = load ptr, ptr %prefix.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %prefix.addr, align 8
  %call = call i64 @_mi_strnlen(ptr noundef %1, i64 noundef 33)
  %cmp1 = icmp ule i64 %call, 32
  br i1 %cmp1, label %land.lhs.true2, label %if.else

land.lhs.true2:                                   ; preds = %land.lhs.true
  %call3 = call zeroext i1 @_mi_is_main_thread()
  br i1 %call3, label %if.else, label %if.then

if.then:                                          ; preds = %land.lhs.true2
  %arraydecay = getelementptr inbounds [64 x i8], ptr %tprefix, i64 0, i64 0
  %2 = load ptr, ptr %prefix.addr, align 8
  %call4 = call i64 @_mi_thread_id()
  %call5 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %arraydecay, i64 noundef 64, ptr noundef @.str.82, ptr noundef %2, i64 noundef %call4) #15
  %3 = load ptr, ptr %out.addr, align 8
  %4 = load ptr, ptr %arg.addr, align 8
  %arraydecay6 = getelementptr inbounds [64 x i8], ptr %tprefix, i64 0, i64 0
  %5 = load ptr, ptr %fmt.addr, align 8
  %6 = load ptr, ptr %args.addr, align 8
  call void @mi_vfprintf(ptr noundef %3, ptr noundef %4, ptr noundef %arraydecay6, ptr noundef %5, ptr noundef %6)
  br label %if.end

if.else:                                          ; preds = %land.lhs.true2, %land.lhs.true, %entry
  %7 = load ptr, ptr %out.addr, align 8
  %8 = load ptr, ptr %arg.addr, align 8
  %9 = load ptr, ptr %prefix.addr, align 8
  %10 = load ptr, ptr %fmt.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  call void @mi_vfprintf(ptr noundef %7, ptr noundef %8, ptr noundef %9, ptr noundef %10, ptr noundef %11)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @mi_register_error(ptr noundef %fun, ptr noundef %arg) #0 {
entry:
  %fun.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %.atomictmp = alloca ptr, align 8
  store ptr %fun, ptr %fun.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %fun.addr, align 8
  store volatile ptr %0, ptr @mi_error_handler, align 8
  %1 = load ptr, ptr %arg.addr, align 8
  store ptr %1, ptr %.atomictmp, align 8
  %2 = load i64, ptr %.atomictmp, align 8
  store atomic i64 %2, ptr @mi_error_arg release, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_show_error_message(ptr noundef %fmt, ptr noundef %args) #0 {
entry:
  %fmt.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %.atomictmp = alloca i64, align 8
  %atomic-temp = alloca i64, align 8
  store ptr %fmt, ptr %fmt.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  %call = call zeroext i1 @mi_option_is_enabled(i32 noundef 2)
  br i1 %call, label %if.end6, label %if.then

if.then:                                          ; preds = %entry
  %call1 = call zeroext i1 @mi_option_is_enabled(i32 noundef 0)
  br i1 %call1, label %if.end, label %if.then2

if.then2:                                         ; preds = %if.then
  br label %return

if.end:                                           ; preds = %if.then
  %0 = load i64, ptr @mi_max_error_count, align 8
  %cmp = icmp sge i64 %0, 0
  br i1 %cmp, label %land.lhs.true, label %if.end5

land.lhs.true:                                    ; preds = %if.end
  store i64 1, ptr %.atomictmp, align 8
  %1 = load i64, ptr %.atomictmp, align 8
  %2 = atomicrmw add ptr @error_count, i64 %1 acq_rel, align 8
  store i64 %2, ptr %atomic-temp, align 8
  %3 = load i64, ptr %atomic-temp, align 8
  %4 = load i64, ptr @mi_max_error_count, align 8
  %cmp3 = icmp sgt i64 %3, %4
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %land.lhs.true
  br label %return

if.end5:                                          ; preds = %land.lhs.true, %if.end
  br label %if.end6

if.end6:                                          ; preds = %if.end5, %entry
  %5 = load ptr, ptr %fmt.addr, align 8
  %6 = load ptr, ptr %args.addr, align 8
  call void @mi_vfprintf_thread(ptr noundef null, ptr noundef null, ptr noundef @.str.83, ptr noundef %5, ptr noundef %6)
  br label %return

return:                                           ; preds = %if.end6, %if.then4, %if.then2
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_error_default(i32 noundef %err) #0 {
entry:
  %err.addr = alloca i32, align 4
  store i32 %err, ptr %err.addr, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define hidden signext i8 @_mi_toupper(i8 noundef signext %c) #0 {
entry:
  %retval = alloca i8, align 1
  %c.addr = alloca i8, align 1
  store i8 %c, ptr %c.addr, align 1
  %0 = load i8, ptr %c.addr, align 1
  %conv = sext i8 %0 to i32
  %cmp = icmp sge i32 %conv, 97
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %1 = load i8, ptr %c.addr, align 1
  %conv2 = sext i8 %1 to i32
  %cmp3 = icmp sle i32 %conv2, 122
  br i1 %cmp3, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %2 = load i8, ptr %c.addr, align 1
  %conv5 = sext i8 %2 to i32
  %sub = sub i32 %conv5, 97
  %add = add i32 %sub, 65
  %conv6 = trunc i32 %add to i8
  store i8 %conv6, ptr %retval, align 1
  br label %return

if.else:                                          ; preds = %land.lhs.true, %entry
  %3 = load i8, ptr %c.addr, align 1
  store i8 %3, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.else, %if.then
  %4 = load i8, ptr %retval, align 1
  ret i8 %4
}

; Function Attrs: nounwind uwtable
define hidden i32 @_mi_strnicmp(ptr noundef %s, ptr noundef %t, i64 noundef %n) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %t.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %t, ptr %t.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %1 = load ptr, ptr %s.addr, align 8
  %2 = load i8, ptr %1, align 1
  %conv = sext i8 %2 to i32
  %cmp1 = icmp ne i32 %conv, 0
  br i1 %cmp1, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %for.cond
  %3 = load ptr, ptr %t.addr, align 8
  %4 = load i8, ptr %3, align 1
  %conv3 = sext i8 %4 to i32
  %cmp4 = icmp ne i32 %conv3, 0
  br i1 %cmp4, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %5 = load i64, ptr %n.addr, align 8
  %cmp6 = icmp ugt i64 %5, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %for.cond
  %6 = phi i1 [ false, %land.lhs.true ], [ false, %for.cond ], [ %cmp6, %land.rhs ]
  br i1 %6, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %7 = load ptr, ptr %s.addr, align 8
  %8 = load i8, ptr %7, align 1
  %call = call signext i8 @_mi_toupper(i8 noundef signext %8)
  %conv8 = sext i8 %call to i32
  %9 = load ptr, ptr %t.addr, align 8
  %10 = load i8, ptr %9, align 1
  %call9 = call signext i8 @_mi_toupper(i8 noundef signext %10)
  %conv10 = sext i8 %call9 to i32
  %cmp11 = icmp ne i32 %conv8, %conv10
  br i1 %cmp11, label %if.then13, label %if.end14

if.then13:                                        ; preds = %for.body
  br label %for.end

if.end14:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end14
  %11 = load ptr, ptr %s.addr, align 8
  %incdec.ptr = getelementptr i8, ptr %11, i32 1
  store ptr %incdec.ptr, ptr %s.addr, align 8
  %12 = load ptr, ptr %t.addr, align 8
  %incdec.ptr15 = getelementptr i8, ptr %12, i32 1
  store ptr %incdec.ptr15, ptr %t.addr, align 8
  %13 = load i64, ptr %n.addr, align 8
  %dec = add i64 %13, -1
  store i64 %dec, ptr %n.addr, align 8
  br label %for.cond, !llvm.loop !48

for.end:                                          ; preds = %if.then13, %land.end
  %14 = load i64, ptr %n.addr, align 8
  %cmp16 = icmp eq i64 %14, 0
  br i1 %cmp16, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.end
  br label %cond.end

cond.false:                                       ; preds = %for.end
  %15 = load ptr, ptr %s.addr, align 8
  %16 = load i8, ptr %15, align 1
  %conv18 = sext i8 %16 to i32
  %17 = load ptr, ptr %t.addr, align 8
  %18 = load i8, ptr %17, align 1
  %conv19 = sext i8 %18 to i32
  %sub = sub i32 %conv18, %conv19
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 0, %cond.true ], [ %sub, %cond.false ]
  store i32 %cond, ptr %retval, align 4
  br label %return

return:                                           ; preds = %cond.end, %if.then
  %19 = load i32, ptr %retval, align 4
  ret i32 %19
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_strlcpy(ptr noundef %dest, ptr noundef %src, i64 noundef %dest_size) #0 {
entry:
  %dest.addr = alloca ptr, align 8
  %src.addr = alloca ptr, align 8
  %dest_size.addr = alloca i64, align 8
  store ptr %dest, ptr %dest.addr, align 8
  store ptr %src, ptr %src.addr, align 8
  store i64 %dest_size, ptr %dest_size.addr, align 8
  %0 = load ptr, ptr %dest.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %src.addr, align 8
  %cmp1 = icmp eq ptr %1, null
  br i1 %cmp1, label %if.then, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %2 = load i64, ptr %dest_size.addr, align 8
  %cmp3 = icmp eq i64 %2, 0
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false2, %lor.lhs.false, %entry
  br label %return

if.end:                                           ; preds = %lor.lhs.false2
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end
  %3 = load ptr, ptr %src.addr, align 8
  %4 = load i8, ptr %3, align 1
  %conv = sext i8 %4 to i32
  %cmp4 = icmp ne i32 %conv, 0
  br i1 %cmp4, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %5 = load i64, ptr %dest_size.addr, align 8
  %cmp6 = icmp ugt i64 %5, 1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %6 = phi i1 [ false, %while.cond ], [ %cmp6, %land.rhs ]
  br i1 %6, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %7 = load ptr, ptr %src.addr, align 8
  %incdec.ptr = getelementptr i8, ptr %7, i32 1
  store ptr %incdec.ptr, ptr %src.addr, align 8
  %8 = load i8, ptr %7, align 1
  %9 = load ptr, ptr %dest.addr, align 8
  %incdec.ptr8 = getelementptr i8, ptr %9, i32 1
  store ptr %incdec.ptr8, ptr %dest.addr, align 8
  store i8 %8, ptr %9, align 1
  %10 = load i64, ptr %dest_size.addr, align 8
  %dec = add i64 %10, -1
  store i64 %dec, ptr %dest_size.addr, align 8
  br label %while.cond, !llvm.loop !49

while.end:                                        ; preds = %land.end
  %11 = load ptr, ptr %dest.addr, align 8
  store i8 0, ptr %11, align 1
  br label %return

return:                                           ; preds = %while.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_strlcat(ptr noundef %dest, ptr noundef %src, i64 noundef %dest_size) #0 {
entry:
  %dest.addr = alloca ptr, align 8
  %src.addr = alloca ptr, align 8
  %dest_size.addr = alloca i64, align 8
  store ptr %dest, ptr %dest.addr, align 8
  store ptr %src, ptr %src.addr, align 8
  store i64 %dest_size, ptr %dest_size.addr, align 8
  %0 = load ptr, ptr %dest.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %src.addr, align 8
  %cmp1 = icmp eq ptr %1, null
  br i1 %cmp1, label %if.then, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %2 = load i64, ptr %dest_size.addr, align 8
  %cmp3 = icmp eq i64 %2, 0
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false2, %lor.lhs.false, %entry
  br label %return

if.end:                                           ; preds = %lor.lhs.false2
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end
  %3 = load ptr, ptr %dest.addr, align 8
  %4 = load i8, ptr %3, align 1
  %conv = sext i8 %4 to i32
  %cmp4 = icmp ne i32 %conv, 0
  br i1 %cmp4, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %5 = load i64, ptr %dest_size.addr, align 8
  %cmp6 = icmp ugt i64 %5, 1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %6 = phi i1 [ false, %while.cond ], [ %cmp6, %land.rhs ]
  br i1 %6, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %7 = load ptr, ptr %dest.addr, align 8
  %incdec.ptr = getelementptr i8, ptr %7, i32 1
  store ptr %incdec.ptr, ptr %dest.addr, align 8
  %8 = load i64, ptr %dest_size.addr, align 8
  %dec = add i64 %8, -1
  store i64 %dec, ptr %dest_size.addr, align 8
  br label %while.cond, !llvm.loop !50

while.end:                                        ; preds = %land.end
  %9 = load ptr, ptr %dest.addr, align 8
  %10 = load ptr, ptr %src.addr, align 8
  %11 = load i64, ptr %dest_size.addr, align 8
  call void @_mi_strlcpy(ptr noundef %9, ptr noundef %10, i64 noundef %11)
  br label %return

return:                                           ; preds = %while.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define hidden i64 @_mi_strnlen(ptr noundef %s, i64 noundef %max_len) #0 {
entry:
  %retval = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  %max_len.addr = alloca i64, align 8
  %len = alloca i64, align 8
  store ptr %s, ptr %s.addr, align 8
  store i64 %max_len, ptr %max_len.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 0, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store i64 0, ptr %len, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end
  %1 = load ptr, ptr %s.addr, align 8
  %2 = load i64, ptr %len, align 8
  %arrayidx = getelementptr i8, ptr %1, i64 %2
  %3 = load i8, ptr %arrayidx, align 1
  %conv = sext i8 %3 to i32
  %cmp1 = icmp ne i32 %conv, 0
  br i1 %cmp1, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %4 = load i64, ptr %len, align 8
  %5 = load i64, ptr %max_len.addr, align 8
  %cmp3 = icmp ult i64 %4, %5
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %6 = phi i1 [ false, %while.cond ], [ %cmp3, %land.rhs ]
  br i1 %6, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %7 = load i64, ptr %len, align 8
  %inc = add i64 %7, 1
  store i64 %inc, ptr %len, align 8
  br label %while.cond, !llvm.loop !51

while.end:                                        ; preds = %land.end
  %8 = load i64, ptr %len, align 8
  store i64 %8, ptr %retval, align 8
  br label %return

return:                                           ; preds = %while.end, %if.then
  %9 = load i64, ptr %retval, align 8
  ret i64 %9
}

; Function Attrs: nounwind uwtable
define hidden zeroext i1 @_mi_os_has_overcommit() #0 {
entry:
  %0 = load i8, ptr getelementptr inbounds (%struct.mi_os_mem_config_s, ptr @mi_os_mem_config, i32 0, i32 3), align 8
  %tobool = trunc i8 %0 to i1
  ret i1 %tobool
}

; Function Attrs: nounwind uwtable
define hidden zeroext i1 @_mi_os_has_virtual_reserve() #0 {
entry:
  %0 = load i8, ptr getelementptr inbounds (%struct.mi_os_mem_config_s, ptr @mi_os_mem_config, i32 0, i32 5), align 2
  %tobool = trunc i8 %0 to i1
  ret i1 %tobool
}

; Function Attrs: nounwind uwtable
define hidden i64 @_mi_os_large_page_size() #0 {
entry:
  %0 = load i64, ptr getelementptr inbounds (%struct.mi_os_mem_config_s, ptr @mi_os_mem_config, i32 0, i32 1), align 8
  %cmp = icmp ne i64 %0, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load i64, ptr getelementptr inbounds (%struct.mi_os_mem_config_s, ptr @mi_os_mem_config, i32 0, i32 1), align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = call i64 @_mi_os_page_size()
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %1, %cond.true ], [ %call, %cond.false ]
  ret i64 %cond
}

; Function Attrs: nounwind uwtable
define hidden zeroext i1 @_mi_os_use_large_page(i64 noundef %size, i64 noundef %alignment) #0 {
entry:
  %retval = alloca i1, align 1
  %size.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  store i64 %size, ptr %size.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  %0 = load i64, ptr getelementptr inbounds (%struct.mi_os_mem_config_s, ptr @mi_os_mem_config, i32 0, i32 1), align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %call = call zeroext i1 @mi_option_is_enabled(i32 noundef 6)
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %1 = load i64, ptr %size.addr, align 8
  %2 = load i64, ptr getelementptr inbounds (%struct.mi_os_mem_config_s, ptr @mi_os_mem_config, i32 0, i32 1), align 8
  %rem = urem i64 %1, %2
  %cmp1 = icmp eq i64 %rem, 0
  br i1 %cmp1, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end
  %3 = load i64, ptr %alignment.addr, align 8
  %4 = load i64, ptr getelementptr inbounds (%struct.mi_os_mem_config_s, ptr @mi_os_mem_config, i32 0, i32 1), align 8
  %rem2 = urem i64 %3, %4
  %cmp3 = icmp eq i64 %rem2, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end
  %5 = phi i1 [ false, %if.end ], [ %cmp3, %land.rhs ]
  store i1 %5, ptr %retval, align 1
  br label %return

return:                                           ; preds = %land.end, %if.then
  %6 = load i1, ptr %retval, align 1
  ret i1 %6
}

; Function Attrs: nounwind uwtable
define hidden i64 @_mi_os_good_alloc_size(i64 noundef %size) #0 {
entry:
  %retval = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %align_size = alloca i64, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load i64, ptr %size.addr, align 8
  %cmp = icmp ult i64 %0, 524288
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call = call i64 @_mi_os_page_size()
  store i64 %call, ptr %align_size, align 8
  br label %if.end12

if.else:                                          ; preds = %entry
  %1 = load i64, ptr %size.addr, align 8
  %cmp1 = icmp ult i64 %1, 2097152
  br i1 %cmp1, label %if.then2, label %if.else3

if.then2:                                         ; preds = %if.else
  store i64 65536, ptr %align_size, align 8
  br label %if.end11

if.else3:                                         ; preds = %if.else
  %2 = load i64, ptr %size.addr, align 8
  %cmp4 = icmp ult i64 %2, 8388608
  br i1 %cmp4, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.else3
  store i64 262144, ptr %align_size, align 8
  br label %if.end10

if.else6:                                         ; preds = %if.else3
  %3 = load i64, ptr %size.addr, align 8
  %cmp7 = icmp ult i64 %3, 33554432
  br i1 %cmp7, label %if.then8, label %if.else9

if.then8:                                         ; preds = %if.else6
  store i64 1048576, ptr %align_size, align 8
  br label %if.end

if.else9:                                         ; preds = %if.else6
  store i64 4194304, ptr %align_size, align 8
  br label %if.end

if.end:                                           ; preds = %if.else9, %if.then8
  br label %if.end10

if.end10:                                         ; preds = %if.end, %if.then5
  br label %if.end11

if.end11:                                         ; preds = %if.end10, %if.then2
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %if.then
  %4 = load i64, ptr %size.addr, align 8
  %5 = load i64, ptr %align_size, align 8
  %sub = sub i64 -1, %5
  %cmp13 = icmp uge i64 %4, %sub
  %lnot = xor i1 %cmp13, true
  %lnot14 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot14 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.end12
  %6 = load i64, ptr %size.addr, align 8
  store i64 %6, ptr %retval, align 8
  br label %return

if.end16:                                         ; preds = %if.end12
  %7 = load i64, ptr %size.addr, align 8
  %8 = load i64, ptr %align_size, align 8
  %call17 = call i64 @_mi_align_up(i64 noundef %7, i64 noundef %8)
  store i64 %call17, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end16, %if.then15
  %9 = load i64, ptr %retval, align 8
  ret i64 %9
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_prim_mem_init(ptr noundef %config) #0 {
entry:
  %config.addr = alloca ptr, align 8
  %psize = alloca i64, align 8
  store ptr %config, ptr %config.addr, align 8
  %call = call i64 @sysconf(i32 noundef 30) #15
  store i64 %call, ptr %psize, align 8
  %0 = load i64, ptr %psize, align 8
  %cmp = icmp sgt i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i64, ptr %psize, align 8
  %2 = load ptr, ptr %config.addr, align 8
  %page_size = getelementptr inbounds %struct.mi_os_mem_config_s, ptr %2, i32 0, i32 0
  store i64 %1, ptr %page_size, align 8
  %3 = load i64, ptr %psize, align 8
  %4 = load ptr, ptr %config.addr, align 8
  %alloc_granularity = getelementptr inbounds %struct.mi_os_mem_config_s, ptr %4, i32 0, i32 2
  store i64 %3, ptr %alloc_granularity, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load ptr, ptr %config.addr, align 8
  %large_page_size = getelementptr inbounds %struct.mi_os_mem_config_s, ptr %5, i32 0, i32 1
  store i64 2097152, ptr %large_page_size, align 8
  %call1 = call zeroext i1 @unix_detect_overcommit()
  %6 = load ptr, ptr %config.addr, align 8
  %has_overcommit = getelementptr inbounds %struct.mi_os_mem_config_s, ptr %6, i32 0, i32 3
  %frombool = zext i1 %call1 to i8
  store i8 %frombool, ptr %has_overcommit, align 8
  %7 = load ptr, ptr %config.addr, align 8
  %must_free_whole = getelementptr inbounds %struct.mi_os_mem_config_s, ptr %7, i32 0, i32 4
  store i8 0, ptr %must_free_whole, align 1
  %8 = load ptr, ptr %config.addr, align 8
  %has_virtual_reserve = getelementptr inbounds %struct.mi_os_mem_config_s, ptr %8, i32 0, i32 5
  store i8 1, ptr %has_virtual_reserve, align 2
  ret void
}

; Function Attrs: nounwind uwtable
define hidden ptr @_mi_os_get_aligned_hint(i64 noundef %try_alignment, i64 noundef %size) #0 {
entry:
  %retval = alloca ptr, align 8
  %try_alignment.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %hint = alloca i64, align 8
  %.atomictmp = alloca i64, align 8
  %atomic-temp = alloca i64, align 8
  %init = alloca i64, align 8
  %r = alloca i64, align 8
  %expected = alloca i64, align 8
  %.atomictmp12 = alloca i64, align 8
  %cmpxchg.bool = alloca i8, align 1
  %.atomictmp13 = alloca i64, align 8
  %atomic-temp14 = alloca i64, align 8
  store i64 %try_alignment, ptr %try_alignment.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load i64, ptr %try_alignment.addr, align 8
  %cmp = icmp ule i64 %0, 1
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i64, ptr %try_alignment.addr, align 8
  %cmp1 = icmp ugt i64 %1, 33554432
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %2 = load i64, ptr %size.addr, align 8
  %call = call i64 @_mi_align_up(i64 noundef %2, i64 noundef 33554432)
  store i64 %call, ptr %size.addr, align 8
  %3 = load i64, ptr %size.addr, align 8
  %cmp2 = icmp ugt i64 %3, 1073741824
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  %4 = load i64, ptr %size.addr, align 8
  store i64 %4, ptr %.atomictmp, align 8
  %5 = load i64, ptr %.atomictmp, align 8
  %6 = atomicrmw add ptr @aligned_base, i64 %5 acq_rel, align 64
  store i64 %6, ptr %atomic-temp, align 8
  %7 = load i64, ptr %atomic-temp, align 8
  store i64 %7, ptr %hint, align 8
  %8 = load i64, ptr %hint, align 8
  %cmp5 = icmp eq i64 %8, 0
  br i1 %cmp5, label %if.then8, label %lor.lhs.false6

lor.lhs.false6:                                   ; preds = %if.end4
  %9 = load i64, ptr %hint, align 8
  %cmp7 = icmp ugt i64 %9, 32985348833280
  br i1 %cmp7, label %if.then8, label %if.end15

if.then8:                                         ; preds = %lor.lhs.false6, %if.end4
  store i64 2199023255552, ptr %init, align 8
  %call9 = call ptr @mi_prim_get_default_heap()
  %call10 = call i64 @_mi_heap_random_next(ptr noundef %call9)
  store i64 %call10, ptr %r, align 8
  %10 = load i64, ptr %init, align 8
  %11 = load i64, ptr %r, align 8
  %shr = lshr i64 %11, 17
  %and = and i64 %shr, 1048575
  %mul = mul i64 33554432, %and
  %rem = urem i64 %mul, 4398046511104
  %add = add i64 %10, %rem
  store i64 %add, ptr %init, align 8
  %12 = load i64, ptr %hint, align 8
  %13 = load i64, ptr %size.addr, align 8
  %add11 = add i64 %12, %13
  store i64 %add11, ptr %expected, align 8
  %14 = load i64, ptr %init, align 8
  store i64 %14, ptr %.atomictmp12, align 8
  %15 = load i64, ptr %expected, align 8
  %16 = load i64, ptr %.atomictmp12, align 8
  %17 = cmpxchg ptr @aligned_base, i64 %15, i64 %16 acq_rel acquire, align 64
  %18 = extractvalue { i64, i1 } %17, 0
  %19 = extractvalue { i64, i1 } %17, 1
  br i1 %19, label %cmpxchg.continue, label %cmpxchg.store_expected

cmpxchg.store_expected:                           ; preds = %if.then8
  store i64 %18, ptr %expected, align 8
  br label %cmpxchg.continue

cmpxchg.continue:                                 ; preds = %cmpxchg.store_expected, %if.then8
  %frombool = zext i1 %19 to i8
  store i8 %frombool, ptr %cmpxchg.bool, align 1
  %20 = load i64, ptr %size.addr, align 8
  store i64 %20, ptr %.atomictmp13, align 8
  %21 = load i64, ptr %.atomictmp13, align 8
  %22 = atomicrmw add ptr @aligned_base, i64 %21 acq_rel, align 64
  store i64 %22, ptr %atomic-temp14, align 8
  %23 = load i64, ptr %atomic-temp14, align 8
  store i64 %23, ptr %hint, align 8
  br label %if.end15

if.end15:                                         ; preds = %cmpxchg.continue, %lor.lhs.false6
  %24 = load i64, ptr %hint, align 8
  %25 = load i64, ptr %try_alignment.addr, align 8
  %rem16 = urem i64 %24, %25
  %cmp17 = icmp ne i64 %rem16, 0
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end15
  store ptr null, ptr %retval, align 8
  br label %return

if.end19:                                         ; preds = %if.end15
  %26 = load i64, ptr %hint, align 8
  %27 = inttoptr i64 %26 to ptr
  store ptr %27, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end19, %if.then18, %if.then3, %if.then
  %28 = load ptr, ptr %retval, align 8
  ret ptr %28
}

; Function Attrs: nounwind uwtable
define internal void @mi_os_free_huge_os_pages(ptr noundef %p, i64 noundef %size, ptr noundef %stats) #0 {
entry:
  %p.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %stats.addr = alloca ptr, align 8
  %base = alloca ptr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store ptr %stats, ptr %stats.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i64, ptr %size.addr, align 8
  %cmp1 = icmp eq i64 %1, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %while.end

if.end:                                           ; preds = %lor.lhs.false
  %2 = load ptr, ptr %p.addr, align 8
  store ptr %2, ptr %base, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end
  %3 = load i64, ptr %size.addr, align 8
  %cmp2 = icmp uge i64 %3, 1073741824
  br i1 %cmp2, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %4 = load ptr, ptr %base, align 8
  %5 = load ptr, ptr %stats.addr, align 8
  call void @mi_os_prim_free(ptr noundef %4, i64 noundef 1073741824, i1 noundef zeroext true, ptr noundef %5)
  %6 = load i64, ptr %size.addr, align 8
  %sub = sub i64 %6, 1073741824
  store i64 %sub, ptr %size.addr, align 8
  %7 = load ptr, ptr %base, align 8
  %add.ptr = getelementptr i8, ptr %7, i64 1073741824
  store ptr %add.ptr, ptr %base, align 8
  br label %while.cond, !llvm.loop !52

while.end:                                        ; preds = %while.cond, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_os_prim_free(ptr noundef %addr, i64 noundef %size, i1 noundef zeroext %still_committed, ptr noundef %tld_stats) #0 {
entry:
  %addr.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %still_committed.addr = alloca i8, align 1
  %tld_stats.addr = alloca ptr, align 8
  %err = alloca i32, align 4
  %stats = alloca ptr, align 8
  store ptr %addr, ptr %addr.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %frombool = zext i1 %still_committed to i8
  store i8 %frombool, ptr %still_committed.addr, align 1
  store ptr %tld_stats, ptr %tld_stats.addr, align 8
  %0 = load ptr, ptr %addr.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i64, ptr %size.addr, align 8
  %cmp1 = icmp eq i64 %1, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %2 = load ptr, ptr %addr.addr, align 8
  %3 = load i64, ptr %size.addr, align 8
  %call = call i32 @_mi_prim_free(ptr noundef %2, i64 noundef %3)
  store i32 %call, ptr %err, align 4
  %4 = load i32, ptr %err, align 4
  %cmp2 = icmp ne i32 %4, 0
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %5 = load i32, ptr %err, align 4
  %6 = load i32, ptr %err, align 4
  %7 = load i64, ptr %size.addr, align 8
  %8 = load ptr, ptr %addr.addr, align 8
  call void (ptr, ...) @_mi_warning_message(ptr noundef @.str.89, i32 noundef %5, i32 noundef %6, i64 noundef %7, ptr noundef %8)
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end
  store ptr @_mi_stats_main, ptr %stats, align 8
  %9 = load i8, ptr %still_committed.addr, align 1
  %tobool = trunc i8 %9 to i1
  br i1 %tobool, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end4
  %10 = load ptr, ptr %stats, align 8
  %committed = getelementptr inbounds %struct.mi_stats_s, ptr %10, i32 0, i32 3
  %11 = load i64, ptr %size.addr, align 8
  call void @_mi_stat_decrease(ptr noundef %committed, i64 noundef %11)
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %if.end4
  %12 = load ptr, ptr %stats, align 8
  %reserved = getelementptr inbounds %struct.mi_stats_s, ptr %12, i32 0, i32 2
  %13 = load i64, ptr %size.addr, align 8
  call void @_mi_stat_decrease(ptr noundef %reserved, i64 noundef %13)
  br label %return

return:                                           ; preds = %if.end6, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define hidden ptr @_mi_os_alloc(i64 noundef %size, ptr noundef %memid, ptr noundef %tld_stats) #0 {
entry:
  %retval = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %memid.addr = alloca ptr, align 8
  %tld_stats.addr = alloca ptr, align 8
  %tmp = alloca %struct.mi_memid_s, align 8
  %stats = alloca ptr, align 8
  %os_is_large = alloca i8, align 1
  %os_is_zero = alloca i8, align 1
  %p = alloca ptr, align 8
  %tmp4 = alloca %struct.mi_memid_s, align 8
  store i64 %size, ptr %size.addr, align 8
  store ptr %memid, ptr %memid.addr, align 8
  store ptr %tld_stats, ptr %tld_stats.addr, align 8
  %0 = load ptr, ptr %memid.addr, align 8
  call void @_mi_memid_none(ptr sret(%struct.mi_memid_s) align 8 %tmp)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %0, ptr align 8 %tmp, i64 24, i1 false)
  store ptr @_mi_stats_main, ptr %stats, align 8
  %1 = load i64, ptr %size.addr, align 8
  %cmp = icmp eq i64 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i64, ptr %size.addr, align 8
  %call = call i64 @_mi_os_good_alloc_size(i64 noundef %2)
  store i64 %call, ptr %size.addr, align 8
  store i8 0, ptr %os_is_large, align 1
  store i8 0, ptr %os_is_zero, align 1
  %3 = load i64, ptr %size.addr, align 8
  %4 = load ptr, ptr %stats, align 8
  %call1 = call ptr @mi_os_prim_alloc(i64 noundef %3, i64 noundef 0, i1 noundef zeroext true, i1 noundef zeroext false, ptr noundef %os_is_large, ptr noundef %os_is_zero, ptr noundef %4)
  store ptr %call1, ptr %p, align 8
  %5 = load ptr, ptr %p, align 8
  %cmp2 = icmp ne ptr %5, null
  br i1 %cmp2, label %if.then3, label %if.end6

if.then3:                                         ; preds = %if.end
  %6 = load ptr, ptr %memid.addr, align 8
  %7 = load i8, ptr %os_is_zero, align 1
  %tobool = trunc i8 %7 to i1
  %8 = load i8, ptr %os_is_large, align 1
  %tobool5 = trunc i8 %8 to i1
  call void @_mi_memid_create_os(ptr sret(%struct.mi_memid_s) align 8 %tmp4, i1 noundef zeroext true, i1 noundef zeroext %tobool, i1 noundef zeroext %tobool5)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %6, ptr align 8 %tmp4, i64 24, i1 false)
  br label %if.end6

if.end6:                                          ; preds = %if.then3, %if.end
  %9 = load ptr, ptr %p, align 8
  store ptr %9, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end6, %if.then
  %10 = load ptr, ptr %retval, align 8
  ret ptr %10
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_os_prim_alloc(i64 noundef %size, i64 noundef %try_alignment, i1 noundef zeroext %commit, i1 noundef zeroext %allow_large, ptr noundef %is_large, ptr noundef %is_zero, ptr noundef %stats) #0 {
entry:
  %retval = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %try_alignment.addr = alloca i64, align 8
  %commit.addr = alloca i8, align 1
  %allow_large.addr = alloca i8, align 1
  %is_large.addr = alloca ptr, align 8
  %is_zero.addr = alloca ptr, align 8
  %stats.addr = alloca ptr, align 8
  %p = alloca ptr, align 8
  %err = alloca i32, align 4
  store i64 %size, ptr %size.addr, align 8
  store i64 %try_alignment, ptr %try_alignment.addr, align 8
  %frombool = zext i1 %commit to i8
  store i8 %frombool, ptr %commit.addr, align 1
  %frombool1 = zext i1 %allow_large to i8
  store i8 %frombool1, ptr %allow_large.addr, align 1
  store ptr %is_large, ptr %is_large.addr, align 8
  store ptr %is_zero, ptr %is_zero.addr, align 8
  store ptr %stats, ptr %stats.addr, align 8
  %0 = load i64, ptr %size.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i8, ptr %commit.addr, align 1
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %if.end3, label %if.then2

if.then2:                                         ; preds = %if.end
  store i8 0, ptr %allow_large.addr, align 1
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end
  %2 = load i64, ptr %try_alignment.addr, align 8
  %cmp4 = icmp eq i64 %2, 0
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end3
  store i64 1, ptr %try_alignment.addr, align 8
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %if.end3
  %3 = load ptr, ptr %is_zero.addr, align 8
  store i8 0, ptr %3, align 1
  store ptr null, ptr %p, align 8
  %4 = load i64, ptr %size.addr, align 8
  %5 = load i64, ptr %try_alignment.addr, align 8
  %6 = load i8, ptr %commit.addr, align 1
  %tobool7 = trunc i8 %6 to i1
  %7 = load i8, ptr %allow_large.addr, align 1
  %tobool8 = trunc i8 %7 to i1
  %8 = load ptr, ptr %is_large.addr, align 8
  %9 = load ptr, ptr %is_zero.addr, align 8
  %call = call i32 @_mi_prim_alloc(i64 noundef %4, i64 noundef %5, i1 noundef zeroext %tobool7, i1 noundef zeroext %tobool8, ptr noundef %8, ptr noundef %9, ptr noundef %p)
  store i32 %call, ptr %err, align 4
  %10 = load i32, ptr %err, align 4
  %cmp9 = icmp ne i32 %10, 0
  br i1 %cmp9, label %if.then10, label %if.end14

if.then10:                                        ; preds = %if.end6
  %11 = load i32, ptr %err, align 4
  %12 = load i32, ptr %err, align 4
  %13 = load i64, ptr %size.addr, align 8
  %14 = load i64, ptr %try_alignment.addr, align 8
  %15 = load i8, ptr %commit.addr, align 1
  %tobool11 = trunc i8 %15 to i1
  %conv = zext i1 %tobool11 to i32
  %16 = load i8, ptr %allow_large.addr, align 1
  %tobool12 = trunc i8 %16 to i1
  %conv13 = zext i1 %tobool12 to i32
  call void (ptr, ...) @_mi_warning_message(ptr noundef @.str.90, i32 noundef %11, i32 noundef %12, i64 noundef %13, i64 noundef %14, i32 noundef %conv, i32 noundef %conv13)
  br label %if.end14

if.end14:                                         ; preds = %if.then10, %if.end6
  %17 = load ptr, ptr %p, align 8
  %cmp15 = icmp ne ptr %17, null
  br i1 %cmp15, label %if.then17, label %if.end21

if.then17:                                        ; preds = %if.end14
  %18 = load ptr, ptr %stats.addr, align 8
  %reserved = getelementptr inbounds %struct.mi_stats_s, ptr %18, i32 0, i32 2
  %19 = load i64, ptr %size.addr, align 8
  call void @_mi_stat_increase(ptr noundef %reserved, i64 noundef %19)
  %20 = load i8, ptr %commit.addr, align 1
  %tobool18 = trunc i8 %20 to i1
  br i1 %tobool18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %if.then17
  %21 = load ptr, ptr %stats.addr, align 8
  %committed = getelementptr inbounds %struct.mi_stats_s, ptr %21, i32 0, i32 3
  %22 = load i64, ptr %size.addr, align 8
  call void @_mi_stat_increase(ptr noundef %committed, i64 noundef %22)
  br label %if.end20

if.end20:                                         ; preds = %if.then19, %if.then17
  br label %if.end21

if.end21:                                         ; preds = %if.end20, %if.end14
  %23 = load ptr, ptr %p, align 8
  store ptr %23, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end21, %if.then
  %24 = load ptr, ptr %retval, align 8
  ret ptr %24
}

; Function Attrs: nounwind uwtable
define internal void @_mi_memid_create_os(ptr noalias sret(%struct.mi_memid_s) align 8 %agg.result, i1 noundef zeroext %committed, i1 noundef zeroext %is_zero, i1 noundef zeroext %is_large) #0 {
entry:
  %committed.addr = alloca i8, align 1
  %is_zero.addr = alloca i8, align 1
  %is_large.addr = alloca i8, align 1
  %frombool = zext i1 %committed to i8
  store i8 %frombool, ptr %committed.addr, align 1
  %frombool1 = zext i1 %is_zero to i8
  store i8 %frombool1, ptr %is_zero.addr, align 1
  %frombool2 = zext i1 %is_large to i8
  store i8 %frombool2, ptr %is_large.addr, align 1
  call void @_mi_memid_create(ptr sret(%struct.mi_memid_s) align 8 %agg.result, i32 noundef 3)
  %0 = load i8, ptr %committed.addr, align 1
  %tobool = trunc i8 %0 to i1
  %initially_committed = getelementptr inbounds %struct.mi_memid_s, ptr %agg.result, i32 0, i32 2
  %frombool3 = zext i1 %tobool to i8
  store i8 %frombool3, ptr %initially_committed, align 1
  %1 = load i8, ptr %is_zero.addr, align 1
  %tobool4 = trunc i8 %1 to i1
  %initially_zero = getelementptr inbounds %struct.mi_memid_s, ptr %agg.result, i32 0, i32 3
  %frombool5 = zext i1 %tobool4 to i8
  store i8 %frombool5, ptr %initially_zero, align 2
  %2 = load i8, ptr %is_large.addr, align 1
  %tobool6 = trunc i8 %2 to i1
  %is_pinned = getelementptr inbounds %struct.mi_memid_s, ptr %agg.result, i32 0, i32 1
  %frombool7 = zext i1 %tobool6 to i8
  store i8 %frombool7, ptr %is_pinned, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_os_prim_alloc_aligned(i64 noundef %size, i64 noundef %alignment, i1 noundef zeroext %commit, i1 noundef zeroext %allow_large, ptr noundef %is_large, ptr noundef %is_zero, ptr noundef %base, ptr noundef %stats) #0 {
entry:
  %retval = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  %commit.addr = alloca i8, align 1
  %allow_large.addr = alloca i8, align 1
  %is_large.addr = alloca ptr, align 8
  %is_zero.addr = alloca ptr, align 8
  %base.addr = alloca ptr, align 8
  %stats.addr = alloca ptr, align 8
  %p = alloca ptr, align 8
  %over_size = alloca i64, align 8
  %aligned_p = alloca ptr, align 8
  %pre_size = alloca i64, align 8
  %mid_size = alloca i64, align 8
  %post_size = alloca i64, align 8
  store i64 %size, ptr %size.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  %frombool = zext i1 %commit to i8
  store i8 %frombool, ptr %commit.addr, align 1
  %frombool1 = zext i1 %allow_large to i8
  store i8 %frombool1, ptr %allow_large.addr, align 1
  store ptr %is_large, ptr %is_large.addr, align 8
  store ptr %is_zero, ptr %is_zero.addr, align 8
  store ptr %base, ptr %base.addr, align 8
  store ptr %stats, ptr %stats.addr, align 8
  %0 = load i8, ptr %commit.addr, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i8 0, ptr %allow_large.addr, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = load i64, ptr %alignment.addr, align 8
  %call = call i64 @_mi_os_page_size()
  %cmp = icmp uge i64 %1, %call
  br i1 %cmp, label %land.lhs.true, label %if.then3

land.lhs.true:                                    ; preds = %if.end
  %2 = load i64, ptr %alignment.addr, align 8
  %3 = load i64, ptr %alignment.addr, align 8
  %sub = sub i64 %3, 1
  %and = and i64 %2, %sub
  %cmp2 = icmp eq i64 %and, 0
  br i1 %cmp2, label %if.end4, label %if.then3

if.then3:                                         ; preds = %land.lhs.true, %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %land.lhs.true
  %4 = load i64, ptr %size.addr, align 8
  %call5 = call i64 @_mi_os_page_size()
  %call6 = call i64 @_mi_align_up(i64 noundef %4, i64 noundef %call5)
  store i64 %call6, ptr %size.addr, align 8
  %5 = load i64, ptr %size.addr, align 8
  %6 = load i64, ptr %alignment.addr, align 8
  %7 = load i8, ptr %commit.addr, align 1
  %tobool7 = trunc i8 %7 to i1
  %8 = load i8, ptr %allow_large.addr, align 1
  %tobool8 = trunc i8 %8 to i1
  %9 = load ptr, ptr %is_large.addr, align 8
  %10 = load ptr, ptr %is_zero.addr, align 8
  %11 = load ptr, ptr %stats.addr, align 8
  %call9 = call ptr @mi_os_prim_alloc(i64 noundef %5, i64 noundef %6, i1 noundef zeroext %tobool7, i1 noundef zeroext %tobool8, ptr noundef %9, ptr noundef %10, ptr noundef %11)
  store ptr %call9, ptr %p, align 8
  %12 = load ptr, ptr %p, align 8
  %cmp10 = icmp eq ptr %12, null
  br i1 %cmp10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end4
  store ptr null, ptr %retval, align 8
  br label %return

if.end12:                                         ; preds = %if.end4
  %13 = load ptr, ptr %p, align 8
  %14 = ptrtoint ptr %13 to i64
  %15 = load i64, ptr %alignment.addr, align 8
  %rem = urem i64 %14, %15
  %cmp13 = icmp eq i64 %rem, 0
  br i1 %cmp13, label %if.then14, label %if.else

if.then14:                                        ; preds = %if.end12
  %16 = load ptr, ptr %p, align 8
  %17 = load ptr, ptr %base.addr, align 8
  store ptr %16, ptr %17, align 8
  br label %if.end51

if.else:                                          ; preds = %if.end12
  %18 = load ptr, ptr %p, align 8
  %19 = load i64, ptr %size.addr, align 8
  %20 = load i8, ptr %commit.addr, align 1
  %tobool15 = trunc i8 %20 to i1
  %21 = load ptr, ptr %stats.addr, align 8
  call void @mi_os_prim_free(ptr noundef %18, i64 noundef %19, i1 noundef zeroext %tobool15, ptr noundef %21)
  %22 = load i64, ptr %size.addr, align 8
  %23 = load i64, ptr %alignment.addr, align 8
  %sub16 = sub i64 -1, %23
  %cmp17 = icmp uge i64 %22, %sub16
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.else
  store ptr null, ptr %retval, align 8
  br label %return

if.end19:                                         ; preds = %if.else
  %24 = load i64, ptr %size.addr, align 8
  %25 = load i64, ptr %alignment.addr, align 8
  %add = add i64 %24, %25
  store i64 %add, ptr %over_size, align 8
  %26 = load i8, ptr getelementptr inbounds (%struct.mi_os_mem_config_s, ptr @mi_os_mem_config, i32 0, i32 4), align 1
  %tobool20 = trunc i8 %26 to i1
  br i1 %tobool20, label %if.then21, label %if.else31

if.then21:                                        ; preds = %if.end19
  %27 = load i64, ptr %over_size, align 8
  %28 = load ptr, ptr %is_large.addr, align 8
  %29 = load ptr, ptr %is_zero.addr, align 8
  %30 = load ptr, ptr %stats.addr, align 8
  %call22 = call ptr @mi_os_prim_alloc(i64 noundef %27, i64 noundef 1, i1 noundef zeroext false, i1 noundef zeroext false, ptr noundef %28, ptr noundef %29, ptr noundef %30)
  store ptr %call22, ptr %p, align 8
  %31 = load ptr, ptr %p, align 8
  %cmp23 = icmp eq ptr %31, null
  br i1 %cmp23, label %if.then24, label %if.end25

if.then24:                                        ; preds = %if.then21
  store ptr null, ptr %retval, align 8
  br label %return

if.end25:                                         ; preds = %if.then21
  %32 = load ptr, ptr %p, align 8
  %33 = load ptr, ptr %base.addr, align 8
  store ptr %32, ptr %33, align 8
  %34 = load ptr, ptr %p, align 8
  %35 = load i64, ptr %alignment.addr, align 8
  %call26 = call ptr @mi_align_up_ptr(ptr noundef %34, i64 noundef %35)
  store ptr %call26, ptr %p, align 8
  %36 = load i8, ptr %commit.addr, align 1
  %tobool27 = trunc i8 %36 to i1
  br i1 %tobool27, label %if.then28, label %if.end30

if.then28:                                        ; preds = %if.end25
  %37 = load ptr, ptr %p, align 8
  %38 = load i64, ptr %size.addr, align 8
  %39 = load ptr, ptr %stats.addr, align 8
  %call29 = call zeroext i1 @_mi_os_commit(ptr noundef %37, i64 noundef %38, ptr noundef null, ptr noundef %39)
  br label %if.end30

if.end30:                                         ; preds = %if.then28, %if.end25
  br label %if.end50

if.else31:                                        ; preds = %if.end19
  %40 = load i64, ptr %over_size, align 8
  %41 = load i8, ptr %commit.addr, align 1
  %tobool32 = trunc i8 %41 to i1
  %42 = load ptr, ptr %is_large.addr, align 8
  %43 = load ptr, ptr %is_zero.addr, align 8
  %44 = load ptr, ptr %stats.addr, align 8
  %call33 = call ptr @mi_os_prim_alloc(i64 noundef %40, i64 noundef 1, i1 noundef zeroext %tobool32, i1 noundef zeroext false, ptr noundef %42, ptr noundef %43, ptr noundef %44)
  store ptr %call33, ptr %p, align 8
  %45 = load ptr, ptr %p, align 8
  %cmp34 = icmp eq ptr %45, null
  br i1 %cmp34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %if.else31
  store ptr null, ptr %retval, align 8
  br label %return

if.end36:                                         ; preds = %if.else31
  %46 = load ptr, ptr %p, align 8
  %47 = load i64, ptr %alignment.addr, align 8
  %call37 = call ptr @mi_align_up_ptr(ptr noundef %46, i64 noundef %47)
  store ptr %call37, ptr %aligned_p, align 8
  %48 = load ptr, ptr %aligned_p, align 8
  %49 = load ptr, ptr %p, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %48 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %49 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, ptr %pre_size, align 8
  %50 = load i64, ptr %size.addr, align 8
  %call38 = call i64 @_mi_os_page_size()
  %call39 = call i64 @_mi_align_up(i64 noundef %50, i64 noundef %call38)
  store i64 %call39, ptr %mid_size, align 8
  %51 = load i64, ptr %over_size, align 8
  %52 = load i64, ptr %pre_size, align 8
  %sub40 = sub i64 %51, %52
  %53 = load i64, ptr %mid_size, align 8
  %sub41 = sub i64 %sub40, %53
  store i64 %sub41, ptr %post_size, align 8
  %54 = load i64, ptr %pre_size, align 8
  %cmp42 = icmp ugt i64 %54, 0
  br i1 %cmp42, label %if.then43, label %if.end45

if.then43:                                        ; preds = %if.end36
  %55 = load ptr, ptr %p, align 8
  %56 = load i64, ptr %pre_size, align 8
  %57 = load i8, ptr %commit.addr, align 1
  %tobool44 = trunc i8 %57 to i1
  %58 = load ptr, ptr %stats.addr, align 8
  call void @mi_os_prim_free(ptr noundef %55, i64 noundef %56, i1 noundef zeroext %tobool44, ptr noundef %58)
  br label %if.end45

if.end45:                                         ; preds = %if.then43, %if.end36
  %59 = load i64, ptr %post_size, align 8
  %cmp46 = icmp ugt i64 %59, 0
  br i1 %cmp46, label %if.then47, label %if.end49

if.then47:                                        ; preds = %if.end45
  %60 = load ptr, ptr %aligned_p, align 8
  %61 = load i64, ptr %mid_size, align 8
  %add.ptr = getelementptr i8, ptr %60, i64 %61
  %62 = load i64, ptr %post_size, align 8
  %63 = load i8, ptr %commit.addr, align 1
  %tobool48 = trunc i8 %63 to i1
  %64 = load ptr, ptr %stats.addr, align 8
  call void @mi_os_prim_free(ptr noundef %add.ptr, i64 noundef %62, i1 noundef zeroext %tobool48, ptr noundef %64)
  br label %if.end49

if.end49:                                         ; preds = %if.then47, %if.end45
  %65 = load ptr, ptr %aligned_p, align 8
  store ptr %65, ptr %p, align 8
  %66 = load ptr, ptr %aligned_p, align 8
  %67 = load ptr, ptr %base.addr, align 8
  store ptr %66, ptr %67, align 8
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.end30
  br label %if.end51

if.end51:                                         ; preds = %if.end50, %if.then14
  %68 = load ptr, ptr %p, align 8
  store ptr %68, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end51, %if.then35, %if.then24, %if.then18, %if.then11, %if.then3
  %69 = load ptr, ptr %retval, align 8
  ret ptr %69
}

; Function Attrs: nounwind uwtable
define hidden zeroext i1 @_mi_os_decommit(ptr noundef %addr, i64 noundef %size, ptr noundef %tld_stats) #0 {
entry:
  %addr.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %tld_stats.addr = alloca ptr, align 8
  %needs_recommit = alloca i8, align 1
  store ptr %addr, ptr %addr.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store ptr %tld_stats, ptr %tld_stats.addr, align 8
  %0 = load ptr, ptr %addr.addr, align 8
  %1 = load i64, ptr %size.addr, align 8
  %2 = load ptr, ptr %tld_stats.addr, align 8
  %call = call zeroext i1 @mi_os_decommit_ex(ptr noundef %0, i64 noundef %1, ptr noundef %needs_recommit, ptr noundef %2)
  ret i1 %call
}

; Function Attrs: nounwind uwtable
define hidden zeroext i1 @_mi_os_commit(ptr noundef %addr, i64 noundef %size, ptr noundef %is_zero, ptr noundef %tld_stats) #0 {
entry:
  %retval = alloca i1, align 1
  %addr.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %is_zero.addr = alloca ptr, align 8
  %tld_stats.addr = alloca ptr, align 8
  %stats = alloca ptr, align 8
  %csize = alloca i64, align 8
  %start = alloca ptr, align 8
  %os_is_zero = alloca i8, align 1
  %err = alloca i32, align 4
  store ptr %addr, ptr %addr.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store ptr %is_zero, ptr %is_zero.addr, align 8
  store ptr %tld_stats, ptr %tld_stats.addr, align 8
  store ptr @_mi_stats_main, ptr %stats, align 8
  %0 = load ptr, ptr %is_zero.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %is_zero.addr, align 8
  store i8 0, ptr %1, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load ptr, ptr %stats, align 8
  %committed = getelementptr inbounds %struct.mi_stats_s, ptr %2, i32 0, i32 3
  %3 = load i64, ptr %size.addr, align 8
  call void @_mi_stat_increase(ptr noundef %committed, i64 noundef %3)
  %4 = load ptr, ptr %stats, align 8
  %commit_calls = getelementptr inbounds %struct.mi_stats_s, ptr %4, i32 0, i32 17
  call void @_mi_stat_counter_increase(ptr noundef %commit_calls, i64 noundef 1)
  %5 = load ptr, ptr %addr.addr, align 8
  %6 = load i64, ptr %size.addr, align 8
  %call = call ptr @mi_os_page_align_areax(i1 noundef zeroext false, ptr noundef %5, i64 noundef %6, ptr noundef %csize)
  store ptr %call, ptr %start, align 8
  %7 = load i64, ptr %csize, align 8
  %cmp1 = icmp eq i64 %7, 0
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i1 true, ptr %retval, align 1
  br label %return

if.end3:                                          ; preds = %if.end
  store i8 0, ptr %os_is_zero, align 1
  %8 = load ptr, ptr %start, align 8
  %9 = load i64, ptr %csize, align 8
  %call4 = call i32 @_mi_prim_commit(ptr noundef %8, i64 noundef %9, ptr noundef %os_is_zero)
  store i32 %call4, ptr %err, align 4
  %10 = load i32, ptr %err, align 4
  %cmp5 = icmp ne i32 %10, 0
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end3
  %11 = load i32, ptr %err, align 4
  %12 = load i32, ptr %err, align 4
  %13 = load ptr, ptr %start, align 8
  %14 = load i64, ptr %csize, align 8
  call void (ptr, ...) @_mi_warning_message(ptr noundef @.str.24, i32 noundef %11, i32 noundef %12, ptr noundef %13, i64 noundef %14)
  store i1 false, ptr %retval, align 1
  br label %return

if.end7:                                          ; preds = %if.end3
  %15 = load i8, ptr %os_is_zero, align 1
  %tobool = trunc i8 %15 to i1
  br i1 %tobool, label %land.lhs.true, label %if.end10

land.lhs.true:                                    ; preds = %if.end7
  %16 = load ptr, ptr %is_zero.addr, align 8
  %cmp8 = icmp ne ptr %16, null
  br i1 %cmp8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %land.lhs.true
  %17 = load ptr, ptr %is_zero.addr, align 8
  store i8 1, ptr %17, align 1
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %land.lhs.true, %if.end7
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end10, %if.then6, %if.then2
  %18 = load i1, ptr %retval, align 1
  ret i1 %18
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_stat_counter_increase(ptr noundef %stat, i64 noundef %amount) #0 {
entry:
  %stat.addr = alloca ptr, align 8
  %amount.addr = alloca i64, align 8
  store ptr %stat, ptr %stat.addr, align 8
  store i64 %amount, ptr %amount.addr, align 8
  %0 = load ptr, ptr %stat.addr, align 8
  %call = call zeroext i1 @mi_is_in_main(ptr noundef %0)
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %stat.addr, align 8
  %count = getelementptr inbounds %struct.mi_stat_counter_s, ptr %1, i32 0, i32 1
  %call1 = call i64 @mi_atomic_addi64_relaxed(ptr noundef %count, i64 noundef 1)
  %2 = load ptr, ptr %stat.addr, align 8
  %total = getelementptr inbounds %struct.mi_stat_counter_s, ptr %2, i32 0, i32 0
  %3 = load i64, ptr %amount.addr, align 8
  %call2 = call i64 @mi_atomic_addi64_relaxed(ptr noundef %total, i64 noundef %3)
  br label %if.end

if.else:                                          ; preds = %entry
  %4 = load ptr, ptr %stat.addr, align 8
  %count3 = getelementptr inbounds %struct.mi_stat_counter_s, ptr %4, i32 0, i32 1
  %5 = load i64, ptr %count3, align 8
  %inc = add i64 %5, 1
  store i64 %inc, ptr %count3, align 8
  %6 = load i64, ptr %amount.addr, align 8
  %7 = load ptr, ptr %stat.addr, align 8
  %total4 = getelementptr inbounds %struct.mi_stat_counter_s, ptr %7, i32 0, i32 0
  %8 = load i64, ptr %total4, align 8
  %add = add i64 %8, %6
  store i64 %add, ptr %total4, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_os_page_align_areax(i1 noundef zeroext %conservative, ptr noundef %addr, i64 noundef %size, ptr noundef %newsize) #0 {
entry:
  %retval = alloca ptr, align 8
  %conservative.addr = alloca i8, align 1
  %addr.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %newsize.addr = alloca ptr, align 8
  %start = alloca ptr, align 8
  %end = alloca ptr, align 8
  %diff = alloca i64, align 8
  %frombool = zext i1 %conservative to i8
  store i8 %frombool, ptr %conservative.addr, align 1
  store ptr %addr, ptr %addr.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store ptr %newsize, ptr %newsize.addr, align 8
  %0 = load ptr, ptr %newsize.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %newsize.addr, align 8
  store i64 0, ptr %1, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i64, ptr %size.addr, align 8
  %cmp1 = icmp eq i64 %2, 0
  br i1 %cmp1, label %if.then3, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %3 = load ptr, ptr %addr.addr, align 8
  %cmp2 = icmp eq ptr %3, null
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %lor.lhs.false, %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %lor.lhs.false
  %4 = load i8, ptr %conservative.addr, align 1
  %tobool = trunc i8 %4 to i1
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end4
  %5 = load ptr, ptr %addr.addr, align 8
  %call = call i64 @_mi_os_page_size()
  %call5 = call ptr @mi_align_up_ptr(ptr noundef %5, i64 noundef %call)
  br label %cond.end

cond.false:                                       ; preds = %if.end4
  %6 = load ptr, ptr %addr.addr, align 8
  %call6 = call i64 @_mi_os_page_size()
  %call7 = call ptr @mi_align_down_ptr(ptr noundef %6, i64 noundef %call6)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call5, %cond.true ], [ %call7, %cond.false ]
  store ptr %cond, ptr %start, align 8
  %7 = load i8, ptr %conservative.addr, align 1
  %tobool8 = trunc i8 %7 to i1
  br i1 %tobool8, label %cond.true9, label %cond.false12

cond.true9:                                       ; preds = %cond.end
  %8 = load ptr, ptr %addr.addr, align 8
  %9 = load i64, ptr %size.addr, align 8
  %add.ptr = getelementptr i8, ptr %8, i64 %9
  %call10 = call i64 @_mi_os_page_size()
  %call11 = call ptr @mi_align_down_ptr(ptr noundef %add.ptr, i64 noundef %call10)
  br label %cond.end16

cond.false12:                                     ; preds = %cond.end
  %10 = load ptr, ptr %addr.addr, align 8
  %11 = load i64, ptr %size.addr, align 8
  %add.ptr13 = getelementptr i8, ptr %10, i64 %11
  %call14 = call i64 @_mi_os_page_size()
  %call15 = call ptr @mi_align_up_ptr(ptr noundef %add.ptr13, i64 noundef %call14)
  br label %cond.end16

cond.end16:                                       ; preds = %cond.false12, %cond.true9
  %cond17 = phi ptr [ %call11, %cond.true9 ], [ %call15, %cond.false12 ]
  store ptr %cond17, ptr %end, align 8
  %12 = load ptr, ptr %end, align 8
  %13 = load ptr, ptr %start, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %12 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %13 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, ptr %diff, align 8
  %14 = load i64, ptr %diff, align 8
  %cmp18 = icmp sle i64 %14, 0
  br i1 %cmp18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %cond.end16
  store ptr null, ptr %retval, align 8
  br label %return

if.end20:                                         ; preds = %cond.end16
  %15 = load ptr, ptr %newsize.addr, align 8
  %cmp21 = icmp ne ptr %15, null
  br i1 %cmp21, label %if.then22, label %if.end23

if.then22:                                        ; preds = %if.end20
  %16 = load i64, ptr %diff, align 8
  %17 = load ptr, ptr %newsize.addr, align 8
  store i64 %16, ptr %17, align 8
  br label %if.end23

if.end23:                                         ; preds = %if.then22, %if.end20
  %18 = load ptr, ptr %start, align 8
  store ptr %18, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end23, %if.then19, %if.then3
  %19 = load ptr, ptr %retval, align 8
  ret ptr %19
}

; Function Attrs: nounwind uwtable
define hidden i32 @_mi_prim_commit(ptr noundef %start, i64 noundef %size, ptr noundef %is_zero) #0 {
entry:
  %start.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %is_zero.addr = alloca ptr, align 8
  %err = alloca i32, align 4
  store ptr %start, ptr %start.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store ptr %is_zero, ptr %is_zero.addr, align 8
  %0 = load ptr, ptr %is_zero.addr, align 8
  store i8 0, ptr %0, align 1
  %1 = load ptr, ptr %start.addr, align 8
  %2 = load i64, ptr %size.addr, align 8
  %call = call i32 @mprotect(ptr noundef %1, i64 noundef %2, i32 noundef 3) #15
  store i32 %call, ptr %err, align 4
  %3 = load i32, ptr %err, align 4
  %cmp = icmp ne i32 %3, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call ptr @__errno_location() #18
  %4 = load i32, ptr %call1, align 4
  store i32 %4, ptr %err, align 4
  %5 = load i32, ptr %err, align 4
  call void @unix_mprotect_hint(i32 noundef %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load i32, ptr %err, align 4
  ret i32 %6
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_os_decommit_ex(ptr noundef %addr, i64 noundef %size, ptr noundef %needs_recommit, ptr noundef %tld_stats) #0 {
entry:
  %retval = alloca i1, align 1
  %addr.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %needs_recommit.addr = alloca ptr, align 8
  %tld_stats.addr = alloca ptr, align 8
  %stats = alloca ptr, align 8
  %csize = alloca i64, align 8
  %start = alloca ptr, align 8
  %err = alloca i32, align 4
  store ptr %addr, ptr %addr.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store ptr %needs_recommit, ptr %needs_recommit.addr, align 8
  store ptr %tld_stats, ptr %tld_stats.addr, align 8
  store ptr @_mi_stats_main, ptr %stats, align 8
  %0 = load ptr, ptr %stats, align 8
  %committed = getelementptr inbounds %struct.mi_stats_s, ptr %0, i32 0, i32 3
  %1 = load i64, ptr %size.addr, align 8
  call void @_mi_stat_decrease(ptr noundef %committed, i64 noundef %1)
  %2 = load ptr, ptr %addr.addr, align 8
  %3 = load i64, ptr %size.addr, align 8
  %call = call ptr @mi_os_page_align_area_conservative(ptr noundef %2, i64 noundef %3, ptr noundef %csize)
  store ptr %call, ptr %start, align 8
  %4 = load i64, ptr %csize, align 8
  %cmp = icmp eq i64 %4, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %5 = load ptr, ptr %needs_recommit.addr, align 8
  store i8 1, ptr %5, align 1
  %6 = load ptr, ptr %start, align 8
  %7 = load i64, ptr %csize, align 8
  %8 = load ptr, ptr %needs_recommit.addr, align 8
  %call1 = call i32 @_mi_prim_decommit(ptr noundef %6, i64 noundef %7, ptr noundef %8)
  store i32 %call1, ptr %err, align 4
  %9 = load i32, ptr %err, align 4
  %cmp2 = icmp ne i32 %9, 0
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %10 = load i32, ptr %err, align 4
  %11 = load i32, ptr %err, align 4
  %12 = load ptr, ptr %start, align 8
  %13 = load i64, ptr %csize, align 8
  call void (ptr, ...) @_mi_warning_message(ptr noundef @.str.91, i32 noundef %10, i32 noundef %11, ptr noundef %12, i64 noundef %13)
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end
  %14 = load i32, ptr %err, align 4
  %cmp5 = icmp eq i32 %14, 0
  store i1 %cmp5, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end4, %if.then
  %15 = load i1, ptr %retval, align 1
  ret i1 %15
}

; Function Attrs: nounwind uwtable
define hidden zeroext i1 @_mi_os_reset(ptr noundef %addr, i64 noundef %size, ptr noundef %stats) #0 {
entry:
  %retval = alloca i1, align 1
  %addr.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %stats.addr = alloca ptr, align 8
  %csize = alloca i64, align 8
  %start = alloca ptr, align 8
  %err = alloca i32, align 4
  store ptr %addr, ptr %addr.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store ptr %stats, ptr %stats.addr, align 8
  %0 = load ptr, ptr %addr.addr, align 8
  %1 = load i64, ptr %size.addr, align 8
  %call = call ptr @mi_os_page_align_area_conservative(ptr noundef %0, i64 noundef %1, ptr noundef %csize)
  store ptr %call, ptr %start, align 8
  %2 = load i64, ptr %csize, align 8
  %cmp = icmp eq i64 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %stats.addr, align 8
  %reset = getelementptr inbounds %struct.mi_stats_s, ptr %3, i32 0, i32 4
  %4 = load i64, ptr %csize, align 8
  call void @_mi_stat_increase(ptr noundef %reset, i64 noundef %4)
  %5 = load ptr, ptr %stats.addr, align 8
  %reset_calls = getelementptr inbounds %struct.mi_stats_s, ptr %5, i32 0, i32 18
  call void @_mi_stat_counter_increase(ptr noundef %reset_calls, i64 noundef 1)
  %6 = load ptr, ptr %start, align 8
  %7 = load i64, ptr %csize, align 8
  %call1 = call i32 @_mi_prim_reset(ptr noundef %6, i64 noundef %7)
  store i32 %call1, ptr %err, align 4
  %8 = load i32, ptr %err, align 4
  %cmp2 = icmp ne i32 %8, 0
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %9 = load i32, ptr %err, align 4
  %10 = load i32, ptr %err, align 4
  %11 = load ptr, ptr %start, align 8
  %12 = load i64, ptr %csize, align 8
  call void (ptr, ...) @_mi_warning_message(ptr noundef @.str.25, i32 noundef %9, i32 noundef %10, ptr noundef %11, i64 noundef %12)
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end
  %13 = load i32, ptr %err, align 4
  %cmp5 = icmp eq i32 %13, 0
  store i1 %cmp5, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end4, %if.then
  %14 = load i1, ptr %retval, align 1
  ret i1 %14
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_os_page_align_area_conservative(ptr noundef %addr, i64 noundef %size, ptr noundef %newsize) #0 {
entry:
  %addr.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %newsize.addr = alloca ptr, align 8
  store ptr %addr, ptr %addr.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store ptr %newsize, ptr %newsize.addr, align 8
  %0 = load ptr, ptr %addr.addr, align 8
  %1 = load i64, ptr %size.addr, align 8
  %2 = load ptr, ptr %newsize.addr, align 8
  %call = call ptr @mi_os_page_align_areax(i1 noundef zeroext true, ptr noundef %0, i64 noundef %1, ptr noundef %2)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define hidden i32 @_mi_prim_reset(ptr noundef %start, i64 noundef %size) #0 {
entry:
  %start.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %oadvice = alloca i32, align 4
  %atomic-temp = alloca i64, align 8
  %err = alloca i32, align 4
  %.atomictmp = alloca i64, align 8
  store ptr %start, ptr %start.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load atomic i64, ptr @_mi_prim_reset.advice monotonic, align 8
  store i64 %0, ptr %atomic-temp, align 8
  %1 = load i64, ptr %atomic-temp, align 8
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %oadvice, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %2 = load ptr, ptr %start.addr, align 8
  %3 = load i64, ptr %size.addr, align 8
  %4 = load i32, ptr %oadvice, align 4
  %call = call i32 @unix_madvise(ptr noundef %2, i64 noundef %3, i32 noundef %4)
  store i32 %call, ptr %err, align 4
  %cmp = icmp ne i32 %call, 0
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %call2 = call ptr @__errno_location() #18
  %5 = load i32, ptr %call2, align 4
  %cmp3 = icmp eq i32 %5, 11
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %6 = phi i1 [ false, %while.cond ], [ %cmp3, %land.rhs ]
  br i1 %6, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %call5 = call ptr @__errno_location() #18
  store i32 0, ptr %call5, align 4
  br label %while.cond, !llvm.loop !53

while.end:                                        ; preds = %land.end
  %7 = load i32, ptr %err, align 4
  %cmp6 = icmp ne i32 %7, 0
  br i1 %cmp6, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %while.end
  %call8 = call ptr @__errno_location() #18
  %8 = load i32, ptr %call8, align 4
  %cmp9 = icmp eq i32 %8, 22
  br i1 %cmp9, label %land.lhs.true11, label %if.end

land.lhs.true11:                                  ; preds = %land.lhs.true
  %9 = load i32, ptr %oadvice, align 4
  %cmp12 = icmp eq i32 %9, 8
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true11
  store i64 4, ptr %.atomictmp, align 8
  %10 = load i64, ptr %.atomictmp, align 8
  store atomic i64 %10, ptr @_mi_prim_reset.advice release, align 8
  %11 = load ptr, ptr %start.addr, align 8
  %12 = load i64, ptr %size.addr, align 8
  %call14 = call i32 @unix_madvise(ptr noundef %11, i64 noundef %12, i32 noundef 4)
  store i32 %call14, ptr %err, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true11, %land.lhs.true, %while.end
  %13 = load i32, ptr %err, align 4
  ret i32 %13
}

; Function Attrs: nounwind uwtable
define hidden zeroext i1 @_mi_os_purge_ex(ptr noundef %p, i64 noundef %size, i1 noundef zeroext %allow_reset, ptr noundef %stats) #0 {
entry:
  %retval = alloca i1, align 1
  %p.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %allow_reset.addr = alloca i8, align 1
  %stats.addr = alloca ptr, align 8
  %needs_recommit = alloca i8, align 1
  store ptr %p, ptr %p.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %frombool = zext i1 %allow_reset to i8
  store i8 %frombool, ptr %allow_reset.addr, align 1
  store ptr %stats, ptr %stats.addr, align 8
  %call = call i64 @mi_option_get(i32 noundef 15)
  %cmp = icmp slt i64 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %0 = load ptr, ptr %stats.addr, align 8
  %purge_calls = getelementptr inbounds %struct.mi_stats_s, ptr %0, i32 0, i32 19
  call void @_mi_stat_counter_increase(ptr noundef %purge_calls, i64 noundef 1)
  %1 = load ptr, ptr %stats.addr, align 8
  %purged = getelementptr inbounds %struct.mi_stats_s, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %size.addr, align 8
  call void @_mi_stat_increase(ptr noundef %purged, i64 noundef %2)
  %call1 = call zeroext i1 @mi_option_is_enabled(i32 noundef 5)
  br i1 %call1, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.end
  %call2 = call zeroext i1 @_mi_preloading()
  br i1 %call2, label %if.else, label %if.then3

if.then3:                                         ; preds = %land.lhs.true
  store i8 1, ptr %needs_recommit, align 1
  %3 = load ptr, ptr %p.addr, align 8
  %4 = load i64, ptr %size.addr, align 8
  %5 = load ptr, ptr %stats.addr, align 8
  %call4 = call zeroext i1 @mi_os_decommit_ex(ptr noundef %3, i64 noundef %4, ptr noundef %needs_recommit, ptr noundef %5)
  %6 = load i8, ptr %needs_recommit, align 1
  %tobool = trunc i8 %6 to i1
  store i1 %tobool, ptr %retval, align 1
  br label %return

if.else:                                          ; preds = %land.lhs.true, %if.end
  %7 = load i8, ptr %allow_reset.addr, align 1
  %tobool5 = trunc i8 %7 to i1
  br i1 %tobool5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.else
  %8 = load ptr, ptr %p.addr, align 8
  %9 = load i64, ptr %size.addr, align 8
  %10 = load ptr, ptr %stats.addr, align 8
  %call7 = call zeroext i1 @_mi_os_reset(ptr noundef %8, i64 noundef %9, ptr noundef %10)
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %if.else
  store i1 false, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end8, %if.then3, %if.then
  %11 = load i1, ptr %retval, align 1
  ret i1 %11
}

; Function Attrs: nounwind uwtable
define hidden zeroext i1 @_mi_os_purge(ptr noundef %p, i64 noundef %size, ptr noundef %stats) #0 {
entry:
  %p.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %stats.addr = alloca ptr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store ptr %stats, ptr %stats.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %1 = load i64, ptr %size.addr, align 8
  %2 = load ptr, ptr %stats.addr, align 8
  %call = call zeroext i1 @_mi_os_purge_ex(ptr noundef %0, i64 noundef %1, i1 noundef zeroext true, ptr noundef %2)
  ret i1 %call
}

; Function Attrs: nounwind uwtable
define hidden zeroext i1 @_mi_os_protect(ptr noundef %addr, i64 noundef %size) #0 {
entry:
  %addr.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  store ptr %addr, ptr %addr.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load ptr, ptr %addr.addr, align 8
  %1 = load i64, ptr %size.addr, align 8
  %call = call zeroext i1 @mi_os_protectx(ptr noundef %0, i64 noundef %1, i1 noundef zeroext true)
  ret i1 %call
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_os_protectx(ptr noundef %addr, i64 noundef %size, i1 noundef zeroext %protect) #0 {
entry:
  %retval = alloca i1, align 1
  %addr.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %protect.addr = alloca i8, align 1
  %csize = alloca i64, align 8
  %start = alloca ptr, align 8
  %err = alloca i32, align 4
  store ptr %addr, ptr %addr.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %frombool = zext i1 %protect to i8
  store i8 %frombool, ptr %protect.addr, align 1
  store i64 0, ptr %csize, align 8
  %0 = load ptr, ptr %addr.addr, align 8
  %1 = load i64, ptr %size.addr, align 8
  %call = call ptr @mi_os_page_align_area_conservative(ptr noundef %0, i64 noundef %1, ptr noundef %csize)
  store ptr %call, ptr %start, align 8
  %2 = load i64, ptr %csize, align 8
  %cmp = icmp eq i64 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %start, align 8
  %4 = load i64, ptr %csize, align 8
  %5 = load i8, ptr %protect.addr, align 1
  %tobool = trunc i8 %5 to i1
  %call1 = call i32 @_mi_prim_protect(ptr noundef %3, i64 noundef %4, i1 noundef zeroext %tobool)
  store i32 %call1, ptr %err, align 4
  %6 = load i32, ptr %err, align 4
  %cmp2 = icmp ne i32 %6, 0
  br i1 %cmp2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %7 = load i8, ptr %protect.addr, align 1
  %tobool4 = trunc i8 %7 to i1
  %cond = select i1 %tobool4, ptr @.str.93, ptr @.str.94
  %8 = load i32, ptr %err, align 4
  %9 = load i32, ptr %err, align 4
  %10 = load ptr, ptr %start, align 8
  %11 = load i64, ptr %csize, align 8
  call void (ptr, ...) @_mi_warning_message(ptr noundef @.str.92, ptr noundef %cond, i32 noundef %8, i32 noundef %9, ptr noundef %10, i64 noundef %11)
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end
  %12 = load i32, ptr %err, align 4
  %cmp6 = icmp eq i32 %12, 0
  store i1 %cmp6, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end5, %if.then
  %13 = load i1, ptr %retval, align 1
  ret i1 %13
}

; Function Attrs: nounwind uwtable
define hidden zeroext i1 @_mi_os_unprotect(ptr noundef %addr, i64 noundef %size) #0 {
entry:
  %addr.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  store ptr %addr, ptr %addr.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load ptr, ptr %addr.addr, align 8
  %1 = load i64, ptr %size.addr, align 8
  %call = call zeroext i1 @mi_os_protectx(ptr noundef %0, i64 noundef %1, i1 noundef zeroext false)
  ret i1 %call
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_os_claim_huge_pages(i64 noundef %pages, ptr noundef %total_size) #0 {
entry:
  %pages.addr = alloca i64, align 8
  %total_size.addr = alloca ptr, align 8
  %size = alloca i64, align 8
  %start = alloca i64, align 8
  %end = alloca i64, align 8
  %huge_start = alloca i64, align 8
  %atomic-temp = alloca i64, align 8
  %r = alloca i64, align 8
  %.atomictmp = alloca i64, align 8
  %cmpxchg.bool = alloca i8, align 1
  store i64 %pages, ptr %pages.addr, align 8
  store ptr %total_size, ptr %total_size.addr, align 8
  %0 = load ptr, ptr %total_size.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %total_size.addr, align 8
  store i64 0, ptr %1, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i64, ptr %pages.addr, align 8
  %mul = mul i64 %2, 1073741824
  store i64 %mul, ptr %size, align 8
  store i64 0, ptr %start, align 8
  store i64 0, ptr %end, align 8
  %3 = load atomic i64, ptr @mi_huge_start monotonic, align 64
  store i64 %3, ptr %atomic-temp, align 8
  %4 = load i64, ptr %atomic-temp, align 8
  store i64 %4, ptr %huge_start, align 8
  br label %do.body

do.body:                                          ; preds = %cmpxchg.continue, %if.end
  %5 = load i64, ptr %huge_start, align 8
  store i64 %5, ptr %start, align 8
  %6 = load i64, ptr %start, align 8
  %cmp1 = icmp eq i64 %6, 0
  br i1 %cmp1, label %if.then2, label %if.end5

if.then2:                                         ; preds = %do.body
  store i64 35184372088832, ptr %start, align 8
  %call = call ptr @mi_prim_get_default_heap()
  %call3 = call i64 @_mi_heap_random_next(ptr noundef %call)
  store i64 %call3, ptr %r, align 8
  %7 = load i64, ptr %start, align 8
  %8 = load i64, ptr %r, align 8
  %shr = lshr i64 %8, 17
  %and = and i64 %shr, 4095
  %mul4 = mul i64 1073741824, %and
  %add = add i64 %7, %mul4
  store i64 %add, ptr %start, align 8
  br label %if.end5

if.end5:                                          ; preds = %if.then2, %do.body
  %9 = load i64, ptr %start, align 8
  %10 = load i64, ptr %size, align 8
  %add6 = add i64 %9, %10
  store i64 %add6, ptr %end, align 8
  br label %do.cond

do.cond:                                          ; preds = %if.end5
  %11 = load i64, ptr %end, align 8
  store i64 %11, ptr %.atomictmp, align 8
  %12 = load i64, ptr %huge_start, align 8
  %13 = load i64, ptr %.atomictmp, align 8
  %14 = cmpxchg ptr @mi_huge_start, i64 %12, i64 %13 acq_rel acquire, align 64
  %15 = extractvalue { i64, i1 } %14, 0
  %16 = extractvalue { i64, i1 } %14, 1
  br i1 %16, label %cmpxchg.continue, label %cmpxchg.store_expected

cmpxchg.store_expected:                           ; preds = %do.cond
  store i64 %15, ptr %huge_start, align 8
  br label %cmpxchg.continue

cmpxchg.continue:                                 ; preds = %cmpxchg.store_expected, %do.cond
  %frombool = zext i1 %16 to i8
  store i8 %frombool, ptr %cmpxchg.bool, align 1
  %17 = load i8, ptr %cmpxchg.bool, align 1
  %tobool = trunc i8 %17 to i1
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %do.body, label %do.end, !llvm.loop !54

do.end:                                           ; preds = %cmpxchg.continue
  %18 = load ptr, ptr %total_size.addr, align 8
  %cmp7 = icmp ne ptr %18, null
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %do.end
  %19 = load i64, ptr %size, align 8
  %20 = load ptr, ptr %total_size.addr, align 8
  store i64 %19, ptr %20, align 8
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %do.end
  %21 = load i64, ptr %start, align 8
  %22 = inttoptr i64 %21 to ptr
  ret ptr %22
}

; Function Attrs: nounwind uwtable
define hidden i64 @_mi_clock_start() #0 {
entry:
  %t0 = alloca i64, align 8
  %0 = load i64, ptr @mi_clock_diff, align 8
  %conv = sitofp i64 %0 to double
  %cmp = fcmp oeq double %conv, 0.000000e+00
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i64 @_mi_clock_now()
  store i64 %call, ptr %t0, align 8
  %call2 = call i64 @_mi_clock_now()
  %1 = load i64, ptr %t0, align 8
  %sub = sub i64 %call2, %1
  store i64 %sub, ptr @mi_clock_diff, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %call3 = call i64 @_mi_clock_now()
  ret i64 %call3
}

; Function Attrs: nounwind uwtable
define hidden i32 @_mi_prim_alloc_huge_os_pages(ptr noundef %hint_addr, i64 noundef %size, i32 noundef %numa_node, ptr noundef %is_zero, ptr noundef %addr) #0 {
entry:
  %hint_addr.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %numa_node.addr = alloca i32, align 4
  %is_zero.addr = alloca ptr, align 8
  %addr.addr = alloca ptr, align 8
  %is_large = alloca i8, align 1
  %numa_mask = alloca i64, align 8
  %err = alloca i64, align 8
  store ptr %hint_addr, ptr %hint_addr.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store i32 %numa_node, ptr %numa_node.addr, align 4
  store ptr %is_zero, ptr %is_zero.addr, align 8
  store ptr %addr, ptr %addr.addr, align 8
  store i8 1, ptr %is_large, align 1
  %0 = load ptr, ptr %is_zero.addr, align 8
  store i8 1, ptr %0, align 1
  %1 = load ptr, ptr %hint_addr.addr, align 8
  %2 = load i64, ptr %size.addr, align 8
  %call = call ptr @unix_mmap(ptr noundef %1, i64 noundef %2, i64 noundef 33554432, i32 noundef 3, i1 noundef zeroext true, i1 noundef zeroext true, ptr noundef %is_large)
  %3 = load ptr, ptr %addr.addr, align 8
  store ptr %call, ptr %3, align 8
  %4 = load ptr, ptr %addr.addr, align 8
  %5 = load ptr, ptr %4, align 8
  %cmp = icmp ne ptr %5, null
  br i1 %cmp, label %land.lhs.true, label %if.end8

land.lhs.true:                                    ; preds = %entry
  %6 = load i32, ptr %numa_node.addr, align 4
  %cmp1 = icmp sge i32 %6, 0
  br i1 %cmp1, label %land.lhs.true2, label %if.end8

land.lhs.true2:                                   ; preds = %land.lhs.true
  %7 = load i32, ptr %numa_node.addr, align 4
  %cmp3 = icmp slt i32 %7, 64
  br i1 %cmp3, label %if.then, label %if.end8

if.then:                                          ; preds = %land.lhs.true2
  %8 = load i32, ptr %numa_node.addr, align 4
  %sh_prom = zext i32 %8 to i64
  %shl = shl i64 1, %sh_prom
  store i64 %shl, ptr %numa_mask, align 8
  %9 = load ptr, ptr %addr.addr, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = load i64, ptr %size.addr, align 8
  %call4 = call i64 @mi_prim_mbind(ptr noundef %10, i64 noundef %11, i64 noundef 1, ptr noundef %numa_mask, i64 noundef 64, i32 noundef 0)
  store i64 %call4, ptr %err, align 8
  %12 = load i64, ptr %err, align 8
  %cmp5 = icmp ne i64 %12, 0
  br i1 %cmp5, label %if.then6, label %if.end

if.then6:                                         ; preds = %if.then
  %call7 = call ptr @__errno_location() #18
  %13 = load i32, ptr %call7, align 4
  %conv = sext i32 %13 to i64
  store i64 %conv, ptr %err, align 8
  %14 = load i32, ptr %numa_node.addr, align 4
  %15 = load i64, ptr %err, align 8
  %16 = load i64, ptr %err, align 8
  call void (ptr, ...) @_mi_warning_message(ptr noundef @.str.31, i32 noundef %14, i64 noundef %15, i64 noundef %16)
  br label %if.end

if.end:                                           ; preds = %if.then6, %if.then
  br label %if.end8

if.end8:                                          ; preds = %if.end, %land.lhs.true2, %land.lhs.true, %entry
  %17 = load ptr, ptr %addr.addr, align 8
  %18 = load ptr, ptr %17, align 8
  %cmp9 = icmp ne ptr %18, null
  br i1 %cmp9, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end8
  br label %cond.end

cond.false:                                       ; preds = %if.end8
  %call11 = call ptr @__errno_location() #18
  %19 = load i32, ptr %call11, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 0, %cond.true ], [ %19, %cond.false ]
  ret i32 %cond
}

; Function Attrs: nounwind uwtable
define hidden i64 @_mi_clock_end(i64 noundef %start) #0 {
entry:
  %start.addr = alloca i64, align 8
  %end = alloca i64, align 8
  store i64 %start, ptr %start.addr, align 8
  %call = call i64 @_mi_clock_now()
  store i64 %call, ptr %end, align 8
  %0 = load i64, ptr %end, align 8
  %1 = load i64, ptr %start.addr, align 8
  %sub = sub i64 %0, %1
  %2 = load i64, ptr @mi_clock_diff, align 8
  %sub1 = sub i64 %sub, %2
  ret i64 %sub1
}

; Function Attrs: nounwind uwtable
define hidden i64 @_mi_os_numa_node_count_get() #0 {
entry:
  %count = alloca i64, align 8
  %atomic-temp = alloca i64, align 8
  %ncount = alloca i64, align 8
  %.atomictmp = alloca i64, align 8
  %0 = load atomic i64, ptr @_mi_numa_node_count acquire, align 8
  store i64 %0, ptr %atomic-temp, align 8
  %1 = load i64, ptr %atomic-temp, align 8
  store i64 %1, ptr %count, align 8
  %2 = load i64, ptr %count, align 8
  %cmp = icmp ule i64 %2, 0
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %call = call i64 @mi_option_get(i32 noundef 16)
  store i64 %call, ptr %ncount, align 8
  %3 = load i64, ptr %ncount, align 8
  %cmp1 = icmp sgt i64 %3, 0
  br i1 %cmp1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  %4 = load i64, ptr %ncount, align 8
  store i64 %4, ptr %count, align 8
  br label %if.end6

if.else:                                          ; preds = %if.then
  %call3 = call i64 @_mi_prim_numa_node_count()
  store i64 %call3, ptr %count, align 8
  %5 = load i64, ptr %count, align 8
  %cmp4 = icmp eq i64 %5, 0
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.else
  store i64 1, ptr %count, align 8
  br label %if.end

if.end:                                           ; preds = %if.then5, %if.else
  br label %if.end6

if.end6:                                          ; preds = %if.end, %if.then2
  %6 = load i64, ptr %count, align 8
  store i64 %6, ptr %.atomictmp, align 8
  %7 = load i64, ptr %.atomictmp, align 8
  store atomic i64 %7, ptr @_mi_numa_node_count release, align 8
  %8 = load i64, ptr %count, align 8
  call void (ptr, ...) @_mi_verbose_message(ptr noundef @.str.29, i64 noundef %8)
  br label %if.end7

if.end7:                                          ; preds = %if.end6, %entry
  %9 = load i64, ptr %count, align 8
  ret i64 %9
}

; Function Attrs: nounwind uwtable
define hidden i64 @_mi_prim_numa_node_count() #0 {
entry:
  %buf = alloca [128 x i8], align 16
  %node = alloca i32, align 4
  store i32 0, ptr %node, align 4
  store i32 0, ptr %node, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %node, align 4
  %cmp = icmp ult i32 %0, 256
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %arraydecay = getelementptr inbounds [128 x i8], ptr %buf, i64 0, i64 0
  %1 = load i32, ptr %node, align 4
  %add = add i32 %1, 1
  %call = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %arraydecay, i64 noundef 127, ptr noundef @.str.32, i32 noundef %add) #15
  %arraydecay1 = getelementptr inbounds [128 x i8], ptr %buf, i64 0, i64 0
  %call2 = call i32 @mi_prim_access(ptr noundef %arraydecay1, i32 noundef 4)
  %cmp3 = icmp ne i32 %call2, 0
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %for.end

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %2 = load i32, ptr %node, align 4
  %inc = add i32 %2, 1
  store i32 %inc, ptr %node, align 4
  br label %for.cond, !llvm.loop !55

for.end:                                          ; preds = %if.then, %for.cond
  %3 = load i32, ptr %node, align 4
  %add4 = add i32 %3, 1
  %conv = zext i32 %add4 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define hidden i32 @_mi_os_numa_node_get(ptr noundef %tld) #0 {
entry:
  %retval = alloca i32, align 4
  %tld.addr = alloca ptr, align 8
  %numa_count = alloca i64, align 8
  %numa_node = alloca i64, align 8
  store ptr %tld, ptr %tld.addr, align 8
  %call = call i64 @_mi_os_numa_node_count()
  store i64 %call, ptr %numa_count, align 8
  %0 = load i64, ptr %numa_count, align 8
  %cmp = icmp ule i64 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call i64 @_mi_prim_numa_node()
  store i64 %call1, ptr %numa_node, align 8
  %1 = load i64, ptr %numa_node, align 8
  %2 = load i64, ptr %numa_count, align 8
  %cmp2 = icmp uge i64 %1, %2
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %3 = load i64, ptr %numa_node, align 8
  %4 = load i64, ptr %numa_count, align 8
  %rem = urem i64 %3, %4
  store i64 %rem, ptr %numa_node, align 8
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end
  %5 = load i64, ptr %numa_node, align 8
  %conv = trunc i64 %5 to i32
  store i32 %conv, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end4, %if.then
  %6 = load i32, ptr %retval, align 4
  ret i32 %6
}

; Function Attrs: nounwind uwtable
define hidden i64 @_mi_prim_numa_node() #0 {
entry:
  %retval = alloca i64, align 8
  %node = alloca i64, align 8
  %ncpu = alloca i64, align 8
  %err = alloca i64, align 8
  store i64 0, ptr %node, align 8
  store i64 0, ptr %ncpu, align 8
  %call = call i64 (i64, ...) @syscall(i64 noundef 309, ptr noundef %ncpu, ptr noundef %node, ptr noundef null) #15
  store i64 %call, ptr %err, align 8
  %0 = load i64, ptr %err, align 8
  %cmp = icmp ne i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 0, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, ptr %node, align 8
  store i64 %1, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load i64, ptr %retval, align 8
  ret i64 %2
}

; Function Attrs: nounwind uwtable
define hidden zeroext i8 @_mi_bin(i64 noundef %size) #0 {
entry:
  %size.addr = alloca i64, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load i64, ptr %size.addr, align 8
  %call = call zeroext i8 @mi_bin(i64 noundef %0)
  ret i8 %call
}

; Function Attrs: nounwind uwtable
define internal zeroext i8 @mi_bin(i64 noundef %size) #0 {
entry:
  %size.addr = alloca i64, align 8
  %wsize = alloca i64, align 8
  %bin = alloca i8, align 1
  %b = alloca i8, align 1
  store i64 %size, ptr %size.addr, align 8
  %0 = load i64, ptr %size.addr, align 8
  %call = call i64 @_mi_wsize_from_size(i64 noundef %0)
  store i64 %call, ptr %wsize, align 8
  %1 = load i64, ptr %wsize, align 8
  %cmp = icmp ule i64 %1, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i8 1, ptr %bin, align 1
  br label %if.end19

if.else:                                          ; preds = %entry
  %2 = load i64, ptr %wsize, align 8
  %cmp1 = icmp ule i64 %2, 8
  br i1 %cmp1, label %if.then2, label %if.else3

if.then2:                                         ; preds = %if.else
  %3 = load i64, ptr %wsize, align 8
  %add = add i64 %3, 1
  %and = and i64 %add, -2
  %conv = trunc i64 %and to i8
  store i8 %conv, ptr %bin, align 1
  br label %if.end18

if.else3:                                         ; preds = %if.else
  %4 = load i64, ptr %wsize, align 8
  %cmp4 = icmp ugt i64 %4, 16384
  br i1 %cmp4, label %if.then6, label %if.else7

if.then6:                                         ; preds = %if.else3
  store i8 73, ptr %bin, align 1
  br label %if.end

if.else7:                                         ; preds = %if.else3
  %5 = load i64, ptr %wsize, align 8
  %dec = add i64 %5, -1
  store i64 %dec, ptr %wsize, align 8
  %6 = load i64, ptr %wsize, align 8
  %call8 = call i64 @mi_bsr(i64 noundef %6)
  %conv9 = trunc i64 %call8 to i8
  store i8 %conv9, ptr %b, align 1
  %7 = load i8, ptr %b, align 1
  %conv10 = zext i8 %7 to i32
  %shl = shl i32 %conv10, 2
  %8 = load i64, ptr %wsize, align 8
  %9 = load i8, ptr %b, align 1
  %conv11 = zext i8 %9 to i32
  %sub = sub i32 %conv11, 2
  %sh_prom = zext i32 %sub to i64
  %shr = lshr i64 %8, %sh_prom
  %and12 = and i64 %shr, 3
  %conv13 = trunc i64 %and12 to i8
  %conv14 = zext i8 %conv13 to i32
  %add15 = add i32 %shl, %conv14
  %sub16 = sub i32 %add15, 3
  %conv17 = trunc i32 %sub16 to i8
  store i8 %conv17, ptr %bin, align 1
  br label %if.end

if.end:                                           ; preds = %if.else7, %if.then6
  br label %if.end18

if.end18:                                         ; preds = %if.end, %if.then2
  br label %if.end19

if.end19:                                         ; preds = %if.end18, %if.then
  %10 = load i8, ptr %bin, align 1
  ret i8 %10
}

; Function Attrs: nounwind uwtable
define hidden i64 @_mi_bin_size(i8 noundef zeroext %bin) #0 {
entry:
  %bin.addr = alloca i8, align 1
  store i8 %bin, ptr %bin.addr, align 1
  %0 = load i8, ptr %bin.addr, align 1
  %idxprom = zext i8 %0 to i64
  %arrayidx = getelementptr [75 x %struct.mi_page_queue_s], ptr getelementptr inbounds (%struct.mi_heap_s, ptr @_mi_heap_empty, i32 0, i32 2), i64 0, i64 %idxprom
  %block_size = getelementptr inbounds %struct.mi_page_queue_s, ptr %arrayidx, i32 0, i32 2
  %1 = load i64, ptr %block_size, align 8
  ret i64 %1
}

; Function Attrs: nounwind uwtable
define hidden i64 @_mi_page_queue_append(ptr noundef %heap, ptr noundef %pq, ptr noundef %append) #0 {
entry:
  %retval = alloca i64, align 8
  %heap.addr = alloca ptr, align 8
  %pq.addr = alloca ptr, align 8
  %append.addr = alloca ptr, align 8
  %count = alloca i64, align 8
  %page = alloca ptr, align 8
  %.atomictmp = alloca i64, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store ptr %pq, ptr %pq.addr, align 8
  store ptr %append, ptr %append.addr, align 8
  %0 = load ptr, ptr %append.addr, align 8
  %first = getelementptr inbounds %struct.mi_page_queue_s, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %first, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 0, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store i64 0, ptr %count, align 8
  %2 = load ptr, ptr %append.addr, align 8
  %first1 = getelementptr inbounds %struct.mi_page_queue_s, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %first1, align 8
  store ptr %3, ptr %page, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %4 = load ptr, ptr %page, align 8
  %cmp2 = icmp ne ptr %4, null
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load ptr, ptr %page, align 8
  %xheap = getelementptr inbounds %struct.mi_page_s, ptr %5, i32 0, i32 12
  %6 = load ptr, ptr %heap.addr, align 8
  %7 = ptrtoint ptr %6 to i64
  store i64 %7, ptr %.atomictmp, align 8
  %8 = load i64, ptr %.atomictmp, align 8
  store atomic i64 %8, ptr %xheap release, align 8
  %9 = load ptr, ptr %page, align 8
  call void @_mi_page_use_delayed_free(ptr noundef %9, i32 noundef 0, i1 noundef zeroext false)
  %10 = load i64, ptr %count, align 8
  %inc = add i64 %10, 1
  store i64 %inc, ptr %count, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %11 = load ptr, ptr %page, align 8
  %next = getelementptr inbounds %struct.mi_page_s, ptr %11, i32 0, i32 13
  %12 = load ptr, ptr %next, align 8
  store ptr %12, ptr %page, align 8
  br label %for.cond, !llvm.loop !56

for.end:                                          ; preds = %for.cond
  %13 = load ptr, ptr %pq.addr, align 8
  %last = getelementptr inbounds %struct.mi_page_queue_s, ptr %13, i32 0, i32 1
  %14 = load ptr, ptr %last, align 8
  %cmp3 = icmp eq ptr %14, null
  br i1 %cmp3, label %if.then4, label %if.else

if.then4:                                         ; preds = %for.end
  %15 = load ptr, ptr %append.addr, align 8
  %first5 = getelementptr inbounds %struct.mi_page_queue_s, ptr %15, i32 0, i32 0
  %16 = load ptr, ptr %first5, align 8
  %17 = load ptr, ptr %pq.addr, align 8
  %first6 = getelementptr inbounds %struct.mi_page_queue_s, ptr %17, i32 0, i32 0
  store ptr %16, ptr %first6, align 8
  %18 = load ptr, ptr %append.addr, align 8
  %last7 = getelementptr inbounds %struct.mi_page_queue_s, ptr %18, i32 0, i32 1
  %19 = load ptr, ptr %last7, align 8
  %20 = load ptr, ptr %pq.addr, align 8
  %last8 = getelementptr inbounds %struct.mi_page_queue_s, ptr %20, i32 0, i32 1
  store ptr %19, ptr %last8, align 8
  %21 = load ptr, ptr %heap.addr, align 8
  %22 = load ptr, ptr %pq.addr, align 8
  call void @mi_heap_queue_first_update(ptr noundef %21, ptr noundef %22)
  br label %if.end16

if.else:                                          ; preds = %for.end
  %23 = load ptr, ptr %append.addr, align 8
  %first9 = getelementptr inbounds %struct.mi_page_queue_s, ptr %23, i32 0, i32 0
  %24 = load ptr, ptr %first9, align 8
  %25 = load ptr, ptr %pq.addr, align 8
  %last10 = getelementptr inbounds %struct.mi_page_queue_s, ptr %25, i32 0, i32 1
  %26 = load ptr, ptr %last10, align 8
  %next11 = getelementptr inbounds %struct.mi_page_s, ptr %26, i32 0, i32 13
  store ptr %24, ptr %next11, align 8
  %27 = load ptr, ptr %pq.addr, align 8
  %last12 = getelementptr inbounds %struct.mi_page_queue_s, ptr %27, i32 0, i32 1
  %28 = load ptr, ptr %last12, align 8
  %29 = load ptr, ptr %append.addr, align 8
  %first13 = getelementptr inbounds %struct.mi_page_queue_s, ptr %29, i32 0, i32 0
  %30 = load ptr, ptr %first13, align 8
  %prev = getelementptr inbounds %struct.mi_page_s, ptr %30, i32 0, i32 14
  store ptr %28, ptr %prev, align 8
  %31 = load ptr, ptr %append.addr, align 8
  %last14 = getelementptr inbounds %struct.mi_page_queue_s, ptr %31, i32 0, i32 1
  %32 = load ptr, ptr %last14, align 8
  %33 = load ptr, ptr %pq.addr, align 8
  %last15 = getelementptr inbounds %struct.mi_page_queue_s, ptr %33, i32 0, i32 1
  store ptr %32, ptr %last15, align 8
  br label %if.end16

if.end16:                                         ; preds = %if.else, %if.then4
  %34 = load i64, ptr %count, align 8
  store i64 %34, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end16, %if.then
  %35 = load i64, ptr %retval, align 8
  ret i64 %35
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_page_use_delayed_free(ptr noundef %page, i32 noundef %delay, i1 noundef zeroext %override_never) #0 {
entry:
  %page.addr = alloca ptr, align 8
  %delay.addr = alloca i32, align 4
  %override_never.addr = alloca i8, align 1
  store ptr %page, ptr %page.addr, align 8
  store i32 %delay, ptr %delay.addr, align 4
  %frombool = zext i1 %override_never to i8
  store i8 %frombool, ptr %override_never.addr, align 1
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load ptr, ptr %page.addr, align 8
  %1 = load i32, ptr %delay.addr, align 4
  %2 = load i8, ptr %override_never.addr, align 1
  %tobool = trunc i8 %2 to i1
  %call = call zeroext i1 @_mi_page_try_use_delayed_free(ptr noundef %0, i32 noundef %1, i1 noundef zeroext %tobool)
  %lnot = xor i1 %call, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  call void @mi_atomic_yield()
  br label %while.cond, !llvm.loop !57

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_heap_queue_first_update(ptr noundef %heap, ptr noundef %pq) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %pq.addr = alloca ptr, align 8
  %size = alloca i64, align 8
  %page = alloca ptr, align 8
  %start = alloca i64, align 8
  %idx = alloca i64, align 8
  %pages_free = alloca ptr, align 8
  %bin = alloca i8, align 1
  %prev = alloca ptr, align 8
  %sz = alloca i64, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store ptr %pq, ptr %pq.addr, align 8
  %0 = load ptr, ptr %pq.addr, align 8
  %block_size = getelementptr inbounds %struct.mi_page_queue_s, ptr %0, i32 0, i32 2
  %1 = load i64, ptr %block_size, align 8
  store i64 %1, ptr %size, align 8
  %2 = load i64, ptr %size, align 8
  %cmp = icmp ugt i64 %2, 1024
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %for.end

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %pq.addr, align 8
  %first = getelementptr inbounds %struct.mi_page_queue_s, ptr %3, i32 0, i32 0
  %4 = load ptr, ptr %first, align 8
  store ptr %4, ptr %page, align 8
  %5 = load ptr, ptr %pq.addr, align 8
  %first1 = getelementptr inbounds %struct.mi_page_queue_s, ptr %5, i32 0, i32 0
  %6 = load ptr, ptr %first1, align 8
  %cmp2 = icmp eq ptr %6, null
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store ptr @_mi_page_empty, ptr %page, align 8
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end
  %7 = load i64, ptr %size, align 8
  %call = call i64 @_mi_wsize_from_size(i64 noundef %7)
  store i64 %call, ptr %idx, align 8
  %8 = load ptr, ptr %heap.addr, align 8
  %pages_free_direct = getelementptr inbounds %struct.mi_heap_s, ptr %8, i32 0, i32 1
  %arraydecay = getelementptr inbounds [129 x ptr], ptr %pages_free_direct, i64 0, i64 0
  store ptr %arraydecay, ptr %pages_free, align 8
  %9 = load ptr, ptr %pages_free, align 8
  %10 = load i64, ptr %idx, align 8
  %arrayidx = getelementptr ptr, ptr %9, i64 %10
  %11 = load ptr, ptr %arrayidx, align 8
  %12 = load ptr, ptr %page, align 8
  %cmp5 = icmp eq ptr %11, %12
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end4
  br label %for.end

if.end7:                                          ; preds = %if.end4
  %13 = load i64, ptr %idx, align 8
  %cmp8 = icmp ule i64 %13, 1
  br i1 %cmp8, label %if.then9, label %if.else

if.then9:                                         ; preds = %if.end7
  store i64 0, ptr %start, align 8
  br label %if.end25

if.else:                                          ; preds = %if.end7
  %14 = load i64, ptr %size, align 8
  %call10 = call zeroext i8 @mi_bin(i64 noundef %14)
  store i8 %call10, ptr %bin, align 1
  %15 = load ptr, ptr %pq.addr, align 8
  %add.ptr = getelementptr %struct.mi_page_queue_s, ptr %15, i64 -1
  store ptr %add.ptr, ptr %prev, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.else
  %16 = load i8, ptr %bin, align 1
  %conv = zext i8 %16 to i32
  %17 = load ptr, ptr %prev, align 8
  %block_size11 = getelementptr inbounds %struct.mi_page_queue_s, ptr %17, i32 0, i32 2
  %18 = load i64, ptr %block_size11, align 8
  %call12 = call zeroext i8 @mi_bin(i64 noundef %18)
  %conv13 = zext i8 %call12 to i32
  %cmp14 = icmp eq i32 %conv, %conv13
  br i1 %cmp14, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %19 = load ptr, ptr %prev, align 8
  %20 = load ptr, ptr %heap.addr, align 8
  %pages = getelementptr inbounds %struct.mi_heap_s, ptr %20, i32 0, i32 2
  %arrayidx16 = getelementptr [75 x %struct.mi_page_queue_s], ptr %pages, i64 0, i64 0
  %cmp17 = icmp ugt ptr %19, %arrayidx16
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %21 = phi i1 [ false, %while.cond ], [ %cmp17, %land.rhs ]
  br i1 %21, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %22 = load ptr, ptr %prev, align 8
  %incdec.ptr = getelementptr %struct.mi_page_queue_s, ptr %22, i32 -1
  store ptr %incdec.ptr, ptr %prev, align 8
  br label %while.cond, !llvm.loop !58

while.end:                                        ; preds = %land.end
  %23 = load ptr, ptr %prev, align 8
  %block_size19 = getelementptr inbounds %struct.mi_page_queue_s, ptr %23, i32 0, i32 2
  %24 = load i64, ptr %block_size19, align 8
  %call20 = call i64 @_mi_wsize_from_size(i64 noundef %24)
  %add = add i64 1, %call20
  store i64 %add, ptr %start, align 8
  %25 = load i64, ptr %start, align 8
  %26 = load i64, ptr %idx, align 8
  %cmp21 = icmp ugt i64 %25, %26
  br i1 %cmp21, label %if.then23, label %if.end24

if.then23:                                        ; preds = %while.end
  %27 = load i64, ptr %idx, align 8
  store i64 %27, ptr %start, align 8
  br label %if.end24

if.end24:                                         ; preds = %if.then23, %while.end
  br label %if.end25

if.end25:                                         ; preds = %if.end24, %if.then9
  %28 = load i64, ptr %start, align 8
  store i64 %28, ptr %sz, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end25
  %29 = load i64, ptr %sz, align 8
  %30 = load i64, ptr %idx, align 8
  %cmp26 = icmp ule i64 %29, %30
  br i1 %cmp26, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %31 = load ptr, ptr %page, align 8
  %32 = load ptr, ptr %pages_free, align 8
  %33 = load i64, ptr %sz, align 8
  %arrayidx28 = getelementptr ptr, ptr %32, i64 %33
  store ptr %31, ptr %arrayidx28, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %34 = load i64, ptr %sz, align 8
  %inc = add i64 %34, 1
  store i64 %inc, ptr %sz, align 8
  br label %for.cond, !llvm.loop !59

for.end:                                          ; preds = %for.cond, %if.then6, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_atomic_yield() #0 {
entry:
  call void @llvm.x86.sse2.pause()
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @mi_tf_set_delayed(i64 noundef %tf, i32 noundef %delayed) #0 {
entry:
  %tf.addr = alloca i64, align 8
  %delayed.addr = alloca i32, align 4
  store i64 %tf, ptr %tf.addr, align 8
  store i32 %delayed, ptr %delayed.addr, align 4
  %0 = load i64, ptr %tf.addr, align 8
  %call = call ptr @mi_tf_block(i64 noundef %0)
  %1 = load i32, ptr %delayed.addr, align 4
  %call1 = call i64 @mi_tf_make(ptr noundef %call, i32 noundef %1)
  ret i64 %call1
}

; Function Attrs: nounwind uwtable
define internal i32 @mi_tf_delayed(i64 noundef %tf) #0 {
entry:
  %tf.addr = alloca i64, align 8
  store i64 %tf, ptr %tf.addr, align 8
  %0 = load i64, ptr %tf.addr, align 8
  %and = and i64 %0, 3
  %conv = trunc i64 %and to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_page_thread_free(ptr noundef %page) #0 {
entry:
  %page.addr = alloca ptr, align 8
  %atomic-temp = alloca i64, align 8
  store ptr %page, ptr %page.addr, align 8
  %0 = load ptr, ptr %page.addr, align 8
  %xthread_free = getelementptr inbounds %struct.mi_page_s, ptr %0, i32 0, i32 11
  %1 = load atomic i64, ptr %xthread_free monotonic, align 8
  store i64 %1, ptr %atomic-temp, align 8
  %2 = load i64, ptr %atomic-temp, align 8
  %and = and i64 %2, -4
  %3 = inttoptr i64 %and to ptr
  ret ptr %3
}

; Function Attrs: nounwind uwtable
define internal void @_mi_page_thread_free_collect(ptr noundef %page) #0 {
entry:
  %page.addr = alloca ptr, align 8
  %head = alloca ptr, align 8
  %tfreex = alloca i64, align 8
  %tfree = alloca i64, align 8
  %atomic-temp = alloca i64, align 8
  %.atomictmp = alloca i64, align 8
  %cmpxchg.bool = alloca i8, align 1
  %max_count = alloca i32, align 4
  %count = alloca i32, align 4
  %tail = alloca ptr, align 8
  %next = alloca ptr, align 8
  store ptr %page, ptr %page.addr, align 8
  %0 = load ptr, ptr %page.addr, align 8
  %xthread_free = getelementptr inbounds %struct.mi_page_s, ptr %0, i32 0, i32 11
  %1 = load atomic i64, ptr %xthread_free monotonic, align 8
  store i64 %1, ptr %atomic-temp, align 8
  %2 = load i64, ptr %atomic-temp, align 8
  store i64 %2, ptr %tfree, align 8
  br label %do.body

do.body:                                          ; preds = %cmpxchg.continue, %entry
  %3 = load i64, ptr %tfree, align 8
  %call = call ptr @mi_tf_block(i64 noundef %3)
  store ptr %call, ptr %head, align 8
  %4 = load i64, ptr %tfree, align 8
  %call1 = call i64 @mi_tf_set_block(i64 noundef %4, ptr noundef null)
  store i64 %call1, ptr %tfreex, align 8
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %5 = load ptr, ptr %page.addr, align 8
  %xthread_free2 = getelementptr inbounds %struct.mi_page_s, ptr %5, i32 0, i32 11
  %6 = load i64, ptr %tfreex, align 8
  store i64 %6, ptr %.atomictmp, align 8
  %7 = load i64, ptr %tfree, align 8
  %8 = load i64, ptr %.atomictmp, align 8
  %9 = cmpxchg weak ptr %xthread_free2, i64 %7, i64 %8 acq_rel acquire, align 8
  %10 = extractvalue { i64, i1 } %9, 0
  %11 = extractvalue { i64, i1 } %9, 1
  br i1 %11, label %cmpxchg.continue, label %cmpxchg.store_expected

cmpxchg.store_expected:                           ; preds = %do.cond
  store i64 %10, ptr %tfree, align 8
  br label %cmpxchg.continue

cmpxchg.continue:                                 ; preds = %cmpxchg.store_expected, %do.cond
  %frombool = zext i1 %11 to i8
  store i8 %frombool, ptr %cmpxchg.bool, align 1
  %12 = load i8, ptr %cmpxchg.bool, align 1
  %tobool = trunc i8 %12 to i1
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %do.body, label %do.end, !llvm.loop !60

do.end:                                           ; preds = %cmpxchg.continue
  %13 = load ptr, ptr %head, align 8
  %cmp = icmp eq ptr %13, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %do.end
  br label %return

if.end:                                           ; preds = %do.end
  %14 = load ptr, ptr %page.addr, align 8
  %capacity = getelementptr inbounds %struct.mi_page_s, ptr %14, i32 0, i32 3
  %15 = load i16, ptr %capacity, align 2
  %conv = zext i16 %15 to i32
  store i32 %conv, ptr %max_count, align 4
  store i32 1, ptr %count, align 4
  %16 = load ptr, ptr %head, align 8
  store ptr %16, ptr %tail, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end
  %17 = load ptr, ptr %page.addr, align 8
  %18 = load ptr, ptr %tail, align 8
  %call3 = call ptr @mi_block_next(ptr noundef %17, ptr noundef %18)
  store ptr %call3, ptr %next, align 8
  %cmp4 = icmp ne ptr %call3, null
  br i1 %cmp4, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %19 = load i32, ptr %count, align 4
  %20 = load i32, ptr %max_count, align 4
  %cmp6 = icmp ule i32 %19, %20
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %21 = phi i1 [ false, %while.cond ], [ %cmp6, %land.rhs ]
  br i1 %21, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %22 = load i32, ptr %count, align 4
  %inc = add i32 %22, 1
  store i32 %inc, ptr %count, align 4
  %23 = load ptr, ptr %next, align 8
  store ptr %23, ptr %tail, align 8
  br label %while.cond, !llvm.loop !61

while.end:                                        ; preds = %land.end
  %24 = load i32, ptr %count, align 4
  %25 = load i32, ptr %max_count, align 4
  %cmp8 = icmp ugt i32 %24, %25
  br i1 %cmp8, label %if.then10, label %if.end11

if.then10:                                        ; preds = %while.end
  call void (i32, ptr, ...) @_mi_error_message(i32 noundef 14, ptr noundef @.str.95)
  br label %return

if.end11:                                         ; preds = %while.end
  %26 = load ptr, ptr %page.addr, align 8
  %27 = load ptr, ptr %tail, align 8
  %28 = load ptr, ptr %page.addr, align 8
  %local_free = getelementptr inbounds %struct.mi_page_s, ptr %28, i32 0, i32 10
  %29 = load ptr, ptr %local_free, align 8
  call void @mi_block_set_next(ptr noundef %26, ptr noundef %27, ptr noundef %29)
  %30 = load ptr, ptr %head, align 8
  %31 = load ptr, ptr %page.addr, align 8
  %local_free12 = getelementptr inbounds %struct.mi_page_s, ptr %31, i32 0, i32 10
  store ptr %30, ptr %local_free12, align 8
  %32 = load i32, ptr %count, align 4
  %33 = load ptr, ptr %page.addr, align 8
  %used = getelementptr inbounds %struct.mi_page_s, ptr %33, i32 0, i32 8
  %34 = load i32, ptr %used, align 8
  %sub = sub i32 %34, %32
  store i32 %sub, ptr %used, align 8
  br label %return

return:                                           ; preds = %if.end11, %if.then10, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_page_reclaim(ptr noundef %heap, ptr noundef %page) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %page.addr = alloca ptr, align 8
  %pq = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store ptr %page, ptr %page.addr, align 8
  %0 = load ptr, ptr %heap.addr, align 8
  %1 = load ptr, ptr %page.addr, align 8
  %call = call i64 @mi_page_block_size(ptr noundef %1)
  %call1 = call ptr @mi_page_queue(ptr noundef %0, i64 noundef %call)
  store ptr %call1, ptr %pq, align 8
  %2 = load ptr, ptr %heap.addr, align 8
  %3 = load ptr, ptr %pq, align 8
  %4 = load ptr, ptr %page.addr, align 8
  call void @mi_page_queue_push(ptr noundef %2, ptr noundef %3, ptr noundef %4)
  ret void
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_page_queue(ptr noundef %heap, i64 noundef %size) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load ptr, ptr %heap.addr, align 8
  %pages = getelementptr inbounds %struct.mi_heap_s, ptr %0, i32 0, i32 2
  %1 = load i64, ptr %size.addr, align 8
  %call = call zeroext i8 @_mi_bin(i64 noundef %1)
  %idxprom = zext i8 %call to i64
  %arrayidx = getelementptr [75 x %struct.mi_page_queue_s], ptr %pages, i64 0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: nounwind uwtable
define internal void @mi_page_queue_push(ptr noundef %heap, ptr noundef %queue, ptr noundef %page) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %queue.addr = alloca ptr, align 8
  %page.addr = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store ptr %queue, ptr %queue.addr, align 8
  store ptr %page, ptr %page.addr, align 8
  %0 = load ptr, ptr %page.addr, align 8
  %1 = load ptr, ptr %queue.addr, align 8
  %call = call zeroext i1 @mi_page_queue_is_full(ptr noundef %1)
  call void @mi_page_set_in_full(ptr noundef %0, i1 noundef zeroext %call)
  %2 = load ptr, ptr %queue.addr, align 8
  %first = getelementptr inbounds %struct.mi_page_queue_s, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %first, align 8
  %4 = load ptr, ptr %page.addr, align 8
  %next = getelementptr inbounds %struct.mi_page_s, ptr %4, i32 0, i32 13
  store ptr %3, ptr %next, align 8
  %5 = load ptr, ptr %page.addr, align 8
  %prev = getelementptr inbounds %struct.mi_page_s, ptr %5, i32 0, i32 14
  store ptr null, ptr %prev, align 8
  %6 = load ptr, ptr %queue.addr, align 8
  %first1 = getelementptr inbounds %struct.mi_page_queue_s, ptr %6, i32 0, i32 0
  %7 = load ptr, ptr %first1, align 8
  %cmp = icmp ne ptr %7, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %8 = load ptr, ptr %page.addr, align 8
  %9 = load ptr, ptr %queue.addr, align 8
  %first2 = getelementptr inbounds %struct.mi_page_queue_s, ptr %9, i32 0, i32 0
  %10 = load ptr, ptr %first2, align 8
  %prev3 = getelementptr inbounds %struct.mi_page_s, ptr %10, i32 0, i32 14
  store ptr %8, ptr %prev3, align 8
  %11 = load ptr, ptr %page.addr, align 8
  %12 = load ptr, ptr %queue.addr, align 8
  %first4 = getelementptr inbounds %struct.mi_page_queue_s, ptr %12, i32 0, i32 0
  store ptr %11, ptr %first4, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %13 = load ptr, ptr %page.addr, align 8
  %14 = load ptr, ptr %queue.addr, align 8
  %last = getelementptr inbounds %struct.mi_page_queue_s, ptr %14, i32 0, i32 1
  store ptr %13, ptr %last, align 8
  %15 = load ptr, ptr %queue.addr, align 8
  %first5 = getelementptr inbounds %struct.mi_page_queue_s, ptr %15, i32 0, i32 0
  store ptr %13, ptr %first5, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %16 = load ptr, ptr %heap.addr, align 8
  %17 = load ptr, ptr %queue.addr, align 8
  call void @mi_heap_queue_first_update(ptr noundef %16, ptr noundef %17)
  %18 = load ptr, ptr %heap.addr, align 8
  %page_count = getelementptr inbounds %struct.mi_heap_s, ptr %18, i32 0, i32 9
  %19 = load i64, ptr %page_count, align 8
  %inc = add i64 %19, 1
  store i64 %inc, ptr %page_count, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_heap_delayed_free_all(ptr noundef %heap) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load ptr, ptr %heap.addr, align 8
  %call = call zeroext i1 @_mi_heap_delayed_free_partial(ptr noundef %0)
  %lnot = xor i1 %call, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  call void @mi_atomic_yield()
  br label %while.cond, !llvm.loop !62

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: nounwind uwtable
define hidden zeroext i1 @_mi_heap_delayed_free_partial(ptr noundef %heap) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %block = alloca ptr, align 8
  %atomic-temp = alloca ptr, align 8
  %.atomictmp = alloca ptr, align 8
  %cmpxchg.bool = alloca i8, align 1
  %all_freed = alloca i8, align 1
  %next = alloca ptr, align 8
  %dfree = alloca ptr, align 8
  %atomic-temp7 = alloca ptr, align 8
  %.atomictmp11 = alloca ptr, align 8
  %cmpxchg.bool12 = alloca i8, align 1
  store ptr %heap, ptr %heap.addr, align 8
  %0 = load ptr, ptr %heap.addr, align 8
  %thread_delayed_free = getelementptr inbounds %struct.mi_heap_s, ptr %0, i32 0, i32 3
  %1 = load atomic i64, ptr %thread_delayed_free monotonic, align 8
  store i64 %1, ptr %atomic-temp, align 8
  %2 = load ptr, ptr %atomic-temp, align 8
  store ptr %2, ptr %block, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %3 = load ptr, ptr %block, align 8
  %cmp = icmp ne ptr %3, null
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %4 = load ptr, ptr %heap.addr, align 8
  %thread_delayed_free1 = getelementptr inbounds %struct.mi_heap_s, ptr %4, i32 0, i32 3
  store ptr null, ptr %.atomictmp, align 8
  %5 = load i64, ptr %block, align 8
  %6 = load i64, ptr %.atomictmp, align 8
  %7 = cmpxchg weak ptr %thread_delayed_free1, i64 %5, i64 %6 acq_rel acquire, align 8
  %8 = extractvalue { i64, i1 } %7, 0
  %9 = extractvalue { i64, i1 } %7, 1
  br i1 %9, label %cmpxchg.continue, label %cmpxchg.store_expected

cmpxchg.store_expected:                           ; preds = %land.rhs
  store i64 %8, ptr %block, align 8
  br label %cmpxchg.continue

cmpxchg.continue:                                 ; preds = %cmpxchg.store_expected, %land.rhs
  %frombool = zext i1 %9 to i8
  store i8 %frombool, ptr %cmpxchg.bool, align 1
  %10 = load i8, ptr %cmpxchg.bool, align 1
  %tobool = trunc i8 %10 to i1
  %lnot = xor i1 %tobool, true
  br label %land.end

land.end:                                         ; preds = %cmpxchg.continue, %while.cond
  %11 = phi i1 [ false, %while.cond ], [ %lnot, %cmpxchg.continue ]
  br i1 %11, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  br label %while.cond, !llvm.loop !63

while.end:                                        ; preds = %land.end
  store i8 1, ptr %all_freed, align 1
  br label %while.cond2

while.cond2:                                      ; preds = %if.end, %while.end
  %12 = load ptr, ptr %block, align 8
  %cmp3 = icmp ne ptr %12, null
  br i1 %cmp3, label %while.body4, label %while.end18

while.body4:                                      ; preds = %while.cond2
  %13 = load ptr, ptr %heap.addr, align 8
  %14 = load ptr, ptr %block, align 8
  %15 = load ptr, ptr %heap.addr, align 8
  %keys = getelementptr inbounds %struct.mi_heap_s, ptr %15, i32 0, i32 7
  %arraydecay = getelementptr inbounds [2 x i64], ptr %keys, i64 0, i64 0
  %call = call ptr @mi_block_nextx(ptr noundef %13, ptr noundef %14, ptr noundef %arraydecay)
  store ptr %call, ptr %next, align 8
  %16 = load ptr, ptr %block, align 8
  %call5 = call zeroext i1 @_mi_free_delayed_block(ptr noundef %16)
  br i1 %call5, label %if.end, label %if.then

if.then:                                          ; preds = %while.body4
  store i8 0, ptr %all_freed, align 1
  %17 = load ptr, ptr %heap.addr, align 8
  %thread_delayed_free6 = getelementptr inbounds %struct.mi_heap_s, ptr %17, i32 0, i32 3
  %18 = load atomic i64, ptr %thread_delayed_free6 monotonic, align 8
  store i64 %18, ptr %atomic-temp7, align 8
  %19 = load ptr, ptr %atomic-temp7, align 8
  store ptr %19, ptr %dfree, align 8
  br label %do.body

do.body:                                          ; preds = %cmpxchg.continue14, %if.then
  %20 = load ptr, ptr %heap.addr, align 8
  %21 = load ptr, ptr %block, align 8
  %22 = load ptr, ptr %dfree, align 8
  %23 = load ptr, ptr %heap.addr, align 8
  %keys8 = getelementptr inbounds %struct.mi_heap_s, ptr %23, i32 0, i32 7
  %arraydecay9 = getelementptr inbounds [2 x i64], ptr %keys8, i64 0, i64 0
  call void @mi_block_set_nextx(ptr noundef %20, ptr noundef %21, ptr noundef %22, ptr noundef %arraydecay9)
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %24 = load ptr, ptr %heap.addr, align 8
  %thread_delayed_free10 = getelementptr inbounds %struct.mi_heap_s, ptr %24, i32 0, i32 3
  %25 = load ptr, ptr %block, align 8
  store ptr %25, ptr %.atomictmp11, align 8
  %26 = load i64, ptr %dfree, align 8
  %27 = load i64, ptr %.atomictmp11, align 8
  %28 = cmpxchg weak ptr %thread_delayed_free10, i64 %26, i64 %27 release monotonic, align 8
  %29 = extractvalue { i64, i1 } %28, 0
  %30 = extractvalue { i64, i1 } %28, 1
  br i1 %30, label %cmpxchg.continue14, label %cmpxchg.store_expected13

cmpxchg.store_expected13:                         ; preds = %do.cond
  store i64 %29, ptr %dfree, align 8
  br label %cmpxchg.continue14

cmpxchg.continue14:                               ; preds = %cmpxchg.store_expected13, %do.cond
  %frombool15 = zext i1 %30 to i8
  store i8 %frombool15, ptr %cmpxchg.bool12, align 1
  %31 = load i8, ptr %cmpxchg.bool12, align 1
  %tobool16 = trunc i8 %31 to i1
  %lnot17 = xor i1 %tobool16, true
  br i1 %lnot17, label %do.body, label %do.end, !llvm.loop !64

do.end:                                           ; preds = %cmpxchg.continue14
  br label %if.end

if.end:                                           ; preds = %do.end, %while.body4
  %32 = load ptr, ptr %next, align 8
  store ptr %32, ptr %block, align 8
  br label %while.cond2, !llvm.loop !65

while.end18:                                      ; preds = %while.cond2
  %33 = load i8, ptr %all_freed, align 1
  %tobool19 = trunc i8 %33 to i1
  ret i1 %tobool19
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_block_nextx(ptr noundef %null, ptr noundef %block, ptr noundef %keys) #0 {
entry:
  %null.addr = alloca ptr, align 8
  %block.addr = alloca ptr, align 8
  %keys.addr = alloca ptr, align 8
  %next = alloca ptr, align 8
  store ptr %null, ptr %null.addr, align 8
  store ptr %block, ptr %block.addr, align 8
  store ptr %keys, ptr %keys.addr, align 8
  %0 = load ptr, ptr %block.addr, align 8
  %next1 = getelementptr inbounds %struct.mi_block_s, ptr %0, i32 0, i32 0
  %1 = load i64, ptr %next1, align 8
  %2 = inttoptr i64 %1 to ptr
  store ptr %2, ptr %next, align 8
  %3 = load ptr, ptr %next, align 8
  ret ptr %3
}

; Function Attrs: nounwind uwtable
define internal void @mi_block_set_nextx(ptr noundef %null, ptr noundef %block, ptr noundef %next, ptr noundef %keys) #0 {
entry:
  %null.addr = alloca ptr, align 8
  %block.addr = alloca ptr, align 8
  %next.addr = alloca ptr, align 8
  %keys.addr = alloca ptr, align 8
  store ptr %null, ptr %null.addr, align 8
  store ptr %block, ptr %block.addr, align 8
  store ptr %next, ptr %next.addr, align 8
  store ptr %keys, ptr %keys.addr, align 8
  %0 = load ptr, ptr %next.addr, align 8
  %1 = ptrtoint ptr %0 to i64
  %2 = load ptr, ptr %block.addr, align 8
  %next1 = getelementptr inbounds %struct.mi_block_s, ptr %2, i32 0, i32 0
  store i64 %1, ptr %next1, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_page_unfull(ptr noundef %page) #0 {
entry:
  %page.addr = alloca ptr, align 8
  %heap = alloca ptr, align 8
  %pqfull = alloca ptr, align 8
  %pq = alloca ptr, align 8
  store ptr %page, ptr %page.addr, align 8
  %0 = load ptr, ptr %page.addr, align 8
  %call = call zeroext i1 @mi_page_is_in_full(ptr noundef %0)
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %page.addr, align 8
  %call1 = call ptr @mi_page_heap(ptr noundef %1)
  store ptr %call1, ptr %heap, align 8
  %2 = load ptr, ptr %heap, align 8
  %pages = getelementptr inbounds %struct.mi_heap_s, ptr %2, i32 0, i32 2
  %arrayidx = getelementptr [75 x %struct.mi_page_queue_s], ptr %pages, i64 0, i64 74
  store ptr %arrayidx, ptr %pqfull, align 8
  %3 = load ptr, ptr %page.addr, align 8
  call void @mi_page_set_in_full(ptr noundef %3, i1 noundef zeroext false)
  %4 = load ptr, ptr %heap, align 8
  %5 = load ptr, ptr %page.addr, align 8
  %call2 = call ptr @mi_heap_page_queue_of(ptr noundef %4, ptr noundef %5)
  store ptr %call2, ptr %pq, align 8
  %6 = load ptr, ptr %page.addr, align 8
  call void @mi_page_set_in_full(ptr noundef %6, i1 noundef zeroext true)
  %7 = load ptr, ptr %pq, align 8
  %8 = load ptr, ptr %pqfull, align 8
  %9 = load ptr, ptr %page.addr, align 8
  call void @mi_page_queue_enqueue_from(ptr noundef %7, ptr noundef %8, ptr noundef %9)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_page_is_in_full(ptr noundef %page) #0 {
entry:
  %page.addr = alloca ptr, align 8
  store ptr %page, ptr %page.addr, align 8
  %0 = load ptr, ptr %page.addr, align 8
  %flags = getelementptr inbounds %struct.mi_page_s, ptr %0, i32 0, i32 5
  %bf.load = load i8, ptr %flags, align 2
  %bf.clear = and i8 %bf.load, 1
  %tobool = icmp ne i8 %bf.clear, 0
  ret i1 %tobool
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_page_heap(ptr noundef %page) #0 {
entry:
  %page.addr = alloca ptr, align 8
  %atomic-temp = alloca i64, align 8
  store ptr %page, ptr %page.addr, align 8
  %0 = load ptr, ptr %page.addr, align 8
  %xheap = getelementptr inbounds %struct.mi_page_s, ptr %0, i32 0, i32 12
  %1 = load atomic i64, ptr %xheap monotonic, align 8
  store i64 %1, ptr %atomic-temp, align 8
  %2 = load i64, ptr %atomic-temp, align 8
  %3 = inttoptr i64 %2 to ptr
  ret ptr %3
}

; Function Attrs: nounwind uwtable
define internal void @mi_page_set_in_full(ptr noundef %page, i1 noundef zeroext %in_full) #0 {
entry:
  %page.addr = alloca ptr, align 8
  %in_full.addr = alloca i8, align 1
  store ptr %page, ptr %page.addr, align 8
  %frombool = zext i1 %in_full to i8
  store i8 %frombool, ptr %in_full.addr, align 1
  %0 = load i8, ptr %in_full.addr, align 1
  %tobool = trunc i8 %0 to i1
  %conv = zext i1 %tobool to i8
  %1 = load ptr, ptr %page.addr, align 8
  %flags = getelementptr inbounds %struct.mi_page_s, ptr %1, i32 0, i32 5
  %bf.load = load i8, ptr %flags, align 2
  %bf.value = and i8 %conv, 1
  %bf.clear = and i8 %bf.load, -2
  %bf.set = or i8 %bf.clear, %bf.value
  store i8 %bf.set, ptr %flags, align 2
  ret void
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_heap_page_queue_of(ptr noundef %heap, ptr noundef %page) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %page.addr = alloca ptr, align 8
  %bin = alloca i8, align 1
  %pq = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store ptr %page, ptr %page.addr, align 8
  %0 = load ptr, ptr %page.addr, align 8
  %call = call zeroext i1 @mi_page_is_in_full(ptr noundef %0)
  br i1 %call, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %page.addr, align 8
  %xblock_size = getelementptr inbounds %struct.mi_page_s, ptr %1, i32 0, i32 9
  %2 = load i32, ptr %xblock_size, align 4
  %conv = zext i32 %2 to i64
  %call1 = call zeroext i8 @mi_bin(i64 noundef %conv)
  %conv2 = zext i8 %call1 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 74, %cond.true ], [ %conv2, %cond.false ]
  %conv3 = trunc i32 %cond to i8
  store i8 %conv3, ptr %bin, align 1
  %3 = load ptr, ptr %heap.addr, align 8
  %pages = getelementptr inbounds %struct.mi_heap_s, ptr %3, i32 0, i32 2
  %4 = load i8, ptr %bin, align 1
  %idxprom = zext i8 %4 to i64
  %arrayidx = getelementptr [75 x %struct.mi_page_queue_s], ptr %pages, i64 0, i64 %idxprom
  store ptr %arrayidx, ptr %pq, align 8
  %5 = load ptr, ptr %pq, align 8
  ret ptr %5
}

; Function Attrs: nounwind uwtable
define internal void @mi_page_queue_enqueue_from(ptr noundef %to, ptr noundef %from, ptr noundef %page) #0 {
entry:
  %to.addr = alloca ptr, align 8
  %from.addr = alloca ptr, align 8
  %page.addr = alloca ptr, align 8
  %heap = alloca ptr, align 8
  store ptr %to, ptr %to.addr, align 8
  store ptr %from, ptr %from.addr, align 8
  store ptr %page, ptr %page.addr, align 8
  %0 = load ptr, ptr %page.addr, align 8
  %call = call ptr @mi_page_heap(ptr noundef %0)
  store ptr %call, ptr %heap, align 8
  %1 = load ptr, ptr %page.addr, align 8
  %prev = getelementptr inbounds %struct.mi_page_s, ptr %1, i32 0, i32 14
  %2 = load ptr, ptr %prev, align 8
  %cmp = icmp ne ptr %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %page.addr, align 8
  %next = getelementptr inbounds %struct.mi_page_s, ptr %3, i32 0, i32 13
  %4 = load ptr, ptr %next, align 8
  %5 = load ptr, ptr %page.addr, align 8
  %prev1 = getelementptr inbounds %struct.mi_page_s, ptr %5, i32 0, i32 14
  %6 = load ptr, ptr %prev1, align 8
  %next2 = getelementptr inbounds %struct.mi_page_s, ptr %6, i32 0, i32 13
  store ptr %4, ptr %next2, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %7 = load ptr, ptr %page.addr, align 8
  %next3 = getelementptr inbounds %struct.mi_page_s, ptr %7, i32 0, i32 13
  %8 = load ptr, ptr %next3, align 8
  %cmp4 = icmp ne ptr %8, null
  br i1 %cmp4, label %if.then5, label %if.end9

if.then5:                                         ; preds = %if.end
  %9 = load ptr, ptr %page.addr, align 8
  %prev6 = getelementptr inbounds %struct.mi_page_s, ptr %9, i32 0, i32 14
  %10 = load ptr, ptr %prev6, align 8
  %11 = load ptr, ptr %page.addr, align 8
  %next7 = getelementptr inbounds %struct.mi_page_s, ptr %11, i32 0, i32 13
  %12 = load ptr, ptr %next7, align 8
  %prev8 = getelementptr inbounds %struct.mi_page_s, ptr %12, i32 0, i32 14
  store ptr %10, ptr %prev8, align 8
  br label %if.end9

if.end9:                                          ; preds = %if.then5, %if.end
  %13 = load ptr, ptr %page.addr, align 8
  %14 = load ptr, ptr %from.addr, align 8
  %last = getelementptr inbounds %struct.mi_page_queue_s, ptr %14, i32 0, i32 1
  %15 = load ptr, ptr %last, align 8
  %cmp10 = icmp eq ptr %13, %15
  br i1 %cmp10, label %if.then11, label %if.end14

if.then11:                                        ; preds = %if.end9
  %16 = load ptr, ptr %page.addr, align 8
  %prev12 = getelementptr inbounds %struct.mi_page_s, ptr %16, i32 0, i32 14
  %17 = load ptr, ptr %prev12, align 8
  %18 = load ptr, ptr %from.addr, align 8
  %last13 = getelementptr inbounds %struct.mi_page_queue_s, ptr %18, i32 0, i32 1
  store ptr %17, ptr %last13, align 8
  br label %if.end14

if.end14:                                         ; preds = %if.then11, %if.end9
  %19 = load ptr, ptr %page.addr, align 8
  %20 = load ptr, ptr %from.addr, align 8
  %first = getelementptr inbounds %struct.mi_page_queue_s, ptr %20, i32 0, i32 0
  %21 = load ptr, ptr %first, align 8
  %cmp15 = icmp eq ptr %19, %21
  br i1 %cmp15, label %if.then16, label %if.end19

if.then16:                                        ; preds = %if.end14
  %22 = load ptr, ptr %page.addr, align 8
  %next17 = getelementptr inbounds %struct.mi_page_s, ptr %22, i32 0, i32 13
  %23 = load ptr, ptr %next17, align 8
  %24 = load ptr, ptr %from.addr, align 8
  %first18 = getelementptr inbounds %struct.mi_page_queue_s, ptr %24, i32 0, i32 0
  store ptr %23, ptr %first18, align 8
  %25 = load ptr, ptr %heap, align 8
  %26 = load ptr, ptr %from.addr, align 8
  call void @mi_heap_queue_first_update(ptr noundef %25, ptr noundef %26)
  br label %if.end19

if.end19:                                         ; preds = %if.then16, %if.end14
  %27 = load ptr, ptr %to.addr, align 8
  %last20 = getelementptr inbounds %struct.mi_page_queue_s, ptr %27, i32 0, i32 1
  %28 = load ptr, ptr %last20, align 8
  %29 = load ptr, ptr %page.addr, align 8
  %prev21 = getelementptr inbounds %struct.mi_page_s, ptr %29, i32 0, i32 14
  store ptr %28, ptr %prev21, align 8
  %30 = load ptr, ptr %page.addr, align 8
  %next22 = getelementptr inbounds %struct.mi_page_s, ptr %30, i32 0, i32 13
  store ptr null, ptr %next22, align 8
  %31 = load ptr, ptr %to.addr, align 8
  %last23 = getelementptr inbounds %struct.mi_page_queue_s, ptr %31, i32 0, i32 1
  %32 = load ptr, ptr %last23, align 8
  %cmp24 = icmp ne ptr %32, null
  br i1 %cmp24, label %if.then25, label %if.else

if.then25:                                        ; preds = %if.end19
  %33 = load ptr, ptr %page.addr, align 8
  %34 = load ptr, ptr %to.addr, align 8
  %last26 = getelementptr inbounds %struct.mi_page_queue_s, ptr %34, i32 0, i32 1
  %35 = load ptr, ptr %last26, align 8
  %next27 = getelementptr inbounds %struct.mi_page_s, ptr %35, i32 0, i32 13
  store ptr %33, ptr %next27, align 8
  %36 = load ptr, ptr %page.addr, align 8
  %37 = load ptr, ptr %to.addr, align 8
  %last28 = getelementptr inbounds %struct.mi_page_queue_s, ptr %37, i32 0, i32 1
  store ptr %36, ptr %last28, align 8
  br label %if.end31

if.else:                                          ; preds = %if.end19
  %38 = load ptr, ptr %page.addr, align 8
  %39 = load ptr, ptr %to.addr, align 8
  %first29 = getelementptr inbounds %struct.mi_page_queue_s, ptr %39, i32 0, i32 0
  store ptr %38, ptr %first29, align 8
  %40 = load ptr, ptr %page.addr, align 8
  %41 = load ptr, ptr %to.addr, align 8
  %last30 = getelementptr inbounds %struct.mi_page_queue_s, ptr %41, i32 0, i32 1
  store ptr %40, ptr %last30, align 8
  %42 = load ptr, ptr %heap, align 8
  %43 = load ptr, ptr %to.addr, align 8
  call void @mi_heap_queue_first_update(ptr noundef %42, ptr noundef %43)
  br label %if.end31

if.end31:                                         ; preds = %if.else, %if.then25
  %44 = load ptr, ptr %page.addr, align 8
  %45 = load ptr, ptr %to.addr, align 8
  %call32 = call zeroext i1 @mi_page_queue_is_full(ptr noundef %45)
  call void @mi_page_set_in_full(ptr noundef %44, i1 noundef zeroext %call32)
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_page_abandon(ptr noundef %page, ptr noundef %pq) #0 {
entry:
  %page.addr = alloca ptr, align 8
  %pq.addr = alloca ptr, align 8
  %pheap = alloca ptr, align 8
  %segments_tld = alloca ptr, align 8
  store ptr %page, ptr %page.addr, align 8
  store ptr %pq, ptr %pq.addr, align 8
  %0 = load ptr, ptr %page.addr, align 8
  %call = call ptr @mi_page_heap(ptr noundef %0)
  store ptr %call, ptr %pheap, align 8
  %1 = load ptr, ptr %pheap, align 8
  %tld = getelementptr inbounds %struct.mi_heap_s, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %tld, align 8
  %segments = getelementptr inbounds %struct.mi_tld_s, ptr %2, i32 0, i32 4
  store ptr %segments, ptr %segments_tld, align 8
  %3 = load ptr, ptr %pq.addr, align 8
  %4 = load ptr, ptr %page.addr, align 8
  call void @mi_page_queue_remove(ptr noundef %3, ptr noundef %4)
  %5 = load ptr, ptr %page.addr, align 8
  call void @mi_page_set_heap(ptr noundef %5, ptr noundef null)
  %6 = load ptr, ptr %page.addr, align 8
  %7 = load ptr, ptr %segments_tld, align 8
  call void @_mi_segment_page_abandon(ptr noundef %6, ptr noundef %7)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_page_queue_remove(ptr noundef %queue, ptr noundef %page) #0 {
entry:
  %queue.addr = alloca ptr, align 8
  %page.addr = alloca ptr, align 8
  %heap = alloca ptr, align 8
  store ptr %queue, ptr %queue.addr, align 8
  store ptr %page, ptr %page.addr, align 8
  %0 = load ptr, ptr %page.addr, align 8
  %call = call ptr @mi_page_heap(ptr noundef %0)
  store ptr %call, ptr %heap, align 8
  %1 = load ptr, ptr %page.addr, align 8
  %prev = getelementptr inbounds %struct.mi_page_s, ptr %1, i32 0, i32 14
  %2 = load ptr, ptr %prev, align 8
  %cmp = icmp ne ptr %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %page.addr, align 8
  %next = getelementptr inbounds %struct.mi_page_s, ptr %3, i32 0, i32 13
  %4 = load ptr, ptr %next, align 8
  %5 = load ptr, ptr %page.addr, align 8
  %prev1 = getelementptr inbounds %struct.mi_page_s, ptr %5, i32 0, i32 14
  %6 = load ptr, ptr %prev1, align 8
  %next2 = getelementptr inbounds %struct.mi_page_s, ptr %6, i32 0, i32 13
  store ptr %4, ptr %next2, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %7 = load ptr, ptr %page.addr, align 8
  %next3 = getelementptr inbounds %struct.mi_page_s, ptr %7, i32 0, i32 13
  %8 = load ptr, ptr %next3, align 8
  %cmp4 = icmp ne ptr %8, null
  br i1 %cmp4, label %if.then5, label %if.end9

if.then5:                                         ; preds = %if.end
  %9 = load ptr, ptr %page.addr, align 8
  %prev6 = getelementptr inbounds %struct.mi_page_s, ptr %9, i32 0, i32 14
  %10 = load ptr, ptr %prev6, align 8
  %11 = load ptr, ptr %page.addr, align 8
  %next7 = getelementptr inbounds %struct.mi_page_s, ptr %11, i32 0, i32 13
  %12 = load ptr, ptr %next7, align 8
  %prev8 = getelementptr inbounds %struct.mi_page_s, ptr %12, i32 0, i32 14
  store ptr %10, ptr %prev8, align 8
  br label %if.end9

if.end9:                                          ; preds = %if.then5, %if.end
  %13 = load ptr, ptr %page.addr, align 8
  %14 = load ptr, ptr %queue.addr, align 8
  %last = getelementptr inbounds %struct.mi_page_queue_s, ptr %14, i32 0, i32 1
  %15 = load ptr, ptr %last, align 8
  %cmp10 = icmp eq ptr %13, %15
  br i1 %cmp10, label %if.then11, label %if.end14

if.then11:                                        ; preds = %if.end9
  %16 = load ptr, ptr %page.addr, align 8
  %prev12 = getelementptr inbounds %struct.mi_page_s, ptr %16, i32 0, i32 14
  %17 = load ptr, ptr %prev12, align 8
  %18 = load ptr, ptr %queue.addr, align 8
  %last13 = getelementptr inbounds %struct.mi_page_queue_s, ptr %18, i32 0, i32 1
  store ptr %17, ptr %last13, align 8
  br label %if.end14

if.end14:                                         ; preds = %if.then11, %if.end9
  %19 = load ptr, ptr %page.addr, align 8
  %20 = load ptr, ptr %queue.addr, align 8
  %first = getelementptr inbounds %struct.mi_page_queue_s, ptr %20, i32 0, i32 0
  %21 = load ptr, ptr %first, align 8
  %cmp15 = icmp eq ptr %19, %21
  br i1 %cmp15, label %if.then16, label %if.end19

if.then16:                                        ; preds = %if.end14
  %22 = load ptr, ptr %page.addr, align 8
  %next17 = getelementptr inbounds %struct.mi_page_s, ptr %22, i32 0, i32 13
  %23 = load ptr, ptr %next17, align 8
  %24 = load ptr, ptr %queue.addr, align 8
  %first18 = getelementptr inbounds %struct.mi_page_queue_s, ptr %24, i32 0, i32 0
  store ptr %23, ptr %first18, align 8
  %25 = load ptr, ptr %heap, align 8
  %26 = load ptr, ptr %queue.addr, align 8
  call void @mi_heap_queue_first_update(ptr noundef %25, ptr noundef %26)
  br label %if.end19

if.end19:                                         ; preds = %if.then16, %if.end14
  %27 = load ptr, ptr %heap, align 8
  %page_count = getelementptr inbounds %struct.mi_heap_s, ptr %27, i32 0, i32 9
  %28 = load i64, ptr %page_count, align 8
  %dec = add i64 %28, -1
  store i64 %dec, ptr %page_count, align 8
  %29 = load ptr, ptr %page.addr, align 8
  %next20 = getelementptr inbounds %struct.mi_page_s, ptr %29, i32 0, i32 13
  store ptr null, ptr %next20, align 8
  %30 = load ptr, ptr %page.addr, align 8
  %prev21 = getelementptr inbounds %struct.mi_page_s, ptr %30, i32 0, i32 14
  store ptr null, ptr %prev21, align 8
  %31 = load ptr, ptr %page.addr, align 8
  call void @mi_page_set_in_full(ptr noundef %31, i1 noundef zeroext false)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_page_set_heap(ptr noundef %page, ptr noundef %heap) #0 {
entry:
  %page.addr = alloca ptr, align 8
  %heap.addr = alloca ptr, align 8
  %.atomictmp = alloca i64, align 8
  store ptr %page, ptr %page.addr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  %0 = load ptr, ptr %page.addr, align 8
  %xheap = getelementptr inbounds %struct.mi_page_s, ptr %0, i32 0, i32 12
  %1 = load ptr, ptr %heap.addr, align 8
  %2 = ptrtoint ptr %1 to i64
  store i64 %2, ptr %.atomictmp, align 8
  %3 = load i64, ptr %.atomictmp, align 8
  store atomic i64 %3, ptr %xheap release, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_segment_page_abandon(ptr noundef %page, ptr noundef %tld) #0 {
entry:
  %page.addr = alloca ptr, align 8
  %tld.addr = alloca ptr, align 8
  %segment = alloca ptr, align 8
  store ptr %page, ptr %page.addr, align 8
  store ptr %tld, ptr %tld.addr, align 8
  %0 = load ptr, ptr %page.addr, align 8
  %call = call ptr @_mi_page_segment(ptr noundef %0)
  store ptr %call, ptr %segment, align 8
  %1 = load ptr, ptr %segment, align 8
  %abandoned = getelementptr inbounds %struct.mi_segment_s, ptr %1, i32 0, i32 9
  %2 = load i64, ptr %abandoned, align 8
  %inc = add i64 %2, 1
  store i64 %inc, ptr %abandoned, align 8
  %3 = load ptr, ptr %tld.addr, align 8
  %stats = getelementptr inbounds %struct.mi_segments_tld_s, ptr %3, i32 0, i32 5
  %4 = load ptr, ptr %stats, align 8
  %pages_abandoned = getelementptr inbounds %struct.mi_stats_s, ptr %4, i32 0, i32 8
  call void @_mi_stat_increase(ptr noundef %pages_abandoned, i64 noundef 1)
  %5 = load ptr, ptr %segment, align 8
  %used = getelementptr inbounds %struct.mi_segment_s, ptr %5, i32 0, i32 11
  %6 = load i64, ptr %used, align 8
  %7 = load ptr, ptr %segment, align 8
  %abandoned1 = getelementptr inbounds %struct.mi_segment_s, ptr %7, i32 0, i32 9
  %8 = load i64, ptr %abandoned1, align 8
  %cmp = icmp eq i64 %6, %8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %9 = load ptr, ptr %segment, align 8
  %10 = load ptr, ptr %tld.addr, align 8
  call void @mi_segment_abandon(ptr noundef %9, ptr noundef %10)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_page_free(ptr noundef %page, ptr noundef %pq, i1 noundef zeroext %force) #0 {
entry:
  %page.addr = alloca ptr, align 8
  %pq.addr = alloca ptr, align 8
  %force.addr = alloca i8, align 1
  %heap = alloca ptr, align 8
  %segments_tld = alloca ptr, align 8
  store ptr %page, ptr %page.addr, align 8
  store ptr %pq, ptr %pq.addr, align 8
  %frombool = zext i1 %force to i8
  store i8 %frombool, ptr %force.addr, align 1
  %0 = load ptr, ptr %page.addr, align 8
  call void @mi_page_set_has_aligned(ptr noundef %0, i1 noundef zeroext false)
  %1 = load ptr, ptr %page.addr, align 8
  %call = call ptr @mi_page_heap(ptr noundef %1)
  store ptr %call, ptr %heap, align 8
  %2 = load ptr, ptr %heap, align 8
  %tld = getelementptr inbounds %struct.mi_heap_s, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %tld, align 8
  %segments = getelementptr inbounds %struct.mi_tld_s, ptr %3, i32 0, i32 4
  store ptr %segments, ptr %segments_tld, align 8
  %4 = load ptr, ptr %pq.addr, align 8
  %5 = load ptr, ptr %page.addr, align 8
  call void @mi_page_queue_remove(ptr noundef %4, ptr noundef %5)
  %6 = load ptr, ptr %page.addr, align 8
  call void @mi_page_set_heap(ptr noundef %6, ptr noundef null)
  %7 = load ptr, ptr %page.addr, align 8
  %8 = load i8, ptr %force.addr, align 1
  %tobool = trunc i8 %8 to i1
  %9 = load ptr, ptr %segments_tld, align 8
  call void @_mi_segment_page_free(ptr noundef %7, i1 noundef zeroext %tobool, ptr noundef %9)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_page_set_has_aligned(ptr noundef %page, i1 noundef zeroext %has_aligned) #0 {
entry:
  %page.addr = alloca ptr, align 8
  %has_aligned.addr = alloca i8, align 1
  store ptr %page, ptr %page.addr, align 8
  %frombool = zext i1 %has_aligned to i8
  store i8 %frombool, ptr %has_aligned.addr, align 1
  %0 = load i8, ptr %has_aligned.addr, align 1
  %tobool = trunc i8 %0 to i1
  %conv = zext i1 %tobool to i8
  %1 = load ptr, ptr %page.addr, align 8
  %flags = getelementptr inbounds %struct.mi_page_s, ptr %1, i32 0, i32 5
  %bf.load = load i8, ptr %flags, align 2
  %bf.value = and i8 %conv, 1
  %bf.shl = shl i8 %bf.value, 1
  %bf.clear = and i8 %bf.load, -3
  %bf.set = or i8 %bf.clear, %bf.shl
  store i8 %bf.set, ptr %flags, align 2
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_segment_page_free(ptr noundef %page, i1 noundef zeroext %force, ptr noundef %tld) #0 {
entry:
  %page.addr = alloca ptr, align 8
  %force.addr = alloca i8, align 1
  %tld.addr = alloca ptr, align 8
  %segment = alloca ptr, align 8
  store ptr %page, ptr %page.addr, align 8
  %frombool = zext i1 %force to i8
  store i8 %frombool, ptr %force.addr, align 1
  store ptr %tld, ptr %tld.addr, align 8
  %0 = load ptr, ptr %page.addr, align 8
  %call = call ptr @_mi_page_segment(ptr noundef %0)
  store ptr %call, ptr %segment, align 8
  %1 = load ptr, ptr %page.addr, align 8
  %2 = load ptr, ptr %tld.addr, align 8
  %call1 = call ptr @mi_segment_page_clear(ptr noundef %1, ptr noundef %2)
  %3 = load ptr, ptr %segment, align 8
  %used = getelementptr inbounds %struct.mi_segment_s, ptr %3, i32 0, i32 11
  %4 = load i64, ptr %used, align 8
  %cmp = icmp eq i64 %4, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %5 = load ptr, ptr %segment, align 8
  %6 = load i8, ptr %force.addr, align 1
  %tobool = trunc i8 %6 to i1
  %7 = load ptr, ptr %tld.addr, align 8
  call void @mi_segment_free(ptr noundef %5, i1 noundef zeroext %tobool, ptr noundef %7)
  br label %if.end5

if.else:                                          ; preds = %entry
  %8 = load ptr, ptr %segment, align 8
  %used2 = getelementptr inbounds %struct.mi_segment_s, ptr %8, i32 0, i32 11
  %9 = load i64, ptr %used2, align 8
  %10 = load ptr, ptr %segment, align 8
  %abandoned = getelementptr inbounds %struct.mi_segment_s, ptr %10, i32 0, i32 9
  %11 = load i64, ptr %abandoned, align 8
  %cmp3 = icmp eq i64 %9, %11
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.else
  %12 = load ptr, ptr %segment, align 8
  %13 = load ptr, ptr %tld.addr, align 8
  call void @mi_segment_abandon(ptr noundef %12, ptr noundef %13)
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.else
  br label %if.end5

if.end5:                                          ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_page_queue_of(ptr noundef %page) #0 {
entry:
  %page.addr = alloca ptr, align 8
  %bin = alloca i8, align 1
  %heap = alloca ptr, align 8
  %pq = alloca ptr, align 8
  store ptr %page, ptr %page.addr, align 8
  %0 = load ptr, ptr %page.addr, align 8
  %call = call zeroext i1 @mi_page_is_in_full(ptr noundef %0)
  br i1 %call, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %page.addr, align 8
  %xblock_size = getelementptr inbounds %struct.mi_page_s, ptr %1, i32 0, i32 9
  %2 = load i32, ptr %xblock_size, align 4
  %conv = zext i32 %2 to i64
  %call1 = call zeroext i8 @mi_bin(i64 noundef %conv)
  %conv2 = zext i8 %call1 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 74, %cond.true ], [ %conv2, %cond.false ]
  %conv3 = trunc i32 %cond to i8
  store i8 %conv3, ptr %bin, align 1
  %3 = load ptr, ptr %page.addr, align 8
  %call4 = call ptr @mi_page_heap(ptr noundef %3)
  store ptr %call4, ptr %heap, align 8
  %4 = load ptr, ptr %heap, align 8
  %pages = getelementptr inbounds %struct.mi_heap_s, ptr %4, i32 0, i32 2
  %5 = load i8, ptr %bin, align 1
  %idxprom = zext i8 %5 to i64
  %arrayidx = getelementptr [75 x %struct.mi_page_queue_s], ptr %pages, i64 0, i64 %idxprom
  store ptr %arrayidx, ptr %pq, align 8
  %6 = load ptr, ptr %pq, align 8
  ret ptr %6
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_page_queue_is_special(ptr noundef %pq) #0 {
entry:
  %pq.addr = alloca ptr, align 8
  store ptr %pq, ptr %pq.addr, align 8
  %0 = load ptr, ptr %pq.addr, align 8
  %block_size = getelementptr inbounds %struct.mi_page_queue_s, ptr %0, i32 0, i32 2
  %1 = load i64, ptr %block_size, align 8
  %cmp = icmp ugt i64 %1, 131072
  ret i1 %cmp
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_heap_collect_retired(ptr noundef %heap, i1 noundef zeroext %force) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %force.addr = alloca i8, align 1
  %min = alloca i64, align 8
  %max = alloca i64, align 8
  %bin = alloca i64, align 8
  %pq = alloca ptr, align 8
  %page = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  %frombool = zext i1 %force to i8
  store i8 %frombool, ptr %force.addr, align 1
  store i64 74, ptr %min, align 8
  store i64 0, ptr %max, align 8
  %0 = load ptr, ptr %heap.addr, align 8
  %page_retired_min = getelementptr inbounds %struct.mi_heap_s, ptr %0, i32 0, i32 10
  %1 = load i64, ptr %page_retired_min, align 8
  store i64 %1, ptr %bin, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i64, ptr %bin, align 8
  %3 = load ptr, ptr %heap.addr, align 8
  %page_retired_max = getelementptr inbounds %struct.mi_heap_s, ptr %3, i32 0, i32 11
  %4 = load i64, ptr %page_retired_max, align 8
  %cmp = icmp ule i64 %2, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load ptr, ptr %heap.addr, align 8
  %pages = getelementptr inbounds %struct.mi_heap_s, ptr %5, i32 0, i32 2
  %6 = load i64, ptr %bin, align 8
  %arrayidx = getelementptr [75 x %struct.mi_page_queue_s], ptr %pages, i64 0, i64 %6
  store ptr %arrayidx, ptr %pq, align 8
  %7 = load ptr, ptr %pq, align 8
  %first = getelementptr inbounds %struct.mi_page_queue_s, ptr %7, i32 0, i32 0
  %8 = load ptr, ptr %first, align 8
  store ptr %8, ptr %page, align 8
  %9 = load ptr, ptr %page, align 8
  %cmp1 = icmp ne ptr %9, null
  br i1 %cmp1, label %land.lhs.true, label %if.end33

land.lhs.true:                                    ; preds = %for.body
  %10 = load ptr, ptr %page, align 8
  %retire_expire = getelementptr inbounds %struct.mi_page_s, ptr %10, i32 0, i32 6
  %bf.load = load i8, ptr %retire_expire, align 1
  %bf.lshr = lshr i8 %bf.load, 1
  %conv = zext i8 %bf.lshr to i32
  %cmp2 = icmp ne i32 %conv, 0
  br i1 %cmp2, label %if.then, label %if.end33

if.then:                                          ; preds = %land.lhs.true
  %11 = load ptr, ptr %page, align 8
  %call = call zeroext i1 @mi_page_all_free(ptr noundef %11)
  br i1 %call, label %if.then4, label %if.else27

if.then4:                                         ; preds = %if.then
  %12 = load ptr, ptr %page, align 8
  %retire_expire5 = getelementptr inbounds %struct.mi_page_s, ptr %12, i32 0, i32 6
  %bf.load6 = load i8, ptr %retire_expire5, align 1
  %bf.lshr7 = lshr i8 %bf.load6, 1
  %dec = add i8 %bf.lshr7, -1
  %bf.load8 = load i8, ptr %retire_expire5, align 1
  %bf.value = and i8 %dec, 127
  %bf.shl = shl i8 %bf.value, 1
  %bf.clear = and i8 %bf.load8, 1
  %bf.set = or i8 %bf.clear, %bf.shl
  store i8 %bf.set, ptr %retire_expire5, align 1
  %13 = load i8, ptr %force.addr, align 1
  %tobool = trunc i8 %13 to i1
  br i1 %tobool, label %if.then16, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then4
  %14 = load ptr, ptr %page, align 8
  %retire_expire10 = getelementptr inbounds %struct.mi_page_s, ptr %14, i32 0, i32 6
  %bf.load11 = load i8, ptr %retire_expire10, align 1
  %bf.lshr12 = lshr i8 %bf.load11, 1
  %conv13 = zext i8 %bf.lshr12 to i32
  %cmp14 = icmp eq i32 %conv13, 0
  br i1 %cmp14, label %if.then16, label %if.else

if.then16:                                        ; preds = %lor.lhs.false, %if.then4
  %15 = load ptr, ptr %pq, align 8
  %first17 = getelementptr inbounds %struct.mi_page_queue_s, ptr %15, i32 0, i32 0
  %16 = load ptr, ptr %first17, align 8
  %17 = load ptr, ptr %pq, align 8
  %18 = load i8, ptr %force.addr, align 1
  %tobool18 = trunc i8 %18 to i1
  call void @_mi_page_free(ptr noundef %16, ptr noundef %17, i1 noundef zeroext %tobool18)
  br label %if.end26

if.else:                                          ; preds = %lor.lhs.false
  %19 = load i64, ptr %bin, align 8
  %20 = load i64, ptr %min, align 8
  %cmp19 = icmp ult i64 %19, %20
  br i1 %cmp19, label %if.then21, label %if.end

if.then21:                                        ; preds = %if.else
  %21 = load i64, ptr %bin, align 8
  store i64 %21, ptr %min, align 8
  br label %if.end

if.end:                                           ; preds = %if.then21, %if.else
  %22 = load i64, ptr %bin, align 8
  %23 = load i64, ptr %max, align 8
  %cmp22 = icmp ugt i64 %22, %23
  br i1 %cmp22, label %if.then24, label %if.end25

if.then24:                                        ; preds = %if.end
  %24 = load i64, ptr %bin, align 8
  store i64 %24, ptr %max, align 8
  br label %if.end25

if.end25:                                         ; preds = %if.then24, %if.end
  br label %if.end26

if.end26:                                         ; preds = %if.end25, %if.then16
  br label %if.end32

if.else27:                                        ; preds = %if.then
  %25 = load ptr, ptr %page, align 8
  %retire_expire28 = getelementptr inbounds %struct.mi_page_s, ptr %25, i32 0, i32 6
  %bf.load29 = load i8, ptr %retire_expire28, align 1
  %bf.clear30 = and i8 %bf.load29, 1
  %bf.set31 = or i8 %bf.clear30, 0
  store i8 %bf.set31, ptr %retire_expire28, align 1
  br label %if.end32

if.end32:                                         ; preds = %if.else27, %if.end26
  br label %if.end33

if.end33:                                         ; preds = %if.end32, %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end33
  %26 = load i64, ptr %bin, align 8
  %inc = add i64 %26, 1
  store i64 %inc, ptr %bin, align 8
  br label %for.cond, !llvm.loop !66

for.end:                                          ; preds = %for.cond
  %27 = load i64, ptr %min, align 8
  %28 = load ptr, ptr %heap.addr, align 8
  %page_retired_min34 = getelementptr inbounds %struct.mi_heap_s, ptr %28, i32 0, i32 10
  store i64 %27, ptr %page_retired_min34, align 8
  %29 = load i64, ptr %max, align 8
  %30 = load ptr, ptr %heap.addr, align 8
  %page_retired_max35 = getelementptr inbounds %struct.mi_heap_s, ptr %30, i32 0, i32 11
  store i64 %29, ptr %page_retired_max35, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_page_all_free(ptr noundef %page) #0 {
entry:
  %page.addr = alloca ptr, align 8
  store ptr %page, ptr %page.addr, align 8
  %0 = load ptr, ptr %page.addr, align 8
  %used = getelementptr inbounds %struct.mi_page_s, ptr %0, i32 0, i32 8
  %1 = load i32, ptr %used, align 8
  %cmp = icmp eq i32 %1, 0
  ret i1 %cmp
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_deferred_free(ptr noundef %heap, i1 noundef zeroext %force) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %force.addr = alloca i8, align 1
  %atomic-temp = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  %frombool = zext i1 %force to i8
  store i8 %frombool, ptr %force.addr, align 1
  %0 = load ptr, ptr %heap.addr, align 8
  %tld = getelementptr inbounds %struct.mi_heap_s, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %tld, align 8
  %heartbeat = getelementptr inbounds %struct.mi_tld_s, ptr %1, i32 0, i32 0
  %2 = load i64, ptr %heartbeat, align 8
  %inc = add i64 %2, 1
  store i64 %inc, ptr %heartbeat, align 8
  %3 = load volatile ptr, ptr @deferred_free, align 8
  %cmp = icmp ne ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %4 = load ptr, ptr %heap.addr, align 8
  %tld1 = getelementptr inbounds %struct.mi_heap_s, ptr %4, i32 0, i32 0
  %5 = load ptr, ptr %tld1, align 8
  %recurse = getelementptr inbounds %struct.mi_tld_s, ptr %5, i32 0, i32 1
  %6 = load i8, ptr %recurse, align 8
  %tobool = trunc i8 %6 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %7 = load ptr, ptr %heap.addr, align 8
  %tld2 = getelementptr inbounds %struct.mi_heap_s, ptr %7, i32 0, i32 0
  %8 = load ptr, ptr %tld2, align 8
  %recurse3 = getelementptr inbounds %struct.mi_tld_s, ptr %8, i32 0, i32 1
  store i8 1, ptr %recurse3, align 8
  %9 = load volatile ptr, ptr @deferred_free, align 8
  %10 = load i8, ptr %force.addr, align 1
  %tobool4 = trunc i8 %10 to i1
  %11 = load ptr, ptr %heap.addr, align 8
  %tld5 = getelementptr inbounds %struct.mi_heap_s, ptr %11, i32 0, i32 0
  %12 = load ptr, ptr %tld5, align 8
  %heartbeat6 = getelementptr inbounds %struct.mi_tld_s, ptr %12, i32 0, i32 0
  %13 = load i64, ptr %heartbeat6, align 8
  %14 = load atomic i64, ptr @deferred_arg monotonic, align 8
  store i64 %14, ptr %atomic-temp, align 8
  %15 = load ptr, ptr %atomic-temp, align 8
  call void %9(i1 noundef zeroext %tobool4, i64 noundef %13, ptr noundef %15)
  %16 = load ptr, ptr %heap.addr, align 8
  %tld7 = getelementptr inbounds %struct.mi_heap_s, ptr %16, i32 0, i32 0
  %17 = load ptr, ptr %tld7, align 8
  %recurse8 = getelementptr inbounds %struct.mi_tld_s, ptr %17, i32 0, i32 1
  store i8 0, ptr %recurse8, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @mi_register_deferred_free(ptr noundef %fn, ptr noundef %arg) #0 {
entry:
  %fn.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %.atomictmp = alloca ptr, align 8
  store ptr %fn, ptr %fn.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %fn.addr, align 8
  store volatile ptr %0, ptr @deferred_free, align 8
  %1 = load ptr, ptr %arg.addr, align 8
  store ptr %1, ptr %.atomictmp, align 8
  %2 = load i64, ptr %.atomictmp, align 8
  store atomic i64 %2, ptr @deferred_arg release, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_find_page(ptr noundef %heap, i64 noundef %size, i64 noundef %huge_alignment) #0 {
entry:
  %retval = alloca ptr, align 8
  %heap.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %huge_alignment.addr = alloca i64, align 8
  %req_size = alloca i64, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store i64 %huge_alignment, ptr %huge_alignment.addr, align 8
  %0 = load i64, ptr %size.addr, align 8
  %sub = sub i64 %0, 0
  store i64 %sub, ptr %req_size, align 8
  %1 = load i64, ptr %req_size, align 8
  %cmp = icmp ugt i64 %1, 131072
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %2 = load i64, ptr %huge_alignment.addr, align 8
  %cmp1 = icmp ugt i64 %2, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %3 = phi i1 [ true, %entry ], [ %cmp1, %lor.rhs ]
  %lnot = xor i1 %3, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %if.then, label %if.else12

if.then:                                          ; preds = %lor.end
  %4 = load i64, ptr %req_size, align 8
  %cmp3 = icmp ugt i64 %4, 9223372036854775807
  %lnot5 = xor i1 %cmp3, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv9 = sext i32 %lnot.ext8 to i64
  %tobool10 = icmp ne i64 %conv9, 0
  br i1 %tobool10, label %if.then11, label %if.else

if.then11:                                        ; preds = %if.then
  %5 = load i64, ptr %req_size, align 8
  call void (i32, ptr, ...) @_mi_error_message(i32 noundef 75, ptr noundef @.str.96, i64 noundef %5)
  store ptr null, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %if.then
  %6 = load ptr, ptr %heap.addr, align 8
  %7 = load i64, ptr %size.addr, align 8
  %8 = load i64, ptr %huge_alignment.addr, align 8
  %call = call ptr @mi_large_huge_page_alloc(ptr noundef %6, i64 noundef %7, i64 noundef %8)
  store ptr %call, ptr %retval, align 8
  br label %return

if.else12:                                        ; preds = %lor.end
  %9 = load ptr, ptr %heap.addr, align 8
  %10 = load i64, ptr %size.addr, align 8
  %call13 = call ptr @mi_find_free_page(ptr noundef %9, i64 noundef %10)
  store ptr %call13, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else12, %if.else, %if.then11
  %11 = load ptr, ptr %retval, align 8
  ret ptr %11
}

; Function Attrs: nounwind uwtable
define internal i64 @mi_page_usable_block_size(ptr noundef %page) #0 {
entry:
  %page.addr = alloca ptr, align 8
  store ptr %page, ptr %page.addr, align 8
  %0 = load ptr, ptr %page.addr, align 8
  %call = call i64 @mi_page_block_size(ptr noundef %0)
  %sub = sub i64 %call, 0
  ret i64 %sub
}

; Function Attrs: nounwind uwtable
define internal void @chacha_split(ptr noundef %ctx, i64 noundef %nonce, ptr noundef %ctx_new) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %nonce.addr = alloca i64, align 8
  %ctx_new.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i64 %nonce, ptr %nonce.addr, align 8
  store ptr %ctx_new, ptr %ctx_new.addr, align 8
  %0 = load ptr, ptr %ctx_new.addr, align 8
  call void @llvm.memset.p0.i64(ptr align 4 %0, i8 0, i64 136, i1 false)
  %1 = load ptr, ptr %ctx_new.addr, align 8
  %input = getelementptr inbounds %struct.mi_random_cxt_s, ptr %1, i32 0, i32 0
  %arraydecay = getelementptr inbounds [16 x i32], ptr %input, i64 0, i64 0
  %2 = load ptr, ptr %ctx.addr, align 8
  %input1 = getelementptr inbounds %struct.mi_random_cxt_s, ptr %2, i32 0, i32 0
  %arraydecay2 = getelementptr inbounds [16 x i32], ptr %input1, i64 0, i64 0
  call void @_mi_memcpy(ptr noundef %arraydecay, ptr noundef %arraydecay2, i64 noundef 64)
  %3 = load ptr, ptr %ctx_new.addr, align 8
  %input3 = getelementptr inbounds %struct.mi_random_cxt_s, ptr %3, i32 0, i32 0
  %arrayidx = getelementptr [16 x i32], ptr %input3, i64 0, i64 12
  store i32 0, ptr %arrayidx, align 4
  %4 = load ptr, ptr %ctx_new.addr, align 8
  %input4 = getelementptr inbounds %struct.mi_random_cxt_s, ptr %4, i32 0, i32 0
  %arrayidx5 = getelementptr [16 x i32], ptr %input4, i64 0, i64 13
  store i32 0, ptr %arrayidx5, align 4
  %5 = load i64, ptr %nonce.addr, align 8
  %conv = trunc i64 %5 to i32
  %6 = load ptr, ptr %ctx_new.addr, align 8
  %input6 = getelementptr inbounds %struct.mi_random_cxt_s, ptr %6, i32 0, i32 0
  %arrayidx7 = getelementptr [16 x i32], ptr %input6, i64 0, i64 14
  store i32 %conv, ptr %arrayidx7, align 4
  %7 = load i64, ptr %nonce.addr, align 8
  %shr = lshr i64 %7, 32
  %conv8 = trunc i64 %shr to i32
  %8 = load ptr, ptr %ctx_new.addr, align 8
  %input9 = getelementptr inbounds %struct.mi_random_cxt_s, ptr %8, i32 0, i32 0
  %arrayidx10 = getelementptr [16 x i32], ptr %input9, i64 0, i64 15
  store i32 %conv8, ptr %arrayidx10, align 4
  %9 = load ptr, ptr %ctx_new.addr, align 8
  call void @chacha_block(ptr noundef %9)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @chacha_next32(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %x = alloca i32, align 4
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %output_available = getelementptr inbounds %struct.mi_random_cxt_s, ptr %0, i32 0, i32 2
  %1 = load i32, ptr %output_available, align 4
  %cmp = icmp sle i32 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %ctx.addr, align 8
  call void @chacha_block(ptr noundef %2)
  %3 = load ptr, ptr %ctx.addr, align 8
  %output_available1 = getelementptr inbounds %struct.mi_random_cxt_s, ptr %3, i32 0, i32 2
  store i32 16, ptr %output_available1, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load ptr, ptr %ctx.addr, align 8
  %output = getelementptr inbounds %struct.mi_random_cxt_s, ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %ctx.addr, align 8
  %output_available2 = getelementptr inbounds %struct.mi_random_cxt_s, ptr %5, i32 0, i32 2
  %6 = load i32, ptr %output_available2, align 4
  %sub = sub i32 16, %6
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr [16 x i32], ptr %output, i64 0, i64 %idxprom
  %7 = load i32, ptr %arrayidx, align 4
  store i32 %7, ptr %x, align 4
  %8 = load ptr, ptr %ctx.addr, align 8
  %output3 = getelementptr inbounds %struct.mi_random_cxt_s, ptr %8, i32 0, i32 1
  %9 = load ptr, ptr %ctx.addr, align 8
  %output_available4 = getelementptr inbounds %struct.mi_random_cxt_s, ptr %9, i32 0, i32 2
  %10 = load i32, ptr %output_available4, align 4
  %sub5 = sub i32 16, %10
  %idxprom6 = sext i32 %sub5 to i64
  %arrayidx7 = getelementptr [16 x i32], ptr %output3, i64 0, i64 %idxprom6
  store i32 0, ptr %arrayidx7, align 4
  %11 = load ptr, ptr %ctx.addr, align 8
  %output_available8 = getelementptr inbounds %struct.mi_random_cxt_s, ptr %11, i32 0, i32 2
  %12 = load i32, ptr %output_available8, align 4
  %dec = add i32 %12, -1
  store i32 %dec, ptr %output_available8, align 4
  %13 = load i32, ptr %x, align 4
  ret i32 %13
}

; Function Attrs: nounwind uwtable
define hidden i64 @_mi_os_random_weak(i64 noundef %extra_seed) #0 {
entry:
  %extra_seed.addr = alloca i64, align 8
  %x = alloca i64, align 8
  %max = alloca i64, align 8
  %i = alloca i64, align 8
  store i64 %extra_seed, ptr %extra_seed.addr, align 8
  %0 = load i64, ptr %extra_seed.addr, align 8
  %xor = xor i64 ptrtoint (ptr @_mi_os_random_weak to i64), %0
  store i64 %xor, ptr %x, align 8
  %call = call i64 @_mi_prim_clock_now()
  %1 = load i64, ptr %x, align 8
  %xor1 = xor i64 %1, %call
  store i64 %xor1, ptr %x, align 8
  %2 = load i64, ptr %x, align 8
  %3 = load i64, ptr %x, align 8
  %shr = lshr i64 %3, 17
  %xor2 = xor i64 %2, %shr
  %and = and i64 %xor2, 15
  %add = add i64 %and, 1
  store i64 %add, ptr %max, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %4 = load i64, ptr %i, align 8
  %5 = load i64, ptr %max, align 8
  %cmp = icmp ult i64 %4, %5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load i64, ptr %x, align 8
  %call3 = call i64 @_mi_random_shuffle(i64 noundef %6)
  store i64 %call3, ptr %x, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %7 = load i64, ptr %i, align 8
  %inc = add i64 %7, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !67

for.end:                                          ; preds = %for.cond
  %8 = load i64, ptr %x, align 8
  ret i64 %8
}

; Function Attrs: nounwind uwtable
define hidden i64 @_mi_prim_clock_now() #0 {
entry:
  %t = alloca %struct.timespec, align 8
  %call = call i32 @clock_gettime(i32 noundef 1, ptr noundef %t) #15
  %tv_sec = getelementptr inbounds %struct.timespec, ptr %t, i32 0, i32 0
  %0 = load i64, ptr %tv_sec, align 8
  %mul = mul i64 %0, 1000
  %tv_nsec = getelementptr inbounds %struct.timespec, ptr %t, i32 0, i32 1
  %1 = load i64, ptr %tv_nsec, align 8
  %div = sdiv i64 %1, 1000000
  %add = add i64 %mul, %div
  ret i64 %add
}

; Function Attrs: nounwind uwtable
define internal i64 @_mi_random_shuffle(i64 noundef %x) #0 {
entry:
  %x.addr = alloca i64, align 8
  store i64 %x, ptr %x.addr, align 8
  %0 = load i64, ptr %x.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 17, ptr %x.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = load i64, ptr %x.addr, align 8
  %shr = lshr i64 %1, 30
  %2 = load i64, ptr %x.addr, align 8
  %xor = xor i64 %2, %shr
  store i64 %xor, ptr %x.addr, align 8
  %3 = load i64, ptr %x.addr, align 8
  %mul = mul i64 %3, -4658895280553007687
  store i64 %mul, ptr %x.addr, align 8
  %4 = load i64, ptr %x.addr, align 8
  %shr1 = lshr i64 %4, 27
  %5 = load i64, ptr %x.addr, align 8
  %xor2 = xor i64 %5, %shr1
  store i64 %xor2, ptr %x.addr, align 8
  %6 = load i64, ptr %x.addr, align 8
  %mul3 = mul i64 %6, -7723592293110705685
  store i64 %mul3, ptr %x.addr, align 8
  %7 = load i64, ptr %x.addr, align 8
  %shr4 = lshr i64 %7, 31
  %8 = load i64, ptr %x.addr, align 8
  %xor5 = xor i64 %8, %shr4
  store i64 %xor5, ptr %x.addr, align 8
  %9 = load i64, ptr %x.addr, align 8
  ret i64 %9
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_random_init(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  call void @mi_random_init_ex(ptr noundef %0, i1 noundef zeroext false)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_random_init_ex(ptr noundef %ctx, i1 noundef zeroext %use_weak) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %use_weak.addr = alloca i8, align 1
  %key = alloca [32 x i8], align 16
  %x = alloca i64, align 8
  %i = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %frombool = zext i1 %use_weak to i8
  store i8 %frombool, ptr %use_weak.addr, align 1
  call void @llvm.memset.p0.i64(ptr align 16 %key, i8 0, i64 32, i1 false)
  %0 = load i8, ptr %use_weak.addr, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %arraydecay = getelementptr inbounds [32 x i8], ptr %key, i64 0, i64 0
  %call = call zeroext i1 @_mi_prim_random_buf(ptr noundef %arraydecay, i64 noundef 32)
  br i1 %call, label %if.else, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  %1 = load i8, ptr %use_weak.addr, align 1
  %tobool1 = trunc i8 %1 to i1
  br i1 %tobool1, label %if.end, label %if.then2

if.then2:                                         ; preds = %if.then
  call void (ptr, ...) @_mi_warning_message(ptr noundef @.str.97)
  br label %if.end

if.end:                                           ; preds = %if.then2, %if.then
  %call3 = call i64 @_mi_os_random_weak(i64 noundef 0)
  store i64 %call3, ptr %x, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %2 = load i64, ptr %i, align 8
  %cmp = icmp ult i64 %2, 8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i64, ptr %x, align 8
  %call4 = call i64 @_mi_random_shuffle(i64 noundef %3)
  store i64 %call4, ptr %x, align 8
  %4 = load i64, ptr %x, align 8
  %conv = trunc i64 %4 to i32
  %arraydecay5 = getelementptr inbounds [32 x i8], ptr %key, i64 0, i64 0
  %5 = load i64, ptr %i, align 8
  %arrayidx = getelementptr i32, ptr %arraydecay5, i64 %5
  store i32 %conv, ptr %arrayidx, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %6 = load i64, ptr %i, align 8
  %inc = add i64 %6, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !68

for.end:                                          ; preds = %for.cond
  %7 = load ptr, ptr %ctx.addr, align 8
  %weak = getelementptr inbounds %struct.mi_random_cxt_s, ptr %7, i32 0, i32 3
  store i8 1, ptr %weak, align 4
  br label %if.end7

if.else:                                          ; preds = %lor.lhs.false
  %8 = load ptr, ptr %ctx.addr, align 8
  %weak6 = getelementptr inbounds %struct.mi_random_cxt_s, ptr %8, i32 0, i32 3
  store i8 0, ptr %weak6, align 4
  br label %if.end7

if.end7:                                          ; preds = %if.else, %for.end
  %9 = load ptr, ptr %ctx.addr, align 8
  %arraydecay8 = getelementptr inbounds [32 x i8], ptr %key, i64 0, i64 0
  %10 = load ptr, ptr %ctx.addr, align 8
  %11 = ptrtoint ptr %10 to i64
  call void @chacha_init(ptr noundef %9, ptr noundef %arraydecay8, i64 noundef %11)
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_random_init_weak(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  call void @mi_random_init_ex(ptr noundef %0, i1 noundef zeroext true)
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_random_reinit_if_weak(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %weak = getelementptr inbounds %struct.mi_random_cxt_s, ptr %0, i32 0, i32 3
  %1 = load i8, ptr %weak, align 4
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %ctx.addr, align 8
  call void @_mi_random_init(ptr noundef %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define hidden i64 @_mi_commit_mask_committed_size(ptr noundef %cm, i64 noundef %total) #0 {
entry:
  %cm.addr = alloca ptr, align 8
  %total.addr = alloca i64, align 8
  %count = alloca i64, align 8
  %i = alloca i64, align 8
  %mask = alloca i64, align 8
  store ptr %cm, ptr %cm.addr, align 8
  store i64 %total, ptr %total.addr, align 8
  store i64 0, ptr %count, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc9, %entry
  %0 = load i64, ptr %i, align 8
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.end11

for.body:                                         ; preds = %for.cond
  %1 = load ptr, ptr %cm.addr, align 8
  %mask1 = getelementptr inbounds %struct.mi_commit_mask_s, ptr %1, i32 0, i32 0
  %2 = load i64, ptr %i, align 8
  %arrayidx = getelementptr [8 x i64], ptr %mask1, i64 0, i64 %2
  %3 = load i64, ptr %arrayidx, align 8
  store i64 %3, ptr %mask, align 8
  %4 = load i64, ptr %mask, align 8
  %not = xor i64 %4, -1
  %cmp2 = icmp eq i64 %not, 0
  br i1 %cmp2, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  %5 = load i64, ptr %count, align 8
  %add = add i64 %5, 64
  store i64 %add, ptr %count, align 8
  br label %if.end8

if.else:                                          ; preds = %for.body
  br label %for.cond3

for.cond3:                                        ; preds = %for.inc, %if.else
  %6 = load i64, ptr %mask, align 8
  %cmp4 = icmp ne i64 %6, 0
  br i1 %cmp4, label %for.body5, label %for.end

for.body5:                                        ; preds = %for.cond3
  %7 = load i64, ptr %mask, align 8
  %and = and i64 %7, 1
  %cmp6 = icmp ne i64 %and, 0
  br i1 %cmp6, label %if.then7, label %if.end

if.then7:                                         ; preds = %for.body5
  %8 = load i64, ptr %count, align 8
  %inc = add i64 %8, 1
  store i64 %inc, ptr %count, align 8
  br label %if.end

if.end:                                           ; preds = %if.then7, %for.body5
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %9 = load i64, ptr %mask, align 8
  %shr = lshr i64 %9, 1
  store i64 %shr, ptr %mask, align 8
  br label %for.cond3, !llvm.loop !69

for.end:                                          ; preds = %for.cond3
  br label %if.end8

if.end8:                                          ; preds = %for.end, %if.then
  br label %for.inc9

for.inc9:                                         ; preds = %if.end8
  %10 = load i64, ptr %i, align 8
  %inc10 = add i64 %10, 1
  store i64 %inc10, ptr %i, align 8
  br label %for.cond, !llvm.loop !70

for.end11:                                        ; preds = %for.cond
  %11 = load i64, ptr %total.addr, align 8
  %div = udiv i64 %11, 512
  %12 = load i64, ptr %count, align 8
  %mul = mul i64 %div, %12
  ret i64 %mul
}

; Function Attrs: nounwind uwtable
define hidden i64 @_mi_commit_mask_next_run(ptr noundef %cm, ptr noundef %idx) #0 {
entry:
  %retval = alloca i64, align 8
  %cm.addr = alloca ptr, align 8
  %idx.addr = alloca ptr, align 8
  %i = alloca i64, align 8
  %ofs = alloca i64, align 8
  %mask = alloca i64, align 8
  %count = alloca i64, align 8
  store ptr %cm, ptr %cm.addr, align 8
  store ptr %idx, ptr %idx.addr, align 8
  %0 = load ptr, ptr %idx.addr, align 8
  %1 = load i64, ptr %0, align 8
  %div = udiv i64 %1, 64
  store i64 %div, ptr %i, align 8
  %2 = load ptr, ptr %idx.addr, align 8
  %3 = load i64, ptr %2, align 8
  %rem = urem i64 %3, 64
  store i64 %rem, ptr %ofs, align 8
  store i64 0, ptr %mask, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %4 = load i64, ptr %i, align 8
  %cmp = icmp ult i64 %4, 8
  br i1 %cmp, label %while.body, label %while.end8

while.body:                                       ; preds = %while.cond
  %5 = load ptr, ptr %cm.addr, align 8
  %mask1 = getelementptr inbounds %struct.mi_commit_mask_s, ptr %5, i32 0, i32 0
  %6 = load i64, ptr %i, align 8
  %arrayidx = getelementptr [8 x i64], ptr %mask1, i64 0, i64 %6
  %7 = load i64, ptr %arrayidx, align 8
  store i64 %7, ptr %mask, align 8
  %8 = load i64, ptr %ofs, align 8
  %9 = load i64, ptr %mask, align 8
  %shr = lshr i64 %9, %8
  store i64 %shr, ptr %mask, align 8
  %10 = load i64, ptr %mask, align 8
  %cmp2 = icmp ne i64 %10, 0
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  br label %while.cond3

while.cond3:                                      ; preds = %while.body5, %if.then
  %11 = load i64, ptr %mask, align 8
  %and = and i64 %11, 1
  %cmp4 = icmp eq i64 %and, 0
  br i1 %cmp4, label %while.body5, label %while.end

while.body5:                                      ; preds = %while.cond3
  %12 = load i64, ptr %mask, align 8
  %shr6 = lshr i64 %12, 1
  store i64 %shr6, ptr %mask, align 8
  %13 = load i64, ptr %ofs, align 8
  %inc = add i64 %13, 1
  store i64 %inc, ptr %ofs, align 8
  br label %while.cond3, !llvm.loop !71

while.end:                                        ; preds = %while.cond3
  br label %while.end8

if.end:                                           ; preds = %while.body
  %14 = load i64, ptr %i, align 8
  %inc7 = add i64 %14, 1
  store i64 %inc7, ptr %i, align 8
  store i64 0, ptr %ofs, align 8
  br label %while.cond, !llvm.loop !72

while.end8:                                       ; preds = %while.end, %while.cond
  %15 = load i64, ptr %i, align 8
  %cmp9 = icmp uge i64 %15, 8
  br i1 %cmp9, label %if.then10, label %if.else

if.then10:                                        ; preds = %while.end8
  %16 = load ptr, ptr %idx.addr, align 8
  store i64 512, ptr %16, align 8
  store i64 0, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %while.end8
  store i64 0, ptr %count, align 8
  %17 = load i64, ptr %i, align 8
  %mul = mul i64 %17, 64
  %18 = load i64, ptr %ofs, align 8
  %add = add i64 %mul, %18
  %19 = load ptr, ptr %idx.addr, align 8
  store i64 %add, ptr %19, align 8
  br label %do.body

do.body:                                          ; preds = %do.cond27, %if.else
  br label %do.body11

do.body11:                                        ; preds = %do.cond, %do.body
  %20 = load i64, ptr %count, align 8
  %inc12 = add i64 %20, 1
  store i64 %inc12, ptr %count, align 8
  %21 = load i64, ptr %mask, align 8
  %shr13 = lshr i64 %21, 1
  store i64 %shr13, ptr %mask, align 8
  br label %do.cond

do.cond:                                          ; preds = %do.body11
  %22 = load i64, ptr %mask, align 8
  %and14 = and i64 %22, 1
  %cmp15 = icmp eq i64 %and14, 1
  br i1 %cmp15, label %do.body11, label %do.end, !llvm.loop !73

do.end:                                           ; preds = %do.cond
  %23 = load ptr, ptr %idx.addr, align 8
  %24 = load i64, ptr %23, align 8
  %25 = load i64, ptr %count, align 8
  %add16 = add i64 %24, %25
  %rem17 = urem i64 %add16, 64
  %cmp18 = icmp eq i64 %rem17, 0
  br i1 %cmp18, label %if.then19, label %if.end26

if.then19:                                        ; preds = %do.end
  %26 = load i64, ptr %i, align 8
  %inc20 = add i64 %26, 1
  store i64 %inc20, ptr %i, align 8
  %27 = load i64, ptr %i, align 8
  %cmp21 = icmp uge i64 %27, 8
  br i1 %cmp21, label %if.then22, label %if.end23

if.then22:                                        ; preds = %if.then19
  br label %do.end30

if.end23:                                         ; preds = %if.then19
  %28 = load ptr, ptr %cm.addr, align 8
  %mask24 = getelementptr inbounds %struct.mi_commit_mask_s, ptr %28, i32 0, i32 0
  %29 = load i64, ptr %i, align 8
  %arrayidx25 = getelementptr [8 x i64], ptr %mask24, i64 0, i64 %29
  %30 = load i64, ptr %arrayidx25, align 8
  store i64 %30, ptr %mask, align 8
  store i64 0, ptr %ofs, align 8
  br label %if.end26

if.end26:                                         ; preds = %if.end23, %do.end
  br label %do.cond27

do.cond27:                                        ; preds = %if.end26
  %31 = load i64, ptr %mask, align 8
  %and28 = and i64 %31, 1
  %cmp29 = icmp eq i64 %and28, 1
  br i1 %cmp29, label %do.body, label %do.end30, !llvm.loop !74

do.end30:                                         ; preds = %do.cond27, %if.then22
  %32 = load i64, ptr %count, align 8
  store i64 %32, ptr %retval, align 8
  br label %return

return:                                           ; preds = %do.end30, %if.then10
  %33 = load i64, ptr %retval, align 8
  ret i64 %33
}

; Function Attrs: nounwind uwtable
define hidden ptr @_mi_segment_page_start(ptr noundef %segment, ptr noundef %page, ptr noundef %page_size) #0 {
entry:
  %segment.addr = alloca ptr, align 8
  %page.addr = alloca ptr, align 8
  %page_size.addr = alloca ptr, align 8
  %slice = alloca ptr, align 8
  %p = alloca ptr, align 8
  store ptr %segment, ptr %segment.addr, align 8
  store ptr %page, ptr %page.addr, align 8
  store ptr %page_size, ptr %page_size.addr, align 8
  %0 = load ptr, ptr %page.addr, align 8
  %call = call ptr @mi_page_to_slice(ptr noundef %0)
  store ptr %call, ptr %slice, align 8
  %1 = load ptr, ptr %segment.addr, align 8
  %2 = load ptr, ptr %slice, align 8
  %3 = load ptr, ptr %page.addr, align 8
  %xblock_size = getelementptr inbounds %struct.mi_page_s, ptr %3, i32 0, i32 9
  %4 = load i32, ptr %xblock_size, align 4
  %conv = zext i32 %4 to i64
  %5 = load ptr, ptr %page_size.addr, align 8
  %call1 = call ptr @_mi_segment_page_start_from_slice(ptr noundef %1, ptr noundef %2, i64 noundef %conv, ptr noundef %5)
  store ptr %call1, ptr %p, align 8
  %6 = load ptr, ptr %p, align 8
  ret ptr %6
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_page_to_slice(ptr noundef %p) #0 {
entry:
  %p.addr = alloca ptr, align 8
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  ret ptr %0
}

; Function Attrs: nounwind uwtable
define internal ptr @_mi_segment_page_start_from_slice(ptr noundef %segment, ptr noundef %slice, i64 noundef %xblock_size, ptr noundef %page_size) #0 {
entry:
  %segment.addr = alloca ptr, align 8
  %slice.addr = alloca ptr, align 8
  %xblock_size.addr = alloca i64, align 8
  %page_size.addr = alloca ptr, align 8
  %idx = alloca i64, align 8
  %psize = alloca i64, align 8
  %start_offset = alloca i64, align 8
  store ptr %segment, ptr %segment.addr, align 8
  store ptr %slice, ptr %slice.addr, align 8
  store i64 %xblock_size, ptr %xblock_size.addr, align 8
  store ptr %page_size, ptr %page_size.addr, align 8
  %0 = load ptr, ptr %slice.addr, align 8
  %1 = load ptr, ptr %segment.addr, align 8
  %slices = getelementptr inbounds %struct.mi_segment_s, ptr %1, i32 0, i32 18
  %arraydecay = getelementptr inbounds [513 x %struct.mi_page_s], ptr %slices, i64 0, i64 0
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %arraydecay to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 80
  store i64 %sub.ptr.div, ptr %idx, align 8
  %2 = load ptr, ptr %slice.addr, align 8
  %slice_count = getelementptr inbounds %struct.mi_page_s, ptr %2, i32 0, i32 0
  %3 = load i32, ptr %slice_count, align 8
  %conv = zext i32 %3 to i64
  %mul = mul i64 %conv, 65536
  store i64 %mul, ptr %psize, align 8
  store i64 0, ptr %start_offset, align 8
  %4 = load i64, ptr %xblock_size.addr, align 8
  %cmp = icmp uge i64 %4, 8
  br i1 %cmp, label %if.then, label %if.end10

if.then:                                          ; preds = %entry
  %5 = load i64, ptr %xblock_size.addr, align 8
  %cmp2 = icmp ule i64 %5, 64
  br i1 %cmp2, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.then
  %6 = load i64, ptr %xblock_size.addr, align 8
  %mul5 = mul i64 3, %6
  store i64 %mul5, ptr %start_offset, align 8
  br label %if.end9

if.else:                                          ; preds = %if.then
  %7 = load i64, ptr %xblock_size.addr, align 8
  %cmp6 = icmp ule i64 %7, 512
  br i1 %cmp6, label %if.then8, label %if.end

if.then8:                                         ; preds = %if.else
  %8 = load i64, ptr %xblock_size.addr, align 8
  store i64 %8, ptr %start_offset, align 8
  br label %if.end

if.end:                                           ; preds = %if.then8, %if.else
  br label %if.end9

if.end9:                                          ; preds = %if.end, %if.then4
  br label %if.end10

if.end10:                                         ; preds = %if.end9, %entry
  %9 = load ptr, ptr %page_size.addr, align 8
  %cmp11 = icmp ne ptr %9, null
  br i1 %cmp11, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end10
  %10 = load i64, ptr %psize, align 8
  %11 = load i64, ptr %start_offset, align 8
  %sub = sub i64 %10, %11
  %12 = load ptr, ptr %page_size.addr, align 8
  store i64 %sub, ptr %12, align 8
  br label %if.end14

if.end14:                                         ; preds = %if.then13, %if.end10
  %13 = load ptr, ptr %segment.addr, align 8
  %14 = load i64, ptr %idx, align 8
  %mul15 = mul i64 %14, 65536
  %15 = load i64, ptr %start_offset, align 8
  %add = add i64 %mul15, %15
  %add.ptr = getelementptr i8, ptr %13, i64 %add
  ret ptr %add.ptr
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_segment_thread_collect(ptr noundef %tld) #0 {
entry:
  %tld.addr = alloca ptr, align 8
  store ptr %tld, ptr %tld.addr, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal ptr @_mi_page_segment(ptr noundef %page) #0 {
entry:
  %page.addr = alloca ptr, align 8
  %segment = alloca ptr, align 8
  store ptr %page, ptr %page.addr, align 8
  %0 = load ptr, ptr %page.addr, align 8
  %call = call ptr @_mi_ptr_segment(ptr noundef %0)
  store ptr %call, ptr %segment, align 8
  %1 = load ptr, ptr %segment, align 8
  ret ptr %1
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_segment_page_clear(ptr noundef %page, ptr noundef %tld) #0 {
entry:
  %page.addr = alloca ptr, align 8
  %tld.addr = alloca ptr, align 8
  %segment = alloca ptr, align 8
  %inuse = alloca i64, align 8
  %psize = alloca i64, align 8
  %start = alloca ptr, align 8
  %ofs = alloca i64, align 8
  %slice = alloca ptr, align 8
  store ptr %page, ptr %page.addr, align 8
  store ptr %tld, ptr %tld.addr, align 8
  %0 = load ptr, ptr %page.addr, align 8
  %call = call ptr @_mi_ptr_segment(ptr noundef %0)
  store ptr %call, ptr %segment, align 8
  %1 = load ptr, ptr %page.addr, align 8
  %capacity = getelementptr inbounds %struct.mi_page_s, ptr %1, i32 0, i32 3
  %2 = load i16, ptr %capacity, align 2
  %conv = zext i16 %2 to i64
  %3 = load ptr, ptr %page.addr, align 8
  %call1 = call i64 @mi_page_block_size(ptr noundef %3)
  %mul = mul i64 %conv, %call1
  store i64 %mul, ptr %inuse, align 8
  %4 = load ptr, ptr %tld.addr, align 8
  %stats = getelementptr inbounds %struct.mi_segments_tld_s, ptr %4, i32 0, i32 5
  %5 = load ptr, ptr %stats, align 8
  %page_committed = getelementptr inbounds %struct.mi_stats_s, ptr %5, i32 0, i32 6
  %6 = load i64, ptr %inuse, align 8
  call void @_mi_stat_decrease(ptr noundef %page_committed, i64 noundef %6)
  %7 = load ptr, ptr %tld.addr, align 8
  %stats2 = getelementptr inbounds %struct.mi_segments_tld_s, ptr %7, i32 0, i32 5
  %8 = load ptr, ptr %stats2, align 8
  %pages = getelementptr inbounds %struct.mi_stats_s, ptr %8, i32 0, i32 1
  call void @_mi_stat_decrease(ptr noundef %pages, i64 noundef 1)
  %9 = load ptr, ptr %segment, align 8
  %allow_decommit = getelementptr inbounds %struct.mi_segment_s, ptr %9, i32 0, i32 1
  %10 = load i8, ptr %allow_decommit, align 8
  %tobool = trunc i8 %10 to i1
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %call4 = call zeroext i1 @mi_option_is_enabled(i32 noundef 11)
  br i1 %call4, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %11 = load ptr, ptr %segment, align 8
  %12 = load ptr, ptr %page.addr, align 8
  %call6 = call ptr @_mi_page_start(ptr noundef %11, ptr noundef %12, ptr noundef %psize)
  store ptr %call6, ptr %start, align 8
  %13 = load ptr, ptr %start, align 8
  %14 = load i64, ptr %psize, align 8
  %15 = load ptr, ptr %tld.addr, align 8
  %stats7 = getelementptr inbounds %struct.mi_segments_tld_s, ptr %15, i32 0, i32 5
  %16 = load ptr, ptr %stats7, align 8
  %call8 = call zeroext i1 @_mi_os_reset(ptr noundef %13, i64 noundef %14, ptr noundef %16)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %17 = load ptr, ptr %page.addr, align 8
  %is_zero_init = getelementptr inbounds %struct.mi_page_s, ptr %17, i32 0, i32 2
  %bf.load = load i8, ptr %is_zero_init, align 8
  %bf.clear = and i8 %bf.load, -3
  %bf.set = or i8 %bf.clear, 0
  store i8 %bf.set, ptr %is_zero_init, align 8
  store i64 10, ptr %ofs, align 8
  %18 = load ptr, ptr %page.addr, align 8
  %19 = load i64, ptr %ofs, align 8
  %add.ptr = getelementptr i8, ptr %18, i64 %19
  %20 = load i64, ptr %ofs, align 8
  %sub = sub i64 80, %20
  call void @_mi_memzero(ptr noundef %add.ptr, i64 noundef %sub)
  %21 = load ptr, ptr %page.addr, align 8
  %xblock_size = getelementptr inbounds %struct.mi_page_s, ptr %21, i32 0, i32 9
  store i32 1, ptr %xblock_size, align 4
  %22 = load ptr, ptr %page.addr, align 8
  %call9 = call ptr @mi_page_to_slice(ptr noundef %22)
  %23 = load ptr, ptr %tld.addr, align 8
  %call10 = call ptr @mi_segment_span_free_coalesce(ptr noundef %call9, ptr noundef %23)
  store ptr %call10, ptr %slice, align 8
  %24 = load ptr, ptr %segment, align 8
  %used = getelementptr inbounds %struct.mi_segment_s, ptr %24, i32 0, i32 11
  %25 = load i64, ptr %used, align 8
  %dec = add i64 %25, -1
  store i64 %dec, ptr %used, align 8
  %26 = load ptr, ptr %slice, align 8
  ret ptr %26
}

; Function Attrs: nounwind uwtable
define internal void @mi_segment_free(ptr noundef %segment, i1 noundef zeroext %force, ptr noundef %tld) #0 {
entry:
  %segment.addr = alloca ptr, align 8
  %force.addr = alloca i8, align 1
  %tld.addr = alloca ptr, align 8
  %slice = alloca ptr, align 8
  %end = alloca ptr, align 8
  store ptr %segment, ptr %segment.addr, align 8
  %frombool = zext i1 %force to i8
  store i8 %frombool, ptr %force.addr, align 1
  store ptr %tld, ptr %tld.addr, align 8
  %0 = load ptr, ptr %segment.addr, align 8
  %slices = getelementptr inbounds %struct.mi_segment_s, ptr %0, i32 0, i32 18
  %arrayidx = getelementptr [513 x %struct.mi_page_s], ptr %slices, i64 0, i64 0
  store ptr %arrayidx, ptr %slice, align 8
  %1 = load ptr, ptr %segment.addr, align 8
  %call = call ptr @mi_segment_slices_end(ptr noundef %1)
  store ptr %call, ptr %end, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %2 = load ptr, ptr %slice, align 8
  %3 = load ptr, ptr %end, align 8
  %cmp = icmp ult ptr %2, %3
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %4 = load ptr, ptr %slice, align 8
  %xblock_size = getelementptr inbounds %struct.mi_page_s, ptr %4, i32 0, i32 9
  %5 = load i32, ptr %xblock_size, align 4
  %cmp1 = icmp eq i32 %5, 0
  br i1 %cmp1, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %while.body
  %6 = load ptr, ptr %segment.addr, align 8
  %kind = getelementptr inbounds %struct.mi_segment_s, ptr %6, i32 0, i32 15
  %7 = load i32, ptr %kind, align 8
  %cmp2 = icmp ne i32 %7, 1
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %8 = load ptr, ptr %slice, align 8
  %9 = load ptr, ptr %tld.addr, align 8
  call void @mi_segment_span_remove_from_queue(ptr noundef %8, ptr noundef %9)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %while.body
  %10 = load ptr, ptr %slice, align 8
  %11 = load ptr, ptr %slice, align 8
  %slice_count = getelementptr inbounds %struct.mi_page_s, ptr %11, i32 0, i32 0
  %12 = load i32, ptr %slice_count, align 8
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr %struct.mi_page_s, ptr %10, i64 %idx.ext
  store ptr %add.ptr, ptr %slice, align 8
  br label %while.cond, !llvm.loop !75

while.end:                                        ; preds = %while.cond
  %13 = load ptr, ptr %tld.addr, align 8
  %stats = getelementptr inbounds %struct.mi_segments_tld_s, ptr %13, i32 0, i32 5
  %14 = load ptr, ptr %stats, align 8
  %page_committed = getelementptr inbounds %struct.mi_stats_s, ptr %14, i32 0, i32 6
  %15 = load ptr, ptr %segment.addr, align 8
  %call3 = call i64 @mi_segment_info_size(ptr noundef %15)
  call void @_mi_stat_decrease(ptr noundef %page_committed, i64 noundef %call3)
  %16 = load ptr, ptr %segment.addr, align 8
  %17 = load ptr, ptr %tld.addr, align 8
  call void @mi_segment_os_free(ptr noundef %16, ptr noundef %17)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_segment_abandon(ptr noundef %segment, ptr noundef %tld) #0 {
entry:
  %segment.addr = alloca ptr, align 8
  %tld.addr = alloca ptr, align 8
  %slice = alloca ptr, align 8
  %end = alloca ptr, align 8
  %.atomictmp = alloca ptr, align 8
  store ptr %segment, ptr %segment.addr, align 8
  store ptr %tld, ptr %tld.addr, align 8
  %0 = load ptr, ptr %segment.addr, align 8
  %slices = getelementptr inbounds %struct.mi_segment_s, ptr %0, i32 0, i32 18
  %arrayidx = getelementptr [513 x %struct.mi_page_s], ptr %slices, i64 0, i64 0
  store ptr %arrayidx, ptr %slice, align 8
  %1 = load ptr, ptr %segment.addr, align 8
  %call = call ptr @mi_segment_slices_end(ptr noundef %1)
  store ptr %call, ptr %end, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %2 = load ptr, ptr %slice, align 8
  %3 = load ptr, ptr %end, align 8
  %cmp = icmp ult ptr %2, %3
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %4 = load ptr, ptr %slice, align 8
  %xblock_size = getelementptr inbounds %struct.mi_page_s, ptr %4, i32 0, i32 9
  %5 = load i32, ptr %xblock_size, align 4
  %cmp1 = icmp eq i32 %5, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %6 = load ptr, ptr %slice, align 8
  %7 = load ptr, ptr %tld.addr, align 8
  call void @mi_segment_span_remove_from_queue(ptr noundef %6, ptr noundef %7)
  %8 = load ptr, ptr %slice, align 8
  %xblock_size2 = getelementptr inbounds %struct.mi_page_s, ptr %8, i32 0, i32 9
  store i32 0, ptr %xblock_size2, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  %9 = load ptr, ptr %slice, align 8
  %10 = load ptr, ptr %slice, align 8
  %slice_count = getelementptr inbounds %struct.mi_page_s, ptr %10, i32 0, i32 0
  %11 = load i32, ptr %slice_count, align 8
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr %struct.mi_page_s, ptr %9, i64 %idx.ext
  store ptr %add.ptr, ptr %slice, align 8
  br label %while.cond, !llvm.loop !76

while.end:                                        ; preds = %while.cond
  %12 = load ptr, ptr %segment.addr, align 8
  %call3 = call zeroext i1 @mi_option_is_enabled(i32 noundef 12)
  %13 = load ptr, ptr %tld.addr, align 8
  %stats = getelementptr inbounds %struct.mi_segments_tld_s, ptr %13, i32 0, i32 5
  %14 = load ptr, ptr %stats, align 8
  call void @mi_segment_try_purge(ptr noundef %12, i1 noundef zeroext %call3, ptr noundef %14)
  %15 = load ptr, ptr %tld.addr, align 8
  %stats4 = getelementptr inbounds %struct.mi_segments_tld_s, ptr %15, i32 0, i32 5
  %16 = load ptr, ptr %stats4, align 8
  %segments_abandoned = getelementptr inbounds %struct.mi_stats_s, ptr %16, i32 0, i32 7
  call void @_mi_stat_increase(ptr noundef %segments_abandoned, i64 noundef 1)
  %17 = load ptr, ptr %segment.addr, align 8
  %call5 = call i64 @mi_segment_size(ptr noundef %17)
  %sub = sub i64 0, %call5
  %18 = load ptr, ptr %tld.addr, align 8
  call void @mi_segments_track_size(i64 noundef %sub, ptr noundef %18)
  %19 = load ptr, ptr %segment.addr, align 8
  %thread_id = getelementptr inbounds %struct.mi_segment_s, ptr %19, i32 0, i32 17
  store atomic i64 0, ptr %thread_id seq_cst, align 8
  %20 = load ptr, ptr %segment.addr, align 8
  %abandoned_next = getelementptr inbounds %struct.mi_segment_s, ptr %20, i32 0, i32 7
  store ptr null, ptr %.atomictmp, align 8
  %21 = load i64, ptr %.atomictmp, align 8
  store atomic i64 %21, ptr %abandoned_next release, align 8
  %22 = load ptr, ptr %segment.addr, align 8
  %abandoned_visits = getelementptr inbounds %struct.mi_segment_s, ptr %22, i32 0, i32 10
  store i64 1, ptr %abandoned_visits, align 8
  %23 = load ptr, ptr %segment.addr, align 8
  call void @mi_abandoned_push(ptr noundef %23)
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_abandoned_await_readers() #0 {
entry:
  %n = alloca i64, align 8
  %atomic-temp = alloca i64, align 8
  br label %do.body

do.body:                                          ; preds = %do.cond, %entry
  %0 = load atomic i64, ptr @abandoned_readers acquire, align 64
  store i64 %0, ptr %atomic-temp, align 8
  %1 = load i64, ptr %atomic-temp, align 8
  store i64 %1, ptr %n, align 8
  %2 = load i64, ptr %n, align 8
  %cmp = icmp ne i64 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  call void @mi_atomic_yield()
  br label %if.end

if.end:                                           ; preds = %if.then, %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  %3 = load i64, ptr %n, align 8
  %cmp1 = icmp ne i64 %3, 0
  br i1 %cmp1, label %do.body, label %do.end, !llvm.loop !77

do.end:                                           ; preds = %do.cond
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_abandoned_reclaim_all(ptr noundef %heap, ptr noundef %tld) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %tld.addr = alloca ptr, align 8
  %segment = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store ptr %tld, ptr %tld.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %call = call ptr @mi_abandoned_pop()
  store ptr %call, ptr %segment, align 8
  %cmp = icmp ne ptr %call, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %0 = load ptr, ptr %segment, align 8
  %1 = load ptr, ptr %heap.addr, align 8
  %2 = load ptr, ptr %tld.addr, align 8
  %call1 = call ptr @mi_segment_reclaim(ptr noundef %0, ptr noundef %1, i64 noundef 0, ptr noundef null, ptr noundef %2)
  br label %while.cond, !llvm.loop !78

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_abandoned_pop() #0 {
entry:
  %retval = alloca ptr, align 8
  %segment = alloca ptr, align 8
  %ts = alloca i64, align 8
  %atomic-temp = alloca i64, align 8
  %.atomictmp = alloca i64, align 8
  %atomic-temp13 = alloca i64, align 8
  %next = alloca i64, align 8
  %atomic-temp14 = alloca i64, align 8
  %anext = alloca ptr, align 8
  %atomic-temp19 = alloca ptr, align 8
  %.atomictmp24 = alloca i64, align 8
  %cmpxchg.bool = alloca i8, align 1
  %.atomictmp28 = alloca i64, align 8
  %atomic-temp29 = alloca i64, align 8
  %.atomictmp34 = alloca ptr, align 8
  %.atomictmp35 = alloca i64, align 8
  %atomic-temp36 = alloca i64, align 8
  %0 = load atomic i64, ptr @abandoned monotonic, align 64
  store i64 %0, ptr %atomic-temp, align 8
  %1 = load i64, ptr %atomic-temp, align 8
  store i64 %1, ptr %ts, align 8
  %2 = load i64, ptr %ts, align 8
  %call = call ptr @mi_tagged_segment_ptr(i64 noundef %2)
  store ptr %call, ptr %segment, align 8
  %3 = load ptr, ptr %segment, align 8
  %cmp = icmp eq ptr %3, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %if.then, label %if.end12

if.then:                                          ; preds = %entry
  %call2 = call zeroext i1 @mi_abandoned_visited_revisit()
  %lnot3 = xor i1 %call2, true
  %lnot5 = xor i1 %lnot3, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv9 = sext i32 %lnot.ext8 to i64
  %tobool10 = icmp ne i64 %conv9, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %if.then
  br label %if.end12

if.end12:                                         ; preds = %if.end, %entry
  store i64 1, ptr %.atomictmp, align 8
  %4 = load i64, ptr %.atomictmp, align 8
  %5 = atomicrmw add ptr @abandoned_readers, i64 %4 monotonic, align 64
  store i64 %5, ptr %atomic-temp13, align 8
  store i64 0, ptr %next, align 8
  %6 = load atomic i64, ptr @abandoned acquire, align 64
  store i64 %6, ptr %atomic-temp14, align 8
  %7 = load i64, ptr %atomic-temp14, align 8
  store i64 %7, ptr %ts, align 8
  br label %do.body

do.body:                                          ; preds = %land.end, %if.end12
  %8 = load i64, ptr %ts, align 8
  %call15 = call ptr @mi_tagged_segment_ptr(i64 noundef %8)
  store ptr %call15, ptr %segment, align 8
  %9 = load ptr, ptr %segment, align 8
  %cmp16 = icmp ne ptr %9, null
  br i1 %cmp16, label %if.then18, label %if.end21

if.then18:                                        ; preds = %do.body
  %10 = load ptr, ptr %segment, align 8
  %abandoned_next = getelementptr inbounds %struct.mi_segment_s, ptr %10, i32 0, i32 7
  %11 = load atomic i64, ptr %abandoned_next monotonic, align 8
  store i64 %11, ptr %atomic-temp19, align 8
  %12 = load ptr, ptr %atomic-temp19, align 8
  store ptr %12, ptr %anext, align 8
  %13 = load ptr, ptr %anext, align 8
  %14 = load i64, ptr %ts, align 8
  %call20 = call i64 @mi_tagged_segment(ptr noundef %13, i64 noundef %14)
  store i64 %call20, ptr %next, align 8
  br label %if.end21

if.end21:                                         ; preds = %if.then18, %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end21
  %15 = load ptr, ptr %segment, align 8
  %cmp22 = icmp ne ptr %15, null
  br i1 %cmp22, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %do.cond
  %16 = load i64, ptr %next, align 8
  store i64 %16, ptr %.atomictmp24, align 8
  %17 = load i64, ptr %ts, align 8
  %18 = load i64, ptr %.atomictmp24, align 8
  %19 = cmpxchg weak ptr @abandoned, i64 %17, i64 %18 acq_rel acquire, align 64
  %20 = extractvalue { i64, i1 } %19, 0
  %21 = extractvalue { i64, i1 } %19, 1
  br i1 %21, label %cmpxchg.continue, label %cmpxchg.store_expected

cmpxchg.store_expected:                           ; preds = %land.rhs
  store i64 %20, ptr %ts, align 8
  br label %cmpxchg.continue

cmpxchg.continue:                                 ; preds = %cmpxchg.store_expected, %land.rhs
  %frombool = zext i1 %21 to i8
  store i8 %frombool, ptr %cmpxchg.bool, align 1
  %22 = load i8, ptr %cmpxchg.bool, align 1
  %tobool25 = trunc i8 %22 to i1
  %lnot26 = xor i1 %tobool25, true
  br label %land.end

land.end:                                         ; preds = %cmpxchg.continue, %do.cond
  %23 = phi i1 [ false, %do.cond ], [ %lnot26, %cmpxchg.continue ]
  br i1 %23, label %do.body, label %do.end, !llvm.loop !79

do.end:                                           ; preds = %land.end
  store i64 1, ptr %.atomictmp28, align 8
  %24 = load i64, ptr %.atomictmp28, align 8
  %25 = atomicrmw sub ptr @abandoned_readers, i64 %24 monotonic, align 64
  store i64 %25, ptr %atomic-temp29, align 8
  %26 = load ptr, ptr %segment, align 8
  %cmp30 = icmp ne ptr %26, null
  br i1 %cmp30, label %if.then32, label %if.end37

if.then32:                                        ; preds = %do.end
  %27 = load ptr, ptr %segment, align 8
  %abandoned_next33 = getelementptr inbounds %struct.mi_segment_s, ptr %27, i32 0, i32 7
  store ptr null, ptr %.atomictmp34, align 8
  %28 = load i64, ptr %.atomictmp34, align 8
  store atomic i64 %28, ptr %abandoned_next33 release, align 8
  store i64 1, ptr %.atomictmp35, align 8
  %29 = load i64, ptr %.atomictmp35, align 8
  %30 = atomicrmw sub ptr @abandoned_count, i64 %29 monotonic, align 64
  store i64 %30, ptr %atomic-temp36, align 8
  br label %if.end37

if.end37:                                         ; preds = %if.then32, %do.end
  %31 = load ptr, ptr %segment, align 8
  store ptr %31, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end37, %if.then11
  %32 = load ptr, ptr %retval, align 8
  ret ptr %32
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_segment_reclaim(ptr noundef %segment, ptr noundef %heap, i64 noundef %requested_block_size, ptr noundef %right_page_reclaimed, ptr noundef %tld) #0 {
entry:
  %retval = alloca ptr, align 8
  %segment.addr = alloca ptr, align 8
  %heap.addr = alloca ptr, align 8
  %requested_block_size.addr = alloca i64, align 8
  %right_page_reclaimed.addr = alloca ptr, align 8
  %tld.addr = alloca ptr, align 8
  %end = alloca ptr, align 8
  %slice = alloca ptr, align 8
  %page = alloca ptr, align 8
  store ptr %segment, ptr %segment.addr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store i64 %requested_block_size, ptr %requested_block_size.addr, align 8
  store ptr %right_page_reclaimed, ptr %right_page_reclaimed.addr, align 8
  store ptr %tld, ptr %tld.addr, align 8
  %0 = load ptr, ptr %right_page_reclaimed.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %right_page_reclaimed.addr, align 8
  store i8 0, ptr %1, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %call = call i64 @_mi_thread_id()
  %2 = load ptr, ptr %segment.addr, align 8
  %thread_id = getelementptr inbounds %struct.mi_segment_s, ptr %2, i32 0, i32 17
  store atomic i64 %call, ptr %thread_id seq_cst, align 8
  %3 = load ptr, ptr %segment.addr, align 8
  %abandoned_visits = getelementptr inbounds %struct.mi_segment_s, ptr %3, i32 0, i32 10
  store i64 0, ptr %abandoned_visits, align 8
  %4 = load ptr, ptr %segment.addr, align 8
  %call1 = call i64 @mi_segment_size(ptr noundef %4)
  %5 = load ptr, ptr %tld.addr, align 8
  call void @mi_segments_track_size(i64 noundef %call1, ptr noundef %5)
  %6 = load ptr, ptr %tld.addr, align 8
  %stats = getelementptr inbounds %struct.mi_segments_tld_s, ptr %6, i32 0, i32 5
  %7 = load ptr, ptr %stats, align 8
  %segments_abandoned = getelementptr inbounds %struct.mi_stats_s, ptr %7, i32 0, i32 7
  call void @_mi_stat_decrease(ptr noundef %segments_abandoned, i64 noundef 1)
  %8 = load ptr, ptr %segment.addr, align 8
  %call2 = call ptr @mi_slices_start_iterate(ptr noundef %8, ptr noundef %end)
  store ptr %call2, ptr %slice, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end24, %if.end
  %9 = load ptr, ptr %slice, align 8
  %10 = load ptr, ptr %end, align 8
  %cmp3 = icmp ult ptr %9, %10
  br i1 %cmp3, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %11 = load ptr, ptr %slice, align 8
  %call4 = call zeroext i1 @mi_slice_is_used(ptr noundef %11)
  br i1 %call4, label %if.then5, label %if.else22

if.then5:                                         ; preds = %while.body
  %12 = load ptr, ptr %slice, align 8
  %call6 = call ptr @mi_slice_to_page(ptr noundef %12)
  store ptr %call6, ptr %page, align 8
  %13 = load ptr, ptr %tld.addr, align 8
  %stats7 = getelementptr inbounds %struct.mi_segments_tld_s, ptr %13, i32 0, i32 5
  %14 = load ptr, ptr %stats7, align 8
  %pages_abandoned = getelementptr inbounds %struct.mi_stats_s, ptr %14, i32 0, i32 8
  call void @_mi_stat_decrease(ptr noundef %pages_abandoned, i64 noundef 1)
  %15 = load ptr, ptr %segment.addr, align 8
  %abandoned = getelementptr inbounds %struct.mi_segment_s, ptr %15, i32 0, i32 9
  %16 = load i64, ptr %abandoned, align 8
  %dec = add i64 %16, -1
  store i64 %dec, ptr %abandoned, align 8
  %17 = load ptr, ptr %page, align 8
  %18 = load ptr, ptr %heap.addr, align 8
  call void @mi_page_set_heap(ptr noundef %17, ptr noundef %18)
  %19 = load ptr, ptr %page, align 8
  call void @_mi_page_use_delayed_free(ptr noundef %19, i32 noundef 0, i1 noundef zeroext true)
  %20 = load ptr, ptr %page, align 8
  call void @_mi_page_free_collect(ptr noundef %20, i1 noundef zeroext false)
  %21 = load ptr, ptr %page, align 8
  %call8 = call zeroext i1 @mi_page_all_free(ptr noundef %21)
  br i1 %call8, label %if.then9, label %if.else

if.then9:                                         ; preds = %if.then5
  %22 = load ptr, ptr %page, align 8
  %23 = load ptr, ptr %tld.addr, align 8
  %call10 = call ptr @mi_segment_page_clear(ptr noundef %22, ptr noundef %23)
  store ptr %call10, ptr %slice, align 8
  br label %if.end21

if.else:                                          ; preds = %if.then5
  %24 = load ptr, ptr %heap.addr, align 8
  %25 = load ptr, ptr %page, align 8
  call void @_mi_page_reclaim(ptr noundef %24, ptr noundef %25)
  %26 = load i64, ptr %requested_block_size.addr, align 8
  %27 = load ptr, ptr %page, align 8
  %xblock_size = getelementptr inbounds %struct.mi_page_s, ptr %27, i32 0, i32 9
  %28 = load i32, ptr %xblock_size, align 4
  %conv = zext i32 %28 to i64
  %cmp11 = icmp eq i64 %26, %conv
  br i1 %cmp11, label %land.lhs.true, label %if.end20

land.lhs.true:                                    ; preds = %if.else
  %29 = load ptr, ptr %page, align 8
  %call13 = call zeroext i1 @mi_page_has_any_available(ptr noundef %29)
  br i1 %call13, label %if.then15, label %if.end20

if.then15:                                        ; preds = %land.lhs.true
  %30 = load ptr, ptr %right_page_reclaimed.addr, align 8
  %cmp16 = icmp ne ptr %30, null
  br i1 %cmp16, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.then15
  %31 = load ptr, ptr %right_page_reclaimed.addr, align 8
  store i8 1, ptr %31, align 1
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.then15
  br label %if.end20

if.end20:                                         ; preds = %if.end19, %land.lhs.true, %if.else
  br label %if.end21

if.end21:                                         ; preds = %if.end20, %if.then9
  br label %if.end24

if.else22:                                        ; preds = %while.body
  %32 = load ptr, ptr %slice, align 8
  %33 = load ptr, ptr %tld.addr, align 8
  %call23 = call ptr @mi_segment_span_free_coalesce(ptr noundef %32, ptr noundef %33)
  store ptr %call23, ptr %slice, align 8
  br label %if.end24

if.end24:                                         ; preds = %if.else22, %if.end21
  %34 = load ptr, ptr %slice, align 8
  %35 = load ptr, ptr %slice, align 8
  %slice_count = getelementptr inbounds %struct.mi_page_s, ptr %35, i32 0, i32 0
  %36 = load i32, ptr %slice_count, align 8
  %idx.ext = zext i32 %36 to i64
  %add.ptr = getelementptr %struct.mi_page_s, ptr %34, i64 %idx.ext
  store ptr %add.ptr, ptr %slice, align 8
  br label %while.cond, !llvm.loop !80

while.end:                                        ; preds = %while.cond
  %37 = load ptr, ptr %segment.addr, align 8
  %used = getelementptr inbounds %struct.mi_segment_s, ptr %37, i32 0, i32 11
  %38 = load i64, ptr %used, align 8
  %cmp25 = icmp eq i64 %38, 0
  br i1 %cmp25, label %if.then27, label %if.else28

if.then27:                                        ; preds = %while.end
  %39 = load ptr, ptr %segment.addr, align 8
  %40 = load ptr, ptr %tld.addr, align 8
  call void @mi_segment_free(ptr noundef %39, i1 noundef zeroext false, ptr noundef %40)
  store ptr null, ptr %retval, align 8
  br label %return

if.else28:                                        ; preds = %while.end
  %41 = load ptr, ptr %segment.addr, align 8
  store ptr %41, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else28, %if.then27
  %42 = load ptr, ptr %retval, align 8
  ret ptr %42
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_abandoned_collect(ptr noundef %heap, i1 noundef zeroext %force, ptr noundef %tld) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %force.addr = alloca i8, align 1
  %tld.addr = alloca ptr, align 8
  %segment = alloca ptr, align 8
  %max_tries = alloca i32, align 4
  store ptr %heap, ptr %heap.addr, align 8
  %frombool = zext i1 %force to i8
  store i8 %frombool, ptr %force.addr, align 1
  store ptr %tld, ptr %tld.addr, align 8
  %0 = load i8, ptr %force.addr, align 1
  %tobool = trunc i8 %0 to i1
  %cond = select i1 %tobool, i32 16384, i32 1024
  store i32 %cond, ptr %max_tries, align 4
  %1 = load i8, ptr %force.addr, align 1
  %tobool1 = trunc i8 %1 to i1
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call zeroext i1 @mi_abandoned_visited_revisit()
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  br label %while.cond

while.cond:                                       ; preds = %if.end9, %if.end
  %2 = load i32, ptr %max_tries, align 4
  %dec = add i32 %2, -1
  store i32 %dec, ptr %max_tries, align 4
  %cmp = icmp sgt i32 %2, 0
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %call2 = call ptr @mi_abandoned_pop()
  store ptr %call2, ptr %segment, align 8
  %cmp3 = icmp ne ptr %call2, null
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %3 = phi i1 [ false, %while.cond ], [ %cmp3, %land.rhs ]
  br i1 %3, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %4 = load ptr, ptr %segment, align 8
  %5 = load ptr, ptr %tld.addr, align 8
  %call4 = call zeroext i1 @mi_segment_check_free(ptr noundef %4, i64 noundef 0, i64 noundef 0, ptr noundef %5)
  %6 = load ptr, ptr %segment, align 8
  %used = getelementptr inbounds %struct.mi_segment_s, ptr %6, i32 0, i32 11
  %7 = load i64, ptr %used, align 8
  %cmp5 = icmp eq i64 %7, 0
  br i1 %cmp5, label %if.then6, label %if.else

if.then6:                                         ; preds = %while.body
  %8 = load ptr, ptr %segment, align 8
  %9 = load ptr, ptr %heap.addr, align 8
  %10 = load ptr, ptr %tld.addr, align 8
  %call7 = call ptr @mi_segment_reclaim(ptr noundef %8, ptr noundef %9, i64 noundef 0, ptr noundef null, ptr noundef %10)
  br label %if.end9

if.else:                                          ; preds = %while.body
  %11 = load ptr, ptr %segment, align 8
  %12 = load i8, ptr %force.addr, align 1
  %tobool8 = trunc i8 %12 to i1
  %13 = load ptr, ptr %tld.addr, align 8
  %stats = getelementptr inbounds %struct.mi_segments_tld_s, ptr %13, i32 0, i32 5
  %14 = load ptr, ptr %stats, align 8
  call void @mi_segment_try_purge(ptr noundef %11, i1 noundef zeroext %tobool8, ptr noundef %14)
  %15 = load ptr, ptr %segment, align 8
  call void @mi_abandoned_visited_push(ptr noundef %15)
  br label %if.end9

if.end9:                                          ; preds = %if.else, %if.then6
  br label %while.cond, !llvm.loop !81

while.end:                                        ; preds = %land.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_abandoned_visited_revisit() #0 {
entry:
  %retval = alloca i1, align 1
  %atomic-temp = alloca ptr, align 8
  %first = alloca ptr, align 8
  %.atomictmp = alloca ptr, align 8
  %atomic-temp1 = alloca ptr, align 8
  %afirst = alloca i64, align 8
  %ts = alloca i64, align 8
  %atomic-temp5 = alloca i64, align 8
  %count = alloca i64, align 8
  %atomic-temp8 = alloca i64, align 8
  %.atomictmp10 = alloca i64, align 8
  %cmpxchg.bool = alloca i8, align 1
  %.atomictmp12 = alloca i64, align 8
  %atomic-temp13 = alloca i64, align 8
  %.atomictmp14 = alloca i64, align 8
  %atomic-temp15 = alloca i64, align 8
  %last = alloca ptr, align 8
  %next = alloca ptr, align 8
  %atomic-temp18 = alloca ptr, align 8
  %anext = alloca i64, align 8
  %atomic-temp20 = alloca i64, align 8
  %count21 = alloca i64, align 8
  %atomic-temp22 = alloca i64, align 8
  %.atomictmp24 = alloca ptr, align 8
  %.atomictmp27 = alloca i64, align 8
  %cmpxchg.bool28 = alloca i8, align 1
  %.atomictmp33 = alloca i64, align 8
  %atomic-temp34 = alloca i64, align 8
  %.atomictmp35 = alloca i64, align 8
  %atomic-temp36 = alloca i64, align 8
  %0 = load atomic i64, ptr @abandoned_visited monotonic, align 64
  store i64 %0, ptr %atomic-temp, align 8
  %1 = load ptr, ptr %atomic-temp, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  store ptr null, ptr %.atomictmp, align 8
  %2 = load i64, ptr %.atomictmp, align 8
  %3 = atomicrmw xchg ptr @abandoned_visited, i64 %2 acq_rel, align 64
  store i64 %3, ptr %atomic-temp1, align 8
  %4 = load ptr, ptr %atomic-temp1, align 8
  store ptr %4, ptr %first, align 8
  %5 = load ptr, ptr %first, align 8
  %cmp2 = icmp eq ptr %5, null
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store i1 false, ptr %retval, align 1
  br label %return

if.end4:                                          ; preds = %if.end
  %6 = load atomic i64, ptr @abandoned monotonic, align 64
  store i64 %6, ptr %atomic-temp5, align 8
  %7 = load i64, ptr %atomic-temp5, align 8
  store i64 %7, ptr %ts, align 8
  %8 = load i64, ptr %ts, align 8
  %call = call ptr @mi_tagged_segment_ptr(i64 noundef %8)
  %cmp6 = icmp eq ptr %call, null
  br i1 %cmp6, label %if.then7, label %if.end17

if.then7:                                         ; preds = %if.end4
  %9 = load atomic i64, ptr @abandoned_visited_count monotonic, align 64
  store i64 %9, ptr %atomic-temp8, align 8
  %10 = load i64, ptr %atomic-temp8, align 8
  store i64 %10, ptr %count, align 8
  %11 = load ptr, ptr %first, align 8
  %12 = load i64, ptr %ts, align 8
  %call9 = call i64 @mi_tagged_segment(ptr noundef %11, i64 noundef %12)
  store i64 %call9, ptr %afirst, align 8
  %13 = load i64, ptr %afirst, align 8
  store i64 %13, ptr %.atomictmp10, align 8
  %14 = load i64, ptr %ts, align 8
  %15 = load i64, ptr %.atomictmp10, align 8
  %16 = cmpxchg ptr @abandoned, i64 %14, i64 %15 acq_rel acquire, align 64
  %17 = extractvalue { i64, i1 } %16, 0
  %18 = extractvalue { i64, i1 } %16, 1
  br i1 %18, label %cmpxchg.continue, label %cmpxchg.store_expected

cmpxchg.store_expected:                           ; preds = %if.then7
  store i64 %17, ptr %ts, align 8
  br label %cmpxchg.continue

cmpxchg.continue:                                 ; preds = %cmpxchg.store_expected, %if.then7
  %frombool = zext i1 %18 to i8
  store i8 %frombool, ptr %cmpxchg.bool, align 1
  %19 = load i8, ptr %cmpxchg.bool, align 1
  %tobool = trunc i8 %19 to i1
  br i1 %tobool, label %if.then11, label %if.end16

if.then11:                                        ; preds = %cmpxchg.continue
  %20 = load i64, ptr %count, align 8
  store i64 %20, ptr %.atomictmp12, align 8
  %21 = load i64, ptr %.atomictmp12, align 8
  %22 = atomicrmw add ptr @abandoned_count, i64 %21 monotonic, align 64
  store i64 %22, ptr %atomic-temp13, align 8
  %23 = load i64, ptr %count, align 8
  store i64 %23, ptr %.atomictmp14, align 8
  %24 = load i64, ptr %.atomictmp14, align 8
  %25 = atomicrmw sub ptr @abandoned_visited_count, i64 %24 monotonic, align 64
  store i64 %25, ptr %atomic-temp15, align 8
  store i1 true, ptr %retval, align 1
  br label %return

if.end16:                                         ; preds = %cmpxchg.continue
  br label %if.end17

if.end17:                                         ; preds = %if.end16, %if.end4
  %26 = load ptr, ptr %first, align 8
  store ptr %26, ptr %last, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end17
  %27 = load ptr, ptr %last, align 8
  %abandoned_next = getelementptr inbounds %struct.mi_segment_s, ptr %27, i32 0, i32 7
  %28 = load atomic i64, ptr %abandoned_next monotonic, align 8
  store i64 %28, ptr %atomic-temp18, align 8
  %29 = load ptr, ptr %atomic-temp18, align 8
  store ptr %29, ptr %next, align 8
  %cmp19 = icmp ne ptr %29, null
  br i1 %cmp19, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %30 = load ptr, ptr %next, align 8
  store ptr %30, ptr %last, align 8
  br label %while.cond, !llvm.loop !82

while.end:                                        ; preds = %while.cond
  %31 = load atomic i64, ptr @abandoned monotonic, align 64
  store i64 %31, ptr %atomic-temp20, align 8
  %32 = load i64, ptr %atomic-temp20, align 8
  store i64 %32, ptr %anext, align 8
  br label %do.body

do.body:                                          ; preds = %cmpxchg.continue30, %while.end
  %33 = load atomic i64, ptr @abandoned_visited_count monotonic, align 64
  store i64 %33, ptr %atomic-temp22, align 8
  %34 = load i64, ptr %atomic-temp22, align 8
  store i64 %34, ptr %count21, align 8
  %35 = load ptr, ptr %last, align 8
  %abandoned_next23 = getelementptr inbounds %struct.mi_segment_s, ptr %35, i32 0, i32 7
  %36 = load i64, ptr %anext, align 8
  %call25 = call ptr @mi_tagged_segment_ptr(i64 noundef %36)
  store ptr %call25, ptr %.atomictmp24, align 8
  %37 = load i64, ptr %.atomictmp24, align 8
  store atomic i64 %37, ptr %abandoned_next23 release, align 8
  %38 = load ptr, ptr %first, align 8
  %39 = load i64, ptr %anext, align 8
  %call26 = call i64 @mi_tagged_segment(ptr noundef %38, i64 noundef %39)
  store i64 %call26, ptr %afirst, align 8
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %40 = load i64, ptr %afirst, align 8
  store i64 %40, ptr %.atomictmp27, align 8
  %41 = load i64, ptr %anext, align 8
  %42 = load i64, ptr %.atomictmp27, align 8
  %43 = cmpxchg weak ptr @abandoned, i64 %41, i64 %42 release monotonic, align 64
  %44 = extractvalue { i64, i1 } %43, 0
  %45 = extractvalue { i64, i1 } %43, 1
  br i1 %45, label %cmpxchg.continue30, label %cmpxchg.store_expected29

cmpxchg.store_expected29:                         ; preds = %do.cond
  store i64 %44, ptr %anext, align 8
  br label %cmpxchg.continue30

cmpxchg.continue30:                               ; preds = %cmpxchg.store_expected29, %do.cond
  %frombool31 = zext i1 %45 to i8
  store i8 %frombool31, ptr %cmpxchg.bool28, align 1
  %46 = load i8, ptr %cmpxchg.bool28, align 1
  %tobool32 = trunc i8 %46 to i1
  %lnot = xor i1 %tobool32, true
  br i1 %lnot, label %do.body, label %do.end, !llvm.loop !83

do.end:                                           ; preds = %cmpxchg.continue30
  %47 = load i64, ptr %count21, align 8
  store i64 %47, ptr %.atomictmp33, align 8
  %48 = load i64, ptr %.atomictmp33, align 8
  %49 = atomicrmw add ptr @abandoned_count, i64 %48 monotonic, align 64
  store i64 %49, ptr %atomic-temp34, align 8
  %50 = load i64, ptr %count21, align 8
  store i64 %50, ptr %.atomictmp35, align 8
  %51 = load i64, ptr %.atomictmp35, align 8
  %52 = atomicrmw sub ptr @abandoned_visited_count, i64 %51 monotonic, align 64
  store i64 %52, ptr %atomic-temp36, align 8
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %do.end, %if.then11, %if.then3, %if.then
  %53 = load i1, ptr %retval, align 1
  ret i1 %53
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_segment_check_free(ptr noundef %segment, i64 noundef %slices_needed, i64 noundef %block_size, ptr noundef %tld) #0 {
entry:
  %segment.addr = alloca ptr, align 8
  %slices_needed.addr = alloca i64, align 8
  %block_size.addr = alloca i64, align 8
  %tld.addr = alloca ptr, align 8
  %has_page = alloca i8, align 1
  %end = alloca ptr, align 8
  %slice = alloca ptr, align 8
  %page = alloca ptr, align 8
  store ptr %segment, ptr %segment.addr, align 8
  store i64 %slices_needed, ptr %slices_needed.addr, align 8
  store i64 %block_size, ptr %block_size.addr, align 8
  store ptr %tld, ptr %tld.addr, align 8
  store i8 0, ptr %has_page, align 1
  %0 = load ptr, ptr %segment.addr, align 8
  %call = call ptr @mi_slices_start_iterate(ptr noundef %0, ptr noundef %end)
  store ptr %call, ptr %slice, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end24, %entry
  %1 = load ptr, ptr %slice, align 8
  %2 = load ptr, ptr %end, align 8
  %cmp = icmp ult ptr %1, %2
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load ptr, ptr %slice, align 8
  %call1 = call zeroext i1 @mi_slice_is_used(ptr noundef %3)
  br i1 %call1, label %if.then, label %if.else17

if.then:                                          ; preds = %while.body
  %4 = load ptr, ptr %slice, align 8
  %call2 = call ptr @mi_slice_to_page(ptr noundef %4)
  store ptr %call2, ptr %page, align 8
  %5 = load ptr, ptr %page, align 8
  call void @_mi_page_free_collect(ptr noundef %5, i1 noundef zeroext false)
  %6 = load ptr, ptr %page, align 8
  %call3 = call zeroext i1 @mi_page_all_free(ptr noundef %6)
  br i1 %call3, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.then
  %7 = load ptr, ptr %tld.addr, align 8
  %stats = getelementptr inbounds %struct.mi_segments_tld_s, ptr %7, i32 0, i32 5
  %8 = load ptr, ptr %stats, align 8
  %pages_abandoned = getelementptr inbounds %struct.mi_stats_s, ptr %8, i32 0, i32 8
  call void @_mi_stat_decrease(ptr noundef %pages_abandoned, i64 noundef 1)
  %9 = load ptr, ptr %segment.addr, align 8
  %abandoned = getelementptr inbounds %struct.mi_segment_s, ptr %9, i32 0, i32 9
  %10 = load i64, ptr %abandoned, align 8
  %dec = add i64 %10, -1
  store i64 %dec, ptr %abandoned, align 8
  %11 = load ptr, ptr %page, align 8
  %12 = load ptr, ptr %tld.addr, align 8
  %call5 = call ptr @mi_segment_page_clear(ptr noundef %11, ptr noundef %12)
  store ptr %call5, ptr %slice, align 8
  %13 = load ptr, ptr %slice, align 8
  %slice_count = getelementptr inbounds %struct.mi_page_s, ptr %13, i32 0, i32 0
  %14 = load i32, ptr %slice_count, align 8
  %conv = zext i32 %14 to i64
  %15 = load i64, ptr %slices_needed.addr, align 8
  %cmp6 = icmp uge i64 %conv, %15
  br i1 %cmp6, label %if.then8, label %if.end

if.then8:                                         ; preds = %if.then4
  store i8 1, ptr %has_page, align 1
  br label %if.end

if.end:                                           ; preds = %if.then8, %if.then4
  br label %if.end16

if.else:                                          ; preds = %if.then
  %16 = load ptr, ptr %page, align 8
  %xblock_size = getelementptr inbounds %struct.mi_page_s, ptr %16, i32 0, i32 9
  %17 = load i32, ptr %xblock_size, align 4
  %conv9 = zext i32 %17 to i64
  %18 = load i64, ptr %block_size.addr, align 8
  %cmp10 = icmp eq i64 %conv9, %18
  br i1 %cmp10, label %land.lhs.true, label %if.end15

land.lhs.true:                                    ; preds = %if.else
  %19 = load ptr, ptr %page, align 8
  %call12 = call zeroext i1 @mi_page_has_any_available(ptr noundef %19)
  br i1 %call12, label %if.then14, label %if.end15

if.then14:                                        ; preds = %land.lhs.true
  store i8 1, ptr %has_page, align 1
  br label %if.end15

if.end15:                                         ; preds = %if.then14, %land.lhs.true, %if.else
  br label %if.end16

if.end16:                                         ; preds = %if.end15, %if.end
  br label %if.end24

if.else17:                                        ; preds = %while.body
  %20 = load ptr, ptr %slice, align 8
  %slice_count18 = getelementptr inbounds %struct.mi_page_s, ptr %20, i32 0, i32 0
  %21 = load i32, ptr %slice_count18, align 8
  %conv19 = zext i32 %21 to i64
  %22 = load i64, ptr %slices_needed.addr, align 8
  %cmp20 = icmp uge i64 %conv19, %22
  br i1 %cmp20, label %if.then22, label %if.end23

if.then22:                                        ; preds = %if.else17
  store i8 1, ptr %has_page, align 1
  br label %if.end23

if.end23:                                         ; preds = %if.then22, %if.else17
  br label %if.end24

if.end24:                                         ; preds = %if.end23, %if.end16
  %23 = load ptr, ptr %slice, align 8
  %24 = load ptr, ptr %slice, align 8
  %slice_count25 = getelementptr inbounds %struct.mi_page_s, ptr %24, i32 0, i32 0
  %25 = load i32, ptr %slice_count25, align 8
  %idx.ext = zext i32 %25 to i64
  %add.ptr = getelementptr %struct.mi_page_s, ptr %23, i64 %idx.ext
  store ptr %add.ptr, ptr %slice, align 8
  br label %while.cond, !llvm.loop !84

while.end:                                        ; preds = %while.cond
  %26 = load i8, ptr %has_page, align 1
  %tobool = trunc i8 %26 to i1
  ret i1 %tobool
}

; Function Attrs: nounwind uwtable
define internal void @mi_segment_try_purge(ptr noundef %segment, i1 noundef zeroext %force, ptr noundef %stats) #0 {
entry:
  %segment.addr = alloca ptr, align 8
  %force.addr = alloca i8, align 1
  %stats.addr = alloca ptr, align 8
  %now = alloca i64, align 8
  %mask = alloca %struct.mi_commit_mask_s, align 8
  %idx = alloca i64, align 8
  %count = alloca i64, align 8
  %p = alloca ptr, align 8
  %size = alloca i64, align 8
  store ptr %segment, ptr %segment.addr, align 8
  %frombool = zext i1 %force to i8
  store i8 %frombool, ptr %force.addr, align 1
  store ptr %stats, ptr %stats.addr, align 8
  %0 = load ptr, ptr %segment.addr, align 8
  %allow_purge = getelementptr inbounds %struct.mi_segment_s, ptr %0, i32 0, i32 2
  %1 = load i8, ptr %allow_purge, align 1
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %2 = load ptr, ptr %segment.addr, align 8
  %purge_mask = getelementptr inbounds %struct.mi_segment_s, ptr %2, i32 0, i32 5
  %call = call zeroext i1 @mi_commit_mask_is_empty(ptr noundef %purge_mask)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %while.end

if.end:                                           ; preds = %lor.lhs.false
  %call1 = call i64 @_mi_clock_now()
  store i64 %call1, ptr %now, align 8
  %3 = load i8, ptr %force.addr, align 1
  %tobool2 = trunc i8 %3 to i1
  br i1 %tobool2, label %if.end4, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %4 = load i64, ptr %now, align 8
  %5 = load ptr, ptr %segment.addr, align 8
  %purge_expire = getelementptr inbounds %struct.mi_segment_s, ptr %5, i32 0, i32 4
  %6 = load i64, ptr %purge_expire, align 8
  %cmp = icmp slt i64 %4, %6
  br i1 %cmp, label %if.then3, label %if.end4

if.then3:                                         ; preds = %land.lhs.true
  br label %while.end

if.end4:                                          ; preds = %land.lhs.true, %if.end
  %7 = load ptr, ptr %segment.addr, align 8
  %purge_mask5 = getelementptr inbounds %struct.mi_segment_s, ptr %7, i32 0, i32 5
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %mask, ptr align 8 %purge_mask5, i64 64, i1 false)
  %8 = load ptr, ptr %segment.addr, align 8
  %purge_expire6 = getelementptr inbounds %struct.mi_segment_s, ptr %8, i32 0, i32 4
  store i64 0, ptr %purge_expire6, align 8
  %9 = load ptr, ptr %segment.addr, align 8
  %purge_mask7 = getelementptr inbounds %struct.mi_segment_s, ptr %9, i32 0, i32 5
  call void @mi_commit_mask_create_empty(ptr noundef %purge_mask7)
  store i64 0, ptr %idx, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end14, %if.end4
  %call8 = call i64 @_mi_commit_mask_next_run(ptr noundef %mask, ptr noundef %idx)
  store i64 %call8, ptr %count, align 8
  %cmp9 = icmp ugt i64 %call8, 0
  br i1 %cmp9, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %10 = load i64, ptr %count, align 8
  %cmp10 = icmp ugt i64 %10, 0
  br i1 %cmp10, label %if.then11, label %if.end14

if.then11:                                        ; preds = %while.body
  %11 = load ptr, ptr %segment.addr, align 8
  %12 = load i64, ptr %idx, align 8
  %mul = mul i64 %12, 65536
  %add.ptr = getelementptr i8, ptr %11, i64 %mul
  store ptr %add.ptr, ptr %p, align 8
  %13 = load i64, ptr %count, align 8
  %mul12 = mul i64 %13, 65536
  store i64 %mul12, ptr %size, align 8
  %14 = load ptr, ptr %segment.addr, align 8
  %15 = load ptr, ptr %p, align 8
  %16 = load i64, ptr %size, align 8
  %17 = load ptr, ptr %stats.addr, align 8
  %call13 = call zeroext i1 @mi_segment_purge(ptr noundef %14, ptr noundef %15, i64 noundef %16, ptr noundef %17)
  br label %if.end14

if.end14:                                         ; preds = %if.then11, %while.body
  %18 = load i64, ptr %count, align 8
  %19 = load i64, ptr %idx, align 8
  %add = add i64 %19, %18
  store i64 %add, ptr %idx, align 8
  br label %while.cond, !llvm.loop !85

while.end:                                        ; preds = %while.cond, %if.then3, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_abandoned_visited_push(ptr noundef %segment) #0 {
entry:
  %segment.addr = alloca ptr, align 8
  %anext = alloca ptr, align 8
  %atomic-temp = alloca ptr, align 8
  %.atomictmp = alloca ptr, align 8
  %.atomictmp1 = alloca ptr, align 8
  %cmpxchg.bool = alloca i8, align 1
  %.atomictmp2 = alloca i64, align 8
  %atomic-temp3 = alloca i64, align 8
  store ptr %segment, ptr %segment.addr, align 8
  %0 = load atomic i64, ptr @abandoned_visited monotonic, align 64
  store i64 %0, ptr %atomic-temp, align 8
  %1 = load ptr, ptr %atomic-temp, align 8
  store ptr %1, ptr %anext, align 8
  br label %do.body

do.body:                                          ; preds = %cmpxchg.continue, %entry
  %2 = load ptr, ptr %segment.addr, align 8
  %abandoned_next = getelementptr inbounds %struct.mi_segment_s, ptr %2, i32 0, i32 7
  %3 = load ptr, ptr %anext, align 8
  store ptr %3, ptr %.atomictmp, align 8
  %4 = load i64, ptr %.atomictmp, align 8
  store atomic i64 %4, ptr %abandoned_next release, align 8
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %5 = load ptr, ptr %segment.addr, align 8
  store ptr %5, ptr %.atomictmp1, align 8
  %6 = load i64, ptr %anext, align 8
  %7 = load i64, ptr %.atomictmp1, align 8
  %8 = cmpxchg weak ptr @abandoned_visited, i64 %6, i64 %7 release monotonic, align 64
  %9 = extractvalue { i64, i1 } %8, 0
  %10 = extractvalue { i64, i1 } %8, 1
  br i1 %10, label %cmpxchg.continue, label %cmpxchg.store_expected

cmpxchg.store_expected:                           ; preds = %do.cond
  store i64 %9, ptr %anext, align 8
  br label %cmpxchg.continue

cmpxchg.continue:                                 ; preds = %cmpxchg.store_expected, %do.cond
  %frombool = zext i1 %10 to i8
  store i8 %frombool, ptr %cmpxchg.bool, align 1
  %11 = load i8, ptr %cmpxchg.bool, align 1
  %tobool = trunc i8 %11 to i1
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %do.body, label %do.end, !llvm.loop !86

do.end:                                           ; preds = %cmpxchg.continue
  store i64 1, ptr %.atomictmp2, align 8
  %12 = load i64, ptr %.atomictmp2, align 8
  %13 = atomicrmw add ptr @abandoned_visited_count, i64 %12 monotonic, align 64
  store i64 %13, ptr %atomic-temp3, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_segment_huge_page_reset(ptr noundef %segment, ptr noundef %page, ptr noundef %block) #0 {
entry:
  %segment.addr = alloca ptr, align 8
  %page.addr = alloca ptr, align 8
  %block.addr = alloca ptr, align 8
  %csize = alloca i64, align 8
  %p = alloca ptr, align 8
  store ptr %segment, ptr %segment.addr, align 8
  store ptr %page, ptr %page.addr, align 8
  store ptr %block, ptr %block.addr, align 8
  %0 = load ptr, ptr %segment.addr, align 8
  %allow_decommit = getelementptr inbounds %struct.mi_segment_s, ptr %0, i32 0, i32 1
  %1 = load i8, ptr %allow_decommit, align 8
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %if.then, label %if.end3

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %block.addr, align 8
  %call = call i64 @mi_usable_size(ptr noundef %2)
  store i64 %call, ptr %csize, align 8
  %3 = load i64, ptr %csize, align 8
  %cmp = icmp ugt i64 %3, 8
  br i1 %cmp, label %if.then1, label %if.end

if.then1:                                         ; preds = %if.then
  %4 = load i64, ptr %csize, align 8
  %sub = sub i64 %4, 8
  store i64 %sub, ptr %csize, align 8
  %5 = load ptr, ptr %block.addr, align 8
  %add.ptr = getelementptr i8, ptr %5, i64 8
  store ptr %add.ptr, ptr %p, align 8
  %6 = load ptr, ptr %p, align 8
  %7 = load i64, ptr %csize, align 8
  %call2 = call zeroext i1 @_mi_os_reset(ptr noundef %6, i64 noundef %7, ptr noundef @_mi_stats_main)
  br label %if.end

if.end:                                           ; preds = %if.then1, %if.then
  br label %if.end3

if.end3:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define hidden ptr @_mi_segment_page_alloc(ptr noundef %heap, i64 noundef %block_size, i64 noundef %page_alignment, ptr noundef %tld, ptr noundef %os_tld) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %block_size.addr = alloca i64, align 8
  %page_alignment.addr = alloca i64, align 8
  %tld.addr = alloca ptr, align 8
  %os_tld.addr = alloca ptr, align 8
  %page = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store i64 %block_size, ptr %block_size.addr, align 8
  store i64 %page_alignment, ptr %page_alignment.addr, align 8
  store ptr %tld, ptr %tld.addr, align 8
  store ptr %os_tld, ptr %os_tld.addr, align 8
  %0 = load i64, ptr %page_alignment.addr, align 8
  %cmp = icmp ugt i64 %0, 16777216
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i64, ptr %page_alignment.addr, align 8
  %cmp2 = icmp ult i64 %1, 33554432
  br i1 %cmp2, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  store i64 33554432, ptr %page_alignment.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then
  %2 = load i64, ptr %block_size.addr, align 8
  %3 = load i64, ptr %page_alignment.addr, align 8
  %4 = load ptr, ptr %heap.addr, align 8
  %arena_id = getelementptr inbounds %struct.mi_heap_s, ptr %4, i32 0, i32 5
  %5 = load i32, ptr %arena_id, align 8
  %6 = load ptr, ptr %tld.addr, align 8
  %7 = load ptr, ptr %os_tld.addr, align 8
  %call = call ptr @mi_segment_huge_page_alloc(i64 noundef %2, i64 noundef %3, i32 noundef %5, ptr noundef %6, ptr noundef %7)
  store ptr %call, ptr %page, align 8
  br label %if.end25

if.else:                                          ; preds = %entry
  %8 = load i64, ptr %block_size.addr, align 8
  %cmp5 = icmp ule i64 %8, 16384
  br i1 %cmp5, label %if.then7, label %if.else9

if.then7:                                         ; preds = %if.else
  %9 = load ptr, ptr %heap.addr, align 8
  %10 = load i64, ptr %block_size.addr, align 8
  %11 = load i64, ptr %block_size.addr, align 8
  %12 = load ptr, ptr %tld.addr, align 8
  %13 = load ptr, ptr %os_tld.addr, align 8
  %call8 = call ptr @mi_segments_page_alloc(ptr noundef %9, i32 noundef 0, i64 noundef %10, i64 noundef %11, ptr noundef %12, ptr noundef %13)
  store ptr %call8, ptr %page, align 8
  br label %if.end24

if.else9:                                         ; preds = %if.else
  %14 = load i64, ptr %block_size.addr, align 8
  %cmp10 = icmp ule i64 %14, 131072
  br i1 %cmp10, label %if.then12, label %if.else14

if.then12:                                        ; preds = %if.else9
  %15 = load ptr, ptr %heap.addr, align 8
  %16 = load i64, ptr %block_size.addr, align 8
  %17 = load ptr, ptr %tld.addr, align 8
  %18 = load ptr, ptr %os_tld.addr, align 8
  %call13 = call ptr @mi_segments_page_alloc(ptr noundef %15, i32 noundef 1, i64 noundef 524288, i64 noundef %16, ptr noundef %17, ptr noundef %18)
  store ptr %call13, ptr %page, align 8
  br label %if.end23

if.else14:                                        ; preds = %if.else9
  %19 = load i64, ptr %block_size.addr, align 8
  %cmp15 = icmp ule i64 %19, 16777216
  br i1 %cmp15, label %if.then17, label %if.else19

if.then17:                                        ; preds = %if.else14
  %20 = load ptr, ptr %heap.addr, align 8
  %21 = load i64, ptr %block_size.addr, align 8
  %22 = load i64, ptr %block_size.addr, align 8
  %23 = load ptr, ptr %tld.addr, align 8
  %24 = load ptr, ptr %os_tld.addr, align 8
  %call18 = call ptr @mi_segments_page_alloc(ptr noundef %20, i32 noundef 2, i64 noundef %21, i64 noundef %22, ptr noundef %23, ptr noundef %24)
  store ptr %call18, ptr %page, align 8
  br label %if.end22

if.else19:                                        ; preds = %if.else14
  %25 = load i64, ptr %block_size.addr, align 8
  %26 = load i64, ptr %page_alignment.addr, align 8
  %27 = load ptr, ptr %heap.addr, align 8
  %arena_id20 = getelementptr inbounds %struct.mi_heap_s, ptr %27, i32 0, i32 5
  %28 = load i32, ptr %arena_id20, align 8
  %29 = load ptr, ptr %tld.addr, align 8
  %30 = load ptr, ptr %os_tld.addr, align 8
  %call21 = call ptr @mi_segment_huge_page_alloc(i64 noundef %25, i64 noundef %26, i32 noundef %28, ptr noundef %29, ptr noundef %30)
  store ptr %call21, ptr %page, align 8
  br label %if.end22

if.end22:                                         ; preds = %if.else19, %if.then17
  br label %if.end23

if.end23:                                         ; preds = %if.end22, %if.then12
  br label %if.end24

if.end24:                                         ; preds = %if.end23, %if.then7
  br label %if.end25

if.end25:                                         ; preds = %if.end24, %if.end
  %31 = load ptr, ptr %page, align 8
  ret ptr %31
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_segment_huge_page_alloc(i64 noundef %size, i64 noundef %page_alignment, i32 noundef %req_arena_id, ptr noundef %tld, ptr noundef %os_tld) #0 {
entry:
  %retval = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %page_alignment.addr = alloca i64, align 8
  %req_arena_id.addr = alloca i32, align 4
  %tld.addr = alloca ptr, align 8
  %os_tld.addr = alloca ptr, align 8
  %page = alloca ptr, align 8
  %segment = alloca ptr, align 8
  %psize = alloca i64, align 8
  %start = alloca ptr, align 8
  %aligned_p = alloca ptr, align 8
  %decommit_start = alloca ptr, align 8
  %decommit_size = alloca i64, align 8
  store i64 %size, ptr %size.addr, align 8
  store i64 %page_alignment, ptr %page_alignment.addr, align 8
  store i32 %req_arena_id, ptr %req_arena_id.addr, align 4
  store ptr %tld, ptr %tld.addr, align 8
  store ptr %os_tld, ptr %os_tld.addr, align 8
  store ptr null, ptr %page, align 8
  %0 = load i64, ptr %size.addr, align 8
  %1 = load i64, ptr %page_alignment.addr, align 8
  %2 = load i32, ptr %req_arena_id.addr, align 4
  %3 = load ptr, ptr %tld.addr, align 8
  %4 = load ptr, ptr %os_tld.addr, align 8
  %call = call ptr @mi_segment_alloc(i64 noundef %0, i64 noundef %1, i32 noundef %2, ptr noundef %3, ptr noundef %4, ptr noundef %page)
  store ptr %call, ptr %segment, align 8
  %5 = load ptr, ptr %segment, align 8
  %cmp = icmp eq ptr %5, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %6 = load ptr, ptr %page, align 8
  %cmp1 = icmp eq ptr %6, null
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %7 = load ptr, ptr %segment, align 8
  %8 = load ptr, ptr %page, align 8
  %call2 = call ptr @_mi_segment_page_start(ptr noundef %7, ptr noundef %8, ptr noundef %psize)
  store ptr %call2, ptr %start, align 8
  %9 = load i64, ptr %psize, align 8
  %cmp3 = icmp ugt i64 %9, 2147483648
  br i1 %cmp3, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %10 = load i64, ptr %psize, align 8
  %conv = trunc i64 %10 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ -2147483648, %cond.true ], [ %conv, %cond.false ]
  %11 = load ptr, ptr %page, align 8
  %xblock_size = getelementptr inbounds %struct.mi_page_s, ptr %11, i32 0, i32 9
  store i32 %cond, ptr %xblock_size, align 4
  %12 = load i64, ptr %page_alignment.addr, align 8
  %cmp4 = icmp ugt i64 %12, 0
  br i1 %cmp4, label %land.lhs.true, label %if.end10

land.lhs.true:                                    ; preds = %cond.end
  %13 = load ptr, ptr %segment, align 8
  %allow_decommit = getelementptr inbounds %struct.mi_segment_s, ptr %13, i32 0, i32 1
  %14 = load i8, ptr %allow_decommit, align 8
  %tobool = trunc i8 %14 to i1
  br i1 %tobool, label %if.then7, label %if.end10

if.then7:                                         ; preds = %land.lhs.true
  %15 = load ptr, ptr %start, align 8
  %16 = ptrtoint ptr %15 to i64
  %17 = load i64, ptr %page_alignment.addr, align 8
  %call8 = call i64 @_mi_align_up(i64 noundef %16, i64 noundef %17)
  %18 = inttoptr i64 %call8 to ptr
  store ptr %18, ptr %aligned_p, align 8
  %19 = load ptr, ptr %start, align 8
  %add.ptr = getelementptr i8, ptr %19, i64 8
  store ptr %add.ptr, ptr %decommit_start, align 8
  %20 = load ptr, ptr %aligned_p, align 8
  %21 = load ptr, ptr %decommit_start, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %20 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %21 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, ptr %decommit_size, align 8
  %22 = load ptr, ptr %decommit_start, align 8
  %23 = load i64, ptr %decommit_size, align 8
  %call9 = call zeroext i1 @_mi_os_reset(ptr noundef %22, i64 noundef %23, ptr noundef @_mi_stats_main)
  br label %if.end10

if.end10:                                         ; preds = %if.then7, %land.lhs.true, %cond.end
  %24 = load ptr, ptr %page, align 8
  store ptr %24, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end10, %if.then
  %25 = load ptr, ptr %retval, align 8
  ret ptr %25
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_segments_page_alloc(ptr noundef %heap, i32 noundef %page_kind, i64 noundef %required, i64 noundef %block_size, ptr noundef %tld, ptr noundef %os_tld) #0 {
entry:
  %retval = alloca ptr, align 8
  %heap.addr = alloca ptr, align 8
  %page_kind.addr = alloca i32, align 4
  %required.addr = alloca i64, align 8
  %block_size.addr = alloca i64, align 8
  %tld.addr = alloca ptr, align 8
  %os_tld.addr = alloca ptr, align 8
  %page_size = alloca i64, align 8
  %slices_needed = alloca i64, align 8
  %page = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store i32 %page_kind, ptr %page_kind.addr, align 4
  store i64 %required, ptr %required.addr, align 8
  store i64 %block_size, ptr %block_size.addr, align 8
  store ptr %tld, ptr %tld.addr, align 8
  store ptr %os_tld, ptr %os_tld.addr, align 8
  %0 = load i64, ptr %required.addr, align 8
  %1 = load i64, ptr %required.addr, align 8
  %cmp = icmp ugt i64 %1, 524288
  %cond = select i1 %cmp, i64 524288, i64 65536
  %call = call i64 @_mi_align_up(i64 noundef %0, i64 noundef %cond)
  store i64 %call, ptr %page_size, align 8
  %2 = load i64, ptr %page_size, align 8
  %div = udiv i64 %2, 65536
  store i64 %div, ptr %slices_needed, align 8
  %3 = load i64, ptr %slices_needed, align 8
  %4 = load ptr, ptr %heap.addr, align 8
  %arena_id = getelementptr inbounds %struct.mi_heap_s, ptr %4, i32 0, i32 5
  %5 = load i32, ptr %arena_id, align 8
  %6 = load ptr, ptr %tld.addr, align 8
  %call1 = call ptr @mi_segments_page_find_and_allocate(i64 noundef %3, i32 noundef %5, ptr noundef %6)
  store ptr %call1, ptr %page, align 8
  %7 = load ptr, ptr %page, align 8
  %cmp2 = icmp eq ptr %7, null
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %8 = load ptr, ptr %heap.addr, align 8
  %9 = load i64, ptr %slices_needed, align 8
  %10 = load i64, ptr %block_size.addr, align 8
  %11 = load ptr, ptr %tld.addr, align 8
  %12 = load ptr, ptr %os_tld.addr, align 8
  %call3 = call ptr @mi_segment_reclaim_or_alloc(ptr noundef %8, i64 noundef %9, i64 noundef %10, ptr noundef %11, ptr noundef %12)
  %cmp4 = icmp eq ptr %call3, null
  br i1 %cmp4, label %if.then5, label %if.else

if.then5:                                         ; preds = %if.then
  store ptr null, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %if.then
  %13 = load ptr, ptr %heap.addr, align 8
  %14 = load i32, ptr %page_kind.addr, align 4
  %15 = load i64, ptr %required.addr, align 8
  %16 = load i64, ptr %block_size.addr, align 8
  %17 = load ptr, ptr %tld.addr, align 8
  %18 = load ptr, ptr %os_tld.addr, align 8
  %call6 = call ptr @mi_segments_page_alloc(ptr noundef %13, i32 noundef %14, i64 noundef %15, i64 noundef %16, ptr noundef %17, ptr noundef %18)
  store ptr %call6, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %19 = load ptr, ptr %page, align 8
  %call7 = call ptr @_mi_ptr_segment(ptr noundef %19)
  %20 = load ptr, ptr %tld.addr, align 8
  %stats = getelementptr inbounds %struct.mi_segments_tld_s, ptr %20, i32 0, i32 5
  %21 = load ptr, ptr %stats, align 8
  call void @mi_segment_try_purge(ptr noundef %call7, i1 noundef zeroext false, ptr noundef %21)
  %22 = load ptr, ptr %page, align 8
  store ptr %22, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.else, %if.then5
  %23 = load ptr, ptr %retval, align 8
  ret ptr %23
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_segment_map_allocated_at(ptr noundef %segment) #0 {
entry:
  %segment.addr = alloca ptr, align 8
  %bitidx = alloca i64, align 8
  %index = alloca i64, align 8
  %mask = alloca i64, align 8
  %atomic-temp = alloca i64, align 8
  %newmask = alloca i64, align 8
  %.atomictmp = alloca i64, align 8
  %cmpxchg.bool = alloca i8, align 1
  store ptr %segment, ptr %segment.addr, align 8
  %0 = load ptr, ptr %segment.addr, align 8
  %call = call i64 @mi_segment_map_index_of(ptr noundef %0, ptr noundef %bitidx)
  store i64 %call, ptr %index, align 8
  %1 = load i64, ptr %index, align 8
  %cmp = icmp eq i64 %1, 20480
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %do.end

if.end:                                           ; preds = %entry
  %2 = load i64, ptr %index, align 8
  %arrayidx = getelementptr [20481 x i64], ptr @mi_segment_map, i64 0, i64 %2
  %3 = load atomic i64, ptr %arrayidx monotonic, align 8
  store i64 %3, ptr %atomic-temp, align 8
  %4 = load i64, ptr %atomic-temp, align 8
  store i64 %4, ptr %mask, align 8
  br label %do.body

do.body:                                          ; preds = %cmpxchg.continue, %if.end
  %5 = load i64, ptr %mask, align 8
  %6 = load i64, ptr %bitidx, align 8
  %shl = shl i64 1, %6
  %or = or i64 %5, %shl
  store i64 %or, ptr %newmask, align 8
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %7 = load i64, ptr %index, align 8
  %arrayidx1 = getelementptr [20481 x i64], ptr @mi_segment_map, i64 0, i64 %7
  %8 = load i64, ptr %newmask, align 8
  store i64 %8, ptr %.atomictmp, align 8
  %9 = load i64, ptr %mask, align 8
  %10 = load i64, ptr %.atomictmp, align 8
  %11 = cmpxchg weak ptr %arrayidx1, i64 %9, i64 %10 release monotonic, align 8
  %12 = extractvalue { i64, i1 } %11, 0
  %13 = extractvalue { i64, i1 } %11, 1
  br i1 %13, label %cmpxchg.continue, label %cmpxchg.store_expected

cmpxchg.store_expected:                           ; preds = %do.cond
  store i64 %12, ptr %mask, align 8
  br label %cmpxchg.continue

cmpxchg.continue:                                 ; preds = %cmpxchg.store_expected, %do.cond
  %frombool = zext i1 %13 to i8
  store i8 %frombool, ptr %cmpxchg.bool, align 1
  %14 = load i8, ptr %cmpxchg.bool, align 1
  %tobool = trunc i8 %14 to i1
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %do.body, label %do.end, !llvm.loop !87

do.end:                                           ; preds = %cmpxchg.continue, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @mi_segment_map_index_of(ptr noundef %segment, ptr noundef %bitidx) #0 {
entry:
  %retval = alloca i64, align 8
  %segment.addr = alloca ptr, align 8
  %bitidx.addr = alloca ptr, align 8
  %segindex = alloca i64, align 8
  %mapindex = alloca i64, align 8
  store ptr %segment, ptr %segment.addr, align 8
  store ptr %bitidx, ptr %bitidx.addr, align 8
  %0 = load ptr, ptr %segment.addr, align 8
  %1 = ptrtoint ptr %0 to i64
  %cmp = icmp uge i64 %1, 43980465111040
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %bitidx.addr, align 8
  store i64 0, ptr %2, align 8
  store i64 20480, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %3 = load ptr, ptr %segment.addr, align 8
  %4 = ptrtoint ptr %3 to i64
  %div = udiv i64 %4, 33554432
  store i64 %div, ptr %segindex, align 8
  %5 = load i64, ptr %segindex, align 8
  %rem = urem i64 %5, 64
  %6 = load ptr, ptr %bitidx.addr, align 8
  store i64 %rem, ptr %6, align 8
  %7 = load i64, ptr %segindex, align 8
  %div1 = udiv i64 %7, 64
  store i64 %div1, ptr %mapindex, align 8
  %8 = load i64, ptr %mapindex, align 8
  store i64 %8, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %9 = load i64, ptr %retval, align 8
  ret i64 %9
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_segment_map_freed_at(ptr noundef %segment) #0 {
entry:
  %segment.addr = alloca ptr, align 8
  %bitidx = alloca i64, align 8
  %index = alloca i64, align 8
  %mask = alloca i64, align 8
  %atomic-temp = alloca i64, align 8
  %newmask = alloca i64, align 8
  %.atomictmp = alloca i64, align 8
  %cmpxchg.bool = alloca i8, align 1
  store ptr %segment, ptr %segment.addr, align 8
  %0 = load ptr, ptr %segment.addr, align 8
  %call = call i64 @mi_segment_map_index_of(ptr noundef %0, ptr noundef %bitidx)
  store i64 %call, ptr %index, align 8
  %1 = load i64, ptr %index, align 8
  %cmp = icmp eq i64 %1, 20480
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %do.end

if.end:                                           ; preds = %entry
  %2 = load i64, ptr %index, align 8
  %arrayidx = getelementptr [20481 x i64], ptr @mi_segment_map, i64 0, i64 %2
  %3 = load atomic i64, ptr %arrayidx monotonic, align 8
  store i64 %3, ptr %atomic-temp, align 8
  %4 = load i64, ptr %atomic-temp, align 8
  store i64 %4, ptr %mask, align 8
  br label %do.body

do.body:                                          ; preds = %cmpxchg.continue, %if.end
  %5 = load i64, ptr %mask, align 8
  %6 = load i64, ptr %bitidx, align 8
  %shl = shl i64 1, %6
  %not = xor i64 %shl, -1
  %and = and i64 %5, %not
  store i64 %and, ptr %newmask, align 8
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %7 = load i64, ptr %index, align 8
  %arrayidx1 = getelementptr [20481 x i64], ptr @mi_segment_map, i64 0, i64 %7
  %8 = load i64, ptr %newmask, align 8
  store i64 %8, ptr %.atomictmp, align 8
  %9 = load i64, ptr %mask, align 8
  %10 = load i64, ptr %.atomictmp, align 8
  %11 = cmpxchg weak ptr %arrayidx1, i64 %9, i64 %10 release monotonic, align 8
  %12 = extractvalue { i64, i1 } %11, 0
  %13 = extractvalue { i64, i1 } %11, 1
  br i1 %13, label %cmpxchg.continue, label %cmpxchg.store_expected

cmpxchg.store_expected:                           ; preds = %do.cond
  store i64 %12, ptr %mask, align 8
  br label %cmpxchg.continue

cmpxchg.continue:                                 ; preds = %cmpxchg.store_expected, %do.cond
  %frombool = zext i1 %13 to i8
  store i8 %frombool, ptr %cmpxchg.bool, align 1
  %14 = load i8, ptr %cmpxchg.bool, align 1
  %tobool = trunc i8 %14 to i1
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %do.body, label %do.end, !llvm.loop !88

do.end:                                           ; preds = %cmpxchg.continue, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_is_valid_pointer(ptr noundef %p) #0 {
entry:
  %p.addr = alloca ptr, align 8
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %call = call ptr @_mi_segment_of(ptr noundef %0)
  %cmp = icmp ne ptr %call, null
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %1 = load ptr, ptr %p.addr, align 8
  %call1 = call zeroext i1 @_mi_arena_contains(ptr noundef %1)
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %2 = phi i1 [ true, %entry ], [ %call1, %lor.rhs ]
  ret i1 %2
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_is_in_main(ptr noundef %stat) #0 {
entry:
  %stat.addr = alloca ptr, align 8
  store ptr %stat, ptr %stat.addr, align 8
  %0 = load ptr, ptr %stat.addr, align 8
  %cmp = icmp uge ptr %0, @_mi_stats_main
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %1 = load ptr, ptr %stat.addr, align 8
  %cmp1 = icmp ult ptr %1, getelementptr (i8, ptr @_mi_stats_main, i64 640)
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %2 = phi i1 [ false, %entry ], [ %cmp1, %land.rhs ]
  ret i1 %2
}

; Function Attrs: nounwind uwtable
define internal i64 @mi_atomic_addi64_relaxed(ptr noundef %p, i64 noundef %add) #0 {
entry:
  %p.addr = alloca ptr, align 8
  %add.addr = alloca i64, align 8
  %.atomictmp = alloca i64, align 8
  %atomic-temp = alloca i64, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %add, ptr %add.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %1 = load i64, ptr %add.addr, align 8
  store i64 %1, ptr %.atomictmp, align 8
  %2 = load i64, ptr %.atomictmp, align 8
  %3 = atomicrmw add ptr %0, i64 %2 monotonic, align 8
  store i64 %3, ptr %atomic-temp, align 8
  %4 = load i64, ptr %atomic-temp, align 8
  ret i64 %4
}

; Function Attrs: nounwind uwtable
define internal void @mi_stat_update(ptr noundef %stat, i64 noundef %amount) #0 {
entry:
  %stat.addr = alloca ptr, align 8
  %amount.addr = alloca i64, align 8
  %current = alloca i64, align 8
  store ptr %stat, ptr %stat.addr, align 8
  store i64 %amount, ptr %amount.addr, align 8
  %0 = load i64, ptr %amount.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end28

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %stat.addr, align 8
  %call = call zeroext i1 @mi_is_in_main(ptr noundef %1)
  br i1 %call, label %if.then1, label %if.else9

if.then1:                                         ; preds = %if.end
  %2 = load ptr, ptr %stat.addr, align 8
  %current2 = getelementptr inbounds %struct.mi_stat_count_s, ptr %2, i32 0, i32 3
  %3 = load i64, ptr %amount.addr, align 8
  %call3 = call i64 @mi_atomic_addi64_relaxed(ptr noundef %current2, i64 noundef %3)
  store i64 %call3, ptr %current, align 8
  %4 = load ptr, ptr %stat.addr, align 8
  %peak = getelementptr inbounds %struct.mi_stat_count_s, ptr %4, i32 0, i32 2
  %5 = load i64, ptr %current, align 8
  %6 = load i64, ptr %amount.addr, align 8
  %add = add i64 %5, %6
  call void @mi_atomic_maxi64_relaxed(ptr noundef %peak, i64 noundef %add)
  %7 = load i64, ptr %amount.addr, align 8
  %cmp4 = icmp sgt i64 %7, 0
  br i1 %cmp4, label %if.then5, label %if.else

if.then5:                                         ; preds = %if.then1
  %8 = load ptr, ptr %stat.addr, align 8
  %allocated = getelementptr inbounds %struct.mi_stat_count_s, ptr %8, i32 0, i32 0
  %9 = load i64, ptr %amount.addr, align 8
  %call6 = call i64 @mi_atomic_addi64_relaxed(ptr noundef %allocated, i64 noundef %9)
  br label %if.end8

if.else:                                          ; preds = %if.then1
  %10 = load ptr, ptr %stat.addr, align 8
  %freed = getelementptr inbounds %struct.mi_stat_count_s, ptr %10, i32 0, i32 1
  %11 = load i64, ptr %amount.addr, align 8
  %sub = sub i64 0, %11
  %call7 = call i64 @mi_atomic_addi64_relaxed(ptr noundef %freed, i64 noundef %sub)
  br label %if.end8

if.end8:                                          ; preds = %if.else, %if.then5
  br label %if.end28

if.else9:                                         ; preds = %if.end
  %12 = load i64, ptr %amount.addr, align 8
  %13 = load ptr, ptr %stat.addr, align 8
  %current10 = getelementptr inbounds %struct.mi_stat_count_s, ptr %13, i32 0, i32 3
  %14 = load i64, ptr %current10, align 8
  %add11 = add i64 %14, %12
  store i64 %add11, ptr %current10, align 8
  %15 = load ptr, ptr %stat.addr, align 8
  %current12 = getelementptr inbounds %struct.mi_stat_count_s, ptr %15, i32 0, i32 3
  %16 = load i64, ptr %current12, align 8
  %17 = load ptr, ptr %stat.addr, align 8
  %peak13 = getelementptr inbounds %struct.mi_stat_count_s, ptr %17, i32 0, i32 2
  %18 = load i64, ptr %peak13, align 8
  %cmp14 = icmp sgt i64 %16, %18
  br i1 %cmp14, label %if.then15, label %if.end18

if.then15:                                        ; preds = %if.else9
  %19 = load ptr, ptr %stat.addr, align 8
  %current16 = getelementptr inbounds %struct.mi_stat_count_s, ptr %19, i32 0, i32 3
  %20 = load i64, ptr %current16, align 8
  %21 = load ptr, ptr %stat.addr, align 8
  %peak17 = getelementptr inbounds %struct.mi_stat_count_s, ptr %21, i32 0, i32 2
  store i64 %20, ptr %peak17, align 8
  br label %if.end18

if.end18:                                         ; preds = %if.then15, %if.else9
  %22 = load i64, ptr %amount.addr, align 8
  %cmp19 = icmp sgt i64 %22, 0
  br i1 %cmp19, label %if.then20, label %if.else23

if.then20:                                        ; preds = %if.end18
  %23 = load i64, ptr %amount.addr, align 8
  %24 = load ptr, ptr %stat.addr, align 8
  %allocated21 = getelementptr inbounds %struct.mi_stat_count_s, ptr %24, i32 0, i32 0
  %25 = load i64, ptr %allocated21, align 8
  %add22 = add i64 %25, %23
  store i64 %add22, ptr %allocated21, align 8
  br label %if.end27

if.else23:                                        ; preds = %if.end18
  %26 = load i64, ptr %amount.addr, align 8
  %sub24 = sub i64 0, %26
  %27 = load ptr, ptr %stat.addr, align 8
  %freed25 = getelementptr inbounds %struct.mi_stat_count_s, ptr %27, i32 0, i32 1
  %28 = load i64, ptr %freed25, align 8
  %add26 = add i64 %28, %sub24
  store i64 %add26, ptr %freed25, align 8
  br label %if.end27

if.end27:                                         ; preds = %if.else23, %if.then20
  br label %if.end28

if.end28:                                         ; preds = %if.end27, %if.end8, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_stats_get_default() #0 {
entry:
  %heap = alloca ptr, align 8
  %call = call ptr @mi_heap_get_default()
  store ptr %call, ptr %heap, align 8
  %0 = load ptr, ptr %heap, align 8
  %tld = getelementptr inbounds %struct.mi_heap_s, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %tld, align 8
  %stats = getelementptr inbounds %struct.mi_tld_s, ptr %1, i32 0, i32 6
  ret ptr %stats
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #7

; Function Attrs: nounwind uwtable
define hidden void @mi_stats_merge() #0 {
entry:
  %call = call ptr @mi_stats_get_default()
  call void @mi_stats_merge_from(ptr noundef %call)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_stats_merge_from(ptr noundef %stats) #0 {
entry:
  %stats.addr = alloca ptr, align 8
  store ptr %stats, ptr %stats.addr, align 8
  %0 = load ptr, ptr %stats.addr, align 8
  %cmp = icmp ne ptr %0, @_mi_stats_main
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %stats.addr, align 8
  call void @mi_stats_add(ptr noundef @_mi_stats_main, ptr noundef %1)
  %2 = load ptr, ptr %stats.addr, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %2, i8 0, i64 640, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_stats_done(ptr noundef %stats) #0 {
entry:
  %stats.addr = alloca ptr, align 8
  store ptr %stats, ptr %stats.addr, align 8
  %0 = load ptr, ptr %stats.addr, align 8
  call void @mi_stats_merge_from(ptr noundef %0)
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @mi_stats_print_out(ptr noundef %out, ptr noundef %arg) #0 {
entry:
  %out.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  store ptr %out, ptr %out.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %call = call ptr @mi_stats_get_default()
  call void @mi_stats_merge_from(ptr noundef %call)
  %0 = load ptr, ptr %out.addr, align 8
  %1 = load ptr, ptr %arg.addr, align 8
  call void @_mi_stats_print(ptr noundef @_mi_stats_main, ptr noundef %0, ptr noundef %1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @_mi_stats_print(ptr noundef %stats, ptr noundef %out0, ptr noundef %arg0) #0 {
entry:
  %stats.addr = alloca ptr, align 8
  %out0.addr = alloca ptr, align 8
  %arg0.addr = alloca ptr, align 8
  %buf = alloca [256 x i8], align 16
  %buffer = alloca %struct.buffered_s, align 8
  %out3 = alloca ptr, align 8
  %arg4 = alloca ptr, align 8
  %elapsed = alloca i64, align 8
  %user_time = alloca i64, align 8
  %sys_time = alloca i64, align 8
  %current_rss = alloca i64, align 8
  %peak_rss = alloca i64, align 8
  %current_commit = alloca i64, align 8
  %peak_commit = alloca i64, align 8
  %page_faults = alloca i64, align 8
  store ptr %stats, ptr %stats.addr, align 8
  store ptr %out0, ptr %out0.addr, align 8
  store ptr %arg0, ptr %arg0.addr, align 8
  %out = getelementptr inbounds %struct.buffered_s, ptr %buffer, i32 0, i32 0
  %0 = load ptr, ptr %out0.addr, align 8
  store ptr %0, ptr %out, align 8
  %arg = getelementptr inbounds %struct.buffered_s, ptr %buffer, i32 0, i32 1
  %1 = load ptr, ptr %arg0.addr, align 8
  store ptr %1, ptr %arg, align 8
  %buf1 = getelementptr inbounds %struct.buffered_s, ptr %buffer, i32 0, i32 2
  store ptr null, ptr %buf1, align 8
  %used = getelementptr inbounds %struct.buffered_s, ptr %buffer, i32 0, i32 3
  store i64 0, ptr %used, align 8
  %count = getelementptr inbounds %struct.buffered_s, ptr %buffer, i32 0, i32 4
  store i64 255, ptr %count, align 8
  %arraydecay = getelementptr inbounds [256 x i8], ptr %buf, i64 0, i64 0
  %buf2 = getelementptr inbounds %struct.buffered_s, ptr %buffer, i32 0, i32 2
  store ptr %arraydecay, ptr %buf2, align 8
  store ptr @mi_buffered_out, ptr %out3, align 8
  store ptr %buffer, ptr %arg4, align 8
  %2 = load ptr, ptr %out3, align 8
  %3 = load ptr, ptr %arg4, align 8
  call void @mi_print_header(ptr noundef %2, ptr noundef %3)
  %4 = load ptr, ptr %stats.addr, align 8
  %reserved = getelementptr inbounds %struct.mi_stats_s, ptr %4, i32 0, i32 2
  %5 = load ptr, ptr %out3, align 8
  %6 = load ptr, ptr %arg4, align 8
  call void @mi_stat_print_ex(ptr noundef %reserved, ptr noundef @.str.100, i64 noundef 1, ptr noundef %5, ptr noundef %6, ptr noundef @.str.10)
  %7 = load ptr, ptr %stats.addr, align 8
  %committed = getelementptr inbounds %struct.mi_stats_s, ptr %7, i32 0, i32 3
  %8 = load ptr, ptr %out3, align 8
  %9 = load ptr, ptr %arg4, align 8
  call void @mi_stat_print_ex(ptr noundef %committed, ptr noundef @.str.101, i64 noundef 1, ptr noundef %8, ptr noundef %9, ptr noundef @.str.10)
  %10 = load ptr, ptr %stats.addr, align 8
  %reset = getelementptr inbounds %struct.mi_stats_s, ptr %10, i32 0, i32 4
  %11 = load ptr, ptr %out3, align 8
  %12 = load ptr, ptr %arg4, align 8
  call void @mi_stat_peak_print(ptr noundef %reset, ptr noundef @.str.102, i64 noundef 1, ptr noundef %11, ptr noundef %12)
  %13 = load ptr, ptr %stats.addr, align 8
  %purged = getelementptr inbounds %struct.mi_stats_s, ptr %13, i32 0, i32 5
  %14 = load ptr, ptr %out3, align 8
  %15 = load ptr, ptr %arg4, align 8
  call void @mi_stat_peak_print(ptr noundef %purged, ptr noundef @.str.103, i64 noundef 1, ptr noundef %14, ptr noundef %15)
  %16 = load ptr, ptr %stats.addr, align 8
  %page_committed = getelementptr inbounds %struct.mi_stats_s, ptr %16, i32 0, i32 6
  %17 = load ptr, ptr %out3, align 8
  %18 = load ptr, ptr %arg4, align 8
  call void @mi_stat_print(ptr noundef %page_committed, ptr noundef @.str.104, i64 noundef 1, ptr noundef %17, ptr noundef %18)
  %19 = load ptr, ptr %stats.addr, align 8
  %segments = getelementptr inbounds %struct.mi_stats_s, ptr %19, i32 0, i32 0
  %20 = load ptr, ptr %out3, align 8
  %21 = load ptr, ptr %arg4, align 8
  call void @mi_stat_print(ptr noundef %segments, ptr noundef @.str.105, i64 noundef -1, ptr noundef %20, ptr noundef %21)
  %22 = load ptr, ptr %stats.addr, align 8
  %segments_abandoned = getelementptr inbounds %struct.mi_stats_s, ptr %22, i32 0, i32 7
  %23 = load ptr, ptr %out3, align 8
  %24 = load ptr, ptr %arg4, align 8
  call void @mi_stat_print(ptr noundef %segments_abandoned, ptr noundef @.str.106, i64 noundef -1, ptr noundef %23, ptr noundef %24)
  %25 = load ptr, ptr %stats.addr, align 8
  %segments_cache = getelementptr inbounds %struct.mi_stats_s, ptr %25, i32 0, i32 14
  %26 = load ptr, ptr %out3, align 8
  %27 = load ptr, ptr %arg4, align 8
  call void @mi_stat_print(ptr noundef %segments_cache, ptr noundef @.str.107, i64 noundef -1, ptr noundef %26, ptr noundef %27)
  %28 = load ptr, ptr %stats.addr, align 8
  %pages = getelementptr inbounds %struct.mi_stats_s, ptr %28, i32 0, i32 1
  %29 = load ptr, ptr %out3, align 8
  %30 = load ptr, ptr %arg4, align 8
  call void @mi_stat_print(ptr noundef %pages, ptr noundef @.str.108, i64 noundef -1, ptr noundef %29, ptr noundef %30)
  %31 = load ptr, ptr %stats.addr, align 8
  %pages_abandoned = getelementptr inbounds %struct.mi_stats_s, ptr %31, i32 0, i32 8
  %32 = load ptr, ptr %out3, align 8
  %33 = load ptr, ptr %arg4, align 8
  call void @mi_stat_print(ptr noundef %pages_abandoned, ptr noundef @.str.106, i64 noundef -1, ptr noundef %32, ptr noundef %33)
  %34 = load ptr, ptr %stats.addr, align 8
  %pages_extended = getelementptr inbounds %struct.mi_stats_s, ptr %34, i32 0, i32 15
  %35 = load ptr, ptr %out3, align 8
  %36 = load ptr, ptr %arg4, align 8
  call void @mi_stat_counter_print(ptr noundef %pages_extended, ptr noundef @.str.109, ptr noundef %35, ptr noundef %36)
  %37 = load ptr, ptr %stats.addr, align 8
  %page_no_retire = getelementptr inbounds %struct.mi_stats_s, ptr %37, i32 0, i32 20
  %38 = load ptr, ptr %out3, align 8
  %39 = load ptr, ptr %arg4, align 8
  call void @mi_stat_counter_print(ptr noundef %page_no_retire, ptr noundef @.str.110, ptr noundef %38, ptr noundef %39)
  %40 = load ptr, ptr %stats.addr, align 8
  %mmap_calls = getelementptr inbounds %struct.mi_stats_s, ptr %40, i32 0, i32 16
  %41 = load ptr, ptr %out3, align 8
  %42 = load ptr, ptr %arg4, align 8
  call void @mi_stat_counter_print(ptr noundef %mmap_calls, ptr noundef @.str.111, ptr noundef %41, ptr noundef %42)
  %43 = load ptr, ptr %stats.addr, align 8
  %commit_calls = getelementptr inbounds %struct.mi_stats_s, ptr %43, i32 0, i32 17
  %44 = load ptr, ptr %out3, align 8
  %45 = load ptr, ptr %arg4, align 8
  call void @mi_stat_counter_print(ptr noundef %commit_calls, ptr noundef @.str.112, ptr noundef %44, ptr noundef %45)
  %46 = load ptr, ptr %stats.addr, align 8
  %reset_calls = getelementptr inbounds %struct.mi_stats_s, ptr %46, i32 0, i32 18
  %47 = load ptr, ptr %out3, align 8
  %48 = load ptr, ptr %arg4, align 8
  call void @mi_stat_counter_print(ptr noundef %reset_calls, ptr noundef @.str.113, ptr noundef %47, ptr noundef %48)
  %49 = load ptr, ptr %stats.addr, align 8
  %purge_calls = getelementptr inbounds %struct.mi_stats_s, ptr %49, i32 0, i32 19
  %50 = load ptr, ptr %out3, align 8
  %51 = load ptr, ptr %arg4, align 8
  call void @mi_stat_counter_print(ptr noundef %purge_calls, ptr noundef @.str.114, ptr noundef %50, ptr noundef %51)
  %52 = load ptr, ptr %stats.addr, align 8
  %threads = getelementptr inbounds %struct.mi_stats_s, ptr %52, i32 0, i32 9
  %53 = load ptr, ptr %out3, align 8
  %54 = load ptr, ptr %arg4, align 8
  call void @mi_stat_print(ptr noundef %threads, ptr noundef @.str.115, i64 noundef -1, ptr noundef %53, ptr noundef %54)
  %55 = load ptr, ptr %stats.addr, align 8
  %searches = getelementptr inbounds %struct.mi_stats_s, ptr %55, i32 0, i32 21
  %56 = load ptr, ptr %out3, align 8
  %57 = load ptr, ptr %arg4, align 8
  call void @mi_stat_counter_print_avg(ptr noundef %searches, ptr noundef @.str.116, ptr noundef %56, ptr noundef %57)
  %58 = load ptr, ptr %out3, align 8
  %59 = load ptr, ptr %arg4, align 8
  %call = call i64 @_mi_os_numa_node_count()
  call void (ptr, ptr, ptr, ...) @_mi_fprintf(ptr noundef %58, ptr noundef %59, ptr noundef @.str.117, ptr noundef @.str.118, i64 noundef %call)
  call void @mi_process_info(ptr noundef %elapsed, ptr noundef %user_time, ptr noundef %sys_time, ptr noundef %current_rss, ptr noundef %peak_rss, ptr noundef %current_commit, ptr noundef %peak_commit, ptr noundef %page_faults)
  %60 = load ptr, ptr %out3, align 8
  %61 = load ptr, ptr %arg4, align 8
  %62 = load i64, ptr %elapsed, align 8
  %div = udiv i64 %62, 1000
  %63 = load i64, ptr %elapsed, align 8
  %rem = urem i64 %63, 1000
  call void (ptr, ptr, ptr, ...) @_mi_fprintf(ptr noundef %60, ptr noundef %61, ptr noundef @.str.119, ptr noundef @.str.120, i64 noundef %div, i64 noundef %rem)
  %64 = load ptr, ptr %out3, align 8
  %65 = load ptr, ptr %arg4, align 8
  %66 = load i64, ptr %user_time, align 8
  %div5 = udiv i64 %66, 1000
  %67 = load i64, ptr %user_time, align 8
  %rem6 = urem i64 %67, 1000
  %68 = load i64, ptr %sys_time, align 8
  %div7 = udiv i64 %68, 1000
  %69 = load i64, ptr %sys_time, align 8
  %rem8 = urem i64 %69, 1000
  %70 = load i64, ptr %page_faults, align 8
  call void (ptr, ptr, ptr, ...) @_mi_fprintf(ptr noundef %64, ptr noundef %65, ptr noundef @.str.121, ptr noundef @.str.122, i64 noundef %div5, i64 noundef %rem6, i64 noundef %div7, i64 noundef %rem8, i64 noundef %70)
  %71 = load i64, ptr %peak_rss, align 8
  %72 = load ptr, ptr %out3, align 8
  %73 = load ptr, ptr %arg4, align 8
  call void @mi_printf_amount(i64 noundef %71, i64 noundef 1, ptr noundef %72, ptr noundef %73, ptr noundef @.str.123)
  %74 = load i64, ptr %peak_commit, align 8
  %cmp = icmp ugt i64 %74, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %75 = load ptr, ptr %out3, align 8
  %76 = load ptr, ptr %arg4, align 8
  call void (ptr, ptr, ptr, ...) @_mi_fprintf(ptr noundef %75, ptr noundef %76, ptr noundef @.str.124)
  %77 = load i64, ptr %peak_commit, align 8
  %78 = load ptr, ptr %out3, align 8
  %79 = load ptr, ptr %arg4, align 8
  call void @mi_printf_amount(i64 noundef %77, i64 noundef 1, ptr noundef %78, ptr noundef %79, ptr noundef @.str.123)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %80 = load ptr, ptr %out3, align 8
  %81 = load ptr, ptr %arg4, align 8
  call void (ptr, ptr, ptr, ...) @_mi_fprintf(ptr noundef %80, ptr noundef %81, ptr noundef @.str.125)
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @mi_stats_print(ptr noundef %out) #0 {
entry:
  %out.addr = alloca ptr, align 8
  store ptr %out, ptr %out.addr, align 8
  %0 = load ptr, ptr %out.addr, align 8
  call void @mi_stats_print_out(ptr noundef %0, ptr noundef null)
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @mi_thread_stats_print_out(ptr noundef %out, ptr noundef %arg) #0 {
entry:
  %out.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  store ptr %out, ptr %out.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %call = call ptr @mi_stats_get_default()
  %0 = load ptr, ptr %out.addr, align 8
  %1 = load ptr, ptr %arg.addr, align 8
  call void @_mi_stats_print(ptr noundef %call, ptr noundef %0, ptr noundef %1)
  ret void
}

; Function Attrs: nounwind uwtable
define hidden i64 @_mi_clock_now() #0 {
entry:
  %call = call i64 @_mi_prim_clock_now()
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define hidden void @mi_process_info(ptr noundef %elapsed_msecs, ptr noundef %user_msecs, ptr noundef %system_msecs, ptr noundef %current_rss, ptr noundef %peak_rss, ptr noundef %current_commit, ptr noundef %peak_commit, ptr noundef %page_faults) #0 {
entry:
  %elapsed_msecs.addr = alloca ptr, align 8
  %user_msecs.addr = alloca ptr, align 8
  %system_msecs.addr = alloca ptr, align 8
  %current_rss.addr = alloca ptr, align 8
  %peak_rss.addr = alloca ptr, align 8
  %current_commit.addr = alloca ptr, align 8
  %peak_commit.addr = alloca ptr, align 8
  %page_faults.addr = alloca ptr, align 8
  %pinfo = alloca %struct.mi_process_info_s, align 8
  %atomic-temp = alloca i64, align 8
  %atomic-temp2 = alloca i64, align 8
  store ptr %elapsed_msecs, ptr %elapsed_msecs.addr, align 8
  store ptr %user_msecs, ptr %user_msecs.addr, align 8
  store ptr %system_msecs, ptr %system_msecs.addr, align 8
  store ptr %current_rss, ptr %current_rss.addr, align 8
  store ptr %peak_rss, ptr %peak_rss.addr, align 8
  store ptr %current_commit, ptr %current_commit.addr, align 8
  store ptr %peak_commit, ptr %peak_commit.addr, align 8
  store ptr %page_faults, ptr %page_faults.addr, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %pinfo, i8 0, i64 64, i1 false)
  %0 = load i64, ptr @mi_process_start, align 8
  %call = call i64 @_mi_clock_end(i64 noundef %0)
  %elapsed = getelementptr inbounds %struct.mi_process_info_s, ptr %pinfo, i32 0, i32 0
  store i64 %call, ptr %elapsed, align 8
  %1 = load atomic i64, ptr getelementptr inbounds (%struct.mi_stats_s, ptr @_mi_stats_main, i32 0, i32 3, i32 3) monotonic, align 8
  store i64 %1, ptr %atomic-temp, align 8
  %2 = load i64, ptr %atomic-temp, align 8
  %current_commit1 = getelementptr inbounds %struct.mi_process_info_s, ptr %pinfo, i32 0, i32 5
  store i64 %2, ptr %current_commit1, align 8
  %3 = load atomic i64, ptr getelementptr inbounds (%struct.mi_stats_s, ptr @_mi_stats_main, i32 0, i32 3, i32 2) monotonic, align 16
  store i64 %3, ptr %atomic-temp2, align 8
  %4 = load i64, ptr %atomic-temp2, align 8
  %peak_commit3 = getelementptr inbounds %struct.mi_process_info_s, ptr %pinfo, i32 0, i32 6
  store i64 %4, ptr %peak_commit3, align 8
  %current_commit4 = getelementptr inbounds %struct.mi_process_info_s, ptr %pinfo, i32 0, i32 5
  %5 = load i64, ptr %current_commit4, align 8
  %current_rss5 = getelementptr inbounds %struct.mi_process_info_s, ptr %pinfo, i32 0, i32 3
  store i64 %5, ptr %current_rss5, align 8
  %peak_commit6 = getelementptr inbounds %struct.mi_process_info_s, ptr %pinfo, i32 0, i32 6
  %6 = load i64, ptr %peak_commit6, align 8
  %peak_rss7 = getelementptr inbounds %struct.mi_process_info_s, ptr %pinfo, i32 0, i32 4
  store i64 %6, ptr %peak_rss7, align 8
  %utime = getelementptr inbounds %struct.mi_process_info_s, ptr %pinfo, i32 0, i32 1
  store i64 0, ptr %utime, align 8
  %stime = getelementptr inbounds %struct.mi_process_info_s, ptr %pinfo, i32 0, i32 2
  store i64 0, ptr %stime, align 8
  %page_faults8 = getelementptr inbounds %struct.mi_process_info_s, ptr %pinfo, i32 0, i32 7
  store i64 0, ptr %page_faults8, align 8
  call void @_mi_prim_process_info(ptr noundef %pinfo)
  %7 = load ptr, ptr %elapsed_msecs.addr, align 8
  %cmp = icmp ne ptr %7, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %elapsed9 = getelementptr inbounds %struct.mi_process_info_s, ptr %pinfo, i32 0, i32 0
  %8 = load i64, ptr %elapsed9, align 8
  %cmp10 = icmp slt i64 %8, 0
  br i1 %cmp10, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  br label %cond.end16

cond.false:                                       ; preds = %if.then
  %elapsed11 = getelementptr inbounds %struct.mi_process_info_s, ptr %pinfo, i32 0, i32 0
  %9 = load i64, ptr %elapsed11, align 8
  %cmp12 = icmp slt i64 %9, 9223372036854775807
  br i1 %cmp12, label %cond.true13, label %cond.false15

cond.true13:                                      ; preds = %cond.false
  %elapsed14 = getelementptr inbounds %struct.mi_process_info_s, ptr %pinfo, i32 0, i32 0
  %10 = load i64, ptr %elapsed14, align 8
  br label %cond.end

cond.false15:                                     ; preds = %cond.false
  br label %cond.end

cond.end:                                         ; preds = %cond.false15, %cond.true13
  %cond = phi i64 [ %10, %cond.true13 ], [ 9223372036854775807, %cond.false15 ]
  br label %cond.end16

cond.end16:                                       ; preds = %cond.end, %cond.true
  %cond17 = phi i64 [ 0, %cond.true ], [ %cond, %cond.end ]
  %11 = load ptr, ptr %elapsed_msecs.addr, align 8
  store i64 %cond17, ptr %11, align 8
  br label %if.end

if.end:                                           ; preds = %cond.end16, %entry
  %12 = load ptr, ptr %user_msecs.addr, align 8
  %cmp18 = icmp ne ptr %12, null
  br i1 %cmp18, label %if.then19, label %if.end33

if.then19:                                        ; preds = %if.end
  %utime20 = getelementptr inbounds %struct.mi_process_info_s, ptr %pinfo, i32 0, i32 1
  %13 = load i64, ptr %utime20, align 8
  %cmp21 = icmp slt i64 %13, 0
  br i1 %cmp21, label %cond.true22, label %cond.false23

cond.true22:                                      ; preds = %if.then19
  br label %cond.end31

cond.false23:                                     ; preds = %if.then19
  %utime24 = getelementptr inbounds %struct.mi_process_info_s, ptr %pinfo, i32 0, i32 1
  %14 = load i64, ptr %utime24, align 8
  %cmp25 = icmp slt i64 %14, 9223372036854775807
  br i1 %cmp25, label %cond.true26, label %cond.false28

cond.true26:                                      ; preds = %cond.false23
  %utime27 = getelementptr inbounds %struct.mi_process_info_s, ptr %pinfo, i32 0, i32 1
  %15 = load i64, ptr %utime27, align 8
  br label %cond.end29

cond.false28:                                     ; preds = %cond.false23
  br label %cond.end29

cond.end29:                                       ; preds = %cond.false28, %cond.true26
  %cond30 = phi i64 [ %15, %cond.true26 ], [ 9223372036854775807, %cond.false28 ]
  br label %cond.end31

cond.end31:                                       ; preds = %cond.end29, %cond.true22
  %cond32 = phi i64 [ 0, %cond.true22 ], [ %cond30, %cond.end29 ]
  %16 = load ptr, ptr %user_msecs.addr, align 8
  store i64 %cond32, ptr %16, align 8
  br label %if.end33

if.end33:                                         ; preds = %cond.end31, %if.end
  %17 = load ptr, ptr %system_msecs.addr, align 8
  %cmp34 = icmp ne ptr %17, null
  br i1 %cmp34, label %if.then35, label %if.end49

if.then35:                                        ; preds = %if.end33
  %stime36 = getelementptr inbounds %struct.mi_process_info_s, ptr %pinfo, i32 0, i32 2
  %18 = load i64, ptr %stime36, align 8
  %cmp37 = icmp slt i64 %18, 0
  br i1 %cmp37, label %cond.true38, label %cond.false39

cond.true38:                                      ; preds = %if.then35
  br label %cond.end47

cond.false39:                                     ; preds = %if.then35
  %stime40 = getelementptr inbounds %struct.mi_process_info_s, ptr %pinfo, i32 0, i32 2
  %19 = load i64, ptr %stime40, align 8
  %cmp41 = icmp slt i64 %19, 9223372036854775807
  br i1 %cmp41, label %cond.true42, label %cond.false44

cond.true42:                                      ; preds = %cond.false39
  %stime43 = getelementptr inbounds %struct.mi_process_info_s, ptr %pinfo, i32 0, i32 2
  %20 = load i64, ptr %stime43, align 8
  br label %cond.end45

cond.false44:                                     ; preds = %cond.false39
  br label %cond.end45

cond.end45:                                       ; preds = %cond.false44, %cond.true42
  %cond46 = phi i64 [ %20, %cond.true42 ], [ 9223372036854775807, %cond.false44 ]
  br label %cond.end47

cond.end47:                                       ; preds = %cond.end45, %cond.true38
  %cond48 = phi i64 [ 0, %cond.true38 ], [ %cond46, %cond.end45 ]
  %21 = load ptr, ptr %system_msecs.addr, align 8
  store i64 %cond48, ptr %21, align 8
  br label %if.end49

if.end49:                                         ; preds = %cond.end47, %if.end33
  %22 = load ptr, ptr %current_rss.addr, align 8
  %cmp50 = icmp ne ptr %22, null
  br i1 %cmp50, label %if.then51, label %if.end53

if.then51:                                        ; preds = %if.end49
  %current_rss52 = getelementptr inbounds %struct.mi_process_info_s, ptr %pinfo, i32 0, i32 3
  %23 = load i64, ptr %current_rss52, align 8
  %24 = load ptr, ptr %current_rss.addr, align 8
  store i64 %23, ptr %24, align 8
  br label %if.end53

if.end53:                                         ; preds = %if.then51, %if.end49
  %25 = load ptr, ptr %peak_rss.addr, align 8
  %cmp54 = icmp ne ptr %25, null
  br i1 %cmp54, label %if.then55, label %if.end57

if.then55:                                        ; preds = %if.end53
  %peak_rss56 = getelementptr inbounds %struct.mi_process_info_s, ptr %pinfo, i32 0, i32 4
  %26 = load i64, ptr %peak_rss56, align 8
  %27 = load ptr, ptr %peak_rss.addr, align 8
  store i64 %26, ptr %27, align 8
  br label %if.end57

if.end57:                                         ; preds = %if.then55, %if.end53
  %28 = load ptr, ptr %current_commit.addr, align 8
  %cmp58 = icmp ne ptr %28, null
  br i1 %cmp58, label %if.then59, label %if.end61

if.then59:                                        ; preds = %if.end57
  %current_commit60 = getelementptr inbounds %struct.mi_process_info_s, ptr %pinfo, i32 0, i32 5
  %29 = load i64, ptr %current_commit60, align 8
  %30 = load ptr, ptr %current_commit.addr, align 8
  store i64 %29, ptr %30, align 8
  br label %if.end61

if.end61:                                         ; preds = %if.then59, %if.end57
  %31 = load ptr, ptr %peak_commit.addr, align 8
  %cmp62 = icmp ne ptr %31, null
  br i1 %cmp62, label %if.then63, label %if.end65

if.then63:                                        ; preds = %if.end61
  %peak_commit64 = getelementptr inbounds %struct.mi_process_info_s, ptr %pinfo, i32 0, i32 6
  %32 = load i64, ptr %peak_commit64, align 8
  %33 = load ptr, ptr %peak_commit.addr, align 8
  store i64 %32, ptr %33, align 8
  br label %if.end65

if.end65:                                         ; preds = %if.then63, %if.end61
  %34 = load ptr, ptr %page_faults.addr, align 8
  %cmp66 = icmp ne ptr %34, null
  br i1 %cmp66, label %if.then67, label %if.end69

if.then67:                                        ; preds = %if.end65
  %page_faults68 = getelementptr inbounds %struct.mi_process_info_s, ptr %pinfo, i32 0, i32 7
  %35 = load i64, ptr %page_faults68, align 8
  %36 = load ptr, ptr %page_faults.addr, align 8
  store i64 %35, ptr %36, align 8
  br label %if.end69

if.end69:                                         ; preds = %if.then67, %if.end65
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_prim_process_info(ptr noundef %pinfo) #0 {
entry:
  %pinfo.addr = alloca ptr, align 8
  %rusage = alloca %struct.rusage, align 8
  store ptr %pinfo, ptr %pinfo.addr, align 8
  %call = call i32 @getrusage(i32 noundef 0, ptr noundef %rusage) #15
  %ru_utime = getelementptr inbounds %struct.rusage, ptr %rusage, i32 0, i32 0
  %call1 = call i64 @timeval_secs(ptr noundef %ru_utime)
  %0 = load ptr, ptr %pinfo.addr, align 8
  %utime = getelementptr inbounds %struct.mi_process_info_s, ptr %0, i32 0, i32 1
  store i64 %call1, ptr %utime, align 8
  %ru_stime = getelementptr inbounds %struct.rusage, ptr %rusage, i32 0, i32 1
  %call2 = call i64 @timeval_secs(ptr noundef %ru_stime)
  %1 = load ptr, ptr %pinfo.addr, align 8
  %stime = getelementptr inbounds %struct.mi_process_info_s, ptr %1, i32 0, i32 2
  store i64 %call2, ptr %stime, align 8
  %2 = getelementptr inbounds %struct.rusage, ptr %rusage, i32 0, i32 7
  %3 = load i64, ptr %2, align 8
  %4 = load ptr, ptr %pinfo.addr, align 8
  %page_faults = getelementptr inbounds %struct.mi_process_info_s, ptr %4, i32 0, i32 7
  store i64 %3, ptr %page_faults, align 8
  %5 = getelementptr inbounds %struct.rusage, ptr %rusage, i32 0, i32 2
  %6 = load i64, ptr %5, align 8
  %mul = mul i64 %6, 1024
  %7 = load ptr, ptr %pinfo.addr, align 8
  %peak_rss = getelementptr inbounds %struct.mi_process_info_s, ptr %7, i32 0, i32 4
  store i64 %mul, ptr %peak_rss, align 8
  ret void
}

; Function Attrs: nounwind
declare i64 @sysconf(i32 noundef) #2

; Function Attrs: nounwind uwtable
define internal zeroext i1 @unix_detect_overcommit() #0 {
entry:
  %os_overcommit = alloca i8, align 1
  %fd = alloca i32, align 4
  %buf = alloca [32 x i8], align 16
  %nread = alloca i64, align 8
  store i8 1, ptr %os_overcommit, align 1
  %call = call i32 @mi_prim_open(ptr noundef @.str.151, i32 noundef 0)
  store i32 %call, ptr %fd, align 4
  %0 = load i32, ptr %fd, align 4
  %cmp = icmp sge i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end11

if.then:                                          ; preds = %entry
  call void @llvm.memset.p0.i64(ptr align 16 %buf, i8 0, i64 32, i1 false)
  %1 = load i32, ptr %fd, align 4
  %call1 = call i64 @mi_prim_read(i32 noundef %1, ptr noundef %buf, i64 noundef 32)
  store i64 %call1, ptr %nread, align 8
  %2 = load i32, ptr %fd, align 4
  %call2 = call i32 @mi_prim_close(i32 noundef %2)
  %3 = load i64, ptr %nread, align 8
  %cmp3 = icmp sge i64 %3, 1
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  %arrayidx = getelementptr [32 x i8], ptr %buf, i64 0, i64 0
  %4 = load i8, ptr %arrayidx, align 16
  %conv = sext i8 %4 to i32
  %cmp5 = icmp eq i32 %conv, 48
  br i1 %cmp5, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.then4
  %arrayidx7 = getelementptr [32 x i8], ptr %buf, i64 0, i64 0
  %5 = load i8, ptr %arrayidx7, align 16
  %conv8 = sext i8 %5 to i32
  %cmp9 = icmp eq i32 %conv8, 49
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.then4
  %6 = phi i1 [ true, %if.then4 ], [ %cmp9, %lor.rhs ]
  %frombool = zext i1 %6 to i8
  store i8 %frombool, ptr %os_overcommit, align 1
  br label %if.end

if.end:                                           ; preds = %lor.end, %if.then
  br label %if.end11

if.end11:                                         ; preds = %if.end, %entry
  %7 = load i8, ptr %os_overcommit, align 1
  %tobool = trunc i8 %7 to i1
  ret i1 %tobool
}

; Function Attrs: nounwind uwtable
define hidden i32 @_mi_prim_free(ptr noundef %addr, i64 noundef %size) #0 {
entry:
  %addr.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %err = alloca i8, align 1
  store ptr %addr, ptr %addr.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load ptr, ptr %addr.addr, align 8
  %1 = load i64, ptr %size.addr, align 8
  %call = call i32 @munmap(ptr noundef %0, i64 noundef %1) #15
  %cmp = icmp eq i32 %call, -1
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, ptr %err, align 1
  %2 = load i8, ptr %err, align 1
  %tobool = trunc i8 %2 to i1
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %call1 = call ptr @__errno_location() #18
  %3 = load i32, ptr %call1, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %3, %cond.true ], [ 0, %cond.false ]
  ret i32 %cond
}

; Function Attrs: nounwind
declare i32 @munmap(ptr noundef, i64 noundef) #2

; Function Attrs: nounwind uwtable
define hidden i32 @_mi_prim_alloc(i64 noundef %size, i64 noundef %try_alignment, i1 noundef zeroext %commit, i1 noundef zeroext %allow_large, ptr noundef %is_large, ptr noundef %is_zero, ptr noundef %addr) #0 {
entry:
  %size.addr = alloca i64, align 8
  %try_alignment.addr = alloca i64, align 8
  %commit.addr = alloca i8, align 1
  %allow_large.addr = alloca i8, align 1
  %is_large.addr = alloca ptr, align 8
  %is_zero.addr = alloca ptr, align 8
  %addr.addr = alloca ptr, align 8
  %protect_flags = alloca i32, align 4
  store i64 %size, ptr %size.addr, align 8
  store i64 %try_alignment, ptr %try_alignment.addr, align 8
  %frombool = zext i1 %commit to i8
  store i8 %frombool, ptr %commit.addr, align 1
  %frombool1 = zext i1 %allow_large to i8
  store i8 %frombool1, ptr %allow_large.addr, align 1
  store ptr %is_large, ptr %is_large.addr, align 8
  store ptr %is_zero, ptr %is_zero.addr, align 8
  store ptr %addr, ptr %addr.addr, align 8
  %0 = load ptr, ptr %is_zero.addr, align 8
  store i8 1, ptr %0, align 1
  %1 = load i8, ptr %commit.addr, align 1
  %tobool = trunc i8 %1 to i1
  %cond = select i1 %tobool, i32 3, i32 0
  store i32 %cond, ptr %protect_flags, align 4
  %2 = load i64, ptr %size.addr, align 8
  %3 = load i64, ptr %try_alignment.addr, align 8
  %4 = load i32, ptr %protect_flags, align 4
  %5 = load i8, ptr %allow_large.addr, align 1
  %tobool2 = trunc i8 %5 to i1
  %6 = load ptr, ptr %is_large.addr, align 8
  %call = call ptr @unix_mmap(ptr noundef null, i64 noundef %2, i64 noundef %3, i32 noundef %4, i1 noundef zeroext false, i1 noundef zeroext %tobool2, ptr noundef %6)
  %7 = load ptr, ptr %addr.addr, align 8
  store ptr %call, ptr %7, align 8
  %8 = load ptr, ptr %addr.addr, align 8
  %9 = load ptr, ptr %8, align 8
  %cmp = icmp ne ptr %9, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call3 = call ptr @__errno_location() #18
  %10 = load i32, ptr %call3, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond4 = phi i32 [ 0, %cond.true ], [ %10, %cond.false ]
  ret i32 %cond4
}

; Function Attrs: nounwind uwtable
define internal ptr @unix_mmap(ptr noundef %addr, i64 noundef %size, i64 noundef %try_alignment, i32 noundef %protect_flags, i1 noundef zeroext %large_only, i1 noundef zeroext %allow_large, ptr noundef %is_large) #0 {
entry:
  %retval = alloca ptr, align 8
  %addr.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %try_alignment.addr = alloca i64, align 8
  %protect_flags.addr = alloca i32, align 4
  %large_only.addr = alloca i8, align 1
  %allow_large.addr = alloca i8, align 1
  %is_large.addr = alloca ptr, align 8
  %p = alloca ptr, align 8
  %fd = alloca i32, align 4
  %flags = alloca i32, align 4
  %try_ok = alloca i64, align 8
  %atomic-temp = alloca i64, align 8
  %.atomictmp = alloca i64, align 8
  %cmpxchg.bool = alloca i8, align 1
  %lflags = alloca i32, align 4
  %lfd = alloca i32, align 4
  %.atomictmp40 = alloca i64, align 8
  store ptr %addr, ptr %addr.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store i64 %try_alignment, ptr %try_alignment.addr, align 8
  store i32 %protect_flags, ptr %protect_flags.addr, align 4
  %frombool = zext i1 %large_only to i8
  store i8 %frombool, ptr %large_only.addr, align 1
  %frombool1 = zext i1 %allow_large to i8
  store i8 %frombool1, ptr %allow_large.addr, align 1
  store ptr %is_large, ptr %is_large.addr, align 8
  store ptr null, ptr %p, align 8
  %call = call i32 @unix_mmap_fd()
  store i32 %call, ptr %fd, align 4
  store i32 34, ptr %flags, align 4
  %call2 = call zeroext i1 @_mi_os_has_overcommit()
  br i1 %call2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %0 = load i32, ptr %flags, align 4
  %or = or i32 %0, 16384
  store i32 %or, ptr %flags, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = load i8, ptr %large_only.addr, align 1
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %2 = load i64, ptr %size.addr, align 8
  %3 = load i64, ptr %try_alignment.addr, align 8
  %call3 = call zeroext i1 @_mi_os_use_large_page(i64 noundef %2, i64 noundef %3)
  br i1 %call3, label %land.lhs.true, label %if.end44

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.end
  %4 = load i8, ptr %allow_large.addr, align 1
  %tobool4 = trunc i8 %4 to i1
  br i1 %tobool4, label %if.then5, label %if.end44

if.then5:                                         ; preds = %land.lhs.true
  %5 = load atomic i64, ptr @unix_mmap.large_page_try_ok acquire, align 8
  store i64 %5, ptr %atomic-temp, align 8
  %6 = load i64, ptr %atomic-temp, align 8
  store i64 %6, ptr %try_ok, align 8
  %7 = load i8, ptr %large_only.addr, align 1
  %tobool6 = trunc i8 %7 to i1
  br i1 %tobool6, label %if.else, label %land.lhs.true7

land.lhs.true7:                                   ; preds = %if.then5
  %8 = load i64, ptr %try_ok, align 8
  %cmp = icmp ugt i64 %8, 0
  br i1 %cmp, label %if.then8, label %if.else

if.then8:                                         ; preds = %land.lhs.true7
  %9 = load i64, ptr %try_ok, align 8
  %sub = sub i64 %9, 1
  store i64 %sub, ptr %.atomictmp, align 8
  %10 = load i64, ptr %try_ok, align 8
  %11 = load i64, ptr %.atomictmp, align 8
  %12 = cmpxchg ptr @unix_mmap.large_page_try_ok, i64 %10, i64 %11 acq_rel acquire, align 8
  %13 = extractvalue { i64, i1 } %12, 0
  %14 = extractvalue { i64, i1 } %12, 1
  br i1 %14, label %cmpxchg.continue, label %cmpxchg.store_expected

cmpxchg.store_expected:                           ; preds = %if.then8
  store i64 %13, ptr %try_ok, align 8
  br label %cmpxchg.continue

cmpxchg.continue:                                 ; preds = %cmpxchg.store_expected, %if.then8
  %frombool9 = zext i1 %14 to i8
  store i8 %frombool9, ptr %cmpxchg.bool, align 1
  br label %if.end43

if.else:                                          ; preds = %land.lhs.true7, %if.then5
  %15 = load i32, ptr %flags, align 4
  %and = and i32 %15, -16385
  store i32 %and, ptr %lflags, align 4
  %16 = load i32, ptr %fd, align 4
  store i32 %16, ptr %lfd, align 4
  %17 = load i32, ptr %lflags, align 4
  %or11 = or i32 %17, 262144
  store i32 %or11, ptr %lflags, align 4
  %18 = load i64, ptr %size.addr, align 8
  %rem = urem i64 %18, 1073741824
  %cmp12 = icmp eq i64 %rem, 0
  br i1 %cmp12, label %land.lhs.true13, label %if.else17

land.lhs.true13:                                  ; preds = %if.else
  %19 = load i8, ptr @unix_mmap.mi_huge_pages_available, align 1
  %tobool14 = trunc i8 %19 to i1
  br i1 %tobool14, label %if.then15, label %if.else17

if.then15:                                        ; preds = %land.lhs.true13
  %20 = load i32, ptr %lflags, align 4
  %or16 = or i32 %20, 2013265920
  store i32 %or16, ptr %lflags, align 4
  br label %if.end19

if.else17:                                        ; preds = %land.lhs.true13, %if.else
  %21 = load i32, ptr %lflags, align 4
  %or18 = or i32 %21, 1409286144
  store i32 %or18, ptr %lflags, align 4
  br label %if.end19

if.end19:                                         ; preds = %if.else17, %if.then15
  %22 = load i8, ptr %large_only.addr, align 1
  %tobool20 = trunc i8 %22 to i1
  br i1 %tobool20, label %if.then23, label %lor.lhs.false21

lor.lhs.false21:                                  ; preds = %if.end19
  %23 = load i32, ptr %lflags, align 4
  %24 = load i32, ptr %flags, align 4
  %cmp22 = icmp ne i32 %23, %24
  br i1 %cmp22, label %if.then23, label %if.end42

if.then23:                                        ; preds = %lor.lhs.false21, %if.end19
  %25 = load ptr, ptr %is_large.addr, align 8
  store i8 1, ptr %25, align 1
  %26 = load ptr, ptr %addr.addr, align 8
  %27 = load i64, ptr %size.addr, align 8
  %28 = load i64, ptr %try_alignment.addr, align 8
  %29 = load i32, ptr %protect_flags.addr, align 4
  %30 = load i32, ptr %lflags, align 4
  %31 = load i32, ptr %lfd, align 4
  %call24 = call ptr @unix_mmap_prim(ptr noundef %26, i64 noundef %27, i64 noundef %28, i32 noundef %29, i32 noundef %30, i32 noundef %31)
  store ptr %call24, ptr %p, align 8
  %32 = load ptr, ptr %p, align 8
  %cmp25 = icmp eq ptr %32, null
  br i1 %cmp25, label %land.lhs.true26, label %if.end34

land.lhs.true26:                                  ; preds = %if.then23
  %33 = load i32, ptr %lflags, align 4
  %and27 = and i32 %33, 2013265920
  %cmp28 = icmp ne i32 %and27, 0
  br i1 %cmp28, label %if.then29, label %if.end34

if.then29:                                        ; preds = %land.lhs.true26
  store i8 0, ptr @unix_mmap.mi_huge_pages_available, align 1
  %call30 = call ptr @__errno_location() #18
  %34 = load i32, ptr %call30, align 4
  call void (ptr, ...) @_mi_warning_message(ptr noundef @.str.152, i32 noundef %34)
  %35 = load i32, ptr %lflags, align 4
  %and31 = and i32 %35, -2013265921
  %or32 = or i32 %and31, 1409286144
  store i32 %or32, ptr %lflags, align 4
  %36 = load ptr, ptr %addr.addr, align 8
  %37 = load i64, ptr %size.addr, align 8
  %38 = load i64, ptr %try_alignment.addr, align 8
  %39 = load i32, ptr %protect_flags.addr, align 4
  %40 = load i32, ptr %lflags, align 4
  %41 = load i32, ptr %lfd, align 4
  %call33 = call ptr @unix_mmap_prim(ptr noundef %36, i64 noundef %37, i64 noundef %38, i32 noundef %39, i32 noundef %40, i32 noundef %41)
  store ptr %call33, ptr %p, align 8
  br label %if.end34

if.end34:                                         ; preds = %if.then29, %land.lhs.true26, %if.then23
  %42 = load i8, ptr %large_only.addr, align 1
  %tobool35 = trunc i8 %42 to i1
  br i1 %tobool35, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.end34
  %43 = load ptr, ptr %p, align 8
  store ptr %43, ptr %retval, align 8
  br label %return

if.end37:                                         ; preds = %if.end34
  %44 = load ptr, ptr %p, align 8
  %cmp38 = icmp eq ptr %44, null
  br i1 %cmp38, label %if.then39, label %if.end41

if.then39:                                        ; preds = %if.end37
  store i64 8, ptr %.atomictmp40, align 8
  %45 = load i64, ptr %.atomictmp40, align 8
  store atomic i64 %45, ptr @unix_mmap.large_page_try_ok release, align 8
  br label %if.end41

if.end41:                                         ; preds = %if.then39, %if.end37
  br label %if.end42

if.end42:                                         ; preds = %if.end41, %lor.lhs.false21
  br label %if.end43

if.end43:                                         ; preds = %if.end42, %cmpxchg.continue
  br label %if.end44

if.end44:                                         ; preds = %if.end43, %land.lhs.true, %lor.lhs.false
  %46 = load ptr, ptr %p, align 8
  %cmp45 = icmp eq ptr %46, null
  br i1 %cmp45, label %if.then46, label %if.end60

if.then46:                                        ; preds = %if.end44
  %47 = load ptr, ptr %is_large.addr, align 8
  store i8 0, ptr %47, align 1
  %48 = load ptr, ptr %addr.addr, align 8
  %49 = load i64, ptr %size.addr, align 8
  %50 = load i64, ptr %try_alignment.addr, align 8
  %51 = load i32, ptr %protect_flags.addr, align 4
  %52 = load i32, ptr %flags, align 4
  %53 = load i32, ptr %fd, align 4
  %call47 = call ptr @unix_mmap_prim(ptr noundef %48, i64 noundef %49, i64 noundef %50, i32 noundef %51, i32 noundef %52, i32 noundef %53)
  store ptr %call47, ptr %p, align 8
  %54 = load ptr, ptr %p, align 8
  %cmp48 = icmp ne ptr %54, null
  br i1 %cmp48, label %if.then49, label %if.end59

if.then49:                                        ; preds = %if.then46
  %55 = load i8, ptr %allow_large.addr, align 1
  %tobool50 = trunc i8 %55 to i1
  br i1 %tobool50, label %land.lhs.true51, label %if.end58

land.lhs.true51:                                  ; preds = %if.then49
  %56 = load i64, ptr %size.addr, align 8
  %57 = load i64, ptr %try_alignment.addr, align 8
  %call52 = call zeroext i1 @_mi_os_use_large_page(i64 noundef %56, i64 noundef %57)
  br i1 %call52, label %if.then53, label %if.end58

if.then53:                                        ; preds = %land.lhs.true51
  %58 = load ptr, ptr %p, align 8
  %59 = load i64, ptr %size.addr, align 8
  %call54 = call i32 @unix_madvise(ptr noundef %58, i64 noundef %59, i32 noundef 14)
  %cmp55 = icmp eq i32 %call54, 0
  br i1 %cmp55, label %if.then56, label %if.end57

if.then56:                                        ; preds = %if.then53
  %60 = load ptr, ptr %is_large.addr, align 8
  store i8 1, ptr %60, align 1
  br label %if.end57

if.end57:                                         ; preds = %if.then56, %if.then53
  br label %if.end58

if.end58:                                         ; preds = %if.end57, %land.lhs.true51, %if.then49
  br label %if.end59

if.end59:                                         ; preds = %if.end58, %if.then46
  br label %if.end60

if.end60:                                         ; preds = %if.end59, %if.end44
  %61 = load ptr, ptr %p, align 8
  store ptr %61, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end60, %if.then36
  %62 = load ptr, ptr %retval, align 8
  ret ptr %62
}

; Function Attrs: nounwind
declare i32 @mprotect(ptr noundef, i64 noundef, i32 noundef) #2

; Function Attrs: nounwind uwtable
define internal void @unix_mprotect_hint(i32 noundef %err) #0 {
entry:
  %err.addr = alloca i32, align 4
  store i32 %err, ptr %err.addr, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define hidden i32 @_mi_prim_decommit(ptr noundef %start, i64 noundef %size, ptr noundef %needs_recommit) #0 {
entry:
  %start.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %needs_recommit.addr = alloca ptr, align 8
  %err = alloca i32, align 4
  store ptr %start, ptr %start.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store ptr %needs_recommit, ptr %needs_recommit.addr, align 8
  store i32 0, ptr %err, align 4
  %0 = load ptr, ptr %start.addr, align 8
  %1 = load i64, ptr %size.addr, align 8
  %call = call i32 @unix_madvise(ptr noundef %0, i64 noundef %1, i32 noundef 4)
  store i32 %call, ptr %err, align 4
  %2 = load ptr, ptr %needs_recommit.addr, align 8
  store i8 0, ptr %2, align 1
  %3 = load i32, ptr %err, align 4
  ret i32 %3
}

; Function Attrs: nounwind uwtable
define internal i32 @unix_madvise(ptr noundef %addr, i64 noundef %size, i32 noundef %advice) #0 {
entry:
  %addr.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %advice.addr = alloca i32, align 4
  store ptr %addr, ptr %addr.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store i32 %advice, ptr %advice.addr, align 4
  %0 = load ptr, ptr %addr.addr, align 8
  %1 = load i64, ptr %size.addr, align 8
  %2 = load i32, ptr %advice.addr, align 4
  %call = call i32 @madvise(ptr noundef %0, i64 noundef %1, i32 noundef %2) #15
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define hidden i32 @_mi_prim_protect(ptr noundef %start, i64 noundef %size, i1 noundef zeroext %protect) #0 {
entry:
  %start.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %protect.addr = alloca i8, align 1
  %err = alloca i32, align 4
  store ptr %start, ptr %start.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %frombool = zext i1 %protect to i8
  store i8 %frombool, ptr %protect.addr, align 1
  %0 = load ptr, ptr %start.addr, align 8
  %1 = load i64, ptr %size.addr, align 8
  %2 = load i8, ptr %protect.addr, align 1
  %tobool = trunc i8 %2 to i1
  %cond = select i1 %tobool, i32 0, i32 3
  %call = call i32 @mprotect(ptr noundef %0, i64 noundef %1, i32 noundef %cond) #15
  store i32 %call, ptr %err, align 4
  %3 = load i32, ptr %err, align 4
  %cmp = icmp ne i32 %3, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call ptr @__errno_location() #18
  %4 = load i32, ptr %call1, align 4
  store i32 %4, ptr %err, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load i32, ptr %err, align 4
  call void @unix_mprotect_hint(i32 noundef %5)
  %6 = load i32, ptr %err, align 4
  ret i32 %6
}

; Function Attrs: nounwind uwtable
define internal i64 @mi_prim_mbind(ptr noundef %start, i64 noundef %len, i64 noundef %mode, ptr noundef %nmask, i64 noundef %maxnode, i32 noundef %flags) #0 {
entry:
  %start.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  %mode.addr = alloca i64, align 8
  %nmask.addr = alloca ptr, align 8
  %maxnode.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  store ptr %start, ptr %start.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  store i64 %mode, ptr %mode.addr, align 8
  store ptr %nmask, ptr %nmask.addr, align 8
  store i64 %maxnode, ptr %maxnode.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  %0 = load ptr, ptr %start.addr, align 8
  %1 = load i64, ptr %len.addr, align 8
  %2 = load i64, ptr %mode.addr, align 8
  %3 = load ptr, ptr %nmask.addr, align 8
  %4 = load i64, ptr %maxnode.addr, align 8
  %5 = load i32, ptr %flags.addr, align 4
  %call = call i64 (i64, ...) @syscall(i64 noundef 237, ptr noundef %0, i64 noundef %1, i64 noundef %2, ptr noundef %3, i64 noundef %4, i32 noundef %5) #15
  ret i64 %call
}

; Function Attrs: nounwind
declare i64 @syscall(i64 noundef, ...) #2

; Function Attrs: nounwind
declare i32 @snprintf(ptr noundef, i64 noundef, ptr noundef, ...) #2

; Function Attrs: nounwind uwtable
define internal i32 @mi_prim_access(ptr noundef %fpath, i32 noundef %mode) #0 {
entry:
  %fpath.addr = alloca ptr, align 8
  %mode.addr = alloca i32, align 4
  store ptr %fpath, ptr %fpath.addr, align 8
  store i32 %mode, ptr %mode.addr, align 4
  %0 = load ptr, ptr %fpath.addr, align 8
  %1 = load i32, ptr %mode.addr, align 4
  %call = call i64 (i64, ...) @syscall(i64 noundef 21, ptr noundef %0, i32 noundef %1) #15
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind
declare i32 @clock_gettime(i32 noundef, ptr noundef) #2

; Function Attrs: nounwind
declare i32 @getrusage(i32 noundef, ptr noundef) #2

; Function Attrs: nounwind uwtable
define internal i64 @timeval_secs(ptr noundef %tv) #0 {
entry:
  %tv.addr = alloca ptr, align 8
  store ptr %tv, ptr %tv.addr, align 8
  %0 = load ptr, ptr %tv.addr, align 8
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %0, i32 0, i32 0
  %1 = load i64, ptr %tv_sec, align 8
  %mul = mul i64 %1, 1000
  %2 = load ptr, ptr %tv.addr, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %2, i32 0, i32 1
  %3 = load i64, ptr %tv_usec, align 8
  %div = sdiv i64 %3, 1000
  %add = add i64 %mul, %div
  ret i64 %add
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_prim_out_stderr(ptr noundef %msg) #0 {
entry:
  %msg.addr = alloca ptr, align 8
  store ptr %msg, ptr %msg.addr, align 8
  %0 = load ptr, ptr %msg.addr, align 8
  %1 = load ptr, ptr @stderr, align 8
  %call = call i32 @fputs(ptr noundef %0, ptr noundef %1)
  ret void
}

declare i32 @fputs(ptr noundef, ptr noundef) #8

; Function Attrs: nounwind uwtable
define hidden zeroext i1 @_mi_prim_getenv(ptr noundef %name, ptr noundef %result, i64 noundef %result_size) #0 {
entry:
  %retval = alloca i1, align 1
  %name.addr = alloca ptr, align 8
  %result.addr = alloca ptr, align 8
  %result_size.addr = alloca i64, align 8
  %len = alloca i64, align 8
  %env = alloca ptr, align 8
  %i = alloca i32, align 4
  %s = alloca ptr, align 8
  store ptr %name, ptr %name.addr, align 8
  store ptr %result, ptr %result.addr, align 8
  store i64 %result_size, ptr %result_size.addr, align 8
  %0 = load ptr, ptr %name.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %name.addr, align 8
  %call = call i64 @_mi_strlen(ptr noundef %1)
  store i64 %call, ptr %len, align 8
  %2 = load i64, ptr %len, align 8
  %cmp1 = icmp eq i64 %2, 0
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i1 false, ptr %retval, align 1
  br label %return

if.end3:                                          ; preds = %if.end
  %call4 = call ptr @mi_get_environ()
  store ptr %call4, ptr %env, align 8
  %3 = load ptr, ptr %env, align 8
  %cmp5 = icmp eq ptr %3, null
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end3
  store i1 false, ptr %retval, align 1
  br label %return

if.end7:                                          ; preds = %if.end3
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end7
  %4 = load i32, ptr %i, align 4
  %cmp8 = icmp slt i32 %4, 10000
  br i1 %cmp8, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %5 = load ptr, ptr %env, align 8
  %6 = load i32, ptr %i, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr ptr, ptr %5, i64 %idxprom
  %7 = load ptr, ptr %arrayidx, align 8
  %cmp9 = icmp ne ptr %7, null
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %8 = phi i1 [ false, %for.cond ], [ %cmp9, %land.rhs ]
  br i1 %8, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %9 = load ptr, ptr %env, align 8
  %10 = load i32, ptr %i, align 4
  %idxprom10 = sext i32 %10 to i64
  %arrayidx11 = getelementptr ptr, ptr %9, i64 %idxprom10
  %11 = load ptr, ptr %arrayidx11, align 8
  store ptr %11, ptr %s, align 8
  %12 = load ptr, ptr %name.addr, align 8
  %13 = load ptr, ptr %s, align 8
  %14 = load i64, ptr %len, align 8
  %call12 = call i32 @_mi_strnicmp(ptr noundef %12, ptr noundef %13, i64 noundef %14)
  %cmp13 = icmp eq i32 %call12, 0
  br i1 %cmp13, label %land.lhs.true, label %if.end19

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %s, align 8
  %16 = load i64, ptr %len, align 8
  %arrayidx14 = getelementptr i8, ptr %15, i64 %16
  %17 = load i8, ptr %arrayidx14, align 1
  %conv = sext i8 %17 to i32
  %cmp15 = icmp eq i32 %conv, 61
  br i1 %cmp15, label %if.then17, label %if.end19

if.then17:                                        ; preds = %land.lhs.true
  %18 = load ptr, ptr %result.addr, align 8
  %19 = load ptr, ptr %s, align 8
  %20 = load i64, ptr %len, align 8
  %add.ptr = getelementptr i8, ptr %19, i64 %20
  %add.ptr18 = getelementptr i8, ptr %add.ptr, i64 1
  %21 = load i64, ptr %result_size.addr, align 8
  call void @_mi_strlcpy(ptr noundef %18, ptr noundef %add.ptr18, i64 noundef %21)
  store i1 true, ptr %retval, align 1
  br label %return

if.end19:                                         ; preds = %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end19
  %22 = load i32, ptr %i, align 4
  %inc = add i32 %22, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !89

for.end:                                          ; preds = %land.end
  store i1 false, ptr %retval, align 1
  br label %return

return:                                           ; preds = %for.end, %if.then17, %if.then6, %if.then2, %if.then
  %23 = load i1, ptr %retval, align 1
  ret i1 %23
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_get_environ() #0 {
entry:
  %0 = load ptr, ptr @environ, align 8
  ret ptr %0
}

; Function Attrs: nounwind uwtable
define hidden zeroext i1 @_mi_prim_random_buf(ptr noundef %buf, i64 noundef %buf_len) #0 {
entry:
  %retval = alloca i1, align 1
  %buf.addr = alloca ptr, align 8
  %buf_len.addr = alloca i64, align 8
  %atomic-temp = alloca i64, align 8
  %ret = alloca i64, align 8
  %.atomictmp = alloca i64, align 8
  %flags = alloca i32, align 4
  %fd = alloca i32, align 4
  %count = alloca i64, align 8
  %ret14 = alloca i64, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store i64 %buf_len, ptr %buf_len.addr, align 8
  %0 = load atomic i64, ptr @_mi_prim_random_buf.no_getrandom acquire, align 8
  store i64 %0, ptr %atomic-temp, align 8
  %1 = load i64, ptr %atomic-temp, align 8
  %cmp = icmp eq i64 %1, 0
  br i1 %cmp, label %if.then, label %if.end8

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %buf.addr, align 8
  %3 = load i64, ptr %buf_len.addr, align 8
  %call = call i64 (i64, ...) @syscall(i64 noundef 318, ptr noundef %2, i64 noundef %3, i32 noundef 1) #15
  store i64 %call, ptr %ret, align 8
  %4 = load i64, ptr %ret, align 8
  %cmp1 = icmp sge i64 %4, 0
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %5 = load i64, ptr %buf_len.addr, align 8
  %6 = load i64, ptr %ret, align 8
  %cmp3 = icmp eq i64 %5, %6
  store i1 %cmp3, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %if.then
  %call4 = call ptr @__errno_location() #18
  %7 = load i32, ptr %call4, align 4
  %cmp5 = icmp ne i32 %7, 38
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  store i1 false, ptr %retval, align 1
  br label %return

if.end7:                                          ; preds = %if.end
  store i64 1, ptr %.atomictmp, align 8
  %8 = load i64, ptr %.atomictmp, align 8
  store atomic i64 %8, ptr @_mi_prim_random_buf.no_getrandom release, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.end7, %entry
  store i32 0, ptr %flags, align 4
  %9 = load i32, ptr %flags, align 4
  %or = or i32 %9, 524288
  store i32 %or, ptr %flags, align 4
  %10 = load i32, ptr %flags, align 4
  %call9 = call i32 @mi_prim_open(ptr noundef @.str.33, i32 noundef %10)
  store i32 %call9, ptr %fd, align 4
  %11 = load i32, ptr %fd, align 4
  %cmp10 = icmp slt i32 %11, 0
  br i1 %cmp10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end8
  store i1 false, ptr %retval, align 1
  br label %return

if.end12:                                         ; preds = %if.end8
  store i64 0, ptr %count, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end24, %if.end12
  %12 = load i64, ptr %count, align 8
  %13 = load i64, ptr %buf_len.addr, align 8
  %cmp13 = icmp ult i64 %12, %13
  br i1 %cmp13, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %14 = load i32, ptr %fd, align 4
  %15 = load ptr, ptr %buf.addr, align 8
  %16 = load i64, ptr %count, align 8
  %add.ptr = getelementptr i8, ptr %15, i64 %16
  %17 = load i64, ptr %buf_len.addr, align 8
  %18 = load i64, ptr %count, align 8
  %sub = sub i64 %17, %18
  %call15 = call i64 @mi_prim_read(i32 noundef %14, ptr noundef %add.ptr, i64 noundef %sub)
  store i64 %call15, ptr %ret14, align 8
  %19 = load i64, ptr %ret14, align 8
  %cmp16 = icmp sle i64 %19, 0
  br i1 %cmp16, label %if.then17, label %if.else

if.then17:                                        ; preds = %while.body
  %call18 = call ptr @__errno_location() #18
  %20 = load i32, ptr %call18, align 4
  %cmp19 = icmp ne i32 %20, 11
  br i1 %cmp19, label %land.lhs.true, label %if.end23

land.lhs.true:                                    ; preds = %if.then17
  %call20 = call ptr @__errno_location() #18
  %21 = load i32, ptr %call20, align 4
  %cmp21 = icmp ne i32 %21, 4
  br i1 %cmp21, label %if.then22, label %if.end23

if.then22:                                        ; preds = %land.lhs.true
  br label %while.end

if.end23:                                         ; preds = %land.lhs.true, %if.then17
  br label %if.end24

if.else:                                          ; preds = %while.body
  %22 = load i64, ptr %ret14, align 8
  %23 = load i64, ptr %count, align 8
  %add = add i64 %23, %22
  store i64 %add, ptr %count, align 8
  br label %if.end24

if.end24:                                         ; preds = %if.else, %if.end23
  br label %while.cond, !llvm.loop !90

while.end:                                        ; preds = %if.then22, %while.cond
  %24 = load i32, ptr %fd, align 4
  %call25 = call i32 @mi_prim_close(i32 noundef %24)
  %25 = load i64, ptr %count, align 8
  %26 = load i64, ptr %buf_len.addr, align 8
  %cmp26 = icmp eq i64 %25, %26
  store i1 %cmp26, ptr %retval, align 1
  br label %return

return:                                           ; preds = %while.end, %if.then11, %if.then6, %if.then2
  %27 = load i1, ptr %retval, align 1
  ret i1 %27
}

; Function Attrs: nounwind uwtable
define internal i32 @mi_prim_open(ptr noundef %fpath, i32 noundef %open_flags) #0 {
entry:
  %fpath.addr = alloca ptr, align 8
  %open_flags.addr = alloca i32, align 4
  store ptr %fpath, ptr %fpath.addr, align 8
  store i32 %open_flags, ptr %open_flags.addr, align 4
  %0 = load ptr, ptr %fpath.addr, align 8
  %1 = load i32, ptr %open_flags.addr, align 4
  %call = call i64 (i64, ...) @syscall(i64 noundef 2, ptr noundef %0, i32 noundef %1, i32 noundef 0) #15
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @mi_prim_read(i32 noundef %fd, ptr noundef %buf, i64 noundef %bufsize) #0 {
entry:
  %fd.addr = alloca i32, align 4
  %buf.addr = alloca ptr, align 8
  %bufsize.addr = alloca i64, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store ptr %buf, ptr %buf.addr, align 8
  store i64 %bufsize, ptr %bufsize.addr, align 8
  %0 = load i32, ptr %fd.addr, align 4
  %1 = load ptr, ptr %buf.addr, align 8
  %2 = load i64, ptr %bufsize.addr, align 8
  %call = call i64 (i64, ...) @syscall(i64 noundef 0, i32 noundef %0, ptr noundef %1, i64 noundef %2) #15
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @mi_prim_close(i32 noundef %fd) #0 {
entry:
  %fd.addr = alloca i32, align 4
  store i32 %fd, ptr %fd.addr, align 4
  %0 = load i32, ptr %fd.addr, align 4
  %call = call i64 (i64, ...) @syscall(i64 noundef 3, i32 noundef %0) #15
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_prim_thread_init_auto_done() #0 {
entry:
  %call = call i32 @pthread_key_create(ptr noundef @_mi_heap_default_key, ptr noundef @mi_pthread_done) #15
  ret void
}

; Function Attrs: nounwind
declare i32 @pthread_key_create(ptr noundef, ptr noundef) #2

; Function Attrs: nounwind uwtable
define internal void @mi_pthread_done(ptr noundef %value) #0 {
entry:
  %value.addr = alloca ptr, align 8
  store ptr %value, ptr %value.addr, align 8
  %0 = load ptr, ptr %value.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %value.addr, align 8
  call void @_mi_thread_done(ptr noundef %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @_mi_prim_thread_done_auto_done() #0 {
entry:
  ret void
}

; Function Attrs: nounwind
declare i32 @pthread_setspecific(i32 noundef, ptr noundef) #2

; Function Attrs: nounwind uwtable
define hidden ptr @_PyMem_RawMalloc(ptr noundef %_unused_ctx, i64 noundef %size) #0 {
entry:
  %_unused_ctx.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  store ptr %_unused_ctx, ptr %_unused_ctx.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load i64, ptr %size.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 1, ptr %size.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = load i64, ptr %size.addr, align 8
  %call = call noalias ptr @malloc(i64 noundef %1) #19
  ret ptr %call
}

; Function Attrs: nounwind allocsize(0)
declare noalias ptr @malloc(i64 noundef) #9

; Function Attrs: nounwind uwtable
define hidden ptr @_PyMem_RawCalloc(ptr noundef %_unused_ctx, i64 noundef %nelem, i64 noundef %elsize) #0 {
entry:
  %_unused_ctx.addr = alloca ptr, align 8
  %nelem.addr = alloca i64, align 8
  %elsize.addr = alloca i64, align 8
  store ptr %_unused_ctx, ptr %_unused_ctx.addr, align 8
  store i64 %nelem, ptr %nelem.addr, align 8
  store i64 %elsize, ptr %elsize.addr, align 8
  %0 = load i64, ptr %nelem.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i64, ptr %elsize.addr, align 8
  %cmp1 = icmp eq i64 %1, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i64 1, ptr %nelem.addr, align 8
  store i64 1, ptr %elsize.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  %2 = load i64, ptr %nelem.addr, align 8
  %3 = load i64, ptr %elsize.addr, align 8
  %call = call noalias ptr @calloc(i64 noundef %2, i64 noundef %3) #20
  ret ptr %call
}

; Function Attrs: nounwind allocsize(0,1)
declare noalias ptr @calloc(i64 noundef, i64 noundef) #10

; Function Attrs: nounwind uwtable
define hidden ptr @_PyMem_RawRealloc(ptr noundef %_unused_ctx, ptr noundef %ptr, i64 noundef %size) #0 {
entry:
  %_unused_ctx.addr = alloca ptr, align 8
  %ptr.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  store ptr %_unused_ctx, ptr %_unused_ctx.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load i64, ptr %size.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 1, ptr %size.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = load ptr, ptr %ptr.addr, align 8
  %2 = load i64, ptr %size.addr, align 8
  %call = call ptr @realloc(ptr noundef %1, i64 noundef %2) #21
  ret ptr %call
}

; Function Attrs: nounwind allocsize(1)
declare ptr @realloc(ptr noundef, i64 noundef) #11

; Function Attrs: nounwind uwtable
define hidden void @_PyMem_RawFree(ptr noundef %_unused_ctx, ptr noundef %ptr) #0 {
entry:
  %_unused_ctx.addr = alloca ptr, align 8
  %ptr.addr = alloca ptr, align 8
  store ptr %_unused_ctx, ptr %_unused_ctx.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  call void @free(ptr noundef %0) #15
  ret void
}

; Function Attrs: nounwind uwtable
define hidden ptr @_PyMem_MiMalloc(ptr noundef %ctx, i64 noundef %size) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load i64, ptr %size.addr, align 8
  %call = call noalias ptr @mi_malloc(i64 noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define hidden ptr @_PyMem_MiCalloc(ptr noundef %ctx, i64 noundef %nelem, i64 noundef %elsize) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %nelem.addr = alloca i64, align 8
  %elsize.addr = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i64 %nelem, ptr %nelem.addr, align 8
  store i64 %elsize, ptr %elsize.addr, align 8
  %0 = load i64, ptr %nelem.addr, align 8
  %1 = load i64, ptr %elsize.addr, align 8
  %call = call noalias ptr @mi_calloc(i64 noundef %0, i64 noundef %1)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define hidden ptr @_PyMem_MiRealloc(ptr noundef %ctx, ptr noundef %ptr, i64 noundef %size) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %ptr.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  %1 = load i64, ptr %size.addr, align 8
  %call = call ptr @mi_realloc(ptr noundef %0, i64 noundef %1)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define hidden void @_PyMem_MiFree(ptr noundef %ctx, ptr noundef %ptr) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %ptr.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  call void @mi_free(ptr noundef %0)
  ret void
}

; Function Attrs: nounwind uwtable
define hidden ptr @_PyObject_MiMalloc(ptr noundef %ctx, i64 noundef %nbytes) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %nbytes.addr = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i64 %nbytes, ptr %nbytes.addr, align 8
  %0 = load i64, ptr %nbytes.addr, align 8
  %call = call noalias ptr @mi_malloc(i64 noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define hidden ptr @_PyObject_MiCalloc(ptr noundef %ctx, i64 noundef %nelem, i64 noundef %elsize) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %nelem.addr = alloca i64, align 8
  %elsize.addr = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i64 %nelem, ptr %nelem.addr, align 8
  store i64 %elsize, ptr %elsize.addr, align 8
  %0 = load i64, ptr %nelem.addr, align 8
  %1 = load i64, ptr %elsize.addr, align 8
  %call = call noalias ptr @mi_calloc(i64 noundef %0, i64 noundef %1)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define hidden ptr @_PyObject_MiRealloc(ptr noundef %ctx, ptr noundef %ptr, i64 noundef %nbytes) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %ptr.addr = alloca ptr, align 8
  %nbytes.addr = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  store i64 %nbytes, ptr %nbytes.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  %1 = load i64, ptr %nbytes.addr, align 8
  %call = call ptr @mi_realloc(ptr noundef %0, i64 noundef %1)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define hidden void @_PyObject_MiFree(ptr noundef %ctx, ptr noundef %ptr) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %ptr.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  call void @mi_free(ptr noundef %0)
  ret void
}

; Function Attrs: nounwind uwtable
define hidden ptr @_PyMem_ArenaAlloc(ptr noundef %_unused_ctx, i64 noundef %size) #0 {
entry:
  %retval = alloca ptr, align 8
  %_unused_ctx.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %ptr = alloca ptr, align 8
  store ptr %_unused_ctx, ptr %_unused_ctx.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load i64, ptr %size.addr, align 8
  %call = call ptr @mmap64(ptr noundef null, i64 noundef %0, i32 noundef 3, i32 noundef 34, i32 noundef -1, i64 noundef 0) #15
  store ptr %call, ptr %ptr, align 8
  %1 = load ptr, ptr %ptr, align 8
  %cmp = icmp eq ptr %1, inttoptr (i64 -1 to ptr)
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %ptr, align 8
  store ptr %2, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load ptr, ptr %retval, align 8
  ret ptr %3
}

; Function Attrs: nounwind
declare ptr @mmap64(ptr noundef, i64 noundef, i32 noundef, i32 noundef, i32 noundef, i64 noundef) #2

; Function Attrs: nounwind uwtable
define hidden void @_PyMem_ArenaFree(ptr noundef %_unused_ctx, ptr noundef %ptr, i64 noundef %size) #0 {
entry:
  %_unused_ctx.addr = alloca ptr, align 8
  %ptr.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  store ptr %_unused_ctx, ptr %_unused_ctx.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  %1 = load i64, ptr %size.addr, align 8
  %call = call i32 @munmap(ptr noundef %0, i64 noundef %1) #15
  ret void
}

; Function Attrs: nounwind uwtable
define hidden i32 @_PyMem_SetDefaultAllocator(i32 noundef %domain, ptr noundef %old_alloc) #0 {
entry:
  %domain.addr = alloca i32, align 4
  %old_alloc.addr = alloca ptr, align 8
  %res = alloca i32, align 4
  store i32 %domain, ptr %domain.addr, align 4
  store ptr %old_alloc, ptr %old_alloc.addr, align 8
  call void @PyMutex_Lock(ptr noundef getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11))
  %0 = load i32, ptr %domain.addr, align 4
  %1 = load ptr, ptr %old_alloc.addr, align 8
  %call = call i32 @set_default_allocator_unlocked(i32 noundef %0, i32 noundef 0, ptr noundef %1)
  store i32 %call, ptr %res, align 4
  call void @PyMutex_Unlock(ptr noundef getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11))
  %2 = load i32, ptr %res, align 4
  ret i32 %2
}

; Function Attrs: nounwind uwtable
define internal void @PyMutex_Lock(ptr noundef %m) #0 {
entry:
  %m.addr = alloca ptr, align 8
  %expected = alloca i8, align 1
  store ptr %m, ptr %m.addr, align 8
  store i8 0, ptr %expected, align 1
  %0 = load ptr, ptr %m.addr, align 8
  %v = getelementptr inbounds %struct._PyMutex, ptr %0, i32 0, i32 0
  %call = call i32 @_Py_atomic_compare_exchange_uint8(ptr noundef %v, ptr noundef %expected, i8 noundef zeroext 1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %m.addr, align 8
  call void @_PyMutex_LockSlow(ptr noundef %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @set_default_allocator_unlocked(i32 noundef %domain, i32 noundef %debug, ptr noundef %old_alloc) #0 {
entry:
  %retval = alloca i32, align 4
  %domain.addr = alloca i32, align 4
  %debug.addr = alloca i32, align 4
  %old_alloc.addr = alloca ptr, align 8
  %new_alloc = alloca %struct.PyMemAllocatorEx, align 8
  %.compoundliteral = alloca %struct.PyMemAllocatorEx, align 8
  %.compoundliteral2 = alloca %struct.PyMemAllocatorEx, align 8
  %.compoundliteral9 = alloca %struct.PyMemAllocatorEx, align 8
  store i32 %domain, ptr %domain.addr, align 4
  store i32 %debug, ptr %debug.addr, align 4
  store ptr %old_alloc, ptr %old_alloc.addr, align 8
  %0 = load ptr, ptr %old_alloc.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i32, ptr %domain.addr, align 4
  %2 = load ptr, ptr %old_alloc.addr, align 8
  call void @get_allocator_unlocked(i32 noundef %1, ptr noundef %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32, ptr %domain.addr, align 4
  switch i32 %3, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb1
    i32 2, label %sw.bb8
  ]

sw.bb:                                            ; preds = %if.end
  %ctx = getelementptr inbounds %struct.PyMemAllocatorEx, ptr %.compoundliteral, i32 0, i32 0
  store ptr null, ptr %ctx, align 8
  %malloc = getelementptr inbounds %struct.PyMemAllocatorEx, ptr %.compoundliteral, i32 0, i32 1
  store ptr @_PyMem_RawMalloc, ptr %malloc, align 8
  %calloc = getelementptr inbounds %struct.PyMemAllocatorEx, ptr %.compoundliteral, i32 0, i32 2
  store ptr @_PyMem_RawCalloc, ptr %calloc, align 8
  %realloc = getelementptr inbounds %struct.PyMemAllocatorEx, ptr %.compoundliteral, i32 0, i32 3
  store ptr @_PyMem_RawRealloc, ptr %realloc, align 8
  %free = getelementptr inbounds %struct.PyMemAllocatorEx, ptr %.compoundliteral, i32 0, i32 4
  store ptr @_PyMem_RawFree, ptr %free, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %new_alloc, ptr align 8 %.compoundliteral, i64 40, i1 false)
  br label %sw.epilog

sw.bb1:                                           ; preds = %if.end
  %ctx3 = getelementptr inbounds %struct.PyMemAllocatorEx, ptr %.compoundliteral2, i32 0, i32 0
  store ptr null, ptr %ctx3, align 8
  %malloc4 = getelementptr inbounds %struct.PyMemAllocatorEx, ptr %.compoundliteral2, i32 0, i32 1
  store ptr @_PyObject_Malloc, ptr %malloc4, align 8
  %calloc5 = getelementptr inbounds %struct.PyMemAllocatorEx, ptr %.compoundliteral2, i32 0, i32 2
  store ptr @_PyObject_Calloc, ptr %calloc5, align 8
  %realloc6 = getelementptr inbounds %struct.PyMemAllocatorEx, ptr %.compoundliteral2, i32 0, i32 3
  store ptr @_PyObject_Realloc, ptr %realloc6, align 8
  %free7 = getelementptr inbounds %struct.PyMemAllocatorEx, ptr %.compoundliteral2, i32 0, i32 4
  store ptr @_PyObject_Free, ptr %free7, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %new_alloc, ptr align 8 %.compoundliteral2, i64 40, i1 false)
  br label %sw.epilog

sw.bb8:                                           ; preds = %if.end
  %ctx10 = getelementptr inbounds %struct.PyMemAllocatorEx, ptr %.compoundliteral9, i32 0, i32 0
  store ptr null, ptr %ctx10, align 8
  %malloc11 = getelementptr inbounds %struct.PyMemAllocatorEx, ptr %.compoundliteral9, i32 0, i32 1
  store ptr @_PyObject_Malloc, ptr %malloc11, align 8
  %calloc12 = getelementptr inbounds %struct.PyMemAllocatorEx, ptr %.compoundliteral9, i32 0, i32 2
  store ptr @_PyObject_Calloc, ptr %calloc12, align 8
  %realloc13 = getelementptr inbounds %struct.PyMemAllocatorEx, ptr %.compoundliteral9, i32 0, i32 3
  store ptr @_PyObject_Realloc, ptr %realloc13, align 8
  %free14 = getelementptr inbounds %struct.PyMemAllocatorEx, ptr %.compoundliteral9, i32 0, i32 4
  store ptr @_PyObject_Free, ptr %free14, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %new_alloc, ptr align 8 %.compoundliteral9, i64 40, i1 false)
  br label %sw.epilog

sw.default:                                       ; preds = %if.end
  store i32 -1, ptr %retval, align 4
  br label %return

sw.epilog:                                        ; preds = %sw.bb8, %sw.bb1, %sw.bb
  %4 = load i32, ptr %domain.addr, align 4
  call void @set_allocator_unlocked(i32 noundef %4, ptr noundef %new_alloc)
  %5 = load i32, ptr %debug.addr, align 4
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %if.then15, label %if.end16

if.then15:                                        ; preds = %sw.epilog
  %6 = load i32, ptr %domain.addr, align 4
  call void @set_up_debug_hooks_domain_unlocked(i32 noundef %6)
  br label %if.end16

if.end16:                                         ; preds = %if.then15, %sw.epilog
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end16, %sw.default
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal void @PyMutex_Unlock(ptr noundef %m) #0 {
entry:
  %m.addr = alloca ptr, align 8
  %expected = alloca i8, align 1
  store ptr %m, ptr %m.addr, align 8
  store i8 1, ptr %expected, align 1
  %0 = load ptr, ptr %m.addr, align 8
  %v = getelementptr inbounds %struct._PyMutex, ptr %0, i32 0, i32 0
  %call = call i32 @_Py_atomic_compare_exchange_uint8(ptr noundef %v, ptr noundef %expected, i8 noundef zeroext 0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %m.addr, align 8
  call void @_PyMutex_UnlockSlow(ptr noundef %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define hidden i32 @_PyMem_GetAllocatorName(ptr noundef %name, ptr noundef %allocator) #0 {
entry:
  %retval = alloca i32, align 4
  %name.addr = alloca ptr, align 8
  %allocator.addr = alloca ptr, align 8
  store ptr %name, ptr %name.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %0 = load ptr, ptr %name.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %name.addr, align 8
  %2 = load i8, ptr %1, align 1
  %conv = sext i8 %2 to i32
  %cmp1 = icmp eq i32 %conv, 0
  br i1 %cmp1, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  %3 = load ptr, ptr %allocator.addr, align 8
  store i32 1, ptr %3, align 4
  br label %if.end49

if.else:                                          ; preds = %lor.lhs.false
  %4 = load ptr, ptr %name.addr, align 8
  %call = call i32 @strcmp(ptr noundef %4, ptr noundef @.str.34) #16
  %cmp3 = icmp eq i32 %call, 0
  br i1 %cmp3, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.else
  %5 = load ptr, ptr %allocator.addr, align 8
  store i32 1, ptr %5, align 4
  br label %if.end48

if.else6:                                         ; preds = %if.else
  %6 = load ptr, ptr %name.addr, align 8
  %call7 = call i32 @strcmp(ptr noundef %6, ptr noundef @.str.35) #16
  %cmp8 = icmp eq i32 %call7, 0
  br i1 %cmp8, label %if.then10, label %if.else11

if.then10:                                        ; preds = %if.else6
  %7 = load ptr, ptr %allocator.addr, align 8
  store i32 2, ptr %7, align 4
  br label %if.end47

if.else11:                                        ; preds = %if.else6
  %8 = load ptr, ptr %name.addr, align 8
  %call12 = call i32 @strcmp(ptr noundef %8, ptr noundef @.str.36) #16
  %cmp13 = icmp eq i32 %call12, 0
  br i1 %cmp13, label %if.then15, label %if.else16

if.then15:                                        ; preds = %if.else11
  %9 = load ptr, ptr %allocator.addr, align 8
  store i32 5, ptr %9, align 4
  br label %if.end46

if.else16:                                        ; preds = %if.else11
  %10 = load ptr, ptr %name.addr, align 8
  %call17 = call i32 @strcmp(ptr noundef %10, ptr noundef @.str.37) #16
  %cmp18 = icmp eq i32 %call17, 0
  br i1 %cmp18, label %if.then20, label %if.else21

if.then20:                                        ; preds = %if.else16
  %11 = load ptr, ptr %allocator.addr, align 8
  store i32 6, ptr %11, align 4
  br label %if.end45

if.else21:                                        ; preds = %if.else16
  %12 = load ptr, ptr %name.addr, align 8
  %call22 = call i32 @strcmp(ptr noundef %12, ptr noundef @.str.38) #16
  %cmp23 = icmp eq i32 %call22, 0
  br i1 %cmp23, label %if.then25, label %if.else26

if.then25:                                        ; preds = %if.else21
  %13 = load ptr, ptr %allocator.addr, align 8
  store i32 7, ptr %13, align 4
  br label %if.end44

if.else26:                                        ; preds = %if.else21
  %14 = load ptr, ptr %name.addr, align 8
  %call27 = call i32 @strcmp(ptr noundef %14, ptr noundef @.str.39) #16
  %cmp28 = icmp eq i32 %call27, 0
  br i1 %cmp28, label %if.then30, label %if.else31

if.then30:                                        ; preds = %if.else26
  %15 = load ptr, ptr %allocator.addr, align 8
  store i32 8, ptr %15, align 4
  br label %if.end43

if.else31:                                        ; preds = %if.else26
  %16 = load ptr, ptr %name.addr, align 8
  %call32 = call i32 @strcmp(ptr noundef %16, ptr noundef @.str.40) #16
  %cmp33 = icmp eq i32 %call32, 0
  br i1 %cmp33, label %if.then35, label %if.else36

if.then35:                                        ; preds = %if.else31
  %17 = load ptr, ptr %allocator.addr, align 8
  store i32 3, ptr %17, align 4
  br label %if.end42

if.else36:                                        ; preds = %if.else31
  %18 = load ptr, ptr %name.addr, align 8
  %call37 = call i32 @strcmp(ptr noundef %18, ptr noundef @.str.41) #16
  %cmp38 = icmp eq i32 %call37, 0
  br i1 %cmp38, label %if.then40, label %if.else41

if.then40:                                        ; preds = %if.else36
  %19 = load ptr, ptr %allocator.addr, align 8
  store i32 4, ptr %19, align 4
  br label %if.end

if.else41:                                        ; preds = %if.else36
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then40
  br label %if.end42

if.end42:                                         ; preds = %if.end, %if.then35
  br label %if.end43

if.end43:                                         ; preds = %if.end42, %if.then30
  br label %if.end44

if.end44:                                         ; preds = %if.end43, %if.then25
  br label %if.end45

if.end45:                                         ; preds = %if.end44, %if.then20
  br label %if.end46

if.end46:                                         ; preds = %if.end45, %if.then15
  br label %if.end47

if.end47:                                         ; preds = %if.end46, %if.then10
  br label %if.end48

if.end48:                                         ; preds = %if.end47, %if.then5
  br label %if.end49

if.end49:                                         ; preds = %if.end48, %if.then
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end49, %if.else41
  %20 = load i32, ptr %retval, align 4
  ret i32 %20
}

; Function Attrs: nounwind willreturn memory(read)
declare i32 @strcmp(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define hidden i32 @_PyMem_SetupAllocators(i32 noundef %allocator) #0 {
entry:
  %allocator.addr = alloca i32, align 4
  %res = alloca i32, align 4
  store i32 %allocator, ptr %allocator.addr, align 4
  call void @PyMutex_Lock(ptr noundef getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11))
  %0 = load i32, ptr %allocator.addr, align 4
  %call = call i32 @set_up_allocators_unlocked(i32 noundef %0)
  store i32 %call, ptr %res, align 4
  call void @PyMutex_Unlock(ptr noundef getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11))
  %1 = load i32, ptr %res, align 4
  ret i32 %1
}

; Function Attrs: nounwind uwtable
define internal i32 @set_up_allocators_unlocked(i32 noundef %allocator) #0 {
entry:
  %retval = alloca i32, align 4
  %allocator.addr = alloca i32, align 4
  %malloc_alloc = alloca %struct.PyMemAllocatorEx, align 8
  %pymalloc = alloca %struct.PyMemAllocatorEx, align 8
  %malloc_alloc10 = alloca %struct.PyMemAllocatorEx, align 8
  %pymalloc11 = alloca %struct.PyMemAllocatorEx, align 8
  %objmalloc = alloca %struct.PyMemAllocatorEx, align 8
  %malloc_alloc16 = alloca %struct.PyMemAllocatorEx, align 8
  store i32 %allocator, ptr %allocator.addr, align 4
  %0 = load i32, ptr %allocator.addr, align 4
  switch i32 %0, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb1
    i32 2, label %sw.bb4
    i32 5, label %sw.bb8
    i32 6, label %sw.bb8
    i32 7, label %sw.bb9
    i32 8, label %sw.bb9
    i32 3, label %sw.bb15
    i32 4, label %sw.bb15
  ]

sw.bb:                                            ; preds = %entry
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry
  %call = call i32 @set_default_allocator_unlocked(i32 noundef 0, i32 noundef 0, ptr noundef null)
  %call2 = call i32 @set_default_allocator_unlocked(i32 noundef 1, i32 noundef 0, ptr noundef null)
  %call3 = call i32 @set_default_allocator_unlocked(i32 noundef 2, i32 noundef 0, ptr noundef null)
  br label %sw.epilog

sw.bb4:                                           ; preds = %entry
  %call5 = call i32 @set_default_allocator_unlocked(i32 noundef 0, i32 noundef 1, ptr noundef null)
  %call6 = call i32 @set_default_allocator_unlocked(i32 noundef 1, i32 noundef 1, ptr noundef null)
  %call7 = call i32 @set_default_allocator_unlocked(i32 noundef 2, i32 noundef 1, ptr noundef null)
  br label %sw.epilog

sw.bb8:                                           ; preds = %entry, %entry
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %malloc_alloc, ptr align 8 @__const.set_up_allocators_unlocked.malloc_alloc, i64 40, i1 false)
  call void @set_allocator_unlocked(i32 noundef 0, ptr noundef %malloc_alloc)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %pymalloc, ptr align 8 @__const.set_up_allocators_unlocked.pymalloc, i64 40, i1 false)
  call void @set_allocator_unlocked(i32 noundef 1, ptr noundef %pymalloc)
  call void @set_allocator_unlocked(i32 noundef 2, ptr noundef %pymalloc)
  %1 = load i32, ptr %allocator.addr, align 4
  %cmp = icmp eq i32 %1, 6
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb8
  call void @set_up_debug_hooks_unlocked()
  br label %if.end

if.end:                                           ; preds = %if.then, %sw.bb8
  br label %sw.epilog

sw.bb9:                                           ; preds = %entry, %entry
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %malloc_alloc10, ptr align 8 @__const.set_up_allocators_unlocked.malloc_alloc.154, i64 40, i1 false)
  call void @set_allocator_unlocked(i32 noundef 0, ptr noundef %malloc_alloc10)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %pymalloc11, ptr align 8 @__const.set_up_allocators_unlocked.pymalloc.155, i64 40, i1 false)
  call void @set_allocator_unlocked(i32 noundef 1, ptr noundef %pymalloc11)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %objmalloc, ptr align 8 @__const.set_up_allocators_unlocked.objmalloc, i64 40, i1 false)
  call void @set_allocator_unlocked(i32 noundef 2, ptr noundef %objmalloc)
  %2 = load i32, ptr %allocator.addr, align 4
  %cmp12 = icmp eq i32 %2, 8
  br i1 %cmp12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %sw.bb9
  call void @set_up_debug_hooks_unlocked()
  br label %if.end14

if.end14:                                         ; preds = %if.then13, %sw.bb9
  br label %sw.epilog

sw.bb15:                                          ; preds = %entry, %entry
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %malloc_alloc16, ptr align 8 @__const.set_up_allocators_unlocked.malloc_alloc.156, i64 40, i1 false)
  call void @set_allocator_unlocked(i32 noundef 0, ptr noundef %malloc_alloc16)
  call void @set_allocator_unlocked(i32 noundef 1, ptr noundef %malloc_alloc16)
  call void @set_allocator_unlocked(i32 noundef 2, ptr noundef %malloc_alloc16)
  %3 = load i32, ptr %allocator.addr, align 4
  %cmp17 = icmp eq i32 %3, 4
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %sw.bb15
  call void @set_up_debug_hooks_unlocked()
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %sw.bb15
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  store i32 -1, ptr %retval, align 4
  br label %return

sw.epilog:                                        ; preds = %if.end19, %if.end14, %if.end, %sw.bb4, %sw.bb1, %sw.bb
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %sw.epilog, %sw.default
  %4 = load i32, ptr %retval, align 4
  ret i32 %4
}

; Function Attrs: nounwind uwtable
define dso_local ptr @_PyMem_GetCurrentAllocatorName() #0 {
entry:
  %name = alloca ptr, align 8
  call void @PyMutex_Lock(ptr noundef getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11))
  %call = call ptr @get_current_allocator_name_unlocked()
  store ptr %call, ptr %name, align 8
  call void @PyMutex_Unlock(ptr noundef getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11))
  %0 = load ptr, ptr %name, align 8
  ret ptr %0
}

; Function Attrs: nounwind uwtable
define internal ptr @get_current_allocator_name_unlocked() #0 {
entry:
  %retval = alloca ptr, align 8
  %malloc_alloc = alloca %struct.PyMemAllocatorEx, align 8
  %pymalloc = alloca %struct.PyMemAllocatorEx, align 8
  %mimalloc = alloca %struct.PyMemAllocatorEx, align 8
  %mimalloc_obj = alloca %struct.PyMemAllocatorEx, align 8
  %dbg_raw = alloca %struct.PyMemAllocatorEx, align 8
  %dbg_mem = alloca %struct.PyMemAllocatorEx, align 8
  %dbg_obj = alloca %struct.PyMemAllocatorEx, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %malloc_alloc, ptr align 8 @__const.get_current_allocator_name_unlocked.malloc_alloc, i64 40, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %pymalloc, ptr align 8 @__const.get_current_allocator_name_unlocked.pymalloc, i64 40, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %mimalloc, ptr align 8 @__const.get_current_allocator_name_unlocked.mimalloc, i64 40, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %mimalloc_obj, ptr align 8 @__const.get_current_allocator_name_unlocked.mimalloc_obj, i64 40, i1 false)
  %call = call i32 @pymemallocator_eq(ptr noundef getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1), ptr noundef %malloc_alloc)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %call1 = call i32 @pymemallocator_eq(ptr noundef getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1, i32 1), ptr noundef %malloc_alloc)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %land.lhs.true3, label %if.end

land.lhs.true3:                                   ; preds = %land.lhs.true
  %call4 = call i32 @pymemallocator_eq(ptr noundef getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1, i32 2), ptr noundef %malloc_alloc)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true3
  store ptr @.str.40, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %land.lhs.true3, %land.lhs.true, %entry
  %call6 = call i32 @pymemallocator_eq(ptr noundef getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1), ptr noundef %malloc_alloc)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %land.lhs.true8, label %if.end15

land.lhs.true8:                                   ; preds = %if.end
  %call9 = call i32 @pymemallocator_eq(ptr noundef getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1, i32 1), ptr noundef %pymalloc)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %land.lhs.true11, label %if.end15

land.lhs.true11:                                  ; preds = %land.lhs.true8
  %call12 = call i32 @pymemallocator_eq(ptr noundef getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1, i32 2), ptr noundef %pymalloc)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %land.lhs.true11
  store ptr @.str.36, ptr %retval, align 8
  br label %return

if.end15:                                         ; preds = %land.lhs.true11, %land.lhs.true8, %if.end
  %call16 = call i32 @pymemallocator_eq(ptr noundef getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1), ptr noundef %malloc_alloc)
  %tobool17 = icmp ne i32 %call16, 0
  br i1 %tobool17, label %land.lhs.true18, label %if.end25

land.lhs.true18:                                  ; preds = %if.end15
  %call19 = call i32 @pymemallocator_eq(ptr noundef getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1, i32 1), ptr noundef %mimalloc)
  %tobool20 = icmp ne i32 %call19, 0
  br i1 %tobool20, label %land.lhs.true21, label %if.end25

land.lhs.true21:                                  ; preds = %land.lhs.true18
  %call22 = call i32 @pymemallocator_eq(ptr noundef getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1, i32 2), ptr noundef %mimalloc_obj)
  %tobool23 = icmp ne i32 %call22, 0
  br i1 %tobool23, label %if.then24, label %if.end25

if.then24:                                        ; preds = %land.lhs.true21
  store ptr @.str.38, ptr %retval, align 8
  br label %return

if.end25:                                         ; preds = %land.lhs.true21, %land.lhs.true18, %if.end15
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %dbg_raw, ptr align 8 @__const.get_current_allocator_name_unlocked.dbg_raw, i64 40, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %dbg_mem, ptr align 8 @__const.get_current_allocator_name_unlocked.dbg_mem, i64 40, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %dbg_obj, ptr align 8 @__const.get_current_allocator_name_unlocked.dbg_obj, i64 40, i1 false)
  %call26 = call i32 @pymemallocator_eq(ptr noundef getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1), ptr noundef %dbg_raw)
  %tobool27 = icmp ne i32 %call26, 0
  br i1 %tobool27, label %land.lhs.true28, label %if.end65

land.lhs.true28:                                  ; preds = %if.end25
  %call29 = call i32 @pymemallocator_eq(ptr noundef getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1, i32 1), ptr noundef %dbg_mem)
  %tobool30 = icmp ne i32 %call29, 0
  br i1 %tobool30, label %land.lhs.true31, label %if.end65

land.lhs.true31:                                  ; preds = %land.lhs.true28
  %call32 = call i32 @pymemallocator_eq(ptr noundef getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1, i32 2), ptr noundef %dbg_obj)
  %tobool33 = icmp ne i32 %call32, 0
  br i1 %tobool33, label %if.then34, label %if.end65

if.then34:                                        ; preds = %land.lhs.true31
  %call35 = call i32 @pymemallocator_eq(ptr noundef getelementptr inbounds (%struct.debug_alloc_api_t, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 2), i32 0, i32 1), ptr noundef %malloc_alloc)
  %tobool36 = icmp ne i32 %call35, 0
  br i1 %tobool36, label %land.lhs.true37, label %if.end44

land.lhs.true37:                                  ; preds = %if.then34
  %call38 = call i32 @pymemallocator_eq(ptr noundef getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 2, i32 1, i32 1), ptr noundef %malloc_alloc)
  %tobool39 = icmp ne i32 %call38, 0
  br i1 %tobool39, label %land.lhs.true40, label %if.end44

land.lhs.true40:                                  ; preds = %land.lhs.true37
  %call41 = call i32 @pymemallocator_eq(ptr noundef getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 2, i32 2, i32 1), ptr noundef %malloc_alloc)
  %tobool42 = icmp ne i32 %call41, 0
  br i1 %tobool42, label %if.then43, label %if.end44

if.then43:                                        ; preds = %land.lhs.true40
  store ptr @.str.41, ptr %retval, align 8
  br label %return

if.end44:                                         ; preds = %land.lhs.true40, %land.lhs.true37, %if.then34
  %call45 = call i32 @pymemallocator_eq(ptr noundef getelementptr inbounds (%struct.debug_alloc_api_t, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 2), i32 0, i32 1), ptr noundef %malloc_alloc)
  %tobool46 = icmp ne i32 %call45, 0
  br i1 %tobool46, label %land.lhs.true47, label %if.end54

land.lhs.true47:                                  ; preds = %if.end44
  %call48 = call i32 @pymemallocator_eq(ptr noundef getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 2, i32 1, i32 1), ptr noundef %pymalloc)
  %tobool49 = icmp ne i32 %call48, 0
  br i1 %tobool49, label %land.lhs.true50, label %if.end54

land.lhs.true50:                                  ; preds = %land.lhs.true47
  %call51 = call i32 @pymemallocator_eq(ptr noundef getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 2, i32 2, i32 1), ptr noundef %pymalloc)
  %tobool52 = icmp ne i32 %call51, 0
  br i1 %tobool52, label %if.then53, label %if.end54

if.then53:                                        ; preds = %land.lhs.true50
  store ptr @.str.37, ptr %retval, align 8
  br label %return

if.end54:                                         ; preds = %land.lhs.true50, %land.lhs.true47, %if.end44
  %call55 = call i32 @pymemallocator_eq(ptr noundef getelementptr inbounds (%struct.debug_alloc_api_t, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 2), i32 0, i32 1), ptr noundef %malloc_alloc)
  %tobool56 = icmp ne i32 %call55, 0
  br i1 %tobool56, label %land.lhs.true57, label %if.end64

land.lhs.true57:                                  ; preds = %if.end54
  %call58 = call i32 @pymemallocator_eq(ptr noundef getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 2, i32 1, i32 1), ptr noundef %mimalloc)
  %tobool59 = icmp ne i32 %call58, 0
  br i1 %tobool59, label %land.lhs.true60, label %if.end64

land.lhs.true60:                                  ; preds = %land.lhs.true57
  %call61 = call i32 @pymemallocator_eq(ptr noundef getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 2, i32 2, i32 1), ptr noundef %mimalloc_obj)
  %tobool62 = icmp ne i32 %call61, 0
  br i1 %tobool62, label %if.then63, label %if.end64

if.then63:                                        ; preds = %land.lhs.true60
  store ptr @.str.39, ptr %retval, align 8
  br label %return

if.end64:                                         ; preds = %land.lhs.true60, %land.lhs.true57, %if.end54
  br label %if.end65

if.end65:                                         ; preds = %if.end64, %land.lhs.true31, %land.lhs.true28, %if.end25
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end65, %if.then63, %if.then53, %if.then43, %if.then24, %if.then14, %if.then
  %0 = load ptr, ptr %retval, align 8
  ret ptr %0
}

; Function Attrs: nounwind uwtable
define dso_local void @PyMem_SetupDebugHooks() #0 {
entry:
  call void @PyMutex_Lock(ptr noundef getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11))
  call void @set_up_debug_hooks_unlocked()
  call void @PyMutex_Unlock(ptr noundef getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11))
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @set_up_debug_hooks_unlocked() #0 {
entry:
  call void @set_up_debug_hooks_domain_unlocked(i32 noundef 0)
  call void @set_up_debug_hooks_domain_unlocked(i32 noundef 1)
  call void @set_up_debug_hooks_domain_unlocked(i32 noundef 2)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @PyMem_GetAllocator(i32 noundef %domain, ptr noundef %allocator) #0 {
entry:
  %domain.addr = alloca i32, align 4
  %allocator.addr = alloca ptr, align 8
  store i32 %domain, ptr %domain.addr, align 4
  store ptr %allocator, ptr %allocator.addr, align 8
  call void @PyMutex_Lock(ptr noundef getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11))
  %0 = load i32, ptr %domain.addr, align 4
  %1 = load ptr, ptr %allocator.addr, align 8
  call void @get_allocator_unlocked(i32 noundef %0, ptr noundef %1)
  call void @PyMutex_Unlock(ptr noundef getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11))
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @get_allocator_unlocked(i32 noundef %domain, ptr noundef %allocator) #0 {
entry:
  %domain.addr = alloca i32, align 4
  %allocator.addr = alloca ptr, align 8
  store i32 %domain, ptr %domain.addr, align 4
  store ptr %allocator, ptr %allocator.addr, align 8
  %0 = load i32, ptr %domain.addr, align 4
  switch i32 %0, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb1
    i32 2, label %sw.bb2
  ]

sw.bb:                                            ; preds = %entry
  %1 = load ptr, ptr %allocator.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %1, ptr align 8 getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1), i64 40, i1 false)
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry
  %2 = load ptr, ptr %allocator.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %2, ptr align 8 getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1, i32 1), i64 40, i1 false)
  br label %sw.epilog

sw.bb2:                                           ; preds = %entry
  %3 = load ptr, ptr %allocator.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %3, ptr align 8 getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1, i32 2), i64 40, i1 false)
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %4 = load ptr, ptr %allocator.addr, align 8
  %ctx = getelementptr inbounds %struct.PyMemAllocatorEx, ptr %4, i32 0, i32 0
  store ptr null, ptr %ctx, align 8
  %5 = load ptr, ptr %allocator.addr, align 8
  %malloc = getelementptr inbounds %struct.PyMemAllocatorEx, ptr %5, i32 0, i32 1
  store ptr null, ptr %malloc, align 8
  %6 = load ptr, ptr %allocator.addr, align 8
  %calloc = getelementptr inbounds %struct.PyMemAllocatorEx, ptr %6, i32 0, i32 2
  store ptr null, ptr %calloc, align 8
  %7 = load ptr, ptr %allocator.addr, align 8
  %realloc = getelementptr inbounds %struct.PyMemAllocatorEx, ptr %7, i32 0, i32 3
  store ptr null, ptr %realloc, align 8
  %8 = load ptr, ptr %allocator.addr, align 8
  %free = getelementptr inbounds %struct.PyMemAllocatorEx, ptr %8, i32 0, i32 4
  store ptr null, ptr %free, align 8
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb2, %sw.bb1, %sw.bb
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @PyMem_SetAllocator(i32 noundef %domain, ptr noundef %allocator) #0 {
entry:
  %domain.addr = alloca i32, align 4
  %allocator.addr = alloca ptr, align 8
  store i32 %domain, ptr %domain.addr, align 4
  store ptr %allocator, ptr %allocator.addr, align 8
  call void @PyMutex_Lock(ptr noundef getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11))
  %0 = load i32, ptr %domain.addr, align 4
  %1 = load ptr, ptr %allocator.addr, align 8
  call void @set_allocator_unlocked(i32 noundef %0, ptr noundef %1)
  call void @PyMutex_Unlock(ptr noundef getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11))
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @set_allocator_unlocked(i32 noundef %domain, ptr noundef %allocator) #0 {
entry:
  %domain.addr = alloca i32, align 4
  %allocator.addr = alloca ptr, align 8
  store i32 %domain, ptr %domain.addr, align 4
  store ptr %allocator, ptr %allocator.addr, align 8
  %0 = load i32, ptr %domain.addr, align 4
  switch i32 %0, label %sw.epilog [
    i32 0, label %sw.bb
    i32 1, label %sw.bb1
    i32 2, label %sw.bb2
  ]

sw.bb:                                            ; preds = %entry
  %1 = load ptr, ptr %allocator.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1), ptr align 8 %1, i64 40, i1 false)
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry
  %2 = load ptr, ptr %allocator.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1, i32 1), ptr align 8 %2, i64 40, i1 false)
  br label %sw.epilog

sw.bb2:                                           ; preds = %entry
  %3 = load ptr, ptr %allocator.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1, i32 2), ptr align 8 %3, i64 40, i1 false)
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb2, %sw.bb1, %sw.bb, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @PyObject_GetArenaAllocator(ptr noundef %allocator) #0 {
entry:
  %allocator.addr = alloca ptr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  call void @PyMutex_Lock(ptr noundef getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11))
  %0 = load ptr, ptr %allocator.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %0, ptr align 8 getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 3), i64 24, i1 false)
  call void @PyMutex_Unlock(ptr noundef getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11))
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @PyObject_SetArenaAllocator(ptr noundef %allocator) #0 {
entry:
  %allocator.addr = alloca ptr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  call void @PyMutex_Lock(ptr noundef getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11))
  %0 = load ptr, ptr %allocator.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 3), ptr align 8 %0, i64 24, i1 false)
  call void @PyMutex_Unlock(ptr noundef getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11))
  ret void
}

; Function Attrs: nounwind uwtable
define hidden ptr @_PyObject_VirtualAlloc(i64 noundef %size) #0 {
entry:
  %size.addr = alloca i64, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load ptr, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 3, i32 1), align 8
  %1 = load ptr, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 3), align 8
  %2 = load i64, ptr %size.addr, align 8
  %call = call ptr %0(ptr noundef %1, i64 noundef %2)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define hidden void @_PyObject_VirtualFree(ptr noundef %obj, i64 noundef %size) #0 {
entry:
  %obj.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  store ptr %obj, ptr %obj.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load ptr, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 3, i32 2), align 8
  %1 = load ptr, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 3), align 8
  %2 = load ptr, ptr %obj.addr, align 8
  %3 = load i64, ptr %size.addr, align 8
  call void %0(ptr noundef %1, ptr noundef %2, i64 noundef %3)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local ptr @PyMem_RawMalloc(i64 noundef %size) #0 {
entry:
  %retval = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load i64, ptr %size.addr, align 8
  %cmp = icmp ugt i64 %0, 9223372036854775807
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr getelementptr inbounds (%struct.PyMemAllocatorEx, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1), i32 0, i32 1), align 8
  %2 = load ptr, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1), align 8
  %3 = load i64, ptr %size.addr, align 8
  %call = call ptr %1(ptr noundef %2, i64 noundef %3)
  store ptr %call, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load ptr, ptr %retval, align 8
  ret ptr %4
}

; Function Attrs: nounwind uwtable
define dso_local ptr @PyMem_RawCalloc(i64 noundef %nelem, i64 noundef %elsize) #0 {
entry:
  %retval = alloca ptr, align 8
  %nelem.addr = alloca i64, align 8
  %elsize.addr = alloca i64, align 8
  store i64 %nelem, ptr %nelem.addr, align 8
  store i64 %elsize, ptr %elsize.addr, align 8
  %0 = load i64, ptr %elsize.addr, align 8
  %cmp = icmp ne i64 %0, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nelem.addr, align 8
  %2 = load i64, ptr %elsize.addr, align 8
  %div = udiv i64 9223372036854775807, %2
  %cmp1 = icmp ugt i64 %1, %div
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %3 = load ptr, ptr getelementptr inbounds (%struct.PyMemAllocatorEx, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1), i32 0, i32 2), align 8
  %4 = load ptr, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1), align 8
  %5 = load i64, ptr %nelem.addr, align 8
  %6 = load i64, ptr %elsize.addr, align 8
  %call = call ptr %3(ptr noundef %4, i64 noundef %5, i64 noundef %6)
  store ptr %call, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load ptr, ptr %retval, align 8
  ret ptr %7
}

; Function Attrs: nounwind uwtable
define dso_local ptr @PyMem_RawRealloc(ptr noundef %ptr, i64 noundef %new_size) #0 {
entry:
  %retval = alloca ptr, align 8
  %ptr.addr = alloca ptr, align 8
  %new_size.addr = alloca i64, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  store i64 %new_size, ptr %new_size.addr, align 8
  %0 = load i64, ptr %new_size.addr, align 8
  %cmp = icmp ugt i64 %0, 9223372036854775807
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr getelementptr inbounds (%struct.PyMemAllocatorEx, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1), i32 0, i32 3), align 8
  %2 = load ptr, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1), align 8
  %3 = load ptr, ptr %ptr.addr, align 8
  %4 = load i64, ptr %new_size.addr, align 8
  %call = call ptr %1(ptr noundef %2, ptr noundef %3, i64 noundef %4)
  store ptr %call, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %5 = load ptr, ptr %retval, align 8
  ret ptr %5
}

; Function Attrs: nounwind uwtable
define dso_local void @PyMem_RawFree(ptr noundef %ptr) #0 {
entry:
  %ptr.addr = alloca ptr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr getelementptr inbounds (%struct.PyMemAllocatorEx, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1), i32 0, i32 4), align 8
  %1 = load ptr, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1), align 8
  %2 = load ptr, ptr %ptr.addr, align 8
  call void %0(ptr noundef %1, ptr noundef %2)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local ptr @PyMem_Malloc(i64 noundef %size) #0 {
entry:
  %retval = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load i64, ptr %size.addr, align 8
  %cmp = icmp ugt i64 %0, 9223372036854775807
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1, i32 1, i32 1), align 8
  %2 = load ptr, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1, i32 1), align 8
  %3 = load i64, ptr %size.addr, align 8
  %call = call ptr %1(ptr noundef %2, i64 noundef %3)
  store ptr %call, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load ptr, ptr %retval, align 8
  ret ptr %4
}

; Function Attrs: nounwind uwtable
define dso_local ptr @PyMem_Calloc(i64 noundef %nelem, i64 noundef %elsize) #0 {
entry:
  %retval = alloca ptr, align 8
  %nelem.addr = alloca i64, align 8
  %elsize.addr = alloca i64, align 8
  store i64 %nelem, ptr %nelem.addr, align 8
  store i64 %elsize, ptr %elsize.addr, align 8
  %0 = load i64, ptr %elsize.addr, align 8
  %cmp = icmp ne i64 %0, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nelem.addr, align 8
  %2 = load i64, ptr %elsize.addr, align 8
  %div = udiv i64 9223372036854775807, %2
  %cmp1 = icmp ugt i64 %1, %div
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %3 = load ptr, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1, i32 1, i32 2), align 8
  %4 = load ptr, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1, i32 1), align 8
  %5 = load i64, ptr %nelem.addr, align 8
  %6 = load i64, ptr %elsize.addr, align 8
  %call = call ptr %3(ptr noundef %4, i64 noundef %5, i64 noundef %6)
  store ptr %call, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load ptr, ptr %retval, align 8
  ret ptr %7
}

; Function Attrs: nounwind uwtable
define dso_local ptr @PyMem_Realloc(ptr noundef %ptr, i64 noundef %new_size) #0 {
entry:
  %retval = alloca ptr, align 8
  %ptr.addr = alloca ptr, align 8
  %new_size.addr = alloca i64, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  store i64 %new_size, ptr %new_size.addr, align 8
  %0 = load i64, ptr %new_size.addr, align 8
  %cmp = icmp ugt i64 %0, 9223372036854775807
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1, i32 1, i32 3), align 8
  %2 = load ptr, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1, i32 1), align 8
  %3 = load ptr, ptr %ptr.addr, align 8
  %4 = load i64, ptr %new_size.addr, align 8
  %call = call ptr %1(ptr noundef %2, ptr noundef %3, i64 noundef %4)
  store ptr %call, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %5 = load ptr, ptr %retval, align 8
  ret ptr %5
}

; Function Attrs: nounwind uwtable
define dso_local void @PyMem_Free(ptr noundef %ptr) #0 {
entry:
  %ptr.addr = alloca ptr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1, i32 1, i32 4), align 8
  %1 = load ptr, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1, i32 1), align 8
  %2 = load ptr, ptr %ptr.addr, align 8
  call void %0(ptr noundef %1, ptr noundef %2)
  ret void
}

; Function Attrs: nounwind uwtable
define hidden ptr @_PyMem_RawWcsdup(ptr noundef %str) #0 {
entry:
  %retval = alloca ptr, align 8
  %str.addr = alloca ptr, align 8
  %len = alloca i64, align 8
  %size = alloca i64, align 8
  %str2 = alloca ptr, align 8
  store ptr %str, ptr %str.addr, align 8
  %0 = load ptr, ptr %str.addr, align 8
  %call = call i64 @wcslen(ptr noundef %0) #16
  store i64 %call, ptr %len, align 8
  %1 = load i64, ptr %len, align 8
  %cmp = icmp ugt i64 %1, 2305843009213693950
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i64, ptr %len, align 8
  %add = add i64 %2, 1
  %mul = mul i64 %add, 4
  store i64 %mul, ptr %size, align 8
  %3 = load i64, ptr %size, align 8
  %call1 = call ptr @PyMem_RawMalloc(i64 noundef %3)
  store ptr %call1, ptr %str2, align 8
  %4 = load ptr, ptr %str2, align 8
  %cmp2 = icmp eq ptr %4, null
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  %5 = load ptr, ptr %str2, align 8
  %6 = load ptr, ptr %str.addr, align 8
  %7 = load i64, ptr %size, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %5, ptr align 4 %6, i64 %7, i1 false)
  %8 = load ptr, ptr %str2, align 8
  store ptr %8, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end4, %if.then3, %if.then
  %9 = load ptr, ptr %retval, align 8
  ret ptr %9
}

; Function Attrs: nounwind willreturn memory(read)
declare i64 @wcslen(ptr noundef) #1

; Function Attrs: nounwind uwtable
define hidden ptr @_PyMem_RawStrdup(ptr noundef %str) #0 {
entry:
  %retval = alloca ptr, align 8
  %str.addr = alloca ptr, align 8
  %size = alloca i64, align 8
  %copy = alloca ptr, align 8
  store ptr %str, ptr %str.addr, align 8
  %0 = load ptr, ptr %str.addr, align 8
  %call = call i64 @strlen(ptr noundef %0) #16
  %add = add i64 %call, 1
  store i64 %add, ptr %size, align 8
  %1 = load i64, ptr %size, align 8
  %call1 = call ptr @PyMem_RawMalloc(i64 noundef %1)
  store ptr %call1, ptr %copy, align 8
  %2 = load ptr, ptr %copy, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %copy, align 8
  %4 = load ptr, ptr %str.addr, align 8
  %5 = load i64, ptr %size, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %3, ptr align 1 %4, i64 %5, i1 false)
  %6 = load ptr, ptr %copy, align 8
  store ptr %6, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load ptr, ptr %retval, align 8
  ret ptr %7
}

; Function Attrs: nounwind uwtable
define dso_local ptr @_PyMem_Strdup(ptr noundef %str) #0 {
entry:
  %retval = alloca ptr, align 8
  %str.addr = alloca ptr, align 8
  %size = alloca i64, align 8
  %copy = alloca ptr, align 8
  store ptr %str, ptr %str.addr, align 8
  %0 = load ptr, ptr %str.addr, align 8
  %call = call i64 @strlen(ptr noundef %0) #16
  %add = add i64 %call, 1
  store i64 %add, ptr %size, align 8
  %1 = load i64, ptr %size, align 8
  %call1 = call ptr @PyMem_Malloc(i64 noundef %1)
  store ptr %call1, ptr %copy, align 8
  %2 = load ptr, ptr %copy, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %copy, align 8
  %4 = load ptr, ptr %str.addr, align 8
  %5 = load i64, ptr %size, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %3, ptr align 1 %4, i64 %5, i1 false)
  %6 = load ptr, ptr %copy, align 8
  store ptr %6, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load ptr, ptr %retval, align 8
  ret ptr %7
}

; Function Attrs: nounwind uwtable
define dso_local ptr @PyObject_Malloc(i64 noundef %size) #0 {
entry:
  %retval = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load i64, ptr %size.addr, align 8
  %cmp = icmp ugt i64 %0, 9223372036854775807
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1, i32 2, i32 1), align 8
  %2 = load ptr, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1, i32 2), align 8
  %3 = load i64, ptr %size.addr, align 8
  %call = call ptr %1(ptr noundef %2, i64 noundef %3)
  store ptr %call, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load ptr, ptr %retval, align 8
  ret ptr %4
}

; Function Attrs: nounwind uwtable
define dso_local ptr @PyObject_Calloc(i64 noundef %nelem, i64 noundef %elsize) #0 {
entry:
  %retval = alloca ptr, align 8
  %nelem.addr = alloca i64, align 8
  %elsize.addr = alloca i64, align 8
  store i64 %nelem, ptr %nelem.addr, align 8
  store i64 %elsize, ptr %elsize.addr, align 8
  %0 = load i64, ptr %elsize.addr, align 8
  %cmp = icmp ne i64 %0, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nelem.addr, align 8
  %2 = load i64, ptr %elsize.addr, align 8
  %div = udiv i64 9223372036854775807, %2
  %cmp1 = icmp ugt i64 %1, %div
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %3 = load ptr, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1, i32 2, i32 2), align 8
  %4 = load ptr, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1, i32 2), align 8
  %5 = load i64, ptr %nelem.addr, align 8
  %6 = load i64, ptr %elsize.addr, align 8
  %call = call ptr %3(ptr noundef %4, i64 noundef %5, i64 noundef %6)
  store ptr %call, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load ptr, ptr %retval, align 8
  ret ptr %7
}

; Function Attrs: nounwind uwtable
define dso_local ptr @PyObject_Realloc(ptr noundef %ptr, i64 noundef %new_size) #0 {
entry:
  %retval = alloca ptr, align 8
  %ptr.addr = alloca ptr, align 8
  %new_size.addr = alloca i64, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  store i64 %new_size, ptr %new_size.addr, align 8
  %0 = load i64, ptr %new_size.addr, align 8
  %cmp = icmp ugt i64 %0, 9223372036854775807
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1, i32 2, i32 3), align 8
  %2 = load ptr, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1, i32 2), align 8
  %3 = load ptr, ptr %ptr.addr, align 8
  %4 = load i64, ptr %new_size.addr, align 8
  %call = call ptr %1(ptr noundef %2, ptr noundef %3, i64 noundef %4)
  store ptr %call, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %5 = load ptr, ptr %retval, align 8
  ret ptr %5
}

; Function Attrs: nounwind uwtable
define dso_local void @PyObject_Free(ptr noundef %ptr) #0 {
entry:
  %ptr.addr = alloca ptr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1, i32 2, i32 4), align 8
  %1 = load ptr, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1, i32 2), align 8
  %2 = load ptr, ptr %ptr.addr, align 8
  call void %0(ptr noundef %1, ptr noundef %2)
  ret void
}

; Function Attrs: nounwind uwtable
define hidden i64 @_PyInterpreterState_GetAllocatedBlocks(ptr noundef %interp) #0 {
entry:
  %retval = alloca i64, align 8
  %interp.addr = alloca ptr, align 8
  %allocated_blocks = alloca i64, align 8
  %heap = alloca ptr, align 8
  %state = alloca ptr, align 8
  %n = alloca i64, align 8
  %i = alloca i32, align 4
  %base = alloca i64, align 8
  %p = alloca ptr, align 8
  store ptr %interp, ptr %interp.addr, align 8
  %call = call i32 @_PyMem_MimallocEnabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 0, ptr %allocated_blocks, align 8
  %call1 = call ptr @mi_heap_get_default()
  store ptr %call1, ptr %heap, align 8
  %0 = load ptr, ptr %heap, align 8
  %call2 = call zeroext i1 @mi_heap_visit_blocks(ptr noundef %0, i1 noundef zeroext false, ptr noundef @count_blocks, ptr noundef %allocated_blocks)
  %1 = load i64, ptr %allocated_blocks, align 8
  store i64 %1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %interp.addr, align 8
  %call3 = call i32 @has_own_state(ptr noundef %2)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.end6, label %if.then5

if.then5:                                         ; preds = %if.end
  call void @_Py_FatalErrorFunc(ptr noundef @__func__._PyInterpreterState_GetAllocatedBlocks, ptr noundef @.str.42) #22
  unreachable

if.end6:                                          ; preds = %if.end
  %3 = load ptr, ptr %interp.addr, align 8
  %obmalloc = getelementptr inbounds %struct._is, ptr %3, i32 0, i32 38
  store ptr %obmalloc, ptr %state, align 8
  %4 = load ptr, ptr %state, align 8
  %mgmt = getelementptr inbounds %struct._obmalloc_state, ptr %4, i32 0, i32 1
  %raw_allocated_blocks = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt, i32 0, i32 8
  %5 = load i64, ptr %raw_allocated_blocks, align 8
  store i64 %5, ptr %n, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc26, %if.end6
  %6 = load i32, ptr %i, align 4
  %7 = load ptr, ptr %state, align 8
  %mgmt7 = getelementptr inbounds %struct._obmalloc_state, ptr %7, i32 0, i32 1
  %maxarenas = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt7, i32 0, i32 1
  %8 = load i32, ptr %maxarenas, align 8
  %cmp = icmp ult i32 %6, %8
  br i1 %cmp, label %for.body, label %for.end27

for.body:                                         ; preds = %for.cond
  %9 = load ptr, ptr %state, align 8
  %mgmt8 = getelementptr inbounds %struct._obmalloc_state, ptr %9, i32 0, i32 1
  %arenas = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt8, i32 0, i32 0
  %10 = load ptr, ptr %arenas, align 8
  %11 = load i32, ptr %i, align 4
  %idxprom = zext i32 %11 to i64
  %arrayidx = getelementptr %struct.arena_object, ptr %10, i64 %idxprom
  %address = getelementptr inbounds %struct.arena_object, ptr %arrayidx, i32 0, i32 0
  %12 = load i64, ptr %address, align 8
  %cmp9 = icmp eq i64 %12, 0
  br i1 %cmp9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %for.body
  br label %for.inc26

if.end11:                                         ; preds = %for.body
  %13 = load ptr, ptr %state, align 8
  %mgmt12 = getelementptr inbounds %struct._obmalloc_state, ptr %13, i32 0, i32 1
  %arenas13 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt12, i32 0, i32 0
  %14 = load ptr, ptr %arenas13, align 8
  %15 = load i32, ptr %i, align 4
  %idxprom14 = zext i32 %15 to i64
  %arrayidx15 = getelementptr %struct.arena_object, ptr %14, i64 %idxprom14
  %address16 = getelementptr inbounds %struct.arena_object, ptr %arrayidx15, i32 0, i32 0
  %16 = load i64, ptr %address16, align 8
  %add = add i64 %16, 16383
  %and = and i64 %add, -16384
  %17 = inttoptr i64 %and to ptr
  %18 = ptrtoint ptr %17 to i64
  store i64 %18, ptr %base, align 8
  br label %for.cond17

for.cond17:                                       ; preds = %for.inc, %if.end11
  %19 = load i64, ptr %base, align 8
  %20 = load ptr, ptr %state, align 8
  %mgmt18 = getelementptr inbounds %struct._obmalloc_state, ptr %20, i32 0, i32 1
  %arenas19 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt18, i32 0, i32 0
  %21 = load ptr, ptr %arenas19, align 8
  %22 = load i32, ptr %i, align 4
  %idxprom20 = zext i32 %22 to i64
  %arrayidx21 = getelementptr %struct.arena_object, ptr %21, i64 %idxprom20
  %pool_address = getelementptr inbounds %struct.arena_object, ptr %arrayidx21, i32 0, i32 1
  %23 = load ptr, ptr %pool_address, align 8
  %24 = ptrtoint ptr %23 to i64
  %cmp22 = icmp ult i64 %19, %24
  br i1 %cmp22, label %for.body23, label %for.end

for.body23:                                       ; preds = %for.cond17
  %25 = load i64, ptr %base, align 8
  %26 = inttoptr i64 %25 to ptr
  store ptr %26, ptr %p, align 8
  %27 = load ptr, ptr %p, align 8
  %ref = getelementptr inbounds %struct.pool_header, ptr %27, i32 0, i32 0
  %28 = load i32, ptr %ref, align 8
  %conv = zext i32 %28 to i64
  %29 = load i64, ptr %n, align 8
  %add24 = add i64 %29, %conv
  store i64 %add24, ptr %n, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body23
  %30 = load i64, ptr %base, align 8
  %add25 = add i64 %30, 16384
  store i64 %add25, ptr %base, align 8
  br label %for.cond17, !llvm.loop !91

for.end:                                          ; preds = %for.cond17
  br label %for.inc26

for.inc26:                                        ; preds = %for.end, %if.then10
  %31 = load i32, ptr %i, align 4
  %inc = add i32 %31, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !92

for.end27:                                        ; preds = %for.cond
  %32 = load i64, ptr %n, align 8
  store i64 %32, ptr %retval, align 8
  br label %return

return:                                           ; preds = %for.end27, %if.then
  %33 = load i64, ptr %retval, align 8
  ret i64 %33
}

; Function Attrs: nounwind uwtable
define internal i32 @_PyMem_MimallocEnabled() #0 {
entry:
  %retval = alloca i32, align 4
  %call = call i32 @_PyMem_DebugEnabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %0 = load ptr, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 2, i32 2, i32 1, i32 1), align 8
  %cmp = icmp eq ptr %0, @_PyObject_MiMalloc
  %conv = zext i1 %cmp to i32
  store i32 %conv, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %1 = load ptr, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1, i32 2, i32 1), align 8
  %cmp1 = icmp eq ptr %1, @_PyObject_MiMalloc
  %conv2 = zext i1 %cmp1 to i32
  store i32 %conv2, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.else, %if.then
  %2 = load i32, ptr %retval, align 4
  ret i32 %2
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @count_blocks(ptr noundef %heap, ptr noundef %area, ptr noundef %block, i64 noundef %block_size, ptr noundef %allocated_blocks) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %area.addr = alloca ptr, align 8
  %block.addr = alloca ptr, align 8
  %block_size.addr = alloca i64, align 8
  %allocated_blocks.addr = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store ptr %area, ptr %area.addr, align 8
  store ptr %block, ptr %block.addr, align 8
  store i64 %block_size, ptr %block_size.addr, align 8
  store ptr %allocated_blocks, ptr %allocated_blocks.addr, align 8
  %0 = load ptr, ptr %area.addr, align 8
  %used = getelementptr inbounds %struct.mi_heap_area_s, ptr %0, i32 0, i32 3
  %1 = load i64, ptr %used, align 8
  %2 = load ptr, ptr %allocated_blocks.addr, align 8
  %3 = load i64, ptr %2, align 8
  %add = add i64 %3, %1
  store i64 %add, ptr %2, align 8
  ret i1 true
}

; Function Attrs: nounwind uwtable
define internal i32 @has_own_state(ptr noundef %interp) #0 {
entry:
  %interp.addr = alloca ptr, align 8
  store ptr %interp, ptr %interp.addr, align 8
  %0 = load ptr, ptr %interp.addr, align 8
  %call = call i32 @_Py_IsMainInterpreter(ptr noundef %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %interp.addr, align 8
  %feature_flags = getelementptr inbounds %struct._is, ptr %1, i32 0, i32 23
  %2 = load i64, ptr %feature_flags, align 8
  %and = and i64 %2, 32
  %tobool1 = icmp ne i64 %and, 0
  br i1 %tobool1, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %lor.lhs.false
  %3 = load ptr, ptr %interp.addr, align 8
  %call2 = call i32 @_Py_IsMainInterpreterFinalizing(ptr noundef %3)
  %tobool3 = icmp ne i32 %call2, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false, %entry
  %4 = phi i1 [ true, %lor.lhs.false ], [ true, %entry ], [ %tobool3, %lor.rhs ]
  %lor.ext = zext i1 %4 to i32
  ret i32 %lor.ext
}

; Function Attrs: noreturn
declare void @_Py_FatalErrorFunc(ptr noundef, ptr noundef) #12

; Function Attrs: nounwind uwtable
define hidden void @_PyInterpreterState_FinalizeAllocatedBlocks(ptr noundef %interp) #0 {
entry:
  %interp.addr = alloca ptr, align 8
  %leaked = alloca i64, align 8
  store ptr %interp, ptr %interp.addr, align 8
  %call = call i32 @_PyMem_MimallocEnabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end5

if.end:                                           ; preds = %entry
  %0 = load ptr, ptr %interp.addr, align 8
  %call1 = call i32 @has_own_state(ptr noundef %0)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %1 = load ptr, ptr %interp.addr, align 8
  %call4 = call i64 @_PyInterpreterState_GetAllocatedBlocks(ptr noundef %1)
  store i64 %call4, ptr %leaked, align 8
  %2 = load i64, ptr %leaked, align 8
  %3 = load ptr, ptr %interp.addr, align 8
  %runtime = getelementptr inbounds %struct._is, ptr %3, i32 0, i32 10
  %4 = load ptr, ptr %runtime, align 8
  %obmalloc = getelementptr inbounds %struct.pyruntimestate, ptr %4, i32 0, i32 12
  %interpreter_leaks = getelementptr inbounds %struct._obmalloc_global_state, ptr %obmalloc, i32 0, i32 1
  %5 = load i64, ptr %interpreter_leaks, align 8
  %add = add i64 %5, %2
  store i64 %add, ptr %interpreter_leaks, align 8
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @_Py_FinalizeAllocatedBlocks(ptr noundef %runtime) #0 {
entry:
  %runtime.addr = alloca ptr, align 8
  store ptr %runtime, ptr %runtime.addr, align 8
  %0 = load ptr, ptr %runtime.addr, align 8
  %call = call i64 @get_num_global_allocated_blocks(ptr noundef %0)
  store i64 %call, ptr @last_final_leaks, align 8
  %1 = load ptr, ptr %runtime.addr, align 8
  %obmalloc = getelementptr inbounds %struct.pyruntimestate, ptr %1, i32 0, i32 12
  %interpreter_leaks = getelementptr inbounds %struct._obmalloc_global_state, ptr %obmalloc, i32 0, i32 1
  store i64 0, ptr %interpreter_leaks, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @get_num_global_allocated_blocks(ptr noundef %runtime) #0 {
entry:
  %retval = alloca i64, align 8
  %runtime.addr = alloca ptr, align 8
  %allocated_blocks = alloca i64, align 8
  %heap = alloca ptr, align 8
  %total = alloca i64, align 8
  %interp = alloca ptr, align 8
  %interp11 = alloca ptr, align 8
  store ptr %runtime, ptr %runtime.addr, align 8
  %call = call i32 @_PyMem_MimallocEnabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 0, ptr %allocated_blocks, align 8
  %call1 = call ptr @mi_heap_get_default()
  store ptr %call1, ptr %heap, align 8
  %0 = load ptr, ptr %heap, align 8
  %call2 = call zeroext i1 @mi_heap_visit_blocks(ptr noundef %0, i1 noundef zeroext false, ptr noundef @count_blocks, ptr noundef %allocated_blocks)
  %1 = load i64, ptr %allocated_blocks, align 8
  store i64 %1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store i64 0, ptr %total, align 8
  %2 = load ptr, ptr %runtime.addr, align 8
  %call3 = call ptr @_PyRuntimeState_GetFinalizing(ptr noundef %2)
  %cmp = icmp ne ptr %call3, null
  br i1 %cmp, label %if.then4, label %if.else10

if.then4:                                         ; preds = %if.end
  %call5 = call ptr @_PyInterpreterState_Main()
  store ptr %call5, ptr %interp, align 8
  %3 = load ptr, ptr %interp, align 8
  %cmp6 = icmp eq ptr %3, null
  br i1 %cmp6, label %if.then7, label %if.else

if.then7:                                         ; preds = %if.then4
  br label %if.end9

if.else:                                          ; preds = %if.then4
  %4 = load ptr, ptr %interp, align 8
  %call8 = call i64 @_PyInterpreterState_GetAllocatedBlocks(ptr noundef %4)
  %5 = load i64, ptr %total, align 8
  %add = add i64 %5, %call8
  store i64 %add, ptr %total, align 8
  br label %if.end9

if.end9:                                          ; preds = %if.else, %if.then7
  br label %if.end23

if.else10:                                        ; preds = %if.end
  %6 = load ptr, ptr %runtime.addr, align 8
  %interpreters = getelementptr inbounds %struct.pyruntimestate, ptr %6, i32 0, i32 8
  %mutex = getelementptr inbounds %struct.pyinterpreters, ptr %interpreters, i32 0, i32 0
  call void @PyMutex_LockFlags(ptr noundef %mutex, i32 noundef 0)
  %call12 = call ptr @PyInterpreterState_Head()
  store ptr %call12, ptr %interp11, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.else10
  %7 = load ptr, ptr %interp11, align 8
  %cmp13 = icmp ne ptr %7, null
  br i1 %cmp13, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load ptr, ptr %interp11, align 8
  %call14 = call i32 @has_own_state(ptr noundef %8)
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %if.then16, label %if.end19

if.then16:                                        ; preds = %for.body
  %9 = load ptr, ptr %interp11, align 8
  %call17 = call i64 @_PyInterpreterState_GetAllocatedBlocks(ptr noundef %9)
  %10 = load i64, ptr %total, align 8
  %add18 = add i64 %10, %call17
  store i64 %add18, ptr %total, align 8
  br label %if.end19

if.end19:                                         ; preds = %if.then16, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end19
  %11 = load ptr, ptr %interp11, align 8
  %call20 = call ptr @PyInterpreterState_Next(ptr noundef %11)
  store ptr %call20, ptr %interp11, align 8
  br label %for.cond, !llvm.loop !93

for.end:                                          ; preds = %for.cond
  %12 = load ptr, ptr %runtime.addr, align 8
  %interpreters21 = getelementptr inbounds %struct.pyruntimestate, ptr %12, i32 0, i32 8
  %mutex22 = getelementptr inbounds %struct.pyinterpreters, ptr %interpreters21, i32 0, i32 0
  call void @PyMutex_Unlock(ptr noundef %mutex22)
  br label %if.end23

if.end23:                                         ; preds = %for.end, %if.end9
  %13 = load ptr, ptr %runtime.addr, align 8
  %obmalloc = getelementptr inbounds %struct.pyruntimestate, ptr %13, i32 0, i32 12
  %interpreter_leaks = getelementptr inbounds %struct._obmalloc_global_state, ptr %obmalloc, i32 0, i32 1
  %14 = load i64, ptr %interpreter_leaks, align 8
  %15 = load i64, ptr %total, align 8
  %add24 = add i64 %15, %14
  store i64 %add24, ptr %total, align 8
  %16 = load i64, ptr @last_final_leaks, align 8
  %17 = load i64, ptr %total, align 8
  %add25 = add i64 %17, %16
  store i64 %add25, ptr %total, align 8
  %18 = load i64, ptr %total, align 8
  store i64 %18, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end23, %if.then
  %19 = load i64, ptr %retval, align 8
  ret i64 %19
}

; Function Attrs: nounwind uwtable
define hidden i64 @_Py_GetGlobalAllocatedBlocks() #0 {
entry:
  %call = call i64 @get_num_global_allocated_blocks(ptr noundef @_PyRuntime)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define hidden ptr @_PyObject_Malloc(ptr noundef %ctx, i64 noundef %nbytes) #0 {
entry:
  %retval = alloca ptr, align 8
  %ctx.addr = alloca ptr, align 8
  %nbytes.addr = alloca i64, align 8
  %state = alloca ptr, align 8
  %ptr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i64 %nbytes, ptr %nbytes.addr, align 8
  %call = call ptr @get_state()
  store ptr %call, ptr %state, align 8
  %0 = load ptr, ptr %state, align 8
  %1 = load ptr, ptr %ctx.addr, align 8
  %2 = load i64, ptr %nbytes.addr, align 8
  %call1 = call ptr @pymalloc_alloc(ptr noundef %0, ptr noundef %1, i64 noundef %2)
  store ptr %call1, ptr %ptr, align 8
  %3 = load ptr, ptr %ptr, align 8
  %cmp = icmp ne ptr %3, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr %ptr, align 8
  store ptr %4, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i64, ptr %nbytes.addr, align 8
  %call2 = call ptr @PyMem_RawMalloc(i64 noundef %5)
  store ptr %call2, ptr %ptr, align 8
  %6 = load ptr, ptr %ptr, align 8
  %cmp3 = icmp ne ptr %6, null
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  %7 = load ptr, ptr %state, align 8
  %mgmt = getelementptr inbounds %struct._obmalloc_state, ptr %7, i32 0, i32 1
  %raw_allocated_blocks = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt, i32 0, i32 8
  %8 = load i64, ptr %raw_allocated_blocks, align 8
  %inc = add i64 %8, 1
  store i64 %inc, ptr %raw_allocated_blocks, align 8
  br label %if.end5

if.end5:                                          ; preds = %if.then4, %if.end
  %9 = load ptr, ptr %ptr, align 8
  store ptr %9, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end5, %if.then
  %10 = load ptr, ptr %retval, align 8
  ret ptr %10
}

; Function Attrs: nounwind uwtable
define internal ptr @get_state() #0 {
entry:
  %interp = alloca ptr, align 8
  %call = call ptr @_PyInterpreterState_GET()
  store ptr %call, ptr %interp, align 8
  %0 = load ptr, ptr %interp, align 8
  %call1 = call i32 @has_own_state(ptr noundef %0)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call2 = call ptr @_PyInterpreterState_Main()
  store ptr %call2, ptr %interp, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = load ptr, ptr %interp, align 8
  %obmalloc = getelementptr inbounds %struct._is, ptr %1, i32 0, i32 38
  ret ptr %obmalloc
}

; Function Attrs: nounwind uwtable
define internal ptr @pymalloc_alloc(ptr noundef %state, ptr noundef %_unused_ctx, i64 noundef %nbytes) #0 {
entry:
  %retval = alloca ptr, align 8
  %state.addr = alloca ptr, align 8
  %_unused_ctx.addr = alloca ptr, align 8
  %nbytes.addr = alloca i64, align 8
  %size = alloca i32, align 4
  %pool = alloca ptr, align 8
  %bp = alloca ptr, align 8
  store ptr %state, ptr %state.addr, align 8
  store ptr %_unused_ctx, ptr %_unused_ctx.addr, align 8
  store i64 %nbytes, ptr %nbytes.addr, align 8
  %0 = load i64, ptr %nbytes.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, ptr %nbytes.addr, align 8
  %cmp1 = icmp ugt i64 %1, 512
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end3:                                          ; preds = %if.end
  %2 = load i64, ptr %nbytes.addr, align 8
  %sub = sub i64 %2, 1
  %conv = trunc i64 %sub to i32
  %shr = lshr i32 %conv, 4
  store i32 %shr, ptr %size, align 4
  %3 = load ptr, ptr %state.addr, align 8
  %pools = getelementptr inbounds %struct._obmalloc_state, ptr %3, i32 0, i32 0
  %used = getelementptr inbounds %struct._obmalloc_pools, ptr %pools, i32 0, i32 0
  %4 = load i32, ptr %size, align 4
  %5 = load i32, ptr %size, align 4
  %add = add i32 %4, %5
  %idxprom = zext i32 %add to i64
  %arrayidx = getelementptr [64 x ptr], ptr %used, i64 0, i64 %idxprom
  %6 = load ptr, ptr %arrayidx, align 8
  store ptr %6, ptr %pool, align 8
  %7 = load ptr, ptr %pool, align 8
  %8 = load ptr, ptr %pool, align 8
  %nextpool = getelementptr inbounds %struct.pool_header, ptr %8, i32 0, i32 2
  %9 = load ptr, ptr %nextpool, align 8
  %cmp4 = icmp ne ptr %7, %9
  br i1 %cmp4, label %if.then6, label %if.else

if.then6:                                         ; preds = %if.end3
  %10 = load ptr, ptr %pool, align 8
  %ref = getelementptr inbounds %struct.pool_header, ptr %10, i32 0, i32 0
  %11 = load i32, ptr %ref, align 8
  %inc = add i32 %11, 1
  store i32 %inc, ptr %ref, align 8
  %12 = load ptr, ptr %pool, align 8
  %freeblock = getelementptr inbounds %struct.pool_header, ptr %12, i32 0, i32 1
  %13 = load ptr, ptr %freeblock, align 8
  store ptr %13, ptr %bp, align 8
  %14 = load ptr, ptr %bp, align 8
  %15 = load ptr, ptr %14, align 8
  %16 = load ptr, ptr %pool, align 8
  %freeblock7 = getelementptr inbounds %struct.pool_header, ptr %16, i32 0, i32 1
  store ptr %15, ptr %freeblock7, align 8
  %cmp8 = icmp eq ptr %15, null
  br i1 %cmp8, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.then6
  %17 = load ptr, ptr %pool, align 8
  %18 = load i32, ptr %size, align 4
  call void @pymalloc_pool_extend(ptr noundef %17, i32 noundef %18)
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %if.then6
  br label %if.end12

if.else:                                          ; preds = %if.end3
  %19 = load ptr, ptr %state.addr, align 8
  %20 = load i32, ptr %size, align 4
  %call = call ptr @allocate_from_new_pool(ptr noundef %19, i32 noundef %20)
  store ptr %call, ptr %bp, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.else, %if.end11
  %21 = load ptr, ptr %bp, align 8
  store ptr %21, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end12, %if.then2, %if.then
  %22 = load ptr, ptr %retval, align 8
  ret ptr %22
}

; Function Attrs: nounwind uwtable
define hidden ptr @_PyObject_Calloc(ptr noundef %ctx, i64 noundef %nelem, i64 noundef %elsize) #0 {
entry:
  %retval = alloca ptr, align 8
  %ctx.addr = alloca ptr, align 8
  %nelem.addr = alloca i64, align 8
  %elsize.addr = alloca i64, align 8
  %nbytes = alloca i64, align 8
  %state = alloca ptr, align 8
  %ptr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i64 %nelem, ptr %nelem.addr, align 8
  store i64 %elsize, ptr %elsize.addr, align 8
  %0 = load i64, ptr %nelem.addr, align 8
  %1 = load i64, ptr %elsize.addr, align 8
  %mul = mul i64 %0, %1
  store i64 %mul, ptr %nbytes, align 8
  %call = call ptr @get_state()
  store ptr %call, ptr %state, align 8
  %2 = load ptr, ptr %state, align 8
  %3 = load ptr, ptr %ctx.addr, align 8
  %4 = load i64, ptr %nbytes, align 8
  %call1 = call ptr @pymalloc_alloc(ptr noundef %2, ptr noundef %3, i64 noundef %4)
  store ptr %call1, ptr %ptr, align 8
  %5 = load ptr, ptr %ptr, align 8
  %cmp = icmp ne ptr %5, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load ptr, ptr %ptr, align 8
  %7 = load i64, ptr %nbytes, align 8
  call void @llvm.memset.p0.i64(ptr align 1 %6, i8 0, i64 %7, i1 false)
  %8 = load ptr, ptr %ptr, align 8
  store ptr %8, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %9 = load i64, ptr %nelem.addr, align 8
  %10 = load i64, ptr %elsize.addr, align 8
  %call2 = call ptr @PyMem_RawCalloc(i64 noundef %9, i64 noundef %10)
  store ptr %call2, ptr %ptr, align 8
  %11 = load ptr, ptr %ptr, align 8
  %cmp3 = icmp ne ptr %11, null
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  %12 = load ptr, ptr %state, align 8
  %mgmt = getelementptr inbounds %struct._obmalloc_state, ptr %12, i32 0, i32 1
  %raw_allocated_blocks = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt, i32 0, i32 8
  %13 = load i64, ptr %raw_allocated_blocks, align 8
  %inc = add i64 %13, 1
  store i64 %inc, ptr %raw_allocated_blocks, align 8
  br label %if.end5

if.end5:                                          ; preds = %if.then4, %if.end
  %14 = load ptr, ptr %ptr, align 8
  store ptr %14, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end5, %if.then
  %15 = load ptr, ptr %retval, align 8
  ret ptr %15
}

; Function Attrs: nounwind uwtable
define hidden void @_PyObject_Free(ptr noundef %ctx, ptr noundef %p) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %state = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end3

if.end:                                           ; preds = %entry
  %call = call ptr @get_state()
  store ptr %call, ptr %state, align 8
  %1 = load ptr, ptr %state, align 8
  %2 = load ptr, ptr %ctx.addr, align 8
  %3 = load ptr, ptr %p.addr, align 8
  %call1 = call i32 @pymalloc_free(ptr noundef %1, ptr noundef %2, ptr noundef %3)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.end3, label %if.then2

if.then2:                                         ; preds = %if.end
  %4 = load ptr, ptr %p.addr, align 8
  call void @PyMem_RawFree(ptr noundef %4)
  %5 = load ptr, ptr %state, align 8
  %mgmt = getelementptr inbounds %struct._obmalloc_state, ptr %5, i32 0, i32 1
  %raw_allocated_blocks = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt, i32 0, i32 8
  %6 = load i64, ptr %raw_allocated_blocks, align 8
  %dec = add i64 %6, -1
  store i64 %dec, ptr %raw_allocated_blocks, align 8
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @pymalloc_free(ptr noundef %state, ptr noundef %_unused_ctx, ptr noundef %p) #0 {
entry:
  %retval = alloca i32, align 4
  %state.addr = alloca ptr, align 8
  %_unused_ctx.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %pool = alloca ptr, align 8
  %lastfree = alloca ptr, align 8
  store ptr %state, ptr %state.addr, align 8
  store ptr %_unused_ctx, ptr %_unused_ctx.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %1 = ptrtoint ptr %0 to i64
  %and = and i64 %1, -16384
  %2 = inttoptr i64 %and to ptr
  store ptr %2, ptr %pool, align 8
  %3 = load ptr, ptr %state.addr, align 8
  %4 = load ptr, ptr %p.addr, align 8
  %5 = load ptr, ptr %pool, align 8
  %call = call zeroext i1 @address_in_range(ptr noundef %3, ptr noundef %4, ptr noundef %5)
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %6 = load ptr, ptr %pool, align 8
  %freeblock = getelementptr inbounds %struct.pool_header, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %freeblock, align 8
  store ptr %7, ptr %lastfree, align 8
  %8 = load ptr, ptr %lastfree, align 8
  %9 = load ptr, ptr %p.addr, align 8
  store ptr %8, ptr %9, align 8
  %10 = load ptr, ptr %p.addr, align 8
  %11 = load ptr, ptr %pool, align 8
  %freeblock1 = getelementptr inbounds %struct.pool_header, ptr %11, i32 0, i32 1
  store ptr %10, ptr %freeblock1, align 8
  %12 = load ptr, ptr %pool, align 8
  %ref = getelementptr inbounds %struct.pool_header, ptr %12, i32 0, i32 0
  %13 = load i32, ptr %ref, align 8
  %dec = add i32 %13, -1
  store i32 %dec, ptr %ref, align 8
  %14 = load ptr, ptr %lastfree, align 8
  %cmp = icmp eq ptr %14, null
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %15 = load ptr, ptr %state.addr, align 8
  %16 = load ptr, ptr %pool, align 8
  call void @insert_to_usedpool(ptr noundef %15, ptr noundef %16)
  store i32 1, ptr %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  %17 = load ptr, ptr %pool, align 8
  %ref4 = getelementptr inbounds %struct.pool_header, ptr %17, i32 0, i32 0
  %18 = load i32, ptr %ref4, align 8
  %cmp5 = icmp ne i32 %18, 0
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end3
  store i32 1, ptr %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end3
  %19 = load ptr, ptr %state.addr, align 8
  %20 = load ptr, ptr %pool, align 8
  call void @insert_to_freepool(ptr noundef %19, ptr noundef %20)
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then6, %if.then2, %if.then
  %21 = load i32, ptr %retval, align 4
  ret i32 %21
}

; Function Attrs: nounwind uwtable
define hidden ptr @_PyObject_Realloc(ptr noundef %ctx, ptr noundef %ptr, i64 noundef %nbytes) #0 {
entry:
  %retval = alloca ptr, align 8
  %ctx.addr = alloca ptr, align 8
  %ptr.addr = alloca ptr, align 8
  %nbytes.addr = alloca i64, align 8
  %ptr2 = alloca ptr, align 8
  %state = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  store i64 %nbytes, ptr %nbytes.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %ctx.addr, align 8
  %2 = load i64, ptr %nbytes.addr, align 8
  %call = call ptr @_PyObject_Malloc(ptr noundef %1, i64 noundef %2)
  store ptr %call, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call ptr @get_state()
  store ptr %call1, ptr %state, align 8
  %3 = load ptr, ptr %state, align 8
  %4 = load ptr, ptr %ctx.addr, align 8
  %5 = load ptr, ptr %ptr.addr, align 8
  %6 = load i64, ptr %nbytes.addr, align 8
  %call2 = call i32 @pymalloc_realloc(ptr noundef %3, ptr noundef %4, ptr noundef %ptr2, ptr noundef %5, i64 noundef %6)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %7 = load ptr, ptr %ptr2, align 8
  store ptr %7, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  %8 = load ptr, ptr %ptr.addr, align 8
  %9 = load i64, ptr %nbytes.addr, align 8
  %call5 = call ptr @PyMem_RawRealloc(ptr noundef %8, i64 noundef %9)
  store ptr %call5, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end4, %if.then3, %if.then
  %10 = load ptr, ptr %retval, align 8
  ret ptr %10
}

; Function Attrs: nounwind uwtable
define internal i32 @pymalloc_realloc(ptr noundef %state, ptr noundef %ctx, ptr noundef %newptr_p, ptr noundef %p, i64 noundef %nbytes) #0 {
entry:
  %retval = alloca i32, align 4
  %state.addr = alloca ptr, align 8
  %ctx.addr = alloca ptr, align 8
  %newptr_p.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %nbytes.addr = alloca i64, align 8
  %bp = alloca ptr, align 8
  %pool = alloca ptr, align 8
  %size = alloca i64, align 8
  store ptr %state, ptr %state.addr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %newptr_p, ptr %newptr_p.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %nbytes, ptr %nbytes.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %1 = ptrtoint ptr %0 to i64
  %and = and i64 %1, -16384
  %2 = inttoptr i64 %and to ptr
  store ptr %2, ptr %pool, align 8
  %3 = load ptr, ptr %state.addr, align 8
  %4 = load ptr, ptr %p.addr, align 8
  %5 = load ptr, ptr %pool, align 8
  %call = call zeroext i1 @address_in_range(ptr noundef %3, ptr noundef %4, ptr noundef %5)
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %6 = load ptr, ptr %pool, align 8
  %szidx = getelementptr inbounds %struct.pool_header, ptr %6, i32 0, i32 5
  %7 = load i32, ptr %szidx, align 4
  %add = add i32 %7, 1
  %shl = shl i32 %add, 4
  %conv = zext i32 %shl to i64
  store i64 %conv, ptr %size, align 8
  %8 = load i64, ptr %nbytes.addr, align 8
  %9 = load i64, ptr %size, align 8
  %cmp = icmp ule i64 %8, %9
  br i1 %cmp, label %if.then2, label %if.end8

if.then2:                                         ; preds = %if.end
  %10 = load i64, ptr %nbytes.addr, align 8
  %mul = mul i64 4, %10
  %11 = load i64, ptr %size, align 8
  %mul3 = mul i64 3, %11
  %cmp4 = icmp ugt i64 %mul, %mul3
  br i1 %cmp4, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.then2
  %12 = load ptr, ptr %p.addr, align 8
  %13 = load ptr, ptr %newptr_p.addr, align 8
  store ptr %12, ptr %13, align 8
  store i32 1, ptr %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.then2
  %14 = load i64, ptr %nbytes.addr, align 8
  store i64 %14, ptr %size, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.end7, %if.end
  %15 = load ptr, ptr %ctx.addr, align 8
  %16 = load i64, ptr %nbytes.addr, align 8
  %call9 = call ptr @_PyObject_Malloc(ptr noundef %15, i64 noundef %16)
  store ptr %call9, ptr %bp, align 8
  %17 = load ptr, ptr %bp, align 8
  %cmp10 = icmp ne ptr %17, null
  br i1 %cmp10, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end8
  %18 = load ptr, ptr %bp, align 8
  %19 = load ptr, ptr %p.addr, align 8
  %20 = load i64, ptr %size, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %18, ptr align 1 %19, i64 %20, i1 false)
  %21 = load ptr, ptr %ctx.addr, align 8
  %22 = load ptr, ptr %p.addr, align 8
  call void @_PyObject_Free(ptr noundef %21, ptr noundef %22)
  br label %if.end13

if.end13:                                         ; preds = %if.then12, %if.end8
  %23 = load ptr, ptr %bp, align 8
  %24 = load ptr, ptr %newptr_p.addr, align 8
  store ptr %23, ptr %24, align 8
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end13, %if.then6, %if.then
  %25 = load i32, ptr %retval, align 4
  ret i32 %25
}

; Function Attrs: nounwind uwtable
define hidden ptr @_PyMem_DebugRawMalloc(ptr noundef %ctx, i64 noundef %nbytes) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %nbytes.addr = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i64 %nbytes, ptr %nbytes.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %1 = load i64, ptr %nbytes.addr, align 8
  %call = call ptr @_PyMem_DebugRawAlloc(i32 noundef 0, ptr noundef %0, i64 noundef %1)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @_PyMem_DebugRawAlloc(i32 noundef %use_calloc, ptr noundef %ctx, i64 noundef %nbytes) #0 {
entry:
  %retval = alloca ptr, align 8
  %use_calloc.addr = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %nbytes.addr = alloca i64, align 8
  %api = alloca ptr, align 8
  %p = alloca ptr, align 8
  %data = alloca ptr, align 8
  %tail = alloca ptr, align 8
  %total = alloca i64, align 8
  store i32 %use_calloc, ptr %use_calloc.addr, align 4
  store ptr %ctx, ptr %ctx.addr, align 8
  store i64 %nbytes, ptr %nbytes.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  store ptr %0, ptr %api, align 8
  %1 = load i64, ptr %nbytes.addr, align 8
  %cmp = icmp ugt i64 %1, 9223372036854775783
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i64, ptr %nbytes.addr, align 8
  %add = add i64 %2, 24
  store i64 %add, ptr %total, align 8
  %3 = load i32, ptr %use_calloc.addr, align 4
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.then1, label %if.else

if.then1:                                         ; preds = %if.end
  %4 = load ptr, ptr %api, align 8
  %alloc = getelementptr inbounds %struct.debug_alloc_api_t, ptr %4, i32 0, i32 1
  %calloc = getelementptr inbounds %struct.PyMemAllocatorEx, ptr %alloc, i32 0, i32 2
  %5 = load ptr, ptr %calloc, align 8
  %6 = load ptr, ptr %api, align 8
  %alloc2 = getelementptr inbounds %struct.debug_alloc_api_t, ptr %6, i32 0, i32 1
  %ctx3 = getelementptr inbounds %struct.PyMemAllocatorEx, ptr %alloc2, i32 0, i32 0
  %7 = load ptr, ptr %ctx3, align 8
  %8 = load i64, ptr %total, align 8
  %call = call ptr %5(ptr noundef %7, i64 noundef 1, i64 noundef %8)
  store ptr %call, ptr %p, align 8
  br label %if.end8

if.else:                                          ; preds = %if.end
  %9 = load ptr, ptr %api, align 8
  %alloc4 = getelementptr inbounds %struct.debug_alloc_api_t, ptr %9, i32 0, i32 1
  %malloc = getelementptr inbounds %struct.PyMemAllocatorEx, ptr %alloc4, i32 0, i32 1
  %10 = load ptr, ptr %malloc, align 8
  %11 = load ptr, ptr %api, align 8
  %alloc5 = getelementptr inbounds %struct.debug_alloc_api_t, ptr %11, i32 0, i32 1
  %ctx6 = getelementptr inbounds %struct.PyMemAllocatorEx, ptr %alloc5, i32 0, i32 0
  %12 = load ptr, ptr %ctx6, align 8
  %13 = load i64, ptr %total, align 8
  %call7 = call ptr %10(ptr noundef %12, i64 noundef %13)
  store ptr %call7, ptr %p, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.else, %if.then1
  %14 = load ptr, ptr %p, align 8
  %cmp9 = icmp eq ptr %14, null
  br i1 %cmp9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end8
  store ptr null, ptr %retval, align 8
  br label %return

if.end11:                                         ; preds = %if.end8
  %15 = load ptr, ptr %p, align 8
  %add.ptr = getelementptr i8, ptr %15, i64 16
  store ptr %add.ptr, ptr %data, align 8
  %16 = load ptr, ptr %p, align 8
  %17 = load i64, ptr %nbytes.addr, align 8
  call void @write_size_t(ptr noundef %16, i64 noundef %17)
  %18 = load ptr, ptr %api, align 8
  %api_id = getelementptr inbounds %struct.debug_alloc_api_t, ptr %18, i32 0, i32 0
  %19 = load i8, ptr %api_id, align 8
  %20 = load ptr, ptr %p, align 8
  %arrayidx = getelementptr i8, ptr %20, i64 8
  store i8 %19, ptr %arrayidx, align 1
  %21 = load ptr, ptr %p, align 8
  %add.ptr12 = getelementptr i8, ptr %21, i64 8
  %add.ptr13 = getelementptr i8, ptr %add.ptr12, i64 1
  call void @llvm.memset.p0.i64(ptr align 1 %add.ptr13, i8 -3, i64 7, i1 false)
  %22 = load i64, ptr %nbytes.addr, align 8
  %cmp14 = icmp ugt i64 %22, 0
  br i1 %cmp14, label %land.lhs.true, label %if.end17

land.lhs.true:                                    ; preds = %if.end11
  %23 = load i32, ptr %use_calloc.addr, align 4
  %tobool15 = icmp ne i32 %23, 0
  br i1 %tobool15, label %if.end17, label %if.then16

if.then16:                                        ; preds = %land.lhs.true
  %24 = load ptr, ptr %data, align 8
  %25 = load i64, ptr %nbytes.addr, align 8
  call void @llvm.memset.p0.i64(ptr align 1 %24, i8 -51, i64 %25, i1 false)
  br label %if.end17

if.end17:                                         ; preds = %if.then16, %land.lhs.true, %if.end11
  %26 = load ptr, ptr %data, align 8
  %27 = load i64, ptr %nbytes.addr, align 8
  %add.ptr18 = getelementptr i8, ptr %26, i64 %27
  store ptr %add.ptr18, ptr %tail, align 8
  %28 = load ptr, ptr %tail, align 8
  call void @llvm.memset.p0.i64(ptr align 1 %28, i8 -3, i64 8, i1 false)
  %29 = load ptr, ptr %data, align 8
  store ptr %29, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end17, %if.then10, %if.then
  %30 = load ptr, ptr %retval, align 8
  ret ptr %30
}

; Function Attrs: nounwind uwtable
define hidden ptr @_PyMem_DebugRawCalloc(ptr noundef %ctx, i64 noundef %nelem, i64 noundef %elsize) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %nelem.addr = alloca i64, align 8
  %elsize.addr = alloca i64, align 8
  %nbytes = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i64 %nelem, ptr %nelem.addr, align 8
  store i64 %elsize, ptr %elsize.addr, align 8
  %0 = load i64, ptr %nelem.addr, align 8
  %1 = load i64, ptr %elsize.addr, align 8
  %mul = mul i64 %0, %1
  store i64 %mul, ptr %nbytes, align 8
  %2 = load ptr, ptr %ctx.addr, align 8
  %3 = load i64, ptr %nbytes, align 8
  %call = call ptr @_PyMem_DebugRawAlloc(i32 noundef 1, ptr noundef %2, i64 noundef %3)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define hidden void @_PyMem_DebugRawFree(ptr noundef %ctx, ptr noundef %p) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %api = alloca ptr, align 8
  %q = alloca ptr, align 8
  %nbytes = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %ctx.addr, align 8
  store ptr %1, ptr %api, align 8
  %2 = load ptr, ptr %p.addr, align 8
  %add.ptr = getelementptr i8, ptr %2, i64 -16
  store ptr %add.ptr, ptr %q, align 8
  %3 = load ptr, ptr %api, align 8
  %api_id = getelementptr inbounds %struct.debug_alloc_api_t, ptr %3, i32 0, i32 0
  %4 = load i8, ptr %api_id, align 8
  %5 = load ptr, ptr %p.addr, align 8
  call void @_PyMem_DebugCheckAddress(ptr noundef @__func__._PyMem_DebugRawFree, i8 noundef signext %4, ptr noundef %5)
  %6 = load ptr, ptr %q, align 8
  %call = call i64 @read_size_t(ptr noundef %6)
  store i64 %call, ptr %nbytes, align 8
  %7 = load i64, ptr %nbytes, align 8
  %add = add i64 %7, 24
  store i64 %add, ptr %nbytes, align 8
  %8 = load ptr, ptr %q, align 8
  %9 = load i64, ptr %nbytes, align 8
  call void @llvm.memset.p0.i64(ptr align 1 %8, i8 -35, i64 %9, i1 false)
  %10 = load ptr, ptr %api, align 8
  %alloc = getelementptr inbounds %struct.debug_alloc_api_t, ptr %10, i32 0, i32 1
  %free = getelementptr inbounds %struct.PyMemAllocatorEx, ptr %alloc, i32 0, i32 4
  %11 = load ptr, ptr %free, align 8
  %12 = load ptr, ptr %api, align 8
  %alloc1 = getelementptr inbounds %struct.debug_alloc_api_t, ptr %12, i32 0, i32 1
  %ctx2 = getelementptr inbounds %struct.PyMemAllocatorEx, ptr %alloc1, i32 0, i32 0
  %13 = load ptr, ptr %ctx2, align 8
  %14 = load ptr, ptr %q, align 8
  call void %11(ptr noundef %13, ptr noundef %14)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @_PyMem_DebugCheckAddress(ptr noundef %func, i8 noundef signext %api, ptr noundef %p) #0 {
entry:
  %func.addr = alloca ptr, align 8
  %api.addr = alloca i8, align 1
  %p.addr = alloca ptr, align 8
  %q = alloca ptr, align 8
  %nbytes = alloca i64, align 8
  %tail = alloca ptr, align 8
  %i = alloca i32, align 4
  %id = alloca i8, align 1
  store ptr %func, ptr %func.addr, align 8
  store i8 %api, ptr %api.addr, align 1
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  store ptr %0, ptr %q, align 8
  %1 = load ptr, ptr %q, align 8
  %arrayidx = getelementptr i8, ptr %1, i64 -8
  %2 = load i8, ptr %arrayidx, align 1
  store i8 %2, ptr %id, align 1
  %3 = load i8, ptr %id, align 1
  %conv = sext i8 %3 to i32
  %4 = load i8, ptr %api.addr, align 1
  %conv1 = sext i8 %4 to i32
  %cmp = icmp ne i32 %conv, %conv1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load ptr, ptr %p.addr, align 8
  call void @_PyObject_DebugDumpAddress(ptr noundef %5)
  %6 = load ptr, ptr %func.addr, align 8
  %7 = load i8, ptr %id, align 1
  %conv3 = sext i8 %7 to i32
  %8 = load i8, ptr %api.addr, align 1
  %conv4 = sext i8 %8 to i32
  call void (ptr, ptr, ...) @_Py_FatalErrorFormat(ptr noundef %6, ptr noundef @.str.159, i32 noundef %conv3, i32 noundef %conv4) #22
  unreachable

if.end:                                           ; preds = %entry
  store i32 7, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %9 = load i32, ptr %i, align 4
  %cmp5 = icmp sge i32 %9, 1
  br i1 %cmp5, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %q, align 8
  %11 = load i32, ptr %i, align 4
  %idx.ext = sext i32 %11 to i64
  %idx.neg = sub i64 0, %idx.ext
  %add.ptr = getelementptr i8, ptr %10, i64 %idx.neg
  %12 = load i8, ptr %add.ptr, align 1
  %conv7 = zext i8 %12 to i32
  %cmp8 = icmp ne i32 %conv7, 253
  br i1 %cmp8, label %if.then10, label %if.end11

if.then10:                                        ; preds = %for.body
  %13 = load ptr, ptr %p.addr, align 8
  call void @_PyObject_DebugDumpAddress(ptr noundef %13)
  %14 = load ptr, ptr %func.addr, align 8
  call void @_Py_FatalErrorFunc(ptr noundef %14, ptr noundef @.str.160) #22
  unreachable

if.end11:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end11
  %15 = load i32, ptr %i, align 4
  %dec = add i32 %15, -1
  store i32 %dec, ptr %i, align 4
  br label %for.cond, !llvm.loop !94

for.end:                                          ; preds = %for.cond
  %16 = load ptr, ptr %q, align 8
  %add.ptr12 = getelementptr i8, ptr %16, i64 -16
  %call = call i64 @read_size_t(ptr noundef %add.ptr12)
  store i64 %call, ptr %nbytes, align 8
  %17 = load ptr, ptr %q, align 8
  %18 = load i64, ptr %nbytes, align 8
  %add.ptr13 = getelementptr i8, ptr %17, i64 %18
  store ptr %add.ptr13, ptr %tail, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond14

for.cond14:                                       ; preds = %for.inc24, %for.end
  %19 = load i32, ptr %i, align 4
  %cmp15 = icmp slt i32 %19, 8
  br i1 %cmp15, label %for.body17, label %for.end25

for.body17:                                       ; preds = %for.cond14
  %20 = load ptr, ptr %tail, align 8
  %21 = load i32, ptr %i, align 4
  %idxprom = sext i32 %21 to i64
  %arrayidx18 = getelementptr i8, ptr %20, i64 %idxprom
  %22 = load i8, ptr %arrayidx18, align 1
  %conv19 = zext i8 %22 to i32
  %cmp20 = icmp ne i32 %conv19, 253
  br i1 %cmp20, label %if.then22, label %if.end23

if.then22:                                        ; preds = %for.body17
  %23 = load ptr, ptr %p.addr, align 8
  call void @_PyObject_DebugDumpAddress(ptr noundef %23)
  %24 = load ptr, ptr %func.addr, align 8
  call void @_Py_FatalErrorFunc(ptr noundef %24, ptr noundef @.str.161) #22
  unreachable

if.end23:                                         ; preds = %for.body17
  br label %for.inc24

for.inc24:                                        ; preds = %if.end23
  %25 = load i32, ptr %i, align 4
  %inc = add i32 %25, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond14, !llvm.loop !95

for.end25:                                        ; preds = %for.cond14
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @read_size_t(ptr noundef %p) #0 {
entry:
  %p.addr = alloca ptr, align 8
  %q = alloca ptr, align 8
  %result = alloca i64, align 8
  %i = alloca i32, align 4
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  store ptr %0, ptr %q, align 8
  %1 = load ptr, ptr %q, align 8
  %incdec.ptr = getelementptr i8, ptr %1, i32 1
  store ptr %incdec.ptr, ptr %q, align 8
  %2 = load i8, ptr %1, align 1
  %conv = zext i8 %2 to i64
  store i64 %conv, ptr %result, align 8
  store i32 8, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %3 = load i32, ptr %i, align 4
  %dec = add i32 %3, -1
  store i32 %dec, ptr %i, align 4
  %cmp = icmp sgt i32 %dec, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load i64, ptr %result, align 8
  %shl = shl i64 %4, 8
  %5 = load ptr, ptr %q, align 8
  %6 = load i8, ptr %5, align 1
  %conv2 = zext i8 %6 to i64
  %or = or i64 %shl, %conv2
  store i64 %or, ptr %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %7 = load ptr, ptr %q, align 8
  %incdec.ptr3 = getelementptr i8, ptr %7, i32 1
  store ptr %incdec.ptr3, ptr %q, align 8
  br label %for.cond, !llvm.loop !96

for.end:                                          ; preds = %for.cond
  %8 = load i64, ptr %result, align 8
  ret i64 %8
}

; Function Attrs: nounwind uwtable
define hidden ptr @_PyMem_DebugRawRealloc(ptr noundef %ctx, ptr noundef %p, i64 noundef %nbytes) #0 {
entry:
  %retval = alloca ptr, align 8
  %ctx.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %nbytes.addr = alloca i64, align 8
  %api = alloca ptr, align 8
  %head = alloca ptr, align 8
  %data = alloca ptr, align 8
  %r = alloca ptr, align 8
  %tail = alloca ptr, align 8
  %total = alloca i64, align 8
  %original_nbytes = alloca i64, align 8
  %save = alloca [128 x i8], align 16
  %i = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %nbytes, ptr %nbytes.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %ctx.addr, align 8
  %2 = load i64, ptr %nbytes.addr, align 8
  %call = call ptr @_PyMem_DebugRawAlloc(i32 noundef 0, ptr noundef %1, i64 noundef %2)
  store ptr %call, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %ctx.addr, align 8
  store ptr %3, ptr %api, align 8
  %4 = load ptr, ptr %api, align 8
  %api_id = getelementptr inbounds %struct.debug_alloc_api_t, ptr %4, i32 0, i32 0
  %5 = load i8, ptr %api_id, align 8
  %6 = load ptr, ptr %p.addr, align 8
  call void @_PyMem_DebugCheckAddress(ptr noundef @__func__._PyMem_DebugRawRealloc, i8 noundef signext %5, ptr noundef %6)
  %7 = load ptr, ptr %p.addr, align 8
  store ptr %7, ptr %data, align 8
  %8 = load ptr, ptr %data, align 8
  %add.ptr = getelementptr i8, ptr %8, i64 -16
  store ptr %add.ptr, ptr %head, align 8
  %9 = load ptr, ptr %head, align 8
  %call1 = call i64 @read_size_t(ptr noundef %9)
  store i64 %call1, ptr %original_nbytes, align 8
  %10 = load i64, ptr %nbytes.addr, align 8
  %cmp2 = icmp ugt i64 %10, 9223372036854775783
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  %11 = load i64, ptr %nbytes.addr, align 8
  %add = add i64 %11, 24
  store i64 %add, ptr %total, align 8
  %12 = load ptr, ptr %data, align 8
  %13 = load i64, ptr %original_nbytes, align 8
  %add.ptr5 = getelementptr i8, ptr %12, i64 %13
  store ptr %add.ptr5, ptr %tail, align 8
  %14 = load i64, ptr %original_nbytes, align 8
  %cmp6 = icmp ule i64 %14, 128
  br i1 %cmp6, label %if.then7, label %if.else

if.then7:                                         ; preds = %if.end4
  %arraydecay = getelementptr inbounds [128 x i8], ptr %save, i64 0, i64 0
  %15 = load ptr, ptr %data, align 8
  %16 = load i64, ptr %original_nbytes, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arraydecay, ptr align 1 %15, i64 %16, i1 false)
  %17 = load ptr, ptr %data, align 8
  %add.ptr8 = getelementptr i8, ptr %17, i64 -16
  %18 = load i64, ptr %original_nbytes, align 8
  %add9 = add i64 %18, 24
  call void @llvm.memset.p0.i64(ptr align 1 %add.ptr8, i8 -35, i64 %add9, i1 false)
  br label %if.end13

if.else:                                          ; preds = %if.end4
  %arraydecay10 = getelementptr inbounds [128 x i8], ptr %save, i64 0, i64 0
  %19 = load ptr, ptr %data, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arraydecay10, ptr align 1 %19, i64 64, i1 false)
  %20 = load ptr, ptr %head, align 8
  call void @llvm.memset.p0.i64(ptr align 1 %20, i8 -35, i64 80, i1 false)
  %arrayidx = getelementptr [128 x i8], ptr %save, i64 0, i64 64
  %21 = load ptr, ptr %tail, align 8
  %add.ptr11 = getelementptr i8, ptr %21, i64 -64
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx, ptr align 1 %add.ptr11, i64 64, i1 false)
  %22 = load ptr, ptr %tail, align 8
  %add.ptr12 = getelementptr i8, ptr %22, i64 -64
  call void @llvm.memset.p0.i64(ptr align 1 %add.ptr12, i8 -35, i64 72, i1 false)
  br label %if.end13

if.end13:                                         ; preds = %if.else, %if.then7
  %23 = load ptr, ptr %api, align 8
  %alloc = getelementptr inbounds %struct.debug_alloc_api_t, ptr %23, i32 0, i32 1
  %realloc = getelementptr inbounds %struct.PyMemAllocatorEx, ptr %alloc, i32 0, i32 3
  %24 = load ptr, ptr %realloc, align 8
  %25 = load ptr, ptr %api, align 8
  %alloc14 = getelementptr inbounds %struct.debug_alloc_api_t, ptr %25, i32 0, i32 1
  %ctx15 = getelementptr inbounds %struct.PyMemAllocatorEx, ptr %alloc14, i32 0, i32 0
  %26 = load ptr, ptr %ctx15, align 8
  %27 = load ptr, ptr %head, align 8
  %28 = load i64, ptr %total, align 8
  %call16 = call ptr %24(ptr noundef %26, ptr noundef %27, i64 noundef %28)
  store ptr %call16, ptr %r, align 8
  %29 = load ptr, ptr %r, align 8
  %cmp17 = icmp eq ptr %29, null
  br i1 %cmp17, label %if.then18, label %if.else19

if.then18:                                        ; preds = %if.end13
  %30 = load i64, ptr %original_nbytes, align 8
  store i64 %30, ptr %nbytes.addr, align 8
  br label %if.end20

if.else19:                                        ; preds = %if.end13
  %31 = load ptr, ptr %r, align 8
  store ptr %31, ptr %head, align 8
  br label %if.end20

if.end20:                                         ; preds = %if.else19, %if.then18
  %32 = load ptr, ptr %head, align 8
  %add.ptr21 = getelementptr i8, ptr %32, i64 16
  store ptr %add.ptr21, ptr %data, align 8
  %33 = load ptr, ptr %head, align 8
  %34 = load i64, ptr %nbytes.addr, align 8
  call void @write_size_t(ptr noundef %33, i64 noundef %34)
  %35 = load ptr, ptr %api, align 8
  %api_id22 = getelementptr inbounds %struct.debug_alloc_api_t, ptr %35, i32 0, i32 0
  %36 = load i8, ptr %api_id22, align 8
  %37 = load ptr, ptr %head, align 8
  %arrayidx23 = getelementptr i8, ptr %37, i64 8
  store i8 %36, ptr %arrayidx23, align 1
  %38 = load ptr, ptr %head, align 8
  %add.ptr24 = getelementptr i8, ptr %38, i64 8
  %add.ptr25 = getelementptr i8, ptr %add.ptr24, i64 1
  call void @llvm.memset.p0.i64(ptr align 1 %add.ptr25, i8 -3, i64 7, i1 false)
  %39 = load ptr, ptr %data, align 8
  %40 = load i64, ptr %nbytes.addr, align 8
  %add.ptr26 = getelementptr i8, ptr %39, i64 %40
  store ptr %add.ptr26, ptr %tail, align 8
  %41 = load ptr, ptr %tail, align 8
  call void @llvm.memset.p0.i64(ptr align 1 %41, i8 -3, i64 8, i1 false)
  %42 = load i64, ptr %original_nbytes, align 8
  %cmp27 = icmp ule i64 %42, 128
  br i1 %cmp27, label %if.then28, label %if.else31

if.then28:                                        ; preds = %if.end20
  %43 = load ptr, ptr %data, align 8
  %arraydecay29 = getelementptr inbounds [128 x i8], ptr %save, i64 0, i64 0
  %44 = load i64, ptr %nbytes.addr, align 8
  %45 = load i64, ptr %original_nbytes, align 8
  %cmp30 = icmp ugt i64 %44, %45
  br i1 %cmp30, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then28
  %46 = load i64, ptr %original_nbytes, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then28
  %47 = load i64, ptr %nbytes.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %46, %cond.true ], [ %47, %cond.false ]
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %43, ptr align 16 %arraydecay29, i64 %cond, i1 false)
  br label %if.end50

if.else31:                                        ; preds = %if.end20
  %48 = load i64, ptr %original_nbytes, align 8
  %sub = sub i64 %48, 64
  store i64 %sub, ptr %i, align 8
  %49 = load ptr, ptr %data, align 8
  %arraydecay32 = getelementptr inbounds [128 x i8], ptr %save, i64 0, i64 0
  %50 = load i64, ptr %nbytes.addr, align 8
  %cmp33 = icmp ugt i64 %50, 64
  br i1 %cmp33, label %cond.true34, label %cond.false35

cond.true34:                                      ; preds = %if.else31
  br label %cond.end36

cond.false35:                                     ; preds = %if.else31
  %51 = load i64, ptr %nbytes.addr, align 8
  br label %cond.end36

cond.end36:                                       ; preds = %cond.false35, %cond.true34
  %cond37 = phi i64 [ 64, %cond.true34 ], [ %51, %cond.false35 ]
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %49, ptr align 16 %arraydecay32, i64 %cond37, i1 false)
  %52 = load i64, ptr %nbytes.addr, align 8
  %53 = load i64, ptr %i, align 8
  %cmp38 = icmp ugt i64 %52, %53
  br i1 %cmp38, label %if.then39, label %if.end49

if.then39:                                        ; preds = %cond.end36
  %54 = load ptr, ptr %data, align 8
  %55 = load i64, ptr %i, align 8
  %add.ptr40 = getelementptr i8, ptr %54, i64 %55
  %arrayidx41 = getelementptr [128 x i8], ptr %save, i64 0, i64 64
  %56 = load i64, ptr %nbytes.addr, align 8
  %57 = load i64, ptr %i, align 8
  %sub42 = sub i64 %56, %57
  %cmp43 = icmp ugt i64 %sub42, 64
  br i1 %cmp43, label %cond.true44, label %cond.false45

cond.true44:                                      ; preds = %if.then39
  br label %cond.end47

cond.false45:                                     ; preds = %if.then39
  %58 = load i64, ptr %nbytes.addr, align 8
  %59 = load i64, ptr %i, align 8
  %sub46 = sub i64 %58, %59
  br label %cond.end47

cond.end47:                                       ; preds = %cond.false45, %cond.true44
  %cond48 = phi i64 [ 64, %cond.true44 ], [ %sub46, %cond.false45 ]
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %add.ptr40, ptr align 16 %arrayidx41, i64 %cond48, i1 false)
  br label %if.end49

if.end49:                                         ; preds = %cond.end47, %cond.end36
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %cond.end
  %60 = load ptr, ptr %r, align 8
  %cmp51 = icmp eq ptr %60, null
  br i1 %cmp51, label %if.then52, label %if.end53

if.then52:                                        ; preds = %if.end50
  store ptr null, ptr %retval, align 8
  br label %return

if.end53:                                         ; preds = %if.end50
  %61 = load i64, ptr %nbytes.addr, align 8
  %62 = load i64, ptr %original_nbytes, align 8
  %cmp54 = icmp ugt i64 %61, %62
  br i1 %cmp54, label %if.then55, label %if.end58

if.then55:                                        ; preds = %if.end53
  %63 = load ptr, ptr %data, align 8
  %64 = load i64, ptr %original_nbytes, align 8
  %add.ptr56 = getelementptr i8, ptr %63, i64 %64
  %65 = load i64, ptr %nbytes.addr, align 8
  %66 = load i64, ptr %original_nbytes, align 8
  %sub57 = sub i64 %65, %66
  call void @llvm.memset.p0.i64(ptr align 1 %add.ptr56, i8 -51, i64 %sub57, i1 false)
  br label %if.end58

if.end58:                                         ; preds = %if.then55, %if.end53
  %67 = load ptr, ptr %data, align 8
  store ptr %67, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end58, %if.then52, %if.then3, %if.then
  %68 = load ptr, ptr %retval, align 8
  ret ptr %68
}

; Function Attrs: nounwind uwtable
define internal void @write_size_t(ptr noundef %p, i64 noundef %n) #0 {
entry:
  %p.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %q = alloca ptr, align 8
  %i = alloca i32, align 4
  store ptr %p, ptr %p.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %add.ptr = getelementptr i8, ptr %0, i64 8
  %add.ptr1 = getelementptr i8, ptr %add.ptr, i64 -1
  store ptr %add.ptr1, ptr %q, align 8
  store i32 8, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, ptr %i, align 4
  %dec = add i32 %1, -1
  store i32 %dec, ptr %i, align 4
  %cmp = icmp sge i32 %dec, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i64, ptr %n.addr, align 8
  %and = and i64 %2, 255
  %conv = trunc i64 %and to i8
  %3 = load ptr, ptr %q, align 8
  store i8 %conv, ptr %3, align 1
  %4 = load i64, ptr %n.addr, align 8
  %shr = lshr i64 %4, 8
  store i64 %shr, ptr %n.addr, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %5 = load ptr, ptr %q, align 8
  %incdec.ptr = getelementptr i8, ptr %5, i32 -1
  store ptr %incdec.ptr, ptr %q, align 8
  br label %for.cond, !llvm.loop !97

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define hidden ptr @_PyMem_DebugMalloc(ptr noundef %ctx, i64 noundef %nbytes) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %nbytes.addr = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i64 %nbytes, ptr %nbytes.addr, align 8
  call void @_PyMem_DebugCheckGIL(ptr noundef @__func__._PyMem_DebugMalloc)
  %0 = load ptr, ptr %ctx.addr, align 8
  %1 = load i64, ptr %nbytes.addr, align 8
  %call = call ptr @_PyMem_DebugRawMalloc(ptr noundef %0, i64 noundef %1)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal void @_PyMem_DebugCheckGIL(ptr noundef %func) #0 {
entry:
  %func.addr = alloca ptr, align 8
  store ptr %func, ptr %func.addr, align 8
  %call = call i32 @PyGILState_Check()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %0 = load ptr, ptr %func.addr, align 8
  call void @_Py_FatalErrorFunc(ptr noundef %0, ptr noundef @.str.158) #22
  unreachable

if.end:                                           ; preds = %entry
  ret void
}

; Function Attrs: nounwind uwtable
define hidden ptr @_PyMem_DebugCalloc(ptr noundef %ctx, i64 noundef %nelem, i64 noundef %elsize) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %nelem.addr = alloca i64, align 8
  %elsize.addr = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i64 %nelem, ptr %nelem.addr, align 8
  store i64 %elsize, ptr %elsize.addr, align 8
  call void @_PyMem_DebugCheckGIL(ptr noundef @__func__._PyMem_DebugCalloc)
  %0 = load ptr, ptr %ctx.addr, align 8
  %1 = load i64, ptr %nelem.addr, align 8
  %2 = load i64, ptr %elsize.addr, align 8
  %call = call ptr @_PyMem_DebugRawCalloc(ptr noundef %0, i64 noundef %1, i64 noundef %2)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define hidden void @_PyMem_DebugFree(ptr noundef %ctx, ptr noundef %ptr) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %ptr.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  call void @_PyMem_DebugCheckGIL(ptr noundef @__func__._PyMem_DebugFree)
  %0 = load ptr, ptr %ctx.addr, align 8
  %1 = load ptr, ptr %ptr.addr, align 8
  call void @_PyMem_DebugRawFree(ptr noundef %0, ptr noundef %1)
  ret void
}

; Function Attrs: nounwind uwtable
define hidden ptr @_PyMem_DebugRealloc(ptr noundef %ctx, ptr noundef %ptr, i64 noundef %nbytes) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %ptr.addr = alloca ptr, align 8
  %nbytes.addr = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  store i64 %nbytes, ptr %nbytes.addr, align 8
  call void @_PyMem_DebugCheckGIL(ptr noundef @__func__._PyMem_DebugRealloc)
  %0 = load ptr, ptr %ctx.addr, align 8
  %1 = load ptr, ptr %ptr.addr, align 8
  %2 = load i64, ptr %nbytes.addr, align 8
  %call = call ptr @_PyMem_DebugRawRealloc(ptr noundef %0, ptr noundef %1, i64 noundef %2)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define hidden void @_PyDebugAllocatorStats(ptr noundef %out, ptr noundef %block_name, i32 noundef %num_blocks, i64 noundef %sizeof_block) #0 {
entry:
  %out.addr = alloca ptr, align 8
  %block_name.addr = alloca ptr, align 8
  %num_blocks.addr = alloca i32, align 4
  %sizeof_block.addr = alloca i64, align 8
  %buf1 = alloca [128 x i8], align 16
  %buf2 = alloca [128 x i8], align 16
  store ptr %out, ptr %out.addr, align 8
  store ptr %block_name, ptr %block_name.addr, align 8
  store i32 %num_blocks, ptr %num_blocks.addr, align 4
  store i64 %sizeof_block, ptr %sizeof_block.addr, align 8
  %arraydecay = getelementptr inbounds [128 x i8], ptr %buf1, i64 0, i64 0
  %0 = load i32, ptr %num_blocks.addr, align 4
  %1 = load ptr, ptr %block_name.addr, align 8
  %2 = load i64, ptr %sizeof_block.addr, align 8
  %call = call i32 (ptr, i64, ptr, ...) @PyOS_snprintf(ptr noundef %arraydecay, i64 noundef 128, ptr noundef @.str.43, i32 noundef %0, ptr noundef %1, i64 noundef %2)
  %arraydecay1 = getelementptr inbounds [128 x i8], ptr %buf2, i64 0, i64 0
  %arraydecay2 = getelementptr inbounds [128 x i8], ptr %buf1, i64 0, i64 0
  %call3 = call i32 (ptr, i64, ptr, ...) @PyOS_snprintf(ptr noundef %arraydecay1, i64 noundef 128, ptr noundef @.str.44, ptr noundef %arraydecay2)
  %3 = load ptr, ptr %out.addr, align 8
  %arraydecay4 = getelementptr inbounds [128 x i8], ptr %buf2, i64 0, i64 0
  %4 = load i32, ptr %num_blocks.addr, align 4
  %conv = sext i32 %4 to i64
  %5 = load i64, ptr %sizeof_block.addr, align 8
  %mul = mul i64 %conv, %5
  %call5 = call i64 @printone(ptr noundef %3, ptr noundef %arraydecay4, i64 noundef %mul)
  ret void
}

declare i32 @PyOS_snprintf(ptr noundef, i64 noundef, ptr noundef, ...) #8

; Function Attrs: nounwind uwtable
define internal i64 @printone(ptr noundef %out, ptr noundef %msg, i64 noundef %value) #0 {
entry:
  %out.addr = alloca ptr, align 8
  %msg.addr = alloca ptr, align 8
  %value.addr = alloca i64, align 8
  %i = alloca i32, align 4
  %k = alloca i32, align 4
  %buf = alloca [100 x i8], align 16
  %origvalue = alloca i64, align 8
  %nextvalue = alloca i64, align 8
  %digit = alloca i32, align 4
  store ptr %out, ptr %out.addr, align 8
  store ptr %msg, ptr %msg.addr, align 8
  store i64 %value, ptr %value.addr, align 8
  %0 = load i64, ptr %value.addr, align 8
  store i64 %0, ptr %origvalue, align 8
  %1 = load ptr, ptr %msg.addr, align 8
  %2 = load ptr, ptr %out.addr, align 8
  %call = call i32 @fputs(ptr noundef %1, ptr noundef %2)
  %3 = load ptr, ptr %msg.addr, align 8
  %call1 = call i64 @strlen(ptr noundef %3) #16
  %conv = trunc i64 %call1 to i32
  store i32 %conv, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %4 = load i32, ptr %i, align 4
  %cmp = icmp slt i32 %4, 35
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load ptr, ptr %out.addr, align 8
  %call3 = call i32 @fputc(i32 noundef 32, ptr noundef %5)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %6 = load i32, ptr %i, align 4
  %inc = add i32 %6, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !98

for.end:                                          ; preds = %for.cond
  %7 = load ptr, ptr %out.addr, align 8
  %call4 = call i32 @fputc(i32 noundef 61, ptr noundef %7)
  store i32 22, ptr %i, align 4
  %8 = load i32, ptr %i, align 4
  %dec = add i32 %8, -1
  store i32 %dec, ptr %i, align 4
  %idxprom = sext i32 %8 to i64
  %arrayidx = getelementptr [100 x i8], ptr %buf, i64 0, i64 %idxprom
  store i8 0, ptr %arrayidx, align 1
  %9 = load i32, ptr %i, align 4
  %dec5 = add i32 %9, -1
  store i32 %dec5, ptr %i, align 4
  %idxprom6 = sext i32 %9 to i64
  %arrayidx7 = getelementptr [100 x i8], ptr %buf, i64 0, i64 %idxprom6
  store i8 10, ptr %arrayidx7, align 1
  store i32 3, ptr %k, align 4
  br label %do.body

do.body:                                          ; preds = %land.end, %for.end
  %10 = load i64, ptr %value.addr, align 8
  %div = udiv i64 %10, 10
  store i64 %div, ptr %nextvalue, align 8
  %11 = load i64, ptr %value.addr, align 8
  %12 = load i64, ptr %nextvalue, align 8
  %mul = mul i64 %12, 10
  %sub = sub i64 %11, %mul
  %conv8 = trunc i64 %sub to i32
  store i32 %conv8, ptr %digit, align 4
  %13 = load i64, ptr %nextvalue, align 8
  store i64 %13, ptr %value.addr, align 8
  %14 = load i32, ptr %digit, align 4
  %add = add i32 %14, 48
  %conv9 = trunc i32 %add to i8
  %15 = load i32, ptr %i, align 4
  %dec10 = add i32 %15, -1
  store i32 %dec10, ptr %i, align 4
  %idxprom11 = sext i32 %15 to i64
  %arrayidx12 = getelementptr [100 x i8], ptr %buf, i64 0, i64 %idxprom11
  store i8 %conv9, ptr %arrayidx12, align 1
  %16 = load i32, ptr %k, align 4
  %dec13 = add i32 %16, -1
  store i32 %dec13, ptr %k, align 4
  %17 = load i32, ptr %k, align 4
  %cmp14 = icmp eq i32 %17, 0
  br i1 %cmp14, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %do.body
  %18 = load i64, ptr %value.addr, align 8
  %tobool = icmp ne i64 %18, 0
  br i1 %tobool, label %land.lhs.true16, label %if.end

land.lhs.true16:                                  ; preds = %land.lhs.true
  %19 = load i32, ptr %i, align 4
  %cmp17 = icmp sge i32 %19, 0
  br i1 %cmp17, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true16
  store i32 3, ptr %k, align 4
  %20 = load i32, ptr %i, align 4
  %dec19 = add i32 %20, -1
  store i32 %dec19, ptr %i, align 4
  %idxprom20 = sext i32 %20 to i64
  %arrayidx21 = getelementptr [100 x i8], ptr %buf, i64 0, i64 %idxprom20
  store i8 44, ptr %arrayidx21, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true16, %land.lhs.true, %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  %21 = load i64, ptr %value.addr, align 8
  %tobool22 = icmp ne i64 %21, 0
  br i1 %tobool22, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %do.cond
  %22 = load i32, ptr %i, align 4
  %cmp23 = icmp sge i32 %22, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %do.cond
  %23 = phi i1 [ false, %do.cond ], [ %cmp23, %land.rhs ]
  br i1 %23, label %do.body, label %do.end, !llvm.loop !99

do.end:                                           ; preds = %land.end
  br label %while.cond

while.cond:                                       ; preds = %while.body, %do.end
  %24 = load i32, ptr %i, align 4
  %cmp25 = icmp sge i32 %24, 0
  br i1 %cmp25, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %25 = load i32, ptr %i, align 4
  %dec27 = add i32 %25, -1
  store i32 %dec27, ptr %i, align 4
  %idxprom28 = sext i32 %25 to i64
  %arrayidx29 = getelementptr [100 x i8], ptr %buf, i64 0, i64 %idxprom28
  store i8 32, ptr %arrayidx29, align 1
  br label %while.cond, !llvm.loop !100

while.end:                                        ; preds = %while.cond
  %arraydecay = getelementptr inbounds [100 x i8], ptr %buf, i64 0, i64 0
  %26 = load ptr, ptr %out.addr, align 8
  %call30 = call i32 @fputs(ptr noundef %arraydecay, ptr noundef %26)
  %27 = load i64, ptr %origvalue, align 8
  ret i64 %27
}

; Function Attrs: nounwind uwtable
define dso_local i32 @_PyObject_DebugMallocStats(ptr noundef %out) #0 {
entry:
  %retval = alloca i32, align 4
  %out.addr = alloca ptr, align 8
  store ptr %out, ptr %out.addr, align 8
  %call = call i32 @_PyMem_MimallocEnabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %0 = load ptr, ptr %out.addr, align 8
  call void @py_mimalloc_print_stats(ptr noundef %0)
  store i32 1, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %call1 = call i32 @_PyMem_PymallocEnabled()
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then3, label %if.else4

if.then3:                                         ; preds = %if.else
  %1 = load ptr, ptr %out.addr, align 8
  call void @pymalloc_print_stats(ptr noundef %1)
  store i32 1, ptr %retval, align 4
  br label %return

if.else4:                                         ; preds = %if.else
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.else4, %if.then3, %if.then
  %2 = load i32, ptr %retval, align 4
  ret i32 %2
}

; Function Attrs: nounwind uwtable
define internal void @py_mimalloc_print_stats(ptr noundef %out) #0 {
entry:
  %out.addr = alloca ptr, align 8
  %heap = alloca ptr, align 8
  %stats = alloca %struct._alloc_stats, align 8
  store ptr %out, ptr %out.addr, align 8
  %0 = load ptr, ptr %out.addr, align 8
  %call = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %0, ptr noundef @.str.176, i64 noundef 16384, i32 noundef 73)
  %1 = load ptr, ptr %out.addr, align 8
  %call1 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %1, ptr noundef @.str.177, i64 noundef 131072)
  %2 = load ptr, ptr %out.addr, align 8
  %call2 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %2, ptr noundef @.str.178, i64 noundef 16777216)
  %call3 = call ptr @mi_heap_get_default()
  store ptr %call3, ptr %heap, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %stats, i8 0, i64 40, i1 false)
  %3 = load ptr, ptr %heap, align 8
  %call4 = call zeroext i1 @mi_heap_visit_blocks(ptr noundef %3, i1 noundef zeroext false, ptr noundef @_collect_alloc_stats, ptr noundef %stats)
  %4 = load ptr, ptr %out.addr, align 8
  %allocated_blocks = getelementptr inbounds %struct._alloc_stats, ptr %stats, i32 0, i32 0
  %5 = load i64, ptr %allocated_blocks, align 8
  %call5 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %4, ptr noundef @.str.179, i64 noundef %5)
  %6 = load ptr, ptr %out.addr, align 8
  %allocated_bytes = getelementptr inbounds %struct._alloc_stats, ptr %stats, i32 0, i32 1
  %7 = load i64, ptr %allocated_bytes, align 8
  %call6 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %6, ptr noundef @.str.180, i64 noundef %7)
  %8 = load ptr, ptr %out.addr, align 8
  %allocated_with_overhead = getelementptr inbounds %struct._alloc_stats, ptr %stats, i32 0, i32 2
  %9 = load i64, ptr %allocated_with_overhead, align 8
  %call7 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %8, ptr noundef @.str.181, i64 noundef %9)
  %10 = load ptr, ptr %out.addr, align 8
  %bytes_reserved = getelementptr inbounds %struct._alloc_stats, ptr %stats, i32 0, i32 3
  %11 = load i64, ptr %bytes_reserved, align 8
  %call8 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %10, ptr noundef @.str.182, i64 noundef %11)
  %12 = load ptr, ptr %out.addr, align 8
  %bytes_committed = getelementptr inbounds %struct._alloc_stats, ptr %stats, i32 0, i32 4
  %13 = load i64, ptr %bytes_committed, align 8
  %call9 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %12, ptr noundef @.str.183, i64 noundef %13)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @_PyMem_PymallocEnabled() #0 {
entry:
  %retval = alloca i32, align 4
  %call = call i32 @_PyMem_DebugEnabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %0 = load ptr, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 2, i32 2, i32 1, i32 1), align 8
  %cmp = icmp eq ptr %0, @_PyObject_Malloc
  %conv = zext i1 %cmp to i32
  store i32 %conv, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %1 = load ptr, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1, i32 2, i32 1), align 8
  %cmp1 = icmp eq ptr %1, @_PyObject_Malloc
  %conv2 = zext i1 %cmp1 to i32
  store i32 %conv2, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.else, %if.then
  %2 = load i32, ptr %retval, align 4
  ret i32 %2
}

; Function Attrs: nounwind uwtable
define internal void @pymalloc_print_stats(ptr noundef %out) #0 {
entry:
  %out.addr = alloca ptr, align 8
  %state = alloca ptr, align 8
  %i = alloca i32, align 4
  %numclasses = alloca i32, align 4
  %numpools = alloca [32 x i64], align 16
  %numblocks = alloca [32 x i64], align 16
  %numfreeblocks = alloca [32 x i64], align 16
  %allocated_bytes = alloca i64, align 8
  %available_bytes = alloca i64, align 8
  %numfreepools = alloca i32, align 4
  %arena_alignment = alloca i64, align 8
  %pool_header_bytes = alloca i64, align 8
  %quantization = alloca i64, align 8
  %narenas = alloca i64, align 8
  %total = alloca i64, align 8
  %buf = alloca [128 x i8], align 16
  %base = alloca i64, align 8
  %p = alloca ptr, align 8
  %sz = alloca i32, align 4
  %freeblocks = alloca i32, align 4
  %p63 = alloca i64, align 8
  %b = alloca i64, align 8
  %f = alloca i64, align 8
  %size = alloca i32, align 4
  store ptr %out, ptr %out.addr, align 8
  %call = call ptr @get_state()
  store ptr %call, ptr %state, align 8
  store i32 32, ptr %numclasses, align 4
  store i64 0, ptr %allocated_bytes, align 8
  store i64 0, ptr %available_bytes, align 8
  store i32 0, ptr %numfreepools, align 4
  store i64 0, ptr %arena_alignment, align 8
  store i64 0, ptr %pool_header_bytes, align 8
  store i64 0, ptr %quantization, align 8
  store i64 0, ptr %narenas, align 8
  %0 = load ptr, ptr %out.addr, align 8
  %call1 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %0, ptr noundef @.str.184, i32 noundef 512, i32 noundef 32)
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, ptr %i, align 4
  %cmp = icmp ult i32 %1, 32
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i32, ptr %i, align 4
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr [32 x i64], ptr %numfreeblocks, i64 0, i64 %idxprom
  store i64 0, ptr %arrayidx, align 8
  %3 = load i32, ptr %i, align 4
  %idxprom2 = zext i32 %3 to i64
  %arrayidx3 = getelementptr [32 x i64], ptr %numblocks, i64 0, i64 %idxprom2
  store i64 0, ptr %arrayidx3, align 8
  %4 = load i32, ptr %i, align 4
  %idxprom4 = zext i32 %4 to i64
  %arrayidx5 = getelementptr [32 x i64], ptr %numpools, i64 0, i64 %idxprom4
  store i64 0, ptr %arrayidx5, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %5 = load i32, ptr %i, align 4
  %inc = add i32 %5, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !101

for.end:                                          ; preds = %for.cond
  store i32 0, ptr %i, align 4
  br label %for.cond6

for.cond6:                                        ; preds = %for.inc54, %for.end
  %6 = load i32, ptr %i, align 4
  %7 = load ptr, ptr %state, align 8
  %mgmt = getelementptr inbounds %struct._obmalloc_state, ptr %7, i32 0, i32 1
  %maxarenas = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt, i32 0, i32 1
  %8 = load i32, ptr %maxarenas, align 8
  %cmp7 = icmp ult i32 %6, %8
  br i1 %cmp7, label %for.body8, label %for.end56

for.body8:                                        ; preds = %for.cond6
  %9 = load ptr, ptr %state, align 8
  %mgmt9 = getelementptr inbounds %struct._obmalloc_state, ptr %9, i32 0, i32 1
  %arenas = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt9, i32 0, i32 0
  %10 = load ptr, ptr %arenas, align 8
  %11 = load i32, ptr %i, align 4
  %idxprom10 = zext i32 %11 to i64
  %arrayidx11 = getelementptr %struct.arena_object, ptr %10, i64 %idxprom10
  %address = getelementptr inbounds %struct.arena_object, ptr %arrayidx11, i32 0, i32 0
  %12 = load i64, ptr %address, align 8
  store i64 %12, ptr %base, align 8
  %13 = load ptr, ptr %state, align 8
  %mgmt12 = getelementptr inbounds %struct._obmalloc_state, ptr %13, i32 0, i32 1
  %arenas13 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt12, i32 0, i32 0
  %14 = load ptr, ptr %arenas13, align 8
  %15 = load i32, ptr %i, align 4
  %idxprom14 = zext i32 %15 to i64
  %arrayidx15 = getelementptr %struct.arena_object, ptr %14, i64 %idxprom14
  %address16 = getelementptr inbounds %struct.arena_object, ptr %arrayidx15, i32 0, i32 0
  %16 = load i64, ptr %address16, align 8
  %cmp17 = icmp eq i64 %16, 0
  br i1 %cmp17, label %if.then, label %if.end

if.then:                                          ; preds = %for.body8
  br label %for.inc54

if.end:                                           ; preds = %for.body8
  %17 = load i64, ptr %narenas, align 8
  %add = add i64 %17, 1
  store i64 %add, ptr %narenas, align 8
  %18 = load ptr, ptr %state, align 8
  %mgmt18 = getelementptr inbounds %struct._obmalloc_state, ptr %18, i32 0, i32 1
  %arenas19 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt18, i32 0, i32 0
  %19 = load ptr, ptr %arenas19, align 8
  %20 = load i32, ptr %i, align 4
  %idxprom20 = zext i32 %20 to i64
  %arrayidx21 = getelementptr %struct.arena_object, ptr %19, i64 %idxprom20
  %nfreepools = getelementptr inbounds %struct.arena_object, ptr %arrayidx21, i32 0, i32 2
  %21 = load i32, ptr %nfreepools, align 8
  %22 = load i32, ptr %numfreepools, align 4
  %add22 = add i32 %22, %21
  store i32 %add22, ptr %numfreepools, align 4
  %23 = load i64, ptr %base, align 8
  %and = and i64 %23, 16383
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.then23, label %if.end27

if.then23:                                        ; preds = %if.end
  %24 = load i64, ptr %arena_alignment, align 8
  %add24 = add i64 %24, 16384
  store i64 %add24, ptr %arena_alignment, align 8
  %25 = load i64, ptr %base, align 8
  %and25 = and i64 %25, -16384
  store i64 %and25, ptr %base, align 8
  %26 = load i64, ptr %base, align 8
  %add26 = add i64 %26, 16384
  store i64 %add26, ptr %base, align 8
  br label %if.end27

if.end27:                                         ; preds = %if.then23, %if.end
  br label %for.cond28

for.cond28:                                       ; preds = %for.inc51, %if.end27
  %27 = load i64, ptr %base, align 8
  %28 = load ptr, ptr %state, align 8
  %mgmt29 = getelementptr inbounds %struct._obmalloc_state, ptr %28, i32 0, i32 1
  %arenas30 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt29, i32 0, i32 0
  %29 = load ptr, ptr %arenas30, align 8
  %30 = load i32, ptr %i, align 4
  %idxprom31 = zext i32 %30 to i64
  %arrayidx32 = getelementptr %struct.arena_object, ptr %29, i64 %idxprom31
  %pool_address = getelementptr inbounds %struct.arena_object, ptr %arrayidx32, i32 0, i32 1
  %31 = load ptr, ptr %pool_address, align 8
  %32 = ptrtoint ptr %31 to i64
  %cmp33 = icmp ult i64 %27, %32
  br i1 %cmp33, label %for.body34, label %for.end53

for.body34:                                       ; preds = %for.cond28
  %33 = load i64, ptr %base, align 8
  %34 = inttoptr i64 %33 to ptr
  store ptr %34, ptr %p, align 8
  %35 = load ptr, ptr %p, align 8
  %szidx = getelementptr inbounds %struct.pool_header, ptr %35, i32 0, i32 5
  %36 = load i32, ptr %szidx, align 4
  store i32 %36, ptr %sz, align 4
  %37 = load ptr, ptr %p, align 8
  %ref = getelementptr inbounds %struct.pool_header, ptr %37, i32 0, i32 0
  %38 = load i32, ptr %ref, align 8
  %cmp35 = icmp eq i32 %38, 0
  br i1 %cmp35, label %if.then36, label %if.end37

if.then36:                                        ; preds = %for.body34
  br label %for.inc51

if.end37:                                         ; preds = %for.body34
  %39 = load i32, ptr %sz, align 4
  %idxprom38 = zext i32 %39 to i64
  %arrayidx39 = getelementptr [32 x i64], ptr %numpools, i64 0, i64 %idxprom38
  %40 = load i64, ptr %arrayidx39, align 8
  %inc40 = add i64 %40, 1
  store i64 %inc40, ptr %arrayidx39, align 8
  %41 = load ptr, ptr %p, align 8
  %ref41 = getelementptr inbounds %struct.pool_header, ptr %41, i32 0, i32 0
  %42 = load i32, ptr %ref41, align 8
  %conv = zext i32 %42 to i64
  %43 = load i32, ptr %sz, align 4
  %idxprom42 = zext i32 %43 to i64
  %arrayidx43 = getelementptr [32 x i64], ptr %numblocks, i64 0, i64 %idxprom42
  %44 = load i64, ptr %arrayidx43, align 8
  %add44 = add i64 %44, %conv
  store i64 %add44, ptr %arrayidx43, align 8
  %45 = load i32, ptr %sz, align 4
  %add45 = add i32 %45, 1
  %shl = shl i32 %add45, 4
  %div = udiv i32 16336, %shl
  %46 = load ptr, ptr %p, align 8
  %ref46 = getelementptr inbounds %struct.pool_header, ptr %46, i32 0, i32 0
  %47 = load i32, ptr %ref46, align 8
  %sub = sub i32 %div, %47
  store i32 %sub, ptr %freeblocks, align 4
  %48 = load i32, ptr %freeblocks, align 4
  %conv47 = zext i32 %48 to i64
  %49 = load i32, ptr %sz, align 4
  %idxprom48 = zext i32 %49 to i64
  %arrayidx49 = getelementptr [32 x i64], ptr %numfreeblocks, i64 0, i64 %idxprom48
  %50 = load i64, ptr %arrayidx49, align 8
  %add50 = add i64 %50, %conv47
  store i64 %add50, ptr %arrayidx49, align 8
  br label %for.inc51

for.inc51:                                        ; preds = %if.end37, %if.then36
  %51 = load i64, ptr %base, align 8
  %add52 = add i64 %51, 16384
  store i64 %add52, ptr %base, align 8
  br label %for.cond28, !llvm.loop !102

for.end53:                                        ; preds = %for.cond28
  br label %for.inc54

for.inc54:                                        ; preds = %for.end53, %if.then
  %52 = load i32, ptr %i, align 4
  %inc55 = add i32 %52, 1
  store i32 %inc55, ptr %i, align 4
  br label %for.cond6, !llvm.loop !103

for.end56:                                        ; preds = %for.cond6
  %53 = load ptr, ptr %out.addr, align 8
  %call57 = call i32 @fputc(i32 noundef 10, ptr noundef %53)
  %54 = load ptr, ptr %out.addr, align 8
  %call58 = call i32 @fputs(ptr noundef @.str.185, ptr noundef %54)
  store i32 0, ptr %i, align 4
  br label %for.cond59

for.cond59:                                       ; preds = %for.inc87, %for.end56
  %55 = load i32, ptr %i, align 4
  %cmp60 = icmp ult i32 %55, 32
  br i1 %cmp60, label %for.body62, label %for.end89

for.body62:                                       ; preds = %for.cond59
  %56 = load i32, ptr %i, align 4
  %idxprom64 = zext i32 %56 to i64
  %arrayidx65 = getelementptr [32 x i64], ptr %numpools, i64 0, i64 %idxprom64
  %57 = load i64, ptr %arrayidx65, align 8
  store i64 %57, ptr %p63, align 8
  %58 = load i32, ptr %i, align 4
  %idxprom66 = zext i32 %58 to i64
  %arrayidx67 = getelementptr [32 x i64], ptr %numblocks, i64 0, i64 %idxprom66
  %59 = load i64, ptr %arrayidx67, align 8
  store i64 %59, ptr %b, align 8
  %60 = load i32, ptr %i, align 4
  %idxprom68 = zext i32 %60 to i64
  %arrayidx69 = getelementptr [32 x i64], ptr %numfreeblocks, i64 0, i64 %idxprom68
  %61 = load i64, ptr %arrayidx69, align 8
  store i64 %61, ptr %f, align 8
  %62 = load i32, ptr %i, align 4
  %add70 = add i32 %62, 1
  %shl71 = shl i32 %add70, 4
  store i32 %shl71, ptr %size, align 4
  %63 = load i64, ptr %p63, align 8
  %cmp72 = icmp eq i64 %63, 0
  br i1 %cmp72, label %if.then74, label %if.end75

if.then74:                                        ; preds = %for.body62
  br label %for.inc87

if.end75:                                         ; preds = %for.body62
  %64 = load ptr, ptr %out.addr, align 8
  %65 = load i32, ptr %i, align 4
  %66 = load i32, ptr %size, align 4
  %67 = load i64, ptr %p63, align 8
  %68 = load i64, ptr %b, align 8
  %69 = load i64, ptr %f, align 8
  %call76 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %64, ptr noundef @.str.186, i32 noundef %65, i32 noundef %66, i64 noundef %67, i64 noundef %68, i64 noundef %69)
  %70 = load i64, ptr %b, align 8
  %71 = load i32, ptr %size, align 4
  %conv77 = zext i32 %71 to i64
  %mul = mul i64 %70, %conv77
  %72 = load i64, ptr %allocated_bytes, align 8
  %add78 = add i64 %72, %mul
  store i64 %add78, ptr %allocated_bytes, align 8
  %73 = load i64, ptr %f, align 8
  %74 = load i32, ptr %size, align 4
  %conv79 = zext i32 %74 to i64
  %mul80 = mul i64 %73, %conv79
  %75 = load i64, ptr %available_bytes, align 8
  %add81 = add i64 %75, %mul80
  store i64 %add81, ptr %available_bytes, align 8
  %76 = load i64, ptr %p63, align 8
  %mul82 = mul i64 %76, 48
  %77 = load i64, ptr %pool_header_bytes, align 8
  %add83 = add i64 %77, %mul82
  store i64 %add83, ptr %pool_header_bytes, align 8
  %78 = load i64, ptr %p63, align 8
  %79 = load i32, ptr %size, align 4
  %conv84 = zext i32 %79 to i64
  %rem = urem i64 16336, %conv84
  %mul85 = mul i64 %78, %rem
  %80 = load i64, ptr %quantization, align 8
  %add86 = add i64 %80, %mul85
  store i64 %add86, ptr %quantization, align 8
  br label %for.inc87

for.inc87:                                        ; preds = %if.end75, %if.then74
  %81 = load i32, ptr %i, align 4
  %inc88 = add i32 %81, 1
  store i32 %inc88, ptr %i, align 4
  br label %for.cond59, !llvm.loop !104

for.end89:                                        ; preds = %for.cond59
  %82 = load ptr, ptr %out.addr, align 8
  %call90 = call i32 @fputc(i32 noundef 10, ptr noundef %82)
  %83 = load ptr, ptr %out.addr, align 8
  %84 = load ptr, ptr %state, align 8
  %mgmt91 = getelementptr inbounds %struct._obmalloc_state, ptr %84, i32 0, i32 1
  %ntimes_arena_allocated = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt91, i32 0, i32 6
  %85 = load i64, ptr %ntimes_arena_allocated, align 8
  %call92 = call i64 @printone(ptr noundef %83, ptr noundef @.str.187, i64 noundef %85)
  %86 = load ptr, ptr %out.addr, align 8
  %87 = load ptr, ptr %state, align 8
  %mgmt93 = getelementptr inbounds %struct._obmalloc_state, ptr %87, i32 0, i32 1
  %ntimes_arena_allocated94 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt93, i32 0, i32 6
  %88 = load i64, ptr %ntimes_arena_allocated94, align 8
  %89 = load i64, ptr %narenas, align 8
  %sub95 = sub i64 %88, %89
  %call96 = call i64 @printone(ptr noundef %86, ptr noundef @.str.188, i64 noundef %sub95)
  %90 = load ptr, ptr %out.addr, align 8
  %91 = load ptr, ptr %state, align 8
  %mgmt97 = getelementptr inbounds %struct._obmalloc_state, ptr %91, i32 0, i32 1
  %narenas_highwater = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt97, i32 0, i32 7
  %92 = load i64, ptr %narenas_highwater, align 8
  %call98 = call i64 @printone(ptr noundef %90, ptr noundef @.str.189, i64 noundef %92)
  %93 = load ptr, ptr %out.addr, align 8
  %94 = load i64, ptr %narenas, align 8
  %call99 = call i64 @printone(ptr noundef %93, ptr noundef @.str.190, i64 noundef %94)
  %arraydecay = getelementptr inbounds [128 x i8], ptr %buf, i64 0, i64 0
  %95 = load i64, ptr %narenas, align 8
  %call100 = call i32 (ptr, i64, ptr, ...) @PyOS_snprintf(ptr noundef %arraydecay, i64 noundef 128, ptr noundef @.str.191, i64 noundef %95, i32 noundef 1048576)
  %96 = load ptr, ptr %out.addr, align 8
  %arraydecay101 = getelementptr inbounds [128 x i8], ptr %buf, i64 0, i64 0
  %97 = load i64, ptr %narenas, align 8
  %mul102 = mul i64 %97, 1048576
  %call103 = call i64 @printone(ptr noundef %96, ptr noundef %arraydecay101, i64 noundef %mul102)
  %98 = load ptr, ptr %out.addr, align 8
  %call104 = call i32 @fputc(i32 noundef 10, ptr noundef %98)
  %99 = load ptr, ptr %out.addr, align 8
  %100 = load i64, ptr %allocated_bytes, align 8
  %call105 = call i64 @printone(ptr noundef %99, ptr noundef @.str.192, i64 noundef %100)
  store i64 %call105, ptr %total, align 8
  %101 = load ptr, ptr %out.addr, align 8
  %102 = load i64, ptr %available_bytes, align 8
  %call106 = call i64 @printone(ptr noundef %101, ptr noundef @.str.193, i64 noundef %102)
  %103 = load i64, ptr %total, align 8
  %add107 = add i64 %103, %call106
  store i64 %add107, ptr %total, align 8
  %arraydecay108 = getelementptr inbounds [128 x i8], ptr %buf, i64 0, i64 0
  %104 = load i32, ptr %numfreepools, align 4
  %call109 = call i32 (ptr, i64, ptr, ...) @PyOS_snprintf(ptr noundef %arraydecay108, i64 noundef 128, ptr noundef @.str.194, i32 noundef %104, i32 noundef 16384)
  %105 = load ptr, ptr %out.addr, align 8
  %arraydecay110 = getelementptr inbounds [128 x i8], ptr %buf, i64 0, i64 0
  %106 = load i32, ptr %numfreepools, align 4
  %conv111 = zext i32 %106 to i64
  %mul112 = mul i64 %conv111, 16384
  %call113 = call i64 @printone(ptr noundef %105, ptr noundef %arraydecay110, i64 noundef %mul112)
  %107 = load i64, ptr %total, align 8
  %add114 = add i64 %107, %call113
  store i64 %add114, ptr %total, align 8
  %108 = load ptr, ptr %out.addr, align 8
  %109 = load i64, ptr %pool_header_bytes, align 8
  %call115 = call i64 @printone(ptr noundef %108, ptr noundef @.str.195, i64 noundef %109)
  %110 = load i64, ptr %total, align 8
  %add116 = add i64 %110, %call115
  store i64 %add116, ptr %total, align 8
  %111 = load ptr, ptr %out.addr, align 8
  %112 = load i64, ptr %quantization, align 8
  %call117 = call i64 @printone(ptr noundef %111, ptr noundef @.str.196, i64 noundef %112)
  %113 = load i64, ptr %total, align 8
  %add118 = add i64 %113, %call117
  store i64 %add118, ptr %total, align 8
  %114 = load ptr, ptr %out.addr, align 8
  %115 = load i64, ptr %arena_alignment, align 8
  %call119 = call i64 @printone(ptr noundef %114, ptr noundef @.str.197, i64 noundef %115)
  %116 = load i64, ptr %total, align 8
  %add120 = add i64 %116, %call119
  store i64 %add120, ptr %total, align 8
  %117 = load ptr, ptr %out.addr, align 8
  %118 = load i64, ptr %total, align 8
  %call121 = call i64 @printone(ptr noundef %117, ptr noundef @.str.198, i64 noundef %118)
  %119 = load ptr, ptr %out.addr, align 8
  %call122 = call i32 @fputs(ptr noundef @.str.199, ptr noundef %119)
  %120 = load ptr, ptr %out.addr, align 8
  %121 = load ptr, ptr %state, align 8
  %usage = getelementptr inbounds %struct._obmalloc_state, ptr %121, i32 0, i32 2
  %arena_map_mid_count = getelementptr inbounds %struct._obmalloc_usage, ptr %usage, i32 0, i32 1
  %122 = load i32, ptr %arena_map_mid_count, align 8
  %conv123 = sext i32 %122 to i64
  %call124 = call i64 @printone(ptr noundef %120, ptr noundef @.str.200, i64 noundef %conv123)
  %123 = load ptr, ptr %out.addr, align 8
  %124 = load ptr, ptr %state, align 8
  %usage125 = getelementptr inbounds %struct._obmalloc_state, ptr %124, i32 0, i32 2
  %arena_map_bot_count = getelementptr inbounds %struct._obmalloc_usage, ptr %usage125, i32 0, i32 2
  %125 = load i32, ptr %arena_map_bot_count, align 4
  %conv126 = sext i32 %125 to i64
  %call127 = call i64 @printone(ptr noundef %123, ptr noundef @.str.201, i64 noundef %conv126)
  %126 = load ptr, ptr %out.addr, align 8
  %call128 = call i32 @fputc(i32 noundef 10, ptr noundef %126)
  %127 = load ptr, ptr %out.addr, align 8
  %call129 = call i64 @printone(ptr noundef %127, ptr noundef @.str.202, i64 noundef 262144)
  store i64 %call129, ptr %total, align 8
  %128 = load ptr, ptr %out.addr, align 8
  %129 = load ptr, ptr %state, align 8
  %usage130 = getelementptr inbounds %struct._obmalloc_state, ptr %129, i32 0, i32 2
  %arena_map_mid_count131 = getelementptr inbounds %struct._obmalloc_usage, ptr %usage130, i32 0, i32 1
  %130 = load i32, ptr %arena_map_mid_count131, align 8
  %conv132 = sext i32 %130 to i64
  %mul133 = mul i64 262144, %conv132
  %call134 = call i64 @printone(ptr noundef %128, ptr noundef @.str.203, i64 noundef %mul133)
  %131 = load i64, ptr %total, align 8
  %add135 = add i64 %131, %call134
  store i64 %add135, ptr %total, align 8
  %132 = load ptr, ptr %out.addr, align 8
  %133 = load ptr, ptr %state, align 8
  %usage136 = getelementptr inbounds %struct._obmalloc_state, ptr %133, i32 0, i32 2
  %arena_map_bot_count137 = getelementptr inbounds %struct._obmalloc_usage, ptr %usage136, i32 0, i32 2
  %134 = load i32, ptr %arena_map_bot_count137, align 4
  %conv138 = sext i32 %134 to i64
  %mul139 = mul i64 131072, %conv138
  %call140 = call i64 @printone(ptr noundef %132, ptr noundef @.str.204, i64 noundef %mul139)
  %135 = load i64, ptr %total, align 8
  %add141 = add i64 %135, %call140
  store i64 %add141, ptr %total, align 8
  %136 = load ptr, ptr %out.addr, align 8
  %137 = load i64, ptr %total, align 8
  %call142 = call i64 @printone(ptr noundef %136, ptr noundef @.str.198, i64 noundef %137)
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write)
declare void @llvm.assume(i1 noundef) #13

; Function Attrs: nounwind uwtable
define internal ptr @_mi_heap_get_free_small_page(ptr noundef %heap, i64 noundef %size) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %idx = alloca i64, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load i64, ptr %size.addr, align 8
  %call = call i64 @_mi_wsize_from_size(i64 noundef %0)
  store i64 %call, ptr %idx, align 8
  %1 = load ptr, ptr %heap.addr, align 8
  %pages_free_direct = getelementptr inbounds %struct.mi_heap_s, ptr %1, i32 0, i32 1
  %2 = load i64, ptr %idx, align 8
  %arrayidx = getelementptr [129 x ptr], ptr %pages_free_direct, i64 0, i64 %2
  %3 = load ptr, ptr %arrayidx, align 8
  ret ptr %3
}

; Function Attrs: nounwind uwtable
define internal i64 @_mi_wsize_from_size(i64 noundef %size) #0 {
entry:
  %size.addr = alloca i64, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load i64, ptr %size.addr, align 8
  %add = add i64 %0, 8
  %sub = sub i64 %add, 1
  %div = udiv i64 %sub, 8
  ret i64 %div
}

; Function Attrs: nounwind uwtable
define internal void @_mi_free_block_mt(ptr noundef %page, ptr noundef %block) #0 {
entry:
  %page.addr = alloca ptr, align 8
  %block.addr = alloca ptr, align 8
  %segment = alloca ptr, align 8
  %tfreex = alloca i64, align 8
  %use_delayed = alloca i8, align 1
  %tfree = alloca i64, align 8
  %atomic-temp = alloca i64, align 8
  %.atomictmp = alloca i64, align 8
  %cmpxchg.bool = alloca i8, align 1
  %heap = alloca ptr, align 8
  %atomic-temp23 = alloca i64, align 8
  %dfree = alloca ptr, align 8
  %atomic-temp27 = alloca ptr, align 8
  %.atomictmp31 = alloca ptr, align 8
  %cmpxchg.bool32 = alloca i8, align 1
  %atomic-temp42 = alloca i64, align 8
  %.atomictmp47 = alloca i64, align 8
  %cmpxchg.bool48 = alloca i8, align 1
  store ptr %page, ptr %page.addr, align 8
  store ptr %block, ptr %block.addr, align 8
  %0 = load ptr, ptr %page.addr, align 8
  %1 = load ptr, ptr %block.addr, align 8
  call void @mi_check_padding(ptr noundef %0, ptr noundef %1)
  %2 = load ptr, ptr %page.addr, align 8
  %3 = load ptr, ptr %block.addr, align 8
  call void @_mi_padding_shrink(ptr noundef %2, ptr noundef %3, i64 noundef 8)
  %4 = load ptr, ptr %page.addr, align 8
  %call = call ptr @_mi_page_segment(ptr noundef %4)
  store ptr %call, ptr %segment, align 8
  %5 = load ptr, ptr %segment, align 8
  %kind = getelementptr inbounds %struct.mi_segment_s, ptr %5, i32 0, i32 15
  %6 = load i32, ptr %kind, align 8
  %cmp = icmp eq i32 %6, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %7 = load ptr, ptr %segment, align 8
  %8 = load ptr, ptr %page.addr, align 8
  %9 = load ptr, ptr %block.addr, align 8
  call void @_mi_segment_huge_page_reset(ptr noundef %7, ptr noundef %8, ptr noundef %9)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %10 = load ptr, ptr %page.addr, align 8
  %xthread_free = getelementptr inbounds %struct.mi_page_s, ptr %10, i32 0, i32 11
  %11 = load atomic i64, ptr %xthread_free monotonic, align 8
  store i64 %11, ptr %atomic-temp, align 8
  %12 = load i64, ptr %atomic-temp, align 8
  store i64 %12, ptr %tfree, align 8
  br label %do.body

do.body:                                          ; preds = %cmpxchg.continue, %if.end
  %13 = load i64, ptr %tfree, align 8
  %call1 = call i32 @mi_tf_delayed(i64 noundef %13)
  %cmp2 = icmp eq i32 %call1, 0
  %frombool = zext i1 %cmp2 to i8
  store i8 %frombool, ptr %use_delayed, align 1
  %14 = load i8, ptr %use_delayed, align 1
  %tobool = trunc i8 %14 to i1
  %lnot = xor i1 %tobool, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool4 = icmp ne i64 %conv, 0
  br i1 %tobool4, label %if.then5, label %if.else

if.then5:                                         ; preds = %do.body
  %15 = load i64, ptr %tfree, align 8
  %call6 = call i64 @mi_tf_set_delayed(i64 noundef %15, i32 noundef 1)
  store i64 %call6, ptr %tfreex, align 8
  br label %if.end9

if.else:                                          ; preds = %do.body
  %16 = load ptr, ptr %page.addr, align 8
  %17 = load ptr, ptr %block.addr, align 8
  %18 = load i64, ptr %tfree, align 8
  %call7 = call ptr @mi_tf_block(i64 noundef %18)
  call void @mi_block_set_next(ptr noundef %16, ptr noundef %17, ptr noundef %call7)
  %19 = load i64, ptr %tfree, align 8
  %20 = load ptr, ptr %block.addr, align 8
  %call8 = call i64 @mi_tf_set_block(i64 noundef %19, ptr noundef %20)
  store i64 %call8, ptr %tfreex, align 8
  br label %if.end9

if.end9:                                          ; preds = %if.else, %if.then5
  br label %do.cond

do.cond:                                          ; preds = %if.end9
  %21 = load ptr, ptr %page.addr, align 8
  %xthread_free10 = getelementptr inbounds %struct.mi_page_s, ptr %21, i32 0, i32 11
  %22 = load i64, ptr %tfreex, align 8
  store i64 %22, ptr %.atomictmp, align 8
  %23 = load i64, ptr %tfree, align 8
  %24 = load i64, ptr %.atomictmp, align 8
  %25 = cmpxchg weak ptr %xthread_free10, i64 %23, i64 %24 release monotonic, align 8
  %26 = extractvalue { i64, i1 } %25, 0
  %27 = extractvalue { i64, i1 } %25, 1
  br i1 %27, label %cmpxchg.continue, label %cmpxchg.store_expected

cmpxchg.store_expected:                           ; preds = %do.cond
  store i64 %26, ptr %tfree, align 8
  br label %cmpxchg.continue

cmpxchg.continue:                                 ; preds = %cmpxchg.store_expected, %do.cond
  %frombool11 = zext i1 %27 to i8
  store i8 %frombool11, ptr %cmpxchg.bool, align 1
  %28 = load i8, ptr %cmpxchg.bool, align 1
  %tobool12 = trunc i8 %28 to i1
  %lnot13 = xor i1 %tobool12, true
  br i1 %lnot13, label %do.body, label %do.end, !llvm.loop !105

do.end:                                           ; preds = %cmpxchg.continue
  %29 = load i8, ptr %use_delayed, align 1
  %tobool15 = trunc i8 %29 to i1
  %lnot16 = xor i1 %tobool15, true
  %lnot18 = xor i1 %lnot16, true
  %lnot.ext19 = zext i1 %lnot18 to i32
  %conv20 = sext i32 %lnot.ext19 to i64
  %tobool21 = icmp ne i64 %conv20, 0
  br i1 %tobool21, label %if.then22, label %if.end56

if.then22:                                        ; preds = %do.end
  %30 = load ptr, ptr %page.addr, align 8
  %xheap = getelementptr inbounds %struct.mi_page_s, ptr %30, i32 0, i32 12
  %31 = load atomic i64, ptr %xheap acquire, align 8
  store i64 %31, ptr %atomic-temp23, align 8
  %32 = load i64, ptr %atomic-temp23, align 8
  %33 = inttoptr i64 %32 to ptr
  store ptr %33, ptr %heap, align 8
  %34 = load ptr, ptr %heap, align 8
  %cmp24 = icmp ne ptr %34, null
  br i1 %cmp24, label %if.then26, label %if.end40

if.then26:                                        ; preds = %if.then22
  %35 = load ptr, ptr %heap, align 8
  %thread_delayed_free = getelementptr inbounds %struct.mi_heap_s, ptr %35, i32 0, i32 3
  %36 = load atomic i64, ptr %thread_delayed_free monotonic, align 8
  store i64 %36, ptr %atomic-temp27, align 8
  %37 = load ptr, ptr %atomic-temp27, align 8
  store ptr %37, ptr %dfree, align 8
  br label %do.body28

do.body28:                                        ; preds = %cmpxchg.continue34, %if.then26
  %38 = load ptr, ptr %heap, align 8
  %39 = load ptr, ptr %block.addr, align 8
  %40 = load ptr, ptr %dfree, align 8
  %41 = load ptr, ptr %heap, align 8
  %keys = getelementptr inbounds %struct.mi_heap_s, ptr %41, i32 0, i32 7
  %arraydecay = getelementptr inbounds [2 x i64], ptr %keys, i64 0, i64 0
  call void @mi_block_set_nextx(ptr noundef %38, ptr noundef %39, ptr noundef %40, ptr noundef %arraydecay)
  br label %do.cond29

do.cond29:                                        ; preds = %do.body28
  %42 = load ptr, ptr %heap, align 8
  %thread_delayed_free30 = getelementptr inbounds %struct.mi_heap_s, ptr %42, i32 0, i32 3
  %43 = load ptr, ptr %block.addr, align 8
  store ptr %43, ptr %.atomictmp31, align 8
  %44 = load i64, ptr %dfree, align 8
  %45 = load i64, ptr %.atomictmp31, align 8
  %46 = cmpxchg weak ptr %thread_delayed_free30, i64 %44, i64 %45 release monotonic, align 8
  %47 = extractvalue { i64, i1 } %46, 0
  %48 = extractvalue { i64, i1 } %46, 1
  br i1 %48, label %cmpxchg.continue34, label %cmpxchg.store_expected33

cmpxchg.store_expected33:                         ; preds = %do.cond29
  store i64 %47, ptr %dfree, align 8
  br label %cmpxchg.continue34

cmpxchg.continue34:                               ; preds = %cmpxchg.store_expected33, %do.cond29
  %frombool35 = zext i1 %48 to i8
  store i8 %frombool35, ptr %cmpxchg.bool32, align 1
  %49 = load i8, ptr %cmpxchg.bool32, align 1
  %tobool36 = trunc i8 %49 to i1
  %lnot37 = xor i1 %tobool36, true
  br i1 %lnot37, label %do.body28, label %do.end39, !llvm.loop !106

do.end39:                                         ; preds = %cmpxchg.continue34
  br label %if.end40

if.end40:                                         ; preds = %do.end39, %if.then22
  %50 = load ptr, ptr %page.addr, align 8
  %xthread_free41 = getelementptr inbounds %struct.mi_page_s, ptr %50, i32 0, i32 11
  %51 = load atomic i64, ptr %xthread_free41 monotonic, align 8
  store i64 %51, ptr %atomic-temp42, align 8
  %52 = load i64, ptr %atomic-temp42, align 8
  store i64 %52, ptr %tfree, align 8
  br label %do.body43

do.body43:                                        ; preds = %cmpxchg.continue50, %if.end40
  %53 = load i64, ptr %tfree, align 8
  store i64 %53, ptr %tfreex, align 8
  %54 = load i64, ptr %tfree, align 8
  %call44 = call i64 @mi_tf_set_delayed(i64 noundef %54, i32 noundef 2)
  store i64 %call44, ptr %tfreex, align 8
  br label %do.cond45

do.cond45:                                        ; preds = %do.body43
  %55 = load ptr, ptr %page.addr, align 8
  %xthread_free46 = getelementptr inbounds %struct.mi_page_s, ptr %55, i32 0, i32 11
  %56 = load i64, ptr %tfreex, align 8
  store i64 %56, ptr %.atomictmp47, align 8
  %57 = load i64, ptr %tfree, align 8
  %58 = load i64, ptr %.atomictmp47, align 8
  %59 = cmpxchg weak ptr %xthread_free46, i64 %57, i64 %58 release monotonic, align 8
  %60 = extractvalue { i64, i1 } %59, 0
  %61 = extractvalue { i64, i1 } %59, 1
  br i1 %61, label %cmpxchg.continue50, label %cmpxchg.store_expected49

cmpxchg.store_expected49:                         ; preds = %do.cond45
  store i64 %60, ptr %tfree, align 8
  br label %cmpxchg.continue50

cmpxchg.continue50:                               ; preds = %cmpxchg.store_expected49, %do.cond45
  %frombool51 = zext i1 %61 to i8
  store i8 %frombool51, ptr %cmpxchg.bool48, align 1
  %62 = load i8, ptr %cmpxchg.bool48, align 1
  %tobool52 = trunc i8 %62 to i1
  %lnot53 = xor i1 %tobool52, true
  br i1 %lnot53, label %do.body43, label %do.end55, !llvm.loop !107

do.end55:                                         ; preds = %cmpxchg.continue50
  br label %if.end56

if.end56:                                         ; preds = %do.end55, %do.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_tf_block(i64 noundef %tf) #0 {
entry:
  %tf.addr = alloca i64, align 8
  store i64 %tf, ptr %tf.addr, align 8
  %0 = load i64, ptr %tf.addr, align 8
  %and = and i64 %0, -4
  %1 = inttoptr i64 %and to ptr
  ret ptr %1
}

; Function Attrs: nounwind uwtable
define internal i64 @mi_tf_set_block(i64 noundef %tf, ptr noundef %block) #0 {
entry:
  %tf.addr = alloca i64, align 8
  %block.addr = alloca ptr, align 8
  store i64 %tf, ptr %tf.addr, align 8
  store ptr %block, ptr %block.addr, align 8
  %0 = load ptr, ptr %block.addr, align 8
  %1 = load i64, ptr %tf.addr, align 8
  %call = call i32 @mi_tf_delayed(i64 noundef %1)
  %call1 = call i64 @mi_tf_make(ptr noundef %0, i32 noundef %call)
  ret i64 %call1
}

; Function Attrs: nounwind uwtable
define internal i64 @mi_tf_make(ptr noundef %block, i32 noundef %delayed) #0 {
entry:
  %block.addr = alloca ptr, align 8
  %delayed.addr = alloca i32, align 4
  store ptr %block, ptr %block.addr, align 8
  store i32 %delayed, ptr %delayed.addr, align 4
  %0 = load ptr, ptr %block.addr, align 8
  %1 = ptrtoint ptr %0 to i64
  %2 = load i32, ptr %delayed.addr, align 4
  %conv = zext i32 %2 to i64
  %or = or i64 %1, %conv
  ret i64 %or
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_prim_tls_slot(i64 noundef %slot) #0 {
entry:
  %slot.addr = alloca i64, align 8
  %res = alloca ptr, align 8
  %ofs = alloca i64, align 8
  store i64 %slot, ptr %slot.addr, align 8
  %0 = load i64, ptr %slot.addr, align 8
  %mul = mul i64 %0, 8
  store i64 %mul, ptr %ofs, align 8
  %1 = load i64, ptr %ofs, align 8
  %2 = inttoptr i64 %1 to ptr
  %3 = call ptr asm "movq %fs:$1, $0", "=r,*m,~{dirflag},~{fpsr},~{flags}"(ptr elementtype(ptr) %2) #23, !srcloc !108
  store ptr %3, ptr %res, align 8
  %4 = load ptr, ptr %res, align 8
  ret ptr %4
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_slice_first(ptr noundef %slice) #0 {
entry:
  %slice.addr = alloca ptr, align 8
  %start = alloca ptr, align 8
  store ptr %slice, ptr %slice.addr, align 8
  %0 = load ptr, ptr %slice.addr, align 8
  %1 = load ptr, ptr %slice.addr, align 8
  %slice_offset = getelementptr inbounds %struct.mi_page_s, ptr %1, i32 0, i32 1
  %2 = load i32, ptr %slice_offset, align 4
  %idx.ext = zext i32 %2 to i64
  %idx.neg = sub i64 0, %idx.ext
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.neg
  store ptr %add.ptr, ptr %start, align 8
  %3 = load ptr, ptr %start, align 8
  ret ptr %3
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_slice_to_page(ptr noundef %s) #0 {
entry:
  %s.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  ret ptr %0
}

; Function Attrs: nounwind uwtable
define internal i64 @mi_page_usable_size_of(ptr noundef %page, ptr noundef %block) #0 {
entry:
  %page.addr = alloca ptr, align 8
  %block.addr = alloca ptr, align 8
  store ptr %page, ptr %page.addr, align 8
  store ptr %block, ptr %block.addr, align 8
  %0 = load ptr, ptr %page.addr, align 8
  %call = call i64 @mi_page_usable_block_size(ptr noundef %0)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define internal i64 @mi_page_usable_aligned_size_of(ptr noundef %segment, ptr noundef %page, ptr noundef %p) #0 {
entry:
  %segment.addr = alloca ptr, align 8
  %page.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %block = alloca ptr, align 8
  %size = alloca i64, align 8
  %adjust = alloca i64, align 8
  store ptr %segment, ptr %segment.addr, align 8
  store ptr %page, ptr %page.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %segment.addr, align 8
  %1 = load ptr, ptr %page.addr, align 8
  %2 = load ptr, ptr %p.addr, align 8
  %call = call ptr @_mi_page_ptr_unalign(ptr noundef %0, ptr noundef %1, ptr noundef %2)
  store ptr %call, ptr %block, align 8
  %3 = load ptr, ptr %page.addr, align 8
  %4 = load ptr, ptr %block, align 8
  %call1 = call i64 @mi_page_usable_size_of(ptr noundef %3, ptr noundef %4)
  store i64 %call1, ptr %size, align 8
  %5 = load ptr, ptr %p.addr, align 8
  %6 = load ptr, ptr %block, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %5 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %6 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, ptr %adjust, align 8
  %7 = load i64, ptr %size, align 8
  %8 = load i64, ptr %adjust, align 8
  %sub = sub i64 %7, %8
  ret i64 %sub
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_mul_overflow(i64 noundef %count, i64 noundef %size, ptr noundef %total) #0 {
entry:
  %count.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %total.addr = alloca ptr, align 8
  store i64 %count, ptr %count.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store ptr %total, ptr %total.addr, align 8
  %0 = load i64, ptr %count.addr, align 8
  %1 = load i64, ptr %size.addr, align 8
  %2 = load ptr, ptr %total.addr, align 8
  %3 = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 %0, i64 %1)
  %4 = extractvalue { i64, i1 } %3, 1
  %5 = extractvalue { i64, i1 } %3, 0
  store i64 %5, ptr %2, align 8
  ret i1 %4
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare { i64, i1 } @llvm.umul.with.overflow.i64(i64, i64) #5

; Function Attrs: nounwind uwtable
define internal ptr @mi_get_new_handler() #0 {
entry:
  %call = call ptr @_Py__ZSt15get_new_handlerv()
  ret ptr %call
}

; Function Attrs: noreturn nounwind
declare void @abort() #14

; Function Attrs: nounwind uwtable
define internal ptr @mi_heap_malloc_zero_aligned_at_fallback(ptr noundef %heap, i64 noundef %size, i64 noundef %alignment, i64 noundef %offset, i1 noundef zeroext %zero) #0 {
entry:
  %retval = alloca ptr, align 8
  %heap.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  %offset.addr = alloca i64, align 8
  %zero.addr = alloca i8, align 1
  %align_mask = alloca i64, align 8
  %padsize = alloca i64, align 8
  %p = alloca ptr, align 8
  %p6 = alloca ptr, align 8
  %oversize = alloca i64, align 8
  %poffset = alloca i64, align 8
  %adjust = alloca i64, align 8
  %aligned_p = alloca ptr, align 8
  %page = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  store i64 %offset, ptr %offset.addr, align 8
  %frombool = zext i1 %zero to i8
  store i8 %frombool, ptr %zero.addr, align 1
  %0 = load i64, ptr %alignment.addr, align 8
  %sub = sub i64 %0, 1
  store i64 %sub, ptr %align_mask, align 8
  %1 = load i64, ptr %size.addr, align 8
  %add = add i64 %1, 0
  store i64 %add, ptr %padsize, align 8
  %2 = load i64, ptr %offset.addr, align 8
  %cmp = icmp eq i64 %2, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %3 = load i64, ptr %alignment.addr, align 8
  %4 = load i64, ptr %padsize, align 8
  %cmp1 = icmp ule i64 %3, %4
  br i1 %cmp1, label %land.lhs.true2, label %if.end

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %padsize, align 8
  %cmp3 = icmp ule i64 %5, 128
  br i1 %cmp3, label %land.lhs.true4, label %if.end

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load i64, ptr %padsize, align 8
  %7 = load i64, ptr %align_mask, align 8
  %and = and i64 %6, %7
  %cmp5 = icmp eq i64 %and, 0
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true4
  %8 = load ptr, ptr %heap.addr, align 8
  %9 = load i64, ptr %size.addr, align 8
  %10 = load i8, ptr %zero.addr, align 1
  %tobool = trunc i8 %10 to i1
  %call = call ptr @_mi_heap_malloc_zero(ptr noundef %8, i64 noundef %9, i1 noundef zeroext %tobool)
  store ptr %call, ptr %p, align 8
  %11 = load ptr, ptr %p, align 8
  store ptr %11, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  %12 = load i64, ptr %alignment.addr, align 8
  %cmp7 = icmp ugt i64 %12, 16777216
  %lnot = xor i1 %cmp7, true
  %lnot8 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot8 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool9 = icmp ne i64 %conv, 0
  br i1 %tobool9, label %if.then10, label %if.else

if.then10:                                        ; preds = %if.end
  %13 = load i64, ptr %offset.addr, align 8
  %cmp11 = icmp ne i64 %13, 0
  %lnot13 = xor i1 %cmp11, true
  %lnot15 = xor i1 %lnot13, true
  %lnot.ext16 = zext i1 %lnot15 to i32
  %conv17 = sext i32 %lnot.ext16 to i64
  %tobool18 = icmp ne i64 %conv17, 0
  br i1 %tobool18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %if.then10
  store ptr null, ptr %retval, align 8
  br label %return

if.end20:                                         ; preds = %if.then10
  %14 = load i64, ptr %size.addr, align 8
  %cmp21 = icmp ule i64 %14, 1024
  br i1 %cmp21, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end20
  br label %cond.end

cond.false:                                       ; preds = %if.end20
  %15 = load i64, ptr %size.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ 1025, %cond.true ], [ %15, %cond.false ]
  store i64 %cond, ptr %oversize, align 8
  %16 = load ptr, ptr %heap.addr, align 8
  %17 = load i64, ptr %oversize, align 8
  %18 = load i64, ptr %alignment.addr, align 8
  %call23 = call ptr @_mi_heap_malloc_zero_ex(ptr noundef %16, i64 noundef %17, i1 noundef zeroext false, i64 noundef %18)
  store ptr %call23, ptr %p6, align 8
  %19 = load ptr, ptr %p6, align 8
  %cmp24 = icmp eq ptr %19, null
  br i1 %cmp24, label %if.then26, label %if.end27

if.then26:                                        ; preds = %cond.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end27:                                         ; preds = %cond.end
  br label %if.end36

if.else:                                          ; preds = %if.end
  %20 = load i64, ptr %size.addr, align 8
  %21 = load i64, ptr %alignment.addr, align 8
  %add28 = add i64 %20, %21
  %sub29 = sub i64 %add28, 1
  store i64 %sub29, ptr %oversize, align 8
  %22 = load ptr, ptr %heap.addr, align 8
  %23 = load i64, ptr %oversize, align 8
  %24 = load i8, ptr %zero.addr, align 1
  %tobool30 = trunc i8 %24 to i1
  %call31 = call ptr @_mi_heap_malloc_zero(ptr noundef %22, i64 noundef %23, i1 noundef zeroext %tobool30)
  store ptr %call31, ptr %p6, align 8
  %25 = load ptr, ptr %p6, align 8
  %cmp32 = icmp eq ptr %25, null
  br i1 %cmp32, label %if.then34, label %if.end35

if.then34:                                        ; preds = %if.else
  store ptr null, ptr %retval, align 8
  br label %return

if.end35:                                         ; preds = %if.else
  br label %if.end36

if.end36:                                         ; preds = %if.end35, %if.end27
  %26 = load ptr, ptr %p6, align 8
  %27 = ptrtoint ptr %26 to i64
  %28 = load i64, ptr %offset.addr, align 8
  %add37 = add i64 %27, %28
  %29 = load i64, ptr %align_mask, align 8
  %and38 = and i64 %add37, %29
  store i64 %and38, ptr %poffset, align 8
  %30 = load i64, ptr %poffset, align 8
  %cmp39 = icmp eq i64 %30, 0
  br i1 %cmp39, label %cond.true41, label %cond.false42

cond.true41:                                      ; preds = %if.end36
  br label %cond.end44

cond.false42:                                     ; preds = %if.end36
  %31 = load i64, ptr %alignment.addr, align 8
  %32 = load i64, ptr %poffset, align 8
  %sub43 = sub i64 %31, %32
  br label %cond.end44

cond.end44:                                       ; preds = %cond.false42, %cond.true41
  %cond45 = phi i64 [ 0, %cond.true41 ], [ %sub43, %cond.false42 ]
  store i64 %cond45, ptr %adjust, align 8
  %33 = load ptr, ptr %p6, align 8
  %34 = ptrtoint ptr %33 to i64
  %35 = load i64, ptr %adjust, align 8
  %add46 = add i64 %34, %35
  %36 = inttoptr i64 %add46 to ptr
  store ptr %36, ptr %aligned_p, align 8
  %37 = load ptr, ptr %aligned_p, align 8
  %38 = load ptr, ptr %p6, align 8
  %cmp47 = icmp ne ptr %37, %38
  br i1 %cmp47, label %if.then49, label %if.end52

if.then49:                                        ; preds = %cond.end44
  %39 = load ptr, ptr %p6, align 8
  %call50 = call ptr @_mi_ptr_page(ptr noundef %39)
  store ptr %call50, ptr %page, align 8
  %40 = load ptr, ptr %page, align 8
  call void @mi_page_set_has_aligned(ptr noundef %40, i1 noundef zeroext true)
  %41 = load ptr, ptr %page, align 8
  %42 = load ptr, ptr %p6, align 8
  %43 = load i64, ptr %adjust, align 8
  %44 = load i64, ptr %size.addr, align 8
  %add51 = add i64 %43, %44
  call void @_mi_padding_shrink(ptr noundef %41, ptr noundef %42, i64 noundef %add51)
  br label %if.end52

if.end52:                                         ; preds = %if.then49, %cond.end44
  %45 = load i64, ptr %alignment.addr, align 8
  %cmp53 = icmp ugt i64 %45, 16777216
  br i1 %cmp53, label %if.then55, label %if.end60

if.then55:                                        ; preds = %if.end52
  %46 = load i8, ptr %zero.addr, align 1
  %tobool56 = trunc i8 %46 to i1
  br i1 %tobool56, label %if.then57, label %if.end59

if.then57:                                        ; preds = %if.then55
  %47 = load ptr, ptr %aligned_p, align 8
  %48 = load ptr, ptr %aligned_p, align 8
  %call58 = call i64 @mi_usable_size(ptr noundef %48)
  call void @_mi_memzero_aligned(ptr noundef %47, i64 noundef %call58)
  br label %if.end59

if.end59:                                         ; preds = %if.then57, %if.then55
  br label %if.end60

if.end60:                                         ; preds = %if.end59, %if.end52
  %49 = load ptr, ptr %p6, align 8
  %50 = load ptr, ptr %aligned_p, align 8
  %cmp61 = icmp ne ptr %49, %50
  br i1 %cmp61, label %if.then63, label %if.end64

if.then63:                                        ; preds = %if.end60
  br label %if.end64

if.end64:                                         ; preds = %if.then63, %if.end60
  %51 = load ptr, ptr %aligned_p, align 8
  store ptr %51, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end64, %if.then34, %if.then26, %if.then19, %if.then
  %52 = load ptr, ptr %retval, align 8
  ret ptr %52
}

; Function Attrs: nounwind uwtable
define internal ptr @_mi_ptr_page(ptr noundef %p) #0 {
entry:
  %p.addr = alloca ptr, align 8
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %call = call ptr @_mi_ptr_segment(ptr noundef %0)
  %1 = load ptr, ptr %p.addr, align 8
  %call1 = call ptr @_mi_segment_page_of(ptr noundef %call, ptr noundef %1)
  ret ptr %call1
}

; Function Attrs: nounwind uwtable
define internal i32 @mi_arena_id_create(i64 noundef %arena_index) #0 {
entry:
  %arena_index.addr = alloca i64, align 8
  store i64 %arena_index, ptr %arena_index.addr, align 8
  %0 = load i64, ptr %arena_index.addr, align 8
  %conv = trunc i64 %0 to i32
  %add = add i32 %conv, 1
  ret i32 %add
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_arena_try_alloc_at(ptr noundef %arena, i64 noundef %arena_index, i64 noundef %needed_bcount, i1 noundef zeroext %commit, ptr noundef %memid, ptr noundef %tld) #0 {
entry:
  %retval = alloca ptr, align 8
  %arena.addr = alloca ptr, align 8
  %arena_index.addr = alloca i64, align 8
  %needed_bcount.addr = alloca i64, align 8
  %commit.addr = alloca i8, align 1
  %memid.addr = alloca ptr, align 8
  %tld.addr = alloca ptr, align 8
  %bitmap_index = alloca i64, align 8
  %p = alloca ptr, align 8
  %tmp = alloca %struct.mi_memid_s, align 8
  %any_uncommitted = alloca i8, align 1
  %commit_zero = alloca i8, align 1
  store ptr %arena, ptr %arena.addr, align 8
  store i64 %arena_index, ptr %arena_index.addr, align 8
  store i64 %needed_bcount, ptr %needed_bcount.addr, align 8
  %frombool = zext i1 %commit to i8
  store i8 %frombool, ptr %commit.addr, align 1
  store ptr %memid, ptr %memid.addr, align 8
  store ptr %tld, ptr %tld.addr, align 8
  %0 = load ptr, ptr %arena.addr, align 8
  %1 = load i64, ptr %needed_bcount.addr, align 8
  %call = call zeroext i1 @mi_arena_try_claim(ptr noundef %0, i64 noundef %1, ptr noundef %bitmap_index)
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %arena.addr, align 8
  %3 = load i64, ptr %bitmap_index, align 8
  %call1 = call ptr @mi_arena_block_start(ptr noundef %2, i64 noundef %3)
  store ptr %call1, ptr %p, align 8
  %4 = load ptr, ptr %memid.addr, align 8
  %5 = load ptr, ptr %arena.addr, align 8
  %id = getelementptr inbounds %struct.mi_arena_s, ptr %5, i32 0, i32 0
  %6 = load i32, ptr %id, align 8
  %7 = load ptr, ptr %arena.addr, align 8
  %exclusive = getelementptr inbounds %struct.mi_arena_s, ptr %7, i32 0, i32 8
  %8 = load i8, ptr %exclusive, align 4
  %tobool = trunc i8 %8 to i1
  %9 = load i64, ptr %bitmap_index, align 8
  call void @mi_memid_create_arena(ptr sret(%struct.mi_memid_s) align 8 %tmp, i32 noundef %6, i1 noundef zeroext %tobool, i64 noundef %9)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %4, ptr align 8 %tmp, i64 24, i1 false)
  %10 = load ptr, ptr %arena.addr, align 8
  %memid2 = getelementptr inbounds %struct.mi_arena_s, ptr %10, i32 0, i32 1
  %is_pinned = getelementptr inbounds %struct.mi_memid_s, ptr %memid2, i32 0, i32 1
  %11 = load i8, ptr %is_pinned, align 8
  %tobool3 = trunc i8 %11 to i1
  %12 = load ptr, ptr %memid.addr, align 8
  %is_pinned4 = getelementptr inbounds %struct.mi_memid_s, ptr %12, i32 0, i32 1
  %frombool5 = zext i1 %tobool3 to i8
  store i8 %frombool5, ptr %is_pinned4, align 8
  %13 = load ptr, ptr %arena.addr, align 8
  %blocks_purge = getelementptr inbounds %struct.mi_arena_s, ptr %13, i32 0, i32 14
  %14 = load ptr, ptr %blocks_purge, align 8
  %cmp = icmp ne ptr %14, null
  br i1 %cmp, label %if.then6, label %if.end9

if.then6:                                         ; preds = %if.end
  %15 = load ptr, ptr %arena.addr, align 8
  %blocks_purge7 = getelementptr inbounds %struct.mi_arena_s, ptr %15, i32 0, i32 14
  %16 = load ptr, ptr %blocks_purge7, align 8
  %17 = load ptr, ptr %arena.addr, align 8
  %field_count = getelementptr inbounds %struct.mi_arena_s, ptr %17, i32 0, i32 4
  %18 = load i64, ptr %field_count, align 8
  %19 = load i64, ptr %needed_bcount.addr, align 8
  %20 = load i64, ptr %bitmap_index, align 8
  %call8 = call zeroext i1 @_mi_bitmap_unclaim_across(ptr noundef %16, i64 noundef %18, i64 noundef %19, i64 noundef %20)
  br label %if.end9

if.end9:                                          ; preds = %if.then6, %if.end
  %21 = load ptr, ptr %arena.addr, align 8
  %memid10 = getelementptr inbounds %struct.mi_arena_s, ptr %21, i32 0, i32 1
  %initially_zero = getelementptr inbounds %struct.mi_memid_s, ptr %memid10, i32 0, i32 3
  %22 = load i8, ptr %initially_zero, align 2
  %tobool11 = trunc i8 %22 to i1
  br i1 %tobool11, label %land.lhs.true, label %if.end19

land.lhs.true:                                    ; preds = %if.end9
  %23 = load ptr, ptr %arena.addr, align 8
  %blocks_dirty = getelementptr inbounds %struct.mi_arena_s, ptr %23, i32 0, i32 12
  %24 = load ptr, ptr %blocks_dirty, align 8
  %cmp12 = icmp ne ptr %24, null
  br i1 %cmp12, label %if.then13, label %if.end19

if.then13:                                        ; preds = %land.lhs.true
  %25 = load ptr, ptr %arena.addr, align 8
  %blocks_dirty14 = getelementptr inbounds %struct.mi_arena_s, ptr %25, i32 0, i32 12
  %26 = load ptr, ptr %blocks_dirty14, align 8
  %27 = load ptr, ptr %arena.addr, align 8
  %field_count15 = getelementptr inbounds %struct.mi_arena_s, ptr %27, i32 0, i32 4
  %28 = load i64, ptr %field_count15, align 8
  %29 = load i64, ptr %needed_bcount.addr, align 8
  %30 = load i64, ptr %bitmap_index, align 8
  %call16 = call zeroext i1 @_mi_bitmap_claim_across(ptr noundef %26, i64 noundef %28, i64 noundef %29, i64 noundef %30, ptr noundef null)
  %31 = load ptr, ptr %memid.addr, align 8
  %initially_zero17 = getelementptr inbounds %struct.mi_memid_s, ptr %31, i32 0, i32 3
  %frombool18 = zext i1 %call16 to i8
  store i8 %frombool18, ptr %initially_zero17, align 2
  br label %if.end19

if.end19:                                         ; preds = %if.then13, %land.lhs.true, %if.end9
  %32 = load ptr, ptr %arena.addr, align 8
  %blocks_committed = getelementptr inbounds %struct.mi_arena_s, ptr %32, i32 0, i32 13
  %33 = load ptr, ptr %blocks_committed, align 8
  %cmp20 = icmp eq ptr %33, null
  br i1 %cmp20, label %if.then21, label %if.else

if.then21:                                        ; preds = %if.end19
  %34 = load ptr, ptr %memid.addr, align 8
  %initially_committed = getelementptr inbounds %struct.mi_memid_s, ptr %34, i32 0, i32 2
  store i8 1, ptr %initially_committed, align 1
  br label %if.end48

if.else:                                          ; preds = %if.end19
  %35 = load i8, ptr %commit.addr, align 1
  %tobool22 = trunc i8 %35 to i1
  br i1 %tobool22, label %if.then23, label %if.else41

if.then23:                                        ; preds = %if.else
  %36 = load ptr, ptr %memid.addr, align 8
  %initially_committed24 = getelementptr inbounds %struct.mi_memid_s, ptr %36, i32 0, i32 2
  store i8 1, ptr %initially_committed24, align 1
  %37 = load ptr, ptr %arena.addr, align 8
  %blocks_committed25 = getelementptr inbounds %struct.mi_arena_s, ptr %37, i32 0, i32 13
  %38 = load ptr, ptr %blocks_committed25, align 8
  %39 = load ptr, ptr %arena.addr, align 8
  %field_count26 = getelementptr inbounds %struct.mi_arena_s, ptr %39, i32 0, i32 4
  %40 = load i64, ptr %field_count26, align 8
  %41 = load i64, ptr %needed_bcount.addr, align 8
  %42 = load i64, ptr %bitmap_index, align 8
  %call27 = call zeroext i1 @_mi_bitmap_claim_across(ptr noundef %38, i64 noundef %40, i64 noundef %41, i64 noundef %42, ptr noundef %any_uncommitted)
  %43 = load i8, ptr %any_uncommitted, align 1
  %tobool28 = trunc i8 %43 to i1
  br i1 %tobool28, label %if.then29, label %if.end40

if.then29:                                        ; preds = %if.then23
  store i8 0, ptr %commit_zero, align 1
  %44 = load ptr, ptr %p, align 8
  %45 = load i64, ptr %needed_bcount.addr, align 8
  %call30 = call i64 @mi_arena_block_size(i64 noundef %45)
  %46 = load ptr, ptr %tld.addr, align 8
  %stats = getelementptr inbounds %struct.mi_os_tld_s, ptr %46, i32 0, i32 1
  %47 = load ptr, ptr %stats, align 8
  %call31 = call zeroext i1 @_mi_os_commit(ptr noundef %44, i64 noundef %call30, ptr noundef %commit_zero, ptr noundef %47)
  br i1 %call31, label %if.else34, label %if.then32

if.then32:                                        ; preds = %if.then29
  %48 = load ptr, ptr %memid.addr, align 8
  %initially_committed33 = getelementptr inbounds %struct.mi_memid_s, ptr %48, i32 0, i32 2
  store i8 0, ptr %initially_committed33, align 1
  br label %if.end39

if.else34:                                        ; preds = %if.then29
  %49 = load i8, ptr %commit_zero, align 1
  %tobool35 = trunc i8 %49 to i1
  br i1 %tobool35, label %if.then36, label %if.end38

if.then36:                                        ; preds = %if.else34
  %50 = load ptr, ptr %memid.addr, align 8
  %initially_zero37 = getelementptr inbounds %struct.mi_memid_s, ptr %50, i32 0, i32 3
  store i8 1, ptr %initially_zero37, align 2
  br label %if.end38

if.end38:                                         ; preds = %if.then36, %if.else34
  br label %if.end39

if.end39:                                         ; preds = %if.end38, %if.then32
  br label %if.end40

if.end40:                                         ; preds = %if.end39, %if.then23
  br label %if.end47

if.else41:                                        ; preds = %if.else
  %51 = load ptr, ptr %arena.addr, align 8
  %blocks_committed42 = getelementptr inbounds %struct.mi_arena_s, ptr %51, i32 0, i32 13
  %52 = load ptr, ptr %blocks_committed42, align 8
  %53 = load ptr, ptr %arena.addr, align 8
  %field_count43 = getelementptr inbounds %struct.mi_arena_s, ptr %53, i32 0, i32 4
  %54 = load i64, ptr %field_count43, align 8
  %55 = load i64, ptr %needed_bcount.addr, align 8
  %56 = load i64, ptr %bitmap_index, align 8
  %call44 = call zeroext i1 @_mi_bitmap_is_claimed_across(ptr noundef %52, i64 noundef %54, i64 noundef %55, i64 noundef %56)
  %57 = load ptr, ptr %memid.addr, align 8
  %initially_committed45 = getelementptr inbounds %struct.mi_memid_s, ptr %57, i32 0, i32 2
  %frombool46 = zext i1 %call44 to i8
  store i8 %frombool46, ptr %initially_committed45, align 1
  br label %if.end47

if.end47:                                         ; preds = %if.else41, %if.end40
  br label %if.end48

if.end48:                                         ; preds = %if.end47, %if.then21
  %58 = load ptr, ptr %p, align 8
  store ptr %58, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end48, %if.then
  %59 = load ptr, ptr %retval, align 8
  ret ptr %59
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_arena_try_claim(ptr noundef %arena, i64 noundef %blocks, ptr noundef %bitmap_idx) #0 {
entry:
  %retval = alloca i1, align 1
  %arena.addr = alloca ptr, align 8
  %blocks.addr = alloca i64, align 8
  %bitmap_idx.addr = alloca ptr, align 8
  %idx = alloca i64, align 8
  %.atomictmp = alloca i64, align 8
  store ptr %arena, ptr %arena.addr, align 8
  store i64 %blocks, ptr %blocks.addr, align 8
  store ptr %bitmap_idx, ptr %bitmap_idx.addr, align 8
  store i64 0, ptr %idx, align 8
  %0 = load ptr, ptr %arena.addr, align 8
  %blocks_inuse = getelementptr inbounds %struct.mi_arena_s, ptr %0, i32 0, i32 15
  %arraydecay = getelementptr inbounds [1 x i64], ptr %blocks_inuse, i64 0, i64 0
  %1 = load ptr, ptr %arena.addr, align 8
  %field_count = getelementptr inbounds %struct.mi_arena_s, ptr %1, i32 0, i32 4
  %2 = load i64, ptr %field_count, align 8
  %3 = load i64, ptr %idx, align 8
  %4 = load i64, ptr %blocks.addr, align 8
  %5 = load ptr, ptr %bitmap_idx.addr, align 8
  %call = call zeroext i1 @_mi_bitmap_try_find_from_claim_across(ptr noundef %arraydecay, i64 noundef %2, i64 noundef %3, i64 noundef %4, ptr noundef %5)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load ptr, ptr %arena.addr, align 8
  %search_idx = getelementptr inbounds %struct.mi_arena_s, ptr %6, i32 0, i32 10
  %7 = load ptr, ptr %bitmap_idx.addr, align 8
  %8 = load i64, ptr %7, align 8
  %call1 = call i64 @mi_bitmap_index_field(i64 noundef %8)
  store i64 %call1, ptr %.atomictmp, align 8
  %9 = load i64, ptr %.atomictmp, align 8
  store atomic i64 %9, ptr %search_idx monotonic, align 8
  store i1 true, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %10 = load i1, ptr %retval, align 1
  ret i1 %10
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_arena_block_start(ptr noundef %arena, i64 noundef %bindex) #0 {
entry:
  %arena.addr = alloca ptr, align 8
  %bindex.addr = alloca i64, align 8
  store ptr %arena, ptr %arena.addr, align 8
  store i64 %bindex, ptr %bindex.addr, align 8
  %0 = load ptr, ptr %arena.addr, align 8
  %start = getelementptr inbounds %struct.mi_arena_s, ptr %0, i32 0, i32 2
  %atomic-load = load atomic i64, ptr %start seq_cst, align 8
  %1 = inttoptr i64 %atomic-load to ptr
  %2 = load i64, ptr %bindex.addr, align 8
  %call = call i64 @mi_bitmap_index_bit(i64 noundef %2)
  %call1 = call i64 @mi_arena_block_size(i64 noundef %call)
  %add.ptr = getelementptr i8, ptr %1, i64 %call1
  ret ptr %add.ptr
}

; Function Attrs: nounwind uwtable
define internal void @mi_memid_create_arena(ptr noalias sret(%struct.mi_memid_s) align 8 %agg.result, i32 noundef %id, i1 noundef zeroext %is_exclusive, i64 noundef %bitmap_index) #0 {
entry:
  %id.addr = alloca i32, align 4
  %is_exclusive.addr = alloca i8, align 1
  %bitmap_index.addr = alloca i64, align 8
  store i32 %id, ptr %id.addr, align 4
  %frombool = zext i1 %is_exclusive to i8
  store i8 %frombool, ptr %is_exclusive.addr, align 1
  store i64 %bitmap_index, ptr %bitmap_index.addr, align 8
  call void @_mi_memid_create(ptr sret(%struct.mi_memid_s) align 8 %agg.result, i32 noundef 6)
  %0 = load i32, ptr %id.addr, align 4
  %mem = getelementptr inbounds %struct.mi_memid_s, ptr %agg.result, i32 0, i32 0
  %id1 = getelementptr inbounds %struct.mi_memid_arena_info, ptr %mem, i32 0, i32 1
  store i32 %0, ptr %id1, align 8
  %1 = load i64, ptr %bitmap_index.addr, align 8
  %mem2 = getelementptr inbounds %struct.mi_memid_s, ptr %agg.result, i32 0, i32 0
  %block_index = getelementptr inbounds %struct.mi_memid_arena_info, ptr %mem2, i32 0, i32 0
  store i64 %1, ptr %block_index, align 8
  %2 = load i8, ptr %is_exclusive.addr, align 1
  %tobool = trunc i8 %2 to i1
  %mem3 = getelementptr inbounds %struct.mi_memid_s, ptr %agg.result, i32 0, i32 0
  %is_exclusive4 = getelementptr inbounds %struct.mi_memid_arena_info, ptr %mem3, i32 0, i32 2
  %frombool5 = zext i1 %tobool to i8
  store i8 %frombool5, ptr %is_exclusive4, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @mi_bitmap_index_bit(i64 noundef %bitmap_idx) #0 {
entry:
  %bitmap_idx.addr = alloca i64, align 8
  store i64 %bitmap_idx, ptr %bitmap_idx.addr, align 8
  %0 = load i64, ptr %bitmap_idx.addr, align 8
  ret i64 %0
}

; Function Attrs: nounwind uwtable
define internal i64 @mi_arena_purge_delay() #0 {
entry:
  %call = call i64 @mi_option_get(i32 noundef 15)
  %call1 = call i64 @mi_option_get(i32 noundef 24)
  %mul = mul i64 %call, %call1
  ret i64 %mul
}

; Function Attrs: nounwind uwtable
define internal void @mi_arena_purge(ptr noundef %arena, i64 noundef %bitmap_idx, i64 noundef %blocks, ptr noundef %stats) #0 {
entry:
  %arena.addr = alloca ptr, align 8
  %bitmap_idx.addr = alloca i64, align 8
  %blocks.addr = alloca i64, align 8
  %stats.addr = alloca ptr, align 8
  %size = alloca i64, align 8
  %p = alloca ptr, align 8
  %needs_recommit = alloca i8, align 1
  store ptr %arena, ptr %arena.addr, align 8
  store i64 %bitmap_idx, ptr %bitmap_idx.addr, align 8
  store i64 %blocks, ptr %blocks.addr, align 8
  store ptr %stats, ptr %stats.addr, align 8
  %0 = load i64, ptr %blocks.addr, align 8
  %call = call i64 @mi_arena_block_size(i64 noundef %0)
  store i64 %call, ptr %size, align 8
  %1 = load ptr, ptr %arena.addr, align 8
  %2 = load i64, ptr %bitmap_idx.addr, align 8
  %call1 = call ptr @mi_arena_block_start(ptr noundef %1, i64 noundef %2)
  store ptr %call1, ptr %p, align 8
  %3 = load ptr, ptr %arena.addr, align 8
  %blocks_committed = getelementptr inbounds %struct.mi_arena_s, ptr %3, i32 0, i32 13
  %4 = load ptr, ptr %blocks_committed, align 8
  %5 = load ptr, ptr %arena.addr, align 8
  %field_count = getelementptr inbounds %struct.mi_arena_s, ptr %5, i32 0, i32 4
  %6 = load i64, ptr %field_count, align 8
  %7 = load i64, ptr %blocks.addr, align 8
  %8 = load i64, ptr %bitmap_idx.addr, align 8
  %call2 = call zeroext i1 @_mi_bitmap_is_claimed_across(ptr noundef %4, i64 noundef %6, i64 noundef %7, i64 noundef %8)
  br i1 %call2, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %9 = load ptr, ptr %p, align 8
  %10 = load i64, ptr %size, align 8
  %11 = load ptr, ptr %stats.addr, align 8
  %call3 = call zeroext i1 @_mi_os_purge(ptr noundef %9, i64 noundef %10, ptr noundef %11)
  %frombool = zext i1 %call3 to i8
  store i8 %frombool, ptr %needs_recommit, align 1
  br label %if.end

if.else:                                          ; preds = %entry
  %12 = load ptr, ptr %p, align 8
  %13 = load i64, ptr %size, align 8
  %14 = load ptr, ptr %stats.addr, align 8
  %call4 = call zeroext i1 @_mi_os_purge_ex(ptr noundef %12, i64 noundef %13, i1 noundef zeroext false, ptr noundef %14)
  %frombool5 = zext i1 %call4 to i8
  store i8 %frombool5, ptr %needs_recommit, align 1
  %15 = load ptr, ptr %stats.addr, align 8
  %committed = getelementptr inbounds %struct.mi_stats_s, ptr %15, i32 0, i32 3
  %16 = load i64, ptr %size, align 8
  call void @_mi_stat_increase(ptr noundef %committed, i64 noundef %16)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %17 = load ptr, ptr %arena.addr, align 8
  %blocks_purge = getelementptr inbounds %struct.mi_arena_s, ptr %17, i32 0, i32 14
  %18 = load ptr, ptr %blocks_purge, align 8
  %19 = load ptr, ptr %arena.addr, align 8
  %field_count6 = getelementptr inbounds %struct.mi_arena_s, ptr %19, i32 0, i32 4
  %20 = load i64, ptr %field_count6, align 8
  %21 = load i64, ptr %blocks.addr, align 8
  %22 = load i64, ptr %bitmap_idx.addr, align 8
  %call7 = call zeroext i1 @_mi_bitmap_unclaim_across(ptr noundef %18, i64 noundef %20, i64 noundef %21, i64 noundef %22)
  %23 = load i8, ptr %needs_recommit, align 1
  %tobool = trunc i8 %23 to i1
  br i1 %tobool, label %if.then8, label %if.end12

if.then8:                                         ; preds = %if.end
  %24 = load ptr, ptr %arena.addr, align 8
  %blocks_committed9 = getelementptr inbounds %struct.mi_arena_s, ptr %24, i32 0, i32 13
  %25 = load ptr, ptr %blocks_committed9, align 8
  %26 = load ptr, ptr %arena.addr, align 8
  %field_count10 = getelementptr inbounds %struct.mi_arena_s, ptr %26, i32 0, i32 4
  %27 = load i64, ptr %field_count10, align 8
  %28 = load i64, ptr %blocks.addr, align 8
  %29 = load i64, ptr %bitmap_idx.addr, align 8
  %call11 = call zeroext i1 @_mi_bitmap_unclaim_across(ptr noundef %25, i64 noundef %27, i64 noundef %28, i64 noundef %29)
  br label %if.end12

if.end12:                                         ; preds = %if.then8, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_arena_try_purge(ptr noundef %arena, i64 noundef %now, i1 noundef zeroext %force, ptr noundef %stats) #0 {
entry:
  %retval = alloca i1, align 1
  %arena.addr = alloca ptr, align 8
  %now.addr = alloca i64, align 8
  %force.addr = alloca i8, align 1
  %stats.addr = alloca ptr, align 8
  %expire = alloca i64, align 8
  %atomic-temp = alloca i64, align 8
  %.atomictmp = alloca i64, align 8
  %cmpxchg.bool = alloca i8, align 1
  %any_purged = alloca i8, align 1
  %full_purge = alloca i8, align 1
  %i = alloca i64, align 8
  %purge = alloca i64, align 8
  %atomic-temp13 = alloca i64, align 8
  %bitidx = alloca i64, align 8
  %bitlen = alloca i64, align 8
  %bitmap_index = alloca i64, align 8
  %atomic-temp34 = alloca i64, align 8
  %delay = alloca i64, align 8
  %expected = alloca i64, align 8
  %.atomictmp52 = alloca i64, align 8
  %cmpxchg.bool55 = alloca i8, align 1
  store ptr %arena, ptr %arena.addr, align 8
  store i64 %now, ptr %now.addr, align 8
  %frombool = zext i1 %force to i8
  store i8 %frombool, ptr %force.addr, align 1
  store ptr %stats, ptr %stats.addr, align 8
  %0 = load ptr, ptr %arena.addr, align 8
  %memid = getelementptr inbounds %struct.mi_arena_s, ptr %0, i32 0, i32 1
  %is_pinned = getelementptr inbounds %struct.mi_memid_s, ptr %memid, i32 0, i32 1
  %1 = load i8, ptr %is_pinned, align 8
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load ptr, ptr %arena.addr, align 8
  %blocks_purge = getelementptr inbounds %struct.mi_arena_s, ptr %2, i32 0, i32 14
  %3 = load ptr, ptr %blocks_purge, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %4 = load ptr, ptr %arena.addr, align 8
  %purge_expire = getelementptr inbounds %struct.mi_arena_s, ptr %4, i32 0, i32 11
  %5 = load atomic i64, ptr %purge_expire monotonic, align 8
  store i64 %5, ptr %atomic-temp, align 8
  %6 = load i64, ptr %atomic-temp, align 8
  store i64 %6, ptr %expire, align 8
  %7 = load i64, ptr %expire, align 8
  %cmp1 = icmp eq i64 %7, 0
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i1 false, ptr %retval, align 1
  br label %return

if.end3:                                          ; preds = %if.end
  %8 = load i8, ptr %force.addr, align 1
  %tobool4 = trunc i8 %8 to i1
  br i1 %tobool4, label %if.end7, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end3
  %9 = load i64, ptr %expire, align 8
  %10 = load i64, ptr %now.addr, align 8
  %cmp5 = icmp sgt i64 %9, %10
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %land.lhs.true
  store i1 false, ptr %retval, align 1
  br label %return

if.end7:                                          ; preds = %land.lhs.true, %if.end3
  %11 = load ptr, ptr %arena.addr, align 8
  %purge_expire8 = getelementptr inbounds %struct.mi_arena_s, ptr %11, i32 0, i32 11
  store i64 0, ptr %.atomictmp, align 8
  %12 = load i64, ptr %expire, align 8
  %13 = load i64, ptr %.atomictmp, align 8
  %14 = cmpxchg ptr %purge_expire8, i64 %12, i64 %13 acq_rel acquire, align 8
  %15 = extractvalue { i64, i1 } %14, 0
  %16 = extractvalue { i64, i1 } %14, 1
  br i1 %16, label %cmpxchg.continue, label %cmpxchg.store_expected

cmpxchg.store_expected:                           ; preds = %if.end7
  store i64 %15, ptr %expire, align 8
  br label %cmpxchg.continue

cmpxchg.continue:                                 ; preds = %cmpxchg.store_expected, %if.end7
  %frombool9 = zext i1 %16 to i8
  store i8 %frombool9, ptr %cmpxchg.bool, align 1
  store i8 0, ptr %any_purged, align 1
  store i8 1, ptr %full_purge, align 1
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cmpxchg.continue
  %17 = load i64, ptr %i, align 8
  %18 = load ptr, ptr %arena.addr, align 8
  %field_count = getelementptr inbounds %struct.mi_arena_s, ptr %18, i32 0, i32 4
  %19 = load i64, ptr %field_count, align 8
  %cmp11 = icmp ult i64 %17, %19
  br i1 %cmp11, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %20 = load ptr, ptr %arena.addr, align 8
  %blocks_purge12 = getelementptr inbounds %struct.mi_arena_s, ptr %20, i32 0, i32 14
  %21 = load ptr, ptr %blocks_purge12, align 8
  %22 = load i64, ptr %i, align 8
  %arrayidx = getelementptr i64, ptr %21, i64 %22
  %23 = load atomic i64, ptr %arrayidx monotonic, align 8
  store i64 %23, ptr %atomic-temp13, align 8
  %24 = load i64, ptr %atomic-temp13, align 8
  store i64 %24, ptr %purge, align 8
  %25 = load i64, ptr %purge, align 8
  %cmp14 = icmp ne i64 %25, 0
  br i1 %cmp14, label %if.then15, label %if.end46

if.then15:                                        ; preds = %for.body
  store i64 0, ptr %bitidx, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end42, %if.then15
  %26 = load i64, ptr %bitidx, align 8
  %cmp16 = icmp ult i64 %26, 64
  br i1 %cmp16, label %while.body, label %while.end45

while.body:                                       ; preds = %while.cond
  store i64 0, ptr %bitlen, align 8
  br label %while.cond17

while.cond17:                                     ; preds = %while.body21, %while.body
  %27 = load i64, ptr %bitidx, align 8
  %28 = load i64, ptr %bitlen, align 8
  %add = add i64 %27, %28
  %cmp18 = icmp ult i64 %add, 64
  br i1 %cmp18, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond17
  %29 = load i64, ptr %purge, align 8
  %30 = load i64, ptr %bitidx, align 8
  %31 = load i64, ptr %bitlen, align 8
  %add19 = add i64 %30, %31
  %shl = shl i64 1, %add19
  %and = and i64 %29, %shl
  %cmp20 = icmp ne i64 %and, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond17
  %32 = phi i1 [ false, %while.cond17 ], [ %cmp20, %land.rhs ]
  br i1 %32, label %while.body21, label %while.end

while.body21:                                     ; preds = %land.end
  %33 = load i64, ptr %bitlen, align 8
  %inc = add i64 %33, 1
  store i64 %inc, ptr %bitlen, align 8
  br label %while.cond17, !llvm.loop !109

while.end:                                        ; preds = %land.end
  %34 = load i64, ptr %i, align 8
  %35 = load i64, ptr %bitidx, align 8
  %call = call i64 @mi_bitmap_index_create(i64 noundef %34, i64 noundef %35)
  store i64 %call, ptr %bitmap_index, align 8
  br label %while.cond22

while.cond22:                                     ; preds = %if.end28, %while.end
  %36 = load i64, ptr %bitlen, align 8
  %cmp23 = icmp ugt i64 %36, 0
  br i1 %cmp23, label %while.body24, label %while.end29

while.body24:                                     ; preds = %while.cond22
  %37 = load ptr, ptr %arena.addr, align 8
  %blocks_inuse = getelementptr inbounds %struct.mi_arena_s, ptr %37, i32 0, i32 15
  %arraydecay = getelementptr inbounds [1 x i64], ptr %blocks_inuse, i64 0, i64 0
  %38 = load ptr, ptr %arena.addr, align 8
  %field_count25 = getelementptr inbounds %struct.mi_arena_s, ptr %38, i32 0, i32 4
  %39 = load i64, ptr %field_count25, align 8
  %40 = load i64, ptr %bitlen, align 8
  %41 = load i64, ptr %bitmap_index, align 8
  %call26 = call zeroext i1 @_mi_bitmap_try_claim(ptr noundef %arraydecay, i64 noundef %39, i64 noundef %40, i64 noundef %41)
  br i1 %call26, label %if.then27, label %if.end28

if.then27:                                        ; preds = %while.body24
  br label %while.end29

if.end28:                                         ; preds = %while.body24
  %42 = load i64, ptr %bitlen, align 8
  %dec = add i64 %42, -1
  store i64 %dec, ptr %bitlen, align 8
  br label %while.cond22, !llvm.loop !110

while.end29:                                      ; preds = %if.then27, %while.cond22
  %43 = load i64, ptr %bitlen, align 8
  %cmp30 = icmp ugt i64 %43, 0
  br i1 %cmp30, label %if.then31, label %if.end42

if.then31:                                        ; preds = %while.end29
  %44 = load ptr, ptr %arena.addr, align 8
  %blocks_purge32 = getelementptr inbounds %struct.mi_arena_s, ptr %44, i32 0, i32 14
  %45 = load ptr, ptr %blocks_purge32, align 8
  %46 = load i64, ptr %i, align 8
  %arrayidx33 = getelementptr i64, ptr %45, i64 %46
  %47 = load atomic i64, ptr %arrayidx33 acquire, align 8
  store i64 %47, ptr %atomic-temp34, align 8
  %48 = load i64, ptr %atomic-temp34, align 8
  store i64 %48, ptr %purge, align 8
  %49 = load ptr, ptr %arena.addr, align 8
  %50 = load i64, ptr %i, align 8
  %51 = load i64, ptr %bitidx, align 8
  %52 = load i64, ptr %bitlen, align 8
  %53 = load i64, ptr %purge, align 8
  %54 = load ptr, ptr %stats.addr, align 8
  %call35 = call zeroext i1 @mi_arena_purge_range(ptr noundef %49, i64 noundef %50, i64 noundef %51, i64 noundef %52, i64 noundef %53, ptr noundef %54)
  br i1 %call35, label %if.end37, label %if.then36

if.then36:                                        ; preds = %if.then31
  store i8 0, ptr %full_purge, align 1
  br label %if.end37

if.end37:                                         ; preds = %if.then36, %if.then31
  store i8 1, ptr %any_purged, align 1
  %55 = load ptr, ptr %arena.addr, align 8
  %blocks_inuse38 = getelementptr inbounds %struct.mi_arena_s, ptr %55, i32 0, i32 15
  %arraydecay39 = getelementptr inbounds [1 x i64], ptr %blocks_inuse38, i64 0, i64 0
  %56 = load ptr, ptr %arena.addr, align 8
  %field_count40 = getelementptr inbounds %struct.mi_arena_s, ptr %56, i32 0, i32 4
  %57 = load i64, ptr %field_count40, align 8
  %58 = load i64, ptr %bitlen, align 8
  %59 = load i64, ptr %bitmap_index, align 8
  %call41 = call zeroext i1 @_mi_bitmap_unclaim(ptr noundef %arraydecay39, i64 noundef %57, i64 noundef %58, i64 noundef %59)
  br label %if.end42

if.end42:                                         ; preds = %if.end37, %while.end29
  %60 = load i64, ptr %bitlen, align 8
  %add43 = add i64 %60, 1
  %61 = load i64, ptr %bitidx, align 8
  %add44 = add i64 %61, %add43
  store i64 %add44, ptr %bitidx, align 8
  br label %while.cond, !llvm.loop !111

while.end45:                                      ; preds = %while.cond
  br label %if.end46

if.end46:                                         ; preds = %while.end45, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end46
  %62 = load i64, ptr %i, align 8
  %inc47 = add i64 %62, 1
  store i64 %inc47, ptr %i, align 8
  br label %for.cond, !llvm.loop !112

for.end:                                          ; preds = %for.cond
  %63 = load i8, ptr %full_purge, align 1
  %tobool48 = trunc i8 %63 to i1
  br i1 %tobool48, label %if.end60, label %if.then49

if.then49:                                        ; preds = %for.end
  %call50 = call i64 @mi_arena_purge_delay()
  store i64 %call50, ptr %delay, align 8
  store i64 0, ptr %expected, align 8
  %64 = load ptr, ptr %arena.addr, align 8
  %purge_expire51 = getelementptr inbounds %struct.mi_arena_s, ptr %64, i32 0, i32 11
  %call53 = call i64 @_mi_clock_now()
  %65 = load i64, ptr %delay, align 8
  %add54 = add i64 %call53, %65
  store i64 %add54, ptr %.atomictmp52, align 8
  %66 = load i64, ptr %expected, align 8
  %67 = load i64, ptr %.atomictmp52, align 8
  %68 = cmpxchg ptr %purge_expire51, i64 %66, i64 %67 acq_rel acquire, align 8
  %69 = extractvalue { i64, i1 } %68, 0
  %70 = extractvalue { i64, i1 } %68, 1
  br i1 %70, label %cmpxchg.continue57, label %cmpxchg.store_expected56

cmpxchg.store_expected56:                         ; preds = %if.then49
  store i64 %69, ptr %expected, align 8
  br label %cmpxchg.continue57

cmpxchg.continue57:                               ; preds = %cmpxchg.store_expected56, %if.then49
  %frombool58 = zext i1 %70 to i8
  store i8 %frombool58, ptr %cmpxchg.bool55, align 1
  br label %if.end60

if.end60:                                         ; preds = %cmpxchg.continue57, %for.end
  %71 = load i8, ptr %any_purged, align 1
  %tobool61 = trunc i8 %71 to i1
  store i1 %tobool61, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end60, %if.then6, %if.then2, %if.then
  %72 = load i1, ptr %retval, align 1
  ret i1 %72
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_arena_purge_range(ptr noundef %arena, i64 noundef %idx, i64 noundef %startidx, i64 noundef %bitlen, i64 noundef %purge, ptr noundef %stats) #0 {
entry:
  %arena.addr = alloca ptr, align 8
  %idx.addr = alloca i64, align 8
  %startidx.addr = alloca i64, align 8
  %bitlen.addr = alloca i64, align 8
  %purge.addr = alloca i64, align 8
  %stats.addr = alloca ptr, align 8
  %endidx = alloca i64, align 8
  %bitidx = alloca i64, align 8
  %all_purged = alloca i8, align 1
  %count = alloca i64, align 8
  %range_idx = alloca i64, align 8
  store ptr %arena, ptr %arena.addr, align 8
  store i64 %idx, ptr %idx.addr, align 8
  store i64 %startidx, ptr %startidx.addr, align 8
  store i64 %bitlen, ptr %bitlen.addr, align 8
  store i64 %purge, ptr %purge.addr, align 8
  store ptr %stats, ptr %stats.addr, align 8
  %0 = load i64, ptr %startidx.addr, align 8
  %1 = load i64, ptr %bitlen.addr, align 8
  %add = add i64 %0, %1
  store i64 %add, ptr %endidx, align 8
  %2 = load i64, ptr %startidx.addr, align 8
  store i64 %2, ptr %bitidx, align 8
  store i8 0, ptr %all_purged, align 1
  br label %while.cond

while.cond:                                       ; preds = %if.end10, %entry
  %3 = load i64, ptr %bitidx, align 8
  %4 = load i64, ptr %endidx, align 8
  %cmp = icmp ult i64 %3, %4
  br i1 %cmp, label %while.body, label %while.end13

while.body:                                       ; preds = %while.cond
  store i64 0, ptr %count, align 8
  br label %while.cond1

while.cond1:                                      ; preds = %while.body6, %while.body
  %5 = load i64, ptr %bitidx, align 8
  %6 = load i64, ptr %count, align 8
  %add2 = add i64 %5, %6
  %7 = load i64, ptr %endidx, align 8
  %cmp3 = icmp ult i64 %add2, %7
  br i1 %cmp3, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond1
  %8 = load i64, ptr %purge.addr, align 8
  %9 = load i64, ptr %bitidx, align 8
  %10 = load i64, ptr %count, align 8
  %add4 = add i64 %9, %10
  %shl = shl i64 1, %add4
  %and = and i64 %8, %shl
  %cmp5 = icmp ne i64 %and, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond1
  %11 = phi i1 [ false, %while.cond1 ], [ %cmp5, %land.rhs ]
  br i1 %11, label %while.body6, label %while.end

while.body6:                                      ; preds = %land.end
  %12 = load i64, ptr %count, align 8
  %inc = add i64 %12, 1
  store i64 %inc, ptr %count, align 8
  br label %while.cond1, !llvm.loop !113

while.end:                                        ; preds = %land.end
  %13 = load i64, ptr %count, align 8
  %cmp7 = icmp ugt i64 %13, 0
  br i1 %cmp7, label %if.then, label %if.end10

if.then:                                          ; preds = %while.end
  %14 = load i64, ptr %idx.addr, align 8
  %15 = load i64, ptr %bitidx, align 8
  %call = call i64 @mi_bitmap_index_create(i64 noundef %14, i64 noundef %15)
  store i64 %call, ptr %range_idx, align 8
  %16 = load ptr, ptr %arena.addr, align 8
  %17 = load i64, ptr %range_idx, align 8
  %18 = load i64, ptr %count, align 8
  %19 = load ptr, ptr %stats.addr, align 8
  call void @mi_arena_purge(ptr noundef %16, i64 noundef %17, i64 noundef %18, ptr noundef %19)
  %20 = load i64, ptr %count, align 8
  %21 = load i64, ptr %bitlen.addr, align 8
  %cmp8 = icmp eq i64 %20, %21
  br i1 %cmp8, label %if.then9, label %if.end

if.then9:                                         ; preds = %if.then
  store i8 1, ptr %all_purged, align 1
  br label %if.end

if.end:                                           ; preds = %if.then9, %if.then
  br label %if.end10

if.end10:                                         ; preds = %if.end, %while.end
  %22 = load i64, ptr %count, align 8
  %add11 = add i64 %22, 1
  %23 = load i64, ptr %bitidx, align 8
  %add12 = add i64 %23, %add11
  store i64 %add12, ptr %bitidx, align 8
  br label %while.cond, !llvm.loop !114

while.end13:                                      ; preds = %while.cond
  %24 = load i8, ptr %all_purged, align 1
  %tobool = trunc i8 %24 to i1
  ret i1 %tobool
}

; Function Attrs: nounwind uwtable
define internal i64 @mi_arena_size(ptr noundef %arena) #0 {
entry:
  %arena.addr = alloca ptr, align 8
  store ptr %arena, ptr %arena.addr, align 8
  %0 = load ptr, ptr %arena.addr, align 8
  %block_count = getelementptr inbounds %struct.mi_arena_s, ptr %0, i32 0, i32 3
  %1 = load i64, ptr %block_count, align 8
  %call = call i64 @mi_arena_block_size(i64 noundef %1)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define internal void @mi_arena_meta_free(ptr noundef %p, ptr noundef byval(%struct.mi_memid_s) align 8 %memid, i64 noundef %size, ptr noundef %stats) #0 {
entry:
  %p.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %stats.addr = alloca ptr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store ptr %stats, ptr %stats.addr, align 8
  %memkind = getelementptr inbounds %struct.mi_memid_s, ptr %memid, i32 0, i32 4
  %0 = load i32, ptr %memkind, align 4
  %call = call zeroext i1 @mi_memkind_is_os(i32 noundef %0)
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %p.addr, align 8
  %2 = load i64, ptr %size.addr, align 8
  %3 = load ptr, ptr %stats.addr, align 8
  call void @_mi_os_free(ptr noundef %1, i64 noundef %2, ptr noundef byval(%struct.mi_memid_s) align 8 %memid, ptr noundef %3)
  br label %if.end

if.else:                                          ; preds = %entry
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_arena_meta_zalloc(i64 noundef %size, ptr noundef %memid, ptr noundef %stats) #0 {
entry:
  %retval = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %memid.addr = alloca ptr, align 8
  %stats.addr = alloca ptr, align 8
  %tmp = alloca %struct.mi_memid_s, align 8
  %p = alloca ptr, align 8
  store i64 %size, ptr %size.addr, align 8
  store ptr %memid, ptr %memid.addr, align 8
  store ptr %stats, ptr %stats.addr, align 8
  %0 = load ptr, ptr %memid.addr, align 8
  call void @_mi_memid_none(ptr sret(%struct.mi_memid_s) align 8 %tmp)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %0, ptr align 8 %tmp, i64 24, i1 false)
  %1 = load i64, ptr %size.addr, align 8
  %2 = load ptr, ptr %memid.addr, align 8
  %call = call ptr @mi_arena_static_zalloc(i64 noundef %1, i64 noundef 16777216, ptr noundef %2)
  store ptr %call, ptr %p, align 8
  %3 = load ptr, ptr %p, align 8
  %cmp = icmp ne ptr %3, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr %p, align 8
  store ptr %4, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i64, ptr %size.addr, align 8
  %6 = load ptr, ptr %memid.addr, align 8
  %7 = load ptr, ptr %stats.addr, align 8
  %call1 = call ptr @_mi_os_alloc(i64 noundef %5, ptr noundef %6, ptr noundef %7)
  store ptr %call1, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %8 = load ptr, ptr %retval, align 8
  ret ptr %8
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_arena_add(ptr noundef %arena, ptr noundef %arena_id) #0 {
entry:
  %retval = alloca i1, align 1
  %arena.addr = alloca ptr, align 8
  %arena_id.addr = alloca ptr, align 8
  %i = alloca i64, align 8
  %.atomictmp = alloca i64, align 8
  %atomic-temp = alloca i64, align 8
  %.atomictmp3 = alloca i64, align 8
  %atomic-temp4 = alloca i64, align 8
  %.atomictmp6 = alloca ptr, align 8
  store ptr %arena, ptr %arena.addr, align 8
  store ptr %arena_id, ptr %arena_id.addr, align 8
  %0 = load ptr, ptr %arena_id.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %arena_id.addr, align 8
  store i32 -1, ptr %1, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  store i64 1, ptr %.atomictmp, align 8
  %2 = load i64, ptr %.atomictmp, align 8
  %3 = atomicrmw add ptr @mi_arena_count, i64 %2 acq_rel, align 64
  store i64 %3, ptr %atomic-temp, align 8
  %4 = load i64, ptr %atomic-temp, align 8
  store i64 %4, ptr %i, align 8
  %5 = load i64, ptr %i, align 8
  %cmp1 = icmp uge i64 %5, 112
  br i1 %cmp1, label %if.then2, label %if.end5

if.then2:                                         ; preds = %if.end
  store i64 1, ptr %.atomictmp3, align 8
  %6 = load i64, ptr %.atomictmp3, align 8
  %7 = atomicrmw sub ptr @mi_arena_count, i64 %6 acq_rel, align 64
  store i64 %7, ptr %atomic-temp4, align 8
  store i1 false, ptr %retval, align 1
  br label %return

if.end5:                                          ; preds = %if.end
  %8 = load i64, ptr %i, align 8
  %call = call i32 @mi_arena_id_create(i64 noundef %8)
  %9 = load ptr, ptr %arena.addr, align 8
  %id = getelementptr inbounds %struct.mi_arena_s, ptr %9, i32 0, i32 0
  store i32 %call, ptr %id, align 8
  %10 = load i64, ptr %i, align 8
  %arrayidx = getelementptr [112 x ptr], ptr @mi_arenas, i64 0, i64 %10
  %11 = load ptr, ptr %arena.addr, align 8
  store ptr %11, ptr %.atomictmp6, align 8
  %12 = load i64, ptr %.atomictmp6, align 8
  store atomic i64 %12, ptr %arrayidx release, align 8
  %13 = load ptr, ptr %arena_id.addr, align 8
  %cmp7 = icmp ne ptr %13, null
  br i1 %cmp7, label %if.then8, label %if.end10

if.then8:                                         ; preds = %if.end5
  %14 = load ptr, ptr %arena.addr, align 8
  %id9 = getelementptr inbounds %struct.mi_arena_s, ptr %14, i32 0, i32 0
  %15 = load i32, ptr %id9, align 8
  %16 = load ptr, ptr %arena_id.addr, align 8
  store i32 %15, ptr %16, align 4
  br label %if.end10

if.end10:                                         ; preds = %if.then8, %if.end5
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end10, %if.then2
  %17 = load i1, ptr %retval, align 1
  ret i1 %17
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_arena_static_zalloc(i64 noundef %size, i64 noundef %alignment, ptr noundef %memid) #0 {
entry:
  %retval = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  %memid.addr = alloca ptr, align 8
  %tmp = alloca %struct.mi_memid_s, align 8
  %atomic-temp = alloca i64, align 8
  %oversize = alloca i64, align 8
  %oldtop = alloca i64, align 8
  %.atomictmp = alloca i64, align 8
  %atomic-temp12 = alloca i64, align 8
  %top = alloca i64, align 8
  %.atomictmp16 = alloca i64, align 8
  %cmpxchg.bool = alloca i8, align 1
  %tmp18 = alloca %struct.mi_memid_s, align 8
  %start = alloca i64, align 8
  %p = alloca ptr, align 8
  store i64 %size, ptr %size.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  store ptr %memid, ptr %memid.addr, align 8
  %0 = load ptr, ptr %memid.addr, align 8
  call void @_mi_memid_none(ptr sret(%struct.mi_memid_s) align 8 %tmp)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %0, ptr align 8 %tmp, i64 24, i1 false)
  %1 = load i64, ptr %size.addr, align 8
  %cmp = icmp eq i64 %1, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load i64, ptr %size.addr, align 8
  %cmp1 = icmp ugt i64 %2, 8192
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %3 = load atomic i64, ptr @mi_arena_static_top monotonic, align 8
  store i64 %3, ptr %atomic-temp, align 8
  %4 = load i64, ptr %atomic-temp, align 8
  %5 = load i64, ptr %size.addr, align 8
  %add = add i64 %4, %5
  %cmp2 = icmp ugt i64 %add, 8192
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  %6 = load i64, ptr %alignment.addr, align 8
  %cmp5 = icmp eq i64 %6, 0
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end4
  store i64 1, ptr %alignment.addr, align 8
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %if.end4
  %7 = load i64, ptr %size.addr, align 8
  %8 = load i64, ptr %alignment.addr, align 8
  %add8 = add i64 %7, %8
  %sub = sub i64 %add8, 1
  store i64 %sub, ptr %oversize, align 8
  %9 = load i64, ptr %oversize, align 8
  %cmp9 = icmp ugt i64 %9, 8192
  br i1 %cmp9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end7
  store ptr null, ptr %retval, align 8
  br label %return

if.end11:                                         ; preds = %if.end7
  %10 = load i64, ptr %oversize, align 8
  store i64 %10, ptr %.atomictmp, align 8
  %11 = load i64, ptr %.atomictmp, align 8
  %12 = atomicrmw add ptr @mi_arena_static_top, i64 %11 acq_rel, align 8
  store i64 %12, ptr %atomic-temp12, align 8
  %13 = load i64, ptr %atomic-temp12, align 8
  store i64 %13, ptr %oldtop, align 8
  %14 = load i64, ptr %oldtop, align 8
  %15 = load i64, ptr %oversize, align 8
  %add13 = add i64 %14, %15
  store i64 %add13, ptr %top, align 8
  %16 = load i64, ptr %top, align 8
  %cmp14 = icmp ugt i64 %16, 8192
  br i1 %cmp14, label %if.then15, label %if.end17

if.then15:                                        ; preds = %if.end11
  %17 = load i64, ptr %oldtop, align 8
  store i64 %17, ptr %.atomictmp16, align 8
  %18 = load i64, ptr %top, align 8
  %19 = load i64, ptr %.atomictmp16, align 8
  %20 = cmpxchg ptr @mi_arena_static_top, i64 %18, i64 %19 acq_rel acquire, align 8
  %21 = extractvalue { i64, i1 } %20, 0
  %22 = extractvalue { i64, i1 } %20, 1
  br i1 %22, label %cmpxchg.continue, label %cmpxchg.store_expected

cmpxchg.store_expected:                           ; preds = %if.then15
  store i64 %21, ptr %top, align 8
  br label %cmpxchg.continue

cmpxchg.continue:                                 ; preds = %cmpxchg.store_expected, %if.then15
  %frombool = zext i1 %22 to i8
  store i8 %frombool, ptr %cmpxchg.bool, align 1
  store ptr null, ptr %retval, align 8
  br label %return

if.end17:                                         ; preds = %if.end11
  %23 = load ptr, ptr %memid.addr, align 8
  call void @_mi_memid_create(ptr sret(%struct.mi_memid_s) align 8 %tmp18, i32 noundef 2)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %23, ptr align 8 %tmp18, i64 24, i1 false)
  %24 = load i64, ptr %oldtop, align 8
  %25 = load i64, ptr %alignment.addr, align 8
  %call = call i64 @_mi_align_up(i64 noundef %24, i64 noundef %25)
  store i64 %call, ptr %start, align 8
  %26 = load i64, ptr %start, align 8
  %arrayidx = getelementptr [8192 x i8], ptr @mi_arena_static, i64 0, i64 %26
  store ptr %arrayidx, ptr %p, align 8
  %27 = load ptr, ptr %p, align 8
  %28 = load i64, ptr %size.addr, align 8
  call void @_mi_memzero(ptr noundef %27, i64 noundef %28)
  %29 = load ptr, ptr %p, align 8
  store ptr %29, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end17, %cmpxchg.continue, %if.then10, %if.then3, %if.then
  %30 = load ptr, ptr %retval, align 8
  ret ptr %30
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.cttz.i64(i64, i1 immarg) #5

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.ctlz.i64(i64, i1 immarg) #5

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_heap_page_never_delayed_free(ptr noundef %heap, ptr noundef %pq, ptr noundef %page, ptr noundef %arg1, ptr noundef %arg2) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %pq.addr = alloca ptr, align 8
  %page.addr = alloca ptr, align 8
  %arg1.addr = alloca ptr, align 8
  %arg2.addr = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store ptr %pq, ptr %pq.addr, align 8
  store ptr %page, ptr %page.addr, align 8
  store ptr %arg1, ptr %arg1.addr, align 8
  store ptr %arg2, ptr %arg2.addr, align 8
  %0 = load ptr, ptr %page.addr, align 8
  call void @_mi_page_use_delayed_free(ptr noundef %0, i32 noundef 3, i1 noundef zeroext false)
  ret i1 true
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_heap_page_collect(ptr noundef %heap, ptr noundef %pq, ptr noundef %page, ptr noundef %arg_collect, ptr noundef %arg2) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %pq.addr = alloca ptr, align 8
  %page.addr = alloca ptr, align 8
  %arg_collect.addr = alloca ptr, align 8
  %arg2.addr = alloca ptr, align 8
  %collect = alloca i32, align 4
  store ptr %heap, ptr %heap.addr, align 8
  store ptr %pq, ptr %pq.addr, align 8
  store ptr %page, ptr %page.addr, align 8
  store ptr %arg_collect, ptr %arg_collect.addr, align 8
  store ptr %arg2, ptr %arg2.addr, align 8
  %0 = load ptr, ptr %arg_collect.addr, align 8
  %1 = load i32, ptr %0, align 4
  store i32 %1, ptr %collect, align 4
  %2 = load ptr, ptr %page.addr, align 8
  %3 = load i32, ptr %collect, align 4
  %cmp = icmp uge i32 %3, 1
  call void @_mi_page_free_collect(ptr noundef %2, i1 noundef zeroext %cmp)
  %4 = load ptr, ptr %page.addr, align 8
  %call = call zeroext i1 @mi_page_all_free(ptr noundef %4)
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %5 = load ptr, ptr %page.addr, align 8
  %6 = load ptr, ptr %pq.addr, align 8
  %7 = load i32, ptr %collect, align 4
  %cmp1 = icmp uge i32 %7, 1
  call void @_mi_page_free(ptr noundef %5, ptr noundef %6, i1 noundef zeroext %cmp1)
  br label %if.end4

if.else:                                          ; preds = %entry
  %8 = load i32, ptr %collect, align 4
  %cmp2 = icmp eq i32 %8, 2
  br i1 %cmp2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.else
  %9 = load ptr, ptr %page.addr, align 8
  %10 = load ptr, ptr %pq.addr, align 8
  call void @_mi_page_abandon(ptr noundef %9, ptr noundef %10)
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.else
  br label %if.end4

if.end4:                                          ; preds = %if.end, %if.then
  ret i1 true
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_heap_is_default(ptr noundef %heap) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  %0 = load ptr, ptr %heap.addr, align 8
  %call = call ptr @mi_prim_get_default_heap()
  %cmp = icmp eq ptr %0, %call
  ret i1 %cmp
}

; Function Attrs: nounwind uwtable
define internal i64 @_mi_ptr_cookie(ptr noundef %p) #0 {
entry:
  %p.addr = alloca ptr, align 8
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %1 = ptrtoint ptr %0 to i64
  %2 = load i64, ptr getelementptr inbounds (%struct.mi_heap_s, ptr @_mi_heap_main, i32 0, i32 6), align 8
  %xor = xor i64 %1, %2
  ret i64 %xor
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_heap_visit_areas_page(ptr noundef %heap, ptr noundef %pq, ptr noundef %page, ptr noundef %vfun, ptr noundef %arg) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %pq.addr = alloca ptr, align 8
  %page.addr = alloca ptr, align 8
  %vfun.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %fun = alloca ptr, align 8
  %xarea = alloca %struct.mi_heap_area_ex_s, align 8
  %bsize = alloca i64, align 8
  %ubsize = alloca i64, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store ptr %pq, ptr %pq.addr, align 8
  store ptr %page, ptr %page.addr, align 8
  store ptr %vfun, ptr %vfun.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %vfun.addr, align 8
  store ptr %0, ptr %fun, align 8
  %1 = load ptr, ptr %page.addr, align 8
  %call = call i64 @mi_page_block_size(ptr noundef %1)
  store i64 %call, ptr %bsize, align 8
  %2 = load ptr, ptr %page.addr, align 8
  %call1 = call i64 @mi_page_usable_block_size(ptr noundef %2)
  store i64 %call1, ptr %ubsize, align 8
  %3 = load ptr, ptr %page.addr, align 8
  %page2 = getelementptr inbounds %struct.mi_heap_area_ex_s, ptr %xarea, i32 0, i32 1
  store ptr %3, ptr %page2, align 8
  %4 = load ptr, ptr %page.addr, align 8
  %reserved = getelementptr inbounds %struct.mi_page_s, ptr %4, i32 0, i32 4
  %5 = load i16, ptr %reserved, align 4
  %conv = zext i16 %5 to i64
  %6 = load i64, ptr %bsize, align 8
  %mul = mul i64 %conv, %6
  %area = getelementptr inbounds %struct.mi_heap_area_ex_s, ptr %xarea, i32 0, i32 0
  %reserved3 = getelementptr inbounds %struct.mi_heap_area_s, ptr %area, i32 0, i32 1
  store i64 %mul, ptr %reserved3, align 8
  %7 = load ptr, ptr %page.addr, align 8
  %capacity = getelementptr inbounds %struct.mi_page_s, ptr %7, i32 0, i32 3
  %8 = load i16, ptr %capacity, align 2
  %conv4 = zext i16 %8 to i64
  %9 = load i64, ptr %bsize, align 8
  %mul5 = mul i64 %conv4, %9
  %area6 = getelementptr inbounds %struct.mi_heap_area_ex_s, ptr %xarea, i32 0, i32 0
  %committed = getelementptr inbounds %struct.mi_heap_area_s, ptr %area6, i32 0, i32 2
  store i64 %mul5, ptr %committed, align 8
  %10 = load ptr, ptr %page.addr, align 8
  %call7 = call ptr @_mi_page_segment(ptr noundef %10)
  %11 = load ptr, ptr %page.addr, align 8
  %call8 = call ptr @_mi_page_start(ptr noundef %call7, ptr noundef %11, ptr noundef null)
  %area9 = getelementptr inbounds %struct.mi_heap_area_ex_s, ptr %xarea, i32 0, i32 0
  %blocks = getelementptr inbounds %struct.mi_heap_area_s, ptr %area9, i32 0, i32 0
  store ptr %call8, ptr %blocks, align 8
  %12 = load ptr, ptr %page.addr, align 8
  %used = getelementptr inbounds %struct.mi_page_s, ptr %12, i32 0, i32 8
  %13 = load i32, ptr %used, align 8
  %conv10 = zext i32 %13 to i64
  %area11 = getelementptr inbounds %struct.mi_heap_area_ex_s, ptr %xarea, i32 0, i32 0
  %used12 = getelementptr inbounds %struct.mi_heap_area_s, ptr %area11, i32 0, i32 3
  store i64 %conv10, ptr %used12, align 8
  %14 = load i64, ptr %ubsize, align 8
  %area13 = getelementptr inbounds %struct.mi_heap_area_ex_s, ptr %xarea, i32 0, i32 0
  %block_size = getelementptr inbounds %struct.mi_heap_area_s, ptr %area13, i32 0, i32 4
  store i64 %14, ptr %block_size, align 8
  %15 = load i64, ptr %bsize, align 8
  %area14 = getelementptr inbounds %struct.mi_heap_area_ex_s, ptr %xarea, i32 0, i32 0
  %full_block_size = getelementptr inbounds %struct.mi_heap_area_s, ptr %area14, i32 0, i32 5
  store i64 %15, ptr %full_block_size, align 8
  %16 = load ptr, ptr %fun, align 8
  %17 = load ptr, ptr %heap.addr, align 8
  %18 = load ptr, ptr %arg.addr, align 8
  %call15 = call zeroext i1 %16(ptr noundef %17, ptr noundef %xarea, ptr noundef %18)
  ret i1 %call15
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_heap_area_visit_blocks(ptr noundef %xarea, ptr noundef %visitor, ptr noundef %arg) #0 {
entry:
  %retval = alloca i1, align 1
  %xarea.addr = alloca ptr, align 8
  %visitor.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %area = alloca ptr, align 8
  %page = alloca ptr, align 8
  %bsize = alloca i64, align 8
  %ubsize = alloca i64, align 8
  %psize = alloca i64, align 8
  %pstart = alloca ptr, align 8
  %free_map = alloca [1024 x i64], align 16
  %block = alloca ptr, align 8
  %offset = alloca i64, align 8
  %blockidx = alloca i64, align 8
  %bitidx = alloca i64, align 8
  %bit = alloca i64, align 8
  %i = alloca i64, align 8
  %bitidx28 = alloca i64, align 8
  %bit30 = alloca i64, align 8
  %m = alloca i64, align 8
  %block43 = alloca ptr, align 8
  store ptr %xarea, ptr %xarea.addr, align 8
  store ptr %visitor, ptr %visitor.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %xarea.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %xarea.addr, align 8
  %area1 = getelementptr inbounds %struct.mi_heap_area_ex_s, ptr %1, i32 0, i32 0
  store ptr %area1, ptr %area, align 8
  %2 = load ptr, ptr %xarea.addr, align 8
  %page2 = getelementptr inbounds %struct.mi_heap_area_ex_s, ptr %2, i32 0, i32 1
  %3 = load ptr, ptr %page2, align 8
  store ptr %3, ptr %page, align 8
  %4 = load ptr, ptr %page, align 8
  %cmp3 = icmp eq ptr %4, null
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  store i1 true, ptr %retval, align 1
  br label %return

if.end5:                                          ; preds = %if.end
  %5 = load ptr, ptr %page, align 8
  call void @_mi_page_free_collect(ptr noundef %5, i1 noundef zeroext true)
  %6 = load ptr, ptr %page, align 8
  %used = getelementptr inbounds %struct.mi_page_s, ptr %6, i32 0, i32 8
  %7 = load i32, ptr %used, align 8
  %cmp6 = icmp eq i32 %7, 0
  br i1 %cmp6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end5
  store i1 true, ptr %retval, align 1
  br label %return

if.end8:                                          ; preds = %if.end5
  %8 = load ptr, ptr %page, align 8
  %call = call i64 @mi_page_block_size(ptr noundef %8)
  store i64 %call, ptr %bsize, align 8
  %9 = load ptr, ptr %page, align 8
  %call9 = call i64 @mi_page_usable_block_size(ptr noundef %9)
  store i64 %call9, ptr %ubsize, align 8
  %10 = load ptr, ptr %page, align 8
  %call10 = call ptr @_mi_page_segment(ptr noundef %10)
  %11 = load ptr, ptr %page, align 8
  %call11 = call ptr @_mi_page_start(ptr noundef %call10, ptr noundef %11, ptr noundef %psize)
  store ptr %call11, ptr %pstart, align 8
  %12 = load ptr, ptr %page, align 8
  %capacity = getelementptr inbounds %struct.mi_page_s, ptr %12, i32 0, i32 3
  %13 = load i16, ptr %capacity, align 2
  %conv = zext i16 %13 to i32
  %cmp12 = icmp eq i32 %conv, 1
  br i1 %cmp12, label %if.then14, label %if.end17

if.then14:                                        ; preds = %if.end8
  %14 = load ptr, ptr %visitor.addr, align 8
  %15 = load ptr, ptr %page, align 8
  %call15 = call ptr @mi_page_heap(ptr noundef %15)
  %16 = load ptr, ptr %area, align 8
  %17 = load ptr, ptr %pstart, align 8
  %18 = load i64, ptr %ubsize, align 8
  %19 = load ptr, ptr %arg.addr, align 8
  %call16 = call zeroext i1 %14(ptr noundef %call15, ptr noundef %16, ptr noundef %17, i64 noundef %18, ptr noundef %19)
  store i1 %call16, ptr %retval, align 1
  br label %return

if.end17:                                         ; preds = %if.end8
  %arraydecay = getelementptr inbounds [1024 x i64], ptr %free_map, i64 0, i64 0
  call void @llvm.memset.p0.i64(ptr align 16 %arraydecay, i8 0, i64 8192, i1 false)
  %20 = load ptr, ptr %page, align 8
  %free = getelementptr inbounds %struct.mi_page_s, ptr %20, i32 0, i32 7
  %21 = load ptr, ptr %free, align 8
  store ptr %21, ptr %block, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end17
  %22 = load ptr, ptr %block, align 8
  %cmp18 = icmp ne ptr %22, null
  br i1 %cmp18, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %23 = load ptr, ptr %block, align 8
  %24 = load ptr, ptr %pstart, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %23 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %24 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, ptr %offset, align 8
  %25 = load i64, ptr %offset, align 8
  %26 = load i64, ptr %bsize, align 8
  %div = udiv i64 %25, %26
  store i64 %div, ptr %blockidx, align 8
  %27 = load i64, ptr %blockidx, align 8
  %div20 = udiv i64 %27, 8
  store i64 %div20, ptr %bitidx, align 8
  %28 = load i64, ptr %blockidx, align 8
  %29 = load i64, ptr %bitidx, align 8
  %mul = mul i64 %29, 8
  %sub = sub i64 %28, %mul
  store i64 %sub, ptr %bit, align 8
  %30 = load i64, ptr %bit, align 8
  %shl = shl i64 1, %30
  %31 = load i64, ptr %bitidx, align 8
  %arrayidx = getelementptr [1024 x i64], ptr %free_map, i64 0, i64 %31
  %32 = load i64, ptr %arrayidx, align 8
  %or = or i64 %32, %shl
  store i64 %or, ptr %arrayidx, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %33 = load ptr, ptr %page, align 8
  %34 = load ptr, ptr %block, align 8
  %call21 = call ptr @mi_block_next(ptr noundef %33, ptr noundef %34)
  store ptr %call21, ptr %block, align 8
  br label %for.cond, !llvm.loop !115

for.end:                                          ; preds = %for.cond
  store i64 0, ptr %i, align 8
  br label %for.cond22

for.cond22:                                       ; preds = %for.inc51, %for.end
  %35 = load i64, ptr %i, align 8
  %36 = load ptr, ptr %page, align 8
  %capacity23 = getelementptr inbounds %struct.mi_page_s, ptr %36, i32 0, i32 3
  %37 = load i16, ptr %capacity23, align 2
  %conv24 = zext i16 %37 to i64
  %cmp25 = icmp ult i64 %35, %conv24
  br i1 %cmp25, label %for.body27, label %for.end52

for.body27:                                       ; preds = %for.cond22
  %38 = load i64, ptr %i, align 8
  %div29 = udiv i64 %38, 8
  store i64 %div29, ptr %bitidx28, align 8
  %39 = load i64, ptr %i, align 8
  %40 = load i64, ptr %bitidx28, align 8
  %mul31 = mul i64 %40, 8
  %sub32 = sub i64 %39, %mul31
  store i64 %sub32, ptr %bit30, align 8
  %41 = load i64, ptr %bitidx28, align 8
  %arrayidx33 = getelementptr [1024 x i64], ptr %free_map, i64 0, i64 %41
  %42 = load i64, ptr %arrayidx33, align 8
  store i64 %42, ptr %m, align 8
  %43 = load i64, ptr %bit30, align 8
  %cmp34 = icmp eq i64 %43, 0
  br i1 %cmp34, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %for.body27
  %44 = load i64, ptr %m, align 8
  %cmp36 = icmp eq i64 %44, -1
  br i1 %cmp36, label %if.then38, label %if.else

if.then38:                                        ; preds = %land.lhs.true
  %45 = load i64, ptr %i, align 8
  %add = add i64 %45, 7
  store i64 %add, ptr %i, align 8
  br label %if.end50

if.else:                                          ; preds = %land.lhs.true, %for.body27
  %46 = load i64, ptr %m, align 8
  %47 = load i64, ptr %bit30, align 8
  %shl39 = shl i64 1, %47
  %and = and i64 %46, %shl39
  %cmp40 = icmp eq i64 %and, 0
  br i1 %cmp40, label %if.then42, label %if.end49

if.then42:                                        ; preds = %if.else
  %48 = load ptr, ptr %pstart, align 8
  %49 = load i64, ptr %i, align 8
  %50 = load i64, ptr %bsize, align 8
  %mul44 = mul i64 %49, %50
  %add.ptr = getelementptr i8, ptr %48, i64 %mul44
  store ptr %add.ptr, ptr %block43, align 8
  %51 = load ptr, ptr %visitor.addr, align 8
  %52 = load ptr, ptr %page, align 8
  %call45 = call ptr @mi_page_heap(ptr noundef %52)
  %53 = load ptr, ptr %area, align 8
  %54 = load ptr, ptr %block43, align 8
  %55 = load i64, ptr %ubsize, align 8
  %56 = load ptr, ptr %arg.addr, align 8
  %call46 = call zeroext i1 %51(ptr noundef %call45, ptr noundef %53, ptr noundef %54, i64 noundef %55, ptr noundef %56)
  br i1 %call46, label %if.end48, label %if.then47

if.then47:                                        ; preds = %if.then42
  store i1 false, ptr %retval, align 1
  br label %return

if.end48:                                         ; preds = %if.then42
  br label %if.end49

if.end49:                                         ; preds = %if.end48, %if.else
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then38
  br label %for.inc51

for.inc51:                                        ; preds = %if.end50
  %57 = load i64, ptr %i, align 8
  %inc = add i64 %57, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond22, !llvm.loop !116

for.end52:                                        ; preds = %for.cond22
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %for.end52, %if.then47, %if.then14, %if.then7, %if.then4, %if.then
  %58 = load i1, ptr %retval, align 1
  ret i1 %58
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_thread_data_zalloc() #0 {
entry:
  %is_zero = alloca i8, align 1
  %td = alloca ptr, align 8
  %i = alloca i32, align 4
  %atomic-temp = alloca ptr, align 8
  %.atomictmp = alloca ptr, align 8
  %atomic-temp4 = alloca ptr, align 8
  %memid = alloca %struct.mi_memid_s, align 8
  store i8 0, ptr %is_zero, align 1
  store ptr null, ptr %td, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %i, align 4
  %cmp = icmp slt i32 %0, 16
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load i32, ptr %i, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr [16 x ptr], ptr @td_cache, i64 0, i64 %idxprom
  %2 = load atomic i64, ptr %arrayidx monotonic, align 8
  store i64 %2, ptr %atomic-temp, align 8
  %3 = load ptr, ptr %atomic-temp, align 8
  store ptr %3, ptr %td, align 8
  %4 = load ptr, ptr %td, align 8
  %cmp1 = icmp ne ptr %4, null
  br i1 %cmp1, label %if.then, label %if.end7

if.then:                                          ; preds = %for.body
  %5 = load i32, ptr %i, align 4
  %idxprom2 = sext i32 %5 to i64
  %arrayidx3 = getelementptr [16 x ptr], ptr @td_cache, i64 0, i64 %idxprom2
  store ptr null, ptr %.atomictmp, align 8
  %6 = load i64, ptr %.atomictmp, align 8
  %7 = atomicrmw xchg ptr %arrayidx3, i64 %6 acq_rel, align 8
  store i64 %7, ptr %atomic-temp4, align 8
  %8 = load ptr, ptr %atomic-temp4, align 8
  store ptr %8, ptr %td, align 8
  %9 = load ptr, ptr %td, align 8
  %cmp5 = icmp ne ptr %9, null
  br i1 %cmp5, label %if.then6, label %if.end

if.then6:                                         ; preds = %if.then
  br label %for.end

if.end:                                           ; preds = %if.then
  br label %if.end7

if.end7:                                          ; preds = %if.end, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end7
  %10 = load i32, ptr %i, align 4
  %inc = add i32 %10, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !117

for.end:                                          ; preds = %if.then6, %for.cond
  %11 = load ptr, ptr %td, align 8
  %cmp8 = icmp eq ptr %11, null
  br i1 %cmp8, label %if.then9, label %if.end21

if.then9:                                         ; preds = %for.end
  %call = call ptr @_mi_os_alloc(i64 noundef 4688, ptr noundef %memid, ptr noundef @_mi_stats_main)
  store ptr %call, ptr %td, align 8
  %12 = load ptr, ptr %td, align 8
  %cmp10 = icmp eq ptr %12, null
  br i1 %cmp10, label %if.then11, label %if.end16

if.then11:                                        ; preds = %if.then9
  %call12 = call ptr @_mi_os_alloc(i64 noundef 4688, ptr noundef %memid, ptr noundef @_mi_stats_main)
  store ptr %call12, ptr %td, align 8
  %13 = load ptr, ptr %td, align 8
  %cmp13 = icmp eq ptr %13, null
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.then11
  call void (i32, ptr, ...) @_mi_error_message(i32 noundef 12, ptr noundef @.str.47, i64 noundef 4688)
  br label %if.end15

if.end15:                                         ; preds = %if.then14, %if.then11
  br label %if.end16

if.end16:                                         ; preds = %if.end15, %if.then9
  %14 = load ptr, ptr %td, align 8
  %cmp17 = icmp ne ptr %14, null
  br i1 %cmp17, label %if.then18, label %if.end20

if.then18:                                        ; preds = %if.end16
  %15 = load ptr, ptr %td, align 8
  %memid19 = getelementptr inbounds %struct.mi_thread_data_s, ptr %15, i32 0, i32 2
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %memid19, ptr align 8 %memid, i64 24, i1 false)
  %initially_zero = getelementptr inbounds %struct.mi_memid_s, ptr %memid, i32 0, i32 3
  %16 = load i8, ptr %initially_zero, align 2
  %tobool = trunc i8 %16 to i1
  %frombool = zext i1 %tobool to i8
  store i8 %frombool, ptr %is_zero, align 1
  br label %if.end20

if.end20:                                         ; preds = %if.then18, %if.end16
  br label %if.end21

if.end21:                                         ; preds = %if.end20, %for.end
  %17 = load ptr, ptr %td, align 8
  %cmp22 = icmp ne ptr %17, null
  br i1 %cmp22, label %land.lhs.true, label %if.end25

land.lhs.true:                                    ; preds = %if.end21
  %18 = load i8, ptr %is_zero, align 1
  %tobool23 = trunc i8 %18 to i1
  br i1 %tobool23, label %if.end25, label %if.then24

if.then24:                                        ; preds = %land.lhs.true
  %19 = load ptr, ptr %td, align 8
  call void @_mi_memzero_aligned(ptr noundef %19, i64 noundef 4688)
  br label %if.end25

if.end25:                                         ; preds = %if.then24, %land.lhs.true, %if.end21
  %20 = load ptr, ptr %td, align 8
  ret ptr %20
}

; Function Attrs: nounwind uwtable
define internal void @mi_thread_data_free(ptr noundef %tdfree) #0 {
entry:
  %tdfree.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  %td = alloca ptr, align 8
  %atomic-temp = alloca ptr, align 8
  %expected = alloca ptr, align 8
  %.atomictmp = alloca ptr, align 8
  %cmpxchg.bool = alloca i8, align 1
  store ptr %tdfree, ptr %tdfree.addr, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %i, align 4
  %cmp = icmp slt i32 %0, 16
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load i32, ptr %i, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr [16 x ptr], ptr @td_cache, i64 0, i64 %idxprom
  %2 = load atomic i64, ptr %arrayidx monotonic, align 8
  store i64 %2, ptr %atomic-temp, align 8
  %3 = load ptr, ptr %atomic-temp, align 8
  store ptr %3, ptr %td, align 8
  %4 = load ptr, ptr %td, align 8
  %cmp1 = icmp eq ptr %4, null
  br i1 %cmp1, label %if.then, label %if.end5

if.then:                                          ; preds = %for.body
  store ptr null, ptr %expected, align 8
  %5 = load i32, ptr %i, align 4
  %idxprom2 = sext i32 %5 to i64
  %arrayidx3 = getelementptr [16 x ptr], ptr @td_cache, i64 0, i64 %idxprom2
  %6 = load ptr, ptr %tdfree.addr, align 8
  store ptr %6, ptr %.atomictmp, align 8
  %7 = load i64, ptr %expected, align 8
  %8 = load i64, ptr %.atomictmp, align 8
  %9 = cmpxchg weak ptr %arrayidx3, i64 %7, i64 %8 acq_rel acquire, align 8
  %10 = extractvalue { i64, i1 } %9, 0
  %11 = extractvalue { i64, i1 } %9, 1
  br i1 %11, label %cmpxchg.continue, label %cmpxchg.store_expected

cmpxchg.store_expected:                           ; preds = %if.then
  store i64 %10, ptr %expected, align 8
  br label %cmpxchg.continue

cmpxchg.continue:                                 ; preds = %cmpxchg.store_expected, %if.then
  %frombool = zext i1 %11 to i8
  store i8 %frombool, ptr %cmpxchg.bool, align 1
  %12 = load i8, ptr %cmpxchg.bool, align 1
  %tobool = trunc i8 %12 to i1
  br i1 %tobool, label %if.then4, label %if.end

if.then4:                                         ; preds = %cmpxchg.continue
  br label %return

if.end:                                           ; preds = %cmpxchg.continue
  br label %if.end5

if.end5:                                          ; preds = %if.end, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end5
  %13 = load i32, ptr %i, align 4
  %inc = add i32 %13, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !118

for.end:                                          ; preds = %for.cond
  %14 = load ptr, ptr %tdfree.addr, align 8
  %15 = load ptr, ptr %tdfree.addr, align 8
  %memid = getelementptr inbounds %struct.mi_thread_data_s, ptr %15, i32 0, i32 2
  call void @_mi_os_free(ptr noundef %14, i64 noundef 4688, ptr noundef byval(%struct.mi_memid_s) align 8 %memid, ptr noundef @_mi_stats_main)
  br label %return

return:                                           ; preds = %for.end, %if.then4
  ret void
}

; Function Attrs: nounwind
declare i32 @atexit(ptr noundef) #2

; Function Attrs: nounwind uwtable
define internal void @mi_process_done() #0 {
entry:
  %0 = load i8, ptr @_mi_process_is_initialized, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i8, ptr @mi_process_done.process_done, align 1
  %tobool1 = trunc i8 %1 to i1
  br i1 %tobool1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  br label %return

if.end3:                                          ; preds = %if.end
  store i8 1, ptr @mi_process_done.process_done, align 1
  call void @_mi_prim_thread_done_auto_done()
  call void @mi_collect(i1 noundef zeroext true)
  %call = call zeroext i1 @mi_option_is_enabled(i32 noundef 22)
  br i1 %call, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end3
  call void @mi_collect(i1 noundef zeroext true)
  call void @_mi_heap_unsafe_destroy_all()
  %call5 = call ptr @_mi_heap_main_get()
  %tld = getelementptr inbounds %struct.mi_heap_s, ptr %call5, i32 0, i32 0
  %2 = load ptr, ptr %tld, align 8
  %stats = getelementptr inbounds %struct.mi_tld_s, ptr %2, i32 0, i32 6
  call void @_mi_arena_unsafe_destroy_all(ptr noundef %stats)
  br label %if.end6

if.end6:                                          ; preds = %if.then4, %if.end3
  %call7 = call zeroext i1 @mi_option_is_enabled(i32 noundef 1)
  br i1 %call7, label %if.then9, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end6
  %call8 = call zeroext i1 @mi_option_is_enabled(i32 noundef 2)
  br i1 %call8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %lor.lhs.false, %if.end6
  call void @mi_stats_print(ptr noundef null)
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %lor.lhs.false
  call void @mi_allocator_done()
  %3 = load i64, ptr getelementptr inbounds (%struct.mi_heap_s, ptr @_mi_heap_main, i32 0, i32 4), align 8
  call void (ptr, ...) @_mi_verbose_message(ptr noundef @.str.49, i64 noundef %3)
  store i8 1, ptr @os_preloading, align 1
  br label %return

return:                                           ; preds = %if.end10, %if.then2, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_allocator_init(ptr noundef %message) #0 {
entry:
  %message.addr = alloca ptr, align 8
  store ptr %message, ptr %message.addr, align 8
  %0 = load ptr, ptr %message.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %message.addr, align 8
  store ptr null, ptr %1, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i1 true
}

; Function Attrs: nounwind uwtable
define internal void @mi_allocator_done() #0 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_out_buf_stderr(ptr noundef %msg, ptr noundef %arg) #0 {
entry:
  %msg.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  store ptr %msg, ptr %msg.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %msg.addr, align 8
  %1 = load ptr, ptr %arg.addr, align 8
  call void @mi_out_stderr(ptr noundef %0, ptr noundef %1)
  %2 = load ptr, ptr %msg.addr, align 8
  %3 = load ptr, ptr %arg.addr, align 8
  call void @mi_out_buf(ptr noundef %2, ptr noundef %3)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_out_buf(ptr noundef %msg, ptr noundef %arg) #0 {
entry:
  %msg.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %atomic-temp = alloca i64, align 8
  %n = alloca i64, align 8
  %start = alloca i64, align 8
  %.atomictmp = alloca i64, align 8
  %atomic-temp7 = alloca i64, align 8
  store ptr %msg, ptr %msg.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %msg.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load atomic i64, ptr @out_len monotonic, align 8
  store i64 %1, ptr %atomic-temp, align 8
  %2 = load i64, ptr %atomic-temp, align 8
  %cmp1 = icmp uge i64 %2, 32768
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  br label %return

if.end3:                                          ; preds = %if.end
  %3 = load ptr, ptr %msg.addr, align 8
  %call = call i64 @_mi_strlen(ptr noundef %3)
  store i64 %call, ptr %n, align 8
  %4 = load i64, ptr %n, align 8
  %cmp4 = icmp eq i64 %4, 0
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end3
  br label %return

if.end6:                                          ; preds = %if.end3
  %5 = load i64, ptr %n, align 8
  store i64 %5, ptr %.atomictmp, align 8
  %6 = load i64, ptr %.atomictmp, align 8
  %7 = atomicrmw add ptr @out_len, i64 %6 acq_rel, align 8
  store i64 %7, ptr %atomic-temp7, align 8
  %8 = load i64, ptr %atomic-temp7, align 8
  store i64 %8, ptr %start, align 8
  %9 = load i64, ptr %start, align 8
  %cmp8 = icmp uge i64 %9, 32768
  br i1 %cmp8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end6
  br label %return

if.end10:                                         ; preds = %if.end6
  %10 = load i64, ptr %start, align 8
  %11 = load i64, ptr %n, align 8
  %add = add i64 %10, %11
  %cmp11 = icmp uge i64 %add, 32768
  br i1 %cmp11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %if.end10
  %12 = load i64, ptr %start, align 8
  %sub = sub i64 32768, %12
  %sub13 = sub i64 %sub, 1
  store i64 %sub13, ptr %n, align 8
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %if.end10
  %13 = load i64, ptr %start, align 8
  %arrayidx = getelementptr [32769 x i8], ptr @out_buf, i64 0, i64 %13
  %14 = load ptr, ptr %msg.addr, align 8
  %15 = load i64, ptr %n, align 8
  call void @_mi_memcpy(ptr noundef %arrayidx, ptr noundef %14, i64 noundef %15)
  br label %return

return:                                           ; preds = %if.end14, %if.then9, %if.then5, %if.then2, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_recurse_enter_prim() #0 {
entry:
  %retval = alloca i1, align 1
  %0 = call align 1 ptr @llvm.threadlocal.address.p0(ptr align 1 @recurse)
  %1 = load i8, ptr %0, align 1
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %2 = call align 1 ptr @llvm.threadlocal.address.p0(ptr align 1 @recurse)
  store i8 1, ptr %2, align 1
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load i1, ptr %retval, align 1
  ret i1 %3
}

; Function Attrs: nounwind uwtable
define internal void @mi_recurse_exit_prim() #0 {
entry:
  %0 = call align 1 ptr @llvm.threadlocal.address.p0(ptr align 1 @recurse)
  store i8 0, ptr %0, align 1
  ret void
}

; Function Attrs: nounwind
declare i32 @vsnprintf(ptr noundef, i64 noundef, ptr noundef, ptr noundef) #2

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_getenv(ptr noundef %name, ptr noundef %result, i64 noundef %result_size) #0 {
entry:
  %retval = alloca i1, align 1
  %name.addr = alloca ptr, align 8
  %result.addr = alloca ptr, align 8
  %result_size.addr = alloca i64, align 8
  store ptr %name, ptr %name.addr, align 8
  store ptr %result, ptr %result.addr, align 8
  store i64 %result_size, ptr %result_size.addr, align 8
  %0 = load ptr, ptr %name.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %result.addr, align 8
  %cmp1 = icmp eq ptr %1, null
  br i1 %cmp1, label %if.then, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %2 = load i64, ptr %result_size.addr, align 8
  %cmp3 = icmp ult i64 %2, 64
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false2, %lor.lhs.false, %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %lor.lhs.false2
  %3 = load ptr, ptr %name.addr, align 8
  %4 = load ptr, ptr %result.addr, align 8
  %5 = load i64, ptr %result_size.addr, align 8
  %call = call zeroext i1 @_mi_prim_getenv(ptr noundef %3, ptr noundef %4, i64 noundef %5)
  store i1 %call, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i1, ptr %retval, align 1
  ret i1 %6
}

; Function Attrs: nounwind willreturn memory(read)
declare ptr @strstr(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind
declare i64 @strtol(ptr noundef, ptr noundef, i32 noundef) #2

; Function Attrs: nounwind uwtable
define internal ptr @mi_align_up_ptr(ptr noundef %p, i64 noundef %alignment) #0 {
entry:
  %p.addr = alloca ptr, align 8
  %alignment.addr = alloca i64, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %1 = ptrtoint ptr %0 to i64
  %2 = load i64, ptr %alignment.addr, align 8
  %call = call i64 @_mi_align_up(i64 noundef %1, i64 noundef %2)
  %3 = inttoptr i64 %call to ptr
  ret ptr %3
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_align_down_ptr(ptr noundef %p, i64 noundef %alignment) #0 {
entry:
  %p.addr = alloca ptr, align 8
  %alignment.addr = alloca i64, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %1 = ptrtoint ptr %0 to i64
  %2 = load i64, ptr %alignment.addr, align 8
  %call = call i64 @_mi_align_down(i64 noundef %1, i64 noundef %2)
  %3 = inttoptr i64 %call to ptr
  ret ptr %3
}

; Function Attrs: nounwind uwtable
define internal i64 @_mi_align_down(i64 noundef %sz, i64 noundef %alignment) #0 {
entry:
  %retval = alloca i64, align 8
  %sz.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  %mask = alloca i64, align 8
  store i64 %sz, ptr %sz.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  %0 = load i64, ptr %alignment.addr, align 8
  %sub = sub i64 %0, 1
  store i64 %sub, ptr %mask, align 8
  %1 = load i64, ptr %alignment.addr, align 8
  %2 = load i64, ptr %mask, align 8
  %and = and i64 %1, %2
  %cmp = icmp eq i64 %and, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load i64, ptr %sz.addr, align 8
  %4 = load i64, ptr %mask, align 8
  %not = xor i64 %4, -1
  %and1 = and i64 %3, %not
  store i64 %and1, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %5 = load i64, ptr %sz.addr, align 8
  %6 = load i64, ptr %alignment.addr, align 8
  %div = udiv i64 %5, %6
  %7 = load i64, ptr %alignment.addr, align 8
  %mul = mul i64 %div, %7
  store i64 %mul, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %8 = load i64, ptr %retval, align 8
  ret i64 %8
}

; Function Attrs: nounwind uwtable
define internal i64 @mi_bsr(i64 noundef %x) #0 {
entry:
  %x.addr = alloca i64, align 8
  store i64 %x, ptr %x.addr, align 8
  %0 = load i64, ptr %x.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %1 = load i64, ptr %x.addr, align 8
  %call = call i64 @mi_clz(i64 noundef %1)
  %sub = sub i64 63, %call
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ 64, %cond.true ], [ %sub, %cond.false ]
  ret i64 %cond
}

; Function Attrs: nounwind
declare void @llvm.x86.sse2.pause() #15

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_page_queue_is_full(ptr noundef %pq) #0 {
entry:
  %pq.addr = alloca ptr, align 8
  store ptr %pq, ptr %pq.addr, align 8
  %0 = load ptr, ptr %pq.addr, align 8
  %block_size = getelementptr inbounds %struct.mi_page_queue_s, ptr %0, i32 0, i32 2
  %1 = load i64, ptr %block_size, align 8
  %cmp = icmp eq i64 %1, 131088
  ret i1 %cmp
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_large_huge_page_alloc(ptr noundef %heap, i64 noundef %size, i64 noundef %page_alignment) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %page_alignment.addr = alloca i64, align 8
  %block_size = alloca i64, align 8
  %is_huge = alloca i8, align 1
  %pq = alloca ptr, align 8
  %page = alloca ptr, align 8
  %bsize = alloca i64, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store i64 %page_alignment, ptr %page_alignment.addr, align 8
  %0 = load i64, ptr %size.addr, align 8
  %call = call i64 @_mi_os_good_alloc_size(i64 noundef %0)
  store i64 %call, ptr %block_size, align 8
  %1 = load i64, ptr %block_size, align 8
  %cmp = icmp ugt i64 %1, 16777216
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %2 = load i64, ptr %page_alignment.addr, align 8
  %cmp1 = icmp ugt i64 %2, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %3 = phi i1 [ true, %entry ], [ %cmp1, %lor.rhs ]
  %frombool = zext i1 %3 to i8
  store i8 %frombool, ptr %is_huge, align 1
  %4 = load ptr, ptr %heap.addr, align 8
  %5 = load i8, ptr %is_huge, align 1
  %tobool = trunc i8 %5 to i1
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %lor.end
  br label %cond.end

cond.false:                                       ; preds = %lor.end
  %6 = load i64, ptr %block_size, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ 2147483648, %cond.true ], [ %6, %cond.false ]
  %call2 = call ptr @mi_page_queue(ptr noundef %4, i64 noundef %cond)
  store ptr %call2, ptr %pq, align 8
  %7 = load ptr, ptr %heap.addr, align 8
  %8 = load ptr, ptr %pq, align 8
  %9 = load i64, ptr %block_size, align 8
  %10 = load i64, ptr %page_alignment.addr, align 8
  %call3 = call ptr @mi_page_fresh_alloc(ptr noundef %7, ptr noundef %8, i64 noundef %9, i64 noundef %10)
  store ptr %call3, ptr %page, align 8
  %11 = load ptr, ptr %page, align 8
  %cmp4 = icmp ne ptr %11, null
  br i1 %cmp4, label %if.then, label %if.end12

if.then:                                          ; preds = %cond.end
  %12 = load i8, ptr %is_huge, align 1
  %tobool5 = trunc i8 %12 to i1
  br i1 %tobool5, label %if.then6, label %if.else

if.then6:                                         ; preds = %if.then
  br label %if.end

if.else:                                          ; preds = %if.then
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then6
  %13 = load ptr, ptr %page, align 8
  %call7 = call i64 @mi_page_usable_block_size(ptr noundef %13)
  store i64 %call7, ptr %bsize, align 8
  %14 = load i64, ptr %bsize, align 8
  %cmp8 = icmp ule i64 %14, 16777216
  br i1 %cmp8, label %if.then9, label %if.else10

if.then9:                                         ; preds = %if.end
  br label %if.end11

if.else10:                                        ; preds = %if.end
  br label %if.end11

if.end11:                                         ; preds = %if.else10, %if.then9
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %cond.end
  %15 = load ptr, ptr %page, align 8
  ret ptr %15
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_find_free_page(ptr noundef %heap, i64 noundef %size) #0 {
entry:
  %retval = alloca ptr, align 8
  %heap.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %pq = alloca ptr, align 8
  %page = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load ptr, ptr %heap.addr, align 8
  %1 = load i64, ptr %size.addr, align 8
  %call = call ptr @mi_page_queue(ptr noundef %0, i64 noundef %1)
  store ptr %call, ptr %pq, align 8
  %2 = load ptr, ptr %pq, align 8
  %first = getelementptr inbounds %struct.mi_page_queue_s, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %first, align 8
  store ptr %3, ptr %page, align 8
  %4 = load ptr, ptr %page, align 8
  %cmp = icmp ne ptr %4, null
  br i1 %cmp, label %if.then, label %if.end3

if.then:                                          ; preds = %entry
  %5 = load ptr, ptr %page, align 8
  call void @_mi_page_free_collect(ptr noundef %5, i1 noundef zeroext false)
  %6 = load ptr, ptr %page, align 8
  %call1 = call zeroext i1 @mi_page_immediate_available(ptr noundef %6)
  br i1 %call1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %7 = load ptr, ptr %page, align 8
  %retire_expire = getelementptr inbounds %struct.mi_page_s, ptr %7, i32 0, i32 6
  %bf.load = load i8, ptr %retire_expire, align 1
  %bf.clear = and i8 %bf.load, 1
  %bf.set = or i8 %bf.clear, 0
  store i8 %bf.set, ptr %retire_expire, align 1
  %8 = load ptr, ptr %page, align 8
  store ptr %8, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %if.then
  br label %if.end3

if.end3:                                          ; preds = %if.end, %entry
  %9 = load ptr, ptr %heap.addr, align 8
  %10 = load ptr, ptr %pq, align 8
  %call4 = call ptr @mi_page_queue_find_free_ex(ptr noundef %9, ptr noundef %10, i1 noundef zeroext true)
  store ptr %call4, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end3, %if.then2
  %11 = load ptr, ptr %retval, align 8
  ret ptr %11
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_page_fresh_alloc(ptr noundef %heap, ptr noundef %pq, i64 noundef %block_size, i64 noundef %page_alignment) #0 {
entry:
  %retval = alloca ptr, align 8
  %heap.addr = alloca ptr, align 8
  %pq.addr = alloca ptr, align 8
  %block_size.addr = alloca i64, align 8
  %page_alignment.addr = alloca i64, align 8
  %page = alloca ptr, align 8
  %full_block_size = alloca i64, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store ptr %pq, ptr %pq.addr, align 8
  store i64 %block_size, ptr %block_size.addr, align 8
  store i64 %page_alignment, ptr %page_alignment.addr, align 8
  %0 = load ptr, ptr %heap.addr, align 8
  %1 = load i64, ptr %block_size.addr, align 8
  %2 = load i64, ptr %page_alignment.addr, align 8
  %3 = load ptr, ptr %heap.addr, align 8
  %tld = getelementptr inbounds %struct.mi_heap_s, ptr %3, i32 0, i32 0
  %4 = load ptr, ptr %tld, align 8
  %segments = getelementptr inbounds %struct.mi_tld_s, ptr %4, i32 0, i32 4
  %5 = load ptr, ptr %heap.addr, align 8
  %tld1 = getelementptr inbounds %struct.mi_heap_s, ptr %5, i32 0, i32 0
  %6 = load ptr, ptr %tld1, align 8
  %os = getelementptr inbounds %struct.mi_tld_s, ptr %6, i32 0, i32 5
  %call = call ptr @_mi_segment_page_alloc(ptr noundef %0, i64 noundef %1, i64 noundef %2, ptr noundef %segments, ptr noundef %os)
  store ptr %call, ptr %page, align 8
  %7 = load ptr, ptr %page, align 8
  %cmp = icmp eq ptr %7, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %pq.addr, align 8
  %cmp2 = icmp eq ptr %8, null
  br i1 %cmp2, label %cond.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %9 = load ptr, ptr %pq.addr, align 8
  %call3 = call zeroext i1 @mi_page_queue_is_huge(ptr noundef %9)
  br i1 %call3, label %cond.true, label %cond.false

cond.true:                                        ; preds = %lor.lhs.false, %if.end
  %10 = load ptr, ptr %page, align 8
  %call4 = call i64 @mi_page_block_size(ptr noundef %10)
  br label %cond.end

cond.false:                                       ; preds = %lor.lhs.false
  %11 = load i64, ptr %block_size.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call4, %cond.true ], [ %11, %cond.false ]
  store i64 %cond, ptr %full_block_size, align 8
  %12 = load ptr, ptr %heap.addr, align 8
  %13 = load ptr, ptr %page, align 8
  %14 = load i64, ptr %full_block_size, align 8
  %15 = load ptr, ptr %heap.addr, align 8
  %tld5 = getelementptr inbounds %struct.mi_heap_s, ptr %15, i32 0, i32 0
  %16 = load ptr, ptr %tld5, align 8
  call void @mi_page_init(ptr noundef %12, ptr noundef %13, i64 noundef %14, ptr noundef %16)
  %17 = load ptr, ptr %pq.addr, align 8
  %cmp6 = icmp ne ptr %17, null
  br i1 %cmp6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %cond.end
  %18 = load ptr, ptr %heap.addr, align 8
  %19 = load ptr, ptr %pq.addr, align 8
  %20 = load ptr, ptr %page, align 8
  call void @mi_page_queue_push(ptr noundef %18, ptr noundef %19, ptr noundef %20)
  br label %if.end8

if.end8:                                          ; preds = %if.then7, %cond.end
  %21 = load ptr, ptr %page, align 8
  store ptr %21, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end8, %if.then
  %22 = load ptr, ptr %retval, align 8
  ret ptr %22
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_page_queue_is_huge(ptr noundef %pq) #0 {
entry:
  %pq.addr = alloca ptr, align 8
  store ptr %pq, ptr %pq.addr, align 8
  %0 = load ptr, ptr %pq.addr, align 8
  %block_size = getelementptr inbounds %struct.mi_page_queue_s, ptr %0, i32 0, i32 2
  %1 = load i64, ptr %block_size, align 8
  %cmp = icmp eq i64 %1, 131080
  ret i1 %cmp
}

; Function Attrs: nounwind uwtable
define internal void @mi_page_init(ptr noundef %heap, ptr noundef %page, i64 noundef %block_size, ptr noundef %tld) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %page.addr = alloca ptr, align 8
  %block_size.addr = alloca i64, align 8
  %tld.addr = alloca ptr, align 8
  %segment = alloca ptr, align 8
  %page_size = alloca i64, align 8
  %page_start = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store ptr %page, ptr %page.addr, align 8
  store i64 %block_size, ptr %block_size.addr, align 8
  store ptr %tld, ptr %tld.addr, align 8
  %0 = load ptr, ptr %page.addr, align 8
  %call = call ptr @_mi_page_segment(ptr noundef %0)
  store ptr %call, ptr %segment, align 8
  %1 = load ptr, ptr %page.addr, align 8
  %2 = load ptr, ptr %heap.addr, align 8
  call void @mi_page_set_heap(ptr noundef %1, ptr noundef %2)
  %3 = load i64, ptr %block_size.addr, align 8
  %cmp = icmp ult i64 %3, 2147483648
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %4 = load i64, ptr %block_size.addr, align 8
  %conv = trunc i64 %4 to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv, %cond.true ], [ -2147483648, %cond.false ]
  %5 = load ptr, ptr %page.addr, align 8
  %xblock_size = getelementptr inbounds %struct.mi_page_s, ptr %5, i32 0, i32 9
  store i32 %cond, ptr %xblock_size, align 4
  %6 = load ptr, ptr %segment, align 8
  %7 = load ptr, ptr %page.addr, align 8
  %call1 = call ptr @_mi_segment_page_start(ptr noundef %6, ptr noundef %7, ptr noundef %page_size)
  store ptr %call1, ptr %page_start, align 8
  %8 = load i64, ptr %page_size, align 8
  %9 = load i64, ptr %block_size.addr, align 8
  %div = udiv i64 %8, %9
  %conv2 = trunc i64 %div to i16
  %10 = load ptr, ptr %page.addr, align 8
  %reserved = getelementptr inbounds %struct.mi_page_s, ptr %10, i32 0, i32 4
  store i16 %conv2, ptr %reserved, align 4
  %11 = load ptr, ptr %page.addr, align 8
  %is_zero_init = getelementptr inbounds %struct.mi_page_s, ptr %11, i32 0, i32 2
  %bf.load = load i8, ptr %is_zero_init, align 8
  %bf.lshr = lshr i8 %bf.load, 1
  %bf.clear = and i8 %bf.lshr, 1
  %12 = load ptr, ptr %page.addr, align 8
  %free_is_zero = getelementptr inbounds %struct.mi_page_s, ptr %12, i32 0, i32 6
  %bf.load3 = load i8, ptr %free_is_zero, align 1
  %bf.value = and i8 %bf.clear, 1
  %bf.clear4 = and i8 %bf.load3, -2
  %bf.set = or i8 %bf.clear4, %bf.value
  store i8 %bf.set, ptr %free_is_zero, align 1
  %13 = load ptr, ptr %heap.addr, align 8
  %14 = load ptr, ptr %page.addr, align 8
  %15 = load ptr, ptr %tld.addr, align 8
  call void @mi_page_extend_free(ptr noundef %13, ptr noundef %14, ptr noundef %15)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_page_extend_free(ptr noundef %heap, ptr noundef %page, ptr noundef %tld) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %page.addr = alloca ptr, align 8
  %tld.addr = alloca ptr, align 8
  %page_size = alloca i64, align 8
  %bsize = alloca i64, align 8
  %extend = alloca i64, align 8
  %max_extend = alloca i64, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store ptr %page, ptr %page.addr, align 8
  store ptr %tld, ptr %tld.addr, align 8
  %0 = load ptr, ptr %page.addr, align 8
  %free = getelementptr inbounds %struct.mi_page_s, ptr %0, i32 0, i32 7
  %1 = load ptr, ptr %free, align 8
  %cmp = icmp ne ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %page.addr, align 8
  %capacity = getelementptr inbounds %struct.mi_page_s, ptr %2, i32 0, i32 3
  %3 = load i16, ptr %capacity, align 2
  %conv = zext i16 %3 to i32
  %4 = load ptr, ptr %page.addr, align 8
  %reserved = getelementptr inbounds %struct.mi_page_s, ptr %4, i32 0, i32 4
  %5 = load i16, ptr %reserved, align 4
  %conv1 = zext i16 %5 to i32
  %cmp2 = icmp sge i32 %conv, %conv1
  br i1 %cmp2, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  br label %return

if.end5:                                          ; preds = %if.end
  %6 = load ptr, ptr %page.addr, align 8
  %call = call ptr @_mi_page_segment(ptr noundef %6)
  %7 = load ptr, ptr %page.addr, align 8
  %call6 = call ptr @_mi_page_start(ptr noundef %call, ptr noundef %7, ptr noundef %page_size)
  %8 = load ptr, ptr %page.addr, align 8
  %xblock_size = getelementptr inbounds %struct.mi_page_s, ptr %8, i32 0, i32 9
  %9 = load i32, ptr %xblock_size, align 4
  %cmp7 = icmp ult i32 %9, -2147483648
  br i1 %cmp7, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end5
  %10 = load ptr, ptr %page.addr, align 8
  %xblock_size9 = getelementptr inbounds %struct.mi_page_s, ptr %10, i32 0, i32 9
  %11 = load i32, ptr %xblock_size9, align 4
  %conv10 = zext i32 %11 to i64
  br label %cond.end

cond.false:                                       ; preds = %if.end5
  %12 = load i64, ptr %page_size, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %conv10, %cond.true ], [ %12, %cond.false ]
  store i64 %cond, ptr %bsize, align 8
  %13 = load ptr, ptr %page.addr, align 8
  %reserved11 = getelementptr inbounds %struct.mi_page_s, ptr %13, i32 0, i32 4
  %14 = load i16, ptr %reserved11, align 4
  %conv12 = zext i16 %14 to i32
  %15 = load ptr, ptr %page.addr, align 8
  %capacity13 = getelementptr inbounds %struct.mi_page_s, ptr %15, i32 0, i32 3
  %16 = load i16, ptr %capacity13, align 2
  %conv14 = zext i16 %16 to i32
  %sub = sub i32 %conv12, %conv14
  %conv15 = sext i32 %sub to i64
  store i64 %conv15, ptr %extend, align 8
  %17 = load i64, ptr %bsize, align 8
  %cmp16 = icmp uge i64 %17, 4096
  br i1 %cmp16, label %cond.true18, label %cond.false19

cond.true18:                                      ; preds = %cond.end
  br label %cond.end21

cond.false19:                                     ; preds = %cond.end
  %18 = load i64, ptr %bsize, align 8
  %conv20 = trunc i64 %18 to i32
  %div = udiv i32 4096, %conv20
  br label %cond.end21

cond.end21:                                       ; preds = %cond.false19, %cond.true18
  %cond22 = phi i32 [ 4, %cond.true18 ], [ %div, %cond.false19 ]
  %conv23 = zext i32 %cond22 to i64
  store i64 %conv23, ptr %max_extend, align 8
  %19 = load i64, ptr %max_extend, align 8
  %cmp24 = icmp ult i64 %19, 4
  br i1 %cmp24, label %if.then26, label %if.end27

if.then26:                                        ; preds = %cond.end21
  store i64 4, ptr %max_extend, align 8
  br label %if.end27

if.end27:                                         ; preds = %if.then26, %cond.end21
  %20 = load i64, ptr %extend, align 8
  %21 = load i64, ptr %max_extend, align 8
  %cmp28 = icmp ugt i64 %20, %21
  br i1 %cmp28, label %if.then30, label %if.end31

if.then30:                                        ; preds = %if.end27
  %22 = load i64, ptr %max_extend, align 8
  store i64 %22, ptr %extend, align 8
  br label %if.end31

if.end31:                                         ; preds = %if.then30, %if.end27
  %23 = load i64, ptr %extend, align 8
  %cmp32 = icmp ult i64 %23, 2
  br i1 %cmp32, label %if.then34, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end31
  br i1 true, label %if.then34, label %if.else

if.then34:                                        ; preds = %lor.lhs.false, %if.end31
  %24 = load ptr, ptr %page.addr, align 8
  %25 = load i64, ptr %bsize, align 8
  %26 = load i64, ptr %extend, align 8
  %27 = load ptr, ptr %tld.addr, align 8
  %stats = getelementptr inbounds %struct.mi_tld_s, ptr %27, i32 0, i32 6
  call void @mi_page_free_list_extend(ptr noundef %24, i64 noundef %25, i64 noundef %26, ptr noundef %stats)
  br label %if.end36

if.else:                                          ; preds = %lor.lhs.false
  %28 = load ptr, ptr %heap.addr, align 8
  %29 = load ptr, ptr %page.addr, align 8
  %30 = load i64, ptr %bsize, align 8
  %31 = load i64, ptr %extend, align 8
  %32 = load ptr, ptr %tld.addr, align 8
  %stats35 = getelementptr inbounds %struct.mi_tld_s, ptr %32, i32 0, i32 6
  call void @mi_page_free_list_extend_secure(ptr noundef %28, ptr noundef %29, i64 noundef %30, i64 noundef %31, ptr noundef %stats35)
  br label %if.end36

if.end36:                                         ; preds = %if.else, %if.then34
  %33 = load i64, ptr %extend, align 8
  %conv37 = trunc i64 %33 to i16
  %conv38 = zext i16 %conv37 to i32
  %34 = load ptr, ptr %page.addr, align 8
  %capacity39 = getelementptr inbounds %struct.mi_page_s, ptr %34, i32 0, i32 3
  %35 = load i16, ptr %capacity39, align 2
  %conv40 = zext i16 %35 to i32
  %add = add i32 %conv40, %conv38
  %conv41 = trunc i32 %add to i16
  store i16 %conv41, ptr %capacity39, align 2
  br label %return

return:                                           ; preds = %if.end36, %if.then4, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_page_free_list_extend(ptr noundef %page, i64 noundef %bsize, i64 noundef %extend, ptr noundef %stats) #0 {
entry:
  %page.addr = alloca ptr, align 8
  %bsize.addr = alloca i64, align 8
  %extend.addr = alloca i64, align 8
  %stats.addr = alloca ptr, align 8
  %page_area = alloca ptr, align 8
  %start = alloca ptr, align 8
  %last = alloca ptr, align 8
  %block = alloca ptr, align 8
  %next = alloca ptr, align 8
  store ptr %page, ptr %page.addr, align 8
  store i64 %bsize, ptr %bsize.addr, align 8
  store i64 %extend, ptr %extend.addr, align 8
  store ptr %stats, ptr %stats.addr, align 8
  %0 = load ptr, ptr %page.addr, align 8
  %call = call ptr @_mi_page_segment(ptr noundef %0)
  %1 = load ptr, ptr %page.addr, align 8
  %call1 = call ptr @_mi_page_start(ptr noundef %call, ptr noundef %1, ptr noundef null)
  store ptr %call1, ptr %page_area, align 8
  %2 = load ptr, ptr %page.addr, align 8
  %3 = load ptr, ptr %page_area, align 8
  %4 = load i64, ptr %bsize.addr, align 8
  %5 = load ptr, ptr %page.addr, align 8
  %capacity = getelementptr inbounds %struct.mi_page_s, ptr %5, i32 0, i32 3
  %6 = load i16, ptr %capacity, align 2
  %conv = zext i16 %6 to i64
  %call2 = call ptr @mi_page_block_at(ptr noundef %2, ptr noundef %3, i64 noundef %4, i64 noundef %conv)
  store ptr %call2, ptr %start, align 8
  %7 = load ptr, ptr %page.addr, align 8
  %8 = load ptr, ptr %page_area, align 8
  %9 = load i64, ptr %bsize.addr, align 8
  %10 = load ptr, ptr %page.addr, align 8
  %capacity3 = getelementptr inbounds %struct.mi_page_s, ptr %10, i32 0, i32 3
  %11 = load i16, ptr %capacity3, align 2
  %conv4 = zext i16 %11 to i64
  %12 = load i64, ptr %extend.addr, align 8
  %add = add i64 %conv4, %12
  %sub = sub i64 %add, 1
  %call5 = call ptr @mi_page_block_at(ptr noundef %7, ptr noundef %8, i64 noundef %9, i64 noundef %sub)
  store ptr %call5, ptr %last, align 8
  %13 = load ptr, ptr %start, align 8
  store ptr %13, ptr %block, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %14 = load ptr, ptr %block, align 8
  %15 = load ptr, ptr %last, align 8
  %cmp = icmp ule ptr %14, %15
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %16 = load ptr, ptr %block, align 8
  %17 = load i64, ptr %bsize.addr, align 8
  %add.ptr = getelementptr i8, ptr %16, i64 %17
  store ptr %add.ptr, ptr %next, align 8
  %18 = load ptr, ptr %page.addr, align 8
  %19 = load ptr, ptr %block, align 8
  %20 = load ptr, ptr %next, align 8
  call void @mi_block_set_next(ptr noundef %18, ptr noundef %19, ptr noundef %20)
  %21 = load ptr, ptr %next, align 8
  store ptr %21, ptr %block, align 8
  br label %while.cond, !llvm.loop !119

while.end:                                        ; preds = %while.cond
  %22 = load ptr, ptr %page.addr, align 8
  %23 = load ptr, ptr %last, align 8
  %24 = load ptr, ptr %page.addr, align 8
  %free = getelementptr inbounds %struct.mi_page_s, ptr %24, i32 0, i32 7
  %25 = load ptr, ptr %free, align 8
  call void @mi_block_set_next(ptr noundef %22, ptr noundef %23, ptr noundef %25)
  %26 = load ptr, ptr %start, align 8
  %27 = load ptr, ptr %page.addr, align 8
  %free7 = getelementptr inbounds %struct.mi_page_s, ptr %27, i32 0, i32 7
  store ptr %26, ptr %free7, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_page_free_list_extend_secure(ptr noundef %heap, ptr noundef %page, i64 noundef %bsize, i64 noundef %extend, ptr noundef %stats) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %page.addr = alloca ptr, align 8
  %bsize.addr = alloca i64, align 8
  %extend.addr = alloca i64, align 8
  %stats.addr = alloca ptr, align 8
  %page_area = alloca ptr, align 8
  %shift = alloca i64, align 8
  %slice_count = alloca i64, align 8
  %slice_extend = alloca i64, align 8
  %blocks = alloca [64 x ptr], align 16
  %counts = alloca [64 x i64], align 16
  %i = alloca i64, align 8
  %r = alloca i64, align 8
  %current = alloca i64, align 8
  %free_start = alloca ptr, align 8
  %rnd = alloca i64, align 8
  %i13 = alloca i64, align 8
  %round = alloca i64, align 8
  %next = alloca i64, align 8
  %block = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store ptr %page, ptr %page.addr, align 8
  store i64 %bsize, ptr %bsize.addr, align 8
  store i64 %extend, ptr %extend.addr, align 8
  store ptr %stats, ptr %stats.addr, align 8
  %0 = load ptr, ptr %page.addr, align 8
  %call = call ptr @_mi_page_segment(ptr noundef %0)
  %1 = load ptr, ptr %page.addr, align 8
  %call1 = call ptr @_mi_page_start(ptr noundef %call, ptr noundef %1, ptr noundef null)
  store ptr %call1, ptr %page_area, align 8
  store i64 6, ptr %shift, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %2 = load i64, ptr %extend.addr, align 8
  %3 = load i64, ptr %shift, align 8
  %shr = lshr i64 %2, %3
  %cmp = icmp eq i64 %shr, 0
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %4 = load i64, ptr %shift, align 8
  %dec = add i64 %4, -1
  store i64 %dec, ptr %shift, align 8
  br label %while.cond, !llvm.loop !120

while.end:                                        ; preds = %while.cond
  %5 = load i64, ptr %shift, align 8
  %shl = shl i64 1, %5
  store i64 %shl, ptr %slice_count, align 8
  %6 = load i64, ptr %extend.addr, align 8
  %7 = load i64, ptr %slice_count, align 8
  %div = udiv i64 %6, %7
  store i64 %div, ptr %slice_extend, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %while.end
  %8 = load i64, ptr %i, align 8
  %9 = load i64, ptr %slice_count, align 8
  %cmp2 = icmp ult i64 %8, %9
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %page.addr, align 8
  %11 = load ptr, ptr %page_area, align 8
  %12 = load i64, ptr %bsize.addr, align 8
  %13 = load ptr, ptr %page.addr, align 8
  %capacity = getelementptr inbounds %struct.mi_page_s, ptr %13, i32 0, i32 3
  %14 = load i16, ptr %capacity, align 2
  %conv = zext i16 %14 to i64
  %15 = load i64, ptr %i, align 8
  %16 = load i64, ptr %slice_extend, align 8
  %mul = mul i64 %15, %16
  %add = add i64 %conv, %mul
  %call3 = call ptr @mi_page_block_at(ptr noundef %10, ptr noundef %11, i64 noundef %12, i64 noundef %add)
  %17 = load i64, ptr %i, align 8
  %arrayidx = getelementptr [64 x ptr], ptr %blocks, i64 0, i64 %17
  store ptr %call3, ptr %arrayidx, align 8
  %18 = load i64, ptr %slice_extend, align 8
  %19 = load i64, ptr %i, align 8
  %arrayidx4 = getelementptr [64 x i64], ptr %counts, i64 0, i64 %19
  store i64 %18, ptr %arrayidx4, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %20 = load i64, ptr %i, align 8
  %inc = add i64 %20, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !121

for.end:                                          ; preds = %for.cond
  %21 = load i64, ptr %extend.addr, align 8
  %22 = load i64, ptr %slice_count, align 8
  %rem = urem i64 %21, %22
  %23 = load i64, ptr %slice_count, align 8
  %sub = sub i64 %23, 1
  %arrayidx5 = getelementptr [64 x i64], ptr %counts, i64 0, i64 %sub
  %24 = load i64, ptr %arrayidx5, align 8
  %add6 = add i64 %24, %rem
  store i64 %add6, ptr %arrayidx5, align 8
  %25 = load ptr, ptr %heap.addr, align 8
  %call7 = call i64 @_mi_heap_random_next(ptr noundef %25)
  store i64 %call7, ptr %r, align 8
  %26 = load i64, ptr %r, align 8
  %27 = load i64, ptr %slice_count, align 8
  %rem8 = urem i64 %26, %27
  store i64 %rem8, ptr %current, align 8
  %28 = load i64, ptr %current, align 8
  %arrayidx9 = getelementptr [64 x i64], ptr %counts, i64 0, i64 %28
  %29 = load i64, ptr %arrayidx9, align 8
  %dec10 = add i64 %29, -1
  store i64 %dec10, ptr %arrayidx9, align 8
  %30 = load i64, ptr %current, align 8
  %arrayidx11 = getelementptr [64 x ptr], ptr %blocks, i64 0, i64 %30
  %31 = load ptr, ptr %arrayidx11, align 8
  store ptr %31, ptr %free_start, align 8
  %32 = load i64, ptr %r, align 8
  %or = or i64 %32, 1
  %call12 = call i64 @_mi_random_shuffle(i64 noundef %or)
  store i64 %call12, ptr %rnd, align 8
  store i64 1, ptr %i13, align 8
  br label %for.cond14

for.cond14:                                       ; preds = %for.inc41, %for.end
  %33 = load i64, ptr %i13, align 8
  %34 = load i64, ptr %extend.addr, align 8
  %cmp15 = icmp ult i64 %33, %34
  br i1 %cmp15, label %for.body17, label %for.end43

for.body17:                                       ; preds = %for.cond14
  %35 = load i64, ptr %i13, align 8
  %rem18 = urem i64 %35, 8
  store i64 %rem18, ptr %round, align 8
  %36 = load i64, ptr %round, align 8
  %cmp19 = icmp eq i64 %36, 0
  br i1 %cmp19, label %if.then, label %if.end

if.then:                                          ; preds = %for.body17
  %37 = load i64, ptr %rnd, align 8
  %call21 = call i64 @_mi_random_shuffle(i64 noundef %37)
  store i64 %call21, ptr %rnd, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body17
  %38 = load i64, ptr %rnd, align 8
  %39 = load i64, ptr %round, align 8
  %mul22 = mul i64 8, %39
  %shr23 = lshr i64 %38, %mul22
  %40 = load i64, ptr %slice_count, align 8
  %sub24 = sub i64 %40, 1
  %and = and i64 %shr23, %sub24
  store i64 %and, ptr %next, align 8
  br label %while.cond25

while.cond25:                                     ; preds = %if.end34, %if.end
  %41 = load i64, ptr %next, align 8
  %arrayidx26 = getelementptr [64 x i64], ptr %counts, i64 0, i64 %41
  %42 = load i64, ptr %arrayidx26, align 8
  %cmp27 = icmp eq i64 %42, 0
  br i1 %cmp27, label %while.body29, label %while.end35

while.body29:                                     ; preds = %while.cond25
  %43 = load i64, ptr %next, align 8
  %inc30 = add i64 %43, 1
  store i64 %inc30, ptr %next, align 8
  %44 = load i64, ptr %next, align 8
  %45 = load i64, ptr %slice_count, align 8
  %cmp31 = icmp eq i64 %44, %45
  br i1 %cmp31, label %if.then33, label %if.end34

if.then33:                                        ; preds = %while.body29
  store i64 0, ptr %next, align 8
  br label %if.end34

if.end34:                                         ; preds = %if.then33, %while.body29
  br label %while.cond25, !llvm.loop !122

while.end35:                                      ; preds = %while.cond25
  %46 = load i64, ptr %next, align 8
  %arrayidx36 = getelementptr [64 x i64], ptr %counts, i64 0, i64 %46
  %47 = load i64, ptr %arrayidx36, align 8
  %dec37 = add i64 %47, -1
  store i64 %dec37, ptr %arrayidx36, align 8
  %48 = load i64, ptr %current, align 8
  %arrayidx38 = getelementptr [64 x ptr], ptr %blocks, i64 0, i64 %48
  %49 = load ptr, ptr %arrayidx38, align 8
  store ptr %49, ptr %block, align 8
  %50 = load ptr, ptr %block, align 8
  %51 = load i64, ptr %bsize.addr, align 8
  %add.ptr = getelementptr i8, ptr %50, i64 %51
  %52 = load i64, ptr %current, align 8
  %arrayidx39 = getelementptr [64 x ptr], ptr %blocks, i64 0, i64 %52
  store ptr %add.ptr, ptr %arrayidx39, align 8
  %53 = load ptr, ptr %page.addr, align 8
  %54 = load ptr, ptr %block, align 8
  %55 = load i64, ptr %next, align 8
  %arrayidx40 = getelementptr [64 x ptr], ptr %blocks, i64 0, i64 %55
  %56 = load ptr, ptr %arrayidx40, align 8
  call void @mi_block_set_next(ptr noundef %53, ptr noundef %54, ptr noundef %56)
  %57 = load i64, ptr %next, align 8
  store i64 %57, ptr %current, align 8
  br label %for.inc41

for.inc41:                                        ; preds = %while.end35
  %58 = load i64, ptr %i13, align 8
  %inc42 = add i64 %58, 1
  store i64 %inc42, ptr %i13, align 8
  br label %for.cond14, !llvm.loop !123

for.end43:                                        ; preds = %for.cond14
  %59 = load ptr, ptr %page.addr, align 8
  %60 = load i64, ptr %current, align 8
  %arrayidx44 = getelementptr [64 x ptr], ptr %blocks, i64 0, i64 %60
  %61 = load ptr, ptr %arrayidx44, align 8
  %62 = load ptr, ptr %page.addr, align 8
  %free = getelementptr inbounds %struct.mi_page_s, ptr %62, i32 0, i32 7
  %63 = load ptr, ptr %free, align 8
  call void @mi_block_set_next(ptr noundef %59, ptr noundef %61, ptr noundef %63)
  %64 = load ptr, ptr %free_start, align 8
  %65 = load ptr, ptr %page.addr, align 8
  %free45 = getelementptr inbounds %struct.mi_page_s, ptr %65, i32 0, i32 7
  store ptr %64, ptr %free45, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_page_block_at(ptr noundef %page, ptr noundef %page_start, i64 noundef %block_size, i64 noundef %i) #0 {
entry:
  %page.addr = alloca ptr, align 8
  %page_start.addr = alloca ptr, align 8
  %block_size.addr = alloca i64, align 8
  %i.addr = alloca i64, align 8
  store ptr %page, ptr %page.addr, align 8
  store ptr %page_start, ptr %page_start.addr, align 8
  store i64 %block_size, ptr %block_size.addr, align 8
  store i64 %i, ptr %i.addr, align 8
  %0 = load ptr, ptr %page_start.addr, align 8
  %1 = load i64, ptr %i.addr, align 8
  %2 = load i64, ptr %block_size.addr, align 8
  %mul = mul i64 %1, %2
  %add.ptr = getelementptr i8, ptr %0, i64 %mul
  ret ptr %add.ptr
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_page_immediate_available(ptr noundef %page) #0 {
entry:
  %page.addr = alloca ptr, align 8
  store ptr %page, ptr %page.addr, align 8
  %0 = load ptr, ptr %page.addr, align 8
  %free = getelementptr inbounds %struct.mi_page_s, ptr %0, i32 0, i32 7
  %1 = load ptr, ptr %free, align 8
  %cmp = icmp ne ptr %1, null
  ret i1 %cmp
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_page_queue_find_free_ex(ptr noundef %heap, ptr noundef %pq, i1 noundef zeroext %first_try) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %pq.addr = alloca ptr, align 8
  %first_try.addr = alloca i8, align 1
  %page = alloca ptr, align 8
  %next = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store ptr %pq, ptr %pq.addr, align 8
  %frombool = zext i1 %first_try to i8
  store i8 %frombool, ptr %first_try.addr, align 1
  %0 = load ptr, ptr %pq.addr, align 8
  %first = getelementptr inbounds %struct.mi_page_queue_s, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %first, align 8
  store ptr %1, ptr %page, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end6, %entry
  %2 = load ptr, ptr %page, align 8
  %cmp = icmp ne ptr %2, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load ptr, ptr %page, align 8
  %next1 = getelementptr inbounds %struct.mi_page_s, ptr %3, i32 0, i32 13
  %4 = load ptr, ptr %next1, align 8
  store ptr %4, ptr %next, align 8
  %5 = load ptr, ptr %page, align 8
  call void @_mi_page_free_collect(ptr noundef %5, i1 noundef zeroext false)
  %6 = load ptr, ptr %page, align 8
  %call = call zeroext i1 @mi_page_immediate_available(ptr noundef %6)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  br label %while.end

if.end:                                           ; preds = %while.body
  %7 = load ptr, ptr %page, align 8
  %capacity = getelementptr inbounds %struct.mi_page_s, ptr %7, i32 0, i32 3
  %8 = load i16, ptr %capacity, align 2
  %conv = zext i16 %8 to i32
  %9 = load ptr, ptr %page, align 8
  %reserved = getelementptr inbounds %struct.mi_page_s, ptr %9, i32 0, i32 4
  %10 = load i16, ptr %reserved, align 4
  %conv2 = zext i16 %10 to i32
  %cmp3 = icmp slt i32 %conv, %conv2
  br i1 %cmp3, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end
  %11 = load ptr, ptr %heap.addr, align 8
  %12 = load ptr, ptr %page, align 8
  %13 = load ptr, ptr %heap.addr, align 8
  %tld = getelementptr inbounds %struct.mi_heap_s, ptr %13, i32 0, i32 0
  %14 = load ptr, ptr %tld, align 8
  call void @mi_page_extend_free(ptr noundef %11, ptr noundef %12, ptr noundef %14)
  br label %while.end

if.end6:                                          ; preds = %if.end
  %15 = load ptr, ptr %page, align 8
  %16 = load ptr, ptr %pq.addr, align 8
  call void @mi_page_to_full(ptr noundef %15, ptr noundef %16)
  %17 = load ptr, ptr %next, align 8
  store ptr %17, ptr %page, align 8
  br label %while.cond, !llvm.loop !124

while.end:                                        ; preds = %if.then5, %if.then, %while.cond
  %18 = load ptr, ptr %page, align 8
  %cmp7 = icmp eq ptr %18, null
  br i1 %cmp7, label %if.then9, label %if.else

if.then9:                                         ; preds = %while.end
  %19 = load ptr, ptr %heap.addr, align 8
  call void @_mi_heap_collect_retired(ptr noundef %19, i1 noundef zeroext false)
  %20 = load ptr, ptr %heap.addr, align 8
  %21 = load ptr, ptr %pq.addr, align 8
  %call10 = call ptr @mi_page_fresh(ptr noundef %20, ptr noundef %21)
  store ptr %call10, ptr %page, align 8
  %22 = load ptr, ptr %page, align 8
  %cmp11 = icmp eq ptr %22, null
  br i1 %cmp11, label %land.lhs.true, label %if.end16

land.lhs.true:                                    ; preds = %if.then9
  %23 = load i8, ptr %first_try.addr, align 1
  %tobool = trunc i8 %23 to i1
  br i1 %tobool, label %if.then14, label %if.end16

if.then14:                                        ; preds = %land.lhs.true
  %24 = load ptr, ptr %heap.addr, align 8
  %25 = load ptr, ptr %pq.addr, align 8
  %call15 = call ptr @mi_page_queue_find_free_ex(ptr noundef %24, ptr noundef %25, i1 noundef zeroext false)
  store ptr %call15, ptr %page, align 8
  br label %if.end16

if.end16:                                         ; preds = %if.then14, %land.lhs.true, %if.then9
  br label %if.end17

if.else:                                          ; preds = %while.end
  %26 = load ptr, ptr %page, align 8
  %retire_expire = getelementptr inbounds %struct.mi_page_s, ptr %26, i32 0, i32 6
  %bf.load = load i8, ptr %retire_expire, align 1
  %bf.clear = and i8 %bf.load, 1
  %bf.set = or i8 %bf.clear, 0
  store i8 %bf.set, ptr %retire_expire, align 1
  br label %if.end17

if.end17:                                         ; preds = %if.else, %if.end16
  %27 = load ptr, ptr %page, align 8
  ret ptr %27
}

; Function Attrs: nounwind uwtable
define internal void @mi_page_to_full(ptr noundef %page, ptr noundef %pq) #0 {
entry:
  %page.addr = alloca ptr, align 8
  %pq.addr = alloca ptr, align 8
  store ptr %page, ptr %page.addr, align 8
  store ptr %pq, ptr %pq.addr, align 8
  %0 = load ptr, ptr %page.addr, align 8
  %call = call zeroext i1 @mi_page_is_in_full(ptr noundef %0)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %page.addr, align 8
  %call1 = call ptr @mi_page_heap(ptr noundef %1)
  %pages = getelementptr inbounds %struct.mi_heap_s, ptr %call1, i32 0, i32 2
  %arrayidx = getelementptr [75 x %struct.mi_page_queue_s], ptr %pages, i64 0, i64 74
  %2 = load ptr, ptr %pq.addr, align 8
  %3 = load ptr, ptr %page.addr, align 8
  call void @mi_page_queue_enqueue_from(ptr noundef %arrayidx, ptr noundef %2, ptr noundef %3)
  %4 = load ptr, ptr %page.addr, align 8
  call void @_mi_page_free_collect(ptr noundef %4, i1 noundef zeroext false)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_page_fresh(ptr noundef %heap, ptr noundef %pq) #0 {
entry:
  %retval = alloca ptr, align 8
  %heap.addr = alloca ptr, align 8
  %pq.addr = alloca ptr, align 8
  %page = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store ptr %pq, ptr %pq.addr, align 8
  %0 = load ptr, ptr %heap.addr, align 8
  %1 = load ptr, ptr %pq.addr, align 8
  %2 = load ptr, ptr %pq.addr, align 8
  %block_size = getelementptr inbounds %struct.mi_page_queue_s, ptr %2, i32 0, i32 2
  %3 = load i64, ptr %block_size, align 8
  %call = call ptr @mi_page_fresh_alloc(ptr noundef %0, ptr noundef %1, i64 noundef %3, i64 noundef 0)
  store ptr %call, ptr %page, align 8
  %4 = load ptr, ptr %page, align 8
  %cmp = icmp eq ptr %4, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %5 = load ptr, ptr %page, align 8
  store ptr %5, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load ptr, ptr %retval, align 8
  ret ptr %6
}

; Function Attrs: nounwind uwtable
define internal void @chacha_block(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %x = alloca [16 x i32], align 16
  %i = alloca i64, align 8
  %i2 = alloca i64, align 8
  %i15 = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8
  %cmp = icmp ult i64 %0, 16
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load ptr, ptr %ctx.addr, align 8
  %input = getelementptr inbounds %struct.mi_random_cxt_s, ptr %1, i32 0, i32 0
  %2 = load i64, ptr %i, align 8
  %arrayidx = getelementptr [16 x i32], ptr %input, i64 0, i64 %2
  %3 = load i32, ptr %arrayidx, align 4
  %4 = load i64, ptr %i, align 8
  %arrayidx1 = getelementptr [16 x i32], ptr %x, i64 0, i64 %4
  store i32 %3, ptr %arrayidx1, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %5 = load i64, ptr %i, align 8
  %inc = add i64 %5, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !125

for.end:                                          ; preds = %for.cond
  store i64 0, ptr %i2, align 8
  br label %for.cond3

for.cond3:                                        ; preds = %for.inc13, %for.end
  %6 = load i64, ptr %i2, align 8
  %cmp4 = icmp ult i64 %6, 20
  br i1 %cmp4, label %for.body5, label %for.end14

for.body5:                                        ; preds = %for.cond3
  %arraydecay = getelementptr inbounds [16 x i32], ptr %x, i64 0, i64 0
  call void @qround(ptr noundef %arraydecay, i64 noundef 0, i64 noundef 4, i64 noundef 8, i64 noundef 12)
  %arraydecay6 = getelementptr inbounds [16 x i32], ptr %x, i64 0, i64 0
  call void @qround(ptr noundef %arraydecay6, i64 noundef 1, i64 noundef 5, i64 noundef 9, i64 noundef 13)
  %arraydecay7 = getelementptr inbounds [16 x i32], ptr %x, i64 0, i64 0
  call void @qround(ptr noundef %arraydecay7, i64 noundef 2, i64 noundef 6, i64 noundef 10, i64 noundef 14)
  %arraydecay8 = getelementptr inbounds [16 x i32], ptr %x, i64 0, i64 0
  call void @qround(ptr noundef %arraydecay8, i64 noundef 3, i64 noundef 7, i64 noundef 11, i64 noundef 15)
  %arraydecay9 = getelementptr inbounds [16 x i32], ptr %x, i64 0, i64 0
  call void @qround(ptr noundef %arraydecay9, i64 noundef 0, i64 noundef 5, i64 noundef 10, i64 noundef 15)
  %arraydecay10 = getelementptr inbounds [16 x i32], ptr %x, i64 0, i64 0
  call void @qround(ptr noundef %arraydecay10, i64 noundef 1, i64 noundef 6, i64 noundef 11, i64 noundef 12)
  %arraydecay11 = getelementptr inbounds [16 x i32], ptr %x, i64 0, i64 0
  call void @qround(ptr noundef %arraydecay11, i64 noundef 2, i64 noundef 7, i64 noundef 8, i64 noundef 13)
  %arraydecay12 = getelementptr inbounds [16 x i32], ptr %x, i64 0, i64 0
  call void @qround(ptr noundef %arraydecay12, i64 noundef 3, i64 noundef 4, i64 noundef 9, i64 noundef 14)
  br label %for.inc13

for.inc13:                                        ; preds = %for.body5
  %7 = load i64, ptr %i2, align 8
  %add = add i64 %7, 2
  store i64 %add, ptr %i2, align 8
  br label %for.cond3, !llvm.loop !126

for.end14:                                        ; preds = %for.cond3
  store i64 0, ptr %i15, align 8
  br label %for.cond16

for.cond16:                                       ; preds = %for.inc24, %for.end14
  %8 = load i64, ptr %i15, align 8
  %cmp17 = icmp ult i64 %8, 16
  br i1 %cmp17, label %for.body18, label %for.end26

for.body18:                                       ; preds = %for.cond16
  %9 = load i64, ptr %i15, align 8
  %arrayidx19 = getelementptr [16 x i32], ptr %x, i64 0, i64 %9
  %10 = load i32, ptr %arrayidx19, align 4
  %11 = load ptr, ptr %ctx.addr, align 8
  %input20 = getelementptr inbounds %struct.mi_random_cxt_s, ptr %11, i32 0, i32 0
  %12 = load i64, ptr %i15, align 8
  %arrayidx21 = getelementptr [16 x i32], ptr %input20, i64 0, i64 %12
  %13 = load i32, ptr %arrayidx21, align 4
  %add22 = add i32 %10, %13
  %14 = load ptr, ptr %ctx.addr, align 8
  %output = getelementptr inbounds %struct.mi_random_cxt_s, ptr %14, i32 0, i32 1
  %15 = load i64, ptr %i15, align 8
  %arrayidx23 = getelementptr [16 x i32], ptr %output, i64 0, i64 %15
  store i32 %add22, ptr %arrayidx23, align 4
  br label %for.inc24

for.inc24:                                        ; preds = %for.body18
  %16 = load i64, ptr %i15, align 8
  %inc25 = add i64 %16, 1
  store i64 %inc25, ptr %i15, align 8
  br label %for.cond16, !llvm.loop !127

for.end26:                                        ; preds = %for.cond16
  %17 = load ptr, ptr %ctx.addr, align 8
  %output_available = getelementptr inbounds %struct.mi_random_cxt_s, ptr %17, i32 0, i32 2
  store i32 16, ptr %output_available, align 4
  %18 = load ptr, ptr %ctx.addr, align 8
  %input27 = getelementptr inbounds %struct.mi_random_cxt_s, ptr %18, i32 0, i32 0
  %arrayidx28 = getelementptr [16 x i32], ptr %input27, i64 0, i64 12
  %19 = load i32, ptr %arrayidx28, align 4
  %add29 = add i32 %19, 1
  store i32 %add29, ptr %arrayidx28, align 4
  %20 = load ptr, ptr %ctx.addr, align 8
  %input30 = getelementptr inbounds %struct.mi_random_cxt_s, ptr %20, i32 0, i32 0
  %arrayidx31 = getelementptr [16 x i32], ptr %input30, i64 0, i64 12
  %21 = load i32, ptr %arrayidx31, align 4
  %cmp32 = icmp eq i32 %21, 0
  br i1 %cmp32, label %if.then, label %if.end43

if.then:                                          ; preds = %for.end26
  %22 = load ptr, ptr %ctx.addr, align 8
  %input33 = getelementptr inbounds %struct.mi_random_cxt_s, ptr %22, i32 0, i32 0
  %arrayidx34 = getelementptr [16 x i32], ptr %input33, i64 0, i64 13
  %23 = load i32, ptr %arrayidx34, align 4
  %add35 = add i32 %23, 1
  store i32 %add35, ptr %arrayidx34, align 4
  %24 = load ptr, ptr %ctx.addr, align 8
  %input36 = getelementptr inbounds %struct.mi_random_cxt_s, ptr %24, i32 0, i32 0
  %arrayidx37 = getelementptr [16 x i32], ptr %input36, i64 0, i64 13
  %25 = load i32, ptr %arrayidx37, align 4
  %cmp38 = icmp eq i32 %25, 0
  br i1 %cmp38, label %if.then39, label %if.end

if.then39:                                        ; preds = %if.then
  %26 = load ptr, ptr %ctx.addr, align 8
  %input40 = getelementptr inbounds %struct.mi_random_cxt_s, ptr %26, i32 0, i32 0
  %arrayidx41 = getelementptr [16 x i32], ptr %input40, i64 0, i64 14
  %27 = load i32, ptr %arrayidx41, align 4
  %add42 = add i32 %27, 1
  store i32 %add42, ptr %arrayidx41, align 4
  br label %if.end

if.end:                                           ; preds = %if.then39, %if.then
  br label %if.end43

if.end43:                                         ; preds = %if.end, %for.end26
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @qround(ptr noundef %x, i64 noundef %a, i64 noundef %b, i64 noundef %c, i64 noundef %d) #0 {
entry:
  %x.addr = alloca ptr, align 8
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %c.addr = alloca i64, align 8
  %d.addr = alloca i64, align 8
  store ptr %x, ptr %x.addr, align 8
  store i64 %a, ptr %a.addr, align 8
  store i64 %b, ptr %b.addr, align 8
  store i64 %c, ptr %c.addr, align 8
  store i64 %d, ptr %d.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  %1 = load i64, ptr %b.addr, align 8
  %arrayidx = getelementptr i32, ptr %0, i64 %1
  %2 = load i32, ptr %arrayidx, align 4
  %3 = load ptr, ptr %x.addr, align 8
  %4 = load i64, ptr %a.addr, align 8
  %arrayidx1 = getelementptr i32, ptr %3, i64 %4
  %5 = load i32, ptr %arrayidx1, align 4
  %add = add i32 %5, %2
  store i32 %add, ptr %arrayidx1, align 4
  %6 = load ptr, ptr %x.addr, align 8
  %7 = load i64, ptr %d.addr, align 8
  %arrayidx2 = getelementptr i32, ptr %6, i64 %7
  %8 = load i32, ptr %arrayidx2, align 4
  %9 = load ptr, ptr %x.addr, align 8
  %10 = load i64, ptr %a.addr, align 8
  %arrayidx3 = getelementptr i32, ptr %9, i64 %10
  %11 = load i32, ptr %arrayidx3, align 4
  %xor = xor i32 %8, %11
  %call = call i32 @rotl(i32 noundef %xor, i32 noundef 16)
  %12 = load ptr, ptr %x.addr, align 8
  %13 = load i64, ptr %d.addr, align 8
  %arrayidx4 = getelementptr i32, ptr %12, i64 %13
  store i32 %call, ptr %arrayidx4, align 4
  %14 = load ptr, ptr %x.addr, align 8
  %15 = load i64, ptr %d.addr, align 8
  %arrayidx5 = getelementptr i32, ptr %14, i64 %15
  %16 = load i32, ptr %arrayidx5, align 4
  %17 = load ptr, ptr %x.addr, align 8
  %18 = load i64, ptr %c.addr, align 8
  %arrayidx6 = getelementptr i32, ptr %17, i64 %18
  %19 = load i32, ptr %arrayidx6, align 4
  %add7 = add i32 %19, %16
  store i32 %add7, ptr %arrayidx6, align 4
  %20 = load ptr, ptr %x.addr, align 8
  %21 = load i64, ptr %b.addr, align 8
  %arrayidx8 = getelementptr i32, ptr %20, i64 %21
  %22 = load i32, ptr %arrayidx8, align 4
  %23 = load ptr, ptr %x.addr, align 8
  %24 = load i64, ptr %c.addr, align 8
  %arrayidx9 = getelementptr i32, ptr %23, i64 %24
  %25 = load i32, ptr %arrayidx9, align 4
  %xor10 = xor i32 %22, %25
  %call11 = call i32 @rotl(i32 noundef %xor10, i32 noundef 12)
  %26 = load ptr, ptr %x.addr, align 8
  %27 = load i64, ptr %b.addr, align 8
  %arrayidx12 = getelementptr i32, ptr %26, i64 %27
  store i32 %call11, ptr %arrayidx12, align 4
  %28 = load ptr, ptr %x.addr, align 8
  %29 = load i64, ptr %b.addr, align 8
  %arrayidx13 = getelementptr i32, ptr %28, i64 %29
  %30 = load i32, ptr %arrayidx13, align 4
  %31 = load ptr, ptr %x.addr, align 8
  %32 = load i64, ptr %a.addr, align 8
  %arrayidx14 = getelementptr i32, ptr %31, i64 %32
  %33 = load i32, ptr %arrayidx14, align 4
  %add15 = add i32 %33, %30
  store i32 %add15, ptr %arrayidx14, align 4
  %34 = load ptr, ptr %x.addr, align 8
  %35 = load i64, ptr %d.addr, align 8
  %arrayidx16 = getelementptr i32, ptr %34, i64 %35
  %36 = load i32, ptr %arrayidx16, align 4
  %37 = load ptr, ptr %x.addr, align 8
  %38 = load i64, ptr %a.addr, align 8
  %arrayidx17 = getelementptr i32, ptr %37, i64 %38
  %39 = load i32, ptr %arrayidx17, align 4
  %xor18 = xor i32 %36, %39
  %call19 = call i32 @rotl(i32 noundef %xor18, i32 noundef 8)
  %40 = load ptr, ptr %x.addr, align 8
  %41 = load i64, ptr %d.addr, align 8
  %arrayidx20 = getelementptr i32, ptr %40, i64 %41
  store i32 %call19, ptr %arrayidx20, align 4
  %42 = load ptr, ptr %x.addr, align 8
  %43 = load i64, ptr %d.addr, align 8
  %arrayidx21 = getelementptr i32, ptr %42, i64 %43
  %44 = load i32, ptr %arrayidx21, align 4
  %45 = load ptr, ptr %x.addr, align 8
  %46 = load i64, ptr %c.addr, align 8
  %arrayidx22 = getelementptr i32, ptr %45, i64 %46
  %47 = load i32, ptr %arrayidx22, align 4
  %add23 = add i32 %47, %44
  store i32 %add23, ptr %arrayidx22, align 4
  %48 = load ptr, ptr %x.addr, align 8
  %49 = load i64, ptr %b.addr, align 8
  %arrayidx24 = getelementptr i32, ptr %48, i64 %49
  %50 = load i32, ptr %arrayidx24, align 4
  %51 = load ptr, ptr %x.addr, align 8
  %52 = load i64, ptr %c.addr, align 8
  %arrayidx25 = getelementptr i32, ptr %51, i64 %52
  %53 = load i32, ptr %arrayidx25, align 4
  %xor26 = xor i32 %50, %53
  %call27 = call i32 @rotl(i32 noundef %xor26, i32 noundef 7)
  %54 = load ptr, ptr %x.addr, align 8
  %55 = load i64, ptr %b.addr, align 8
  %arrayidx28 = getelementptr i32, ptr %54, i64 %55
  store i32 %call27, ptr %arrayidx28, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @rotl(i32 noundef %x, i32 noundef %shift) #0 {
entry:
  %x.addr = alloca i32, align 4
  %shift.addr = alloca i32, align 4
  store i32 %x, ptr %x.addr, align 4
  store i32 %shift, ptr %shift.addr, align 4
  %0 = load i32, ptr %x.addr, align 4
  %1 = load i32, ptr %shift.addr, align 4
  %shl = shl i32 %0, %1
  %2 = load i32, ptr %x.addr, align 4
  %3 = load i32, ptr %shift.addr, align 4
  %sub = sub i32 32, %3
  %shr = lshr i32 %2, %sub
  %or = or i32 %shl, %shr
  ret i32 %or
}

; Function Attrs: nounwind uwtable
define internal void @chacha_init(ptr noundef %ctx, ptr noundef %key, i64 noundef %nonce) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %key.addr = alloca ptr, align 8
  %nonce.addr = alloca i64, align 8
  %i = alloca i64, align 8
  %sigma = alloca ptr, align 8
  %i1 = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %key, ptr %key.addr, align 8
  store i64 %nonce, ptr %nonce.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  call void @llvm.memset.p0.i64(ptr align 4 %0, i8 0, i64 136, i1 false)
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i64, ptr %i, align 8
  %cmp = icmp ult i64 %1, 4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  store ptr @.str.98, ptr %sigma, align 8
  %2 = load ptr, ptr %sigma, align 8
  %3 = load i64, ptr %i, align 8
  %call = call i32 @read32(ptr noundef %2, i64 noundef %3)
  %4 = load ptr, ptr %ctx.addr, align 8
  %input = getelementptr inbounds %struct.mi_random_cxt_s, ptr %4, i32 0, i32 0
  %5 = load i64, ptr %i, align 8
  %arrayidx = getelementptr [16 x i32], ptr %input, i64 0, i64 %5
  store i32 %call, ptr %arrayidx, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %6 = load i64, ptr %i, align 8
  %inc = add i64 %6, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !128

for.end:                                          ; preds = %for.cond
  store i64 0, ptr %i1, align 8
  br label %for.cond2

for.cond2:                                        ; preds = %for.inc8, %for.end
  %7 = load i64, ptr %i1, align 8
  %cmp3 = icmp ult i64 %7, 8
  br i1 %cmp3, label %for.body4, label %for.end10

for.body4:                                        ; preds = %for.cond2
  %8 = load ptr, ptr %key.addr, align 8
  %9 = load i64, ptr %i1, align 8
  %call5 = call i32 @read32(ptr noundef %8, i64 noundef %9)
  %10 = load ptr, ptr %ctx.addr, align 8
  %input6 = getelementptr inbounds %struct.mi_random_cxt_s, ptr %10, i32 0, i32 0
  %11 = load i64, ptr %i1, align 8
  %add = add i64 %11, 4
  %arrayidx7 = getelementptr [16 x i32], ptr %input6, i64 0, i64 %add
  store i32 %call5, ptr %arrayidx7, align 4
  br label %for.inc8

for.inc8:                                         ; preds = %for.body4
  %12 = load i64, ptr %i1, align 8
  %inc9 = add i64 %12, 1
  store i64 %inc9, ptr %i1, align 8
  br label %for.cond2, !llvm.loop !129

for.end10:                                        ; preds = %for.cond2
  %13 = load ptr, ptr %ctx.addr, align 8
  %input11 = getelementptr inbounds %struct.mi_random_cxt_s, ptr %13, i32 0, i32 0
  %arrayidx12 = getelementptr [16 x i32], ptr %input11, i64 0, i64 12
  store i32 0, ptr %arrayidx12, align 4
  %14 = load ptr, ptr %ctx.addr, align 8
  %input13 = getelementptr inbounds %struct.mi_random_cxt_s, ptr %14, i32 0, i32 0
  %arrayidx14 = getelementptr [16 x i32], ptr %input13, i64 0, i64 13
  store i32 0, ptr %arrayidx14, align 4
  %15 = load i64, ptr %nonce.addr, align 8
  %conv = trunc i64 %15 to i32
  %16 = load ptr, ptr %ctx.addr, align 8
  %input15 = getelementptr inbounds %struct.mi_random_cxt_s, ptr %16, i32 0, i32 0
  %arrayidx16 = getelementptr [16 x i32], ptr %input15, i64 0, i64 14
  store i32 %conv, ptr %arrayidx16, align 4
  %17 = load i64, ptr %nonce.addr, align 8
  %shr = lshr i64 %17, 32
  %conv17 = trunc i64 %shr to i32
  %18 = load ptr, ptr %ctx.addr, align 8
  %input18 = getelementptr inbounds %struct.mi_random_cxt_s, ptr %18, i32 0, i32 0
  %arrayidx19 = getelementptr [16 x i32], ptr %input18, i64 0, i64 15
  store i32 %conv17, ptr %arrayidx19, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @read32(ptr noundef %p, i64 noundef %idx32) #0 {
entry:
  %p.addr = alloca ptr, align 8
  %idx32.addr = alloca i64, align 8
  %i = alloca i64, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %idx32, ptr %idx32.addr, align 8
  %0 = load i64, ptr %idx32.addr, align 8
  %mul = mul i64 4, %0
  store i64 %mul, ptr %i, align 8
  %1 = load ptr, ptr %p.addr, align 8
  %2 = load i64, ptr %i, align 8
  %add = add i64 %2, 0
  %arrayidx = getelementptr i8, ptr %1, i64 %add
  %3 = load i8, ptr %arrayidx, align 1
  %conv = zext i8 %3 to i32
  %4 = load ptr, ptr %p.addr, align 8
  %5 = load i64, ptr %i, align 8
  %add1 = add i64 %5, 1
  %arrayidx2 = getelementptr i8, ptr %4, i64 %add1
  %6 = load i8, ptr %arrayidx2, align 1
  %conv3 = zext i8 %6 to i32
  %shl = shl i32 %conv3, 8
  %or = or i32 %conv, %shl
  %7 = load ptr, ptr %p.addr, align 8
  %8 = load i64, ptr %i, align 8
  %add4 = add i64 %8, 2
  %arrayidx5 = getelementptr i8, ptr %7, i64 %add4
  %9 = load i8, ptr %arrayidx5, align 1
  %conv6 = zext i8 %9 to i32
  %shl7 = shl i32 %conv6, 16
  %or8 = or i32 %or, %shl7
  %10 = load ptr, ptr %p.addr, align 8
  %11 = load i64, ptr %i, align 8
  %add9 = add i64 %11, 3
  %arrayidx10 = getelementptr i8, ptr %10, i64 %add9
  %12 = load i8, ptr %arrayidx10, align 1
  %conv11 = zext i8 %12 to i32
  %shl12 = shl i32 %conv11, 24
  %or13 = or i32 %or8, %shl12
  ret i32 %or13
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_segment_span_free_coalesce(ptr noundef %slice, ptr noundef %tld) #0 {
entry:
  %retval = alloca ptr, align 8
  %slice.addr = alloca ptr, align 8
  %tld.addr = alloca ptr, align 8
  %segment = alloca ptr, align 8
  %is_abandoned = alloca i8, align 1
  %slice_count = alloca i64, align 8
  %next = alloca ptr, align 8
  %prev = alloca ptr, align 8
  store ptr %slice, ptr %slice.addr, align 8
  store ptr %tld, ptr %tld.addr, align 8
  %0 = load ptr, ptr %slice.addr, align 8
  %call = call ptr @_mi_ptr_segment(ptr noundef %0)
  store ptr %call, ptr %segment, align 8
  %1 = load ptr, ptr %segment, align 8
  %call1 = call zeroext i1 @mi_segment_is_abandoned(ptr noundef %1)
  %frombool = zext i1 %call1 to i8
  store i8 %frombool, ptr %is_abandoned, align 1
  %2 = load ptr, ptr %segment, align 8
  %kind = getelementptr inbounds %struct.mi_segment_s, ptr %2, i32 0, i32 15
  %3 = load i32, ptr %kind, align 8
  %cmp = icmp eq i32 %3, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr %slice.addr, align 8
  %xblock_size = getelementptr inbounds %struct.mi_page_s, ptr %4, i32 0, i32 9
  store i32 0, ptr %xblock_size, align 4
  %5 = load ptr, ptr %slice.addr, align 8
  store ptr %5, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %6 = load ptr, ptr %slice.addr, align 8
  %slice_count2 = getelementptr inbounds %struct.mi_page_s, ptr %6, i32 0, i32 0
  %7 = load i32, ptr %slice_count2, align 8
  %conv = zext i32 %7 to i64
  store i64 %conv, ptr %slice_count, align 8
  %8 = load ptr, ptr %slice.addr, align 8
  %9 = load ptr, ptr %slice.addr, align 8
  %slice_count3 = getelementptr inbounds %struct.mi_page_s, ptr %9, i32 0, i32 0
  %10 = load i32, ptr %slice_count3, align 8
  %idx.ext = zext i32 %10 to i64
  %add.ptr = getelementptr %struct.mi_page_s, ptr %8, i64 %idx.ext
  store ptr %add.ptr, ptr %next, align 8
  %11 = load ptr, ptr %next, align 8
  %12 = load ptr, ptr %segment, align 8
  %call4 = call ptr @mi_segment_slices_end(ptr noundef %12)
  %cmp5 = icmp ult ptr %11, %call4
  br i1 %cmp5, label %land.lhs.true, label %if.end15

land.lhs.true:                                    ; preds = %if.end
  %13 = load ptr, ptr %next, align 8
  %xblock_size7 = getelementptr inbounds %struct.mi_page_s, ptr %13, i32 0, i32 9
  %14 = load i32, ptr %xblock_size7, align 4
  %cmp8 = icmp eq i32 %14, 0
  br i1 %cmp8, label %if.then10, label %if.end15

if.then10:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %next, align 8
  %slice_count11 = getelementptr inbounds %struct.mi_page_s, ptr %15, i32 0, i32 0
  %16 = load i32, ptr %slice_count11, align 8
  %conv12 = zext i32 %16 to i64
  %17 = load i64, ptr %slice_count, align 8
  %add = add i64 %17, %conv12
  store i64 %add, ptr %slice_count, align 8
  %18 = load i8, ptr %is_abandoned, align 1
  %tobool = trunc i8 %18 to i1
  br i1 %tobool, label %if.end14, label %if.then13

if.then13:                                        ; preds = %if.then10
  %19 = load ptr, ptr %next, align 8
  %20 = load ptr, ptr %tld.addr, align 8
  call void @mi_segment_span_remove_from_queue(ptr noundef %19, ptr noundef %20)
  br label %if.end14

if.end14:                                         ; preds = %if.then13, %if.then10
  br label %if.end15

if.end15:                                         ; preds = %if.end14, %land.lhs.true, %if.end
  %21 = load ptr, ptr %slice.addr, align 8
  %22 = load ptr, ptr %segment, align 8
  %slices = getelementptr inbounds %struct.mi_segment_s, ptr %22, i32 0, i32 18
  %arraydecay = getelementptr inbounds [513 x %struct.mi_page_s], ptr %slices, i64 0, i64 0
  %cmp16 = icmp ugt ptr %21, %arraydecay
  br i1 %cmp16, label %if.then18, label %if.end32

if.then18:                                        ; preds = %if.end15
  %23 = load ptr, ptr %slice.addr, align 8
  %add.ptr19 = getelementptr %struct.mi_page_s, ptr %23, i64 -1
  %call20 = call ptr @mi_slice_first(ptr noundef %add.ptr19)
  store ptr %call20, ptr %prev, align 8
  %24 = load ptr, ptr %prev, align 8
  %xblock_size21 = getelementptr inbounds %struct.mi_page_s, ptr %24, i32 0, i32 9
  %25 = load i32, ptr %xblock_size21, align 4
  %cmp22 = icmp eq i32 %25, 0
  br i1 %cmp22, label %if.then24, label %if.end31

if.then24:                                        ; preds = %if.then18
  %26 = load ptr, ptr %prev, align 8
  %slice_count25 = getelementptr inbounds %struct.mi_page_s, ptr %26, i32 0, i32 0
  %27 = load i32, ptr %slice_count25, align 8
  %conv26 = zext i32 %27 to i64
  %28 = load i64, ptr %slice_count, align 8
  %add27 = add i64 %28, %conv26
  store i64 %add27, ptr %slice_count, align 8
  %29 = load i8, ptr %is_abandoned, align 1
  %tobool28 = trunc i8 %29 to i1
  br i1 %tobool28, label %if.end30, label %if.then29

if.then29:                                        ; preds = %if.then24
  %30 = load ptr, ptr %prev, align 8
  %31 = load ptr, ptr %tld.addr, align 8
  call void @mi_segment_span_remove_from_queue(ptr noundef %30, ptr noundef %31)
  br label %if.end30

if.end30:                                         ; preds = %if.then29, %if.then24
  %32 = load ptr, ptr %prev, align 8
  store ptr %32, ptr %slice.addr, align 8
  br label %if.end31

if.end31:                                         ; preds = %if.end30, %if.then18
  br label %if.end32

if.end32:                                         ; preds = %if.end31, %if.end15
  %33 = load ptr, ptr %segment, align 8
  %34 = load ptr, ptr %slice.addr, align 8
  %call33 = call i64 @mi_slice_index(ptr noundef %34)
  %35 = load i64, ptr %slice_count, align 8
  %36 = load ptr, ptr %tld.addr, align 8
  call void @mi_segment_span_free(ptr noundef %33, i64 noundef %call33, i64 noundef %35, i1 noundef zeroext true, ptr noundef %36)
  %37 = load ptr, ptr %slice.addr, align 8
  store ptr %37, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end32, %if.then
  %38 = load ptr, ptr %retval, align 8
  ret ptr %38
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_segment_is_abandoned(ptr noundef %segment) #0 {
entry:
  %segment.addr = alloca ptr, align 8
  store ptr %segment, ptr %segment.addr, align 8
  %0 = load ptr, ptr %segment.addr, align 8
  %thread_id = getelementptr inbounds %struct.mi_segment_s, ptr %0, i32 0, i32 17
  %atomic-load = load atomic i64, ptr %thread_id seq_cst, align 8
  %cmp = icmp eq i64 %atomic-load, 0
  ret i1 %cmp
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_segment_slices_end(ptr noundef %segment) #0 {
entry:
  %segment.addr = alloca ptr, align 8
  store ptr %segment, ptr %segment.addr, align 8
  %0 = load ptr, ptr %segment.addr, align 8
  %slices = getelementptr inbounds %struct.mi_segment_s, ptr %0, i32 0, i32 18
  %1 = load ptr, ptr %segment.addr, align 8
  %slice_entries = getelementptr inbounds %struct.mi_segment_s, ptr %1, i32 0, i32 16
  %2 = load i64, ptr %slice_entries, align 8
  %arrayidx = getelementptr [513 x %struct.mi_page_s], ptr %slices, i64 0, i64 %2
  ret ptr %arrayidx
}

; Function Attrs: nounwind uwtable
define internal void @mi_segment_span_remove_from_queue(ptr noundef %slice, ptr noundef %tld) #0 {
entry:
  %slice.addr = alloca ptr, align 8
  %tld.addr = alloca ptr, align 8
  %sq = alloca ptr, align 8
  store ptr %slice, ptr %slice.addr, align 8
  store ptr %tld, ptr %tld.addr, align 8
  %0 = load ptr, ptr %slice.addr, align 8
  %slice_count = getelementptr inbounds %struct.mi_page_s, ptr %0, i32 0, i32 0
  %1 = load i32, ptr %slice_count, align 8
  %conv = zext i32 %1 to i64
  %2 = load ptr, ptr %tld.addr, align 8
  %call = call ptr @mi_span_queue_for(i64 noundef %conv, ptr noundef %2)
  store ptr %call, ptr %sq, align 8
  %3 = load ptr, ptr %sq, align 8
  %4 = load ptr, ptr %slice.addr, align 8
  call void @mi_span_queue_delete(ptr noundef %3, ptr noundef %4)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_segment_span_free(ptr noundef %segment, i64 noundef %slice_index, i64 noundef %slice_count, i1 noundef zeroext %allow_purge, ptr noundef %tld) #0 {
entry:
  %segment.addr = alloca ptr, align 8
  %slice_index.addr = alloca i64, align 8
  %slice_count.addr = alloca i64, align 8
  %allow_purge.addr = alloca i8, align 1
  %tld.addr = alloca ptr, align 8
  %sq = alloca ptr, align 8
  %slice = alloca ptr, align 8
  %last = alloca ptr, align 8
  store ptr %segment, ptr %segment.addr, align 8
  store i64 %slice_index, ptr %slice_index.addr, align 8
  store i64 %slice_count, ptr %slice_count.addr, align 8
  %frombool = zext i1 %allow_purge to i8
  store i8 %frombool, ptr %allow_purge.addr, align 1
  store ptr %tld, ptr %tld.addr, align 8
  %0 = load ptr, ptr %segment.addr, align 8
  %kind = getelementptr inbounds %struct.mi_segment_s, ptr %0, i32 0, i32 15
  %1 = load i32, ptr %kind, align 8
  %cmp = icmp eq i32 %1, 1
  br i1 %cmp, label %cond.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load ptr, ptr %segment.addr, align 8
  %call = call zeroext i1 @mi_segment_is_abandoned(ptr noundef %2)
  br i1 %call, label %cond.true, label %cond.false

cond.true:                                        ; preds = %lor.lhs.false, %entry
  br label %cond.end

cond.false:                                       ; preds = %lor.lhs.false
  %3 = load i64, ptr %slice_count.addr, align 8
  %4 = load ptr, ptr %tld.addr, align 8
  %call1 = call ptr @mi_span_queue_for(i64 noundef %3, ptr noundef %4)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ null, %cond.true ], [ %call1, %cond.false ]
  store ptr %cond, ptr %sq, align 8
  %5 = load i64, ptr %slice_count.addr, align 8
  %cmp2 = icmp eq i64 %5, 0
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  store i64 1, ptr %slice_count.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end
  %6 = load ptr, ptr %segment.addr, align 8
  %slices = getelementptr inbounds %struct.mi_segment_s, ptr %6, i32 0, i32 18
  %7 = load i64, ptr %slice_index.addr, align 8
  %arrayidx = getelementptr [513 x %struct.mi_page_s], ptr %slices, i64 0, i64 %7
  store ptr %arrayidx, ptr %slice, align 8
  %8 = load i64, ptr %slice_count.addr, align 8
  %conv = trunc i64 %8 to i32
  %9 = load ptr, ptr %slice, align 8
  %slice_count3 = getelementptr inbounds %struct.mi_page_s, ptr %9, i32 0, i32 0
  store i32 %conv, ptr %slice_count3, align 8
  %10 = load ptr, ptr %slice, align 8
  %slice_offset = getelementptr inbounds %struct.mi_page_s, ptr %10, i32 0, i32 1
  store i32 0, ptr %slice_offset, align 4
  %11 = load i64, ptr %slice_count.addr, align 8
  %cmp4 = icmp ugt i64 %11, 1
  br i1 %cmp4, label %if.then6, label %if.end13

if.then6:                                         ; preds = %if.end
  %12 = load ptr, ptr %segment.addr, align 8
  %slices7 = getelementptr inbounds %struct.mi_segment_s, ptr %12, i32 0, i32 18
  %13 = load i64, ptr %slice_index.addr, align 8
  %14 = load i64, ptr %slice_count.addr, align 8
  %add = add i64 %13, %14
  %sub = sub i64 %add, 1
  %arrayidx8 = getelementptr [513 x %struct.mi_page_s], ptr %slices7, i64 0, i64 %sub
  store ptr %arrayidx8, ptr %last, align 8
  %15 = load ptr, ptr %last, align 8
  %slice_count9 = getelementptr inbounds %struct.mi_page_s, ptr %15, i32 0, i32 0
  store i32 0, ptr %slice_count9, align 8
  %16 = load i64, ptr %slice_count.addr, align 8
  %sub10 = sub i64 %16, 1
  %mul = mul i64 80, %sub10
  %conv11 = trunc i64 %mul to i32
  %17 = load ptr, ptr %last, align 8
  %slice_offset12 = getelementptr inbounds %struct.mi_page_s, ptr %17, i32 0, i32 1
  store i32 %conv11, ptr %slice_offset12, align 4
  %18 = load ptr, ptr %last, align 8
  %xblock_size = getelementptr inbounds %struct.mi_page_s, ptr %18, i32 0, i32 9
  store i32 0, ptr %xblock_size, align 4
  br label %if.end13

if.end13:                                         ; preds = %if.then6, %if.end
  %19 = load i8, ptr %allow_purge.addr, align 1
  %tobool = trunc i8 %19 to i1
  br i1 %tobool, label %if.then14, label %if.end17

if.then14:                                        ; preds = %if.end13
  %20 = load ptr, ptr %segment.addr, align 8
  %21 = load ptr, ptr %slice, align 8
  %call15 = call ptr @mi_slice_start(ptr noundef %21)
  %22 = load i64, ptr %slice_count.addr, align 8
  %mul16 = mul i64 %22, 65536
  %23 = load ptr, ptr %tld.addr, align 8
  %stats = getelementptr inbounds %struct.mi_segments_tld_s, ptr %23, i32 0, i32 5
  %24 = load ptr, ptr %stats, align 8
  call void @mi_segment_schedule_purge(ptr noundef %20, ptr noundef %call15, i64 noundef %mul16, ptr noundef %24)
  br label %if.end17

if.end17:                                         ; preds = %if.then14, %if.end13
  %25 = load ptr, ptr %sq, align 8
  %cmp18 = icmp ne ptr %25, null
  br i1 %cmp18, label %if.then20, label %if.else

if.then20:                                        ; preds = %if.end17
  %26 = load ptr, ptr %sq, align 8
  %27 = load ptr, ptr %slice, align 8
  call void @mi_span_queue_push(ptr noundef %26, ptr noundef %27)
  br label %if.end22

if.else:                                          ; preds = %if.end17
  %28 = load ptr, ptr %slice, align 8
  %xblock_size21 = getelementptr inbounds %struct.mi_page_s, ptr %28, i32 0, i32 9
  store i32 0, ptr %xblock_size21, align 4
  br label %if.end22

if.end22:                                         ; preds = %if.else, %if.then20
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @mi_slice_index(ptr noundef %slice) #0 {
entry:
  %slice.addr = alloca ptr, align 8
  %segment = alloca ptr, align 8
  %index = alloca i64, align 8
  store ptr %slice, ptr %slice.addr, align 8
  %0 = load ptr, ptr %slice.addr, align 8
  %call = call ptr @_mi_ptr_segment(ptr noundef %0)
  store ptr %call, ptr %segment, align 8
  %1 = load ptr, ptr %slice.addr, align 8
  %2 = load ptr, ptr %segment, align 8
  %slices = getelementptr inbounds %struct.mi_segment_s, ptr %2, i32 0, i32 18
  %arraydecay = getelementptr inbounds [513 x %struct.mi_page_s], ptr %slices, i64 0, i64 0
  %sub.ptr.lhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %arraydecay to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 80
  store i64 %sub.ptr.div, ptr %index, align 8
  %3 = load i64, ptr %index, align 8
  ret i64 %3
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_span_queue_for(i64 noundef %slice_count, ptr noundef %tld) #0 {
entry:
  %slice_count.addr = alloca i64, align 8
  %tld.addr = alloca ptr, align 8
  %bin = alloca i64, align 8
  %sq = alloca ptr, align 8
  store i64 %slice_count, ptr %slice_count.addr, align 8
  store ptr %tld, ptr %tld.addr, align 8
  %0 = load i64, ptr %slice_count.addr, align 8
  %call = call i64 @mi_slice_bin(i64 noundef %0)
  store i64 %call, ptr %bin, align 8
  %1 = load ptr, ptr %tld.addr, align 8
  %spans = getelementptr inbounds %struct.mi_segments_tld_s, ptr %1, i32 0, i32 0
  %2 = load i64, ptr %bin, align 8
  %arrayidx = getelementptr [36 x %struct.mi_span_queue_s], ptr %spans, i64 0, i64 %2
  store ptr %arrayidx, ptr %sq, align 8
  %3 = load ptr, ptr %sq, align 8
  ret ptr %3
}

; Function Attrs: nounwind uwtable
define internal void @mi_span_queue_delete(ptr noundef %sq, ptr noundef %slice) #0 {
entry:
  %sq.addr = alloca ptr, align 8
  %slice.addr = alloca ptr, align 8
  store ptr %sq, ptr %sq.addr, align 8
  store ptr %slice, ptr %slice.addr, align 8
  %0 = load ptr, ptr %slice.addr, align 8
  %prev = getelementptr inbounds %struct.mi_page_s, ptr %0, i32 0, i32 14
  %1 = load ptr, ptr %prev, align 8
  %cmp = icmp ne ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %slice.addr, align 8
  %next = getelementptr inbounds %struct.mi_page_s, ptr %2, i32 0, i32 13
  %3 = load ptr, ptr %next, align 8
  %4 = load ptr, ptr %slice.addr, align 8
  %prev1 = getelementptr inbounds %struct.mi_page_s, ptr %4, i32 0, i32 14
  %5 = load ptr, ptr %prev1, align 8
  %next2 = getelementptr inbounds %struct.mi_page_s, ptr %5, i32 0, i32 13
  store ptr %3, ptr %next2, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load ptr, ptr %slice.addr, align 8
  %7 = load ptr, ptr %sq.addr, align 8
  %first = getelementptr inbounds %struct.mi_span_queue_s, ptr %7, i32 0, i32 0
  %8 = load ptr, ptr %first, align 8
  %cmp3 = icmp eq ptr %6, %8
  br i1 %cmp3, label %if.then4, label %if.end7

if.then4:                                         ; preds = %if.end
  %9 = load ptr, ptr %slice.addr, align 8
  %next5 = getelementptr inbounds %struct.mi_page_s, ptr %9, i32 0, i32 13
  %10 = load ptr, ptr %next5, align 8
  %11 = load ptr, ptr %sq.addr, align 8
  %first6 = getelementptr inbounds %struct.mi_span_queue_s, ptr %11, i32 0, i32 0
  store ptr %10, ptr %first6, align 8
  br label %if.end7

if.end7:                                          ; preds = %if.then4, %if.end
  %12 = load ptr, ptr %slice.addr, align 8
  %next8 = getelementptr inbounds %struct.mi_page_s, ptr %12, i32 0, i32 13
  %13 = load ptr, ptr %next8, align 8
  %cmp9 = icmp ne ptr %13, null
  br i1 %cmp9, label %if.then10, label %if.end14

if.then10:                                        ; preds = %if.end7
  %14 = load ptr, ptr %slice.addr, align 8
  %prev11 = getelementptr inbounds %struct.mi_page_s, ptr %14, i32 0, i32 14
  %15 = load ptr, ptr %prev11, align 8
  %16 = load ptr, ptr %slice.addr, align 8
  %next12 = getelementptr inbounds %struct.mi_page_s, ptr %16, i32 0, i32 13
  %17 = load ptr, ptr %next12, align 8
  %prev13 = getelementptr inbounds %struct.mi_page_s, ptr %17, i32 0, i32 14
  store ptr %15, ptr %prev13, align 8
  br label %if.end14

if.end14:                                         ; preds = %if.then10, %if.end7
  %18 = load ptr, ptr %slice.addr, align 8
  %19 = load ptr, ptr %sq.addr, align 8
  %last = getelementptr inbounds %struct.mi_span_queue_s, ptr %19, i32 0, i32 1
  %20 = load ptr, ptr %last, align 8
  %cmp15 = icmp eq ptr %18, %20
  br i1 %cmp15, label %if.then16, label %if.end19

if.then16:                                        ; preds = %if.end14
  %21 = load ptr, ptr %slice.addr, align 8
  %prev17 = getelementptr inbounds %struct.mi_page_s, ptr %21, i32 0, i32 14
  %22 = load ptr, ptr %prev17, align 8
  %23 = load ptr, ptr %sq.addr, align 8
  %last18 = getelementptr inbounds %struct.mi_span_queue_s, ptr %23, i32 0, i32 1
  store ptr %22, ptr %last18, align 8
  br label %if.end19

if.end19:                                         ; preds = %if.then16, %if.end14
  %24 = load ptr, ptr %slice.addr, align 8
  %prev20 = getelementptr inbounds %struct.mi_page_s, ptr %24, i32 0, i32 14
  store ptr null, ptr %prev20, align 8
  %25 = load ptr, ptr %slice.addr, align 8
  %next21 = getelementptr inbounds %struct.mi_page_s, ptr %25, i32 0, i32 13
  store ptr null, ptr %next21, align 8
  %26 = load ptr, ptr %slice.addr, align 8
  %xblock_size = getelementptr inbounds %struct.mi_page_s, ptr %26, i32 0, i32 9
  store i32 1, ptr %xblock_size, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @mi_slice_bin(i64 noundef %slice_count) #0 {
entry:
  %slice_count.addr = alloca i64, align 8
  %bin = alloca i64, align 8
  store i64 %slice_count, ptr %slice_count.addr, align 8
  %0 = load i64, ptr %slice_count.addr, align 8
  %call = call i64 @mi_slice_bin8(i64 noundef %0)
  store i64 %call, ptr %bin, align 8
  %1 = load i64, ptr %bin, align 8
  ret i64 %1
}

; Function Attrs: nounwind uwtable
define internal i64 @mi_slice_bin8(i64 noundef %slice_count) #0 {
entry:
  %retval = alloca i64, align 8
  %slice_count.addr = alloca i64, align 8
  %s = alloca i64, align 8
  %bin = alloca i64, align 8
  store i64 %slice_count, ptr %slice_count.addr, align 8
  %0 = load i64, ptr %slice_count.addr, align 8
  %cmp = icmp ule i64 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i64, ptr %slice_count.addr, align 8
  store i64 %1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i64, ptr %slice_count.addr, align 8
  %dec = add i64 %2, -1
  store i64 %dec, ptr %slice_count.addr, align 8
  %3 = load i64, ptr %slice_count.addr, align 8
  %call = call i64 @mi_bsr(i64 noundef %3)
  store i64 %call, ptr %s, align 8
  %4 = load i64, ptr %s, align 8
  %cmp1 = icmp ule i64 %4, 2
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %5 = load i64, ptr %slice_count.addr, align 8
  %add = add i64 %5, 1
  store i64 %add, ptr %retval, align 8
  br label %return

if.end3:                                          ; preds = %if.end
  %6 = load i64, ptr %s, align 8
  %shl = shl i64 %6, 2
  %7 = load i64, ptr %slice_count.addr, align 8
  %8 = load i64, ptr %s, align 8
  %sub = sub i64 %8, 2
  %shr = lshr i64 %7, %sub
  %and = and i64 %shr, 3
  %or = or i64 %shl, %and
  %sub4 = sub i64 %or, 4
  store i64 %sub4, ptr %bin, align 8
  %9 = load i64, ptr %bin, align 8
  store i64 %9, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end3, %if.then2, %if.then
  %10 = load i64, ptr %retval, align 8
  ret i64 %10
}

; Function Attrs: nounwind uwtable
define internal void @mi_segment_schedule_purge(ptr noundef %segment, ptr noundef %p, i64 noundef %size, ptr noundef %stats) #0 {
entry:
  %segment.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %stats.addr = alloca ptr, align 8
  %start = alloca ptr, align 8
  %full_size = alloca i64, align 8
  %mask = alloca %struct.mi_commit_mask_s, align 8
  %cmask = alloca %struct.mi_commit_mask_s, align 8
  %now = alloca i64, align 8
  store ptr %segment, ptr %segment.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store ptr %stats, ptr %stats.addr, align 8
  %0 = load ptr, ptr %segment.addr, align 8
  %allow_purge = getelementptr inbounds %struct.mi_segment_s, ptr %0, i32 0, i32 2
  %1 = load i8, ptr %allow_purge, align 1
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %if.end32

if.end:                                           ; preds = %entry
  %call = call i64 @mi_option_get(i32 noundef 15)
  %cmp = icmp eq i64 %call, 0
  br i1 %cmp, label %if.then1, label %if.else

if.then1:                                         ; preds = %if.end
  %2 = load ptr, ptr %segment.addr, align 8
  %3 = load ptr, ptr %p.addr, align 8
  %4 = load i64, ptr %size.addr, align 8
  %5 = load ptr, ptr %stats.addr, align 8
  %call2 = call zeroext i1 @mi_segment_purge(ptr noundef %2, ptr noundef %3, i64 noundef %4, ptr noundef %5)
  br label %if.end32

if.else:                                          ; preds = %if.end
  store ptr null, ptr %start, align 8
  store i64 0, ptr %full_size, align 8
  %6 = load ptr, ptr %segment.addr, align 8
  %7 = load ptr, ptr %p.addr, align 8
  %8 = load i64, ptr %size.addr, align 8
  call void @mi_segment_commit_mask(ptr noundef %6, i1 noundef zeroext true, ptr noundef %7, i64 noundef %8, ptr noundef %start, ptr noundef %full_size, ptr noundef %mask)
  %call3 = call zeroext i1 @mi_commit_mask_is_empty(ptr noundef %mask)
  br i1 %call3, label %if.then5, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else
  %9 = load i64, ptr %full_size, align 8
  %cmp4 = icmp eq i64 %9, 0
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %lor.lhs.false, %if.else
  br label %if.end32

if.end6:                                          ; preds = %lor.lhs.false
  %10 = load ptr, ptr %segment.addr, align 8
  %commit_mask = getelementptr inbounds %struct.mi_segment_s, ptr %10, i32 0, i32 6
  call void @mi_commit_mask_create_intersect(ptr noundef %commit_mask, ptr noundef %mask, ptr noundef %cmask)
  %11 = load ptr, ptr %segment.addr, align 8
  %purge_mask = getelementptr inbounds %struct.mi_segment_s, ptr %11, i32 0, i32 5
  call void @mi_commit_mask_set(ptr noundef %purge_mask, ptr noundef %cmask)
  %call7 = call i64 @_mi_clock_now()
  store i64 %call7, ptr %now, align 8
  %12 = load ptr, ptr %segment.addr, align 8
  %purge_expire = getelementptr inbounds %struct.mi_segment_s, ptr %12, i32 0, i32 4
  %13 = load i64, ptr %purge_expire, align 8
  %cmp8 = icmp eq i64 %13, 0
  br i1 %cmp8, label %if.then9, label %if.else12

if.then9:                                         ; preds = %if.end6
  %14 = load i64, ptr %now, align 8
  %call10 = call i64 @mi_option_get(i32 noundef 15)
  %add = add i64 %14, %call10
  %15 = load ptr, ptr %segment.addr, align 8
  %purge_expire11 = getelementptr inbounds %struct.mi_segment_s, ptr %15, i32 0, i32 4
  store i64 %add, ptr %purge_expire11, align 8
  br label %if.end31

if.else12:                                        ; preds = %if.end6
  %16 = load ptr, ptr %segment.addr, align 8
  %purge_expire13 = getelementptr inbounds %struct.mi_segment_s, ptr %16, i32 0, i32 4
  %17 = load i64, ptr %purge_expire13, align 8
  %18 = load i64, ptr %now, align 8
  %cmp14 = icmp sle i64 %17, %18
  br i1 %cmp14, label %if.then15, label %if.else26

if.then15:                                        ; preds = %if.else12
  %19 = load ptr, ptr %segment.addr, align 8
  %purge_expire16 = getelementptr inbounds %struct.mi_segment_s, ptr %19, i32 0, i32 4
  %20 = load i64, ptr %purge_expire16, align 8
  %call17 = call i64 @mi_option_get(i32 noundef 25)
  %add18 = add i64 %20, %call17
  %21 = load i64, ptr %now, align 8
  %cmp19 = icmp sle i64 %add18, %21
  br i1 %cmp19, label %if.then20, label %if.else21

if.then20:                                        ; preds = %if.then15
  %22 = load ptr, ptr %segment.addr, align 8
  %23 = load ptr, ptr %stats.addr, align 8
  call void @mi_segment_try_purge(ptr noundef %22, i1 noundef zeroext true, ptr noundef %23)
  br label %if.end25

if.else21:                                        ; preds = %if.then15
  %24 = load i64, ptr %now, align 8
  %call22 = call i64 @mi_option_get(i32 noundef 25)
  %add23 = add i64 %24, %call22
  %25 = load ptr, ptr %segment.addr, align 8
  %purge_expire24 = getelementptr inbounds %struct.mi_segment_s, ptr %25, i32 0, i32 4
  store i64 %add23, ptr %purge_expire24, align 8
  br label %if.end25

if.end25:                                         ; preds = %if.else21, %if.then20
  br label %if.end30

if.else26:                                        ; preds = %if.else12
  %call27 = call i64 @mi_option_get(i32 noundef 25)
  %26 = load ptr, ptr %segment.addr, align 8
  %purge_expire28 = getelementptr inbounds %struct.mi_segment_s, ptr %26, i32 0, i32 4
  %27 = load i64, ptr %purge_expire28, align 8
  %add29 = add i64 %27, %call27
  store i64 %add29, ptr %purge_expire28, align 8
  br label %if.end30

if.end30:                                         ; preds = %if.else26, %if.end25
  br label %if.end31

if.end31:                                         ; preds = %if.end30, %if.then9
  br label %if.end32

if.end32:                                         ; preds = %if.end31, %if.then5, %if.then1, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_slice_start(ptr noundef %slice) #0 {
entry:
  %slice.addr = alloca ptr, align 8
  %segment = alloca ptr, align 8
  store ptr %slice, ptr %slice.addr, align 8
  %0 = load ptr, ptr %slice.addr, align 8
  %call = call ptr @_mi_ptr_segment(ptr noundef %0)
  store ptr %call, ptr %segment, align 8
  %1 = load ptr, ptr %segment, align 8
  %2 = load ptr, ptr %slice.addr, align 8
  %3 = load ptr, ptr %segment, align 8
  %slices = getelementptr inbounds %struct.mi_segment_s, ptr %3, i32 0, i32 18
  %arraydecay = getelementptr inbounds [513 x %struct.mi_page_s], ptr %slices, i64 0, i64 0
  %sub.ptr.lhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %arraydecay to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 80
  %mul = mul i64 %sub.ptr.div, 65536
  %add.ptr = getelementptr i8, ptr %1, i64 %mul
  ret ptr %add.ptr
}

; Function Attrs: nounwind uwtable
define internal void @mi_span_queue_push(ptr noundef %sq, ptr noundef %slice) #0 {
entry:
  %sq.addr = alloca ptr, align 8
  %slice.addr = alloca ptr, align 8
  store ptr %sq, ptr %sq.addr, align 8
  store ptr %slice, ptr %slice.addr, align 8
  %0 = load ptr, ptr %slice.addr, align 8
  %prev = getelementptr inbounds %struct.mi_page_s, ptr %0, i32 0, i32 14
  store ptr null, ptr %prev, align 8
  %1 = load ptr, ptr %sq.addr, align 8
  %first = getelementptr inbounds %struct.mi_span_queue_s, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %first, align 8
  %3 = load ptr, ptr %slice.addr, align 8
  %next = getelementptr inbounds %struct.mi_page_s, ptr %3, i32 0, i32 13
  store ptr %2, ptr %next, align 8
  %4 = load ptr, ptr %slice.addr, align 8
  %5 = load ptr, ptr %sq.addr, align 8
  %first1 = getelementptr inbounds %struct.mi_span_queue_s, ptr %5, i32 0, i32 0
  store ptr %4, ptr %first1, align 8
  %6 = load ptr, ptr %slice.addr, align 8
  %next2 = getelementptr inbounds %struct.mi_page_s, ptr %6, i32 0, i32 13
  %7 = load ptr, ptr %next2, align 8
  %cmp = icmp ne ptr %7, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %8 = load ptr, ptr %slice.addr, align 8
  %9 = load ptr, ptr %slice.addr, align 8
  %next3 = getelementptr inbounds %struct.mi_page_s, ptr %9, i32 0, i32 13
  %10 = load ptr, ptr %next3, align 8
  %prev4 = getelementptr inbounds %struct.mi_page_s, ptr %10, i32 0, i32 14
  store ptr %8, ptr %prev4, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %11 = load ptr, ptr %slice.addr, align 8
  %12 = load ptr, ptr %sq.addr, align 8
  %last = getelementptr inbounds %struct.mi_span_queue_s, ptr %12, i32 0, i32 1
  store ptr %11, ptr %last, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %13 = load ptr, ptr %slice.addr, align 8
  %xblock_size = getelementptr inbounds %struct.mi_page_s, ptr %13, i32 0, i32 9
  store i32 0, ptr %xblock_size, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_segment_purge(ptr noundef %segment, ptr noundef %p, i64 noundef %size, ptr noundef %stats) #0 {
entry:
  %retval = alloca i1, align 1
  %segment.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %stats.addr = alloca ptr, align 8
  %start = alloca ptr, align 8
  %full_size = alloca i64, align 8
  %mask = alloca %struct.mi_commit_mask_s, align 8
  %decommitted = alloca i8, align 1
  %cmask = alloca %struct.mi_commit_mask_s, align 8
  store ptr %segment, ptr %segment.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store ptr %stats, ptr %stats.addr, align 8
  %0 = load ptr, ptr %segment.addr, align 8
  %allow_purge = getelementptr inbounds %struct.mi_segment_s, ptr %0, i32 0, i32 2
  %1 = load i8, ptr %allow_purge, align 1
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  store ptr null, ptr %start, align 8
  store i64 0, ptr %full_size, align 8
  %2 = load ptr, ptr %segment.addr, align 8
  %3 = load ptr, ptr %p.addr, align 8
  %4 = load i64, ptr %size.addr, align 8
  call void @mi_segment_commit_mask(ptr noundef %2, i1 noundef zeroext true, ptr noundef %3, i64 noundef %4, ptr noundef %start, ptr noundef %full_size, ptr noundef %mask)
  %call = call zeroext i1 @mi_commit_mask_is_empty(ptr noundef %mask)
  br i1 %call, label %if.then1, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %5 = load i64, ptr %full_size, align 8
  %cmp = icmp eq i64 %5, 0
  br i1 %cmp, label %if.then1, label %if.end2

if.then1:                                         ; preds = %lor.lhs.false, %if.end
  store i1 true, ptr %retval, align 1
  br label %return

if.end2:                                          ; preds = %lor.lhs.false
  %6 = load ptr, ptr %segment.addr, align 8
  %commit_mask = getelementptr inbounds %struct.mi_segment_s, ptr %6, i32 0, i32 6
  %call3 = call zeroext i1 @mi_commit_mask_any_set(ptr noundef %commit_mask, ptr noundef %mask)
  br i1 %call3, label %if.then4, label %if.end12

if.then4:                                         ; preds = %if.end2
  %7 = load ptr, ptr %start, align 8
  %8 = load i64, ptr %full_size, align 8
  %9 = load ptr, ptr %stats.addr, align 8
  %call5 = call zeroext i1 @_mi_os_purge(ptr noundef %7, i64 noundef %8, ptr noundef %9)
  %frombool = zext i1 %call5 to i8
  store i8 %frombool, ptr %decommitted, align 1
  %10 = load i8, ptr %decommitted, align 1
  %tobool6 = trunc i8 %10 to i1
  br i1 %tobool6, label %if.then7, label %if.end11

if.then7:                                         ; preds = %if.then4
  %11 = load ptr, ptr %segment.addr, align 8
  %commit_mask8 = getelementptr inbounds %struct.mi_segment_s, ptr %11, i32 0, i32 6
  call void @mi_commit_mask_create_intersect(ptr noundef %commit_mask8, ptr noundef %mask, ptr noundef %cmask)
  %12 = load i64, ptr %full_size, align 8
  %call9 = call i64 @_mi_commit_mask_committed_size(ptr noundef %cmask, i64 noundef 33554432)
  %sub = sub i64 %12, %call9
  call void @_mi_stat_increase(ptr noundef getelementptr inbounds (%struct.mi_stats_s, ptr @_mi_stats_main, i32 0, i32 3), i64 noundef %sub)
  %13 = load ptr, ptr %segment.addr, align 8
  %commit_mask10 = getelementptr inbounds %struct.mi_segment_s, ptr %13, i32 0, i32 6
  call void @mi_commit_mask_clear(ptr noundef %commit_mask10, ptr noundef %mask)
  br label %if.end11

if.end11:                                         ; preds = %if.then7, %if.then4
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %if.end2
  %14 = load ptr, ptr %segment.addr, align 8
  %purge_mask = getelementptr inbounds %struct.mi_segment_s, ptr %14, i32 0, i32 5
  call void @mi_commit_mask_clear(ptr noundef %purge_mask, ptr noundef %mask)
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end12, %if.then1, %if.then
  %15 = load i1, ptr %retval, align 1
  ret i1 %15
}

; Function Attrs: nounwind uwtable
define internal void @mi_segment_commit_mask(ptr noundef %segment, i1 noundef zeroext %conservative, ptr noundef %p, i64 noundef %size, ptr noundef %start_p, ptr noundef %full_size, ptr noundef %cm) #0 {
entry:
  %segment.addr = alloca ptr, align 8
  %conservative.addr = alloca i8, align 1
  %p.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %start_p.addr = alloca ptr, align 8
  %full_size.addr = alloca ptr, align 8
  %cm.addr = alloca ptr, align 8
  %segstart = alloca i64, align 8
  %segsize = alloca i64, align 8
  %pstart = alloca i64, align 8
  %start = alloca i64, align 8
  %end = alloca i64, align 8
  %bitidx = alloca i64, align 8
  %bitcount = alloca i64, align 8
  store ptr %segment, ptr %segment.addr, align 8
  %frombool = zext i1 %conservative to i8
  store i8 %frombool, ptr %conservative.addr, align 1
  store ptr %p, ptr %p.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store ptr %start_p, ptr %start_p.addr, align 8
  store ptr %full_size, ptr %full_size.addr, align 8
  store ptr %cm, ptr %cm.addr, align 8
  %0 = load ptr, ptr %cm.addr, align 8
  call void @mi_commit_mask_create_empty(ptr noundef %0)
  %1 = load i64, ptr %size.addr, align 8
  %cmp = icmp eq i64 %1, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load i64, ptr %size.addr, align 8
  %cmp1 = icmp ugt i64 %2, 33554432
  br i1 %cmp1, label %if.then, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %3 = load ptr, ptr %segment.addr, align 8
  %kind = getelementptr inbounds %struct.mi_segment_s, ptr %3, i32 0, i32 15
  %4 = load i32, ptr %kind, align 8
  %cmp3 = icmp eq i32 %4, 1
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false2, %lor.lhs.false, %entry
  br label %return

if.end:                                           ; preds = %lor.lhs.false2
  %5 = load ptr, ptr %segment.addr, align 8
  %call = call i64 @mi_segment_info_size(ptr noundef %5)
  store i64 %call, ptr %segstart, align 8
  %6 = load ptr, ptr %segment.addr, align 8
  %call4 = call i64 @mi_segment_size(ptr noundef %6)
  store i64 %call4, ptr %segsize, align 8
  %7 = load ptr, ptr %p.addr, align 8
  %8 = load ptr, ptr %segment.addr, align 8
  %9 = load i64, ptr %segsize, align 8
  %add.ptr = getelementptr i8, ptr %8, i64 %9
  %cmp5 = icmp uge ptr %7, %add.ptr
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  br label %return

if.end7:                                          ; preds = %if.end
  %10 = load ptr, ptr %p.addr, align 8
  %11 = load ptr, ptr %segment.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %10 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %11 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, ptr %pstart, align 8
  %12 = load i8, ptr %conservative.addr, align 1
  %tobool = trunc i8 %12 to i1
  br i1 %tobool, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.end7
  %13 = load i64, ptr %pstart, align 8
  %call9 = call i64 @_mi_align_up(i64 noundef %13, i64 noundef 65536)
  store i64 %call9, ptr %start, align 8
  %14 = load i64, ptr %pstart, align 8
  %15 = load i64, ptr %size.addr, align 8
  %add = add i64 %14, %15
  %call10 = call i64 @_mi_align_down(i64 noundef %add, i64 noundef 65536)
  store i64 %call10, ptr %end, align 8
  br label %if.end14

if.else:                                          ; preds = %if.end7
  %16 = load i64, ptr %pstart, align 8
  %call11 = call i64 @_mi_align_down(i64 noundef %16, i64 noundef 65536)
  store i64 %call11, ptr %start, align 8
  %17 = load i64, ptr %pstart, align 8
  %18 = load i64, ptr %size.addr, align 8
  %add12 = add i64 %17, %18
  %call13 = call i64 @_mi_align_up(i64 noundef %add12, i64 noundef 65536)
  store i64 %call13, ptr %end, align 8
  br label %if.end14

if.end14:                                         ; preds = %if.else, %if.then8
  %19 = load i64, ptr %pstart, align 8
  %20 = load i64, ptr %segstart, align 8
  %cmp15 = icmp uge i64 %19, %20
  br i1 %cmp15, label %land.lhs.true, label %if.end18

land.lhs.true:                                    ; preds = %if.end14
  %21 = load i64, ptr %start, align 8
  %22 = load i64, ptr %segstart, align 8
  %cmp16 = icmp ult i64 %21, %22
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %land.lhs.true
  %23 = load i64, ptr %segstart, align 8
  store i64 %23, ptr %start, align 8
  br label %if.end18

if.end18:                                         ; preds = %if.then17, %land.lhs.true, %if.end14
  %24 = load i64, ptr %end, align 8
  %25 = load i64, ptr %segsize, align 8
  %cmp19 = icmp ugt i64 %24, %25
  br i1 %cmp19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %if.end18
  %26 = load i64, ptr %segsize, align 8
  store i64 %26, ptr %end, align 8
  br label %if.end21

if.end21:                                         ; preds = %if.then20, %if.end18
  %27 = load ptr, ptr %segment.addr, align 8
  %28 = load i64, ptr %start, align 8
  %add.ptr22 = getelementptr i8, ptr %27, i64 %28
  %29 = load ptr, ptr %start_p.addr, align 8
  store ptr %add.ptr22, ptr %29, align 8
  %30 = load i64, ptr %end, align 8
  %31 = load i64, ptr %start, align 8
  %cmp23 = icmp ugt i64 %30, %31
  br i1 %cmp23, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end21
  %32 = load i64, ptr %end, align 8
  %33 = load i64, ptr %start, align 8
  %sub = sub i64 %32, %33
  br label %cond.end

cond.false:                                       ; preds = %if.end21
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %sub, %cond.true ], [ 0, %cond.false ]
  %34 = load ptr, ptr %full_size.addr, align 8
  store i64 %cond, ptr %34, align 8
  %35 = load ptr, ptr %full_size.addr, align 8
  %36 = load i64, ptr %35, align 8
  %cmp24 = icmp eq i64 %36, 0
  br i1 %cmp24, label %if.then25, label %if.end26

if.then25:                                        ; preds = %cond.end
  br label %return

if.end26:                                         ; preds = %cond.end
  %37 = load i64, ptr %start, align 8
  %div = udiv i64 %37, 65536
  store i64 %div, ptr %bitidx, align 8
  %38 = load ptr, ptr %full_size.addr, align 8
  %39 = load i64, ptr %38, align 8
  %div27 = udiv i64 %39, 65536
  store i64 %div27, ptr %bitcount, align 8
  %40 = load i64, ptr %bitidx, align 8
  %41 = load i64, ptr %bitcount, align 8
  %add28 = add i64 %40, %41
  %cmp29 = icmp ugt i64 %add28, 512
  br i1 %cmp29, label %if.then30, label %if.end31

if.then30:                                        ; preds = %if.end26
  %42 = load i64, ptr %bitidx, align 8
  %43 = load i64, ptr %bitcount, align 8
  %44 = load i64, ptr %start, align 8
  %45 = load i64, ptr %end, align 8
  %46 = load ptr, ptr %p.addr, align 8
  %47 = load i64, ptr %size.addr, align 8
  %48 = load ptr, ptr %full_size.addr, align 8
  %49 = load i64, ptr %48, align 8
  call void (ptr, ...) @_mi_warning_message(ptr noundef @.str.99, i64 noundef %42, i64 noundef %43, i64 noundef %44, i64 noundef %45, ptr noundef %46, i64 noundef %47, i64 noundef %49)
  br label %if.end31

if.end31:                                         ; preds = %if.then30, %if.end26
  %50 = load i64, ptr %bitidx, align 8
  %51 = load i64, ptr %bitcount, align 8
  %52 = load ptr, ptr %cm.addr, align 8
  call void @mi_commit_mask_create(i64 noundef %50, i64 noundef %51, ptr noundef %52)
  br label %return

return:                                           ; preds = %if.end31, %if.then25, %if.then6, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_commit_mask_is_empty(ptr noundef %cm) #0 {
entry:
  %retval = alloca i1, align 1
  %cm.addr = alloca ptr, align 8
  %i = alloca i64, align 8
  store ptr %cm, ptr %cm.addr, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load ptr, ptr %cm.addr, align 8
  %mask = getelementptr inbounds %struct.mi_commit_mask_s, ptr %1, i32 0, i32 0
  %2 = load i64, ptr %i, align 8
  %arrayidx = getelementptr [8 x i64], ptr %mask, i64 0, i64 %2
  %3 = load i64, ptr %arrayidx, align 8
  %cmp1 = icmp ne i64 %3, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %4 = load i64, ptr %i, align 8
  %inc = add i64 %4, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !130

for.end:                                          ; preds = %for.cond
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %for.end, %if.then
  %5 = load i1, ptr %retval, align 1
  ret i1 %5
}

; Function Attrs: nounwind uwtable
define internal void @mi_commit_mask_create_intersect(ptr noundef %commit, ptr noundef %cm, ptr noundef %res) #0 {
entry:
  %commit.addr = alloca ptr, align 8
  %cm.addr = alloca ptr, align 8
  %res.addr = alloca ptr, align 8
  %i = alloca i64, align 8
  store ptr %commit, ptr %commit.addr, align 8
  store ptr %cm, ptr %cm.addr, align 8
  store ptr %res, ptr %res.addr, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load ptr, ptr %commit.addr, align 8
  %mask = getelementptr inbounds %struct.mi_commit_mask_s, ptr %1, i32 0, i32 0
  %2 = load i64, ptr %i, align 8
  %arrayidx = getelementptr [8 x i64], ptr %mask, i64 0, i64 %2
  %3 = load i64, ptr %arrayidx, align 8
  %4 = load ptr, ptr %cm.addr, align 8
  %mask1 = getelementptr inbounds %struct.mi_commit_mask_s, ptr %4, i32 0, i32 0
  %5 = load i64, ptr %i, align 8
  %arrayidx2 = getelementptr [8 x i64], ptr %mask1, i64 0, i64 %5
  %6 = load i64, ptr %arrayidx2, align 8
  %and = and i64 %3, %6
  %7 = load ptr, ptr %res.addr, align 8
  %mask3 = getelementptr inbounds %struct.mi_commit_mask_s, ptr %7, i32 0, i32 0
  %8 = load i64, ptr %i, align 8
  %arrayidx4 = getelementptr [8 x i64], ptr %mask3, i64 0, i64 %8
  store i64 %and, ptr %arrayidx4, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %9 = load i64, ptr %i, align 8
  %inc = add i64 %9, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !131

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_commit_mask_set(ptr noundef %res, ptr noundef %cm) #0 {
entry:
  %res.addr = alloca ptr, align 8
  %cm.addr = alloca ptr, align 8
  %i = alloca i64, align 8
  store ptr %res, ptr %res.addr, align 8
  store ptr %cm, ptr %cm.addr, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load ptr, ptr %cm.addr, align 8
  %mask = getelementptr inbounds %struct.mi_commit_mask_s, ptr %1, i32 0, i32 0
  %2 = load i64, ptr %i, align 8
  %arrayidx = getelementptr [8 x i64], ptr %mask, i64 0, i64 %2
  %3 = load i64, ptr %arrayidx, align 8
  %4 = load ptr, ptr %res.addr, align 8
  %mask1 = getelementptr inbounds %struct.mi_commit_mask_s, ptr %4, i32 0, i32 0
  %5 = load i64, ptr %i, align 8
  %arrayidx2 = getelementptr [8 x i64], ptr %mask1, i64 0, i64 %5
  %6 = load i64, ptr %arrayidx2, align 8
  %or = or i64 %6, %3
  store i64 %or, ptr %arrayidx2, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %7 = load i64, ptr %i, align 8
  %inc = add i64 %7, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !132

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_commit_mask_any_set(ptr noundef %commit, ptr noundef %cm) #0 {
entry:
  %retval = alloca i1, align 1
  %commit.addr = alloca ptr, align 8
  %cm.addr = alloca ptr, align 8
  %i = alloca i64, align 8
  store ptr %commit, ptr %commit.addr, align 8
  store ptr %cm, ptr %cm.addr, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load ptr, ptr %commit.addr, align 8
  %mask = getelementptr inbounds %struct.mi_commit_mask_s, ptr %1, i32 0, i32 0
  %2 = load i64, ptr %i, align 8
  %arrayidx = getelementptr [8 x i64], ptr %mask, i64 0, i64 %2
  %3 = load i64, ptr %arrayidx, align 8
  %4 = load ptr, ptr %cm.addr, align 8
  %mask1 = getelementptr inbounds %struct.mi_commit_mask_s, ptr %4, i32 0, i32 0
  %5 = load i64, ptr %i, align 8
  %arrayidx2 = getelementptr [8 x i64], ptr %mask1, i64 0, i64 %5
  %6 = load i64, ptr %arrayidx2, align 8
  %and = and i64 %3, %6
  %cmp3 = icmp ne i64 %and, 0
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  store i1 true, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %7 = load i64, ptr %i, align 8
  %inc = add i64 %7, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !133

for.end:                                          ; preds = %for.cond
  store i1 false, ptr %retval, align 1
  br label %return

return:                                           ; preds = %for.end, %if.then
  %8 = load i1, ptr %retval, align 1
  ret i1 %8
}

; Function Attrs: nounwind uwtable
define internal void @mi_commit_mask_clear(ptr noundef %res, ptr noundef %cm) #0 {
entry:
  %res.addr = alloca ptr, align 8
  %cm.addr = alloca ptr, align 8
  %i = alloca i64, align 8
  store ptr %res, ptr %res.addr, align 8
  store ptr %cm, ptr %cm.addr, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load ptr, ptr %cm.addr, align 8
  %mask = getelementptr inbounds %struct.mi_commit_mask_s, ptr %1, i32 0, i32 0
  %2 = load i64, ptr %i, align 8
  %arrayidx = getelementptr [8 x i64], ptr %mask, i64 0, i64 %2
  %3 = load i64, ptr %arrayidx, align 8
  %not = xor i64 %3, -1
  %4 = load ptr, ptr %res.addr, align 8
  %mask1 = getelementptr inbounds %struct.mi_commit_mask_s, ptr %4, i32 0, i32 0
  %5 = load i64, ptr %i, align 8
  %arrayidx2 = getelementptr [8 x i64], ptr %mask1, i64 0, i64 %5
  %6 = load i64, ptr %arrayidx2, align 8
  %and = and i64 %6, %not
  store i64 %and, ptr %arrayidx2, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %7 = load i64, ptr %i, align 8
  %inc = add i64 %7, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !134

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_commit_mask_create_empty(ptr noundef %cm) #0 {
entry:
  %cm.addr = alloca ptr, align 8
  %i = alloca i64, align 8
  store ptr %cm, ptr %cm.addr, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load ptr, ptr %cm.addr, align 8
  %mask = getelementptr inbounds %struct.mi_commit_mask_s, ptr %1, i32 0, i32 0
  %2 = load i64, ptr %i, align 8
  %arrayidx = getelementptr [8 x i64], ptr %mask, i64 0, i64 %2
  store i64 0, ptr %arrayidx, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %3 = load i64, ptr %i, align 8
  %inc = add i64 %3, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !135

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @mi_segment_info_size(ptr noundef %segment) #0 {
entry:
  %segment.addr = alloca ptr, align 8
  store ptr %segment, ptr %segment.addr, align 8
  %0 = load ptr, ptr %segment.addr, align 8
  %segment_info_slices = getelementptr inbounds %struct.mi_segment_s, ptr %0, i32 0, i32 14
  %1 = load i64, ptr %segment_info_slices, align 8
  %mul = mul i64 %1, 65536
  ret i64 %mul
}

; Function Attrs: nounwind uwtable
define internal i64 @mi_segment_size(ptr noundef %segment) #0 {
entry:
  %segment.addr = alloca ptr, align 8
  store ptr %segment, ptr %segment.addr, align 8
  %0 = load ptr, ptr %segment.addr, align 8
  %segment_slices = getelementptr inbounds %struct.mi_segment_s, ptr %0, i32 0, i32 13
  %1 = load i64, ptr %segment_slices, align 8
  %mul = mul i64 %1, 65536
  ret i64 %mul
}

; Function Attrs: nounwind uwtable
define internal void @mi_commit_mask_create(i64 noundef %bitidx, i64 noundef %bitcount, ptr noundef %cm) #0 {
entry:
  %bitidx.addr = alloca i64, align 8
  %bitcount.addr = alloca i64, align 8
  %cm.addr = alloca ptr, align 8
  %i = alloca i64, align 8
  %ofs = alloca i64, align 8
  %avail = alloca i64, align 8
  %count = alloca i64, align 8
  %mask = alloca i64, align 8
  store i64 %bitidx, ptr %bitidx.addr, align 8
  store i64 %bitcount, ptr %bitcount.addr, align 8
  store ptr %cm, ptr %cm.addr, align 8
  %0 = load i64, ptr %bitcount.addr, align 8
  %cmp = icmp eq i64 %0, 512
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %cm.addr, align 8
  call void @mi_commit_mask_create_full(ptr noundef %1)
  br label %if.end15

if.else:                                          ; preds = %entry
  %2 = load i64, ptr %bitcount.addr, align 8
  %cmp1 = icmp eq i64 %2, 0
  br i1 %cmp1, label %if.then2, label %if.else3

if.then2:                                         ; preds = %if.else
  %3 = load ptr, ptr %cm.addr, align 8
  call void @mi_commit_mask_create_empty(ptr noundef %3)
  br label %if.end

if.else3:                                         ; preds = %if.else
  %4 = load ptr, ptr %cm.addr, align 8
  call void @mi_commit_mask_create_empty(ptr noundef %4)
  %5 = load i64, ptr %bitidx.addr, align 8
  %div = udiv i64 %5, 64
  store i64 %div, ptr %i, align 8
  %6 = load i64, ptr %bitidx.addr, align 8
  %rem = urem i64 %6, 64
  store i64 %rem, ptr %ofs, align 8
  br label %while.cond

while.cond:                                       ; preds = %cond.end11, %if.else3
  %7 = load i64, ptr %bitcount.addr, align 8
  %cmp4 = icmp ugt i64 %7, 0
  br i1 %cmp4, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %8 = load i64, ptr %ofs, align 8
  %sub = sub i64 64, %8
  store i64 %sub, ptr %avail, align 8
  %9 = load i64, ptr %bitcount.addr, align 8
  %10 = load i64, ptr %avail, align 8
  %cmp5 = icmp ugt i64 %9, %10
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %while.body
  %11 = load i64, ptr %avail, align 8
  br label %cond.end

cond.false:                                       ; preds = %while.body
  %12 = load i64, ptr %bitcount.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %11, %cond.true ], [ %12, %cond.false ]
  store i64 %cond, ptr %count, align 8
  %13 = load i64, ptr %count, align 8
  %cmp6 = icmp uge i64 %13, 64
  br i1 %cmp6, label %cond.true7, label %cond.false8

cond.true7:                                       ; preds = %cond.end
  br label %cond.end11

cond.false8:                                      ; preds = %cond.end
  %14 = load i64, ptr %count, align 8
  %shl = shl i64 1, %14
  %sub9 = sub i64 %shl, 1
  %15 = load i64, ptr %ofs, align 8
  %shl10 = shl i64 %sub9, %15
  br label %cond.end11

cond.end11:                                       ; preds = %cond.false8, %cond.true7
  %cond12 = phi i64 [ -1, %cond.true7 ], [ %shl10, %cond.false8 ]
  store i64 %cond12, ptr %mask, align 8
  %16 = load i64, ptr %mask, align 8
  %17 = load ptr, ptr %cm.addr, align 8
  %mask13 = getelementptr inbounds %struct.mi_commit_mask_s, ptr %17, i32 0, i32 0
  %18 = load i64, ptr %i, align 8
  %arrayidx = getelementptr [8 x i64], ptr %mask13, i64 0, i64 %18
  store i64 %16, ptr %arrayidx, align 8
  %19 = load i64, ptr %count, align 8
  %20 = load i64, ptr %bitcount.addr, align 8
  %sub14 = sub i64 %20, %19
  store i64 %sub14, ptr %bitcount.addr, align 8
  store i64 0, ptr %ofs, align 8
  %21 = load i64, ptr %i, align 8
  %inc = add i64 %21, 1
  store i64 %inc, ptr %i, align 8
  br label %while.cond, !llvm.loop !136

while.end:                                        ; preds = %while.cond
  br label %if.end

if.end:                                           ; preds = %while.end, %if.then2
  br label %if.end15

if.end15:                                         ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_commit_mask_create_full(ptr noundef %cm) #0 {
entry:
  %cm.addr = alloca ptr, align 8
  %i = alloca i64, align 8
  store ptr %cm, ptr %cm.addr, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load ptr, ptr %cm.addr, align 8
  %mask = getelementptr inbounds %struct.mi_commit_mask_s, ptr %1, i32 0, i32 0
  %2 = load i64, ptr %i, align 8
  %arrayidx = getelementptr [8 x i64], ptr %mask, i64 0, i64 %2
  store i64 -1, ptr %arrayidx, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %3 = load i64, ptr %i, align 8
  %inc = add i64 %3, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !137

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_segment_os_free(ptr noundef %segment, ptr noundef %tld) #0 {
entry:
  %segment.addr = alloca ptr, align 8
  %tld.addr = alloca ptr, align 8
  %size = alloca i64, align 8
  %csize = alloca i64, align 8
  store ptr %segment, ptr %segment.addr, align 8
  store ptr %tld, ptr %tld.addr, align 8
  %0 = load ptr, ptr %segment.addr, align 8
  %thread_id = getelementptr inbounds %struct.mi_segment_s, ptr %0, i32 0, i32 17
  store atomic i64 0, ptr %thread_id seq_cst, align 8
  %1 = load ptr, ptr %segment.addr, align 8
  call void @_mi_segment_map_freed_at(ptr noundef %1)
  %2 = load ptr, ptr %segment.addr, align 8
  %call = call i64 @mi_segment_size(ptr noundef %2)
  %sub = sub i64 0, %call
  %3 = load ptr, ptr %tld.addr, align 8
  call void @mi_segments_track_size(i64 noundef %sub, ptr noundef %3)
  %4 = load ptr, ptr %segment.addr, align 8
  %call1 = call i64 @mi_segment_size(ptr noundef %4)
  store i64 %call1, ptr %size, align 8
  %5 = load ptr, ptr %segment.addr, align 8
  %commit_mask = getelementptr inbounds %struct.mi_segment_s, ptr %5, i32 0, i32 6
  %6 = load i64, ptr %size, align 8
  %call2 = call i64 @_mi_commit_mask_committed_size(ptr noundef %commit_mask, i64 noundef %6)
  store i64 %call2, ptr %csize, align 8
  call void @_mi_abandoned_await_readers()
  %7 = load ptr, ptr %segment.addr, align 8
  %8 = load ptr, ptr %segment.addr, align 8
  %call3 = call i64 @mi_segment_size(ptr noundef %8)
  %9 = load i64, ptr %csize, align 8
  %10 = load ptr, ptr %segment.addr, align 8
  %memid = getelementptr inbounds %struct.mi_segment_s, ptr %10, i32 0, i32 0
  %11 = load ptr, ptr %tld.addr, align 8
  %stats = getelementptr inbounds %struct.mi_segments_tld_s, ptr %11, i32 0, i32 5
  %12 = load ptr, ptr %stats, align 8
  call void @_mi_arena_free(ptr noundef %7, i64 noundef %call3, i64 noundef %9, ptr noundef byval(%struct.mi_memid_s) align 8 %memid, ptr noundef %12)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_segments_track_size(i64 noundef %segment_size, ptr noundef %tld) #0 {
entry:
  %segment_size.addr = alloca i64, align 8
  %tld.addr = alloca ptr, align 8
  store i64 %segment_size, ptr %segment_size.addr, align 8
  store ptr %tld, ptr %tld.addr, align 8
  %0 = load i64, ptr %segment_size.addr, align 8
  %cmp = icmp sge i64 %0, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %tld.addr, align 8
  %stats = getelementptr inbounds %struct.mi_segments_tld_s, ptr %1, i32 0, i32 5
  %2 = load ptr, ptr %stats, align 8
  %segments = getelementptr inbounds %struct.mi_stats_s, ptr %2, i32 0, i32 0
  call void @_mi_stat_increase(ptr noundef %segments, i64 noundef 1)
  br label %if.end

if.else:                                          ; preds = %entry
  %3 = load ptr, ptr %tld.addr, align 8
  %stats1 = getelementptr inbounds %struct.mi_segments_tld_s, ptr %3, i32 0, i32 5
  %4 = load ptr, ptr %stats1, align 8
  %segments2 = getelementptr inbounds %struct.mi_stats_s, ptr %4, i32 0, i32 0
  call void @_mi_stat_decrease(ptr noundef %segments2, i64 noundef 1)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %5 = load i64, ptr %segment_size.addr, align 8
  %cmp3 = icmp sge i64 %5, 0
  %cond = select i1 %cmp3, i32 1, i32 -1
  %conv = sext i32 %cond to i64
  %6 = load ptr, ptr %tld.addr, align 8
  %count = getelementptr inbounds %struct.mi_segments_tld_s, ptr %6, i32 0, i32 1
  %7 = load i64, ptr %count, align 8
  %add = add i64 %7, %conv
  store i64 %add, ptr %count, align 8
  %8 = load ptr, ptr %tld.addr, align 8
  %count4 = getelementptr inbounds %struct.mi_segments_tld_s, ptr %8, i32 0, i32 1
  %9 = load i64, ptr %count4, align 8
  %10 = load ptr, ptr %tld.addr, align 8
  %peak_count = getelementptr inbounds %struct.mi_segments_tld_s, ptr %10, i32 0, i32 2
  %11 = load i64, ptr %peak_count, align 8
  %cmp5 = icmp ugt i64 %9, %11
  br i1 %cmp5, label %if.then7, label %if.end10

if.then7:                                         ; preds = %if.end
  %12 = load ptr, ptr %tld.addr, align 8
  %count8 = getelementptr inbounds %struct.mi_segments_tld_s, ptr %12, i32 0, i32 1
  %13 = load i64, ptr %count8, align 8
  %14 = load ptr, ptr %tld.addr, align 8
  %peak_count9 = getelementptr inbounds %struct.mi_segments_tld_s, ptr %14, i32 0, i32 2
  store i64 %13, ptr %peak_count9, align 8
  br label %if.end10

if.end10:                                         ; preds = %if.then7, %if.end
  %15 = load i64, ptr %segment_size.addr, align 8
  %16 = load ptr, ptr %tld.addr, align 8
  %current_size = getelementptr inbounds %struct.mi_segments_tld_s, ptr %16, i32 0, i32 3
  %17 = load i64, ptr %current_size, align 8
  %add11 = add i64 %17, %15
  store i64 %add11, ptr %current_size, align 8
  %18 = load ptr, ptr %tld.addr, align 8
  %current_size12 = getelementptr inbounds %struct.mi_segments_tld_s, ptr %18, i32 0, i32 3
  %19 = load i64, ptr %current_size12, align 8
  %20 = load ptr, ptr %tld.addr, align 8
  %peak_size = getelementptr inbounds %struct.mi_segments_tld_s, ptr %20, i32 0, i32 4
  %21 = load i64, ptr %peak_size, align 8
  %cmp13 = icmp ugt i64 %19, %21
  br i1 %cmp13, label %if.then15, label %if.end18

if.then15:                                        ; preds = %if.end10
  %22 = load ptr, ptr %tld.addr, align 8
  %current_size16 = getelementptr inbounds %struct.mi_segments_tld_s, ptr %22, i32 0, i32 3
  %23 = load i64, ptr %current_size16, align 8
  %24 = load ptr, ptr %tld.addr, align 8
  %peak_size17 = getelementptr inbounds %struct.mi_segments_tld_s, ptr %24, i32 0, i32 4
  store i64 %23, ptr %peak_size17, align 8
  br label %if.end18

if.end18:                                         ; preds = %if.then15, %if.end10
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_abandoned_push(ptr noundef %segment) #0 {
entry:
  %segment.addr = alloca ptr, align 8
  %next = alloca i64, align 8
  %ts = alloca i64, align 8
  %atomic-temp = alloca i64, align 8
  %.atomictmp = alloca ptr, align 8
  %.atomictmp2 = alloca i64, align 8
  %cmpxchg.bool = alloca i8, align 1
  %.atomictmp3 = alloca i64, align 8
  %atomic-temp4 = alloca i64, align 8
  store ptr %segment, ptr %segment.addr, align 8
  %0 = load atomic i64, ptr @abandoned monotonic, align 64
  store i64 %0, ptr %atomic-temp, align 8
  %1 = load i64, ptr %atomic-temp, align 8
  store i64 %1, ptr %ts, align 8
  br label %do.body

do.body:                                          ; preds = %cmpxchg.continue, %entry
  %2 = load ptr, ptr %segment.addr, align 8
  %abandoned_next = getelementptr inbounds %struct.mi_segment_s, ptr %2, i32 0, i32 7
  %3 = load i64, ptr %ts, align 8
  %call = call ptr @mi_tagged_segment_ptr(i64 noundef %3)
  store ptr %call, ptr %.atomictmp, align 8
  %4 = load i64, ptr %.atomictmp, align 8
  store atomic i64 %4, ptr %abandoned_next release, align 8
  %5 = load ptr, ptr %segment.addr, align 8
  %6 = load i64, ptr %ts, align 8
  %call1 = call i64 @mi_tagged_segment(ptr noundef %5, i64 noundef %6)
  store i64 %call1, ptr %next, align 8
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %7 = load i64, ptr %next, align 8
  store i64 %7, ptr %.atomictmp2, align 8
  %8 = load i64, ptr %ts, align 8
  %9 = load i64, ptr %.atomictmp2, align 8
  %10 = cmpxchg weak ptr @abandoned, i64 %8, i64 %9 release monotonic, align 64
  %11 = extractvalue { i64, i1 } %10, 0
  %12 = extractvalue { i64, i1 } %10, 1
  br i1 %12, label %cmpxchg.continue, label %cmpxchg.store_expected

cmpxchg.store_expected:                           ; preds = %do.cond
  store i64 %11, ptr %ts, align 8
  br label %cmpxchg.continue

cmpxchg.continue:                                 ; preds = %cmpxchg.store_expected, %do.cond
  %frombool = zext i1 %12 to i8
  store i8 %frombool, ptr %cmpxchg.bool, align 1
  %13 = load i8, ptr %cmpxchg.bool, align 1
  %tobool = trunc i8 %13 to i1
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %do.body, label %do.end, !llvm.loop !138

do.end:                                           ; preds = %cmpxchg.continue
  store i64 1, ptr %.atomictmp3, align 8
  %14 = load i64, ptr %.atomictmp3, align 8
  %15 = atomicrmw add ptr @abandoned_count, i64 %14 monotonic, align 64
  store i64 %15, ptr %atomic-temp4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_tagged_segment_ptr(i64 noundef %ts) #0 {
entry:
  %ts.addr = alloca i64, align 8
  store i64 %ts, ptr %ts.addr, align 8
  %0 = load i64, ptr %ts.addr, align 8
  %and = and i64 %0, -33554432
  %1 = inttoptr i64 %and to ptr
  ret ptr %1
}

; Function Attrs: nounwind uwtable
define internal i64 @mi_tagged_segment(ptr noundef %segment, i64 noundef %ts) #0 {
entry:
  %segment.addr = alloca ptr, align 8
  %ts.addr = alloca i64, align 8
  %tag = alloca i64, align 8
  store ptr %segment, ptr %segment.addr, align 8
  store i64 %ts, ptr %ts.addr, align 8
  %0 = load i64, ptr %ts.addr, align 8
  %and = and i64 %0, 33554431
  %add = add i64 %and, 1
  %and1 = and i64 %add, 33554431
  store i64 %and1, ptr %tag, align 8
  %1 = load ptr, ptr %segment.addr, align 8
  %2 = ptrtoint ptr %1 to i64
  %3 = load i64, ptr %tag, align 8
  %or = or i64 %2, %3
  ret i64 %or
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_slices_start_iterate(ptr noundef %segment, ptr noundef %end) #0 {
entry:
  %segment.addr = alloca ptr, align 8
  %end.addr = alloca ptr, align 8
  %slice = alloca ptr, align 8
  store ptr %segment, ptr %segment.addr, align 8
  store ptr %end, ptr %end.addr, align 8
  %0 = load ptr, ptr %segment.addr, align 8
  %slices = getelementptr inbounds %struct.mi_segment_s, ptr %0, i32 0, i32 18
  %arrayidx = getelementptr [513 x %struct.mi_page_s], ptr %slices, i64 0, i64 0
  store ptr %arrayidx, ptr %slice, align 8
  %1 = load ptr, ptr %segment.addr, align 8
  %call = call ptr @mi_segment_slices_end(ptr noundef %1)
  %2 = load ptr, ptr %end.addr, align 8
  store ptr %call, ptr %2, align 8
  %3 = load ptr, ptr %slice, align 8
  %4 = load ptr, ptr %slice, align 8
  %slice_count = getelementptr inbounds %struct.mi_page_s, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %slice_count, align 8
  %idx.ext = zext i32 %5 to i64
  %add.ptr = getelementptr %struct.mi_page_s, ptr %3, i64 %idx.ext
  store ptr %add.ptr, ptr %slice, align 8
  %6 = load ptr, ptr %slice, align 8
  ret ptr %6
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_slice_is_used(ptr noundef %slice) #0 {
entry:
  %slice.addr = alloca ptr, align 8
  store ptr %slice, ptr %slice.addr, align 8
  %0 = load ptr, ptr %slice.addr, align 8
  %xblock_size = getelementptr inbounds %struct.mi_page_s, ptr %0, i32 0, i32 9
  %1 = load i32, ptr %xblock_size, align 4
  %cmp = icmp ugt i32 %1, 0
  ret i1 %cmp
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_page_has_any_available(ptr noundef %page) #0 {
entry:
  %page.addr = alloca ptr, align 8
  store ptr %page, ptr %page.addr, align 8
  %0 = load ptr, ptr %page.addr, align 8
  %used = getelementptr inbounds %struct.mi_page_s, ptr %0, i32 0, i32 8
  %1 = load i32, ptr %used, align 8
  %2 = load ptr, ptr %page.addr, align 8
  %reserved = getelementptr inbounds %struct.mi_page_s, ptr %2, i32 0, i32 4
  %3 = load i16, ptr %reserved, align 4
  %conv = zext i16 %3 to i32
  %cmp = icmp ult i32 %1, %conv
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %4 = load ptr, ptr %page.addr, align 8
  %call = call ptr @mi_page_thread_free(ptr noundef %4)
  %cmp2 = icmp ne ptr %call, null
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %5 = phi i1 [ true, %entry ], [ %cmp2, %lor.rhs ]
  ret i1 %5
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_segment_alloc(i64 noundef %required, i64 noundef %page_alignment, i32 noundef %req_arena_id, ptr noundef %tld, ptr noundef %os_tld, ptr noundef %huge_page) #0 {
entry:
  %retval = alloca ptr, align 8
  %required.addr = alloca i64, align 8
  %page_alignment.addr = alloca i64, align 8
  %req_arena_id.addr = alloca i32, align 4
  %tld.addr = alloca ptr, align 8
  %os_tld.addr = alloca ptr, align 8
  %huge_page.addr = alloca ptr, align 8
  %info_slices = alloca i64, align 8
  %pre_size = alloca i64, align 8
  %segment_slices = alloca i64, align 8
  %eager_delay = alloca i8, align 1
  %eager = alloca i8, align 1
  %commit = alloca i8, align 1
  %segment = alloca ptr, align 8
  %ofs = alloca i64, align 8
  %prefix = alloca i64, align 8
  %zsize = alloca i64, align 8
  %slice_entries = alloca i64, align 8
  %guard_slices = alloca i64, align 8
  %page0 = alloca ptr, align 8
  store i64 %required, ptr %required.addr, align 8
  store i64 %page_alignment, ptr %page_alignment.addr, align 8
  store i32 %req_arena_id, ptr %req_arena_id.addr, align 4
  store ptr %tld, ptr %tld.addr, align 8
  store ptr %os_tld, ptr %os_tld.addr, align 8
  store ptr %huge_page, ptr %huge_page.addr, align 8
  %0 = load i64, ptr %required.addr, align 8
  %call = call i64 @mi_segment_calculate_slices(i64 noundef %0, ptr noundef %pre_size, ptr noundef %info_slices)
  store i64 %call, ptr %segment_slices, align 8
  %call1 = call i64 @_mi_current_thread_count()
  %cmp = icmp ugt i64 %call1, 1
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %1 = load ptr, ptr %tld.addr, align 8
  %count = getelementptr inbounds %struct.mi_segments_tld_s, ptr %1, i32 0, i32 1
  %2 = load i64, ptr %count, align 8
  %call2 = call i64 @mi_option_get(i32 noundef 14)
  %cmp3 = icmp ult i64 %2, %call2
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %3 = phi i1 [ false, %entry ], [ %cmp3, %land.rhs ]
  %frombool = zext i1 %3 to i8
  store i8 %frombool, ptr %eager_delay, align 1
  %4 = load i8, ptr %eager_delay, align 1
  %tobool = trunc i8 %4 to i1
  br i1 %tobool, label %land.end6, label %land.rhs4

land.rhs4:                                        ; preds = %land.end
  %call5 = call zeroext i1 @mi_option_is_enabled(i32 noundef 3)
  br label %land.end6

land.end6:                                        ; preds = %land.rhs4, %land.end
  %5 = phi i1 [ false, %land.end ], [ %call5, %land.rhs4 ]
  %frombool7 = zext i1 %5 to i8
  store i8 %frombool7, ptr %eager, align 1
  %6 = load i8, ptr %eager, align 1
  %tobool8 = trunc i8 %6 to i1
  br i1 %tobool8, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.end6
  %7 = load i64, ptr %required.addr, align 8
  %cmp9 = icmp ugt i64 %7, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.end6
  %8 = phi i1 [ true, %land.end6 ], [ %cmp9, %lor.rhs ]
  %frombool10 = zext i1 %8 to i8
  store i8 %frombool10, ptr %commit, align 1
  %9 = load i64, ptr %required.addr, align 8
  %10 = load i64, ptr %page_alignment.addr, align 8
  %11 = load i8, ptr %eager_delay, align 1
  %tobool11 = trunc i8 %11 to i1
  %12 = load i32, ptr %req_arena_id.addr, align 4
  %13 = load i8, ptr %commit, align 1
  %tobool12 = trunc i8 %13 to i1
  %14 = load ptr, ptr %tld.addr, align 8
  %15 = load ptr, ptr %os_tld.addr, align 8
  %call13 = call ptr @mi_segment_os_alloc(i64 noundef %9, i64 noundef %10, i1 noundef zeroext %tobool11, i32 noundef %12, ptr noundef %segment_slices, ptr noundef %pre_size, ptr noundef %info_slices, i1 noundef zeroext %tobool12, ptr noundef %14, ptr noundef %15)
  store ptr %call13, ptr %segment, align 8
  %16 = load ptr, ptr %segment, align 8
  %cmp14 = icmp eq ptr %16, null
  br i1 %cmp14, label %if.then, label %if.end

if.then:                                          ; preds = %lor.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.end
  %17 = load ptr, ptr %segment, align 8
  %memid = getelementptr inbounds %struct.mi_segment_s, ptr %17, i32 0, i32 0
  %initially_zero = getelementptr inbounds %struct.mi_memid_s, ptr %memid, i32 0, i32 3
  %18 = load i8, ptr %initially_zero, align 2
  %tobool15 = trunc i8 %18 to i1
  br i1 %tobool15, label %if.end18, label %if.then16

if.then16:                                        ; preds = %if.end
  store i64 184, ptr %ofs, align 8
  %19 = load i64, ptr %ofs, align 8
  %sub = sub i64 264, %19
  store i64 %sub, ptr %prefix, align 8
  %20 = load i64, ptr %prefix, align 8
  %21 = load i64, ptr %segment_slices, align 8
  %add = add i64 %21, 1
  %mul = mul i64 80, %add
  %add17 = add i64 %20, %mul
  store i64 %add17, ptr %zsize, align 8
  %22 = load ptr, ptr %segment, align 8
  %23 = load i64, ptr %ofs, align 8
  %add.ptr = getelementptr i8, ptr %22, i64 %23
  %24 = load i64, ptr %zsize, align 8
  call void @_mi_memzero(ptr noundef %add.ptr, i64 noundef %24)
  br label %if.end18

if.end18:                                         ; preds = %if.then16, %if.end
  %25 = load i64, ptr %segment_slices, align 8
  %cmp19 = icmp ugt i64 %25, 512
  br i1 %cmp19, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end18
  br label %cond.end

cond.false:                                       ; preds = %if.end18
  %26 = load i64, ptr %segment_slices, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ 512, %cond.true ], [ %26, %cond.false ]
  store i64 %cond, ptr %slice_entries, align 8
  %27 = load i64, ptr %segment_slices, align 8
  %28 = load ptr, ptr %segment, align 8
  %segment_slices20 = getelementptr inbounds %struct.mi_segment_s, ptr %28, i32 0, i32 13
  store i64 %27, ptr %segment_slices20, align 8
  %29 = load i64, ptr %info_slices, align 8
  %30 = load ptr, ptr %segment, align 8
  %segment_info_slices = getelementptr inbounds %struct.mi_segment_s, ptr %30, i32 0, i32 14
  store i64 %29, ptr %segment_info_slices, align 8
  %call21 = call i64 @_mi_thread_id()
  %31 = load ptr, ptr %segment, align 8
  %thread_id = getelementptr inbounds %struct.mi_segment_s, ptr %31, i32 0, i32 17
  store atomic i64 %call21, ptr %thread_id seq_cst, align 8
  %32 = load ptr, ptr %segment, align 8
  %call22 = call i64 @_mi_ptr_cookie(ptr noundef %32)
  %33 = load ptr, ptr %segment, align 8
  %cookie = getelementptr inbounds %struct.mi_segment_s, ptr %33, i32 0, i32 12
  store i64 %call22, ptr %cookie, align 8
  %34 = load i64, ptr %slice_entries, align 8
  %35 = load ptr, ptr %segment, align 8
  %slice_entries23 = getelementptr inbounds %struct.mi_segment_s, ptr %35, i32 0, i32 16
  store i64 %34, ptr %slice_entries23, align 8
  %36 = load i64, ptr %required.addr, align 8
  %cmp24 = icmp eq i64 %36, 0
  %cond25 = select i1 %cmp24, i32 0, i32 1
  %37 = load ptr, ptr %segment, align 8
  %kind = getelementptr inbounds %struct.mi_segment_s, ptr %37, i32 0, i32 15
  store i32 %cond25, ptr %kind, align 8
  %38 = load ptr, ptr %tld.addr, align 8
  %stats = getelementptr inbounds %struct.mi_segments_tld_s, ptr %38, i32 0, i32 5
  %39 = load ptr, ptr %stats, align 8
  %page_committed = getelementptr inbounds %struct.mi_stats_s, ptr %39, i32 0, i32 6
  %40 = load ptr, ptr %segment, align 8
  %call26 = call i64 @mi_segment_info_size(ptr noundef %40)
  call void @_mi_stat_increase(ptr noundef %page_committed, i64 noundef %call26)
  store i64 0, ptr %guard_slices, align 8
  %41 = load ptr, ptr %segment, align 8
  %42 = load i64, ptr %info_slices, align 8
  %43 = load ptr, ptr %tld.addr, align 8
  %call27 = call ptr @mi_segment_span_allocate(ptr noundef %41, i64 noundef 0, i64 noundef %42, ptr noundef %43)
  store ptr %call27, ptr %page0, align 8
  %44 = load ptr, ptr %page0, align 8
  %cmp28 = icmp eq ptr %44, null
  br i1 %cmp28, label %if.then29, label %if.end30

if.then29:                                        ; preds = %cond.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end30:                                         ; preds = %cond.end
  %45 = load ptr, ptr %segment, align 8
  %used = getelementptr inbounds %struct.mi_segment_s, ptr %45, i32 0, i32 11
  store i64 0, ptr %used, align 8
  %46 = load ptr, ptr %segment, align 8
  %kind31 = getelementptr inbounds %struct.mi_segment_s, ptr %46, i32 0, i32 15
  %47 = load i32, ptr %kind31, align 8
  %cmp32 = icmp eq i32 %47, 0
  br i1 %cmp32, label %if.then33, label %if.else

if.then33:                                        ; preds = %if.end30
  %48 = load ptr, ptr %segment, align 8
  %49 = load i64, ptr %info_slices, align 8
  %50 = load ptr, ptr %segment, align 8
  %slice_entries34 = getelementptr inbounds %struct.mi_segment_s, ptr %50, i32 0, i32 16
  %51 = load i64, ptr %slice_entries34, align 8
  %52 = load i64, ptr %info_slices, align 8
  %sub35 = sub i64 %51, %52
  %53 = load ptr, ptr %tld.addr, align 8
  call void @mi_segment_span_free(ptr noundef %48, i64 noundef %49, i64 noundef %sub35, i1 noundef zeroext false, ptr noundef %53)
  br label %if.end39

if.else:                                          ; preds = %if.end30
  %54 = load ptr, ptr %segment, align 8
  %55 = load i64, ptr %info_slices, align 8
  %56 = load i64, ptr %segment_slices, align 8
  %57 = load i64, ptr %info_slices, align 8
  %sub36 = sub i64 %56, %57
  %58 = load i64, ptr %guard_slices, align 8
  %sub37 = sub i64 %sub36, %58
  %59 = load ptr, ptr %tld.addr, align 8
  %call38 = call ptr @mi_segment_span_allocate(ptr noundef %54, i64 noundef %55, i64 noundef %sub37, ptr noundef %59)
  %60 = load ptr, ptr %huge_page.addr, align 8
  store ptr %call38, ptr %60, align 8
  br label %if.end39

if.end39:                                         ; preds = %if.else, %if.then33
  %61 = load ptr, ptr %segment, align 8
  store ptr %61, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end39, %if.then29, %if.then
  %62 = load ptr, ptr %retval, align 8
  ret ptr %62
}

; Function Attrs: nounwind uwtable
define internal i64 @mi_segment_calculate_slices(i64 noundef %required, ptr noundef %pre_size, ptr noundef %info_slices) #0 {
entry:
  %required.addr = alloca i64, align 8
  %pre_size.addr = alloca ptr, align 8
  %info_slices.addr = alloca ptr, align 8
  %page_size = alloca i64, align 8
  %isize = alloca i64, align 8
  %guardsize = alloca i64, align 8
  %segment_size = alloca i64, align 8
  store i64 %required, ptr %required.addr, align 8
  store ptr %pre_size, ptr %pre_size.addr, align 8
  store ptr %info_slices, ptr %info_slices.addr, align 8
  %call = call i64 @_mi_os_page_size()
  store i64 %call, ptr %page_size, align 8
  %0 = load i64, ptr %page_size, align 8
  %call1 = call i64 @_mi_align_up(i64 noundef 41304, i64 noundef %0)
  store i64 %call1, ptr %isize, align 8
  store i64 0, ptr %guardsize, align 8
  %1 = load ptr, ptr %pre_size.addr, align 8
  %cmp = icmp ne ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i64, ptr %isize, align 8
  %3 = load ptr, ptr %pre_size.addr, align 8
  store i64 %2, ptr %3, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load i64, ptr %isize, align 8
  %5 = load i64, ptr %guardsize, align 8
  %add = add i64 %4, %5
  %call2 = call i64 @_mi_align_up(i64 noundef %add, i64 noundef 65536)
  store i64 %call2, ptr %isize, align 8
  %6 = load ptr, ptr %info_slices.addr, align 8
  %cmp3 = icmp ne ptr %6, null
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  %7 = load i64, ptr %isize, align 8
  %div = udiv i64 %7, 65536
  %8 = load ptr, ptr %info_slices.addr, align 8
  store i64 %div, ptr %8, align 8
  br label %if.end5

if.end5:                                          ; preds = %if.then4, %if.end
  %9 = load i64, ptr %required.addr, align 8
  %cmp6 = icmp eq i64 %9, 0
  br i1 %cmp6, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end5
  br label %cond.end

cond.false:                                       ; preds = %if.end5
  %10 = load i64, ptr %required.addr, align 8
  %11 = load i64, ptr %isize, align 8
  %add7 = add i64 %10, %11
  %12 = load i64, ptr %guardsize, align 8
  %add8 = add i64 %add7, %12
  %call9 = call i64 @_mi_align_up(i64 noundef %add8, i64 noundef 65536)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ 33554432, %cond.true ], [ %call9, %cond.false ]
  store i64 %cond, ptr %segment_size, align 8
  %13 = load i64, ptr %segment_size, align 8
  %div10 = udiv i64 %13, 65536
  ret i64 %div10
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_segment_os_alloc(i64 noundef %required, i64 noundef %page_alignment, i1 noundef zeroext %eager_delayed, i32 noundef %req_arena_id, ptr noundef %psegment_slices, ptr noundef %ppre_size, ptr noundef %pinfo_slices, i1 noundef zeroext %commit, ptr noundef %tld, ptr noundef %os_tld) #0 {
entry:
  %retval = alloca ptr, align 8
  %required.addr = alloca i64, align 8
  %page_alignment.addr = alloca i64, align 8
  %eager_delayed.addr = alloca i8, align 1
  %req_arena_id.addr = alloca i32, align 4
  %psegment_slices.addr = alloca ptr, align 8
  %ppre_size.addr = alloca ptr, align 8
  %pinfo_slices.addr = alloca ptr, align 8
  %commit.addr = alloca i8, align 1
  %tld.addr = alloca ptr, align 8
  %os_tld.addr = alloca ptr, align 8
  %memid = alloca %struct.mi_memid_s, align 8
  %allow_large = alloca i8, align 1
  %align_offset = alloca i64, align 8
  %alignment = alloca i64, align 8
  %info_size = alloca i64, align 8
  %extra = alloca i64, align 8
  %segment_size = alloca i64, align 8
  %segment = alloca ptr, align 8
  %commit_mask = alloca %struct.mi_commit_mask_s, align 8
  %commit_needed = alloca i64, align 8
  %.atomictmp = alloca ptr, align 8
  store i64 %required, ptr %required.addr, align 8
  store i64 %page_alignment, ptr %page_alignment.addr, align 8
  %frombool = zext i1 %eager_delayed to i8
  store i8 %frombool, ptr %eager_delayed.addr, align 1
  store i32 %req_arena_id, ptr %req_arena_id.addr, align 4
  store ptr %psegment_slices, ptr %psegment_slices.addr, align 8
  store ptr %ppre_size, ptr %ppre_size.addr, align 8
  store ptr %pinfo_slices, ptr %pinfo_slices.addr, align 8
  %frombool1 = zext i1 %commit to i8
  store i8 %frombool1, ptr %commit.addr, align 1
  store ptr %tld, ptr %tld.addr, align 8
  store ptr %os_tld, ptr %os_tld.addr, align 8
  %0 = load i8, ptr %eager_delayed.addr, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %entry
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %1 = phi i1 [ false, %entry ], [ true, %land.rhs ]
  %frombool2 = zext i1 %1 to i8
  store i8 %frombool2, ptr %allow_large, align 1
  store i64 0, ptr %align_offset, align 8
  store i64 33554432, ptr %alignment, align 8
  %2 = load i64, ptr %page_alignment.addr, align 8
  %cmp = icmp ugt i64 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %land.end
  %3 = load i64, ptr %page_alignment.addr, align 8
  store i64 %3, ptr %alignment, align 8
  %4 = load ptr, ptr %pinfo_slices.addr, align 8
  %5 = load i64, ptr %4, align 8
  %mul = mul i64 %5, 65536
  store i64 %mul, ptr %info_size, align 8
  %6 = load i64, ptr %info_size, align 8
  %call = call i64 @_mi_align_up(i64 noundef %6, i64 noundef 33554432)
  store i64 %call, ptr %align_offset, align 8
  %7 = load i64, ptr %align_offset, align 8
  %8 = load i64, ptr %info_size, align 8
  %sub = sub i64 %7, %8
  store i64 %sub, ptr %extra, align 8
  %9 = load i64, ptr %required.addr, align 8
  %10 = load i64, ptr %extra, align 8
  %add = add i64 %9, %10
  %11 = load ptr, ptr %ppre_size.addr, align 8
  %12 = load ptr, ptr %pinfo_slices.addr, align 8
  %call3 = call i64 @mi_segment_calculate_slices(i64 noundef %add, ptr noundef %11, ptr noundef %12)
  %13 = load ptr, ptr %psegment_slices.addr, align 8
  store i64 %call3, ptr %13, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %land.end
  %14 = load ptr, ptr %psegment_slices.addr, align 8
  %15 = load i64, ptr %14, align 8
  %mul4 = mul i64 %15, 65536
  store i64 %mul4, ptr %segment_size, align 8
  %16 = load i64, ptr %segment_size, align 8
  %17 = load i64, ptr %alignment, align 8
  %18 = load i64, ptr %align_offset, align 8
  %19 = load i8, ptr %commit.addr, align 1
  %tobool5 = trunc i8 %19 to i1
  %20 = load i8, ptr %allow_large, align 1
  %tobool6 = trunc i8 %20 to i1
  %21 = load i32, ptr %req_arena_id.addr, align 4
  %22 = load ptr, ptr %os_tld.addr, align 8
  %call7 = call ptr @_mi_arena_alloc_aligned(i64 noundef %16, i64 noundef %17, i64 noundef %18, i1 noundef zeroext %tobool5, i1 noundef zeroext %tobool6, i32 noundef %21, ptr noundef %memid, ptr noundef %22)
  store ptr %call7, ptr %segment, align 8
  %23 = load ptr, ptr %segment, align 8
  %cmp8 = icmp eq ptr %23, null
  br i1 %cmp8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end10:                                         ; preds = %if.end
  %initially_committed = getelementptr inbounds %struct.mi_memid_s, ptr %memid, i32 0, i32 2
  %24 = load i8, ptr %initially_committed, align 1
  %tobool11 = trunc i8 %24 to i1
  br i1 %tobool11, label %if.then12, label %if.else

if.then12:                                        ; preds = %if.end10
  call void @mi_commit_mask_create_full(ptr noundef %commit_mask)
  br label %if.end20

if.else:                                          ; preds = %if.end10
  %25 = load ptr, ptr %pinfo_slices.addr, align 8
  %26 = load i64, ptr %25, align 8
  %mul13 = mul i64 %26, 65536
  %call14 = call i64 @_mi_divide_up(i64 noundef %mul13, i64 noundef 65536)
  store i64 %call14, ptr %commit_needed, align 8
  %27 = load i64, ptr %commit_needed, align 8
  call void @mi_commit_mask_create(i64 noundef 0, i64 noundef %27, ptr noundef %commit_mask)
  %28 = load ptr, ptr %segment, align 8
  %29 = load i64, ptr %commit_needed, align 8
  %mul15 = mul i64 %29, 65536
  %30 = load ptr, ptr %tld.addr, align 8
  %stats = getelementptr inbounds %struct.mi_segments_tld_s, ptr %30, i32 0, i32 5
  %31 = load ptr, ptr %stats, align 8
  %call16 = call zeroext i1 @_mi_os_commit(ptr noundef %28, i64 noundef %mul15, ptr noundef null, ptr noundef %31)
  br i1 %call16, label %if.end19, label %if.then17

if.then17:                                        ; preds = %if.else
  %32 = load ptr, ptr %segment, align 8
  %33 = load i64, ptr %segment_size, align 8
  %34 = load ptr, ptr %tld.addr, align 8
  %stats18 = getelementptr inbounds %struct.mi_segments_tld_s, ptr %34, i32 0, i32 5
  %35 = load ptr, ptr %stats18, align 8
  call void @_mi_arena_free(ptr noundef %32, i64 noundef %33, i64 noundef 0, ptr noundef byval(%struct.mi_memid_s) align 8 %memid, ptr noundef %35)
  store ptr null, ptr %retval, align 8
  br label %return

if.end19:                                         ; preds = %if.else
  br label %if.end20

if.end20:                                         ; preds = %if.end19, %if.then12
  %36 = load ptr, ptr %segment, align 8
  %memid21 = getelementptr inbounds %struct.mi_segment_s, ptr %36, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %memid21, ptr align 8 %memid, i64 24, i1 false)
  %is_pinned = getelementptr inbounds %struct.mi_memid_s, ptr %memid, i32 0, i32 1
  %37 = load i8, ptr %is_pinned, align 8
  %tobool22 = trunc i8 %37 to i1
  %lnot = xor i1 %tobool22, true
  %38 = load ptr, ptr %segment, align 8
  %allow_decommit = getelementptr inbounds %struct.mi_segment_s, ptr %38, i32 0, i32 1
  %frombool23 = zext i1 %lnot to i8
  store i8 %frombool23, ptr %allow_decommit, align 8
  %39 = load ptr, ptr %segment, align 8
  %allow_decommit24 = getelementptr inbounds %struct.mi_segment_s, ptr %39, i32 0, i32 1
  %40 = load i8, ptr %allow_decommit24, align 8
  %tobool25 = trunc i8 %40 to i1
  br i1 %tobool25, label %land.rhs26, label %land.end29

land.rhs26:                                       ; preds = %if.end20
  %call27 = call i64 @mi_option_get(i32 noundef 15)
  %cmp28 = icmp sge i64 %call27, 0
  br label %land.end29

land.end29:                                       ; preds = %land.rhs26, %if.end20
  %41 = phi i1 [ false, %if.end20 ], [ %cmp28, %land.rhs26 ]
  %42 = load ptr, ptr %segment, align 8
  %allow_purge = getelementptr inbounds %struct.mi_segment_s, ptr %42, i32 0, i32 2
  %frombool30 = zext i1 %41 to i8
  store i8 %frombool30, ptr %allow_purge, align 1
  %43 = load i64, ptr %segment_size, align 8
  %44 = load ptr, ptr %segment, align 8
  %segment_size31 = getelementptr inbounds %struct.mi_segment_s, ptr %44, i32 0, i32 3
  store i64 %43, ptr %segment_size31, align 8
  %45 = load ptr, ptr %segment, align 8
  %commit_mask32 = getelementptr inbounds %struct.mi_segment_s, ptr %45, i32 0, i32 6
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %commit_mask32, ptr align 8 %commit_mask, i64 64, i1 false)
  %46 = load ptr, ptr %segment, align 8
  %purge_expire = getelementptr inbounds %struct.mi_segment_s, ptr %46, i32 0, i32 4
  store i64 0, ptr %purge_expire, align 8
  %47 = load ptr, ptr %segment, align 8
  %purge_mask = getelementptr inbounds %struct.mi_segment_s, ptr %47, i32 0, i32 5
  call void @mi_commit_mask_create_empty(ptr noundef %purge_mask)
  %48 = load ptr, ptr %segment, align 8
  %abandoned_next = getelementptr inbounds %struct.mi_segment_s, ptr %48, i32 0, i32 7
  store ptr null, ptr %.atomictmp, align 8
  %49 = load i64, ptr %.atomictmp, align 8
  store atomic i64 %49, ptr %abandoned_next release, align 8
  %50 = load i64, ptr %segment_size, align 8
  %51 = load ptr, ptr %tld.addr, align 8
  call void @mi_segments_track_size(i64 noundef %50, ptr noundef %51)
  %52 = load ptr, ptr %segment, align 8
  call void @_mi_segment_map_allocated_at(ptr noundef %52)
  %53 = load ptr, ptr %segment, align 8
  store ptr %53, ptr %retval, align 8
  br label %return

return:                                           ; preds = %land.end29, %if.then17, %if.then9
  %54 = load ptr, ptr %retval, align 8
  ret ptr %54
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_segment_span_allocate(ptr noundef %segment, i64 noundef %slice_index, i64 noundef %slice_count, ptr noundef %tld) #0 {
entry:
  %retval = alloca ptr, align 8
  %segment.addr = alloca ptr, align 8
  %slice_index.addr = alloca i64, align 8
  %slice_count.addr = alloca i64, align 8
  %tld.addr = alloca ptr, align 8
  %slice = alloca ptr, align 8
  %bsize = alloca i64, align 8
  %page = alloca ptr, align 8
  %extra = alloca i64, align 8
  %slice_next = alloca ptr, align 8
  %i = alloca i64, align 8
  %last = alloca ptr, align 8
  %end = alloca ptr, align 8
  store ptr %segment, ptr %segment.addr, align 8
  store i64 %slice_index, ptr %slice_index.addr, align 8
  store i64 %slice_count, ptr %slice_count.addr, align 8
  store ptr %tld, ptr %tld.addr, align 8
  %0 = load ptr, ptr %segment.addr, align 8
  %slices = getelementptr inbounds %struct.mi_segment_s, ptr %0, i32 0, i32 18
  %1 = load i64, ptr %slice_index.addr, align 8
  %arrayidx = getelementptr [513 x %struct.mi_page_s], ptr %slices, i64 0, i64 %1
  store ptr %arrayidx, ptr %slice, align 8
  %2 = load ptr, ptr %segment.addr, align 8
  %3 = load ptr, ptr %segment.addr, align 8
  %4 = load ptr, ptr %slice, align 8
  %call = call ptr @_mi_segment_page_start_from_slice(ptr noundef %3, ptr noundef %4, i64 noundef 0, ptr noundef null)
  %5 = load i64, ptr %slice_count.addr, align 8
  %mul = mul i64 %5, 65536
  %6 = load ptr, ptr %tld.addr, align 8
  %stats = getelementptr inbounds %struct.mi_segments_tld_s, ptr %6, i32 0, i32 5
  %7 = load ptr, ptr %stats, align 8
  %call1 = call zeroext i1 @mi_segment_ensure_committed(ptr noundef %2, ptr noundef %call, i64 noundef %mul, ptr noundef %7)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %slice, align 8
  %slice_offset = getelementptr inbounds %struct.mi_page_s, ptr %8, i32 0, i32 1
  store i32 0, ptr %slice_offset, align 4
  %9 = load i64, ptr %slice_count.addr, align 8
  %conv = trunc i64 %9 to i32
  %10 = load ptr, ptr %slice, align 8
  %slice_count2 = getelementptr inbounds %struct.mi_page_s, ptr %10, i32 0, i32 0
  store i32 %conv, ptr %slice_count2, align 8
  %11 = load i64, ptr %slice_count.addr, align 8
  %mul3 = mul i64 %11, 65536
  store i64 %mul3, ptr %bsize, align 8
  %12 = load i64, ptr %bsize, align 8
  %cmp = icmp uge i64 %12, 2147483648
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %13 = load i64, ptr %bsize, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ 2147483648, %cond.true ], [ %13, %cond.false ]
  %conv5 = trunc i64 %cond to i32
  %14 = load ptr, ptr %slice, align 8
  %xblock_size = getelementptr inbounds %struct.mi_page_s, ptr %14, i32 0, i32 9
  store i32 %conv5, ptr %xblock_size, align 4
  %15 = load ptr, ptr %slice, align 8
  %call6 = call ptr @mi_slice_to_page(ptr noundef %15)
  store ptr %call6, ptr %page, align 8
  %16 = load i64, ptr %slice_count.addr, align 8
  %sub = sub i64 %16, 1
  store i64 %sub, ptr %extra, align 8
  %17 = load i64, ptr %extra, align 8
  %cmp7 = icmp ugt i64 %17, 255
  br i1 %cmp7, label %if.then9, label %if.end10

if.then9:                                         ; preds = %cond.end
  store i64 255, ptr %extra, align 8
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %cond.end
  %18 = load i64, ptr %slice_index.addr, align 8
  %19 = load i64, ptr %extra, align 8
  %add = add i64 %18, %19
  %20 = load ptr, ptr %segment.addr, align 8
  %slice_entries = getelementptr inbounds %struct.mi_segment_s, ptr %20, i32 0, i32 16
  %21 = load i64, ptr %slice_entries, align 8
  %cmp11 = icmp uge i64 %add, %21
  br i1 %cmp11, label %if.then13, label %if.end17

if.then13:                                        ; preds = %if.end10
  %22 = load ptr, ptr %segment.addr, align 8
  %slice_entries14 = getelementptr inbounds %struct.mi_segment_s, ptr %22, i32 0, i32 16
  %23 = load i64, ptr %slice_entries14, align 8
  %24 = load i64, ptr %slice_index.addr, align 8
  %sub15 = sub i64 %23, %24
  %sub16 = sub i64 %sub15, 1
  store i64 %sub16, ptr %extra, align 8
  br label %if.end17

if.end17:                                         ; preds = %if.then13, %if.end10
  %25 = load ptr, ptr %slice, align 8
  %add.ptr = getelementptr %struct.mi_page_s, ptr %25, i64 1
  store ptr %add.ptr, ptr %slice_next, align 8
  store i64 1, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end17
  %26 = load i64, ptr %i, align 8
  %27 = load i64, ptr %extra, align 8
  %cmp18 = icmp ule i64 %26, %27
  br i1 %cmp18, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %28 = load i64, ptr %i, align 8
  %mul20 = mul i64 80, %28
  %conv21 = trunc i64 %mul20 to i32
  %29 = load ptr, ptr %slice_next, align 8
  %slice_offset22 = getelementptr inbounds %struct.mi_page_s, ptr %29, i32 0, i32 1
  store i32 %conv21, ptr %slice_offset22, align 4
  %30 = load ptr, ptr %slice_next, align 8
  %slice_count23 = getelementptr inbounds %struct.mi_page_s, ptr %30, i32 0, i32 0
  store i32 0, ptr %slice_count23, align 8
  %31 = load ptr, ptr %slice_next, align 8
  %xblock_size24 = getelementptr inbounds %struct.mi_page_s, ptr %31, i32 0, i32 9
  store i32 1, ptr %xblock_size24, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %32 = load i64, ptr %i, align 8
  %inc = add i64 %32, 1
  store i64 %inc, ptr %i, align 8
  %33 = load ptr, ptr %slice_next, align 8
  %incdec.ptr = getelementptr %struct.mi_page_s, ptr %33, i32 1
  store ptr %incdec.ptr, ptr %slice_next, align 8
  br label %for.cond, !llvm.loop !139

for.end:                                          ; preds = %for.cond
  %34 = load ptr, ptr %slice, align 8
  %35 = load i64, ptr %slice_count.addr, align 8
  %add.ptr25 = getelementptr %struct.mi_page_s, ptr %34, i64 %35
  %add.ptr26 = getelementptr %struct.mi_page_s, ptr %add.ptr25, i64 -1
  store ptr %add.ptr26, ptr %last, align 8
  %36 = load ptr, ptr %segment.addr, align 8
  %call27 = call ptr @mi_segment_slices_end(ptr noundef %36)
  store ptr %call27, ptr %end, align 8
  %37 = load ptr, ptr %last, align 8
  %38 = load ptr, ptr %end, align 8
  %cmp28 = icmp ugt ptr %37, %38
  br i1 %cmp28, label %if.then30, label %if.end31

if.then30:                                        ; preds = %for.end
  %39 = load ptr, ptr %end, align 8
  store ptr %39, ptr %last, align 8
  br label %if.end31

if.end31:                                         ; preds = %if.then30, %for.end
  %40 = load ptr, ptr %last, align 8
  %41 = load ptr, ptr %slice, align 8
  %cmp32 = icmp ugt ptr %40, %41
  br i1 %cmp32, label %if.then34, label %if.end40

if.then34:                                        ; preds = %if.end31
  %42 = load ptr, ptr %last, align 8
  %43 = load ptr, ptr %slice, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %42 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %43 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 80
  %mul35 = mul i64 80, %sub.ptr.div
  %conv36 = trunc i64 %mul35 to i32
  %44 = load ptr, ptr %last, align 8
  %slice_offset37 = getelementptr inbounds %struct.mi_page_s, ptr %44, i32 0, i32 1
  store i32 %conv36, ptr %slice_offset37, align 4
  %45 = load ptr, ptr %last, align 8
  %slice_count38 = getelementptr inbounds %struct.mi_page_s, ptr %45, i32 0, i32 0
  store i32 0, ptr %slice_count38, align 8
  %46 = load ptr, ptr %last, align 8
  %xblock_size39 = getelementptr inbounds %struct.mi_page_s, ptr %46, i32 0, i32 9
  store i32 1, ptr %xblock_size39, align 4
  br label %if.end40

if.end40:                                         ; preds = %if.then34, %if.end31
  %47 = load ptr, ptr %page, align 8
  %is_committed = getelementptr inbounds %struct.mi_page_s, ptr %47, i32 0, i32 2
  %bf.load = load i8, ptr %is_committed, align 8
  %bf.clear = and i8 %bf.load, -2
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, ptr %is_committed, align 8
  %48 = load ptr, ptr %segment.addr, align 8
  %used = getelementptr inbounds %struct.mi_segment_s, ptr %48, i32 0, i32 11
  %49 = load i64, ptr %used, align 8
  %inc41 = add i64 %49, 1
  store i64 %inc41, ptr %used, align 8
  %50 = load ptr, ptr %page, align 8
  store ptr %50, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end40, %if.then
  %51 = load ptr, ptr %retval, align 8
  ret ptr %51
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_segment_ensure_committed(ptr noundef %segment, ptr noundef %p, i64 noundef %size, ptr noundef %stats) #0 {
entry:
  %retval = alloca i1, align 1
  %segment.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %stats.addr = alloca ptr, align 8
  store ptr %segment, ptr %segment.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store ptr %stats, ptr %stats.addr, align 8
  %0 = load ptr, ptr %segment.addr, align 8
  %commit_mask = getelementptr inbounds %struct.mi_segment_s, ptr %0, i32 0, i32 6
  %call = call zeroext i1 @mi_commit_mask_is_full(ptr noundef %commit_mask)
  br i1 %call, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %segment.addr, align 8
  %purge_mask = getelementptr inbounds %struct.mi_segment_s, ptr %1, i32 0, i32 5
  %call1 = call zeroext i1 @mi_commit_mask_is_empty(ptr noundef %purge_mask)
  br i1 %call1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store i1 true, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %2 = load ptr, ptr %segment.addr, align 8
  %3 = load ptr, ptr %p.addr, align 8
  %4 = load i64, ptr %size.addr, align 8
  %5 = load ptr, ptr %stats.addr, align 8
  %call2 = call zeroext i1 @mi_segment_commit(ptr noundef %2, ptr noundef %3, i64 noundef %4, ptr noundef %5)
  store i1 %call2, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i1, ptr %retval, align 1
  ret i1 %6
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_commit_mask_is_full(ptr noundef %cm) #0 {
entry:
  %retval = alloca i1, align 1
  %cm.addr = alloca ptr, align 8
  %i = alloca i64, align 8
  store ptr %cm, ptr %cm.addr, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load ptr, ptr %cm.addr, align 8
  %mask = getelementptr inbounds %struct.mi_commit_mask_s, ptr %1, i32 0, i32 0
  %2 = load i64, ptr %i, align 8
  %arrayidx = getelementptr [8 x i64], ptr %mask, i64 0, i64 %2
  %3 = load i64, ptr %arrayidx, align 8
  %cmp1 = icmp ne i64 %3, -1
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %4 = load i64, ptr %i, align 8
  %inc = add i64 %4, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !140

for.end:                                          ; preds = %for.cond
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %for.end, %if.then
  %5 = load i1, ptr %retval, align 1
  ret i1 %5
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_segment_commit(ptr noundef %segment, ptr noundef %p, i64 noundef %size, ptr noundef %stats) #0 {
entry:
  %retval = alloca i1, align 1
  %segment.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %stats.addr = alloca ptr, align 8
  %start = alloca ptr, align 8
  %full_size = alloca i64, align 8
  %mask = alloca %struct.mi_commit_mask_s, align 8
  %is_zero = alloca i8, align 1
  %cmask = alloca %struct.mi_commit_mask_s, align 8
  store ptr %segment, ptr %segment.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store ptr %stats, ptr %stats.addr, align 8
  store ptr null, ptr %start, align 8
  store i64 0, ptr %full_size, align 8
  %0 = load ptr, ptr %segment.addr, align 8
  %1 = load ptr, ptr %p.addr, align 8
  %2 = load i64, ptr %size.addr, align 8
  call void @mi_segment_commit_mask(ptr noundef %0, i1 noundef zeroext false, ptr noundef %1, i64 noundef %2, ptr noundef %start, ptr noundef %full_size, ptr noundef %mask)
  %call = call zeroext i1 @mi_commit_mask_is_empty(ptr noundef %mask)
  br i1 %call, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %3 = load i64, ptr %full_size, align 8
  %cmp = icmp eq i64 %3, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i1 true, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %4 = load ptr, ptr %segment.addr, align 8
  %commit_mask = getelementptr inbounds %struct.mi_segment_s, ptr %4, i32 0, i32 6
  %call1 = call zeroext i1 @mi_commit_mask_all_set(ptr noundef %commit_mask, ptr noundef %mask)
  br i1 %call1, label %if.end9, label %if.then2

if.then2:                                         ; preds = %if.end
  store i8 0, ptr %is_zero, align 1
  %5 = load ptr, ptr %segment.addr, align 8
  %commit_mask3 = getelementptr inbounds %struct.mi_segment_s, ptr %5, i32 0, i32 6
  call void @mi_commit_mask_create_intersect(ptr noundef %commit_mask3, ptr noundef %mask, ptr noundef %cmask)
  %call4 = call i64 @_mi_commit_mask_committed_size(ptr noundef %cmask, i64 noundef 33554432)
  call void @_mi_stat_decrease(ptr noundef getelementptr inbounds (%struct.mi_stats_s, ptr @_mi_stats_main, i32 0, i32 3), i64 noundef %call4)
  %6 = load ptr, ptr %start, align 8
  %7 = load i64, ptr %full_size, align 8
  %8 = load ptr, ptr %stats.addr, align 8
  %call5 = call zeroext i1 @_mi_os_commit(ptr noundef %6, i64 noundef %7, ptr noundef %is_zero, ptr noundef %8)
  br i1 %call5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %if.then2
  store i1 false, ptr %retval, align 1
  br label %return

if.end7:                                          ; preds = %if.then2
  %9 = load ptr, ptr %segment.addr, align 8
  %commit_mask8 = getelementptr inbounds %struct.mi_segment_s, ptr %9, i32 0, i32 6
  call void @mi_commit_mask_set(ptr noundef %commit_mask8, ptr noundef %mask)
  br label %if.end9

if.end9:                                          ; preds = %if.end7, %if.end
  %10 = load ptr, ptr %segment.addr, align 8
  %purge_mask = getelementptr inbounds %struct.mi_segment_s, ptr %10, i32 0, i32 5
  %call10 = call zeroext i1 @mi_commit_mask_any_set(ptr noundef %purge_mask, ptr noundef %mask)
  br i1 %call10, label %if.then11, label %if.end14

if.then11:                                        ; preds = %if.end9
  %call12 = call i64 @_mi_clock_now()
  %call13 = call i64 @mi_option_get(i32 noundef 15)
  %add = add i64 %call12, %call13
  %11 = load ptr, ptr %segment.addr, align 8
  %purge_expire = getelementptr inbounds %struct.mi_segment_s, ptr %11, i32 0, i32 4
  store i64 %add, ptr %purge_expire, align 8
  br label %if.end14

if.end14:                                         ; preds = %if.then11, %if.end9
  %12 = load ptr, ptr %segment.addr, align 8
  %purge_mask15 = getelementptr inbounds %struct.mi_segment_s, ptr %12, i32 0, i32 5
  call void @mi_commit_mask_clear(ptr noundef %purge_mask15, ptr noundef %mask)
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end14, %if.then6, %if.then
  %13 = load i1, ptr %retval, align 1
  ret i1 %13
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mi_commit_mask_all_set(ptr noundef %commit, ptr noundef %cm) #0 {
entry:
  %retval = alloca i1, align 1
  %commit.addr = alloca ptr, align 8
  %cm.addr = alloca ptr, align 8
  %i = alloca i64, align 8
  store ptr %commit, ptr %commit.addr, align 8
  store ptr %cm, ptr %cm.addr, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load ptr, ptr %commit.addr, align 8
  %mask = getelementptr inbounds %struct.mi_commit_mask_s, ptr %1, i32 0, i32 0
  %2 = load i64, ptr %i, align 8
  %arrayidx = getelementptr [8 x i64], ptr %mask, i64 0, i64 %2
  %3 = load i64, ptr %arrayidx, align 8
  %4 = load ptr, ptr %cm.addr, align 8
  %mask1 = getelementptr inbounds %struct.mi_commit_mask_s, ptr %4, i32 0, i32 0
  %5 = load i64, ptr %i, align 8
  %arrayidx2 = getelementptr [8 x i64], ptr %mask1, i64 0, i64 %5
  %6 = load i64, ptr %arrayidx2, align 8
  %and = and i64 %3, %6
  %7 = load ptr, ptr %cm.addr, align 8
  %mask3 = getelementptr inbounds %struct.mi_commit_mask_s, ptr %7, i32 0, i32 0
  %8 = load i64, ptr %i, align 8
  %arrayidx4 = getelementptr [8 x i64], ptr %mask3, i64 0, i64 %8
  %9 = load i64, ptr %arrayidx4, align 8
  %cmp5 = icmp ne i64 %and, %9
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %10 = load i64, ptr %i, align 8
  %inc = add i64 %10, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !141

for.end:                                          ; preds = %for.cond
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %for.end, %if.then
  %11 = load i1, ptr %retval, align 1
  ret i1 %11
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_segments_page_find_and_allocate(i64 noundef %slice_count, i32 noundef %req_arena_id, ptr noundef %tld) #0 {
entry:
  %retval = alloca ptr, align 8
  %slice_count.addr = alloca i64, align 8
  %req_arena_id.addr = alloca i32, align 4
  %tld.addr = alloca ptr, align 8
  %sq = alloca ptr, align 8
  %slice = alloca ptr, align 8
  %segment = alloca ptr, align 8
  %page = alloca ptr, align 8
  store i64 %slice_count, ptr %slice_count.addr, align 8
  store i32 %req_arena_id, ptr %req_arena_id.addr, align 4
  store ptr %tld, ptr %tld.addr, align 8
  %0 = load i64, ptr %slice_count.addr, align 8
  %1 = load ptr, ptr %tld.addr, align 8
  %call = call ptr @mi_span_queue_for(i64 noundef %0, ptr noundef %1)
  store ptr %call, ptr %sq, align 8
  %2 = load i64, ptr %slice_count.addr, align 8
  %cmp = icmp eq i64 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 1, ptr %slice_count.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  br label %while.cond

while.cond:                                       ; preds = %for.end, %if.end
  %3 = load ptr, ptr %sq, align 8
  %4 = load ptr, ptr %tld.addr, align 8
  %spans = getelementptr inbounds %struct.mi_segments_tld_s, ptr %4, i32 0, i32 0
  %arrayidx = getelementptr [36 x %struct.mi_span_queue_s], ptr %spans, i64 0, i64 35
  %cmp1 = icmp ule ptr %3, %arrayidx
  br i1 %cmp1, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %5 = load ptr, ptr %sq, align 8
  %first = getelementptr inbounds %struct.mi_span_queue_s, ptr %5, i32 0, i32 0
  %6 = load ptr, ptr %first, align 8
  store ptr %6, ptr %slice, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %while.body
  %7 = load ptr, ptr %slice, align 8
  %cmp2 = icmp ne ptr %7, null
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load ptr, ptr %slice, align 8
  %slice_count3 = getelementptr inbounds %struct.mi_page_s, ptr %8, i32 0, i32 0
  %9 = load i32, ptr %slice_count3, align 8
  %conv = zext i32 %9 to i64
  %10 = load i64, ptr %slice_count.addr, align 8
  %cmp4 = icmp uge i64 %conv, %10
  br i1 %cmp4, label %if.then6, label %if.end26

if.then6:                                         ; preds = %for.body
  %11 = load ptr, ptr %slice, align 8
  %call7 = call ptr @_mi_ptr_segment(ptr noundef %11)
  store ptr %call7, ptr %segment, align 8
  %12 = load ptr, ptr %segment, align 8
  %memid = getelementptr inbounds %struct.mi_segment_s, ptr %12, i32 0, i32 0
  %13 = load i32, ptr %req_arena_id.addr, align 4
  %call8 = call zeroext i1 @_mi_arena_memid_is_suitable(ptr noundef byval(%struct.mi_memid_s) align 8 %memid, i32 noundef %13)
  br i1 %call8, label %if.then9, label %if.end25

if.then9:                                         ; preds = %if.then6
  %14 = load ptr, ptr %sq, align 8
  %15 = load ptr, ptr %slice, align 8
  call void @mi_span_queue_delete(ptr noundef %14, ptr noundef %15)
  %16 = load ptr, ptr %slice, align 8
  %slice_count10 = getelementptr inbounds %struct.mi_page_s, ptr %16, i32 0, i32 0
  %17 = load i32, ptr %slice_count10, align 8
  %conv11 = zext i32 %17 to i64
  %18 = load i64, ptr %slice_count.addr, align 8
  %cmp12 = icmp ugt i64 %conv11, %18
  br i1 %cmp12, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.then9
  %19 = load ptr, ptr %segment, align 8
  %20 = load ptr, ptr %slice, align 8
  %21 = load i64, ptr %slice_count.addr, align 8
  %22 = load ptr, ptr %tld.addr, align 8
  call void @mi_segment_slice_split(ptr noundef %19, ptr noundef %20, i64 noundef %21, ptr noundef %22)
  br label %if.end15

if.end15:                                         ; preds = %if.then14, %if.then9
  %23 = load ptr, ptr %segment, align 8
  %24 = load ptr, ptr %slice, align 8
  %call16 = call i64 @mi_slice_index(ptr noundef %24)
  %25 = load ptr, ptr %slice, align 8
  %slice_count17 = getelementptr inbounds %struct.mi_page_s, ptr %25, i32 0, i32 0
  %26 = load i32, ptr %slice_count17, align 8
  %conv18 = zext i32 %26 to i64
  %27 = load ptr, ptr %tld.addr, align 8
  %call19 = call ptr @mi_segment_span_allocate(ptr noundef %23, i64 noundef %call16, i64 noundef %conv18, ptr noundef %27)
  store ptr %call19, ptr %page, align 8
  %28 = load ptr, ptr %page, align 8
  %cmp20 = icmp eq ptr %28, null
  br i1 %cmp20, label %if.then22, label %if.end24

if.then22:                                        ; preds = %if.end15
  %29 = load ptr, ptr %slice, align 8
  %30 = load ptr, ptr %tld.addr, align 8
  %call23 = call ptr @mi_segment_span_free_coalesce(ptr noundef %29, ptr noundef %30)
  store ptr null, ptr %retval, align 8
  br label %return

if.end24:                                         ; preds = %if.end15
  %31 = load ptr, ptr %page, align 8
  store ptr %31, ptr %retval, align 8
  br label %return

if.end25:                                         ; preds = %if.then6
  br label %if.end26

if.end26:                                         ; preds = %if.end25, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end26
  %32 = load ptr, ptr %slice, align 8
  %next = getelementptr inbounds %struct.mi_page_s, ptr %32, i32 0, i32 13
  %33 = load ptr, ptr %next, align 8
  store ptr %33, ptr %slice, align 8
  br label %for.cond, !llvm.loop !142

for.end:                                          ; preds = %for.cond
  %34 = load ptr, ptr %sq, align 8
  %incdec.ptr = getelementptr %struct.mi_span_queue_s, ptr %34, i32 1
  store ptr %incdec.ptr, ptr %sq, align 8
  br label %while.cond, !llvm.loop !143

while.end:                                        ; preds = %while.cond
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %while.end, %if.end24, %if.then22
  %35 = load ptr, ptr %retval, align 8
  ret ptr %35
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_segment_reclaim_or_alloc(ptr noundef %heap, i64 noundef %needed_slices, i64 noundef %block_size, ptr noundef %tld, ptr noundef %os_tld) #0 {
entry:
  %retval = alloca ptr, align 8
  %heap.addr = alloca ptr, align 8
  %needed_slices.addr = alloca i64, align 8
  %block_size.addr = alloca i64, align 8
  %tld.addr = alloca ptr, align 8
  %os_tld.addr = alloca ptr, align 8
  %reclaimed = alloca i8, align 1
  %segment = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store i64 %needed_slices, ptr %needed_slices.addr, align 8
  store i64 %block_size, ptr %block_size.addr, align 8
  store ptr %tld, ptr %tld.addr, align 8
  store ptr %os_tld, ptr %os_tld.addr, align 8
  %0 = load ptr, ptr %heap.addr, align 8
  %1 = load i64, ptr %needed_slices.addr, align 8
  %2 = load i64, ptr %block_size.addr, align 8
  %3 = load ptr, ptr %tld.addr, align 8
  %call = call ptr @mi_segment_try_reclaim(ptr noundef %0, i64 noundef %1, i64 noundef %2, ptr noundef %reclaimed, ptr noundef %3)
  store ptr %call, ptr %segment, align 8
  %4 = load i8, ptr %reclaimed, align 1
  %tobool = trunc i8 %4 to i1
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %5 = load ptr, ptr %segment, align 8
  %cmp = icmp ne ptr %5, null
  br i1 %cmp, label %if.then1, label %if.end

if.then1:                                         ; preds = %if.else
  %6 = load ptr, ptr %segment, align 8
  store ptr %6, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %if.else
  br label %if.end2

if.end2:                                          ; preds = %if.end
  %7 = load ptr, ptr %heap.addr, align 8
  %arena_id = getelementptr inbounds %struct.mi_heap_s, ptr %7, i32 0, i32 5
  %8 = load i32, ptr %arena_id, align 8
  %9 = load ptr, ptr %tld.addr, align 8
  %10 = load ptr, ptr %os_tld.addr, align 8
  %call3 = call ptr @mi_segment_alloc(i64 noundef 0, i64 noundef 0, i32 noundef %8, ptr noundef %9, ptr noundef %10, ptr noundef null)
  store ptr %call3, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end2, %if.then1, %if.then
  %11 = load ptr, ptr %retval, align 8
  ret ptr %11
}

; Function Attrs: nounwind uwtable
define internal void @mi_segment_slice_split(ptr noundef %segment, ptr noundef %slice, i64 noundef %slice_count, ptr noundef %tld) #0 {
entry:
  %segment.addr = alloca ptr, align 8
  %slice.addr = alloca ptr, align 8
  %slice_count.addr = alloca i64, align 8
  %tld.addr = alloca ptr, align 8
  %next_index = alloca i64, align 8
  %next_count = alloca i64, align 8
  store ptr %segment, ptr %segment.addr, align 8
  store ptr %slice, ptr %slice.addr, align 8
  store i64 %slice_count, ptr %slice_count.addr, align 8
  store ptr %tld, ptr %tld.addr, align 8
  %0 = load ptr, ptr %slice.addr, align 8
  %slice_count1 = getelementptr inbounds %struct.mi_page_s, ptr %0, i32 0, i32 0
  %1 = load i32, ptr %slice_count1, align 8
  %conv = zext i32 %1 to i64
  %2 = load i64, ptr %slice_count.addr, align 8
  %cmp = icmp ule i64 %conv, %2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %slice.addr, align 8
  %call = call i64 @mi_slice_index(ptr noundef %3)
  %4 = load i64, ptr %slice_count.addr, align 8
  %add = add i64 %call, %4
  store i64 %add, ptr %next_index, align 8
  %5 = load ptr, ptr %slice.addr, align 8
  %slice_count3 = getelementptr inbounds %struct.mi_page_s, ptr %5, i32 0, i32 0
  %6 = load i32, ptr %slice_count3, align 8
  %conv4 = zext i32 %6 to i64
  %7 = load i64, ptr %slice_count.addr, align 8
  %sub = sub i64 %conv4, %7
  store i64 %sub, ptr %next_count, align 8
  %8 = load ptr, ptr %segment.addr, align 8
  %9 = load i64, ptr %next_index, align 8
  %10 = load i64, ptr %next_count, align 8
  %11 = load ptr, ptr %tld.addr, align 8
  call void @mi_segment_span_free(ptr noundef %8, i64 noundef %9, i64 noundef %10, i1 noundef zeroext false, ptr noundef %11)
  %12 = load i64, ptr %slice_count.addr, align 8
  %conv5 = trunc i64 %12 to i32
  %13 = load ptr, ptr %slice.addr, align 8
  %slice_count6 = getelementptr inbounds %struct.mi_page_s, ptr %13, i32 0, i32 0
  store i32 %conv5, ptr %slice_count6, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal ptr @mi_segment_try_reclaim(ptr noundef %heap, i64 noundef %needed_slices, i64 noundef %block_size, ptr noundef %reclaimed, ptr noundef %tld) #0 {
entry:
  %retval = alloca ptr, align 8
  %heap.addr = alloca ptr, align 8
  %needed_slices.addr = alloca i64, align 8
  %block_size.addr = alloca i64, align 8
  %reclaimed.addr = alloca ptr, align 8
  %tld.addr = alloca ptr, align 8
  %segment = alloca ptr, align 8
  %max_tries = alloca i64, align 8
  %is_suitable = alloca i8, align 1
  %has_page = alloca i8, align 1
  store ptr %heap, ptr %heap.addr, align 8
  store i64 %needed_slices, ptr %needed_slices.addr, align 8
  store i64 %block_size, ptr %block_size.addr, align 8
  store ptr %reclaimed, ptr %reclaimed.addr, align 8
  store ptr %tld, ptr %tld.addr, align 8
  %0 = load ptr, ptr %reclaimed.addr, align 8
  store i8 0, ptr %0, align 1
  %call = call i64 @mi_option_get_clamp(i32 noundef 21, i64 noundef 8, i64 noundef 1024)
  store i64 %call, ptr %max_tries, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end20, %entry
  %1 = load i64, ptr %max_tries, align 8
  %dec = add i64 %1, -1
  store i64 %dec, ptr %max_tries, align 8
  %cmp = icmp sgt i64 %1, 0
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %call1 = call ptr @mi_abandoned_pop()
  store ptr %call1, ptr %segment, align 8
  %cmp2 = icmp ne ptr %call1, null
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %2 = phi i1 [ false, %while.cond ], [ %cmp2, %land.rhs ]
  br i1 %2, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %3 = load ptr, ptr %segment, align 8
  %abandoned_visits = getelementptr inbounds %struct.mi_segment_s, ptr %3, i32 0, i32 10
  %4 = load i64, ptr %abandoned_visits, align 8
  %inc = add i64 %4, 1
  store i64 %inc, ptr %abandoned_visits, align 8
  %5 = load ptr, ptr %heap.addr, align 8
  %6 = load ptr, ptr %segment, align 8
  %memid = getelementptr inbounds %struct.mi_segment_s, ptr %6, i32 0, i32 0
  %call3 = call zeroext i1 @_mi_heap_memid_is_suitable(ptr noundef %5, ptr noundef byval(%struct.mi_memid_s) align 8 %memid)
  %frombool = zext i1 %call3 to i8
  store i8 %frombool, ptr %is_suitable, align 1
  %7 = load ptr, ptr %segment, align 8
  %8 = load i64, ptr %needed_slices.addr, align 8
  %9 = load i64, ptr %block_size.addr, align 8
  %10 = load ptr, ptr %tld.addr, align 8
  %call4 = call zeroext i1 @mi_segment_check_free(ptr noundef %7, i64 noundef %8, i64 noundef %9, ptr noundef %10)
  %frombool5 = zext i1 %call4 to i8
  store i8 %frombool5, ptr %has_page, align 1
  %11 = load ptr, ptr %segment, align 8
  %used = getelementptr inbounds %struct.mi_segment_s, ptr %11, i32 0, i32 11
  %12 = load i64, ptr %used, align 8
  %cmp6 = icmp eq i64 %12, 0
  br i1 %cmp6, label %if.then, label %if.else

if.then:                                          ; preds = %while.body
  %13 = load ptr, ptr %segment, align 8
  %14 = load ptr, ptr %heap.addr, align 8
  %15 = load ptr, ptr %tld.addr, align 8
  %call7 = call ptr @mi_segment_reclaim(ptr noundef %13, ptr noundef %14, i64 noundef 0, ptr noundef null, ptr noundef %15)
  br label %if.end20

if.else:                                          ; preds = %while.body
  %16 = load i8, ptr %has_page, align 1
  %tobool = trunc i8 %16 to i1
  br i1 %tobool, label %land.lhs.true, label %if.else11

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, ptr %is_suitable, align 1
  %tobool8 = trunc i8 %17 to i1
  br i1 %tobool8, label %if.then9, label %if.else11

if.then9:                                         ; preds = %land.lhs.true
  %18 = load ptr, ptr %segment, align 8
  %19 = load ptr, ptr %heap.addr, align 8
  %20 = load i64, ptr %block_size.addr, align 8
  %21 = load ptr, ptr %reclaimed.addr, align 8
  %22 = load ptr, ptr %tld.addr, align 8
  %call10 = call ptr @mi_segment_reclaim(ptr noundef %18, ptr noundef %19, i64 noundef %20, ptr noundef %21, ptr noundef %22)
  store ptr %call10, ptr %retval, align 8
  br label %return

if.else11:                                        ; preds = %land.lhs.true, %if.else
  %23 = load ptr, ptr %segment, align 8
  %abandoned_visits12 = getelementptr inbounds %struct.mi_segment_s, ptr %23, i32 0, i32 10
  %24 = load i64, ptr %abandoned_visits12, align 8
  %cmp13 = icmp ugt i64 %24, 3
  br i1 %cmp13, label %land.lhs.true14, label %if.else18

land.lhs.true14:                                  ; preds = %if.else11
  %25 = load i8, ptr %is_suitable, align 1
  %tobool15 = trunc i8 %25 to i1
  br i1 %tobool15, label %if.then16, label %if.else18

if.then16:                                        ; preds = %land.lhs.true14
  %26 = load ptr, ptr %segment, align 8
  %27 = load ptr, ptr %heap.addr, align 8
  %28 = load ptr, ptr %tld.addr, align 8
  %call17 = call ptr @mi_segment_reclaim(ptr noundef %26, ptr noundef %27, i64 noundef 0, ptr noundef null, ptr noundef %28)
  br label %if.end

if.else18:                                        ; preds = %land.lhs.true14, %if.else11
  %29 = load ptr, ptr %segment, align 8
  %30 = load ptr, ptr %tld.addr, align 8
  %stats = getelementptr inbounds %struct.mi_segments_tld_s, ptr %30, i32 0, i32 5
  %31 = load ptr, ptr %stats, align 8
  call void @mi_segment_try_purge(ptr noundef %29, i1 noundef zeroext true, ptr noundef %31)
  %32 = load ptr, ptr %segment, align 8
  call void @mi_abandoned_visited_push(ptr noundef %32)
  br label %if.end

if.end:                                           ; preds = %if.else18, %if.then16
  br label %if.end19

if.end19:                                         ; preds = %if.end
  br label %if.end20

if.end20:                                         ; preds = %if.end19, %if.then
  br label %while.cond, !llvm.loop !144

while.end:                                        ; preds = %land.end
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %while.end, %if.then9
  %33 = load ptr, ptr %retval, align 8
  ret ptr %33
}

; Function Attrs: nounwind uwtable
define internal ptr @_mi_segment_of(ptr noundef %p) #0 {
entry:
  %retval = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %segment = alloca ptr, align 8
  %bitidx = alloca i64, align 8
  %index = alloca i64, align 8
  %mask = alloca i64, align 8
  %atomic-temp = alloca i64, align 8
  %lobitidx = alloca i64, align 8
  %loindex = alloca i64, align 8
  %lobits = alloca i64, align 8
  %lomask = alloca i64, align 8
  %atomic-temp21 = alloca i64, align 8
  %diff = alloca i64, align 8
  %cookie_ok = alloca i8, align 1
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %p.addr, align 8
  %call = call ptr @_mi_ptr_segment(ptr noundef %1)
  store ptr %call, ptr %segment, align 8
  %2 = load ptr, ptr %segment, align 8
  %call1 = call i64 @mi_segment_map_index_of(ptr noundef %2, ptr noundef %bitidx)
  store i64 %call1, ptr %index, align 8
  %3 = load i64, ptr %index, align 8
  %arrayidx = getelementptr [20481 x i64], ptr @mi_segment_map, i64 0, i64 %3
  %4 = load atomic i64, ptr %arrayidx monotonic, align 8
  store i64 %4, ptr %atomic-temp, align 8
  %5 = load i64, ptr %atomic-temp, align 8
  store i64 %5, ptr %mask, align 8
  %6 = load i64, ptr %mask, align 8
  %7 = load i64, ptr %bitidx, align 8
  %shl = shl i64 1, %7
  %and = and i64 %6, %shl
  %cmp2 = icmp ne i64 %and, 0
  %lnot = xor i1 %cmp2, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  %8 = load ptr, ptr %segment, align 8
  store ptr %8, ptr %retval, align 8
  br label %return

if.end5:                                          ; preds = %if.end
  %9 = load i64, ptr %index, align 8
  %cmp6 = icmp eq i64 %9, 20480
  br i1 %cmp6, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end5
  store ptr null, ptr %retval, align 8
  br label %return

if.end9:                                          ; preds = %if.end5
  %10 = load i64, ptr %mask, align 8
  %11 = load i64, ptr %bitidx, align 8
  %shl10 = shl i64 1, %11
  %sub = sub i64 %shl10, 1
  %and11 = and i64 %10, %sub
  store i64 %and11, ptr %lobits, align 8
  %12 = load i64, ptr %lobits, align 8
  %cmp12 = icmp ne i64 %12, 0
  br i1 %cmp12, label %if.then14, label %if.else

if.then14:                                        ; preds = %if.end9
  %13 = load i64, ptr %index, align 8
  store i64 %13, ptr %loindex, align 8
  %14 = load i64, ptr %lobits, align 8
  %call15 = call i64 @mi_bsr(i64 noundef %14)
  store i64 %call15, ptr %lobitidx, align 8
  br label %if.end32

if.else:                                          ; preds = %if.end9
  %15 = load i64, ptr %index, align 8
  %cmp16 = icmp eq i64 %15, 0
  br i1 %cmp16, label %if.then18, label %if.else19

if.then18:                                        ; preds = %if.else
  store ptr null, ptr %retval, align 8
  br label %return

if.else19:                                        ; preds = %if.else
  %16 = load i64, ptr %mask, align 8
  store i64 %16, ptr %lomask, align 8
  %17 = load i64, ptr %index, align 8
  store i64 %17, ptr %loindex, align 8
  br label %do.body

do.body:                                          ; preds = %land.end, %if.else19
  %18 = load i64, ptr %loindex, align 8
  %dec = add i64 %18, -1
  store i64 %dec, ptr %loindex, align 8
  %19 = load i64, ptr %loindex, align 8
  %arrayidx20 = getelementptr [20481 x i64], ptr @mi_segment_map, i64 0, i64 %19
  %20 = load atomic i64, ptr %arrayidx20 monotonic, align 8
  store i64 %20, ptr %atomic-temp21, align 8
  %21 = load i64, ptr %atomic-temp21, align 8
  store i64 %21, ptr %lomask, align 8
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %22 = load i64, ptr %lomask, align 8
  %cmp22 = icmp ne i64 %22, 0
  br i1 %cmp22, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %do.cond
  %23 = load i64, ptr %loindex, align 8
  %cmp24 = icmp ugt i64 %23, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %do.cond
  %24 = phi i1 [ false, %do.cond ], [ %cmp24, %land.rhs ]
  br i1 %24, label %do.body, label %do.end, !llvm.loop !145

do.end:                                           ; preds = %land.end
  %25 = load i64, ptr %lomask, align 8
  %cmp26 = icmp eq i64 %25, 0
  br i1 %cmp26, label %if.then28, label %if.end29

if.then28:                                        ; preds = %do.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end29:                                         ; preds = %do.end
  %26 = load i64, ptr %lomask, align 8
  %call30 = call i64 @mi_bsr(i64 noundef %26)
  store i64 %call30, ptr %lobitidx, align 8
  br label %if.end31

if.end31:                                         ; preds = %if.end29
  br label %if.end32

if.end32:                                         ; preds = %if.end31, %if.then14
  %27 = load i64, ptr %index, align 8
  %28 = load i64, ptr %loindex, align 8
  %sub33 = sub i64 %27, %28
  %mul = mul i64 %sub33, 64
  %29 = load i64, ptr %bitidx, align 8
  %add = add i64 %mul, %29
  %30 = load i64, ptr %lobitidx, align 8
  %sub34 = sub i64 %add, %30
  %mul35 = mul i64 %sub34, 33554432
  store i64 %mul35, ptr %diff, align 8
  %31 = load ptr, ptr %segment, align 8
  %32 = load i64, ptr %diff, align 8
  %idx.neg = sub i64 0, %32
  %add.ptr = getelementptr i8, ptr %31, i64 %idx.neg
  store ptr %add.ptr, ptr %segment, align 8
  %33 = load ptr, ptr %segment, align 8
  %cmp36 = icmp eq ptr %33, null
  br i1 %cmp36, label %if.then38, label %if.end39

if.then38:                                        ; preds = %if.end32
  store ptr null, ptr %retval, align 8
  br label %return

if.end39:                                         ; preds = %if.end32
  %34 = load ptr, ptr %segment, align 8
  %call40 = call i64 @_mi_ptr_cookie(ptr noundef %34)
  %35 = load ptr, ptr %segment, align 8
  %cookie = getelementptr inbounds %struct.mi_segment_s, ptr %35, i32 0, i32 12
  %36 = load i64, ptr %cookie, align 8
  %cmp41 = icmp eq i64 %call40, %36
  %frombool = zext i1 %cmp41 to i8
  store i8 %frombool, ptr %cookie_ok, align 1
  %37 = load i8, ptr %cookie_ok, align 1
  %tobool43 = trunc i8 %37 to i1
  %lnot44 = xor i1 %tobool43, true
  %lnot46 = xor i1 %lnot44, true
  %lnot48 = xor i1 %lnot46, true
  %lnot.ext49 = zext i1 %lnot48 to i32
  %conv50 = sext i32 %lnot.ext49 to i64
  %tobool51 = icmp ne i64 %conv50, 0
  br i1 %tobool51, label %if.then52, label %if.end53

if.then52:                                        ; preds = %if.end39
  store ptr null, ptr %retval, align 8
  br label %return

if.end53:                                         ; preds = %if.end39
  %38 = load ptr, ptr %segment, align 8
  %39 = load ptr, ptr %segment, align 8
  %call54 = call i64 @mi_segment_size(ptr noundef %39)
  %add.ptr55 = getelementptr i8, ptr %38, i64 %call54
  %40 = load ptr, ptr %p.addr, align 8
  %cmp56 = icmp ule ptr %add.ptr55, %40
  br i1 %cmp56, label %if.then58, label %if.end59

if.then58:                                        ; preds = %if.end53
  store ptr null, ptr %retval, align 8
  br label %return

if.end59:                                         ; preds = %if.end53
  %41 = load ptr, ptr %segment, align 8
  store ptr %41, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end59, %if.then58, %if.then52, %if.then38, %if.then28, %if.then18, %if.then8, %if.then4, %if.then
  %42 = load ptr, ptr %retval, align 8
  ret ptr %42
}

; Function Attrs: nounwind uwtable
define internal void @mi_atomic_maxi64_relaxed(ptr noundef %p, i64 noundef %x) #0 {
entry:
  %p.addr = alloca ptr, align 8
  %x.addr = alloca i64, align 8
  %current = alloca i64, align 8
  %atomic-temp = alloca i64, align 8
  %.atomictmp = alloca i64, align 8
  %cmpxchg.bool = alloca i8, align 1
  store ptr %p, ptr %p.addr, align 8
  store i64 %x, ptr %x.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %1 = load atomic i64, ptr %0 monotonic, align 8
  store i64 %1, ptr %atomic-temp, align 8
  %2 = load i64, ptr %atomic-temp, align 8
  store i64 %2, ptr %current, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %3 = load i64, ptr %current, align 8
  %4 = load i64, ptr %x.addr, align 8
  %cmp = icmp slt i64 %3, %4
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %5 = load ptr, ptr %p.addr, align 8
  %6 = load i64, ptr %x.addr, align 8
  store i64 %6, ptr %.atomictmp, align 8
  %7 = load i64, ptr %current, align 8
  %8 = load i64, ptr %.atomictmp, align 8
  %9 = cmpxchg weak ptr %5, i64 %7, i64 %8 release monotonic, align 8
  %10 = extractvalue { i64, i1 } %9, 0
  %11 = extractvalue { i64, i1 } %9, 1
  br i1 %11, label %cmpxchg.continue, label %cmpxchg.store_expected

cmpxchg.store_expected:                           ; preds = %land.rhs
  store i64 %10, ptr %current, align 8
  br label %cmpxchg.continue

cmpxchg.continue:                                 ; preds = %cmpxchg.store_expected, %land.rhs
  %frombool = zext i1 %11 to i8
  store i8 %frombool, ptr %cmpxchg.bool, align 1
  %12 = load i8, ptr %cmpxchg.bool, align 1
  %tobool = trunc i8 %12 to i1
  %lnot = xor i1 %tobool, true
  br label %land.end

land.end:                                         ; preds = %cmpxchg.continue, %while.cond
  %13 = phi i1 [ false, %while.cond ], [ %lnot, %cmpxchg.continue ]
  br i1 %13, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  br label %while.cond, !llvm.loop !146

while.end:                                        ; preds = %land.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_stats_add(ptr noundef %stats, ptr noundef %src) #0 {
entry:
  %stats.addr = alloca ptr, align 8
  %src.addr = alloca ptr, align 8
  store ptr %stats, ptr %stats.addr, align 8
  store ptr %src, ptr %src.addr, align 8
  %0 = load ptr, ptr %stats.addr, align 8
  %1 = load ptr, ptr %src.addr, align 8
  %cmp = icmp eq ptr %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %stats.addr, align 8
  %segments = getelementptr inbounds %struct.mi_stats_s, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %src.addr, align 8
  %segments1 = getelementptr inbounds %struct.mi_stats_s, ptr %3, i32 0, i32 0
  call void @mi_stat_add(ptr noundef %segments, ptr noundef %segments1, i64 noundef 1)
  %4 = load ptr, ptr %stats.addr, align 8
  %pages = getelementptr inbounds %struct.mi_stats_s, ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %src.addr, align 8
  %pages2 = getelementptr inbounds %struct.mi_stats_s, ptr %5, i32 0, i32 1
  call void @mi_stat_add(ptr noundef %pages, ptr noundef %pages2, i64 noundef 1)
  %6 = load ptr, ptr %stats.addr, align 8
  %reserved = getelementptr inbounds %struct.mi_stats_s, ptr %6, i32 0, i32 2
  %7 = load ptr, ptr %src.addr, align 8
  %reserved3 = getelementptr inbounds %struct.mi_stats_s, ptr %7, i32 0, i32 2
  call void @mi_stat_add(ptr noundef %reserved, ptr noundef %reserved3, i64 noundef 1)
  %8 = load ptr, ptr %stats.addr, align 8
  %committed = getelementptr inbounds %struct.mi_stats_s, ptr %8, i32 0, i32 3
  %9 = load ptr, ptr %src.addr, align 8
  %committed4 = getelementptr inbounds %struct.mi_stats_s, ptr %9, i32 0, i32 3
  call void @mi_stat_add(ptr noundef %committed, ptr noundef %committed4, i64 noundef 1)
  %10 = load ptr, ptr %stats.addr, align 8
  %reset = getelementptr inbounds %struct.mi_stats_s, ptr %10, i32 0, i32 4
  %11 = load ptr, ptr %src.addr, align 8
  %reset5 = getelementptr inbounds %struct.mi_stats_s, ptr %11, i32 0, i32 4
  call void @mi_stat_add(ptr noundef %reset, ptr noundef %reset5, i64 noundef 1)
  %12 = load ptr, ptr %stats.addr, align 8
  %purged = getelementptr inbounds %struct.mi_stats_s, ptr %12, i32 0, i32 5
  %13 = load ptr, ptr %src.addr, align 8
  %purged6 = getelementptr inbounds %struct.mi_stats_s, ptr %13, i32 0, i32 5
  call void @mi_stat_add(ptr noundef %purged, ptr noundef %purged6, i64 noundef 1)
  %14 = load ptr, ptr %stats.addr, align 8
  %page_committed = getelementptr inbounds %struct.mi_stats_s, ptr %14, i32 0, i32 6
  %15 = load ptr, ptr %src.addr, align 8
  %page_committed7 = getelementptr inbounds %struct.mi_stats_s, ptr %15, i32 0, i32 6
  call void @mi_stat_add(ptr noundef %page_committed, ptr noundef %page_committed7, i64 noundef 1)
  %16 = load ptr, ptr %stats.addr, align 8
  %pages_abandoned = getelementptr inbounds %struct.mi_stats_s, ptr %16, i32 0, i32 8
  %17 = load ptr, ptr %src.addr, align 8
  %pages_abandoned8 = getelementptr inbounds %struct.mi_stats_s, ptr %17, i32 0, i32 8
  call void @mi_stat_add(ptr noundef %pages_abandoned, ptr noundef %pages_abandoned8, i64 noundef 1)
  %18 = load ptr, ptr %stats.addr, align 8
  %segments_abandoned = getelementptr inbounds %struct.mi_stats_s, ptr %18, i32 0, i32 7
  %19 = load ptr, ptr %src.addr, align 8
  %segments_abandoned9 = getelementptr inbounds %struct.mi_stats_s, ptr %19, i32 0, i32 7
  call void @mi_stat_add(ptr noundef %segments_abandoned, ptr noundef %segments_abandoned9, i64 noundef 1)
  %20 = load ptr, ptr %stats.addr, align 8
  %threads = getelementptr inbounds %struct.mi_stats_s, ptr %20, i32 0, i32 9
  %21 = load ptr, ptr %src.addr, align 8
  %threads10 = getelementptr inbounds %struct.mi_stats_s, ptr %21, i32 0, i32 9
  call void @mi_stat_add(ptr noundef %threads, ptr noundef %threads10, i64 noundef 1)
  %22 = load ptr, ptr %stats.addr, align 8
  %malloc = getelementptr inbounds %struct.mi_stats_s, ptr %22, i32 0, i32 13
  %23 = load ptr, ptr %src.addr, align 8
  %malloc11 = getelementptr inbounds %struct.mi_stats_s, ptr %23, i32 0, i32 13
  call void @mi_stat_add(ptr noundef %malloc, ptr noundef %malloc11, i64 noundef 1)
  %24 = load ptr, ptr %stats.addr, align 8
  %segments_cache = getelementptr inbounds %struct.mi_stats_s, ptr %24, i32 0, i32 14
  %25 = load ptr, ptr %src.addr, align 8
  %segments_cache12 = getelementptr inbounds %struct.mi_stats_s, ptr %25, i32 0, i32 14
  call void @mi_stat_add(ptr noundef %segments_cache, ptr noundef %segments_cache12, i64 noundef 1)
  %26 = load ptr, ptr %stats.addr, align 8
  %normal = getelementptr inbounds %struct.mi_stats_s, ptr %26, i32 0, i32 10
  %27 = load ptr, ptr %src.addr, align 8
  %normal13 = getelementptr inbounds %struct.mi_stats_s, ptr %27, i32 0, i32 10
  call void @mi_stat_add(ptr noundef %normal, ptr noundef %normal13, i64 noundef 1)
  %28 = load ptr, ptr %stats.addr, align 8
  %huge = getelementptr inbounds %struct.mi_stats_s, ptr %28, i32 0, i32 11
  %29 = load ptr, ptr %src.addr, align 8
  %huge14 = getelementptr inbounds %struct.mi_stats_s, ptr %29, i32 0, i32 11
  call void @mi_stat_add(ptr noundef %huge, ptr noundef %huge14, i64 noundef 1)
  %30 = load ptr, ptr %stats.addr, align 8
  %large = getelementptr inbounds %struct.mi_stats_s, ptr %30, i32 0, i32 12
  %31 = load ptr, ptr %src.addr, align 8
  %large15 = getelementptr inbounds %struct.mi_stats_s, ptr %31, i32 0, i32 12
  call void @mi_stat_add(ptr noundef %large, ptr noundef %large15, i64 noundef 1)
  %32 = load ptr, ptr %stats.addr, align 8
  %pages_extended = getelementptr inbounds %struct.mi_stats_s, ptr %32, i32 0, i32 15
  %33 = load ptr, ptr %src.addr, align 8
  %pages_extended16 = getelementptr inbounds %struct.mi_stats_s, ptr %33, i32 0, i32 15
  call void @mi_stat_counter_add(ptr noundef %pages_extended, ptr noundef %pages_extended16, i64 noundef 1)
  %34 = load ptr, ptr %stats.addr, align 8
  %mmap_calls = getelementptr inbounds %struct.mi_stats_s, ptr %34, i32 0, i32 16
  %35 = load ptr, ptr %src.addr, align 8
  %mmap_calls17 = getelementptr inbounds %struct.mi_stats_s, ptr %35, i32 0, i32 16
  call void @mi_stat_counter_add(ptr noundef %mmap_calls, ptr noundef %mmap_calls17, i64 noundef 1)
  %36 = load ptr, ptr %stats.addr, align 8
  %commit_calls = getelementptr inbounds %struct.mi_stats_s, ptr %36, i32 0, i32 17
  %37 = load ptr, ptr %src.addr, align 8
  %commit_calls18 = getelementptr inbounds %struct.mi_stats_s, ptr %37, i32 0, i32 17
  call void @mi_stat_counter_add(ptr noundef %commit_calls, ptr noundef %commit_calls18, i64 noundef 1)
  %38 = load ptr, ptr %stats.addr, align 8
  %reset_calls = getelementptr inbounds %struct.mi_stats_s, ptr %38, i32 0, i32 18
  %39 = load ptr, ptr %src.addr, align 8
  %reset_calls19 = getelementptr inbounds %struct.mi_stats_s, ptr %39, i32 0, i32 18
  call void @mi_stat_counter_add(ptr noundef %reset_calls, ptr noundef %reset_calls19, i64 noundef 1)
  %40 = load ptr, ptr %stats.addr, align 8
  %purge_calls = getelementptr inbounds %struct.mi_stats_s, ptr %40, i32 0, i32 19
  %41 = load ptr, ptr %src.addr, align 8
  %purge_calls20 = getelementptr inbounds %struct.mi_stats_s, ptr %41, i32 0, i32 19
  call void @mi_stat_counter_add(ptr noundef %purge_calls, ptr noundef %purge_calls20, i64 noundef 1)
  %42 = load ptr, ptr %stats.addr, align 8
  %page_no_retire = getelementptr inbounds %struct.mi_stats_s, ptr %42, i32 0, i32 20
  %43 = load ptr, ptr %src.addr, align 8
  %page_no_retire21 = getelementptr inbounds %struct.mi_stats_s, ptr %43, i32 0, i32 20
  call void @mi_stat_counter_add(ptr noundef %page_no_retire, ptr noundef %page_no_retire21, i64 noundef 1)
  %44 = load ptr, ptr %stats.addr, align 8
  %searches = getelementptr inbounds %struct.mi_stats_s, ptr %44, i32 0, i32 21
  %45 = load ptr, ptr %src.addr, align 8
  %searches22 = getelementptr inbounds %struct.mi_stats_s, ptr %45, i32 0, i32 21
  call void @mi_stat_counter_add(ptr noundef %searches, ptr noundef %searches22, i64 noundef 1)
  %46 = load ptr, ptr %stats.addr, align 8
  %normal_count = getelementptr inbounds %struct.mi_stats_s, ptr %46, i32 0, i32 22
  %47 = load ptr, ptr %src.addr, align 8
  %normal_count23 = getelementptr inbounds %struct.mi_stats_s, ptr %47, i32 0, i32 22
  call void @mi_stat_counter_add(ptr noundef %normal_count, ptr noundef %normal_count23, i64 noundef 1)
  %48 = load ptr, ptr %stats.addr, align 8
  %huge_count = getelementptr inbounds %struct.mi_stats_s, ptr %48, i32 0, i32 23
  %49 = load ptr, ptr %src.addr, align 8
  %huge_count24 = getelementptr inbounds %struct.mi_stats_s, ptr %49, i32 0, i32 23
  call void @mi_stat_counter_add(ptr noundef %huge_count, ptr noundef %huge_count24, i64 noundef 1)
  %50 = load ptr, ptr %stats.addr, align 8
  %large_count = getelementptr inbounds %struct.mi_stats_s, ptr %50, i32 0, i32 24
  %51 = load ptr, ptr %src.addr, align 8
  %large_count25 = getelementptr inbounds %struct.mi_stats_s, ptr %51, i32 0, i32 24
  call void @mi_stat_counter_add(ptr noundef %large_count, ptr noundef %large_count25, i64 noundef 1)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_stat_add(ptr noundef %stat, ptr noundef %src, i64 noundef %unit) #0 {
entry:
  %stat.addr = alloca ptr, align 8
  %src.addr = alloca ptr, align 8
  %unit.addr = alloca i64, align 8
  store ptr %stat, ptr %stat.addr, align 8
  store ptr %src, ptr %src.addr, align 8
  store i64 %unit, ptr %unit.addr, align 8
  %0 = load ptr, ptr %stat.addr, align 8
  %1 = load ptr, ptr %src.addr, align 8
  %cmp = icmp eq ptr %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %src.addr, align 8
  %allocated = getelementptr inbounds %struct.mi_stat_count_s, ptr %2, i32 0, i32 0
  %3 = load i64, ptr %allocated, align 8
  %cmp1 = icmp eq i64 %3, 0
  br i1 %cmp1, label %land.lhs.true, label %if.end4

land.lhs.true:                                    ; preds = %if.end
  %4 = load ptr, ptr %src.addr, align 8
  %freed = getelementptr inbounds %struct.mi_stat_count_s, ptr %4, i32 0, i32 1
  %5 = load i64, ptr %freed, align 8
  %cmp2 = icmp eq i64 %5, 0
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %land.lhs.true
  br label %return

if.end4:                                          ; preds = %land.lhs.true, %if.end
  %6 = load ptr, ptr %stat.addr, align 8
  %allocated5 = getelementptr inbounds %struct.mi_stat_count_s, ptr %6, i32 0, i32 0
  %7 = load ptr, ptr %src.addr, align 8
  %allocated6 = getelementptr inbounds %struct.mi_stat_count_s, ptr %7, i32 0, i32 0
  %8 = load i64, ptr %allocated6, align 8
  %9 = load i64, ptr %unit.addr, align 8
  %mul = mul i64 %8, %9
  %call = call i64 @mi_atomic_addi64_relaxed(ptr noundef %allocated5, i64 noundef %mul)
  %10 = load ptr, ptr %stat.addr, align 8
  %current = getelementptr inbounds %struct.mi_stat_count_s, ptr %10, i32 0, i32 3
  %11 = load ptr, ptr %src.addr, align 8
  %current7 = getelementptr inbounds %struct.mi_stat_count_s, ptr %11, i32 0, i32 3
  %12 = load i64, ptr %current7, align 8
  %13 = load i64, ptr %unit.addr, align 8
  %mul8 = mul i64 %12, %13
  %call9 = call i64 @mi_atomic_addi64_relaxed(ptr noundef %current, i64 noundef %mul8)
  %14 = load ptr, ptr %stat.addr, align 8
  %freed10 = getelementptr inbounds %struct.mi_stat_count_s, ptr %14, i32 0, i32 1
  %15 = load ptr, ptr %src.addr, align 8
  %freed11 = getelementptr inbounds %struct.mi_stat_count_s, ptr %15, i32 0, i32 1
  %16 = load i64, ptr %freed11, align 8
  %17 = load i64, ptr %unit.addr, align 8
  %mul12 = mul i64 %16, %17
  %call13 = call i64 @mi_atomic_addi64_relaxed(ptr noundef %freed10, i64 noundef %mul12)
  %18 = load ptr, ptr %stat.addr, align 8
  %peak = getelementptr inbounds %struct.mi_stat_count_s, ptr %18, i32 0, i32 2
  %19 = load ptr, ptr %src.addr, align 8
  %peak14 = getelementptr inbounds %struct.mi_stat_count_s, ptr %19, i32 0, i32 2
  %20 = load i64, ptr %peak14, align 8
  %21 = load i64, ptr %unit.addr, align 8
  %mul15 = mul i64 %20, %21
  %call16 = call i64 @mi_atomic_addi64_relaxed(ptr noundef %peak, i64 noundef %mul15)
  br label %return

return:                                           ; preds = %if.end4, %if.then3, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_stat_counter_add(ptr noundef %stat, ptr noundef %src, i64 noundef %unit) #0 {
entry:
  %stat.addr = alloca ptr, align 8
  %src.addr = alloca ptr, align 8
  %unit.addr = alloca i64, align 8
  store ptr %stat, ptr %stat.addr, align 8
  store ptr %src, ptr %src.addr, align 8
  store i64 %unit, ptr %unit.addr, align 8
  %0 = load ptr, ptr %stat.addr, align 8
  %1 = load ptr, ptr %src.addr, align 8
  %cmp = icmp eq ptr %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %stat.addr, align 8
  %total = getelementptr inbounds %struct.mi_stat_counter_s, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %src.addr, align 8
  %total1 = getelementptr inbounds %struct.mi_stat_counter_s, ptr %3, i32 0, i32 0
  %4 = load i64, ptr %total1, align 8
  %5 = load i64, ptr %unit.addr, align 8
  %mul = mul i64 %4, %5
  %call = call i64 @mi_atomic_addi64_relaxed(ptr noundef %total, i64 noundef %mul)
  %6 = load ptr, ptr %stat.addr, align 8
  %count = getelementptr inbounds %struct.mi_stat_counter_s, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %src.addr, align 8
  %count2 = getelementptr inbounds %struct.mi_stat_counter_s, ptr %7, i32 0, i32 1
  %8 = load i64, ptr %count2, align 8
  %9 = load i64, ptr %unit.addr, align 8
  %mul3 = mul i64 %8, %9
  %call4 = call i64 @mi_atomic_addi64_relaxed(ptr noundef %count, i64 noundef %mul3)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_buffered_out(ptr noundef %msg, ptr noundef %arg) #0 {
entry:
  %msg.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %buf = alloca ptr, align 8
  %src = alloca ptr, align 8
  %c = alloca i8, align 1
  store ptr %msg, ptr %msg.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  store ptr %0, ptr %buf, align 8
  %1 = load ptr, ptr %msg.addr, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load ptr, ptr %buf, align 8
  %cmp1 = icmp eq ptr %2, null
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %for.end

if.end:                                           ; preds = %lor.lhs.false
  %3 = load ptr, ptr %msg.addr, align 8
  store ptr %3, ptr %src, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %4 = load ptr, ptr %src, align 8
  %5 = load i8, ptr %4, align 1
  %conv = sext i8 %5 to i32
  %cmp2 = icmp ne i32 %conv, 0
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load ptr, ptr %src, align 8
  %7 = load i8, ptr %6, align 1
  store i8 %7, ptr %c, align 1
  %8 = load ptr, ptr %buf, align 8
  %used = getelementptr inbounds %struct.buffered_s, ptr %8, i32 0, i32 3
  %9 = load i64, ptr %used, align 8
  %10 = load ptr, ptr %buf, align 8
  %count = getelementptr inbounds %struct.buffered_s, ptr %10, i32 0, i32 4
  %11 = load i64, ptr %count, align 8
  %cmp4 = icmp uge i64 %9, %11
  br i1 %cmp4, label %if.then6, label %if.end7

if.then6:                                         ; preds = %for.body
  %12 = load ptr, ptr %buf, align 8
  call void @mi_buffered_flush(ptr noundef %12)
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %for.body
  %13 = load i8, ptr %c, align 1
  %14 = load ptr, ptr %buf, align 8
  %buf8 = getelementptr inbounds %struct.buffered_s, ptr %14, i32 0, i32 2
  %15 = load ptr, ptr %buf8, align 8
  %16 = load ptr, ptr %buf, align 8
  %used9 = getelementptr inbounds %struct.buffered_s, ptr %16, i32 0, i32 3
  %17 = load i64, ptr %used9, align 8
  %inc = add i64 %17, 1
  store i64 %inc, ptr %used9, align 8
  %arrayidx = getelementptr i8, ptr %15, i64 %17
  store i8 %13, ptr %arrayidx, align 1
  %18 = load i8, ptr %c, align 1
  %conv10 = sext i8 %18 to i32
  %cmp11 = icmp eq i32 %conv10, 10
  br i1 %cmp11, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end7
  %19 = load ptr, ptr %buf, align 8
  call void @mi_buffered_flush(ptr noundef %19)
  br label %if.end14

if.end14:                                         ; preds = %if.then13, %if.end7
  br label %for.inc

for.inc:                                          ; preds = %if.end14
  %20 = load ptr, ptr %src, align 8
  %incdec.ptr = getelementptr i8, ptr %20, i32 1
  store ptr %incdec.ptr, ptr %src, align 8
  br label %for.cond, !llvm.loop !147

for.end:                                          ; preds = %for.cond, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_print_header(ptr noundef %out, ptr noundef %arg) #0 {
entry:
  %out.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  store ptr %out, ptr %out.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %out.addr, align 8
  %1 = load ptr, ptr %arg.addr, align 8
  call void (ptr, ptr, ptr, ...) @_mi_fprintf(ptr noundef %0, ptr noundef %1, ptr noundef @.str.126, ptr noundef @.str.127, ptr noundef @.str.128, ptr noundef @.str.129, ptr noundef @.str.130, ptr noundef @.str.131, ptr noundef @.str.132, ptr noundef @.str.133)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_stat_print_ex(ptr noundef %stat, ptr noundef %msg, i64 noundef %unit, ptr noundef %out, ptr noundef %arg, ptr noundef %notok) #0 {
entry:
  %stat.addr = alloca ptr, align 8
  %msg.addr = alloca ptr, align 8
  %unit.addr = alloca i64, align 8
  %out.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %notok.addr = alloca ptr, align 8
  store ptr %stat, ptr %stat.addr, align 8
  store ptr %msg, ptr %msg.addr, align 8
  store i64 %unit, ptr %unit.addr, align 8
  store ptr %out, ptr %out.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr %notok, ptr %notok.addr, align 8
  %0 = load ptr, ptr %out.addr, align 8
  %1 = load ptr, ptr %arg.addr, align 8
  %2 = load ptr, ptr %msg.addr, align 8
  call void (ptr, ptr, ptr, ...) @_mi_fprintf(ptr noundef %0, ptr noundef %1, ptr noundef @.str.134, ptr noundef %2)
  %3 = load i64, ptr %unit.addr, align 8
  %cmp = icmp sgt i64 %3, 0
  br i1 %cmp, label %if.then, label %if.else7

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr %stat.addr, align 8
  %peak = getelementptr inbounds %struct.mi_stat_count_s, ptr %4, i32 0, i32 2
  %5 = load i64, ptr %peak, align 8
  %6 = load i64, ptr %unit.addr, align 8
  %7 = load ptr, ptr %out.addr, align 8
  %8 = load ptr, ptr %arg.addr, align 8
  call void @mi_print_amount(i64 noundef %5, i64 noundef %6, ptr noundef %7, ptr noundef %8)
  %9 = load ptr, ptr %stat.addr, align 8
  %allocated = getelementptr inbounds %struct.mi_stat_count_s, ptr %9, i32 0, i32 0
  %10 = load i64, ptr %allocated, align 8
  %11 = load i64, ptr %unit.addr, align 8
  %12 = load ptr, ptr %out.addr, align 8
  %13 = load ptr, ptr %arg.addr, align 8
  call void @mi_print_amount(i64 noundef %10, i64 noundef %11, ptr noundef %12, ptr noundef %13)
  %14 = load ptr, ptr %stat.addr, align 8
  %freed = getelementptr inbounds %struct.mi_stat_count_s, ptr %14, i32 0, i32 1
  %15 = load i64, ptr %freed, align 8
  %16 = load i64, ptr %unit.addr, align 8
  %17 = load ptr, ptr %out.addr, align 8
  %18 = load ptr, ptr %arg.addr, align 8
  call void @mi_print_amount(i64 noundef %15, i64 noundef %16, ptr noundef %17, ptr noundef %18)
  %19 = load ptr, ptr %stat.addr, align 8
  %current = getelementptr inbounds %struct.mi_stat_count_s, ptr %19, i32 0, i32 3
  %20 = load i64, ptr %current, align 8
  %21 = load i64, ptr %unit.addr, align 8
  %22 = load ptr, ptr %out.addr, align 8
  %23 = load ptr, ptr %arg.addr, align 8
  call void @mi_print_amount(i64 noundef %20, i64 noundef %21, ptr noundef %22, ptr noundef %23)
  %24 = load i64, ptr %unit.addr, align 8
  %25 = load ptr, ptr %out.addr, align 8
  %26 = load ptr, ptr %arg.addr, align 8
  call void @mi_print_amount(i64 noundef %24, i64 noundef 1, ptr noundef %25, ptr noundef %26)
  %27 = load ptr, ptr %stat.addr, align 8
  %allocated1 = getelementptr inbounds %struct.mi_stat_count_s, ptr %27, i32 0, i32 0
  %28 = load i64, ptr %allocated1, align 8
  %29 = load i64, ptr %unit.addr, align 8
  %30 = load ptr, ptr %out.addr, align 8
  %31 = load ptr, ptr %arg.addr, align 8
  call void @mi_print_count(i64 noundef %28, i64 noundef %29, ptr noundef %30, ptr noundef %31)
  %32 = load ptr, ptr %stat.addr, align 8
  %allocated2 = getelementptr inbounds %struct.mi_stat_count_s, ptr %32, i32 0, i32 0
  %33 = load i64, ptr %allocated2, align 8
  %34 = load ptr, ptr %stat.addr, align 8
  %freed3 = getelementptr inbounds %struct.mi_stat_count_s, ptr %34, i32 0, i32 1
  %35 = load i64, ptr %freed3, align 8
  %cmp4 = icmp sgt i64 %33, %35
  br i1 %cmp4, label %if.then5, label %if.else

if.then5:                                         ; preds = %if.then
  %36 = load ptr, ptr %out.addr, align 8
  %37 = load ptr, ptr %arg.addr, align 8
  call void (ptr, ptr, ptr, ...) @_mi_fprintf(ptr noundef %36, ptr noundef %37, ptr noundef @.str.12)
  %38 = load ptr, ptr %out.addr, align 8
  %39 = load ptr, ptr %arg.addr, align 8
  %40 = load ptr, ptr %notok.addr, align 8
  %cmp6 = icmp eq ptr %40, null
  br i1 %cmp6, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then5
  br label %cond.end

cond.false:                                       ; preds = %if.then5
  %41 = load ptr, ptr %notok.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ @.str.135, %cond.true ], [ %41, %cond.false ]
  call void (ptr, ptr, ptr, ...) @_mi_fprintf(ptr noundef %38, ptr noundef %39, ptr noundef %cond)
  %42 = load ptr, ptr %out.addr, align 8
  %43 = load ptr, ptr %arg.addr, align 8
  call void (ptr, ptr, ptr, ...) @_mi_fprintf(ptr noundef %42, ptr noundef %43, ptr noundef @.str.125)
  br label %if.end

if.else:                                          ; preds = %if.then
  %44 = load ptr, ptr %out.addr, align 8
  %45 = load ptr, ptr %arg.addr, align 8
  call void (ptr, ptr, ptr, ...) @_mi_fprintf(ptr noundef %44, ptr noundef %45, ptr noundef @.str.136)
  br label %if.end

if.end:                                           ; preds = %if.else, %cond.end
  br label %if.end31

if.else7:                                         ; preds = %entry
  %46 = load i64, ptr %unit.addr, align 8
  %cmp8 = icmp slt i64 %46, 0
  br i1 %cmp8, label %if.then9, label %if.else26

if.then9:                                         ; preds = %if.else7
  %47 = load ptr, ptr %stat.addr, align 8
  %peak10 = getelementptr inbounds %struct.mi_stat_count_s, ptr %47, i32 0, i32 2
  %48 = load i64, ptr %peak10, align 8
  %49 = load ptr, ptr %out.addr, align 8
  %50 = load ptr, ptr %arg.addr, align 8
  call void @mi_print_amount(i64 noundef %48, i64 noundef -1, ptr noundef %49, ptr noundef %50)
  %51 = load ptr, ptr %stat.addr, align 8
  %allocated11 = getelementptr inbounds %struct.mi_stat_count_s, ptr %51, i32 0, i32 0
  %52 = load i64, ptr %allocated11, align 8
  %53 = load ptr, ptr %out.addr, align 8
  %54 = load ptr, ptr %arg.addr, align 8
  call void @mi_print_amount(i64 noundef %52, i64 noundef -1, ptr noundef %53, ptr noundef %54)
  %55 = load ptr, ptr %stat.addr, align 8
  %freed12 = getelementptr inbounds %struct.mi_stat_count_s, ptr %55, i32 0, i32 1
  %56 = load i64, ptr %freed12, align 8
  %57 = load ptr, ptr %out.addr, align 8
  %58 = load ptr, ptr %arg.addr, align 8
  call void @mi_print_amount(i64 noundef %56, i64 noundef -1, ptr noundef %57, ptr noundef %58)
  %59 = load ptr, ptr %stat.addr, align 8
  %current13 = getelementptr inbounds %struct.mi_stat_count_s, ptr %59, i32 0, i32 3
  %60 = load i64, ptr %current13, align 8
  %61 = load ptr, ptr %out.addr, align 8
  %62 = load ptr, ptr %arg.addr, align 8
  call void @mi_print_amount(i64 noundef %60, i64 noundef -1, ptr noundef %61, ptr noundef %62)
  %63 = load i64, ptr %unit.addr, align 8
  %cmp14 = icmp eq i64 %63, -1
  br i1 %cmp14, label %if.then15, label %if.else16

if.then15:                                        ; preds = %if.then9
  %64 = load ptr, ptr %out.addr, align 8
  %65 = load ptr, ptr %arg.addr, align 8
  call void (ptr, ptr, ptr, ...) @_mi_fprintf(ptr noundef %64, ptr noundef %65, ptr noundef @.str.137, ptr noundef @.str.10)
  br label %if.end19

if.else16:                                        ; preds = %if.then9
  %66 = load i64, ptr %unit.addr, align 8
  %sub = sub i64 0, %66
  %67 = load ptr, ptr %out.addr, align 8
  %68 = load ptr, ptr %arg.addr, align 8
  call void @mi_print_amount(i64 noundef %sub, i64 noundef 1, ptr noundef %67, ptr noundef %68)
  %69 = load ptr, ptr %stat.addr, align 8
  %allocated17 = getelementptr inbounds %struct.mi_stat_count_s, ptr %69, i32 0, i32 0
  %70 = load i64, ptr %allocated17, align 8
  %71 = load i64, ptr %unit.addr, align 8
  %sub18 = sub i64 0, %71
  %div = sdiv i64 %70, %sub18
  %72 = load ptr, ptr %out.addr, align 8
  %73 = load ptr, ptr %arg.addr, align 8
  call void @mi_print_count(i64 noundef %div, i64 noundef 0, ptr noundef %72, ptr noundef %73)
  br label %if.end19

if.end19:                                         ; preds = %if.else16, %if.then15
  %74 = load ptr, ptr %stat.addr, align 8
  %allocated20 = getelementptr inbounds %struct.mi_stat_count_s, ptr %74, i32 0, i32 0
  %75 = load i64, ptr %allocated20, align 8
  %76 = load ptr, ptr %stat.addr, align 8
  %freed21 = getelementptr inbounds %struct.mi_stat_count_s, ptr %76, i32 0, i32 1
  %77 = load i64, ptr %freed21, align 8
  %cmp22 = icmp sgt i64 %75, %77
  br i1 %cmp22, label %if.then23, label %if.else24

if.then23:                                        ; preds = %if.end19
  %78 = load ptr, ptr %out.addr, align 8
  %79 = load ptr, ptr %arg.addr, align 8
  call void (ptr, ptr, ptr, ...) @_mi_fprintf(ptr noundef %78, ptr noundef %79, ptr noundef @.str.138)
  br label %if.end25

if.else24:                                        ; preds = %if.end19
  %80 = load ptr, ptr %out.addr, align 8
  %81 = load ptr, ptr %arg.addr, align 8
  call void (ptr, ptr, ptr, ...) @_mi_fprintf(ptr noundef %80, ptr noundef %81, ptr noundef @.str.136)
  br label %if.end25

if.end25:                                         ; preds = %if.else24, %if.then23
  br label %if.end30

if.else26:                                        ; preds = %if.else7
  %82 = load ptr, ptr %stat.addr, align 8
  %peak27 = getelementptr inbounds %struct.mi_stat_count_s, ptr %82, i32 0, i32 2
  %83 = load i64, ptr %peak27, align 8
  %84 = load ptr, ptr %out.addr, align 8
  %85 = load ptr, ptr %arg.addr, align 8
  call void @mi_print_amount(i64 noundef %83, i64 noundef 1, ptr noundef %84, ptr noundef %85)
  %86 = load ptr, ptr %stat.addr, align 8
  %allocated28 = getelementptr inbounds %struct.mi_stat_count_s, ptr %86, i32 0, i32 0
  %87 = load i64, ptr %allocated28, align 8
  %88 = load ptr, ptr %out.addr, align 8
  %89 = load ptr, ptr %arg.addr, align 8
  call void @mi_print_amount(i64 noundef %87, i64 noundef 1, ptr noundef %88, ptr noundef %89)
  %90 = load ptr, ptr %out.addr, align 8
  %91 = load ptr, ptr %arg.addr, align 8
  call void (ptr, ptr, ptr, ...) @_mi_fprintf(ptr noundef %90, ptr noundef %91, ptr noundef @.str.139, ptr noundef @.str.140)
  %92 = load ptr, ptr %stat.addr, align 8
  %current29 = getelementptr inbounds %struct.mi_stat_count_s, ptr %92, i32 0, i32 3
  %93 = load i64, ptr %current29, align 8
  %94 = load ptr, ptr %out.addr, align 8
  %95 = load ptr, ptr %arg.addr, align 8
  call void @mi_print_amount(i64 noundef %93, i64 noundef 1, ptr noundef %94, ptr noundef %95)
  %96 = load ptr, ptr %out.addr, align 8
  %97 = load ptr, ptr %arg.addr, align 8
  call void (ptr, ptr, ptr, ...) @_mi_fprintf(ptr noundef %96, ptr noundef %97, ptr noundef @.str.125)
  br label %if.end30

if.end30:                                         ; preds = %if.else26, %if.end25
  br label %if.end31

if.end31:                                         ; preds = %if.end30, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_stat_peak_print(ptr noundef %stat, ptr noundef %msg, i64 noundef %unit, ptr noundef %out, ptr noundef %arg) #0 {
entry:
  %stat.addr = alloca ptr, align 8
  %msg.addr = alloca ptr, align 8
  %unit.addr = alloca i64, align 8
  %out.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  store ptr %stat, ptr %stat.addr, align 8
  store ptr %msg, ptr %msg.addr, align 8
  store i64 %unit, ptr %unit.addr, align 8
  store ptr %out, ptr %out.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %out.addr, align 8
  %1 = load ptr, ptr %arg.addr, align 8
  %2 = load ptr, ptr %msg.addr, align 8
  call void (ptr, ptr, ptr, ...) @_mi_fprintf(ptr noundef %0, ptr noundef %1, ptr noundef @.str.134, ptr noundef %2)
  %3 = load ptr, ptr %stat.addr, align 8
  %peak = getelementptr inbounds %struct.mi_stat_count_s, ptr %3, i32 0, i32 2
  %4 = load i64, ptr %peak, align 8
  %5 = load i64, ptr %unit.addr, align 8
  %6 = load ptr, ptr %out.addr, align 8
  %7 = load ptr, ptr %arg.addr, align 8
  call void @mi_print_amount(i64 noundef %4, i64 noundef %5, ptr noundef %6, ptr noundef %7)
  %8 = load ptr, ptr %out.addr, align 8
  %9 = load ptr, ptr %arg.addr, align 8
  call void (ptr, ptr, ptr, ...) @_mi_fprintf(ptr noundef %8, ptr noundef %9, ptr noundef @.str.125)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_stat_print(ptr noundef %stat, ptr noundef %msg, i64 noundef %unit, ptr noundef %out, ptr noundef %arg) #0 {
entry:
  %stat.addr = alloca ptr, align 8
  %msg.addr = alloca ptr, align 8
  %unit.addr = alloca i64, align 8
  %out.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  store ptr %stat, ptr %stat.addr, align 8
  store ptr %msg, ptr %msg.addr, align 8
  store i64 %unit, ptr %unit.addr, align 8
  store ptr %out, ptr %out.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %stat.addr, align 8
  %1 = load ptr, ptr %msg.addr, align 8
  %2 = load i64, ptr %unit.addr, align 8
  %3 = load ptr, ptr %out.addr, align 8
  %4 = load ptr, ptr %arg.addr, align 8
  call void @mi_stat_print_ex(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, ptr noundef null)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_stat_counter_print(ptr noundef %stat, ptr noundef %msg, ptr noundef %out, ptr noundef %arg) #0 {
entry:
  %stat.addr = alloca ptr, align 8
  %msg.addr = alloca ptr, align 8
  %out.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  store ptr %stat, ptr %stat.addr, align 8
  store ptr %msg, ptr %msg.addr, align 8
  store ptr %out, ptr %out.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %out.addr, align 8
  %1 = load ptr, ptr %arg.addr, align 8
  %2 = load ptr, ptr %msg.addr, align 8
  call void (ptr, ptr, ptr, ...) @_mi_fprintf(ptr noundef %0, ptr noundef %1, ptr noundef @.str.134, ptr noundef %2)
  %3 = load ptr, ptr %stat.addr, align 8
  %total = getelementptr inbounds %struct.mi_stat_counter_s, ptr %3, i32 0, i32 0
  %4 = load i64, ptr %total, align 8
  %5 = load ptr, ptr %out.addr, align 8
  %6 = load ptr, ptr %arg.addr, align 8
  call void @mi_print_amount(i64 noundef %4, i64 noundef -1, ptr noundef %5, ptr noundef %6)
  %7 = load ptr, ptr %out.addr, align 8
  %8 = load ptr, ptr %arg.addr, align 8
  call void (ptr, ptr, ptr, ...) @_mi_fprintf(ptr noundef %7, ptr noundef %8, ptr noundef @.str.125)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_stat_counter_print_avg(ptr noundef %stat, ptr noundef %msg, ptr noundef %out, ptr noundef %arg) #0 {
entry:
  %stat.addr = alloca ptr, align 8
  %msg.addr = alloca ptr, align 8
  %out.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %avg_tens = alloca i64, align 8
  %avg_whole = alloca i64, align 8
  %avg_frac1 = alloca i64, align 8
  store ptr %stat, ptr %stat.addr, align 8
  store ptr %msg, ptr %msg.addr, align 8
  store ptr %out, ptr %out.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %stat.addr, align 8
  %count = getelementptr inbounds %struct.mi_stat_counter_s, ptr %0, i32 0, i32 1
  %1 = load i64, ptr %count, align 8
  %cmp = icmp eq i64 %1, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %2 = load ptr, ptr %stat.addr, align 8
  %total = getelementptr inbounds %struct.mi_stat_counter_s, ptr %2, i32 0, i32 0
  %3 = load i64, ptr %total, align 8
  %mul = mul i64 %3, 10
  %4 = load ptr, ptr %stat.addr, align 8
  %count1 = getelementptr inbounds %struct.mi_stat_counter_s, ptr %4, i32 0, i32 1
  %5 = load i64, ptr %count1, align 8
  %div = sdiv i64 %mul, %5
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ 0, %cond.true ], [ %div, %cond.false ]
  store i64 %cond, ptr %avg_tens, align 8
  %6 = load i64, ptr %avg_tens, align 8
  %div2 = sdiv i64 %6, 10
  store i64 %div2, ptr %avg_whole, align 8
  %7 = load i64, ptr %avg_tens, align 8
  %rem = srem i64 %7, 10
  store i64 %rem, ptr %avg_frac1, align 8
  %8 = load ptr, ptr %out.addr, align 8
  %9 = load ptr, ptr %arg.addr, align 8
  %10 = load ptr, ptr %msg.addr, align 8
  %11 = load i64, ptr %avg_whole, align 8
  %12 = load i64, ptr %avg_frac1, align 8
  call void (ptr, ptr, ptr, ...) @_mi_fprintf(ptr noundef %8, ptr noundef %9, ptr noundef @.str.142, ptr noundef %10, i64 noundef %11, i64 noundef %12)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_printf_amount(i64 noundef %n, i64 noundef %unit, ptr noundef %out, ptr noundef %arg, ptr noundef %fmt) #0 {
entry:
  %n.addr = alloca i64, align 8
  %unit.addr = alloca i64, align 8
  %out.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %fmt.addr = alloca ptr, align 8
  %buf = alloca [32 x i8], align 16
  %len = alloca i32, align 4
  %suffix = alloca ptr, align 8
  %base = alloca i64, align 8
  %pos = alloca i64, align 8
  %divider = alloca i64, align 8
  %magnitude = alloca ptr, align 8
  %tens = alloca i64, align 8
  %whole = alloca i64, align 8
  %frac1 = alloca i64, align 8
  %unitdesc = alloca [8 x i8], align 1
  store i64 %n, ptr %n.addr, align 8
  store i64 %unit, ptr %unit.addr, align 8
  store ptr %out, ptr %out.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr %fmt, ptr %fmt.addr, align 8
  %arrayidx = getelementptr [32 x i8], ptr %buf, i64 0, i64 0
  store i8 0, ptr %arrayidx, align 16
  store i32 32, ptr %len, align 4
  %0 = load i64, ptr %unit.addr, align 8
  %cmp = icmp sle i64 %0, 0
  %cond = select i1 %cmp, ptr @.str.140, ptr @.str.143
  store ptr %cond, ptr %suffix, align 8
  %1 = load i64, ptr %unit.addr, align 8
  %cmp1 = icmp eq i64 %1, 0
  %cond2 = select i1 %cmp1, i32 1000, i32 1024
  %conv = sext i32 %cond2 to i64
  store i64 %conv, ptr %base, align 8
  %2 = load i64, ptr %unit.addr, align 8
  %cmp3 = icmp sgt i64 %2, 0
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i64, ptr %unit.addr, align 8
  %4 = load i64, ptr %n.addr, align 8
  %mul = mul i64 %4, %3
  store i64 %mul, ptr %n.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load i64, ptr %n.addr, align 8
  %cmp5 = icmp slt i64 %5, 0
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %6 = load i64, ptr %n.addr, align 8
  %sub = sub i64 0, %6
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %7 = load i64, ptr %n.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond7 = phi i64 [ %sub, %cond.true ], [ %7, %cond.false ]
  store i64 %cond7, ptr %pos, align 8
  %8 = load i64, ptr %pos, align 8
  %9 = load i64, ptr %base, align 8
  %cmp8 = icmp slt i64 %8, %9
  br i1 %cmp8, label %if.then10, label %if.else

if.then10:                                        ; preds = %cond.end
  %10 = load i64, ptr %n.addr, align 8
  %cmp11 = icmp ne i64 %10, 1
  br i1 %cmp11, label %if.then17, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then10
  %11 = load ptr, ptr %suffix, align 8
  %arrayidx13 = getelementptr i8, ptr %11, i64 0
  %12 = load i8, ptr %arrayidx13, align 1
  %conv14 = sext i8 %12 to i32
  %cmp15 = icmp ne i32 %conv14, 66
  br i1 %cmp15, label %if.then17, label %if.end26

if.then17:                                        ; preds = %lor.lhs.false, %if.then10
  %arraydecay = getelementptr inbounds [32 x i8], ptr %buf, i64 0, i64 0
  %13 = load i32, ptr %len, align 4
  %conv18 = sext i32 %13 to i64
  %14 = load i64, ptr %n.addr, align 8
  %conv19 = trunc i64 %14 to i32
  %15 = load i64, ptr %n.addr, align 8
  %cmp20 = icmp eq i64 %15, 0
  br i1 %cmp20, label %cond.true22, label %cond.false23

cond.true22:                                      ; preds = %if.then17
  br label %cond.end24

cond.false23:                                     ; preds = %if.then17
  %16 = load ptr, ptr %suffix, align 8
  br label %cond.end24

cond.end24:                                       ; preds = %cond.false23, %cond.true22
  %cond25 = phi ptr [ @.str.10, %cond.true22 ], [ %16, %cond.false23 ]
  %call = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %arraydecay, i64 noundef %conv18, ptr noundef @.str.144, i32 noundef %conv19, ptr noundef %cond25) #15
  br label %if.end26

if.end26:                                         ; preds = %cond.end24, %lor.lhs.false
  br label %if.end57

if.else:                                          ; preds = %cond.end
  %17 = load i64, ptr %base, align 8
  store i64 %17, ptr %divider, align 8
  store ptr @.str.145, ptr %magnitude, align 8
  %18 = load i64, ptr %pos, align 8
  %19 = load i64, ptr %divider, align 8
  %20 = load i64, ptr %base, align 8
  %mul27 = mul i64 %19, %20
  %cmp28 = icmp sge i64 %18, %mul27
  br i1 %cmp28, label %if.then30, label %if.end32

if.then30:                                        ; preds = %if.else
  %21 = load i64, ptr %base, align 8
  %22 = load i64, ptr %divider, align 8
  %mul31 = mul i64 %22, %21
  store i64 %mul31, ptr %divider, align 8
  store ptr @.str.146, ptr %magnitude, align 8
  br label %if.end32

if.end32:                                         ; preds = %if.then30, %if.else
  %23 = load i64, ptr %pos, align 8
  %24 = load i64, ptr %divider, align 8
  %25 = load i64, ptr %base, align 8
  %mul33 = mul i64 %24, %25
  %cmp34 = icmp sge i64 %23, %mul33
  br i1 %cmp34, label %if.then36, label %if.end38

if.then36:                                        ; preds = %if.end32
  %26 = load i64, ptr %base, align 8
  %27 = load i64, ptr %divider, align 8
  %mul37 = mul i64 %27, %26
  store i64 %mul37, ptr %divider, align 8
  store ptr @.str.147, ptr %magnitude, align 8
  br label %if.end38

if.end38:                                         ; preds = %if.then36, %if.end32
  %28 = load i64, ptr %n.addr, align 8
  %29 = load i64, ptr %divider, align 8
  %div = sdiv i64 %29, 10
  %div39 = sdiv i64 %28, %div
  store i64 %div39, ptr %tens, align 8
  %30 = load i64, ptr %tens, align 8
  %div40 = sdiv i64 %30, 10
  store i64 %div40, ptr %whole, align 8
  %31 = load i64, ptr %tens, align 8
  %rem = srem i64 %31, 10
  store i64 %rem, ptr %frac1, align 8
  %arraydecay41 = getelementptr inbounds [8 x i8], ptr %unitdesc, i64 0, i64 0
  %32 = load ptr, ptr %magnitude, align 8
  %33 = load i64, ptr %base, align 8
  %cmp42 = icmp eq i64 %33, 1024
  %cond44 = select i1 %cmp42, ptr @.str.149, ptr @.str.10
  %34 = load ptr, ptr %suffix, align 8
  %call45 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %arraydecay41, i64 noundef 8, ptr noundef @.str.148, ptr noundef %32, ptr noundef %cond44, ptr noundef %34) #15
  %arraydecay46 = getelementptr inbounds [32 x i8], ptr %buf, i64 0, i64 0
  %35 = load i32, ptr %len, align 4
  %conv47 = sext i32 %35 to i64
  %36 = load i64, ptr %whole, align 8
  %37 = load i64, ptr %frac1, align 8
  %cmp48 = icmp slt i64 %37, 0
  br i1 %cmp48, label %cond.true50, label %cond.false52

cond.true50:                                      ; preds = %if.end38
  %38 = load i64, ptr %frac1, align 8
  %sub51 = sub i64 0, %38
  br label %cond.end53

cond.false52:                                     ; preds = %if.end38
  %39 = load i64, ptr %frac1, align 8
  br label %cond.end53

cond.end53:                                       ; preds = %cond.false52, %cond.true50
  %cond54 = phi i64 [ %sub51, %cond.true50 ], [ %39, %cond.false52 ]
  %arraydecay55 = getelementptr inbounds [8 x i8], ptr %unitdesc, i64 0, i64 0
  %call56 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %arraydecay46, i64 noundef %conv47, ptr noundef @.str.150, i64 noundef %36, i64 noundef %cond54, ptr noundef %arraydecay55) #15
  br label %if.end57

if.end57:                                         ; preds = %cond.end53, %if.end26
  %40 = load ptr, ptr %out.addr, align 8
  %41 = load ptr, ptr %arg.addr, align 8
  %42 = load ptr, ptr %fmt.addr, align 8
  %cmp58 = icmp eq ptr %42, null
  br i1 %cmp58, label %cond.true60, label %cond.false61

cond.true60:                                      ; preds = %if.end57
  br label %cond.end62

cond.false61:                                     ; preds = %if.end57
  %43 = load ptr, ptr %fmt.addr, align 8
  br label %cond.end62

cond.end62:                                       ; preds = %cond.false61, %cond.true60
  %cond63 = phi ptr [ @.str.141, %cond.true60 ], [ %43, %cond.false61 ]
  %arraydecay64 = getelementptr inbounds [32 x i8], ptr %buf, i64 0, i64 0
  call void (ptr, ptr, ptr, ...) @_mi_fprintf(ptr noundef %40, ptr noundef %41, ptr noundef %cond63, ptr noundef %arraydecay64)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_buffered_flush(ptr noundef %buf) #0 {
entry:
  %buf.addr = alloca ptr, align 8
  store ptr %buf, ptr %buf.addr, align 8
  %0 = load ptr, ptr %buf.addr, align 8
  %buf1 = getelementptr inbounds %struct.buffered_s, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %buf1, align 8
  %2 = load ptr, ptr %buf.addr, align 8
  %used = getelementptr inbounds %struct.buffered_s, ptr %2, i32 0, i32 3
  %3 = load i64, ptr %used, align 8
  %arrayidx = getelementptr i8, ptr %1, i64 %3
  store i8 0, ptr %arrayidx, align 1
  %4 = load ptr, ptr %buf.addr, align 8
  %out = getelementptr inbounds %struct.buffered_s, ptr %4, i32 0, i32 0
  %5 = load ptr, ptr %out, align 8
  %6 = load ptr, ptr %buf.addr, align 8
  %arg = getelementptr inbounds %struct.buffered_s, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %arg, align 8
  %8 = load ptr, ptr %buf.addr, align 8
  %buf2 = getelementptr inbounds %struct.buffered_s, ptr %8, i32 0, i32 2
  %9 = load ptr, ptr %buf2, align 8
  call void @_mi_fputs(ptr noundef %5, ptr noundef %7, ptr noundef null, ptr noundef %9)
  %10 = load ptr, ptr %buf.addr, align 8
  %used3 = getelementptr inbounds %struct.buffered_s, ptr %10, i32 0, i32 3
  store i64 0, ptr %used3, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_print_amount(i64 noundef %n, i64 noundef %unit, ptr noundef %out, ptr noundef %arg) #0 {
entry:
  %n.addr = alloca i64, align 8
  %unit.addr = alloca i64, align 8
  %out.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  store i64 %n, ptr %n.addr, align 8
  store i64 %unit, ptr %unit.addr, align 8
  store ptr %out, ptr %out.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %1 = load i64, ptr %unit.addr, align 8
  %2 = load ptr, ptr %out.addr, align 8
  %3 = load ptr, ptr %arg.addr, align 8
  call void @mi_printf_amount(i64 noundef %0, i64 noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef null)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mi_print_count(i64 noundef %n, i64 noundef %unit, ptr noundef %out, ptr noundef %arg) #0 {
entry:
  %n.addr = alloca i64, align 8
  %unit.addr = alloca i64, align 8
  %out.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  store i64 %n, ptr %n.addr, align 8
  store i64 %unit, ptr %unit.addr, align 8
  store ptr %out, ptr %out.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load i64, ptr %unit.addr, align 8
  %cmp = icmp eq i64 %0, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %out.addr, align 8
  %2 = load ptr, ptr %arg.addr, align 8
  call void (ptr, ptr, ptr, ...) @_mi_fprintf(ptr noundef %1, ptr noundef %2, ptr noundef @.str.141, ptr noundef @.str.140)
  br label %if.end

if.else:                                          ; preds = %entry
  %3 = load i64, ptr %n.addr, align 8
  %4 = load ptr, ptr %out.addr, align 8
  %5 = load ptr, ptr %arg.addr, align 8
  call void @mi_print_amount(i64 noundef %3, i64 noundef 0, ptr noundef %4, ptr noundef %5)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @unix_mmap_fd() #0 {
entry:
  ret i32 -1
}

; Function Attrs: nounwind uwtable
define internal ptr @unix_mmap_prim(ptr noundef %addr, i64 noundef %size, i64 noundef %try_alignment, i32 noundef %protect_flags, i32 noundef %flags, i32 noundef %fd) #0 {
entry:
  %retval = alloca ptr, align 8
  %addr.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %try_alignment.addr = alloca i64, align 8
  %protect_flags.addr = alloca i32, align 4
  %flags.addr = alloca i32, align 4
  %fd.addr = alloca i32, align 4
  %p = alloca ptr, align 8
  %hint = alloca ptr, align 8
  %err = alloca i32, align 4
  store ptr %addr, ptr %addr.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store i64 %try_alignment, ptr %try_alignment.addr, align 8
  store i32 %protect_flags, ptr %protect_flags.addr, align 4
  store i32 %flags, ptr %flags.addr, align 4
  store i32 %fd, ptr %fd.addr, align 4
  store ptr null, ptr %p, align 8
  %0 = load ptr, ptr %addr.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end12

if.then:                                          ; preds = %entry
  %1 = load i64, ptr %try_alignment.addr, align 8
  %2 = load i64, ptr %size.addr, align 8
  %call = call ptr @_mi_os_get_aligned_hint(i64 noundef %1, i64 noundef %2)
  store ptr %call, ptr %hint, align 8
  %3 = load ptr, ptr %hint, align 8
  %cmp1 = icmp ne ptr %3, null
  br i1 %cmp1, label %if.then2, label %if.end11

if.then2:                                         ; preds = %if.then
  %4 = load ptr, ptr %hint, align 8
  %5 = load i64, ptr %size.addr, align 8
  %6 = load i32, ptr %protect_flags.addr, align 4
  %7 = load i32, ptr %flags.addr, align 4
  %8 = load i32, ptr %fd.addr, align 4
  %call3 = call ptr @mmap64(ptr noundef %4, i64 noundef %5, i32 noundef %6, i32 noundef %7, i32 noundef %8, i64 noundef 0) #15
  store ptr %call3, ptr %p, align 8
  %9 = load ptr, ptr %p, align 8
  %cmp4 = icmp eq ptr %9, inttoptr (i64 -1 to ptr)
  br i1 %cmp4, label %if.then6, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then2
  %10 = load ptr, ptr %p, align 8
  %11 = load i64, ptr %try_alignment.addr, align 8
  %call5 = call zeroext i1 @_mi_is_aligned(ptr noundef %10, i64 noundef %11)
  br i1 %call5, label %if.end, label %if.then6

if.then6:                                         ; preds = %lor.lhs.false, %if.then2
  %call7 = call ptr @__errno_location() #18
  %12 = load i32, ptr %call7, align 4
  store i32 %12, ptr %err, align 4
  %13 = load i32, ptr %err, align 4
  %14 = load i32, ptr %err, align 4
  %15 = load i64, ptr %size.addr, align 8
  %16 = load i64, ptr %try_alignment.addr, align 8
  %17 = load ptr, ptr %hint, align 8
  call void (ptr, ...) @_mi_warning_message(ptr noundef @.str.153, i32 noundef %13, i32 noundef %14, i64 noundef %15, i64 noundef %16, ptr noundef %17)
  br label %if.end

if.end:                                           ; preds = %if.then6, %lor.lhs.false
  %18 = load ptr, ptr %p, align 8
  %cmp8 = icmp ne ptr %18, inttoptr (i64 -1 to ptr)
  br i1 %cmp8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end
  %19 = load ptr, ptr %p, align 8
  store ptr %19, ptr %retval, align 8
  br label %return

if.end10:                                         ; preds = %if.end
  br label %if.end11

if.end11:                                         ; preds = %if.end10, %if.then
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %entry
  %20 = load ptr, ptr %addr.addr, align 8
  %21 = load i64, ptr %size.addr, align 8
  %22 = load i32, ptr %protect_flags.addr, align 4
  %23 = load i32, ptr %flags.addr, align 4
  %24 = load i32, ptr %fd.addr, align 4
  %call13 = call ptr @mmap64(ptr noundef %20, i64 noundef %21, i32 noundef %22, i32 noundef %23, i32 noundef %24, i64 noundef 0) #15
  store ptr %call13, ptr %p, align 8
  %25 = load ptr, ptr %p, align 8
  %cmp14 = icmp ne ptr %25, inttoptr (i64 -1 to ptr)
  br i1 %cmp14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.end12
  %26 = load ptr, ptr %p, align 8
  store ptr %26, ptr %retval, align 8
  br label %return

if.end16:                                         ; preds = %if.end12
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end16, %if.then15, %if.then9
  %27 = load ptr, ptr %retval, align 8
  ret ptr %27
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @_mi_is_aligned(ptr noundef %p, i64 noundef %alignment) #0 {
entry:
  %p.addr = alloca ptr, align 8
  %alignment.addr = alloca i64, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %1 = ptrtoint ptr %0 to i64
  %2 = load i64, ptr %alignment.addr, align 8
  %rem = urem i64 %1, %2
  %cmp = icmp eq i64 %rem, 0
  ret i1 %cmp
}

; Function Attrs: nounwind
declare i32 @madvise(ptr noundef, i64 noundef, i32 noundef) #2

; Function Attrs: nounwind uwtable
define internal i32 @_Py_atomic_compare_exchange_uint8(ptr noundef %obj, ptr noundef %expected, i8 noundef zeroext %desired) #0 {
entry:
  %obj.addr = alloca ptr, align 8
  %expected.addr = alloca ptr, align 8
  %desired.addr = alloca i8, align 1
  %.atomictmp = alloca i8, align 1
  %cmpxchg.bool = alloca i8, align 1
  store ptr %obj, ptr %obj.addr, align 8
  store ptr %expected, ptr %expected.addr, align 8
  store i8 %desired, ptr %desired.addr, align 1
  %0 = load ptr, ptr %obj.addr, align 8
  %1 = load ptr, ptr %expected.addr, align 8
  %2 = load i8, ptr %desired.addr, align 1
  store i8 %2, ptr %.atomictmp, align 1
  %3 = load i8, ptr %1, align 1
  %4 = load i8, ptr %.atomictmp, align 1
  %5 = cmpxchg ptr %0, i8 %3, i8 %4 seq_cst seq_cst, align 1
  %6 = extractvalue { i8, i1 } %5, 0
  %7 = extractvalue { i8, i1 } %5, 1
  br i1 %7, label %cmpxchg.continue, label %cmpxchg.store_expected

cmpxchg.store_expected:                           ; preds = %entry
  store i8 %6, ptr %1, align 1
  br label %cmpxchg.continue

cmpxchg.continue:                                 ; preds = %cmpxchg.store_expected, %entry
  %frombool = zext i1 %7 to i8
  store i8 %frombool, ptr %cmpxchg.bool, align 1
  %8 = load i8, ptr %cmpxchg.bool, align 1
  %tobool = trunc i8 %8 to i1
  %conv = zext i1 %tobool to i32
  ret i32 %conv
}

declare void @_PyMutex_LockSlow(ptr noundef) #8

; Function Attrs: nounwind uwtable
define internal void @set_up_debug_hooks_domain_unlocked(i32 noundef %domain) #0 {
entry:
  %domain.addr = alloca i32, align 4
  %alloc = alloca %struct.PyMemAllocatorEx, align 8
  store i32 %domain, ptr %domain.addr, align 4
  %0 = load i32, ptr %domain.addr, align 4
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr getelementptr inbounds (%struct.PyMemAllocatorEx, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1), i32 0, i32 1), align 8
  %cmp1 = icmp eq ptr %1, @_PyMem_DebugRawMalloc
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  br label %if.end26

if.end:                                           ; preds = %if.then
  %2 = load i32, ptr %domain.addr, align 4
  call void @get_allocator_unlocked(i32 noundef %2, ptr noundef getelementptr inbounds (%struct.debug_alloc_api_t, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 2), i32 0, i32 1))
  %ctx = getelementptr inbounds %struct.PyMemAllocatorEx, ptr %alloc, i32 0, i32 0
  store ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 2), ptr %ctx, align 8
  %malloc = getelementptr inbounds %struct.PyMemAllocatorEx, ptr %alloc, i32 0, i32 1
  store ptr @_PyMem_DebugRawMalloc, ptr %malloc, align 8
  %calloc = getelementptr inbounds %struct.PyMemAllocatorEx, ptr %alloc, i32 0, i32 2
  store ptr @_PyMem_DebugRawCalloc, ptr %calloc, align 8
  %realloc = getelementptr inbounds %struct.PyMemAllocatorEx, ptr %alloc, i32 0, i32 3
  store ptr @_PyMem_DebugRawRealloc, ptr %realloc, align 8
  %free = getelementptr inbounds %struct.PyMemAllocatorEx, ptr %alloc, i32 0, i32 4
  store ptr @_PyMem_DebugRawFree, ptr %free, align 8
  %3 = load i32, ptr %domain.addr, align 4
  call void @set_allocator_unlocked(i32 noundef %3, ptr noundef %alloc)
  br label %if.end26

if.else:                                          ; preds = %entry
  %4 = load i32, ptr %domain.addr, align 4
  %cmp3 = icmp eq i32 %4, 1
  br i1 %cmp3, label %if.then4, label %if.else13

if.then4:                                         ; preds = %if.else
  %5 = load ptr, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1, i32 1, i32 1), align 8
  %cmp5 = icmp eq ptr %5, @_PyMem_DebugMalloc
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.then4
  br label %if.end26

if.end7:                                          ; preds = %if.then4
  %6 = load i32, ptr %domain.addr, align 4
  call void @get_allocator_unlocked(i32 noundef %6, ptr noundef getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 2, i32 1, i32 1))
  %ctx8 = getelementptr inbounds %struct.PyMemAllocatorEx, ptr %alloc, i32 0, i32 0
  store ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 2, i32 1), ptr %ctx8, align 8
  %malloc9 = getelementptr inbounds %struct.PyMemAllocatorEx, ptr %alloc, i32 0, i32 1
  store ptr @_PyMem_DebugMalloc, ptr %malloc9, align 8
  %calloc10 = getelementptr inbounds %struct.PyMemAllocatorEx, ptr %alloc, i32 0, i32 2
  store ptr @_PyMem_DebugCalloc, ptr %calloc10, align 8
  %realloc11 = getelementptr inbounds %struct.PyMemAllocatorEx, ptr %alloc, i32 0, i32 3
  store ptr @_PyMem_DebugRealloc, ptr %realloc11, align 8
  %free12 = getelementptr inbounds %struct.PyMemAllocatorEx, ptr %alloc, i32 0, i32 4
  store ptr @_PyMem_DebugFree, ptr %free12, align 8
  %7 = load i32, ptr %domain.addr, align 4
  call void @set_allocator_unlocked(i32 noundef %7, ptr noundef %alloc)
  br label %if.end25

if.else13:                                        ; preds = %if.else
  %8 = load i32, ptr %domain.addr, align 4
  %cmp14 = icmp eq i32 %8, 2
  br i1 %cmp14, label %if.then15, label %if.end24

if.then15:                                        ; preds = %if.else13
  %9 = load ptr, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1, i32 2, i32 1), align 8
  %cmp16 = icmp eq ptr %9, @_PyMem_DebugMalloc
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.then15
  br label %if.end26

if.end18:                                         ; preds = %if.then15
  %10 = load i32, ptr %domain.addr, align 4
  call void @get_allocator_unlocked(i32 noundef %10, ptr noundef getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 2, i32 2, i32 1))
  %ctx19 = getelementptr inbounds %struct.PyMemAllocatorEx, ptr %alloc, i32 0, i32 0
  store ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 2, i32 2), ptr %ctx19, align 8
  %malloc20 = getelementptr inbounds %struct.PyMemAllocatorEx, ptr %alloc, i32 0, i32 1
  store ptr @_PyMem_DebugMalloc, ptr %malloc20, align 8
  %calloc21 = getelementptr inbounds %struct.PyMemAllocatorEx, ptr %alloc, i32 0, i32 2
  store ptr @_PyMem_DebugCalloc, ptr %calloc21, align 8
  %realloc22 = getelementptr inbounds %struct.PyMemAllocatorEx, ptr %alloc, i32 0, i32 3
  store ptr @_PyMem_DebugRealloc, ptr %realloc22, align 8
  %free23 = getelementptr inbounds %struct.PyMemAllocatorEx, ptr %alloc, i32 0, i32 4
  store ptr @_PyMem_DebugFree, ptr %free23, align 8
  %11 = load i32, ptr %domain.addr, align 4
  call void @set_allocator_unlocked(i32 noundef %11, ptr noundef %alloc)
  br label %if.end24

if.end24:                                         ; preds = %if.end18, %if.else13
  br label %if.end25

if.end25:                                         ; preds = %if.end24, %if.end7
  br label %if.end26

if.end26:                                         ; preds = %if.end25, %if.then17, %if.then6, %if.end, %if.then2
  ret void
}

declare void @_PyMutex_UnlockSlow(ptr noundef) #8

; Function Attrs: nounwind uwtable
define internal i32 @pymemallocator_eq(ptr noundef %a, ptr noundef %b) #0 {
entry:
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %1 = load ptr, ptr %b.addr, align 8
  %call = call i32 @memcmp(ptr noundef %0, ptr noundef %1, i64 noundef 40) #16
  %cmp = icmp eq i32 %call, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind willreturn memory(read)
declare i32 @memcmp(ptr noundef, ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define internal i32 @_PyMem_DebugEnabled() #0 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 1, i32 2, i32 1), align 8
  %cmp = icmp eq ptr %0, @_PyMem_DebugMalloc
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define internal i32 @_Py_IsMainInterpreter(ptr noundef %interp) #0 {
entry:
  %interp.addr = alloca ptr, align 8
  store ptr %interp, ptr %interp.addr, align 8
  %0 = load ptr, ptr %interp.addr, align 8
  %call = call ptr @_PyInterpreterState_Main()
  %cmp = icmp eq ptr %0, %call
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define internal i32 @_Py_IsMainInterpreterFinalizing(ptr noundef %interp) #0 {
entry:
  %interp.addr = alloca ptr, align 8
  store ptr %interp, ptr %interp.addr, align 8
  %call = call ptr @_PyRuntimeState_GetFinalizing(ptr noundef @_PyRuntime)
  %cmp = icmp ne ptr %call, null
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %0 = load ptr, ptr %interp.addr, align 8
  %cmp1 = icmp eq ptr %0, getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 38)
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %1 = phi i1 [ false, %entry ], [ %cmp1, %land.rhs ]
  %land.ext = zext i1 %1 to i32
  ret i32 %land.ext
}

; Function Attrs: nounwind uwtable
define internal ptr @_PyInterpreterState_Main() #0 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 8, i32 2), align 8
  ret ptr %0
}

; Function Attrs: nounwind uwtable
define internal ptr @_PyRuntimeState_GetFinalizing(ptr noundef %runtime) #0 {
entry:
  %runtime.addr = alloca ptr, align 8
  store ptr %runtime, ptr %runtime.addr, align 8
  %0 = load ptr, ptr %runtime.addr, align 8
  %_finalizing = getelementptr inbounds %struct.pyruntimestate, ptr %0, i32 0, i32 6
  %call = call ptr @_Py_atomic_load_ptr_relaxed(ptr noundef %_finalizing)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @_Py_atomic_load_ptr_relaxed(ptr noundef %obj) #0 {
entry:
  %obj.addr = alloca ptr, align 8
  %atomic-temp = alloca ptr, align 8
  store ptr %obj, ptr %obj.addr, align 8
  %0 = load ptr, ptr %obj.addr, align 8
  %1 = load atomic i64, ptr %0 monotonic, align 8
  store i64 %1, ptr %atomic-temp, align 8
  %2 = load ptr, ptr %atomic-temp, align 8
  ret ptr %2
}

; Function Attrs: nounwind uwtable
define internal void @PyMutex_LockFlags(ptr noundef %m, i32 noundef %flags) #0 {
entry:
  %m.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %expected = alloca i8, align 1
  store ptr %m, ptr %m.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  store i8 0, ptr %expected, align 1
  %0 = load ptr, ptr %m.addr, align 8
  %v = getelementptr inbounds %struct._PyMutex, ptr %0, i32 0, i32 0
  %call = call i32 @_Py_atomic_compare_exchange_uint8(ptr noundef %v, ptr noundef %expected, i8 noundef zeroext 1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %m.addr, align 8
  %2 = load i32, ptr %flags.addr, align 4
  %call1 = call i32 @_PyMutex_LockTimed(ptr noundef %1, i64 noundef -1, i32 noundef %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare ptr @PyInterpreterState_Head() #8

declare ptr @PyInterpreterState_Next(ptr noundef) #8

declare i32 @_PyMutex_LockTimed(ptr noundef, i64 noundef, i32 noundef) #8

; Function Attrs: nounwind uwtable
define internal ptr @_PyInterpreterState_GET() #0 {
entry:
  %tstate = alloca ptr, align 8
  %call = call ptr @_PyThreadState_GET()
  store ptr %call, ptr %tstate, align 8
  %0 = load ptr, ptr %tstate, align 8
  %interp = getelementptr inbounds %struct._ts, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %interp, align 8
  ret ptr %1
}

; Function Attrs: nounwind uwtable
define internal ptr @_PyThreadState_GET() #0 {
entry:
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @_Py_tss_tstate)
  %1 = load ptr, ptr %0, align 8
  ret ptr %1
}

; Function Attrs: nounwind uwtable
define internal void @pymalloc_pool_extend(ptr noundef %pool, i32 noundef %size) #0 {
entry:
  %pool.addr = alloca ptr, align 8
  %size.addr = alloca i32, align 4
  %next = alloca ptr, align 8
  store ptr %pool, ptr %pool.addr, align 8
  store i32 %size, ptr %size.addr, align 4
  %0 = load ptr, ptr %pool.addr, align 8
  %nextoffset = getelementptr inbounds %struct.pool_header, ptr %0, i32 0, i32 6
  %1 = load i32, ptr %nextoffset, align 8
  %2 = load ptr, ptr %pool.addr, align 8
  %maxnextoffset = getelementptr inbounds %struct.pool_header, ptr %2, i32 0, i32 7
  %3 = load i32, ptr %maxnextoffset, align 4
  %cmp = icmp ule i32 %1, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr %pool.addr, align 8
  %5 = load ptr, ptr %pool.addr, align 8
  %nextoffset1 = getelementptr inbounds %struct.pool_header, ptr %5, i32 0, i32 6
  %6 = load i32, ptr %nextoffset1, align 8
  %idx.ext = zext i32 %6 to i64
  %add.ptr = getelementptr i8, ptr %4, i64 %idx.ext
  %7 = load ptr, ptr %pool.addr, align 8
  %freeblock = getelementptr inbounds %struct.pool_header, ptr %7, i32 0, i32 1
  store ptr %add.ptr, ptr %freeblock, align 8
  %8 = load i32, ptr %size.addr, align 4
  %add = add i32 %8, 1
  %shl = shl i32 %add, 4
  %9 = load ptr, ptr %pool.addr, align 8
  %nextoffset2 = getelementptr inbounds %struct.pool_header, ptr %9, i32 0, i32 6
  %10 = load i32, ptr %nextoffset2, align 8
  %add3 = add i32 %10, %shl
  store i32 %add3, ptr %nextoffset2, align 8
  %11 = load ptr, ptr %pool.addr, align 8
  %freeblock4 = getelementptr inbounds %struct.pool_header, ptr %11, i32 0, i32 1
  %12 = load ptr, ptr %freeblock4, align 8
  store ptr null, ptr %12, align 8
  br label %return

if.end:                                           ; preds = %entry
  %13 = load ptr, ptr %pool.addr, align 8
  %nextpool = getelementptr inbounds %struct.pool_header, ptr %13, i32 0, i32 2
  %14 = load ptr, ptr %nextpool, align 8
  store ptr %14, ptr %next, align 8
  %15 = load ptr, ptr %pool.addr, align 8
  %prevpool = getelementptr inbounds %struct.pool_header, ptr %15, i32 0, i32 3
  %16 = load ptr, ptr %prevpool, align 8
  store ptr %16, ptr %pool.addr, align 8
  %17 = load ptr, ptr %pool.addr, align 8
  %18 = load ptr, ptr %next, align 8
  %prevpool5 = getelementptr inbounds %struct.pool_header, ptr %18, i32 0, i32 3
  store ptr %17, ptr %prevpool5, align 8
  %19 = load ptr, ptr %next, align 8
  %20 = load ptr, ptr %pool.addr, align 8
  %nextpool6 = getelementptr inbounds %struct.pool_header, ptr %20, i32 0, i32 2
  store ptr %19, ptr %nextpool6, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal ptr @allocate_from_new_pool(ptr noundef %state, i32 noundef %size) #0 {
entry:
  %retval = alloca ptr, align 8
  %state.addr = alloca ptr, align 8
  %size.addr = alloca i32, align 4
  %pool = alloca ptr, align 8
  %bp = alloca ptr, align 8
  %next = alloca ptr, align 8
  store ptr %state, ptr %state.addr, align 8
  store i32 %size, ptr %size.addr, align 4
  %0 = load ptr, ptr %state.addr, align 8
  %mgmt = getelementptr inbounds %struct._obmalloc_state, ptr %0, i32 0, i32 1
  %usable_arenas = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt, i32 0, i32 3
  %1 = load ptr, ptr %usable_arenas, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end16

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %state.addr, align 8
  %call = call ptr @new_arena(ptr noundef %2)
  %3 = load ptr, ptr %state.addr, align 8
  %mgmt1 = getelementptr inbounds %struct._obmalloc_state, ptr %3, i32 0, i32 1
  %usable_arenas2 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt1, i32 0, i32 3
  store ptr %call, ptr %usable_arenas2, align 8
  %4 = load ptr, ptr %state.addr, align 8
  %mgmt3 = getelementptr inbounds %struct._obmalloc_state, ptr %4, i32 0, i32 1
  %usable_arenas4 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt3, i32 0, i32 3
  %5 = load ptr, ptr %usable_arenas4, align 8
  %cmp5 = icmp eq ptr %5, null
  br i1 %cmp5, label %if.then6, label %if.end

if.then6:                                         ; preds = %if.then
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %if.then
  %6 = load ptr, ptr %state.addr, align 8
  %mgmt7 = getelementptr inbounds %struct._obmalloc_state, ptr %6, i32 0, i32 1
  %usable_arenas8 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt7, i32 0, i32 3
  %7 = load ptr, ptr %usable_arenas8, align 8
  %prevarena = getelementptr inbounds %struct.arena_object, ptr %7, i32 0, i32 6
  store ptr null, ptr %prevarena, align 8
  %8 = load ptr, ptr %state.addr, align 8
  %mgmt9 = getelementptr inbounds %struct._obmalloc_state, ptr %8, i32 0, i32 1
  %usable_arenas10 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt9, i32 0, i32 3
  %9 = load ptr, ptr %usable_arenas10, align 8
  %nextarena = getelementptr inbounds %struct.arena_object, ptr %9, i32 0, i32 5
  store ptr null, ptr %nextarena, align 8
  %10 = load ptr, ptr %state.addr, align 8
  %mgmt11 = getelementptr inbounds %struct._obmalloc_state, ptr %10, i32 0, i32 1
  %usable_arenas12 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt11, i32 0, i32 3
  %11 = load ptr, ptr %usable_arenas12, align 8
  %12 = load ptr, ptr %state.addr, align 8
  %mgmt13 = getelementptr inbounds %struct._obmalloc_state, ptr %12, i32 0, i32 1
  %nfp2lasta = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt13, i32 0, i32 4
  %13 = load ptr, ptr %state.addr, align 8
  %mgmt14 = getelementptr inbounds %struct._obmalloc_state, ptr %13, i32 0, i32 1
  %usable_arenas15 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt14, i32 0, i32 3
  %14 = load ptr, ptr %usable_arenas15, align 8
  %nfreepools = getelementptr inbounds %struct.arena_object, ptr %14, i32 0, i32 2
  %15 = load i32, ptr %nfreepools, align 8
  %idxprom = zext i32 %15 to i64
  %arrayidx = getelementptr [65 x ptr], ptr %nfp2lasta, i64 0, i64 %idxprom
  store ptr %11, ptr %arrayidx, align 8
  br label %if.end16

if.end16:                                         ; preds = %if.end, %entry
  %16 = load ptr, ptr %state.addr, align 8
  %mgmt17 = getelementptr inbounds %struct._obmalloc_state, ptr %16, i32 0, i32 1
  %nfp2lasta18 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt17, i32 0, i32 4
  %17 = load ptr, ptr %state.addr, align 8
  %mgmt19 = getelementptr inbounds %struct._obmalloc_state, ptr %17, i32 0, i32 1
  %usable_arenas20 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt19, i32 0, i32 3
  %18 = load ptr, ptr %usable_arenas20, align 8
  %nfreepools21 = getelementptr inbounds %struct.arena_object, ptr %18, i32 0, i32 2
  %19 = load i32, ptr %nfreepools21, align 8
  %idxprom22 = zext i32 %19 to i64
  %arrayidx23 = getelementptr [65 x ptr], ptr %nfp2lasta18, i64 0, i64 %idxprom22
  %20 = load ptr, ptr %arrayidx23, align 8
  %21 = load ptr, ptr %state.addr, align 8
  %mgmt24 = getelementptr inbounds %struct._obmalloc_state, ptr %21, i32 0, i32 1
  %usable_arenas25 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt24, i32 0, i32 3
  %22 = load ptr, ptr %usable_arenas25, align 8
  %cmp26 = icmp eq ptr %20, %22
  br i1 %cmp26, label %if.then27, label %if.end35

if.then27:                                        ; preds = %if.end16
  %23 = load ptr, ptr %state.addr, align 8
  %mgmt28 = getelementptr inbounds %struct._obmalloc_state, ptr %23, i32 0, i32 1
  %nfp2lasta29 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt28, i32 0, i32 4
  %24 = load ptr, ptr %state.addr, align 8
  %mgmt30 = getelementptr inbounds %struct._obmalloc_state, ptr %24, i32 0, i32 1
  %usable_arenas31 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt30, i32 0, i32 3
  %25 = load ptr, ptr %usable_arenas31, align 8
  %nfreepools32 = getelementptr inbounds %struct.arena_object, ptr %25, i32 0, i32 2
  %26 = load i32, ptr %nfreepools32, align 8
  %idxprom33 = zext i32 %26 to i64
  %arrayidx34 = getelementptr [65 x ptr], ptr %nfp2lasta29, i64 0, i64 %idxprom33
  store ptr null, ptr %arrayidx34, align 8
  br label %if.end35

if.end35:                                         ; preds = %if.then27, %if.end16
  %27 = load ptr, ptr %state.addr, align 8
  %mgmt36 = getelementptr inbounds %struct._obmalloc_state, ptr %27, i32 0, i32 1
  %usable_arenas37 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt36, i32 0, i32 3
  %28 = load ptr, ptr %usable_arenas37, align 8
  %nfreepools38 = getelementptr inbounds %struct.arena_object, ptr %28, i32 0, i32 2
  %29 = load i32, ptr %nfreepools38, align 8
  %cmp39 = icmp ugt i32 %29, 1
  br i1 %cmp39, label %if.then40, label %if.end50

if.then40:                                        ; preds = %if.end35
  %30 = load ptr, ptr %state.addr, align 8
  %mgmt41 = getelementptr inbounds %struct._obmalloc_state, ptr %30, i32 0, i32 1
  %usable_arenas42 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt41, i32 0, i32 3
  %31 = load ptr, ptr %usable_arenas42, align 8
  %32 = load ptr, ptr %state.addr, align 8
  %mgmt43 = getelementptr inbounds %struct._obmalloc_state, ptr %32, i32 0, i32 1
  %nfp2lasta44 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt43, i32 0, i32 4
  %33 = load ptr, ptr %state.addr, align 8
  %mgmt45 = getelementptr inbounds %struct._obmalloc_state, ptr %33, i32 0, i32 1
  %usable_arenas46 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt45, i32 0, i32 3
  %34 = load ptr, ptr %usable_arenas46, align 8
  %nfreepools47 = getelementptr inbounds %struct.arena_object, ptr %34, i32 0, i32 2
  %35 = load i32, ptr %nfreepools47, align 8
  %sub = sub i32 %35, 1
  %idxprom48 = zext i32 %sub to i64
  %arrayidx49 = getelementptr [65 x ptr], ptr %nfp2lasta44, i64 0, i64 %idxprom48
  store ptr %31, ptr %arrayidx49, align 8
  br label %if.end50

if.end50:                                         ; preds = %if.then40, %if.end35
  %36 = load ptr, ptr %state.addr, align 8
  %mgmt51 = getelementptr inbounds %struct._obmalloc_state, ptr %36, i32 0, i32 1
  %usable_arenas52 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt51, i32 0, i32 3
  %37 = load ptr, ptr %usable_arenas52, align 8
  %freepools = getelementptr inbounds %struct.arena_object, ptr %37, i32 0, i32 4
  %38 = load ptr, ptr %freepools, align 8
  store ptr %38, ptr %pool, align 8
  %39 = load ptr, ptr %pool, align 8
  %cmp53 = icmp ne ptr %39, null
  br i1 %cmp53, label %if.then54, label %if.else80

if.then54:                                        ; preds = %if.end50
  %40 = load ptr, ptr %pool, align 8
  %nextpool = getelementptr inbounds %struct.pool_header, ptr %40, i32 0, i32 2
  %41 = load ptr, ptr %nextpool, align 8
  %42 = load ptr, ptr %state.addr, align 8
  %mgmt55 = getelementptr inbounds %struct._obmalloc_state, ptr %42, i32 0, i32 1
  %usable_arenas56 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt55, i32 0, i32 3
  %43 = load ptr, ptr %usable_arenas56, align 8
  %freepools57 = getelementptr inbounds %struct.arena_object, ptr %43, i32 0, i32 4
  store ptr %41, ptr %freepools57, align 8
  %44 = load ptr, ptr %state.addr, align 8
  %mgmt58 = getelementptr inbounds %struct._obmalloc_state, ptr %44, i32 0, i32 1
  %usable_arenas59 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt58, i32 0, i32 3
  %45 = load ptr, ptr %usable_arenas59, align 8
  %nfreepools60 = getelementptr inbounds %struct.arena_object, ptr %45, i32 0, i32 2
  %46 = load i32, ptr %nfreepools60, align 8
  %dec = add i32 %46, -1
  store i32 %dec, ptr %nfreepools60, align 8
  %47 = load ptr, ptr %state.addr, align 8
  %mgmt61 = getelementptr inbounds %struct._obmalloc_state, ptr %47, i32 0, i32 1
  %usable_arenas62 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt61, i32 0, i32 3
  %48 = load ptr, ptr %usable_arenas62, align 8
  %nfreepools63 = getelementptr inbounds %struct.arena_object, ptr %48, i32 0, i32 2
  %49 = load i32, ptr %nfreepools63, align 8
  %cmp64 = icmp eq i32 %49, 0
  br i1 %cmp64, label %if.then65, label %if.else

if.then65:                                        ; preds = %if.then54
  %50 = load ptr, ptr %state.addr, align 8
  %mgmt66 = getelementptr inbounds %struct._obmalloc_state, ptr %50, i32 0, i32 1
  %usable_arenas67 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt66, i32 0, i32 3
  %51 = load ptr, ptr %usable_arenas67, align 8
  %nextarena68 = getelementptr inbounds %struct.arena_object, ptr %51, i32 0, i32 5
  %52 = load ptr, ptr %nextarena68, align 8
  %53 = load ptr, ptr %state.addr, align 8
  %mgmt69 = getelementptr inbounds %struct._obmalloc_state, ptr %53, i32 0, i32 1
  %usable_arenas70 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt69, i32 0, i32 3
  store ptr %52, ptr %usable_arenas70, align 8
  %54 = load ptr, ptr %state.addr, align 8
  %mgmt71 = getelementptr inbounds %struct._obmalloc_state, ptr %54, i32 0, i32 1
  %usable_arenas72 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt71, i32 0, i32 3
  %55 = load ptr, ptr %usable_arenas72, align 8
  %cmp73 = icmp ne ptr %55, null
  br i1 %cmp73, label %if.then74, label %if.end78

if.then74:                                        ; preds = %if.then65
  %56 = load ptr, ptr %state.addr, align 8
  %mgmt75 = getelementptr inbounds %struct._obmalloc_state, ptr %56, i32 0, i32 1
  %usable_arenas76 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt75, i32 0, i32 3
  %57 = load ptr, ptr %usable_arenas76, align 8
  %prevarena77 = getelementptr inbounds %struct.arena_object, ptr %57, i32 0, i32 6
  store ptr null, ptr %prevarena77, align 8
  br label %if.end78

if.end78:                                         ; preds = %if.then74, %if.then65
  br label %if.end79

if.else:                                          ; preds = %if.then54
  br label %if.end79

if.end79:                                         ; preds = %if.else, %if.end78
  br label %if.end114

if.else80:                                        ; preds = %if.end50
  %58 = load ptr, ptr %state.addr, align 8
  %mgmt81 = getelementptr inbounds %struct._obmalloc_state, ptr %58, i32 0, i32 1
  %usable_arenas82 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt81, i32 0, i32 3
  %59 = load ptr, ptr %usable_arenas82, align 8
  %pool_address = getelementptr inbounds %struct.arena_object, ptr %59, i32 0, i32 1
  %60 = load ptr, ptr %pool_address, align 8
  store ptr %60, ptr %pool, align 8
  %61 = load ptr, ptr %state.addr, align 8
  %mgmt83 = getelementptr inbounds %struct._obmalloc_state, ptr %61, i32 0, i32 1
  %usable_arenas84 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt83, i32 0, i32 3
  %62 = load ptr, ptr %usable_arenas84, align 8
  %63 = load ptr, ptr %state.addr, align 8
  %mgmt85 = getelementptr inbounds %struct._obmalloc_state, ptr %63, i32 0, i32 1
  %arenas = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt85, i32 0, i32 0
  %64 = load ptr, ptr %arenas, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %62 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %64 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 48
  %conv = trunc i64 %sub.ptr.div to i32
  %65 = load ptr, ptr %pool, align 8
  %arenaindex = getelementptr inbounds %struct.pool_header, ptr %65, i32 0, i32 4
  store i32 %conv, ptr %arenaindex, align 8
  %66 = load ptr, ptr %pool, align 8
  %szidx = getelementptr inbounds %struct.pool_header, ptr %66, i32 0, i32 5
  store i32 65535, ptr %szidx, align 4
  %67 = load ptr, ptr %state.addr, align 8
  %mgmt86 = getelementptr inbounds %struct._obmalloc_state, ptr %67, i32 0, i32 1
  %usable_arenas87 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt86, i32 0, i32 3
  %68 = load ptr, ptr %usable_arenas87, align 8
  %pool_address88 = getelementptr inbounds %struct.arena_object, ptr %68, i32 0, i32 1
  %69 = load ptr, ptr %pool_address88, align 8
  %add.ptr = getelementptr i8, ptr %69, i64 16384
  store ptr %add.ptr, ptr %pool_address88, align 8
  %70 = load ptr, ptr %state.addr, align 8
  %mgmt89 = getelementptr inbounds %struct._obmalloc_state, ptr %70, i32 0, i32 1
  %usable_arenas90 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt89, i32 0, i32 3
  %71 = load ptr, ptr %usable_arenas90, align 8
  %nfreepools91 = getelementptr inbounds %struct.arena_object, ptr %71, i32 0, i32 2
  %72 = load i32, ptr %nfreepools91, align 8
  %dec92 = add i32 %72, -1
  store i32 %dec92, ptr %nfreepools91, align 8
  %73 = load ptr, ptr %state.addr, align 8
  %mgmt93 = getelementptr inbounds %struct._obmalloc_state, ptr %73, i32 0, i32 1
  %usable_arenas94 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt93, i32 0, i32 3
  %74 = load ptr, ptr %usable_arenas94, align 8
  %nfreepools95 = getelementptr inbounds %struct.arena_object, ptr %74, i32 0, i32 2
  %75 = load i32, ptr %nfreepools95, align 8
  %cmp96 = icmp eq i32 %75, 0
  br i1 %cmp96, label %if.then98, label %if.end113

if.then98:                                        ; preds = %if.else80
  %76 = load ptr, ptr %state.addr, align 8
  %mgmt99 = getelementptr inbounds %struct._obmalloc_state, ptr %76, i32 0, i32 1
  %usable_arenas100 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt99, i32 0, i32 3
  %77 = load ptr, ptr %usable_arenas100, align 8
  %nextarena101 = getelementptr inbounds %struct.arena_object, ptr %77, i32 0, i32 5
  %78 = load ptr, ptr %nextarena101, align 8
  %79 = load ptr, ptr %state.addr, align 8
  %mgmt102 = getelementptr inbounds %struct._obmalloc_state, ptr %79, i32 0, i32 1
  %usable_arenas103 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt102, i32 0, i32 3
  store ptr %78, ptr %usable_arenas103, align 8
  %80 = load ptr, ptr %state.addr, align 8
  %mgmt104 = getelementptr inbounds %struct._obmalloc_state, ptr %80, i32 0, i32 1
  %usable_arenas105 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt104, i32 0, i32 3
  %81 = load ptr, ptr %usable_arenas105, align 8
  %cmp106 = icmp ne ptr %81, null
  br i1 %cmp106, label %if.then108, label %if.end112

if.then108:                                       ; preds = %if.then98
  %82 = load ptr, ptr %state.addr, align 8
  %mgmt109 = getelementptr inbounds %struct._obmalloc_state, ptr %82, i32 0, i32 1
  %usable_arenas110 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt109, i32 0, i32 3
  %83 = load ptr, ptr %usable_arenas110, align 8
  %prevarena111 = getelementptr inbounds %struct.arena_object, ptr %83, i32 0, i32 6
  store ptr null, ptr %prevarena111, align 8
  br label %if.end112

if.end112:                                        ; preds = %if.then108, %if.then98
  br label %if.end113

if.end113:                                        ; preds = %if.end112, %if.else80
  br label %if.end114

if.end114:                                        ; preds = %if.end113, %if.end79
  %84 = load ptr, ptr %state.addr, align 8
  %pools = getelementptr inbounds %struct._obmalloc_state, ptr %84, i32 0, i32 0
  %used = getelementptr inbounds %struct._obmalloc_pools, ptr %pools, i32 0, i32 0
  %85 = load i32, ptr %size.addr, align 4
  %86 = load i32, ptr %size.addr, align 4
  %add = add i32 %85, %86
  %idxprom115 = zext i32 %add to i64
  %arrayidx116 = getelementptr [64 x ptr], ptr %used, i64 0, i64 %idxprom115
  %87 = load ptr, ptr %arrayidx116, align 8
  store ptr %87, ptr %next, align 8
  %88 = load ptr, ptr %next, align 8
  %89 = load ptr, ptr %pool, align 8
  %nextpool117 = getelementptr inbounds %struct.pool_header, ptr %89, i32 0, i32 2
  store ptr %88, ptr %nextpool117, align 8
  %90 = load ptr, ptr %next, align 8
  %91 = load ptr, ptr %pool, align 8
  %prevpool = getelementptr inbounds %struct.pool_header, ptr %91, i32 0, i32 3
  store ptr %90, ptr %prevpool, align 8
  %92 = load ptr, ptr %pool, align 8
  %93 = load ptr, ptr %next, align 8
  %nextpool118 = getelementptr inbounds %struct.pool_header, ptr %93, i32 0, i32 2
  store ptr %92, ptr %nextpool118, align 8
  %94 = load ptr, ptr %pool, align 8
  %95 = load ptr, ptr %next, align 8
  %prevpool119 = getelementptr inbounds %struct.pool_header, ptr %95, i32 0, i32 3
  store ptr %94, ptr %prevpool119, align 8
  %96 = load ptr, ptr %pool, align 8
  %ref = getelementptr inbounds %struct.pool_header, ptr %96, i32 0, i32 0
  store i32 1, ptr %ref, align 8
  %97 = load ptr, ptr %pool, align 8
  %szidx120 = getelementptr inbounds %struct.pool_header, ptr %97, i32 0, i32 5
  %98 = load i32, ptr %szidx120, align 4
  %99 = load i32, ptr %size.addr, align 4
  %cmp121 = icmp eq i32 %98, %99
  br i1 %cmp121, label %if.then123, label %if.end125

if.then123:                                       ; preds = %if.end114
  %100 = load ptr, ptr %pool, align 8
  %freeblock = getelementptr inbounds %struct.pool_header, ptr %100, i32 0, i32 1
  %101 = load ptr, ptr %freeblock, align 8
  store ptr %101, ptr %bp, align 8
  %102 = load ptr, ptr %bp, align 8
  %103 = load ptr, ptr %102, align 8
  %104 = load ptr, ptr %pool, align 8
  %freeblock124 = getelementptr inbounds %struct.pool_header, ptr %104, i32 0, i32 1
  store ptr %103, ptr %freeblock124, align 8
  %105 = load ptr, ptr %bp, align 8
  store ptr %105, ptr %retval, align 8
  br label %return

if.end125:                                        ; preds = %if.end114
  %106 = load i32, ptr %size.addr, align 4
  %107 = load ptr, ptr %pool, align 8
  %szidx126 = getelementptr inbounds %struct.pool_header, ptr %107, i32 0, i32 5
  store i32 %106, ptr %szidx126, align 4
  %108 = load i32, ptr %size.addr, align 4
  %add127 = add i32 %108, 1
  %shl = shl i32 %add127, 4
  store i32 %shl, ptr %size.addr, align 4
  %109 = load ptr, ptr %pool, align 8
  %add.ptr128 = getelementptr i8, ptr %109, i64 48
  store ptr %add.ptr128, ptr %bp, align 8
  %110 = load i32, ptr %size.addr, align 4
  %shl129 = shl i32 %110, 1
  %conv130 = zext i32 %shl129 to i64
  %add131 = add i64 48, %conv130
  %conv132 = trunc i64 %add131 to i32
  %111 = load ptr, ptr %pool, align 8
  %nextoffset = getelementptr inbounds %struct.pool_header, ptr %111, i32 0, i32 6
  store i32 %conv132, ptr %nextoffset, align 8
  %112 = load i32, ptr %size.addr, align 4
  %sub133 = sub i32 16384, %112
  %113 = load ptr, ptr %pool, align 8
  %maxnextoffset = getelementptr inbounds %struct.pool_header, ptr %113, i32 0, i32 7
  store i32 %sub133, ptr %maxnextoffset, align 4
  %114 = load ptr, ptr %bp, align 8
  %115 = load i32, ptr %size.addr, align 4
  %idx.ext = zext i32 %115 to i64
  %add.ptr134 = getelementptr i8, ptr %114, i64 %idx.ext
  %116 = load ptr, ptr %pool, align 8
  %freeblock135 = getelementptr inbounds %struct.pool_header, ptr %116, i32 0, i32 1
  store ptr %add.ptr134, ptr %freeblock135, align 8
  %117 = load ptr, ptr %pool, align 8
  %freeblock136 = getelementptr inbounds %struct.pool_header, ptr %117, i32 0, i32 1
  %118 = load ptr, ptr %freeblock136, align 8
  store ptr null, ptr %118, align 8
  %119 = load ptr, ptr %bp, align 8
  store ptr %119, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end125, %if.then123, %if.then6
  %120 = load ptr, ptr %retval, align 8
  ret ptr %120
}

; Function Attrs: nounwind uwtable
define internal ptr @new_arena(ptr noundef %state) #0 {
entry:
  %retval = alloca ptr, align 8
  %state.addr = alloca ptr, align 8
  %arenaobj = alloca ptr, align 8
  %excess = alloca i32, align 4
  %address = alloca ptr, align 8
  %debug_stats = alloca i32, align 4
  %opt = alloca ptr, align 8
  %i = alloca i32, align 4
  %numarenas = alloca i32, align 4
  %nbytes = alloca i64, align 8
  store ptr %state, ptr %state.addr, align 8
  %0 = load i32, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 12), align 8
  store i32 %0, ptr %debug_stats, align 4
  %1 = load i32, ptr %debug_stats, align 4
  %cmp = icmp eq i32 %1, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call ptr @Py_GETENV(ptr noundef @.str.157)
  store ptr %call, ptr %opt, align 8
  %2 = load ptr, ptr %opt, align 8
  %cmp1 = icmp ne ptr %2, null
  br i1 %cmp1, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then
  %3 = load ptr, ptr %opt, align 8
  %4 = load i8, ptr %3, align 1
  %conv = sext i8 %4 to i32
  %cmp2 = icmp ne i32 %conv, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then
  %5 = phi i1 [ false, %if.then ], [ %cmp2, %land.rhs ]
  %land.ext = zext i1 %5 to i32
  store i32 %land.ext, ptr %debug_stats, align 4
  %6 = load i32, ptr %debug_stats, align 4
  store i32 %6, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 12), align 8
  br label %if.end

if.end:                                           ; preds = %land.end, %entry
  %7 = load i32, ptr %debug_stats, align 4
  %tobool = icmp ne i32 %7, 0
  br i1 %tobool, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %8 = load ptr, ptr @stderr, align 8
  %call5 = call i32 @_PyObject_DebugMallocStats(ptr noundef %8)
  br label %if.end6

if.end6:                                          ; preds = %if.then4, %if.end
  %9 = load ptr, ptr %state.addr, align 8
  %mgmt = getelementptr inbounds %struct._obmalloc_state, ptr %9, i32 0, i32 1
  %unused_arena_objects = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt, i32 0, i32 2
  %10 = load ptr, ptr %unused_arena_objects, align 8
  %cmp7 = icmp eq ptr %10, null
  br i1 %cmp7, label %if.then9, label %if.end60

if.then9:                                         ; preds = %if.end6
  %11 = load ptr, ptr %state.addr, align 8
  %mgmt10 = getelementptr inbounds %struct._obmalloc_state, ptr %11, i32 0, i32 1
  %maxarenas = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt10, i32 0, i32 1
  %12 = load i32, ptr %maxarenas, align 8
  %tobool11 = icmp ne i32 %12, 0
  br i1 %tobool11, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then9
  %13 = load ptr, ptr %state.addr, align 8
  %mgmt12 = getelementptr inbounds %struct._obmalloc_state, ptr %13, i32 0, i32 1
  %maxarenas13 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt12, i32 0, i32 1
  %14 = load i32, ptr %maxarenas13, align 8
  %shl = shl i32 %14, 1
  br label %cond.end

cond.false:                                       ; preds = %if.then9
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %shl, %cond.true ], [ 16, %cond.false ]
  store i32 %cond, ptr %numarenas, align 4
  %15 = load i32, ptr %numarenas, align 4
  %16 = load ptr, ptr %state.addr, align 8
  %mgmt14 = getelementptr inbounds %struct._obmalloc_state, ptr %16, i32 0, i32 1
  %maxarenas15 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt14, i32 0, i32 1
  %17 = load i32, ptr %maxarenas15, align 8
  %cmp16 = icmp ule i32 %15, %17
  br i1 %cmp16, label %if.then18, label %if.end19

if.then18:                                        ; preds = %cond.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end19:                                         ; preds = %cond.end
  %18 = load i32, ptr %numarenas, align 4
  %conv20 = zext i32 %18 to i64
  %mul = mul i64 %conv20, 48
  store i64 %mul, ptr %nbytes, align 8
  %19 = load ptr, ptr %state.addr, align 8
  %mgmt21 = getelementptr inbounds %struct._obmalloc_state, ptr %19, i32 0, i32 1
  %arenas = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt21, i32 0, i32 0
  %20 = load ptr, ptr %arenas, align 8
  %21 = load i64, ptr %nbytes, align 8
  %call22 = call ptr @PyMem_RawRealloc(ptr noundef %20, i64 noundef %21)
  store ptr %call22, ptr %arenaobj, align 8
  %22 = load ptr, ptr %arenaobj, align 8
  %cmp23 = icmp eq ptr %22, null
  br i1 %cmp23, label %if.then25, label %if.end26

if.then25:                                        ; preds = %if.end19
  store ptr null, ptr %retval, align 8
  br label %return

if.end26:                                         ; preds = %if.end19
  %23 = load ptr, ptr %arenaobj, align 8
  %24 = load ptr, ptr %state.addr, align 8
  %mgmt27 = getelementptr inbounds %struct._obmalloc_state, ptr %24, i32 0, i32 1
  %arenas28 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt27, i32 0, i32 0
  store ptr %23, ptr %arenas28, align 8
  %25 = load ptr, ptr %state.addr, align 8
  %mgmt29 = getelementptr inbounds %struct._obmalloc_state, ptr %25, i32 0, i32 1
  %maxarenas30 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt29, i32 0, i32 1
  %26 = load i32, ptr %maxarenas30, align 8
  store i32 %26, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end26
  %27 = load i32, ptr %i, align 4
  %28 = load i32, ptr %numarenas, align 4
  %cmp31 = icmp ult i32 %27, %28
  br i1 %cmp31, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %29 = load ptr, ptr %state.addr, align 8
  %mgmt33 = getelementptr inbounds %struct._obmalloc_state, ptr %29, i32 0, i32 1
  %arenas34 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt33, i32 0, i32 0
  %30 = load ptr, ptr %arenas34, align 8
  %31 = load i32, ptr %i, align 4
  %idxprom = zext i32 %31 to i64
  %arrayidx = getelementptr %struct.arena_object, ptr %30, i64 %idxprom
  %address35 = getelementptr inbounds %struct.arena_object, ptr %arrayidx, i32 0, i32 0
  store i64 0, ptr %address35, align 8
  %32 = load i32, ptr %i, align 4
  %33 = load i32, ptr %numarenas, align 4
  %sub = sub i32 %33, 1
  %cmp36 = icmp ult i32 %32, %sub
  br i1 %cmp36, label %cond.true38, label %cond.false43

cond.true38:                                      ; preds = %for.body
  %34 = load ptr, ptr %state.addr, align 8
  %mgmt39 = getelementptr inbounds %struct._obmalloc_state, ptr %34, i32 0, i32 1
  %arenas40 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt39, i32 0, i32 0
  %35 = load ptr, ptr %arenas40, align 8
  %36 = load i32, ptr %i, align 4
  %add = add i32 %36, 1
  %idxprom41 = zext i32 %add to i64
  %arrayidx42 = getelementptr %struct.arena_object, ptr %35, i64 %idxprom41
  br label %cond.end44

cond.false43:                                     ; preds = %for.body
  br label %cond.end44

cond.end44:                                       ; preds = %cond.false43, %cond.true38
  %cond45 = phi ptr [ %arrayidx42, %cond.true38 ], [ null, %cond.false43 ]
  %37 = load ptr, ptr %state.addr, align 8
  %mgmt46 = getelementptr inbounds %struct._obmalloc_state, ptr %37, i32 0, i32 1
  %arenas47 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt46, i32 0, i32 0
  %38 = load ptr, ptr %arenas47, align 8
  %39 = load i32, ptr %i, align 4
  %idxprom48 = zext i32 %39 to i64
  %arrayidx49 = getelementptr %struct.arena_object, ptr %38, i64 %idxprom48
  %nextarena = getelementptr inbounds %struct.arena_object, ptr %arrayidx49, i32 0, i32 5
  store ptr %cond45, ptr %nextarena, align 8
  br label %for.inc

for.inc:                                          ; preds = %cond.end44
  %40 = load i32, ptr %i, align 4
  %inc = add i32 %40, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !148

for.end:                                          ; preds = %for.cond
  %41 = load ptr, ptr %state.addr, align 8
  %mgmt50 = getelementptr inbounds %struct._obmalloc_state, ptr %41, i32 0, i32 1
  %arenas51 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt50, i32 0, i32 0
  %42 = load ptr, ptr %arenas51, align 8
  %43 = load ptr, ptr %state.addr, align 8
  %mgmt52 = getelementptr inbounds %struct._obmalloc_state, ptr %43, i32 0, i32 1
  %maxarenas53 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt52, i32 0, i32 1
  %44 = load i32, ptr %maxarenas53, align 8
  %idxprom54 = zext i32 %44 to i64
  %arrayidx55 = getelementptr %struct.arena_object, ptr %42, i64 %idxprom54
  %45 = load ptr, ptr %state.addr, align 8
  %mgmt56 = getelementptr inbounds %struct._obmalloc_state, ptr %45, i32 0, i32 1
  %unused_arena_objects57 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt56, i32 0, i32 2
  store ptr %arrayidx55, ptr %unused_arena_objects57, align 8
  %46 = load i32, ptr %numarenas, align 4
  %47 = load ptr, ptr %state.addr, align 8
  %mgmt58 = getelementptr inbounds %struct._obmalloc_state, ptr %47, i32 0, i32 1
  %maxarenas59 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt58, i32 0, i32 1
  store i32 %46, ptr %maxarenas59, align 8
  br label %if.end60

if.end60:                                         ; preds = %for.end, %if.end6
  %48 = load ptr, ptr %state.addr, align 8
  %mgmt61 = getelementptr inbounds %struct._obmalloc_state, ptr %48, i32 0, i32 1
  %unused_arena_objects62 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt61, i32 0, i32 2
  %49 = load ptr, ptr %unused_arena_objects62, align 8
  store ptr %49, ptr %arenaobj, align 8
  %50 = load ptr, ptr %arenaobj, align 8
  %nextarena63 = getelementptr inbounds %struct.arena_object, ptr %50, i32 0, i32 5
  %51 = load ptr, ptr %nextarena63, align 8
  %52 = load ptr, ptr %state.addr, align 8
  %mgmt64 = getelementptr inbounds %struct._obmalloc_state, ptr %52, i32 0, i32 1
  %unused_arena_objects65 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt64, i32 0, i32 2
  store ptr %51, ptr %unused_arena_objects65, align 8
  %53 = load ptr, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 3, i32 1), align 8
  %54 = load ptr, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 3), align 8
  %call66 = call ptr %53(ptr noundef %54, i64 noundef 1048576)
  store ptr %call66, ptr %address, align 8
  %55 = load ptr, ptr %address, align 8
  %cmp67 = icmp ne ptr %55, null
  br i1 %cmp67, label %if.then69, label %if.end74

if.then69:                                        ; preds = %if.end60
  %56 = load ptr, ptr %state.addr, align 8
  %57 = load ptr, ptr %address, align 8
  %58 = ptrtoint ptr %57 to i64
  %call70 = call i32 @arena_map_mark_used(ptr noundef %56, i64 noundef %58, i32 noundef 1)
  %tobool71 = icmp ne i32 %call70, 0
  br i1 %tobool71, label %if.end73, label %if.then72

if.then72:                                        ; preds = %if.then69
  %59 = load ptr, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 3, i32 2), align 8
  %60 = load ptr, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 3), align 8
  %61 = load ptr, ptr %address, align 8
  call void %59(ptr noundef %60, ptr noundef %61, i64 noundef 1048576)
  store ptr null, ptr %address, align 8
  br label %if.end73

if.end73:                                         ; preds = %if.then72, %if.then69
  br label %if.end74

if.end74:                                         ; preds = %if.end73, %if.end60
  %62 = load ptr, ptr %address, align 8
  %cmp75 = icmp eq ptr %62, null
  br i1 %cmp75, label %if.then77, label %if.end83

if.then77:                                        ; preds = %if.end74
  %63 = load ptr, ptr %state.addr, align 8
  %mgmt78 = getelementptr inbounds %struct._obmalloc_state, ptr %63, i32 0, i32 1
  %unused_arena_objects79 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt78, i32 0, i32 2
  %64 = load ptr, ptr %unused_arena_objects79, align 8
  %65 = load ptr, ptr %arenaobj, align 8
  %nextarena80 = getelementptr inbounds %struct.arena_object, ptr %65, i32 0, i32 5
  store ptr %64, ptr %nextarena80, align 8
  %66 = load ptr, ptr %arenaobj, align 8
  %67 = load ptr, ptr %state.addr, align 8
  %mgmt81 = getelementptr inbounds %struct._obmalloc_state, ptr %67, i32 0, i32 1
  %unused_arena_objects82 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt81, i32 0, i32 2
  store ptr %66, ptr %unused_arena_objects82, align 8
  store ptr null, ptr %retval, align 8
  br label %return

if.end83:                                         ; preds = %if.end74
  %68 = load ptr, ptr %address, align 8
  %69 = ptrtoint ptr %68 to i64
  %70 = load ptr, ptr %arenaobj, align 8
  %address84 = getelementptr inbounds %struct.arena_object, ptr %70, i32 0, i32 0
  store i64 %69, ptr %address84, align 8
  %71 = load ptr, ptr %state.addr, align 8
  %mgmt85 = getelementptr inbounds %struct._obmalloc_state, ptr %71, i32 0, i32 1
  %narenas_currently_allocated = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt85, i32 0, i32 5
  %72 = load i64, ptr %narenas_currently_allocated, align 8
  %inc86 = add i64 %72, 1
  store i64 %inc86, ptr %narenas_currently_allocated, align 8
  %73 = load ptr, ptr %state.addr, align 8
  %mgmt87 = getelementptr inbounds %struct._obmalloc_state, ptr %73, i32 0, i32 1
  %ntimes_arena_allocated = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt87, i32 0, i32 6
  %74 = load i64, ptr %ntimes_arena_allocated, align 8
  %inc88 = add i64 %74, 1
  store i64 %inc88, ptr %ntimes_arena_allocated, align 8
  %75 = load ptr, ptr %state.addr, align 8
  %mgmt89 = getelementptr inbounds %struct._obmalloc_state, ptr %75, i32 0, i32 1
  %narenas_currently_allocated90 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt89, i32 0, i32 5
  %76 = load i64, ptr %narenas_currently_allocated90, align 8
  %77 = load ptr, ptr %state.addr, align 8
  %mgmt91 = getelementptr inbounds %struct._obmalloc_state, ptr %77, i32 0, i32 1
  %narenas_highwater = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt91, i32 0, i32 7
  %78 = load i64, ptr %narenas_highwater, align 8
  %cmp92 = icmp ugt i64 %76, %78
  br i1 %cmp92, label %if.then94, label %if.end99

if.then94:                                        ; preds = %if.end83
  %79 = load ptr, ptr %state.addr, align 8
  %mgmt95 = getelementptr inbounds %struct._obmalloc_state, ptr %79, i32 0, i32 1
  %narenas_currently_allocated96 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt95, i32 0, i32 5
  %80 = load i64, ptr %narenas_currently_allocated96, align 8
  %81 = load ptr, ptr %state.addr, align 8
  %mgmt97 = getelementptr inbounds %struct._obmalloc_state, ptr %81, i32 0, i32 1
  %narenas_highwater98 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt97, i32 0, i32 7
  store i64 %80, ptr %narenas_highwater98, align 8
  br label %if.end99

if.end99:                                         ; preds = %if.then94, %if.end83
  %82 = load ptr, ptr %arenaobj, align 8
  %freepools = getelementptr inbounds %struct.arena_object, ptr %82, i32 0, i32 4
  store ptr null, ptr %freepools, align 8
  %83 = load ptr, ptr %arenaobj, align 8
  %address100 = getelementptr inbounds %struct.arena_object, ptr %83, i32 0, i32 0
  %84 = load i64, ptr %address100, align 8
  %85 = inttoptr i64 %84 to ptr
  %86 = load ptr, ptr %arenaobj, align 8
  %pool_address = getelementptr inbounds %struct.arena_object, ptr %86, i32 0, i32 1
  store ptr %85, ptr %pool_address, align 8
  %87 = load ptr, ptr %arenaobj, align 8
  %nfreepools = getelementptr inbounds %struct.arena_object, ptr %87, i32 0, i32 2
  store i32 64, ptr %nfreepools, align 8
  %88 = load ptr, ptr %arenaobj, align 8
  %address101 = getelementptr inbounds %struct.arena_object, ptr %88, i32 0, i32 0
  %89 = load i64, ptr %address101, align 8
  %and = and i64 %89, 16383
  %conv102 = trunc i64 %and to i32
  store i32 %conv102, ptr %excess, align 4
  %90 = load i32, ptr %excess, align 4
  %cmp103 = icmp ne i32 %90, 0
  br i1 %cmp103, label %if.then105, label %if.end109

if.then105:                                       ; preds = %if.end99
  %91 = load ptr, ptr %arenaobj, align 8
  %nfreepools106 = getelementptr inbounds %struct.arena_object, ptr %91, i32 0, i32 2
  %92 = load i32, ptr %nfreepools106, align 8
  %dec = add i32 %92, -1
  store i32 %dec, ptr %nfreepools106, align 8
  %93 = load i32, ptr %excess, align 4
  %sub107 = sub i32 16384, %93
  %94 = load ptr, ptr %arenaobj, align 8
  %pool_address108 = getelementptr inbounds %struct.arena_object, ptr %94, i32 0, i32 1
  %95 = load ptr, ptr %pool_address108, align 8
  %idx.ext = zext i32 %sub107 to i64
  %add.ptr = getelementptr i8, ptr %95, i64 %idx.ext
  store ptr %add.ptr, ptr %pool_address108, align 8
  br label %if.end109

if.end109:                                        ; preds = %if.then105, %if.end99
  %96 = load ptr, ptr %arenaobj, align 8
  %nfreepools110 = getelementptr inbounds %struct.arena_object, ptr %96, i32 0, i32 2
  %97 = load i32, ptr %nfreepools110, align 8
  %98 = load ptr, ptr %arenaobj, align 8
  %ntotalpools = getelementptr inbounds %struct.arena_object, ptr %98, i32 0, i32 3
  store i32 %97, ptr %ntotalpools, align 4
  %99 = load ptr, ptr %arenaobj, align 8
  store ptr %99, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end109, %if.then77, %if.then25, %if.then18
  %100 = load ptr, ptr %retval, align 8
  ret ptr %100
}

declare ptr @Py_GETENV(ptr noundef) #8

; Function Attrs: nounwind uwtable
define internal i32 @arena_map_mark_used(ptr noundef %state, i64 noundef %arena_base, i32 noundef %is_used) #0 {
entry:
  %retval.i33 = alloca ptr, align 8
  %state.addr.i34 = alloca ptr, align 8
  %p.addr.i35 = alloca ptr, align 8
  %create.addr.i36 = alloca i32, align 4
  %i1.i37 = alloca i32, align 4
  %n.i38 = alloca ptr, align 8
  %i2.i39 = alloca i32, align 4
  %n31.i40 = alloca ptr, align 8
  %retval.i = alloca ptr, align 8
  %state.addr.i = alloca ptr, align 8
  %p.addr.i = alloca ptr, align 8
  %create.addr.i = alloca i32, align 4
  %i1.i = alloca i32, align 4
  %n.i = alloca ptr, align 8
  %i2.i = alloca i32, align 4
  %n31.i = alloca ptr, align 8
  %retval = alloca i32, align 4
  %state.addr = alloca ptr, align 8
  %arena_base.addr = alloca i64, align 8
  %is_used.addr = alloca i32, align 4
  %n_hi = alloca ptr, align 8
  %i3 = alloca i32, align 4
  %tail = alloca i32, align 4
  %arena_base_next = alloca i64, align 8
  %n_lo = alloca ptr, align 8
  %i3_next = alloca i32, align 4
  store ptr %state, ptr %state.addr, align 8
  store i64 %arena_base, ptr %arena_base.addr, align 8
  store i32 %is_used, ptr %is_used.addr, align 4
  %0 = load ptr, ptr %state.addr, align 8
  %1 = load i64, ptr %arena_base.addr, align 8
  %2 = inttoptr i64 %1 to ptr
  %3 = load i32, ptr %is_used.addr, align 4
  store ptr %0, ptr %state.addr.i34, align 8
  store ptr %2, ptr %p.addr.i35, align 8
  store i32 %3, ptr %create.addr.i36, align 4
  %4 = load ptr, ptr %p.addr.i35, align 8
  %5 = ptrtoint ptr %4 to i64
  %shr.i41 = lshr i64 %5, 49
  %conv.i42 = trunc i64 %shr.i41 to i32
  store i32 %conv.i42, ptr %i1.i37, align 4
  %6 = load ptr, ptr %state.addr.i34, align 8
  %usage.i43 = getelementptr inbounds %struct._obmalloc_state, ptr %6, i32 0, i32 2
  %7 = load i32, ptr %i1.i37, align 4
  %idxprom.i44 = sext i32 %7 to i64
  %arrayidx.i45 = getelementptr [32768 x ptr], ptr %usage.i43, i64 0, i64 %idxprom.i44
  %8 = load ptr, ptr %arrayidx.i45, align 8
  %cmp.i46 = icmp eq ptr %8, null
  br i1 %cmp.i46, label %if.then.i79, label %if.end13.i47

if.then.i79:                                      ; preds = %entry
  %9 = load i32, ptr %create.addr.i36, align 4
  %tobool.i80 = icmp ne i32 %9, 0
  br i1 %tobool.i80, label %if.end.i82, label %if.then2.i81

if.then2.i81:                                     ; preds = %if.then.i79
  store ptr null, ptr %retval.i33, align 8
  br label %arena_map_get.exit93

if.end.i82:                                       ; preds = %if.then.i79
  %call.i83 = call ptr @PyMem_RawCalloc(i64 noundef 1, i64 noundef 262144)
  store ptr %call.i83, ptr %n.i38, align 8
  %10 = load ptr, ptr %n.i38, align 8
  %cmp3.i84 = icmp eq ptr %10, null
  br i1 %cmp3.i84, label %if.then5.i92, label %if.end6.i85

if.then5.i92:                                     ; preds = %if.end.i82
  store ptr null, ptr %retval.i33, align 8
  br label %arena_map_get.exit93

if.end6.i85:                                      ; preds = %if.end.i82
  %11 = load ptr, ptr %n.i38, align 8
  %12 = load ptr, ptr %state.addr.i34, align 8
  %usage7.i86 = getelementptr inbounds %struct._obmalloc_state, ptr %12, i32 0, i32 2
  %13 = load i32, ptr %i1.i37, align 4
  %idxprom10.i87 = sext i32 %13 to i64
  %arrayidx11.i88 = getelementptr [32768 x ptr], ptr %usage7.i86, i64 0, i64 %idxprom10.i87
  store ptr %11, ptr %arrayidx11.i88, align 8
  %14 = load ptr, ptr %state.addr.i34, align 8
  %usage12.i89 = getelementptr inbounds %struct._obmalloc_state, ptr %14, i32 0, i32 2
  %arena_map_mid_count.i90 = getelementptr inbounds %struct._obmalloc_usage, ptr %usage12.i89, i32 0, i32 1
  %15 = load i32, ptr %arena_map_mid_count.i90, align 8
  %inc.i91 = add i32 %15, 1
  store i32 %inc.i91, ptr %arena_map_mid_count.i90, align 8
  br label %if.end13.i47

if.end13.i47:                                     ; preds = %if.end6.i85, %entry
  %16 = load ptr, ptr %p.addr.i35, align 8
  %17 = ptrtoint ptr %16 to i64
  %shr14.i48 = lshr i64 %17, 34
  %and15.i49 = and i64 %shr14.i48, 32767
  %conv16.i50 = trunc i64 %and15.i49 to i32
  store i32 %conv16.i50, ptr %i2.i39, align 4
  %18 = load ptr, ptr %state.addr.i34, align 8
  %usage17.i51 = getelementptr inbounds %struct._obmalloc_state, ptr %18, i32 0, i32 2
  %19 = load i32, ptr %i1.i37, align 4
  %idxprom20.i52 = sext i32 %19 to i64
  %arrayidx21.i53 = getelementptr [32768 x ptr], ptr %usage17.i51, i64 0, i64 %idxprom20.i52
  %20 = load ptr, ptr %arrayidx21.i53, align 8
  %21 = load i32, ptr %i2.i39, align 4
  %idxprom23.i54 = sext i32 %21 to i64
  %arrayidx24.i55 = getelementptr [32768 x ptr], ptr %20, i64 0, i64 %idxprom23.i54
  %22 = load ptr, ptr %arrayidx24.i55, align 8
  %cmp25.i56 = icmp eq ptr %22, null
  br i1 %cmp25.i56, label %if.then27.i63, label %if.end47.i57

if.then27.i63:                                    ; preds = %if.end13.i47
  %23 = load i32, ptr %create.addr.i36, align 4
  %tobool28.i64 = icmp ne i32 %23, 0
  br i1 %tobool28.i64, label %if.end30.i66, label %if.then29.i65

if.then29.i65:                                    ; preds = %if.then27.i63
  store ptr null, ptr %retval.i33, align 8
  br label %arena_map_get.exit93

if.end30.i66:                                     ; preds = %if.then27.i63
  %call32.i67 = call ptr @PyMem_RawCalloc(i64 noundef 1, i64 noundef 131072)
  store ptr %call32.i67, ptr %n31.i40, align 8
  %24 = load ptr, ptr %n31.i40, align 8
  %cmp33.i68 = icmp eq ptr %24, null
  br i1 %cmp33.i68, label %if.then35.i78, label %if.end36.i69

if.then35.i78:                                    ; preds = %if.end30.i66
  store ptr null, ptr %retval.i33, align 8
  br label %arena_map_get.exit93

if.end36.i69:                                     ; preds = %if.end30.i66
  %25 = load ptr, ptr %n31.i40, align 8
  %26 = load ptr, ptr %state.addr.i34, align 8
  %usage37.i70 = getelementptr inbounds %struct._obmalloc_state, ptr %26, i32 0, i32 2
  %27 = load i32, ptr %i1.i37, align 4
  %idxprom40.i71 = sext i32 %27 to i64
  %arrayidx41.i72 = getelementptr [32768 x ptr], ptr %usage37.i70, i64 0, i64 %idxprom40.i71
  %28 = load ptr, ptr %arrayidx41.i72, align 8
  %29 = load i32, ptr %i2.i39, align 4
  %idxprom43.i73 = sext i32 %29 to i64
  %arrayidx44.i74 = getelementptr [32768 x ptr], ptr %28, i64 0, i64 %idxprom43.i73
  store ptr %25, ptr %arrayidx44.i74, align 8
  %30 = load ptr, ptr %state.addr.i34, align 8
  %usage45.i75 = getelementptr inbounds %struct._obmalloc_state, ptr %30, i32 0, i32 2
  %arena_map_bot_count.i76 = getelementptr inbounds %struct._obmalloc_usage, ptr %usage45.i75, i32 0, i32 2
  %31 = load i32, ptr %arena_map_bot_count.i76, align 4
  %inc46.i77 = add i32 %31, 1
  store i32 %inc46.i77, ptr %arena_map_bot_count.i76, align 4
  br label %if.end47.i57

if.end47.i57:                                     ; preds = %if.end36.i69, %if.end13.i47
  %32 = load ptr, ptr %state.addr.i34, align 8
  %usage48.i58 = getelementptr inbounds %struct._obmalloc_state, ptr %32, i32 0, i32 2
  %33 = load i32, ptr %i1.i37, align 4
  %idxprom51.i59 = sext i32 %33 to i64
  %arrayidx52.i60 = getelementptr [32768 x ptr], ptr %usage48.i58, i64 0, i64 %idxprom51.i59
  %34 = load ptr, ptr %arrayidx52.i60, align 8
  %35 = load i32, ptr %i2.i39, align 4
  %idxprom54.i61 = sext i32 %35 to i64
  %arrayidx55.i62 = getelementptr [32768 x ptr], ptr %34, i64 0, i64 %idxprom54.i61
  %36 = load ptr, ptr %arrayidx55.i62, align 8
  store ptr %36, ptr %retval.i33, align 8
  br label %arena_map_get.exit93

arena_map_get.exit93:                             ; preds = %if.end47.i57, %if.then35.i78, %if.then29.i65, %if.then5.i92, %if.then2.i81
  %37 = load ptr, ptr %retval.i33, align 8
  store ptr %37, ptr %n_hi, align 8
  %38 = load ptr, ptr %n_hi, align 8
  %cmp = icmp eq ptr %38, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %arena_map_get.exit93
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %arena_map_get.exit93
  %39 = load i64, ptr %arena_base.addr, align 8
  %40 = inttoptr i64 %39 to ptr
  %41 = ptrtoint ptr %40 to i64
  %shr = lshr i64 %41, 20
  %and = and i64 %shr, 16383
  %conv = trunc i64 %and to i32
  store i32 %conv, ptr %i3, align 4
  %42 = load i64, ptr %arena_base.addr, align 8
  %and1 = and i64 %42, 1048575
  %conv2 = trunc i64 %and1 to i32
  store i32 %conv2, ptr %tail, align 4
  %43 = load i32, ptr %tail, align 4
  %cmp3 = icmp eq i32 %43, 0
  br i1 %cmp3, label %if.then5, label %if.else

if.then5:                                         ; preds = %if.end
  %44 = load i32, ptr %is_used.addr, align 4
  %tobool = icmp ne i32 %44, 0
  %cond = select i1 %tobool, i32 -1, i32 0
  %45 = load ptr, ptr %n_hi, align 8
  %arenas = getelementptr inbounds %struct.arena_map_bot, ptr %45, i32 0, i32 0
  %46 = load i32, ptr %i3, align 4
  %idxprom = sext i32 %46 to i64
  %arrayidx = getelementptr [16384 x %struct.arena_coverage_t], ptr %arenas, i64 0, i64 %idxprom
  %tail_hi = getelementptr inbounds %struct.arena_coverage_t, ptr %arrayidx, i32 0, i32 0
  store i32 %cond, ptr %tail_hi, align 4
  br label %if.end32

if.else:                                          ; preds = %if.end
  %47 = load i32, ptr %is_used.addr, align 4
  %tobool6 = icmp ne i32 %47, 0
  br i1 %tobool6, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.else
  %48 = load i32, ptr %tail, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.else
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond7 = phi i32 [ %48, %cond.true ], [ 0, %cond.false ]
  %49 = load ptr, ptr %n_hi, align 8
  %arenas8 = getelementptr inbounds %struct.arena_map_bot, ptr %49, i32 0, i32 0
  %50 = load i32, ptr %i3, align 4
  %idxprom9 = sext i32 %50 to i64
  %arrayidx10 = getelementptr [16384 x %struct.arena_coverage_t], ptr %arenas8, i64 0, i64 %idxprom9
  %tail_hi11 = getelementptr inbounds %struct.arena_coverage_t, ptr %arrayidx10, i32 0, i32 0
  store i32 %cond7, ptr %tail_hi11, align 4
  %51 = load i64, ptr %arena_base.addr, align 8
  %add = add i64 %51, 1048576
  store i64 %add, ptr %arena_base_next, align 8
  %52 = load ptr, ptr %state.addr, align 8
  %53 = load i64, ptr %arena_base_next, align 8
  %54 = inttoptr i64 %53 to ptr
  %55 = load i32, ptr %is_used.addr, align 4
  store ptr %52, ptr %state.addr.i, align 8
  store ptr %54, ptr %p.addr.i, align 8
  store i32 %55, ptr %create.addr.i, align 4
  %56 = load ptr, ptr %p.addr.i, align 8
  %57 = ptrtoint ptr %56 to i64
  %shr.i = lshr i64 %57, 49
  %conv.i = trunc i64 %shr.i to i32
  store i32 %conv.i, ptr %i1.i, align 4
  %58 = load ptr, ptr %state.addr.i, align 8
  %usage.i = getelementptr inbounds %struct._obmalloc_state, ptr %58, i32 0, i32 2
  %59 = load i32, ptr %i1.i, align 4
  %idxprom.i = sext i32 %59 to i64
  %arrayidx.i = getelementptr [32768 x ptr], ptr %usage.i, i64 0, i64 %idxprom.i
  %60 = load ptr, ptr %arrayidx.i, align 8
  %cmp.i = icmp eq ptr %60, null
  br i1 %cmp.i, label %if.then.i, label %if.end13.i

if.then.i:                                        ; preds = %cond.end
  %61 = load i32, ptr %create.addr.i, align 4
  %tobool.i = icmp ne i32 %61, 0
  br i1 %tobool.i, label %if.end.i, label %if.then2.i

if.then2.i:                                       ; preds = %if.then.i
  store ptr null, ptr %retval.i, align 8
  br label %arena_map_get.exit

if.end.i:                                         ; preds = %if.then.i
  %call.i = call ptr @PyMem_RawCalloc(i64 noundef 1, i64 noundef 262144)
  store ptr %call.i, ptr %n.i, align 8
  %62 = load ptr, ptr %n.i, align 8
  %cmp3.i = icmp eq ptr %62, null
  br i1 %cmp3.i, label %if.then5.i, label %if.end6.i

if.then5.i:                                       ; preds = %if.end.i
  store ptr null, ptr %retval.i, align 8
  br label %arena_map_get.exit

if.end6.i:                                        ; preds = %if.end.i
  %63 = load ptr, ptr %n.i, align 8
  %64 = load ptr, ptr %state.addr.i, align 8
  %usage7.i = getelementptr inbounds %struct._obmalloc_state, ptr %64, i32 0, i32 2
  %65 = load i32, ptr %i1.i, align 4
  %idxprom10.i = sext i32 %65 to i64
  %arrayidx11.i = getelementptr [32768 x ptr], ptr %usage7.i, i64 0, i64 %idxprom10.i
  store ptr %63, ptr %arrayidx11.i, align 8
  %66 = load ptr, ptr %state.addr.i, align 8
  %usage12.i = getelementptr inbounds %struct._obmalloc_state, ptr %66, i32 0, i32 2
  %arena_map_mid_count.i = getelementptr inbounds %struct._obmalloc_usage, ptr %usage12.i, i32 0, i32 1
  %67 = load i32, ptr %arena_map_mid_count.i, align 8
  %inc.i = add i32 %67, 1
  store i32 %inc.i, ptr %arena_map_mid_count.i, align 8
  br label %if.end13.i

if.end13.i:                                       ; preds = %if.end6.i, %cond.end
  %68 = load ptr, ptr %p.addr.i, align 8
  %69 = ptrtoint ptr %68 to i64
  %shr14.i = lshr i64 %69, 34
  %and15.i = and i64 %shr14.i, 32767
  %conv16.i = trunc i64 %and15.i to i32
  store i32 %conv16.i, ptr %i2.i, align 4
  %70 = load ptr, ptr %state.addr.i, align 8
  %usage17.i = getelementptr inbounds %struct._obmalloc_state, ptr %70, i32 0, i32 2
  %71 = load i32, ptr %i1.i, align 4
  %idxprom20.i = sext i32 %71 to i64
  %arrayidx21.i = getelementptr [32768 x ptr], ptr %usage17.i, i64 0, i64 %idxprom20.i
  %72 = load ptr, ptr %arrayidx21.i, align 8
  %73 = load i32, ptr %i2.i, align 4
  %idxprom23.i = sext i32 %73 to i64
  %arrayidx24.i = getelementptr [32768 x ptr], ptr %72, i64 0, i64 %idxprom23.i
  %74 = load ptr, ptr %arrayidx24.i, align 8
  %cmp25.i = icmp eq ptr %74, null
  br i1 %cmp25.i, label %if.then27.i, label %if.end47.i

if.then27.i:                                      ; preds = %if.end13.i
  %75 = load i32, ptr %create.addr.i, align 4
  %tobool28.i = icmp ne i32 %75, 0
  br i1 %tobool28.i, label %if.end30.i, label %if.then29.i

if.then29.i:                                      ; preds = %if.then27.i
  store ptr null, ptr %retval.i, align 8
  br label %arena_map_get.exit

if.end30.i:                                       ; preds = %if.then27.i
  %call32.i = call ptr @PyMem_RawCalloc(i64 noundef 1, i64 noundef 131072)
  store ptr %call32.i, ptr %n31.i, align 8
  %76 = load ptr, ptr %n31.i, align 8
  %cmp33.i = icmp eq ptr %76, null
  br i1 %cmp33.i, label %if.then35.i, label %if.end36.i

if.then35.i:                                      ; preds = %if.end30.i
  store ptr null, ptr %retval.i, align 8
  br label %arena_map_get.exit

if.end36.i:                                       ; preds = %if.end30.i
  %77 = load ptr, ptr %n31.i, align 8
  %78 = load ptr, ptr %state.addr.i, align 8
  %usage37.i = getelementptr inbounds %struct._obmalloc_state, ptr %78, i32 0, i32 2
  %79 = load i32, ptr %i1.i, align 4
  %idxprom40.i = sext i32 %79 to i64
  %arrayidx41.i = getelementptr [32768 x ptr], ptr %usage37.i, i64 0, i64 %idxprom40.i
  %80 = load ptr, ptr %arrayidx41.i, align 8
  %81 = load i32, ptr %i2.i, align 4
  %idxprom43.i = sext i32 %81 to i64
  %arrayidx44.i = getelementptr [32768 x ptr], ptr %80, i64 0, i64 %idxprom43.i
  store ptr %77, ptr %arrayidx44.i, align 8
  %82 = load ptr, ptr %state.addr.i, align 8
  %usage45.i = getelementptr inbounds %struct._obmalloc_state, ptr %82, i32 0, i32 2
  %arena_map_bot_count.i = getelementptr inbounds %struct._obmalloc_usage, ptr %usage45.i, i32 0, i32 2
  %83 = load i32, ptr %arena_map_bot_count.i, align 4
  %inc46.i = add i32 %83, 1
  store i32 %inc46.i, ptr %arena_map_bot_count.i, align 4
  br label %if.end47.i

if.end47.i:                                       ; preds = %if.end36.i, %if.end13.i
  %84 = load ptr, ptr %state.addr.i, align 8
  %usage48.i = getelementptr inbounds %struct._obmalloc_state, ptr %84, i32 0, i32 2
  %85 = load i32, ptr %i1.i, align 4
  %idxprom51.i = sext i32 %85 to i64
  %arrayidx52.i = getelementptr [32768 x ptr], ptr %usage48.i, i64 0, i64 %idxprom51.i
  %86 = load ptr, ptr %arrayidx52.i, align 8
  %87 = load i32, ptr %i2.i, align 4
  %idxprom54.i = sext i32 %87 to i64
  %arrayidx55.i = getelementptr [32768 x ptr], ptr %86, i64 0, i64 %idxprom54.i
  %88 = load ptr, ptr %arrayidx55.i, align 8
  store ptr %88, ptr %retval.i, align 8
  br label %arena_map_get.exit

arena_map_get.exit:                               ; preds = %if.end47.i, %if.then35.i, %if.then29.i, %if.then5.i, %if.then2.i
  %89 = load ptr, ptr %retval.i, align 8
  store ptr %89, ptr %n_lo, align 8
  %90 = load ptr, ptr %n_lo, align 8
  %cmp13 = icmp eq ptr %90, null
  br i1 %cmp13, label %if.then15, label %if.end20

if.then15:                                        ; preds = %arena_map_get.exit
  %91 = load ptr, ptr %n_hi, align 8
  %arenas16 = getelementptr inbounds %struct.arena_map_bot, ptr %91, i32 0, i32 0
  %92 = load i32, ptr %i3, align 4
  %idxprom17 = sext i32 %92 to i64
  %arrayidx18 = getelementptr [16384 x %struct.arena_coverage_t], ptr %arenas16, i64 0, i64 %idxprom17
  %tail_hi19 = getelementptr inbounds %struct.arena_coverage_t, ptr %arrayidx18, i32 0, i32 0
  store i32 0, ptr %tail_hi19, align 4
  store i32 0, ptr %retval, align 4
  br label %return

if.end20:                                         ; preds = %arena_map_get.exit
  %93 = load i64, ptr %arena_base_next, align 8
  %shr21 = lshr i64 %93, 20
  %and22 = and i64 %shr21, 16383
  %conv23 = trunc i64 %and22 to i32
  store i32 %conv23, ptr %i3_next, align 4
  %94 = load i32, ptr %is_used.addr, align 4
  %tobool24 = icmp ne i32 %94, 0
  br i1 %tobool24, label %cond.true25, label %cond.false26

cond.true25:                                      ; preds = %if.end20
  %95 = load i32, ptr %tail, align 4
  br label %cond.end27

cond.false26:                                     ; preds = %if.end20
  br label %cond.end27

cond.end27:                                       ; preds = %cond.false26, %cond.true25
  %cond28 = phi i32 [ %95, %cond.true25 ], [ 0, %cond.false26 ]
  %96 = load ptr, ptr %n_lo, align 8
  %arenas29 = getelementptr inbounds %struct.arena_map_bot, ptr %96, i32 0, i32 0
  %97 = load i32, ptr %i3_next, align 4
  %idxprom30 = sext i32 %97 to i64
  %arrayidx31 = getelementptr [16384 x %struct.arena_coverage_t], ptr %arenas29, i64 0, i64 %idxprom30
  %tail_lo = getelementptr inbounds %struct.arena_coverage_t, ptr %arrayidx31, i32 0, i32 1
  store i32 %cond28, ptr %tail_lo, align 4
  br label %if.end32

if.end32:                                         ; preds = %cond.end27, %if.then5
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end32, %if.then15, %if.then
  %98 = load i32, ptr %retval, align 4
  ret i32 %98
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @address_in_range(ptr noundef %state, ptr noundef %p, ptr noundef %_unused_pool) #0 {
entry:
  %state.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %_unused_pool.addr = alloca ptr, align 8
  store ptr %state, ptr %state.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store ptr %_unused_pool, ptr %_unused_pool.addr, align 8
  %0 = load ptr, ptr %state.addr, align 8
  %1 = load ptr, ptr %p.addr, align 8
  %call = call i32 @arena_map_is_used(ptr noundef %0, ptr noundef %1)
  %tobool = icmp ne i32 %call, 0
  ret i1 %tobool
}

; Function Attrs: nounwind uwtable
define internal void @insert_to_usedpool(ptr noundef %state, ptr noundef %pool) #0 {
entry:
  %state.addr = alloca ptr, align 8
  %pool.addr = alloca ptr, align 8
  %size = alloca i32, align 4
  %next = alloca ptr, align 8
  %prev = alloca ptr, align 8
  store ptr %state, ptr %state.addr, align 8
  store ptr %pool, ptr %pool.addr, align 8
  %0 = load ptr, ptr %pool.addr, align 8
  %szidx = getelementptr inbounds %struct.pool_header, ptr %0, i32 0, i32 5
  %1 = load i32, ptr %szidx, align 4
  store i32 %1, ptr %size, align 4
  %2 = load ptr, ptr %state.addr, align 8
  %pools = getelementptr inbounds %struct._obmalloc_state, ptr %2, i32 0, i32 0
  %used = getelementptr inbounds %struct._obmalloc_pools, ptr %pools, i32 0, i32 0
  %3 = load i32, ptr %size, align 4
  %4 = load i32, ptr %size, align 4
  %add = add i32 %3, %4
  %idxprom = zext i32 %add to i64
  %arrayidx = getelementptr [64 x ptr], ptr %used, i64 0, i64 %idxprom
  %5 = load ptr, ptr %arrayidx, align 8
  store ptr %5, ptr %next, align 8
  %6 = load ptr, ptr %next, align 8
  %prevpool = getelementptr inbounds %struct.pool_header, ptr %6, i32 0, i32 3
  %7 = load ptr, ptr %prevpool, align 8
  store ptr %7, ptr %prev, align 8
  %8 = load ptr, ptr %next, align 8
  %9 = load ptr, ptr %pool.addr, align 8
  %nextpool = getelementptr inbounds %struct.pool_header, ptr %9, i32 0, i32 2
  store ptr %8, ptr %nextpool, align 8
  %10 = load ptr, ptr %prev, align 8
  %11 = load ptr, ptr %pool.addr, align 8
  %prevpool1 = getelementptr inbounds %struct.pool_header, ptr %11, i32 0, i32 3
  store ptr %10, ptr %prevpool1, align 8
  %12 = load ptr, ptr %pool.addr, align 8
  %13 = load ptr, ptr %next, align 8
  %prevpool2 = getelementptr inbounds %struct.pool_header, ptr %13, i32 0, i32 3
  store ptr %12, ptr %prevpool2, align 8
  %14 = load ptr, ptr %pool.addr, align 8
  %15 = load ptr, ptr %prev, align 8
  %nextpool3 = getelementptr inbounds %struct.pool_header, ptr %15, i32 0, i32 2
  store ptr %14, ptr %nextpool3, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @insert_to_freepool(ptr noundef %state, ptr noundef %pool) #0 {
entry:
  %state.addr = alloca ptr, align 8
  %pool.addr = alloca ptr, align 8
  %next = alloca ptr, align 8
  %prev = alloca ptr, align 8
  %ao = alloca ptr, align 8
  %nf = alloca i32, align 4
  %lastnf = alloca ptr, align 8
  %p = alloca ptr, align 8
  store ptr %state, ptr %state.addr, align 8
  store ptr %pool, ptr %pool.addr, align 8
  %0 = load ptr, ptr %pool.addr, align 8
  %nextpool = getelementptr inbounds %struct.pool_header, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %nextpool, align 8
  store ptr %1, ptr %next, align 8
  %2 = load ptr, ptr %pool.addr, align 8
  %prevpool = getelementptr inbounds %struct.pool_header, ptr %2, i32 0, i32 3
  %3 = load ptr, ptr %prevpool, align 8
  store ptr %3, ptr %prev, align 8
  %4 = load ptr, ptr %prev, align 8
  %5 = load ptr, ptr %next, align 8
  %prevpool1 = getelementptr inbounds %struct.pool_header, ptr %5, i32 0, i32 3
  store ptr %4, ptr %prevpool1, align 8
  %6 = load ptr, ptr %next, align 8
  %7 = load ptr, ptr %prev, align 8
  %nextpool2 = getelementptr inbounds %struct.pool_header, ptr %7, i32 0, i32 2
  store ptr %6, ptr %nextpool2, align 8
  %8 = load ptr, ptr %state.addr, align 8
  %mgmt = getelementptr inbounds %struct._obmalloc_state, ptr %8, i32 0, i32 1
  %arenas = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt, i32 0, i32 0
  %9 = load ptr, ptr %arenas, align 8
  %10 = load ptr, ptr %pool.addr, align 8
  %arenaindex = getelementptr inbounds %struct.pool_header, ptr %10, i32 0, i32 4
  %11 = load i32, ptr %arenaindex, align 8
  %idxprom = zext i32 %11 to i64
  %arrayidx = getelementptr %struct.arena_object, ptr %9, i64 %idxprom
  store ptr %arrayidx, ptr %ao, align 8
  %12 = load ptr, ptr %ao, align 8
  %freepools = getelementptr inbounds %struct.arena_object, ptr %12, i32 0, i32 4
  %13 = load ptr, ptr %freepools, align 8
  %14 = load ptr, ptr %pool.addr, align 8
  %nextpool3 = getelementptr inbounds %struct.pool_header, ptr %14, i32 0, i32 2
  store ptr %13, ptr %nextpool3, align 8
  %15 = load ptr, ptr %pool.addr, align 8
  %16 = load ptr, ptr %ao, align 8
  %freepools4 = getelementptr inbounds %struct.arena_object, ptr %16, i32 0, i32 4
  store ptr %15, ptr %freepools4, align 8
  %17 = load ptr, ptr %ao, align 8
  %nfreepools = getelementptr inbounds %struct.arena_object, ptr %17, i32 0, i32 2
  %18 = load i32, ptr %nfreepools, align 8
  store i32 %18, ptr %nf, align 4
  %19 = load ptr, ptr %state.addr, align 8
  %mgmt5 = getelementptr inbounds %struct._obmalloc_state, ptr %19, i32 0, i32 1
  %nfp2lasta = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt5, i32 0, i32 4
  %20 = load i32, ptr %nf, align 4
  %idxprom6 = zext i32 %20 to i64
  %arrayidx7 = getelementptr [65 x ptr], ptr %nfp2lasta, i64 0, i64 %idxprom6
  %21 = load ptr, ptr %arrayidx7, align 8
  store ptr %21, ptr %lastnf, align 8
  %22 = load ptr, ptr %lastnf, align 8
  %23 = load ptr, ptr %ao, align 8
  %cmp = icmp eq ptr %22, %23
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %24 = load ptr, ptr %ao, align 8
  %prevarena = getelementptr inbounds %struct.arena_object, ptr %24, i32 0, i32 6
  %25 = load ptr, ptr %prevarena, align 8
  store ptr %25, ptr %p, align 8
  %26 = load ptr, ptr %p, align 8
  %cmp8 = icmp ne ptr %26, null
  br i1 %cmp8, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %if.then
  %27 = load ptr, ptr %p, align 8
  %nfreepools9 = getelementptr inbounds %struct.arena_object, ptr %27, i32 0, i32 2
  %28 = load i32, ptr %nfreepools9, align 8
  %29 = load i32, ptr %nf, align 4
  %cmp10 = icmp eq i32 %28, %29
  br i1 %cmp10, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  %30 = load ptr, ptr %p, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %if.then
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %30, %cond.true ], [ null, %cond.false ]
  %31 = load ptr, ptr %state.addr, align 8
  %mgmt11 = getelementptr inbounds %struct._obmalloc_state, ptr %31, i32 0, i32 1
  %nfp2lasta12 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt11, i32 0, i32 4
  %32 = load i32, ptr %nf, align 4
  %idxprom13 = zext i32 %32 to i64
  %arrayidx14 = getelementptr [65 x ptr], ptr %nfp2lasta12, i64 0, i64 %idxprom13
  store ptr %cond, ptr %arrayidx14, align 8
  br label %if.end

if.end:                                           ; preds = %cond.end, %entry
  %33 = load i32, ptr %nf, align 4
  %inc = add i32 %33, 1
  store i32 %inc, ptr %nf, align 4
  %34 = load ptr, ptr %ao, align 8
  %nfreepools15 = getelementptr inbounds %struct.arena_object, ptr %34, i32 0, i32 2
  store i32 %inc, ptr %nfreepools15, align 8
  %35 = load i32, ptr %nf, align 4
  %36 = load ptr, ptr %ao, align 8
  %ntotalpools = getelementptr inbounds %struct.arena_object, ptr %36, i32 0, i32 3
  %37 = load i32, ptr %ntotalpools, align 4
  %cmp16 = icmp eq i32 %35, %37
  br i1 %cmp16, label %land.lhs.true17, label %if.end43

land.lhs.true17:                                  ; preds = %if.end
  %38 = load ptr, ptr %ao, align 8
  %nextarena = getelementptr inbounds %struct.arena_object, ptr %38, i32 0, i32 5
  %39 = load ptr, ptr %nextarena, align 8
  %cmp18 = icmp ne ptr %39, null
  br i1 %cmp18, label %if.then19, label %if.end43

if.then19:                                        ; preds = %land.lhs.true17
  %40 = load ptr, ptr %ao, align 8
  %prevarena20 = getelementptr inbounds %struct.arena_object, ptr %40, i32 0, i32 6
  %41 = load ptr, ptr %prevarena20, align 8
  %cmp21 = icmp eq ptr %41, null
  br i1 %cmp21, label %if.then22, label %if.else

if.then22:                                        ; preds = %if.then19
  %42 = load ptr, ptr %ao, align 8
  %nextarena23 = getelementptr inbounds %struct.arena_object, ptr %42, i32 0, i32 5
  %43 = load ptr, ptr %nextarena23, align 8
  %44 = load ptr, ptr %state.addr, align 8
  %mgmt24 = getelementptr inbounds %struct._obmalloc_state, ptr %44, i32 0, i32 1
  %usable_arenas = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt24, i32 0, i32 3
  store ptr %43, ptr %usable_arenas, align 8
  br label %if.end28

if.else:                                          ; preds = %if.then19
  %45 = load ptr, ptr %ao, align 8
  %nextarena25 = getelementptr inbounds %struct.arena_object, ptr %45, i32 0, i32 5
  %46 = load ptr, ptr %nextarena25, align 8
  %47 = load ptr, ptr %ao, align 8
  %prevarena26 = getelementptr inbounds %struct.arena_object, ptr %47, i32 0, i32 6
  %48 = load ptr, ptr %prevarena26, align 8
  %nextarena27 = getelementptr inbounds %struct.arena_object, ptr %48, i32 0, i32 5
  store ptr %46, ptr %nextarena27, align 8
  br label %if.end28

if.end28:                                         ; preds = %if.else, %if.then22
  %49 = load ptr, ptr %ao, align 8
  %nextarena29 = getelementptr inbounds %struct.arena_object, ptr %49, i32 0, i32 5
  %50 = load ptr, ptr %nextarena29, align 8
  %cmp30 = icmp ne ptr %50, null
  br i1 %cmp30, label %if.then31, label %if.end35

if.then31:                                        ; preds = %if.end28
  %51 = load ptr, ptr %ao, align 8
  %prevarena32 = getelementptr inbounds %struct.arena_object, ptr %51, i32 0, i32 6
  %52 = load ptr, ptr %prevarena32, align 8
  %53 = load ptr, ptr %ao, align 8
  %nextarena33 = getelementptr inbounds %struct.arena_object, ptr %53, i32 0, i32 5
  %54 = load ptr, ptr %nextarena33, align 8
  %prevarena34 = getelementptr inbounds %struct.arena_object, ptr %54, i32 0, i32 6
  store ptr %52, ptr %prevarena34, align 8
  br label %if.end35

if.end35:                                         ; preds = %if.then31, %if.end28
  %55 = load ptr, ptr %state.addr, align 8
  %mgmt36 = getelementptr inbounds %struct._obmalloc_state, ptr %55, i32 0, i32 1
  %unused_arena_objects = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt36, i32 0, i32 2
  %56 = load ptr, ptr %unused_arena_objects, align 8
  %57 = load ptr, ptr %ao, align 8
  %nextarena37 = getelementptr inbounds %struct.arena_object, ptr %57, i32 0, i32 5
  store ptr %56, ptr %nextarena37, align 8
  %58 = load ptr, ptr %ao, align 8
  %59 = load ptr, ptr %state.addr, align 8
  %mgmt38 = getelementptr inbounds %struct._obmalloc_state, ptr %59, i32 0, i32 1
  %unused_arena_objects39 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt38, i32 0, i32 2
  store ptr %58, ptr %unused_arena_objects39, align 8
  %60 = load ptr, ptr %state.addr, align 8
  %61 = load ptr, ptr %ao, align 8
  %address = getelementptr inbounds %struct.arena_object, ptr %61, i32 0, i32 0
  %62 = load i64, ptr %address, align 8
  %call = call i32 @arena_map_mark_used(ptr noundef %60, i64 noundef %62, i32 noundef 0)
  %63 = load ptr, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 3, i32 2), align 8
  %64 = load ptr, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 11, i32 3), align 8
  %65 = load ptr, ptr %ao, align 8
  %address40 = getelementptr inbounds %struct.arena_object, ptr %65, i32 0, i32 0
  %66 = load i64, ptr %address40, align 8
  %67 = inttoptr i64 %66 to ptr
  call void %63(ptr noundef %64, ptr noundef %67, i64 noundef 1048576)
  %68 = load ptr, ptr %ao, align 8
  %address41 = getelementptr inbounds %struct.arena_object, ptr %68, i32 0, i32 0
  store i64 0, ptr %address41, align 8
  %69 = load ptr, ptr %state.addr, align 8
  %mgmt42 = getelementptr inbounds %struct._obmalloc_state, ptr %69, i32 0, i32 1
  %narenas_currently_allocated = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt42, i32 0, i32 5
  %70 = load i64, ptr %narenas_currently_allocated, align 8
  %dec = add i64 %70, -1
  store i64 %dec, ptr %narenas_currently_allocated, align 8
  br label %return

if.end43:                                         ; preds = %land.lhs.true17, %if.end
  %71 = load i32, ptr %nf, align 4
  %cmp44 = icmp eq i32 %71, 1
  br i1 %cmp44, label %if.then45, label %if.end68

if.then45:                                        ; preds = %if.end43
  %72 = load ptr, ptr %state.addr, align 8
  %mgmt46 = getelementptr inbounds %struct._obmalloc_state, ptr %72, i32 0, i32 1
  %usable_arenas47 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt46, i32 0, i32 3
  %73 = load ptr, ptr %usable_arenas47, align 8
  %74 = load ptr, ptr %ao, align 8
  %nextarena48 = getelementptr inbounds %struct.arena_object, ptr %74, i32 0, i32 5
  store ptr %73, ptr %nextarena48, align 8
  %75 = load ptr, ptr %ao, align 8
  %prevarena49 = getelementptr inbounds %struct.arena_object, ptr %75, i32 0, i32 6
  store ptr null, ptr %prevarena49, align 8
  %76 = load ptr, ptr %state.addr, align 8
  %mgmt50 = getelementptr inbounds %struct._obmalloc_state, ptr %76, i32 0, i32 1
  %usable_arenas51 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt50, i32 0, i32 3
  %77 = load ptr, ptr %usable_arenas51, align 8
  %tobool = icmp ne ptr %77, null
  br i1 %tobool, label %if.then52, label %if.end56

if.then52:                                        ; preds = %if.then45
  %78 = load ptr, ptr %ao, align 8
  %79 = load ptr, ptr %state.addr, align 8
  %mgmt53 = getelementptr inbounds %struct._obmalloc_state, ptr %79, i32 0, i32 1
  %usable_arenas54 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt53, i32 0, i32 3
  %80 = load ptr, ptr %usable_arenas54, align 8
  %prevarena55 = getelementptr inbounds %struct.arena_object, ptr %80, i32 0, i32 6
  store ptr %78, ptr %prevarena55, align 8
  br label %if.end56

if.end56:                                         ; preds = %if.then52, %if.then45
  %81 = load ptr, ptr %ao, align 8
  %82 = load ptr, ptr %state.addr, align 8
  %mgmt57 = getelementptr inbounds %struct._obmalloc_state, ptr %82, i32 0, i32 1
  %usable_arenas58 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt57, i32 0, i32 3
  store ptr %81, ptr %usable_arenas58, align 8
  %83 = load ptr, ptr %state.addr, align 8
  %mgmt59 = getelementptr inbounds %struct._obmalloc_state, ptr %83, i32 0, i32 1
  %nfp2lasta60 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt59, i32 0, i32 4
  %arrayidx61 = getelementptr [65 x ptr], ptr %nfp2lasta60, i64 0, i64 1
  %84 = load ptr, ptr %arrayidx61, align 8
  %cmp62 = icmp eq ptr %84, null
  br i1 %cmp62, label %if.then63, label %if.end67

if.then63:                                        ; preds = %if.end56
  %85 = load ptr, ptr %ao, align 8
  %86 = load ptr, ptr %state.addr, align 8
  %mgmt64 = getelementptr inbounds %struct._obmalloc_state, ptr %86, i32 0, i32 1
  %nfp2lasta65 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt64, i32 0, i32 4
  %arrayidx66 = getelementptr [65 x ptr], ptr %nfp2lasta65, i64 0, i64 1
  store ptr %85, ptr %arrayidx66, align 8
  br label %if.end67

if.end67:                                         ; preds = %if.then63, %if.end56
  br label %return

if.end68:                                         ; preds = %if.end43
  %87 = load ptr, ptr %state.addr, align 8
  %mgmt69 = getelementptr inbounds %struct._obmalloc_state, ptr %87, i32 0, i32 1
  %nfp2lasta70 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt69, i32 0, i32 4
  %88 = load i32, ptr %nf, align 4
  %idxprom71 = zext i32 %88 to i64
  %arrayidx72 = getelementptr [65 x ptr], ptr %nfp2lasta70, i64 0, i64 %idxprom71
  %89 = load ptr, ptr %arrayidx72, align 8
  %cmp73 = icmp eq ptr %89, null
  br i1 %cmp73, label %if.then74, label %if.end79

if.then74:                                        ; preds = %if.end68
  %90 = load ptr, ptr %ao, align 8
  %91 = load ptr, ptr %state.addr, align 8
  %mgmt75 = getelementptr inbounds %struct._obmalloc_state, ptr %91, i32 0, i32 1
  %nfp2lasta76 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt75, i32 0, i32 4
  %92 = load i32, ptr %nf, align 4
  %idxprom77 = zext i32 %92 to i64
  %arrayidx78 = getelementptr [65 x ptr], ptr %nfp2lasta76, i64 0, i64 %idxprom77
  store ptr %90, ptr %arrayidx78, align 8
  br label %if.end79

if.end79:                                         ; preds = %if.then74, %if.end68
  %93 = load ptr, ptr %ao, align 8
  %94 = load ptr, ptr %lastnf, align 8
  %cmp80 = icmp eq ptr %93, %94
  br i1 %cmp80, label %if.then81, label %if.end82

if.then81:                                        ; preds = %if.end79
  br label %return

if.end82:                                         ; preds = %if.end79
  %95 = load ptr, ptr %ao, align 8
  %prevarena83 = getelementptr inbounds %struct.arena_object, ptr %95, i32 0, i32 6
  %96 = load ptr, ptr %prevarena83, align 8
  %cmp84 = icmp ne ptr %96, null
  br i1 %cmp84, label %if.then85, label %if.else89

if.then85:                                        ; preds = %if.end82
  %97 = load ptr, ptr %ao, align 8
  %nextarena86 = getelementptr inbounds %struct.arena_object, ptr %97, i32 0, i32 5
  %98 = load ptr, ptr %nextarena86, align 8
  %99 = load ptr, ptr %ao, align 8
  %prevarena87 = getelementptr inbounds %struct.arena_object, ptr %99, i32 0, i32 6
  %100 = load ptr, ptr %prevarena87, align 8
  %nextarena88 = getelementptr inbounds %struct.arena_object, ptr %100, i32 0, i32 5
  store ptr %98, ptr %nextarena88, align 8
  br label %if.end93

if.else89:                                        ; preds = %if.end82
  %101 = load ptr, ptr %ao, align 8
  %nextarena90 = getelementptr inbounds %struct.arena_object, ptr %101, i32 0, i32 5
  %102 = load ptr, ptr %nextarena90, align 8
  %103 = load ptr, ptr %state.addr, align 8
  %mgmt91 = getelementptr inbounds %struct._obmalloc_state, ptr %103, i32 0, i32 1
  %usable_arenas92 = getelementptr inbounds %struct._obmalloc_mgmt, ptr %mgmt91, i32 0, i32 3
  store ptr %102, ptr %usable_arenas92, align 8
  br label %if.end93

if.end93:                                         ; preds = %if.else89, %if.then85
  %104 = load ptr, ptr %ao, align 8
  %prevarena94 = getelementptr inbounds %struct.arena_object, ptr %104, i32 0, i32 6
  %105 = load ptr, ptr %prevarena94, align 8
  %106 = load ptr, ptr %ao, align 8
  %nextarena95 = getelementptr inbounds %struct.arena_object, ptr %106, i32 0, i32 5
  %107 = load ptr, ptr %nextarena95, align 8
  %prevarena96 = getelementptr inbounds %struct.arena_object, ptr %107, i32 0, i32 6
  store ptr %105, ptr %prevarena96, align 8
  %108 = load ptr, ptr %lastnf, align 8
  %109 = load ptr, ptr %ao, align 8
  %prevarena97 = getelementptr inbounds %struct.arena_object, ptr %109, i32 0, i32 6
  store ptr %108, ptr %prevarena97, align 8
  %110 = load ptr, ptr %lastnf, align 8
  %nextarena98 = getelementptr inbounds %struct.arena_object, ptr %110, i32 0, i32 5
  %111 = load ptr, ptr %nextarena98, align 8
  %112 = load ptr, ptr %ao, align 8
  %nextarena99 = getelementptr inbounds %struct.arena_object, ptr %112, i32 0, i32 5
  store ptr %111, ptr %nextarena99, align 8
  %113 = load ptr, ptr %ao, align 8
  %nextarena100 = getelementptr inbounds %struct.arena_object, ptr %113, i32 0, i32 5
  %114 = load ptr, ptr %nextarena100, align 8
  %cmp101 = icmp ne ptr %114, null
  br i1 %cmp101, label %if.then102, label %if.end105

if.then102:                                       ; preds = %if.end93
  %115 = load ptr, ptr %ao, align 8
  %116 = load ptr, ptr %ao, align 8
  %nextarena103 = getelementptr inbounds %struct.arena_object, ptr %116, i32 0, i32 5
  %117 = load ptr, ptr %nextarena103, align 8
  %prevarena104 = getelementptr inbounds %struct.arena_object, ptr %117, i32 0, i32 6
  store ptr %115, ptr %prevarena104, align 8
  br label %if.end105

if.end105:                                        ; preds = %if.then102, %if.end93
  %118 = load ptr, ptr %ao, align 8
  %119 = load ptr, ptr %lastnf, align 8
  %nextarena106 = getelementptr inbounds %struct.arena_object, ptr %119, i32 0, i32 5
  store ptr %118, ptr %nextarena106, align 8
  br label %return

return:                                           ; preds = %if.end105, %if.then81, %if.end67, %if.end35
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @arena_map_is_used(ptr noundef %state, ptr noundef %p) #0 {
entry:
  %retval.i = alloca ptr, align 8
  %state.addr.i = alloca ptr, align 8
  %p.addr.i = alloca ptr, align 8
  %create.addr.i = alloca i32, align 4
  %i1.i = alloca i32, align 4
  %n.i = alloca ptr, align 8
  %i2.i = alloca i32, align 4
  %n31.i = alloca ptr, align 8
  %retval = alloca i32, align 4
  %state.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %n = alloca ptr, align 8
  %i3 = alloca i32, align 4
  %hi = alloca i32, align 4
  %lo = alloca i32, align 4
  %tail = alloca i32, align 4
  store ptr %state, ptr %state.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %state.addr, align 8
  %1 = load ptr, ptr %p.addr, align 8
  store ptr %0, ptr %state.addr.i, align 8
  store ptr %1, ptr %p.addr.i, align 8
  store i32 0, ptr %create.addr.i, align 4
  %2 = load ptr, ptr %p.addr.i, align 8
  %3 = ptrtoint ptr %2 to i64
  %shr.i = lshr i64 %3, 49
  %conv.i = trunc i64 %shr.i to i32
  store i32 %conv.i, ptr %i1.i, align 4
  %4 = load ptr, ptr %state.addr.i, align 8
  %usage.i = getelementptr inbounds %struct._obmalloc_state, ptr %4, i32 0, i32 2
  %5 = load i32, ptr %i1.i, align 4
  %idxprom.i = sext i32 %5 to i64
  %arrayidx.i = getelementptr [32768 x ptr], ptr %usage.i, i64 0, i64 %idxprom.i
  %6 = load ptr, ptr %arrayidx.i, align 8
  %cmp.i = icmp eq ptr %6, null
  br i1 %cmp.i, label %if.then.i, label %if.end13.i

if.then.i:                                        ; preds = %entry
  %7 = load i32, ptr %create.addr.i, align 4
  %tobool.i = icmp ne i32 %7, 0
  br i1 %tobool.i, label %if.end.i, label %if.then2.i

if.then2.i:                                       ; preds = %if.then.i
  store ptr null, ptr %retval.i, align 8
  br label %arena_map_get.exit

if.end.i:                                         ; preds = %if.then.i
  %call.i = call ptr @PyMem_RawCalloc(i64 noundef 1, i64 noundef 262144)
  store ptr %call.i, ptr %n.i, align 8
  %8 = load ptr, ptr %n.i, align 8
  %cmp3.i = icmp eq ptr %8, null
  br i1 %cmp3.i, label %if.then5.i, label %if.end6.i

if.then5.i:                                       ; preds = %if.end.i
  store ptr null, ptr %retval.i, align 8
  br label %arena_map_get.exit

if.end6.i:                                        ; preds = %if.end.i
  %9 = load ptr, ptr %n.i, align 8
  %10 = load ptr, ptr %state.addr.i, align 8
  %usage7.i = getelementptr inbounds %struct._obmalloc_state, ptr %10, i32 0, i32 2
  %11 = load i32, ptr %i1.i, align 4
  %idxprom10.i = sext i32 %11 to i64
  %arrayidx11.i = getelementptr [32768 x ptr], ptr %usage7.i, i64 0, i64 %idxprom10.i
  store ptr %9, ptr %arrayidx11.i, align 8
  %12 = load ptr, ptr %state.addr.i, align 8
  %usage12.i = getelementptr inbounds %struct._obmalloc_state, ptr %12, i32 0, i32 2
  %arena_map_mid_count.i = getelementptr inbounds %struct._obmalloc_usage, ptr %usage12.i, i32 0, i32 1
  %13 = load i32, ptr %arena_map_mid_count.i, align 8
  %inc.i = add i32 %13, 1
  store i32 %inc.i, ptr %arena_map_mid_count.i, align 8
  br label %if.end13.i

if.end13.i:                                       ; preds = %if.end6.i, %entry
  %14 = load ptr, ptr %p.addr.i, align 8
  %15 = ptrtoint ptr %14 to i64
  %shr14.i = lshr i64 %15, 34
  %and15.i = and i64 %shr14.i, 32767
  %conv16.i = trunc i64 %and15.i to i32
  store i32 %conv16.i, ptr %i2.i, align 4
  %16 = load ptr, ptr %state.addr.i, align 8
  %usage17.i = getelementptr inbounds %struct._obmalloc_state, ptr %16, i32 0, i32 2
  %17 = load i32, ptr %i1.i, align 4
  %idxprom20.i = sext i32 %17 to i64
  %arrayidx21.i = getelementptr [32768 x ptr], ptr %usage17.i, i64 0, i64 %idxprom20.i
  %18 = load ptr, ptr %arrayidx21.i, align 8
  %19 = load i32, ptr %i2.i, align 4
  %idxprom23.i = sext i32 %19 to i64
  %arrayidx24.i = getelementptr [32768 x ptr], ptr %18, i64 0, i64 %idxprom23.i
  %20 = load ptr, ptr %arrayidx24.i, align 8
  %cmp25.i = icmp eq ptr %20, null
  br i1 %cmp25.i, label %if.then27.i, label %if.end47.i

if.then27.i:                                      ; preds = %if.end13.i
  %21 = load i32, ptr %create.addr.i, align 4
  %tobool28.i = icmp ne i32 %21, 0
  br i1 %tobool28.i, label %if.end30.i, label %if.then29.i

if.then29.i:                                      ; preds = %if.then27.i
  store ptr null, ptr %retval.i, align 8
  br label %arena_map_get.exit

if.end30.i:                                       ; preds = %if.then27.i
  %call32.i = call ptr @PyMem_RawCalloc(i64 noundef 1, i64 noundef 131072)
  store ptr %call32.i, ptr %n31.i, align 8
  %22 = load ptr, ptr %n31.i, align 8
  %cmp33.i = icmp eq ptr %22, null
  br i1 %cmp33.i, label %if.then35.i, label %if.end36.i

if.then35.i:                                      ; preds = %if.end30.i
  store ptr null, ptr %retval.i, align 8
  br label %arena_map_get.exit

if.end36.i:                                       ; preds = %if.end30.i
  %23 = load ptr, ptr %n31.i, align 8
  %24 = load ptr, ptr %state.addr.i, align 8
  %usage37.i = getelementptr inbounds %struct._obmalloc_state, ptr %24, i32 0, i32 2
  %25 = load i32, ptr %i1.i, align 4
  %idxprom40.i = sext i32 %25 to i64
  %arrayidx41.i = getelementptr [32768 x ptr], ptr %usage37.i, i64 0, i64 %idxprom40.i
  %26 = load ptr, ptr %arrayidx41.i, align 8
  %27 = load i32, ptr %i2.i, align 4
  %idxprom43.i = sext i32 %27 to i64
  %arrayidx44.i = getelementptr [32768 x ptr], ptr %26, i64 0, i64 %idxprom43.i
  store ptr %23, ptr %arrayidx44.i, align 8
  %28 = load ptr, ptr %state.addr.i, align 8
  %usage45.i = getelementptr inbounds %struct._obmalloc_state, ptr %28, i32 0, i32 2
  %arena_map_bot_count.i = getelementptr inbounds %struct._obmalloc_usage, ptr %usage45.i, i32 0, i32 2
  %29 = load i32, ptr %arena_map_bot_count.i, align 4
  %inc46.i = add i32 %29, 1
  store i32 %inc46.i, ptr %arena_map_bot_count.i, align 4
  br label %if.end47.i

if.end47.i:                                       ; preds = %if.end36.i, %if.end13.i
  %30 = load ptr, ptr %state.addr.i, align 8
  %usage48.i = getelementptr inbounds %struct._obmalloc_state, ptr %30, i32 0, i32 2
  %31 = load i32, ptr %i1.i, align 4
  %idxprom51.i = sext i32 %31 to i64
  %arrayidx52.i = getelementptr [32768 x ptr], ptr %usage48.i, i64 0, i64 %idxprom51.i
  %32 = load ptr, ptr %arrayidx52.i, align 8
  %33 = load i32, ptr %i2.i, align 4
  %idxprom54.i = sext i32 %33 to i64
  %arrayidx55.i = getelementptr [32768 x ptr], ptr %32, i64 0, i64 %idxprom54.i
  %34 = load ptr, ptr %arrayidx55.i, align 8
  store ptr %34, ptr %retval.i, align 8
  br label %arena_map_get.exit

arena_map_get.exit:                               ; preds = %if.end47.i, %if.then35.i, %if.then29.i, %if.then5.i, %if.then2.i
  %35 = load ptr, ptr %retval.i, align 8
  store ptr %35, ptr %n, align 8
  %36 = load ptr, ptr %n, align 8
  %cmp = icmp eq ptr %36, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %arena_map_get.exit
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %arena_map_get.exit
  %37 = load ptr, ptr %p.addr, align 8
  %38 = ptrtoint ptr %37 to i64
  %shr = lshr i64 %38, 20
  %and = and i64 %shr, 16383
  %conv = trunc i64 %and to i32
  store i32 %conv, ptr %i3, align 4
  %39 = load ptr, ptr %n, align 8
  %arenas = getelementptr inbounds %struct.arena_map_bot, ptr %39, i32 0, i32 0
  %40 = load i32, ptr %i3, align 4
  %idxprom = sext i32 %40 to i64
  %arrayidx = getelementptr [16384 x %struct.arena_coverage_t], ptr %arenas, i64 0, i64 %idxprom
  %tail_hi = getelementptr inbounds %struct.arena_coverage_t, ptr %arrayidx, i32 0, i32 0
  %41 = load i32, ptr %tail_hi, align 4
  store i32 %41, ptr %hi, align 4
  %42 = load ptr, ptr %n, align 8
  %arenas1 = getelementptr inbounds %struct.arena_map_bot, ptr %42, i32 0, i32 0
  %43 = load i32, ptr %i3, align 4
  %idxprom2 = sext i32 %43 to i64
  %arrayidx3 = getelementptr [16384 x %struct.arena_coverage_t], ptr %arenas1, i64 0, i64 %idxprom2
  %tail_lo = getelementptr inbounds %struct.arena_coverage_t, ptr %arrayidx3, i32 0, i32 1
  %44 = load i32, ptr %tail_lo, align 4
  store i32 %44, ptr %lo, align 4
  %45 = load ptr, ptr %p.addr, align 8
  %46 = ptrtoint ptr %45 to i64
  %and4 = and i64 %46, 1048575
  %conv5 = trunc i64 %and4 to i32
  store i32 %conv5, ptr %tail, align 4
  %47 = load i32, ptr %tail, align 4
  %48 = load i32, ptr %lo, align 4
  %cmp6 = icmp slt i32 %47, %48
  br i1 %cmp6, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.end
  %49 = load i32, ptr %tail, align 4
  %50 = load i32, ptr %hi, align 4
  %cmp8 = icmp sge i32 %49, %50
  br i1 %cmp8, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %lor.rhs
  %51 = load i32, ptr %hi, align 4
  %cmp10 = icmp ne i32 %51, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %lor.rhs
  %52 = phi i1 [ false, %lor.rhs ], [ %cmp10, %land.rhs ]
  br label %lor.end

lor.end:                                          ; preds = %land.end, %if.end
  %53 = phi i1 [ true, %if.end ], [ %52, %land.end ]
  %lor.ext = zext i1 %53 to i32
  store i32 %lor.ext, ptr %retval, align 4
  br label %return

return:                                           ; preds = %lor.end, %if.then
  %54 = load i32, ptr %retval, align 4
  ret i32 %54
}

declare i32 @PyGILState_Check() #8

; Function Attrs: nounwind uwtable
define internal void @_PyObject_DebugDumpAddress(ptr noundef %p) #0 {
entry:
  %p.addr = alloca ptr, align 8
  %q = alloca ptr, align 8
  %tail = alloca ptr, align 8
  %nbytes = alloca i64, align 8
  %i = alloca i32, align 4
  %ok = alloca i32, align 4
  %id = alloca i8, align 1
  %byte = alloca i8, align 1
  %byte61 = alloca i8, align 1
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  store ptr %0, ptr %q, align 8
  %1 = load ptr, ptr @stderr, align 8
  %2 = load ptr, ptr %p.addr, align 8
  %call = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %1, ptr noundef @.str.162, ptr noundef %2)
  %3 = load ptr, ptr %p.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr @stderr, align 8
  %call1 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %4, ptr noundef @.str.125)
  br label %return

if.end:                                           ; preds = %entry
  %5 = load ptr, ptr %q, align 8
  %arrayidx = getelementptr i8, ptr %5, i64 -8
  %6 = load i8, ptr %arrayidx, align 1
  store i8 %6, ptr %id, align 1
  %7 = load ptr, ptr @stderr, align 8
  %8 = load i8, ptr %id, align 1
  %conv = sext i8 %8 to i32
  %call2 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %7, ptr noundef @.str.163, i32 noundef %conv)
  %9 = load ptr, ptr %q, align 8
  %add.ptr = getelementptr i8, ptr %9, i64 -16
  %call3 = call i64 @read_size_t(ptr noundef %add.ptr)
  store i64 %call3, ptr %nbytes, align 8
  %10 = load ptr, ptr @stderr, align 8
  %11 = load i64, ptr %nbytes, align 8
  %call4 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %10, ptr noundef @.str.164, i64 noundef %11)
  %12 = load ptr, ptr @stderr, align 8
  %call5 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %12, ptr noundef @.str.165, i32 noundef 7, i32 noundef 7)
  store i32 1, ptr %ok, align 4
  store i32 1, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %13 = load i32, ptr %i, align 4
  %cmp6 = icmp sle i32 %13, 7
  br i1 %cmp6, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %14 = load ptr, ptr %q, align 8
  %15 = load i32, ptr %i, align 4
  %idx.ext = sext i32 %15 to i64
  %idx.neg = sub i64 0, %idx.ext
  %add.ptr8 = getelementptr i8, ptr %14, i64 %idx.neg
  %16 = load i8, ptr %add.ptr8, align 1
  %conv9 = zext i8 %16 to i32
  %cmp10 = icmp ne i32 %conv9, 253
  br i1 %cmp10, label %if.then12, label %if.end13

if.then12:                                        ; preds = %for.body
  store i32 0, ptr %ok, align 4
  br label %for.end

if.end13:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end13
  %17 = load i32, ptr %i, align 4
  %inc = add i32 %17, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !149

for.end:                                          ; preds = %if.then12, %for.cond
  %18 = load i32, ptr %ok, align 4
  %tobool = icmp ne i32 %18, 0
  br i1 %tobool, label %if.then14, label %if.else

if.then14:                                        ; preds = %for.end
  %19 = load ptr, ptr @stderr, align 8
  %call15 = call i32 @fputs(ptr noundef @.str.166, ptr noundef %19)
  br label %if.end36

if.else:                                          ; preds = %for.end
  %20 = load ptr, ptr @stderr, align 8
  %call16 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %20, ptr noundef @.str.167, i32 noundef 253)
  store i32 7, ptr %i, align 4
  br label %for.cond17

for.cond17:                                       ; preds = %for.inc33, %if.else
  %21 = load i32, ptr %i, align 4
  %cmp18 = icmp sge i32 %21, 1
  br i1 %cmp18, label %for.body20, label %for.end34

for.body20:                                       ; preds = %for.cond17
  %22 = load ptr, ptr %q, align 8
  %23 = load i32, ptr %i, align 4
  %idx.ext21 = sext i32 %23 to i64
  %idx.neg22 = sub i64 0, %idx.ext21
  %add.ptr23 = getelementptr i8, ptr %22, i64 %idx.neg22
  %24 = load i8, ptr %add.ptr23, align 1
  store i8 %24, ptr %byte, align 1
  %25 = load ptr, ptr @stderr, align 8
  %26 = load i32, ptr %i, align 4
  %27 = load i8, ptr %byte, align 1
  %conv24 = zext i8 %27 to i32
  %call25 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %25, ptr noundef @.str.168, i32 noundef %26, i32 noundef %conv24)
  %28 = load i8, ptr %byte, align 1
  %conv26 = zext i8 %28 to i32
  %cmp27 = icmp ne i32 %conv26, 253
  br i1 %cmp27, label %if.then29, label %if.end31

if.then29:                                        ; preds = %for.body20
  %29 = load ptr, ptr @stderr, align 8
  %call30 = call i32 @fputs(ptr noundef @.str.169, ptr noundef %29)
  br label %if.end31

if.end31:                                         ; preds = %if.then29, %for.body20
  %30 = load ptr, ptr @stderr, align 8
  %call32 = call i32 @fputc(i32 noundef 10, ptr noundef %30)
  br label %for.inc33

for.inc33:                                        ; preds = %if.end31
  %31 = load i32, ptr %i, align 4
  %dec = add i32 %31, -1
  store i32 %dec, ptr %i, align 4
  br label %for.cond17, !llvm.loop !150

for.end34:                                        ; preds = %for.cond17
  %32 = load ptr, ptr @stderr, align 8
  %call35 = call i32 @fputs(ptr noundef @.str.170, ptr noundef %32)
  br label %if.end36

if.end36:                                         ; preds = %for.end34, %if.then14
  %33 = load ptr, ptr %q, align 8
  %34 = load i64, ptr %nbytes, align 8
  %add.ptr37 = getelementptr i8, ptr %33, i64 %34
  store ptr %add.ptr37, ptr %tail, align 8
  %35 = load ptr, ptr @stderr, align 8
  %36 = load ptr, ptr %tail, align 8
  %call38 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %35, ptr noundef @.str.171, i32 noundef 8, ptr noundef %36)
  store i32 1, ptr %ok, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond39

for.cond39:                                       ; preds = %for.inc49, %if.end36
  %37 = load i32, ptr %i, align 4
  %cmp40 = icmp slt i32 %37, 8
  br i1 %cmp40, label %for.body42, label %for.end51

for.body42:                                       ; preds = %for.cond39
  %38 = load ptr, ptr %tail, align 8
  %39 = load i32, ptr %i, align 4
  %idxprom = sext i32 %39 to i64
  %arrayidx43 = getelementptr i8, ptr %38, i64 %idxprom
  %40 = load i8, ptr %arrayidx43, align 1
  %conv44 = zext i8 %40 to i32
  %cmp45 = icmp ne i32 %conv44, 253
  br i1 %cmp45, label %if.then47, label %if.end48

if.then47:                                        ; preds = %for.body42
  store i32 0, ptr %ok, align 4
  br label %for.end51

if.end48:                                         ; preds = %for.body42
  br label %for.inc49

for.inc49:                                        ; preds = %if.end48
  %41 = load i32, ptr %i, align 4
  %inc50 = add i32 %41, 1
  store i32 %inc50, ptr %i, align 4
  br label %for.cond39, !llvm.loop !151

for.end51:                                        ; preds = %if.then47, %for.cond39
  %42 = load i32, ptr %ok, align 4
  %tobool52 = icmp ne i32 %42, 0
  br i1 %tobool52, label %if.then53, label %if.else55

if.then53:                                        ; preds = %for.end51
  %43 = load ptr, ptr @stderr, align 8
  %call54 = call i32 @fputs(ptr noundef @.str.166, ptr noundef %43)
  br label %if.end76

if.else55:                                        ; preds = %for.end51
  %44 = load ptr, ptr @stderr, align 8
  %call56 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %44, ptr noundef @.str.167, i32 noundef 253)
  store i32 0, ptr %i, align 4
  br label %for.cond57

for.cond57:                                       ; preds = %for.inc73, %if.else55
  %45 = load i32, ptr %i, align 4
  %cmp58 = icmp slt i32 %45, 8
  br i1 %cmp58, label %for.body60, label %for.end75

for.body60:                                       ; preds = %for.cond57
  %46 = load ptr, ptr %tail, align 8
  %47 = load i32, ptr %i, align 4
  %idxprom62 = sext i32 %47 to i64
  %arrayidx63 = getelementptr i8, ptr %46, i64 %idxprom62
  %48 = load i8, ptr %arrayidx63, align 1
  store i8 %48, ptr %byte61, align 1
  %49 = load ptr, ptr @stderr, align 8
  %50 = load i32, ptr %i, align 4
  %51 = load i8, ptr %byte61, align 1
  %conv64 = zext i8 %51 to i32
  %call65 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %49, ptr noundef @.str.172, i32 noundef %50, i32 noundef %conv64)
  %52 = load i8, ptr %byte61, align 1
  %conv66 = zext i8 %52 to i32
  %cmp67 = icmp ne i32 %conv66, 253
  br i1 %cmp67, label %if.then69, label %if.end71

if.then69:                                        ; preds = %for.body60
  %53 = load ptr, ptr @stderr, align 8
  %call70 = call i32 @fputs(ptr noundef @.str.169, ptr noundef %53)
  br label %if.end71

if.end71:                                         ; preds = %if.then69, %for.body60
  %54 = load ptr, ptr @stderr, align 8
  %call72 = call i32 @fputc(i32 noundef 10, ptr noundef %54)
  br label %for.inc73

for.inc73:                                        ; preds = %if.end71
  %55 = load i32, ptr %i, align 4
  %inc74 = add i32 %55, 1
  store i32 %inc74, ptr %i, align 4
  br label %for.cond57, !llvm.loop !152

for.end75:                                        ; preds = %for.cond57
  br label %if.end76

if.end76:                                         ; preds = %for.end75, %if.then53
  %56 = load i64, ptr %nbytes, align 8
  %cmp77 = icmp ugt i64 %56, 0
  br i1 %cmp77, label %if.then79, label %if.end107

if.then79:                                        ; preds = %if.end76
  store i32 0, ptr %i, align 4
  %57 = load ptr, ptr @stderr, align 8
  %call80 = call i32 @fputs(ptr noundef @.str.173, ptr noundef %57)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then79
  %58 = load ptr, ptr %q, align 8
  %59 = load ptr, ptr %tail, align 8
  %cmp81 = icmp ult ptr %58, %59
  br i1 %cmp81, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %60 = load i32, ptr %i, align 4
  %cmp83 = icmp slt i32 %60, 8
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %61 = phi i1 [ false, %while.cond ], [ %cmp83, %land.rhs ]
  br i1 %61, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %62 = load ptr, ptr @stderr, align 8
  %63 = load ptr, ptr %q, align 8
  %64 = load i8, ptr %63, align 1
  %conv85 = zext i8 %64 to i32
  %call86 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %62, ptr noundef @.str.174, i32 noundef %conv85)
  %65 = load i32, ptr %i, align 4
  %inc87 = add i32 %65, 1
  store i32 %inc87, ptr %i, align 4
  %66 = load ptr, ptr %q, align 8
  %incdec.ptr = getelementptr i8, ptr %66, i32 1
  store ptr %incdec.ptr, ptr %q, align 8
  br label %while.cond, !llvm.loop !153

while.end:                                        ; preds = %land.end
  %67 = load ptr, ptr %q, align 8
  %68 = load ptr, ptr %tail, align 8
  %cmp88 = icmp ult ptr %67, %68
  br i1 %cmp88, label %if.then90, label %if.end105

if.then90:                                        ; preds = %while.end
  %69 = load ptr, ptr %tail, align 8
  %70 = load ptr, ptr %q, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %69 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %70 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp91 = icmp sgt i64 %sub.ptr.sub, 8
  br i1 %cmp91, label %if.then93, label %if.end96

if.then93:                                        ; preds = %if.then90
  %71 = load ptr, ptr @stderr, align 8
  %call94 = call i32 @fputs(ptr noundef @.str.175, ptr noundef %71)
  %72 = load ptr, ptr %tail, align 8
  %add.ptr95 = getelementptr i8, ptr %72, i64 -8
  store ptr %add.ptr95, ptr %q, align 8
  br label %if.end96

if.end96:                                         ; preds = %if.then93, %if.then90
  br label %while.cond97

while.cond97:                                     ; preds = %while.body100, %if.end96
  %73 = load ptr, ptr %q, align 8
  %74 = load ptr, ptr %tail, align 8
  %cmp98 = icmp ult ptr %73, %74
  br i1 %cmp98, label %while.body100, label %while.end104

while.body100:                                    ; preds = %while.cond97
  %75 = load ptr, ptr @stderr, align 8
  %76 = load ptr, ptr %q, align 8
  %77 = load i8, ptr %76, align 1
  %conv101 = zext i8 %77 to i32
  %call102 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %75, ptr noundef @.str.174, i32 noundef %conv101)
  %78 = load ptr, ptr %q, align 8
  %incdec.ptr103 = getelementptr i8, ptr %78, i32 1
  store ptr %incdec.ptr103, ptr %q, align 8
  br label %while.cond97, !llvm.loop !154

while.end104:                                     ; preds = %while.cond97
  br label %if.end105

if.end105:                                        ; preds = %while.end104, %while.end
  %79 = load ptr, ptr @stderr, align 8
  %call106 = call i32 @fputc(i32 noundef 10, ptr noundef %79)
  br label %if.end107

if.end107:                                        ; preds = %if.end105, %if.end76
  %80 = load ptr, ptr @stderr, align 8
  %call108 = call i32 @fputc(i32 noundef 10, ptr noundef %80)
  %81 = load ptr, ptr @stderr, align 8
  %call109 = call i32 @fflush(ptr noundef %81)
  %82 = load ptr, ptr @stderr, align 8
  %call110 = call i32 @fileno(ptr noundef %82) #15
  %83 = load ptr, ptr %p.addr, align 8
  call void @_PyMem_DumpTraceback(i32 noundef %call110, ptr noundef %83)
  br label %return

return:                                           ; preds = %if.end107, %if.then
  ret void
}

; Function Attrs: noreturn
declare void @_Py_FatalErrorFormat(ptr noundef, ptr noundef, ...) #12

declare i32 @fprintf(ptr noundef, ptr noundef, ...) #8

declare i32 @fputc(i32 noundef, ptr noundef) #8

declare i32 @fflush(ptr noundef) #8

declare void @_PyMem_DumpTraceback(i32 noundef, ptr noundef) #8

; Function Attrs: nounwind
declare i32 @fileno(ptr noundef) #2

; Function Attrs: nounwind uwtable
define internal zeroext i1 @_collect_alloc_stats(ptr noundef %heap, ptr noundef %area, ptr noundef %block, i64 noundef %block_size, ptr noundef %arg) #0 {
entry:
  %heap.addr = alloca ptr, align 8
  %area.addr = alloca ptr, align 8
  %block.addr = alloca ptr, align 8
  %block_size.addr = alloca i64, align 8
  %arg.addr = alloca ptr, align 8
  %stats = alloca ptr, align 8
  store ptr %heap, ptr %heap.addr, align 8
  store ptr %area, ptr %area.addr, align 8
  store ptr %block, ptr %block.addr, align 8
  store i64 %block_size, ptr %block_size.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  store ptr %0, ptr %stats, align 8
  %1 = load ptr, ptr %area.addr, align 8
  %used = getelementptr inbounds %struct.mi_heap_area_s, ptr %1, i32 0, i32 3
  %2 = load i64, ptr %used, align 8
  %3 = load ptr, ptr %stats, align 8
  %allocated_blocks = getelementptr inbounds %struct._alloc_stats, ptr %3, i32 0, i32 0
  %4 = load i64, ptr %allocated_blocks, align 8
  %add = add i64 %4, %2
  store i64 %add, ptr %allocated_blocks, align 8
  %5 = load ptr, ptr %area.addr, align 8
  %used1 = getelementptr inbounds %struct.mi_heap_area_s, ptr %5, i32 0, i32 3
  %6 = load i64, ptr %used1, align 8
  %7 = load ptr, ptr %area.addr, align 8
  %block_size2 = getelementptr inbounds %struct.mi_heap_area_s, ptr %7, i32 0, i32 4
  %8 = load i64, ptr %block_size2, align 8
  %mul = mul i64 %6, %8
  %9 = load ptr, ptr %stats, align 8
  %allocated_bytes = getelementptr inbounds %struct._alloc_stats, ptr %9, i32 0, i32 1
  %10 = load i64, ptr %allocated_bytes, align 8
  %add3 = add i64 %10, %mul
  store i64 %add3, ptr %allocated_bytes, align 8
  %11 = load ptr, ptr %area.addr, align 8
  %used4 = getelementptr inbounds %struct.mi_heap_area_s, ptr %11, i32 0, i32 3
  %12 = load i64, ptr %used4, align 8
  %13 = load ptr, ptr %area.addr, align 8
  %full_block_size = getelementptr inbounds %struct.mi_heap_area_s, ptr %13, i32 0, i32 5
  %14 = load i64, ptr %full_block_size, align 8
  %mul5 = mul i64 %12, %14
  %15 = load ptr, ptr %stats, align 8
  %allocated_with_overhead = getelementptr inbounds %struct._alloc_stats, ptr %15, i32 0, i32 2
  %16 = load i64, ptr %allocated_with_overhead, align 8
  %add6 = add i64 %16, %mul5
  store i64 %add6, ptr %allocated_with_overhead, align 8
  %17 = load ptr, ptr %area.addr, align 8
  %reserved = getelementptr inbounds %struct.mi_heap_area_s, ptr %17, i32 0, i32 1
  %18 = load i64, ptr %reserved, align 8
  %19 = load ptr, ptr %stats, align 8
  %bytes_reserved = getelementptr inbounds %struct._alloc_stats, ptr %19, i32 0, i32 3
  %20 = load i64, ptr %bytes_reserved, align 8
  %add7 = add i64 %20, %18
  store i64 %add7, ptr %bytes_reserved, align 8
  %21 = load ptr, ptr %area.addr, align 8
  %committed = getelementptr inbounds %struct.mi_heap_area_s, ptr %21, i32 0, i32 2
  %22 = load i64, ptr %committed, align 8
  %23 = load ptr, ptr %stats, align 8
  %bytes_committed = getelementptr inbounds %struct._alloc_stats, ptr %23, i32 0, i32 4
  %24 = load i64, ptr %bytes_committed, align 8
  %add8 = add i64 %24, %22
  store i64 %add8, ptr %bytes_committed, align 8
  ret i1 true
}

attributes #0 = { nounwind uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { nounwind willreturn memory(read) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #2 = { nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { nounwind willreturn memory(none) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #4 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #5 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #6 = { nocallback nofree nosync nounwind willreturn }
attributes #7 = { nocallback nofree nounwind willreturn memory(argmem: write) }
attributes #8 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #9 = { nounwind allocsize(0) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #10 = { nounwind allocsize(0,1) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #11 = { nounwind allocsize(1) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #12 = { noreturn "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #13 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write) }
attributes #14 = { noreturn nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #15 = { nounwind }
attributes #16 = { nounwind willreturn memory(read) }
attributes #17 = { noreturn nounwind }
attributes #18 = { nounwind willreturn memory(none) }
attributes #19 = { nounwind allocsize(0) }
attributes #20 = { nounwind allocsize(0,1) }
attributes #21 = { nounwind allocsize(1) }
attributes #22 = { noreturn }
attributes #23 = { nounwind memory(read) }

!llvm.module.flags = !{!0, !1, !2, !3, !4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = distinct !{!5, !6}
!6 = !{!"llvm.loop.mustprogress"}
!7 = distinct !{!7, !6}
!8 = distinct !{!8, !6}
!9 = distinct !{!9, !6}
!10 = distinct !{!10, !6}
!11 = distinct !{!11, !6}
!12 = distinct !{!12, !6}
!13 = distinct !{!13, !6}
!14 = distinct !{!14, !6}
!15 = distinct !{!15, !6}
!16 = distinct !{!16, !6}
!17 = distinct !{!17, !6}
!18 = distinct !{!18, !6}
!19 = distinct !{!19, !6}
!20 = distinct !{!20, !6}
!21 = distinct !{!21, !6}
!22 = distinct !{!22, !6}
!23 = distinct !{!23, !6}
!24 = distinct !{!24, !6}
!25 = distinct !{!25, !6}
!26 = distinct !{!26, !6}
!27 = distinct !{!27, !6}
!28 = distinct !{!28, !6}
!29 = distinct !{!29, !6}
!30 = distinct !{!30, !6}
!31 = distinct !{!31, !6}
!32 = distinct !{!32, !6}
!33 = distinct !{!33, !6}
!34 = distinct !{!34, !6}
!35 = distinct !{!35, !6}
!36 = distinct !{!36, !6}
!37 = distinct !{!37, !6}
!38 = distinct !{!38, !6}
!39 = distinct !{!39, !6}
!40 = distinct !{!40, !6}
!41 = distinct !{!41, !6}
!42 = distinct !{!42, !6}
!43 = distinct !{!43, !6}
!44 = distinct !{!44, !6}
!45 = distinct !{!45, !6}
!46 = distinct !{!46, !6}
!47 = distinct !{!47, !6}
!48 = distinct !{!48, !6}
!49 = distinct !{!49, !6}
!50 = distinct !{!50, !6}
!51 = distinct !{!51, !6}
!52 = distinct !{!52, !6}
!53 = distinct !{!53, !6}
!54 = distinct !{!54, !6}
!55 = distinct !{!55, !6}
!56 = distinct !{!56, !6}
!57 = distinct !{!57, !6}
!58 = distinct !{!58, !6}
!59 = distinct !{!59, !6}
!60 = distinct !{!60, !6}
!61 = distinct !{!61, !6}
!62 = distinct !{!62, !6}
!63 = distinct !{!63, !6}
!64 = distinct !{!64, !6}
!65 = distinct !{!65, !6}
!66 = distinct !{!66, !6}
!67 = distinct !{!67, !6}
!68 = distinct !{!68, !6}
!69 = distinct !{!69, !6}
!70 = distinct !{!70, !6}
!71 = distinct !{!71, !6}
!72 = distinct !{!72, !6}
!73 = distinct !{!73, !6}
!74 = distinct !{!74, !6}
!75 = distinct !{!75, !6}
!76 = distinct !{!76, !6}
!77 = distinct !{!77, !6}
!78 = distinct !{!78, !6}
!79 = distinct !{!79, !6}
!80 = distinct !{!80, !6}
!81 = distinct !{!81, !6}
!82 = distinct !{!82, !6}
!83 = distinct !{!83, !6}
!84 = distinct !{!84, !6}
!85 = distinct !{!85, !6}
!86 = distinct !{!86, !6}
!87 = distinct !{!87, !6}
!88 = distinct !{!88, !6}
!89 = distinct !{!89, !6}
!90 = distinct !{!90, !6}
!91 = distinct !{!91, !6}
!92 = distinct !{!92, !6}
!93 = distinct !{!93, !6}
!94 = distinct !{!94, !6}
!95 = distinct !{!95, !6}
!96 = distinct !{!96, !6}
!97 = distinct !{!97, !6}
!98 = distinct !{!98, !6}
!99 = distinct !{!99, !6}
!100 = distinct !{!100, !6}
!101 = distinct !{!101, !6}
!102 = distinct !{!102, !6}
!103 = distinct !{!103, !6}
!104 = distinct !{!104, !6}
!105 = distinct !{!105, !6}
!106 = distinct !{!106, !6}
!107 = distinct !{!107, !6}
!108 = !{i64 3786279}
!109 = distinct !{!109, !6}
!110 = distinct !{!110, !6}
!111 = distinct !{!111, !6}
!112 = distinct !{!112, !6}
!113 = distinct !{!113, !6}
!114 = distinct !{!114, !6}
!115 = distinct !{!115, !6}
!116 = distinct !{!116, !6}
!117 = distinct !{!117, !6}
!118 = distinct !{!118, !6}
!119 = distinct !{!119, !6}
!120 = distinct !{!120, !6}
!121 = distinct !{!121, !6}
!122 = distinct !{!122, !6}
!123 = distinct !{!123, !6}
!124 = distinct !{!124, !6}
!125 = distinct !{!125, !6}
!126 = distinct !{!126, !6}
!127 = distinct !{!127, !6}
!128 = distinct !{!128, !6}
!129 = distinct !{!129, !6}
!130 = distinct !{!130, !6}
!131 = distinct !{!131, !6}
!132 = distinct !{!132, !6}
!133 = distinct !{!133, !6}
!134 = distinct !{!134, !6}
!135 = distinct !{!135, !6}
!136 = distinct !{!136, !6}
!137 = distinct !{!137, !6}
!138 = distinct !{!138, !6}
!139 = distinct !{!139, !6}
!140 = distinct !{!140, !6}
!141 = distinct !{!141, !6}
!142 = distinct !{!142, !6}
!143 = distinct !{!143, !6}
!144 = distinct !{!144, !6}
!145 = distinct !{!145, !6}
!146 = distinct !{!146, !6}
!147 = distinct !{!147, !6}
!148 = distinct !{!148, !6}
!149 = distinct !{!149, !6}
!150 = distinct !{!150, !6}
!151 = distinct !{!151, !6}
!152 = distinct !{!152, !6}
!153 = distinct !{!153, !6}
!154 = distinct !{!154, !6}
