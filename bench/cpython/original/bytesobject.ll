target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.pyruntimestate = type { %struct._Py_DebugOffsets, i32, i32, i32, i32, i32, ptr, i64, %struct.pyinterpreters, i64, %struct._xi_runtime_state, %struct._pymem_allocators, %struct._obmalloc_global_state, %struct.pyhash_runtime_state, %struct._pythread_runtime_state, %struct._signals_runtime_state, %struct._Py_tss_t, %struct._Py_tss_t, %struct.PyWideStringList, %struct._parser_runtime_state, %struct._atexit_runtime_state, %struct._import_runtime_state, %struct._ceval_runtime_state, %struct._gilstate_runtime_state, %struct._getargs_runtime_state, %struct._fileutils_state, %struct._faulthandler_runtime_state, %struct._tracemalloc_runtime_state, %struct.PyPreConfig, ptr, ptr, %struct.anon.37, %struct._py_object_runtime_state, %struct._Py_float_runtime_state, %struct._Py_unicode_runtime_state, %struct._types_runtime_state, %struct._Py_cached_objects, %struct._Py_static_objects, %struct._is }
%struct._Py_DebugOffsets = type { [8 x i8], i64, %struct._runtime_state, %struct._interpreter_state, %struct._thread_state, %struct._interpreter_frame, %struct._cframe, %struct._code_object, %struct._pyobject, %struct._type_object, %struct._tuple_object }
%struct._runtime_state = type { i64, i64 }
%struct._interpreter_state = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct._thread_state = type { i64, i64, i64, i64, i64, i64 }
%struct._interpreter_frame = type { i64, i64, i64, i64, i64 }
%struct._cframe = type { i64, i64 }
%struct._code_object = type { i64, i64, i64, i64, i64, i64, i64, i64 }
%struct._pyobject = type { i64 }
%struct._type_object = type { i64 }
%struct._tuple_object = type { i64 }
%struct.pyinterpreters = type { %struct._PyMutex, ptr, ptr, i64 }
%struct._PyMutex = type { i8 }
%struct._xi_runtime_state = type { %struct._xidregistry }
%struct._xidregistry = type { i32, i32, %struct._PyMutex, ptr }
%struct._pymem_allocators = type { %struct._PyMutex, %struct.anon, %struct.anon.0, %struct.PyObjectArenaAllocator }
%struct.anon = type { %struct.PyMemAllocatorEx, %struct.PyMemAllocatorEx, %struct.PyMemAllocatorEx }
%struct.PyMemAllocatorEx = type { ptr, ptr, ptr, ptr, ptr }
%struct.anon.0 = type { %struct.debug_alloc_api_t, %struct.debug_alloc_api_t, %struct.debug_alloc_api_t }
%struct.debug_alloc_api_t = type { i8, %struct.PyMemAllocatorEx }
%struct.PyObjectArenaAllocator = type { ptr, ptr, ptr }
%struct._obmalloc_global_state = type { i32, i64 }
%struct.pyhash_runtime_state = type { %struct.anon.1 }
%struct.anon.1 = type { i32, i64, i64 }
%struct._pythread_runtime_state = type { i32, %struct.anon.2 }
%struct.anon.2 = type { ptr, %union.pthread_condattr_t }
%union.pthread_condattr_t = type { i32 }
%struct._signals_runtime_state = type { [65 x %struct.anon.3], %struct.anon.4, i32, ptr, ptr, i32 }
%struct.anon.3 = type { i32, ptr }
%struct.anon.4 = type { i32, i32 }
%struct._Py_tss_t = type { i32, i32 }
%struct.PyWideStringList = type { i64, ptr }
%struct._parser_runtime_state = type { i32, %struct._expr }
%struct._expr = type { i32, %union.anon, i32, i32, i32, i32 }
%union.anon = type { %struct.anon.7 }
%struct.anon.7 = type { ptr, i32, ptr }
%struct._atexit_runtime_state = type { %struct._PyMutex, [32 x ptr], i32 }
%struct._import_runtime_state = type { ptr, i64, %struct.anon.32, ptr }
%struct.anon.32 = type { %struct._PyMutex, ptr }
%struct._ceval_runtime_state = type { %struct.anon.33, %struct._pending_calls }
%struct.anon.33 = type { i32, i64, ptr, %struct.trampoline_api_st, ptr, i64 }
%struct.trampoline_api_st = type { ptr, ptr, ptr, ptr }
%struct._pending_calls = type { i32, %struct._PyMutex, i32, [32 x %struct._pending_call], i32, i32 }
%struct._pending_call = type { ptr, ptr, i32 }
%struct._gilstate_runtime_state = type { i32, ptr }
%struct._getargs_runtime_state = type { ptr }
%struct._fileutils_state = type { i32 }
%struct._faulthandler_runtime_state = type { %struct.anon.34, %struct.anon.35, ptr, %struct.stack_t, %struct.stack_t }
%struct.anon.34 = type { i32, ptr, i32, i32, ptr }
%struct.anon.35 = type { ptr, i32, i64, i32, ptr, i32, ptr, i64, ptr, ptr }
%struct.stack_t = type { ptr, i32, i64 }
%struct._tracemalloc_runtime_state = type { %struct._PyTraceMalloc_Config, %struct.anon.36, ptr, i64, i64, ptr, ptr, ptr, ptr, ptr, %struct.tracemalloc_traceback, %struct._Py_tss_t }
%struct._PyTraceMalloc_Config = type { i32, i32, i32 }
%struct.anon.36 = type { %struct.PyMemAllocatorEx, %struct.PyMemAllocatorEx, %struct.PyMemAllocatorEx }
%struct.tracemalloc_traceback = type { i64, i16, i16, [1 x %struct.tracemalloc_frame] }
%struct.tracemalloc_frame = type <{ ptr, i32 }>
%struct.PyPreConfig = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.anon.37 = type { %struct._PyMutex, ptr }
%struct._py_object_runtime_state = type { i32 }
%struct._Py_float_runtime_state = type { i32, i32 }
%struct._Py_unicode_runtime_state = type { %struct._Py_unicode_runtime_ids }
%struct._Py_unicode_runtime_ids = type { %struct._PyMutex, i64 }
%struct._types_runtime_state = type { i32 }
%struct._Py_cached_objects = type { ptr }
%struct._Py_static_objects = type { %struct.anon.38 }
%struct.anon.38 = type { [262 x %struct._longobject], %struct.PyBytesObject, [256 x %struct.anon.40], %struct._Py_global_strings, %struct.PyGC_Head, %struct.PyTupleObject, %struct.PyGC_Head, %struct.PyHamtNode_Bitmap, %struct._PyContextTokenMissing }
%struct._longobject = type { %struct._object, %struct._PyLongValue }
%struct._object = type { %union.anon.39, ptr }
%union.anon.39 = type { i64 }
%struct._PyLongValue = type { i64, [1 x i32] }
%struct.PyBytesObject = type { %struct.PyVarObject, i64, [1 x i8] }
%struct.PyVarObject = type { %struct._object, i64 }
%struct.anon.40 = type { %struct.PyBytesObject, i8 }
%struct._Py_global_strings = type { %struct.anon.41, %struct.anon.69, [128 x %struct.anon.762], [128 x %struct.anon.763] }
%struct.anon.41 = type { %struct.anon.42, %struct.anon.44, %struct.anon.45, %struct.anon.46, %struct.anon.47, %struct.anon.48, %struct.anon.49, %struct.anon.50, %struct.anon.51, %struct.anon.52, %struct.anon.53, %struct.anon.54, %struct.anon.55, %struct.anon.56, %struct.anon.57, %struct.anon.58, %struct.anon.59, %struct.anon.60, %struct.anon.61, %struct.anon.62, %struct.anon.63, %struct.anon.64, %struct.anon.65, %struct.anon.66, %struct.anon.67, %struct.anon.68 }
%struct.anon.42 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.PyASCIIObject = type { %struct._object, i64, i64, %struct.anon.43 }
%struct.anon.43 = type { i32 }
%struct.anon.44 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.45 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.46 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.47 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.48 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.49 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.50 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.51 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.52 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.53 = type { %struct.PyASCIIObject, [3 x i8] }
%struct.anon.54 = type { %struct.PyASCIIObject, [3 x i8] }
%struct.anon.55 = type { %struct.PyASCIIObject, [3 x i8] }
%struct.anon.56 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.57 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.58 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.59 = type { %struct.PyASCIIObject, [1 x i8] }
%struct.anon.60 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.61 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.62 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.63 = type { %struct.PyASCIIObject, [24 x i8] }
%struct.anon.64 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.65 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.66 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.67 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.68 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.69 = type { %struct.anon.70, %struct.anon.71, %struct.anon.72, %struct.anon.73, %struct.anon.74, %struct.anon.75, %struct.anon.76, %struct.anon.77, %struct.anon.78, %struct.anon.79, %struct.anon.80, %struct.anon.81, %struct.anon.82, %struct.anon.83, %struct.anon.84, %struct.anon.85, %struct.anon.86, %struct.anon.87, %struct.anon.88, %struct.anon.89, %struct.anon.90, %struct.anon.91, %struct.anon.92, %struct.anon.93, %struct.anon.94, %struct.anon.95, %struct.anon.96, %struct.anon.97, %struct.anon.98, %struct.anon.99, %struct.anon.100, %struct.anon.101, %struct.anon.102, %struct.anon.103, %struct.anon.104, %struct.anon.105, %struct.anon.106, %struct.anon.107, %struct.anon.108, %struct.anon.109, %struct.anon.110, %struct.anon.111, %struct.anon.112, %struct.anon.113, %struct.anon.114, %struct.anon.115, %struct.anon.116, %struct.anon.117, %struct.anon.118, %struct.anon.119, %struct.anon.120, %struct.anon.121, %struct.anon.122, %struct.anon.123, %struct.anon.124, %struct.anon.125, %struct.anon.126, %struct.anon.127, %struct.anon.128, %struct.anon.129, %struct.anon.130, %struct.anon.131, %struct.anon.132, %struct.anon.133, %struct.anon.134, %struct.anon.135, %struct.anon.136, %struct.anon.137, %struct.anon.138, %struct.anon.139, %struct.anon.140, %struct.anon.141, %struct.anon.142, %struct.anon.143, %struct.anon.144, %struct.anon.145, %struct.anon.146, %struct.anon.147, %struct.anon.148, %struct.anon.149, %struct.anon.150, %struct.anon.151, %struct.anon.152, %struct.anon.153, %struct.anon.154, %struct.anon.155, %struct.anon.156, %struct.anon.157, %struct.anon.158, %struct.anon.159, %struct.anon.160, %struct.anon.161, %struct.anon.162, %struct.anon.163, %struct.anon.164, %struct.anon.165, %struct.anon.166, %struct.anon.167, %struct.anon.168, %struct.anon.169, %struct.anon.170, %struct.anon.171, %struct.anon.172, %struct.anon.173, %struct.anon.174, %struct.anon.175, %struct.anon.176, %struct.anon.177, %struct.anon.178, %struct.anon.179, %struct.anon.180, %struct.anon.181, %struct.anon.182, %struct.anon.183, %struct.anon.184, %struct.anon.185, %struct.anon.186, %struct.anon.187, %struct.anon.188, %struct.anon.189, %struct.anon.190, %struct.anon.191, %struct.anon.192, %struct.anon.193, %struct.anon.194, %struct.anon.195, %struct.anon.196, %struct.anon.197, %struct.anon.198, %struct.anon.199, %struct.anon.200, %struct.anon.201, %struct.anon.202, %struct.anon.203, %struct.anon.204, %struct.anon.205, %struct.anon.206, %struct.anon.207, %struct.anon.208, %struct.anon.209, %struct.anon.210, %struct.anon.211, %struct.anon.212, %struct.anon.213, %struct.anon.214, %struct.anon.215, %struct.anon.216, %struct.anon.217, %struct.anon.218, %struct.anon.219, %struct.anon.220, %struct.anon.221, %struct.anon.222, %struct.anon.223, %struct.anon.224, %struct.anon.225, %struct.anon.226, %struct.anon.227, %struct.anon.228, %struct.anon.229, %struct.anon.230, %struct.anon.231, %struct.anon.232, %struct.anon.233, %struct.anon.234, %struct.anon.235, %struct.anon.236, %struct.anon.237, %struct.anon.238, %struct.anon.239, %struct.anon.240, %struct.anon.241, %struct.anon.242, %struct.anon.243, %struct.anon.244, %struct.anon.245, %struct.anon.246, %struct.anon.247, %struct.anon.248, %struct.anon.249, %struct.anon.250, %struct.anon.251, %struct.anon.252, %struct.anon.253, %struct.anon.254, %struct.anon.255, %struct.anon.256, %struct.anon.257, %struct.anon.258, %struct.anon.259, %struct.anon.260, %struct.anon.261, %struct.anon.262, %struct.anon.263, %struct.anon.264, %struct.anon.265, %struct.anon.266, %struct.anon.267, %struct.anon.268, %struct.anon.269, %struct.anon.270, %struct.anon.271, %struct.anon.272, %struct.anon.273, %struct.anon.274, %struct.anon.275, %struct.anon.276, %struct.anon.277, %struct.anon.278, %struct.anon.279, %struct.anon.280, %struct.anon.281, %struct.anon.282, %struct.anon.283, %struct.anon.284, %struct.anon.285, %struct.anon.286, %struct.anon.287, %struct.anon.288, %struct.anon.289, %struct.anon.290, %struct.anon.291, %struct.anon.292, %struct.anon.293, %struct.anon.294, %struct.anon.295, %struct.anon.296, %struct.anon.297, %struct.anon.298, %struct.anon.299, %struct.anon.300, %struct.anon.301, %struct.anon.302, %struct.anon.303, %struct.anon.304, %struct.anon.305, %struct.anon.306, %struct.anon.307, %struct.anon.308, %struct.anon.309, %struct.anon.310, %struct.anon.311, %struct.anon.312, %struct.anon.313, %struct.anon.314, %struct.anon.315, %struct.anon.316, %struct.anon.317, %struct.anon.318, %struct.anon.319, %struct.anon.320, %struct.anon.321, %struct.anon.322, %struct.anon.323, %struct.anon.324, %struct.anon.325, %struct.anon.326, %struct.anon.327, %struct.anon.328, %struct.anon.329, %struct.anon.330, %struct.anon.331, %struct.anon.332, %struct.anon.333, %struct.anon.334, %struct.anon.335, %struct.anon.336, %struct.anon.337, %struct.anon.338, %struct.anon.339, %struct.anon.340, %struct.anon.341, %struct.anon.342, %struct.anon.343, %struct.anon.344, %struct.anon.345, %struct.anon.346, %struct.anon.347, %struct.anon.348, %struct.anon.349, %struct.anon.350, %struct.anon.351, %struct.anon.352, %struct.anon.353, %struct.anon.354, %struct.anon.355, %struct.anon.356, %struct.anon.357, %struct.anon.358, %struct.anon.359, %struct.anon.360, %struct.anon.361, %struct.anon.362, %struct.anon.363, %struct.anon.364, %struct.anon.365, %struct.anon.366, %struct.anon.367, %struct.anon.368, %struct.anon.369, %struct.anon.370, %struct.anon.371, %struct.anon.372, %struct.anon.373, %struct.anon.374, %struct.anon.375, %struct.anon.376, %struct.anon.377, %struct.anon.378, %struct.anon.379, %struct.anon.380, %struct.anon.381, %struct.anon.382, %struct.anon.383, %struct.anon.384, %struct.anon.385, %struct.anon.386, %struct.anon.387, %struct.anon.388, %struct.anon.389, %struct.anon.390, %struct.anon.391, %struct.anon.392, %struct.anon.393, %struct.anon.394, %struct.anon.395, %struct.anon.396, %struct.anon.397, %struct.anon.398, %struct.anon.399, %struct.anon.400, %struct.anon.401, %struct.anon.402, %struct.anon.403, %struct.anon.404, %struct.anon.405, %struct.anon.406, %struct.anon.407, %struct.anon.408, %struct.anon.409, %struct.anon.410, %struct.anon.411, %struct.anon.412, %struct.anon.413, %struct.anon.414, %struct.anon.415, %struct.anon.416, %struct.anon.417, %struct.anon.418, %struct.anon.419, %struct.anon.420, %struct.anon.421, %struct.anon.422, %struct.anon.423, %struct.anon.424, %struct.anon.425, %struct.anon.426, %struct.anon.427, %struct.anon.428, %struct.anon.429, %struct.anon.430, %struct.anon.431, %struct.anon.432, %struct.anon.433, %struct.anon.434, %struct.anon.435, %struct.anon.436, %struct.anon.437, %struct.anon.438, %struct.anon.439, %struct.anon.440, %struct.anon.441, %struct.anon.442, %struct.anon.443, %struct.anon.444, %struct.anon.445, %struct.anon.446, %struct.anon.447, %struct.anon.448, %struct.anon.449, %struct.anon.450, %struct.anon.451, %struct.anon.452, %struct.anon.453, %struct.anon.454, %struct.anon.455, %struct.anon.456, %struct.anon.457, %struct.anon.458, %struct.anon.459, %struct.anon.460, %struct.anon.461, %struct.anon.462, %struct.anon.463, %struct.anon.464, %struct.anon.465, %struct.anon.466, %struct.anon.467, %struct.anon.468, %struct.anon.469, %struct.anon.470, %struct.anon.471, %struct.anon.472, %struct.anon.473, %struct.anon.474, %struct.anon.475, %struct.anon.476, %struct.anon.477, %struct.anon.478, %struct.anon.479, %struct.anon.480, %struct.anon.481, %struct.anon.482, %struct.anon.483, %struct.anon.484, %struct.anon.485, %struct.anon.486, %struct.anon.487, %struct.anon.488, %struct.anon.489, %struct.anon.490, %struct.anon.491, %struct.anon.492, %struct.anon.493, %struct.anon.494, %struct.anon.495, %struct.anon.496, %struct.anon.497, %struct.anon.498, %struct.anon.499, %struct.anon.500, %struct.anon.501, %struct.anon.502, %struct.anon.503, %struct.anon.504, %struct.anon.505, %struct.anon.506, %struct.anon.507, %struct.anon.508, %struct.anon.509, %struct.anon.510, %struct.anon.511, %struct.anon.512, %struct.anon.513, %struct.anon.514, %struct.anon.515, %struct.anon.516, %struct.anon.517, %struct.anon.518, %struct.anon.519, %struct.anon.520, %struct.anon.521, %struct.anon.522, %struct.anon.523, %struct.anon.524, %struct.anon.525, %struct.anon.526, %struct.anon.527, %struct.anon.528, %struct.anon.529, %struct.anon.530, %struct.anon.531, %struct.anon.532, %struct.anon.533, %struct.anon.534, %struct.anon.535, %struct.anon.536, %struct.anon.537, %struct.anon.538, %struct.anon.539, %struct.anon.540, %struct.anon.541, %struct.anon.542, %struct.anon.543, %struct.anon.544, %struct.anon.545, %struct.anon.546, %struct.anon.547, %struct.anon.548, %struct.anon.549, %struct.anon.550, %struct.anon.551, %struct.anon.552, %struct.anon.553, %struct.anon.554, %struct.anon.555, %struct.anon.556, %struct.anon.557, %struct.anon.558, %struct.anon.559, %struct.anon.560, %struct.anon.561, %struct.anon.562, %struct.anon.563, %struct.anon.564, %struct.anon.565, %struct.anon.566, %struct.anon.567, %struct.anon.568, %struct.anon.569, %struct.anon.570, %struct.anon.571, %struct.anon.572, %struct.anon.573, %struct.anon.574, %struct.anon.575, %struct.anon.576, %struct.anon.577, %struct.anon.578, %struct.anon.579, %struct.anon.580, %struct.anon.581, %struct.anon.582, %struct.anon.583, %struct.anon.584, %struct.anon.585, %struct.anon.586, %struct.anon.587, %struct.anon.588, %struct.anon.589, %struct.anon.590, %struct.anon.591, %struct.anon.592, %struct.anon.593, %struct.anon.594, %struct.anon.595, %struct.anon.596, %struct.anon.597, %struct.anon.598, %struct.anon.599, %struct.anon.600, %struct.anon.601, %struct.anon.602, %struct.anon.603, %struct.anon.604, %struct.anon.605, %struct.anon.606, %struct.anon.607, %struct.anon.608, %struct.anon.609, %struct.anon.610, %struct.anon.611, %struct.anon.612, %struct.anon.613, %struct.anon.614, %struct.anon.615, %struct.anon.616, %struct.anon.617, %struct.anon.618, %struct.anon.619, %struct.anon.620, %struct.anon.621, %struct.anon.622, %struct.anon.623, %struct.anon.624, %struct.anon.625, %struct.anon.626, %struct.anon.627, %struct.anon.628, %struct.anon.629, %struct.anon.630, %struct.anon.631, %struct.anon.632, %struct.anon.633, %struct.anon.634, %struct.anon.635, %struct.anon.636, %struct.anon.637, %struct.anon.638, %struct.anon.639, %struct.anon.640, %struct.anon.641, %struct.anon.642, %struct.anon.643, %struct.anon.644, %struct.anon.645, %struct.anon.646, %struct.anon.647, %struct.anon.648, %struct.anon.649, %struct.anon.650, %struct.anon.651, %struct.anon.652, %struct.anon.653, %struct.anon.654, %struct.anon.655, %struct.anon.656, %struct.anon.657, %struct.anon.658, %struct.anon.659, %struct.anon.660, %struct.anon.661, %struct.anon.662, %struct.anon.663, %struct.anon.664, %struct.anon.665, %struct.anon.666, %struct.anon.667, %struct.anon.668, %struct.anon.669, %struct.anon.670, %struct.anon.671, %struct.anon.672, %struct.anon.673, %struct.anon.674, %struct.anon.675, %struct.anon.676, %struct.anon.677, %struct.anon.678, %struct.anon.679, %struct.anon.680, %struct.anon.681, %struct.anon.682, %struct.anon.683, %struct.anon.684, %struct.anon.685, %struct.anon.686, %struct.anon.687, %struct.anon.688, %struct.anon.689, %struct.anon.690, %struct.anon.691, %struct.anon.692, %struct.anon.693, %struct.anon.694, %struct.anon.695, %struct.anon.696, %struct.anon.697, %struct.anon.698, %struct.anon.699, %struct.anon.700, %struct.anon.701, %struct.anon.702, %struct.anon.703, %struct.anon.704, %struct.anon.705, %struct.anon.706, %struct.anon.707, %struct.anon.708, %struct.anon.709, %struct.anon.710, %struct.anon.711, %struct.anon.712, %struct.anon.713, %struct.anon.714, %struct.anon.715, %struct.anon.716, %struct.anon.717, %struct.anon.718, %struct.anon.719, %struct.anon.720, %struct.anon.721, %struct.anon.722, %struct.anon.723, %struct.anon.724, %struct.anon.725, %struct.anon.726, %struct.anon.727, %struct.anon.728, %struct.anon.729, %struct.anon.730, %struct.anon.731, %struct.anon.732, %struct.anon.733, %struct.anon.734, %struct.anon.735, %struct.anon.736, %struct.anon.737, %struct.anon.738, %struct.anon.739, %struct.anon.740, %struct.anon.741, %struct.anon.742, %struct.anon.743, %struct.anon.744, %struct.anon.745, %struct.anon.746, %struct.anon.747, %struct.anon.748, %struct.anon.749, %struct.anon.750, %struct.anon.751, %struct.anon.752, %struct.anon.753, %struct.anon.754, %struct.anon.755, %struct.anon.756, %struct.anon.757, %struct.anon.758, %struct.anon.759, %struct.anon.760, %struct.anon.761 }
%struct.anon.70 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.71 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.72 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.73 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.74 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.75 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.76 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.77 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.78 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.79 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.80 = type { %struct.PyASCIIObject, [18 x i8] }
%struct.anon.81 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.82 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.83 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.84 = type { %struct.PyASCIIObject, [20 x i8] }
%struct.anon.85 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.86 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.87 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.88 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.89 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.90 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.91 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.92 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.93 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.94 = type { %struct.PyASCIIObject, [31 x i8] }
%struct.anon.95 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.96 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.97 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.98 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.99 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.100 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.101 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.102 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.103 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.104 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.105 = type { %struct.PyASCIIObject, [18 x i8] }
%struct.anon.106 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.107 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.108 = type { %struct.PyASCIIObject, [18 x i8] }
%struct.anon.109 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.110 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.111 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.112 = type { %struct.PyASCIIObject, [25 x i8] }
%struct.anon.113 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.114 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.115 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.116 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.117 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.118 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.119 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.120 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.121 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.122 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.123 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.124 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.125 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.126 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.127 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.128 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.129 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.130 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.131 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.132 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.133 = type { %struct.PyASCIIObject, [17 x i8] }
%struct.anon.134 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.135 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.136 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.137 = type { %struct.PyASCIIObject, [18 x i8] }
%struct.anon.138 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.139 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.140 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.141 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.142 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.143 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.144 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.145 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.146 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.147 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.148 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.149 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.150 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.151 = type { %struct.PyASCIIObject, [18 x i8] }
%struct.anon.152 = type { %struct.PyASCIIObject, [18 x i8] }
%struct.anon.153 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.154 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.155 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.156 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.157 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.158 = type { %struct.PyASCIIObject, [21 x i8] }
%struct.anon.159 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.160 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.161 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.162 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.163 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.164 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.165 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.166 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.167 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.168 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.169 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.170 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.171 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.172 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.173 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.174 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.175 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.176 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.177 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.178 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.179 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.180 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.181 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.182 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.183 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.184 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.185 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.186 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.187 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.188 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.189 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.190 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.191 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.192 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.193 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.194 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.195 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.196 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.197 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.198 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.199 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.200 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.201 = type { %struct.PyASCIIObject, [19 x i8] }
%struct.anon.202 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.203 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.204 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.205 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.206 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.207 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.208 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.209 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.210 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.211 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.212 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.213 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.214 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.215 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.216 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.217 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.218 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.219 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.220 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.221 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.222 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.223 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.224 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.225 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.226 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.227 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.228 = type { %struct.PyASCIIObject, [18 x i8] }
%struct.anon.229 = type { %struct.PyASCIIObject, [17 x i8] }
%struct.anon.230 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.231 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.232 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.233 = type { %struct.PyASCIIObject, [36 x i8] }
%struct.anon.234 = type { %struct.PyASCIIObject, [25 x i8] }
%struct.anon.235 = type { %struct.PyASCIIObject, [17 x i8] }
%struct.anon.236 = type { %struct.PyASCIIObject, [31 x i8] }
%struct.anon.237 = type { %struct.PyASCIIObject, [20 x i8] }
%struct.anon.238 = type { %struct.PyASCIIObject, [19 x i8] }
%struct.anon.239 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.240 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.241 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.242 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.243 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.244 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.245 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.246 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.247 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.248 = type { %struct.PyASCIIObject, [25 x i8] }
%struct.anon.249 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.250 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.251 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.252 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.253 = type { %struct.PyASCIIObject, [17 x i8] }
%struct.anon.254 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.255 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.256 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.257 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.258 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.259 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.260 = type { %struct.PyASCIIObject, [17 x i8] }
%struct.anon.261 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.262 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.263 = type { %struct.PyASCIIObject, [18 x i8] }
%struct.anon.264 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.265 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.266 = type { %struct.PyASCIIObject, [20 x i8] }
%struct.anon.267 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.268 = type { %struct.PyASCIIObject, [19 x i8] }
%struct.anon.269 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.270 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.271 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.272 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.273 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.274 = type { %struct.PyASCIIObject, [19 x i8] }
%struct.anon.275 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.276 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.277 = type { %struct.PyASCIIObject, [26 x i8] }
%struct.anon.278 = type { %struct.PyASCIIObject, [26 x i8] }
%struct.anon.279 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.280 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.281 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.282 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.283 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.284 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.285 = type { %struct.PyASCIIObject, [18 x i8] }
%struct.anon.286 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.287 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.288 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.289 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.290 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.291 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.292 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.293 = type { %struct.PyASCIIObject, [17 x i8] }
%struct.anon.294 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.295 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.296 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.297 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.298 = type { %struct.PyASCIIObject, [20 x i8] }
%struct.anon.299 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.300 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.301 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.302 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.303 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.304 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.305 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.306 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.307 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.308 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.309 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.310 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.311 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.312 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.313 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.314 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.315 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.316 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.317 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.318 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.319 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.320 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.321 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.322 = type { %struct.PyASCIIObject, [18 x i8] }
%struct.anon.323 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.324 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.325 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.326 = type { %struct.PyASCIIObject, [23 x i8] }
%struct.anon.327 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.328 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.329 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.330 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.331 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.332 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.333 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.334 = type { %struct.PyASCIIObject, [18 x i8] }
%struct.anon.335 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.336 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.337 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.338 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.339 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.340 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.341 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.342 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.343 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.344 = type { %struct.PyASCIIObject, [18 x i8] }
%struct.anon.345 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.346 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.347 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.348 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.349 = type { %struct.PyASCIIObject, [18 x i8] }
%struct.anon.350 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.351 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.352 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.353 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.354 = type { %struct.PyASCIIObject, [19 x i8] }
%struct.anon.355 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.356 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.357 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.358 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.359 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.360 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.361 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.362 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.363 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.364 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.365 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.366 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.367 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.368 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.369 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.370 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.371 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.372 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.373 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.374 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.375 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.376 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.377 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.378 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.379 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.380 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.381 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.382 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.383 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.384 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.385 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.386 = type { %struct.PyASCIIObject, [18 x i8] }
%struct.anon.387 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.388 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.389 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.390 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.391 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.392 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.393 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.394 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.395 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.396 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.397 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.398 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.399 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.400 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.401 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.402 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.403 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.404 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.405 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.406 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.407 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.408 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.409 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.410 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.411 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.412 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.413 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.414 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.415 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.416 = type { %struct.PyASCIIObject, [19 x i8] }
%struct.anon.417 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.418 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.419 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.420 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.421 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.422 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.423 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.424 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.425 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.426 = type { %struct.PyASCIIObject, [3 x i8] }
%struct.anon.427 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.428 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.429 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.430 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.431 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.432 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.433 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.434 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.435 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.436 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.437 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.438 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.439 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.440 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.441 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.442 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.443 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.444 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.445 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.446 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.447 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.448 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.449 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.450 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.451 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.452 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.453 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.454 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.455 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.456 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.457 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.458 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.459 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.460 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.461 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.462 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.463 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.464 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.465 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.466 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.467 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.468 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.469 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.470 = type { %struct.PyASCIIObject, [3 x i8] }
%struct.anon.471 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.472 = type { %struct.PyASCIIObject, [3 x i8] }
%struct.anon.473 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.474 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.475 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.476 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.477 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.478 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.479 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.480 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.481 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.482 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.483 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.484 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.485 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.486 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.487 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.488 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.489 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.490 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.491 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.492 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.493 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.494 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.495 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.496 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.497 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.498 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.499 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.500 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.501 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.502 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.503 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.504 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.505 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.506 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.507 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.508 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.509 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.510 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.511 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.512 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.513 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.514 = type { %struct.PyASCIIObject, [3 x i8] }
%struct.anon.515 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.516 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.517 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.518 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.519 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.520 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.521 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.522 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.523 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.524 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.525 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.526 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.527 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.528 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.529 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.530 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.531 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.532 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.533 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.534 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.535 = type { %struct.PyASCIIObject, [3 x i8] }
%struct.anon.536 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.537 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.538 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.539 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.540 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.541 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.542 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.543 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.544 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.545 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.546 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.547 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.548 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.549 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.550 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.551 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.552 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.553 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.554 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.555 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.556 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.557 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.558 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.559 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.560 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.561 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.562 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.563 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.564 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.565 = type { %struct.PyASCIIObject, [18 x i8] }
%struct.anon.566 = type { %struct.PyASCIIObject, [17 x i8] }
%struct.anon.567 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.568 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.569 = type { %struct.PyASCIIObject, [20 x i8] }
%struct.anon.570 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.571 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.572 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.573 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.574 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.575 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.576 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.577 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.578 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.579 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.580 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.581 = type { %struct.PyASCIIObject, [3 x i8] }
%struct.anon.582 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.583 = type { %struct.PyASCIIObject, [3 x i8] }
%struct.anon.584 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.585 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.586 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.587 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.588 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.589 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.590 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.591 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.592 = type { %struct.PyASCIIObject, [13 x i8] }
%struct.anon.593 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.594 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.595 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.596 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.597 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.598 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.599 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.600 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.601 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.602 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.603 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.604 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.605 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.606 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.607 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.608 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.609 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.610 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.611 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.612 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.613 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.614 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.615 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.616 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.617 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.618 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.619 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.620 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.621 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.622 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.623 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.624 = type { %struct.PyASCIIObject, [20 x i8] }
%struct.anon.625 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.626 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.627 = type { %struct.PyASCIIObject, [17 x i8] }
%struct.anon.628 = type { %struct.PyASCIIObject, [17 x i8] }
%struct.anon.629 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.630 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.631 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.632 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.633 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.634 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.635 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.636 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.637 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.638 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.639 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.640 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.641 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.642 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.643 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.644 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.645 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.646 = type { %struct.PyASCIIObject, [17 x i8] }
%struct.anon.647 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.648 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.649 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.650 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.651 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.652 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.653 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.654 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.655 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.656 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.657 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.658 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.659 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.660 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.661 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.662 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.663 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.664 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.665 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.666 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.667 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.668 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.669 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.670 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.671 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.672 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.673 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.674 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.675 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.676 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.677 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.678 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.679 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.680 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.681 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.682 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.683 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.684 = type { %struct.PyASCIIObject, [19 x i8] }
%struct.anon.685 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.686 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.687 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.688 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.689 = type { %struct.PyASCIIObject, [17 x i8] }
%struct.anon.690 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.691 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.692 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.693 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.694 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.695 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.696 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.697 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.698 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.699 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.700 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.701 = type { %struct.PyASCIIObject, [11 x i8] }
%struct.anon.702 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.703 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.704 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.705 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.706 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.707 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.708 = type { %struct.PyASCIIObject, [28 x i8] }
%struct.anon.709 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.710 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.711 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.712 = type { %struct.PyASCIIObject, [20 x i8] }
%struct.anon.713 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.714 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.715 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.716 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.717 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.718 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.719 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.720 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.721 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.722 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.723 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.724 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.725 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.726 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.727 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.728 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.729 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.730 = type { %struct.PyASCIIObject, [10 x i8] }
%struct.anon.731 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.732 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.733 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.734 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.735 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.736 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.737 = type { %struct.PyASCIIObject, [3 x i8] }
%struct.anon.738 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.739 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.740 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.741 = type { %struct.PyASCIIObject, [15 x i8] }
%struct.anon.742 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.743 = type { %struct.PyASCIIObject, [16 x i8] }
%struct.anon.744 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.745 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.746 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.747 = type { %struct.PyASCIIObject, [7 x i8] }
%struct.anon.748 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.749 = type { %struct.PyASCIIObject, [12 x i8] }
%struct.anon.750 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.751 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.752 = type { %struct.PyASCIIObject, [8 x i8] }
%struct.anon.753 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.754 = type { %struct.PyASCIIObject, [4 x i8] }
%struct.anon.755 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.756 = type { %struct.PyASCIIObject, [9 x i8] }
%struct.anon.757 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.758 = type { %struct.PyASCIIObject, [14 x i8] }
%struct.anon.759 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.760 = type { %struct.PyASCIIObject, [5 x i8] }
%struct.anon.761 = type { %struct.PyASCIIObject, [6 x i8] }
%struct.anon.762 = type { %struct.PyASCIIObject, [2 x i8] }
%struct.anon.763 = type { %struct.PyCompactUnicodeObject, [2 x i8] }
%struct.PyCompactUnicodeObject = type { %struct.PyASCIIObject, i64, ptr }
%struct.PyTupleObject = type { %struct.PyVarObject, [1 x ptr] }
%struct.PyGC_Head = type { i64, i64 }
%struct.PyHamtNode_Bitmap = type { %struct.PyVarObject, i32, [1 x ptr] }
%struct._PyContextTokenMissing = type { %struct._object }
%struct._is = type { %struct._ceval_state, ptr, i64, i64, i32, ptr, i32, i32, i64, %struct.pythreads, ptr, ptr, i64, %struct._gc_runtime_state, ptr, ptr, %struct._import_state, %struct._gil_runtime_state, ptr, ptr, ptr, i32, %struct.PyConfig, i64, ptr, ptr, ptr, ptr, [8 x ptr], i8, i64, [255 x ptr], %struct._xi_state, ptr, ptr, ptr, %struct._warnings_runtime_state, %struct.atexit_state, %struct._obmalloc_state, ptr, [8 x ptr], [8 x ptr], i8, %struct._py_object_state, %struct._Py_unicode_state, %struct._Py_float_state, %struct._Py_long_state, %struct._dtoa_state, %struct._py_func_state, ptr, %struct._Py_tuple_state, %struct._Py_list_state, %struct._Py_dict_state, %struct._Py_async_gen_state, %struct._Py_context_state, %struct._Py_exc_state, %struct.ast_state, %struct.types_state, %struct.callable_cache, ptr, ptr, i16, i16, i32, %struct._Py_GlobalMonitors, i8, i8, i64, i64, [8 x [17 x ptr]], [8 x ptr], %struct._Py_interp_cached_objects, %struct._Py_interp_static_objects, %struct._PyThreadStateImpl, i64 }
%struct._ceval_state = type { i64, [7 x i64], i32, ptr, i32, %struct._pending_calls }
%struct.pythreads = type { i64, ptr, ptr, i64, i64 }
%struct._gc_runtime_state = type { ptr, i32, i32, i32, [3 x %struct.gc_generation], ptr, %struct.gc_generation, [3 x %struct.gc_generation_stats], i32, ptr, ptr, i64, i64 }
%struct.gc_generation = type { %struct.PyGC_Head, i32, i32 }
%struct.gc_generation_stats = type { i64, i64, i64 }
%struct._import_state = type { ptr, ptr, ptr, i32, i32, i32, ptr, %struct.anon.764, %struct.anon.765 }
%struct.anon.764 = type { ptr, i64, i32 }
%struct.anon.765 = type { i32, i64, i32 }
%struct._gil_runtime_state = type { i64, ptr, i32, i64, %union.pthread_cond_t, %union.pthread_mutex_t, %union.pthread_cond_t, %union.pthread_mutex_t }
%union.pthread_cond_t = type { %struct.__pthread_cond_s }
%struct.__pthread_cond_s = type { %union.__atomic_wide_counter, %union.__atomic_wide_counter, [2 x i32], [2 x i32], i32, i32, [2 x i32] }
%union.__atomic_wide_counter = type { i64 }
%union.pthread_mutex_t = type { %struct.__pthread_mutex_s }
%struct.__pthread_mutex_s = type { i32, i32, i32, i32, i32, i16, i16, %struct.__pthread_internal_list }
%struct.__pthread_internal_list = type { ptr, ptr }
%struct.PyConfig = type { i32, i32, i32, i32, i32, i32, i64, i32, i32, i32, i32, i32, i32, i32, ptr, i32, ptr, ptr, ptr, i32, %struct.PyWideStringList, %struct.PyWideStringList, %struct.PyWideStringList, %struct.PyWideStringList, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, ptr, ptr, ptr, i32, i32, i32, i32, i32, ptr, ptr, ptr, ptr, i32, %struct.PyWideStringList, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i32, ptr, ptr, ptr, ptr, i32, i32, i32 }
%struct._xi_state = type { %struct._xidregistry, ptr }
%struct._warnings_runtime_state = type { ptr, ptr, ptr, i64 }
%struct.atexit_state = type { ptr, ptr, ptr, i32, i32 }
%struct._obmalloc_state = type { %struct._obmalloc_pools, %struct._obmalloc_mgmt, %struct._obmalloc_usage }
%struct._obmalloc_pools = type { [64 x ptr] }
%struct._obmalloc_mgmt = type { ptr, i32, ptr, ptr, [65 x ptr], i64, i64, i64, i64 }
%struct._obmalloc_usage = type { %struct.arena_map_top, i32, i32 }
%struct.arena_map_top = type { [32768 x ptr] }
%struct._py_object_state = type { i32 }
%struct._Py_unicode_state = type { %struct._Py_unicode_fs_codec, ptr, %struct._Py_unicode_ids }
%struct._Py_unicode_fs_codec = type { ptr, i32, ptr, i32 }
%struct._Py_unicode_ids = type { i64, ptr }
%struct._Py_float_state = type { i32, ptr }
%struct._Py_long_state = type { i32 }
%struct._dtoa_state = type { [8 x ptr], [8 x ptr], [288 x double], ptr }
%struct._py_func_state = type { i32, [4096 x ptr] }
%struct._Py_tuple_state = type { [20 x ptr], [20 x i32] }
%struct._Py_list_state = type { [80 x ptr], i32 }
%struct._Py_dict_state = type { i64, i32, [80 x ptr], [80 x ptr], i32, i32, [8 x ptr] }
%struct._Py_async_gen_state = type { [80 x ptr], i32, [80 x ptr], i32 }
%struct._Py_context_state = type { ptr, i32 }
%struct._Py_exc_state = type { ptr, ptr, i32, ptr }
%struct.ast_state = type { %struct._PyOnceFlag, i32, i32, i32, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr }
%struct._PyOnceFlag = type { i8 }
%struct.types_state = type { i32, %struct.type_cache, i64, [200 x %struct.static_builtin_state] }
%struct.type_cache = type { [4096 x %struct.type_cache_entry] }
%struct.type_cache_entry = type { i32, ptr, ptr }
%struct.static_builtin_state = type { ptr, i32, i32, ptr, ptr, ptr }
%struct.callable_cache = type { ptr, ptr, ptr, ptr }
%struct._Py_GlobalMonitors = type { [15 x i8] }
%struct._Py_interp_cached_objects = type { ptr, ptr, ptr, ptr, [10 x ptr], ptr, ptr, ptr, ptr, ptr, ptr }
%struct._Py_interp_static_objects = type { %struct.anon.767 }
%struct.anon.767 = type { i32, %struct.PyGC_Head, %struct.PyHamtObject, %struct.PyBaseExceptionObject }
%struct.PyHamtObject = type { %struct._object, ptr, ptr, i64 }
%struct.PyBaseExceptionObject = type { %struct._object, ptr, ptr, ptr, ptr, ptr, ptr, i8 }
%struct._PyThreadStateImpl = type { %struct._ts }
%struct._ts = type { ptr, ptr, ptr, %struct.anon.768, i32, i32, i32, i32, i32, i32, i32, i32, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i32, ptr, i64, i64, %struct._py_trashcan, i64, ptr, ptr, i32, ptr, ptr, ptr, i64, i64, ptr, ptr, ptr, %struct._err_stackitem }
%struct.anon.768 = type { i32 }
%struct._py_trashcan = type { i32, ptr }
%struct._err_stackitem = type { ptr, ptr }
%struct._typeobject = type { %struct.PyVarObject, ptr, i64, i64, ptr, i64, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i64, ptr, ptr, ptr, ptr, i64, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i64, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i32, ptr, ptr, i8 }
%struct.PyNumberMethods = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr }
%struct.PySequenceMethods = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr }
%struct.PyMappingMethods = type { ptr, ptr, ptr }
%struct.PyBufferProcs = type { ptr, ptr }
%struct.PyMethodDef = type { ptr, ptr, i32, ptr }
%struct.anon.770 = type { %struct.PyGC_Head, %struct.PyVarObject, [2 x ptr] }
%struct._PyArg_Parser = type { ptr, ptr, ptr, ptr, %struct._PyOnceFlag, i32, i32, i32, i32, ptr, ptr }
%struct.anon.771 = type { %struct.PyGC_Head, %struct.PyVarObject, [1 x ptr] }
%struct.anon.772 = type { %struct.PyGC_Head, %struct.PyVarObject, [2 x ptr] }
%struct.anon.773 = type { %struct.PyGC_Head, %struct.PyVarObject, [2 x ptr] }
%struct.anon.774 = type { %struct.PyGC_Head, %struct.PyVarObject, [2 x ptr] }
%struct.anon.775 = type { %struct.PyGC_Head, %struct.PyVarObject, [1 x ptr] }
%struct.anon.776 = type { %struct.PyGC_Head, %struct.PyVarObject, [1 x ptr] }
%struct.anon.777 = type { %struct.PyGC_Head, %struct.PyVarObject, [3 x ptr] }
%struct._PyBytesWriter = type { ptr, i64, i64, i32, i32, i32, [512 x i8] }
%struct.__va_list_tag = type { i32, i32, ptr, ptr }
%struct.Py_buffer = type { ptr, ptr, i64, i64, i32, i32, ptr, ptr, ptr, ptr, ptr }
%struct.PyListObject = type { %struct.PyVarObject, ptr, i64 }
%struct.striterobject = type { %struct._object, i64, ptr }
%struct.PyByteArrayObject = type { %struct.PyVarObject, i64, ptr, ptr, i64 }
%struct.PyUnicodeObject = type { %struct.PyCompactUnicodeObject, %union.anon.769 }
%union.anon.769 = type { ptr }
%struct.stringlib__pre = type { ptr, i64, i64, i64, i64, i32, [64 x i8] }
%struct.PyDictObject = type { %struct._object, i64, i64, ptr, ptr }

@PyExc_SystemError = external global ptr, align 8
@.str = private unnamed_addr constant [50 x i8] c"Negative size passed to PyBytes_FromStringAndSize\00", align 1
@_PyRuntime = external global %struct.pyruntimestate, align 8
@PyExc_OverflowError = external global ptr, align 8
@.str.1 = private unnamed_addr constant [24 x i8] c"byte string is too long\00", align 1
@PyBytes_Type = dso_local global %struct._typeobject { %struct.PyVarObject { %struct._object { %union.anon.39 { i64 4294967295 }, ptr @PyType_Type }, i64 0 }, ptr @.str.34, i64 33, i64 1, ptr null, i64 0, ptr null, ptr null, ptr null, ptr @bytes_repr, ptr @bytes_as_number, ptr @bytes_as_sequence, ptr @bytes_as_mapping, ptr @bytes_hash, ptr null, ptr @bytes_str, ptr @PyObject_GenericGetAttr, ptr null, ptr @bytes_as_buffer, i64 138413056, ptr @bytes_doc, ptr null, ptr null, ptr @bytes_richcompare, i64 0, ptr @bytes_iter, ptr null, ptr @bytes_methods, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, i64 0, ptr null, ptr @bytes_alloc, ptr @bytes_new, ptr @PyObject_Free, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, i32 0, ptr null, ptr null, i8 0 }, align 8
@_Py_ctype_table = external constant [256 x i32], align 16
@.str.2 = private unnamed_addr constant [70 x i8] c"PyBytes_FromFormatV(): %c format expects an integer in range [0; 255]\00", align 1
@.str.3 = private unnamed_addr constant [4 x i8] c"%ld\00", align 1
@.str.4 = private unnamed_addr constant [4 x i8] c"%zd\00", align 1
@.str.5 = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str.6 = private unnamed_addr constant [4 x i8] c"%lu\00", align 1
@.str.7 = private unnamed_addr constant [4 x i8] c"%zu\00", align 1
@.str.8 = private unnamed_addr constant [3 x i8] c"%u\00", align 1
@.str.9 = private unnamed_addr constant [3 x i8] c"%i\00", align 1
@.str.10 = private unnamed_addr constant [3 x i8] c"%x\00", align 1
@.str.11 = private unnamed_addr constant [3 x i8] c"%p\00", align 1
@.str.12 = private unnamed_addr constant [33 x i8] c"../cpython/Objects/bytesobject.c\00", align 1
@PyByteArray_Type = external global %struct._typeobject, align 8
@PyExc_TypeError = external global ptr, align 8
@.str.13 = private unnamed_addr constant [26 x i8] c"format requires a mapping\00", align 1
@PyExc_ValueError = external global ptr, align 8
@.str.14 = private unnamed_addr constant [22 x i8] c"incomplete format key\00", align 1
@.str.15 = private unnamed_addr constant [12 x i8] c"* wants int\00", align 1
@.str.16 = private unnamed_addr constant [14 x i8] c"width too big\00", align 1
@.str.17 = private unnamed_addr constant [13 x i8] c"prec too big\00", align 1
@.str.18 = private unnamed_addr constant [18 x i8] c"incomplete format\00", align 1
@PyLong_Type = external global %struct._typeobject, align 8
@.str.19 = private unnamed_addr constant [54 x i8] c"unsupported format character '%c' (0x%x) at index %zd\00", align 1
@.str.20 = private unnamed_addr constant [52 x i8] c"not all arguments converted during bytes formatting\00", align 1
@.str.21 = private unnamed_addr constant [21 x i8] c"Trailing \\ in string\00", align 1
@_PyLong_DigitValue = external global [256 x i8], align 16
@.str.22 = private unnamed_addr constant [7 x i8] c"strict\00", align 1
@.str.23 = private unnamed_addr constant [34 x i8] c"invalid \\x escape at position %zd\00", align 1
@.str.24 = private unnamed_addr constant [8 x i8] c"replace\00", align 1
@.str.25 = private unnamed_addr constant [7 x i8] c"ignore\00", align 1
@.str.26 = private unnamed_addr constant [52 x i8] c"decoding error; unknown error handling code: %.400s\00", align 1
@PyExc_DeprecationWarning = external global ptr, align 8
@.str.27 = private unnamed_addr constant [38 x i8] c"invalid octal escape sequence '\\%.3s'\00", align 1
@.str.28 = private unnamed_addr constant [30 x i8] c"invalid escape sequence '\\%c'\00", align 1
@.str.29 = private unnamed_addr constant [29 x i8] c"expected bytes, %.200s found\00", align 1
@.str.30 = private unnamed_addr constant [19 x i8] c"embedded null byte\00", align 1
@Py_hexdigits = external global ptr, align 8
@.str.31 = private unnamed_addr constant [39 x i8] c"bytes object is too large to make repr\00", align 1
@.str.32 = private unnamed_addr constant [62 x i8] c"non-hexadecimal number found in fromhex() arg at position %zd\00", align 1
@PyList_Type = external global %struct._typeobject, align 8
@PyTuple_Type = external global %struct._typeobject, align 8
@.str.33 = private unnamed_addr constant [40 x i8] c"cannot convert '%.200s' object to bytes\00", align 1
@PyType_Type = external global %struct._typeobject, align 8
@.str.34 = private unnamed_addr constant [6 x i8] c"bytes\00", align 1
@bytes_as_number = internal global %struct.PyNumberMethods { ptr null, ptr null, ptr null, ptr @bytes_mod, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null }, align 8
@bytes_as_sequence = internal global %struct.PySequenceMethods { ptr @bytes_length, ptr @bytes_concat, ptr @bytes_repeat, ptr @bytes_item, ptr null, ptr null, ptr null, ptr @bytes_contains, ptr null, ptr null }, align 8
@bytes_as_mapping = internal global %struct.PyMappingMethods { ptr @bytes_length, ptr @bytes_subscript, ptr null }, align 8
@bytes_as_buffer = internal global %struct.PyBufferProcs { ptr @bytes_buffer_getbuffer, ptr null }, align 8
@bytes_doc = internal constant [459 x i8] c"bytes(iterable_of_ints) -> bytes\0Abytes(string, encoding[, errors]) -> bytes\0Abytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer\0Abytes(int) -> bytes object of size given by the parameter initialized with null bytes\0Abytes() -> empty bytes object\0A\0AConstruct an immutable array of bytes from:\0A  - an iterable yielding integers in range(256)\0A  - a text string encoded using the specified encoding\0A  - any object implementing the buffer API.\0A  - an integer\00", align 16
@bytes_methods = internal global [45 x %struct.PyMethodDef] [%struct.PyMethodDef { ptr @.str.59, ptr @bytes_getnewargs, i32 4, ptr null }, %struct.PyMethodDef { ptr @.str.60, ptr @bytes___bytes__, i32 4, ptr @bytes___bytes____doc__ }, %struct.PyMethodDef { ptr @.str.61, ptr @stringlib_capitalize, i32 4, ptr @_Py_capitalize__doc__ }, %struct.PyMethodDef { ptr @.str.62, ptr @stringlib_center, i32 128, ptr @stringlib_center__doc__ }, %struct.PyMethodDef { ptr @.str.63, ptr @bytes_count, i32 1, ptr @_Py_count__doc__ }, %struct.PyMethodDef { ptr @.str.64, ptr @bytes_decode, i32 130, ptr @bytes_decode__doc__ }, %struct.PyMethodDef { ptr @.str.65, ptr @bytes_endswith, i32 1, ptr @_Py_endswith__doc__ }, %struct.PyMethodDef { ptr @.str.66, ptr @stringlib_expandtabs, i32 130, ptr @stringlib_expandtabs__doc__ }, %struct.PyMethodDef { ptr @.str.67, ptr @bytes_find, i32 1, ptr @_Py_find__doc__ }, %struct.PyMethodDef { ptr @.str.68, ptr @bytes_fromhex, i32 24, ptr @bytes_fromhex__doc__ }, %struct.PyMethodDef { ptr @.str.69, ptr @bytes_hex, i32 130, ptr @bytes_hex__doc__ }, %struct.PyMethodDef { ptr @.str.70, ptr @bytes_index, i32 1, ptr @_Py_index__doc__ }, %struct.PyMethodDef { ptr @.str.71, ptr @stringlib_isalnum, i32 4, ptr @_Py_isalnum__doc__ }, %struct.PyMethodDef { ptr @.str.72, ptr @stringlib_isalpha, i32 4, ptr @_Py_isalpha__doc__ }, %struct.PyMethodDef { ptr @.str.73, ptr @stringlib_isascii, i32 4, ptr @_Py_isascii__doc__ }, %struct.PyMethodDef { ptr @.str.74, ptr @stringlib_isdigit, i32 4, ptr @_Py_isdigit__doc__ }, %struct.PyMethodDef { ptr @.str.75, ptr @stringlib_islower, i32 4, ptr @_Py_islower__doc__ }, %struct.PyMethodDef { ptr @.str.76, ptr @stringlib_isspace, i32 4, ptr @_Py_isspace__doc__ }, %struct.PyMethodDef { ptr @.str.77, ptr @stringlib_istitle, i32 4, ptr @_Py_istitle__doc__ }, %struct.PyMethodDef { ptr @.str.78, ptr @stringlib_isupper, i32 4, ptr @_Py_isupper__doc__ }, %struct.PyMethodDef { ptr @.str.79, ptr @bytes_join, i32 8, ptr @bytes_join__doc__ }, %struct.PyMethodDef { ptr @.str.80, ptr @stringlib_ljust, i32 128, ptr @stringlib_ljust__doc__ }, %struct.PyMethodDef { ptr @.str.81, ptr @stringlib_lower, i32 4, ptr @_Py_lower__doc__ }, %struct.PyMethodDef { ptr @.str.82, ptr @bytes_lstrip, i32 128, ptr @bytes_lstrip__doc__ }, %struct.PyMethodDef { ptr @.str.83, ptr @bytes_maketrans, i32 160, ptr @bytes_maketrans__doc__ }, %struct.PyMethodDef { ptr @.str.84, ptr @bytes_partition, i32 8, ptr @bytes_partition__doc__ }, %struct.PyMethodDef { ptr @.str.24, ptr @bytes_replace, i32 128, ptr @bytes_replace__doc__ }, %struct.PyMethodDef { ptr @.str.85, ptr @bytes_removeprefix, i32 8, ptr @bytes_removeprefix__doc__ }, %struct.PyMethodDef { ptr @.str.86, ptr @bytes_removesuffix, i32 8, ptr @bytes_removesuffix__doc__ }, %struct.PyMethodDef { ptr @.str.87, ptr @bytes_rfind, i32 1, ptr @_Py_rfind__doc__ }, %struct.PyMethodDef { ptr @.str.88, ptr @bytes_rindex, i32 1, ptr @_Py_rindex__doc__ }, %struct.PyMethodDef { ptr @.str.89, ptr @stringlib_rjust, i32 128, ptr @stringlib_rjust__doc__ }, %struct.PyMethodDef { ptr @.str.90, ptr @bytes_rpartition, i32 8, ptr @bytes_rpartition__doc__ }, %struct.PyMethodDef { ptr @.str.91, ptr @bytes_rsplit, i32 130, ptr @bytes_rsplit__doc__ }, %struct.PyMethodDef { ptr @.str.92, ptr @bytes_rstrip, i32 128, ptr @bytes_rstrip__doc__ }, %struct.PyMethodDef { ptr @.str.93, ptr @bytes_split, i32 130, ptr @bytes_split__doc__ }, %struct.PyMethodDef { ptr @.str.94, ptr @bytes_splitlines, i32 130, ptr @bytes_splitlines__doc__ }, %struct.PyMethodDef { ptr @.str.95, ptr @bytes_startswith, i32 1, ptr @_Py_startswith__doc__ }, %struct.PyMethodDef { ptr @.str.96, ptr @bytes_strip, i32 128, ptr @bytes_strip__doc__ }, %struct.PyMethodDef { ptr @.str.97, ptr @stringlib_swapcase, i32 4, ptr @_Py_swapcase__doc__ }, %struct.PyMethodDef { ptr @.str.98, ptr @stringlib_title, i32 4, ptr @_Py_title__doc__ }, %struct.PyMethodDef { ptr @.str.99, ptr @bytes_translate, i32 130, ptr @bytes_translate__doc__ }, %struct.PyMethodDef { ptr @.str.100, ptr @stringlib_upper, i32 4, ptr @_Py_upper__doc__ }, %struct.PyMethodDef { ptr @.str.101, ptr @stringlib_zfill, i32 8, ptr @stringlib_zfill__doc__ }, %struct.PyMethodDef zeroinitializer], align 16
@.str.35 = private unnamed_addr constant [30 x i8] c"can't concat %.100s to %.100s\00", align 1
@.str.36 = private unnamed_addr constant [15 x i8] c"bytes_iterator\00", align 1
@striter_methods = internal global [4 x %struct.PyMethodDef] [%struct.PyMethodDef { ptr @.str.127, ptr @striter_len, i32 4, ptr @length_hint_doc }, %struct.PyMethodDef { ptr @.str.128, ptr @striter_reduce, i32 4, ptr @reduce_doc }, %struct.PyMethodDef { ptr @.str.129, ptr @striter_setstate, i32 8, ptr @setstate_doc }, %struct.PyMethodDef zeroinitializer], align 16
@PyBytesIter_Type = dso_local global %struct._typeobject { %struct.PyVarObject { %struct._object { %union.anon.39 { i64 4294967295 }, ptr @PyType_Type }, i64 0 }, ptr @.str.36, i64 32, i64 0, ptr @striter_dealloc, i64 0, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @PyObject_GenericGetAttr, ptr null, ptr null, i64 16384, ptr null, ptr @striter_traverse, ptr null, ptr null, i64 0, ptr @PyObject_SelfIter, ptr @striter_next, ptr @striter_methods, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, i64 0, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, i32 0, ptr null, ptr null, i8 0 }, align 8
@.str.37 = private unnamed_addr constant [25 x i8] c"byte string is too large\00", align 1
@.str.38 = private unnamed_addr constant [39 x i8] c"not enough arguments for format string\00", align 1
@.str.39 = private unnamed_addr constant [43 x i8] c"__bytes__ returned non-bytes (type %.200s)\00", align 1
@.str.40 = private unnamed_addr constant [87 x i8] c"%%b requires a bytes-like object, or an object that implements __bytes__, not '%.100s'\00", align 1
@_Py_tss_tstate = external thread_local global ptr, align 8
@.str.41 = private unnamed_addr constant [40 x i8] c"%%%c format: %s is required, not %.200s\00", align 1
@.str.42 = private unnamed_addr constant [11 x i8] c"an integer\00", align 1
@.str.43 = private unnamed_addr constant [14 x i8] c"a real number\00", align 1
@.str.44 = private unnamed_addr constant [36 x i8] c"float argument required, not %.200s\00", align 1
@.str.45 = private unnamed_addr constant [25 x i8] c"%c arg not in range(256)\00", align 1
@.str.46 = private unnamed_addr constant [54 x i8] c"%c requires an integer in range(256) or a single byte\00", align 1
@.str.47 = private unnamed_addr constant [26 x i8] c"can only join an iterable\00", align 1
@.str.48 = private unnamed_addr constant [61 x i8] c"sequence item %zd: expected a bytes-like object, %.80s found\00", align 1
@.str.49 = private unnamed_addr constant [26 x i8] c"join() result is too long\00", align 1
@PyExc_RuntimeError = external global ptr, align 8
@.str.50 = private unnamed_addr constant [39 x i8] c"sequence changed size during iteration\00", align 1
@.str.51 = private unnamed_addr constant [31 x i8] c"bytes must be in range(0, 256)\00", align 1
@_Py_NotImplementedStruct = external global %struct._object, align 8
@.str.52 = private unnamed_addr constant [28 x i8] c"repeated bytes are too long\00", align 1
@PyExc_IndexError = external global ptr, align 8
@.str.53 = private unnamed_addr constant [19 x i8] c"index out of range\00", align 1
@PySlice_Type = external global %struct._typeobject, align 8
@.str.54 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.55 = private unnamed_addr constant [52 x i8] c"byte indices must be integers or slices, not %.200s\00", align 1
@PyExc_BytesWarning = external global ptr, align 8
@.str.56 = private unnamed_addr constant [26 x i8] c"str() on a bytes instance\00", align 1
@.str.57 = private unnamed_addr constant [36 x i8] c"Comparison between bytes and string\00", align 1
@.str.58 = private unnamed_addr constant [33 x i8] c"Comparison between bytes and int\00", align 1
@_Py_TrueStruct = external global %struct._longobject, align 8
@_Py_FalseStruct = external global %struct._longobject, align 8
@.str.59 = private unnamed_addr constant [15 x i8] c"__getnewargs__\00", align 1
@.str.60 = private unnamed_addr constant [10 x i8] c"__bytes__\00", align 1
@bytes___bytes____doc__ = internal constant [64 x i8] c"__bytes__($self, /)\0A--\0A\0AConvert this value to exact type bytes.\00", align 16
@.str.61 = private unnamed_addr constant [11 x i8] c"capitalize\00", align 1
@_Py_capitalize__doc__ = external constant [0 x i8], align 1
@.str.62 = private unnamed_addr constant [7 x i8] c"center\00", align 1
@stringlib_center__doc__ = internal constant [138 x i8] c"center($self, width, fillchar=b' ', /)\0A--\0A\0AReturn a centered string of length width.\0A\0APadding is done using the specified fill character.\00", align 16
@.str.63 = private unnamed_addr constant [6 x i8] c"count\00", align 1
@_Py_count__doc__ = external constant [0 x i8], align 1
@.str.64 = private unnamed_addr constant [7 x i8] c"decode\00", align 1
@bytes_decode__doc__ = internal constant [505 x i8] c"decode($self, /, encoding='utf-8', errors='strict')\0A--\0A\0ADecode the bytes using the codec registered for encoding.\0A\0A  encoding\0A    The encoding with which to decode the bytes.\0A  errors\0A    The error handling scheme to use for the handling of decoding errors.\0A    The default is 'strict' meaning that decoding errors raise a\0A    UnicodeDecodeError. Other possible values are 'ignore' and 'replace'\0A    as well as any other name registered with codecs.register_error that\0A    can handle UnicodeDecodeErrors.\00", align 16
@.str.65 = private unnamed_addr constant [9 x i8] c"endswith\00", align 1
@_Py_endswith__doc__ = external constant [0 x i8], align 1
@.str.66 = private unnamed_addr constant [11 x i8] c"expandtabs\00", align 1
@stringlib_expandtabs__doc__ = internal constant [167 x i8] c"expandtabs($self, /, tabsize=8)\0A--\0A\0AReturn a copy where all tab characters are expanded using spaces.\0A\0AIf tabsize is not given, a tab size of 8 characters is assumed.\00", align 16
@.str.67 = private unnamed_addr constant [5 x i8] c"find\00", align 1
@_Py_find__doc__ = external constant [0 x i8], align 1
@.str.68 = private unnamed_addr constant [8 x i8] c"fromhex\00", align 1
@bytes_fromhex__doc__ = internal constant [189 x i8] c"fromhex($type, string, /)\0A--\0A\0ACreate a bytes object from a string of hexadecimal numbers.\0A\0ASpaces between two numbers are accepted.\0AExample: bytes.fromhex('B9 01EF') -> b'\\\\xb9\\\\x01\\\\xef'.\00", align 16
@.str.69 = private unnamed_addr constant [4 x i8] c"hex\00", align 1
@bytes_hex__doc__ = internal constant [482 x i8] c"hex($self, /, sep=<unrepresentable>, bytes_per_sep=1)\0A--\0A\0ACreate a string of hexadecimal numbers from a bytes object.\0A\0A  sep\0A    An optional single character or byte to separate hex bytes.\0A  bytes_per_sep\0A    How many bytes between separators.  Positive values count from the\0A    right, negative values count from the left.\0A\0AExample:\0A>>> value = b'\\xb9\\x01\\xef'\0A>>> value.hex()\0A'b901ef'\0A>>> value.hex(':')\0A'b9:01:ef'\0A>>> value.hex(':', 2)\0A'b9:01ef'\0A>>> value.hex(':', -2)\0A'b901:ef'\00", align 16
@.str.70 = private unnamed_addr constant [6 x i8] c"index\00", align 1
@_Py_index__doc__ = external constant [0 x i8], align 1
@.str.71 = private unnamed_addr constant [8 x i8] c"isalnum\00", align 1
@_Py_isalnum__doc__ = external constant [0 x i8], align 1
@.str.72 = private unnamed_addr constant [8 x i8] c"isalpha\00", align 1
@_Py_isalpha__doc__ = external constant [0 x i8], align 1
@.str.73 = private unnamed_addr constant [8 x i8] c"isascii\00", align 1
@_Py_isascii__doc__ = external constant [0 x i8], align 1
@.str.74 = private unnamed_addr constant [8 x i8] c"isdigit\00", align 1
@_Py_isdigit__doc__ = external constant [0 x i8], align 1
@.str.75 = private unnamed_addr constant [8 x i8] c"islower\00", align 1
@_Py_islower__doc__ = external constant [0 x i8], align 1
@.str.76 = private unnamed_addr constant [8 x i8] c"isspace\00", align 1
@_Py_isspace__doc__ = external constant [0 x i8], align 1
@.str.77 = private unnamed_addr constant [8 x i8] c"istitle\00", align 1
@_Py_istitle__doc__ = external constant [0 x i8], align 1
@.str.78 = private unnamed_addr constant [8 x i8] c"isupper\00", align 1
@_Py_isupper__doc__ = external constant [0 x i8], align 1
@.str.79 = private unnamed_addr constant [5 x i8] c"join\00", align 1
@bytes_join__doc__ = internal constant [253 x i8] c"join($self, iterable_of_bytes, /)\0A--\0A\0AConcatenate any number of bytes objects.\0A\0AThe bytes whose method is called is inserted in between each pair.\0A\0AThe result is returned as a new bytes object.\0A\0AExample: b'.'.join([b'ab', b'pq', b'rs']) -> b'ab.pq.rs'.\00", align 16
@.str.80 = private unnamed_addr constant [6 x i8] c"ljust\00", align 1
@stringlib_ljust__doc__ = internal constant [143 x i8] c"ljust($self, width, fillchar=b' ', /)\0A--\0A\0AReturn a left-justified string of length width.\0A\0APadding is done using the specified fill character.\00", align 16
@.str.81 = private unnamed_addr constant [6 x i8] c"lower\00", align 1
@_Py_lower__doc__ = external constant [0 x i8], align 1
@.str.82 = private unnamed_addr constant [7 x i8] c"lstrip\00", align 1
@bytes_lstrip__doc__ = internal constant [150 x i8] c"lstrip($self, bytes=None, /)\0A--\0A\0AStrip leading bytes contained in the argument.\0A\0AIf the argument is omitted or None, strip leading  ASCII whitespace.\00", align 16
@.str.83 = private unnamed_addr constant [10 x i8] c"maketrans\00", align 1
@bytes_maketrans__doc__ = internal constant [268 x i8] c"maketrans(frm, to, /)\0A--\0A\0AReturn a translation table usable for the bytes or bytearray translate method.\0A\0AThe returned table will be one where each byte in frm is mapped to the byte at\0Athe same position in to.\0A\0AThe bytes objects frm and to must be of the same length.\00", align 16
@.str.84 = private unnamed_addr constant [10 x i8] c"partition\00", align 1
@bytes_partition__doc__ = internal constant [395 x i8] c"partition($self, sep, /)\0A--\0A\0APartition the bytes into three parts using the given separator.\0A\0AThis will search for the separator sep in the bytes. If the separator is found,\0Areturns a 3-tuple containing the part before the separator, the separator\0Aitself, and the part after it.\0A\0AIf the separator is not found, returns a 3-tuple containing the original bytes\0Aobject and two empty bytes objects.\00", align 16
@bytes_replace__doc__ = internal constant [313 x i8] c"replace($self, old, new, count=-1, /)\0A--\0A\0AReturn a copy with all occurrences of substring old replaced by new.\0A\0A  count\0A    Maximum number of occurrences to replace.\0A    -1 (the default value) means replace all occurrences.\0A\0AIf the optional argument count is given, only the first count occurrences are\0Areplaced.\00", align 16
@.str.85 = private unnamed_addr constant [13 x i8] c"removeprefix\00", align 1
@bytes_removeprefix__doc__ = internal constant [227 x i8] c"removeprefix($self, prefix, /)\0A--\0A\0AReturn a bytes object with the given prefix string removed if present.\0A\0AIf the bytes starts with the prefix string, return bytes[len(prefix):].\0AOtherwise, return a copy of the original bytes.\00", align 16
@.str.86 = private unnamed_addr constant [13 x i8] c"removesuffix\00", align 1
@bytes_removesuffix__doc__ = internal constant [256 x i8] c"removesuffix($self, suffix, /)\0A--\0A\0AReturn a bytes object with the given suffix string removed if present.\0A\0AIf the bytes ends with the suffix string and that suffix is not empty,\0Areturn bytes[:-len(prefix)].  Otherwise, return a copy of the original\0Abytes.\00", align 16
@.str.87 = private unnamed_addr constant [6 x i8] c"rfind\00", align 1
@_Py_rfind__doc__ = external constant [0 x i8], align 1
@.str.88 = private unnamed_addr constant [7 x i8] c"rindex\00", align 1
@_Py_rindex__doc__ = external constant [0 x i8], align 1
@.str.89 = private unnamed_addr constant [6 x i8] c"rjust\00", align 1
@stringlib_rjust__doc__ = internal constant [144 x i8] c"rjust($self, width, fillchar=b' ', /)\0A--\0A\0AReturn a right-justified string of length width.\0A\0APadding is done using the specified fill character.\00", align 16
@.str.90 = private unnamed_addr constant [11 x i8] c"rpartition\00", align 1
@bytes_rpartition__doc__ = internal constant [417 x i8] c"rpartition($self, sep, /)\0A--\0A\0APartition the bytes into three parts using the given separator.\0A\0AThis will search for the separator sep in the bytes, starting at the end. If\0Athe separator is found, returns a 3-tuple containing the part before the\0Aseparator, the separator itself, and the part after it.\0A\0AIf the separator is not found, returns a 3-tuple containing two empty bytes\0Aobjects and the original bytes object.\00", align 16
@.str.91 = private unnamed_addr constant [7 x i8] c"rsplit\00", align 1
@bytes_rsplit__doc__ = internal constant [476 x i8] c"rsplit($self, /, sep=None, maxsplit=-1)\0A--\0A\0AReturn a list of the sections in the bytes, using sep as the delimiter.\0A\0A  sep\0A    The delimiter according which to split the bytes.\0A    None (the default value) means split on ASCII whitespace characters\0A    (space, tab, return, newline, formfeed, vertical tab).\0A  maxsplit\0A    Maximum number of splits to do.\0A    -1 (the default value) means no limit.\0A\0ASplitting is done starting at the end of the bytes and working to the front.\00", align 16
@.str.92 = private unnamed_addr constant [7 x i8] c"rstrip\00", align 1
@bytes_rstrip__doc__ = internal constant [151 x i8] c"rstrip($self, bytes=None, /)\0A--\0A\0AStrip trailing bytes contained in the argument.\0A\0AIf the argument is omitted or None, strip trailing ASCII whitespace.\00", align 16
@.str.93 = private unnamed_addr constant [6 x i8] c"split\00", align 1
@bytes_split__doc__ = internal constant [397 x i8] c"split($self, /, sep=None, maxsplit=-1)\0A--\0A\0AReturn a list of the sections in the bytes, using sep as the delimiter.\0A\0A  sep\0A    The delimiter according which to split the bytes.\0A    None (the default value) means split on ASCII whitespace characters\0A    (space, tab, return, newline, formfeed, vertical tab).\0A  maxsplit\0A    Maximum number of splits to do.\0A    -1 (the default value) means no limit.\00", align 16
@.str.94 = private unnamed_addr constant [11 x i8] c"splitlines\00", align 1
@bytes_splitlines__doc__ = internal constant [198 x i8] c"splitlines($self, /, keepends=False)\0A--\0A\0AReturn a list of the lines in the bytes, breaking at line boundaries.\0A\0ALine breaks are not included in the resulting list unless keepends is given and\0Atrue.\00", align 16
@.str.95 = private unnamed_addr constant [11 x i8] c"startswith\00", align 1
@_Py_startswith__doc__ = external constant [0 x i8], align 1
@.str.96 = private unnamed_addr constant [6 x i8] c"strip\00", align 1
@bytes_strip__doc__ = internal constant [174 x i8] c"strip($self, bytes=None, /)\0A--\0A\0AStrip leading and trailing bytes contained in the argument.\0A\0AIf the argument is omitted or None, strip leading and trailing ASCII whitespace.\00", align 16
@.str.97 = private unnamed_addr constant [9 x i8] c"swapcase\00", align 1
@_Py_swapcase__doc__ = external constant [0 x i8], align 1
@.str.98 = private unnamed_addr constant [6 x i8] c"title\00", align 1
@_Py_title__doc__ = external constant [0 x i8], align 1
@.str.99 = private unnamed_addr constant [10 x i8] c"translate\00", align 1
@bytes_translate__doc__ = internal constant [336 x i8] c"translate($self, table, /, delete=b'')\0A--\0A\0AReturn a copy with each character mapped by the given translation table.\0A\0A  table\0A    Translation table, which must be a bytes object of length 256.\0A\0AAll characters occurring in the optional argument delete are removed.\0AThe remaining characters are mapped through the given translation table.\00", align 16
@.str.100 = private unnamed_addr constant [6 x i8] c"upper\00", align 1
@_Py_upper__doc__ = external constant [0 x i8], align 1
@.str.101 = private unnamed_addr constant [6 x i8] c"zfill\00", align 1
@stringlib_zfill__doc__ = internal constant [149 x i8] c"zfill($self, width, /)\0A--\0A\0APad a numeric string with zeros on the left, to fill a field of the given width.\0A\0AThe original string is never truncated.\00", align 16
@.str.102 = private unnamed_addr constant [5 x i8] c"(y#)\00", align 1
@.str.103 = private unnamed_addr constant [11 x i8] c"argument 2\00", align 1
@.str.104 = private unnamed_addr constant [26 x i8] c"a byte string of length 1\00", align 1
@bytes_decode._kwtuple = internal global %struct.anon.770 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon.39 { i64 4294967295 }, ptr @PyTuple_Type }, i64 2 }, [2 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 44000), ptr getelementptr (i8, ptr @_PyRuntime, i64 44368)] }, align 8
@bytes_decode._keywords = internal constant [3 x ptr] [ptr @.str.105, ptr @.str.106, ptr null], align 16
@.str.105 = private unnamed_addr constant [9 x i8] c"encoding\00", align 1
@.str.106 = private unnamed_addr constant [7 x i8] c"errors\00", align 1
@bytes_decode._parser = internal global %struct._PyArg_Parser { ptr null, ptr @bytes_decode._keywords, ptr @.str.64, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @bytes_decode._kwtuple, i64 16), ptr null }, align 8
@.str.107 = private unnamed_addr constant [20 x i8] c"argument 'encoding'\00", align 1
@.str.108 = private unnamed_addr constant [4 x i8] c"str\00", align 1
@.str.109 = private unnamed_addr constant [24 x i8] c"embedded null character\00", align 1
@.str.110 = private unnamed_addr constant [18 x i8] c"argument 'errors'\00", align 1
@stringlib_expandtabs._kwtuple = internal global %struct.anon.771 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon.39 { i64 4294967295 }, ptr @PyTuple_Type }, i64 1 }, [1 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 59792)] }, align 8
@stringlib_expandtabs._keywords = internal constant [2 x ptr] [ptr @.str.111, ptr null], align 16
@.str.111 = private unnamed_addr constant [8 x i8] c"tabsize\00", align 1
@stringlib_expandtabs._parser = internal global %struct._PyArg_Parser { ptr null, ptr @stringlib_expandtabs._keywords, ptr @.str.66, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @stringlib_expandtabs._kwtuple, i64 16), ptr null }, align 8
@.str.112 = private unnamed_addr constant [16 x i8] c"result too long\00", align 1
@.str.113 = private unnamed_addr constant [9 x i8] c"argument\00", align 1
@bytes_hex._kwtuple = internal global %struct.anon.772 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon.39 { i64 4294967295 }, ptr @PyTuple_Type }, i64 2 }, [2 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 57640), ptr getelementptr (i8, ptr @_PyRuntime, i64 39408)] }, align 8
@bytes_hex._keywords = internal constant [3 x ptr] [ptr @.str.114, ptr @.str.115, ptr null], align 16
@.str.114 = private unnamed_addr constant [4 x i8] c"sep\00", align 1
@.str.115 = private unnamed_addr constant [14 x i8] c"bytes_per_sep\00", align 1
@bytes_hex._parser = internal global %struct._PyArg_Parser { ptr null, ptr @bytes_hex._keywords, ptr @.str.69, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @bytes_hex._kwtuple, i64 16), ptr null }, align 8
@_Py_NoneStruct = external global %struct._object, align 8
@.str.116 = private unnamed_addr constant [16 x i8] c"empty separator\00", align 1
@.str.117 = private unnamed_addr constant [26 x i8] c"replace bytes is too long\00", align 1
@bytes_rsplit._kwtuple = internal global %struct.anon.773 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon.39 { i64 4294967295 }, ptr @PyTuple_Type }, i64 2 }, [2 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 57640), ptr getelementptr (i8, ptr @_PyRuntime, i64 51312)] }, align 8
@bytes_rsplit._keywords = internal constant [3 x ptr] [ptr @.str.114, ptr @.str.118, ptr null], align 16
@.str.118 = private unnamed_addr constant [9 x i8] c"maxsplit\00", align 1
@bytes_rsplit._parser = internal global %struct._PyArg_Parser { ptr null, ptr @bytes_rsplit._keywords, ptr @.str.91, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @bytes_rsplit._kwtuple, i64 16), ptr null }, align 8
@bytes_split._kwtuple = internal global %struct.anon.774 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon.39 { i64 4294967295 }, ptr @PyTuple_Type }, i64 2 }, [2 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 57640), ptr getelementptr (i8, ptr @_PyRuntime, i64 51312)] }, align 8
@bytes_split._keywords = internal constant [3 x ptr] [ptr @.str.114, ptr @.str.118, ptr null], align 16
@bytes_split._parser = internal global %struct._PyArg_Parser { ptr null, ptr @bytes_split._keywords, ptr @.str.93, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @bytes_split._kwtuple, i64 16), ptr null }, align 8
@bytes_splitlines._kwtuple = internal global %struct.anon.775 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon.39 { i64 4294967295 }, ptr @PyTuple_Type }, i64 1 }, [1 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 49432)] }, align 8
@bytes_splitlines._keywords = internal constant [2 x ptr] [ptr @.str.119, ptr null], align 16
@.str.119 = private unnamed_addr constant [9 x i8] c"keepends\00", align 1
@bytes_splitlines._parser = internal global %struct._PyArg_Parser { ptr null, ptr @bytes_splitlines._keywords, ptr @.str.94, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @bytes_splitlines._kwtuple, i64 16), ptr null }, align 8
@bytes_translate._kwtuple = internal global %struct.anon.776 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon.39 { i64 4294967295 }, ptr @PyTuple_Type }, i64 1 }, [1 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 42688)] }, align 8
@bytes_translate._keywords = internal constant [3 x ptr] [ptr @.str.54, ptr @.str.120, ptr null], align 16
@.str.120 = private unnamed_addr constant [7 x i8] c"delete\00", align 1
@bytes_translate._parser = internal global %struct._PyArg_Parser { ptr null, ptr @bytes_translate._keywords, ptr @.str.99, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @bytes_translate._kwtuple, i64 16), ptr null }, align 8
@.str.121 = private unnamed_addr constant [46 x i8] c"translation table must be 256 characters long\00", align 1
@bytes_new._kwtuple = internal global %struct.anon.777 { %struct.PyGC_Head zeroinitializer, %struct.PyVarObject { %struct._object { %union.anon.39 { i64 4294967295 }, ptr @PyTuple_Type }, i64 3 }, [3 x ptr] [ptr getelementptr (i8, ptr @_PyRuntime, i64 58688), ptr getelementptr (i8, ptr @_PyRuntime, i64 44000), ptr getelementptr (i8, ptr @_PyRuntime, i64 44368)] }, align 8
@bytes_new._keywords = internal constant [4 x ptr] [ptr @.str.122, ptr @.str.105, ptr @.str.106, ptr null], align 16
@.str.122 = private unnamed_addr constant [7 x i8] c"source\00", align 1
@bytes_new._parser = internal global %struct._PyArg_Parser { ptr null, ptr @bytes_new._keywords, ptr @.str.34, ptr null, %struct._PyOnceFlag zeroinitializer, i32 0, i32 0, i32 0, i32 0, ptr getelementptr (i8, ptr @bytes_new._kwtuple, i64 16), ptr null }, align 8
@.str.123 = private unnamed_addr constant [35 x i8] c"encoding without a string argument\00", align 1
@.str.124 = private unnamed_addr constant [33 x i8] c"errors without a string argument\00", align 1
@.str.125 = private unnamed_addr constant [36 x i8] c"string argument without an encoding\00", align 1
@.str.126 = private unnamed_addr constant [15 x i8] c"negative count\00", align 1
@.str.127 = private unnamed_addr constant [16 x i8] c"__length_hint__\00", align 1
@length_hint_doc = internal constant [55 x i8] c"Private method returning an estimate of len(list(it)).\00", align 16
@.str.128 = private unnamed_addr constant [11 x i8] c"__reduce__\00", align 1
@reduce_doc = internal constant [39 x i8] c"Return state information for pickling.\00", align 16
@.str.129 = private unnamed_addr constant [13 x i8] c"__setstate__\00", align 1
@setstate_doc = internal constant [38 x i8] c"Set state information for unpickling.\00", align 16
@.str.130 = private unnamed_addr constant [6 x i8] c"N(O)n\00", align 1
@.str.131 = private unnamed_addr constant [6 x i8] c"N(())\00", align 1
@_PyByteArray_empty_string = external global [0 x i8], align 1

; Function Attrs: nounwind uwtable
define dso_local ptr @PyBytes_FromStringAndSize(ptr noundef %str, i64 noundef %size) #0 {
entry:
  %retval = alloca ptr, align 8
  %str.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %op = alloca ptr, align 8
  store ptr %str, ptr %str.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load i64, ptr %size.addr, align 8
  %cmp = icmp slt i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr @PyExc_SystemError, align 8
  call void @PyErr_SetString(ptr noundef %1, ptr noundef @.str)
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i64, ptr %size.addr, align 8
  %cmp1 = icmp eq i64 %2, 1
  br i1 %cmp1, label %land.lhs.true, label %if.end4

land.lhs.true:                                    ; preds = %if.end
  %3 = load ptr, ptr %str.addr, align 8
  %cmp2 = icmp ne ptr %3, null
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %land.lhs.true
  %4 = load ptr, ptr %str.addr, align 8
  %5 = load i8, ptr %4, align 1
  %conv = sext i8 %5 to i32
  %and = and i32 %conv, 255
  %idxprom = sext i32 %and to i64
  %arrayidx = getelementptr [256 x %struct.anon.40], ptr getelementptr inbounds (%struct.anon.38, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 37), i32 0, i32 2), i64 0, i64 %idxprom
  store ptr %arrayidx, ptr %op, align 8
  %6 = load ptr, ptr %op, align 8
  store ptr %6, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %land.lhs.true, %if.end
  %7 = load i64, ptr %size.addr, align 8
  %cmp5 = icmp eq i64 %7, 0
  br i1 %cmp5, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end4
  %call = call ptr @bytes_get_empty()
  store ptr %call, ptr %retval, align 8
  br label %return

if.end8:                                          ; preds = %if.end4
  %8 = load i64, ptr %size.addr, align 8
  %call9 = call ptr @_PyBytes_FromSize(i64 noundef %8, i32 noundef 0)
  store ptr %call9, ptr %op, align 8
  %9 = load ptr, ptr %op, align 8
  %cmp10 = icmp eq ptr %9, null
  br i1 %cmp10, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end8
  store ptr null, ptr %retval, align 8
  br label %return

if.end13:                                         ; preds = %if.end8
  %10 = load ptr, ptr %str.addr, align 8
  %cmp14 = icmp eq ptr %10, null
  br i1 %cmp14, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.end13
  %11 = load ptr, ptr %op, align 8
  store ptr %11, ptr %retval, align 8
  br label %return

if.end17:                                         ; preds = %if.end13
  %12 = load ptr, ptr %op, align 8
  %ob_sval = getelementptr inbounds %struct.PyBytesObject, ptr %12, i32 0, i32 2
  %arraydecay = getelementptr inbounds [1 x i8], ptr %ob_sval, i64 0, i64 0
  %13 = load ptr, ptr %str.addr, align 8
  %14 = load i64, ptr %size.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arraydecay, ptr align 1 %13, i64 %14, i1 false)
  %15 = load ptr, ptr %op, align 8
  store ptr %15, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end17, %if.then16, %if.then12, %if.then7, %if.then3, %if.then
  %16 = load ptr, ptr %retval, align 8
  ret ptr %16
}

declare void @PyErr_SetString(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @bytes_get_empty() #0 {
entry:
  %empty = alloca ptr, align 8
  store ptr getelementptr inbounds (%struct.anon.38, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 37), i32 0, i32 1), ptr %empty, align 8
  %0 = load ptr, ptr %empty, align 8
  ret ptr %0
}

; Function Attrs: nounwind uwtable
define internal ptr @_PyBytes_FromSize(i64 noundef %size, i32 noundef %use_calloc) #0 {
entry:
  %retval = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %use_calloc.addr = alloca i32, align 4
  %op = alloca ptr, align 8
  store i64 %size, ptr %size.addr, align 8
  store i32 %use_calloc, ptr %use_calloc.addr, align 4
  %0 = load i64, ptr %size.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call ptr @bytes_get_empty()
  store ptr %call, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, ptr %size.addr, align 8
  %cmp1 = icmp ugt i64 %1, 9223372036854775774
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %2 = load ptr, ptr @PyExc_OverflowError, align 8
  call void @PyErr_SetString(ptr noundef %2, ptr noundef @.str.37)
  store ptr null, ptr %retval, align 8
  br label %return

if.end3:                                          ; preds = %if.end
  %3 = load i32, ptr %use_calloc.addr, align 4
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.end3
  %4 = load i64, ptr %size.addr, align 8
  %add = add i64 33, %4
  %call5 = call ptr @PyObject_Calloc(i64 noundef 1, i64 noundef %add)
  store ptr %call5, ptr %op, align 8
  br label %if.end8

if.else:                                          ; preds = %if.end3
  %5 = load i64, ptr %size.addr, align 8
  %add6 = add i64 33, %5
  %call7 = call ptr @PyObject_Malloc(i64 noundef %add6)
  store ptr %call7, ptr %op, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.else, %if.then4
  %6 = load ptr, ptr %op, align 8
  %cmp9 = icmp eq ptr %6, null
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %if.end8
  %call11 = call ptr @PyErr_NoMemory()
  store ptr %call11, ptr %retval, align 8
  br label %return

if.end12:                                         ; preds = %if.end8
  %7 = load ptr, ptr %op, align 8
  %8 = load i64, ptr %size.addr, align 8
  call void @_PyObject_InitVar(ptr noundef %7, ptr noundef @PyBytes_Type, i64 noundef %8)
  %9 = load ptr, ptr %op, align 8
  %ob_shash = getelementptr inbounds %struct.PyBytesObject, ptr %9, i32 0, i32 1
  store i64 -1, ptr %ob_shash, align 8
  %10 = load i32, ptr %use_calloc.addr, align 4
  %tobool13 = icmp ne i32 %10, 0
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end12
  %11 = load ptr, ptr %op, align 8
  %ob_sval = getelementptr inbounds %struct.PyBytesObject, ptr %11, i32 0, i32 2
  %12 = load i64, ptr %size.addr, align 8
  %arrayidx = getelementptr [1 x i8], ptr %ob_sval, i64 0, i64 %12
  store i8 0, ptr %arrayidx, align 1
  br label %if.end15

if.end15:                                         ; preds = %if.then14, %if.end12
  %13 = load ptr, ptr %op, align 8
  store ptr %13, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end15, %if.then10, %if.then2, %if.then
  %14 = load ptr, ptr %retval, align 8
  ret ptr %14
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #2

; Function Attrs: nounwind uwtable
define dso_local ptr @PyBytes_FromString(ptr noundef %str) #0 {
entry:
  %retval = alloca ptr, align 8
  %str.addr = alloca ptr, align 8
  %size = alloca i64, align 8
  %op = alloca ptr, align 8
  store ptr %str, ptr %str.addr, align 8
  %0 = load ptr, ptr %str.addr, align 8
  %call = call i64 @strlen(ptr noundef %0) #8
  store i64 %call, ptr %size, align 8
  %1 = load i64, ptr %size, align 8
  %cmp = icmp ugt i64 %1, 9223372036854775774
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr @PyExc_OverflowError, align 8
  call void @PyErr_SetString(ptr noundef %2, ptr noundef @.str.1)
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load i64, ptr %size, align 8
  %cmp1 = icmp eq i64 %3, 0
  br i1 %cmp1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.end
  %call3 = call ptr @bytes_get_empty()
  store ptr %call3, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %if.end
  %4 = load i64, ptr %size, align 8
  %cmp4 = icmp eq i64 %4, 1
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.else
  %5 = load ptr, ptr %str.addr, align 8
  %6 = load i8, ptr %5, align 1
  %conv = sext i8 %6 to i32
  %and = and i32 %conv, 255
  %idxprom = sext i32 %and to i64
  %arrayidx = getelementptr [256 x %struct.anon.40], ptr getelementptr inbounds (%struct.anon.38, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 37), i32 0, i32 2), i64 0, i64 %idxprom
  store ptr %arrayidx, ptr %op, align 8
  %7 = load ptr, ptr %op, align 8
  store ptr %7, ptr %retval, align 8
  br label %return

if.end6:                                          ; preds = %if.else
  br label %if.end7

if.end7:                                          ; preds = %if.end6
  %8 = load i64, ptr %size, align 8
  %add = add i64 33, %8
  %call8 = call ptr @PyObject_Malloc(i64 noundef %add)
  store ptr %call8, ptr %op, align 8
  %9 = load ptr, ptr %op, align 8
  %cmp9 = icmp eq ptr %9, null
  br i1 %cmp9, label %if.then11, label %if.end13

if.then11:                                        ; preds = %if.end7
  %call12 = call ptr @PyErr_NoMemory()
  store ptr %call12, ptr %retval, align 8
  br label %return

if.end13:                                         ; preds = %if.end7
  %10 = load ptr, ptr %op, align 8
  %11 = load i64, ptr %size, align 8
  call void @_PyObject_InitVar(ptr noundef %10, ptr noundef @PyBytes_Type, i64 noundef %11)
  %12 = load ptr, ptr %op, align 8
  %ob_shash = getelementptr inbounds %struct.PyBytesObject, ptr %12, i32 0, i32 1
  store i64 -1, ptr %ob_shash, align 8
  %13 = load ptr, ptr %op, align 8
  %ob_sval = getelementptr inbounds %struct.PyBytesObject, ptr %13, i32 0, i32 2
  %arraydecay = getelementptr inbounds [1 x i8], ptr %ob_sval, i64 0, i64 0
  %14 = load ptr, ptr %str.addr, align 8
  %15 = load i64, ptr %size, align 8
  %add14 = add i64 %15, 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arraydecay, ptr align 1 %14, i64 %add14, i1 false)
  %16 = load ptr, ptr %op, align 8
  store ptr %16, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end13, %if.then11, %if.then5, %if.then2, %if.then
  %17 = load ptr, ptr %retval, align 8
  ret ptr %17
}

; Function Attrs: nounwind willreturn memory(read)
declare i64 @strlen(ptr noundef) #3

declare ptr @PyObject_Malloc(i64 noundef) #1

declare ptr @PyErr_NoMemory() #1

; Function Attrs: nounwind uwtable
define internal void @_PyObject_InitVar(ptr noundef %op, ptr noundef %typeobj, i64 noundef %size) #0 {
entry:
  %op.addr = alloca ptr, align 8
  %typeobj.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  store ptr %op, ptr %op.addr, align 8
  store ptr %typeobj, ptr %typeobj.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load ptr, ptr %op.addr, align 8
  %1 = load ptr, ptr %typeobj.addr, align 8
  call void @_PyObject_Init(ptr noundef %0, ptr noundef %1)
  %2 = load ptr, ptr %op.addr, align 8
  %3 = load i64, ptr %size.addr, align 8
  call void @Py_SET_SIZE(ptr noundef %2, i64 noundef %3)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local ptr @PyBytes_FromFormatV(ptr noundef %format, ptr noundef %vargs) #0 {
entry:
  %retval = alloca ptr, align 8
  %format.addr = alloca ptr, align 8
  %vargs.addr = alloca ptr, align 8
  %s = alloca ptr, align 8
  %f = alloca ptr, align 8
  %p = alloca ptr, align 8
  %prec = alloca i64, align 8
  %longflag = alloca i32, align 4
  %size_tflag = alloca i32, align 4
  %buffer = alloca [21 x i8], align 16
  %writer = alloca %struct._PyBytesWriter, align 8
  %c = alloca i32, align 4
  %i = alloca i64, align 8
  store ptr %format, ptr %format.addr, align 8
  store ptr %vargs, ptr %vargs.addr, align 8
  call void @_PyBytesWriter_Init(ptr noundef %writer)
  %0 = load ptr, ptr %format.addr, align 8
  %call = call i64 @strlen(ptr noundef %0) #8
  %call1 = call ptr @_PyBytesWriter_Alloc(ptr noundef %writer, i64 noundef %call)
  store ptr %call1, ptr %s, align 8
  %1 = load ptr, ptr %s, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %overallocate = getelementptr inbounds %struct._PyBytesWriter, ptr %writer, i32 0, i32 4
  store i32 1, ptr %overallocate, align 4
  %2 = load ptr, ptr %format.addr, align 8
  store ptr %2, ptr %f, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc349, %if.end
  %3 = load ptr, ptr %f, align 8
  %4 = load i8, ptr %3, align 1
  %tobool = icmp ne i8 %4, 0
  br i1 %tobool, label %for.body, label %for.end351

for.body:                                         ; preds = %for.cond
  %5 = load ptr, ptr %f, align 8
  %6 = load i8, ptr %5, align 1
  %conv = sext i8 %6 to i32
  %cmp2 = icmp ne i32 %conv, 37
  br i1 %cmp2, label %if.then4, label %if.end5

if.then4:                                         ; preds = %for.body
  %7 = load ptr, ptr %f, align 8
  %8 = load i8, ptr %7, align 1
  %9 = load ptr, ptr %s, align 8
  %incdec.ptr = getelementptr i8, ptr %9, i32 1
  store ptr %incdec.ptr, ptr %s, align 8
  store i8 %8, ptr %9, align 1
  br label %for.inc349

if.end5:                                          ; preds = %for.body
  %10 = load ptr, ptr %f, align 8
  %incdec.ptr6 = getelementptr i8, ptr %10, i32 1
  store ptr %incdec.ptr6, ptr %f, align 8
  store ptr %10, ptr %p, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end5
  %11 = load ptr, ptr %f, align 8
  %12 = load i8, ptr %11, align 1
  %conv7 = sext i8 %12 to i32
  %and = and i32 %conv7, 255
  %conv8 = trunc i32 %and to i8
  %idxprom = zext i8 %conv8 to i64
  %arrayidx = getelementptr [256 x i32], ptr @_Py_ctype_table, i64 0, i64 %idxprom
  %13 = load i32, ptr %arrayidx, align 4
  %and9 = and i32 %13, 4
  %tobool10 = icmp ne i32 %and9, 0
  br i1 %tobool10, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %14 = load ptr, ptr %f, align 8
  %incdec.ptr11 = getelementptr i8, ptr %14, i32 1
  store ptr %incdec.ptr11, ptr %f, align 8
  br label %while.cond, !llvm.loop !5

while.end:                                        ; preds = %while.cond
  store i64 0, ptr %prec, align 8
  %15 = load ptr, ptr %f, align 8
  %16 = load i8, ptr %15, align 1
  %conv12 = sext i8 %16 to i32
  %cmp13 = icmp eq i32 %conv12, 46
  br i1 %cmp13, label %if.then15, label %if.end29

if.then15:                                        ; preds = %while.end
  %17 = load ptr, ptr %f, align 8
  %incdec.ptr16 = getelementptr i8, ptr %17, i32 1
  store ptr %incdec.ptr16, ptr %f, align 8
  br label %for.cond17

for.cond17:                                       ; preds = %for.inc, %if.then15
  %18 = load ptr, ptr %f, align 8
  %19 = load i8, ptr %18, align 1
  %conv18 = sext i8 %19 to i32
  %and19 = and i32 %conv18, 255
  %conv20 = trunc i32 %and19 to i8
  %idxprom21 = zext i8 %conv20 to i64
  %arrayidx22 = getelementptr [256 x i32], ptr @_Py_ctype_table, i64 0, i64 %idxprom21
  %20 = load i32, ptr %arrayidx22, align 4
  %and23 = and i32 %20, 4
  %tobool24 = icmp ne i32 %and23, 0
  br i1 %tobool24, label %for.body25, label %for.end

for.body25:                                       ; preds = %for.cond17
  %21 = load i64, ptr %prec, align 8
  %mul = mul i64 %21, 10
  %22 = load ptr, ptr %f, align 8
  %23 = load i8, ptr %22, align 1
  %conv26 = sext i8 %23 to i32
  %sub = sub i32 %conv26, 48
  %conv27 = sext i32 %sub to i64
  %add = add i64 %mul, %conv27
  store i64 %add, ptr %prec, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body25
  %24 = load ptr, ptr %f, align 8
  %incdec.ptr28 = getelementptr i8, ptr %24, i32 1
  store ptr %incdec.ptr28, ptr %f, align 8
  br label %for.cond17, !llvm.loop !7

for.end:                                          ; preds = %for.cond17
  br label %if.end29

if.end29:                                         ; preds = %for.end, %while.end
  br label %while.cond30

while.cond30:                                     ; preds = %while.body43, %if.end29
  %25 = load ptr, ptr %f, align 8
  %26 = load i8, ptr %25, align 1
  %conv31 = sext i8 %26 to i32
  %tobool32 = icmp ne i32 %conv31, 0
  br i1 %tobool32, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %while.cond30
  %27 = load ptr, ptr %f, align 8
  %28 = load i8, ptr %27, align 1
  %conv33 = sext i8 %28 to i32
  %cmp34 = icmp ne i32 %conv33, 37
  br i1 %cmp34, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %29 = load ptr, ptr %f, align 8
  %30 = load i8, ptr %29, align 1
  %conv36 = sext i8 %30 to i32
  %and37 = and i32 %conv36, 255
  %conv38 = trunc i32 %and37 to i8
  %idxprom39 = zext i8 %conv38 to i64
  %arrayidx40 = getelementptr [256 x i32], ptr @_Py_ctype_table, i64 0, i64 %idxprom39
  %31 = load i32, ptr %arrayidx40, align 4
  %and41 = and i32 %31, 3
  %tobool42 = icmp ne i32 %and41, 0
  %lnot = xor i1 %tobool42, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %while.cond30
  %32 = phi i1 [ false, %land.lhs.true ], [ false, %while.cond30 ], [ %lnot, %land.rhs ]
  br i1 %32, label %while.body43, label %while.end45

while.body43:                                     ; preds = %land.end
  %33 = load ptr, ptr %f, align 8
  %incdec.ptr44 = getelementptr i8, ptr %33, i32 1
  store ptr %incdec.ptr44, ptr %f, align 8
  br label %while.cond30, !llvm.loop !8

while.end45:                                      ; preds = %land.end
  store i32 0, ptr %longflag, align 4
  %34 = load ptr, ptr %f, align 8
  %35 = load i8, ptr %34, align 1
  %conv46 = sext i8 %35 to i32
  %cmp47 = icmp eq i32 %conv46, 108
  br i1 %cmp47, label %land.lhs.true49, label %if.end60

land.lhs.true49:                                  ; preds = %while.end45
  %36 = load ptr, ptr %f, align 8
  %arrayidx50 = getelementptr i8, ptr %36, i64 1
  %37 = load i8, ptr %arrayidx50, align 1
  %conv51 = sext i8 %37 to i32
  %cmp52 = icmp eq i32 %conv51, 100
  br i1 %cmp52, label %if.then58, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true49
  %38 = load ptr, ptr %f, align 8
  %arrayidx54 = getelementptr i8, ptr %38, i64 1
  %39 = load i8, ptr %arrayidx54, align 1
  %conv55 = sext i8 %39 to i32
  %cmp56 = icmp eq i32 %conv55, 117
  br i1 %cmp56, label %if.then58, label %if.end60

if.then58:                                        ; preds = %lor.lhs.false, %land.lhs.true49
  store i32 1, ptr %longflag, align 4
  %40 = load ptr, ptr %f, align 8
  %incdec.ptr59 = getelementptr i8, ptr %40, i32 1
  store ptr %incdec.ptr59, ptr %f, align 8
  br label %if.end60

if.end60:                                         ; preds = %if.then58, %lor.lhs.false, %while.end45
  store i32 0, ptr %size_tflag, align 4
  %41 = load ptr, ptr %f, align 8
  %42 = load i8, ptr %41, align 1
  %conv61 = sext i8 %42 to i32
  %cmp62 = icmp eq i32 %conv61, 122
  br i1 %cmp62, label %land.lhs.true64, label %if.end76

land.lhs.true64:                                  ; preds = %if.end60
  %43 = load ptr, ptr %f, align 8
  %arrayidx65 = getelementptr i8, ptr %43, i64 1
  %44 = load i8, ptr %arrayidx65, align 1
  %conv66 = sext i8 %44 to i32
  %cmp67 = icmp eq i32 %conv66, 100
  br i1 %cmp67, label %if.then74, label %lor.lhs.false69

lor.lhs.false69:                                  ; preds = %land.lhs.true64
  %45 = load ptr, ptr %f, align 8
  %arrayidx70 = getelementptr i8, ptr %45, i64 1
  %46 = load i8, ptr %arrayidx70, align 1
  %conv71 = sext i8 %46 to i32
  %cmp72 = icmp eq i32 %conv71, 117
  br i1 %cmp72, label %if.then74, label %if.end76

if.then74:                                        ; preds = %lor.lhs.false69, %land.lhs.true64
  store i32 1, ptr %size_tflag, align 4
  %47 = load ptr, ptr %f, align 8
  %incdec.ptr75 = getelementptr i8, ptr %47, i32 1
  store ptr %incdec.ptr75, ptr %f, align 8
  br label %if.end76

if.end76:                                         ; preds = %if.then74, %lor.lhs.false69, %if.end60
  %48 = load ptr, ptr %f, align 8
  %49 = load ptr, ptr %p, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %48 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %49 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %add77 = add i64 %sub.ptr.sub, 1
  %min_size = getelementptr inbounds %struct._PyBytesWriter, ptr %writer, i32 0, i32 2
  %50 = load i64, ptr %min_size, align 8
  %sub78 = sub i64 %50, %add77
  store i64 %sub78, ptr %min_size, align 8
  %51 = load ptr, ptr %f, align 8
  %52 = load i8, ptr %51, align 1
  %conv79 = sext i8 %52 to i32
  switch i32 %conv79, label %sw.default [
    i32 99, label %sw.bb
    i32 100, label %sw.bb90
    i32 117, label %sw.bb144
    i32 105, label %sw.bb202
    i32 120, label %sw.bb226
    i32 115, label %sw.bb250
    i32 112, label %sw.bb284
    i32 37, label %sw.bb329
  ]

sw.bb:                                            ; preds = %if.end76
  %53 = load ptr, ptr %vargs.addr, align 8
  %gp_offset_p = getelementptr inbounds %struct.__va_list_tag, ptr %53, i32 0, i32 0
  %gp_offset = load i32, ptr %gp_offset_p, align 8
  %fits_in_gp = icmp ule i32 %gp_offset, 40
  br i1 %fits_in_gp, label %vaarg.in_reg, label %vaarg.in_mem

vaarg.in_reg:                                     ; preds = %sw.bb
  %54 = getelementptr inbounds %struct.__va_list_tag, ptr %53, i32 0, i32 3
  %reg_save_area = load ptr, ptr %54, align 8
  %55 = getelementptr i8, ptr %reg_save_area, i32 %gp_offset
  %56 = add i32 %gp_offset, 8
  store i32 %56, ptr %gp_offset_p, align 8
  br label %vaarg.end

vaarg.in_mem:                                     ; preds = %sw.bb
  %overflow_arg_area_p = getelementptr inbounds %struct.__va_list_tag, ptr %53, i32 0, i32 2
  %overflow_arg_area = load ptr, ptr %overflow_arg_area_p, align 8
  %overflow_arg_area.next = getelementptr i8, ptr %overflow_arg_area, i32 8
  store ptr %overflow_arg_area.next, ptr %overflow_arg_area_p, align 8
  br label %vaarg.end

vaarg.end:                                        ; preds = %vaarg.in_mem, %vaarg.in_reg
  %vaarg.addr = phi ptr [ %55, %vaarg.in_reg ], [ %overflow_arg_area, %vaarg.in_mem ]
  %57 = load i32, ptr %vaarg.addr, align 4
  store i32 %57, ptr %c, align 4
  %58 = load i32, ptr %c, align 4
  %cmp80 = icmp slt i32 %58, 0
  br i1 %cmp80, label %if.then85, label %lor.lhs.false82

lor.lhs.false82:                                  ; preds = %vaarg.end
  %59 = load i32, ptr %c, align 4
  %cmp83 = icmp sgt i32 %59, 255
  br i1 %cmp83, label %if.then85, label %if.end86

if.then85:                                        ; preds = %lor.lhs.false82, %vaarg.end
  %60 = load ptr, ptr @PyExc_OverflowError, align 8
  call void @PyErr_SetString(ptr noundef %60, ptr noundef @.str.2)
  br label %error

if.end86:                                         ; preds = %lor.lhs.false82
  %min_size87 = getelementptr inbounds %struct._PyBytesWriter, ptr %writer, i32 0, i32 2
  %61 = load i64, ptr %min_size87, align 8
  %inc = add i64 %61, 1
  store i64 %inc, ptr %min_size87, align 8
  %62 = load i32, ptr %c, align 4
  %conv88 = trunc i32 %62 to i8
  %63 = load ptr, ptr %s, align 8
  %incdec.ptr89 = getelementptr i8, ptr %63, i32 1
  store ptr %incdec.ptr89, ptr %s, align 8
  store i8 %conv88, ptr %63, align 1
  br label %sw.epilog

sw.bb90:                                          ; preds = %if.end76
  %64 = load i32, ptr %longflag, align 4
  %tobool91 = icmp ne i32 %64, 0
  br i1 %tobool91, label %if.then92, label %if.else

if.then92:                                        ; preds = %sw.bb90
  %arraydecay = getelementptr inbounds [21 x i8], ptr %buffer, i64 0, i64 0
  %65 = load ptr, ptr %vargs.addr, align 8
  %gp_offset_p93 = getelementptr inbounds %struct.__va_list_tag, ptr %65, i32 0, i32 0
  %gp_offset94 = load i32, ptr %gp_offset_p93, align 8
  %fits_in_gp95 = icmp ule i32 %gp_offset94, 40
  br i1 %fits_in_gp95, label %vaarg.in_reg96, label %vaarg.in_mem98

vaarg.in_reg96:                                   ; preds = %if.then92
  %66 = getelementptr inbounds %struct.__va_list_tag, ptr %65, i32 0, i32 3
  %reg_save_area97 = load ptr, ptr %66, align 8
  %67 = getelementptr i8, ptr %reg_save_area97, i32 %gp_offset94
  %68 = add i32 %gp_offset94, 8
  store i32 %68, ptr %gp_offset_p93, align 8
  br label %vaarg.end102

vaarg.in_mem98:                                   ; preds = %if.then92
  %overflow_arg_area_p99 = getelementptr inbounds %struct.__va_list_tag, ptr %65, i32 0, i32 2
  %overflow_arg_area100 = load ptr, ptr %overflow_arg_area_p99, align 8
  %overflow_arg_area.next101 = getelementptr i8, ptr %overflow_arg_area100, i32 8
  store ptr %overflow_arg_area.next101, ptr %overflow_arg_area_p99, align 8
  br label %vaarg.end102

vaarg.end102:                                     ; preds = %vaarg.in_mem98, %vaarg.in_reg96
  %vaarg.addr103 = phi ptr [ %67, %vaarg.in_reg96 ], [ %overflow_arg_area100, %vaarg.in_mem98 ]
  %69 = load i64, ptr %vaarg.addr103, align 8
  %call104 = call i32 (ptr, ptr, ...) @sprintf(ptr noundef %arraydecay, ptr noundef @.str.3, i64 noundef %69) #9
  br label %if.end135

if.else:                                          ; preds = %sw.bb90
  %70 = load i32, ptr %size_tflag, align 4
  %tobool105 = icmp ne i32 %70, 0
  br i1 %tobool105, label %if.then106, label %if.else120

if.then106:                                       ; preds = %if.else
  %arraydecay107 = getelementptr inbounds [21 x i8], ptr %buffer, i64 0, i64 0
  %71 = load ptr, ptr %vargs.addr, align 8
  %gp_offset_p108 = getelementptr inbounds %struct.__va_list_tag, ptr %71, i32 0, i32 0
  %gp_offset109 = load i32, ptr %gp_offset_p108, align 8
  %fits_in_gp110 = icmp ule i32 %gp_offset109, 40
  br i1 %fits_in_gp110, label %vaarg.in_reg111, label %vaarg.in_mem113

vaarg.in_reg111:                                  ; preds = %if.then106
  %72 = getelementptr inbounds %struct.__va_list_tag, ptr %71, i32 0, i32 3
  %reg_save_area112 = load ptr, ptr %72, align 8
  %73 = getelementptr i8, ptr %reg_save_area112, i32 %gp_offset109
  %74 = add i32 %gp_offset109, 8
  store i32 %74, ptr %gp_offset_p108, align 8
  br label %vaarg.end117

vaarg.in_mem113:                                  ; preds = %if.then106
  %overflow_arg_area_p114 = getelementptr inbounds %struct.__va_list_tag, ptr %71, i32 0, i32 2
  %overflow_arg_area115 = load ptr, ptr %overflow_arg_area_p114, align 8
  %overflow_arg_area.next116 = getelementptr i8, ptr %overflow_arg_area115, i32 8
  store ptr %overflow_arg_area.next116, ptr %overflow_arg_area_p114, align 8
  br label %vaarg.end117

vaarg.end117:                                     ; preds = %vaarg.in_mem113, %vaarg.in_reg111
  %vaarg.addr118 = phi ptr [ %73, %vaarg.in_reg111 ], [ %overflow_arg_area115, %vaarg.in_mem113 ]
  %75 = load i64, ptr %vaarg.addr118, align 8
  %call119 = call i32 (ptr, ptr, ...) @sprintf(ptr noundef %arraydecay107, ptr noundef @.str.4, i64 noundef %75) #9
  br label %if.end134

if.else120:                                       ; preds = %if.else
  %arraydecay121 = getelementptr inbounds [21 x i8], ptr %buffer, i64 0, i64 0
  %76 = load ptr, ptr %vargs.addr, align 8
  %gp_offset_p122 = getelementptr inbounds %struct.__va_list_tag, ptr %76, i32 0, i32 0
  %gp_offset123 = load i32, ptr %gp_offset_p122, align 8
  %fits_in_gp124 = icmp ule i32 %gp_offset123, 40
  br i1 %fits_in_gp124, label %vaarg.in_reg125, label %vaarg.in_mem127

vaarg.in_reg125:                                  ; preds = %if.else120
  %77 = getelementptr inbounds %struct.__va_list_tag, ptr %76, i32 0, i32 3
  %reg_save_area126 = load ptr, ptr %77, align 8
  %78 = getelementptr i8, ptr %reg_save_area126, i32 %gp_offset123
  %79 = add i32 %gp_offset123, 8
  store i32 %79, ptr %gp_offset_p122, align 8
  br label %vaarg.end131

vaarg.in_mem127:                                  ; preds = %if.else120
  %overflow_arg_area_p128 = getelementptr inbounds %struct.__va_list_tag, ptr %76, i32 0, i32 2
  %overflow_arg_area129 = load ptr, ptr %overflow_arg_area_p128, align 8
  %overflow_arg_area.next130 = getelementptr i8, ptr %overflow_arg_area129, i32 8
  store ptr %overflow_arg_area.next130, ptr %overflow_arg_area_p128, align 8
  br label %vaarg.end131

vaarg.end131:                                     ; preds = %vaarg.in_mem127, %vaarg.in_reg125
  %vaarg.addr132 = phi ptr [ %78, %vaarg.in_reg125 ], [ %overflow_arg_area129, %vaarg.in_mem127 ]
  %80 = load i32, ptr %vaarg.addr132, align 4
  %call133 = call i32 (ptr, ptr, ...) @sprintf(ptr noundef %arraydecay121, ptr noundef @.str.5, i32 noundef %80) #9
  br label %if.end134

if.end134:                                        ; preds = %vaarg.end131, %vaarg.end117
  br label %if.end135

if.end135:                                        ; preds = %if.end134, %vaarg.end102
  br label %do.body

do.body:                                          ; preds = %if.end135
  %81 = load ptr, ptr %s, align 8
  %arraydecay136 = getelementptr inbounds [21 x i8], ptr %buffer, i64 0, i64 0
  %arraydecay137 = getelementptr inbounds [21 x i8], ptr %buffer, i64 0, i64 0
  %call138 = call i64 @strlen(ptr noundef %arraydecay137) #8
  %call139 = call ptr @_PyBytesWriter_WriteBytes(ptr noundef %writer, ptr noundef %81, ptr noundef %arraydecay136, i64 noundef %call138)
  store ptr %call139, ptr %s, align 8
  %82 = load ptr, ptr %s, align 8
  %cmp140 = icmp eq ptr %82, null
  br i1 %cmp140, label %if.then142, label %if.end143

if.then142:                                       ; preds = %do.body
  br label %error

if.end143:                                        ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end143
  br label %sw.epilog

sw.bb144:                                         ; preds = %if.end76
  %83 = load i32, ptr %longflag, align 4
  %tobool145 = icmp ne i32 %83, 0
  br i1 %tobool145, label %if.then146, label %if.else160

if.then146:                                       ; preds = %sw.bb144
  %arraydecay147 = getelementptr inbounds [21 x i8], ptr %buffer, i64 0, i64 0
  %84 = load ptr, ptr %vargs.addr, align 8
  %gp_offset_p148 = getelementptr inbounds %struct.__va_list_tag, ptr %84, i32 0, i32 0
  %gp_offset149 = load i32, ptr %gp_offset_p148, align 8
  %fits_in_gp150 = icmp ule i32 %gp_offset149, 40
  br i1 %fits_in_gp150, label %vaarg.in_reg151, label %vaarg.in_mem153

vaarg.in_reg151:                                  ; preds = %if.then146
  %85 = getelementptr inbounds %struct.__va_list_tag, ptr %84, i32 0, i32 3
  %reg_save_area152 = load ptr, ptr %85, align 8
  %86 = getelementptr i8, ptr %reg_save_area152, i32 %gp_offset149
  %87 = add i32 %gp_offset149, 8
  store i32 %87, ptr %gp_offset_p148, align 8
  br label %vaarg.end157

vaarg.in_mem153:                                  ; preds = %if.then146
  %overflow_arg_area_p154 = getelementptr inbounds %struct.__va_list_tag, ptr %84, i32 0, i32 2
  %overflow_arg_area155 = load ptr, ptr %overflow_arg_area_p154, align 8
  %overflow_arg_area.next156 = getelementptr i8, ptr %overflow_arg_area155, i32 8
  store ptr %overflow_arg_area.next156, ptr %overflow_arg_area_p154, align 8
  br label %vaarg.end157

vaarg.end157:                                     ; preds = %vaarg.in_mem153, %vaarg.in_reg151
  %vaarg.addr158 = phi ptr [ %86, %vaarg.in_reg151 ], [ %overflow_arg_area155, %vaarg.in_mem153 ]
  %88 = load i64, ptr %vaarg.addr158, align 8
  %call159 = call i32 (ptr, ptr, ...) @sprintf(ptr noundef %arraydecay147, ptr noundef @.str.6, i64 noundef %88) #9
  br label %if.end191

if.else160:                                       ; preds = %sw.bb144
  %89 = load i32, ptr %size_tflag, align 4
  %tobool161 = icmp ne i32 %89, 0
  br i1 %tobool161, label %if.then162, label %if.else176

if.then162:                                       ; preds = %if.else160
  %arraydecay163 = getelementptr inbounds [21 x i8], ptr %buffer, i64 0, i64 0
  %90 = load ptr, ptr %vargs.addr, align 8
  %gp_offset_p164 = getelementptr inbounds %struct.__va_list_tag, ptr %90, i32 0, i32 0
  %gp_offset165 = load i32, ptr %gp_offset_p164, align 8
  %fits_in_gp166 = icmp ule i32 %gp_offset165, 40
  br i1 %fits_in_gp166, label %vaarg.in_reg167, label %vaarg.in_mem169

vaarg.in_reg167:                                  ; preds = %if.then162
  %91 = getelementptr inbounds %struct.__va_list_tag, ptr %90, i32 0, i32 3
  %reg_save_area168 = load ptr, ptr %91, align 8
  %92 = getelementptr i8, ptr %reg_save_area168, i32 %gp_offset165
  %93 = add i32 %gp_offset165, 8
  store i32 %93, ptr %gp_offset_p164, align 8
  br label %vaarg.end173

vaarg.in_mem169:                                  ; preds = %if.then162
  %overflow_arg_area_p170 = getelementptr inbounds %struct.__va_list_tag, ptr %90, i32 0, i32 2
  %overflow_arg_area171 = load ptr, ptr %overflow_arg_area_p170, align 8
  %overflow_arg_area.next172 = getelementptr i8, ptr %overflow_arg_area171, i32 8
  store ptr %overflow_arg_area.next172, ptr %overflow_arg_area_p170, align 8
  br label %vaarg.end173

vaarg.end173:                                     ; preds = %vaarg.in_mem169, %vaarg.in_reg167
  %vaarg.addr174 = phi ptr [ %92, %vaarg.in_reg167 ], [ %overflow_arg_area171, %vaarg.in_mem169 ]
  %94 = load i64, ptr %vaarg.addr174, align 8
  %call175 = call i32 (ptr, ptr, ...) @sprintf(ptr noundef %arraydecay163, ptr noundef @.str.7, i64 noundef %94) #9
  br label %if.end190

if.else176:                                       ; preds = %if.else160
  %arraydecay177 = getelementptr inbounds [21 x i8], ptr %buffer, i64 0, i64 0
  %95 = load ptr, ptr %vargs.addr, align 8
  %gp_offset_p178 = getelementptr inbounds %struct.__va_list_tag, ptr %95, i32 0, i32 0
  %gp_offset179 = load i32, ptr %gp_offset_p178, align 8
  %fits_in_gp180 = icmp ule i32 %gp_offset179, 40
  br i1 %fits_in_gp180, label %vaarg.in_reg181, label %vaarg.in_mem183

vaarg.in_reg181:                                  ; preds = %if.else176
  %96 = getelementptr inbounds %struct.__va_list_tag, ptr %95, i32 0, i32 3
  %reg_save_area182 = load ptr, ptr %96, align 8
  %97 = getelementptr i8, ptr %reg_save_area182, i32 %gp_offset179
  %98 = add i32 %gp_offset179, 8
  store i32 %98, ptr %gp_offset_p178, align 8
  br label %vaarg.end187

vaarg.in_mem183:                                  ; preds = %if.else176
  %overflow_arg_area_p184 = getelementptr inbounds %struct.__va_list_tag, ptr %95, i32 0, i32 2
  %overflow_arg_area185 = load ptr, ptr %overflow_arg_area_p184, align 8
  %overflow_arg_area.next186 = getelementptr i8, ptr %overflow_arg_area185, i32 8
  store ptr %overflow_arg_area.next186, ptr %overflow_arg_area_p184, align 8
  br label %vaarg.end187

vaarg.end187:                                     ; preds = %vaarg.in_mem183, %vaarg.in_reg181
  %vaarg.addr188 = phi ptr [ %97, %vaarg.in_reg181 ], [ %overflow_arg_area185, %vaarg.in_mem183 ]
  %99 = load i32, ptr %vaarg.addr188, align 4
  %call189 = call i32 (ptr, ptr, ...) @sprintf(ptr noundef %arraydecay177, ptr noundef @.str.8, i32 noundef %99) #9
  br label %if.end190

if.end190:                                        ; preds = %vaarg.end187, %vaarg.end173
  br label %if.end191

if.end191:                                        ; preds = %if.end190, %vaarg.end157
  br label %do.body192

do.body192:                                       ; preds = %if.end191
  %100 = load ptr, ptr %s, align 8
  %arraydecay193 = getelementptr inbounds [21 x i8], ptr %buffer, i64 0, i64 0
  %arraydecay194 = getelementptr inbounds [21 x i8], ptr %buffer, i64 0, i64 0
  %call195 = call i64 @strlen(ptr noundef %arraydecay194) #8
  %call196 = call ptr @_PyBytesWriter_WriteBytes(ptr noundef %writer, ptr noundef %100, ptr noundef %arraydecay193, i64 noundef %call195)
  store ptr %call196, ptr %s, align 8
  %101 = load ptr, ptr %s, align 8
  %cmp197 = icmp eq ptr %101, null
  br i1 %cmp197, label %if.then199, label %if.end200

if.then199:                                       ; preds = %do.body192
  br label %error

if.end200:                                        ; preds = %do.body192
  br label %do.end201

do.end201:                                        ; preds = %if.end200
  br label %sw.epilog

sw.bb202:                                         ; preds = %if.end76
  %arraydecay203 = getelementptr inbounds [21 x i8], ptr %buffer, i64 0, i64 0
  %102 = load ptr, ptr %vargs.addr, align 8
  %gp_offset_p204 = getelementptr inbounds %struct.__va_list_tag, ptr %102, i32 0, i32 0
  %gp_offset205 = load i32, ptr %gp_offset_p204, align 8
  %fits_in_gp206 = icmp ule i32 %gp_offset205, 40
  br i1 %fits_in_gp206, label %vaarg.in_reg207, label %vaarg.in_mem209

vaarg.in_reg207:                                  ; preds = %sw.bb202
  %103 = getelementptr inbounds %struct.__va_list_tag, ptr %102, i32 0, i32 3
  %reg_save_area208 = load ptr, ptr %103, align 8
  %104 = getelementptr i8, ptr %reg_save_area208, i32 %gp_offset205
  %105 = add i32 %gp_offset205, 8
  store i32 %105, ptr %gp_offset_p204, align 8
  br label %vaarg.end213

vaarg.in_mem209:                                  ; preds = %sw.bb202
  %overflow_arg_area_p210 = getelementptr inbounds %struct.__va_list_tag, ptr %102, i32 0, i32 2
  %overflow_arg_area211 = load ptr, ptr %overflow_arg_area_p210, align 8
  %overflow_arg_area.next212 = getelementptr i8, ptr %overflow_arg_area211, i32 8
  store ptr %overflow_arg_area.next212, ptr %overflow_arg_area_p210, align 8
  br label %vaarg.end213

vaarg.end213:                                     ; preds = %vaarg.in_mem209, %vaarg.in_reg207
  %vaarg.addr214 = phi ptr [ %104, %vaarg.in_reg207 ], [ %overflow_arg_area211, %vaarg.in_mem209 ]
  %106 = load i32, ptr %vaarg.addr214, align 4
  %call215 = call i32 (ptr, ptr, ...) @sprintf(ptr noundef %arraydecay203, ptr noundef @.str.9, i32 noundef %106) #9
  br label %do.body216

do.body216:                                       ; preds = %vaarg.end213
  %107 = load ptr, ptr %s, align 8
  %arraydecay217 = getelementptr inbounds [21 x i8], ptr %buffer, i64 0, i64 0
  %arraydecay218 = getelementptr inbounds [21 x i8], ptr %buffer, i64 0, i64 0
  %call219 = call i64 @strlen(ptr noundef %arraydecay218) #8
  %call220 = call ptr @_PyBytesWriter_WriteBytes(ptr noundef %writer, ptr noundef %107, ptr noundef %arraydecay217, i64 noundef %call219)
  store ptr %call220, ptr %s, align 8
  %108 = load ptr, ptr %s, align 8
  %cmp221 = icmp eq ptr %108, null
  br i1 %cmp221, label %if.then223, label %if.end224

if.then223:                                       ; preds = %do.body216
  br label %error

if.end224:                                        ; preds = %do.body216
  br label %do.end225

do.end225:                                        ; preds = %if.end224
  br label %sw.epilog

sw.bb226:                                         ; preds = %if.end76
  %arraydecay227 = getelementptr inbounds [21 x i8], ptr %buffer, i64 0, i64 0
  %109 = load ptr, ptr %vargs.addr, align 8
  %gp_offset_p228 = getelementptr inbounds %struct.__va_list_tag, ptr %109, i32 0, i32 0
  %gp_offset229 = load i32, ptr %gp_offset_p228, align 8
  %fits_in_gp230 = icmp ule i32 %gp_offset229, 40
  br i1 %fits_in_gp230, label %vaarg.in_reg231, label %vaarg.in_mem233

vaarg.in_reg231:                                  ; preds = %sw.bb226
  %110 = getelementptr inbounds %struct.__va_list_tag, ptr %109, i32 0, i32 3
  %reg_save_area232 = load ptr, ptr %110, align 8
  %111 = getelementptr i8, ptr %reg_save_area232, i32 %gp_offset229
  %112 = add i32 %gp_offset229, 8
  store i32 %112, ptr %gp_offset_p228, align 8
  br label %vaarg.end237

vaarg.in_mem233:                                  ; preds = %sw.bb226
  %overflow_arg_area_p234 = getelementptr inbounds %struct.__va_list_tag, ptr %109, i32 0, i32 2
  %overflow_arg_area235 = load ptr, ptr %overflow_arg_area_p234, align 8
  %overflow_arg_area.next236 = getelementptr i8, ptr %overflow_arg_area235, i32 8
  store ptr %overflow_arg_area.next236, ptr %overflow_arg_area_p234, align 8
  br label %vaarg.end237

vaarg.end237:                                     ; preds = %vaarg.in_mem233, %vaarg.in_reg231
  %vaarg.addr238 = phi ptr [ %111, %vaarg.in_reg231 ], [ %overflow_arg_area235, %vaarg.in_mem233 ]
  %113 = load i32, ptr %vaarg.addr238, align 4
  %call239 = call i32 (ptr, ptr, ...) @sprintf(ptr noundef %arraydecay227, ptr noundef @.str.10, i32 noundef %113) #9
  br label %do.body240

do.body240:                                       ; preds = %vaarg.end237
  %114 = load ptr, ptr %s, align 8
  %arraydecay241 = getelementptr inbounds [21 x i8], ptr %buffer, i64 0, i64 0
  %arraydecay242 = getelementptr inbounds [21 x i8], ptr %buffer, i64 0, i64 0
  %call243 = call i64 @strlen(ptr noundef %arraydecay242) #8
  %call244 = call ptr @_PyBytesWriter_WriteBytes(ptr noundef %writer, ptr noundef %114, ptr noundef %arraydecay241, i64 noundef %call243)
  store ptr %call244, ptr %s, align 8
  %115 = load ptr, ptr %s, align 8
  %cmp245 = icmp eq ptr %115, null
  br i1 %cmp245, label %if.then247, label %if.end248

if.then247:                                       ; preds = %do.body240
  br label %error

if.end248:                                        ; preds = %do.body240
  br label %do.end249

do.end249:                                        ; preds = %if.end248
  br label %sw.epilog

sw.bb250:                                         ; preds = %if.end76
  %116 = load ptr, ptr %vargs.addr, align 8
  %gp_offset_p251 = getelementptr inbounds %struct.__va_list_tag, ptr %116, i32 0, i32 0
  %gp_offset252 = load i32, ptr %gp_offset_p251, align 8
  %fits_in_gp253 = icmp ule i32 %gp_offset252, 40
  br i1 %fits_in_gp253, label %vaarg.in_reg254, label %vaarg.in_mem256

vaarg.in_reg254:                                  ; preds = %sw.bb250
  %117 = getelementptr inbounds %struct.__va_list_tag, ptr %116, i32 0, i32 3
  %reg_save_area255 = load ptr, ptr %117, align 8
  %118 = getelementptr i8, ptr %reg_save_area255, i32 %gp_offset252
  %119 = add i32 %gp_offset252, 8
  store i32 %119, ptr %gp_offset_p251, align 8
  br label %vaarg.end260

vaarg.in_mem256:                                  ; preds = %sw.bb250
  %overflow_arg_area_p257 = getelementptr inbounds %struct.__va_list_tag, ptr %116, i32 0, i32 2
  %overflow_arg_area258 = load ptr, ptr %overflow_arg_area_p257, align 8
  %overflow_arg_area.next259 = getelementptr i8, ptr %overflow_arg_area258, i32 8
  store ptr %overflow_arg_area.next259, ptr %overflow_arg_area_p257, align 8
  br label %vaarg.end260

vaarg.end260:                                     ; preds = %vaarg.in_mem256, %vaarg.in_reg254
  %vaarg.addr261 = phi ptr [ %118, %vaarg.in_reg254 ], [ %overflow_arg_area258, %vaarg.in_mem256 ]
  %120 = load ptr, ptr %vaarg.addr261, align 8
  store ptr %120, ptr %p, align 8
  %121 = load i64, ptr %prec, align 8
  %cmp262 = icmp sle i64 %121, 0
  br i1 %cmp262, label %if.then264, label %if.else266

if.then264:                                       ; preds = %vaarg.end260
  %122 = load ptr, ptr %p, align 8
  %call265 = call i64 @strlen(ptr noundef %122) #8
  store i64 %call265, ptr %i, align 8
  br label %if.end278

if.else266:                                       ; preds = %vaarg.end260
  store i64 0, ptr %i, align 8
  br label %while.cond267

while.cond267:                                    ; preds = %while.body275, %if.else266
  %123 = load i64, ptr %i, align 8
  %124 = load i64, ptr %prec, align 8
  %cmp268 = icmp slt i64 %123, %124
  br i1 %cmp268, label %land.rhs270, label %land.end274

land.rhs270:                                      ; preds = %while.cond267
  %125 = load ptr, ptr %p, align 8
  %126 = load i64, ptr %i, align 8
  %arrayidx271 = getelementptr i8, ptr %125, i64 %126
  %127 = load i8, ptr %arrayidx271, align 1
  %conv272 = sext i8 %127 to i32
  %tobool273 = icmp ne i32 %conv272, 0
  br label %land.end274

land.end274:                                      ; preds = %land.rhs270, %while.cond267
  %128 = phi i1 [ false, %while.cond267 ], [ %tobool273, %land.rhs270 ]
  br i1 %128, label %while.body275, label %while.end277

while.body275:                                    ; preds = %land.end274
  %129 = load i64, ptr %i, align 8
  %inc276 = add i64 %129, 1
  store i64 %inc276, ptr %i, align 8
  br label %while.cond267, !llvm.loop !9

while.end277:                                     ; preds = %land.end274
  br label %if.end278

if.end278:                                        ; preds = %while.end277, %if.then264
  %130 = load ptr, ptr %s, align 8
  %131 = load ptr, ptr %p, align 8
  %132 = load i64, ptr %i, align 8
  %call279 = call ptr @_PyBytesWriter_WriteBytes(ptr noundef %writer, ptr noundef %130, ptr noundef %131, i64 noundef %132)
  store ptr %call279, ptr %s, align 8
  %133 = load ptr, ptr %s, align 8
  %cmp280 = icmp eq ptr %133, null
  br i1 %cmp280, label %if.then282, label %if.end283

if.then282:                                       ; preds = %if.end278
  br label %error

if.end283:                                        ; preds = %if.end278
  br label %sw.epilog

sw.bb284:                                         ; preds = %if.end76
  %arraydecay285 = getelementptr inbounds [21 x i8], ptr %buffer, i64 0, i64 0
  %134 = load ptr, ptr %vargs.addr, align 8
  %gp_offset_p286 = getelementptr inbounds %struct.__va_list_tag, ptr %134, i32 0, i32 0
  %gp_offset287 = load i32, ptr %gp_offset_p286, align 8
  %fits_in_gp288 = icmp ule i32 %gp_offset287, 40
  br i1 %fits_in_gp288, label %vaarg.in_reg289, label %vaarg.in_mem291

vaarg.in_reg289:                                  ; preds = %sw.bb284
  %135 = getelementptr inbounds %struct.__va_list_tag, ptr %134, i32 0, i32 3
  %reg_save_area290 = load ptr, ptr %135, align 8
  %136 = getelementptr i8, ptr %reg_save_area290, i32 %gp_offset287
  %137 = add i32 %gp_offset287, 8
  store i32 %137, ptr %gp_offset_p286, align 8
  br label %vaarg.end295

vaarg.in_mem291:                                  ; preds = %sw.bb284
  %overflow_arg_area_p292 = getelementptr inbounds %struct.__va_list_tag, ptr %134, i32 0, i32 2
  %overflow_arg_area293 = load ptr, ptr %overflow_arg_area_p292, align 8
  %overflow_arg_area.next294 = getelementptr i8, ptr %overflow_arg_area293, i32 8
  store ptr %overflow_arg_area.next294, ptr %overflow_arg_area_p292, align 8
  br label %vaarg.end295

vaarg.end295:                                     ; preds = %vaarg.in_mem291, %vaarg.in_reg289
  %vaarg.addr296 = phi ptr [ %136, %vaarg.in_reg289 ], [ %overflow_arg_area293, %vaarg.in_mem291 ]
  %138 = load ptr, ptr %vaarg.addr296, align 8
  %call297 = call i32 (ptr, ptr, ...) @sprintf(ptr noundef %arraydecay285, ptr noundef @.str.11, ptr noundef %138) #9
  %arrayidx298 = getelementptr [21 x i8], ptr %buffer, i64 0, i64 1
  %139 = load i8, ptr %arrayidx298, align 1
  %conv299 = sext i8 %139 to i32
  %cmp300 = icmp eq i32 %conv299, 88
  br i1 %cmp300, label %if.then302, label %if.else304

if.then302:                                       ; preds = %vaarg.end295
  %arrayidx303 = getelementptr [21 x i8], ptr %buffer, i64 0, i64 1
  store i8 120, ptr %arrayidx303, align 1
  br label %if.end318

if.else304:                                       ; preds = %vaarg.end295
  %arrayidx305 = getelementptr [21 x i8], ptr %buffer, i64 0, i64 1
  %140 = load i8, ptr %arrayidx305, align 1
  %conv306 = sext i8 %140 to i32
  %cmp307 = icmp ne i32 %conv306, 120
  br i1 %cmp307, label %if.then309, label %if.end317

if.then309:                                       ; preds = %if.else304
  %arraydecay310 = getelementptr inbounds [21 x i8], ptr %buffer, i64 0, i64 0
  %add.ptr = getelementptr i8, ptr %arraydecay310, i64 2
  %arraydecay311 = getelementptr inbounds [21 x i8], ptr %buffer, i64 0, i64 0
  %arraydecay312 = getelementptr inbounds [21 x i8], ptr %buffer, i64 0, i64 0
  %call313 = call i64 @strlen(ptr noundef %arraydecay312) #8
  %add314 = add i64 %call313, 1
  call void @llvm.memmove.p0.p0.i64(ptr align 1 %add.ptr, ptr align 16 %arraydecay311, i64 %add314, i1 false)
  %arrayidx315 = getelementptr [21 x i8], ptr %buffer, i64 0, i64 0
  store i8 48, ptr %arrayidx315, align 16
  %arrayidx316 = getelementptr [21 x i8], ptr %buffer, i64 0, i64 1
  store i8 120, ptr %arrayidx316, align 1
  br label %if.end317

if.end317:                                        ; preds = %if.then309, %if.else304
  br label %if.end318

if.end318:                                        ; preds = %if.end317, %if.then302
  br label %do.body319

do.body319:                                       ; preds = %if.end318
  %141 = load ptr, ptr %s, align 8
  %arraydecay320 = getelementptr inbounds [21 x i8], ptr %buffer, i64 0, i64 0
  %arraydecay321 = getelementptr inbounds [21 x i8], ptr %buffer, i64 0, i64 0
  %call322 = call i64 @strlen(ptr noundef %arraydecay321) #8
  %call323 = call ptr @_PyBytesWriter_WriteBytes(ptr noundef %writer, ptr noundef %141, ptr noundef %arraydecay320, i64 noundef %call322)
  store ptr %call323, ptr %s, align 8
  %142 = load ptr, ptr %s, align 8
  %cmp324 = icmp eq ptr %142, null
  br i1 %cmp324, label %if.then326, label %if.end327

if.then326:                                       ; preds = %do.body319
  br label %error

if.end327:                                        ; preds = %do.body319
  br label %do.end328

do.end328:                                        ; preds = %if.end327
  br label %sw.epilog

sw.bb329:                                         ; preds = %if.end76
  %min_size330 = getelementptr inbounds %struct._PyBytesWriter, ptr %writer, i32 0, i32 2
  %143 = load i64, ptr %min_size330, align 8
  %inc331 = add i64 %143, 1
  store i64 %inc331, ptr %min_size330, align 8
  %144 = load ptr, ptr %s, align 8
  %incdec.ptr332 = getelementptr i8, ptr %144, i32 1
  store ptr %incdec.ptr332, ptr %s, align 8
  store i8 37, ptr %144, align 1
  br label %sw.epilog

sw.default:                                       ; preds = %if.end76
  %145 = load ptr, ptr %f, align 8
  %146 = load i8, ptr %145, align 1
  %conv333 = sext i8 %146 to i32
  %cmp334 = icmp eq i32 %conv333, 0
  br i1 %cmp334, label %if.then336, label %if.end339

if.then336:                                       ; preds = %sw.default
  %min_size337 = getelementptr inbounds %struct._PyBytesWriter, ptr %writer, i32 0, i32 2
  %147 = load i64, ptr %min_size337, align 8
  %inc338 = add i64 %147, 1
  store i64 %inc338, ptr %min_size337, align 8
  br label %if.end339

if.end339:                                        ; preds = %if.then336, %sw.default
  br label %do.body340

do.body340:                                       ; preds = %if.end339
  %148 = load ptr, ptr %s, align 8
  %149 = load ptr, ptr %p, align 8
  %150 = load ptr, ptr %p, align 8
  %call341 = call i64 @strlen(ptr noundef %150) #8
  %call342 = call ptr @_PyBytesWriter_WriteBytes(ptr noundef %writer, ptr noundef %148, ptr noundef %149, i64 noundef %call341)
  store ptr %call342, ptr %s, align 8
  %151 = load ptr, ptr %s, align 8
  %cmp343 = icmp eq ptr %151, null
  br i1 %cmp343, label %if.then345, label %if.end346

if.then345:                                       ; preds = %do.body340
  br label %error

if.end346:                                        ; preds = %do.body340
  br label %do.end347

do.end347:                                        ; preds = %if.end346
  %152 = load ptr, ptr %s, align 8
  %call348 = call ptr @_PyBytesWriter_Finish(ptr noundef %writer, ptr noundef %152)
  store ptr %call348, ptr %retval, align 8
  br label %return

sw.epilog:                                        ; preds = %sw.bb329, %do.end328, %if.end283, %do.end249, %do.end225, %do.end201, %do.end, %if.end86
  br label %for.inc349

for.inc349:                                       ; preds = %sw.epilog, %if.then4
  %153 = load ptr, ptr %f, align 8
  %incdec.ptr350 = getelementptr i8, ptr %153, i32 1
  store ptr %incdec.ptr350, ptr %f, align 8
  br label %for.cond, !llvm.loop !10

for.end351:                                       ; preds = %for.cond
  %154 = load ptr, ptr %s, align 8
  %call352 = call ptr @_PyBytesWriter_Finish(ptr noundef %writer, ptr noundef %154)
  store ptr %call352, ptr %retval, align 8
  br label %return

error:                                            ; preds = %if.then345, %if.then326, %if.then282, %if.then247, %if.then223, %if.then199, %if.then142, %if.then85
  call void @_PyBytesWriter_Dealloc(ptr noundef %writer)
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %error, %for.end351, %do.end347, %if.then
  %155 = load ptr, ptr %retval, align 8
  ret ptr %155
}

; Function Attrs: nounwind uwtable
define dso_local void @_PyBytesWriter_Init(ptr noundef %writer) #0 {
entry:
  %writer.addr = alloca ptr, align 8
  store ptr %writer, ptr %writer.addr, align 8
  %0 = load ptr, ptr %writer.addr, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %0, i8 0, i64 36, i1 false)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local ptr @_PyBytesWriter_Alloc(ptr noundef %writer, i64 noundef %size) #0 {
entry:
  %writer.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  store ptr %writer, ptr %writer.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load ptr, ptr %writer.addr, align 8
  %use_small_buffer = getelementptr inbounds %struct._PyBytesWriter, ptr %0, i32 0, i32 5
  store i32 1, ptr %use_small_buffer, align 8
  %1 = load ptr, ptr %writer.addr, align 8
  %allocated = getelementptr inbounds %struct._PyBytesWriter, ptr %1, i32 0, i32 1
  store i64 512, ptr %allocated, align 8
  %2 = load ptr, ptr %writer.addr, align 8
  %3 = load ptr, ptr %writer.addr, align 8
  %small_buffer = getelementptr inbounds %struct._PyBytesWriter, ptr %3, i32 0, i32 6
  %arraydecay = getelementptr inbounds [512 x i8], ptr %small_buffer, i64 0, i64 0
  %4 = load i64, ptr %size.addr, align 8
  %call = call ptr @_PyBytesWriter_Prepare(ptr noundef %2, ptr noundef %arraydecay, i64 noundef %4)
  ret ptr %call
}

; Function Attrs: nounwind
declare i32 @sprintf(ptr noundef, ptr noundef, ...) #4

; Function Attrs: nounwind uwtable
define dso_local ptr @_PyBytesWriter_WriteBytes(ptr noundef %writer, ptr noundef %ptr, ptr noundef %bytes, i64 noundef %size) #0 {
entry:
  %retval = alloca ptr, align 8
  %writer.addr = alloca ptr, align 8
  %ptr.addr = alloca ptr, align 8
  %bytes.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %str = alloca ptr, align 8
  store ptr %writer, ptr %writer.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  store ptr %bytes, ptr %bytes.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  store ptr %0, ptr %str, align 8
  %1 = load ptr, ptr %writer.addr, align 8
  %2 = load ptr, ptr %str, align 8
  %3 = load i64, ptr %size.addr, align 8
  %call = call ptr @_PyBytesWriter_Prepare(ptr noundef %1, ptr noundef %2, i64 noundef %3)
  store ptr %call, ptr %str, align 8
  %4 = load ptr, ptr %str, align 8
  %cmp = icmp eq ptr %4, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %5 = load ptr, ptr %str, align 8
  %6 = load ptr, ptr %bytes.addr, align 8
  %7 = load i64, ptr %size.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %5, ptr align 1 %6, i64 %7, i1 false)
  %8 = load i64, ptr %size.addr, align 8
  %9 = load ptr, ptr %str, align 8
  %add.ptr = getelementptr i8, ptr %9, i64 %8
  store ptr %add.ptr, ptr %str, align 8
  %10 = load ptr, ptr %str, align 8
  store ptr %10, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load ptr, ptr %retval, align 8
  ret ptr %11
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memmove.p0.p0.i64(ptr nocapture writeonly, ptr nocapture readonly, i64, i1 immarg) #2

; Function Attrs: nounwind uwtable
define dso_local ptr @_PyBytesWriter_Finish(ptr noundef %writer, ptr noundef %str) #0 {
entry:
  %op.addr.i47 = alloca ptr, align 8
  %op.addr.i45 = alloca ptr, align 8
  %op.addr.i36 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %writer.addr = alloca ptr, align 8
  %str.addr = alloca ptr, align 8
  %size = alloca i64, align 8
  %result = alloca ptr, align 8
  %_tmp_op_ptr = alloca ptr, align 8
  %_tmp_old_op = alloca ptr, align 8
  store ptr %writer, ptr %writer.addr, align 8
  store ptr %str, ptr %str.addr, align 8
  %0 = load ptr, ptr %writer.addr, align 8
  %1 = load ptr, ptr %str.addr, align 8
  %call = call i64 @_PyBytesWriter_GetSize(ptr noundef %0, ptr noundef %1)
  store i64 %call, ptr %size, align 8
  %2 = load i64, ptr %size, align 8
  %cmp = icmp eq i64 %2, 0
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %3 = load ptr, ptr %writer.addr, align 8
  %use_bytearray = getelementptr inbounds %struct._PyBytesWriter, ptr %3, i32 0, i32 3
  %4 = load i32, ptr %use_bytearray, align 8
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %do.body

do.body:                                          ; preds = %if.then
  %5 = load ptr, ptr %writer.addr, align 8
  %buffer = getelementptr inbounds %struct._PyBytesWriter, ptr %5, i32 0, i32 0
  store ptr %buffer, ptr %_tmp_op_ptr, align 8
  %6 = load ptr, ptr %_tmp_op_ptr, align 8
  %7 = load ptr, ptr %6, align 8
  store ptr %7, ptr %_tmp_old_op, align 8
  %8 = load ptr, ptr %_tmp_old_op, align 8
  %cmp1 = icmp ne ptr %8, null
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %do.body
  %9 = load ptr, ptr %_tmp_op_ptr, align 8
  store ptr null, ptr %9, align 8
  %10 = load ptr, ptr %_tmp_old_op, align 8
  store ptr %10, ptr %op.addr.i36, align 8
  %11 = load ptr, ptr %op.addr.i36, align 8
  store ptr %11, ptr %op.addr.i45, align 8
  %12 = load ptr, ptr %op.addr.i45, align 8
  %13 = load i64, ptr %12, align 8
  %conv.i = trunc i64 %13 to i32
  %cmp.i46 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i46 to i32
  %tobool.i38 = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i38, label %if.then.i43, label %if.end.i39

if.then.i43:                                      ; preds = %if.then2
  br label %Py_DECREF.exit44

if.end.i39:                                       ; preds = %if.then2
  %14 = load ptr, ptr %op.addr.i36, align 8
  %15 = load i64, ptr %14, align 8
  %dec.i40 = add i64 %15, -1
  store i64 %dec.i40, ptr %14, align 8
  %cmp.i41 = icmp eq i64 %dec.i40, 0
  br i1 %cmp.i41, label %if.then1.i42, label %Py_DECREF.exit44

if.then1.i42:                                     ; preds = %if.end.i39
  %16 = load ptr, ptr %op.addr.i36, align 8
  call void @_Py_Dealloc(ptr noundef %16) #9
  br label %Py_DECREF.exit44

Py_DECREF.exit44:                                 ; preds = %if.then1.i42, %if.end.i39, %if.then.i43
  br label %if.end

if.end:                                           ; preds = %Py_DECREF.exit44, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  %call3 = call ptr @PyBytes_FromStringAndSize(ptr noundef null, i64 noundef 0)
  store ptr %call3, ptr %result, align 8
  br label %if.end35

if.else:                                          ; preds = %land.lhs.true, %entry
  %17 = load ptr, ptr %writer.addr, align 8
  %use_small_buffer = getelementptr inbounds %struct._PyBytesWriter, ptr %17, i32 0, i32 5
  %18 = load i32, ptr %use_small_buffer, align 8
  %tobool4 = icmp ne i32 %18, 0
  br i1 %tobool4, label %if.then5, label %if.else15

if.then5:                                         ; preds = %if.else
  %19 = load ptr, ptr %writer.addr, align 8
  %use_bytearray6 = getelementptr inbounds %struct._PyBytesWriter, ptr %19, i32 0, i32 3
  %20 = load i32, ptr %use_bytearray6, align 8
  %tobool7 = icmp ne i32 %20, 0
  br i1 %tobool7, label %if.then8, label %if.else10

if.then8:                                         ; preds = %if.then5
  %21 = load ptr, ptr %writer.addr, align 8
  %small_buffer = getelementptr inbounds %struct._PyBytesWriter, ptr %21, i32 0, i32 6
  %arraydecay = getelementptr inbounds [512 x i8], ptr %small_buffer, i64 0, i64 0
  %22 = load i64, ptr %size, align 8
  %call9 = call ptr @PyByteArray_FromStringAndSize(ptr noundef %arraydecay, i64 noundef %22)
  store ptr %call9, ptr %result, align 8
  br label %if.end14

if.else10:                                        ; preds = %if.then5
  %23 = load ptr, ptr %writer.addr, align 8
  %small_buffer11 = getelementptr inbounds %struct._PyBytesWriter, ptr %23, i32 0, i32 6
  %arraydecay12 = getelementptr inbounds [512 x i8], ptr %small_buffer11, i64 0, i64 0
  %24 = load i64, ptr %size, align 8
  %call13 = call ptr @PyBytes_FromStringAndSize(ptr noundef %arraydecay12, i64 noundef %24)
  store ptr %call13, ptr %result, align 8
  br label %if.end14

if.end14:                                         ; preds = %if.else10, %if.then8
  br label %if.end34

if.else15:                                        ; preds = %if.else
  %25 = load ptr, ptr %writer.addr, align 8
  %buffer16 = getelementptr inbounds %struct._PyBytesWriter, ptr %25, i32 0, i32 0
  %26 = load ptr, ptr %buffer16, align 8
  store ptr %26, ptr %result, align 8
  %27 = load ptr, ptr %writer.addr, align 8
  %buffer17 = getelementptr inbounds %struct._PyBytesWriter, ptr %27, i32 0, i32 0
  store ptr null, ptr %buffer17, align 8
  %28 = load i64, ptr %size, align 8
  %29 = load ptr, ptr %writer.addr, align 8
  %allocated = getelementptr inbounds %struct._PyBytesWriter, ptr %29, i32 0, i32 1
  %30 = load i64, ptr %allocated, align 8
  %cmp18 = icmp ne i64 %28, %30
  br i1 %cmp18, label %if.then19, label %if.end33

if.then19:                                        ; preds = %if.else15
  %31 = load ptr, ptr %writer.addr, align 8
  %use_bytearray20 = getelementptr inbounds %struct._PyBytesWriter, ptr %31, i32 0, i32 3
  %32 = load i32, ptr %use_bytearray20, align 8
  %tobool21 = icmp ne i32 %32, 0
  br i1 %tobool21, label %if.then22, label %if.else27

if.then22:                                        ; preds = %if.then19
  %33 = load ptr, ptr %result, align 8
  %34 = load i64, ptr %size, align 8
  %call23 = call i32 @PyByteArray_Resize(ptr noundef %33, i64 noundef %34)
  %tobool24 = icmp ne i32 %call23, 0
  br i1 %tobool24, label %if.then25, label %if.end26

if.then25:                                        ; preds = %if.then22
  %35 = load ptr, ptr %result, align 8
  store ptr %35, ptr %op.addr.i, align 8
  %36 = load ptr, ptr %op.addr.i, align 8
  store ptr %36, ptr %op.addr.i47, align 8
  %37 = load ptr, ptr %op.addr.i47, align 8
  %38 = load i64, ptr %37, align 8
  %conv.i48 = trunc i64 %38 to i32
  %cmp.i49 = icmp slt i32 %conv.i48, 0
  %conv1.i50 = zext i1 %cmp.i49 to i32
  %tobool.i = icmp ne i32 %conv1.i50, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then25
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.then25
  %39 = load ptr, ptr %op.addr.i, align 8
  %40 = load i64, ptr %39, align 8
  %dec.i = add i64 %40, -1
  store i64 %dec.i, ptr %39, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %41 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %41) #9
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  store ptr null, ptr %retval, align 8
  br label %return

if.end26:                                         ; preds = %if.then22
  br label %if.end32

if.else27:                                        ; preds = %if.then19
  %42 = load i64, ptr %size, align 8
  %call28 = call i32 @_PyBytes_Resize(ptr noundef %result, i64 noundef %42)
  %tobool29 = icmp ne i32 %call28, 0
  br i1 %tobool29, label %if.then30, label %if.end31

if.then30:                                        ; preds = %if.else27
  store ptr null, ptr %retval, align 8
  br label %return

if.end31:                                         ; preds = %if.else27
  br label %if.end32

if.end32:                                         ; preds = %if.end31, %if.end26
  br label %if.end33

if.end33:                                         ; preds = %if.end32, %if.else15
  br label %if.end34

if.end34:                                         ; preds = %if.end33, %if.end14
  br label %if.end35

if.end35:                                         ; preds = %if.end34, %do.end
  %43 = load ptr, ptr %result, align 8
  store ptr %43, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end35, %if.then30, %Py_DECREF.exit
  %44 = load ptr, ptr %retval, align 8
  ret ptr %44
}

; Function Attrs: nounwind uwtable
define dso_local void @_PyBytesWriter_Dealloc(ptr noundef %writer) #0 {
entry:
  %op.addr.i1 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %writer.addr = alloca ptr, align 8
  %_tmp_op_ptr = alloca ptr, align 8
  %_tmp_old_op = alloca ptr, align 8
  store ptr %writer, ptr %writer.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load ptr, ptr %writer.addr, align 8
  %buffer = getelementptr inbounds %struct._PyBytesWriter, ptr %0, i32 0, i32 0
  store ptr %buffer, ptr %_tmp_op_ptr, align 8
  %1 = load ptr, ptr %_tmp_op_ptr, align 8
  %2 = load ptr, ptr %1, align 8
  store ptr %2, ptr %_tmp_old_op, align 8
  %3 = load ptr, ptr %_tmp_old_op, align 8
  %cmp = icmp ne ptr %3, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  %4 = load ptr, ptr %_tmp_op_ptr, align 8
  store ptr null, ptr %4, align 8
  %5 = load ptr, ptr %_tmp_old_op, align 8
  store ptr %5, ptr %op.addr.i, align 8
  %6 = load ptr, ptr %op.addr.i, align 8
  store ptr %6, ptr %op.addr.i1, align 8
  %7 = load ptr, ptr %op.addr.i1, align 8
  %8 = load i64, ptr %7, align 8
  %conv.i = trunc i64 %8 to i32
  %cmp.i2 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i2 to i32
  %tobool.i = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.then
  %9 = load ptr, ptr %op.addr.i, align 8
  %10 = load i64, ptr %9, align 8
  %dec.i = add i64 %10, -1
  store i64 %dec.i, ptr %9, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %11 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %11) #9
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  br label %if.end

if.end:                                           ; preds = %Py_DECREF.exit, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local ptr @PyBytes_FromFormat(ptr noundef %format, ...) #0 {
entry:
  %format.addr = alloca ptr, align 8
  %ret = alloca ptr, align 8
  %vargs = alloca [1 x %struct.__va_list_tag], align 16
  store ptr %format, ptr %format.addr, align 8
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %vargs, i64 0, i64 0
  call void @llvm.va_start(ptr %arraydecay)
  %0 = load ptr, ptr %format.addr, align 8
  %arraydecay1 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %vargs, i64 0, i64 0
  %call = call ptr @PyBytes_FromFormatV(ptr noundef %0, ptr noundef %arraydecay1)
  store ptr %call, ptr %ret, align 8
  %arraydecay2 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %vargs, i64 0, i64 0
  call void @llvm.va_end(ptr %arraydecay2)
  %1 = load ptr, ptr %ret, align 8
  ret ptr %1
}

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare void @llvm.va_start(ptr) #5

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare void @llvm.va_end(ptr) #5

; Function Attrs: nounwind uwtable
define hidden ptr @_PyBytes_FormatEx(ptr noundef %format, i64 noundef %format_len, ptr noundef %args, i32 noundef %use_bytearray) #0 {
entry:
  %op.addr.i631 = alloca ptr, align 8
  %op.addr.i627 = alloca ptr, align 8
  %op.addr.i623 = alloca ptr, align 8
  %op.addr.i621 = alloca ptr, align 8
  %op.addr.i612 = alloca ptr, align 8
  %op.addr.i603 = alloca ptr, align 8
  %op.addr.i594 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %format.addr = alloca ptr, align 8
  %format_len.addr = alloca i64, align 8
  %args.addr = alloca ptr, align 8
  %use_bytearray.addr = alloca i32, align 4
  %fmt = alloca ptr, align 8
  %res = alloca ptr, align 8
  %arglen = alloca i64, align 8
  %argidx = alloca i64, align 8
  %fmtcnt = alloca i64, align 8
  %args_owned = alloca i32, align 4
  %dict = alloca ptr, align 8
  %writer = alloca %struct._PyBytesWriter, align 8
  %len = alloca i64, align 8
  %pos = alloca ptr, align 8
  %flags = alloca i32, align 4
  %width = alloca i64, align 8
  %prec = alloca i32, align 4
  %c = alloca i32, align 4
  %fill = alloca i32, align 4
  %v = alloca ptr, align 8
  %temp = alloca ptr, align 8
  %pbuf = alloca ptr, align 8
  %sign = alloca i32, align 4
  %len49 = alloca i64, align 8
  %onechar = alloca i8, align 1
  %alloc = alloca i64, align 8
  %keystart = alloca ptr, align 8
  %keylen = alloca i64, align 8
  %key = alloca ptr, align 8
  %pcount = alloca i32, align 4
  %alternate = alloca i32, align 4
  %base = alloca i32, align 4
  store ptr %format, ptr %format.addr, align 8
  store i64 %format_len, ptr %format_len.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i32 %use_bytearray, ptr %use_bytearray.addr, align 4
  store i32 0, ptr %args_owned, align 4
  store ptr null, ptr %dict, align 8
  %0 = load ptr, ptr %args.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @_PyErr_BadInternalCall(ptr noundef @.str.12, i32 noundef 579)
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %format.addr, align 8
  store ptr %1, ptr %fmt, align 8
  %2 = load i64, ptr %format_len.addr, align 8
  store i64 %2, ptr %fmtcnt, align 8
  call void @_PyBytesWriter_Init(ptr noundef %writer)
  %3 = load i32, ptr %use_bytearray.addr, align 4
  %use_bytearray1 = getelementptr inbounds %struct._PyBytesWriter, ptr %writer, i32 0, i32 3
  store i32 %3, ptr %use_bytearray1, align 8
  %4 = load i64, ptr %fmtcnt, align 8
  %call = call ptr @_PyBytesWriter_Alloc(ptr noundef %writer, i64 noundef %4)
  store ptr %call, ptr %res, align 8
  %5 = load ptr, ptr %res, align 8
  %cmp2 = icmp eq ptr %5, null
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  %6 = load i32, ptr %use_bytearray.addr, align 4
  %tobool = icmp ne i32 %6, 0
  br i1 %tobool, label %if.end6, label %if.then5

if.then5:                                         ; preds = %if.end4
  %overallocate = getelementptr inbounds %struct._PyBytesWriter, ptr %writer, i32 0, i32 4
  store i32 1, ptr %overallocate, align 4
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %if.end4
  %7 = load ptr, ptr %args.addr, align 8
  %call7 = call ptr @Py_TYPE(ptr noundef %7)
  %call8 = call i32 @PyType_HasFeature(ptr noundef %call7, i64 noundef 67108864)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.then10, label %if.else

if.then10:                                        ; preds = %if.end6
  %8 = load ptr, ptr %args.addr, align 8
  %call11 = call i64 @PyTuple_GET_SIZE(ptr noundef %8)
  store i64 %call11, ptr %arglen, align 8
  store i64 0, ptr %argidx, align 8
  br label %if.end12

if.else:                                          ; preds = %if.end6
  store i64 -1, ptr %arglen, align 8
  store i64 -2, ptr %argidx, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.else, %if.then10
  %9 = load ptr, ptr %args.addr, align 8
  %call13 = call ptr @Py_TYPE(ptr noundef %9)
  %tp_as_mapping = getelementptr inbounds %struct._typeobject, ptr %call13, i32 0, i32 12
  %10 = load ptr, ptr %tp_as_mapping, align 8
  %tobool14 = icmp ne ptr %10, null
  br i1 %tobool14, label %land.lhs.true, label %if.end34

land.lhs.true:                                    ; preds = %if.end12
  %11 = load ptr, ptr %args.addr, align 8
  %call15 = call ptr @Py_TYPE(ptr noundef %11)
  %tp_as_mapping16 = getelementptr inbounds %struct._typeobject, ptr %call15, i32 0, i32 12
  %12 = load ptr, ptr %tp_as_mapping16, align 8
  %mp_subscript = getelementptr inbounds %struct.PyMappingMethods, ptr %12, i32 0, i32 1
  %13 = load ptr, ptr %mp_subscript, align 8
  %tobool17 = icmp ne ptr %13, null
  br i1 %tobool17, label %land.lhs.true18, label %if.end34

land.lhs.true18:                                  ; preds = %land.lhs.true
  %14 = load ptr, ptr %args.addr, align 8
  %call19 = call ptr @Py_TYPE(ptr noundef %14)
  %call20 = call i32 @PyType_HasFeature(ptr noundef %call19, i64 noundef 67108864)
  %tobool21 = icmp ne i32 %call20, 0
  br i1 %tobool21, label %if.end34, label %land.lhs.true22

land.lhs.true22:                                  ; preds = %land.lhs.true18
  %15 = load ptr, ptr %args.addr, align 8
  %call23 = call ptr @Py_TYPE(ptr noundef %15)
  %call24 = call i32 @PyType_HasFeature(ptr noundef %call23, i64 noundef 134217728)
  %tobool25 = icmp ne i32 %call24, 0
  br i1 %tobool25, label %if.end34, label %land.lhs.true26

land.lhs.true26:                                  ; preds = %land.lhs.true22
  %16 = load ptr, ptr %args.addr, align 8
  %call27 = call ptr @Py_TYPE(ptr noundef %16)
  %call28 = call i32 @PyType_HasFeature(ptr noundef %call27, i64 noundef 268435456)
  %tobool29 = icmp ne i32 %call28, 0
  br i1 %tobool29, label %if.end34, label %land.lhs.true30

land.lhs.true30:                                  ; preds = %land.lhs.true26
  %17 = load ptr, ptr %args.addr, align 8
  %call31 = call i32 @PyObject_TypeCheck(ptr noundef %17, ptr noundef @PyByteArray_Type)
  %tobool32 = icmp ne i32 %call31, 0
  br i1 %tobool32, label %if.end34, label %if.then33

if.then33:                                        ; preds = %land.lhs.true30
  %18 = load ptr, ptr %args.addr, align 8
  store ptr %18, ptr %dict, align 8
  br label %if.end34

if.end34:                                         ; preds = %if.then33, %land.lhs.true30, %land.lhs.true26, %land.lhs.true22, %land.lhs.true18, %land.lhs.true, %if.end12
  br label %while.cond

while.cond:                                       ; preds = %if.end579, %if.then430, %if.end410, %if.end382, %if.then53, %if.end34
  %19 = load i64, ptr %fmtcnt, align 8
  %dec = add i64 %19, -1
  store i64 %dec, ptr %fmtcnt, align 8
  %cmp35 = icmp sge i64 %dec, 0
  br i1 %cmp35, label %while.body, label %while.end580

while.body:                                       ; preds = %while.cond
  %20 = load ptr, ptr %fmt, align 8
  %21 = load i8, ptr %20, align 1
  %conv = sext i8 %21 to i32
  %cmp36 = icmp ne i32 %conv, 37
  br i1 %cmp36, label %if.then38, label %if.else48

if.then38:                                        ; preds = %while.body
  %22 = load ptr, ptr %fmt, align 8
  %add.ptr = getelementptr i8, ptr %22, i64 1
  %23 = load i64, ptr %fmtcnt, align 8
  %call39 = call ptr @memchr(ptr noundef %add.ptr, i32 noundef 37, i64 noundef %23) #8
  store ptr %call39, ptr %pos, align 8
  %24 = load ptr, ptr %pos, align 8
  %cmp40 = icmp ne ptr %24, null
  br i1 %cmp40, label %if.then42, label %if.else43

if.then42:                                        ; preds = %if.then38
  %25 = load ptr, ptr %pos, align 8
  %26 = load ptr, ptr %fmt, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %25 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %26 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, ptr %len, align 8
  br label %if.end44

if.else43:                                        ; preds = %if.then38
  %27 = load i64, ptr %fmtcnt, align 8
  %add = add i64 %27, 1
  store i64 %add, ptr %len, align 8
  br label %if.end44

if.end44:                                         ; preds = %if.else43, %if.then42
  %28 = load ptr, ptr %res, align 8
  %29 = load ptr, ptr %fmt, align 8
  %30 = load i64, ptr %len, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %28, ptr align 1 %29, i64 %30, i1 false)
  %31 = load i64, ptr %len, align 8
  %32 = load ptr, ptr %res, align 8
  %add.ptr45 = getelementptr i8, ptr %32, i64 %31
  store ptr %add.ptr45, ptr %res, align 8
  %33 = load i64, ptr %len, align 8
  %34 = load ptr, ptr %fmt, align 8
  %add.ptr46 = getelementptr i8, ptr %34, i64 %33
  store ptr %add.ptr46, ptr %fmt, align 8
  %35 = load i64, ptr %len, align 8
  %sub = sub i64 %35, 1
  %36 = load i64, ptr %fmtcnt, align 8
  %sub47 = sub i64 %36, %sub
  store i64 %sub47, ptr %fmtcnt, align 8
  br label %if.end579

if.else48:                                        ; preds = %while.body
  store i32 0, ptr %flags, align 4
  store i64 -1, ptr %width, align 8
  store i32 -1, ptr %prec, align 4
  store i32 0, ptr %c, align 4
  store ptr null, ptr %v, align 8
  store ptr null, ptr %temp, align 8
  store ptr null, ptr %pbuf, align 8
  store i64 0, ptr %len49, align 8
  %37 = load ptr, ptr %fmt, align 8
  %incdec.ptr = getelementptr i8, ptr %37, i32 1
  store ptr %incdec.ptr, ptr %fmt, align 8
  %38 = load ptr, ptr %fmt, align 8
  %39 = load i8, ptr %38, align 1
  %conv50 = sext i8 %39 to i32
  %cmp51 = icmp eq i32 %conv50, 37
  br i1 %cmp51, label %if.then53, label %if.end57

if.then53:                                        ; preds = %if.else48
  %40 = load ptr, ptr %res, align 8
  %incdec.ptr54 = getelementptr i8, ptr %40, i32 1
  store ptr %incdec.ptr54, ptr %res, align 8
  store i8 37, ptr %40, align 1
  %41 = load ptr, ptr %fmt, align 8
  %incdec.ptr55 = getelementptr i8, ptr %41, i32 1
  store ptr %incdec.ptr55, ptr %fmt, align 8
  %42 = load i64, ptr %fmtcnt, align 8
  %dec56 = add i64 %42, -1
  store i64 %dec56, ptr %fmtcnt, align 8
  br label %while.cond, !llvm.loop !11

if.end57:                                         ; preds = %if.else48
  %43 = load ptr, ptr %fmt, align 8
  %44 = load i8, ptr %43, align 1
  %conv58 = sext i8 %44 to i32
  %cmp59 = icmp eq i32 %conv58, 40
  br i1 %cmp59, label %if.then61, label %if.end111

if.then61:                                        ; preds = %if.end57
  store i32 1, ptr %pcount, align 4
  %45 = load ptr, ptr %dict, align 8
  %cmp62 = icmp eq ptr %45, null
  br i1 %cmp62, label %if.then64, label %if.end65

if.then64:                                        ; preds = %if.then61
  %46 = load ptr, ptr @PyExc_TypeError, align 8
  call void @PyErr_SetString(ptr noundef %46, ptr noundef @.str.13)
  br label %error

if.end65:                                         ; preds = %if.then61
  %47 = load ptr, ptr %fmt, align 8
  %incdec.ptr66 = getelementptr i8, ptr %47, i32 1
  store ptr %incdec.ptr66, ptr %fmt, align 8
  %48 = load i64, ptr %fmtcnt, align 8
  %dec67 = add i64 %48, -1
  store i64 %dec67, ptr %fmtcnt, align 8
  %49 = load ptr, ptr %fmt, align 8
  store ptr %49, ptr %keystart, align 8
  br label %while.cond68

while.cond68:                                     ; preds = %if.end86, %if.end65
  %50 = load i32, ptr %pcount, align 4
  %cmp69 = icmp sgt i32 %50, 0
  br i1 %cmp69, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond68
  %51 = load i64, ptr %fmtcnt, align 8
  %dec71 = add i64 %51, -1
  store i64 %dec71, ptr %fmtcnt, align 8
  %cmp72 = icmp sge i64 %dec71, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond68
  %52 = phi i1 [ false, %while.cond68 ], [ %cmp72, %land.rhs ]
  br i1 %52, label %while.body74, label %while.end

while.body74:                                     ; preds = %land.end
  %53 = load ptr, ptr %fmt, align 8
  %54 = load i8, ptr %53, align 1
  %conv75 = sext i8 %54 to i32
  %cmp76 = icmp eq i32 %conv75, 41
  br i1 %cmp76, label %if.then78, label %if.else80

if.then78:                                        ; preds = %while.body74
  %55 = load i32, ptr %pcount, align 4
  %dec79 = add i32 %55, -1
  store i32 %dec79, ptr %pcount, align 4
  br label %if.end86

if.else80:                                        ; preds = %while.body74
  %56 = load ptr, ptr %fmt, align 8
  %57 = load i8, ptr %56, align 1
  %conv81 = sext i8 %57 to i32
  %cmp82 = icmp eq i32 %conv81, 40
  br i1 %cmp82, label %if.then84, label %if.end85

if.then84:                                        ; preds = %if.else80
  %58 = load i32, ptr %pcount, align 4
  %inc = add i32 %58, 1
  store i32 %inc, ptr %pcount, align 4
  br label %if.end85

if.end85:                                         ; preds = %if.then84, %if.else80
  br label %if.end86

if.end86:                                         ; preds = %if.end85, %if.then78
  %59 = load ptr, ptr %fmt, align 8
  %incdec.ptr87 = getelementptr i8, ptr %59, i32 1
  store ptr %incdec.ptr87, ptr %fmt, align 8
  br label %while.cond68, !llvm.loop !12

while.end:                                        ; preds = %land.end
  %60 = load ptr, ptr %fmt, align 8
  %61 = load ptr, ptr %keystart, align 8
  %sub.ptr.lhs.cast88 = ptrtoint ptr %60 to i64
  %sub.ptr.rhs.cast89 = ptrtoint ptr %61 to i64
  %sub.ptr.sub90 = sub i64 %sub.ptr.lhs.cast88, %sub.ptr.rhs.cast89
  %sub91 = sub i64 %sub.ptr.sub90, 1
  store i64 %sub91, ptr %keylen, align 8
  %62 = load i64, ptr %fmtcnt, align 8
  %cmp92 = icmp slt i64 %62, 0
  br i1 %cmp92, label %if.then96, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %while.end
  %63 = load i32, ptr %pcount, align 4
  %cmp94 = icmp sgt i32 %63, 0
  br i1 %cmp94, label %if.then96, label %if.end97

if.then96:                                        ; preds = %lor.lhs.false, %while.end
  %64 = load ptr, ptr @PyExc_ValueError, align 8
  call void @PyErr_SetString(ptr noundef %64, ptr noundef @.str.14)
  br label %error

if.end97:                                         ; preds = %lor.lhs.false
  %65 = load ptr, ptr %keystart, align 8
  %66 = load i64, ptr %keylen, align 8
  %call98 = call ptr @PyBytes_FromStringAndSize(ptr noundef %65, i64 noundef %66)
  store ptr %call98, ptr %key, align 8
  %67 = load ptr, ptr %key, align 8
  %cmp99 = icmp eq ptr %67, null
  br i1 %cmp99, label %if.then101, label %if.end102

if.then101:                                       ; preds = %if.end97
  br label %error

if.end102:                                        ; preds = %if.end97
  %68 = load i32, ptr %args_owned, align 4
  %tobool103 = icmp ne i32 %68, 0
  br i1 %tobool103, label %if.then104, label %if.end105

if.then104:                                       ; preds = %if.end102
  %69 = load ptr, ptr %args.addr, align 8
  store ptr %69, ptr %op.addr.i612, align 8
  %70 = load ptr, ptr %op.addr.i612, align 8
  store ptr %70, ptr %op.addr.i621, align 8
  %71 = load ptr, ptr %op.addr.i621, align 8
  %72 = load i64, ptr %71, align 8
  %conv.i = trunc i64 %72 to i32
  %cmp.i622 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i622 to i32
  %tobool.i614 = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i614, label %if.then.i619, label %if.end.i615

if.then.i619:                                     ; preds = %if.then104
  br label %Py_DECREF.exit620

if.end.i615:                                      ; preds = %if.then104
  %73 = load ptr, ptr %op.addr.i612, align 8
  %74 = load i64, ptr %73, align 8
  %dec.i616 = add i64 %74, -1
  store i64 %dec.i616, ptr %73, align 8
  %cmp.i617 = icmp eq i64 %dec.i616, 0
  br i1 %cmp.i617, label %if.then1.i618, label %Py_DECREF.exit620

if.then1.i618:                                    ; preds = %if.end.i615
  %75 = load ptr, ptr %op.addr.i612, align 8
  call void @_Py_Dealloc(ptr noundef %75) #9
  br label %Py_DECREF.exit620

Py_DECREF.exit620:                                ; preds = %if.then1.i618, %if.end.i615, %if.then.i619
  store i32 0, ptr %args_owned, align 4
  br label %if.end105

if.end105:                                        ; preds = %Py_DECREF.exit620, %if.end102
  %76 = load ptr, ptr %dict, align 8
  %77 = load ptr, ptr %key, align 8
  %call106 = call ptr @PyObject_GetItem(ptr noundef %76, ptr noundef %77)
  store ptr %call106, ptr %args.addr, align 8
  %78 = load ptr, ptr %key, align 8
  store ptr %78, ptr %op.addr.i603, align 8
  %79 = load ptr, ptr %op.addr.i603, align 8
  store ptr %79, ptr %op.addr.i623, align 8
  %80 = load ptr, ptr %op.addr.i623, align 8
  %81 = load i64, ptr %80, align 8
  %conv.i624 = trunc i64 %81 to i32
  %cmp.i625 = icmp slt i32 %conv.i624, 0
  %conv1.i626 = zext i1 %cmp.i625 to i32
  %tobool.i605 = icmp ne i32 %conv1.i626, 0
  br i1 %tobool.i605, label %if.then.i610, label %if.end.i606

if.then.i610:                                     ; preds = %if.end105
  br label %Py_DECREF.exit611

if.end.i606:                                      ; preds = %if.end105
  %82 = load ptr, ptr %op.addr.i603, align 8
  %83 = load i64, ptr %82, align 8
  %dec.i607 = add i64 %83, -1
  store i64 %dec.i607, ptr %82, align 8
  %cmp.i608 = icmp eq i64 %dec.i607, 0
  br i1 %cmp.i608, label %if.then1.i609, label %Py_DECREF.exit611

if.then1.i609:                                    ; preds = %if.end.i606
  %84 = load ptr, ptr %op.addr.i603, align 8
  call void @_Py_Dealloc(ptr noundef %84) #9
  br label %Py_DECREF.exit611

Py_DECREF.exit611:                                ; preds = %if.then1.i609, %if.end.i606, %if.then.i610
  %85 = load ptr, ptr %args.addr, align 8
  %cmp107 = icmp eq ptr %85, null
  br i1 %cmp107, label %if.then109, label %if.end110

if.then109:                                       ; preds = %Py_DECREF.exit611
  br label %error

if.end110:                                        ; preds = %Py_DECREF.exit611
  store i32 1, ptr %args_owned, align 4
  store i64 -1, ptr %arglen, align 8
  store i64 -2, ptr %argidx, align 8
  br label %if.end111

if.end111:                                        ; preds = %if.end110, %if.end57
  br label %while.cond112

while.cond112:                                    ; preds = %sw.bb125, %sw.bb123, %sw.bb121, %sw.bb119, %sw.bb, %if.end111
  %86 = load i64, ptr %fmtcnt, align 8
  %dec113 = add i64 %86, -1
  store i64 %dec113, ptr %fmtcnt, align 8
  %cmp114 = icmp sge i64 %dec113, 0
  br i1 %cmp114, label %while.body116, label %while.end127

while.body116:                                    ; preds = %while.cond112
  %87 = load ptr, ptr %fmt, align 8
  %incdec.ptr117 = getelementptr i8, ptr %87, i32 1
  store ptr %incdec.ptr117, ptr %fmt, align 8
  %88 = load i8, ptr %87, align 1
  %conv118 = sext i8 %88 to i32
  store i32 %conv118, ptr %c, align 4
  switch i32 %conv118, label %sw.epilog [
    i32 45, label %sw.bb
    i32 43, label %sw.bb119
    i32 32, label %sw.bb121
    i32 35, label %sw.bb123
    i32 48, label %sw.bb125
  ]

sw.bb:                                            ; preds = %while.body116
  %89 = load i32, ptr %flags, align 4
  %or = or i32 %89, 1
  store i32 %or, ptr %flags, align 4
  br label %while.cond112, !llvm.loop !13

sw.bb119:                                         ; preds = %while.body116
  %90 = load i32, ptr %flags, align 4
  %or120 = or i32 %90, 2
  store i32 %or120, ptr %flags, align 4
  br label %while.cond112, !llvm.loop !13

sw.bb121:                                         ; preds = %while.body116
  %91 = load i32, ptr %flags, align 4
  %or122 = or i32 %91, 4
  store i32 %or122, ptr %flags, align 4
  br label %while.cond112, !llvm.loop !13

sw.bb123:                                         ; preds = %while.body116
  %92 = load i32, ptr %flags, align 4
  %or124 = or i32 %92, 8
  store i32 %or124, ptr %flags, align 4
  br label %while.cond112, !llvm.loop !13

sw.bb125:                                         ; preds = %while.body116
  %93 = load i32, ptr %flags, align 4
  %or126 = or i32 %93, 16
  store i32 %or126, ptr %flags, align 4
  br label %while.cond112, !llvm.loop !13

sw.epilog:                                        ; preds = %while.body116
  br label %while.end127

while.end127:                                     ; preds = %sw.epilog, %while.cond112
  %94 = load i32, ptr %c, align 4
  %cmp128 = icmp eq i32 %94, 42
  br i1 %cmp128, label %if.then130, label %if.else162

if.then130:                                       ; preds = %while.end127
  %95 = load ptr, ptr %args.addr, align 8
  %96 = load i64, ptr %arglen, align 8
  %call131 = call ptr @getnextarg(ptr noundef %95, i64 noundef %96, ptr noundef %argidx)
  store ptr %call131, ptr %v, align 8
  %97 = load ptr, ptr %v, align 8
  %cmp132 = icmp eq ptr %97, null
  br i1 %cmp132, label %if.then134, label %if.end135

if.then134:                                       ; preds = %if.then130
  br label %error

if.end135:                                        ; preds = %if.then130
  %98 = load ptr, ptr %v, align 8
  %call136 = call ptr @Py_TYPE(ptr noundef %98)
  %call137 = call i32 @PyType_HasFeature(ptr noundef %call136, i64 noundef 16777216)
  %tobool138 = icmp ne i32 %call137, 0
  br i1 %tobool138, label %if.end140, label %if.then139

if.then139:                                       ; preds = %if.end135
  %99 = load ptr, ptr @PyExc_TypeError, align 8
  call void @PyErr_SetString(ptr noundef %99, ptr noundef @.str.15)
  br label %error

if.end140:                                        ; preds = %if.end135
  %100 = load ptr, ptr %v, align 8
  %call141 = call i64 @PyLong_AsSsize_t(ptr noundef %100)
  store i64 %call141, ptr %width, align 8
  %101 = load i64, ptr %width, align 8
  %cmp142 = icmp eq i64 %101, -1
  br i1 %cmp142, label %land.lhs.true144, label %if.end148

land.lhs.true144:                                 ; preds = %if.end140
  %call145 = call ptr @PyErr_Occurred()
  %tobool146 = icmp ne ptr %call145, null
  br i1 %tobool146, label %if.then147, label %if.end148

if.then147:                                       ; preds = %land.lhs.true144
  br label %error

if.end148:                                        ; preds = %land.lhs.true144, %if.end140
  %102 = load i64, ptr %width, align 8
  %cmp149 = icmp slt i64 %102, 0
  br i1 %cmp149, label %if.then151, label %if.end154

if.then151:                                       ; preds = %if.end148
  %103 = load i32, ptr %flags, align 4
  %or152 = or i32 %103, 1
  store i32 %or152, ptr %flags, align 4
  %104 = load i64, ptr %width, align 8
  %sub153 = sub i64 0, %104
  store i64 %sub153, ptr %width, align 8
  br label %if.end154

if.end154:                                        ; preds = %if.then151, %if.end148
  %105 = load i64, ptr %fmtcnt, align 8
  %dec155 = add i64 %105, -1
  store i64 %dec155, ptr %fmtcnt, align 8
  %cmp156 = icmp sge i64 %dec155, 0
  br i1 %cmp156, label %if.then158, label %if.end161

if.then158:                                       ; preds = %if.end154
  %106 = load ptr, ptr %fmt, align 8
  %incdec.ptr159 = getelementptr i8, ptr %106, i32 1
  store ptr %incdec.ptr159, ptr %fmt, align 8
  %107 = load i8, ptr %106, align 1
  %conv160 = sext i8 %107 to i32
  store i32 %conv160, ptr %c, align 4
  br label %if.end161

if.end161:                                        ; preds = %if.then158, %if.end154
  br label %if.end202

if.else162:                                       ; preds = %while.end127
  %108 = load i32, ptr %c, align 4
  %cmp163 = icmp sge i32 %108, 0
  br i1 %cmp163, label %land.lhs.true165, label %if.end201

land.lhs.true165:                                 ; preds = %if.else162
  %109 = load i32, ptr %c, align 4
  %and = and i32 %109, 255
  %conv166 = trunc i32 %and to i8
  %idxprom = zext i8 %conv166 to i64
  %arrayidx = getelementptr [256 x i32], ptr @_Py_ctype_table, i64 0, i64 %idxprom
  %110 = load i32, ptr %arrayidx, align 4
  %and167 = and i32 %110, 4
  %tobool168 = icmp ne i32 %and167, 0
  br i1 %tobool168, label %if.then169, label %if.end201

if.then169:                                       ; preds = %land.lhs.true165
  %111 = load i32, ptr %c, align 4
  %sub170 = sub i32 %111, 48
  %conv171 = sext i32 %sub170 to i64
  store i64 %conv171, ptr %width, align 8
  br label %while.cond172

while.cond172:                                    ; preds = %if.end196, %if.then169
  %112 = load i64, ptr %fmtcnt, align 8
  %dec173 = add i64 %112, -1
  store i64 %dec173, ptr %fmtcnt, align 8
  %cmp174 = icmp sge i64 %dec173, 0
  br i1 %cmp174, label %while.body176, label %while.end200

while.body176:                                    ; preds = %while.cond172
  %113 = load ptr, ptr %fmt, align 8
  %incdec.ptr177 = getelementptr i8, ptr %113, i32 1
  store ptr %incdec.ptr177, ptr %fmt, align 8
  %114 = load i8, ptr %113, align 1
  %conv178 = sext i8 %114 to i32
  %and179 = and i32 %conv178, 255
  %conv180 = trunc i32 %and179 to i8
  %conv181 = zext i8 %conv180 to i32
  store i32 %conv181, ptr %c, align 4
  %115 = load i32, ptr %c, align 4
  %and182 = and i32 %115, 255
  %conv183 = trunc i32 %and182 to i8
  %idxprom184 = zext i8 %conv183 to i64
  %arrayidx185 = getelementptr [256 x i32], ptr @_Py_ctype_table, i64 0, i64 %idxprom184
  %116 = load i32, ptr %arrayidx185, align 4
  %and186 = and i32 %116, 4
  %tobool187 = icmp ne i32 %and186, 0
  br i1 %tobool187, label %if.end189, label %if.then188

if.then188:                                       ; preds = %while.body176
  br label %while.end200

if.end189:                                        ; preds = %while.body176
  %117 = load i64, ptr %width, align 8
  %118 = load i32, ptr %c, align 4
  %sub190 = sub i32 %118, 48
  %conv191 = sext i32 %sub190 to i64
  %sub192 = sub i64 9223372036854775807, %conv191
  %div = sdiv i64 %sub192, 10
  %cmp193 = icmp sgt i64 %117, %div
  br i1 %cmp193, label %if.then195, label %if.end196

if.then195:                                       ; preds = %if.end189
  %119 = load ptr, ptr @PyExc_ValueError, align 8
  call void @PyErr_SetString(ptr noundef %119, ptr noundef @.str.16)
  br label %error

if.end196:                                        ; preds = %if.end189
  %120 = load i64, ptr %width, align 8
  %mul = mul i64 %120, 10
  %121 = load i32, ptr %c, align 4
  %sub197 = sub i32 %121, 48
  %conv198 = sext i32 %sub197 to i64
  %add199 = add i64 %mul, %conv198
  store i64 %add199, ptr %width, align 8
  br label %while.cond172, !llvm.loop !14

while.end200:                                     ; preds = %if.then188, %while.cond172
  br label %if.end201

if.end201:                                        ; preds = %while.end200, %land.lhs.true165, %if.else162
  br label %if.end202

if.end202:                                        ; preds = %if.end201, %if.end161
  %122 = load i32, ptr %c, align 4
  %cmp203 = icmp eq i32 %122, 46
  br i1 %cmp203, label %if.then205, label %if.end288

if.then205:                                       ; preds = %if.end202
  store i32 0, ptr %prec, align 4
  %123 = load i64, ptr %fmtcnt, align 8
  %dec206 = add i64 %123, -1
  store i64 %dec206, ptr %fmtcnt, align 8
  %cmp207 = icmp sge i64 %dec206, 0
  br i1 %cmp207, label %if.then209, label %if.end212

if.then209:                                       ; preds = %if.then205
  %124 = load ptr, ptr %fmt, align 8
  %incdec.ptr210 = getelementptr i8, ptr %124, i32 1
  store ptr %incdec.ptr210, ptr %fmt, align 8
  %125 = load i8, ptr %124, align 1
  %conv211 = sext i8 %125 to i32
  store i32 %conv211, ptr %c, align 4
  br label %if.end212

if.end212:                                        ; preds = %if.then209, %if.then205
  %126 = load i32, ptr %c, align 4
  %cmp213 = icmp eq i32 %126, 42
  br i1 %cmp213, label %if.then215, label %if.else245

if.then215:                                       ; preds = %if.end212
  %127 = load ptr, ptr %args.addr, align 8
  %128 = load i64, ptr %arglen, align 8
  %call216 = call ptr @getnextarg(ptr noundef %127, i64 noundef %128, ptr noundef %argidx)
  store ptr %call216, ptr %v, align 8
  %129 = load ptr, ptr %v, align 8
  %cmp217 = icmp eq ptr %129, null
  br i1 %cmp217, label %if.then219, label %if.end220

if.then219:                                       ; preds = %if.then215
  br label %error

if.end220:                                        ; preds = %if.then215
  %130 = load ptr, ptr %v, align 8
  %call221 = call ptr @Py_TYPE(ptr noundef %130)
  %call222 = call i32 @PyType_HasFeature(ptr noundef %call221, i64 noundef 16777216)
  %tobool223 = icmp ne i32 %call222, 0
  br i1 %tobool223, label %if.end225, label %if.then224

if.then224:                                       ; preds = %if.end220
  %131 = load ptr, ptr @PyExc_TypeError, align 8
  call void @PyErr_SetString(ptr noundef %131, ptr noundef @.str.15)
  br label %error

if.end225:                                        ; preds = %if.end220
  %132 = load ptr, ptr %v, align 8
  %call226 = call i32 @PyLong_AsInt(ptr noundef %132)
  store i32 %call226, ptr %prec, align 4
  %133 = load i32, ptr %prec, align 4
  %cmp227 = icmp eq i32 %133, -1
  br i1 %cmp227, label %land.lhs.true229, label %if.end233

land.lhs.true229:                                 ; preds = %if.end225
  %call230 = call ptr @PyErr_Occurred()
  %tobool231 = icmp ne ptr %call230, null
  br i1 %tobool231, label %if.then232, label %if.end233

if.then232:                                       ; preds = %land.lhs.true229
  br label %error

if.end233:                                        ; preds = %land.lhs.true229, %if.end225
  %134 = load i32, ptr %prec, align 4
  %cmp234 = icmp slt i32 %134, 0
  br i1 %cmp234, label %if.then236, label %if.end237

if.then236:                                       ; preds = %if.end233
  store i32 0, ptr %prec, align 4
  br label %if.end237

if.end237:                                        ; preds = %if.then236, %if.end233
  %135 = load i64, ptr %fmtcnt, align 8
  %dec238 = add i64 %135, -1
  store i64 %dec238, ptr %fmtcnt, align 8
  %cmp239 = icmp sge i64 %dec238, 0
  br i1 %cmp239, label %if.then241, label %if.end244

if.then241:                                       ; preds = %if.end237
  %136 = load ptr, ptr %fmt, align 8
  %incdec.ptr242 = getelementptr i8, ptr %136, i32 1
  store ptr %incdec.ptr242, ptr %fmt, align 8
  %137 = load i8, ptr %136, align 1
  %conv243 = sext i8 %137 to i32
  store i32 %conv243, ptr %c, align 4
  br label %if.end244

if.end244:                                        ; preds = %if.then241, %if.end237
  br label %if.end287

if.else245:                                       ; preds = %if.end212
  %138 = load i32, ptr %c, align 4
  %cmp246 = icmp sge i32 %138, 0
  br i1 %cmp246, label %land.lhs.true248, label %if.end286

land.lhs.true248:                                 ; preds = %if.else245
  %139 = load i32, ptr %c, align 4
  %and249 = and i32 %139, 255
  %conv250 = trunc i32 %and249 to i8
  %idxprom251 = zext i8 %conv250 to i64
  %arrayidx252 = getelementptr [256 x i32], ptr @_Py_ctype_table, i64 0, i64 %idxprom251
  %140 = load i32, ptr %arrayidx252, align 4
  %and253 = and i32 %140, 4
  %tobool254 = icmp ne i32 %and253, 0
  br i1 %tobool254, label %if.then255, label %if.end286

if.then255:                                       ; preds = %land.lhs.true248
  %141 = load i32, ptr %c, align 4
  %sub256 = sub i32 %141, 48
  store i32 %sub256, ptr %prec, align 4
  br label %while.cond257

while.cond257:                                    ; preds = %if.end281, %if.then255
  %142 = load i64, ptr %fmtcnt, align 8
  %dec258 = add i64 %142, -1
  store i64 %dec258, ptr %fmtcnt, align 8
  %cmp259 = icmp sge i64 %dec258, 0
  br i1 %cmp259, label %while.body261, label %while.end285

while.body261:                                    ; preds = %while.cond257
  %143 = load ptr, ptr %fmt, align 8
  %incdec.ptr262 = getelementptr i8, ptr %143, i32 1
  store ptr %incdec.ptr262, ptr %fmt, align 8
  %144 = load i8, ptr %143, align 1
  %conv263 = sext i8 %144 to i32
  %and264 = and i32 %conv263, 255
  %conv265 = trunc i32 %and264 to i8
  %conv266 = zext i8 %conv265 to i32
  store i32 %conv266, ptr %c, align 4
  %145 = load i32, ptr %c, align 4
  %and267 = and i32 %145, 255
  %conv268 = trunc i32 %and267 to i8
  %idxprom269 = zext i8 %conv268 to i64
  %arrayidx270 = getelementptr [256 x i32], ptr @_Py_ctype_table, i64 0, i64 %idxprom269
  %146 = load i32, ptr %arrayidx270, align 4
  %and271 = and i32 %146, 4
  %tobool272 = icmp ne i32 %and271, 0
  br i1 %tobool272, label %if.end274, label %if.then273

if.then273:                                       ; preds = %while.body261
  br label %while.end285

if.end274:                                        ; preds = %while.body261
  %147 = load i32, ptr %prec, align 4
  %148 = load i32, ptr %c, align 4
  %sub275 = sub i32 %148, 48
  %sub276 = sub i32 2147483647, %sub275
  %div277 = sdiv i32 %sub276, 10
  %cmp278 = icmp sgt i32 %147, %div277
  br i1 %cmp278, label %if.then280, label %if.end281

if.then280:                                       ; preds = %if.end274
  %149 = load ptr, ptr @PyExc_ValueError, align 8
  call void @PyErr_SetString(ptr noundef %149, ptr noundef @.str.17)
  br label %error

if.end281:                                        ; preds = %if.end274
  %150 = load i32, ptr %prec, align 4
  %mul282 = mul i32 %150, 10
  %151 = load i32, ptr %c, align 4
  %sub283 = sub i32 %151, 48
  %add284 = add i32 %mul282, %sub283
  store i32 %add284, ptr %prec, align 4
  br label %while.cond257, !llvm.loop !15

while.end285:                                     ; preds = %if.then273, %while.cond257
  br label %if.end286

if.end286:                                        ; preds = %while.end285, %land.lhs.true248, %if.else245
  br label %if.end287

if.end287:                                        ; preds = %if.end286, %if.end244
  br label %if.end288

if.end288:                                        ; preds = %if.end287, %if.end202
  %152 = load i64, ptr %fmtcnt, align 8
  %cmp289 = icmp sge i64 %152, 0
  br i1 %cmp289, label %if.then291, label %if.end309

if.then291:                                       ; preds = %if.end288
  %153 = load i32, ptr %c, align 4
  %cmp292 = icmp eq i32 %153, 104
  br i1 %cmp292, label %if.then300, label %lor.lhs.false294

lor.lhs.false294:                                 ; preds = %if.then291
  %154 = load i32, ptr %c, align 4
  %cmp295 = icmp eq i32 %154, 108
  br i1 %cmp295, label %if.then300, label %lor.lhs.false297

lor.lhs.false297:                                 ; preds = %lor.lhs.false294
  %155 = load i32, ptr %c, align 4
  %cmp298 = icmp eq i32 %155, 76
  br i1 %cmp298, label %if.then300, label %if.end308

if.then300:                                       ; preds = %lor.lhs.false297, %lor.lhs.false294, %if.then291
  %156 = load i64, ptr %fmtcnt, align 8
  %dec301 = add i64 %156, -1
  store i64 %dec301, ptr %fmtcnt, align 8
  %cmp302 = icmp sge i64 %dec301, 0
  br i1 %cmp302, label %if.then304, label %if.end307

if.then304:                                       ; preds = %if.then300
  %157 = load ptr, ptr %fmt, align 8
  %incdec.ptr305 = getelementptr i8, ptr %157, i32 1
  store ptr %incdec.ptr305, ptr %fmt, align 8
  %158 = load i8, ptr %157, align 1
  %conv306 = sext i8 %158 to i32
  store i32 %conv306, ptr %c, align 4
  br label %if.end307

if.end307:                                        ; preds = %if.then304, %if.then300
  br label %if.end308

if.end308:                                        ; preds = %if.end307, %lor.lhs.false297
  br label %if.end309

if.end309:                                        ; preds = %if.end308, %if.end288
  %159 = load i64, ptr %fmtcnt, align 8
  %cmp310 = icmp slt i64 %159, 0
  br i1 %cmp310, label %if.then312, label %if.end313

if.then312:                                       ; preds = %if.end309
  %160 = load ptr, ptr @PyExc_ValueError, align 8
  call void @PyErr_SetString(ptr noundef %160, ptr noundef @.str.18)
  br label %error

if.end313:                                        ; preds = %if.end309
  %161 = load ptr, ptr %args.addr, align 8
  %162 = load i64, ptr %arglen, align 8
  %call314 = call ptr @getnextarg(ptr noundef %161, i64 noundef %162, ptr noundef %argidx)
  store ptr %call314, ptr %v, align 8
  %163 = load ptr, ptr %v, align 8
  %cmp315 = icmp eq ptr %163, null
  br i1 %cmp315, label %if.then317, label %if.end318

if.then317:                                       ; preds = %if.end313
  br label %error

if.end318:                                        ; preds = %if.end313
  %164 = load i64, ptr %fmtcnt, align 8
  %cmp319 = icmp eq i64 %164, 0
  br i1 %cmp319, label %if.then321, label %if.end323

if.then321:                                       ; preds = %if.end318
  %overallocate322 = getelementptr inbounds %struct._PyBytesWriter, ptr %writer, i32 0, i32 4
  store i32 0, ptr %overallocate322, align 4
  br label %if.end323

if.end323:                                        ; preds = %if.then321, %if.end318
  store i32 0, ptr %sign, align 4
  store i32 32, ptr %fill, align 4
  %165 = load i32, ptr %c, align 4
  switch i32 %165, label %sw.default433 [
    i32 114, label %sw.bb324
    i32 97, label %sw.bb324
    i32 115, label %sw.bb341
    i32 98, label %sw.bb341
    i32 105, label %sw.bb356
    i32 100, label %sw.bb356
    i32 117, label %sw.bb356
    i32 111, label %sw.bb356
    i32 120, label %sw.bb356
    i32 88, label %sw.bb356
    i32 101, label %sw.bb394
    i32 69, label %sw.bb394
    i32 102, label %sw.bb394
    i32 70, label %sw.bb394
    i32 103, label %sw.bb394
    i32 71, label %sw.bb394
    i32 99, label %sw.bb422
  ]

sw.bb324:                                         ; preds = %if.end323, %if.end323
  %166 = load ptr, ptr %v, align 8
  %call325 = call ptr @PyObject_ASCII(ptr noundef %166)
  store ptr %call325, ptr %temp, align 8
  %167 = load ptr, ptr %temp, align 8
  %cmp326 = icmp eq ptr %167, null
  br i1 %cmp326, label %if.then328, label %if.end329

if.then328:                                       ; preds = %sw.bb324
  br label %error

if.end329:                                        ; preds = %sw.bb324
  %168 = load ptr, ptr %temp, align 8
  %call330 = call ptr @PyUnicode_DATA(ptr noundef %168)
  store ptr %call330, ptr %pbuf, align 8
  %169 = load ptr, ptr %temp, align 8
  %call331 = call i64 @PyUnicode_GET_LENGTH(ptr noundef %169)
  store i64 %call331, ptr %len49, align 8
  %170 = load i32, ptr %prec, align 4
  %cmp332 = icmp sge i32 %170, 0
  br i1 %cmp332, label %land.lhs.true334, label %if.end340

land.lhs.true334:                                 ; preds = %if.end329
  %171 = load i64, ptr %len49, align 8
  %172 = load i32, ptr %prec, align 4
  %conv335 = sext i32 %172 to i64
  %cmp336 = icmp sgt i64 %171, %conv335
  br i1 %cmp336, label %if.then338, label %if.end340

if.then338:                                       ; preds = %land.lhs.true334
  %173 = load i32, ptr %prec, align 4
  %conv339 = sext i32 %173 to i64
  store i64 %conv339, ptr %len49, align 8
  br label %if.end340

if.end340:                                        ; preds = %if.then338, %land.lhs.true334, %if.end329
  br label %sw.epilog439

sw.bb341:                                         ; preds = %if.end323, %if.end323
  %174 = load ptr, ptr %v, align 8
  %call342 = call ptr @format_obj(ptr noundef %174, ptr noundef %pbuf, ptr noundef %len49)
  store ptr %call342, ptr %temp, align 8
  %175 = load ptr, ptr %temp, align 8
  %cmp343 = icmp eq ptr %175, null
  br i1 %cmp343, label %if.then345, label %if.end346

if.then345:                                       ; preds = %sw.bb341
  br label %error

if.end346:                                        ; preds = %sw.bb341
  %176 = load i32, ptr %prec, align 4
  %cmp347 = icmp sge i32 %176, 0
  br i1 %cmp347, label %land.lhs.true349, label %if.end355

land.lhs.true349:                                 ; preds = %if.end346
  %177 = load i64, ptr %len49, align 8
  %178 = load i32, ptr %prec, align 4
  %conv350 = sext i32 %178 to i64
  %cmp351 = icmp sgt i64 %177, %conv350
  br i1 %cmp351, label %if.then353, label %if.end355

if.then353:                                       ; preds = %land.lhs.true349
  %179 = load i32, ptr %prec, align 4
  %conv354 = sext i32 %179 to i64
  store i64 %conv354, ptr %len49, align 8
  br label %if.end355

if.end355:                                        ; preds = %if.then353, %land.lhs.true349, %if.end346
  br label %sw.epilog439

sw.bb356:                                         ; preds = %if.end323, %if.end323, %if.end323, %if.end323, %if.end323, %if.end323
  %180 = load ptr, ptr %v, align 8
  %call357 = call i32 @Py_IS_TYPE(ptr noundef %180, ptr noundef @PyLong_Type)
  %tobool358 = icmp ne i32 %call357, 0
  br i1 %tobool358, label %land.lhs.true359, label %if.end383

land.lhs.true359:                                 ; preds = %sw.bb356
  %181 = load i64, ptr %width, align 8
  %cmp360 = icmp eq i64 %181, -1
  br i1 %cmp360, label %land.lhs.true362, label %if.end383

land.lhs.true362:                                 ; preds = %land.lhs.true359
  %182 = load i32, ptr %prec, align 4
  %cmp363 = icmp eq i32 %182, -1
  br i1 %cmp363, label %land.lhs.true365, label %if.end383

land.lhs.true365:                                 ; preds = %land.lhs.true362
  %183 = load i32, ptr %flags, align 4
  %and366 = and i32 %183, 6
  %tobool367 = icmp ne i32 %and366, 0
  br i1 %tobool367, label %if.end383, label %land.lhs.true368

land.lhs.true368:                                 ; preds = %land.lhs.true365
  %184 = load i32, ptr %c, align 4
  %cmp369 = icmp ne i32 %184, 88
  br i1 %cmp369, label %if.then371, label %if.end383

if.then371:                                       ; preds = %land.lhs.true368
  %185 = load i32, ptr %flags, align 4
  %and372 = and i32 %185, 8
  store i32 %and372, ptr %alternate, align 4
  %186 = load i32, ptr %c, align 4
  switch i32 %186, label %sw.default [
    i32 100, label %sw.bb373
    i32 105, label %sw.bb373
    i32 117, label %sw.bb373
    i32 111, label %sw.bb374
    i32 120, label %sw.bb375
    i32 88, label %sw.bb375
  ]

sw.default:                                       ; preds = %if.then371
  unreachable

sw.bb373:                                         ; preds = %if.then371, %if.then371, %if.then371
  store i32 10, ptr %base, align 4
  br label %sw.epilog376

sw.bb374:                                         ; preds = %if.then371
  store i32 8, ptr %base, align 4
  br label %sw.epilog376

sw.bb375:                                         ; preds = %if.then371, %if.then371
  store i32 16, ptr %base, align 4
  br label %sw.epilog376

sw.epilog376:                                     ; preds = %sw.bb375, %sw.bb374, %sw.bb373
  %min_size = getelementptr inbounds %struct._PyBytesWriter, ptr %writer, i32 0, i32 2
  %187 = load i64, ptr %min_size, align 8
  %sub377 = sub i64 %187, 2
  store i64 %sub377, ptr %min_size, align 8
  %188 = load ptr, ptr %res, align 8
  %189 = load ptr, ptr %v, align 8
  %190 = load i32, ptr %base, align 4
  %191 = load i32, ptr %alternate, align 4
  %call378 = call ptr @_PyLong_FormatBytesWriter(ptr noundef %writer, ptr noundef %188, ptr noundef %189, i32 noundef %190, i32 noundef %191)
  store ptr %call378, ptr %res, align 8
  %192 = load ptr, ptr %res, align 8
  %cmp379 = icmp eq ptr %192, null
  br i1 %cmp379, label %if.then381, label %if.end382

if.then381:                                       ; preds = %sw.epilog376
  br label %error

if.end382:                                        ; preds = %sw.epilog376
  br label %while.cond, !llvm.loop !11

if.end383:                                        ; preds = %land.lhs.true368, %land.lhs.true365, %land.lhs.true362, %land.lhs.true359, %sw.bb356
  %193 = load ptr, ptr %v, align 8
  %194 = load i32, ptr %flags, align 4
  %195 = load i32, ptr %prec, align 4
  %196 = load i32, ptr %c, align 4
  %call384 = call ptr @formatlong(ptr noundef %193, i32 noundef %194, i32 noundef %195, i32 noundef %196)
  store ptr %call384, ptr %temp, align 8
  %197 = load ptr, ptr %temp, align 8
  %tobool385 = icmp ne ptr %197, null
  br i1 %tobool385, label %if.end387, label %if.then386

if.then386:                                       ; preds = %if.end383
  br label %error

if.end387:                                        ; preds = %if.end383
  %198 = load ptr, ptr %temp, align 8
  %call388 = call ptr @PyUnicode_DATA(ptr noundef %198)
  store ptr %call388, ptr %pbuf, align 8
  %199 = load ptr, ptr %temp, align 8
  %call389 = call i64 @PyUnicode_GET_LENGTH(ptr noundef %199)
  store i64 %call389, ptr %len49, align 8
  store i32 1, ptr %sign, align 4
  %200 = load i32, ptr %flags, align 4
  %and390 = and i32 %200, 16
  %tobool391 = icmp ne i32 %and390, 0
  br i1 %tobool391, label %if.then392, label %if.end393

if.then392:                                       ; preds = %if.end387
  store i32 48, ptr %fill, align 4
  br label %if.end393

if.end393:                                        ; preds = %if.then392, %if.end387
  br label %sw.epilog439

sw.bb394:                                         ; preds = %if.end323, %if.end323, %if.end323, %if.end323, %if.end323, %if.end323
  %201 = load i64, ptr %width, align 8
  %cmp395 = icmp eq i64 %201, -1
  br i1 %cmp395, label %land.lhs.true397, label %if.end411

land.lhs.true397:                                 ; preds = %sw.bb394
  %202 = load i32, ptr %prec, align 4
  %cmp398 = icmp eq i32 %202, -1
  br i1 %cmp398, label %land.lhs.true400, label %if.end411

land.lhs.true400:                                 ; preds = %land.lhs.true397
  %203 = load i32, ptr %flags, align 4
  %and401 = and i32 %203, 6
  %tobool402 = icmp ne i32 %and401, 0
  br i1 %tobool402, label %if.end411, label %if.then403

if.then403:                                       ; preds = %land.lhs.true400
  %min_size404 = getelementptr inbounds %struct._PyBytesWriter, ptr %writer, i32 0, i32 2
  %204 = load i64, ptr %min_size404, align 8
  %sub405 = sub i64 %204, 2
  store i64 %sub405, ptr %min_size404, align 8
  %205 = load ptr, ptr %v, align 8
  %206 = load i32, ptr %flags, align 4
  %207 = load i32, ptr %prec, align 4
  %208 = load i32, ptr %c, align 4
  %209 = load ptr, ptr %res, align 8
  %call406 = call ptr @formatfloat(ptr noundef %205, i32 noundef %206, i32 noundef %207, i32 noundef %208, ptr noundef null, ptr noundef %writer, ptr noundef %209)
  store ptr %call406, ptr %res, align 8
  %210 = load ptr, ptr %res, align 8
  %cmp407 = icmp eq ptr %210, null
  br i1 %cmp407, label %if.then409, label %if.end410

if.then409:                                       ; preds = %if.then403
  br label %error

if.end410:                                        ; preds = %if.then403
  br label %while.cond, !llvm.loop !11

if.end411:                                        ; preds = %land.lhs.true400, %land.lhs.true397, %sw.bb394
  %211 = load ptr, ptr %v, align 8
  %212 = load i32, ptr %flags, align 4
  %213 = load i32, ptr %prec, align 4
  %214 = load i32, ptr %c, align 4
  %215 = load ptr, ptr %res, align 8
  %call412 = call ptr @formatfloat(ptr noundef %211, i32 noundef %212, i32 noundef %213, i32 noundef %214, ptr noundef %temp, ptr noundef null, ptr noundef %215)
  %tobool413 = icmp ne ptr %call412, null
  br i1 %tobool413, label %if.end415, label %if.then414

if.then414:                                       ; preds = %if.end411
  br label %error

if.end415:                                        ; preds = %if.end411
  %216 = load ptr, ptr %temp, align 8
  %call416 = call ptr @PyBytes_AS_STRING(ptr noundef %216)
  store ptr %call416, ptr %pbuf, align 8
  %217 = load ptr, ptr %temp, align 8
  %call417 = call i64 @PyBytes_GET_SIZE(ptr noundef %217)
  store i64 %call417, ptr %len49, align 8
  store i32 1, ptr %sign, align 4
  %218 = load i32, ptr %flags, align 4
  %and418 = and i32 %218, 16
  %tobool419 = icmp ne i32 %and418, 0
  br i1 %tobool419, label %if.then420, label %if.end421

if.then420:                                       ; preds = %if.end415
  store i32 48, ptr %fill, align 4
  br label %if.end421

if.end421:                                        ; preds = %if.then420, %if.end415
  br label %sw.epilog439

sw.bb422:                                         ; preds = %if.end323
  store ptr %onechar, ptr %pbuf, align 8
  %219 = load ptr, ptr %v, align 8
  %call423 = call i32 @byte_converter(ptr noundef %219, ptr noundef %onechar)
  %conv424 = sext i32 %call423 to i64
  store i64 %conv424, ptr %len49, align 8
  %220 = load i64, ptr %len49, align 8
  %tobool425 = icmp ne i64 %220, 0
  br i1 %tobool425, label %if.end427, label %if.then426

if.then426:                                       ; preds = %sw.bb422
  br label %error

if.end427:                                        ; preds = %sw.bb422
  %221 = load i64, ptr %width, align 8
  %cmp428 = icmp eq i64 %221, -1
  br i1 %cmp428, label %if.then430, label %if.end432

if.then430:                                       ; preds = %if.end427
  %222 = load i8, ptr %onechar, align 1
  %223 = load ptr, ptr %res, align 8
  %incdec.ptr431 = getelementptr i8, ptr %223, i32 1
  store ptr %incdec.ptr431, ptr %res, align 8
  store i8 %222, ptr %223, align 1
  br label %while.cond, !llvm.loop !11

if.end432:                                        ; preds = %if.end427
  br label %sw.epilog439

sw.default433:                                    ; preds = %if.end323
  %224 = load ptr, ptr @PyExc_ValueError, align 8
  %225 = load i32, ptr %c, align 4
  %226 = load i32, ptr %c, align 4
  %227 = load ptr, ptr %fmt, align 8
  %add.ptr434 = getelementptr i8, ptr %227, i64 -1
  %228 = load ptr, ptr %format.addr, align 8
  %sub.ptr.lhs.cast435 = ptrtoint ptr %add.ptr434 to i64
  %sub.ptr.rhs.cast436 = ptrtoint ptr %228 to i64
  %sub.ptr.sub437 = sub i64 %sub.ptr.lhs.cast435, %sub.ptr.rhs.cast436
  %call438 = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %224, ptr noundef @.str.19, i32 noundef %225, i32 noundef %226, i64 noundef %sub.ptr.sub437)
  br label %error

sw.epilog439:                                     ; preds = %if.end432, %if.end421, %if.end393, %if.end355, %if.end340
  %229 = load i32, ptr %sign, align 4
  %tobool440 = icmp ne i32 %229, 0
  br i1 %tobool440, label %if.then441, label %if.end465

if.then441:                                       ; preds = %sw.epilog439
  %230 = load ptr, ptr %pbuf, align 8
  %231 = load i8, ptr %230, align 1
  %conv442 = sext i8 %231 to i32
  %cmp443 = icmp eq i32 %conv442, 45
  br i1 %cmp443, label %if.then449, label %lor.lhs.false445

lor.lhs.false445:                                 ; preds = %if.then441
  %232 = load ptr, ptr %pbuf, align 8
  %233 = load i8, ptr %232, align 1
  %conv446 = sext i8 %233 to i32
  %cmp447 = icmp eq i32 %conv446, 43
  br i1 %cmp447, label %if.then449, label %if.else453

if.then449:                                       ; preds = %lor.lhs.false445, %if.then441
  %234 = load ptr, ptr %pbuf, align 8
  %incdec.ptr450 = getelementptr i8, ptr %234, i32 1
  store ptr %incdec.ptr450, ptr %pbuf, align 8
  %235 = load i8, ptr %234, align 1
  %conv451 = sext i8 %235 to i32
  store i32 %conv451, ptr %sign, align 4
  %236 = load i64, ptr %len49, align 8
  %dec452 = add i64 %236, -1
  store i64 %dec452, ptr %len49, align 8
  br label %if.end464

if.else453:                                       ; preds = %lor.lhs.false445
  %237 = load i32, ptr %flags, align 4
  %and454 = and i32 %237, 2
  %tobool455 = icmp ne i32 %and454, 0
  br i1 %tobool455, label %if.then456, label %if.else457

if.then456:                                       ; preds = %if.else453
  store i32 43, ptr %sign, align 4
  br label %if.end463

if.else457:                                       ; preds = %if.else453
  %238 = load i32, ptr %flags, align 4
  %and458 = and i32 %238, 4
  %tobool459 = icmp ne i32 %and458, 0
  br i1 %tobool459, label %if.then460, label %if.else461

if.then460:                                       ; preds = %if.else457
  store i32 32, ptr %sign, align 4
  br label %if.end462

if.else461:                                       ; preds = %if.else457
  store i32 0, ptr %sign, align 4
  br label %if.end462

if.end462:                                        ; preds = %if.else461, %if.then460
  br label %if.end463

if.end463:                                        ; preds = %if.end462, %if.then456
  br label %if.end464

if.end464:                                        ; preds = %if.end463, %if.then449
  br label %if.end465

if.end465:                                        ; preds = %if.end464, %sw.epilog439
  %239 = load i64, ptr %width, align 8
  %240 = load i64, ptr %len49, align 8
  %cmp466 = icmp slt i64 %239, %240
  br i1 %cmp466, label %if.then468, label %if.end469

if.then468:                                       ; preds = %if.end465
  %241 = load i64, ptr %len49, align 8
  store i64 %241, ptr %width, align 8
  br label %if.end469

if.end469:                                        ; preds = %if.then468, %if.end465
  %242 = load i64, ptr %width, align 8
  store i64 %242, ptr %alloc, align 8
  %243 = load i32, ptr %sign, align 4
  %cmp470 = icmp ne i32 %243, 0
  br i1 %cmp470, label %land.lhs.true472, label %if.end477

land.lhs.true472:                                 ; preds = %if.end469
  %244 = load i64, ptr %len49, align 8
  %245 = load i64, ptr %width, align 8
  %cmp473 = icmp eq i64 %244, %245
  br i1 %cmp473, label %if.then475, label %if.end477

if.then475:                                       ; preds = %land.lhs.true472
  %246 = load i64, ptr %alloc, align 8
  %inc476 = add i64 %246, 1
  store i64 %inc476, ptr %alloc, align 8
  br label %if.end477

if.end477:                                        ; preds = %if.then475, %land.lhs.true472, %if.end469
  %247 = load i64, ptr %alloc, align 8
  %cmp478 = icmp sgt i64 %247, 2
  br i1 %cmp478, label %if.then480, label %if.end487

if.then480:                                       ; preds = %if.end477
  %248 = load ptr, ptr %res, align 8
  %249 = load i64, ptr %alloc, align 8
  %sub481 = sub i64 %249, 2
  %call482 = call ptr @_PyBytesWriter_Prepare(ptr noundef %writer, ptr noundef %248, i64 noundef %sub481)
  store ptr %call482, ptr %res, align 8
  %250 = load ptr, ptr %res, align 8
  %cmp483 = icmp eq ptr %250, null
  br i1 %cmp483, label %if.then485, label %if.end486

if.then485:                                       ; preds = %if.then480
  br label %error

if.end486:                                        ; preds = %if.then480
  br label %if.end487

if.end487:                                        ; preds = %if.end486, %if.end477
  %251 = load i32, ptr %sign, align 4
  %tobool488 = icmp ne i32 %251, 0
  br i1 %tobool488, label %if.then489, label %if.end501

if.then489:                                       ; preds = %if.end487
  %252 = load i32, ptr %fill, align 4
  %cmp490 = icmp ne i32 %252, 32
  br i1 %cmp490, label %if.then492, label %if.end495

if.then492:                                       ; preds = %if.then489
  %253 = load i32, ptr %sign, align 4
  %conv493 = trunc i32 %253 to i8
  %254 = load ptr, ptr %res, align 8
  %incdec.ptr494 = getelementptr i8, ptr %254, i32 1
  store ptr %incdec.ptr494, ptr %res, align 8
  store i8 %conv493, ptr %254, align 1
  br label %if.end495

if.end495:                                        ; preds = %if.then492, %if.then489
  %255 = load i64, ptr %width, align 8
  %256 = load i64, ptr %len49, align 8
  %cmp496 = icmp sgt i64 %255, %256
  br i1 %cmp496, label %if.then498, label %if.end500

if.then498:                                       ; preds = %if.end495
  %257 = load i64, ptr %width, align 8
  %dec499 = add i64 %257, -1
  store i64 %dec499, ptr %width, align 8
  br label %if.end500

if.end500:                                        ; preds = %if.then498, %if.end495
  br label %if.end501

if.end501:                                        ; preds = %if.end500, %if.end487
  %258 = load i32, ptr %flags, align 4
  %and502 = and i32 %258, 8
  %tobool503 = icmp ne i32 %and502, 0
  br i1 %tobool503, label %land.lhs.true504, label %if.end528

land.lhs.true504:                                 ; preds = %if.end501
  %259 = load i32, ptr %c, align 4
  %cmp505 = icmp eq i32 %259, 111
  br i1 %cmp505, label %if.then513, label %lor.lhs.false507

lor.lhs.false507:                                 ; preds = %land.lhs.true504
  %260 = load i32, ptr %c, align 4
  %cmp508 = icmp eq i32 %260, 120
  br i1 %cmp508, label %if.then513, label %lor.lhs.false510

lor.lhs.false510:                                 ; preds = %lor.lhs.false507
  %261 = load i32, ptr %c, align 4
  %cmp511 = icmp eq i32 %261, 88
  br i1 %cmp511, label %if.then513, label %if.end528

if.then513:                                       ; preds = %lor.lhs.false510, %lor.lhs.false507, %land.lhs.true504
  %262 = load i32, ptr %fill, align 4
  %cmp514 = icmp ne i32 %262, 32
  br i1 %cmp514, label %if.then516, label %if.end521

if.then516:                                       ; preds = %if.then513
  %263 = load ptr, ptr %pbuf, align 8
  %incdec.ptr517 = getelementptr i8, ptr %263, i32 1
  store ptr %incdec.ptr517, ptr %pbuf, align 8
  %264 = load i8, ptr %263, align 1
  %265 = load ptr, ptr %res, align 8
  %incdec.ptr518 = getelementptr i8, ptr %265, i32 1
  store ptr %incdec.ptr518, ptr %res, align 8
  store i8 %264, ptr %265, align 1
  %266 = load ptr, ptr %pbuf, align 8
  %incdec.ptr519 = getelementptr i8, ptr %266, i32 1
  store ptr %incdec.ptr519, ptr %pbuf, align 8
  %267 = load i8, ptr %266, align 1
  %268 = load ptr, ptr %res, align 8
  %incdec.ptr520 = getelementptr i8, ptr %268, i32 1
  store ptr %incdec.ptr520, ptr %res, align 8
  store i8 %267, ptr %268, align 1
  br label %if.end521

if.end521:                                        ; preds = %if.then516, %if.then513
  %269 = load i64, ptr %width, align 8
  %sub522 = sub i64 %269, 2
  store i64 %sub522, ptr %width, align 8
  %270 = load i64, ptr %width, align 8
  %cmp523 = icmp slt i64 %270, 0
  br i1 %cmp523, label %if.then525, label %if.end526

if.then525:                                       ; preds = %if.end521
  store i64 0, ptr %width, align 8
  br label %if.end526

if.end526:                                        ; preds = %if.then525, %if.end521
  %271 = load i64, ptr %len49, align 8
  %sub527 = sub i64 %271, 2
  store i64 %sub527, ptr %len49, align 8
  br label %if.end528

if.end528:                                        ; preds = %if.end526, %lor.lhs.false510, %if.end501
  %272 = load i64, ptr %width, align 8
  %273 = load i64, ptr %len49, align 8
  %cmp529 = icmp sgt i64 %272, %273
  br i1 %cmp529, label %land.lhs.true531, label %if.end538

land.lhs.true531:                                 ; preds = %if.end528
  %274 = load i32, ptr %flags, align 4
  %and532 = and i32 %274, 1
  %tobool533 = icmp ne i32 %and532, 0
  br i1 %tobool533, label %if.end538, label %if.then534

if.then534:                                       ; preds = %land.lhs.true531
  %275 = load ptr, ptr %res, align 8
  %276 = load i32, ptr %fill, align 4
  %277 = trunc i32 %276 to i8
  %278 = load i64, ptr %width, align 8
  %279 = load i64, ptr %len49, align 8
  %sub535 = sub i64 %278, %279
  call void @llvm.memset.p0.i64(ptr align 1 %275, i8 %277, i64 %sub535, i1 false)
  %280 = load i64, ptr %width, align 8
  %281 = load i64, ptr %len49, align 8
  %sub536 = sub i64 %280, %281
  %282 = load ptr, ptr %res, align 8
  %add.ptr537 = getelementptr i8, ptr %282, i64 %sub536
  store ptr %add.ptr537, ptr %res, align 8
  %283 = load i64, ptr %len49, align 8
  store i64 %283, ptr %width, align 8
  br label %if.end538

if.end538:                                        ; preds = %if.then534, %land.lhs.true531, %if.end528
  %284 = load i32, ptr %fill, align 4
  %cmp539 = icmp eq i32 %284, 32
  br i1 %cmp539, label %if.then541, label %if.end564

if.then541:                                       ; preds = %if.end538
  %285 = load i32, ptr %sign, align 4
  %tobool542 = icmp ne i32 %285, 0
  br i1 %tobool542, label %if.then543, label %if.end546

if.then543:                                       ; preds = %if.then541
  %286 = load i32, ptr %sign, align 4
  %conv544 = trunc i32 %286 to i8
  %287 = load ptr, ptr %res, align 8
  %incdec.ptr545 = getelementptr i8, ptr %287, i32 1
  store ptr %incdec.ptr545, ptr %res, align 8
  store i8 %conv544, ptr %287, align 1
  br label %if.end546

if.end546:                                        ; preds = %if.then543, %if.then541
  %288 = load i32, ptr %flags, align 4
  %and547 = and i32 %288, 8
  %tobool548 = icmp ne i32 %and547, 0
  br i1 %tobool548, label %land.lhs.true549, label %if.end563

land.lhs.true549:                                 ; preds = %if.end546
  %289 = load i32, ptr %c, align 4
  %cmp550 = icmp eq i32 %289, 111
  br i1 %cmp550, label %if.then558, label %lor.lhs.false552

lor.lhs.false552:                                 ; preds = %land.lhs.true549
  %290 = load i32, ptr %c, align 4
  %cmp553 = icmp eq i32 %290, 120
  br i1 %cmp553, label %if.then558, label %lor.lhs.false555

lor.lhs.false555:                                 ; preds = %lor.lhs.false552
  %291 = load i32, ptr %c, align 4
  %cmp556 = icmp eq i32 %291, 88
  br i1 %cmp556, label %if.then558, label %if.end563

if.then558:                                       ; preds = %lor.lhs.false555, %lor.lhs.false552, %land.lhs.true549
  %292 = load ptr, ptr %pbuf, align 8
  %incdec.ptr559 = getelementptr i8, ptr %292, i32 1
  store ptr %incdec.ptr559, ptr %pbuf, align 8
  %293 = load i8, ptr %292, align 1
  %294 = load ptr, ptr %res, align 8
  %incdec.ptr560 = getelementptr i8, ptr %294, i32 1
  store ptr %incdec.ptr560, ptr %res, align 8
  store i8 %293, ptr %294, align 1
  %295 = load ptr, ptr %pbuf, align 8
  %incdec.ptr561 = getelementptr i8, ptr %295, i32 1
  store ptr %incdec.ptr561, ptr %pbuf, align 8
  %296 = load i8, ptr %295, align 1
  %297 = load ptr, ptr %res, align 8
  %incdec.ptr562 = getelementptr i8, ptr %297, i32 1
  store ptr %incdec.ptr562, ptr %res, align 8
  store i8 %296, ptr %297, align 1
  br label %if.end563

if.end563:                                        ; preds = %if.then558, %lor.lhs.false555, %if.end546
  br label %if.end564

if.end564:                                        ; preds = %if.end563, %if.end538
  %298 = load ptr, ptr %res, align 8
  %299 = load ptr, ptr %pbuf, align 8
  %300 = load i64, ptr %len49, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %298, ptr align 1 %299, i64 %300, i1 false)
  %301 = load i64, ptr %len49, align 8
  %302 = load ptr, ptr %res, align 8
  %add.ptr565 = getelementptr i8, ptr %302, i64 %301
  store ptr %add.ptr565, ptr %res, align 8
  %303 = load i64, ptr %width, align 8
  %304 = load i64, ptr %len49, align 8
  %cmp566 = icmp sgt i64 %303, %304
  br i1 %cmp566, label %if.then568, label %if.end572

if.then568:                                       ; preds = %if.end564
  %305 = load ptr, ptr %res, align 8
  %306 = load i64, ptr %width, align 8
  %307 = load i64, ptr %len49, align 8
  %sub569 = sub i64 %306, %307
  call void @llvm.memset.p0.i64(ptr align 1 %305, i8 32, i64 %sub569, i1 false)
  %308 = load i64, ptr %width, align 8
  %309 = load i64, ptr %len49, align 8
  %sub570 = sub i64 %308, %309
  %310 = load ptr, ptr %res, align 8
  %add.ptr571 = getelementptr i8, ptr %310, i64 %sub570
  store ptr %add.ptr571, ptr %res, align 8
  br label %if.end572

if.end572:                                        ; preds = %if.then568, %if.end564
  %311 = load ptr, ptr %dict, align 8
  %tobool573 = icmp ne ptr %311, null
  br i1 %tobool573, label %land.lhs.true574, label %if.end578

land.lhs.true574:                                 ; preds = %if.end572
  %312 = load i64, ptr %argidx, align 8
  %313 = load i64, ptr %arglen, align 8
  %cmp575 = icmp slt i64 %312, %313
  br i1 %cmp575, label %if.then577, label %if.end578

if.then577:                                       ; preds = %land.lhs.true574
  %314 = load ptr, ptr @PyExc_TypeError, align 8
  call void @PyErr_SetString(ptr noundef %314, ptr noundef @.str.20)
  %315 = load ptr, ptr %temp, align 8
  call void @Py_XDECREF(ptr noundef %315)
  br label %error

if.end578:                                        ; preds = %land.lhs.true574, %if.end572
  %316 = load ptr, ptr %temp, align 8
  call void @Py_XDECREF(ptr noundef %316)
  br label %if.end579

if.end579:                                        ; preds = %if.end578, %if.end44
  br label %while.cond, !llvm.loop !11

while.end580:                                     ; preds = %while.cond
  %317 = load i64, ptr %argidx, align 8
  %318 = load i64, ptr %arglen, align 8
  %cmp581 = icmp slt i64 %317, %318
  br i1 %cmp581, label %land.lhs.true583, label %if.end586

land.lhs.true583:                                 ; preds = %while.end580
  %319 = load ptr, ptr %dict, align 8
  %tobool584 = icmp ne ptr %319, null
  br i1 %tobool584, label %if.end586, label %if.then585

if.then585:                                       ; preds = %land.lhs.true583
  %320 = load ptr, ptr @PyExc_TypeError, align 8
  call void @PyErr_SetString(ptr noundef %320, ptr noundef @.str.20)
  br label %error

if.end586:                                        ; preds = %land.lhs.true583, %while.end580
  %321 = load i32, ptr %args_owned, align 4
  %tobool587 = icmp ne i32 %321, 0
  br i1 %tobool587, label %if.then588, label %if.end589

if.then588:                                       ; preds = %if.end586
  %322 = load ptr, ptr %args.addr, align 8
  store ptr %322, ptr %op.addr.i594, align 8
  %323 = load ptr, ptr %op.addr.i594, align 8
  store ptr %323, ptr %op.addr.i627, align 8
  %324 = load ptr, ptr %op.addr.i627, align 8
  %325 = load i64, ptr %324, align 8
  %conv.i628 = trunc i64 %325 to i32
  %cmp.i629 = icmp slt i32 %conv.i628, 0
  %conv1.i630 = zext i1 %cmp.i629 to i32
  %tobool.i596 = icmp ne i32 %conv1.i630, 0
  br i1 %tobool.i596, label %if.then.i601, label %if.end.i597

if.then.i601:                                     ; preds = %if.then588
  br label %Py_DECREF.exit602

if.end.i597:                                      ; preds = %if.then588
  %326 = load ptr, ptr %op.addr.i594, align 8
  %327 = load i64, ptr %326, align 8
  %dec.i598 = add i64 %327, -1
  store i64 %dec.i598, ptr %326, align 8
  %cmp.i599 = icmp eq i64 %dec.i598, 0
  br i1 %cmp.i599, label %if.then1.i600, label %Py_DECREF.exit602

if.then1.i600:                                    ; preds = %if.end.i597
  %328 = load ptr, ptr %op.addr.i594, align 8
  call void @_Py_Dealloc(ptr noundef %328) #9
  br label %Py_DECREF.exit602

Py_DECREF.exit602:                                ; preds = %if.then1.i600, %if.end.i597, %if.then.i601
  br label %if.end589

if.end589:                                        ; preds = %Py_DECREF.exit602, %if.end586
  %329 = load ptr, ptr %res, align 8
  %call590 = call ptr @_PyBytesWriter_Finish(ptr noundef %writer, ptr noundef %329)
  store ptr %call590, ptr %retval, align 8
  br label %return

error:                                            ; preds = %if.then585, %if.then577, %if.then485, %sw.default433, %if.then426, %if.then414, %if.then409, %if.then386, %if.then381, %if.then345, %if.then328, %if.then317, %if.then312, %if.then280, %if.then232, %if.then224, %if.then219, %if.then195, %if.then147, %if.then139, %if.then134, %if.then109, %if.then101, %if.then96, %if.then64
  call void @_PyBytesWriter_Dealloc(ptr noundef %writer)
  %330 = load i32, ptr %args_owned, align 4
  %tobool591 = icmp ne i32 %330, 0
  br i1 %tobool591, label %if.then592, label %if.end593

if.then592:                                       ; preds = %error
  %331 = load ptr, ptr %args.addr, align 8
  store ptr %331, ptr %op.addr.i, align 8
  %332 = load ptr, ptr %op.addr.i, align 8
  store ptr %332, ptr %op.addr.i631, align 8
  %333 = load ptr, ptr %op.addr.i631, align 8
  %334 = load i64, ptr %333, align 8
  %conv.i632 = trunc i64 %334 to i32
  %cmp.i633 = icmp slt i32 %conv.i632, 0
  %conv1.i634 = zext i1 %cmp.i633 to i32
  %tobool.i = icmp ne i32 %conv1.i634, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then592
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.then592
  %335 = load ptr, ptr %op.addr.i, align 8
  %336 = load i64, ptr %335, align 8
  %dec.i = add i64 %336, -1
  store i64 %dec.i, ptr %335, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %337 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %337) #9
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  br label %if.end593

if.end593:                                        ; preds = %Py_DECREF.exit, %error
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end593, %if.end589, %if.then3, %if.then
  %338 = load ptr, ptr %retval, align 8
  ret ptr %338
}

declare void @_PyErr_BadInternalCall(ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define internal i32 @PyType_HasFeature(ptr noundef %type, i64 noundef %feature) #0 {
entry:
  %type.addr = alloca ptr, align 8
  %feature.addr = alloca i64, align 8
  %flags = alloca i64, align 8
  store ptr %type, ptr %type.addr, align 8
  store i64 %feature, ptr %feature.addr, align 8
  %0 = load ptr, ptr %type.addr, align 8
  %tp_flags = getelementptr inbounds %struct._typeobject, ptr %0, i32 0, i32 19
  %1 = load i64, ptr %tp_flags, align 8
  store i64 %1, ptr %flags, align 8
  %2 = load i64, ptr %flags, align 8
  %3 = load i64, ptr %feature.addr, align 8
  %and = and i64 %2, %3
  %cmp = icmp ne i64 %and, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define internal ptr @Py_TYPE(ptr noundef %ob) #0 {
entry:
  %ob.addr = alloca ptr, align 8
  store ptr %ob, ptr %ob.addr, align 8
  %0 = load ptr, ptr %ob.addr, align 8
  %ob_type = getelementptr inbounds %struct._object, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %ob_type, align 8
  ret ptr %1
}

; Function Attrs: nounwind uwtable
define internal i64 @PyTuple_GET_SIZE(ptr noundef %op) #0 {
entry:
  %op.addr = alloca ptr, align 8
  %tuple = alloca ptr, align 8
  store ptr %op, ptr %op.addr, align 8
  %0 = load ptr, ptr %op.addr, align 8
  store ptr %0, ptr %tuple, align 8
  %1 = load ptr, ptr %tuple, align 8
  %call = call i64 @Py_SIZE(ptr noundef %1)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @PyObject_TypeCheck(ptr noundef %ob, ptr noundef %type) #0 {
entry:
  %ob.addr = alloca ptr, align 8
  %type.addr = alloca ptr, align 8
  store ptr %ob, ptr %ob.addr, align 8
  store ptr %type, ptr %type.addr, align 8
  %0 = load ptr, ptr %ob.addr, align 8
  %1 = load ptr, ptr %type.addr, align 8
  %call = call i32 @Py_IS_TYPE(ptr noundef %0, ptr noundef %1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %2 = load ptr, ptr %ob.addr, align 8
  %call1 = call ptr @Py_TYPE(ptr noundef %2)
  %3 = load ptr, ptr %type.addr, align 8
  %call2 = call i32 @PyType_IsSubtype(ptr noundef %call1, ptr noundef %3)
  %tobool3 = icmp ne i32 %call2, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %4 = phi i1 [ true, %entry ], [ %tobool3, %lor.rhs ]
  %lor.ext = zext i1 %4 to i32
  ret i32 %lor.ext
}

; Function Attrs: nounwind willreturn memory(read)
declare ptr @memchr(ptr noundef, i32 noundef, i64 noundef) #3

declare ptr @PyObject_GetItem(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @getnextarg(ptr noundef %args, i64 noundef %arglen, ptr noundef %p_argidx) #0 {
entry:
  %retval = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %arglen.addr = alloca i64, align 8
  %p_argidx.addr = alloca ptr, align 8
  %argidx = alloca i64, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %arglen, ptr %arglen.addr, align 8
  store ptr %p_argidx, ptr %p_argidx.addr, align 8
  %0 = load ptr, ptr %p_argidx.addr, align 8
  %1 = load i64, ptr %0, align 8
  store i64 %1, ptr %argidx, align 8
  %2 = load i64, ptr %argidx, align 8
  %3 = load i64, ptr %arglen.addr, align 8
  %cmp = icmp slt i64 %2, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr %p_argidx.addr, align 8
  %5 = load i64, ptr %4, align 8
  %inc = add i64 %5, 1
  store i64 %inc, ptr %4, align 8
  %6 = load i64, ptr %arglen.addr, align 8
  %cmp1 = icmp slt i64 %6, 0
  br i1 %cmp1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  %7 = load ptr, ptr %args.addr, align 8
  store ptr %7, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %if.then
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %argidx, align 8
  %call = call ptr @PyTuple_GetItem(ptr noundef %8, i64 noundef %9)
  store ptr %call, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %10 = load ptr, ptr @PyExc_TypeError, align 8
  call void @PyErr_SetString(ptr noundef %10, ptr noundef @.str.38)
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.else, %if.then2
  %11 = load ptr, ptr %retval, align 8
  ret ptr %11
}

declare i64 @PyLong_AsSsize_t(ptr noundef) #1

declare ptr @PyErr_Occurred() #1

declare i32 @PyLong_AsInt(ptr noundef) #1

declare ptr @PyObject_ASCII(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @PyUnicode_DATA(ptr noundef %op) #0 {
entry:
  %retval = alloca ptr, align 8
  %op.addr = alloca ptr, align 8
  store ptr %op, ptr %op.addr, align 8
  %0 = load ptr, ptr %op.addr, align 8
  %call = call i32 @PyUnicode_IS_COMPACT(ptr noundef %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %op.addr, align 8
  %call1 = call ptr @_PyUnicode_COMPACT_DATA(ptr noundef %1)
  store ptr %call1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %op.addr, align 8
  %call2 = call ptr @_PyUnicode_NONCOMPACT_DATA(ptr noundef %2)
  store ptr %call2, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load ptr, ptr %retval, align 8
  ret ptr %3
}

; Function Attrs: nounwind uwtable
define internal i64 @PyUnicode_GET_LENGTH(ptr noundef %op) #0 {
entry:
  %op.addr = alloca ptr, align 8
  store ptr %op, ptr %op.addr, align 8
  %0 = load ptr, ptr %op.addr, align 8
  %length = getelementptr inbounds %struct.PyASCIIObject, ptr %0, i32 0, i32 1
  %1 = load i64, ptr %length, align 8
  ret i64 %1
}

; Function Attrs: nounwind uwtable
define internal ptr @format_obj(ptr noundef %v, ptr noundef %pbuf, ptr noundef %plen) #0 {
entry:
  %op.addr.i52 = alloca ptr, align 8
  %op.addr.i50 = alloca ptr, align 8
  %op.addr.i41 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %v.addr = alloca ptr, align 8
  %pbuf.addr = alloca ptr, align 8
  %plen.addr = alloca ptr, align 8
  %func = alloca ptr, align 8
  %result = alloca ptr, align 8
  store ptr %v, ptr %v.addr, align 8
  store ptr %pbuf, ptr %pbuf.addr, align 8
  store ptr %plen, ptr %plen.addr, align 8
  %0 = load ptr, ptr %v.addr, align 8
  %call = call ptr @Py_TYPE(ptr noundef %0)
  %call1 = call i32 @PyType_HasFeature(ptr noundef %call, i64 noundef 134217728)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %v.addr, align 8
  %call2 = call ptr @PyBytes_AS_STRING(ptr noundef %1)
  %2 = load ptr, ptr %pbuf.addr, align 8
  store ptr %call2, ptr %2, align 8
  %3 = load ptr, ptr %v.addr, align 8
  %call3 = call i64 @PyBytes_GET_SIZE(ptr noundef %3)
  %4 = load ptr, ptr %plen.addr, align 8
  store i64 %call3, ptr %4, align 8
  %5 = load ptr, ptr %v.addr, align 8
  %call4 = call ptr @_Py_NewRef(ptr noundef %5)
  store ptr %call4, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %6 = load ptr, ptr %v.addr, align 8
  %call5 = call i32 @PyObject_TypeCheck(ptr noundef %6, ptr noundef @PyByteArray_Type)
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %if.then7, label %if.end11

if.then7:                                         ; preds = %if.end
  %7 = load ptr, ptr %v.addr, align 8
  %call8 = call ptr @PyByteArray_AS_STRING(ptr noundef %7)
  %8 = load ptr, ptr %pbuf.addr, align 8
  store ptr %call8, ptr %8, align 8
  %9 = load ptr, ptr %v.addr, align 8
  %call9 = call i64 @PyByteArray_GET_SIZE(ptr noundef %9)
  %10 = load ptr, ptr %plen.addr, align 8
  store i64 %call9, ptr %10, align 8
  %11 = load ptr, ptr %v.addr, align 8
  %call10 = call ptr @_Py_NewRef(ptr noundef %11)
  store ptr %call10, ptr %retval, align 8
  br label %return

if.end11:                                         ; preds = %if.end
  %12 = load ptr, ptr %v.addr, align 8
  %call12 = call ptr @_PyObject_LookupSpecial(ptr noundef %12, ptr noundef getelementptr inbounds (%struct.anon.38, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 37), i32 0, i32 3, i32 1, i32 31))
  store ptr %call12, ptr %func, align 8
  %13 = load ptr, ptr %func, align 8
  %cmp = icmp ne ptr %13, null
  br i1 %cmp, label %if.then13, label %if.end27

if.then13:                                        ; preds = %if.end11
  %14 = load ptr, ptr %func, align 8
  %call14 = call ptr @_PyObject_CallNoArgs(ptr noundef %14)
  store ptr %call14, ptr %result, align 8
  %15 = load ptr, ptr %func, align 8
  store ptr %15, ptr %op.addr.i41, align 8
  %16 = load ptr, ptr %op.addr.i41, align 8
  store ptr %16, ptr %op.addr.i50, align 8
  %17 = load ptr, ptr %op.addr.i50, align 8
  %18 = load i64, ptr %17, align 8
  %conv.i = trunc i64 %18 to i32
  %cmp.i51 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i51 to i32
  %tobool.i43 = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i43, label %if.then.i48, label %if.end.i44

if.then.i48:                                      ; preds = %if.then13
  br label %Py_DECREF.exit49

if.end.i44:                                       ; preds = %if.then13
  %19 = load ptr, ptr %op.addr.i41, align 8
  %20 = load i64, ptr %19, align 8
  %dec.i45 = add i64 %20, -1
  store i64 %dec.i45, ptr %19, align 8
  %cmp.i46 = icmp eq i64 %dec.i45, 0
  br i1 %cmp.i46, label %if.then1.i47, label %Py_DECREF.exit49

if.then1.i47:                                     ; preds = %if.end.i44
  %21 = load ptr, ptr %op.addr.i41, align 8
  call void @_Py_Dealloc(ptr noundef %21) #9
  br label %Py_DECREF.exit49

Py_DECREF.exit49:                                 ; preds = %if.then1.i47, %if.end.i44, %if.then.i48
  %22 = load ptr, ptr %result, align 8
  %cmp15 = icmp eq ptr %22, null
  br i1 %cmp15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %Py_DECREF.exit49
  store ptr null, ptr %retval, align 8
  br label %return

if.end17:                                         ; preds = %Py_DECREF.exit49
  %23 = load ptr, ptr %result, align 8
  %call18 = call ptr @Py_TYPE(ptr noundef %23)
  %call19 = call i32 @PyType_HasFeature(ptr noundef %call18, i64 noundef 134217728)
  %tobool20 = icmp ne i32 %call19, 0
  br i1 %tobool20, label %if.end24, label %if.then21

if.then21:                                        ; preds = %if.end17
  %24 = load ptr, ptr @PyExc_TypeError, align 8
  %25 = load ptr, ptr %result, align 8
  %call22 = call ptr @Py_TYPE(ptr noundef %25)
  %tp_name = getelementptr inbounds %struct._typeobject, ptr %call22, i32 0, i32 1
  %26 = load ptr, ptr %tp_name, align 8
  %call23 = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %24, ptr noundef @.str.39, ptr noundef %26)
  %27 = load ptr, ptr %result, align 8
  store ptr %27, ptr %op.addr.i, align 8
  %28 = load ptr, ptr %op.addr.i, align 8
  store ptr %28, ptr %op.addr.i52, align 8
  %29 = load ptr, ptr %op.addr.i52, align 8
  %30 = load i64, ptr %29, align 8
  %conv.i53 = trunc i64 %30 to i32
  %cmp.i54 = icmp slt i32 %conv.i53, 0
  %conv1.i55 = zext i1 %cmp.i54 to i32
  %tobool.i = icmp ne i32 %conv1.i55, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then21
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.then21
  %31 = load ptr, ptr %op.addr.i, align 8
  %32 = load i64, ptr %31, align 8
  %dec.i = add i64 %32, -1
  store i64 %dec.i, ptr %31, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %33 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %33) #9
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  store ptr null, ptr %retval, align 8
  br label %return

if.end24:                                         ; preds = %if.end17
  %34 = load ptr, ptr %result, align 8
  %call25 = call ptr @PyBytes_AS_STRING(ptr noundef %34)
  %35 = load ptr, ptr %pbuf.addr, align 8
  store ptr %call25, ptr %35, align 8
  %36 = load ptr, ptr %result, align 8
  %call26 = call i64 @PyBytes_GET_SIZE(ptr noundef %36)
  %37 = load ptr, ptr %plen.addr, align 8
  store i64 %call26, ptr %37, align 8
  %38 = load ptr, ptr %result, align 8
  store ptr %38, ptr %retval, align 8
  br label %return

if.end27:                                         ; preds = %if.end11
  %39 = load ptr, ptr %v.addr, align 8
  %call28 = call i32 @PyObject_CheckBuffer(ptr noundef %39)
  %tobool29 = icmp ne i32 %call28, 0
  br i1 %tobool29, label %if.then30, label %if.end37

if.then30:                                        ; preds = %if.end27
  %40 = load ptr, ptr %v.addr, align 8
  %call31 = call ptr @_PyBytes_FromBuffer(ptr noundef %40)
  store ptr %call31, ptr %result, align 8
  %41 = load ptr, ptr %result, align 8
  %cmp32 = icmp eq ptr %41, null
  br i1 %cmp32, label %if.then33, label %if.end34

if.then33:                                        ; preds = %if.then30
  store ptr null, ptr %retval, align 8
  br label %return

if.end34:                                         ; preds = %if.then30
  %42 = load ptr, ptr %result, align 8
  %call35 = call ptr @PyBytes_AS_STRING(ptr noundef %42)
  %43 = load ptr, ptr %pbuf.addr, align 8
  store ptr %call35, ptr %43, align 8
  %44 = load ptr, ptr %result, align 8
  %call36 = call i64 @PyBytes_GET_SIZE(ptr noundef %44)
  %45 = load ptr, ptr %plen.addr, align 8
  store i64 %call36, ptr %45, align 8
  %46 = load ptr, ptr %result, align 8
  store ptr %46, ptr %retval, align 8
  br label %return

if.end37:                                         ; preds = %if.end27
  %47 = load ptr, ptr @PyExc_TypeError, align 8
  %48 = load ptr, ptr %v.addr, align 8
  %call38 = call ptr @Py_TYPE(ptr noundef %48)
  %tp_name39 = getelementptr inbounds %struct._typeobject, ptr %call38, i32 0, i32 1
  %49 = load ptr, ptr %tp_name39, align 8
  %call40 = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %47, ptr noundef @.str.40, ptr noundef %49)
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end37, %if.end34, %if.then33, %if.end24, %Py_DECREF.exit, %if.then16, %if.then7, %if.then
  %50 = load ptr, ptr %retval, align 8
  ret ptr %50
}

; Function Attrs: nounwind uwtable
define internal i32 @Py_IS_TYPE(ptr noundef %ob, ptr noundef %type) #0 {
entry:
  %ob.addr = alloca ptr, align 8
  %type.addr = alloca ptr, align 8
  store ptr %ob, ptr %ob.addr, align 8
  store ptr %type, ptr %type.addr, align 8
  %0 = load ptr, ptr %ob.addr, align 8
  %call = call ptr @Py_TYPE(ptr noundef %0)
  %1 = load ptr, ptr %type.addr, align 8
  %cmp = icmp eq ptr %call, %1
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

declare ptr @_PyLong_FormatBytesWriter(ptr noundef, ptr noundef, ptr noundef, i32 noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @formatlong(ptr noundef %v, i32 noundef %flags, i32 noundef %prec, i32 noundef %type) #0 {
entry:
  %op.addr.i32 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %v.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %prec.addr = alloca i32, align 4
  %type.addr = alloca i32, align 4
  %result = alloca ptr, align 8
  %iobj = alloca ptr, align 8
  store ptr %v, ptr %v.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  store i32 %prec, ptr %prec.addr, align 4
  store i32 %type, ptr %type.addr, align 4
  %0 = load i32, ptr %type.addr, align 4
  %cmp = icmp eq i32 %0, 105
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 100, ptr %type.addr, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = load ptr, ptr %v.addr, align 8
  %call = call ptr @Py_TYPE(ptr noundef %1)
  %call1 = call i32 @PyType_HasFeature(ptr noundef %call, i64 noundef 16777216)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %2 = load ptr, ptr %v.addr, align 8
  %3 = load i32, ptr %flags.addr, align 4
  %and = and i32 %3, 8
  %4 = load i32, ptr %prec.addr, align 4
  %5 = load i32, ptr %type.addr, align 4
  %call3 = call ptr @_PyUnicode_FormatLong(ptr noundef %2, i32 noundef %and, i32 noundef %4, i32 noundef %5)
  store ptr %call3, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  %6 = load ptr, ptr %v.addr, align 8
  %call5 = call i32 @PyNumber_Check(ptr noundef %6)
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %if.then7, label %if.end25

if.then7:                                         ; preds = %if.end4
  %7 = load i32, ptr %type.addr, align 4
  %cmp8 = icmp eq i32 %7, 111
  br i1 %cmp8, label %if.then12, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then7
  %8 = load i32, ptr %type.addr, align 4
  %cmp9 = icmp eq i32 %8, 120
  br i1 %cmp9, label %if.then12, label %lor.lhs.false10

lor.lhs.false10:                                  ; preds = %lor.lhs.false
  %9 = load i32, ptr %type.addr, align 4
  %cmp11 = icmp eq i32 %9, 88
  br i1 %cmp11, label %if.then12, label %if.else

if.then12:                                        ; preds = %lor.lhs.false10, %lor.lhs.false, %if.then7
  %10 = load ptr, ptr %v.addr, align 8
  %call13 = call ptr @_PyNumber_Index(ptr noundef %10)
  store ptr %call13, ptr %iobj, align 8
  br label %if.end15

if.else:                                          ; preds = %lor.lhs.false10
  %11 = load ptr, ptr %v.addr, align 8
  %call14 = call ptr @PyNumber_Long(ptr noundef %11)
  store ptr %call14, ptr %iobj, align 8
  br label %if.end15

if.end15:                                         ; preds = %if.else, %if.then12
  %12 = load ptr, ptr %iobj, align 8
  %cmp16 = icmp ne ptr %12, null
  br i1 %cmp16, label %if.then17, label %if.end20

if.then17:                                        ; preds = %if.end15
  %13 = load ptr, ptr %iobj, align 8
  %14 = load i32, ptr %flags.addr, align 4
  %and18 = and i32 %14, 8
  %15 = load i32, ptr %prec.addr, align 4
  %16 = load i32, ptr %type.addr, align 4
  %call19 = call ptr @_PyUnicode_FormatLong(ptr noundef %13, i32 noundef %and18, i32 noundef %15, i32 noundef %16)
  store ptr %call19, ptr %result, align 8
  %17 = load ptr, ptr %iobj, align 8
  store ptr %17, ptr %op.addr.i, align 8
  %18 = load ptr, ptr %op.addr.i, align 8
  store ptr %18, ptr %op.addr.i32, align 8
  %19 = load ptr, ptr %op.addr.i32, align 8
  %20 = load i64, ptr %19, align 8
  %conv.i = trunc i64 %20 to i32
  %cmp.i33 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i33 to i32
  %tobool.i = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then17
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.then17
  %21 = load ptr, ptr %op.addr.i, align 8
  %22 = load i64, ptr %21, align 8
  %dec.i = add i64 %22, -1
  store i64 %dec.i, ptr %21, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %23 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %23) #9
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  %24 = load ptr, ptr %result, align 8
  store ptr %24, ptr %retval, align 8
  br label %return

if.end20:                                         ; preds = %if.end15
  %25 = load ptr, ptr @PyExc_TypeError, align 8
  %call21 = call i32 @PyErr_ExceptionMatches(ptr noundef %25)
  %tobool22 = icmp ne i32 %call21, 0
  br i1 %tobool22, label %if.end24, label %if.then23

if.then23:                                        ; preds = %if.end20
  store ptr null, ptr %retval, align 8
  br label %return

if.end24:                                         ; preds = %if.end20
  br label %if.end25

if.end25:                                         ; preds = %if.end24, %if.end4
  %26 = load ptr, ptr @PyExc_TypeError, align 8
  %27 = load i32, ptr %type.addr, align 4
  %28 = load i32, ptr %type.addr, align 4
  %cmp26 = icmp eq i32 %28, 111
  br i1 %cmp26, label %lor.end, label %lor.lhs.false27

lor.lhs.false27:                                  ; preds = %if.end25
  %29 = load i32, ptr %type.addr, align 4
  %cmp28 = icmp eq i32 %29, 120
  br i1 %cmp28, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false27
  %30 = load i32, ptr %type.addr, align 4
  %cmp29 = icmp eq i32 %30, 88
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false27, %if.end25
  %31 = phi i1 [ true, %lor.lhs.false27 ], [ true, %if.end25 ], [ %cmp29, %lor.rhs ]
  %cond = select i1 %31, ptr @.str.42, ptr @.str.43
  %32 = load ptr, ptr %v.addr, align 8
  %call30 = call ptr @Py_TYPE(ptr noundef %32)
  %tp_name = getelementptr inbounds %struct._typeobject, ptr %call30, i32 0, i32 1
  %33 = load ptr, ptr %tp_name, align 8
  %call31 = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %26, ptr noundef @.str.41, i32 noundef %27, ptr noundef %cond, ptr noundef %33)
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %lor.end, %if.then23, %Py_DECREF.exit, %if.then2
  %34 = load ptr, ptr %retval, align 8
  ret ptr %34
}

; Function Attrs: nounwind uwtable
define internal ptr @formatfloat(ptr noundef %v, i32 noundef %flags, i32 noundef %prec, i32 noundef %type, ptr noundef %p_result, ptr noundef %writer, ptr noundef %str) #0 {
entry:
  %retval = alloca ptr, align 8
  %v.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %prec.addr = alloca i32, align 4
  %type.addr = alloca i32, align 4
  %p_result.addr = alloca ptr, align 8
  %writer.addr = alloca ptr, align 8
  %str.addr = alloca ptr, align 8
  %p = alloca ptr, align 8
  %result = alloca ptr, align 8
  %x = alloca double, align 8
  %len = alloca i64, align 8
  %dtoa_flags = alloca i32, align 4
  store ptr %v, ptr %v.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  store i32 %prec, ptr %prec.addr, align 4
  store i32 %type, ptr %type.addr, align 4
  store ptr %p_result, ptr %p_result.addr, align 8
  store ptr %writer, ptr %writer.addr, align 8
  store ptr %str, ptr %str.addr, align 8
  store i32 0, ptr %dtoa_flags, align 4
  %0 = load ptr, ptr %v.addr, align 8
  %call = call double @PyFloat_AsDouble(ptr noundef %0)
  store double %call, ptr %x, align 8
  %1 = load double, ptr %x, align 8
  %cmp = fcmp oeq double %1, -1.000000e+00
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %call1 = call ptr @PyErr_Occurred()
  %tobool = icmp ne ptr %call1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %2 = load ptr, ptr @PyExc_TypeError, align 8
  %3 = load ptr, ptr %v.addr, align 8
  %call2 = call ptr @Py_TYPE(ptr noundef %3)
  %tp_name = getelementptr inbounds %struct._typeobject, ptr %call2, i32 0, i32 1
  %4 = load ptr, ptr %tp_name, align 8
  %call3 = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %2, ptr noundef @.str.44, ptr noundef %4)
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %5 = load i32, ptr %prec.addr, align 4
  %cmp4 = icmp slt i32 %5, 0
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end
  store i32 6, ptr %prec.addr, align 4
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %if.end
  %6 = load i32, ptr %flags.addr, align 4
  %and = and i32 %6, 8
  %tobool7 = icmp ne i32 %and, 0
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end6
  %7 = load i32, ptr %dtoa_flags, align 4
  %or = or i32 %7, 4
  store i32 %or, ptr %dtoa_flags, align 4
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %if.end6
  %8 = load double, ptr %x, align 8
  %9 = load i32, ptr %type.addr, align 4
  %conv = trunc i32 %9 to i8
  %10 = load i32, ptr %prec.addr, align 4
  %11 = load i32, ptr %dtoa_flags, align 4
  %call10 = call ptr @PyOS_double_to_string(double noundef %8, i8 noundef signext %conv, i32 noundef %10, i32 noundef %11, ptr noundef null)
  store ptr %call10, ptr %p, align 8
  %12 = load ptr, ptr %p, align 8
  %cmp11 = icmp eq ptr %12, null
  br i1 %cmp11, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end9
  store ptr null, ptr %retval, align 8
  br label %return

if.end14:                                         ; preds = %if.end9
  %13 = load ptr, ptr %p, align 8
  %call15 = call i64 @strlen(ptr noundef %13) #8
  store i64 %call15, ptr %len, align 8
  %14 = load ptr, ptr %writer.addr, align 8
  %cmp16 = icmp ne ptr %14, null
  br i1 %cmp16, label %if.then18, label %if.end24

if.then18:                                        ; preds = %if.end14
  %15 = load ptr, ptr %writer.addr, align 8
  %16 = load ptr, ptr %str.addr, align 8
  %17 = load i64, ptr %len, align 8
  %call19 = call ptr @_PyBytesWriter_Prepare(ptr noundef %15, ptr noundef %16, i64 noundef %17)
  store ptr %call19, ptr %str.addr, align 8
  %18 = load ptr, ptr %str.addr, align 8
  %cmp20 = icmp eq ptr %18, null
  br i1 %cmp20, label %if.then22, label %if.end23

if.then22:                                        ; preds = %if.then18
  %19 = load ptr, ptr %p, align 8
  call void @PyMem_Free(ptr noundef %19)
  store ptr null, ptr %retval, align 8
  br label %return

if.end23:                                         ; preds = %if.then18
  %20 = load ptr, ptr %str.addr, align 8
  %21 = load ptr, ptr %p, align 8
  %22 = load i64, ptr %len, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %20, ptr align 1 %21, i64 %22, i1 false)
  %23 = load ptr, ptr %p, align 8
  call void @PyMem_Free(ptr noundef %23)
  %24 = load i64, ptr %len, align 8
  %25 = load ptr, ptr %str.addr, align 8
  %add.ptr = getelementptr i8, ptr %25, i64 %24
  store ptr %add.ptr, ptr %str.addr, align 8
  %26 = load ptr, ptr %str.addr, align 8
  store ptr %26, ptr %retval, align 8
  br label %return

if.end24:                                         ; preds = %if.end14
  %27 = load ptr, ptr %p, align 8
  %28 = load i64, ptr %len, align 8
  %call25 = call ptr @PyBytes_FromStringAndSize(ptr noundef %27, i64 noundef %28)
  store ptr %call25, ptr %result, align 8
  %29 = load ptr, ptr %p, align 8
  call void @PyMem_Free(ptr noundef %29)
  %30 = load ptr, ptr %result, align 8
  %31 = load ptr, ptr %p_result.addr, align 8
  store ptr %30, ptr %31, align 8
  %32 = load ptr, ptr %result, align 8
  %cmp26 = icmp ne ptr %32, null
  br i1 %cmp26, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end24
  %33 = load ptr, ptr %str.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end24
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %33, %cond.true ], [ null, %cond.false ]
  store ptr %cond, ptr %retval, align 8
  br label %return

return:                                           ; preds = %cond.end, %if.end23, %if.then22, %if.then13, %if.then
  %34 = load ptr, ptr %retval, align 8
  ret ptr %34
}

; Function Attrs: nounwind uwtable
define internal ptr @PyBytes_AS_STRING(ptr noundef %op) #0 {
entry:
  %op.addr = alloca ptr, align 8
  store ptr %op, ptr %op.addr, align 8
  %0 = load ptr, ptr %op.addr, align 8
  %ob_sval = getelementptr inbounds %struct.PyBytesObject, ptr %0, i32 0, i32 2
  %arraydecay = getelementptr inbounds [1 x i8], ptr %ob_sval, i64 0, i64 0
  ret ptr %arraydecay
}

; Function Attrs: nounwind uwtable
define internal i64 @PyBytes_GET_SIZE(ptr noundef %op) #0 {
entry:
  %op.addr = alloca ptr, align 8
  %self = alloca ptr, align 8
  store ptr %op, ptr %op.addr, align 8
  %0 = load ptr, ptr %op.addr, align 8
  store ptr %0, ptr %self, align 8
  %1 = load ptr, ptr %self, align 8
  %call = call i64 @Py_SIZE(ptr noundef %1)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @byte_converter(ptr noundef %arg, ptr noundef %p) #0 {
entry:
  %retval = alloca i32, align 4
  %arg.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %overflow = alloca i32, align 4
  %ival = alloca i64, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %call = call ptr @Py_TYPE(ptr noundef %0)
  %call1 = call i32 @PyType_HasFeature(ptr noundef %call, i64 noundef 134217728)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %arg.addr, align 8
  %call2 = call i64 @PyBytes_GET_SIZE(ptr noundef %1)
  %cmp = icmp eq i64 %call2, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %2 = load ptr, ptr %arg.addr, align 8
  %call3 = call ptr @PyBytes_AS_STRING(ptr noundef %2)
  %arrayidx = getelementptr i8, ptr %call3, i64 0
  %3 = load i8, ptr %arrayidx, align 1
  %4 = load ptr, ptr %p.addr, align 8
  store i8 %3, ptr %4, align 1
  store i32 1, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %land.lhs.true, %entry
  %5 = load ptr, ptr %arg.addr, align 8
  %call4 = call i32 @PyObject_TypeCheck(ptr noundef %5, ptr noundef @PyByteArray_Type)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %land.lhs.true6, label %if.else12

land.lhs.true6:                                   ; preds = %if.else
  %6 = load ptr, ptr %arg.addr, align 8
  %call7 = call i64 @PyByteArray_GET_SIZE(ptr noundef %6)
  %cmp8 = icmp eq i64 %call7, 1
  br i1 %cmp8, label %if.then9, label %if.else12

if.then9:                                         ; preds = %land.lhs.true6
  %7 = load ptr, ptr %arg.addr, align 8
  %call10 = call ptr @PyByteArray_AS_STRING(ptr noundef %7)
  %arrayidx11 = getelementptr i8, ptr %call10, i64 0
  %8 = load i8, ptr %arrayidx11, align 1
  %9 = load ptr, ptr %p.addr, align 8
  store i8 %8, ptr %9, align 1
  store i32 1, ptr %retval, align 4
  br label %return

if.else12:                                        ; preds = %land.lhs.true6, %if.else
  %10 = load ptr, ptr %arg.addr, align 8
  %call13 = call i64 @PyLong_AsLongAndOverflow(ptr noundef %10, ptr noundef %overflow)
  store i64 %call13, ptr %ival, align 8
  %11 = load i64, ptr %ival, align 8
  %cmp14 = icmp eq i64 %11, -1
  br i1 %cmp14, label %land.lhs.true15, label %if.end22

land.lhs.true15:                                  ; preds = %if.else12
  %call16 = call ptr @PyErr_Occurred()
  %tobool17 = icmp ne ptr %call16, null
  br i1 %tobool17, label %if.then18, label %if.end22

if.then18:                                        ; preds = %land.lhs.true15
  %12 = load ptr, ptr @PyExc_TypeError, align 8
  %call19 = call i32 @PyErr_ExceptionMatches(ptr noundef %12)
  %tobool20 = icmp ne i32 %call19, 0
  br i1 %tobool20, label %if.then21, label %if.end

if.then21:                                        ; preds = %if.then18
  br label %onError

if.end:                                           ; preds = %if.then18
  store i32 0, ptr %retval, align 4
  br label %return

if.end22:                                         ; preds = %land.lhs.true15, %if.else12
  %13 = load i64, ptr %ival, align 8
  %cmp23 = icmp sle i64 0, %13
  br i1 %cmp23, label %land.lhs.true24, label %if.then26

land.lhs.true24:                                  ; preds = %if.end22
  %14 = load i64, ptr %ival, align 8
  %cmp25 = icmp sle i64 %14, 255
  br i1 %cmp25, label %if.end27, label %if.then26

if.then26:                                        ; preds = %land.lhs.true24, %if.end22
  %15 = load ptr, ptr @PyExc_OverflowError, align 8
  call void @PyErr_SetString(ptr noundef %15, ptr noundef @.str.45)
  store i32 0, ptr %retval, align 4
  br label %return

if.end27:                                         ; preds = %land.lhs.true24
  %16 = load i64, ptr %ival, align 8
  %conv = trunc i64 %16 to i8
  %17 = load ptr, ptr %p.addr, align 8
  store i8 %conv, ptr %17, align 1
  store i32 1, ptr %retval, align 4
  br label %return

onError:                                          ; preds = %if.then21
  %18 = load ptr, ptr @PyExc_TypeError, align 8
  call void @PyErr_SetString(ptr noundef %18, ptr noundef @.str.46)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %onError, %if.end27, %if.then26, %if.end, %if.then9, %if.then
  %19 = load i32, ptr %retval, align 4
  ret i32 %19
}

declare ptr @PyErr_Format(ptr noundef, ptr noundef, ...) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @_PyBytesWriter_Prepare(ptr noundef %writer, ptr noundef %str, i64 noundef %size) #0 {
entry:
  %retval = alloca ptr, align 8
  %writer.addr = alloca ptr, align 8
  %str.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %new_min_size = alloca i64, align 8
  store ptr %writer, ptr %writer.addr, align 8
  store ptr %str, ptr %str.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load i64, ptr %size.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %str.addr, align 8
  store ptr %1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %writer.addr, align 8
  %min_size = getelementptr inbounds %struct._PyBytesWriter, ptr %2, i32 0, i32 2
  %3 = load i64, ptr %min_size, align 8
  %4 = load i64, ptr %size.addr, align 8
  %sub = sub i64 9223372036854775807, %4
  %cmp1 = icmp sgt i64 %3, %sub
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %call = call ptr @PyErr_NoMemory()
  %5 = load ptr, ptr %writer.addr, align 8
  call void @_PyBytesWriter_Dealloc(ptr noundef %5)
  store ptr null, ptr %retval, align 8
  br label %return

if.end3:                                          ; preds = %if.end
  %6 = load ptr, ptr %writer.addr, align 8
  %min_size4 = getelementptr inbounds %struct._PyBytesWriter, ptr %6, i32 0, i32 2
  %7 = load i64, ptr %min_size4, align 8
  %8 = load i64, ptr %size.addr, align 8
  %add = add i64 %7, %8
  store i64 %add, ptr %new_min_size, align 8
  %9 = load i64, ptr %new_min_size, align 8
  %10 = load ptr, ptr %writer.addr, align 8
  %allocated = getelementptr inbounds %struct._PyBytesWriter, ptr %10, i32 0, i32 1
  %11 = load i64, ptr %allocated, align 8
  %cmp5 = icmp sgt i64 %9, %11
  br i1 %cmp5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end3
  %12 = load ptr, ptr %writer.addr, align 8
  %13 = load ptr, ptr %str.addr, align 8
  %14 = load i64, ptr %new_min_size, align 8
  %call7 = call ptr @_PyBytesWriter_Resize(ptr noundef %12, ptr noundef %13, i64 noundef %14)
  store ptr %call7, ptr %str.addr, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %if.end3
  %15 = load i64, ptr %new_min_size, align 8
  %16 = load ptr, ptr %writer.addr, align 8
  %min_size9 = getelementptr inbounds %struct._PyBytesWriter, ptr %16, i32 0, i32 2
  store i64 %15, ptr %min_size9, align 8
  %17 = load ptr, ptr %str.addr, align 8
  store ptr %17, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end8, %if.then2, %if.then
  %18 = load ptr, ptr %retval, align 8
  ret ptr %18
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #6

; Function Attrs: nounwind uwtable
define internal void @Py_XDECREF(ptr noundef %op) #0 {
entry:
  %op.addr.i1 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %op.addr = alloca ptr, align 8
  store ptr %op, ptr %op.addr, align 8
  %0 = load ptr, ptr %op.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %op.addr, align 8
  store ptr %1, ptr %op.addr.i, align 8
  %2 = load ptr, ptr %op.addr.i, align 8
  store ptr %2, ptr %op.addr.i1, align 8
  %3 = load ptr, ptr %op.addr.i1, align 8
  %4 = load i64, ptr %3, align 8
  %conv.i = trunc i64 %4 to i32
  %cmp.i2 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i2 to i32
  %tobool.i = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.then
  %5 = load ptr, ptr %op.addr.i, align 8
  %6 = load i64, ptr %5, align 8
  %dec.i = add i64 %6, -1
  store i64 %dec.i, ptr %5, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %7 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %7) #9
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  br label %if.end

if.end:                                           ; preds = %Py_DECREF.exit, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local ptr @_PyBytes_DecodeEscape(ptr noundef %s, i64 noundef %len, ptr noundef %errors, ptr noundef %first_invalid_escape) #0 {
entry:
  %retval = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  %errors.addr = alloca ptr, align 8
  %first_invalid_escape.addr = alloca ptr, align 8
  %c = alloca i32, align 4
  %p = alloca ptr, align 8
  %end = alloca ptr, align 8
  %writer = alloca %struct._PyBytesWriter, align 8
  %digit1 = alloca i32, align 4
  %digit2 = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  store ptr %errors, ptr %errors.addr, align 8
  store ptr %first_invalid_escape, ptr %first_invalid_escape.addr, align 8
  call void @_PyBytesWriter_Init(ptr noundef %writer)
  %0 = load i64, ptr %len.addr, align 8
  %call = call ptr @_PyBytesWriter_Alloc(ptr noundef %writer, i64 noundef %0)
  store ptr %call, ptr %p, align 8
  %1 = load ptr, ptr %p, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %overallocate = getelementptr inbounds %struct._PyBytesWriter, ptr %writer, i32 0, i32 4
  store i32 1, ptr %overallocate, align 4
  %2 = load ptr, ptr %first_invalid_escape.addr, align 8
  store ptr null, ptr %2, align 8
  %3 = load ptr, ptr %s.addr, align 8
  %4 = load i64, ptr %len.addr, align 8
  %add.ptr = getelementptr i8, ptr %3, i64 %4
  store ptr %add.ptr, ptr %end, align 8
  br label %while.cond

while.cond:                                       ; preds = %sw.epilog, %if.then4, %if.end
  %5 = load ptr, ptr %s.addr, align 8
  %6 = load ptr, ptr %end, align 8
  %cmp1 = icmp ult ptr %5, %6
  br i1 %cmp1, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %7 = load ptr, ptr %s.addr, align 8
  %8 = load i8, ptr %7, align 1
  %conv = sext i8 %8 to i32
  %cmp2 = icmp ne i32 %conv, 92
  br i1 %cmp2, label %if.then4, label %if.end6

if.then4:                                         ; preds = %while.body
  %9 = load ptr, ptr %s.addr, align 8
  %incdec.ptr = getelementptr i8, ptr %9, i32 1
  store ptr %incdec.ptr, ptr %s.addr, align 8
  %10 = load i8, ptr %9, align 1
  %11 = load ptr, ptr %p, align 8
  %incdec.ptr5 = getelementptr i8, ptr %11, i32 1
  store ptr %incdec.ptr5, ptr %p, align 8
  store i8 %10, ptr %11, align 1
  br label %while.cond, !llvm.loop !16

if.end6:                                          ; preds = %while.body
  %12 = load ptr, ptr %s.addr, align 8
  %incdec.ptr7 = getelementptr i8, ptr %12, i32 1
  store ptr %incdec.ptr7, ptr %s.addr, align 8
  %13 = load ptr, ptr %s.addr, align 8
  %14 = load ptr, ptr %end, align 8
  %cmp8 = icmp eq ptr %13, %14
  br i1 %cmp8, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end6
  %15 = load ptr, ptr @PyExc_ValueError, align 8
  call void @PyErr_SetString(ptr noundef %15, ptr noundef @.str.21)
  br label %failed

if.end11:                                         ; preds = %if.end6
  %16 = load ptr, ptr %s.addr, align 8
  %incdec.ptr12 = getelementptr i8, ptr %16, i32 1
  store ptr %incdec.ptr12, ptr %s.addr, align 8
  %17 = load i8, ptr %16, align 1
  %conv13 = sext i8 %17 to i32
  switch i32 %conv13, label %sw.default [
    i32 10, label %sw.bb
    i32 92, label %sw.bb14
    i32 39, label %sw.bb16
    i32 34, label %sw.bb18
    i32 98, label %sw.bb20
    i32 102, label %sw.bb22
    i32 116, label %sw.bb24
    i32 110, label %sw.bb26
    i32 114, label %sw.bb28
    i32 118, label %sw.bb30
    i32 97, label %sw.bb32
    i32 48, label %sw.bb34
    i32 49, label %sw.bb34
    i32 50, label %sw.bb34
    i32 51, label %sw.bb34
    i32 52, label %sw.bb34
    i32 53, label %sw.bb34
    i32 54, label %sw.bb34
    i32 55, label %sw.bb34
    i32 120, label %sw.bb78
  ]

sw.bb:                                            ; preds = %if.end11
  br label %sw.epilog

sw.bb14:                                          ; preds = %if.end11
  %18 = load ptr, ptr %p, align 8
  %incdec.ptr15 = getelementptr i8, ptr %18, i32 1
  store ptr %incdec.ptr15, ptr %p, align 8
  store i8 92, ptr %18, align 1
  br label %sw.epilog

sw.bb16:                                          ; preds = %if.end11
  %19 = load ptr, ptr %p, align 8
  %incdec.ptr17 = getelementptr i8, ptr %19, i32 1
  store ptr %incdec.ptr17, ptr %p, align 8
  store i8 39, ptr %19, align 1
  br label %sw.epilog

sw.bb18:                                          ; preds = %if.end11
  %20 = load ptr, ptr %p, align 8
  %incdec.ptr19 = getelementptr i8, ptr %20, i32 1
  store ptr %incdec.ptr19, ptr %p, align 8
  store i8 34, ptr %20, align 1
  br label %sw.epilog

sw.bb20:                                          ; preds = %if.end11
  %21 = load ptr, ptr %p, align 8
  %incdec.ptr21 = getelementptr i8, ptr %21, i32 1
  store ptr %incdec.ptr21, ptr %p, align 8
  store i8 8, ptr %21, align 1
  br label %sw.epilog

sw.bb22:                                          ; preds = %if.end11
  %22 = load ptr, ptr %p, align 8
  %incdec.ptr23 = getelementptr i8, ptr %22, i32 1
  store ptr %incdec.ptr23, ptr %p, align 8
  store i8 12, ptr %22, align 1
  br label %sw.epilog

sw.bb24:                                          ; preds = %if.end11
  %23 = load ptr, ptr %p, align 8
  %incdec.ptr25 = getelementptr i8, ptr %23, i32 1
  store ptr %incdec.ptr25, ptr %p, align 8
  store i8 9, ptr %23, align 1
  br label %sw.epilog

sw.bb26:                                          ; preds = %if.end11
  %24 = load ptr, ptr %p, align 8
  %incdec.ptr27 = getelementptr i8, ptr %24, i32 1
  store ptr %incdec.ptr27, ptr %p, align 8
  store i8 10, ptr %24, align 1
  br label %sw.epilog

sw.bb28:                                          ; preds = %if.end11
  %25 = load ptr, ptr %p, align 8
  %incdec.ptr29 = getelementptr i8, ptr %25, i32 1
  store ptr %incdec.ptr29, ptr %p, align 8
  store i8 13, ptr %25, align 1
  br label %sw.epilog

sw.bb30:                                          ; preds = %if.end11
  %26 = load ptr, ptr %p, align 8
  %incdec.ptr31 = getelementptr i8, ptr %26, i32 1
  store ptr %incdec.ptr31, ptr %p, align 8
  store i8 11, ptr %26, align 1
  br label %sw.epilog

sw.bb32:                                          ; preds = %if.end11
  %27 = load ptr, ptr %p, align 8
  %incdec.ptr33 = getelementptr i8, ptr %27, i32 1
  store ptr %incdec.ptr33, ptr %p, align 8
  store i8 7, ptr %27, align 1
  br label %sw.epilog

sw.bb34:                                          ; preds = %if.end11, %if.end11, %if.end11, %if.end11, %if.end11, %if.end11, %if.end11, %if.end11
  %28 = load ptr, ptr %s.addr, align 8
  %arrayidx = getelementptr i8, ptr %28, i64 -1
  %29 = load i8, ptr %arrayidx, align 1
  %conv35 = sext i8 %29 to i32
  %sub = sub i32 %conv35, 48
  store i32 %sub, ptr %c, align 4
  %30 = load ptr, ptr %s.addr, align 8
  %31 = load ptr, ptr %end, align 8
  %cmp36 = icmp ult ptr %30, %31
  br i1 %cmp36, label %land.lhs.true, label %if.end66

land.lhs.true:                                    ; preds = %sw.bb34
  %32 = load ptr, ptr %s.addr, align 8
  %33 = load i8, ptr %32, align 1
  %conv38 = sext i8 %33 to i32
  %cmp39 = icmp sle i32 48, %conv38
  br i1 %cmp39, label %land.lhs.true41, label %if.end66

land.lhs.true41:                                  ; preds = %land.lhs.true
  %34 = load ptr, ptr %s.addr, align 8
  %35 = load i8, ptr %34, align 1
  %conv42 = sext i8 %35 to i32
  %cmp43 = icmp sle i32 %conv42, 55
  br i1 %cmp43, label %if.then45, label %if.end66

if.then45:                                        ; preds = %land.lhs.true41
  %36 = load i32, ptr %c, align 4
  %shl = shl i32 %36, 3
  %37 = load ptr, ptr %s.addr, align 8
  %incdec.ptr46 = getelementptr i8, ptr %37, i32 1
  store ptr %incdec.ptr46, ptr %s.addr, align 8
  %38 = load i8, ptr %37, align 1
  %conv47 = sext i8 %38 to i32
  %add = add i32 %shl, %conv47
  %sub48 = sub i32 %add, 48
  store i32 %sub48, ptr %c, align 4
  %39 = load ptr, ptr %s.addr, align 8
  %40 = load ptr, ptr %end, align 8
  %cmp49 = icmp ult ptr %39, %40
  br i1 %cmp49, label %land.lhs.true51, label %if.end65

land.lhs.true51:                                  ; preds = %if.then45
  %41 = load ptr, ptr %s.addr, align 8
  %42 = load i8, ptr %41, align 1
  %conv52 = sext i8 %42 to i32
  %cmp53 = icmp sle i32 48, %conv52
  br i1 %cmp53, label %land.lhs.true55, label %if.end65

land.lhs.true55:                                  ; preds = %land.lhs.true51
  %43 = load ptr, ptr %s.addr, align 8
  %44 = load i8, ptr %43, align 1
  %conv56 = sext i8 %44 to i32
  %cmp57 = icmp sle i32 %conv56, 55
  br i1 %cmp57, label %if.then59, label %if.end65

if.then59:                                        ; preds = %land.lhs.true55
  %45 = load i32, ptr %c, align 4
  %shl60 = shl i32 %45, 3
  %46 = load ptr, ptr %s.addr, align 8
  %incdec.ptr61 = getelementptr i8, ptr %46, i32 1
  store ptr %incdec.ptr61, ptr %s.addr, align 8
  %47 = load i8, ptr %46, align 1
  %conv62 = sext i8 %47 to i32
  %add63 = add i32 %shl60, %conv62
  %sub64 = sub i32 %add63, 48
  store i32 %sub64, ptr %c, align 4
  br label %if.end65

if.end65:                                         ; preds = %if.then59, %land.lhs.true55, %land.lhs.true51, %if.then45
  br label %if.end66

if.end66:                                         ; preds = %if.end65, %land.lhs.true41, %land.lhs.true, %sw.bb34
  %48 = load i32, ptr %c, align 4
  %cmp67 = icmp sgt i32 %48, 255
  br i1 %cmp67, label %if.then69, label %if.end75

if.then69:                                        ; preds = %if.end66
  %49 = load ptr, ptr %first_invalid_escape.addr, align 8
  %50 = load ptr, ptr %49, align 8
  %cmp70 = icmp eq ptr %50, null
  br i1 %cmp70, label %if.then72, label %if.end74

if.then72:                                        ; preds = %if.then69
  %51 = load ptr, ptr %s.addr, align 8
  %add.ptr73 = getelementptr i8, ptr %51, i64 -3
  %52 = load ptr, ptr %first_invalid_escape.addr, align 8
  store ptr %add.ptr73, ptr %52, align 8
  br label %if.end74

if.end74:                                         ; preds = %if.then72, %if.then69
  br label %if.end75

if.end75:                                         ; preds = %if.end74, %if.end66
  %53 = load i32, ptr %c, align 4
  %conv76 = trunc i32 %53 to i8
  %54 = load ptr, ptr %p, align 8
  %incdec.ptr77 = getelementptr i8, ptr %54, i32 1
  store ptr %incdec.ptr77, ptr %p, align 8
  store i8 %conv76, ptr %54, align 1
  br label %sw.epilog

sw.bb78:                                          ; preds = %if.end11
  %55 = load ptr, ptr %s.addr, align 8
  %add.ptr79 = getelementptr i8, ptr %55, i64 1
  %56 = load ptr, ptr %end, align 8
  %cmp80 = icmp ult ptr %add.ptr79, %56
  br i1 %cmp80, label %if.then82, label %if.end107

if.then82:                                        ; preds = %sw.bb78
  %57 = load ptr, ptr %s.addr, align 8
  %arrayidx83 = getelementptr i8, ptr %57, i64 0
  %58 = load i8, ptr %arrayidx83, align 1
  %conv84 = sext i8 %58 to i32
  %and = and i32 %conv84, 255
  %conv85 = trunc i32 %and to i8
  %idxprom = zext i8 %conv85 to i64
  %arrayidx86 = getelementptr [256 x i8], ptr @_PyLong_DigitValue, i64 0, i64 %idxprom
  %59 = load i8, ptr %arrayidx86, align 1
  %conv87 = zext i8 %59 to i32
  store i32 %conv87, ptr %digit1, align 4
  %60 = load ptr, ptr %s.addr, align 8
  %arrayidx88 = getelementptr i8, ptr %60, i64 1
  %61 = load i8, ptr %arrayidx88, align 1
  %conv89 = sext i8 %61 to i32
  %and90 = and i32 %conv89, 255
  %conv91 = trunc i32 %and90 to i8
  %idxprom92 = zext i8 %conv91 to i64
  %arrayidx93 = getelementptr [256 x i8], ptr @_PyLong_DigitValue, i64 0, i64 %idxprom92
  %62 = load i8, ptr %arrayidx93, align 1
  %conv94 = zext i8 %62 to i32
  store i32 %conv94, ptr %digit2, align 4
  %63 = load i32, ptr %digit1, align 4
  %cmp95 = icmp slt i32 %63, 16
  br i1 %cmp95, label %land.lhs.true97, label %if.end106

land.lhs.true97:                                  ; preds = %if.then82
  %64 = load i32, ptr %digit2, align 4
  %cmp98 = icmp slt i32 %64, 16
  br i1 %cmp98, label %if.then100, label %if.end106

if.then100:                                       ; preds = %land.lhs.true97
  %65 = load i32, ptr %digit1, align 4
  %shl101 = shl i32 %65, 4
  %66 = load i32, ptr %digit2, align 4
  %add102 = add i32 %shl101, %66
  %conv103 = trunc i32 %add102 to i8
  %67 = load ptr, ptr %p, align 8
  %incdec.ptr104 = getelementptr i8, ptr %67, i32 1
  store ptr %incdec.ptr104, ptr %p, align 8
  store i8 %conv103, ptr %67, align 1
  %68 = load ptr, ptr %s.addr, align 8
  %add.ptr105 = getelementptr i8, ptr %68, i64 2
  store ptr %add.ptr105, ptr %s.addr, align 8
  br label %sw.epilog

if.end106:                                        ; preds = %land.lhs.true97, %if.then82
  br label %if.end107

if.end107:                                        ; preds = %if.end106, %sw.bb78
  %69 = load ptr, ptr %errors.addr, align 8
  %tobool = icmp ne ptr %69, null
  br i1 %tobool, label %lor.lhs.false, label %if.then111

lor.lhs.false:                                    ; preds = %if.end107
  %70 = load ptr, ptr %errors.addr, align 8
  %call108 = call i32 @strcmp(ptr noundef %70, ptr noundef @.str.22) #8
  %cmp109 = icmp eq i32 %call108, 0
  br i1 %cmp109, label %if.then111, label %if.end115

if.then111:                                       ; preds = %lor.lhs.false, %if.end107
  %71 = load ptr, ptr @PyExc_ValueError, align 8
  %72 = load ptr, ptr %s.addr, align 8
  %add.ptr112 = getelementptr i8, ptr %72, i64 -2
  %73 = load ptr, ptr %end, align 8
  %74 = load i64, ptr %len.addr, align 8
  %idx.neg = sub i64 0, %74
  %add.ptr113 = getelementptr i8, ptr %73, i64 %idx.neg
  %sub.ptr.lhs.cast = ptrtoint ptr %add.ptr112 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %add.ptr113 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %call114 = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %71, ptr noundef @.str.23, i64 noundef %sub.ptr.sub)
  br label %failed

if.end115:                                        ; preds = %lor.lhs.false
  %75 = load ptr, ptr %errors.addr, align 8
  %call116 = call i32 @strcmp(ptr noundef %75, ptr noundef @.str.24) #8
  %cmp117 = icmp eq i32 %call116, 0
  br i1 %cmp117, label %if.then119, label %if.else

if.then119:                                       ; preds = %if.end115
  %76 = load ptr, ptr %p, align 8
  %incdec.ptr120 = getelementptr i8, ptr %76, i32 1
  store ptr %incdec.ptr120, ptr %p, align 8
  store i8 63, ptr %76, align 1
  br label %if.end128

if.else:                                          ; preds = %if.end115
  %77 = load ptr, ptr %errors.addr, align 8
  %call121 = call i32 @strcmp(ptr noundef %77, ptr noundef @.str.25) #8
  %cmp122 = icmp eq i32 %call121, 0
  br i1 %cmp122, label %if.then124, label %if.else125

if.then124:                                       ; preds = %if.else
  br label %if.end127

if.else125:                                       ; preds = %if.else
  %78 = load ptr, ptr @PyExc_ValueError, align 8
  %79 = load ptr, ptr %errors.addr, align 8
  %call126 = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %78, ptr noundef @.str.26, ptr noundef %79)
  br label %failed

if.end127:                                        ; preds = %if.then124
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then119
  %80 = load ptr, ptr %s.addr, align 8
  %81 = load ptr, ptr %end, align 8
  %cmp129 = icmp ult ptr %80, %81
  br i1 %cmp129, label %land.lhs.true131, label %if.end142

land.lhs.true131:                                 ; preds = %if.end128
  %82 = load ptr, ptr %s.addr, align 8
  %arrayidx132 = getelementptr i8, ptr %82, i64 0
  %83 = load i8, ptr %arrayidx132, align 1
  %conv133 = sext i8 %83 to i32
  %and134 = and i32 %conv133, 255
  %conv135 = trunc i32 %and134 to i8
  %idxprom136 = zext i8 %conv135 to i64
  %arrayidx137 = getelementptr [256 x i32], ptr @_Py_ctype_table, i64 0, i64 %idxprom136
  %84 = load i32, ptr %arrayidx137, align 4
  %and138 = and i32 %84, 16
  %tobool139 = icmp ne i32 %and138, 0
  br i1 %tobool139, label %if.then140, label %if.end142

if.then140:                                       ; preds = %land.lhs.true131
  %85 = load ptr, ptr %s.addr, align 8
  %incdec.ptr141 = getelementptr i8, ptr %85, i32 1
  store ptr %incdec.ptr141, ptr %s.addr, align 8
  br label %if.end142

if.end142:                                        ; preds = %if.then140, %land.lhs.true131, %if.end128
  br label %sw.epilog

sw.default:                                       ; preds = %if.end11
  %86 = load ptr, ptr %first_invalid_escape.addr, align 8
  %87 = load ptr, ptr %86, align 8
  %cmp143 = icmp eq ptr %87, null
  br i1 %cmp143, label %if.then145, label %if.end147

if.then145:                                       ; preds = %sw.default
  %88 = load ptr, ptr %s.addr, align 8
  %add.ptr146 = getelementptr i8, ptr %88, i64 -1
  %89 = load ptr, ptr %first_invalid_escape.addr, align 8
  store ptr %add.ptr146, ptr %89, align 8
  br label %if.end147

if.end147:                                        ; preds = %if.then145, %sw.default
  %90 = load ptr, ptr %p, align 8
  %incdec.ptr148 = getelementptr i8, ptr %90, i32 1
  store ptr %incdec.ptr148, ptr %p, align 8
  store i8 92, ptr %90, align 1
  %91 = load ptr, ptr %s.addr, align 8
  %incdec.ptr149 = getelementptr i8, ptr %91, i32 -1
  store ptr %incdec.ptr149, ptr %s.addr, align 8
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end147, %if.end142, %if.then100, %if.end75, %sw.bb32, %sw.bb30, %sw.bb28, %sw.bb26, %sw.bb24, %sw.bb22, %sw.bb20, %sw.bb18, %sw.bb16, %sw.bb14, %sw.bb
  br label %while.cond, !llvm.loop !16

while.end:                                        ; preds = %while.cond
  %92 = load ptr, ptr %p, align 8
  %call150 = call ptr @_PyBytesWriter_Finish(ptr noundef %writer, ptr noundef %92)
  store ptr %call150, ptr %retval, align 8
  br label %return

failed:                                           ; preds = %if.else125, %if.then111, %if.then10
  call void @_PyBytesWriter_Dealloc(ptr noundef %writer)
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %failed, %while.end, %if.then
  %93 = load ptr, ptr %retval, align 8
  ret ptr %93
}

; Function Attrs: nounwind willreturn memory(read)
declare i32 @strcmp(ptr noundef, ptr noundef) #3

; Function Attrs: nounwind uwtable
define dso_local ptr @PyBytes_DecodeEscape(ptr noundef %s, i64 noundef %len, ptr noundef %errors, i64 noundef %_unused_unicode, ptr noundef %_unused_recode_encoding) #0 {
entry:
  %op.addr.i33 = alloca ptr, align 8
  %op.addr.i31 = alloca ptr, align 8
  %op.addr.i22 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  %errors.addr = alloca ptr, align 8
  %_unused_unicode.addr = alloca i64, align 8
  %_unused_recode_encoding.addr = alloca ptr, align 8
  %first_invalid_escape = alloca ptr, align 8
  %result = alloca ptr, align 8
  %c = alloca i8, align 1
  store ptr %s, ptr %s.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  store ptr %errors, ptr %errors.addr, align 8
  store i64 %_unused_unicode, ptr %_unused_unicode.addr, align 8
  store ptr %_unused_recode_encoding, ptr %_unused_recode_encoding.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load i64, ptr %len.addr, align 8
  %2 = load ptr, ptr %errors.addr, align 8
  %call = call ptr @_PyBytes_DecodeEscape(ptr noundef %0, i64 noundef %1, ptr noundef %2, ptr noundef %first_invalid_escape)
  store ptr %call, ptr %result, align 8
  %3 = load ptr, ptr %result, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %first_invalid_escape, align 8
  %cmp1 = icmp ne ptr %4, null
  br i1 %cmp1, label %if.then2, label %if.end21

if.then2:                                         ; preds = %if.end
  %5 = load ptr, ptr %first_invalid_escape, align 8
  %6 = load i8, ptr %5, align 1
  store i8 %6, ptr %c, align 1
  %7 = load i8, ptr %c, align 1
  %conv = zext i8 %7 to i32
  %cmp3 = icmp sle i32 52, %conv
  br i1 %cmp3, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.then2
  %8 = load i8, ptr %c, align 1
  %conv5 = zext i8 %8 to i32
  %cmp6 = icmp sle i32 %conv5, 55
  br i1 %cmp6, label %if.then8, label %if.else

if.then8:                                         ; preds = %land.lhs.true
  %9 = load ptr, ptr @PyExc_DeprecationWarning, align 8
  %10 = load ptr, ptr %first_invalid_escape, align 8
  %call9 = call i32 (ptr, i64, ptr, ...) @PyErr_WarnFormat(ptr noundef %9, i64 noundef 1, ptr noundef @.str.27, ptr noundef %10)
  %cmp10 = icmp slt i32 %call9, 0
  br i1 %cmp10, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.then8
  %11 = load ptr, ptr %result, align 8
  store ptr %11, ptr %op.addr.i22, align 8
  %12 = load ptr, ptr %op.addr.i22, align 8
  store ptr %12, ptr %op.addr.i31, align 8
  %13 = load ptr, ptr %op.addr.i31, align 8
  %14 = load i64, ptr %13, align 8
  %conv.i = trunc i64 %14 to i32
  %cmp.i32 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i32 to i32
  %tobool.i24 = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i24, label %if.then.i29, label %if.end.i25

if.then.i29:                                      ; preds = %if.then12
  br label %Py_DECREF.exit30

if.end.i25:                                       ; preds = %if.then12
  %15 = load ptr, ptr %op.addr.i22, align 8
  %16 = load i64, ptr %15, align 8
  %dec.i26 = add i64 %16, -1
  store i64 %dec.i26, ptr %15, align 8
  %cmp.i27 = icmp eq i64 %dec.i26, 0
  br i1 %cmp.i27, label %if.then1.i28, label %Py_DECREF.exit30

if.then1.i28:                                     ; preds = %if.end.i25
  %17 = load ptr, ptr %op.addr.i22, align 8
  call void @_Py_Dealloc(ptr noundef %17) #9
  br label %Py_DECREF.exit30

Py_DECREF.exit30:                                 ; preds = %if.then1.i28, %if.end.i25, %if.then.i29
  store ptr null, ptr %retval, align 8
  br label %return

if.end13:                                         ; preds = %if.then8
  br label %if.end20

if.else:                                          ; preds = %land.lhs.true, %if.then2
  %18 = load ptr, ptr @PyExc_DeprecationWarning, align 8
  %19 = load i8, ptr %c, align 1
  %conv14 = zext i8 %19 to i32
  %call15 = call i32 (ptr, i64, ptr, ...) @PyErr_WarnFormat(ptr noundef %18, i64 noundef 1, ptr noundef @.str.28, i32 noundef %conv14)
  %cmp16 = icmp slt i32 %call15, 0
  br i1 %cmp16, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.else
  %20 = load ptr, ptr %result, align 8
  store ptr %20, ptr %op.addr.i, align 8
  %21 = load ptr, ptr %op.addr.i, align 8
  store ptr %21, ptr %op.addr.i33, align 8
  %22 = load ptr, ptr %op.addr.i33, align 8
  %23 = load i64, ptr %22, align 8
  %conv.i34 = trunc i64 %23 to i32
  %cmp.i35 = icmp slt i32 %conv.i34, 0
  %conv1.i36 = zext i1 %cmp.i35 to i32
  %tobool.i = icmp ne i32 %conv1.i36, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then18
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.then18
  %24 = load ptr, ptr %op.addr.i, align 8
  %25 = load i64, ptr %24, align 8
  %dec.i = add i64 %25, -1
  store i64 %dec.i, ptr %24, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %26 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %26) #9
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  store ptr null, ptr %retval, align 8
  br label %return

if.end19:                                         ; preds = %if.else
  br label %if.end20

if.end20:                                         ; preds = %if.end19, %if.end13
  br label %if.end21

if.end21:                                         ; preds = %if.end20, %if.end
  %27 = load ptr, ptr %result, align 8
  store ptr %27, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end21, %Py_DECREF.exit, %Py_DECREF.exit30, %if.then
  %28 = load ptr, ptr %retval, align 8
  ret ptr %28
}

declare i32 @PyErr_WarnFormat(ptr noundef, i64 noundef, ptr noundef, ...) #1

; Function Attrs: nounwind uwtable
define dso_local i64 @PyBytes_Size(ptr noundef %op) #0 {
entry:
  %retval = alloca i64, align 8
  %op.addr = alloca ptr, align 8
  store ptr %op, ptr %op.addr, align 8
  %0 = load ptr, ptr %op.addr, align 8
  %call = call ptr @Py_TYPE(ptr noundef %0)
  %call1 = call i32 @PyType_HasFeature(ptr noundef %call, i64 noundef 134217728)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr @PyExc_TypeError, align 8
  %2 = load ptr, ptr %op.addr, align 8
  %call2 = call ptr @Py_TYPE(ptr noundef %2)
  %tp_name = getelementptr inbounds %struct._typeobject, ptr %call2, i32 0, i32 1
  %3 = load ptr, ptr %tp_name, align 8
  %call3 = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %1, ptr noundef @.str.29, ptr noundef %3)
  store i64 -1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %op.addr, align 8
  %call4 = call i64 @Py_SIZE(ptr noundef %4)
  store i64 %call4, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %5 = load i64, ptr %retval, align 8
  ret i64 %5
}

; Function Attrs: nounwind uwtable
define internal i64 @Py_SIZE(ptr noundef %ob) #0 {
entry:
  %ob.addr = alloca ptr, align 8
  %var_ob = alloca ptr, align 8
  store ptr %ob, ptr %ob.addr, align 8
  %0 = load ptr, ptr %ob.addr, align 8
  store ptr %0, ptr %var_ob, align 8
  %1 = load ptr, ptr %var_ob, align 8
  %ob_size = getelementptr inbounds %struct.PyVarObject, ptr %1, i32 0, i32 1
  %2 = load i64, ptr %ob_size, align 8
  ret i64 %2
}

; Function Attrs: nounwind uwtable
define dso_local ptr @PyBytes_AsString(ptr noundef %op) #0 {
entry:
  %retval = alloca ptr, align 8
  %op.addr = alloca ptr, align 8
  store ptr %op, ptr %op.addr, align 8
  %0 = load ptr, ptr %op.addr, align 8
  %call = call ptr @Py_TYPE(ptr noundef %0)
  %call1 = call i32 @PyType_HasFeature(ptr noundef %call, i64 noundef 134217728)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr @PyExc_TypeError, align 8
  %2 = load ptr, ptr %op.addr, align 8
  %call2 = call ptr @Py_TYPE(ptr noundef %2)
  %tp_name = getelementptr inbounds %struct._typeobject, ptr %call2, i32 0, i32 1
  %3 = load ptr, ptr %tp_name, align 8
  %call3 = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %1, ptr noundef @.str.29, ptr noundef %3)
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %op.addr, align 8
  %ob_sval = getelementptr inbounds %struct.PyBytesObject, ptr %4, i32 0, i32 2
  %arraydecay = getelementptr inbounds [1 x i8], ptr %ob_sval, i64 0, i64 0
  store ptr %arraydecay, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %5 = load ptr, ptr %retval, align 8
  ret ptr %5
}

; Function Attrs: nounwind uwtable
define dso_local i32 @PyBytes_AsStringAndSize(ptr noundef %obj, ptr noundef %s, ptr noundef %len) #0 {
entry:
  %retval = alloca i32, align 4
  %obj.addr = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %len.addr = alloca ptr, align 8
  store ptr %obj, ptr %obj.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %len, ptr %len.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @_PyErr_BadInternalCall(ptr noundef @.str.12, i32 noundef 1227)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %obj.addr, align 8
  %call = call ptr @Py_TYPE(ptr noundef %1)
  %call1 = call i32 @PyType_HasFeature(ptr noundef %call, i64 noundef 134217728)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.end5, label %if.then2

if.then2:                                         ; preds = %if.end
  %2 = load ptr, ptr @PyExc_TypeError, align 8
  %3 = load ptr, ptr %obj.addr, align 8
  %call3 = call ptr @Py_TYPE(ptr noundef %3)
  %tp_name = getelementptr inbounds %struct._typeobject, ptr %call3, i32 0, i32 1
  %4 = load ptr, ptr %tp_name, align 8
  %call4 = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %2, ptr noundef @.str.29, ptr noundef %4)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  %5 = load ptr, ptr %obj.addr, align 8
  %call6 = call ptr @PyBytes_AS_STRING(ptr noundef %5)
  %6 = load ptr, ptr %s.addr, align 8
  store ptr %call6, ptr %6, align 8
  %7 = load ptr, ptr %len.addr, align 8
  %cmp7 = icmp ne ptr %7, null
  br i1 %cmp7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.end5
  %8 = load ptr, ptr %obj.addr, align 8
  %call9 = call i64 @PyBytes_GET_SIZE(ptr noundef %8)
  %9 = load ptr, ptr %len.addr, align 8
  store i64 %call9, ptr %9, align 8
  br label %if.end15

if.else:                                          ; preds = %if.end5
  %10 = load ptr, ptr %s.addr, align 8
  %11 = load ptr, ptr %10, align 8
  %call10 = call i64 @strlen(ptr noundef %11) #8
  %12 = load ptr, ptr %obj.addr, align 8
  %call11 = call i64 @PyBytes_GET_SIZE(ptr noundef %12)
  %cmp12 = icmp ne i64 %call10, %call11
  br i1 %cmp12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.else
  %13 = load ptr, ptr @PyExc_ValueError, align 8
  call void @PyErr_SetString(ptr noundef %13, ptr noundef @.str.30)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end14:                                         ; preds = %if.else
  br label %if.end15

if.end15:                                         ; preds = %if.end14, %if.then8
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end15, %if.then13, %if.then2, %if.then
  %14 = load i32, ptr %retval, align 4
  ret i32 %14
}

; Function Attrs: nounwind uwtable
define dso_local i64 @_PyBytes_Find(ptr noundef %haystack, i64 noundef %len_haystack, ptr noundef %needle, i64 noundef %len_needle, i64 noundef %offset) #0 {
entry:
  %retval = alloca i64, align 8
  %haystack.addr = alloca ptr, align 8
  %len_haystack.addr = alloca i64, align 8
  %needle.addr = alloca ptr, align 8
  %len_needle.addr = alloca i64, align 8
  %offset.addr = alloca i64, align 8
  %res = alloca i64, align 8
  %last_align = alloca i64, align 8
  store ptr %haystack, ptr %haystack.addr, align 8
  store i64 %len_haystack, ptr %len_haystack.addr, align 8
  store ptr %needle, ptr %needle.addr, align 8
  store i64 %len_needle, ptr %len_needle.addr, align 8
  store i64 %offset, ptr %offset.addr, align 8
  %0 = load i64, ptr %len_needle.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i64, ptr %offset.addr, align 8
  store i64 %1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i64, ptr %len_needle.addr, align 8
  %3 = load i64, ptr %len_haystack.addr, align 8
  %cmp1 = icmp sgt i64 %2, %3
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i64 -1, ptr %retval, align 8
  br label %return

if.end3:                                          ; preds = %if.end
  %4 = load ptr, ptr %haystack.addr, align 8
  %5 = load i64, ptr %len_haystack.addr, align 8
  %sub = sub i64 %5, 1
  %6 = load ptr, ptr %needle.addr, align 8
  %7 = load i64, ptr %len_needle.addr, align 8
  %8 = load i64, ptr %offset.addr, align 8
  %call = call i64 @stringlib_find(ptr noundef %4, i64 noundef %sub, ptr noundef %6, i64 noundef %7, i64 noundef %8)
  store i64 %call, ptr %res, align 8
  %9 = load i64, ptr %res, align 8
  %cmp4 = icmp eq i64 %9, -1
  br i1 %cmp4, label %if.then5, label %if.end11

if.then5:                                         ; preds = %if.end3
  %10 = load i64, ptr %len_haystack.addr, align 8
  %11 = load i64, ptr %len_needle.addr, align 8
  %sub6 = sub i64 %10, %11
  store i64 %sub6, ptr %last_align, align 8
  %12 = load ptr, ptr %haystack.addr, align 8
  %13 = load i64, ptr %last_align, align 8
  %add.ptr = getelementptr i8, ptr %12, i64 %13
  %14 = load ptr, ptr %needle.addr, align 8
  %15 = load i64, ptr %len_needle.addr, align 8
  %call7 = call i32 @memcmp(ptr noundef %add.ptr, ptr noundef %14, i64 noundef %15) #8
  %cmp8 = icmp eq i32 %call7, 0
  br i1 %cmp8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.then5
  %16 = load i64, ptr %offset.addr, align 8
  %17 = load i64, ptr %last_align, align 8
  %add = add i64 %16, %17
  store i64 %add, ptr %retval, align 8
  br label %return

if.end10:                                         ; preds = %if.then5
  br label %if.end11

if.end11:                                         ; preds = %if.end10, %if.end3
  %18 = load i64, ptr %res, align 8
  store i64 %18, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end11, %if.then9, %if.then2, %if.then
  %19 = load i64, ptr %retval, align 8
  ret i64 %19
}

; Function Attrs: nounwind uwtable
define internal i64 @stringlib_find(ptr noundef %str, i64 noundef %str_len, ptr noundef %sub, i64 noundef %sub_len, i64 noundef %offset) #0 {
entry:
  %retval = alloca i64, align 8
  %str.addr = alloca ptr, align 8
  %str_len.addr = alloca i64, align 8
  %sub.addr = alloca ptr, align 8
  %sub_len.addr = alloca i64, align 8
  %offset.addr = alloca i64, align 8
  %pos = alloca i64, align 8
  store ptr %str, ptr %str.addr, align 8
  store i64 %str_len, ptr %str_len.addr, align 8
  store ptr %sub, ptr %sub.addr, align 8
  store i64 %sub_len, ptr %sub_len.addr, align 8
  store i64 %offset, ptr %offset.addr, align 8
  %0 = load i64, ptr %sub_len.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i64, ptr %offset.addr, align 8
  store i64 %1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %str.addr, align 8
  %3 = load i64, ptr %str_len.addr, align 8
  %4 = load ptr, ptr %sub.addr, align 8
  %5 = load i64, ptr %sub_len.addr, align 8
  %call = call i64 @fastsearch(ptr noundef %2, i64 noundef %3, ptr noundef %4, i64 noundef %5, i64 noundef -1, i32 noundef 1)
  store i64 %call, ptr %pos, align 8
  %6 = load i64, ptr %pos, align 8
  %cmp1 = icmp sge i64 %6, 0
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %7 = load i64, ptr %offset.addr, align 8
  %8 = load i64, ptr %pos, align 8
  %add = add i64 %8, %7
  store i64 %add, ptr %pos, align 8
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end
  %9 = load i64, ptr %pos, align 8
  store i64 %9, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end3, %if.then
  %10 = load i64, ptr %retval, align 8
  ret i64 %10
}

; Function Attrs: nounwind willreturn memory(read)
declare i32 @memcmp(ptr noundef, ptr noundef, i64 noundef) #3

; Function Attrs: nounwind uwtable
define dso_local i64 @_PyBytes_ReverseFind(ptr noundef %haystack, i64 noundef %len_haystack, ptr noundef %needle, i64 noundef %len_needle, i64 noundef %offset) #0 {
entry:
  %haystack.addr = alloca ptr, align 8
  %len_haystack.addr = alloca i64, align 8
  %needle.addr = alloca ptr, align 8
  %len_needle.addr = alloca i64, align 8
  %offset.addr = alloca i64, align 8
  store ptr %haystack, ptr %haystack.addr, align 8
  store i64 %len_haystack, ptr %len_haystack.addr, align 8
  store ptr %needle, ptr %needle.addr, align 8
  store i64 %len_needle, ptr %len_needle.addr, align 8
  store i64 %offset, ptr %offset.addr, align 8
  %0 = load ptr, ptr %haystack.addr, align 8
  %1 = load i64, ptr %len_haystack.addr, align 8
  %2 = load ptr, ptr %needle.addr, align 8
  %3 = load i64, ptr %len_needle.addr, align 8
  %4 = load i64, ptr %offset.addr, align 8
  %call = call i64 @stringlib_rfind(ptr noundef %0, i64 noundef %1, ptr noundef %2, i64 noundef %3, i64 noundef %4)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define internal i64 @stringlib_rfind(ptr noundef %str, i64 noundef %str_len, ptr noundef %sub, i64 noundef %sub_len, i64 noundef %offset) #0 {
entry:
  %retval = alloca i64, align 8
  %str.addr = alloca ptr, align 8
  %str_len.addr = alloca i64, align 8
  %sub.addr = alloca ptr, align 8
  %sub_len.addr = alloca i64, align 8
  %offset.addr = alloca i64, align 8
  %pos = alloca i64, align 8
  store ptr %str, ptr %str.addr, align 8
  store i64 %str_len, ptr %str_len.addr, align 8
  store ptr %sub, ptr %sub.addr, align 8
  store i64 %sub_len, ptr %sub_len.addr, align 8
  store i64 %offset, ptr %offset.addr, align 8
  %0 = load i64, ptr %sub_len.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i64, ptr %str_len.addr, align 8
  %2 = load i64, ptr %offset.addr, align 8
  %add = add i64 %1, %2
  store i64 %add, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %str.addr, align 8
  %4 = load i64, ptr %str_len.addr, align 8
  %5 = load ptr, ptr %sub.addr, align 8
  %6 = load i64, ptr %sub_len.addr, align 8
  %call = call i64 @fastsearch(ptr noundef %3, i64 noundef %4, ptr noundef %5, i64 noundef %6, i64 noundef -1, i32 noundef 2)
  store i64 %call, ptr %pos, align 8
  %7 = load i64, ptr %pos, align 8
  %cmp1 = icmp sge i64 %7, 0
  br i1 %cmp1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %8 = load i64, ptr %offset.addr, align 8
  %9 = load i64, ptr %pos, align 8
  %add3 = add i64 %9, %8
  store i64 %add3, ptr %pos, align 8
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.end
  %10 = load i64, ptr %pos, align 8
  store i64 %10, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end4, %if.then
  %11 = load i64, ptr %retval, align 8
  ret i64 %11
}

; Function Attrs: nounwind uwtable
define dso_local ptr @PyBytes_Repr(ptr noundef %obj, i32 noundef %smartquotes) #0 {
entry:
  %retval = alloca ptr, align 8
  %obj.addr = alloca ptr, align 8
  %smartquotes.addr = alloca i32, align 4
  %op = alloca ptr, align 8
  %i = alloca i64, align 8
  %length = alloca i64, align 8
  %newsize = alloca i64, align 8
  %squotes = alloca i64, align 8
  %dquotes = alloca i64, align 8
  %v = alloca ptr, align 8
  %quote = alloca i8, align 1
  %s = alloca ptr, align 8
  %p = alloca ptr, align 8
  %incr = alloca i64, align 8
  %c = alloca i8, align 1
  store ptr %obj, ptr %obj.addr, align 8
  store i32 %smartquotes, ptr %smartquotes.addr, align 4
  %0 = load ptr, ptr %obj.addr, align 8
  store ptr %0, ptr %op, align 8
  %1 = load ptr, ptr %op, align 8
  %call = call i64 @Py_SIZE(ptr noundef %1)
  store i64 %call, ptr %length, align 8
  store i64 0, ptr %dquotes, align 8
  store i64 0, ptr %squotes, align 8
  store i64 3, ptr %newsize, align 8
  %2 = load ptr, ptr %op, align 8
  %ob_sval = getelementptr inbounds %struct.PyBytesObject, ptr %2, i32 0, i32 2
  %arraydecay = getelementptr inbounds [1 x i8], ptr %ob_sval, i64 0, i64 0
  store ptr %arraydecay, ptr %s, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %3 = load i64, ptr %i, align 8
  %4 = load i64, ptr %length, align 8
  %cmp = icmp slt i64 %3, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  store i64 1, ptr %incr, align 8
  %5 = load ptr, ptr %s, align 8
  %6 = load i64, ptr %i, align 8
  %arrayidx = getelementptr i8, ptr %5, i64 %6
  %7 = load i8, ptr %arrayidx, align 1
  %conv = zext i8 %7 to i32
  switch i32 %conv, label %sw.default [
    i32 39, label %sw.bb
    i32 34, label %sw.bb1
    i32 92, label %sw.bb3
    i32 9, label %sw.bb3
    i32 10, label %sw.bb3
    i32 13, label %sw.bb3
  ]

sw.bb:                                            ; preds = %for.body
  %8 = load i64, ptr %squotes, align 8
  %inc = add i64 %8, 1
  store i64 %inc, ptr %squotes, align 8
  br label %sw.epilog

sw.bb1:                                           ; preds = %for.body
  %9 = load i64, ptr %dquotes, align 8
  %inc2 = add i64 %9, 1
  store i64 %inc2, ptr %dquotes, align 8
  br label %sw.epilog

sw.bb3:                                           ; preds = %for.body, %for.body, %for.body, %for.body
  store i64 2, ptr %incr, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %for.body
  %10 = load ptr, ptr %s, align 8
  %11 = load i64, ptr %i, align 8
  %arrayidx4 = getelementptr i8, ptr %10, i64 %11
  %12 = load i8, ptr %arrayidx4, align 1
  %conv5 = zext i8 %12 to i32
  %cmp6 = icmp slt i32 %conv5, 32
  br i1 %cmp6, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %sw.default
  %13 = load ptr, ptr %s, align 8
  %14 = load i64, ptr %i, align 8
  %arrayidx8 = getelementptr i8, ptr %13, i64 %14
  %15 = load i8, ptr %arrayidx8, align 1
  %conv9 = zext i8 %15 to i32
  %cmp10 = icmp sge i32 %conv9, 127
  br i1 %cmp10, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %sw.default
  store i64 4, ptr %incr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end, %sw.bb3, %sw.bb1, %sw.bb
  %16 = load i64, ptr %newsize, align 8
  %17 = load i64, ptr %incr, align 8
  %sub = sub i64 9223372036854775807, %17
  %cmp12 = icmp sgt i64 %16, %sub
  br i1 %cmp12, label %if.then14, label %if.end15

if.then14:                                        ; preds = %sw.epilog
  br label %overflow

if.end15:                                         ; preds = %sw.epilog
  %18 = load i64, ptr %incr, align 8
  %19 = load i64, ptr %newsize, align 8
  %add = add i64 %19, %18
  store i64 %add, ptr %newsize, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end15
  %20 = load i64, ptr %i, align 8
  %inc16 = add i64 %20, 1
  store i64 %inc16, ptr %i, align 8
  br label %for.cond, !llvm.loop !17

for.end:                                          ; preds = %for.cond
  store i8 39, ptr %quote, align 1
  %21 = load i32, ptr %smartquotes.addr, align 4
  %tobool = icmp ne i32 %21, 0
  br i1 %tobool, label %land.lhs.true, label %if.end21

land.lhs.true:                                    ; preds = %for.end
  %22 = load i64, ptr %squotes, align 8
  %tobool17 = icmp ne i64 %22, 0
  br i1 %tobool17, label %land.lhs.true18, label %if.end21

land.lhs.true18:                                  ; preds = %land.lhs.true
  %23 = load i64, ptr %dquotes, align 8
  %tobool19 = icmp ne i64 %23, 0
  br i1 %tobool19, label %if.end21, label %if.then20

if.then20:                                        ; preds = %land.lhs.true18
  store i8 34, ptr %quote, align 1
  br label %if.end21

if.end21:                                         ; preds = %if.then20, %land.lhs.true18, %land.lhs.true, %for.end
  %24 = load i64, ptr %squotes, align 8
  %tobool22 = icmp ne i64 %24, 0
  br i1 %tobool22, label %land.lhs.true23, label %if.end34

land.lhs.true23:                                  ; preds = %if.end21
  %25 = load i8, ptr %quote, align 1
  %conv24 = zext i8 %25 to i32
  %cmp25 = icmp eq i32 %conv24, 39
  br i1 %cmp25, label %if.then27, label %if.end34

if.then27:                                        ; preds = %land.lhs.true23
  %26 = load i64, ptr %newsize, align 8
  %27 = load i64, ptr %squotes, align 8
  %sub28 = sub i64 9223372036854775807, %27
  %cmp29 = icmp sgt i64 %26, %sub28
  br i1 %cmp29, label %if.then31, label %if.end32

if.then31:                                        ; preds = %if.then27
  br label %overflow

if.end32:                                         ; preds = %if.then27
  %28 = load i64, ptr %squotes, align 8
  %29 = load i64, ptr %newsize, align 8
  %add33 = add i64 %29, %28
  store i64 %add33, ptr %newsize, align 8
  br label %if.end34

if.end34:                                         ; preds = %if.end32, %land.lhs.true23, %if.end21
  %30 = load i64, ptr %newsize, align 8
  %call35 = call ptr @PyUnicode_New(i64 noundef %30, i32 noundef 127)
  store ptr %call35, ptr %v, align 8
  %31 = load ptr, ptr %v, align 8
  %cmp36 = icmp eq ptr %31, null
  br i1 %cmp36, label %if.then38, label %if.end39

if.then38:                                        ; preds = %if.end34
  store ptr null, ptr %retval, align 8
  br label %return

if.end39:                                         ; preds = %if.end34
  %32 = load ptr, ptr %v, align 8
  %call40 = call ptr @PyUnicode_DATA(ptr noundef %32)
  store ptr %call40, ptr %p, align 8
  %33 = load ptr, ptr %p, align 8
  %incdec.ptr = getelementptr i8, ptr %33, i32 1
  store ptr %incdec.ptr, ptr %p, align 8
  store i8 98, ptr %33, align 1
  %34 = load i8, ptr %quote, align 1
  %35 = load ptr, ptr %p, align 8
  %incdec.ptr41 = getelementptr i8, ptr %35, i32 1
  store ptr %incdec.ptr41, ptr %p, align 8
  store i8 %34, ptr %35, align 1
  store i64 0, ptr %i, align 8
  br label %for.cond42

for.cond42:                                       ; preds = %for.inc105, %if.end39
  %36 = load i64, ptr %i, align 8
  %37 = load i64, ptr %length, align 8
  %cmp43 = icmp slt i64 %36, %37
  br i1 %cmp43, label %for.body45, label %for.end107

for.body45:                                       ; preds = %for.cond42
  %38 = load ptr, ptr %op, align 8
  %ob_sval46 = getelementptr inbounds %struct.PyBytesObject, ptr %38, i32 0, i32 2
  %39 = load i64, ptr %i, align 8
  %arrayidx47 = getelementptr [1 x i8], ptr %ob_sval46, i64 0, i64 %39
  %40 = load i8, ptr %arrayidx47, align 1
  store i8 %40, ptr %c, align 1
  %41 = load i8, ptr %c, align 1
  %conv48 = zext i8 %41 to i32
  %42 = load i8, ptr %quote, align 1
  %conv49 = zext i8 %42 to i32
  %cmp50 = icmp eq i32 %conv48, %conv49
  br i1 %cmp50, label %if.then56, label %lor.lhs.false52

lor.lhs.false52:                                  ; preds = %for.body45
  %43 = load i8, ptr %c, align 1
  %conv53 = zext i8 %43 to i32
  %cmp54 = icmp eq i32 %conv53, 92
  br i1 %cmp54, label %if.then56, label %if.else

if.then56:                                        ; preds = %lor.lhs.false52, %for.body45
  %44 = load ptr, ptr %p, align 8
  %incdec.ptr57 = getelementptr i8, ptr %44, i32 1
  store ptr %incdec.ptr57, ptr %p, align 8
  store i8 92, ptr %44, align 1
  %45 = load i8, ptr %c, align 1
  %46 = load ptr, ptr %p, align 8
  %incdec.ptr58 = getelementptr i8, ptr %46, i32 1
  store ptr %incdec.ptr58, ptr %p, align 8
  store i8 %45, ptr %46, align 1
  br label %if.end104

if.else:                                          ; preds = %lor.lhs.false52
  %47 = load i8, ptr %c, align 1
  %conv59 = zext i8 %47 to i32
  %cmp60 = icmp eq i32 %conv59, 9
  br i1 %cmp60, label %if.then62, label %if.else65

if.then62:                                        ; preds = %if.else
  %48 = load ptr, ptr %p, align 8
  %incdec.ptr63 = getelementptr i8, ptr %48, i32 1
  store ptr %incdec.ptr63, ptr %p, align 8
  store i8 92, ptr %48, align 1
  %49 = load ptr, ptr %p, align 8
  %incdec.ptr64 = getelementptr i8, ptr %49, i32 1
  store ptr %incdec.ptr64, ptr %p, align 8
  store i8 116, ptr %49, align 1
  br label %if.end103

if.else65:                                        ; preds = %if.else
  %50 = load i8, ptr %c, align 1
  %conv66 = zext i8 %50 to i32
  %cmp67 = icmp eq i32 %conv66, 10
  br i1 %cmp67, label %if.then69, label %if.else72

if.then69:                                        ; preds = %if.else65
  %51 = load ptr, ptr %p, align 8
  %incdec.ptr70 = getelementptr i8, ptr %51, i32 1
  store ptr %incdec.ptr70, ptr %p, align 8
  store i8 92, ptr %51, align 1
  %52 = load ptr, ptr %p, align 8
  %incdec.ptr71 = getelementptr i8, ptr %52, i32 1
  store ptr %incdec.ptr71, ptr %p, align 8
  store i8 110, ptr %52, align 1
  br label %if.end102

if.else72:                                        ; preds = %if.else65
  %53 = load i8, ptr %c, align 1
  %conv73 = zext i8 %53 to i32
  %cmp74 = icmp eq i32 %conv73, 13
  br i1 %cmp74, label %if.then76, label %if.else79

if.then76:                                        ; preds = %if.else72
  %54 = load ptr, ptr %p, align 8
  %incdec.ptr77 = getelementptr i8, ptr %54, i32 1
  store ptr %incdec.ptr77, ptr %p, align 8
  store i8 92, ptr %54, align 1
  %55 = load ptr, ptr %p, align 8
  %incdec.ptr78 = getelementptr i8, ptr %55, i32 1
  store ptr %incdec.ptr78, ptr %p, align 8
  store i8 114, ptr %55, align 1
  br label %if.end101

if.else79:                                        ; preds = %if.else72
  %56 = load i8, ptr %c, align 1
  %conv80 = zext i8 %56 to i32
  %cmp81 = icmp slt i32 %conv80, 32
  br i1 %cmp81, label %if.then87, label %lor.lhs.false83

lor.lhs.false83:                                  ; preds = %if.else79
  %57 = load i8, ptr %c, align 1
  %conv84 = zext i8 %57 to i32
  %cmp85 = icmp sge i32 %conv84, 127
  br i1 %cmp85, label %if.then87, label %if.else98

if.then87:                                        ; preds = %lor.lhs.false83, %if.else79
  %58 = load ptr, ptr %p, align 8
  %incdec.ptr88 = getelementptr i8, ptr %58, i32 1
  store ptr %incdec.ptr88, ptr %p, align 8
  store i8 92, ptr %58, align 1
  %59 = load ptr, ptr %p, align 8
  %incdec.ptr89 = getelementptr i8, ptr %59, i32 1
  store ptr %incdec.ptr89, ptr %p, align 8
  store i8 120, ptr %59, align 1
  %60 = load ptr, ptr @Py_hexdigits, align 8
  %61 = load i8, ptr %c, align 1
  %conv90 = zext i8 %61 to i32
  %and = and i32 %conv90, 240
  %shr = ashr i32 %and, 4
  %idxprom = sext i32 %shr to i64
  %arrayidx91 = getelementptr i8, ptr %60, i64 %idxprom
  %62 = load i8, ptr %arrayidx91, align 1
  %63 = load ptr, ptr %p, align 8
  %incdec.ptr92 = getelementptr i8, ptr %63, i32 1
  store ptr %incdec.ptr92, ptr %p, align 8
  store i8 %62, ptr %63, align 1
  %64 = load ptr, ptr @Py_hexdigits, align 8
  %65 = load i8, ptr %c, align 1
  %conv93 = zext i8 %65 to i32
  %and94 = and i32 %conv93, 15
  %idxprom95 = sext i32 %and94 to i64
  %arrayidx96 = getelementptr i8, ptr %64, i64 %idxprom95
  %66 = load i8, ptr %arrayidx96, align 1
  %67 = load ptr, ptr %p, align 8
  %incdec.ptr97 = getelementptr i8, ptr %67, i32 1
  store ptr %incdec.ptr97, ptr %p, align 8
  store i8 %66, ptr %67, align 1
  br label %if.end100

if.else98:                                        ; preds = %lor.lhs.false83
  %68 = load i8, ptr %c, align 1
  %69 = load ptr, ptr %p, align 8
  %incdec.ptr99 = getelementptr i8, ptr %69, i32 1
  store ptr %incdec.ptr99, ptr %p, align 8
  store i8 %68, ptr %69, align 1
  br label %if.end100

if.end100:                                        ; preds = %if.else98, %if.then87
  br label %if.end101

if.end101:                                        ; preds = %if.end100, %if.then76
  br label %if.end102

if.end102:                                        ; preds = %if.end101, %if.then69
  br label %if.end103

if.end103:                                        ; preds = %if.end102, %if.then62
  br label %if.end104

if.end104:                                        ; preds = %if.end103, %if.then56
  br label %for.inc105

for.inc105:                                       ; preds = %if.end104
  %70 = load i64, ptr %i, align 8
  %inc106 = add i64 %70, 1
  store i64 %inc106, ptr %i, align 8
  br label %for.cond42, !llvm.loop !18

for.end107:                                       ; preds = %for.cond42
  %71 = load i8, ptr %quote, align 1
  %72 = load ptr, ptr %p, align 8
  %incdec.ptr108 = getelementptr i8, ptr %72, i32 1
  store ptr %incdec.ptr108, ptr %p, align 8
  store i8 %71, ptr %72, align 1
  %73 = load ptr, ptr %v, align 8
  store ptr %73, ptr %retval, align 8
  br label %return

overflow:                                         ; preds = %if.then31, %if.then14
  %74 = load ptr, ptr @PyExc_OverflowError, align 8
  call void @PyErr_SetString(ptr noundef %74, ptr noundef @.str.31)
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %overflow, %for.end107, %if.then38
  %75 = load ptr, ptr %retval, align 8
  ret ptr %75
}

declare ptr @PyUnicode_New(i64 noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define hidden ptr @_PyBytes_Join(ptr noundef %sep, ptr noundef %x) #0 {
entry:
  %sep.addr = alloca ptr, align 8
  %x.addr = alloca ptr, align 8
  store ptr %sep, ptr %sep.addr, align 8
  store ptr %x, ptr %x.addr, align 8
  %0 = load ptr, ptr %sep.addr, align 8
  %1 = load ptr, ptr %x.addr, align 8
  %call = call ptr @bytes_join(ptr noundef %0, ptr noundef %1)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @bytes_join(ptr noundef %self, ptr noundef %iterable_of_bytes) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %iterable_of_bytes.addr = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %iterable_of_bytes, ptr %iterable_of_bytes.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %1 = load ptr, ptr %iterable_of_bytes.addr, align 8
  %call = call ptr @stringlib_bytes_join(ptr noundef %0, ptr noundef %1)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define hidden ptr @_PyBytes_FromHex(ptr noundef %string, i32 noundef %use_bytearray) #0 {
entry:
  %retval = alloca ptr, align 8
  %string.addr = alloca ptr, align 8
  %use_bytearray.addr = alloca i32, align 4
  %buf = alloca ptr, align 8
  %hexlen = alloca i64, align 8
  %invalid_char = alloca i64, align 8
  %top = alloca i32, align 4
  %bot = alloca i32, align 4
  %str = alloca ptr, align 8
  %end = alloca ptr, align 8
  %writer = alloca %struct._PyBytesWriter, align 8
  %data = alloca ptr, align 8
  %kind = alloca i32, align 4
  %i = alloca i64, align 8
  store ptr %string, ptr %string.addr, align 8
  store i32 %use_bytearray, ptr %use_bytearray.addr, align 4
  call void @_PyBytesWriter_Init(ptr noundef %writer)
  %0 = load i32, ptr %use_bytearray.addr, align 4
  %use_bytearray1 = getelementptr inbounds %struct._PyBytesWriter, ptr %writer, i32 0, i32 3
  store i32 %0, ptr %use_bytearray1, align 8
  %1 = load ptr, ptr %string.addr, align 8
  %call = call i64 @PyUnicode_GET_LENGTH(ptr noundef %1)
  store i64 %call, ptr %hexlen, align 8
  %2 = load ptr, ptr %string.addr, align 8
  %call2 = call i32 @PyUnicode_IS_ASCII(ptr noundef %2)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.end7, label %if.then

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %string.addr, align 8
  %call3 = call ptr @PyUnicode_DATA(ptr noundef %3)
  store ptr %call3, ptr %data, align 8
  %4 = load ptr, ptr %string.addr, align 8
  %state = getelementptr inbounds %struct.PyASCIIObject, ptr %4, i32 0, i32 3
  %bf.load = load i32, ptr %state, align 8
  %bf.lshr = lshr i32 %bf.load, 2
  %bf.clear = and i32 %bf.lshr, 7
  store i32 %bf.clear, ptr %kind, align 4
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %5 = load i64, ptr %i, align 8
  %6 = load i64, ptr %hexlen, align 8
  %cmp = icmp slt i64 %5, %6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load i32, ptr %kind, align 4
  %8 = load ptr, ptr %data, align 8
  %9 = load i64, ptr %i, align 8
  %call4 = call i32 @PyUnicode_READ(i32 noundef %7, ptr noundef %8, i64 noundef %9)
  %cmp5 = icmp uge i32 %call4, 128
  br i1 %cmp5, label %if.then6, label %if.end

if.then6:                                         ; preds = %for.body
  br label %for.end

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %10 = load i64, ptr %i, align 8
  %inc = add i64 %10, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !19

for.end:                                          ; preds = %if.then6, %for.cond
  %11 = load i64, ptr %i, align 8
  store i64 %11, ptr %invalid_char, align 8
  br label %error

if.end7:                                          ; preds = %entry
  %12 = load ptr, ptr %string.addr, align 8
  %call8 = call ptr @PyUnicode_DATA(ptr noundef %12)
  store ptr %call8, ptr %str, align 8
  %13 = load i64, ptr %hexlen, align 8
  %div = sdiv i64 %13, 2
  %call9 = call ptr @_PyBytesWriter_Alloc(ptr noundef %writer, i64 noundef %div)
  store ptr %call9, ptr %buf, align 8
  %14 = load ptr, ptr %buf, align 8
  %cmp10 = icmp eq ptr %14, null
  br i1 %cmp10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end7
  store ptr null, ptr %retval, align 8
  br label %return

if.end12:                                         ; preds = %if.end7
  %15 = load ptr, ptr %str, align 8
  %16 = load i64, ptr %hexlen, align 8
  %add.ptr = getelementptr i8, ptr %15, i64 %16
  store ptr %add.ptr, ptr %end, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end49, %if.end12
  %17 = load ptr, ptr %str, align 8
  %18 = load ptr, ptr %end, align 8
  %cmp13 = icmp ult ptr %17, %18
  br i1 %cmp13, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %19 = load ptr, ptr %str, align 8
  %20 = load i8, ptr %19, align 1
  %conv = zext i8 %20 to i32
  %and = and i32 %conv, 255
  %conv14 = trunc i32 %and to i8
  %idxprom = zext i8 %conv14 to i64
  %arrayidx = getelementptr [256 x i32], ptr @_Py_ctype_table, i64 0, i64 %idxprom
  %21 = load i32, ptr %arrayidx, align 4
  %and15 = and i32 %21, 8
  %tobool16 = icmp ne i32 %and15, 0
  br i1 %tobool16, label %if.then17, label %if.end29

if.then17:                                        ; preds = %while.body
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.then17
  %22 = load ptr, ptr %str, align 8
  %incdec.ptr = getelementptr i8, ptr %22, i32 1
  store ptr %incdec.ptr, ptr %str, align 8
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %23 = load ptr, ptr %str, align 8
  %24 = load i8, ptr %23, align 1
  %conv18 = zext i8 %24 to i32
  %and19 = and i32 %conv18, 255
  %conv20 = trunc i32 %and19 to i8
  %idxprom21 = zext i8 %conv20 to i64
  %arrayidx22 = getelementptr [256 x i32], ptr @_Py_ctype_table, i64 0, i64 %idxprom21
  %25 = load i32, ptr %arrayidx22, align 4
  %and23 = and i32 %25, 8
  %tobool24 = icmp ne i32 %and23, 0
  br i1 %tobool24, label %do.body, label %do.end, !llvm.loop !20

do.end:                                           ; preds = %do.cond
  %26 = load ptr, ptr %str, align 8
  %27 = load ptr, ptr %end, align 8
  %cmp25 = icmp uge ptr %26, %27
  br i1 %cmp25, label %if.then27, label %if.end28

if.then27:                                        ; preds = %do.end
  br label %while.end

if.end28:                                         ; preds = %do.end
  br label %if.end29

if.end29:                                         ; preds = %if.end28, %while.body
  %28 = load ptr, ptr %str, align 8
  %29 = load i8, ptr %28, align 1
  %idxprom30 = zext i8 %29 to i64
  %arrayidx31 = getelementptr [256 x i8], ptr @_PyLong_DigitValue, i64 0, i64 %idxprom30
  %30 = load i8, ptr %arrayidx31, align 1
  %conv32 = zext i8 %30 to i32
  store i32 %conv32, ptr %top, align 4
  %31 = load i32, ptr %top, align 4
  %cmp33 = icmp uge i32 %31, 16
  br i1 %cmp33, label %if.then35, label %if.end37

if.then35:                                        ; preds = %if.end29
  %32 = load ptr, ptr %str, align 8
  %33 = load ptr, ptr %string.addr, align 8
  %call36 = call ptr @PyUnicode_DATA(ptr noundef %33)
  %sub.ptr.lhs.cast = ptrtoint ptr %32 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %call36 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, ptr %invalid_char, align 8
  br label %error

if.end37:                                         ; preds = %if.end29
  %34 = load ptr, ptr %str, align 8
  %incdec.ptr38 = getelementptr i8, ptr %34, i32 1
  store ptr %incdec.ptr38, ptr %str, align 8
  %35 = load ptr, ptr %str, align 8
  %36 = load i8, ptr %35, align 1
  %idxprom39 = zext i8 %36 to i64
  %arrayidx40 = getelementptr [256 x i8], ptr @_PyLong_DigitValue, i64 0, i64 %idxprom39
  %37 = load i8, ptr %arrayidx40, align 1
  %conv41 = zext i8 %37 to i32
  store i32 %conv41, ptr %bot, align 4
  %38 = load i32, ptr %bot, align 4
  %cmp42 = icmp uge i32 %38, 16
  br i1 %cmp42, label %if.then44, label %if.end49

if.then44:                                        ; preds = %if.end37
  %39 = load ptr, ptr %str, align 8
  %40 = load ptr, ptr %string.addr, align 8
  %call45 = call ptr @PyUnicode_DATA(ptr noundef %40)
  %sub.ptr.lhs.cast46 = ptrtoint ptr %39 to i64
  %sub.ptr.rhs.cast47 = ptrtoint ptr %call45 to i64
  %sub.ptr.sub48 = sub i64 %sub.ptr.lhs.cast46, %sub.ptr.rhs.cast47
  store i64 %sub.ptr.sub48, ptr %invalid_char, align 8
  br label %error

if.end49:                                         ; preds = %if.end37
  %41 = load ptr, ptr %str, align 8
  %incdec.ptr50 = getelementptr i8, ptr %41, i32 1
  store ptr %incdec.ptr50, ptr %str, align 8
  %42 = load i32, ptr %top, align 4
  %shl = shl i32 %42, 4
  %43 = load i32, ptr %bot, align 4
  %add = add i32 %shl, %43
  %conv51 = trunc i32 %add to i8
  %44 = load ptr, ptr %buf, align 8
  %incdec.ptr52 = getelementptr i8, ptr %44, i32 1
  store ptr %incdec.ptr52, ptr %buf, align 8
  store i8 %conv51, ptr %44, align 1
  br label %while.cond, !llvm.loop !21

while.end:                                        ; preds = %if.then27, %while.cond
  %45 = load ptr, ptr %buf, align 8
  %call53 = call ptr @_PyBytesWriter_Finish(ptr noundef %writer, ptr noundef %45)
  store ptr %call53, ptr %retval, align 8
  br label %return

error:                                            ; preds = %if.then44, %if.then35, %for.end
  %46 = load ptr, ptr @PyExc_ValueError, align 8
  %47 = load i64, ptr %invalid_char, align 8
  %call54 = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %46, ptr noundef @.str.32, i64 noundef %47)
  call void @_PyBytesWriter_Dealloc(ptr noundef %writer)
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %error, %while.end, %if.then11
  %48 = load ptr, ptr %retval, align 8
  ret ptr %48
}

; Function Attrs: nounwind uwtable
define internal i32 @PyUnicode_IS_ASCII(ptr noundef %op) #0 {
entry:
  %op.addr = alloca ptr, align 8
  store ptr %op, ptr %op.addr, align 8
  %0 = load ptr, ptr %op.addr, align 8
  %state = getelementptr inbounds %struct.PyASCIIObject, ptr %0, i32 0, i32 3
  %bf.load = load i32, ptr %state, align 8
  %bf.lshr = lshr i32 %bf.load, 6
  %bf.clear = and i32 %bf.lshr, 1
  ret i32 %bf.clear
}

; Function Attrs: nounwind uwtable
define internal i32 @PyUnicode_READ(i32 noundef %kind, ptr noundef %data, i64 noundef %index) #0 {
entry:
  %retval = alloca i32, align 4
  %kind.addr = alloca i32, align 4
  %data.addr = alloca ptr, align 8
  %index.addr = alloca i64, align 8
  store i32 %kind, ptr %kind.addr, align 4
  store ptr %data, ptr %data.addr, align 8
  store i64 %index, ptr %index.addr, align 8
  %0 = load i32, ptr %kind.addr, align 4
  %cmp = icmp eq i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %data.addr, align 8
  %2 = load i64, ptr %index.addr, align 8
  %arrayidx = getelementptr i8, ptr %1, i64 %2
  %3 = load i8, ptr %arrayidx, align 1
  %conv = zext i8 %3 to i32
  store i32 %conv, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %4 = load i32, ptr %kind.addr, align 4
  %cmp1 = icmp eq i32 %4, 2
  br i1 %cmp1, label %if.then3, label %if.end6

if.then3:                                         ; preds = %if.end
  %5 = load ptr, ptr %data.addr, align 8
  %6 = load i64, ptr %index.addr, align 8
  %arrayidx4 = getelementptr i16, ptr %5, i64 %6
  %7 = load i16, ptr %arrayidx4, align 2
  %conv5 = zext i16 %7 to i32
  store i32 %conv5, ptr %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.end
  %8 = load ptr, ptr %data.addr, align 8
  %9 = load i64, ptr %index.addr, align 8
  %arrayidx7 = getelementptr i32, ptr %8, i64 %9
  %10 = load i32, ptr %arrayidx7, align 4
  store i32 %10, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end6, %if.then3, %if.then
  %11 = load i32, ptr %retval, align 4
  ret i32 %11
}

; Function Attrs: nounwind uwtable
define dso_local ptr @PyBytes_FromObject(ptr noundef %x) #0 {
entry:
  %op.addr.i35 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %x.addr = alloca ptr, align 8
  %it = alloca ptr, align 8
  %result = alloca ptr, align 8
  store ptr %x, ptr %x.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @_PyErr_BadInternalCall(ptr noundef @.str.12, i32 noundef 2834)
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %x.addr, align 8
  %call = call i32 @Py_IS_TYPE(ptr noundef %1, ptr noundef @PyBytes_Type)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then1, label %if.end3

if.then1:                                         ; preds = %if.end
  %2 = load ptr, ptr %x.addr, align 8
  %call2 = call ptr @_Py_NewRef(ptr noundef %2)
  store ptr %call2, ptr %retval, align 8
  br label %return

if.end3:                                          ; preds = %if.end
  %3 = load ptr, ptr %x.addr, align 8
  %call4 = call i32 @PyObject_CheckBuffer(ptr noundef %3)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end3
  %4 = load ptr, ptr %x.addr, align 8
  %call7 = call ptr @_PyBytes_FromBuffer(ptr noundef %4)
  store ptr %call7, ptr %retval, align 8
  br label %return

if.end8:                                          ; preds = %if.end3
  %5 = load ptr, ptr %x.addr, align 8
  %call9 = call i32 @Py_IS_TYPE(ptr noundef %5, ptr noundef @PyList_Type)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.then11, label %if.end13

if.then11:                                        ; preds = %if.end8
  %6 = load ptr, ptr %x.addr, align 8
  %call12 = call ptr @_PyBytes_FromList(ptr noundef %6)
  store ptr %call12, ptr %retval, align 8
  br label %return

if.end13:                                         ; preds = %if.end8
  %7 = load ptr, ptr %x.addr, align 8
  %call14 = call i32 @Py_IS_TYPE(ptr noundef %7, ptr noundef @PyTuple_Type)
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %if.then16, label %if.end18

if.then16:                                        ; preds = %if.end13
  %8 = load ptr, ptr %x.addr, align 8
  %call17 = call ptr @_PyBytes_FromTuple(ptr noundef %8)
  store ptr %call17, ptr %retval, align 8
  br label %return

if.end18:                                         ; preds = %if.end13
  %9 = load ptr, ptr %x.addr, align 8
  %call19 = call ptr @Py_TYPE(ptr noundef %9)
  %call20 = call i32 @PyType_HasFeature(ptr noundef %call19, i64 noundef 268435456)
  %tobool21 = icmp ne i32 %call20, 0
  br i1 %tobool21, label %if.end32, label %if.then22

if.then22:                                        ; preds = %if.end18
  %10 = load ptr, ptr %x.addr, align 8
  %call23 = call ptr @PyObject_GetIter(ptr noundef %10)
  store ptr %call23, ptr %it, align 8
  %11 = load ptr, ptr %it, align 8
  %cmp24 = icmp ne ptr %11, null
  br i1 %cmp24, label %if.then25, label %if.end27

if.then25:                                        ; preds = %if.then22
  %12 = load ptr, ptr %it, align 8
  %13 = load ptr, ptr %x.addr, align 8
  %call26 = call ptr @_PyBytes_FromIterator(ptr noundef %12, ptr noundef %13)
  store ptr %call26, ptr %result, align 8
  %14 = load ptr, ptr %it, align 8
  store ptr %14, ptr %op.addr.i, align 8
  %15 = load ptr, ptr %op.addr.i, align 8
  store ptr %15, ptr %op.addr.i35, align 8
  %16 = load ptr, ptr %op.addr.i35, align 8
  %17 = load i64, ptr %16, align 8
  %conv.i = trunc i64 %17 to i32
  %cmp.i36 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i36 to i32
  %tobool.i = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then25
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.then25
  %18 = load ptr, ptr %op.addr.i, align 8
  %19 = load i64, ptr %18, align 8
  %dec.i = add i64 %19, -1
  store i64 %dec.i, ptr %18, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %20 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %20) #9
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  %21 = load ptr, ptr %result, align 8
  store ptr %21, ptr %retval, align 8
  br label %return

if.end27:                                         ; preds = %if.then22
  %22 = load ptr, ptr @PyExc_TypeError, align 8
  %call28 = call i32 @PyErr_ExceptionMatches(ptr noundef %22)
  %tobool29 = icmp ne i32 %call28, 0
  br i1 %tobool29, label %if.end31, label %if.then30

if.then30:                                        ; preds = %if.end27
  store ptr null, ptr %retval, align 8
  br label %return

if.end31:                                         ; preds = %if.end27
  br label %if.end32

if.end32:                                         ; preds = %if.end31, %if.end18
  %23 = load ptr, ptr @PyExc_TypeError, align 8
  %24 = load ptr, ptr %x.addr, align 8
  %call33 = call ptr @Py_TYPE(ptr noundef %24)
  %tp_name = getelementptr inbounds %struct._typeobject, ptr %call33, i32 0, i32 1
  %25 = load ptr, ptr %tp_name, align 8
  %call34 = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %23, ptr noundef @.str.33, ptr noundef %25)
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end32, %if.then30, %Py_DECREF.exit, %if.then16, %if.then11, %if.then6, %if.then1, %if.then
  %26 = load ptr, ptr %retval, align 8
  ret ptr %26
}

; Function Attrs: nounwind uwtable
define internal ptr @_Py_NewRef(ptr noundef %obj) #0 {
entry:
  %op.addr.i = alloca ptr, align 8
  %cur_refcnt.i = alloca i32, align 4
  %new_refcnt.i = alloca i32, align 4
  %obj.addr = alloca ptr, align 8
  store ptr %obj, ptr %obj.addr, align 8
  %0 = load ptr, ptr %obj.addr, align 8
  store ptr %0, ptr %op.addr.i, align 8
  %1 = load ptr, ptr %op.addr.i, align 8
  %2 = load i32, ptr %1, align 8
  store i32 %2, ptr %cur_refcnt.i, align 4
  %3 = load i32, ptr %cur_refcnt.i, align 4
  %add.i = add i32 %3, 1
  store i32 %add.i, ptr %new_refcnt.i, align 4
  %4 = load i32, ptr %new_refcnt.i, align 4
  %cmp.i = icmp eq i32 %4, 0
  br i1 %cmp.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %entry
  br label %Py_INCREF.exit

if.end.i:                                         ; preds = %entry
  %5 = load i32, ptr %new_refcnt.i, align 4
  %6 = load ptr, ptr %op.addr.i, align 8
  store i32 %5, ptr %6, align 8
  br label %Py_INCREF.exit

Py_INCREF.exit:                                   ; preds = %if.end.i, %if.then.i
  %7 = load ptr, ptr %obj.addr, align 8
  ret ptr %7
}

declare i32 @PyObject_CheckBuffer(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @_PyBytes_FromBuffer(ptr noundef %x) #0 {
entry:
  %retval = alloca ptr, align 8
  %x.addr = alloca ptr, align 8
  %new = alloca ptr, align 8
  %view = alloca %struct.Py_buffer, align 8
  store ptr %x, ptr %x.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  %call = call i32 @PyObject_GetBuffer(ptr noundef %0, ptr noundef %view, i32 noundef 284)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %len = getelementptr inbounds %struct.Py_buffer, ptr %view, i32 0, i32 2
  %1 = load i64, ptr %len, align 8
  %call1 = call ptr @PyBytes_FromStringAndSize(ptr noundef null, i64 noundef %1)
  store ptr %call1, ptr %new, align 8
  %2 = load ptr, ptr %new, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.end3, label %if.then2

if.then2:                                         ; preds = %if.end
  br label %fail

if.end3:                                          ; preds = %if.end
  %3 = load ptr, ptr %new, align 8
  %ob_sval = getelementptr inbounds %struct.PyBytesObject, ptr %3, i32 0, i32 2
  %arraydecay = getelementptr inbounds [1 x i8], ptr %ob_sval, i64 0, i64 0
  %len4 = getelementptr inbounds %struct.Py_buffer, ptr %view, i32 0, i32 2
  %4 = load i64, ptr %len4, align 8
  %call5 = call i32 @PyBuffer_ToContiguous(ptr noundef %arraydecay, ptr noundef %view, i64 noundef %4, i8 noundef signext 67)
  %cmp6 = icmp slt i32 %call5, 0
  br i1 %cmp6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end3
  br label %fail

if.end8:                                          ; preds = %if.end3
  call void @PyBuffer_Release(ptr noundef %view)
  %5 = load ptr, ptr %new, align 8
  store ptr %5, ptr %retval, align 8
  br label %return

fail:                                             ; preds = %if.then7, %if.then2
  %6 = load ptr, ptr %new, align 8
  call void @Py_XDECREF(ptr noundef %6)
  call void @PyBuffer_Release(ptr noundef %view)
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %fail, %if.end8, %if.then
  %7 = load ptr, ptr %retval, align 8
  ret ptr %7
}

; Function Attrs: nounwind uwtable
define internal ptr @_PyBytes_FromList(ptr noundef %x) #0 {
entry:
  %op.addr.i26 = alloca ptr, align 8
  %op.addr.i22 = alloca ptr, align 8
  %cur_refcnt.i = alloca i32, align 4
  %new_refcnt.i = alloca i32, align 4
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %x.addr = alloca ptr, align 8
  %i = alloca i64, align 8
  %size = alloca i64, align 8
  %value = alloca i64, align 8
  %str = alloca ptr, align 8
  %item = alloca ptr, align 8
  %writer = alloca %struct._PyBytesWriter, align 8
  store ptr %x, ptr %x.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  %call = call i64 @PyList_GET_SIZE(ptr noundef %0)
  store i64 %call, ptr %size, align 8
  call void @_PyBytesWriter_Init(ptr noundef %writer)
  %1 = load i64, ptr %size, align 8
  %call1 = call ptr @_PyBytesWriter_Alloc(ptr noundef %writer, i64 noundef %1)
  store ptr %call1, ptr %str, align 8
  %2 = load ptr, ptr %str, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %overallocate = getelementptr inbounds %struct._PyBytesWriter, ptr %writer, i32 0, i32 4
  store i32 1, ptr %overallocate, align 4
  %allocated = getelementptr inbounds %struct._PyBytesWriter, ptr %writer, i32 0, i32 1
  %3 = load i64, ptr %allocated, align 8
  store i64 %3, ptr %size, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %4 = load i64, ptr %i, align 8
  %5 = load ptr, ptr %x.addr, align 8
  %call2 = call i64 @PyList_GET_SIZE(ptr noundef %5)
  %cmp3 = icmp slt i64 %4, %call2
  br i1 %cmp3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load ptr, ptr %x.addr, align 8
  %ob_item = getelementptr inbounds %struct.PyListObject, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %ob_item, align 8
  %8 = load i64, ptr %i, align 8
  %arrayidx = getelementptr ptr, ptr %7, i64 %8
  %9 = load ptr, ptr %arrayidx, align 8
  store ptr %9, ptr %item, align 8
  %10 = load ptr, ptr %item, align 8
  store ptr %10, ptr %op.addr.i22, align 8
  %11 = load ptr, ptr %op.addr.i22, align 8
  %12 = load i32, ptr %11, align 8
  store i32 %12, ptr %cur_refcnt.i, align 4
  %13 = load i32, ptr %cur_refcnt.i, align 4
  %add.i = add i32 %13, 1
  store i32 %add.i, ptr %new_refcnt.i, align 4
  %14 = load i32, ptr %new_refcnt.i, align 4
  %cmp.i23 = icmp eq i32 %14, 0
  br i1 %cmp.i23, label %if.then.i25, label %if.end.i24

if.then.i25:                                      ; preds = %for.body
  br label %Py_INCREF.exit

if.end.i24:                                       ; preds = %for.body
  %15 = load i32, ptr %new_refcnt.i, align 4
  %16 = load ptr, ptr %op.addr.i22, align 8
  store i32 %15, ptr %16, align 8
  br label %Py_INCREF.exit

Py_INCREF.exit:                                   ; preds = %if.end.i24, %if.then.i25
  %17 = load ptr, ptr %item, align 8
  %call4 = call i64 @PyNumber_AsSsize_t(ptr noundef %17, ptr noundef null)
  store i64 %call4, ptr %value, align 8
  %18 = load ptr, ptr %item, align 8
  store ptr %18, ptr %op.addr.i, align 8
  %19 = load ptr, ptr %op.addr.i, align 8
  store ptr %19, ptr %op.addr.i26, align 8
  %20 = load ptr, ptr %op.addr.i26, align 8
  %21 = load i64, ptr %20, align 8
  %conv.i = trunc i64 %21 to i32
  %cmp.i27 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i27 to i32
  %tobool.i = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %Py_INCREF.exit
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %Py_INCREF.exit
  %22 = load ptr, ptr %op.addr.i, align 8
  %23 = load i64, ptr %22, align 8
  %dec.i = add i64 %23, -1
  store i64 %dec.i, ptr %22, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %24 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %24) #9
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  %25 = load i64, ptr %value, align 8
  %cmp5 = icmp eq i64 %25, -1
  br i1 %cmp5, label %land.lhs.true, label %if.end8

land.lhs.true:                                    ; preds = %Py_DECREF.exit
  %call6 = call ptr @PyErr_Occurred()
  %tobool = icmp ne ptr %call6, null
  br i1 %tobool, label %if.then7, label %if.end8

if.then7:                                         ; preds = %land.lhs.true
  br label %error

if.end8:                                          ; preds = %land.lhs.true, %Py_DECREF.exit
  %26 = load i64, ptr %value, align 8
  %cmp9 = icmp slt i64 %26, 0
  br i1 %cmp9, label %if.then11, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end8
  %27 = load i64, ptr %value, align 8
  %cmp10 = icmp sge i64 %27, 256
  br i1 %cmp10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %lor.lhs.false, %if.end8
  %28 = load ptr, ptr @PyExc_ValueError, align 8
  call void @PyErr_SetString(ptr noundef %28, ptr noundef @.str.51)
  br label %error

if.end12:                                         ; preds = %lor.lhs.false
  %29 = load i64, ptr %i, align 8
  %30 = load i64, ptr %size, align 8
  %cmp13 = icmp sge i64 %29, %30
  br i1 %cmp13, label %if.then14, label %if.end20

if.then14:                                        ; preds = %if.end12
  %31 = load ptr, ptr %str, align 8
  %32 = load i64, ptr %size, align 8
  %add = add i64 %32, 1
  %call15 = call ptr @_PyBytesWriter_Resize(ptr noundef %writer, ptr noundef %31, i64 noundef %add)
  store ptr %call15, ptr %str, align 8
  %33 = load ptr, ptr %str, align 8
  %cmp16 = icmp eq ptr %33, null
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.then14
  store ptr null, ptr %retval, align 8
  br label %return

if.end18:                                         ; preds = %if.then14
  %allocated19 = getelementptr inbounds %struct._PyBytesWriter, ptr %writer, i32 0, i32 1
  %34 = load i64, ptr %allocated19, align 8
  store i64 %34, ptr %size, align 8
  br label %if.end20

if.end20:                                         ; preds = %if.end18, %if.end12
  %35 = load i64, ptr %value, align 8
  %conv = trunc i64 %35 to i8
  %36 = load ptr, ptr %str, align 8
  %incdec.ptr = getelementptr i8, ptr %36, i32 1
  store ptr %incdec.ptr, ptr %str, align 8
  store i8 %conv, ptr %36, align 1
  br label %for.inc

for.inc:                                          ; preds = %if.end20
  %37 = load i64, ptr %i, align 8
  %inc = add i64 %37, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !22

for.end:                                          ; preds = %for.cond
  %38 = load ptr, ptr %str, align 8
  %call21 = call ptr @_PyBytesWriter_Finish(ptr noundef %writer, ptr noundef %38)
  store ptr %call21, ptr %retval, align 8
  br label %return

error:                                            ; preds = %if.then11, %if.then7
  call void @_PyBytesWriter_Dealloc(ptr noundef %writer)
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %error, %for.end, %if.then17, %if.then
  %39 = load ptr, ptr %retval, align 8
  ret ptr %39
}

; Function Attrs: nounwind uwtable
define internal ptr @_PyBytes_FromTuple(ptr noundef %x) #0 {
entry:
  %op.addr.i12 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %x.addr = alloca ptr, align 8
  %bytes = alloca ptr, align 8
  %i = alloca i64, align 8
  %size = alloca i64, align 8
  %value = alloca i64, align 8
  %str = alloca ptr, align 8
  %item = alloca ptr, align 8
  store ptr %x, ptr %x.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %0)
  store i64 %call, ptr %size, align 8
  %1 = load i64, ptr %size, align 8
  %call1 = call ptr @PyBytes_FromStringAndSize(ptr noundef null, i64 noundef %1)
  store ptr %call1, ptr %bytes, align 8
  %2 = load ptr, ptr %bytes, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %bytes, align 8
  %ob_sval = getelementptr inbounds %struct.PyBytesObject, ptr %3, i32 0, i32 2
  %arraydecay = getelementptr inbounds [1 x i8], ptr %ob_sval, i64 0, i64 0
  store ptr %arraydecay, ptr %str, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %4 = load i64, ptr %i, align 8
  %5 = load i64, ptr %size, align 8
  %cmp2 = icmp slt i64 %4, %5
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load ptr, ptr %x.addr, align 8
  %ob_item = getelementptr inbounds %struct.PyTupleObject, ptr %6, i32 0, i32 1
  %7 = load i64, ptr %i, align 8
  %arrayidx = getelementptr [1 x ptr], ptr %ob_item, i64 0, i64 %7
  %8 = load ptr, ptr %arrayidx, align 8
  store ptr %8, ptr %item, align 8
  %9 = load ptr, ptr %item, align 8
  %call3 = call i64 @PyNumber_AsSsize_t(ptr noundef %9, ptr noundef null)
  store i64 %call3, ptr %value, align 8
  %10 = load i64, ptr %value, align 8
  %cmp4 = icmp eq i64 %10, -1
  br i1 %cmp4, label %land.lhs.true, label %if.end7

land.lhs.true:                                    ; preds = %for.body
  %call5 = call ptr @PyErr_Occurred()
  %tobool = icmp ne ptr %call5, null
  br i1 %tobool, label %if.then6, label %if.end7

if.then6:                                         ; preds = %land.lhs.true
  br label %error

if.end7:                                          ; preds = %land.lhs.true, %for.body
  %11 = load i64, ptr %value, align 8
  %cmp8 = icmp slt i64 %11, 0
  br i1 %cmp8, label %if.then10, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end7
  %12 = load i64, ptr %value, align 8
  %cmp9 = icmp sge i64 %12, 256
  br i1 %cmp9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %lor.lhs.false, %if.end7
  %13 = load ptr, ptr @PyExc_ValueError, align 8
  call void @PyErr_SetString(ptr noundef %13, ptr noundef @.str.51)
  br label %error

if.end11:                                         ; preds = %lor.lhs.false
  %14 = load i64, ptr %value, align 8
  %conv = trunc i64 %14 to i8
  %15 = load ptr, ptr %str, align 8
  %incdec.ptr = getelementptr i8, ptr %15, i32 1
  store ptr %incdec.ptr, ptr %str, align 8
  store i8 %conv, ptr %15, align 1
  br label %for.inc

for.inc:                                          ; preds = %if.end11
  %16 = load i64, ptr %i, align 8
  %inc = add i64 %16, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !23

for.end:                                          ; preds = %for.cond
  %17 = load ptr, ptr %bytes, align 8
  store ptr %17, ptr %retval, align 8
  br label %return

error:                                            ; preds = %if.then10, %if.then6
  %18 = load ptr, ptr %bytes, align 8
  store ptr %18, ptr %op.addr.i, align 8
  %19 = load ptr, ptr %op.addr.i, align 8
  store ptr %19, ptr %op.addr.i12, align 8
  %20 = load ptr, ptr %op.addr.i12, align 8
  %21 = load i64, ptr %20, align 8
  %conv.i = trunc i64 %21 to i32
  %cmp.i13 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i13 to i32
  %tobool.i = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %error
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %error
  %22 = load ptr, ptr %op.addr.i, align 8
  %23 = load i64, ptr %22, align 8
  %dec.i = add i64 %23, -1
  store i64 %dec.i, ptr %22, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %24 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %24) #9
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %Py_DECREF.exit, %for.end, %if.then
  %25 = load ptr, ptr %retval, align 8
  ret ptr %25
}

declare ptr @PyObject_GetIter(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @_PyBytes_FromIterator(ptr noundef %it, ptr noundef %x) #0 {
entry:
  %op.addr.i34 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %it.addr = alloca ptr, align 8
  %x.addr = alloca ptr, align 8
  %str = alloca ptr, align 8
  %i = alloca i64, align 8
  %size = alloca i64, align 8
  %writer = alloca %struct._PyBytesWriter, align 8
  %item = alloca ptr, align 8
  %value = alloca i64, align 8
  store ptr %it, ptr %it.addr, align 8
  store ptr %x, ptr %x.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  %call = call i64 @PyObject_LengthHint(ptr noundef %0, i64 noundef 64)
  store i64 %call, ptr %size, align 8
  %1 = load i64, ptr %size, align 8
  %cmp = icmp eq i64 %1, -1
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %call1 = call ptr @PyErr_Occurred()
  %tobool = icmp ne ptr %call1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  call void @_PyBytesWriter_Init(ptr noundef %writer)
  %2 = load i64, ptr %size, align 8
  %call2 = call ptr @_PyBytesWriter_Alloc(ptr noundef %writer, i64 noundef %2)
  store ptr %call2, ptr %str, align 8
  %3 = load ptr, ptr %str, align 8
  %cmp3 = icmp eq ptr %3, null
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end5:                                          ; preds = %if.end
  %overallocate = getelementptr inbounds %struct._PyBytesWriter, ptr %writer, i32 0, i32 4
  store i32 1, ptr %overallocate, align 4
  %allocated = getelementptr inbounds %struct._PyBytesWriter, ptr %writer, i32 0, i32 1
  %4 = load i64, ptr %allocated, align 8
  store i64 %4, ptr %size, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end5
  %5 = load ptr, ptr %it.addr, align 8
  %call6 = call ptr @PyIter_Next(ptr noundef %5)
  store ptr %call6, ptr %item, align 8
  %6 = load ptr, ptr %item, align 8
  %cmp7 = icmp eq ptr %6, null
  br i1 %cmp7, label %if.then8, label %if.end13

if.then8:                                         ; preds = %for.cond
  %call9 = call ptr @PyErr_Occurred()
  %tobool10 = icmp ne ptr %call9, null
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.then8
  br label %error

if.end12:                                         ; preds = %if.then8
  br label %for.end

if.end13:                                         ; preds = %for.cond
  %7 = load ptr, ptr %item, align 8
  %call14 = call i64 @PyNumber_AsSsize_t(ptr noundef %7, ptr noundef null)
  store i64 %call14, ptr %value, align 8
  %8 = load ptr, ptr %item, align 8
  store ptr %8, ptr %op.addr.i, align 8
  %9 = load ptr, ptr %op.addr.i, align 8
  store ptr %9, ptr %op.addr.i34, align 8
  %10 = load ptr, ptr %op.addr.i34, align 8
  %11 = load i64, ptr %10, align 8
  %conv.i = trunc i64 %11 to i32
  %cmp.i35 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i35 to i32
  %tobool.i = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.end13
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.end13
  %12 = load ptr, ptr %op.addr.i, align 8
  %13 = load i64, ptr %12, align 8
  %dec.i = add i64 %13, -1
  store i64 %dec.i, ptr %12, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %14 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %14) #9
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  %15 = load i64, ptr %value, align 8
  %cmp15 = icmp eq i64 %15, -1
  br i1 %cmp15, label %land.lhs.true16, label %if.end20

land.lhs.true16:                                  ; preds = %Py_DECREF.exit
  %call17 = call ptr @PyErr_Occurred()
  %tobool18 = icmp ne ptr %call17, null
  br i1 %tobool18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %land.lhs.true16
  br label %error

if.end20:                                         ; preds = %land.lhs.true16, %Py_DECREF.exit
  %16 = load i64, ptr %value, align 8
  %cmp21 = icmp slt i64 %16, 0
  br i1 %cmp21, label %if.then23, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end20
  %17 = load i64, ptr %value, align 8
  %cmp22 = icmp sge i64 %17, 256
  br i1 %cmp22, label %if.then23, label %if.end24

if.then23:                                        ; preds = %lor.lhs.false, %if.end20
  %18 = load ptr, ptr @PyExc_ValueError, align 8
  call void @PyErr_SetString(ptr noundef %18, ptr noundef @.str.51)
  br label %error

if.end24:                                         ; preds = %lor.lhs.false
  %19 = load i64, ptr %i, align 8
  %20 = load i64, ptr %size, align 8
  %cmp25 = icmp sge i64 %19, %20
  br i1 %cmp25, label %if.then26, label %if.end32

if.then26:                                        ; preds = %if.end24
  %21 = load ptr, ptr %str, align 8
  %22 = load i64, ptr %size, align 8
  %add = add i64 %22, 1
  %call27 = call ptr @_PyBytesWriter_Resize(ptr noundef %writer, ptr noundef %21, i64 noundef %add)
  store ptr %call27, ptr %str, align 8
  %23 = load ptr, ptr %str, align 8
  %cmp28 = icmp eq ptr %23, null
  br i1 %cmp28, label %if.then29, label %if.end30

if.then29:                                        ; preds = %if.then26
  store ptr null, ptr %retval, align 8
  br label %return

if.end30:                                         ; preds = %if.then26
  %allocated31 = getelementptr inbounds %struct._PyBytesWriter, ptr %writer, i32 0, i32 1
  %24 = load i64, ptr %allocated31, align 8
  store i64 %24, ptr %size, align 8
  br label %if.end32

if.end32:                                         ; preds = %if.end30, %if.end24
  %25 = load i64, ptr %value, align 8
  %conv = trunc i64 %25 to i8
  %26 = load ptr, ptr %str, align 8
  %incdec.ptr = getelementptr i8, ptr %26, i32 1
  store ptr %incdec.ptr, ptr %str, align 8
  store i8 %conv, ptr %26, align 1
  br label %for.inc

for.inc:                                          ; preds = %if.end32
  %27 = load i64, ptr %i, align 8
  %inc = add i64 %27, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond

for.end:                                          ; preds = %if.end12
  %28 = load ptr, ptr %str, align 8
  %call33 = call ptr @_PyBytesWriter_Finish(ptr noundef %writer, ptr noundef %28)
  store ptr %call33, ptr %retval, align 8
  br label %return

error:                                            ; preds = %if.then23, %if.then19, %if.then11
  call void @_PyBytesWriter_Dealloc(ptr noundef %writer)
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %error, %for.end, %if.then29, %if.then4, %if.then
  %29 = load ptr, ptr %retval, align 8
  ret ptr %29
}

declare i32 @PyErr_ExceptionMatches(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @bytes_repr(ptr noundef %op) #0 {
entry:
  %op.addr = alloca ptr, align 8
  store ptr %op, ptr %op.addr, align 8
  %0 = load ptr, ptr %op.addr, align 8
  %call = call ptr @PyBytes_Repr(ptr noundef %0, i32 noundef 1)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal i64 @bytes_hash(ptr noundef %a) #0 {
entry:
  %a.addr = alloca ptr, align 8
  store ptr %a, ptr %a.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %ob_shash = getelementptr inbounds %struct.PyBytesObject, ptr %0, i32 0, i32 1
  %1 = load i64, ptr %ob_shash, align 8
  %cmp = icmp eq i64 %1, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %a.addr, align 8
  %ob_sval = getelementptr inbounds %struct.PyBytesObject, ptr %2, i32 0, i32 2
  %arraydecay = getelementptr inbounds [1 x i8], ptr %ob_sval, i64 0, i64 0
  %3 = load ptr, ptr %a.addr, align 8
  %call = call i64 @Py_SIZE(ptr noundef %3)
  %call1 = call i64 @_Py_HashBytes(ptr noundef %arraydecay, i64 noundef %call)
  %4 = load ptr, ptr %a.addr, align 8
  %ob_shash2 = getelementptr inbounds %struct.PyBytesObject, ptr %4, i32 0, i32 1
  store i64 %call1, ptr %ob_shash2, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load ptr, ptr %a.addr, align 8
  %ob_shash3 = getelementptr inbounds %struct.PyBytesObject, ptr %5, i32 0, i32 1
  %6 = load i64, ptr %ob_shash3, align 8
  ret i64 %6
}

; Function Attrs: nounwind uwtable
define internal ptr @bytes_str(ptr noundef %op) #0 {
entry:
  %retval = alloca ptr, align 8
  %op.addr = alloca ptr, align 8
  store ptr %op, ptr %op.addr, align 8
  %call = call ptr @_Py_GetConfig()
  %bytes_warning = getelementptr inbounds %struct.PyConfig, ptr %call, i32 0, i32 25
  %0 = load i32, ptr %bytes_warning, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end4

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr @PyExc_BytesWarning, align 8
  %call1 = call i32 @PyErr_WarnEx(ptr noundef %1, ptr noundef @.str.56, i64 noundef 1)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %if.then
  br label %if.end4

if.end4:                                          ; preds = %if.end, %entry
  %2 = load ptr, ptr %op.addr, align 8
  %call5 = call ptr @bytes_repr(ptr noundef %2)
  store ptr %call5, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end4, %if.then3
  %3 = load ptr, ptr %retval, align 8
  ret ptr %3
}

declare ptr @PyObject_GenericGetAttr(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @bytes_richcompare(ptr noundef %a, ptr noundef %b, i32 noundef %op) #0 {
entry:
  %retval = alloca ptr, align 8
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  %op.addr = alloca i32, align 4
  %c = alloca i32, align 4
  %len_a = alloca i64, align 8
  %len_b = alloca i64, align 8
  %min_len = alloca i64, align 8
  %eq = alloca i32, align 4
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  store i32 %op, ptr %op.addr, align 4
  %0 = load ptr, ptr %a.addr, align 8
  %call = call ptr @Py_TYPE(ptr noundef %0)
  %call1 = call i32 @PyType_HasFeature(ptr noundef %call, i64 noundef 134217728)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %b.addr, align 8
  %call2 = call ptr @Py_TYPE(ptr noundef %1)
  %call3 = call i32 @PyType_HasFeature(ptr noundef %call2, i64 noundef 134217728)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.else, label %if.then

if.then:                                          ; preds = %land.lhs.true, %entry
  %call5 = call ptr @_Py_GetConfig()
  %bytes_warning = getelementptr inbounds %struct.PyConfig, ptr %call5, i32 0, i32 25
  %2 = load i32, ptr %bytes_warning, align 4
  %tobool6 = icmp ne i32 %2, 0
  br i1 %tobool6, label %land.lhs.true7, label %if.end35

land.lhs.true7:                                   ; preds = %if.then
  %3 = load i32, ptr %op.addr, align 4
  %cmp = icmp eq i32 %3, 2
  br i1 %cmp, label %if.then9, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true7
  %4 = load i32, ptr %op.addr, align 4
  %cmp8 = icmp eq i32 %4, 3
  br i1 %cmp8, label %if.then9, label %if.end35

if.then9:                                         ; preds = %lor.lhs.false, %land.lhs.true7
  %5 = load ptr, ptr %a.addr, align 8
  %call10 = call ptr @Py_TYPE(ptr noundef %5)
  %call11 = call i32 @PyType_HasFeature(ptr noundef %call10, i64 noundef 268435456)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %if.then17, label %lor.lhs.false13

lor.lhs.false13:                                  ; preds = %if.then9
  %6 = load ptr, ptr %b.addr, align 8
  %call14 = call ptr @Py_TYPE(ptr noundef %6)
  %call15 = call i32 @PyType_HasFeature(ptr noundef %call14, i64 noundef 268435456)
  %tobool16 = icmp ne i32 %call15, 0
  br i1 %tobool16, label %if.then17, label %if.end21

if.then17:                                        ; preds = %lor.lhs.false13, %if.then9
  %7 = load ptr, ptr @PyExc_BytesWarning, align 8
  %call18 = call i32 @PyErr_WarnEx(ptr noundef %7, ptr noundef @.str.57, i64 noundef 1)
  %tobool19 = icmp ne i32 %call18, 0
  br i1 %tobool19, label %if.then20, label %if.end

if.then20:                                        ; preds = %if.then17
  store ptr null, ptr %retval, align 8
  br label %if.end147

if.end:                                           ; preds = %if.then17
  br label %if.end21

if.end21:                                         ; preds = %if.end, %lor.lhs.false13
  %8 = load ptr, ptr %a.addr, align 8
  %call22 = call ptr @Py_TYPE(ptr noundef %8)
  %call23 = call i32 @PyType_HasFeature(ptr noundef %call22, i64 noundef 16777216)
  %tobool24 = icmp ne i32 %call23, 0
  br i1 %tobool24, label %if.then29, label %lor.lhs.false25

lor.lhs.false25:                                  ; preds = %if.end21
  %9 = load ptr, ptr %b.addr, align 8
  %call26 = call ptr @Py_TYPE(ptr noundef %9)
  %call27 = call i32 @PyType_HasFeature(ptr noundef %call26, i64 noundef 16777216)
  %tobool28 = icmp ne i32 %call27, 0
  br i1 %tobool28, label %if.then29, label %if.end34

if.then29:                                        ; preds = %lor.lhs.false25, %if.end21
  %10 = load ptr, ptr @PyExc_BytesWarning, align 8
  %call30 = call i32 @PyErr_WarnEx(ptr noundef %10, ptr noundef @.str.58, i64 noundef 1)
  %tobool31 = icmp ne i32 %call30, 0
  br i1 %tobool31, label %if.then32, label %if.end33

if.then32:                                        ; preds = %if.then29
  store ptr null, ptr %retval, align 8
  br label %if.end147

if.end33:                                         ; preds = %if.then29
  br label %if.end34

if.end34:                                         ; preds = %if.end33, %lor.lhs.false25
  br label %if.end35

if.end35:                                         ; preds = %if.end34, %lor.lhs.false, %if.then
  store ptr @_Py_NotImplementedStruct, ptr %retval, align 8
  br label %if.end147

if.else:                                          ; preds = %land.lhs.true
  %11 = load ptr, ptr %a.addr, align 8
  %12 = load ptr, ptr %b.addr, align 8
  %cmp36 = icmp eq ptr %11, %12
  br i1 %cmp36, label %if.then37, label %if.else40

if.then37:                                        ; preds = %if.else
  %13 = load i32, ptr %op.addr, align 4
  switch i32 %13, label %sw.default [
    i32 2, label %sw.bb
    i32 1, label %sw.bb
    i32 5, label %sw.bb
    i32 3, label %sw.bb38
    i32 0, label %sw.bb38
    i32 4, label %sw.bb38
  ]

sw.bb:                                            ; preds = %if.then37, %if.then37, %if.then37
  store ptr @_Py_TrueStruct, ptr %retval, align 8
  br label %if.end147

sw.bb38:                                          ; preds = %if.then37, %if.then37, %if.then37
  store ptr @_Py_FalseStruct, ptr %retval, align 8
  br label %if.end147

sw.default:                                       ; preds = %if.then37
  %call39 = call i32 @PyErr_BadArgument()
  store ptr null, ptr %retval, align 8
  br label %if.end147

if.else40:                                        ; preds = %if.else
  %14 = load i32, ptr %op.addr, align 4
  %cmp41 = icmp eq i32 %14, 2
  br i1 %cmp41, label %if.then44, label %lor.lhs.false42

lor.lhs.false42:                                  ; preds = %if.else40
  %15 = load i32, ptr %op.addr, align 4
  %cmp43 = icmp eq i32 %15, 3
  br i1 %cmp43, label %if.then44, label %if.else49

if.then44:                                        ; preds = %lor.lhs.false42, %if.else40
  %16 = load ptr, ptr %a.addr, align 8
  %17 = load ptr, ptr %b.addr, align 8
  %call45 = call i32 @bytes_compare_eq(ptr noundef %16, ptr noundef %17)
  store i32 %call45, ptr %eq, align 4
  %18 = load i32, ptr %op.addr, align 4
  %cmp46 = icmp eq i32 %18, 3
  %conv = zext i1 %cmp46 to i32
  %19 = load i32, ptr %eq, align 4
  %xor = xor i32 %19, %conv
  store i32 %xor, ptr %eq, align 4
  %20 = load i32, ptr %eq, align 4
  %conv47 = sext i32 %20 to i64
  %call48 = call ptr @PyBool_FromLong(i64 noundef %conv47)
  store ptr %call48, ptr %retval, align 8
  br label %if.end147

if.else49:                                        ; preds = %lor.lhs.false42
  %21 = load ptr, ptr %a.addr, align 8
  %call50 = call i64 @Py_SIZE(ptr noundef %21)
  store i64 %call50, ptr %len_a, align 8
  %22 = load ptr, ptr %b.addr, align 8
  %call51 = call i64 @Py_SIZE(ptr noundef %22)
  store i64 %call51, ptr %len_b, align 8
  %23 = load i64, ptr %len_a, align 8
  %24 = load i64, ptr %len_b, align 8
  %cmp52 = icmp sgt i64 %23, %24
  br i1 %cmp52, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.else49
  %25 = load i64, ptr %len_b, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.else49
  %26 = load i64, ptr %len_a, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %25, %cond.true ], [ %26, %cond.false ]
  store i64 %cond, ptr %min_len, align 8
  %27 = load i64, ptr %min_len, align 8
  %cmp54 = icmp sgt i64 %27, 0
  br i1 %cmp54, label %if.then56, label %if.else75

if.then56:                                        ; preds = %cond.end
  %28 = load ptr, ptr %a.addr, align 8
  %ob_sval = getelementptr inbounds %struct.PyBytesObject, ptr %28, i32 0, i32 2
  %arraydecay = getelementptr inbounds [1 x i8], ptr %ob_sval, i64 0, i64 0
  %29 = load i8, ptr %arraydecay, align 8
  %conv57 = sext i8 %29 to i32
  %and = and i32 %conv57, 255
  %conv58 = trunc i32 %and to i8
  %conv59 = zext i8 %conv58 to i32
  %30 = load ptr, ptr %b.addr, align 8
  %ob_sval60 = getelementptr inbounds %struct.PyBytesObject, ptr %30, i32 0, i32 2
  %arraydecay61 = getelementptr inbounds [1 x i8], ptr %ob_sval60, i64 0, i64 0
  %31 = load i8, ptr %arraydecay61, align 8
  %conv62 = sext i8 %31 to i32
  %and63 = and i32 %conv62, 255
  %conv64 = trunc i32 %and63 to i8
  %conv65 = zext i8 %conv64 to i32
  %sub = sub i32 %conv59, %conv65
  store i32 %sub, ptr %c, align 4
  %32 = load i32, ptr %c, align 4
  %cmp66 = icmp eq i32 %32, 0
  br i1 %cmp66, label %if.then68, label %if.end74

if.then68:                                        ; preds = %if.then56
  %33 = load ptr, ptr %a.addr, align 8
  %ob_sval69 = getelementptr inbounds %struct.PyBytesObject, ptr %33, i32 0, i32 2
  %arraydecay70 = getelementptr inbounds [1 x i8], ptr %ob_sval69, i64 0, i64 0
  %34 = load ptr, ptr %b.addr, align 8
  %ob_sval71 = getelementptr inbounds %struct.PyBytesObject, ptr %34, i32 0, i32 2
  %arraydecay72 = getelementptr inbounds [1 x i8], ptr %ob_sval71, i64 0, i64 0
  %35 = load i64, ptr %min_len, align 8
  %call73 = call i32 @memcmp(ptr noundef %arraydecay70, ptr noundef %arraydecay72, i64 noundef %35) #8
  store i32 %call73, ptr %c, align 4
  br label %if.end74

if.end74:                                         ; preds = %if.then68, %if.then56
  br label %if.end76

if.else75:                                        ; preds = %cond.end
  store i32 0, ptr %c, align 4
  br label %if.end76

if.end76:                                         ; preds = %if.else75, %if.end74
  %36 = load i32, ptr %c, align 4
  %cmp77 = icmp ne i32 %36, 0
  br i1 %cmp77, label %if.then79, label %if.end111

if.then79:                                        ; preds = %if.end76
  br label %do.body

do.body:                                          ; preds = %if.then79
  %37 = load i32, ptr %op.addr, align 4
  switch i32 %37, label %sw.default110 [
    i32 2, label %sw.bb80
    i32 3, label %sw.bb85
    i32 0, label %sw.bb90
    i32 4, label %sw.bb95
    i32 1, label %sw.bb100
    i32 5, label %sw.bb105
  ]

sw.bb80:                                          ; preds = %do.body
  %38 = load i32, ptr %c, align 4
  %cmp81 = icmp eq i32 %38, 0
  br i1 %cmp81, label %if.then83, label %if.end84

if.then83:                                        ; preds = %sw.bb80
  store ptr @_Py_TrueStruct, ptr %retval, align 8
  br label %if.end147

if.end84:                                         ; preds = %sw.bb80
  store ptr @_Py_FalseStruct, ptr %retval, align 8
  br label %if.end147

sw.bb85:                                          ; preds = %do.body
  %39 = load i32, ptr %c, align 4
  %cmp86 = icmp ne i32 %39, 0
  br i1 %cmp86, label %if.then88, label %if.end89

if.then88:                                        ; preds = %sw.bb85
  store ptr @_Py_TrueStruct, ptr %retval, align 8
  br label %if.end147

if.end89:                                         ; preds = %sw.bb85
  store ptr @_Py_FalseStruct, ptr %retval, align 8
  br label %if.end147

sw.bb90:                                          ; preds = %do.body
  %40 = load i32, ptr %c, align 4
  %cmp91 = icmp slt i32 %40, 0
  br i1 %cmp91, label %if.then93, label %if.end94

if.then93:                                        ; preds = %sw.bb90
  store ptr @_Py_TrueStruct, ptr %retval, align 8
  br label %if.end147

if.end94:                                         ; preds = %sw.bb90
  store ptr @_Py_FalseStruct, ptr %retval, align 8
  br label %if.end147

sw.bb95:                                          ; preds = %do.body
  %41 = load i32, ptr %c, align 4
  %cmp96 = icmp sgt i32 %41, 0
  br i1 %cmp96, label %if.then98, label %if.end99

if.then98:                                        ; preds = %sw.bb95
  store ptr @_Py_TrueStruct, ptr %retval, align 8
  br label %if.end147

if.end99:                                         ; preds = %sw.bb95
  store ptr @_Py_FalseStruct, ptr %retval, align 8
  br label %if.end147

sw.bb100:                                         ; preds = %do.body
  %42 = load i32, ptr %c, align 4
  %cmp101 = icmp sle i32 %42, 0
  br i1 %cmp101, label %if.then103, label %if.end104

if.then103:                                       ; preds = %sw.bb100
  store ptr @_Py_TrueStruct, ptr %retval, align 8
  br label %if.end147

if.end104:                                        ; preds = %sw.bb100
  store ptr @_Py_FalseStruct, ptr %retval, align 8
  br label %if.end147

sw.bb105:                                         ; preds = %do.body
  %43 = load i32, ptr %c, align 4
  %cmp106 = icmp sge i32 %43, 0
  br i1 %cmp106, label %if.then108, label %if.end109

if.then108:                                       ; preds = %sw.bb105
  store ptr @_Py_TrueStruct, ptr %retval, align 8
  br label %if.end147

if.end109:                                        ; preds = %sw.bb105
  store ptr @_Py_FalseStruct, ptr %retval, align 8
  br label %if.end147

sw.default110:                                    ; preds = %do.body
  unreachable

do.end:                                           ; No predecessors!
  br label %if.end111

if.end111:                                        ; preds = %do.end, %if.end76
  br label %do.body112

do.body112:                                       ; preds = %if.end111
  %44 = load i32, ptr %op.addr, align 4
  switch i32 %44, label %sw.default143 [
    i32 2, label %sw.bb113
    i32 3, label %sw.bb118
    i32 0, label %sw.bb123
    i32 4, label %sw.bb128
    i32 1, label %sw.bb133
    i32 5, label %sw.bb138
  ]

sw.bb113:                                         ; preds = %do.body112
  %45 = load i64, ptr %len_a, align 8
  %46 = load i64, ptr %len_b, align 8
  %cmp114 = icmp eq i64 %45, %46
  br i1 %cmp114, label %if.then116, label %if.end117

if.then116:                                       ; preds = %sw.bb113
  store ptr @_Py_TrueStruct, ptr %retval, align 8
  br label %if.end147

if.end117:                                        ; preds = %sw.bb113
  store ptr @_Py_FalseStruct, ptr %retval, align 8
  br label %if.end147

sw.bb118:                                         ; preds = %do.body112
  %47 = load i64, ptr %len_a, align 8
  %48 = load i64, ptr %len_b, align 8
  %cmp119 = icmp ne i64 %47, %48
  br i1 %cmp119, label %if.then121, label %if.end122

if.then121:                                       ; preds = %sw.bb118
  store ptr @_Py_TrueStruct, ptr %retval, align 8
  br label %if.end147

if.end122:                                        ; preds = %sw.bb118
  store ptr @_Py_FalseStruct, ptr %retval, align 8
  br label %if.end147

sw.bb123:                                         ; preds = %do.body112
  %49 = load i64, ptr %len_a, align 8
  %50 = load i64, ptr %len_b, align 8
  %cmp124 = icmp slt i64 %49, %50
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %sw.bb123
  store ptr @_Py_TrueStruct, ptr %retval, align 8
  br label %if.end147

if.end127:                                        ; preds = %sw.bb123
  store ptr @_Py_FalseStruct, ptr %retval, align 8
  br label %if.end147

sw.bb128:                                         ; preds = %do.body112
  %51 = load i64, ptr %len_a, align 8
  %52 = load i64, ptr %len_b, align 8
  %cmp129 = icmp sgt i64 %51, %52
  br i1 %cmp129, label %if.then131, label %if.end132

if.then131:                                       ; preds = %sw.bb128
  store ptr @_Py_TrueStruct, ptr %retval, align 8
  br label %if.end147

if.end132:                                        ; preds = %sw.bb128
  store ptr @_Py_FalseStruct, ptr %retval, align 8
  br label %if.end147

sw.bb133:                                         ; preds = %do.body112
  %53 = load i64, ptr %len_a, align 8
  %54 = load i64, ptr %len_b, align 8
  %cmp134 = icmp sle i64 %53, %54
  br i1 %cmp134, label %if.then136, label %if.end137

if.then136:                                       ; preds = %sw.bb133
  store ptr @_Py_TrueStruct, ptr %retval, align 8
  br label %if.end147

if.end137:                                        ; preds = %sw.bb133
  store ptr @_Py_FalseStruct, ptr %retval, align 8
  br label %if.end147

sw.bb138:                                         ; preds = %do.body112
  %55 = load i64, ptr %len_a, align 8
  %56 = load i64, ptr %len_b, align 8
  %cmp139 = icmp sge i64 %55, %56
  br i1 %cmp139, label %if.then141, label %if.end142

if.then141:                                       ; preds = %sw.bb138
  store ptr @_Py_TrueStruct, ptr %retval, align 8
  br label %if.end147

if.end142:                                        ; preds = %sw.bb138
  store ptr @_Py_FalseStruct, ptr %retval, align 8
  br label %if.end147

sw.default143:                                    ; preds = %do.body112
  unreachable

do.end144:                                        ; No predecessors!
  br label %if.end145

if.end145:                                        ; preds = %do.end144
  br label %if.end146

if.end146:                                        ; preds = %if.end145
  br label %if.end147

if.end147:                                        ; preds = %if.end146, %if.end142, %if.then141, %if.end137, %if.then136, %if.end132, %if.then131, %if.end127, %if.then126, %if.end122, %if.then121, %if.end117, %if.then116, %if.end109, %if.then108, %if.end104, %if.then103, %if.end99, %if.then98, %if.end94, %if.then93, %if.end89, %if.then88, %if.end84, %if.then83, %if.then44, %sw.default, %sw.bb38, %sw.bb, %if.end35, %if.then32, %if.then20
  %57 = load ptr, ptr %retval, align 8
  ret ptr %57
}

; Function Attrs: nounwind uwtable
define internal ptr @bytes_iter(ptr noundef %seq) #0 {
entry:
  %retval = alloca ptr, align 8
  %seq.addr = alloca ptr, align 8
  %it = alloca ptr, align 8
  store ptr %seq, ptr %seq.addr, align 8
  %0 = load ptr, ptr %seq.addr, align 8
  %call = call ptr @Py_TYPE(ptr noundef %0)
  %call1 = call i32 @PyType_HasFeature(ptr noundef %call, i64 noundef 134217728)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void @_PyErr_BadInternalCall(ptr noundef @.str.12, i32 noundef 3241)
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %call2 = call ptr @_PyObject_GC_New(ptr noundef @PyBytesIter_Type)
  store ptr %call2, ptr %it, align 8
  %1 = load ptr, ptr %it, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  %2 = load ptr, ptr %it, align 8
  %it_index = getelementptr inbounds %struct.striterobject, ptr %2, i32 0, i32 1
  store i64 0, ptr %it_index, align 8
  %3 = load ptr, ptr %seq.addr, align 8
  %call5 = call ptr @_Py_NewRef(ptr noundef %3)
  %4 = load ptr, ptr %it, align 8
  %it_seq = getelementptr inbounds %struct.striterobject, ptr %4, i32 0, i32 2
  store ptr %call5, ptr %it_seq, align 8
  %5 = load ptr, ptr %it, align 8
  call void @_PyObject_GC_TRACK(ptr noundef %5)
  %6 = load ptr, ptr %it, align 8
  store ptr %6, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end4, %if.then3, %if.then
  %7 = load ptr, ptr %retval, align 8
  ret ptr %7
}

; Function Attrs: nounwind uwtable
define internal ptr @bytes_alloc(ptr noundef %self, i64 noundef %nitems) #0 {
entry:
  %retval = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  %nitems.addr = alloca i64, align 8
  %obj = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store i64 %nitems, ptr %nitems.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %1 = load i64, ptr %nitems.addr, align 8
  %call = call ptr @PyType_GenericAlloc(ptr noundef %0, i64 noundef %1)
  store ptr %call, ptr %obj, align 8
  %2 = load ptr, ptr %obj, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %obj, align 8
  %ob_shash = getelementptr inbounds %struct.PyBytesObject, ptr %3, i32 0, i32 1
  store i64 -1, ptr %ob_shash, align 8
  %4 = load ptr, ptr %obj, align 8
  store ptr %4, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %5 = load ptr, ptr %retval, align 8
  ret ptr %5
}

; Function Attrs: nounwind uwtable
define internal ptr @bytes_new(ptr noundef %type, ptr noundef %args, ptr noundef %kwargs) #0 {
entry:
  %type.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %kwargs.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [3 x ptr], align 16
  %fastargs = alloca ptr, align 8
  %nargs = alloca i64, align 8
  %noptargs = alloca i64, align 8
  %x = alloca ptr, align 8
  %encoding = alloca ptr, align 8
  %errors = alloca ptr, align 8
  %encoding_length = alloca i64, align 8
  %errors_length = alloca i64, align 8
  store ptr %type, ptr %type.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store ptr %kwargs, ptr %kwargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %args.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %0)
  store i64 %call, ptr %nargs, align 8
  %1 = load i64, ptr %nargs, align 8
  %2 = load ptr, ptr %kwargs.addr, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load ptr, ptr %kwargs.addr, align 8
  %call1 = call i64 @PyDict_GET_SIZE(ptr noundef %3)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call1, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %1, %cond
  %sub = sub i64 %add, 0
  store i64 %sub, ptr %noptargs, align 8
  store ptr null, ptr %x, align 8
  store ptr null, ptr %encoding, align 8
  store ptr null, ptr %errors, align 8
  %4 = load ptr, ptr %kwargs.addr, align 8
  %cmp = icmp eq ptr %4, null
  br i1 %cmp, label %land.lhs.true, label %cond.false10

land.lhs.true:                                    ; preds = %cond.end
  %5 = load i64, ptr %nargs, align 8
  %cmp2 = icmp sle i64 0, %5
  br i1 %cmp2, label %land.lhs.true3, label %cond.false10

land.lhs.true3:                                   ; preds = %land.lhs.true
  %6 = load i64, ptr %nargs, align 8
  %cmp4 = icmp sle i64 %6, 3
  br i1 %cmp4, label %land.lhs.true5, label %cond.false10

land.lhs.true5:                                   ; preds = %land.lhs.true3
  %7 = load ptr, ptr %args.addr, align 8
  %ob_item = getelementptr inbounds %struct.PyTupleObject, ptr %7, i32 0, i32 1
  %arraydecay = getelementptr inbounds [1 x ptr], ptr %ob_item, i64 0, i64 0
  %cmp6 = icmp ne ptr %arraydecay, null
  br i1 %cmp6, label %cond.true7, label %cond.false10

cond.true7:                                       ; preds = %land.lhs.true5
  %8 = load ptr, ptr %args.addr, align 8
  %ob_item8 = getelementptr inbounds %struct.PyTupleObject, ptr %8, i32 0, i32 1
  %arraydecay9 = getelementptr inbounds [1 x ptr], ptr %ob_item8, i64 0, i64 0
  br label %cond.end15

cond.false10:                                     ; preds = %land.lhs.true5, %land.lhs.true3, %land.lhs.true, %cond.end
  %9 = load ptr, ptr %args.addr, align 8
  %ob_item11 = getelementptr inbounds %struct.PyTupleObject, ptr %9, i32 0, i32 1
  %arraydecay12 = getelementptr inbounds [1 x ptr], ptr %ob_item11, i64 0, i64 0
  %10 = load i64, ptr %nargs, align 8
  %11 = load ptr, ptr %kwargs.addr, align 8
  %arraydecay13 = getelementptr inbounds [3 x ptr], ptr %argsbuf, i64 0, i64 0
  %call14 = call ptr @_PyArg_UnpackKeywords(ptr noundef %arraydecay12, i64 noundef %10, ptr noundef %11, ptr noundef null, ptr noundef @bytes_new._parser, i32 noundef 0, i32 noundef 3, i32 noundef 0, ptr noundef %arraydecay13)
  br label %cond.end15

cond.end15:                                       ; preds = %cond.false10, %cond.true7
  %cond16 = phi ptr [ %arraydecay9, %cond.true7 ], [ %call14, %cond.false10 ]
  store ptr %cond16, ptr %fastargs, align 8
  %12 = load ptr, ptr %fastargs, align 8
  %tobool17 = icmp ne ptr %12, null
  br i1 %tobool17, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end15
  br label %exit

if.end:                                           ; preds = %cond.end15
  %13 = load i64, ptr %noptargs, align 8
  %tobool18 = icmp ne i64 %13, 0
  br i1 %tobool18, label %if.end20, label %if.then19

if.then19:                                        ; preds = %if.end
  br label %skip_optional_pos

if.end20:                                         ; preds = %if.end
  %14 = load ptr, ptr %fastargs, align 8
  %arrayidx = getelementptr ptr, ptr %14, i64 0
  %15 = load ptr, ptr %arrayidx, align 8
  %tobool21 = icmp ne ptr %15, null
  br i1 %tobool21, label %if.then22, label %if.end27

if.then22:                                        ; preds = %if.end20
  %16 = load ptr, ptr %fastargs, align 8
  %arrayidx23 = getelementptr ptr, ptr %16, i64 0
  %17 = load ptr, ptr %arrayidx23, align 8
  store ptr %17, ptr %x, align 8
  %18 = load i64, ptr %noptargs, align 8
  %dec = add i64 %18, -1
  store i64 %dec, ptr %noptargs, align 8
  %tobool24 = icmp ne i64 %dec, 0
  br i1 %tobool24, label %if.end26, label %if.then25

if.then25:                                        ; preds = %if.then22
  br label %skip_optional_pos

if.end26:                                         ; preds = %if.then22
  br label %if.end27

if.end27:                                         ; preds = %if.end26, %if.end20
  %19 = load ptr, ptr %fastargs, align 8
  %arrayidx28 = getelementptr ptr, ptr %19, i64 1
  %20 = load ptr, ptr %arrayidx28, align 8
  %tobool29 = icmp ne ptr %20, null
  br i1 %tobool29, label %if.then30, label %if.end51

if.then30:                                        ; preds = %if.end27
  %21 = load ptr, ptr %fastargs, align 8
  %arrayidx31 = getelementptr ptr, ptr %21, i64 1
  %22 = load ptr, ptr %arrayidx31, align 8
  %call32 = call ptr @Py_TYPE(ptr noundef %22)
  %call33 = call i32 @PyType_HasFeature(ptr noundef %call32, i64 noundef 268435456)
  %tobool34 = icmp ne i32 %call33, 0
  br i1 %tobool34, label %if.end37, label %if.then35

if.then35:                                        ; preds = %if.then30
  %23 = load ptr, ptr %fastargs, align 8
  %arrayidx36 = getelementptr ptr, ptr %23, i64 1
  %24 = load ptr, ptr %arrayidx36, align 8
  call void @_PyArg_BadArgument(ptr noundef @.str.34, ptr noundef @.str.107, ptr noundef @.str.108, ptr noundef %24)
  br label %exit

if.end37:                                         ; preds = %if.then30
  %25 = load ptr, ptr %fastargs, align 8
  %arrayidx38 = getelementptr ptr, ptr %25, i64 1
  %26 = load ptr, ptr %arrayidx38, align 8
  %call39 = call ptr @PyUnicode_AsUTF8AndSize(ptr noundef %26, ptr noundef %encoding_length)
  store ptr %call39, ptr %encoding, align 8
  %27 = load ptr, ptr %encoding, align 8
  %cmp40 = icmp eq ptr %27, null
  br i1 %cmp40, label %if.then41, label %if.end42

if.then41:                                        ; preds = %if.end37
  br label %exit

if.end42:                                         ; preds = %if.end37
  %28 = load ptr, ptr %encoding, align 8
  %call43 = call i64 @strlen(ptr noundef %28) #8
  %29 = load i64, ptr %encoding_length, align 8
  %cmp44 = icmp ne i64 %call43, %29
  br i1 %cmp44, label %if.then45, label %if.end46

if.then45:                                        ; preds = %if.end42
  %30 = load ptr, ptr @PyExc_ValueError, align 8
  call void @PyErr_SetString(ptr noundef %30, ptr noundef @.str.109)
  br label %exit

if.end46:                                         ; preds = %if.end42
  %31 = load i64, ptr %noptargs, align 8
  %dec47 = add i64 %31, -1
  store i64 %dec47, ptr %noptargs, align 8
  %tobool48 = icmp ne i64 %dec47, 0
  br i1 %tobool48, label %if.end50, label %if.then49

if.then49:                                        ; preds = %if.end46
  br label %skip_optional_pos

if.end50:                                         ; preds = %if.end46
  br label %if.end51

if.end51:                                         ; preds = %if.end50, %if.end27
  %32 = load ptr, ptr %fastargs, align 8
  %arrayidx52 = getelementptr ptr, ptr %32, i64 2
  %33 = load ptr, ptr %arrayidx52, align 8
  %call53 = call ptr @Py_TYPE(ptr noundef %33)
  %call54 = call i32 @PyType_HasFeature(ptr noundef %call53, i64 noundef 268435456)
  %tobool55 = icmp ne i32 %call54, 0
  br i1 %tobool55, label %if.end58, label %if.then56

if.then56:                                        ; preds = %if.end51
  %34 = load ptr, ptr %fastargs, align 8
  %arrayidx57 = getelementptr ptr, ptr %34, i64 2
  %35 = load ptr, ptr %arrayidx57, align 8
  call void @_PyArg_BadArgument(ptr noundef @.str.34, ptr noundef @.str.110, ptr noundef @.str.108, ptr noundef %35)
  br label %exit

if.end58:                                         ; preds = %if.end51
  %36 = load ptr, ptr %fastargs, align 8
  %arrayidx59 = getelementptr ptr, ptr %36, i64 2
  %37 = load ptr, ptr %arrayidx59, align 8
  %call60 = call ptr @PyUnicode_AsUTF8AndSize(ptr noundef %37, ptr noundef %errors_length)
  store ptr %call60, ptr %errors, align 8
  %38 = load ptr, ptr %errors, align 8
  %cmp61 = icmp eq ptr %38, null
  br i1 %cmp61, label %if.then62, label %if.end63

if.then62:                                        ; preds = %if.end58
  br label %exit

if.end63:                                         ; preds = %if.end58
  %39 = load ptr, ptr %errors, align 8
  %call64 = call i64 @strlen(ptr noundef %39) #8
  %40 = load i64, ptr %errors_length, align 8
  %cmp65 = icmp ne i64 %call64, %40
  br i1 %cmp65, label %if.then66, label %if.end67

if.then66:                                        ; preds = %if.end63
  %41 = load ptr, ptr @PyExc_ValueError, align 8
  call void @PyErr_SetString(ptr noundef %41, ptr noundef @.str.109)
  br label %exit

if.end67:                                         ; preds = %if.end63
  br label %skip_optional_pos

skip_optional_pos:                                ; preds = %if.end67, %if.then49, %if.then25, %if.then19
  %42 = load ptr, ptr %type.addr, align 8
  %43 = load ptr, ptr %x, align 8
  %44 = load ptr, ptr %encoding, align 8
  %45 = load ptr, ptr %errors, align 8
  %call68 = call ptr @bytes_new_impl(ptr noundef %42, ptr noundef %43, ptr noundef %44, ptr noundef %45)
  store ptr %call68, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional_pos, %if.then66, %if.then62, %if.then56, %if.then45, %if.then41, %if.then35, %if.then
  %46 = load ptr, ptr %return_value, align 8
  ret ptr %46
}

declare void @PyObject_Free(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @PyBytes_Concat(ptr noundef %pv, ptr noundef %w) #0 {
entry:
  %op.addr.i85 = alloca ptr, align 8
  %op.addr.i81 = alloca ptr, align 8
  %op.addr.i77 = alloca ptr, align 8
  %op.addr.i75 = alloca ptr, align 8
  %op.addr.i66 = alloca ptr, align 8
  %op.addr.i57 = alloca ptr, align 8
  %op.addr.i48 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %pv.addr = alloca ptr, align 8
  %w.addr = alloca ptr, align 8
  %_tmp_op_ptr = alloca ptr, align 8
  %_tmp_old_op = alloca ptr, align 8
  %oldsize = alloca i64, align 8
  %wb = alloca %struct.Py_buffer, align 8
  %_tmp_op_ptr18 = alloca ptr, align 8
  %_tmp_old_op19 = alloca ptr, align 8
  %_tmp_op_ptr38 = alloca ptr, align 8
  %_tmp_old_op39 = alloca ptr, align 8
  %v = alloca ptr, align 8
  %_tmp_dst_ptr = alloca ptr, align 8
  %_tmp_old_dst = alloca ptr, align 8
  store ptr %pv, ptr %pv.addr, align 8
  store ptr %w, ptr %w.addr, align 8
  %0 = load ptr, ptr %pv.addr, align 8
  %1 = load ptr, ptr %0, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end47

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %w.addr, align 8
  %cmp1 = icmp eq ptr %2, null
  br i1 %cmp1, label %if.then2, label %if.end6

if.then2:                                         ; preds = %if.end
  br label %do.body

do.body:                                          ; preds = %if.then2
  %3 = load ptr, ptr %pv.addr, align 8
  store ptr %3, ptr %_tmp_op_ptr, align 8
  %4 = load ptr, ptr %_tmp_op_ptr, align 8
  %5 = load ptr, ptr %4, align 8
  store ptr %5, ptr %_tmp_old_op, align 8
  %6 = load ptr, ptr %_tmp_old_op, align 8
  %cmp3 = icmp ne ptr %6, null
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %do.body
  %7 = load ptr, ptr %_tmp_op_ptr, align 8
  store ptr null, ptr %7, align 8
  %8 = load ptr, ptr %_tmp_old_op, align 8
  store ptr %8, ptr %op.addr.i66, align 8
  %9 = load ptr, ptr %op.addr.i66, align 8
  store ptr %9, ptr %op.addr.i75, align 8
  %10 = load ptr, ptr %op.addr.i75, align 8
  %11 = load i64, ptr %10, align 8
  %conv.i = trunc i64 %11 to i32
  %cmp.i76 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i76 to i32
  %tobool.i68 = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i68, label %if.then.i73, label %if.end.i69

if.then.i73:                                      ; preds = %if.then4
  br label %Py_DECREF.exit74

if.end.i69:                                       ; preds = %if.then4
  %12 = load ptr, ptr %op.addr.i66, align 8
  %13 = load i64, ptr %12, align 8
  %dec.i70 = add i64 %13, -1
  store i64 %dec.i70, ptr %12, align 8
  %cmp.i71 = icmp eq i64 %dec.i70, 0
  br i1 %cmp.i71, label %if.then1.i72, label %Py_DECREF.exit74

if.then1.i72:                                     ; preds = %if.end.i69
  %14 = load ptr, ptr %op.addr.i66, align 8
  call void @_Py_Dealloc(ptr noundef %14) #9
  br label %Py_DECREF.exit74

Py_DECREF.exit74:                                 ; preds = %if.then1.i72, %if.end.i69, %if.then.i73
  br label %if.end5

if.end5:                                          ; preds = %Py_DECREF.exit74, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end5
  br label %if.end47

if.end6:                                          ; preds = %if.end
  %15 = load ptr, ptr %pv.addr, align 8
  %16 = load ptr, ptr %15, align 8
  %call = call i64 @Py_REFCNT(ptr noundef %16)
  %cmp7 = icmp eq i64 %call, 1
  br i1 %cmp7, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.end6
  %17 = load ptr, ptr %pv.addr, align 8
  %18 = load ptr, ptr %17, align 8
  %call8 = call i32 @Py_IS_TYPE(ptr noundef %18, ptr noundef @PyBytes_Type)
  %tobool = icmp ne i32 %call8, 0
  br i1 %tobool, label %if.then9, label %if.else

if.then9:                                         ; preds = %land.lhs.true
  %19 = load ptr, ptr %w.addr, align 8
  %call10 = call i32 @PyObject_GetBuffer(ptr noundef %19, ptr noundef %wb, i32 noundef 0)
  %cmp11 = icmp ne i32 %call10, 0
  br i1 %cmp11, label %if.then12, label %if.end24

if.then12:                                        ; preds = %if.then9
  %20 = load ptr, ptr @PyExc_TypeError, align 8
  %21 = load ptr, ptr %w.addr, align 8
  %call13 = call ptr @Py_TYPE(ptr noundef %21)
  %tp_name = getelementptr inbounds %struct._typeobject, ptr %call13, i32 0, i32 1
  %22 = load ptr, ptr %tp_name, align 8
  %23 = load ptr, ptr %pv.addr, align 8
  %24 = load ptr, ptr %23, align 8
  %call14 = call ptr @Py_TYPE(ptr noundef %24)
  %tp_name15 = getelementptr inbounds %struct._typeobject, ptr %call14, i32 0, i32 1
  %25 = load ptr, ptr %tp_name15, align 8
  %call16 = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %20, ptr noundef @.str.35, ptr noundef %22, ptr noundef %25)
  br label %do.body17

do.body17:                                        ; preds = %if.then12
  %26 = load ptr, ptr %pv.addr, align 8
  store ptr %26, ptr %_tmp_op_ptr18, align 8
  %27 = load ptr, ptr %_tmp_op_ptr18, align 8
  %28 = load ptr, ptr %27, align 8
  store ptr %28, ptr %_tmp_old_op19, align 8
  %29 = load ptr, ptr %_tmp_old_op19, align 8
  %cmp20 = icmp ne ptr %29, null
  br i1 %cmp20, label %if.then21, label %if.end22

if.then21:                                        ; preds = %do.body17
  %30 = load ptr, ptr %_tmp_op_ptr18, align 8
  store ptr null, ptr %30, align 8
  %31 = load ptr, ptr %_tmp_old_op19, align 8
  store ptr %31, ptr %op.addr.i57, align 8
  %32 = load ptr, ptr %op.addr.i57, align 8
  store ptr %32, ptr %op.addr.i77, align 8
  %33 = load ptr, ptr %op.addr.i77, align 8
  %34 = load i64, ptr %33, align 8
  %conv.i78 = trunc i64 %34 to i32
  %cmp.i79 = icmp slt i32 %conv.i78, 0
  %conv1.i80 = zext i1 %cmp.i79 to i32
  %tobool.i59 = icmp ne i32 %conv1.i80, 0
  br i1 %tobool.i59, label %if.then.i64, label %if.end.i60

if.then.i64:                                      ; preds = %if.then21
  br label %Py_DECREF.exit65

if.end.i60:                                       ; preds = %if.then21
  %35 = load ptr, ptr %op.addr.i57, align 8
  %36 = load i64, ptr %35, align 8
  %dec.i61 = add i64 %36, -1
  store i64 %dec.i61, ptr %35, align 8
  %cmp.i62 = icmp eq i64 %dec.i61, 0
  br i1 %cmp.i62, label %if.then1.i63, label %Py_DECREF.exit65

if.then1.i63:                                     ; preds = %if.end.i60
  %37 = load ptr, ptr %op.addr.i57, align 8
  call void @_Py_Dealloc(ptr noundef %37) #9
  br label %Py_DECREF.exit65

Py_DECREF.exit65:                                 ; preds = %if.then1.i63, %if.end.i60, %if.then.i64
  br label %if.end22

if.end22:                                         ; preds = %Py_DECREF.exit65, %do.body17
  br label %do.end23

do.end23:                                         ; preds = %if.end22
  br label %if.end47

if.end24:                                         ; preds = %if.then9
  %38 = load ptr, ptr %pv.addr, align 8
  %39 = load ptr, ptr %38, align 8
  %call25 = call i64 @PyBytes_GET_SIZE(ptr noundef %39)
  store i64 %call25, ptr %oldsize, align 8
  %40 = load i64, ptr %oldsize, align 8
  %len = getelementptr inbounds %struct.Py_buffer, ptr %wb, i32 0, i32 2
  %41 = load i64, ptr %len, align 8
  %sub = sub i64 9223372036854775807, %41
  %cmp26 = icmp sgt i64 %40, %sub
  br i1 %cmp26, label %if.then27, label %if.end29

if.then27:                                        ; preds = %if.end24
  %call28 = call ptr @PyErr_NoMemory()
  br label %error

if.end29:                                         ; preds = %if.end24
  %42 = load ptr, ptr %pv.addr, align 8
  %43 = load i64, ptr %oldsize, align 8
  %len30 = getelementptr inbounds %struct.Py_buffer, ptr %wb, i32 0, i32 2
  %44 = load i64, ptr %len30, align 8
  %add = add i64 %43, %44
  %call31 = call i32 @_PyBytes_Resize(ptr noundef %42, i64 noundef %add)
  %cmp32 = icmp slt i32 %call31, 0
  br i1 %cmp32, label %if.then33, label %if.end34

if.then33:                                        ; preds = %if.end29
  br label %error

if.end34:                                         ; preds = %if.end29
  %45 = load ptr, ptr %pv.addr, align 8
  %46 = load ptr, ptr %45, align 8
  %call35 = call ptr @PyBytes_AS_STRING(ptr noundef %46)
  %47 = load i64, ptr %oldsize, align 8
  %add.ptr = getelementptr i8, ptr %call35, i64 %47
  %buf = getelementptr inbounds %struct.Py_buffer, ptr %wb, i32 0, i32 0
  %48 = load ptr, ptr %buf, align 8
  %len36 = getelementptr inbounds %struct.Py_buffer, ptr %wb, i32 0, i32 2
  %49 = load i64, ptr %len36, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %add.ptr, ptr align 1 %48, i64 %49, i1 false)
  call void @PyBuffer_Release(ptr noundef %wb)
  br label %if.end47

error:                                            ; preds = %if.then33, %if.then27
  call void @PyBuffer_Release(ptr noundef %wb)
  br label %do.body37

do.body37:                                        ; preds = %error
  %50 = load ptr, ptr %pv.addr, align 8
  store ptr %50, ptr %_tmp_op_ptr38, align 8
  %51 = load ptr, ptr %_tmp_op_ptr38, align 8
  %52 = load ptr, ptr %51, align 8
  store ptr %52, ptr %_tmp_old_op39, align 8
  %53 = load ptr, ptr %_tmp_old_op39, align 8
  %cmp40 = icmp ne ptr %53, null
  br i1 %cmp40, label %if.then41, label %if.end42

if.then41:                                        ; preds = %do.body37
  %54 = load ptr, ptr %_tmp_op_ptr38, align 8
  store ptr null, ptr %54, align 8
  %55 = load ptr, ptr %_tmp_old_op39, align 8
  store ptr %55, ptr %op.addr.i48, align 8
  %56 = load ptr, ptr %op.addr.i48, align 8
  store ptr %56, ptr %op.addr.i81, align 8
  %57 = load ptr, ptr %op.addr.i81, align 8
  %58 = load i64, ptr %57, align 8
  %conv.i82 = trunc i64 %58 to i32
  %cmp.i83 = icmp slt i32 %conv.i82, 0
  %conv1.i84 = zext i1 %cmp.i83 to i32
  %tobool.i50 = icmp ne i32 %conv1.i84, 0
  br i1 %tobool.i50, label %if.then.i55, label %if.end.i51

if.then.i55:                                      ; preds = %if.then41
  br label %Py_DECREF.exit56

if.end.i51:                                       ; preds = %if.then41
  %59 = load ptr, ptr %op.addr.i48, align 8
  %60 = load i64, ptr %59, align 8
  %dec.i52 = add i64 %60, -1
  store i64 %dec.i52, ptr %59, align 8
  %cmp.i53 = icmp eq i64 %dec.i52, 0
  br i1 %cmp.i53, label %if.then1.i54, label %Py_DECREF.exit56

if.then1.i54:                                     ; preds = %if.end.i51
  %61 = load ptr, ptr %op.addr.i48, align 8
  call void @_Py_Dealloc(ptr noundef %61) #9
  br label %Py_DECREF.exit56

Py_DECREF.exit56:                                 ; preds = %if.then1.i54, %if.end.i51, %if.then.i55
  br label %if.end42

if.end42:                                         ; preds = %Py_DECREF.exit56, %do.body37
  br label %do.end43

do.end43:                                         ; preds = %if.end42
  br label %if.end47

if.else:                                          ; preds = %land.lhs.true, %if.end6
  %62 = load ptr, ptr %pv.addr, align 8
  %63 = load ptr, ptr %62, align 8
  %64 = load ptr, ptr %w.addr, align 8
  %call44 = call ptr @bytes_concat(ptr noundef %63, ptr noundef %64)
  store ptr %call44, ptr %v, align 8
  br label %do.body45

do.body45:                                        ; preds = %if.else
  %65 = load ptr, ptr %pv.addr, align 8
  store ptr %65, ptr %_tmp_dst_ptr, align 8
  %66 = load ptr, ptr %_tmp_dst_ptr, align 8
  %67 = load ptr, ptr %66, align 8
  store ptr %67, ptr %_tmp_old_dst, align 8
  %68 = load ptr, ptr %v, align 8
  %69 = load ptr, ptr %_tmp_dst_ptr, align 8
  store ptr %68, ptr %69, align 8
  %70 = load ptr, ptr %_tmp_old_dst, align 8
  store ptr %70, ptr %op.addr.i, align 8
  %71 = load ptr, ptr %op.addr.i, align 8
  store ptr %71, ptr %op.addr.i85, align 8
  %72 = load ptr, ptr %op.addr.i85, align 8
  %73 = load i64, ptr %72, align 8
  %conv.i86 = trunc i64 %73 to i32
  %cmp.i87 = icmp slt i32 %conv.i86, 0
  %conv1.i88 = zext i1 %cmp.i87 to i32
  %tobool.i = icmp ne i32 %conv1.i88, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %do.body45
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %do.body45
  %74 = load ptr, ptr %op.addr.i, align 8
  %75 = load i64, ptr %74, align 8
  %dec.i = add i64 %75, -1
  store i64 %dec.i, ptr %74, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %76 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %76) #9
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  br label %do.end46

do.end46:                                         ; preds = %Py_DECREF.exit
  br label %if.end47

if.end47:                                         ; preds = %do.end46, %do.end43, %if.end34, %do.end23, %do.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @Py_REFCNT(ptr noundef %ob) #0 {
entry:
  %ob.addr = alloca ptr, align 8
  store ptr %ob, ptr %ob.addr, align 8
  %0 = load ptr, ptr %ob.addr, align 8
  %1 = getelementptr inbounds %struct._object, ptr %0, i32 0, i32 0
  %2 = load i64, ptr %1, align 8
  ret i64 %2
}

declare i32 @PyObject_GetBuffer(ptr noundef, ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @_PyBytes_Resize(ptr noundef %pv, i64 noundef %newsize) #0 {
entry:
  %op.addr.i52 = alloca ptr, align 8
  %op.addr.i48 = alloca ptr, align 8
  %op.addr.i46 = alloca ptr, align 8
  %op.addr.i37 = alloca ptr, align 8
  %op.addr.i28 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca i32, align 4
  %pv.addr = alloca ptr, align 8
  %newsize.addr = alloca i64, align 8
  %v = alloca ptr, align 8
  %sv = alloca ptr, align 8
  store ptr %pv, ptr %pv.addr, align 8
  store i64 %newsize, ptr %newsize.addr, align 8
  %0 = load ptr, ptr %pv.addr, align 8
  %1 = load ptr, ptr %0, align 8
  store ptr %1, ptr %v, align 8
  %2 = load ptr, ptr %v, align 8
  %call = call ptr @Py_TYPE(ptr noundef %2)
  %call1 = call i32 @PyType_HasFeature(ptr noundef %call, i64 noundef 134217728)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %3 = load i64, ptr %newsize.addr, align 8
  %cmp = icmp slt i64 %3, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %error

if.end:                                           ; preds = %lor.lhs.false
  %4 = load ptr, ptr %v, align 8
  %call2 = call i64 @Py_SIZE(ptr noundef %4)
  %5 = load i64, ptr %newsize.addr, align 8
  %cmp3 = icmp eq i64 %call2, %5
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  %6 = load ptr, ptr %v, align 8
  %call6 = call i64 @Py_SIZE(ptr noundef %6)
  %cmp7 = icmp eq i64 %call6, 0
  br i1 %cmp7, label %if.then8, label %if.end14

if.then8:                                         ; preds = %if.end5
  %7 = load i64, ptr %newsize.addr, align 8
  %cmp9 = icmp eq i64 %7, 0
  br i1 %cmp9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.then8
  store i32 0, ptr %retval, align 4
  br label %return

if.end11:                                         ; preds = %if.then8
  %8 = load i64, ptr %newsize.addr, align 8
  %call12 = call ptr @_PyBytes_FromSize(i64 noundef %8, i32 noundef 0)
  %9 = load ptr, ptr %pv.addr, align 8
  store ptr %call12, ptr %9, align 8
  %10 = load ptr, ptr %v, align 8
  store ptr %10, ptr %op.addr.i37, align 8
  %11 = load ptr, ptr %op.addr.i37, align 8
  store ptr %11, ptr %op.addr.i46, align 8
  %12 = load ptr, ptr %op.addr.i46, align 8
  %13 = load i64, ptr %12, align 8
  %conv.i = trunc i64 %13 to i32
  %cmp.i47 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i47 to i32
  %tobool.i39 = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i39, label %if.then.i44, label %if.end.i40

if.then.i44:                                      ; preds = %if.end11
  br label %Py_DECREF.exit45

if.end.i40:                                       ; preds = %if.end11
  %14 = load ptr, ptr %op.addr.i37, align 8
  %15 = load i64, ptr %14, align 8
  %dec.i41 = add i64 %15, -1
  store i64 %dec.i41, ptr %14, align 8
  %cmp.i42 = icmp eq i64 %dec.i41, 0
  br i1 %cmp.i42, label %if.then1.i43, label %Py_DECREF.exit45

if.then1.i43:                                     ; preds = %if.end.i40
  %16 = load ptr, ptr %op.addr.i37, align 8
  call void @_Py_Dealloc(ptr noundef %16) #9
  br label %Py_DECREF.exit45

Py_DECREF.exit45:                                 ; preds = %if.then1.i43, %if.end.i40, %if.then.i44
  %17 = load ptr, ptr %pv.addr, align 8
  %18 = load ptr, ptr %17, align 8
  %cmp13 = icmp eq ptr %18, null
  %cond = select i1 %cmp13, i32 -1, i32 0
  store i32 %cond, ptr %retval, align 4
  br label %return

if.end14:                                         ; preds = %if.end5
  %19 = load ptr, ptr %v, align 8
  %call15 = call i64 @Py_REFCNT(ptr noundef %19)
  %cmp16 = icmp ne i64 %call15, 1
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end14
  br label %error

if.end18:                                         ; preds = %if.end14
  %20 = load i64, ptr %newsize.addr, align 8
  %cmp19 = icmp eq i64 %20, 0
  br i1 %cmp19, label %if.then20, label %if.end22

if.then20:                                        ; preds = %if.end18
  %call21 = call ptr @bytes_get_empty()
  %21 = load ptr, ptr %pv.addr, align 8
  store ptr %call21, ptr %21, align 8
  %22 = load ptr, ptr %v, align 8
  store ptr %22, ptr %op.addr.i28, align 8
  %23 = load ptr, ptr %op.addr.i28, align 8
  store ptr %23, ptr %op.addr.i48, align 8
  %24 = load ptr, ptr %op.addr.i48, align 8
  %25 = load i64, ptr %24, align 8
  %conv.i49 = trunc i64 %25 to i32
  %cmp.i50 = icmp slt i32 %conv.i49, 0
  %conv1.i51 = zext i1 %cmp.i50 to i32
  %tobool.i30 = icmp ne i32 %conv1.i51, 0
  br i1 %tobool.i30, label %if.then.i35, label %if.end.i31

if.then.i35:                                      ; preds = %if.then20
  br label %Py_DECREF.exit36

if.end.i31:                                       ; preds = %if.then20
  %26 = load ptr, ptr %op.addr.i28, align 8
  %27 = load i64, ptr %26, align 8
  %dec.i32 = add i64 %27, -1
  store i64 %dec.i32, ptr %26, align 8
  %cmp.i33 = icmp eq i64 %dec.i32, 0
  br i1 %cmp.i33, label %if.then1.i34, label %Py_DECREF.exit36

if.then1.i34:                                     ; preds = %if.end.i31
  %28 = load ptr, ptr %op.addr.i28, align 8
  call void @_Py_Dealloc(ptr noundef %28) #9
  br label %Py_DECREF.exit36

Py_DECREF.exit36:                                 ; preds = %if.then1.i34, %if.end.i31, %if.then.i35
  store i32 0, ptr %retval, align 4
  br label %return

if.end22:                                         ; preds = %if.end18
  %29 = load ptr, ptr %v, align 8
  %30 = load i64, ptr %newsize.addr, align 8
  %add = add i64 33, %30
  %call23 = call ptr @PyObject_Realloc(ptr noundef %29, i64 noundef %add)
  %31 = load ptr, ptr %pv.addr, align 8
  store ptr %call23, ptr %31, align 8
  %32 = load ptr, ptr %pv.addr, align 8
  %33 = load ptr, ptr %32, align 8
  %cmp24 = icmp eq ptr %33, null
  br i1 %cmp24, label %if.then25, label %if.end27

if.then25:                                        ; preds = %if.end22
  %34 = load ptr, ptr %v, align 8
  call void @PyObject_Free(ptr noundef %34)
  %call26 = call ptr @PyErr_NoMemory()
  store i32 -1, ptr %retval, align 4
  br label %return

if.end27:                                         ; preds = %if.end22
  %35 = load ptr, ptr %pv.addr, align 8
  %36 = load ptr, ptr %35, align 8
  call void @_Py_NewReferenceNoTotal(ptr noundef %36)
  %37 = load ptr, ptr %pv.addr, align 8
  %38 = load ptr, ptr %37, align 8
  store ptr %38, ptr %sv, align 8
  %39 = load ptr, ptr %sv, align 8
  %40 = load i64, ptr %newsize.addr, align 8
  call void @Py_SET_SIZE(ptr noundef %39, i64 noundef %40)
  %41 = load ptr, ptr %sv, align 8
  %ob_sval = getelementptr inbounds %struct.PyBytesObject, ptr %41, i32 0, i32 2
  %42 = load i64, ptr %newsize.addr, align 8
  %arrayidx = getelementptr [1 x i8], ptr %ob_sval, i64 0, i64 %42
  store i8 0, ptr %arrayidx, align 1
  %43 = load ptr, ptr %sv, align 8
  %ob_shash = getelementptr inbounds %struct.PyBytesObject, ptr %43, i32 0, i32 1
  store i64 -1, ptr %ob_shash, align 8
  store i32 0, ptr %retval, align 4
  br label %return

error:                                            ; preds = %if.then17, %if.then
  %44 = load ptr, ptr %pv.addr, align 8
  store ptr null, ptr %44, align 8
  %45 = load ptr, ptr %v, align 8
  store ptr %45, ptr %op.addr.i, align 8
  %46 = load ptr, ptr %op.addr.i, align 8
  store ptr %46, ptr %op.addr.i52, align 8
  %47 = load ptr, ptr %op.addr.i52, align 8
  %48 = load i64, ptr %47, align 8
  %conv.i53 = trunc i64 %48 to i32
  %cmp.i54 = icmp slt i32 %conv.i53, 0
  %conv1.i55 = zext i1 %cmp.i54 to i32
  %tobool.i = icmp ne i32 %conv1.i55, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %error
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %error
  %49 = load ptr, ptr %op.addr.i, align 8
  %50 = load i64, ptr %49, align 8
  %dec.i = add i64 %50, -1
  store i64 %dec.i, ptr %49, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %51 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %51) #9
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  call void @_PyErr_BadInternalCall(ptr noundef @.str.12, i32 noundef 3095)
  store i32 -1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %Py_DECREF.exit, %if.end27, %if.then25, %Py_DECREF.exit36, %Py_DECREF.exit45, %if.then10, %if.then4
  %52 = load i32, ptr %retval, align 4
  ret i32 %52
}

declare void @PyBuffer_Release(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @bytes_concat(ptr noundef %a, ptr noundef %b) #0 {
entry:
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  %va = alloca %struct.Py_buffer, align 8
  %vb = alloca %struct.Py_buffer, align 8
  %result = alloca ptr, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  store ptr null, ptr %result, align 8
  %len = getelementptr inbounds %struct.Py_buffer, ptr %va, i32 0, i32 2
  store i64 -1, ptr %len, align 8
  %len1 = getelementptr inbounds %struct.Py_buffer, ptr %vb, i32 0, i32 2
  store i64 -1, ptr %len1, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %call = call i32 @PyObject_GetBuffer(ptr noundef %0, ptr noundef %va, i32 noundef 0)
  %cmp = icmp ne i32 %call, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %b.addr, align 8
  %call2 = call i32 @PyObject_GetBuffer(ptr noundef %1, ptr noundef %vb, i32 noundef 0)
  %cmp3 = icmp ne i32 %call2, 0
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %2 = load ptr, ptr @PyExc_TypeError, align 8
  %3 = load ptr, ptr %b.addr, align 8
  %call4 = call ptr @Py_TYPE(ptr noundef %3)
  %tp_name = getelementptr inbounds %struct._typeobject, ptr %call4, i32 0, i32 1
  %4 = load ptr, ptr %tp_name, align 8
  %5 = load ptr, ptr %a.addr, align 8
  %call5 = call ptr @Py_TYPE(ptr noundef %5)
  %tp_name6 = getelementptr inbounds %struct._typeobject, ptr %call5, i32 0, i32 1
  %6 = load ptr, ptr %tp_name6, align 8
  %call7 = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %2, ptr noundef @.str.35, ptr noundef %4, ptr noundef %6)
  br label %done

if.end:                                           ; preds = %lor.lhs.false
  %len8 = getelementptr inbounds %struct.Py_buffer, ptr %va, i32 0, i32 2
  %7 = load i64, ptr %len8, align 8
  %cmp9 = icmp eq i64 %7, 0
  br i1 %cmp9, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %if.end
  %8 = load ptr, ptr %b.addr, align 8
  %call10 = call i32 @Py_IS_TYPE(ptr noundef %8, ptr noundef @PyBytes_Type)
  %tobool = icmp ne i32 %call10, 0
  br i1 %tobool, label %if.then11, label %if.end13

if.then11:                                        ; preds = %land.lhs.true
  %9 = load ptr, ptr %b.addr, align 8
  %call12 = call ptr @_Py_NewRef(ptr noundef %9)
  store ptr %call12, ptr %result, align 8
  br label %done

if.end13:                                         ; preds = %land.lhs.true, %if.end
  %len14 = getelementptr inbounds %struct.Py_buffer, ptr %vb, i32 0, i32 2
  %10 = load i64, ptr %len14, align 8
  %cmp15 = icmp eq i64 %10, 0
  br i1 %cmp15, label %land.lhs.true16, label %if.end21

land.lhs.true16:                                  ; preds = %if.end13
  %11 = load ptr, ptr %a.addr, align 8
  %call17 = call i32 @Py_IS_TYPE(ptr noundef %11, ptr noundef @PyBytes_Type)
  %tobool18 = icmp ne i32 %call17, 0
  br i1 %tobool18, label %if.then19, label %if.end21

if.then19:                                        ; preds = %land.lhs.true16
  %12 = load ptr, ptr %a.addr, align 8
  %call20 = call ptr @_Py_NewRef(ptr noundef %12)
  store ptr %call20, ptr %result, align 8
  br label %done

if.end21:                                         ; preds = %land.lhs.true16, %if.end13
  %len22 = getelementptr inbounds %struct.Py_buffer, ptr %va, i32 0, i32 2
  %13 = load i64, ptr %len22, align 8
  %len23 = getelementptr inbounds %struct.Py_buffer, ptr %vb, i32 0, i32 2
  %14 = load i64, ptr %len23, align 8
  %sub = sub i64 9223372036854775807, %14
  %cmp24 = icmp sgt i64 %13, %sub
  br i1 %cmp24, label %if.then25, label %if.end27

if.then25:                                        ; preds = %if.end21
  %call26 = call ptr @PyErr_NoMemory()
  br label %done

if.end27:                                         ; preds = %if.end21
  %len28 = getelementptr inbounds %struct.Py_buffer, ptr %va, i32 0, i32 2
  %15 = load i64, ptr %len28, align 8
  %len29 = getelementptr inbounds %struct.Py_buffer, ptr %vb, i32 0, i32 2
  %16 = load i64, ptr %len29, align 8
  %add = add i64 %15, %16
  %call30 = call ptr @PyBytes_FromStringAndSize(ptr noundef null, i64 noundef %add)
  store ptr %call30, ptr %result, align 8
  %17 = load ptr, ptr %result, align 8
  %cmp31 = icmp ne ptr %17, null
  br i1 %cmp31, label %if.then32, label %if.end39

if.then32:                                        ; preds = %if.end27
  %18 = load ptr, ptr %result, align 8
  %call33 = call ptr @PyBytes_AS_STRING(ptr noundef %18)
  %buf = getelementptr inbounds %struct.Py_buffer, ptr %va, i32 0, i32 0
  %19 = load ptr, ptr %buf, align 8
  %len34 = getelementptr inbounds %struct.Py_buffer, ptr %va, i32 0, i32 2
  %20 = load i64, ptr %len34, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %call33, ptr align 1 %19, i64 %20, i1 false)
  %21 = load ptr, ptr %result, align 8
  %call35 = call ptr @PyBytes_AS_STRING(ptr noundef %21)
  %len36 = getelementptr inbounds %struct.Py_buffer, ptr %va, i32 0, i32 2
  %22 = load i64, ptr %len36, align 8
  %add.ptr = getelementptr i8, ptr %call35, i64 %22
  %buf37 = getelementptr inbounds %struct.Py_buffer, ptr %vb, i32 0, i32 0
  %23 = load ptr, ptr %buf37, align 8
  %len38 = getelementptr inbounds %struct.Py_buffer, ptr %vb, i32 0, i32 2
  %24 = load i64, ptr %len38, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %add.ptr, ptr align 1 %23, i64 %24, i1 false)
  br label %if.end39

if.end39:                                         ; preds = %if.then32, %if.end27
  br label %done

done:                                             ; preds = %if.end39, %if.then25, %if.then19, %if.then11, %if.then
  %len40 = getelementptr inbounds %struct.Py_buffer, ptr %va, i32 0, i32 2
  %25 = load i64, ptr %len40, align 8
  %cmp41 = icmp ne i64 %25, -1
  br i1 %cmp41, label %if.then42, label %if.end43

if.then42:                                        ; preds = %done
  call void @PyBuffer_Release(ptr noundef %va)
  br label %if.end43

if.end43:                                         ; preds = %if.then42, %done
  %len44 = getelementptr inbounds %struct.Py_buffer, ptr %vb, i32 0, i32 2
  %26 = load i64, ptr %len44, align 8
  %cmp45 = icmp ne i64 %26, -1
  br i1 %cmp45, label %if.then46, label %if.end47

if.then46:                                        ; preds = %if.end43
  call void @PyBuffer_Release(ptr noundef %vb)
  br label %if.end47

if.end47:                                         ; preds = %if.then46, %if.end43
  %27 = load ptr, ptr %result, align 8
  ret ptr %27
}

; Function Attrs: nounwind uwtable
define dso_local void @PyBytes_ConcatAndDel(ptr noundef %pv, ptr noundef %w) #0 {
entry:
  %pv.addr = alloca ptr, align 8
  %w.addr = alloca ptr, align 8
  store ptr %pv, ptr %pv.addr, align 8
  store ptr %w, ptr %w.addr, align 8
  %0 = load ptr, ptr %pv.addr, align 8
  %1 = load ptr, ptr %w.addr, align 8
  call void @PyBytes_Concat(ptr noundef %0, ptr noundef %1)
  %2 = load ptr, ptr %w.addr, align 8
  call void @Py_XDECREF(ptr noundef %2)
  ret void
}

declare ptr @PyObject_Realloc(ptr noundef, i64 noundef) #1

declare void @_Py_NewReferenceNoTotal(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal void @Py_SET_SIZE(ptr noundef %ob, i64 noundef %size) #0 {
entry:
  %ob.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  store ptr %ob, ptr %ob.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load i64, ptr %size.addr, align 8
  %1 = load ptr, ptr %ob.addr, align 8
  %ob_size = getelementptr inbounds %struct.PyVarObject, ptr %1, i32 0, i32 1
  store i64 %0, ptr %ob_size, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @striter_dealloc(ptr noundef %it) #0 {
entry:
  %it.addr = alloca ptr, align 8
  store ptr %it, ptr %it.addr, align 8
  %0 = load ptr, ptr %it.addr, align 8
  call void @_PyObject_GC_UNTRACK(ptr noundef %0)
  %1 = load ptr, ptr %it.addr, align 8
  %it_seq = getelementptr inbounds %struct.striterobject, ptr %1, i32 0, i32 2
  %2 = load ptr, ptr %it_seq, align 8
  call void @Py_XDECREF(ptr noundef %2)
  %3 = load ptr, ptr %it.addr, align 8
  call void @PyObject_GC_Del(ptr noundef %3)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @striter_traverse(ptr noundef %it, ptr noundef %visit, ptr noundef %arg) #0 {
entry:
  %retval = alloca i32, align 4
  %it.addr = alloca ptr, align 8
  %visit.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %vret = alloca i32, align 4
  store ptr %it, ptr %it.addr, align 8
  store ptr %visit, ptr %visit.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load ptr, ptr %it.addr, align 8
  %it_seq = getelementptr inbounds %struct.striterobject, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %it_seq, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.then, label %if.end4

if.then:                                          ; preds = %do.body
  %2 = load ptr, ptr %visit.addr, align 8
  %3 = load ptr, ptr %it.addr, align 8
  %it_seq1 = getelementptr inbounds %struct.striterobject, ptr %3, i32 0, i32 2
  %4 = load ptr, ptr %it_seq1, align 8
  %5 = load ptr, ptr %arg.addr, align 8
  %call = call i32 %2(ptr noundef %4, ptr noundef %5)
  store i32 %call, ptr %vret, align 4
  %6 = load i32, ptr %vret, align 4
  %tobool2 = icmp ne i32 %6, 0
  br i1 %tobool2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %7 = load i32, ptr %vret, align 4
  store i32 %7, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  br label %if.end4

if.end4:                                          ; preds = %if.end, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end4
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %do.end, %if.then3
  %8 = load i32, ptr %retval, align 4
  ret i32 %8
}

declare ptr @PyObject_SelfIter(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @striter_next(ptr noundef %it) #0 {
entry:
  %op.addr.i7 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %it.addr = alloca ptr, align 8
  %seq = alloca ptr, align 8
  store ptr %it, ptr %it.addr, align 8
  %0 = load ptr, ptr %it.addr, align 8
  %it_seq = getelementptr inbounds %struct.striterobject, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %it_seq, align 8
  store ptr %1, ptr %seq, align 8
  %2 = load ptr, ptr %seq, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %it.addr, align 8
  %it_index = getelementptr inbounds %struct.striterobject, ptr %3, i32 0, i32 1
  %4 = load i64, ptr %it_index, align 8
  %5 = load ptr, ptr %seq, align 8
  %call = call i64 @PyBytes_GET_SIZE(ptr noundef %5)
  %cmp1 = icmp slt i64 %4, %call
  br i1 %cmp1, label %if.then2, label %if.end5

if.then2:                                         ; preds = %if.end
  %6 = load ptr, ptr %seq, align 8
  %ob_sval = getelementptr inbounds %struct.PyBytesObject, ptr %6, i32 0, i32 2
  %7 = load ptr, ptr %it.addr, align 8
  %it_index3 = getelementptr inbounds %struct.striterobject, ptr %7, i32 0, i32 1
  %8 = load i64, ptr %it_index3, align 8
  %inc = add i64 %8, 1
  store i64 %inc, ptr %it_index3, align 8
  %arrayidx = getelementptr [1 x i8], ptr %ob_sval, i64 0, i64 %8
  %9 = load i8, ptr %arrayidx, align 1
  %call4 = call ptr @_PyLong_FromUnsignedChar(i8 noundef zeroext %9)
  store ptr %call4, ptr %retval, align 8
  br label %return

if.end5:                                          ; preds = %if.end
  %10 = load ptr, ptr %it.addr, align 8
  %it_seq6 = getelementptr inbounds %struct.striterobject, ptr %10, i32 0, i32 2
  store ptr null, ptr %it_seq6, align 8
  %11 = load ptr, ptr %seq, align 8
  store ptr %11, ptr %op.addr.i, align 8
  %12 = load ptr, ptr %op.addr.i, align 8
  store ptr %12, ptr %op.addr.i7, align 8
  %13 = load ptr, ptr %op.addr.i7, align 8
  %14 = load i64, ptr %13, align 8
  %conv.i = trunc i64 %14 to i32
  %cmp.i8 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i8 to i32
  %tobool.i = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.end5
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.end5
  %15 = load ptr, ptr %op.addr.i, align 8
  %16 = load i64, ptr %15, align 8
  %dec.i = add i64 %16, -1
  store i64 %dec.i, ptr %15, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %17 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %17) #9
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %Py_DECREF.exit, %if.then2, %if.then
  %18 = load ptr, ptr %retval, align 8
  ret ptr %18
}

; Function Attrs: nounwind uwtable
define dso_local ptr @_PyBytesWriter_Resize(ptr noundef %writer, ptr noundef %str, i64 noundef %size) #0 {
entry:
  %retval = alloca ptr, align 8
  %writer.addr = alloca ptr, align 8
  %str.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %allocated = alloca i64, align 8
  %pos = alloca i64, align 8
  %dest = alloca ptr, align 8
  store ptr %writer, ptr %writer.addr, align 8
  store ptr %str, ptr %str.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load i64, ptr %size.addr, align 8
  store i64 %0, ptr %allocated, align 8
  %1 = load ptr, ptr %writer.addr, align 8
  %overallocate = getelementptr inbounds %struct._PyBytesWriter, ptr %1, i32 0, i32 4
  %2 = load i32, ptr %overallocate, align 4
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %3 = load i64, ptr %allocated, align 8
  %4 = load i64, ptr %allocated, align 8
  %div = sdiv i64 %4, 4
  %sub = sub i64 9223372036854775807, %div
  %cmp = icmp sle i64 %3, %sub
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %5 = load i64, ptr %allocated, align 8
  %div1 = sdiv i64 %5, 4
  %6 = load i64, ptr %allocated, align 8
  %add = add i64 %6, %div1
  store i64 %add, ptr %allocated, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %7 = load ptr, ptr %writer.addr, align 8
  %8 = load ptr, ptr %str.addr, align 8
  %call = call i64 @_PyBytesWriter_GetSize(ptr noundef %7, ptr noundef %8)
  store i64 %call, ptr %pos, align 8
  %9 = load ptr, ptr %writer.addr, align 8
  %use_small_buffer = getelementptr inbounds %struct._PyBytesWriter, ptr %9, i32 0, i32 5
  %10 = load i32, ptr %use_small_buffer, align 8
  %tobool2 = icmp ne i32 %10, 0
  br i1 %tobool2, label %if.else16, label %if.then3

if.then3:                                         ; preds = %if.end
  %11 = load ptr, ptr %writer.addr, align 8
  %use_bytearray = getelementptr inbounds %struct._PyBytesWriter, ptr %11, i32 0, i32 3
  %12 = load i32, ptr %use_bytearray, align 8
  %tobool4 = icmp ne i32 %12, 0
  br i1 %tobool4, label %if.then5, label %if.else

if.then5:                                         ; preds = %if.then3
  %13 = load ptr, ptr %writer.addr, align 8
  %buffer = getelementptr inbounds %struct._PyBytesWriter, ptr %13, i32 0, i32 0
  %14 = load ptr, ptr %buffer, align 8
  %15 = load i64, ptr %allocated, align 8
  %call6 = call i32 @PyByteArray_Resize(ptr noundef %14, i64 noundef %15)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.then5
  br label %error

if.end9:                                          ; preds = %if.then5
  br label %if.end15

if.else:                                          ; preds = %if.then3
  %16 = load ptr, ptr %writer.addr, align 8
  %buffer10 = getelementptr inbounds %struct._PyBytesWriter, ptr %16, i32 0, i32 0
  %17 = load i64, ptr %allocated, align 8
  %call11 = call i32 @_PyBytes_Resize(ptr noundef %buffer10, i64 noundef %17)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.else
  br label %error

if.end14:                                         ; preds = %if.else
  br label %if.end15

if.end15:                                         ; preds = %if.end14, %if.end9
  br label %if.end43

if.else16:                                        ; preds = %if.end
  %18 = load ptr, ptr %writer.addr, align 8
  %use_bytearray17 = getelementptr inbounds %struct._PyBytesWriter, ptr %18, i32 0, i32 3
  %19 = load i32, ptr %use_bytearray17, align 8
  %tobool18 = icmp ne i32 %19, 0
  br i1 %tobool18, label %if.then19, label %if.else22

if.then19:                                        ; preds = %if.else16
  %20 = load i64, ptr %allocated, align 8
  %call20 = call ptr @PyByteArray_FromStringAndSize(ptr noundef null, i64 noundef %20)
  %21 = load ptr, ptr %writer.addr, align 8
  %buffer21 = getelementptr inbounds %struct._PyBytesWriter, ptr %21, i32 0, i32 0
  store ptr %call20, ptr %buffer21, align 8
  br label %if.end25

if.else22:                                        ; preds = %if.else16
  %22 = load i64, ptr %allocated, align 8
  %call23 = call ptr @PyBytes_FromStringAndSize(ptr noundef null, i64 noundef %22)
  %23 = load ptr, ptr %writer.addr, align 8
  %buffer24 = getelementptr inbounds %struct._PyBytesWriter, ptr %23, i32 0, i32 0
  store ptr %call23, ptr %buffer24, align 8
  br label %if.end25

if.end25:                                         ; preds = %if.else22, %if.then19
  %24 = load ptr, ptr %writer.addr, align 8
  %buffer26 = getelementptr inbounds %struct._PyBytesWriter, ptr %24, i32 0, i32 0
  %25 = load ptr, ptr %buffer26, align 8
  %cmp27 = icmp eq ptr %25, null
  br i1 %cmp27, label %if.then28, label %if.end29

if.then28:                                        ; preds = %if.end25
  br label %error

if.end29:                                         ; preds = %if.end25
  %26 = load i64, ptr %pos, align 8
  %cmp30 = icmp ne i64 %26, 0
  br i1 %cmp30, label %if.then31, label %if.end41

if.then31:                                        ; preds = %if.end29
  %27 = load ptr, ptr %writer.addr, align 8
  %use_bytearray32 = getelementptr inbounds %struct._PyBytesWriter, ptr %27, i32 0, i32 3
  %28 = load i32, ptr %use_bytearray32, align 8
  %tobool33 = icmp ne i32 %28, 0
  br i1 %tobool33, label %if.then34, label %if.else37

if.then34:                                        ; preds = %if.then31
  %29 = load ptr, ptr %writer.addr, align 8
  %buffer35 = getelementptr inbounds %struct._PyBytesWriter, ptr %29, i32 0, i32 0
  %30 = load ptr, ptr %buffer35, align 8
  %call36 = call ptr @PyByteArray_AS_STRING(ptr noundef %30)
  store ptr %call36, ptr %dest, align 8
  br label %if.end40

if.else37:                                        ; preds = %if.then31
  %31 = load ptr, ptr %writer.addr, align 8
  %buffer38 = getelementptr inbounds %struct._PyBytesWriter, ptr %31, i32 0, i32 0
  %32 = load ptr, ptr %buffer38, align 8
  %call39 = call ptr @PyBytes_AS_STRING(ptr noundef %32)
  store ptr %call39, ptr %dest, align 8
  br label %if.end40

if.end40:                                         ; preds = %if.else37, %if.then34
  %33 = load ptr, ptr %dest, align 8
  %34 = load ptr, ptr %writer.addr, align 8
  %small_buffer = getelementptr inbounds %struct._PyBytesWriter, ptr %34, i32 0, i32 6
  %arraydecay = getelementptr inbounds [512 x i8], ptr %small_buffer, i64 0, i64 0
  %35 = load i64, ptr %pos, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %33, ptr align 4 %arraydecay, i64 %35, i1 false)
  br label %if.end41

if.end41:                                         ; preds = %if.end40, %if.end29
  %36 = load ptr, ptr %writer.addr, align 8
  %use_small_buffer42 = getelementptr inbounds %struct._PyBytesWriter, ptr %36, i32 0, i32 5
  store i32 0, ptr %use_small_buffer42, align 8
  br label %if.end43

if.end43:                                         ; preds = %if.end41, %if.end15
  %37 = load i64, ptr %allocated, align 8
  %38 = load ptr, ptr %writer.addr, align 8
  %allocated44 = getelementptr inbounds %struct._PyBytesWriter, ptr %38, i32 0, i32 1
  store i64 %37, ptr %allocated44, align 8
  %39 = load ptr, ptr %writer.addr, align 8
  %call45 = call ptr @_PyBytesWriter_AsString(ptr noundef %39)
  %40 = load i64, ptr %pos, align 8
  %add.ptr = getelementptr i8, ptr %call45, i64 %40
  store ptr %add.ptr, ptr %str.addr, align 8
  %41 = load ptr, ptr %str.addr, align 8
  store ptr %41, ptr %retval, align 8
  br label %return

error:                                            ; preds = %if.then28, %if.then13, %if.then8
  %42 = load ptr, ptr %writer.addr, align 8
  call void @_PyBytesWriter_Dealloc(ptr noundef %42)
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %error, %if.end43
  %43 = load ptr, ptr %retval, align 8
  ret ptr %43
}

; Function Attrs: nounwind uwtable
define internal i64 @_PyBytesWriter_GetSize(ptr noundef %writer, ptr noundef %str) #0 {
entry:
  %writer.addr = alloca ptr, align 8
  %str.addr = alloca ptr, align 8
  %start = alloca ptr, align 8
  store ptr %writer, ptr %writer.addr, align 8
  store ptr %str, ptr %str.addr, align 8
  %0 = load ptr, ptr %writer.addr, align 8
  %call = call ptr @_PyBytesWriter_AsString(ptr noundef %0)
  store ptr %call, ptr %start, align 8
  %1 = load ptr, ptr %str.addr, align 8
  %2 = load ptr, ptr %start, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  ret i64 %sub.ptr.sub
}

declare i32 @PyByteArray_Resize(ptr noundef, i64 noundef) #1

declare ptr @PyByteArray_FromStringAndSize(ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @PyByteArray_AS_STRING(ptr noundef %op) #0 {
entry:
  %retval = alloca ptr, align 8
  %op.addr = alloca ptr, align 8
  %self = alloca ptr, align 8
  store ptr %op, ptr %op.addr, align 8
  %0 = load ptr, ptr %op.addr, align 8
  store ptr %0, ptr %self, align 8
  %1 = load ptr, ptr %self, align 8
  %call = call i64 @Py_SIZE(ptr noundef %1)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %self, align 8
  %ob_start = getelementptr inbounds %struct.PyByteArrayObject, ptr %2, i32 0, i32 3
  %3 = load ptr, ptr %ob_start, align 8
  store ptr %3, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store ptr @_PyByteArray_empty_string, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load ptr, ptr %retval, align 8
  ret ptr %4
}

; Function Attrs: nounwind uwtable
define internal ptr @_PyBytesWriter_AsString(ptr noundef %writer) #0 {
entry:
  %retval = alloca ptr, align 8
  %writer.addr = alloca ptr, align 8
  store ptr %writer, ptr %writer.addr, align 8
  %0 = load ptr, ptr %writer.addr, align 8
  %use_small_buffer = getelementptr inbounds %struct._PyBytesWriter, ptr %0, i32 0, i32 5
  %1 = load i32, ptr %use_small_buffer, align 8
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %writer.addr, align 8
  %small_buffer = getelementptr inbounds %struct._PyBytesWriter, ptr %2, i32 0, i32 6
  %arraydecay = getelementptr inbounds [512 x i8], ptr %small_buffer, i64 0, i64 0
  store ptr %arraydecay, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %3 = load ptr, ptr %writer.addr, align 8
  %use_bytearray = getelementptr inbounds %struct._PyBytesWriter, ptr %3, i32 0, i32 3
  %4 = load i32, ptr %use_bytearray, align 8
  %tobool1 = icmp ne i32 %4, 0
  br i1 %tobool1, label %if.then2, label %if.else3

if.then2:                                         ; preds = %if.else
  %5 = load ptr, ptr %writer.addr, align 8
  %buffer = getelementptr inbounds %struct._PyBytesWriter, ptr %5, i32 0, i32 0
  %6 = load ptr, ptr %buffer, align 8
  %call = call ptr @PyByteArray_AS_STRING(ptr noundef %6)
  store ptr %call, ptr %retval, align 8
  br label %return

if.else3:                                         ; preds = %if.else
  %7 = load ptr, ptr %writer.addr, align 8
  %buffer4 = getelementptr inbounds %struct._PyBytesWriter, ptr %7, i32 0, i32 0
  %8 = load ptr, ptr %buffer4, align 8
  %call5 = call ptr @PyBytes_AS_STRING(ptr noundef %8)
  store ptr %call5, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else3, %if.then2, %if.then
  %9 = load ptr, ptr %retval, align 8
  ret ptr %9
}

; Function Attrs: nounwind uwtable
define dso_local void @_PyBytes_Repeat(ptr noundef %dest, i64 noundef %len_dest, ptr noundef %src, i64 noundef %len_src) #0 {
entry:
  %dest.addr = alloca ptr, align 8
  %len_dest.addr = alloca i64, align 8
  %src.addr = alloca ptr, align 8
  %len_src.addr = alloca i64, align 8
  %copied = alloca i64, align 8
  %bytes_to_copy = alloca i64, align 8
  store ptr %dest, ptr %dest.addr, align 8
  store i64 %len_dest, ptr %len_dest.addr, align 8
  store ptr %src, ptr %src.addr, align 8
  store i64 %len_src, ptr %len_src.addr, align 8
  %0 = load i64, ptr %len_dest.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end12

if.end:                                           ; preds = %entry
  %1 = load i64, ptr %len_src.addr, align 8
  %cmp1 = icmp eq i64 %1, 1
  br i1 %cmp1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.end
  %2 = load ptr, ptr %dest.addr, align 8
  %3 = load ptr, ptr %src.addr, align 8
  %arrayidx = getelementptr i8, ptr %3, i64 0
  %4 = load i8, ptr %arrayidx, align 1
  %conv = sext i8 %4 to i32
  %5 = trunc i32 %conv to i8
  %6 = load i64, ptr %len_dest.addr, align 8
  call void @llvm.memset.p0.i64(ptr align 1 %2, i8 %5, i64 %6, i1 false)
  br label %if.end12

if.else:                                          ; preds = %if.end
  %7 = load ptr, ptr %src.addr, align 8
  %8 = load ptr, ptr %dest.addr, align 8
  %cmp3 = icmp ne ptr %7, %8
  br i1 %cmp3, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.else
  %9 = load ptr, ptr %dest.addr, align 8
  %10 = load ptr, ptr %src.addr, align 8
  %11 = load i64, ptr %len_src.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %9, ptr align 1 %10, i64 %11, i1 false)
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %if.else
  %12 = load i64, ptr %len_src.addr, align 8
  store i64 %12, ptr %copied, align 8
  br label %while.cond

while.cond:                                       ; preds = %cond.end, %if.end6
  %13 = load i64, ptr %copied, align 8
  %14 = load i64, ptr %len_dest.addr, align 8
  %cmp7 = icmp slt i64 %13, %14
  br i1 %cmp7, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %15 = load i64, ptr %copied, align 8
  %16 = load i64, ptr %len_dest.addr, align 8
  %17 = load i64, ptr %copied, align 8
  %sub = sub i64 %16, %17
  %cmp9 = icmp sgt i64 %15, %sub
  br i1 %cmp9, label %cond.true, label %cond.false

cond.true:                                        ; preds = %while.body
  %18 = load i64, ptr %len_dest.addr, align 8
  %19 = load i64, ptr %copied, align 8
  %sub11 = sub i64 %18, %19
  br label %cond.end

cond.false:                                       ; preds = %while.body
  %20 = load i64, ptr %copied, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %sub11, %cond.true ], [ %20, %cond.false ]
  store i64 %cond, ptr %bytes_to_copy, align 8
  %21 = load ptr, ptr %dest.addr, align 8
  %22 = load i64, ptr %copied, align 8
  %add.ptr = getelementptr i8, ptr %21, i64 %22
  %23 = load ptr, ptr %dest.addr, align 8
  %24 = load i64, ptr %bytes_to_copy, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %add.ptr, ptr align 1 %23, i64 %24, i1 false)
  %25 = load i64, ptr %bytes_to_copy, align 8
  %26 = load i64, ptr %copied, align 8
  %add = add i64 %26, %25
  store i64 %add, ptr %copied, align 8
  br label %while.cond, !llvm.loop !24

while.end:                                        ; preds = %while.cond
  br label %if.end12

if.end12:                                         ; preds = %while.end, %if.then2, %if.then
  ret void
}

declare ptr @PyObject_Calloc(i64 noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define internal void @_PyObject_Init(ptr noundef %op, ptr noundef %typeobj) #0 {
entry:
  %op.addr.i = alloca ptr, align 8
  %cur_refcnt.i = alloca i32, align 4
  %new_refcnt.i = alloca i32, align 4
  %op.addr = alloca ptr, align 8
  %typeobj.addr = alloca ptr, align 8
  store ptr %op, ptr %op.addr, align 8
  store ptr %typeobj, ptr %typeobj.addr, align 8
  %0 = load ptr, ptr %op.addr, align 8
  %1 = load ptr, ptr %typeobj.addr, align 8
  call void @Py_SET_TYPE(ptr noundef %0, ptr noundef %1)
  %2 = load ptr, ptr %typeobj.addr, align 8
  %call = call i32 @_PyType_HasFeature(ptr noundef %2, i64 noundef 512)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %typeobj.addr, align 8
  store ptr %3, ptr %op.addr.i, align 8
  %4 = load ptr, ptr %op.addr.i, align 8
  %5 = load i32, ptr %4, align 8
  store i32 %5, ptr %cur_refcnt.i, align 4
  %6 = load i32, ptr %cur_refcnt.i, align 4
  %add.i = add i32 %6, 1
  store i32 %add.i, ptr %new_refcnt.i, align 4
  %7 = load i32, ptr %new_refcnt.i, align 4
  %cmp.i = icmp eq i32 %7, 0
  br i1 %cmp.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then
  br label %Py_INCREF.exit

if.end.i:                                         ; preds = %if.then
  %8 = load i32, ptr %new_refcnt.i, align 4
  %9 = load ptr, ptr %op.addr.i, align 8
  store i32 %8, ptr %9, align 8
  br label %Py_INCREF.exit

Py_INCREF.exit:                                   ; preds = %if.end.i, %if.then.i
  br label %if.end

if.end:                                           ; preds = %Py_INCREF.exit, %entry
  %10 = load ptr, ptr %op.addr, align 8
  call void @_Py_NewReference(ptr noundef %10)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @Py_SET_TYPE(ptr noundef %ob, ptr noundef %type) #0 {
entry:
  %ob.addr = alloca ptr, align 8
  %type.addr = alloca ptr, align 8
  store ptr %ob, ptr %ob.addr, align 8
  store ptr %type, ptr %type.addr, align 8
  %0 = load ptr, ptr %type.addr, align 8
  %1 = load ptr, ptr %ob.addr, align 8
  %ob_type = getelementptr inbounds %struct._object, ptr %1, i32 0, i32 1
  store ptr %0, ptr %ob_type, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @_PyType_HasFeature(ptr noundef %type, i64 noundef %feature) #0 {
entry:
  %type.addr = alloca ptr, align 8
  %feature.addr = alloca i64, align 8
  store ptr %type, ptr %type.addr, align 8
  store i64 %feature, ptr %feature.addr, align 8
  %0 = load ptr, ptr %type.addr, align 8
  %tp_flags = getelementptr inbounds %struct._typeobject, ptr %0, i32 0, i32 19
  %1 = load i64, ptr %tp_flags, align 8
  %2 = load i64, ptr %feature.addr, align 8
  %and = and i64 %1, %2
  %cmp = icmp ne i64 %and, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

declare void @_Py_NewReference(ptr noundef) #1

declare i32 @PyType_IsSubtype(ptr noundef, ptr noundef) #1

declare void @_Py_Dealloc(ptr noundef) #1

declare ptr @PyTuple_GetItem(ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define internal i32 @PyUnicode_IS_COMPACT(ptr noundef %op) #0 {
entry:
  %op.addr = alloca ptr, align 8
  store ptr %op, ptr %op.addr, align 8
  %0 = load ptr, ptr %op.addr, align 8
  %state = getelementptr inbounds %struct.PyASCIIObject, ptr %0, i32 0, i32 3
  %bf.load = load i32, ptr %state, align 8
  %bf.lshr = lshr i32 %bf.load, 5
  %bf.clear = and i32 %bf.lshr, 1
  ret i32 %bf.clear
}

; Function Attrs: nounwind uwtable
define internal ptr @_PyUnicode_COMPACT_DATA(ptr noundef %op) #0 {
entry:
  %retval = alloca ptr, align 8
  %op.addr = alloca ptr, align 8
  store ptr %op, ptr %op.addr, align 8
  %0 = load ptr, ptr %op.addr, align 8
  %call = call i32 @PyUnicode_IS_ASCII(ptr noundef %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %op.addr, align 8
  %add.ptr = getelementptr %struct.PyASCIIObject, ptr %1, i64 1
  store ptr %add.ptr, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %op.addr, align 8
  %add.ptr1 = getelementptr %struct.PyCompactUnicodeObject, ptr %2, i64 1
  store ptr %add.ptr1, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load ptr, ptr %retval, align 8
  ret ptr %3
}

; Function Attrs: nounwind uwtable
define internal ptr @_PyUnicode_NONCOMPACT_DATA(ptr noundef %op) #0 {
entry:
  %op.addr = alloca ptr, align 8
  %data = alloca ptr, align 8
  store ptr %op, ptr %op.addr, align 8
  %0 = load ptr, ptr %op.addr, align 8
  %data1 = getelementptr inbounds %struct.PyUnicodeObject, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %data1, align 8
  store ptr %1, ptr %data, align 8
  %2 = load ptr, ptr %data, align 8
  ret ptr %2
}

; Function Attrs: nounwind uwtable
define internal i64 @PyByteArray_GET_SIZE(ptr noundef %op) #0 {
entry:
  %op.addr = alloca ptr, align 8
  %self = alloca ptr, align 8
  store ptr %op, ptr %op.addr, align 8
  %0 = load ptr, ptr %op.addr, align 8
  store ptr %0, ptr %self, align 8
  %1 = load ptr, ptr %self, align 8
  %call = call i64 @Py_SIZE(ptr noundef %1)
  ret i64 %call
}

declare ptr @_PyObject_LookupSpecial(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @_PyObject_CallNoArgs(ptr noundef %func) #0 {
entry:
  %func.addr = alloca ptr, align 8
  %tstate = alloca ptr, align 8
  store ptr %func, ptr %func.addr, align 8
  %call = call ptr @_PyThreadState_GET()
  store ptr %call, ptr %tstate, align 8
  %0 = load ptr, ptr %tstate, align 8
  %1 = load ptr, ptr %func.addr, align 8
  %call1 = call ptr @_PyObject_VectorcallTstate(ptr noundef %0, ptr noundef %1, ptr noundef null, i64 noundef 0, ptr noundef null)
  ret ptr %call1
}

; Function Attrs: nounwind uwtable
define internal ptr @_PyThreadState_GET() #0 {
entry:
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @_Py_tss_tstate)
  %1 = load ptr, ptr %0, align 8
  ret ptr %1
}

; Function Attrs: nounwind uwtable
define internal ptr @_PyObject_VectorcallTstate(ptr noundef %tstate, ptr noundef %callable, ptr noundef %args, i64 noundef %nargsf, ptr noundef %kwnames) #0 {
entry:
  %retval = alloca ptr, align 8
  %tstate.addr = alloca ptr, align 8
  %callable.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargsf.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %func = alloca ptr, align 8
  %res = alloca ptr, align 8
  %nargs = alloca i64, align 8
  store ptr %tstate, ptr %tstate.addr, align 8
  store ptr %callable, ptr %callable.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargsf, ptr %nargsf.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  %0 = load ptr, ptr %callable.addr, align 8
  %call = call ptr @_PyVectorcall_FunctionInline(ptr noundef %0)
  store ptr %call, ptr %func, align 8
  %1 = load ptr, ptr %func, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i64, ptr %nargsf.addr, align 8
  %call1 = call i64 @_PyVectorcall_NARGS(i64 noundef %2)
  store i64 %call1, ptr %nargs, align 8
  %3 = load ptr, ptr %tstate.addr, align 8
  %4 = load ptr, ptr %callable.addr, align 8
  %5 = load ptr, ptr %args.addr, align 8
  %6 = load i64, ptr %nargs, align 8
  %7 = load ptr, ptr %kwnames.addr, align 8
  %call2 = call ptr @_PyObject_MakeTpCall(ptr noundef %3, ptr noundef %4, ptr noundef %5, i64 noundef %6, ptr noundef %7)
  store ptr %call2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %func, align 8
  %9 = load ptr, ptr %callable.addr, align 8
  %10 = load ptr, ptr %args.addr, align 8
  %11 = load i64, ptr %nargsf.addr, align 8
  %12 = load ptr, ptr %kwnames.addr, align 8
  %call3 = call ptr %8(ptr noundef %9, ptr noundef %10, i64 noundef %11, ptr noundef %12)
  store ptr %call3, ptr %res, align 8
  %13 = load ptr, ptr %tstate.addr, align 8
  %14 = load ptr, ptr %callable.addr, align 8
  %15 = load ptr, ptr %res, align 8
  %call4 = call ptr @_Py_CheckFunctionResult(ptr noundef %13, ptr noundef %14, ptr noundef %15, ptr noundef null)
  store ptr %call4, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %16 = load ptr, ptr %retval, align 8
  ret ptr %16
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare nonnull ptr @llvm.threadlocal.address.p0(ptr nonnull) #7

; Function Attrs: nounwind uwtable
define internal ptr @_PyVectorcall_FunctionInline(ptr noundef %callable) #0 {
entry:
  %retval = alloca ptr, align 8
  %callable.addr = alloca ptr, align 8
  %tp = alloca ptr, align 8
  %offset = alloca i64, align 8
  %ptr = alloca ptr, align 8
  store ptr %callable, ptr %callable.addr, align 8
  %0 = load ptr, ptr %callable.addr, align 8
  %call = call ptr @Py_TYPE(ptr noundef %0)
  store ptr %call, ptr %tp, align 8
  %1 = load ptr, ptr %tp, align 8
  %call1 = call i32 @PyType_HasFeature(ptr noundef %1, i64 noundef 2048)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %tp, align 8
  %tp_vectorcall_offset = getelementptr inbounds %struct._typeobject, ptr %2, i32 0, i32 5
  %3 = load i64, ptr %tp_vectorcall_offset, align 8
  store i64 %3, ptr %offset, align 8
  %4 = load ptr, ptr %callable.addr, align 8
  %5 = load i64, ptr %offset, align 8
  %add.ptr = getelementptr i8, ptr %4, i64 %5
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %ptr, ptr align 1 %add.ptr, i64 8, i1 false)
  %6 = load ptr, ptr %ptr, align 8
  store ptr %6, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load ptr, ptr %retval, align 8
  ret ptr %7
}

; Function Attrs: nounwind uwtable
define internal i64 @_PyVectorcall_NARGS(i64 noundef %n) #0 {
entry:
  %n.addr = alloca i64, align 8
  store i64 %n, ptr %n.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %and = and i64 %0, 9223372036854775807
  ret i64 %and
}

declare ptr @_PyObject_MakeTpCall(ptr noundef, ptr noundef, ptr noundef, i64 noundef, ptr noundef) #1

declare ptr @_Py_CheckFunctionResult(ptr noundef, ptr noundef, ptr noundef, ptr noundef) #1

declare ptr @_PyUnicode_FormatLong(ptr noundef, i32 noundef, i32 noundef, i32 noundef) #1

declare i32 @PyNumber_Check(ptr noundef) #1

declare ptr @_PyNumber_Index(ptr noundef) #1

declare ptr @PyNumber_Long(ptr noundef) #1

declare double @PyFloat_AsDouble(ptr noundef) #1

declare ptr @PyOS_double_to_string(double noundef, i8 noundef signext, i32 noundef, i32 noundef, ptr noundef) #1

declare void @PyMem_Free(ptr noundef) #1

declare i64 @PyLong_AsLongAndOverflow(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal i64 @fastsearch(ptr noundef %s, i64 noundef %n, ptr noundef %p, i64 noundef %m, i64 noundef %maxcount, i32 noundef %mode) #0 {
entry:
  %retval = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %p.addr = alloca ptr, align 8
  %m.addr = alloca i64, align 8
  %maxcount.addr = alloca i64, align 8
  %mode.addr = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %m, ptr %m.addr, align 8
  store i64 %maxcount, ptr %maxcount.addr, align 8
  store i32 %mode, ptr %mode.addr, align 4
  %0 = load i64, ptr %n.addr, align 8
  %1 = load i64, ptr %m.addr, align 8
  %cmp = icmp slt i64 %0, %1
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load i32, ptr %mode.addr, align 4
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.lhs.false
  %3 = load i64, ptr %maxcount.addr, align 8
  %cmp2 = icmp eq i64 %3, 0
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true, %entry
  store i64 -1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %land.lhs.true, %lor.lhs.false
  %4 = load i64, ptr %m.addr, align 8
  %cmp3 = icmp sle i64 %4, 1
  br i1 %cmp3, label %if.then4, label %if.end17

if.then4:                                         ; preds = %if.end
  %5 = load i64, ptr %m.addr, align 8
  %cmp5 = icmp sle i64 %5, 0
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.then4
  store i64 -1, ptr %retval, align 8
  br label %return

if.end7:                                          ; preds = %if.then4
  %6 = load i32, ptr %mode.addr, align 4
  %cmp8 = icmp eq i32 %6, 1
  br i1 %cmp8, label %if.then9, label %if.else

if.then9:                                         ; preds = %if.end7
  %7 = load ptr, ptr %s.addr, align 8
  %8 = load i64, ptr %n.addr, align 8
  %9 = load ptr, ptr %p.addr, align 8
  %arrayidx = getelementptr i8, ptr %9, i64 0
  %10 = load i8, ptr %arrayidx, align 1
  %call = call i64 @stringlib_find_char(ptr noundef %7, i64 noundef %8, i8 noundef signext %10)
  store i64 %call, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %if.end7
  %11 = load i32, ptr %mode.addr, align 4
  %cmp10 = icmp eq i32 %11, 2
  br i1 %cmp10, label %if.then11, label %if.else14

if.then11:                                        ; preds = %if.else
  %12 = load ptr, ptr %s.addr, align 8
  %13 = load i64, ptr %n.addr, align 8
  %14 = load ptr, ptr %p.addr, align 8
  %arrayidx12 = getelementptr i8, ptr %14, i64 0
  %15 = load i8, ptr %arrayidx12, align 1
  %call13 = call i64 @stringlib_rfind_char(ptr noundef %12, i64 noundef %13, i8 noundef signext %15)
  store i64 %call13, ptr %retval, align 8
  br label %return

if.else14:                                        ; preds = %if.else
  %16 = load ptr, ptr %s.addr, align 8
  %17 = load i64, ptr %n.addr, align 8
  %18 = load ptr, ptr %p.addr, align 8
  %arrayidx15 = getelementptr i8, ptr %18, i64 0
  %19 = load i8, ptr %arrayidx15, align 1
  %20 = load i64, ptr %maxcount.addr, align 8
  %call16 = call i64 @stringlib_count_char(ptr noundef %16, i64 noundef %17, i8 noundef signext %19, i64 noundef %20)
  store i64 %call16, ptr %retval, align 8
  br label %return

if.end17:                                         ; preds = %if.end
  %21 = load i32, ptr %mode.addr, align 4
  %cmp18 = icmp ne i32 %21, 2
  br i1 %cmp18, label %if.then19, label %if.else40

if.then19:                                        ; preds = %if.end17
  %22 = load i64, ptr %n.addr, align 8
  %cmp20 = icmp slt i64 %22, 2500
  br i1 %cmp20, label %if.then27, label %lor.lhs.false21

lor.lhs.false21:                                  ; preds = %if.then19
  %23 = load i64, ptr %m.addr, align 8
  %cmp22 = icmp slt i64 %23, 100
  br i1 %cmp22, label %land.lhs.true23, label %lor.lhs.false25

land.lhs.true23:                                  ; preds = %lor.lhs.false21
  %24 = load i64, ptr %n.addr, align 8
  %cmp24 = icmp slt i64 %24, 30000
  br i1 %cmp24, label %if.then27, label %lor.lhs.false25

lor.lhs.false25:                                  ; preds = %land.lhs.true23, %lor.lhs.false21
  %25 = load i64, ptr %m.addr, align 8
  %cmp26 = icmp slt i64 %25, 6
  br i1 %cmp26, label %if.then27, label %if.else29

if.then27:                                        ; preds = %lor.lhs.false25, %land.lhs.true23, %if.then19
  %26 = load ptr, ptr %s.addr, align 8
  %27 = load i64, ptr %n.addr, align 8
  %28 = load ptr, ptr %p.addr, align 8
  %29 = load i64, ptr %m.addr, align 8
  %30 = load i64, ptr %maxcount.addr, align 8
  %31 = load i32, ptr %mode.addr, align 4
  %call28 = call i64 @stringlib_default_find(ptr noundef %26, i64 noundef %27, ptr noundef %28, i64 noundef %29, i64 noundef %30, i32 noundef %31)
  store i64 %call28, ptr %retval, align 8
  br label %return

if.else29:                                        ; preds = %lor.lhs.false25
  %32 = load i64, ptr %m.addr, align 8
  %shr = ashr i64 %32, 2
  %mul = mul i64 %shr, 3
  %33 = load i64, ptr %n.addr, align 8
  %shr30 = ashr i64 %33, 2
  %cmp31 = icmp slt i64 %mul, %shr30
  br i1 %cmp31, label %if.then32, label %if.else38

if.then32:                                        ; preds = %if.else29
  %34 = load i32, ptr %mode.addr, align 4
  %cmp33 = icmp eq i32 %34, 1
  br i1 %cmp33, label %if.then34, label %if.else36

if.then34:                                        ; preds = %if.then32
  %35 = load ptr, ptr %s.addr, align 8
  %36 = load i64, ptr %n.addr, align 8
  %37 = load ptr, ptr %p.addr, align 8
  %38 = load i64, ptr %m.addr, align 8
  %call35 = call i64 @stringlib__two_way_find(ptr noundef %35, i64 noundef %36, ptr noundef %37, i64 noundef %38)
  store i64 %call35, ptr %retval, align 8
  br label %return

if.else36:                                        ; preds = %if.then32
  %39 = load ptr, ptr %s.addr, align 8
  %40 = load i64, ptr %n.addr, align 8
  %41 = load ptr, ptr %p.addr, align 8
  %42 = load i64, ptr %m.addr, align 8
  %43 = load i64, ptr %maxcount.addr, align 8
  %call37 = call i64 @stringlib__two_way_count(ptr noundef %39, i64 noundef %40, ptr noundef %41, i64 noundef %42, i64 noundef %43)
  store i64 %call37, ptr %retval, align 8
  br label %return

if.else38:                                        ; preds = %if.else29
  %44 = load ptr, ptr %s.addr, align 8
  %45 = load i64, ptr %n.addr, align 8
  %46 = load ptr, ptr %p.addr, align 8
  %47 = load i64, ptr %m.addr, align 8
  %48 = load i64, ptr %maxcount.addr, align 8
  %49 = load i32, ptr %mode.addr, align 4
  %call39 = call i64 @stringlib_adaptive_find(ptr noundef %44, i64 noundef %45, ptr noundef %46, i64 noundef %47, i64 noundef %48, i32 noundef %49)
  store i64 %call39, ptr %retval, align 8
  br label %return

if.else40:                                        ; preds = %if.end17
  %50 = load ptr, ptr %s.addr, align 8
  %51 = load i64, ptr %n.addr, align 8
  %52 = load ptr, ptr %p.addr, align 8
  %53 = load i64, ptr %m.addr, align 8
  %54 = load i64, ptr %maxcount.addr, align 8
  %55 = load i32, ptr %mode.addr, align 4
  %call41 = call i64 @stringlib_default_rfind(ptr noundef %50, i64 noundef %51, ptr noundef %52, i64 noundef %53, i64 noundef %54, i32 noundef %55)
  store i64 %call41, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else40, %if.else38, %if.else36, %if.then34, %if.then27, %if.else14, %if.then11, %if.then9, %if.then6, %if.then
  %56 = load i64, ptr %retval, align 8
  ret i64 %56
}

; Function Attrs: nounwind uwtable
define internal i64 @stringlib_find_char(ptr noundef %s, i64 noundef %n, i8 noundef signext %ch) #0 {
entry:
  %retval = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %ch.addr = alloca i8, align 1
  %p = alloca ptr, align 8
  %e = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store i8 %ch, ptr %ch.addr, align 1
  %0 = load ptr, ptr %s.addr, align 8
  store ptr %0, ptr %p, align 8
  %1 = load ptr, ptr %s.addr, align 8
  %2 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr i8, ptr %1, i64 %2
  store ptr %add.ptr, ptr %e, align 8
  %3 = load i64, ptr %n.addr, align 8
  %cmp = icmp sgt i64 %3, 15
  br i1 %cmp, label %if.then, label %if.end4

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr %s.addr, align 8
  %5 = load i8, ptr %ch.addr, align 1
  %conv = sext i8 %5 to i32
  %6 = load i64, ptr %n.addr, align 8
  %call = call ptr @memchr(ptr noundef %4, i32 noundef %conv, i64 noundef %6) #8
  store ptr %call, ptr %p, align 8
  %7 = load ptr, ptr %p, align 8
  %cmp1 = icmp ne ptr %7, null
  br i1 %cmp1, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %8 = load ptr, ptr %p, align 8
  %9 = load ptr, ptr %s.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %8 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %9 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %if.then
  store i64 -1, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %entry
  br label %while.cond

while.cond:                                       ; preds = %if.end15, %if.end4
  %10 = load ptr, ptr %p, align 8
  %11 = load ptr, ptr %e, align 8
  %cmp5 = icmp ult ptr %10, %11
  br i1 %cmp5, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %12 = load ptr, ptr %p, align 8
  %13 = load i8, ptr %12, align 1
  %conv7 = sext i8 %13 to i32
  %14 = load i8, ptr %ch.addr, align 1
  %conv8 = sext i8 %14 to i32
  %cmp9 = icmp eq i32 %conv7, %conv8
  br i1 %cmp9, label %if.then11, label %if.end15

if.then11:                                        ; preds = %while.body
  %15 = load ptr, ptr %p, align 8
  %16 = load ptr, ptr %s.addr, align 8
  %sub.ptr.lhs.cast12 = ptrtoint ptr %15 to i64
  %sub.ptr.rhs.cast13 = ptrtoint ptr %16 to i64
  %sub.ptr.sub14 = sub i64 %sub.ptr.lhs.cast12, %sub.ptr.rhs.cast13
  store i64 %sub.ptr.sub14, ptr %retval, align 8
  br label %return

if.end15:                                         ; preds = %while.body
  %17 = load ptr, ptr %p, align 8
  %incdec.ptr = getelementptr i8, ptr %17, i32 1
  store ptr %incdec.ptr, ptr %p, align 8
  br label %while.cond, !llvm.loop !25

while.end:                                        ; preds = %while.cond
  store i64 -1, ptr %retval, align 8
  br label %return

return:                                           ; preds = %while.end, %if.then11, %if.end, %if.then3
  %18 = load i64, ptr %retval, align 8
  ret i64 %18
}

; Function Attrs: nounwind uwtable
define internal i64 @stringlib_rfind_char(ptr noundef %s, i64 noundef %n, i8 noundef signext %ch) #0 {
entry:
  %retval = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %ch.addr = alloca i8, align 1
  %p = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store i8 %ch, ptr %ch.addr, align 1
  %0 = load i64, ptr %n.addr, align 8
  %cmp = icmp sgt i64 %0, 15
  br i1 %cmp, label %if.then, label %if.end4

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %2 = load i8, ptr %ch.addr, align 1
  %conv = sext i8 %2 to i32
  %3 = load i64, ptr %n.addr, align 8
  %call = call ptr @memrchr(ptr noundef %1, i32 noundef %conv, i64 noundef %3) #8
  store ptr %call, ptr %p, align 8
  %4 = load ptr, ptr %p, align 8
  %cmp1 = icmp ne ptr %4, null
  br i1 %cmp1, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %5 = load ptr, ptr %p, align 8
  %6 = load ptr, ptr %s.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %5 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %6 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %if.then
  store i64 -1, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %entry
  %7 = load ptr, ptr %s.addr, align 8
  %8 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr i8, ptr %7, i64 %8
  store ptr %add.ptr, ptr %p, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end15, %if.end4
  %9 = load ptr, ptr %p, align 8
  %10 = load ptr, ptr %s.addr, align 8
  %cmp5 = icmp ugt ptr %9, %10
  br i1 %cmp5, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %11 = load ptr, ptr %p, align 8
  %incdec.ptr = getelementptr i8, ptr %11, i32 -1
  store ptr %incdec.ptr, ptr %p, align 8
  %12 = load ptr, ptr %p, align 8
  %13 = load i8, ptr %12, align 1
  %conv7 = sext i8 %13 to i32
  %14 = load i8, ptr %ch.addr, align 1
  %conv8 = sext i8 %14 to i32
  %cmp9 = icmp eq i32 %conv7, %conv8
  br i1 %cmp9, label %if.then11, label %if.end15

if.then11:                                        ; preds = %while.body
  %15 = load ptr, ptr %p, align 8
  %16 = load ptr, ptr %s.addr, align 8
  %sub.ptr.lhs.cast12 = ptrtoint ptr %15 to i64
  %sub.ptr.rhs.cast13 = ptrtoint ptr %16 to i64
  %sub.ptr.sub14 = sub i64 %sub.ptr.lhs.cast12, %sub.ptr.rhs.cast13
  store i64 %sub.ptr.sub14, ptr %retval, align 8
  br label %return

if.end15:                                         ; preds = %while.body
  br label %while.cond, !llvm.loop !26

while.end:                                        ; preds = %while.cond
  store i64 -1, ptr %retval, align 8
  br label %return

return:                                           ; preds = %while.end, %if.then11, %if.end, %if.then3
  %17 = load i64, ptr %retval, align 8
  ret i64 %17
}

; Function Attrs: nounwind uwtable
define internal i64 @stringlib_count_char(ptr noundef %s, i64 noundef %n, i8 noundef signext %p0, i64 noundef %maxcount) #0 {
entry:
  %retval = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %p0.addr = alloca i8, align 1
  %maxcount.addr = alloca i64, align 8
  %i = alloca i64, align 8
  %count = alloca i64, align 8
  store ptr %s, ptr %s.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store i8 %p0, ptr %p0.addr, align 1
  store i64 %maxcount, ptr %maxcount.addr, align 8
  store i64 0, ptr %count, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8
  %1 = load i64, ptr %n.addr, align 8
  %cmp = icmp slt i64 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr %s.addr, align 8
  %3 = load i64, ptr %i, align 8
  %arrayidx = getelementptr i8, ptr %2, i64 %3
  %4 = load i8, ptr %arrayidx, align 1
  %conv = sext i8 %4 to i32
  %5 = load i8, ptr %p0.addr, align 1
  %conv1 = sext i8 %5 to i32
  %cmp2 = icmp eq i32 %conv, %conv1
  br i1 %cmp2, label %if.then, label %if.end7

if.then:                                          ; preds = %for.body
  %6 = load i64, ptr %count, align 8
  %inc = add i64 %6, 1
  store i64 %inc, ptr %count, align 8
  %7 = load i64, ptr %count, align 8
  %8 = load i64, ptr %maxcount.addr, align 8
  %cmp4 = icmp eq i64 %7, %8
  br i1 %cmp4, label %if.then6, label %if.end

if.then6:                                         ; preds = %if.then
  %9 = load i64, ptr %maxcount.addr, align 8
  store i64 %9, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %if.then
  br label %if.end7

if.end7:                                          ; preds = %if.end, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end7
  %10 = load i64, ptr %i, align 8
  %inc8 = add i64 %10, 1
  store i64 %inc8, ptr %i, align 8
  br label %for.cond, !llvm.loop !27

for.end:                                          ; preds = %for.cond
  %11 = load i64, ptr %count, align 8
  store i64 %11, ptr %retval, align 8
  br label %return

return:                                           ; preds = %for.end, %if.then6
  %12 = load i64, ptr %retval, align 8
  ret i64 %12
}

; Function Attrs: nounwind uwtable
define internal i64 @stringlib_default_find(ptr noundef %s, i64 noundef %n, ptr noundef %p, i64 noundef %m, i64 noundef %maxcount, i32 noundef %mode) #0 {
entry:
  %retval = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %p.addr = alloca ptr, align 8
  %m.addr = alloca i64, align 8
  %maxcount.addr = alloca i64, align 8
  %mode.addr = alloca i32, align 4
  %w = alloca i64, align 8
  %mlast = alloca i64, align 8
  %count = alloca i64, align 8
  %gap = alloca i64, align 8
  %last = alloca i8, align 1
  %ss = alloca ptr, align 8
  %mask = alloca i64, align 8
  %i = alloca i64, align 8
  %i16 = alloca i64, align 8
  %j = alloca i64, align 8
  store ptr %s, ptr %s.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %m, ptr %m.addr, align 8
  store i64 %maxcount, ptr %maxcount.addr, align 8
  store i32 %mode, ptr %mode.addr, align 4
  %0 = load i64, ptr %n.addr, align 8
  %1 = load i64, ptr %m.addr, align 8
  %sub = sub i64 %0, %1
  store i64 %sub, ptr %w, align 8
  %2 = load i64, ptr %m.addr, align 8
  %sub1 = sub i64 %2, 1
  store i64 %sub1, ptr %mlast, align 8
  store i64 0, ptr %count, align 8
  %3 = load i64, ptr %mlast, align 8
  store i64 %3, ptr %gap, align 8
  %4 = load ptr, ptr %p.addr, align 8
  %5 = load i64, ptr %mlast, align 8
  %arrayidx = getelementptr i8, ptr %4, i64 %5
  %6 = load i8, ptr %arrayidx, align 1
  store i8 %6, ptr %last, align 1
  %7 = load ptr, ptr %s.addr, align 8
  %8 = load i64, ptr %mlast, align 8
  %arrayidx2 = getelementptr i8, ptr %7, i64 %8
  store ptr %arrayidx2, ptr %ss, align 8
  store i64 0, ptr %mask, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i64, ptr %i, align 8
  %10 = load i64, ptr %mlast, align 8
  %cmp = icmp slt i64 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %p.addr, align 8
  %12 = load i64, ptr %i, align 8
  %arrayidx3 = getelementptr i8, ptr %11, i64 %12
  %13 = load i8, ptr %arrayidx3, align 1
  %conv = sext i8 %13 to i32
  %and = and i32 %conv, 63
  %sh_prom = zext i32 %and to i64
  %shl = shl i64 1, %sh_prom
  %14 = load i64, ptr %mask, align 8
  %or = or i64 %14, %shl
  store i64 %or, ptr %mask, align 8
  %15 = load ptr, ptr %p.addr, align 8
  %16 = load i64, ptr %i, align 8
  %arrayidx4 = getelementptr i8, ptr %15, i64 %16
  %17 = load i8, ptr %arrayidx4, align 1
  %conv5 = sext i8 %17 to i32
  %18 = load i8, ptr %last, align 1
  %conv6 = sext i8 %18 to i32
  %cmp7 = icmp eq i32 %conv5, %conv6
  br i1 %cmp7, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %19 = load i64, ptr %mlast, align 8
  %20 = load i64, ptr %i, align 8
  %sub9 = sub i64 %19, %20
  %sub10 = sub i64 %sub9, 1
  store i64 %sub10, ptr %gap, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %21 = load i64, ptr %i, align 8
  %inc = add i64 %21, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !28

for.end:                                          ; preds = %for.cond
  %22 = load i8, ptr %last, align 1
  %conv11 = sext i8 %22 to i32
  %and12 = and i32 %conv11, 63
  %sh_prom13 = zext i32 %and12 to i64
  %shl14 = shl i64 1, %sh_prom13
  %23 = load i64, ptr %mask, align 8
  %or15 = or i64 %23, %shl14
  store i64 %or15, ptr %mask, align 8
  store i64 0, ptr %i16, align 8
  br label %for.cond17

for.cond17:                                       ; preds = %for.inc80, %for.end
  %24 = load i64, ptr %i16, align 8
  %25 = load i64, ptr %w, align 8
  %cmp18 = icmp sle i64 %24, %25
  br i1 %cmp18, label %for.body20, label %for.end82

for.body20:                                       ; preds = %for.cond17
  %26 = load ptr, ptr %ss, align 8
  %27 = load i64, ptr %i16, align 8
  %arrayidx21 = getelementptr i8, ptr %26, i64 %27
  %28 = load i8, ptr %arrayidx21, align 1
  %conv22 = sext i8 %28 to i32
  %29 = load i8, ptr %last, align 1
  %conv23 = sext i8 %29 to i32
  %cmp24 = icmp eq i32 %conv22, %conv23
  br i1 %cmp24, label %if.then26, label %if.else67

if.then26:                                        ; preds = %for.body20
  store i64 0, ptr %j, align 8
  br label %for.cond27

for.cond27:                                       ; preds = %for.inc39, %if.then26
  %30 = load i64, ptr %j, align 8
  %31 = load i64, ptr %mlast, align 8
  %cmp28 = icmp slt i64 %30, %31
  br i1 %cmp28, label %for.body30, label %for.end41

for.body30:                                       ; preds = %for.cond27
  %32 = load ptr, ptr %s.addr, align 8
  %33 = load i64, ptr %i16, align 8
  %34 = load i64, ptr %j, align 8
  %add = add i64 %33, %34
  %arrayidx31 = getelementptr i8, ptr %32, i64 %add
  %35 = load i8, ptr %arrayidx31, align 1
  %conv32 = sext i8 %35 to i32
  %36 = load ptr, ptr %p.addr, align 8
  %37 = load i64, ptr %j, align 8
  %arrayidx33 = getelementptr i8, ptr %36, i64 %37
  %38 = load i8, ptr %arrayidx33, align 1
  %conv34 = sext i8 %38 to i32
  %cmp35 = icmp ne i32 %conv32, %conv34
  br i1 %cmp35, label %if.then37, label %if.end38

if.then37:                                        ; preds = %for.body30
  br label %for.end41

if.end38:                                         ; preds = %for.body30
  br label %for.inc39

for.inc39:                                        ; preds = %if.end38
  %39 = load i64, ptr %j, align 8
  %inc40 = add i64 %39, 1
  store i64 %inc40, ptr %j, align 8
  br label %for.cond27, !llvm.loop !29

for.end41:                                        ; preds = %if.then37, %for.cond27
  %40 = load i64, ptr %j, align 8
  %41 = load i64, ptr %mlast, align 8
  %cmp42 = icmp eq i64 %40, %41
  br i1 %cmp42, label %if.then44, label %if.end55

if.then44:                                        ; preds = %for.end41
  %42 = load i32, ptr %mode.addr, align 4
  %cmp45 = icmp ne i32 %42, 0
  br i1 %cmp45, label %if.then47, label %if.end48

if.then47:                                        ; preds = %if.then44
  %43 = load i64, ptr %i16, align 8
  store i64 %43, ptr %retval, align 8
  br label %return

if.end48:                                         ; preds = %if.then44
  %44 = load i64, ptr %count, align 8
  %inc49 = add i64 %44, 1
  store i64 %inc49, ptr %count, align 8
  %45 = load i64, ptr %count, align 8
  %46 = load i64, ptr %maxcount.addr, align 8
  %cmp50 = icmp eq i64 %45, %46
  br i1 %cmp50, label %if.then52, label %if.end53

if.then52:                                        ; preds = %if.end48
  %47 = load i64, ptr %maxcount.addr, align 8
  store i64 %47, ptr %retval, align 8
  br label %return

if.end53:                                         ; preds = %if.end48
  %48 = load i64, ptr %i16, align 8
  %49 = load i64, ptr %mlast, align 8
  %add54 = add i64 %48, %49
  store i64 %add54, ptr %i16, align 8
  br label %for.inc80

if.end55:                                         ; preds = %for.end41
  %50 = load i64, ptr %mask, align 8
  %51 = load ptr, ptr %ss, align 8
  %52 = load i64, ptr %i16, align 8
  %add56 = add i64 %52, 1
  %arrayidx57 = getelementptr i8, ptr %51, i64 %add56
  %53 = load i8, ptr %arrayidx57, align 1
  %conv58 = sext i8 %53 to i32
  %and59 = and i32 %conv58, 63
  %sh_prom60 = zext i32 %and59 to i64
  %shl61 = shl i64 1, %sh_prom60
  %and62 = and i64 %50, %shl61
  %tobool = icmp ne i64 %and62, 0
  br i1 %tobool, label %if.else, label %if.then63

if.then63:                                        ; preds = %if.end55
  %54 = load i64, ptr %i16, align 8
  %55 = load i64, ptr %m.addr, align 8
  %add64 = add i64 %54, %55
  store i64 %add64, ptr %i16, align 8
  br label %if.end66

if.else:                                          ; preds = %if.end55
  %56 = load i64, ptr %i16, align 8
  %57 = load i64, ptr %gap, align 8
  %add65 = add i64 %56, %57
  store i64 %add65, ptr %i16, align 8
  br label %if.end66

if.end66:                                         ; preds = %if.else, %if.then63
  br label %if.end79

if.else67:                                        ; preds = %for.body20
  %58 = load i64, ptr %mask, align 8
  %59 = load ptr, ptr %ss, align 8
  %60 = load i64, ptr %i16, align 8
  %add68 = add i64 %60, 1
  %arrayidx69 = getelementptr i8, ptr %59, i64 %add68
  %61 = load i8, ptr %arrayidx69, align 1
  %conv70 = sext i8 %61 to i32
  %and71 = and i32 %conv70, 63
  %sh_prom72 = zext i32 %and71 to i64
  %shl73 = shl i64 1, %sh_prom72
  %and74 = and i64 %58, %shl73
  %tobool75 = icmp ne i64 %and74, 0
  br i1 %tobool75, label %if.end78, label %if.then76

if.then76:                                        ; preds = %if.else67
  %62 = load i64, ptr %i16, align 8
  %63 = load i64, ptr %m.addr, align 8
  %add77 = add i64 %62, %63
  store i64 %add77, ptr %i16, align 8
  br label %if.end78

if.end78:                                         ; preds = %if.then76, %if.else67
  br label %if.end79

if.end79:                                         ; preds = %if.end78, %if.end66
  br label %for.inc80

for.inc80:                                        ; preds = %if.end79, %if.end53
  %64 = load i64, ptr %i16, align 8
  %inc81 = add i64 %64, 1
  store i64 %inc81, ptr %i16, align 8
  br label %for.cond17, !llvm.loop !30

for.end82:                                        ; preds = %for.cond17
  %65 = load i32, ptr %mode.addr, align 4
  %cmp83 = icmp eq i32 %65, 0
  br i1 %cmp83, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.end82
  %66 = load i64, ptr %count, align 8
  br label %cond.end

cond.false:                                       ; preds = %for.end82
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %66, %cond.true ], [ -1, %cond.false ]
  store i64 %cond, ptr %retval, align 8
  br label %return

return:                                           ; preds = %cond.end, %if.then52, %if.then47
  %67 = load i64, ptr %retval, align 8
  ret i64 %67
}

; Function Attrs: nounwind uwtable
define internal i64 @stringlib__two_way_find(ptr noundef %haystack, i64 noundef %len_haystack, ptr noundef %needle, i64 noundef %len_needle) #0 {
entry:
  %haystack.addr = alloca ptr, align 8
  %len_haystack.addr = alloca i64, align 8
  %needle.addr = alloca ptr, align 8
  %len_needle.addr = alloca i64, align 8
  %p = alloca %struct.stringlib__pre, align 8
  store ptr %haystack, ptr %haystack.addr, align 8
  store i64 %len_haystack, ptr %len_haystack.addr, align 8
  store ptr %needle, ptr %needle.addr, align 8
  store i64 %len_needle, ptr %len_needle.addr, align 8
  %0 = load ptr, ptr %needle.addr, align 8
  %1 = load i64, ptr %len_needle.addr, align 8
  call void @stringlib__preprocess(ptr noundef %0, i64 noundef %1, ptr noundef %p)
  %2 = load ptr, ptr %haystack.addr, align 8
  %3 = load i64, ptr %len_haystack.addr, align 8
  %call = call i64 @stringlib__two_way(ptr noundef %2, i64 noundef %3, ptr noundef %p)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define internal i64 @stringlib__two_way_count(ptr noundef %haystack, i64 noundef %len_haystack, ptr noundef %needle, i64 noundef %len_needle, i64 noundef %maxcount) #0 {
entry:
  %retval = alloca i64, align 8
  %haystack.addr = alloca ptr, align 8
  %len_haystack.addr = alloca i64, align 8
  %needle.addr = alloca ptr, align 8
  %len_needle.addr = alloca i64, align 8
  %maxcount.addr = alloca i64, align 8
  %p = alloca %struct.stringlib__pre, align 8
  %index = alloca i64, align 8
  %count = alloca i64, align 8
  %result = alloca i64, align 8
  store ptr %haystack, ptr %haystack.addr, align 8
  store i64 %len_haystack, ptr %len_haystack.addr, align 8
  store ptr %needle, ptr %needle.addr, align 8
  store i64 %len_needle, ptr %len_needle.addr, align 8
  store i64 %maxcount, ptr %maxcount.addr, align 8
  %0 = load ptr, ptr %needle.addr, align 8
  %1 = load i64, ptr %len_needle.addr, align 8
  call void @stringlib__preprocess(ptr noundef %0, i64 noundef %1, ptr noundef %p)
  store i64 0, ptr %index, align 8
  store i64 0, ptr %count, align 8
  br label %while.body

while.body:                                       ; preds = %if.end3, %entry
  %2 = load ptr, ptr %haystack.addr, align 8
  %3 = load i64, ptr %index, align 8
  %add.ptr = getelementptr i8, ptr %2, i64 %3
  %4 = load i64, ptr %len_haystack.addr, align 8
  %5 = load i64, ptr %index, align 8
  %sub = sub i64 %4, %5
  %call = call i64 @stringlib__two_way(ptr noundef %add.ptr, i64 noundef %sub, ptr noundef %p)
  store i64 %call, ptr %result, align 8
  %6 = load i64, ptr %result, align 8
  %cmp = icmp eq i64 %6, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %7 = load i64, ptr %count, align 8
  store i64 %7, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %while.body
  %8 = load i64, ptr %count, align 8
  %inc = add i64 %8, 1
  store i64 %inc, ptr %count, align 8
  %9 = load i64, ptr %count, align 8
  %10 = load i64, ptr %maxcount.addr, align 8
  %cmp1 = icmp eq i64 %9, %10
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %11 = load i64, ptr %maxcount.addr, align 8
  store i64 %11, ptr %retval, align 8
  br label %return

if.end3:                                          ; preds = %if.end
  %12 = load i64, ptr %result, align 8
  %13 = load i64, ptr %len_needle.addr, align 8
  %add = add i64 %12, %13
  %14 = load i64, ptr %index, align 8
  %add4 = add i64 %14, %add
  store i64 %add4, ptr %index, align 8
  br label %while.body

return:                                           ; preds = %if.then2, %if.then
  %15 = load i64, ptr %retval, align 8
  ret i64 %15
}

; Function Attrs: nounwind uwtable
define internal i64 @stringlib_adaptive_find(ptr noundef %s, i64 noundef %n, ptr noundef %p, i64 noundef %m, i64 noundef %maxcount, i32 noundef %mode) #0 {
entry:
  %retval = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %p.addr = alloca ptr, align 8
  %m.addr = alloca i64, align 8
  %maxcount.addr = alloca i64, align 8
  %mode.addr = alloca i32, align 4
  %w = alloca i64, align 8
  %mlast = alloca i64, align 8
  %count = alloca i64, align 8
  %gap = alloca i64, align 8
  %hits = alloca i64, align 8
  %res = alloca i64, align 8
  %last = alloca i8, align 1
  %ss = alloca ptr, align 8
  %mask = alloca i64, align 8
  %i = alloca i64, align 8
  %i16 = alloca i64, align 8
  %j = alloca i64, align 8
  store ptr %s, ptr %s.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %m, ptr %m.addr, align 8
  store i64 %maxcount, ptr %maxcount.addr, align 8
  store i32 %mode, ptr %mode.addr, align 4
  %0 = load i64, ptr %n.addr, align 8
  %1 = load i64, ptr %m.addr, align 8
  %sub = sub i64 %0, %1
  store i64 %sub, ptr %w, align 8
  %2 = load i64, ptr %m.addr, align 8
  %sub1 = sub i64 %2, 1
  store i64 %sub1, ptr %mlast, align 8
  store i64 0, ptr %count, align 8
  %3 = load i64, ptr %mlast, align 8
  store i64 %3, ptr %gap, align 8
  store i64 0, ptr %hits, align 8
  %4 = load ptr, ptr %p.addr, align 8
  %5 = load i64, ptr %mlast, align 8
  %arrayidx = getelementptr i8, ptr %4, i64 %5
  %6 = load i8, ptr %arrayidx, align 1
  store i8 %6, ptr %last, align 1
  %7 = load ptr, ptr %s.addr, align 8
  %8 = load i64, ptr %mlast, align 8
  %arrayidx2 = getelementptr i8, ptr %7, i64 %8
  store ptr %arrayidx2, ptr %ss, align 8
  store i64 0, ptr %mask, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i64, ptr %i, align 8
  %10 = load i64, ptr %mlast, align 8
  %cmp = icmp slt i64 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %p.addr, align 8
  %12 = load i64, ptr %i, align 8
  %arrayidx3 = getelementptr i8, ptr %11, i64 %12
  %13 = load i8, ptr %arrayidx3, align 1
  %conv = sext i8 %13 to i32
  %and = and i32 %conv, 63
  %sh_prom = zext i32 %and to i64
  %shl = shl i64 1, %sh_prom
  %14 = load i64, ptr %mask, align 8
  %or = or i64 %14, %shl
  store i64 %or, ptr %mask, align 8
  %15 = load ptr, ptr %p.addr, align 8
  %16 = load i64, ptr %i, align 8
  %arrayidx4 = getelementptr i8, ptr %15, i64 %16
  %17 = load i8, ptr %arrayidx4, align 1
  %conv5 = sext i8 %17 to i32
  %18 = load i8, ptr %last, align 1
  %conv6 = sext i8 %18 to i32
  %cmp7 = icmp eq i32 %conv5, %conv6
  br i1 %cmp7, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %19 = load i64, ptr %mlast, align 8
  %20 = load i64, ptr %i, align 8
  %sub9 = sub i64 %19, %20
  %sub10 = sub i64 %sub9, 1
  store i64 %sub10, ptr %gap, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %21 = load i64, ptr %i, align 8
  %inc = add i64 %21, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !31

for.end:                                          ; preds = %for.cond
  %22 = load i8, ptr %last, align 1
  %conv11 = sext i8 %22 to i32
  %and12 = and i32 %conv11, 63
  %sh_prom13 = zext i32 %and12 to i64
  %shl14 = shl i64 1, %sh_prom13
  %23 = load i64, ptr %mask, align 8
  %or15 = or i64 %23, %shl14
  store i64 %or15, ptr %mask, align 8
  store i64 0, ptr %i16, align 8
  br label %for.cond17

for.cond17:                                       ; preds = %for.inc102, %for.end
  %24 = load i64, ptr %i16, align 8
  %25 = load i64, ptr %w, align 8
  %cmp18 = icmp sle i64 %24, %25
  br i1 %cmp18, label %for.body20, label %for.end104

for.body20:                                       ; preds = %for.cond17
  %26 = load ptr, ptr %ss, align 8
  %27 = load i64, ptr %i16, align 8
  %arrayidx21 = getelementptr i8, ptr %26, i64 %27
  %28 = load i8, ptr %arrayidx21, align 1
  %conv22 = sext i8 %28 to i32
  %29 = load i8, ptr %last, align 1
  %conv23 = sext i8 %29 to i32
  %cmp24 = icmp eq i32 %conv22, %conv23
  br i1 %cmp24, label %if.then26, label %if.else89

if.then26:                                        ; preds = %for.body20
  store i64 0, ptr %j, align 8
  br label %for.cond27

for.cond27:                                       ; preds = %for.inc39, %if.then26
  %30 = load i64, ptr %j, align 8
  %31 = load i64, ptr %mlast, align 8
  %cmp28 = icmp slt i64 %30, %31
  br i1 %cmp28, label %for.body30, label %for.end41

for.body30:                                       ; preds = %for.cond27
  %32 = load ptr, ptr %s.addr, align 8
  %33 = load i64, ptr %i16, align 8
  %34 = load i64, ptr %j, align 8
  %add = add i64 %33, %34
  %arrayidx31 = getelementptr i8, ptr %32, i64 %add
  %35 = load i8, ptr %arrayidx31, align 1
  %conv32 = sext i8 %35 to i32
  %36 = load ptr, ptr %p.addr, align 8
  %37 = load i64, ptr %j, align 8
  %arrayidx33 = getelementptr i8, ptr %36, i64 %37
  %38 = load i8, ptr %arrayidx33, align 1
  %conv34 = sext i8 %38 to i32
  %cmp35 = icmp ne i32 %conv32, %conv34
  br i1 %cmp35, label %if.then37, label %if.end38

if.then37:                                        ; preds = %for.body30
  br label %for.end41

if.end38:                                         ; preds = %for.body30
  br label %for.inc39

for.inc39:                                        ; preds = %if.end38
  %39 = load i64, ptr %j, align 8
  %inc40 = add i64 %39, 1
  store i64 %inc40, ptr %j, align 8
  br label %for.cond27, !llvm.loop !32

for.end41:                                        ; preds = %if.then37, %for.cond27
  %40 = load i64, ptr %j, align 8
  %41 = load i64, ptr %mlast, align 8
  %cmp42 = icmp eq i64 %40, %41
  br i1 %cmp42, label %if.then44, label %if.end55

if.then44:                                        ; preds = %for.end41
  %42 = load i32, ptr %mode.addr, align 4
  %cmp45 = icmp ne i32 %42, 0
  br i1 %cmp45, label %if.then47, label %if.end48

if.then47:                                        ; preds = %if.then44
  %43 = load i64, ptr %i16, align 8
  store i64 %43, ptr %retval, align 8
  br label %return

if.end48:                                         ; preds = %if.then44
  %44 = load i64, ptr %count, align 8
  %inc49 = add i64 %44, 1
  store i64 %inc49, ptr %count, align 8
  %45 = load i64, ptr %count, align 8
  %46 = load i64, ptr %maxcount.addr, align 8
  %cmp50 = icmp eq i64 %45, %46
  br i1 %cmp50, label %if.then52, label %if.end53

if.then52:                                        ; preds = %if.end48
  %47 = load i64, ptr %maxcount.addr, align 8
  store i64 %47, ptr %retval, align 8
  br label %return

if.end53:                                         ; preds = %if.end48
  %48 = load i64, ptr %i16, align 8
  %49 = load i64, ptr %mlast, align 8
  %add54 = add i64 %48, %49
  store i64 %add54, ptr %i16, align 8
  br label %for.inc102

if.end55:                                         ; preds = %for.end41
  %50 = load i64, ptr %j, align 8
  %add56 = add i64 %50, 1
  %51 = load i64, ptr %hits, align 8
  %add57 = add i64 %51, %add56
  store i64 %add57, ptr %hits, align 8
  %52 = load i64, ptr %hits, align 8
  %53 = load i64, ptr %m.addr, align 8
  %div = sdiv i64 %53, 4
  %cmp58 = icmp sgt i64 %52, %div
  br i1 %cmp58, label %land.lhs.true, label %if.end76

land.lhs.true:                                    ; preds = %if.end55
  %54 = load i64, ptr %w, align 8
  %55 = load i64, ptr %i16, align 8
  %sub60 = sub i64 %54, %55
  %cmp61 = icmp sgt i64 %sub60, 2000
  br i1 %cmp61, label %if.then63, label %if.end76

if.then63:                                        ; preds = %land.lhs.true
  %56 = load i32, ptr %mode.addr, align 4
  %cmp64 = icmp eq i32 %56, 1
  br i1 %cmp64, label %if.then66, label %if.else

if.then66:                                        ; preds = %if.then63
  %57 = load ptr, ptr %s.addr, align 8
  %58 = load i64, ptr %i16, align 8
  %add.ptr = getelementptr i8, ptr %57, i64 %58
  %59 = load i64, ptr %n.addr, align 8
  %60 = load i64, ptr %i16, align 8
  %sub67 = sub i64 %59, %60
  %61 = load ptr, ptr %p.addr, align 8
  %62 = load i64, ptr %m.addr, align 8
  %call = call i64 @stringlib__two_way_find(ptr noundef %add.ptr, i64 noundef %sub67, ptr noundef %61, i64 noundef %62)
  store i64 %call, ptr %res, align 8
  %63 = load i64, ptr %res, align 8
  %cmp68 = icmp eq i64 %63, -1
  br i1 %cmp68, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then66
  br label %cond.end

cond.false:                                       ; preds = %if.then66
  %64 = load i64, ptr %res, align 8
  %65 = load i64, ptr %i16, align 8
  %add70 = add i64 %64, %65
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ -1, %cond.true ], [ %add70, %cond.false ]
  store i64 %cond, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %if.then63
  %66 = load ptr, ptr %s.addr, align 8
  %67 = load i64, ptr %i16, align 8
  %add.ptr71 = getelementptr i8, ptr %66, i64 %67
  %68 = load i64, ptr %n.addr, align 8
  %69 = load i64, ptr %i16, align 8
  %sub72 = sub i64 %68, %69
  %70 = load ptr, ptr %p.addr, align 8
  %71 = load i64, ptr %m.addr, align 8
  %72 = load i64, ptr %maxcount.addr, align 8
  %73 = load i64, ptr %count, align 8
  %sub73 = sub i64 %72, %73
  %call74 = call i64 @stringlib__two_way_count(ptr noundef %add.ptr71, i64 noundef %sub72, ptr noundef %70, i64 noundef %71, i64 noundef %sub73)
  store i64 %call74, ptr %res, align 8
  %74 = load i64, ptr %res, align 8
  %75 = load i64, ptr %count, align 8
  %add75 = add i64 %74, %75
  store i64 %add75, ptr %retval, align 8
  br label %return

if.end76:                                         ; preds = %land.lhs.true, %if.end55
  %76 = load i64, ptr %mask, align 8
  %77 = load ptr, ptr %ss, align 8
  %78 = load i64, ptr %i16, align 8
  %add77 = add i64 %78, 1
  %arrayidx78 = getelementptr i8, ptr %77, i64 %add77
  %79 = load i8, ptr %arrayidx78, align 1
  %conv79 = sext i8 %79 to i32
  %and80 = and i32 %conv79, 63
  %sh_prom81 = zext i32 %and80 to i64
  %shl82 = shl i64 1, %sh_prom81
  %and83 = and i64 %76, %shl82
  %tobool = icmp ne i64 %and83, 0
  br i1 %tobool, label %if.else86, label %if.then84

if.then84:                                        ; preds = %if.end76
  %80 = load i64, ptr %i16, align 8
  %81 = load i64, ptr %m.addr, align 8
  %add85 = add i64 %80, %81
  store i64 %add85, ptr %i16, align 8
  br label %if.end88

if.else86:                                        ; preds = %if.end76
  %82 = load i64, ptr %i16, align 8
  %83 = load i64, ptr %gap, align 8
  %add87 = add i64 %82, %83
  store i64 %add87, ptr %i16, align 8
  br label %if.end88

if.end88:                                         ; preds = %if.else86, %if.then84
  br label %if.end101

if.else89:                                        ; preds = %for.body20
  %84 = load i64, ptr %mask, align 8
  %85 = load ptr, ptr %ss, align 8
  %86 = load i64, ptr %i16, align 8
  %add90 = add i64 %86, 1
  %arrayidx91 = getelementptr i8, ptr %85, i64 %add90
  %87 = load i8, ptr %arrayidx91, align 1
  %conv92 = sext i8 %87 to i32
  %and93 = and i32 %conv92, 63
  %sh_prom94 = zext i32 %and93 to i64
  %shl95 = shl i64 1, %sh_prom94
  %and96 = and i64 %84, %shl95
  %tobool97 = icmp ne i64 %and96, 0
  br i1 %tobool97, label %if.end100, label %if.then98

if.then98:                                        ; preds = %if.else89
  %88 = load i64, ptr %i16, align 8
  %89 = load i64, ptr %m.addr, align 8
  %add99 = add i64 %88, %89
  store i64 %add99, ptr %i16, align 8
  br label %if.end100

if.end100:                                        ; preds = %if.then98, %if.else89
  br label %if.end101

if.end101:                                        ; preds = %if.end100, %if.end88
  br label %for.inc102

for.inc102:                                       ; preds = %if.end101, %if.end53
  %90 = load i64, ptr %i16, align 8
  %inc103 = add i64 %90, 1
  store i64 %inc103, ptr %i16, align 8
  br label %for.cond17, !llvm.loop !33

for.end104:                                       ; preds = %for.cond17
  %91 = load i32, ptr %mode.addr, align 4
  %cmp105 = icmp eq i32 %91, 0
  br i1 %cmp105, label %cond.true107, label %cond.false108

cond.true107:                                     ; preds = %for.end104
  %92 = load i64, ptr %count, align 8
  br label %cond.end109

cond.false108:                                    ; preds = %for.end104
  br label %cond.end109

cond.end109:                                      ; preds = %cond.false108, %cond.true107
  %cond110 = phi i64 [ %92, %cond.true107 ], [ -1, %cond.false108 ]
  store i64 %cond110, ptr %retval, align 8
  br label %return

return:                                           ; preds = %cond.end109, %if.else, %cond.end, %if.then52, %if.then47
  %93 = load i64, ptr %retval, align 8
  ret i64 %93
}

; Function Attrs: nounwind uwtable
define internal i64 @stringlib_default_rfind(ptr noundef %s, i64 noundef %n, ptr noundef %p, i64 noundef %m, i64 noundef %maxcount, i32 noundef %mode) #0 {
entry:
  %retval = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %p.addr = alloca ptr, align 8
  %m.addr = alloca i64, align 8
  %maxcount.addr = alloca i64, align 8
  %mode.addr = alloca i32, align 4
  %mask = alloca i64, align 8
  %i = alloca i64, align 8
  %j = alloca i64, align 8
  %mlast = alloca i64, align 8
  %skip = alloca i64, align 8
  %w = alloca i64, align 8
  store ptr %s, ptr %s.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %m, ptr %m.addr, align 8
  store i64 %maxcount, ptr %maxcount.addr, align 8
  store i32 %mode, ptr %mode.addr, align 4
  store i64 0, ptr %mask, align 8
  %0 = load i64, ptr %m.addr, align 8
  %sub = sub i64 %0, 1
  store i64 %sub, ptr %mlast, align 8
  %1 = load i64, ptr %m.addr, align 8
  %sub1 = sub i64 %1, 1
  store i64 %sub1, ptr %skip, align 8
  %2 = load i64, ptr %n.addr, align 8
  %3 = load i64, ptr %m.addr, align 8
  %sub2 = sub i64 %2, %3
  store i64 %sub2, ptr %w, align 8
  %4 = load ptr, ptr %p.addr, align 8
  %arrayidx = getelementptr i8, ptr %4, i64 0
  %5 = load i8, ptr %arrayidx, align 1
  %conv = sext i8 %5 to i32
  %and = and i32 %conv, 63
  %sh_prom = zext i32 %and to i64
  %shl = shl i64 1, %sh_prom
  %6 = load i64, ptr %mask, align 8
  %or = or i64 %6, %shl
  store i64 %or, ptr %mask, align 8
  %7 = load i64, ptr %mlast, align 8
  store i64 %7, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i64, ptr %i, align 8
  %cmp = icmp sgt i64 %8, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load ptr, ptr %p.addr, align 8
  %10 = load i64, ptr %i, align 8
  %arrayidx4 = getelementptr i8, ptr %9, i64 %10
  %11 = load i8, ptr %arrayidx4, align 1
  %conv5 = sext i8 %11 to i32
  %and6 = and i32 %conv5, 63
  %sh_prom7 = zext i32 %and6 to i64
  %shl8 = shl i64 1, %sh_prom7
  %12 = load i64, ptr %mask, align 8
  %or9 = or i64 %12, %shl8
  store i64 %or9, ptr %mask, align 8
  %13 = load ptr, ptr %p.addr, align 8
  %14 = load i64, ptr %i, align 8
  %arrayidx10 = getelementptr i8, ptr %13, i64 %14
  %15 = load i8, ptr %arrayidx10, align 1
  %conv11 = sext i8 %15 to i32
  %16 = load ptr, ptr %p.addr, align 8
  %arrayidx12 = getelementptr i8, ptr %16, i64 0
  %17 = load i8, ptr %arrayidx12, align 1
  %conv13 = sext i8 %17 to i32
  %cmp14 = icmp eq i32 %conv11, %conv13
  br i1 %cmp14, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %18 = load i64, ptr %i, align 8
  %sub16 = sub i64 %18, 1
  store i64 %sub16, ptr %skip, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %19 = load i64, ptr %i, align 8
  %dec = add i64 %19, -1
  store i64 %dec, ptr %i, align 8
  br label %for.cond, !llvm.loop !34

for.end:                                          ; preds = %for.cond
  %20 = load i64, ptr %w, align 8
  store i64 %20, ptr %i, align 8
  br label %for.cond17

for.cond17:                                       ; preds = %for.inc76, %for.end
  %21 = load i64, ptr %i, align 8
  %cmp18 = icmp sge i64 %21, 0
  br i1 %cmp18, label %for.body20, label %for.end78

for.body20:                                       ; preds = %for.cond17
  %22 = load ptr, ptr %s.addr, align 8
  %23 = load i64, ptr %i, align 8
  %arrayidx21 = getelementptr i8, ptr %22, i64 %23
  %24 = load i8, ptr %arrayidx21, align 1
  %conv22 = sext i8 %24 to i32
  %25 = load ptr, ptr %p.addr, align 8
  %arrayidx23 = getelementptr i8, ptr %25, i64 0
  %26 = load i8, ptr %arrayidx23, align 1
  %conv24 = sext i8 %26 to i32
  %cmp25 = icmp eq i32 %conv22, %conv24
  br i1 %cmp25, label %if.then27, label %if.else60

if.then27:                                        ; preds = %for.body20
  %27 = load i64, ptr %mlast, align 8
  store i64 %27, ptr %j, align 8
  br label %for.cond28

for.cond28:                                       ; preds = %for.inc40, %if.then27
  %28 = load i64, ptr %j, align 8
  %cmp29 = icmp sgt i64 %28, 0
  br i1 %cmp29, label %for.body31, label %for.end42

for.body31:                                       ; preds = %for.cond28
  %29 = load ptr, ptr %s.addr, align 8
  %30 = load i64, ptr %i, align 8
  %31 = load i64, ptr %j, align 8
  %add = add i64 %30, %31
  %arrayidx32 = getelementptr i8, ptr %29, i64 %add
  %32 = load i8, ptr %arrayidx32, align 1
  %conv33 = sext i8 %32 to i32
  %33 = load ptr, ptr %p.addr, align 8
  %34 = load i64, ptr %j, align 8
  %arrayidx34 = getelementptr i8, ptr %33, i64 %34
  %35 = load i8, ptr %arrayidx34, align 1
  %conv35 = sext i8 %35 to i32
  %cmp36 = icmp ne i32 %conv33, %conv35
  br i1 %cmp36, label %if.then38, label %if.end39

if.then38:                                        ; preds = %for.body31
  br label %for.end42

if.end39:                                         ; preds = %for.body31
  br label %for.inc40

for.inc40:                                        ; preds = %if.end39
  %36 = load i64, ptr %j, align 8
  %dec41 = add i64 %36, -1
  store i64 %dec41, ptr %j, align 8
  br label %for.cond28, !llvm.loop !35

for.end42:                                        ; preds = %if.then38, %for.cond28
  %37 = load i64, ptr %j, align 8
  %cmp43 = icmp eq i64 %37, 0
  br i1 %cmp43, label %if.then45, label %if.end46

if.then45:                                        ; preds = %for.end42
  %38 = load i64, ptr %i, align 8
  store i64 %38, ptr %retval, align 8
  br label %return

if.end46:                                         ; preds = %for.end42
  %39 = load i64, ptr %i, align 8
  %cmp47 = icmp sgt i64 %39, 0
  br i1 %cmp47, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.end46
  %40 = load i64, ptr %mask, align 8
  %41 = load ptr, ptr %s.addr, align 8
  %42 = load i64, ptr %i, align 8
  %sub49 = sub i64 %42, 1
  %arrayidx50 = getelementptr i8, ptr %41, i64 %sub49
  %43 = load i8, ptr %arrayidx50, align 1
  %conv51 = sext i8 %43 to i32
  %and52 = and i32 %conv51, 63
  %sh_prom53 = zext i32 %and52 to i64
  %shl54 = shl i64 1, %sh_prom53
  %and55 = and i64 %40, %shl54
  %tobool = icmp ne i64 %and55, 0
  br i1 %tobool, label %if.else, label %if.then56

if.then56:                                        ; preds = %land.lhs.true
  %44 = load i64, ptr %i, align 8
  %45 = load i64, ptr %m.addr, align 8
  %sub57 = sub i64 %44, %45
  store i64 %sub57, ptr %i, align 8
  br label %if.end59

if.else:                                          ; preds = %land.lhs.true, %if.end46
  %46 = load i64, ptr %i, align 8
  %47 = load i64, ptr %skip, align 8
  %sub58 = sub i64 %46, %47
  store i64 %sub58, ptr %i, align 8
  br label %if.end59

if.end59:                                         ; preds = %if.else, %if.then56
  br label %if.end75

if.else60:                                        ; preds = %for.body20
  %48 = load i64, ptr %i, align 8
  %cmp61 = icmp sgt i64 %48, 0
  br i1 %cmp61, label %land.lhs.true63, label %if.end74

land.lhs.true63:                                  ; preds = %if.else60
  %49 = load i64, ptr %mask, align 8
  %50 = load ptr, ptr %s.addr, align 8
  %51 = load i64, ptr %i, align 8
  %sub64 = sub i64 %51, 1
  %arrayidx65 = getelementptr i8, ptr %50, i64 %sub64
  %52 = load i8, ptr %arrayidx65, align 1
  %conv66 = sext i8 %52 to i32
  %and67 = and i32 %conv66, 63
  %sh_prom68 = zext i32 %and67 to i64
  %shl69 = shl i64 1, %sh_prom68
  %and70 = and i64 %49, %shl69
  %tobool71 = icmp ne i64 %and70, 0
  br i1 %tobool71, label %if.end74, label %if.then72

if.then72:                                        ; preds = %land.lhs.true63
  %53 = load i64, ptr %i, align 8
  %54 = load i64, ptr %m.addr, align 8
  %sub73 = sub i64 %53, %54
  store i64 %sub73, ptr %i, align 8
  br label %if.end74

if.end74:                                         ; preds = %if.then72, %land.lhs.true63, %if.else60
  br label %if.end75

if.end75:                                         ; preds = %if.end74, %if.end59
  br label %for.inc76

for.inc76:                                        ; preds = %if.end75
  %55 = load i64, ptr %i, align 8
  %dec77 = add i64 %55, -1
  store i64 %dec77, ptr %i, align 8
  br label %for.cond17, !llvm.loop !36

for.end78:                                        ; preds = %for.cond17
  store i64 -1, ptr %retval, align 8
  br label %return

return:                                           ; preds = %for.end78, %if.then45
  %56 = load i64, ptr %retval, align 8
  ret i64 %56
}

; Function Attrs: nounwind willreturn memory(read)
declare ptr @memrchr(ptr noundef, i32 noundef, i64 noundef) #3

; Function Attrs: nounwind uwtable
define internal void @stringlib__preprocess(ptr noundef %needle, i64 noundef %len_needle, ptr noundef %p) #0 {
entry:
  %needle.addr = alloca ptr, align 8
  %len_needle.addr = alloca i64, align 8
  %p.addr = alloca ptr, align 8
  %last = alloca i8, align 1
  %i = alloca i64, align 8
  %x = alloca i8, align 1
  %not_found_shift = alloca i64, align 8
  %i41 = alloca i64, align 8
  %i50 = alloca i64, align 8
  %shift = alloca i8, align 1
  store ptr %needle, ptr %needle.addr, align 8
  store i64 %len_needle, ptr %len_needle.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %needle.addr, align 8
  %1 = load ptr, ptr %p.addr, align 8
  %needle1 = getelementptr inbounds %struct.stringlib__pre, ptr %1, i32 0, i32 0
  store ptr %0, ptr %needle1, align 8
  %2 = load i64, ptr %len_needle.addr, align 8
  %3 = load ptr, ptr %p.addr, align 8
  %len_needle2 = getelementptr inbounds %struct.stringlib__pre, ptr %3, i32 0, i32 1
  store i64 %2, ptr %len_needle2, align 8
  %4 = load ptr, ptr %needle.addr, align 8
  %5 = load i64, ptr %len_needle.addr, align 8
  %6 = load ptr, ptr %p.addr, align 8
  %period = getelementptr inbounds %struct.stringlib__pre, ptr %6, i32 0, i32 3
  %call = call i64 @stringlib__factorize(ptr noundef %4, i64 noundef %5, ptr noundef %period)
  %7 = load ptr, ptr %p.addr, align 8
  %cut = getelementptr inbounds %struct.stringlib__pre, ptr %7, i32 0, i32 2
  store i64 %call, ptr %cut, align 8
  %8 = load ptr, ptr %needle.addr, align 8
  %9 = load ptr, ptr %needle.addr, align 8
  %10 = load ptr, ptr %p.addr, align 8
  %period3 = getelementptr inbounds %struct.stringlib__pre, ptr %10, i32 0, i32 3
  %11 = load i64, ptr %period3, align 8
  %add.ptr = getelementptr i8, ptr %9, i64 %11
  %12 = load ptr, ptr %p.addr, align 8
  %cut4 = getelementptr inbounds %struct.stringlib__pre, ptr %12, i32 0, i32 2
  %13 = load i64, ptr %cut4, align 8
  %mul = mul i64 %13, 1
  %call5 = call i32 @memcmp(ptr noundef %8, ptr noundef %add.ptr, i64 noundef %mul) #8
  %cmp = icmp eq i32 0, %call5
  %conv = zext i1 %cmp to i32
  %14 = load ptr, ptr %p.addr, align 8
  %is_periodic = getelementptr inbounds %struct.stringlib__pre, ptr %14, i32 0, i32 5
  store i32 %conv, ptr %is_periodic, align 8
  %15 = load ptr, ptr %p.addr, align 8
  %is_periodic6 = getelementptr inbounds %struct.stringlib__pre, ptr %15, i32 0, i32 5
  %16 = load i32, ptr %is_periodic6, align 8
  %tobool = icmp ne i32 %16, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %17 = load ptr, ptr %p.addr, align 8
  %gap = getelementptr inbounds %struct.stringlib__pre, ptr %17, i32 0, i32 4
  store i64 0, ptr %gap, align 8
  br label %if.end34

if.else:                                          ; preds = %entry
  %18 = load ptr, ptr %p.addr, align 8
  %cut7 = getelementptr inbounds %struct.stringlib__pre, ptr %18, i32 0, i32 2
  %19 = load i64, ptr %cut7, align 8
  %20 = load i64, ptr %len_needle.addr, align 8
  %21 = load ptr, ptr %p.addr, align 8
  %cut8 = getelementptr inbounds %struct.stringlib__pre, ptr %21, i32 0, i32 2
  %22 = load i64, ptr %cut8, align 8
  %sub = sub i64 %20, %22
  %cmp9 = icmp sgt i64 %19, %sub
  br i1 %cmp9, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.else
  %23 = load ptr, ptr %p.addr, align 8
  %cut11 = getelementptr inbounds %struct.stringlib__pre, ptr %23, i32 0, i32 2
  %24 = load i64, ptr %cut11, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.else
  %25 = load i64, ptr %len_needle.addr, align 8
  %26 = load ptr, ptr %p.addr, align 8
  %cut12 = getelementptr inbounds %struct.stringlib__pre, ptr %26, i32 0, i32 2
  %27 = load i64, ptr %cut12, align 8
  %sub13 = sub i64 %25, %27
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %24, %cond.true ], [ %sub13, %cond.false ]
  %add = add i64 %cond, 1
  %28 = load ptr, ptr %p.addr, align 8
  %period14 = getelementptr inbounds %struct.stringlib__pre, ptr %28, i32 0, i32 3
  store i64 %add, ptr %period14, align 8
  %29 = load i64, ptr %len_needle.addr, align 8
  %30 = load ptr, ptr %p.addr, align 8
  %gap15 = getelementptr inbounds %struct.stringlib__pre, ptr %30, i32 0, i32 4
  store i64 %29, ptr %gap15, align 8
  %31 = load ptr, ptr %needle.addr, align 8
  %32 = load i64, ptr %len_needle.addr, align 8
  %sub16 = sub i64 %32, 1
  %arrayidx = getelementptr i8, ptr %31, i64 %sub16
  %33 = load i8, ptr %arrayidx, align 1
  %conv17 = sext i8 %33 to i32
  %and = and i32 %conv17, 63
  %conv18 = trunc i32 %and to i8
  store i8 %conv18, ptr %last, align 1
  %34 = load i64, ptr %len_needle.addr, align 8
  %sub19 = sub i64 %34, 2
  store i64 %sub19, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %35 = load i64, ptr %i, align 8
  %cmp20 = icmp sge i64 %35, 0
  br i1 %cmp20, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %36 = load ptr, ptr %needle.addr, align 8
  %37 = load i64, ptr %i, align 8
  %arrayidx22 = getelementptr i8, ptr %36, i64 %37
  %38 = load i8, ptr %arrayidx22, align 1
  %conv23 = sext i8 %38 to i32
  %and24 = and i32 %conv23, 63
  %conv25 = trunc i32 %and24 to i8
  store i8 %conv25, ptr %x, align 1
  %39 = load i8, ptr %x, align 1
  %conv26 = sext i8 %39 to i32
  %40 = load i8, ptr %last, align 1
  %conv27 = sext i8 %40 to i32
  %cmp28 = icmp eq i32 %conv26, %conv27
  br i1 %cmp28, label %if.then30, label %if.end

if.then30:                                        ; preds = %for.body
  %41 = load i64, ptr %len_needle.addr, align 8
  %sub31 = sub i64 %41, 1
  %42 = load i64, ptr %i, align 8
  %sub32 = sub i64 %sub31, %42
  %43 = load ptr, ptr %p.addr, align 8
  %gap33 = getelementptr inbounds %struct.stringlib__pre, ptr %43, i32 0, i32 4
  store i64 %sub32, ptr %gap33, align 8
  br label %for.end

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %44 = load i64, ptr %i, align 8
  %dec = add i64 %44, -1
  store i64 %dec, ptr %i, align 8
  br label %for.cond, !llvm.loop !37

for.end:                                          ; preds = %if.then30, %for.cond
  br label %if.end34

if.end34:                                         ; preds = %for.end, %if.then
  %45 = load i64, ptr %len_needle.addr, align 8
  %cmp35 = icmp sgt i64 %45, 255
  br i1 %cmp35, label %cond.true37, label %cond.false38

cond.true37:                                      ; preds = %if.end34
  br label %cond.end39

cond.false38:                                     ; preds = %if.end34
  %46 = load i64, ptr %len_needle.addr, align 8
  br label %cond.end39

cond.end39:                                       ; preds = %cond.false38, %cond.true37
  %cond40 = phi i64 [ 255, %cond.true37 ], [ %46, %cond.false38 ]
  store i64 %cond40, ptr %not_found_shift, align 8
  store i64 0, ptr %i41, align 8
  br label %for.cond42

for.cond42:                                       ; preds = %for.inc48, %cond.end39
  %47 = load i64, ptr %i41, align 8
  %cmp43 = icmp slt i64 %47, 64
  br i1 %cmp43, label %for.body45, label %for.end49

for.body45:                                       ; preds = %for.cond42
  %48 = load i64, ptr %not_found_shift, align 8
  %conv46 = trunc i64 %48 to i8
  %49 = load ptr, ptr %p.addr, align 8
  %table = getelementptr inbounds %struct.stringlib__pre, ptr %49, i32 0, i32 6
  %50 = load i64, ptr %i41, align 8
  %arrayidx47 = getelementptr [64 x i8], ptr %table, i64 0, i64 %50
  store i8 %conv46, ptr %arrayidx47, align 1
  br label %for.inc48

for.inc48:                                        ; preds = %for.body45
  %51 = load i64, ptr %i41, align 8
  %inc = add i64 %51, 1
  store i64 %inc, ptr %i41, align 8
  br label %for.cond42, !llvm.loop !38

for.end49:                                        ; preds = %for.cond42
  %52 = load i64, ptr %len_needle.addr, align 8
  %53 = load i64, ptr %not_found_shift, align 8
  %sub51 = sub i64 %52, %53
  store i64 %sub51, ptr %i50, align 8
  br label %for.cond52

for.cond52:                                       ; preds = %for.inc64, %for.end49
  %54 = load i64, ptr %i50, align 8
  %55 = load i64, ptr %len_needle.addr, align 8
  %cmp53 = icmp slt i64 %54, %55
  br i1 %cmp53, label %for.body55, label %for.end66

for.body55:                                       ; preds = %for.cond52
  %56 = load i64, ptr %len_needle.addr, align 8
  %sub56 = sub i64 %56, 1
  %57 = load i64, ptr %i50, align 8
  %sub57 = sub i64 %sub56, %57
  %conv58 = trunc i64 %sub57 to i8
  store i8 %conv58, ptr %shift, align 1
  %58 = load i8, ptr %shift, align 1
  %59 = load ptr, ptr %p.addr, align 8
  %table59 = getelementptr inbounds %struct.stringlib__pre, ptr %59, i32 0, i32 6
  %60 = load ptr, ptr %needle.addr, align 8
  %61 = load i64, ptr %i50, align 8
  %arrayidx60 = getelementptr i8, ptr %60, i64 %61
  %62 = load i8, ptr %arrayidx60, align 1
  %conv61 = sext i8 %62 to i32
  %and62 = and i32 %conv61, 63
  %idxprom = zext i32 %and62 to i64
  %arrayidx63 = getelementptr [64 x i8], ptr %table59, i64 0, i64 %idxprom
  store i8 %58, ptr %arrayidx63, align 1
  br label %for.inc64

for.inc64:                                        ; preds = %for.body55
  %63 = load i64, ptr %i50, align 8
  %inc65 = add i64 %63, 1
  store i64 %inc65, ptr %i50, align 8
  br label %for.cond52, !llvm.loop !39

for.end66:                                        ; preds = %for.cond52
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @stringlib__two_way(ptr noundef %haystack, i64 noundef %len_haystack, ptr noundef %p) #0 {
entry:
  %retval = alloca i64, align 8
  %haystack.addr = alloca ptr, align 8
  %len_haystack.addr = alloca i64, align 8
  %p.addr = alloca ptr, align 8
  %len_needle = alloca i64, align 8
  %cut = alloca i64, align 8
  %period = alloca i64, align 8
  %needle = alloca ptr, align 8
  %window_last = alloca ptr, align 8
  %haystack_end = alloca ptr, align 8
  %table = alloca ptr, align 8
  %window = alloca ptr, align 8
  %memory = alloca i64, align 8
  %shift = alloca i64, align 8
  %i = alloca i64, align 8
  %shift51 = alloca i64, align 8
  %mem_jump = alloca i64, align 8
  %gap = alloca i64, align 8
  %gap_jump_end = alloca i64, align 8
  %shift99 = alloca i64, align 8
  %i118 = alloca i64, align 8
  %i135 = alloca i64, align 8
  %i154 = alloca i64, align 8
  store ptr %haystack, ptr %haystack.addr, align 8
  store i64 %len_haystack, ptr %len_haystack.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %len_needle1 = getelementptr inbounds %struct.stringlib__pre, ptr %0, i32 0, i32 1
  %1 = load i64, ptr %len_needle1, align 8
  store i64 %1, ptr %len_needle, align 8
  %2 = load ptr, ptr %p.addr, align 8
  %cut2 = getelementptr inbounds %struct.stringlib__pre, ptr %2, i32 0, i32 2
  %3 = load i64, ptr %cut2, align 8
  store i64 %3, ptr %cut, align 8
  %4 = load ptr, ptr %p.addr, align 8
  %period3 = getelementptr inbounds %struct.stringlib__pre, ptr %4, i32 0, i32 3
  %5 = load i64, ptr %period3, align 8
  store i64 %5, ptr %period, align 8
  %6 = load ptr, ptr %p.addr, align 8
  %needle4 = getelementptr inbounds %struct.stringlib__pre, ptr %6, i32 0, i32 0
  %7 = load ptr, ptr %needle4, align 8
  store ptr %7, ptr %needle, align 8
  %8 = load ptr, ptr %haystack.addr, align 8
  %9 = load i64, ptr %len_needle, align 8
  %add.ptr = getelementptr i8, ptr %8, i64 %9
  %add.ptr5 = getelementptr i8, ptr %add.ptr, i64 -1
  store ptr %add.ptr5, ptr %window_last, align 8
  %10 = load ptr, ptr %haystack.addr, align 8
  %11 = load i64, ptr %len_haystack.addr, align 8
  %add.ptr6 = getelementptr i8, ptr %10, i64 %11
  store ptr %add.ptr6, ptr %haystack_end, align 8
  %12 = load ptr, ptr %p.addr, align 8
  %table7 = getelementptr inbounds %struct.stringlib__pre, ptr %12, i32 0, i32 6
  %arraydecay = getelementptr inbounds [64 x i8], ptr %table7, i64 0, i64 0
  store ptr %arraydecay, ptr %table, align 8
  %13 = load ptr, ptr %p.addr, align 8
  %is_periodic = getelementptr inbounds %struct.stringlib__pre, ptr %13, i32 0, i32 5
  %14 = load i32, ptr %is_periodic, align 8
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i64 0, ptr %memory, align 8
  br label %periodicwindowloop

periodicwindowloop:                               ; preds = %cond.end71, %if.then30, %if.then
  br label %while.cond

while.cond:                                       ; preds = %periodicwindowloop
  %15 = load ptr, ptr %window_last, align 8
  %16 = load ptr, ptr %haystack_end, align 8
  %cmp = icmp ult ptr %15, %16
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  br label %for.cond

for.cond:                                         ; preds = %if.end16, %while.body
  %17 = load ptr, ptr %table, align 8
  %18 = load ptr, ptr %window_last, align 8
  %19 = load i8, ptr %18, align 1
  %conv = sext i8 %19 to i32
  %and = and i32 %conv, 63
  %idxprom = zext i32 %and to i64
  %arrayidx = getelementptr i8, ptr %17, i64 %idxprom
  %20 = load i8, ptr %arrayidx, align 1
  %conv8 = zext i8 %20 to i64
  store i64 %conv8, ptr %shift, align 8
  %21 = load i64, ptr %shift, align 8
  %22 = load ptr, ptr %window_last, align 8
  %add.ptr9 = getelementptr i8, ptr %22, i64 %21
  store ptr %add.ptr9, ptr %window_last, align 8
  %23 = load i64, ptr %shift, align 8
  %cmp10 = icmp eq i64 %23, 0
  br i1 %cmp10, label %if.then12, label %if.end

if.then12:                                        ; preds = %for.cond
  br label %for.end

if.end:                                           ; preds = %for.cond
  %24 = load ptr, ptr %window_last, align 8
  %25 = load ptr, ptr %haystack_end, align 8
  %cmp13 = icmp uge ptr %24, %25
  br i1 %cmp13, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.end
  store i64 -1, ptr %retval, align 8
  br label %return

if.end16:                                         ; preds = %if.end
  br label %for.cond

for.end:                                          ; preds = %if.then12
  br label %no_shift

no_shift:                                         ; preds = %if.end74, %for.end
  %26 = load ptr, ptr %window_last, align 8
  %27 = load i64, ptr %len_needle, align 8
  %idx.neg = sub i64 0, %27
  %add.ptr17 = getelementptr i8, ptr %26, i64 %idx.neg
  %add.ptr18 = getelementptr i8, ptr %add.ptr17, i64 1
  store ptr %add.ptr18, ptr %window, align 8
  %28 = load i64, ptr %cut, align 8
  %29 = load i64, ptr %memory, align 8
  %cmp19 = icmp sgt i64 %28, %29
  br i1 %cmp19, label %cond.true, label %cond.false

cond.true:                                        ; preds = %no_shift
  %30 = load i64, ptr %cut, align 8
  br label %cond.end

cond.false:                                       ; preds = %no_shift
  %31 = load i64, ptr %memory, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %30, %cond.true ], [ %31, %cond.false ]
  store i64 %cond, ptr %i, align 8
  br label %for.cond21

for.cond21:                                       ; preds = %for.inc, %cond.end
  %32 = load i64, ptr %i, align 8
  %33 = load i64, ptr %len_needle, align 8
  %cmp22 = icmp slt i64 %32, %33
  br i1 %cmp22, label %for.body, label %for.end33

for.body:                                         ; preds = %for.cond21
  %34 = load ptr, ptr %needle, align 8
  %35 = load i64, ptr %i, align 8
  %arrayidx24 = getelementptr i8, ptr %34, i64 %35
  %36 = load i8, ptr %arrayidx24, align 1
  %conv25 = sext i8 %36 to i32
  %37 = load ptr, ptr %window, align 8
  %38 = load i64, ptr %i, align 8
  %arrayidx26 = getelementptr i8, ptr %37, i64 %38
  %39 = load i8, ptr %arrayidx26, align 1
  %conv27 = sext i8 %39 to i32
  %cmp28 = icmp ne i32 %conv25, %conv27
  br i1 %cmp28, label %if.then30, label %if.end32

if.then30:                                        ; preds = %for.body
  %40 = load i64, ptr %i, align 8
  %41 = load i64, ptr %cut, align 8
  %sub = sub i64 %40, %41
  %add = add i64 %sub, 1
  %42 = load ptr, ptr %window_last, align 8
  %add.ptr31 = getelementptr i8, ptr %42, i64 %add
  store ptr %add.ptr31, ptr %window_last, align 8
  store i64 0, ptr %memory, align 8
  br label %periodicwindowloop

if.end32:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end32
  %43 = load i64, ptr %i, align 8
  %inc = add i64 %43, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond21, !llvm.loop !40

for.end33:                                        ; preds = %for.cond21
  %44 = load i64, ptr %memory, align 8
  store i64 %44, ptr %i, align 8
  br label %for.cond34

for.cond34:                                       ; preds = %for.inc76, %for.end33
  %45 = load i64, ptr %i, align 8
  %46 = load i64, ptr %cut, align 8
  %cmp35 = icmp slt i64 %45, %46
  br i1 %cmp35, label %for.body37, label %for.end78

for.body37:                                       ; preds = %for.cond34
  %47 = load ptr, ptr %needle, align 8
  %48 = load i64, ptr %i, align 8
  %arrayidx38 = getelementptr i8, ptr %47, i64 %48
  %49 = load i8, ptr %arrayidx38, align 1
  %conv39 = sext i8 %49 to i32
  %50 = load ptr, ptr %window, align 8
  %51 = load i64, ptr %i, align 8
  %arrayidx40 = getelementptr i8, ptr %50, i64 %51
  %52 = load i8, ptr %arrayidx40, align 1
  %conv41 = sext i8 %52 to i32
  %cmp42 = icmp ne i32 %conv39, %conv41
  br i1 %cmp42, label %if.then44, label %if.end75

if.then44:                                        ; preds = %for.body37
  %53 = load i64, ptr %period, align 8
  %54 = load ptr, ptr %window_last, align 8
  %add.ptr45 = getelementptr i8, ptr %54, i64 %53
  store ptr %add.ptr45, ptr %window_last, align 8
  %55 = load i64, ptr %len_needle, align 8
  %56 = load i64, ptr %period, align 8
  %sub46 = sub i64 %55, %56
  store i64 %sub46, ptr %memory, align 8
  %57 = load ptr, ptr %window_last, align 8
  %58 = load ptr, ptr %haystack_end, align 8
  %cmp47 = icmp uge ptr %57, %58
  br i1 %cmp47, label %if.then49, label %if.end50

if.then49:                                        ; preds = %if.then44
  store i64 -1, ptr %retval, align 8
  br label %return

if.end50:                                         ; preds = %if.then44
  %59 = load ptr, ptr %table, align 8
  %60 = load ptr, ptr %window_last, align 8
  %61 = load i8, ptr %60, align 1
  %conv52 = sext i8 %61 to i32
  %and53 = and i32 %conv52, 63
  %idxprom54 = zext i32 %and53 to i64
  %arrayidx55 = getelementptr i8, ptr %59, i64 %idxprom54
  %62 = load i8, ptr %arrayidx55, align 1
  %conv56 = zext i8 %62 to i64
  store i64 %conv56, ptr %shift51, align 8
  %63 = load i64, ptr %shift51, align 8
  %tobool57 = icmp ne i64 %63, 0
  br i1 %tobool57, label %if.then58, label %if.end74

if.then58:                                        ; preds = %if.end50
  %64 = load i64, ptr %cut, align 8
  %65 = load i64, ptr %memory, align 8
  %cmp59 = icmp sgt i64 %64, %65
  br i1 %cmp59, label %cond.true61, label %cond.false62

cond.true61:                                      ; preds = %if.then58
  %66 = load i64, ptr %cut, align 8
  br label %cond.end63

cond.false62:                                     ; preds = %if.then58
  %67 = load i64, ptr %memory, align 8
  br label %cond.end63

cond.end63:                                       ; preds = %cond.false62, %cond.true61
  %cond64 = phi i64 [ %66, %cond.true61 ], [ %67, %cond.false62 ]
  %68 = load i64, ptr %cut, align 8
  %sub65 = sub i64 %cond64, %68
  %add66 = add i64 %sub65, 1
  store i64 %add66, ptr %mem_jump, align 8
  store i64 0, ptr %memory, align 8
  %69 = load i64, ptr %shift51, align 8
  %70 = load i64, ptr %mem_jump, align 8
  %cmp67 = icmp sgt i64 %69, %70
  br i1 %cmp67, label %cond.true69, label %cond.false70

cond.true69:                                      ; preds = %cond.end63
  %71 = load i64, ptr %shift51, align 8
  br label %cond.end71

cond.false70:                                     ; preds = %cond.end63
  %72 = load i64, ptr %mem_jump, align 8
  br label %cond.end71

cond.end71:                                       ; preds = %cond.false70, %cond.true69
  %cond72 = phi i64 [ %71, %cond.true69 ], [ %72, %cond.false70 ]
  %73 = load ptr, ptr %window_last, align 8
  %add.ptr73 = getelementptr i8, ptr %73, i64 %cond72
  store ptr %add.ptr73, ptr %window_last, align 8
  br label %periodicwindowloop

if.end74:                                         ; preds = %if.end50
  br label %no_shift

if.end75:                                         ; preds = %for.body37
  br label %for.inc76

for.inc76:                                        ; preds = %if.end75
  %74 = load i64, ptr %i, align 8
  %inc77 = add i64 %74, 1
  store i64 %inc77, ptr %i, align 8
  br label %for.cond34, !llvm.loop !41

for.end78:                                        ; preds = %for.cond34
  %75 = load ptr, ptr %window, align 8
  %76 = load ptr, ptr %haystack.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %75 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %76 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, ptr %retval, align 8
  br label %return

while.end:                                        ; preds = %while.cond
  br label %if.end175

if.else:                                          ; preds = %entry
  %77 = load ptr, ptr %p.addr, align 8
  %gap79 = getelementptr inbounds %struct.stringlib__pre, ptr %77, i32 0, i32 4
  %78 = load i64, ptr %gap79, align 8
  store i64 %78, ptr %gap, align 8
  %79 = load i64, ptr %gap, align 8
  %80 = load i64, ptr %period, align 8
  %cmp80 = icmp sgt i64 %79, %80
  br i1 %cmp80, label %cond.true82, label %cond.false83

cond.true82:                                      ; preds = %if.else
  %81 = load i64, ptr %gap, align 8
  br label %cond.end84

cond.false83:                                     ; preds = %if.else
  %82 = load i64, ptr %period, align 8
  br label %cond.end84

cond.end84:                                       ; preds = %cond.false83, %cond.true82
  %cond85 = phi i64 [ %81, %cond.true82 ], [ %82, %cond.false83 ]
  store i64 %cond85, ptr %period, align 8
  %83 = load i64, ptr %len_needle, align 8
  %84 = load i64, ptr %cut, align 8
  %85 = load i64, ptr %gap, align 8
  %add86 = add i64 %84, %85
  %cmp87 = icmp sgt i64 %83, %add86
  br i1 %cmp87, label %cond.true89, label %cond.false91

cond.true89:                                      ; preds = %cond.end84
  %86 = load i64, ptr %cut, align 8
  %87 = load i64, ptr %gap, align 8
  %add90 = add i64 %86, %87
  br label %cond.end92

cond.false91:                                     ; preds = %cond.end84
  %88 = load i64, ptr %len_needle, align 8
  br label %cond.end92

cond.end92:                                       ; preds = %cond.false91, %cond.true89
  %cond93 = phi i64 [ %add90, %cond.true89 ], [ %88, %cond.false91 ]
  store i64 %cond93, ptr %gap_jump_end, align 8
  br label %windowloop

windowloop:                                       ; preds = %if.then165, %if.then146, %if.then129, %cond.end92
  br label %while.cond94

while.cond94:                                     ; preds = %windowloop
  %89 = load ptr, ptr %window_last, align 8
  %90 = load ptr, ptr %haystack_end, align 8
  %cmp95 = icmp ult ptr %89, %90
  br i1 %cmp95, label %while.body97, label %while.end174

while.body97:                                     ; preds = %while.cond94
  br label %for.cond98

for.cond98:                                       ; preds = %if.end113, %while.body97
  %91 = load ptr, ptr %table, align 8
  %92 = load ptr, ptr %window_last, align 8
  %93 = load i8, ptr %92, align 1
  %conv100 = sext i8 %93 to i32
  %and101 = and i32 %conv100, 63
  %idxprom102 = zext i32 %and101 to i64
  %arrayidx103 = getelementptr i8, ptr %91, i64 %idxprom102
  %94 = load i8, ptr %arrayidx103, align 1
  %conv104 = zext i8 %94 to i64
  store i64 %conv104, ptr %shift99, align 8
  %95 = load i64, ptr %shift99, align 8
  %96 = load ptr, ptr %window_last, align 8
  %add.ptr105 = getelementptr i8, ptr %96, i64 %95
  store ptr %add.ptr105, ptr %window_last, align 8
  %97 = load i64, ptr %shift99, align 8
  %cmp106 = icmp eq i64 %97, 0
  br i1 %cmp106, label %if.then108, label %if.end109

if.then108:                                       ; preds = %for.cond98
  br label %for.end114

if.end109:                                        ; preds = %for.cond98
  %98 = load ptr, ptr %window_last, align 8
  %99 = load ptr, ptr %haystack_end, align 8
  %cmp110 = icmp uge ptr %98, %99
  br i1 %cmp110, label %if.then112, label %if.end113

if.then112:                                       ; preds = %if.end109
  store i64 -1, ptr %retval, align 8
  br label %return

if.end113:                                        ; preds = %if.end109
  br label %for.cond98

for.end114:                                       ; preds = %if.then108
  %100 = load ptr, ptr %window_last, align 8
  %101 = load i64, ptr %len_needle, align 8
  %idx.neg115 = sub i64 0, %101
  %add.ptr116 = getelementptr i8, ptr %100, i64 %idx.neg115
  %add.ptr117 = getelementptr i8, ptr %add.ptr116, i64 1
  store ptr %add.ptr117, ptr %window, align 8
  %102 = load i64, ptr %cut, align 8
  store i64 %102, ptr %i118, align 8
  br label %for.cond119

for.cond119:                                      ; preds = %for.inc132, %for.end114
  %103 = load i64, ptr %i118, align 8
  %104 = load i64, ptr %gap_jump_end, align 8
  %cmp120 = icmp slt i64 %103, %104
  br i1 %cmp120, label %for.body122, label %for.end134

for.body122:                                      ; preds = %for.cond119
  %105 = load ptr, ptr %needle, align 8
  %106 = load i64, ptr %i118, align 8
  %arrayidx123 = getelementptr i8, ptr %105, i64 %106
  %107 = load i8, ptr %arrayidx123, align 1
  %conv124 = sext i8 %107 to i32
  %108 = load ptr, ptr %window, align 8
  %109 = load i64, ptr %i118, align 8
  %arrayidx125 = getelementptr i8, ptr %108, i64 %109
  %110 = load i8, ptr %arrayidx125, align 1
  %conv126 = sext i8 %110 to i32
  %cmp127 = icmp ne i32 %conv124, %conv126
  br i1 %cmp127, label %if.then129, label %if.end131

if.then129:                                       ; preds = %for.body122
  %111 = load i64, ptr %gap, align 8
  %112 = load ptr, ptr %window_last, align 8
  %add.ptr130 = getelementptr i8, ptr %112, i64 %111
  store ptr %add.ptr130, ptr %window_last, align 8
  br label %windowloop

if.end131:                                        ; preds = %for.body122
  br label %for.inc132

for.inc132:                                       ; preds = %if.end131
  %113 = load i64, ptr %i118, align 8
  %inc133 = add i64 %113, 1
  store i64 %inc133, ptr %i118, align 8
  br label %for.cond119, !llvm.loop !42

for.end134:                                       ; preds = %for.cond119
  %114 = load i64, ptr %gap_jump_end, align 8
  store i64 %114, ptr %i135, align 8
  br label %for.cond136

for.cond136:                                      ; preds = %for.inc151, %for.end134
  %115 = load i64, ptr %i135, align 8
  %116 = load i64, ptr %len_needle, align 8
  %cmp137 = icmp slt i64 %115, %116
  br i1 %cmp137, label %for.body139, label %for.end153

for.body139:                                      ; preds = %for.cond136
  %117 = load ptr, ptr %needle, align 8
  %118 = load i64, ptr %i135, align 8
  %arrayidx140 = getelementptr i8, ptr %117, i64 %118
  %119 = load i8, ptr %arrayidx140, align 1
  %conv141 = sext i8 %119 to i32
  %120 = load ptr, ptr %window, align 8
  %121 = load i64, ptr %i135, align 8
  %arrayidx142 = getelementptr i8, ptr %120, i64 %121
  %122 = load i8, ptr %arrayidx142, align 1
  %conv143 = sext i8 %122 to i32
  %cmp144 = icmp ne i32 %conv141, %conv143
  br i1 %cmp144, label %if.then146, label %if.end150

if.then146:                                       ; preds = %for.body139
  %123 = load i64, ptr %i135, align 8
  %124 = load i64, ptr %cut, align 8
  %sub147 = sub i64 %123, %124
  %add148 = add i64 %sub147, 1
  %125 = load ptr, ptr %window_last, align 8
  %add.ptr149 = getelementptr i8, ptr %125, i64 %add148
  store ptr %add.ptr149, ptr %window_last, align 8
  br label %windowloop

if.end150:                                        ; preds = %for.body139
  br label %for.inc151

for.inc151:                                       ; preds = %if.end150
  %126 = load i64, ptr %i135, align 8
  %inc152 = add i64 %126, 1
  store i64 %inc152, ptr %i135, align 8
  br label %for.cond136, !llvm.loop !43

for.end153:                                       ; preds = %for.cond136
  store i64 0, ptr %i154, align 8
  br label %for.cond155

for.cond155:                                      ; preds = %for.inc168, %for.end153
  %127 = load i64, ptr %i154, align 8
  %128 = load i64, ptr %cut, align 8
  %cmp156 = icmp slt i64 %127, %128
  br i1 %cmp156, label %for.body158, label %for.end170

for.body158:                                      ; preds = %for.cond155
  %129 = load ptr, ptr %needle, align 8
  %130 = load i64, ptr %i154, align 8
  %arrayidx159 = getelementptr i8, ptr %129, i64 %130
  %131 = load i8, ptr %arrayidx159, align 1
  %conv160 = sext i8 %131 to i32
  %132 = load ptr, ptr %window, align 8
  %133 = load i64, ptr %i154, align 8
  %arrayidx161 = getelementptr i8, ptr %132, i64 %133
  %134 = load i8, ptr %arrayidx161, align 1
  %conv162 = sext i8 %134 to i32
  %cmp163 = icmp ne i32 %conv160, %conv162
  br i1 %cmp163, label %if.then165, label %if.end167

if.then165:                                       ; preds = %for.body158
  %135 = load i64, ptr %period, align 8
  %136 = load ptr, ptr %window_last, align 8
  %add.ptr166 = getelementptr i8, ptr %136, i64 %135
  store ptr %add.ptr166, ptr %window_last, align 8
  br label %windowloop

if.end167:                                        ; preds = %for.body158
  br label %for.inc168

for.inc168:                                       ; preds = %if.end167
  %137 = load i64, ptr %i154, align 8
  %inc169 = add i64 %137, 1
  store i64 %inc169, ptr %i154, align 8
  br label %for.cond155, !llvm.loop !44

for.end170:                                       ; preds = %for.cond155
  %138 = load ptr, ptr %window, align 8
  %139 = load ptr, ptr %haystack.addr, align 8
  %sub.ptr.lhs.cast171 = ptrtoint ptr %138 to i64
  %sub.ptr.rhs.cast172 = ptrtoint ptr %139 to i64
  %sub.ptr.sub173 = sub i64 %sub.ptr.lhs.cast171, %sub.ptr.rhs.cast172
  store i64 %sub.ptr.sub173, ptr %retval, align 8
  br label %return

while.end174:                                     ; preds = %while.cond94
  br label %if.end175

if.end175:                                        ; preds = %while.end174, %while.end
  store i64 -1, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end175, %for.end170, %if.then112, %for.end78, %if.then49, %if.then15
  %140 = load i64, ptr %retval, align 8
  ret i64 %140
}

; Function Attrs: nounwind uwtable
define internal i64 @stringlib__factorize(ptr noundef %needle, i64 noundef %len_needle, ptr noundef %return_period) #0 {
entry:
  %needle.addr = alloca ptr, align 8
  %len_needle.addr = alloca i64, align 8
  %return_period.addr = alloca ptr, align 8
  %cut1 = alloca i64, align 8
  %period1 = alloca i64, align 8
  %cut2 = alloca i64, align 8
  %period2 = alloca i64, align 8
  %cut = alloca i64, align 8
  %period = alloca i64, align 8
  store ptr %needle, ptr %needle.addr, align 8
  store i64 %len_needle, ptr %len_needle.addr, align 8
  store ptr %return_period, ptr %return_period.addr, align 8
  %0 = load ptr, ptr %needle.addr, align 8
  %1 = load i64, ptr %len_needle.addr, align 8
  %call = call i64 @stringlib__lex_search(ptr noundef %0, i64 noundef %1, ptr noundef %period1, i32 noundef 0)
  store i64 %call, ptr %cut1, align 8
  %2 = load ptr, ptr %needle.addr, align 8
  %3 = load i64, ptr %len_needle.addr, align 8
  %call1 = call i64 @stringlib__lex_search(ptr noundef %2, i64 noundef %3, ptr noundef %period2, i32 noundef 1)
  store i64 %call1, ptr %cut2, align 8
  %4 = load i64, ptr %cut1, align 8
  %5 = load i64, ptr %cut2, align 8
  %cmp = icmp sgt i64 %4, %5
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %6 = load i64, ptr %period1, align 8
  store i64 %6, ptr %period, align 8
  %7 = load i64, ptr %cut1, align 8
  store i64 %7, ptr %cut, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %8 = load i64, ptr %period2, align 8
  store i64 %8, ptr %period, align 8
  %9 = load i64, ptr %cut2, align 8
  store i64 %9, ptr %cut, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %10 = load i64, ptr %period, align 8
  %11 = load ptr, ptr %return_period.addr, align 8
  store i64 %10, ptr %11, align 8
  %12 = load i64, ptr %cut, align 8
  ret i64 %12
}

; Function Attrs: nounwind uwtable
define internal i64 @stringlib__lex_search(ptr noundef %needle, i64 noundef %len_needle, ptr noundef %return_period, i32 noundef %invert_alphabet) #0 {
entry:
  %needle.addr = alloca ptr, align 8
  %len_needle.addr = alloca i64, align 8
  %return_period.addr = alloca ptr, align 8
  %invert_alphabet.addr = alloca i32, align 4
  %max_suffix = alloca i64, align 8
  %candidate = alloca i64, align 8
  %k = alloca i64, align 8
  %period = alloca i64, align 8
  %a = alloca i8, align 1
  %b = alloca i8, align 1
  store ptr %needle, ptr %needle.addr, align 8
  store i64 %len_needle, ptr %len_needle.addr, align 8
  store ptr %return_period, ptr %return_period.addr, align 8
  store i32 %invert_alphabet, ptr %invert_alphabet.addr, align 4
  store i64 0, ptr %max_suffix, align 8
  store i64 1, ptr %candidate, align 8
  store i64 0, ptr %k, align 8
  store i64 1, ptr %period, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end27, %entry
  %0 = load i64, ptr %candidate, align 8
  %1 = load i64, ptr %k, align 8
  %add = add i64 %0, %1
  %2 = load i64, ptr %len_needle.addr, align 8
  %cmp = icmp slt i64 %add, %2
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load ptr, ptr %needle.addr, align 8
  %4 = load i64, ptr %candidate, align 8
  %5 = load i64, ptr %k, align 8
  %add1 = add i64 %4, %5
  %arrayidx = getelementptr i8, ptr %3, i64 %add1
  %6 = load i8, ptr %arrayidx, align 1
  store i8 %6, ptr %a, align 1
  %7 = load ptr, ptr %needle.addr, align 8
  %8 = load i64, ptr %max_suffix, align 8
  %9 = load i64, ptr %k, align 8
  %add2 = add i64 %8, %9
  %arrayidx3 = getelementptr i8, ptr %7, i64 %add2
  %10 = load i8, ptr %arrayidx3, align 1
  store i8 %10, ptr %b, align 1
  %11 = load i32, ptr %invert_alphabet.addr, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %while.body
  %12 = load i8, ptr %b, align 1
  %conv = sext i8 %12 to i32
  %13 = load i8, ptr %a, align 1
  %conv4 = sext i8 %13 to i32
  %cmp5 = icmp slt i32 %conv, %conv4
  br i1 %cmp5, label %if.then, label %if.else

cond.false:                                       ; preds = %while.body
  %14 = load i8, ptr %a, align 1
  %conv7 = sext i8 %14 to i32
  %15 = load i8, ptr %b, align 1
  %conv8 = sext i8 %15 to i32
  %cmp9 = icmp slt i32 %conv7, %conv8
  br i1 %cmp9, label %if.then, label %if.else

if.then:                                          ; preds = %cond.false, %cond.true
  %16 = load i64, ptr %k, align 8
  %add11 = add i64 %16, 1
  %17 = load i64, ptr %candidate, align 8
  %add12 = add i64 %17, %add11
  store i64 %add12, ptr %candidate, align 8
  store i64 0, ptr %k, align 8
  %18 = load i64, ptr %candidate, align 8
  %19 = load i64, ptr %max_suffix, align 8
  %sub = sub i64 %18, %19
  store i64 %sub, ptr %period, align 8
  br label %if.end27

if.else:                                          ; preds = %cond.false, %cond.true
  %20 = load i8, ptr %a, align 1
  %conv13 = sext i8 %20 to i32
  %21 = load i8, ptr %b, align 1
  %conv14 = sext i8 %21 to i32
  %cmp15 = icmp eq i32 %conv13, %conv14
  br i1 %cmp15, label %if.then17, label %if.else24

if.then17:                                        ; preds = %if.else
  %22 = load i64, ptr %k, align 8
  %add18 = add i64 %22, 1
  %23 = load i64, ptr %period, align 8
  %cmp19 = icmp ne i64 %add18, %23
  br i1 %cmp19, label %if.then21, label %if.else22

if.then21:                                        ; preds = %if.then17
  %24 = load i64, ptr %k, align 8
  %inc = add i64 %24, 1
  store i64 %inc, ptr %k, align 8
  br label %if.end

if.else22:                                        ; preds = %if.then17
  %25 = load i64, ptr %period, align 8
  %26 = load i64, ptr %candidate, align 8
  %add23 = add i64 %26, %25
  store i64 %add23, ptr %candidate, align 8
  store i64 0, ptr %k, align 8
  br label %if.end

if.end:                                           ; preds = %if.else22, %if.then21
  br label %if.end26

if.else24:                                        ; preds = %if.else
  %27 = load i64, ptr %candidate, align 8
  store i64 %27, ptr %max_suffix, align 8
  %28 = load i64, ptr %candidate, align 8
  %inc25 = add i64 %28, 1
  store i64 %inc25, ptr %candidate, align 8
  store i64 0, ptr %k, align 8
  store i64 1, ptr %period, align 8
  br label %if.end26

if.end26:                                         ; preds = %if.else24, %if.end
  br label %if.end27

if.end27:                                         ; preds = %if.end26, %if.then
  br label %while.cond, !llvm.loop !45

while.end:                                        ; preds = %while.cond
  %29 = load i64, ptr %period, align 8
  %30 = load ptr, ptr %return_period.addr, align 8
  store i64 %29, ptr %30, align 8
  %31 = load i64, ptr %max_suffix, align 8
  ret i64 %31
}

; Function Attrs: nounwind uwtable
define internal ptr @stringlib_bytes_join(ptr noundef %sep, ptr noundef %iterable) #0 {
entry:
  %op.addr.i194 = alloca ptr, align 8
  %op.addr.i190 = alloca ptr, align 8
  %op.addr.i186 = alloca ptr, align 8
  %op.addr.i184 = alloca ptr, align 8
  %op.addr.i180 = alloca ptr, align 8
  %cur_refcnt.i = alloca i32, align 4
  %new_refcnt.i = alloca i32, align 4
  %op.addr.i171 = alloca ptr, align 8
  %op.addr.i162 = alloca ptr, align 8
  %op.addr.i153 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %sep.addr = alloca ptr, align 8
  %iterable.addr = alloca ptr, align 8
  %sepstr = alloca ptr, align 8
  %seplen = alloca i64, align 8
  %res = alloca ptr, align 8
  %p = alloca ptr, align 8
  %seqlen = alloca i64, align 8
  %sz = alloca i64, align 8
  %i = alloca i64, align 8
  %nbufs = alloca i64, align 8
  %seq = alloca ptr, align 8
  %item = alloca ptr, align 8
  %buffers = alloca ptr, align 8
  %static_buffers = alloca [10 x %struct.Py_buffer], align 16
  %drop_gil = alloca i32, align 4
  %save = alloca ptr, align 8
  %itemlen = alloca i64, align 8
  %n = alloca i64, align 8
  %q = alloca ptr, align 8
  %n124 = alloca i64, align 8
  %q125 = alloca ptr, align 8
  store ptr %sep, ptr %sep.addr, align 8
  store ptr %iterable, ptr %iterable.addr, align 8
  %0 = load ptr, ptr %sep.addr, align 8
  %call = call ptr @PyBytes_AS_STRING(ptr noundef %0)
  store ptr %call, ptr %sepstr, align 8
  %1 = load ptr, ptr %sep.addr, align 8
  %call1 = call i64 @PyBytes_GET_SIZE(ptr noundef %1)
  store i64 %call1, ptr %seplen, align 8
  store ptr null, ptr %res, align 8
  store i64 0, ptr %seqlen, align 8
  store i64 0, ptr %sz, align 8
  store ptr null, ptr %buffers, align 8
  store i32 1, ptr %drop_gil, align 4
  store ptr null, ptr %save, align 8
  %2 = load ptr, ptr %iterable.addr, align 8
  %call2 = call ptr @PySequence_Fast(ptr noundef %2, ptr noundef @.str.47)
  store ptr %call2, ptr %seq, align 8
  %3 = load ptr, ptr %seq, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %seq, align 8
  %call3 = call ptr @Py_TYPE(ptr noundef %4)
  %call4 = call i32 @PyType_HasFeature(ptr noundef %call3, i64 noundef 33554432)
  %tobool = icmp ne i32 %call4, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %5 = load ptr, ptr %seq, align 8
  %call5 = call i64 @PyList_GET_SIZE(ptr noundef %5)
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %6 = load ptr, ptr %seq, align 8
  %call6 = call i64 @PyTuple_GET_SIZE(ptr noundef %6)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call5, %cond.true ], [ %call6, %cond.false ]
  store i64 %cond, ptr %seqlen, align 8
  %7 = load i64, ptr %seqlen, align 8
  %cmp7 = icmp eq i64 %7, 0
  br i1 %cmp7, label %if.then8, label %if.end10

if.then8:                                         ; preds = %cond.end
  %8 = load ptr, ptr %seq, align 8
  store ptr %8, ptr %op.addr.i171, align 8
  %9 = load ptr, ptr %op.addr.i171, align 8
  store ptr %9, ptr %op.addr.i184, align 8
  %10 = load ptr, ptr %op.addr.i184, align 8
  %11 = load i64, ptr %10, align 8
  %conv.i = trunc i64 %11 to i32
  %cmp.i185 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i185 to i32
  %tobool.i173 = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i173, label %if.then.i178, label %if.end.i174

if.then.i178:                                     ; preds = %if.then8
  br label %Py_DECREF.exit179

if.end.i174:                                      ; preds = %if.then8
  %12 = load ptr, ptr %op.addr.i171, align 8
  %13 = load i64, ptr %12, align 8
  %dec.i175 = add i64 %13, -1
  store i64 %dec.i175, ptr %12, align 8
  %cmp.i176 = icmp eq i64 %dec.i175, 0
  br i1 %cmp.i176, label %if.then1.i177, label %Py_DECREF.exit179

if.then1.i177:                                    ; preds = %if.end.i174
  %14 = load ptr, ptr %op.addr.i171, align 8
  call void @_Py_Dealloc(ptr noundef %14) #9
  br label %Py_DECREF.exit179

Py_DECREF.exit179:                                ; preds = %if.then1.i177, %if.end.i174, %if.then.i178
  %call9 = call ptr @PyBytes_FromStringAndSize(ptr noundef null, i64 noundef 0)
  store ptr %call9, ptr %retval, align 8
  br label %return

if.end10:                                         ; preds = %cond.end
  %15 = load i64, ptr %seqlen, align 8
  %cmp11 = icmp eq i64 %15, 1
  br i1 %cmp11, label %if.then12, label %if.end26

if.then12:                                        ; preds = %if.end10
  %16 = load ptr, ptr %seq, align 8
  %call13 = call ptr @Py_TYPE(ptr noundef %16)
  %call14 = call i32 @PyType_HasFeature(ptr noundef %call13, i64 noundef 33554432)
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %cond.true16, label %cond.false17

cond.true16:                                      ; preds = %if.then12
  %17 = load ptr, ptr %seq, align 8
  %ob_item = getelementptr inbounds %struct.PyListObject, ptr %17, i32 0, i32 1
  %18 = load ptr, ptr %ob_item, align 8
  %arrayidx = getelementptr ptr, ptr %18, i64 0
  %19 = load ptr, ptr %arrayidx, align 8
  br label %cond.end20

cond.false17:                                     ; preds = %if.then12
  %20 = load ptr, ptr %seq, align 8
  %ob_item18 = getelementptr inbounds %struct.PyTupleObject, ptr %20, i32 0, i32 1
  %arrayidx19 = getelementptr [1 x ptr], ptr %ob_item18, i64 0, i64 0
  %21 = load ptr, ptr %arrayidx19, align 8
  br label %cond.end20

cond.end20:                                       ; preds = %cond.false17, %cond.true16
  %cond21 = phi ptr [ %19, %cond.true16 ], [ %21, %cond.false17 ]
  store ptr %cond21, ptr %item, align 8
  %22 = load ptr, ptr %item, align 8
  %call22 = call i32 @Py_IS_TYPE(ptr noundef %22, ptr noundef @PyBytes_Type)
  %tobool23 = icmp ne i32 %call22, 0
  br i1 %tobool23, label %if.then24, label %if.end25

if.then24:                                        ; preds = %cond.end20
  %23 = load ptr, ptr %item, align 8
  store ptr %23, ptr %op.addr.i180, align 8
  %24 = load ptr, ptr %op.addr.i180, align 8
  %25 = load i32, ptr %24, align 8
  store i32 %25, ptr %cur_refcnt.i, align 4
  %26 = load i32, ptr %cur_refcnt.i, align 4
  %add.i = add i32 %26, 1
  store i32 %add.i, ptr %new_refcnt.i, align 4
  %27 = load i32, ptr %new_refcnt.i, align 4
  %cmp.i181 = icmp eq i32 %27, 0
  br i1 %cmp.i181, label %if.then.i183, label %if.end.i182

if.then.i183:                                     ; preds = %if.then24
  br label %Py_INCREF.exit

if.end.i182:                                      ; preds = %if.then24
  %28 = load i32, ptr %new_refcnt.i, align 4
  %29 = load ptr, ptr %op.addr.i180, align 8
  store i32 %28, ptr %29, align 8
  br label %Py_INCREF.exit

Py_INCREF.exit:                                   ; preds = %if.end.i182, %if.then.i183
  %30 = load ptr, ptr %seq, align 8
  store ptr %30, ptr %op.addr.i162, align 8
  %31 = load ptr, ptr %op.addr.i162, align 8
  store ptr %31, ptr %op.addr.i186, align 8
  %32 = load ptr, ptr %op.addr.i186, align 8
  %33 = load i64, ptr %32, align 8
  %conv.i187 = trunc i64 %33 to i32
  %cmp.i188 = icmp slt i32 %conv.i187, 0
  %conv1.i189 = zext i1 %cmp.i188 to i32
  %tobool.i164 = icmp ne i32 %conv1.i189, 0
  br i1 %tobool.i164, label %if.then.i169, label %if.end.i165

if.then.i169:                                     ; preds = %Py_INCREF.exit
  br label %Py_DECREF.exit170

if.end.i165:                                      ; preds = %Py_INCREF.exit
  %34 = load ptr, ptr %op.addr.i162, align 8
  %35 = load i64, ptr %34, align 8
  %dec.i166 = add i64 %35, -1
  store i64 %dec.i166, ptr %34, align 8
  %cmp.i167 = icmp eq i64 %dec.i166, 0
  br i1 %cmp.i167, label %if.then1.i168, label %Py_DECREF.exit170

if.then1.i168:                                    ; preds = %if.end.i165
  %36 = load ptr, ptr %op.addr.i162, align 8
  call void @_Py_Dealloc(ptr noundef %36) #9
  br label %Py_DECREF.exit170

Py_DECREF.exit170:                                ; preds = %if.then1.i168, %if.end.i165, %if.then.i169
  %37 = load ptr, ptr %item, align 8
  store ptr %37, ptr %retval, align 8
  br label %return

if.end25:                                         ; preds = %cond.end20
  br label %if.end26

if.end26:                                         ; preds = %if.end25, %if.end10
  %38 = load i64, ptr %seqlen, align 8
  %cmp27 = icmp sgt i64 %38, 10
  br i1 %cmp27, label %if.then28, label %if.else

if.then28:                                        ; preds = %if.end26
  %39 = load i64, ptr %seqlen, align 8
  %cmp29 = icmp ugt i64 %39, 115292150460684697
  br i1 %cmp29, label %cond.true30, label %cond.false31

cond.true30:                                      ; preds = %if.then28
  br label %cond.end33

cond.false31:                                     ; preds = %if.then28
  %40 = load i64, ptr %seqlen, align 8
  %mul = mul i64 %40, 80
  %call32 = call ptr @PyMem_Malloc(i64 noundef %mul)
  br label %cond.end33

cond.end33:                                       ; preds = %cond.false31, %cond.true30
  %cond34 = phi ptr [ null, %cond.true30 ], [ %call32, %cond.false31 ]
  store ptr %cond34, ptr %buffers, align 8
  %41 = load ptr, ptr %buffers, align 8
  %cmp35 = icmp eq ptr %41, null
  br i1 %cmp35, label %if.then36, label %if.end38

if.then36:                                        ; preds = %cond.end33
  %42 = load ptr, ptr %seq, align 8
  store ptr %42, ptr %op.addr.i153, align 8
  %43 = load ptr, ptr %op.addr.i153, align 8
  store ptr %43, ptr %op.addr.i190, align 8
  %44 = load ptr, ptr %op.addr.i190, align 8
  %45 = load i64, ptr %44, align 8
  %conv.i191 = trunc i64 %45 to i32
  %cmp.i192 = icmp slt i32 %conv.i191, 0
  %conv1.i193 = zext i1 %cmp.i192 to i32
  %tobool.i155 = icmp ne i32 %conv1.i193, 0
  br i1 %tobool.i155, label %if.then.i160, label %if.end.i156

if.then.i160:                                     ; preds = %if.then36
  br label %Py_DECREF.exit161

if.end.i156:                                      ; preds = %if.then36
  %46 = load ptr, ptr %op.addr.i153, align 8
  %47 = load i64, ptr %46, align 8
  %dec.i157 = add i64 %47, -1
  store i64 %dec.i157, ptr %46, align 8
  %cmp.i158 = icmp eq i64 %dec.i157, 0
  br i1 %cmp.i158, label %if.then1.i159, label %Py_DECREF.exit161

if.then1.i159:                                    ; preds = %if.end.i156
  %48 = load ptr, ptr %op.addr.i153, align 8
  call void @_Py_Dealloc(ptr noundef %48) #9
  br label %Py_DECREF.exit161

Py_DECREF.exit161:                                ; preds = %if.then1.i159, %if.end.i156, %if.then.i160
  %call37 = call ptr @PyErr_NoMemory()
  store ptr null, ptr %retval, align 8
  br label %return

if.end38:                                         ; preds = %cond.end33
  br label %if.end39

if.else:                                          ; preds = %if.end26
  %arraydecay = getelementptr inbounds [10 x %struct.Py_buffer], ptr %static_buffers, i64 0, i64 0
  store ptr %arraydecay, ptr %buffers, align 8
  br label %if.end39

if.end39:                                         ; preds = %if.else, %if.end38
  store i64 0, ptr %i, align 8
  store i64 0, ptr %nbufs, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end39
  %49 = load i64, ptr %i, align 8
  %50 = load i64, ptr %seqlen, align 8
  %cmp40 = icmp slt i64 %49, %50
  br i1 %cmp40, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %51 = load ptr, ptr %seq, align 8
  %call41 = call ptr @Py_TYPE(ptr noundef %51)
  %call42 = call i32 @PyType_HasFeature(ptr noundef %call41, i64 noundef 33554432)
  %tobool43 = icmp ne i32 %call42, 0
  br i1 %tobool43, label %cond.true44, label %cond.false47

cond.true44:                                      ; preds = %for.body
  %52 = load ptr, ptr %seq, align 8
  %ob_item45 = getelementptr inbounds %struct.PyListObject, ptr %52, i32 0, i32 1
  %53 = load ptr, ptr %ob_item45, align 8
  %54 = load i64, ptr %i, align 8
  %arrayidx46 = getelementptr ptr, ptr %53, i64 %54
  %55 = load ptr, ptr %arrayidx46, align 8
  br label %cond.end50

cond.false47:                                     ; preds = %for.body
  %56 = load ptr, ptr %seq, align 8
  %ob_item48 = getelementptr inbounds %struct.PyTupleObject, ptr %56, i32 0, i32 1
  %57 = load i64, ptr %i, align 8
  %arrayidx49 = getelementptr [1 x ptr], ptr %ob_item48, i64 0, i64 %57
  %58 = load ptr, ptr %arrayidx49, align 8
  br label %cond.end50

cond.end50:                                       ; preds = %cond.false47, %cond.true44
  %cond51 = phi ptr [ %55, %cond.true44 ], [ %58, %cond.false47 ]
  store ptr %cond51, ptr %item, align 8
  %59 = load ptr, ptr %item, align 8
  %call52 = call i32 @Py_IS_TYPE(ptr noundef %59, ptr noundef @PyBytes_Type)
  %tobool53 = icmp ne i32 %call52, 0
  br i1 %tobool53, label %if.then54, label %if.else61

if.then54:                                        ; preds = %cond.end50
  %60 = load ptr, ptr %item, align 8
  %call55 = call ptr @_Py_NewRef(ptr noundef %60)
  %61 = load ptr, ptr %buffers, align 8
  %62 = load i64, ptr %i, align 8
  %arrayidx56 = getelementptr %struct.Py_buffer, ptr %61, i64 %62
  %obj = getelementptr inbounds %struct.Py_buffer, ptr %arrayidx56, i32 0, i32 1
  store ptr %call55, ptr %obj, align 8
  %63 = load ptr, ptr %item, align 8
  %call57 = call ptr @PyBytes_AS_STRING(ptr noundef %63)
  %64 = load ptr, ptr %buffers, align 8
  %65 = load i64, ptr %i, align 8
  %arrayidx58 = getelementptr %struct.Py_buffer, ptr %64, i64 %65
  %buf = getelementptr inbounds %struct.Py_buffer, ptr %arrayidx58, i32 0, i32 0
  store ptr %call57, ptr %buf, align 8
  %66 = load ptr, ptr %item, align 8
  %call59 = call i64 @PyBytes_GET_SIZE(ptr noundef %66)
  %67 = load ptr, ptr %buffers, align 8
  %68 = load i64, ptr %i, align 8
  %arrayidx60 = getelementptr %struct.Py_buffer, ptr %67, i64 %68
  %len = getelementptr inbounds %struct.Py_buffer, ptr %arrayidx60, i32 0, i32 2
  store i64 %call59, ptr %len, align 8
  br label %if.end69

if.else61:                                        ; preds = %cond.end50
  %69 = load ptr, ptr %item, align 8
  %70 = load ptr, ptr %buffers, align 8
  %71 = load i64, ptr %i, align 8
  %arrayidx62 = getelementptr %struct.Py_buffer, ptr %70, i64 %71
  %call63 = call i32 @PyObject_GetBuffer(ptr noundef %69, ptr noundef %arrayidx62, i32 noundef 0)
  %cmp64 = icmp ne i32 %call63, 0
  br i1 %cmp64, label %if.then65, label %if.end68

if.then65:                                        ; preds = %if.else61
  %72 = load ptr, ptr @PyExc_TypeError, align 8
  %73 = load i64, ptr %i, align 8
  %74 = load ptr, ptr %item, align 8
  %call66 = call ptr @Py_TYPE(ptr noundef %74)
  %tp_name = getelementptr inbounds %struct._typeobject, ptr %call66, i32 0, i32 1
  %75 = load ptr, ptr %tp_name, align 8
  %call67 = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %72, ptr noundef @.str.48, i64 noundef %73, ptr noundef %75)
  br label %error

if.end68:                                         ; preds = %if.else61
  store i32 0, ptr %drop_gil, align 4
  br label %if.end69

if.end69:                                         ; preds = %if.end68, %if.then54
  %76 = load i64, ptr %i, align 8
  %add = add i64 %76, 1
  store i64 %add, ptr %nbufs, align 8
  %77 = load ptr, ptr %buffers, align 8
  %78 = load i64, ptr %i, align 8
  %arrayidx70 = getelementptr %struct.Py_buffer, ptr %77, i64 %78
  %len71 = getelementptr inbounds %struct.Py_buffer, ptr %arrayidx70, i32 0, i32 2
  %79 = load i64, ptr %len71, align 8
  store i64 %79, ptr %itemlen, align 8
  %80 = load i64, ptr %itemlen, align 8
  %81 = load i64, ptr %sz, align 8
  %sub = sub i64 9223372036854775807, %81
  %cmp72 = icmp sgt i64 %80, %sub
  br i1 %cmp72, label %if.then73, label %if.end74

if.then73:                                        ; preds = %if.end69
  %82 = load ptr, ptr @PyExc_OverflowError, align 8
  call void @PyErr_SetString(ptr noundef %82, ptr noundef @.str.49)
  br label %error

if.end74:                                         ; preds = %if.end69
  %83 = load i64, ptr %itemlen, align 8
  %84 = load i64, ptr %sz, align 8
  %add75 = add i64 %84, %83
  store i64 %add75, ptr %sz, align 8
  %85 = load i64, ptr %i, align 8
  %cmp76 = icmp ne i64 %85, 0
  br i1 %cmp76, label %if.then77, label %if.end83

if.then77:                                        ; preds = %if.end74
  %86 = load i64, ptr %seplen, align 8
  %87 = load i64, ptr %sz, align 8
  %sub78 = sub i64 9223372036854775807, %87
  %cmp79 = icmp sgt i64 %86, %sub78
  br i1 %cmp79, label %if.then80, label %if.end81

if.then80:                                        ; preds = %if.then77
  %88 = load ptr, ptr @PyExc_OverflowError, align 8
  call void @PyErr_SetString(ptr noundef %88, ptr noundef @.str.49)
  br label %error

if.end81:                                         ; preds = %if.then77
  %89 = load i64, ptr %seplen, align 8
  %90 = load i64, ptr %sz, align 8
  %add82 = add i64 %90, %89
  store i64 %add82, ptr %sz, align 8
  br label %if.end83

if.end83:                                         ; preds = %if.end81, %if.end74
  %91 = load i64, ptr %seqlen, align 8
  %92 = load ptr, ptr %seq, align 8
  %call84 = call ptr @Py_TYPE(ptr noundef %92)
  %call85 = call i32 @PyType_HasFeature(ptr noundef %call84, i64 noundef 33554432)
  %tobool86 = icmp ne i32 %call85, 0
  br i1 %tobool86, label %cond.true87, label %cond.false89

cond.true87:                                      ; preds = %if.end83
  %93 = load ptr, ptr %seq, align 8
  %call88 = call i64 @PyList_GET_SIZE(ptr noundef %93)
  br label %cond.end91

cond.false89:                                     ; preds = %if.end83
  %94 = load ptr, ptr %seq, align 8
  %call90 = call i64 @PyTuple_GET_SIZE(ptr noundef %94)
  br label %cond.end91

cond.end91:                                       ; preds = %cond.false89, %cond.true87
  %cond92 = phi i64 [ %call88, %cond.true87 ], [ %call90, %cond.false89 ]
  %cmp93 = icmp ne i64 %91, %cond92
  br i1 %cmp93, label %if.then94, label %if.end95

if.then94:                                        ; preds = %cond.end91
  %95 = load ptr, ptr @PyExc_RuntimeError, align 8
  call void @PyErr_SetString(ptr noundef %95, ptr noundef @.str.50)
  br label %error

if.end95:                                         ; preds = %cond.end91
  br label %for.inc

for.inc:                                          ; preds = %if.end95
  %96 = load i64, ptr %i, align 8
  %inc = add i64 %96, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !46

for.end:                                          ; preds = %for.cond
  %97 = load i64, ptr %sz, align 8
  %call96 = call ptr @PyBytes_FromStringAndSize(ptr noundef null, i64 noundef %97)
  store ptr %call96, ptr %res, align 8
  %98 = load ptr, ptr %res, align 8
  %cmp97 = icmp eq ptr %98, null
  br i1 %cmp97, label %if.then98, label %if.end99

if.then98:                                        ; preds = %for.end
  br label %error

if.end99:                                         ; preds = %for.end
  %99 = load ptr, ptr %res, align 8
  %call100 = call ptr @PyBytes_AS_STRING(ptr noundef %99)
  store ptr %call100, ptr %p, align 8
  %100 = load i64, ptr %sz, align 8
  %cmp101 = icmp slt i64 %100, 1048576
  br i1 %cmp101, label %if.then102, label %if.end103

if.then102:                                       ; preds = %if.end99
  store i32 0, ptr %drop_gil, align 4
  br label %if.end103

if.end103:                                        ; preds = %if.then102, %if.end99
  %101 = load i32, ptr %drop_gil, align 4
  %tobool104 = icmp ne i32 %101, 0
  br i1 %tobool104, label %if.then105, label %if.end107

if.then105:                                       ; preds = %if.end103
  %call106 = call ptr @PyEval_SaveThread()
  store ptr %call106, ptr %save, align 8
  br label %if.end107

if.end107:                                        ; preds = %if.then105, %if.end103
  %102 = load i64, ptr %seplen, align 8
  %tobool108 = icmp ne i64 %102, 0
  br i1 %tobool108, label %if.else120, label %if.then109

if.then109:                                       ; preds = %if.end107
  store i64 0, ptr %i, align 8
  br label %for.cond110

for.cond110:                                      ; preds = %for.inc117, %if.then109
  %103 = load i64, ptr %i, align 8
  %104 = load i64, ptr %nbufs, align 8
  %cmp111 = icmp slt i64 %103, %104
  br i1 %cmp111, label %for.body112, label %for.end119

for.body112:                                      ; preds = %for.cond110
  %105 = load ptr, ptr %buffers, align 8
  %106 = load i64, ptr %i, align 8
  %arrayidx113 = getelementptr %struct.Py_buffer, ptr %105, i64 %106
  %len114 = getelementptr inbounds %struct.Py_buffer, ptr %arrayidx113, i32 0, i32 2
  %107 = load i64, ptr %len114, align 8
  store i64 %107, ptr %n, align 8
  %108 = load ptr, ptr %buffers, align 8
  %109 = load i64, ptr %i, align 8
  %arrayidx115 = getelementptr %struct.Py_buffer, ptr %108, i64 %109
  %buf116 = getelementptr inbounds %struct.Py_buffer, ptr %arrayidx115, i32 0, i32 0
  %110 = load ptr, ptr %buf116, align 8
  store ptr %110, ptr %q, align 8
  %111 = load ptr, ptr %p, align 8
  %112 = load ptr, ptr %q, align 8
  %113 = load i64, ptr %n, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %111, ptr align 1 %112, i64 %113, i1 false)
  %114 = load i64, ptr %n, align 8
  %115 = load ptr, ptr %p, align 8
  %add.ptr = getelementptr i8, ptr %115, i64 %114
  store ptr %add.ptr, ptr %p, align 8
  br label %for.inc117

for.inc117:                                       ; preds = %for.body112
  %116 = load i64, ptr %i, align 8
  %inc118 = add i64 %116, 1
  store i64 %inc118, ptr %i, align 8
  br label %for.cond110, !llvm.loop !47

for.end119:                                       ; preds = %for.cond110
  br label %if.end138

if.else120:                                       ; preds = %if.end107
  store i64 0, ptr %i, align 8
  br label %for.cond121

for.cond121:                                      ; preds = %for.inc135, %if.else120
  %117 = load i64, ptr %i, align 8
  %118 = load i64, ptr %nbufs, align 8
  %cmp122 = icmp slt i64 %117, %118
  br i1 %cmp122, label %for.body123, label %for.end137

for.body123:                                      ; preds = %for.cond121
  %119 = load i64, ptr %i, align 8
  %tobool126 = icmp ne i64 %119, 0
  br i1 %tobool126, label %if.then127, label %if.end129

if.then127:                                       ; preds = %for.body123
  %120 = load ptr, ptr %p, align 8
  %121 = load ptr, ptr %sepstr, align 8
  %122 = load i64, ptr %seplen, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %120, ptr align 1 %121, i64 %122, i1 false)
  %123 = load i64, ptr %seplen, align 8
  %124 = load ptr, ptr %p, align 8
  %add.ptr128 = getelementptr i8, ptr %124, i64 %123
  store ptr %add.ptr128, ptr %p, align 8
  br label %if.end129

if.end129:                                        ; preds = %if.then127, %for.body123
  %125 = load ptr, ptr %buffers, align 8
  %126 = load i64, ptr %i, align 8
  %arrayidx130 = getelementptr %struct.Py_buffer, ptr %125, i64 %126
  %len131 = getelementptr inbounds %struct.Py_buffer, ptr %arrayidx130, i32 0, i32 2
  %127 = load i64, ptr %len131, align 8
  store i64 %127, ptr %n124, align 8
  %128 = load ptr, ptr %buffers, align 8
  %129 = load i64, ptr %i, align 8
  %arrayidx132 = getelementptr %struct.Py_buffer, ptr %128, i64 %129
  %buf133 = getelementptr inbounds %struct.Py_buffer, ptr %arrayidx132, i32 0, i32 0
  %130 = load ptr, ptr %buf133, align 8
  store ptr %130, ptr %q125, align 8
  %131 = load ptr, ptr %p, align 8
  %132 = load ptr, ptr %q125, align 8
  %133 = load i64, ptr %n124, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %131, ptr align 1 %132, i64 %133, i1 false)
  %134 = load i64, ptr %n124, align 8
  %135 = load ptr, ptr %p, align 8
  %add.ptr134 = getelementptr i8, ptr %135, i64 %134
  store ptr %add.ptr134, ptr %p, align 8
  br label %for.inc135

for.inc135:                                       ; preds = %if.end129
  %136 = load i64, ptr %i, align 8
  %inc136 = add i64 %136, 1
  store i64 %inc136, ptr %i, align 8
  br label %for.cond121, !llvm.loop !48

for.end137:                                       ; preds = %for.cond121
  br label %if.end138

if.end138:                                        ; preds = %for.end137, %for.end119
  %137 = load i32, ptr %drop_gil, align 4
  %tobool139 = icmp ne i32 %137, 0
  br i1 %tobool139, label %if.then140, label %if.end141

if.then140:                                       ; preds = %if.end138
  %138 = load ptr, ptr %save, align 8
  call void @PyEval_RestoreThread(ptr noundef %138)
  br label %if.end141

if.end141:                                        ; preds = %if.then140, %if.end138
  br label %done

error:                                            ; preds = %if.then98, %if.then94, %if.then80, %if.then73, %if.then65
  store ptr null, ptr %res, align 8
  br label %done

done:                                             ; preds = %error, %if.end141
  %139 = load ptr, ptr %seq, align 8
  store ptr %139, ptr %op.addr.i, align 8
  %140 = load ptr, ptr %op.addr.i, align 8
  store ptr %140, ptr %op.addr.i194, align 8
  %141 = load ptr, ptr %op.addr.i194, align 8
  %142 = load i64, ptr %141, align 8
  %conv.i195 = trunc i64 %142 to i32
  %cmp.i196 = icmp slt i32 %conv.i195, 0
  %conv1.i197 = zext i1 %cmp.i196 to i32
  %tobool.i = icmp ne i32 %conv1.i197, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %done
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %done
  %143 = load ptr, ptr %op.addr.i, align 8
  %144 = load i64, ptr %143, align 8
  %dec.i = add i64 %144, -1
  store i64 %dec.i, ptr %143, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %145 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %145) #9
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  store i64 0, ptr %i, align 8
  br label %for.cond142

for.cond142:                                      ; preds = %for.inc146, %Py_DECREF.exit
  %146 = load i64, ptr %i, align 8
  %147 = load i64, ptr %nbufs, align 8
  %cmp143 = icmp slt i64 %146, %147
  br i1 %cmp143, label %for.body144, label %for.end148

for.body144:                                      ; preds = %for.cond142
  %148 = load ptr, ptr %buffers, align 8
  %149 = load i64, ptr %i, align 8
  %arrayidx145 = getelementptr %struct.Py_buffer, ptr %148, i64 %149
  call void @PyBuffer_Release(ptr noundef %arrayidx145)
  br label %for.inc146

for.inc146:                                       ; preds = %for.body144
  %150 = load i64, ptr %i, align 8
  %inc147 = add i64 %150, 1
  store i64 %inc147, ptr %i, align 8
  br label %for.cond142, !llvm.loop !49

for.end148:                                       ; preds = %for.cond142
  %151 = load ptr, ptr %buffers, align 8
  %arraydecay149 = getelementptr inbounds [10 x %struct.Py_buffer], ptr %static_buffers, i64 0, i64 0
  %cmp150 = icmp ne ptr %151, %arraydecay149
  br i1 %cmp150, label %if.then151, label %if.end152

if.then151:                                       ; preds = %for.end148
  %152 = load ptr, ptr %buffers, align 8
  call void @PyMem_Free(ptr noundef %152)
  br label %if.end152

if.end152:                                        ; preds = %if.then151, %for.end148
  %153 = load ptr, ptr %res, align 8
  store ptr %153, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end152, %Py_DECREF.exit161, %Py_DECREF.exit170, %Py_DECREF.exit179, %if.then
  %154 = load ptr, ptr %retval, align 8
  ret ptr %154
}

declare ptr @PySequence_Fast(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal i64 @PyList_GET_SIZE(ptr noundef %op) #0 {
entry:
  %op.addr = alloca ptr, align 8
  %list = alloca ptr, align 8
  store ptr %op, ptr %op.addr, align 8
  %0 = load ptr, ptr %op.addr, align 8
  store ptr %0, ptr %list, align 8
  %1 = load ptr, ptr %list, align 8
  %call = call i64 @Py_SIZE(ptr noundef %1)
  ret i64 %call
}

declare ptr @PyMem_Malloc(i64 noundef) #1

declare ptr @PyEval_SaveThread() #1

declare void @PyEval_RestoreThread(ptr noundef) #1

declare i32 @PyBuffer_ToContiguous(ptr noundef, ptr noundef, i64 noundef, i8 noundef signext) #1

declare i64 @PyNumber_AsSsize_t(ptr noundef, ptr noundef) #1

declare i64 @PyObject_LengthHint(ptr noundef, i64 noundef) #1

declare ptr @PyIter_Next(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @bytes_mod(ptr noundef %self, ptr noundef %arg) #0 {
entry:
  %retval = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %call = call ptr @Py_TYPE(ptr noundef %0)
  %call1 = call i32 @PyType_HasFeature(ptr noundef %call, i64 noundef 134217728)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store ptr @_Py_NotImplementedStruct, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %self.addr, align 8
  %call2 = call ptr @PyBytes_AS_STRING(ptr noundef %1)
  %2 = load ptr, ptr %self.addr, align 8
  %call3 = call i64 @PyBytes_GET_SIZE(ptr noundef %2)
  %3 = load ptr, ptr %arg.addr, align 8
  %call4 = call ptr @_PyBytes_FormatEx(ptr noundef %call2, i64 noundef %call3, ptr noundef %3, i32 noundef 0)
  store ptr %call4, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load ptr, ptr %retval, align 8
  ret ptr %4
}

; Function Attrs: nounwind uwtable
define internal i64 @bytes_length(ptr noundef %a) #0 {
entry:
  %a.addr = alloca ptr, align 8
  store ptr %a, ptr %a.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %call = call i64 @Py_SIZE(ptr noundef %0)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define internal ptr @bytes_repeat(ptr noundef %a, i64 noundef %n) #0 {
entry:
  %retval = alloca ptr, align 8
  %a.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %size = alloca i64, align 8
  %op = alloca ptr, align 8
  %nbytes = alloca i64, align 8
  store ptr %a, ptr %a.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %cmp = icmp slt i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 0, ptr %n.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = load i64, ptr %n.addr, align 8
  %cmp1 = icmp sgt i64 %1, 0
  br i1 %cmp1, label %land.lhs.true, label %if.end4

land.lhs.true:                                    ; preds = %if.end
  %2 = load ptr, ptr %a.addr, align 8
  %call = call i64 @Py_SIZE(ptr noundef %2)
  %3 = load i64, ptr %n.addr, align 8
  %div = sdiv i64 9223372036854775807, %3
  %cmp2 = icmp sgt i64 %call, %div
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %land.lhs.true
  %4 = load ptr, ptr @PyExc_OverflowError, align 8
  call void @PyErr_SetString(ptr noundef %4, ptr noundef @.str.52)
  store ptr null, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %land.lhs.true, %if.end
  %5 = load ptr, ptr %a.addr, align 8
  %call5 = call i64 @Py_SIZE(ptr noundef %5)
  %6 = load i64, ptr %n.addr, align 8
  %mul = mul i64 %call5, %6
  store i64 %mul, ptr %size, align 8
  %7 = load i64, ptr %size, align 8
  %8 = load ptr, ptr %a.addr, align 8
  %call6 = call i64 @Py_SIZE(ptr noundef %8)
  %cmp7 = icmp eq i64 %7, %call6
  br i1 %cmp7, label %land.lhs.true8, label %if.end12

land.lhs.true8:                                   ; preds = %if.end4
  %9 = load ptr, ptr %a.addr, align 8
  %call9 = call i32 @Py_IS_TYPE(ptr noundef %9, ptr noundef @PyBytes_Type)
  %tobool = icmp ne i32 %call9, 0
  br i1 %tobool, label %if.then10, label %if.end12

if.then10:                                        ; preds = %land.lhs.true8
  %10 = load ptr, ptr %a.addr, align 8
  %call11 = call ptr @_Py_NewRef(ptr noundef %10)
  store ptr %call11, ptr %retval, align 8
  br label %return

if.end12:                                         ; preds = %land.lhs.true8, %if.end4
  %11 = load i64, ptr %size, align 8
  store i64 %11, ptr %nbytes, align 8
  %12 = load i64, ptr %nbytes, align 8
  %add = add i64 %12, 33
  %13 = load i64, ptr %nbytes, align 8
  %cmp13 = icmp ule i64 %add, %13
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end12
  %14 = load ptr, ptr @PyExc_OverflowError, align 8
  call void @PyErr_SetString(ptr noundef %14, ptr noundef @.str.52)
  store ptr null, ptr %retval, align 8
  br label %return

if.end15:                                         ; preds = %if.end12
  %15 = load i64, ptr %nbytes, align 8
  %add16 = add i64 33, %15
  %call17 = call ptr @PyObject_Malloc(i64 noundef %add16)
  store ptr %call17, ptr %op, align 8
  %16 = load ptr, ptr %op, align 8
  %cmp18 = icmp eq ptr %16, null
  br i1 %cmp18, label %if.then19, label %if.end21

if.then19:                                        ; preds = %if.end15
  %call20 = call ptr @PyErr_NoMemory()
  store ptr %call20, ptr %retval, align 8
  br label %return

if.end21:                                         ; preds = %if.end15
  %17 = load ptr, ptr %op, align 8
  %18 = load i64, ptr %size, align 8
  call void @_PyObject_InitVar(ptr noundef %17, ptr noundef @PyBytes_Type, i64 noundef %18)
  %19 = load ptr, ptr %op, align 8
  %ob_shash = getelementptr inbounds %struct.PyBytesObject, ptr %19, i32 0, i32 1
  store i64 -1, ptr %ob_shash, align 8
  %20 = load ptr, ptr %op, align 8
  %ob_sval = getelementptr inbounds %struct.PyBytesObject, ptr %20, i32 0, i32 2
  %21 = load i64, ptr %size, align 8
  %arrayidx = getelementptr [1 x i8], ptr %ob_sval, i64 0, i64 %21
  store i8 0, ptr %arrayidx, align 1
  %22 = load ptr, ptr %op, align 8
  %ob_sval22 = getelementptr inbounds %struct.PyBytesObject, ptr %22, i32 0, i32 2
  %arraydecay = getelementptr inbounds [1 x i8], ptr %ob_sval22, i64 0, i64 0
  %23 = load i64, ptr %size, align 8
  %24 = load ptr, ptr %a.addr, align 8
  %ob_sval23 = getelementptr inbounds %struct.PyBytesObject, ptr %24, i32 0, i32 2
  %arraydecay24 = getelementptr inbounds [1 x i8], ptr %ob_sval23, i64 0, i64 0
  %25 = load ptr, ptr %a.addr, align 8
  %call25 = call i64 @Py_SIZE(ptr noundef %25)
  call void @_PyBytes_Repeat(ptr noundef %arraydecay, i64 noundef %23, ptr noundef %arraydecay24, i64 noundef %call25)
  %26 = load ptr, ptr %op, align 8
  store ptr %26, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end21, %if.then19, %if.then14, %if.then10, %if.then3
  %27 = load ptr, ptr %retval, align 8
  ret ptr %27
}

; Function Attrs: nounwind uwtable
define internal ptr @bytes_item(ptr noundef %a, i64 noundef %i) #0 {
entry:
  %retval = alloca ptr, align 8
  %a.addr = alloca ptr, align 8
  %i.addr = alloca i64, align 8
  store ptr %a, ptr %a.addr, align 8
  store i64 %i, ptr %i.addr, align 8
  %0 = load i64, ptr %i.addr, align 8
  %cmp = icmp slt i64 %0, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i64, ptr %i.addr, align 8
  %2 = load ptr, ptr %a.addr, align 8
  %call = call i64 @Py_SIZE(ptr noundef %2)
  %cmp1 = icmp sge i64 %1, %call
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %3 = load ptr, ptr @PyExc_IndexError, align 8
  call void @PyErr_SetString(ptr noundef %3, ptr noundef @.str.53)
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %4 = load ptr, ptr %a.addr, align 8
  %ob_sval = getelementptr inbounds %struct.PyBytesObject, ptr %4, i32 0, i32 2
  %5 = load i64, ptr %i.addr, align 8
  %arrayidx = getelementptr [1 x i8], ptr %ob_sval, i64 0, i64 %5
  %6 = load i8, ptr %arrayidx, align 1
  %call2 = call ptr @_PyLong_FromUnsignedChar(i8 noundef zeroext %6)
  store ptr %call2, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load ptr, ptr %retval, align 8
  ret ptr %7
}

; Function Attrs: nounwind uwtable
define internal i32 @bytes_contains(ptr noundef %self, ptr noundef %arg) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %call = call ptr @PyBytes_AS_STRING(ptr noundef %0)
  %1 = load ptr, ptr %self.addr, align 8
  %call1 = call i64 @PyBytes_GET_SIZE(ptr noundef %1)
  %2 = load ptr, ptr %arg.addr, align 8
  %call2 = call i32 @_Py_bytes_contains(ptr noundef %call, i64 noundef %call1, ptr noundef %2)
  ret i32 %call2
}

; Function Attrs: nounwind uwtable
define internal ptr @_PyLong_FromUnsignedChar(i8 noundef zeroext %i) #0 {
entry:
  %i.addr = alloca i8, align 1
  store i8 %i, ptr %i.addr, align 1
  %0 = load i8, ptr %i.addr, align 1
  %conv = zext i8 %0 to i32
  %add = add i32 5, %conv
  %idxprom = sext i32 %add to i64
  %arrayidx = getelementptr [262 x %struct._longobject], ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 37), i64 0, i64 %idxprom
  ret ptr %arrayidx
}

declare i32 @_Py_bytes_contains(ptr noundef, i64 noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @bytes_subscript(ptr noundef %self, ptr noundef %item) #0 {
entry:
  %retval = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  %item.addr = alloca ptr, align 8
  %i = alloca i64, align 8
  %start = alloca i64, align 8
  %stop = alloca i64, align 8
  %step = alloca i64, align 8
  %slicelength = alloca i64, align 8
  %i18 = alloca i64, align 8
  %cur = alloca i64, align 8
  %source_buf = alloca ptr, align 8
  %result_buf = alloca ptr, align 8
  %result = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %item, ptr %item.addr, align 8
  %0 = load ptr, ptr %item.addr, align 8
  %call = call i32 @_PyIndex_Check(ptr noundef %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %item.addr, align 8
  %2 = load ptr, ptr @PyExc_IndexError, align 8
  %call1 = call i64 @PyNumber_AsSsize_t(ptr noundef %1, ptr noundef %2)
  store i64 %call1, ptr %i, align 8
  %3 = load i64, ptr %i, align 8
  %cmp = icmp eq i64 %3, -1
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then
  %call2 = call ptr @PyErr_Occurred()
  %tobool3 = icmp ne ptr %call2, null
  br i1 %tobool3, label %if.then4, label %if.end

if.then4:                                         ; preds = %land.lhs.true
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %land.lhs.true, %if.then
  %4 = load i64, ptr %i, align 8
  %cmp5 = icmp slt i64 %4, 0
  br i1 %cmp5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end
  %5 = load ptr, ptr %self.addr, align 8
  %call7 = call i64 @PyBytes_GET_SIZE(ptr noundef %5)
  %6 = load i64, ptr %i, align 8
  %add = add i64 %6, %call7
  store i64 %add, ptr %i, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %if.end
  %7 = load i64, ptr %i, align 8
  %cmp9 = icmp slt i64 %7, 0
  br i1 %cmp9, label %if.then12, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end8
  %8 = load i64, ptr %i, align 8
  %9 = load ptr, ptr %self.addr, align 8
  %call10 = call i64 @PyBytes_GET_SIZE(ptr noundef %9)
  %cmp11 = icmp sge i64 %8, %call10
  br i1 %cmp11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %lor.lhs.false, %if.end8
  %10 = load ptr, ptr @PyExc_IndexError, align 8
  call void @PyErr_SetString(ptr noundef %10, ptr noundef @.str.53)
  store ptr null, ptr %retval, align 8
  br label %return

if.end13:                                         ; preds = %lor.lhs.false
  %11 = load ptr, ptr %self.addr, align 8
  %ob_sval = getelementptr inbounds %struct.PyBytesObject, ptr %11, i32 0, i32 2
  %12 = load i64, ptr %i, align 8
  %arrayidx = getelementptr [1 x i8], ptr %ob_sval, i64 0, i64 %12
  %13 = load i8, ptr %arrayidx, align 1
  %call14 = call ptr @_PyLong_FromUnsignedChar(i8 noundef zeroext %13)
  store ptr %call14, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %14 = load ptr, ptr %item.addr, align 8
  %call15 = call i32 @Py_IS_TYPE(ptr noundef %14, ptr noundef @PySlice_Type)
  %tobool16 = icmp ne i32 %call15, 0
  br i1 %tobool16, label %if.then17, label %if.else56

if.then17:                                        ; preds = %if.else
  %15 = load ptr, ptr %item.addr, align 8
  %call19 = call i32 @PySlice_Unpack(ptr noundef %15, ptr noundef %start, ptr noundef %stop, ptr noundef %step)
  %cmp20 = icmp slt i32 %call19, 0
  br i1 %cmp20, label %if.then21, label %if.end22

if.then21:                                        ; preds = %if.then17
  store ptr null, ptr %retval, align 8
  br label %return

if.end22:                                         ; preds = %if.then17
  %16 = load ptr, ptr %self.addr, align 8
  %call23 = call i64 @PyBytes_GET_SIZE(ptr noundef %16)
  %17 = load i64, ptr %step, align 8
  %call24 = call i64 @PySlice_AdjustIndices(i64 noundef %call23, ptr noundef %start, ptr noundef %stop, i64 noundef %17)
  store i64 %call24, ptr %slicelength, align 8
  %18 = load i64, ptr %slicelength, align 8
  %cmp25 = icmp sle i64 %18, 0
  br i1 %cmp25, label %if.then26, label %if.else28

if.then26:                                        ; preds = %if.end22
  %call27 = call ptr @PyBytes_FromStringAndSize(ptr noundef @.str.54, i64 noundef 0)
  store ptr %call27, ptr %retval, align 8
  br label %return

if.else28:                                        ; preds = %if.end22
  %19 = load i64, ptr %start, align 8
  %cmp29 = icmp eq i64 %19, 0
  br i1 %cmp29, label %land.lhs.true30, label %if.else40

land.lhs.true30:                                  ; preds = %if.else28
  %20 = load i64, ptr %step, align 8
  %cmp31 = icmp eq i64 %20, 1
  br i1 %cmp31, label %land.lhs.true32, label %if.else40

land.lhs.true32:                                  ; preds = %land.lhs.true30
  %21 = load i64, ptr %slicelength, align 8
  %22 = load ptr, ptr %self.addr, align 8
  %call33 = call i64 @PyBytes_GET_SIZE(ptr noundef %22)
  %cmp34 = icmp eq i64 %21, %call33
  br i1 %cmp34, label %land.lhs.true35, label %if.else40

land.lhs.true35:                                  ; preds = %land.lhs.true32
  %23 = load ptr, ptr %self.addr, align 8
  %call36 = call i32 @Py_IS_TYPE(ptr noundef %23, ptr noundef @PyBytes_Type)
  %tobool37 = icmp ne i32 %call36, 0
  br i1 %tobool37, label %if.then38, label %if.else40

if.then38:                                        ; preds = %land.lhs.true35
  %24 = load ptr, ptr %self.addr, align 8
  %call39 = call ptr @_Py_NewRef(ptr noundef %24)
  store ptr %call39, ptr %retval, align 8
  br label %return

if.else40:                                        ; preds = %land.lhs.true35, %land.lhs.true32, %land.lhs.true30, %if.else28
  %25 = load i64, ptr %step, align 8
  %cmp41 = icmp eq i64 %25, 1
  br i1 %cmp41, label %if.then42, label %if.else45

if.then42:                                        ; preds = %if.else40
  %26 = load ptr, ptr %self.addr, align 8
  %call43 = call ptr @PyBytes_AS_STRING(ptr noundef %26)
  %27 = load i64, ptr %start, align 8
  %add.ptr = getelementptr i8, ptr %call43, i64 %27
  %28 = load i64, ptr %slicelength, align 8
  %call44 = call ptr @PyBytes_FromStringAndSize(ptr noundef %add.ptr, i64 noundef %28)
  store ptr %call44, ptr %retval, align 8
  br label %return

if.else45:                                        ; preds = %if.else40
  %29 = load ptr, ptr %self.addr, align 8
  %call46 = call ptr @PyBytes_AS_STRING(ptr noundef %29)
  store ptr %call46, ptr %source_buf, align 8
  %30 = load i64, ptr %slicelength, align 8
  %call47 = call ptr @PyBytes_FromStringAndSize(ptr noundef null, i64 noundef %30)
  store ptr %call47, ptr %result, align 8
  %31 = load ptr, ptr %result, align 8
  %cmp48 = icmp eq ptr %31, null
  br i1 %cmp48, label %if.then49, label %if.end50

if.then49:                                        ; preds = %if.else45
  store ptr null, ptr %retval, align 8
  br label %return

if.end50:                                         ; preds = %if.else45
  %32 = load ptr, ptr %result, align 8
  %call51 = call ptr @PyBytes_AS_STRING(ptr noundef %32)
  store ptr %call51, ptr %result_buf, align 8
  %33 = load i64, ptr %start, align 8
  store i64 %33, ptr %cur, align 8
  store i64 0, ptr %i18, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end50
  %34 = load i64, ptr %i18, align 8
  %35 = load i64, ptr %slicelength, align 8
  %cmp52 = icmp slt i64 %34, %35
  br i1 %cmp52, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %36 = load ptr, ptr %source_buf, align 8
  %37 = load i64, ptr %cur, align 8
  %arrayidx53 = getelementptr i8, ptr %36, i64 %37
  %38 = load i8, ptr %arrayidx53, align 1
  %39 = load ptr, ptr %result_buf, align 8
  %40 = load i64, ptr %i18, align 8
  %arrayidx54 = getelementptr i8, ptr %39, i64 %40
  store i8 %38, ptr %arrayidx54, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %41 = load i64, ptr %step, align 8
  %42 = load i64, ptr %cur, align 8
  %add55 = add i64 %42, %41
  store i64 %add55, ptr %cur, align 8
  %43 = load i64, ptr %i18, align 8
  %inc = add i64 %43, 1
  store i64 %inc, ptr %i18, align 8
  br label %for.cond, !llvm.loop !50

for.end:                                          ; preds = %for.cond
  %44 = load ptr, ptr %result, align 8
  store ptr %44, ptr %retval, align 8
  br label %return

if.else56:                                        ; preds = %if.else
  %45 = load ptr, ptr @PyExc_TypeError, align 8
  %46 = load ptr, ptr %item.addr, align 8
  %call57 = call ptr @Py_TYPE(ptr noundef %46)
  %tp_name = getelementptr inbounds %struct._typeobject, ptr %call57, i32 0, i32 1
  %47 = load ptr, ptr %tp_name, align 8
  %call58 = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %45, ptr noundef @.str.55, ptr noundef %47)
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else56, %for.end, %if.then49, %if.then42, %if.then38, %if.then26, %if.then21, %if.end13, %if.then12, %if.then4
  %48 = load ptr, ptr %retval, align 8
  ret ptr %48
}

; Function Attrs: nounwind uwtable
define internal i32 @_PyIndex_Check(ptr noundef %obj) #0 {
entry:
  %obj.addr = alloca ptr, align 8
  %tp_as_number = alloca ptr, align 8
  store ptr %obj, ptr %obj.addr, align 8
  %0 = load ptr, ptr %obj.addr, align 8
  %call = call ptr @Py_TYPE(ptr noundef %0)
  %tp_as_number1 = getelementptr inbounds %struct._typeobject, ptr %call, i32 0, i32 10
  %1 = load ptr, ptr %tp_as_number1, align 8
  store ptr %1, ptr %tp_as_number, align 8
  %2 = load ptr, ptr %tp_as_number, align 8
  %cmp = icmp ne ptr %2, null
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %3 = load ptr, ptr %tp_as_number, align 8
  %nb_index = getelementptr inbounds %struct.PyNumberMethods, ptr %3, i32 0, i32 33
  %4 = load ptr, ptr %nb_index, align 8
  %cmp2 = icmp ne ptr %4, null
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %5 = phi i1 [ false, %entry ], [ %cmp2, %land.rhs ]
  %land.ext = zext i1 %5 to i32
  ret i32 %land.ext
}

declare i32 @PySlice_Unpack(ptr noundef, ptr noundef, ptr noundef, ptr noundef) #1

declare i64 @PySlice_AdjustIndices(i64 noundef, ptr noundef, ptr noundef, i64 noundef) #1

declare i64 @_Py_HashBytes(ptr noundef, i64 noundef) #1

declare ptr @_Py_GetConfig() #1

declare i32 @PyErr_WarnEx(ptr noundef, ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define internal i32 @bytes_buffer_getbuffer(ptr noundef %self, ptr noundef %view, i32 noundef %flags) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %view.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  store ptr %self, ptr %self.addr, align 8
  store ptr %view, ptr %view.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  %0 = load ptr, ptr %view.addr, align 8
  %1 = load ptr, ptr %self.addr, align 8
  %2 = load ptr, ptr %self.addr, align 8
  %ob_sval = getelementptr inbounds %struct.PyBytesObject, ptr %2, i32 0, i32 2
  %arraydecay = getelementptr inbounds [1 x i8], ptr %ob_sval, i64 0, i64 0
  %3 = load ptr, ptr %self.addr, align 8
  %call = call i64 @Py_SIZE(ptr noundef %3)
  %4 = load i32, ptr %flags.addr, align 4
  %call1 = call i32 @PyBuffer_FillInfo(ptr noundef %0, ptr noundef %1, ptr noundef %arraydecay, i64 noundef %call, i32 noundef 1, i32 noundef %4)
  ret i32 %call1
}

declare i32 @PyBuffer_FillInfo(ptr noundef, ptr noundef, ptr noundef, i64 noundef, i32 noundef, i32 noundef) #1

declare i32 @PyErr_BadArgument() #1

; Function Attrs: nounwind uwtable
define internal i32 @bytes_compare_eq(ptr noundef %a, ptr noundef %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  %cmp = alloca i32, align 4
  %len = alloca i64, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %call = call i64 @Py_SIZE(ptr noundef %0)
  store i64 %call, ptr %len, align 8
  %1 = load ptr, ptr %b.addr, align 8
  %call1 = call i64 @Py_SIZE(ptr noundef %1)
  %2 = load i64, ptr %len, align 8
  %cmp2 = icmp ne i64 %call1, %2
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %a.addr, align 8
  %ob_sval = getelementptr inbounds %struct.PyBytesObject, ptr %3, i32 0, i32 2
  %arrayidx = getelementptr [1 x i8], ptr %ob_sval, i64 0, i64 0
  %4 = load i8, ptr %arrayidx, align 8
  %conv = sext i8 %4 to i32
  %5 = load ptr, ptr %b.addr, align 8
  %ob_sval3 = getelementptr inbounds %struct.PyBytesObject, ptr %5, i32 0, i32 2
  %arrayidx4 = getelementptr [1 x i8], ptr %ob_sval3, i64 0, i64 0
  %6 = load i8, ptr %arrayidx4, align 8
  %conv5 = sext i8 %6 to i32
  %cmp6 = icmp ne i32 %conv, %conv5
  br i1 %cmp6, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end9:                                          ; preds = %if.end
  %7 = load ptr, ptr %a.addr, align 8
  %ob_sval10 = getelementptr inbounds %struct.PyBytesObject, ptr %7, i32 0, i32 2
  %arraydecay = getelementptr inbounds [1 x i8], ptr %ob_sval10, i64 0, i64 0
  %8 = load ptr, ptr %b.addr, align 8
  %ob_sval11 = getelementptr inbounds %struct.PyBytesObject, ptr %8, i32 0, i32 2
  %arraydecay12 = getelementptr inbounds [1 x i8], ptr %ob_sval11, i64 0, i64 0
  %9 = load i64, ptr %len, align 8
  %call13 = call i32 @memcmp(ptr noundef %arraydecay, ptr noundef %arraydecay12, i64 noundef %9) #8
  store i32 %call13, ptr %cmp, align 4
  %10 = load i32, ptr %cmp, align 4
  %cmp14 = icmp eq i32 %10, 0
  %conv15 = zext i1 %cmp14 to i32
  store i32 %conv15, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end9, %if.then8, %if.then
  %11 = load i32, ptr %retval, align 4
  ret i32 %11
}

declare ptr @PyBool_FromLong(i64 noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @bytes_getnewargs(ptr noundef %v, ptr noundef %_unused_ignored) #0 {
entry:
  %v.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  store ptr %v, ptr %v.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %0 = load ptr, ptr %v.addr, align 8
  %ob_sval = getelementptr inbounds %struct.PyBytesObject, ptr %0, i32 0, i32 2
  %arraydecay = getelementptr inbounds [1 x i8], ptr %ob_sval, i64 0, i64 0
  %1 = load ptr, ptr %v.addr, align 8
  %call = call i64 @Py_SIZE(ptr noundef %1)
  %call1 = call ptr (ptr, ...) @Py_BuildValue(ptr noundef @.str.102, ptr noundef %arraydecay, i64 noundef %call)
  ret ptr %call1
}

; Function Attrs: nounwind uwtable
define internal ptr @bytes___bytes__(ptr noundef %self, ptr noundef %_unused_ignored) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %call = call ptr @bytes___bytes___impl(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @stringlib_capitalize(ptr noundef %self, ptr noundef %_unused_ignored) #0 {
entry:
  %retval = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  %newobj = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %call = call i64 @PyBytes_GET_SIZE(ptr noundef %0)
  %call1 = call ptr @PyBytes_FromStringAndSize(ptr noundef null, i64 noundef %call)
  store ptr %call1, ptr %newobj, align 8
  %1 = load ptr, ptr %newobj, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %newobj, align 8
  %call2 = call ptr @PyBytes_AS_STRING(ptr noundef %2)
  %3 = load ptr, ptr %self.addr, align 8
  %call3 = call ptr @PyBytes_AS_STRING(ptr noundef %3)
  %4 = load ptr, ptr %self.addr, align 8
  %call4 = call i64 @PyBytes_GET_SIZE(ptr noundef %4)
  call void @_Py_bytes_capitalize(ptr noundef %call2, ptr noundef %call3, i64 noundef %call4)
  %5 = load ptr, ptr %newobj, align 8
  store ptr %5, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load ptr, ptr %retval, align 8
  ret ptr %6
}

; Function Attrs: nounwind uwtable
define internal ptr @stringlib_center(ptr noundef %self, ptr noundef %args, i64 noundef %nargs) #0 {
entry:
  %op.addr.i44 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %return_value = alloca ptr, align 8
  %width = alloca i64, align 8
  %fillchar = alloca i8, align 1
  %ival = alloca i64, align 8
  %iobj = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  store i8 32, ptr %fillchar, align 1
  %0 = load i64, ptr %nargs.addr, align 8
  %cmp = icmp sle i64 1, %0
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 %1, 2
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %2 = load i64, ptr %nargs.addr, align 8
  %call = call i32 @_PyArg_CheckPositional(ptr noundef @.str.62, i64 noundef %2, i64 noundef 1, i64 noundef 2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false
  br label %exit

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  store i64 -1, ptr %ival, align 8
  %3 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %3, i64 0
  %4 = load ptr, ptr %arrayidx, align 8
  %call2 = call ptr @_PyNumber_Index(ptr noundef %4)
  store ptr %call2, ptr %iobj, align 8
  %5 = load ptr, ptr %iobj, align 8
  %cmp3 = icmp ne ptr %5, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %6 = load ptr, ptr %iobj, align 8
  %call5 = call i64 @PyLong_AsSsize_t(ptr noundef %6)
  store i64 %call5, ptr %ival, align 8
  %7 = load ptr, ptr %iobj, align 8
  store ptr %7, ptr %op.addr.i, align 8
  %8 = load ptr, ptr %op.addr.i, align 8
  store ptr %8, ptr %op.addr.i44, align 8
  %9 = load ptr, ptr %op.addr.i44, align 8
  %10 = load i64, ptr %9, align 8
  %conv.i = trunc i64 %10 to i32
  %cmp.i45 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i45 to i32
  %tobool.i = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then4
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.then4
  %11 = load ptr, ptr %op.addr.i, align 8
  %12 = load i64, ptr %11, align 8
  %dec.i = add i64 %12, -1
  store i64 %dec.i, ptr %11, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %13 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %13) #9
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  br label %if.end6

if.end6:                                          ; preds = %Py_DECREF.exit, %if.end
  %14 = load i64, ptr %ival, align 8
  %cmp7 = icmp eq i64 %14, -1
  br i1 %cmp7, label %land.lhs.true8, label %if.end12

land.lhs.true8:                                   ; preds = %if.end6
  %call9 = call ptr @PyErr_Occurred()
  %tobool10 = icmp ne ptr %call9, null
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %land.lhs.true8
  br label %exit

if.end12:                                         ; preds = %land.lhs.true8, %if.end6
  %15 = load i64, ptr %ival, align 8
  store i64 %15, ptr %width, align 8
  %16 = load i64, ptr %nargs.addr, align 8
  %cmp13 = icmp slt i64 %16, 2
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end12
  br label %skip_optional

if.end15:                                         ; preds = %if.end12
  %17 = load ptr, ptr %args.addr, align 8
  %arrayidx16 = getelementptr ptr, ptr %17, i64 1
  %18 = load ptr, ptr %arrayidx16, align 8
  %call17 = call ptr @Py_TYPE(ptr noundef %18)
  %call18 = call i32 @PyType_HasFeature(ptr noundef %call17, i64 noundef 134217728)
  %tobool19 = icmp ne i32 %call18, 0
  br i1 %tobool19, label %land.lhs.true20, label %if.else

land.lhs.true20:                                  ; preds = %if.end15
  %19 = load ptr, ptr %args.addr, align 8
  %arrayidx21 = getelementptr ptr, ptr %19, i64 1
  %20 = load ptr, ptr %arrayidx21, align 8
  %call22 = call i64 @PyBytes_GET_SIZE(ptr noundef %20)
  %cmp23 = icmp eq i64 %call22, 1
  br i1 %cmp23, label %if.then24, label %if.else

if.then24:                                        ; preds = %land.lhs.true20
  %21 = load ptr, ptr %args.addr, align 8
  %arrayidx25 = getelementptr ptr, ptr %21, i64 1
  %22 = load ptr, ptr %arrayidx25, align 8
  %call26 = call ptr @PyBytes_AS_STRING(ptr noundef %22)
  %arrayidx27 = getelementptr i8, ptr %call26, i64 0
  %23 = load i8, ptr %arrayidx27, align 1
  store i8 %23, ptr %fillchar, align 1
  br label %if.end42

if.else:                                          ; preds = %land.lhs.true20, %if.end15
  %24 = load ptr, ptr %args.addr, align 8
  %arrayidx28 = getelementptr ptr, ptr %24, i64 1
  %25 = load ptr, ptr %arrayidx28, align 8
  %call29 = call i32 @PyObject_TypeCheck(ptr noundef %25, ptr noundef @PyByteArray_Type)
  %tobool30 = icmp ne i32 %call29, 0
  br i1 %tobool30, label %land.lhs.true31, label %if.else39

land.lhs.true31:                                  ; preds = %if.else
  %26 = load ptr, ptr %args.addr, align 8
  %arrayidx32 = getelementptr ptr, ptr %26, i64 1
  %27 = load ptr, ptr %arrayidx32, align 8
  %call33 = call i64 @PyByteArray_GET_SIZE(ptr noundef %27)
  %cmp34 = icmp eq i64 %call33, 1
  br i1 %cmp34, label %if.then35, label %if.else39

if.then35:                                        ; preds = %land.lhs.true31
  %28 = load ptr, ptr %args.addr, align 8
  %arrayidx36 = getelementptr ptr, ptr %28, i64 1
  %29 = load ptr, ptr %arrayidx36, align 8
  %call37 = call ptr @PyByteArray_AS_STRING(ptr noundef %29)
  %arrayidx38 = getelementptr i8, ptr %call37, i64 0
  %30 = load i8, ptr %arrayidx38, align 1
  store i8 %30, ptr %fillchar, align 1
  br label %if.end41

if.else39:                                        ; preds = %land.lhs.true31, %if.else
  %31 = load ptr, ptr %args.addr, align 8
  %arrayidx40 = getelementptr ptr, ptr %31, i64 1
  %32 = load ptr, ptr %arrayidx40, align 8
  call void @_PyArg_BadArgument(ptr noundef @.str.62, ptr noundef @.str.103, ptr noundef @.str.104, ptr noundef %32)
  br label %exit

if.end41:                                         ; preds = %if.then35
  br label %if.end42

if.end42:                                         ; preds = %if.end41, %if.then24
  br label %skip_optional

skip_optional:                                    ; preds = %if.end42, %if.then14
  %33 = load ptr, ptr %self.addr, align 8
  %34 = load i64, ptr %width, align 8
  %35 = load i8, ptr %fillchar, align 1
  %call43 = call ptr @stringlib_center_impl(ptr noundef %33, i64 noundef %34, i8 noundef signext %35)
  store ptr %call43, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional, %if.else39, %if.then11, %if.then
  %36 = load ptr, ptr %return_value, align 8
  ret ptr %36
}

; Function Attrs: nounwind uwtable
define internal ptr @bytes_count(ptr noundef %self, ptr noundef %args) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %call = call ptr @PyBytes_AS_STRING(ptr noundef %0)
  %1 = load ptr, ptr %self.addr, align 8
  %call1 = call i64 @PyBytes_GET_SIZE(ptr noundef %1)
  %2 = load ptr, ptr %args.addr, align 8
  %call2 = call ptr @_Py_bytes_count(ptr noundef %call, i64 noundef %call1, ptr noundef %2)
  ret ptr %call2
}

; Function Attrs: nounwind uwtable
define internal ptr @bytes_decode(ptr noundef %self, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [2 x ptr], align 16
  %noptargs = alloca i64, align 8
  %encoding = alloca ptr, align 8
  %errors = alloca ptr, align 8
  %encoding_length = alloca i64, align 8
  %errors_length = alloca i64, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 0
  store i64 %sub, ptr %noptargs, align 8
  store ptr null, ptr %encoding, align 8
  store ptr null, ptr %errors, align 8
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 0, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 2
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [2 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @bytes_decode._parser, i32 noundef 0, i32 noundef 2, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load i64, ptr %noptargs, align 8
  %tobool12 = icmp ne i64 %12, 0
  br i1 %tobool12, label %if.end14, label %if.then13

if.then13:                                        ; preds = %if.end
  br label %skip_optional_pos

if.end14:                                         ; preds = %if.end
  %13 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %13, i64 0
  %14 = load ptr, ptr %arrayidx, align 8
  %tobool15 = icmp ne ptr %14, null
  br i1 %tobool15, label %if.then16, label %if.end36

if.then16:                                        ; preds = %if.end14
  %15 = load ptr, ptr %args.addr, align 8
  %arrayidx17 = getelementptr ptr, ptr %15, i64 0
  %16 = load ptr, ptr %arrayidx17, align 8
  %call18 = call ptr @Py_TYPE(ptr noundef %16)
  %call19 = call i32 @PyType_HasFeature(ptr noundef %call18, i64 noundef 268435456)
  %tobool20 = icmp ne i32 %call19, 0
  br i1 %tobool20, label %if.end23, label %if.then21

if.then21:                                        ; preds = %if.then16
  %17 = load ptr, ptr %args.addr, align 8
  %arrayidx22 = getelementptr ptr, ptr %17, i64 0
  %18 = load ptr, ptr %arrayidx22, align 8
  call void @_PyArg_BadArgument(ptr noundef @.str.64, ptr noundef @.str.107, ptr noundef @.str.108, ptr noundef %18)
  br label %exit

if.end23:                                         ; preds = %if.then16
  %19 = load ptr, ptr %args.addr, align 8
  %arrayidx24 = getelementptr ptr, ptr %19, i64 0
  %20 = load ptr, ptr %arrayidx24, align 8
  %call25 = call ptr @PyUnicode_AsUTF8AndSize(ptr noundef %20, ptr noundef %encoding_length)
  store ptr %call25, ptr %encoding, align 8
  %21 = load ptr, ptr %encoding, align 8
  %cmp26 = icmp eq ptr %21, null
  br i1 %cmp26, label %if.then27, label %if.end28

if.then27:                                        ; preds = %if.end23
  br label %exit

if.end28:                                         ; preds = %if.end23
  %22 = load ptr, ptr %encoding, align 8
  %call29 = call i64 @strlen(ptr noundef %22) #8
  %23 = load i64, ptr %encoding_length, align 8
  %cmp30 = icmp ne i64 %call29, %23
  br i1 %cmp30, label %if.then31, label %if.end32

if.then31:                                        ; preds = %if.end28
  %24 = load ptr, ptr @PyExc_ValueError, align 8
  call void @PyErr_SetString(ptr noundef %24, ptr noundef @.str.109)
  br label %exit

if.end32:                                         ; preds = %if.end28
  %25 = load i64, ptr %noptargs, align 8
  %dec = add i64 %25, -1
  store i64 %dec, ptr %noptargs, align 8
  %tobool33 = icmp ne i64 %dec, 0
  br i1 %tobool33, label %if.end35, label %if.then34

if.then34:                                        ; preds = %if.end32
  br label %skip_optional_pos

if.end35:                                         ; preds = %if.end32
  br label %if.end36

if.end36:                                         ; preds = %if.end35, %if.end14
  %26 = load ptr, ptr %args.addr, align 8
  %arrayidx37 = getelementptr ptr, ptr %26, i64 1
  %27 = load ptr, ptr %arrayidx37, align 8
  %call38 = call ptr @Py_TYPE(ptr noundef %27)
  %call39 = call i32 @PyType_HasFeature(ptr noundef %call38, i64 noundef 268435456)
  %tobool40 = icmp ne i32 %call39, 0
  br i1 %tobool40, label %if.end43, label %if.then41

if.then41:                                        ; preds = %if.end36
  %28 = load ptr, ptr %args.addr, align 8
  %arrayidx42 = getelementptr ptr, ptr %28, i64 1
  %29 = load ptr, ptr %arrayidx42, align 8
  call void @_PyArg_BadArgument(ptr noundef @.str.64, ptr noundef @.str.110, ptr noundef @.str.108, ptr noundef %29)
  br label %exit

if.end43:                                         ; preds = %if.end36
  %30 = load ptr, ptr %args.addr, align 8
  %arrayidx44 = getelementptr ptr, ptr %30, i64 1
  %31 = load ptr, ptr %arrayidx44, align 8
  %call45 = call ptr @PyUnicode_AsUTF8AndSize(ptr noundef %31, ptr noundef %errors_length)
  store ptr %call45, ptr %errors, align 8
  %32 = load ptr, ptr %errors, align 8
  %cmp46 = icmp eq ptr %32, null
  br i1 %cmp46, label %if.then47, label %if.end48

if.then47:                                        ; preds = %if.end43
  br label %exit

if.end48:                                         ; preds = %if.end43
  %33 = load ptr, ptr %errors, align 8
  %call49 = call i64 @strlen(ptr noundef %33) #8
  %34 = load i64, ptr %errors_length, align 8
  %cmp50 = icmp ne i64 %call49, %34
  br i1 %cmp50, label %if.then51, label %if.end52

if.then51:                                        ; preds = %if.end48
  %35 = load ptr, ptr @PyExc_ValueError, align 8
  call void @PyErr_SetString(ptr noundef %35, ptr noundef @.str.109)
  br label %exit

if.end52:                                         ; preds = %if.end48
  br label %skip_optional_pos

skip_optional_pos:                                ; preds = %if.end52, %if.then34, %if.then13
  %36 = load ptr, ptr %self.addr, align 8
  %37 = load ptr, ptr %encoding, align 8
  %38 = load ptr, ptr %errors, align 8
  %call53 = call ptr @bytes_decode_impl(ptr noundef %36, ptr noundef %37, ptr noundef %38)
  store ptr %call53, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional_pos, %if.then51, %if.then47, %if.then41, %if.then31, %if.then27, %if.then21, %if.then
  %39 = load ptr, ptr %return_value, align 8
  ret ptr %39
}

; Function Attrs: nounwind uwtable
define internal ptr @bytes_endswith(ptr noundef %self, ptr noundef %args) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %call = call ptr @PyBytes_AS_STRING(ptr noundef %0)
  %1 = load ptr, ptr %self.addr, align 8
  %call1 = call i64 @PyBytes_GET_SIZE(ptr noundef %1)
  %2 = load ptr, ptr %args.addr, align 8
  %call2 = call ptr @_Py_bytes_endswith(ptr noundef %call, i64 noundef %call1, ptr noundef %2)
  ret ptr %call2
}

; Function Attrs: nounwind uwtable
define internal ptr @stringlib_expandtabs(ptr noundef %self, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [1 x ptr], align 8
  %noptargs = alloca i64, align 8
  %tabsize = alloca i32, align 4
  store ptr %self, ptr %self.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 0
  store i64 %sub, ptr %noptargs, align 8
  store i32 8, ptr %tabsize, align 4
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 0, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 1
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [1 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @stringlib_expandtabs._parser, i32 noundef 0, i32 noundef 1, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load i64, ptr %noptargs, align 8
  %tobool12 = icmp ne i64 %12, 0
  br i1 %tobool12, label %if.end14, label %if.then13

if.then13:                                        ; preds = %if.end
  br label %skip_optional_pos

if.end14:                                         ; preds = %if.end
  %13 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %13, i64 0
  %14 = load ptr, ptr %arrayidx, align 8
  %call15 = call i32 @PyLong_AsInt(ptr noundef %14)
  store i32 %call15, ptr %tabsize, align 4
  %15 = load i32, ptr %tabsize, align 4
  %cmp16 = icmp eq i32 %15, -1
  br i1 %cmp16, label %land.lhs.true17, label %if.end21

land.lhs.true17:                                  ; preds = %if.end14
  %call18 = call ptr @PyErr_Occurred()
  %tobool19 = icmp ne ptr %call18, null
  br i1 %tobool19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %land.lhs.true17
  br label %exit

if.end21:                                         ; preds = %land.lhs.true17, %if.end14
  br label %skip_optional_pos

skip_optional_pos:                                ; preds = %if.end21, %if.then13
  %16 = load ptr, ptr %self.addr, align 8
  %17 = load i32, ptr %tabsize, align 4
  %call22 = call ptr @stringlib_expandtabs_impl(ptr noundef %16, i32 noundef %17)
  store ptr %call22, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional_pos, %if.then20, %if.then
  %18 = load ptr, ptr %return_value, align 8
  ret ptr %18
}

; Function Attrs: nounwind uwtable
define internal ptr @bytes_find(ptr noundef %self, ptr noundef %args) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %call = call ptr @PyBytes_AS_STRING(ptr noundef %0)
  %1 = load ptr, ptr %self.addr, align 8
  %call1 = call i64 @PyBytes_GET_SIZE(ptr noundef %1)
  %2 = load ptr, ptr %args.addr, align 8
  %call2 = call ptr @_Py_bytes_find(ptr noundef %call, i64 noundef %call1, ptr noundef %2)
  ret ptr %call2
}

; Function Attrs: nounwind uwtable
define internal ptr @bytes_fromhex(ptr noundef %type, ptr noundef %arg) #0 {
entry:
  %type.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %string = alloca ptr, align 8
  store ptr %type, ptr %type.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %call = call ptr @Py_TYPE(ptr noundef %0)
  %call1 = call i32 @PyType_HasFeature(ptr noundef %call, i64 noundef 268435456)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %arg.addr, align 8
  call void @_PyArg_BadArgument(ptr noundef @.str.68, ptr noundef @.str.113, ptr noundef @.str.108, ptr noundef %1)
  br label %exit

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %arg.addr, align 8
  store ptr %2, ptr %string, align 8
  %3 = load ptr, ptr %type.addr, align 8
  %4 = load ptr, ptr %string, align 8
  %call2 = call ptr @bytes_fromhex_impl(ptr noundef %3, ptr noundef %4)
  store ptr %call2, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end, %if.then
  %5 = load ptr, ptr %return_value, align 8
  ret ptr %5
}

; Function Attrs: nounwind uwtable
define internal ptr @bytes_hex(ptr noundef %self, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [2 x ptr], align 16
  %noptargs = alloca i64, align 8
  %sep = alloca ptr, align 8
  %bytes_per_sep = alloca i32, align 4
  store ptr %self, ptr %self.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 0
  store i64 %sub, ptr %noptargs, align 8
  store ptr null, ptr %sep, align 8
  store i32 1, ptr %bytes_per_sep, align 4
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 0, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 2
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [2 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @bytes_hex._parser, i32 noundef 0, i32 noundef 2, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load i64, ptr %noptargs, align 8
  %tobool12 = icmp ne i64 %12, 0
  br i1 %tobool12, label %if.end14, label %if.then13

if.then13:                                        ; preds = %if.end
  br label %skip_optional_pos

if.end14:                                         ; preds = %if.end
  %13 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %13, i64 0
  %14 = load ptr, ptr %arrayidx, align 8
  %tobool15 = icmp ne ptr %14, null
  br i1 %tobool15, label %if.then16, label %if.end21

if.then16:                                        ; preds = %if.end14
  %15 = load ptr, ptr %args.addr, align 8
  %arrayidx17 = getelementptr ptr, ptr %15, i64 0
  %16 = load ptr, ptr %arrayidx17, align 8
  store ptr %16, ptr %sep, align 8
  %17 = load i64, ptr %noptargs, align 8
  %dec = add i64 %17, -1
  store i64 %dec, ptr %noptargs, align 8
  %tobool18 = icmp ne i64 %dec, 0
  br i1 %tobool18, label %if.end20, label %if.then19

if.then19:                                        ; preds = %if.then16
  br label %skip_optional_pos

if.end20:                                         ; preds = %if.then16
  br label %if.end21

if.end21:                                         ; preds = %if.end20, %if.end14
  %18 = load ptr, ptr %args.addr, align 8
  %arrayidx22 = getelementptr ptr, ptr %18, i64 1
  %19 = load ptr, ptr %arrayidx22, align 8
  %call23 = call i32 @PyLong_AsInt(ptr noundef %19)
  store i32 %call23, ptr %bytes_per_sep, align 4
  %20 = load i32, ptr %bytes_per_sep, align 4
  %cmp24 = icmp eq i32 %20, -1
  br i1 %cmp24, label %land.lhs.true25, label %if.end29

land.lhs.true25:                                  ; preds = %if.end21
  %call26 = call ptr @PyErr_Occurred()
  %tobool27 = icmp ne ptr %call26, null
  br i1 %tobool27, label %if.then28, label %if.end29

if.then28:                                        ; preds = %land.lhs.true25
  br label %exit

if.end29:                                         ; preds = %land.lhs.true25, %if.end21
  br label %skip_optional_pos

skip_optional_pos:                                ; preds = %if.end29, %if.then19, %if.then13
  %21 = load ptr, ptr %self.addr, align 8
  %22 = load ptr, ptr %sep, align 8
  %23 = load i32, ptr %bytes_per_sep, align 4
  %call30 = call ptr @bytes_hex_impl(ptr noundef %21, ptr noundef %22, i32 noundef %23)
  store ptr %call30, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional_pos, %if.then28, %if.then
  %24 = load ptr, ptr %return_value, align 8
  ret ptr %24
}

; Function Attrs: nounwind uwtable
define internal ptr @bytes_index(ptr noundef %self, ptr noundef %args) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %call = call ptr @PyBytes_AS_STRING(ptr noundef %0)
  %1 = load ptr, ptr %self.addr, align 8
  %call1 = call i64 @PyBytes_GET_SIZE(ptr noundef %1)
  %2 = load ptr, ptr %args.addr, align 8
  %call2 = call ptr @_Py_bytes_index(ptr noundef %call, i64 noundef %call1, ptr noundef %2)
  ret ptr %call2
}

; Function Attrs: nounwind uwtable
define internal ptr @stringlib_isalnum(ptr noundef %self, ptr noundef %_unused_ignored) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %call = call ptr @PyBytes_AS_STRING(ptr noundef %0)
  %1 = load ptr, ptr %self.addr, align 8
  %call1 = call i64 @PyBytes_GET_SIZE(ptr noundef %1)
  %call2 = call ptr @_Py_bytes_isalnum(ptr noundef %call, i64 noundef %call1)
  ret ptr %call2
}

; Function Attrs: nounwind uwtable
define internal ptr @stringlib_isalpha(ptr noundef %self, ptr noundef %_unused_ignored) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %call = call ptr @PyBytes_AS_STRING(ptr noundef %0)
  %1 = load ptr, ptr %self.addr, align 8
  %call1 = call i64 @PyBytes_GET_SIZE(ptr noundef %1)
  %call2 = call ptr @_Py_bytes_isalpha(ptr noundef %call, i64 noundef %call1)
  ret ptr %call2
}

; Function Attrs: nounwind uwtable
define internal ptr @stringlib_isascii(ptr noundef %self, ptr noundef %_unused_ignored) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %call = call ptr @PyBytes_AS_STRING(ptr noundef %0)
  %1 = load ptr, ptr %self.addr, align 8
  %call1 = call i64 @PyBytes_GET_SIZE(ptr noundef %1)
  %call2 = call ptr @_Py_bytes_isascii(ptr noundef %call, i64 noundef %call1)
  ret ptr %call2
}

; Function Attrs: nounwind uwtable
define internal ptr @stringlib_isdigit(ptr noundef %self, ptr noundef %_unused_ignored) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %call = call ptr @PyBytes_AS_STRING(ptr noundef %0)
  %1 = load ptr, ptr %self.addr, align 8
  %call1 = call i64 @PyBytes_GET_SIZE(ptr noundef %1)
  %call2 = call ptr @_Py_bytes_isdigit(ptr noundef %call, i64 noundef %call1)
  ret ptr %call2
}

; Function Attrs: nounwind uwtable
define internal ptr @stringlib_islower(ptr noundef %self, ptr noundef %_unused_ignored) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %call = call ptr @PyBytes_AS_STRING(ptr noundef %0)
  %1 = load ptr, ptr %self.addr, align 8
  %call1 = call i64 @PyBytes_GET_SIZE(ptr noundef %1)
  %call2 = call ptr @_Py_bytes_islower(ptr noundef %call, i64 noundef %call1)
  ret ptr %call2
}

; Function Attrs: nounwind uwtable
define internal ptr @stringlib_isspace(ptr noundef %self, ptr noundef %_unused_ignored) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %call = call ptr @PyBytes_AS_STRING(ptr noundef %0)
  %1 = load ptr, ptr %self.addr, align 8
  %call1 = call i64 @PyBytes_GET_SIZE(ptr noundef %1)
  %call2 = call ptr @_Py_bytes_isspace(ptr noundef %call, i64 noundef %call1)
  ret ptr %call2
}

; Function Attrs: nounwind uwtable
define internal ptr @stringlib_istitle(ptr noundef %self, ptr noundef %_unused_ignored) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %call = call ptr @PyBytes_AS_STRING(ptr noundef %0)
  %1 = load ptr, ptr %self.addr, align 8
  %call1 = call i64 @PyBytes_GET_SIZE(ptr noundef %1)
  %call2 = call ptr @_Py_bytes_istitle(ptr noundef %call, i64 noundef %call1)
  ret ptr %call2
}

; Function Attrs: nounwind uwtable
define internal ptr @stringlib_isupper(ptr noundef %self, ptr noundef %_unused_ignored) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %call = call ptr @PyBytes_AS_STRING(ptr noundef %0)
  %1 = load ptr, ptr %self.addr, align 8
  %call1 = call i64 @PyBytes_GET_SIZE(ptr noundef %1)
  %call2 = call ptr @_Py_bytes_isupper(ptr noundef %call, i64 noundef %call1)
  ret ptr %call2
}

; Function Attrs: nounwind uwtable
define internal ptr @stringlib_ljust(ptr noundef %self, ptr noundef %args, i64 noundef %nargs) #0 {
entry:
  %op.addr.i44 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %return_value = alloca ptr, align 8
  %width = alloca i64, align 8
  %fillchar = alloca i8, align 1
  %ival = alloca i64, align 8
  %iobj = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  store i8 32, ptr %fillchar, align 1
  %0 = load i64, ptr %nargs.addr, align 8
  %cmp = icmp sle i64 1, %0
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 %1, 2
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %2 = load i64, ptr %nargs.addr, align 8
  %call = call i32 @_PyArg_CheckPositional(ptr noundef @.str.80, i64 noundef %2, i64 noundef 1, i64 noundef 2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false
  br label %exit

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  store i64 -1, ptr %ival, align 8
  %3 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %3, i64 0
  %4 = load ptr, ptr %arrayidx, align 8
  %call2 = call ptr @_PyNumber_Index(ptr noundef %4)
  store ptr %call2, ptr %iobj, align 8
  %5 = load ptr, ptr %iobj, align 8
  %cmp3 = icmp ne ptr %5, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %6 = load ptr, ptr %iobj, align 8
  %call5 = call i64 @PyLong_AsSsize_t(ptr noundef %6)
  store i64 %call5, ptr %ival, align 8
  %7 = load ptr, ptr %iobj, align 8
  store ptr %7, ptr %op.addr.i, align 8
  %8 = load ptr, ptr %op.addr.i, align 8
  store ptr %8, ptr %op.addr.i44, align 8
  %9 = load ptr, ptr %op.addr.i44, align 8
  %10 = load i64, ptr %9, align 8
  %conv.i = trunc i64 %10 to i32
  %cmp.i45 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i45 to i32
  %tobool.i = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then4
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.then4
  %11 = load ptr, ptr %op.addr.i, align 8
  %12 = load i64, ptr %11, align 8
  %dec.i = add i64 %12, -1
  store i64 %dec.i, ptr %11, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %13 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %13) #9
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  br label %if.end6

if.end6:                                          ; preds = %Py_DECREF.exit, %if.end
  %14 = load i64, ptr %ival, align 8
  %cmp7 = icmp eq i64 %14, -1
  br i1 %cmp7, label %land.lhs.true8, label %if.end12

land.lhs.true8:                                   ; preds = %if.end6
  %call9 = call ptr @PyErr_Occurred()
  %tobool10 = icmp ne ptr %call9, null
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %land.lhs.true8
  br label %exit

if.end12:                                         ; preds = %land.lhs.true8, %if.end6
  %15 = load i64, ptr %ival, align 8
  store i64 %15, ptr %width, align 8
  %16 = load i64, ptr %nargs.addr, align 8
  %cmp13 = icmp slt i64 %16, 2
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end12
  br label %skip_optional

if.end15:                                         ; preds = %if.end12
  %17 = load ptr, ptr %args.addr, align 8
  %arrayidx16 = getelementptr ptr, ptr %17, i64 1
  %18 = load ptr, ptr %arrayidx16, align 8
  %call17 = call ptr @Py_TYPE(ptr noundef %18)
  %call18 = call i32 @PyType_HasFeature(ptr noundef %call17, i64 noundef 134217728)
  %tobool19 = icmp ne i32 %call18, 0
  br i1 %tobool19, label %land.lhs.true20, label %if.else

land.lhs.true20:                                  ; preds = %if.end15
  %19 = load ptr, ptr %args.addr, align 8
  %arrayidx21 = getelementptr ptr, ptr %19, i64 1
  %20 = load ptr, ptr %arrayidx21, align 8
  %call22 = call i64 @PyBytes_GET_SIZE(ptr noundef %20)
  %cmp23 = icmp eq i64 %call22, 1
  br i1 %cmp23, label %if.then24, label %if.else

if.then24:                                        ; preds = %land.lhs.true20
  %21 = load ptr, ptr %args.addr, align 8
  %arrayidx25 = getelementptr ptr, ptr %21, i64 1
  %22 = load ptr, ptr %arrayidx25, align 8
  %call26 = call ptr @PyBytes_AS_STRING(ptr noundef %22)
  %arrayidx27 = getelementptr i8, ptr %call26, i64 0
  %23 = load i8, ptr %arrayidx27, align 1
  store i8 %23, ptr %fillchar, align 1
  br label %if.end42

if.else:                                          ; preds = %land.lhs.true20, %if.end15
  %24 = load ptr, ptr %args.addr, align 8
  %arrayidx28 = getelementptr ptr, ptr %24, i64 1
  %25 = load ptr, ptr %arrayidx28, align 8
  %call29 = call i32 @PyObject_TypeCheck(ptr noundef %25, ptr noundef @PyByteArray_Type)
  %tobool30 = icmp ne i32 %call29, 0
  br i1 %tobool30, label %land.lhs.true31, label %if.else39

land.lhs.true31:                                  ; preds = %if.else
  %26 = load ptr, ptr %args.addr, align 8
  %arrayidx32 = getelementptr ptr, ptr %26, i64 1
  %27 = load ptr, ptr %arrayidx32, align 8
  %call33 = call i64 @PyByteArray_GET_SIZE(ptr noundef %27)
  %cmp34 = icmp eq i64 %call33, 1
  br i1 %cmp34, label %if.then35, label %if.else39

if.then35:                                        ; preds = %land.lhs.true31
  %28 = load ptr, ptr %args.addr, align 8
  %arrayidx36 = getelementptr ptr, ptr %28, i64 1
  %29 = load ptr, ptr %arrayidx36, align 8
  %call37 = call ptr @PyByteArray_AS_STRING(ptr noundef %29)
  %arrayidx38 = getelementptr i8, ptr %call37, i64 0
  %30 = load i8, ptr %arrayidx38, align 1
  store i8 %30, ptr %fillchar, align 1
  br label %if.end41

if.else39:                                        ; preds = %land.lhs.true31, %if.else
  %31 = load ptr, ptr %args.addr, align 8
  %arrayidx40 = getelementptr ptr, ptr %31, i64 1
  %32 = load ptr, ptr %arrayidx40, align 8
  call void @_PyArg_BadArgument(ptr noundef @.str.80, ptr noundef @.str.103, ptr noundef @.str.104, ptr noundef %32)
  br label %exit

if.end41:                                         ; preds = %if.then35
  br label %if.end42

if.end42:                                         ; preds = %if.end41, %if.then24
  br label %skip_optional

skip_optional:                                    ; preds = %if.end42, %if.then14
  %33 = load ptr, ptr %self.addr, align 8
  %34 = load i64, ptr %width, align 8
  %35 = load i8, ptr %fillchar, align 1
  %call43 = call ptr @stringlib_ljust_impl(ptr noundef %33, i64 noundef %34, i8 noundef signext %35)
  store ptr %call43, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional, %if.else39, %if.then11, %if.then
  %36 = load ptr, ptr %return_value, align 8
  ret ptr %36
}

; Function Attrs: nounwind uwtable
define internal ptr @stringlib_lower(ptr noundef %self, ptr noundef %_unused_ignored) #0 {
entry:
  %retval = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  %newobj = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %call = call i64 @PyBytes_GET_SIZE(ptr noundef %0)
  %call1 = call ptr @PyBytes_FromStringAndSize(ptr noundef null, i64 noundef %call)
  store ptr %call1, ptr %newobj, align 8
  %1 = load ptr, ptr %newobj, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %newobj, align 8
  %call2 = call ptr @PyBytes_AS_STRING(ptr noundef %2)
  %3 = load ptr, ptr %self.addr, align 8
  %call3 = call ptr @PyBytes_AS_STRING(ptr noundef %3)
  %4 = load ptr, ptr %self.addr, align 8
  %call4 = call i64 @PyBytes_GET_SIZE(ptr noundef %4)
  call void @_Py_bytes_lower(ptr noundef %call2, ptr noundef %call3, i64 noundef %call4)
  %5 = load ptr, ptr %newobj, align 8
  store ptr %5, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load ptr, ptr %retval, align 8
  ret ptr %6
}

; Function Attrs: nounwind uwtable
define internal ptr @bytes_lstrip(ptr noundef %self, ptr noundef %args, i64 noundef %nargs) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %return_value = alloca ptr, align 8
  %bytes = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  store ptr @_Py_NoneStruct, ptr %bytes, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %cmp = icmp sle i64 0, %0
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 %1, 1
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %2 = load i64, ptr %nargs.addr, align 8
  %call = call i32 @_PyArg_CheckPositional(ptr noundef @.str.82, i64 noundef %2, i64 noundef 0, i64 noundef 1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false
  br label %exit

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %3 = load i64, ptr %nargs.addr, align 8
  %cmp2 = icmp slt i64 %3, 1
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  br label %skip_optional

if.end4:                                          ; preds = %if.end
  %4 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %4, i64 0
  %5 = load ptr, ptr %arrayidx, align 8
  store ptr %5, ptr %bytes, align 8
  br label %skip_optional

skip_optional:                                    ; preds = %if.end4, %if.then3
  %6 = load ptr, ptr %self.addr, align 8
  %7 = load ptr, ptr %bytes, align 8
  %call5 = call ptr @bytes_lstrip_impl(ptr noundef %6, ptr noundef %7)
  store ptr %call5, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional, %if.then
  %8 = load ptr, ptr %return_value, align 8
  ret ptr %8
}

; Function Attrs: nounwind uwtable
define internal ptr @bytes_maketrans(ptr noundef %null, ptr noundef %args, i64 noundef %nargs) #0 {
entry:
  %null.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %return_value = alloca ptr, align 8
  %frm = alloca %struct.Py_buffer, align 8
  %to = alloca %struct.Py_buffer, align 8
  store ptr %null, ptr %null.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %frm, i8 0, i64 80, i1 false)
  call void @llvm.memset.p0.i64(ptr align 8 %to, i8 0, i64 80, i1 false)
  %0 = load i64, ptr %nargs.addr, align 8
  %cmp = icmp sle i64 2, %0
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 %1, 2
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %2 = load i64, ptr %nargs.addr, align 8
  %call = call i32 @_PyArg_CheckPositional(ptr noundef @.str.83, i64 noundef %2, i64 noundef 2, i64 noundef 2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false
  br label %exit

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %3 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %3, i64 0
  %4 = load ptr, ptr %arrayidx, align 8
  %call2 = call i32 @PyObject_GetBuffer(ptr noundef %4, ptr noundef %frm, i32 noundef 0)
  %cmp3 = icmp ne i32 %call2, 0
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  br label %exit

if.end5:                                          ; preds = %if.end
  %5 = load ptr, ptr %args.addr, align 8
  %arrayidx6 = getelementptr ptr, ptr %5, i64 1
  %6 = load ptr, ptr %arrayidx6, align 8
  %call7 = call i32 @PyObject_GetBuffer(ptr noundef %6, ptr noundef %to, i32 noundef 0)
  %cmp8 = icmp ne i32 %call7, 0
  br i1 %cmp8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end5
  br label %exit

if.end10:                                         ; preds = %if.end5
  %call11 = call ptr @bytes_maketrans_impl(ptr noundef %frm, ptr noundef %to)
  store ptr %call11, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end10, %if.then9, %if.then4, %if.then
  %obj = getelementptr inbounds %struct.Py_buffer, ptr %frm, i32 0, i32 1
  %7 = load ptr, ptr %obj, align 8
  %tobool12 = icmp ne ptr %7, null
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %exit
  call void @PyBuffer_Release(ptr noundef %frm)
  br label %if.end14

if.end14:                                         ; preds = %if.then13, %exit
  %obj15 = getelementptr inbounds %struct.Py_buffer, ptr %to, i32 0, i32 1
  %8 = load ptr, ptr %obj15, align 8
  %tobool16 = icmp ne ptr %8, null
  br i1 %tobool16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end14
  call void @PyBuffer_Release(ptr noundef %to)
  br label %if.end18

if.end18:                                         ; preds = %if.then17, %if.end14
  %9 = load ptr, ptr %return_value, align 8
  ret ptr %9
}

; Function Attrs: nounwind uwtable
define internal ptr @bytes_partition(ptr noundef %self, ptr noundef %arg) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %sep = alloca %struct.Py_buffer, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr null, ptr %return_value, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %sep, i8 0, i64 80, i1 false)
  %0 = load ptr, ptr %arg.addr, align 8
  %call = call i32 @PyObject_GetBuffer(ptr noundef %0, ptr noundef %sep, i32 noundef 0)
  %cmp = icmp ne i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %exit

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %self.addr, align 8
  %call1 = call ptr @bytes_partition_impl(ptr noundef %1, ptr noundef %sep)
  store ptr %call1, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end, %if.then
  %obj = getelementptr inbounds %struct.Py_buffer, ptr %sep, i32 0, i32 1
  %2 = load ptr, ptr %obj, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.then2, label %if.end3

if.then2:                                         ; preds = %exit
  call void @PyBuffer_Release(ptr noundef %sep)
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %exit
  %3 = load ptr, ptr %return_value, align 8
  ret ptr %3
}

; Function Attrs: nounwind uwtable
define internal ptr @bytes_replace(ptr noundef %self, ptr noundef %args, i64 noundef %nargs) #0 {
entry:
  %op.addr.i34 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %return_value = alloca ptr, align 8
  %old = alloca %struct.Py_buffer, align 8
  %new = alloca %struct.Py_buffer, align 8
  %count = alloca i64, align 8
  %ival = alloca i64, align 8
  %iobj = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %old, i8 0, i64 80, i1 false)
  call void @llvm.memset.p0.i64(ptr align 8 %new, i8 0, i64 80, i1 false)
  store i64 -1, ptr %count, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %cmp = icmp sle i64 2, %0
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 %1, 3
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %2 = load i64, ptr %nargs.addr, align 8
  %call = call i32 @_PyArg_CheckPositional(ptr noundef @.str.24, i64 noundef %2, i64 noundef 2, i64 noundef 3)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false
  br label %exit

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %3 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %3, i64 0
  %4 = load ptr, ptr %arrayidx, align 8
  %call2 = call i32 @PyObject_GetBuffer(ptr noundef %4, ptr noundef %old, i32 noundef 0)
  %cmp3 = icmp ne i32 %call2, 0
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  br label %exit

if.end5:                                          ; preds = %if.end
  %5 = load ptr, ptr %args.addr, align 8
  %arrayidx6 = getelementptr ptr, ptr %5, i64 1
  %6 = load ptr, ptr %arrayidx6, align 8
  %call7 = call i32 @PyObject_GetBuffer(ptr noundef %6, ptr noundef %new, i32 noundef 0)
  %cmp8 = icmp ne i32 %call7, 0
  br i1 %cmp8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end5
  br label %exit

if.end10:                                         ; preds = %if.end5
  %7 = load i64, ptr %nargs.addr, align 8
  %cmp11 = icmp slt i64 %7, 3
  br i1 %cmp11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end10
  br label %skip_optional

if.end13:                                         ; preds = %if.end10
  store i64 -1, ptr %ival, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %arrayidx14 = getelementptr ptr, ptr %8, i64 2
  %9 = load ptr, ptr %arrayidx14, align 8
  %call15 = call ptr @_PyNumber_Index(ptr noundef %9)
  store ptr %call15, ptr %iobj, align 8
  %10 = load ptr, ptr %iobj, align 8
  %cmp16 = icmp ne ptr %10, null
  br i1 %cmp16, label %if.then17, label %if.end19

if.then17:                                        ; preds = %if.end13
  %11 = load ptr, ptr %iobj, align 8
  %call18 = call i64 @PyLong_AsSsize_t(ptr noundef %11)
  store i64 %call18, ptr %ival, align 8
  %12 = load ptr, ptr %iobj, align 8
  store ptr %12, ptr %op.addr.i, align 8
  %13 = load ptr, ptr %op.addr.i, align 8
  store ptr %13, ptr %op.addr.i34, align 8
  %14 = load ptr, ptr %op.addr.i34, align 8
  %15 = load i64, ptr %14, align 8
  %conv.i = trunc i64 %15 to i32
  %cmp.i35 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i35 to i32
  %tobool.i = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then17
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.then17
  %16 = load ptr, ptr %op.addr.i, align 8
  %17 = load i64, ptr %16, align 8
  %dec.i = add i64 %17, -1
  store i64 %dec.i, ptr %16, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %18 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %18) #9
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  br label %if.end19

if.end19:                                         ; preds = %Py_DECREF.exit, %if.end13
  %19 = load i64, ptr %ival, align 8
  %cmp20 = icmp eq i64 %19, -1
  br i1 %cmp20, label %land.lhs.true21, label %if.end25

land.lhs.true21:                                  ; preds = %if.end19
  %call22 = call ptr @PyErr_Occurred()
  %tobool23 = icmp ne ptr %call22, null
  br i1 %tobool23, label %if.then24, label %if.end25

if.then24:                                        ; preds = %land.lhs.true21
  br label %exit

if.end25:                                         ; preds = %land.lhs.true21, %if.end19
  %20 = load i64, ptr %ival, align 8
  store i64 %20, ptr %count, align 8
  br label %skip_optional

skip_optional:                                    ; preds = %if.end25, %if.then12
  %21 = load ptr, ptr %self.addr, align 8
  %22 = load i64, ptr %count, align 8
  %call26 = call ptr @bytes_replace_impl(ptr noundef %21, ptr noundef %old, ptr noundef %new, i64 noundef %22)
  store ptr %call26, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional, %if.then24, %if.then9, %if.then4, %if.then
  %obj = getelementptr inbounds %struct.Py_buffer, ptr %old, i32 0, i32 1
  %23 = load ptr, ptr %obj, align 8
  %tobool27 = icmp ne ptr %23, null
  br i1 %tobool27, label %if.then28, label %if.end29

if.then28:                                        ; preds = %exit
  call void @PyBuffer_Release(ptr noundef %old)
  br label %if.end29

if.end29:                                         ; preds = %if.then28, %exit
  %obj30 = getelementptr inbounds %struct.Py_buffer, ptr %new, i32 0, i32 1
  %24 = load ptr, ptr %obj30, align 8
  %tobool31 = icmp ne ptr %24, null
  br i1 %tobool31, label %if.then32, label %if.end33

if.then32:                                        ; preds = %if.end29
  call void @PyBuffer_Release(ptr noundef %new)
  br label %if.end33

if.end33:                                         ; preds = %if.then32, %if.end29
  %25 = load ptr, ptr %return_value, align 8
  ret ptr %25
}

; Function Attrs: nounwind uwtable
define internal ptr @bytes_removeprefix(ptr noundef %self, ptr noundef %arg) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %prefix = alloca %struct.Py_buffer, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr null, ptr %return_value, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %prefix, i8 0, i64 80, i1 false)
  %0 = load ptr, ptr %arg.addr, align 8
  %call = call i32 @PyObject_GetBuffer(ptr noundef %0, ptr noundef %prefix, i32 noundef 0)
  %cmp = icmp ne i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %exit

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %self.addr, align 8
  %call1 = call ptr @bytes_removeprefix_impl(ptr noundef %1, ptr noundef %prefix)
  store ptr %call1, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end, %if.then
  %obj = getelementptr inbounds %struct.Py_buffer, ptr %prefix, i32 0, i32 1
  %2 = load ptr, ptr %obj, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.then2, label %if.end3

if.then2:                                         ; preds = %exit
  call void @PyBuffer_Release(ptr noundef %prefix)
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %exit
  %3 = load ptr, ptr %return_value, align 8
  ret ptr %3
}

; Function Attrs: nounwind uwtable
define internal ptr @bytes_removesuffix(ptr noundef %self, ptr noundef %arg) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %suffix = alloca %struct.Py_buffer, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr null, ptr %return_value, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %suffix, i8 0, i64 80, i1 false)
  %0 = load ptr, ptr %arg.addr, align 8
  %call = call i32 @PyObject_GetBuffer(ptr noundef %0, ptr noundef %suffix, i32 noundef 0)
  %cmp = icmp ne i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %exit

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %self.addr, align 8
  %call1 = call ptr @bytes_removesuffix_impl(ptr noundef %1, ptr noundef %suffix)
  store ptr %call1, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end, %if.then
  %obj = getelementptr inbounds %struct.Py_buffer, ptr %suffix, i32 0, i32 1
  %2 = load ptr, ptr %obj, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.then2, label %if.end3

if.then2:                                         ; preds = %exit
  call void @PyBuffer_Release(ptr noundef %suffix)
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %exit
  %3 = load ptr, ptr %return_value, align 8
  ret ptr %3
}

; Function Attrs: nounwind uwtable
define internal ptr @bytes_rfind(ptr noundef %self, ptr noundef %args) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %call = call ptr @PyBytes_AS_STRING(ptr noundef %0)
  %1 = load ptr, ptr %self.addr, align 8
  %call1 = call i64 @PyBytes_GET_SIZE(ptr noundef %1)
  %2 = load ptr, ptr %args.addr, align 8
  %call2 = call ptr @_Py_bytes_rfind(ptr noundef %call, i64 noundef %call1, ptr noundef %2)
  ret ptr %call2
}

; Function Attrs: nounwind uwtable
define internal ptr @bytes_rindex(ptr noundef %self, ptr noundef %args) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %call = call ptr @PyBytes_AS_STRING(ptr noundef %0)
  %1 = load ptr, ptr %self.addr, align 8
  %call1 = call i64 @PyBytes_GET_SIZE(ptr noundef %1)
  %2 = load ptr, ptr %args.addr, align 8
  %call2 = call ptr @_Py_bytes_rindex(ptr noundef %call, i64 noundef %call1, ptr noundef %2)
  ret ptr %call2
}

; Function Attrs: nounwind uwtable
define internal ptr @stringlib_rjust(ptr noundef %self, ptr noundef %args, i64 noundef %nargs) #0 {
entry:
  %op.addr.i44 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %return_value = alloca ptr, align 8
  %width = alloca i64, align 8
  %fillchar = alloca i8, align 1
  %ival = alloca i64, align 8
  %iobj = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  store i8 32, ptr %fillchar, align 1
  %0 = load i64, ptr %nargs.addr, align 8
  %cmp = icmp sle i64 1, %0
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 %1, 2
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %2 = load i64, ptr %nargs.addr, align 8
  %call = call i32 @_PyArg_CheckPositional(ptr noundef @.str.89, i64 noundef %2, i64 noundef 1, i64 noundef 2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false
  br label %exit

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  store i64 -1, ptr %ival, align 8
  %3 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %3, i64 0
  %4 = load ptr, ptr %arrayidx, align 8
  %call2 = call ptr @_PyNumber_Index(ptr noundef %4)
  store ptr %call2, ptr %iobj, align 8
  %5 = load ptr, ptr %iobj, align 8
  %cmp3 = icmp ne ptr %5, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %6 = load ptr, ptr %iobj, align 8
  %call5 = call i64 @PyLong_AsSsize_t(ptr noundef %6)
  store i64 %call5, ptr %ival, align 8
  %7 = load ptr, ptr %iobj, align 8
  store ptr %7, ptr %op.addr.i, align 8
  %8 = load ptr, ptr %op.addr.i, align 8
  store ptr %8, ptr %op.addr.i44, align 8
  %9 = load ptr, ptr %op.addr.i44, align 8
  %10 = load i64, ptr %9, align 8
  %conv.i = trunc i64 %10 to i32
  %cmp.i45 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i45 to i32
  %tobool.i = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then4
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.then4
  %11 = load ptr, ptr %op.addr.i, align 8
  %12 = load i64, ptr %11, align 8
  %dec.i = add i64 %12, -1
  store i64 %dec.i, ptr %11, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %13 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %13) #9
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  br label %if.end6

if.end6:                                          ; preds = %Py_DECREF.exit, %if.end
  %14 = load i64, ptr %ival, align 8
  %cmp7 = icmp eq i64 %14, -1
  br i1 %cmp7, label %land.lhs.true8, label %if.end12

land.lhs.true8:                                   ; preds = %if.end6
  %call9 = call ptr @PyErr_Occurred()
  %tobool10 = icmp ne ptr %call9, null
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %land.lhs.true8
  br label %exit

if.end12:                                         ; preds = %land.lhs.true8, %if.end6
  %15 = load i64, ptr %ival, align 8
  store i64 %15, ptr %width, align 8
  %16 = load i64, ptr %nargs.addr, align 8
  %cmp13 = icmp slt i64 %16, 2
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end12
  br label %skip_optional

if.end15:                                         ; preds = %if.end12
  %17 = load ptr, ptr %args.addr, align 8
  %arrayidx16 = getelementptr ptr, ptr %17, i64 1
  %18 = load ptr, ptr %arrayidx16, align 8
  %call17 = call ptr @Py_TYPE(ptr noundef %18)
  %call18 = call i32 @PyType_HasFeature(ptr noundef %call17, i64 noundef 134217728)
  %tobool19 = icmp ne i32 %call18, 0
  br i1 %tobool19, label %land.lhs.true20, label %if.else

land.lhs.true20:                                  ; preds = %if.end15
  %19 = load ptr, ptr %args.addr, align 8
  %arrayidx21 = getelementptr ptr, ptr %19, i64 1
  %20 = load ptr, ptr %arrayidx21, align 8
  %call22 = call i64 @PyBytes_GET_SIZE(ptr noundef %20)
  %cmp23 = icmp eq i64 %call22, 1
  br i1 %cmp23, label %if.then24, label %if.else

if.then24:                                        ; preds = %land.lhs.true20
  %21 = load ptr, ptr %args.addr, align 8
  %arrayidx25 = getelementptr ptr, ptr %21, i64 1
  %22 = load ptr, ptr %arrayidx25, align 8
  %call26 = call ptr @PyBytes_AS_STRING(ptr noundef %22)
  %arrayidx27 = getelementptr i8, ptr %call26, i64 0
  %23 = load i8, ptr %arrayidx27, align 1
  store i8 %23, ptr %fillchar, align 1
  br label %if.end42

if.else:                                          ; preds = %land.lhs.true20, %if.end15
  %24 = load ptr, ptr %args.addr, align 8
  %arrayidx28 = getelementptr ptr, ptr %24, i64 1
  %25 = load ptr, ptr %arrayidx28, align 8
  %call29 = call i32 @PyObject_TypeCheck(ptr noundef %25, ptr noundef @PyByteArray_Type)
  %tobool30 = icmp ne i32 %call29, 0
  br i1 %tobool30, label %land.lhs.true31, label %if.else39

land.lhs.true31:                                  ; preds = %if.else
  %26 = load ptr, ptr %args.addr, align 8
  %arrayidx32 = getelementptr ptr, ptr %26, i64 1
  %27 = load ptr, ptr %arrayidx32, align 8
  %call33 = call i64 @PyByteArray_GET_SIZE(ptr noundef %27)
  %cmp34 = icmp eq i64 %call33, 1
  br i1 %cmp34, label %if.then35, label %if.else39

if.then35:                                        ; preds = %land.lhs.true31
  %28 = load ptr, ptr %args.addr, align 8
  %arrayidx36 = getelementptr ptr, ptr %28, i64 1
  %29 = load ptr, ptr %arrayidx36, align 8
  %call37 = call ptr @PyByteArray_AS_STRING(ptr noundef %29)
  %arrayidx38 = getelementptr i8, ptr %call37, i64 0
  %30 = load i8, ptr %arrayidx38, align 1
  store i8 %30, ptr %fillchar, align 1
  br label %if.end41

if.else39:                                        ; preds = %land.lhs.true31, %if.else
  %31 = load ptr, ptr %args.addr, align 8
  %arrayidx40 = getelementptr ptr, ptr %31, i64 1
  %32 = load ptr, ptr %arrayidx40, align 8
  call void @_PyArg_BadArgument(ptr noundef @.str.89, ptr noundef @.str.103, ptr noundef @.str.104, ptr noundef %32)
  br label %exit

if.end41:                                         ; preds = %if.then35
  br label %if.end42

if.end42:                                         ; preds = %if.end41, %if.then24
  br label %skip_optional

skip_optional:                                    ; preds = %if.end42, %if.then14
  %33 = load ptr, ptr %self.addr, align 8
  %34 = load i64, ptr %width, align 8
  %35 = load i8, ptr %fillchar, align 1
  %call43 = call ptr @stringlib_rjust_impl(ptr noundef %33, i64 noundef %34, i8 noundef signext %35)
  store ptr %call43, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional, %if.else39, %if.then11, %if.then
  %36 = load ptr, ptr %return_value, align 8
  ret ptr %36
}

; Function Attrs: nounwind uwtable
define internal ptr @bytes_rpartition(ptr noundef %self, ptr noundef %arg) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %sep = alloca %struct.Py_buffer, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr null, ptr %return_value, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %sep, i8 0, i64 80, i1 false)
  %0 = load ptr, ptr %arg.addr, align 8
  %call = call i32 @PyObject_GetBuffer(ptr noundef %0, ptr noundef %sep, i32 noundef 0)
  %cmp = icmp ne i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %exit

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %self.addr, align 8
  %call1 = call ptr @bytes_rpartition_impl(ptr noundef %1, ptr noundef %sep)
  store ptr %call1, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end, %if.then
  %obj = getelementptr inbounds %struct.Py_buffer, ptr %sep, i32 0, i32 1
  %2 = load ptr, ptr %obj, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.then2, label %if.end3

if.then2:                                         ; preds = %exit
  call void @PyBuffer_Release(ptr noundef %sep)
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %exit
  %3 = load ptr, ptr %return_value, align 8
  ret ptr %3
}

; Function Attrs: nounwind uwtable
define internal ptr @bytes_rsplit(ptr noundef %self, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %op.addr.i35 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [2 x ptr], align 16
  %noptargs = alloca i64, align 8
  %sep = alloca ptr, align 8
  %maxsplit = alloca i64, align 8
  %ival = alloca i64, align 8
  %iobj = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 0
  store i64 %sub, ptr %noptargs, align 8
  store ptr @_Py_NoneStruct, ptr %sep, align 8
  store i64 -1, ptr %maxsplit, align 8
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 0, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 2
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [2 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @bytes_rsplit._parser, i32 noundef 0, i32 noundef 2, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load i64, ptr %noptargs, align 8
  %tobool12 = icmp ne i64 %12, 0
  br i1 %tobool12, label %if.end14, label %if.then13

if.then13:                                        ; preds = %if.end
  br label %skip_optional_pos

if.end14:                                         ; preds = %if.end
  %13 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %13, i64 0
  %14 = load ptr, ptr %arrayidx, align 8
  %tobool15 = icmp ne ptr %14, null
  br i1 %tobool15, label %if.then16, label %if.end21

if.then16:                                        ; preds = %if.end14
  %15 = load ptr, ptr %args.addr, align 8
  %arrayidx17 = getelementptr ptr, ptr %15, i64 0
  %16 = load ptr, ptr %arrayidx17, align 8
  store ptr %16, ptr %sep, align 8
  %17 = load i64, ptr %noptargs, align 8
  %dec = add i64 %17, -1
  store i64 %dec, ptr %noptargs, align 8
  %tobool18 = icmp ne i64 %dec, 0
  br i1 %tobool18, label %if.end20, label %if.then19

if.then19:                                        ; preds = %if.then16
  br label %skip_optional_pos

if.end20:                                         ; preds = %if.then16
  br label %if.end21

if.end21:                                         ; preds = %if.end20, %if.end14
  store i64 -1, ptr %ival, align 8
  %18 = load ptr, ptr %args.addr, align 8
  %arrayidx22 = getelementptr ptr, ptr %18, i64 1
  %19 = load ptr, ptr %arrayidx22, align 8
  %call23 = call ptr @_PyNumber_Index(ptr noundef %19)
  store ptr %call23, ptr %iobj, align 8
  %20 = load ptr, ptr %iobj, align 8
  %cmp24 = icmp ne ptr %20, null
  br i1 %cmp24, label %if.then25, label %if.end27

if.then25:                                        ; preds = %if.end21
  %21 = load ptr, ptr %iobj, align 8
  %call26 = call i64 @PyLong_AsSsize_t(ptr noundef %21)
  store i64 %call26, ptr %ival, align 8
  %22 = load ptr, ptr %iobj, align 8
  store ptr %22, ptr %op.addr.i, align 8
  %23 = load ptr, ptr %op.addr.i, align 8
  store ptr %23, ptr %op.addr.i35, align 8
  %24 = load ptr, ptr %op.addr.i35, align 8
  %25 = load i64, ptr %24, align 8
  %conv.i = trunc i64 %25 to i32
  %cmp.i36 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i36 to i32
  %tobool.i = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then25
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.then25
  %26 = load ptr, ptr %op.addr.i, align 8
  %27 = load i64, ptr %26, align 8
  %dec.i = add i64 %27, -1
  store i64 %dec.i, ptr %26, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %28 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %28) #9
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  br label %if.end27

if.end27:                                         ; preds = %Py_DECREF.exit, %if.end21
  %29 = load i64, ptr %ival, align 8
  %cmp28 = icmp eq i64 %29, -1
  br i1 %cmp28, label %land.lhs.true29, label %if.end33

land.lhs.true29:                                  ; preds = %if.end27
  %call30 = call ptr @PyErr_Occurred()
  %tobool31 = icmp ne ptr %call30, null
  br i1 %tobool31, label %if.then32, label %if.end33

if.then32:                                        ; preds = %land.lhs.true29
  br label %exit

if.end33:                                         ; preds = %land.lhs.true29, %if.end27
  %30 = load i64, ptr %ival, align 8
  store i64 %30, ptr %maxsplit, align 8
  br label %skip_optional_pos

skip_optional_pos:                                ; preds = %if.end33, %if.then19, %if.then13
  %31 = load ptr, ptr %self.addr, align 8
  %32 = load ptr, ptr %sep, align 8
  %33 = load i64, ptr %maxsplit, align 8
  %call34 = call ptr @bytes_rsplit_impl(ptr noundef %31, ptr noundef %32, i64 noundef %33)
  store ptr %call34, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional_pos, %if.then32, %if.then
  %34 = load ptr, ptr %return_value, align 8
  ret ptr %34
}

; Function Attrs: nounwind uwtable
define internal ptr @bytes_rstrip(ptr noundef %self, ptr noundef %args, i64 noundef %nargs) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %return_value = alloca ptr, align 8
  %bytes = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  store ptr @_Py_NoneStruct, ptr %bytes, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %cmp = icmp sle i64 0, %0
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 %1, 1
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %2 = load i64, ptr %nargs.addr, align 8
  %call = call i32 @_PyArg_CheckPositional(ptr noundef @.str.92, i64 noundef %2, i64 noundef 0, i64 noundef 1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false
  br label %exit

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %3 = load i64, ptr %nargs.addr, align 8
  %cmp2 = icmp slt i64 %3, 1
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  br label %skip_optional

if.end4:                                          ; preds = %if.end
  %4 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %4, i64 0
  %5 = load ptr, ptr %arrayidx, align 8
  store ptr %5, ptr %bytes, align 8
  br label %skip_optional

skip_optional:                                    ; preds = %if.end4, %if.then3
  %6 = load ptr, ptr %self.addr, align 8
  %7 = load ptr, ptr %bytes, align 8
  %call5 = call ptr @bytes_rstrip_impl(ptr noundef %6, ptr noundef %7)
  store ptr %call5, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional, %if.then
  %8 = load ptr, ptr %return_value, align 8
  ret ptr %8
}

; Function Attrs: nounwind uwtable
define internal ptr @bytes_split(ptr noundef %self, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %op.addr.i35 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [2 x ptr], align 16
  %noptargs = alloca i64, align 8
  %sep = alloca ptr, align 8
  %maxsplit = alloca i64, align 8
  %ival = alloca i64, align 8
  %iobj = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 0
  store i64 %sub, ptr %noptargs, align 8
  store ptr @_Py_NoneStruct, ptr %sep, align 8
  store i64 -1, ptr %maxsplit, align 8
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 0, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 2
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [2 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @bytes_split._parser, i32 noundef 0, i32 noundef 2, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load i64, ptr %noptargs, align 8
  %tobool12 = icmp ne i64 %12, 0
  br i1 %tobool12, label %if.end14, label %if.then13

if.then13:                                        ; preds = %if.end
  br label %skip_optional_pos

if.end14:                                         ; preds = %if.end
  %13 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %13, i64 0
  %14 = load ptr, ptr %arrayidx, align 8
  %tobool15 = icmp ne ptr %14, null
  br i1 %tobool15, label %if.then16, label %if.end21

if.then16:                                        ; preds = %if.end14
  %15 = load ptr, ptr %args.addr, align 8
  %arrayidx17 = getelementptr ptr, ptr %15, i64 0
  %16 = load ptr, ptr %arrayidx17, align 8
  store ptr %16, ptr %sep, align 8
  %17 = load i64, ptr %noptargs, align 8
  %dec = add i64 %17, -1
  store i64 %dec, ptr %noptargs, align 8
  %tobool18 = icmp ne i64 %dec, 0
  br i1 %tobool18, label %if.end20, label %if.then19

if.then19:                                        ; preds = %if.then16
  br label %skip_optional_pos

if.end20:                                         ; preds = %if.then16
  br label %if.end21

if.end21:                                         ; preds = %if.end20, %if.end14
  store i64 -1, ptr %ival, align 8
  %18 = load ptr, ptr %args.addr, align 8
  %arrayidx22 = getelementptr ptr, ptr %18, i64 1
  %19 = load ptr, ptr %arrayidx22, align 8
  %call23 = call ptr @_PyNumber_Index(ptr noundef %19)
  store ptr %call23, ptr %iobj, align 8
  %20 = load ptr, ptr %iobj, align 8
  %cmp24 = icmp ne ptr %20, null
  br i1 %cmp24, label %if.then25, label %if.end27

if.then25:                                        ; preds = %if.end21
  %21 = load ptr, ptr %iobj, align 8
  %call26 = call i64 @PyLong_AsSsize_t(ptr noundef %21)
  store i64 %call26, ptr %ival, align 8
  %22 = load ptr, ptr %iobj, align 8
  store ptr %22, ptr %op.addr.i, align 8
  %23 = load ptr, ptr %op.addr.i, align 8
  store ptr %23, ptr %op.addr.i35, align 8
  %24 = load ptr, ptr %op.addr.i35, align 8
  %25 = load i64, ptr %24, align 8
  %conv.i = trunc i64 %25 to i32
  %cmp.i36 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i36 to i32
  %tobool.i = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then25
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.then25
  %26 = load ptr, ptr %op.addr.i, align 8
  %27 = load i64, ptr %26, align 8
  %dec.i = add i64 %27, -1
  store i64 %dec.i, ptr %26, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %28 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %28) #9
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  br label %if.end27

if.end27:                                         ; preds = %Py_DECREF.exit, %if.end21
  %29 = load i64, ptr %ival, align 8
  %cmp28 = icmp eq i64 %29, -1
  br i1 %cmp28, label %land.lhs.true29, label %if.end33

land.lhs.true29:                                  ; preds = %if.end27
  %call30 = call ptr @PyErr_Occurred()
  %tobool31 = icmp ne ptr %call30, null
  br i1 %tobool31, label %if.then32, label %if.end33

if.then32:                                        ; preds = %land.lhs.true29
  br label %exit

if.end33:                                         ; preds = %land.lhs.true29, %if.end27
  %30 = load i64, ptr %ival, align 8
  store i64 %30, ptr %maxsplit, align 8
  br label %skip_optional_pos

skip_optional_pos:                                ; preds = %if.end33, %if.then19, %if.then13
  %31 = load ptr, ptr %self.addr, align 8
  %32 = load ptr, ptr %sep, align 8
  %33 = load i64, ptr %maxsplit, align 8
  %call34 = call ptr @bytes_split_impl(ptr noundef %31, ptr noundef %32, i64 noundef %33)
  store ptr %call34, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional_pos, %if.then32, %if.then
  %34 = load ptr, ptr %return_value, align 8
  ret ptr %34
}

; Function Attrs: nounwind uwtable
define internal ptr @bytes_splitlines(ptr noundef %self, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [1 x ptr], align 8
  %noptargs = alloca i64, align 8
  %keepends = alloca i32, align 4
  store ptr %self, ptr %self.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 0
  store i64 %sub, ptr %noptargs, align 8
  store i32 0, ptr %keepends, align 4
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 0, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 1
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [1 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @bytes_splitlines._parser, i32 noundef 0, i32 noundef 1, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load i64, ptr %noptargs, align 8
  %tobool12 = icmp ne i64 %12, 0
  br i1 %tobool12, label %if.end14, label %if.then13

if.then13:                                        ; preds = %if.end
  br label %skip_optional_pos

if.end14:                                         ; preds = %if.end
  %13 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %13, i64 0
  %14 = load ptr, ptr %arrayidx, align 8
  %call15 = call i32 @PyObject_IsTrue(ptr noundef %14)
  store i32 %call15, ptr %keepends, align 4
  %15 = load i32, ptr %keepends, align 4
  %cmp16 = icmp slt i32 %15, 0
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end14
  br label %exit

if.end18:                                         ; preds = %if.end14
  br label %skip_optional_pos

skip_optional_pos:                                ; preds = %if.end18, %if.then13
  %16 = load ptr, ptr %self.addr, align 8
  %17 = load i32, ptr %keepends, align 4
  %call19 = call ptr @bytes_splitlines_impl(ptr noundef %16, i32 noundef %17)
  store ptr %call19, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional_pos, %if.then17, %if.then
  %18 = load ptr, ptr %return_value, align 8
  ret ptr %18
}

; Function Attrs: nounwind uwtable
define internal ptr @bytes_startswith(ptr noundef %self, ptr noundef %args) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %call = call ptr @PyBytes_AS_STRING(ptr noundef %0)
  %1 = load ptr, ptr %self.addr, align 8
  %call1 = call i64 @PyBytes_GET_SIZE(ptr noundef %1)
  %2 = load ptr, ptr %args.addr, align 8
  %call2 = call ptr @_Py_bytes_startswith(ptr noundef %call, i64 noundef %call1, ptr noundef %2)
  ret ptr %call2
}

; Function Attrs: nounwind uwtable
define internal ptr @bytes_strip(ptr noundef %self, ptr noundef %args, i64 noundef %nargs) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %return_value = alloca ptr, align 8
  %bytes = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr null, ptr %return_value, align 8
  store ptr @_Py_NoneStruct, ptr %bytes, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %cmp = icmp sle i64 0, %0
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 %1, 1
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %2 = load i64, ptr %nargs.addr, align 8
  %call = call i32 @_PyArg_CheckPositional(ptr noundef @.str.96, i64 noundef %2, i64 noundef 0, i64 noundef 1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false
  br label %exit

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %3 = load i64, ptr %nargs.addr, align 8
  %cmp2 = icmp slt i64 %3, 1
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  br label %skip_optional

if.end4:                                          ; preds = %if.end
  %4 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %4, i64 0
  %5 = load ptr, ptr %arrayidx, align 8
  store ptr %5, ptr %bytes, align 8
  br label %skip_optional

skip_optional:                                    ; preds = %if.end4, %if.then3
  %6 = load ptr, ptr %self.addr, align 8
  %7 = load ptr, ptr %bytes, align 8
  %call5 = call ptr @bytes_strip_impl(ptr noundef %6, ptr noundef %7)
  store ptr %call5, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional, %if.then
  %8 = load ptr, ptr %return_value, align 8
  ret ptr %8
}

; Function Attrs: nounwind uwtable
define internal ptr @stringlib_swapcase(ptr noundef %self, ptr noundef %_unused_ignored) #0 {
entry:
  %retval = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  %newobj = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %call = call i64 @PyBytes_GET_SIZE(ptr noundef %0)
  %call1 = call ptr @PyBytes_FromStringAndSize(ptr noundef null, i64 noundef %call)
  store ptr %call1, ptr %newobj, align 8
  %1 = load ptr, ptr %newobj, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %newobj, align 8
  %call2 = call ptr @PyBytes_AS_STRING(ptr noundef %2)
  %3 = load ptr, ptr %self.addr, align 8
  %call3 = call ptr @PyBytes_AS_STRING(ptr noundef %3)
  %4 = load ptr, ptr %self.addr, align 8
  %call4 = call i64 @PyBytes_GET_SIZE(ptr noundef %4)
  call void @_Py_bytes_swapcase(ptr noundef %call2, ptr noundef %call3, i64 noundef %call4)
  %5 = load ptr, ptr %newobj, align 8
  store ptr %5, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load ptr, ptr %retval, align 8
  ret ptr %6
}

; Function Attrs: nounwind uwtable
define internal ptr @stringlib_title(ptr noundef %self, ptr noundef %_unused_ignored) #0 {
entry:
  %retval = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  %newobj = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %call = call i64 @PyBytes_GET_SIZE(ptr noundef %0)
  %call1 = call ptr @PyBytes_FromStringAndSize(ptr noundef null, i64 noundef %call)
  store ptr %call1, ptr %newobj, align 8
  %1 = load ptr, ptr %newobj, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %newobj, align 8
  %call2 = call ptr @PyBytes_AS_STRING(ptr noundef %2)
  %3 = load ptr, ptr %self.addr, align 8
  %call3 = call ptr @PyBytes_AS_STRING(ptr noundef %3)
  %4 = load ptr, ptr %self.addr, align 8
  %call4 = call i64 @PyBytes_GET_SIZE(ptr noundef %4)
  call void @_Py_bytes_title(ptr noundef %call2, ptr noundef %call3, i64 noundef %call4)
  %5 = load ptr, ptr %newobj, align 8
  store ptr %5, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load ptr, ptr %retval, align 8
  ret ptr %6
}

; Function Attrs: nounwind uwtable
define internal ptr @bytes_translate(ptr noundef %self, ptr noundef %args, i64 noundef %nargs, ptr noundef %kwnames) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nargs.addr = alloca i64, align 8
  %kwnames.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %argsbuf = alloca [2 x ptr], align 16
  %noptargs = alloca i64, align 8
  %table = alloca ptr, align 8
  %deletechars = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %nargs, ptr %nargs.addr, align 8
  store ptr %kwnames, ptr %kwnames.addr, align 8
  store ptr null, ptr %return_value, align 8
  %0 = load i64, ptr %nargs.addr, align 8
  %1 = load ptr, ptr %kwnames.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %kwnames.addr, align 8
  %call = call i64 @PyTuple_GET_SIZE(ptr noundef %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  %add = add i64 %0, %cond
  %sub = sub i64 %add, 1
  store i64 %sub, ptr %noptargs, align 8
  store ptr null, ptr %deletechars, align 8
  %3 = load ptr, ptr %kwnames.addr, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false7

land.lhs.true:                                    ; preds = %cond.end
  %4 = load i64, ptr %nargs.addr, align 8
  %cmp1 = icmp sle i64 1, %4
  br i1 %cmp1, label %land.lhs.true2, label %cond.false7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load i64, ptr %nargs.addr, align 8
  %cmp3 = icmp sle i64 %5, 2
  br i1 %cmp3, label %land.lhs.true4, label %cond.false7

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load ptr, ptr %args.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %land.lhs.true4
  %7 = load ptr, ptr %args.addr, align 8
  br label %cond.end9

cond.false7:                                      ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %cond.end
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %nargs.addr, align 8
  %10 = load ptr, ptr %kwnames.addr, align 8
  %arraydecay = getelementptr inbounds [2 x ptr], ptr %argsbuf, i64 0, i64 0
  %call8 = call ptr @_PyArg_UnpackKeywords(ptr noundef %8, i64 noundef %9, ptr noundef null, ptr noundef %10, ptr noundef @bytes_translate._parser, i32 noundef 1, i32 noundef 2, i32 noundef 0, ptr noundef %arraydecay)
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi ptr [ %7, %cond.true6 ], [ %call8, %cond.false7 ]
  store ptr %cond10, ptr %args.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end9
  br label %exit

if.end:                                           ; preds = %cond.end9
  %12 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr ptr, ptr %12, i64 0
  %13 = load ptr, ptr %arrayidx, align 8
  store ptr %13, ptr %table, align 8
  %14 = load i64, ptr %noptargs, align 8
  %tobool12 = icmp ne i64 %14, 0
  br i1 %tobool12, label %if.end14, label %if.then13

if.then13:                                        ; preds = %if.end
  br label %skip_optional_pos

if.end14:                                         ; preds = %if.end
  %15 = load ptr, ptr %args.addr, align 8
  %arrayidx15 = getelementptr ptr, ptr %15, i64 1
  %16 = load ptr, ptr %arrayidx15, align 8
  store ptr %16, ptr %deletechars, align 8
  br label %skip_optional_pos

skip_optional_pos:                                ; preds = %if.end14, %if.then13
  %17 = load ptr, ptr %self.addr, align 8
  %18 = load ptr, ptr %table, align 8
  %19 = load ptr, ptr %deletechars, align 8
  %call16 = call ptr @bytes_translate_impl(ptr noundef %17, ptr noundef %18, ptr noundef %19)
  store ptr %call16, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %skip_optional_pos, %if.then
  %20 = load ptr, ptr %return_value, align 8
  ret ptr %20
}

; Function Attrs: nounwind uwtable
define internal ptr @stringlib_upper(ptr noundef %self, ptr noundef %_unused_ignored) #0 {
entry:
  %retval = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  %newobj = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %call = call i64 @PyBytes_GET_SIZE(ptr noundef %0)
  %call1 = call ptr @PyBytes_FromStringAndSize(ptr noundef null, i64 noundef %call)
  store ptr %call1, ptr %newobj, align 8
  %1 = load ptr, ptr %newobj, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %newobj, align 8
  %call2 = call ptr @PyBytes_AS_STRING(ptr noundef %2)
  %3 = load ptr, ptr %self.addr, align 8
  %call3 = call ptr @PyBytes_AS_STRING(ptr noundef %3)
  %4 = load ptr, ptr %self.addr, align 8
  %call4 = call i64 @PyBytes_GET_SIZE(ptr noundef %4)
  call void @_Py_bytes_upper(ptr noundef %call2, ptr noundef %call3, i64 noundef %call4)
  %5 = load ptr, ptr %newobj, align 8
  store ptr %5, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load ptr, ptr %retval, align 8
  ret ptr %6
}

; Function Attrs: nounwind uwtable
define internal ptr @stringlib_zfill(ptr noundef %self, ptr noundef %arg) #0 {
entry:
  %op.addr.i7 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %return_value = alloca ptr, align 8
  %width = alloca i64, align 8
  %ival = alloca i64, align 8
  %iobj = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr null, ptr %return_value, align 8
  store i64 -1, ptr %ival, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %call = call ptr @_PyNumber_Index(ptr noundef %0)
  store ptr %call, ptr %iobj, align 8
  %1 = load ptr, ptr %iobj, align 8
  %cmp = icmp ne ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %iobj, align 8
  %call1 = call i64 @PyLong_AsSsize_t(ptr noundef %2)
  store i64 %call1, ptr %ival, align 8
  %3 = load ptr, ptr %iobj, align 8
  store ptr %3, ptr %op.addr.i, align 8
  %4 = load ptr, ptr %op.addr.i, align 8
  store ptr %4, ptr %op.addr.i7, align 8
  %5 = load ptr, ptr %op.addr.i7, align 8
  %6 = load i64, ptr %5, align 8
  %conv.i = trunc i64 %6 to i32
  %cmp.i8 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i8 to i32
  %tobool.i = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.then
  %7 = load ptr, ptr %op.addr.i, align 8
  %8 = load i64, ptr %7, align 8
  %dec.i = add i64 %8, -1
  store i64 %dec.i, ptr %7, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %9 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %9) #9
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  br label %if.end

if.end:                                           ; preds = %Py_DECREF.exit, %entry
  %10 = load i64, ptr %ival, align 8
  %cmp2 = icmp eq i64 %10, -1
  br i1 %cmp2, label %land.lhs.true, label %if.end5

land.lhs.true:                                    ; preds = %if.end
  %call3 = call ptr @PyErr_Occurred()
  %tobool = icmp ne ptr %call3, null
  br i1 %tobool, label %if.then4, label %if.end5

if.then4:                                         ; preds = %land.lhs.true
  br label %exit

if.end5:                                          ; preds = %land.lhs.true, %if.end
  %11 = load i64, ptr %ival, align 8
  store i64 %11, ptr %width, align 8
  %12 = load ptr, ptr %self.addr, align 8
  %13 = load i64, ptr %width, align 8
  %call6 = call ptr @stringlib_zfill_impl(ptr noundef %12, i64 noundef %13)
  store ptr %call6, ptr %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end5, %if.then4
  %14 = load ptr, ptr %return_value, align 8
  ret ptr %14
}

declare ptr @Py_BuildValue(ptr noundef, ...) #1

; Function Attrs: nounwind uwtable
define internal ptr @bytes___bytes___impl(ptr noundef %self) #0 {
entry:
  %retval = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %call = call i32 @Py_IS_TYPE(ptr noundef %0, ptr noundef @PyBytes_Type)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %self.addr, align 8
  %call1 = call ptr @_Py_NewRef(ptr noundef %1)
  store ptr %call1, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %2 = load ptr, ptr %self.addr, align 8
  %ob_sval = getelementptr inbounds %struct.PyBytesObject, ptr %2, i32 0, i32 2
  %arraydecay = getelementptr inbounds [1 x i8], ptr %ob_sval, i64 0, i64 0
  %3 = load ptr, ptr %self.addr, align 8
  %call2 = call i64 @Py_SIZE(ptr noundef %3)
  %call3 = call ptr @PyBytes_FromStringAndSize(ptr noundef %arraydecay, i64 noundef %call2)
  store ptr %call3, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %4 = load ptr, ptr %retval, align 8
  ret ptr %4
}

declare void @_Py_bytes_capitalize(ptr noundef, ptr noundef, i64 noundef) #1

declare i32 @_PyArg_CheckPositional(ptr noundef, i64 noundef, i64 noundef, i64 noundef) #1

declare void @_PyArg_BadArgument(ptr noundef, ptr noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @stringlib_center_impl(ptr noundef %self, i64 noundef %width, i8 noundef signext %fillchar) #0 {
entry:
  %retval = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  %width.addr = alloca i64, align 8
  %fillchar.addr = alloca i8, align 1
  %marg = alloca i64, align 8
  %left = alloca i64, align 8
  store ptr %self, ptr %self.addr, align 8
  store i64 %width, ptr %width.addr, align 8
  store i8 %fillchar, ptr %fillchar.addr, align 1
  %0 = load ptr, ptr %self.addr, align 8
  %call = call i64 @PyBytes_GET_SIZE(ptr noundef %0)
  %1 = load i64, ptr %width.addr, align 8
  %cmp = icmp sge i64 %call, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %self.addr, align 8
  %call1 = call ptr @return_self(ptr noundef %2)
  store ptr %call1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load i64, ptr %width.addr, align 8
  %4 = load ptr, ptr %self.addr, align 8
  %call2 = call i64 @PyBytes_GET_SIZE(ptr noundef %4)
  %sub = sub i64 %3, %call2
  store i64 %sub, ptr %marg, align 8
  %5 = load i64, ptr %marg, align 8
  %div = sdiv i64 %5, 2
  %6 = load i64, ptr %marg, align 8
  %7 = load i64, ptr %width.addr, align 8
  %and = and i64 %6, %7
  %and3 = and i64 %and, 1
  %add = add i64 %div, %and3
  store i64 %add, ptr %left, align 8
  %8 = load ptr, ptr %self.addr, align 8
  %9 = load i64, ptr %left, align 8
  %10 = load i64, ptr %marg, align 8
  %11 = load i64, ptr %left, align 8
  %sub4 = sub i64 %10, %11
  %12 = load i8, ptr %fillchar.addr, align 1
  %call5 = call ptr @pad(ptr noundef %8, i64 noundef %9, i64 noundef %sub4, i8 noundef signext %12)
  store ptr %call5, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %13 = load ptr, ptr %retval, align 8
  ret ptr %13
}

; Function Attrs: nounwind uwtable
define internal ptr @return_self(ptr noundef %self) #0 {
entry:
  %retval = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %call = call i32 @Py_IS_TYPE(ptr noundef %0, ptr noundef @PyBytes_Type)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %self.addr, align 8
  %call1 = call ptr @_Py_NewRef(ptr noundef %1)
  store ptr %call1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %self.addr, align 8
  %call2 = call ptr @PyBytes_AS_STRING(ptr noundef %2)
  %3 = load ptr, ptr %self.addr, align 8
  %call3 = call i64 @PyBytes_GET_SIZE(ptr noundef %3)
  %call4 = call ptr @PyBytes_FromStringAndSize(ptr noundef %call2, i64 noundef %call3)
  store ptr %call4, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load ptr, ptr %retval, align 8
  ret ptr %4
}

; Function Attrs: nounwind uwtable
define internal ptr @pad(ptr noundef %self, i64 noundef %left, i64 noundef %right, i8 noundef signext %fill) #0 {
entry:
  %retval = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  %left.addr = alloca i64, align 8
  %right.addr = alloca i64, align 8
  %fill.addr = alloca i8, align 1
  %u = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store i64 %left, ptr %left.addr, align 8
  store i64 %right, ptr %right.addr, align 8
  store i8 %fill, ptr %fill.addr, align 1
  %0 = load i64, ptr %left.addr, align 8
  %cmp = icmp slt i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 0, ptr %left.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = load i64, ptr %right.addr, align 8
  %cmp1 = icmp slt i64 %1, 0
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i64 0, ptr %right.addr, align 8
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end
  %2 = load i64, ptr %left.addr, align 8
  %cmp4 = icmp eq i64 %2, 0
  br i1 %cmp4, label %land.lhs.true, label %if.end7

land.lhs.true:                                    ; preds = %if.end3
  %3 = load i64, ptr %right.addr, align 8
  %cmp5 = icmp eq i64 %3, 0
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %land.lhs.true
  %4 = load ptr, ptr %self.addr, align 8
  %call = call ptr @return_self(ptr noundef %4)
  store ptr %call, ptr %retval, align 8
  br label %return

if.end7:                                          ; preds = %land.lhs.true, %if.end3
  %5 = load i64, ptr %left.addr, align 8
  %6 = load ptr, ptr %self.addr, align 8
  %call8 = call i64 @PyBytes_GET_SIZE(ptr noundef %6)
  %add = add i64 %5, %call8
  %7 = load i64, ptr %right.addr, align 8
  %add9 = add i64 %add, %7
  %call10 = call ptr @PyBytes_FromStringAndSize(ptr noundef null, i64 noundef %add9)
  store ptr %call10, ptr %u, align 8
  %8 = load ptr, ptr %u, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.then11, label %if.end27

if.then11:                                        ; preds = %if.end7
  %9 = load i64, ptr %left.addr, align 8
  %tobool12 = icmp ne i64 %9, 0
  br i1 %tobool12, label %if.then13, label %if.end15

if.then13:                                        ; preds = %if.then11
  %10 = load ptr, ptr %u, align 8
  %call14 = call ptr @PyBytes_AS_STRING(ptr noundef %10)
  %11 = load i8, ptr %fill.addr, align 1
  %conv = sext i8 %11 to i32
  %12 = trunc i32 %conv to i8
  %13 = load i64, ptr %left.addr, align 8
  call void @llvm.memset.p0.i64(ptr align 1 %call14, i8 %12, i64 %13, i1 false)
  br label %if.end15

if.end15:                                         ; preds = %if.then13, %if.then11
  %14 = load ptr, ptr %u, align 8
  %call16 = call ptr @PyBytes_AS_STRING(ptr noundef %14)
  %15 = load i64, ptr %left.addr, align 8
  %add.ptr = getelementptr i8, ptr %call16, i64 %15
  %16 = load ptr, ptr %self.addr, align 8
  %call17 = call ptr @PyBytes_AS_STRING(ptr noundef %16)
  %17 = load ptr, ptr %self.addr, align 8
  %call18 = call i64 @PyBytes_GET_SIZE(ptr noundef %17)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %add.ptr, ptr align 1 %call17, i64 %call18, i1 false)
  %18 = load i64, ptr %right.addr, align 8
  %tobool19 = icmp ne i64 %18, 0
  br i1 %tobool19, label %if.then20, label %if.end26

if.then20:                                        ; preds = %if.end15
  %19 = load ptr, ptr %u, align 8
  %call21 = call ptr @PyBytes_AS_STRING(ptr noundef %19)
  %20 = load i64, ptr %left.addr, align 8
  %add.ptr22 = getelementptr i8, ptr %call21, i64 %20
  %21 = load ptr, ptr %self.addr, align 8
  %call23 = call i64 @PyBytes_GET_SIZE(ptr noundef %21)
  %add.ptr24 = getelementptr i8, ptr %add.ptr22, i64 %call23
  %22 = load i8, ptr %fill.addr, align 1
  %conv25 = sext i8 %22 to i32
  %23 = trunc i32 %conv25 to i8
  %24 = load i64, ptr %right.addr, align 8
  call void @llvm.memset.p0.i64(ptr align 1 %add.ptr24, i8 %23, i64 %24, i1 false)
  br label %if.end26

if.end26:                                         ; preds = %if.then20, %if.end15
  br label %if.end27

if.end27:                                         ; preds = %if.end26, %if.end7
  %25 = load ptr, ptr %u, align 8
  store ptr %25, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end27, %if.then6
  %26 = load ptr, ptr %retval, align 8
  ret ptr %26
}

declare ptr @_Py_bytes_count(ptr noundef, i64 noundef, ptr noundef) #1

declare ptr @_PyArg_UnpackKeywords(ptr noundef, i64 noundef, ptr noundef, ptr noundef, ptr noundef, i32 noundef, i32 noundef, i32 noundef, ptr noundef) #1

declare ptr @PyUnicode_AsUTF8AndSize(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @bytes_decode_impl(ptr noundef %self, ptr noundef %encoding, ptr noundef %errors) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %encoding.addr = alloca ptr, align 8
  %errors.addr = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %encoding, ptr %encoding.addr, align 8
  store ptr %errors, ptr %errors.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %1 = load ptr, ptr %encoding.addr, align 8
  %2 = load ptr, ptr %errors.addr, align 8
  %call = call ptr @PyUnicode_FromEncodedObject(ptr noundef %0, ptr noundef %1, ptr noundef %2)
  ret ptr %call
}

declare ptr @PyUnicode_FromEncodedObject(ptr noundef, ptr noundef, ptr noundef) #1

declare ptr @_Py_bytes_endswith(ptr noundef, i64 noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @stringlib_expandtabs_impl(ptr noundef %self, i32 noundef %tabsize) #0 {
entry:
  %retval = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  %tabsize.addr = alloca i32, align 4
  %e = alloca ptr, align 8
  %p = alloca ptr, align 8
  %q = alloca ptr, align 8
  %i = alloca i64, align 8
  %j = alloca i64, align 8
  %u = alloca ptr, align 8
  %incr = alloca i64, align 8
  store ptr %self, ptr %self.addr, align 8
  store i32 %tabsize, ptr %tabsize.addr, align 4
  store i64 0, ptr %j, align 8
  store i64 0, ptr %i, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %call = call ptr @PyBytes_AS_STRING(ptr noundef %0)
  %1 = load ptr, ptr %self.addr, align 8
  %call1 = call i64 @PyBytes_GET_SIZE(ptr noundef %1)
  %add.ptr = getelementptr i8, ptr %call, i64 %call1
  store ptr %add.ptr, ptr %e, align 8
  %2 = load ptr, ptr %self.addr, align 8
  %call2 = call ptr @PyBytes_AS_STRING(ptr noundef %2)
  store ptr %call2, ptr %p, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %3 = load ptr, ptr %p, align 8
  %4 = load ptr, ptr %e, align 8
  %cmp = icmp ult ptr %3, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load ptr, ptr %p, align 8
  %6 = load i8, ptr %5, align 1
  %conv = sext i8 %6 to i32
  %cmp3 = icmp eq i32 %conv, 9
  br i1 %cmp3, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  %7 = load i32, ptr %tabsize.addr, align 4
  %cmp5 = icmp sgt i32 %7, 0
  br i1 %cmp5, label %if.then7, label %if.end14

if.then7:                                         ; preds = %if.then
  %8 = load i32, ptr %tabsize.addr, align 4
  %conv8 = sext i32 %8 to i64
  %9 = load i64, ptr %j, align 8
  %10 = load i32, ptr %tabsize.addr, align 4
  %conv9 = sext i32 %10 to i64
  %rem = srem i64 %9, %conv9
  %sub = sub i64 %conv8, %rem
  store i64 %sub, ptr %incr, align 8
  %11 = load i64, ptr %j, align 8
  %12 = load i64, ptr %incr, align 8
  %sub10 = sub i64 9223372036854775807, %12
  %cmp11 = icmp sgt i64 %11, %sub10
  br i1 %cmp11, label %if.then13, label %if.end

if.then13:                                        ; preds = %if.then7
  br label %overflow

if.end:                                           ; preds = %if.then7
  %13 = load i64, ptr %incr, align 8
  %14 = load i64, ptr %j, align 8
  %add = add i64 %14, %13
  store i64 %add, ptr %j, align 8
  br label %if.end14

if.end14:                                         ; preds = %if.end, %if.then
  br label %if.end33

if.else:                                          ; preds = %for.body
  %15 = load i64, ptr %j, align 8
  %cmp15 = icmp sgt i64 %15, 9223372036854775806
  br i1 %cmp15, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.else
  br label %overflow

if.end18:                                         ; preds = %if.else
  %16 = load i64, ptr %j, align 8
  %inc = add i64 %16, 1
  store i64 %inc, ptr %j, align 8
  %17 = load ptr, ptr %p, align 8
  %18 = load i8, ptr %17, align 1
  %conv19 = sext i8 %18 to i32
  %cmp20 = icmp eq i32 %conv19, 10
  br i1 %cmp20, label %if.then25, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end18
  %19 = load ptr, ptr %p, align 8
  %20 = load i8, ptr %19, align 1
  %conv22 = sext i8 %20 to i32
  %cmp23 = icmp eq i32 %conv22, 13
  br i1 %cmp23, label %if.then25, label %if.end32

if.then25:                                        ; preds = %lor.lhs.false, %if.end18
  %21 = load i64, ptr %i, align 8
  %22 = load i64, ptr %j, align 8
  %sub26 = sub i64 9223372036854775807, %22
  %cmp27 = icmp sgt i64 %21, %sub26
  br i1 %cmp27, label %if.then29, label %if.end30

if.then29:                                        ; preds = %if.then25
  br label %overflow

if.end30:                                         ; preds = %if.then25
  %23 = load i64, ptr %j, align 8
  %24 = load i64, ptr %i, align 8
  %add31 = add i64 %24, %23
  store i64 %add31, ptr %i, align 8
  store i64 0, ptr %j, align 8
  br label %if.end32

if.end32:                                         ; preds = %if.end30, %lor.lhs.false
  br label %if.end33

if.end33:                                         ; preds = %if.end32, %if.end14
  br label %for.inc

for.inc:                                          ; preds = %if.end33
  %25 = load ptr, ptr %p, align 8
  %incdec.ptr = getelementptr i8, ptr %25, i32 1
  store ptr %incdec.ptr, ptr %p, align 8
  br label %for.cond, !llvm.loop !51

for.end:                                          ; preds = %for.cond
  %26 = load i64, ptr %i, align 8
  %27 = load i64, ptr %j, align 8
  %sub34 = sub i64 9223372036854775807, %27
  %cmp35 = icmp sgt i64 %26, %sub34
  br i1 %cmp35, label %if.then37, label %if.end38

if.then37:                                        ; preds = %for.end
  br label %overflow

if.end38:                                         ; preds = %for.end
  %28 = load i64, ptr %i, align 8
  %29 = load i64, ptr %j, align 8
  %add39 = add i64 %28, %29
  %call40 = call ptr @PyBytes_FromStringAndSize(ptr noundef null, i64 noundef %add39)
  store ptr %call40, ptr %u, align 8
  %30 = load ptr, ptr %u, align 8
  %tobool = icmp ne ptr %30, null
  br i1 %tobool, label %if.end42, label %if.then41

if.then41:                                        ; preds = %if.end38
  store ptr null, ptr %retval, align 8
  br label %return

if.end42:                                         ; preds = %if.end38
  store i64 0, ptr %j, align 8
  %31 = load ptr, ptr %u, align 8
  %call43 = call ptr @PyBytes_AS_STRING(ptr noundef %31)
  store ptr %call43, ptr %q, align 8
  %32 = load ptr, ptr %self.addr, align 8
  %call44 = call ptr @PyBytes_AS_STRING(ptr noundef %32)
  store ptr %call44, ptr %p, align 8
  br label %for.cond45

for.cond45:                                       ; preds = %for.inc77, %if.end42
  %33 = load ptr, ptr %p, align 8
  %34 = load ptr, ptr %e, align 8
  %cmp46 = icmp ult ptr %33, %34
  br i1 %cmp46, label %for.body48, label %for.end79

for.body48:                                       ; preds = %for.cond45
  %35 = load ptr, ptr %p, align 8
  %36 = load i8, ptr %35, align 1
  %conv49 = sext i8 %36 to i32
  %cmp50 = icmp eq i32 %conv49, 9
  br i1 %cmp50, label %if.then52, label %if.else64

if.then52:                                        ; preds = %for.body48
  %37 = load i32, ptr %tabsize.addr, align 4
  %cmp53 = icmp sgt i32 %37, 0
  br i1 %cmp53, label %if.then55, label %if.end63

if.then55:                                        ; preds = %if.then52
  %38 = load i32, ptr %tabsize.addr, align 4
  %conv56 = sext i32 %38 to i64
  %39 = load i64, ptr %j, align 8
  %40 = load i32, ptr %tabsize.addr, align 4
  %conv57 = sext i32 %40 to i64
  %rem58 = srem i64 %39, %conv57
  %sub59 = sub i64 %conv56, %rem58
  store i64 %sub59, ptr %i, align 8
  %41 = load i64, ptr %i, align 8
  %42 = load i64, ptr %j, align 8
  %add60 = add i64 %42, %41
  store i64 %add60, ptr %j, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then55
  %43 = load i64, ptr %i, align 8
  %dec = add i64 %43, -1
  store i64 %dec, ptr %i, align 8
  %tobool61 = icmp ne i64 %43, 0
  br i1 %tobool61, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %44 = load ptr, ptr %q, align 8
  %incdec.ptr62 = getelementptr i8, ptr %44, i32 1
  store ptr %incdec.ptr62, ptr %q, align 8
  store i8 32, ptr %44, align 1
  br label %while.cond, !llvm.loop !52

while.end:                                        ; preds = %while.cond
  br label %if.end63

if.end63:                                         ; preds = %while.end, %if.then52
  br label %if.end76

if.else64:                                        ; preds = %for.body48
  %45 = load i64, ptr %j, align 8
  %inc65 = add i64 %45, 1
  store i64 %inc65, ptr %j, align 8
  %46 = load ptr, ptr %p, align 8
  %47 = load i8, ptr %46, align 1
  %48 = load ptr, ptr %q, align 8
  %incdec.ptr66 = getelementptr i8, ptr %48, i32 1
  store ptr %incdec.ptr66, ptr %q, align 8
  store i8 %47, ptr %48, align 1
  %49 = load ptr, ptr %p, align 8
  %50 = load i8, ptr %49, align 1
  %conv67 = sext i8 %50 to i32
  %cmp68 = icmp eq i32 %conv67, 10
  br i1 %cmp68, label %if.then74, label %lor.lhs.false70

lor.lhs.false70:                                  ; preds = %if.else64
  %51 = load ptr, ptr %p, align 8
  %52 = load i8, ptr %51, align 1
  %conv71 = sext i8 %52 to i32
  %cmp72 = icmp eq i32 %conv71, 13
  br i1 %cmp72, label %if.then74, label %if.end75

if.then74:                                        ; preds = %lor.lhs.false70, %if.else64
  store i64 0, ptr %j, align 8
  br label %if.end75

if.end75:                                         ; preds = %if.then74, %lor.lhs.false70
  br label %if.end76

if.end76:                                         ; preds = %if.end75, %if.end63
  br label %for.inc77

for.inc77:                                        ; preds = %if.end76
  %53 = load ptr, ptr %p, align 8
  %incdec.ptr78 = getelementptr i8, ptr %53, i32 1
  store ptr %incdec.ptr78, ptr %p, align 8
  br label %for.cond45, !llvm.loop !53

for.end79:                                        ; preds = %for.cond45
  %54 = load ptr, ptr %u, align 8
  store ptr %54, ptr %retval, align 8
  br label %return

overflow:                                         ; preds = %if.then37, %if.then29, %if.then17, %if.then13
  %55 = load ptr, ptr @PyExc_OverflowError, align 8
  call void @PyErr_SetString(ptr noundef %55, ptr noundef @.str.112)
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %overflow, %for.end79, %if.then41
  %56 = load ptr, ptr %retval, align 8
  ret ptr %56
}

declare ptr @_Py_bytes_find(ptr noundef, i64 noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @bytes_fromhex_impl(ptr noundef %type, ptr noundef %string) #0 {
entry:
  %op.addr.i3 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %type.addr = alloca ptr, align 8
  %string.addr = alloca ptr, align 8
  %result = alloca ptr, align 8
  %_tmp_dst_ptr = alloca ptr, align 8
  %_tmp_old_dst = alloca ptr, align 8
  store ptr %type, ptr %type.addr, align 8
  store ptr %string, ptr %string.addr, align 8
  %0 = load ptr, ptr %string.addr, align 8
  %call = call ptr @_PyBytes_FromHex(ptr noundef %0, i32 noundef 0)
  store ptr %call, ptr %result, align 8
  %1 = load ptr, ptr %type.addr, align 8
  %cmp = icmp ne ptr %1, @PyBytes_Type
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %2 = load ptr, ptr %result, align 8
  %cmp1 = icmp ne ptr %2, null
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  br label %do.body

do.body:                                          ; preds = %if.then
  store ptr %result, ptr %_tmp_dst_ptr, align 8
  %3 = load ptr, ptr %_tmp_dst_ptr, align 8
  %4 = load ptr, ptr %3, align 8
  store ptr %4, ptr %_tmp_old_dst, align 8
  %5 = load ptr, ptr %type.addr, align 8
  %6 = load ptr, ptr %result, align 8
  %call2 = call ptr @PyObject_CallOneArg(ptr noundef %5, ptr noundef %6)
  %7 = load ptr, ptr %_tmp_dst_ptr, align 8
  store ptr %call2, ptr %7, align 8
  %8 = load ptr, ptr %_tmp_old_dst, align 8
  store ptr %8, ptr %op.addr.i, align 8
  %9 = load ptr, ptr %op.addr.i, align 8
  store ptr %9, ptr %op.addr.i3, align 8
  %10 = load ptr, ptr %op.addr.i3, align 8
  %11 = load i64, ptr %10, align 8
  %conv.i = trunc i64 %11 to i32
  %cmp.i4 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i4 to i32
  %tobool.i = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %do.body
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %do.body
  %12 = load ptr, ptr %op.addr.i, align 8
  %13 = load i64, ptr %12, align 8
  %dec.i = add i64 %13, -1
  store i64 %dec.i, ptr %12, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %14 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %14) #9
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  br label %do.end

do.end:                                           ; preds = %Py_DECREF.exit
  br label %if.end

if.end:                                           ; preds = %do.end, %land.lhs.true, %entry
  %15 = load ptr, ptr %result, align 8
  ret ptr %15
}

declare ptr @PyObject_CallOneArg(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @bytes_hex_impl(ptr noundef %self, ptr noundef %sep, i32 noundef %bytes_per_sep) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %sep.addr = alloca ptr, align 8
  %bytes_per_sep.addr = alloca i32, align 4
  %argbuf = alloca ptr, align 8
  %arglen = alloca i64, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %sep, ptr %sep.addr, align 8
  store i32 %bytes_per_sep, ptr %bytes_per_sep.addr, align 4
  %0 = load ptr, ptr %self.addr, align 8
  %call = call ptr @PyBytes_AS_STRING(ptr noundef %0)
  store ptr %call, ptr %argbuf, align 8
  %1 = load ptr, ptr %self.addr, align 8
  %call1 = call i64 @PyBytes_GET_SIZE(ptr noundef %1)
  store i64 %call1, ptr %arglen, align 8
  %2 = load ptr, ptr %argbuf, align 8
  %3 = load i64, ptr %arglen, align 8
  %4 = load ptr, ptr %sep.addr, align 8
  %5 = load i32, ptr %bytes_per_sep.addr, align 4
  %call2 = call ptr @_Py_strhex_with_sep(ptr noundef %2, i64 noundef %3, ptr noundef %4, i32 noundef %5)
  ret ptr %call2
}

declare ptr @_Py_strhex_with_sep(ptr noundef, i64 noundef, ptr noundef, i32 noundef) #1

declare ptr @_Py_bytes_index(ptr noundef, i64 noundef, ptr noundef) #1

declare ptr @_Py_bytes_isalnum(ptr noundef, i64 noundef) #1

declare ptr @_Py_bytes_isalpha(ptr noundef, i64 noundef) #1

declare ptr @_Py_bytes_isascii(ptr noundef, i64 noundef) #1

declare ptr @_Py_bytes_isdigit(ptr noundef, i64 noundef) #1

declare ptr @_Py_bytes_islower(ptr noundef, i64 noundef) #1

declare ptr @_Py_bytes_isspace(ptr noundef, i64 noundef) #1

declare ptr @_Py_bytes_istitle(ptr noundef, i64 noundef) #1

declare ptr @_Py_bytes_isupper(ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @stringlib_ljust_impl(ptr noundef %self, i64 noundef %width, i8 noundef signext %fillchar) #0 {
entry:
  %retval = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  %width.addr = alloca i64, align 8
  %fillchar.addr = alloca i8, align 1
  store ptr %self, ptr %self.addr, align 8
  store i64 %width, ptr %width.addr, align 8
  store i8 %fillchar, ptr %fillchar.addr, align 1
  %0 = load ptr, ptr %self.addr, align 8
  %call = call i64 @PyBytes_GET_SIZE(ptr noundef %0)
  %1 = load i64, ptr %width.addr, align 8
  %cmp = icmp sge i64 %call, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %self.addr, align 8
  %call1 = call ptr @return_self(ptr noundef %2)
  store ptr %call1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %self.addr, align 8
  %4 = load i64, ptr %width.addr, align 8
  %5 = load ptr, ptr %self.addr, align 8
  %call2 = call i64 @PyBytes_GET_SIZE(ptr noundef %5)
  %sub = sub i64 %4, %call2
  %6 = load i8, ptr %fillchar.addr, align 1
  %call3 = call ptr @pad(ptr noundef %3, i64 noundef 0, i64 noundef %sub, i8 noundef signext %6)
  store ptr %call3, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load ptr, ptr %retval, align 8
  ret ptr %7
}

declare void @_Py_bytes_lower(ptr noundef, ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @bytes_lstrip_impl(ptr noundef %self, ptr noundef %bytes) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %bytes.addr = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %bytes, ptr %bytes.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %1 = load ptr, ptr %bytes.addr, align 8
  %call = call ptr @do_argstrip(ptr noundef %0, i32 noundef 0, ptr noundef %1)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @do_argstrip(ptr noundef %self, i32 noundef %striptype, ptr noundef %bytes) #0 {
entry:
  %retval = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  %striptype.addr = alloca i32, align 4
  %bytes.addr = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store i32 %striptype, ptr %striptype.addr, align 4
  store ptr %bytes, ptr %bytes.addr, align 8
  %0 = load ptr, ptr %bytes.addr, align 8
  %cmp = icmp ne ptr %0, @_Py_NoneStruct
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %self.addr, align 8
  %2 = load i32, ptr %striptype.addr, align 4
  %3 = load ptr, ptr %bytes.addr, align 8
  %call = call ptr @do_xstrip(ptr noundef %1, i32 noundef %2, ptr noundef %3)
  store ptr %call, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %self.addr, align 8
  %5 = load i32, ptr %striptype.addr, align 4
  %call1 = call ptr @do_strip(ptr noundef %4, i32 noundef %5)
  store ptr %call1, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load ptr, ptr %retval, align 8
  ret ptr %6
}

; Function Attrs: nounwind uwtable
define internal ptr @do_xstrip(ptr noundef %self, i32 noundef %striptype, ptr noundef %sepobj) #0 {
entry:
  %retval = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  %striptype.addr = alloca i32, align 4
  %sepobj.addr = alloca ptr, align 8
  %vsep = alloca %struct.Py_buffer, align 8
  %s = alloca ptr, align 8
  %len = alloca i64, align 8
  %sep = alloca ptr, align 8
  %seplen = alloca i64, align 8
  %i = alloca i64, align 8
  %j = alloca i64, align 8
  store ptr %self, ptr %self.addr, align 8
  store i32 %striptype, ptr %striptype.addr, align 4
  store ptr %sepobj, ptr %sepobj.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %call = call ptr @PyBytes_AS_STRING(ptr noundef %0)
  store ptr %call, ptr %s, align 8
  %1 = load ptr, ptr %self.addr, align 8
  %call1 = call i64 @PyBytes_GET_SIZE(ptr noundef %1)
  store i64 %call1, ptr %len, align 8
  %2 = load ptr, ptr %sepobj.addr, align 8
  %call2 = call i32 @PyObject_GetBuffer(ptr noundef %2, ptr noundef %vsep, i32 noundef 0)
  %cmp = icmp ne i32 %call2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %buf = getelementptr inbounds %struct.Py_buffer, ptr %vsep, i32 0, i32 0
  %3 = load ptr, ptr %buf, align 8
  store ptr %3, ptr %sep, align 8
  %len3 = getelementptr inbounds %struct.Py_buffer, ptr %vsep, i32 0, i32 2
  %4 = load i64, ptr %len3, align 8
  store i64 %4, ptr %seplen, align 8
  store i64 0, ptr %i, align 8
  %5 = load i32, ptr %striptype.addr, align 4
  %cmp4 = icmp ne i32 %5, 1
  br i1 %cmp4, label %if.then5, label %if.end10

if.then5:                                         ; preds = %if.end
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then5
  %6 = load i64, ptr %i, align 8
  %7 = load i64, ptr %len, align 8
  %cmp6 = icmp slt i64 %6, %7
  br i1 %cmp6, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %8 = load ptr, ptr %sep, align 8
  %9 = load ptr, ptr %s, align 8
  %10 = load i64, ptr %i, align 8
  %arrayidx = getelementptr i8, ptr %9, i64 %10
  %11 = load i8, ptr %arrayidx, align 1
  %conv = sext i8 %11 to i32
  %and = and i32 %conv, 255
  %conv7 = trunc i32 %and to i8
  %conv8 = zext i8 %conv7 to i32
  %12 = load i64, ptr %seplen, align 8
  %call9 = call ptr @memchr(ptr noundef %8, i32 noundef %conv8, i64 noundef %12) #8
  %tobool = icmp ne ptr %call9, null
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %13 = phi i1 [ false, %while.cond ], [ %tobool, %land.rhs ]
  br i1 %13, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %14 = load i64, ptr %i, align 8
  %inc = add i64 %14, 1
  store i64 %inc, ptr %i, align 8
  br label %while.cond, !llvm.loop !54

while.end:                                        ; preds = %land.end
  br label %if.end10

if.end10:                                         ; preds = %while.end, %if.end
  %15 = load i64, ptr %len, align 8
  store i64 %15, ptr %j, align 8
  %16 = load i32, ptr %striptype.addr, align 4
  %cmp11 = icmp ne i32 %16, 0
  br i1 %cmp11, label %if.then13, label %if.end26

if.then13:                                        ; preds = %if.end10
  br label %do.body

do.body:                                          ; preds = %land.end24, %if.then13
  %17 = load i64, ptr %j, align 8
  %dec = add i64 %17, -1
  store i64 %dec, ptr %j, align 8
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %18 = load i64, ptr %j, align 8
  %19 = load i64, ptr %i, align 8
  %cmp14 = icmp sge i64 %18, %19
  br i1 %cmp14, label %land.rhs16, label %land.end24

land.rhs16:                                       ; preds = %do.cond
  %20 = load ptr, ptr %sep, align 8
  %21 = load ptr, ptr %s, align 8
  %22 = load i64, ptr %j, align 8
  %arrayidx17 = getelementptr i8, ptr %21, i64 %22
  %23 = load i8, ptr %arrayidx17, align 1
  %conv18 = sext i8 %23 to i32
  %and19 = and i32 %conv18, 255
  %conv20 = trunc i32 %and19 to i8
  %conv21 = zext i8 %conv20 to i32
  %24 = load i64, ptr %seplen, align 8
  %call22 = call ptr @memchr(ptr noundef %20, i32 noundef %conv21, i64 noundef %24) #8
  %tobool23 = icmp ne ptr %call22, null
  br label %land.end24

land.end24:                                       ; preds = %land.rhs16, %do.cond
  %25 = phi i1 [ false, %do.cond ], [ %tobool23, %land.rhs16 ]
  br i1 %25, label %do.body, label %do.end, !llvm.loop !55

do.end:                                           ; preds = %land.end24
  %26 = load i64, ptr %j, align 8
  %inc25 = add i64 %26, 1
  store i64 %inc25, ptr %j, align 8
  br label %if.end26

if.end26:                                         ; preds = %do.end, %if.end10
  call void @PyBuffer_Release(ptr noundef %vsep)
  %27 = load i64, ptr %i, align 8
  %cmp27 = icmp eq i64 %27, 0
  br i1 %cmp27, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.end26
  %28 = load i64, ptr %j, align 8
  %29 = load i64, ptr %len, align 8
  %cmp29 = icmp eq i64 %28, %29
  br i1 %cmp29, label %land.lhs.true31, label %if.else

land.lhs.true31:                                  ; preds = %land.lhs.true
  %30 = load ptr, ptr %self.addr, align 8
  %call32 = call i32 @Py_IS_TYPE(ptr noundef %30, ptr noundef @PyBytes_Type)
  %tobool33 = icmp ne i32 %call32, 0
  br i1 %tobool33, label %if.then34, label %if.else

if.then34:                                        ; preds = %land.lhs.true31
  %31 = load ptr, ptr %self.addr, align 8
  %call35 = call ptr @_Py_NewRef(ptr noundef %31)
  store ptr %call35, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %land.lhs.true31, %land.lhs.true, %if.end26
  %32 = load ptr, ptr %s, align 8
  %33 = load i64, ptr %i, align 8
  %add.ptr = getelementptr i8, ptr %32, i64 %33
  %34 = load i64, ptr %j, align 8
  %35 = load i64, ptr %i, align 8
  %sub = sub i64 %34, %35
  %call36 = call ptr @PyBytes_FromStringAndSize(ptr noundef %add.ptr, i64 noundef %sub)
  store ptr %call36, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then34, %if.then
  %36 = load ptr, ptr %retval, align 8
  ret ptr %36
}

; Function Attrs: nounwind uwtable
define internal ptr @do_strip(ptr noundef %self, i32 noundef %striptype) #0 {
entry:
  %retval = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  %striptype.addr = alloca i32, align 4
  %s = alloca ptr, align 8
  %len = alloca i64, align 8
  %i = alloca i64, align 8
  %j = alloca i64, align 8
  store ptr %self, ptr %self.addr, align 8
  store i32 %striptype, ptr %striptype.addr, align 4
  %0 = load ptr, ptr %self.addr, align 8
  %call = call ptr @PyBytes_AS_STRING(ptr noundef %0)
  store ptr %call, ptr %s, align 8
  %1 = load ptr, ptr %self.addr, align 8
  %call1 = call i64 @PyBytes_GET_SIZE(ptr noundef %1)
  store i64 %call1, ptr %len, align 8
  store i64 0, ptr %i, align 8
  %2 = load i32, ptr %striptype.addr, align 4
  %cmp = icmp ne i32 %2, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then
  %3 = load i64, ptr %i, align 8
  %4 = load i64, ptr %len, align 8
  %cmp2 = icmp slt i64 %3, %4
  br i1 %cmp2, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %5 = load ptr, ptr %s, align 8
  %6 = load i64, ptr %i, align 8
  %arrayidx = getelementptr i8, ptr %5, i64 %6
  %7 = load i8, ptr %arrayidx, align 1
  %conv = sext i8 %7 to i32
  %and = and i32 %conv, 255
  %conv3 = trunc i32 %and to i8
  %idxprom = zext i8 %conv3 to i64
  %arrayidx4 = getelementptr [256 x i32], ptr @_Py_ctype_table, i64 0, i64 %idxprom
  %8 = load i32, ptr %arrayidx4, align 4
  %and5 = and i32 %8, 8
  %tobool = icmp ne i32 %and5, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %9 = phi i1 [ false, %while.cond ], [ %tobool, %land.rhs ]
  br i1 %9, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %10 = load i64, ptr %i, align 8
  %inc = add i64 %10, 1
  store i64 %inc, ptr %i, align 8
  br label %while.cond, !llvm.loop !56

while.end:                                        ; preds = %land.end
  br label %if.end

if.end:                                           ; preds = %while.end, %entry
  %11 = load i64, ptr %len, align 8
  store i64 %11, ptr %j, align 8
  %12 = load i32, ptr %striptype.addr, align 4
  %cmp6 = icmp ne i32 %12, 0
  br i1 %cmp6, label %if.then8, label %if.end22

if.then8:                                         ; preds = %if.end
  br label %do.body

do.body:                                          ; preds = %land.end20, %if.then8
  %13 = load i64, ptr %j, align 8
  %dec = add i64 %13, -1
  store i64 %dec, ptr %j, align 8
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %14 = load i64, ptr %j, align 8
  %15 = load i64, ptr %i, align 8
  %cmp9 = icmp sge i64 %14, %15
  br i1 %cmp9, label %land.rhs11, label %land.end20

land.rhs11:                                       ; preds = %do.cond
  %16 = load ptr, ptr %s, align 8
  %17 = load i64, ptr %j, align 8
  %arrayidx12 = getelementptr i8, ptr %16, i64 %17
  %18 = load i8, ptr %arrayidx12, align 1
  %conv13 = sext i8 %18 to i32
  %and14 = and i32 %conv13, 255
  %conv15 = trunc i32 %and14 to i8
  %idxprom16 = zext i8 %conv15 to i64
  %arrayidx17 = getelementptr [256 x i32], ptr @_Py_ctype_table, i64 0, i64 %idxprom16
  %19 = load i32, ptr %arrayidx17, align 4
  %and18 = and i32 %19, 8
  %tobool19 = icmp ne i32 %and18, 0
  br label %land.end20

land.end20:                                       ; preds = %land.rhs11, %do.cond
  %20 = phi i1 [ false, %do.cond ], [ %tobool19, %land.rhs11 ]
  br i1 %20, label %do.body, label %do.end, !llvm.loop !57

do.end:                                           ; preds = %land.end20
  %21 = load i64, ptr %j, align 8
  %inc21 = add i64 %21, 1
  store i64 %inc21, ptr %j, align 8
  br label %if.end22

if.end22:                                         ; preds = %do.end, %if.end
  %22 = load i64, ptr %i, align 8
  %cmp23 = icmp eq i64 %22, 0
  br i1 %cmp23, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.end22
  %23 = load i64, ptr %j, align 8
  %24 = load i64, ptr %len, align 8
  %cmp25 = icmp eq i64 %23, %24
  br i1 %cmp25, label %land.lhs.true27, label %if.else

land.lhs.true27:                                  ; preds = %land.lhs.true
  %25 = load ptr, ptr %self.addr, align 8
  %call28 = call i32 @Py_IS_TYPE(ptr noundef %25, ptr noundef @PyBytes_Type)
  %tobool29 = icmp ne i32 %call28, 0
  br i1 %tobool29, label %if.then30, label %if.else

if.then30:                                        ; preds = %land.lhs.true27
  %26 = load ptr, ptr %self.addr, align 8
  %call31 = call ptr @_Py_NewRef(ptr noundef %26)
  store ptr %call31, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %land.lhs.true27, %land.lhs.true, %if.end22
  %27 = load ptr, ptr %s, align 8
  %28 = load i64, ptr %i, align 8
  %add.ptr = getelementptr i8, ptr %27, i64 %28
  %29 = load i64, ptr %j, align 8
  %30 = load i64, ptr %i, align 8
  %sub = sub i64 %29, %30
  %call32 = call ptr @PyBytes_FromStringAndSize(ptr noundef %add.ptr, i64 noundef %sub)
  store ptr %call32, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then30
  %31 = load ptr, ptr %retval, align 8
  ret ptr %31
}

; Function Attrs: nounwind uwtable
define internal ptr @bytes_maketrans_impl(ptr noundef %frm, ptr noundef %to) #0 {
entry:
  %frm.addr = alloca ptr, align 8
  %to.addr = alloca ptr, align 8
  store ptr %frm, ptr %frm.addr, align 8
  store ptr %to, ptr %to.addr, align 8
  %0 = load ptr, ptr %frm.addr, align 8
  %1 = load ptr, ptr %to.addr, align 8
  %call = call ptr @_Py_bytes_maketrans(ptr noundef %0, ptr noundef %1)
  ret ptr %call
}

declare ptr @_Py_bytes_maketrans(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @bytes_partition_impl(ptr noundef %self, ptr noundef %sep) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %sep.addr = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %sep, ptr %sep.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %1 = load ptr, ptr %self.addr, align 8
  %call = call ptr @PyBytes_AS_STRING(ptr noundef %1)
  %2 = load ptr, ptr %self.addr, align 8
  %call1 = call i64 @PyBytes_GET_SIZE(ptr noundef %2)
  %3 = load ptr, ptr %sep.addr, align 8
  %obj = getelementptr inbounds %struct.Py_buffer, ptr %3, i32 0, i32 1
  %4 = load ptr, ptr %obj, align 8
  %5 = load ptr, ptr %sep.addr, align 8
  %buf = getelementptr inbounds %struct.Py_buffer, ptr %5, i32 0, i32 0
  %6 = load ptr, ptr %buf, align 8
  %7 = load ptr, ptr %sep.addr, align 8
  %len = getelementptr inbounds %struct.Py_buffer, ptr %7, i32 0, i32 2
  %8 = load i64, ptr %len, align 8
  %call2 = call ptr @stringlib_partition(ptr noundef %0, ptr noundef %call, i64 noundef %call1, ptr noundef %4, ptr noundef %6, i64 noundef %8)
  ret ptr %call2
}

; Function Attrs: nounwind uwtable
define internal ptr @stringlib_partition(ptr noundef %str_obj, ptr noundef %str, i64 noundef %str_len, ptr noundef %sep_obj, ptr noundef %sep, i64 noundef %sep_len) #0 {
entry:
  %op.addr.i42 = alloca ptr, align 8
  %op.addr.i34 = alloca ptr, align 8
  %cur_refcnt.i35 = alloca i32, align 4
  %new_refcnt.i36 = alloca i32, align 4
  %op.addr.i26 = alloca ptr, align 8
  %cur_refcnt.i27 = alloca i32, align 4
  %new_refcnt.i28 = alloca i32, align 4
  %op.addr.i18 = alloca ptr, align 8
  %cur_refcnt.i19 = alloca i32, align 4
  %new_refcnt.i20 = alloca i32, align 4
  %op.addr.i14 = alloca ptr, align 8
  %cur_refcnt.i = alloca i32, align 4
  %new_refcnt.i = alloca i32, align 4
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %str_obj.addr = alloca ptr, align 8
  %str.addr = alloca ptr, align 8
  %str_len.addr = alloca i64, align 8
  %sep_obj.addr = alloca ptr, align 8
  %sep.addr = alloca ptr, align 8
  %sep_len.addr = alloca i64, align 8
  %out = alloca ptr, align 8
  %pos = alloca i64, align 8
  %empty = alloca ptr, align 8
  store ptr %str_obj, ptr %str_obj.addr, align 8
  store ptr %str, ptr %str.addr, align 8
  store i64 %str_len, ptr %str_len.addr, align 8
  store ptr %sep_obj, ptr %sep_obj.addr, align 8
  store ptr %sep, ptr %sep.addr, align 8
  store i64 %sep_len, ptr %sep_len.addr, align 8
  %0 = load i64, ptr %sep_len.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr @PyExc_ValueError, align 8
  call void @PyErr_SetString(ptr noundef %1, ptr noundef @.str.116)
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %call = call ptr @PyTuple_New(i64 noundef 3)
  store ptr %call, ptr %out, align 8
  %2 = load ptr, ptr %out, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.end2, label %if.then1

if.then1:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end2:                                          ; preds = %if.end
  %3 = load ptr, ptr %str.addr, align 8
  %4 = load i64, ptr %str_len.addr, align 8
  %5 = load ptr, ptr %sep.addr, align 8
  %6 = load i64, ptr %sep_len.addr, align 8
  %call3 = call i64 @fastsearch(ptr noundef %3, i64 noundef %4, ptr noundef %5, i64 noundef %6, i64 noundef -1, i32 noundef 1)
  store i64 %call3, ptr %pos, align 8
  %7 = load i64, ptr %pos, align 8
  %cmp4 = icmp slt i64 %7, 0
  br i1 %cmp4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end2
  %8 = load ptr, ptr %str_obj.addr, align 8
  store ptr %8, ptr %op.addr.i34, align 8
  %9 = load ptr, ptr %op.addr.i34, align 8
  %10 = load i32, ptr %9, align 8
  store i32 %10, ptr %cur_refcnt.i35, align 4
  %11 = load i32, ptr %cur_refcnt.i35, align 4
  %add.i37 = add i32 %11, 1
  store i32 %add.i37, ptr %new_refcnt.i36, align 4
  %12 = load i32, ptr %new_refcnt.i36, align 4
  %cmp.i38 = icmp eq i32 %12, 0
  br i1 %cmp.i38, label %if.then.i40, label %if.end.i39

if.then.i40:                                      ; preds = %if.then5
  br label %Py_INCREF.exit41

if.end.i39:                                       ; preds = %if.then5
  %13 = load i32, ptr %new_refcnt.i36, align 4
  %14 = load ptr, ptr %op.addr.i34, align 8
  store i32 %13, ptr %14, align 8
  br label %Py_INCREF.exit41

Py_INCREF.exit41:                                 ; preds = %if.end.i39, %if.then.i40
  %15 = load ptr, ptr %out, align 8
  %16 = load ptr, ptr %str_obj.addr, align 8
  call void @PyTuple_SET_ITEM(ptr noundef %15, i64 noundef 0, ptr noundef %16)
  %call6 = call ptr @bytes_get_empty()
  store ptr %call6, ptr %empty, align 8
  %17 = load ptr, ptr %empty, align 8
  store ptr %17, ptr %op.addr.i26, align 8
  %18 = load ptr, ptr %op.addr.i26, align 8
  %19 = load i32, ptr %18, align 8
  store i32 %19, ptr %cur_refcnt.i27, align 4
  %20 = load i32, ptr %cur_refcnt.i27, align 4
  %add.i29 = add i32 %20, 1
  store i32 %add.i29, ptr %new_refcnt.i28, align 4
  %21 = load i32, ptr %new_refcnt.i28, align 4
  %cmp.i30 = icmp eq i32 %21, 0
  br i1 %cmp.i30, label %if.then.i32, label %if.end.i31

if.then.i32:                                      ; preds = %Py_INCREF.exit41
  br label %Py_INCREF.exit33

if.end.i31:                                       ; preds = %Py_INCREF.exit41
  %22 = load i32, ptr %new_refcnt.i28, align 4
  %23 = load ptr, ptr %op.addr.i26, align 8
  store i32 %22, ptr %23, align 8
  br label %Py_INCREF.exit33

Py_INCREF.exit33:                                 ; preds = %if.end.i31, %if.then.i32
  %24 = load ptr, ptr %out, align 8
  %25 = load ptr, ptr %empty, align 8
  call void @PyTuple_SET_ITEM(ptr noundef %24, i64 noundef 1, ptr noundef %25)
  %26 = load ptr, ptr %empty, align 8
  store ptr %26, ptr %op.addr.i18, align 8
  %27 = load ptr, ptr %op.addr.i18, align 8
  %28 = load i32, ptr %27, align 8
  store i32 %28, ptr %cur_refcnt.i19, align 4
  %29 = load i32, ptr %cur_refcnt.i19, align 4
  %add.i21 = add i32 %29, 1
  store i32 %add.i21, ptr %new_refcnt.i20, align 4
  %30 = load i32, ptr %new_refcnt.i20, align 4
  %cmp.i22 = icmp eq i32 %30, 0
  br i1 %cmp.i22, label %if.then.i24, label %if.end.i23

if.then.i24:                                      ; preds = %Py_INCREF.exit33
  br label %Py_INCREF.exit25

if.end.i23:                                       ; preds = %Py_INCREF.exit33
  %31 = load i32, ptr %new_refcnt.i20, align 4
  %32 = load ptr, ptr %op.addr.i18, align 8
  store i32 %31, ptr %32, align 8
  br label %Py_INCREF.exit25

Py_INCREF.exit25:                                 ; preds = %if.end.i23, %if.then.i24
  %33 = load ptr, ptr %out, align 8
  %34 = load ptr, ptr %empty, align 8
  call void @PyTuple_SET_ITEM(ptr noundef %33, i64 noundef 2, ptr noundef %34)
  %35 = load ptr, ptr %out, align 8
  store ptr %35, ptr %retval, align 8
  br label %return

if.end7:                                          ; preds = %if.end2
  %36 = load ptr, ptr %out, align 8
  %37 = load ptr, ptr %str.addr, align 8
  %38 = load i64, ptr %pos, align 8
  %call8 = call ptr @PyBytes_FromStringAndSize(ptr noundef %37, i64 noundef %38)
  call void @PyTuple_SET_ITEM(ptr noundef %36, i64 noundef 0, ptr noundef %call8)
  %39 = load ptr, ptr %sep_obj.addr, align 8
  store ptr %39, ptr %op.addr.i14, align 8
  %40 = load ptr, ptr %op.addr.i14, align 8
  %41 = load i32, ptr %40, align 8
  store i32 %41, ptr %cur_refcnt.i, align 4
  %42 = load i32, ptr %cur_refcnt.i, align 4
  %add.i = add i32 %42, 1
  store i32 %add.i, ptr %new_refcnt.i, align 4
  %43 = load i32, ptr %new_refcnt.i, align 4
  %cmp.i15 = icmp eq i32 %43, 0
  br i1 %cmp.i15, label %if.then.i17, label %if.end.i16

if.then.i17:                                      ; preds = %if.end7
  br label %Py_INCREF.exit

if.end.i16:                                       ; preds = %if.end7
  %44 = load i32, ptr %new_refcnt.i, align 4
  %45 = load ptr, ptr %op.addr.i14, align 8
  store i32 %44, ptr %45, align 8
  br label %Py_INCREF.exit

Py_INCREF.exit:                                   ; preds = %if.end.i16, %if.then.i17
  %46 = load ptr, ptr %out, align 8
  %47 = load ptr, ptr %sep_obj.addr, align 8
  call void @PyTuple_SET_ITEM(ptr noundef %46, i64 noundef 1, ptr noundef %47)
  %48 = load i64, ptr %sep_len.addr, align 8
  %49 = load i64, ptr %pos, align 8
  %add = add i64 %49, %48
  store i64 %add, ptr %pos, align 8
  %50 = load ptr, ptr %out, align 8
  %51 = load ptr, ptr %str.addr, align 8
  %52 = load i64, ptr %pos, align 8
  %add.ptr = getelementptr i8, ptr %51, i64 %52
  %53 = load i64, ptr %str_len.addr, align 8
  %54 = load i64, ptr %pos, align 8
  %sub = sub i64 %53, %54
  %call9 = call ptr @PyBytes_FromStringAndSize(ptr noundef %add.ptr, i64 noundef %sub)
  call void @PyTuple_SET_ITEM(ptr noundef %50, i64 noundef 2, ptr noundef %call9)
  %call10 = call ptr @PyErr_Occurred()
  %tobool11 = icmp ne ptr %call10, null
  br i1 %tobool11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %Py_INCREF.exit
  %55 = load ptr, ptr %out, align 8
  store ptr %55, ptr %op.addr.i, align 8
  %56 = load ptr, ptr %op.addr.i, align 8
  store ptr %56, ptr %op.addr.i42, align 8
  %57 = load ptr, ptr %op.addr.i42, align 8
  %58 = load i64, ptr %57, align 8
  %conv.i = trunc i64 %58 to i32
  %cmp.i43 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i43 to i32
  %tobool.i = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then12
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.then12
  %59 = load ptr, ptr %op.addr.i, align 8
  %60 = load i64, ptr %59, align 8
  %dec.i = add i64 %60, -1
  store i64 %dec.i, ptr %59, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %61 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %61) #9
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  store ptr null, ptr %retval, align 8
  br label %return

if.end13:                                         ; preds = %Py_INCREF.exit
  %62 = load ptr, ptr %out, align 8
  store ptr %62, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end13, %Py_DECREF.exit, %Py_INCREF.exit25, %if.then1, %if.then
  %63 = load ptr, ptr %retval, align 8
  ret ptr %63
}

declare ptr @PyTuple_New(i64 noundef) #1

; Function Attrs: nounwind uwtable
define internal void @PyTuple_SET_ITEM(ptr noundef %op, i64 noundef %index, ptr noundef %value) #0 {
entry:
  %op.addr = alloca ptr, align 8
  %index.addr = alloca i64, align 8
  %value.addr = alloca ptr, align 8
  %tuple = alloca ptr, align 8
  store ptr %op, ptr %op.addr, align 8
  store i64 %index, ptr %index.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  %0 = load ptr, ptr %op.addr, align 8
  store ptr %0, ptr %tuple, align 8
  %1 = load ptr, ptr %value.addr, align 8
  %2 = load ptr, ptr %tuple, align 8
  %ob_item = getelementptr inbounds %struct.PyTupleObject, ptr %2, i32 0, i32 1
  %3 = load i64, ptr %index.addr, align 8
  %arrayidx = getelementptr [1 x ptr], ptr %ob_item, i64 0, i64 %3
  store ptr %1, ptr %arrayidx, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal ptr @bytes_replace_impl(ptr noundef %self, ptr noundef %old, ptr noundef %new, i64 noundef %count) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %old.addr = alloca ptr, align 8
  %new.addr = alloca ptr, align 8
  %count.addr = alloca i64, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %old, ptr %old.addr, align 8
  store ptr %new, ptr %new.addr, align 8
  store i64 %count, ptr %count.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %1 = load ptr, ptr %old.addr, align 8
  %buf = getelementptr inbounds %struct.Py_buffer, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %buf, align 8
  %3 = load ptr, ptr %old.addr, align 8
  %len = getelementptr inbounds %struct.Py_buffer, ptr %3, i32 0, i32 2
  %4 = load i64, ptr %len, align 8
  %5 = load ptr, ptr %new.addr, align 8
  %buf1 = getelementptr inbounds %struct.Py_buffer, ptr %5, i32 0, i32 0
  %6 = load ptr, ptr %buf1, align 8
  %7 = load ptr, ptr %new.addr, align 8
  %len2 = getelementptr inbounds %struct.Py_buffer, ptr %7, i32 0, i32 2
  %8 = load i64, ptr %len2, align 8
  %9 = load i64, ptr %count.addr, align 8
  %call = call ptr @stringlib_replace(ptr noundef %0, ptr noundef %2, i64 noundef %4, ptr noundef %6, i64 noundef %8, i64 noundef %9)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @stringlib_replace(ptr noundef %self, ptr noundef %from_s, i64 noundef %from_len, ptr noundef %to_s, i64 noundef %to_len, i64 noundef %maxcount) #0 {
entry:
  %retval = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  %from_s.addr = alloca ptr, align 8
  %from_len.addr = alloca i64, align 8
  %to_s.addr = alloca ptr, align 8
  %to_len.addr = alloca i64, align 8
  %maxcount.addr = alloca i64, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %from_s, ptr %from_s.addr, align 8
  store i64 %from_len, ptr %from_len.addr, align 8
  store ptr %to_s, ptr %to_s.addr, align 8
  store i64 %to_len, ptr %to_len.addr, align 8
  store i64 %maxcount, ptr %maxcount.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %call = call i64 @PyBytes_GET_SIZE(ptr noundef %0)
  %1 = load i64, ptr %from_len.addr, align 8
  %cmp = icmp slt i64 %call, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %self.addr, align 8
  %call1 = call ptr @return_self(ptr noundef %2)
  store ptr %call1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load i64, ptr %maxcount.addr, align 8
  %cmp2 = icmp slt i64 %3, 0
  br i1 %cmp2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  store i64 9223372036854775807, ptr %maxcount.addr, align 8
  br label %if.end8

if.else:                                          ; preds = %if.end
  %4 = load i64, ptr %maxcount.addr, align 8
  %cmp4 = icmp eq i64 %4, 0
  br i1 %cmp4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.else
  %5 = load ptr, ptr %self.addr, align 8
  %call6 = call ptr @return_self(ptr noundef %5)
  store ptr %call6, ptr %retval, align 8
  br label %return

if.end7:                                          ; preds = %if.else
  br label %if.end8

if.end8:                                          ; preds = %if.end7, %if.then3
  %6 = load i64, ptr %from_len.addr, align 8
  %cmp9 = icmp eq i64 %6, 0
  br i1 %cmp9, label %if.then10, label %if.end16

if.then10:                                        ; preds = %if.end8
  %7 = load i64, ptr %to_len.addr, align 8
  %cmp11 = icmp eq i64 %7, 0
  br i1 %cmp11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %if.then10
  %8 = load ptr, ptr %self.addr, align 8
  %call13 = call ptr @return_self(ptr noundef %8)
  store ptr %call13, ptr %retval, align 8
  br label %return

if.end14:                                         ; preds = %if.then10
  %9 = load ptr, ptr %self.addr, align 8
  %10 = load ptr, ptr %to_s.addr, align 8
  %11 = load i64, ptr %to_len.addr, align 8
  %12 = load i64, ptr %maxcount.addr, align 8
  %call15 = call ptr @stringlib_replace_interleave(ptr noundef %9, ptr noundef %10, i64 noundef %11, i64 noundef %12)
  store ptr %call15, ptr %retval, align 8
  br label %return

if.end16:                                         ; preds = %if.end8
  %13 = load i64, ptr %to_len.addr, align 8
  %cmp17 = icmp eq i64 %13, 0
  br i1 %cmp17, label %if.then18, label %if.end24

if.then18:                                        ; preds = %if.end16
  %14 = load i64, ptr %from_len.addr, align 8
  %cmp19 = icmp eq i64 %14, 1
  br i1 %cmp19, label %if.then20, label %if.else22

if.then20:                                        ; preds = %if.then18
  %15 = load ptr, ptr %self.addr, align 8
  %16 = load ptr, ptr %from_s.addr, align 8
  %arrayidx = getelementptr i8, ptr %16, i64 0
  %17 = load i8, ptr %arrayidx, align 1
  %18 = load i64, ptr %maxcount.addr, align 8
  %call21 = call ptr @stringlib_replace_delete_single_character(ptr noundef %15, i8 noundef signext %17, i64 noundef %18)
  store ptr %call21, ptr %retval, align 8
  br label %return

if.else22:                                        ; preds = %if.then18
  %19 = load ptr, ptr %self.addr, align 8
  %20 = load ptr, ptr %from_s.addr, align 8
  %21 = load i64, ptr %from_len.addr, align 8
  %22 = load i64, ptr %maxcount.addr, align 8
  %call23 = call ptr @stringlib_replace_delete_substring(ptr noundef %19, ptr noundef %20, i64 noundef %21, i64 noundef %22)
  store ptr %call23, ptr %retval, align 8
  br label %return

if.end24:                                         ; preds = %if.end16
  %23 = load i64, ptr %from_len.addr, align 8
  %24 = load i64, ptr %to_len.addr, align 8
  %cmp25 = icmp eq i64 %23, %24
  br i1 %cmp25, label %if.then26, label %if.end34

if.then26:                                        ; preds = %if.end24
  %25 = load i64, ptr %from_len.addr, align 8
  %cmp27 = icmp eq i64 %25, 1
  br i1 %cmp27, label %if.then28, label %if.else32

if.then28:                                        ; preds = %if.then26
  %26 = load ptr, ptr %self.addr, align 8
  %27 = load ptr, ptr %from_s.addr, align 8
  %arrayidx29 = getelementptr i8, ptr %27, i64 0
  %28 = load i8, ptr %arrayidx29, align 1
  %29 = load ptr, ptr %to_s.addr, align 8
  %arrayidx30 = getelementptr i8, ptr %29, i64 0
  %30 = load i8, ptr %arrayidx30, align 1
  %31 = load i64, ptr %maxcount.addr, align 8
  %call31 = call ptr @stringlib_replace_single_character_in_place(ptr noundef %26, i8 noundef signext %28, i8 noundef signext %30, i64 noundef %31)
  store ptr %call31, ptr %retval, align 8
  br label %return

if.else32:                                        ; preds = %if.then26
  %32 = load ptr, ptr %self.addr, align 8
  %33 = load ptr, ptr %from_s.addr, align 8
  %34 = load i64, ptr %from_len.addr, align 8
  %35 = load ptr, ptr %to_s.addr, align 8
  %36 = load i64, ptr %to_len.addr, align 8
  %37 = load i64, ptr %maxcount.addr, align 8
  %call33 = call ptr @stringlib_replace_substring_in_place(ptr noundef %32, ptr noundef %33, i64 noundef %34, ptr noundef %35, i64 noundef %36, i64 noundef %37)
  store ptr %call33, ptr %retval, align 8
  br label %return

if.end34:                                         ; preds = %if.end24
  %38 = load i64, ptr %from_len.addr, align 8
  %cmp35 = icmp eq i64 %38, 1
  br i1 %cmp35, label %if.then36, label %if.else39

if.then36:                                        ; preds = %if.end34
  %39 = load ptr, ptr %self.addr, align 8
  %40 = load ptr, ptr %from_s.addr, align 8
  %arrayidx37 = getelementptr i8, ptr %40, i64 0
  %41 = load i8, ptr %arrayidx37, align 1
  %42 = load ptr, ptr %to_s.addr, align 8
  %43 = load i64, ptr %to_len.addr, align 8
  %44 = load i64, ptr %maxcount.addr, align 8
  %call38 = call ptr @stringlib_replace_single_character(ptr noundef %39, i8 noundef signext %41, ptr noundef %42, i64 noundef %43, i64 noundef %44)
  store ptr %call38, ptr %retval, align 8
  br label %return

if.else39:                                        ; preds = %if.end34
  %45 = load ptr, ptr %self.addr, align 8
  %46 = load ptr, ptr %from_s.addr, align 8
  %47 = load i64, ptr %from_len.addr, align 8
  %48 = load ptr, ptr %to_s.addr, align 8
  %49 = load i64, ptr %to_len.addr, align 8
  %50 = load i64, ptr %maxcount.addr, align 8
  %call40 = call ptr @stringlib_replace_substring(ptr noundef %45, ptr noundef %46, i64 noundef %47, ptr noundef %48, i64 noundef %49, i64 noundef %50)
  store ptr %call40, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else39, %if.then36, %if.else32, %if.then28, %if.else22, %if.then20, %if.end14, %if.then12, %if.then5, %if.then
  %51 = load ptr, ptr %retval, align 8
  ret ptr %51
}

; Function Attrs: nounwind uwtable
define internal ptr @stringlib_replace_interleave(ptr noundef %self, ptr noundef %to_s, i64 noundef %to_len, i64 noundef %maxcount) #0 {
entry:
  %retval = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  %to_s.addr = alloca ptr, align 8
  %to_len.addr = alloca i64, align 8
  %maxcount.addr = alloca i64, align 8
  %self_s = alloca ptr, align 8
  %result_s = alloca ptr, align 8
  %self_len = alloca i64, align 8
  %result_len = alloca i64, align 8
  %count = alloca i64, align 8
  %i = alloca i64, align 8
  %result = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %to_s, ptr %to_s.addr, align 8
  store i64 %to_len, ptr %to_len.addr, align 8
  store i64 %maxcount, ptr %maxcount.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %call = call i64 @PyBytes_GET_SIZE(ptr noundef %0)
  store i64 %call, ptr %self_len, align 8
  %1 = load i64, ptr %maxcount.addr, align 8
  %2 = load i64, ptr %self_len, align 8
  %cmp = icmp sle i64 %1, %2
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load i64, ptr %maxcount.addr, align 8
  store i64 %3, ptr %count, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %4 = load i64, ptr %self_len, align 8
  %add = add i64 %4, 1
  store i64 %add, ptr %count, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %5 = load i64, ptr %to_len.addr, align 8
  %6 = load i64, ptr %self_len, align 8
  %sub = sub i64 9223372036854775807, %6
  %7 = load i64, ptr %count, align 8
  %div = sdiv i64 %sub, %7
  %cmp1 = icmp sgt i64 %5, %div
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %8 = load ptr, ptr @PyExc_OverflowError, align 8
  call void @PyErr_SetString(ptr noundef %8, ptr noundef @.str.117)
  store ptr null, ptr %retval, align 8
  br label %return

if.end3:                                          ; preds = %if.end
  %9 = load i64, ptr %count, align 8
  %10 = load i64, ptr %to_len.addr, align 8
  %mul = mul i64 %9, %10
  %11 = load i64, ptr %self_len, align 8
  %add4 = add i64 %mul, %11
  store i64 %add4, ptr %result_len, align 8
  %12 = load i64, ptr %result_len, align 8
  %call5 = call ptr @PyBytes_FromStringAndSize(ptr noundef null, i64 noundef %12)
  store ptr %call5, ptr %result, align 8
  %13 = load ptr, ptr %result, align 8
  %cmp6 = icmp eq ptr %13, null
  br i1 %cmp6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end3
  store ptr null, ptr %retval, align 8
  br label %return

if.end8:                                          ; preds = %if.end3
  %14 = load ptr, ptr %self.addr, align 8
  %call9 = call ptr @PyBytes_AS_STRING(ptr noundef %14)
  store ptr %call9, ptr %self_s, align 8
  %15 = load ptr, ptr %result, align 8
  %call10 = call ptr @PyBytes_AS_STRING(ptr noundef %15)
  store ptr %call10, ptr %result_s, align 8
  %16 = load i64, ptr %to_len.addr, align 8
  %cmp11 = icmp sgt i64 %16, 1
  br i1 %cmp11, label %if.then12, label %if.else17

if.then12:                                        ; preds = %if.end8
  %17 = load ptr, ptr %result_s, align 8
  %18 = load ptr, ptr %to_s.addr, align 8
  %19 = load i64, ptr %to_len.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %17, ptr align 1 %18, i64 %19, i1 false)
  %20 = load i64, ptr %to_len.addr, align 8
  %21 = load ptr, ptr %result_s, align 8
  %add.ptr = getelementptr i8, ptr %21, i64 %20
  store ptr %add.ptr, ptr %result_s, align 8
  %22 = load i64, ptr %count, align 8
  %sub13 = sub i64 %22, 1
  store i64 %sub13, ptr %count, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then12
  %23 = load i64, ptr %i, align 8
  %24 = load i64, ptr %count, align 8
  %cmp14 = icmp slt i64 %23, %24
  br i1 %cmp14, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %25 = load ptr, ptr %self_s, align 8
  %incdec.ptr = getelementptr i8, ptr %25, i32 1
  store ptr %incdec.ptr, ptr %self_s, align 8
  %26 = load i8, ptr %25, align 1
  %27 = load ptr, ptr %result_s, align 8
  %incdec.ptr15 = getelementptr i8, ptr %27, i32 1
  store ptr %incdec.ptr15, ptr %result_s, align 8
  store i8 %26, ptr %27, align 1
  %28 = load ptr, ptr %result_s, align 8
  %29 = load ptr, ptr %to_s.addr, align 8
  %30 = load i64, ptr %to_len.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %28, ptr align 1 %29, i64 %30, i1 false)
  %31 = load i64, ptr %to_len.addr, align 8
  %32 = load ptr, ptr %result_s, align 8
  %add.ptr16 = getelementptr i8, ptr %32, i64 %31
  store ptr %add.ptr16, ptr %result_s, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %33 = load i64, ptr %i, align 8
  %inc = add i64 %33, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !58

for.end:                                          ; preds = %for.cond
  br label %if.end32

if.else17:                                        ; preds = %if.end8
  %34 = load ptr, ptr %to_s.addr, align 8
  %arrayidx = getelementptr i8, ptr %34, i64 0
  %35 = load i8, ptr %arrayidx, align 1
  %36 = load ptr, ptr %result_s, align 8
  %arrayidx18 = getelementptr i8, ptr %36, i64 0
  store i8 %35, ptr %arrayidx18, align 1
  %37 = load i64, ptr %to_len.addr, align 8
  %38 = load ptr, ptr %result_s, align 8
  %add.ptr19 = getelementptr i8, ptr %38, i64 %37
  store ptr %add.ptr19, ptr %result_s, align 8
  %39 = load i64, ptr %count, align 8
  %sub20 = sub i64 %39, 1
  store i64 %sub20, ptr %count, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond21

for.cond21:                                       ; preds = %for.inc29, %if.else17
  %40 = load i64, ptr %i, align 8
  %41 = load i64, ptr %count, align 8
  %cmp22 = icmp slt i64 %40, %41
  br i1 %cmp22, label %for.body23, label %for.end31

for.body23:                                       ; preds = %for.cond21
  %42 = load ptr, ptr %self_s, align 8
  %incdec.ptr24 = getelementptr i8, ptr %42, i32 1
  store ptr %incdec.ptr24, ptr %self_s, align 8
  %43 = load i8, ptr %42, align 1
  %44 = load ptr, ptr %result_s, align 8
  %incdec.ptr25 = getelementptr i8, ptr %44, i32 1
  store ptr %incdec.ptr25, ptr %result_s, align 8
  store i8 %43, ptr %44, align 1
  %45 = load ptr, ptr %to_s.addr, align 8
  %arrayidx26 = getelementptr i8, ptr %45, i64 0
  %46 = load i8, ptr %arrayidx26, align 1
  %47 = load ptr, ptr %result_s, align 8
  %arrayidx27 = getelementptr i8, ptr %47, i64 0
  store i8 %46, ptr %arrayidx27, align 1
  %48 = load i64, ptr %to_len.addr, align 8
  %49 = load ptr, ptr %result_s, align 8
  %add.ptr28 = getelementptr i8, ptr %49, i64 %48
  store ptr %add.ptr28, ptr %result_s, align 8
  br label %for.inc29

for.inc29:                                        ; preds = %for.body23
  %50 = load i64, ptr %i, align 8
  %inc30 = add i64 %50, 1
  store i64 %inc30, ptr %i, align 8
  br label %for.cond21, !llvm.loop !59

for.end31:                                        ; preds = %for.cond21
  br label %if.end32

if.end32:                                         ; preds = %for.end31, %for.end
  %51 = load ptr, ptr %result_s, align 8
  %52 = load ptr, ptr %self_s, align 8
  %53 = load i64, ptr %self_len, align 8
  %54 = load i64, ptr %i, align 8
  %sub33 = sub i64 %53, %54
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %51, ptr align 1 %52, i64 %sub33, i1 false)
  %55 = load ptr, ptr %result, align 8
  store ptr %55, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end32, %if.then7, %if.then2
  %56 = load ptr, ptr %retval, align 8
  ret ptr %56
}

; Function Attrs: nounwind uwtable
define internal ptr @stringlib_replace_delete_single_character(ptr noundef %self, i8 noundef signext %from_c, i64 noundef %maxcount) #0 {
entry:
  %retval = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  %from_c.addr = alloca i8, align 1
  %maxcount.addr = alloca i64, align 8
  %self_s = alloca ptr, align 8
  %start = alloca ptr, align 8
  %next = alloca ptr, align 8
  %end = alloca ptr, align 8
  %result_s = alloca ptr, align 8
  %self_len = alloca i64, align 8
  %result_len = alloca i64, align 8
  %count = alloca i64, align 8
  %result = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store i8 %from_c, ptr %from_c.addr, align 1
  store i64 %maxcount, ptr %maxcount.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %call = call i64 @PyBytes_GET_SIZE(ptr noundef %0)
  store i64 %call, ptr %self_len, align 8
  %1 = load ptr, ptr %self.addr, align 8
  %call1 = call ptr @PyBytes_AS_STRING(ptr noundef %1)
  store ptr %call1, ptr %self_s, align 8
  %2 = load ptr, ptr %self_s, align 8
  %3 = load i64, ptr %self_len, align 8
  %4 = load i8, ptr %from_c.addr, align 1
  %5 = load i64, ptr %maxcount.addr, align 8
  %call2 = call i64 @countchar(ptr noundef %2, i64 noundef %3, i8 noundef signext %4, i64 noundef %5)
  store i64 %call2, ptr %count, align 8
  %6 = load i64, ptr %count, align 8
  %cmp = icmp eq i64 %6, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %7 = load ptr, ptr %self.addr, align 8
  %call3 = call ptr @return_self(ptr noundef %7)
  store ptr %call3, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %8 = load i64, ptr %self_len, align 8
  %9 = load i64, ptr %count, align 8
  %sub = sub i64 %8, %9
  store i64 %sub, ptr %result_len, align 8
  %10 = load i64, ptr %result_len, align 8
  %call4 = call ptr @PyBytes_FromStringAndSize(ptr noundef null, i64 noundef %10)
  store ptr %call4, ptr %result, align 8
  %11 = load ptr, ptr %result, align 8
  %cmp5 = icmp eq ptr %11, null
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end7:                                          ; preds = %if.end
  %12 = load ptr, ptr %result, align 8
  %call8 = call ptr @PyBytes_AS_STRING(ptr noundef %12)
  store ptr %call8, ptr %result_s, align 8
  %13 = load ptr, ptr %self_s, align 8
  store ptr %13, ptr %start, align 8
  %14 = load ptr, ptr %self_s, align 8
  %15 = load i64, ptr %self_len, align 8
  %add.ptr = getelementptr i8, ptr %14, i64 %15
  store ptr %add.ptr, ptr %end, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end14, %if.end7
  %16 = load i64, ptr %count, align 8
  %dec = add i64 %16, -1
  store i64 %dec, ptr %count, align 8
  %cmp9 = icmp sgt i64 %16, 0
  br i1 %cmp9, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %17 = load ptr, ptr %start, align 8
  %18 = load i8, ptr %from_c.addr, align 1
  %conv = sext i8 %18 to i32
  %19 = load ptr, ptr %end, align 8
  %20 = load ptr, ptr %start, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %19 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %20 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %call10 = call ptr @memchr(ptr noundef %17, i32 noundef %conv, i64 noundef %sub.ptr.sub) #8
  store ptr %call10, ptr %next, align 8
  %21 = load ptr, ptr %next, align 8
  %cmp11 = icmp eq ptr %21, null
  br i1 %cmp11, label %if.then13, label %if.end14

if.then13:                                        ; preds = %while.body
  br label %while.end

if.end14:                                         ; preds = %while.body
  %22 = load ptr, ptr %result_s, align 8
  %23 = load ptr, ptr %start, align 8
  %24 = load ptr, ptr %next, align 8
  %25 = load ptr, ptr %start, align 8
  %sub.ptr.lhs.cast15 = ptrtoint ptr %24 to i64
  %sub.ptr.rhs.cast16 = ptrtoint ptr %25 to i64
  %sub.ptr.sub17 = sub i64 %sub.ptr.lhs.cast15, %sub.ptr.rhs.cast16
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %22, ptr align 1 %23, i64 %sub.ptr.sub17, i1 false)
  %26 = load ptr, ptr %next, align 8
  %27 = load ptr, ptr %start, align 8
  %sub.ptr.lhs.cast18 = ptrtoint ptr %26 to i64
  %sub.ptr.rhs.cast19 = ptrtoint ptr %27 to i64
  %sub.ptr.sub20 = sub i64 %sub.ptr.lhs.cast18, %sub.ptr.rhs.cast19
  %28 = load ptr, ptr %result_s, align 8
  %add.ptr21 = getelementptr i8, ptr %28, i64 %sub.ptr.sub20
  store ptr %add.ptr21, ptr %result_s, align 8
  %29 = load ptr, ptr %next, align 8
  %add.ptr22 = getelementptr i8, ptr %29, i64 1
  store ptr %add.ptr22, ptr %start, align 8
  br label %while.cond, !llvm.loop !60

while.end:                                        ; preds = %if.then13, %while.cond
  %30 = load ptr, ptr %result_s, align 8
  %31 = load ptr, ptr %start, align 8
  %32 = load ptr, ptr %end, align 8
  %33 = load ptr, ptr %start, align 8
  %sub.ptr.lhs.cast23 = ptrtoint ptr %32 to i64
  %sub.ptr.rhs.cast24 = ptrtoint ptr %33 to i64
  %sub.ptr.sub25 = sub i64 %sub.ptr.lhs.cast23, %sub.ptr.rhs.cast24
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %30, ptr align 1 %31, i64 %sub.ptr.sub25, i1 false)
  %34 = load ptr, ptr %result, align 8
  store ptr %34, ptr %retval, align 8
  br label %return

return:                                           ; preds = %while.end, %if.then6, %if.then
  %35 = load ptr, ptr %retval, align 8
  ret ptr %35
}

; Function Attrs: nounwind uwtable
define internal ptr @stringlib_replace_delete_substring(ptr noundef %self, ptr noundef %from_s, i64 noundef %from_len, i64 noundef %maxcount) #0 {
entry:
  %retval = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  %from_s.addr = alloca ptr, align 8
  %from_len.addr = alloca i64, align 8
  %maxcount.addr = alloca i64, align 8
  %self_s = alloca ptr, align 8
  %start = alloca ptr, align 8
  %next = alloca ptr, align 8
  %end = alloca ptr, align 8
  %result_s = alloca ptr, align 8
  %self_len = alloca i64, align 8
  %result_len = alloca i64, align 8
  %count = alloca i64, align 8
  %offset = alloca i64, align 8
  %result = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %from_s, ptr %from_s.addr, align 8
  store i64 %from_len, ptr %from_len.addr, align 8
  store i64 %maxcount, ptr %maxcount.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %call = call i64 @PyBytes_GET_SIZE(ptr noundef %0)
  store i64 %call, ptr %self_len, align 8
  %1 = load ptr, ptr %self.addr, align 8
  %call1 = call ptr @PyBytes_AS_STRING(ptr noundef %1)
  store ptr %call1, ptr %self_s, align 8
  %2 = load ptr, ptr %self_s, align 8
  %3 = load i64, ptr %self_len, align 8
  %4 = load ptr, ptr %from_s.addr, align 8
  %5 = load i64, ptr %from_len.addr, align 8
  %6 = load i64, ptr %maxcount.addr, align 8
  %call2 = call i64 @stringlib_count(ptr noundef %2, i64 noundef %3, ptr noundef %4, i64 noundef %5, i64 noundef %6)
  store i64 %call2, ptr %count, align 8
  %7 = load i64, ptr %count, align 8
  %cmp = icmp eq i64 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %8 = load ptr, ptr %self.addr, align 8
  %call3 = call ptr @return_self(ptr noundef %8)
  store ptr %call3, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %9 = load i64, ptr %self_len, align 8
  %10 = load i64, ptr %count, align 8
  %11 = load i64, ptr %from_len.addr, align 8
  %mul = mul i64 %10, %11
  %sub = sub i64 %9, %mul
  store i64 %sub, ptr %result_len, align 8
  %12 = load i64, ptr %result_len, align 8
  %call4 = call ptr @PyBytes_FromStringAndSize(ptr noundef null, i64 noundef %12)
  store ptr %call4, ptr %result, align 8
  %13 = load ptr, ptr %result, align 8
  %cmp5 = icmp eq ptr %13, null
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end7:                                          ; preds = %if.end
  %14 = load ptr, ptr %result, align 8
  %call8 = call ptr @PyBytes_AS_STRING(ptr noundef %14)
  store ptr %call8, ptr %result_s, align 8
  %15 = load ptr, ptr %self_s, align 8
  store ptr %15, ptr %start, align 8
  %16 = load ptr, ptr %self_s, align 8
  %17 = load i64, ptr %self_len, align 8
  %add.ptr = getelementptr i8, ptr %16, i64 %17
  store ptr %add.ptr, ptr %end, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end13, %if.end7
  %18 = load i64, ptr %count, align 8
  %dec = add i64 %18, -1
  store i64 %dec, ptr %count, align 8
  %cmp9 = icmp sgt i64 %18, 0
  br i1 %cmp9, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %19 = load ptr, ptr %start, align 8
  %20 = load ptr, ptr %end, align 8
  %21 = load ptr, ptr %start, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %20 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %21 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %22 = load ptr, ptr %from_s.addr, align 8
  %23 = load i64, ptr %from_len.addr, align 8
  %call10 = call i64 @stringlib_find(ptr noundef %19, i64 noundef %sub.ptr.sub, ptr noundef %22, i64 noundef %23, i64 noundef 0)
  store i64 %call10, ptr %offset, align 8
  %24 = load i64, ptr %offset, align 8
  %cmp11 = icmp eq i64 %24, -1
  br i1 %cmp11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %while.body
  br label %while.end

if.end13:                                         ; preds = %while.body
  %25 = load ptr, ptr %start, align 8
  %26 = load i64, ptr %offset, align 8
  %add.ptr14 = getelementptr i8, ptr %25, i64 %26
  store ptr %add.ptr14, ptr %next, align 8
  %27 = load ptr, ptr %result_s, align 8
  %28 = load ptr, ptr %start, align 8
  %29 = load ptr, ptr %next, align 8
  %30 = load ptr, ptr %start, align 8
  %sub.ptr.lhs.cast15 = ptrtoint ptr %29 to i64
  %sub.ptr.rhs.cast16 = ptrtoint ptr %30 to i64
  %sub.ptr.sub17 = sub i64 %sub.ptr.lhs.cast15, %sub.ptr.rhs.cast16
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %27, ptr align 1 %28, i64 %sub.ptr.sub17, i1 false)
  %31 = load ptr, ptr %next, align 8
  %32 = load ptr, ptr %start, align 8
  %sub.ptr.lhs.cast18 = ptrtoint ptr %31 to i64
  %sub.ptr.rhs.cast19 = ptrtoint ptr %32 to i64
  %sub.ptr.sub20 = sub i64 %sub.ptr.lhs.cast18, %sub.ptr.rhs.cast19
  %33 = load ptr, ptr %result_s, align 8
  %add.ptr21 = getelementptr i8, ptr %33, i64 %sub.ptr.sub20
  store ptr %add.ptr21, ptr %result_s, align 8
  %34 = load ptr, ptr %next, align 8
  %35 = load i64, ptr %from_len.addr, align 8
  %add.ptr22 = getelementptr i8, ptr %34, i64 %35
  store ptr %add.ptr22, ptr %start, align 8
  br label %while.cond, !llvm.loop !61

while.end:                                        ; preds = %if.then12, %while.cond
  %36 = load ptr, ptr %result_s, align 8
  %37 = load ptr, ptr %start, align 8
  %38 = load ptr, ptr %end, align 8
  %39 = load ptr, ptr %start, align 8
  %sub.ptr.lhs.cast23 = ptrtoint ptr %38 to i64
  %sub.ptr.rhs.cast24 = ptrtoint ptr %39 to i64
  %sub.ptr.sub25 = sub i64 %sub.ptr.lhs.cast23, %sub.ptr.rhs.cast24
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %36, ptr align 1 %37, i64 %sub.ptr.sub25, i1 false)
  %40 = load ptr, ptr %result, align 8
  store ptr %40, ptr %retval, align 8
  br label %return

return:                                           ; preds = %while.end, %if.then6, %if.then
  %41 = load ptr, ptr %retval, align 8
  ret ptr %41
}

; Function Attrs: nounwind uwtable
define internal ptr @stringlib_replace_single_character_in_place(ptr noundef %self, i8 noundef signext %from_c, i8 noundef signext %to_c, i64 noundef %maxcount) #0 {
entry:
  %retval = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  %from_c.addr = alloca i8, align 1
  %to_c.addr = alloca i8, align 1
  %maxcount.addr = alloca i64, align 8
  %self_s = alloca ptr, align 8
  %end = alloca ptr, align 8
  %result_s = alloca ptr, align 8
  %start = alloca ptr, align 8
  %next = alloca ptr, align 8
  %self_len = alloca i64, align 8
  %result = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store i8 %from_c, ptr %from_c.addr, align 1
  store i8 %to_c, ptr %to_c.addr, align 1
  store i64 %maxcount, ptr %maxcount.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %call = call ptr @PyBytes_AS_STRING(ptr noundef %0)
  store ptr %call, ptr %self_s, align 8
  %1 = load ptr, ptr %self.addr, align 8
  %call1 = call i64 @PyBytes_GET_SIZE(ptr noundef %1)
  store i64 %call1, ptr %self_len, align 8
  %2 = load ptr, ptr %self_s, align 8
  %3 = load i8, ptr %from_c.addr, align 1
  %conv = sext i8 %3 to i32
  %4 = load i64, ptr %self_len, align 8
  %call2 = call ptr @memchr(ptr noundef %2, i32 noundef %conv, i64 noundef %4) #8
  store ptr %call2, ptr %next, align 8
  %5 = load ptr, ptr %next, align 8
  %cmp = icmp eq ptr %5, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load ptr, ptr %self.addr, align 8
  %call4 = call ptr @return_self(ptr noundef %6)
  store ptr %call4, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %7 = load i64, ptr %self_len, align 8
  %call5 = call ptr @PyBytes_FromStringAndSize(ptr noundef null, i64 noundef %7)
  store ptr %call5, ptr %result, align 8
  %8 = load ptr, ptr %result, align 8
  %cmp6 = icmp eq ptr %8, null
  br i1 %cmp6, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end9:                                          ; preds = %if.end
  %9 = load ptr, ptr %result, align 8
  %call10 = call ptr @PyBytes_AS_STRING(ptr noundef %9)
  store ptr %call10, ptr %result_s, align 8
  %10 = load ptr, ptr %result_s, align 8
  %11 = load ptr, ptr %self_s, align 8
  %12 = load i64, ptr %self_len, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %10, ptr align 1 %11, i64 %12, i1 false)
  %13 = load ptr, ptr %result_s, align 8
  %14 = load ptr, ptr %next, align 8
  %15 = load ptr, ptr %self_s, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %14 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %15 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %add.ptr = getelementptr i8, ptr %13, i64 %sub.ptr.sub
  store ptr %add.ptr, ptr %start, align 8
  %16 = load i8, ptr %to_c.addr, align 1
  %17 = load ptr, ptr %start, align 8
  store i8 %16, ptr %17, align 1
  %18 = load ptr, ptr %start, align 8
  %incdec.ptr = getelementptr i8, ptr %18, i32 1
  store ptr %incdec.ptr, ptr %start, align 8
  %19 = load ptr, ptr %result_s, align 8
  %20 = load i64, ptr %self_len, align 8
  %add.ptr11 = getelementptr i8, ptr %19, i64 %20
  store ptr %add.ptr11, ptr %end, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end22, %if.end9
  %21 = load i64, ptr %maxcount.addr, align 8
  %dec = add i64 %21, -1
  store i64 %dec, ptr %maxcount.addr, align 8
  %cmp12 = icmp sgt i64 %dec, 0
  br i1 %cmp12, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %22 = load ptr, ptr %start, align 8
  %23 = load i8, ptr %from_c.addr, align 1
  %conv14 = sext i8 %23 to i32
  %24 = load ptr, ptr %end, align 8
  %25 = load ptr, ptr %start, align 8
  %sub.ptr.lhs.cast15 = ptrtoint ptr %24 to i64
  %sub.ptr.rhs.cast16 = ptrtoint ptr %25 to i64
  %sub.ptr.sub17 = sub i64 %sub.ptr.lhs.cast15, %sub.ptr.rhs.cast16
  %call18 = call ptr @memchr(ptr noundef %22, i32 noundef %conv14, i64 noundef %sub.ptr.sub17) #8
  store ptr %call18, ptr %next, align 8
  %26 = load ptr, ptr %next, align 8
  %cmp19 = icmp eq ptr %26, null
  br i1 %cmp19, label %if.then21, label %if.end22

if.then21:                                        ; preds = %while.body
  br label %while.end

if.end22:                                         ; preds = %while.body
  %27 = load i8, ptr %to_c.addr, align 1
  %28 = load ptr, ptr %next, align 8
  store i8 %27, ptr %28, align 1
  %29 = load ptr, ptr %next, align 8
  %add.ptr23 = getelementptr i8, ptr %29, i64 1
  store ptr %add.ptr23, ptr %start, align 8
  br label %while.cond, !llvm.loop !62

while.end:                                        ; preds = %if.then21, %while.cond
  %30 = load ptr, ptr %result, align 8
  store ptr %30, ptr %retval, align 8
  br label %return

return:                                           ; preds = %while.end, %if.then8, %if.then
  %31 = load ptr, ptr %retval, align 8
  ret ptr %31
}

; Function Attrs: nounwind uwtable
define internal ptr @stringlib_replace_substring_in_place(ptr noundef %self, ptr noundef %from_s, i64 noundef %from_len, ptr noundef %to_s, i64 noundef %to_len, i64 noundef %maxcount) #0 {
entry:
  %retval = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  %from_s.addr = alloca ptr, align 8
  %from_len.addr = alloca i64, align 8
  %to_s.addr = alloca ptr, align 8
  %to_len.addr = alloca i64, align 8
  %maxcount.addr = alloca i64, align 8
  %self_s = alloca ptr, align 8
  %end = alloca ptr, align 8
  %result_s = alloca ptr, align 8
  %start = alloca ptr, align 8
  %self_len = alloca i64, align 8
  %offset = alloca i64, align 8
  %result = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %from_s, ptr %from_s.addr, align 8
  store i64 %from_len, ptr %from_len.addr, align 8
  store ptr %to_s, ptr %to_s.addr, align 8
  store i64 %to_len, ptr %to_len.addr, align 8
  store i64 %maxcount, ptr %maxcount.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %call = call ptr @PyBytes_AS_STRING(ptr noundef %0)
  store ptr %call, ptr %self_s, align 8
  %1 = load ptr, ptr %self.addr, align 8
  %call1 = call i64 @PyBytes_GET_SIZE(ptr noundef %1)
  store i64 %call1, ptr %self_len, align 8
  %2 = load ptr, ptr %self_s, align 8
  %3 = load i64, ptr %self_len, align 8
  %4 = load ptr, ptr %from_s.addr, align 8
  %5 = load i64, ptr %from_len.addr, align 8
  %call2 = call i64 @stringlib_find(ptr noundef %2, i64 noundef %3, ptr noundef %4, i64 noundef %5, i64 noundef 0)
  store i64 %call2, ptr %offset, align 8
  %6 = load i64, ptr %offset, align 8
  %cmp = icmp eq i64 %6, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %7 = load ptr, ptr %self.addr, align 8
  %call3 = call ptr @return_self(ptr noundef %7)
  store ptr %call3, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %8 = load i64, ptr %self_len, align 8
  %call4 = call ptr @PyBytes_FromStringAndSize(ptr noundef null, i64 noundef %8)
  store ptr %call4, ptr %result, align 8
  %9 = load ptr, ptr %result, align 8
  %cmp5 = icmp eq ptr %9, null
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end7:                                          ; preds = %if.end
  %10 = load ptr, ptr %result, align 8
  %call8 = call ptr @PyBytes_AS_STRING(ptr noundef %10)
  store ptr %call8, ptr %result_s, align 8
  %11 = load ptr, ptr %result_s, align 8
  %12 = load ptr, ptr %self_s, align 8
  %13 = load i64, ptr %self_len, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %11, ptr align 1 %12, i64 %13, i1 false)
  %14 = load ptr, ptr %result_s, align 8
  %15 = load i64, ptr %offset, align 8
  %add.ptr = getelementptr i8, ptr %14, i64 %15
  store ptr %add.ptr, ptr %start, align 8
  %16 = load ptr, ptr %start, align 8
  %17 = load ptr, ptr %to_s.addr, align 8
  %18 = load i64, ptr %from_len.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %16, ptr align 1 %17, i64 %18, i1 false)
  %19 = load i64, ptr %from_len.addr, align 8
  %20 = load ptr, ptr %start, align 8
  %add.ptr9 = getelementptr i8, ptr %20, i64 %19
  store ptr %add.ptr9, ptr %start, align 8
  %21 = load ptr, ptr %result_s, align 8
  %22 = load i64, ptr %self_len, align 8
  %add.ptr10 = getelementptr i8, ptr %21, i64 %22
  store ptr %add.ptr10, ptr %end, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end15, %if.end7
  %23 = load i64, ptr %maxcount.addr, align 8
  %dec = add i64 %23, -1
  store i64 %dec, ptr %maxcount.addr, align 8
  %cmp11 = icmp sgt i64 %dec, 0
  br i1 %cmp11, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %24 = load ptr, ptr %start, align 8
  %25 = load ptr, ptr %end, align 8
  %26 = load ptr, ptr %start, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %25 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %26 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %27 = load ptr, ptr %from_s.addr, align 8
  %28 = load i64, ptr %from_len.addr, align 8
  %call12 = call i64 @stringlib_find(ptr noundef %24, i64 noundef %sub.ptr.sub, ptr noundef %27, i64 noundef %28, i64 noundef 0)
  store i64 %call12, ptr %offset, align 8
  %29 = load i64, ptr %offset, align 8
  %cmp13 = icmp eq i64 %29, -1
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %while.body
  br label %while.end

if.end15:                                         ; preds = %while.body
  %30 = load ptr, ptr %start, align 8
  %31 = load i64, ptr %offset, align 8
  %add.ptr16 = getelementptr i8, ptr %30, i64 %31
  %32 = load ptr, ptr %to_s.addr, align 8
  %33 = load i64, ptr %from_len.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %add.ptr16, ptr align 1 %32, i64 %33, i1 false)
  %34 = load i64, ptr %offset, align 8
  %35 = load i64, ptr %from_len.addr, align 8
  %add = add i64 %34, %35
  %36 = load ptr, ptr %start, align 8
  %add.ptr17 = getelementptr i8, ptr %36, i64 %add
  store ptr %add.ptr17, ptr %start, align 8
  br label %while.cond, !llvm.loop !63

while.end:                                        ; preds = %if.then14, %while.cond
  %37 = load ptr, ptr %result, align 8
  store ptr %37, ptr %retval, align 8
  br label %return

return:                                           ; preds = %while.end, %if.then6, %if.then
  %38 = load ptr, ptr %retval, align 8
  ret ptr %38
}

; Function Attrs: nounwind uwtable
define internal ptr @stringlib_replace_single_character(ptr noundef %self, i8 noundef signext %from_c, ptr noundef %to_s, i64 noundef %to_len, i64 noundef %maxcount) #0 {
entry:
  %retval = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  %from_c.addr = alloca i8, align 1
  %to_s.addr = alloca ptr, align 8
  %to_len.addr = alloca i64, align 8
  %maxcount.addr = alloca i64, align 8
  %self_s = alloca ptr, align 8
  %start = alloca ptr, align 8
  %next = alloca ptr, align 8
  %end = alloca ptr, align 8
  %result_s = alloca ptr, align 8
  %self_len = alloca i64, align 8
  %result_len = alloca i64, align 8
  %count = alloca i64, align 8
  %result = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store i8 %from_c, ptr %from_c.addr, align 1
  store ptr %to_s, ptr %to_s.addr, align 8
  store i64 %to_len, ptr %to_len.addr, align 8
  store i64 %maxcount, ptr %maxcount.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %call = call ptr @PyBytes_AS_STRING(ptr noundef %0)
  store ptr %call, ptr %self_s, align 8
  %1 = load ptr, ptr %self.addr, align 8
  %call1 = call i64 @PyBytes_GET_SIZE(ptr noundef %1)
  store i64 %call1, ptr %self_len, align 8
  %2 = load ptr, ptr %self_s, align 8
  %3 = load i64, ptr %self_len, align 8
  %4 = load i8, ptr %from_c.addr, align 1
  %5 = load i64, ptr %maxcount.addr, align 8
  %call2 = call i64 @countchar(ptr noundef %2, i64 noundef %3, i8 noundef signext %4, i64 noundef %5)
  store i64 %call2, ptr %count, align 8
  %6 = load i64, ptr %count, align 8
  %cmp = icmp eq i64 %6, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %7 = load ptr, ptr %self.addr, align 8
  %call3 = call ptr @return_self(ptr noundef %7)
  store ptr %call3, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %8 = load i64, ptr %to_len.addr, align 8
  %sub = sub i64 %8, 1
  %9 = load i64, ptr %self_len, align 8
  %sub4 = sub i64 9223372036854775807, %9
  %10 = load i64, ptr %count, align 8
  %div = sdiv i64 %sub4, %10
  %cmp5 = icmp sgt i64 %sub, %div
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  %11 = load ptr, ptr @PyExc_OverflowError, align 8
  call void @PyErr_SetString(ptr noundef %11, ptr noundef @.str.117)
  store ptr null, ptr %retval, align 8
  br label %return

if.end7:                                          ; preds = %if.end
  %12 = load i64, ptr %self_len, align 8
  %13 = load i64, ptr %count, align 8
  %14 = load i64, ptr %to_len.addr, align 8
  %sub8 = sub i64 %14, 1
  %mul = mul i64 %13, %sub8
  %add = add i64 %12, %mul
  store i64 %add, ptr %result_len, align 8
  %15 = load i64, ptr %result_len, align 8
  %call9 = call ptr @PyBytes_FromStringAndSize(ptr noundef null, i64 noundef %15)
  store ptr %call9, ptr %result, align 8
  %16 = load ptr, ptr %result, align 8
  %cmp10 = icmp eq ptr %16, null
  br i1 %cmp10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end7
  store ptr null, ptr %retval, align 8
  br label %return

if.end12:                                         ; preds = %if.end7
  %17 = load ptr, ptr %result, align 8
  %call13 = call ptr @PyBytes_AS_STRING(ptr noundef %17)
  store ptr %call13, ptr %result_s, align 8
  %18 = load ptr, ptr %self_s, align 8
  store ptr %18, ptr %start, align 8
  %19 = load ptr, ptr %self_s, align 8
  %20 = load i64, ptr %self_len, align 8
  %add.ptr = getelementptr i8, ptr %19, i64 %20
  store ptr %add.ptr, ptr %end, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end34, %if.end12
  %21 = load i64, ptr %count, align 8
  %dec = add i64 %21, -1
  store i64 %dec, ptr %count, align 8
  %cmp14 = icmp sgt i64 %21, 0
  br i1 %cmp14, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %22 = load ptr, ptr %start, align 8
  %23 = load i8, ptr %from_c.addr, align 1
  %conv = sext i8 %23 to i32
  %24 = load ptr, ptr %end, align 8
  %25 = load ptr, ptr %start, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %24 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %25 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %call15 = call ptr @memchr(ptr noundef %22, i32 noundef %conv, i64 noundef %sub.ptr.sub) #8
  store ptr %call15, ptr %next, align 8
  %26 = load ptr, ptr %next, align 8
  %cmp16 = icmp eq ptr %26, null
  br i1 %cmp16, label %if.then18, label %if.end19

if.then18:                                        ; preds = %while.body
  br label %while.end

if.end19:                                         ; preds = %while.body
  %27 = load ptr, ptr %next, align 8
  %28 = load ptr, ptr %start, align 8
  %cmp20 = icmp eq ptr %27, %28
  br i1 %cmp20, label %if.then22, label %if.else

if.then22:                                        ; preds = %if.end19
  %29 = load ptr, ptr %result_s, align 8
  %30 = load ptr, ptr %to_s.addr, align 8
  %31 = load i64, ptr %to_len.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %29, ptr align 1 %30, i64 %31, i1 false)
  %32 = load i64, ptr %to_len.addr, align 8
  %33 = load ptr, ptr %result_s, align 8
  %add.ptr23 = getelementptr i8, ptr %33, i64 %32
  store ptr %add.ptr23, ptr %result_s, align 8
  %34 = load ptr, ptr %start, align 8
  %add.ptr24 = getelementptr i8, ptr %34, i64 1
  store ptr %add.ptr24, ptr %start, align 8
  br label %if.end34

if.else:                                          ; preds = %if.end19
  %35 = load ptr, ptr %result_s, align 8
  %36 = load ptr, ptr %start, align 8
  %37 = load ptr, ptr %next, align 8
  %38 = load ptr, ptr %start, align 8
  %sub.ptr.lhs.cast25 = ptrtoint ptr %37 to i64
  %sub.ptr.rhs.cast26 = ptrtoint ptr %38 to i64
  %sub.ptr.sub27 = sub i64 %sub.ptr.lhs.cast25, %sub.ptr.rhs.cast26
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %35, ptr align 1 %36, i64 %sub.ptr.sub27, i1 false)
  %39 = load ptr, ptr %next, align 8
  %40 = load ptr, ptr %start, align 8
  %sub.ptr.lhs.cast28 = ptrtoint ptr %39 to i64
  %sub.ptr.rhs.cast29 = ptrtoint ptr %40 to i64
  %sub.ptr.sub30 = sub i64 %sub.ptr.lhs.cast28, %sub.ptr.rhs.cast29
  %41 = load ptr, ptr %result_s, align 8
  %add.ptr31 = getelementptr i8, ptr %41, i64 %sub.ptr.sub30
  store ptr %add.ptr31, ptr %result_s, align 8
  %42 = load ptr, ptr %result_s, align 8
  %43 = load ptr, ptr %to_s.addr, align 8
  %44 = load i64, ptr %to_len.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %42, ptr align 1 %43, i64 %44, i1 false)
  %45 = load i64, ptr %to_len.addr, align 8
  %46 = load ptr, ptr %result_s, align 8
  %add.ptr32 = getelementptr i8, ptr %46, i64 %45
  store ptr %add.ptr32, ptr %result_s, align 8
  %47 = load ptr, ptr %next, align 8
  %add.ptr33 = getelementptr i8, ptr %47, i64 1
  store ptr %add.ptr33, ptr %start, align 8
  br label %if.end34

if.end34:                                         ; preds = %if.else, %if.then22
  br label %while.cond, !llvm.loop !64

while.end:                                        ; preds = %if.then18, %while.cond
  %48 = load ptr, ptr %result_s, align 8
  %49 = load ptr, ptr %start, align 8
  %50 = load ptr, ptr %end, align 8
  %51 = load ptr, ptr %start, align 8
  %sub.ptr.lhs.cast35 = ptrtoint ptr %50 to i64
  %sub.ptr.rhs.cast36 = ptrtoint ptr %51 to i64
  %sub.ptr.sub37 = sub i64 %sub.ptr.lhs.cast35, %sub.ptr.rhs.cast36
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %48, ptr align 1 %49, i64 %sub.ptr.sub37, i1 false)
  %52 = load ptr, ptr %result, align 8
  store ptr %52, ptr %retval, align 8
  br label %return

return:                                           ; preds = %while.end, %if.then11, %if.then6, %if.then
  %53 = load ptr, ptr %retval, align 8
  ret ptr %53
}

; Function Attrs: nounwind uwtable
define internal ptr @stringlib_replace_substring(ptr noundef %self, ptr noundef %from_s, i64 noundef %from_len, ptr noundef %to_s, i64 noundef %to_len, i64 noundef %maxcount) #0 {
entry:
  %retval = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  %from_s.addr = alloca ptr, align 8
  %from_len.addr = alloca i64, align 8
  %to_s.addr = alloca ptr, align 8
  %to_len.addr = alloca i64, align 8
  %maxcount.addr = alloca i64, align 8
  %self_s = alloca ptr, align 8
  %start = alloca ptr, align 8
  %next = alloca ptr, align 8
  %end = alloca ptr, align 8
  %result_s = alloca ptr, align 8
  %self_len = alloca i64, align 8
  %result_len = alloca i64, align 8
  %count = alloca i64, align 8
  %offset = alloca i64, align 8
  %result = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %from_s, ptr %from_s.addr, align 8
  store i64 %from_len, ptr %from_len.addr, align 8
  store ptr %to_s, ptr %to_s.addr, align 8
  store i64 %to_len, ptr %to_len.addr, align 8
  store i64 %maxcount, ptr %maxcount.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %call = call ptr @PyBytes_AS_STRING(ptr noundef %0)
  store ptr %call, ptr %self_s, align 8
  %1 = load ptr, ptr %self.addr, align 8
  %call1 = call i64 @PyBytes_GET_SIZE(ptr noundef %1)
  store i64 %call1, ptr %self_len, align 8
  %2 = load ptr, ptr %self_s, align 8
  %3 = load i64, ptr %self_len, align 8
  %4 = load ptr, ptr %from_s.addr, align 8
  %5 = load i64, ptr %from_len.addr, align 8
  %6 = load i64, ptr %maxcount.addr, align 8
  %call2 = call i64 @stringlib_count(ptr noundef %2, i64 noundef %3, ptr noundef %4, i64 noundef %5, i64 noundef %6)
  store i64 %call2, ptr %count, align 8
  %7 = load i64, ptr %count, align 8
  %cmp = icmp eq i64 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %8 = load ptr, ptr %self.addr, align 8
  %call3 = call ptr @return_self(ptr noundef %8)
  store ptr %call3, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %9 = load i64, ptr %to_len.addr, align 8
  %10 = load i64, ptr %from_len.addr, align 8
  %sub = sub i64 %9, %10
  %11 = load i64, ptr %self_len, align 8
  %sub4 = sub i64 9223372036854775807, %11
  %12 = load i64, ptr %count, align 8
  %div = sdiv i64 %sub4, %12
  %cmp5 = icmp sgt i64 %sub, %div
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  %13 = load ptr, ptr @PyExc_OverflowError, align 8
  call void @PyErr_SetString(ptr noundef %13, ptr noundef @.str.117)
  store ptr null, ptr %retval, align 8
  br label %return

if.end7:                                          ; preds = %if.end
  %14 = load i64, ptr %self_len, align 8
  %15 = load i64, ptr %count, align 8
  %16 = load i64, ptr %to_len.addr, align 8
  %17 = load i64, ptr %from_len.addr, align 8
  %sub8 = sub i64 %16, %17
  %mul = mul i64 %15, %sub8
  %add = add i64 %14, %mul
  store i64 %add, ptr %result_len, align 8
  %18 = load i64, ptr %result_len, align 8
  %call9 = call ptr @PyBytes_FromStringAndSize(ptr noundef null, i64 noundef %18)
  store ptr %call9, ptr %result, align 8
  %19 = load ptr, ptr %result, align 8
  %cmp10 = icmp eq ptr %19, null
  br i1 %cmp10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end7
  store ptr null, ptr %retval, align 8
  br label %return

if.end12:                                         ; preds = %if.end7
  %20 = load ptr, ptr %result, align 8
  %call13 = call ptr @PyBytes_AS_STRING(ptr noundef %20)
  store ptr %call13, ptr %result_s, align 8
  %21 = load ptr, ptr %self_s, align 8
  store ptr %21, ptr %start, align 8
  %22 = load ptr, ptr %self_s, align 8
  %23 = load i64, ptr %self_len, align 8
  %add.ptr = getelementptr i8, ptr %22, i64 %23
  store ptr %add.ptr, ptr %end, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end33, %if.end12
  %24 = load i64, ptr %count, align 8
  %dec = add i64 %24, -1
  store i64 %dec, ptr %count, align 8
  %cmp14 = icmp sgt i64 %24, 0
  br i1 %cmp14, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %25 = load ptr, ptr %start, align 8
  %26 = load ptr, ptr %end, align 8
  %27 = load ptr, ptr %start, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %26 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %27 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %28 = load ptr, ptr %from_s.addr, align 8
  %29 = load i64, ptr %from_len.addr, align 8
  %call15 = call i64 @stringlib_find(ptr noundef %25, i64 noundef %sub.ptr.sub, ptr noundef %28, i64 noundef %29, i64 noundef 0)
  store i64 %call15, ptr %offset, align 8
  %30 = load i64, ptr %offset, align 8
  %cmp16 = icmp eq i64 %30, -1
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %while.body
  br label %while.end

if.end18:                                         ; preds = %while.body
  %31 = load ptr, ptr %start, align 8
  %32 = load i64, ptr %offset, align 8
  %add.ptr19 = getelementptr i8, ptr %31, i64 %32
  store ptr %add.ptr19, ptr %next, align 8
  %33 = load ptr, ptr %next, align 8
  %34 = load ptr, ptr %start, align 8
  %cmp20 = icmp eq ptr %33, %34
  br i1 %cmp20, label %if.then21, label %if.else

if.then21:                                        ; preds = %if.end18
  %35 = load ptr, ptr %result_s, align 8
  %36 = load ptr, ptr %to_s.addr, align 8
  %37 = load i64, ptr %to_len.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %35, ptr align 1 %36, i64 %37, i1 false)
  %38 = load i64, ptr %to_len.addr, align 8
  %39 = load ptr, ptr %result_s, align 8
  %add.ptr22 = getelementptr i8, ptr %39, i64 %38
  store ptr %add.ptr22, ptr %result_s, align 8
  %40 = load i64, ptr %from_len.addr, align 8
  %41 = load ptr, ptr %start, align 8
  %add.ptr23 = getelementptr i8, ptr %41, i64 %40
  store ptr %add.ptr23, ptr %start, align 8
  br label %if.end33

if.else:                                          ; preds = %if.end18
  %42 = load ptr, ptr %result_s, align 8
  %43 = load ptr, ptr %start, align 8
  %44 = load ptr, ptr %next, align 8
  %45 = load ptr, ptr %start, align 8
  %sub.ptr.lhs.cast24 = ptrtoint ptr %44 to i64
  %sub.ptr.rhs.cast25 = ptrtoint ptr %45 to i64
  %sub.ptr.sub26 = sub i64 %sub.ptr.lhs.cast24, %sub.ptr.rhs.cast25
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %42, ptr align 1 %43, i64 %sub.ptr.sub26, i1 false)
  %46 = load ptr, ptr %next, align 8
  %47 = load ptr, ptr %start, align 8
  %sub.ptr.lhs.cast27 = ptrtoint ptr %46 to i64
  %sub.ptr.rhs.cast28 = ptrtoint ptr %47 to i64
  %sub.ptr.sub29 = sub i64 %sub.ptr.lhs.cast27, %sub.ptr.rhs.cast28
  %48 = load ptr, ptr %result_s, align 8
  %add.ptr30 = getelementptr i8, ptr %48, i64 %sub.ptr.sub29
  store ptr %add.ptr30, ptr %result_s, align 8
  %49 = load ptr, ptr %result_s, align 8
  %50 = load ptr, ptr %to_s.addr, align 8
  %51 = load i64, ptr %to_len.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %49, ptr align 1 %50, i64 %51, i1 false)
  %52 = load i64, ptr %to_len.addr, align 8
  %53 = load ptr, ptr %result_s, align 8
  %add.ptr31 = getelementptr i8, ptr %53, i64 %52
  store ptr %add.ptr31, ptr %result_s, align 8
  %54 = load ptr, ptr %next, align 8
  %55 = load i64, ptr %from_len.addr, align 8
  %add.ptr32 = getelementptr i8, ptr %54, i64 %55
  store ptr %add.ptr32, ptr %start, align 8
  br label %if.end33

if.end33:                                         ; preds = %if.else, %if.then21
  br label %while.cond, !llvm.loop !65

while.end:                                        ; preds = %if.then17, %while.cond
  %56 = load ptr, ptr %result_s, align 8
  %57 = load ptr, ptr %start, align 8
  %58 = load ptr, ptr %end, align 8
  %59 = load ptr, ptr %start, align 8
  %sub.ptr.lhs.cast34 = ptrtoint ptr %58 to i64
  %sub.ptr.rhs.cast35 = ptrtoint ptr %59 to i64
  %sub.ptr.sub36 = sub i64 %sub.ptr.lhs.cast34, %sub.ptr.rhs.cast35
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %56, ptr align 1 %57, i64 %sub.ptr.sub36, i1 false)
  %60 = load ptr, ptr %result, align 8
  store ptr %60, ptr %retval, align 8
  br label %return

return:                                           ; preds = %while.end, %if.then11, %if.then6, %if.then
  %61 = load ptr, ptr %retval, align 8
  ret ptr %61
}

; Function Attrs: nounwind uwtable
define internal i64 @countchar(ptr noundef %target, i64 noundef %target_len, i8 noundef signext %c, i64 noundef %maxcount) #0 {
entry:
  %target.addr = alloca ptr, align 8
  %target_len.addr = alloca i64, align 8
  %c.addr = alloca i8, align 1
  %maxcount.addr = alloca i64, align 8
  %count = alloca i64, align 8
  %start = alloca ptr, align 8
  %end = alloca ptr, align 8
  store ptr %target, ptr %target.addr, align 8
  store i64 %target_len, ptr %target_len.addr, align 8
  store i8 %c, ptr %c.addr, align 1
  store i64 %maxcount, ptr %maxcount.addr, align 8
  store i64 0, ptr %count, align 8
  %0 = load ptr, ptr %target.addr, align 8
  store ptr %0, ptr %start, align 8
  %1 = load ptr, ptr %target.addr, align 8
  %2 = load i64, ptr %target_len.addr, align 8
  %add.ptr = getelementptr i8, ptr %1, i64 %2
  store ptr %add.ptr, ptr %end, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %3 = load ptr, ptr %start, align 8
  %4 = load i8, ptr %c.addr, align 1
  %conv = sext i8 %4 to i32
  %5 = load ptr, ptr %end, align 8
  %6 = load ptr, ptr %start, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %5 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %6 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %call = call ptr @memchr(ptr noundef %3, i32 noundef %conv, i64 noundef %sub.ptr.sub) #8
  store ptr %call, ptr %start, align 8
  %cmp = icmp ne ptr %call, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %7 = load i64, ptr %count, align 8
  %inc = add i64 %7, 1
  store i64 %inc, ptr %count, align 8
  %8 = load i64, ptr %count, align 8
  %9 = load i64, ptr %maxcount.addr, align 8
  %cmp2 = icmp sge i64 %8, %9
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  br label %while.end

if.end:                                           ; preds = %while.body
  %10 = load ptr, ptr %start, align 8
  %add.ptr4 = getelementptr i8, ptr %10, i64 1
  store ptr %add.ptr4, ptr %start, align 8
  br label %while.cond, !llvm.loop !66

while.end:                                        ; preds = %if.then, %while.cond
  %11 = load i64, ptr %count, align 8
  ret i64 %11
}

; Function Attrs: nounwind uwtable
define internal i64 @stringlib_count(ptr noundef %str, i64 noundef %str_len, ptr noundef %sub, i64 noundef %sub_len, i64 noundef %maxcount) #0 {
entry:
  %retval = alloca i64, align 8
  %str.addr = alloca ptr, align 8
  %str_len.addr = alloca i64, align 8
  %sub.addr = alloca ptr, align 8
  %sub_len.addr = alloca i64, align 8
  %maxcount.addr = alloca i64, align 8
  %count = alloca i64, align 8
  store ptr %str, ptr %str.addr, align 8
  store i64 %str_len, ptr %str_len.addr, align 8
  store ptr %sub, ptr %sub.addr, align 8
  store i64 %sub_len, ptr %sub_len.addr, align 8
  store i64 %maxcount, ptr %maxcount.addr, align 8
  %0 = load i64, ptr %str_len.addr, align 8
  %cmp = icmp slt i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 0, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, ptr %sub_len.addr, align 8
  %cmp1 = icmp eq i64 %1, 0
  br i1 %cmp1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %2 = load i64, ptr %str_len.addr, align 8
  %3 = load i64, ptr %maxcount.addr, align 8
  %cmp3 = icmp slt i64 %2, %3
  br i1 %cmp3, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then2
  %4 = load i64, ptr %str_len.addr, align 8
  %add = add i64 %4, 1
  br label %cond.end

cond.false:                                       ; preds = %if.then2
  %5 = load i64, ptr %maxcount.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %add, %cond.true ], [ %5, %cond.false ]
  store i64 %cond, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  %6 = load ptr, ptr %str.addr, align 8
  %7 = load i64, ptr %str_len.addr, align 8
  %8 = load ptr, ptr %sub.addr, align 8
  %9 = load i64, ptr %sub_len.addr, align 8
  %10 = load i64, ptr %maxcount.addr, align 8
  %call = call i64 @fastsearch(ptr noundef %6, i64 noundef %7, ptr noundef %8, i64 noundef %9, i64 noundef %10, i32 noundef 0)
  store i64 %call, ptr %count, align 8
  %11 = load i64, ptr %count, align 8
  %cmp5 = icmp slt i64 %11, 0
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end4
  store i64 0, ptr %retval, align 8
  br label %return

if.end7:                                          ; preds = %if.end4
  %12 = load i64, ptr %count, align 8
  store i64 %12, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end7, %if.then6, %cond.end, %if.then
  %13 = load i64, ptr %retval, align 8
  ret i64 %13
}

; Function Attrs: nounwind uwtable
define internal ptr @bytes_removeprefix_impl(ptr noundef %self, ptr noundef %prefix) #0 {
entry:
  %retval = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  %prefix.addr = alloca ptr, align 8
  %self_start = alloca ptr, align 8
  %self_len = alloca i64, align 8
  %prefix_start = alloca ptr, align 8
  %prefix_len = alloca i64, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %prefix, ptr %prefix.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %call = call ptr @PyBytes_AS_STRING(ptr noundef %0)
  store ptr %call, ptr %self_start, align 8
  %1 = load ptr, ptr %self.addr, align 8
  %call1 = call i64 @PyBytes_GET_SIZE(ptr noundef %1)
  store i64 %call1, ptr %self_len, align 8
  %2 = load ptr, ptr %prefix.addr, align 8
  %buf = getelementptr inbounds %struct.Py_buffer, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %buf, align 8
  store ptr %3, ptr %prefix_start, align 8
  %4 = load ptr, ptr %prefix.addr, align 8
  %len = getelementptr inbounds %struct.Py_buffer, ptr %4, i32 0, i32 2
  %5 = load i64, ptr %len, align 8
  store i64 %5, ptr %prefix_len, align 8
  %6 = load i64, ptr %self_len, align 8
  %7 = load i64, ptr %prefix_len, align 8
  %cmp = icmp sge i64 %6, %7
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %8 = load i64, ptr %prefix_len, align 8
  %cmp2 = icmp sgt i64 %8, 0
  br i1 %cmp2, label %land.lhs.true3, label %if.end

land.lhs.true3:                                   ; preds = %land.lhs.true
  %9 = load ptr, ptr %self_start, align 8
  %10 = load ptr, ptr %prefix_start, align 8
  %11 = load i64, ptr %prefix_len, align 8
  %call4 = call i32 @memcmp(ptr noundef %9, ptr noundef %10, i64 noundef %11) #8
  %cmp5 = icmp eq i32 %call4, 0
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true3
  %12 = load ptr, ptr %self_start, align 8
  %13 = load i64, ptr %prefix_len, align 8
  %add.ptr = getelementptr i8, ptr %12, i64 %13
  %14 = load i64, ptr %self_len, align 8
  %15 = load i64, ptr %prefix_len, align 8
  %sub = sub i64 %14, %15
  %call6 = call ptr @PyBytes_FromStringAndSize(ptr noundef %add.ptr, i64 noundef %sub)
  store ptr %call6, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %land.lhs.true3, %land.lhs.true, %entry
  %16 = load ptr, ptr %self.addr, align 8
  %call7 = call i32 @Py_IS_TYPE(ptr noundef %16, ptr noundef @PyBytes_Type)
  %tobool = icmp ne i32 %call7, 0
  br i1 %tobool, label %if.then8, label %if.end10

if.then8:                                         ; preds = %if.end
  %17 = load ptr, ptr %self.addr, align 8
  %call9 = call ptr @_Py_NewRef(ptr noundef %17)
  store ptr %call9, ptr %retval, align 8
  br label %return

if.end10:                                         ; preds = %if.end
  %18 = load ptr, ptr %self_start, align 8
  %19 = load i64, ptr %self_len, align 8
  %call11 = call ptr @PyBytes_FromStringAndSize(ptr noundef %18, i64 noundef %19)
  store ptr %call11, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end10, %if.then8, %if.then
  %20 = load ptr, ptr %retval, align 8
  ret ptr %20
}

; Function Attrs: nounwind uwtable
define internal ptr @bytes_removesuffix_impl(ptr noundef %self, ptr noundef %suffix) #0 {
entry:
  %retval = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  %suffix.addr = alloca ptr, align 8
  %self_start = alloca ptr, align 8
  %self_len = alloca i64, align 8
  %suffix_start = alloca ptr, align 8
  %suffix_len = alloca i64, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %suffix, ptr %suffix.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %call = call ptr @PyBytes_AS_STRING(ptr noundef %0)
  store ptr %call, ptr %self_start, align 8
  %1 = load ptr, ptr %self.addr, align 8
  %call1 = call i64 @PyBytes_GET_SIZE(ptr noundef %1)
  store i64 %call1, ptr %self_len, align 8
  %2 = load ptr, ptr %suffix.addr, align 8
  %buf = getelementptr inbounds %struct.Py_buffer, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %buf, align 8
  store ptr %3, ptr %suffix_start, align 8
  %4 = load ptr, ptr %suffix.addr, align 8
  %len = getelementptr inbounds %struct.Py_buffer, ptr %4, i32 0, i32 2
  %5 = load i64, ptr %len, align 8
  store i64 %5, ptr %suffix_len, align 8
  %6 = load i64, ptr %self_len, align 8
  %7 = load i64, ptr %suffix_len, align 8
  %cmp = icmp sge i64 %6, %7
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %8 = load i64, ptr %suffix_len, align 8
  %cmp2 = icmp sgt i64 %8, 0
  br i1 %cmp2, label %land.lhs.true3, label %if.end

land.lhs.true3:                                   ; preds = %land.lhs.true
  %9 = load ptr, ptr %self_start, align 8
  %10 = load i64, ptr %self_len, align 8
  %add.ptr = getelementptr i8, ptr %9, i64 %10
  %11 = load i64, ptr %suffix_len, align 8
  %idx.neg = sub i64 0, %11
  %add.ptr4 = getelementptr i8, ptr %add.ptr, i64 %idx.neg
  %12 = load ptr, ptr %suffix_start, align 8
  %13 = load i64, ptr %suffix_len, align 8
  %call5 = call i32 @memcmp(ptr noundef %add.ptr4, ptr noundef %12, i64 noundef %13) #8
  %cmp6 = icmp eq i32 %call5, 0
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true3
  %14 = load ptr, ptr %self_start, align 8
  %15 = load i64, ptr %self_len, align 8
  %16 = load i64, ptr %suffix_len, align 8
  %sub = sub i64 %15, %16
  %call7 = call ptr @PyBytes_FromStringAndSize(ptr noundef %14, i64 noundef %sub)
  store ptr %call7, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %land.lhs.true3, %land.lhs.true, %entry
  %17 = load ptr, ptr %self.addr, align 8
  %call8 = call i32 @Py_IS_TYPE(ptr noundef %17, ptr noundef @PyBytes_Type)
  %tobool = icmp ne i32 %call8, 0
  br i1 %tobool, label %if.then9, label %if.end11

if.then9:                                         ; preds = %if.end
  %18 = load ptr, ptr %self.addr, align 8
  %call10 = call ptr @_Py_NewRef(ptr noundef %18)
  store ptr %call10, ptr %retval, align 8
  br label %return

if.end11:                                         ; preds = %if.end
  %19 = load ptr, ptr %self_start, align 8
  %20 = load i64, ptr %self_len, align 8
  %call12 = call ptr @PyBytes_FromStringAndSize(ptr noundef %19, i64 noundef %20)
  store ptr %call12, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end11, %if.then9, %if.then
  %21 = load ptr, ptr %retval, align 8
  ret ptr %21
}

declare ptr @_Py_bytes_rfind(ptr noundef, i64 noundef, ptr noundef) #1

declare ptr @_Py_bytes_rindex(ptr noundef, i64 noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @stringlib_rjust_impl(ptr noundef %self, i64 noundef %width, i8 noundef signext %fillchar) #0 {
entry:
  %retval = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  %width.addr = alloca i64, align 8
  %fillchar.addr = alloca i8, align 1
  store ptr %self, ptr %self.addr, align 8
  store i64 %width, ptr %width.addr, align 8
  store i8 %fillchar, ptr %fillchar.addr, align 1
  %0 = load ptr, ptr %self.addr, align 8
  %call = call i64 @PyBytes_GET_SIZE(ptr noundef %0)
  %1 = load i64, ptr %width.addr, align 8
  %cmp = icmp sge i64 %call, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %self.addr, align 8
  %call1 = call ptr @return_self(ptr noundef %2)
  store ptr %call1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %self.addr, align 8
  %4 = load i64, ptr %width.addr, align 8
  %5 = load ptr, ptr %self.addr, align 8
  %call2 = call i64 @PyBytes_GET_SIZE(ptr noundef %5)
  %sub = sub i64 %4, %call2
  %6 = load i8, ptr %fillchar.addr, align 1
  %call3 = call ptr @pad(ptr noundef %3, i64 noundef %sub, i64 noundef 0, i8 noundef signext %6)
  store ptr %call3, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load ptr, ptr %retval, align 8
  ret ptr %7
}

; Function Attrs: nounwind uwtable
define internal ptr @bytes_rpartition_impl(ptr noundef %self, ptr noundef %sep) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %sep.addr = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %sep, ptr %sep.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %1 = load ptr, ptr %self.addr, align 8
  %call = call ptr @PyBytes_AS_STRING(ptr noundef %1)
  %2 = load ptr, ptr %self.addr, align 8
  %call1 = call i64 @PyBytes_GET_SIZE(ptr noundef %2)
  %3 = load ptr, ptr %sep.addr, align 8
  %obj = getelementptr inbounds %struct.Py_buffer, ptr %3, i32 0, i32 1
  %4 = load ptr, ptr %obj, align 8
  %5 = load ptr, ptr %sep.addr, align 8
  %buf = getelementptr inbounds %struct.Py_buffer, ptr %5, i32 0, i32 0
  %6 = load ptr, ptr %buf, align 8
  %7 = load ptr, ptr %sep.addr, align 8
  %len = getelementptr inbounds %struct.Py_buffer, ptr %7, i32 0, i32 2
  %8 = load i64, ptr %len, align 8
  %call2 = call ptr @stringlib_rpartition(ptr noundef %0, ptr noundef %call, i64 noundef %call1, ptr noundef %4, ptr noundef %6, i64 noundef %8)
  ret ptr %call2
}

; Function Attrs: nounwind uwtable
define internal ptr @stringlib_rpartition(ptr noundef %str_obj, ptr noundef %str, i64 noundef %str_len, ptr noundef %sep_obj, ptr noundef %sep, i64 noundef %sep_len) #0 {
entry:
  %op.addr.i42 = alloca ptr, align 8
  %op.addr.i34 = alloca ptr, align 8
  %cur_refcnt.i35 = alloca i32, align 4
  %new_refcnt.i36 = alloca i32, align 4
  %op.addr.i26 = alloca ptr, align 8
  %cur_refcnt.i27 = alloca i32, align 4
  %new_refcnt.i28 = alloca i32, align 4
  %op.addr.i18 = alloca ptr, align 8
  %cur_refcnt.i19 = alloca i32, align 4
  %new_refcnt.i20 = alloca i32, align 4
  %op.addr.i14 = alloca ptr, align 8
  %cur_refcnt.i = alloca i32, align 4
  %new_refcnt.i = alloca i32, align 4
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %str_obj.addr = alloca ptr, align 8
  %str.addr = alloca ptr, align 8
  %str_len.addr = alloca i64, align 8
  %sep_obj.addr = alloca ptr, align 8
  %sep.addr = alloca ptr, align 8
  %sep_len.addr = alloca i64, align 8
  %out = alloca ptr, align 8
  %pos = alloca i64, align 8
  %empty = alloca ptr, align 8
  store ptr %str_obj, ptr %str_obj.addr, align 8
  store ptr %str, ptr %str.addr, align 8
  store i64 %str_len, ptr %str_len.addr, align 8
  store ptr %sep_obj, ptr %sep_obj.addr, align 8
  store ptr %sep, ptr %sep.addr, align 8
  store i64 %sep_len, ptr %sep_len.addr, align 8
  %0 = load i64, ptr %sep_len.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr @PyExc_ValueError, align 8
  call void @PyErr_SetString(ptr noundef %1, ptr noundef @.str.116)
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %call = call ptr @PyTuple_New(i64 noundef 3)
  store ptr %call, ptr %out, align 8
  %2 = load ptr, ptr %out, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.end2, label %if.then1

if.then1:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end2:                                          ; preds = %if.end
  %3 = load ptr, ptr %str.addr, align 8
  %4 = load i64, ptr %str_len.addr, align 8
  %5 = load ptr, ptr %sep.addr, align 8
  %6 = load i64, ptr %sep_len.addr, align 8
  %call3 = call i64 @fastsearch(ptr noundef %3, i64 noundef %4, ptr noundef %5, i64 noundef %6, i64 noundef -1, i32 noundef 2)
  store i64 %call3, ptr %pos, align 8
  %7 = load i64, ptr %pos, align 8
  %cmp4 = icmp slt i64 %7, 0
  br i1 %cmp4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end2
  %call6 = call ptr @bytes_get_empty()
  store ptr %call6, ptr %empty, align 8
  %8 = load ptr, ptr %empty, align 8
  store ptr %8, ptr %op.addr.i34, align 8
  %9 = load ptr, ptr %op.addr.i34, align 8
  %10 = load i32, ptr %9, align 8
  store i32 %10, ptr %cur_refcnt.i35, align 4
  %11 = load i32, ptr %cur_refcnt.i35, align 4
  %add.i37 = add i32 %11, 1
  store i32 %add.i37, ptr %new_refcnt.i36, align 4
  %12 = load i32, ptr %new_refcnt.i36, align 4
  %cmp.i38 = icmp eq i32 %12, 0
  br i1 %cmp.i38, label %if.then.i40, label %if.end.i39

if.then.i40:                                      ; preds = %if.then5
  br label %Py_INCREF.exit41

if.end.i39:                                       ; preds = %if.then5
  %13 = load i32, ptr %new_refcnt.i36, align 4
  %14 = load ptr, ptr %op.addr.i34, align 8
  store i32 %13, ptr %14, align 8
  br label %Py_INCREF.exit41

Py_INCREF.exit41:                                 ; preds = %if.end.i39, %if.then.i40
  %15 = load ptr, ptr %out, align 8
  %16 = load ptr, ptr %empty, align 8
  call void @PyTuple_SET_ITEM(ptr noundef %15, i64 noundef 0, ptr noundef %16)
  %17 = load ptr, ptr %empty, align 8
  store ptr %17, ptr %op.addr.i26, align 8
  %18 = load ptr, ptr %op.addr.i26, align 8
  %19 = load i32, ptr %18, align 8
  store i32 %19, ptr %cur_refcnt.i27, align 4
  %20 = load i32, ptr %cur_refcnt.i27, align 4
  %add.i29 = add i32 %20, 1
  store i32 %add.i29, ptr %new_refcnt.i28, align 4
  %21 = load i32, ptr %new_refcnt.i28, align 4
  %cmp.i30 = icmp eq i32 %21, 0
  br i1 %cmp.i30, label %if.then.i32, label %if.end.i31

if.then.i32:                                      ; preds = %Py_INCREF.exit41
  br label %Py_INCREF.exit33

if.end.i31:                                       ; preds = %Py_INCREF.exit41
  %22 = load i32, ptr %new_refcnt.i28, align 4
  %23 = load ptr, ptr %op.addr.i26, align 8
  store i32 %22, ptr %23, align 8
  br label %Py_INCREF.exit33

Py_INCREF.exit33:                                 ; preds = %if.end.i31, %if.then.i32
  %24 = load ptr, ptr %out, align 8
  %25 = load ptr, ptr %empty, align 8
  call void @PyTuple_SET_ITEM(ptr noundef %24, i64 noundef 1, ptr noundef %25)
  %26 = load ptr, ptr %str_obj.addr, align 8
  store ptr %26, ptr %op.addr.i18, align 8
  %27 = load ptr, ptr %op.addr.i18, align 8
  %28 = load i32, ptr %27, align 8
  store i32 %28, ptr %cur_refcnt.i19, align 4
  %29 = load i32, ptr %cur_refcnt.i19, align 4
  %add.i21 = add i32 %29, 1
  store i32 %add.i21, ptr %new_refcnt.i20, align 4
  %30 = load i32, ptr %new_refcnt.i20, align 4
  %cmp.i22 = icmp eq i32 %30, 0
  br i1 %cmp.i22, label %if.then.i24, label %if.end.i23

if.then.i24:                                      ; preds = %Py_INCREF.exit33
  br label %Py_INCREF.exit25

if.end.i23:                                       ; preds = %Py_INCREF.exit33
  %31 = load i32, ptr %new_refcnt.i20, align 4
  %32 = load ptr, ptr %op.addr.i18, align 8
  store i32 %31, ptr %32, align 8
  br label %Py_INCREF.exit25

Py_INCREF.exit25:                                 ; preds = %if.end.i23, %if.then.i24
  %33 = load ptr, ptr %out, align 8
  %34 = load ptr, ptr %str_obj.addr, align 8
  call void @PyTuple_SET_ITEM(ptr noundef %33, i64 noundef 2, ptr noundef %34)
  %35 = load ptr, ptr %out, align 8
  store ptr %35, ptr %retval, align 8
  br label %return

if.end7:                                          ; preds = %if.end2
  %36 = load ptr, ptr %out, align 8
  %37 = load ptr, ptr %str.addr, align 8
  %38 = load i64, ptr %pos, align 8
  %call8 = call ptr @PyBytes_FromStringAndSize(ptr noundef %37, i64 noundef %38)
  call void @PyTuple_SET_ITEM(ptr noundef %36, i64 noundef 0, ptr noundef %call8)
  %39 = load ptr, ptr %sep_obj.addr, align 8
  store ptr %39, ptr %op.addr.i14, align 8
  %40 = load ptr, ptr %op.addr.i14, align 8
  %41 = load i32, ptr %40, align 8
  store i32 %41, ptr %cur_refcnt.i, align 4
  %42 = load i32, ptr %cur_refcnt.i, align 4
  %add.i = add i32 %42, 1
  store i32 %add.i, ptr %new_refcnt.i, align 4
  %43 = load i32, ptr %new_refcnt.i, align 4
  %cmp.i15 = icmp eq i32 %43, 0
  br i1 %cmp.i15, label %if.then.i17, label %if.end.i16

if.then.i17:                                      ; preds = %if.end7
  br label %Py_INCREF.exit

if.end.i16:                                       ; preds = %if.end7
  %44 = load i32, ptr %new_refcnt.i, align 4
  %45 = load ptr, ptr %op.addr.i14, align 8
  store i32 %44, ptr %45, align 8
  br label %Py_INCREF.exit

Py_INCREF.exit:                                   ; preds = %if.end.i16, %if.then.i17
  %46 = load ptr, ptr %out, align 8
  %47 = load ptr, ptr %sep_obj.addr, align 8
  call void @PyTuple_SET_ITEM(ptr noundef %46, i64 noundef 1, ptr noundef %47)
  %48 = load i64, ptr %sep_len.addr, align 8
  %49 = load i64, ptr %pos, align 8
  %add = add i64 %49, %48
  store i64 %add, ptr %pos, align 8
  %50 = load ptr, ptr %out, align 8
  %51 = load ptr, ptr %str.addr, align 8
  %52 = load i64, ptr %pos, align 8
  %add.ptr = getelementptr i8, ptr %51, i64 %52
  %53 = load i64, ptr %str_len.addr, align 8
  %54 = load i64, ptr %pos, align 8
  %sub = sub i64 %53, %54
  %call9 = call ptr @PyBytes_FromStringAndSize(ptr noundef %add.ptr, i64 noundef %sub)
  call void @PyTuple_SET_ITEM(ptr noundef %50, i64 noundef 2, ptr noundef %call9)
  %call10 = call ptr @PyErr_Occurred()
  %tobool11 = icmp ne ptr %call10, null
  br i1 %tobool11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %Py_INCREF.exit
  %55 = load ptr, ptr %out, align 8
  store ptr %55, ptr %op.addr.i, align 8
  %56 = load ptr, ptr %op.addr.i, align 8
  store ptr %56, ptr %op.addr.i42, align 8
  %57 = load ptr, ptr %op.addr.i42, align 8
  %58 = load i64, ptr %57, align 8
  %conv.i = trunc i64 %58 to i32
  %cmp.i43 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i43 to i32
  %tobool.i = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then12
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.then12
  %59 = load ptr, ptr %op.addr.i, align 8
  %60 = load i64, ptr %59, align 8
  %dec.i = add i64 %60, -1
  store i64 %dec.i, ptr %59, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %61 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %61) #9
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  store ptr null, ptr %retval, align 8
  br label %return

if.end13:                                         ; preds = %Py_INCREF.exit
  %62 = load ptr, ptr %out, align 8
  store ptr %62, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end13, %Py_DECREF.exit, %Py_INCREF.exit25, %if.then1, %if.then
  %63 = load ptr, ptr %retval, align 8
  ret ptr %63
}

; Function Attrs: nounwind uwtable
define internal ptr @bytes_rsplit_impl(ptr noundef %self, ptr noundef %sep, i64 noundef %maxsplit) #0 {
entry:
  %retval = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  %sep.addr = alloca ptr, align 8
  %maxsplit.addr = alloca i64, align 8
  %len = alloca i64, align 8
  %n = alloca i64, align 8
  %s = alloca ptr, align 8
  %sub = alloca ptr, align 8
  %vsub = alloca %struct.Py_buffer, align 8
  %list = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %sep, ptr %sep.addr, align 8
  store i64 %maxsplit, ptr %maxsplit.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %call = call i64 @PyBytes_GET_SIZE(ptr noundef %0)
  store i64 %call, ptr %len, align 8
  %1 = load ptr, ptr %self.addr, align 8
  %call1 = call ptr @PyBytes_AS_STRING(ptr noundef %1)
  store ptr %call1, ptr %s, align 8
  %2 = load i64, ptr %maxsplit.addr, align 8
  %cmp = icmp slt i64 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 9223372036854775807, ptr %maxsplit.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load ptr, ptr %sep.addr, align 8
  %cmp2 = icmp eq ptr %3, @_Py_NoneStruct
  br i1 %cmp2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %4 = load ptr, ptr %self.addr, align 8
  %5 = load ptr, ptr %s, align 8
  %6 = load i64, ptr %len, align 8
  %7 = load i64, ptr %maxsplit.addr, align 8
  %call4 = call ptr @stringlib_rsplit_whitespace(ptr noundef %4, ptr noundef %5, i64 noundef %6, i64 noundef %7)
  store ptr %call4, ptr %retval, align 8
  br label %return

if.end5:                                          ; preds = %if.end
  %8 = load ptr, ptr %sep.addr, align 8
  %call6 = call i32 @PyObject_GetBuffer(ptr noundef %8, ptr noundef %vsub, i32 noundef 0)
  %cmp7 = icmp ne i32 %call6, 0
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end5
  store ptr null, ptr %retval, align 8
  br label %return

if.end9:                                          ; preds = %if.end5
  %buf = getelementptr inbounds %struct.Py_buffer, ptr %vsub, i32 0, i32 0
  %9 = load ptr, ptr %buf, align 8
  store ptr %9, ptr %sub, align 8
  %len10 = getelementptr inbounds %struct.Py_buffer, ptr %vsub, i32 0, i32 2
  %10 = load i64, ptr %len10, align 8
  store i64 %10, ptr %n, align 8
  %11 = load ptr, ptr %self.addr, align 8
  %12 = load ptr, ptr %s, align 8
  %13 = load i64, ptr %len, align 8
  %14 = load ptr, ptr %sub, align 8
  %15 = load i64, ptr %n, align 8
  %16 = load i64, ptr %maxsplit.addr, align 8
  %call11 = call ptr @stringlib_rsplit(ptr noundef %11, ptr noundef %12, i64 noundef %13, ptr noundef %14, i64 noundef %15, i64 noundef %16)
  store ptr %call11, ptr %list, align 8
  call void @PyBuffer_Release(ptr noundef %vsub)
  %17 = load ptr, ptr %list, align 8
  store ptr %17, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end9, %if.then8, %if.then3
  %18 = load ptr, ptr %retval, align 8
  ret ptr %18
}

; Function Attrs: nounwind uwtable
define internal ptr @stringlib_rsplit_whitespace(ptr noundef %str_obj, ptr noundef %str, i64 noundef %str_len, i64 noundef %maxcount) #0 {
entry:
  %op.addr.i164 = alloca ptr, align 8
  %op.addr.i160 = alloca ptr, align 8
  %op.addr.i156 = alloca ptr, align 8
  %op.addr.i152 = alloca ptr, align 8
  %op.addr.i150 = alloca ptr, align 8
  %op.addr.i146 = alloca ptr, align 8
  %cur_refcnt.i = alloca i32, align 4
  %new_refcnt.i = alloca i32, align 4
  %op.addr.i137 = alloca ptr, align 8
  %op.addr.i128 = alloca ptr, align 8
  %op.addr.i119 = alloca ptr, align 8
  %op.addr.i110 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %str_obj.addr = alloca ptr, align 8
  %str.addr = alloca ptr, align 8
  %str_len.addr = alloca i64, align 8
  %maxcount.addr = alloca i64, align 8
  %i = alloca i64, align 8
  %j = alloca i64, align 8
  %count = alloca i64, align 8
  %list = alloca ptr, align 8
  %sub = alloca ptr, align 8
  store ptr %str_obj, ptr %str_obj.addr, align 8
  store ptr %str, ptr %str.addr, align 8
  store i64 %str_len, ptr %str_len.addr, align 8
  store i64 %maxcount, ptr %maxcount.addr, align 8
  store i64 0, ptr %count, align 8
  %0 = load i64, ptr %maxcount.addr, align 8
  %cmp = icmp sge i64 %0, 12
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %1 = load i64, ptr %maxcount.addr, align 8
  %add = add i64 %1, 1
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ 12, %cond.true ], [ %add, %cond.false ]
  %call = call ptr @PyList_New(i64 noundef %cond)
  store ptr %call, ptr %list, align 8
  %2 = load ptr, ptr %list, align 8
  %cmp1 = icmp eq ptr %2, null
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end
  %3 = load i64, ptr %str_len.addr, align 8
  %sub2 = sub i64 %3, 1
  store i64 %sub2, ptr %j, align 8
  store i64 %sub2, ptr %i, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end59, %if.end
  %4 = load i64, ptr %maxcount.addr, align 8
  %dec = add i64 %4, -1
  store i64 %dec, ptr %maxcount.addr, align 8
  %cmp3 = icmp sgt i64 %4, 0
  br i1 %cmp3, label %while.body, label %while.end61

while.body:                                       ; preds = %while.cond
  br label %while.cond4

while.cond4:                                      ; preds = %while.body9, %while.body
  %5 = load i64, ptr %i, align 8
  %cmp5 = icmp sge i64 %5, 0
  br i1 %cmp5, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond4
  %6 = load ptr, ptr %str.addr, align 8
  %7 = load i64, ptr %i, align 8
  %arrayidx = getelementptr i8, ptr %6, i64 %7
  %8 = load i8, ptr %arrayidx, align 1
  %conv = sext i8 %8 to i32
  %and = and i32 %conv, 255
  %conv6 = trunc i32 %and to i8
  %idxprom = zext i8 %conv6 to i64
  %arrayidx7 = getelementptr [256 x i32], ptr @_Py_ctype_table, i64 0, i64 %idxprom
  %9 = load i32, ptr %arrayidx7, align 4
  %and8 = and i32 %9, 8
  %tobool = icmp ne i32 %and8, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond4
  %10 = phi i1 [ false, %while.cond4 ], [ %tobool, %land.rhs ]
  br i1 %10, label %while.body9, label %while.end

while.body9:                                      ; preds = %land.end
  %11 = load i64, ptr %i, align 8
  %dec10 = add i64 %11, -1
  store i64 %dec10, ptr %i, align 8
  br label %while.cond4, !llvm.loop !67

while.end:                                        ; preds = %land.end
  %12 = load i64, ptr %i, align 8
  %cmp11 = icmp slt i64 %12, 0
  br i1 %cmp11, label %if.then13, label %if.end14

if.then13:                                        ; preds = %while.end
  br label %while.end61

if.end14:                                         ; preds = %while.end
  %13 = load i64, ptr %i, align 8
  store i64 %13, ptr %j, align 8
  %14 = load i64, ptr %i, align 8
  %dec15 = add i64 %14, -1
  store i64 %dec15, ptr %i, align 8
  br label %while.cond16

while.cond16:                                     ; preds = %while.body29, %if.end14
  %15 = load i64, ptr %i, align 8
  %cmp17 = icmp sge i64 %15, 0
  br i1 %cmp17, label %land.rhs19, label %land.end28

land.rhs19:                                       ; preds = %while.cond16
  %16 = load ptr, ptr %str.addr, align 8
  %17 = load i64, ptr %i, align 8
  %arrayidx20 = getelementptr i8, ptr %16, i64 %17
  %18 = load i8, ptr %arrayidx20, align 1
  %conv21 = sext i8 %18 to i32
  %and22 = and i32 %conv21, 255
  %conv23 = trunc i32 %and22 to i8
  %idxprom24 = zext i8 %conv23 to i64
  %arrayidx25 = getelementptr [256 x i32], ptr @_Py_ctype_table, i64 0, i64 %idxprom24
  %19 = load i32, ptr %arrayidx25, align 4
  %and26 = and i32 %19, 8
  %tobool27 = icmp ne i32 %and26, 0
  %lnot = xor i1 %tobool27, true
  br label %land.end28

land.end28:                                       ; preds = %land.rhs19, %while.cond16
  %20 = phi i1 [ false, %while.cond16 ], [ %lnot, %land.rhs19 ]
  br i1 %20, label %while.body29, label %while.end31

while.body29:                                     ; preds = %land.end28
  %21 = load i64, ptr %i, align 8
  %dec30 = add i64 %21, -1
  store i64 %dec30, ptr %i, align 8
  br label %while.cond16, !llvm.loop !68

while.end31:                                      ; preds = %land.end28
  %22 = load i64, ptr %j, align 8
  %23 = load i64, ptr %str_len.addr, align 8
  %sub32 = sub i64 %23, 1
  %cmp33 = icmp eq i64 %22, %sub32
  br i1 %cmp33, label %land.lhs.true, label %if.end41

land.lhs.true:                                    ; preds = %while.end31
  %24 = load i64, ptr %i, align 8
  %cmp35 = icmp slt i64 %24, 0
  br i1 %cmp35, label %land.lhs.true37, label %if.end41

land.lhs.true37:                                  ; preds = %land.lhs.true
  %25 = load ptr, ptr %str_obj.addr, align 8
  %call38 = call i32 @Py_IS_TYPE(ptr noundef %25, ptr noundef @PyBytes_Type)
  %tobool39 = icmp ne i32 %call38, 0
  br i1 %tobool39, label %if.then40, label %if.end41

if.then40:                                        ; preds = %land.lhs.true37
  %26 = load ptr, ptr %str_obj.addr, align 8
  store ptr %26, ptr %op.addr.i146, align 8
  %27 = load ptr, ptr %op.addr.i146, align 8
  %28 = load i32, ptr %27, align 8
  store i32 %28, ptr %cur_refcnt.i, align 4
  %29 = load i32, ptr %cur_refcnt.i, align 4
  %add.i = add i32 %29, 1
  store i32 %add.i, ptr %new_refcnt.i, align 4
  %30 = load i32, ptr %new_refcnt.i, align 4
  %cmp.i147 = icmp eq i32 %30, 0
  br i1 %cmp.i147, label %if.then.i149, label %if.end.i148

if.then.i149:                                     ; preds = %if.then40
  br label %Py_INCREF.exit

if.end.i148:                                      ; preds = %if.then40
  %31 = load i32, ptr %new_refcnt.i, align 4
  %32 = load ptr, ptr %op.addr.i146, align 8
  store i32 %31, ptr %32, align 8
  br label %Py_INCREF.exit

Py_INCREF.exit:                                   ; preds = %if.end.i148, %if.then.i149
  %33 = load ptr, ptr %list, align 8
  %34 = load ptr, ptr %str_obj.addr, align 8
  call void @PyList_SET_ITEM(ptr noundef %33, i64 noundef 0, ptr noundef %34)
  %35 = load i64, ptr %count, align 8
  %inc = add i64 %35, 1
  store i64 %inc, ptr %count, align 8
  br label %while.end61

if.end41:                                         ; preds = %land.lhs.true37, %land.lhs.true, %while.end31
  %36 = load ptr, ptr %str.addr, align 8
  %37 = load i64, ptr %i, align 8
  %add42 = add i64 %37, 1
  %add.ptr = getelementptr i8, ptr %36, i64 %add42
  %38 = load i64, ptr %j, align 8
  %add43 = add i64 %38, 1
  %39 = load i64, ptr %i, align 8
  %add44 = add i64 %39, 1
  %sub45 = sub i64 %add43, %add44
  %call46 = call ptr @PyBytes_FromStringAndSize(ptr noundef %add.ptr, i64 noundef %sub45)
  store ptr %call46, ptr %sub, align 8
  %40 = load ptr, ptr %sub, align 8
  %cmp47 = icmp eq ptr %40, null
  br i1 %cmp47, label %if.then49, label %if.end50

if.then49:                                        ; preds = %if.end41
  br label %onError

if.end50:                                         ; preds = %if.end41
  %41 = load i64, ptr %count, align 8
  %cmp51 = icmp slt i64 %41, 12
  br i1 %cmp51, label %if.then53, label %if.else

if.then53:                                        ; preds = %if.end50
  %42 = load ptr, ptr %list, align 8
  %43 = load i64, ptr %count, align 8
  %44 = load ptr, ptr %sub, align 8
  call void @PyList_SET_ITEM(ptr noundef %42, i64 noundef %43, ptr noundef %44)
  br label %if.end59

if.else:                                          ; preds = %if.end50
  %45 = load ptr, ptr %list, align 8
  %46 = load ptr, ptr %sub, align 8
  %call54 = call i32 @PyList_Append(ptr noundef %45, ptr noundef %46)
  %tobool55 = icmp ne i32 %call54, 0
  br i1 %tobool55, label %if.then56, label %if.else57

if.then56:                                        ; preds = %if.else
  %47 = load ptr, ptr %sub, align 8
  store ptr %47, ptr %op.addr.i137, align 8
  %48 = load ptr, ptr %op.addr.i137, align 8
  store ptr %48, ptr %op.addr.i150, align 8
  %49 = load ptr, ptr %op.addr.i150, align 8
  %50 = load i64, ptr %49, align 8
  %conv.i = trunc i64 %50 to i32
  %cmp.i151 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i151 to i32
  %tobool.i139 = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i139, label %if.then.i144, label %if.end.i140

if.then.i144:                                     ; preds = %if.then56
  br label %Py_DECREF.exit145

if.end.i140:                                      ; preds = %if.then56
  %51 = load ptr, ptr %op.addr.i137, align 8
  %52 = load i64, ptr %51, align 8
  %dec.i141 = add i64 %52, -1
  store i64 %dec.i141, ptr %51, align 8
  %cmp.i142 = icmp eq i64 %dec.i141, 0
  br i1 %cmp.i142, label %if.then1.i143, label %Py_DECREF.exit145

if.then1.i143:                                    ; preds = %if.end.i140
  %53 = load ptr, ptr %op.addr.i137, align 8
  call void @_Py_Dealloc(ptr noundef %53) #9
  br label %Py_DECREF.exit145

Py_DECREF.exit145:                                ; preds = %if.then1.i143, %if.end.i140, %if.then.i144
  br label %onError

if.else57:                                        ; preds = %if.else
  %54 = load ptr, ptr %sub, align 8
  store ptr %54, ptr %op.addr.i128, align 8
  %55 = load ptr, ptr %op.addr.i128, align 8
  store ptr %55, ptr %op.addr.i152, align 8
  %56 = load ptr, ptr %op.addr.i152, align 8
  %57 = load i64, ptr %56, align 8
  %conv.i153 = trunc i64 %57 to i32
  %cmp.i154 = icmp slt i32 %conv.i153, 0
  %conv1.i155 = zext i1 %cmp.i154 to i32
  %tobool.i130 = icmp ne i32 %conv1.i155, 0
  br i1 %tobool.i130, label %if.then.i135, label %if.end.i131

if.then.i135:                                     ; preds = %if.else57
  br label %Py_DECREF.exit136

if.end.i131:                                      ; preds = %if.else57
  %58 = load ptr, ptr %op.addr.i128, align 8
  %59 = load i64, ptr %58, align 8
  %dec.i132 = add i64 %59, -1
  store i64 %dec.i132, ptr %58, align 8
  %cmp.i133 = icmp eq i64 %dec.i132, 0
  br i1 %cmp.i133, label %if.then1.i134, label %Py_DECREF.exit136

if.then1.i134:                                    ; preds = %if.end.i131
  %60 = load ptr, ptr %op.addr.i128, align 8
  call void @_Py_Dealloc(ptr noundef %60) #9
  br label %Py_DECREF.exit136

Py_DECREF.exit136:                                ; preds = %if.then1.i134, %if.end.i131, %if.then.i135
  br label %if.end58

if.end58:                                         ; preds = %Py_DECREF.exit136
  br label %if.end59

if.end59:                                         ; preds = %if.end58, %if.then53
  %61 = load i64, ptr %count, align 8
  %inc60 = add i64 %61, 1
  store i64 %inc60, ptr %count, align 8
  br label %while.cond, !llvm.loop !69

while.end61:                                      ; preds = %Py_INCREF.exit, %if.then13, %while.cond
  %62 = load i64, ptr %i, align 8
  %cmp62 = icmp sge i64 %62, 0
  br i1 %cmp62, label %if.then64, label %if.end104

if.then64:                                        ; preds = %while.end61
  br label %while.cond65

while.cond65:                                     ; preds = %while.body78, %if.then64
  %63 = load i64, ptr %i, align 8
  %cmp66 = icmp sge i64 %63, 0
  br i1 %cmp66, label %land.rhs68, label %land.end77

land.rhs68:                                       ; preds = %while.cond65
  %64 = load ptr, ptr %str.addr, align 8
  %65 = load i64, ptr %i, align 8
  %arrayidx69 = getelementptr i8, ptr %64, i64 %65
  %66 = load i8, ptr %arrayidx69, align 1
  %conv70 = sext i8 %66 to i32
  %and71 = and i32 %conv70, 255
  %conv72 = trunc i32 %and71 to i8
  %idxprom73 = zext i8 %conv72 to i64
  %arrayidx74 = getelementptr [256 x i32], ptr @_Py_ctype_table, i64 0, i64 %idxprom73
  %67 = load i32, ptr %arrayidx74, align 4
  %and75 = and i32 %67, 8
  %tobool76 = icmp ne i32 %and75, 0
  br label %land.end77

land.end77:                                       ; preds = %land.rhs68, %while.cond65
  %68 = phi i1 [ false, %while.cond65 ], [ %tobool76, %land.rhs68 ]
  br i1 %68, label %while.body78, label %while.end80

while.body78:                                     ; preds = %land.end77
  %69 = load i64, ptr %i, align 8
  %dec79 = add i64 %69, -1
  store i64 %dec79, ptr %i, align 8
  br label %while.cond65, !llvm.loop !70

while.end80:                                      ; preds = %land.end77
  %70 = load i64, ptr %i, align 8
  %cmp81 = icmp sge i64 %70, 0
  br i1 %cmp81, label %if.then83, label %if.end103

if.then83:                                        ; preds = %while.end80
  %71 = load ptr, ptr %str.addr, align 8
  %add.ptr84 = getelementptr i8, ptr %71, i64 0
  %72 = load i64, ptr %i, align 8
  %add85 = add i64 %72, 1
  %sub86 = sub i64 %add85, 0
  %call87 = call ptr @PyBytes_FromStringAndSize(ptr noundef %add.ptr84, i64 noundef %sub86)
  store ptr %call87, ptr %sub, align 8
  %73 = load ptr, ptr %sub, align 8
  %cmp88 = icmp eq ptr %73, null
  br i1 %cmp88, label %if.then90, label %if.end91

if.then90:                                        ; preds = %if.then83
  br label %onError

if.end91:                                         ; preds = %if.then83
  %74 = load i64, ptr %count, align 8
  %cmp92 = icmp slt i64 %74, 12
  br i1 %cmp92, label %if.then94, label %if.else95

if.then94:                                        ; preds = %if.end91
  %75 = load ptr, ptr %list, align 8
  %76 = load i64, ptr %count, align 8
  %77 = load ptr, ptr %sub, align 8
  call void @PyList_SET_ITEM(ptr noundef %75, i64 noundef %76, ptr noundef %77)
  br label %if.end101

if.else95:                                        ; preds = %if.end91
  %78 = load ptr, ptr %list, align 8
  %79 = load ptr, ptr %sub, align 8
  %call96 = call i32 @PyList_Append(ptr noundef %78, ptr noundef %79)
  %tobool97 = icmp ne i32 %call96, 0
  br i1 %tobool97, label %if.then98, label %if.else99

if.then98:                                        ; preds = %if.else95
  %80 = load ptr, ptr %sub, align 8
  store ptr %80, ptr %op.addr.i119, align 8
  %81 = load ptr, ptr %op.addr.i119, align 8
  store ptr %81, ptr %op.addr.i156, align 8
  %82 = load ptr, ptr %op.addr.i156, align 8
  %83 = load i64, ptr %82, align 8
  %conv.i157 = trunc i64 %83 to i32
  %cmp.i158 = icmp slt i32 %conv.i157, 0
  %conv1.i159 = zext i1 %cmp.i158 to i32
  %tobool.i121 = icmp ne i32 %conv1.i159, 0
  br i1 %tobool.i121, label %if.then.i126, label %if.end.i122

if.then.i126:                                     ; preds = %if.then98
  br label %Py_DECREF.exit127

if.end.i122:                                      ; preds = %if.then98
  %84 = load ptr, ptr %op.addr.i119, align 8
  %85 = load i64, ptr %84, align 8
  %dec.i123 = add i64 %85, -1
  store i64 %dec.i123, ptr %84, align 8
  %cmp.i124 = icmp eq i64 %dec.i123, 0
  br i1 %cmp.i124, label %if.then1.i125, label %Py_DECREF.exit127

if.then1.i125:                                    ; preds = %if.end.i122
  %86 = load ptr, ptr %op.addr.i119, align 8
  call void @_Py_Dealloc(ptr noundef %86) #9
  br label %Py_DECREF.exit127

Py_DECREF.exit127:                                ; preds = %if.then1.i125, %if.end.i122, %if.then.i126
  br label %onError

if.else99:                                        ; preds = %if.else95
  %87 = load ptr, ptr %sub, align 8
  store ptr %87, ptr %op.addr.i110, align 8
  %88 = load ptr, ptr %op.addr.i110, align 8
  store ptr %88, ptr %op.addr.i160, align 8
  %89 = load ptr, ptr %op.addr.i160, align 8
  %90 = load i64, ptr %89, align 8
  %conv.i161 = trunc i64 %90 to i32
  %cmp.i162 = icmp slt i32 %conv.i161, 0
  %conv1.i163 = zext i1 %cmp.i162 to i32
  %tobool.i112 = icmp ne i32 %conv1.i163, 0
  br i1 %tobool.i112, label %if.then.i117, label %if.end.i113

if.then.i117:                                     ; preds = %if.else99
  br label %Py_DECREF.exit118

if.end.i113:                                      ; preds = %if.else99
  %91 = load ptr, ptr %op.addr.i110, align 8
  %92 = load i64, ptr %91, align 8
  %dec.i114 = add i64 %92, -1
  store i64 %dec.i114, ptr %91, align 8
  %cmp.i115 = icmp eq i64 %dec.i114, 0
  br i1 %cmp.i115, label %if.then1.i116, label %Py_DECREF.exit118

if.then1.i116:                                    ; preds = %if.end.i113
  %93 = load ptr, ptr %op.addr.i110, align 8
  call void @_Py_Dealloc(ptr noundef %93) #9
  br label %Py_DECREF.exit118

Py_DECREF.exit118:                                ; preds = %if.then1.i116, %if.end.i113, %if.then.i117
  br label %if.end100

if.end100:                                        ; preds = %Py_DECREF.exit118
  br label %if.end101

if.end101:                                        ; preds = %if.end100, %if.then94
  %94 = load i64, ptr %count, align 8
  %inc102 = add i64 %94, 1
  store i64 %inc102, ptr %count, align 8
  br label %if.end103

if.end103:                                        ; preds = %if.end101, %while.end80
  br label %if.end104

if.end104:                                        ; preds = %if.end103, %while.end61
  %95 = load ptr, ptr %list, align 8
  %96 = load i64, ptr %count, align 8
  call void @Py_SET_SIZE(ptr noundef %95, i64 noundef %96)
  %97 = load ptr, ptr %list, align 8
  %call105 = call i32 @PyList_Reverse(ptr noundef %97)
  %cmp106 = icmp slt i32 %call105, 0
  br i1 %cmp106, label %if.then108, label %if.end109

if.then108:                                       ; preds = %if.end104
  br label %onError

if.end109:                                        ; preds = %if.end104
  %98 = load ptr, ptr %list, align 8
  store ptr %98, ptr %retval, align 8
  br label %return

onError:                                          ; preds = %if.then108, %Py_DECREF.exit127, %if.then90, %Py_DECREF.exit145, %if.then49
  %99 = load ptr, ptr %list, align 8
  store ptr %99, ptr %op.addr.i, align 8
  %100 = load ptr, ptr %op.addr.i, align 8
  store ptr %100, ptr %op.addr.i164, align 8
  %101 = load ptr, ptr %op.addr.i164, align 8
  %102 = load i64, ptr %101, align 8
  %conv.i165 = trunc i64 %102 to i32
  %cmp.i166 = icmp slt i32 %conv.i165, 0
  %conv1.i167 = zext i1 %cmp.i166 to i32
  %tobool.i = icmp ne i32 %conv1.i167, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %onError
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %onError
  %103 = load ptr, ptr %op.addr.i, align 8
  %104 = load i64, ptr %103, align 8
  %dec.i = add i64 %104, -1
  store i64 %dec.i, ptr %103, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %105 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %105) #9
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %Py_DECREF.exit, %if.end109, %if.then
  %106 = load ptr, ptr %retval, align 8
  ret ptr %106
}

; Function Attrs: nounwind uwtable
define internal ptr @stringlib_rsplit(ptr noundef %str_obj, ptr noundef %str, i64 noundef %str_len, ptr noundef %sep, i64 noundef %sep_len, i64 noundef %maxcount) #0 {
entry:
  %op.addr.i110 = alloca ptr, align 8
  %op.addr.i106 = alloca ptr, align 8
  %op.addr.i102 = alloca ptr, align 8
  %op.addr.i98 = alloca ptr, align 8
  %op.addr.i96 = alloca ptr, align 8
  %op.addr.i92 = alloca ptr, align 8
  %cur_refcnt.i = alloca i32, align 4
  %new_refcnt.i = alloca i32, align 4
  %op.addr.i83 = alloca ptr, align 8
  %op.addr.i74 = alloca ptr, align 8
  %op.addr.i65 = alloca ptr, align 8
  %op.addr.i56 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %str_obj.addr = alloca ptr, align 8
  %str.addr = alloca ptr, align 8
  %str_len.addr = alloca i64, align 8
  %sep.addr = alloca ptr, align 8
  %sep_len.addr = alloca i64, align 8
  %maxcount.addr = alloca i64, align 8
  %j = alloca i64, align 8
  %pos = alloca i64, align 8
  %count = alloca i64, align 8
  %list = alloca ptr, align 8
  %sub = alloca ptr, align 8
  store ptr %str_obj, ptr %str_obj.addr, align 8
  store ptr %str, ptr %str.addr, align 8
  store i64 %str_len, ptr %str_len.addr, align 8
  store ptr %sep, ptr %sep.addr, align 8
  store i64 %sep_len, ptr %sep_len.addr, align 8
  store i64 %maxcount, ptr %maxcount.addr, align 8
  store i64 0, ptr %count, align 8
  %0 = load i64, ptr %sep_len.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr @PyExc_ValueError, align 8
  call void @PyErr_SetString(ptr noundef %1, ptr noundef @.str.116)
  store ptr null, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %2 = load i64, ptr %sep_len.addr, align 8
  %cmp1 = icmp eq i64 %2, 1
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.else
  %3 = load ptr, ptr %str_obj.addr, align 8
  %4 = load ptr, ptr %str.addr, align 8
  %5 = load i64, ptr %str_len.addr, align 8
  %6 = load ptr, ptr %sep.addr, align 8
  %arrayidx = getelementptr i8, ptr %6, i64 0
  %7 = load i8, ptr %arrayidx, align 1
  %8 = load i64, ptr %maxcount.addr, align 8
  %call = call ptr @stringlib_rsplit_char(ptr noundef %3, ptr noundef %4, i64 noundef %5, i8 noundef signext %7, i64 noundef %8)
  store ptr %call, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %if.else
  br label %if.end3

if.end3:                                          ; preds = %if.end
  %9 = load i64, ptr %maxcount.addr, align 8
  %cmp4 = icmp sge i64 %9, 12
  br i1 %cmp4, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end3
  br label %cond.end

cond.false:                                       ; preds = %if.end3
  %10 = load i64, ptr %maxcount.addr, align 8
  %add = add i64 %10, 1
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ 12, %cond.true ], [ %add, %cond.false ]
  %call5 = call ptr @PyList_New(i64 noundef %cond)
  store ptr %call5, ptr %list, align 8
  %11 = load ptr, ptr %list, align 8
  %cmp6 = icmp eq ptr %11, null
  br i1 %cmp6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %cond.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end8:                                          ; preds = %cond.end
  %12 = load i64, ptr %str_len.addr, align 8
  store i64 %12, ptr %j, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end28, %if.end8
  %13 = load i64, ptr %maxcount.addr, align 8
  %dec = add i64 %13, -1
  store i64 %dec, ptr %maxcount.addr, align 8
  %cmp9 = icmp sgt i64 %13, 0
  br i1 %cmp9, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %14 = load ptr, ptr %str.addr, align 8
  %15 = load i64, ptr %j, align 8
  %16 = load ptr, ptr %sep.addr, align 8
  %17 = load i64, ptr %sep_len.addr, align 8
  %call10 = call i64 @fastsearch(ptr noundef %14, i64 noundef %15, ptr noundef %16, i64 noundef %17, i64 noundef -1, i32 noundef 2)
  store i64 %call10, ptr %pos, align 8
  %18 = load i64, ptr %pos, align 8
  %cmp11 = icmp slt i64 %18, 0
  br i1 %cmp11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %while.body
  br label %while.end

if.end13:                                         ; preds = %while.body
  %19 = load ptr, ptr %str.addr, align 8
  %20 = load i64, ptr %pos, align 8
  %21 = load i64, ptr %sep_len.addr, align 8
  %add14 = add i64 %20, %21
  %add.ptr = getelementptr i8, ptr %19, i64 %add14
  %22 = load i64, ptr %j, align 8
  %23 = load i64, ptr %pos, align 8
  %24 = load i64, ptr %sep_len.addr, align 8
  %add15 = add i64 %23, %24
  %sub16 = sub i64 %22, %add15
  %call17 = call ptr @PyBytes_FromStringAndSize(ptr noundef %add.ptr, i64 noundef %sub16)
  store ptr %call17, ptr %sub, align 8
  %25 = load ptr, ptr %sub, align 8
  %cmp18 = icmp eq ptr %25, null
  br i1 %cmp18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %if.end13
  br label %onError

if.end20:                                         ; preds = %if.end13
  %26 = load i64, ptr %count, align 8
  %cmp21 = icmp slt i64 %26, 12
  br i1 %cmp21, label %if.then22, label %if.else23

if.then22:                                        ; preds = %if.end20
  %27 = load ptr, ptr %list, align 8
  %28 = load i64, ptr %count, align 8
  %29 = load ptr, ptr %sub, align 8
  call void @PyList_SET_ITEM(ptr noundef %27, i64 noundef %28, ptr noundef %29)
  br label %if.end28

if.else23:                                        ; preds = %if.end20
  %30 = load ptr, ptr %list, align 8
  %31 = load ptr, ptr %sub, align 8
  %call24 = call i32 @PyList_Append(ptr noundef %30, ptr noundef %31)
  %tobool = icmp ne i32 %call24, 0
  br i1 %tobool, label %if.then25, label %if.else26

if.then25:                                        ; preds = %if.else23
  %32 = load ptr, ptr %sub, align 8
  store ptr %32, ptr %op.addr.i83, align 8
  %33 = load ptr, ptr %op.addr.i83, align 8
  store ptr %33, ptr %op.addr.i96, align 8
  %34 = load ptr, ptr %op.addr.i96, align 8
  %35 = load i64, ptr %34, align 8
  %conv.i = trunc i64 %35 to i32
  %cmp.i97 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i97 to i32
  %tobool.i85 = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i85, label %if.then.i90, label %if.end.i86

if.then.i90:                                      ; preds = %if.then25
  br label %Py_DECREF.exit91

if.end.i86:                                       ; preds = %if.then25
  %36 = load ptr, ptr %op.addr.i83, align 8
  %37 = load i64, ptr %36, align 8
  %dec.i87 = add i64 %37, -1
  store i64 %dec.i87, ptr %36, align 8
  %cmp.i88 = icmp eq i64 %dec.i87, 0
  br i1 %cmp.i88, label %if.then1.i89, label %Py_DECREF.exit91

if.then1.i89:                                     ; preds = %if.end.i86
  %38 = load ptr, ptr %op.addr.i83, align 8
  call void @_Py_Dealloc(ptr noundef %38) #9
  br label %Py_DECREF.exit91

Py_DECREF.exit91:                                 ; preds = %if.then1.i89, %if.end.i86, %if.then.i90
  br label %onError

if.else26:                                        ; preds = %if.else23
  %39 = load ptr, ptr %sub, align 8
  store ptr %39, ptr %op.addr.i74, align 8
  %40 = load ptr, ptr %op.addr.i74, align 8
  store ptr %40, ptr %op.addr.i98, align 8
  %41 = load ptr, ptr %op.addr.i98, align 8
  %42 = load i64, ptr %41, align 8
  %conv.i99 = trunc i64 %42 to i32
  %cmp.i100 = icmp slt i32 %conv.i99, 0
  %conv1.i101 = zext i1 %cmp.i100 to i32
  %tobool.i76 = icmp ne i32 %conv1.i101, 0
  br i1 %tobool.i76, label %if.then.i81, label %if.end.i77

if.then.i81:                                      ; preds = %if.else26
  br label %Py_DECREF.exit82

if.end.i77:                                       ; preds = %if.else26
  %43 = load ptr, ptr %op.addr.i74, align 8
  %44 = load i64, ptr %43, align 8
  %dec.i78 = add i64 %44, -1
  store i64 %dec.i78, ptr %43, align 8
  %cmp.i79 = icmp eq i64 %dec.i78, 0
  br i1 %cmp.i79, label %if.then1.i80, label %Py_DECREF.exit82

if.then1.i80:                                     ; preds = %if.end.i77
  %45 = load ptr, ptr %op.addr.i74, align 8
  call void @_Py_Dealloc(ptr noundef %45) #9
  br label %Py_DECREF.exit82

Py_DECREF.exit82:                                 ; preds = %if.then1.i80, %if.end.i77, %if.then.i81
  br label %if.end27

if.end27:                                         ; preds = %Py_DECREF.exit82
  br label %if.end28

if.end28:                                         ; preds = %if.end27, %if.then22
  %46 = load i64, ptr %count, align 8
  %inc = add i64 %46, 1
  store i64 %inc, ptr %count, align 8
  %47 = load i64, ptr %pos, align 8
  store i64 %47, ptr %j, align 8
  br label %while.cond, !llvm.loop !71

while.end:                                        ; preds = %if.then12, %while.cond
  %48 = load i64, ptr %count, align 8
  %cmp29 = icmp eq i64 %48, 0
  br i1 %cmp29, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %while.end
  %49 = load ptr, ptr %str_obj.addr, align 8
  %call30 = call i32 @Py_IS_TYPE(ptr noundef %49, ptr noundef @PyBytes_Type)
  %tobool31 = icmp ne i32 %call30, 0
  br i1 %tobool31, label %if.then32, label %if.else34

if.then32:                                        ; preds = %land.lhs.true
  %50 = load ptr, ptr %str_obj.addr, align 8
  store ptr %50, ptr %op.addr.i92, align 8
  %51 = load ptr, ptr %op.addr.i92, align 8
  %52 = load i32, ptr %51, align 8
  store i32 %52, ptr %cur_refcnt.i, align 4
  %53 = load i32, ptr %cur_refcnt.i, align 4
  %add.i = add i32 %53, 1
  store i32 %add.i, ptr %new_refcnt.i, align 4
  %54 = load i32, ptr %new_refcnt.i, align 4
  %cmp.i93 = icmp eq i32 %54, 0
  br i1 %cmp.i93, label %if.then.i95, label %if.end.i94

if.then.i95:                                      ; preds = %if.then32
  br label %Py_INCREF.exit

if.end.i94:                                       ; preds = %if.then32
  %55 = load i32, ptr %new_refcnt.i, align 4
  %56 = load ptr, ptr %op.addr.i92, align 8
  store i32 %55, ptr %56, align 8
  br label %Py_INCREF.exit

Py_INCREF.exit:                                   ; preds = %if.end.i94, %if.then.i95
  %57 = load ptr, ptr %list, align 8
  %58 = load ptr, ptr %str_obj.addr, align 8
  call void @PyList_SET_ITEM(ptr noundef %57, i64 noundef 0, ptr noundef %58)
  %59 = load i64, ptr %count, align 8
  %inc33 = add i64 %59, 1
  store i64 %inc33, ptr %count, align 8
  br label %if.end51

if.else34:                                        ; preds = %land.lhs.true, %while.end
  %60 = load ptr, ptr %str.addr, align 8
  %add.ptr35 = getelementptr i8, ptr %60, i64 0
  %61 = load i64, ptr %j, align 8
  %sub36 = sub i64 %61, 0
  %call37 = call ptr @PyBytes_FromStringAndSize(ptr noundef %add.ptr35, i64 noundef %sub36)
  store ptr %call37, ptr %sub, align 8
  %62 = load ptr, ptr %sub, align 8
  %cmp38 = icmp eq ptr %62, null
  br i1 %cmp38, label %if.then39, label %if.end40

if.then39:                                        ; preds = %if.else34
  br label %onError

if.end40:                                         ; preds = %if.else34
  %63 = load i64, ptr %count, align 8
  %cmp41 = icmp slt i64 %63, 12
  br i1 %cmp41, label %if.then42, label %if.else43

if.then42:                                        ; preds = %if.end40
  %64 = load ptr, ptr %list, align 8
  %65 = load i64, ptr %count, align 8
  %66 = load ptr, ptr %sub, align 8
  call void @PyList_SET_ITEM(ptr noundef %64, i64 noundef %65, ptr noundef %66)
  br label %if.end49

if.else43:                                        ; preds = %if.end40
  %67 = load ptr, ptr %list, align 8
  %68 = load ptr, ptr %sub, align 8
  %call44 = call i32 @PyList_Append(ptr noundef %67, ptr noundef %68)
  %tobool45 = icmp ne i32 %call44, 0
  br i1 %tobool45, label %if.then46, label %if.else47

if.then46:                                        ; preds = %if.else43
  %69 = load ptr, ptr %sub, align 8
  store ptr %69, ptr %op.addr.i65, align 8
  %70 = load ptr, ptr %op.addr.i65, align 8
  store ptr %70, ptr %op.addr.i102, align 8
  %71 = load ptr, ptr %op.addr.i102, align 8
  %72 = load i64, ptr %71, align 8
  %conv.i103 = trunc i64 %72 to i32
  %cmp.i104 = icmp slt i32 %conv.i103, 0
  %conv1.i105 = zext i1 %cmp.i104 to i32
  %tobool.i67 = icmp ne i32 %conv1.i105, 0
  br i1 %tobool.i67, label %if.then.i72, label %if.end.i68

if.then.i72:                                      ; preds = %if.then46
  br label %Py_DECREF.exit73

if.end.i68:                                       ; preds = %if.then46
  %73 = load ptr, ptr %op.addr.i65, align 8
  %74 = load i64, ptr %73, align 8
  %dec.i69 = add i64 %74, -1
  store i64 %dec.i69, ptr %73, align 8
  %cmp.i70 = icmp eq i64 %dec.i69, 0
  br i1 %cmp.i70, label %if.then1.i71, label %Py_DECREF.exit73

if.then1.i71:                                     ; preds = %if.end.i68
  %75 = load ptr, ptr %op.addr.i65, align 8
  call void @_Py_Dealloc(ptr noundef %75) #9
  br label %Py_DECREF.exit73

Py_DECREF.exit73:                                 ; preds = %if.then1.i71, %if.end.i68, %if.then.i72
  br label %onError

if.else47:                                        ; preds = %if.else43
  %76 = load ptr, ptr %sub, align 8
  store ptr %76, ptr %op.addr.i56, align 8
  %77 = load ptr, ptr %op.addr.i56, align 8
  store ptr %77, ptr %op.addr.i106, align 8
  %78 = load ptr, ptr %op.addr.i106, align 8
  %79 = load i64, ptr %78, align 8
  %conv.i107 = trunc i64 %79 to i32
  %cmp.i108 = icmp slt i32 %conv.i107, 0
  %conv1.i109 = zext i1 %cmp.i108 to i32
  %tobool.i58 = icmp ne i32 %conv1.i109, 0
  br i1 %tobool.i58, label %if.then.i63, label %if.end.i59

if.then.i63:                                      ; preds = %if.else47
  br label %Py_DECREF.exit64

if.end.i59:                                       ; preds = %if.else47
  %80 = load ptr, ptr %op.addr.i56, align 8
  %81 = load i64, ptr %80, align 8
  %dec.i60 = add i64 %81, -1
  store i64 %dec.i60, ptr %80, align 8
  %cmp.i61 = icmp eq i64 %dec.i60, 0
  br i1 %cmp.i61, label %if.then1.i62, label %Py_DECREF.exit64

if.then1.i62:                                     ; preds = %if.end.i59
  %82 = load ptr, ptr %op.addr.i56, align 8
  call void @_Py_Dealloc(ptr noundef %82) #9
  br label %Py_DECREF.exit64

Py_DECREF.exit64:                                 ; preds = %if.then1.i62, %if.end.i59, %if.then.i63
  br label %if.end48

if.end48:                                         ; preds = %Py_DECREF.exit64
  br label %if.end49

if.end49:                                         ; preds = %if.end48, %if.then42
  %83 = load i64, ptr %count, align 8
  %inc50 = add i64 %83, 1
  store i64 %inc50, ptr %count, align 8
  br label %if.end51

if.end51:                                         ; preds = %if.end49, %Py_INCREF.exit
  %84 = load ptr, ptr %list, align 8
  %85 = load i64, ptr %count, align 8
  call void @Py_SET_SIZE(ptr noundef %84, i64 noundef %85)
  %86 = load ptr, ptr %list, align 8
  %call52 = call i32 @PyList_Reverse(ptr noundef %86)
  %cmp53 = icmp slt i32 %call52, 0
  br i1 %cmp53, label %if.then54, label %if.end55

if.then54:                                        ; preds = %if.end51
  br label %onError

if.end55:                                         ; preds = %if.end51
  %87 = load ptr, ptr %list, align 8
  store ptr %87, ptr %retval, align 8
  br label %return

onError:                                          ; preds = %if.then54, %Py_DECREF.exit73, %if.then39, %Py_DECREF.exit91, %if.then19
  %88 = load ptr, ptr %list, align 8
  store ptr %88, ptr %op.addr.i, align 8
  %89 = load ptr, ptr %op.addr.i, align 8
  store ptr %89, ptr %op.addr.i110, align 8
  %90 = load ptr, ptr %op.addr.i110, align 8
  %91 = load i64, ptr %90, align 8
  %conv.i111 = trunc i64 %91 to i32
  %cmp.i112 = icmp slt i32 %conv.i111, 0
  %conv1.i113 = zext i1 %cmp.i112 to i32
  %tobool.i = icmp ne i32 %conv1.i113, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %onError
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %onError
  %92 = load ptr, ptr %op.addr.i, align 8
  %93 = load i64, ptr %92, align 8
  %dec.i = add i64 %93, -1
  store i64 %dec.i, ptr %92, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %94 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %94) #9
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %Py_DECREF.exit, %if.end55, %if.then7, %if.then2, %if.then
  %95 = load ptr, ptr %retval, align 8
  ret ptr %95
}

declare ptr @PyList_New(i64 noundef) #1

; Function Attrs: nounwind uwtable
define internal void @PyList_SET_ITEM(ptr noundef %op, i64 noundef %index, ptr noundef %value) #0 {
entry:
  %op.addr = alloca ptr, align 8
  %index.addr = alloca i64, align 8
  %value.addr = alloca ptr, align 8
  %list = alloca ptr, align 8
  store ptr %op, ptr %op.addr, align 8
  store i64 %index, ptr %index.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  %0 = load ptr, ptr %op.addr, align 8
  store ptr %0, ptr %list, align 8
  %1 = load ptr, ptr %value.addr, align 8
  %2 = load ptr, ptr %list, align 8
  %ob_item = getelementptr inbounds %struct.PyListObject, ptr %2, i32 0, i32 1
  %3 = load ptr, ptr %ob_item, align 8
  %4 = load i64, ptr %index.addr, align 8
  %arrayidx = getelementptr ptr, ptr %3, i64 %4
  store ptr %1, ptr %arrayidx, align 8
  ret void
}

declare i32 @PyList_Append(ptr noundef, ptr noundef) #1

declare i32 @PyList_Reverse(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @stringlib_rsplit_char(ptr noundef %str_obj, ptr noundef %str, i64 noundef %str_len, i8 noundef signext %ch, i64 noundef %maxcount) #0 {
entry:
  %op.addr.i120 = alloca ptr, align 8
  %op.addr.i116 = alloca ptr, align 8
  %op.addr.i112 = alloca ptr, align 8
  %op.addr.i108 = alloca ptr, align 8
  %op.addr.i106 = alloca ptr, align 8
  %op.addr.i102 = alloca ptr, align 8
  %cur_refcnt.i = alloca i32, align 4
  %new_refcnt.i = alloca i32, align 4
  %op.addr.i93 = alloca ptr, align 8
  %op.addr.i84 = alloca ptr, align 8
  %op.addr.i75 = alloca ptr, align 8
  %op.addr.i66 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %str_obj.addr = alloca ptr, align 8
  %str.addr = alloca ptr, align 8
  %str_len.addr = alloca i64, align 8
  %ch.addr = alloca i8, align 1
  %maxcount.addr = alloca i64, align 8
  %i = alloca i64, align 8
  %j = alloca i64, align 8
  %count = alloca i64, align 8
  %list = alloca ptr, align 8
  %sub = alloca ptr, align 8
  store ptr %str_obj, ptr %str_obj.addr, align 8
  store ptr %str, ptr %str.addr, align 8
  store i64 %str_len, ptr %str_len.addr, align 8
  store i8 %ch, ptr %ch.addr, align 1
  store i64 %maxcount, ptr %maxcount.addr, align 8
  store i64 0, ptr %count, align 8
  %0 = load i64, ptr %maxcount.addr, align 8
  %cmp = icmp sge i64 %0, 12
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %1 = load i64, ptr %maxcount.addr, align 8
  %add = add i64 %1, 1
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ 12, %cond.true ], [ %add, %cond.false ]
  %call = call ptr @PyList_New(i64 noundef %cond)
  store ptr %call, ptr %list, align 8
  %2 = load ptr, ptr %list, align 8
  %cmp1 = icmp eq ptr %2, null
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end
  %3 = load i64, ptr %str_len.addr, align 8
  %sub2 = sub i64 %3, 1
  store i64 %sub2, ptr %j, align 8
  store i64 %sub2, ptr %i, align 8
  br label %while.cond

while.cond:                                       ; preds = %for.end, %if.end
  %4 = load i64, ptr %i, align 8
  %cmp3 = icmp sge i64 %4, 0
  br i1 %cmp3, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %5 = load i64, ptr %maxcount.addr, align 8
  %dec = add i64 %5, -1
  store i64 %dec, ptr %maxcount.addr, align 8
  %cmp4 = icmp sgt i64 %5, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %6 = phi i1 [ false, %while.cond ], [ %cmp4, %land.rhs ]
  br i1 %6, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %while.body
  %7 = load i64, ptr %i, align 8
  %cmp5 = icmp sge i64 %7, 0
  br i1 %cmp5, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load ptr, ptr %str.addr, align 8
  %9 = load i64, ptr %i, align 8
  %arrayidx = getelementptr i8, ptr %8, i64 %9
  %10 = load i8, ptr %arrayidx, align 1
  %conv = sext i8 %10 to i32
  %11 = load i8, ptr %ch.addr, align 1
  %conv6 = sext i8 %11 to i32
  %cmp7 = icmp eq i32 %conv, %conv6
  br i1 %cmp7, label %if.then9, label %if.end28

if.then9:                                         ; preds = %for.body
  %12 = load ptr, ptr %str.addr, align 8
  %13 = load i64, ptr %i, align 8
  %add10 = add i64 %13, 1
  %add.ptr = getelementptr i8, ptr %12, i64 %add10
  %14 = load i64, ptr %j, align 8
  %add11 = add i64 %14, 1
  %15 = load i64, ptr %i, align 8
  %add12 = add i64 %15, 1
  %sub13 = sub i64 %add11, %add12
  %call14 = call ptr @PyBytes_FromStringAndSize(ptr noundef %add.ptr, i64 noundef %sub13)
  store ptr %call14, ptr %sub, align 8
  %16 = load ptr, ptr %sub, align 8
  %cmp15 = icmp eq ptr %16, null
  br i1 %cmp15, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.then9
  br label %onError

if.end18:                                         ; preds = %if.then9
  %17 = load i64, ptr %count, align 8
  %cmp19 = icmp slt i64 %17, 12
  br i1 %cmp19, label %if.then21, label %if.else

if.then21:                                        ; preds = %if.end18
  %18 = load ptr, ptr %list, align 8
  %19 = load i64, ptr %count, align 8
  %20 = load ptr, ptr %sub, align 8
  call void @PyList_SET_ITEM(ptr noundef %18, i64 noundef %19, ptr noundef %20)
  br label %if.end26

if.else:                                          ; preds = %if.end18
  %21 = load ptr, ptr %list, align 8
  %22 = load ptr, ptr %sub, align 8
  %call22 = call i32 @PyList_Append(ptr noundef %21, ptr noundef %22)
  %tobool = icmp ne i32 %call22, 0
  br i1 %tobool, label %if.then23, label %if.else24

if.then23:                                        ; preds = %if.else
  %23 = load ptr, ptr %sub, align 8
  store ptr %23, ptr %op.addr.i93, align 8
  %24 = load ptr, ptr %op.addr.i93, align 8
  store ptr %24, ptr %op.addr.i106, align 8
  %25 = load ptr, ptr %op.addr.i106, align 8
  %26 = load i64, ptr %25, align 8
  %conv.i = trunc i64 %26 to i32
  %cmp.i107 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i107 to i32
  %tobool.i95 = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i95, label %if.then.i100, label %if.end.i96

if.then.i100:                                     ; preds = %if.then23
  br label %Py_DECREF.exit101

if.end.i96:                                       ; preds = %if.then23
  %27 = load ptr, ptr %op.addr.i93, align 8
  %28 = load i64, ptr %27, align 8
  %dec.i97 = add i64 %28, -1
  store i64 %dec.i97, ptr %27, align 8
  %cmp.i98 = icmp eq i64 %dec.i97, 0
  br i1 %cmp.i98, label %if.then1.i99, label %Py_DECREF.exit101

if.then1.i99:                                     ; preds = %if.end.i96
  %29 = load ptr, ptr %op.addr.i93, align 8
  call void @_Py_Dealloc(ptr noundef %29) #9
  br label %Py_DECREF.exit101

Py_DECREF.exit101:                                ; preds = %if.then1.i99, %if.end.i96, %if.then.i100
  br label %onError

if.else24:                                        ; preds = %if.else
  %30 = load ptr, ptr %sub, align 8
  store ptr %30, ptr %op.addr.i84, align 8
  %31 = load ptr, ptr %op.addr.i84, align 8
  store ptr %31, ptr %op.addr.i108, align 8
  %32 = load ptr, ptr %op.addr.i108, align 8
  %33 = load i64, ptr %32, align 8
  %conv.i109 = trunc i64 %33 to i32
  %cmp.i110 = icmp slt i32 %conv.i109, 0
  %conv1.i111 = zext i1 %cmp.i110 to i32
  %tobool.i86 = icmp ne i32 %conv1.i111, 0
  br i1 %tobool.i86, label %if.then.i91, label %if.end.i87

if.then.i91:                                      ; preds = %if.else24
  br label %Py_DECREF.exit92

if.end.i87:                                       ; preds = %if.else24
  %34 = load ptr, ptr %op.addr.i84, align 8
  %35 = load i64, ptr %34, align 8
  %dec.i88 = add i64 %35, -1
  store i64 %dec.i88, ptr %34, align 8
  %cmp.i89 = icmp eq i64 %dec.i88, 0
  br i1 %cmp.i89, label %if.then1.i90, label %Py_DECREF.exit92

if.then1.i90:                                     ; preds = %if.end.i87
  %36 = load ptr, ptr %op.addr.i84, align 8
  call void @_Py_Dealloc(ptr noundef %36) #9
  br label %Py_DECREF.exit92

Py_DECREF.exit92:                                 ; preds = %if.then1.i90, %if.end.i87, %if.then.i91
  br label %if.end25

if.end25:                                         ; preds = %Py_DECREF.exit92
  br label %if.end26

if.end26:                                         ; preds = %if.end25, %if.then21
  %37 = load i64, ptr %count, align 8
  %inc = add i64 %37, 1
  store i64 %inc, ptr %count, align 8
  %38 = load i64, ptr %i, align 8
  %sub27 = sub i64 %38, 1
  store i64 %sub27, ptr %i, align 8
  store i64 %sub27, ptr %j, align 8
  br label %for.end

if.end28:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end28
  %39 = load i64, ptr %i, align 8
  %dec29 = add i64 %39, -1
  store i64 %dec29, ptr %i, align 8
  br label %for.cond, !llvm.loop !72

for.end:                                          ; preds = %if.end26, %for.cond
  br label %while.cond, !llvm.loop !73

while.end:                                        ; preds = %land.end
  %40 = load i64, ptr %count, align 8
  %cmp30 = icmp eq i64 %40, 0
  br i1 %cmp30, label %land.lhs.true, label %if.else36

land.lhs.true:                                    ; preds = %while.end
  %41 = load ptr, ptr %str_obj.addr, align 8
  %call32 = call i32 @Py_IS_TYPE(ptr noundef %41, ptr noundef @PyBytes_Type)
  %tobool33 = icmp ne i32 %call32, 0
  br i1 %tobool33, label %if.then34, label %if.else36

if.then34:                                        ; preds = %land.lhs.true
  %42 = load ptr, ptr %str_obj.addr, align 8
  store ptr %42, ptr %op.addr.i102, align 8
  %43 = load ptr, ptr %op.addr.i102, align 8
  %44 = load i32, ptr %43, align 8
  store i32 %44, ptr %cur_refcnt.i, align 4
  %45 = load i32, ptr %cur_refcnt.i, align 4
  %add.i = add i32 %45, 1
  store i32 %add.i, ptr %new_refcnt.i, align 4
  %46 = load i32, ptr %new_refcnt.i, align 4
  %cmp.i103 = icmp eq i32 %46, 0
  br i1 %cmp.i103, label %if.then.i105, label %if.end.i104

if.then.i105:                                     ; preds = %if.then34
  br label %Py_INCREF.exit

if.end.i104:                                      ; preds = %if.then34
  %47 = load i32, ptr %new_refcnt.i, align 4
  %48 = load ptr, ptr %op.addr.i102, align 8
  store i32 %47, ptr %48, align 8
  br label %Py_INCREF.exit

Py_INCREF.exit:                                   ; preds = %if.end.i104, %if.then.i105
  %49 = load ptr, ptr %list, align 8
  %50 = load ptr, ptr %str_obj.addr, align 8
  call void @PyList_SET_ITEM(ptr noundef %49, i64 noundef 0, ptr noundef %50)
  %51 = load i64, ptr %count, align 8
  %inc35 = add i64 %51, 1
  store i64 %inc35, ptr %count, align 8
  br label %if.end60

if.else36:                                        ; preds = %land.lhs.true, %while.end
  %52 = load i64, ptr %j, align 8
  %cmp37 = icmp sge i64 %52, -1
  br i1 %cmp37, label %if.then39, label %if.end59

if.then39:                                        ; preds = %if.else36
  %53 = load ptr, ptr %str.addr, align 8
  %add.ptr40 = getelementptr i8, ptr %53, i64 0
  %54 = load i64, ptr %j, align 8
  %add41 = add i64 %54, 1
  %sub42 = sub i64 %add41, 0
  %call43 = call ptr @PyBytes_FromStringAndSize(ptr noundef %add.ptr40, i64 noundef %sub42)
  store ptr %call43, ptr %sub, align 8
  %55 = load ptr, ptr %sub, align 8
  %cmp44 = icmp eq ptr %55, null
  br i1 %cmp44, label %if.then46, label %if.end47

if.then46:                                        ; preds = %if.then39
  br label %onError

if.end47:                                         ; preds = %if.then39
  %56 = load i64, ptr %count, align 8
  %cmp48 = icmp slt i64 %56, 12
  br i1 %cmp48, label %if.then50, label %if.else51

if.then50:                                        ; preds = %if.end47
  %57 = load ptr, ptr %list, align 8
  %58 = load i64, ptr %count, align 8
  %59 = load ptr, ptr %sub, align 8
  call void @PyList_SET_ITEM(ptr noundef %57, i64 noundef %58, ptr noundef %59)
  br label %if.end57

if.else51:                                        ; preds = %if.end47
  %60 = load ptr, ptr %list, align 8
  %61 = load ptr, ptr %sub, align 8
  %call52 = call i32 @PyList_Append(ptr noundef %60, ptr noundef %61)
  %tobool53 = icmp ne i32 %call52, 0
  br i1 %tobool53, label %if.then54, label %if.else55

if.then54:                                        ; preds = %if.else51
  %62 = load ptr, ptr %sub, align 8
  store ptr %62, ptr %op.addr.i75, align 8
  %63 = load ptr, ptr %op.addr.i75, align 8
  store ptr %63, ptr %op.addr.i112, align 8
  %64 = load ptr, ptr %op.addr.i112, align 8
  %65 = load i64, ptr %64, align 8
  %conv.i113 = trunc i64 %65 to i32
  %cmp.i114 = icmp slt i32 %conv.i113, 0
  %conv1.i115 = zext i1 %cmp.i114 to i32
  %tobool.i77 = icmp ne i32 %conv1.i115, 0
  br i1 %tobool.i77, label %if.then.i82, label %if.end.i78

if.then.i82:                                      ; preds = %if.then54
  br label %Py_DECREF.exit83

if.end.i78:                                       ; preds = %if.then54
  %66 = load ptr, ptr %op.addr.i75, align 8
  %67 = load i64, ptr %66, align 8
  %dec.i79 = add i64 %67, -1
  store i64 %dec.i79, ptr %66, align 8
  %cmp.i80 = icmp eq i64 %dec.i79, 0
  br i1 %cmp.i80, label %if.then1.i81, label %Py_DECREF.exit83

if.then1.i81:                                     ; preds = %if.end.i78
  %68 = load ptr, ptr %op.addr.i75, align 8
  call void @_Py_Dealloc(ptr noundef %68) #9
  br label %Py_DECREF.exit83

Py_DECREF.exit83:                                 ; preds = %if.then1.i81, %if.end.i78, %if.then.i82
  br label %onError

if.else55:                                        ; preds = %if.else51
  %69 = load ptr, ptr %sub, align 8
  store ptr %69, ptr %op.addr.i66, align 8
  %70 = load ptr, ptr %op.addr.i66, align 8
  store ptr %70, ptr %op.addr.i116, align 8
  %71 = load ptr, ptr %op.addr.i116, align 8
  %72 = load i64, ptr %71, align 8
  %conv.i117 = trunc i64 %72 to i32
  %cmp.i118 = icmp slt i32 %conv.i117, 0
  %conv1.i119 = zext i1 %cmp.i118 to i32
  %tobool.i68 = icmp ne i32 %conv1.i119, 0
  br i1 %tobool.i68, label %if.then.i73, label %if.end.i69

if.then.i73:                                      ; preds = %if.else55
  br label %Py_DECREF.exit74

if.end.i69:                                       ; preds = %if.else55
  %73 = load ptr, ptr %op.addr.i66, align 8
  %74 = load i64, ptr %73, align 8
  %dec.i70 = add i64 %74, -1
  store i64 %dec.i70, ptr %73, align 8
  %cmp.i71 = icmp eq i64 %dec.i70, 0
  br i1 %cmp.i71, label %if.then1.i72, label %Py_DECREF.exit74

if.then1.i72:                                     ; preds = %if.end.i69
  %75 = load ptr, ptr %op.addr.i66, align 8
  call void @_Py_Dealloc(ptr noundef %75) #9
  br label %Py_DECREF.exit74

Py_DECREF.exit74:                                 ; preds = %if.then1.i72, %if.end.i69, %if.then.i73
  br label %if.end56

if.end56:                                         ; preds = %Py_DECREF.exit74
  br label %if.end57

if.end57:                                         ; preds = %if.end56, %if.then50
  %76 = load i64, ptr %count, align 8
  %inc58 = add i64 %76, 1
  store i64 %inc58, ptr %count, align 8
  br label %if.end59

if.end59:                                         ; preds = %if.end57, %if.else36
  br label %if.end60

if.end60:                                         ; preds = %if.end59, %Py_INCREF.exit
  %77 = load ptr, ptr %list, align 8
  %78 = load i64, ptr %count, align 8
  call void @Py_SET_SIZE(ptr noundef %77, i64 noundef %78)
  %79 = load ptr, ptr %list, align 8
  %call61 = call i32 @PyList_Reverse(ptr noundef %79)
  %cmp62 = icmp slt i32 %call61, 0
  br i1 %cmp62, label %if.then64, label %if.end65

if.then64:                                        ; preds = %if.end60
  br label %onError

if.end65:                                         ; preds = %if.end60
  %80 = load ptr, ptr %list, align 8
  store ptr %80, ptr %retval, align 8
  br label %return

onError:                                          ; preds = %if.then64, %Py_DECREF.exit83, %if.then46, %Py_DECREF.exit101, %if.then17
  %81 = load ptr, ptr %list, align 8
  store ptr %81, ptr %op.addr.i, align 8
  %82 = load ptr, ptr %op.addr.i, align 8
  store ptr %82, ptr %op.addr.i120, align 8
  %83 = load ptr, ptr %op.addr.i120, align 8
  %84 = load i64, ptr %83, align 8
  %conv.i121 = trunc i64 %84 to i32
  %cmp.i122 = icmp slt i32 %conv.i121, 0
  %conv1.i123 = zext i1 %cmp.i122 to i32
  %tobool.i = icmp ne i32 %conv1.i123, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %onError
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %onError
  %85 = load ptr, ptr %op.addr.i, align 8
  %86 = load i64, ptr %85, align 8
  %dec.i = add i64 %86, -1
  store i64 %dec.i, ptr %85, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %87 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %87) #9
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %Py_DECREF.exit, %if.end65, %if.then
  %88 = load ptr, ptr %retval, align 8
  ret ptr %88
}

; Function Attrs: nounwind uwtable
define internal ptr @bytes_rstrip_impl(ptr noundef %self, ptr noundef %bytes) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %bytes.addr = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %bytes, ptr %bytes.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %1 = load ptr, ptr %bytes.addr, align 8
  %call = call ptr @do_argstrip(ptr noundef %0, i32 noundef 1, ptr noundef %1)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal ptr @bytes_split_impl(ptr noundef %self, ptr noundef %sep, i64 noundef %maxsplit) #0 {
entry:
  %retval = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  %sep.addr = alloca ptr, align 8
  %maxsplit.addr = alloca i64, align 8
  %len = alloca i64, align 8
  %n = alloca i64, align 8
  %s = alloca ptr, align 8
  %sub = alloca ptr, align 8
  %vsub = alloca %struct.Py_buffer, align 8
  %list = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %sep, ptr %sep.addr, align 8
  store i64 %maxsplit, ptr %maxsplit.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %call = call i64 @PyBytes_GET_SIZE(ptr noundef %0)
  store i64 %call, ptr %len, align 8
  %1 = load ptr, ptr %self.addr, align 8
  %call1 = call ptr @PyBytes_AS_STRING(ptr noundef %1)
  store ptr %call1, ptr %s, align 8
  %2 = load i64, ptr %maxsplit.addr, align 8
  %cmp = icmp slt i64 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 9223372036854775807, ptr %maxsplit.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load ptr, ptr %sep.addr, align 8
  %cmp2 = icmp eq ptr %3, @_Py_NoneStruct
  br i1 %cmp2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %4 = load ptr, ptr %self.addr, align 8
  %5 = load ptr, ptr %s, align 8
  %6 = load i64, ptr %len, align 8
  %7 = load i64, ptr %maxsplit.addr, align 8
  %call4 = call ptr @stringlib_split_whitespace(ptr noundef %4, ptr noundef %5, i64 noundef %6, i64 noundef %7)
  store ptr %call4, ptr %retval, align 8
  br label %return

if.end5:                                          ; preds = %if.end
  %8 = load ptr, ptr %sep.addr, align 8
  %call6 = call i32 @PyObject_GetBuffer(ptr noundef %8, ptr noundef %vsub, i32 noundef 0)
  %cmp7 = icmp ne i32 %call6, 0
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end5
  store ptr null, ptr %retval, align 8
  br label %return

if.end9:                                          ; preds = %if.end5
  %buf = getelementptr inbounds %struct.Py_buffer, ptr %vsub, i32 0, i32 0
  %9 = load ptr, ptr %buf, align 8
  store ptr %9, ptr %sub, align 8
  %len10 = getelementptr inbounds %struct.Py_buffer, ptr %vsub, i32 0, i32 2
  %10 = load i64, ptr %len10, align 8
  store i64 %10, ptr %n, align 8
  %11 = load ptr, ptr %self.addr, align 8
  %12 = load ptr, ptr %s, align 8
  %13 = load i64, ptr %len, align 8
  %14 = load ptr, ptr %sub, align 8
  %15 = load i64, ptr %n, align 8
  %16 = load i64, ptr %maxsplit.addr, align 8
  %call11 = call ptr @stringlib_split(ptr noundef %11, ptr noundef %12, i64 noundef %13, ptr noundef %14, i64 noundef %15, i64 noundef %16)
  store ptr %call11, ptr %list, align 8
  call void @PyBuffer_Release(ptr noundef %vsub)
  %17 = load ptr, ptr %list, align 8
  store ptr %17, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end9, %if.then8, %if.then3
  %18 = load ptr, ptr %retval, align 8
  ret ptr %18
}

; Function Attrs: nounwind uwtable
define internal ptr @stringlib_split_whitespace(ptr noundef %str_obj, ptr noundef %str, i64 noundef %str_len, i64 noundef %maxcount) #0 {
entry:
  %op.addr.i153 = alloca ptr, align 8
  %op.addr.i149 = alloca ptr, align 8
  %op.addr.i145 = alloca ptr, align 8
  %op.addr.i141 = alloca ptr, align 8
  %op.addr.i139 = alloca ptr, align 8
  %op.addr.i135 = alloca ptr, align 8
  %cur_refcnt.i = alloca i32, align 4
  %new_refcnt.i = alloca i32, align 4
  %op.addr.i126 = alloca ptr, align 8
  %op.addr.i117 = alloca ptr, align 8
  %op.addr.i108 = alloca ptr, align 8
  %op.addr.i99 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %str_obj.addr = alloca ptr, align 8
  %str.addr = alloca ptr, align 8
  %str_len.addr = alloca i64, align 8
  %maxcount.addr = alloca i64, align 8
  %i = alloca i64, align 8
  %j = alloca i64, align 8
  %count = alloca i64, align 8
  %list = alloca ptr, align 8
  %sub = alloca ptr, align 8
  store ptr %str_obj, ptr %str_obj.addr, align 8
  store ptr %str, ptr %str.addr, align 8
  store i64 %str_len, ptr %str_len.addr, align 8
  store i64 %maxcount, ptr %maxcount.addr, align 8
  store i64 0, ptr %count, align 8
  %0 = load i64, ptr %maxcount.addr, align 8
  %cmp = icmp sge i64 %0, 12
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %1 = load i64, ptr %maxcount.addr, align 8
  %add = add i64 %1, 1
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ 12, %cond.true ], [ %add, %cond.false ]
  %call = call ptr @PyList_New(i64 noundef %cond)
  store ptr %call, ptr %list, align 8
  %2 = load ptr, ptr %list, align 8
  %cmp1 = icmp eq ptr %2, null
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end
  store i64 0, ptr %j, align 8
  store i64 0, ptr %i, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end54, %if.end
  %3 = load i64, ptr %maxcount.addr, align 8
  %dec = add i64 %3, -1
  store i64 %dec, ptr %maxcount.addr, align 8
  %cmp2 = icmp sgt i64 %3, 0
  br i1 %cmp2, label %while.body, label %while.end56

while.body:                                       ; preds = %while.cond
  br label %while.cond3

while.cond3:                                      ; preds = %while.body8, %while.body
  %4 = load i64, ptr %i, align 8
  %5 = load i64, ptr %str_len.addr, align 8
  %cmp4 = icmp slt i64 %4, %5
  br i1 %cmp4, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond3
  %6 = load ptr, ptr %str.addr, align 8
  %7 = load i64, ptr %i, align 8
  %arrayidx = getelementptr i8, ptr %6, i64 %7
  %8 = load i8, ptr %arrayidx, align 1
  %conv = sext i8 %8 to i32
  %and = and i32 %conv, 255
  %conv5 = trunc i32 %and to i8
  %idxprom = zext i8 %conv5 to i64
  %arrayidx6 = getelementptr [256 x i32], ptr @_Py_ctype_table, i64 0, i64 %idxprom
  %9 = load i32, ptr %arrayidx6, align 4
  %and7 = and i32 %9, 8
  %tobool = icmp ne i32 %and7, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond3
  %10 = phi i1 [ false, %while.cond3 ], [ %tobool, %land.rhs ]
  br i1 %10, label %while.body8, label %while.end

while.body8:                                      ; preds = %land.end
  %11 = load i64, ptr %i, align 8
  %inc = add i64 %11, 1
  store i64 %inc, ptr %i, align 8
  br label %while.cond3, !llvm.loop !74

while.end:                                        ; preds = %land.end
  %12 = load i64, ptr %i, align 8
  %13 = load i64, ptr %str_len.addr, align 8
  %cmp9 = icmp eq i64 %12, %13
  br i1 %cmp9, label %if.then11, label %if.end12

if.then11:                                        ; preds = %while.end
  br label %while.end56

if.end12:                                         ; preds = %while.end
  %14 = load i64, ptr %i, align 8
  store i64 %14, ptr %j, align 8
  %15 = load i64, ptr %i, align 8
  %inc13 = add i64 %15, 1
  store i64 %inc13, ptr %i, align 8
  br label %while.cond14

while.cond14:                                     ; preds = %while.body27, %if.end12
  %16 = load i64, ptr %i, align 8
  %17 = load i64, ptr %str_len.addr, align 8
  %cmp15 = icmp slt i64 %16, %17
  br i1 %cmp15, label %land.rhs17, label %land.end26

land.rhs17:                                       ; preds = %while.cond14
  %18 = load ptr, ptr %str.addr, align 8
  %19 = load i64, ptr %i, align 8
  %arrayidx18 = getelementptr i8, ptr %18, i64 %19
  %20 = load i8, ptr %arrayidx18, align 1
  %conv19 = sext i8 %20 to i32
  %and20 = and i32 %conv19, 255
  %conv21 = trunc i32 %and20 to i8
  %idxprom22 = zext i8 %conv21 to i64
  %arrayidx23 = getelementptr [256 x i32], ptr @_Py_ctype_table, i64 0, i64 %idxprom22
  %21 = load i32, ptr %arrayidx23, align 4
  %and24 = and i32 %21, 8
  %tobool25 = icmp ne i32 %and24, 0
  %lnot = xor i1 %tobool25, true
  br label %land.end26

land.end26:                                       ; preds = %land.rhs17, %while.cond14
  %22 = phi i1 [ false, %while.cond14 ], [ %lnot, %land.rhs17 ]
  br i1 %22, label %while.body27, label %while.end29

while.body27:                                     ; preds = %land.end26
  %23 = load i64, ptr %i, align 8
  %inc28 = add i64 %23, 1
  store i64 %inc28, ptr %i, align 8
  br label %while.cond14, !llvm.loop !75

while.end29:                                      ; preds = %land.end26
  %24 = load i64, ptr %j, align 8
  %cmp30 = icmp eq i64 %24, 0
  br i1 %cmp30, label %land.lhs.true, label %if.end39

land.lhs.true:                                    ; preds = %while.end29
  %25 = load i64, ptr %i, align 8
  %26 = load i64, ptr %str_len.addr, align 8
  %cmp32 = icmp eq i64 %25, %26
  br i1 %cmp32, label %land.lhs.true34, label %if.end39

land.lhs.true34:                                  ; preds = %land.lhs.true
  %27 = load ptr, ptr %str_obj.addr, align 8
  %call35 = call i32 @Py_IS_TYPE(ptr noundef %27, ptr noundef @PyBytes_Type)
  %tobool36 = icmp ne i32 %call35, 0
  br i1 %tobool36, label %if.then37, label %if.end39

if.then37:                                        ; preds = %land.lhs.true34
  %28 = load ptr, ptr %str_obj.addr, align 8
  store ptr %28, ptr %op.addr.i135, align 8
  %29 = load ptr, ptr %op.addr.i135, align 8
  %30 = load i32, ptr %29, align 8
  store i32 %30, ptr %cur_refcnt.i, align 4
  %31 = load i32, ptr %cur_refcnt.i, align 4
  %add.i = add i32 %31, 1
  store i32 %add.i, ptr %new_refcnt.i, align 4
  %32 = load i32, ptr %new_refcnt.i, align 4
  %cmp.i136 = icmp eq i32 %32, 0
  br i1 %cmp.i136, label %if.then.i138, label %if.end.i137

if.then.i138:                                     ; preds = %if.then37
  br label %Py_INCREF.exit

if.end.i137:                                      ; preds = %if.then37
  %33 = load i32, ptr %new_refcnt.i, align 4
  %34 = load ptr, ptr %op.addr.i135, align 8
  store i32 %33, ptr %34, align 8
  br label %Py_INCREF.exit

Py_INCREF.exit:                                   ; preds = %if.end.i137, %if.then.i138
  %35 = load ptr, ptr %list, align 8
  %36 = load ptr, ptr %str_obj.addr, align 8
  call void @PyList_SET_ITEM(ptr noundef %35, i64 noundef 0, ptr noundef %36)
  %37 = load i64, ptr %count, align 8
  %inc38 = add i64 %37, 1
  store i64 %inc38, ptr %count, align 8
  br label %while.end56

if.end39:                                         ; preds = %land.lhs.true34, %land.lhs.true, %while.end29
  %38 = load ptr, ptr %str.addr, align 8
  %39 = load i64, ptr %j, align 8
  %add.ptr = getelementptr i8, ptr %38, i64 %39
  %40 = load i64, ptr %i, align 8
  %41 = load i64, ptr %j, align 8
  %sub40 = sub i64 %40, %41
  %call41 = call ptr @PyBytes_FromStringAndSize(ptr noundef %add.ptr, i64 noundef %sub40)
  store ptr %call41, ptr %sub, align 8
  %42 = load ptr, ptr %sub, align 8
  %cmp42 = icmp eq ptr %42, null
  br i1 %cmp42, label %if.then44, label %if.end45

if.then44:                                        ; preds = %if.end39
  br label %onError

if.end45:                                         ; preds = %if.end39
  %43 = load i64, ptr %count, align 8
  %cmp46 = icmp slt i64 %43, 12
  br i1 %cmp46, label %if.then48, label %if.else

if.then48:                                        ; preds = %if.end45
  %44 = load ptr, ptr %list, align 8
  %45 = load i64, ptr %count, align 8
  %46 = load ptr, ptr %sub, align 8
  call void @PyList_SET_ITEM(ptr noundef %44, i64 noundef %45, ptr noundef %46)
  br label %if.end54

if.else:                                          ; preds = %if.end45
  %47 = load ptr, ptr %list, align 8
  %48 = load ptr, ptr %sub, align 8
  %call49 = call i32 @PyList_Append(ptr noundef %47, ptr noundef %48)
  %tobool50 = icmp ne i32 %call49, 0
  br i1 %tobool50, label %if.then51, label %if.else52

if.then51:                                        ; preds = %if.else
  %49 = load ptr, ptr %sub, align 8
  store ptr %49, ptr %op.addr.i126, align 8
  %50 = load ptr, ptr %op.addr.i126, align 8
  store ptr %50, ptr %op.addr.i139, align 8
  %51 = load ptr, ptr %op.addr.i139, align 8
  %52 = load i64, ptr %51, align 8
  %conv.i = trunc i64 %52 to i32
  %cmp.i140 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i140 to i32
  %tobool.i128 = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i128, label %if.then.i133, label %if.end.i129

if.then.i133:                                     ; preds = %if.then51
  br label %Py_DECREF.exit134

if.end.i129:                                      ; preds = %if.then51
  %53 = load ptr, ptr %op.addr.i126, align 8
  %54 = load i64, ptr %53, align 8
  %dec.i130 = add i64 %54, -1
  store i64 %dec.i130, ptr %53, align 8
  %cmp.i131 = icmp eq i64 %dec.i130, 0
  br i1 %cmp.i131, label %if.then1.i132, label %Py_DECREF.exit134

if.then1.i132:                                    ; preds = %if.end.i129
  %55 = load ptr, ptr %op.addr.i126, align 8
  call void @_Py_Dealloc(ptr noundef %55) #9
  br label %Py_DECREF.exit134

Py_DECREF.exit134:                                ; preds = %if.then1.i132, %if.end.i129, %if.then.i133
  br label %onError

if.else52:                                        ; preds = %if.else
  %56 = load ptr, ptr %sub, align 8
  store ptr %56, ptr %op.addr.i117, align 8
  %57 = load ptr, ptr %op.addr.i117, align 8
  store ptr %57, ptr %op.addr.i141, align 8
  %58 = load ptr, ptr %op.addr.i141, align 8
  %59 = load i64, ptr %58, align 8
  %conv.i142 = trunc i64 %59 to i32
  %cmp.i143 = icmp slt i32 %conv.i142, 0
  %conv1.i144 = zext i1 %cmp.i143 to i32
  %tobool.i119 = icmp ne i32 %conv1.i144, 0
  br i1 %tobool.i119, label %if.then.i124, label %if.end.i120

if.then.i124:                                     ; preds = %if.else52
  br label %Py_DECREF.exit125

if.end.i120:                                      ; preds = %if.else52
  %60 = load ptr, ptr %op.addr.i117, align 8
  %61 = load i64, ptr %60, align 8
  %dec.i121 = add i64 %61, -1
  store i64 %dec.i121, ptr %60, align 8
  %cmp.i122 = icmp eq i64 %dec.i121, 0
  br i1 %cmp.i122, label %if.then1.i123, label %Py_DECREF.exit125

if.then1.i123:                                    ; preds = %if.end.i120
  %62 = load ptr, ptr %op.addr.i117, align 8
  call void @_Py_Dealloc(ptr noundef %62) #9
  br label %Py_DECREF.exit125

Py_DECREF.exit125:                                ; preds = %if.then1.i123, %if.end.i120, %if.then.i124
  br label %if.end53

if.end53:                                         ; preds = %Py_DECREF.exit125
  br label %if.end54

if.end54:                                         ; preds = %if.end53, %if.then48
  %63 = load i64, ptr %count, align 8
  %inc55 = add i64 %63, 1
  store i64 %inc55, ptr %count, align 8
  br label %while.cond, !llvm.loop !76

while.end56:                                      ; preds = %Py_INCREF.exit, %if.then11, %while.cond
  %64 = load i64, ptr %i, align 8
  %65 = load i64, ptr %str_len.addr, align 8
  %cmp57 = icmp slt i64 %64, %65
  br i1 %cmp57, label %if.then59, label %if.end98

if.then59:                                        ; preds = %while.end56
  br label %while.cond60

while.cond60:                                     ; preds = %while.body73, %if.then59
  %66 = load i64, ptr %i, align 8
  %67 = load i64, ptr %str_len.addr, align 8
  %cmp61 = icmp slt i64 %66, %67
  br i1 %cmp61, label %land.rhs63, label %land.end72

land.rhs63:                                       ; preds = %while.cond60
  %68 = load ptr, ptr %str.addr, align 8
  %69 = load i64, ptr %i, align 8
  %arrayidx64 = getelementptr i8, ptr %68, i64 %69
  %70 = load i8, ptr %arrayidx64, align 1
  %conv65 = sext i8 %70 to i32
  %and66 = and i32 %conv65, 255
  %conv67 = trunc i32 %and66 to i8
  %idxprom68 = zext i8 %conv67 to i64
  %arrayidx69 = getelementptr [256 x i32], ptr @_Py_ctype_table, i64 0, i64 %idxprom68
  %71 = load i32, ptr %arrayidx69, align 4
  %and70 = and i32 %71, 8
  %tobool71 = icmp ne i32 %and70, 0
  br label %land.end72

land.end72:                                       ; preds = %land.rhs63, %while.cond60
  %72 = phi i1 [ false, %while.cond60 ], [ %tobool71, %land.rhs63 ]
  br i1 %72, label %while.body73, label %while.end75

while.body73:                                     ; preds = %land.end72
  %73 = load i64, ptr %i, align 8
  %inc74 = add i64 %73, 1
  store i64 %inc74, ptr %i, align 8
  br label %while.cond60, !llvm.loop !77

while.end75:                                      ; preds = %land.end72
  %74 = load i64, ptr %i, align 8
  %75 = load i64, ptr %str_len.addr, align 8
  %cmp76 = icmp ne i64 %74, %75
  br i1 %cmp76, label %if.then78, label %if.end97

if.then78:                                        ; preds = %while.end75
  %76 = load ptr, ptr %str.addr, align 8
  %77 = load i64, ptr %i, align 8
  %add.ptr79 = getelementptr i8, ptr %76, i64 %77
  %78 = load i64, ptr %str_len.addr, align 8
  %79 = load i64, ptr %i, align 8
  %sub80 = sub i64 %78, %79
  %call81 = call ptr @PyBytes_FromStringAndSize(ptr noundef %add.ptr79, i64 noundef %sub80)
  store ptr %call81, ptr %sub, align 8
  %80 = load ptr, ptr %sub, align 8
  %cmp82 = icmp eq ptr %80, null
  br i1 %cmp82, label %if.then84, label %if.end85

if.then84:                                        ; preds = %if.then78
  br label %onError

if.end85:                                         ; preds = %if.then78
  %81 = load i64, ptr %count, align 8
  %cmp86 = icmp slt i64 %81, 12
  br i1 %cmp86, label %if.then88, label %if.else89

if.then88:                                        ; preds = %if.end85
  %82 = load ptr, ptr %list, align 8
  %83 = load i64, ptr %count, align 8
  %84 = load ptr, ptr %sub, align 8
  call void @PyList_SET_ITEM(ptr noundef %82, i64 noundef %83, ptr noundef %84)
  br label %if.end95

if.else89:                                        ; preds = %if.end85
  %85 = load ptr, ptr %list, align 8
  %86 = load ptr, ptr %sub, align 8
  %call90 = call i32 @PyList_Append(ptr noundef %85, ptr noundef %86)
  %tobool91 = icmp ne i32 %call90, 0
  br i1 %tobool91, label %if.then92, label %if.else93

if.then92:                                        ; preds = %if.else89
  %87 = load ptr, ptr %sub, align 8
  store ptr %87, ptr %op.addr.i108, align 8
  %88 = load ptr, ptr %op.addr.i108, align 8
  store ptr %88, ptr %op.addr.i145, align 8
  %89 = load ptr, ptr %op.addr.i145, align 8
  %90 = load i64, ptr %89, align 8
  %conv.i146 = trunc i64 %90 to i32
  %cmp.i147 = icmp slt i32 %conv.i146, 0
  %conv1.i148 = zext i1 %cmp.i147 to i32
  %tobool.i110 = icmp ne i32 %conv1.i148, 0
  br i1 %tobool.i110, label %if.then.i115, label %if.end.i111

if.then.i115:                                     ; preds = %if.then92
  br label %Py_DECREF.exit116

if.end.i111:                                      ; preds = %if.then92
  %91 = load ptr, ptr %op.addr.i108, align 8
  %92 = load i64, ptr %91, align 8
  %dec.i112 = add i64 %92, -1
  store i64 %dec.i112, ptr %91, align 8
  %cmp.i113 = icmp eq i64 %dec.i112, 0
  br i1 %cmp.i113, label %if.then1.i114, label %Py_DECREF.exit116

if.then1.i114:                                    ; preds = %if.end.i111
  %93 = load ptr, ptr %op.addr.i108, align 8
  call void @_Py_Dealloc(ptr noundef %93) #9
  br label %Py_DECREF.exit116

Py_DECREF.exit116:                                ; preds = %if.then1.i114, %if.end.i111, %if.then.i115
  br label %onError

if.else93:                                        ; preds = %if.else89
  %94 = load ptr, ptr %sub, align 8
  store ptr %94, ptr %op.addr.i99, align 8
  %95 = load ptr, ptr %op.addr.i99, align 8
  store ptr %95, ptr %op.addr.i149, align 8
  %96 = load ptr, ptr %op.addr.i149, align 8
  %97 = load i64, ptr %96, align 8
  %conv.i150 = trunc i64 %97 to i32
  %cmp.i151 = icmp slt i32 %conv.i150, 0
  %conv1.i152 = zext i1 %cmp.i151 to i32
  %tobool.i101 = icmp ne i32 %conv1.i152, 0
  br i1 %tobool.i101, label %if.then.i106, label %if.end.i102

if.then.i106:                                     ; preds = %if.else93
  br label %Py_DECREF.exit107

if.end.i102:                                      ; preds = %if.else93
  %98 = load ptr, ptr %op.addr.i99, align 8
  %99 = load i64, ptr %98, align 8
  %dec.i103 = add i64 %99, -1
  store i64 %dec.i103, ptr %98, align 8
  %cmp.i104 = icmp eq i64 %dec.i103, 0
  br i1 %cmp.i104, label %if.then1.i105, label %Py_DECREF.exit107

if.then1.i105:                                    ; preds = %if.end.i102
  %100 = load ptr, ptr %op.addr.i99, align 8
  call void @_Py_Dealloc(ptr noundef %100) #9
  br label %Py_DECREF.exit107

Py_DECREF.exit107:                                ; preds = %if.then1.i105, %if.end.i102, %if.then.i106
  br label %if.end94

if.end94:                                         ; preds = %Py_DECREF.exit107
  br label %if.end95

if.end95:                                         ; preds = %if.end94, %if.then88
  %101 = load i64, ptr %count, align 8
  %inc96 = add i64 %101, 1
  store i64 %inc96, ptr %count, align 8
  br label %if.end97

if.end97:                                         ; preds = %if.end95, %while.end75
  br label %if.end98

if.end98:                                         ; preds = %if.end97, %while.end56
  %102 = load ptr, ptr %list, align 8
  %103 = load i64, ptr %count, align 8
  call void @Py_SET_SIZE(ptr noundef %102, i64 noundef %103)
  %104 = load ptr, ptr %list, align 8
  store ptr %104, ptr %retval, align 8
  br label %return

onError:                                          ; preds = %Py_DECREF.exit116, %if.then84, %Py_DECREF.exit134, %if.then44
  %105 = load ptr, ptr %list, align 8
  store ptr %105, ptr %op.addr.i, align 8
  %106 = load ptr, ptr %op.addr.i, align 8
  store ptr %106, ptr %op.addr.i153, align 8
  %107 = load ptr, ptr %op.addr.i153, align 8
  %108 = load i64, ptr %107, align 8
  %conv.i154 = trunc i64 %108 to i32
  %cmp.i155 = icmp slt i32 %conv.i154, 0
  %conv1.i156 = zext i1 %cmp.i155 to i32
  %tobool.i = icmp ne i32 %conv1.i156, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %onError
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %onError
  %109 = load ptr, ptr %op.addr.i, align 8
  %110 = load i64, ptr %109, align 8
  %dec.i = add i64 %110, -1
  store i64 %dec.i, ptr %109, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %111 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %111) #9
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %Py_DECREF.exit, %if.end98, %if.then
  %112 = load ptr, ptr %retval, align 8
  ret ptr %112
}

; Function Attrs: nounwind uwtable
define internal ptr @stringlib_split(ptr noundef %str_obj, ptr noundef %str, i64 noundef %str_len, ptr noundef %sep, i64 noundef %sep_len, i64 noundef %maxcount) #0 {
entry:
  %op.addr.i108 = alloca ptr, align 8
  %op.addr.i104 = alloca ptr, align 8
  %op.addr.i100 = alloca ptr, align 8
  %op.addr.i96 = alloca ptr, align 8
  %op.addr.i94 = alloca ptr, align 8
  %op.addr.i90 = alloca ptr, align 8
  %cur_refcnt.i = alloca i32, align 4
  %new_refcnt.i = alloca i32, align 4
  %op.addr.i81 = alloca ptr, align 8
  %op.addr.i72 = alloca ptr, align 8
  %op.addr.i63 = alloca ptr, align 8
  %op.addr.i54 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %str_obj.addr = alloca ptr, align 8
  %str.addr = alloca ptr, align 8
  %str_len.addr = alloca i64, align 8
  %sep.addr = alloca ptr, align 8
  %sep_len.addr = alloca i64, align 8
  %maxcount.addr = alloca i64, align 8
  %i = alloca i64, align 8
  %j = alloca i64, align 8
  %pos = alloca i64, align 8
  %count = alloca i64, align 8
  %list = alloca ptr, align 8
  %sub = alloca ptr, align 8
  store ptr %str_obj, ptr %str_obj.addr, align 8
  store ptr %str, ptr %str.addr, align 8
  store i64 %str_len, ptr %str_len.addr, align 8
  store ptr %sep, ptr %sep.addr, align 8
  store i64 %sep_len, ptr %sep_len.addr, align 8
  store i64 %maxcount, ptr %maxcount.addr, align 8
  store i64 0, ptr %count, align 8
  %0 = load i64, ptr %sep_len.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr @PyExc_ValueError, align 8
  call void @PyErr_SetString(ptr noundef %1, ptr noundef @.str.116)
  store ptr null, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %2 = load i64, ptr %sep_len.addr, align 8
  %cmp1 = icmp eq i64 %2, 1
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.else
  %3 = load ptr, ptr %str_obj.addr, align 8
  %4 = load ptr, ptr %str.addr, align 8
  %5 = load i64, ptr %str_len.addr, align 8
  %6 = load ptr, ptr %sep.addr, align 8
  %arrayidx = getelementptr i8, ptr %6, i64 0
  %7 = load i8, ptr %arrayidx, align 1
  %8 = load i64, ptr %maxcount.addr, align 8
  %call = call ptr @stringlib_split_char(ptr noundef %3, ptr noundef %4, i64 noundef %5, i8 noundef signext %7, i64 noundef %8)
  store ptr %call, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %if.else
  br label %if.end3

if.end3:                                          ; preds = %if.end
  %9 = load i64, ptr %maxcount.addr, align 8
  %cmp4 = icmp sge i64 %9, 12
  br i1 %cmp4, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end3
  br label %cond.end

cond.false:                                       ; preds = %if.end3
  %10 = load i64, ptr %maxcount.addr, align 8
  %add = add i64 %10, 1
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ 12, %cond.true ], [ %add, %cond.false ]
  %call5 = call ptr @PyList_New(i64 noundef %cond)
  store ptr %call5, ptr %list, align 8
  %11 = load ptr, ptr %list, align 8
  %cmp6 = icmp eq ptr %11, null
  br i1 %cmp6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %cond.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end8:                                          ; preds = %cond.end
  store i64 0, ptr %j, align 8
  store i64 0, ptr %i, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end29, %if.end8
  %12 = load i64, ptr %maxcount.addr, align 8
  %dec = add i64 %12, -1
  store i64 %dec, ptr %maxcount.addr, align 8
  %cmp9 = icmp sgt i64 %12, 0
  br i1 %cmp9, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %13 = load ptr, ptr %str.addr, align 8
  %14 = load i64, ptr %i, align 8
  %add.ptr = getelementptr i8, ptr %13, i64 %14
  %15 = load i64, ptr %str_len.addr, align 8
  %16 = load i64, ptr %i, align 8
  %sub10 = sub i64 %15, %16
  %17 = load ptr, ptr %sep.addr, align 8
  %18 = load i64, ptr %sep_len.addr, align 8
  %call11 = call i64 @fastsearch(ptr noundef %add.ptr, i64 noundef %sub10, ptr noundef %17, i64 noundef %18, i64 noundef -1, i32 noundef 1)
  store i64 %call11, ptr %pos, align 8
  %19 = load i64, ptr %pos, align 8
  %cmp12 = icmp slt i64 %19, 0
  br i1 %cmp12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %while.body
  br label %while.end

if.end14:                                         ; preds = %while.body
  %20 = load i64, ptr %i, align 8
  %21 = load i64, ptr %pos, align 8
  %add15 = add i64 %20, %21
  store i64 %add15, ptr %j, align 8
  %22 = load ptr, ptr %str.addr, align 8
  %23 = load i64, ptr %i, align 8
  %add.ptr16 = getelementptr i8, ptr %22, i64 %23
  %24 = load i64, ptr %j, align 8
  %25 = load i64, ptr %i, align 8
  %sub17 = sub i64 %24, %25
  %call18 = call ptr @PyBytes_FromStringAndSize(ptr noundef %add.ptr16, i64 noundef %sub17)
  store ptr %call18, ptr %sub, align 8
  %26 = load ptr, ptr %sub, align 8
  %cmp19 = icmp eq ptr %26, null
  br i1 %cmp19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %if.end14
  br label %onError

if.end21:                                         ; preds = %if.end14
  %27 = load i64, ptr %count, align 8
  %cmp22 = icmp slt i64 %27, 12
  br i1 %cmp22, label %if.then23, label %if.else24

if.then23:                                        ; preds = %if.end21
  %28 = load ptr, ptr %list, align 8
  %29 = load i64, ptr %count, align 8
  %30 = load ptr, ptr %sub, align 8
  call void @PyList_SET_ITEM(ptr noundef %28, i64 noundef %29, ptr noundef %30)
  br label %if.end29

if.else24:                                        ; preds = %if.end21
  %31 = load ptr, ptr %list, align 8
  %32 = load ptr, ptr %sub, align 8
  %call25 = call i32 @PyList_Append(ptr noundef %31, ptr noundef %32)
  %tobool = icmp ne i32 %call25, 0
  br i1 %tobool, label %if.then26, label %if.else27

if.then26:                                        ; preds = %if.else24
  %33 = load ptr, ptr %sub, align 8
  store ptr %33, ptr %op.addr.i81, align 8
  %34 = load ptr, ptr %op.addr.i81, align 8
  store ptr %34, ptr %op.addr.i94, align 8
  %35 = load ptr, ptr %op.addr.i94, align 8
  %36 = load i64, ptr %35, align 8
  %conv.i = trunc i64 %36 to i32
  %cmp.i95 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i95 to i32
  %tobool.i83 = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i83, label %if.then.i88, label %if.end.i84

if.then.i88:                                      ; preds = %if.then26
  br label %Py_DECREF.exit89

if.end.i84:                                       ; preds = %if.then26
  %37 = load ptr, ptr %op.addr.i81, align 8
  %38 = load i64, ptr %37, align 8
  %dec.i85 = add i64 %38, -1
  store i64 %dec.i85, ptr %37, align 8
  %cmp.i86 = icmp eq i64 %dec.i85, 0
  br i1 %cmp.i86, label %if.then1.i87, label %Py_DECREF.exit89

if.then1.i87:                                     ; preds = %if.end.i84
  %39 = load ptr, ptr %op.addr.i81, align 8
  call void @_Py_Dealloc(ptr noundef %39) #9
  br label %Py_DECREF.exit89

Py_DECREF.exit89:                                 ; preds = %if.then1.i87, %if.end.i84, %if.then.i88
  br label %onError

if.else27:                                        ; preds = %if.else24
  %40 = load ptr, ptr %sub, align 8
  store ptr %40, ptr %op.addr.i72, align 8
  %41 = load ptr, ptr %op.addr.i72, align 8
  store ptr %41, ptr %op.addr.i96, align 8
  %42 = load ptr, ptr %op.addr.i96, align 8
  %43 = load i64, ptr %42, align 8
  %conv.i97 = trunc i64 %43 to i32
  %cmp.i98 = icmp slt i32 %conv.i97, 0
  %conv1.i99 = zext i1 %cmp.i98 to i32
  %tobool.i74 = icmp ne i32 %conv1.i99, 0
  br i1 %tobool.i74, label %if.then.i79, label %if.end.i75

if.then.i79:                                      ; preds = %if.else27
  br label %Py_DECREF.exit80

if.end.i75:                                       ; preds = %if.else27
  %44 = load ptr, ptr %op.addr.i72, align 8
  %45 = load i64, ptr %44, align 8
  %dec.i76 = add i64 %45, -1
  store i64 %dec.i76, ptr %44, align 8
  %cmp.i77 = icmp eq i64 %dec.i76, 0
  br i1 %cmp.i77, label %if.then1.i78, label %Py_DECREF.exit80

if.then1.i78:                                     ; preds = %if.end.i75
  %46 = load ptr, ptr %op.addr.i72, align 8
  call void @_Py_Dealloc(ptr noundef %46) #9
  br label %Py_DECREF.exit80

Py_DECREF.exit80:                                 ; preds = %if.then1.i78, %if.end.i75, %if.then.i79
  br label %if.end28

if.end28:                                         ; preds = %Py_DECREF.exit80
  br label %if.end29

if.end29:                                         ; preds = %if.end28, %if.then23
  %47 = load i64, ptr %count, align 8
  %inc = add i64 %47, 1
  store i64 %inc, ptr %count, align 8
  %48 = load i64, ptr %j, align 8
  %49 = load i64, ptr %sep_len.addr, align 8
  %add30 = add i64 %48, %49
  store i64 %add30, ptr %i, align 8
  br label %while.cond, !llvm.loop !78

while.end:                                        ; preds = %if.then13, %while.cond
  %50 = load i64, ptr %count, align 8
  %cmp31 = icmp eq i64 %50, 0
  br i1 %cmp31, label %land.lhs.true, label %if.else36

land.lhs.true:                                    ; preds = %while.end
  %51 = load ptr, ptr %str_obj.addr, align 8
  %call32 = call i32 @Py_IS_TYPE(ptr noundef %51, ptr noundef @PyBytes_Type)
  %tobool33 = icmp ne i32 %call32, 0
  br i1 %tobool33, label %if.then34, label %if.else36

if.then34:                                        ; preds = %land.lhs.true
  %52 = load ptr, ptr %str_obj.addr, align 8
  store ptr %52, ptr %op.addr.i90, align 8
  %53 = load ptr, ptr %op.addr.i90, align 8
  %54 = load i32, ptr %53, align 8
  store i32 %54, ptr %cur_refcnt.i, align 4
  %55 = load i32, ptr %cur_refcnt.i, align 4
  %add.i = add i32 %55, 1
  store i32 %add.i, ptr %new_refcnt.i, align 4
  %56 = load i32, ptr %new_refcnt.i, align 4
  %cmp.i91 = icmp eq i32 %56, 0
  br i1 %cmp.i91, label %if.then.i93, label %if.end.i92

if.then.i93:                                      ; preds = %if.then34
  br label %Py_INCREF.exit

if.end.i92:                                       ; preds = %if.then34
  %57 = load i32, ptr %new_refcnt.i, align 4
  %58 = load ptr, ptr %op.addr.i90, align 8
  store i32 %57, ptr %58, align 8
  br label %Py_INCREF.exit

Py_INCREF.exit:                                   ; preds = %if.end.i92, %if.then.i93
  %59 = load ptr, ptr %list, align 8
  %60 = load ptr, ptr %str_obj.addr, align 8
  call void @PyList_SET_ITEM(ptr noundef %59, i64 noundef 0, ptr noundef %60)
  %61 = load i64, ptr %count, align 8
  %inc35 = add i64 %61, 1
  store i64 %inc35, ptr %count, align 8
  br label %if.end53

if.else36:                                        ; preds = %land.lhs.true, %while.end
  %62 = load ptr, ptr %str.addr, align 8
  %63 = load i64, ptr %i, align 8
  %add.ptr37 = getelementptr i8, ptr %62, i64 %63
  %64 = load i64, ptr %str_len.addr, align 8
  %65 = load i64, ptr %i, align 8
  %sub38 = sub i64 %64, %65
  %call39 = call ptr @PyBytes_FromStringAndSize(ptr noundef %add.ptr37, i64 noundef %sub38)
  store ptr %call39, ptr %sub, align 8
  %66 = load ptr, ptr %sub, align 8
  %cmp40 = icmp eq ptr %66, null
  br i1 %cmp40, label %if.then41, label %if.end42

if.then41:                                        ; preds = %if.else36
  br label %onError

if.end42:                                         ; preds = %if.else36
  %67 = load i64, ptr %count, align 8
  %cmp43 = icmp slt i64 %67, 12
  br i1 %cmp43, label %if.then44, label %if.else45

if.then44:                                        ; preds = %if.end42
  %68 = load ptr, ptr %list, align 8
  %69 = load i64, ptr %count, align 8
  %70 = load ptr, ptr %sub, align 8
  call void @PyList_SET_ITEM(ptr noundef %68, i64 noundef %69, ptr noundef %70)
  br label %if.end51

if.else45:                                        ; preds = %if.end42
  %71 = load ptr, ptr %list, align 8
  %72 = load ptr, ptr %sub, align 8
  %call46 = call i32 @PyList_Append(ptr noundef %71, ptr noundef %72)
  %tobool47 = icmp ne i32 %call46, 0
  br i1 %tobool47, label %if.then48, label %if.else49

if.then48:                                        ; preds = %if.else45
  %73 = load ptr, ptr %sub, align 8
  store ptr %73, ptr %op.addr.i63, align 8
  %74 = load ptr, ptr %op.addr.i63, align 8
  store ptr %74, ptr %op.addr.i100, align 8
  %75 = load ptr, ptr %op.addr.i100, align 8
  %76 = load i64, ptr %75, align 8
  %conv.i101 = trunc i64 %76 to i32
  %cmp.i102 = icmp slt i32 %conv.i101, 0
  %conv1.i103 = zext i1 %cmp.i102 to i32
  %tobool.i65 = icmp ne i32 %conv1.i103, 0
  br i1 %tobool.i65, label %if.then.i70, label %if.end.i66

if.then.i70:                                      ; preds = %if.then48
  br label %Py_DECREF.exit71

if.end.i66:                                       ; preds = %if.then48
  %77 = load ptr, ptr %op.addr.i63, align 8
  %78 = load i64, ptr %77, align 8
  %dec.i67 = add i64 %78, -1
  store i64 %dec.i67, ptr %77, align 8
  %cmp.i68 = icmp eq i64 %dec.i67, 0
  br i1 %cmp.i68, label %if.then1.i69, label %Py_DECREF.exit71

if.then1.i69:                                     ; preds = %if.end.i66
  %79 = load ptr, ptr %op.addr.i63, align 8
  call void @_Py_Dealloc(ptr noundef %79) #9
  br label %Py_DECREF.exit71

Py_DECREF.exit71:                                 ; preds = %if.then1.i69, %if.end.i66, %if.then.i70
  br label %onError

if.else49:                                        ; preds = %if.else45
  %80 = load ptr, ptr %sub, align 8
  store ptr %80, ptr %op.addr.i54, align 8
  %81 = load ptr, ptr %op.addr.i54, align 8
  store ptr %81, ptr %op.addr.i104, align 8
  %82 = load ptr, ptr %op.addr.i104, align 8
  %83 = load i64, ptr %82, align 8
  %conv.i105 = trunc i64 %83 to i32
  %cmp.i106 = icmp slt i32 %conv.i105, 0
  %conv1.i107 = zext i1 %cmp.i106 to i32
  %tobool.i56 = icmp ne i32 %conv1.i107, 0
  br i1 %tobool.i56, label %if.then.i61, label %if.end.i57

if.then.i61:                                      ; preds = %if.else49
  br label %Py_DECREF.exit62

if.end.i57:                                       ; preds = %if.else49
  %84 = load ptr, ptr %op.addr.i54, align 8
  %85 = load i64, ptr %84, align 8
  %dec.i58 = add i64 %85, -1
  store i64 %dec.i58, ptr %84, align 8
  %cmp.i59 = icmp eq i64 %dec.i58, 0
  br i1 %cmp.i59, label %if.then1.i60, label %Py_DECREF.exit62

if.then1.i60:                                     ; preds = %if.end.i57
  %86 = load ptr, ptr %op.addr.i54, align 8
  call void @_Py_Dealloc(ptr noundef %86) #9
  br label %Py_DECREF.exit62

Py_DECREF.exit62:                                 ; preds = %if.then1.i60, %if.end.i57, %if.then.i61
  br label %if.end50

if.end50:                                         ; preds = %Py_DECREF.exit62
  br label %if.end51

if.end51:                                         ; preds = %if.end50, %if.then44
  %87 = load i64, ptr %count, align 8
  %inc52 = add i64 %87, 1
  store i64 %inc52, ptr %count, align 8
  br label %if.end53

if.end53:                                         ; preds = %if.end51, %Py_INCREF.exit
  %88 = load ptr, ptr %list, align 8
  %89 = load i64, ptr %count, align 8
  call void @Py_SET_SIZE(ptr noundef %88, i64 noundef %89)
  %90 = load ptr, ptr %list, align 8
  store ptr %90, ptr %retval, align 8
  br label %return

onError:                                          ; preds = %Py_DECREF.exit71, %if.then41, %Py_DECREF.exit89, %if.then20
  %91 = load ptr, ptr %list, align 8
  store ptr %91, ptr %op.addr.i, align 8
  %92 = load ptr, ptr %op.addr.i, align 8
  store ptr %92, ptr %op.addr.i108, align 8
  %93 = load ptr, ptr %op.addr.i108, align 8
  %94 = load i64, ptr %93, align 8
  %conv.i109 = trunc i64 %94 to i32
  %cmp.i110 = icmp slt i32 %conv.i109, 0
  %conv1.i111 = zext i1 %cmp.i110 to i32
  %tobool.i = icmp ne i32 %conv1.i111, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %onError
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %onError
  %95 = load ptr, ptr %op.addr.i, align 8
  %96 = load i64, ptr %95, align 8
  %dec.i = add i64 %96, -1
  store i64 %dec.i, ptr %95, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %97 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %97) #9
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %Py_DECREF.exit, %if.end53, %if.then7, %if.then2, %if.then
  %98 = load ptr, ptr %retval, align 8
  ret ptr %98
}

; Function Attrs: nounwind uwtable
define internal ptr @stringlib_split_char(ptr noundef %str_obj, ptr noundef %str, i64 noundef %str_len, i8 noundef signext %ch, i64 noundef %maxcount) #0 {
entry:
  %op.addr.i110 = alloca ptr, align 8
  %op.addr.i106 = alloca ptr, align 8
  %op.addr.i102 = alloca ptr, align 8
  %op.addr.i98 = alloca ptr, align 8
  %op.addr.i96 = alloca ptr, align 8
  %op.addr.i92 = alloca ptr, align 8
  %cur_refcnt.i = alloca i32, align 4
  %new_refcnt.i = alloca i32, align 4
  %op.addr.i83 = alloca ptr, align 8
  %op.addr.i74 = alloca ptr, align 8
  %op.addr.i65 = alloca ptr, align 8
  %op.addr.i56 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %str_obj.addr = alloca ptr, align 8
  %str.addr = alloca ptr, align 8
  %str_len.addr = alloca i64, align 8
  %ch.addr = alloca i8, align 1
  %maxcount.addr = alloca i64, align 8
  %i = alloca i64, align 8
  %j = alloca i64, align 8
  %count = alloca i64, align 8
  %list = alloca ptr, align 8
  %sub = alloca ptr, align 8
  store ptr %str_obj, ptr %str_obj.addr, align 8
  store ptr %str, ptr %str.addr, align 8
  store i64 %str_len, ptr %str_len.addr, align 8
  store i8 %ch, ptr %ch.addr, align 1
  store i64 %maxcount, ptr %maxcount.addr, align 8
  store i64 0, ptr %count, align 8
  %0 = load i64, ptr %maxcount.addr, align 8
  %cmp = icmp sge i64 %0, 12
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %1 = load i64, ptr %maxcount.addr, align 8
  %add = add i64 %1, 1
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ 12, %cond.true ], [ %add, %cond.false ]
  %call = call ptr @PyList_New(i64 noundef %cond)
  store ptr %call, ptr %list, align 8
  %2 = load ptr, ptr %list, align 8
  %cmp1 = icmp eq ptr %2, null
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end
  store i64 0, ptr %j, align 8
  store i64 0, ptr %i, align 8
  br label %while.cond

while.cond:                                       ; preds = %for.end, %if.end
  %3 = load i64, ptr %j, align 8
  %4 = load i64, ptr %str_len.addr, align 8
  %cmp2 = icmp slt i64 %3, %4
  br i1 %cmp2, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %5 = load i64, ptr %maxcount.addr, align 8
  %dec = add i64 %5, -1
  store i64 %dec, ptr %maxcount.addr, align 8
  %cmp3 = icmp sgt i64 %5, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %6 = phi i1 [ false, %while.cond ], [ %cmp3, %land.rhs ]
  br i1 %6, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %while.body
  %7 = load i64, ptr %j, align 8
  %8 = load i64, ptr %str_len.addr, align 8
  %cmp4 = icmp slt i64 %7, %8
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load ptr, ptr %str.addr, align 8
  %10 = load i64, ptr %j, align 8
  %arrayidx = getelementptr i8, ptr %9, i64 %10
  %11 = load i8, ptr %arrayidx, align 1
  %conv = sext i8 %11 to i32
  %12 = load i8, ptr %ch.addr, align 1
  %conv5 = sext i8 %12 to i32
  %cmp6 = icmp eq i32 %conv, %conv5
  br i1 %cmp6, label %if.then8, label %if.end24

if.then8:                                         ; preds = %for.body
  %13 = load ptr, ptr %str.addr, align 8
  %14 = load i64, ptr %i, align 8
  %add.ptr = getelementptr i8, ptr %13, i64 %14
  %15 = load i64, ptr %j, align 8
  %16 = load i64, ptr %i, align 8
  %sub9 = sub i64 %15, %16
  %call10 = call ptr @PyBytes_FromStringAndSize(ptr noundef %add.ptr, i64 noundef %sub9)
  store ptr %call10, ptr %sub, align 8
  %17 = load ptr, ptr %sub, align 8
  %cmp11 = icmp eq ptr %17, null
  br i1 %cmp11, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.then8
  br label %onError

if.end14:                                         ; preds = %if.then8
  %18 = load i64, ptr %count, align 8
  %cmp15 = icmp slt i64 %18, 12
  br i1 %cmp15, label %if.then17, label %if.else

if.then17:                                        ; preds = %if.end14
  %19 = load ptr, ptr %list, align 8
  %20 = load i64, ptr %count, align 8
  %21 = load ptr, ptr %sub, align 8
  call void @PyList_SET_ITEM(ptr noundef %19, i64 noundef %20, ptr noundef %21)
  br label %if.end22

if.else:                                          ; preds = %if.end14
  %22 = load ptr, ptr %list, align 8
  %23 = load ptr, ptr %sub, align 8
  %call18 = call i32 @PyList_Append(ptr noundef %22, ptr noundef %23)
  %tobool = icmp ne i32 %call18, 0
  br i1 %tobool, label %if.then19, label %if.else20

if.then19:                                        ; preds = %if.else
  %24 = load ptr, ptr %sub, align 8
  store ptr %24, ptr %op.addr.i83, align 8
  %25 = load ptr, ptr %op.addr.i83, align 8
  store ptr %25, ptr %op.addr.i96, align 8
  %26 = load ptr, ptr %op.addr.i96, align 8
  %27 = load i64, ptr %26, align 8
  %conv.i = trunc i64 %27 to i32
  %cmp.i97 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i97 to i32
  %tobool.i85 = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i85, label %if.then.i90, label %if.end.i86

if.then.i90:                                      ; preds = %if.then19
  br label %Py_DECREF.exit91

if.end.i86:                                       ; preds = %if.then19
  %28 = load ptr, ptr %op.addr.i83, align 8
  %29 = load i64, ptr %28, align 8
  %dec.i87 = add i64 %29, -1
  store i64 %dec.i87, ptr %28, align 8
  %cmp.i88 = icmp eq i64 %dec.i87, 0
  br i1 %cmp.i88, label %if.then1.i89, label %Py_DECREF.exit91

if.then1.i89:                                     ; preds = %if.end.i86
  %30 = load ptr, ptr %op.addr.i83, align 8
  call void @_Py_Dealloc(ptr noundef %30) #9
  br label %Py_DECREF.exit91

Py_DECREF.exit91:                                 ; preds = %if.then1.i89, %if.end.i86, %if.then.i90
  br label %onError

if.else20:                                        ; preds = %if.else
  %31 = load ptr, ptr %sub, align 8
  store ptr %31, ptr %op.addr.i74, align 8
  %32 = load ptr, ptr %op.addr.i74, align 8
  store ptr %32, ptr %op.addr.i98, align 8
  %33 = load ptr, ptr %op.addr.i98, align 8
  %34 = load i64, ptr %33, align 8
  %conv.i99 = trunc i64 %34 to i32
  %cmp.i100 = icmp slt i32 %conv.i99, 0
  %conv1.i101 = zext i1 %cmp.i100 to i32
  %tobool.i76 = icmp ne i32 %conv1.i101, 0
  br i1 %tobool.i76, label %if.then.i81, label %if.end.i77

if.then.i81:                                      ; preds = %if.else20
  br label %Py_DECREF.exit82

if.end.i77:                                       ; preds = %if.else20
  %35 = load ptr, ptr %op.addr.i74, align 8
  %36 = load i64, ptr %35, align 8
  %dec.i78 = add i64 %36, -1
  store i64 %dec.i78, ptr %35, align 8
  %cmp.i79 = icmp eq i64 %dec.i78, 0
  br i1 %cmp.i79, label %if.then1.i80, label %Py_DECREF.exit82

if.then1.i80:                                     ; preds = %if.end.i77
  %37 = load ptr, ptr %op.addr.i74, align 8
  call void @_Py_Dealloc(ptr noundef %37) #9
  br label %Py_DECREF.exit82

Py_DECREF.exit82:                                 ; preds = %if.then1.i80, %if.end.i77, %if.then.i81
  br label %if.end21

if.end21:                                         ; preds = %Py_DECREF.exit82
  br label %if.end22

if.end22:                                         ; preds = %if.end21, %if.then17
  %38 = load i64, ptr %count, align 8
  %inc = add i64 %38, 1
  store i64 %inc, ptr %count, align 8
  %39 = load i64, ptr %j, align 8
  %add23 = add i64 %39, 1
  store i64 %add23, ptr %j, align 8
  store i64 %add23, ptr %i, align 8
  br label %for.end

if.end24:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end24
  %40 = load i64, ptr %j, align 8
  %inc25 = add i64 %40, 1
  store i64 %inc25, ptr %j, align 8
  br label %for.cond, !llvm.loop !79

for.end:                                          ; preds = %if.end22, %for.cond
  br label %while.cond, !llvm.loop !80

while.end:                                        ; preds = %land.end
  %41 = load i64, ptr %count, align 8
  %cmp26 = icmp eq i64 %41, 0
  br i1 %cmp26, label %land.lhs.true, label %if.else32

land.lhs.true:                                    ; preds = %while.end
  %42 = load ptr, ptr %str_obj.addr, align 8
  %call28 = call i32 @Py_IS_TYPE(ptr noundef %42, ptr noundef @PyBytes_Type)
  %tobool29 = icmp ne i32 %call28, 0
  br i1 %tobool29, label %if.then30, label %if.else32

if.then30:                                        ; preds = %land.lhs.true
  %43 = load ptr, ptr %str_obj.addr, align 8
  store ptr %43, ptr %op.addr.i92, align 8
  %44 = load ptr, ptr %op.addr.i92, align 8
  %45 = load i32, ptr %44, align 8
  store i32 %45, ptr %cur_refcnt.i, align 4
  %46 = load i32, ptr %cur_refcnt.i, align 4
  %add.i = add i32 %46, 1
  store i32 %add.i, ptr %new_refcnt.i, align 4
  %47 = load i32, ptr %new_refcnt.i, align 4
  %cmp.i93 = icmp eq i32 %47, 0
  br i1 %cmp.i93, label %if.then.i95, label %if.end.i94

if.then.i95:                                      ; preds = %if.then30
  br label %Py_INCREF.exit

if.end.i94:                                       ; preds = %if.then30
  %48 = load i32, ptr %new_refcnt.i, align 4
  %49 = load ptr, ptr %op.addr.i92, align 8
  store i32 %48, ptr %49, align 8
  br label %Py_INCREF.exit

Py_INCREF.exit:                                   ; preds = %if.end.i94, %if.then.i95
  %50 = load ptr, ptr %list, align 8
  %51 = load ptr, ptr %str_obj.addr, align 8
  call void @PyList_SET_ITEM(ptr noundef %50, i64 noundef 0, ptr noundef %51)
  %52 = load i64, ptr %count, align 8
  %inc31 = add i64 %52, 1
  store i64 %inc31, ptr %count, align 8
  br label %if.end55

if.else32:                                        ; preds = %land.lhs.true, %while.end
  %53 = load i64, ptr %i, align 8
  %54 = load i64, ptr %str_len.addr, align 8
  %cmp33 = icmp sle i64 %53, %54
  br i1 %cmp33, label %if.then35, label %if.end54

if.then35:                                        ; preds = %if.else32
  %55 = load ptr, ptr %str.addr, align 8
  %56 = load i64, ptr %i, align 8
  %add.ptr36 = getelementptr i8, ptr %55, i64 %56
  %57 = load i64, ptr %str_len.addr, align 8
  %58 = load i64, ptr %i, align 8
  %sub37 = sub i64 %57, %58
  %call38 = call ptr @PyBytes_FromStringAndSize(ptr noundef %add.ptr36, i64 noundef %sub37)
  store ptr %call38, ptr %sub, align 8
  %59 = load ptr, ptr %sub, align 8
  %cmp39 = icmp eq ptr %59, null
  br i1 %cmp39, label %if.then41, label %if.end42

if.then41:                                        ; preds = %if.then35
  br label %onError

if.end42:                                         ; preds = %if.then35
  %60 = load i64, ptr %count, align 8
  %cmp43 = icmp slt i64 %60, 12
  br i1 %cmp43, label %if.then45, label %if.else46

if.then45:                                        ; preds = %if.end42
  %61 = load ptr, ptr %list, align 8
  %62 = load i64, ptr %count, align 8
  %63 = load ptr, ptr %sub, align 8
  call void @PyList_SET_ITEM(ptr noundef %61, i64 noundef %62, ptr noundef %63)
  br label %if.end52

if.else46:                                        ; preds = %if.end42
  %64 = load ptr, ptr %list, align 8
  %65 = load ptr, ptr %sub, align 8
  %call47 = call i32 @PyList_Append(ptr noundef %64, ptr noundef %65)
  %tobool48 = icmp ne i32 %call47, 0
  br i1 %tobool48, label %if.then49, label %if.else50

if.then49:                                        ; preds = %if.else46
  %66 = load ptr, ptr %sub, align 8
  store ptr %66, ptr %op.addr.i65, align 8
  %67 = load ptr, ptr %op.addr.i65, align 8
  store ptr %67, ptr %op.addr.i102, align 8
  %68 = load ptr, ptr %op.addr.i102, align 8
  %69 = load i64, ptr %68, align 8
  %conv.i103 = trunc i64 %69 to i32
  %cmp.i104 = icmp slt i32 %conv.i103, 0
  %conv1.i105 = zext i1 %cmp.i104 to i32
  %tobool.i67 = icmp ne i32 %conv1.i105, 0
  br i1 %tobool.i67, label %if.then.i72, label %if.end.i68

if.then.i72:                                      ; preds = %if.then49
  br label %Py_DECREF.exit73

if.end.i68:                                       ; preds = %if.then49
  %70 = load ptr, ptr %op.addr.i65, align 8
  %71 = load i64, ptr %70, align 8
  %dec.i69 = add i64 %71, -1
  store i64 %dec.i69, ptr %70, align 8
  %cmp.i70 = icmp eq i64 %dec.i69, 0
  br i1 %cmp.i70, label %if.then1.i71, label %Py_DECREF.exit73

if.then1.i71:                                     ; preds = %if.end.i68
  %72 = load ptr, ptr %op.addr.i65, align 8
  call void @_Py_Dealloc(ptr noundef %72) #9
  br label %Py_DECREF.exit73

Py_DECREF.exit73:                                 ; preds = %if.then1.i71, %if.end.i68, %if.then.i72
  br label %onError

if.else50:                                        ; preds = %if.else46
  %73 = load ptr, ptr %sub, align 8
  store ptr %73, ptr %op.addr.i56, align 8
  %74 = load ptr, ptr %op.addr.i56, align 8
  store ptr %74, ptr %op.addr.i106, align 8
  %75 = load ptr, ptr %op.addr.i106, align 8
  %76 = load i64, ptr %75, align 8
  %conv.i107 = trunc i64 %76 to i32
  %cmp.i108 = icmp slt i32 %conv.i107, 0
  %conv1.i109 = zext i1 %cmp.i108 to i32
  %tobool.i58 = icmp ne i32 %conv1.i109, 0
  br i1 %tobool.i58, label %if.then.i63, label %if.end.i59

if.then.i63:                                      ; preds = %if.else50
  br label %Py_DECREF.exit64

if.end.i59:                                       ; preds = %if.else50
  %77 = load ptr, ptr %op.addr.i56, align 8
  %78 = load i64, ptr %77, align 8
  %dec.i60 = add i64 %78, -1
  store i64 %dec.i60, ptr %77, align 8
  %cmp.i61 = icmp eq i64 %dec.i60, 0
  br i1 %cmp.i61, label %if.then1.i62, label %Py_DECREF.exit64

if.then1.i62:                                     ; preds = %if.end.i59
  %79 = load ptr, ptr %op.addr.i56, align 8
  call void @_Py_Dealloc(ptr noundef %79) #9
  br label %Py_DECREF.exit64

Py_DECREF.exit64:                                 ; preds = %if.then1.i62, %if.end.i59, %if.then.i63
  br label %if.end51

if.end51:                                         ; preds = %Py_DECREF.exit64
  br label %if.end52

if.end52:                                         ; preds = %if.end51, %if.then45
  %80 = load i64, ptr %count, align 8
  %inc53 = add i64 %80, 1
  store i64 %inc53, ptr %count, align 8
  br label %if.end54

if.end54:                                         ; preds = %if.end52, %if.else32
  br label %if.end55

if.end55:                                         ; preds = %if.end54, %Py_INCREF.exit
  %81 = load ptr, ptr %list, align 8
  %82 = load i64, ptr %count, align 8
  call void @Py_SET_SIZE(ptr noundef %81, i64 noundef %82)
  %83 = load ptr, ptr %list, align 8
  store ptr %83, ptr %retval, align 8
  br label %return

onError:                                          ; preds = %Py_DECREF.exit73, %if.then41, %Py_DECREF.exit91, %if.then13
  %84 = load ptr, ptr %list, align 8
  store ptr %84, ptr %op.addr.i, align 8
  %85 = load ptr, ptr %op.addr.i, align 8
  store ptr %85, ptr %op.addr.i110, align 8
  %86 = load ptr, ptr %op.addr.i110, align 8
  %87 = load i64, ptr %86, align 8
  %conv.i111 = trunc i64 %87 to i32
  %cmp.i112 = icmp slt i32 %conv.i111, 0
  %conv1.i113 = zext i1 %cmp.i112 to i32
  %tobool.i = icmp ne i32 %conv1.i113, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %onError
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %onError
  %88 = load ptr, ptr %op.addr.i, align 8
  %89 = load i64, ptr %88, align 8
  %dec.i = add i64 %89, -1
  store i64 %dec.i, ptr %88, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %90 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %90) #9
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %Py_DECREF.exit, %if.end55, %if.then
  %91 = load ptr, ptr %retval, align 8
  ret ptr %91
}

declare i32 @PyObject_IsTrue(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @bytes_splitlines_impl(ptr noundef %self, i32 noundef %keepends) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %keepends.addr = alloca i32, align 4
  store ptr %self, ptr %self.addr, align 8
  store i32 %keepends, ptr %keepends.addr, align 4
  %0 = load ptr, ptr %self.addr, align 8
  %1 = load ptr, ptr %self.addr, align 8
  %call = call ptr @PyBytes_AS_STRING(ptr noundef %1)
  %2 = load ptr, ptr %self.addr, align 8
  %call1 = call i64 @PyBytes_GET_SIZE(ptr noundef %2)
  %3 = load i32, ptr %keepends.addr, align 4
  %call2 = call ptr @stringlib_splitlines(ptr noundef %0, ptr noundef %call, i64 noundef %call1, i32 noundef %3)
  ret ptr %call2
}

; Function Attrs: nounwind uwtable
define internal ptr @stringlib_splitlines(ptr noundef %str_obj, ptr noundef %str, i64 noundef %str_len, i32 noundef %keepends) #0 {
entry:
  %op.addr.i80 = alloca ptr, align 8
  %op.addr.i76 = alloca ptr, align 8
  %op.addr.i74 = alloca ptr, align 8
  %op.addr.i65 = alloca ptr, align 8
  %op.addr.i56 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %str_obj.addr = alloca ptr, align 8
  %str.addr = alloca ptr, align 8
  %str_len.addr = alloca i64, align 8
  %keepends.addr = alloca i32, align 4
  %i = alloca i64, align 8
  %j = alloca i64, align 8
  %list = alloca ptr, align 8
  %sub = alloca ptr, align 8
  %eol = alloca i64, align 8
  store ptr %str_obj, ptr %str_obj.addr, align 8
  store ptr %str, ptr %str.addr, align 8
  store i64 %str_len, ptr %str_len.addr, align 8
  store i32 %keepends, ptr %keepends.addr, align 4
  %call = call ptr @PyList_New(i64 noundef 0)
  store ptr %call, ptr %list, align 8
  %0 = load ptr, ptr %list, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store i64 0, ptr %j, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %if.end55, %if.end
  %1 = load i64, ptr %i, align 8
  %2 = load i64, ptr %str_len.addr, align 8
  %cmp1 = icmp slt i64 %1, %2
  br i1 %cmp1, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %while.cond

while.cond:                                       ; preds = %while.body, %for.body
  %3 = load i64, ptr %i, align 8
  %4 = load i64, ptr %str_len.addr, align 8
  %cmp2 = icmp slt i64 %3, %4
  br i1 %cmp2, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %5 = load ptr, ptr %str.addr, align 8
  %6 = load i64, ptr %i, align 8
  %arrayidx = getelementptr i8, ptr %5, i64 %6
  %7 = load i8, ptr %arrayidx, align 1
  %conv = sext i8 %7 to i32
  %cmp3 = icmp eq i32 %conv, 10
  br i1 %cmp3, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.rhs
  %8 = load ptr, ptr %str.addr, align 8
  %9 = load i64, ptr %i, align 8
  %arrayidx5 = getelementptr i8, ptr %8, i64 %9
  %10 = load i8, ptr %arrayidx5, align 1
  %conv6 = sext i8 %10 to i32
  %cmp7 = icmp eq i32 %conv6, 13
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.rhs
  %11 = phi i1 [ true, %land.rhs ], [ %cmp7, %lor.rhs ]
  %lnot = xor i1 %11, true
  br label %land.end

land.end:                                         ; preds = %lor.end, %while.cond
  %12 = phi i1 [ false, %while.cond ], [ %lnot, %lor.end ]
  br i1 %12, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %13 = load i64, ptr %i, align 8
  %inc = add i64 %13, 1
  store i64 %inc, ptr %i, align 8
  br label %while.cond, !llvm.loop !81

while.end:                                        ; preds = %land.end
  %14 = load i64, ptr %i, align 8
  store i64 %14, ptr %eol, align 8
  %15 = load i64, ptr %i, align 8
  %16 = load i64, ptr %str_len.addr, align 8
  %cmp9 = icmp slt i64 %15, %16
  br i1 %cmp9, label %if.then11, label %if.end30

if.then11:                                        ; preds = %while.end
  %17 = load ptr, ptr %str.addr, align 8
  %18 = load i64, ptr %i, align 8
  %arrayidx12 = getelementptr i8, ptr %17, i64 %18
  %19 = load i8, ptr %arrayidx12, align 1
  %conv13 = sext i8 %19 to i32
  %cmp14 = icmp eq i32 %conv13, 13
  br i1 %cmp14, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.then11
  %20 = load i64, ptr %i, align 8
  %add = add i64 %20, 1
  %21 = load i64, ptr %str_len.addr, align 8
  %cmp16 = icmp slt i64 %add, %21
  br i1 %cmp16, label %land.lhs.true18, label %if.else

land.lhs.true18:                                  ; preds = %land.lhs.true
  %22 = load ptr, ptr %str.addr, align 8
  %23 = load i64, ptr %i, align 8
  %add19 = add i64 %23, 1
  %arrayidx20 = getelementptr i8, ptr %22, i64 %add19
  %24 = load i8, ptr %arrayidx20, align 1
  %conv21 = sext i8 %24 to i32
  %cmp22 = icmp eq i32 %conv21, 10
  br i1 %cmp22, label %if.then24, label %if.else

if.then24:                                        ; preds = %land.lhs.true18
  %25 = load i64, ptr %i, align 8
  %add25 = add i64 %25, 2
  store i64 %add25, ptr %i, align 8
  br label %if.end27

if.else:                                          ; preds = %land.lhs.true18, %land.lhs.true, %if.then11
  %26 = load i64, ptr %i, align 8
  %inc26 = add i64 %26, 1
  store i64 %inc26, ptr %i, align 8
  br label %if.end27

if.end27:                                         ; preds = %if.else, %if.then24
  %27 = load i32, ptr %keepends.addr, align 4
  %tobool = icmp ne i32 %27, 0
  br i1 %tobool, label %if.then28, label %if.end29

if.then28:                                        ; preds = %if.end27
  %28 = load i64, ptr %i, align 8
  store i64 %28, ptr %eol, align 8
  br label %if.end29

if.end29:                                         ; preds = %if.then28, %if.end27
  br label %if.end30

if.end30:                                         ; preds = %if.end29, %while.end
  %29 = load i64, ptr %j, align 8
  %cmp31 = icmp eq i64 %29, 0
  br i1 %cmp31, label %land.lhs.true33, label %if.end44

land.lhs.true33:                                  ; preds = %if.end30
  %30 = load i64, ptr %eol, align 8
  %31 = load i64, ptr %str_len.addr, align 8
  %cmp34 = icmp eq i64 %30, %31
  br i1 %cmp34, label %land.lhs.true36, label %if.end44

land.lhs.true36:                                  ; preds = %land.lhs.true33
  %32 = load ptr, ptr %str_obj.addr, align 8
  %call37 = call i32 @Py_IS_TYPE(ptr noundef %32, ptr noundef @PyBytes_Type)
  %tobool38 = icmp ne i32 %call37, 0
  br i1 %tobool38, label %if.then39, label %if.end44

if.then39:                                        ; preds = %land.lhs.true36
  %33 = load ptr, ptr %list, align 8
  %34 = load ptr, ptr %str_obj.addr, align 8
  %call40 = call i32 @PyList_Append(ptr noundef %33, ptr noundef %34)
  %tobool41 = icmp ne i32 %call40, 0
  br i1 %tobool41, label %if.then42, label %if.end43

if.then42:                                        ; preds = %if.then39
  br label %onError

if.end43:                                         ; preds = %if.then39
  br label %for.end

if.end44:                                         ; preds = %land.lhs.true36, %land.lhs.true33, %if.end30
  %35 = load ptr, ptr %str.addr, align 8
  %36 = load i64, ptr %j, align 8
  %add.ptr = getelementptr i8, ptr %35, i64 %36
  %37 = load i64, ptr %eol, align 8
  %38 = load i64, ptr %j, align 8
  %sub45 = sub i64 %37, %38
  %call46 = call ptr @PyBytes_FromStringAndSize(ptr noundef %add.ptr, i64 noundef %sub45)
  store ptr %call46, ptr %sub, align 8
  %39 = load ptr, ptr %sub, align 8
  %cmp47 = icmp eq ptr %39, null
  br i1 %cmp47, label %if.then49, label %if.end50

if.then49:                                        ; preds = %if.end44
  br label %onError

if.end50:                                         ; preds = %if.end44
  %40 = load ptr, ptr %list, align 8
  %41 = load ptr, ptr %sub, align 8
  %call51 = call i32 @PyList_Append(ptr noundef %40, ptr noundef %41)
  %tobool52 = icmp ne i32 %call51, 0
  br i1 %tobool52, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  %42 = load ptr, ptr %sub, align 8
  store ptr %42, ptr %op.addr.i65, align 8
  %43 = load ptr, ptr %op.addr.i65, align 8
  store ptr %43, ptr %op.addr.i74, align 8
  %44 = load ptr, ptr %op.addr.i74, align 8
  %45 = load i64, ptr %44, align 8
  %conv.i = trunc i64 %45 to i32
  %cmp.i75 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i75 to i32
  %tobool.i67 = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i67, label %if.then.i72, label %if.end.i68

if.then.i72:                                      ; preds = %if.then53
  br label %Py_DECREF.exit73

if.end.i68:                                       ; preds = %if.then53
  %46 = load ptr, ptr %op.addr.i65, align 8
  %47 = load i64, ptr %46, align 8
  %dec.i69 = add i64 %47, -1
  store i64 %dec.i69, ptr %46, align 8
  %cmp.i70 = icmp eq i64 %dec.i69, 0
  br i1 %cmp.i70, label %if.then1.i71, label %Py_DECREF.exit73

if.then1.i71:                                     ; preds = %if.end.i68
  %48 = load ptr, ptr %op.addr.i65, align 8
  call void @_Py_Dealloc(ptr noundef %48) #9
  br label %Py_DECREF.exit73

Py_DECREF.exit73:                                 ; preds = %if.then1.i71, %if.end.i68, %if.then.i72
  br label %onError

if.else54:                                        ; preds = %if.end50
  %49 = load ptr, ptr %sub, align 8
  store ptr %49, ptr %op.addr.i56, align 8
  %50 = load ptr, ptr %op.addr.i56, align 8
  store ptr %50, ptr %op.addr.i76, align 8
  %51 = load ptr, ptr %op.addr.i76, align 8
  %52 = load i64, ptr %51, align 8
  %conv.i77 = trunc i64 %52 to i32
  %cmp.i78 = icmp slt i32 %conv.i77, 0
  %conv1.i79 = zext i1 %cmp.i78 to i32
  %tobool.i58 = icmp ne i32 %conv1.i79, 0
  br i1 %tobool.i58, label %if.then.i63, label %if.end.i59

if.then.i63:                                      ; preds = %if.else54
  br label %Py_DECREF.exit64

if.end.i59:                                       ; preds = %if.else54
  %53 = load ptr, ptr %op.addr.i56, align 8
  %54 = load i64, ptr %53, align 8
  %dec.i60 = add i64 %54, -1
  store i64 %dec.i60, ptr %53, align 8
  %cmp.i61 = icmp eq i64 %dec.i60, 0
  br i1 %cmp.i61, label %if.then1.i62, label %Py_DECREF.exit64

if.then1.i62:                                     ; preds = %if.end.i59
  %55 = load ptr, ptr %op.addr.i56, align 8
  call void @_Py_Dealloc(ptr noundef %55) #9
  br label %Py_DECREF.exit64

Py_DECREF.exit64:                                 ; preds = %if.then1.i62, %if.end.i59, %if.then.i63
  br label %if.end55

if.end55:                                         ; preds = %Py_DECREF.exit64
  %56 = load i64, ptr %i, align 8
  store i64 %56, ptr %j, align 8
  br label %for.cond, !llvm.loop !82

for.end:                                          ; preds = %if.end43, %for.cond
  %57 = load ptr, ptr %list, align 8
  store ptr %57, ptr %retval, align 8
  br label %return

onError:                                          ; preds = %Py_DECREF.exit73, %if.then49, %if.then42
  %58 = load ptr, ptr %list, align 8
  store ptr %58, ptr %op.addr.i, align 8
  %59 = load ptr, ptr %op.addr.i, align 8
  store ptr %59, ptr %op.addr.i80, align 8
  %60 = load ptr, ptr %op.addr.i80, align 8
  %61 = load i64, ptr %60, align 8
  %conv.i81 = trunc i64 %61 to i32
  %cmp.i82 = icmp slt i32 %conv.i81, 0
  %conv1.i83 = zext i1 %cmp.i82 to i32
  %tobool.i = icmp ne i32 %conv1.i83, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %onError
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %onError
  %62 = load ptr, ptr %op.addr.i, align 8
  %63 = load i64, ptr %62, align 8
  %dec.i = add i64 %63, -1
  store i64 %dec.i, ptr %62, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %64 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %64) #9
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %Py_DECREF.exit, %for.end, %if.then
  %65 = load ptr, ptr %retval, align 8
  ret ptr %65
}

declare ptr @_Py_bytes_startswith(ptr noundef, i64 noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @bytes_strip_impl(ptr noundef %self, ptr noundef %bytes) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %bytes.addr = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %bytes, ptr %bytes.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %1 = load ptr, ptr %bytes.addr, align 8
  %call = call ptr @do_argstrip(ptr noundef %0, i32 noundef 2, ptr noundef %1)
  ret ptr %call
}

declare void @_Py_bytes_swapcase(ptr noundef, ptr noundef, i64 noundef) #1

declare void @_Py_bytes_title(ptr noundef, ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @bytes_translate_impl(ptr noundef %self, ptr noundef %table, ptr noundef %deletechars) #0 {
entry:
  %op.addr.i152 = alloca ptr, align 8
  %op.addr.i150 = alloca ptr, align 8
  %op.addr.i141 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  %table.addr = alloca ptr, align 8
  %deletechars.addr = alloca ptr, align 8
  %input = alloca ptr, align 8
  %output = alloca ptr, align 8
  %table_view = alloca %struct.Py_buffer, align 8
  %del_table_view = alloca %struct.Py_buffer, align 8
  %table_chars = alloca ptr, align 8
  %i = alloca i64, align 8
  %c = alloca i64, align 8
  %changed = alloca i64, align 8
  %input_obj = alloca ptr, align 8
  %output_start = alloca ptr, align 8
  %del_table_chars = alloca ptr, align 8
  %inlen = alloca i64, align 8
  %tablen = alloca i64, align 8
  %dellen = alloca i64, align 8
  %result = alloca ptr, align 8
  %trans_table = alloca [256 x i32], align 16
  %_tmp_dst_ptr = alloca ptr, align 8
  %_tmp_old_dst = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %table, ptr %table.addr, align 8
  store ptr %deletechars, ptr %deletechars.addr, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %table_view, i8 0, i64 80, i1 false)
  call void @llvm.memset.p0.i64(ptr align 8 %del_table_view, i8 0, i64 80, i1 false)
  store i64 0, ptr %changed, align 8
  %0 = load ptr, ptr %self.addr, align 8
  store ptr %0, ptr %input_obj, align 8
  store ptr null, ptr %del_table_chars, align 8
  store i64 0, ptr %dellen, align 8
  %1 = load ptr, ptr %table.addr, align 8
  %call = call ptr @Py_TYPE(ptr noundef %1)
  %call1 = call i32 @PyType_HasFeature(ptr noundef %call, i64 noundef 134217728)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %table.addr, align 8
  %call2 = call ptr @PyBytes_AS_STRING(ptr noundef %2)
  store ptr %call2, ptr %table_chars, align 8
  %3 = load ptr, ptr %table.addr, align 8
  %call3 = call i64 @PyBytes_GET_SIZE(ptr noundef %3)
  store i64 %call3, ptr %tablen, align 8
  br label %if.end10

if.else:                                          ; preds = %entry
  %4 = load ptr, ptr %table.addr, align 8
  %cmp = icmp eq ptr %4, @_Py_NoneStruct
  br i1 %cmp, label %if.then4, label %if.else5

if.then4:                                         ; preds = %if.else
  store ptr null, ptr %table_chars, align 8
  store i64 256, ptr %tablen, align 8
  br label %if.end9

if.else5:                                         ; preds = %if.else
  %5 = load ptr, ptr %table.addr, align 8
  %call6 = call i32 @PyObject_GetBuffer(ptr noundef %5, ptr noundef %table_view, i32 noundef 0)
  %cmp7 = icmp ne i32 %call6, 0
  br i1 %cmp7, label %if.then8, label %if.end

if.then8:                                         ; preds = %if.else5
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %if.else5
  %buf = getelementptr inbounds %struct.Py_buffer, ptr %table_view, i32 0, i32 0
  %6 = load ptr, ptr %buf, align 8
  store ptr %6, ptr %table_chars, align 8
  %len = getelementptr inbounds %struct.Py_buffer, ptr %table_view, i32 0, i32 2
  %7 = load i64, ptr %len, align 8
  store i64 %7, ptr %tablen, align 8
  br label %if.end9

if.end9:                                          ; preds = %if.end, %if.then4
  br label %if.end10

if.end10:                                         ; preds = %if.end9, %if.then
  %8 = load i64, ptr %tablen, align 8
  %cmp11 = icmp ne i64 %8, 256
  br i1 %cmp11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end10
  %9 = load ptr, ptr @PyExc_ValueError, align 8
  call void @PyErr_SetString(ptr noundef %9, ptr noundef @.str.121)
  call void @PyBuffer_Release(ptr noundef %table_view)
  store ptr null, ptr %retval, align 8
  br label %return

if.end13:                                         ; preds = %if.end10
  %10 = load ptr, ptr %deletechars.addr, align 8
  %cmp14 = icmp ne ptr %10, null
  br i1 %cmp14, label %if.then15, label %if.else30

if.then15:                                        ; preds = %if.end13
  %11 = load ptr, ptr %deletechars.addr, align 8
  %call16 = call ptr @Py_TYPE(ptr noundef %11)
  %call17 = call i32 @PyType_HasFeature(ptr noundef %call16, i64 noundef 134217728)
  %tobool18 = icmp ne i32 %call17, 0
  br i1 %tobool18, label %if.then19, label %if.else22

if.then19:                                        ; preds = %if.then15
  %12 = load ptr, ptr %deletechars.addr, align 8
  %call20 = call ptr @PyBytes_AS_STRING(ptr noundef %12)
  store ptr %call20, ptr %del_table_chars, align 8
  %13 = load ptr, ptr %deletechars.addr, align 8
  %call21 = call i64 @PyBytes_GET_SIZE(ptr noundef %13)
  store i64 %call21, ptr %dellen, align 8
  br label %if.end29

if.else22:                                        ; preds = %if.then15
  %14 = load ptr, ptr %deletechars.addr, align 8
  %call23 = call i32 @PyObject_GetBuffer(ptr noundef %14, ptr noundef %del_table_view, i32 noundef 0)
  %cmp24 = icmp ne i32 %call23, 0
  br i1 %cmp24, label %if.then25, label %if.end26

if.then25:                                        ; preds = %if.else22
  call void @PyBuffer_Release(ptr noundef %table_view)
  store ptr null, ptr %retval, align 8
  br label %return

if.end26:                                         ; preds = %if.else22
  %buf27 = getelementptr inbounds %struct.Py_buffer, ptr %del_table_view, i32 0, i32 0
  %15 = load ptr, ptr %buf27, align 8
  store ptr %15, ptr %del_table_chars, align 8
  %len28 = getelementptr inbounds %struct.Py_buffer, ptr %del_table_view, i32 0, i32 2
  %16 = load i64, ptr %len28, align 8
  store i64 %16, ptr %dellen, align 8
  br label %if.end29

if.end29:                                         ; preds = %if.end26, %if.then19
  br label %if.end31

if.else30:                                        ; preds = %if.end13
  store ptr null, ptr %del_table_chars, align 8
  store i64 0, ptr %dellen, align 8
  br label %if.end31

if.end31:                                         ; preds = %if.else30, %if.end29
  %17 = load ptr, ptr %input_obj, align 8
  %call32 = call i64 @PyBytes_GET_SIZE(ptr noundef %17)
  store i64 %call32, ptr %inlen, align 8
  %18 = load i64, ptr %inlen, align 8
  %call33 = call ptr @PyBytes_FromStringAndSize(ptr noundef null, i64 noundef %18)
  store ptr %call33, ptr %result, align 8
  %19 = load ptr, ptr %result, align 8
  %cmp34 = icmp eq ptr %19, null
  br i1 %cmp34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %if.end31
  call void @PyBuffer_Release(ptr noundef %del_table_view)
  call void @PyBuffer_Release(ptr noundef %table_view)
  store ptr null, ptr %retval, align 8
  br label %return

if.end36:                                         ; preds = %if.end31
  %20 = load ptr, ptr %result, align 8
  %call37 = call ptr @PyBytes_AS_STRING(ptr noundef %20)
  store ptr %call37, ptr %output, align 8
  store ptr %call37, ptr %output_start, align 8
  %21 = load ptr, ptr %input_obj, align 8
  %call38 = call ptr @PyBytes_AS_STRING(ptr noundef %21)
  store ptr %call38, ptr %input, align 8
  %22 = load i64, ptr %dellen, align 8
  %cmp39 = icmp eq i64 %22, 0
  br i1 %cmp39, label %land.lhs.true, label %if.end61

land.lhs.true:                                    ; preds = %if.end36
  %23 = load ptr, ptr %table_chars, align 8
  %cmp40 = icmp ne ptr %23, null
  br i1 %cmp40, label %if.then41, label %if.end61

if.then41:                                        ; preds = %land.lhs.true
  %24 = load i64, ptr %inlen, align 8
  store i64 %24, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %if.end53, %if.then41
  %25 = load i64, ptr %i, align 8
  %dec = add i64 %25, -1
  store i64 %dec, ptr %i, align 8
  %cmp42 = icmp sge i64 %dec, 0
  br i1 %cmp42, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %26 = load ptr, ptr %input, align 8
  %incdec.ptr = getelementptr i8, ptr %26, i32 1
  store ptr %incdec.ptr, ptr %input, align 8
  %27 = load i8, ptr %26, align 1
  %conv = sext i8 %27 to i32
  %and = and i32 %conv, 255
  %conv43 = trunc i32 %and to i8
  %conv44 = zext i8 %conv43 to i64
  store i64 %conv44, ptr %c, align 8
  %28 = load ptr, ptr %table_chars, align 8
  %29 = load i64, ptr %c, align 8
  %arrayidx = getelementptr i8, ptr %28, i64 %29
  %30 = load i8, ptr %arrayidx, align 1
  %31 = load ptr, ptr %output, align 8
  %incdec.ptr45 = getelementptr i8, ptr %31, i32 1
  store ptr %incdec.ptr45, ptr %output, align 8
  store i8 %30, ptr %31, align 1
  %conv46 = sext i8 %30 to i32
  %and47 = and i32 %conv46, 255
  %conv48 = trunc i32 %and47 to i8
  %conv49 = zext i8 %conv48 to i64
  %32 = load i64, ptr %c, align 8
  %cmp50 = icmp ne i64 %conv49, %32
  br i1 %cmp50, label %if.then52, label %if.end53

if.then52:                                        ; preds = %for.body
  store i64 1, ptr %changed, align 8
  br label %if.end53

if.end53:                                         ; preds = %if.then52, %for.body
  br label %for.cond, !llvm.loop !83

for.end:                                          ; preds = %for.cond
  %33 = load i64, ptr %changed, align 8
  %tobool54 = icmp ne i64 %33, 0
  br i1 %tobool54, label %if.end60, label %land.lhs.true55

land.lhs.true55:                                  ; preds = %for.end
  %34 = load ptr, ptr %input_obj, align 8
  %call56 = call i32 @Py_IS_TYPE(ptr noundef %34, ptr noundef @PyBytes_Type)
  %tobool57 = icmp ne i32 %call56, 0
  br i1 %tobool57, label %if.then58, label %if.end60

if.then58:                                        ; preds = %land.lhs.true55
  br label %do.body

do.body:                                          ; preds = %if.then58
  store ptr %result, ptr %_tmp_dst_ptr, align 8
  %35 = load ptr, ptr %_tmp_dst_ptr, align 8
  %36 = load ptr, ptr %35, align 8
  store ptr %36, ptr %_tmp_old_dst, align 8
  %37 = load ptr, ptr %input_obj, align 8
  %call59 = call ptr @_Py_NewRef(ptr noundef %37)
  %38 = load ptr, ptr %_tmp_dst_ptr, align 8
  store ptr %call59, ptr %38, align 8
  %39 = load ptr, ptr %_tmp_old_dst, align 8
  store ptr %39, ptr %op.addr.i141, align 8
  %40 = load ptr, ptr %op.addr.i141, align 8
  store ptr %40, ptr %op.addr.i150, align 8
  %41 = load ptr, ptr %op.addr.i150, align 8
  %42 = load i64, ptr %41, align 8
  %conv.i = trunc i64 %42 to i32
  %cmp.i151 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i151 to i32
  %tobool.i143 = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i143, label %if.then.i148, label %if.end.i144

if.then.i148:                                     ; preds = %do.body
  br label %Py_DECREF.exit149

if.end.i144:                                      ; preds = %do.body
  %43 = load ptr, ptr %op.addr.i141, align 8
  %44 = load i64, ptr %43, align 8
  %dec.i145 = add i64 %44, -1
  store i64 %dec.i145, ptr %43, align 8
  %cmp.i146 = icmp eq i64 %dec.i145, 0
  br i1 %cmp.i146, label %if.then1.i147, label %Py_DECREF.exit149

if.then1.i147:                                    ; preds = %if.end.i144
  %45 = load ptr, ptr %op.addr.i141, align 8
  call void @_Py_Dealloc(ptr noundef %45) #9
  br label %Py_DECREF.exit149

Py_DECREF.exit149:                                ; preds = %if.then1.i147, %if.end.i144, %if.then.i148
  br label %do.end

do.end:                                           ; preds = %Py_DECREF.exit149
  br label %if.end60

if.end60:                                         ; preds = %do.end, %land.lhs.true55, %for.end
  call void @PyBuffer_Release(ptr noundef %del_table_view)
  call void @PyBuffer_Release(ptr noundef %table_view)
  %46 = load ptr, ptr %result, align 8
  store ptr %46, ptr %retval, align 8
  br label %return

if.end61:                                         ; preds = %land.lhs.true, %if.end36
  %47 = load ptr, ptr %table_chars, align 8
  %cmp62 = icmp eq ptr %47, null
  br i1 %cmp62, label %if.then64, label %if.else74

if.then64:                                        ; preds = %if.end61
  store i64 0, ptr %i, align 8
  br label %for.cond65

for.cond65:                                       ; preds = %for.inc, %if.then64
  %48 = load i64, ptr %i, align 8
  %cmp66 = icmp slt i64 %48, 256
  br i1 %cmp66, label %for.body68, label %for.end73

for.body68:                                       ; preds = %for.cond65
  %49 = load i64, ptr %i, align 8
  %and69 = and i64 %49, 255
  %conv70 = trunc i64 %and69 to i8
  %conv71 = zext i8 %conv70 to i32
  %50 = load i64, ptr %i, align 8
  %arrayidx72 = getelementptr [256 x i32], ptr %trans_table, i64 0, i64 %50
  store i32 %conv71, ptr %arrayidx72, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body68
  %51 = load i64, ptr %i, align 8
  %inc = add i64 %51, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond65, !llvm.loop !84

for.end73:                                        ; preds = %for.cond65
  br label %if.end88

if.else74:                                        ; preds = %if.end61
  store i64 0, ptr %i, align 8
  br label %for.cond75

for.cond75:                                       ; preds = %for.inc85, %if.else74
  %52 = load i64, ptr %i, align 8
  %cmp76 = icmp slt i64 %52, 256
  br i1 %cmp76, label %for.body78, label %for.end87

for.body78:                                       ; preds = %for.cond75
  %53 = load ptr, ptr %table_chars, align 8
  %54 = load i64, ptr %i, align 8
  %arrayidx79 = getelementptr i8, ptr %53, i64 %54
  %55 = load i8, ptr %arrayidx79, align 1
  %conv80 = sext i8 %55 to i32
  %and81 = and i32 %conv80, 255
  %conv82 = trunc i32 %and81 to i8
  %conv83 = zext i8 %conv82 to i32
  %56 = load i64, ptr %i, align 8
  %arrayidx84 = getelementptr [256 x i32], ptr %trans_table, i64 0, i64 %56
  store i32 %conv83, ptr %arrayidx84, align 4
  br label %for.inc85

for.inc85:                                        ; preds = %for.body78
  %57 = load i64, ptr %i, align 8
  %inc86 = add i64 %57, 1
  store i64 %inc86, ptr %i, align 8
  br label %for.cond75, !llvm.loop !85

for.end87:                                        ; preds = %for.cond75
  br label %if.end88

if.end88:                                         ; preds = %for.end87, %for.end73
  call void @PyBuffer_Release(ptr noundef %table_view)
  store i64 0, ptr %i, align 8
  br label %for.cond89

for.cond89:                                       ; preds = %for.inc99, %if.end88
  %58 = load i64, ptr %i, align 8
  %59 = load i64, ptr %dellen, align 8
  %cmp90 = icmp slt i64 %58, %59
  br i1 %cmp90, label %for.body92, label %for.end101

for.body92:                                       ; preds = %for.cond89
  %60 = load ptr, ptr %del_table_chars, align 8
  %61 = load i64, ptr %i, align 8
  %arrayidx93 = getelementptr i8, ptr %60, i64 %61
  %62 = load i8, ptr %arrayidx93, align 1
  %conv94 = sext i8 %62 to i32
  %and95 = and i32 %conv94, 255
  %conv96 = trunc i32 %and95 to i8
  %conv97 = zext i8 %conv96 to i32
  %idxprom = sext i32 %conv97 to i64
  %arrayidx98 = getelementptr [256 x i32], ptr %trans_table, i64 0, i64 %idxprom
  store i32 -1, ptr %arrayidx98, align 4
  br label %for.inc99

for.inc99:                                        ; preds = %for.body92
  %63 = load i64, ptr %i, align 8
  %inc100 = add i64 %63, 1
  store i64 %inc100, ptr %i, align 8
  br label %for.cond89, !llvm.loop !86

for.end101:                                       ; preds = %for.cond89
  call void @PyBuffer_Release(ptr noundef %del_table_view)
  %64 = load i64, ptr %inlen, align 8
  store i64 %64, ptr %i, align 8
  br label %for.cond102

for.cond102:                                      ; preds = %if.end127, %if.then125, %for.end101
  %65 = load i64, ptr %i, align 8
  %dec103 = add i64 %65, -1
  store i64 %dec103, ptr %i, align 8
  %cmp104 = icmp sge i64 %dec103, 0
  br i1 %cmp104, label %for.body106, label %for.end128

for.body106:                                      ; preds = %for.cond102
  %66 = load ptr, ptr %input, align 8
  %incdec.ptr107 = getelementptr i8, ptr %66, i32 1
  store ptr %incdec.ptr107, ptr %input, align 8
  %67 = load i8, ptr %66, align 1
  %conv108 = sext i8 %67 to i32
  %and109 = and i32 %conv108, 255
  %conv110 = trunc i32 %and109 to i8
  %conv111 = zext i8 %conv110 to i64
  store i64 %conv111, ptr %c, align 8
  %68 = load i64, ptr %c, align 8
  %arrayidx112 = getelementptr [256 x i32], ptr %trans_table, i64 0, i64 %68
  %69 = load i32, ptr %arrayidx112, align 4
  %cmp113 = icmp ne i32 %69, -1
  br i1 %cmp113, label %if.then115, label %if.end127

if.then115:                                       ; preds = %for.body106
  %70 = load i64, ptr %c, align 8
  %arrayidx116 = getelementptr [256 x i32], ptr %trans_table, i64 0, i64 %70
  %71 = load i32, ptr %arrayidx116, align 4
  %conv117 = trunc i32 %71 to i8
  %72 = load ptr, ptr %output, align 8
  %incdec.ptr118 = getelementptr i8, ptr %72, i32 1
  store ptr %incdec.ptr118, ptr %output, align 8
  store i8 %conv117, ptr %72, align 1
  %conv119 = sext i8 %conv117 to i32
  %and120 = and i32 %conv119, 255
  %conv121 = trunc i32 %and120 to i8
  %conv122 = zext i8 %conv121 to i64
  %73 = load i64, ptr %c, align 8
  %cmp123 = icmp eq i64 %conv122, %73
  br i1 %cmp123, label %if.then125, label %if.end126

if.then125:                                       ; preds = %if.then115
  br label %for.cond102, !llvm.loop !87

if.end126:                                        ; preds = %if.then115
  br label %if.end127

if.end127:                                        ; preds = %if.end126, %for.body106
  store i64 1, ptr %changed, align 8
  br label %for.cond102, !llvm.loop !87

for.end128:                                       ; preds = %for.cond102
  %74 = load i64, ptr %changed, align 8
  %tobool129 = icmp ne i64 %74, 0
  br i1 %tobool129, label %if.end135, label %land.lhs.true130

land.lhs.true130:                                 ; preds = %for.end128
  %75 = load ptr, ptr %input_obj, align 8
  %call131 = call i32 @Py_IS_TYPE(ptr noundef %75, ptr noundef @PyBytes_Type)
  %tobool132 = icmp ne i32 %call131, 0
  br i1 %tobool132, label %if.then133, label %if.end135

if.then133:                                       ; preds = %land.lhs.true130
  %76 = load ptr, ptr %result, align 8
  store ptr %76, ptr %op.addr.i, align 8
  %77 = load ptr, ptr %op.addr.i, align 8
  store ptr %77, ptr %op.addr.i152, align 8
  %78 = load ptr, ptr %op.addr.i152, align 8
  %79 = load i64, ptr %78, align 8
  %conv.i153 = trunc i64 %79 to i32
  %cmp.i154 = icmp slt i32 %conv.i153, 0
  %conv1.i155 = zext i1 %cmp.i154 to i32
  %tobool.i = icmp ne i32 %conv1.i155, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then133
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %if.then133
  %80 = load ptr, ptr %op.addr.i, align 8
  %81 = load i64, ptr %80, align 8
  %dec.i = add i64 %81, -1
  store i64 %dec.i, ptr %80, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %82 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %82) #9
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  %83 = load ptr, ptr %input_obj, align 8
  %call134 = call ptr @_Py_NewRef(ptr noundef %83)
  store ptr %call134, ptr %retval, align 8
  br label %return

if.end135:                                        ; preds = %land.lhs.true130, %for.end128
  %84 = load i64, ptr %inlen, align 8
  %cmp136 = icmp sgt i64 %84, 0
  br i1 %cmp136, label %if.then138, label %if.end140

if.then138:                                       ; preds = %if.end135
  %85 = load ptr, ptr %output, align 8
  %86 = load ptr, ptr %output_start, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %85 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %86 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %call139 = call i32 @_PyBytes_Resize(ptr noundef %result, i64 noundef %sub.ptr.sub)
  br label %if.end140

if.end140:                                        ; preds = %if.then138, %if.end135
  %87 = load ptr, ptr %result, align 8
  store ptr %87, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end140, %Py_DECREF.exit, %if.end60, %if.then35, %if.then25, %if.then12, %if.then8
  %88 = load ptr, ptr %retval, align 8
  ret ptr %88
}

declare void @_Py_bytes_upper(ptr noundef, ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @stringlib_zfill_impl(ptr noundef %self, i64 noundef %width) #0 {
entry:
  %retval = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  %width.addr = alloca i64, align 8
  %fill = alloca i64, align 8
  %s = alloca ptr, align 8
  %p = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store i64 %width, ptr %width.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %call = call i64 @PyBytes_GET_SIZE(ptr noundef %0)
  %1 = load i64, ptr %width.addr, align 8
  %cmp = icmp sge i64 %call, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %self.addr, align 8
  %call1 = call ptr @return_self(ptr noundef %2)
  store ptr %call1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load i64, ptr %width.addr, align 8
  %4 = load ptr, ptr %self.addr, align 8
  %call2 = call i64 @PyBytes_GET_SIZE(ptr noundef %4)
  %sub = sub i64 %3, %call2
  store i64 %sub, ptr %fill, align 8
  %5 = load ptr, ptr %self.addr, align 8
  %6 = load i64, ptr %fill, align 8
  %call3 = call ptr @pad(ptr noundef %5, i64 noundef %6, i64 noundef 0, i8 noundef signext 48)
  store ptr %call3, ptr %s, align 8
  %7 = load ptr, ptr %s, align 8
  %cmp4 = icmp eq ptr %7, null
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end6:                                          ; preds = %if.end
  %8 = load ptr, ptr %s, align 8
  %call7 = call ptr @PyBytes_AS_STRING(ptr noundef %8)
  store ptr %call7, ptr %p, align 8
  %9 = load ptr, ptr %p, align 8
  %10 = load i64, ptr %fill, align 8
  %arrayidx = getelementptr i8, ptr %9, i64 %10
  %11 = load i8, ptr %arrayidx, align 1
  %conv = sext i8 %11 to i32
  %cmp8 = icmp eq i32 %conv, 43
  br i1 %cmp8, label %if.then14, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end6
  %12 = load ptr, ptr %p, align 8
  %13 = load i64, ptr %fill, align 8
  %arrayidx10 = getelementptr i8, ptr %12, i64 %13
  %14 = load i8, ptr %arrayidx10, align 1
  %conv11 = sext i8 %14 to i32
  %cmp12 = icmp eq i32 %conv11, 45
  br i1 %cmp12, label %if.then14, label %if.end18

if.then14:                                        ; preds = %lor.lhs.false, %if.end6
  %15 = load ptr, ptr %p, align 8
  %16 = load i64, ptr %fill, align 8
  %arrayidx15 = getelementptr i8, ptr %15, i64 %16
  %17 = load i8, ptr %arrayidx15, align 1
  %18 = load ptr, ptr %p, align 8
  %arrayidx16 = getelementptr i8, ptr %18, i64 0
  store i8 %17, ptr %arrayidx16, align 1
  %19 = load ptr, ptr %p, align 8
  %20 = load i64, ptr %fill, align 8
  %arrayidx17 = getelementptr i8, ptr %19, i64 %20
  store i8 48, ptr %arrayidx17, align 1
  br label %if.end18

if.end18:                                         ; preds = %if.then14, %lor.lhs.false
  %21 = load ptr, ptr %s, align 8
  store ptr %21, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end18, %if.then5, %if.then
  %22 = load ptr, ptr %retval, align 8
  ret ptr %22
}

declare ptr @PyType_GenericAlloc(ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define internal i64 @PyDict_GET_SIZE(ptr noundef %op) #0 {
entry:
  %op.addr = alloca ptr, align 8
  %mp = alloca ptr, align 8
  store ptr %op, ptr %op.addr, align 8
  %0 = load ptr, ptr %op.addr, align 8
  store ptr %0, ptr %mp, align 8
  %1 = load ptr, ptr %mp, align 8
  %ma_used = getelementptr inbounds %struct.PyDictObject, ptr %1, i32 0, i32 1
  %2 = load i64, ptr %ma_used, align 8
  ret i64 %2
}

; Function Attrs: nounwind uwtable
define internal ptr @bytes_new_impl(ptr noundef %type, ptr noundef %x, ptr noundef %encoding, ptr noundef %errors) #0 {
entry:
  %op.addr.i102 = alloca ptr, align 8
  %op.addr.i98 = alloca ptr, align 8
  %op.addr.i96 = alloca ptr, align 8
  %op.addr.i87 = alloca ptr, align 8
  %op.addr.i78 = alloca ptr, align 8
  %op.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %type.addr = alloca ptr, align 8
  %x.addr = alloca ptr, align 8
  %encoding.addr = alloca ptr, align 8
  %errors.addr = alloca ptr, align 8
  %bytes = alloca ptr, align 8
  %func = alloca ptr, align 8
  %size = alloca i64, align 8
  %_tmp_dst_ptr = alloca ptr, align 8
  %_tmp_old_dst = alloca ptr, align 8
  store ptr %type, ptr %type.addr, align 8
  store ptr %x, ptr %x.addr, align 8
  store ptr %encoding, ptr %encoding.addr, align 8
  store ptr %errors, ptr %errors.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %encoding.addr, align 8
  %cmp1 = icmp ne ptr %1, null
  br i1 %cmp1, label %if.then3, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %2 = load ptr, ptr %errors.addr, align 8
  %cmp2 = icmp ne ptr %2, null
  br i1 %cmp2, label %if.then3, label %if.end

if.then3:                                         ; preds = %lor.lhs.false, %if.then
  %3 = load ptr, ptr @PyExc_TypeError, align 8
  %4 = load ptr, ptr %encoding.addr, align 8
  %cmp4 = icmp ne ptr %4, null
  %cond = select i1 %cmp4, ptr @.str.123, ptr @.str.124
  call void @PyErr_SetString(ptr noundef %3, ptr noundef %cond)
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %call = call ptr @PyBytes_FromStringAndSize(ptr noundef null, i64 noundef 0)
  store ptr %call, ptr %bytes, align 8
  br label %if.end71

if.else:                                          ; preds = %entry
  %5 = load ptr, ptr %encoding.addr, align 8
  %cmp5 = icmp ne ptr %5, null
  br i1 %cmp5, label %if.then6, label %if.else12

if.then6:                                         ; preds = %if.else
  %6 = load ptr, ptr %x.addr, align 8
  %call7 = call ptr @Py_TYPE(ptr noundef %6)
  %call8 = call i32 @PyType_HasFeature(ptr noundef %call7, i64 noundef 268435456)
  %tobool = icmp ne i32 %call8, 0
  br i1 %tobool, label %if.end10, label %if.then9

if.then9:                                         ; preds = %if.then6
  %7 = load ptr, ptr @PyExc_TypeError, align 8
  call void @PyErr_SetString(ptr noundef %7, ptr noundef @.str.123)
  store ptr null, ptr %retval, align 8
  br label %return

if.end10:                                         ; preds = %if.then6
  %8 = load ptr, ptr %x.addr, align 8
  %9 = load ptr, ptr %encoding.addr, align 8
  %10 = load ptr, ptr %errors.addr, align 8
  %call11 = call ptr @PyUnicode_AsEncodedString(ptr noundef %8, ptr noundef %9, ptr noundef %10)
  store ptr %call11, ptr %bytes, align 8
  br label %if.end70

if.else12:                                        ; preds = %if.else
  %11 = load ptr, ptr %errors.addr, align 8
  %cmp13 = icmp ne ptr %11, null
  br i1 %cmp13, label %if.then14, label %if.else19

if.then14:                                        ; preds = %if.else12
  %12 = load ptr, ptr @PyExc_TypeError, align 8
  %13 = load ptr, ptr %x.addr, align 8
  %call15 = call ptr @Py_TYPE(ptr noundef %13)
  %call16 = call i32 @PyType_HasFeature(ptr noundef %call15, i64 noundef 268435456)
  %tobool17 = icmp ne i32 %call16, 0
  %cond18 = select i1 %tobool17, ptr @.str.125, ptr @.str.124
  call void @PyErr_SetString(ptr noundef %12, ptr noundef %cond18)
  store ptr null, ptr %retval, align 8
  br label %return

if.else19:                                        ; preds = %if.else12
  %14 = load ptr, ptr %x.addr, align 8
  %call20 = call ptr @_PyObject_LookupSpecial(ptr noundef %14, ptr noundef getelementptr inbounds (%struct.anon.38, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 37), i32 0, i32 3, i32 1, i32 31))
  store ptr %call20, ptr %func, align 8
  %cmp21 = icmp ne ptr %call20, null
  br i1 %cmp21, label %if.then22, label %if.else34

if.then22:                                        ; preds = %if.else19
  %15 = load ptr, ptr %func, align 8
  %call23 = call ptr @_PyObject_CallNoArgs(ptr noundef %15)
  store ptr %call23, ptr %bytes, align 8
  %16 = load ptr, ptr %func, align 8
  store ptr %16, ptr %op.addr.i87, align 8
  %17 = load ptr, ptr %op.addr.i87, align 8
  store ptr %17, ptr %op.addr.i96, align 8
  %18 = load ptr, ptr %op.addr.i96, align 8
  %19 = load i64, ptr %18, align 8
  %conv.i = trunc i64 %19 to i32
  %cmp.i97 = icmp slt i32 %conv.i, 0
  %conv1.i = zext i1 %cmp.i97 to i32
  %tobool.i89 = icmp ne i32 %conv1.i, 0
  br i1 %tobool.i89, label %if.then.i94, label %if.end.i90

if.then.i94:                                      ; preds = %if.then22
  br label %Py_DECREF.exit95

if.end.i90:                                       ; preds = %if.then22
  %20 = load ptr, ptr %op.addr.i87, align 8
  %21 = load i64, ptr %20, align 8
  %dec.i91 = add i64 %21, -1
  store i64 %dec.i91, ptr %20, align 8
  %cmp.i92 = icmp eq i64 %dec.i91, 0
  br i1 %cmp.i92, label %if.then1.i93, label %Py_DECREF.exit95

if.then1.i93:                                     ; preds = %if.end.i90
  %22 = load ptr, ptr %op.addr.i87, align 8
  call void @_Py_Dealloc(ptr noundef %22) #9
  br label %Py_DECREF.exit95

Py_DECREF.exit95:                                 ; preds = %if.then1.i93, %if.end.i90, %if.then.i94
  %23 = load ptr, ptr %bytes, align 8
  %cmp24 = icmp eq ptr %23, null
  br i1 %cmp24, label %if.then25, label %if.end26

if.then25:                                        ; preds = %Py_DECREF.exit95
  store ptr null, ptr %retval, align 8
  br label %return

if.end26:                                         ; preds = %Py_DECREF.exit95
  %24 = load ptr, ptr %bytes, align 8
  %call27 = call ptr @Py_TYPE(ptr noundef %24)
  %call28 = call i32 @PyType_HasFeature(ptr noundef %call27, i64 noundef 134217728)
  %tobool29 = icmp ne i32 %call28, 0
  br i1 %tobool29, label %if.end33, label %if.then30

if.then30:                                        ; preds = %if.end26
  %25 = load ptr, ptr @PyExc_TypeError, align 8
  %26 = load ptr, ptr %bytes, align 8
  %call31 = call ptr @Py_TYPE(ptr noundef %26)
  %tp_name = getelementptr inbounds %struct._typeobject, ptr %call31, i32 0, i32 1
  %27 = load ptr, ptr %tp_name, align 8
  %call32 = call ptr (ptr, ptr, ...) @PyErr_Format(ptr noundef %25, ptr noundef @.str.39, ptr noundef %27)
  %28 = load ptr, ptr %bytes, align 8
  store ptr %28, ptr %op.addr.i78, align 8
  %29 = load ptr, ptr %op.addr.i78, align 8
  store ptr %29, ptr %op.addr.i98, align 8
  %30 = load ptr, ptr %op.addr.i98, align 8
  %31 = load i64, ptr %30, align 8
  %conv.i99 = trunc i64 %31 to i32
  %cmp.i100 = icmp slt i32 %conv.i99, 0
  %conv1.i101 = zext i1 %cmp.i100 to i32
  %tobool.i80 = icmp ne i32 %conv1.i101, 0
  br i1 %tobool.i80, label %if.then.i85, label %if.end.i81

if.then.i85:                                      ; preds = %if.then30
  br label %Py_DECREF.exit86

if.end.i81:                                       ; preds = %if.then30
  %32 = load ptr, ptr %op.addr.i78, align 8
  %33 = load i64, ptr %32, align 8
  %dec.i82 = add i64 %33, -1
  store i64 %dec.i82, ptr %32, align 8
  %cmp.i83 = icmp eq i64 %dec.i82, 0
  br i1 %cmp.i83, label %if.then1.i84, label %Py_DECREF.exit86

if.then1.i84:                                     ; preds = %if.end.i81
  %34 = load ptr, ptr %op.addr.i78, align 8
  call void @_Py_Dealloc(ptr noundef %34) #9
  br label %Py_DECREF.exit86

Py_DECREF.exit86:                                 ; preds = %if.then1.i84, %if.end.i81, %if.then.i85
  store ptr null, ptr %retval, align 8
  br label %return

if.end33:                                         ; preds = %if.end26
  br label %if.end68

if.else34:                                        ; preds = %if.else19
  %call35 = call ptr @PyErr_Occurred()
  %tobool36 = icmp ne ptr %call35, null
  br i1 %tobool36, label %if.then37, label %if.else38

if.then37:                                        ; preds = %if.else34
  store ptr null, ptr %retval, align 8
  br label %return

if.else38:                                        ; preds = %if.else34
  %35 = load ptr, ptr %x.addr, align 8
  %call39 = call ptr @Py_TYPE(ptr noundef %35)
  %call40 = call i32 @PyType_HasFeature(ptr noundef %call39, i64 noundef 268435456)
  %tobool41 = icmp ne i32 %call40, 0
  br i1 %tobool41, label %if.then42, label %if.else43

if.then42:                                        ; preds = %if.else38
  %36 = load ptr, ptr @PyExc_TypeError, align 8
  call void @PyErr_SetString(ptr noundef %36, ptr noundef @.str.125)
  store ptr null, ptr %retval, align 8
  br label %return

if.else43:                                        ; preds = %if.else38
  %37 = load ptr, ptr %x.addr, align 8
  %call44 = call i32 @_PyIndex_Check(ptr noundef %37)
  %tobool45 = icmp ne i32 %call44, 0
  br i1 %tobool45, label %if.then46, label %if.else63

if.then46:                                        ; preds = %if.else43
  %38 = load ptr, ptr %x.addr, align 8
  %39 = load ptr, ptr @PyExc_OverflowError, align 8
  %call47 = call i64 @PyNumber_AsSsize_t(ptr noundef %38, ptr noundef %39)
  store i64 %call47, ptr %size, align 8
  %40 = load i64, ptr %size, align 8
  %cmp48 = icmp eq i64 %40, -1
  br i1 %cmp48, label %land.lhs.true, label %if.else57

land.lhs.true:                                    ; preds = %if.then46
  %call49 = call ptr @PyErr_Occurred()
  %tobool50 = icmp ne ptr %call49, null
  br i1 %tobool50, label %if.then51, label %if.else57

if.then51:                                        ; preds = %land.lhs.true
  %41 = load ptr, ptr @PyExc_TypeError, align 8
  %call52 = call i32 @PyErr_ExceptionMatches(ptr noundef %41)
  %tobool53 = icmp ne i32 %call52, 0
  br i1 %tobool53, label %if.end55, label %if.then54

if.then54:                                        ; preds = %if.then51
  store ptr null, ptr %retval, align 8
  br label %return

if.end55:                                         ; preds = %if.then51
  call void @PyErr_Clear()
  %42 = load ptr, ptr %x.addr, align 8
  %call56 = call ptr @PyBytes_FromObject(ptr noundef %42)
  store ptr %call56, ptr %bytes, align 8
  br label %if.end62

if.else57:                                        ; preds = %land.lhs.true, %if.then46
  %43 = load i64, ptr %size, align 8
  %cmp58 = icmp slt i64 %43, 0
  br i1 %cmp58, label %if.then59, label %if.end60

if.then59:                                        ; preds = %if.else57
  %44 = load ptr, ptr @PyExc_ValueError, align 8
  call void @PyErr_SetString(ptr noundef %44, ptr noundef @.str.126)
  store ptr null, ptr %retval, align 8
  br label %return

if.end60:                                         ; preds = %if.else57
  %45 = load i64, ptr %size, align 8
  %call61 = call ptr @_PyBytes_FromSize(i64 noundef %45, i32 noundef 1)
  store ptr %call61, ptr %bytes, align 8
  br label %if.end62

if.end62:                                         ; preds = %if.end60, %if.end55
  br label %if.end65

if.else63:                                        ; preds = %if.else43
  %46 = load ptr, ptr %x.addr, align 8
  %call64 = call ptr @PyBytes_FromObject(ptr noundef %46)
  store ptr %call64, ptr %bytes, align 8
  br label %if.end65

if.end65:                                         ; preds = %if.else63, %if.end62
  br label %if.end66

if.end66:                                         ; preds = %if.end65
  br label %if.end67

if.end67:                                         ; preds = %if.end66
  br label %if.end68

if.end68:                                         ; preds = %if.end67, %if.end33
  br label %if.end69

if.end69:                                         ; preds = %if.end68
  br label %if.end70

if.end70:                                         ; preds = %if.end69, %if.end10
  br label %if.end71

if.end71:                                         ; preds = %if.end70, %if.end
  %47 = load ptr, ptr %bytes, align 8
  %cmp72 = icmp ne ptr %47, null
  br i1 %cmp72, label %land.lhs.true73, label %if.end77

land.lhs.true73:                                  ; preds = %if.end71
  %48 = load ptr, ptr %type.addr, align 8
  %cmp74 = icmp ne ptr %48, @PyBytes_Type
  br i1 %cmp74, label %if.then75, label %if.end77

if.then75:                                        ; preds = %land.lhs.true73
  br label %do.body

do.body:                                          ; preds = %if.then75
  store ptr %bytes, ptr %_tmp_dst_ptr, align 8
  %49 = load ptr, ptr %_tmp_dst_ptr, align 8
  %50 = load ptr, ptr %49, align 8
  store ptr %50, ptr %_tmp_old_dst, align 8
  %51 = load ptr, ptr %type.addr, align 8
  %52 = load ptr, ptr %bytes, align 8
  %call76 = call ptr @bytes_subtype_new(ptr noundef %51, ptr noundef %52)
  %53 = load ptr, ptr %_tmp_dst_ptr, align 8
  store ptr %call76, ptr %53, align 8
  %54 = load ptr, ptr %_tmp_old_dst, align 8
  store ptr %54, ptr %op.addr.i, align 8
  %55 = load ptr, ptr %op.addr.i, align 8
  store ptr %55, ptr %op.addr.i102, align 8
  %56 = load ptr, ptr %op.addr.i102, align 8
  %57 = load i64, ptr %56, align 8
  %conv.i103 = trunc i64 %57 to i32
  %cmp.i104 = icmp slt i32 %conv.i103, 0
  %conv1.i105 = zext i1 %cmp.i104 to i32
  %tobool.i = icmp ne i32 %conv1.i105, 0
  br i1 %tobool.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %do.body
  br label %Py_DECREF.exit

if.end.i:                                         ; preds = %do.body
  %58 = load ptr, ptr %op.addr.i, align 8
  %59 = load i64, ptr %58, align 8
  %dec.i = add i64 %59, -1
  store i64 %dec.i, ptr %58, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then1.i, label %Py_DECREF.exit

if.then1.i:                                       ; preds = %if.end.i
  %60 = load ptr, ptr %op.addr.i, align 8
  call void @_Py_Dealloc(ptr noundef %60) #9
  br label %Py_DECREF.exit

Py_DECREF.exit:                                   ; preds = %if.then1.i, %if.end.i, %if.then.i
  br label %do.end

do.end:                                           ; preds = %Py_DECREF.exit
  br label %if.end77

if.end77:                                         ; preds = %do.end, %land.lhs.true73, %if.end71
  %61 = load ptr, ptr %bytes, align 8
  store ptr %61, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end77, %if.then59, %if.then54, %if.then42, %if.then37, %Py_DECREF.exit86, %if.then25, %if.then14, %if.then9, %if.then3
  %62 = load ptr, ptr %retval, align 8
  ret ptr %62
}

declare ptr @PyUnicode_AsEncodedString(ptr noundef, ptr noundef, ptr noundef) #1

declare void @PyErr_Clear() #1

; Function Attrs: nounwind uwtable
define internal ptr @bytes_subtype_new(ptr noundef %type, ptr noundef %tmp) #0 {
entry:
  %type.addr = alloca ptr, align 8
  %tmp.addr = alloca ptr, align 8
  %pnew = alloca ptr, align 8
  %n = alloca i64, align 8
  store ptr %type, ptr %type.addr, align 8
  store ptr %tmp, ptr %tmp.addr, align 8
  %0 = load ptr, ptr %tmp.addr, align 8
  %call = call i64 @PyBytes_GET_SIZE(ptr noundef %0)
  store i64 %call, ptr %n, align 8
  %1 = load ptr, ptr %type.addr, align 8
  %tp_alloc = getelementptr inbounds %struct._typeobject, ptr %1, i32 0, i32 36
  %2 = load ptr, ptr %tp_alloc, align 8
  %3 = load ptr, ptr %type.addr, align 8
  %4 = load i64, ptr %n, align 8
  %call1 = call ptr %2(ptr noundef %3, i64 noundef %4)
  store ptr %call1, ptr %pnew, align 8
  %5 = load ptr, ptr %pnew, align 8
  %cmp = icmp ne ptr %5, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load ptr, ptr %pnew, align 8
  %call2 = call ptr @PyBytes_AS_STRING(ptr noundef %6)
  %7 = load ptr, ptr %tmp.addr, align 8
  %call3 = call ptr @PyBytes_AS_STRING(ptr noundef %7)
  %8 = load i64, ptr %n, align 8
  %add = add i64 %8, 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %call2, ptr align 1 %call3, i64 %add, i1 false)
  %9 = load ptr, ptr %tmp.addr, align 8
  %ob_shash = getelementptr inbounds %struct.PyBytesObject, ptr %9, i32 0, i32 1
  %10 = load i64, ptr %ob_shash, align 8
  %11 = load ptr, ptr %pnew, align 8
  %ob_shash4 = getelementptr inbounds %struct.PyBytesObject, ptr %11, i32 0, i32 1
  store i64 %10, ptr %ob_shash4, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %12 = load ptr, ptr %pnew, align 8
  ret ptr %12
}

; Function Attrs: nounwind uwtable
define internal void @_PyObject_GC_UNTRACK(ptr noundef %op) #0 {
entry:
  %op.addr = alloca ptr, align 8
  %gc = alloca ptr, align 8
  %prev = alloca ptr, align 8
  %next = alloca ptr, align 8
  store ptr %op, ptr %op.addr, align 8
  %0 = load ptr, ptr %op.addr, align 8
  %call = call ptr @_Py_AS_GC(ptr noundef %0)
  store ptr %call, ptr %gc, align 8
  %1 = load ptr, ptr %gc, align 8
  %call1 = call ptr @_PyGCHead_PREV(ptr noundef %1)
  store ptr %call1, ptr %prev, align 8
  %2 = load ptr, ptr %gc, align 8
  %call2 = call ptr @_PyGCHead_NEXT(ptr noundef %2)
  store ptr %call2, ptr %next, align 8
  %3 = load ptr, ptr %prev, align 8
  %4 = load ptr, ptr %next, align 8
  call void @_PyGCHead_SET_NEXT(ptr noundef %3, ptr noundef %4)
  %5 = load ptr, ptr %next, align 8
  %6 = load ptr, ptr %prev, align 8
  call void @_PyGCHead_SET_PREV(ptr noundef %5, ptr noundef %6)
  %7 = load ptr, ptr %gc, align 8
  %_gc_next = getelementptr inbounds %struct.PyGC_Head, ptr %7, i32 0, i32 0
  store i64 0, ptr %_gc_next, align 8
  %8 = load ptr, ptr %gc, align 8
  %_gc_prev = getelementptr inbounds %struct.PyGC_Head, ptr %8, i32 0, i32 1
  %9 = load i64, ptr %_gc_prev, align 8
  %and = and i64 %9, 1
  store i64 %and, ptr %_gc_prev, align 8
  ret void
}

declare void @PyObject_GC_Del(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @_Py_AS_GC(ptr noundef %op) #0 {
entry:
  %op.addr = alloca ptr, align 8
  %gc = alloca ptr, align 8
  store ptr %op, ptr %op.addr, align 8
  %0 = load ptr, ptr %op.addr, align 8
  %add.ptr = getelementptr i8, ptr %0, i64 -16
  store ptr %add.ptr, ptr %gc, align 8
  %1 = load ptr, ptr %gc, align 8
  ret ptr %1
}

; Function Attrs: nounwind uwtable
define internal ptr @_PyGCHead_PREV(ptr noundef %gc) #0 {
entry:
  %gc.addr = alloca ptr, align 8
  %prev = alloca i64, align 8
  store ptr %gc, ptr %gc.addr, align 8
  %0 = load ptr, ptr %gc.addr, align 8
  %_gc_prev = getelementptr inbounds %struct.PyGC_Head, ptr %0, i32 0, i32 1
  %1 = load i64, ptr %_gc_prev, align 8
  %and = and i64 %1, -4
  store i64 %and, ptr %prev, align 8
  %2 = load i64, ptr %prev, align 8
  %3 = inttoptr i64 %2 to ptr
  ret ptr %3
}

; Function Attrs: nounwind uwtable
define internal ptr @_PyGCHead_NEXT(ptr noundef %gc) #0 {
entry:
  %gc.addr = alloca ptr, align 8
  %next = alloca i64, align 8
  store ptr %gc, ptr %gc.addr, align 8
  %0 = load ptr, ptr %gc.addr, align 8
  %_gc_next = getelementptr inbounds %struct.PyGC_Head, ptr %0, i32 0, i32 0
  %1 = load i64, ptr %_gc_next, align 8
  store i64 %1, ptr %next, align 8
  %2 = load i64, ptr %next, align 8
  %3 = inttoptr i64 %2 to ptr
  ret ptr %3
}

; Function Attrs: nounwind uwtable
define internal void @_PyGCHead_SET_NEXT(ptr noundef %gc, ptr noundef %next) #0 {
entry:
  %gc.addr = alloca ptr, align 8
  %next.addr = alloca ptr, align 8
  store ptr %gc, ptr %gc.addr, align 8
  store ptr %next, ptr %next.addr, align 8
  %0 = load ptr, ptr %next.addr, align 8
  %1 = ptrtoint ptr %0 to i64
  %2 = load ptr, ptr %gc.addr, align 8
  %_gc_next = getelementptr inbounds %struct.PyGC_Head, ptr %2, i32 0, i32 0
  store i64 %1, ptr %_gc_next, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @_PyGCHead_SET_PREV(ptr noundef %gc, ptr noundef %prev) #0 {
entry:
  %gc.addr = alloca ptr, align 8
  %prev.addr = alloca ptr, align 8
  %uprev = alloca i64, align 8
  store ptr %gc, ptr %gc.addr, align 8
  store ptr %prev, ptr %prev.addr, align 8
  %0 = load ptr, ptr %prev.addr, align 8
  %1 = ptrtoint ptr %0 to i64
  store i64 %1, ptr %uprev, align 8
  %2 = load ptr, ptr %gc.addr, align 8
  %_gc_prev = getelementptr inbounds %struct.PyGC_Head, ptr %2, i32 0, i32 1
  %3 = load i64, ptr %_gc_prev, align 8
  %and = and i64 %3, 3
  %4 = load i64, ptr %uprev, align 8
  %or = or i64 %and, %4
  %5 = load ptr, ptr %gc.addr, align 8
  %_gc_prev1 = getelementptr inbounds %struct.PyGC_Head, ptr %5, i32 0, i32 1
  store i64 %or, ptr %_gc_prev1, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal ptr @striter_len(ptr noundef %it, ptr noundef %_unused_ignored) #0 {
entry:
  %it.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  %len = alloca i64, align 8
  store ptr %it, ptr %it.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  store i64 0, ptr %len, align 8
  %0 = load ptr, ptr %it.addr, align 8
  %it_seq = getelementptr inbounds %struct.striterobject, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %it_seq, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %it.addr, align 8
  %it_seq1 = getelementptr inbounds %struct.striterobject, ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %it_seq1, align 8
  %call = call i64 @PyBytes_GET_SIZE(ptr noundef %3)
  %4 = load ptr, ptr %it.addr, align 8
  %it_index = getelementptr inbounds %struct.striterobject, ptr %4, i32 0, i32 1
  %5 = load i64, ptr %it_index, align 8
  %sub = sub i64 %call, %5
  store i64 %sub, ptr %len, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load i64, ptr %len, align 8
  %call2 = call ptr @PyLong_FromSsize_t(i64 noundef %6)
  ret ptr %call2
}

; Function Attrs: nounwind uwtable
define internal ptr @striter_reduce(ptr noundef %it, ptr noundef %_unused_ignored) #0 {
entry:
  %retval = alloca ptr, align 8
  %it.addr = alloca ptr, align 8
  %_unused_ignored.addr = alloca ptr, align 8
  %iter = alloca ptr, align 8
  store ptr %it, ptr %it.addr, align 8
  store ptr %_unused_ignored, ptr %_unused_ignored.addr, align 8
  %call = call ptr @_PyEval_GetBuiltin(ptr noundef getelementptr inbounds (%struct.anon.38, ptr getelementptr inbounds (%struct.pyruntimestate, ptr @_PyRuntime, i32 0, i32 37), i32 0, i32 3, i32 1, i32 434))
  store ptr %call, ptr %iter, align 8
  %0 = load ptr, ptr %it.addr, align 8
  %it_seq = getelementptr inbounds %struct.striterobject, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %it_seq, align 8
  %cmp = icmp ne ptr %1, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %iter, align 8
  %3 = load ptr, ptr %it.addr, align 8
  %it_seq1 = getelementptr inbounds %struct.striterobject, ptr %3, i32 0, i32 2
  %4 = load ptr, ptr %it_seq1, align 8
  %5 = load ptr, ptr %it.addr, align 8
  %it_index = getelementptr inbounds %struct.striterobject, ptr %5, i32 0, i32 1
  %6 = load i64, ptr %it_index, align 8
  %call2 = call ptr (ptr, ...) @Py_BuildValue(ptr noundef @.str.130, ptr noundef %2, ptr noundef %4, i64 noundef %6)
  store ptr %call2, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %7 = load ptr, ptr %iter, align 8
  %call3 = call ptr (ptr, ...) @Py_BuildValue(ptr noundef @.str.131, ptr noundef %7)
  store ptr %call3, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %8 = load ptr, ptr %retval, align 8
  ret ptr %8
}

; Function Attrs: nounwind uwtable
define internal ptr @striter_setstate(ptr noundef %it, ptr noundef %state) #0 {
entry:
  %retval = alloca ptr, align 8
  %it.addr = alloca ptr, align 8
  %state.addr = alloca ptr, align 8
  %index = alloca i64, align 8
  store ptr %it, ptr %it.addr, align 8
  store ptr %state, ptr %state.addr, align 8
  %0 = load ptr, ptr %state.addr, align 8
  %call = call i64 @PyLong_AsSsize_t(ptr noundef %0)
  store i64 %call, ptr %index, align 8
  %1 = load i64, ptr %index, align 8
  %cmp = icmp eq i64 %1, -1
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %call1 = call ptr @PyErr_Occurred()
  %tobool = icmp ne ptr %call1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %2 = load ptr, ptr %it.addr, align 8
  %it_seq = getelementptr inbounds %struct.striterobject, ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %it_seq, align 8
  %cmp2 = icmp ne ptr %3, null
  br i1 %cmp2, label %if.then3, label %if.end14

if.then3:                                         ; preds = %if.end
  %4 = load i64, ptr %index, align 8
  %cmp4 = icmp slt i64 %4, 0
  br i1 %cmp4, label %if.then5, label %if.else

if.then5:                                         ; preds = %if.then3
  store i64 0, ptr %index, align 8
  br label %if.end13

if.else:                                          ; preds = %if.then3
  %5 = load i64, ptr %index, align 8
  %6 = load ptr, ptr %it.addr, align 8
  %it_seq6 = getelementptr inbounds %struct.striterobject, ptr %6, i32 0, i32 2
  %7 = load ptr, ptr %it_seq6, align 8
  %call7 = call i64 @PyBytes_GET_SIZE(ptr noundef %7)
  %cmp8 = icmp sgt i64 %5, %call7
  br i1 %cmp8, label %if.then9, label %if.end12

if.then9:                                         ; preds = %if.else
  %8 = load ptr, ptr %it.addr, align 8
  %it_seq10 = getelementptr inbounds %struct.striterobject, ptr %8, i32 0, i32 2
  %9 = load ptr, ptr %it_seq10, align 8
  %call11 = call i64 @PyBytes_GET_SIZE(ptr noundef %9)
  store i64 %call11, ptr %index, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then9, %if.else
  br label %if.end13

if.end13:                                         ; preds = %if.end12, %if.then5
  %10 = load i64, ptr %index, align 8
  %11 = load ptr, ptr %it.addr, align 8
  %it_index = getelementptr inbounds %struct.striterobject, ptr %11, i32 0, i32 1
  store i64 %10, ptr %it_index, align 8
  br label %if.end14

if.end14:                                         ; preds = %if.end13, %if.end
  store ptr @_Py_NoneStruct, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end14, %if.then
  %12 = load ptr, ptr %retval, align 8
  ret ptr %12
}

declare ptr @PyLong_FromSsize_t(i64 noundef) #1

declare ptr @_PyEval_GetBuiltin(ptr noundef) #1

declare ptr @_PyObject_GC_New(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal void @_PyObject_GC_TRACK(ptr noundef %op) #0 {
entry:
  %op.addr = alloca ptr, align 8
  %gc = alloca ptr, align 8
  %interp = alloca ptr, align 8
  %generation0 = alloca ptr, align 8
  %last = alloca ptr, align 8
  store ptr %op, ptr %op.addr, align 8
  %0 = load ptr, ptr %op.addr, align 8
  %call = call ptr @_Py_AS_GC(ptr noundef %0)
  store ptr %call, ptr %gc, align 8
  %call1 = call ptr @_PyInterpreterState_GET()
  store ptr %call1, ptr %interp, align 8
  %1 = load ptr, ptr %interp, align 8
  %gc2 = getelementptr inbounds %struct._is, ptr %1, i32 0, i32 13
  %generation03 = getelementptr inbounds %struct._gc_runtime_state, ptr %gc2, i32 0, i32 5
  %2 = load ptr, ptr %generation03, align 8
  store ptr %2, ptr %generation0, align 8
  %3 = load ptr, ptr %generation0, align 8
  %_gc_prev = getelementptr inbounds %struct.PyGC_Head, ptr %3, i32 0, i32 1
  %4 = load i64, ptr %_gc_prev, align 8
  %5 = inttoptr i64 %4 to ptr
  store ptr %5, ptr %last, align 8
  %6 = load ptr, ptr %last, align 8
  %7 = load ptr, ptr %gc, align 8
  call void @_PyGCHead_SET_NEXT(ptr noundef %6, ptr noundef %7)
  %8 = load ptr, ptr %gc, align 8
  %9 = load ptr, ptr %last, align 8
  call void @_PyGCHead_SET_PREV(ptr noundef %8, ptr noundef %9)
  %10 = load ptr, ptr %gc, align 8
  %11 = load ptr, ptr %generation0, align 8
  call void @_PyGCHead_SET_NEXT(ptr noundef %10, ptr noundef %11)
  %12 = load ptr, ptr %gc, align 8
  %13 = ptrtoint ptr %12 to i64
  %14 = load ptr, ptr %generation0, align 8
  %_gc_prev4 = getelementptr inbounds %struct.PyGC_Head, ptr %14, i32 0, i32 1
  store i64 %13, ptr %_gc_prev4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal ptr @_PyInterpreterState_GET() #0 {
entry:
  %tstate = alloca ptr, align 8
  %call = call ptr @_PyThreadState_GET()
  store ptr %call, ptr %tstate, align 8
  %0 = load ptr, ptr %tstate, align 8
  %interp = getelementptr inbounds %struct._ts, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %interp, align 8
  ret ptr %1
}

attributes #0 = { nounwind uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #2 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #3 = { nounwind willreturn memory(read) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #4 = { nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #5 = { nocallback nofree nosync nounwind willreturn }
attributes #6 = { nocallback nofree nounwind willreturn memory(argmem: write) }
attributes #7 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #8 = { nounwind willreturn memory(read) }
attributes #9 = { nounwind }

!llvm.module.flags = !{!0, !1, !2, !3, !4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = distinct !{!5, !6}
!6 = !{!"llvm.loop.mustprogress"}
!7 = distinct !{!7, !6}
!8 = distinct !{!8, !6}
!9 = distinct !{!9, !6}
!10 = distinct !{!10, !6}
!11 = distinct !{!11, !6}
!12 = distinct !{!12, !6}
!13 = distinct !{!13, !6}
!14 = distinct !{!14, !6}
!15 = distinct !{!15, !6}
!16 = distinct !{!16, !6}
!17 = distinct !{!17, !6}
!18 = distinct !{!18, !6}
!19 = distinct !{!19, !6}
!20 = distinct !{!20, !6}
!21 = distinct !{!21, !6}
!22 = distinct !{!22, !6}
!23 = distinct !{!23, !6}
!24 = distinct !{!24, !6}
!25 = distinct !{!25, !6}
!26 = distinct !{!26, !6}
!27 = distinct !{!27, !6}
!28 = distinct !{!28, !6}
!29 = distinct !{!29, !6}
!30 = distinct !{!30, !6}
!31 = distinct !{!31, !6}
!32 = distinct !{!32, !6}
!33 = distinct !{!33, !6}
!34 = distinct !{!34, !6}
!35 = distinct !{!35, !6}
!36 = distinct !{!36, !6}
!37 = distinct !{!37, !6}
!38 = distinct !{!38, !6}
!39 = distinct !{!39, !6}
!40 = distinct !{!40, !6}
!41 = distinct !{!41, !6}
!42 = distinct !{!42, !6}
!43 = distinct !{!43, !6}
!44 = distinct !{!44, !6}
!45 = distinct !{!45, !6}
!46 = distinct !{!46, !6}
!47 = distinct !{!47, !6}
!48 = distinct !{!48, !6}
!49 = distinct !{!49, !6}
!50 = distinct !{!50, !6}
!51 = distinct !{!51, !6}
!52 = distinct !{!52, !6}
!53 = distinct !{!53, !6}
!54 = distinct !{!54, !6}
!55 = distinct !{!55, !6}
!56 = distinct !{!56, !6}
!57 = distinct !{!57, !6}
!58 = distinct !{!58, !6}
!59 = distinct !{!59, !6}
!60 = distinct !{!60, !6}
!61 = distinct !{!61, !6}
!62 = distinct !{!62, !6}
!63 = distinct !{!63, !6}
!64 = distinct !{!64, !6}
!65 = distinct !{!65, !6}
!66 = distinct !{!66, !6}
!67 = distinct !{!67, !6}
!68 = distinct !{!68, !6}
!69 = distinct !{!69, !6}
!70 = distinct !{!70, !6}
!71 = distinct !{!71, !6}
!72 = distinct !{!72, !6}
!73 = distinct !{!73, !6}
!74 = distinct !{!74, !6}
!75 = distinct !{!75, !6}
!76 = distinct !{!76, !6}
!77 = distinct !{!77, !6}
!78 = distinct !{!78, !6}
!79 = distinct !{!79, !6}
!80 = distinct !{!80, !6}
!81 = distinct !{!81, !6}
!82 = distinct !{!82, !6}
!83 = distinct !{!83, !6}
!84 = distinct !{!84, !6}
!85 = distinct !{!85, !6}
!86 = distinct !{!86, !6}
!87 = distinct !{!87, !6}
