; ModuleID = 'bench/cpython/original/xmlparse.ll'
source_filename = "bench/cpython/original/xmlparse.ll"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.XML_Feature = type { i32, ptr, i64 }
%struct.XML_ParserStruct = type { ptr, ptr, ptr, %struct.XML_Memory_Handling_Suite, ptr, ptr, ptr, i64, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, %struct.INIT_ENCODING, ptr, ptr, i8, i8, ptr, ptr, ptr, ptr, %struct.prolog_state, ptr, i32, ptr, ptr, ptr, ptr, ptr, i8, i32, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i8, i8, ptr, ptr, ptr, ptr, ptr, ptr, i32, i32, i32, ptr, ptr, i64, i8, %struct.position, %struct.STRING_POOL, %struct.STRING_POOL, ptr, i32, i8, ptr, %struct.XML_ParsingStatus, i8, i8, i32, i64, %struct.accounting, %struct.entity_stats }
%struct.XML_Memory_Handling_Suite = type { ptr, ptr, ptr }
%struct.INIT_ENCODING = type { %struct.encoding, ptr }
%struct.encoding = type { [4 x ptr], [2 x ptr], ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i32, i8, i8 }
%struct.prolog_state = type { ptr, i32, i32, i32, i32, i32 }
%struct.position = type { i64, i64 }
%struct.STRING_POOL = type { ptr, ptr, ptr, ptr, ptr, ptr }
%struct.XML_ParsingStatus = type { i32, i8 }
%struct.accounting = type { i64, i64, i32, float, i64 }
%struct.entity_stats = type { i32, i32, i32, i32 }
%struct.DTD = type { %struct.HASH_TABLE, %struct.HASH_TABLE, %struct.HASH_TABLE, %struct.HASH_TABLE, %struct.STRING_POOL, %struct.STRING_POOL, i8, i8, i8, i8, %struct.HASH_TABLE, %struct.prefix, i8, ptr, i32, i32, i32, i32, ptr }
%struct.HASH_TABLE = type { ptr, i8, i64, i64, ptr }
%struct.prefix = type { ptr, ptr }
%struct.tag = type { ptr, ptr, i32, %struct.TAG_NAME, ptr, ptr, ptr }
%struct.TAG_NAME = type { ptr, ptr, ptr, i32, i32, i32 }
%struct.binding = type { ptr, ptr, ptr, ptr, ptr, i32, i32 }
%struct.open_internal_entity = type { ptr, ptr, ptr, ptr, i32, i8 }
%struct.ELEMENT_TYPE = type { ptr, ptr, ptr, i32, i32, ptr }
%struct.block = type { ptr, i32, [1 x i8] }
%struct.attribute_id = type { ptr, ptr, i8, i8 }
%struct.DEFAULT_ATTRIBUTE = type { ptr, i8, ptr }
%struct.ENTITY = type { ptr, ptr, i32, i32, ptr, ptr, ptr, ptr, i8, i8, i8 }
%struct.timeval = type { i64, i64 }
%struct.XML_Encoding = type { [256 x i32], ptr, ptr, ptr }
%struct.CONTENT_SCAFFOLD = type { i32, i32, ptr, i32, i32, i32, i32 }
%struct.XML_cp = type { i32, i32, ptr, i32, ptr }
%struct.siphash = type { i64, i64, i64, i64, [8 x i8], ptr, i64 }
%struct.ATTRIBUTE = type { ptr, ptr, ptr, i8 }
%struct.NS_ATT = type { i64, i64, ptr }

@.str = private unnamed_addr constant [14 x i8] c"out of memory\00", align 1
@.str.1 = private unnamed_addr constant [13 x i8] c"syntax error\00", align 1
@.str.2 = private unnamed_addr constant [17 x i8] c"no element found\00", align 1
@.str.3 = private unnamed_addr constant [32 x i8] c"not well-formed (invalid token)\00", align 1
@.str.4 = private unnamed_addr constant [15 x i8] c"unclosed token\00", align 1
@.str.5 = private unnamed_addr constant [18 x i8] c"partial character\00", align 1
@.str.6 = private unnamed_addr constant [15 x i8] c"mismatched tag\00", align 1
@.str.7 = private unnamed_addr constant [20 x i8] c"duplicate attribute\00", align 1
@.str.8 = private unnamed_addr constant [28 x i8] c"junk after document element\00", align 1
@.str.9 = private unnamed_addr constant [35 x i8] c"illegal parameter entity reference\00", align 1
@.str.10 = private unnamed_addr constant [17 x i8] c"undefined entity\00", align 1
@.str.11 = private unnamed_addr constant [27 x i8] c"recursive entity reference\00", align 1
@.str.12 = private unnamed_addr constant [20 x i8] c"asynchronous entity\00", align 1
@.str.13 = private unnamed_addr constant [38 x i8] c"reference to invalid character number\00", align 1
@.str.14 = private unnamed_addr constant [27 x i8] c"reference to binary entity\00", align 1
@.str.15 = private unnamed_addr constant [42 x i8] c"reference to external entity in attribute\00", align 1
@.str.16 = private unnamed_addr constant [47 x i8] c"XML or text declaration not at start of entity\00", align 1
@.str.17 = private unnamed_addr constant [17 x i8] c"unknown encoding\00", align 1
@.str.18 = private unnamed_addr constant [51 x i8] c"encoding specified in XML declaration is incorrect\00", align 1
@.str.19 = private unnamed_addr constant [23 x i8] c"unclosed CDATA section\00", align 1
@.str.20 = private unnamed_addr constant [46 x i8] c"error in processing external entity reference\00", align 1
@.str.21 = private unnamed_addr constant [27 x i8] c"document is not standalone\00", align 1
@.str.22 = private unnamed_addr constant [51 x i8] c"unexpected parser state - please send a bug report\00", align 1
@.str.23 = private unnamed_addr constant [36 x i8] c"entity declared in parameter entity\00", align 1
@.str.24 = private unnamed_addr constant [52 x i8] c"requested feature requires XML_DTD support in Expat\00", align 1
@.str.25 = private unnamed_addr constant [45 x i8] c"cannot change setting once parsing has begun\00", align 1
@.str.26 = private unnamed_addr constant [15 x i8] c"unbound prefix\00", align 1
@.str.27 = private unnamed_addr constant [26 x i8] c"must not undeclare prefix\00", align 1
@.str.28 = private unnamed_addr constant [38 x i8] c"incomplete markup in parameter entity\00", align 1
@.str.29 = private unnamed_addr constant [32 x i8] c"XML declaration not well-formed\00", align 1
@.str.30 = private unnamed_addr constant [33 x i8] c"text declaration not well-formed\00", align 1
@.str.31 = private unnamed_addr constant [34 x i8] c"illegal character(s) in public id\00", align 1
@.str.32 = private unnamed_addr constant [17 x i8] c"parser suspended\00", align 1
@.str.33 = private unnamed_addr constant [21 x i8] c"parser not suspended\00", align 1
@.str.34 = private unnamed_addr constant [16 x i8] c"parsing aborted\00", align 1
@.str.35 = private unnamed_addr constant [17 x i8] c"parsing finished\00", align 1
@.str.36 = private unnamed_addr constant [44 x i8] c"cannot suspend in external parameter entity\00", align 1
@.str.37 = private unnamed_addr constant [80 x i8] c"reserved prefix (xml) must not be undeclared or bound to another namespace name\00", align 1
@.str.38 = private unnamed_addr constant [59 x i8] c"reserved prefix (xmlns) must not be declared or undeclared\00", align 1
@.str.39 = private unnamed_addr constant [64 x i8] c"prefix must not be bound to one of the reserved namespace names\00", align 1
@.str.40 = private unnamed_addr constant [17 x i8] c"invalid argument\00", align 1
@.str.41 = private unnamed_addr constant [62 x i8] c"a successful prior call to function XML_GetBuffer is required\00", align 1
@.str.42 = private unnamed_addr constant [69 x i8] c"limit on input amplification factor (from DTD and entities) breached\00", align 1
@.str.43 = private unnamed_addr constant [12 x i8] c"expat_2.5.0\00", align 1
@PyExpat_XML_GetFeatureList.features = internal constant [8 x %struct.XML_Feature] [%struct.XML_Feature { i32 6, ptr @.str.44, i64 1 }, %struct.XML_Feature { i32 7, ptr @.str.45, i64 1 }, %struct.XML_Feature { i32 3, ptr @.str.46, i64 0 }, %struct.XML_Feature { i32 4, ptr @.str.47, i64 1024 }, %struct.XML_Feature { i32 8, ptr @.str.48, i64 0 }, %struct.XML_Feature { i32 11, ptr @.str.49, i64 100 }, %struct.XML_Feature { i32 12, ptr @.str.50, i64 8388608 }, %struct.XML_Feature zeroinitializer], align 16
@.str.44 = private unnamed_addr constant [17 x i8] c"sizeof(XML_Char)\00", align 1
@.str.45 = private unnamed_addr constant [18 x i8] c"sizeof(XML_LChar)\00", align 1
@.str.46 = private unnamed_addr constant [8 x i8] c"XML_DTD\00", align 1
@.str.47 = private unnamed_addr constant [18 x i8] c"XML_CONTEXT_BYTES\00", align 1
@.str.48 = private unnamed_addr constant [7 x i8] c"XML_NS\00", align 1
@.str.49 = private unnamed_addr constant [17 x i8] c"XML_BLAP_MAX_AMP\00", align 1
@.str.50 = private unnamed_addr constant [19 x i8] c"XML_BLAP_ACT_THRES\00", align 1
@.str.51 = private unnamed_addr constant [3 x i8] c"\\0\00", align 1
@.str.52 = private unnamed_addr constant [4 x i8] c"\\x1\00", align 1
@.str.53 = private unnamed_addr constant [4 x i8] c"\\x2\00", align 1
@.str.54 = private unnamed_addr constant [4 x i8] c"\\x3\00", align 1
@.str.55 = private unnamed_addr constant [4 x i8] c"\\x4\00", align 1
@.str.56 = private unnamed_addr constant [4 x i8] c"\\x5\00", align 1
@.str.57 = private unnamed_addr constant [4 x i8] c"\\x6\00", align 1
@.str.58 = private unnamed_addr constant [4 x i8] c"\\x7\00", align 1
@.str.59 = private unnamed_addr constant [4 x i8] c"\\x8\00", align 1
@.str.60 = private unnamed_addr constant [3 x i8] c"\\t\00", align 1
@.str.61 = private unnamed_addr constant [3 x i8] c"\\n\00", align 1
@.str.62 = private unnamed_addr constant [4 x i8] c"\\xB\00", align 1
@.str.63 = private unnamed_addr constant [4 x i8] c"\\xC\00", align 1
@.str.64 = private unnamed_addr constant [3 x i8] c"\\r\00", align 1
@.str.65 = private unnamed_addr constant [4 x i8] c"\\xE\00", align 1
@.str.66 = private unnamed_addr constant [4 x i8] c"\\xF\00", align 1
@.str.67 = private unnamed_addr constant [5 x i8] c"\\x10\00", align 1
@.str.68 = private unnamed_addr constant [5 x i8] c"\\x11\00", align 1
@.str.69 = private unnamed_addr constant [5 x i8] c"\\x12\00", align 1
@.str.70 = private unnamed_addr constant [5 x i8] c"\\x13\00", align 1
@.str.71 = private unnamed_addr constant [5 x i8] c"\\x14\00", align 1
@.str.72 = private unnamed_addr constant [5 x i8] c"\\x15\00", align 1
@.str.73 = private unnamed_addr constant [5 x i8] c"\\x16\00", align 1
@.str.74 = private unnamed_addr constant [5 x i8] c"\\x17\00", align 1
@.str.75 = private unnamed_addr constant [5 x i8] c"\\x18\00", align 1
@.str.76 = private unnamed_addr constant [5 x i8] c"\\x19\00", align 1
@.str.77 = private unnamed_addr constant [5 x i8] c"\\x1A\00", align 1
@.str.78 = private unnamed_addr constant [5 x i8] c"\\x1B\00", align 1
@.str.79 = private unnamed_addr constant [5 x i8] c"\\x1C\00", align 1
@.str.80 = private unnamed_addr constant [5 x i8] c"\\x1D\00", align 1
@.str.81 = private unnamed_addr constant [5 x i8] c"\\x1E\00", align 1
@.str.82 = private unnamed_addr constant [5 x i8] c"\\x1F\00", align 1
@.str.83 = private unnamed_addr constant [2 x i8] c" \00", align 1
@.str.84 = private unnamed_addr constant [2 x i8] c"!\00", align 1
@.str.85 = private unnamed_addr constant [3 x i8] c"\\\22\00", align 1
@.str.86 = private constant [2 x i8] c"#\00", align 1
@.str.87 = private unnamed_addr constant [2 x i8] c"$\00", align 1
@.str.88 = private unnamed_addr constant [2 x i8] c"%\00", align 1
@.str.89 = private unnamed_addr constant [2 x i8] c"&\00", align 1
@.str.90 = private unnamed_addr constant [2 x i8] c"'\00", align 1
@.str.92 = private unnamed_addr constant [2 x i8] c")\00", align 1
@.str.93 = private unnamed_addr constant [2 x i8] c"*\00", align 1
@.str.94 = private unnamed_addr constant [2 x i8] c"+\00", align 1
@.str.95 = private unnamed_addr constant [2 x i8] c",\00", align 1
@.str.96 = private unnamed_addr constant [2 x i8] c"-\00", align 1
@.str.97 = private unnamed_addr constant [2 x i8] c".\00", align 1
@.str.98 = private unnamed_addr constant [2 x i8] c"/\00", align 1
@.str.99 = private unnamed_addr constant [2 x i8] c"0\00", align 1
@.str.100 = private unnamed_addr constant [2 x i8] c"1\00", align 1
@.str.101 = private unnamed_addr constant [2 x i8] c"2\00", align 1
@.str.102 = private unnamed_addr constant [2 x i8] c"3\00", align 1
@.str.103 = private unnamed_addr constant [2 x i8] c"4\00", align 1
@.str.104 = private unnamed_addr constant [2 x i8] c"5\00", align 1
@.str.105 = private unnamed_addr constant [2 x i8] c"6\00", align 1
@.str.106 = private unnamed_addr constant [2 x i8] c"7\00", align 1
@.str.107 = private unnamed_addr constant [2 x i8] c"8\00", align 1
@.str.108 = private unnamed_addr constant [2 x i8] c"9\00", align 1
@.str.109 = private unnamed_addr constant [2 x i8] c":\00", align 1
@.str.110 = private unnamed_addr constant [2 x i8] c";\00", align 1
@.str.111 = private unnamed_addr constant [2 x i8] c"<\00", align 1
@.str.112 = private unnamed_addr constant [2 x i8] c"=\00", align 1
@.str.113 = private unnamed_addr constant [2 x i8] c">\00", align 1
@.str.114 = private unnamed_addr constant [2 x i8] c"?\00", align 1
@.str.115 = private unnamed_addr constant [2 x i8] c"@\00", align 1
@.str.116 = private unnamed_addr constant [2 x i8] c"A\00", align 1
@.str.117 = private unnamed_addr constant [2 x i8] c"B\00", align 1
@.str.118 = private unnamed_addr constant [2 x i8] c"C\00", align 1
@.str.119 = private unnamed_addr constant [2 x i8] c"D\00", align 1
@.str.120 = private unnamed_addr constant [2 x i8] c"E\00", align 1
@.str.121 = private unnamed_addr constant [2 x i8] c"F\00", align 1
@.str.122 = private unnamed_addr constant [2 x i8] c"G\00", align 1
@.str.123 = private unnamed_addr constant [2 x i8] c"H\00", align 1
@.str.124 = private unnamed_addr constant [2 x i8] c"I\00", align 1
@.str.125 = private unnamed_addr constant [2 x i8] c"J\00", align 1
@.str.126 = private unnamed_addr constant [2 x i8] c"K\00", align 1
@.str.127 = private unnamed_addr constant [2 x i8] c"L\00", align 1
@.str.128 = private unnamed_addr constant [2 x i8] c"M\00", align 1
@.str.129 = private unnamed_addr constant [2 x i8] c"N\00", align 1
@.str.130 = private unnamed_addr constant [2 x i8] c"O\00", align 1
@.str.131 = private unnamed_addr constant [2 x i8] c"P\00", align 1
@.str.132 = private unnamed_addr constant [2 x i8] c"Q\00", align 1
@.str.133 = private unnamed_addr constant [2 x i8] c"R\00", align 1
@.str.134 = private unnamed_addr constant [2 x i8] c"S\00", align 1
@.str.135 = private unnamed_addr constant [2 x i8] c"T\00", align 1
@.str.136 = private unnamed_addr constant [2 x i8] c"U\00", align 1
@.str.137 = private unnamed_addr constant [2 x i8] c"V\00", align 1
@.str.138 = private unnamed_addr constant [2 x i8] c"W\00", align 1
@.str.139 = private unnamed_addr constant [2 x i8] c"X\00", align 1
@.str.140 = private unnamed_addr constant [2 x i8] c"Y\00", align 1
@.str.141 = private unnamed_addr constant [2 x i8] c"Z\00", align 1
@.str.142 = private unnamed_addr constant [2 x i8] c"[\00", align 1
@.str.143 = private unnamed_addr constant [3 x i8] c"\\\\\00", align 1
@.str.144 = private unnamed_addr constant [2 x i8] c"]\00", align 1
@.str.145 = private unnamed_addr constant [2 x i8] c"^\00", align 1
@.str.146 = private unnamed_addr constant [2 x i8] c"_\00", align 1
@.str.147 = private unnamed_addr constant [2 x i8] c"`\00", align 1
@.str.148 = private unnamed_addr constant [2 x i8] c"a\00", align 1
@.str.149 = private unnamed_addr constant [2 x i8] c"b\00", align 1
@.str.150 = private unnamed_addr constant [2 x i8] c"c\00", align 1
@.str.151 = private unnamed_addr constant [2 x i8] c"d\00", align 1
@.str.152 = private unnamed_addr constant [2 x i8] c"e\00", align 1
@.str.153 = private unnamed_addr constant [2 x i8] c"f\00", align 1
@.str.154 = private unnamed_addr constant [2 x i8] c"g\00", align 1
@.str.155 = private unnamed_addr constant [2 x i8] c"h\00", align 1
@.str.156 = private unnamed_addr constant [2 x i8] c"i\00", align 1
@.str.157 = private unnamed_addr constant [2 x i8] c"j\00", align 1
@.str.158 = private unnamed_addr constant [2 x i8] c"k\00", align 1
@.str.159 = private unnamed_addr constant [2 x i8] c"l\00", align 1
@.str.160 = private unnamed_addr constant [2 x i8] c"m\00", align 1
@.str.161 = private unnamed_addr constant [2 x i8] c"n\00", align 1
@.str.162 = private unnamed_addr constant [2 x i8] c"o\00", align 1
@.str.163 = private unnamed_addr constant [2 x i8] c"p\00", align 1
@.str.164 = private unnamed_addr constant [2 x i8] c"q\00", align 1
@.str.165 = private unnamed_addr constant [2 x i8] c"r\00", align 1
@.str.166 = private unnamed_addr constant [2 x i8] c"s\00", align 1
@.str.167 = private unnamed_addr constant [2 x i8] c"t\00", align 1
@.str.168 = private unnamed_addr constant [2 x i8] c"u\00", align 1
@.str.169 = private unnamed_addr constant [2 x i8] c"v\00", align 1
@.str.170 = private unnamed_addr constant [2 x i8] c"w\00", align 1
@.str.171 = private unnamed_addr constant [2 x i8] c"x\00", align 1
@.str.172 = private unnamed_addr constant [2 x i8] c"y\00", align 1
@.str.173 = private unnamed_addr constant [2 x i8] c"z\00", align 1
@.str.174 = private unnamed_addr constant [2 x i8] c"{\00", align 1
@.str.176 = private unnamed_addr constant [2 x i8] c"}\00", align 1
@.str.177 = private unnamed_addr constant [2 x i8] c"~\00", align 1
@.str.178 = private unnamed_addr constant [5 x i8] c"\\x7F\00", align 1
@.str.179 = private unnamed_addr constant [5 x i8] c"\\x80\00", align 1
@.str.180 = private unnamed_addr constant [5 x i8] c"\\x81\00", align 1
@.str.181 = private unnamed_addr constant [5 x i8] c"\\x82\00", align 1
@.str.182 = private unnamed_addr constant [5 x i8] c"\\x83\00", align 1
@.str.183 = private unnamed_addr constant [5 x i8] c"\\x84\00", align 1
@.str.184 = private unnamed_addr constant [5 x i8] c"\\x85\00", align 1
@.str.185 = private unnamed_addr constant [5 x i8] c"\\x86\00", align 1
@.str.186 = private unnamed_addr constant [5 x i8] c"\\x87\00", align 1
@.str.187 = private unnamed_addr constant [5 x i8] c"\\x88\00", align 1
@.str.188 = private unnamed_addr constant [5 x i8] c"\\x89\00", align 1
@.str.189 = private unnamed_addr constant [5 x i8] c"\\x8A\00", align 1
@.str.190 = private unnamed_addr constant [5 x i8] c"\\x8B\00", align 1
@.str.191 = private unnamed_addr constant [5 x i8] c"\\x8C\00", align 1
@.str.192 = private unnamed_addr constant [5 x i8] c"\\x8D\00", align 1
@.str.193 = private unnamed_addr constant [5 x i8] c"\\x8E\00", align 1
@.str.194 = private unnamed_addr constant [5 x i8] c"\\x8F\00", align 1
@.str.195 = private unnamed_addr constant [5 x i8] c"\\x90\00", align 1
@.str.196 = private unnamed_addr constant [5 x i8] c"\\x91\00", align 1
@.str.197 = private unnamed_addr constant [5 x i8] c"\\x92\00", align 1
@.str.198 = private unnamed_addr constant [5 x i8] c"\\x93\00", align 1
@.str.199 = private unnamed_addr constant [5 x i8] c"\\x94\00", align 1
@.str.200 = private unnamed_addr constant [5 x i8] c"\\x95\00", align 1
@.str.201 = private unnamed_addr constant [5 x i8] c"\\x96\00", align 1
@.str.202 = private unnamed_addr constant [5 x i8] c"\\x97\00", align 1
@.str.203 = private unnamed_addr constant [5 x i8] c"\\x98\00", align 1
@.str.204 = private unnamed_addr constant [5 x i8] c"\\x99\00", align 1
@.str.205 = private unnamed_addr constant [5 x i8] c"\\x9A\00", align 1
@.str.206 = private unnamed_addr constant [5 x i8] c"\\x9B\00", align 1
@.str.207 = private unnamed_addr constant [5 x i8] c"\\x9C\00", align 1
@.str.208 = private unnamed_addr constant [5 x i8] c"\\x9D\00", align 1
@.str.209 = private unnamed_addr constant [5 x i8] c"\\x9E\00", align 1
@.str.210 = private unnamed_addr constant [5 x i8] c"\\x9F\00", align 1
@.str.211 = private unnamed_addr constant [5 x i8] c"\\xA0\00", align 1
@.str.212 = private unnamed_addr constant [5 x i8] c"\\xA1\00", align 1
@.str.213 = private unnamed_addr constant [5 x i8] c"\\xA2\00", align 1
@.str.214 = private unnamed_addr constant [5 x i8] c"\\xA3\00", align 1
@.str.215 = private unnamed_addr constant [5 x i8] c"\\xA4\00", align 1
@.str.216 = private unnamed_addr constant [5 x i8] c"\\xA5\00", align 1
@.str.217 = private unnamed_addr constant [5 x i8] c"\\xA6\00", align 1
@.str.218 = private unnamed_addr constant [5 x i8] c"\\xA7\00", align 1
@.str.219 = private unnamed_addr constant [5 x i8] c"\\xA8\00", align 1
@.str.220 = private unnamed_addr constant [5 x i8] c"\\xA9\00", align 1
@.str.221 = private unnamed_addr constant [5 x i8] c"\\xAA\00", align 1
@.str.222 = private unnamed_addr constant [5 x i8] c"\\xAB\00", align 1
@.str.223 = private unnamed_addr constant [5 x i8] c"\\xAC\00", align 1
@.str.224 = private unnamed_addr constant [5 x i8] c"\\xAD\00", align 1
@.str.225 = private unnamed_addr constant [5 x i8] c"\\xAE\00", align 1
@.str.226 = private unnamed_addr constant [5 x i8] c"\\xAF\00", align 1
@.str.227 = private unnamed_addr constant [5 x i8] c"\\xB0\00", align 1
@.str.228 = private unnamed_addr constant [5 x i8] c"\\xB1\00", align 1
@.str.229 = private unnamed_addr constant [5 x i8] c"\\xB2\00", align 1
@.str.230 = private unnamed_addr constant [5 x i8] c"\\xB3\00", align 1
@.str.231 = private unnamed_addr constant [5 x i8] c"\\xB4\00", align 1
@.str.232 = private unnamed_addr constant [5 x i8] c"\\xB5\00", align 1
@.str.233 = private unnamed_addr constant [5 x i8] c"\\xB6\00", align 1
@.str.234 = private unnamed_addr constant [5 x i8] c"\\xB7\00", align 1
@.str.235 = private unnamed_addr constant [5 x i8] c"\\xB8\00", align 1
@.str.236 = private unnamed_addr constant [5 x i8] c"\\xB9\00", align 1
@.str.237 = private unnamed_addr constant [5 x i8] c"\\xBA\00", align 1
@.str.238 = private unnamed_addr constant [5 x i8] c"\\xBB\00", align 1
@.str.239 = private unnamed_addr constant [5 x i8] c"\\xBC\00", align 1
@.str.240 = private unnamed_addr constant [5 x i8] c"\\xBD\00", align 1
@.str.241 = private unnamed_addr constant [5 x i8] c"\\xBE\00", align 1
@.str.242 = private unnamed_addr constant [5 x i8] c"\\xBF\00", align 1
@.str.243 = private unnamed_addr constant [5 x i8] c"\\xC0\00", align 1
@.str.244 = private unnamed_addr constant [5 x i8] c"\\xC1\00", align 1
@.str.245 = private unnamed_addr constant [5 x i8] c"\\xC2\00", align 1
@.str.246 = private unnamed_addr constant [5 x i8] c"\\xC3\00", align 1
@.str.247 = private unnamed_addr constant [5 x i8] c"\\xC4\00", align 1
@.str.248 = private unnamed_addr constant [5 x i8] c"\\xC5\00", align 1
@.str.249 = private unnamed_addr constant [5 x i8] c"\\xC6\00", align 1
@.str.250 = private unnamed_addr constant [5 x i8] c"\\xC7\00", align 1
@.str.251 = private unnamed_addr constant [5 x i8] c"\\xC8\00", align 1
@.str.252 = private unnamed_addr constant [5 x i8] c"\\xC9\00", align 1
@.str.253 = private unnamed_addr constant [5 x i8] c"\\xCA\00", align 1
@.str.254 = private unnamed_addr constant [5 x i8] c"\\xCB\00", align 1
@.str.255 = private unnamed_addr constant [5 x i8] c"\\xCC\00", align 1
@.str.256 = private unnamed_addr constant [5 x i8] c"\\xCD\00", align 1
@.str.257 = private unnamed_addr constant [5 x i8] c"\\xCE\00", align 1
@.str.258 = private unnamed_addr constant [5 x i8] c"\\xCF\00", align 1
@.str.259 = private unnamed_addr constant [5 x i8] c"\\xD0\00", align 1
@.str.260 = private unnamed_addr constant [5 x i8] c"\\xD1\00", align 1
@.str.261 = private unnamed_addr constant [5 x i8] c"\\xD2\00", align 1
@.str.262 = private unnamed_addr constant [5 x i8] c"\\xD3\00", align 1
@.str.263 = private unnamed_addr constant [5 x i8] c"\\xD4\00", align 1
@.str.264 = private unnamed_addr constant [5 x i8] c"\\xD5\00", align 1
@.str.265 = private unnamed_addr constant [5 x i8] c"\\xD6\00", align 1
@.str.266 = private unnamed_addr constant [5 x i8] c"\\xD7\00", align 1
@.str.267 = private unnamed_addr constant [5 x i8] c"\\xD8\00", align 1
@.str.268 = private unnamed_addr constant [5 x i8] c"\\xD9\00", align 1
@.str.269 = private unnamed_addr constant [5 x i8] c"\\xDA\00", align 1
@.str.270 = private unnamed_addr constant [5 x i8] c"\\xDB\00", align 1
@.str.271 = private unnamed_addr constant [5 x i8] c"\\xDC\00", align 1
@.str.272 = private unnamed_addr constant [5 x i8] c"\\xDD\00", align 1
@.str.273 = private unnamed_addr constant [5 x i8] c"\\xDE\00", align 1
@.str.274 = private unnamed_addr constant [5 x i8] c"\\xDF\00", align 1
@.str.275 = private unnamed_addr constant [5 x i8] c"\\xE0\00", align 1
@.str.276 = private unnamed_addr constant [5 x i8] c"\\xE1\00", align 1
@.str.277 = private unnamed_addr constant [5 x i8] c"\\xE2\00", align 1
@.str.278 = private unnamed_addr constant [5 x i8] c"\\xE3\00", align 1
@.str.279 = private unnamed_addr constant [5 x i8] c"\\xE4\00", align 1
@.str.280 = private unnamed_addr constant [5 x i8] c"\\xE5\00", align 1
@.str.281 = private unnamed_addr constant [5 x i8] c"\\xE6\00", align 1
@.str.282 = private unnamed_addr constant [5 x i8] c"\\xE7\00", align 1
@.str.283 = private unnamed_addr constant [5 x i8] c"\\xE8\00", align 1
@.str.284 = private unnamed_addr constant [5 x i8] c"\\xE9\00", align 1
@.str.285 = private unnamed_addr constant [5 x i8] c"\\xEA\00", align 1
@.str.286 = private unnamed_addr constant [5 x i8] c"\\xEB\00", align 1
@.str.287 = private unnamed_addr constant [5 x i8] c"\\xEC\00", align 1
@.str.288 = private unnamed_addr constant [5 x i8] c"\\xED\00", align 1
@.str.289 = private unnamed_addr constant [5 x i8] c"\\xEE\00", align 1
@.str.290 = private unnamed_addr constant [5 x i8] c"\\xEF\00", align 1
@.str.291 = private unnamed_addr constant [5 x i8] c"\\xF0\00", align 1
@.str.292 = private unnamed_addr constant [5 x i8] c"\\xF1\00", align 1
@.str.293 = private unnamed_addr constant [5 x i8] c"\\xF2\00", align 1
@.str.294 = private unnamed_addr constant [5 x i8] c"\\xF3\00", align 1
@.str.295 = private unnamed_addr constant [5 x i8] c"\\xF4\00", align 1
@.str.296 = private unnamed_addr constant [5 x i8] c"\\xF5\00", align 1
@.str.297 = private unnamed_addr constant [5 x i8] c"\\xF6\00", align 1
@.str.298 = private unnamed_addr constant [5 x i8] c"\\xF7\00", align 1
@.str.299 = private unnamed_addr constant [5 x i8] c"\\xF8\00", align 1
@.str.300 = private unnamed_addr constant [5 x i8] c"\\xF9\00", align 1
@.str.301 = private unnamed_addr constant [5 x i8] c"\\xFA\00", align 1
@.str.302 = private unnamed_addr constant [5 x i8] c"\\xFB\00", align 1
@.str.303 = private unnamed_addr constant [5 x i8] c"\\xFC\00", align 1
@.str.304 = private unnamed_addr constant [5 x i8] c"\\xFD\00", align 1
@.str.305 = private unnamed_addr constant [5 x i8] c"\\xFE\00", align 1
@.str.306 = private unnamed_addr constant [5 x i8] c"\\xFF\00", align 1
@.str.308 = private unnamed_addr constant [23 x i8] c"EXPAT_ACCOUNTING_DEBUG\00", align 1
@.str.309 = private unnamed_addr constant [19 x i8] c"EXPAT_ENTITY_DEBUG\00", align 1
@doProlog.atypeCDATA = internal constant [6 x i8] c"CDATA\00", align 1
@doProlog.atypeID = internal constant [3 x i8] c"ID\00", align 1
@doProlog.atypeIDREF = internal constant [6 x i8] c"IDREF\00", align 1
@doProlog.atypeIDREFS = internal constant [7 x i8] c"IDREFS\00", align 1
@doProlog.atypeENTITY = internal constant [7 x i8] c"ENTITY\00", align 1
@doProlog.atypeENTITIES = internal constant [9 x i8] c"ENTITIES\00", align 1
@doProlog.atypeNMTOKEN = internal constant [8 x i8] c"NMTOKEN\00", align 1
@doProlog.atypeNMTOKENS = internal constant [9 x i8] c"NMTOKENS\00", align 1
@doProlog.notationPrefix = internal unnamed_addr constant [10 x i8] c"NOTATION(\00", align 1
@doProlog.enumValueSep = internal unnamed_addr constant [2 x i8] c"|\00", align 1
@doProlog.enumValueStart = internal unnamed_addr constant [2 x i8] c"(\00", align 1
@.str.310 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@stderr = external local_unnamed_addr global ptr, align 8
@.str.311 = private unnamed_addr constant [77 x i8] c"expat: Accounting(%p): Direct %10llu, indirect %10llu, amplification %8.2f%s\00", align 1
@.str.312 = private unnamed_addr constant [41 x i8] c" (+%6ld bytes %s|%d, xmlparse.c:%d) %*s\22\00", align 1
@.str.313 = private unnamed_addr constant [4 x i8] c"DIR\00", align 1
@.str.314 = private unnamed_addr constant [4 x i8] c"EXP\00", align 1
@__const.accountingReportDiff.ellipis = private unnamed_addr constant [5 x i8] c"[..]\00", align 1
@.str.316 = private unnamed_addr constant [3 x i8] c"\22\0A\00", align 1
@.str.317 = private unnamed_addr constant [11 x i8] c" ABORTING\0A\00", align 1
@addBinding.xmlNamespace = internal unnamed_addr constant [37 x i8] c"http://www.w3.org/XML/1998/namespace\00", align 16
@addBinding.xmlnsNamespace = internal unnamed_addr constant [30 x i8] c"http://www.w3.org/2000/xmlns/\00", align 16
@.str.319 = private unnamed_addr constant [6 x i8] c"OPEN \00", align 1
@.str.320 = private unnamed_addr constant [85 x i8] c"expat: Entities(%p): Count %9d, depth %2d/%2d %*s%s%s; %s length %d (xmlparse.c:%d)\0A\00", align 1
@.str.321 = private unnamed_addr constant [6 x i8] c"CLOSE\00", align 1
@implicitContext = internal constant [41 x i8] c"xml=http://www.w3.org/XML/1998/namespace\00", align 16
@.str.322 = private unnamed_addr constant [10 x i8] c"getrandom\00", align 1
@.str.323 = private unnamed_addr constant [12 x i8] c"fallback(8)\00", align 1
@.str.324 = private unnamed_addr constant [20 x i8] c"EXPAT_ENTROPY_DEBUG\00", align 1
@.str.325 = private unnamed_addr constant [44 x i8] c"expat: Entropy: %s --> 0x%0*lx (%lu bytes)\0A\00", align 1
@switch.table.PyExpat_XML_ErrorString = private unnamed_addr constant [43 x ptr] [ptr @.str, ptr @.str.1, ptr @.str.2, ptr @.str.3, ptr @.str.4, ptr @.str.5, ptr @.str.6, ptr @.str.7, ptr @.str.8, ptr @.str.9, ptr @.str.10, ptr @.str.11, ptr @.str.12, ptr @.str.13, ptr @.str.14, ptr @.str.15, ptr @.str.16, ptr @.str.17, ptr @.str.18, ptr @.str.19, ptr @.str.20, ptr @.str.21, ptr @.str.22, ptr @.str.23, ptr @.str.24, ptr @.str.25, ptr @.str.26, ptr @.str.27, ptr @.str.28, ptr @.str.29, ptr @.str.30, ptr @.str.31, ptr @.str.32, ptr @.str.33, ptr @.str.34, ptr @.str.35, ptr @.str.36, ptr @.str.37, ptr @.str.38, ptr @.str.39, ptr @.str.40, ptr @.str.41, ptr @.str.42], align 8
@switch.table.PyExpat_unsignedCharToPrintable = private unnamed_addr constant [256 x ptr] [ptr @.str.179, ptr @.str.180, ptr @.str.181, ptr @.str.182, ptr @.str.183, ptr @.str.184, ptr @.str.185, ptr @.str.186, ptr @.str.187, ptr @.str.188, ptr @.str.189, ptr @.str.190, ptr @.str.191, ptr @.str.192, ptr @.str.193, ptr @.str.194, ptr @.str.195, ptr @.str.196, ptr @.str.197, ptr @.str.198, ptr @.str.199, ptr @.str.200, ptr @.str.201, ptr @.str.202, ptr @.str.203, ptr @.str.204, ptr @.str.205, ptr @.str.206, ptr @.str.207, ptr @.str.208, ptr @.str.209, ptr @.str.210, ptr @.str.211, ptr @.str.212, ptr @.str.213, ptr @.str.214, ptr @.str.215, ptr @.str.216, ptr @.str.217, ptr @.str.218, ptr @.str.219, ptr @.str.220, ptr @.str.221, ptr @.str.222, ptr @.str.223, ptr @.str.224, ptr @.str.225, ptr @.str.226, ptr @.str.227, ptr @.str.228, ptr @.str.229, ptr @.str.230, ptr @.str.231, ptr @.str.232, ptr @.str.233, ptr @.str.234, ptr @.str.235, ptr @.str.236, ptr @.str.237, ptr @.str.238, ptr @.str.239, ptr @.str.240, ptr @.str.241, ptr @.str.242, ptr @.str.243, ptr @.str.244, ptr @.str.245, ptr @.str.246, ptr @.str.247, ptr @.str.248, ptr @.str.249, ptr @.str.250, ptr @.str.251, ptr @.str.252, ptr @.str.253, ptr @.str.254, ptr @.str.255, ptr @.str.256, ptr @.str.257, ptr @.str.258, ptr @.str.259, ptr @.str.260, ptr @.str.261, ptr @.str.262, ptr @.str.263, ptr @.str.264, ptr @.str.265, ptr @.str.266, ptr @.str.267, ptr @.str.268, ptr @.str.269, ptr @.str.270, ptr @.str.271, ptr @.str.272, ptr @.str.273, ptr @.str.274, ptr @.str.275, ptr @.str.276, ptr @.str.277, ptr @.str.278, ptr @.str.279, ptr @.str.280, ptr @.str.281, ptr @.str.282, ptr @.str.283, ptr @.str.284, ptr @.str.285, ptr @.str.286, ptr @.str.287, ptr @.str.288, ptr @.str.289, ptr @.str.290, ptr @.str.291, ptr @.str.292, ptr @.str.293, ptr @.str.294, ptr @.str.295, ptr @.str.296, ptr @.str.297, ptr @.str.298, ptr @.str.299, ptr @.str.300, ptr @.str.301, ptr @.str.302, ptr @.str.303, ptr @.str.304, ptr @.str.305, ptr @.str.306, ptr @.str.51, ptr @.str.52, ptr @.str.53, ptr @.str.54, ptr @.str.55, ptr @.str.56, ptr @.str.57, ptr @.str.58, ptr @.str.59, ptr @.str.60, ptr @.str.61, ptr @.str.62, ptr @.str.63, ptr @.str.64, ptr @.str.65, ptr @.str.66, ptr @.str.67, ptr @.str.68, ptr @.str.69, ptr @.str.70, ptr @.str.71, ptr @.str.72, ptr @.str.73, ptr @.str.74, ptr @.str.75, ptr @.str.76, ptr @.str.77, ptr @.str.78, ptr @.str.79, ptr @.str.80, ptr @.str.81, ptr @.str.82, ptr @.str.83, ptr @.str.84, ptr @.str.85, ptr @.str.86, ptr @.str.87, ptr @.str.88, ptr @.str.89, ptr @.str.90, ptr @doProlog.enumValueStart, ptr @.str.92, ptr @.str.93, ptr @.str.94, ptr @.str.95, ptr @.str.96, ptr @.str.97, ptr @.str.98, ptr @.str.99, ptr @.str.100, ptr @.str.101, ptr @.str.102, ptr @.str.103, ptr @.str.104, ptr @.str.105, ptr @.str.106, ptr @.str.107, ptr @.str.108, ptr @.str.109, ptr @.str.110, ptr @.str.111, ptr @.str.112, ptr @.str.113, ptr @.str.114, ptr @.str.115, ptr @.str.116, ptr @.str.117, ptr @.str.118, ptr @.str.119, ptr @.str.120, ptr @.str.121, ptr @.str.122, ptr @.str.123, ptr @.str.124, ptr @.str.125, ptr @.str.126, ptr @.str.127, ptr @.str.128, ptr @.str.129, ptr @.str.130, ptr @.str.131, ptr @.str.132, ptr @.str.133, ptr @.str.134, ptr @.str.135, ptr @.str.136, ptr @.str.137, ptr @.str.138, ptr @.str.139, ptr @.str.140, ptr @.str.141, ptr @.str.142, ptr @.str.143, ptr @.str.144, ptr @.str.145, ptr @.str.146, ptr @.str.147, ptr @.str.148, ptr @.str.149, ptr @.str.150, ptr @.str.151, ptr @.str.152, ptr @.str.153, ptr @.str.154, ptr @.str.155, ptr @.str.156, ptr @.str.157, ptr @.str.158, ptr @.str.159, ptr @.str.160, ptr @.str.161, ptr @.str.162, ptr @.str.163, ptr @.str.164, ptr @.str.165, ptr @.str.166, ptr @.str.167, ptr @.str.168, ptr @.str.169, ptr @.str.170, ptr @.str.171, ptr @.str.172, ptr @.str.173, ptr @.str.174, ptr @doProlog.enumValueSep, ptr @.str.176, ptr @.str.177, ptr @.str.178], align 8

; Function Attrs: nounwind uwtable
define hidden ptr @PyExpat_XML_ParserCreate(ptr noundef %encodingName) local_unnamed_addr #0 {
entry:
  %call.i = tail call fastcc ptr @parserCreate(ptr noundef %encodingName, ptr noundef null, ptr noundef null, ptr noundef null)
  ret ptr %call.i
}

; Function Attrs: nounwind uwtable
define hidden ptr @PyExpat_XML_ParserCreate_MM(ptr noundef %encodingName, ptr noundef %memsuite, ptr noundef %nameSep) local_unnamed_addr #0 {
entry:
  %call = tail call fastcc ptr @parserCreate(ptr noundef %encodingName, ptr noundef %memsuite, ptr noundef %nameSep, ptr noundef null)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define hidden ptr @PyExpat_XML_ParserCreateNS(ptr noundef %encodingName, i8 noundef signext %nsSep) local_unnamed_addr #0 {
entry:
  %tmp = alloca [2 x i8], align 1
  store i8 %nsSep, ptr %tmp, align 1
  %arrayinit.element = getelementptr inbounds i8, ptr %tmp, i64 1
  store i8 0, ptr %arrayinit.element, align 1
  %call.i = call fastcc ptr @parserCreate(ptr noundef %encodingName, ptr noundef null, ptr noundef nonnull %tmp, ptr noundef null)
  ret ptr %call.i
}

; Function Attrs: nounwind uwtable
define internal fastcc ptr @parserCreate(ptr noundef %encodingName, ptr noundef readonly %memsuite, ptr noundef readonly %nameSep, ptr noundef %dtd) unnamed_addr #0 {
entry:
  %tobool.not = icmp eq ptr %memsuite, null
  br i1 %tobool.not, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %0 = load ptr, ptr %memsuite, align 8
  %call = tail call ptr %0(i64 noundef 976) #24
  %cmp.not = icmp eq ptr %call, null
  br i1 %cmp.not, label %return, label %if.then1

if.then1:                                         ; preds = %if.then
  %m_mem = getelementptr inbounds %struct.XML_ParserStruct, ptr %call, i64 0, i32 3
  %1 = load ptr, ptr %memsuite, align 8
  store ptr %1, ptr %m_mem, align 8
  %realloc_fcn = getelementptr inbounds %struct.XML_Memory_Handling_Suite, ptr %memsuite, i64 0, i32 1
  %2 = load ptr, ptr %realloc_fcn, align 8
  %realloc_fcn4 = getelementptr inbounds %struct.XML_ParserStruct, ptr %call, i64 0, i32 3, i32 1
  store ptr %2, ptr %realloc_fcn4, align 8
  %free_fcn = getelementptr inbounds %struct.XML_Memory_Handling_Suite, ptr %memsuite, i64 0, i32 2
  %3 = load ptr, ptr %free_fcn, align 8
  br label %if.end18

if.else:                                          ; preds = %entry
  %call7 = tail call noalias dereferenceable_or_null(976) ptr @malloc(i64 noundef 976) #25
  %cmp8.not = icmp eq ptr %call7, null
  br i1 %cmp8.not, label %return, label %if.then9

if.then9:                                         ; preds = %if.else
  %m_mem10 = getelementptr inbounds %struct.XML_ParserStruct, ptr %call7, i64 0, i32 3
  store ptr @malloc, ptr %m_mem10, align 8
  %realloc_fcn12 = getelementptr inbounds %struct.XML_ParserStruct, ptr %call7, i64 0, i32 3, i32 1
  store ptr @realloc, ptr %realloc_fcn12, align 8
  br label %if.end18

if.end18:                                         ; preds = %if.then1, %if.then9
  %call.sink = phi ptr [ %call, %if.then1 ], [ %call7, %if.then9 ]
  %.sink = phi ptr [ %3, %if.then1 ], [ @free, %if.then9 ]
  %4 = phi ptr [ %1, %if.then1 ], [ @malloc, %if.then9 ]
  %free_fcn5 = getelementptr inbounds %struct.XML_ParserStruct, ptr %call.sink, i64 0, i32 3, i32 2
  store ptr %.sink, ptr %free_fcn5, align 8
  %m_buffer = getelementptr inbounds %struct.XML_ParserStruct, ptr %call.sink, i64 0, i32 2
  store ptr null, ptr %m_buffer, align 8
  %m_bufferLim = getelementptr inbounds %struct.XML_ParserStruct, ptr %call.sink, i64 0, i32 6
  store ptr null, ptr %m_bufferLim, align 8
  %m_attsSize = getelementptr inbounds %struct.XML_ParserStruct, ptr %call.sink, i64 0, i32 71
  store i32 16, ptr %m_attsSize, align 8
  %m_mem19 = getelementptr inbounds %struct.XML_ParserStruct, ptr %call.sink, i64 0, i32 3
  %call22 = tail call ptr %4(i64 noundef 512) #24
  %m_atts = getelementptr inbounds %struct.XML_ParserStruct, ptr %call.sink, i64 0, i32 74
  store ptr %call22, ptr %m_atts, align 8
  %cmp24 = icmp eq ptr %call22, null
  br i1 %cmp24, label %if.then26, label %if.end29

if.then26:                                        ; preds = %if.end18
  %free_fcn28 = getelementptr inbounds %struct.XML_ParserStruct, ptr %call.sink, i64 0, i32 3, i32 2
  %5 = load ptr, ptr %free_fcn28, align 8
  tail call void %5(ptr noundef nonnull %call.sink) #24
  br label %return

if.end29:                                         ; preds = %if.end18
  %6 = load ptr, ptr %m_mem19, align 8
  %call32 = tail call ptr %6(i64 noundef 1024) #24
  %m_dataBuf = getelementptr inbounds %struct.XML_ParserStruct, ptr %call.sink, i64 0, i32 9
  store ptr %call32, ptr %m_dataBuf, align 8
  %cmp34 = icmp eq ptr %call32, null
  br i1 %cmp34, label %if.then36, label %if.end42

if.then36:                                        ; preds = %if.end29
  %free_fcn38 = getelementptr inbounds %struct.XML_ParserStruct, ptr %call.sink, i64 0, i32 3, i32 2
  %7 = load ptr, ptr %free_fcn38, align 8
  %8 = load ptr, ptr %m_atts, align 8
  tail call void %7(ptr noundef %8) #24
  %9 = load ptr, ptr %free_fcn38, align 8
  tail call void %9(ptr noundef nonnull %call.sink) #24
  br label %return

if.end42:                                         ; preds = %if.end29
  %add.ptr = getelementptr i8, ptr %call32, i64 1024
  %m_dataBufEnd = getelementptr inbounds %struct.XML_ParserStruct, ptr %call.sink, i64 0, i32 10
  store ptr %add.ptr, ptr %m_dataBufEnd, align 8
  %tobool44.not = icmp eq ptr %dtd, null
  br i1 %tobool44.not, label %if.else46, label %if.end63

if.else46:                                        ; preds = %if.end42
  %10 = load ptr, ptr %m_mem19, align 8
  %call.i = tail call ptr %10(i64 noundef 360) #24
  %cmp.i = icmp eq ptr %call.i, null
  br i1 %cmp.i, label %if.then53, label %dtdCreate.exit

dtdCreate.exit:                                   ; preds = %if.else46
  %pool.i = getelementptr inbounds %struct.DTD, ptr %call.i, i64 0, i32 4
  %mem.i.i = getelementptr inbounds %struct.DTD, ptr %call.i, i64 0, i32 4, i32 5
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %pool.i, i8 0, i64 40, i1 false)
  store ptr %m_mem19, ptr %mem.i.i, align 8
  %entityValuePool.i = getelementptr inbounds %struct.DTD, ptr %call.i, i64 0, i32 5
  %mem.i30.i = getelementptr inbounds %struct.DTD, ptr %call.i, i64 0, i32 5, i32 5
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %entityValuePool.i, i8 0, i64 40, i1 false)
  store ptr %m_mem19, ptr %mem.i30.i, align 8
  %power.i.i = getelementptr inbounds %struct.HASH_TABLE, ptr %call.i, i64 0, i32 1
  store i8 0, ptr %power.i.i, align 8
  %size.i.i = getelementptr inbounds %struct.HASH_TABLE, ptr %call.i, i64 0, i32 2
  store ptr null, ptr %call.i, align 8
  %mem.i31.i = getelementptr inbounds %struct.HASH_TABLE, ptr %call.i, i64 0, i32 4
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %size.i.i, i8 0, i64 16, i1 false)
  store ptr %m_mem19, ptr %mem.i31.i, align 8
  %elementTypes.i = getelementptr inbounds %struct.DTD, ptr %call.i, i64 0, i32 1
  %power.i32.i = getelementptr inbounds %struct.DTD, ptr %call.i, i64 0, i32 1, i32 1
  store i8 0, ptr %power.i32.i, align 8
  %size.i33.i = getelementptr inbounds %struct.DTD, ptr %call.i, i64 0, i32 1, i32 2
  store ptr null, ptr %elementTypes.i, align 8
  %mem.i34.i = getelementptr inbounds %struct.DTD, ptr %call.i, i64 0, i32 1, i32 4
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %size.i33.i, i8 0, i64 16, i1 false)
  store ptr %m_mem19, ptr %mem.i34.i, align 8
  %attributeIds.i = getelementptr inbounds %struct.DTD, ptr %call.i, i64 0, i32 2
  %power.i35.i = getelementptr inbounds %struct.DTD, ptr %call.i, i64 0, i32 2, i32 1
  store i8 0, ptr %power.i35.i, align 8
  %size.i36.i = getelementptr inbounds %struct.DTD, ptr %call.i, i64 0, i32 2, i32 2
  store ptr null, ptr %attributeIds.i, align 8
  %mem.i37.i = getelementptr inbounds %struct.DTD, ptr %call.i, i64 0, i32 2, i32 4
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %size.i36.i, i8 0, i64 16, i1 false)
  store ptr %m_mem19, ptr %mem.i37.i, align 8
  %prefixes.i = getelementptr inbounds %struct.DTD, ptr %call.i, i64 0, i32 3
  %power.i38.i = getelementptr inbounds %struct.DTD, ptr %call.i, i64 0, i32 3, i32 1
  store i8 0, ptr %power.i38.i, align 8
  %size.i39.i = getelementptr inbounds %struct.DTD, ptr %call.i, i64 0, i32 3, i32 2
  store ptr null, ptr %prefixes.i, align 8
  %mem.i40.i = getelementptr inbounds %struct.DTD, ptr %call.i, i64 0, i32 3, i32 4
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %size.i39.i, i8 0, i64 16, i1 false)
  store ptr %m_mem19, ptr %mem.i40.i, align 8
  %paramEntities.i = getelementptr inbounds %struct.DTD, ptr %call.i, i64 0, i32 10
  %power.i41.i = getelementptr inbounds %struct.DTD, ptr %call.i, i64 0, i32 10, i32 1
  store i8 0, ptr %power.i41.i, align 8
  %size.i42.i = getelementptr inbounds %struct.DTD, ptr %call.i, i64 0, i32 10, i32 2
  store ptr null, ptr %paramEntities.i, align 8
  %mem.i43.i = getelementptr inbounds %struct.DTD, ptr %call.i, i64 0, i32 10, i32 4
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %size.i42.i, i8 0, i64 16, i1 false)
  store ptr %m_mem19, ptr %mem.i43.i, align 8
  %defaultPrefix.i = getelementptr inbounds %struct.DTD, ptr %call.i, i64 0, i32 11
  %scaffold.i = getelementptr inbounds %struct.DTD, ptr %call.i, i64 0, i32 13
  %keepProcessing.i = getelementptr inbounds %struct.DTD, ptr %call.i, i64 0, i32 6
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(17) %defaultPrefix.i, i8 0, i64 17, i1 false)
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %scaffold.i, i8 0, i64 32, i1 false)
  store <4 x i8> <i8 1, i8 0, i8 0, i8 0>, ptr %keepProcessing.i, align 8
  br label %if.end63

if.then53:                                        ; preds = %if.else46
  %m_dtd4976 = getelementptr inbounds %struct.XML_ParserStruct, ptr %call.sink, i64 0, i32 65
  store ptr null, ptr %m_dtd4976, align 8
  %free_fcn55 = getelementptr inbounds %struct.XML_ParserStruct, ptr %call.sink, i64 0, i32 3, i32 2
  %11 = load ptr, ptr %free_fcn55, align 8
  %12 = load ptr, ptr %m_dataBuf, align 8
  tail call void %11(ptr noundef %12) #24
  %13 = load ptr, ptr %free_fcn55, align 8
  %14 = load ptr, ptr %m_atts, align 8
  tail call void %13(ptr noundef %14) #24
  %15 = load ptr, ptr %free_fcn55, align 8
  tail call void %15(ptr noundef nonnull %call.sink) #24
  br label %return

if.end63:                                         ; preds = %if.end42, %dtdCreate.exit
  %call.i.sink = phi ptr [ %call.i, %dtdCreate.exit ], [ %dtd, %if.end42 ]
  %m_dtd49 = getelementptr inbounds %struct.XML_ParserStruct, ptr %call.sink, i64 0, i32 65
  store ptr %call.i.sink, ptr %m_dtd49, align 8
  %m_freeBindingList = getelementptr inbounds %struct.XML_ParserStruct, ptr %call.sink, i64 0, i32 70
  store ptr null, ptr %m_freeBindingList, align 8
  %m_freeTagList = getelementptr inbounds %struct.XML_ParserStruct, ptr %call.sink, i64 0, i32 68
  store ptr null, ptr %m_freeTagList, align 8
  %m_freeInternalEntities = getelementptr inbounds %struct.XML_ParserStruct, ptr %call.sink, i64 0, i32 51
  store ptr null, ptr %m_freeInternalEntities, align 8
  %m_groupSize = getelementptr inbounds %struct.XML_ParserStruct, ptr %call.sink, i64 0, i32 82
  store i32 0, ptr %m_groupSize, align 8
  %m_groupConnector = getelementptr inbounds %struct.XML_ParserStruct, ptr %call.sink, i64 0, i32 81
  store ptr null, ptr %m_groupConnector, align 8
  %m_unknownEncodingHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %call.sink, i64 0, i32 29
  store ptr null, ptr %m_unknownEncodingHandler, align 8
  %m_unknownEncodingHandlerData = getelementptr inbounds %struct.XML_ParserStruct, ptr %call.sink, i64 0, i32 42
  store ptr null, ptr %m_unknownEncodingHandlerData, align 8
  %m_namespaceSeparator = getelementptr inbounds %struct.XML_ParserStruct, ptr %call.sink, i64 0, i32 83
  store i8 33, ptr %m_namespaceSeparator, align 4
  %m_ns = getelementptr inbounds %struct.XML_ParserStruct, ptr %call.sink, i64 0, i32 38
  store i8 0, ptr %m_ns, align 8
  %m_ns_triplets = getelementptr inbounds %struct.XML_ParserStruct, ptr %call.sink, i64 0, i32 39
  store i8 0, ptr %m_ns_triplets, align 1
  %m_nsAtts = getelementptr inbounds %struct.XML_ParserStruct, ptr %call.sink, i64 0, i32 75
  %m_protocolEncodingName = getelementptr inbounds %struct.XML_ParserStruct, ptr %call.sink, i64 0, i32 37
  store ptr null, ptr %m_protocolEncodingName, align 8
  %m_tempPool = getelementptr inbounds %struct.XML_ParserStruct, ptr %call.sink, i64 0, i32 79
  %mem.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %call.sink, i64 0, i32 79, i32 5
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %m_tempPool, i8 0, i64 40, i1 false)
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(17) %m_nsAtts, i8 0, i64 17, i1 false)
  store ptr %m_mem19, ptr %mem.i, align 8
  %m_temp2Pool = getelementptr inbounds %struct.XML_ParserStruct, ptr %call.sink, i64 0, i32 80
  %mem.i73 = getelementptr inbounds %struct.XML_ParserStruct, ptr %call.sink, i64 0, i32 80, i32 5
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %m_temp2Pool, i8 0, i64 40, i1 false)
  store ptr %m_mem19, ptr %mem.i73, align 8
  tail call fastcc void @parserInit(ptr noundef nonnull %call.sink, ptr noundef %encodingName)
  %tobool66.not = icmp eq ptr %encodingName, null
  br i1 %tobool66.not, label %if.end74, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end63
  %16 = load ptr, ptr %m_protocolEncodingName, align 8
  %tobool68.not = icmp eq ptr %16, null
  br i1 %tobool68.not, label %if.then69, label %if.end74

if.then69:                                        ; preds = %land.lhs.true
  br i1 %tobool44.not, label %if.end73, label %if.then71

if.then71:                                        ; preds = %if.then69
  %m_dtd72 = getelementptr inbounds %struct.XML_ParserStruct, ptr %call.sink, i64 0, i32 65
  store ptr null, ptr %m_dtd72, align 8
  br label %if.end73

if.end73:                                         ; preds = %if.then71, %if.then69
  tail call void @PyExpat_XML_ParserFree(ptr noundef nonnull %call.sink)
  br label %return

if.end74:                                         ; preds = %land.lhs.true, %if.end63
  %tobool75.not = icmp eq ptr %nameSep, null
  br i1 %tobool75.not, label %if.else80, label %if.then76

if.then76:                                        ; preds = %if.end74
  store i8 1, ptr %m_ns, align 8
  %call78 = tail call ptr @PyExpat_XmlGetUtf8InternalEncodingNS() #24
  %m_internalEncoding = getelementptr inbounds %struct.XML_ParserStruct, ptr %call.sink, i64 0, i32 36
  store ptr %call78, ptr %m_internalEncoding, align 8
  %17 = load i8, ptr %nameSep, align 1
  store i8 %17, ptr %m_namespaceSeparator, align 4
  br label %return

if.else80:                                        ; preds = %if.end74
  %call81 = tail call ptr @PyExpat_XmlGetUtf8InternalEncoding() #24
  %m_internalEncoding82 = getelementptr inbounds %struct.XML_ParserStruct, ptr %call.sink, i64 0, i32 36
  store ptr %call81, ptr %m_internalEncoding82, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then, %if.then76, %if.else80, %if.end73, %if.then53, %if.then36, %if.then26
  %retval.0 = phi ptr [ null, %if.then26 ], [ null, %if.then36 ], [ null, %if.end73 ], [ null, %if.then53 ], [ %call.sink, %if.else80 ], [ %call.sink, %if.then76 ], [ null, %if.then ], [ null, %if.else ]
  ret ptr %retval.0
}

; Function Attrs: nounwind uwtable
define hidden zeroext i8 @PyExpat_XML_ParserReset(ptr noundef %parser, ptr noundef %encodingName) local_unnamed_addr #0 {
entry:
  %cmp = icmp eq ptr %parser, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %m_parentParser = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 84
  %0 = load ptr, ptr %m_parentParser, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %if.end2, label %return

if.end2:                                          ; preds = %if.end
  %m_tagStack = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 67
  %1 = load ptr, ptr %m_tagStack, align 8
  %tobool3.not53 = icmp eq ptr %1, null
  br i1 %tobool3.not53, label %while.end, label %while.body.lr.ph

while.body.lr.ph:                                 ; preds = %if.end2
  %m_freeTagList = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 68
  %m_freeBindingList.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 70
  %.pre = load ptr, ptr %m_freeTagList, align 8
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %moveToFreeBindingList.exit
  %2 = phi ptr [ %.pre, %while.body.lr.ph ], [ %tStk.054, %moveToFreeBindingList.exit ]
  %tStk.054 = phi ptr [ %1, %while.body.lr.ph ], [ %3, %moveToFreeBindingList.exit ]
  %3 = load ptr, ptr %tStk.054, align 8
  store ptr %2, ptr %tStk.054, align 8
  %bindings = getelementptr inbounds %struct.tag, ptr %tStk.054, i64 0, i32 6
  %4 = load ptr, ptr %bindings, align 8
  %tobool.not5.i = icmp eq ptr %4, null
  br i1 %tobool.not5.i, label %moveToFreeBindingList.exit, label %while.body.lr.ph.i

while.body.lr.ph.i:                               ; preds = %while.body
  %.pre.i = load ptr, ptr %m_freeBindingList.i, align 8
  br label %while.body.i

while.body.i:                                     ; preds = %while.body.i, %while.body.lr.ph.i
  %5 = phi ptr [ %.pre.i, %while.body.lr.ph.i ], [ %bindings.addr.06.i, %while.body.i ]
  %bindings.addr.06.i = phi ptr [ %4, %while.body.lr.ph.i ], [ %6, %while.body.i ]
  %nextTagBinding.i = getelementptr inbounds %struct.binding, ptr %bindings.addr.06.i, i64 0, i32 1
  %6 = load ptr, ptr %nextTagBinding.i, align 8
  store ptr %5, ptr %nextTagBinding.i, align 8
  store ptr %bindings.addr.06.i, ptr %m_freeBindingList.i, align 8
  %tobool.not.i = icmp eq ptr %6, null
  br i1 %tobool.not.i, label %moveToFreeBindingList.exit, label %while.body.i, !llvm.loop !4

moveToFreeBindingList.exit:                       ; preds = %while.body.i, %while.body
  store ptr null, ptr %bindings, align 8
  store ptr %tStk.054, ptr %m_freeTagList, align 8
  %tobool3.not = icmp eq ptr %3, null
  br i1 %tobool3.not, label %while.end, label %while.body, !llvm.loop !6

while.end:                                        ; preds = %moveToFreeBindingList.exit, %if.end2
  %m_openInternalEntities = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 50
  %7 = load ptr, ptr %m_openInternalEntities, align 8
  %tobool8.not55 = icmp eq ptr %7, null
  br i1 %tobool8.not55, label %while.end12, label %while.body9.lr.ph

while.body9.lr.ph:                                ; preds = %while.end
  %m_freeInternalEntities = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 51
  %.pre57 = load ptr, ptr %m_freeInternalEntities, align 8
  br label %while.body9

while.body9:                                      ; preds = %while.body9.lr.ph, %while.body9
  %8 = phi ptr [ %.pre57, %while.body9.lr.ph ], [ %openEntityList.056, %while.body9 ]
  %openEntityList.056 = phi ptr [ %7, %while.body9.lr.ph ], [ %9, %while.body9 ]
  %next = getelementptr inbounds %struct.open_internal_entity, ptr %openEntityList.056, i64 0, i32 2
  %9 = load ptr, ptr %next, align 8
  store ptr %8, ptr %next, align 8
  store ptr %openEntityList.056, ptr %m_freeInternalEntities, align 8
  %tobool8.not = icmp eq ptr %9, null
  br i1 %tobool8.not, label %while.end12, label %while.body9, !llvm.loop !7

while.end12:                                      ; preds = %while.body9, %while.end
  %m_inheritedBindings = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 69
  %10 = load ptr, ptr %m_inheritedBindings, align 8
  %tobool.not5.i32 = icmp eq ptr %10, null
  br i1 %tobool.not5.i32, label %moveToFreeBindingList.exit40, label %while.body.lr.ph.i33

while.body.lr.ph.i33:                             ; preds = %while.end12
  %m_freeBindingList.i34 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 70
  %.pre.i35 = load ptr, ptr %m_freeBindingList.i34, align 8
  br label %while.body.i36

while.body.i36:                                   ; preds = %while.body.i36, %while.body.lr.ph.i33
  %11 = phi ptr [ %.pre.i35, %while.body.lr.ph.i33 ], [ %bindings.addr.06.i37, %while.body.i36 ]
  %bindings.addr.06.i37 = phi ptr [ %10, %while.body.lr.ph.i33 ], [ %12, %while.body.i36 ]
  %nextTagBinding.i38 = getelementptr inbounds %struct.binding, ptr %bindings.addr.06.i37, i64 0, i32 1
  %12 = load ptr, ptr %nextTagBinding.i38, align 8
  store ptr %11, ptr %nextTagBinding.i38, align 8
  store ptr %bindings.addr.06.i37, ptr %m_freeBindingList.i34, align 8
  %tobool.not.i39 = icmp eq ptr %12, null
  br i1 %tobool.not.i39, label %moveToFreeBindingList.exit40, label %while.body.i36, !llvm.loop !4

moveToFreeBindingList.exit40:                     ; preds = %while.body.i36, %while.end12
  %free_fcn = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 3, i32 2
  %13 = load ptr, ptr %free_fcn, align 8
  %m_unknownEncodingMem = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 40
  %14 = load ptr, ptr %m_unknownEncodingMem, align 8
  tail call void %13(ptr noundef %14) #24
  %m_unknownEncodingRelease = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 43
  %15 = load ptr, ptr %m_unknownEncodingRelease, align 8
  %tobool13.not = icmp eq ptr %15, null
  br i1 %tobool13.not, label %if.end16, label %if.then14

if.then14:                                        ; preds = %moveToFreeBindingList.exit40
  %m_unknownEncodingData = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 41
  %16 = load ptr, ptr %m_unknownEncodingData, align 8
  tail call void %15(ptr noundef %16) #24
  br label %if.end16

if.end16:                                         ; preds = %if.then14, %moveToFreeBindingList.exit40
  %m_tempPool = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 79
  %freeBlocks.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 79, i32 1
  %17 = load ptr, ptr %freeBlocks.i, align 8
  %tobool.not.i41 = icmp eq ptr %17, null
  %18 = load ptr, ptr %m_tempPool, align 8
  br i1 %tobool.not.i41, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %if.end16
  store ptr %18, ptr %freeBlocks.i, align 8
  br label %poolClear.exit

if.else.i:                                        ; preds = %if.end16
  %tobool3.not13.i = icmp eq ptr %18, null
  br i1 %tobool3.not13.i, label %poolClear.exit, label %while.body.i42

while.body.i42:                                   ; preds = %if.else.i, %while.body.i42
  %19 = phi ptr [ %p.014.i, %while.body.i42 ], [ %17, %if.else.i ]
  %p.014.i = phi ptr [ %20, %while.body.i42 ], [ %18, %if.else.i ]
  %20 = load ptr, ptr %p.014.i, align 8
  store ptr %19, ptr %p.014.i, align 8
  store ptr %p.014.i, ptr %freeBlocks.i, align 8
  %tobool3.not.i = icmp eq ptr %20, null
  br i1 %tobool3.not.i, label %poolClear.exit, label %while.body.i42, !llvm.loop !8

poolClear.exit:                                   ; preds = %while.body.i42, %if.then.i, %if.else.i
  store ptr null, ptr %m_tempPool, align 8
  %end.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 79, i32 2
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %end.i, i8 0, i64 24, i1 false)
  %m_temp2Pool = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 80
  %freeBlocks.i43 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 80, i32 1
  %21 = load ptr, ptr %freeBlocks.i43, align 8
  %tobool.not.i44 = icmp eq ptr %21, null
  %22 = load ptr, ptr %m_temp2Pool, align 8
  br i1 %tobool.not.i44, label %if.then.i51, label %if.else.i45

if.then.i51:                                      ; preds = %poolClear.exit
  store ptr %22, ptr %freeBlocks.i43, align 8
  br label %poolClear.exit52

if.else.i45:                                      ; preds = %poolClear.exit
  %tobool3.not13.i46 = icmp eq ptr %22, null
  br i1 %tobool3.not13.i46, label %poolClear.exit52, label %while.body.i47

while.body.i47:                                   ; preds = %if.else.i45, %while.body.i47
  %23 = phi ptr [ %p.014.i48, %while.body.i47 ], [ %21, %if.else.i45 ]
  %p.014.i48 = phi ptr [ %24, %while.body.i47 ], [ %22, %if.else.i45 ]
  %24 = load ptr, ptr %p.014.i48, align 8
  store ptr %23, ptr %p.014.i48, align 8
  store ptr %p.014.i48, ptr %freeBlocks.i43, align 8
  %tobool3.not.i49 = icmp eq ptr %24, null
  br i1 %tobool3.not.i49, label %poolClear.exit52, label %while.body.i47, !llvm.loop !8

poolClear.exit52:                                 ; preds = %while.body.i47, %if.then.i51, %if.else.i45
  store ptr null, ptr %m_temp2Pool, align 8
  %end.i50 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 80, i32 2
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %end.i50, i8 0, i64 24, i1 false)
  %25 = load ptr, ptr %free_fcn, align 8
  %m_protocolEncodingName = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 37
  %26 = load ptr, ptr %m_protocolEncodingName, align 8
  tail call void %25(ptr noundef %26) #24
  store ptr null, ptr %m_protocolEncodingName, align 8
  tail call fastcc void @parserInit(ptr noundef nonnull %parser, ptr noundef %encodingName)
  %m_dtd = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 65
  %27 = load ptr, ptr %m_dtd, align 8
  %elementTypes.i = getelementptr inbounds %struct.DTD, ptr %27, i64 0, i32 1
  %28 = load ptr, ptr %elementTypes.i, align 8
  %tobool.not.i.i = icmp eq ptr %28, null
  br i1 %tobool.not.i.i, label %hashTableIterInit.exit.i, label %cond.true.i.i

cond.true.i.i:                                    ; preds = %poolClear.exit52
  %size.i.i = getelementptr inbounds %struct.DTD, ptr %27, i64 0, i32 1, i32 2
  %29 = load i64, ptr %size.i.i, align 8
  %add.ptr.i.i = getelementptr ptr, ptr %28, i64 %29
  br label %hashTableIterInit.exit.i

hashTableIterInit.exit.i:                         ; preds = %cond.true.i.i, %poolClear.exit52
  %cond.i.i = phi ptr [ %add.ptr.i.i, %cond.true.i.i ], [ null, %poolClear.exit52 ]
  br label %while.cond.i.i

while.cond.i.i:                                   ; preds = %while.cond.i.i.backedge, %hashTableIterInit.exit.i
  %incdec.ptr5.i.i = phi ptr [ %28, %hashTableIterInit.exit.i ], [ %incdec.ptr.i.i, %while.cond.i.i.backedge ]
  %cmp.not.i.i = icmp eq ptr %incdec.ptr5.i.i, %cond.i.i
  br i1 %cmp.not.i.i, label %for.end.i, label %while.body.i.i

while.body.i.i:                                   ; preds = %while.cond.i.i
  %incdec.ptr.i.i = getelementptr ptr, ptr %incdec.ptr5.i.i, i64 1
  %30 = load ptr, ptr %incdec.ptr5.i.i, align 8
  %tobool.not.i28.i = icmp eq ptr %30, null
  br i1 %tobool.not.i28.i, label %while.cond.i.i.backedge, label %if.end.i

while.cond.i.i.backedge:                          ; preds = %while.body.i.i, %if.then1.i, %if.end.i
  br label %while.cond.i.i, !llvm.loop !9

if.end.i:                                         ; preds = %while.body.i.i
  %allocDefaultAtts.i = getelementptr inbounds %struct.ELEMENT_TYPE, ptr %30, i64 0, i32 4
  %31 = load i32, ptr %allocDefaultAtts.i, align 4
  %cmp.not.i = icmp eq i32 %31, 0
  br i1 %cmp.not.i, label %while.cond.i.i.backedge, label %if.then1.i

if.then1.i:                                       ; preds = %if.end.i
  %32 = load ptr, ptr %free_fcn, align 8
  %defaultAtts.i = getelementptr inbounds %struct.ELEMENT_TYPE, ptr %30, i64 0, i32 5
  %33 = load ptr, ptr %defaultAtts.i, align 8
  tail call void %32(ptr noundef %33) #24
  br label %while.cond.i.i.backedge

for.end.i:                                        ; preds = %while.cond.i.i
  %size.i29.i = getelementptr inbounds %struct.HASH_TABLE, ptr %27, i64 0, i32 2
  %34 = load i64, ptr %size.i29.i, align 8
  %cmp8.not.i.i = icmp eq i64 %34, 0
  br i1 %cmp8.not.i.i, label %hashTableClear.exit.i, label %for.body.lr.ph.i.i

for.body.lr.ph.i.i:                               ; preds = %for.end.i
  %mem.i.i = getelementptr inbounds %struct.HASH_TABLE, ptr %27, i64 0, i32 4
  br label %for.body.i.i

for.body.i.i:                                     ; preds = %for.body.i.i, %for.body.lr.ph.i.i
  %i.09.i.i = phi i64 [ 0, %for.body.lr.ph.i.i ], [ %inc.i.i, %for.body.i.i ]
  %35 = load ptr, ptr %mem.i.i, align 8
  %free_fcn.i.i = getelementptr inbounds %struct.XML_Memory_Handling_Suite, ptr %35, i64 0, i32 2
  %36 = load ptr, ptr %free_fcn.i.i, align 8
  %37 = load ptr, ptr %27, align 8
  %arrayidx.i.i = getelementptr ptr, ptr %37, i64 %i.09.i.i
  %38 = load ptr, ptr %arrayidx.i.i, align 8
  tail call void %36(ptr noundef %38) #24
  %39 = load ptr, ptr %27, align 8
  %arrayidx2.i.i = getelementptr ptr, ptr %39, i64 %i.09.i.i
  store ptr null, ptr %arrayidx2.i.i, align 8
  %inc.i.i = add nuw i64 %i.09.i.i, 1
  %40 = load i64, ptr %size.i29.i, align 8
  %cmp.i.i = icmp ult i64 %inc.i.i, %40
  br i1 %cmp.i.i, label %for.body.i.i, label %hashTableClear.exit.i, !llvm.loop !10

hashTableClear.exit.i:                            ; preds = %for.body.i.i, %for.end.i
  %used.i.i = getelementptr inbounds %struct.HASH_TABLE, ptr %27, i64 0, i32 3
  store i64 0, ptr %used.i.i, align 8
  %paramEntityRead.i = getelementptr inbounds %struct.DTD, ptr %27, i64 0, i32 9
  store i8 0, ptr %paramEntityRead.i, align 1
  %paramEntities.i = getelementptr inbounds %struct.DTD, ptr %27, i64 0, i32 10
  %size.i30.i = getelementptr inbounds %struct.DTD, ptr %27, i64 0, i32 10, i32 2
  %41 = load i64, ptr %size.i30.i, align 8
  %cmp8.not.i31.i = icmp eq i64 %41, 0
  br i1 %cmp8.not.i31.i, label %hashTableClear.exit42.i, label %for.body.lr.ph.i32.i

for.body.lr.ph.i32.i:                             ; preds = %hashTableClear.exit.i
  %mem.i33.i = getelementptr inbounds %struct.DTD, ptr %27, i64 0, i32 10, i32 4
  br label %for.body.i34.i

for.body.i34.i:                                   ; preds = %for.body.i34.i, %for.body.lr.ph.i32.i
  %i.09.i35.i = phi i64 [ 0, %for.body.lr.ph.i32.i ], [ %inc.i39.i, %for.body.i34.i ]
  %42 = load ptr, ptr %mem.i33.i, align 8
  %free_fcn.i36.i = getelementptr inbounds %struct.XML_Memory_Handling_Suite, ptr %42, i64 0, i32 2
  %43 = load ptr, ptr %free_fcn.i36.i, align 8
  %44 = load ptr, ptr %paramEntities.i, align 8
  %arrayidx.i37.i = getelementptr ptr, ptr %44, i64 %i.09.i35.i
  %45 = load ptr, ptr %arrayidx.i37.i, align 8
  tail call void %43(ptr noundef %45) #24
  %46 = load ptr, ptr %paramEntities.i, align 8
  %arrayidx2.i38.i = getelementptr ptr, ptr %46, i64 %i.09.i35.i
  store ptr null, ptr %arrayidx2.i38.i, align 8
  %inc.i39.i = add nuw i64 %i.09.i35.i, 1
  %47 = load i64, ptr %size.i30.i, align 8
  %cmp.i40.i = icmp ult i64 %inc.i39.i, %47
  br i1 %cmp.i40.i, label %for.body.i34.i, label %hashTableClear.exit42.i, !llvm.loop !10

hashTableClear.exit42.i:                          ; preds = %for.body.i34.i, %hashTableClear.exit.i
  %used.i41.i = getelementptr inbounds %struct.DTD, ptr %27, i64 0, i32 10, i32 3
  store i64 0, ptr %used.i41.i, align 8
  %size.i43.i = getelementptr inbounds %struct.DTD, ptr %27, i64 0, i32 1, i32 2
  %48 = load i64, ptr %size.i43.i, align 8
  %cmp8.not.i44.i = icmp eq i64 %48, 0
  br i1 %cmp8.not.i44.i, label %hashTableClear.exit55.i, label %for.body.lr.ph.i45.i

for.body.lr.ph.i45.i:                             ; preds = %hashTableClear.exit42.i
  %mem.i46.i = getelementptr inbounds %struct.DTD, ptr %27, i64 0, i32 1, i32 4
  br label %for.body.i47.i

for.body.i47.i:                                   ; preds = %for.body.i47.i, %for.body.lr.ph.i45.i
  %i.09.i48.i = phi i64 [ 0, %for.body.lr.ph.i45.i ], [ %inc.i52.i, %for.body.i47.i ]
  %49 = load ptr, ptr %mem.i46.i, align 8
  %free_fcn.i49.i = getelementptr inbounds %struct.XML_Memory_Handling_Suite, ptr %49, i64 0, i32 2
  %50 = load ptr, ptr %free_fcn.i49.i, align 8
  %51 = load ptr, ptr %elementTypes.i, align 8
  %arrayidx.i50.i = getelementptr ptr, ptr %51, i64 %i.09.i48.i
  %52 = load ptr, ptr %arrayidx.i50.i, align 8
  tail call void %50(ptr noundef %52) #24
  %53 = load ptr, ptr %elementTypes.i, align 8
  %arrayidx2.i51.i = getelementptr ptr, ptr %53, i64 %i.09.i48.i
  store ptr null, ptr %arrayidx2.i51.i, align 8
  %inc.i52.i = add nuw i64 %i.09.i48.i, 1
  %54 = load i64, ptr %size.i43.i, align 8
  %cmp.i53.i = icmp ult i64 %inc.i52.i, %54
  br i1 %cmp.i53.i, label %for.body.i47.i, label %hashTableClear.exit55.i, !llvm.loop !10

hashTableClear.exit55.i:                          ; preds = %for.body.i47.i, %hashTableClear.exit42.i
  %used.i54.i = getelementptr inbounds %struct.DTD, ptr %27, i64 0, i32 1, i32 3
  store i64 0, ptr %used.i54.i, align 8
  %attributeIds.i = getelementptr inbounds %struct.DTD, ptr %27, i64 0, i32 2
  %size.i56.i = getelementptr inbounds %struct.DTD, ptr %27, i64 0, i32 2, i32 2
  %55 = load i64, ptr %size.i56.i, align 8
  %cmp8.not.i57.i = icmp eq i64 %55, 0
  br i1 %cmp8.not.i57.i, label %hashTableClear.exit68.i, label %for.body.lr.ph.i58.i

for.body.lr.ph.i58.i:                             ; preds = %hashTableClear.exit55.i
  %mem.i59.i = getelementptr inbounds %struct.DTD, ptr %27, i64 0, i32 2, i32 4
  br label %for.body.i60.i

for.body.i60.i:                                   ; preds = %for.body.i60.i, %for.body.lr.ph.i58.i
  %i.09.i61.i = phi i64 [ 0, %for.body.lr.ph.i58.i ], [ %inc.i65.i, %for.body.i60.i ]
  %56 = load ptr, ptr %mem.i59.i, align 8
  %free_fcn.i62.i = getelementptr inbounds %struct.XML_Memory_Handling_Suite, ptr %56, i64 0, i32 2
  %57 = load ptr, ptr %free_fcn.i62.i, align 8
  %58 = load ptr, ptr %attributeIds.i, align 8
  %arrayidx.i63.i = getelementptr ptr, ptr %58, i64 %i.09.i61.i
  %59 = load ptr, ptr %arrayidx.i63.i, align 8
  tail call void %57(ptr noundef %59) #24
  %60 = load ptr, ptr %attributeIds.i, align 8
  %arrayidx2.i64.i = getelementptr ptr, ptr %60, i64 %i.09.i61.i
  store ptr null, ptr %arrayidx2.i64.i, align 8
  %inc.i65.i = add nuw i64 %i.09.i61.i, 1
  %61 = load i64, ptr %size.i56.i, align 8
  %cmp.i66.i = icmp ult i64 %inc.i65.i, %61
  br i1 %cmp.i66.i, label %for.body.i60.i, label %hashTableClear.exit68.i, !llvm.loop !10

hashTableClear.exit68.i:                          ; preds = %for.body.i60.i, %hashTableClear.exit55.i
  %used.i67.i = getelementptr inbounds %struct.DTD, ptr %27, i64 0, i32 2, i32 3
  store i64 0, ptr %used.i67.i, align 8
  %prefixes.i = getelementptr inbounds %struct.DTD, ptr %27, i64 0, i32 3
  %size.i69.i = getelementptr inbounds %struct.DTD, ptr %27, i64 0, i32 3, i32 2
  %62 = load i64, ptr %size.i69.i, align 8
  %cmp8.not.i70.i = icmp eq i64 %62, 0
  br i1 %cmp8.not.i70.i, label %hashTableClear.exit81.i, label %for.body.lr.ph.i71.i

for.body.lr.ph.i71.i:                             ; preds = %hashTableClear.exit68.i
  %mem.i72.i = getelementptr inbounds %struct.DTD, ptr %27, i64 0, i32 3, i32 4
  br label %for.body.i73.i

for.body.i73.i:                                   ; preds = %for.body.i73.i, %for.body.lr.ph.i71.i
  %i.09.i74.i = phi i64 [ 0, %for.body.lr.ph.i71.i ], [ %inc.i78.i, %for.body.i73.i ]
  %63 = load ptr, ptr %mem.i72.i, align 8
  %free_fcn.i75.i = getelementptr inbounds %struct.XML_Memory_Handling_Suite, ptr %63, i64 0, i32 2
  %64 = load ptr, ptr %free_fcn.i75.i, align 8
  %65 = load ptr, ptr %prefixes.i, align 8
  %arrayidx.i76.i = getelementptr ptr, ptr %65, i64 %i.09.i74.i
  %66 = load ptr, ptr %arrayidx.i76.i, align 8
  tail call void %64(ptr noundef %66) #24
  %67 = load ptr, ptr %prefixes.i, align 8
  %arrayidx2.i77.i = getelementptr ptr, ptr %67, i64 %i.09.i74.i
  store ptr null, ptr %arrayidx2.i77.i, align 8
  %inc.i78.i = add nuw i64 %i.09.i74.i, 1
  %68 = load i64, ptr %size.i69.i, align 8
  %cmp.i79.i = icmp ult i64 %inc.i78.i, %68
  br i1 %cmp.i79.i, label %for.body.i73.i, label %hashTableClear.exit81.i, !llvm.loop !10

hashTableClear.exit81.i:                          ; preds = %for.body.i73.i, %hashTableClear.exit68.i
  %used.i80.i = getelementptr inbounds %struct.DTD, ptr %27, i64 0, i32 3, i32 3
  store i64 0, ptr %used.i80.i, align 8
  %pool.i = getelementptr inbounds %struct.DTD, ptr %27, i64 0, i32 4
  %freeBlocks.i.i = getelementptr inbounds %struct.DTD, ptr %27, i64 0, i32 4, i32 1
  %69 = load ptr, ptr %freeBlocks.i.i, align 8
  %tobool.not.i82.i = icmp eq ptr %69, null
  %70 = load ptr, ptr %pool.i, align 8
  br i1 %tobool.not.i82.i, label %if.then.i.i, label %if.else.i.i

if.then.i.i:                                      ; preds = %hashTableClear.exit81.i
  store ptr %70, ptr %freeBlocks.i.i, align 8
  br label %poolClear.exit.i

if.else.i.i:                                      ; preds = %hashTableClear.exit81.i
  %tobool3.not13.i.i = icmp eq ptr %70, null
  br i1 %tobool3.not13.i.i, label %poolClear.exit.i, label %while.body.i83.i

while.body.i83.i:                                 ; preds = %if.else.i.i, %while.body.i83.i
  %71 = phi ptr [ %p.014.i.i, %while.body.i83.i ], [ %69, %if.else.i.i ]
  %p.014.i.i = phi ptr [ %72, %while.body.i83.i ], [ %70, %if.else.i.i ]
  %72 = load ptr, ptr %p.014.i.i, align 8
  store ptr %71, ptr %p.014.i.i, align 8
  store ptr %p.014.i.i, ptr %freeBlocks.i.i, align 8
  %tobool3.not.i.i = icmp eq ptr %72, null
  br i1 %tobool3.not.i.i, label %poolClear.exit.i, label %while.body.i83.i, !llvm.loop !8

poolClear.exit.i:                                 ; preds = %while.body.i83.i, %if.else.i.i, %if.then.i.i
  store ptr null, ptr %pool.i, align 8
  %end.i84.i = getelementptr inbounds %struct.DTD, ptr %27, i64 0, i32 4, i32 2
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %end.i84.i, i8 0, i64 24, i1 false)
  %entityValuePool.i = getelementptr inbounds %struct.DTD, ptr %27, i64 0, i32 5
  %freeBlocks.i85.i = getelementptr inbounds %struct.DTD, ptr %27, i64 0, i32 5, i32 1
  %73 = load ptr, ptr %freeBlocks.i85.i, align 8
  %tobool.not.i86.i = icmp eq ptr %73, null
  %74 = load ptr, ptr %entityValuePool.i, align 8
  br i1 %tobool.not.i86.i, label %if.then.i93.i, label %if.else.i87.i

if.then.i93.i:                                    ; preds = %poolClear.exit.i
  store ptr %74, ptr %freeBlocks.i85.i, align 8
  br label %dtdReset.exit

if.else.i87.i:                                    ; preds = %poolClear.exit.i
  %tobool3.not13.i88.i = icmp eq ptr %74, null
  br i1 %tobool3.not13.i88.i, label %dtdReset.exit, label %while.body.i89.i

while.body.i89.i:                                 ; preds = %if.else.i87.i, %while.body.i89.i
  %75 = phi ptr [ %p.014.i90.i, %while.body.i89.i ], [ %73, %if.else.i87.i ]
  %p.014.i90.i = phi ptr [ %76, %while.body.i89.i ], [ %74, %if.else.i87.i ]
  %76 = load ptr, ptr %p.014.i90.i, align 8
  store ptr %75, ptr %p.014.i90.i, align 8
  store ptr %p.014.i90.i, ptr %freeBlocks.i85.i, align 8
  %tobool3.not.i91.i = icmp eq ptr %76, null
  br i1 %tobool3.not.i91.i, label %dtdReset.exit, label %while.body.i89.i, !llvm.loop !8

dtdReset.exit:                                    ; preds = %while.body.i89.i, %if.then.i93.i, %if.else.i87.i
  store ptr null, ptr %entityValuePool.i, align 8
  %end.i92.i = getelementptr inbounds %struct.DTD, ptr %27, i64 0, i32 5, i32 2
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %end.i92.i, i8 0, i64 24, i1 false)
  %defaultPrefix.i = getelementptr inbounds %struct.DTD, ptr %27, i64 0, i32 11
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(17) %defaultPrefix.i, i8 0, i64 17, i1 false)
  %77 = load ptr, ptr %free_fcn, align 8
  %scaffIndex.i = getelementptr inbounds %struct.DTD, ptr %27, i64 0, i32 18
  %78 = load ptr, ptr %scaffIndex.i, align 8
  tail call void %77(ptr noundef %78) #24
  store ptr null, ptr %scaffIndex.i, align 8
  %79 = load ptr, ptr %free_fcn, align 8
  %scaffold.i = getelementptr inbounds %struct.DTD, ptr %27, i64 0, i32 13
  %80 = load ptr, ptr %scaffold.i, align 8
  tail call void %79(ptr noundef %80) #24
  %keepProcessing.i = getelementptr inbounds %struct.DTD, ptr %27, i64 0, i32 6
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %scaffold.i, i8 0, i64 24, i1 false)
  store i8 1, ptr %keepProcessing.i, align 8
  %hasParamEntityRefs.i = getelementptr inbounds %struct.DTD, ptr %27, i64 0, i32 7
  store i8 0, ptr %hasParamEntityRefs.i, align 1
  %standalone.i = getelementptr inbounds %struct.DTD, ptr %27, i64 0, i32 8
  store i8 0, ptr %standalone.i, align 2
  br label %return

return:                                           ; preds = %if.end, %entry, %dtdReset.exit
  %retval.0 = phi i8 [ 1, %dtdReset.exit ], [ 0, %entry ], [ 0, %if.end ]
  ret i8 %retval.0
}

; Function Attrs: nounwind uwtable
define internal fastcc void @parserInit(ptr noundef %parser, ptr noundef readonly %encodingName) unnamed_addr #0 {
entry:
  %afterValue.i78 = alloca ptr, align 8
  %afterValue.i = alloca ptr, align 8
  %m_processor = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 45
  store ptr @prologInitProcessor, ptr %m_processor, align 8
  %m_prologState = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 44
  tail call void @PyExpat_XmlPrologStateInit(ptr noundef nonnull %m_prologState) #24
  %cmp.not = icmp eq ptr %encodingName, null
  br i1 %cmp.not, label %if.end, label %while.cond.i

while.cond.i:                                     ; preds = %entry, %while.cond.i
  %charsRequired.0.i = phi i64 [ %inc.i, %while.cond.i ], [ 0, %entry ]
  %arrayidx.i = getelementptr i8, ptr %encodingName, i64 %charsRequired.0.i
  %0 = load i8, ptr %arrayidx.i, align 1
  %cmp.not.i = icmp eq i8 %0, 0
  %inc.i = add i64 %charsRequired.0.i, 1
  br i1 %cmp.not.i, label %while.end.i, label %while.cond.i, !llvm.loop !11

while.end.i:                                      ; preds = %while.cond.i
  %m_mem = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 3
  %1 = load ptr, ptr %m_mem, align 8
  %call.i = tail call ptr %1(i64 noundef %inc.i) #24
  %cmp3.i = icmp eq ptr %call.i, null
  br i1 %cmp3.i, label %copyString.exit, label %if.end.i

if.end.i:                                         ; preds = %while.end.i
  tail call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 1 %call.i, ptr nonnull align 1 %encodingName, i64 %inc.i, i1 false)
  br label %copyString.exit

copyString.exit:                                  ; preds = %while.end.i, %if.end.i
  %m_protocolEncodingName = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 37
  store ptr %call.i, ptr %m_protocolEncodingName, align 8
  br label %if.end

if.end:                                           ; preds = %copyString.exit, %entry
  %m_curBase = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 66
  store ptr null, ptr %m_curBase, align 8
  %m_initEncoding = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 35
  %m_encoding = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 34
  %call1 = tail call i32 @PyExpat_XmlInitEncoding(ptr noundef nonnull %m_initEncoding, ptr noundef nonnull %m_encoding, ptr noundef null) #24
  %m_startElementHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 11
  %m_externalEntityRefHandlerArg = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 27
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %parser, i8 0, i64 16, i1 false)
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(128) %m_startElementHandler, i8 0, i64 128, i1 false)
  store ptr %parser, ptr %m_externalEntityRefHandlerArg, align 8
  %m_skippedEntityHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 28
  store ptr null, ptr %m_skippedEntityHandler, align 8
  %m_elementDeclHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 30
  %m_buffer = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 2
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %m_elementDeclHandler, i8 0, i64 32, i1 false)
  %2 = load ptr, ptr %m_buffer, align 8
  %m_bufferPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 4
  store ptr %2, ptr %m_bufferPtr, align 8
  %m_bufferEnd = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 5
  store ptr %2, ptr %m_bufferEnd, align 8
  %m_parseEndByteIndex = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 7
  %m_declEntity = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 54
  %m_position = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 78
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %m_position, i8 0, i64 16, i1 false)
  %m_errorCode = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 46
  store i32 0, ptr %m_errorCode, align 8
  %m_eventPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 47
  %m_defaultExpandInternalEntities = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 52
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %m_parseEndByteIndex, i8 0, i64 16, i1 false)
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %m_eventPtr, i8 0, i64 32, i1 false)
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(74) %m_declEntity, i8 0, i64 74, i1 false)
  store i8 1, ptr %m_defaultExpandInternalEntities, align 8
  %m_tagLevel = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 53
  store i32 0, ptr %m_tagLevel, align 4
  %m_tagStack = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 67
  store ptr null, ptr %m_tagStack, align 8
  %m_inheritedBindings = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 69
  store ptr null, ptr %m_inheritedBindings, align 8
  %m_nSpecifiedAtts = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 72
  store i32 0, ptr %m_nSpecifiedAtts, align 4
  %m_unknownEncodingMem = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 40
  %m_unknownEncodingRelease = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 43
  store ptr null, ptr %m_unknownEncodingRelease, align 8
  %m_parentParser = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 84
  store ptr null, ptr %m_parentParser, align 8
  %m_parsingStatus = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 85
  store i32 0, ptr %m_parsingStatus, align 8
  %m_isParamEntity = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 86
  store i8 0, ptr %m_isParamEntity, align 8
  %m_useForeignDTD = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 87
  store i8 0, ptr %m_useForeignDTD, align 1
  %m_paramEntityParsing = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 88
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %m_unknownEncodingMem, i8 0, i64 16, i1 false)
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 4 dereferenceable(44) %m_paramEntityParsing, i8 0, i64 44, i1 false)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %afterValue.i)
  %call.i76 = tail call ptr @getenv(ptr noundef nonnull @.str.308) #24
  %cmp.i = icmp eq ptr %call.i76, null
  br i1 %cmp.i, label %getDebugLevel.exit, label %if.end.i77

if.end.i77:                                       ; preds = %if.end
  %call1.i = tail call ptr @__errno_location() #26
  store i32 0, ptr %call1.i, align 4
  store ptr %call.i76, ptr %afterValue.i, align 8
  %call2.i = call i64 @strtoul(ptr noundef nonnull %call.i76, ptr noundef nonnull %afterValue.i, i32 noundef 10) #24
  %3 = load i32, ptr %call1.i, align 4
  %cmp4.not.i = icmp eq i32 %3, 0
  br i1 %cmp4.not.i, label %lor.lhs.false.i, label %if.then7.i

lor.lhs.false.i:                                  ; preds = %if.end.i77
  %4 = load ptr, ptr %afterValue.i, align 8
  %5 = load i8, ptr %4, align 1
  %cmp5.not.i = icmp eq i8 %5, 0
  br i1 %cmp5.not.i, label %getDebugLevel.exit, label %if.then7.i

if.then7.i:                                       ; preds = %lor.lhs.false.i, %if.end.i77
  store i32 0, ptr %call1.i, align 4
  br label %getDebugLevel.exit

getDebugLevel.exit:                               ; preds = %if.end, %lor.lhs.false.i, %if.then7.i
  %retval.0.i = phi i64 [ 0, %if.then7.i ], [ 0, %if.end ], [ %call2.i, %lor.lhs.false.i ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %afterValue.i)
  %conv = trunc i64 %retval.0.i to i32
  %debugLevel = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 90, i32 2
  store i32 %conv, ptr %debugLevel, align 8
  %maximumAmplificationFactor = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 90, i32 3
  store float 1.000000e+02, ptr %maximumAmplificationFactor, align 4
  %activationThresholdBytes = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 90, i32 4
  store i64 8388608, ptr %activationThresholdBytes, align 8
  %m_entity_stats = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 91
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %m_entity_stats, i8 0, i64 16, i1 false)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %afterValue.i78)
  %call.i79 = tail call ptr @getenv(ptr noundef nonnull @.str.309) #24
  %cmp.i80 = icmp eq ptr %call.i79, null
  br i1 %cmp.i80, label %getDebugLevel.exit89, label %if.end.i81

if.end.i81:                                       ; preds = %getDebugLevel.exit
  %call1.i82 = tail call ptr @__errno_location() #26
  store i32 0, ptr %call1.i82, align 4
  store ptr %call.i79, ptr %afterValue.i78, align 8
  %call2.i83 = call i64 @strtoul(ptr noundef nonnull %call.i79, ptr noundef nonnull %afterValue.i78, i32 noundef 10) #24
  %6 = load i32, ptr %call1.i82, align 4
  %cmp4.not.i84 = icmp eq i32 %6, 0
  br i1 %cmp4.not.i84, label %lor.lhs.false.i87, label %if.then7.i85

lor.lhs.false.i87:                                ; preds = %if.end.i81
  %7 = load ptr, ptr %afterValue.i78, align 8
  %8 = load i8, ptr %7, align 1
  %cmp5.not.i88 = icmp eq i8 %8, 0
  br i1 %cmp5.not.i88, label %getDebugLevel.exit89, label %if.then7.i85

if.then7.i85:                                     ; preds = %lor.lhs.false.i87, %if.end.i81
  store i32 0, ptr %call1.i82, align 4
  br label %getDebugLevel.exit89

getDebugLevel.exit89:                             ; preds = %getDebugLevel.exit, %lor.lhs.false.i87, %if.then7.i85
  %retval.0.i86 = phi i64 [ 0, %if.then7.i85 ], [ 0, %getDebugLevel.exit ], [ %call2.i83, %lor.lhs.false.i87 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %afterValue.i78)
  %conv8 = trunc i64 %retval.0.i86 to i32
  %debugLevel10 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 91, i32 3
  store i32 %conv8, ptr %debugLevel10, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define hidden i32 @PyExpat_XML_SetEncoding(ptr noundef %parser, ptr noundef readonly %encodingName) local_unnamed_addr #0 {
entry:
  %cmp = icmp eq ptr %parser, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %m_parsingStatus = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 85
  %0 = load i32, ptr %m_parsingStatus, align 8
  switch i32 %0, label %if.end6 [
    i32 1, label %return
    i32 3, label %return
  ]

if.end6:                                          ; preds = %if.end
  %free_fcn = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 3, i32 2
  %1 = load ptr, ptr %free_fcn, align 8
  %m_protocolEncodingName = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 37
  %2 = load ptr, ptr %m_protocolEncodingName, align 8
  tail call void %1(ptr noundef %2) #24
  %cmp7 = icmp eq ptr %encodingName, null
  br i1 %cmp7, label %return.sink.split, label %while.cond.i

while.cond.i:                                     ; preds = %if.end6, %while.cond.i
  %charsRequired.0.i = phi i64 [ %inc.i, %while.cond.i ], [ 0, %if.end6 ]
  %arrayidx.i = getelementptr i8, ptr %encodingName, i64 %charsRequired.0.i
  %3 = load i8, ptr %arrayidx.i, align 1
  %cmp.not.i = icmp eq i8 %3, 0
  %inc.i = add i64 %charsRequired.0.i, 1
  br i1 %cmp.not.i, label %while.end.i, label %while.cond.i, !llvm.loop !11

while.end.i:                                      ; preds = %while.cond.i
  %m_mem = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 3
  %4 = load ptr, ptr %m_mem, align 8
  %call.i = tail call ptr %4(i64 noundef %inc.i) #24
  %cmp3.i = icmp eq ptr %call.i, null
  br i1 %cmp3.i, label %return.sink.split, label %copyString.exit

copyString.exit:                                  ; preds = %while.end.i
  tail call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 1 %call.i, ptr nonnull align 1 %encodingName, i64 %inc.i, i1 false)
  br label %return.sink.split

return.sink.split:                                ; preds = %while.end.i, %if.end6, %copyString.exit
  %.sink = phi ptr [ %call.i, %copyString.exit ], [ null, %if.end6 ], [ null, %while.end.i ]
  %retval.0.ph = phi i32 [ 1, %copyString.exit ], [ 1, %if.end6 ], [ 0, %while.end.i ]
  store ptr %.sink, ptr %m_protocolEncodingName, align 8
  br label %return

return:                                           ; preds = %return.sink.split, %if.end, %if.end, %entry
  %retval.0 = phi i32 [ 0, %entry ], [ 0, %if.end ], [ 0, %if.end ], [ %retval.0.ph, %return.sink.split ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define hidden ptr @PyExpat_XML_ExternalEntityParserCreate(ptr noundef %oldParser, ptr noundef readonly %context, ptr noundef %encodingName) local_unnamed_addr #0 {
entry:
  %tmp = alloca [2 x i8], align 1
  %cmp = icmp eq ptr %oldParser, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %m_dtd = getelementptr inbounds %struct.XML_ParserStruct, ptr %oldParser, i64 0, i32 65
  %0 = load ptr, ptr %m_dtd, align 8
  %m_startElementHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %oldParser, i64 0, i32 11
  %1 = load <2 x ptr>, ptr %m_startElementHandler, align 8
  %m_characterDataHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %oldParser, i64 0, i32 13
  %2 = load <2 x ptr>, ptr %m_characterDataHandler, align 8
  %m_commentHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %oldParser, i64 0, i32 15
  %3 = load <2 x ptr>, ptr %m_commentHandler, align 8
  %m_endCdataSectionHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %oldParser, i64 0, i32 17
  %4 = load <2 x ptr>, ptr %m_endCdataSectionHandler, align 8
  %m_unparsedEntityDeclHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %oldParser, i64 0, i32 21
  %5 = load <2 x ptr>, ptr %m_unparsedEntityDeclHandler, align 8
  %m_startNamespaceDeclHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %oldParser, i64 0, i32 23
  %6 = load <2 x ptr>, ptr %m_startNamespaceDeclHandler, align 8
  %m_notStandaloneHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %oldParser, i64 0, i32 25
  %7 = load <2 x ptr>, ptr %m_notStandaloneHandler, align 8
  %m_skippedEntityHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %oldParser, i64 0, i32 28
  %8 = load <2 x ptr>, ptr %m_skippedEntityHandler, align 8
  %m_elementDeclHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %oldParser, i64 0, i32 30
  %9 = load <2 x ptr>, ptr %m_elementDeclHandler, align 8
  %m_entityDeclHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %oldParser, i64 0, i32 32
  %10 = load <2 x ptr>, ptr %m_entityDeclHandler, align 8
  %m_declElementType = getelementptr inbounds %struct.XML_ParserStruct, ptr %oldParser, i64 0, i32 61
  %11 = load ptr, ptr %m_declElementType, align 8
  %12 = load ptr, ptr %oldParser, align 8
  %m_handlerArg = getelementptr inbounds %struct.XML_ParserStruct, ptr %oldParser, i64 0, i32 1
  %13 = load ptr, ptr %m_handlerArg, align 8
  %m_defaultExpandInternalEntities = getelementptr inbounds %struct.XML_ParserStruct, ptr %oldParser, i64 0, i32 52
  %14 = load i8, ptr %m_defaultExpandInternalEntities, align 8
  %m_externalEntityRefHandlerArg = getelementptr inbounds %struct.XML_ParserStruct, ptr %oldParser, i64 0, i32 27
  %15 = load ptr, ptr %m_externalEntityRefHandlerArg, align 8
  %m_paramEntityParsing = getelementptr inbounds %struct.XML_ParserStruct, ptr %oldParser, i64 0, i32 88
  %16 = load i32, ptr %m_paramEntityParsing, align 4
  %inEntityValue = getelementptr inbounds %struct.XML_ParserStruct, ptr %oldParser, i64 0, i32 44, i32 5
  %17 = load i32, ptr %inEntityValue, align 8
  %m_ns_triplets = getelementptr inbounds %struct.XML_ParserStruct, ptr %oldParser, i64 0, i32 39
  %18 = load i8, ptr %m_ns_triplets, align 1
  %m_hash_secret_salt = getelementptr inbounds %struct.XML_ParserStruct, ptr %oldParser, i64 0, i32 89
  %19 = load i64, ptr %m_hash_secret_salt, align 8
  %tobool.not = icmp eq ptr %context, null
  %spec.select = select i1 %tobool.not, ptr %0, ptr null
  %m_ns = getelementptr inbounds %struct.XML_ParserStruct, ptr %oldParser, i64 0, i32 38
  %20 = load i8, ptr %m_ns, align 8
  %tobool3.not = icmp eq i8 %20, 0
  br i1 %tobool3.not, label %if.else, label %if.then4

if.then4:                                         ; preds = %if.end
  %m_namespaceSeparator = getelementptr inbounds %struct.XML_ParserStruct, ptr %oldParser, i64 0, i32 83
  %21 = load i8, ptr %m_namespaceSeparator, align 4
  store i8 %21, ptr %tmp, align 1
  %arrayinit.element = getelementptr inbounds i8, ptr %tmp, i64 1
  store i8 0, ptr %arrayinit.element, align 1
  %m_mem = getelementptr inbounds %struct.XML_ParserStruct, ptr %oldParser, i64 0, i32 3
  %call = call fastcc ptr @parserCreate(ptr noundef %encodingName, ptr noundef nonnull %m_mem, ptr noundef nonnull %tmp, ptr noundef %spec.select)
  br label %if.end7

if.else:                                          ; preds = %if.end
  %m_mem5 = getelementptr inbounds %struct.XML_ParserStruct, ptr %oldParser, i64 0, i32 3
  %call6 = tail call fastcc ptr @parserCreate(ptr noundef %encodingName, ptr noundef nonnull %m_mem5, ptr noundef null, ptr noundef %spec.select)
  br label %if.end7

if.end7:                                          ; preds = %if.else, %if.then4
  %parser.0 = phi ptr [ %call, %if.then4 ], [ %call6, %if.else ]
  %tobool8.not = icmp eq ptr %parser.0, null
  br i1 %tobool8.not, label %return, label %if.end10

if.end10:                                         ; preds = %if.end7
  %m_startElementHandler11 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser.0, i64 0, i32 11
  store <2 x ptr> %1, ptr %m_startElementHandler11, align 8
  %m_characterDataHandler13 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser.0, i64 0, i32 13
  store <2 x ptr> %2, ptr %m_characterDataHandler13, align 8
  %m_commentHandler15 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser.0, i64 0, i32 15
  store <2 x ptr> %3, ptr %m_commentHandler15, align 8
  %m_endCdataSectionHandler17 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser.0, i64 0, i32 17
  store <2 x ptr> %4, ptr %m_endCdataSectionHandler17, align 8
  %m_unparsedEntityDeclHandler19 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser.0, i64 0, i32 21
  store <2 x ptr> %5, ptr %m_unparsedEntityDeclHandler19, align 8
  %m_startNamespaceDeclHandler21 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser.0, i64 0, i32 23
  store <2 x ptr> %6, ptr %m_startNamespaceDeclHandler21, align 8
  %m_notStandaloneHandler23 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser.0, i64 0, i32 25
  store <2 x ptr> %7, ptr %m_notStandaloneHandler23, align 8
  %m_skippedEntityHandler25 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser.0, i64 0, i32 28
  store <2 x ptr> %8, ptr %m_skippedEntityHandler25, align 8
  %m_elementDeclHandler27 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser.0, i64 0, i32 30
  store <2 x ptr> %9, ptr %m_elementDeclHandler27, align 8
  %m_entityDeclHandler29 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser.0, i64 0, i32 32
  store <2 x ptr> %10, ptr %m_entityDeclHandler29, align 8
  %m_declElementType31 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser.0, i64 0, i32 61
  store ptr %11, ptr %m_declElementType31, align 8
  store ptr %12, ptr %parser.0, align 8
  %cmp33 = icmp eq ptr %12, %13
  %spec.select153 = select i1 %cmp33, ptr %12, ptr %parser.0
  %22 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser.0, i64 0, i32 1
  store ptr %spec.select153, ptr %22, align 8
  %cmp40.not = icmp eq ptr %15, %oldParser
  br i1 %cmp40.not, label %if.end43, label %if.then41

if.then41:                                        ; preds = %if.end10
  %m_externalEntityRefHandlerArg42 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser.0, i64 0, i32 27
  store ptr %15, ptr %m_externalEntityRefHandlerArg42, align 8
  br label %if.end43

if.end43:                                         ; preds = %if.then41, %if.end10
  %m_defaultExpandInternalEntities44 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser.0, i64 0, i32 52
  store i8 %14, ptr %m_defaultExpandInternalEntities44, align 8
  %m_ns_triplets45 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser.0, i64 0, i32 39
  store i8 %18, ptr %m_ns_triplets45, align 1
  %m_hash_secret_salt46 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser.0, i64 0, i32 89
  store i64 %19, ptr %m_hash_secret_salt46, align 8
  %m_parentParser = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser.0, i64 0, i32 84
  store ptr %oldParser, ptr %m_parentParser, align 8
  %m_paramEntityParsing47 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser.0, i64 0, i32 88
  store i32 %16, ptr %m_paramEntityParsing47, align 4
  %inEntityValue49 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser.0, i64 0, i32 44, i32 5
  store i32 %17, ptr %inEntityValue49, align 8
  br i1 %tobool.not, label %if.else60, label %if.then51

if.then51:                                        ; preds = %if.end43
  %m_dtd52 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser.0, i64 0, i32 65
  %23 = load ptr, ptr %m_dtd52, align 8
  %m_mem53 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser.0, i64 0, i32 3
  %prefixes.i = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 3
  %24 = load ptr, ptr %prefixes.i, align 8
  %tobool.not.i.i = icmp eq ptr %24, null
  br i1 %tobool.not.i.i, label %hashTableIterInit.exit.i, label %cond.true.i.i

cond.true.i.i:                                    ; preds = %if.then51
  %size.i.i = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 3, i32 2
  %25 = load i64, ptr %size.i.i, align 8
  %add.ptr.i.i = getelementptr ptr, ptr %24, i64 %25
  br label %hashTableIterInit.exit.i

hashTableIterInit.exit.i:                         ; preds = %cond.true.i.i, %if.then51
  %cond.i.i = phi ptr [ %add.ptr.i.i, %cond.true.i.i ], [ null, %if.then51 ]
  %pool.i = getelementptr inbounds %struct.DTD, ptr %23, i64 0, i32 4
  %ptr.i.i = getelementptr inbounds %struct.DTD, ptr %23, i64 0, i32 4, i32 3
  %end.i108.i = getelementptr inbounds %struct.DTD, ptr %23, i64 0, i32 4, i32 2
  %freeBlocks.i.i = getelementptr inbounds %struct.DTD, ptr %23, i64 0, i32 4, i32 1
  %start.i350.i = getelementptr inbounds %struct.DTD, ptr %23, i64 0, i32 4, i32 4
  %mem140.i.i = getelementptr inbounds %struct.DTD, ptr %23, i64 0, i32 4, i32 5
  %prefixes6.i = getelementptr inbounds %struct.DTD, ptr %23, i64 0, i32 3
  br label %while.cond.i.i

while.cond.i.i:                                   ; preds = %while.cond.i.i.backedge, %hashTableIterInit.exit.i
  %incdec.ptr5.i.i = phi ptr [ %24, %hashTableIterInit.exit.i ], [ %incdec.ptr.i.i, %while.cond.i.i.backedge ]
  %cmp.not.i.i = icmp eq ptr %incdec.ptr5.i.i, %cond.i.i
  br i1 %cmp.not.i.i, label %for.end.i, label %while.body.i.i

while.body.i.i:                                   ; preds = %while.cond.i.i
  %incdec.ptr.i.i = getelementptr ptr, ptr %incdec.ptr5.i.i, i64 1
  %26 = load ptr, ptr %incdec.ptr5.i.i, align 8
  %tobool.not.i107.i = icmp eq ptr %26, null
  br i1 %tobool.not.i107.i, label %while.cond.i.i.backedge, label %if.end.i

while.cond.i.i.backedge:                          ; preds = %while.body.i.i, %if.end5.i
  br label %while.cond.i.i, !llvm.loop !9

if.end.i:                                         ; preds = %while.body.i.i
  %27 = load ptr, ptr %26, align 8
  br label %do.body.i.i

do.body.i.i:                                      ; preds = %cond.false.i.i, %if.end.i
  %s.addr.0.i.i = phi ptr [ %27, %if.end.i ], [ %incdec.ptr2.i.i, %cond.false.i.i ]
  %28 = load ptr, ptr %ptr.i.i, align 8
  %29 = load ptr, ptr %end.i108.i, align 8
  %cmp.i.i = icmp eq ptr %28, %29
  br i1 %cmp.i.i, label %land.lhs.true.i.i, label %cond.false.i.i

land.lhs.true.i.i:                                ; preds = %do.body.i.i
  %30 = load ptr, ptr %freeBlocks.i.i, align 8
  %tobool.not.i348.i = icmp eq ptr %30, null
  %.pre.i353.pre.i = load ptr, ptr %start.i350.i, align 8
  br i1 %tobool.not.i348.i, label %land.lhs.true.i.i.if.end57.i.i_crit_edge, label %if.then.i349.i

land.lhs.true.i.i.if.end57.i.i_crit_edge:         ; preds = %land.lhs.true.i.i
  %.pre = ptrtoint ptr %28 to i64
  %.pre131 = ptrtoint ptr %.pre.i353.pre.i to i64
  %.pre132 = sub i64 %.pre, %.pre131
  br label %if.end57.i.i

if.then.i349.i:                                   ; preds = %land.lhs.true.i.i
  %cmp.i351.i = icmp eq ptr %.pre.i353.pre.i, null
  br i1 %cmp.i351.i, label %if.then1.i.i, label %if.end.i.i

if.then1.i.i:                                     ; preds = %if.then.i349.i
  store ptr %30, ptr %pool.i, align 8
  %31 = load ptr, ptr %30, align 8
  store ptr %31, ptr %freeBlocks.i.i, align 8
  store ptr null, ptr %30, align 8
  %32 = load ptr, ptr %pool.i, align 8
  %s.i.i = getelementptr inbounds %struct.block, ptr %32, i64 0, i32 2
  store ptr %s.i.i, ptr %start.i350.i, align 8
  %size.i356.i = getelementptr inbounds %struct.block, ptr %32, i64 0, i32 1
  %33 = load i32, ptr %size.i356.i, align 8
  %idx.ext.i.i = sext i32 %33 to i64
  %add.ptr.i357.i = getelementptr i8, ptr %s.i.i, i64 %idx.ext.i.i
  store ptr %add.ptr.i357.i, ptr %end.i108.i, align 8
  store ptr %s.i.i, ptr %ptr.i.i, align 8
  br label %cond.false.i.i

if.end.i.i:                                       ; preds = %if.then.i349.i
  %sub.ptr.lhs.cast.i.i = ptrtoint ptr %28 to i64
  %sub.ptr.rhs.cast.i.i = ptrtoint ptr %.pre.i353.pre.i to i64
  %sub.ptr.sub.i.i = sub i64 %sub.ptr.lhs.cast.i.i, %sub.ptr.rhs.cast.i.i
  %size15.i.i = getelementptr inbounds %struct.block, ptr %30, i64 0, i32 1
  %34 = load i32, ptr %size15.i.i, align 8
  %conv.i352.i = sext i32 %34 to i64
  %cmp16.i.i = icmp slt i64 %sub.ptr.sub.i.i, %conv.i352.i
  br i1 %cmp16.i.i, label %if.then18.i.i, label %if.end57.i.i

if.then18.i.i:                                    ; preds = %if.end.i.i
  %35 = load ptr, ptr %30, align 8
  %36 = load ptr, ptr %pool.i, align 8
  store ptr %36, ptr %30, align 8
  %37 = load ptr, ptr %freeBlocks.i.i, align 8
  store ptr %37, ptr %pool.i, align 8
  store ptr %35, ptr %freeBlocks.i.i, align 8
  %s28.i.i = getelementptr inbounds %struct.block, ptr %37, i64 0, i32 2
  %38 = load ptr, ptr %start.i350.i, align 8
  %39 = load ptr, ptr %end.i108.i, align 8
  %sub.ptr.lhs.cast33.i.i = ptrtoint ptr %39 to i64
  %sub.ptr.rhs.cast34.i.i = ptrtoint ptr %38 to i64
  %sub.ptr.sub35.i.i = sub i64 %sub.ptr.lhs.cast33.i.i, %sub.ptr.rhs.cast34.i.i
  call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 4 %s28.i.i, ptr align 1 %38, i64 %sub.ptr.sub35.i.i, i1 false)
  %40 = load ptr, ptr %pool.i, align 8
  %s37.i.i = getelementptr inbounds %struct.block, ptr %40, i64 0, i32 2
  %41 = load ptr, ptr %ptr.i.i, align 8
  %42 = load ptr, ptr %start.i350.i, align 8
  %sub.ptr.lhs.cast41.i.i = ptrtoint ptr %41 to i64
  %sub.ptr.rhs.cast42.i.i = ptrtoint ptr %42 to i64
  %sub.ptr.sub43.i.i = sub i64 %sub.ptr.lhs.cast41.i.i, %sub.ptr.rhs.cast42.i.i
  %add.ptr44.i.i = getelementptr i8, ptr %s37.i.i, i64 %sub.ptr.sub43.i.i
  store ptr %add.ptr44.i.i, ptr %ptr.i.i, align 8
  store ptr %s37.i.i, ptr %start.i350.i, align 8
  %size52.i.i = getelementptr inbounds %struct.block, ptr %40, i64 0, i32 1
  %43 = load i32, ptr %size52.i.i, align 8
  %idx.ext53.i.i = sext i32 %43 to i64
  %add.ptr54.i.i = getelementptr i8, ptr %s37.i.i, i64 %idx.ext53.i.i
  store ptr %add.ptr54.i.i, ptr %end.i108.i, align 8
  br label %cond.false.i.i

if.end57.i.i:                                     ; preds = %land.lhs.true.i.i.if.end57.i.i_crit_edge, %if.end.i.i
  %sub.ptr.sub71.i.i.pre-phi = phi i64 [ %.pre132, %land.lhs.true.i.i.if.end57.i.i_crit_edge ], [ %sub.ptr.sub.i.i, %if.end.i.i ]
  %44 = load ptr, ptr %pool.i, align 8
  %tobool59.not.i.i = icmp ne ptr %44, null
  %s62.i.i = getelementptr inbounds %struct.block, ptr %44, i64 0, i32 2
  %cmp64.i.i = icmp eq ptr %.pre.i353.pre.i, %s62.i.i
  %or.cond.i.i = select i1 %tobool59.not.i.i, i1 %cmp64.i.i, i1 false
  %conv72.i.i = trunc i64 %sub.ptr.sub71.i.i.pre-phi to i32
  br i1 %or.cond.i.i, label %if.then66.i.i, label %if.else.i354.i

if.then66.i.i:                                    ; preds = %if.end57.i.i
  %mul73.i.i = shl i32 %conv72.i.i, 1
  %cmp79.i.i = icmp slt i32 %mul73.i.i, 0
  br i1 %cmp79.i.i, label %if.then58, label %if.end82.i.i

if.end82.i.i:                                     ; preds = %if.then66.i.i
  %narrow.i.i.i = add nuw i32 %mul73.i.i, 12
  %narrow4.i.i.i = call i32 @llvm.smax.i32(i32 %narrow.i.i.i, i32 0)
  %cmp.inv.i.not.i.i = icmp eq i32 %mul73.i.i, 0
  %cmp8397.i.i = icmp eq i32 %narrow4.i.i.i, 0
  %cmp83.i.i = select i1 %cmp.inv.i.not.i.i, i1 true, i1 %cmp8397.i.i
  br i1 %cmp83.i.i, label %if.then58, label %if.end86.i.i

if.end86.i.i:                                     ; preds = %if.end82.i.i
  %retval.0.i.i.i = zext nneg i32 %narrow4.i.i.i to i64
  %45 = load ptr, ptr %mem140.i.i, align 8
  %realloc_fcn.i.i = getelementptr inbounds %struct.XML_Memory_Handling_Suite, ptr %45, i64 0, i32 1
  %46 = load ptr, ptr %realloc_fcn.i.i, align 8
  %call90.i.i = call ptr %46(ptr noundef nonnull %44, i64 noundef %retval.0.i.i.i) #24
  %cmp91.i.i = icmp eq ptr %call90.i.i, null
  br i1 %cmp91.i.i, label %if.then58, label %if.end94.i.i

if.end94.i.i:                                     ; preds = %if.end86.i.i
  store ptr %call90.i.i, ptr %pool.i, align 8
  %size97.i.i = getelementptr inbounds %struct.block, ptr %call90.i.i, i64 0, i32 1
  store i32 %mul73.i.i, ptr %size97.i.i, align 8
  %47 = load ptr, ptr %pool.i, align 8
  %s99.i.i = getelementptr inbounds %struct.block, ptr %47, i64 0, i32 2
  %add.ptr101.i.i = getelementptr i8, ptr %s99.i.i, i64 %sub.ptr.sub71.i.i.pre-phi
  store ptr %add.ptr101.i.i, ptr %ptr.i.i, align 8
  store ptr %s99.i.i, ptr %start.i350.i, align 8
  %idx.ext108.i.i = zext nneg i32 %mul73.i.i to i64
  %add.ptr109.i.i = getelementptr i8, ptr %s99.i.i, i64 %idx.ext108.i.i
  store ptr %add.ptr109.i.i, ptr %end.i108.i, align 8
  br label %cond.false.i.i

if.else.i354.i:                                   ; preds = %if.end57.i.i
  %cmp120.i.i = icmp slt i32 %conv72.i.i, 0
  br i1 %cmp120.i.i, label %if.then58, label %if.end123.i.i

if.end123.i.i:                                    ; preds = %if.else.i354.i
  %cmp124.i.i = icmp ult i32 %conv72.i.i, 1024
  br i1 %cmp124.i.i, label %48, label %if.else127.i.i

if.else127.i.i:                                   ; preds = %if.end123.i.i
  %mul128.i.i = shl nuw i32 %conv72.i.i, 1
  %cmp129.i.i = icmp slt i32 %mul128.i.i, 0
  br i1 %cmp129.i.i, label %if.then58, label %48

48:                                               ; preds = %if.else127.i.i, %if.end123.i.i
  %blockSize112.0.i.i = phi i32 [ 1024, %if.end123.i.i ], [ %mul128.i.i, %if.else127.i.i ]
  %narrow.i92.i.i = add nuw i32 %blockSize112.0.i.i, 12
  %narrow4.i93.i.i = call i32 @llvm.smax.i32(i32 %narrow.i92.i.i, i32 0)
  %cmp136.i.i = icmp eq i32 %narrow4.i93.i.i, 0
  br i1 %cmp136.i.i, label %if.then58, label %if.end139.i.i

if.end139.i.i:                                    ; preds = %48
  %retval.0.i96.i.i = zext nneg i32 %narrow4.i93.i.i to i64
  %49 = load ptr, ptr %mem140.i.i, align 8
  %50 = load ptr, ptr %49, align 8
  %call141.i.i = call ptr %50(i64 noundef %retval.0.i96.i.i) #24
  %tobool142.not.i.i = icmp eq ptr %call141.i.i, null
  br i1 %tobool142.not.i.i, label %if.then58, label %if.end144.i.i

if.end144.i.i:                                    ; preds = %if.end139.i.i
  %size145.i.i = getelementptr inbounds %struct.block, ptr %call141.i.i, i64 0, i32 1
  store i32 %blockSize112.0.i.i, ptr %size145.i.i, align 8
  %51 = load ptr, ptr %pool.i, align 8
  store ptr %51, ptr %call141.i.i, align 8
  store ptr %call141.i.i, ptr %pool.i, align 8
  %52 = load ptr, ptr %ptr.i.i, align 8
  %53 = load ptr, ptr %start.i350.i, align 8
  %cmp151.not.i.i = icmp eq ptr %52, %53
  br i1 %cmp151.not.i.i, label %if.end163.i.i, label %if.then153.i.i

if.then153.i.i:                                   ; preds = %if.end144.i.i
  %s154.i.i = getelementptr inbounds %struct.block, ptr %call141.i.i, i64 0, i32 2
  %sub.ptr.lhs.cast159.i.i = ptrtoint ptr %52 to i64
  %sub.ptr.rhs.cast160.i.i = ptrtoint ptr %53 to i64
  %sub.ptr.sub161.i.i = sub i64 %sub.ptr.lhs.cast159.i.i, %sub.ptr.rhs.cast160.i.i
  call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 4 %s154.i.i, ptr align 1 %53, i64 %sub.ptr.sub161.i.i, i1 false)
  %.pre98.i.i = load ptr, ptr %ptr.i.i, align 8
  %.pre99.i.i = load ptr, ptr %start.i350.i, align 8
  br label %if.end163.i.i

if.end163.i.i:                                    ; preds = %if.then153.i.i, %if.end144.i.i
  %54 = phi ptr [ %.pre99.i.i, %if.then153.i.i ], [ %52, %if.end144.i.i ]
  %55 = phi ptr [ %.pre98.i.i, %if.then153.i.i ], [ %52, %if.end144.i.i ]
  %s164.i.i = getelementptr inbounds %struct.block, ptr %call141.i.i, i64 0, i32 2
  %sub.ptr.lhs.cast168.i.i = ptrtoint ptr %55 to i64
  %sub.ptr.rhs.cast169.i.i = ptrtoint ptr %54 to i64
  %sub.ptr.sub170.i.i = sub i64 %sub.ptr.lhs.cast168.i.i, %sub.ptr.rhs.cast169.i.i
  %add.ptr171.i.i = getelementptr i8, ptr %s164.i.i, i64 %sub.ptr.sub170.i.i
  store ptr %add.ptr171.i.i, ptr %ptr.i.i, align 8
  store ptr %s164.i.i, ptr %start.i350.i, align 8
  %idx.ext178.i.i = zext nneg i32 %blockSize112.0.i.i to i64
  %add.ptr179.i.i = getelementptr i8, ptr %s164.i.i, i64 %idx.ext178.i.i
  store ptr %add.ptr179.i.i, ptr %end.i108.i, align 8
  br label %cond.false.i.i

cond.false.i.i:                                   ; preds = %if.end163.i.i, %if.end94.i.i, %if.then18.i.i, %if.then1.i.i, %do.body.i.i
  %56 = phi ptr [ %28, %do.body.i.i ], [ %add.ptr171.i.i, %if.end163.i.i ], [ %add.ptr101.i.i, %if.end94.i.i ], [ %add.ptr44.i.i, %if.then18.i.i ], [ %s.i.i, %if.then1.i.i ]
  %57 = load i8, ptr %s.addr.0.i.i, align 1
  %incdec.ptr.i109.i = getelementptr i8, ptr %56, i64 1
  store ptr %incdec.ptr.i109.i, ptr %ptr.i.i, align 8
  store i8 %57, ptr %56, align 1
  %incdec.ptr2.i.i = getelementptr i8, ptr %s.addr.0.i.i, i64 1
  %58 = load i8, ptr %s.addr.0.i.i, align 1
  %tobool3.not.i.i = icmp eq i8 %58, 0
  br i1 %tobool3.not.i.i, label %poolCopyString.exit.i, label %do.body.i.i, !llvm.loop !12

poolCopyString.exit.i:                            ; preds = %cond.false.i.i
  %59 = load ptr, ptr %start.i350.i, align 8
  %60 = load ptr, ptr %ptr.i.i, align 8
  store ptr %60, ptr %start.i350.i, align 8
  %tobool3.not.i = icmp eq ptr %59, null
  br i1 %tobool3.not.i, label %if.then58, label %if.end5.i

if.end5.i:                                        ; preds = %poolCopyString.exit.i
  %call7.i = call fastcc ptr @lookup(ptr noundef %oldParser, ptr noundef nonnull %prefixes6.i, ptr noundef nonnull %59, i64 noundef 16)
  %tobool8.not.i = icmp eq ptr %call7.i, null
  br i1 %tobool8.not.i, label %if.then58, label %while.cond.i.i.backedge

for.end.i:                                        ; preds = %while.cond.i.i
  %attributeIds.i = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 2
  %61 = load ptr, ptr %attributeIds.i, align 8
  %tobool.not.i112.i = icmp eq ptr %61, null
  br i1 %tobool.not.i112.i, label %hashTableIterInit.exit118.i, label %cond.true.i113.i

cond.true.i113.i:                                 ; preds = %for.end.i
  %size.i114.i = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 2, i32 2
  %62 = load i64, ptr %size.i114.i, align 8
  %add.ptr.i115.i = getelementptr ptr, ptr %61, i64 %62
  br label %hashTableIterInit.exit118.i

hashTableIterInit.exit118.i:                      ; preds = %cond.true.i113.i, %for.end.i
  %cond.i116.i = phi ptr [ %add.ptr.i115.i, %cond.true.i113.i ], [ null, %for.end.i ]
  %attributeIds33.i = getelementptr inbounds %struct.DTD, ptr %23, i64 0, i32 2
  %defaultPrefix.i = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 11
  %size.i147.i = getelementptr inbounds %struct.DTD, ptr %23, i64 0, i32 3, i32 2
  %power30.i.i = getelementptr inbounds %struct.DTD, ptr %23, i64 0, i32 3, i32 1
  %defaultPrefix45.i = getelementptr inbounds %struct.DTD, ptr %23, i64 0, i32 11
  br label %while.cond.i121.i

while.cond.i121.i:                                ; preds = %while.cond.i121.i.backedge, %hashTableIterInit.exit118.i
  %incdec.ptr5.i122.i = phi ptr [ %61, %hashTableIterInit.exit118.i ], [ %incdec.ptr.i125.i, %while.cond.i121.i.backedge ]
  %cmp.not.i123.i = icmp eq ptr %incdec.ptr5.i122.i, %cond.i116.i
  br i1 %cmp.not.i123.i, label %for.end54.i, label %while.body.i124.i

while.body.i124.i:                                ; preds = %while.cond.i121.i
  %incdec.ptr.i125.i = getelementptr ptr, ptr %incdec.ptr5.i122.i, i64 1
  %63 = load ptr, ptr %incdec.ptr5.i122.i, align 8
  %tobool.not.i126.i = icmp eq ptr %63, null
  br i1 %tobool.not.i126.i, label %while.cond.i121.i.backedge, label %if.end16.i

while.cond.i121.i.backedge:                       ; preds = %while.body.i124.i, %if.end53.sink.split.i, %if.end37.i
  br label %while.cond.i121.i, !llvm.loop !9

if.end16.i:                                       ; preds = %while.body.i124.i
  %64 = load ptr, ptr %ptr.i.i, align 8
  %65 = load ptr, ptr %end.i108.i, align 8
  %cmp.i = icmp eq ptr %64, %65
  br i1 %cmp.i, label %land.lhs.true.i, label %cond.false.i

land.lhs.true.i:                                  ; preds = %if.end16.i
  %call20.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool.i), !range !13
  %tobool21.not.i = icmp eq i8 %call20.i, 0
  br i1 %tobool21.not.i, label %if.then58, label %land.lhs.true.cond.false_crit_edge.i

land.lhs.true.cond.false_crit_edge.i:             ; preds = %land.lhs.true.i
  %.pre.i = load ptr, ptr %ptr.i.i, align 8
  br label %cond.false.i

cond.false.i:                                     ; preds = %land.lhs.true.cond.false_crit_edge.i, %if.end16.i
  %66 = phi ptr [ %.pre.i, %land.lhs.true.cond.false_crit_edge.i ], [ %64, %if.end16.i ]
  %incdec.ptr.i = getelementptr i8, ptr %66, i64 1
  store ptr %incdec.ptr.i, ptr %ptr.i.i, align 8
  store i8 0, ptr %66, align 1
  %67 = load ptr, ptr %63, align 8
  br label %do.body.i131.i

do.body.i131.i:                                   ; preds = %cond.false.i134.i, %cond.false.i
  %s.addr.0.i132.i = phi ptr [ %67, %cond.false.i ], [ %incdec.ptr2.i136.i, %cond.false.i134.i ]
  %68 = load ptr, ptr %ptr.i.i, align 8
  %69 = load ptr, ptr %end.i108.i, align 8
  %cmp.i133.i = icmp eq ptr %68, %69
  br i1 %cmp.i133.i, label %land.lhs.true.i141.i, label %cond.false.i134.i

land.lhs.true.i141.i:                             ; preds = %do.body.i131.i
  %call.i142.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool.i), !range !13
  %tobool.not.i143.i = icmp eq i8 %call.i142.i, 0
  br i1 %tobool.not.i143.i, label %if.then58, label %land.lhs.true.cond.false_crit_edge.i144.i

land.lhs.true.cond.false_crit_edge.i144.i:        ; preds = %land.lhs.true.i141.i
  %.pre.i145.i = load ptr, ptr %ptr.i.i, align 8
  br label %cond.false.i134.i

cond.false.i134.i:                                ; preds = %land.lhs.true.cond.false_crit_edge.i144.i, %do.body.i131.i
  %70 = phi ptr [ %.pre.i145.i, %land.lhs.true.cond.false_crit_edge.i144.i ], [ %68, %do.body.i131.i ]
  %71 = load i8, ptr %s.addr.0.i132.i, align 1
  %incdec.ptr.i135.i = getelementptr i8, ptr %70, i64 1
  store ptr %incdec.ptr.i135.i, ptr %ptr.i.i, align 8
  store i8 %71, ptr %70, align 1
  %incdec.ptr2.i136.i = getelementptr i8, ptr %s.addr.0.i132.i, i64 1
  %72 = load i8, ptr %s.addr.0.i132.i, align 1
  %tobool3.not.i137.i = icmp eq i8 %72, 0
  br i1 %tobool3.not.i137.i, label %poolCopyString.exit146.i, label %do.body.i131.i, !llvm.loop !12

poolCopyString.exit146.i:                         ; preds = %cond.false.i134.i
  %73 = load ptr, ptr %start.i350.i, align 8
  %74 = load ptr, ptr %ptr.i.i, align 8
  store ptr %74, ptr %start.i350.i, align 8
  %tobool29.not.i = icmp eq ptr %73, null
  br i1 %tobool29.not.i, label %if.then58, label %if.end31.i

if.end31.i:                                       ; preds = %poolCopyString.exit146.i
  %incdec.ptr32.i = getelementptr i8, ptr %73, i64 1
  %call34.i = call fastcc ptr @lookup(ptr noundef %oldParser, ptr noundef nonnull %attributeIds33.i, ptr noundef %incdec.ptr32.i, i64 noundef 24)
  %tobool35.not.i = icmp eq ptr %call34.i, null
  br i1 %tobool35.not.i, label %if.then58, label %if.end37.i

if.end37.i:                                       ; preds = %if.end31.i
  %maybeTokenized.i = getelementptr inbounds %struct.attribute_id, ptr %63, i64 0, i32 2
  %75 = load i8, ptr %maybeTokenized.i, align 8
  %maybeTokenized38.i = getelementptr inbounds %struct.attribute_id, ptr %call34.i, i64 0, i32 2
  store i8 %75, ptr %maybeTokenized38.i, align 8
  %prefix.i = getelementptr inbounds %struct.attribute_id, ptr %63, i64 0, i32 1
  %76 = load ptr, ptr %prefix.i, align 8
  %tobool39.not.i = icmp eq ptr %76, null
  br i1 %tobool39.not.i, label %while.cond.i121.i.backedge, label %if.then40.i

if.then40.i:                                      ; preds = %if.end37.i
  %xmlns.i = getelementptr inbounds %struct.attribute_id, ptr %63, i64 0, i32 3
  %77 = load i8, ptr %xmlns.i, align 1
  %xmlns41.i = getelementptr inbounds %struct.attribute_id, ptr %call34.i, i64 0, i32 3
  store i8 %77, ptr %xmlns41.i, align 1
  %78 = load ptr, ptr %prefix.i, align 8
  %cmp43.i = icmp eq ptr %78, %defaultPrefix.i
  br i1 %cmp43.i, label %if.end53.sink.split.i, label %if.else.i

if.else.i:                                        ; preds = %if.then40.i
  %79 = load ptr, ptr %78, align 8
  %80 = load i64, ptr %size.i147.i, align 8
  %cmp.i148.i = icmp eq i64 %80, 0
  br i1 %cmp.i148.i, label %if.end53.sink.split.i, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.else.i
  %call12.i.i = call fastcc i64 @hash(ptr noundef %oldParser, ptr noundef %79)
  %81 = load i64, ptr %size.i147.i, align 8
  %sub14.i.i = add i64 %81, -1
  %and15.i.i = and i64 %sub14.i.i, %call12.i.i
  %82 = load ptr, ptr %prefixes6.i, align 8
  %arrayidx111.i.i = getelementptr ptr, ptr %82, i64 %and15.i.i
  %83 = load ptr, ptr %arrayidx111.i.i, align 8
  %tobool17.not112.i.i = icmp eq ptr %83, null
  br i1 %tobool17.not112.i.i, label %if.end53.sink.split.i, label %while.body.lr.ph.i.i

while.body.lr.ph.i.i:                             ; preds = %if.else.i.i
  %84 = load i8, ptr %79, align 1
  %not.i.i = sub i64 0, %81
  %and29.i.i = and i64 %call12.i.i, %not.i.i
  %shr32.i.i = lshr i64 %sub14.i.i, 2
  br label %while.body.i149.i

while.body.i149.i:                                ; preds = %if.end35.i.i, %while.body.lr.ph.i.i
  %85 = phi ptr [ %83, %while.body.lr.ph.i.i ], [ %93, %if.end35.i.i ]
  %i.0114.i.i = phi i64 [ %and15.i.i, %while.body.lr.ph.i.i ], [ %i.1.i.i, %if.end35.i.i ]
  %step.0113.i.i = phi i8 [ 0, %while.body.lr.ph.i.i ], [ %step.1.i.i, %if.end35.i.i ]
  %86 = load ptr, ptr %85, align 8
  %87 = load i8, ptr %86, align 1
  %cmp5.i.i.i = icmp eq i8 %84, %87
  br i1 %cmp5.i.i.i, label %for.body.i.i.i, label %if.end26.i.i

for.body.i.i.i:                                   ; preds = %while.body.i149.i, %for.inc.i.i.i
  %88 = phi i8 [ %89, %for.inc.i.i.i ], [ %84, %while.body.i149.i ]
  %s2.addr.07.i.i.i = phi ptr [ %incdec.ptr6.i.i.i, %for.inc.i.i.i ], [ %86, %while.body.i149.i ]
  %s1.addr.06.i.i.i = phi ptr [ %incdec.ptr.i.i.i, %for.inc.i.i.i ], [ %79, %while.body.i149.i ]
  %cmp4.i.i.i = icmp eq i8 %88, 0
  br i1 %cmp4.i.i.i, label %if.end53.sink.split.i, label %for.inc.i.i.i

for.inc.i.i.i:                                    ; preds = %for.body.i.i.i
  %incdec.ptr.i.i.i = getelementptr i8, ptr %s1.addr.06.i.i.i, i64 1
  %incdec.ptr6.i.i.i = getelementptr i8, ptr %s2.addr.07.i.i.i, i64 1
  %89 = load i8, ptr %incdec.ptr.i.i.i, align 1
  %90 = load i8, ptr %incdec.ptr6.i.i.i, align 1
  %cmp.i.i.i = icmp eq i8 %89, %90
  br i1 %cmp.i.i.i, label %for.body.i.i.i, label %if.end26.i.i, !llvm.loop !14

if.end26.i.i:                                     ; preds = %for.inc.i.i.i, %while.body.i149.i
  %tobool27.not.i.i = icmp eq i8 %step.0113.i.i, 0
  br i1 %tobool27.not.i.i, label %if.then28.i.i, label %if.end35.i.i

if.then28.i.i:                                    ; preds = %if.end26.i.i
  %91 = load i8, ptr %power30.i.i, align 8
  %conv.i.i = zext i8 %91 to i64
  %sub31.i.i = add nuw nsw i64 %conv.i.i, 4294967295
  %sh_prom.i.i = and i64 %sub31.i.i, 4294967295
  %shr.i.i = lshr i64 %and29.i.i, %sh_prom.i.i
  %and33.i.i = and i64 %shr.i.i, %shr32.i.i
  %92 = trunc i64 %and33.i.i to i8
  %conv34.i.i = or i8 %92, 1
  br label %if.end35.i.i

if.end35.i.i:                                     ; preds = %if.then28.i.i, %if.end26.i.i
  %step.1.i.i = phi i8 [ %step.0113.i.i, %if.end26.i.i ], [ %conv34.i.i, %if.then28.i.i ]
  %conv36.i.i = zext i8 %step.1.i.i to i64
  %cmp37.i.i = icmp ult i64 %i.0114.i.i, %conv36.i.i
  %i.1.p.v.i.i = select i1 %cmp37.i.i, i64 %81, i64 0
  %i.1.p.i.i = sub i64 %i.0114.i.i, %conv36.i.i
  %i.1.i.i = add i64 %i.1.p.v.i.i, %i.1.p.i.i
  %arrayidx.i.i = getelementptr ptr, ptr %82, i64 %i.1.i.i
  %93 = load ptr, ptr %arrayidx.i.i, align 8
  %tobool17.not.i.i = icmp eq ptr %93, null
  br i1 %tobool17.not.i.i, label %if.end53.sink.split.i, label %while.body.i149.i, !llvm.loop !15

if.end53.sink.split.i:                            ; preds = %if.end35.i.i, %for.body.i.i.i, %if.else.i.i, %if.else.i, %if.then40.i
  %defaultPrefix45.sink.i = phi ptr [ %defaultPrefix45.i, %if.then40.i ], [ null, %if.else.i ], [ null, %if.else.i.i ], [ %85, %for.body.i.i.i ], [ null, %if.end35.i.i ]
  %prefix46.i = getelementptr inbounds %struct.attribute_id, ptr %call34.i, i64 0, i32 1
  store ptr %defaultPrefix45.sink.i, ptr %prefix46.i, align 8
  br label %while.cond.i121.i.backedge

for.end54.i:                                      ; preds = %while.cond.i121.i
  %elementTypes.i = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 1
  %94 = load ptr, ptr %elementTypes.i, align 8
  %tobool.not.i151.i = icmp eq ptr %94, null
  br i1 %tobool.not.i151.i, label %hashTableIterInit.exit157.i, label %cond.true.i152.i

cond.true.i152.i:                                 ; preds = %for.end54.i
  %size.i153.i = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 1, i32 2
  %95 = load i64, ptr %size.i153.i, align 8
  %add.ptr.i154.i = getelementptr ptr, ptr %94, i64 %95
  br label %hashTableIterInit.exit157.i

hashTableIterInit.exit157.i:                      ; preds = %cond.true.i152.i, %for.end54.i
  %cond.i155.i = phi ptr [ %add.ptr.i154.i, %cond.true.i152.i ], [ null, %for.end54.i ]
  %elementTypes67.i = getelementptr inbounds %struct.DTD, ptr %23, i64 0, i32 1
  %size.i186.i = getelementptr inbounds %struct.DTD, ptr %23, i64 0, i32 2, i32 2
  %power30.i197.i = getelementptr inbounds %struct.DTD, ptr %23, i64 0, i32 2, i32 1
  br label %while.cond.i160.i

while.cond.i160.i:                                ; preds = %while.cond.i160.i.backedge, %hashTableIterInit.exit157.i
  %incdec.ptr5.i161.i = phi ptr [ %94, %hashTableIterInit.exit157.i ], [ %incdec.ptr.i164.i, %while.cond.i160.i.backedge ]
  %cmp.not.i162.i = icmp eq ptr %incdec.ptr5.i161.i, %cond.i155.i
  br i1 %cmp.not.i162.i, label %for.end148.i, label %while.body.i163.i

while.body.i163.i:                                ; preds = %while.cond.i160.i
  %incdec.ptr.i164.i = getelementptr ptr, ptr %incdec.ptr5.i161.i, i64 1
  %96 = load ptr, ptr %incdec.ptr5.i161.i, align 8
  %tobool.not.i165.i = icmp eq ptr %96, null
  br i1 %tobool.not.i165.i, label %while.cond.i160.i.backedge, label %if.end60.i

while.cond.i160.i.backedge:                       ; preds = %for.inc.i, %while.body.i163.i, %if.end99.i
  br label %while.cond.i160.i, !llvm.loop !9

if.end60.i:                                       ; preds = %while.body.i163.i
  %97 = load ptr, ptr %96, align 8
  br label %do.body.i170.i

do.body.i170.i:                                   ; preds = %cond.false.i173.i, %if.end60.i
  %s.addr.0.i171.i = phi ptr [ %97, %if.end60.i ], [ %incdec.ptr2.i175.i, %cond.false.i173.i ]
  %98 = load ptr, ptr %ptr.i.i, align 8
  %99 = load ptr, ptr %end.i108.i, align 8
  %cmp.i172.i = icmp eq ptr %98, %99
  br i1 %cmp.i172.i, label %land.lhs.true.i180.i, label %cond.false.i173.i

land.lhs.true.i180.i:                             ; preds = %do.body.i170.i
  %call.i181.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool.i), !range !13
  %tobool.not.i182.i = icmp eq i8 %call.i181.i, 0
  br i1 %tobool.not.i182.i, label %if.then58, label %land.lhs.true.cond.false_crit_edge.i183.i

land.lhs.true.cond.false_crit_edge.i183.i:        ; preds = %land.lhs.true.i180.i
  %.pre.i184.i = load ptr, ptr %ptr.i.i, align 8
  br label %cond.false.i173.i

cond.false.i173.i:                                ; preds = %land.lhs.true.cond.false_crit_edge.i183.i, %do.body.i170.i
  %100 = phi ptr [ %.pre.i184.i, %land.lhs.true.cond.false_crit_edge.i183.i ], [ %98, %do.body.i170.i ]
  %101 = load i8, ptr %s.addr.0.i171.i, align 1
  %incdec.ptr.i174.i = getelementptr i8, ptr %100, i64 1
  store ptr %incdec.ptr.i174.i, ptr %ptr.i.i, align 8
  store i8 %101, ptr %100, align 1
  %incdec.ptr2.i175.i = getelementptr i8, ptr %s.addr.0.i171.i, i64 1
  %102 = load i8, ptr %s.addr.0.i171.i, align 1
  %tobool3.not.i176.i = icmp eq i8 %102, 0
  br i1 %tobool3.not.i176.i, label %poolCopyString.exit185.i, label %do.body.i170.i, !llvm.loop !12

poolCopyString.exit185.i:                         ; preds = %cond.false.i173.i
  %103 = load ptr, ptr %start.i350.i, align 8
  %104 = load ptr, ptr %ptr.i.i, align 8
  store ptr %104, ptr %start.i350.i, align 8
  %tobool64.not.i = icmp eq ptr %103, null
  br i1 %tobool64.not.i, label %if.then58, label %if.end66.i

if.end66.i:                                       ; preds = %poolCopyString.exit185.i
  %call68.i = call fastcc ptr @lookup(ptr noundef %oldParser, ptr noundef nonnull %elementTypes67.i, ptr noundef nonnull %103, i64 noundef 40)
  %tobool69.not.i = icmp eq ptr %call68.i, null
  br i1 %tobool69.not.i, label %if.then58, label %if.end71.i

if.end71.i:                                       ; preds = %if.end66.i
  %nDefaultAtts.i = getelementptr inbounds %struct.ELEMENT_TYPE, ptr %96, i64 0, i32 3
  %105 = load i32, ptr %nDefaultAtts.i, align 8
  %tobool72.not.i = icmp eq i32 %105, 0
  br i1 %tobool72.not.i, label %if.end80.i, label %if.then73.i

if.then73.i:                                      ; preds = %if.end71.i
  %106 = load ptr, ptr %m_mem53, align 8
  %conv.i = sext i32 %105 to i64
  %mul.i = mul nsw i64 %conv.i, 24
  %call75.i = call ptr %106(i64 noundef %mul.i) #24
  %defaultAtts.i = getelementptr inbounds %struct.ELEMENT_TYPE, ptr %call68.i, i64 0, i32 5
  store ptr %call75.i, ptr %defaultAtts.i, align 8
  %tobool77.not.i = icmp eq ptr %call75.i, null
  br i1 %tobool77.not.i, label %if.then58, label %if.end80.i

if.end80.i:                                       ; preds = %if.then73.i, %if.end71.i
  %idAtt.i = getelementptr inbounds %struct.ELEMENT_TYPE, ptr %96, i64 0, i32 2
  %107 = load ptr, ptr %idAtt.i, align 8
  %tobool81.not.i = icmp eq ptr %107, null
  br i1 %tobool81.not.i, label %if.end88.i, label %if.then82.i

if.then82.i:                                      ; preds = %if.end80.i
  %108 = load ptr, ptr %107, align 8
  %109 = load i64, ptr %size.i186.i, align 8
  %cmp.i187.i = icmp eq i64 %109, 0
  br i1 %cmp.i187.i, label %lookup.exit233.i, label %if.else.i188.i

if.else.i188.i:                                   ; preds = %if.then82.i
  %call12.i189.i = call fastcc i64 @hash(ptr noundef %oldParser, ptr noundef %108)
  %110 = load i64, ptr %size.i186.i, align 8
  %sub14.i190.i = add i64 %110, -1
  %and15.i191.i = and i64 %sub14.i190.i, %call12.i189.i
  %111 = load ptr, ptr %attributeIds33.i, align 8
  %arrayidx111.i192.i = getelementptr ptr, ptr %111, i64 %and15.i191.i
  %112 = load ptr, ptr %arrayidx111.i192.i, align 8
  %tobool17.not112.i193.i = icmp eq ptr %112, null
  br i1 %tobool17.not112.i193.i, label %lookup.exit233.i, label %while.body.lr.ph.i194.i

while.body.lr.ph.i194.i:                          ; preds = %if.else.i188.i
  %113 = load i8, ptr %108, align 1
  %not.i195.i = sub i64 0, %110
  %and29.i196.i = and i64 %call12.i189.i, %not.i195.i
  %shr32.i198.i = lshr i64 %sub14.i190.i, 2
  br label %while.body.i199.i

while.body.i199.i:                                ; preds = %if.end35.i205.i, %while.body.lr.ph.i194.i
  %114 = phi ptr [ %112, %while.body.lr.ph.i194.i ], [ %122, %if.end35.i205.i ]
  %i.0114.i200.i = phi i64 [ %and15.i191.i, %while.body.lr.ph.i194.i ], [ %i.1.i211.i, %if.end35.i205.i ]
  %step.0113.i201.i = phi i8 [ 0, %while.body.lr.ph.i194.i ], [ %step.1.i206.i, %if.end35.i205.i ]
  %115 = load ptr, ptr %114, align 8
  %116 = load i8, ptr %115, align 1
  %cmp5.i.i202.i = icmp eq i8 %113, %116
  br i1 %cmp5.i.i202.i, label %for.body.i.i224.i, label %if.end26.i203.i

for.body.i.i224.i:                                ; preds = %while.body.i199.i, %for.inc.i.i228.i
  %117 = phi i8 [ %118, %for.inc.i.i228.i ], [ %113, %while.body.i199.i ]
  %s2.addr.07.i.i225.i = phi ptr [ %incdec.ptr6.i.i230.i, %for.inc.i.i228.i ], [ %115, %while.body.i199.i ]
  %s1.addr.06.i.i226.i = phi ptr [ %incdec.ptr.i.i229.i, %for.inc.i.i228.i ], [ %108, %while.body.i199.i ]
  %cmp4.i.i227.i = icmp eq i8 %117, 0
  br i1 %cmp4.i.i227.i, label %lookup.exit233.i, label %for.inc.i.i228.i

for.inc.i.i228.i:                                 ; preds = %for.body.i.i224.i
  %incdec.ptr.i.i229.i = getelementptr i8, ptr %s1.addr.06.i.i226.i, i64 1
  %incdec.ptr6.i.i230.i = getelementptr i8, ptr %s2.addr.07.i.i225.i, i64 1
  %118 = load i8, ptr %incdec.ptr.i.i229.i, align 1
  %119 = load i8, ptr %incdec.ptr6.i.i230.i, align 1
  %cmp.i.i231.i = icmp eq i8 %118, %119
  br i1 %cmp.i.i231.i, label %for.body.i.i224.i, label %if.end26.i203.i, !llvm.loop !14

if.end26.i203.i:                                  ; preds = %for.inc.i.i228.i, %while.body.i199.i
  %tobool27.not.i204.i = icmp eq i8 %step.0113.i201.i, 0
  br i1 %tobool27.not.i204.i, label %if.then28.i217.i, label %if.end35.i205.i

if.then28.i217.i:                                 ; preds = %if.end26.i203.i
  %120 = load i8, ptr %power30.i197.i, align 8
  %conv.i218.i = zext i8 %120 to i64
  %sub31.i219.i = add nuw nsw i64 %conv.i218.i, 4294967295
  %sh_prom.i220.i = and i64 %sub31.i219.i, 4294967295
  %shr.i221.i = lshr i64 %and29.i196.i, %sh_prom.i220.i
  %and33.i222.i = and i64 %shr.i221.i, %shr32.i198.i
  %121 = trunc i64 %and33.i222.i to i8
  %conv34.i223.i = or i8 %121, 1
  br label %if.end35.i205.i

if.end35.i205.i:                                  ; preds = %if.then28.i217.i, %if.end26.i203.i
  %step.1.i206.i = phi i8 [ %step.0113.i201.i, %if.end26.i203.i ], [ %conv34.i223.i, %if.then28.i217.i ]
  %conv36.i207.i = zext i8 %step.1.i206.i to i64
  %cmp37.i208.i = icmp ult i64 %i.0114.i200.i, %conv36.i207.i
  %i.1.p.v.i209.i = select i1 %cmp37.i208.i, i64 %110, i64 0
  %i.1.p.i210.i = sub i64 %i.0114.i200.i, %conv36.i207.i
  %i.1.i211.i = add i64 %i.1.p.v.i209.i, %i.1.p.i210.i
  %arrayidx.i212.i = getelementptr ptr, ptr %111, i64 %i.1.i211.i
  %122 = load ptr, ptr %arrayidx.i212.i, align 8
  %tobool17.not.i213.i = icmp eq ptr %122, null
  br i1 %tobool17.not.i213.i, label %lookup.exit233.i, label %while.body.i199.i, !llvm.loop !15

lookup.exit233.i:                                 ; preds = %if.end35.i205.i, %for.body.i.i224.i, %if.else.i188.i, %if.then82.i
  %retval.0.i216.i = phi ptr [ null, %if.then82.i ], [ null, %if.else.i188.i ], [ %114, %for.body.i.i224.i ], [ null, %if.end35.i205.i ]
  %idAtt87.i = getelementptr inbounds %struct.ELEMENT_TYPE, ptr %call68.i, i64 0, i32 2
  store ptr %retval.0.i216.i, ptr %idAtt87.i, align 8
  br label %if.end88.i

if.end88.i:                                       ; preds = %lookup.exit233.i, %if.end80.i
  %123 = load i32, ptr %nDefaultAtts.i, align 8
  %nDefaultAtts90.i = getelementptr inbounds %struct.ELEMENT_TYPE, ptr %call68.i, i64 0, i32 3
  store i32 %123, ptr %nDefaultAtts90.i, align 8
  %allocDefaultAtts.i = getelementptr inbounds %struct.ELEMENT_TYPE, ptr %call68.i, i64 0, i32 4
  store i32 %123, ptr %allocDefaultAtts.i, align 4
  %prefix91.i = getelementptr inbounds %struct.ELEMENT_TYPE, ptr %96, i64 0, i32 1
  %124 = load ptr, ptr %prefix91.i, align 8
  %tobool92.not.i = icmp eq ptr %124, null
  br i1 %tobool92.not.i, label %if.end99.i, label %if.then93.i

if.then93.i:                                      ; preds = %if.end88.i
  %125 = load ptr, ptr %124, align 8
  %126 = load i64, ptr %size.i147.i, align 8
  %cmp.i235.i = icmp eq i64 %126, 0
  br i1 %cmp.i235.i, label %lookup.exit281.i, label %if.else.i236.i

if.else.i236.i:                                   ; preds = %if.then93.i
  %call12.i237.i = call fastcc i64 @hash(ptr noundef %oldParser, ptr noundef %125)
  %127 = load i64, ptr %size.i147.i, align 8
  %sub14.i238.i = add i64 %127, -1
  %and15.i239.i = and i64 %sub14.i238.i, %call12.i237.i
  %128 = load ptr, ptr %prefixes6.i, align 8
  %arrayidx111.i240.i = getelementptr ptr, ptr %128, i64 %and15.i239.i
  %129 = load ptr, ptr %arrayidx111.i240.i, align 8
  %tobool17.not112.i241.i = icmp eq ptr %129, null
  br i1 %tobool17.not112.i241.i, label %lookup.exit281.i, label %while.body.lr.ph.i242.i

while.body.lr.ph.i242.i:                          ; preds = %if.else.i236.i
  %130 = load i8, ptr %125, align 1
  %not.i243.i = sub i64 0, %127
  %and29.i244.i = and i64 %call12.i237.i, %not.i243.i
  %shr32.i246.i = lshr i64 %sub14.i238.i, 2
  br label %while.body.i247.i

while.body.i247.i:                                ; preds = %if.end35.i253.i, %while.body.lr.ph.i242.i
  %131 = phi ptr [ %129, %while.body.lr.ph.i242.i ], [ %139, %if.end35.i253.i ]
  %i.0114.i248.i = phi i64 [ %and15.i239.i, %while.body.lr.ph.i242.i ], [ %i.1.i259.i, %if.end35.i253.i ]
  %step.0113.i249.i = phi i8 [ 0, %while.body.lr.ph.i242.i ], [ %step.1.i254.i, %if.end35.i253.i ]
  %132 = load ptr, ptr %131, align 8
  %133 = load i8, ptr %132, align 1
  %cmp5.i.i250.i = icmp eq i8 %130, %133
  br i1 %cmp5.i.i250.i, label %for.body.i.i272.i, label %if.end26.i251.i

for.body.i.i272.i:                                ; preds = %while.body.i247.i, %for.inc.i.i276.i
  %134 = phi i8 [ %135, %for.inc.i.i276.i ], [ %130, %while.body.i247.i ]
  %s2.addr.07.i.i273.i = phi ptr [ %incdec.ptr6.i.i278.i, %for.inc.i.i276.i ], [ %132, %while.body.i247.i ]
  %s1.addr.06.i.i274.i = phi ptr [ %incdec.ptr.i.i277.i, %for.inc.i.i276.i ], [ %125, %while.body.i247.i ]
  %cmp4.i.i275.i = icmp eq i8 %134, 0
  br i1 %cmp4.i.i275.i, label %lookup.exit281.i, label %for.inc.i.i276.i

for.inc.i.i276.i:                                 ; preds = %for.body.i.i272.i
  %incdec.ptr.i.i277.i = getelementptr i8, ptr %s1.addr.06.i.i274.i, i64 1
  %incdec.ptr6.i.i278.i = getelementptr i8, ptr %s2.addr.07.i.i273.i, i64 1
  %135 = load i8, ptr %incdec.ptr.i.i277.i, align 1
  %136 = load i8, ptr %incdec.ptr6.i.i278.i, align 1
  %cmp.i.i279.i = icmp eq i8 %135, %136
  br i1 %cmp.i.i279.i, label %for.body.i.i272.i, label %if.end26.i251.i, !llvm.loop !14

if.end26.i251.i:                                  ; preds = %for.inc.i.i276.i, %while.body.i247.i
  %tobool27.not.i252.i = icmp eq i8 %step.0113.i249.i, 0
  br i1 %tobool27.not.i252.i, label %if.then28.i265.i, label %if.end35.i253.i

if.then28.i265.i:                                 ; preds = %if.end26.i251.i
  %137 = load i8, ptr %power30.i.i, align 8
  %conv.i266.i = zext i8 %137 to i64
  %sub31.i267.i = add nuw nsw i64 %conv.i266.i, 4294967295
  %sh_prom.i268.i = and i64 %sub31.i267.i, 4294967295
  %shr.i269.i = lshr i64 %and29.i244.i, %sh_prom.i268.i
  %and33.i270.i = and i64 %shr.i269.i, %shr32.i246.i
  %138 = trunc i64 %and33.i270.i to i8
  %conv34.i271.i = or i8 %138, 1
  br label %if.end35.i253.i

if.end35.i253.i:                                  ; preds = %if.then28.i265.i, %if.end26.i251.i
  %step.1.i254.i = phi i8 [ %step.0113.i249.i, %if.end26.i251.i ], [ %conv34.i271.i, %if.then28.i265.i ]
  %conv36.i255.i = zext i8 %step.1.i254.i to i64
  %cmp37.i256.i = icmp ult i64 %i.0114.i248.i, %conv36.i255.i
  %i.1.p.v.i257.i = select i1 %cmp37.i256.i, i64 %127, i64 0
  %i.1.p.i258.i = sub i64 %i.0114.i248.i, %conv36.i255.i
  %i.1.i259.i = add i64 %i.1.p.v.i257.i, %i.1.p.i258.i
  %arrayidx.i260.i = getelementptr ptr, ptr %128, i64 %i.1.i259.i
  %139 = load ptr, ptr %arrayidx.i260.i, align 8
  %tobool17.not.i261.i = icmp eq ptr %139, null
  br i1 %tobool17.not.i261.i, label %lookup.exit281.i, label %while.body.i247.i, !llvm.loop !15

lookup.exit281.i:                                 ; preds = %if.end35.i253.i, %for.body.i.i272.i, %if.else.i236.i, %if.then93.i
  %retval.0.i264.i = phi ptr [ null, %if.then93.i ], [ null, %if.else.i236.i ], [ %131, %for.body.i.i272.i ], [ null, %if.end35.i253.i ]
  %prefix98.i = getelementptr inbounds %struct.ELEMENT_TYPE, ptr %call68.i, i64 0, i32 1
  store ptr %retval.0.i264.i, ptr %prefix98.i, align 8
  %.pre423.i = load i32, ptr %nDefaultAtts90.i, align 8
  br label %if.end99.i

if.end99.i:                                       ; preds = %lookup.exit281.i, %if.end88.i
  %140 = phi i32 [ %.pre423.i, %lookup.exit281.i ], [ %123, %if.end88.i ]
  %cmp102399.i = icmp sgt i32 %140, 0
  br i1 %cmp102399.i, label %for.body.lr.ph.i, label %while.cond.i160.i.backedge

for.body.lr.ph.i:                                 ; preds = %if.end99.i
  %defaultAtts105.i = getelementptr inbounds %struct.ELEMENT_TYPE, ptr %96, i64 0, i32 5
  %defaultAtts108.i = getelementptr inbounds %struct.ELEMENT_TYPE, ptr %call68.i, i64 0, i32 5
  br label %for.body.i

for.body.i:                                       ; preds = %for.inc.i, %for.body.lr.ph.i
  %indvars.iv.i = phi i64 [ 0, %for.body.lr.ph.i ], [ %indvars.iv.next.i, %for.inc.i ]
  %141 = load ptr, ptr %defaultAtts105.i, align 8
  %arrayidx.i = getelementptr %struct.DEFAULT_ATTRIBUTE, ptr %141, i64 %indvars.iv.i
  %142 = load ptr, ptr %arrayidx.i, align 8
  %143 = load ptr, ptr %142, align 8
  %144 = load i64, ptr %size.i186.i, align 8
  %cmp.i283.i = icmp eq i64 %144, 0
  br i1 %cmp.i283.i, label %lookup.exit329.i, label %if.else.i284.i

if.else.i284.i:                                   ; preds = %for.body.i
  %call12.i285.i = call fastcc i64 @hash(ptr noundef %oldParser, ptr noundef %143)
  %145 = load i64, ptr %size.i186.i, align 8
  %sub14.i286.i = add i64 %145, -1
  %and15.i287.i = and i64 %sub14.i286.i, %call12.i285.i
  %146 = load ptr, ptr %attributeIds33.i, align 8
  %arrayidx111.i288.i = getelementptr ptr, ptr %146, i64 %and15.i287.i
  %147 = load ptr, ptr %arrayidx111.i288.i, align 8
  %tobool17.not112.i289.i = icmp eq ptr %147, null
  br i1 %tobool17.not112.i289.i, label %lookup.exit329.i, label %while.body.lr.ph.i290.i

while.body.lr.ph.i290.i:                          ; preds = %if.else.i284.i
  %148 = load i8, ptr %143, align 1
  %not.i291.i = sub i64 0, %145
  %and29.i292.i = and i64 %call12.i285.i, %not.i291.i
  %shr32.i294.i = lshr i64 %sub14.i286.i, 2
  br label %while.body.i295.i

while.body.i295.i:                                ; preds = %if.end35.i301.i, %while.body.lr.ph.i290.i
  %149 = phi ptr [ %147, %while.body.lr.ph.i290.i ], [ %157, %if.end35.i301.i ]
  %i.0114.i296.i = phi i64 [ %and15.i287.i, %while.body.lr.ph.i290.i ], [ %i.1.i307.i, %if.end35.i301.i ]
  %step.0113.i297.i = phi i8 [ 0, %while.body.lr.ph.i290.i ], [ %step.1.i302.i, %if.end35.i301.i ]
  %150 = load ptr, ptr %149, align 8
  %151 = load i8, ptr %150, align 1
  %cmp5.i.i298.i = icmp eq i8 %148, %151
  br i1 %cmp5.i.i298.i, label %for.body.i.i320.i, label %if.end26.i299.i

for.body.i.i320.i:                                ; preds = %while.body.i295.i, %for.inc.i.i324.i
  %152 = phi i8 [ %153, %for.inc.i.i324.i ], [ %148, %while.body.i295.i ]
  %s2.addr.07.i.i321.i = phi ptr [ %incdec.ptr6.i.i326.i, %for.inc.i.i324.i ], [ %150, %while.body.i295.i ]
  %s1.addr.06.i.i322.i = phi ptr [ %incdec.ptr.i.i325.i, %for.inc.i.i324.i ], [ %143, %while.body.i295.i ]
  %cmp4.i.i323.i = icmp eq i8 %152, 0
  br i1 %cmp4.i.i323.i, label %lookup.exit329.i, label %for.inc.i.i324.i

for.inc.i.i324.i:                                 ; preds = %for.body.i.i320.i
  %incdec.ptr.i.i325.i = getelementptr i8, ptr %s1.addr.06.i.i322.i, i64 1
  %incdec.ptr6.i.i326.i = getelementptr i8, ptr %s2.addr.07.i.i321.i, i64 1
  %153 = load i8, ptr %incdec.ptr.i.i325.i, align 1
  %154 = load i8, ptr %incdec.ptr6.i.i326.i, align 1
  %cmp.i.i327.i = icmp eq i8 %153, %154
  br i1 %cmp.i.i327.i, label %for.body.i.i320.i, label %if.end26.i299.i, !llvm.loop !14

if.end26.i299.i:                                  ; preds = %for.inc.i.i324.i, %while.body.i295.i
  %tobool27.not.i300.i = icmp eq i8 %step.0113.i297.i, 0
  br i1 %tobool27.not.i300.i, label %if.then28.i313.i, label %if.end35.i301.i

if.then28.i313.i:                                 ; preds = %if.end26.i299.i
  %155 = load i8, ptr %power30.i197.i, align 8
  %conv.i314.i = zext i8 %155 to i64
  %sub31.i315.i = add nuw nsw i64 %conv.i314.i, 4294967295
  %sh_prom.i316.i = and i64 %sub31.i315.i, 4294967295
  %shr.i317.i = lshr i64 %and29.i292.i, %sh_prom.i316.i
  %and33.i318.i = and i64 %shr.i317.i, %shr32.i294.i
  %156 = trunc i64 %and33.i318.i to i8
  %conv34.i319.i = or i8 %156, 1
  br label %if.end35.i301.i

if.end35.i301.i:                                  ; preds = %if.then28.i313.i, %if.end26.i299.i
  %step.1.i302.i = phi i8 [ %step.0113.i297.i, %if.end26.i299.i ], [ %conv34.i319.i, %if.then28.i313.i ]
  %conv36.i303.i = zext i8 %step.1.i302.i to i64
  %cmp37.i304.i = icmp ult i64 %i.0114.i296.i, %conv36.i303.i
  %i.1.p.v.i305.i = select i1 %cmp37.i304.i, i64 %145, i64 0
  %i.1.p.i306.i = sub i64 %i.0114.i296.i, %conv36.i303.i
  %i.1.i307.i = add i64 %i.1.p.v.i305.i, %i.1.p.i306.i
  %arrayidx.i308.i = getelementptr ptr, ptr %146, i64 %i.1.i307.i
  %157 = load ptr, ptr %arrayidx.i308.i, align 8
  %tobool17.not.i309.i = icmp eq ptr %157, null
  br i1 %tobool17.not.i309.i, label %lookup.exit329.i, label %while.body.i295.i, !llvm.loop !15

lookup.exit329.i:                                 ; preds = %if.end35.i301.i, %for.body.i.i320.i, %if.else.i284.i, %for.body.i
  %retval.0.i312.i = phi ptr [ null, %for.body.i ], [ null, %if.else.i284.i ], [ %149, %for.body.i.i320.i ], [ null, %if.end35.i301.i ]
  %158 = load ptr, ptr %defaultAtts108.i, align 8
  %arrayidx110.i = getelementptr %struct.DEFAULT_ATTRIBUTE, ptr %158, i64 %indvars.iv.i
  store ptr %retval.0.i312.i, ptr %arrayidx110.i, align 8
  %159 = load ptr, ptr %defaultAtts105.i, align 8
  %isCdata.i = getelementptr %struct.DEFAULT_ATTRIBUTE, ptr %159, i64 %indvars.iv.i, i32 1
  %160 = load i8, ptr %isCdata.i, align 8
  %161 = load ptr, ptr %defaultAtts108.i, align 8
  %isCdata118.i = getelementptr %struct.DEFAULT_ATTRIBUTE, ptr %161, i64 %indvars.iv.i, i32 1
  store i8 %160, ptr %isCdata118.i, align 8
  %162 = load ptr, ptr %defaultAtts105.i, align 8
  %value.i = getelementptr %struct.DEFAULT_ATTRIBUTE, ptr %162, i64 %indvars.iv.i, i32 2
  %163 = load ptr, ptr %value.i, align 8
  %tobool122.not.i = icmp eq ptr %163, null
  br i1 %tobool122.not.i, label %if.else141.i, label %do.body.i332.i

do.body.i332.i:                                   ; preds = %lookup.exit329.i, %cond.false.i335.i
  %s.addr.0.i333.i = phi ptr [ %incdec.ptr2.i337.i, %cond.false.i335.i ], [ %163, %lookup.exit329.i ]
  %164 = load ptr, ptr %ptr.i.i, align 8
  %165 = load ptr, ptr %end.i108.i, align 8
  %cmp.i334.i = icmp eq ptr %164, %165
  br i1 %cmp.i334.i, label %land.lhs.true.i342.i, label %cond.false.i335.i

land.lhs.true.i342.i:                             ; preds = %do.body.i332.i
  %call.i343.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool.i), !range !13
  %tobool.not.i344.i = icmp eq i8 %call.i343.i, 0
  br i1 %tobool.not.i344.i, label %poolCopyString.exit347.i, label %land.lhs.true.cond.false_crit_edge.i345.i

land.lhs.true.cond.false_crit_edge.i345.i:        ; preds = %land.lhs.true.i342.i
  %.pre.i346.i = load ptr, ptr %ptr.i.i, align 8
  br label %cond.false.i335.i

cond.false.i335.i:                                ; preds = %land.lhs.true.cond.false_crit_edge.i345.i, %do.body.i332.i
  %166 = phi ptr [ %.pre.i346.i, %land.lhs.true.cond.false_crit_edge.i345.i ], [ %164, %do.body.i332.i ]
  %167 = load i8, ptr %s.addr.0.i333.i, align 1
  %incdec.ptr.i336.i = getelementptr i8, ptr %166, i64 1
  store ptr %incdec.ptr.i336.i, ptr %ptr.i.i, align 8
  store i8 %167, ptr %166, align 1
  %incdec.ptr2.i337.i = getelementptr i8, ptr %s.addr.0.i333.i, i64 1
  %168 = load i8, ptr %s.addr.0.i333.i, align 1
  %tobool3.not.i338.i = icmp eq i8 %168, 0
  br i1 %tobool3.not.i338.i, label %do.end.i339.i, label %do.body.i332.i, !llvm.loop !12

do.end.i339.i:                                    ; preds = %cond.false.i335.i
  %169 = load ptr, ptr %start.i350.i, align 8
  %170 = load ptr, ptr %ptr.i.i, align 8
  store ptr %170, ptr %start.i350.i, align 8
  br label %poolCopyString.exit347.i

poolCopyString.exit347.i:                         ; preds = %land.lhs.true.i342.i, %do.end.i339.i
  %retval.0.i341.i = phi ptr [ %169, %do.end.i339.i ], [ null, %land.lhs.true.i342.i ]
  %171 = load ptr, ptr %defaultAtts108.i, align 8
  %value133.i = getelementptr %struct.DEFAULT_ATTRIBUTE, ptr %171, i64 %indvars.iv.i, i32 2
  store ptr %retval.0.i341.i, ptr %value133.i, align 8
  %172 = load ptr, ptr %defaultAtts108.i, align 8
  %value137.i = getelementptr %struct.DEFAULT_ATTRIBUTE, ptr %172, i64 %indvars.iv.i, i32 2
  %173 = load ptr, ptr %value137.i, align 8
  %tobool138.not.i = icmp eq ptr %173, null
  br i1 %tobool138.not.i, label %if.then58, label %for.inc.i

if.else141.i:                                     ; preds = %lookup.exit329.i
  %174 = load ptr, ptr %defaultAtts108.i, align 8
  %value145.i = getelementptr %struct.DEFAULT_ATTRIBUTE, ptr %174, i64 %indvars.iv.i, i32 2
  store ptr null, ptr %value145.i, align 8
  br label %for.inc.i

for.inc.i:                                        ; preds = %if.else141.i, %poolCopyString.exit347.i
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %175 = load i32, ptr %nDefaultAtts90.i, align 8
  %176 = sext i32 %175 to i64
  %cmp102.i = icmp slt i64 %indvars.iv.next.i, %176
  br i1 %cmp102.i, label %for.body.i, label %while.cond.i160.i.backedge, !llvm.loop !16

for.end148.i:                                     ; preds = %while.cond.i160.i
  %call151.i = call fastcc i32 @copyEntityTable(ptr noundef %oldParser, ptr noundef %23, ptr noundef nonnull %pool.i, ptr noundef %0), !range !17
  %tobool152.not.i = icmp eq i32 %call151.i, 0
  br i1 %tobool152.not.i, label %if.then58, label %if.end154.i

if.end154.i:                                      ; preds = %for.end148.i
  %paramEntities.i = getelementptr inbounds %struct.DTD, ptr %23, i64 0, i32 10
  %paramEntities156.i = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 10
  %call157.i = call fastcc i32 @copyEntityTable(ptr noundef %oldParser, ptr noundef nonnull %paramEntities.i, ptr noundef nonnull %pool.i, ptr noundef nonnull %paramEntities156.i), !range !17
  %tobool158.not.i = icmp eq i32 %call157.i, 0
  br i1 %tobool158.not.i, label %if.then58, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end154.i
  %paramEntityRead.i = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 9
  %177 = load i8, ptr %paramEntityRead.i, align 1
  %paramEntityRead161.i = getelementptr inbounds %struct.DTD, ptr %23, i64 0, i32 9
  store i8 %177, ptr %paramEntityRead161.i, align 1
  %keepProcessing.i = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 6
  %178 = load i8, ptr %keepProcessing.i, align 8
  %keepProcessing162.i = getelementptr inbounds %struct.DTD, ptr %23, i64 0, i32 6
  store i8 %178, ptr %keepProcessing162.i, align 8
  %hasParamEntityRefs.i = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 7
  %179 = load i8, ptr %hasParamEntityRefs.i, align 1
  %hasParamEntityRefs163.i = getelementptr inbounds %struct.DTD, ptr %23, i64 0, i32 7
  store i8 %179, ptr %hasParamEntityRefs163.i, align 1
  %standalone.i = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 8
  %180 = load i8, ptr %standalone.i, align 2
  %standalone164.i = getelementptr inbounds %struct.DTD, ptr %23, i64 0, i32 8
  store i8 %180, ptr %standalone164.i, align 2
  %in_eldecl.i = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 12
  %181 = load i8, ptr %in_eldecl.i, align 8
  %in_eldecl165.i = getelementptr inbounds %struct.DTD, ptr %23, i64 0, i32 12
  store i8 %181, ptr %in_eldecl165.i, align 8
  %scaffold.i = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 13
  %182 = load ptr, ptr %scaffold.i, align 8
  %scaffold166.i = getelementptr inbounds %struct.DTD, ptr %23, i64 0, i32 13
  store ptr %182, ptr %scaffold166.i, align 8
  %contentStringLen.i = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 14
  %183 = load i32, ptr %contentStringLen.i, align 8
  %contentStringLen167.i = getelementptr inbounds %struct.DTD, ptr %23, i64 0, i32 14
  store i32 %183, ptr %contentStringLen167.i, align 8
  %scaffSize.i = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 15
  %184 = load i32, ptr %scaffSize.i, align 4
  %scaffSize168.i = getelementptr inbounds %struct.DTD, ptr %23, i64 0, i32 15
  store i32 %184, ptr %scaffSize168.i, align 4
  %scaffLevel.i = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 17
  %185 = load i32, ptr %scaffLevel.i, align 4
  %scaffLevel169.i = getelementptr inbounds %struct.DTD, ptr %23, i64 0, i32 17
  store i32 %185, ptr %scaffLevel169.i, align 4
  %scaffIndex.i = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 18
  %186 = load ptr, ptr %scaffIndex.i, align 8
  %scaffIndex170.i = getelementptr inbounds %struct.DTD, ptr %23, i64 0, i32 18
  store ptr %186, ptr %scaffIndex170.i, align 8
  %call56 = call fastcc zeroext i8 @setContext(ptr noundef nonnull %parser.0, ptr noundef nonnull %context), !range !13
  %tobool57.not = icmp eq i8 %call56, 0
  br i1 %tobool57.not, label %if.then58, label %if.end59

if.then58:                                        ; preds = %if.end5.i, %poolCopyString.exit.i, %if.then66.i.i, %if.end82.i.i, %if.end86.i.i, %if.else.i354.i, %if.else127.i.i, %48, %if.end139.i.i, %if.end31.i, %poolCopyString.exit146.i, %land.lhs.true.i, %land.lhs.true.i141.i, %if.then73.i, %if.end66.i, %poolCopyString.exit185.i, %land.lhs.true.i180.i, %poolCopyString.exit347.i, %if.end154.i, %for.end148.i, %lor.lhs.false
  call void @PyExpat_XML_ParserFree(ptr noundef nonnull %parser.0)
  br label %return

if.end59:                                         ; preds = %lor.lhs.false
  %m_processor = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser.0, i64 0, i32 45
  store ptr @externalEntityInitProcessor, ptr %m_processor, align 8
  br label %return

if.else60:                                        ; preds = %if.end43
  %m_prologState48 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser.0, i64 0, i32 44
  %m_isParamEntity = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser.0, i64 0, i32 86
  store i8 1, ptr %m_isParamEntity, align 8
  call void @PyExpat_XmlPrologStateInitExternalEntity(ptr noundef nonnull %m_prologState48) #24
  %m_processor62 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser.0, i64 0, i32 45
  store ptr @externalParEntInitProcessor, ptr %m_processor62, align 8
  br label %return

return:                                           ; preds = %if.end59, %if.else60, %if.end7, %entry, %if.then58
  %retval.0 = phi ptr [ null, %if.then58 ], [ null, %entry ], [ null, %if.end7 ], [ %parser.0, %if.else60 ], [ %parser.0, %if.end59 ]
  ret ptr %retval.0
}

; Function Attrs: nounwind uwtable
define internal fastcc zeroext i8 @setContext(ptr nocapture noundef %parser, ptr nocapture noundef readonly %context) unnamed_addr #0 {
entry:
  %m_dtd = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 65
  %0 = load ptr, ptr %m_dtd, align 8
  %1 = load i8, ptr %context, align 1
  %cmp.not73 = icmp eq i8 %1, 0
  br i1 %cmp.not73, label %return, label %while.body.lr.ph

while.body.lr.ph:                                 ; preds = %entry
  %m_tempPool34 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 79
  %ptr35 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 79, i32 3
  %start37 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 79, i32 4
  %end45 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 79, i32 2
  %prefixes = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 3
  %pool = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 4
  %ptr.i = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 4, i32 3
  %end.i = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 4, i32 2
  %start.i = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 4, i32 4
  %defaultPrefix = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 11
  %m_inheritedBindings = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 69
  %size.i = getelementptr inbounds %struct.HASH_TABLE, ptr %0, i64 0, i32 2
  %power30.i = getelementptr inbounds %struct.HASH_TABLE, ptr %0, i64 0, i32 1
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %if.end161
  %s.075 = phi ptr [ %context, %while.body.lr.ph ], [ %s.2, %if.end161 ]
  %context.addr.074 = phi ptr [ %context, %while.body.lr.ph ], [ %context.addr.3, %if.end161 ]
  %2 = load i8, ptr %s.075, align 1
  switch i8 %2, label %if.else141 [
    i8 12, label %if.then
    i8 0, label %if.then
    i8 61, label %if.then33
  ]

if.then:                                          ; preds = %while.body, %while.body
  %3 = load ptr, ptr %ptr35, align 8
  %4 = load ptr, ptr %end45, align 8
  %cmp9 = icmp eq ptr %3, %4
  br i1 %cmp9, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %if.then
  %call = tail call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool34), !range !13
  %tobool.not = icmp eq i8 %call, 0
  br i1 %tobool.not, label %return, label %land.lhs.true.cond.false_crit_edge

land.lhs.true.cond.false_crit_edge:               ; preds = %land.lhs.true
  %.pre91 = load ptr, ptr %ptr35, align 8
  br label %cond.false

cond.false:                                       ; preds = %land.lhs.true.cond.false_crit_edge, %if.then
  %5 = phi ptr [ %.pre91, %land.lhs.true.cond.false_crit_edge ], [ %3, %if.then ]
  %incdec.ptr = getelementptr i8, ptr %5, i64 1
  store ptr %incdec.ptr, ptr %ptr35, align 8
  store i8 0, ptr %5, align 1
  %6 = load ptr, ptr %start37, align 8
  %7 = load i64, ptr %size.i, align 8
  %cmp.i = icmp eq i64 %7, 0
  br i1 %cmp.i, label %if.end19, label %if.else.i

if.else.i:                                        ; preds = %cond.false
  %call12.i = tail call fastcc i64 @hash(ptr noundef nonnull %parser, ptr noundef %6)
  %8 = load i64, ptr %size.i, align 8
  %sub14.i = add i64 %8, -1
  %and15.i = and i64 %sub14.i, %call12.i
  %9 = load ptr, ptr %0, align 8
  %arrayidx111.i = getelementptr ptr, ptr %9, i64 %and15.i
  %10 = load ptr, ptr %arrayidx111.i, align 8
  %tobool17.not112.i = icmp eq ptr %10, null
  br i1 %tobool17.not112.i, label %if.end19, label %while.body.lr.ph.i

while.body.lr.ph.i:                               ; preds = %if.else.i
  %11 = load i8, ptr %6, align 1
  %not.i = sub i64 0, %8
  %and29.i = and i64 %call12.i, %not.i
  %shr32.i = lshr i64 %sub14.i, 2
  br label %while.body.i

while.body.i:                                     ; preds = %if.end35.i, %while.body.lr.ph.i
  %12 = phi ptr [ %10, %while.body.lr.ph.i ], [ %20, %if.end35.i ]
  %i.0114.i = phi i64 [ %and15.i, %while.body.lr.ph.i ], [ %i.1.i, %if.end35.i ]
  %step.0113.i = phi i8 [ 0, %while.body.lr.ph.i ], [ %step.1.i, %if.end35.i ]
  %13 = load ptr, ptr %12, align 8
  %14 = load i8, ptr %13, align 1
  %cmp5.i.i = icmp eq i8 %11, %14
  br i1 %cmp5.i.i, label %for.body.i.i, label %if.end26.i

for.body.i.i:                                     ; preds = %while.body.i, %for.inc.i.i
  %15 = phi i8 [ %16, %for.inc.i.i ], [ %11, %while.body.i ]
  %s2.addr.07.i.i = phi ptr [ %incdec.ptr6.i.i, %for.inc.i.i ], [ %13, %while.body.i ]
  %s1.addr.06.i.i = phi ptr [ %incdec.ptr.i.i, %for.inc.i.i ], [ %6, %while.body.i ]
  %cmp4.i.i = icmp eq i8 %15, 0
  br i1 %cmp4.i.i, label %if.then18, label %for.inc.i.i

for.inc.i.i:                                      ; preds = %for.body.i.i
  %incdec.ptr.i.i = getelementptr i8, ptr %s1.addr.06.i.i, i64 1
  %incdec.ptr6.i.i = getelementptr i8, ptr %s2.addr.07.i.i, i64 1
  %16 = load i8, ptr %incdec.ptr.i.i, align 1
  %17 = load i8, ptr %incdec.ptr6.i.i, align 1
  %cmp.i.i = icmp eq i8 %16, %17
  br i1 %cmp.i.i, label %for.body.i.i, label %if.end26.i, !llvm.loop !14

if.end26.i:                                       ; preds = %for.inc.i.i, %while.body.i
  %tobool27.not.i = icmp eq i8 %step.0113.i, 0
  br i1 %tobool27.not.i, label %if.then28.i, label %if.end35.i

if.then28.i:                                      ; preds = %if.end26.i
  %18 = load i8, ptr %power30.i, align 8
  %conv.i = zext i8 %18 to i64
  %sub31.i = add nuw nsw i64 %conv.i, 4294967295
  %sh_prom.i = and i64 %sub31.i, 4294967295
  %shr.i = lshr i64 %and29.i, %sh_prom.i
  %and33.i = and i64 %shr.i, %shr32.i
  %19 = trunc i64 %and33.i to i8
  %conv34.i = or i8 %19, 1
  br label %if.end35.i

if.end35.i:                                       ; preds = %if.then28.i, %if.end26.i
  %step.1.i = phi i8 [ %step.0113.i, %if.end26.i ], [ %conv34.i, %if.then28.i ]
  %conv36.i = zext i8 %step.1.i to i64
  %cmp37.i = icmp ult i64 %i.0114.i, %conv36.i
  %i.1.p.v.i = select i1 %cmp37.i, i64 %8, i64 0
  %i.1.p.i = sub i64 %i.0114.i, %conv36.i
  %i.1.i = add i64 %i.1.p.v.i, %i.1.p.i
  %arrayidx.i = getelementptr ptr, ptr %9, i64 %i.1.i
  %20 = load ptr, ptr %arrayidx.i, align 8
  %tobool17.not.i = icmp eq ptr %20, null
  br i1 %tobool17.not.i, label %if.end19, label %while.body.i, !llvm.loop !15

if.then18:                                        ; preds = %for.body.i.i
  %open = getelementptr inbounds %struct.ENTITY, ptr %12, i64 0, i32 8
  store i8 1, ptr %open, align 8
  br label %if.end19

if.end19:                                         ; preds = %if.end35.i, %if.else.i, %cond.false, %if.then18
  %21 = load i8, ptr %s.075, align 1
  %cmp21.not = icmp ne i8 %21, 0
  %spec.select.idx = zext i1 %cmp21.not to i64
  %spec.select = getelementptr i8, ptr %s.075, i64 %spec.select.idx
  %22 = load ptr, ptr %start37, align 8
  store ptr %22, ptr %ptr35, align 8
  br label %if.end161

if.then33:                                        ; preds = %while.body
  %23 = load ptr, ptr %ptr35, align 8
  %24 = load ptr, ptr %start37, align 8
  %cmp38 = icmp eq ptr %23, %24
  br i1 %cmp38, label %if.end82, label %if.else41

if.else41:                                        ; preds = %if.then33
  %25 = load ptr, ptr %end45, align 8
  %cmp46 = icmp eq ptr %23, %25
  br i1 %cmp46, label %land.lhs.true48, label %cond.false53

land.lhs.true48:                                  ; preds = %if.else41
  %call50 = tail call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool34), !range !13
  %tobool51.not = icmp eq i8 %call50, 0
  br i1 %tobool51.not, label %return, label %land.lhs.true48.cond.false53_crit_edge

land.lhs.true48.cond.false53_crit_edge:           ; preds = %land.lhs.true48
  %.pre = load ptr, ptr %ptr35, align 8
  br label %cond.false53

cond.false53:                                     ; preds = %land.lhs.true48.cond.false53_crit_edge, %if.else41
  %26 = phi ptr [ %.pre, %land.lhs.true48.cond.false53_crit_edge ], [ %23, %if.else41 ]
  %incdec.ptr56 = getelementptr i8, ptr %26, i64 1
  store ptr %incdec.ptr56, ptr %ptr35, align 8
  store i8 0, ptr %26, align 1
  %27 = load ptr, ptr %start37, align 8
  %call61 = tail call fastcc ptr @lookup(ptr noundef nonnull %parser, ptr noundef nonnull %prefixes, ptr noundef %27, i64 noundef 16)
  %tobool62.not = icmp eq ptr %call61, null
  br i1 %tobool62.not, label %return, label %if.end64

if.end64:                                         ; preds = %cond.false53
  %28 = load ptr, ptr %call61, align 8
  %29 = load ptr, ptr %start37, align 8
  %cmp67 = icmp eq ptr %28, %29
  br i1 %cmp67, label %do.body.i, label %if.end77

do.body.i:                                        ; preds = %if.end64, %cond.false.i
  %s.addr.0.i = phi ptr [ %incdec.ptr2.i, %cond.false.i ], [ %28, %if.end64 ]
  %30 = load ptr, ptr %ptr.i, align 8
  %31 = load ptr, ptr %end.i, align 8
  %cmp.i63 = icmp eq ptr %30, %31
  br i1 %cmp.i63, label %land.lhs.true.i, label %cond.false.i

land.lhs.true.i:                                  ; preds = %do.body.i
  %call.i = tail call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool), !range !13
  %tobool.not.i = icmp eq i8 %call.i, 0
  br i1 %tobool.not.i, label %poolCopyString.exit.thread, label %land.lhs.true.cond.false_crit_edge.i

poolCopyString.exit.thread:                       ; preds = %land.lhs.true.i
  store ptr null, ptr %call61, align 8
  br label %return

land.lhs.true.cond.false_crit_edge.i:             ; preds = %land.lhs.true.i
  %.pre.i = load ptr, ptr %ptr.i, align 8
  br label %cond.false.i

cond.false.i:                                     ; preds = %land.lhs.true.cond.false_crit_edge.i, %do.body.i
  %32 = phi ptr [ %.pre.i, %land.lhs.true.cond.false_crit_edge.i ], [ %30, %do.body.i ]
  %33 = load i8, ptr %s.addr.0.i, align 1
  %incdec.ptr.i = getelementptr i8, ptr %32, i64 1
  store ptr %incdec.ptr.i, ptr %ptr.i, align 8
  store i8 %33, ptr %32, align 1
  %incdec.ptr2.i = getelementptr i8, ptr %s.addr.0.i, i64 1
  %34 = load i8, ptr %s.addr.0.i, align 1
  %tobool3.not.i = icmp eq i8 %34, 0
  br i1 %tobool3.not.i, label %poolCopyString.exit, label %do.body.i, !llvm.loop !12

poolCopyString.exit:                              ; preds = %cond.false.i
  %35 = load ptr, ptr %start.i, align 8
  %36 = load ptr, ptr %ptr.i, align 8
  store ptr %36, ptr %start.i, align 8
  store ptr %35, ptr %call61, align 8
  %tobool74.not = icmp eq ptr %35, null
  br i1 %tobool74.not, label %return, label %poolCopyString.exit.if.end77_crit_edge

poolCopyString.exit.if.end77_crit_edge:           ; preds = %poolCopyString.exit
  %.pre87 = load ptr, ptr %start37, align 8
  br label %if.end77

if.end77:                                         ; preds = %poolCopyString.exit.if.end77_crit_edge, %if.end64
  %37 = phi ptr [ %.pre87, %poolCopyString.exit.if.end77_crit_edge ], [ %29, %if.end64 ]
  store ptr %37, ptr %ptr35, align 8
  br label %if.end82

if.end82:                                         ; preds = %if.then33, %if.end77
  %prefix.0 = phi ptr [ %call61, %if.end77 ], [ %defaultPrefix, %if.then33 ]
  br label %for.cond

for.cond:                                         ; preds = %cond.false100, %if.end82
  %s.0.pn = phi ptr [ %s.075, %if.end82 ], [ %context.addr.1, %cond.false100 ]
  %context.addr.1 = getelementptr i8, ptr %s.0.pn, i64 1
  %38 = load i8, ptr %context.addr.1, align 1
  switch i8 %38, label %for.body [
    i8 12, label %for.end
    i8 0, label %for.end
  ]

for.body:                                         ; preds = %for.cond
  %39 = load ptr, ptr %ptr35, align 8
  %40 = load ptr, ptr %end45, align 8
  %cmp93 = icmp eq ptr %39, %40
  br i1 %cmp93, label %land.lhs.true95, label %cond.false100

land.lhs.true95:                                  ; preds = %for.body
  %call97 = tail call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool34), !range !13
  %tobool98.not = icmp eq i8 %call97, 0
  br i1 %tobool98.not, label %return, label %land.lhs.true95.cond.false100_crit_edge

land.lhs.true95.cond.false100_crit_edge:          ; preds = %land.lhs.true95
  %.pre89 = load i8, ptr %context.addr.1, align 1
  %.pre90 = load ptr, ptr %ptr35, align 8
  br label %cond.false100

cond.false100:                                    ; preds = %land.lhs.true95.cond.false100_crit_edge, %for.body
  %41 = phi ptr [ %.pre90, %land.lhs.true95.cond.false100_crit_edge ], [ %39, %for.body ]
  %42 = phi i8 [ %.pre89, %land.lhs.true95.cond.false100_crit_edge ], [ %38, %for.body ]
  %incdec.ptr103 = getelementptr i8, ptr %41, i64 1
  store ptr %incdec.ptr103, ptr %ptr35, align 8
  store i8 %42, ptr %41, align 1
  br label %for.cond, !llvm.loop !18

for.end:                                          ; preds = %for.cond, %for.cond
  %43 = load ptr, ptr %ptr35, align 8
  %44 = load ptr, ptr %end45, align 8
  %cmp111 = icmp eq ptr %43, %44
  br i1 %cmp111, label %land.lhs.true113, label %cond.false118

land.lhs.true113:                                 ; preds = %for.end
  %call115 = tail call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool34), !range !13
  %tobool116.not = icmp eq i8 %call115, 0
  br i1 %tobool116.not, label %return, label %land.lhs.true113.cond.false118_crit_edge

land.lhs.true113.cond.false118_crit_edge:         ; preds = %land.lhs.true113
  %.pre88 = load ptr, ptr %ptr35, align 8
  br label %cond.false118

cond.false118:                                    ; preds = %land.lhs.true113.cond.false118_crit_edge, %for.end
  %45 = phi ptr [ %.pre88, %land.lhs.true113.cond.false118_crit_edge ], [ %43, %for.end ]
  %incdec.ptr121 = getelementptr i8, ptr %45, i64 1
  store ptr %incdec.ptr121, ptr %ptr35, align 8
  store i8 0, ptr %45, align 1
  %46 = load ptr, ptr %start37, align 8
  %call126 = tail call fastcc i32 @addBinding(ptr noundef nonnull %parser, ptr noundef nonnull %prefix.0, ptr noundef null, ptr noundef %46, ptr noundef nonnull %m_inheritedBindings), !range !19
  %cmp127.not = icmp eq i32 %call126, 0
  br i1 %cmp127.not, label %if.end130, label %return

if.end130:                                        ; preds = %cond.false118
  %47 = load ptr, ptr %start37, align 8
  store ptr %47, ptr %ptr35, align 8
  %48 = load i8, ptr %context.addr.1, align 1
  %cmp136.not = icmp eq i8 %48, 0
  %incdec.ptr139 = getelementptr i8, ptr %s.0.pn, i64 2
  %spec.select62 = select i1 %cmp136.not, ptr %context.addr.1, ptr %incdec.ptr139
  br label %if.end161

if.else141:                                       ; preds = %while.body
  %49 = load ptr, ptr %ptr35, align 8
  %50 = load ptr, ptr %end45, align 8
  %cmp146 = icmp eq ptr %49, %50
  br i1 %cmp146, label %land.lhs.true148, label %cond.false153

land.lhs.true148:                                 ; preds = %if.else141
  %call150 = tail call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool34), !range !13
  %tobool151.not = icmp eq i8 %call150, 0
  br i1 %tobool151.not, label %return, label %land.lhs.true148.cond.false153_crit_edge

land.lhs.true148.cond.false153_crit_edge:         ; preds = %land.lhs.true148
  %.pre92 = load i8, ptr %s.075, align 1
  %.pre93 = load ptr, ptr %ptr35, align 8
  br label %cond.false153

cond.false153:                                    ; preds = %land.lhs.true148.cond.false153_crit_edge, %if.else141
  %51 = phi ptr [ %.pre93, %land.lhs.true148.cond.false153_crit_edge ], [ %49, %if.else141 ]
  %52 = phi i8 [ %.pre92, %land.lhs.true148.cond.false153_crit_edge ], [ %2, %if.else141 ]
  %incdec.ptr156 = getelementptr i8, ptr %51, i64 1
  store ptr %incdec.ptr156, ptr %ptr35, align 8
  store i8 %52, ptr %51, align 1
  %incdec.ptr159 = getelementptr i8, ptr %s.075, i64 1
  br label %if.end161

if.end161:                                        ; preds = %if.end130, %cond.false153, %if.end19
  %context.addr.3 = phi ptr [ %spec.select, %if.end19 ], [ %spec.select62, %if.end130 ], [ %context.addr.074, %cond.false153 ]
  %s.2 = phi ptr [ %spec.select, %if.end19 ], [ %spec.select62, %if.end130 ], [ %incdec.ptr159, %cond.false153 ]
  %53 = load i8, ptr %context.addr.3, align 1
  %cmp.not = icmp eq i8 %53, 0
  br i1 %cmp.not, label %return, label %while.body, !llvm.loop !20

return:                                           ; preds = %land.lhs.true, %land.lhs.true48, %cond.false53, %poolCopyString.exit, %land.lhs.true113, %cond.false118, %land.lhs.true148, %if.end161, %land.lhs.true95, %entry, %poolCopyString.exit.thread
  %retval.0 = phi i8 [ 0, %poolCopyString.exit.thread ], [ 1, %entry ], [ 0, %land.lhs.true95 ], [ 0, %land.lhs.true ], [ 0, %land.lhs.true48 ], [ 0, %cond.false53 ], [ 0, %poolCopyString.exit ], [ 0, %land.lhs.true113 ], [ 0, %cond.false118 ], [ 0, %land.lhs.true148 ], [ 1, %if.end161 ]
  ret i8 %retval.0
}

; Function Attrs: nounwind uwtable
define hidden void @PyExpat_XML_ParserFree(ptr noundef %parser) local_unnamed_addr #0 {
entry:
  %cmp = icmp eq ptr %parser, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %m_tagStack = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 67
  %0 = load ptr, ptr %m_tagStack, align 8
  %m_freeTagList = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 68
  %free_fcn = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 3, i32 2
  br label %for.cond

for.cond:                                         ; preds = %destroyBindings.exit, %if.end
  %tagList.0 = phi ptr [ %0, %if.end ], [ %2, %destroyBindings.exit ]
  %cmp1 = icmp eq ptr %tagList.0, null
  br i1 %cmp1, label %if.then2, label %if.end8

if.then2:                                         ; preds = %for.cond
  %1 = load ptr, ptr %m_freeTagList, align 8
  %cmp3 = icmp eq ptr %1, null
  br i1 %cmp3, label %for.end, label %if.end5

if.end5:                                          ; preds = %if.then2
  store ptr null, ptr %m_freeTagList, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.end5, %for.cond
  %tagList.1 = phi ptr [ %1, %if.end5 ], [ %tagList.0, %for.cond ]
  %2 = load ptr, ptr %tagList.1, align 8
  %3 = load ptr, ptr %free_fcn, align 8
  %buf = getelementptr inbounds %struct.tag, ptr %tagList.1, i64 0, i32 4
  %4 = load ptr, ptr %buf, align 8
  tail call void %3(ptr noundef %4) #24
  %bindings = getelementptr inbounds %struct.tag, ptr %tagList.1, i64 0, i32 6
  %5 = load ptr, ptr %bindings, align 8
  %tobool.not5.i = icmp eq ptr %5, null
  br i1 %tobool.not5.i, label %destroyBindings.exit, label %if.end.i

if.end.i:                                         ; preds = %if.end8, %if.end.i
  %bindings.addr.06.i = phi ptr [ %6, %if.end.i ], [ %5, %if.end8 ]
  %nextTagBinding.i = getelementptr inbounds %struct.binding, ptr %bindings.addr.06.i, i64 0, i32 1
  %6 = load ptr, ptr %nextTagBinding.i, align 8
  %7 = load ptr, ptr %free_fcn, align 8
  %uri.i = getelementptr inbounds %struct.binding, ptr %bindings.addr.06.i, i64 0, i32 4
  %8 = load ptr, ptr %uri.i, align 8
  tail call void %7(ptr noundef %8) #24
  %9 = load ptr, ptr %free_fcn, align 8
  tail call void %9(ptr noundef nonnull %bindings.addr.06.i) #24
  %tobool.not.i = icmp eq ptr %6, null
  br i1 %tobool.not.i, label %destroyBindings.exit, label %if.end.i

destroyBindings.exit:                             ; preds = %if.end.i, %if.end8
  %10 = load ptr, ptr %free_fcn, align 8
  tail call void %10(ptr noundef nonnull %tagList.1) #24
  br label %for.cond

for.end:                                          ; preds = %if.then2
  %m_openInternalEntities = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 50
  %11 = load ptr, ptr %m_openInternalEntities, align 8
  %m_freeInternalEntities = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 51
  br label %for.cond11

for.cond11:                                       ; preds = %if.end19, %for.end
  %entityList.0 = phi ptr [ %11, %for.end ], [ %13, %if.end19 ]
  %cmp12 = icmp eq ptr %entityList.0, null
  br i1 %cmp12, label %if.then13, label %if.end19

if.then13:                                        ; preds = %for.cond11
  %12 = load ptr, ptr %m_freeInternalEntities, align 8
  %cmp14 = icmp eq ptr %12, null
  br i1 %cmp14, label %for.end22, label %if.end16

if.end16:                                         ; preds = %if.then13
  store ptr null, ptr %m_freeInternalEntities, align 8
  br label %if.end19

if.end19:                                         ; preds = %if.end16, %for.cond11
  %entityList.1 = phi ptr [ %12, %if.end16 ], [ %entityList.0, %for.cond11 ]
  %next = getelementptr inbounds %struct.open_internal_entity, ptr %entityList.1, i64 0, i32 2
  %13 = load ptr, ptr %next, align 8
  %14 = load ptr, ptr %free_fcn, align 8
  tail call void %14(ptr noundef nonnull %entityList.1) #24
  br label %for.cond11

for.end22:                                        ; preds = %if.then13
  %m_freeBindingList = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 70
  %15 = load ptr, ptr %m_freeBindingList, align 8
  %tobool.not5.i52 = icmp eq ptr %15, null
  br i1 %tobool.not5.i52, label %destroyBindings.exit60, label %if.end.i55

if.end.i55:                                       ; preds = %for.end22, %if.end.i55
  %bindings.addr.06.i56 = phi ptr [ %16, %if.end.i55 ], [ %15, %for.end22 ]
  %nextTagBinding.i57 = getelementptr inbounds %struct.binding, ptr %bindings.addr.06.i56, i64 0, i32 1
  %16 = load ptr, ptr %nextTagBinding.i57, align 8
  %17 = load ptr, ptr %free_fcn, align 8
  %uri.i58 = getelementptr inbounds %struct.binding, ptr %bindings.addr.06.i56, i64 0, i32 4
  %18 = load ptr, ptr %uri.i58, align 8
  tail call void %17(ptr noundef %18) #24
  %19 = load ptr, ptr %free_fcn, align 8
  tail call void %19(ptr noundef nonnull %bindings.addr.06.i56) #24
  %tobool.not.i59 = icmp eq ptr %16, null
  br i1 %tobool.not.i59, label %destroyBindings.exit60, label %if.end.i55

destroyBindings.exit60:                           ; preds = %if.end.i55, %for.end22
  %m_inheritedBindings = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 69
  %20 = load ptr, ptr %m_inheritedBindings, align 8
  %tobool.not5.i61 = icmp eq ptr %20, null
  br i1 %tobool.not5.i61, label %destroyBindings.exit69, label %if.end.i64

if.end.i64:                                       ; preds = %destroyBindings.exit60, %if.end.i64
  %bindings.addr.06.i65 = phi ptr [ %21, %if.end.i64 ], [ %20, %destroyBindings.exit60 ]
  %nextTagBinding.i66 = getelementptr inbounds %struct.binding, ptr %bindings.addr.06.i65, i64 0, i32 1
  %21 = load ptr, ptr %nextTagBinding.i66, align 8
  %22 = load ptr, ptr %free_fcn, align 8
  %uri.i67 = getelementptr inbounds %struct.binding, ptr %bindings.addr.06.i65, i64 0, i32 4
  %23 = load ptr, ptr %uri.i67, align 8
  tail call void %22(ptr noundef %23) #24
  %24 = load ptr, ptr %free_fcn, align 8
  tail call void %24(ptr noundef nonnull %bindings.addr.06.i65) #24
  %tobool.not.i68 = icmp eq ptr %21, null
  br i1 %tobool.not.i68, label %destroyBindings.exit69, label %if.end.i64

destroyBindings.exit69:                           ; preds = %if.end.i64, %destroyBindings.exit60
  %m_tempPool = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 79
  %25 = load ptr, ptr %m_tempPool, align 8
  %tobool.not9.i = icmp eq ptr %25, null
  br i1 %tobool.not9.i, label %while.end.i, label %while.body.lr.ph.i

while.body.lr.ph.i:                               ; preds = %destroyBindings.exit69
  %mem.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 79, i32 5
  br label %while.body.i

while.body.i:                                     ; preds = %while.body.i, %while.body.lr.ph.i
  %p.010.i = phi ptr [ %25, %while.body.lr.ph.i ], [ %26, %while.body.i ]
  %26 = load ptr, ptr %p.010.i, align 8
  %27 = load ptr, ptr %mem.i, align 8
  %free_fcn.i70 = getelementptr inbounds %struct.XML_Memory_Handling_Suite, ptr %27, i64 0, i32 2
  %28 = load ptr, ptr %free_fcn.i70, align 8
  tail call void %28(ptr noundef nonnull %p.010.i) #24
  %tobool.not.i71 = icmp eq ptr %26, null
  br i1 %tobool.not.i71, label %while.end.i, label %while.body.i, !llvm.loop !21

while.end.i:                                      ; preds = %while.body.i, %destroyBindings.exit69
  %freeBlocks.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 79, i32 1
  %29 = load ptr, ptr %freeBlocks.i, align 8
  %tobool2.not11.i = icmp eq ptr %29, null
  br i1 %tobool2.not11.i, label %poolDestroy.exit, label %while.body3.lr.ph.i

while.body3.lr.ph.i:                              ; preds = %while.end.i
  %mem6.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 79, i32 5
  br label %while.body3.i

while.body3.i:                                    ; preds = %while.body3.i, %while.body3.lr.ph.i
  %p.112.i = phi ptr [ %29, %while.body3.lr.ph.i ], [ %30, %while.body3.i ]
  %30 = load ptr, ptr %p.112.i, align 8
  %31 = load ptr, ptr %mem6.i, align 8
  %free_fcn7.i = getelementptr inbounds %struct.XML_Memory_Handling_Suite, ptr %31, i64 0, i32 2
  %32 = load ptr, ptr %free_fcn7.i, align 8
  tail call void %32(ptr noundef nonnull %p.112.i) #24
  %tobool2.not.i = icmp eq ptr %30, null
  br i1 %tobool2.not.i, label %poolDestroy.exit, label %while.body3.i, !llvm.loop !22

poolDestroy.exit:                                 ; preds = %while.body3.i, %while.end.i
  %m_temp2Pool = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 80
  %33 = load ptr, ptr %m_temp2Pool, align 8
  %tobool.not9.i72 = icmp eq ptr %33, null
  br i1 %tobool.not9.i72, label %while.end.i79, label %while.body.lr.ph.i73

while.body.lr.ph.i73:                             ; preds = %poolDestroy.exit
  %mem.i74 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 80, i32 5
  br label %while.body.i75

while.body.i75:                                   ; preds = %while.body.i75, %while.body.lr.ph.i73
  %p.010.i76 = phi ptr [ %33, %while.body.lr.ph.i73 ], [ %34, %while.body.i75 ]
  %34 = load ptr, ptr %p.010.i76, align 8
  %35 = load ptr, ptr %mem.i74, align 8
  %free_fcn.i77 = getelementptr inbounds %struct.XML_Memory_Handling_Suite, ptr %35, i64 0, i32 2
  %36 = load ptr, ptr %free_fcn.i77, align 8
  tail call void %36(ptr noundef nonnull %p.010.i76) #24
  %tobool.not.i78 = icmp eq ptr %34, null
  br i1 %tobool.not.i78, label %while.end.i79, label %while.body.i75, !llvm.loop !21

while.end.i79:                                    ; preds = %while.body.i75, %poolDestroy.exit
  %freeBlocks.i80 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 80, i32 1
  %37 = load ptr, ptr %freeBlocks.i80, align 8
  %tobool2.not11.i81 = icmp eq ptr %37, null
  br i1 %tobool2.not11.i81, label %poolDestroy.exit88, label %while.body3.lr.ph.i82

while.body3.lr.ph.i82:                            ; preds = %while.end.i79
  %mem6.i83 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 80, i32 5
  br label %while.body3.i84

while.body3.i84:                                  ; preds = %while.body3.i84, %while.body3.lr.ph.i82
  %p.112.i85 = phi ptr [ %37, %while.body3.lr.ph.i82 ], [ %38, %while.body3.i84 ]
  %38 = load ptr, ptr %p.112.i85, align 8
  %39 = load ptr, ptr %mem6.i83, align 8
  %free_fcn7.i86 = getelementptr inbounds %struct.XML_Memory_Handling_Suite, ptr %39, i64 0, i32 2
  %40 = load ptr, ptr %free_fcn7.i86, align 8
  tail call void %40(ptr noundef nonnull %p.112.i85) #24
  %tobool2.not.i87 = icmp eq ptr %38, null
  br i1 %tobool2.not.i87, label %poolDestroy.exit88, label %while.body3.i84, !llvm.loop !22

poolDestroy.exit88:                               ; preds = %while.body3.i84, %while.end.i79
  %41 = load ptr, ptr %free_fcn, align 8
  %m_protocolEncodingName = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 37
  %42 = load ptr, ptr %m_protocolEncodingName, align 8
  tail call void %41(ptr noundef %42) #24
  %m_isParamEntity = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 86
  %43 = load i8, ptr %m_isParamEntity, align 8
  %tobool.not = icmp eq i8 %43, 0
  br i1 %tobool.not, label %land.lhs.true, label %if.end30

land.lhs.true:                                    ; preds = %poolDestroy.exit88
  %m_dtd = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 65
  %44 = load ptr, ptr %m_dtd, align 8
  %tobool25.not = icmp eq ptr %44, null
  br i1 %tobool25.not, label %if.end30, label %if.then26

if.then26:                                        ; preds = %land.lhs.true
  %m_parentParser = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 84
  %45 = load ptr, ptr %m_parentParser, align 8
  %tobool28.not.not = icmp eq ptr %45, null
  %elementTypes.i = getelementptr inbounds %struct.DTD, ptr %44, i64 0, i32 1
  %46 = load ptr, ptr %elementTypes.i, align 8
  %tobool.not.i.i = icmp eq ptr %46, null
  br i1 %tobool.not.i.i, label %hashTableIterInit.exit.i, label %cond.true.i.i

cond.true.i.i:                                    ; preds = %if.then26
  %size.i.i = getelementptr inbounds %struct.DTD, ptr %44, i64 0, i32 1, i32 2
  %47 = load i64, ptr %size.i.i, align 8
  %add.ptr.i.i = getelementptr ptr, ptr %46, i64 %47
  br label %hashTableIterInit.exit.i

hashTableIterInit.exit.i:                         ; preds = %cond.true.i.i, %if.then26
  %cond.i.i = phi ptr [ %add.ptr.i.i, %cond.true.i.i ], [ null, %if.then26 ]
  br label %while.cond.i.i

while.cond.i.i:                                   ; preds = %while.cond.i.i.backedge, %hashTableIterInit.exit.i
  %incdec.ptr5.i.i = phi ptr [ %46, %hashTableIterInit.exit.i ], [ %incdec.ptr.i.i, %while.cond.i.i.backedge ]
  %cmp.not.i.i = icmp eq ptr %incdec.ptr5.i.i, %cond.i.i
  br i1 %cmp.not.i.i, label %for.end.i, label %while.body.i.i

while.body.i.i:                                   ; preds = %while.cond.i.i
  %incdec.ptr.i.i = getelementptr ptr, ptr %incdec.ptr5.i.i, i64 1
  %48 = load ptr, ptr %incdec.ptr5.i.i, align 8
  %tobool.not.i17.i = icmp eq ptr %48, null
  br i1 %tobool.not.i17.i, label %while.cond.i.i.backedge, label %if.end.i90

while.cond.i.i.backedge:                          ; preds = %while.body.i.i, %if.then1.i, %if.end.i90
  br label %while.cond.i.i, !llvm.loop !9

if.end.i90:                                       ; preds = %while.body.i.i
  %allocDefaultAtts.i = getelementptr inbounds %struct.ELEMENT_TYPE, ptr %48, i64 0, i32 4
  %49 = load i32, ptr %allocDefaultAtts.i, align 4
  %cmp.not.i = icmp eq i32 %49, 0
  br i1 %cmp.not.i, label %while.cond.i.i.backedge, label %if.then1.i

if.then1.i:                                       ; preds = %if.end.i90
  %50 = load ptr, ptr %free_fcn, align 8
  %defaultAtts.i = getelementptr inbounds %struct.ELEMENT_TYPE, ptr %48, i64 0, i32 5
  %51 = load ptr, ptr %defaultAtts.i, align 8
  tail call void %50(ptr noundef %51) #24
  br label %while.cond.i.i.backedge

for.end.i:                                        ; preds = %while.cond.i.i
  %size.i18.i = getelementptr inbounds %struct.HASH_TABLE, ptr %44, i64 0, i32 2
  %52 = load i64, ptr %size.i18.i, align 8
  %cmp7.not.i.i = icmp eq i64 %52, 0
  br i1 %cmp7.not.i.i, label %hashTableDestroy.exit.i, label %for.body.lr.ph.i.i

for.body.lr.ph.i.i:                               ; preds = %for.end.i
  %mem.i.i = getelementptr inbounds %struct.HASH_TABLE, ptr %44, i64 0, i32 4
  br label %for.body.i.i

for.body.i.i:                                     ; preds = %for.body.i.i, %for.body.lr.ph.i.i
  %i.08.i.i = phi i64 [ 0, %for.body.lr.ph.i.i ], [ %inc.i.i, %for.body.i.i ]
  %53 = load ptr, ptr %mem.i.i, align 8
  %free_fcn.i.i = getelementptr inbounds %struct.XML_Memory_Handling_Suite, ptr %53, i64 0, i32 2
  %54 = load ptr, ptr %free_fcn.i.i, align 8
  %55 = load ptr, ptr %44, align 8
  %arrayidx.i.i = getelementptr ptr, ptr %55, i64 %i.08.i.i
  %56 = load ptr, ptr %arrayidx.i.i, align 8
  tail call void %54(ptr noundef %56) #24
  %inc.i.i = add nuw i64 %i.08.i.i, 1
  %57 = load i64, ptr %size.i18.i, align 8
  %cmp.i.i = icmp ult i64 %inc.i.i, %57
  br i1 %cmp.i.i, label %for.body.i.i, label %hashTableDestroy.exit.i, !llvm.loop !23

hashTableDestroy.exit.i:                          ; preds = %for.body.i.i, %for.end.i
  %mem1.i.i = getelementptr inbounds %struct.HASH_TABLE, ptr %44, i64 0, i32 4
  %58 = load ptr, ptr %mem1.i.i, align 8
  %free_fcn2.i.i = getelementptr inbounds %struct.XML_Memory_Handling_Suite, ptr %58, i64 0, i32 2
  %59 = load ptr, ptr %free_fcn2.i.i, align 8
  %60 = load ptr, ptr %44, align 8
  tail call void %59(ptr noundef %60) #24
  %paramEntities.i = getelementptr inbounds %struct.DTD, ptr %44, i64 0, i32 10
  %size.i19.i = getelementptr inbounds %struct.DTD, ptr %44, i64 0, i32 10, i32 2
  %61 = load i64, ptr %size.i19.i, align 8
  %cmp7.not.i20.i = icmp eq i64 %61, 0
  br i1 %cmp7.not.i20.i, label %hashTableDestroy.exit31.i, label %for.body.lr.ph.i21.i

for.body.lr.ph.i21.i:                             ; preds = %hashTableDestroy.exit.i
  %mem.i22.i = getelementptr inbounds %struct.DTD, ptr %44, i64 0, i32 10, i32 4
  br label %for.body.i23.i

for.body.i23.i:                                   ; preds = %for.body.i23.i, %for.body.lr.ph.i21.i
  %i.08.i24.i = phi i64 [ 0, %for.body.lr.ph.i21.i ], [ %inc.i27.i, %for.body.i23.i ]
  %62 = load ptr, ptr %mem.i22.i, align 8
  %free_fcn.i25.i = getelementptr inbounds %struct.XML_Memory_Handling_Suite, ptr %62, i64 0, i32 2
  %63 = load ptr, ptr %free_fcn.i25.i, align 8
  %64 = load ptr, ptr %paramEntities.i, align 8
  %arrayidx.i26.i = getelementptr ptr, ptr %64, i64 %i.08.i24.i
  %65 = load ptr, ptr %arrayidx.i26.i, align 8
  tail call void %63(ptr noundef %65) #24
  %inc.i27.i = add nuw i64 %i.08.i24.i, 1
  %66 = load i64, ptr %size.i19.i, align 8
  %cmp.i28.i = icmp ult i64 %inc.i27.i, %66
  br i1 %cmp.i28.i, label %for.body.i23.i, label %hashTableDestroy.exit31.i, !llvm.loop !23

hashTableDestroy.exit31.i:                        ; preds = %for.body.i23.i, %hashTableDestroy.exit.i
  %mem1.i29.i = getelementptr inbounds %struct.DTD, ptr %44, i64 0, i32 10, i32 4
  %67 = load ptr, ptr %mem1.i29.i, align 8
  %free_fcn2.i30.i = getelementptr inbounds %struct.XML_Memory_Handling_Suite, ptr %67, i64 0, i32 2
  %68 = load ptr, ptr %free_fcn2.i30.i, align 8
  %69 = load ptr, ptr %paramEntities.i, align 8
  tail call void %68(ptr noundef %69) #24
  %size.i32.i = getelementptr inbounds %struct.DTD, ptr %44, i64 0, i32 1, i32 2
  %70 = load i64, ptr %size.i32.i, align 8
  %cmp7.not.i33.i = icmp eq i64 %70, 0
  br i1 %cmp7.not.i33.i, label %hashTableDestroy.exit44.i, label %for.body.lr.ph.i34.i

for.body.lr.ph.i34.i:                             ; preds = %hashTableDestroy.exit31.i
  %mem.i35.i = getelementptr inbounds %struct.DTD, ptr %44, i64 0, i32 1, i32 4
  br label %for.body.i36.i

for.body.i36.i:                                   ; preds = %for.body.i36.i, %for.body.lr.ph.i34.i
  %i.08.i37.i = phi i64 [ 0, %for.body.lr.ph.i34.i ], [ %inc.i40.i, %for.body.i36.i ]
  %71 = load ptr, ptr %mem.i35.i, align 8
  %free_fcn.i38.i = getelementptr inbounds %struct.XML_Memory_Handling_Suite, ptr %71, i64 0, i32 2
  %72 = load ptr, ptr %free_fcn.i38.i, align 8
  %73 = load ptr, ptr %elementTypes.i, align 8
  %arrayidx.i39.i = getelementptr ptr, ptr %73, i64 %i.08.i37.i
  %74 = load ptr, ptr %arrayidx.i39.i, align 8
  tail call void %72(ptr noundef %74) #24
  %inc.i40.i = add nuw i64 %i.08.i37.i, 1
  %75 = load i64, ptr %size.i32.i, align 8
  %cmp.i41.i = icmp ult i64 %inc.i40.i, %75
  br i1 %cmp.i41.i, label %for.body.i36.i, label %hashTableDestroy.exit44.i, !llvm.loop !23

hashTableDestroy.exit44.i:                        ; preds = %for.body.i36.i, %hashTableDestroy.exit31.i
  %mem1.i42.i = getelementptr inbounds %struct.DTD, ptr %44, i64 0, i32 1, i32 4
  %76 = load ptr, ptr %mem1.i42.i, align 8
  %free_fcn2.i43.i = getelementptr inbounds %struct.XML_Memory_Handling_Suite, ptr %76, i64 0, i32 2
  %77 = load ptr, ptr %free_fcn2.i43.i, align 8
  %78 = load ptr, ptr %elementTypes.i, align 8
  tail call void %77(ptr noundef %78) #24
  %attributeIds.i = getelementptr inbounds %struct.DTD, ptr %44, i64 0, i32 2
  %size.i45.i = getelementptr inbounds %struct.DTD, ptr %44, i64 0, i32 2, i32 2
  %79 = load i64, ptr %size.i45.i, align 8
  %cmp7.not.i46.i = icmp eq i64 %79, 0
  br i1 %cmp7.not.i46.i, label %hashTableDestroy.exit57.i, label %for.body.lr.ph.i47.i

for.body.lr.ph.i47.i:                             ; preds = %hashTableDestroy.exit44.i
  %mem.i48.i = getelementptr inbounds %struct.DTD, ptr %44, i64 0, i32 2, i32 4
  br label %for.body.i49.i

for.body.i49.i:                                   ; preds = %for.body.i49.i, %for.body.lr.ph.i47.i
  %i.08.i50.i = phi i64 [ 0, %for.body.lr.ph.i47.i ], [ %inc.i53.i, %for.body.i49.i ]
  %80 = load ptr, ptr %mem.i48.i, align 8
  %free_fcn.i51.i = getelementptr inbounds %struct.XML_Memory_Handling_Suite, ptr %80, i64 0, i32 2
  %81 = load ptr, ptr %free_fcn.i51.i, align 8
  %82 = load ptr, ptr %attributeIds.i, align 8
  %arrayidx.i52.i = getelementptr ptr, ptr %82, i64 %i.08.i50.i
  %83 = load ptr, ptr %arrayidx.i52.i, align 8
  tail call void %81(ptr noundef %83) #24
  %inc.i53.i = add nuw i64 %i.08.i50.i, 1
  %84 = load i64, ptr %size.i45.i, align 8
  %cmp.i54.i = icmp ult i64 %inc.i53.i, %84
  br i1 %cmp.i54.i, label %for.body.i49.i, label %hashTableDestroy.exit57.i, !llvm.loop !23

hashTableDestroy.exit57.i:                        ; preds = %for.body.i49.i, %hashTableDestroy.exit44.i
  %mem1.i55.i = getelementptr inbounds %struct.DTD, ptr %44, i64 0, i32 2, i32 4
  %85 = load ptr, ptr %mem1.i55.i, align 8
  %free_fcn2.i56.i = getelementptr inbounds %struct.XML_Memory_Handling_Suite, ptr %85, i64 0, i32 2
  %86 = load ptr, ptr %free_fcn2.i56.i, align 8
  %87 = load ptr, ptr %attributeIds.i, align 8
  tail call void %86(ptr noundef %87) #24
  %prefixes.i = getelementptr inbounds %struct.DTD, ptr %44, i64 0, i32 3
  %size.i58.i = getelementptr inbounds %struct.DTD, ptr %44, i64 0, i32 3, i32 2
  %88 = load i64, ptr %size.i58.i, align 8
  %cmp7.not.i59.i = icmp eq i64 %88, 0
  br i1 %cmp7.not.i59.i, label %hashTableDestroy.exit70.i, label %for.body.lr.ph.i60.i

for.body.lr.ph.i60.i:                             ; preds = %hashTableDestroy.exit57.i
  %mem.i61.i = getelementptr inbounds %struct.DTD, ptr %44, i64 0, i32 3, i32 4
  br label %for.body.i62.i

for.body.i62.i:                                   ; preds = %for.body.i62.i, %for.body.lr.ph.i60.i
  %i.08.i63.i = phi i64 [ 0, %for.body.lr.ph.i60.i ], [ %inc.i66.i, %for.body.i62.i ]
  %89 = load ptr, ptr %mem.i61.i, align 8
  %free_fcn.i64.i = getelementptr inbounds %struct.XML_Memory_Handling_Suite, ptr %89, i64 0, i32 2
  %90 = load ptr, ptr %free_fcn.i64.i, align 8
  %91 = load ptr, ptr %prefixes.i, align 8
  %arrayidx.i65.i = getelementptr ptr, ptr %91, i64 %i.08.i63.i
  %92 = load ptr, ptr %arrayidx.i65.i, align 8
  tail call void %90(ptr noundef %92) #24
  %inc.i66.i = add nuw i64 %i.08.i63.i, 1
  %93 = load i64, ptr %size.i58.i, align 8
  %cmp.i67.i = icmp ult i64 %inc.i66.i, %93
  br i1 %cmp.i67.i, label %for.body.i62.i, label %hashTableDestroy.exit70.i, !llvm.loop !23

hashTableDestroy.exit70.i:                        ; preds = %for.body.i62.i, %hashTableDestroy.exit57.i
  %mem1.i68.i = getelementptr inbounds %struct.DTD, ptr %44, i64 0, i32 3, i32 4
  %94 = load ptr, ptr %mem1.i68.i, align 8
  %free_fcn2.i69.i = getelementptr inbounds %struct.XML_Memory_Handling_Suite, ptr %94, i64 0, i32 2
  %95 = load ptr, ptr %free_fcn2.i69.i, align 8
  %96 = load ptr, ptr %prefixes.i, align 8
  tail call void %95(ptr noundef %96) #24
  %pool.i = getelementptr inbounds %struct.DTD, ptr %44, i64 0, i32 4
  %97 = load ptr, ptr %pool.i, align 8
  %tobool.not9.i.i = icmp eq ptr %97, null
  br i1 %tobool.not9.i.i, label %while.end.i.i, label %while.body.lr.ph.i.i

while.body.lr.ph.i.i:                             ; preds = %hashTableDestroy.exit70.i
  %mem.i71.i = getelementptr inbounds %struct.DTD, ptr %44, i64 0, i32 4, i32 5
  br label %while.body.i72.i

while.body.i72.i:                                 ; preds = %while.body.i72.i, %while.body.lr.ph.i.i
  %p.010.i.i = phi ptr [ %97, %while.body.lr.ph.i.i ], [ %98, %while.body.i72.i ]
  %98 = load ptr, ptr %p.010.i.i, align 8
  %99 = load ptr, ptr %mem.i71.i, align 8
  %free_fcn.i73.i = getelementptr inbounds %struct.XML_Memory_Handling_Suite, ptr %99, i64 0, i32 2
  %100 = load ptr, ptr %free_fcn.i73.i, align 8
  tail call void %100(ptr noundef nonnull %p.010.i.i) #24
  %tobool.not.i74.i = icmp eq ptr %98, null
  br i1 %tobool.not.i74.i, label %while.end.i.i, label %while.body.i72.i, !llvm.loop !21

while.end.i.i:                                    ; preds = %while.body.i72.i, %hashTableDestroy.exit70.i
  %freeBlocks.i.i = getelementptr inbounds %struct.DTD, ptr %44, i64 0, i32 4, i32 1
  %101 = load ptr, ptr %freeBlocks.i.i, align 8
  %tobool2.not11.i.i = icmp eq ptr %101, null
  br i1 %tobool2.not11.i.i, label %poolDestroy.exit.i, label %while.body3.lr.ph.i.i

while.body3.lr.ph.i.i:                            ; preds = %while.end.i.i
  %mem6.i.i = getelementptr inbounds %struct.DTD, ptr %44, i64 0, i32 4, i32 5
  br label %while.body3.i.i

while.body3.i.i:                                  ; preds = %while.body3.i.i, %while.body3.lr.ph.i.i
  %p.112.i.i = phi ptr [ %101, %while.body3.lr.ph.i.i ], [ %102, %while.body3.i.i ]
  %102 = load ptr, ptr %p.112.i.i, align 8
  %103 = load ptr, ptr %mem6.i.i, align 8
  %free_fcn7.i.i = getelementptr inbounds %struct.XML_Memory_Handling_Suite, ptr %103, i64 0, i32 2
  %104 = load ptr, ptr %free_fcn7.i.i, align 8
  tail call void %104(ptr noundef nonnull %p.112.i.i) #24
  %tobool2.not.i.i = icmp eq ptr %102, null
  br i1 %tobool2.not.i.i, label %poolDestroy.exit.i, label %while.body3.i.i, !llvm.loop !22

poolDestroy.exit.i:                               ; preds = %while.body3.i.i, %while.end.i.i
  %entityValuePool.i = getelementptr inbounds %struct.DTD, ptr %44, i64 0, i32 5
  %105 = load ptr, ptr %entityValuePool.i, align 8
  %tobool.not9.i75.i = icmp eq ptr %105, null
  br i1 %tobool.not9.i75.i, label %while.end.i82.i, label %while.body.lr.ph.i76.i

while.body.lr.ph.i76.i:                           ; preds = %poolDestroy.exit.i
  %mem.i77.i = getelementptr inbounds %struct.DTD, ptr %44, i64 0, i32 5, i32 5
  br label %while.body.i78.i

while.body.i78.i:                                 ; preds = %while.body.i78.i, %while.body.lr.ph.i76.i
  %p.010.i79.i = phi ptr [ %105, %while.body.lr.ph.i76.i ], [ %106, %while.body.i78.i ]
  %106 = load ptr, ptr %p.010.i79.i, align 8
  %107 = load ptr, ptr %mem.i77.i, align 8
  %free_fcn.i80.i = getelementptr inbounds %struct.XML_Memory_Handling_Suite, ptr %107, i64 0, i32 2
  %108 = load ptr, ptr %free_fcn.i80.i, align 8
  tail call void %108(ptr noundef nonnull %p.010.i79.i) #24
  %tobool.not.i81.i = icmp eq ptr %106, null
  br i1 %tobool.not.i81.i, label %while.end.i82.i, label %while.body.i78.i, !llvm.loop !21

while.end.i82.i:                                  ; preds = %while.body.i78.i, %poolDestroy.exit.i
  %freeBlocks.i83.i = getelementptr inbounds %struct.DTD, ptr %44, i64 0, i32 5, i32 1
  %109 = load ptr, ptr %freeBlocks.i83.i, align 8
  %tobool2.not11.i84.i = icmp eq ptr %109, null
  br i1 %tobool2.not11.i84.i, label %poolDestroy.exit91.i, label %while.body3.lr.ph.i85.i

while.body3.lr.ph.i85.i:                          ; preds = %while.end.i82.i
  %mem6.i86.i = getelementptr inbounds %struct.DTD, ptr %44, i64 0, i32 5, i32 5
  br label %while.body3.i87.i

while.body3.i87.i:                                ; preds = %while.body3.i87.i, %while.body3.lr.ph.i85.i
  %p.112.i88.i = phi ptr [ %109, %while.body3.lr.ph.i85.i ], [ %110, %while.body3.i87.i ]
  %110 = load ptr, ptr %p.112.i88.i, align 8
  %111 = load ptr, ptr %mem6.i86.i, align 8
  %free_fcn7.i89.i = getelementptr inbounds %struct.XML_Memory_Handling_Suite, ptr %111, i64 0, i32 2
  %112 = load ptr, ptr %free_fcn7.i89.i, align 8
  tail call void %112(ptr noundef nonnull %p.112.i88.i) #24
  %tobool2.not.i90.i = icmp eq ptr %110, null
  br i1 %tobool2.not.i90.i, label %poolDestroy.exit91.i, label %while.body3.i87.i, !llvm.loop !22

poolDestroy.exit91.i:                             ; preds = %while.body3.i87.i, %while.end.i82.i
  br i1 %tobool28.not.not, label %if.then5.i, label %dtdDestroy.exit

if.then5.i:                                       ; preds = %poolDestroy.exit91.i
  %113 = load ptr, ptr %free_fcn, align 8
  %scaffIndex.i = getelementptr inbounds %struct.DTD, ptr %44, i64 0, i32 18
  %114 = load ptr, ptr %scaffIndex.i, align 8
  tail call void %113(ptr noundef %114) #24
  %115 = load ptr, ptr %free_fcn, align 8
  %scaffold.i = getelementptr inbounds %struct.DTD, ptr %44, i64 0, i32 13
  %116 = load ptr, ptr %scaffold.i, align 8
  tail call void %115(ptr noundef %116) #24
  br label %dtdDestroy.exit

dtdDestroy.exit:                                  ; preds = %poolDestroy.exit91.i, %if.then5.i
  %117 = load ptr, ptr %free_fcn, align 8
  tail call void %117(ptr noundef nonnull %44) #24
  br label %if.end30

if.end30:                                         ; preds = %dtdDestroy.exit, %land.lhs.true, %poolDestroy.exit88
  %118 = load ptr, ptr %free_fcn, align 8
  %m_atts = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 74
  %119 = load ptr, ptr %m_atts, align 8
  tail call void %118(ptr noundef %119) #24
  %120 = load ptr, ptr %free_fcn, align 8
  %m_groupConnector = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 81
  %121 = load ptr, ptr %m_groupConnector, align 8
  tail call void %120(ptr noundef %121) #24
  %122 = load ptr, ptr %free_fcn, align 8
  %m_buffer = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 2
  %123 = load ptr, ptr %m_buffer, align 8
  tail call void %122(ptr noundef %123) #24
  %124 = load ptr, ptr %free_fcn, align 8
  %m_dataBuf = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 9
  %125 = load ptr, ptr %m_dataBuf, align 8
  tail call void %124(ptr noundef %125) #24
  %126 = load ptr, ptr %free_fcn, align 8
  %m_nsAtts = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 75
  %127 = load ptr, ptr %m_nsAtts, align 8
  tail call void %126(ptr noundef %127) #24
  %128 = load ptr, ptr %free_fcn, align 8
  %m_unknownEncodingMem = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 40
  %129 = load ptr, ptr %m_unknownEncodingMem, align 8
  tail call void %128(ptr noundef %129) #24
  %m_unknownEncodingRelease = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 43
  %130 = load ptr, ptr %m_unknownEncodingRelease, align 8
  %tobool43.not = icmp eq ptr %130, null
  br i1 %tobool43.not, label %if.end46, label %if.then44

if.then44:                                        ; preds = %if.end30
  %m_unknownEncodingData = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 41
  %131 = load ptr, ptr %m_unknownEncodingData, align 8
  tail call void %130(ptr noundef %131) #24
  br label %if.end46

if.end46:                                         ; preds = %if.then44, %if.end30
  %132 = load ptr, ptr %free_fcn, align 8
  tail call void %132(ptr noundef nonnull %parser) #24
  br label %return

return:                                           ; preds = %entry, %if.end46
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @externalEntityInitProcessor(ptr noundef %parser, ptr noundef %start, ptr noundef %end, ptr nocapture noundef writeonly %endPtr) #0 {
entry:
  %call = tail call fastcc i32 @initializeEncoding(ptr noundef %parser), !range !24
  %cmp.not = icmp eq i32 %call, 0
  br i1 %cmp.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  %m_processor = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 45
  store ptr @externalEntityInitProcessor2, ptr %m_processor, align 8
  %call1 = tail call i32 @externalEntityInitProcessor2(ptr noundef %parser, ptr noundef %start, ptr noundef %end, ptr noundef %endPtr)
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi i32 [ %call1, %if.end ], [ %call, %entry ]
  ret i32 %retval.0
}

declare void @PyExpat_XmlPrologStateInitExternalEntity(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define internal i32 @externalParEntInitProcessor(ptr noundef %parser, ptr noundef %s, ptr noundef %end, ptr noundef %nextPtr) #0 {
entry:
  %call = tail call fastcc i32 @initializeEncoding(ptr noundef %parser), !range !24
  %cmp.not = icmp eq i32 %call, 0
  br i1 %cmp.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  %m_dtd = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 65
  %0 = load ptr, ptr %m_dtd, align 8
  %paramEntityRead = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 9
  store i8 1, ptr %paramEntityRead, align 1
  %inEntityValue = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 44, i32 5
  %1 = load i32, ptr %inEntityValue, align 8
  %tobool.not = icmp eq i32 %1, 0
  %m_processor3 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 45
  br i1 %tobool.not, label %if.else, label %if.then1

if.then1:                                         ; preds = %if.end
  store ptr @entityValueInitProcessor, ptr %m_processor3, align 8
  %call2 = tail call i32 @entityValueInitProcessor(ptr noundef nonnull %parser, ptr noundef %s, ptr noundef %end, ptr noundef %nextPtr)
  br label %return

if.else:                                          ; preds = %if.end
  store ptr @externalParEntProcessor, ptr %m_processor3, align 8
  %call4 = tail call i32 @externalParEntProcessor(ptr noundef nonnull %parser, ptr noundef %s, ptr noundef %end, ptr noundef %nextPtr)
  br label %return

return:                                           ; preds = %entry, %if.else, %if.then1
  %retval.0 = phi i32 [ %call2, %if.then1 ], [ %call4, %if.else ], [ %call, %entry ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) uwtable
define hidden void @PyExpat_XML_UseParserAsHandlerArg(ptr noundef %parser) local_unnamed_addr #2 {
entry:
  %cmp.not = icmp eq ptr %parser, null
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %m_handlerArg = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 1
  store ptr %parser, ptr %m_handlerArg, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite) uwtable
define hidden i32 @PyExpat_XML_UseForeignDTD(ptr noundef %parser, i8 noundef zeroext %useDTD) local_unnamed_addr #3 {
entry:
  %cmp = icmp eq ptr %parser, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %m_parsingStatus = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 85
  %0 = load i32, ptr %m_parsingStatus, align 8
  switch i32 %0, label %if.end6 [
    i32 1, label %return
    i32 3, label %return
  ]

if.end6:                                          ; preds = %if.end
  %m_useForeignDTD = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 87
  store i8 %useDTD, ptr %m_useForeignDTD, align 1
  br label %return

return:                                           ; preds = %if.end, %if.end, %entry, %if.end6
  %retval.0 = phi i32 [ 0, %if.end6 ], [ 41, %entry ], [ 26, %if.end ], [ 26, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite) uwtable
define hidden void @PyExpat_XML_SetReturnNSTriplet(ptr noundef %parser, i32 noundef %do_nst) local_unnamed_addr #3 {
entry:
  %cmp = icmp eq ptr %parser, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %m_parsingStatus = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 85
  %0 = load i32, ptr %m_parsingStatus, align 8
  switch i32 %0, label %if.end6 [
    i32 1, label %return
    i32 3, label %return
  ]

if.end6:                                          ; preds = %if.end
  %tobool.not = icmp ne i32 %do_nst, 0
  %conv = zext i1 %tobool.not to i8
  %m_ns_triplets = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 39
  store i8 %conv, ptr %m_ns_triplets, align 1
  br label %return

return:                                           ; preds = %if.end, %if.end, %entry, %if.end6
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite) uwtable
define hidden void @PyExpat_XML_SetUserData(ptr noundef %parser, ptr noundef %p) local_unnamed_addr #3 {
entry:
  %cmp = icmp eq ptr %parser, null
  br i1 %cmp, label %if.end6, label %if.end

if.end:                                           ; preds = %entry
  %m_handlerArg = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 1
  %0 = load ptr, ptr %m_handlerArg, align 8
  %1 = load ptr, ptr %parser, align 8
  %cmp1 = icmp eq ptr %0, %1
  store ptr %p, ptr %parser, align 8
  br i1 %cmp1, label %if.then2, label %if.end6

if.then2:                                         ; preds = %if.end
  store ptr %p, ptr %m_handlerArg, align 8
  br label %if.end6

if.end6:                                          ; preds = %if.end, %entry, %if.then2
  ret void
}

; Function Attrs: nounwind uwtable
define hidden i32 @PyExpat_XML_SetBase(ptr noundef %parser, ptr noundef readonly %p) local_unnamed_addr #0 {
entry:
  %cmp = icmp eq ptr %parser, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %tobool.not = icmp eq ptr %p, null
  br i1 %tobool.not, label %return.sink.split, label %if.then1

if.then1:                                         ; preds = %if.end
  %m_dtd = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 65
  %0 = load ptr, ptr %m_dtd, align 8
  %pool = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 4
  %ptr.i = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 4, i32 3
  %end.i = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 4, i32 2
  br label %do.body.i

do.body.i:                                        ; preds = %cond.false.i, %if.then1
  %s.addr.0.i = phi ptr [ %p, %if.then1 ], [ %incdec.ptr2.i, %cond.false.i ]
  %1 = load ptr, ptr %ptr.i, align 8
  %2 = load ptr, ptr %end.i, align 8
  %cmp.i = icmp eq ptr %1, %2
  br i1 %cmp.i, label %land.lhs.true.i, label %cond.false.i

land.lhs.true.i:                                  ; preds = %do.body.i
  %call.i = tail call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool), !range !13
  %tobool.not.i = icmp eq i8 %call.i, 0
  br i1 %tobool.not.i, label %return, label %land.lhs.true.cond.false_crit_edge.i

land.lhs.true.cond.false_crit_edge.i:             ; preds = %land.lhs.true.i
  %.pre.i = load ptr, ptr %ptr.i, align 8
  br label %cond.false.i

cond.false.i:                                     ; preds = %land.lhs.true.cond.false_crit_edge.i, %do.body.i
  %3 = phi ptr [ %.pre.i, %land.lhs.true.cond.false_crit_edge.i ], [ %1, %do.body.i ]
  %4 = load i8, ptr %s.addr.0.i, align 1
  %incdec.ptr.i = getelementptr i8, ptr %3, i64 1
  store ptr %incdec.ptr.i, ptr %ptr.i, align 8
  store i8 %4, ptr %3, align 1
  %incdec.ptr2.i = getelementptr i8, ptr %s.addr.0.i, i64 1
  %5 = load i8, ptr %s.addr.0.i, align 1
  %tobool3.not.i = icmp eq i8 %5, 0
  br i1 %tobool3.not.i, label %poolCopyString.exit, label %do.body.i, !llvm.loop !12

poolCopyString.exit:                              ; preds = %cond.false.i
  %start.i = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 4, i32 4
  %6 = load ptr, ptr %start.i, align 8
  %7 = load ptr, ptr %ptr.i, align 8
  store ptr %7, ptr %start.i, align 8
  %tobool2.not = icmp eq ptr %6, null
  br i1 %tobool2.not, label %return, label %return.sink.split

return.sink.split:                                ; preds = %if.end, %poolCopyString.exit
  %.sink = phi ptr [ %6, %poolCopyString.exit ], [ null, %if.end ]
  %m_curBase = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 66
  store ptr %.sink, ptr %m_curBase, align 8
  br label %return

return:                                           ; preds = %land.lhs.true.i, %return.sink.split, %poolCopyString.exit, %entry
  %retval.0 = phi i32 [ 0, %entry ], [ 0, %poolCopyString.exit ], [ 1, %return.sink.split ], [ 0, %land.lhs.true.i ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define hidden ptr @PyExpat_XML_GetBase(ptr noundef readonly %parser) local_unnamed_addr #4 {
entry:
  %cmp = icmp eq ptr %parser, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %m_curBase = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 66
  %0 = load ptr, ptr %m_curBase, align 8
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi ptr [ %0, %if.end ], [ null, %entry ]
  ret ptr %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define hidden i32 @PyExpat_XML_GetSpecifiedAttributeCount(ptr noundef readonly %parser) local_unnamed_addr #4 {
entry:
  %cmp = icmp eq ptr %parser, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %m_nSpecifiedAtts = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 72
  %0 = load i32, ptr %m_nSpecifiedAtts, align 4
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi i32 [ %0, %if.end ], [ -1, %entry ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define hidden i32 @PyExpat_XML_GetIdAttributeIndex(ptr noundef readonly %parser) local_unnamed_addr #4 {
entry:
  %cmp = icmp eq ptr %parser, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %m_idAttIndex = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 73
  %0 = load i32, ptr %m_idAttIndex, align 8
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi i32 [ %0, %if.end ], [ -1, %entry ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) uwtable
define hidden void @PyExpat_XML_SetElementHandler(ptr noundef writeonly %parser, ptr noundef %start, ptr noundef %end) local_unnamed_addr #2 {
entry:
  %cmp = icmp eq ptr %parser, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %m_startElementHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 11
  store ptr %start, ptr %m_startElementHandler, align 8
  %m_endElementHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 12
  store ptr %end, ptr %m_endElementHandler, align 8
  br label %return

return:                                           ; preds = %entry, %if.end
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) uwtable
define hidden void @PyExpat_XML_SetStartElementHandler(ptr noundef writeonly %parser, ptr noundef %start) local_unnamed_addr #2 {
entry:
  %cmp.not = icmp eq ptr %parser, null
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %m_startElementHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 11
  store ptr %start, ptr %m_startElementHandler, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) uwtable
define hidden void @PyExpat_XML_SetEndElementHandler(ptr noundef writeonly %parser, ptr noundef %end) local_unnamed_addr #2 {
entry:
  %cmp.not = icmp eq ptr %parser, null
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %m_endElementHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 12
  store ptr %end, ptr %m_endElementHandler, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) uwtable
define hidden void @PyExpat_XML_SetCharacterDataHandler(ptr noundef writeonly %parser, ptr noundef %handler) local_unnamed_addr #2 {
entry:
  %cmp.not = icmp eq ptr %parser, null
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %m_characterDataHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 13
  store ptr %handler, ptr %m_characterDataHandler, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) uwtable
define hidden void @PyExpat_XML_SetProcessingInstructionHandler(ptr noundef writeonly %parser, ptr noundef %handler) local_unnamed_addr #2 {
entry:
  %cmp.not = icmp eq ptr %parser, null
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %m_processingInstructionHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 14
  store ptr %handler, ptr %m_processingInstructionHandler, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) uwtable
define hidden void @PyExpat_XML_SetCommentHandler(ptr noundef writeonly %parser, ptr noundef %handler) local_unnamed_addr #2 {
entry:
  %cmp.not = icmp eq ptr %parser, null
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %m_commentHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 15
  store ptr %handler, ptr %m_commentHandler, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) uwtable
define hidden void @PyExpat_XML_SetCdataSectionHandler(ptr noundef writeonly %parser, ptr noundef %start, ptr noundef %end) local_unnamed_addr #2 {
entry:
  %cmp = icmp eq ptr %parser, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %m_startCdataSectionHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 16
  store ptr %start, ptr %m_startCdataSectionHandler, align 8
  %m_endCdataSectionHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 17
  store ptr %end, ptr %m_endCdataSectionHandler, align 8
  br label %return

return:                                           ; preds = %entry, %if.end
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) uwtable
define hidden void @PyExpat_XML_SetStartCdataSectionHandler(ptr noundef writeonly %parser, ptr noundef %start) local_unnamed_addr #2 {
entry:
  %cmp.not = icmp eq ptr %parser, null
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %m_startCdataSectionHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 16
  store ptr %start, ptr %m_startCdataSectionHandler, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) uwtable
define hidden void @PyExpat_XML_SetEndCdataSectionHandler(ptr noundef writeonly %parser, ptr noundef %end) local_unnamed_addr #2 {
entry:
  %cmp.not = icmp eq ptr %parser, null
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %m_endCdataSectionHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 17
  store ptr %end, ptr %m_endCdataSectionHandler, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) uwtable
define hidden void @PyExpat_XML_SetDefaultHandler(ptr noundef writeonly %parser, ptr noundef %handler) local_unnamed_addr #2 {
entry:
  %cmp = icmp eq ptr %parser, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %m_defaultHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 18
  store ptr %handler, ptr %m_defaultHandler, align 8
  %m_defaultExpandInternalEntities = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 52
  store i8 0, ptr %m_defaultExpandInternalEntities, align 8
  br label %return

return:                                           ; preds = %entry, %if.end
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) uwtable
define hidden void @PyExpat_XML_SetDefaultHandlerExpand(ptr noundef writeonly %parser, ptr noundef %handler) local_unnamed_addr #2 {
entry:
  %cmp = icmp eq ptr %parser, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %m_defaultHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 18
  store ptr %handler, ptr %m_defaultHandler, align 8
  %m_defaultExpandInternalEntities = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 52
  store i8 1, ptr %m_defaultExpandInternalEntities, align 8
  br label %return

return:                                           ; preds = %entry, %if.end
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) uwtable
define hidden void @PyExpat_XML_SetDoctypeDeclHandler(ptr noundef writeonly %parser, ptr noundef %start, ptr noundef %end) local_unnamed_addr #2 {
entry:
  %cmp = icmp eq ptr %parser, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %m_startDoctypeDeclHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 19
  store ptr %start, ptr %m_startDoctypeDeclHandler, align 8
  %m_endDoctypeDeclHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 20
  store ptr %end, ptr %m_endDoctypeDeclHandler, align 8
  br label %return

return:                                           ; preds = %entry, %if.end
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) uwtable
define hidden void @PyExpat_XML_SetStartDoctypeDeclHandler(ptr noundef writeonly %parser, ptr noundef %start) local_unnamed_addr #2 {
entry:
  %cmp.not = icmp eq ptr %parser, null
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %m_startDoctypeDeclHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 19
  store ptr %start, ptr %m_startDoctypeDeclHandler, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) uwtable
define hidden void @PyExpat_XML_SetEndDoctypeDeclHandler(ptr noundef writeonly %parser, ptr noundef %end) local_unnamed_addr #2 {
entry:
  %cmp.not = icmp eq ptr %parser, null
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %m_endDoctypeDeclHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 20
  store ptr %end, ptr %m_endDoctypeDeclHandler, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) uwtable
define hidden void @PyExpat_XML_SetUnparsedEntityDeclHandler(ptr noundef writeonly %parser, ptr noundef %handler) local_unnamed_addr #2 {
entry:
  %cmp.not = icmp eq ptr %parser, null
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %m_unparsedEntityDeclHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 21
  store ptr %handler, ptr %m_unparsedEntityDeclHandler, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) uwtable
define hidden void @PyExpat_XML_SetNotationDeclHandler(ptr noundef writeonly %parser, ptr noundef %handler) local_unnamed_addr #2 {
entry:
  %cmp.not = icmp eq ptr %parser, null
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %m_notationDeclHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 22
  store ptr %handler, ptr %m_notationDeclHandler, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) uwtable
define hidden void @PyExpat_XML_SetNamespaceDeclHandler(ptr noundef writeonly %parser, ptr noundef %start, ptr noundef %end) local_unnamed_addr #2 {
entry:
  %cmp = icmp eq ptr %parser, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %m_startNamespaceDeclHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 23
  store ptr %start, ptr %m_startNamespaceDeclHandler, align 8
  %m_endNamespaceDeclHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 24
  store ptr %end, ptr %m_endNamespaceDeclHandler, align 8
  br label %return

return:                                           ; preds = %entry, %if.end
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) uwtable
define hidden void @PyExpat_XML_SetStartNamespaceDeclHandler(ptr noundef writeonly %parser, ptr noundef %start) local_unnamed_addr #2 {
entry:
  %cmp.not = icmp eq ptr %parser, null
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %m_startNamespaceDeclHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 23
  store ptr %start, ptr %m_startNamespaceDeclHandler, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) uwtable
define hidden void @PyExpat_XML_SetEndNamespaceDeclHandler(ptr noundef writeonly %parser, ptr noundef %end) local_unnamed_addr #2 {
entry:
  %cmp.not = icmp eq ptr %parser, null
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %m_endNamespaceDeclHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 24
  store ptr %end, ptr %m_endNamespaceDeclHandler, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) uwtable
define hidden void @PyExpat_XML_SetNotStandaloneHandler(ptr noundef writeonly %parser, ptr noundef %handler) local_unnamed_addr #2 {
entry:
  %cmp.not = icmp eq ptr %parser, null
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %m_notStandaloneHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 25
  store ptr %handler, ptr %m_notStandaloneHandler, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) uwtable
define hidden void @PyExpat_XML_SetExternalEntityRefHandler(ptr noundef writeonly %parser, ptr noundef %handler) local_unnamed_addr #2 {
entry:
  %cmp.not = icmp eq ptr %parser, null
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %m_externalEntityRefHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 26
  store ptr %handler, ptr %m_externalEntityRefHandler, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) uwtable
define hidden void @PyExpat_XML_SetExternalEntityRefHandlerArg(ptr noundef %parser, ptr noundef %arg) local_unnamed_addr #2 {
entry:
  %cmp = icmp eq ptr %parser, null
  br i1 %cmp, label %if.end3, label %if.end

if.end:                                           ; preds = %entry
  %tobool.not = icmp eq ptr %arg, null
  %m_externalEntityRefHandlerArg2 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 27
  %parser.arg = select i1 %tobool.not, ptr %parser, ptr %arg
  store ptr %parser.arg, ptr %m_externalEntityRefHandlerArg2, align 8
  br label %if.end3

if.end3:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) uwtable
define hidden void @PyExpat_XML_SetSkippedEntityHandler(ptr noundef writeonly %parser, ptr noundef %handler) local_unnamed_addr #2 {
entry:
  %cmp.not = icmp eq ptr %parser, null
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %m_skippedEntityHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 28
  store ptr %handler, ptr %m_skippedEntityHandler, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) uwtable
define hidden void @PyExpat_XML_SetUnknownEncodingHandler(ptr noundef writeonly %parser, ptr noundef %handler, ptr noundef %data) local_unnamed_addr #2 {
entry:
  %cmp = icmp eq ptr %parser, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %m_unknownEncodingHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 29
  store ptr %handler, ptr %m_unknownEncodingHandler, align 8
  %m_unknownEncodingHandlerData = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 42
  store ptr %data, ptr %m_unknownEncodingHandlerData, align 8
  br label %return

return:                                           ; preds = %entry, %if.end
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) uwtable
define hidden void @PyExpat_XML_SetElementDeclHandler(ptr noundef writeonly %parser, ptr noundef %eldecl) local_unnamed_addr #2 {
entry:
  %cmp.not = icmp eq ptr %parser, null
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %m_elementDeclHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 30
  store ptr %eldecl, ptr %m_elementDeclHandler, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) uwtable
define hidden void @PyExpat_XML_SetAttlistDeclHandler(ptr noundef writeonly %parser, ptr noundef %attdecl) local_unnamed_addr #2 {
entry:
  %cmp.not = icmp eq ptr %parser, null
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %m_attlistDeclHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 31
  store ptr %attdecl, ptr %m_attlistDeclHandler, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) uwtable
define hidden void @PyExpat_XML_SetEntityDeclHandler(ptr noundef writeonly %parser, ptr noundef %handler) local_unnamed_addr #2 {
entry:
  %cmp.not = icmp eq ptr %parser, null
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %m_entityDeclHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 32
  store ptr %handler, ptr %m_entityDeclHandler, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) uwtable
define hidden void @PyExpat_XML_SetXmlDeclHandler(ptr noundef writeonly %parser, ptr noundef %handler) local_unnamed_addr #2 {
entry:
  %cmp.not = icmp eq ptr %parser, null
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %m_xmlDeclHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 33
  store ptr %handler, ptr %m_xmlDeclHandler, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite) uwtable
define hidden i32 @PyExpat_XML_SetParamEntityParsing(ptr noundef %parser, i32 noundef %peParsing) local_unnamed_addr #3 {
entry:
  %cmp = icmp eq ptr %parser, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %m_parsingStatus = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 85
  %0 = load i32, ptr %m_parsingStatus, align 8
  switch i32 %0, label %if.end6 [
    i32 1, label %return
    i32 3, label %return
  ]

if.end6:                                          ; preds = %if.end
  %m_paramEntityParsing = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 88
  store i32 %peParsing, ptr %m_paramEntityParsing, align 4
  br label %return

return:                                           ; preds = %if.end, %if.end, %entry, %if.end6
  %retval.0 = phi i32 [ 1, %if.end6 ], [ 0, %entry ], [ 0, %if.end ], [ 0, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define hidden i32 @PyExpat_XML_SetHashSalt(ptr noundef %parser, i64 noundef %hash_salt) local_unnamed_addr #5 {
entry:
  br label %tailrecurse

tailrecurse:                                      ; preds = %if.end, %entry
  %parser.tr = phi ptr [ %parser, %entry ], [ %0, %if.end ]
  %cmp = icmp eq ptr %parser.tr, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %tailrecurse
  %m_parentParser = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser.tr, i64 0, i32 84
  %0 = load ptr, ptr %m_parentParser, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %if.end3, label %tailrecurse

if.end3:                                          ; preds = %if.end
  %m_parsingStatus = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser.tr, i64 0, i32 85
  %1 = load i32, ptr %m_parsingStatus, align 8
  switch i32 %1, label %if.end9 [
    i32 1, label %return
    i32 3, label %return
  ]

if.end9:                                          ; preds = %if.end3
  %m_hash_secret_salt = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser.tr, i64 0, i32 89
  store i64 %hash_salt, ptr %m_hash_secret_salt, align 8
  br label %return

return:                                           ; preds = %tailrecurse, %if.end3, %if.end3, %if.end9
  %retval.0 = phi i32 [ 1, %if.end9 ], [ 0, %if.end3 ], [ 0, %if.end3 ], [ 0, %tailrecurse ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define hidden i32 @PyExpat_XML_Parse(ptr noundef %parser, ptr noundef readonly %s, i32 noundef %len, i32 noundef %isFinal) local_unnamed_addr #0 {
entry:
  %cmp = icmp eq ptr %parser, null
  %cmp1 = icmp slt i32 %len, 0
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %entry
  %cmp3 = icmp eq ptr %s, null
  %cmp4 = icmp ne i32 %len, 0
  %or.cond1 = and i1 %cmp3, %cmp4
  br i1 %or.cond1, label %if.then6, label %if.end7

if.then:                                          ; preds = %entry
  br i1 %cmp, label %return, label %if.then6

if.then6:                                         ; preds = %lor.lhs.false2, %if.then
  %m_errorCode = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 46
  store i32 41, ptr %m_errorCode, align 8
  br label %return

if.end7:                                          ; preds = %lor.lhs.false2
  %m_parsingStatus = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 85
  %0 = load i32, ptr %m_parsingStatus, align 8
  switch i32 %0, label %sw.default [
    i32 3, label %sw.bb
    i32 2, label %sw.bb9
    i32 0, label %sw.bb11
  ]

sw.bb:                                            ; preds = %if.end7
  %m_errorCode8 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 46
  store i32 33, ptr %m_errorCode8, align 8
  br label %return

sw.bb9:                                           ; preds = %if.end7
  %m_errorCode10 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 46
  store i32 36, ptr %m_errorCode10, align 8
  br label %return

sw.bb11:                                          ; preds = %if.end7
  %m_parentParser = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 84
  %1 = load ptr, ptr %m_parentParser, align 8
  %cmp12 = icmp eq ptr %1, null
  br i1 %cmp12, label %land.lhs.true13, label %sw.default

land.lhs.true13:                                  ; preds = %sw.bb11
  %call = tail call fastcc zeroext i8 @startParsing(ptr noundef nonnull %parser), !range !13
  %tobool.not = icmp eq i8 %call, 0
  br i1 %tobool.not, label %if.then14, label %sw.default

if.then14:                                        ; preds = %land.lhs.true13
  %m_errorCode15 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 46
  store i32 1, ptr %m_errorCode15, align 8
  br label %return

sw.default:                                       ; preds = %sw.bb11, %land.lhs.true13, %if.end7
  store i32 1, ptr %m_parsingStatus, align 8
  %cmp19 = icmp eq i32 %len, 0
  br i1 %cmp19, label %if.then20, label %if.else

if.then20:                                        ; preds = %sw.default
  %conv = trunc i32 %isFinal to i8
  %finalBuffer = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 85, i32 1
  store i8 %conv, ptr %finalBuffer, align 4
  %tobool22.not = icmp eq i32 %isFinal, 0
  br i1 %tobool22.not, label %return, label %if.end24

if.end24:                                         ; preds = %if.then20
  %m_bufferPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 4
  %2 = load ptr, ptr %m_bufferPtr, align 8
  %m_positionPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 49
  store ptr %2, ptr %m_positionPtr, align 8
  %m_bufferEnd = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 5
  %3 = load ptr, ptr %m_bufferEnd, align 8
  %m_parseEndPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 8
  store ptr %3, ptr %m_parseEndPtr, align 8
  %m_processor = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 45
  %4 = load ptr, ptr %m_processor, align 8
  %call28 = tail call i32 %4(ptr noundef nonnull %parser, ptr noundef %2, ptr noundef %3, ptr noundef nonnull %m_bufferPtr) #24
  %m_errorCode29 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 46
  store i32 %call28, ptr %m_errorCode29, align 8
  %cmp31 = icmp eq i32 %call28, 0
  br i1 %cmp31, label %if.then33, label %if.end46

if.then33:                                        ; preds = %if.end24
  %5 = load i32, ptr %m_parsingStatus, align 8
  switch i32 %5, label %return [
    i32 3, label %sw.bb36
    i32 0, label %sw.bb42
    i32 1, label %sw.bb42
  ]

sw.bb36:                                          ; preds = %if.then33
  %m_encoding = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 34
  %6 = load ptr, ptr %m_encoding, align 8
  %updatePosition = getelementptr inbounds %struct.encoding, ptr %6, i64 0, i32 8
  %7 = load ptr, ptr %updatePosition, align 8
  %8 = load ptr, ptr %m_positionPtr, align 8
  %9 = load ptr, ptr %m_bufferPtr, align 8
  %m_position = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 78
  tail call void %7(ptr noundef %6, ptr noundef %8, ptr noundef %9, ptr noundef nonnull %m_position) #24
  %10 = load ptr, ptr %m_bufferPtr, align 8
  store ptr %10, ptr %m_positionPtr, align 8
  br label %return

sw.bb42:                                          ; preds = %if.then33, %if.then33
  store i32 2, ptr %m_parsingStatus, align 8
  br label %return

if.end46:                                         ; preds = %if.end24
  %m_eventPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 47
  %11 = load ptr, ptr %m_eventPtr, align 8
  %m_eventEndPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 48
  store ptr %11, ptr %m_eventEndPtr, align 8
  store ptr @errorProcessor, ptr %m_processor, align 8
  br label %return

if.else:                                          ; preds = %sw.default
  %call48 = tail call ptr @PyExpat_XML_GetBuffer(ptr noundef nonnull %parser, i32 noundef %len)
  %cmp49 = icmp eq ptr %call48, null
  br i1 %cmp49, label %return, label %if.else52

if.else52:                                        ; preds = %if.else
  %conv53 = zext nneg i32 %len to i64
  tail call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 1 %call48, ptr align 1 %s, i64 %conv53, i1 false)
  %call54 = tail call i32 @PyExpat_XML_ParseBuffer(ptr noundef nonnull %parser, i32 noundef %len, i32 noundef %isFinal), !range !25
  br label %return

return:                                           ; preds = %if.else, %if.then33, %sw.bb42, %if.then20, %if.then, %if.then6, %if.else52, %if.end46, %sw.bb36, %if.then14, %sw.bb9, %sw.bb
  %retval.0 = phi i32 [ 2, %sw.bb36 ], [ 0, %if.end46 ], [ %call54, %if.else52 ], [ 0, %if.then14 ], [ 0, %sw.bb9 ], [ 0, %sw.bb ], [ 0, %if.then6 ], [ 0, %if.then ], [ 1, %if.then20 ], [ 1, %sw.bb42 ], [ 1, %if.then33 ], [ 0, %if.else ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal fastcc zeroext i8 @startParsing(ptr nocapture noundef %parser) unnamed_addr #0 {
entry:
  %afterValue.i.i2.i = alloca ptr, align 8
  %tv.i.i = alloca %struct.timeval, align 8
  %afterValue.i.i.i = alloca ptr, align 8
  %entropy.i = alloca i64, align 8
  %m_hash_secret_salt = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 89
  %0 = load i64, ptr %m_hash_secret_salt, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %entropy.i)
  br label %do.body.i.i

do.body.i.i:                                      ; preds = %land.rhs.i.i, %if.then
  %bytesWrittenTotal.0.i.i = phi i64 [ 0, %if.then ], [ %bytesWrittenTotal.111.i.i, %land.rhs.i.i ]
  %add.ptr.i.i = getelementptr i8, ptr %entropy.i, i64 %bytesWrittenTotal.0.i.i
  %sub.i.i = sub i64 8, %bytesWrittenTotal.0.i.i
  %call.i.i = call i64 @getrandom(ptr noundef %add.ptr.i.i, i64 noundef %sub.i.i, i32 noundef 1) #24
  %conv.i.i = trunc i64 %call.i.i to i32
  %cmp.i.i = icmp sgt i32 %conv.i.i, 0
  br i1 %cmp.i.i, label %do.cond.i.i, label %land.rhs.i.i

do.cond.i.i:                                      ; preds = %do.body.i.i
  %conv2.i.i = and i64 %call.i.i, 4294967295
  %add.i.i = add i64 %conv2.i.i, %bytesWrittenTotal.0.i.i
  %cmp3.i.i = icmp ugt i64 %add.i.i, 7
  br i1 %cmp3.i.i, label %if.then.i, label %land.rhs.i.i

land.rhs.i.i:                                     ; preds = %do.cond.i.i, %do.body.i.i
  %bytesWrittenTotal.111.i.i = phi i64 [ %add.i.i, %do.cond.i.i ], [ %bytesWrittenTotal.0.i.i, %do.body.i.i ]
  %call7.i.i = tail call ptr @__errno_location() #26
  %1 = load i32, ptr %call7.i.i, align 4
  %cmp8.i.i = icmp eq i32 %1, 4
  br i1 %cmp8.i.i, label %do.body.i.i, label %if.end.i, !llvm.loop !26

if.then.i:                                        ; preds = %do.cond.i.i
  %2 = load i64, ptr %entropy.i, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %afterValue.i.i.i)
  %call.i.i.i = call ptr @getenv(ptr noundef nonnull @.str.324) #24
  %cmp.i.i.i = icmp eq ptr %call.i.i.i, null
  br i1 %cmp.i.i.i, label %getDebugLevel.exit.thread.i.i, label %if.end.i.i.i

if.end.i.i.i:                                     ; preds = %if.then.i
  %call1.i.i.i = tail call ptr @__errno_location() #26
  store i32 0, ptr %call1.i.i.i, align 4
  store ptr %call.i.i.i, ptr %afterValue.i.i.i, align 8
  %call2.i.i.i = call i64 @strtoul(ptr noundef nonnull %call.i.i.i, ptr noundef nonnull %afterValue.i.i.i, i32 noundef 10) #24
  %3 = load i32, ptr %call1.i.i.i, align 4
  %cmp4.not.i.i.i = icmp eq i32 %3, 0
  br i1 %cmp4.not.i.i.i, label %lor.lhs.false.i.i.i, label %if.then7.i.i.i

lor.lhs.false.i.i.i:                              ; preds = %if.end.i.i.i
  %4 = load ptr, ptr %afterValue.i.i.i, align 8
  %5 = load i8, ptr %4, align 1
  %cmp5.not.i.i.i = icmp eq i8 %5, 0
  br i1 %cmp5.not.i.i.i, label %getDebugLevel.exit.i.i, label %if.then7.i.i.i

if.then7.i.i.i:                                   ; preds = %lor.lhs.false.i.i.i, %if.end.i.i.i
  store i32 0, ptr %call1.i.i.i, align 4
  br label %getDebugLevel.exit.thread.i.i

getDebugLevel.exit.thread.i.i:                    ; preds = %if.then7.i.i.i, %if.then.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %afterValue.i.i.i)
  br label %generate_hash_secret_salt.exit

getDebugLevel.exit.i.i:                           ; preds = %lor.lhs.false.i.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %afterValue.i.i.i)
  %cmp.not.i.i = icmp eq i64 %call2.i.i.i, 0
  br i1 %cmp.not.i.i, label %generate_hash_secret_salt.exit, label %if.then.i.i

if.then.i.i:                                      ; preds = %getDebugLevel.exit.i.i
  %6 = load ptr, ptr @stderr, align 8
  %call1.i.i = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %6, ptr noundef nonnull @.str.325, ptr noundef nonnull @.str.322, i32 noundef 16, i64 noundef %2, i64 noundef 8) #27
  br label %generate_hash_secret_salt.exit

if.end.i:                                         ; preds = %land.rhs.i.i
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %tv.i.i)
  %call.i1.i = call i32 @gettimeofday(ptr noundef nonnull %tv.i.i, ptr noundef null) #24
  %tv_usec.i.i = getelementptr inbounds %struct.timeval, ptr %tv.i.i, i64 0, i32 1
  %7 = load i64, ptr %tv_usec.i.i, align 8
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %tv.i.i)
  %call3.i = call i32 @getpid() #24
  %conv.i = sext i32 %call3.i to i64
  %xor.i = xor i64 %7, %conv.i
  store i64 %xor.i, ptr %entropy.i, align 8
  %mul.i = mul i64 %xor.i, 2305843009213693951
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %afterValue.i.i2.i)
  %call.i.i3.i = call ptr @getenv(ptr noundef nonnull @.str.324) #24
  %cmp.i.i4.i = icmp eq ptr %call.i.i3.i, null
  br i1 %cmp.i.i4.i, label %getDebugLevel.exit.thread.i10.i, label %if.end.i.i5.i

if.end.i.i5.i:                                    ; preds = %if.end.i
  store i32 0, ptr %call7.i.i, align 4
  store ptr %call.i.i3.i, ptr %afterValue.i.i2.i, align 8
  %call2.i.i7.i = call i64 @strtoul(ptr noundef nonnull %call.i.i3.i, ptr noundef nonnull %afterValue.i.i2.i, i32 noundef 10) #24
  %8 = load i32, ptr %call7.i.i, align 4
  %cmp4.not.i.i8.i = icmp eq i32 %8, 0
  br i1 %cmp4.not.i.i8.i, label %lor.lhs.false.i.i11.i, label %if.then7.i.i9.i

lor.lhs.false.i.i11.i:                            ; preds = %if.end.i.i5.i
  %9 = load ptr, ptr %afterValue.i.i2.i, align 8
  %10 = load i8, ptr %9, align 1
  %cmp5.not.i.i12.i = icmp eq i8 %10, 0
  br i1 %cmp5.not.i.i12.i, label %getDebugLevel.exit.i13.i, label %if.then7.i.i9.i

if.then7.i.i9.i:                                  ; preds = %lor.lhs.false.i.i11.i, %if.end.i.i5.i
  store i32 0, ptr %call7.i.i, align 4
  br label %getDebugLevel.exit.thread.i10.i

getDebugLevel.exit.thread.i10.i:                  ; preds = %if.then7.i.i9.i, %if.end.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %afterValue.i.i2.i)
  br label %generate_hash_secret_salt.exit

getDebugLevel.exit.i13.i:                         ; preds = %lor.lhs.false.i.i11.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %afterValue.i.i2.i)
  %cmp.not.i14.i = icmp eq i64 %call2.i.i7.i, 0
  br i1 %cmp.not.i14.i, label %generate_hash_secret_salt.exit, label %if.then.i15.i

if.then.i15.i:                                    ; preds = %getDebugLevel.exit.i13.i
  %11 = load ptr, ptr @stderr, align 8
  %call1.i16.i = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %11, ptr noundef nonnull @.str.325, ptr noundef nonnull @.str.323, i32 noundef 16, i64 noundef %mul.i, i64 noundef 8) #27
  br label %generate_hash_secret_salt.exit

generate_hash_secret_salt.exit:                   ; preds = %getDebugLevel.exit.thread.i.i, %getDebugLevel.exit.i.i, %if.then.i.i, %getDebugLevel.exit.thread.i10.i, %getDebugLevel.exit.i13.i, %if.then.i15.i
  %retval.0.i = phi i64 [ %2, %getDebugLevel.exit.thread.i.i ], [ %2, %getDebugLevel.exit.i.i ], [ %2, %if.then.i.i ], [ %mul.i, %getDebugLevel.exit.thread.i10.i ], [ %mul.i, %getDebugLevel.exit.i13.i ], [ %mul.i, %if.then.i15.i ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %entropy.i)
  store i64 %retval.0.i, ptr %m_hash_secret_salt, align 8
  br label %if.end

if.end:                                           ; preds = %generate_hash_secret_salt.exit, %entry
  %m_ns = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 38
  %12 = load i8, ptr %m_ns, align 8
  %tobool.not = icmp eq i8 %12, 0
  br i1 %tobool.not, label %return, label %if.then2

if.then2:                                         ; preds = %if.end
  %call3 = call fastcc zeroext i8 @setContext(ptr noundef nonnull %parser, ptr noundef nonnull @implicitContext), !range !13
  br label %return

return:                                           ; preds = %if.end, %if.then2
  %retval.0 = phi i8 [ %call3, %if.then2 ], [ 1, %if.end ]
  ret i8 %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define internal i32 @errorProcessor(ptr nocapture noundef readonly %parser, ptr nocapture readnone %s, ptr nocapture readnone %end, ptr nocapture readnone %nextPtr) #4 {
entry:
  %m_errorCode = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 46
  %0 = load i32, ptr %m_errorCode, align 8
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define hidden ptr @PyExpat_XML_GetBuffer(ptr noundef %parser, i32 noundef %len) local_unnamed_addr #0 {
entry:
  %cmp = icmp eq ptr %parser, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %cmp1 = icmp slt i32 %len, 0
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %m_errorCode = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 46
  store i32 1, ptr %m_errorCode, align 8
  br label %return

if.end3:                                          ; preds = %if.end
  %m_parsingStatus = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 85
  %0 = load i32, ptr %m_parsingStatus, align 8
  switch i32 %0, label %sw.epilog [
    i32 3, label %sw.bb
    i32 2, label %sw.bb5
  ]

sw.bb:                                            ; preds = %if.end3
  %m_errorCode4 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 46
  store i32 33, ptr %m_errorCode4, align 8
  br label %return

sw.bb5:                                           ; preds = %if.end3
  %m_errorCode6 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 46
  store i32 36, ptr %m_errorCode6, align 8
  br label %return

sw.epilog:                                        ; preds = %if.end3
  %conv = zext nneg i32 %len to i64
  %m_bufferLim = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 6
  %1 = load ptr, ptr %m_bufferLim, align 8
  %tobool.not = icmp eq ptr %1, null
  br i1 %tobool.not, label %cond.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %sw.epilog
  %m_bufferEnd = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 5
  %2 = load ptr, ptr %m_bufferEnd, align 8
  %tobool7.not = icmp eq ptr %2, null
  br i1 %tobool7.not, label %cond.end, label %cond.true

cond.true:                                        ; preds = %land.lhs.true
  %sub.ptr.lhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  br label %cond.end

cond.end:                                         ; preds = %sw.epilog, %land.lhs.true, %cond.true
  %cond = phi i64 [ %sub.ptr.sub, %cond.true ], [ 0, %land.lhs.true ], [ 0, %sw.epilog ]
  %cmp10 = icmp slt i64 %cond, %conv
  %m_bufferEnd13 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 5
  %3 = load ptr, ptr %m_bufferEnd13, align 8
  br i1 %cmp10, label %if.then12, label %return

if.then12:                                        ; preds = %cond.end
  %tobool14.not = icmp eq ptr %3, null
  br i1 %tobool14.not, label %cond.end24, label %land.lhs.true15

land.lhs.true15:                                  ; preds = %if.then12
  %m_bufferPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 4
  %4 = load ptr, ptr %m_bufferPtr, align 8
  %tobool16.not = icmp eq ptr %4, null
  br i1 %tobool16.not, label %cond.end24, label %cond.true17

cond.true17:                                      ; preds = %land.lhs.true15
  %sub.ptr.lhs.cast20 = ptrtoint ptr %3 to i64
  %sub.ptr.rhs.cast21 = ptrtoint ptr %4 to i64
  %sub.ptr.sub22 = sub i64 %sub.ptr.lhs.cast20, %sub.ptr.rhs.cast21
  br label %cond.end24

cond.end24:                                       ; preds = %if.then12, %land.lhs.true15, %cond.true17
  %cond25 = phi i64 [ %sub.ptr.sub22, %cond.true17 ], [ 0, %land.lhs.true15 ], [ 0, %if.then12 ]
  %conv26 = trunc i64 %cond25 to i32
  %add = add i32 %conv26, %len
  %cmp27 = icmp slt i32 %add, 0
  br i1 %cmp27, label %if.then29, label %if.end31

if.then29:                                        ; preds = %cond.end24
  %m_errorCode30 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 46
  store i32 1, ptr %m_errorCode30, align 8
  br label %return

if.end31:                                         ; preds = %cond.end24
  %m_bufferPtr32 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 4
  %5 = load ptr, ptr %m_bufferPtr32, align 8
  %tobool33.not = icmp eq ptr %5, null
  br i1 %tobool33.not, label %cond.end43, label %land.lhs.true34

land.lhs.true34:                                  ; preds = %if.end31
  %m_buffer = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 2
  %6 = load ptr, ptr %m_buffer, align 8
  %tobool35.not = icmp eq ptr %6, null
  br i1 %tobool35.not, label %cond.end43, label %cond.true36

cond.true36:                                      ; preds = %land.lhs.true34
  %sub.ptr.lhs.cast39 = ptrtoint ptr %5 to i64
  %sub.ptr.rhs.cast40 = ptrtoint ptr %6 to i64
  %sub.ptr.sub41 = sub i64 %sub.ptr.lhs.cast39, %sub.ptr.rhs.cast40
  %7 = trunc i64 %sub.ptr.sub41 to i32
  br label %cond.end43

cond.end43:                                       ; preds = %if.end31, %land.lhs.true34, %cond.true36
  %cond44 = phi i32 [ %7, %cond.true36 ], [ 0, %land.lhs.true34 ], [ 0, %if.end31 ]
  %spec.store.select = tail call i32 @llvm.smin.i32(i32 %cond44, i32 1024)
  %sub = xor i32 %add, 2147483647
  %cmp50 = icmp sgt i32 %spec.store.select, %sub
  br i1 %cmp50, label %if.then52, label %if.end54

if.then52:                                        ; preds = %cond.end43
  %m_errorCode53 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 46
  store i32 1, ptr %m_errorCode53, align 8
  br label %return

if.end54:                                         ; preds = %cond.end43
  %add55 = add i32 %spec.store.select, %add
  br i1 %tobool.not, label %cond.end69.thread, label %land.lhs.true59

land.lhs.true59:                                  ; preds = %if.end54
  %conv56 = sext i32 %add55 to i64
  %m_buffer60 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 2
  %8 = load ptr, ptr %m_buffer60, align 8
  %tobool61.not = icmp eq ptr %8, null
  %sub.ptr.lhs.cast65 = ptrtoint ptr %1 to i64
  %sub.ptr.rhs.cast66 = ptrtoint ptr %8 to i64
  %sub.ptr.sub67 = sub i64 %sub.ptr.lhs.cast65, %sub.ptr.rhs.cast66
  %cond70 = select i1 %tobool61.not, i64 0, i64 %sub.ptr.sub67
  %cmp71.not = icmp slt i64 %cond70, %conv56
  br i1 %cmp71.not, label %if.else, label %if.then73

cond.end69.thread:                                ; preds = %if.end54
  %cmp71.not118 = icmp sgt i32 %add55, 0
  br i1 %cmp71.not118, label %cond.end135.thread, label %if.then73

if.then73:                                        ; preds = %cond.end69.thread, %land.lhs.true59
  %conv74 = sext i32 %spec.store.select to i64
  br i1 %tobool33.not, label %cond.end87.thread, label %land.lhs.true77

land.lhs.true77:                                  ; preds = %if.then73
  %m_buffer78 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 2
  %9 = load ptr, ptr %m_buffer78, align 8
  %tobool79.not = icmp eq ptr %9, null
  %sub.ptr.lhs.cast83 = ptrtoint ptr %5 to i64
  %sub.ptr.rhs.cast84 = ptrtoint ptr %9 to i64
  %sub.ptr.sub85 = sub i64 %sub.ptr.lhs.cast83, %sub.ptr.rhs.cast84
  %cond88 = select i1 %tobool79.not, i64 0, i64 %sub.ptr.sub85
  %cmp89 = icmp sgt i64 %cond88, %conv74
  br i1 %cmp89, label %land.lhs.true94, label %if.end214

cond.end87.thread:                                ; preds = %if.then73
  %cmp89116 = icmp slt i32 %cond44, 0
  br i1 %cmp89116, label %cond.end87.thread.cond.end104_crit_edge, label %if.end214

cond.end87.thread.cond.end104_crit_edge:          ; preds = %cond.end87.thread
  %m_buffer108.phi.trans.insert = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 2
  %.pre = load ptr, ptr %m_buffer108.phi.trans.insert, align 8
  br label %cond.end104

land.lhs.true94:                                  ; preds = %land.lhs.true77
  %10 = trunc i64 %sub.ptr.sub85 to i32
  %spec.select124 = select i1 %tobool79.not, i32 0, i32 %10
  br label %cond.end104

cond.end104:                                      ; preds = %land.lhs.true94, %cond.end87.thread.cond.end104_crit_edge
  %sub.ptr.rhs.cast113.pre-phi = phi i64 [ 0, %cond.end87.thread.cond.end104_crit_edge ], [ %sub.ptr.lhs.cast83, %land.lhs.true94 ]
  %11 = phi ptr [ %.pre, %cond.end87.thread.cond.end104_crit_edge ], [ %9, %land.lhs.true94 ]
  %cond105 = phi i32 [ 0, %cond.end87.thread.cond.end104_crit_edge ], [ %spec.select124, %land.lhs.true94 ]
  %sub107 = sub i32 %cond105, %spec.store.select
  %idxprom = sext i32 %sub107 to i64
  %arrayidx = getelementptr i8, ptr %11, i64 %idxprom
  %sub.ptr.lhs.cast112 = ptrtoint ptr %3 to i64
  %sub.ptr.sub114 = sub i64 %sub.ptr.lhs.cast112, %sub.ptr.rhs.cast113.pre-phi
  %add116 = add i64 %sub.ptr.sub114, %conv74
  tail call void @llvm.memmove.p0.p0.i64(ptr align 1 %11, ptr align 1 %arrayidx, i64 %add116, i1 false)
  %12 = load ptr, ptr %m_bufferEnd13, align 8
  %idx.neg = sub nsw i64 0, %idxprom
  %add.ptr = getelementptr i8, ptr %12, i64 %idx.neg
  store ptr %add.ptr, ptr %m_bufferEnd13, align 8
  %13 = load ptr, ptr %m_bufferPtr32, align 8
  %add.ptr121 = getelementptr i8, ptr %13, i64 %idx.neg
  br label %if.end214.sink.split

if.else:                                          ; preds = %land.lhs.true59
  %sub.ptr.rhs.cast132 = ptrtoint ptr %5 to i64
  %sub.ptr.sub133 = sub i64 %sub.ptr.lhs.cast65, %sub.ptr.rhs.cast132
  %sub.ptr.sub133.fr = freeze i64 %sub.ptr.sub133
  %14 = trunc i64 %sub.ptr.sub133.fr to i32
  %cmp138 = icmp eq i32 %14, 0
  %or.cond = or i1 %tobool33.not, %cmp138
  br i1 %or.cond, label %cond.end135.thread, label %do.body.preheader

cond.end135.thread:                               ; preds = %if.else, %cond.end69.thread
  br label %do.body.preheader

do.body.preheader:                                ; preds = %if.else, %cond.end135.thread
  %bufferSize.0.ph = phi i32 [ %14, %if.else ], [ 1024, %cond.end135.thread ]
  br label %do.body

do.body:                                          ; preds = %do.body.preheader, %do.body
  %bufferSize.0 = phi i32 [ %mul, %do.body ], [ %bufferSize.0.ph, %do.body.preheader ]
  %mul = shl i32 %bufferSize.0, 1
  %cmp142 = icmp slt i32 %mul, %add55
  %cmp144 = icmp sgt i32 %mul, 0
  %15 = and i1 %cmp142, %cmp144
  br i1 %15, label %do.body, label %do.end, !llvm.loop !27

do.end:                                           ; preds = %do.body
  %cmp146 = icmp slt i32 %mul, 1
  br i1 %cmp146, label %if.then148, label %if.end150

if.then148:                                       ; preds = %do.end
  %m_errorCode149 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 46
  store i32 1, ptr %m_errorCode149, align 8
  br label %return

if.end150:                                        ; preds = %do.end
  %m_mem = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 3
  %16 = load ptr, ptr %m_mem, align 8
  %conv151 = zext nneg i32 %mul to i64
  %call = tail call ptr %16(i64 noundef %conv151) #24
  %cmp152 = icmp eq ptr %call, null
  br i1 %cmp152, label %if.then154, label %if.end156

if.then154:                                       ; preds = %if.end150
  %m_errorCode155 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 46
  store i32 1, ptr %m_errorCode155, align 8
  br label %return

if.end156:                                        ; preds = %if.end150
  %add.ptr158 = getelementptr i8, ptr %call, i64 %conv151
  store ptr %add.ptr158, ptr %m_bufferLim, align 8
  %17 = load ptr, ptr %m_bufferPtr32, align 8
  %tobool161.not = icmp eq ptr %17, null
  br i1 %tobool161.not, label %if.else209, label %if.then162

if.then162:                                       ; preds = %if.end156
  %sub164 = sub i32 0, %spec.store.select
  %idxprom165 = sext i32 %sub164 to i64
  %arrayidx166 = getelementptr i8, ptr %17, i64 %idxprom165
  %18 = load ptr, ptr %m_bufferEnd13, align 8
  %tobool168.not = icmp eq ptr %18, null
  %sub.ptr.lhs.cast175 = ptrtoint ptr %18 to i64
  %sub.ptr.rhs.cast176 = ptrtoint ptr %17 to i64
  %sub.ptr.sub177 = sub i64 %sub.ptr.lhs.cast175, %sub.ptr.rhs.cast176
  %cond180 = select i1 %tobool168.not, i64 0, i64 %sub.ptr.sub177
  %conv181 = sext i32 %spec.store.select to i64
  %add182 = add i64 %cond180, %conv181
  tail call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 1 %call, ptr align 1 %arrayidx166, i64 %add182, i1 false)
  %free_fcn = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 3, i32 2
  %19 = load ptr, ptr %free_fcn, align 8
  %m_buffer184 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 2
  %20 = load ptr, ptr %m_buffer184, align 8
  tail call void %19(ptr noundef %20) #24
  store ptr %call, ptr %m_buffer184, align 8
  %21 = load ptr, ptr %m_bufferEnd13, align 8
  %tobool188.not = icmp eq ptr %21, null
  br i1 %tobool188.not, label %cond.end199, label %land.lhs.true189

land.lhs.true189:                                 ; preds = %if.then162
  %22 = load ptr, ptr %m_bufferPtr32, align 8
  %tobool191.not = icmp eq ptr %22, null
  br i1 %tobool191.not, label %cond.end199, label %cond.true192

cond.true192:                                     ; preds = %land.lhs.true189
  %sub.ptr.lhs.cast195 = ptrtoint ptr %21 to i64
  %sub.ptr.rhs.cast196 = ptrtoint ptr %22 to i64
  %sub.ptr.sub197 = sub i64 %sub.ptr.lhs.cast195, %sub.ptr.rhs.cast196
  br label %cond.end199

cond.end199:                                      ; preds = %if.then162, %land.lhs.true189, %cond.true192
  %cond200 = phi i64 [ %sub.ptr.sub197, %cond.true192 ], [ 0, %land.lhs.true189 ], [ 0, %if.then162 ]
  %add.ptr201 = getelementptr i8, ptr %call, i64 %cond200
  %add.ptr203 = getelementptr i8, ptr %add.ptr201, i64 %conv181
  store ptr %add.ptr203, ptr %m_bufferEnd13, align 8
  %add.ptr207 = getelementptr i8, ptr %call, i64 %conv181
  br label %if.end214.sink.split

if.else209:                                       ; preds = %if.end156
  store ptr %call, ptr %m_bufferEnd13, align 8
  %m_buffer211 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 2
  store ptr %call, ptr %m_buffer211, align 8
  br label %if.end214.sink.split

if.end214.sink.split:                             ; preds = %cond.end104, %if.else209, %cond.end199
  %add.ptr207.sink = phi ptr [ %add.ptr207, %cond.end199 ], [ %call, %if.else209 ], [ %add.ptr121, %cond.end104 ]
  %.ph = phi ptr [ %add.ptr203, %cond.end199 ], [ %call, %if.else209 ], [ %add.ptr, %cond.end104 ]
  store ptr %add.ptr207.sink, ptr %m_bufferPtr32, align 8
  br label %if.end214

if.end214:                                        ; preds = %if.end214.sink.split, %cond.end87.thread, %land.lhs.true77
  %23 = phi ptr [ %3, %cond.end87.thread ], [ %3, %land.lhs.true77 ], [ %.ph, %if.end214.sink.split ]
  %m_eventPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 47
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %m_eventPtr, i8 0, i64 24, i1 false)
  br label %return

return:                                           ; preds = %cond.end, %if.end214, %entry, %if.then154, %if.then148, %if.then52, %if.then29, %sw.bb5, %sw.bb, %if.then2
  %retval.0 = phi ptr [ null, %if.then2 ], [ null, %if.then29 ], [ null, %if.then52 ], [ null, %if.then148 ], [ null, %if.then154 ], [ null, %sw.bb5 ], [ null, %sw.bb ], [ null, %entry ], [ %23, %if.end214 ], [ %3, %cond.end ]
  ret ptr %retval.0
}

; Function Attrs: mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #6

; Function Attrs: nounwind uwtable
define hidden i32 @PyExpat_XML_ParseBuffer(ptr noundef %parser, i32 noundef %len, i32 noundef %isFinal) local_unnamed_addr #0 {
entry:
  %cmp = icmp eq ptr %parser, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %m_parsingStatus = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 85
  %0 = load i32, ptr %m_parsingStatus, align 8
  switch i32 %0, label %sw.default [
    i32 3, label %sw.bb
    i32 2, label %sw.bb1
    i32 0, label %sw.bb3
  ]

sw.bb:                                            ; preds = %if.end
  %m_errorCode = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 46
  store i32 33, ptr %m_errorCode, align 8
  br label %return

sw.bb1:                                           ; preds = %if.end
  %m_errorCode2 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 46
  store i32 36, ptr %m_errorCode2, align 8
  br label %return

sw.bb3:                                           ; preds = %if.end
  %m_bufferPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 4
  %1 = load ptr, ptr %m_bufferPtr, align 8
  %tobool.not = icmp eq ptr %1, null
  br i1 %tobool.not, label %if.then4, label %if.end6

if.then4:                                         ; preds = %sw.bb3
  %m_errorCode5 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 46
  store i32 42, ptr %m_errorCode5, align 8
  br label %return

if.end6:                                          ; preds = %sw.bb3
  %m_parentParser = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 84
  %2 = load ptr, ptr %m_parentParser, align 8
  %cmp7 = icmp eq ptr %2, null
  br i1 %cmp7, label %land.lhs.true, label %sw.default

land.lhs.true:                                    ; preds = %if.end6
  %call = tail call fastcc zeroext i8 @startParsing(ptr noundef nonnull %parser), !range !13
  %tobool8.not = icmp eq i8 %call, 0
  br i1 %tobool8.not, label %if.then9, label %sw.default

if.then9:                                         ; preds = %land.lhs.true
  %m_errorCode10 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 46
  store i32 1, ptr %m_errorCode10, align 8
  br label %return

sw.default:                                       ; preds = %if.end6, %land.lhs.true, %if.end
  store i32 1, ptr %m_parsingStatus, align 8
  %m_bufferPtr14 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 4
  %3 = load ptr, ptr %m_bufferPtr14, align 8
  %m_positionPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 49
  store ptr %3, ptr %m_positionPtr, align 8
  %m_bufferEnd = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 5
  %4 = load ptr, ptr %m_bufferEnd, align 8
  %idx.ext = sext i32 %len to i64
  %add.ptr = getelementptr i8, ptr %4, i64 %idx.ext
  store ptr %add.ptr, ptr %m_bufferEnd, align 8
  %m_parseEndPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 8
  store ptr %add.ptr, ptr %m_parseEndPtr, align 8
  %m_parseEndByteIndex = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 7
  %5 = load i64, ptr %m_parseEndByteIndex, align 8
  %add = add i64 %5, %idx.ext
  store i64 %add, ptr %m_parseEndByteIndex, align 8
  %conv16 = trunc i32 %isFinal to i8
  %finalBuffer = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 85, i32 1
  store i8 %conv16, ptr %finalBuffer, align 4
  %m_processor = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 45
  %6 = load ptr, ptr %m_processor, align 8
  %call20 = tail call i32 %6(ptr noundef nonnull %parser, ptr noundef %3, ptr noundef %add.ptr, ptr noundef nonnull %m_bufferPtr14) #24
  %m_errorCode21 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 46
  store i32 %call20, ptr %m_errorCode21, align 8
  %cmp23.not = icmp eq i32 %call20, 0
  br i1 %cmp23.not, label %if.else, label %if.then25

if.then25:                                        ; preds = %sw.default
  %m_eventPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 47
  %7 = load ptr, ptr %m_eventPtr, align 8
  %m_eventEndPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 48
  store ptr %7, ptr %m_eventEndPtr, align 8
  store ptr @errorProcessor, ptr %m_processor, align 8
  br label %return

if.else:                                          ; preds = %sw.default
  %8 = load i32, ptr %m_parsingStatus, align 8
  switch i32 %8, label %if.end38 [
    i32 3, label %sw.bb29
    i32 0, label %sw.bb30
    i32 1, label %sw.bb30
  ]

sw.bb29:                                          ; preds = %if.else
  br label %if.end38

sw.bb30:                                          ; preds = %if.else, %if.else
  %tobool31.not = icmp eq i32 %isFinal, 0
  br i1 %tobool31.not, label %if.end38, label %if.then32

if.then32:                                        ; preds = %sw.bb30
  store i32 2, ptr %m_parsingStatus, align 8
  br label %return

if.end38:                                         ; preds = %sw.bb29, %sw.bb30, %if.else
  %result.0 = phi i32 [ 1, %if.else ], [ 1, %sw.bb30 ], [ 2, %sw.bb29 ]
  %m_encoding = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 34
  %9 = load ptr, ptr %m_encoding, align 8
  %updatePosition = getelementptr inbounds %struct.encoding, ptr %9, i64 0, i32 8
  %10 = load ptr, ptr %updatePosition, align 8
  %11 = load ptr, ptr %m_positionPtr, align 8
  %12 = load ptr, ptr %m_bufferPtr14, align 8
  %m_position = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 78
  tail call void %10(ptr noundef %9, ptr noundef %11, ptr noundef %12, ptr noundef nonnull %m_position) #24
  %13 = load ptr, ptr %m_bufferPtr14, align 8
  store ptr %13, ptr %m_positionPtr, align 8
  br label %return

return:                                           ; preds = %entry, %if.end38, %if.then32, %if.then25, %if.then9, %if.then4, %sw.bb1, %sw.bb
  %retval.0 = phi i32 [ 0, %if.then25 ], [ %result.0, %if.end38 ], [ 1, %if.then32 ], [ 0, %if.then9 ], [ 0, %if.then4 ], [ 0, %sw.bb1 ], [ 0, %sw.bb ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memmove.p0.p0.i64(ptr nocapture writeonly, ptr nocapture readonly, i64, i1 immarg) #6

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite) uwtable
define hidden i32 @PyExpat_XML_StopParser(ptr noundef %parser, i8 noundef zeroext %resumable) local_unnamed_addr #3 {
entry:
  %cmp = icmp eq ptr %parser, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %m_parsingStatus = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 85
  %0 = load i32, ptr %m_parsingStatus, align 8
  switch i32 %0, label %sw.default [
    i32 3, label %sw.bb
    i32 2, label %sw.bb5
  ]

sw.bb:                                            ; preds = %if.end
  %tobool.not = icmp eq i8 %resumable, 0
  br i1 %tobool.not, label %if.end2, label %if.then1

if.then1:                                         ; preds = %sw.bb
  %m_errorCode = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 46
  store i32 33, ptr %m_errorCode, align 8
  br label %return

if.end2:                                          ; preds = %sw.bb
  store i32 2, ptr %m_parsingStatus, align 8
  br label %return

sw.bb5:                                           ; preds = %if.end
  %m_errorCode6 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 46
  store i32 36, ptr %m_errorCode6, align 8
  br label %return

sw.default:                                       ; preds = %if.end
  %tobool7.not = icmp eq i8 %resumable, 0
  br i1 %tobool7.not, label %if.else, label %if.then8

if.then8:                                         ; preds = %sw.default
  %m_isParamEntity = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 86
  %1 = load i8, ptr %m_isParamEntity, align 8
  %tobool9.not = icmp eq i8 %1, 0
  br i1 %tobool9.not, label %if.end12, label %if.then10

if.then10:                                        ; preds = %if.then8
  %m_errorCode11 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 46
  store i32 37, ptr %m_errorCode11, align 8
  br label %return

if.end12:                                         ; preds = %if.then8
  store i32 3, ptr %m_parsingStatus, align 8
  br label %return

if.else:                                          ; preds = %sw.default
  store i32 2, ptr %m_parsingStatus, align 8
  br label %return

return:                                           ; preds = %if.end2, %if.else, %if.end12, %entry, %if.then10, %sw.bb5, %if.then1
  %retval.0 = phi i32 [ 0, %if.then10 ], [ 0, %sw.bb5 ], [ 0, %if.then1 ], [ 0, %entry ], [ 1, %if.end12 ], [ 1, %if.else ], [ 1, %if.end2 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define hidden i32 @PyExpat_XML_ResumeParser(ptr noundef %parser) local_unnamed_addr #0 {
entry:
  %cmp = icmp eq ptr %parser, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %m_parsingStatus = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 85
  %0 = load i32, ptr %m_parsingStatus, align 8
  %cmp1.not = icmp eq i32 %0, 3
  br i1 %cmp1.not, label %if.end3, label %if.then2

if.then2:                                         ; preds = %if.end
  %m_errorCode = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 46
  store i32 34, ptr %m_errorCode, align 8
  br label %return

if.end3:                                          ; preds = %if.end
  store i32 1, ptr %m_parsingStatus, align 8
  %m_processor = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 45
  %1 = load ptr, ptr %m_processor, align 8
  %m_bufferPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 4
  %2 = load ptr, ptr %m_bufferPtr, align 8
  %m_parseEndPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 8
  %3 = load ptr, ptr %m_parseEndPtr, align 8
  %call = tail call i32 %1(ptr noundef nonnull %parser, ptr noundef %2, ptr noundef %3, ptr noundef nonnull %m_bufferPtr) #24
  %m_errorCode7 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 46
  store i32 %call, ptr %m_errorCode7, align 8
  %cmp9.not = icmp eq i32 %call, 0
  br i1 %cmp9.not, label %if.else, label %if.then10

if.then10:                                        ; preds = %if.end3
  %m_eventPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 47
  %4 = load ptr, ptr %m_eventPtr, align 8
  %m_eventEndPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 48
  store ptr %4, ptr %m_eventEndPtr, align 8
  store ptr @errorProcessor, ptr %m_processor, align 8
  br label %return

if.else:                                          ; preds = %if.end3
  %5 = load i32, ptr %m_parsingStatus, align 8
  switch i32 %5, label %if.end20 [
    i32 3, label %sw.bb
    i32 0, label %sw.bb14
    i32 1, label %sw.bb14
  ]

sw.bb:                                            ; preds = %if.else
  br label %if.end20

sw.bb14:                                          ; preds = %if.else, %if.else
  %finalBuffer = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 85, i32 1
  %6 = load i8, ptr %finalBuffer, align 4
  %tobool.not = icmp eq i8 %6, 0
  br i1 %tobool.not, label %if.end20, label %if.then16

if.then16:                                        ; preds = %sw.bb14
  store i32 2, ptr %m_parsingStatus, align 8
  br label %return

if.end20:                                         ; preds = %sw.bb, %sw.bb14, %if.else
  %result.0 = phi i32 [ 1, %if.else ], [ 1, %sw.bb14 ], [ 2, %sw.bb ]
  %m_encoding = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 34
  %7 = load ptr, ptr %m_encoding, align 8
  %updatePosition = getelementptr inbounds %struct.encoding, ptr %7, i64 0, i32 8
  %8 = load ptr, ptr %updatePosition, align 8
  %m_positionPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 49
  %9 = load ptr, ptr %m_positionPtr, align 8
  %10 = load ptr, ptr %m_bufferPtr, align 8
  %m_position = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 78
  tail call void %8(ptr noundef %7, ptr noundef %9, ptr noundef %10, ptr noundef nonnull %m_position) #24
  %11 = load ptr, ptr %m_bufferPtr, align 8
  store ptr %11, ptr %m_positionPtr, align 8
  br label %return

return:                                           ; preds = %entry, %if.end20, %if.then16, %if.then10, %if.then2
  %retval.0 = phi i32 [ 0, %if.then2 ], [ 0, %if.then10 ], [ %result.0, %if.end20 ], [ 1, %if.then16 ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite) uwtable
define hidden void @PyExpat_XML_GetParsingStatus(ptr noundef readonly %parser, ptr nocapture noundef writeonly %status) local_unnamed_addr #3 {
entry:
  %cmp = icmp eq ptr %parser, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %m_parsingStatus = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 85
  %0 = load i64, ptr %m_parsingStatus, align 8
  store i64 %0, ptr %status, align 4
  br label %return

return:                                           ; preds = %entry, %if.end
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define hidden i32 @PyExpat_XML_GetErrorCode(ptr noundef readonly %parser) local_unnamed_addr #4 {
entry:
  %cmp = icmp eq ptr %parser, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %m_errorCode = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 46
  %0 = load i32, ptr %m_errorCode, align 8
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi i32 [ %0, %if.end ], [ 41, %entry ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define hidden i64 @PyExpat_XML_GetCurrentByteIndex(ptr noundef readonly %parser) local_unnamed_addr #4 {
entry:
  %cmp = icmp eq ptr %parser, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %m_eventPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 47
  %0 = load ptr, ptr %m_eventPtr, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %return, label %if.then1

if.then1:                                         ; preds = %if.end
  %m_parseEndByteIndex = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 7
  %1 = load i64, ptr %m_parseEndByteIndex, align 8
  %m_parseEndPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 8
  %2 = load ptr, ptr %m_parseEndPtr, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.sub.neg = add i64 %1, %sub.ptr.rhs.cast
  %sub = sub i64 %sub.ptr.sub.neg, %sub.ptr.lhs.cast
  br label %return

return:                                           ; preds = %if.end, %entry, %if.then1
  %retval.0 = phi i64 [ %sub, %if.then1 ], [ -1, %entry ], [ -1, %if.end ]
  ret i64 %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define hidden i32 @PyExpat_XML_GetCurrentByteCount(ptr noundef readonly %parser) local_unnamed_addr #4 {
entry:
  %cmp = icmp eq ptr %parser, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %m_eventEndPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 48
  %0 = load ptr, ptr %m_eventEndPtr, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %return, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %m_eventPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 47
  %1 = load ptr, ptr %m_eventPtr, align 8
  %tobool1.not = icmp eq ptr %1, null
  br i1 %tobool1.not, label %return, label %if.then2

if.then2:                                         ; preds = %land.lhs.true
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv = trunc i64 %sub.ptr.sub to i32
  br label %return

return:                                           ; preds = %if.end, %land.lhs.true, %entry, %if.then2
  %retval.0 = phi i32 [ %conv, %if.then2 ], [ 0, %entry ], [ 0, %land.lhs.true ], [ 0, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite) uwtable
define hidden ptr @PyExpat_XML_GetInputContext(ptr noundef readonly %parser, ptr noundef writeonly %offset, ptr noundef writeonly %size) local_unnamed_addr #3 {
entry:
  %cmp = icmp eq ptr %parser, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %m_eventPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 47
  %0 = load ptr, ptr %m_eventPtr, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %return, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %m_buffer = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 2
  %1 = load ptr, ptr %m_buffer, align 8
  %tobool1.not = icmp eq ptr %1, null
  br i1 %tobool1.not, label %return, label %if.then2

if.then2:                                         ; preds = %land.lhs.true
  %cmp3.not = icmp eq ptr %offset, null
  br i1 %cmp3.not, label %if.end7, label %if.then4

if.then4:                                         ; preds = %if.then2
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv = trunc i64 %sub.ptr.sub to i32
  store i32 %conv, ptr %offset, align 4
  %.pre11.pre = load ptr, ptr %m_buffer, align 8
  br label %if.end7

if.end7:                                          ; preds = %if.then4, %if.then2
  %.pre11 = phi ptr [ %.pre11.pre, %if.then4 ], [ %1, %if.then2 ]
  %cmp8.not = icmp eq ptr %size, null
  br i1 %cmp8.not, label %return, label %if.then10

if.then10:                                        ; preds = %if.end7
  %m_bufferEnd = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 5
  %2 = load ptr, ptr %m_bufferEnd, align 8
  %sub.ptr.lhs.cast12 = ptrtoint ptr %2 to i64
  %sub.ptr.rhs.cast13 = ptrtoint ptr %.pre11 to i64
  %sub.ptr.sub14 = sub i64 %sub.ptr.lhs.cast12, %sub.ptr.rhs.cast13
  %conv15 = trunc i64 %sub.ptr.sub14 to i32
  store i32 %conv15, ptr %size, align 4
  %.pre = load ptr, ptr %m_buffer, align 8
  br label %return

return:                                           ; preds = %if.end7, %if.then10, %if.end, %land.lhs.true, %entry
  %retval.0 = phi ptr [ null, %entry ], [ null, %land.lhs.true ], [ null, %if.end ], [ %.pre, %if.then10 ], [ %.pre11, %if.end7 ]
  ret ptr %retval.0
}

; Function Attrs: nounwind uwtable
define hidden i64 @PyExpat_XML_GetCurrentLineNumber(ptr noundef %parser) local_unnamed_addr #0 {
entry:
  %cmp = icmp eq ptr %parser, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %m_eventPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 47
  %0 = load ptr, ptr %m_eventPtr, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %if.end9, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %m_positionPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 49
  %1 = load ptr, ptr %m_positionPtr, align 8
  %cmp2.not = icmp ult ptr %0, %1
  br i1 %cmp2.not, label %if.end9, label %if.then3

if.then3:                                         ; preds = %land.lhs.true
  %m_encoding = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 34
  %2 = load ptr, ptr %m_encoding, align 8
  %updatePosition = getelementptr inbounds %struct.encoding, ptr %2, i64 0, i32 8
  %3 = load ptr, ptr %updatePosition, align 8
  %m_position = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 78
  tail call void %3(ptr noundef %2, ptr noundef %1, ptr noundef nonnull %0, ptr noundef nonnull %m_position) #24
  %4 = load ptr, ptr %m_eventPtr, align 8
  store ptr %4, ptr %m_positionPtr, align 8
  br label %if.end9

if.end9:                                          ; preds = %if.then3, %land.lhs.true, %if.end
  %m_position10 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 78
  %5 = load i64, ptr %m_position10, align 8
  %add = add i64 %5, 1
  br label %return

return:                                           ; preds = %entry, %if.end9
  %retval.0 = phi i64 [ %add, %if.end9 ], [ 0, %entry ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define hidden i64 @PyExpat_XML_GetCurrentColumnNumber(ptr noundef %parser) local_unnamed_addr #0 {
entry:
  %cmp = icmp eq ptr %parser, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %m_eventPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 47
  %0 = load ptr, ptr %m_eventPtr, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %if.end9, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %m_positionPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 49
  %1 = load ptr, ptr %m_positionPtr, align 8
  %cmp2.not = icmp ult ptr %0, %1
  br i1 %cmp2.not, label %if.end9, label %if.then3

if.then3:                                         ; preds = %land.lhs.true
  %m_encoding = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 34
  %2 = load ptr, ptr %m_encoding, align 8
  %updatePosition = getelementptr inbounds %struct.encoding, ptr %2, i64 0, i32 8
  %3 = load ptr, ptr %updatePosition, align 8
  %m_position = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 78
  tail call void %3(ptr noundef %2, ptr noundef %1, ptr noundef nonnull %0, ptr noundef nonnull %m_position) #24
  %4 = load ptr, ptr %m_eventPtr, align 8
  store ptr %4, ptr %m_positionPtr, align 8
  br label %if.end9

if.end9:                                          ; preds = %if.then3, %land.lhs.true, %if.end
  %columnNumber = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 78, i32 1
  %5 = load i64, ptr %columnNumber, align 8
  br label %return

return:                                           ; preds = %entry, %if.end9
  %retval.0 = phi i64 [ %5, %if.end9 ], [ 0, %entry ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define hidden void @PyExpat_XML_FreeContentModel(ptr noundef readonly %parser, ptr noundef %model) local_unnamed_addr #0 {
entry:
  %cmp.not = icmp eq ptr %parser, null
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %free_fcn = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 3, i32 2
  %0 = load ptr, ptr %free_fcn, align 8
  tail call void %0(ptr noundef %model) #24
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define hidden noalias ptr @PyExpat_XML_MemMalloc(ptr noundef readonly %parser, i64 noundef %size) local_unnamed_addr #0 {
entry:
  %cmp = icmp eq ptr %parser, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %m_mem = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 3
  %0 = load ptr, ptr %m_mem, align 8
  %call = tail call ptr %0(i64 noundef %size) #24
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi ptr [ %call, %if.end ], [ null, %entry ]
  ret ptr %retval.0
}

; Function Attrs: nounwind uwtable
define hidden ptr @PyExpat_XML_MemRealloc(ptr noundef readonly %parser, ptr noundef %ptr, i64 noundef %size) local_unnamed_addr #0 {
entry:
  %cmp = icmp eq ptr %parser, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %realloc_fcn = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 3, i32 1
  %0 = load ptr, ptr %realloc_fcn, align 8
  %call = tail call ptr %0(ptr noundef %ptr, i64 noundef %size) #24
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi ptr [ %call, %if.end ], [ null, %entry ]
  ret ptr %retval.0
}

; Function Attrs: nounwind uwtable
define hidden void @PyExpat_XML_MemFree(ptr noundef readonly %parser, ptr noundef %ptr) local_unnamed_addr #0 {
entry:
  %cmp.not = icmp eq ptr %parser, null
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %free_fcn = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 3, i32 2
  %0 = load ptr, ptr %free_fcn, align 8
  tail call void %0(ptr noundef %ptr) #24
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @PyExpat_XML_DefaultCurrent(ptr noundef %parser) local_unnamed_addr #0 {
entry:
  %s.addr.i11 = alloca ptr, align 8
  %dataPtr.i12 = alloca ptr, align 8
  %s.addr.i = alloca ptr, align 8
  %dataPtr.i = alloca ptr, align 8
  %cmp = icmp eq ptr %parser, null
  br i1 %cmp, label %if.end7, label %if.end

if.end:                                           ; preds = %entry
  %m_defaultHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 18
  %0 = load ptr, ptr %m_defaultHandler, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %if.end7, label %if.then1

if.then1:                                         ; preds = %if.end
  %m_openInternalEntities = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 50
  %1 = load ptr, ptr %m_openInternalEntities, align 8
  %tobool2.not = icmp eq ptr %1, null
  br i1 %tobool2.not, label %if.else, label %if.then3

if.then3:                                         ; preds = %if.then1
  %m_internalEncoding = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 36
  %2 = load ptr, ptr %m_internalEncoding, align 8
  %3 = load ptr, ptr %1, align 8
  %internalEventEndPtr = getelementptr inbounds %struct.open_internal_entity, ptr %1, i64 0, i32 1
  %4 = load ptr, ptr %internalEventEndPtr, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %s.addr.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %dataPtr.i)
  store ptr %3, ptr %s.addr.i, align 8
  %isUtf8.i = getelementptr inbounds %struct.encoding, ptr %2, i64 0, i32 13
  %5 = load i8, ptr %isUtf8.i, align 4
  %tobool.not.i = icmp eq i8 %5, 0
  br i1 %tobool.not.i, label %if.then.i, label %if.else9.i

if.then.i:                                        ; preds = %if.then3
  %m_encoding.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 34
  %6 = load ptr, ptr %m_encoding.i, align 8
  %cmp.i = icmp eq ptr %6, %2
  %m_eventPtr.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 47
  %m_eventEndPtr.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 48
  %eventPP.0.i = select i1 %cmp.i, ptr %m_eventPtr.i, ptr %1
  %eventEndPP.0.i = select i1 %cmp.i, ptr %m_eventEndPtr.i, ptr %internalEventEndPtr
  %m_dataBuf.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 9
  %utf8Convert.i = getelementptr inbounds %struct.encoding, ptr %2, i64 0, i32 10
  %m_dataBufEnd.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 10
  %m_handlerArg.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 1
  br label %do.body.i

do.body.i:                                        ; preds = %do.body.i, %if.then.i
  %7 = load ptr, ptr %m_dataBuf.i, align 8
  store ptr %7, ptr %dataPtr.i, align 8
  %8 = load ptr, ptr %utf8Convert.i, align 8
  %9 = load ptr, ptr %m_dataBufEnd.i, align 8
  %call.i = call i32 %8(ptr noundef nonnull %2, ptr noundef nonnull %s.addr.i, ptr noundef %4, ptr noundef nonnull %dataPtr.i, ptr noundef %9) #24
  %10 = load ptr, ptr %s.addr.i, align 8
  store ptr %10, ptr %eventEndPP.0.i, align 8
  %11 = load ptr, ptr %m_defaultHandler, align 8
  %12 = load ptr, ptr %m_handlerArg.i, align 8
  %13 = load ptr, ptr %m_dataBuf.i, align 8
  %14 = load ptr, ptr %dataPtr.i, align 8
  %sub.ptr.lhs.cast.i = ptrtoint ptr %14 to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %13 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %conv.i = trunc i64 %sub.ptr.sub.i to i32
  call void %11(ptr noundef %12, ptr noundef %13, i32 noundef %conv.i) #24
  %15 = load ptr, ptr %s.addr.i, align 8
  store ptr %15, ptr %eventPP.0.i, align 8
  %16 = icmp ugt i32 %call.i, 1
  br i1 %16, label %do.body.i, label %reportDefault.exit, !llvm.loop !28

if.else9.i:                                       ; preds = %if.then3
  %m_handlerArg11.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 1
  %17 = load ptr, ptr %m_handlerArg11.i, align 8
  %sub.ptr.lhs.cast12.i = ptrtoint ptr %4 to i64
  %sub.ptr.rhs.cast13.i = ptrtoint ptr %3 to i64
  %sub.ptr.sub14.i = sub i64 %sub.ptr.lhs.cast12.i, %sub.ptr.rhs.cast13.i
  %conv15.i = trunc i64 %sub.ptr.sub14.i to i32
  tail call void %0(ptr noundef %17, ptr noundef %3, i32 noundef %conv15.i) #24
  br label %reportDefault.exit

reportDefault.exit:                               ; preds = %do.body.i, %if.else9.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %s.addr.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %dataPtr.i)
  br label %if.end7

if.else:                                          ; preds = %if.then1
  %m_encoding = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 34
  %18 = load ptr, ptr %m_encoding, align 8
  %m_eventPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 47
  %19 = load ptr, ptr %m_eventPtr, align 8
  %m_eventEndPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 48
  %20 = load ptr, ptr %m_eventEndPtr, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %s.addr.i11)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %dataPtr.i12)
  store ptr %19, ptr %s.addr.i11, align 8
  %isUtf8.i13 = getelementptr inbounds %struct.encoding, ptr %18, i64 0, i32 13
  %21 = load i8, ptr %isUtf8.i13, align 4
  %tobool.not.i14 = icmp eq i8 %21, 0
  br i1 %tobool.not.i14, label %if.end.i28, label %if.else9.i15

if.end.i28:                                       ; preds = %if.else
  %m_dataBuf.i31 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 9
  %utf8Convert.i32 = getelementptr inbounds %struct.encoding, ptr %18, i64 0, i32 10
  %m_dataBufEnd.i33 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 10
  %m_handlerArg.i35 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 1
  br label %do.body.i36

do.body.i36:                                      ; preds = %do.body.i36, %if.end.i28
  %22 = load ptr, ptr %m_dataBuf.i31, align 8
  store ptr %22, ptr %dataPtr.i12, align 8
  %23 = load ptr, ptr %utf8Convert.i32, align 8
  %24 = load ptr, ptr %m_dataBufEnd.i33, align 8
  %call.i37 = call i32 %23(ptr noundef nonnull %18, ptr noundef nonnull %s.addr.i11, ptr noundef %20, ptr noundef nonnull %dataPtr.i12, ptr noundef %24) #24
  %25 = load ptr, ptr %s.addr.i11, align 8
  store ptr %25, ptr %m_eventEndPtr, align 8
  %26 = load ptr, ptr %m_defaultHandler, align 8
  %27 = load ptr, ptr %m_handlerArg.i35, align 8
  %28 = load ptr, ptr %m_dataBuf.i31, align 8
  %29 = load ptr, ptr %dataPtr.i12, align 8
  %sub.ptr.lhs.cast.i38 = ptrtoint ptr %29 to i64
  %sub.ptr.rhs.cast.i39 = ptrtoint ptr %28 to i64
  %sub.ptr.sub.i40 = sub i64 %sub.ptr.lhs.cast.i38, %sub.ptr.rhs.cast.i39
  %conv.i41 = trunc i64 %sub.ptr.sub.i40 to i32
  call void %26(ptr noundef %27, ptr noundef %28, i32 noundef %conv.i41) #24
  %30 = load ptr, ptr %s.addr.i11, align 8
  store ptr %30, ptr %m_eventPtr, align 8
  %31 = icmp ugt i32 %call.i37, 1
  br i1 %31, label %do.body.i36, label %reportDefault.exit45, !llvm.loop !28

if.else9.i15:                                     ; preds = %if.else
  %m_handlerArg11.i17 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 1
  %32 = load ptr, ptr %m_handlerArg11.i17, align 8
  %sub.ptr.lhs.cast12.i18 = ptrtoint ptr %20 to i64
  %sub.ptr.rhs.cast13.i19 = ptrtoint ptr %19 to i64
  %sub.ptr.sub14.i20 = sub i64 %sub.ptr.lhs.cast12.i18, %sub.ptr.rhs.cast13.i19
  %conv15.i21 = trunc i64 %sub.ptr.sub14.i20 to i32
  tail call void %0(ptr noundef %32, ptr noundef %19, i32 noundef %conv15.i21) #24
  br label %reportDefault.exit45

reportDefault.exit45:                             ; preds = %do.body.i36, %if.else9.i15
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %s.addr.i11)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %dataPtr.i12)
  br label %if.end7

if.end7:                                          ; preds = %reportDefault.exit, %reportDefault.exit45, %entry, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @reportDefault(ptr nocapture noundef %parser, ptr noundef %enc, ptr noundef %s, ptr noundef %end) unnamed_addr #0 {
entry:
  %s.addr = alloca ptr, align 8
  %dataPtr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %isUtf8 = getelementptr inbounds %struct.encoding, ptr %enc, i64 0, i32 13
  %0 = load i8, ptr %isUtf8, align 4
  %tobool.not = icmp eq i8 %0, 0
  br i1 %tobool.not, label %if.then, label %if.else9

if.then:                                          ; preds = %entry
  %m_encoding = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 34
  %1 = load ptr, ptr %m_encoding, align 8
  %cmp = icmp eq ptr %1, %enc
  br i1 %cmp, label %if.then1, label %if.else

if.then1:                                         ; preds = %if.then
  %m_eventPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 47
  %m_eventEndPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 48
  br label %if.end

if.else:                                          ; preds = %if.then
  %m_openInternalEntities = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 50
  %2 = load ptr, ptr %m_openInternalEntities, align 8
  %internalEventEndPtr = getelementptr inbounds %struct.open_internal_entity, ptr %2, i64 0, i32 1
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then1
  %eventPP.0 = phi ptr [ %m_eventPtr, %if.then1 ], [ %2, %if.else ]
  %eventEndPP.0 = phi ptr [ %m_eventEndPtr, %if.then1 ], [ %internalEventEndPtr, %if.else ]
  %m_dataBuf = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 9
  %utf8Convert = getelementptr inbounds %struct.encoding, ptr %enc, i64 0, i32 10
  %m_dataBufEnd = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 10
  %m_defaultHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 18
  %m_handlerArg = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 1
  br label %do.body

do.body:                                          ; preds = %do.body, %if.end
  %3 = load ptr, ptr %m_dataBuf, align 8
  store ptr %3, ptr %dataPtr, align 8
  %4 = load ptr, ptr %utf8Convert, align 8
  %5 = load ptr, ptr %m_dataBufEnd, align 8
  %call = call i32 %4(ptr noundef nonnull %enc, ptr noundef nonnull %s.addr, ptr noundef %end, ptr noundef nonnull %dataPtr, ptr noundef %5) #24
  %6 = load ptr, ptr %s.addr, align 8
  store ptr %6, ptr %eventEndPP.0, align 8
  %7 = load ptr, ptr %m_defaultHandler, align 8
  %8 = load ptr, ptr %m_handlerArg, align 8
  %9 = load ptr, ptr %m_dataBuf, align 8
  %10 = load ptr, ptr %dataPtr, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %10 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %9 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv = trunc i64 %sub.ptr.sub to i32
  call void %7(ptr noundef %8, ptr noundef %9, i32 noundef %conv) #24
  %11 = load ptr, ptr %s.addr, align 8
  store ptr %11, ptr %eventPP.0, align 8
  %12 = icmp ugt i32 %call, 1
  br i1 %12, label %do.body, label %if.end16, !llvm.loop !28

if.else9:                                         ; preds = %entry
  %m_defaultHandler10 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 18
  %13 = load ptr, ptr %m_defaultHandler10, align 8
  %m_handlerArg11 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 1
  %14 = load ptr, ptr %m_handlerArg11, align 8
  %sub.ptr.lhs.cast12 = ptrtoint ptr %end to i64
  %sub.ptr.rhs.cast13 = ptrtoint ptr %s to i64
  %sub.ptr.sub14 = sub i64 %sub.ptr.lhs.cast12, %sub.ptr.rhs.cast13
  %conv15 = trunc i64 %sub.ptr.sub14 to i32
  tail call void %13(ptr noundef %14, ptr noundef %s, i32 noundef %conv15) #24
  br label %if.end16

if.end16:                                         ; preds = %do.body, %if.else9
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable
define hidden ptr @PyExpat_XML_ErrorString(i32 noundef %code) local_unnamed_addr #7 {
entry:
  %switch.tableidx = add i32 %code, -1
  %0 = icmp ult i32 %switch.tableidx, 43
  br i1 %0, label %switch.lookup, label %return

switch.lookup:                                    ; preds = %entry
  %1 = zext nneg i32 %switch.tableidx to i64
  %switch.gep = getelementptr inbounds [43 x ptr], ptr @switch.table.PyExpat_XML_ErrorString, i64 0, i64 %1
  %switch.load = load ptr, ptr %switch.gep, align 8
  br label %return

return:                                           ; preds = %switch.lookup, %entry
  %retval.0 = phi ptr [ null, %entry ], [ %switch.load, %switch.lookup ]
  ret ptr %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable
define hidden nonnull ptr @PyExpat_XML_ExpatVersion() local_unnamed_addr #7 {
entry:
  ret ptr @.str.43
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable
define hidden { i64, i32 } @PyExpat_XML_ExpatVersionInfo() local_unnamed_addr #7 {
entry:
  ret { i64, i32 } { i64 21474836482, i32 0 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable
define hidden nonnull ptr @PyExpat_XML_GetFeatureList() local_unnamed_addr #7 {
entry:
  ret ptr @PyExpat_XML_GetFeatureList.features
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite) uwtable
define hidden zeroext i8 @PyExpat_XML_SetBillionLaughsAttackProtectionMaximumAmplification(ptr noundef %parser, float noundef %maximumAmplificationFactor) local_unnamed_addr #3 {
entry:
  %cmp = icmp eq ptr %parser, null
  br i1 %cmp, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %m_parentParser = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 84
  %0 = load ptr, ptr %m_parentParser, align 8
  %cmp1.not = icmp eq ptr %0, null
  br i1 %cmp1.not, label %lor.lhs.false2, label %return

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %1 = fcmp uno float %maximumAmplificationFactor, 0.000000e+00
  %cmp4 = fcmp olt float %maximumAmplificationFactor, 1.000000e+00
  %or.cond = or i1 %1, %cmp4
  br i1 %or.cond, label %return, label %if.end

if.end:                                           ; preds = %lor.lhs.false2
  %maximumAmplificationFactor5 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 90, i32 3
  store float %maximumAmplificationFactor, ptr %maximumAmplificationFactor5, align 4
  br label %return

return:                                           ; preds = %entry, %lor.lhs.false, %lor.lhs.false2, %if.end
  %retval.0 = phi i8 [ 1, %if.end ], [ 0, %lor.lhs.false2 ], [ 0, %lor.lhs.false ], [ 0, %entry ]
  ret i8 %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite) uwtable
define hidden zeroext i8 @PyExpat_XML_SetBillionLaughsAttackProtectionActivationThreshold(ptr noundef %parser, i64 noundef %activationThresholdBytes) local_unnamed_addr #3 {
entry:
  %cmp = icmp eq ptr %parser, null
  br i1 %cmp, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %m_parentParser = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 84
  %0 = load ptr, ptr %m_parentParser, align 8
  %cmp1.not = icmp eq ptr %0, null
  br i1 %cmp1.not, label %if.end, label %return

if.end:                                           ; preds = %lor.lhs.false
  %activationThresholdBytes2 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 90, i32 4
  store i64 %activationThresholdBytes, ptr %activationThresholdBytes2, align 8
  br label %return

return:                                           ; preds = %entry, %lor.lhs.false, %if.end
  %retval.0 = phi i8 [ 1, %if.end ], [ 0, %lor.lhs.false ], [ 0, %entry ]
  ret i8 %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define hidden i64 @PyExpat_testingAccountingGetCountBytesDirect(ptr noundef readonly %parser) local_unnamed_addr #4 {
entry:
  %tobool.not = icmp eq ptr %parser, null
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %m_accounting = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 90
  %0 = load i64, ptr %m_accounting, align 8
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi i64 [ %0, %if.end ], [ 0, %entry ]
  ret i64 %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define hidden i64 @PyExpat_testingAccountingGetCountBytesIndirect(ptr noundef readonly %parser) local_unnamed_addr #4 {
entry:
  %tobool.not = icmp eq ptr %parser, null
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %countBytesIndirect = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 90, i32 1
  %0 = load i64, ptr %countBytesIndirect, align 8
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi i64 [ %0, %if.end ], [ 0, %entry ]
  ret i64 %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable
define hidden nonnull ptr @PyExpat_unsignedCharToPrintable(i8 noundef zeroext %c) local_unnamed_addr #7 {
entry:
  %switch.tableidx = xor i8 %c, -128
  %0 = zext i8 %switch.tableidx to i64
  %switch.gep = getelementptr inbounds [256 x ptr], ptr @switch.table.PyExpat_unsignedCharToPrintable, i64 0, i64 %0
  %switch.load = load ptr, ptr %switch.gep, align 8
  ret ptr %switch.load
}

; Function Attrs: mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite)
declare noalias noundef ptr @malloc(i64 noundef) #8

; Function Attrs: mustprogress nounwind willreturn allockind("realloc") allocsize(1) memory(argmem: readwrite, inaccessiblemem: readwrite)
declare noalias noundef ptr @realloc(ptr allocptr nocapture noundef, i64 noundef) #9

; Function Attrs: mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite)
declare void @free(ptr allocptr nocapture noundef) #10

declare ptr @PyExpat_XmlGetUtf8InternalEncodingNS() local_unnamed_addr #1

declare ptr @PyExpat_XmlGetUtf8InternalEncoding() local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define internal i32 @prologInitProcessor(ptr noundef %parser, ptr noundef %s, ptr noundef %end, ptr noundef %nextPtr) #0 {
entry:
  %next.i = alloca ptr, align 8
  %call = tail call fastcc i32 @initializeEncoding(ptr noundef %parser), !range !24
  %cmp.not = icmp eq i32 %call, 0
  br i1 %cmp.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  %m_processor = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 45
  store ptr @prologProcessor, ptr %m_processor, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %next.i)
  store ptr %s, ptr %next.i, align 8
  %m_encoding.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 34
  %0 = load ptr, ptr %m_encoding.i, align 8
  %1 = load ptr, ptr %0, align 8
  %call.i = call i32 %1(ptr noundef nonnull %0, ptr noundef %s, ptr noundef %end, ptr noundef nonnull %next.i) #24
  %2 = load ptr, ptr %m_encoding.i, align 8
  %3 = load ptr, ptr %next.i, align 8
  %finalBuffer.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 85, i32 1
  %4 = load i8, ptr %finalBuffer.i, align 4
  %tobool.not.i = icmp eq i8 %4, 0
  %conv.i = zext i1 %tobool.not.i to i8
  %call3.i = call fastcc i32 @doProlog(ptr noundef %parser, ptr noundef %2, ptr noundef %s, ptr noundef %end, i32 noundef %call.i, ptr noundef %3, ptr noundef %nextPtr, i8 noundef zeroext %conv.i, i8 noundef zeroext 1, i32 noundef 0)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %next.i)
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi i32 [ %call3.i, %if.end ], [ %call, %entry ]
  ret i32 %retval.0
}

declare void @PyExpat_XmlPrologStateInit(ptr noundef) local_unnamed_addr #1

declare i32 @PyExpat_XmlInitEncoding(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: mustprogress nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #11

; Function Attrs: nounwind uwtable
define internal fastcc i32 @initializeEncoding(ptr noundef %parser) unnamed_addr #0 {
entry:
  %info.i = alloca %struct.XML_Encoding, align 8
  %m_protocolEncodingName = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 37
  %0 = load ptr, ptr %m_protocolEncodingName, align 8
  %m_ns = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 38
  %1 = load i8, ptr %m_ns, align 8
  %tobool.not = icmp eq i8 %1, 0
  %cond = select i1 %tobool.not, ptr @PyExpat_XmlInitEncoding, ptr @PyExpat_XmlInitEncodingNS
  %m_initEncoding = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 35
  %m_encoding = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 34
  %call = tail call i32 %cond(ptr noundef nonnull %m_initEncoding, ptr noundef nonnull %m_encoding, ptr noundef %0) #24, !callees !29
  %tobool1.not = icmp eq i32 %call, 0
  br i1 %tobool1.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %m_protocolEncodingName, align 8
  call void @llvm.lifetime.start.p0(i64 1048, ptr nonnull %info.i)
  %m_unknownEncodingHandler.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 29
  %3 = load ptr, ptr %m_unknownEncodingHandler.i, align 8
  %tobool.not.i = icmp eq ptr %3, null
  br i1 %tobool.not.i, label %handleUnknownEncoding.exit, label %for.body.preheader.i

for.body.preheader.i:                             ; preds = %if.end
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(1024) %info.i, i8 -1, i64 1024, i1 false)
  %convert.i = getelementptr inbounds %struct.XML_Encoding, ptr %info.i, i64 0, i32 2
  %data.i = getelementptr inbounds %struct.XML_Encoding, ptr %info.i, i64 0, i32 1
  %release.i = getelementptr inbounds %struct.XML_Encoding, ptr %info.i, i64 0, i32 3
  %m_unknownEncodingHandlerData.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 42
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %data.i, i8 0, i64 24, i1 false)
  %4 = load ptr, ptr %m_unknownEncodingHandlerData.i, align 8
  %call.i = call i32 %3(ptr noundef %4, ptr noundef %2, ptr noundef nonnull %info.i) #24
  %tobool2.not.i = icmp eq i32 %call.i, 0
  br i1 %tobool2.not.i, label %if.end27.i, label %if.then3.i

if.then3.i:                                       ; preds = %for.body.preheader.i
  %m_mem.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 3
  %5 = load ptr, ptr %m_mem.i, align 8
  %call4.i = call i32 @PyExpat_XmlSizeOfUnknownEncoding() #24
  %conv.i = sext i32 %call4.i to i64
  %call5.i = call ptr %5(i64 noundef %conv.i) #24
  %m_unknownEncodingMem.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 40
  store ptr %call5.i, ptr %m_unknownEncodingMem.i, align 8
  %tobool7.not.i = icmp eq ptr %call5.i, null
  br i1 %tobool7.not.i, label %if.then8.i, label %if.end14.i

if.then8.i:                                       ; preds = %if.then3.i
  %6 = load ptr, ptr %release.i, align 8
  %tobool10.not.i = icmp eq ptr %6, null
  br i1 %tobool10.not.i, label %handleUnknownEncoding.exit, label %if.then11.i

if.then11.i:                                      ; preds = %if.then8.i
  %7 = load ptr, ptr %data.i, align 8
  call void %6(ptr noundef %7) #24
  br label %handleUnknownEncoding.exit

if.end14.i:                                       ; preds = %if.then3.i
  %8 = load i8, ptr %m_ns, align 8
  %tobool16.not.i = icmp eq i8 %8, 0
  %cond.i = select i1 %tobool16.not.i, ptr @PyExpat_XmlInitUnknownEncoding, ptr @PyExpat_XmlInitUnknownEncodingNS
  %9 = load ptr, ptr %convert.i, align 8
  %10 = load ptr, ptr %data.i, align 8
  %call21.i = call ptr %cond.i(ptr noundef nonnull %call5.i, ptr noundef nonnull %info.i, ptr noundef %9, ptr noundef %10) #24, !callees !30
  %tobool22.not.i = icmp eq ptr %call21.i, null
  br i1 %tobool22.not.i, label %if.end27.i, label %if.then23.i

if.then23.i:                                      ; preds = %if.end14.i
  %11 = load ptr, ptr %data.i, align 8
  %m_unknownEncodingData.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 41
  store ptr %11, ptr %m_unknownEncodingData.i, align 8
  %12 = load ptr, ptr %release.i, align 8
  %m_unknownEncodingRelease.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 43
  store ptr %12, ptr %m_unknownEncodingRelease.i, align 8
  store ptr %call21.i, ptr %m_encoding, align 8
  br label %handleUnknownEncoding.exit

if.end27.i:                                       ; preds = %if.end14.i, %for.body.preheader.i
  %13 = load ptr, ptr %release.i, align 8
  %cmp29.not.i = icmp eq ptr %13, null
  br i1 %cmp29.not.i, label %handleUnknownEncoding.exit, label %if.then31.i

if.then31.i:                                      ; preds = %if.end27.i
  %14 = load ptr, ptr %data.i, align 8
  call void %13(ptr noundef %14) #24
  br label %handleUnknownEncoding.exit

handleUnknownEncoding.exit:                       ; preds = %if.end, %if.then8.i, %if.then11.i, %if.then23.i, %if.end27.i, %if.then31.i
  %retval.0.i = phi i32 [ 0, %if.then23.i ], [ 1, %if.then11.i ], [ 1, %if.then8.i ], [ 18, %if.end27.i ], [ 18, %if.then31.i ], [ 18, %if.end ]
  call void @llvm.lifetime.end.p0(i64 1048, ptr nonnull %info.i)
  br label %return

return:                                           ; preds = %entry, %handleUnknownEncoding.exit
  %retval.0 = phi i32 [ %retval.0.i, %handleUnknownEncoding.exit ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @prologProcessor(ptr noundef %parser, ptr noundef %s, ptr noundef %end, ptr noundef %nextPtr) #0 {
entry:
  %next = alloca ptr, align 8
  store ptr %s, ptr %next, align 8
  %m_encoding = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 34
  %0 = load ptr, ptr %m_encoding, align 8
  %1 = load ptr, ptr %0, align 8
  %call = call i32 %1(ptr noundef nonnull %0, ptr noundef %s, ptr noundef %end, ptr noundef nonnull %next) #24
  %2 = load ptr, ptr %m_encoding, align 8
  %3 = load ptr, ptr %next, align 8
  %finalBuffer = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 85, i32 1
  %4 = load i8, ptr %finalBuffer, align 4
  %tobool.not = icmp eq i8 %4, 0
  %conv = zext i1 %tobool.not to i8
  %call3 = call fastcc i32 @doProlog(ptr noundef %parser, ptr noundef %2, ptr noundef %s, ptr noundef %end, i32 noundef %call, ptr noundef %3, ptr noundef %nextPtr, i8 noundef zeroext %conv, i8 noundef zeroext 1, i32 noundef 0)
  ret i32 %call3
}

declare i32 @PyExpat_XmlInitEncodingNS(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #1

declare i32 @PyExpat_XmlSizeOfUnknownEncoding() local_unnamed_addr #1

declare ptr @PyExpat_XmlInitUnknownEncodingNS(ptr noundef, ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #1

declare ptr @PyExpat_XmlInitUnknownEncoding(ptr noundef, ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define internal fastcc i32 @doProlog(ptr noundef %parser, ptr noundef %enc, ptr noundef %s, ptr noundef %end, i32 noundef %tok, ptr noundef %next, ptr noundef %nextPtr, i8 noundef zeroext %haveMore, i8 noundef zeroext %allowClosingDoctype, i32 noundef %account) unnamed_addr #0 {
entry:
  %s.addr.i1263 = alloca ptr, align 8
  %dataPtr.i1264 = alloca ptr, align 8
  %ptr.addr.i.i1187 = alloca ptr, align 8
  %s.addr.i = alloca ptr, align 8
  %dataPtr.i = alloca ptr, align 8
  %ptr.addr.i.i1127 = alloca ptr, align 8
  %ptr.addr.i.i1072 = alloca ptr, align 8
  %ptr.addr.i.i1042 = alloca ptr, align 8
  %ptr.addr.i.i1012 = alloca ptr, align 8
  %ptr.addr.i.i982 = alloca ptr, align 8
  %ptr.addr.i.i952 = alloca ptr, align 8
  %ptr.addr.i.i922 = alloca ptr, align 8
  %ptr.addr.i.i892 = alloca ptr, align 8
  %ptr.addr.i = alloca ptr, align 8
  %ptr.addr.i.i770 = alloca ptr, align 8
  %ptr.addr.i.i738 = alloca ptr, align 8
  %ptr.addr.i.i = alloca ptr, align 8
  %next.addr = alloca ptr, align 8
  store ptr %next, ptr %next.addr, align 8
  %m_dtd = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 65
  %0 = load ptr, ptr %m_dtd, align 8
  %m_encoding = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 34
  %1 = load ptr, ptr %m_encoding, align 8
  %cmp = icmp eq ptr %1, %enc
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %m_eventPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 47
  %m_eventEndPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 48
  br label %if.end

if.else:                                          ; preds = %entry
  %m_openInternalEntities = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 50
  %2 = load ptr, ptr %m_openInternalEntities, align 8
  %internalEventEndPtr = getelementptr inbounds %struct.open_internal_entity, ptr %2, i64 0, i32 1
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %eventEndPP.0 = phi ptr [ %m_eventEndPtr, %if.then ], [ %internalEventEndPtr, %if.else ]
  %eventPP.0 = phi ptr [ %m_eventPtr, %if.then ], [ %2, %if.else ]
  %tobool = icmp ne i8 %haveMore, 0
  %m_prologState34 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 44
  %m_elementDeclHandler1432 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 30
  %keepProcessing1423 = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 6
  %m_attlistDeclHandler1427 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 31
  %m_notationDeclHandler1418 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 22
  %m_entityDeclHandler1413 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 32
  %m_startDoctypeDeclHandler1404 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 19
  %in_eldecl1355 = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 12
  %scaffLevel1362 = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 17
  %scaffold1363 = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 13
  %scaffIndex1364 = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 18
  %3 = getelementptr i8, ptr %parser, i64 24
  %m_handlerArg1382 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 1
  %m_declElementType1383 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 61
  %contentStringLen1387 = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 14
  %scaffCount = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 16
  %hasParamEntityRefs1117 = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 7
  %m_paramEntityParsing1118 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 88
  %pool1126 = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 4
  %ptr1.i.i1188 = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 4, i32 3
  %end4.i.i1192 = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 4, i32 2
  %start.i.i1202 = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 4, i32 4
  %size.i = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 10, i32 2
  %paramEntities1138 = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 10
  %power30.i = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 10, i32 1
  %documentEntity = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 44, i32 4
  %standalone1147 = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 8
  %m_openInternalEntities1151 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 50
  %m_externalEntityRefHandler1198 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 26
  %paramEntityRead1201 = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 9
  %m_externalEntityRefHandlerArg1204 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 27
  %m_skippedEntityHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 28
  %m_notStandaloneHandler1228 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 25
  %m_groupConnector1064 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 81
  %level1066 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 44, i32 1
  %m_groupSize = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 82
  %realloc_fcn = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 3, i32 1
  %m_defaultHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 18
  %m_eventPtr.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 47
  %m_eventEndPtr.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 48
  %m_dataBuf.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 9
  %m_dataBufEnd.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 10
  %m_declNotationPublicId937 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 60
  %m_declNotationName945 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 59
  %m_curBase946 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 66
  %m_tempPool949 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 79
  %freeBlocks.i1168 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 79, i32 1
  %end.i1176 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 79, i32 2
  %ptr1.i.i1128 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 79, i32 3
  %start.i.i1142 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 79, i32 4
  %m_declEntity819 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 54
  %m_parentParser843 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 84
  %m_unparsedEntityDeclHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 21
  %m_useForeignDTD578 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 87
  %m_doctypeSysid592 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 56
  %start539 = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 5, i32 4
  %ptr542 = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 5, i32 3
  %m_declAttributeIsCdata422 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 63
  %m_declAttributeId442 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 62
  %m_declAttributeType451 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 58
  %m_declAttributeIsId342 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 64
  %cmp146.not = icmp eq i8 %allowClosingDoctype, 1
  %m_doctypeName150 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 55
  %m_doctypePubid157 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 57
  %m_endDoctypeDeclHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 20
  %m_parsingStatus = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 85
  br label %for.cond

for.cond:                                         ; preds = %sw.default1446, %if.end
  %tok.addr.0 = phi i32 [ %tok, %if.end ], [ %call1448, %sw.default1446 ]
  %s.addr.0 = phi ptr [ %s, %if.end ], [ %620, %sw.default1446 ]
  %enc.addr.0 = phi ptr [ %enc, %if.end ], [ %enc.addr.11359, %sw.default1446 ]
  store ptr %s.addr.0, ptr %eventPP.0, align 8
  %4 = load ptr, ptr %next.addr, align 8
  store ptr %4, ptr %eventEndPP.0, align 8
  %cmp2 = icmp slt i32 %tok.addr.0, 1
  br i1 %cmp2, label %if.then3, label %if.end33

if.then3:                                         ; preds = %for.cond
  %cmp4 = icmp ne i32 %tok.addr.0, 0
  %or.cond = and i1 %tobool, %cmp4
  br i1 %or.cond, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.then3
  store ptr %s.addr.0, ptr %nextPtr, align 8
  br label %return

if.end7:                                          ; preds = %if.then3
  switch i32 %tok.addr.0, label %sw.default [
    i32 0, label %sw.bb
    i32 -1, label %return.loopexit2043
    i32 -2, label %return
    i32 -15, label %if.end33
    i32 -4, label %sw.bb11
  ]

sw.bb:                                            ; preds = %if.end7
  store ptr %4, ptr %eventPP.0, align 8
  br label %return

sw.bb11:                                          ; preds = %if.end7
  %5 = load ptr, ptr %m_encoding, align 8
  %cmp13.not = icmp eq ptr %enc.addr.0, %5
  br i1 %cmp13.not, label %if.end19, label %land.lhs.true15

land.lhs.true15:                                  ; preds = %sw.bb11
  %6 = load ptr, ptr %m_openInternalEntities1151, align 8
  %betweenDecl = getelementptr inbounds %struct.open_internal_entity, ptr %6, i64 0, i32 5
  %7 = load i8, ptr %betweenDecl, align 4
  %tobool17.not = icmp eq i8 %7, 0
  br i1 %tobool17.not, label %if.then18, label %if.then25

if.then18:                                        ; preds = %land.lhs.true15
  store ptr %s.addr.0, ptr %nextPtr, align 8
  br label %return

if.end19:                                         ; preds = %sw.bb11
  %m_isParamEntity = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 86
  %8 = load i8, ptr %m_isParamEntity, align 8
  %tobool21.not = icmp eq i8 %8, 0
  br i1 %tobool21.not, label %return, label %if.then25

if.then25:                                        ; preds = %land.lhs.true15, %if.end19
  %9 = load ptr, ptr %m_prologState34, align 8
  %call = call i32 %9(ptr noundef nonnull %m_prologState34, i32 noundef -4, ptr noundef %end, ptr noundef %end, ptr noundef %enc.addr.0) #24
  %cmp27 = icmp eq i32 %call, -1
  br i1 %cmp27, label %return, label %if.end30

if.end30:                                         ; preds = %if.then25
  store ptr %s.addr.0, ptr %nextPtr, align 8
  br label %return

sw.default:                                       ; preds = %if.end7
  %sub32 = sub i32 0, %tok.addr.0
  store ptr %end, ptr %next.addr, align 8
  br label %if.end33

if.end33:                                         ; preds = %if.end7, %sw.default, %for.cond
  %10 = phi ptr [ %end, %sw.default ], [ %4, %for.cond ], [ %4, %if.end7 ]
  %tok.addr.1 = phi i32 [ %sub32, %sw.default ], [ %tok.addr.0, %for.cond ], [ 15, %if.end7 ]
  %11 = load ptr, ptr %m_prologState34, align 8
  %call37 = call i32 %11(ptr noundef nonnull %m_prologState34, i32 noundef %tok.addr.1, ptr noundef %s.addr.0, ptr noundef %10, ptr noundef %enc.addr.0) #24
  switch i32 %call37, label %sw.default39 [
    i32 2, label %sw.epilog44
    i32 1, label %sw.epilog44
    i32 57, label %sw.epilog44
  ]

sw.default39:                                     ; preds = %if.end33
  %12 = load ptr, ptr %next.addr, align 8
  %call40 = call fastcc zeroext i8 @accountingDiffTolerated(ptr noundef nonnull %parser, i32 noundef %tok.addr.1, ptr noundef %s.addr.0, ptr noundef %12, i32 noundef 4717, i32 noundef %account), !range !13
  %tobool41.not = icmp eq i8 %call40, 0
  br i1 %tobool41.not, label %while.cond.i.i.i, label %sw.epilog44

while.cond.i.i.i:                                 ; preds = %sw.default39, %while.cond.i.i.i
  %rootParser.0.i.i.i = phi ptr [ %13, %while.cond.i.i.i ], [ %parser, %sw.default39 ]
  %m_parentParser.i.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i.i, i64 0, i32 84
  %13 = load ptr, ptr %m_parentParser.i.i.i, align 8
  %tobool.not.i.i.i = icmp eq ptr %13, null
  br i1 %tobool.not.i.i.i, label %getRootParserOf.exit.i.i, label %while.cond.i.i.i, !llvm.loop !31

getRootParserOf.exit.i.i:                         ; preds = %while.cond.i.i.i
  %debugLevel.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i.i, i64 0, i32 90, i32 2
  %14 = load i32, ptr %debugLevel.i.i, align 8
  %cmp.i.i = icmp slt i32 %14, 1
  br i1 %cmp.i.i, label %return, label %if.end.i.i

if.end.i.i:                                       ; preds = %getRootParserOf.exit.i.i
  %m_accounting.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i.i, i64 0, i32 90
  %15 = load i64, ptr %m_accounting.i.i, align 8
  %tobool.not.i5.i.i = icmp eq i64 %15, 0
  %countBytesIndirect.phi.trans.insert.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i.i, i64 0, i32 90, i32 1
  %.pre.i.i = load i64, ptr %countBytesIndirect.phi.trans.insert.i.i, align 8
  br i1 %tobool.not.i5.i.i, label %accountingGetCurrentAmplification.exit.i.i, label %cond.true.i.i.i

cond.true.i.i.i:                                  ; preds = %if.end.i.i
  %add.i.i.i = add i64 %.pre.i.i, %15
  %conv.i.i.i = uitofp i64 %add.i.i.i to float
  %conv6.i.i.i = uitofp i64 %15 to float
  %div.i.i.i = fdiv float %conv.i.i.i, %conv6.i.i.i
  %16 = fpext float %div.i.i.i to double
  br label %accountingGetCurrentAmplification.exit.i.i

accountingGetCurrentAmplification.exit.i.i:       ; preds = %cond.true.i.i.i, %if.end.i.i
  %cond.i.i.i = phi double [ %16, %cond.true.i.i.i ], [ 1.000000e+00, %if.end.i.i ]
  %17 = load ptr, ptr @stderr, align 8
  %call4.i.i = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %17, ptr noundef nonnull @.str.311, ptr noundef nonnull %rootParser.0.i.i.i, i64 noundef %15, i64 noundef %.pre.i.i, double noundef %cond.i.i.i, ptr noundef nonnull @.str.317) #27
  br label %return

sw.epilog44:                                      ; preds = %sw.default39, %if.end33, %if.end33, %if.end33
  switch i32 %call37, label %land.lhs.true1439 [
    i32 1, label %sw.bb45
    i32 4, label %sw.bb52
    i32 7, label %sw.bb63
    i32 57, label %sw.bb74
    i32 6, label %sw.bb82
    i32 14, label %sw.bb109
    i32 8, label %sw.bb144
    i32 2, label %sw.bb217
    i32 34, label %sw.bb269
    i32 22, label %sw.bb275
    i32 23, label %sw.bb281
    i32 24, label %sw.bb284
    i32 25, label %sw.bb287
    i32 26, label %sw.bb289
    i32 27, label %sw.bb291
    i32 28, label %sw.bb293
    i32 29, label %sw.bb295
    i32 30, label %sw.bb297
    i32 31, label %sw.bb306
    i32 32, label %sw.bb306
    i32 35, label %sw.bb335
    i32 36, label %sw.bb335
    i32 37, label %sw.bb417
    i32 38, label %sw.bb417
    i32 12, label %sw.bb523
    i32 5, label %sw.bb577
    i32 13, label %sw.bb633
    i32 15, label %sw.bb672
    i32 16, label %sw.bb697
    i32 9, label %sw.bb750
    i32 10, label %sw.bb807
    i32 18, label %sw.bb866
    i32 21, label %sw.bb881
    i32 19, label %sw.bb909
    i32 20, label %sw.bb936
    i32 -1, label %sw.bb950
    i32 58, label %sw.bb954
    i32 44, label %sw.bb969
    i32 50, label %sw.bb1039
    i32 49, label %sw.bb1063
    i32 60, label %sw.bb1116
    i32 59, label %sw.bb1116
    i32 40, label %sw.bb1237
    i32 41, label %sw.bb1250
    i32 42, label %sw.bb1250
    i32 43, label %sw.bb1276
    i32 51, label %elementContent.thread
    i32 53, label %elementContent
    i32 52, label %sw.bb1296
    i32 54, label %sw.bb1297
    i32 45, label %closeGroup
    i32 47, label %sw.bb1352
    i32 46, label %sw.bb1353
    i32 48, label %sw.bb1354
    i32 55, label %sw.bb1390
    i32 56, label %sw.bb1395
    i32 0, label %sw.bb1400
    i32 3, label %sw.bb1403
    i32 11, label %sw.bb1408
    i32 17, label %sw.bb1417
    i32 33, label %sw.bb1422
    i32 39, label %sw.bb1431
  ]

sw.bb45:                                          ; preds = %sw.epilog44
  %18 = load ptr, ptr %next.addr, align 8
  %call46 = call fastcc i32 @processXmlDecl(ptr noundef %parser, i32 noundef 0, ptr noundef %s.addr.0, ptr noundef %18), !range !32
  %cmp47.not = icmp eq i32 %call46, 0
  br i1 %cmp47.not, label %if.end50, label %return

if.end50:                                         ; preds = %sw.bb45
  %19 = load ptr, ptr %m_encoding, align 8
  br label %if.end1443

sw.bb52:                                          ; preds = %sw.epilog44
  %20 = load ptr, ptr %m_startDoctypeDeclHandler1404, align 8
  %tobool53.not = icmp eq ptr %20, null
  br i1 %tobool53.not, label %if.end62, label %if.then54

if.then54:                                        ; preds = %sw.bb52
  %21 = load ptr, ptr %next.addr, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ptr.addr.i.i)
  store ptr %s.addr.0, ptr %ptr.addr.i.i, align 8
  %22 = load ptr, ptr %ptr1.i.i1128, align 8
  %tobool.not.i.i = icmp eq ptr %22, null
  br i1 %tobool.not.i.i, label %land.lhs.true.i.i, label %if.end.i.i735

land.lhs.true.i.i:                                ; preds = %if.then54
  %call.i.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool949), !range !13
  %tobool2.not.i.i = icmp eq i8 %call.i.i, 0
  br i1 %tobool2.not.i.i, label %poolAppend.exit.thread.i, label %if.end.i.i735

if.end.i.i735:                                    ; preds = %land.lhs.true.i.i, %if.then54
  %utf8Convert.i.i = getelementptr inbounds %struct.encoding, ptr %enc.addr.0, i64 0, i32 10
  br label %for.cond.i.i

for.cond.i.i:                                     ; preds = %if.end8.i.i, %if.end.i.i735
  %23 = load ptr, ptr %utf8Convert.i.i, align 8
  %24 = load ptr, ptr %end.i1176, align 8
  %call5.i.i = call i32 %23(ptr noundef %enc.addr.0, ptr noundef nonnull %ptr.addr.i.i, ptr noundef %21, ptr noundef nonnull %ptr1.i.i1128, ptr noundef %24) #24
  %or.cond.i.i = icmp ult i32 %call5.i.i, 2
  br i1 %or.cond.i.i, label %poolAppend.exit.i, label %if.end8.i.i

if.end8.i.i:                                      ; preds = %for.cond.i.i
  %call9.i.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool949), !range !13
  %tobool10.not.i.i = icmp eq i8 %call9.i.i, 0
  br i1 %tobool10.not.i.i, label %poolAppend.exit.thread.i, label %for.cond.i.i

poolAppend.exit.thread.i:                         ; preds = %land.lhs.true.i.i, %if.end8.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i)
  br label %poolStoreString.exit.thread

poolAppend.exit.i:                                ; preds = %for.cond.i.i
  %25 = load ptr, ptr %start.i.i1142, align 8
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i)
  %tobool.not.i = icmp eq ptr %25, null
  br i1 %tobool.not.i, label %poolStoreString.exit.thread, label %if.end.i

if.end.i:                                         ; preds = %poolAppend.exit.i
  %26 = load ptr, ptr %ptr1.i.i1128, align 8
  %27 = load ptr, ptr %end.i1176, align 8
  %cmp.i = icmp eq ptr %26, %27
  br i1 %cmp.i, label %land.lhs.true.i, label %poolStoreString.exit

land.lhs.true.i:                                  ; preds = %if.end.i
  %call3.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool949), !range !13
  %tobool4.not.i = icmp eq i8 %call3.i, 0
  br i1 %tobool4.not.i, label %poolStoreString.exit.thread, label %land.lhs.true.if.end6_crit_edge.i

land.lhs.true.if.end6_crit_edge.i:                ; preds = %land.lhs.true.i
  %.pre.i = load ptr, ptr %ptr1.i.i1128, align 8
  br label %poolStoreString.exit

poolStoreString.exit.thread:                      ; preds = %poolAppend.exit.i, %land.lhs.true.i, %poolAppend.exit.thread.i
  store ptr null, ptr %m_doctypeName150, align 8
  br label %return

poolStoreString.exit:                             ; preds = %if.end.i, %land.lhs.true.if.end6_crit_edge.i
  %28 = phi ptr [ %.pre.i, %land.lhs.true.if.end6_crit_edge.i ], [ %26, %if.end.i ]
  %incdec.ptr.i = getelementptr i8, ptr %28, i64 1
  store ptr %incdec.ptr.i, ptr %ptr1.i.i1128, align 8
  store i8 0, ptr %28, align 1
  %29 = load ptr, ptr %start.i.i1142, align 8
  store ptr %29, ptr %m_doctypeName150, align 8
  %tobool57.not = icmp eq ptr %29, null
  br i1 %tobool57.not, label %return, label %if.end59

if.end59:                                         ; preds = %poolStoreString.exit
  %30 = load ptr, ptr %ptr1.i.i1128, align 8
  store ptr %30, ptr %start.i.i1142, align 8
  store ptr null, ptr %m_doctypePubid157, align 8
  br label %if.end62

if.end62:                                         ; preds = %if.end59, %sw.bb52
  %handleDefault.0 = phi i8 [ 0, %if.end59 ], [ 1, %sw.bb52 ]
  store ptr null, ptr %m_doctypeSysid592, align 8
  br label %sw.epilog1436

sw.bb63:                                          ; preds = %sw.epilog44
  %31 = load ptr, ptr %m_startDoctypeDeclHandler1404, align 8
  %tobool65.not = icmp eq ptr %31, null
  br i1 %tobool65.not, label %land.lhs.true1439, label %if.then66

if.then66:                                        ; preds = %sw.bb63
  %32 = load ptr, ptr %m_handlerArg1382, align 8
  %33 = load ptr, ptr %m_doctypeName150, align 8
  %34 = load ptr, ptr %m_doctypeSysid592, align 8
  %35 = load ptr, ptr %m_doctypePubid157, align 8
  call void %31(ptr noundef %32, ptr noundef %33, ptr noundef %34, ptr noundef %35, i32 noundef 1) #24
  store ptr null, ptr %m_doctypeName150, align 8
  %36 = load ptr, ptr %freeBlocks.i1168, align 8
  %tobool.not.i736 = icmp eq ptr %36, null
  %37 = load ptr, ptr %m_tempPool949, align 8
  br i1 %tobool.not.i736, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %if.then66
  store ptr %37, ptr %freeBlocks.i1168, align 8
  br label %poolClear.exit

if.else.i:                                        ; preds = %if.then66
  %tobool3.not13.i = icmp eq ptr %37, null
  br i1 %tobool3.not13.i, label %poolClear.exit, label %while.body.i

while.body.i:                                     ; preds = %if.else.i, %while.body.i
  %38 = phi ptr [ %p.014.i, %while.body.i ], [ %36, %if.else.i ]
  %p.014.i = phi ptr [ %39, %while.body.i ], [ %37, %if.else.i ]
  %39 = load ptr, ptr %p.014.i, align 8
  store ptr %38, ptr %p.014.i, align 8
  store ptr %p.014.i, ptr %freeBlocks.i1168, align 8
  %tobool3.not.i = icmp eq ptr %39, null
  br i1 %tobool3.not.i, label %poolClear.exit, label %while.body.i, !llvm.loop !8

poolClear.exit:                                   ; preds = %while.body.i, %if.then.i, %if.else.i
  store ptr null, ptr %m_tempPool949, align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %end.i1176, i8 0, i64 24, i1 false)
  br label %if.end1443

sw.bb74:                                          ; preds = %sw.epilog44
  %40 = load ptr, ptr %next.addr, align 8
  %call76 = call fastcc i32 @processXmlDecl(ptr noundef %parser, i32 noundef 1, ptr noundef %s.addr.0, ptr noundef %40), !range !32
  %cmp77.not = icmp eq i32 %call76, 0
  br i1 %cmp77.not, label %if.end80, label %return

if.end80:                                         ; preds = %sw.bb74
  %41 = load ptr, ptr %m_encoding, align 8
  br label %if.end1443

sw.bb82:                                          ; preds = %sw.epilog44
  store i8 0, ptr %m_useForeignDTD578, align 1
  %call83 = call fastcc ptr @lookup(ptr noundef %parser, ptr noundef nonnull %paramEntities1138, ptr noundef nonnull @.str.86, i64 noundef 64)
  store ptr %call83, ptr %m_declEntity819, align 8
  %tobool85.not = icmp eq ptr %call83, null
  br i1 %tobool85.not, label %return, label %if.end87

if.end87:                                         ; preds = %sw.bb82
  store i8 1, ptr %hasParamEntityRefs1117, align 1
  %42 = load ptr, ptr %m_startDoctypeDeclHandler1404, align 8
  %tobool89.not = icmp eq ptr %42, null
  br i1 %tobool89.not, label %sw.bb109, label %if.then90

if.then90:                                        ; preds = %if.end87
  %isPublicId = getelementptr inbounds %struct.encoding, ptr %enc.addr.0, i64 0, i32 9
  %43 = load ptr, ptr %isPublicId, align 8
  %44 = load ptr, ptr %next.addr, align 8
  %call91 = call i32 %43(ptr noundef %enc.addr.0, ptr noundef %s.addr.0, ptr noundef %44, ptr noundef nonnull %eventPP.0) #24
  %tobool92.not = icmp eq i32 %call91, 0
  br i1 %tobool92.not, label %return, label %if.end94

if.end94:                                         ; preds = %if.then90
  %minBytesPerChar = getelementptr inbounds %struct.encoding, ptr %enc.addr.0, i64 0, i32 12
  %45 = load i32, ptr %minBytesPerChar, align 8
  %idx.ext = sext i32 %45 to i64
  %add.ptr = getelementptr i8, ptr %s.addr.0, i64 %idx.ext
  %46 = load ptr, ptr %next.addr, align 8
  %idx.neg = sub nsw i64 0, %idx.ext
  %add.ptr98 = getelementptr i8, ptr %46, i64 %idx.neg
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ptr.addr.i.i738)
  store ptr %add.ptr, ptr %ptr.addr.i.i738, align 8
  %47 = load ptr, ptr %ptr1.i.i1128, align 8
  %tobool.not.i.i740 = icmp eq ptr %47, null
  br i1 %tobool.not.i.i740, label %land.lhs.true.i.i764, label %if.end.i.i741

land.lhs.true.i.i764:                             ; preds = %if.end94
  %call.i.i765 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool949), !range !13
  %tobool2.not.i.i766 = icmp eq i8 %call.i.i765, 0
  br i1 %tobool2.not.i.i766, label %poolAppend.exit.thread.i750, label %if.end.i.i741

if.end.i.i741:                                    ; preds = %land.lhs.true.i.i764, %if.end94
  %utf8Convert.i.i742 = getelementptr inbounds %struct.encoding, ptr %enc.addr.0, i64 0, i32 10
  br label %for.cond.i.i744

for.cond.i.i744:                                  ; preds = %if.end8.i.i747, %if.end.i.i741
  %48 = load ptr, ptr %utf8Convert.i.i742, align 8
  %49 = load ptr, ptr %end.i1176, align 8
  %call5.i.i745 = call i32 %48(ptr noundef nonnull %enc.addr.0, ptr noundef nonnull %ptr.addr.i.i738, ptr noundef %add.ptr98, ptr noundef nonnull %ptr1.i.i1128, ptr noundef %49) #24
  %or.cond.i.i746 = icmp ult i32 %call5.i.i745, 2
  br i1 %or.cond.i.i746, label %poolAppend.exit.i752, label %if.end8.i.i747

if.end8.i.i747:                                   ; preds = %for.cond.i.i744
  %call9.i.i748 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool949), !range !13
  %tobool10.not.i.i749 = icmp eq i8 %call9.i.i748, 0
  br i1 %tobool10.not.i.i749, label %poolAppend.exit.thread.i750, label %for.cond.i.i744

poolAppend.exit.thread.i750:                      ; preds = %land.lhs.true.i.i764, %if.end8.i.i747
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i738)
  br label %return

poolAppend.exit.i752:                             ; preds = %for.cond.i.i744
  %50 = load ptr, ptr %start.i.i1142, align 8
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i738)
  %tobool.not.i754 = icmp eq ptr %50, null
  br i1 %tobool.not.i754, label %return, label %if.end.i755

if.end.i755:                                      ; preds = %poolAppend.exit.i752
  %51 = load ptr, ptr %ptr1.i.i1128, align 8
  %52 = load ptr, ptr %end.i1176, align 8
  %cmp.i756 = icmp eq ptr %51, %52
  br i1 %cmp.i756, label %land.lhs.true.i759, label %poolStoreString.exit767

land.lhs.true.i759:                               ; preds = %if.end.i755
  %call3.i760 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool949), !range !13
  %tobool4.not.i761 = icmp eq i8 %call3.i760, 0
  br i1 %tobool4.not.i761, label %return, label %land.lhs.true.if.end6_crit_edge.i762

land.lhs.true.if.end6_crit_edge.i762:             ; preds = %land.lhs.true.i759
  %.pre.i763 = load ptr, ptr %ptr1.i.i1128, align 8
  br label %poolStoreString.exit767

poolStoreString.exit767:                          ; preds = %if.end.i755, %land.lhs.true.if.end6_crit_edge.i762
  %53 = phi ptr [ %.pre.i763, %land.lhs.true.if.end6_crit_edge.i762 ], [ %51, %if.end.i755 ]
  %incdec.ptr.i758 = getelementptr i8, ptr %53, i64 1
  store ptr %incdec.ptr.i758, ptr %ptr1.i.i1128, align 8
  store i8 0, ptr %53, align 1
  %54 = load ptr, ptr %start.i.i1142, align 8
  %tobool100.not = icmp eq ptr %54, null
  br i1 %tobool100.not, label %return, label %if.end102

if.end102:                                        ; preds = %poolStoreString.exit767
  %55 = load i8, ptr %54, align 1
  %tobool.not14.i = icmp eq i8 %55, 0
  br i1 %tobool.not14.i, label %normalizePublicId.exit, label %for.body.i

for.body.i:                                       ; preds = %if.end102, %for.inc.i
  %56 = phi i8 [ %58, %for.inc.i ], [ %55, %if.end102 ]
  %s.016.i = phi ptr [ %incdec.ptr6.i, %for.inc.i ], [ %54, %if.end102 ]
  %p.015.i = phi ptr [ %p.1.i, %for.inc.i ], [ %54, %if.end102 ]
  %conv.i = sext i8 %56 to i32
  switch i32 %conv.i, label %for.inc.sink.split.i [
    i32 32, label %sw.bb.i
    i32 13, label %sw.bb.i
    i32 10, label %sw.bb.i
  ]

sw.bb.i:                                          ; preds = %for.body.i, %for.body.i, %for.body.i
  %cmp.not.i = icmp eq ptr %p.015.i, %54
  br i1 %cmp.not.i, label %for.inc.i, label %land.lhs.true.i768

land.lhs.true.i768:                               ; preds = %sw.bb.i
  %arrayidx.i = getelementptr i8, ptr %p.015.i, i64 -1
  %57 = load i8, ptr %arrayidx.i, align 1
  %cmp3.not.i = icmp eq i8 %57, 32
  br i1 %cmp3.not.i, label %for.inc.i, label %for.inc.sink.split.i

for.inc.sink.split.i:                             ; preds = %land.lhs.true.i768, %for.body.i
  %.sink.i = phi i8 [ 32, %land.lhs.true.i768 ], [ %56, %for.body.i ]
  %incdec.ptr5.i = getelementptr i8, ptr %p.015.i, i64 1
  store i8 %.sink.i, ptr %p.015.i, align 1
  br label %for.inc.i

for.inc.i:                                        ; preds = %for.inc.sink.split.i, %land.lhs.true.i768, %sw.bb.i
  %p.1.i = phi ptr [ %p.015.i, %land.lhs.true.i768 ], [ %54, %sw.bb.i ], [ %incdec.ptr5.i, %for.inc.sink.split.i ]
  %incdec.ptr6.i = getelementptr i8, ptr %s.016.i, i64 1
  %58 = load i8, ptr %incdec.ptr6.i, align 1
  %tobool.not.i769 = icmp eq i8 %58, 0
  br i1 %tobool.not.i769, label %for.end.i, label %for.body.i, !llvm.loop !33

for.end.i:                                        ; preds = %for.inc.i
  %cmp7.not.i = icmp eq ptr %p.1.i, %54
  br i1 %cmp7.not.i, label %normalizePublicId.exit, label %land.lhs.true9.i

land.lhs.true9.i:                                 ; preds = %for.end.i
  %arrayidx10.i = getelementptr i8, ptr %p.1.i, i64 -1
  %59 = load i8, ptr %arrayidx10.i, align 1
  %cmp12.i = icmp eq i8 %59, 32
  %spec.select.i = select i1 %cmp12.i, ptr %arrayidx10.i, ptr %p.1.i
  br label %normalizePublicId.exit

normalizePublicId.exit:                           ; preds = %if.end102, %for.end.i, %land.lhs.true9.i
  %p.2.i = phi ptr [ %54, %for.end.i ], [ %spec.select.i, %land.lhs.true9.i ], [ %54, %if.end102 ]
  store i8 0, ptr %p.2.i, align 1
  %60 = load ptr, ptr %ptr1.i.i1128, align 8
  store ptr %60, ptr %start.i.i1142, align 8
  store ptr %54, ptr %m_doctypePubid157, align 8
  br label %alreadyChecked

sw.bb109:                                         ; preds = %if.end87, %sw.epilog44
  %isPublicId110 = getelementptr inbounds %struct.encoding, ptr %enc.addr.0, i64 0, i32 9
  %61 = load ptr, ptr %isPublicId110, align 8
  %62 = load ptr, ptr %next.addr, align 8
  %call111 = call i32 %61(ptr noundef %enc.addr.0, ptr noundef %s.addr.0, ptr noundef %62, ptr noundef nonnull %eventPP.0) #24
  %tobool112.not = icmp eq i32 %call111, 0
  br i1 %tobool112.not, label %return, label %alreadyChecked

alreadyChecked:                                   ; preds = %sw.bb109, %normalizePublicId.exit
  %handleDefault.1 = phi i8 [ 1, %sw.bb109 ], [ 0, %normalizePublicId.exit ]
  %63 = load i8, ptr %keepProcessing1423, align 8
  %tobool116.not = icmp eq i8 %63, 0
  br i1 %tobool116.not, label %sw.epilog1436, label %land.lhs.true117

land.lhs.true117:                                 ; preds = %alreadyChecked
  %64 = load ptr, ptr %m_declEntity819, align 8
  %tobool119.not = icmp eq ptr %64, null
  br i1 %tobool119.not, label %sw.epilog1436, label %if.then120

if.then120:                                       ; preds = %land.lhs.true117
  %minBytesPerChar121 = getelementptr inbounds %struct.encoding, ptr %enc.addr.0, i64 0, i32 12
  %65 = load i32, ptr %minBytesPerChar121, align 8
  %idx.ext122 = sext i32 %65 to i64
  %add.ptr123 = getelementptr i8, ptr %s.addr.0, i64 %idx.ext122
  %66 = load ptr, ptr %next.addr, align 8
  %idx.neg126 = sub nsw i64 0, %idx.ext122
  %add.ptr127 = getelementptr i8, ptr %66, i64 %idx.neg126
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ptr.addr.i.i770)
  store ptr %add.ptr123, ptr %ptr.addr.i.i770, align 8
  %67 = load ptr, ptr %ptr1.i.i1188, align 8
  %tobool.not.i.i772 = icmp eq ptr %67, null
  br i1 %tobool.not.i.i772, label %land.lhs.true.i.i796, label %if.end.i.i773

land.lhs.true.i.i796:                             ; preds = %if.then120
  %call.i.i797 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool1126), !range !13
  %tobool2.not.i.i798 = icmp eq i8 %call.i.i797, 0
  br i1 %tobool2.not.i.i798, label %poolAppend.exit.thread.i782, label %if.end.i.i773

if.end.i.i773:                                    ; preds = %land.lhs.true.i.i796, %if.then120
  %utf8Convert.i.i774 = getelementptr inbounds %struct.encoding, ptr %enc.addr.0, i64 0, i32 10
  br label %for.cond.i.i776

for.cond.i.i776:                                  ; preds = %if.end8.i.i779, %if.end.i.i773
  %68 = load ptr, ptr %utf8Convert.i.i774, align 8
  %69 = load ptr, ptr %end4.i.i1192, align 8
  %call5.i.i777 = call i32 %68(ptr noundef %enc.addr.0, ptr noundef nonnull %ptr.addr.i.i770, ptr noundef %add.ptr127, ptr noundef nonnull %ptr1.i.i1188, ptr noundef %69) #24
  %or.cond.i.i778 = icmp ult i32 %call5.i.i777, 2
  br i1 %or.cond.i.i778, label %poolAppend.exit.i784, label %if.end8.i.i779

if.end8.i.i779:                                   ; preds = %for.cond.i.i776
  %call9.i.i780 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool1126), !range !13
  %tobool10.not.i.i781 = icmp eq i8 %call9.i.i780, 0
  br i1 %tobool10.not.i.i781, label %poolAppend.exit.thread.i782, label %for.cond.i.i776

poolAppend.exit.thread.i782:                      ; preds = %land.lhs.true.i.i796, %if.end8.i.i779
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i770)
  br label %return

poolAppend.exit.i784:                             ; preds = %for.cond.i.i776
  %70 = load ptr, ptr %start.i.i1202, align 8
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i770)
  %tobool.not.i786 = icmp eq ptr %70, null
  br i1 %tobool.not.i786, label %return, label %if.end.i787

if.end.i787:                                      ; preds = %poolAppend.exit.i784
  %71 = load ptr, ptr %ptr1.i.i1188, align 8
  %72 = load ptr, ptr %end4.i.i1192, align 8
  %cmp.i788 = icmp eq ptr %71, %72
  br i1 %cmp.i788, label %land.lhs.true.i791, label %poolStoreString.exit799

land.lhs.true.i791:                               ; preds = %if.end.i787
  %call3.i792 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool1126), !range !13
  %tobool4.not.i793 = icmp eq i8 %call3.i792, 0
  br i1 %tobool4.not.i793, label %return, label %land.lhs.true.if.end6_crit_edge.i794

land.lhs.true.if.end6_crit_edge.i794:             ; preds = %land.lhs.true.i791
  %.pre.i795 = load ptr, ptr %ptr1.i.i1188, align 8
  br label %poolStoreString.exit799

poolStoreString.exit799:                          ; preds = %if.end.i787, %land.lhs.true.if.end6_crit_edge.i794
  %73 = phi ptr [ %.pre.i795, %land.lhs.true.if.end6_crit_edge.i794 ], [ %71, %if.end.i787 ]
  %incdec.ptr.i790 = getelementptr i8, ptr %73, i64 1
  store ptr %incdec.ptr.i790, ptr %ptr1.i.i1188, align 8
  store i8 0, ptr %73, align 1
  %74 = load ptr, ptr %start.i.i1202, align 8
  %tobool129.not = icmp eq ptr %74, null
  br i1 %tobool129.not, label %return, label %if.end131

if.end131:                                        ; preds = %poolStoreString.exit799
  %75 = load i8, ptr %74, align 1
  %tobool.not14.i800 = icmp eq i8 %75, 0
  br i1 %tobool.not14.i800, label %normalizePublicId.exit824, label %for.body.i801

for.body.i801:                                    ; preds = %if.end131, %for.inc.i813
  %76 = phi i8 [ %78, %for.inc.i813 ], [ %75, %if.end131 ]
  %s.016.i802 = phi ptr [ %incdec.ptr6.i815, %for.inc.i813 ], [ %74, %if.end131 ]
  %p.015.i803 = phi ptr [ %p.1.i814, %for.inc.i813 ], [ %74, %if.end131 ]
  %conv.i804 = sext i8 %76 to i32
  switch i32 %conv.i804, label %for.inc.sink.split.i810 [
    i32 32, label %sw.bb.i805
    i32 13, label %sw.bb.i805
    i32 10, label %sw.bb.i805
  ]

sw.bb.i805:                                       ; preds = %for.body.i801, %for.body.i801, %for.body.i801
  %cmp.not.i806 = icmp eq ptr %p.015.i803, %74
  br i1 %cmp.not.i806, label %for.inc.i813, label %land.lhs.true.i807

land.lhs.true.i807:                               ; preds = %sw.bb.i805
  %arrayidx.i808 = getelementptr i8, ptr %p.015.i803, i64 -1
  %77 = load i8, ptr %arrayidx.i808, align 1
  %cmp3.not.i809 = icmp eq i8 %77, 32
  br i1 %cmp3.not.i809, label %for.inc.i813, label %for.inc.sink.split.i810

for.inc.sink.split.i810:                          ; preds = %land.lhs.true.i807, %for.body.i801
  %.sink.i811 = phi i8 [ 32, %land.lhs.true.i807 ], [ %76, %for.body.i801 ]
  %incdec.ptr5.i812 = getelementptr i8, ptr %p.015.i803, i64 1
  store i8 %.sink.i811, ptr %p.015.i803, align 1
  br label %for.inc.i813

for.inc.i813:                                     ; preds = %for.inc.sink.split.i810, %land.lhs.true.i807, %sw.bb.i805
  %p.1.i814 = phi ptr [ %p.015.i803, %land.lhs.true.i807 ], [ %74, %sw.bb.i805 ], [ %incdec.ptr5.i812, %for.inc.sink.split.i810 ]
  %incdec.ptr6.i815 = getelementptr i8, ptr %s.016.i802, i64 1
  %78 = load i8, ptr %incdec.ptr6.i815, align 1
  %tobool.not.i816 = icmp eq i8 %78, 0
  br i1 %tobool.not.i816, label %for.end.i817, label %for.body.i801, !llvm.loop !33

for.end.i817:                                     ; preds = %for.inc.i813
  %cmp7.not.i818 = icmp eq ptr %p.1.i814, %74
  br i1 %cmp7.not.i818, label %normalizePublicId.exit824, label %land.lhs.true9.i819

land.lhs.true9.i819:                              ; preds = %for.end.i817
  %arrayidx10.i820 = getelementptr i8, ptr %p.1.i814, i64 -1
  %79 = load i8, ptr %arrayidx10.i820, align 1
  %cmp12.i821 = icmp eq i8 %79, 32
  %spec.select.i822 = select i1 %cmp12.i821, ptr %arrayidx10.i820, ptr %p.1.i814
  br label %normalizePublicId.exit824

normalizePublicId.exit824:                        ; preds = %if.end131, %for.end.i817, %land.lhs.true9.i819
  %p.2.i823 = phi ptr [ %74, %for.end.i817 ], [ %spec.select.i822, %land.lhs.true9.i819 ], [ %74, %if.end131 ]
  store i8 0, ptr %p.2.i823, align 1
  %80 = load ptr, ptr %m_declEntity819, align 8
  %publicId = getelementptr inbounds %struct.ENTITY, ptr %80, i64 0, i32 6
  store ptr %74, ptr %publicId, align 8
  %81 = load ptr, ptr %ptr1.i.i1188, align 8
  store ptr %81, ptr %start.i.i1202, align 8
  %82 = load ptr, ptr %m_entityDeclHandler1413, align 8
  %tobool137 = icmp ne ptr %82, null
  %cmp139 = icmp eq i32 %call37, 14
  %or.cond2 = and i1 %cmp139, %tobool137
  br i1 %or.cond2, label %if.end1443, label %sw.epilog1436

sw.bb144:                                         ; preds = %sw.epilog44
  br i1 %cmp146.not, label %if.end149, label %return

if.end149:                                        ; preds = %sw.bb144
  %83 = load ptr, ptr %m_doctypeName150, align 8
  %tobool151.not = icmp eq ptr %83, null
  br i1 %tobool151.not, label %if.end159, label %if.then152

if.then152:                                       ; preds = %if.end149
  %84 = load ptr, ptr %m_startDoctypeDeclHandler1404, align 8
  %85 = load ptr, ptr %m_handlerArg1382, align 8
  %86 = load ptr, ptr %m_doctypeSysid592, align 8
  %87 = load ptr, ptr %m_doctypePubid157, align 8
  call void %84(ptr noundef %85, ptr noundef nonnull %83, ptr noundef %86, ptr noundef %87, i32 noundef 0) #24
  %88 = load ptr, ptr %freeBlocks.i1168, align 8
  %tobool.not.i826 = icmp eq ptr %88, null
  %89 = load ptr, ptr %m_tempPool949, align 8
  br i1 %tobool.not.i826, label %if.then.i834, label %if.else.i827

if.then.i834:                                     ; preds = %if.then152
  store ptr %89, ptr %freeBlocks.i1168, align 8
  br label %poolClear.exit835

if.else.i827:                                     ; preds = %if.then152
  %tobool3.not13.i828 = icmp eq ptr %89, null
  br i1 %tobool3.not13.i828, label %poolClear.exit835, label %while.body.i829

while.body.i829:                                  ; preds = %if.else.i827, %while.body.i829
  %90 = phi ptr [ %p.014.i830, %while.body.i829 ], [ %88, %if.else.i827 ]
  %p.014.i830 = phi ptr [ %91, %while.body.i829 ], [ %89, %if.else.i827 ]
  %91 = load ptr, ptr %p.014.i830, align 8
  store ptr %90, ptr %p.014.i830, align 8
  store ptr %p.014.i830, ptr %freeBlocks.i1168, align 8
  %tobool3.not.i831 = icmp eq ptr %91, null
  br i1 %tobool3.not.i831, label %poolClear.exit835, label %while.body.i829, !llvm.loop !8

poolClear.exit835:                                ; preds = %while.body.i829, %if.then.i834, %if.else.i827
  store ptr null, ptr %m_tempPool949, align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %end.i1176, i8 0, i64 24, i1 false)
  br label %if.end159

if.end159:                                        ; preds = %poolClear.exit835, %if.end149
  %handleDefault.2 = phi i8 [ 0, %poolClear.exit835 ], [ 1, %if.end149 ]
  %92 = load ptr, ptr %m_doctypeSysid592, align 8
  %tobool161.not = icmp eq ptr %92, null
  br i1 %tobool161.not, label %lor.lhs.false162, label %if.then166

lor.lhs.false162:                                 ; preds = %if.end159
  %93 = load i8, ptr %m_useForeignDTD578, align 1
  %tobool165.not = icmp eq i8 %93, 0
  br i1 %tobool165.not, label %if.end211, label %if.then166

if.then166:                                       ; preds = %lor.lhs.false162, %if.end159
  %94 = load i8, ptr %hasParamEntityRefs1117, align 1
  store i8 1, ptr %hasParamEntityRefs1117, align 1
  %95 = load i32, ptr %m_paramEntityParsing1118, align 4
  %tobool169.not = icmp eq i32 %95, 0
  br i1 %tobool169.not, label %if.end209, label %land.lhs.true170

land.lhs.true170:                                 ; preds = %if.then166
  %96 = load ptr, ptr %m_externalEntityRefHandler1198, align 8
  %tobool171.not = icmp eq ptr %96, null
  br i1 %tobool171.not, label %if.end209, label %if.then172

if.then172:                                       ; preds = %land.lhs.true170
  %call174 = call fastcc ptr @lookup(ptr noundef nonnull %parser, ptr noundef nonnull %paramEntities1138, ptr noundef nonnull @.str.86, i64 noundef 64)
  %tobool175.not = icmp eq ptr %call174, null
  br i1 %tobool175.not, label %return, label %if.end177

if.end177:                                        ; preds = %if.then172
  %97 = load i8, ptr %m_useForeignDTD578, align 1
  %tobool179.not = icmp eq i8 %97, 0
  br i1 %tobool179.not, label %if.end181, label %if.then180

if.then180:                                       ; preds = %if.end177
  %98 = load ptr, ptr %m_curBase946, align 8
  %base = getelementptr inbounds %struct.ENTITY, ptr %call174, i64 0, i32 5
  store ptr %98, ptr %base, align 8
  br label %if.end181

if.end181:                                        ; preds = %if.then180, %if.end177
  store i8 0, ptr %paramEntityRead1201, align 1
  %99 = load ptr, ptr %m_externalEntityRefHandler1198, align 8
  %100 = load ptr, ptr %m_externalEntityRefHandlerArg1204, align 8
  %base183 = getelementptr inbounds %struct.ENTITY, ptr %call174, i64 0, i32 5
  %101 = load ptr, ptr %base183, align 8
  %systemId = getelementptr inbounds %struct.ENTITY, ptr %call174, i64 0, i32 4
  %102 = load ptr, ptr %systemId, align 8
  %publicId184 = getelementptr inbounds %struct.ENTITY, ptr %call174, i64 0, i32 6
  %103 = load ptr, ptr %publicId184, align 8
  %call185 = call i32 %99(ptr noundef %100, ptr noundef null, ptr noundef %101, ptr noundef %102, ptr noundef %103) #24
  %tobool186.not = icmp eq i32 %call185, 0
  br i1 %tobool186.not, label %return, label %if.end188

if.end188:                                        ; preds = %if.end181
  %104 = load i8, ptr %paramEntityRead1201, align 1
  %tobool190.not = icmp eq i8 %104, 0
  br i1 %tobool190.not, label %if.else202, label %if.then191

if.then191:                                       ; preds = %if.end188
  %105 = load i8, ptr %standalone1147, align 2
  %tobool192.not = icmp eq i8 %105, 0
  br i1 %tobool192.not, label %land.lhs.true193, label %if.end209

land.lhs.true193:                                 ; preds = %if.then191
  %106 = load ptr, ptr %m_notStandaloneHandler1228, align 8
  %tobool194.not = icmp eq ptr %106, null
  br i1 %tobool194.not, label %if.end209, label %land.lhs.true195

land.lhs.true195:                                 ; preds = %land.lhs.true193
  %107 = load ptr, ptr %m_handlerArg1382, align 8
  %call198 = call i32 %106(ptr noundef %107) #24
  %tobool199.not = icmp eq i32 %call198, 0
  br i1 %tobool199.not, label %return, label %if.end209

if.else202:                                       ; preds = %if.end188
  %108 = load ptr, ptr %m_doctypeSysid592, align 8
  %tobool204.not = icmp eq ptr %108, null
  br i1 %tobool204.not, label %if.then205, label %if.end209

if.then205:                                       ; preds = %if.else202
  store i8 %94, ptr %hasParamEntityRefs1117, align 1
  br label %if.end209

if.end209:                                        ; preds = %land.lhs.true195, %land.lhs.true193, %if.then191, %if.then205, %if.else202, %land.lhs.true170, %if.then166
  store i8 0, ptr %m_useForeignDTD578, align 1
  br label %if.end211

if.end211:                                        ; preds = %if.end209, %lor.lhs.false162
  %109 = load ptr, ptr %m_endDoctypeDeclHandler, align 8
  %tobool212.not = icmp eq ptr %109, null
  br i1 %tobool212.not, label %sw.epilog1436, label %if.then213

if.then213:                                       ; preds = %if.end211
  %110 = load ptr, ptr %m_handlerArg1382, align 8
  call void %109(ptr noundef %110) #24
  br label %if.end1443

sw.bb217:                                         ; preds = %sw.epilog44
  %111 = load i8, ptr %m_useForeignDTD578, align 1
  %tobool219.not = icmp eq i8 %111, 0
  br i1 %tobool219.not, label %if.end267, label %if.then220

if.then220:                                       ; preds = %sw.bb217
  %112 = load i8, ptr %hasParamEntityRefs1117, align 1
  store i8 1, ptr %hasParamEntityRefs1117, align 1
  %113 = load i32, ptr %m_paramEntityParsing1118, align 4
  %tobool225.not = icmp eq i32 %113, 0
  br i1 %tobool225.not, label %if.end267, label %land.lhs.true226

land.lhs.true226:                                 ; preds = %if.then220
  %114 = load ptr, ptr %m_externalEntityRefHandler1198, align 8
  %tobool228.not = icmp eq ptr %114, null
  br i1 %tobool228.not, label %if.end267, label %if.then229

if.then229:                                       ; preds = %land.lhs.true226
  %call232 = call fastcc ptr @lookup(ptr noundef nonnull %parser, ptr noundef nonnull %paramEntities1138, ptr noundef nonnull @.str.86, i64 noundef 64)
  %tobool233.not = icmp eq ptr %call232, null
  br i1 %tobool233.not, label %return, label %if.end235

if.end235:                                        ; preds = %if.then229
  %115 = load ptr, ptr %m_curBase946, align 8
  %base237 = getelementptr inbounds %struct.ENTITY, ptr %call232, i64 0, i32 5
  store ptr %115, ptr %base237, align 8
  store i8 0, ptr %paramEntityRead1201, align 1
  %116 = load ptr, ptr %m_externalEntityRefHandler1198, align 8
  %117 = load ptr, ptr %m_externalEntityRefHandlerArg1204, align 8
  %118 = load ptr, ptr %base237, align 8
  %systemId242 = getelementptr inbounds %struct.ENTITY, ptr %call232, i64 0, i32 4
  %119 = load ptr, ptr %systemId242, align 8
  %publicId243 = getelementptr inbounds %struct.ENTITY, ptr %call232, i64 0, i32 6
  %120 = load ptr, ptr %publicId243, align 8
  %call244 = call i32 %116(ptr noundef %117, ptr noundef null, ptr noundef %118, ptr noundef %119, ptr noundef %120) #24
  %tobool245.not = icmp eq i32 %call244, 0
  br i1 %tobool245.not, label %return, label %if.end247

if.end247:                                        ; preds = %if.end235
  %121 = load i8, ptr %paramEntityRead1201, align 1
  %tobool249.not = icmp eq i8 %121, 0
  br i1 %tobool249.not, label %if.else263, label %if.then250

if.then250:                                       ; preds = %if.end247
  %122 = load i8, ptr %standalone1147, align 2
  %tobool252.not = icmp eq i8 %122, 0
  br i1 %tobool252.not, label %land.lhs.true253, label %if.end267

land.lhs.true253:                                 ; preds = %if.then250
  %123 = load ptr, ptr %m_notStandaloneHandler1228, align 8
  %tobool255.not = icmp eq ptr %123, null
  br i1 %tobool255.not, label %if.end267, label %land.lhs.true256

land.lhs.true256:                                 ; preds = %land.lhs.true253
  %124 = load ptr, ptr %m_handlerArg1382, align 8
  %call259 = call i32 %123(ptr noundef %124) #24
  %tobool260.not = icmp eq i32 %call259, 0
  br i1 %tobool260.not, label %return, label %if.end267

if.else263:                                       ; preds = %if.end247
  store i8 %112, ptr %hasParamEntityRefs1117, align 1
  br label %if.end267

if.end267:                                        ; preds = %if.then220, %land.lhs.true226, %if.then250, %land.lhs.true253, %land.lhs.true256, %if.else263, %sw.bb217
  %m_processor = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 45
  store ptr @contentProcessor, ptr %m_processor, align 8
  %call268 = call i32 @contentProcessor(ptr noundef nonnull %parser, ptr noundef %s.addr.0, ptr noundef %end, ptr noundef %nextPtr)
  br label %return

sw.bb269:                                         ; preds = %sw.epilog44
  %125 = load ptr, ptr %next.addr, align 8
  %call270 = call fastcc ptr @getElementType(ptr noundef %parser, ptr noundef %enc.addr.0, ptr noundef %s.addr.0, ptr noundef %125)
  store ptr %call270, ptr %m_declElementType1383, align 8
  %tobool272.not = icmp eq ptr %call270, null
  br i1 %tobool272.not, label %return, label %checkAttListDeclHandler

sw.bb275:                                         ; preds = %sw.epilog44
  %126 = load ptr, ptr %next.addr, align 8
  %call276 = call fastcc ptr @getAttributeId(ptr noundef %parser, ptr noundef %enc.addr.0, ptr noundef %s.addr.0, ptr noundef %126)
  store ptr %call276, ptr %m_declAttributeId442, align 8
  %tobool278.not = icmp eq ptr %call276, null
  br i1 %tobool278.not, label %return, label %if.end280

if.end280:                                        ; preds = %sw.bb275
  store i8 0, ptr %m_declAttributeIsCdata422, align 8
  store ptr null, ptr %m_declAttributeType451, align 8
  store i8 0, ptr %m_declAttributeIsId342, align 1
  br label %checkAttListDeclHandler

sw.bb281:                                         ; preds = %sw.epilog44
  store i8 1, ptr %m_declAttributeIsCdata422, align 8
  store ptr @doProlog.atypeCDATA, ptr %m_declAttributeType451, align 8
  br label %checkAttListDeclHandler

sw.bb284:                                         ; preds = %sw.epilog44
  store i8 1, ptr %m_declAttributeIsId342, align 1
  store ptr @doProlog.atypeID, ptr %m_declAttributeType451, align 8
  br label %checkAttListDeclHandler

sw.bb287:                                         ; preds = %sw.epilog44
  store ptr @doProlog.atypeIDREF, ptr %m_declAttributeType451, align 8
  br label %checkAttListDeclHandler

sw.bb289:                                         ; preds = %sw.epilog44
  store ptr @doProlog.atypeIDREFS, ptr %m_declAttributeType451, align 8
  br label %checkAttListDeclHandler

sw.bb291:                                         ; preds = %sw.epilog44
  store ptr @doProlog.atypeENTITY, ptr %m_declAttributeType451, align 8
  br label %checkAttListDeclHandler

sw.bb293:                                         ; preds = %sw.epilog44
  store ptr @doProlog.atypeENTITIES, ptr %m_declAttributeType451, align 8
  br label %checkAttListDeclHandler

sw.bb295:                                         ; preds = %sw.epilog44
  store ptr @doProlog.atypeNMTOKEN, ptr %m_declAttributeType451, align 8
  br label %checkAttListDeclHandler

sw.bb297:                                         ; preds = %sw.epilog44
  store ptr @doProlog.atypeNMTOKENS, ptr %m_declAttributeType451, align 8
  br label %checkAttListDeclHandler

checkAttListDeclHandler:                          ; preds = %sw.bb269, %sw.bb297, %sw.bb295, %sw.bb293, %sw.bb291, %sw.bb289, %sw.bb287, %sw.bb284, %sw.bb281, %if.end280
  %127 = load i8, ptr %keepProcessing1423, align 8
  %tobool301.not = icmp eq i8 %127, 0
  br i1 %tobool301.not, label %land.lhs.true1439, label %land.lhs.true302

land.lhs.true302:                                 ; preds = %checkAttListDeclHandler
  %128 = load ptr, ptr %m_attlistDeclHandler1427, align 8
  %tobool303.not = icmp eq ptr %128, null
  br i1 %tobool303.not, label %land.lhs.true1439, label %if.end1443

sw.bb306:                                         ; preds = %sw.epilog44, %sw.epilog44
  %129 = load i8, ptr %keepProcessing1423, align 8
  %tobool309.not = icmp eq i8 %129, 0
  br i1 %tobool309.not, label %land.lhs.true1439, label %land.lhs.true310

land.lhs.true310:                                 ; preds = %sw.bb306
  %130 = load ptr, ptr %m_attlistDeclHandler1427, align 8
  %tobool312.not = icmp eq ptr %130, null
  br i1 %tobool312.not, label %land.lhs.true1439, label %if.then313

if.then313:                                       ; preds = %land.lhs.true310
  %131 = load ptr, ptr %m_declAttributeType451, align 8
  %tobool315.not = icmp eq ptr %131, null
  %cmp318 = icmp eq i32 %call37, 32
  %cond = select i1 %cmp318, ptr @doProlog.notationPrefix, ptr @doProlog.enumValueStart
  %prefix.0 = select i1 %tobool315.not, ptr %cond, ptr @doProlog.enumValueSep
  %132 = load i8, ptr %prefix.0, align 1
  %tobool.not7.i = icmp eq i8 %132, 0
  br i1 %tobool.not7.i, label %poolAppendString.exit, label %while.body.i837

while.body.i837:                                  ; preds = %if.then313, %cond.false.i
  %.pre.i843 = phi i8 [ %136, %cond.false.i ], [ %132, %if.then313 ]
  %s.addr.08.i = phi ptr [ %incdec.ptr3.i, %cond.false.i ], [ %prefix.0, %if.then313 ]
  %133 = load ptr, ptr %ptr1.i.i1128, align 8
  %134 = load ptr, ptr %end.i1176, align 8
  %cmp.i838 = icmp eq ptr %133, %134
  br i1 %cmp.i838, label %land.lhs.true.i842, label %cond.false.i

land.lhs.true.i842:                               ; preds = %while.body.i837
  %call.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool949), !range !13
  %tobool1.not.i = icmp eq i8 %call.i, 0
  br i1 %tobool1.not.i, label %return, label %land.lhs.true.cond.false_crit_edge.i

land.lhs.true.cond.false_crit_edge.i:             ; preds = %land.lhs.true.i842
  %.pre9.i = load ptr, ptr %ptr1.i.i1128, align 8
  br label %cond.false.i

cond.false.i:                                     ; preds = %land.lhs.true.cond.false_crit_edge.i, %while.body.i837
  %135 = phi ptr [ %.pre9.i, %land.lhs.true.cond.false_crit_edge.i ], [ %133, %while.body.i837 ]
  %incdec.ptr.i839 = getelementptr i8, ptr %135, i64 1
  store ptr %incdec.ptr.i839, ptr %ptr1.i.i1128, align 8
  store i8 %.pre.i843, ptr %135, align 1
  %incdec.ptr3.i = getelementptr i8, ptr %s.addr.08.i, i64 1
  %136 = load i8, ptr %incdec.ptr3.i, align 1
  %tobool.not.i840 = icmp eq i8 %136, 0
  br i1 %tobool.not.i840, label %poolAppendString.exit, label %while.body.i837, !llvm.loop !34

poolAppendString.exit:                            ; preds = %cond.false.i, %if.then313
  %137 = load ptr, ptr %start.i.i1142, align 8
  %tobool323.not = icmp eq ptr %137, null
  br i1 %tobool323.not, label %return, label %if.end325

if.end325:                                        ; preds = %poolAppendString.exit
  %138 = load ptr, ptr %next.addr, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ptr.addr.i)
  store ptr %s.addr.0, ptr %ptr.addr.i, align 8
  %139 = load ptr, ptr %ptr1.i.i1128, align 8
  %tobool.not.i844 = icmp eq ptr %139, null
  br i1 %tobool.not.i844, label %land.lhs.true.i849, label %if.end.i845

land.lhs.true.i849:                               ; preds = %if.end325
  %call.i850 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool949), !range !13
  %tobool2.not.i = icmp eq i8 %call.i850, 0
  br i1 %tobool2.not.i, label %poolAppend.exit.thread, label %if.end.i845

if.end.i845:                                      ; preds = %land.lhs.true.i849, %if.end325
  %utf8Convert.i = getelementptr inbounds %struct.encoding, ptr %enc.addr.0, i64 0, i32 10
  br label %for.cond.i

for.cond.i:                                       ; preds = %if.end8.i, %if.end.i845
  %140 = load ptr, ptr %utf8Convert.i, align 8
  %141 = load ptr, ptr %end.i1176, align 8
  %call5.i = call i32 %140(ptr noundef %enc.addr.0, ptr noundef nonnull %ptr.addr.i, ptr noundef %138, ptr noundef nonnull %ptr1.i.i1128, ptr noundef %141) #24
  %or.cond.i = icmp ult i32 %call5.i, 2
  br i1 %or.cond.i, label %poolAppend.exit, label %if.end8.i

if.end8.i:                                        ; preds = %for.cond.i
  %call9.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool949), !range !13
  %tobool10.not.i = icmp eq i8 %call9.i, 0
  br i1 %tobool10.not.i, label %poolAppend.exit.thread, label %for.cond.i

poolAppend.exit.thread:                           ; preds = %land.lhs.true.i849, %if.end8.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i)
  br label %return

poolAppend.exit:                                  ; preds = %for.cond.i
  %142 = load ptr, ptr %start.i.i1142, align 8
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i)
  %tobool328.not = icmp eq ptr %142, null
  br i1 %tobool328.not, label %return, label %if.end330

if.end330:                                        ; preds = %poolAppend.exit
  store ptr %142, ptr %m_declAttributeType451, align 8
  br label %if.end1443

sw.bb335:                                         ; preds = %sw.epilog44, %sw.epilog44
  %143 = load i8, ptr %keepProcessing1423, align 8
  %tobool337.not = icmp eq i8 %143, 0
  br i1 %tobool337.not, label %if.end415, label %if.then338

if.then338:                                       ; preds = %sw.bb335
  %144 = load ptr, ptr %m_declElementType1383, align 8
  %145 = load ptr, ptr %m_declAttributeId442, align 8
  %146 = load i8, ptr %m_declAttributeIsCdata422, align 8
  %147 = load i8, ptr %m_declAttributeIsId342, align 1
  %call343 = call fastcc i32 @defineAttribute(ptr noundef %144, ptr noundef %145, i8 noundef zeroext %146, i8 noundef zeroext %147, ptr noundef null, ptr noundef %parser), !range !17
  %tobool344.not = icmp eq i32 %call343, 0
  br i1 %tobool344.not, label %return, label %if.end346

if.end346:                                        ; preds = %if.then338
  %148 = load ptr, ptr %m_attlistDeclHandler1427, align 8
  %tobool348.not = icmp eq ptr %148, null
  br i1 %tobool348.not, label %if.end415, label %land.lhs.true349

land.lhs.true349:                                 ; preds = %if.end346
  %149 = load ptr, ptr %m_declAttributeType451, align 8
  %tobool351.not = icmp eq ptr %149, null
  br i1 %tobool351.not, label %if.end415, label %if.then352

if.then352:                                       ; preds = %land.lhs.true349
  %150 = load i8, ptr %149, align 1
  switch i8 %150, label %if.end405 [
    i8 40, label %if.then367
    i8 78, label %land.lhs.true362
  ]

land.lhs.true362:                                 ; preds = %if.then352
  %arrayidx = getelementptr i8, ptr %149, i64 1
  %151 = load i8, ptr %arrayidx, align 1
  %cmp365 = icmp eq i8 %151, 79
  br i1 %cmp365, label %if.then367, label %if.end405

if.then367:                                       ; preds = %if.then352, %land.lhs.true362
  %152 = load ptr, ptr %ptr1.i.i1128, align 8
  %153 = load ptr, ptr %end.i1176, align 8
  %cmp372 = icmp eq ptr %152, %153
  br i1 %cmp372, label %land.lhs.true374, label %cond.false

land.lhs.true374:                                 ; preds = %if.then367
  %call376 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool949), !range !13
  %tobool377.not = icmp eq i8 %call376, 0
  br i1 %tobool377.not, label %return, label %land.lhs.true374.cond.false_crit_edge

land.lhs.true374.cond.false_crit_edge:            ; preds = %land.lhs.true374
  %.pre1707 = load ptr, ptr %ptr1.i.i1128, align 8
  br label %cond.false

cond.false:                                       ; preds = %land.lhs.true374.cond.false_crit_edge, %if.then367
  %154 = phi ptr [ %.pre1707, %land.lhs.true374.cond.false_crit_edge ], [ %152, %if.then367 ]
  %incdec.ptr = getelementptr i8, ptr %154, i64 1
  store ptr %incdec.ptr, ptr %ptr1.i.i1128, align 8
  store i8 41, ptr %154, align 1
  %155 = load ptr, ptr %ptr1.i.i1128, align 8
  %156 = load ptr, ptr %end.i1176, align 8
  %cmp385 = icmp eq ptr %155, %156
  br i1 %cmp385, label %land.lhs.true387, label %cond.false392

land.lhs.true387:                                 ; preds = %cond.false
  %call389 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool949), !range !13
  %tobool390.not = icmp eq i8 %call389, 0
  br i1 %tobool390.not, label %return, label %land.lhs.true387.cond.false392_crit_edge

land.lhs.true387.cond.false392_crit_edge:         ; preds = %land.lhs.true387
  %.pre1708 = load ptr, ptr %ptr1.i.i1128, align 8
  br label %cond.false392

cond.false392:                                    ; preds = %land.lhs.true387.cond.false392_crit_edge, %cond.false
  %157 = phi ptr [ %.pre1708, %land.lhs.true387.cond.false392_crit_edge ], [ %155, %cond.false ]
  %incdec.ptr395 = getelementptr i8, ptr %157, i64 1
  store ptr %incdec.ptr395, ptr %ptr1.i.i1128, align 8
  store i8 0, ptr %157, align 1
  %158 = load ptr, ptr %start.i.i1142, align 8
  store ptr %158, ptr %m_declAttributeType451, align 8
  %159 = load ptr, ptr %ptr1.i.i1128, align 8
  store ptr %159, ptr %start.i.i1142, align 8
  br label %if.end405

if.end405:                                        ; preds = %if.then352, %cond.false392, %land.lhs.true362
  store ptr %s.addr.0, ptr %eventEndPP.0, align 8
  %160 = load ptr, ptr %m_attlistDeclHandler1427, align 8
  %161 = load ptr, ptr %m_handlerArg1382, align 8
  %162 = load ptr, ptr %m_declElementType1383, align 8
  %163 = load ptr, ptr %162, align 8
  %164 = load ptr, ptr %m_declAttributeId442, align 8
  %165 = load ptr, ptr %164, align 8
  %166 = load ptr, ptr %m_declAttributeType451, align 8
  %cmp412 = icmp eq i32 %call37, 36
  %conv413 = zext i1 %cmp412 to i32
  call void %160(ptr noundef %161, ptr noundef %163, ptr noundef %165, ptr noundef %166, ptr noundef null, i32 noundef %conv413) #24
  br label %if.end415

if.end415:                                        ; preds = %if.end346, %land.lhs.true349, %if.end405, %sw.bb335
  %handleDefault.3 = phi i8 [ 0, %if.end405 ], [ 1, %land.lhs.true349 ], [ 1, %if.end346 ], [ 1, %sw.bb335 ]
  %167 = load ptr, ptr %freeBlocks.i1168, align 8
  %tobool.not.i852 = icmp eq ptr %167, null
  %168 = load ptr, ptr %m_tempPool949, align 8
  br i1 %tobool.not.i852, label %if.then.i860, label %if.else.i853

if.then.i860:                                     ; preds = %if.end415
  store ptr %168, ptr %freeBlocks.i1168, align 8
  br label %poolClear.exit861

if.else.i853:                                     ; preds = %if.end415
  %tobool3.not13.i854 = icmp eq ptr %168, null
  br i1 %tobool3.not13.i854, label %poolClear.exit861, label %while.body.i855

while.body.i855:                                  ; preds = %if.else.i853, %while.body.i855
  %169 = phi ptr [ %p.014.i856, %while.body.i855 ], [ %167, %if.else.i853 ]
  %p.014.i856 = phi ptr [ %170, %while.body.i855 ], [ %168, %if.else.i853 ]
  %170 = load ptr, ptr %p.014.i856, align 8
  store ptr %169, ptr %p.014.i856, align 8
  store ptr %p.014.i856, ptr %freeBlocks.i1168, align 8
  %tobool3.not.i857 = icmp eq ptr %170, null
  br i1 %tobool3.not.i857, label %poolClear.exit861, label %while.body.i855, !llvm.loop !8

poolClear.exit861:                                ; preds = %while.body.i855, %if.then.i860, %if.else.i853
  store ptr null, ptr %m_tempPool949, align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %end.i1176, i8 0, i64 24, i1 false)
  br label %sw.epilog1436

sw.bb417:                                         ; preds = %sw.epilog44, %sw.epilog44
  %171 = load i8, ptr %keepProcessing1423, align 8
  %tobool419.not = icmp eq i8 %171, 0
  br i1 %tobool419.not, label %land.lhs.true1439, label %if.then420

if.then420:                                       ; preds = %sw.bb417
  %172 = load i8, ptr %m_declAttributeIsCdata422, align 8
  %minBytesPerChar423 = getelementptr inbounds %struct.encoding, ptr %enc.addr.0, i64 0, i32 12
  %173 = load i32, ptr %minBytesPerChar423, align 8
  %idx.ext424 = sext i32 %173 to i64
  %add.ptr425 = getelementptr i8, ptr %s.addr.0, i64 %idx.ext424
  %174 = load ptr, ptr %next.addr, align 8
  %idx.neg428 = sub nsw i64 0, %idx.ext424
  %add.ptr429 = getelementptr i8, ptr %174, i64 %idx.neg428
  %call.i862 = call fastcc i32 @appendAttributeValue(ptr noundef %parser, ptr noundef %enc.addr.0, i8 noundef zeroext %172, ptr noundef %add.ptr425, ptr noundef %add.ptr429, ptr noundef nonnull %pool1126, i32 noundef 2), !range !32
  %tobool.not.i863 = icmp eq i32 %call.i862, 0
  br i1 %tobool.not.i863, label %if.end.i865, label %return

if.end.i865:                                      ; preds = %if.then420
  %tobool1.not.i866 = icmp eq i8 %172, 0
  %175 = load ptr, ptr %ptr1.i.i1188, align 8
  br i1 %tobool1.not.i866, label %land.lhs.true.i869, label %if.end9.i

land.lhs.true.i869:                               ; preds = %if.end.i865
  %176 = load ptr, ptr %start.i.i1202, align 8
  %tobool3.not.i871 = icmp eq ptr %175, %176
  br i1 %tobool3.not.i871, label %if.end9.i, label %land.lhs.true4.i

land.lhs.true4.i:                                 ; preds = %land.lhs.true.i869
  %arrayidx.i872 = getelementptr i8, ptr %175, i64 -1
  %177 = load i8, ptr %arrayidx.i872, align 1
  %cmp.i873 = icmp eq i8 %177, 32
  br i1 %cmp.i873, label %if.then7.i, label %if.end9.i

if.then7.i:                                       ; preds = %land.lhs.true4.i
  store ptr %arrayidx.i872, ptr %ptr1.i.i1188, align 8
  br label %if.end9.i

if.end9.i:                                        ; preds = %if.then7.i, %land.lhs.true4.i, %land.lhs.true.i869, %if.end.i865
  %178 = phi ptr [ %arrayidx.i872, %if.then7.i ], [ %175, %land.lhs.true4.i ], [ %175, %land.lhs.true.i869 ], [ %175, %if.end.i865 ]
  %179 = load ptr, ptr %end4.i.i1192, align 8
  %cmp12.i867 = icmp eq ptr %178, %179
  br i1 %cmp12.i867, label %land.lhs.true14.i, label %if.end434

land.lhs.true14.i:                                ; preds = %if.end9.i
  %call15.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool1126), !range !13
  %tobool16.not.i = icmp eq i8 %call15.i, 0
  br i1 %tobool16.not.i, label %return, label %land.lhs.true14.cond.false_crit_edge.i

land.lhs.true14.cond.false_crit_edge.i:           ; preds = %land.lhs.true14.i
  %.pre11.i = load ptr, ptr %ptr1.i.i1188, align 8
  br label %if.end434

if.end434:                                        ; preds = %land.lhs.true14.cond.false_crit_edge.i, %if.end9.i
  %180 = phi ptr [ %.pre11.i, %land.lhs.true14.cond.false_crit_edge.i ], [ %178, %if.end9.i ]
  %incdec.ptr18.i = getelementptr i8, ptr %180, i64 1
  store ptr %incdec.ptr18.i, ptr %ptr1.i.i1188, align 8
  store i8 0, ptr %180, align 1
  %181 = load ptr, ptr %start.i.i1202, align 8
  %182 = load ptr, ptr %ptr1.i.i1188, align 8
  store ptr %182, ptr %start.i.i1202, align 8
  %183 = load ptr, ptr %m_declElementType1383, align 8
  %184 = load ptr, ptr %m_declAttributeId442, align 8
  %185 = load i8, ptr %m_declAttributeIsCdata422, align 8
  %tobool.i = icmp ne ptr %181, null
  %nDefaultAtts.i = getelementptr inbounds %struct.ELEMENT_TYPE, ptr %183, i64 0, i32 3
  %186 = load i32, ptr %nDefaultAtts.i, align 8
  %cmp34.i = icmp sgt i32 %186, 0
  %or.cond1365 = select i1 %tobool.i, i1 %cmp34.i, i1 false
  br i1 %or.cond1365, label %for.body.lr.ph.i, label %if.end14.i

for.body.lr.ph.i:                                 ; preds = %if.end434
  %defaultAtts.i = getelementptr inbounds %struct.ELEMENT_TYPE, ptr %183, i64 0, i32 5
  %187 = load ptr, ptr %defaultAtts.i, align 8
  %wide.trip.count.i = zext nneg i32 %186 to i64
  br label %for.body.i878

for.cond.i880:                                    ; preds = %for.body.i878
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next.i, %wide.trip.count.i
  br i1 %exitcond.not.i, label %if.end14.i, label %for.body.i878, !llvm.loop !35

for.body.i878:                                    ; preds = %for.cond.i880, %for.body.lr.ph.i
  %indvars.iv.i = phi i64 [ 0, %for.body.lr.ph.i ], [ %indvars.iv.next.i, %for.cond.i880 ]
  %arrayidx.i879 = getelementptr %struct.DEFAULT_ATTRIBUTE, ptr %187, i64 %indvars.iv.i
  %188 = load ptr, ptr %arrayidx.i879, align 8
  %cmp3.i = icmp eq ptr %188, %184
  br i1 %cmp3.i, label %if.end447, label %for.cond.i880

if.end14.i:                                       ; preds = %for.cond.i880, %if.end434
  %allocDefaultAtts.i = getelementptr inbounds %struct.ELEMENT_TYPE, ptr %183, i64 0, i32 4
  %189 = load i32, ptr %allocDefaultAtts.i, align 4
  %cmp16.i = icmp eq i32 %186, %189
  br i1 %cmp16.i, label %if.then18.i, label %if.end14.if.end51_crit_edge.i

if.end14.if.end51_crit_edge.i:                    ; preds = %if.end14.i
  %defaultAtts52.phi.trans.insert.i = getelementptr inbounds %struct.ELEMENT_TYPE, ptr %183, i64 0, i32 5
  %.pre37.i = load ptr, ptr %defaultAtts52.phi.trans.insert.i, align 8
  br label %if.end51.i

if.then18.i:                                      ; preds = %if.end14.i
  %cmp20.i = icmp eq i32 %186, 0
  br i1 %cmp20.i, label %if.then22.i, label %if.else.i875

if.then22.i:                                      ; preds = %if.then18.i
  store i32 8, ptr %allocDefaultAtts.i, align 4
  %190 = load ptr, ptr %3, align 8
  %call.i876 = call ptr %190(i64 noundef 192) #24
  %defaultAtts26.i = getelementptr inbounds %struct.ELEMENT_TYPE, ptr %183, i64 0, i32 5
  store ptr %call.i876, ptr %defaultAtts26.i, align 8
  %tobool28.not.i = icmp eq ptr %call.i876, null
  br i1 %tobool28.not.i, label %if.then29.i, label %if.end51.i

if.then29.i:                                      ; preds = %if.then22.i
  store i32 0, ptr %allocDefaultAtts.i, align 4
  br label %return

if.else.i875:                                     ; preds = %if.then18.i
  %cmp33.i = icmp sgt i32 %186, 1073741823
  br i1 %cmp33.i, label %return, label %if.end36.i

if.end36.i:                                       ; preds = %if.else.i875
  %mul38.i = shl i32 %186, 1
  %191 = load ptr, ptr %realloc_fcn, align 8
  %defaultAtts40.i = getelementptr inbounds %struct.ELEMENT_TYPE, ptr %183, i64 0, i32 5
  %192 = load ptr, ptr %defaultAtts40.i, align 8
  %conv41.i = sext i32 %mul38.i to i64
  %mul42.i = mul nsw i64 %conv41.i, 24
  %call43.i = call ptr %191(ptr noundef %192, i64 noundef %mul42.i) #24
  %cmp44.i = icmp eq ptr %call43.i, null
  br i1 %cmp44.i, label %return, label %if.end47.i

if.end47.i:                                       ; preds = %if.end36.i
  store i32 %mul38.i, ptr %allocDefaultAtts.i, align 4
  store ptr %call43.i, ptr %defaultAtts40.i, align 8
  br label %if.end51.i

if.end51.i:                                       ; preds = %if.end47.i, %if.then22.i, %if.end14.if.end51_crit_edge.i
  %193 = phi ptr [ %.pre37.i, %if.end14.if.end51_crit_edge.i ], [ %call43.i, %if.end47.i ], [ %call.i876, %if.then22.i ]
  %194 = load i32, ptr %nDefaultAtts.i, align 8
  %idx.ext.i = sext i32 %194 to i64
  %add.ptr.i = getelementptr %struct.DEFAULT_ATTRIBUTE, ptr %193, i64 %idx.ext.i
  store ptr %184, ptr %add.ptr.i, align 8
  %value55.i = getelementptr %struct.DEFAULT_ATTRIBUTE, ptr %193, i64 %idx.ext.i, i32 2
  store ptr %181, ptr %value55.i, align 8
  %isCdata56.i = getelementptr %struct.DEFAULT_ATTRIBUTE, ptr %193, i64 %idx.ext.i, i32 1
  store i8 %185, ptr %isCdata56.i, align 8
  %tobool57.not.i = icmp eq i8 %185, 0
  br i1 %tobool57.not.i, label %if.then58.i, label %if.end59.i

if.then58.i:                                      ; preds = %if.end51.i
  %maybeTokenized.i = getelementptr inbounds %struct.attribute_id, ptr %184, i64 0, i32 2
  store i8 1, ptr %maybeTokenized.i, align 8
  br label %if.end59.i

if.end59.i:                                       ; preds = %if.then58.i, %if.end51.i
  %195 = load i32, ptr %nDefaultAtts.i, align 8
  %add.i = add i32 %195, 1
  store i32 %add.i, ptr %nDefaultAtts.i, align 8
  br label %if.end447

if.end447:                                        ; preds = %for.body.i878, %if.end59.i
  %196 = load ptr, ptr %m_attlistDeclHandler1427, align 8
  %tobool449.not = icmp eq ptr %196, null
  br i1 %tobool449.not, label %land.lhs.true1439, label %land.lhs.true450

land.lhs.true450:                                 ; preds = %if.end447
  %197 = load ptr, ptr %m_declAttributeType451, align 8
  %tobool452.not = icmp eq ptr %197, null
  br i1 %tobool452.not, label %land.lhs.true1439, label %if.then453

if.then453:                                       ; preds = %land.lhs.true450
  %198 = load i8, ptr %197, align 1
  switch i8 %198, label %if.end510 [
    i8 40, label %if.then469
    i8 78, label %land.lhs.true463
  ]

land.lhs.true463:                                 ; preds = %if.then453
  %arrayidx465 = getelementptr i8, ptr %197, i64 1
  %199 = load i8, ptr %arrayidx465, align 1
  %cmp467 = icmp eq i8 %199, 79
  br i1 %cmp467, label %if.then469, label %if.end510

if.then469:                                       ; preds = %if.then453, %land.lhs.true463
  %200 = load ptr, ptr %ptr1.i.i1128, align 8
  %201 = load ptr, ptr %end.i1176, align 8
  %cmp474 = icmp eq ptr %200, %201
  br i1 %cmp474, label %land.lhs.true476, label %cond.false481

land.lhs.true476:                                 ; preds = %if.then469
  %call478 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool949), !range !13
  %tobool479.not = icmp eq i8 %call478, 0
  br i1 %tobool479.not, label %return, label %land.lhs.true476.cond.false481_crit_edge

land.lhs.true476.cond.false481_crit_edge:         ; preds = %land.lhs.true476
  %.pre1705 = load ptr, ptr %ptr1.i.i1128, align 8
  br label %cond.false481

cond.false481:                                    ; preds = %land.lhs.true476.cond.false481_crit_edge, %if.then469
  %202 = phi ptr [ %.pre1705, %land.lhs.true476.cond.false481_crit_edge ], [ %200, %if.then469 ]
  %incdec.ptr484 = getelementptr i8, ptr %202, i64 1
  store ptr %incdec.ptr484, ptr %ptr1.i.i1128, align 8
  store i8 41, ptr %202, align 1
  %203 = load ptr, ptr %ptr1.i.i1128, align 8
  %204 = load ptr, ptr %end.i1176, align 8
  %cmp490 = icmp eq ptr %203, %204
  br i1 %cmp490, label %land.lhs.true492, label %cond.false497

land.lhs.true492:                                 ; preds = %cond.false481
  %call494 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool949), !range !13
  %tobool495.not = icmp eq i8 %call494, 0
  br i1 %tobool495.not, label %return, label %land.lhs.true492.cond.false497_crit_edge

land.lhs.true492.cond.false497_crit_edge:         ; preds = %land.lhs.true492
  %.pre1706 = load ptr, ptr %ptr1.i.i1128, align 8
  br label %cond.false497

cond.false497:                                    ; preds = %land.lhs.true492.cond.false497_crit_edge, %cond.false481
  %205 = phi ptr [ %.pre1706, %land.lhs.true492.cond.false497_crit_edge ], [ %203, %cond.false481 ]
  %incdec.ptr500 = getelementptr i8, ptr %205, i64 1
  store ptr %incdec.ptr500, ptr %ptr1.i.i1128, align 8
  store i8 0, ptr %205, align 1
  %206 = load ptr, ptr %start.i.i1142, align 8
  store ptr %206, ptr %m_declAttributeType451, align 8
  %207 = load ptr, ptr %ptr1.i.i1128, align 8
  store ptr %207, ptr %start.i.i1142, align 8
  br label %if.end510

if.end510:                                        ; preds = %if.then453, %cond.false497, %land.lhs.true463
  store ptr %s.addr.0, ptr %eventEndPP.0, align 8
  %208 = load ptr, ptr %m_attlistDeclHandler1427, align 8
  %209 = load ptr, ptr %m_handlerArg1382, align 8
  %210 = load ptr, ptr %m_declElementType1383, align 8
  %211 = load ptr, ptr %210, align 8
  %212 = load ptr, ptr %m_declAttributeId442, align 8
  %213 = load ptr, ptr %212, align 8
  %214 = load ptr, ptr %m_declAttributeType451, align 8
  %cmp518 = icmp eq i32 %call37, 38
  %conv519 = zext i1 %cmp518 to i32
  call void %208(ptr noundef %209, ptr noundef %211, ptr noundef %213, ptr noundef %214, ptr noundef %181, i32 noundef %conv519) #24
  %215 = load ptr, ptr %freeBlocks.i1168, align 8
  %tobool.not.i882 = icmp eq ptr %215, null
  %216 = load ptr, ptr %m_tempPool949, align 8
  br i1 %tobool.not.i882, label %if.then.i890, label %if.else.i883

if.then.i890:                                     ; preds = %if.end510
  store ptr %216, ptr %freeBlocks.i1168, align 8
  br label %poolClear.exit891

if.else.i883:                                     ; preds = %if.end510
  %tobool3.not13.i884 = icmp eq ptr %216, null
  br i1 %tobool3.not13.i884, label %poolClear.exit891, label %while.body.i885

while.body.i885:                                  ; preds = %if.else.i883, %while.body.i885
  %217 = phi ptr [ %p.014.i886, %while.body.i885 ], [ %215, %if.else.i883 ]
  %p.014.i886 = phi ptr [ %218, %while.body.i885 ], [ %216, %if.else.i883 ]
  %218 = load ptr, ptr %p.014.i886, align 8
  store ptr %217, ptr %p.014.i886, align 8
  store ptr %p.014.i886, ptr %freeBlocks.i1168, align 8
  %tobool3.not.i887 = icmp eq ptr %218, null
  br i1 %tobool3.not.i887, label %poolClear.exit891, label %while.body.i885, !llvm.loop !8

poolClear.exit891:                                ; preds = %while.body.i885, %if.then.i890, %if.else.i883
  store ptr null, ptr %m_tempPool949, align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %end.i1176, i8 0, i64 24, i1 false)
  br label %if.end1443

sw.bb523:                                         ; preds = %sw.epilog44
  %219 = load i8, ptr %keepProcessing1423, align 8
  %tobool525.not = icmp eq i8 %219, 0
  br i1 %tobool525.not, label %land.lhs.true1439, label %if.then526

if.then526:                                       ; preds = %sw.bb523
  %minBytesPerChar528 = getelementptr inbounds %struct.encoding, ptr %enc.addr.0, i64 0, i32 12
  %220 = load i32, ptr %minBytesPerChar528, align 8
  %idx.ext529 = sext i32 %220 to i64
  %add.ptr530 = getelementptr i8, ptr %s.addr.0, i64 %idx.ext529
  %221 = load ptr, ptr %next.addr, align 8
  %idx.neg533 = sub nsw i64 0, %idx.ext529
  %add.ptr534 = getelementptr i8, ptr %221, i64 %idx.neg533
  %call535 = call fastcc i32 @storeEntityValue(ptr noundef %parser, ptr noundef %enc.addr.0, ptr noundef %add.ptr530, ptr noundef %add.ptr534, i32 noundef 2)
  %222 = load ptr, ptr %m_declEntity819, align 8
  %tobool537.not = icmp eq ptr %222, null
  %223 = load ptr, ptr %start539, align 8
  br i1 %tobool537.not, label %if.else566, label %if.then538

if.then538:                                       ; preds = %if.then526
  %textPtr = getelementptr inbounds %struct.ENTITY, ptr %222, i64 0, i32 1
  store ptr %223, ptr %textPtr, align 8
  %224 = load ptr, ptr %ptr542, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %224 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %223 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv545 = trunc i64 %sub.ptr.sub to i32
  %225 = load ptr, ptr %m_declEntity819, align 8
  %textLen = getelementptr inbounds %struct.ENTITY, ptr %225, i64 0, i32 2
  store i32 %conv545, ptr %textLen, align 8
  %226 = load ptr, ptr %ptr542, align 8
  store ptr %226, ptr %start539, align 8
  %227 = load ptr, ptr %m_entityDeclHandler1413, align 8
  %tobool552.not = icmp eq ptr %227, null
  br i1 %tobool552.not, label %if.end571, label %if.then553

if.then553:                                       ; preds = %if.then538
  store ptr %s.addr.0, ptr %eventEndPP.0, align 8
  %228 = load ptr, ptr %m_entityDeclHandler1413, align 8
  %229 = load ptr, ptr %m_handlerArg1382, align 8
  %230 = load ptr, ptr %m_declEntity819, align 8
  %231 = load ptr, ptr %230, align 8
  %is_param = getelementptr inbounds %struct.ENTITY, ptr %230, i64 0, i32 9
  %232 = load i8, ptr %is_param, align 1
  %conv559 = zext i8 %232 to i32
  %textPtr561 = getelementptr inbounds %struct.ENTITY, ptr %230, i64 0, i32 1
  %233 = load ptr, ptr %textPtr561, align 8
  %textLen563 = getelementptr inbounds %struct.ENTITY, ptr %230, i64 0, i32 2
  %234 = load i32, ptr %textLen563, align 8
  %235 = load ptr, ptr %m_curBase946, align 8
  call void %228(ptr noundef %229, ptr noundef %231, i32 noundef %conv559, ptr noundef %233, i32 noundef %234, ptr noundef %235, ptr noundef null, ptr noundef null, ptr noundef null) #24
  br label %if.end571

if.else566:                                       ; preds = %if.then526
  store ptr %223, ptr %ptr542, align 8
  br label %if.end571

if.end571:                                        ; preds = %if.then538, %if.then553, %if.else566
  %handleDefault.4 = phi i8 [ 0, %if.then553 ], [ 1, %if.then538 ], [ 1, %if.else566 ]
  %cmp572.not = icmp eq i32 %call535, 0
  br i1 %cmp572.not, label %sw.epilog1436, label %return

sw.bb577:                                         ; preds = %sw.epilog44
  store i8 0, ptr %m_useForeignDTD578, align 1
  store i8 1, ptr %hasParamEntityRefs1117, align 1
  %236 = load ptr, ptr %m_startDoctypeDeclHandler1404, align 8
  %tobool581.not = icmp eq ptr %236, null
  br i1 %tobool581.not, label %if.else602, label %if.then582

if.then582:                                       ; preds = %sw.bb577
  %minBytesPerChar584 = getelementptr inbounds %struct.encoding, ptr %enc.addr.0, i64 0, i32 12
  %237 = load i32, ptr %minBytesPerChar584, align 8
  %idx.ext585 = sext i32 %237 to i64
  %add.ptr586 = getelementptr i8, ptr %s.addr.0, i64 %idx.ext585
  %238 = load ptr, ptr %next.addr, align 8
  %idx.neg589 = sub nsw i64 0, %idx.ext585
  %add.ptr590 = getelementptr i8, ptr %238, i64 %idx.neg589
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ptr.addr.i.i892)
  store ptr %add.ptr586, ptr %ptr.addr.i.i892, align 8
  %239 = load ptr, ptr %ptr1.i.i1128, align 8
  %tobool.not.i.i894 = icmp eq ptr %239, null
  br i1 %tobool.not.i.i894, label %land.lhs.true.i.i918, label %if.end.i.i895

land.lhs.true.i.i918:                             ; preds = %if.then582
  %call.i.i919 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool949), !range !13
  %tobool2.not.i.i920 = icmp eq i8 %call.i.i919, 0
  br i1 %tobool2.not.i.i920, label %poolAppend.exit.thread.i904, label %if.end.i.i895

if.end.i.i895:                                    ; preds = %land.lhs.true.i.i918, %if.then582
  %utf8Convert.i.i896 = getelementptr inbounds %struct.encoding, ptr %enc.addr.0, i64 0, i32 10
  br label %for.cond.i.i898

for.cond.i.i898:                                  ; preds = %if.end8.i.i901, %if.end.i.i895
  %240 = load ptr, ptr %utf8Convert.i.i896, align 8
  %241 = load ptr, ptr %end.i1176, align 8
  %call5.i.i899 = call i32 %240(ptr noundef nonnull %enc.addr.0, ptr noundef nonnull %ptr.addr.i.i892, ptr noundef %add.ptr590, ptr noundef nonnull %ptr1.i.i1128, ptr noundef %241) #24
  %or.cond.i.i900 = icmp ult i32 %call5.i.i899, 2
  br i1 %or.cond.i.i900, label %poolAppend.exit.i906, label %if.end8.i.i901

if.end8.i.i901:                                   ; preds = %for.cond.i.i898
  %call9.i.i902 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool949), !range !13
  %tobool10.not.i.i903 = icmp eq i8 %call9.i.i902, 0
  br i1 %tobool10.not.i.i903, label %poolAppend.exit.thread.i904, label %for.cond.i.i898

poolAppend.exit.thread.i904:                      ; preds = %land.lhs.true.i.i918, %if.end8.i.i901
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i892)
  br label %poolStoreString.exit921.thread

poolAppend.exit.i906:                             ; preds = %for.cond.i.i898
  %242 = load ptr, ptr %start.i.i1142, align 8
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i892)
  %tobool.not.i908 = icmp eq ptr %242, null
  br i1 %tobool.not.i908, label %poolStoreString.exit921.thread, label %if.end.i909

if.end.i909:                                      ; preds = %poolAppend.exit.i906
  %243 = load ptr, ptr %ptr1.i.i1128, align 8
  %244 = load ptr, ptr %end.i1176, align 8
  %cmp.i910 = icmp eq ptr %243, %244
  br i1 %cmp.i910, label %land.lhs.true.i913, label %poolStoreString.exit921

land.lhs.true.i913:                               ; preds = %if.end.i909
  %call3.i914 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool949), !range !13
  %tobool4.not.i915 = icmp eq i8 %call3.i914, 0
  br i1 %tobool4.not.i915, label %poolStoreString.exit921.thread, label %land.lhs.true.if.end6_crit_edge.i916

land.lhs.true.if.end6_crit_edge.i916:             ; preds = %land.lhs.true.i913
  %.pre.i917 = load ptr, ptr %ptr1.i.i1128, align 8
  br label %poolStoreString.exit921

poolStoreString.exit921.thread:                   ; preds = %poolAppend.exit.i906, %land.lhs.true.i913, %poolAppend.exit.thread.i904
  store ptr null, ptr %m_doctypeSysid592, align 8
  br label %return

poolStoreString.exit921:                          ; preds = %if.end.i909, %land.lhs.true.if.end6_crit_edge.i916
  %245 = phi ptr [ %.pre.i917, %land.lhs.true.if.end6_crit_edge.i916 ], [ %243, %if.end.i909 ]
  %incdec.ptr.i912 = getelementptr i8, ptr %245, i64 1
  store ptr %incdec.ptr.i912, ptr %ptr1.i.i1128, align 8
  store i8 0, ptr %245, align 1
  %246 = load ptr, ptr %start.i.i1142, align 8
  store ptr %246, ptr %m_doctypeSysid592, align 8
  %cmp594 = icmp eq ptr %246, null
  br i1 %cmp594, label %return, label %if.end597

if.end597:                                        ; preds = %poolStoreString.exit921
  %247 = load ptr, ptr %ptr1.i.i1128, align 8
  store ptr %247, ptr %start.i.i1142, align 8
  br label %if.end604

if.else602:                                       ; preds = %sw.bb577
  store ptr @.str.86, ptr %m_doctypeSysid592, align 8
  br label %if.end604

if.end604:                                        ; preds = %if.else602, %if.end597
  %handleDefault.5 = phi i8 [ 0, %if.end597 ], [ 1, %if.else602 ]
  %248 = load i8, ptr %standalone1147, align 2
  %tobool606.not = icmp eq i8 %248, 0
  br i1 %tobool606.not, label %land.lhs.true607, label %if.end619

land.lhs.true607:                                 ; preds = %if.end604
  %249 = load i32, ptr %m_paramEntityParsing1118, align 4
  %tobool609.not = icmp eq i32 %249, 0
  br i1 %tobool609.not, label %land.lhs.true610, label %if.end619

land.lhs.true610:                                 ; preds = %land.lhs.true607
  %250 = load ptr, ptr %m_notStandaloneHandler1228, align 8
  %tobool612.not = icmp eq ptr %250, null
  br i1 %tobool612.not, label %if.end619, label %land.lhs.true613

land.lhs.true613:                                 ; preds = %land.lhs.true610
  %251 = load ptr, ptr %m_handlerArg1382, align 8
  %call616 = call i32 %250(ptr noundef %251) #24
  %tobool617.not = icmp eq i32 %call616, 0
  br i1 %tobool617.not, label %return, label %if.end619

if.end619:                                        ; preds = %land.lhs.true613, %land.lhs.true610, %land.lhs.true607, %if.end604
  %252 = load ptr, ptr %m_declEntity819, align 8
  %tobool621.not = icmp eq ptr %252, null
  br i1 %tobool621.not, label %if.then622, label %sw.bb633

if.then622:                                       ; preds = %if.end619
  %call624 = call fastcc ptr @lookup(ptr noundef nonnull %parser, ptr noundef nonnull %paramEntities1138, ptr noundef nonnull @.str.86, i64 noundef 64)
  store ptr %call624, ptr %m_declEntity819, align 8
  %tobool627.not = icmp eq ptr %call624, null
  br i1 %tobool627.not, label %return, label %if.end629

if.end629:                                        ; preds = %if.then622
  %publicId631 = getelementptr inbounds %struct.ENTITY, ptr %call624, i64 0, i32 6
  store ptr null, ptr %publicId631, align 8
  br label %sw.bb633

sw.bb633:                                         ; preds = %if.end619, %if.end629, %sw.epilog44
  %handleDefault.6 = phi i8 [ 1, %sw.epilog44 ], [ %handleDefault.5, %if.end619 ], [ %handleDefault.5, %if.end629 ]
  %253 = load i8, ptr %keepProcessing1423, align 8
  %tobool636.not = icmp eq i8 %253, 0
  br i1 %tobool636.not, label %sw.epilog1436, label %land.lhs.true637

land.lhs.true637:                                 ; preds = %sw.bb633
  %254 = load ptr, ptr %m_declEntity819, align 8
  %tobool639.not = icmp eq ptr %254, null
  br i1 %tobool639.not, label %sw.epilog1436, label %if.then640

if.then640:                                       ; preds = %land.lhs.true637
  %minBytesPerChar642 = getelementptr inbounds %struct.encoding, ptr %enc.addr.0, i64 0, i32 12
  %255 = load i32, ptr %minBytesPerChar642, align 8
  %idx.ext643 = sext i32 %255 to i64
  %add.ptr644 = getelementptr i8, ptr %s.addr.0, i64 %idx.ext643
  %256 = load ptr, ptr %next.addr, align 8
  %idx.neg647 = sub nsw i64 0, %idx.ext643
  %add.ptr648 = getelementptr i8, ptr %256, i64 %idx.neg647
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ptr.addr.i.i922)
  store ptr %add.ptr644, ptr %ptr.addr.i.i922, align 8
  %257 = load ptr, ptr %ptr1.i.i1188, align 8
  %tobool.not.i.i924 = icmp eq ptr %257, null
  br i1 %tobool.not.i.i924, label %land.lhs.true.i.i948, label %if.end.i.i925

land.lhs.true.i.i948:                             ; preds = %if.then640
  %call.i.i949 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool1126), !range !13
  %tobool2.not.i.i950 = icmp eq i8 %call.i.i949, 0
  br i1 %tobool2.not.i.i950, label %poolAppend.exit.thread.i934, label %if.end.i.i925

if.end.i.i925:                                    ; preds = %land.lhs.true.i.i948, %if.then640
  %utf8Convert.i.i926 = getelementptr inbounds %struct.encoding, ptr %enc.addr.0, i64 0, i32 10
  br label %for.cond.i.i928

for.cond.i.i928:                                  ; preds = %if.end8.i.i931, %if.end.i.i925
  %258 = load ptr, ptr %utf8Convert.i.i926, align 8
  %259 = load ptr, ptr %end4.i.i1192, align 8
  %call5.i.i929 = call i32 %258(ptr noundef nonnull %enc.addr.0, ptr noundef nonnull %ptr.addr.i.i922, ptr noundef %add.ptr648, ptr noundef nonnull %ptr1.i.i1188, ptr noundef %259) #24
  %or.cond.i.i930 = icmp ult i32 %call5.i.i929, 2
  br i1 %or.cond.i.i930, label %poolAppend.exit.i936, label %if.end8.i.i931

if.end8.i.i931:                                   ; preds = %for.cond.i.i928
  %call9.i.i932 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool1126), !range !13
  %tobool10.not.i.i933 = icmp eq i8 %call9.i.i932, 0
  br i1 %tobool10.not.i.i933, label %poolAppend.exit.thread.i934, label %for.cond.i.i928

poolAppend.exit.thread.i934:                      ; preds = %if.end8.i.i931, %land.lhs.true.i.i948
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i922)
  br label %poolStoreString.exit951

poolAppend.exit.i936:                             ; preds = %for.cond.i.i928
  %260 = load ptr, ptr %start.i.i1202, align 8
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i922)
  %tobool.not.i938 = icmp eq ptr %260, null
  br i1 %tobool.not.i938, label %poolStoreString.exit951, label %if.end.i939

if.end.i939:                                      ; preds = %poolAppend.exit.i936
  %261 = load ptr, ptr %ptr1.i.i1188, align 8
  %262 = load ptr, ptr %end4.i.i1192, align 8
  %cmp.i940 = icmp eq ptr %261, %262
  br i1 %cmp.i940, label %land.lhs.true.i943, label %if.end6.i941

land.lhs.true.i943:                               ; preds = %if.end.i939
  %call3.i944 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool1126), !range !13
  %tobool4.not.i945 = icmp eq i8 %call3.i944, 0
  br i1 %tobool4.not.i945, label %poolStoreString.exit951, label %land.lhs.true.if.end6_crit_edge.i946

land.lhs.true.if.end6_crit_edge.i946:             ; preds = %land.lhs.true.i943
  %.pre.i947 = load ptr, ptr %ptr1.i.i1188, align 8
  br label %if.end6.i941

if.end6.i941:                                     ; preds = %land.lhs.true.if.end6_crit_edge.i946, %if.end.i939
  %263 = phi ptr [ %.pre.i947, %land.lhs.true.if.end6_crit_edge.i946 ], [ %261, %if.end.i939 ]
  %incdec.ptr.i942 = getelementptr i8, ptr %263, i64 1
  store ptr %incdec.ptr.i942, ptr %ptr1.i.i1188, align 8
  store i8 0, ptr %263, align 1
  %264 = load ptr, ptr %start.i.i1202, align 8
  br label %poolStoreString.exit951

poolStoreString.exit951:                          ; preds = %poolAppend.exit.thread.i934, %poolAppend.exit.i936, %land.lhs.true.i943, %if.end6.i941
  %retval.0.i935 = phi ptr [ %264, %if.end6.i941 ], [ null, %poolAppend.exit.i936 ], [ null, %land.lhs.true.i943 ], [ null, %poolAppend.exit.thread.i934 ]
  %265 = load ptr, ptr %m_declEntity819, align 8
  %systemId651 = getelementptr inbounds %struct.ENTITY, ptr %265, i64 0, i32 4
  store ptr %retval.0.i935, ptr %systemId651, align 8
  %266 = load ptr, ptr %m_declEntity819, align 8
  %systemId653 = getelementptr inbounds %struct.ENTITY, ptr %266, i64 0, i32 4
  %267 = load ptr, ptr %systemId653, align 8
  %tobool654.not = icmp eq ptr %267, null
  br i1 %tobool654.not, label %return, label %if.end656

if.end656:                                        ; preds = %poolStoreString.exit951
  %268 = load ptr, ptr %m_curBase946, align 8
  %base659 = getelementptr inbounds %struct.ENTITY, ptr %266, i64 0, i32 5
  store ptr %268, ptr %base659, align 8
  %269 = load ptr, ptr %ptr1.i.i1188, align 8
  store ptr %269, ptr %start.i.i1202, align 8
  %270 = load ptr, ptr %m_entityDeclHandler1413, align 8
  %tobool665 = icmp ne ptr %270, null
  %cmp667 = icmp eq i32 %call37, 13
  %or.cond3 = and i1 %cmp667, %tobool665
  br i1 %or.cond3, label %if.end1443, label %sw.epilog1436

sw.bb672:                                         ; preds = %sw.epilog44
  %271 = load i8, ptr %keepProcessing1423, align 8
  %tobool675.not = icmp eq i8 %271, 0
  br i1 %tobool675.not, label %land.lhs.true1439, label %land.lhs.true676

land.lhs.true676:                                 ; preds = %sw.bb672
  %272 = load ptr, ptr %m_declEntity819, align 8
  %tobool678.not = icmp eq ptr %272, null
  br i1 %tobool678.not, label %land.lhs.true1439, label %land.lhs.true679

land.lhs.true679:                                 ; preds = %land.lhs.true676
  %273 = load ptr, ptr %m_entityDeclHandler1413, align 8
  %tobool681.not = icmp eq ptr %273, null
  br i1 %tobool681.not, label %land.lhs.true1439, label %if.then682

if.then682:                                       ; preds = %land.lhs.true679
  store ptr %s.addr.0, ptr %eventEndPP.0, align 8
  %274 = load ptr, ptr %m_entityDeclHandler1413, align 8
  %275 = load ptr, ptr %m_handlerArg1382, align 8
  %276 = load ptr, ptr %m_declEntity819, align 8
  %277 = load ptr, ptr %276, align 8
  %is_param688 = getelementptr inbounds %struct.ENTITY, ptr %276, i64 0, i32 9
  %278 = load i8, ptr %is_param688, align 1
  %conv689 = zext i8 %278 to i32
  %base691 = getelementptr inbounds %struct.ENTITY, ptr %276, i64 0, i32 5
  %279 = load ptr, ptr %base691, align 8
  %systemId693 = getelementptr inbounds %struct.ENTITY, ptr %276, i64 0, i32 4
  %280 = load ptr, ptr %systemId693, align 8
  %publicId695 = getelementptr inbounds %struct.ENTITY, ptr %276, i64 0, i32 6
  %281 = load ptr, ptr %publicId695, align 8
  call void %274(ptr noundef %275, ptr noundef %277, i32 noundef %conv689, ptr noundef null, i32 noundef 0, ptr noundef %279, ptr noundef %280, ptr noundef %281, ptr noundef null) #24
  br label %if.end1443

sw.bb697:                                         ; preds = %sw.epilog44
  %282 = load i8, ptr %keepProcessing1423, align 8
  %tobool700.not = icmp eq i8 %282, 0
  br i1 %tobool700.not, label %land.lhs.true1439, label %land.lhs.true701

land.lhs.true701:                                 ; preds = %sw.bb697
  %283 = load ptr, ptr %m_declEntity819, align 8
  %tobool703.not = icmp eq ptr %283, null
  br i1 %tobool703.not, label %land.lhs.true1439, label %if.then704

if.then704:                                       ; preds = %land.lhs.true701
  %284 = load ptr, ptr %next.addr, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ptr.addr.i.i952)
  store ptr %s.addr.0, ptr %ptr.addr.i.i952, align 8
  %285 = load ptr, ptr %ptr1.i.i1188, align 8
  %tobool.not.i.i954 = icmp eq ptr %285, null
  br i1 %tobool.not.i.i954, label %land.lhs.true.i.i978, label %if.end.i.i955

land.lhs.true.i.i978:                             ; preds = %if.then704
  %call.i.i979 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool1126), !range !13
  %tobool2.not.i.i980 = icmp eq i8 %call.i.i979, 0
  br i1 %tobool2.not.i.i980, label %poolAppend.exit.thread.i964, label %if.end.i.i955

if.end.i.i955:                                    ; preds = %land.lhs.true.i.i978, %if.then704
  %utf8Convert.i.i956 = getelementptr inbounds %struct.encoding, ptr %enc.addr.0, i64 0, i32 10
  br label %for.cond.i.i958

for.cond.i.i958:                                  ; preds = %if.end8.i.i961, %if.end.i.i955
  %286 = load ptr, ptr %utf8Convert.i.i956, align 8
  %287 = load ptr, ptr %end4.i.i1192, align 8
  %call5.i.i959 = call i32 %286(ptr noundef %enc.addr.0, ptr noundef nonnull %ptr.addr.i.i952, ptr noundef %284, ptr noundef nonnull %ptr1.i.i1188, ptr noundef %287) #24
  %or.cond.i.i960 = icmp ult i32 %call5.i.i959, 2
  br i1 %or.cond.i.i960, label %poolAppend.exit.i966, label %if.end8.i.i961

if.end8.i.i961:                                   ; preds = %for.cond.i.i958
  %call9.i.i962 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool1126), !range !13
  %tobool10.not.i.i963 = icmp eq i8 %call9.i.i962, 0
  br i1 %tobool10.not.i.i963, label %poolAppend.exit.thread.i964, label %for.cond.i.i958

poolAppend.exit.thread.i964:                      ; preds = %if.end8.i.i961, %land.lhs.true.i.i978
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i952)
  br label %poolStoreString.exit981

poolAppend.exit.i966:                             ; preds = %for.cond.i.i958
  %288 = load ptr, ptr %start.i.i1202, align 8
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i952)
  %tobool.not.i968 = icmp eq ptr %288, null
  br i1 %tobool.not.i968, label %poolStoreString.exit981, label %if.end.i969

if.end.i969:                                      ; preds = %poolAppend.exit.i966
  %289 = load ptr, ptr %ptr1.i.i1188, align 8
  %290 = load ptr, ptr %end4.i.i1192, align 8
  %cmp.i970 = icmp eq ptr %289, %290
  br i1 %cmp.i970, label %land.lhs.true.i973, label %if.end6.i971

land.lhs.true.i973:                               ; preds = %if.end.i969
  %call3.i974 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool1126), !range !13
  %tobool4.not.i975 = icmp eq i8 %call3.i974, 0
  br i1 %tobool4.not.i975, label %poolStoreString.exit981, label %land.lhs.true.if.end6_crit_edge.i976

land.lhs.true.if.end6_crit_edge.i976:             ; preds = %land.lhs.true.i973
  %.pre.i977 = load ptr, ptr %ptr1.i.i1188, align 8
  br label %if.end6.i971

if.end6.i971:                                     ; preds = %land.lhs.true.if.end6_crit_edge.i976, %if.end.i969
  %291 = phi ptr [ %.pre.i977, %land.lhs.true.if.end6_crit_edge.i976 ], [ %289, %if.end.i969 ]
  %incdec.ptr.i972 = getelementptr i8, ptr %291, i64 1
  store ptr %incdec.ptr.i972, ptr %ptr1.i.i1188, align 8
  store i8 0, ptr %291, align 1
  %292 = load ptr, ptr %start.i.i1202, align 8
  br label %poolStoreString.exit981

poolStoreString.exit981:                          ; preds = %poolAppend.exit.thread.i964, %poolAppend.exit.i966, %land.lhs.true.i973, %if.end6.i971
  %retval.0.i965 = phi ptr [ %292, %if.end6.i971 ], [ null, %poolAppend.exit.i966 ], [ null, %land.lhs.true.i973 ], [ null, %poolAppend.exit.thread.i964 ]
  %293 = load ptr, ptr %m_declEntity819, align 8
  %notation = getelementptr inbounds %struct.ENTITY, ptr %293, i64 0, i32 7
  store ptr %retval.0.i965, ptr %notation, align 8
  %294 = load ptr, ptr %m_declEntity819, align 8
  %notation709 = getelementptr inbounds %struct.ENTITY, ptr %294, i64 0, i32 7
  %295 = load ptr, ptr %notation709, align 8
  %tobool710.not = icmp eq ptr %295, null
  br i1 %tobool710.not, label %return, label %if.end712

if.end712:                                        ; preds = %poolStoreString.exit981
  %296 = load ptr, ptr %ptr1.i.i1188, align 8
  store ptr %296, ptr %start.i.i1202, align 8
  %297 = load ptr, ptr %m_unparsedEntityDeclHandler, align 8
  %tobool717.not = icmp eq ptr %297, null
  br i1 %tobool717.not, label %if.else731, label %if.then718

if.then718:                                       ; preds = %if.end712
  store ptr %s.addr.0, ptr %eventEndPP.0, align 8
  %298 = load ptr, ptr %m_unparsedEntityDeclHandler, align 8
  %299 = load ptr, ptr %m_handlerArg1382, align 8
  %300 = load ptr, ptr %m_declEntity819, align 8
  %301 = load ptr, ptr %300, align 8
  %base724 = getelementptr inbounds %struct.ENTITY, ptr %300, i64 0, i32 5
  %302 = load ptr, ptr %base724, align 8
  %systemId726 = getelementptr inbounds %struct.ENTITY, ptr %300, i64 0, i32 4
  %303 = load ptr, ptr %systemId726, align 8
  %publicId728 = getelementptr inbounds %struct.ENTITY, ptr %300, i64 0, i32 6
  %304 = load ptr, ptr %publicId728, align 8
  %notation730 = getelementptr inbounds %struct.ENTITY, ptr %300, i64 0, i32 7
  %305 = load ptr, ptr %notation730, align 8
  call void %298(ptr noundef %299, ptr noundef %301, ptr noundef %302, ptr noundef %303, ptr noundef %304, ptr noundef %305) #24
  br label %if.end1443

if.else731:                                       ; preds = %if.end712
  %306 = load ptr, ptr %m_entityDeclHandler1413, align 8
  %tobool733.not = icmp eq ptr %306, null
  br i1 %tobool733.not, label %land.lhs.true1439, label %if.then734

if.then734:                                       ; preds = %if.else731
  store ptr %s.addr.0, ptr %eventEndPP.0, align 8
  %307 = load ptr, ptr %m_entityDeclHandler1413, align 8
  %308 = load ptr, ptr %m_handlerArg1382, align 8
  %309 = load ptr, ptr %m_declEntity819, align 8
  %310 = load ptr, ptr %309, align 8
  %base740 = getelementptr inbounds %struct.ENTITY, ptr %309, i64 0, i32 5
  %311 = load ptr, ptr %base740, align 8
  %systemId742 = getelementptr inbounds %struct.ENTITY, ptr %309, i64 0, i32 4
  %312 = load ptr, ptr %systemId742, align 8
  %publicId744 = getelementptr inbounds %struct.ENTITY, ptr %309, i64 0, i32 6
  %313 = load ptr, ptr %publicId744, align 8
  %notation746 = getelementptr inbounds %struct.ENTITY, ptr %309, i64 0, i32 7
  %314 = load ptr, ptr %notation746, align 8
  call void %307(ptr noundef %308, ptr noundef %310, i32 noundef 0, ptr noundef null, i32 noundef 0, ptr noundef %311, ptr noundef %312, ptr noundef %313, ptr noundef %314) #24
  br label %if.end1443

sw.bb750:                                         ; preds = %sw.epilog44
  %predefinedEntityName = getelementptr inbounds %struct.encoding, ptr %enc.addr.0, i64 0, i32 7
  %315 = load ptr, ptr %predefinedEntityName, align 8
  %316 = load ptr, ptr %next.addr, align 8
  %call751 = call i32 %315(ptr noundef %enc.addr.0, ptr noundef %s.addr.0, ptr noundef %316) #24
  %tobool752.not = icmp eq i32 %call751, 0
  br i1 %tobool752.not, label %if.end755, label %if.then753

if.then753:                                       ; preds = %sw.bb750
  store ptr null, ptr %m_declEntity819, align 8
  br label %land.lhs.true1439

if.end755:                                        ; preds = %sw.bb750
  %317 = load i8, ptr %keepProcessing1423, align 8
  %tobool757.not = icmp eq i8 %317, 0
  br i1 %tobool757.not, label %if.else800, label %if.then758

if.then758:                                       ; preds = %if.end755
  %318 = load ptr, ptr %next.addr, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ptr.addr.i.i982)
  store ptr %s.addr.0, ptr %ptr.addr.i.i982, align 8
  %319 = load ptr, ptr %ptr1.i.i1188, align 8
  %tobool.not.i.i984 = icmp eq ptr %319, null
  br i1 %tobool.not.i.i984, label %land.lhs.true.i.i1008, label %if.end.i.i985

land.lhs.true.i.i1008:                            ; preds = %if.then758
  %call.i.i1009 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool1126), !range !13
  %tobool2.not.i.i1010 = icmp eq i8 %call.i.i1009, 0
  br i1 %tobool2.not.i.i1010, label %poolAppend.exit.thread.i994, label %if.end.i.i985

if.end.i.i985:                                    ; preds = %land.lhs.true.i.i1008, %if.then758
  %utf8Convert.i.i986 = getelementptr inbounds %struct.encoding, ptr %enc.addr.0, i64 0, i32 10
  br label %for.cond.i.i988

for.cond.i.i988:                                  ; preds = %if.end8.i.i991, %if.end.i.i985
  %320 = load ptr, ptr %utf8Convert.i.i986, align 8
  %321 = load ptr, ptr %end4.i.i1192, align 8
  %call5.i.i989 = call i32 %320(ptr noundef %enc.addr.0, ptr noundef nonnull %ptr.addr.i.i982, ptr noundef %318, ptr noundef nonnull %ptr1.i.i1188, ptr noundef %321) #24
  %or.cond.i.i990 = icmp ult i32 %call5.i.i989, 2
  br i1 %or.cond.i.i990, label %poolAppend.exit.i996, label %if.end8.i.i991

if.end8.i.i991:                                   ; preds = %for.cond.i.i988
  %call9.i.i992 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool1126), !range !13
  %tobool10.not.i.i993 = icmp eq i8 %call9.i.i992, 0
  br i1 %tobool10.not.i.i993, label %poolAppend.exit.thread.i994, label %for.cond.i.i988

poolAppend.exit.thread.i994:                      ; preds = %land.lhs.true.i.i1008, %if.end8.i.i991
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i982)
  br label %return

poolAppend.exit.i996:                             ; preds = %for.cond.i.i988
  %322 = load ptr, ptr %start.i.i1202, align 8
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i982)
  %tobool.not.i998 = icmp eq ptr %322, null
  br i1 %tobool.not.i998, label %return, label %if.end.i999

if.end.i999:                                      ; preds = %poolAppend.exit.i996
  %323 = load ptr, ptr %ptr1.i.i1188, align 8
  %324 = load ptr, ptr %end4.i.i1192, align 8
  %cmp.i1000 = icmp eq ptr %323, %324
  br i1 %cmp.i1000, label %land.lhs.true.i1003, label %poolStoreString.exit1011

land.lhs.true.i1003:                              ; preds = %if.end.i999
  %call3.i1004 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool1126), !range !13
  %tobool4.not.i1005 = icmp eq i8 %call3.i1004, 0
  br i1 %tobool4.not.i1005, label %return, label %land.lhs.true.if.end6_crit_edge.i1006

land.lhs.true.if.end6_crit_edge.i1006:            ; preds = %land.lhs.true.i1003
  %.pre.i1007 = load ptr, ptr %ptr1.i.i1188, align 8
  br label %poolStoreString.exit1011

poolStoreString.exit1011:                         ; preds = %if.end.i999, %land.lhs.true.if.end6_crit_edge.i1006
  %325 = phi ptr [ %.pre.i1007, %land.lhs.true.if.end6_crit_edge.i1006 ], [ %323, %if.end.i999 ]
  %incdec.ptr.i1002 = getelementptr i8, ptr %325, i64 1
  store ptr %incdec.ptr.i1002, ptr %ptr1.i.i1188, align 8
  store i8 0, ptr %325, align 1
  %326 = load ptr, ptr %start.i.i1202, align 8
  %tobool762.not = icmp eq ptr %326, null
  br i1 %tobool762.not, label %return, label %if.end764

if.end764:                                        ; preds = %poolStoreString.exit1011
  %call765 = call fastcc ptr @lookup(ptr noundef %parser, ptr noundef nonnull %0, ptr noundef nonnull %326, i64 noundef 64)
  store ptr %call765, ptr %m_declEntity819, align 8
  %tobool768.not = icmp eq ptr %call765, null
  br i1 %tobool768.not, label %return, label %if.end770

if.end770:                                        ; preds = %if.end764
  %327 = load ptr, ptr %call765, align 8
  %cmp773.not = icmp eq ptr %327, %326
  br i1 %cmp773.not, label %if.else781, label %if.then775

if.then775:                                       ; preds = %if.end770
  %328 = load ptr, ptr %start.i.i1202, align 8
  store ptr %328, ptr %ptr1.i.i1188, align 8
  store ptr null, ptr %m_declEntity819, align 8
  br label %land.lhs.true1439

if.else781:                                       ; preds = %if.end770
  %329 = load ptr, ptr %ptr1.i.i1188, align 8
  store ptr %329, ptr %start.i.i1202, align 8
  %330 = load ptr, ptr %m_declEntity819, align 8
  %publicId787 = getelementptr inbounds %struct.ENTITY, ptr %330, i64 0, i32 6
  store ptr null, ptr %publicId787, align 8
  %331 = load ptr, ptr %m_declEntity819, align 8
  %is_param789 = getelementptr inbounds %struct.ENTITY, ptr %331, i64 0, i32 9
  store i8 0, ptr %is_param789, align 1
  %332 = load ptr, ptr %m_parentParser843, align 8
  %tobool790.not = icmp eq ptr %332, null
  br i1 %tobool790.not, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %if.else781
  %333 = load ptr, ptr %m_openInternalEntities1151, align 8
  %tobool792 = icmp ne ptr %333, null
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.else781
  %334 = phi i1 [ true, %if.else781 ], [ %tobool792, %lor.rhs ]
  %lnot = xor i1 %334, true
  %conv793 = zext i1 %lnot to i8
  %335 = load ptr, ptr %m_declEntity819, align 8
  %is_internal = getelementptr inbounds %struct.ENTITY, ptr %335, i64 0, i32 10
  store i8 %conv793, ptr %is_internal, align 2
  %336 = load ptr, ptr %m_entityDeclHandler1413, align 8
  %tobool796.not = icmp eq ptr %336, null
  br i1 %tobool796.not, label %land.lhs.true1439, label %if.end1443

if.else800:                                       ; preds = %if.end755
  %337 = load ptr, ptr %start.i.i1202, align 8
  store ptr %337, ptr %ptr1.i.i1188, align 8
  store ptr null, ptr %m_declEntity819, align 8
  br label %land.lhs.true1439

sw.bb807:                                         ; preds = %sw.epilog44
  %338 = load i8, ptr %keepProcessing1423, align 8
  %tobool809.not = icmp eq i8 %338, 0
  br i1 %tobool809.not, label %if.else859, label %if.then810

if.then810:                                       ; preds = %sw.bb807
  %339 = load ptr, ptr %next.addr, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ptr.addr.i.i1012)
  store ptr %s.addr.0, ptr %ptr.addr.i.i1012, align 8
  %340 = load ptr, ptr %ptr1.i.i1188, align 8
  %tobool.not.i.i1014 = icmp eq ptr %340, null
  br i1 %tobool.not.i.i1014, label %land.lhs.true.i.i1038, label %if.end.i.i1015

land.lhs.true.i.i1038:                            ; preds = %if.then810
  %call.i.i1039 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool1126), !range !13
  %tobool2.not.i.i1040 = icmp eq i8 %call.i.i1039, 0
  br i1 %tobool2.not.i.i1040, label %poolAppend.exit.thread.i1024, label %if.end.i.i1015

if.end.i.i1015:                                   ; preds = %land.lhs.true.i.i1038, %if.then810
  %utf8Convert.i.i1016 = getelementptr inbounds %struct.encoding, ptr %enc.addr.0, i64 0, i32 10
  br label %for.cond.i.i1018

for.cond.i.i1018:                                 ; preds = %if.end8.i.i1021, %if.end.i.i1015
  %341 = load ptr, ptr %utf8Convert.i.i1016, align 8
  %342 = load ptr, ptr %end4.i.i1192, align 8
  %call5.i.i1019 = call i32 %341(ptr noundef %enc.addr.0, ptr noundef nonnull %ptr.addr.i.i1012, ptr noundef %339, ptr noundef nonnull %ptr1.i.i1188, ptr noundef %342) #24
  %or.cond.i.i1020 = icmp ult i32 %call5.i.i1019, 2
  br i1 %or.cond.i.i1020, label %poolAppend.exit.i1026, label %if.end8.i.i1021

if.end8.i.i1021:                                  ; preds = %for.cond.i.i1018
  %call9.i.i1022 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool1126), !range !13
  %tobool10.not.i.i1023 = icmp eq i8 %call9.i.i1022, 0
  br i1 %tobool10.not.i.i1023, label %poolAppend.exit.thread.i1024, label %for.cond.i.i1018

poolAppend.exit.thread.i1024:                     ; preds = %land.lhs.true.i.i1038, %if.end8.i.i1021
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i1012)
  br label %return

poolAppend.exit.i1026:                            ; preds = %for.cond.i.i1018
  %343 = load ptr, ptr %start.i.i1202, align 8
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i1012)
  %tobool.not.i1028 = icmp eq ptr %343, null
  br i1 %tobool.not.i1028, label %return, label %if.end.i1029

if.end.i1029:                                     ; preds = %poolAppend.exit.i1026
  %344 = load ptr, ptr %ptr1.i.i1188, align 8
  %345 = load ptr, ptr %end4.i.i1192, align 8
  %cmp.i1030 = icmp eq ptr %344, %345
  br i1 %cmp.i1030, label %land.lhs.true.i1033, label %poolStoreString.exit1041

land.lhs.true.i1033:                              ; preds = %if.end.i1029
  %call3.i1034 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool1126), !range !13
  %tobool4.not.i1035 = icmp eq i8 %call3.i1034, 0
  br i1 %tobool4.not.i1035, label %return, label %land.lhs.true.if.end6_crit_edge.i1036

land.lhs.true.if.end6_crit_edge.i1036:            ; preds = %land.lhs.true.i1033
  %.pre.i1037 = load ptr, ptr %ptr1.i.i1188, align 8
  br label %poolStoreString.exit1041

poolStoreString.exit1041:                         ; preds = %if.end.i1029, %land.lhs.true.if.end6_crit_edge.i1036
  %346 = phi ptr [ %.pre.i1037, %land.lhs.true.if.end6_crit_edge.i1036 ], [ %344, %if.end.i1029 ]
  %incdec.ptr.i1032 = getelementptr i8, ptr %346, i64 1
  store ptr %incdec.ptr.i1032, ptr %ptr1.i.i1188, align 8
  store i8 0, ptr %346, align 1
  %347 = load ptr, ptr %start.i.i1202, align 8
  %tobool814.not = icmp eq ptr %347, null
  br i1 %tobool814.not, label %return, label %if.end816

if.end816:                                        ; preds = %poolStoreString.exit1041
  %call818 = call fastcc ptr @lookup(ptr noundef %parser, ptr noundef nonnull %paramEntities1138, ptr noundef nonnull %347, i64 noundef 64)
  store ptr %call818, ptr %m_declEntity819, align 8
  %tobool821.not = icmp eq ptr %call818, null
  br i1 %tobool821.not, label %return, label %if.end823

if.end823:                                        ; preds = %if.end816
  %348 = load ptr, ptr %call818, align 8
  %cmp826.not = icmp eq ptr %348, %347
  br i1 %cmp826.not, label %if.else834, label %if.then828

if.then828:                                       ; preds = %if.end823
  %349 = load ptr, ptr %start.i.i1202, align 8
  store ptr %349, ptr %ptr1.i.i1188, align 8
  store ptr null, ptr %m_declEntity819, align 8
  br label %land.lhs.true1439

if.else834:                                       ; preds = %if.end823
  %350 = load ptr, ptr %ptr1.i.i1188, align 8
  store ptr %350, ptr %start.i.i1202, align 8
  %351 = load ptr, ptr %m_declEntity819, align 8
  %publicId840 = getelementptr inbounds %struct.ENTITY, ptr %351, i64 0, i32 6
  store ptr null, ptr %publicId840, align 8
  %352 = load ptr, ptr %m_declEntity819, align 8
  %is_param842 = getelementptr inbounds %struct.ENTITY, ptr %352, i64 0, i32 9
  store i8 1, ptr %is_param842, align 1
  %353 = load ptr, ptr %m_parentParser843, align 8
  %tobool844.not = icmp eq ptr %353, null
  br i1 %tobool844.not, label %lor.rhs845, label %lor.end848

lor.rhs845:                                       ; preds = %if.else834
  %354 = load ptr, ptr %m_openInternalEntities1151, align 8
  %tobool847 = icmp ne ptr %354, null
  br label %lor.end848

lor.end848:                                       ; preds = %lor.rhs845, %if.else834
  %355 = phi i1 [ true, %if.else834 ], [ %tobool847, %lor.rhs845 ]
  %lnot849 = xor i1 %355, true
  %conv851 = zext i1 %lnot849 to i8
  %356 = load ptr, ptr %m_declEntity819, align 8
  %is_internal853 = getelementptr inbounds %struct.ENTITY, ptr %356, i64 0, i32 10
  store i8 %conv851, ptr %is_internal853, align 2
  %357 = load ptr, ptr %m_entityDeclHandler1413, align 8
  %tobool855.not = icmp eq ptr %357, null
  br i1 %tobool855.not, label %land.lhs.true1439, label %if.end1443

if.else859:                                       ; preds = %sw.bb807
  %358 = load ptr, ptr %start.i.i1202, align 8
  store ptr %358, ptr %ptr1.i.i1188, align 8
  store ptr null, ptr %m_declEntity819, align 8
  br label %land.lhs.true1439

sw.bb866:                                         ; preds = %sw.epilog44
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %m_declNotationName945, i8 0, i64 16, i1 false)
  %359 = load ptr, ptr %m_notationDeclHandler1418, align 8
  %tobool867.not = icmp eq ptr %359, null
  br i1 %tobool867.not, label %land.lhs.true1439, label %if.then868

if.then868:                                       ; preds = %sw.bb866
  %360 = load ptr, ptr %next.addr, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ptr.addr.i.i1042)
  store ptr %s.addr.0, ptr %ptr.addr.i.i1042, align 8
  %361 = load ptr, ptr %ptr1.i.i1128, align 8
  %tobool.not.i.i1044 = icmp eq ptr %361, null
  br i1 %tobool.not.i.i1044, label %land.lhs.true.i.i1068, label %if.end.i.i1045

land.lhs.true.i.i1068:                            ; preds = %if.then868
  %call.i.i1069 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool949), !range !13
  %tobool2.not.i.i1070 = icmp eq i8 %call.i.i1069, 0
  br i1 %tobool2.not.i.i1070, label %poolAppend.exit.thread.i1054, label %if.end.i.i1045

if.end.i.i1045:                                   ; preds = %land.lhs.true.i.i1068, %if.then868
  %utf8Convert.i.i1046 = getelementptr inbounds %struct.encoding, ptr %enc.addr.0, i64 0, i32 10
  br label %for.cond.i.i1048

for.cond.i.i1048:                                 ; preds = %if.end8.i.i1051, %if.end.i.i1045
  %362 = load ptr, ptr %utf8Convert.i.i1046, align 8
  %363 = load ptr, ptr %end.i1176, align 8
  %call5.i.i1049 = call i32 %362(ptr noundef %enc.addr.0, ptr noundef nonnull %ptr.addr.i.i1042, ptr noundef %360, ptr noundef nonnull %ptr1.i.i1128, ptr noundef %363) #24
  %or.cond.i.i1050 = icmp ult i32 %call5.i.i1049, 2
  br i1 %or.cond.i.i1050, label %poolAppend.exit.i1056, label %if.end8.i.i1051

if.end8.i.i1051:                                  ; preds = %for.cond.i.i1048
  %call9.i.i1052 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool949), !range !13
  %tobool10.not.i.i1053 = icmp eq i8 %call9.i.i1052, 0
  br i1 %tobool10.not.i.i1053, label %poolAppend.exit.thread.i1054, label %for.cond.i.i1048

poolAppend.exit.thread.i1054:                     ; preds = %land.lhs.true.i.i1068, %if.end8.i.i1051
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i1042)
  br label %poolStoreString.exit1071.thread

poolAppend.exit.i1056:                            ; preds = %for.cond.i.i1048
  %364 = load ptr, ptr %start.i.i1142, align 8
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i1042)
  %tobool.not.i1058 = icmp eq ptr %364, null
  br i1 %tobool.not.i1058, label %poolStoreString.exit1071.thread, label %if.end.i1059

if.end.i1059:                                     ; preds = %poolAppend.exit.i1056
  %365 = load ptr, ptr %ptr1.i.i1128, align 8
  %366 = load ptr, ptr %end.i1176, align 8
  %cmp.i1060 = icmp eq ptr %365, %366
  br i1 %cmp.i1060, label %land.lhs.true.i1063, label %poolStoreString.exit1071

land.lhs.true.i1063:                              ; preds = %if.end.i1059
  %call3.i1064 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool949), !range !13
  %tobool4.not.i1065 = icmp eq i8 %call3.i1064, 0
  br i1 %tobool4.not.i1065, label %poolStoreString.exit1071.thread, label %land.lhs.true.if.end6_crit_edge.i1066

land.lhs.true.if.end6_crit_edge.i1066:            ; preds = %land.lhs.true.i1063
  %.pre.i1067 = load ptr, ptr %ptr1.i.i1128, align 8
  br label %poolStoreString.exit1071

poolStoreString.exit1071.thread:                  ; preds = %poolAppend.exit.i1056, %land.lhs.true.i1063, %poolAppend.exit.thread.i1054
  store ptr null, ptr %m_declNotationName945, align 8
  br label %return

poolStoreString.exit1071:                         ; preds = %if.end.i1059, %land.lhs.true.if.end6_crit_edge.i1066
  %367 = phi ptr [ %.pre.i1067, %land.lhs.true.if.end6_crit_edge.i1066 ], [ %365, %if.end.i1059 ]
  %incdec.ptr.i1062 = getelementptr i8, ptr %367, i64 1
  store ptr %incdec.ptr.i1062, ptr %ptr1.i.i1128, align 8
  store i8 0, ptr %367, align 1
  %368 = load ptr, ptr %start.i.i1142, align 8
  store ptr %368, ptr %m_declNotationName945, align 8
  %tobool873.not = icmp eq ptr %368, null
  br i1 %tobool873.not, label %return, label %if.end875

if.end875:                                        ; preds = %poolStoreString.exit1071
  %369 = load ptr, ptr %ptr1.i.i1128, align 8
  store ptr %369, ptr %start.i.i1142, align 8
  br label %if.end1443

sw.bb881:                                         ; preds = %sw.epilog44
  %isPublicId882 = getelementptr inbounds %struct.encoding, ptr %enc.addr.0, i64 0, i32 9
  %370 = load ptr, ptr %isPublicId882, align 8
  %371 = load ptr, ptr %next.addr, align 8
  %call883 = call i32 %370(ptr noundef %enc.addr.0, ptr noundef %s.addr.0, ptr noundef %371, ptr noundef nonnull %eventPP.0) #24
  %tobool884.not = icmp eq i32 %call883, 0
  br i1 %tobool884.not, label %return, label %if.end886

if.end886:                                        ; preds = %sw.bb881
  %372 = load ptr, ptr %m_declNotationName945, align 8
  %tobool888.not = icmp eq ptr %372, null
  br i1 %tobool888.not, label %land.lhs.true1439, label %if.then889

if.then889:                                       ; preds = %if.end886
  %minBytesPerChar892 = getelementptr inbounds %struct.encoding, ptr %enc.addr.0, i64 0, i32 12
  %373 = load i32, ptr %minBytesPerChar892, align 8
  %idx.ext893 = sext i32 %373 to i64
  %add.ptr894 = getelementptr i8, ptr %s.addr.0, i64 %idx.ext893
  %374 = load ptr, ptr %next.addr, align 8
  %idx.neg897 = sub nsw i64 0, %idx.ext893
  %add.ptr898 = getelementptr i8, ptr %374, i64 %idx.neg897
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ptr.addr.i.i1072)
  store ptr %add.ptr894, ptr %ptr.addr.i.i1072, align 8
  %375 = load ptr, ptr %ptr1.i.i1128, align 8
  %tobool.not.i.i1074 = icmp eq ptr %375, null
  br i1 %tobool.not.i.i1074, label %land.lhs.true.i.i1098, label %if.end.i.i1075

land.lhs.true.i.i1098:                            ; preds = %if.then889
  %call.i.i1099 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool949), !range !13
  %tobool2.not.i.i1100 = icmp eq i8 %call.i.i1099, 0
  br i1 %tobool2.not.i.i1100, label %poolAppend.exit.thread.i1084, label %if.end.i.i1075

if.end.i.i1075:                                   ; preds = %land.lhs.true.i.i1098, %if.then889
  %utf8Convert.i.i1076 = getelementptr inbounds %struct.encoding, ptr %enc.addr.0, i64 0, i32 10
  br label %for.cond.i.i1078

for.cond.i.i1078:                                 ; preds = %if.end8.i.i1081, %if.end.i.i1075
  %376 = load ptr, ptr %utf8Convert.i.i1076, align 8
  %377 = load ptr, ptr %end.i1176, align 8
  %call5.i.i1079 = call i32 %376(ptr noundef %enc.addr.0, ptr noundef nonnull %ptr.addr.i.i1072, ptr noundef %add.ptr898, ptr noundef nonnull %ptr1.i.i1128, ptr noundef %377) #24
  %or.cond.i.i1080 = icmp ult i32 %call5.i.i1079, 2
  br i1 %or.cond.i.i1080, label %poolAppend.exit.i1086, label %if.end8.i.i1081

if.end8.i.i1081:                                  ; preds = %for.cond.i.i1078
  %call9.i.i1082 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool949), !range !13
  %tobool10.not.i.i1083 = icmp eq i8 %call9.i.i1082, 0
  br i1 %tobool10.not.i.i1083, label %poolAppend.exit.thread.i1084, label %for.cond.i.i1078

poolAppend.exit.thread.i1084:                     ; preds = %land.lhs.true.i.i1098, %if.end8.i.i1081
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i1072)
  br label %return

poolAppend.exit.i1086:                            ; preds = %for.cond.i.i1078
  %378 = load ptr, ptr %start.i.i1142, align 8
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i1072)
  %tobool.not.i1088 = icmp eq ptr %378, null
  br i1 %tobool.not.i1088, label %return, label %if.end.i1089

if.end.i1089:                                     ; preds = %poolAppend.exit.i1086
  %379 = load ptr, ptr %ptr1.i.i1128, align 8
  %380 = load ptr, ptr %end.i1176, align 8
  %cmp.i1090 = icmp eq ptr %379, %380
  br i1 %cmp.i1090, label %land.lhs.true.i1093, label %poolStoreString.exit1101

land.lhs.true.i1093:                              ; preds = %if.end.i1089
  %call3.i1094 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool949), !range !13
  %tobool4.not.i1095 = icmp eq i8 %call3.i1094, 0
  br i1 %tobool4.not.i1095, label %return, label %land.lhs.true.if.end6_crit_edge.i1096

land.lhs.true.if.end6_crit_edge.i1096:            ; preds = %land.lhs.true.i1093
  %.pre.i1097 = load ptr, ptr %ptr1.i.i1128, align 8
  br label %poolStoreString.exit1101

poolStoreString.exit1101:                         ; preds = %if.end.i1089, %land.lhs.true.if.end6_crit_edge.i1096
  %381 = phi ptr [ %.pre.i1097, %land.lhs.true.if.end6_crit_edge.i1096 ], [ %379, %if.end.i1089 ]
  %incdec.ptr.i1092 = getelementptr i8, ptr %381, i64 1
  store ptr %incdec.ptr.i1092, ptr %ptr1.i.i1128, align 8
  store i8 0, ptr %381, align 1
  %382 = load ptr, ptr %start.i.i1142, align 8
  %tobool900.not = icmp eq ptr %382, null
  br i1 %tobool900.not, label %return, label %if.end902

if.end902:                                        ; preds = %poolStoreString.exit1101
  %383 = load i8, ptr %382, align 1
  %tobool.not14.i1102 = icmp eq i8 %383, 0
  br i1 %tobool.not14.i1102, label %normalizePublicId.exit1126, label %for.body.i1103

for.body.i1103:                                   ; preds = %if.end902, %for.inc.i1115
  %384 = phi i8 [ %386, %for.inc.i1115 ], [ %383, %if.end902 ]
  %s.016.i1104 = phi ptr [ %incdec.ptr6.i1117, %for.inc.i1115 ], [ %382, %if.end902 ]
  %p.015.i1105 = phi ptr [ %p.1.i1116, %for.inc.i1115 ], [ %382, %if.end902 ]
  %conv.i1106 = sext i8 %384 to i32
  switch i32 %conv.i1106, label %for.inc.sink.split.i1112 [
    i32 32, label %sw.bb.i1107
    i32 13, label %sw.bb.i1107
    i32 10, label %sw.bb.i1107
  ]

sw.bb.i1107:                                      ; preds = %for.body.i1103, %for.body.i1103, %for.body.i1103
  %cmp.not.i1108 = icmp eq ptr %p.015.i1105, %382
  br i1 %cmp.not.i1108, label %for.inc.i1115, label %land.lhs.true.i1109

land.lhs.true.i1109:                              ; preds = %sw.bb.i1107
  %arrayidx.i1110 = getelementptr i8, ptr %p.015.i1105, i64 -1
  %385 = load i8, ptr %arrayidx.i1110, align 1
  %cmp3.not.i1111 = icmp eq i8 %385, 32
  br i1 %cmp3.not.i1111, label %for.inc.i1115, label %for.inc.sink.split.i1112

for.inc.sink.split.i1112:                         ; preds = %land.lhs.true.i1109, %for.body.i1103
  %.sink.i1113 = phi i8 [ 32, %land.lhs.true.i1109 ], [ %384, %for.body.i1103 ]
  %incdec.ptr5.i1114 = getelementptr i8, ptr %p.015.i1105, i64 1
  store i8 %.sink.i1113, ptr %p.015.i1105, align 1
  br label %for.inc.i1115

for.inc.i1115:                                    ; preds = %for.inc.sink.split.i1112, %land.lhs.true.i1109, %sw.bb.i1107
  %p.1.i1116 = phi ptr [ %p.015.i1105, %land.lhs.true.i1109 ], [ %382, %sw.bb.i1107 ], [ %incdec.ptr5.i1114, %for.inc.sink.split.i1112 ]
  %incdec.ptr6.i1117 = getelementptr i8, ptr %s.016.i1104, i64 1
  %386 = load i8, ptr %incdec.ptr6.i1117, align 1
  %tobool.not.i1118 = icmp eq i8 %386, 0
  br i1 %tobool.not.i1118, label %for.end.i1119, label %for.body.i1103, !llvm.loop !33

for.end.i1119:                                    ; preds = %for.inc.i1115
  %cmp7.not.i1120 = icmp eq ptr %p.1.i1116, %382
  br i1 %cmp7.not.i1120, label %normalizePublicId.exit1126, label %land.lhs.true9.i1121

land.lhs.true9.i1121:                             ; preds = %for.end.i1119
  %arrayidx10.i1122 = getelementptr i8, ptr %p.1.i1116, i64 -1
  %387 = load i8, ptr %arrayidx10.i1122, align 1
  %cmp12.i1123 = icmp eq i8 %387, 32
  %spec.select.i1124 = select i1 %cmp12.i1123, ptr %arrayidx10.i1122, ptr %p.1.i1116
  br label %normalizePublicId.exit1126

normalizePublicId.exit1126:                       ; preds = %if.end902, %for.end.i1119, %land.lhs.true9.i1121
  %p.2.i1125 = phi ptr [ %382, %for.end.i1119 ], [ %spec.select.i1124, %land.lhs.true9.i1121 ], [ %382, %if.end902 ]
  store i8 0, ptr %p.2.i1125, align 1
  store ptr %382, ptr %m_declNotationPublicId937, align 8
  %388 = load ptr, ptr %ptr1.i.i1128, align 8
  store ptr %388, ptr %start.i.i1142, align 8
  br label %if.end1443

sw.bb909:                                         ; preds = %sw.epilog44
  %389 = load ptr, ptr %m_declNotationName945, align 8
  %tobool911.not = icmp eq ptr %389, null
  br i1 %tobool911.not, label %if.end934, label %land.lhs.true912

land.lhs.true912:                                 ; preds = %sw.bb909
  %390 = load ptr, ptr %m_notationDeclHandler1418, align 8
  %tobool914.not = icmp eq ptr %390, null
  br i1 %tobool914.not, label %if.end934, label %if.then915

if.then915:                                       ; preds = %land.lhs.true912
  %minBytesPerChar918 = getelementptr inbounds %struct.encoding, ptr %enc.addr.0, i64 0, i32 12
  %391 = load i32, ptr %minBytesPerChar918, align 8
  %idx.ext919 = sext i32 %391 to i64
  %add.ptr920 = getelementptr i8, ptr %s.addr.0, i64 %idx.ext919
  %392 = load ptr, ptr %next.addr, align 8
  %idx.neg923 = sub nsw i64 0, %idx.ext919
  %add.ptr924 = getelementptr i8, ptr %392, i64 %idx.neg923
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ptr.addr.i.i1127)
  store ptr %add.ptr920, ptr %ptr.addr.i.i1127, align 8
  %393 = load ptr, ptr %ptr1.i.i1128, align 8
  %tobool.not.i.i1129 = icmp eq ptr %393, null
  br i1 %tobool.not.i.i1129, label %land.lhs.true.i.i1153, label %if.end.i.i1130

land.lhs.true.i.i1153:                            ; preds = %if.then915
  %call.i.i1154 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool949), !range !13
  %tobool2.not.i.i1155 = icmp eq i8 %call.i.i1154, 0
  br i1 %tobool2.not.i.i1155, label %poolAppend.exit.thread.i1139, label %if.end.i.i1130

if.end.i.i1130:                                   ; preds = %land.lhs.true.i.i1153, %if.then915
  %utf8Convert.i.i1131 = getelementptr inbounds %struct.encoding, ptr %enc.addr.0, i64 0, i32 10
  br label %for.cond.i.i1133

for.cond.i.i1133:                                 ; preds = %if.end8.i.i1136, %if.end.i.i1130
  %394 = load ptr, ptr %utf8Convert.i.i1131, align 8
  %395 = load ptr, ptr %end.i1176, align 8
  %call5.i.i1134 = call i32 %394(ptr noundef nonnull %enc.addr.0, ptr noundef nonnull %ptr.addr.i.i1127, ptr noundef %add.ptr924, ptr noundef nonnull %ptr1.i.i1128, ptr noundef %395) #24
  %or.cond.i.i1135 = icmp ult i32 %call5.i.i1134, 2
  br i1 %or.cond.i.i1135, label %poolAppend.exit.i1141, label %if.end8.i.i1136

if.end8.i.i1136:                                  ; preds = %for.cond.i.i1133
  %call9.i.i1137 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool949), !range !13
  %tobool10.not.i.i1138 = icmp eq i8 %call9.i.i1137, 0
  br i1 %tobool10.not.i.i1138, label %poolAppend.exit.thread.i1139, label %for.cond.i.i1133

poolAppend.exit.thread.i1139:                     ; preds = %land.lhs.true.i.i1153, %if.end8.i.i1136
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i1127)
  br label %return

poolAppend.exit.i1141:                            ; preds = %for.cond.i.i1133
  %396 = load ptr, ptr %start.i.i1142, align 8
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i1127)
  %tobool.not.i1143 = icmp eq ptr %396, null
  br i1 %tobool.not.i1143, label %return, label %if.end.i1144

if.end.i1144:                                     ; preds = %poolAppend.exit.i1141
  %397 = load ptr, ptr %ptr1.i.i1128, align 8
  %398 = load ptr, ptr %end.i1176, align 8
  %cmp.i1145 = icmp eq ptr %397, %398
  br i1 %cmp.i1145, label %land.lhs.true.i1148, label %poolStoreString.exit1156

land.lhs.true.i1148:                              ; preds = %if.end.i1144
  %call3.i1149 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool949), !range !13
  %tobool4.not.i1150 = icmp eq i8 %call3.i1149, 0
  br i1 %tobool4.not.i1150, label %return, label %land.lhs.true.if.end6_crit_edge.i1151

land.lhs.true.if.end6_crit_edge.i1151:            ; preds = %land.lhs.true.i1148
  %.pre.i1152 = load ptr, ptr %ptr1.i.i1128, align 8
  br label %poolStoreString.exit1156

poolStoreString.exit1156:                         ; preds = %if.end.i1144, %land.lhs.true.if.end6_crit_edge.i1151
  %399 = phi ptr [ %.pre.i1152, %land.lhs.true.if.end6_crit_edge.i1151 ], [ %397, %if.end.i1144 ]
  %incdec.ptr.i1147 = getelementptr i8, ptr %399, i64 1
  store ptr %incdec.ptr.i1147, ptr %ptr1.i.i1128, align 8
  store i8 0, ptr %399, align 1
  %400 = load ptr, ptr %start.i.i1142, align 8
  %tobool926.not = icmp eq ptr %400, null
  br i1 %tobool926.not, label %return, label %if.end928

if.end928:                                        ; preds = %poolStoreString.exit1156
  store ptr %s.addr.0, ptr %eventEndPP.0, align 8
  %401 = load ptr, ptr %m_notationDeclHandler1418, align 8
  %402 = load ptr, ptr %m_handlerArg1382, align 8
  %403 = load ptr, ptr %m_declNotationName945, align 8
  %404 = load ptr, ptr %m_curBase946, align 8
  %405 = load ptr, ptr %m_declNotationPublicId937, align 8
  call void %401(ptr noundef %402, ptr noundef %403, ptr noundef %404, ptr noundef nonnull %400, ptr noundef %405) #24
  br label %if.end934

if.end934:                                        ; preds = %if.end928, %land.lhs.true912, %sw.bb909
  %handleDefault.7 = phi i8 [ 0, %if.end928 ], [ 1, %land.lhs.true912 ], [ 1, %sw.bb909 ]
  %406 = load ptr, ptr %freeBlocks.i1168, align 8
  %tobool.not.i1158 = icmp eq ptr %406, null
  %407 = load ptr, ptr %m_tempPool949, align 8
  br i1 %tobool.not.i1158, label %if.then.i1166, label %if.else.i1159

if.then.i1166:                                    ; preds = %if.end934
  store ptr %407, ptr %freeBlocks.i1168, align 8
  br label %poolClear.exit1167

if.else.i1159:                                    ; preds = %if.end934
  %tobool3.not13.i1160 = icmp eq ptr %407, null
  br i1 %tobool3.not13.i1160, label %poolClear.exit1167, label %while.body.i1161

while.body.i1161:                                 ; preds = %if.else.i1159, %while.body.i1161
  %408 = phi ptr [ %p.014.i1162, %while.body.i1161 ], [ %406, %if.else.i1159 ]
  %p.014.i1162 = phi ptr [ %409, %while.body.i1161 ], [ %407, %if.else.i1159 ]
  %409 = load ptr, ptr %p.014.i1162, align 8
  store ptr %408, ptr %p.014.i1162, align 8
  store ptr %p.014.i1162, ptr %freeBlocks.i1168, align 8
  %tobool3.not.i1163 = icmp eq ptr %409, null
  br i1 %tobool3.not.i1163, label %poolClear.exit1167, label %while.body.i1161, !llvm.loop !8

poolClear.exit1167:                               ; preds = %while.body.i1161, %if.then.i1166, %if.else.i1159
  store ptr null, ptr %m_tempPool949, align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %end.i1176, i8 0, i64 24, i1 false)
  br label %sw.epilog1436

sw.bb936:                                         ; preds = %sw.epilog44
  %410 = load ptr, ptr %m_declNotationPublicId937, align 8
  %tobool938.not = icmp eq ptr %410, null
  br i1 %tobool938.not, label %if.end948, label %land.lhs.true939

land.lhs.true939:                                 ; preds = %sw.bb936
  %411 = load ptr, ptr %m_notationDeclHandler1418, align 8
  %tobool941.not = icmp eq ptr %411, null
  br i1 %tobool941.not, label %if.end948, label %if.then942

if.then942:                                       ; preds = %land.lhs.true939
  store ptr %s.addr.0, ptr %eventEndPP.0, align 8
  %412 = load ptr, ptr %m_notationDeclHandler1418, align 8
  %413 = load ptr, ptr %m_handlerArg1382, align 8
  %414 = load ptr, ptr %m_declNotationName945, align 8
  %415 = load ptr, ptr %m_curBase946, align 8
  %416 = load ptr, ptr %m_declNotationPublicId937, align 8
  call void %412(ptr noundef %413, ptr noundef %414, ptr noundef %415, ptr noundef null, ptr noundef %416) #24
  br label %if.end948

if.end948:                                        ; preds = %if.then942, %land.lhs.true939, %sw.bb936
  %handleDefault.8 = phi i8 [ 0, %if.then942 ], [ 1, %land.lhs.true939 ], [ 1, %sw.bb936 ]
  %417 = load ptr, ptr %freeBlocks.i1168, align 8
  %tobool.not.i1169 = icmp eq ptr %417, null
  %418 = load ptr, ptr %m_tempPool949, align 8
  br i1 %tobool.not.i1169, label %if.then.i1177, label %if.else.i1170

if.then.i1177:                                    ; preds = %if.end948
  store ptr %418, ptr %freeBlocks.i1168, align 8
  br label %poolClear.exit1178

if.else.i1170:                                    ; preds = %if.end948
  %tobool3.not13.i1171 = icmp eq ptr %418, null
  br i1 %tobool3.not13.i1171, label %poolClear.exit1178, label %while.body.i1172

while.body.i1172:                                 ; preds = %if.else.i1170, %while.body.i1172
  %419 = phi ptr [ %p.014.i1173, %while.body.i1172 ], [ %417, %if.else.i1170 ]
  %p.014.i1173 = phi ptr [ %420, %while.body.i1172 ], [ %418, %if.else.i1170 ]
  %420 = load ptr, ptr %p.014.i1173, align 8
  store ptr %419, ptr %p.014.i1173, align 8
  store ptr %p.014.i1173, ptr %freeBlocks.i1168, align 8
  %tobool3.not.i1174 = icmp eq ptr %420, null
  br i1 %tobool3.not.i1174, label %poolClear.exit1178, label %while.body.i1172, !llvm.loop !8

poolClear.exit1178:                               ; preds = %while.body.i1172, %if.then.i1177, %if.else.i1170
  store ptr null, ptr %m_tempPool949, align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %end.i1176, i8 0, i64 24, i1 false)
  br label %sw.epilog1436

sw.bb950:                                         ; preds = %sw.epilog44
  %switch.selectcmp = icmp eq i32 %tok.addr.1, 12
  %switch.select = select i1 %switch.selectcmp, i32 17, i32 2
  %switch.selectcmp719 = icmp eq i32 %tok.addr.1, 28
  %switch.select720 = select i1 %switch.selectcmp719, i32 10, i32 %switch.select
  br label %return

sw.bb954:                                         ; preds = %sw.epilog44
  %421 = load ptr, ptr %m_defaultHandler, align 8
  %tobool956.not = icmp eq ptr %421, null
  br i1 %tobool956.not, label %if.end958, label %if.then957

if.then957:                                       ; preds = %sw.bb954
  %422 = load ptr, ptr %next.addr, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %s.addr.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %dataPtr.i)
  store ptr %s.addr.0, ptr %s.addr.i, align 8
  %isUtf8.i = getelementptr inbounds %struct.encoding, ptr %enc.addr.0, i64 0, i32 13
  %423 = load i8, ptr %isUtf8.i, align 4
  %tobool.not.i1179 = icmp eq i8 %423, 0
  br i1 %tobool.not.i1179, label %if.then.i1180, label %if.else9.i

if.then.i1180:                                    ; preds = %if.then957
  %424 = load ptr, ptr %m_encoding, align 8
  %cmp.i1181 = icmp eq ptr %424, %enc.addr.0
  br i1 %cmp.i1181, label %if.end.i1183, label %if.else.i1182

if.else.i1182:                                    ; preds = %if.then.i1180
  %425 = load ptr, ptr %m_openInternalEntities1151, align 8
  %internalEventEndPtr.i = getelementptr inbounds %struct.open_internal_entity, ptr %425, i64 0, i32 1
  br label %if.end.i1183

if.end.i1183:                                     ; preds = %if.then.i1180, %if.else.i1182
  %eventPP.0.i = phi ptr [ %425, %if.else.i1182 ], [ %m_eventPtr.i, %if.then.i1180 ]
  %eventEndPP.0.i = phi ptr [ %internalEventEndPtr.i, %if.else.i1182 ], [ %m_eventEndPtr.i, %if.then.i1180 ]
  %utf8Convert.i1184 = getelementptr inbounds %struct.encoding, ptr %enc.addr.0, i64 0, i32 10
  br label %do.body.i

do.body.i:                                        ; preds = %do.body.i, %if.end.i1183
  %426 = load ptr, ptr %m_dataBuf.i, align 8
  store ptr %426, ptr %dataPtr.i, align 8
  %427 = load ptr, ptr %utf8Convert.i1184, align 8
  %428 = load ptr, ptr %m_dataBufEnd.i, align 8
  %call.i1185 = call i32 %427(ptr noundef nonnull %enc.addr.0, ptr noundef nonnull %s.addr.i, ptr noundef %422, ptr noundef nonnull %dataPtr.i, ptr noundef %428) #24
  %429 = load ptr, ptr %s.addr.i, align 8
  store ptr %429, ptr %eventEndPP.0.i, align 8
  %430 = load ptr, ptr %m_defaultHandler, align 8
  %431 = load ptr, ptr %m_handlerArg1382, align 8
  %432 = load ptr, ptr %m_dataBuf.i, align 8
  %433 = load ptr, ptr %dataPtr.i, align 8
  %sub.ptr.lhs.cast.i = ptrtoint ptr %433 to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %432 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %conv.i1186 = trunc i64 %sub.ptr.sub.i to i32
  call void %430(ptr noundef %431, ptr noundef %432, i32 noundef %conv.i1186) #24
  %434 = load ptr, ptr %s.addr.i, align 8
  store ptr %434, ptr %eventPP.0.i, align 8
  %435 = icmp ugt i32 %call.i1185, 1
  br i1 %435, label %do.body.i, label %reportDefault.exit, !llvm.loop !28

if.else9.i:                                       ; preds = %if.then957
  %436 = load ptr, ptr %m_handlerArg1382, align 8
  %sub.ptr.lhs.cast12.i = ptrtoint ptr %422 to i64
  %sub.ptr.rhs.cast13.i = ptrtoint ptr %s.addr.0 to i64
  %sub.ptr.sub14.i = sub i64 %sub.ptr.lhs.cast12.i, %sub.ptr.rhs.cast13.i
  %conv15.i = trunc i64 %sub.ptr.sub14.i to i32
  call void %421(ptr noundef %436, ptr noundef %s.addr.0, i32 noundef %conv15.i) #24
  br label %reportDefault.exit

reportDefault.exit:                               ; preds = %do.body.i, %if.else9.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %s.addr.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %dataPtr.i)
  br label %if.end958

if.end958:                                        ; preds = %reportDefault.exit, %sw.bb954
  %call959 = call fastcc i32 @doIgnoreSection(ptr noundef nonnull %parser, ptr noundef %enc.addr.0, ptr noundef nonnull %next.addr, ptr noundef %end, ptr noundef %nextPtr, i8 noundef zeroext %haveMore), !range !32
  %cmp960.not = icmp eq i32 %call959, 0
  br i1 %cmp960.not, label %if.else963, label %return

if.else963:                                       ; preds = %if.end958
  %437 = load ptr, ptr %next.addr, align 8
  %tobool964.not = icmp eq ptr %437, null
  br i1 %tobool964.not, label %if.then965, label %if.end1443

if.then965:                                       ; preds = %if.else963
  %m_processor966 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 45
  store ptr @ignoreSectionProcessor, ptr %m_processor966, align 8
  br label %return

sw.bb969:                                         ; preds = %sw.epilog44
  %438 = load i32, ptr %level1066, align 8
  %439 = load i32, ptr %m_groupSize, align 8
  %cmp971.not = icmp ult i32 %438, %439
  br i1 %cmp971.not, label %if.end1017, label %if.then973

if.then973:                                       ; preds = %sw.bb969
  %tobool975.not = icmp eq i32 %439, 0
  br i1 %tobool975.not, label %if.else1006, label %if.then976

if.then976:                                       ; preds = %if.then973
  %cmp978 = icmp slt i32 %439, 0
  br i1 %cmp978, label %return, label %if.end981

if.end981:                                        ; preds = %if.then976
  %440 = load ptr, ptr %realloc_fcn, align 8
  %441 = load ptr, ptr %m_groupConnector1064, align 8
  %mul = shl nuw i32 %439, 1
  store i32 %mul, ptr %m_groupSize, align 8
  %conv983 = zext i32 %mul to i64
  %call984 = call ptr %440(ptr noundef %441, i64 noundef %conv983) #24
  %cmp985 = icmp eq ptr %call984, null
  br i1 %cmp985, label %if.then987, label %if.end989

if.then987:                                       ; preds = %if.end981
  %442 = load i32, ptr %m_groupSize, align 8
  %div714 = lshr i32 %442, 1
  store i32 %div714, ptr %m_groupSize, align 8
  br label %return

if.end989:                                        ; preds = %if.end981
  store ptr %call984, ptr %m_groupConnector1064, align 8
  %443 = load ptr, ptr %scaffIndex1364, align 8
  %tobool991.not = icmp eq ptr %443, null
  br i1 %tobool991.not, label %if.end1017, label %if.then992

if.then992:                                       ; preds = %if.end989
  %444 = load ptr, ptr %realloc_fcn, align 8
  %445 = load i32, ptr %m_groupSize, align 8
  %conv997 = zext i32 %445 to i64
  %mul998 = shl nuw nsw i64 %conv997, 2
  %call999 = call ptr %444(ptr noundef nonnull %443, i64 noundef %mul998) #24
  %cmp1000 = icmp eq ptr %call999, null
  br i1 %cmp1000, label %return, label %if.end1003

if.end1003:                                       ; preds = %if.then992
  store ptr %call999, ptr %scaffIndex1364, align 8
  br label %if.end1017

if.else1006:                                      ; preds = %if.then973
  %446 = load ptr, ptr %3, align 8
  store i32 32, ptr %m_groupSize, align 8
  %call1009 = call ptr %446(i64 noundef 32) #24
  store ptr %call1009, ptr %m_groupConnector1064, align 8
  %tobool1012.not = icmp eq ptr %call1009, null
  br i1 %tobool1012.not, label %if.then1013, label %if.end1017

if.then1013:                                      ; preds = %if.else1006
  store i32 0, ptr %m_groupSize, align 8
  br label %return

if.end1017:                                       ; preds = %if.end1003, %if.end989, %if.else1006, %sw.bb969
  %447 = load ptr, ptr %m_groupConnector1064, align 8
  %448 = load i32, ptr %level1066, align 8
  %idxprom = zext i32 %448 to i64
  %arrayidx1021 = getelementptr i8, ptr %447, i64 %idxprom
  store i8 0, ptr %arrayidx1021, align 1
  %449 = load i8, ptr %in_eldecl1355, align 8
  %tobool1022.not = icmp eq i8 %449, 0
  br i1 %tobool1022.not, label %land.lhs.true1439, label %if.then1023

if.then1023:                                      ; preds = %if.end1017
  %call1024 = call fastcc i32 @nextScaffoldPart(ptr noundef nonnull %parser)
  %cmp1025 = icmp slt i32 %call1024, 0
  br i1 %cmp1025, label %return, label %if.end1028

if.end1028:                                       ; preds = %if.then1023
  %450 = load ptr, ptr %scaffIndex1364, align 8
  %451 = load i32, ptr %scaffLevel1362, align 4
  %idxprom1030 = sext i32 %451 to i64
  %arrayidx1031 = getelementptr i32, ptr %450, i64 %idxprom1030
  store i32 %call1024, ptr %arrayidx1031, align 4
  %452 = load i32, ptr %scaffLevel1362, align 4
  %inc = add i32 %452, 1
  store i32 %inc, ptr %scaffLevel1362, align 4
  %453 = load ptr, ptr %scaffold1363, align 8
  %idxprom1033 = zext nneg i32 %call1024 to i64
  %arrayidx1034 = getelementptr %struct.CONTENT_SCAFFOLD, ptr %453, i64 %idxprom1033
  store i32 6, ptr %arrayidx1034, align 8
  %454 = load ptr, ptr %m_elementDeclHandler1432, align 8
  %tobool1035.not = icmp eq ptr %454, null
  br i1 %tobool1035.not, label %land.lhs.true1439, label %if.end1443

sw.bb1039:                                        ; preds = %sw.epilog44
  %455 = load ptr, ptr %m_groupConnector1064, align 8
  %456 = load i32, ptr %level1066, align 8
  %idxprom1043 = zext i32 %456 to i64
  %arrayidx1044 = getelementptr i8, ptr %455, i64 %idxprom1043
  %457 = load i8, ptr %arrayidx1044, align 1
  %cmp1046 = icmp eq i8 %457, 124
  br i1 %cmp1046, label %return, label %if.end1049

if.end1049:                                       ; preds = %sw.bb1039
  store i8 44, ptr %arrayidx1044, align 1
  %458 = load i8, ptr %in_eldecl1355, align 8
  %tobool1057.not = icmp eq i8 %458, 0
  br i1 %tobool1057.not, label %land.lhs.true1439, label %land.lhs.true1058

land.lhs.true1058:                                ; preds = %if.end1049
  %459 = load ptr, ptr %m_elementDeclHandler1432, align 8
  %tobool1060.not = icmp eq ptr %459, null
  br i1 %tobool1060.not, label %land.lhs.true1439, label %if.end1443

sw.bb1063:                                        ; preds = %sw.epilog44
  %460 = load ptr, ptr %m_groupConnector1064, align 8
  %461 = load i32, ptr %level1066, align 8
  %idxprom1067 = zext i32 %461 to i64
  %arrayidx1068 = getelementptr i8, ptr %460, i64 %idxprom1067
  %462 = load i8, ptr %arrayidx1068, align 1
  %cmp1070 = icmp eq i8 %462, 44
  br i1 %cmp1070, label %return, label %if.end1073

if.end1073:                                       ; preds = %sw.bb1063
  %463 = load i8, ptr %in_eldecl1355, align 8
  %tobool1076.not = icmp ne i8 %463, 0
  %tobool1083.not = icmp eq i8 %462, 0
  %or.cond723 = and i1 %tobool1083.not, %tobool1076.not
  br i1 %or.cond723, label %land.lhs.true1084, label %if.end1110

land.lhs.true1084:                                ; preds = %if.end1073
  %464 = load ptr, ptr %scaffold1363, align 8
  %465 = load ptr, ptr %scaffIndex1364, align 8
  %466 = load i32, ptr %scaffLevel1362, align 4
  %sub1088 = add i32 %466, -1
  %idxprom1089 = sext i32 %sub1088 to i64
  %arrayidx1090 = getelementptr i32, ptr %465, i64 %idxprom1089
  %467 = load i32, ptr %arrayidx1090, align 4
  %idxprom1091 = sext i32 %467 to i64
  %arrayidx1092 = getelementptr %struct.CONTENT_SCAFFOLD, ptr %464, i64 %idxprom1091
  %468 = load i32, ptr %arrayidx1092, align 8
  %cmp1094.not = icmp eq i32 %468, 3
  br i1 %cmp1094.not, label %if.end1110, label %if.then1096

if.then1096:                                      ; preds = %land.lhs.true1084
  store i32 5, ptr %arrayidx1092, align 8
  %469 = load ptr, ptr %m_elementDeclHandler1432, align 8
  %tobool1107.not = icmp eq ptr %469, null
  %spec.select724 = zext i1 %tobool1107.not to i8
  %.pre1703 = load ptr, ptr %m_groupConnector1064, align 8
  %.pre1704 = load i32, ptr %level1066, align 8
  %.pre1709 = zext i32 %.pre1704 to i64
  br label %if.end1110

if.end1110:                                       ; preds = %if.then1096, %land.lhs.true1084, %if.end1073
  %idxprom1114.pre-phi = phi i64 [ %.pre1709, %if.then1096 ], [ %idxprom1067, %land.lhs.true1084 ], [ %idxprom1067, %if.end1073 ]
  %470 = phi ptr [ %.pre1703, %if.then1096 ], [ %460, %land.lhs.true1084 ], [ %460, %if.end1073 ]
  %handleDefault.9 = phi i8 [ %spec.select724, %if.then1096 ], [ 1, %land.lhs.true1084 ], [ 1, %if.end1073 ]
  %arrayidx1115 = getelementptr i8, ptr %470, i64 %idxprom1114.pre-phi
  store i8 124, ptr %arrayidx1115, align 1
  br label %sw.epilog1436

sw.bb1116:                                        ; preds = %sw.epilog44, %sw.epilog44
  store i8 1, ptr %hasParamEntityRefs1117, align 1
  %471 = load i32, ptr %m_paramEntityParsing1118, align 4
  %tobool1119.not = icmp eq i32 %471, 0
  br i1 %tobool1119.not, label %if.then1120, label %if.else1123

if.then1120:                                      ; preds = %sw.bb1116
  %472 = load i8, ptr %standalone1147, align 2
  store i8 %472, ptr %keepProcessing1423, align 8
  br label %if.end1224

if.else1123:                                      ; preds = %sw.bb1116
  %minBytesPerChar1127 = getelementptr inbounds %struct.encoding, ptr %enc.addr.0, i64 0, i32 12
  %473 = load i32, ptr %minBytesPerChar1127, align 8
  %idx.ext1128 = sext i32 %473 to i64
  %add.ptr1129 = getelementptr i8, ptr %s.addr.0, i64 %idx.ext1128
  %474 = load ptr, ptr %next.addr, align 8
  %idx.neg1132 = sub nsw i64 0, %idx.ext1128
  %add.ptr1133 = getelementptr i8, ptr %474, i64 %idx.neg1132
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ptr.addr.i.i1187)
  store ptr %add.ptr1129, ptr %ptr.addr.i.i1187, align 8
  %475 = load ptr, ptr %ptr1.i.i1188, align 8
  %tobool.not.i.i1189 = icmp eq ptr %475, null
  br i1 %tobool.not.i.i1189, label %land.lhs.true.i.i1213, label %if.end.i.i1190

land.lhs.true.i.i1213:                            ; preds = %if.else1123
  %call.i.i1214 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool1126), !range !13
  %tobool2.not.i.i1215 = icmp eq i8 %call.i.i1214, 0
  br i1 %tobool2.not.i.i1215, label %poolAppend.exit.thread.i1199, label %if.end.i.i1190

if.end.i.i1190:                                   ; preds = %land.lhs.true.i.i1213, %if.else1123
  %utf8Convert.i.i1191 = getelementptr inbounds %struct.encoding, ptr %enc.addr.0, i64 0, i32 10
  br label %for.cond.i.i1193

for.cond.i.i1193:                                 ; preds = %if.end8.i.i1196, %if.end.i.i1190
  %476 = load ptr, ptr %utf8Convert.i.i1191, align 8
  %477 = load ptr, ptr %end4.i.i1192, align 8
  %call5.i.i1194 = call i32 %476(ptr noundef nonnull %enc.addr.0, ptr noundef nonnull %ptr.addr.i.i1187, ptr noundef %add.ptr1133, ptr noundef nonnull %ptr1.i.i1188, ptr noundef %477) #24
  %or.cond.i.i1195 = icmp ult i32 %call5.i.i1194, 2
  br i1 %or.cond.i.i1195, label %poolAppend.exit.i1201, label %if.end8.i.i1196

if.end8.i.i1196:                                  ; preds = %for.cond.i.i1193
  %call9.i.i1197 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool1126), !range !13
  %tobool10.not.i.i1198 = icmp eq i8 %call9.i.i1197, 0
  br i1 %tobool10.not.i.i1198, label %poolAppend.exit.thread.i1199, label %for.cond.i.i1193

poolAppend.exit.thread.i1199:                     ; preds = %land.lhs.true.i.i1213, %if.end8.i.i1196
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i1187)
  br label %return

poolAppend.exit.i1201:                            ; preds = %for.cond.i.i1193
  %478 = load ptr, ptr %start.i.i1202, align 8
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i1187)
  %tobool.not.i1203 = icmp eq ptr %478, null
  br i1 %tobool.not.i1203, label %return, label %if.end.i1204

if.end.i1204:                                     ; preds = %poolAppend.exit.i1201
  %479 = load ptr, ptr %ptr1.i.i1188, align 8
  %480 = load ptr, ptr %end4.i.i1192, align 8
  %cmp.i1205 = icmp eq ptr %479, %480
  br i1 %cmp.i1205, label %land.lhs.true.i1208, label %poolStoreString.exit1216

land.lhs.true.i1208:                              ; preds = %if.end.i1204
  %call3.i1209 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool1126), !range !13
  %tobool4.not.i1210 = icmp eq i8 %call3.i1209, 0
  br i1 %tobool4.not.i1210, label %return, label %land.lhs.true.if.end6_crit_edge.i1211

land.lhs.true.if.end6_crit_edge.i1211:            ; preds = %land.lhs.true.i1208
  %.pre.i1212 = load ptr, ptr %ptr1.i.i1188, align 8
  br label %poolStoreString.exit1216

poolStoreString.exit1216:                         ; preds = %if.end.i1204, %land.lhs.true.if.end6_crit_edge.i1211
  %481 = phi ptr [ %.pre.i1212, %land.lhs.true.if.end6_crit_edge.i1211 ], [ %479, %if.end.i1204 ]
  %incdec.ptr.i1207 = getelementptr i8, ptr %481, i64 1
  store ptr %incdec.ptr.i1207, ptr %ptr1.i.i1188, align 8
  store i8 0, ptr %481, align 1
  %482 = load ptr, ptr %start.i.i1202, align 8
  %tobool1135.not = icmp eq ptr %482, null
  br i1 %tobool1135.not, label %return, label %if.end1137

if.end1137:                                       ; preds = %poolStoreString.exit1216
  %483 = load i64, ptr %size.i, align 8
  %cmp.i1217 = icmp eq i64 %483, 0
  br i1 %cmp.i1217, label %lookup.exit, label %if.else.i1218

if.else.i1218:                                    ; preds = %if.end1137
  %call12.i = call fastcc i64 @hash(ptr noundef %parser, ptr noundef nonnull %482)
  %484 = load i64, ptr %size.i, align 8
  %sub14.i = add i64 %484, -1
  %and15.i = and i64 %sub14.i, %call12.i
  %485 = load ptr, ptr %paramEntities1138, align 8
  %arrayidx111.i = getelementptr ptr, ptr %485, i64 %and15.i
  %486 = load ptr, ptr %arrayidx111.i, align 8
  %tobool17.not112.i = icmp eq ptr %486, null
  br i1 %tobool17.not112.i, label %lookup.exit, label %while.body.lr.ph.i1219

while.body.lr.ph.i1219:                           ; preds = %if.else.i1218
  %487 = load i8, ptr %482, align 1
  %not.i = sub i64 0, %484
  %and29.i = and i64 %call12.i, %not.i
  %shr32.i = lshr i64 %sub14.i, 2
  br label %while.body.i1220

while.body.i1220:                                 ; preds = %if.end35.i, %while.body.lr.ph.i1219
  %488 = phi ptr [ %486, %while.body.lr.ph.i1219 ], [ %496, %if.end35.i ]
  %i.0114.i = phi i64 [ %and15.i, %while.body.lr.ph.i1219 ], [ %i.1.i, %if.end35.i ]
  %step.0113.i = phi i8 [ 0, %while.body.lr.ph.i1219 ], [ %step.1.i, %if.end35.i ]
  %489 = load ptr, ptr %488, align 8
  %490 = load i8, ptr %489, align 1
  %cmp5.i.i = icmp eq i8 %487, %490
  br i1 %cmp5.i.i, label %for.body.i.i, label %if.end26.i

for.body.i.i:                                     ; preds = %while.body.i1220, %for.inc.i.i
  %491 = phi i8 [ %492, %for.inc.i.i ], [ %487, %while.body.i1220 ]
  %s2.addr.07.i.i = phi ptr [ %incdec.ptr6.i.i, %for.inc.i.i ], [ %489, %while.body.i1220 ]
  %s1.addr.06.i.i = phi ptr [ %incdec.ptr.i.i, %for.inc.i.i ], [ %482, %while.body.i1220 ]
  %cmp4.i.i = icmp eq i8 %491, 0
  br i1 %cmp4.i.i, label %lookup.exit, label %for.inc.i.i

for.inc.i.i:                                      ; preds = %for.body.i.i
  %incdec.ptr.i.i = getelementptr i8, ptr %s1.addr.06.i.i, i64 1
  %incdec.ptr6.i.i = getelementptr i8, ptr %s2.addr.07.i.i, i64 1
  %492 = load i8, ptr %incdec.ptr.i.i, align 1
  %493 = load i8, ptr %incdec.ptr6.i.i, align 1
  %cmp.i.i1225 = icmp eq i8 %492, %493
  br i1 %cmp.i.i1225, label %for.body.i.i, label %if.end26.i, !llvm.loop !14

if.end26.i:                                       ; preds = %for.inc.i.i, %while.body.i1220
  %tobool27.not.i = icmp eq i8 %step.0113.i, 0
  br i1 %tobool27.not.i, label %if.then28.i, label %if.end35.i

if.then28.i:                                      ; preds = %if.end26.i
  %494 = load i8, ptr %power30.i, align 8
  %conv.i1224 = zext i8 %494 to i64
  %sub31.i = add nuw nsw i64 %conv.i1224, 4294967295
  %sh_prom.i = and i64 %sub31.i, 4294967295
  %shr.i = lshr i64 %and29.i, %sh_prom.i
  %and33.i = and i64 %shr.i, %shr32.i
  %495 = trunc i64 %and33.i to i8
  %conv34.i = or i8 %495, 1
  br label %if.end35.i

if.end35.i:                                       ; preds = %if.then28.i, %if.end26.i
  %step.1.i = phi i8 [ %step.0113.i, %if.end26.i ], [ %conv34.i, %if.then28.i ]
  %conv36.i = zext i8 %step.1.i to i64
  %cmp37.i = icmp ult i64 %i.0114.i, %conv36.i
  %i.1.p.v.i = select i1 %cmp37.i, i64 %484, i64 0
  %i.1.p.i = sub i64 %i.0114.i, %conv36.i
  %i.1.i = add i64 %i.1.p.v.i, %i.1.p.i
  %arrayidx.i1221 = getelementptr ptr, ptr %485, i64 %i.1.i
  %496 = load ptr, ptr %arrayidx.i1221, align 8
  %tobool17.not.i = icmp eq ptr %496, null
  br i1 %tobool17.not.i, label %lookup.exit, label %while.body.i1220, !llvm.loop !15

lookup.exit:                                      ; preds = %if.end35.i, %for.body.i.i, %if.else.i1218, %if.end1137
  %retval.0.i1223 = phi ptr [ null, %if.end1137 ], [ null, %if.else.i1218 ], [ %488, %for.body.i.i ], [ null, %if.end35.i ]
  %497 = load ptr, ptr %start.i.i1202, align 8
  store ptr %497, ptr %ptr1.i.i1188, align 8
  %498 = load i32, ptr %documentEntity, align 4
  %tobool1145.not = icmp eq i32 %498, 0
  br i1 %tobool1145.not, label %if.else1165, label %land.lhs.true1146

land.lhs.true1146:                                ; preds = %lookup.exit
  %499 = load i8, ptr %standalone1147, align 2
  %tobool1149.not = icmp eq i8 %499, 0
  br i1 %tobool1149.not, label %cond.false1153, label %cond.true1150

cond.true1150:                                    ; preds = %land.lhs.true1146
  %500 = load ptr, ptr %m_openInternalEntities1151, align 8
  %tobool1152.not = icmp eq ptr %500, null
  br i1 %tobool1152.not, label %if.then1156, label %if.else1165

cond.false1153:                                   ; preds = %land.lhs.true1146
  %501 = load i8, ptr %hasParamEntityRefs1117, align 1
  %tobool1155.not = icmp eq i8 %501, 0
  br i1 %tobool1155.not, label %if.then1156, label %if.else1165

if.then1156:                                      ; preds = %cond.false1153, %cond.true1150
  %tobool1157.not = icmp eq ptr %retval.0.i1223, null
  br i1 %tobool1157.not, label %return, label %if.else1159

if.else1159:                                      ; preds = %if.then1156
  %is_internal1160 = getelementptr inbounds %struct.ENTITY, ptr %retval.0.i1223, i64 0, i32 10
  %502 = load i8, ptr %is_internal1160, align 2
  %tobool1161.not = icmp eq i8 %502, 0
  br i1 %tobool1161.not, label %return, label %if.end1179

if.else1165:                                      ; preds = %cond.false1153, %cond.true1150, %lookup.exit
  %tobool1166.not = icmp eq ptr %retval.0.i1223, null
  br i1 %tobool1166.not, label %if.then1167, label %if.end1179

if.then1167:                                      ; preds = %if.else1165
  %503 = load i8, ptr %standalone1147, align 2
  store i8 %503, ptr %keepProcessing1423, align 8
  %cmp1170 = icmp eq i32 %call37, 60
  br i1 %cmp1170, label %land.lhs.true1172, label %land.lhs.true1439

land.lhs.true1172:                                ; preds = %if.then1167
  %504 = load ptr, ptr %m_skippedEntityHandler, align 8
  %tobool1173.not = icmp eq ptr %504, null
  br i1 %tobool1173.not, label %land.lhs.true1439, label %if.then1174

if.then1174:                                      ; preds = %land.lhs.true1172
  %505 = load ptr, ptr %m_handlerArg1382, align 8
  call void %504(ptr noundef %505, ptr noundef nonnull %482, i32 noundef 1) #24
  br label %if.end1443

if.end1179:                                       ; preds = %if.else1165, %if.else1159
  %open = getelementptr inbounds %struct.ENTITY, ptr %retval.0.i1223, i64 0, i32 8
  %506 = load i8, ptr %open, align 8
  %tobool1180.not = icmp eq i8 %506, 0
  br i1 %tobool1180.not, label %if.end1182, label %return

if.end1182:                                       ; preds = %if.end1179
  %textPtr1183 = getelementptr inbounds %struct.ENTITY, ptr %retval.0.i1223, i64 0, i32 1
  %507 = load ptr, ptr %textPtr1183, align 8
  %tobool1184.not = icmp eq ptr %507, null
  br i1 %tobool1184.not, label %if.end1197, label %if.then1185

if.then1185:                                      ; preds = %if.end1182
  %cmp1188 = icmp eq i32 %call37, 60
  %conv1191 = zext i1 %cmp1188 to i8
  %call1192 = call fastcc i32 @processInternalEntity(ptr noundef nonnull %parser, ptr noundef nonnull %retval.0.i1223, i8 noundef zeroext %conv1191)
  %cmp1193.not = icmp eq i32 %call1192, 0
  br i1 %cmp1193.not, label %if.end1443, label %return

if.end1197:                                       ; preds = %if.end1182
  %508 = load ptr, ptr %m_externalEntityRefHandler1198, align 8
  %tobool1199.not = icmp eq ptr %508, null
  br i1 %tobool1199.not, label %if.else1220, label %if.then1200

if.then1200:                                      ; preds = %if.end1197
  store i8 0, ptr %paramEntityRead1201, align 1
  store i8 1, ptr %open, align 8
  br label %while.cond.i.i

while.cond.i.i:                                   ; preds = %while.cond.i.i, %if.then1200
  %rootParser.0.i.i = phi ptr [ %parser, %if.then1200 ], [ %509, %while.cond.i.i ]
  %m_parentParser.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i, i64 0, i32 84
  %509 = load ptr, ptr %m_parentParser.i.i, align 8
  %tobool.not.i.i1227 = icmp eq ptr %509, null
  br i1 %tobool.not.i.i1227, label %getRootParserOf.exit.i, label %while.cond.i.i, !llvm.loop !31

getRootParserOf.exit.i:                           ; preds = %while.cond.i.i
  %m_entity_stats.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i, i64 0, i32 91
  %510 = load i32, ptr %m_entity_stats.i, align 8
  %inc.i = add i32 %510, 1
  store i32 %inc.i, ptr %m_entity_stats.i, align 8
  %currentDepth.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i, i64 0, i32 91, i32 1
  %511 = load i32, ptr %currentDepth.i, align 4
  %inc2.i = add i32 %511, 1
  store i32 %inc2.i, ptr %currentDepth.i, align 4
  %maximumDepthSeen.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i, i64 0, i32 91, i32 2
  %512 = load i32, ptr %maximumDepthSeen.i, align 8
  %cmp.i1228 = icmp ugt i32 %inc2.i, %512
  br i1 %cmp.i1228, label %if.then.i1234, label %if.end.i1229

if.then.i1234:                                    ; preds = %getRootParserOf.exit.i
  %inc8.i = add nuw i32 %512, 1
  store i32 %inc8.i, ptr %maximumDepthSeen.i, align 8
  br label %if.end.i1229

if.end.i1229:                                     ; preds = %if.then.i1234, %getRootParserOf.exit.i
  %513 = phi i32 [ %inc8.i, %if.then.i1234 ], [ %512, %getRootParserOf.exit.i ]
  %debugLevel.i.i1230 = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i, i64 0, i32 91, i32 3
  %514 = load i32, ptr %debugLevel.i.i1230, align 4
  %cmp.i.i1231 = icmp slt i32 %514, 1
  br i1 %cmp.i.i1231, label %entityTrackingOnOpen.exit, label %if.end.i.i1232

if.end.i.i1232:                                   ; preds = %if.end.i1229
  %515 = load ptr, ptr %retval.0.i1223, align 8
  %516 = load ptr, ptr @stderr, align 8
  %sub.i.i = shl i32 %inc2.i, 1
  %mul.i.i = add i32 %sub.i.i, -2
  %is_param.i.i = getelementptr inbounds %struct.ENTITY, ptr %retval.0.i1223, i64 0, i32 9
  %517 = load i8, ptr %is_param.i.i, align 1
  %tobool.not.i6.i = icmp eq i8 %517, 0
  %cond.i.i = select i1 %tobool.not.i6.i, ptr @.str.89, ptr @.str.88
  %textLen.i.i = getelementptr inbounds %struct.ENTITY, ptr %retval.0.i1223, i64 0, i32 2
  %518 = load i32, ptr %textLen.i.i, align 8
  %call.i.i1233 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %516, ptr noundef nonnull @.str.320, ptr noundef nonnull %rootParser.0.i.i, i32 noundef %inc.i, i32 noundef %inc2.i, i32 noundef %513, i32 noundef %mul.i.i, ptr noundef nonnull @.str.310, ptr noundef nonnull %cond.i.i, ptr noundef %515, ptr noundef nonnull @.str.319, i32 noundef %518, i32 noundef 5439) #27
  br label %entityTrackingOnOpen.exit

entityTrackingOnOpen.exit:                        ; preds = %if.end.i1229, %if.end.i.i1232
  %519 = load ptr, ptr %m_externalEntityRefHandler1198, align 8
  %520 = load ptr, ptr %m_externalEntityRefHandlerArg1204, align 8
  %base1205 = getelementptr inbounds %struct.ENTITY, ptr %retval.0.i1223, i64 0, i32 5
  %521 = load ptr, ptr %base1205, align 8
  %systemId1206 = getelementptr inbounds %struct.ENTITY, ptr %retval.0.i1223, i64 0, i32 4
  %522 = load ptr, ptr %systemId1206, align 8
  %publicId1207 = getelementptr inbounds %struct.ENTITY, ptr %retval.0.i1223, i64 0, i32 6
  %523 = load ptr, ptr %publicId1207, align 8
  %call1208 = call i32 %519(ptr noundef %520, ptr noundef null, ptr noundef %521, ptr noundef %522, ptr noundef %523) #24
  %tobool1209.not = icmp eq i32 %call1208, 0
  br i1 %tobool1209.not, label %if.then1210, label %while.cond.i.i1235

if.then1210:                                      ; preds = %entityTrackingOnOpen.exit
  call fastcc void @entityTrackingOnClose(ptr noundef nonnull %parser, ptr noundef nonnull %retval.0.i1223, i32 noundef 5443)
  store i8 0, ptr %open, align 8
  br label %return

while.cond.i.i1235:                               ; preds = %entityTrackingOnOpen.exit, %while.cond.i.i1235
  %rootParser.0.i.i1236 = phi ptr [ %524, %while.cond.i.i1235 ], [ %parser, %entityTrackingOnOpen.exit ]
  %m_parentParser.i.i1237 = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i1236, i64 0, i32 84
  %524 = load ptr, ptr %m_parentParser.i.i1237, align 8
  %tobool.not.i.i1238 = icmp eq ptr %524, null
  br i1 %tobool.not.i.i1238, label %getRootParserOf.exit.i1239, label %while.cond.i.i1235, !llvm.loop !31

getRootParserOf.exit.i1239:                       ; preds = %while.cond.i.i1235
  %debugLevel.i.i1240 = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i1236, i64 0, i32 91, i32 3
  %525 = load i32, ptr %debugLevel.i.i1240, align 4
  %cmp.i.i1241 = icmp slt i32 %525, 1
  br i1 %cmp.i.i1241, label %entityTrackingOnClose.exit, label %if.end.i.i1242

if.end.i.i1242:                                   ; preds = %getRootParserOf.exit.i1239
  %m_entity_stats.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i1236, i64 0, i32 91
  %526 = load ptr, ptr %retval.0.i1223, align 8
  %527 = load ptr, ptr @stderr, align 8
  %528 = load i32, ptr %m_entity_stats.i.i, align 8
  %currentDepth.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i1236, i64 0, i32 91, i32 1
  %529 = load i32, ptr %currentDepth.i.i, align 4
  %maximumDepthSeen.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i1236, i64 0, i32 91, i32 2
  %530 = load i32, ptr %maximumDepthSeen.i.i, align 8
  %sub.i.i1243 = shl i32 %529, 1
  %mul.i.i1244 = add i32 %sub.i.i1243, -2
  %is_param.i.i1245 = getelementptr inbounds %struct.ENTITY, ptr %retval.0.i1223, i64 0, i32 9
  %531 = load i8, ptr %is_param.i.i1245, align 1
  %tobool.not.i2.i = icmp eq i8 %531, 0
  %cond.i.i1246 = select i1 %tobool.not.i2.i, ptr @.str.89, ptr @.str.88
  %textLen.i.i1247 = getelementptr inbounds %struct.ENTITY, ptr %retval.0.i1223, i64 0, i32 2
  %532 = load i32, ptr %textLen.i.i1247, align 8
  %call.i.i1248 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %527, ptr noundef nonnull @.str.320, ptr noundef nonnull %rootParser.0.i.i1236, i32 noundef %528, i32 noundef %529, i32 noundef %530, i32 noundef %mul.i.i1244, ptr noundef nonnull @.str.310, ptr noundef nonnull %cond.i.i1246, ptr noundef %526, ptr noundef nonnull @.str.321, i32 noundef %532, i32 noundef 5447) #27
  br label %entityTrackingOnClose.exit

entityTrackingOnClose.exit:                       ; preds = %getRootParserOf.exit.i1239, %if.end.i.i1242
  %currentDepth.i1249 = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i1236, i64 0, i32 91, i32 1
  %533 = load i32, ptr %currentDepth.i1249, align 4
  %dec.i = add i32 %533, -1
  store i32 %dec.i, ptr %currentDepth.i1249, align 4
  store i8 0, ptr %open, align 8
  %534 = load i8, ptr %paramEntityRead1201, align 1
  %tobool1215.not = icmp eq i8 %534, 0
  %.pre = load i8, ptr %standalone1147, align 2
  br i1 %tobool1215.not, label %if.then1216, label %if.end1224

if.then1216:                                      ; preds = %entityTrackingOnClose.exit
  store i8 %.pre, ptr %keepProcessing1423, align 8
  br label %if.end1443

if.else1220:                                      ; preds = %if.end1197
  %535 = load i8, ptr %standalone1147, align 2
  store i8 %535, ptr %keepProcessing1423, align 8
  br label %land.lhs.true1439

if.end1224:                                       ; preds = %entityTrackingOnClose.exit, %if.then1120
  %536 = phi i8 [ %.pre, %entityTrackingOnClose.exit ], [ %472, %if.then1120 ]
  %handleDefault.10 = phi i8 [ 0, %entityTrackingOnClose.exit ], [ 1, %if.then1120 ]
  %tobool1226.not = icmp eq i8 %536, 0
  br i1 %tobool1226.not, label %land.lhs.true1227, label %sw.epilog1436

land.lhs.true1227:                                ; preds = %if.end1224
  %537 = load ptr, ptr %m_notStandaloneHandler1228, align 8
  %tobool1229.not = icmp eq ptr %537, null
  br i1 %tobool1229.not, label %sw.epilog1436, label %land.lhs.true1230

land.lhs.true1230:                                ; preds = %land.lhs.true1227
  %538 = load ptr, ptr %m_handlerArg1382, align 8
  %call1233 = call i32 %537(ptr noundef %538) #24
  %tobool1234.not = icmp eq i32 %call1233, 0
  br i1 %tobool1234.not, label %return, label %sw.epilog1436

sw.bb1237:                                        ; preds = %sw.epilog44
  %539 = load ptr, ptr %m_elementDeclHandler1432, align 8
  %tobool1239.not = icmp eq ptr %539, null
  br i1 %tobool1239.not, label %land.lhs.true1439, label %if.then1240

if.then1240:                                      ; preds = %sw.bb1237
  %540 = load ptr, ptr %next.addr, align 8
  %call1241 = call fastcc ptr @getElementType(ptr noundef nonnull %parser, ptr noundef %enc.addr.0, ptr noundef %s.addr.0, ptr noundef %540)
  store ptr %call1241, ptr %m_declElementType1383, align 8
  %tobool1244.not = icmp eq ptr %call1241, null
  br i1 %tobool1244.not, label %return, label %if.end1246

if.end1246:                                       ; preds = %if.then1240
  store i32 0, ptr %scaffLevel1362, align 4
  store i32 0, ptr %scaffCount, align 8
  store i8 1, ptr %in_eldecl1355, align 8
  br label %if.end1443

sw.bb1250:                                        ; preds = %sw.epilog44, %sw.epilog44
  %541 = load i8, ptr %in_eldecl1355, align 8
  %tobool1252.not = icmp eq i8 %541, 0
  br i1 %tobool1252.not, label %land.lhs.true1439, label %if.then1253

if.then1253:                                      ; preds = %sw.bb1250
  %542 = load ptr, ptr %m_elementDeclHandler1432, align 8
  %tobool1255.not = icmp eq ptr %542, null
  br i1 %tobool1255.not, label %if.end1273, label %if.then1256

if.then1256:                                      ; preds = %if.then1253
  %543 = load ptr, ptr %3, align 8
  %call1259 = call ptr %543(i64 noundef 32) #24
  %tobool1260.not = icmp eq ptr %call1259, null
  br i1 %tobool1260.not, label %return, label %if.end1262

if.end1262:                                       ; preds = %if.then1256
  %quant1263 = getelementptr inbounds %struct.XML_cp, ptr %call1259, i64 0, i32 1
  %children = getelementptr inbounds %struct.XML_cp, ptr %call1259, i64 0, i32 4
  store ptr null, ptr %children, align 8
  %cmp1265 = icmp eq i32 %call37, 41
  %cond1267 = select i1 %cmp1265, i32 2, i32 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 4 dereferenceable(16) %quant1263, i8 0, i64 16, i1 false)
  store i32 %cond1267, ptr %call1259, align 8
  store ptr %s.addr.0, ptr %eventEndPP.0, align 8
  %544 = load ptr, ptr %m_elementDeclHandler1432, align 8
  %545 = load ptr, ptr %m_handlerArg1382, align 8
  %546 = load ptr, ptr %m_declElementType1383, align 8
  %547 = load ptr, ptr %546, align 8
  call void %544(ptr noundef %545, ptr noundef %547, ptr noundef nonnull %call1259) #24
  br label %if.end1273

if.end1273:                                       ; preds = %if.end1262, %if.then1253
  %handleDefault.11 = phi i8 [ 0, %if.end1262 ], [ 1, %if.then1253 ]
  store i8 0, ptr %in_eldecl1355, align 8
  br label %sw.epilog1436

sw.bb1276:                                        ; preds = %sw.epilog44
  %548 = load i8, ptr %in_eldecl1355, align 8
  %tobool1278.not = icmp eq i8 %548, 0
  br i1 %tobool1278.not, label %land.lhs.true1439, label %if.then1279

if.then1279:                                      ; preds = %sw.bb1276
  %549 = load ptr, ptr %scaffold1363, align 8
  %550 = load ptr, ptr %scaffIndex1364, align 8
  %551 = load i32, ptr %scaffLevel1362, align 4
  %sub1283 = add i32 %551, -1
  %idxprom1284 = sext i32 %sub1283 to i64
  %arrayidx1285 = getelementptr i32, ptr %550, i64 %idxprom1284
  %552 = load i32, ptr %arrayidx1285, align 4
  %idxprom1286 = sext i32 %552 to i64
  %arrayidx1287 = getelementptr %struct.CONTENT_SCAFFOLD, ptr %549, i64 %idxprom1286
  store i32 3, ptr %arrayidx1287, align 8
  %553 = load ptr, ptr %m_elementDeclHandler1432, align 8
  %tobool1290.not = icmp eq ptr %553, null
  br i1 %tobool1290.not, label %land.lhs.true1439, label %if.end1443

sw.bb1296:                                        ; preds = %sw.epilog44
  br label %elementContent

sw.bb1297:                                        ; preds = %sw.epilog44
  br label %elementContent

elementContent:                                   ; preds = %sw.epilog44, %sw.bb1297, %sw.bb1296
  %quant.0 = phi i32 [ 3, %sw.bb1297 ], [ 2, %sw.bb1296 ], [ 1, %sw.epilog44 ]
  %554 = load i8, ptr %in_eldecl1355, align 8
  %tobool1299.not = icmp eq i8 %554, 0
  br i1 %tobool1299.not, label %land.lhs.true1439, label %cond.false1305

elementContent.thread:                            ; preds = %sw.epilog44
  %555 = load i8, ptr %in_eldecl1355, align 8
  %tobool1299.not1333 = icmp eq i8 %555, 0
  br i1 %tobool1299.not1333, label %land.lhs.true1439, label %cond.true1304

cond.true1304:                                    ; preds = %elementContent.thread
  %556 = load ptr, ptr %next.addr, align 8
  br label %cond.end

cond.false1305:                                   ; preds = %elementContent
  %557 = load ptr, ptr %next.addr, align 8
  %minBytesPerChar1306 = getelementptr inbounds %struct.encoding, ptr %enc.addr.0, i64 0, i32 12
  %558 = load i32, ptr %minBytesPerChar1306, align 8
  %idx.ext1307 = sext i32 %558 to i64
  %idx.neg1308 = sub nsw i64 0, %idx.ext1307
  %add.ptr1309 = getelementptr i8, ptr %557, i64 %idx.neg1308
  br label %cond.end

cond.end:                                         ; preds = %cond.false1305, %cond.true1304
  %quant.013351338 = phi i32 [ 0, %cond.true1304 ], [ %quant.0, %cond.false1305 ]
  %cond1310 = phi ptr [ %556, %cond.true1304 ], [ %add.ptr1309, %cond.false1305 ]
  %call1312 = call fastcc i32 @nextScaffoldPart(ptr noundef %parser)
  %cmp1313 = icmp slt i32 %call1312, 0
  br i1 %cmp1313, label %return, label %if.end1316

if.end1316:                                       ; preds = %cond.end
  %559 = load ptr, ptr %scaffold1363, align 8
  %idxprom1318 = zext nneg i32 %call1312 to i64
  %arrayidx1319 = getelementptr %struct.CONTENT_SCAFFOLD, ptr %559, i64 %idxprom1318
  store i32 4, ptr %arrayidx1319, align 8
  %560 = load ptr, ptr %scaffold1363, align 8
  %quant1324 = getelementptr %struct.CONTENT_SCAFFOLD, ptr %560, i64 %idxprom1318, i32 1
  store i32 %quant.013351338, ptr %quant1324, align 4
  %call1325 = call fastcc ptr @getElementType(ptr noundef %parser, ptr noundef %enc.addr.0, ptr noundef %s.addr.0, ptr noundef %cond1310)
  %tobool1326.not = icmp eq ptr %call1325, null
  br i1 %tobool1326.not, label %return, label %if.end1328

if.end1328:                                       ; preds = %if.end1316
  %561 = load ptr, ptr %call1325, align 8
  %562 = load ptr, ptr %scaffold1363, align 8
  %name1333 = getelementptr %struct.CONTENT_SCAFFOLD, ptr %562, i64 %idxprom1318, i32 2
  store ptr %561, ptr %name1333, align 8
  br label %for.cond1334

for.cond1334:                                     ; preds = %for.cond1334, %if.end1328
  %nameLen.0 = phi i64 [ 0, %if.end1328 ], [ %inc1335, %for.cond1334 ]
  %inc1335 = add i64 %nameLen.0, 1
  %arrayidx1336 = getelementptr i8, ptr %561, i64 %nameLen.0
  %563 = load i8, ptr %arrayidx1336, align 1
  %tobool1337.not = icmp eq i8 %563, 0
  br i1 %tobool1337.not, label %for.end, label %for.cond1334, !llvm.loop !36

for.end:                                          ; preds = %for.cond1334
  %564 = load i32, ptr %contentStringLen1387, align 8
  %sub1338 = xor i32 %564, -1
  %conv1339 = zext i32 %sub1338 to i64
  %cmp1340 = icmp ugt i64 %inc1335, %conv1339
  br i1 %cmp1340, label %return, label %if.end1343

if.end1343:                                       ; preds = %for.end
  %conv1344 = trunc i64 %inc1335 to i32
  %add = add i32 %564, %conv1344
  store i32 %add, ptr %contentStringLen1387, align 8
  %565 = load ptr, ptr %m_elementDeclHandler1432, align 8
  %tobool1347.not = icmp eq ptr %565, null
  br i1 %tobool1347.not, label %land.lhs.true1439, label %if.end1443

sw.bb1352:                                        ; preds = %sw.epilog44
  br label %closeGroup

sw.bb1353:                                        ; preds = %sw.epilog44
  br label %closeGroup

sw.bb1354:                                        ; preds = %sw.epilog44
  br label %closeGroup

closeGroup:                                       ; preds = %sw.epilog44, %sw.bb1354, %sw.bb1353, %sw.bb1352
  %quant.1 = phi i32 [ 3, %sw.bb1354 ], [ 2, %sw.bb1353 ], [ 1, %sw.bb1352 ], [ 0, %sw.epilog44 ]
  %566 = load i8, ptr %in_eldecl1355, align 8
  %tobool1356.not = icmp eq i8 %566, 0
  br i1 %tobool1356.not, label %land.lhs.true1439, label %if.then1357

if.then1357:                                      ; preds = %closeGroup
  %567 = load ptr, ptr %m_elementDeclHandler1432, align 8
  %tobool1359.not.not = icmp eq ptr %567, null
  %spec.select727 = zext i1 %tobool1359.not.not to i8
  %568 = load i32, ptr %scaffLevel1362, align 4
  %dec = add i32 %568, -1
  store i32 %dec, ptr %scaffLevel1362, align 4
  %569 = load ptr, ptr %scaffold1363, align 8
  %570 = load ptr, ptr %scaffIndex1364, align 8
  %idxprom1366 = sext i32 %dec to i64
  %arrayidx1367 = getelementptr i32, ptr %570, i64 %idxprom1366
  %571 = load i32, ptr %arrayidx1367, align 4
  %idxprom1368 = sext i32 %571 to i64
  %quant1370 = getelementptr %struct.CONTENT_SCAFFOLD, ptr %569, i64 %idxprom1368, i32 1
  store i32 %quant.1, ptr %quant1370, align 4
  %572 = load i32, ptr %scaffLevel1362, align 4
  %cmp1372 = icmp eq i32 %572, 0
  br i1 %cmp1372, label %if.then1374, label %sw.epilog1436

if.then1374:                                      ; preds = %if.then1357
  br i1 %tobool1359.not.not, label %if.end1385, label %if.then1376

if.then1376:                                      ; preds = %if.then1374
  %parser.val = load ptr, ptr %3, align 8
  %parser.val734 = load ptr, ptr %m_dtd, align 8
  %scaffCount.i = getelementptr inbounds %struct.DTD, ptr %parser.val734, i64 0, i32 16
  %contentStringLen.i = getelementptr inbounds %struct.DTD, ptr %parser.val734, i64 0, i32 14
  %573 = load i32, ptr %contentStringLen.i, align 8
  %conv1.i = zext i32 %573 to i64
  %574 = load i32, ptr %scaffCount.i, align 8
  %conv.i1250 = zext i32 %574 to i64
  %mul.i = shl nuw nsw i64 %conv.i1250, 5
  %add.i1251 = add nuw nsw i64 %mul.i, %conv1.i
  %call.i1252 = call ptr %parser.val(i64 noundef %add.i1251) #24
  %tobool.not.i1253 = icmp eq ptr %call.i1252, null
  br i1 %tobool.not.i1253, label %return, label %if.end11.i

if.end11.i:                                       ; preds = %if.then1376
  %575 = load i32, ptr %scaffCount.i, align 8
  %idxprom.i = zext i32 %575 to i64
  %arrayidx.i1254 = getelementptr %struct.XML_cp, ptr %call.i1252, i64 %idxprom.i
  %numchildren.i = getelementptr inbounds %struct.XML_cp, ptr %call.i1252, i64 0, i32 3
  store i32 0, ptr %numchildren.i, align 8
  %cmp165.i = icmp ult ptr %call.i1252, %arrayidx.i1254
  br i1 %cmp165.i, label %for.body.lr.ph.i1255, label %if.end1380

for.body.lr.ph.i1255:                             ; preds = %if.end11.i
  %incdec.ptr.i1256 = getelementptr %struct.XML_cp, ptr %call.i1252, i64 1
  %scaffold.i = getelementptr inbounds %struct.DTD, ptr %parser.val734, i64 0, i32 13
  br label %for.body.i1257

for.body.i1257:                                   ; preds = %for.inc62.i, %for.body.lr.ph.i1255
  %jobDest.08.i = phi ptr [ %incdec.ptr.i1256, %for.body.lr.ph.i1255 ], [ %jobDest.2.i, %for.inc62.i ]
  %str.07.i = phi ptr [ %arrayidx.i1254, %for.body.lr.ph.i1255 ], [ %str.2.i, %for.inc62.i ]
  %dest.06.i = phi ptr [ %call.i1252, %for.body.lr.ph.i1255 ], [ %incdec.ptr63.i, %for.inc62.i ]
  %numchildren18.i = getelementptr inbounds %struct.XML_cp, ptr %dest.06.i, i64 0, i32 3
  %576 = load i32, ptr %numchildren18.i, align 8
  %577 = load ptr, ptr %scaffold.i, align 8
  %idxprom19.i = sext i32 %576 to i64
  %arrayidx20.i = getelementptr %struct.CONTENT_SCAFFOLD, ptr %577, i64 %idxprom19.i
  %578 = load i32, ptr %arrayidx20.i, align 8
  store i32 %578, ptr %dest.06.i, align 8
  %579 = load ptr, ptr %scaffold.i, align 8
  %quant.i = getelementptr %struct.CONTENT_SCAFFOLD, ptr %579, i64 %idxprom19.i, i32 1
  %580 = load i32, ptr %quant.i, align 4
  %quant25.i = getelementptr inbounds %struct.XML_cp, ptr %dest.06.i, i64 0, i32 1
  store i32 %580, ptr %quant25.i, align 4
  %cmp27.i = icmp eq i32 %578, 4
  %name.i = getelementptr inbounds %struct.XML_cp, ptr %dest.06.i, i64 0, i32 2
  br i1 %cmp27.i, label %if.then29.i1261, label %if.else.i1258

if.then29.i1261:                                  ; preds = %for.body.i1257
  store ptr %str.07.i, ptr %name.i, align 8
  %581 = load ptr, ptr %scaffold.i, align 8
  %name33.i = getelementptr %struct.CONTENT_SCAFFOLD, ptr %581, i64 %idxprom19.i, i32 2
  %582 = load ptr, ptr %name33.i, align 8
  br label %for.cond34.i

for.cond34.i:                                     ; preds = %for.cond34.i, %if.then29.i1261
  %str.1.i = phi ptr [ %str.07.i, %if.then29.i1261 ], [ %incdec.ptr35.i, %for.cond34.i ]
  %src.0.i = phi ptr [ %582, %if.then29.i1261 ], [ %incdec.ptr39.i, %for.cond34.i ]
  %583 = load i8, ptr %src.0.i, align 1
  %incdec.ptr35.i = getelementptr i8, ptr %str.1.i, i64 1
  store i8 %583, ptr %str.1.i, align 1
  %tobool36.not.i = icmp eq i8 %583, 0
  %incdec.ptr39.i = getelementptr i8, ptr %src.0.i, i64 1
  br i1 %tobool36.not.i, label %for.end.i1262, label %for.cond34.i

for.end.i1262:                                    ; preds = %for.cond34.i
  store i32 0, ptr %numchildren18.i, align 8
  %children.i = getelementptr inbounds %struct.XML_cp, ptr %dest.06.i, i64 0, i32 4
  store ptr null, ptr %children.i, align 8
  br label %for.inc62.i

if.else.i1258:                                    ; preds = %for.body.i1257
  store ptr null, ptr %name.i, align 8
  %584 = load ptr, ptr %scaffold.i, align 8
  %childcnt.i = getelementptr %struct.CONTENT_SCAFFOLD, ptr %584, i64 %idxprom19.i, i32 5
  %585 = load i32, ptr %childcnt.i, align 8
  store i32 %585, ptr %numchildren18.i, align 8
  %children46.i = getelementptr inbounds %struct.XML_cp, ptr %dest.06.i, i64 0, i32 4
  store ptr %jobDest.08.i, ptr %children46.i, align 8
  %cmp521.not.i = icmp eq i32 %585, 0
  br i1 %cmp521.not.i, label %for.inc62.i, label %for.body54.preheader.i

for.body54.preheader.i:                           ; preds = %if.else.i1258
  %586 = load ptr, ptr %scaffold.i, align 8
  %firstchild.i = getelementptr %struct.CONTENT_SCAFFOLD, ptr %586, i64 %idxprom19.i, i32 3
  br label %for.body54.i

for.body54.i:                                     ; preds = %for.body54.i, %for.body54.preheader.i
  %cn.0.in4.i = phi ptr [ %nextsib.i, %for.body54.i ], [ %firstchild.i, %for.body54.preheader.i ]
  %i.03.i = phi i32 [ %inc.i1259, %for.body54.i ], [ 0, %for.body54.preheader.i ]
  %jobDest.12.i = phi ptr [ %incdec.ptr55.i, %for.body54.i ], [ %jobDest.08.i, %for.body54.preheader.i ]
  %cn.0.i = load i32, ptr %cn.0.in4.i, align 4
  %incdec.ptr55.i = getelementptr %struct.XML_cp, ptr %jobDest.12.i, i64 1
  %numchildren56.i = getelementptr inbounds %struct.XML_cp, ptr %jobDest.12.i, i64 0, i32 3
  store i32 %cn.0.i, ptr %numchildren56.i, align 8
  %inc.i1259 = add nuw i32 %i.03.i, 1
  %587 = load ptr, ptr %scaffold.i, align 8
  %idxprom58.i = sext i32 %cn.0.i to i64
  %nextsib.i = getelementptr %struct.CONTENT_SCAFFOLD, ptr %587, i64 %idxprom58.i, i32 6
  %588 = load i32, ptr %numchildren18.i, align 8
  %cmp52.i = icmp ult i32 %inc.i1259, %588
  br i1 %cmp52.i, label %for.body54.i, label %for.inc62.i, !llvm.loop !37

for.inc62.i:                                      ; preds = %for.body54.i, %if.else.i1258, %for.end.i1262
  %str.2.i = phi ptr [ %incdec.ptr35.i, %for.end.i1262 ], [ %str.07.i, %if.else.i1258 ], [ %str.07.i, %for.body54.i ]
  %jobDest.2.i = phi ptr [ %jobDest.08.i, %for.end.i1262 ], [ %jobDest.08.i, %if.else.i1258 ], [ %incdec.ptr55.i, %for.body54.i ]
  %incdec.ptr63.i = getelementptr %struct.XML_cp, ptr %dest.06.i, i64 1
  %cmp16.i1260 = icmp ult ptr %incdec.ptr63.i, %arrayidx.i1254
  br i1 %cmp16.i1260, label %for.body.i1257, label %if.end1380, !llvm.loop !38

if.end1380:                                       ; preds = %for.inc62.i, %if.end11.i
  store ptr %s.addr.0, ptr %eventEndPP.0, align 8
  %589 = load ptr, ptr %m_elementDeclHandler1432, align 8
  %590 = load ptr, ptr %m_handlerArg1382, align 8
  %591 = load ptr, ptr %m_declElementType1383, align 8
  %592 = load ptr, ptr %591, align 8
  call void %589(ptr noundef %590, ptr noundef %592, ptr noundef nonnull %call.i1252) #24
  br label %if.end1385

if.end1385:                                       ; preds = %if.end1380, %if.then1374
  store i8 0, ptr %in_eldecl1355, align 8
  store i32 0, ptr %contentStringLen1387, align 8
  br label %sw.epilog1436

sw.bb1390:                                        ; preds = %sw.epilog44
  %593 = load ptr, ptr %next.addr, align 8
  %call1391 = call fastcc i32 @reportProcessingInstruction(ptr noundef %parser, ptr noundef %enc.addr.0, ptr noundef %s.addr.0, ptr noundef %593), !range !17
  %tobool1392.not = icmp eq i32 %call1391, 0
  br i1 %tobool1392.not, label %return, label %if.end1443

sw.bb1395:                                        ; preds = %sw.epilog44
  %594 = load ptr, ptr %next.addr, align 8
  %call1396 = call fastcc i32 @reportComment(ptr noundef %parser, ptr noundef %enc.addr.0, ptr noundef %s.addr.0, ptr noundef %594), !range !17
  %tobool1397.not = icmp eq i32 %call1396, 0
  br i1 %tobool1397.not, label %return, label %if.end1443

sw.bb1400:                                        ; preds = %sw.epilog44
  %cond1 = icmp eq i32 %tok.addr.1, 14
  br i1 %cond1, label %if.end1443, label %land.lhs.true1439

sw.bb1403:                                        ; preds = %sw.epilog44
  %595 = load ptr, ptr %m_startDoctypeDeclHandler1404, align 8
  %tobool1405.not = icmp eq ptr %595, null
  br i1 %tobool1405.not, label %land.lhs.true1439, label %if.end1443

sw.bb1408:                                        ; preds = %sw.epilog44
  %596 = load i8, ptr %keepProcessing1423, align 8
  %tobool1411.not = icmp eq i8 %596, 0
  br i1 %tobool1411.not, label %land.lhs.true1439, label %land.lhs.true1412

land.lhs.true1412:                                ; preds = %sw.bb1408
  %597 = load ptr, ptr %m_entityDeclHandler1413, align 8
  %tobool1414.not = icmp eq ptr %597, null
  br i1 %tobool1414.not, label %land.lhs.true1439, label %if.end1443

sw.bb1417:                                        ; preds = %sw.epilog44
  %598 = load ptr, ptr %m_notationDeclHandler1418, align 8
  %tobool1419.not = icmp eq ptr %598, null
  br i1 %tobool1419.not, label %land.lhs.true1439, label %if.end1443

sw.bb1422:                                        ; preds = %sw.epilog44
  %599 = load i8, ptr %keepProcessing1423, align 8
  %tobool1425.not = icmp eq i8 %599, 0
  br i1 %tobool1425.not, label %land.lhs.true1439, label %land.lhs.true1426

land.lhs.true1426:                                ; preds = %sw.bb1422
  %600 = load ptr, ptr %m_attlistDeclHandler1427, align 8
  %tobool1428.not = icmp eq ptr %600, null
  br i1 %tobool1428.not, label %land.lhs.true1439, label %if.end1443

sw.bb1431:                                        ; preds = %sw.epilog44
  %601 = load ptr, ptr %m_elementDeclHandler1432, align 8
  %tobool1433.not = icmp eq ptr %601, null
  br i1 %tobool1433.not, label %land.lhs.true1439, label %if.end1443

sw.epilog1436:                                    ; preds = %if.end656, %normalizePublicId.exit824, %if.end1385, %if.then1357, %if.end1273, %if.end1224, %land.lhs.true1227, %land.lhs.true1230, %sw.bb633, %land.lhs.true637, %if.end571, %if.end211, %alreadyChecked, %land.lhs.true117, %if.end1110, %poolClear.exit1178, %poolClear.exit1167, %poolClear.exit861, %if.end62
  %handleDefault.13 = phi i8 [ %spec.select727, %if.end1385 ], [ %spec.select727, %if.then1357 ], [ %handleDefault.11, %if.end1273 ], [ %handleDefault.10, %if.end1224 ], [ %handleDefault.10, %land.lhs.true1230 ], [ %handleDefault.10, %land.lhs.true1227 ], [ %handleDefault.9, %if.end1110 ], [ %handleDefault.8, %poolClear.exit1178 ], [ %handleDefault.7, %poolClear.exit1167 ], [ %handleDefault.6, %land.lhs.true637 ], [ %handleDefault.6, %sw.bb633 ], [ %handleDefault.4, %if.end571 ], [ %handleDefault.3, %poolClear.exit861 ], [ %handleDefault.2, %if.end211 ], [ %handleDefault.1, %land.lhs.true117 ], [ %handleDefault.1, %alreadyChecked ], [ %handleDefault.0, %if.end62 ], [ %handleDefault.1, %normalizePublicId.exit824 ], [ %handleDefault.6, %if.end656 ]
  %tobool1438.not = icmp eq i8 %handleDefault.13, 0
  br i1 %tobool1438.not, label %if.end1443, label %land.lhs.true1439

land.lhs.true1439:                                ; preds = %sw.bb1431, %land.lhs.true1426, %sw.bb1417, %land.lhs.true1412, %sw.bb1403, %if.end1343, %if.then1279, %land.lhs.true1058, %if.end1028, %lor.end848, %lor.end, %land.lhs.true302, %elementContent.thread, %sw.bb1400, %sw.bb63, %checkAttListDeclHandler, %sw.bb306, %land.lhs.true310, %sw.bb417, %if.end447, %land.lhs.true450, %sw.bb523, %sw.bb672, %land.lhs.true676, %land.lhs.true679, %sw.bb697, %land.lhs.true701, %if.else731, %if.else800, %if.then775, %if.then753, %if.else859, %if.then828, %sw.bb866, %if.end886, %if.end1017, %if.end1049, %if.then1167, %land.lhs.true1172, %if.else1220, %sw.bb1237, %sw.bb1250, %sw.bb1276, %elementContent, %closeGroup, %sw.bb1408, %sw.bb1422, %sw.epilog44, %sw.epilog1436
  %602 = load ptr, ptr %m_defaultHandler, align 8
  %tobool1441.not = icmp eq ptr %602, null
  br i1 %tobool1441.not, label %if.end1443, label %if.then1442

if.then1442:                                      ; preds = %land.lhs.true1439
  %603 = load ptr, ptr %next.addr, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %s.addr.i1263)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %dataPtr.i1264)
  store ptr %s.addr.0, ptr %s.addr.i1263, align 8
  %isUtf8.i1265 = getelementptr inbounds %struct.encoding, ptr %enc.addr.0, i64 0, i32 13
  %604 = load i8, ptr %isUtf8.i1265, align 4
  %tobool.not.i1266 = icmp eq i8 %604, 0
  br i1 %tobool.not.i1266, label %if.then.i1274, label %if.else9.i1267

if.then.i1274:                                    ; preds = %if.then1442
  %605 = load ptr, ptr %m_encoding, align 8
  %cmp.i1276 = icmp eq ptr %605, %enc.addr.0
  br i1 %cmp.i1276, label %if.end.i1280, label %if.else.i1277

if.else.i1277:                                    ; preds = %if.then.i1274
  %606 = load ptr, ptr %m_openInternalEntities1151, align 8
  %internalEventEndPtr.i1279 = getelementptr inbounds %struct.open_internal_entity, ptr %606, i64 0, i32 1
  br label %if.end.i1280

if.end.i1280:                                     ; preds = %if.then.i1274, %if.else.i1277
  %eventPP.0.i1281 = phi ptr [ %606, %if.else.i1277 ], [ %m_eventPtr.i, %if.then.i1274 ]
  %eventEndPP.0.i1282 = phi ptr [ %internalEventEndPtr.i1279, %if.else.i1277 ], [ %m_eventEndPtr.i, %if.then.i1274 ]
  %utf8Convert.i1284 = getelementptr inbounds %struct.encoding, ptr %enc.addr.0, i64 0, i32 10
  br label %do.body.i1288

do.body.i1288:                                    ; preds = %do.body.i1288, %if.end.i1280
  %607 = load ptr, ptr %m_dataBuf.i, align 8
  store ptr %607, ptr %dataPtr.i1264, align 8
  %608 = load ptr, ptr %utf8Convert.i1284, align 8
  %609 = load ptr, ptr %m_dataBufEnd.i, align 8
  %call.i1289 = call i32 %608(ptr noundef nonnull %enc.addr.0, ptr noundef nonnull %s.addr.i1263, ptr noundef %603, ptr noundef nonnull %dataPtr.i1264, ptr noundef %609) #24
  %610 = load ptr, ptr %s.addr.i1263, align 8
  store ptr %610, ptr %eventEndPP.0.i1282, align 8
  %611 = load ptr, ptr %m_defaultHandler, align 8
  %612 = load ptr, ptr %m_handlerArg1382, align 8
  %613 = load ptr, ptr %m_dataBuf.i, align 8
  %614 = load ptr, ptr %dataPtr.i1264, align 8
  %sub.ptr.lhs.cast.i1290 = ptrtoint ptr %614 to i64
  %sub.ptr.rhs.cast.i1291 = ptrtoint ptr %613 to i64
  %sub.ptr.sub.i1292 = sub i64 %sub.ptr.lhs.cast.i1290, %sub.ptr.rhs.cast.i1291
  %conv.i1293 = trunc i64 %sub.ptr.sub.i1292 to i32
  call void %611(ptr noundef %612, ptr noundef %613, i32 noundef %conv.i1293) #24
  %615 = load ptr, ptr %s.addr.i1263, align 8
  store ptr %615, ptr %eventPP.0.i1281, align 8
  %616 = icmp ugt i32 %call.i1289, 1
  br i1 %616, label %do.body.i1288, label %reportDefault.exit1297, !llvm.loop !28

if.else9.i1267:                                   ; preds = %if.then1442
  %617 = load ptr, ptr %m_handlerArg1382, align 8
  %sub.ptr.lhs.cast12.i1270 = ptrtoint ptr %603 to i64
  %sub.ptr.rhs.cast13.i1271 = ptrtoint ptr %s.addr.0 to i64
  %sub.ptr.sub14.i1272 = sub i64 %sub.ptr.lhs.cast12.i1270, %sub.ptr.rhs.cast13.i1271
  %conv15.i1273 = trunc i64 %sub.ptr.sub14.i1272 to i32
  call void %602(ptr noundef %617, ptr noundef %s.addr.0, i32 noundef %conv15.i1273) #24
  br label %reportDefault.exit1297

reportDefault.exit1297:                           ; preds = %do.body.i1288, %if.else9.i1267
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %s.addr.i1263)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %dataPtr.i1264)
  br label %if.end1443

if.end1443:                                       ; preds = %sw.bb1400, %if.end656, %normalizePublicId.exit824, %sw.bb1431, %land.lhs.true1426, %sw.bb1417, %land.lhs.true1412, %sw.bb1403, %sw.bb1395, %sw.bb1390, %if.end1343, %if.then1279, %if.then1185, %land.lhs.true1058, %if.end1028, %lor.end848, %lor.end, %land.lhs.true302, %if.end50, %poolClear.exit, %if.end80, %if.then213, %if.end330, %poolClear.exit891, %if.then682, %if.then734, %if.then718, %if.end875, %normalizePublicId.exit1126, %if.else963, %if.then1174, %if.then1216, %if.end1246, %reportDefault.exit1297, %land.lhs.true1439, %sw.epilog1436
  %enc.addr.11359 = phi ptr [ %enc.addr.0, %reportDefault.exit1297 ], [ %enc.addr.0, %land.lhs.true1439 ], [ %enc.addr.0, %sw.epilog1436 ], [ %enc.addr.0, %sw.bb1431 ], [ %enc.addr.0, %land.lhs.true1426 ], [ %enc.addr.0, %sw.bb1417 ], [ %enc.addr.0, %land.lhs.true1412 ], [ %enc.addr.0, %sw.bb1403 ], [ %enc.addr.0, %sw.bb1395 ], [ %enc.addr.0, %sw.bb1390 ], [ %enc.addr.0, %if.end1343 ], [ %enc.addr.0, %if.then1279 ], [ %enc.addr.0, %if.then1185 ], [ %enc.addr.0, %land.lhs.true1058 ], [ %enc.addr.0, %if.end1028 ], [ %enc.addr.0, %lor.end848 ], [ %enc.addr.0, %lor.end ], [ %enc.addr.0, %land.lhs.true302 ], [ %19, %if.end50 ], [ %enc.addr.0, %poolClear.exit ], [ %41, %if.end80 ], [ %enc.addr.0, %if.then213 ], [ %enc.addr.0, %if.end330 ], [ %enc.addr.0, %poolClear.exit891 ], [ %enc.addr.0, %if.then682 ], [ %enc.addr.0, %if.then734 ], [ %enc.addr.0, %if.then718 ], [ %enc.addr.0, %if.end875 ], [ %enc.addr.0, %normalizePublicId.exit1126 ], [ %enc.addr.0, %if.else963 ], [ %enc.addr.0, %if.then1174 ], [ %enc.addr.0, %if.then1216 ], [ %enc.addr.0, %if.end1246 ], [ %enc.addr.0, %normalizePublicId.exit824 ], [ %enc.addr.0, %if.end656 ], [ %enc.addr.0, %sw.bb1400 ]
  %618 = load i32, ptr %m_parsingStatus, align 8
  switch i32 %618, label %sw.default1446 [
    i32 3, label %sw.bb1444
    i32 2, label %return
  ]

sw.bb1444:                                        ; preds = %if.end1443
  %619 = load ptr, ptr %next.addr, align 8
  store ptr %619, ptr %nextPtr, align 8
  br label %return

sw.default1446:                                   ; preds = %if.end1443
  %620 = load ptr, ptr %next.addr, align 8
  %621 = load ptr, ptr %enc.addr.11359, align 8
  %call1448 = call i32 %621(ptr noundef nonnull %enc.addr.11359, ptr noundef %620, ptr noundef %end, ptr noundef nonnull %next.addr) #24
  br label %for.cond

return.loopexit2043:                              ; preds = %if.end7
  br label %return

return:                                           ; preds = %if.then1376, %land.lhs.true.i1208, %poolAppend.exit.i1201, %land.lhs.true.i1148, %poolAppend.exit.i1141, %land.lhs.true.i1093, %poolAppend.exit.i1086, %land.lhs.true.i1033, %poolAppend.exit.i1026, %land.lhs.true.i1003, %poolAppend.exit.i996, %if.end36.i, %if.else.i875, %land.lhs.true14.i, %if.then420, %land.lhs.true.i791, %poolAppend.exit.i784, %land.lhs.true.i759, %poolAppend.exit.i752, %if.end1443, %sw.bb1395, %sw.bb1390, %for.end, %if.end1316, %cond.end, %if.then1256, %if.then1240, %land.lhs.true1230, %if.then1185, %if.end1179, %if.else1159, %if.then1156, %poolStoreString.exit1216, %sw.bb1063, %sw.bb1039, %if.then1023, %if.then992, %if.then976, %if.end958, %poolStoreString.exit1156, %poolStoreString.exit1101, %sw.bb881, %poolStoreString.exit1071, %if.end816, %poolStoreString.exit1041, %if.end764, %poolStoreString.exit1011, %poolStoreString.exit981, %poolStoreString.exit951, %if.then622, %land.lhs.true613, %poolStoreString.exit921, %if.end571, %land.lhs.true476, %land.lhs.true492, %land.lhs.true374, %land.lhs.true387, %if.then338, %poolAppend.exit, %poolAppendString.exit, %sw.bb275, %sw.bb269, %land.lhs.true195, %if.end181, %if.then172, %sw.bb144, %poolStoreString.exit799, %sw.bb109, %poolStoreString.exit767, %if.then90, %sw.bb82, %sw.bb74, %poolStoreString.exit, %sw.bb45, %land.lhs.true.i842, %if.end7, %return.loopexit2043, %poolAppend.exit.thread.i1199, %poolAppend.exit.thread.i1139, %poolAppend.exit.thread.i1084, %poolAppend.exit.thread.i1024, %poolAppend.exit.thread.i994, %if.then29.i, %poolAppend.exit.thread.i782, %poolAppend.exit.thread.i750, %poolStoreString.exit1071.thread, %poolStoreString.exit921.thread, %poolAppend.exit.thread, %poolStoreString.exit.thread, %accountingGetCurrentAmplification.exit.i.i, %getRootParserOf.exit.i.i, %if.end19, %sw.bb950, %land.lhs.true256, %if.end235, %if.then229, %if.then25, %sw.bb1444, %if.then1210, %if.then1013, %if.then987, %if.then965, %if.end267, %if.end30, %if.then18, %sw.bb, %if.then6
  %retval.0 = phi i32 [ 0, %if.then6 ], [ 0, %sw.bb1444 ], [ 21, %if.then1210 ], [ 1, %if.then987 ], [ 1, %if.then1013 ], [ 0, %if.then965 ], [ %call268, %if.end267 ], [ 0, %if.end30 ], [ 0, %if.then18 ], [ 4, %sw.bb ], [ 29, %if.then25 ], [ 1, %if.then229 ], [ 21, %if.end235 ], [ 22, %land.lhs.true256 ], [ %switch.select720, %sw.bb950 ], [ 3, %if.end19 ], [ 43, %getRootParserOf.exit.i.i ], [ 43, %accountingGetCurrentAmplification.exit.i.i ], [ 1, %poolStoreString.exit.thread ], [ 1, %poolAppend.exit.thread ], [ 1, %poolStoreString.exit921.thread ], [ 1, %poolStoreString.exit1071.thread ], [ 1, %poolAppend.exit.thread.i750 ], [ 1, %poolAppend.exit.thread.i782 ], [ 1, %if.then29.i ], [ 1, %poolAppend.exit.thread.i994 ], [ 1, %poolAppend.exit.thread.i1024 ], [ 1, %poolAppend.exit.thread.i1084 ], [ 1, %poolAppend.exit.thread.i1139 ], [ 1, %poolAppend.exit.thread.i1199 ], [ 6, %if.end7 ], [ 1, %land.lhs.true.i842 ], [ 1, %if.then1376 ], [ 1, %land.lhs.true.i1208 ], [ 1, %poolAppend.exit.i1201 ], [ 1, %land.lhs.true.i1148 ], [ 1, %poolAppend.exit.i1141 ], [ 1, %land.lhs.true.i1093 ], [ 1, %poolAppend.exit.i1086 ], [ 1, %land.lhs.true.i1033 ], [ 1, %poolAppend.exit.i1026 ], [ 1, %land.lhs.true.i1003 ], [ 1, %poolAppend.exit.i996 ], [ 1, %if.end36.i ], [ 1, %if.else.i875 ], [ %call.i862, %if.then420 ], [ 1, %land.lhs.true14.i ], [ 1, %land.lhs.true.i791 ], [ 1, %poolAppend.exit.i784 ], [ 1, %land.lhs.true.i759 ], [ 1, %poolAppend.exit.i752 ], [ 35, %if.end1443 ], [ 1, %sw.bb1395 ], [ 1, %sw.bb1390 ], [ 1, %for.end ], [ 1, %if.end1316 ], [ 1, %cond.end ], [ 1, %if.then1256 ], [ 1, %if.then1240 ], [ 22, %land.lhs.true1230 ], [ %call1192, %if.then1185 ], [ 12, %if.end1179 ], [ 24, %if.else1159 ], [ 11, %if.then1156 ], [ 1, %poolStoreString.exit1216 ], [ 2, %sw.bb1063 ], [ 2, %sw.bb1039 ], [ 1, %if.then1023 ], [ 1, %if.then992 ], [ 1, %if.then976 ], [ %call959, %if.end958 ], [ 1, %poolStoreString.exit1156 ], [ 1, %poolStoreString.exit1101 ], [ 32, %sw.bb881 ], [ 1, %poolStoreString.exit1071 ], [ 1, %if.end816 ], [ 1, %poolStoreString.exit1041 ], [ 1, %if.end764 ], [ 1, %poolStoreString.exit1011 ], [ 1, %poolStoreString.exit981 ], [ 1, %poolStoreString.exit951 ], [ 1, %if.then622 ], [ 22, %land.lhs.true613 ], [ 1, %poolStoreString.exit921 ], [ %call535, %if.end571 ], [ 1, %land.lhs.true476 ], [ 1, %land.lhs.true492 ], [ 1, %land.lhs.true374 ], [ 1, %land.lhs.true387 ], [ 1, %if.then338 ], [ 1, %poolAppend.exit ], [ 1, %poolAppendString.exit ], [ 1, %sw.bb275 ], [ 1, %sw.bb269 ], [ 22, %land.lhs.true195 ], [ 21, %if.end181 ], [ 1, %if.then172 ], [ 4, %sw.bb144 ], [ 1, %poolStoreString.exit799 ], [ 32, %sw.bb109 ], [ 1, %poolStoreString.exit767 ], [ 32, %if.then90 ], [ 1, %sw.bb82 ], [ %call76, %sw.bb74 ], [ 1, %poolStoreString.exit ], [ %call46, %sw.bb45 ], [ 5, %return.loopexit2043 ]
  ret i32 %retval.0
}

; Function Attrs: nofree nounwind uwtable
define internal fastcc zeroext i8 @accountingDiffTolerated(ptr noundef %originParser, i32 noundef %tok, ptr noundef %before, ptr noundef %after, i32 noundef %source_line, i32 noundef %account) unnamed_addr #12 {
entry:
  %switch.tableidx = add i32 %tok, 4
  %0 = icmp ult i32 %switch.tableidx, 5
  br i1 %0, label %switch.hole_check, label %sw.epilog

sw.epilog:                                        ; preds = %entry
  %cmp.old = icmp eq i32 %account, 2
  br i1 %cmp.old, label %return, label %while.cond.i.preheader

while.cond.i.preheader:                           ; preds = %sw.epilog, %switch.hole_check
  br label %while.cond.i

while.cond.i:                                     ; preds = %while.cond.i.preheader, %while.cond.i
  %rootParser.0.i = phi ptr [ %1, %while.cond.i ], [ %originParser, %while.cond.i.preheader ]
  %stepsTakenUpwards.0.i = phi i32 [ %inc.i, %while.cond.i ], [ 0, %while.cond.i.preheader ]
  %m_parentParser.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i, i64 0, i32 84
  %1 = load ptr, ptr %m_parentParser.i, align 8
  %tobool.not.i = icmp eq ptr %1, null
  %inc.i = add i32 %stepsTakenUpwards.0.i, 1
  br i1 %tobool.not.i, label %getRootParserOf.exit, label %while.cond.i, !llvm.loop !31

getRootParserOf.exit:                             ; preds = %while.cond.i
  %cmp1 = icmp eq i32 %account, 0
  %cmp2 = icmp eq ptr %rootParser.0.i, %originParser
  %2 = and i1 %cmp1, %cmp2
  %sub.ptr.lhs.cast = ptrtoint ptr %after to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %before to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %m_accounting = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i, i64 0, i32 90
  %countBytesIndirect = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i, i64 0, i32 90, i32 1
  %cond = select i1 %2, ptr %m_accounting, ptr %countBytesIndirect
  %3 = load i64, ptr %cond, align 8
  %sub = xor i64 %sub.ptr.sub, -1
  %cmp4 = icmp ugt i64 %3, %sub
  br i1 %cmp4, label %return, label %if.end6

if.end6:                                          ; preds = %getRootParserOf.exit
  %add = add i64 %3, %sub.ptr.sub
  store i64 %add, ptr %cond, align 8
  %4 = load i64, ptr %m_accounting, align 8
  %5 = load i64, ptr %countBytesIndirect, align 8
  %add11 = add i64 %5, %4
  %activationThresholdBytes = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i, i64 0, i32 90, i32 4
  %6 = load i64, ptr %activationThresholdBytes, align 8
  %cmp14 = icmp ult i64 %add11, %6
  br i1 %cmp14, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.end6
  %tobool.not.i19 = icmp eq i64 %4, 0
  %conv.i = uitofp i64 %add11 to float
  %conv6.i = uitofp i64 %4 to float
  %div.i = fdiv float %conv.i, %conv6.i
  %cond.i = select i1 %tobool.not.i19, float 1.000000e+00, float %div.i
  %maximumAmplificationFactor = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i, i64 0, i32 90, i32 3
  %7 = load float, ptr %maximumAmplificationFactor, align 4
  %cmp16 = fcmp ole float %cond.i, %7
  %8 = zext i1 %cmp16 to i8
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.end6
  %conv = phi i8 [ 1, %if.end6 ], [ %8, %lor.rhs ]
  %debugLevel = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i, i64 0, i32 90, i32 2
  %9 = load i32, ptr %debugLevel, align 8
  %cmp18 = icmp sgt i32 %9, 1
  br i1 %cmp18, label %while.cond.i.i, label %return

while.cond.i.i:                                   ; preds = %lor.end, %while.cond.i.i
  %rootParser.0.i.i = phi ptr [ %10, %while.cond.i.i ], [ %rootParser.0.i, %lor.end ]
  %m_parentParser.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i, i64 0, i32 84
  %10 = load ptr, ptr %m_parentParser.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %10, null
  br i1 %tobool.not.i.i, label %getRootParserOf.exit.i, label %while.cond.i.i, !llvm.loop !31

getRootParserOf.exit.i:                           ; preds = %while.cond.i.i
  %debugLevel.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i, i64 0, i32 90, i32 2
  %11 = load i32, ptr %debugLevel.i, align 8
  %cmp.i = icmp slt i32 %11, 1
  br i1 %cmp.i, label %accountingReportStats.exit, label %if.end.i

if.end.i:                                         ; preds = %getRootParserOf.exit.i
  %m_accounting.i20 = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i, i64 0, i32 90
  %12 = load i64, ptr %m_accounting.i20, align 8
  %tobool.not.i5.i = icmp eq i64 %12, 0
  %countBytesIndirect.phi.trans.insert.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i, i64 0, i32 90, i32 1
  %.pre.i = load i64, ptr %countBytesIndirect.phi.trans.insert.i, align 8
  br i1 %tobool.not.i5.i, label %accountingGetCurrentAmplification.exit.i, label %cond.true.i.i

cond.true.i.i:                                    ; preds = %if.end.i
  %add.i.i = add i64 %.pre.i, %12
  %conv.i.i = uitofp i64 %add.i.i to float
  %conv6.i.i = uitofp i64 %12 to float
  %div.i.i = fdiv float %conv.i.i, %conv6.i.i
  %13 = fpext float %div.i.i to double
  br label %accountingGetCurrentAmplification.exit.i

accountingGetCurrentAmplification.exit.i:         ; preds = %cond.true.i.i, %if.end.i
  %cond.i.i = phi double [ %13, %cond.true.i.i ], [ 1.000000e+00, %if.end.i ]
  %14 = load ptr, ptr @stderr, align 8
  %call4.i = tail call i32 (ptr, ptr, ...) @fprintf(ptr noundef %14, ptr noundef nonnull @.str.311, ptr noundef nonnull %rootParser.0.i.i, i64 noundef %12, i64 noundef %.pre.i, double noundef %cond.i.i, ptr noundef nonnull @.str.310) #27
  br label %accountingReportStats.exit

accountingReportStats.exit:                       ; preds = %getRootParserOf.exit.i, %accountingGetCurrentAmplification.exit.i
  %15 = load ptr, ptr @stderr, align 8
  %cond.i22 = select i1 %cmp1, ptr @.str.313, ptr @.str.314
  %call.i = tail call i32 (ptr, ptr, ...) @fprintf(ptr noundef %15, ptr noundef nonnull @.str.312, i64 noundef %sub.ptr.sub, ptr noundef nonnull %cond.i22, i32 noundef %stepsTakenUpwards.0.i, i32 noundef %source_line, i32 noundef 10, ptr noundef nonnull @.str.310) #27
  %16 = load i32, ptr %debugLevel, align 8
  %cmp1.i = icmp sgt i32 %16, 2
  %cmp2.i = icmp slt i64 %sub.ptr.sub, 25
  %or.cond.i = or i1 %cmp2.i, %cmp1.i
  br i1 %or.cond.i, label %for.cond.preheader.i, label %for.cond6.preheader.i

for.cond6.preheader.i:                            ; preds = %accountingReportStats.exit
  %add.ptr.i = getelementptr i8, ptr %before, i64 10
  %cmp717.i = icmp ugt ptr %add.ptr.i, %before
  br i1 %cmp717.i, label %for.body8.i, label %for.end14.i

for.cond.preheader.i:                             ; preds = %accountingReportStats.exit
  %cmp321.i = icmp ult ptr %before, %after
  br i1 %cmp321.i, label %for.body.preheader.i, label %accountingReportDiff.exit

for.body.preheader.i:                             ; preds = %for.cond.preheader.i
  %scevgep.i = getelementptr i8, ptr %before, i64 %sub.ptr.sub
  br label %for.body.i

for.body.i:                                       ; preds = %for.body.i, %for.body.preheader.i
  %walker.022.i = phi ptr [ %incdec.ptr.i, %for.body.i ], [ %before, %for.body.preheader.i ]
  %17 = load ptr, ptr @stderr, align 8
  %18 = load i8, ptr %walker.022.i, align 1
  %call4.i25 = tail call ptr @PyExpat_unsignedCharToPrintable(i8 noundef zeroext %18)
  %fputs15.i = tail call i32 @fputs(ptr nonnull %call4.i25, ptr %17) #27
  %incdec.ptr.i = getelementptr i8, ptr %walker.022.i, i64 1
  %exitcond25.not.i = icmp eq ptr %incdec.ptr.i, %scevgep.i
  br i1 %exitcond25.not.i, label %accountingReportDiff.exit, label %for.body.i, !llvm.loop !39

for.body8.i:                                      ; preds = %for.cond6.preheader.i, %for.body8.i
  %walker.118.i = phi ptr [ %incdec.ptr13.i, %for.body8.i ], [ %before, %for.cond6.preheader.i ]
  %19 = load ptr, ptr @stderr, align 8
  %20 = load i8, ptr %walker.118.i, align 1
  %call10.i = tail call ptr @PyExpat_unsignedCharToPrintable(i8 noundef zeroext %20)
  %fputs14.i = tail call i32 @fputs(ptr nonnull %call10.i, ptr %19) #27
  %incdec.ptr13.i = getelementptr i8, ptr %walker.118.i, i64 1
  %exitcond.not.i = icmp eq ptr %incdec.ptr13.i, %add.ptr.i
  br i1 %exitcond.not.i, label %for.end14.i, label %for.body8.i, !llvm.loop !40

for.end14.i:                                      ; preds = %for.body8.i, %for.cond6.preheader.i
  %21 = load ptr, ptr @stderr, align 8
  %22 = tail call i64 @fwrite(ptr nonnull @__const.accountingReportDiff.ellipis, i64 4, i64 1, ptr %21) #27
  %add.ptr16.i = getelementptr i8, ptr %after, i64 -10
  %cmp1819.i = icmp ult ptr %add.ptr16.i, %after
  br i1 %cmp1819.i, label %for.body19.i, label %accountingReportDiff.exit

for.body19.i:                                     ; preds = %for.end14.i, %for.body19.i
  %walker.220.i = phi ptr [ %incdec.ptr24.i, %for.body19.i ], [ %add.ptr16.i, %for.end14.i ]
  %23 = load ptr, ptr @stderr, align 8
  %24 = load i8, ptr %walker.220.i, align 1
  %call21.i = tail call ptr @PyExpat_unsignedCharToPrintable(i8 noundef zeroext %24)
  %fputs.i = tail call i32 @fputs(ptr nonnull %call21.i, ptr %23) #27
  %incdec.ptr24.i = getelementptr i8, ptr %walker.220.i, i64 1
  %exitcond24.not.i = icmp eq ptr %incdec.ptr24.i, %after
  br i1 %exitcond24.not.i, label %accountingReportDiff.exit, label %for.body19.i, !llvm.loop !41

accountingReportDiff.exit:                        ; preds = %for.body19.i, %for.body.i, %for.cond.preheader.i, %for.end14.i
  %25 = load ptr, ptr @stderr, align 8
  %26 = tail call i64 @fwrite(ptr nonnull @.str.316, i64 2, i64 1, ptr %25) #27
  br label %return

switch.hole_check:                                ; preds = %entry
  %switch.maskindex = trunc i32 %switch.tableidx to i8
  %switch.shifted = lshr i8 29, %switch.maskindex
  %27 = and i8 %switch.shifted, 1
  %switch.lobit = icmp ne i8 %27, 0
  %cmp = icmp eq i32 %account, 2
  %or.cond = or i1 %switch.lobit, %cmp
  br i1 %or.cond, label %return, label %while.cond.i.preheader

return:                                           ; preds = %switch.hole_check, %lor.end, %accountingReportDiff.exit, %getRootParserOf.exit, %sw.epilog
  %retval.0 = phi i8 [ 1, %sw.epilog ], [ 0, %getRootParserOf.exit ], [ %conv, %accountingReportDiff.exit ], [ %conv, %lor.end ], [ 1, %switch.hole_check ]
  ret i8 %retval.0
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @processXmlDecl(ptr noundef %parser, i32 noundef %isGeneralTextEntity, ptr noundef %s, ptr noundef %next) unnamed_addr #0 {
entry:
  %info.i = alloca %struct.XML_Encoding, align 8
  %s.addr.i = alloca ptr, align 8
  %dataPtr.i = alloca ptr, align 8
  %ptr.addr.i.i57 = alloca ptr, align 8
  %ptr.addr.i.i = alloca ptr, align 8
  %encodingName = alloca ptr, align 8
  %newEncoding = alloca ptr, align 8
  %version = alloca ptr, align 8
  %versionend = alloca ptr, align 8
  %standalone = alloca i32, align 4
  store ptr null, ptr %encodingName, align 8
  store ptr null, ptr %newEncoding, align 8
  store ptr null, ptr %version, align 8
  store ptr null, ptr %versionend, align 8
  store i32 -1, ptr %standalone, align 4
  %call = tail call fastcc zeroext i8 @accountingDiffTolerated(ptr noundef %parser, i32 noundef 12, ptr noundef %s, ptr noundef %next, i32 noundef 4288, i32 noundef 0), !range !13
  %tobool.not = icmp eq i8 %call, 0
  br i1 %tobool.not, label %while.cond.i.i.i, label %if.end

while.cond.i.i.i:                                 ; preds = %entry, %while.cond.i.i.i
  %rootParser.0.i.i.i = phi ptr [ %0, %while.cond.i.i.i ], [ %parser, %entry ]
  %m_parentParser.i.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i.i, i64 0, i32 84
  %0 = load ptr, ptr %m_parentParser.i.i.i, align 8
  %tobool.not.i.i.i = icmp eq ptr %0, null
  br i1 %tobool.not.i.i.i, label %getRootParserOf.exit.i.i, label %while.cond.i.i.i, !llvm.loop !31

getRootParserOf.exit.i.i:                         ; preds = %while.cond.i.i.i
  %debugLevel.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i.i, i64 0, i32 90, i32 2
  %1 = load i32, ptr %debugLevel.i.i, align 8
  %cmp.i.i = icmp slt i32 %1, 1
  br i1 %cmp.i.i, label %return, label %if.end.i.i

if.end.i.i:                                       ; preds = %getRootParserOf.exit.i.i
  %m_accounting.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i.i, i64 0, i32 90
  %2 = load i64, ptr %m_accounting.i.i, align 8
  %tobool.not.i5.i.i = icmp eq i64 %2, 0
  %countBytesIndirect.phi.trans.insert.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i.i, i64 0, i32 90, i32 1
  %.pre.i.i = load i64, ptr %countBytesIndirect.phi.trans.insert.i.i, align 8
  br i1 %tobool.not.i5.i.i, label %accountingGetCurrentAmplification.exit.i.i, label %cond.true.i.i.i

cond.true.i.i.i:                                  ; preds = %if.end.i.i
  %add.i.i.i = add i64 %.pre.i.i, %2
  %conv.i.i.i = uitofp i64 %add.i.i.i to float
  %conv6.i.i.i = uitofp i64 %2 to float
  %div.i.i.i = fdiv float %conv.i.i.i, %conv6.i.i.i
  %3 = fpext float %div.i.i.i to double
  br label %accountingGetCurrentAmplification.exit.i.i

accountingGetCurrentAmplification.exit.i.i:       ; preds = %cond.true.i.i.i, %if.end.i.i
  %cond.i.i.i = phi double [ %3, %cond.true.i.i.i ], [ 1.000000e+00, %if.end.i.i ]
  %4 = load ptr, ptr @stderr, align 8
  %call4.i.i = tail call i32 (ptr, ptr, ...) @fprintf(ptr noundef %4, ptr noundef nonnull @.str.311, ptr noundef nonnull %rootParser.0.i.i.i, i64 noundef %2, i64 noundef %.pre.i.i, double noundef %cond.i.i.i, ptr noundef nonnull @.str.317) #27
  br label %return

if.end:                                           ; preds = %entry
  %m_ns = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 38
  %5 = load i8, ptr %m_ns, align 8
  %tobool1.not = icmp eq i8 %5, 0
  %cond = select i1 %tobool1.not, ptr @PyExpat_XmlParseXmlDecl, ptr @PyExpat_XmlParseXmlDeclNS
  %m_encoding = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 34
  %6 = load ptr, ptr %m_encoding, align 8
  %m_eventPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 47
  %call2 = call i32 %cond(i32 noundef %isGeneralTextEntity, ptr noundef %6, ptr noundef %s, ptr noundef %next, ptr noundef nonnull %m_eventPtr, ptr noundef nonnull %version, ptr noundef nonnull %versionend, ptr noundef nonnull %encodingName, ptr noundef nonnull %newEncoding, ptr noundef nonnull %standalone) #24, !callees !42
  %tobool3.not = icmp eq i32 %call2, 0
  %tobool5.not = icmp eq i32 %isGeneralTextEntity, 0
  br i1 %tobool3.not, label %if.then4, label %if.end7

if.then4:                                         ; preds = %if.end
  %. = select i1 %tobool5.not, i32 30, i32 31
  br label %return

if.end7:                                          ; preds = %if.end
  %7 = load i32, ptr %standalone, align 4
  %cmp = icmp eq i32 %7, 1
  %or.cond = select i1 %tobool5.not, i1 %cmp, i1 false
  br i1 %or.cond, label %if.then10, label %if.end17

if.then10:                                        ; preds = %if.end7
  %m_dtd = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 65
  %8 = load ptr, ptr %m_dtd, align 8
  %standalone11 = getelementptr inbounds %struct.DTD, ptr %8, i64 0, i32 8
  store i8 1, ptr %standalone11, align 2
  %m_paramEntityParsing = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 88
  %9 = load i32, ptr %m_paramEntityParsing, align 4
  %cmp12 = icmp eq i32 %9, 1
  br i1 %cmp12, label %if.then14, label %if.end17

if.then14:                                        ; preds = %if.then10
  store i32 0, ptr %m_paramEntityParsing, align 4
  br label %if.end17

if.end17:                                         ; preds = %if.then10, %if.then14, %if.end7
  %m_xmlDeclHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 33
  %10 = load ptr, ptr %m_xmlDeclHandler, align 8
  %tobool18.not = icmp eq ptr %10, null
  br i1 %tobool18.not, label %if.else47, label %if.then19

if.then19:                                        ; preds = %if.end17
  %11 = load ptr, ptr %encodingName, align 8
  %cmp20.not = icmp eq ptr %11, null
  br i1 %cmp20.not, label %if.end33, label %if.then22

if.then22:                                        ; preds = %if.then19
  %m_temp2Pool = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 80
  %12 = load ptr, ptr %m_encoding, align 8
  %nameLength = getelementptr inbounds %struct.encoding, ptr %12, i64 0, i32 3
  %13 = load ptr, ptr %nameLength, align 8
  %call26 = call i32 %13(ptr noundef %12, ptr noundef nonnull %11) #24
  %idx.ext = sext i32 %call26 to i64
  %add.ptr = getelementptr i8, ptr %11, i64 %idx.ext
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ptr.addr.i.i)
  store ptr %11, ptr %ptr.addr.i.i, align 8
  %ptr1.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 80, i32 3
  %14 = load ptr, ptr %ptr1.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %14, null
  br i1 %tobool.not.i.i, label %land.lhs.true.i.i, label %if.end.i.i56

land.lhs.true.i.i:                                ; preds = %if.then22
  %call.i.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_temp2Pool), !range !13
  %tobool2.not.i.i = icmp eq i8 %call.i.i, 0
  br i1 %tobool2.not.i.i, label %poolAppend.exit.thread.i, label %if.end.i.i56

if.end.i.i56:                                     ; preds = %land.lhs.true.i.i, %if.then22
  %utf8Convert.i.i = getelementptr inbounds %struct.encoding, ptr %12, i64 0, i32 10
  %end4.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 80, i32 2
  br label %for.cond.i.i

for.cond.i.i:                                     ; preds = %if.end8.i.i, %if.end.i.i56
  %15 = load ptr, ptr %utf8Convert.i.i, align 8
  %16 = load ptr, ptr %end4.i.i, align 8
  %call5.i.i = call i32 %15(ptr noundef nonnull %12, ptr noundef nonnull %ptr.addr.i.i, ptr noundef %add.ptr, ptr noundef nonnull %ptr1.i.i, ptr noundef %16) #24
  %or.cond.i.i = icmp ult i32 %call5.i.i, 2
  br i1 %or.cond.i.i, label %poolAppend.exit.i, label %if.end8.i.i

if.end8.i.i:                                      ; preds = %for.cond.i.i
  %call9.i.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_temp2Pool), !range !13
  %tobool10.not.i.i = icmp eq i8 %call9.i.i, 0
  br i1 %tobool10.not.i.i, label %poolAppend.exit.thread.i, label %for.cond.i.i

poolAppend.exit.thread.i:                         ; preds = %if.end8.i.i, %land.lhs.true.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i)
  br label %return

poolAppend.exit.i:                                ; preds = %for.cond.i.i
  %start.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 80, i32 4
  %17 = load ptr, ptr %start.i.i, align 8
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i)
  %tobool.not.i = icmp eq ptr %17, null
  br i1 %tobool.not.i, label %return, label %if.end.i

if.end.i:                                         ; preds = %poolAppend.exit.i
  %18 = load ptr, ptr %ptr1.i.i, align 8
  %19 = load ptr, ptr %end4.i.i, align 8
  %cmp.i = icmp eq ptr %18, %19
  br i1 %cmp.i, label %land.lhs.true.i, label %poolStoreString.exit

land.lhs.true.i:                                  ; preds = %if.end.i
  %call3.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_temp2Pool), !range !13
  %tobool4.not.i = icmp eq i8 %call3.i, 0
  br i1 %tobool4.not.i, label %return, label %land.lhs.true.if.end6_crit_edge.i

land.lhs.true.if.end6_crit_edge.i:                ; preds = %land.lhs.true.i
  %.pre.i = load ptr, ptr %ptr1.i.i, align 8
  br label %poolStoreString.exit

poolStoreString.exit:                             ; preds = %if.end.i, %land.lhs.true.if.end6_crit_edge.i
  %20 = phi ptr [ %.pre.i, %land.lhs.true.if.end6_crit_edge.i ], [ %18, %if.end.i ]
  %incdec.ptr.i = getelementptr i8, ptr %20, i64 1
  store ptr %incdec.ptr.i, ptr %ptr1.i.i, align 8
  store i8 0, ptr %20, align 1
  %21 = load ptr, ptr %start.i.i, align 8
  %tobool28.not = icmp eq ptr %21, null
  br i1 %tobool28.not, label %return, label %if.end30

if.end30:                                         ; preds = %poolStoreString.exit
  %22 = load ptr, ptr %ptr1.i.i, align 8
  store ptr %22, ptr %start.i.i, align 8
  br label %if.end33

if.end33:                                         ; preds = %if.end30, %if.then19
  %storedEncName.0 = phi ptr [ %21, %if.end30 ], [ null, %if.then19 ]
  %23 = load ptr, ptr %version, align 8
  %tobool34.not = icmp eq ptr %23, null
  br i1 %tobool34.not, label %if.end45, label %if.then35

if.then35:                                        ; preds = %if.end33
  %m_temp2Pool36 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 80
  %24 = load ptr, ptr %m_encoding, align 8
  %25 = load ptr, ptr %versionend, align 8
  %minBytesPerChar = getelementptr inbounds %struct.encoding, ptr %24, i64 0, i32 12
  %26 = load i32, ptr %minBytesPerChar, align 8
  %idx.ext39 = sext i32 %26 to i64
  %idx.neg = sub nsw i64 0, %idx.ext39
  %add.ptr40 = getelementptr i8, ptr %25, i64 %idx.neg
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ptr.addr.i.i57)
  store ptr %23, ptr %ptr.addr.i.i57, align 8
  %ptr1.i.i58 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 80, i32 3
  %27 = load ptr, ptr %ptr1.i.i58, align 8
  %tobool.not.i.i59 = icmp eq ptr %27, null
  br i1 %tobool.not.i.i59, label %land.lhs.true.i.i83, label %if.end.i.i60

land.lhs.true.i.i83:                              ; preds = %if.then35
  %call.i.i84 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_temp2Pool36), !range !13
  %tobool2.not.i.i85 = icmp eq i8 %call.i.i84, 0
  br i1 %tobool2.not.i.i85, label %poolAppend.exit.thread.i69, label %if.end.i.i60

if.end.i.i60:                                     ; preds = %land.lhs.true.i.i83, %if.then35
  %utf8Convert.i.i61 = getelementptr inbounds %struct.encoding, ptr %24, i64 0, i32 10
  %end4.i.i62 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 80, i32 2
  br label %for.cond.i.i63

for.cond.i.i63:                                   ; preds = %if.end8.i.i66, %if.end.i.i60
  %28 = load ptr, ptr %utf8Convert.i.i61, align 8
  %29 = load ptr, ptr %end4.i.i62, align 8
  %call5.i.i64 = call i32 %28(ptr noundef nonnull %24, ptr noundef nonnull %ptr.addr.i.i57, ptr noundef %add.ptr40, ptr noundef nonnull %ptr1.i.i58, ptr noundef %29) #24
  %or.cond.i.i65 = icmp ult i32 %call5.i.i64, 2
  br i1 %or.cond.i.i65, label %poolAppend.exit.i71, label %if.end8.i.i66

if.end8.i.i66:                                    ; preds = %for.cond.i.i63
  %call9.i.i67 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_temp2Pool36), !range !13
  %tobool10.not.i.i68 = icmp eq i8 %call9.i.i67, 0
  br i1 %tobool10.not.i.i68, label %poolAppend.exit.thread.i69, label %for.cond.i.i63

poolAppend.exit.thread.i69:                       ; preds = %if.end8.i.i66, %land.lhs.true.i.i83
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i57)
  br label %return

poolAppend.exit.i71:                              ; preds = %for.cond.i.i63
  %start.i.i72 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 80, i32 4
  %30 = load ptr, ptr %start.i.i72, align 8
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i57)
  %tobool.not.i73 = icmp eq ptr %30, null
  br i1 %tobool.not.i73, label %return, label %if.end.i74

if.end.i74:                                       ; preds = %poolAppend.exit.i71
  %31 = load ptr, ptr %ptr1.i.i58, align 8
  %32 = load ptr, ptr %end4.i.i62, align 8
  %cmp.i75 = icmp eq ptr %31, %32
  br i1 %cmp.i75, label %land.lhs.true.i78, label %poolStoreString.exit86

land.lhs.true.i78:                                ; preds = %if.end.i74
  %call3.i79 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_temp2Pool36), !range !13
  %tobool4.not.i80 = icmp eq i8 %call3.i79, 0
  br i1 %tobool4.not.i80, label %return, label %land.lhs.true.if.end6_crit_edge.i81

land.lhs.true.if.end6_crit_edge.i81:              ; preds = %land.lhs.true.i78
  %.pre.i82 = load ptr, ptr %ptr1.i.i58, align 8
  br label %poolStoreString.exit86

poolStoreString.exit86:                           ; preds = %if.end.i74, %land.lhs.true.if.end6_crit_edge.i81
  %33 = phi ptr [ %.pre.i82, %land.lhs.true.if.end6_crit_edge.i81 ], [ %31, %if.end.i74 ]
  %incdec.ptr.i77 = getelementptr i8, ptr %33, i64 1
  store ptr %incdec.ptr.i77, ptr %ptr1.i.i58, align 8
  store i8 0, ptr %33, align 1
  %34 = load ptr, ptr %start.i.i72, align 8
  %tobool42.not = icmp eq ptr %34, null
  br i1 %tobool42.not, label %return, label %if.end45

if.end45:                                         ; preds = %poolStoreString.exit86, %if.end33
  %storedversion.0 = phi ptr [ %34, %poolStoreString.exit86 ], [ null, %if.end33 ]
  %35 = load ptr, ptr %m_xmlDeclHandler, align 8
  %m_handlerArg = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 1
  %36 = load ptr, ptr %m_handlerArg, align 8
  %37 = load i32, ptr %standalone, align 4
  call void %35(ptr noundef %36, ptr noundef %storedversion.0, ptr noundef %storedEncName.0, i32 noundef %37) #24
  %38 = icmp ne ptr %storedversion.0, null
  br label %if.end52

if.else47:                                        ; preds = %if.end17
  %m_defaultHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 18
  %39 = load ptr, ptr %m_defaultHandler, align 8
  %tobool48.not = icmp eq ptr %39, null
  br i1 %tobool48.not, label %if.end52, label %if.then49

if.then49:                                        ; preds = %if.else47
  %40 = load ptr, ptr %m_encoding, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %s.addr.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %dataPtr.i)
  store ptr %s, ptr %s.addr.i, align 8
  %isUtf8.i = getelementptr inbounds %struct.encoding, ptr %40, i64 0, i32 13
  %41 = load i8, ptr %isUtf8.i, align 4
  %tobool.not.i87 = icmp eq i8 %41, 0
  br i1 %tobool.not.i87, label %if.end.i89, label %if.else9.i

if.end.i89:                                       ; preds = %if.then49
  %m_eventEndPtr.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 48
  %m_dataBuf.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 9
  %utf8Convert.i = getelementptr inbounds %struct.encoding, ptr %40, i64 0, i32 10
  %m_dataBufEnd.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 10
  %m_handlerArg.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 1
  br label %do.body.i

do.body.i:                                        ; preds = %do.body.i, %if.end.i89
  %42 = load ptr, ptr %m_dataBuf.i, align 8
  store ptr %42, ptr %dataPtr.i, align 8
  %43 = load ptr, ptr %utf8Convert.i, align 8
  %44 = load ptr, ptr %m_dataBufEnd.i, align 8
  %call.i = call i32 %43(ptr noundef nonnull %40, ptr noundef nonnull %s.addr.i, ptr noundef %next, ptr noundef nonnull %dataPtr.i, ptr noundef %44) #24
  %45 = load ptr, ptr %s.addr.i, align 8
  store ptr %45, ptr %m_eventEndPtr.i, align 8
  %46 = load ptr, ptr %m_defaultHandler, align 8
  %47 = load ptr, ptr %m_handlerArg.i, align 8
  %48 = load ptr, ptr %m_dataBuf.i, align 8
  %49 = load ptr, ptr %dataPtr.i, align 8
  %sub.ptr.lhs.cast.i = ptrtoint ptr %49 to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %48 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %conv.i = trunc i64 %sub.ptr.sub.i to i32
  call void %46(ptr noundef %47, ptr noundef %48, i32 noundef %conv.i) #24
  %50 = load ptr, ptr %s.addr.i, align 8
  store ptr %50, ptr %m_eventPtr, align 8
  %51 = icmp ugt i32 %call.i, 1
  br i1 %51, label %do.body.i, label %reportDefault.exit, !llvm.loop !28

if.else9.i:                                       ; preds = %if.then49
  %m_handlerArg11.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 1
  %52 = load ptr, ptr %m_handlerArg11.i, align 8
  %sub.ptr.lhs.cast12.i = ptrtoint ptr %next to i64
  %sub.ptr.rhs.cast13.i = ptrtoint ptr %s to i64
  %sub.ptr.sub14.i = sub i64 %sub.ptr.lhs.cast12.i, %sub.ptr.rhs.cast13.i
  %conv15.i = trunc i64 %sub.ptr.sub14.i to i32
  call void %39(ptr noundef %52, ptr noundef %s, i32 noundef %conv15.i) #24
  br label %reportDefault.exit

reportDefault.exit:                               ; preds = %do.body.i, %if.else9.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %s.addr.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %dataPtr.i)
  br label %if.end52

if.end52:                                         ; preds = %if.else47, %reportDefault.exit, %if.end45
  %storedEncName.1 = phi ptr [ %storedEncName.0, %if.end45 ], [ null, %reportDefault.exit ], [ null, %if.else47 ]
  %storedversion.1 = phi i1 [ %38, %if.end45 ], [ false, %reportDefault.exit ], [ false, %if.else47 ]
  %m_protocolEncodingName = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 37
  %53 = load ptr, ptr %m_protocolEncodingName, align 8
  %cmp53 = icmp eq ptr %53, null
  br i1 %cmp53, label %if.then55, label %if.end101

if.then55:                                        ; preds = %if.end52
  %54 = load ptr, ptr %newEncoding, align 8
  %tobool56.not = icmp eq ptr %54, null
  br i1 %tobool56.not, label %if.else74, label %if.then57

if.then57:                                        ; preds = %if.then55
  %minBytesPerChar58 = getelementptr inbounds %struct.encoding, ptr %54, i64 0, i32 12
  %55 = load i32, ptr %minBytesPerChar58, align 8
  %56 = load ptr, ptr %m_encoding, align 8
  %minBytesPerChar60 = getelementptr inbounds %struct.encoding, ptr %56, i64 0, i32 12
  %57 = load i32, ptr %minBytesPerChar60, align 8
  %cmp61.not = icmp eq i32 %55, %57
  br i1 %cmp61.not, label %lor.lhs.false, label %if.then70

lor.lhs.false:                                    ; preds = %if.then57
  %cmp64 = icmp ne i32 %55, 2
  %cmp68.not = icmp eq ptr %54, %56
  %or.cond55 = or i1 %cmp64, %cmp68.not
  br i1 %or.cond55, label %if.end72, label %if.then70

if.then70:                                        ; preds = %lor.lhs.false, %if.then57
  %58 = load ptr, ptr %encodingName, align 8
  store ptr %58, ptr %m_eventPtr, align 8
  br label %return

if.end72:                                         ; preds = %lor.lhs.false
  store ptr %54, ptr %m_encoding, align 8
  br label %if.end101

if.else74:                                        ; preds = %if.then55
  %59 = load ptr, ptr %encodingName, align 8
  %tobool75.not = icmp eq ptr %59, null
  br i1 %tobool75.not, label %if.end101, label %if.then76

if.then76:                                        ; preds = %if.else74
  %tobool77.not = icmp eq ptr %storedEncName.1, null
  br i1 %tobool77.not, label %if.then78, label %if.end91

if.then78:                                        ; preds = %if.then76
  %m_temp2Pool79 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 80
  %60 = load ptr, ptr %m_encoding, align 8
  %nameLength82 = getelementptr inbounds %struct.encoding, ptr %60, i64 0, i32 3
  %61 = load ptr, ptr %nameLength82, align 8
  %call84 = call i32 %61(ptr noundef %60, ptr noundef nonnull %59) #24
  %idx.ext85 = sext i32 %call84 to i64
  %add.ptr86 = getelementptr i8, ptr %59, i64 %idx.ext85
  %call87 = call fastcc ptr @poolStoreString(ptr noundef nonnull %m_temp2Pool79, ptr noundef %60, ptr noundef nonnull %59, ptr noundef %add.ptr86)
  %tobool88.not = icmp eq ptr %call87, null
  br i1 %tobool88.not, label %return, label %if.end91

if.end91:                                         ; preds = %if.then78, %if.then76
  %storedEncName.2 = phi ptr [ %storedEncName.1, %if.then76 ], [ %call87, %if.then78 ]
  call void @llvm.lifetime.start.p0(i64 1048, ptr nonnull %info.i)
  %m_unknownEncodingHandler.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 29
  %62 = load ptr, ptr %m_unknownEncodingHandler.i, align 8
  %tobool.not.i90 = icmp eq ptr %62, null
  br i1 %tobool.not.i90, label %handleUnknownEncoding.exit, label %for.body.preheader.i

for.body.preheader.i:                             ; preds = %if.end91
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(1024) %info.i, i8 -1, i64 1024, i1 false)
  %convert.i = getelementptr inbounds %struct.XML_Encoding, ptr %info.i, i64 0, i32 2
  %data.i = getelementptr inbounds %struct.XML_Encoding, ptr %info.i, i64 0, i32 1
  %release.i = getelementptr inbounds %struct.XML_Encoding, ptr %info.i, i64 0, i32 3
  %m_unknownEncodingHandlerData.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 42
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %data.i, i8 0, i64 24, i1 false)
  %63 = load ptr, ptr %m_unknownEncodingHandlerData.i, align 8
  %call.i91 = call i32 %62(ptr noundef %63, ptr noundef nonnull %storedEncName.2, ptr noundef nonnull %info.i) #24
  %tobool2.not.i = icmp eq i32 %call.i91, 0
  br i1 %tobool2.not.i, label %if.end27.i, label %if.then3.i

if.then3.i:                                       ; preds = %for.body.preheader.i
  %m_mem.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 3
  %64 = load ptr, ptr %m_mem.i, align 8
  %call4.i = call i32 @PyExpat_XmlSizeOfUnknownEncoding() #24
  %conv.i92 = sext i32 %call4.i to i64
  %call5.i = call ptr %64(i64 noundef %conv.i92) #24
  %m_unknownEncodingMem.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 40
  store ptr %call5.i, ptr %m_unknownEncodingMem.i, align 8
  %tobool7.not.i = icmp eq ptr %call5.i, null
  br i1 %tobool7.not.i, label %if.then8.i, label %if.end14.i

if.then8.i:                                       ; preds = %if.then3.i
  %65 = load ptr, ptr %release.i, align 8
  %tobool10.not.i = icmp eq ptr %65, null
  br i1 %tobool10.not.i, label %handleUnknownEncoding.exit, label %if.then11.i

if.then11.i:                                      ; preds = %if.then8.i
  %66 = load ptr, ptr %data.i, align 8
  call void %65(ptr noundef %66) #24
  br label %handleUnknownEncoding.exit

if.end14.i:                                       ; preds = %if.then3.i
  %67 = load i8, ptr %m_ns, align 8
  %tobool16.not.i = icmp eq i8 %67, 0
  %cond.i = select i1 %tobool16.not.i, ptr @PyExpat_XmlInitUnknownEncoding, ptr @PyExpat_XmlInitUnknownEncodingNS
  %68 = load ptr, ptr %convert.i, align 8
  %69 = load ptr, ptr %data.i, align 8
  %call21.i = call ptr %cond.i(ptr noundef nonnull %call5.i, ptr noundef nonnull %info.i, ptr noundef %68, ptr noundef %69) #24, !callees !30
  %tobool22.not.i = icmp eq ptr %call21.i, null
  br i1 %tobool22.not.i, label %if.end27.i, label %if.then23.i

if.then23.i:                                      ; preds = %if.end14.i
  %70 = load ptr, ptr %data.i, align 8
  %m_unknownEncodingData.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 41
  store ptr %70, ptr %m_unknownEncodingData.i, align 8
  %71 = load ptr, ptr %release.i, align 8
  %m_unknownEncodingRelease.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 43
  store ptr %71, ptr %m_unknownEncodingRelease.i, align 8
  store ptr %call21.i, ptr %m_encoding, align 8
  br label %handleUnknownEncoding.exit

if.end27.i:                                       ; preds = %if.end14.i, %for.body.preheader.i
  %72 = load ptr, ptr %release.i, align 8
  %cmp29.not.i = icmp eq ptr %72, null
  br i1 %cmp29.not.i, label %handleUnknownEncoding.exit, label %if.then31.i

if.then31.i:                                      ; preds = %if.end27.i
  %73 = load ptr, ptr %data.i, align 8
  call void %72(ptr noundef %73) #24
  br label %handleUnknownEncoding.exit

handleUnknownEncoding.exit:                       ; preds = %if.end91, %if.then8.i, %if.then11.i, %if.then23.i, %if.end27.i, %if.then31.i
  %cmp94 = phi i1 [ false, %if.then23.i ], [ false, %if.then11.i ], [ false, %if.then8.i ], [ true, %if.end27.i ], [ true, %if.then31.i ], [ true, %if.end91 ]
  %retval.0.i94 = phi i32 [ 0, %if.then23.i ], [ 1, %if.then11.i ], [ 1, %if.then8.i ], [ 18, %if.end27.i ], [ 18, %if.then31.i ], [ 18, %if.end91 ]
  call void @llvm.lifetime.end.p0(i64 1048, ptr nonnull %info.i)
  %m_temp2Pool93 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 80
  %freeBlocks.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 80, i32 1
  %74 = load ptr, ptr %freeBlocks.i, align 8
  %tobool.not.i95 = icmp eq ptr %74, null
  %75 = load ptr, ptr %m_temp2Pool93, align 8
  br i1 %tobool.not.i95, label %if.then.i98, label %if.else.i96

if.then.i98:                                      ; preds = %handleUnknownEncoding.exit
  store ptr %75, ptr %freeBlocks.i, align 8
  br label %poolClear.exit

if.else.i96:                                      ; preds = %handleUnknownEncoding.exit
  %tobool3.not13.i = icmp eq ptr %75, null
  br i1 %tobool3.not13.i, label %poolClear.exit, label %while.body.i

while.body.i:                                     ; preds = %if.else.i96, %while.body.i
  %76 = phi ptr [ %p.014.i, %while.body.i ], [ %74, %if.else.i96 ]
  %p.014.i = phi ptr [ %77, %while.body.i ], [ %75, %if.else.i96 ]
  %77 = load ptr, ptr %p.014.i, align 8
  store ptr %76, ptr %p.014.i, align 8
  store ptr %p.014.i, ptr %freeBlocks.i, align 8
  %tobool3.not.i = icmp eq ptr %77, null
  br i1 %tobool3.not.i, label %poolClear.exit, label %while.body.i, !llvm.loop !8

poolClear.exit:                                   ; preds = %while.body.i, %if.then.i98, %if.else.i96
  store ptr null, ptr %m_temp2Pool93, align 8
  %end.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 80, i32 2
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %end.i, i8 0, i64 24, i1 false)
  br i1 %cmp94, label %if.then96, label %return

if.then96:                                        ; preds = %poolClear.exit
  %78 = load ptr, ptr %encodingName, align 8
  store ptr %78, ptr %m_eventPtr, align 8
  br label %return

if.end101:                                        ; preds = %if.end72, %if.else74, %if.end52
  %tobool102 = icmp ne ptr %storedEncName.1, null
  %or.cond1 = or i1 %tobool102, %storedversion.1
  br i1 %or.cond1, label %if.then105, label %return

if.then105:                                       ; preds = %if.end101
  %m_temp2Pool106 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 80
  %freeBlocks.i99 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 80, i32 1
  %79 = load ptr, ptr %freeBlocks.i99, align 8
  %tobool.not.i100 = icmp eq ptr %79, null
  %80 = load ptr, ptr %m_temp2Pool106, align 8
  br i1 %tobool.not.i100, label %if.then.i108, label %if.else.i101

if.then.i108:                                     ; preds = %if.then105
  store ptr %80, ptr %freeBlocks.i99, align 8
  br label %poolClear.exit109

if.else.i101:                                     ; preds = %if.then105
  %tobool3.not13.i102 = icmp eq ptr %80, null
  br i1 %tobool3.not13.i102, label %poolClear.exit109, label %while.body.i103

while.body.i103:                                  ; preds = %if.else.i101, %while.body.i103
  %81 = phi ptr [ %p.014.i104, %while.body.i103 ], [ %79, %if.else.i101 ]
  %p.014.i104 = phi ptr [ %82, %while.body.i103 ], [ %80, %if.else.i101 ]
  %82 = load ptr, ptr %p.014.i104, align 8
  store ptr %81, ptr %p.014.i104, align 8
  store ptr %p.014.i104, ptr %freeBlocks.i99, align 8
  %tobool3.not.i105 = icmp eq ptr %82, null
  br i1 %tobool3.not.i105, label %poolClear.exit109, label %while.body.i103, !llvm.loop !8

poolClear.exit109:                                ; preds = %while.body.i103, %if.then.i108, %if.else.i101
  store ptr null, ptr %m_temp2Pool106, align 8
  %end.i107 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 80, i32 2
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %end.i107, i8 0, i64 24, i1 false)
  br label %return

return:                                           ; preds = %poolAppend.exit.thread.i69, %land.lhs.true.i78, %poolAppend.exit.i71, %poolAppend.exit.thread.i, %land.lhs.true.i, %poolAppend.exit.i, %accountingGetCurrentAmplification.exit.i.i, %getRootParserOf.exit.i.i, %poolClear.exit109, %if.end101, %poolClear.exit, %if.then96, %if.then78, %poolStoreString.exit86, %poolStoreString.exit, %if.then4, %if.then70
  %retval.0 = phi i32 [ 19, %if.then70 ], [ %., %if.then4 ], [ 1, %poolStoreString.exit ], [ 1, %poolStoreString.exit86 ], [ 1, %if.then78 ], [ 18, %if.then96 ], [ %retval.0.i94, %poolClear.exit ], [ 0, %if.end101 ], [ 0, %poolClear.exit109 ], [ 43, %getRootParserOf.exit.i.i ], [ 43, %accountingGetCurrentAmplification.exit.i.i ], [ 1, %poolAppend.exit.i ], [ 1, %land.lhs.true.i ], [ 1, %poolAppend.exit.thread.i ], [ 1, %poolAppend.exit.i71 ], [ 1, %land.lhs.true.i78 ], [ 1, %poolAppend.exit.thread.i69 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal fastcc ptr @poolStoreString(ptr noundef %pool, ptr noundef %enc, ptr noundef %ptr, ptr noundef %end) unnamed_addr #0 {
entry:
  %ptr.addr.i = alloca ptr, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ptr.addr.i)
  store ptr %ptr, ptr %ptr.addr.i, align 8
  %ptr1.i = getelementptr inbounds %struct.STRING_POOL, ptr %pool, i64 0, i32 3
  %0 = load ptr, ptr %ptr1.i, align 8
  %tobool.not.i = icmp eq ptr %0, null
  br i1 %tobool.not.i, label %land.lhs.true.i, label %if.end.i

land.lhs.true.i:                                  ; preds = %entry
  %call.i = tail call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool), !range !13
  %tobool2.not.i = icmp eq i8 %call.i, 0
  br i1 %tobool2.not.i, label %poolAppend.exit.thread, label %if.end.i

if.end.i:                                         ; preds = %land.lhs.true.i, %entry
  %utf8Convert.i = getelementptr inbounds %struct.encoding, ptr %enc, i64 0, i32 10
  %end4.i = getelementptr inbounds %struct.STRING_POOL, ptr %pool, i64 0, i32 2
  br label %for.cond.i

for.cond.i:                                       ; preds = %if.end8.i, %if.end.i
  %1 = load ptr, ptr %utf8Convert.i, align 8
  %2 = load ptr, ptr %end4.i, align 8
  %call5.i = call i32 %1(ptr noundef %enc, ptr noundef nonnull %ptr.addr.i, ptr noundef %end, ptr noundef nonnull %ptr1.i, ptr noundef %2) #24
  %or.cond.i = icmp ult i32 %call5.i, 2
  br i1 %or.cond.i, label %poolAppend.exit, label %if.end8.i

if.end8.i:                                        ; preds = %for.cond.i
  %call9.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool), !range !13
  %tobool10.not.i = icmp eq i8 %call9.i, 0
  br i1 %tobool10.not.i, label %poolAppend.exit.thread, label %for.cond.i

poolAppend.exit.thread:                           ; preds = %if.end8.i, %land.lhs.true.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i)
  br label %return

poolAppend.exit:                                  ; preds = %for.cond.i
  %start.i = getelementptr inbounds %struct.STRING_POOL, ptr %pool, i64 0, i32 4
  %3 = load ptr, ptr %start.i, align 8
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i)
  %tobool.not = icmp eq ptr %3, null
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %poolAppend.exit
  %4 = load ptr, ptr %ptr1.i, align 8
  %5 = load ptr, ptr %end4.i, align 8
  %cmp = icmp eq ptr %4, %5
  br i1 %cmp, label %land.lhs.true, label %if.end6

land.lhs.true:                                    ; preds = %if.end
  %call3 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool), !range !13
  %tobool4.not = icmp eq i8 %call3, 0
  br i1 %tobool4.not, label %return, label %land.lhs.true.if.end6_crit_edge

land.lhs.true.if.end6_crit_edge:                  ; preds = %land.lhs.true
  %.pre = load ptr, ptr %ptr1.i, align 8
  br label %if.end6

if.end6:                                          ; preds = %land.lhs.true.if.end6_crit_edge, %if.end
  %6 = phi ptr [ %.pre, %land.lhs.true.if.end6_crit_edge ], [ %4, %if.end ]
  %incdec.ptr = getelementptr i8, ptr %6, i64 1
  store ptr %incdec.ptr, ptr %ptr1.i, align 8
  store i8 0, ptr %6, align 1
  %7 = load ptr, ptr %start.i, align 8
  br label %return

return:                                           ; preds = %poolAppend.exit.thread, %land.lhs.true, %poolAppend.exit, %if.end6
  %retval.0 = phi ptr [ %7, %if.end6 ], [ null, %poolAppend.exit ], [ null, %land.lhs.true ], [ null, %poolAppend.exit.thread ]
  ret ptr %retval.0
}

; Function Attrs: nounwind uwtable
define internal fastcc ptr @lookup(ptr nocapture noundef readonly %parser, ptr nocapture noundef %table, ptr noundef %name, i64 noundef %createSize) unnamed_addr #0 {
entry:
  %size = getelementptr inbounds %struct.HASH_TABLE, ptr %table, i64 0, i32 2
  %0 = load i64, ptr %size, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %tobool.not = icmp eq i64 %createSize, 0
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %if.then
  %power = getelementptr inbounds %struct.HASH_TABLE, ptr %table, i64 0, i32 1
  store i8 6, ptr %power, align 8
  store i64 64, ptr %size, align 8
  %mem = getelementptr inbounds %struct.HASH_TABLE, ptr %table, i64 0, i32 4
  %1 = load ptr, ptr %mem, align 8
  %2 = load ptr, ptr %1, align 8
  %call = tail call ptr %2(i64 noundef 512) #24
  store ptr %call, ptr %table, align 8
  %tobool5.not = icmp eq ptr %call, null
  br i1 %tobool5.not, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end
  store i64 0, ptr %size, align 8
  br label %return

if.end8:                                          ; preds = %if.end
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(512) %call, i8 0, i64 512, i1 false)
  %call10 = tail call fastcc i64 @hash(ptr noundef %parser, ptr noundef %name)
  %3 = load i64, ptr %size, align 8
  %sub = add i64 %3, -1
  %and = and i64 %sub, %call10
  br label %if.end162

if.else:                                          ; preds = %entry
  %call12 = tail call fastcc i64 @hash(ptr noundef %parser, ptr noundef %name)
  %4 = load i64, ptr %size, align 8
  %sub14 = add i64 %4, -1
  %and15 = and i64 %sub14, %call12
  %5 = load ptr, ptr %table, align 8
  %arrayidx111 = getelementptr ptr, ptr %5, i64 %and15
  %6 = load ptr, ptr %arrayidx111, align 8
  %tobool17.not112 = icmp eq ptr %6, null
  br i1 %tobool17.not112, label %while.end, label %while.body.lr.ph

while.body.lr.ph:                                 ; preds = %if.else
  %7 = load i8, ptr %name, align 1
  %not = sub i64 0, %4
  %and29 = and i64 %call12, %not
  %power30 = getelementptr inbounds %struct.HASH_TABLE, ptr %table, i64 0, i32 1
  %shr32 = lshr i64 %sub14, 2
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %if.end35
  %8 = phi ptr [ %6, %while.body.lr.ph ], [ %16, %if.end35 ]
  %i.0114 = phi i64 [ %and15, %while.body.lr.ph ], [ %i.1, %if.end35 ]
  %step.0113 = phi i8 [ 0, %while.body.lr.ph ], [ %step.1, %if.end35 ]
  %9 = load ptr, ptr %8, align 8
  %10 = load i8, ptr %9, align 1
  %cmp5.i = icmp eq i8 %7, %10
  br i1 %cmp5.i, label %for.body.i, label %if.end26

for.body.i:                                       ; preds = %while.body, %for.inc.i
  %11 = phi i8 [ %12, %for.inc.i ], [ %7, %while.body ]
  %s2.addr.07.i = phi ptr [ %incdec.ptr6.i, %for.inc.i ], [ %9, %while.body ]
  %s1.addr.06.i = phi ptr [ %incdec.ptr.i, %for.inc.i ], [ %name, %while.body ]
  %cmp4.i = icmp eq i8 %11, 0
  br i1 %cmp4.i, label %return, label %for.inc.i

for.inc.i:                                        ; preds = %for.body.i
  %incdec.ptr.i = getelementptr i8, ptr %s1.addr.06.i, i64 1
  %incdec.ptr6.i = getelementptr i8, ptr %s2.addr.07.i, i64 1
  %12 = load i8, ptr %incdec.ptr.i, align 1
  %13 = load i8, ptr %incdec.ptr6.i, align 1
  %cmp.i = icmp eq i8 %12, %13
  br i1 %cmp.i, label %for.body.i, label %if.end26, !llvm.loop !14

if.end26:                                         ; preds = %for.inc.i, %while.body
  %tobool27.not = icmp eq i8 %step.0113, 0
  br i1 %tobool27.not, label %if.then28, label %if.end35

if.then28:                                        ; preds = %if.end26
  %14 = load i8, ptr %power30, align 8
  %conv = zext i8 %14 to i64
  %sub31 = add nuw nsw i64 %conv, 4294967295
  %sh_prom = and i64 %sub31, 4294967295
  %shr = lshr i64 %and29, %sh_prom
  %and33 = and i64 %shr, %shr32
  %15 = trunc i64 %and33 to i8
  %conv34 = or i8 %15, 1
  br label %if.end35

if.end35:                                         ; preds = %if.then28, %if.end26
  %step.1 = phi i8 [ %step.0113, %if.end26 ], [ %conv34, %if.then28 ]
  %conv36 = zext i8 %step.1 to i64
  %cmp37 = icmp ult i64 %i.0114, %conv36
  %i.1.p.v = select i1 %cmp37, i64 %4, i64 0
  %i.1.p = sub i64 %i.0114, %conv36
  %i.1 = add i64 %i.1.p, %i.1.p.v
  %arrayidx = getelementptr ptr, ptr %5, i64 %i.1
  %16 = load ptr, ptr %arrayidx, align 8
  %tobool17.not = icmp eq ptr %16, null
  br i1 %tobool17.not, label %while.end, label %while.body, !llvm.loop !15

while.end:                                        ; preds = %if.end35, %if.else
  %i.0.lcssa = phi i64 [ %and15, %if.else ], [ %i.1, %if.end35 ]
  %tobool44.not = icmp eq i64 %createSize, 0
  br i1 %tobool44.not, label %return, label %if.end46

if.end46:                                         ; preds = %while.end
  %used = getelementptr inbounds %struct.HASH_TABLE, ptr %table, i64 0, i32 3
  %17 = load i64, ptr %used, align 8
  %power47 = getelementptr inbounds %struct.HASH_TABLE, ptr %table, i64 0, i32 1
  %18 = load i8, ptr %power47, align 8
  %conv48 = zext i8 %18 to i64
  %sub49 = add nuw nsw i64 %conv48, 4294967295
  %sh_prom50 = and i64 %sub49, 4294967295
  %shr51 = lshr i64 %17, %sh_prom50
  %tobool52.not = icmp eq i64 %shr51, 0
  br i1 %tobool52.not, label %if.end162, label %if.then53

if.then53:                                        ; preds = %if.end46
  %add56 = add i8 %18, 1
  %cmp59 = icmp ugt i8 %add56, 63
  br i1 %cmp59, label %return, label %if.end62

if.end62:                                         ; preds = %if.then53
  %conv63 = zext nneg i8 %add56 to i32
  %sh_prom64 = zext nneg i8 %add56 to i64
  %shl = shl nuw i64 1, %sh_prom64
  %sub65 = add i64 %shl, -1
  %cmp66 = icmp ugt i8 %add56, 60
  br i1 %cmp66, label %return, label %if.end69

if.end69:                                         ; preds = %if.end62
  %mul71 = shl i64 8, %sh_prom64
  %mem72 = getelementptr inbounds %struct.HASH_TABLE, ptr %table, i64 0, i32 4
  %19 = load ptr, ptr %mem72, align 8
  %20 = load ptr, ptr %19, align 8
  %call74 = tail call ptr %20(i64 noundef %mul71) #24
  %tobool75.not = icmp eq ptr %call74, null
  br i1 %tobool75.not, label %return, label %if.end77

if.end77:                                         ; preds = %if.end69
  tail call void @llvm.memset.p0.i64(ptr nonnull align 8 %call74, i8 0, i64 %mul71, i1 false)
  %21 = load i64, ptr %size, align 8
  %cmp79120.not = icmp eq i64 %21, 0
  br i1 %cmp79120.not, label %for.end, label %for.body.lr.ph

for.body.lr.ph:                                   ; preds = %if.end77
  %not96 = sub i64 0, %shl
  %sub99 = add nsw i32 %conv63, -1
  %sh_prom100 = zext nneg i32 %sub99 to i64
  %shr102 = lshr i64 %sub65, 2
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.inc
  %22 = phi i64 [ %21, %for.body.lr.ph ], [ %31, %for.inc ]
  %i.2121 = phi i64 [ 0, %for.body.lr.ph ], [ %inc, %for.inc ]
  %23 = load ptr, ptr %table, align 8
  %arrayidx82 = getelementptr ptr, ptr %23, i64 %i.2121
  %24 = load ptr, ptr %arrayidx82, align 8
  %tobool83.not = icmp eq ptr %24, null
  br i1 %tobool83.not, label %for.inc, label %if.then84

if.then84:                                        ; preds = %for.body
  %25 = load ptr, ptr %24, align 8
  %call88 = tail call fastcc i64 @hash(ptr noundef %parser, ptr noundef %25)
  %and89 = and i64 %call88, %sub65
  %arrayidx91115 = getelementptr ptr, ptr %call74, i64 %and89
  %26 = load ptr, ptr %arrayidx91115, align 8
  %tobool92.not116 = icmp eq ptr %26, null
  br i1 %tobool92.not116, label %while.end119, label %while.body93.lr.ph

while.body93.lr.ph:                               ; preds = %if.then84
  %and97 = and i64 %call88, %not96
  %shr101 = lshr i64 %and97, %sh_prom100
  %and103 = and i64 %shr101, %shr102
  %27 = trunc i64 %and103 to i8
  %conv105 = or i8 %27, 1
  br label %while.body93

while.body93:                                     ; preds = %while.body93.lr.ph, %while.body93
  %j.0118 = phi i64 [ %and89, %while.body93.lr.ph ], [ %j.1, %while.body93 ]
  %step.2117 = phi i8 [ 0, %while.body93.lr.ph ], [ %spec.select, %while.body93 ]
  %tobool94.not = icmp eq i8 %step.2117, 0
  %spec.select = select i1 %tobool94.not, i8 %conv105, i8 %step.2117
  %conv107 = zext i8 %spec.select to i64
  %cmp108 = icmp ult i64 %j.0118, %conv107
  %j.1.p.v = select i1 %cmp108, i64 %shl, i64 0
  %j.1.p = sub i64 %j.0118, %conv107
  %j.1 = add i64 %j.1.p, %j.1.p.v
  %arrayidx91 = getelementptr ptr, ptr %call74, i64 %j.1
  %28 = load ptr, ptr %arrayidx91, align 8
  %tobool92.not = icmp eq ptr %28, null
  br i1 %tobool92.not, label %while.end119, label %while.body93, !llvm.loop !43

while.end119:                                     ; preds = %while.body93, %if.then84
  %j.0.lcssa = phi i64 [ %and89, %if.then84 ], [ %j.1, %while.body93 ]
  %arrayidx91.le = getelementptr ptr, ptr %call74, i64 %j.0.lcssa
  %29 = load ptr, ptr %table, align 8
  %arrayidx121 = getelementptr ptr, ptr %29, i64 %i.2121
  %30 = load ptr, ptr %arrayidx121, align 8
  store ptr %30, ptr %arrayidx91.le, align 8
  %.pre = load i64, ptr %size, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body, %while.end119
  %31 = phi i64 [ %22, %for.body ], [ %.pre, %while.end119 ]
  %inc = add nuw i64 %i.2121, 1
  %cmp79 = icmp ult i64 %inc, %31
  br i1 %cmp79, label %for.body, label %for.end, !llvm.loop !44

for.end:                                          ; preds = %for.inc, %if.end77
  %32 = load ptr, ptr %mem72, align 8
  %free_fcn = getelementptr inbounds %struct.XML_Memory_Handling_Suite, ptr %32, i64 0, i32 2
  %33 = load ptr, ptr %free_fcn, align 8
  %34 = load ptr, ptr %table, align 8
  tail call void %33(ptr noundef %34) #24
  store ptr %call74, ptr %table, align 8
  store i8 %add56, ptr %power47, align 8
  store i64 %shl, ptr %size, align 8
  %and129 = and i64 %sub65, %call12
  %arrayidx132122 = getelementptr ptr, ptr %call74, i64 %and129
  %35 = load ptr, ptr %arrayidx132122, align 8
  %tobool133.not123 = icmp eq ptr %35, null
  br i1 %tobool133.not123, label %if.end162, label %while.body134.lr.ph

while.body134.lr.ph:                              ; preds = %for.end
  %not137 = sub i64 0, %shl
  %and138 = and i64 %call12, %not137
  %sub140 = add nsw i32 %conv63, -1
  %sh_prom141 = zext nneg i32 %sub140 to i64
  %shr142 = lshr i64 %and138, %sh_prom141
  %shr143 = lshr i64 %sub65, 2
  %and144 = and i64 %shr142, %shr143
  %36 = trunc i64 %and144 to i8
  %conv146 = or i8 %36, 1
  br label %while.body134

while.body134:                                    ; preds = %while.body134.lr.ph, %while.body134
  %i.3125 = phi i64 [ %and129, %while.body134.lr.ph ], [ %i.4, %while.body134 ]
  %step.4124 = phi i8 [ 0, %while.body134.lr.ph ], [ %spec.select127, %while.body134 ]
  %tobool135.not = icmp eq i8 %step.4124, 0
  %spec.select127 = select i1 %tobool135.not, i8 %conv146, i8 %step.4124
  %conv148 = zext i8 %spec.select127 to i64
  %cmp149 = icmp ult i64 %i.3125, %conv148
  %i.4.p.v = select i1 %cmp149, i64 %shl, i64 0
  %i.4.p = sub i64 %i.3125, %conv148
  %i.4 = add i64 %i.4.p, %i.4.p.v
  %arrayidx132 = getelementptr ptr, ptr %call74, i64 %i.4
  %37 = load ptr, ptr %arrayidx132, align 8
  %tobool133.not = icmp eq ptr %37, null
  br i1 %tobool133.not, label %if.end162, label %while.body134, !llvm.loop !45

if.end162:                                        ; preds = %while.body134, %for.end, %if.end46, %if.end8
  %i.5 = phi i64 [ %and, %if.end8 ], [ %i.0.lcssa, %if.end46 ], [ %and129, %for.end ], [ %i.4, %while.body134 ]
  %mem163 = getelementptr inbounds %struct.HASH_TABLE, ptr %table, i64 0, i32 4
  %38 = load ptr, ptr %mem163, align 8
  %39 = load ptr, ptr %38, align 8
  %call165 = tail call ptr %39(i64 noundef %createSize) #24
  %40 = load ptr, ptr %table, align 8
  %arrayidx167 = getelementptr ptr, ptr %40, i64 %i.5
  store ptr %call165, ptr %arrayidx167, align 8
  %41 = load ptr, ptr %table, align 8
  %arrayidx169 = getelementptr ptr, ptr %41, i64 %i.5
  %42 = load ptr, ptr %arrayidx169, align 8
  %tobool170.not = icmp eq ptr %42, null
  br i1 %tobool170.not, label %return, label %if.end172

if.end172:                                        ; preds = %if.end162
  tail call void @llvm.memset.p0.i64(ptr nonnull align 8 %42, i8 0, i64 %createSize, i1 false)
  %43 = load ptr, ptr %table, align 8
  %arrayidx176 = getelementptr ptr, ptr %43, i64 %i.5
  %44 = load ptr, ptr %arrayidx176, align 8
  store ptr %name, ptr %44, align 8
  %used178 = getelementptr inbounds %struct.HASH_TABLE, ptr %table, i64 0, i32 3
  %45 = load i64, ptr %used178, align 8
  %inc179 = add i64 %45, 1
  store i64 %inc179, ptr %used178, align 8
  %46 = load ptr, ptr %table, align 8
  %arrayidx181 = getelementptr ptr, ptr %46, i64 %i.5
  %47 = load ptr, ptr %arrayidx181, align 8
  br label %return

return:                                           ; preds = %for.body.i, %if.end162, %if.end69, %if.end62, %if.then53, %while.end, %if.then, %if.end172, %if.then6
  %retval.0 = phi ptr [ %47, %if.end172 ], [ null, %if.then6 ], [ null, %if.then ], [ null, %while.end ], [ null, %if.then53 ], [ null, %if.end62 ], [ null, %if.end69 ], [ null, %if.end162 ], [ %8, %for.body.i ]
  ret ptr %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @contentProcessor(ptr noundef %parser, ptr noundef %start, ptr noundef %end, ptr nocapture noundef writeonly %endPtr) #0 {
entry:
  %m_encoding = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 34
  %0 = load ptr, ptr %m_encoding, align 8
  %finalBuffer = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 85, i32 1
  %1 = load i8, ptr %finalBuffer, align 4
  %tobool.not = icmp eq i8 %1, 0
  %conv = zext i1 %tobool.not to i8
  %call = tail call fastcc i32 @doContent(ptr noundef %parser, i32 noundef 0, ptr noundef %0, ptr noundef %start, ptr noundef %end, ptr noundef %endPtr, i8 noundef zeroext %conv, i32 noundef 0)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.then, label %return

if.then:                                          ; preds = %entry
  %m_tagStack.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 67
  %realloc_fcn.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 3, i32 1
  %tag.035.i = load ptr, ptr %m_tagStack.i, align 8
  %tobool.not36.i = icmp eq ptr %tag.035.i, null
  br i1 %tobool.not36.i, label %return, label %while.body.i

while.body.i:                                     ; preds = %if.then, %if.end50.i
  %tag.037.i = phi ptr [ %tag.0.i, %if.end50.i ], [ %tag.035.i, %if.then ]
  %name.i = getelementptr inbounds %struct.tag, ptr %tag.037.i, i64 0, i32 3
  %strLen.i = getelementptr inbounds %struct.tag, ptr %tag.037.i, i64 0, i32 3, i32 3
  %2 = load i32, ptr %strLen.i, align 8
  %add.i = add i32 %2, 1
  %conv.i = sext i32 %add.i to i64
  %buf.i = getelementptr inbounds %struct.tag, ptr %tag.037.i, i64 0, i32 4
  %3 = load ptr, ptr %buf.i, align 8
  %add.ptr.i = getelementptr i8, ptr %3, i64 %conv.i
  %rawName.i = getelementptr inbounds %struct.tag, ptr %tag.037.i, i64 0, i32 1
  %4 = load ptr, ptr %rawName.i, align 8
  %cmp.i = icmp eq ptr %4, %add.ptr.i
  br i1 %cmp.i, label %return, label %if.end.i

if.end.i:                                         ; preds = %while.body.i
  %rawNameLength.i = getelementptr inbounds %struct.tag, ptr %tag.037.i, i64 0, i32 2
  %5 = load i32, ptr %rawNameLength.i, align 8
  %conv3.i = sext i32 %5 to i64
  %sub.i = sub nsw i64 2147483647, %conv.i
  %cmp6.i = icmp ult i64 %sub.i, %conv3.i
  br i1 %cmp6.i, label %return, label %if.end9.i

if.end9.i:                                        ; preds = %if.end.i
  %add11.i = add i32 %5, %add.i
  %conv12.i = sext i32 %add11.i to i64
  %bufEnd.i = getelementptr inbounds %struct.tag, ptr %tag.037.i, i64 0, i32 5
  %6 = load ptr, ptr %bufEnd.i, align 8
  %sub.ptr.lhs.cast.i = ptrtoint ptr %6 to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %3 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %cmp14.i = icmp slt i64 %sub.ptr.sub.i, %conv12.i
  br i1 %cmp14.i, label %if.then16.i, label %if.end50.i

if.then16.i:                                      ; preds = %if.end9.i
  %7 = load ptr, ptr %realloc_fcn.i, align 8
  %call.i = tail call ptr %7(ptr noundef %3, i64 noundef %conv12.i) #24
  %cmp19.i = icmp eq ptr %call.i, null
  br i1 %cmp19.i, label %return, label %if.end22.i

if.end22.i:                                       ; preds = %if.then16.i
  %8 = load ptr, ptr %name.i, align 8
  %9 = load ptr, ptr %buf.i, align 8
  %cmp25.i = icmp eq ptr %8, %9
  br i1 %cmp25.i, label %if.then27.i, label %if.end30.i

if.then27.i:                                      ; preds = %if.end22.i
  store ptr %call.i, ptr %name.i, align 8
  br label %if.end30.i

if.end30.i:                                       ; preds = %if.then27.i, %if.end22.i
  %localPart.i = getelementptr inbounds %struct.tag, ptr %tag.037.i, i64 0, i32 3, i32 1
  %10 = load ptr, ptr %localPart.i, align 8
  %tobool32.not.i = icmp eq ptr %10, null
  br i1 %tobool32.not.i, label %if.end43.i, label %if.then33.i

if.then33.i:                                      ; preds = %if.end30.i
  %sub.ptr.lhs.cast37.i = ptrtoint ptr %10 to i64
  %sub.ptr.rhs.cast38.i = ptrtoint ptr %9 to i64
  %sub.ptr.sub39.i = sub i64 %sub.ptr.lhs.cast37.i, %sub.ptr.rhs.cast38.i
  %add.ptr40.i = getelementptr i8, ptr %call.i, i64 %sub.ptr.sub39.i
  store ptr %add.ptr40.i, ptr %localPart.i, align 8
  br label %if.end43.i

if.end43.i:                                       ; preds = %if.then33.i, %if.end30.i
  store ptr %call.i, ptr %buf.i, align 8
  %add.ptr46.i = getelementptr i8, ptr %call.i, i64 %conv12.i
  store ptr %add.ptr46.i, ptr %bufEnd.i, align 8
  %add.ptr49.i = getelementptr i8, ptr %call.i, i64 %conv.i
  %.pre.i = load ptr, ptr %rawName.i, align 8
  %.pre41.i = load i32, ptr %rawNameLength.i, align 8
  %.pre42.i = sext i32 %.pre41.i to i64
  br label %if.end50.i

if.end50.i:                                       ; preds = %if.end43.i, %if.end9.i
  %conv53.pre-phi.i = phi i64 [ %.pre42.i, %if.end43.i ], [ %conv3.i, %if.end9.i ]
  %11 = phi ptr [ %.pre.i, %if.end43.i ], [ %4, %if.end9.i ]
  %rawNameBuf.0.i = phi ptr [ %add.ptr49.i, %if.end43.i ], [ %add.ptr.i, %if.end9.i ]
  tail call void @llvm.memcpy.p0.p0.i64(ptr align 1 %rawNameBuf.0.i, ptr align 1 %11, i64 %conv53.pre-phi.i, i1 false)
  store ptr %rawNameBuf.0.i, ptr %rawName.i, align 8
  %tag.0.i = load ptr, ptr %tag.037.i, align 8
  %tobool.not.i = icmp eq ptr %tag.0.i, null
  br i1 %tobool.not.i, label %return, label %while.body.i, !llvm.loop !46

return:                                           ; preds = %while.body.i, %if.end50.i, %if.then16.i, %if.end.i, %if.then, %entry
  %retval.0 = phi i32 [ %call, %entry ], [ 0, %if.then ], [ 0, %while.body.i ], [ 0, %if.end50.i ], [ 1, %if.then16.i ], [ 1, %if.end.i ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal fastcc ptr @getElementType(ptr nocapture noundef readonly %parser, ptr noundef %enc, ptr noundef %ptr, ptr noundef %end) unnamed_addr #0 {
entry:
  %ptr.addr.i.i = alloca ptr, align 8
  %m_dtd = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 65
  %0 = load ptr, ptr %m_dtd, align 8
  %pool = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 4
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ptr.addr.i.i)
  store ptr %ptr, ptr %ptr.addr.i.i, align 8
  %ptr1.i.i = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 4, i32 3
  %1 = load ptr, ptr %ptr1.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %1, null
  br i1 %tobool.not.i.i, label %land.lhs.true.i.i, label %if.end.i.i

land.lhs.true.i.i:                                ; preds = %entry
  %call.i.i = tail call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool), !range !13
  %tobool2.not.i.i = icmp eq i8 %call.i.i, 0
  br i1 %tobool2.not.i.i, label %poolAppend.exit.thread.i, label %if.end.i.i

if.end.i.i:                                       ; preds = %land.lhs.true.i.i, %entry
  %utf8Convert.i.i = getelementptr inbounds %struct.encoding, ptr %enc, i64 0, i32 10
  %end4.i.i = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 4, i32 2
  br label %for.cond.i.i

for.cond.i.i:                                     ; preds = %if.end8.i.i, %if.end.i.i
  %2 = load ptr, ptr %utf8Convert.i.i, align 8
  %3 = load ptr, ptr %end4.i.i, align 8
  %call5.i.i = call i32 %2(ptr noundef %enc, ptr noundef nonnull %ptr.addr.i.i, ptr noundef %end, ptr noundef nonnull %ptr1.i.i, ptr noundef %3) #24
  %or.cond.i.i = icmp ult i32 %call5.i.i, 2
  br i1 %or.cond.i.i, label %poolAppend.exit.i, label %if.end8.i.i

if.end8.i.i:                                      ; preds = %for.cond.i.i
  %call9.i.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool), !range !13
  %tobool10.not.i.i = icmp eq i8 %call9.i.i, 0
  br i1 %tobool10.not.i.i, label %poolAppend.exit.thread.i, label %for.cond.i.i

poolAppend.exit.thread.i:                         ; preds = %if.end8.i.i, %land.lhs.true.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i)
  br label %return

poolAppend.exit.i:                                ; preds = %for.cond.i.i
  %start.i.i = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 4, i32 4
  %4 = load ptr, ptr %start.i.i, align 8
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i)
  %tobool.not.i = icmp eq ptr %4, null
  br i1 %tobool.not.i, label %return, label %if.end.i

if.end.i:                                         ; preds = %poolAppend.exit.i
  %5 = load ptr, ptr %ptr1.i.i, align 8
  %6 = load ptr, ptr %end4.i.i, align 8
  %cmp.i = icmp eq ptr %5, %6
  br i1 %cmp.i, label %land.lhs.true.i, label %poolStoreString.exit

land.lhs.true.i:                                  ; preds = %if.end.i
  %call3.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool), !range !13
  %tobool4.not.i = icmp eq i8 %call3.i, 0
  br i1 %tobool4.not.i, label %return, label %land.lhs.true.if.end6_crit_edge.i

land.lhs.true.if.end6_crit_edge.i:                ; preds = %land.lhs.true.i
  %.pre.i = load ptr, ptr %ptr1.i.i, align 8
  br label %poolStoreString.exit

poolStoreString.exit:                             ; preds = %if.end.i, %land.lhs.true.if.end6_crit_edge.i
  %7 = phi ptr [ %.pre.i, %land.lhs.true.if.end6_crit_edge.i ], [ %5, %if.end.i ]
  %incdec.ptr.i = getelementptr i8, ptr %7, i64 1
  store ptr %incdec.ptr.i, ptr %ptr1.i.i, align 8
  store i8 0, ptr %7, align 1
  %8 = load ptr, ptr %start.i.i, align 8
  %tobool.not = icmp eq ptr %8, null
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %poolStoreString.exit
  %elementTypes = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 1
  %call1 = call fastcc ptr @lookup(ptr noundef %parser, ptr noundef nonnull %elementTypes, ptr noundef nonnull %8, i64 noundef 40)
  %tobool2.not = icmp eq ptr %call1, null
  br i1 %tobool2.not, label %return, label %if.end4

if.end4:                                          ; preds = %if.end
  %9 = load ptr, ptr %call1, align 8
  %cmp.not = icmp eq ptr %9, %8
  br i1 %cmp.not, label %if.else, label %if.then6

if.then6:                                         ; preds = %if.end4
  %10 = load ptr, ptr %start.i.i, align 8
  store ptr %10, ptr %ptr1.i.i, align 8
  br label %if.end18

if.else:                                          ; preds = %if.end4
  %11 = load ptr, ptr %ptr1.i.i, align 8
  store ptr %11, ptr %start.i.i, align 8
  %call14 = call fastcc i32 @setElementTypePrefix(ptr noundef %parser, ptr noundef nonnull %call1), !range !17
  %tobool15.not = icmp eq i32 %call14, 0
  br i1 %tobool15.not, label %return, label %if.end18

if.end18:                                         ; preds = %if.else, %if.then6
  br label %return

return:                                           ; preds = %poolAppend.exit.thread.i, %land.lhs.true.i, %poolAppend.exit.i, %if.else, %if.end, %poolStoreString.exit, %if.end18
  %retval.0 = phi ptr [ %call1, %if.end18 ], [ null, %poolStoreString.exit ], [ null, %if.end ], [ null, %if.else ], [ null, %poolAppend.exit.i ], [ null, %land.lhs.true.i ], [ null, %poolAppend.exit.thread.i ]
  ret ptr %retval.0
}

; Function Attrs: nounwind uwtable
define internal fastcc ptr @getAttributeId(ptr nocapture noundef readonly %parser, ptr noundef %enc, ptr noundef %start, ptr noundef %end) unnamed_addr #0 {
entry:
  %ptr.addr.i.i = alloca ptr, align 8
  %m_dtd = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 65
  %0 = load ptr, ptr %m_dtd, align 8
  %pool = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 4
  %ptr = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 4, i32 3
  %1 = load ptr, ptr %ptr, align 8
  %end2 = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 4, i32 2
  %2 = load ptr, ptr %end2, align 8
  %cmp = icmp eq ptr %1, %2
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %call = tail call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool), !range !13
  %tobool.not = icmp eq i8 %call, 0
  br i1 %tobool.not, label %return, label %land.lhs.true.cond.false_crit_edge

land.lhs.true.cond.false_crit_edge:               ; preds = %land.lhs.true
  %.pre = load ptr, ptr %ptr, align 8
  br label %cond.false

cond.false:                                       ; preds = %land.lhs.true.cond.false_crit_edge, %entry
  %3 = phi ptr [ %.pre, %land.lhs.true.cond.false_crit_edge ], [ %1, %entry ]
  %incdec.ptr = getelementptr i8, ptr %3, i64 1
  store ptr %incdec.ptr, ptr %ptr, align 8
  store i8 0, ptr %3, align 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ptr.addr.i.i)
  store ptr %start, ptr %ptr.addr.i.i, align 8
  %4 = load ptr, ptr %ptr, align 8
  %tobool.not.i.i = icmp eq ptr %4, null
  br i1 %tobool.not.i.i, label %land.lhs.true.i.i, label %if.end.i.i

land.lhs.true.i.i:                                ; preds = %cond.false
  %call.i.i = tail call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool), !range !13
  %tobool2.not.i.i = icmp eq i8 %call.i.i, 0
  br i1 %tobool2.not.i.i, label %poolAppend.exit.thread.i, label %if.end.i.i

if.end.i.i:                                       ; preds = %land.lhs.true.i.i, %cond.false
  %utf8Convert.i.i = getelementptr inbounds %struct.encoding, ptr %enc, i64 0, i32 10
  br label %for.cond.i.i

for.cond.i.i:                                     ; preds = %if.end8.i.i, %if.end.i.i
  %5 = load ptr, ptr %utf8Convert.i.i, align 8
  %6 = load ptr, ptr %end2, align 8
  %call5.i.i = call i32 %5(ptr noundef %enc, ptr noundef nonnull %ptr.addr.i.i, ptr noundef %end, ptr noundef nonnull %ptr, ptr noundef %6) #24
  %or.cond.i.i = icmp ult i32 %call5.i.i, 2
  br i1 %or.cond.i.i, label %poolAppend.exit.i, label %if.end8.i.i

if.end8.i.i:                                      ; preds = %for.cond.i.i
  %call9.i.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool), !range !13
  %tobool10.not.i.i = icmp eq i8 %call9.i.i, 0
  br i1 %tobool10.not.i.i, label %poolAppend.exit.thread.i, label %for.cond.i.i

poolAppend.exit.thread.i:                         ; preds = %if.end8.i.i, %land.lhs.true.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i)
  br label %return

poolAppend.exit.i:                                ; preds = %for.cond.i.i
  %start.i.i = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 4, i32 4
  %7 = load ptr, ptr %start.i.i, align 8
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i)
  %tobool.not.i = icmp eq ptr %7, null
  br i1 %tobool.not.i, label %return, label %if.end.i

if.end.i:                                         ; preds = %poolAppend.exit.i
  %8 = load ptr, ptr %ptr, align 8
  %9 = load ptr, ptr %end2, align 8
  %cmp.i = icmp eq ptr %8, %9
  br i1 %cmp.i, label %land.lhs.true.i, label %poolStoreString.exit

land.lhs.true.i:                                  ; preds = %if.end.i
  %call3.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool), !range !13
  %tobool4.not.i = icmp eq i8 %call3.i, 0
  br i1 %tobool4.not.i, label %return, label %land.lhs.true.if.end6_crit_edge.i

land.lhs.true.if.end6_crit_edge.i:                ; preds = %land.lhs.true.i
  %.pre.i = load ptr, ptr %ptr, align 8
  br label %poolStoreString.exit

poolStoreString.exit:                             ; preds = %if.end.i, %land.lhs.true.if.end6_crit_edge.i
  %10 = phi ptr [ %.pre.i, %land.lhs.true.if.end6_crit_edge.i ], [ %8, %if.end.i ]
  %incdec.ptr.i = getelementptr i8, ptr %10, i64 1
  store ptr %incdec.ptr.i, ptr %ptr, align 8
  store i8 0, ptr %10, align 1
  %11 = load ptr, ptr %start.i.i, align 8
  %tobool8.not = icmp eq ptr %11, null
  br i1 %tobool8.not, label %return, label %if.end10

if.end10:                                         ; preds = %poolStoreString.exit
  %incdec.ptr11 = getelementptr i8, ptr %11, i64 1
  %attributeIds = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 2
  %call12 = call fastcc ptr @lookup(ptr noundef %parser, ptr noundef nonnull %attributeIds, ptr noundef %incdec.ptr11, i64 noundef 24)
  %tobool13.not = icmp eq ptr %call12, null
  br i1 %tobool13.not, label %return, label %if.end15

if.end15:                                         ; preds = %if.end10
  %12 = load ptr, ptr %call12, align 8
  %cmp17.not = icmp eq ptr %12, %incdec.ptr11
  br i1 %cmp17.not, label %if.else, label %if.then18

if.then18:                                        ; preds = %if.end15
  %13 = load ptr, ptr %start.i.i, align 8
  store ptr %13, ptr %ptr, align 8
  br label %return

if.else:                                          ; preds = %if.end15
  %14 = load ptr, ptr %ptr, align 8
  store ptr %14, ptr %start.i.i, align 8
  %m_ns = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 38
  %15 = load i8, ptr %m_ns, align 8
  %tobool27.not = icmp eq i8 %15, 0
  br i1 %tobool27.not, label %return, label %if.else29

if.else29:                                        ; preds = %if.else
  %16 = load i8, ptr %incdec.ptr11, align 1
  %cmp30 = icmp eq i8 %16, 120
  br i1 %cmp30, label %land.lhs.true32, label %for.cond.preheader

for.cond.preheader:                               ; preds = %land.lhs.true52, %land.lhs.true47, %land.lhs.true42, %land.lhs.true37, %land.lhs.true32, %if.else29
  br label %for.cond

land.lhs.true32:                                  ; preds = %if.else29
  %arrayidx33 = getelementptr i8, ptr %11, i64 2
  %17 = load i8, ptr %arrayidx33, align 1
  %cmp35 = icmp eq i8 %17, 109
  br i1 %cmp35, label %land.lhs.true37, label %for.cond.preheader

land.lhs.true37:                                  ; preds = %land.lhs.true32
  %arrayidx38 = getelementptr i8, ptr %11, i64 3
  %18 = load i8, ptr %arrayidx38, align 1
  %cmp40 = icmp eq i8 %18, 108
  br i1 %cmp40, label %land.lhs.true42, label %for.cond.preheader

land.lhs.true42:                                  ; preds = %land.lhs.true37
  %arrayidx43 = getelementptr i8, ptr %11, i64 4
  %19 = load i8, ptr %arrayidx43, align 1
  %cmp45 = icmp eq i8 %19, 110
  br i1 %cmp45, label %land.lhs.true47, label %for.cond.preheader

land.lhs.true47:                                  ; preds = %land.lhs.true42
  %arrayidx48 = getelementptr i8, ptr %11, i64 5
  %20 = load i8, ptr %arrayidx48, align 1
  %cmp50 = icmp eq i8 %20, 115
  br i1 %cmp50, label %land.lhs.true52, label %for.cond.preheader

land.lhs.true52:                                  ; preds = %land.lhs.true47
  %arrayidx53 = getelementptr i8, ptr %11, i64 6
  %21 = load i8, ptr %arrayidx53, align 1
  switch i8 %21, label %for.cond.preheader [
    i8 0, label %if.then66
    i8 58, label %if.else67
  ]

if.then66:                                        ; preds = %land.lhs.true52
  %defaultPrefix = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 11
  br label %if.end70

if.else67:                                        ; preds = %land.lhs.true52
  %prefixes = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 3
  %add.ptr = getelementptr i8, ptr %11, i64 7
  %call68 = call fastcc ptr @lookup(ptr noundef nonnull %parser, ptr noundef nonnull %prefixes, ptr noundef %add.ptr, i64 noundef 16)
  br label %if.end70

if.end70:                                         ; preds = %if.else67, %if.then66
  %call68.sink = phi ptr [ %call68, %if.else67 ], [ %defaultPrefix, %if.then66 ]
  %prefix69 = getelementptr inbounds %struct.attribute_id, ptr %call12, i64 0, i32 1
  store ptr %call68.sink, ptr %prefix69, align 8
  %xmlns = getelementptr inbounds %struct.attribute_id, ptr %call12, i64 0, i32 3
  store i8 1, ptr %xmlns, align 1
  br label %return

for.cond:                                         ; preds = %for.cond.preheader, %for.inc147
  %22 = phi i8 [ %.pre70, %for.inc147 ], [ %16, %for.cond.preheader ]
  %i.0 = phi i32 [ %inc148, %for.inc147 ], [ 0, %for.cond.preheader ]
  switch i8 %22, label %for.inc147 [
    i8 0, label %return
    i8 58, label %for.cond80.preheader
  ]

for.cond80.preheader:                             ; preds = %for.cond
  %cmp8164 = icmp sgt i32 %i.0, 0
  br i1 %cmp8164, label %for.body83.preheader, label %for.end

for.body83.preheader:                             ; preds = %for.cond80.preheader
  %wide.trip.count = zext nneg i32 %i.0 to i64
  br label %for.body83

for.body83:                                       ; preds = %for.body83.preheader, %cond.false95
  %indvars.iv = phi i64 [ 0, %for.body83.preheader ], [ %indvars.iv.next, %cond.false95 ]
  %23 = load ptr, ptr %ptr, align 8
  %24 = load ptr, ptr %end2, align 8
  %cmp88 = icmp eq ptr %23, %24
  br i1 %cmp88, label %land.lhs.true90, label %cond.false95

land.lhs.true90:                                  ; preds = %for.body83
  %call92 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool), !range !13
  %tobool93.not = icmp eq i8 %call92, 0
  br i1 %tobool93.not, label %return, label %land.lhs.true90.cond.false95_crit_edge

land.lhs.true90.cond.false95_crit_edge:           ; preds = %land.lhs.true90
  %.pre71 = load ptr, ptr %ptr, align 8
  br label %cond.false95

cond.false95:                                     ; preds = %land.lhs.true90.cond.false95_crit_edge, %for.body83
  %25 = phi ptr [ %.pre71, %land.lhs.true90.cond.false95_crit_edge ], [ %23, %for.body83 ]
  %arrayidx97 = getelementptr i8, ptr %incdec.ptr11, i64 %indvars.iv
  %26 = load i8, ptr %arrayidx97, align 1
  %incdec.ptr100 = getelementptr i8, ptr %25, i64 1
  store ptr %incdec.ptr100, ptr %ptr, align 8
  store i8 %26, ptr %25, align 1
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.end.loopexit, label %for.body83, !llvm.loop !47

for.end.loopexit:                                 ; preds = %cond.false95
  %.pre72 = load ptr, ptr %ptr, align 8
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %for.cond80.preheader
  %27 = phi ptr [ %.pre72, %for.end.loopexit ], [ %14, %for.cond80.preheader ]
  %28 = load ptr, ptr %end2, align 8
  %cmp107 = icmp eq ptr %27, %28
  br i1 %cmp107, label %land.lhs.true109, label %cond.false114

land.lhs.true109:                                 ; preds = %for.end
  %call111 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool), !range !13
  %tobool112.not = icmp eq i8 %call111, 0
  br i1 %tobool112.not, label %return, label %land.lhs.true109.cond.false114_crit_edge

land.lhs.true109.cond.false114_crit_edge:         ; preds = %land.lhs.true109
  %.pre73 = load ptr, ptr %ptr, align 8
  br label %cond.false114

cond.false114:                                    ; preds = %land.lhs.true109.cond.false114_crit_edge, %for.end
  %29 = phi ptr [ %.pre73, %land.lhs.true109.cond.false114_crit_edge ], [ %27, %for.end ]
  %incdec.ptr117 = getelementptr i8, ptr %29, i64 1
  store ptr %incdec.ptr117, ptr %ptr, align 8
  store i8 0, ptr %29, align 1
  %prefixes120 = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 3
  %30 = load ptr, ptr %start.i.i, align 8
  %call123 = call fastcc ptr @lookup(ptr noundef %parser, ptr noundef nonnull %prefixes120, ptr noundef %30, i64 noundef 16)
  %prefix124 = getelementptr inbounds %struct.attribute_id, ptr %call12, i64 0, i32 1
  store ptr %call123, ptr %prefix124, align 8
  %tobool126.not = icmp eq ptr %call123, null
  br i1 %tobool126.not, label %return, label %if.end128

if.end128:                                        ; preds = %cond.false114
  %31 = load ptr, ptr %call123, align 8
  %32 = load ptr, ptr %start.i.i, align 8
  %cmp133 = icmp eq ptr %31, %32
  br i1 %cmp133, label %if.then135, label %if.else140

if.then135:                                       ; preds = %if.end128
  %33 = load ptr, ptr %ptr, align 8
  store ptr %33, ptr %start.i.i, align 8
  br label %return

if.else140:                                       ; preds = %if.end128
  store ptr %32, ptr %ptr, align 8
  br label %return

for.inc147:                                       ; preds = %for.cond
  %inc148 = add i32 %i.0, 1
  %idxprom.phi.trans.insert = sext i32 %inc148 to i64
  %arrayidx72.phi.trans.insert = getelementptr i8, ptr %incdec.ptr11, i64 %idxprom.phi.trans.insert
  %.pre70 = load i8, ptr %arrayidx72.phi.trans.insert, align 1
  br label %for.cond, !llvm.loop !48

return:                                           ; preds = %for.cond, %land.lhs.true90, %poolAppend.exit.thread.i, %land.lhs.true.i, %poolAppend.exit.i, %if.then18, %if.end70, %if.then135, %if.else140, %if.else, %cond.false114, %land.lhs.true109, %if.end10, %poolStoreString.exit, %land.lhs.true
  %retval.0 = phi ptr [ null, %land.lhs.true ], [ null, %poolStoreString.exit ], [ null, %if.end10 ], [ null, %land.lhs.true109 ], [ null, %cond.false114 ], [ %call12, %if.else ], [ %call12, %if.else140 ], [ %call12, %if.then135 ], [ %call12, %if.end70 ], [ %call12, %if.then18 ], [ null, %poolAppend.exit.i ], [ null, %land.lhs.true.i ], [ null, %poolAppend.exit.thread.i ], [ null, %land.lhs.true90 ], [ %call12, %for.cond ]
  ret ptr %retval.0
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @defineAttribute(ptr nocapture noundef %type, ptr noundef %attId, i8 noundef zeroext %isCdata, i8 noundef zeroext %isId, ptr noundef %value, ptr nocapture noundef readonly %parser) unnamed_addr #0 {
entry:
  %tobool = icmp ne ptr %value, null
  %tobool1 = icmp ne i8 %isId, 0
  %or.cond = or i1 %tobool1, %tobool
  %nDefaultAtts = getelementptr inbounds %struct.ELEMENT_TYPE, ptr %type, i64 0, i32 3
  %0 = load i32, ptr %nDefaultAtts, align 8
  br i1 %or.cond, label %for.cond.preheader, label %if.end14

for.cond.preheader:                               ; preds = %entry
  %cmp34 = icmp sgt i32 %0, 0
  br i1 %cmp34, label %for.body.lr.ph, label %for.end

for.body.lr.ph:                                   ; preds = %for.cond.preheader
  %defaultAtts = getelementptr inbounds %struct.ELEMENT_TYPE, ptr %type, i64 0, i32 5
  %1 = load ptr, ptr %defaultAtts, align 8
  %wide.trip.count = zext nneg i32 %0 to i64
  br label %for.body

for.cond:                                         ; preds = %for.body
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !35

for.body:                                         ; preds = %for.body.lr.ph, %for.cond
  %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.cond ]
  %arrayidx = getelementptr %struct.DEFAULT_ATTRIBUTE, ptr %1, i64 %indvars.iv
  %2 = load ptr, ptr %arrayidx, align 8
  %cmp3 = icmp eq ptr %2, %attId
  br i1 %cmp3, label %return, label %for.cond

for.end:                                          ; preds = %for.cond, %for.cond.preheader
  br i1 %tobool1, label %land.lhs.true, label %if.end14

land.lhs.true:                                    ; preds = %for.end
  %idAtt = getelementptr inbounds %struct.ELEMENT_TYPE, ptr %type, i64 0, i32 2
  %3 = load ptr, ptr %idAtt, align 8
  %tobool8.not = icmp eq ptr %3, null
  br i1 %tobool8.not, label %land.lhs.true9, label %if.end14

land.lhs.true9:                                   ; preds = %land.lhs.true
  %xmlns = getelementptr inbounds %struct.attribute_id, ptr %attId, i64 0, i32 3
  %4 = load i8, ptr %xmlns, align 1
  %tobool10.not = icmp eq i8 %4, 0
  br i1 %tobool10.not, label %if.then11, label %if.end14

if.then11:                                        ; preds = %land.lhs.true9
  store ptr %attId, ptr %idAtt, align 8
  br label %if.end14

if.end14:                                         ; preds = %entry, %for.end, %land.lhs.true, %land.lhs.true9, %if.then11
  %nDefaultAtts15 = getelementptr inbounds %struct.ELEMENT_TYPE, ptr %type, i64 0, i32 3
  %allocDefaultAtts = getelementptr inbounds %struct.ELEMENT_TYPE, ptr %type, i64 0, i32 4
  %5 = load i32, ptr %allocDefaultAtts, align 4
  %cmp16 = icmp eq i32 %0, %5
  br i1 %cmp16, label %if.then18, label %if.end14.if.end51_crit_edge

if.end14.if.end51_crit_edge:                      ; preds = %if.end14
  %defaultAtts52.phi.trans.insert = getelementptr inbounds %struct.ELEMENT_TYPE, ptr %type, i64 0, i32 5
  %.pre37 = load ptr, ptr %defaultAtts52.phi.trans.insert, align 8
  br label %if.end51

if.then18:                                        ; preds = %if.end14
  %cmp20 = icmp eq i32 %0, 0
  br i1 %cmp20, label %if.then22, label %if.else

if.then22:                                        ; preds = %if.then18
  store i32 8, ptr %allocDefaultAtts, align 4
  %m_mem = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 3
  %6 = load ptr, ptr %m_mem, align 8
  %call = tail call ptr %6(i64 noundef 192) #24
  %defaultAtts26 = getelementptr inbounds %struct.ELEMENT_TYPE, ptr %type, i64 0, i32 5
  store ptr %call, ptr %defaultAtts26, align 8
  %tobool28.not = icmp eq ptr %call, null
  br i1 %tobool28.not, label %if.then29, label %if.end51

if.then29:                                        ; preds = %if.then22
  store i32 0, ptr %allocDefaultAtts, align 4
  br label %return

if.else:                                          ; preds = %if.then18
  %cmp33 = icmp sgt i32 %0, 1073741823
  br i1 %cmp33, label %return, label %if.end36

if.end36:                                         ; preds = %if.else
  %mul38 = shl i32 %0, 1
  %realloc_fcn = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 3, i32 1
  %7 = load ptr, ptr %realloc_fcn, align 8
  %defaultAtts40 = getelementptr inbounds %struct.ELEMENT_TYPE, ptr %type, i64 0, i32 5
  %8 = load ptr, ptr %defaultAtts40, align 8
  %conv41 = sext i32 %mul38 to i64
  %mul42 = mul nsw i64 %conv41, 24
  %call43 = tail call ptr %7(ptr noundef %8, i64 noundef %mul42) #24
  %cmp44 = icmp eq ptr %call43, null
  br i1 %cmp44, label %return, label %if.end47

if.end47:                                         ; preds = %if.end36
  store i32 %mul38, ptr %allocDefaultAtts, align 4
  store ptr %call43, ptr %defaultAtts40, align 8
  br label %if.end51

if.end51:                                         ; preds = %if.end14.if.end51_crit_edge, %if.end47, %if.then22
  %9 = phi ptr [ %.pre37, %if.end14.if.end51_crit_edge ], [ %call43, %if.end47 ], [ %call, %if.then22 ]
  %10 = load i32, ptr %nDefaultAtts15, align 8
  %idx.ext = sext i32 %10 to i64
  %add.ptr = getelementptr %struct.DEFAULT_ATTRIBUTE, ptr %9, i64 %idx.ext
  store ptr %attId, ptr %add.ptr, align 8
  %value55 = getelementptr %struct.DEFAULT_ATTRIBUTE, ptr %9, i64 %idx.ext, i32 2
  store ptr %value, ptr %value55, align 8
  %isCdata56 = getelementptr %struct.DEFAULT_ATTRIBUTE, ptr %9, i64 %idx.ext, i32 1
  store i8 %isCdata, ptr %isCdata56, align 8
  %tobool57.not = icmp eq i8 %isCdata, 0
  br i1 %tobool57.not, label %if.then58, label %if.end59

if.then58:                                        ; preds = %if.end51
  %maybeTokenized = getelementptr inbounds %struct.attribute_id, ptr %attId, i64 0, i32 2
  store i8 1, ptr %maybeTokenized, align 8
  br label %if.end59

if.end59:                                         ; preds = %if.then58, %if.end51
  %11 = load i32, ptr %nDefaultAtts15, align 8
  %add = add i32 %11, 1
  store i32 %add, ptr %nDefaultAtts15, align 8
  br label %return

return:                                           ; preds = %for.body, %if.end36, %if.else, %if.end59, %if.then29
  %retval.0 = phi i32 [ 1, %if.end59 ], [ 0, %if.then29 ], [ 0, %if.else ], [ 0, %if.end36 ], [ 1, %for.body ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal fastcc zeroext i8 @poolGrow(ptr nocapture noundef %pool) unnamed_addr #0 {
entry:
  %freeBlocks = getelementptr inbounds %struct.STRING_POOL, ptr %pool, i64 0, i32 1
  %0 = load ptr, ptr %freeBlocks, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %if.end57, label %if.then

if.then:                                          ; preds = %entry
  %start = getelementptr inbounds %struct.STRING_POOL, ptr %pool, i64 0, i32 4
  %1 = load ptr, ptr %start, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then1, label %if.end

if.then1:                                         ; preds = %if.then
  store ptr %0, ptr %pool, align 8
  %2 = load ptr, ptr %0, align 8
  store ptr %2, ptr %freeBlocks, align 8
  store ptr null, ptr %0, align 8
  %3 = load ptr, ptr %pool, align 8
  %s = getelementptr inbounds %struct.block, ptr %3, i64 0, i32 2
  store ptr %s, ptr %start, align 8
  %size = getelementptr inbounds %struct.block, ptr %3, i64 0, i32 1
  %4 = load i32, ptr %size, align 8
  %idx.ext = sext i32 %4 to i64
  %add.ptr = getelementptr i8, ptr %s, i64 %idx.ext
  %end = getelementptr inbounds %struct.STRING_POOL, ptr %pool, i64 0, i32 2
  store ptr %add.ptr, ptr %end, align 8
  %ptr = getelementptr inbounds %struct.STRING_POOL, ptr %pool, i64 0, i32 3
  store ptr %s, ptr %ptr, align 8
  br label %return

if.end:                                           ; preds = %if.then
  %end12 = getelementptr inbounds %struct.STRING_POOL, ptr %pool, i64 0, i32 2
  %5 = load ptr, ptr %end12, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %5 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %size15 = getelementptr inbounds %struct.block, ptr %0, i64 0, i32 1
  %6 = load i32, ptr %size15, align 8
  %conv = sext i32 %6 to i64
  %cmp16 = icmp slt i64 %sub.ptr.sub, %conv
  br i1 %cmp16, label %if.then18, label %if.end57

if.then18:                                        ; preds = %if.end
  %7 = load ptr, ptr %0, align 8
  %8 = load ptr, ptr %pool, align 8
  store ptr %8, ptr %0, align 8
  %9 = load ptr, ptr %freeBlocks, align 8
  store ptr %9, ptr %pool, align 8
  store ptr %7, ptr %freeBlocks, align 8
  %s28 = getelementptr inbounds %struct.block, ptr %9, i64 0, i32 2
  %10 = load ptr, ptr %start, align 8
  %11 = load ptr, ptr %end12, align 8
  %sub.ptr.lhs.cast33 = ptrtoint ptr %11 to i64
  %sub.ptr.rhs.cast34 = ptrtoint ptr %10 to i64
  %sub.ptr.sub35 = sub i64 %sub.ptr.lhs.cast33, %sub.ptr.rhs.cast34
  tail call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 4 %s28, ptr align 1 %10, i64 %sub.ptr.sub35, i1 false)
  %12 = load ptr, ptr %pool, align 8
  %s37 = getelementptr inbounds %struct.block, ptr %12, i64 0, i32 2
  %ptr39 = getelementptr inbounds %struct.STRING_POOL, ptr %pool, i64 0, i32 3
  %13 = load ptr, ptr %ptr39, align 8
  %14 = load ptr, ptr %start, align 8
  %sub.ptr.lhs.cast41 = ptrtoint ptr %13 to i64
  %sub.ptr.rhs.cast42 = ptrtoint ptr %14 to i64
  %sub.ptr.sub43 = sub i64 %sub.ptr.lhs.cast41, %sub.ptr.rhs.cast42
  %add.ptr44 = getelementptr i8, ptr %s37, i64 %sub.ptr.sub43
  store ptr %add.ptr44, ptr %ptr39, align 8
  store ptr %s37, ptr %start, align 8
  %size52 = getelementptr inbounds %struct.block, ptr %12, i64 0, i32 1
  %15 = load i32, ptr %size52, align 8
  %idx.ext53 = sext i32 %15 to i64
  %add.ptr54 = getelementptr i8, ptr %s37, i64 %idx.ext53
  store ptr %add.ptr54, ptr %end12, align 8
  br label %return

if.end57:                                         ; preds = %if.end, %entry
  %16 = load ptr, ptr %pool, align 8
  %tobool59.not = icmp ne ptr %16, null
  %start114.phi.trans.insert = getelementptr inbounds %struct.STRING_POOL, ptr %pool, i64 0, i32 4
  %.pre = load ptr, ptr %start114.phi.trans.insert, align 8
  %s62 = getelementptr inbounds %struct.block, ptr %16, i64 0, i32 2
  %cmp64 = icmp eq ptr %.pre, %s62
  %or.cond = select i1 %tobool59.not, i1 %cmp64, i1 false
  %end67 = getelementptr inbounds %struct.STRING_POOL, ptr %pool, i64 0, i32 2
  %17 = load ptr, ptr %end67, align 8
  br i1 %or.cond, label %if.then66, label %if.else

if.then66:                                        ; preds = %if.end57
  %sub.ptr.lhs.cast69 = ptrtoint ptr %17 to i64
  %sub.ptr.rhs.cast70 = ptrtoint ptr %.pre to i64
  %sub.ptr.sub71 = sub i64 %sub.ptr.lhs.cast69, %sub.ptr.rhs.cast70
  %conv72 = trunc i64 %sub.ptr.sub71 to i32
  %mul73 = shl i32 %conv72, 1
  %ptr74 = getelementptr inbounds %struct.STRING_POOL, ptr %pool, i64 0, i32 3
  %18 = load ptr, ptr %ptr74, align 8
  %sub.ptr.lhs.cast76 = ptrtoint ptr %18 to i64
  %sub.ptr.sub78 = sub i64 %sub.ptr.lhs.cast76, %sub.ptr.rhs.cast70
  %cmp79 = icmp slt i32 %mul73, 0
  br i1 %cmp79, label %return, label %if.end82

if.end82:                                         ; preds = %if.then66
  %narrow.i = add nuw i32 %mul73, 12
  %narrow4.i = tail call i32 @llvm.smax.i32(i32 %narrow.i, i32 0)
  %cmp.inv.i.not = icmp eq i32 %mul73, 0
  %cmp8397 = icmp eq i32 %narrow4.i, 0
  %cmp83 = select i1 %cmp.inv.i.not, i1 true, i1 %cmp8397
  br i1 %cmp83, label %return, label %if.end86

if.end86:                                         ; preds = %if.end82
  %retval.0.i = zext nneg i32 %narrow4.i to i64
  %mem = getelementptr inbounds %struct.STRING_POOL, ptr %pool, i64 0, i32 5
  %19 = load ptr, ptr %mem, align 8
  %realloc_fcn = getelementptr inbounds %struct.XML_Memory_Handling_Suite, ptr %19, i64 0, i32 1
  %20 = load ptr, ptr %realloc_fcn, align 8
  %call90 = tail call ptr %20(ptr noundef nonnull %16, i64 noundef %retval.0.i) #24
  %cmp91 = icmp eq ptr %call90, null
  br i1 %cmp91, label %return, label %if.end94

if.end94:                                         ; preds = %if.end86
  store ptr %call90, ptr %pool, align 8
  %size97 = getelementptr inbounds %struct.block, ptr %call90, i64 0, i32 1
  store i32 %mul73, ptr %size97, align 8
  %21 = load ptr, ptr %pool, align 8
  %s99 = getelementptr inbounds %struct.block, ptr %21, i64 0, i32 2
  %add.ptr101 = getelementptr i8, ptr %s99, i64 %sub.ptr.sub78
  store ptr %add.ptr101, ptr %ptr74, align 8
  store ptr %s99, ptr %start114.phi.trans.insert, align 8
  %idx.ext108 = zext nneg i32 %mul73 to i64
  %add.ptr109 = getelementptr i8, ptr %s99, i64 %idx.ext108
  store ptr %add.ptr109, ptr %end67, align 8
  br label %return

if.else:                                          ; preds = %if.end57
  %start114 = getelementptr inbounds %struct.STRING_POOL, ptr %pool, i64 0, i32 4
  %sub.ptr.lhs.cast115 = ptrtoint ptr %17 to i64
  %sub.ptr.rhs.cast116 = ptrtoint ptr %.pre to i64
  %sub.ptr.sub117 = sub i64 %sub.ptr.lhs.cast115, %sub.ptr.rhs.cast116
  %conv118 = trunc i64 %sub.ptr.sub117 to i32
  %cmp120 = icmp slt i32 %conv118, 0
  br i1 %cmp120, label %return, label %if.end123

if.end123:                                        ; preds = %if.else
  %cmp124 = icmp ult i32 %conv118, 1024
  br i1 %cmp124, label %22, label %if.else127

if.else127:                                       ; preds = %if.end123
  %mul128 = shl nuw i32 %conv118, 1
  %cmp129 = icmp slt i32 %mul128, 0
  br i1 %cmp129, label %return, label %22

22:                                               ; preds = %if.else127, %if.end123
  %blockSize112.0 = phi i32 [ 1024, %if.end123 ], [ %mul128, %if.else127 ]
  %narrow.i92 = add nuw i32 %blockSize112.0, 12
  %narrow4.i93 = tail call i32 @llvm.smax.i32(i32 %narrow.i92, i32 0)
  %cmp136 = icmp eq i32 %narrow4.i93, 0
  br i1 %cmp136, label %return, label %if.end139

if.end139:                                        ; preds = %22
  %retval.0.i96 = zext nneg i32 %narrow4.i93 to i64
  %mem140 = getelementptr inbounds %struct.STRING_POOL, ptr %pool, i64 0, i32 5
  %23 = load ptr, ptr %mem140, align 8
  %24 = load ptr, ptr %23, align 8
  %call141 = tail call ptr %24(i64 noundef %retval.0.i96) #24
  %tobool142.not = icmp eq ptr %call141, null
  br i1 %tobool142.not, label %return, label %if.end144

if.end144:                                        ; preds = %if.end139
  %size145 = getelementptr inbounds %struct.block, ptr %call141, i64 0, i32 1
  store i32 %blockSize112.0, ptr %size145, align 8
  %25 = load ptr, ptr %pool, align 8
  store ptr %25, ptr %call141, align 8
  store ptr %call141, ptr %pool, align 8
  %ptr149 = getelementptr inbounds %struct.STRING_POOL, ptr %pool, i64 0, i32 3
  %26 = load ptr, ptr %ptr149, align 8
  %27 = load ptr, ptr %start114, align 8
  %cmp151.not = icmp eq ptr %26, %27
  br i1 %cmp151.not, label %if.end163, label %if.then153

if.then153:                                       ; preds = %if.end144
  %s154 = getelementptr inbounds %struct.block, ptr %call141, i64 0, i32 2
  %sub.ptr.lhs.cast159 = ptrtoint ptr %26 to i64
  %sub.ptr.rhs.cast160 = ptrtoint ptr %27 to i64
  %sub.ptr.sub161 = sub i64 %sub.ptr.lhs.cast159, %sub.ptr.rhs.cast160
  tail call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 4 %s154, ptr align 1 %27, i64 %sub.ptr.sub161, i1 false)
  %.pre98 = load ptr, ptr %ptr149, align 8
  %.pre99 = load ptr, ptr %start114, align 8
  br label %if.end163

if.end163:                                        ; preds = %if.then153, %if.end144
  %28 = phi ptr [ %.pre99, %if.then153 ], [ %26, %if.end144 ]
  %29 = phi ptr [ %.pre98, %if.then153 ], [ %26, %if.end144 ]
  %s164 = getelementptr inbounds %struct.block, ptr %call141, i64 0, i32 2
  %sub.ptr.lhs.cast168 = ptrtoint ptr %29 to i64
  %sub.ptr.rhs.cast169 = ptrtoint ptr %28 to i64
  %sub.ptr.sub170 = sub i64 %sub.ptr.lhs.cast168, %sub.ptr.rhs.cast169
  %add.ptr171 = getelementptr i8, ptr %s164, i64 %sub.ptr.sub170
  store ptr %add.ptr171, ptr %ptr149, align 8
  store ptr %s164, ptr %start114, align 8
  %idx.ext178 = zext nneg i32 %blockSize112.0 to i64
  %add.ptr179 = getelementptr i8, ptr %s164, i64 %idx.ext178
  store ptr %add.ptr179, ptr %end67, align 8
  br label %return

return:                                           ; preds = %if.end94, %if.end163, %if.end139, %22, %if.else127, %if.else, %if.end86, %if.end82, %if.then66, %if.then18, %if.then1
  %retval.0 = phi i8 [ 1, %if.then1 ], [ 1, %if.then18 ], [ 0, %if.then66 ], [ 0, %if.end82 ], [ 0, %if.end86 ], [ 0, %if.else ], [ 0, %if.else127 ], [ 0, %22 ], [ 0, %if.end139 ], [ 1, %if.end163 ], [ 1, %if.end94 ]
  ret i8 %retval.0
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @storeEntityValue(ptr noundef %parser, ptr noundef %enc, ptr noundef %entityTextPtr, ptr noundef %entityTextEnd, i32 noundef %account) unnamed_addr #0 {
entry:
  %ptr.addr.i = alloca ptr, align 8
  %ptr.addr.i.i = alloca ptr, align 8
  %next = alloca ptr, align 8
  %buf = alloca [4 x i8], align 1
  %m_dtd = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 65
  %0 = load ptr, ptr %m_dtd, align 8
  %entityValuePool = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 5
  %inEntityValue = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 44, i32 5
  %1 = load i32, ptr %inEntityValue, align 8
  store i32 1, ptr %inEntityValue, align 8
  %2 = load ptr, ptr %entityValuePool, align 8
  %tobool.not = icmp eq ptr %2, null
  br i1 %tobool.not, label %if.then, label %if.end5

if.then:                                          ; preds = %entry
  %call = tail call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %entityValuePool), !range !13
  %tobool3.not = icmp eq i8 %call, 0
  br i1 %tobool3.not, label %return, label %if.end5

if.end5:                                          ; preds = %if.then, %entry
  %arrayidx = getelementptr %struct.encoding, ptr %enc, i64 0, i32 1, i64 1
  %charRefNumber = getelementptr inbounds %struct.encoding, ptr %enc, i64 0, i32 6
  %end105 = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 5, i32 2
  %ptr106 = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 5, i32 3
  %minBytesPerChar77 = getelementptr inbounds %struct.encoding, ptr %enc, i64 0, i32 12
  %utf8Convert.i = getelementptr inbounds %struct.encoding, ptr %enc, i64 0, i32 10
  %start.i = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 5, i32 4
  %m_isParamEntity = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 86
  %m_encoding = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 34
  %m_tempPool = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 79
  %ptr1.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 79, i32 3
  %end4.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 79, i32 2
  %start.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 79, i32 4
  %size.i = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 10, i32 2
  %paramEntities = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 10
  %power30.i = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 10, i32 1
  %m_externalEntityRefHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 26
  %paramEntityRead = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 9
  %m_externalEntityRefHandlerArg = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 27
  %standalone51 = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 8
  %keepProcessing52 = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 6
  %m_internalEncoding = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 36
  br label %for.cond

for.cond:                                         ; preds = %sw.epilog, %if.end5
  %entityTextPtr.addr.0 = phi ptr [ %entityTextPtr, %if.end5 ], [ %113, %sw.epilog ]
  store ptr %entityTextPtr.addr.0, ptr %next, align 8
  %3 = load ptr, ptr %arrayidx, align 8
  %call6 = call i32 %3(ptr noundef %enc, ptr noundef %entityTextPtr.addr.0, ptr noundef %entityTextEnd, ptr noundef nonnull %next) #24
  %4 = load ptr, ptr %next, align 8
  %call7 = call fastcc zeroext i8 @accountingDiffTolerated(ptr noundef %parser, i32 noundef %call6, ptr noundef %entityTextPtr.addr.0, ptr noundef %4, i32 noundef 6109, i32 noundef %account), !range !13
  %tobool8.not = icmp eq i8 %call7, 0
  br i1 %tobool8.not, label %while.cond.i.i.i, label %if.end10

while.cond.i.i.i:                                 ; preds = %for.cond, %while.cond.i.i.i
  %rootParser.0.i.i.i = phi ptr [ %5, %while.cond.i.i.i ], [ %parser, %for.cond ]
  %m_parentParser.i.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i.i, i64 0, i32 84
  %5 = load ptr, ptr %m_parentParser.i.i.i, align 8
  %tobool.not.i.i.i = icmp eq ptr %5, null
  br i1 %tobool.not.i.i.i, label %getRootParserOf.exit.i.i, label %while.cond.i.i.i, !llvm.loop !31

getRootParserOf.exit.i.i:                         ; preds = %while.cond.i.i.i
  %debugLevel.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i.i, i64 0, i32 90, i32 2
  %6 = load i32, ptr %debugLevel.i.i, align 8
  %cmp.i.i = icmp slt i32 %6, 1
  br i1 %cmp.i.i, label %endEntityValue, label %if.end.i.i

if.end.i.i:                                       ; preds = %getRootParserOf.exit.i.i
  %m_accounting.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i.i, i64 0, i32 90
  %7 = load i64, ptr %m_accounting.i.i, align 8
  %tobool.not.i5.i.i = icmp eq i64 %7, 0
  %countBytesIndirect.phi.trans.insert.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i.i, i64 0, i32 90, i32 1
  %.pre.i.i = load i64, ptr %countBytesIndirect.phi.trans.insert.i.i, align 8
  br i1 %tobool.not.i5.i.i, label %accountingGetCurrentAmplification.exit.i.i, label %cond.true.i.i.i

cond.true.i.i.i:                                  ; preds = %if.end.i.i
  %add.i.i.i = add i64 %.pre.i.i, %7
  %conv.i.i.i = uitofp i64 %add.i.i.i to float
  %conv6.i.i.i = uitofp i64 %7 to float
  %div.i.i.i = fdiv float %conv.i.i.i, %conv6.i.i.i
  %8 = fpext float %div.i.i.i to double
  br label %accountingGetCurrentAmplification.exit.i.i

accountingGetCurrentAmplification.exit.i.i:       ; preds = %cond.true.i.i.i, %if.end.i.i
  %cond.i.i.i = phi double [ %8, %cond.true.i.i.i ], [ 1.000000e+00, %if.end.i.i ]
  %9 = load ptr, ptr @stderr, align 8
  %call4.i.i = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %9, ptr noundef nonnull @.str.311, ptr noundef nonnull %rootParser.0.i.i.i, i64 noundef %7, i64 noundef %.pre.i.i, double noundef %cond.i.i.i, ptr noundef nonnull @.str.317) #27
  br label %endEntityValue

if.end10:                                         ; preds = %for.cond
  switch i32 %call6, label %sw.default [
    i32 28, label %sw.bb
    i32 -4, label %endEntityValue
    i32 9, label %sw.bb71
    i32 6, label %sw.bb71
    i32 -3, label %sw.bb76
    i32 7, label %sw.bb80
    i32 10, label %sw.bb89
    i32 -1, label %sw.bb117
    i32 0, label %sw.bb124
  ]

sw.bb:                                            ; preds = %if.end10
  %10 = load i8, ptr %m_isParamEntity, align 8
  %tobool11.not = icmp eq i8 %10, 0
  br i1 %tobool11.not, label %lor.lhs.false, label %if.then13

lor.lhs.false:                                    ; preds = %sw.bb
  %11 = load ptr, ptr %m_encoding, align 8
  %cmp.not = icmp eq ptr %11, %enc
  br i1 %cmp.not, label %if.end68, label %if.then13

if.then13:                                        ; preds = %lor.lhs.false, %sw.bb
  %12 = load i32, ptr %minBytesPerChar77, align 8
  %idx.ext = sext i32 %12 to i64
  %add.ptr = getelementptr i8, ptr %entityTextPtr.addr.0, i64 %idx.ext
  %13 = load ptr, ptr %next, align 8
  %idx.neg = sub nsw i64 0, %idx.ext
  %add.ptr16 = getelementptr i8, ptr %13, i64 %idx.neg
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ptr.addr.i.i)
  store ptr %add.ptr, ptr %ptr.addr.i.i, align 8
  %14 = load ptr, ptr %ptr1.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %14, null
  br i1 %tobool.not.i.i, label %land.lhs.true.i.i, label %for.cond.i.i.preheader

land.lhs.true.i.i:                                ; preds = %if.then13
  %call.i.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool), !range !13
  %tobool2.not.i.i = icmp eq i8 %call.i.i, 0
  br i1 %tobool2.not.i.i, label %poolAppend.exit.thread.i, label %for.cond.i.i.preheader

for.cond.i.i.preheader:                           ; preds = %land.lhs.true.i.i, %if.then13
  br label %for.cond.i.i

for.cond.i.i:                                     ; preds = %for.cond.i.i.preheader, %if.end8.i.i
  %15 = load ptr, ptr %utf8Convert.i, align 8
  %16 = load ptr, ptr %end4.i.i, align 8
  %call5.i.i = call i32 %15(ptr noundef nonnull %enc, ptr noundef nonnull %ptr.addr.i.i, ptr noundef %add.ptr16, ptr noundef nonnull %ptr1.i.i, ptr noundef %16) #24
  %or.cond.i.i = icmp ult i32 %call5.i.i, 2
  br i1 %or.cond.i.i, label %poolAppend.exit.i, label %if.end8.i.i

if.end8.i.i:                                      ; preds = %for.cond.i.i
  %call9.i.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool), !range !13
  %tobool10.not.i.i = icmp eq i8 %call9.i.i, 0
  br i1 %tobool10.not.i.i, label %poolAppend.exit.thread.i, label %for.cond.i.i

poolAppend.exit.thread.i:                         ; preds = %land.lhs.true.i.i, %if.end8.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i)
  br label %endEntityValue

poolAppend.exit.i:                                ; preds = %for.cond.i.i
  %17 = load ptr, ptr %start.i.i, align 8
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i)
  %tobool.not.i = icmp eq ptr %17, null
  br i1 %tobool.not.i, label %endEntityValue, label %if.end.i

if.end.i:                                         ; preds = %poolAppend.exit.i
  %18 = load ptr, ptr %ptr1.i.i, align 8
  %19 = load ptr, ptr %end4.i.i, align 8
  %cmp.i = icmp eq ptr %18, %19
  br i1 %cmp.i, label %land.lhs.true.i, label %poolStoreString.exit

land.lhs.true.i:                                  ; preds = %if.end.i
  %call3.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool), !range !13
  %tobool4.not.i = icmp eq i8 %call3.i, 0
  br i1 %tobool4.not.i, label %endEntityValue, label %land.lhs.true.if.end6_crit_edge.i

land.lhs.true.if.end6_crit_edge.i:                ; preds = %land.lhs.true.i
  %.pre.i = load ptr, ptr %ptr1.i.i, align 8
  br label %poolStoreString.exit

poolStoreString.exit:                             ; preds = %if.end.i, %land.lhs.true.if.end6_crit_edge.i
  %20 = phi ptr [ %.pre.i, %land.lhs.true.if.end6_crit_edge.i ], [ %18, %if.end.i ]
  %incdec.ptr.i = getelementptr i8, ptr %20, i64 1
  store ptr %incdec.ptr.i, ptr %ptr1.i.i, align 8
  store i8 0, ptr %20, align 1
  %21 = load ptr, ptr %start.i.i, align 8
  %tobool18.not = icmp eq ptr %21, null
  br i1 %tobool18.not, label %endEntityValue, label %if.end20

if.end20:                                         ; preds = %poolStoreString.exit
  %22 = load i64, ptr %size.i, align 8
  %cmp.i103 = icmp eq i64 %22, 0
  br i1 %cmp.i103, label %lookup.exit.thread, label %if.else.i

if.else.i:                                        ; preds = %if.end20
  %call12.i = call fastcc i64 @hash(ptr noundef nonnull %parser, ptr noundef nonnull %21)
  %23 = load i64, ptr %size.i, align 8
  %sub14.i = add i64 %23, -1
  %and15.i = and i64 %sub14.i, %call12.i
  %24 = load ptr, ptr %paramEntities, align 8
  %arrayidx111.i = getelementptr ptr, ptr %24, i64 %and15.i
  %25 = load ptr, ptr %arrayidx111.i, align 8
  %tobool17.not112.i = icmp eq ptr %25, null
  br i1 %tobool17.not112.i, label %lookup.exit.thread, label %while.body.lr.ph.i

while.body.lr.ph.i:                               ; preds = %if.else.i
  %26 = load i8, ptr %21, align 1
  %not.i = sub i64 0, %23
  %and29.i = and i64 %call12.i, %not.i
  %shr32.i = lshr i64 %sub14.i, 2
  br label %while.body.i

while.body.i:                                     ; preds = %if.end35.i, %while.body.lr.ph.i
  %27 = phi ptr [ %25, %while.body.lr.ph.i ], [ %35, %if.end35.i ]
  %i.0114.i = phi i64 [ %and15.i, %while.body.lr.ph.i ], [ %i.1.i, %if.end35.i ]
  %step.0113.i = phi i8 [ 0, %while.body.lr.ph.i ], [ %step.1.i, %if.end35.i ]
  %28 = load ptr, ptr %27, align 8
  %29 = load i8, ptr %28, align 1
  %cmp5.i.i = icmp eq i8 %26, %29
  br i1 %cmp5.i.i, label %for.body.i.i, label %if.end26.i

for.body.i.i:                                     ; preds = %while.body.i, %for.inc.i.i
  %30 = phi i8 [ %31, %for.inc.i.i ], [ %26, %while.body.i ]
  %s2.addr.07.i.i = phi ptr [ %incdec.ptr6.i.i, %for.inc.i.i ], [ %28, %while.body.i ]
  %s1.addr.06.i.i = phi ptr [ %incdec.ptr.i.i, %for.inc.i.i ], [ %21, %while.body.i ]
  %cmp4.i.i = icmp eq i8 %30, 0
  br i1 %cmp4.i.i, label %lookup.exit, label %for.inc.i.i

for.inc.i.i:                                      ; preds = %for.body.i.i
  %incdec.ptr.i.i = getelementptr i8, ptr %s1.addr.06.i.i, i64 1
  %incdec.ptr6.i.i = getelementptr i8, ptr %s2.addr.07.i.i, i64 1
  %31 = load i8, ptr %incdec.ptr.i.i, align 1
  %32 = load i8, ptr %incdec.ptr6.i.i, align 1
  %cmp.i.i105 = icmp eq i8 %31, %32
  br i1 %cmp.i.i105, label %for.body.i.i, label %if.end26.i, !llvm.loop !14

if.end26.i:                                       ; preds = %for.inc.i.i, %while.body.i
  %tobool27.not.i = icmp eq i8 %step.0113.i, 0
  br i1 %tobool27.not.i, label %if.then28.i, label %if.end35.i

if.then28.i:                                      ; preds = %if.end26.i
  %33 = load i8, ptr %power30.i, align 8
  %conv.i = zext i8 %33 to i64
  %sub31.i = add nuw nsw i64 %conv.i, 4294967295
  %sh_prom.i = and i64 %sub31.i, 4294967295
  %shr.i = lshr i64 %and29.i, %sh_prom.i
  %and33.i = and i64 %shr.i, %shr32.i
  %34 = trunc i64 %and33.i to i8
  %conv34.i = or i8 %34, 1
  br label %if.end35.i

if.end35.i:                                       ; preds = %if.then28.i, %if.end26.i
  %step.1.i = phi i8 [ %step.0113.i, %if.end26.i ], [ %conv34.i, %if.then28.i ]
  %conv36.i = zext i8 %step.1.i to i64
  %cmp37.i = icmp ult i64 %i.0114.i, %conv36.i
  %i.1.p.v.i = select i1 %cmp37.i, i64 %23, i64 0
  %i.1.p.i = sub i64 %i.0114.i, %conv36.i
  %i.1.i = add i64 %i.1.p.v.i, %i.1.p.i
  %arrayidx.i = getelementptr ptr, ptr %24, i64 %i.1.i
  %35 = load ptr, ptr %arrayidx.i, align 8
  %tobool17.not.i = icmp eq ptr %35, null
  br i1 %tobool17.not.i, label %lookup.exit.thread, label %while.body.i, !llvm.loop !15

lookup.exit.thread:                               ; preds = %if.end20, %if.else.i, %if.end35.i
  %36 = load ptr, ptr %start.i.i, align 8
  store ptr %36, ptr %ptr1.i.i, align 8
  %37 = load i8, ptr %standalone51, align 2
  store i8 %37, ptr %keepProcessing52, align 8
  br label %endEntityValue

lookup.exit:                                      ; preds = %for.body.i.i
  %38 = load ptr, ptr %start.i.i, align 8
  store ptr %38, ptr %ptr1.i.i, align 8
  %open = getelementptr inbounds %struct.ENTITY, ptr %27, i64 0, i32 8
  %39 = load i8, ptr %open, align 8
  %tobool27.not = icmp eq i8 %39, 0
  br i1 %tobool27.not, label %if.end34, label %if.then28

if.then28:                                        ; preds = %lookup.exit
  %40 = load ptr, ptr %m_encoding, align 8
  %cmp30 = icmp eq ptr %40, %enc
  br i1 %cmp30, label %if.then32, label %endEntityValue

if.then32:                                        ; preds = %if.then28
  %m_eventPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 47
  store ptr %entityTextPtr.addr.0, ptr %m_eventPtr, align 8
  br label %endEntityValue

if.end34:                                         ; preds = %lookup.exit
  %systemId = getelementptr inbounds %struct.ENTITY, ptr %27, i64 0, i32 4
  %41 = load ptr, ptr %systemId, align 8
  %tobool35.not = icmp eq ptr %41, null
  br i1 %tobool35.not, label %if.else57, label %if.then36

if.then36:                                        ; preds = %if.end34
  %42 = load ptr, ptr %m_externalEntityRefHandler, align 8
  %tobool37.not = icmp eq ptr %42, null
  br i1 %tobool37.not, label %if.else, label %if.then38

if.then38:                                        ; preds = %if.then36
  store i8 0, ptr %paramEntityRead, align 1
  store i8 1, ptr %open, align 8
  br label %while.cond.i.i

while.cond.i.i:                                   ; preds = %while.cond.i.i, %if.then38
  %rootParser.0.i.i = phi ptr [ %parser, %if.then38 ], [ %43, %while.cond.i.i ]
  %m_parentParser.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i, i64 0, i32 84
  %43 = load ptr, ptr %m_parentParser.i.i, align 8
  %tobool.not.i.i106 = icmp eq ptr %43, null
  br i1 %tobool.not.i.i106, label %getRootParserOf.exit.i, label %while.cond.i.i, !llvm.loop !31

getRootParserOf.exit.i:                           ; preds = %while.cond.i.i
  %m_entity_stats.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i, i64 0, i32 91
  %44 = load i32, ptr %m_entity_stats.i, align 8
  %inc.i = add i32 %44, 1
  store i32 %inc.i, ptr %m_entity_stats.i, align 8
  %currentDepth.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i, i64 0, i32 91, i32 1
  %45 = load i32, ptr %currentDepth.i, align 4
  %inc2.i = add i32 %45, 1
  store i32 %inc2.i, ptr %currentDepth.i, align 4
  %maximumDepthSeen.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i, i64 0, i32 91, i32 2
  %46 = load i32, ptr %maximumDepthSeen.i, align 8
  %cmp.i107 = icmp ugt i32 %inc2.i, %46
  br i1 %cmp.i107, label %if.then.i113, label %if.end.i108

if.then.i113:                                     ; preds = %getRootParserOf.exit.i
  %inc8.i = add nuw i32 %46, 1
  store i32 %inc8.i, ptr %maximumDepthSeen.i, align 8
  br label %if.end.i108

if.end.i108:                                      ; preds = %if.then.i113, %getRootParserOf.exit.i
  %47 = phi i32 [ %inc8.i, %if.then.i113 ], [ %46, %getRootParserOf.exit.i ]
  %debugLevel.i.i109 = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i, i64 0, i32 91, i32 3
  %48 = load i32, ptr %debugLevel.i.i109, align 4
  %cmp.i.i110 = icmp slt i32 %48, 1
  br i1 %cmp.i.i110, label %entityTrackingOnOpen.exit, label %if.end.i.i111

if.end.i.i111:                                    ; preds = %if.end.i108
  %49 = load ptr, ptr %27, align 8
  %50 = load ptr, ptr @stderr, align 8
  %sub.i.i = shl i32 %inc2.i, 1
  %mul.i.i = add i32 %sub.i.i, -2
  %is_param.i.i = getelementptr inbounds %struct.ENTITY, ptr %27, i64 0, i32 9
  %51 = load i8, ptr %is_param.i.i, align 1
  %tobool.not.i6.i = icmp eq i8 %51, 0
  %cond.i.i = select i1 %tobool.not.i6.i, ptr @.str.89, ptr @.str.88
  %textLen.i.i = getelementptr inbounds %struct.ENTITY, ptr %27, i64 0, i32 2
  %52 = load i32, ptr %textLen.i.i, align 8
  %call.i.i112 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %50, ptr noundef nonnull @.str.320, ptr noundef nonnull %rootParser.0.i.i, i32 noundef %inc.i, i32 noundef %inc2.i, i32 noundef %47, i32 noundef %mul.i.i, ptr noundef nonnull @.str.310, ptr noundef nonnull %cond.i.i, ptr noundef %49, ptr noundef nonnull @.str.319, i32 noundef %52, i32 noundef 6152) #27
  br label %entityTrackingOnOpen.exit

entityTrackingOnOpen.exit:                        ; preds = %if.end.i108, %if.end.i.i111
  %53 = load ptr, ptr %m_externalEntityRefHandler, align 8
  %54 = load ptr, ptr %m_externalEntityRefHandlerArg, align 8
  %base = getelementptr inbounds %struct.ENTITY, ptr %27, i64 0, i32 5
  %55 = load ptr, ptr %base, align 8
  %56 = load ptr, ptr %systemId, align 8
  %publicId = getelementptr inbounds %struct.ENTITY, ptr %27, i64 0, i32 6
  %57 = load ptr, ptr %publicId, align 8
  %call42 = call i32 %53(ptr noundef %54, ptr noundef null, ptr noundef %55, ptr noundef %56, ptr noundef %57) #24
  %tobool43.not = icmp eq i32 %call42, 0
  br i1 %tobool43.not, label %if.then44, label %while.cond.i.i114

if.then44:                                        ; preds = %entityTrackingOnOpen.exit
  call fastcc void @entityTrackingOnClose(ptr noundef nonnull %parser, ptr noundef nonnull %27, i32 noundef 6156)
  store i8 0, ptr %open, align 8
  br label %endEntityValue

while.cond.i.i114:                                ; preds = %entityTrackingOnOpen.exit, %while.cond.i.i114
  %rootParser.0.i.i115 = phi ptr [ %58, %while.cond.i.i114 ], [ %parser, %entityTrackingOnOpen.exit ]
  %m_parentParser.i.i116 = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i115, i64 0, i32 84
  %58 = load ptr, ptr %m_parentParser.i.i116, align 8
  %tobool.not.i.i117 = icmp eq ptr %58, null
  br i1 %tobool.not.i.i117, label %getRootParserOf.exit.i118, label %while.cond.i.i114, !llvm.loop !31

getRootParserOf.exit.i118:                        ; preds = %while.cond.i.i114
  %debugLevel.i.i119 = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i115, i64 0, i32 91, i32 3
  %59 = load i32, ptr %debugLevel.i.i119, align 4
  %cmp.i.i120 = icmp slt i32 %59, 1
  br i1 %cmp.i.i120, label %entityTrackingOnClose.exit, label %if.end.i.i121

if.end.i.i121:                                    ; preds = %getRootParserOf.exit.i118
  %m_entity_stats.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i115, i64 0, i32 91
  %60 = load ptr, ptr %27, align 8
  %61 = load ptr, ptr @stderr, align 8
  %62 = load i32, ptr %m_entity_stats.i.i, align 8
  %currentDepth.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i115, i64 0, i32 91, i32 1
  %63 = load i32, ptr %currentDepth.i.i, align 4
  %maximumDepthSeen.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i115, i64 0, i32 91, i32 2
  %64 = load i32, ptr %maximumDepthSeen.i.i, align 8
  %sub.i.i122 = shl i32 %63, 1
  %mul.i.i123 = add i32 %sub.i.i122, -2
  %is_param.i.i124 = getelementptr inbounds %struct.ENTITY, ptr %27, i64 0, i32 9
  %65 = load i8, ptr %is_param.i.i124, align 1
  %tobool.not.i2.i = icmp eq i8 %65, 0
  %cond.i.i125 = select i1 %tobool.not.i2.i, ptr @.str.89, ptr @.str.88
  %textLen.i.i126 = getelementptr inbounds %struct.ENTITY, ptr %27, i64 0, i32 2
  %66 = load i32, ptr %textLen.i.i126, align 8
  %call.i.i127 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %61, ptr noundef nonnull @.str.320, ptr noundef nonnull %rootParser.0.i.i115, i32 noundef %62, i32 noundef %63, i32 noundef %64, i32 noundef %mul.i.i123, ptr noundef nonnull @.str.310, ptr noundef nonnull %cond.i.i125, ptr noundef %60, ptr noundef nonnull @.str.321, i32 noundef %66, i32 noundef 6161) #27
  br label %entityTrackingOnClose.exit

entityTrackingOnClose.exit:                       ; preds = %getRootParserOf.exit.i118, %if.end.i.i121
  %currentDepth.i128 = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i115, i64 0, i32 91, i32 1
  %67 = load i32, ptr %currentDepth.i128, align 4
  %dec.i = add i32 %67, -1
  store i32 %dec.i, ptr %currentDepth.i128, align 4
  store i8 0, ptr %open, align 8
  %68 = load i8, ptr %paramEntityRead, align 1
  %tobool49.not = icmp eq i8 %68, 0
  br i1 %tobool49.not, label %if.then50, label %sw.epilog

if.then50:                                        ; preds = %entityTrackingOnClose.exit
  %69 = load i8, ptr %standalone51, align 2
  store i8 %69, ptr %keepProcessing52, align 8
  br label %sw.epilog

if.else:                                          ; preds = %if.then36
  %70 = load i8, ptr %standalone51, align 2
  store i8 %70, ptr %keepProcessing52, align 8
  br label %sw.epilog

if.else57:                                        ; preds = %if.end34
  store i8 1, ptr %open, align 8
  br label %while.cond.i.i129

while.cond.i.i129:                                ; preds = %while.cond.i.i129, %if.else57
  %rootParser.0.i.i130 = phi ptr [ %parser, %if.else57 ], [ %71, %while.cond.i.i129 ]
  %m_parentParser.i.i131 = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i130, i64 0, i32 84
  %71 = load ptr, ptr %m_parentParser.i.i131, align 8
  %tobool.not.i.i132 = icmp eq ptr %71, null
  br i1 %tobool.not.i.i132, label %getRootParserOf.exit.i133, label %while.cond.i.i129, !llvm.loop !31

getRootParserOf.exit.i133:                        ; preds = %while.cond.i.i129
  %m_entity_stats.i134 = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i130, i64 0, i32 91
  %72 = load i32, ptr %m_entity_stats.i134, align 8
  %inc.i135 = add i32 %72, 1
  store i32 %inc.i135, ptr %m_entity_stats.i134, align 8
  %currentDepth.i136 = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i130, i64 0, i32 91, i32 1
  %73 = load i32, ptr %currentDepth.i136, align 4
  %inc2.i137 = add i32 %73, 1
  store i32 %inc2.i137, ptr %currentDepth.i136, align 4
  %maximumDepthSeen.i138 = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i130, i64 0, i32 91, i32 2
  %74 = load i32, ptr %maximumDepthSeen.i138, align 8
  %cmp.i139 = icmp ugt i32 %inc2.i137, %74
  br i1 %cmp.i139, label %if.then.i151, label %if.end.i140

if.then.i151:                                     ; preds = %getRootParserOf.exit.i133
  %inc8.i152 = add nuw i32 %74, 1
  store i32 %inc8.i152, ptr %maximumDepthSeen.i138, align 8
  br label %if.end.i140

if.end.i140:                                      ; preds = %if.then.i151, %getRootParserOf.exit.i133
  %75 = phi i32 [ %inc8.i152, %if.then.i151 ], [ %74, %getRootParserOf.exit.i133 ]
  %debugLevel.i.i141 = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i130, i64 0, i32 91, i32 3
  %76 = load i32, ptr %debugLevel.i.i141, align 4
  %cmp.i.i142 = icmp slt i32 %76, 1
  br i1 %cmp.i.i142, label %entityTrackingOnOpen.exit153, label %if.end.i.i143

if.end.i.i143:                                    ; preds = %if.end.i140
  %77 = load ptr, ptr %27, align 8
  %78 = load ptr, ptr @stderr, align 8
  %sub.i.i144 = shl i32 %inc2.i137, 1
  %mul.i.i145 = add i32 %sub.i.i144, -2
  %is_param.i.i146 = getelementptr inbounds %struct.ENTITY, ptr %27, i64 0, i32 9
  %79 = load i8, ptr %is_param.i.i146, align 1
  %tobool.not.i6.i147 = icmp eq i8 %79, 0
  %cond.i.i148 = select i1 %tobool.not.i6.i147, ptr @.str.89, ptr @.str.88
  %textLen.i.i149 = getelementptr inbounds %struct.ENTITY, ptr %27, i64 0, i32 2
  %80 = load i32, ptr %textLen.i.i149, align 8
  %call.i.i150 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %78, ptr noundef nonnull @.str.320, ptr noundef nonnull %rootParser.0.i.i130, i32 noundef %inc.i135, i32 noundef %inc2.i137, i32 noundef %75, i32 noundef %mul.i.i145, ptr noundef nonnull @.str.310, ptr noundef nonnull %cond.i.i148, ptr noundef %77, ptr noundef nonnull @.str.319, i32 noundef %80, i32 noundef 6169) #27
  br label %entityTrackingOnOpen.exit153

entityTrackingOnOpen.exit153:                     ; preds = %if.end.i140, %if.end.i.i143
  %81 = load ptr, ptr %m_internalEncoding, align 8
  %textPtr = getelementptr inbounds %struct.ENTITY, ptr %27, i64 0, i32 1
  %82 = load ptr, ptr %textPtr, align 8
  %textLen = getelementptr inbounds %struct.ENTITY, ptr %27, i64 0, i32 2
  %83 = load i32, ptr %textLen, align 8
  %idx.ext60 = sext i32 %83 to i64
  %add.ptr61 = getelementptr i8, ptr %82, i64 %idx.ext60
  %call62 = call fastcc i32 @storeEntityValue(ptr noundef %parser, ptr noundef %81, ptr noundef %82, ptr noundef %add.ptr61, i32 noundef 1)
  br label %while.cond.i.i154

while.cond.i.i154:                                ; preds = %while.cond.i.i154, %entityTrackingOnOpen.exit153
  %rootParser.0.i.i155 = phi ptr [ %parser, %entityTrackingOnOpen.exit153 ], [ %84, %while.cond.i.i154 ]
  %m_parentParser.i.i156 = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i155, i64 0, i32 84
  %84 = load ptr, ptr %m_parentParser.i.i156, align 8
  %tobool.not.i.i157 = icmp eq ptr %84, null
  br i1 %tobool.not.i.i157, label %getRootParserOf.exit.i158, label %while.cond.i.i154, !llvm.loop !31

getRootParserOf.exit.i158:                        ; preds = %while.cond.i.i154
  %debugLevel.i.i159 = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i155, i64 0, i32 91, i32 3
  %85 = load i32, ptr %debugLevel.i.i159, align 4
  %cmp.i.i160 = icmp slt i32 %85, 1
  br i1 %cmp.i.i160, label %entityTrackingOnClose.exit174, label %if.end.i.i161

if.end.i.i161:                                    ; preds = %getRootParserOf.exit.i158
  %m_entity_stats.i.i162 = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i155, i64 0, i32 91
  %86 = load ptr, ptr %27, align 8
  %87 = load ptr, ptr @stderr, align 8
  %88 = load i32, ptr %m_entity_stats.i.i162, align 8
  %currentDepth.i.i163 = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i155, i64 0, i32 91, i32 1
  %89 = load i32, ptr %currentDepth.i.i163, align 4
  %maximumDepthSeen.i.i164 = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i155, i64 0, i32 91, i32 2
  %90 = load i32, ptr %maximumDepthSeen.i.i164, align 8
  %sub.i.i165 = shl i32 %89, 1
  %mul.i.i166 = add i32 %sub.i.i165, -2
  %is_param.i.i167 = getelementptr inbounds %struct.ENTITY, ptr %27, i64 0, i32 9
  %91 = load i8, ptr %is_param.i.i167, align 1
  %tobool.not.i2.i168 = icmp eq i8 %91, 0
  %cond.i.i169 = select i1 %tobool.not.i2.i168, ptr @.str.89, ptr @.str.88
  %92 = load i32, ptr %textLen, align 8
  %call.i.i171 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %87, ptr noundef nonnull @.str.320, ptr noundef nonnull %rootParser.0.i.i155, i32 noundef %88, i32 noundef %89, i32 noundef %90, i32 noundef %mul.i.i166, ptr noundef nonnull @.str.310, ptr noundef nonnull %cond.i.i169, ptr noundef %86, ptr noundef nonnull @.str.321, i32 noundef %92, i32 noundef 6174) #27
  br label %entityTrackingOnClose.exit174

entityTrackingOnClose.exit174:                    ; preds = %getRootParserOf.exit.i158, %if.end.i.i161
  %currentDepth.i172 = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i155, i64 0, i32 91, i32 1
  %93 = load i32, ptr %currentDepth.i172, align 4
  %dec.i173 = add i32 %93, -1
  store i32 %dec.i173, ptr %currentDepth.i172, align 4
  store i8 0, ptr %open, align 8
  %tobool64.not = icmp eq i32 %call62, 0
  br i1 %tobool64.not, label %sw.epilog, label %endEntityValue

if.end68:                                         ; preds = %lor.lhs.false
  %m_eventPtr69 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 47
  store ptr %entityTextPtr.addr.0, ptr %m_eventPtr69, align 8
  br label %endEntityValue

sw.bb71:                                          ; preds = %if.end10, %if.end10
  %94 = load ptr, ptr %next, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ptr.addr.i)
  store ptr %entityTextPtr.addr.0, ptr %ptr.addr.i, align 8
  %95 = load ptr, ptr %ptr106, align 8
  %tobool.not.i175 = icmp eq ptr %95, null
  br i1 %tobool.not.i175, label %land.lhs.true.i178, label %for.cond.i.preheader

land.lhs.true.i178:                               ; preds = %sw.bb71
  %call.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %entityValuePool), !range !13
  %tobool2.not.i = icmp eq i8 %call.i, 0
  br i1 %tobool2.not.i, label %poolAppend.exit.thread, label %for.cond.i.preheader

for.cond.i.preheader:                             ; preds = %land.lhs.true.i178, %sw.bb71
  br label %for.cond.i

for.cond.i:                                       ; preds = %for.cond.i.preheader, %if.end8.i
  %96 = load ptr, ptr %utf8Convert.i, align 8
  %97 = load ptr, ptr %end105, align 8
  %call5.i = call i32 %96(ptr noundef nonnull %enc, ptr noundef nonnull %ptr.addr.i, ptr noundef %94, ptr noundef nonnull %ptr106, ptr noundef %97) #24
  %or.cond.i = icmp ult i32 %call5.i, 2
  br i1 %or.cond.i, label %poolAppend.exit, label %if.end8.i

if.end8.i:                                        ; preds = %for.cond.i
  %call9.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %entityValuePool), !range !13
  %tobool10.not.i = icmp eq i8 %call9.i, 0
  br i1 %tobool10.not.i, label %poolAppend.exit.thread, label %for.cond.i

poolAppend.exit.thread:                           ; preds = %land.lhs.true.i178, %if.end8.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i)
  br label %endEntityValue

poolAppend.exit:                                  ; preds = %for.cond.i
  %98 = load ptr, ptr %start.i, align 8
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i)
  %tobool73.not = icmp eq ptr %98, null
  br i1 %tobool73.not, label %endEntityValue, label %sw.epilog

sw.bb76:                                          ; preds = %if.end10
  %99 = load i32, ptr %minBytesPerChar77, align 8
  %idx.ext78 = sext i32 %99 to i64
  %add.ptr79 = getelementptr i8, ptr %entityTextPtr.addr.0, i64 %idx.ext78
  store ptr %add.ptr79, ptr %next, align 8
  br label %sw.bb80

sw.bb80:                                          ; preds = %sw.bb76, %if.end10
  %100 = load ptr, ptr %end105, align 8
  %101 = load ptr, ptr %ptr106, align 8
  %cmp82 = icmp eq ptr %100, %101
  br i1 %cmp82, label %land.lhs.true, label %if.end87

land.lhs.true:                                    ; preds = %sw.bb80
  %call84 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %entityValuePool), !range !13
  %tobool85.not = icmp eq i8 %call84, 0
  br i1 %tobool85.not, label %endEntityValue, label %land.lhs.true.if.end87_crit_edge

land.lhs.true.if.end87_crit_edge:                 ; preds = %land.lhs.true
  %.pre234 = load ptr, ptr %ptr106, align 8
  br label %if.end87

if.end87:                                         ; preds = %land.lhs.true.if.end87_crit_edge, %sw.bb80
  %102 = phi ptr [ %.pre234, %land.lhs.true.if.end87_crit_edge ], [ %101, %sw.bb80 ]
  %incdec.ptr = getelementptr i8, ptr %102, i64 1
  store ptr %incdec.ptr, ptr %ptr106, align 8
  store i8 10, ptr %102, align 1
  br label %sw.epilog

sw.bb89:                                          ; preds = %if.end10
  %103 = load ptr, ptr %charRefNumber, align 8
  %call90 = call i32 %103(ptr noundef nonnull %enc, ptr noundef %entityTextPtr.addr.0) #24
  %cmp91 = icmp slt i32 %call90, 0
  br i1 %cmp91, label %if.then93, label %if.end100

if.then93:                                        ; preds = %sw.bb89
  %104 = load ptr, ptr %m_encoding, align 8
  %cmp95 = icmp eq ptr %104, %enc
  br i1 %cmp95, label %if.then97, label %endEntityValue

if.then97:                                        ; preds = %if.then93
  %m_eventPtr98 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 47
  store ptr %entityTextPtr.addr.0, ptr %m_eventPtr98, align 8
  br label %endEntityValue

if.end100:                                        ; preds = %sw.bb89
  %call101 = call i32 @PyExpat_XmlUtf8Encode(i32 noundef %call90, ptr noundef nonnull %buf) #24
  %cmp103209 = icmp sgt i32 %call101, 0
  br i1 %cmp103209, label %for.body.preheader, label %sw.epilog

for.body.preheader:                               ; preds = %if.end100
  %wide.trip.count = zext nneg i32 %call101 to i64
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end113
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %if.end113 ]
  %105 = load ptr, ptr %end105, align 8
  %106 = load ptr, ptr %ptr106, align 8
  %cmp107 = icmp eq ptr %105, %106
  br i1 %cmp107, label %land.lhs.true109, label %if.end113

land.lhs.true109:                                 ; preds = %for.body
  %call110 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %entityValuePool), !range !13
  %tobool111.not = icmp eq i8 %call110, 0
  br i1 %tobool111.not, label %endEntityValue, label %land.lhs.true109.if.end113_crit_edge

land.lhs.true109.if.end113_crit_edge:             ; preds = %land.lhs.true109
  %.pre = load ptr, ptr %ptr106, align 8
  br label %if.end113

if.end113:                                        ; preds = %land.lhs.true109.if.end113_crit_edge, %for.body
  %107 = phi ptr [ %.pre, %land.lhs.true109.if.end113_crit_edge ], [ %106, %for.body ]
  %arrayidx114 = getelementptr [4 x i8], ptr %buf, i64 0, i64 %indvars.iv
  %108 = load i8, ptr %arrayidx114, align 1
  %incdec.ptr116 = getelementptr i8, ptr %107, i64 1
  store ptr %incdec.ptr116, ptr %ptr106, align 8
  store i8 %108, ptr %107, align 1
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %sw.epilog, label %for.body, !llvm.loop !49

sw.bb117:                                         ; preds = %if.end10
  %109 = load ptr, ptr %m_encoding, align 8
  %cmp119 = icmp eq ptr %109, %enc
  br i1 %cmp119, label %if.then121, label %endEntityValue

if.then121:                                       ; preds = %sw.bb117
  %m_eventPtr122 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 47
  store ptr %entityTextPtr.addr.0, ptr %m_eventPtr122, align 8
  br label %endEntityValue

sw.bb124:                                         ; preds = %if.end10
  %110 = load ptr, ptr %m_encoding, align 8
  %cmp126 = icmp eq ptr %110, %enc
  br i1 %cmp126, label %if.then128, label %endEntityValue

if.then128:                                       ; preds = %sw.bb124
  %111 = load ptr, ptr %next, align 8
  %m_eventPtr129 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 47
  store ptr %111, ptr %m_eventPtr129, align 8
  br label %endEntityValue

sw.default:                                       ; preds = %if.end10
  %112 = load ptr, ptr %m_encoding, align 8
  %cmp132 = icmp eq ptr %112, %enc
  br i1 %cmp132, label %if.then134, label %endEntityValue

if.then134:                                       ; preds = %sw.default
  %m_eventPtr135 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 47
  store ptr %entityTextPtr.addr.0, ptr %m_eventPtr135, align 8
  br label %endEntityValue

sw.epilog:                                        ; preds = %if.end113, %if.end100, %poolAppend.exit, %entityTrackingOnClose.exit, %if.then50, %if.else, %entityTrackingOnClose.exit174, %if.end87
  %113 = load ptr, ptr %next, align 8
  br label %for.cond

endEntityValue:                                   ; preds = %land.lhs.true.i, %poolAppend.exit.i, %land.lhs.true, %poolAppend.exit, %if.end10, %poolStoreString.exit, %entityTrackingOnClose.exit174, %land.lhs.true109, %poolAppend.exit.thread.i, %poolAppend.exit.thread, %accountingGetCurrentAmplification.exit.i.i, %getRootParserOf.exit.i.i, %sw.default, %if.then134, %sw.bb124, %if.then128, %sw.bb117, %if.then121, %if.then93, %if.then97, %if.then28, %if.then32, %if.end68, %if.then44, %lookup.exit.thread
  %result.2 = phi i32 [ 21, %if.then44 ], [ 0, %lookup.exit.thread ], [ 10, %if.end68 ], [ 12, %if.then32 ], [ 12, %if.then28 ], [ 14, %if.then97 ], [ 14, %if.then93 ], [ 4, %if.then121 ], [ 4, %sw.bb117 ], [ 4, %if.then128 ], [ 4, %sw.bb124 ], [ 23, %if.then134 ], [ 23, %sw.default ], [ 43, %getRootParserOf.exit.i.i ], [ 43, %accountingGetCurrentAmplification.exit.i.i ], [ 1, %poolAppend.exit.thread ], [ 1, %poolAppend.exit.thread.i ], [ 1, %land.lhs.true109 ], [ 1, %land.lhs.true.i ], [ 1, %poolAppend.exit.i ], [ 1, %land.lhs.true ], [ 1, %poolAppend.exit ], [ 0, %if.end10 ], [ 1, %poolStoreString.exit ], [ %call62, %entityTrackingOnClose.exit174 ]
  store i32 %1, ptr %inEntityValue, align 8
  br label %return

return:                                           ; preds = %if.then, %endEntityValue
  %retval.0 = phi i32 [ %result.2, %endEntityValue ], [ 1, %if.then ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @doIgnoreSection(ptr noundef %parser, ptr noundef %enc, ptr nocapture noundef %startPtr, ptr noundef %end, ptr nocapture noundef writeonly %nextPtr, i8 noundef zeroext %haveMore) unnamed_addr #0 {
entry:
  %s.addr.i = alloca ptr, align 8
  %dataPtr.i = alloca ptr, align 8
  %next = alloca ptr, align 8
  %0 = load ptr, ptr %startPtr, align 8
  store ptr %0, ptr %next, align 8
  %m_encoding = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 34
  %1 = load ptr, ptr %m_encoding, align 8
  %cmp = icmp eq ptr %1, %enc
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %m_eventPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 47
  store ptr %0, ptr %m_eventPtr, align 8
  %m_eventEndPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 48
  br label %if.end

if.else:                                          ; preds = %entry
  %m_openInternalEntities = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 50
  %2 = load ptr, ptr %m_openInternalEntities, align 8
  %internalEventEndPtr = getelementptr inbounds %struct.open_internal_entity, ptr %2, i64 0, i32 1
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %eventPP.0 = phi ptr [ %m_eventPtr, %if.then ], [ %2, %if.else ]
  %eventEndPP.0 = phi ptr [ %m_eventEndPtr, %if.then ], [ %internalEventEndPtr, %if.else ]
  store ptr %0, ptr %eventPP.0, align 8
  store ptr null, ptr %startPtr, align 8
  %arrayidx = getelementptr [4 x ptr], ptr %enc, i64 0, i64 3
  %3 = load ptr, ptr %arrayidx, align 8
  %call = call i32 %3(ptr noundef %enc, ptr noundef %0, ptr noundef %end, ptr noundef nonnull %next) #24
  %4 = load ptr, ptr %next, align 8
  %call2 = call fastcc zeroext i8 @accountingDiffTolerated(ptr noundef nonnull %parser, i32 noundef %call, ptr noundef %0, ptr noundef %4, i32 noundef 4196, i32 noundef 0), !range !13
  %tobool.not = icmp eq i8 %call2, 0
  br i1 %tobool.not, label %while.cond.i.i.i, label %if.end4

while.cond.i.i.i:                                 ; preds = %if.end, %while.cond.i.i.i
  %rootParser.0.i.i.i = phi ptr [ %5, %while.cond.i.i.i ], [ %parser, %if.end ]
  %m_parentParser.i.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i.i, i64 0, i32 84
  %5 = load ptr, ptr %m_parentParser.i.i.i, align 8
  %tobool.not.i.i.i = icmp eq ptr %5, null
  br i1 %tobool.not.i.i.i, label %getRootParserOf.exit.i.i, label %while.cond.i.i.i, !llvm.loop !31

getRootParserOf.exit.i.i:                         ; preds = %while.cond.i.i.i
  %debugLevel.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i.i, i64 0, i32 90, i32 2
  %6 = load i32, ptr %debugLevel.i.i, align 8
  %cmp.i.i = icmp slt i32 %6, 1
  br i1 %cmp.i.i, label %return, label %if.end.i.i

if.end.i.i:                                       ; preds = %getRootParserOf.exit.i.i
  %m_accounting.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i.i, i64 0, i32 90
  %7 = load i64, ptr %m_accounting.i.i, align 8
  %tobool.not.i5.i.i = icmp eq i64 %7, 0
  %countBytesIndirect.phi.trans.insert.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i.i, i64 0, i32 90, i32 1
  %.pre.i.i = load i64, ptr %countBytesIndirect.phi.trans.insert.i.i, align 8
  br i1 %tobool.not.i5.i.i, label %accountingGetCurrentAmplification.exit.i.i, label %cond.true.i.i.i

cond.true.i.i.i:                                  ; preds = %if.end.i.i
  %add.i.i.i = add i64 %.pre.i.i, %7
  %conv.i.i.i = uitofp i64 %add.i.i.i to float
  %conv6.i.i.i = uitofp i64 %7 to float
  %div.i.i.i = fdiv float %conv.i.i.i, %conv6.i.i.i
  %8 = fpext float %div.i.i.i to double
  br label %accountingGetCurrentAmplification.exit.i.i

accountingGetCurrentAmplification.exit.i.i:       ; preds = %cond.true.i.i.i, %if.end.i.i
  %cond.i.i.i = phi double [ %8, %cond.true.i.i.i ], [ 1.000000e+00, %if.end.i.i ]
  %9 = load ptr, ptr @stderr, align 8
  %call4.i.i = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %9, ptr noundef nonnull @.str.311, ptr noundef nonnull %rootParser.0.i.i.i, i64 noundef %7, i64 noundef %.pre.i.i, double noundef %cond.i.i.i, ptr noundef nonnull @.str.317) #27
  br label %return

if.end4:                                          ; preds = %if.end
  %10 = load ptr, ptr %next, align 8
  store ptr %10, ptr %eventEndPP.0, align 8
  switch i32 %call, label %sw.default [
    i32 42, label %sw.bb
    i32 0, label %sw.bb11
    i32 -2, label %sw.bb12
    i32 -1, label %sw.bb16
    i32 -4, label %sw.bb16
  ]

sw.bb:                                            ; preds = %if.end4
  %m_defaultHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 18
  %11 = load ptr, ptr %m_defaultHandler, align 8
  %tobool5.not = icmp eq ptr %11, null
  br i1 %tobool5.not, label %if.end7, label %if.then6

if.then6:                                         ; preds = %sw.bb
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %s.addr.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %dataPtr.i)
  store ptr %0, ptr %s.addr.i, align 8
  %isUtf8.i = getelementptr inbounds %struct.encoding, ptr %enc, i64 0, i32 13
  %12 = load i8, ptr %isUtf8.i, align 4
  %tobool.not.i = icmp eq i8 %12, 0
  br i1 %tobool.not.i, label %if.then.i, label %if.else9.i

if.then.i:                                        ; preds = %if.then6
  %13 = load ptr, ptr %m_encoding, align 8
  %cmp.i = icmp eq ptr %13, %enc
  br i1 %cmp.i, label %if.then1.i, label %if.else.i

if.then1.i:                                       ; preds = %if.then.i
  %m_eventPtr.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 47
  %m_eventEndPtr.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 48
  br label %if.end.i

if.else.i:                                        ; preds = %if.then.i
  %m_openInternalEntities.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 50
  %14 = load ptr, ptr %m_openInternalEntities.i, align 8
  %internalEventEndPtr.i = getelementptr inbounds %struct.open_internal_entity, ptr %14, i64 0, i32 1
  br label %if.end.i

if.end.i:                                         ; preds = %if.else.i, %if.then1.i
  %eventPP.0.i = phi ptr [ %m_eventPtr.i, %if.then1.i ], [ %14, %if.else.i ]
  %eventEndPP.0.i = phi ptr [ %m_eventEndPtr.i, %if.then1.i ], [ %internalEventEndPtr.i, %if.else.i ]
  %m_dataBuf.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 9
  %utf8Convert.i = getelementptr inbounds %struct.encoding, ptr %enc, i64 0, i32 10
  %m_dataBufEnd.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 10
  %m_handlerArg.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 1
  br label %do.body.i

do.body.i:                                        ; preds = %do.body.i, %if.end.i
  %15 = load ptr, ptr %m_dataBuf.i, align 8
  store ptr %15, ptr %dataPtr.i, align 8
  %16 = load ptr, ptr %utf8Convert.i, align 8
  %17 = load ptr, ptr %m_dataBufEnd.i, align 8
  %call.i = call i32 %16(ptr noundef nonnull %enc, ptr noundef nonnull %s.addr.i, ptr noundef %10, ptr noundef nonnull %dataPtr.i, ptr noundef %17) #24
  %18 = load ptr, ptr %s.addr.i, align 8
  store ptr %18, ptr %eventEndPP.0.i, align 8
  %19 = load ptr, ptr %m_defaultHandler, align 8
  %20 = load ptr, ptr %m_handlerArg.i, align 8
  %21 = load ptr, ptr %m_dataBuf.i, align 8
  %22 = load ptr, ptr %dataPtr.i, align 8
  %sub.ptr.lhs.cast.i = ptrtoint ptr %22 to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %21 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %conv.i = trunc i64 %sub.ptr.sub.i to i32
  call void %19(ptr noundef %20, ptr noundef %21, i32 noundef %conv.i) #24
  %23 = load ptr, ptr %s.addr.i, align 8
  store ptr %23, ptr %eventPP.0.i, align 8
  %24 = icmp ugt i32 %call.i, 1
  br i1 %24, label %do.body.i, label %reportDefault.exit, !llvm.loop !28

if.else9.i:                                       ; preds = %if.then6
  %m_handlerArg11.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 1
  %25 = load ptr, ptr %m_handlerArg11.i, align 8
  %sub.ptr.lhs.cast12.i = ptrtoint ptr %10 to i64
  %sub.ptr.rhs.cast13.i = ptrtoint ptr %0 to i64
  %sub.ptr.sub14.i = sub i64 %sub.ptr.lhs.cast12.i, %sub.ptr.rhs.cast13.i
  %conv15.i = trunc i64 %sub.ptr.sub14.i to i32
  call void %11(ptr noundef %25, ptr noundef %0, i32 noundef %conv15.i) #24
  br label %reportDefault.exit

reportDefault.exit:                               ; preds = %do.body.i, %if.else9.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %s.addr.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %dataPtr.i)
  %.pre = load ptr, ptr %next, align 8
  br label %if.end7

if.end7:                                          ; preds = %reportDefault.exit, %sw.bb
  %26 = phi ptr [ %.pre, %reportDefault.exit ], [ %10, %sw.bb ]
  store ptr %26, ptr %startPtr, align 8
  store ptr %26, ptr %nextPtr, align 8
  %m_parsingStatus = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 85
  %27 = load i32, ptr %m_parsingStatus, align 8
  %cmp8 = icmp eq i32 %27, 2
  %. = select i1 %cmp8, i32 35, i32 0
  br label %return

sw.bb11:                                          ; preds = %if.end4
  store ptr %10, ptr %eventPP.0, align 8
  br label %return

sw.bb12:                                          ; preds = %if.end4
  %tobool13.not = icmp eq i8 %haveMore, 0
  br i1 %tobool13.not, label %return, label %if.then14

if.then14:                                        ; preds = %sw.bb12
  store ptr %0, ptr %nextPtr, align 8
  br label %return

sw.bb16:                                          ; preds = %if.end4, %if.end4
  %tobool17.not = icmp eq i8 %haveMore, 0
  br i1 %tobool17.not, label %return, label %if.then18

if.then18:                                        ; preds = %sw.bb16
  store ptr %0, ptr %nextPtr, align 8
  br label %return

sw.default:                                       ; preds = %if.end4
  store ptr %10, ptr %eventPP.0, align 8
  br label %return

return:                                           ; preds = %accountingGetCurrentAmplification.exit.i.i, %getRootParserOf.exit.i.i, %sw.bb16, %sw.bb12, %if.end7, %sw.default, %if.then18, %if.then14, %sw.bb11
  %retval.0 = phi i32 [ 23, %sw.default ], [ 0, %if.then18 ], [ 0, %if.then14 ], [ 4, %sw.bb11 ], [ %., %if.end7 ], [ 6, %sw.bb12 ], [ 2, %sw.bb16 ], [ 43, %getRootParserOf.exit.i.i ], [ 43, %accountingGetCurrentAmplification.exit.i.i ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @ignoreSectionProcessor(ptr noundef %parser, ptr noundef %start, ptr noundef %end, ptr noundef %endPtr) #0 {
entry:
  %next.i = alloca ptr, align 8
  %start.addr = alloca ptr, align 8
  store ptr %start, ptr %start.addr, align 8
  %m_encoding = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 34
  %0 = load ptr, ptr %m_encoding, align 8
  %finalBuffer = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 85, i32 1
  %1 = load i8, ptr %finalBuffer, align 4
  %tobool.not = icmp eq i8 %1, 0
  %conv = zext i1 %tobool.not to i8
  %call = call fastcc i32 @doIgnoreSection(ptr noundef %parser, ptr noundef %0, ptr noundef nonnull %start.addr, ptr noundef %end, ptr noundef %endPtr, i8 noundef zeroext %conv), !range !32
  %cmp.not = icmp eq i32 %call, 0
  br i1 %cmp.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %start.addr, align 8
  %tobool2.not = icmp eq ptr %2, null
  br i1 %tobool2.not, label %return, label %if.then3

if.then3:                                         ; preds = %if.end
  %m_processor = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 45
  store ptr @prologProcessor, ptr %m_processor, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %next.i)
  store ptr %2, ptr %next.i, align 8
  %3 = load ptr, ptr %m_encoding, align 8
  %4 = load ptr, ptr %3, align 8
  %call.i = call i32 %4(ptr noundef nonnull %3, ptr noundef nonnull %2, ptr noundef %end, ptr noundef nonnull %next.i) #24
  %5 = load ptr, ptr %m_encoding, align 8
  %6 = load ptr, ptr %next.i, align 8
  %7 = load i8, ptr %finalBuffer, align 4
  %tobool.not.i = icmp eq i8 %7, 0
  %conv.i = zext i1 %tobool.not.i to i8
  %call3.i = call fastcc i32 @doProlog(ptr noundef nonnull %parser, ptr noundef %5, ptr noundef nonnull %2, ptr noundef %end, i32 noundef %call.i, ptr noundef %6, ptr noundef %endPtr, i8 noundef zeroext %conv.i, i8 noundef zeroext 1, i32 noundef 0)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %next.i)
  br label %return

return:                                           ; preds = %if.end, %entry, %if.then3
  %retval.0 = phi i32 [ %call3.i, %if.then3 ], [ %call, %entry ], [ 0, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @nextScaffoldPart(ptr nocapture noundef readonly %parser) unnamed_addr #0 {
entry:
  %m_dtd = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 65
  %0 = load ptr, ptr %m_dtd, align 8
  %scaffIndex = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 18
  %1 = load ptr, ptr %scaffIndex, align 8
  %tobool.not = icmp eq ptr %1, null
  br i1 %tobool.not, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %m_mem = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 3
  %2 = load ptr, ptr %m_mem, align 8
  %m_groupSize = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 82
  %3 = load i32, ptr %m_groupSize, align 8
  %conv = zext i32 %3 to i64
  %mul = shl nuw nsw i64 %conv, 2
  %call = tail call ptr %2(i64 noundef %mul) #24
  store ptr %call, ptr %scaffIndex, align 8
  %tobool3.not = icmp eq ptr %call, null
  br i1 %tobool3.not, label %return, label %if.end

if.end:                                           ; preds = %if.then
  store i32 0, ptr %call, align 4
  br label %if.end6

if.end6:                                          ; preds = %if.end, %entry
  %scaffCount = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 16
  %4 = load i32, ptr %scaffCount, align 8
  %scaffSize = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 15
  %5 = load i32, ptr %scaffSize, align 4
  %cmp.not = icmp ult i32 %4, %5
  %scaffold41.phi.trans.insert = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 13
  %.pre41 = load ptr, ptr %scaffold41.phi.trans.insert, align 8
  br i1 %cmp.not, label %if.end39, label %if.then8

if.then8:                                         ; preds = %if.end6
  %tobool9.not = icmp eq ptr %.pre41, null
  br i1 %tobool9.not, label %if.else, label %if.then10

if.then10:                                        ; preds = %if.then8
  %cmp12 = icmp slt i32 %5, 0
  br i1 %cmp12, label %return, label %if.end15

if.end15:                                         ; preds = %if.then10
  %realloc_fcn = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 3, i32 1
  %6 = load ptr, ptr %realloc_fcn, align 8
  %mul19 = shl nuw i32 %5, 1
  %conv20 = zext i32 %mul19 to i64
  %mul21 = shl nuw nsw i64 %conv20, 5
  %call22 = tail call ptr %6(ptr noundef nonnull %.pre41, i64 noundef %mul21) #24
  %cmp23 = icmp eq ptr %call22, null
  br i1 %cmp23, label %return, label %if.end26

if.end26:                                         ; preds = %if.end15
  %7 = load i32, ptr %scaffSize, align 4
  %mul28 = shl i32 %7, 1
  br label %if.end37

if.else:                                          ; preds = %if.then8
  %m_mem29 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 3
  %8 = load ptr, ptr %m_mem29, align 8
  %call31 = tail call ptr %8(i64 noundef 1024) #24
  %cmp32 = icmp eq ptr %call31, null
  br i1 %cmp32, label %return, label %if.end37

if.end37:                                         ; preds = %if.else, %if.end26
  %storemerge = phi i32 [ %mul28, %if.end26 ], [ 32, %if.else ]
  %temp.0 = phi ptr [ %call22, %if.end26 ], [ %call31, %if.else ]
  store i32 %storemerge, ptr %scaffSize, align 4
  store ptr %temp.0, ptr %scaffold41.phi.trans.insert, align 8
  %.pre = load i32, ptr %scaffCount, align 8
  br label %if.end39

if.end39:                                         ; preds = %if.end6, %if.end37
  %9 = phi ptr [ %temp.0, %if.end37 ], [ %.pre41, %if.end6 ]
  %10 = phi i32 [ %.pre, %if.end37 ], [ %4, %if.end6 ]
  %inc = add i32 %10, 1
  store i32 %inc, ptr %scaffCount, align 8
  %idxprom = sext i32 %10 to i64
  %scaffLevel = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 17
  %11 = load i32, ptr %scaffLevel, align 4
  %tobool43.not = icmp eq i32 %11, 0
  br i1 %tobool43.not, label %if.end65, label %if.then44

if.then44:                                        ; preds = %if.end39
  %12 = load ptr, ptr %scaffIndex, align 8
  %sub = add i32 %11, -1
  %idxprom48 = sext i32 %sub to i64
  %arrayidx49 = getelementptr i32, ptr %12, i64 %idxprom48
  %13 = load i32, ptr %arrayidx49, align 4
  %idxprom50 = sext i32 %13 to i64
  %lastchild = getelementptr %struct.CONTENT_SCAFFOLD, ptr %9, i64 %idxprom50, i32 4
  %14 = load i32, ptr %lastchild, align 4
  %tobool52.not = icmp eq i32 %14, 0
  br i1 %tobool52.not, label %if.end58, label %if.then53

if.then53:                                        ; preds = %if.then44
  %idxprom56 = sext i32 %14 to i64
  %nextsib = getelementptr %struct.CONTENT_SCAFFOLD, ptr %9, i64 %idxprom56, i32 6
  store i32 %10, ptr %nextsib, align 4
  br label %if.end58

if.end58:                                         ; preds = %if.then53, %if.then44
  %childcnt = getelementptr %struct.CONTENT_SCAFFOLD, ptr %9, i64 %idxprom50, i32 5
  %15 = load i32, ptr %childcnt, align 8
  %tobool59.not = icmp eq i32 %15, 0
  br i1 %tobool59.not, label %if.then60, label %if.end61

if.then60:                                        ; preds = %if.end58
  %firstchild = getelementptr %struct.CONTENT_SCAFFOLD, ptr %9, i64 %idxprom50, i32 3
  store i32 %10, ptr %firstchild, align 8
  br label %if.end61

if.end61:                                         ; preds = %if.then60, %if.end58
  store i32 %10, ptr %lastchild, align 4
  %inc64 = add i32 %15, 1
  store i32 %inc64, ptr %childcnt, align 8
  br label %if.end65

if.end65:                                         ; preds = %if.end61, %if.end39
  %firstchild69 = getelementptr %struct.CONTENT_SCAFFOLD, ptr %9, i64 %idxprom, i32 3
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %firstchild69, i8 0, i64 16, i1 false)
  br label %return

return:                                           ; preds = %if.else, %if.end15, %if.then10, %if.then, %if.end65
  %retval.0 = phi i32 [ %10, %if.end65 ], [ -1, %if.then ], [ -1, %if.then10 ], [ -1, %if.end15 ], [ -1, %if.else ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @processInternalEntity(ptr noundef %parser, ptr noundef %entity, i8 noundef zeroext %betweenDecl) unnamed_addr #0 {
entry:
  %next = alloca ptr, align 8
  %m_freeInternalEntities = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 51
  %0 = load ptr, ptr %m_freeInternalEntities, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %next2 = getelementptr inbounds %struct.open_internal_entity, ptr %0, i64 0, i32 2
  %1 = load ptr, ptr %next2, align 8
  store ptr %1, ptr %m_freeInternalEntities, align 8
  br label %if.end6

if.else:                                          ; preds = %entry
  %m_mem = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 3
  %2 = load ptr, ptr %m_mem, align 8
  %call = tail call ptr %2(i64 noundef 40) #24
  %tobool4.not = icmp eq ptr %call, null
  br i1 %tobool4.not, label %return, label %if.end6

if.end6:                                          ; preds = %if.else, %if.then
  %openEntity.0 = phi ptr [ %0, %if.then ], [ %call, %if.else ]
  %open = getelementptr inbounds %struct.ENTITY, ptr %entity, i64 0, i32 8
  store i8 1, ptr %open, align 8
  br label %while.cond.i.i

while.cond.i.i:                                   ; preds = %while.cond.i.i, %if.end6
  %rootParser.0.i.i = phi ptr [ %parser, %if.end6 ], [ %3, %while.cond.i.i ]
  %m_parentParser.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i, i64 0, i32 84
  %3 = load ptr, ptr %m_parentParser.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %3, null
  br i1 %tobool.not.i.i, label %getRootParserOf.exit.i, label %while.cond.i.i, !llvm.loop !31

getRootParserOf.exit.i:                           ; preds = %while.cond.i.i
  %m_entity_stats.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i, i64 0, i32 91
  %4 = load i32, ptr %m_entity_stats.i, align 8
  %inc.i = add i32 %4, 1
  store i32 %inc.i, ptr %m_entity_stats.i, align 8
  %currentDepth.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i, i64 0, i32 91, i32 1
  %5 = load i32, ptr %currentDepth.i, align 4
  %inc2.i = add i32 %5, 1
  store i32 %inc2.i, ptr %currentDepth.i, align 4
  %maximumDepthSeen.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i, i64 0, i32 91, i32 2
  %6 = load i32, ptr %maximumDepthSeen.i, align 8
  %cmp.i = icmp ugt i32 %inc2.i, %6
  br i1 %cmp.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %getRootParserOf.exit.i
  %inc8.i = add nuw i32 %6, 1
  store i32 %inc8.i, ptr %maximumDepthSeen.i, align 8
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %getRootParserOf.exit.i
  %7 = phi i32 [ %inc8.i, %if.then.i ], [ %6, %getRootParserOf.exit.i ]
  %debugLevel.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i, i64 0, i32 91, i32 3
  %8 = load i32, ptr %debugLevel.i.i, align 4
  %cmp.i.i = icmp slt i32 %8, 1
  br i1 %cmp.i.i, label %entityTrackingOnOpen.exit, label %if.end.i.i

if.end.i.i:                                       ; preds = %if.end.i
  %9 = load ptr, ptr %entity, align 8
  %10 = load ptr, ptr @stderr, align 8
  %sub.i.i = shl i32 %inc2.i, 1
  %mul.i.i = add i32 %sub.i.i, -2
  %is_param.i.i = getelementptr inbounds %struct.ENTITY, ptr %entity, i64 0, i32 9
  %11 = load i8, ptr %is_param.i.i, align 1
  %tobool.not.i6.i = icmp eq i8 %11, 0
  %cond.i.i = select i1 %tobool.not.i6.i, ptr @.str.89, ptr @.str.88
  %textLen.i.i = getelementptr inbounds %struct.ENTITY, ptr %entity, i64 0, i32 2
  %12 = load i32, ptr %textLen.i.i, align 8
  %call.i.i = tail call i32 (ptr, ptr, ...) @fprintf(ptr noundef %10, ptr noundef nonnull @.str.320, ptr noundef nonnull %rootParser.0.i.i, i32 noundef %inc.i, i32 noundef %inc2.i, i32 noundef %7, i32 noundef %mul.i.i, ptr noundef nonnull @.str.310, ptr noundef nonnull %cond.i.i, ptr noundef %9, ptr noundef nonnull @.str.319, i32 noundef %12, i32 noundef 5732) #27
  br label %entityTrackingOnOpen.exit

entityTrackingOnOpen.exit:                        ; preds = %if.end.i, %if.end.i.i
  %processed = getelementptr inbounds %struct.ENTITY, ptr %entity, i64 0, i32 3
  store i32 0, ptr %processed, align 4
  %m_openInternalEntities = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 50
  %13 = load ptr, ptr %m_openInternalEntities, align 8
  %next7 = getelementptr inbounds %struct.open_internal_entity, ptr %openEntity.0, i64 0, i32 2
  store ptr %13, ptr %next7, align 8
  store ptr %openEntity.0, ptr %m_openInternalEntities, align 8
  %entity9 = getelementptr inbounds %struct.open_internal_entity, ptr %openEntity.0, i64 0, i32 3
  store ptr %entity, ptr %entity9, align 8
  %m_tagLevel = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 53
  %14 = load i32, ptr %m_tagLevel, align 4
  %startTagLevel = getelementptr inbounds %struct.open_internal_entity, ptr %openEntity.0, i64 0, i32 4
  store i32 %14, ptr %startTagLevel, align 8
  %betweenDecl10 = getelementptr inbounds %struct.open_internal_entity, ptr %openEntity.0, i64 0, i32 5
  store i8 %betweenDecl, ptr %betweenDecl10, align 4
  %textPtr = getelementptr inbounds %struct.ENTITY, ptr %entity, i64 0, i32 1
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %openEntity.0, i8 0, i64 16, i1 false)
  %15 = load ptr, ptr %textPtr, align 8
  %textLen = getelementptr inbounds %struct.ENTITY, ptr %entity, i64 0, i32 2
  %16 = load i32, ptr %textLen, align 8
  %idx.ext = sext i32 %16 to i64
  %add.ptr = getelementptr i8, ptr %15, i64 %idx.ext
  store ptr %15, ptr %next, align 8
  %is_param = getelementptr inbounds %struct.ENTITY, ptr %entity, i64 0, i32 9
  %17 = load i8, ptr %is_param, align 1
  %tobool12.not = icmp eq i8 %17, 0
  br i1 %tobool12.not, label %if.else18, label %if.then13

if.then13:                                        ; preds = %entityTrackingOnOpen.exit
  %m_internalEncoding = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 36
  %18 = load ptr, ptr %m_internalEncoding, align 8
  %19 = load ptr, ptr %18, align 8
  %call15 = call i32 %19(ptr noundef nonnull %18, ptr noundef %15, ptr noundef %add.ptr, ptr noundef nonnull %next) #24
  %20 = load ptr, ptr %m_internalEncoding, align 8
  %21 = load ptr, ptr %next, align 8
  %call17 = call fastcc i32 @doProlog(ptr noundef nonnull %parser, ptr noundef %20, ptr noundef %15, ptr noundef %add.ptr, i32 noundef %call15, ptr noundef %21, ptr noundef nonnull %next, i8 noundef zeroext 0, i8 noundef zeroext 0, i32 noundef 1)
  br label %if.end22

if.else18:                                        ; preds = %entityTrackingOnOpen.exit
  %22 = load i32, ptr %m_tagLevel, align 4
  %m_internalEncoding20 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 36
  %23 = load ptr, ptr %m_internalEncoding20, align 8
  %call21 = call fastcc i32 @doContent(ptr noundef nonnull %parser, i32 noundef %22, ptr noundef %23, ptr noundef %15, ptr noundef %add.ptr, ptr noundef nonnull %next, i8 noundef zeroext 0, i32 noundef 1)
  br label %if.end22

if.end22:                                         ; preds = %if.else18, %if.then13
  %result.0 = phi i32 [ %call17, %if.then13 ], [ %call21, %if.else18 ]
  %cmp = icmp eq i32 %result.0, 0
  br i1 %cmp, label %if.then23, label %return

if.then23:                                        ; preds = %if.end22
  %24 = load ptr, ptr %next, align 8
  %cmp24.not = icmp eq ptr %add.ptr, %24
  br i1 %cmp24.not, label %while.cond.i.i51.preheader, label %land.lhs.true

while.cond.i.i51.preheader:                       ; preds = %land.lhs.true, %if.then23
  br label %while.cond.i.i51

land.lhs.true:                                    ; preds = %if.then23
  %m_parsingStatus = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 85
  %25 = load i32, ptr %m_parsingStatus, align 8
  %cmp25 = icmp eq i32 %25, 3
  br i1 %cmp25, label %if.then26, label %while.cond.i.i51.preheader

if.then26:                                        ; preds = %land.lhs.true
  %sub.ptr.lhs.cast = ptrtoint ptr %24 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %15 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv = trunc i64 %sub.ptr.sub to i32
  store i32 %conv, ptr %processed, align 4
  %m_processor = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 45
  store ptr @internalEntityProcessor, ptr %m_processor, align 8
  br label %return

while.cond.i.i51:                                 ; preds = %while.cond.i.i51.preheader, %while.cond.i.i51
  %rootParser.0.i.i52 = phi ptr [ %26, %while.cond.i.i51 ], [ %parser, %while.cond.i.i51.preheader ]
  %m_parentParser.i.i53 = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i52, i64 0, i32 84
  %26 = load ptr, ptr %m_parentParser.i.i53, align 8
  %tobool.not.i.i54 = icmp eq ptr %26, null
  br i1 %tobool.not.i.i54, label %getRootParserOf.exit.i55, label %while.cond.i.i51, !llvm.loop !31

getRootParserOf.exit.i55:                         ; preds = %while.cond.i.i51
  %debugLevel.i.i56 = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i52, i64 0, i32 91, i32 3
  %27 = load i32, ptr %debugLevel.i.i56, align 4
  %cmp.i.i57 = icmp slt i32 %27, 1
  br i1 %cmp.i.i57, label %entityTrackingOnClose.exit, label %if.end.i.i58

if.end.i.i58:                                     ; preds = %getRootParserOf.exit.i55
  %m_entity_stats.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i52, i64 0, i32 91
  %28 = load ptr, ptr %entity, align 8
  %29 = load ptr, ptr @stderr, align 8
  %30 = load i32, ptr %m_entity_stats.i.i, align 8
  %currentDepth.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i52, i64 0, i32 91, i32 1
  %31 = load i32, ptr %currentDepth.i.i, align 4
  %maximumDepthSeen.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i52, i64 0, i32 91, i32 2
  %32 = load i32, ptr %maximumDepthSeen.i.i, align 8
  %sub.i.i59 = shl i32 %31, 1
  %mul.i.i60 = add i32 %sub.i.i59, -2
  %33 = load i8, ptr %is_param, align 1
  %tobool.not.i2.i = icmp eq i8 %33, 0
  %cond.i.i62 = select i1 %tobool.not.i2.i, ptr @.str.89, ptr @.str.88
  %34 = load i32, ptr %textLen, align 8
  %call.i.i64 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %29, ptr noundef nonnull @.str.320, ptr noundef nonnull %rootParser.0.i.i52, i32 noundef %30, i32 noundef %31, i32 noundef %32, i32 noundef %mul.i.i60, ptr noundef nonnull @.str.310, ptr noundef nonnull %cond.i.i62, ptr noundef %28, ptr noundef nonnull @.str.321, i32 noundef %34, i32 noundef 5766) #27
  br label %entityTrackingOnClose.exit

entityTrackingOnClose.exit:                       ; preds = %getRootParserOf.exit.i55, %if.end.i.i58
  %currentDepth.i65 = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i52, i64 0, i32 91, i32 1
  %35 = load i32, ptr %currentDepth.i65, align 4
  %dec.i = add i32 %35, -1
  store i32 %dec.i, ptr %currentDepth.i65, align 4
  store i8 0, ptr %open, align 8
  %36 = load ptr, ptr %next7, align 8
  store ptr %36, ptr %m_openInternalEntities, align 8
  %37 = load ptr, ptr %m_freeInternalEntities, align 8
  store ptr %37, ptr %next7, align 8
  store ptr %openEntity.0, ptr %m_freeInternalEntities, align 8
  br label %return

return:                                           ; preds = %if.end22, %entityTrackingOnClose.exit, %if.then26, %if.else
  %retval.0 = phi i32 [ 1, %if.else ], [ 0, %if.then26 ], [ 0, %entityTrackingOnClose.exit ], [ %result.0, %if.end22 ]
  ret i32 %retval.0
}

; Function Attrs: nofree nounwind uwtable
define internal fastcc void @entityTrackingOnClose(ptr noundef %originParser, ptr nocapture noundef readonly %entity, i32 noundef %sourceLine) unnamed_addr #12 {
entry:
  br label %while.cond.i

while.cond.i:                                     ; preds = %while.cond.i, %entry
  %rootParser.0.i = phi ptr [ %originParser, %entry ], [ %0, %while.cond.i ]
  %m_parentParser.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i, i64 0, i32 84
  %0 = load ptr, ptr %m_parentParser.i, align 8
  %tobool.not.i = icmp eq ptr %0, null
  br i1 %tobool.not.i, label %getRootParserOf.exit, label %while.cond.i, !llvm.loop !31

getRootParserOf.exit:                             ; preds = %while.cond.i
  %debugLevel.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i, i64 0, i32 91, i32 3
  %1 = load i32, ptr %debugLevel.i, align 4
  %cmp.i = icmp slt i32 %1, 1
  br i1 %cmp.i, label %entityTrackingReportStats.exit, label %if.end.i

if.end.i:                                         ; preds = %getRootParserOf.exit
  %m_entity_stats.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i, i64 0, i32 91
  %2 = load ptr, ptr %entity, align 8
  %3 = load ptr, ptr @stderr, align 8
  %4 = load i32, ptr %m_entity_stats.i, align 8
  %currentDepth.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i, i64 0, i32 91, i32 1
  %5 = load i32, ptr %currentDepth.i, align 4
  %maximumDepthSeen.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i, i64 0, i32 91, i32 2
  %6 = load i32, ptr %maximumDepthSeen.i, align 8
  %sub.i = shl i32 %5, 1
  %mul.i = add i32 %sub.i, -2
  %is_param.i = getelementptr inbounds %struct.ENTITY, ptr %entity, i64 0, i32 9
  %7 = load i8, ptr %is_param.i, align 1
  %tobool.not.i2 = icmp eq i8 %7, 0
  %cond.i = select i1 %tobool.not.i2, ptr @.str.89, ptr @.str.88
  %textLen.i = getelementptr inbounds %struct.ENTITY, ptr %entity, i64 0, i32 2
  %8 = load i32, ptr %textLen.i, align 8
  %call.i = tail call i32 (ptr, ptr, ...) @fprintf(ptr noundef %3, ptr noundef nonnull @.str.320, ptr noundef nonnull %rootParser.0.i, i32 noundef %4, i32 noundef %5, i32 noundef %6, i32 noundef %mul.i, ptr noundef nonnull @.str.310, ptr noundef nonnull %cond.i, ptr noundef %2, ptr noundef nonnull @.str.321, i32 noundef %8, i32 noundef %sourceLine) #27
  br label %entityTrackingReportStats.exit

entityTrackingReportStats.exit:                   ; preds = %getRootParserOf.exit, %if.end.i
  %currentDepth = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i, i64 0, i32 91, i32 1
  %9 = load i32, ptr %currentDepth, align 4
  %dec = add i32 %9, -1
  store i32 %dec, ptr %currentDepth, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @reportProcessingInstruction(ptr noundef %parser, ptr noundef %enc, ptr noundef %start, ptr noundef %end) unnamed_addr #0 {
entry:
  %ptr.addr.i.i30 = alloca ptr, align 8
  %ptr.addr.i.i = alloca ptr, align 8
  %s.addr.i = alloca ptr, align 8
  %dataPtr.i = alloca ptr, align 8
  %m_processingInstructionHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 14
  %0 = load ptr, ptr %m_processingInstructionHandler, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %if.then, label %if.end3

if.then:                                          ; preds = %entry
  %m_defaultHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 18
  %1 = load ptr, ptr %m_defaultHandler, align 8
  %tobool1.not = icmp eq ptr %1, null
  br i1 %tobool1.not, label %return, label %if.then2

if.then2:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %s.addr.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %dataPtr.i)
  store ptr %start, ptr %s.addr.i, align 8
  %isUtf8.i = getelementptr inbounds %struct.encoding, ptr %enc, i64 0, i32 13
  %2 = load i8, ptr %isUtf8.i, align 4
  %tobool.not.i = icmp eq i8 %2, 0
  br i1 %tobool.not.i, label %if.then.i, label %if.else9.i

if.then.i:                                        ; preds = %if.then2
  %m_encoding.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 34
  %3 = load ptr, ptr %m_encoding.i, align 8
  %cmp.i = icmp eq ptr %3, %enc
  br i1 %cmp.i, label %if.then1.i, label %if.else.i

if.then1.i:                                       ; preds = %if.then.i
  %m_eventPtr.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 47
  %m_eventEndPtr.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 48
  br label %if.end.i

if.else.i:                                        ; preds = %if.then.i
  %m_openInternalEntities.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 50
  %4 = load ptr, ptr %m_openInternalEntities.i, align 8
  %internalEventEndPtr.i = getelementptr inbounds %struct.open_internal_entity, ptr %4, i64 0, i32 1
  br label %if.end.i

if.end.i:                                         ; preds = %if.else.i, %if.then1.i
  %eventPP.0.i = phi ptr [ %m_eventPtr.i, %if.then1.i ], [ %4, %if.else.i ]
  %eventEndPP.0.i = phi ptr [ %m_eventEndPtr.i, %if.then1.i ], [ %internalEventEndPtr.i, %if.else.i ]
  %m_dataBuf.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 9
  %utf8Convert.i = getelementptr inbounds %struct.encoding, ptr %enc, i64 0, i32 10
  %m_dataBufEnd.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 10
  %m_handlerArg.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 1
  br label %do.body.i

do.body.i:                                        ; preds = %do.body.i, %if.end.i
  %5 = load ptr, ptr %m_dataBuf.i, align 8
  store ptr %5, ptr %dataPtr.i, align 8
  %6 = load ptr, ptr %utf8Convert.i, align 8
  %7 = load ptr, ptr %m_dataBufEnd.i, align 8
  %call.i = call i32 %6(ptr noundef nonnull %enc, ptr noundef nonnull %s.addr.i, ptr noundef %end, ptr noundef nonnull %dataPtr.i, ptr noundef %7) #24
  %8 = load ptr, ptr %s.addr.i, align 8
  store ptr %8, ptr %eventEndPP.0.i, align 8
  %9 = load ptr, ptr %m_defaultHandler, align 8
  %10 = load ptr, ptr %m_handlerArg.i, align 8
  %11 = load ptr, ptr %m_dataBuf.i, align 8
  %12 = load ptr, ptr %dataPtr.i, align 8
  %sub.ptr.lhs.cast.i = ptrtoint ptr %12 to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %11 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %conv.i = trunc i64 %sub.ptr.sub.i to i32
  call void %9(ptr noundef %10, ptr noundef %11, i32 noundef %conv.i) #24
  %13 = load ptr, ptr %s.addr.i, align 8
  store ptr %13, ptr %eventPP.0.i, align 8
  %14 = icmp ugt i32 %call.i, 1
  br i1 %14, label %do.body.i, label %reportDefault.exit, !llvm.loop !28

if.else9.i:                                       ; preds = %if.then2
  %m_handlerArg11.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 1
  %15 = load ptr, ptr %m_handlerArg11.i, align 8
  %sub.ptr.lhs.cast12.i = ptrtoint ptr %end to i64
  %sub.ptr.rhs.cast13.i = ptrtoint ptr %start to i64
  %sub.ptr.sub14.i = sub i64 %sub.ptr.lhs.cast12.i, %sub.ptr.rhs.cast13.i
  %conv15.i = trunc i64 %sub.ptr.sub14.i to i32
  tail call void %1(ptr noundef %15, ptr noundef %start, i32 noundef %conv15.i) #24
  br label %reportDefault.exit

reportDefault.exit:                               ; preds = %do.body.i, %if.else9.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %s.addr.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %dataPtr.i)
  br label %return

if.end3:                                          ; preds = %entry
  %minBytesPerChar = getelementptr inbounds %struct.encoding, ptr %enc, i64 0, i32 12
  %16 = load i32, ptr %minBytesPerChar, align 8
  %mul = shl i32 %16, 1
  %idx.ext = sext i32 %mul to i64
  %add.ptr = getelementptr i8, ptr %start, i64 %idx.ext
  %nameLength = getelementptr inbounds %struct.encoding, ptr %enc, i64 0, i32 3
  %17 = load ptr, ptr %nameLength, align 8
  %call = tail call i32 %17(ptr noundef %enc, ptr noundef %add.ptr) #24
  %idx.ext4 = sext i32 %call to i64
  %add.ptr5 = getelementptr i8, ptr %add.ptr, i64 %idx.ext4
  %m_tempPool = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 79
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ptr.addr.i.i)
  store ptr %add.ptr, ptr %ptr.addr.i.i, align 8
  %ptr1.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 79, i32 3
  %18 = load ptr, ptr %ptr1.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %18, null
  br i1 %tobool.not.i.i, label %land.lhs.true.i.i, label %if.end.i.i

land.lhs.true.i.i:                                ; preds = %if.end3
  %call.i.i = tail call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool), !range !13
  %tobool2.not.i.i = icmp eq i8 %call.i.i, 0
  br i1 %tobool2.not.i.i, label %poolAppend.exit.thread.i, label %if.end.i.i

if.end.i.i:                                       ; preds = %land.lhs.true.i.i, %if.end3
  %utf8Convert.i.i = getelementptr inbounds %struct.encoding, ptr %enc, i64 0, i32 10
  %end4.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 79, i32 2
  br label %for.cond.i.i

for.cond.i.i:                                     ; preds = %if.end8.i.i, %if.end.i.i
  %19 = load ptr, ptr %utf8Convert.i.i, align 8
  %20 = load ptr, ptr %end4.i.i, align 8
  %call5.i.i = call i32 %19(ptr noundef nonnull %enc, ptr noundef nonnull %ptr.addr.i.i, ptr noundef %add.ptr5, ptr noundef nonnull %ptr1.i.i, ptr noundef %20) #24
  %or.cond.i.i = icmp ult i32 %call5.i.i, 2
  br i1 %or.cond.i.i, label %poolAppend.exit.i, label %if.end8.i.i

if.end8.i.i:                                      ; preds = %for.cond.i.i
  %call9.i.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool), !range !13
  %tobool10.not.i.i = icmp eq i8 %call9.i.i, 0
  br i1 %tobool10.not.i.i, label %poolAppend.exit.thread.i, label %for.cond.i.i

poolAppend.exit.thread.i:                         ; preds = %if.end8.i.i, %land.lhs.true.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i)
  br label %return

poolAppend.exit.i:                                ; preds = %for.cond.i.i
  %start.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 79, i32 4
  %21 = load ptr, ptr %start.i.i, align 8
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i)
  %tobool.not.i27 = icmp eq ptr %21, null
  br i1 %tobool.not.i27, label %return, label %if.end.i28

if.end.i28:                                       ; preds = %poolAppend.exit.i
  %22 = load ptr, ptr %ptr1.i.i, align 8
  %23 = load ptr, ptr %end4.i.i, align 8
  %cmp.i29 = icmp eq ptr %22, %23
  br i1 %cmp.i29, label %land.lhs.true.i, label %poolStoreString.exit

land.lhs.true.i:                                  ; preds = %if.end.i28
  %call3.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool), !range !13
  %tobool4.not.i = icmp eq i8 %call3.i, 0
  br i1 %tobool4.not.i, label %return, label %land.lhs.true.if.end6_crit_edge.i

land.lhs.true.if.end6_crit_edge.i:                ; preds = %land.lhs.true.i
  %.pre.i = load ptr, ptr %ptr1.i.i, align 8
  br label %poolStoreString.exit

poolStoreString.exit:                             ; preds = %if.end.i28, %land.lhs.true.if.end6_crit_edge.i
  %24 = phi ptr [ %.pre.i, %land.lhs.true.if.end6_crit_edge.i ], [ %22, %if.end.i28 ]
  %incdec.ptr.i = getelementptr i8, ptr %24, i64 1
  store ptr %incdec.ptr.i, ptr %ptr1.i.i, align 8
  store i8 0, ptr %24, align 1
  %25 = load ptr, ptr %start.i.i, align 8
  %tobool7.not = icmp eq ptr %25, null
  br i1 %tobool7.not, label %return, label %if.end9

if.end9:                                          ; preds = %poolStoreString.exit
  %26 = load ptr, ptr %ptr1.i.i, align 8
  store ptr %26, ptr %start.i.i, align 8
  %skipS = getelementptr inbounds %struct.encoding, ptr %enc, i64 0, i32 4
  %27 = load ptr, ptr %skipS, align 8
  %call14 = call ptr %27(ptr noundef nonnull %enc, ptr noundef %add.ptr5) #24
  %28 = load i32, ptr %minBytesPerChar, align 8
  %mul16 = shl i32 %28, 1
  %idx.ext17 = sext i32 %mul16 to i64
  %idx.neg = sub nsw i64 0, %idx.ext17
  %add.ptr18 = getelementptr i8, ptr %end, i64 %idx.neg
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ptr.addr.i.i30)
  store ptr %call14, ptr %ptr.addr.i.i30, align 8
  %29 = load ptr, ptr %ptr1.i.i, align 8
  %tobool.not.i.i32 = icmp eq ptr %29, null
  br i1 %tobool.not.i.i32, label %land.lhs.true.i.i56, label %for.cond.i.i36.preheader

land.lhs.true.i.i56:                              ; preds = %if.end9
  %call.i.i57 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool), !range !13
  %tobool2.not.i.i58 = icmp eq i8 %call.i.i57, 0
  br i1 %tobool2.not.i.i58, label %poolAppend.exit.thread.i42, label %for.cond.i.i36.preheader

for.cond.i.i36.preheader:                         ; preds = %land.lhs.true.i.i56, %if.end9
  br label %for.cond.i.i36

for.cond.i.i36:                                   ; preds = %for.cond.i.i36.preheader, %if.end8.i.i39
  %30 = load ptr, ptr %utf8Convert.i.i, align 8
  %31 = load ptr, ptr %end4.i.i, align 8
  %call5.i.i37 = call i32 %30(ptr noundef nonnull %enc, ptr noundef nonnull %ptr.addr.i.i30, ptr noundef %add.ptr18, ptr noundef nonnull %ptr1.i.i, ptr noundef %31) #24
  %or.cond.i.i38 = icmp ult i32 %call5.i.i37, 2
  br i1 %or.cond.i.i38, label %poolAppend.exit.i44, label %if.end8.i.i39

if.end8.i.i39:                                    ; preds = %for.cond.i.i36
  %call9.i.i40 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool), !range !13
  %tobool10.not.i.i41 = icmp eq i8 %call9.i.i40, 0
  br i1 %tobool10.not.i.i41, label %poolAppend.exit.thread.i42, label %for.cond.i.i36

poolAppend.exit.thread.i42:                       ; preds = %if.end8.i.i39, %land.lhs.true.i.i56
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i30)
  br label %return

poolAppend.exit.i44:                              ; preds = %for.cond.i.i36
  %32 = load ptr, ptr %start.i.i, align 8
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i30)
  %tobool.not.i46 = icmp eq ptr %32, null
  br i1 %tobool.not.i46, label %return, label %if.end.i47

if.end.i47:                                       ; preds = %poolAppend.exit.i44
  %33 = load ptr, ptr %ptr1.i.i, align 8
  %34 = load ptr, ptr %end4.i.i, align 8
  %cmp.i48 = icmp eq ptr %33, %34
  br i1 %cmp.i48, label %land.lhs.true.i51, label %poolStoreString.exit59

land.lhs.true.i51:                                ; preds = %if.end.i47
  %call3.i52 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool), !range !13
  %tobool4.not.i53 = icmp eq i8 %call3.i52, 0
  br i1 %tobool4.not.i53, label %return, label %land.lhs.true.if.end6_crit_edge.i54

land.lhs.true.if.end6_crit_edge.i54:              ; preds = %land.lhs.true.i51
  %.pre.i55 = load ptr, ptr %ptr1.i.i, align 8
  br label %poolStoreString.exit59

poolStoreString.exit59:                           ; preds = %if.end.i47, %land.lhs.true.if.end6_crit_edge.i54
  %35 = phi ptr [ %.pre.i55, %land.lhs.true.if.end6_crit_edge.i54 ], [ %33, %if.end.i47 ]
  %incdec.ptr.i50 = getelementptr i8, ptr %35, i64 1
  store ptr %incdec.ptr.i50, ptr %ptr1.i.i, align 8
  store i8 0, ptr %35, align 1
  %36 = load ptr, ptr %start.i.i, align 8
  %tobool20.not = icmp eq ptr %36, null
  br i1 %tobool20.not, label %return, label %for.cond.i

for.cond.i:                                       ; preds = %poolStoreString.exit59, %for.inc.i
  %s.addr.0.i = phi ptr [ %incdec.ptr.i63, %for.inc.i ], [ %36, %poolStoreString.exit59 ]
  %37 = load i8, ptr %s.addr.0.i, align 1
  switch i8 %37, label %for.inc.i [
    i8 0, label %normalizeLines.exit
    i8 13, label %do.body.i60
  ]

for.inc.i:                                        ; preds = %for.cond.i
  %incdec.ptr.i63 = getelementptr i8, ptr %s.addr.0.i, i64 1
  br label %for.cond.i

do.body.i60:                                      ; preds = %for.cond.i, %do.cond.i
  %38 = phi i8 [ %40, %do.cond.i ], [ %37, %for.cond.i ]
  %s.addr.1.i = phi ptr [ %s.addr.2.i, %do.cond.i ], [ %s.addr.0.i, %for.cond.i ]
  %p.0.i = phi ptr [ %p.1.i, %do.cond.i ], [ %s.addr.0.i, %for.cond.i ]
  %cmp8.i = icmp eq i8 %38, 13
  br i1 %cmp8.i, label %if.then10.i, label %if.else.i61

if.then10.i:                                      ; preds = %do.body.i60
  store i8 10, ptr %p.0.i, align 1
  %incdec.ptr12.i = getelementptr i8, ptr %s.addr.1.i, i64 1
  %39 = load i8, ptr %incdec.ptr12.i, align 1
  %cmp14.i = icmp eq i8 %39, 10
  %incdec.ptr17.i = getelementptr i8, ptr %s.addr.1.i, i64 2
  %spec.select.i = select i1 %cmp14.i, ptr %incdec.ptr17.i, ptr %incdec.ptr12.i
  br label %do.cond.i

if.else.i61:                                      ; preds = %do.body.i60
  %incdec.ptr19.i = getelementptr i8, ptr %s.addr.1.i, i64 1
  store i8 %38, ptr %p.0.i, align 1
  br label %do.cond.i

do.cond.i:                                        ; preds = %if.else.i61, %if.then10.i
  %s.addr.2.i = phi ptr [ %incdec.ptr19.i, %if.else.i61 ], [ %spec.select.i, %if.then10.i ]
  %p.1.i = getelementptr i8, ptr %p.0.i, i64 1
  %40 = load i8, ptr %s.addr.2.i, align 1
  %tobool.not.i62 = icmp eq i8 %40, 0
  br i1 %tobool.not.i62, label %do.end.i, label %do.body.i60, !llvm.loop !50

do.end.i:                                         ; preds = %do.cond.i
  store i8 0, ptr %p.1.i, align 1
  br label %normalizeLines.exit

normalizeLines.exit:                              ; preds = %for.cond.i, %do.end.i
  %41 = load ptr, ptr %m_processingInstructionHandler, align 8
  %m_handlerArg = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 1
  %42 = load ptr, ptr %m_handlerArg, align 8
  call void %41(ptr noundef %42, ptr noundef nonnull %25, ptr noundef nonnull %36) #24
  %freeBlocks.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 79, i32 1
  %43 = load ptr, ptr %freeBlocks.i, align 8
  %tobool.not.i64 = icmp eq ptr %43, null
  %44 = load ptr, ptr %m_tempPool, align 8
  br i1 %tobool.not.i64, label %if.then.i67, label %if.else.i65

if.then.i67:                                      ; preds = %normalizeLines.exit
  store ptr %44, ptr %freeBlocks.i, align 8
  br label %poolClear.exit

if.else.i65:                                      ; preds = %normalizeLines.exit
  %tobool3.not13.i = icmp eq ptr %44, null
  br i1 %tobool3.not13.i, label %poolClear.exit, label %while.body.i

while.body.i:                                     ; preds = %if.else.i65, %while.body.i
  %45 = phi ptr [ %p.014.i, %while.body.i ], [ %43, %if.else.i65 ]
  %p.014.i = phi ptr [ %46, %while.body.i ], [ %44, %if.else.i65 ]
  %46 = load ptr, ptr %p.014.i, align 8
  store ptr %45, ptr %p.014.i, align 8
  store ptr %p.014.i, ptr %freeBlocks.i, align 8
  %tobool3.not.i = icmp eq ptr %46, null
  br i1 %tobool3.not.i, label %poolClear.exit, label %while.body.i, !llvm.loop !8

poolClear.exit:                                   ; preds = %while.body.i, %if.then.i67, %if.else.i65
  store ptr null, ptr %m_tempPool, align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %end4.i.i, i8 0, i64 24, i1 false)
  br label %return

return:                                           ; preds = %poolAppend.exit.thread.i42, %land.lhs.true.i51, %poolAppend.exit.i44, %poolAppend.exit.thread.i, %land.lhs.true.i, %poolAppend.exit.i, %poolStoreString.exit59, %poolStoreString.exit, %if.then, %reportDefault.exit, %poolClear.exit
  %retval.0 = phi i32 [ 1, %poolClear.exit ], [ 1, %reportDefault.exit ], [ 1, %if.then ], [ 0, %poolStoreString.exit ], [ 0, %poolStoreString.exit59 ], [ 0, %poolAppend.exit.i ], [ 0, %land.lhs.true.i ], [ 0, %poolAppend.exit.thread.i ], [ 0, %poolAppend.exit.i44 ], [ 0, %land.lhs.true.i51 ], [ 0, %poolAppend.exit.thread.i42 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @reportComment(ptr noundef %parser, ptr noundef %enc, ptr noundef %start, ptr noundef %end) unnamed_addr #0 {
entry:
  %ptr.addr.i.i = alloca ptr, align 8
  %s.addr.i = alloca ptr, align 8
  %dataPtr.i = alloca ptr, align 8
  %m_commentHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 15
  %0 = load ptr, ptr %m_commentHandler, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %if.then, label %if.end3

if.then:                                          ; preds = %entry
  %m_defaultHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 18
  %1 = load ptr, ptr %m_defaultHandler, align 8
  %tobool1.not = icmp eq ptr %1, null
  br i1 %tobool1.not, label %return, label %if.then2

if.then2:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %s.addr.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %dataPtr.i)
  store ptr %start, ptr %s.addr.i, align 8
  %isUtf8.i = getelementptr inbounds %struct.encoding, ptr %enc, i64 0, i32 13
  %2 = load i8, ptr %isUtf8.i, align 4
  %tobool.not.i = icmp eq i8 %2, 0
  br i1 %tobool.not.i, label %if.then.i, label %if.else9.i

if.then.i:                                        ; preds = %if.then2
  %m_encoding.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 34
  %3 = load ptr, ptr %m_encoding.i, align 8
  %cmp.i = icmp eq ptr %3, %enc
  br i1 %cmp.i, label %if.then1.i, label %if.else.i

if.then1.i:                                       ; preds = %if.then.i
  %m_eventPtr.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 47
  %m_eventEndPtr.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 48
  br label %if.end.i

if.else.i:                                        ; preds = %if.then.i
  %m_openInternalEntities.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 50
  %4 = load ptr, ptr %m_openInternalEntities.i, align 8
  %internalEventEndPtr.i = getelementptr inbounds %struct.open_internal_entity, ptr %4, i64 0, i32 1
  br label %if.end.i

if.end.i:                                         ; preds = %if.else.i, %if.then1.i
  %eventPP.0.i = phi ptr [ %m_eventPtr.i, %if.then1.i ], [ %4, %if.else.i ]
  %eventEndPP.0.i = phi ptr [ %m_eventEndPtr.i, %if.then1.i ], [ %internalEventEndPtr.i, %if.else.i ]
  %m_dataBuf.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 9
  %utf8Convert.i = getelementptr inbounds %struct.encoding, ptr %enc, i64 0, i32 10
  %m_dataBufEnd.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 10
  %m_handlerArg.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 1
  br label %do.body.i

do.body.i:                                        ; preds = %do.body.i, %if.end.i
  %5 = load ptr, ptr %m_dataBuf.i, align 8
  store ptr %5, ptr %dataPtr.i, align 8
  %6 = load ptr, ptr %utf8Convert.i, align 8
  %7 = load ptr, ptr %m_dataBufEnd.i, align 8
  %call.i = call i32 %6(ptr noundef nonnull %enc, ptr noundef nonnull %s.addr.i, ptr noundef %end, ptr noundef nonnull %dataPtr.i, ptr noundef %7) #24
  %8 = load ptr, ptr %s.addr.i, align 8
  store ptr %8, ptr %eventEndPP.0.i, align 8
  %9 = load ptr, ptr %m_defaultHandler, align 8
  %10 = load ptr, ptr %m_handlerArg.i, align 8
  %11 = load ptr, ptr %m_dataBuf.i, align 8
  %12 = load ptr, ptr %dataPtr.i, align 8
  %sub.ptr.lhs.cast.i = ptrtoint ptr %12 to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %11 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %conv.i = trunc i64 %sub.ptr.sub.i to i32
  call void %9(ptr noundef %10, ptr noundef %11, i32 noundef %conv.i) #24
  %13 = load ptr, ptr %s.addr.i, align 8
  store ptr %13, ptr %eventPP.0.i, align 8
  %14 = icmp ugt i32 %call.i, 1
  br i1 %14, label %do.body.i, label %reportDefault.exit, !llvm.loop !28

if.else9.i:                                       ; preds = %if.then2
  %m_handlerArg11.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 1
  %15 = load ptr, ptr %m_handlerArg11.i, align 8
  %sub.ptr.lhs.cast12.i = ptrtoint ptr %end to i64
  %sub.ptr.rhs.cast13.i = ptrtoint ptr %start to i64
  %sub.ptr.sub14.i = sub i64 %sub.ptr.lhs.cast12.i, %sub.ptr.rhs.cast13.i
  %conv15.i = trunc i64 %sub.ptr.sub14.i to i32
  tail call void %1(ptr noundef %15, ptr noundef %start, i32 noundef %conv15.i) #24
  br label %reportDefault.exit

reportDefault.exit:                               ; preds = %do.body.i, %if.else9.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %s.addr.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %dataPtr.i)
  br label %return

if.end3:                                          ; preds = %entry
  %m_tempPool = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 79
  %minBytesPerChar = getelementptr inbounds %struct.encoding, ptr %enc, i64 0, i32 12
  %16 = load i32, ptr %minBytesPerChar, align 8
  %mul = shl i32 %16, 2
  %idx.ext = sext i32 %mul to i64
  %add.ptr = getelementptr i8, ptr %start, i64 %idx.ext
  %mul5 = mul i32 %16, 3
  %idx.ext6 = sext i32 %mul5 to i64
  %idx.neg = sub nsw i64 0, %idx.ext6
  %add.ptr7 = getelementptr i8, ptr %end, i64 %idx.neg
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ptr.addr.i.i)
  store ptr %add.ptr, ptr %ptr.addr.i.i, align 8
  %ptr1.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 79, i32 3
  %17 = load ptr, ptr %ptr1.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %17, null
  br i1 %tobool.not.i.i, label %land.lhs.true.i.i, label %if.end.i.i

land.lhs.true.i.i:                                ; preds = %if.end3
  %call.i.i = tail call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool), !range !13
  %tobool2.not.i.i = icmp eq i8 %call.i.i, 0
  br i1 %tobool2.not.i.i, label %poolAppend.exit.thread.i, label %if.end.i.i

if.end.i.i:                                       ; preds = %land.lhs.true.i.i, %if.end3
  %utf8Convert.i.i = getelementptr inbounds %struct.encoding, ptr %enc, i64 0, i32 10
  %end4.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 79, i32 2
  br label %for.cond.i.i

for.cond.i.i:                                     ; preds = %if.end8.i.i, %if.end.i.i
  %18 = load ptr, ptr %utf8Convert.i.i, align 8
  %19 = load ptr, ptr %end4.i.i, align 8
  %call5.i.i = call i32 %18(ptr noundef nonnull %enc, ptr noundef nonnull %ptr.addr.i.i, ptr noundef %add.ptr7, ptr noundef nonnull %ptr1.i.i, ptr noundef %19) #24
  %or.cond.i.i = icmp ult i32 %call5.i.i, 2
  br i1 %or.cond.i.i, label %poolAppend.exit.i, label %if.end8.i.i

if.end8.i.i:                                      ; preds = %for.cond.i.i
  %call9.i.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool), !range !13
  %tobool10.not.i.i = icmp eq i8 %call9.i.i, 0
  br i1 %tobool10.not.i.i, label %poolAppend.exit.thread.i, label %for.cond.i.i

poolAppend.exit.thread.i:                         ; preds = %if.end8.i.i, %land.lhs.true.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i)
  br label %return

poolAppend.exit.i:                                ; preds = %for.cond.i.i
  %start.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 79, i32 4
  %20 = load ptr, ptr %start.i.i, align 8
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i)
  %tobool.not.i14 = icmp eq ptr %20, null
  br i1 %tobool.not.i14, label %return, label %if.end.i15

if.end.i15:                                       ; preds = %poolAppend.exit.i
  %21 = load ptr, ptr %ptr1.i.i, align 8
  %22 = load ptr, ptr %end4.i.i, align 8
  %cmp.i16 = icmp eq ptr %21, %22
  br i1 %cmp.i16, label %land.lhs.true.i, label %poolStoreString.exit

land.lhs.true.i:                                  ; preds = %if.end.i15
  %call3.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool), !range !13
  %tobool4.not.i = icmp eq i8 %call3.i, 0
  br i1 %tobool4.not.i, label %return, label %land.lhs.true.if.end6_crit_edge.i

land.lhs.true.if.end6_crit_edge.i:                ; preds = %land.lhs.true.i
  %.pre.i = load ptr, ptr %ptr1.i.i, align 8
  br label %poolStoreString.exit

poolStoreString.exit:                             ; preds = %if.end.i15, %land.lhs.true.if.end6_crit_edge.i
  %23 = phi ptr [ %.pre.i, %land.lhs.true.if.end6_crit_edge.i ], [ %21, %if.end.i15 ]
  %incdec.ptr.i = getelementptr i8, ptr %23, i64 1
  store ptr %incdec.ptr.i, ptr %ptr1.i.i, align 8
  store i8 0, ptr %23, align 1
  %24 = load ptr, ptr %start.i.i, align 8
  %tobool8.not = icmp eq ptr %24, null
  br i1 %tobool8.not, label %return, label %for.cond.i

for.cond.i:                                       ; preds = %poolStoreString.exit, %for.inc.i
  %s.addr.0.i = phi ptr [ %incdec.ptr.i20, %for.inc.i ], [ %24, %poolStoreString.exit ]
  %25 = load i8, ptr %s.addr.0.i, align 1
  switch i8 %25, label %for.inc.i [
    i8 0, label %normalizeLines.exit
    i8 13, label %do.body.i17
  ]

for.inc.i:                                        ; preds = %for.cond.i
  %incdec.ptr.i20 = getelementptr i8, ptr %s.addr.0.i, i64 1
  br label %for.cond.i

do.body.i17:                                      ; preds = %for.cond.i, %do.cond.i
  %26 = phi i8 [ %28, %do.cond.i ], [ %25, %for.cond.i ]
  %s.addr.1.i = phi ptr [ %s.addr.2.i, %do.cond.i ], [ %s.addr.0.i, %for.cond.i ]
  %p.0.i = phi ptr [ %p.1.i, %do.cond.i ], [ %s.addr.0.i, %for.cond.i ]
  %cmp8.i = icmp eq i8 %26, 13
  br i1 %cmp8.i, label %if.then10.i, label %if.else.i18

if.then10.i:                                      ; preds = %do.body.i17
  store i8 10, ptr %p.0.i, align 1
  %incdec.ptr12.i = getelementptr i8, ptr %s.addr.1.i, i64 1
  %27 = load i8, ptr %incdec.ptr12.i, align 1
  %cmp14.i = icmp eq i8 %27, 10
  %incdec.ptr17.i = getelementptr i8, ptr %s.addr.1.i, i64 2
  %spec.select.i = select i1 %cmp14.i, ptr %incdec.ptr17.i, ptr %incdec.ptr12.i
  br label %do.cond.i

if.else.i18:                                      ; preds = %do.body.i17
  %incdec.ptr19.i = getelementptr i8, ptr %s.addr.1.i, i64 1
  store i8 %26, ptr %p.0.i, align 1
  br label %do.cond.i

do.cond.i:                                        ; preds = %if.else.i18, %if.then10.i
  %s.addr.2.i = phi ptr [ %incdec.ptr19.i, %if.else.i18 ], [ %spec.select.i, %if.then10.i ]
  %p.1.i = getelementptr i8, ptr %p.0.i, i64 1
  %28 = load i8, ptr %s.addr.2.i, align 1
  %tobool.not.i19 = icmp eq i8 %28, 0
  br i1 %tobool.not.i19, label %do.end.i, label %do.body.i17, !llvm.loop !50

do.end.i:                                         ; preds = %do.cond.i
  store i8 0, ptr %p.1.i, align 1
  br label %normalizeLines.exit

normalizeLines.exit:                              ; preds = %for.cond.i, %do.end.i
  %29 = load ptr, ptr %m_commentHandler, align 8
  %m_handlerArg = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 1
  %30 = load ptr, ptr %m_handlerArg, align 8
  call void %29(ptr noundef %30, ptr noundef nonnull %24) #24
  %freeBlocks.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 79, i32 1
  %31 = load ptr, ptr %freeBlocks.i, align 8
  %tobool.not.i21 = icmp eq ptr %31, null
  %32 = load ptr, ptr %m_tempPool, align 8
  br i1 %tobool.not.i21, label %if.then.i24, label %if.else.i22

if.then.i24:                                      ; preds = %normalizeLines.exit
  store ptr %32, ptr %freeBlocks.i, align 8
  br label %poolClear.exit

if.else.i22:                                      ; preds = %normalizeLines.exit
  %tobool3.not13.i = icmp eq ptr %32, null
  br i1 %tobool3.not13.i, label %poolClear.exit, label %while.body.i

while.body.i:                                     ; preds = %if.else.i22, %while.body.i
  %33 = phi ptr [ %p.014.i, %while.body.i ], [ %31, %if.else.i22 ]
  %p.014.i = phi ptr [ %34, %while.body.i ], [ %32, %if.else.i22 ]
  %34 = load ptr, ptr %p.014.i, align 8
  store ptr %33, ptr %p.014.i, align 8
  store ptr %p.014.i, ptr %freeBlocks.i, align 8
  %tobool3.not.i = icmp eq ptr %34, null
  br i1 %tobool3.not.i, label %poolClear.exit, label %while.body.i, !llvm.loop !8

poolClear.exit:                                   ; preds = %while.body.i, %if.then.i24, %if.else.i22
  store ptr null, ptr %m_tempPool, align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %end4.i.i, i8 0, i64 24, i1 false)
  br label %return

return:                                           ; preds = %poolAppend.exit.thread.i, %land.lhs.true.i, %poolAppend.exit.i, %poolStoreString.exit, %if.then, %reportDefault.exit, %poolClear.exit
  %retval.0 = phi i32 [ 1, %poolClear.exit ], [ 1, %reportDefault.exit ], [ 1, %if.then ], [ 0, %poolStoreString.exit ], [ 0, %poolAppend.exit.i ], [ 0, %land.lhs.true.i ], [ 0, %poolAppend.exit.thread.i ]
  ret i32 %retval.0
}

; Function Attrs: nofree nounwind
declare noundef i32 @fprintf(ptr nocapture noundef, ptr nocapture noundef readonly, ...) local_unnamed_addr #13

declare i32 @PyExpat_XmlParseXmlDeclNS(i32 noundef, ptr noundef, ptr noundef, ptr noundef, ptr noundef, ptr noundef, ptr noundef, ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #1

declare i32 @PyExpat_XmlParseXmlDecl(i32 noundef, ptr noundef, ptr noundef, ptr noundef, ptr noundef, ptr noundef, ptr noundef, ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nofree nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define internal fastcc i64 @hash(ptr nocapture noundef readonly %parser, ptr noundef readonly %s) unnamed_addr #14 {
entry:
  %state = alloca %struct.siphash, align 8
  br label %tailrecurse.i.i

tailrecurse.i.i:                                  ; preds = %tailrecurse.i.i, %entry
  %parser.tr.i.i = phi ptr [ %parser, %entry ], [ %0, %tailrecurse.i.i ]
  %m_parentParser.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser.tr.i.i, i64 0, i32 84
  %0 = load ptr, ptr %m_parentParser.i.i, align 8
  %cmp.not.i.i = icmp eq ptr %0, null
  br i1 %cmp.not.i.i, label %copy_salt_to_sipkey.exit, label %tailrecurse.i.i

copy_salt_to_sipkey.exit:                         ; preds = %tailrecurse.i.i
  %m_hash_secret_salt.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser.tr.i.i, i64 0, i32 89
  %1 = load i64, ptr %m_hash_secret_salt.i.i, align 8
  store i64 8317987319222330741, ptr %state, align 8
  %xor3.i = xor i64 %1, 7237128888997146477
  %v1.i = getelementptr inbounds %struct.siphash, ptr %state, i64 0, i32 1
  store i64 %xor3.i, ptr %v1.i, align 8
  %v2.i = getelementptr inbounds %struct.siphash, ptr %state, i64 0, i32 2
  store i64 7816392313619706465, ptr %v2.i, align 8
  %xor9.i = xor i64 %1, 8387220255154660723
  %v3.i = getelementptr inbounds %struct.siphash, ptr %state, i64 0, i32 3
  store i64 %xor9.i, ptr %v3.i, align 8
  %buf.i = getelementptr inbounds %struct.siphash, ptr %state, i64 0, i32 4
  %p.i = getelementptr inbounds %struct.siphash, ptr %state, i64 0, i32 5
  store ptr %buf.i, ptr %p.i, align 8
  %c.i = getelementptr inbounds %struct.siphash, ptr %state, i64 0, i32 6
  store i64 0, ptr %c.i, align 8
  %2 = load i8, ptr %s, align 1
  %tobool.not3.i = icmp eq i8 %2, 0
  br i1 %tobool.not3.i, label %keylen.exit, label %for.inc.i

for.inc.i:                                        ; preds = %copy_salt_to_sipkey.exit, %for.inc.i
  %len.05.i = phi i64 [ %inc.i, %for.inc.i ], [ 0, %copy_salt_to_sipkey.exit ]
  %s.addr.04.i = phi ptr [ %incdec.ptr.i, %for.inc.i ], [ %s, %copy_salt_to_sipkey.exit ]
  %incdec.ptr.i = getelementptr i8, ptr %s.addr.04.i, i64 1
  %inc.i = add i64 %len.05.i, 1
  %3 = load i8, ptr %incdec.ptr.i, align 1
  %tobool.not.i = icmp eq i8 %3, 0
  br i1 %tobool.not.i, label %keylen.exit, label %for.inc.i, !llvm.loop !51

keylen.exit:                                      ; preds = %for.inc.i, %copy_salt_to_sipkey.exit
  %len.0.lcssa.i = phi i64 [ 0, %copy_salt_to_sipkey.exit ], [ %inc.i, %for.inc.i ]
  %add.ptr.i = getelementptr i8, ptr %s, i64 %len.0.lcssa.i
  %arrayidx26.i = getelementptr inbounds %struct.siphash, ptr %state, i64 0, i32 4, i64 4
  %arrayidx31.i = getelementptr inbounds %struct.siphash, ptr %state, i64 0, i32 4, i64 5
  %arrayidx36.i = getelementptr inbounds %struct.siphash, ptr %state, i64 0, i32 4, i64 6
  %arrayidx41.i = getelementptr inbounds %struct.siphash, ptr %state, i64 0, i32 4, i64 7
  br label %do.body.i

do.body.i:                                        ; preds = %sip_round.exit.i, %keylen.exit
  %p.0.i = phi ptr [ %s, %keylen.exit ], [ %p.1.lcssa.i, %sip_round.exit.i ]
  %cmp25.i = icmp ult ptr %p.0.i, %add.ptr.i
  br i1 %cmp25.i, label %land.rhs.i, label %sip24_update.exit

land.rhs.i:                                       ; preds = %do.body.i, %while.body.i
  %p.126.i = phi ptr [ %incdec.ptr.i6, %while.body.i ], [ %p.0.i, %do.body.i ]
  %4 = load ptr, ptr %p.i, align 8
  %cmp2.not.i.not.not = icmp ult ptr %4, %p.i
  br i1 %cmp2.not.i.not.not, label %while.body.i, label %while.end.i

while.body.i:                                     ; preds = %land.rhs.i
  %incdec.ptr.i6 = getelementptr i8, ptr %p.126.i, i64 1
  %5 = load i8, ptr %p.126.i, align 1
  %incdec.ptr4.i = getelementptr i8, ptr %4, i64 1
  store ptr %incdec.ptr4.i, ptr %p.i, align 8
  store i8 %5, ptr %4, align 1
  %cmp.i = icmp ult ptr %incdec.ptr.i6, %add.ptr.i
  br i1 %cmp.i, label %land.rhs.i, label %while.body.i.while.end.i.loopexit_crit_edge, !llvm.loop !52

while.body.i.while.end.i.loopexit_crit_edge:      ; preds = %while.body.i
  %.pre.pre = load ptr, ptr %p.i, align 8
  br label %while.end.i

while.end.i:                                      ; preds = %land.rhs.i, %while.body.i.while.end.i.loopexit_crit_edge
  %6 = phi ptr [ %.pre.pre, %while.body.i.while.end.i.loopexit_crit_edge ], [ %4, %land.rhs.i ]
  %p.1.lcssa.i = phi ptr [ %incdec.ptr.i6, %while.body.i.while.end.i.loopexit_crit_edge ], [ %p.126.i, %land.rhs.i ]
  %cmp8.i = icmp ult ptr %6, %p.i
  br i1 %cmp8.i, label %sip24_update.exit, label %if.end.i

if.end.i:                                         ; preds = %while.end.i
  %7 = load i32, ptr %buf.i, align 8
  %8 = zext i32 %7 to i64
  %9 = load i8, ptr %arrayidx26.i, align 4
  %conv27.i = zext i8 %9 to i64
  %shl28.i = shl nuw nsw i64 %conv27.i, 32
  %or29.i = or disjoint i64 %shl28.i, %8
  %10 = load i8, ptr %arrayidx31.i, align 1
  %conv32.i = zext i8 %10 to i64
  %shl33.i = shl nuw nsw i64 %conv32.i, 40
  %or34.i = or disjoint i64 %or29.i, %shl33.i
  %11 = load i8, ptr %arrayidx36.i, align 2
  %conv37.i = zext i8 %11 to i64
  %shl38.i = shl nuw nsw i64 %conv37.i, 48
  %or39.i = or disjoint i64 %or34.i, %shl38.i
  %12 = load i8, ptr %arrayidx41.i, align 1
  %conv42.i = zext i8 %12 to i64
  %shl43.i = shl nuw i64 %conv42.i, 56
  %or44.i = or disjoint i64 %or39.i, %shl43.i
  %13 = load i64, ptr %v3.i, align 8
  %xor.i5 = xor i64 %or44.i, %13
  %v1.promoted.i.i = load i64, ptr %v1.i, align 8
  %H.promoted.i.i = load i64, ptr %state, align 8
  %v2.promoted.i.i = load i64, ptr %v2.i, align 8
  br label %for.body.i.i

for.body.i.i:                                     ; preds = %for.body.i.i, %if.end.i
  %or5040.i.i = phi i64 [ %v2.promoted.i.i, %if.end.i ], [ %or50.i.i, %for.body.i.i ]
  %xor3339.i.i = phi i64 [ %xor.i5, %if.end.i ], [ %xor33.i.i, %for.body.i.i ]
  %add2438.i.i = phi i64 [ %H.promoted.i.i, %if.end.i ], [ %add24.i.i, %for.body.i.i ]
  %xor4537.i.i = phi i64 [ %v1.promoted.i.i, %if.end.i ], [ %xor45.i.i, %for.body.i.i ]
  %i.036.i.i = phi i32 [ 0, %if.end.i ], [ %inc.i.i, %for.body.i.i ]
  %add.i.i = add i64 %xor4537.i.i, %add2438.i.i
  %or.i.i = call i64 @llvm.fshl.i64(i64 %xor4537.i.i, i64 %xor4537.i.i, i64 13)
  %xor.i.i = xor i64 %add.i.i, %or.i.i
  %or10.i.i = call i64 @llvm.fshl.i64(i64 %add.i.i, i64 %add.i.i, i64 32)
  %add12.i.i = add i64 %xor3339.i.i, %or5040.i.i
  %or17.i.i = call i64 @llvm.fshl.i64(i64 %xor3339.i.i, i64 %xor3339.i.i, i64 16)
  %xor21.i.i = xor i64 %add12.i.i, %or17.i.i
  %add24.i.i = add i64 %or10.i.i, %xor21.i.i
  %or29.i.i = call i64 @llvm.fshl.i64(i64 %xor21.i.i, i64 %xor21.i.i, i64 21)
  %xor33.i.i = xor i64 %add24.i.i, %or29.i.i
  %add36.i.i = add i64 %xor.i.i, %add12.i.i
  %or41.i.i = call i64 @llvm.fshl.i64(i64 %xor.i.i, i64 %xor.i.i, i64 17)
  %xor45.i.i = xor i64 %add36.i.i, %or41.i.i
  %or50.i.i = call i64 @llvm.fshl.i64(i64 %add36.i.i, i64 %add36.i.i, i64 32)
  %inc.i.i = add nuw nsw i32 %i.036.i.i, 1
  %exitcond.not.i.i = icmp eq i32 %inc.i.i, 2
  br i1 %exitcond.not.i.i, label %sip_round.exit.i, label %for.body.i.i, !llvm.loop !53

sip_round.exit.i:                                 ; preds = %for.body.i.i
  store i64 %xor45.i.i, ptr %v1.i, align 8
  store i64 %xor33.i.i, ptr %v3.i, align 8
  store i64 %or50.i.i, ptr %v2.i, align 8
  %xor45.i = xor i64 %add24.i.i, %or44.i
  store i64 %xor45.i, ptr %state, align 8
  store ptr %buf.i, ptr %p.i, align 8
  %14 = load i64, ptr %c.i, align 8
  %add.i = add i64 %14, 8
  store i64 %add.i, ptr %c.i, align 8
  br i1 %cmp2.not.i.not.not, label %sip24_update.exit, label %do.body.i, !llvm.loop !54

sip24_update.exit:                                ; preds = %do.body.i, %while.end.i, %sip_round.exit.i
  %call3 = call fastcc i64 @sip24_final(ptr noundef nonnull %state)
  ret i64 %call3
}

; Function Attrs: nofree nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define internal fastcc ptr @sip24_update(ptr noundef returned %H, ptr noundef readonly %src, i64 noundef %len) unnamed_addr #14 {
entry:
  %add.ptr = getelementptr i8, ptr %src, i64 %len
  %p1 = getelementptr inbounds %struct.siphash, ptr %H, i64 0, i32 5
  %buf6 = getelementptr inbounds %struct.siphash, ptr %H, i64 0, i32 4
  %arrayidx26 = getelementptr %struct.siphash, ptr %H, i64 0, i32 4, i64 4
  %arrayidx31 = getelementptr %struct.siphash, ptr %H, i64 0, i32 4, i64 5
  %arrayidx36 = getelementptr %struct.siphash, ptr %H, i64 0, i32 4, i64 6
  %arrayidx41 = getelementptr %struct.siphash, ptr %H, i64 0, i32 4, i64 7
  %v3 = getelementptr inbounds %struct.siphash, ptr %H, i64 0, i32 3
  %v1.i = getelementptr inbounds %struct.siphash, ptr %H, i64 0, i32 1
  %v2.i = getelementptr inbounds %struct.siphash, ptr %H, i64 0, i32 2
  %c = getelementptr inbounds %struct.siphash, ptr %H, i64 0, i32 6
  br label %do.body

do.body:                                          ; preds = %sip_round.exit, %entry
  %p.0 = phi ptr [ %src, %entry ], [ %p.1.lcssa, %sip_round.exit ]
  %cmp25 = icmp ult ptr %p.0, %add.ptr
  br i1 %cmp25, label %land.rhs, label %while.end

land.rhs:                                         ; preds = %do.body, %while.body
  %p.126 = phi ptr [ %incdec.ptr, %while.body ], [ %p.0, %do.body ]
  %0 = load ptr, ptr %p1, align 8
  %cmp2.not = icmp uge ptr %0, %p1
  br i1 %cmp2.not, label %while.end, label %while.body

while.body:                                       ; preds = %land.rhs
  %incdec.ptr = getelementptr i8, ptr %p.126, i64 1
  %1 = load i8, ptr %p.126, align 1
  %incdec.ptr4 = getelementptr i8, ptr %0, i64 1
  store ptr %incdec.ptr4, ptr %p1, align 8
  store i8 %1, ptr %0, align 1
  %cmp = icmp ult ptr %incdec.ptr, %add.ptr
  br i1 %cmp, label %land.rhs, label %while.end, !llvm.loop !52

while.end:                                        ; preds = %land.rhs, %while.body, %do.body
  %p.1.lcssa = phi ptr [ %p.0, %do.body ], [ %incdec.ptr, %while.body ], [ %p.126, %land.rhs ]
  %cmp.lcssa = phi i1 [ false, %do.body ], [ %cmp2.not, %while.body ], [ %cmp2.not, %land.rhs ]
  %2 = load ptr, ptr %p1, align 8
  %cmp8 = icmp ult ptr %2, %p1
  br i1 %cmp8, label %do.end, label %if.end

if.end:                                           ; preds = %while.end
  %3 = load i32, ptr %buf6, align 8
  %4 = zext i32 %3 to i64
  %5 = load i8, ptr %arrayidx26, align 4
  %conv27 = zext i8 %5 to i64
  %shl28 = shl nuw nsw i64 %conv27, 32
  %or29 = or disjoint i64 %shl28, %4
  %6 = load i8, ptr %arrayidx31, align 1
  %conv32 = zext i8 %6 to i64
  %shl33 = shl nuw nsw i64 %conv32, 40
  %or34 = or disjoint i64 %or29, %shl33
  %7 = load i8, ptr %arrayidx36, align 2
  %conv37 = zext i8 %7 to i64
  %shl38 = shl nuw nsw i64 %conv37, 48
  %or39 = or disjoint i64 %or34, %shl38
  %8 = load i8, ptr %arrayidx41, align 1
  %conv42 = zext i8 %8 to i64
  %shl43 = shl nuw i64 %conv42, 56
  %or44 = or disjoint i64 %or39, %shl43
  %9 = load i64, ptr %v3, align 8
  %xor = xor i64 %or44, %9
  %v1.promoted.i = load i64, ptr %v1.i, align 8
  %H.promoted.i = load i64, ptr %H, align 8
  %v2.promoted.i = load i64, ptr %v2.i, align 8
  br label %for.body.i

for.body.i:                                       ; preds = %for.body.i, %if.end
  %or5040.i = phi i64 [ %v2.promoted.i, %if.end ], [ %or50.i, %for.body.i ]
  %xor3339.i = phi i64 [ %xor, %if.end ], [ %xor33.i, %for.body.i ]
  %add2438.i = phi i64 [ %H.promoted.i, %if.end ], [ %add24.i, %for.body.i ]
  %xor4537.i = phi i64 [ %v1.promoted.i, %if.end ], [ %xor45.i, %for.body.i ]
  %i.036.i = phi i32 [ 0, %if.end ], [ %inc.i, %for.body.i ]
  %add.i = add i64 %xor4537.i, %add2438.i
  %or.i = tail call i64 @llvm.fshl.i64(i64 %xor4537.i, i64 %xor4537.i, i64 13)
  %xor.i = xor i64 %add.i, %or.i
  %or10.i = tail call i64 @llvm.fshl.i64(i64 %add.i, i64 %add.i, i64 32)
  %add12.i = add i64 %xor3339.i, %or5040.i
  %or17.i = tail call i64 @llvm.fshl.i64(i64 %xor3339.i, i64 %xor3339.i, i64 16)
  %xor21.i = xor i64 %add12.i, %or17.i
  %add24.i = add i64 %or10.i, %xor21.i
  %or29.i = tail call i64 @llvm.fshl.i64(i64 %xor21.i, i64 %xor21.i, i64 21)
  %xor33.i = xor i64 %add24.i, %or29.i
  %add36.i = add i64 %xor.i, %add12.i
  %or41.i = tail call i64 @llvm.fshl.i64(i64 %xor.i, i64 %xor.i, i64 17)
  %xor45.i = xor i64 %add36.i, %or41.i
  %or50.i = tail call i64 @llvm.fshl.i64(i64 %add36.i, i64 %add36.i, i64 32)
  %inc.i = add nuw nsw i32 %i.036.i, 1
  %exitcond.not.i = icmp eq i32 %inc.i, 2
  br i1 %exitcond.not.i, label %sip_round.exit, label %for.body.i, !llvm.loop !53

sip_round.exit:                                   ; preds = %for.body.i
  store i64 %xor45.i, ptr %v1.i, align 8
  store i64 %xor33.i, ptr %v3, align 8
  store i64 %or50.i, ptr %v2.i, align 8
  %xor45 = xor i64 %add24.i, %or44
  store i64 %xor45, ptr %H, align 8
  store ptr %buf6, ptr %p1, align 8
  %10 = load i64, ptr %c, align 8
  %add = add i64 %10, 8
  store i64 %add, ptr %c, align 8
  br i1 %cmp.lcssa, label %do.body, label %do.end, !llvm.loop !54

do.end:                                           ; preds = %while.end, %sip_round.exit
  ret ptr %H
}

; Function Attrs: nofree nosync nounwind memory(argmem: readwrite) uwtable
define internal fastcc i64 @sip24_final(ptr noundef %H) unnamed_addr #15 {
entry:
  %p = getelementptr inbounds %struct.siphash, ptr %H, i64 0, i32 5
  %0 = load ptr, ptr %p, align 8
  %buf = getelementptr inbounds %struct.siphash, ptr %H, i64 0, i32 4
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %buf to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv = trunc i64 %sub.ptr.sub to i32
  %c = getelementptr inbounds %struct.siphash, ptr %H, i64 0, i32 6
  %1 = load i64, ptr %c, align 8
  %add = add i64 %sub.ptr.sub, %1
  %shl = shl i64 %add, 56
  %sext = shl i32 %conv, 24
  %conv2 = ashr exact i32 %sext, 24
  switch i32 %conv2, label %sw.epilog [
    i32 7, label %sw.bb
    i32 6, label %sw.bb6
    i32 5, label %sw.bb12
    i32 4, label %sw.bb18
    i32 3, label %sw.bb24
    i32 2, label %sw.bb30
    i32 1, label %sw.bb36
  ]

sw.bb:                                            ; preds = %entry
  %arrayidx = getelementptr %struct.siphash, ptr %H, i64 0, i32 4, i64 6
  %2 = load i8, ptr %arrayidx, align 2
  %conv4 = zext i8 %2 to i64
  %shl5 = shl nuw nsw i64 %conv4, 48
  %or = or disjoint i64 %shl5, %shl
  br label %sw.bb6

sw.bb6:                                           ; preds = %sw.bb, %entry
  %b.0 = phi i64 [ %shl, %entry ], [ %or, %sw.bb ]
  %arrayidx8 = getelementptr %struct.siphash, ptr %H, i64 0, i32 4, i64 5
  %3 = load i8, ptr %arrayidx8, align 1
  %conv9 = zext i8 %3 to i64
  %shl10 = shl nuw nsw i64 %conv9, 40
  %or11 = or i64 %shl10, %b.0
  br label %sw.bb12

sw.bb12:                                          ; preds = %sw.bb6, %entry
  %b.1 = phi i64 [ %shl, %entry ], [ %or11, %sw.bb6 ]
  %arrayidx14 = getelementptr %struct.siphash, ptr %H, i64 0, i32 4, i64 4
  %4 = load i8, ptr %arrayidx14, align 4
  %conv15 = zext i8 %4 to i64
  %shl16 = shl nuw nsw i64 %conv15, 32
  %or17 = or i64 %shl16, %b.1
  br label %sw.bb18

sw.bb18:                                          ; preds = %sw.bb12, %entry
  %b.2 = phi i64 [ %shl, %entry ], [ %or17, %sw.bb12 ]
  %arrayidx20 = getelementptr %struct.siphash, ptr %H, i64 0, i32 4, i64 3
  %5 = load i8, ptr %arrayidx20, align 1
  %conv21 = zext i8 %5 to i64
  %shl22 = shl nuw nsw i64 %conv21, 24
  %or23 = or i64 %shl22, %b.2
  br label %sw.bb24

sw.bb24:                                          ; preds = %sw.bb18, %entry
  %b.3 = phi i64 [ %shl, %entry ], [ %or23, %sw.bb18 ]
  %arrayidx26 = getelementptr %struct.siphash, ptr %H, i64 0, i32 4, i64 2
  %6 = load i8, ptr %arrayidx26, align 2
  %conv27 = zext i8 %6 to i64
  %shl28 = shl nuw nsw i64 %conv27, 16
  %or29 = or i64 %shl28, %b.3
  br label %sw.bb30

sw.bb30:                                          ; preds = %sw.bb24, %entry
  %b.4 = phi i64 [ %shl, %entry ], [ %or29, %sw.bb24 ]
  %arrayidx32 = getelementptr %struct.siphash, ptr %H, i64 0, i32 4, i64 1
  %7 = load i8, ptr %arrayidx32, align 1
  %conv33 = zext i8 %7 to i64
  %shl34 = shl nuw nsw i64 %conv33, 8
  %or35 = or i64 %shl34, %b.4
  br label %sw.bb36

sw.bb36:                                          ; preds = %sw.bb30, %entry
  %b.5 = phi i64 [ %shl, %entry ], [ %or35, %sw.bb30 ]
  %8 = load i8, ptr %buf, align 8
  %conv39 = zext i8 %8 to i64
  %or41 = or i64 %b.5, %conv39
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb36, %entry
  %b.6 = phi i64 [ %shl, %entry ], [ %or41, %sw.bb36 ]
  %v3 = getelementptr inbounds %struct.siphash, ptr %H, i64 0, i32 3
  %9 = load i64, ptr %v3, align 8
  %xor = xor i64 %9, %b.6
  %v1.i = getelementptr inbounds %struct.siphash, ptr %H, i64 0, i32 1
  %v2.i = getelementptr inbounds %struct.siphash, ptr %H, i64 0, i32 2
  %v1.promoted.i = load i64, ptr %v1.i, align 8
  %H.promoted.i = load i64, ptr %H, align 8
  %v2.promoted.i = load i64, ptr %v2.i, align 8
  br label %for.body.i

for.body.i:                                       ; preds = %for.body.i, %sw.epilog
  %or5040.i = phi i64 [ %v2.promoted.i, %sw.epilog ], [ %or50.i, %for.body.i ]
  %xor3339.i = phi i64 [ %xor, %sw.epilog ], [ %xor33.i, %for.body.i ]
  %add2438.i = phi i64 [ %H.promoted.i, %sw.epilog ], [ %add24.i, %for.body.i ]
  %xor4537.i = phi i64 [ %v1.promoted.i, %sw.epilog ], [ %xor45.i, %for.body.i ]
  %i.036.i = phi i32 [ 0, %sw.epilog ], [ %inc.i, %for.body.i ]
  %add.i = add i64 %xor4537.i, %add2438.i
  %or.i = tail call i64 @llvm.fshl.i64(i64 %xor4537.i, i64 %xor4537.i, i64 13)
  %xor.i = xor i64 %add.i, %or.i
  %or10.i = tail call i64 @llvm.fshl.i64(i64 %add.i, i64 %add.i, i64 32)
  %add12.i = add i64 %xor3339.i, %or5040.i
  %or17.i = tail call i64 @llvm.fshl.i64(i64 %xor3339.i, i64 %xor3339.i, i64 16)
  %xor21.i = xor i64 %add12.i, %or17.i
  %add24.i = add i64 %or10.i, %xor21.i
  %or29.i = tail call i64 @llvm.fshl.i64(i64 %xor21.i, i64 %xor21.i, i64 21)
  %xor33.i = xor i64 %add24.i, %or29.i
  %add36.i = add i64 %xor.i, %add12.i
  %or41.i = tail call i64 @llvm.fshl.i64(i64 %xor.i, i64 %xor.i, i64 17)
  %xor45.i = xor i64 %add36.i, %or41.i
  %or50.i = tail call i64 @llvm.fshl.i64(i64 %add36.i, i64 %add36.i, i64 32)
  %inc.i = add nuw nsw i32 %i.036.i, 1
  %exitcond.not.i = icmp eq i32 %inc.i, 2
  br i1 %exitcond.not.i, label %sip_round.exit, label %for.body.i, !llvm.loop !53

sip_round.exit:                                   ; preds = %for.body.i
  %xor43 = xor i64 %add24.i, %b.6
  %xor44 = xor i64 %or50.i, 255
  br label %for.body.i35

for.body.i35:                                     ; preds = %for.body.i35, %sip_round.exit
  %or5040.i36 = phi i64 [ %xor44, %sip_round.exit ], [ %or50.i54, %for.body.i35 ]
  %xor3339.i37 = phi i64 [ %xor33.i, %sip_round.exit ], [ %xor33.i50, %for.body.i35 ]
  %add2438.i38 = phi i64 [ %xor43, %sip_round.exit ], [ %add24.i48, %for.body.i35 ]
  %xor4537.i39 = phi i64 [ %xor45.i, %sip_round.exit ], [ %xor45.i53, %for.body.i35 ]
  %i.036.i40 = phi i32 [ 0, %sip_round.exit ], [ %inc.i55, %for.body.i35 ]
  %add.i41 = add i64 %xor4537.i39, %add2438.i38
  %or.i42 = tail call i64 @llvm.fshl.i64(i64 %xor4537.i39, i64 %xor4537.i39, i64 13)
  %xor.i43 = xor i64 %add.i41, %or.i42
  %or10.i44 = tail call i64 @llvm.fshl.i64(i64 %add.i41, i64 %add.i41, i64 32)
  %add12.i45 = add i64 %xor3339.i37, %or5040.i36
  %or17.i46 = tail call i64 @llvm.fshl.i64(i64 %xor3339.i37, i64 %xor3339.i37, i64 16)
  %xor21.i47 = xor i64 %add12.i45, %or17.i46
  %add24.i48 = add i64 %or10.i44, %xor21.i47
  %or29.i49 = tail call i64 @llvm.fshl.i64(i64 %xor21.i47, i64 %xor21.i47, i64 21)
  %xor33.i50 = xor i64 %add24.i48, %or29.i49
  %add36.i51 = add i64 %xor.i43, %add12.i45
  %or41.i52 = tail call i64 @llvm.fshl.i64(i64 %xor.i43, i64 %xor.i43, i64 17)
  %xor45.i53 = xor i64 %add36.i51, %or41.i52
  %or50.i54 = tail call i64 @llvm.fshl.i64(i64 %add36.i51, i64 %add36.i51, i64 32)
  %inc.i55 = add nuw nsw i32 %i.036.i40, 1
  %exitcond.not.i56 = icmp eq i32 %inc.i55, 4
  br i1 %exitcond.not.i56, label %sip_round.exit57, label %for.body.i35, !llvm.loop !53

sip_round.exit57:                                 ; preds = %for.body.i35
  store i64 %xor45.i53, ptr %v1.i, align 8
  store i64 %add24.i48, ptr %H, align 8
  store i64 %xor33.i50, ptr %v3, align 8
  store i64 %or50.i54, ptr %v2.i, align 8
  %xor46 = xor i64 %xor45.i53, %add24.i48
  %xor48 = xor i64 %xor46, %or50.i54
  %xor50 = xor i64 %xor48, %xor33.i50
  ret i64 %xor50
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @doContent(ptr noundef %parser, i32 noundef %startTagLevel, ptr noundef %enc, ptr noundef %s, ptr noundef %end, ptr nocapture noundef writeonly %nextPtr, i8 noundef zeroext %haveMore, i32 noundef %account) unnamed_addr #0 {
entry:
  %s.addr.i705 = alloca ptr, align 8
  %dataPtr.i706 = alloca ptr, align 8
  %s.addr.i670 = alloca ptr, align 8
  %dataPtr.i671 = alloca ptr, align 8
  %s.addr.i635 = alloca ptr, align 8
  %dataPtr.i636 = alloca ptr, align 8
  %s.addr.i600 = alloca ptr, align 8
  %dataPtr.i601 = alloca ptr, align 8
  %s.addr.i565 = alloca ptr, align 8
  %dataPtr.i566 = alloca ptr, align 8
  %s.addr.i530 = alloca ptr, align 8
  %dataPtr.i531 = alloca ptr, align 8
  %s.addr.i468 = alloca ptr, align 8
  %dataPtr.i469 = alloca ptr, align 8
  %ptr.addr.i.i430 = alloca ptr, align 8
  %s.addr.i388 = alloca ptr, align 8
  %dataPtr.i389 = alloca ptr, align 8
  %ptr.addr.i.i = alloca ptr, align 8
  %s.addr.i = alloca ptr, align 8
  %dataPtr.i = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %next = alloca ptr, align 8
  %c = alloca i8, align 1
  %ch = alloca i8, align 1
  %toPtr = alloca ptr, align 8
  %fromPtr = alloca ptr, align 8
  %bindings268 = alloca ptr, align 8
  %name269 = alloca %struct.TAG_NAME, align 8
  %buf458 = alloca [4 x i8], align 1
  %c474 = alloca i8, align 1
  %dataPtr = alloca ptr, align 8
  %dataPtr555 = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %m_dtd = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 65
  %0 = load ptr, ptr %m_dtd, align 8
  %m_encoding = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 34
  %1 = load ptr, ptr %m_encoding, align 8
  %cmp = icmp eq ptr %1, %enc
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %m_eventPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 47
  %m_eventEndPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 48
  br label %if.end

if.else:                                          ; preds = %entry
  %m_openInternalEntities = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 50
  %2 = load ptr, ptr %m_openInternalEntities, align 8
  %internalEventEndPtr = getelementptr inbounds %struct.open_internal_entity, ptr %2, i64 0, i32 1
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %eventEndPP.0 = phi ptr [ %m_eventEndPtr, %if.then ], [ %internalEventEndPtr, %if.else ]
  %eventPP.0 = phi ptr [ %m_eventPtr, %if.then ], [ %2, %if.else ]
  store ptr %s, ptr %eventPP.0, align 8
  %arrayidx = getelementptr [4 x ptr], ptr %enc, i64 0, i64 1
  %tobool.not = icmp eq i8 %haveMore, 0
  %m_characterDataHandler548 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 13
  %isUtf8551 = getelementptr inbounds %struct.encoding, ptr %enc, i64 0, i32 13
  %m_handlerArg577 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 1
  %m_dataBuf556 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 9
  %utf8Convert558 = getelementptr inbounds %struct.encoding, ptr %enc, i64 0, i32 10
  %m_dataBufEnd559 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 10
  %m_defaultHandler584 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 18
  %m_openInternalEntities.i685 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 50
  %m_eventPtr.i702 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 47
  %m_eventEndPtr.i703 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 48
  %m_startCdataSectionHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 16
  %charRefNumber = getelementptr inbounds %struct.encoding, ptr %enc, i64 0, i32 6
  %m_tagLevel336 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 53
  %m_tagStack343 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 67
  %minBytesPerChar344 = getelementptr inbounds %struct.encoding, ptr %enc, i64 0, i32 12
  %nameLength347 = getelementptr inbounds %struct.encoding, ptr %enc, i64 0, i32 3
  %m_freeTagList362 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 68
  %m_endElementHandler366 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 12
  %m_ns = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 38
  %m_ns_triplets = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 39
  %m_namespaceSeparator = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 83
  %m_endNamespaceDeclHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 24
  %m_freeBindingList = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 70
  %m_parsingStatus433 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 85
  %m_processor443 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 45
  %m_tempPool270 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 79
  %ptr1.i.i431 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 79, i32 3
  %end4.i.i435 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 79, i32 2
  %start.i.i445 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 79, i32 4
  %m_startElementHandler294 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 11
  %m_atts300 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 74
  %freeBlocks.i503 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 79, i32 1
  %m_mem = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 3
  %realloc_fcn = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 3, i32 1
  %predefinedEntityName = getelementptr inbounds %struct.encoding, ptr %enc, i64 0, i32 7
  %add.ptr61 = getelementptr inbounds i8, ptr %ch, i64 1
  %pool = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 4
  %ptr1.i.i = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 4, i32 3
  %end4.i.i = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 4, i32 2
  %start.i.i = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 4, i32 4
  %size.i = getelementptr inbounds %struct.HASH_TABLE, ptr %0, i64 0, i32 2
  %power30.i = getelementptr inbounds %struct.HASH_TABLE, ptr %0, i64 0, i32 1
  %hasParamEntityRefs = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 7
  %standalone = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 8
  %m_skippedEntityHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 28
  %m_defaultExpandInternalEntities = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 52
  %m_externalEntityRefHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 26
  %m_externalEntityRefHandlerArg = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 27
  br label %for.cond

for.cond:                                         ; preds = %sw.epilog, %if.end
  %3 = load ptr, ptr %s.addr, align 8
  store ptr %3, ptr %next, align 8
  %4 = load ptr, ptr %arrayidx, align 8
  %call = call i32 %4(ptr noundef %enc, ptr noundef %3, ptr noundef %end, ptr noundef nonnull %next) #24
  switch i32 %call, label %cond.false5 [
    i32 -3, label %cond.true
    i32 -5, label %cond.true
  ]

cond.true:                                        ; preds = %for.cond, %for.cond
  %5 = load ptr, ptr %s.addr, align 8
  %cond = select i1 %tobool.not, ptr %end, ptr %5
  br label %cond.end6

cond.false5:                                      ; preds = %for.cond
  %6 = load ptr, ptr %next, align 8
  %.pre = load ptr, ptr %s.addr, align 8
  br label %cond.end6

cond.end6:                                        ; preds = %cond.false5, %cond.true
  %7 = phi ptr [ %5, %cond.true ], [ %.pre, %cond.false5 ]
  %cond7 = phi ptr [ %cond, %cond.true ], [ %6, %cond.false5 ]
  %call8 = call fastcc zeroext i8 @accountingDiffTolerated(ptr noundef nonnull %parser, i32 noundef %call, ptr noundef %7, ptr noundef %cond7, i32 noundef 2773, i32 noundef %account), !range !13
  %tobool9.not = icmp eq i8 %call8, 0
  br i1 %tobool9.not, label %while.cond.i.i.i, label %if.end11

while.cond.i.i.i:                                 ; preds = %cond.end6, %while.cond.i.i.i
  %rootParser.0.i.i.i = phi ptr [ %8, %while.cond.i.i.i ], [ %parser, %cond.end6 ]
  %m_parentParser.i.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i.i, i64 0, i32 84
  %8 = load ptr, ptr %m_parentParser.i.i.i, align 8
  %tobool.not.i.i.i = icmp eq ptr %8, null
  br i1 %tobool.not.i.i.i, label %getRootParserOf.exit.i.i, label %while.cond.i.i.i, !llvm.loop !31

getRootParserOf.exit.i.i:                         ; preds = %while.cond.i.i.i
  %debugLevel.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i.i, i64 0, i32 90, i32 2
  %9 = load i32, ptr %debugLevel.i.i, align 8
  %cmp.i.i = icmp slt i32 %9, 1
  br i1 %cmp.i.i, label %return, label %if.end.i.i

if.end.i.i:                                       ; preds = %getRootParserOf.exit.i.i
  %m_accounting.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i.i, i64 0, i32 90
  %10 = load i64, ptr %m_accounting.i.i, align 8
  %tobool.not.i5.i.i = icmp eq i64 %10, 0
  %countBytesIndirect.phi.trans.insert.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i.i, i64 0, i32 90, i32 1
  %.pre.i.i = load i64, ptr %countBytesIndirect.phi.trans.insert.i.i, align 8
  br i1 %tobool.not.i5.i.i, label %accountingGetCurrentAmplification.exit.i.i, label %cond.true.i.i.i

cond.true.i.i.i:                                  ; preds = %if.end.i.i
  %add.i.i.i = add i64 %.pre.i.i, %10
  %conv.i.i.i = uitofp i64 %add.i.i.i to float
  %conv6.i.i.i = uitofp i64 %10 to float
  %div.i.i.i = fdiv float %conv.i.i.i, %conv6.i.i.i
  %11 = fpext float %div.i.i.i to double
  br label %accountingGetCurrentAmplification.exit.i.i

accountingGetCurrentAmplification.exit.i.i:       ; preds = %cond.true.i.i.i, %if.end.i.i
  %cond.i.i.i = phi double [ %11, %cond.true.i.i.i ], [ 1.000000e+00, %if.end.i.i ]
  %12 = load ptr, ptr @stderr, align 8
  %call4.i.i = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %12, ptr noundef nonnull @.str.311, ptr noundef nonnull %rootParser.0.i.i.i, i64 noundef %10, i64 noundef %.pre.i.i, double noundef %cond.i.i.i, ptr noundef nonnull @.str.317) #27
  br label %return

if.end11:                                         ; preds = %cond.end6
  %13 = load ptr, ptr %next, align 8
  store ptr %13, ptr %eventEndPP.0, align 8
  switch i32 %call, label %sw.default [
    i32 -3, label %sw.bb
    i32 -4, label %sw.bb31
    i32 0, label %sw.bb44
    i32 -1, label %sw.bb45
    i32 -2, label %sw.bb49
    i32 9, label %sw.bb53
    i32 2, label %sw.bb168
    i32 1, label %sw.bb168
    i32 4, label %sw.bb262
    i32 3, label %sw.bb262
    i32 5, label %sw.bb335
    i32 10, label %sw.bb449
    i32 12, label %return
    i32 7, label %sw.bb470
    i32 8, label %sw.bb483
    i32 -5, label %sw.bb505
    i32 6, label %sw.bb547
    i32 11, label %sw.bb589
    i32 13, label %sw.bb594
  ]

sw.bb:                                            ; preds = %if.end11
  br i1 %tobool.not, label %if.end14, label %if.then13

if.then13:                                        ; preds = %sw.bb
  %14 = load ptr, ptr %s.addr, align 8
  store ptr %14, ptr %nextPtr, align 8
  br label %return

if.end14:                                         ; preds = %sw.bb
  store ptr %end, ptr %eventEndPP.0, align 8
  %15 = load ptr, ptr %m_characterDataHandler548, align 8
  %tobool15.not = icmp eq ptr %15, null
  br i1 %tobool15.not, label %if.else18, label %if.then16

if.then16:                                        ; preds = %if.end14
  store i8 10, ptr %c, align 1
  %16 = load ptr, ptr %m_handlerArg577, align 8
  call void %15(ptr noundef %16, ptr noundef nonnull %c, i32 noundef 1) #24
  br label %if.end22

if.else18:                                        ; preds = %if.end14
  %17 = load ptr, ptr %m_defaultHandler584, align 8
  %tobool19.not = icmp eq ptr %17, null
  br i1 %tobool19.not, label %if.end22, label %if.then20

if.then20:                                        ; preds = %if.else18
  %18 = load ptr, ptr %s.addr, align 8
  call fastcc void @reportDefault(ptr noundef nonnull %parser, ptr noundef nonnull %enc, ptr noundef %18, ptr noundef %end)
  br label %if.end22

if.end22:                                         ; preds = %if.else18, %if.then20, %if.then16
  %cmp23 = icmp eq i32 %startTagLevel, 0
  br i1 %cmp23, label %return, label %if.end26

if.end26:                                         ; preds = %if.end22
  %19 = load i32, ptr %m_tagLevel336, align 4
  %cmp27.not = icmp eq i32 %19, %startTagLevel
  br i1 %cmp27.not, label %if.end30, label %return

if.end30:                                         ; preds = %if.end26
  store ptr %end, ptr %nextPtr, align 8
  br label %return

sw.bb31:                                          ; preds = %if.end11
  br i1 %tobool.not, label %if.end34, label %if.then33

if.then33:                                        ; preds = %sw.bb31
  %20 = load ptr, ptr %s.addr, align 8
  store ptr %20, ptr %nextPtr, align 8
  br label %return

if.end34:                                         ; preds = %sw.bb31
  %cmp35 = icmp sgt i32 %startTagLevel, 0
  br i1 %cmp35, label %if.then37, label %return

if.then37:                                        ; preds = %if.end34
  %21 = load i32, ptr %m_tagLevel336, align 4
  %cmp39.not = icmp eq i32 %21, %startTagLevel
  br i1 %cmp39.not, label %if.end42, label %return

if.end42:                                         ; preds = %if.then37
  %22 = load ptr, ptr %s.addr, align 8
  store ptr %22, ptr %nextPtr, align 8
  br label %return

sw.bb44:                                          ; preds = %if.end11
  store ptr %13, ptr %eventPP.0, align 8
  br label %return

sw.bb45:                                          ; preds = %if.end11
  br i1 %tobool.not, label %return, label %if.then47

if.then47:                                        ; preds = %sw.bb45
  %23 = load ptr, ptr %s.addr, align 8
  store ptr %23, ptr %nextPtr, align 8
  br label %return

sw.bb49:                                          ; preds = %if.end11
  br i1 %tobool.not, label %return, label %if.then51

if.then51:                                        ; preds = %sw.bb49
  %24 = load ptr, ptr %s.addr, align 8
  store ptr %24, ptr %nextPtr, align 8
  br label %return

sw.bb53:                                          ; preds = %if.end11
  %25 = load ptr, ptr %predefinedEntityName, align 8
  %26 = load ptr, ptr %s.addr, align 8
  %27 = load i32, ptr %minBytesPerChar344, align 8
  %idx.ext = sext i32 %27 to i64
  %add.ptr = getelementptr i8, ptr %26, i64 %idx.ext
  %idx.neg = sub nsw i64 0, %idx.ext
  %add.ptr56 = getelementptr i8, ptr %13, i64 %idx.neg
  %call57 = call i32 %25(ptr noundef nonnull %enc, ptr noundef %add.ptr, ptr noundef %add.ptr56) #24
  %conv58 = trunc i32 %call57 to i8
  store i8 %conv58, ptr %ch, align 1
  %tobool59.not = icmp eq i8 %conv58, 0
  br i1 %tobool59.not, label %if.end74, label %if.then60

if.then60:                                        ; preds = %sw.bb53
  %call62 = call fastcc zeroext i8 @accountingDiffTolerated(ptr noundef %parser, i32 noundef 9, ptr noundef nonnull %ch, ptr noundef nonnull %add.ptr61, i32 noundef 2839, i32 noundef 1), !range !13
  %28 = load ptr, ptr %m_characterDataHandler548, align 8
  %tobool64.not = icmp eq ptr %28, null
  br i1 %tobool64.not, label %if.else68, label %if.then65

if.then65:                                        ; preds = %if.then60
  %29 = load ptr, ptr %m_handlerArg577, align 8
  call void %28(ptr noundef %29, ptr noundef nonnull %ch, i32 noundef 1) #24
  br label %sw.epilog

if.else68:                                        ; preds = %if.then60
  %30 = load ptr, ptr %m_defaultHandler584, align 8
  %tobool70.not = icmp eq ptr %30, null
  br i1 %tobool70.not, label %sw.epilog, label %if.then71

if.then71:                                        ; preds = %if.else68
  %31 = load ptr, ptr %s.addr, align 8
  %32 = load ptr, ptr %next, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %s.addr.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %dataPtr.i)
  store ptr %31, ptr %s.addr.i, align 8
  %33 = load i8, ptr %isUtf8551, align 4
  %tobool.not.i = icmp eq i8 %33, 0
  br i1 %tobool.not.i, label %if.then.i, label %if.else9.i

if.then.i:                                        ; preds = %if.then71
  %34 = load ptr, ptr %m_encoding, align 8
  %cmp.i = icmp eq ptr %34, %enc
  br i1 %cmp.i, label %if.end.i, label %if.else.i

if.else.i:                                        ; preds = %if.then.i
  %35 = load ptr, ptr %m_openInternalEntities.i685, align 8
  %internalEventEndPtr.i = getelementptr inbounds %struct.open_internal_entity, ptr %35, i64 0, i32 1
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %if.else.i
  %eventPP.0.i = phi ptr [ %35, %if.else.i ], [ %m_eventPtr.i702, %if.then.i ]
  %eventEndPP.0.i = phi ptr [ %internalEventEndPtr.i, %if.else.i ], [ %m_eventEndPtr.i703, %if.then.i ]
  br label %do.body.i

do.body.i:                                        ; preds = %do.body.i, %if.end.i
  %36 = load ptr, ptr %m_dataBuf556, align 8
  store ptr %36, ptr %dataPtr.i, align 8
  %37 = load ptr, ptr %utf8Convert558, align 8
  %38 = load ptr, ptr %m_dataBufEnd559, align 8
  %call.i = call i32 %37(ptr noundef nonnull %enc, ptr noundef nonnull %s.addr.i, ptr noundef %32, ptr noundef nonnull %dataPtr.i, ptr noundef %38) #24
  %39 = load ptr, ptr %s.addr.i, align 8
  store ptr %39, ptr %eventEndPP.0.i, align 8
  %40 = load ptr, ptr %m_defaultHandler584, align 8
  %41 = load ptr, ptr %m_handlerArg577, align 8
  %42 = load ptr, ptr %m_dataBuf556, align 8
  %43 = load ptr, ptr %dataPtr.i, align 8
  %sub.ptr.lhs.cast.i = ptrtoint ptr %43 to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %42 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %conv.i = trunc i64 %sub.ptr.sub.i to i32
  call void %40(ptr noundef %41, ptr noundef %42, i32 noundef %conv.i) #24
  %44 = load ptr, ptr %s.addr.i, align 8
  store ptr %44, ptr %eventPP.0.i, align 8
  %45 = icmp ugt i32 %call.i, 1
  br i1 %45, label %do.body.i, label %reportDefault.exit, !llvm.loop !28

if.else9.i:                                       ; preds = %if.then71
  %46 = load ptr, ptr %m_handlerArg577, align 8
  %sub.ptr.lhs.cast12.i = ptrtoint ptr %32 to i64
  %sub.ptr.rhs.cast13.i = ptrtoint ptr %31 to i64
  %sub.ptr.sub14.i = sub i64 %sub.ptr.lhs.cast12.i, %sub.ptr.rhs.cast13.i
  %conv15.i = trunc i64 %sub.ptr.sub14.i to i32
  call void %30(ptr noundef %46, ptr noundef %31, i32 noundef %conv15.i) #24
  br label %reportDefault.exit

reportDefault.exit:                               ; preds = %do.body.i, %if.else9.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %s.addr.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %dataPtr.i)
  br label %sw.epilog

if.end74:                                         ; preds = %sw.bb53
  %47 = load ptr, ptr %s.addr, align 8
  %48 = load i32, ptr %minBytesPerChar344, align 8
  %idx.ext76 = sext i32 %48 to i64
  %add.ptr77 = getelementptr i8, ptr %47, i64 %idx.ext76
  %49 = load ptr, ptr %next, align 8
  %idx.neg80 = sub nsw i64 0, %idx.ext76
  %add.ptr81 = getelementptr i8, ptr %49, i64 %idx.neg80
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ptr.addr.i.i)
  store ptr %add.ptr77, ptr %ptr.addr.i.i, align 8
  %50 = load ptr, ptr %ptr1.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %50, null
  br i1 %tobool.not.i.i, label %land.lhs.true.i.i, label %for.cond.i.i.preheader

land.lhs.true.i.i:                                ; preds = %if.end74
  %call.i.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool), !range !13
  %tobool2.not.i.i = icmp eq i8 %call.i.i, 0
  br i1 %tobool2.not.i.i, label %poolAppend.exit.thread.i, label %for.cond.i.i.preheader

for.cond.i.i.preheader:                           ; preds = %land.lhs.true.i.i, %if.end74
  br label %for.cond.i.i

for.cond.i.i:                                     ; preds = %for.cond.i.i.preheader, %if.end8.i.i
  %51 = load ptr, ptr %utf8Convert558, align 8
  %52 = load ptr, ptr %end4.i.i, align 8
  %call5.i.i = call i32 %51(ptr noundef nonnull %enc, ptr noundef nonnull %ptr.addr.i.i, ptr noundef %add.ptr81, ptr noundef nonnull %ptr1.i.i, ptr noundef %52) #24
  %or.cond.i.i = icmp ult i32 %call5.i.i, 2
  br i1 %or.cond.i.i, label %poolAppend.exit.i, label %if.end8.i.i

if.end8.i.i:                                      ; preds = %for.cond.i.i
  %call9.i.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool), !range !13
  %tobool10.not.i.i = icmp eq i8 %call9.i.i, 0
  br i1 %tobool10.not.i.i, label %poolAppend.exit.thread.i, label %for.cond.i.i

poolAppend.exit.thread.i:                         ; preds = %land.lhs.true.i.i, %if.end8.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i)
  br label %return

poolAppend.exit.i:                                ; preds = %for.cond.i.i
  %53 = load ptr, ptr %start.i.i, align 8
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i)
  %tobool.not.i368 = icmp eq ptr %53, null
  br i1 %tobool.not.i368, label %return, label %if.end.i369

if.end.i369:                                      ; preds = %poolAppend.exit.i
  %54 = load ptr, ptr %ptr1.i.i, align 8
  %55 = load ptr, ptr %end4.i.i, align 8
  %cmp.i370 = icmp eq ptr %54, %55
  br i1 %cmp.i370, label %land.lhs.true.i, label %poolStoreString.exit

land.lhs.true.i:                                  ; preds = %if.end.i369
  %call3.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool), !range !13
  %tobool4.not.i = icmp eq i8 %call3.i, 0
  br i1 %tobool4.not.i, label %return, label %land.lhs.true.if.end6_crit_edge.i

land.lhs.true.if.end6_crit_edge.i:                ; preds = %land.lhs.true.i
  %.pre.i = load ptr, ptr %ptr1.i.i, align 8
  br label %poolStoreString.exit

poolStoreString.exit:                             ; preds = %if.end.i369, %land.lhs.true.if.end6_crit_edge.i
  %56 = phi ptr [ %.pre.i, %land.lhs.true.if.end6_crit_edge.i ], [ %54, %if.end.i369 ]
  %incdec.ptr.i = getelementptr i8, ptr %56, i64 1
  store ptr %incdec.ptr.i, ptr %ptr1.i.i, align 8
  store i8 0, ptr %56, align 1
  %57 = load ptr, ptr %start.i.i, align 8
  %tobool83.not = icmp eq ptr %57, null
  br i1 %tobool83.not, label %return, label %if.end85

if.end85:                                         ; preds = %poolStoreString.exit
  %58 = load i64, ptr %size.i, align 8
  %cmp.i371 = icmp eq i64 %58, 0
  br i1 %cmp.i371, label %lookup.exit, label %if.else.i372

if.else.i372:                                     ; preds = %if.end85
  %call12.i = call fastcc i64 @hash(ptr noundef %parser, ptr noundef nonnull %57)
  %59 = load i64, ptr %size.i, align 8
  %sub14.i = add i64 %59, -1
  %and15.i = and i64 %sub14.i, %call12.i
  %60 = load ptr, ptr %0, align 8
  %arrayidx111.i = getelementptr ptr, ptr %60, i64 %and15.i
  %61 = load ptr, ptr %arrayidx111.i, align 8
  %tobool17.not112.i = icmp eq ptr %61, null
  br i1 %tobool17.not112.i, label %lookup.exit, label %while.body.lr.ph.i

while.body.lr.ph.i:                               ; preds = %if.else.i372
  %62 = load i8, ptr %57, align 1
  %not.i = sub i64 0, %59
  %and29.i = and i64 %call12.i, %not.i
  %shr32.i = lshr i64 %sub14.i, 2
  br label %while.body.i

while.body.i:                                     ; preds = %if.end35.i, %while.body.lr.ph.i
  %63 = phi ptr [ %61, %while.body.lr.ph.i ], [ %71, %if.end35.i ]
  %i.0114.i = phi i64 [ %and15.i, %while.body.lr.ph.i ], [ %i.1.i, %if.end35.i ]
  %step.0113.i = phi i8 [ 0, %while.body.lr.ph.i ], [ %step.1.i, %if.end35.i ]
  %64 = load ptr, ptr %63, align 8
  %65 = load i8, ptr %64, align 1
  %cmp5.i.i = icmp eq i8 %62, %65
  br i1 %cmp5.i.i, label %for.body.i.i, label %if.end26.i

for.body.i.i:                                     ; preds = %while.body.i, %for.inc.i.i
  %66 = phi i8 [ %67, %for.inc.i.i ], [ %62, %while.body.i ]
  %s2.addr.07.i.i = phi ptr [ %incdec.ptr6.i.i, %for.inc.i.i ], [ %64, %while.body.i ]
  %s1.addr.06.i.i = phi ptr [ %incdec.ptr.i.i, %for.inc.i.i ], [ %57, %while.body.i ]
  %cmp4.i.i = icmp eq i8 %66, 0
  br i1 %cmp4.i.i, label %lookup.exit, label %for.inc.i.i

for.inc.i.i:                                      ; preds = %for.body.i.i
  %incdec.ptr.i.i = getelementptr i8, ptr %s1.addr.06.i.i, i64 1
  %incdec.ptr6.i.i = getelementptr i8, ptr %s2.addr.07.i.i, i64 1
  %67 = load i8, ptr %incdec.ptr.i.i, align 1
  %68 = load i8, ptr %incdec.ptr6.i.i, align 1
  %cmp.i.i375 = icmp eq i8 %67, %68
  br i1 %cmp.i.i375, label %for.body.i.i, label %if.end26.i, !llvm.loop !14

if.end26.i:                                       ; preds = %for.inc.i.i, %while.body.i
  %tobool27.not.i = icmp eq i8 %step.0113.i, 0
  br i1 %tobool27.not.i, label %if.then28.i, label %if.end35.i

if.then28.i:                                      ; preds = %if.end26.i
  %69 = load i8, ptr %power30.i, align 8
  %conv.i374 = zext i8 %69 to i64
  %sub31.i = add nuw nsw i64 %conv.i374, 4294967295
  %sh_prom.i = and i64 %sub31.i, 4294967295
  %shr.i = lshr i64 %and29.i, %sh_prom.i
  %and33.i = and i64 %shr.i, %shr32.i
  %70 = trunc i64 %and33.i to i8
  %conv34.i = or i8 %70, 1
  br label %if.end35.i

if.end35.i:                                       ; preds = %if.then28.i, %if.end26.i
  %step.1.i = phi i8 [ %step.0113.i, %if.end26.i ], [ %conv34.i, %if.then28.i ]
  %conv36.i = zext i8 %step.1.i to i64
  %cmp37.i = icmp ult i64 %i.0114.i, %conv36.i
  %i.1.p.v.i = select i1 %cmp37.i, i64 %59, i64 0
  %i.1.p.i = sub i64 %i.0114.i, %conv36.i
  %i.1.i = add i64 %i.1.p.v.i, %i.1.p.i
  %arrayidx.i = getelementptr ptr, ptr %60, i64 %i.1.i
  %71 = load ptr, ptr %arrayidx.i, align 8
  %tobool17.not.i = icmp eq ptr %71, null
  br i1 %tobool17.not.i, label %lookup.exit, label %while.body.i, !llvm.loop !15

lookup.exit:                                      ; preds = %if.end35.i, %for.body.i.i, %if.else.i372, %if.end85
  %retval.0.i373 = phi ptr [ null, %if.end85 ], [ null, %if.else.i372 ], [ %63, %for.body.i.i ], [ null, %if.end35.i ]
  %72 = load ptr, ptr %start.i.i, align 8
  store ptr %72, ptr %ptr1.i.i, align 8
  %73 = load i8, ptr %hasParamEntityRefs, align 1
  %tobool89.not = icmp eq i8 %73, 0
  br i1 %tobool89.not, label %if.then93, label %lor.lhs.false90

lor.lhs.false90:                                  ; preds = %lookup.exit
  %74 = load i8, ptr %standalone, align 2
  %tobool92.not = icmp eq i8 %74, 0
  br i1 %tobool92.not, label %if.else101, label %if.then93

if.then93:                                        ; preds = %lor.lhs.false90, %lookup.exit
  %tobool94.not = icmp eq ptr %retval.0.i373, null
  br i1 %tobool94.not, label %return, label %if.else96

if.else96:                                        ; preds = %if.then93
  %is_internal = getelementptr inbounds %struct.ENTITY, ptr %retval.0.i373, i64 0, i32 10
  %75 = load i8, ptr %is_internal, align 2
  %tobool97.not = icmp eq i8 %75, 0
  br i1 %tobool97.not, label %return, label %if.end115

if.else101:                                       ; preds = %lor.lhs.false90
  %tobool102.not = icmp eq ptr %retval.0.i373, null
  br i1 %tobool102.not, label %if.then103, label %if.end115

if.then103:                                       ; preds = %if.else101
  %76 = load ptr, ptr %m_skippedEntityHandler, align 8
  %tobool104.not = icmp eq ptr %76, null
  br i1 %tobool104.not, label %if.else108, label %if.then105

if.then105:                                       ; preds = %if.then103
  %77 = load ptr, ptr %m_handlerArg577, align 8
  call void %76(ptr noundef %77, ptr noundef nonnull %57, i32 noundef 0) #24
  br label %sw.epilog

if.else108:                                       ; preds = %if.then103
  %78 = load ptr, ptr %m_defaultHandler584, align 8
  %tobool110.not = icmp eq ptr %78, null
  br i1 %tobool110.not, label %sw.epilog, label %if.then111

if.then111:                                       ; preds = %if.else108
  %79 = load ptr, ptr %s.addr, align 8
  %80 = load ptr, ptr %next, align 8
  call fastcc void @reportDefault(ptr noundef nonnull %parser, ptr noundef %enc, ptr noundef %79, ptr noundef %80)
  br label %sw.epilog

if.end115:                                        ; preds = %if.else101, %if.else96
  %open = getelementptr inbounds %struct.ENTITY, ptr %retval.0.i373, i64 0, i32 8
  %81 = load i8, ptr %open, align 8
  %tobool116.not = icmp eq i8 %81, 0
  br i1 %tobool116.not, label %if.end118, label %return

if.end118:                                        ; preds = %if.end115
  %notation = getelementptr inbounds %struct.ENTITY, ptr %retval.0.i373, i64 0, i32 7
  %82 = load ptr, ptr %notation, align 8
  %tobool119.not = icmp eq ptr %82, null
  br i1 %tobool119.not, label %if.end121, label %return

if.end121:                                        ; preds = %if.end118
  %textPtr = getelementptr inbounds %struct.ENTITY, ptr %retval.0.i373, i64 0, i32 1
  %83 = load ptr, ptr %textPtr, align 8
  %tobool122.not = icmp eq ptr %83, null
  br i1 %tobool122.not, label %if.else144, label %if.then123

if.then123:                                       ; preds = %if.end121
  %84 = load i8, ptr %m_defaultExpandInternalEntities, align 8
  %tobool124.not = icmp eq i8 %84, 0
  br i1 %tobool124.not, label %if.then125, label %if.end138

if.then125:                                       ; preds = %if.then123
  %85 = load ptr, ptr %m_skippedEntityHandler, align 8
  %tobool127.not = icmp eq ptr %85, null
  br i1 %tobool127.not, label %if.else132, label %if.then128

if.then128:                                       ; preds = %if.then125
  %86 = load ptr, ptr %m_handlerArg577, align 8
  %87 = load ptr, ptr %retval.0.i373, align 8
  call void %85(ptr noundef %86, ptr noundef %87, i32 noundef 0) #24
  br label %sw.epilog

if.else132:                                       ; preds = %if.then125
  %88 = load ptr, ptr %m_defaultHandler584, align 8
  %tobool134.not = icmp eq ptr %88, null
  br i1 %tobool134.not, label %sw.epilog, label %if.then135

if.then135:                                       ; preds = %if.else132
  %89 = load ptr, ptr %s.addr, align 8
  %90 = load ptr, ptr %next, align 8
  call fastcc void @reportDefault(ptr noundef nonnull %parser, ptr noundef %enc, ptr noundef %89, ptr noundef %90)
  br label %sw.epilog

if.end138:                                        ; preds = %if.then123
  %call139 = call fastcc i32 @processInternalEntity(ptr noundef nonnull %parser, ptr noundef nonnull %retval.0.i373, i8 noundef zeroext 0)
  %cmp140.not = icmp eq i32 %call139, 0
  br i1 %cmp140.not, label %sw.epilog, label %return

if.else144:                                       ; preds = %if.end121
  %91 = load ptr, ptr %m_externalEntityRefHandler, align 8
  %tobool145.not = icmp eq ptr %91, null
  br i1 %tobool145.not, label %if.else161, label %if.then146

if.then146:                                       ; preds = %if.else144
  store i8 1, ptr %open, align 8
  %92 = load ptr, ptr %m_dtd, align 8
  %binding.i = getelementptr inbounds %struct.DTD, ptr %92, i64 0, i32 11, i32 1
  %93 = load ptr, ptr %binding.i, align 8
  %tobool.not.i377 = icmp eq ptr %93, null
  br i1 %tobool.not.i377, label %if.end31.i, label %if.then.i378

if.then.i378:                                     ; preds = %if.then146
  %94 = load ptr, ptr %ptr1.i.i431, align 8
  %95 = load ptr, ptr %end4.i.i435, align 8
  %cmp.i379 = icmp eq ptr %94, %95
  br i1 %cmp.i379, label %land.lhs.true.i385, label %cond.false.i

land.lhs.true.i385:                               ; preds = %if.then.i378
  %call.i386 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool270), !range !13
  %tobool3.not.i = icmp eq i8 %call.i386, 0
  br i1 %tobool3.not.i, label %getContext.exit.thread, label %land.lhs.true.cond.false_crit_edge.i

land.lhs.true.cond.false_crit_edge.i:             ; preds = %land.lhs.true.i385
  %.pre.i387 = load ptr, ptr %ptr1.i.i431, align 8
  br label %cond.false.i

cond.false.i:                                     ; preds = %land.lhs.true.cond.false_crit_edge.i, %if.then.i378
  %96 = phi ptr [ %.pre.i387, %land.lhs.true.cond.false_crit_edge.i ], [ %94, %if.then.i378 ]
  %incdec.ptr.i380 = getelementptr i8, ptr %96, i64 1
  store ptr %incdec.ptr.i380, ptr %ptr1.i.i431, align 8
  store i8 61, ptr %96, align 1
  %97 = load ptr, ptr %binding.i, align 8
  %uriLen.i = getelementptr inbounds %struct.binding, ptr %97, i64 0, i32 5
  %98 = load i32, ptr %uriLen.i, align 8
  %99 = load i8, ptr %m_namespaceSeparator, align 4
  %tobool9.not.i = icmp ne i8 %99, 0
  %dec.i = sext i1 %tobool9.not.i to i32
  %spec.select.i = add i32 %98, %dec.i
  %cmp1297.i = icmp sgt i32 %spec.select.i, 0
  br i1 %cmp1297.i, label %for.body.preheader.i, label %if.end31.i

for.body.preheader.i:                             ; preds = %cond.false.i
  %wide.trip.count.i = zext nneg i32 %spec.select.i to i64
  br label %for.body.i

for.body.i:                                       ; preds = %cond.false23.i, %for.body.preheader.i
  %indvars.iv.i = phi i64 [ 0, %for.body.preheader.i ], [ %indvars.iv.next.i, %cond.false23.i ]
  %100 = load ptr, ptr %ptr1.i.i431, align 8
  %101 = load ptr, ptr %end4.i.i435, align 8
  %cmp17.i = icmp eq ptr %100, %101
  br i1 %cmp17.i, label %land.lhs.true18.i, label %cond.false23.i

land.lhs.true18.i:                                ; preds = %for.body.i
  %call20.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool270), !range !13
  %tobool21.not.i = icmp eq i8 %call20.i, 0
  br i1 %tobool21.not.i, label %getContext.exit.thread, label %land.lhs.true18.cond.false23_crit_edge.i

land.lhs.true18.cond.false23_crit_edge.i:         ; preds = %land.lhs.true18.i
  %.pre121.i = load ptr, ptr %ptr1.i.i431, align 8
  br label %cond.false23.i

cond.false23.i:                                   ; preds = %land.lhs.true18.cond.false23_crit_edge.i, %for.body.i
  %102 = phi ptr [ %.pre121.i, %land.lhs.true18.cond.false23_crit_edge.i ], [ %100, %for.body.i ]
  %103 = load ptr, ptr %binding.i, align 8
  %uri.i = getelementptr inbounds %struct.binding, ptr %103, i64 0, i32 4
  %104 = load ptr, ptr %uri.i, align 8
  %arrayidx.i384 = getelementptr i8, ptr %104, i64 %indvars.iv.i
  %105 = load i8, ptr %arrayidx.i384, align 1
  %incdec.ptr28.i = getelementptr i8, ptr %102, i64 1
  store ptr %incdec.ptr28.i, ptr %ptr1.i.i431, align 8
  store i8 %105, ptr %102, align 1
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next.i, %wide.trip.count.i
  br i1 %exitcond.not.i, label %if.end31.i, label %for.body.i, !llvm.loop !55

if.end31.i:                                       ; preds = %cond.false23.i, %cond.false.i, %if.then146
  %prefixes.i = getelementptr inbounds %struct.DTD, ptr %92, i64 0, i32 3
  %106 = load ptr, ptr %prefixes.i, align 8
  %tobool.not.i.i381 = icmp eq ptr %106, null
  br i1 %tobool.not.i.i381, label %hashTableIterInit.exit.i, label %cond.true.i.i

cond.true.i.i:                                    ; preds = %if.end31.i
  %size.i.i = getelementptr inbounds %struct.DTD, ptr %92, i64 0, i32 3, i32 2
  %107 = load i64, ptr %size.i.i, align 8
  %add.ptr.i.i = getelementptr ptr, ptr %106, i64 %107
  br label %hashTableIterInit.exit.i

hashTableIterInit.exit.i:                         ; preds = %cond.true.i.i, %if.end31.i
  %cond.i.i = phi ptr [ %add.ptr.i.i, %cond.true.i.i ], [ null, %if.end31.i ]
  br label %for.cond32.outer.i

for.cond32.outer.i:                               ; preds = %for.cond32.outer.i.backedge, %hashTableIterInit.exit.i
  %iter.sroa.0.0.ph.i = phi ptr [ %106, %hashTableIterInit.exit.i ], [ %incdec.ptr.i.i382, %for.cond32.outer.i.backedge ]
  %needSep.1.ph.i = phi i1 [ %tobool.not.i377, %hashTableIterInit.exit.i ], [ false, %for.cond32.outer.i.backedge ]
  br label %while.cond.i.i

while.cond.i.i:                                   ; preds = %while.cond.i.i.backedge, %for.cond32.outer.i
  %incdec.ptr5.i.i = phi ptr [ %iter.sroa.0.0.ph.i, %for.cond32.outer.i ], [ %incdec.ptr.i.i382, %while.cond.i.i.backedge ]
  %cmp.not.i.i = icmp eq ptr %incdec.ptr5.i.i, %cond.i.i
  br i1 %cmp.not.i.i, label %for.end137.i, label %while.body.i.i

while.body.i.i:                                   ; preds = %while.cond.i.i
  %incdec.ptr.i.i382 = getelementptr ptr, ptr %incdec.ptr5.i.i, i64 1
  %108 = load ptr, ptr %incdec.ptr5.i.i, align 8
  %tobool.not.i63.i = icmp eq ptr %108, null
  br i1 %tobool.not.i63.i, label %while.cond.i.i.backedge, label %if.end38.i

while.cond.i.i.backedge:                          ; preds = %while.body.i.i, %if.end38.i
  br label %while.cond.i.i, !llvm.loop !9

if.end38.i:                                       ; preds = %while.body.i.i
  %binding39.i = getelementptr inbounds %struct.prefix, ptr %108, i64 0, i32 1
  %109 = load ptr, ptr %binding39.i, align 8
  %tobool40.not.i = icmp eq ptr %109, null
  br i1 %tobool40.not.i, label %while.cond.i.i.backedge, label %if.end42.i

if.end42.i:                                       ; preds = %if.end38.i
  %binding39.i.le = getelementptr inbounds %struct.prefix, ptr %108, i64 0, i32 1
  br i1 %needSep.1.ph.i, label %if.end61.i, label %land.lhs.true44.i

land.lhs.true44.i:                                ; preds = %if.end42.i
  %110 = load ptr, ptr %ptr1.i.i431, align 8
  %111 = load ptr, ptr %end4.i.i435, align 8
  %cmp49.i = icmp eq ptr %110, %111
  br i1 %cmp49.i, label %land.lhs.true51.i, label %cond.false56.i

land.lhs.true51.i:                                ; preds = %land.lhs.true44.i
  %call53.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool270), !range !13
  %tobool54.not.i = icmp eq i8 %call53.i, 0
  br i1 %tobool54.not.i, label %getContext.exit.thread, label %land.lhs.true51.cond.false56_crit_edge.i

land.lhs.true51.cond.false56_crit_edge.i:         ; preds = %land.lhs.true51.i
  %.pre122.i = load ptr, ptr %ptr1.i.i431, align 8
  br label %cond.false56.i

cond.false56.i:                                   ; preds = %land.lhs.true51.cond.false56_crit_edge.i, %land.lhs.true44.i
  %112 = phi ptr [ %.pre122.i, %land.lhs.true51.cond.false56_crit_edge.i ], [ %110, %land.lhs.true44.i ]
  %incdec.ptr59.i = getelementptr i8, ptr %112, i64 1
  store ptr %incdec.ptr59.i, ptr %ptr1.i.i431, align 8
  store i8 12, ptr %112, align 1
  br label %if.end61.i

if.end61.i:                                       ; preds = %cond.false56.i, %if.end42.i
  %113 = load ptr, ptr %108, align 8
  %114 = load i8, ptr %113, align 1
  %tobool63.not100.i = icmp eq i8 %114, 0
  br i1 %tobool63.not100.i, label %for.end84.i, label %for.body64.i

for.body64.i:                                     ; preds = %if.end61.i, %cond.false76.i
  %115 = phi i8 [ %120, %cond.false76.i ], [ %114, %if.end61.i ]
  %s.0101.i = phi ptr [ %incdec.ptr83.i, %cond.false76.i ], [ %113, %if.end61.i ]
  %116 = load ptr, ptr %ptr1.i.i431, align 8
  %117 = load ptr, ptr %end4.i.i435, align 8
  %cmp69.i = icmp eq ptr %116, %117
  br i1 %cmp69.i, label %land.lhs.true71.i, label %cond.false76.i

land.lhs.true71.i:                                ; preds = %for.body64.i
  %call73.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool270), !range !13
  %tobool74.not.i = icmp eq i8 %call73.i, 0
  br i1 %tobool74.not.i, label %getContext.exit.thread, label %land.lhs.true71.cond.false76_crit_edge.i

land.lhs.true71.cond.false76_crit_edge.i:         ; preds = %land.lhs.true71.i
  %.pre123.i = load i8, ptr %s.0101.i, align 1
  %.pre124.i = load ptr, ptr %ptr1.i.i431, align 8
  br label %cond.false76.i

cond.false76.i:                                   ; preds = %land.lhs.true71.cond.false76_crit_edge.i, %for.body64.i
  %118 = phi ptr [ %.pre124.i, %land.lhs.true71.cond.false76_crit_edge.i ], [ %116, %for.body64.i ]
  %119 = phi i8 [ %.pre123.i, %land.lhs.true71.cond.false76_crit_edge.i ], [ %115, %for.body64.i ]
  %incdec.ptr79.i = getelementptr i8, ptr %118, i64 1
  store ptr %incdec.ptr79.i, ptr %ptr1.i.i431, align 8
  store i8 %119, ptr %118, align 1
  %incdec.ptr83.i = getelementptr i8, ptr %s.0101.i, i64 1
  %120 = load i8, ptr %incdec.ptr83.i, align 1
  %tobool63.not.i = icmp eq i8 %120, 0
  br i1 %tobool63.not.i, label %for.end84.i, label %for.body64.i, !llvm.loop !56

for.end84.i:                                      ; preds = %cond.false76.i, %if.end61.i
  %121 = load ptr, ptr %ptr1.i.i431, align 8
  %122 = load ptr, ptr %end4.i.i435, align 8
  %cmp89.i = icmp eq ptr %121, %122
  br i1 %cmp89.i, label %land.lhs.true91.i, label %cond.false96.i

land.lhs.true91.i:                                ; preds = %for.end84.i
  %call93.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool270), !range !13
  %tobool94.not.i = icmp eq i8 %call93.i, 0
  br i1 %tobool94.not.i, label %getContext.exit.thread, label %land.lhs.true91.cond.false96_crit_edge.i

land.lhs.true91.cond.false96_crit_edge.i:         ; preds = %land.lhs.true91.i
  %.pre125.i = load ptr, ptr %ptr1.i.i431, align 8
  br label %cond.false96.i

cond.false96.i:                                   ; preds = %land.lhs.true91.cond.false96_crit_edge.i, %for.end84.i
  %123 = phi ptr [ %.pre125.i, %land.lhs.true91.cond.false96_crit_edge.i ], [ %121, %for.end84.i ]
  %incdec.ptr99.i = getelementptr i8, ptr %123, i64 1
  store ptr %incdec.ptr99.i, ptr %ptr1.i.i431, align 8
  store i8 61, ptr %123, align 1
  %124 = load ptr, ptr %binding39.i.le, align 8
  %uriLen103.i = getelementptr inbounds %struct.binding, ptr %124, i64 0, i32 5
  %125 = load i32, ptr %uriLen103.i, align 8
  %126 = load i8, ptr %m_namespaceSeparator, align 4
  %tobool105.not.i = icmp ne i8 %126, 0
  %dec107.i = sext i1 %tobool105.not.i to i32
  %spec.select61.i = add i32 %125, %dec107.i
  %cmp110102.i = icmp sgt i32 %spec.select61.i, 0
  br i1 %cmp110102.i, label %for.body112.preheader.i, label %for.cond32.outer.i.backedge

for.cond32.outer.i.backedge:                      ; preds = %cond.false124.i, %cond.false96.i
  br label %for.cond32.outer.i

for.body112.preheader.i:                          ; preds = %cond.false96.i
  %wide.trip.count119.i = zext nneg i32 %spec.select61.i to i64
  br label %for.body112.i

for.body112.i:                                    ; preds = %cond.false124.i, %for.body112.preheader.i
  %indvars.iv116.i = phi i64 [ 0, %for.body112.preheader.i ], [ %indvars.iv.next117.i, %cond.false124.i ]
  %127 = load ptr, ptr %ptr1.i.i431, align 8
  %128 = load ptr, ptr %end4.i.i435, align 8
  %cmp117.i = icmp eq ptr %127, %128
  br i1 %cmp117.i, label %land.lhs.true119.i, label %cond.false124.i

land.lhs.true119.i:                               ; preds = %for.body112.i
  %call121.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool270), !range !13
  %tobool122.not.i = icmp eq i8 %call121.i, 0
  br i1 %tobool122.not.i, label %getContext.exit.thread, label %land.lhs.true119.cond.false124_crit_edge.i

land.lhs.true119.cond.false124_crit_edge.i:       ; preds = %land.lhs.true119.i
  %.pre126.i = load ptr, ptr %ptr1.i.i431, align 8
  br label %cond.false124.i

cond.false124.i:                                  ; preds = %land.lhs.true119.cond.false124_crit_edge.i, %for.body112.i
  %129 = phi ptr [ %.pre126.i, %land.lhs.true119.cond.false124_crit_edge.i ], [ %127, %for.body112.i ]
  %130 = load ptr, ptr %binding39.i.le, align 8
  %uri126.i = getelementptr inbounds %struct.binding, ptr %130, i64 0, i32 4
  %131 = load ptr, ptr %uri126.i, align 8
  %arrayidx128.i = getelementptr i8, ptr %131, i64 %indvars.iv116.i
  %132 = load i8, ptr %arrayidx128.i, align 1
  %incdec.ptr131.i = getelementptr i8, ptr %129, i64 1
  store ptr %incdec.ptr131.i, ptr %ptr1.i.i431, align 8
  store i8 %132, ptr %129, align 1
  %indvars.iv.next117.i = add nuw nsw i64 %indvars.iv116.i, 1
  %exitcond120.not.i = icmp eq i64 %indvars.iv.next117.i, %wide.trip.count119.i
  br i1 %exitcond120.not.i, label %for.cond32.outer.i.backedge, label %for.body112.i, !llvm.loop !57

for.end137.i:                                     ; preds = %while.cond.i.i
  %133 = load ptr, ptr %92, align 8
  %tobool.not.i64.i = icmp eq ptr %133, null
  br i1 %tobool.not.i64.i, label %hashTableIterInit.exit70.i, label %cond.true.i65.i

cond.true.i65.i:                                  ; preds = %for.end137.i
  %size.i66.i = getelementptr inbounds %struct.HASH_TABLE, ptr %92, i64 0, i32 2
  %134 = load i64, ptr %size.i66.i, align 8
  %add.ptr.i67.i = getelementptr ptr, ptr %133, i64 %134
  br label %hashTableIterInit.exit70.i

hashTableIterInit.exit70.i:                       ; preds = %cond.true.i65.i, %for.end137.i
  %cond.i68.i = phi ptr [ %add.ptr.i67.i, %cond.true.i65.i ], [ null, %for.end137.i ]
  br label %for.cond138.outer.i

for.cond138.outer.i:                              ; preds = %for.cond138.outer.i.backedge, %hashTableIterInit.exit70.i
  %iter.sroa.0.3.ph.i = phi ptr [ %133, %hashTableIterInit.exit70.i ], [ %incdec.ptr.i77.i, %for.cond138.outer.i.backedge ]
  %needSep.2.ph.i = phi i1 [ %needSep.1.ph.i, %hashTableIterInit.exit70.i ], [ false, %for.cond138.outer.i.backedge ]
  br label %while.cond.i73.i

while.cond.i73.i:                                 ; preds = %while.cond.i73.i.backedge, %for.cond138.outer.i
  %incdec.ptr5.i74.i = phi ptr [ %iter.sroa.0.3.ph.i, %for.cond138.outer.i ], [ %incdec.ptr.i77.i, %while.cond.i73.i.backedge ]
  %cmp.not.i75.i = icmp eq ptr %incdec.ptr5.i74.i, %cond.i68.i
  br i1 %cmp.not.i75.i, label %for.end191.i, label %while.body.i76.i

while.body.i76.i:                                 ; preds = %while.cond.i73.i
  %incdec.ptr.i77.i = getelementptr ptr, ptr %incdec.ptr5.i74.i, i64 1
  %135 = load ptr, ptr %incdec.ptr5.i74.i, align 8
  %tobool.not.i78.i = icmp eq ptr %135, null
  br i1 %tobool.not.i78.i, label %while.cond.i73.i.backedge, label %if.end143.i

while.cond.i73.i.backedge:                        ; preds = %while.body.i76.i, %if.end143.i
  br label %while.cond.i73.i, !llvm.loop !9

if.end143.i:                                      ; preds = %while.body.i76.i
  %open.i = getelementptr inbounds %struct.ENTITY, ptr %135, i64 0, i32 8
  %136 = load i8, ptr %open.i, align 8
  %tobool144.not.i = icmp eq i8 %136, 0
  br i1 %tobool144.not.i, label %while.cond.i73.i.backedge, label %if.end146.i

if.end146.i:                                      ; preds = %if.end143.i
  br i1 %needSep.2.ph.i, label %if.end166.i, label %land.lhs.true149.i

land.lhs.true149.i:                               ; preds = %if.end146.i
  %137 = load ptr, ptr %ptr1.i.i431, align 8
  %138 = load ptr, ptr %end4.i.i435, align 8
  %cmp154.i = icmp eq ptr %137, %138
  br i1 %cmp154.i, label %land.lhs.true156.i, label %cond.false161.i

land.lhs.true156.i:                               ; preds = %land.lhs.true149.i
  %call158.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool270), !range !13
  %tobool159.not.i = icmp eq i8 %call158.i, 0
  br i1 %tobool159.not.i, label %getContext.exit.thread, label %land.lhs.true156.cond.false161_crit_edge.i

land.lhs.true156.cond.false161_crit_edge.i:       ; preds = %land.lhs.true156.i
  %.pre127.i = load ptr, ptr %ptr1.i.i431, align 8
  br label %cond.false161.i

cond.false161.i:                                  ; preds = %land.lhs.true156.cond.false161_crit_edge.i, %land.lhs.true149.i
  %139 = phi ptr [ %.pre127.i, %land.lhs.true156.cond.false161_crit_edge.i ], [ %137, %land.lhs.true149.i ]
  %incdec.ptr164.i = getelementptr i8, ptr %139, i64 1
  store ptr %incdec.ptr164.i, ptr %ptr1.i.i431, align 8
  store i8 12, ptr %139, align 1
  br label %if.end166.i

if.end166.i:                                      ; preds = %cond.false161.i, %if.end146.i
  %140 = load ptr, ptr %135, align 8
  %141 = load i8, ptr %140, align 1
  %tobool169.not104.i = icmp eq i8 %141, 0
  br i1 %tobool169.not104.i, label %for.cond138.outer.i.backedge, label %for.body170.i

for.cond138.outer.i.backedge:                     ; preds = %cond.false182.i, %if.end166.i
  br label %for.cond138.outer.i

for.body170.i:                                    ; preds = %if.end166.i, %cond.false182.i
  %142 = phi i8 [ %147, %cond.false182.i ], [ %141, %if.end166.i ]
  %s139.0105.i = phi ptr [ %incdec.ptr189.i, %cond.false182.i ], [ %140, %if.end166.i ]
  %143 = load ptr, ptr %ptr1.i.i431, align 8
  %144 = load ptr, ptr %end4.i.i435, align 8
  %cmp175.i = icmp eq ptr %143, %144
  br i1 %cmp175.i, label %land.lhs.true177.i, label %cond.false182.i

land.lhs.true177.i:                               ; preds = %for.body170.i
  %call179.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool270), !range !13
  %tobool180.not.i = icmp eq i8 %call179.i, 0
  br i1 %tobool180.not.i, label %getContext.exit.thread, label %land.lhs.true177.cond.false182_crit_edge.i

land.lhs.true177.cond.false182_crit_edge.i:       ; preds = %land.lhs.true177.i
  %.pre128.i = load i8, ptr %s139.0105.i, align 1
  %.pre129.i = load ptr, ptr %ptr1.i.i431, align 8
  br label %cond.false182.i

cond.false182.i:                                  ; preds = %land.lhs.true177.cond.false182_crit_edge.i, %for.body170.i
  %145 = phi ptr [ %.pre129.i, %land.lhs.true177.cond.false182_crit_edge.i ], [ %143, %for.body170.i ]
  %146 = phi i8 [ %.pre128.i, %land.lhs.true177.cond.false182_crit_edge.i ], [ %142, %for.body170.i ]
  %incdec.ptr185.i = getelementptr i8, ptr %145, i64 1
  store ptr %incdec.ptr185.i, ptr %ptr1.i.i431, align 8
  store i8 %146, ptr %145, align 1
  %incdec.ptr189.i = getelementptr i8, ptr %s139.0105.i, i64 1
  %147 = load i8, ptr %incdec.ptr189.i, align 1
  %tobool169.not.i = icmp eq i8 %147, 0
  br i1 %tobool169.not.i, label %for.cond138.outer.i.backedge, label %for.body170.i, !llvm.loop !58

for.end191.i:                                     ; preds = %while.cond.i73.i
  %148 = load ptr, ptr %ptr1.i.i431, align 8
  %149 = load ptr, ptr %end4.i.i435, align 8
  %cmp196.i = icmp eq ptr %148, %149
  br i1 %cmp196.i, label %land.lhs.true198.i, label %getContext.exit

land.lhs.true198.i:                               ; preds = %for.end191.i
  %call200.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool270), !range !13
  %tobool201.not.i = icmp eq i8 %call200.i, 0
  br i1 %tobool201.not.i, label %getContext.exit.thread, label %land.lhs.true198.cond.false203_crit_edge.i

land.lhs.true198.cond.false203_crit_edge.i:       ; preds = %land.lhs.true198.i
  %.pre130.i = load ptr, ptr %ptr1.i.i431, align 8
  br label %getContext.exit

getContext.exit.thread:                           ; preds = %land.lhs.true.i385, %land.lhs.true198.i, %land.lhs.true18.i, %land.lhs.true51.i, %land.lhs.true91.i, %land.lhs.true156.i, %land.lhs.true71.i, %land.lhs.true119.i, %land.lhs.true177.i
  store i8 0, ptr %open, align 8
  br label %return

getContext.exit:                                  ; preds = %for.end191.i, %land.lhs.true198.cond.false203_crit_edge.i
  %150 = phi ptr [ %.pre130.i, %land.lhs.true198.cond.false203_crit_edge.i ], [ %148, %for.end191.i ]
  %incdec.ptr206.i = getelementptr i8, ptr %150, i64 1
  store ptr %incdec.ptr206.i, ptr %ptr1.i.i431, align 8
  store i8 0, ptr %150, align 1
  %151 = load ptr, ptr %start.i.i445, align 8
  store i8 0, ptr %open, align 8
  %tobool150.not = icmp eq ptr %151, null
  br i1 %tobool150.not, label %return, label %if.end152

if.end152:                                        ; preds = %getContext.exit
  %152 = load ptr, ptr %m_externalEntityRefHandler, align 8
  %153 = load ptr, ptr %m_externalEntityRefHandlerArg, align 8
  %base = getelementptr inbounds %struct.ENTITY, ptr %retval.0.i373, i64 0, i32 5
  %154 = load ptr, ptr %base, align 8
  %systemId = getelementptr inbounds %struct.ENTITY, ptr %retval.0.i373, i64 0, i32 4
  %155 = load ptr, ptr %systemId, align 8
  %publicId = getelementptr inbounds %struct.ENTITY, ptr %retval.0.i373, i64 0, i32 6
  %156 = load ptr, ptr %publicId, align 8
  %call154 = call i32 %152(ptr noundef %153, ptr noundef nonnull %151, ptr noundef %154, ptr noundef %155, ptr noundef %156) #24
  %tobool155.not = icmp eq i32 %call154, 0
  br i1 %tobool155.not, label %return, label %if.end157

if.end157:                                        ; preds = %if.end152
  %157 = load ptr, ptr %start.i.i445, align 8
  store ptr %157, ptr %ptr1.i.i431, align 8
  br label %sw.epilog

if.else161:                                       ; preds = %if.else144
  %158 = load ptr, ptr %m_defaultHandler584, align 8
  %tobool163.not = icmp eq ptr %158, null
  br i1 %tobool163.not, label %sw.epilog, label %if.then164

if.then164:                                       ; preds = %if.else161
  %159 = load ptr, ptr %s.addr, align 8
  %160 = load ptr, ptr %next, align 8
  call fastcc void @reportDefault(ptr noundef nonnull %parser, ptr noundef %enc, ptr noundef %159, ptr noundef %160)
  br label %sw.epilog

sw.bb168:                                         ; preds = %if.end11, %if.end11
  %161 = load ptr, ptr %m_freeTagList362, align 8
  %tobool170.not = icmp eq ptr %161, null
  br i1 %tobool170.not, label %if.else175, label %if.then171

if.then171:                                       ; preds = %sw.bb168
  %162 = load ptr, ptr %161, align 8
  store ptr %162, ptr %m_freeTagList362, align 8
  br label %if.end190

if.else175:                                       ; preds = %sw.bb168
  %163 = load ptr, ptr %m_mem, align 8
  %call176 = call ptr %163(i64 noundef 88) #24
  %tobool177.not = icmp eq ptr %call176, null
  br i1 %tobool177.not, label %return, label %if.end179

if.end179:                                        ; preds = %if.else175
  %164 = load ptr, ptr %m_mem, align 8
  %call182 = call ptr %164(i64 noundef 32) #24
  %buf = getelementptr inbounds %struct.tag, ptr %call176, i64 0, i32 4
  store ptr %call182, ptr %buf, align 8
  %tobool184.not = icmp eq ptr %call182, null
  br i1 %tobool184.not, label %if.then185, label %if.end187

if.then185:                                       ; preds = %if.end179
  %free_fcn = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 3, i32 2
  %165 = load ptr, ptr %free_fcn, align 8
  call void %165(ptr noundef nonnull %call176) #24
  br label %return

if.end187:                                        ; preds = %if.end179
  %add.ptr189 = getelementptr i8, ptr %call182, i64 32
  %bufEnd = getelementptr inbounds %struct.tag, ptr %call176, i64 0, i32 5
  store ptr %add.ptr189, ptr %bufEnd, align 8
  br label %if.end190

if.end190:                                        ; preds = %if.end187, %if.then171
  %tag.0 = phi ptr [ %161, %if.then171 ], [ %call176, %if.end187 ]
  %bindings = getelementptr inbounds %struct.tag, ptr %tag.0, i64 0, i32 6
  store ptr null, ptr %bindings, align 8
  %166 = load ptr, ptr %m_tagStack343, align 8
  store ptr %166, ptr %tag.0, align 8
  store ptr %tag.0, ptr %m_tagStack343, align 8
  %name193 = getelementptr inbounds %struct.tag, ptr %tag.0, i64 0, i32 3
  %localPart = getelementptr inbounds %struct.tag, ptr %tag.0, i64 0, i32 3, i32 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %localPart, i8 0, i64 16, i1 false)
  %167 = load ptr, ptr %s.addr, align 8
  %168 = load i32, ptr %minBytesPerChar344, align 8
  %idx.ext196 = sext i32 %168 to i64
  %add.ptr197 = getelementptr i8, ptr %167, i64 %idx.ext196
  %rawName = getelementptr inbounds %struct.tag, ptr %tag.0, i64 0, i32 1
  store ptr %add.ptr197, ptr %rawName, align 8
  %169 = load ptr, ptr %nameLength347, align 8
  %call199 = call i32 %169(ptr noundef nonnull %enc, ptr noundef %add.ptr197) #24
  %rawNameLength = getelementptr inbounds %struct.tag, ptr %tag.0, i64 0, i32 2
  store i32 %call199, ptr %rawNameLength, align 8
  %170 = load i32, ptr %m_tagLevel336, align 4
  %inc = add i32 %170, 1
  store i32 %inc, ptr %m_tagLevel336, align 4
  %171 = load ptr, ptr %rawName, align 8
  %172 = load i32, ptr %rawNameLength, align 8
  %idx.ext203 = sext i32 %172 to i64
  %add.ptr204 = getelementptr i8, ptr %171, i64 %idx.ext203
  store ptr %171, ptr %fromPtr, align 8
  %buf206 = getelementptr inbounds %struct.tag, ptr %tag.0, i64 0, i32 4
  %173 = load ptr, ptr %buf206, align 8
  %bufEnd208 = getelementptr inbounds %struct.tag, ptr %tag.0, i64 0, i32 5
  %.pre880 = load ptr, ptr %bufEnd208, align 8
  store ptr %173, ptr %toPtr, align 8
  %174 = load ptr, ptr %utf8Convert558, align 8
  %add.ptr2091002 = getelementptr i8, ptr %.pre880, i64 -1
  %call2101003 = call i32 %174(ptr noundef nonnull %enc, ptr noundef nonnull %fromPtr, ptr noundef %add.ptr204, ptr noundef nonnull %toPtr, ptr noundef %add.ptr2091002) #24
  %175 = load ptr, ptr %toPtr, align 8
  %176 = load ptr, ptr %buf206, align 8
  %sub.ptr.lhs.cast1004 = ptrtoint ptr %175 to i64
  %sub.ptr.rhs.cast1005 = ptrtoint ptr %176 to i64
  %sub.ptr.sub1006 = sub i64 %sub.ptr.lhs.cast1004, %sub.ptr.rhs.cast1005
  %177 = load ptr, ptr %fromPtr, align 8
  %cmp2131007 = icmp uge ptr %177, %add.ptr204
  %cmp2161008 = icmp eq i32 %call2101003, 1
  %or.cond11009 = select i1 %cmp2131007, i1 true, i1 %cmp2161008
  br i1 %or.cond11009, label %if.then218, label %if.end220

if.then218:                                       ; preds = %if.end234, %if.end190
  %.lcssa957 = phi ptr [ %175, %if.end190 ], [ %183, %if.end234 ]
  %.lcssa = phi ptr [ %176, %if.end190 ], [ %184, %if.end234 ]
  %sub.ptr.sub.lcssa = phi i64 [ %sub.ptr.sub1006, %if.end190 ], [ %sub.ptr.sub, %if.end234 ]
  %conv212 = trunc i64 %sub.ptr.sub.lcssa to i32
  %strLen = getelementptr inbounds %struct.tag, ptr %tag.0, i64 0, i32 3, i32 3
  store i32 %conv212, ptr %strLen, align 8
  store ptr %.lcssa, ptr %name193, align 8
  store i8 0, ptr %.lcssa957, align 1
  %178 = load ptr, ptr %s.addr, align 8
  %call245 = call fastcc i32 @storeAtts(ptr noundef nonnull %parser, ptr noundef nonnull %enc, ptr noundef %178, ptr noundef nonnull %name193, ptr noundef nonnull %bindings, i32 noundef %account)
  %tobool246.not = icmp eq i32 %call245, 0
  br i1 %tobool246.not, label %if.end248, label %return

if.end220:                                        ; preds = %if.end190, %if.end234
  %sub.ptr.sub1011 = phi i64 [ %sub.ptr.sub, %if.end234 ], [ %sub.ptr.sub1006, %if.end190 ]
  %sub.ptr.rhs.cast1010 = phi i64 [ %sub.ptr.rhs.cast, %if.end234 ], [ %sub.ptr.rhs.cast1005, %if.end190 ]
  %179 = phi ptr [ %184, %if.end234 ], [ %176, %if.end190 ]
  %180 = load ptr, ptr %bufEnd208, align 8
  %sub.ptr.lhs.cast223 = ptrtoint ptr %180 to i64
  %sub.ptr.sub225 = sub i64 %sub.ptr.lhs.cast223, %sub.ptr.rhs.cast1010
  %conv226 = trunc i64 %sub.ptr.sub225 to i32
  %shl = shl i32 %conv226, 1
  %181 = load ptr, ptr %realloc_fcn, align 8
  %conv229 = sext i32 %shl to i64
  %call230 = call ptr %181(ptr noundef %179, i64 noundef %conv229) #24
  %cmp231 = icmp eq ptr %call230, null
  br i1 %cmp231, label %return, label %if.end234

if.end234:                                        ; preds = %if.end220
  store ptr %call230, ptr %buf206, align 8
  %add.ptr237 = getelementptr i8, ptr %call230, i64 %conv229
  store ptr %add.ptr237, ptr %bufEnd208, align 8
  %sext = shl i64 %sub.ptr.sub1011, 32
  %idx.ext239 = ashr exact i64 %sext, 32
  %add.ptr240 = getelementptr i8, ptr %call230, i64 %idx.ext239
  store ptr %add.ptr240, ptr %toPtr, align 8
  %182 = load ptr, ptr %utf8Convert558, align 8
  %add.ptr209 = getelementptr i8, ptr %add.ptr237, i64 -1
  %call210 = call i32 %182(ptr noundef nonnull %enc, ptr noundef nonnull %fromPtr, ptr noundef %add.ptr204, ptr noundef nonnull %toPtr, ptr noundef %add.ptr209) #24
  %183 = load ptr, ptr %toPtr, align 8
  %184 = load ptr, ptr %buf206, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %183 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %184 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %185 = load ptr, ptr %fromPtr, align 8
  %cmp213 = icmp uge ptr %185, %add.ptr204
  %cmp216 = icmp eq i32 %call210, 1
  %or.cond1 = select i1 %cmp213, i1 true, i1 %cmp216
  br i1 %or.cond1, label %if.then218, label %if.end220

if.end248:                                        ; preds = %if.then218
  %186 = load ptr, ptr %m_startElementHandler294, align 8
  %tobool249.not = icmp eq ptr %186, null
  br i1 %tobool249.not, label %if.else255, label %if.then250

if.then250:                                       ; preds = %if.end248
  %187 = load ptr, ptr %m_handlerArg577, align 8
  %188 = load ptr, ptr %name193, align 8
  %189 = load ptr, ptr %m_atts300, align 8
  call void %186(ptr noundef %187, ptr noundef %188, ptr noundef %189) #24
  br label %if.end260

if.else255:                                       ; preds = %if.end248
  %190 = load ptr, ptr %m_defaultHandler584, align 8
  %tobool257.not = icmp eq ptr %190, null
  br i1 %tobool257.not, label %if.end260, label %if.then258

if.then258:                                       ; preds = %if.else255
  %191 = load ptr, ptr %s.addr, align 8
  %192 = load ptr, ptr %next, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %s.addr.i388)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %dataPtr.i389)
  store ptr %191, ptr %s.addr.i388, align 8
  %193 = load i8, ptr %isUtf8551, align 4
  %tobool.not.i391 = icmp eq i8 %193, 0
  br i1 %tobool.not.i391, label %if.then.i399, label %if.else9.i392

if.then.i399:                                     ; preds = %if.then258
  %194 = load ptr, ptr %m_encoding, align 8
  %cmp.i401 = icmp eq ptr %194, %enc
  br i1 %cmp.i401, label %if.end.i405, label %if.else.i402

if.else.i402:                                     ; preds = %if.then.i399
  %195 = load ptr, ptr %m_openInternalEntities.i685, align 8
  %internalEventEndPtr.i404 = getelementptr inbounds %struct.open_internal_entity, ptr %195, i64 0, i32 1
  br label %if.end.i405

if.end.i405:                                      ; preds = %if.then.i399, %if.else.i402
  %eventPP.0.i406 = phi ptr [ %195, %if.else.i402 ], [ %m_eventPtr.i702, %if.then.i399 ]
  %eventEndPP.0.i407 = phi ptr [ %internalEventEndPtr.i404, %if.else.i402 ], [ %m_eventEndPtr.i703, %if.then.i399 ]
  br label %do.body.i413

do.body.i413:                                     ; preds = %do.body.i413, %if.end.i405
  %196 = load ptr, ptr %m_dataBuf556, align 8
  store ptr %196, ptr %dataPtr.i389, align 8
  %197 = load ptr, ptr %utf8Convert558, align 8
  %198 = load ptr, ptr %m_dataBufEnd559, align 8
  %call.i414 = call i32 %197(ptr noundef nonnull %enc, ptr noundef nonnull %s.addr.i388, ptr noundef %192, ptr noundef nonnull %dataPtr.i389, ptr noundef %198) #24
  %199 = load ptr, ptr %s.addr.i388, align 8
  store ptr %199, ptr %eventEndPP.0.i407, align 8
  %200 = load ptr, ptr %m_defaultHandler584, align 8
  %201 = load ptr, ptr %m_handlerArg577, align 8
  %202 = load ptr, ptr %m_dataBuf556, align 8
  %203 = load ptr, ptr %dataPtr.i389, align 8
  %sub.ptr.lhs.cast.i415 = ptrtoint ptr %203 to i64
  %sub.ptr.rhs.cast.i416 = ptrtoint ptr %202 to i64
  %sub.ptr.sub.i417 = sub i64 %sub.ptr.lhs.cast.i415, %sub.ptr.rhs.cast.i416
  %conv.i418 = trunc i64 %sub.ptr.sub.i417 to i32
  call void %200(ptr noundef %201, ptr noundef %202, i32 noundef %conv.i418) #24
  %204 = load ptr, ptr %s.addr.i388, align 8
  store ptr %204, ptr %eventPP.0.i406, align 8
  %205 = icmp ugt i32 %call.i414, 1
  br i1 %205, label %do.body.i413, label %reportDefault.exit422, !llvm.loop !28

if.else9.i392:                                    ; preds = %if.then258
  %206 = load ptr, ptr %m_handlerArg577, align 8
  %sub.ptr.lhs.cast12.i395 = ptrtoint ptr %192 to i64
  %sub.ptr.rhs.cast13.i396 = ptrtoint ptr %191 to i64
  %sub.ptr.sub14.i397 = sub i64 %sub.ptr.lhs.cast12.i395, %sub.ptr.rhs.cast13.i396
  %conv15.i398 = trunc i64 %sub.ptr.sub14.i397 to i32
  call void %190(ptr noundef %206, ptr noundef %191, i32 noundef %conv15.i398) #24
  br label %reportDefault.exit422

reportDefault.exit422:                            ; preds = %do.body.i413, %if.else9.i392
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %s.addr.i388)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %dataPtr.i389)
  br label %if.end260

if.end260:                                        ; preds = %if.else255, %reportDefault.exit422, %if.then250
  %207 = load ptr, ptr %freeBlocks.i503, align 8
  %tobool.not.i423 = icmp eq ptr %207, null
  %208 = load ptr, ptr %m_tempPool270, align 8
  br i1 %tobool.not.i423, label %if.then.i429, label %if.else.i424

if.then.i429:                                     ; preds = %if.end260
  store ptr %208, ptr %freeBlocks.i503, align 8
  br label %poolClear.exit

if.else.i424:                                     ; preds = %if.end260
  %tobool3.not13.i = icmp eq ptr %208, null
  br i1 %tobool3.not13.i, label %poolClear.exit, label %while.body.i425

while.body.i425:                                  ; preds = %if.else.i424, %while.body.i425
  %209 = phi ptr [ %p.014.i, %while.body.i425 ], [ %207, %if.else.i424 ]
  %p.014.i = phi ptr [ %210, %while.body.i425 ], [ %208, %if.else.i424 ]
  %210 = load ptr, ptr %p.014.i, align 8
  store ptr %209, ptr %p.014.i, align 8
  store ptr %p.014.i, ptr %freeBlocks.i503, align 8
  %tobool3.not.i426 = icmp eq ptr %210, null
  br i1 %tobool3.not.i426, label %poolClear.exit, label %while.body.i425, !llvm.loop !8

poolClear.exit:                                   ; preds = %while.body.i425, %if.then.i429, %if.else.i424
  store ptr null, ptr %m_tempPool270, align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %end4.i.i435, i8 0, i64 24, i1 false)
  br label %sw.epilog

sw.bb262:                                         ; preds = %if.end11, %if.end11
  %211 = load ptr, ptr %s.addr, align 8
  %212 = load i32, ptr %minBytesPerChar344, align 8
  %idx.ext265 = sext i32 %212 to i64
  %add.ptr266 = getelementptr i8, ptr %211, i64 %idx.ext265
  store ptr null, ptr %bindings268, align 8
  %213 = load ptr, ptr %nameLength347, align 8
  %call272 = call i32 %213(ptr noundef nonnull %enc, ptr noundef %add.ptr266) #24
  %idx.ext273 = sext i32 %call272 to i64
  %add.ptr274 = getelementptr i8, ptr %add.ptr266, i64 %idx.ext273
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ptr.addr.i.i430)
  store ptr %add.ptr266, ptr %ptr.addr.i.i430, align 8
  %214 = load ptr, ptr %ptr1.i.i431, align 8
  %tobool.not.i.i432 = icmp eq ptr %214, null
  br i1 %tobool.not.i.i432, label %land.lhs.true.i.i456, label %for.cond.i.i436.preheader

land.lhs.true.i.i456:                             ; preds = %sw.bb262
  %call.i.i457 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool270), !range !13
  %tobool2.not.i.i458 = icmp eq i8 %call.i.i457, 0
  br i1 %tobool2.not.i.i458, label %poolAppend.exit.thread.i442, label %for.cond.i.i436.preheader

for.cond.i.i436.preheader:                        ; preds = %land.lhs.true.i.i456, %sw.bb262
  br label %for.cond.i.i436

for.cond.i.i436:                                  ; preds = %for.cond.i.i436.preheader, %if.end8.i.i439
  %215 = load ptr, ptr %utf8Convert558, align 8
  %216 = load ptr, ptr %end4.i.i435, align 8
  %call5.i.i437 = call i32 %215(ptr noundef nonnull %enc, ptr noundef nonnull %ptr.addr.i.i430, ptr noundef %add.ptr274, ptr noundef nonnull %ptr1.i.i431, ptr noundef %216) #24
  %or.cond.i.i438 = icmp ult i32 %call5.i.i437, 2
  br i1 %or.cond.i.i438, label %poolAppend.exit.i444, label %if.end8.i.i439

if.end8.i.i439:                                   ; preds = %for.cond.i.i436
  %call9.i.i440 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool270), !range !13
  %tobool10.not.i.i441 = icmp eq i8 %call9.i.i440, 0
  br i1 %tobool10.not.i.i441, label %poolAppend.exit.thread.i442, label %for.cond.i.i436

poolAppend.exit.thread.i442:                      ; preds = %land.lhs.true.i.i456, %if.end8.i.i439
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i430)
  br label %return

poolAppend.exit.i444:                             ; preds = %for.cond.i.i436
  %217 = load ptr, ptr %start.i.i445, align 8
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i430)
  %tobool.not.i446 = icmp eq ptr %217, null
  br i1 %tobool.not.i446, label %return, label %if.end.i447

if.end.i447:                                      ; preds = %poolAppend.exit.i444
  %218 = load ptr, ptr %ptr1.i.i431, align 8
  %219 = load ptr, ptr %end4.i.i435, align 8
  %cmp.i448 = icmp eq ptr %218, %219
  br i1 %cmp.i448, label %land.lhs.true.i451, label %poolStoreString.exit459

land.lhs.true.i451:                               ; preds = %if.end.i447
  %call3.i452 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool270), !range !13
  %tobool4.not.i453 = icmp eq i8 %call3.i452, 0
  br i1 %tobool4.not.i453, label %return, label %land.lhs.true.if.end6_crit_edge.i454

land.lhs.true.if.end6_crit_edge.i454:             ; preds = %land.lhs.true.i451
  %.pre.i455 = load ptr, ptr %ptr1.i.i431, align 8
  br label %poolStoreString.exit459

poolStoreString.exit459:                          ; preds = %if.end.i447, %land.lhs.true.if.end6_crit_edge.i454
  %220 = phi ptr [ %.pre.i455, %land.lhs.true.if.end6_crit_edge.i454 ], [ %218, %if.end.i447 ]
  %incdec.ptr.i450 = getelementptr i8, ptr %220, i64 1
  store ptr %incdec.ptr.i450, ptr %ptr1.i.i431, align 8
  store i8 0, ptr %220, align 1
  %221 = load ptr, ptr %start.i.i445, align 8
  store ptr %221, ptr %name269, align 8
  %tobool278.not = icmp eq ptr %221, null
  br i1 %tobool278.not, label %return, label %if.end280

if.end280:                                        ; preds = %poolStoreString.exit459
  %222 = load ptr, ptr %ptr1.i.i431, align 8
  store ptr %222, ptr %start.i.i445, align 8
  %223 = load ptr, ptr %s.addr, align 8
  %call285 = call fastcc i32 @storeAtts(ptr noundef nonnull %parser, ptr noundef nonnull %enc, ptr noundef %223, ptr noundef nonnull %name269, ptr noundef nonnull %bindings268, i32 noundef 2)
  %cmp286.not = icmp eq i32 %call285, 0
  br i1 %cmp286.not, label %if.end289, label %if.then288

if.then288:                                       ; preds = %if.end280
  %224 = load ptr, ptr %bindings268, align 8
  %tobool.not11.i = icmp eq ptr %224, null
  br i1 %tobool.not11.i, label %return, label %while.body.i462

while.body.i462:                                  ; preds = %if.then288, %if.end.i464
  %bindings.addr.012.i = phi ptr [ %229, %if.end.i464 ], [ %224, %if.then288 ]
  %225 = load ptr, ptr %m_endNamespaceDeclHandler, align 8
  %tobool1.not.i = icmp eq ptr %225, null
  br i1 %tobool1.not.i, label %if.end.i464, label %if.then.i463

if.then.i463:                                     ; preds = %while.body.i462
  %226 = load ptr, ptr %m_handlerArg577, align 8
  %227 = load ptr, ptr %bindings.addr.012.i, align 8
  %228 = load ptr, ptr %227, align 8
  call void %225(ptr noundef %226, ptr noundef %228) #24
  br label %if.end.i464

if.end.i464:                                      ; preds = %if.then.i463, %while.body.i462
  %nextTagBinding.i = getelementptr inbounds %struct.binding, ptr %bindings.addr.012.i, i64 0, i32 1
  %229 = load ptr, ptr %nextTagBinding.i, align 8
  %230 = load ptr, ptr %m_freeBindingList, align 8
  store ptr %230, ptr %nextTagBinding.i, align 8
  store ptr %bindings.addr.012.i, ptr %m_freeBindingList, align 8
  %prevPrefixBinding.i = getelementptr inbounds %struct.binding, ptr %bindings.addr.012.i, i64 0, i32 2
  %231 = load ptr, ptr %prevPrefixBinding.i, align 8
  %232 = load ptr, ptr %bindings.addr.012.i, align 8
  %binding.i465 = getelementptr inbounds %struct.prefix, ptr %232, i64 0, i32 1
  store ptr %231, ptr %binding.i465, align 8
  %tobool.not.i466 = icmp eq ptr %229, null
  br i1 %tobool.not.i466, label %return, label %while.body.i462, !llvm.loop !59

if.end289:                                        ; preds = %if.end280
  %233 = load ptr, ptr %ptr1.i.i431, align 8
  store ptr %233, ptr %start.i.i445, align 8
  %234 = load ptr, ptr %m_startElementHandler294, align 8
  %tobool295.not.not = icmp eq ptr %234, null
  br i1 %tobool295.not.not, label %if.end301, label %if.end301.thread

if.end301:                                        ; preds = %if.end289
  %235 = load ptr, ptr %m_endElementHandler366, align 8
  %tobool302.not = icmp eq ptr %235, null
  br i1 %tobool302.not, label %land.lhs.true, label %if.end311.thread

if.end301.thread:                                 ; preds = %if.end289
  %236 = load ptr, ptr %m_handlerArg577, align 8
  %237 = load ptr, ptr %name269, align 8
  %238 = load ptr, ptr %m_atts300, align 8
  call void %234(ptr noundef %236, ptr noundef %237, ptr noundef %238) #24
  %239 = load ptr, ptr %m_endElementHandler366, align 8
  %tobool302.not881 = icmp eq ptr %239, null
  br i1 %tobool302.not881, label %if.end317, label %if.then303

if.then303:                                       ; preds = %if.end301.thread
  %.pr = load ptr, ptr %m_startElementHandler294, align 8
  %tobool305.not = icmp eq ptr %.pr, null
  br i1 %tobool305.not, label %if.end311.thread, label %if.then306

if.then306:                                       ; preds = %if.then303
  %240 = load ptr, ptr %eventEndPP.0, align 8
  store ptr %240, ptr %eventPP.0, align 8
  %.pre879 = load ptr, ptr %m_endElementHandler366, align 8
  br label %if.end311.thread

if.end311.thread:                                 ; preds = %if.end301, %if.then303, %if.then306
  %241 = phi ptr [ %239, %if.then303 ], [ %.pre879, %if.then306 ], [ %235, %if.end301 ]
  %242 = load ptr, ptr %m_handlerArg577, align 8
  %243 = load ptr, ptr %name269, align 8
  call void %241(ptr noundef %242, ptr noundef %243) #24
  br label %if.end317

land.lhs.true:                                    ; preds = %if.end301
  %244 = load ptr, ptr %m_defaultHandler584, align 8
  %tobool315.not = icmp eq ptr %244, null
  br i1 %tobool315.not, label %if.end317, label %if.then316

if.then316:                                       ; preds = %land.lhs.true
  %245 = load ptr, ptr %s.addr, align 8
  %246 = load ptr, ptr %next, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %s.addr.i468)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %dataPtr.i469)
  store ptr %245, ptr %s.addr.i468, align 8
  %247 = load i8, ptr %isUtf8551, align 4
  %tobool.not.i471 = icmp eq i8 %247, 0
  br i1 %tobool.not.i471, label %if.then.i479, label %if.else9.i472

if.then.i479:                                     ; preds = %if.then316
  %248 = load ptr, ptr %m_encoding, align 8
  %cmp.i481 = icmp eq ptr %248, %enc
  br i1 %cmp.i481, label %if.end.i485, label %if.else.i482

if.else.i482:                                     ; preds = %if.then.i479
  %249 = load ptr, ptr %m_openInternalEntities.i685, align 8
  %internalEventEndPtr.i484 = getelementptr inbounds %struct.open_internal_entity, ptr %249, i64 0, i32 1
  br label %if.end.i485

if.end.i485:                                      ; preds = %if.then.i479, %if.else.i482
  %eventPP.0.i486 = phi ptr [ %249, %if.else.i482 ], [ %m_eventPtr.i702, %if.then.i479 ]
  %eventEndPP.0.i487 = phi ptr [ %internalEventEndPtr.i484, %if.else.i482 ], [ %m_eventEndPtr.i703, %if.then.i479 ]
  br label %do.body.i493

do.body.i493:                                     ; preds = %do.body.i493, %if.end.i485
  %250 = load ptr, ptr %m_dataBuf556, align 8
  store ptr %250, ptr %dataPtr.i469, align 8
  %251 = load ptr, ptr %utf8Convert558, align 8
  %252 = load ptr, ptr %m_dataBufEnd559, align 8
  %call.i494 = call i32 %251(ptr noundef nonnull %enc, ptr noundef nonnull %s.addr.i468, ptr noundef %246, ptr noundef nonnull %dataPtr.i469, ptr noundef %252) #24
  %253 = load ptr, ptr %s.addr.i468, align 8
  store ptr %253, ptr %eventEndPP.0.i487, align 8
  %254 = load ptr, ptr %m_defaultHandler584, align 8
  %255 = load ptr, ptr %m_handlerArg577, align 8
  %256 = load ptr, ptr %m_dataBuf556, align 8
  %257 = load ptr, ptr %dataPtr.i469, align 8
  %sub.ptr.lhs.cast.i495 = ptrtoint ptr %257 to i64
  %sub.ptr.rhs.cast.i496 = ptrtoint ptr %256 to i64
  %sub.ptr.sub.i497 = sub i64 %sub.ptr.lhs.cast.i495, %sub.ptr.rhs.cast.i496
  %conv.i498 = trunc i64 %sub.ptr.sub.i497 to i32
  call void %254(ptr noundef %255, ptr noundef %256, i32 noundef %conv.i498) #24
  %258 = load ptr, ptr %s.addr.i468, align 8
  store ptr %258, ptr %eventPP.0.i486, align 8
  %259 = icmp ugt i32 %call.i494, 1
  br i1 %259, label %do.body.i493, label %reportDefault.exit502, !llvm.loop !28

if.else9.i472:                                    ; preds = %if.then316
  %260 = load ptr, ptr %m_handlerArg577, align 8
  %sub.ptr.lhs.cast12.i475 = ptrtoint ptr %246 to i64
  %sub.ptr.rhs.cast13.i476 = ptrtoint ptr %245 to i64
  %sub.ptr.sub14.i477 = sub i64 %sub.ptr.lhs.cast12.i475, %sub.ptr.rhs.cast13.i476
  %conv15.i478 = trunc i64 %sub.ptr.sub14.i477 to i32
  call void %244(ptr noundef %260, ptr noundef %245, i32 noundef %conv15.i478) #24
  br label %reportDefault.exit502

reportDefault.exit502:                            ; preds = %do.body.i493, %if.else9.i472
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %s.addr.i468)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %dataPtr.i469)
  br label %if.end317

if.end317:                                        ; preds = %if.end301.thread, %if.end311.thread, %reportDefault.exit502, %land.lhs.true
  %261 = load ptr, ptr %freeBlocks.i503, align 8
  %tobool.not.i504 = icmp eq ptr %261, null
  %262 = load ptr, ptr %m_tempPool270, align 8
  br i1 %tobool.not.i504, label %if.then.i512, label %if.else.i505

if.then.i512:                                     ; preds = %if.end317
  store ptr %262, ptr %freeBlocks.i503, align 8
  br label %poolClear.exit513

if.else.i505:                                     ; preds = %if.end317
  %tobool3.not13.i506 = icmp eq ptr %262, null
  br i1 %tobool3.not13.i506, label %poolClear.exit513, label %while.body.i507

while.body.i507:                                  ; preds = %if.else.i505, %while.body.i507
  %263 = phi ptr [ %p.014.i508, %while.body.i507 ], [ %261, %if.else.i505 ]
  %p.014.i508 = phi ptr [ %264, %while.body.i507 ], [ %262, %if.else.i505 ]
  %264 = load ptr, ptr %p.014.i508, align 8
  store ptr %263, ptr %p.014.i508, align 8
  store ptr %p.014.i508, ptr %freeBlocks.i503, align 8
  %tobool3.not.i509 = icmp eq ptr %264, null
  br i1 %tobool3.not.i509, label %poolClear.exit513, label %while.body.i507, !llvm.loop !8

poolClear.exit513:                                ; preds = %while.body.i507, %if.then.i512, %if.else.i505
  store ptr null, ptr %m_tempPool270, align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %end4.i.i435, i8 0, i64 24, i1 false)
  %265 = load ptr, ptr %bindings268, align 8
  %tobool.not11.i514 = icmp eq ptr %265, null
  br i1 %tobool.not11.i514, label %freeBindings.exit529, label %while.body.i519

while.body.i519:                                  ; preds = %poolClear.exit513, %if.end.i523
  %bindings.addr.012.i520 = phi ptr [ %270, %if.end.i523 ], [ %265, %poolClear.exit513 ]
  %266 = load ptr, ptr %m_endNamespaceDeclHandler, align 8
  %tobool1.not.i521 = icmp eq ptr %266, null
  br i1 %tobool1.not.i521, label %if.end.i523, label %if.then.i522

if.then.i522:                                     ; preds = %while.body.i519
  %267 = load ptr, ptr %m_handlerArg577, align 8
  %268 = load ptr, ptr %bindings.addr.012.i520, align 8
  %269 = load ptr, ptr %268, align 8
  call void %266(ptr noundef %267, ptr noundef %269) #24
  br label %if.end.i523

if.end.i523:                                      ; preds = %if.then.i522, %while.body.i519
  %nextTagBinding.i524 = getelementptr inbounds %struct.binding, ptr %bindings.addr.012.i520, i64 0, i32 1
  %270 = load ptr, ptr %nextTagBinding.i524, align 8
  %271 = load ptr, ptr %m_freeBindingList, align 8
  store ptr %271, ptr %nextTagBinding.i524, align 8
  store ptr %bindings.addr.012.i520, ptr %m_freeBindingList, align 8
  %prevPrefixBinding.i525 = getelementptr inbounds %struct.binding, ptr %bindings.addr.012.i520, i64 0, i32 2
  %272 = load ptr, ptr %prevPrefixBinding.i525, align 8
  %273 = load ptr, ptr %bindings.addr.012.i520, align 8
  %binding.i526 = getelementptr inbounds %struct.prefix, ptr %273, i64 0, i32 1
  store ptr %272, ptr %binding.i526, align 8
  %tobool.not.i527 = icmp eq ptr %270, null
  br i1 %tobool.not.i527, label %freeBindings.exit529, label %while.body.i519, !llvm.loop !59

freeBindings.exit529:                             ; preds = %if.end.i523, %poolClear.exit513
  %274 = load i32, ptr %m_tagLevel336, align 4
  %cmp320 = icmp eq i32 %274, 0
  br i1 %cmp320, label %land.lhs.true322, label %sw.epilog

land.lhs.true322:                                 ; preds = %freeBindings.exit529
  %275 = load i32, ptr %m_parsingStatus433, align 8
  switch i32 %275, label %if.else331 [
    i32 2, label %sw.epilog
    i32 3, label %if.then330
  ]

if.then330:                                       ; preds = %land.lhs.true322
  store ptr @epilogProcessor, ptr %m_processor443, align 8
  br label %sw.epilog

if.else331:                                       ; preds = %land.lhs.true322
  %276 = load ptr, ptr %next, align 8
  %call332 = call i32 @epilogProcessor(ptr noundef nonnull %parser, ptr noundef %276, ptr noundef %end, ptr noundef %nextPtr), !range !32
  br label %return

sw.bb335:                                         ; preds = %if.end11
  %277 = load i32, ptr %m_tagLevel336, align 4
  %cmp337 = icmp eq i32 %277, %startTagLevel
  br i1 %cmp337, label %return, label %if.else340

if.else340:                                       ; preds = %sw.bb335
  %278 = load ptr, ptr %m_tagStack343, align 8
  %279 = load ptr, ptr %s.addr, align 8
  %280 = load i32, ptr %minBytesPerChar344, align 8
  %mul = shl i32 %280, 1
  %idx.ext345 = sext i32 %mul to i64
  %add.ptr346 = getelementptr i8, ptr %279, i64 %idx.ext345
  %281 = load ptr, ptr %nameLength347, align 8
  %call348 = call i32 %281(ptr noundef nonnull %enc, ptr noundef %add.ptr346) #24
  %rawNameLength349 = getelementptr inbounds %struct.tag, ptr %278, i64 0, i32 2
  %282 = load i32, ptr %rawNameLength349, align 8
  %cmp350.not = icmp eq i32 %call348, %282
  br i1 %cmp350.not, label %lor.lhs.false352, label %if.then358

lor.lhs.false352:                                 ; preds = %if.else340
  %rawName353 = getelementptr inbounds %struct.tag, ptr %278, i64 0, i32 1
  %283 = load ptr, ptr %rawName353, align 8
  %conv354 = sext i32 %call348 to i64
  %bcmp = call i32 @bcmp(ptr %283, ptr %add.ptr346, i64 %conv354)
  %cmp356.not = icmp eq i32 %bcmp, 0
  br i1 %cmp356.not, label %if.end359, label %if.then358

if.then358:                                       ; preds = %lor.lhs.false352, %if.else340
  store ptr %add.ptr346, ptr %eventPP.0, align 8
  br label %return

if.end359:                                        ; preds = %lor.lhs.false352
  %284 = load ptr, ptr %278, align 8
  store ptr %284, ptr %m_tagStack343, align 8
  %285 = load ptr, ptr %m_freeTagList362, align 8
  store ptr %285, ptr %278, align 8
  store ptr %278, ptr %m_freeTagList362, align 8
  %286 = load i32, ptr %m_tagLevel336, align 4
  %dec = add i32 %286, -1
  store i32 %dec, ptr %m_tagLevel336, align 4
  %287 = load ptr, ptr %m_endElementHandler366, align 8
  %tobool367.not = icmp eq ptr %287, null
  br i1 %tobool367.not, label %if.else405, label %if.then368

if.then368:                                       ; preds = %if.end359
  %name371 = getelementptr inbounds %struct.tag, ptr %278, i64 0, i32 3
  %localPart372 = getelementptr inbounds %struct.tag, ptr %278, i64 0, i32 3, i32 1
  %288 = load ptr, ptr %localPart372, align 8
  %289 = load i8, ptr %m_ns, align 8
  %tobool374 = icmp ne i8 %289, 0
  %tobool376 = icmp ne ptr %288, null
  %or.cond2 = select i1 %tobool374, i1 %tobool376, i1 false
  br i1 %or.cond2, label %if.then377, label %if.end400

if.then377:                                       ; preds = %if.then368
  %290 = load ptr, ptr %name371, align 8
  %uriLen = getelementptr inbounds %struct.tag, ptr %278, i64 0, i32 3, i32 4
  %291 = load i32, ptr %uriLen, align 4
  %idx.ext381 = sext i32 %291 to i64
  %add.ptr382 = getelementptr i8, ptr %290, i64 %idx.ext381
  %292 = load i8, ptr %288, align 1
  %tobool383.not808 = icmp eq i8 %292, 0
  br i1 %tobool383.not808, label %while.end, label %while.body

while.body:                                       ; preds = %if.then377, %while.body
  %293 = phi i8 [ %294, %while.body ], [ %292, %if.then377 ]
  %uri.0810 = phi ptr [ %incdec.ptr384, %while.body ], [ %add.ptr382, %if.then377 ]
  %localPart369.0809 = phi ptr [ %incdec.ptr, %while.body ], [ %288, %if.then377 ]
  %incdec.ptr = getelementptr i8, ptr %localPart369.0809, i64 1
  %incdec.ptr384 = getelementptr i8, ptr %uri.0810, i64 1
  store i8 %293, ptr %uri.0810, align 1
  %294 = load i8, ptr %incdec.ptr, align 1
  %tobool383.not = icmp eq i8 %294, 0
  br i1 %tobool383.not, label %while.end, label %while.body, !llvm.loop !60

while.end:                                        ; preds = %while.body, %if.then377
  %uri.0.lcssa = phi ptr [ %add.ptr382, %if.then377 ], [ %incdec.ptr384, %while.body ]
  %prefix386 = getelementptr inbounds %struct.tag, ptr %278, i64 0, i32 3, i32 2
  %295 = load ptr, ptr %prefix386, align 8
  %296 = load i8, ptr %m_ns_triplets, align 1
  %tobool388 = icmp ne i8 %296, 0
  %tobool390 = icmp ne ptr %295, null
  %or.cond3 = select i1 %tobool388, i1 %tobool390, i1 false
  br i1 %or.cond3, label %if.then391, label %if.end399

if.then391:                                       ; preds = %while.end
  %297 = load i8, ptr %m_namespaceSeparator, align 4
  store i8 %297, ptr %uri.0.lcssa, align 1
  %uri.1811 = getelementptr i8, ptr %uri.0.lcssa, i64 1
  %298 = load i8, ptr %295, align 1
  %tobool394.not812 = icmp eq i8 %298, 0
  br i1 %tobool394.not812, label %if.end399, label %while.body395

while.body395:                                    ; preds = %if.then391, %while.body395
  %299 = phi i8 [ %300, %while.body395 ], [ %298, %if.then391 ]
  %uri.1814 = phi ptr [ %uri.1, %while.body395 ], [ %uri.1811, %if.then391 ]
  %prefix370.0813 = phi ptr [ %incdec.ptr396, %while.body395 ], [ %295, %if.then391 ]
  %incdec.ptr396 = getelementptr i8, ptr %prefix370.0813, i64 1
  store i8 %299, ptr %uri.1814, align 1
  %uri.1 = getelementptr i8, ptr %uri.1814, i64 1
  %300 = load i8, ptr %incdec.ptr396, align 1
  %tobool394.not = icmp eq i8 %300, 0
  br i1 %tobool394.not, label %if.end399, label %while.body395, !llvm.loop !61

if.end399:                                        ; preds = %while.body395, %if.then391, %while.end
  %uri.2 = phi ptr [ %uri.0.lcssa, %while.end ], [ %uri.1811, %if.then391 ], [ %uri.1, %while.body395 ]
  store i8 0, ptr %uri.2, align 1
  %.pre877 = load ptr, ptr %m_endElementHandler366, align 8
  br label %if.end400

if.end400:                                        ; preds = %if.end399, %if.then368
  %301 = phi ptr [ %.pre877, %if.end399 ], [ %287, %if.then368 ]
  %302 = load ptr, ptr %m_handlerArg577, align 8
  %303 = load ptr, ptr %name371, align 8
  call void %301(ptr noundef %302, ptr noundef %303) #24
  br label %if.end410

if.else405:                                       ; preds = %if.end359
  %304 = load ptr, ptr %m_defaultHandler584, align 8
  %tobool407.not = icmp eq ptr %304, null
  br i1 %tobool407.not, label %if.end410, label %if.then408

if.then408:                                       ; preds = %if.else405
  %305 = load ptr, ptr %s.addr, align 8
  %306 = load ptr, ptr %next, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %s.addr.i530)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %dataPtr.i531)
  store ptr %305, ptr %s.addr.i530, align 8
  %307 = load i8, ptr %isUtf8551, align 4
  %tobool.not.i533 = icmp eq i8 %307, 0
  br i1 %tobool.not.i533, label %if.then.i541, label %if.else9.i534

if.then.i541:                                     ; preds = %if.then408
  %308 = load ptr, ptr %m_encoding, align 8
  %cmp.i543 = icmp eq ptr %308, %enc
  br i1 %cmp.i543, label %if.end.i547, label %if.else.i544

if.else.i544:                                     ; preds = %if.then.i541
  %309 = load ptr, ptr %m_openInternalEntities.i685, align 8
  %internalEventEndPtr.i546 = getelementptr inbounds %struct.open_internal_entity, ptr %309, i64 0, i32 1
  br label %if.end.i547

if.end.i547:                                      ; preds = %if.then.i541, %if.else.i544
  %eventPP.0.i548 = phi ptr [ %309, %if.else.i544 ], [ %m_eventPtr.i702, %if.then.i541 ]
  %eventEndPP.0.i549 = phi ptr [ %internalEventEndPtr.i546, %if.else.i544 ], [ %m_eventEndPtr.i703, %if.then.i541 ]
  br label %do.body.i555

do.body.i555:                                     ; preds = %do.body.i555, %if.end.i547
  %310 = load ptr, ptr %m_dataBuf556, align 8
  store ptr %310, ptr %dataPtr.i531, align 8
  %311 = load ptr, ptr %utf8Convert558, align 8
  %312 = load ptr, ptr %m_dataBufEnd559, align 8
  %call.i556 = call i32 %311(ptr noundef nonnull %enc, ptr noundef nonnull %s.addr.i530, ptr noundef %306, ptr noundef nonnull %dataPtr.i531, ptr noundef %312) #24
  %313 = load ptr, ptr %s.addr.i530, align 8
  store ptr %313, ptr %eventEndPP.0.i549, align 8
  %314 = load ptr, ptr %m_defaultHandler584, align 8
  %315 = load ptr, ptr %m_handlerArg577, align 8
  %316 = load ptr, ptr %m_dataBuf556, align 8
  %317 = load ptr, ptr %dataPtr.i531, align 8
  %sub.ptr.lhs.cast.i557 = ptrtoint ptr %317 to i64
  %sub.ptr.rhs.cast.i558 = ptrtoint ptr %316 to i64
  %sub.ptr.sub.i559 = sub i64 %sub.ptr.lhs.cast.i557, %sub.ptr.rhs.cast.i558
  %conv.i560 = trunc i64 %sub.ptr.sub.i559 to i32
  call void %314(ptr noundef %315, ptr noundef %316, i32 noundef %conv.i560) #24
  %318 = load ptr, ptr %s.addr.i530, align 8
  store ptr %318, ptr %eventPP.0.i548, align 8
  %319 = icmp ugt i32 %call.i556, 1
  br i1 %319, label %do.body.i555, label %reportDefault.exit564, !llvm.loop !28

if.else9.i534:                                    ; preds = %if.then408
  %320 = load ptr, ptr %m_handlerArg577, align 8
  %sub.ptr.lhs.cast12.i537 = ptrtoint ptr %306 to i64
  %sub.ptr.rhs.cast13.i538 = ptrtoint ptr %305 to i64
  %sub.ptr.sub14.i539 = sub i64 %sub.ptr.lhs.cast12.i537, %sub.ptr.rhs.cast13.i538
  %conv15.i540 = trunc i64 %sub.ptr.sub14.i539 to i32
  call void %304(ptr noundef %320, ptr noundef %305, i32 noundef %conv15.i540) #24
  br label %reportDefault.exit564

reportDefault.exit564:                            ; preds = %do.body.i555, %if.else9.i534
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %s.addr.i530)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %dataPtr.i531)
  br label %if.end410

if.end410:                                        ; preds = %if.else405, %reportDefault.exit564, %if.end400
  %bindings412 = getelementptr inbounds %struct.tag, ptr %278, i64 0, i32 6
  %321 = load ptr, ptr %bindings412, align 8
  %tobool413.not816 = icmp eq ptr %321, null
  br i1 %tobool413.not816, label %while.end428, label %while.body414

while.body414:                                    ; preds = %if.end410, %if.end422
  %322 = phi ptr [ %332, %if.end422 ], [ %321, %if.end410 ]
  %323 = load ptr, ptr %m_endNamespaceDeclHandler, align 8
  %tobool416.not = icmp eq ptr %323, null
  br i1 %tobool416.not, label %if.end422, label %if.then417

if.then417:                                       ; preds = %while.body414
  %324 = load ptr, ptr %m_handlerArg577, align 8
  %325 = load ptr, ptr %322, align 8
  %326 = load ptr, ptr %325, align 8
  call void %323(ptr noundef %324, ptr noundef %326) #24
  %.pre878 = load ptr, ptr %bindings412, align 8
  br label %if.end422

if.end422:                                        ; preds = %if.then417, %while.body414
  %327 = phi ptr [ %.pre878, %if.then417 ], [ %322, %while.body414 ]
  %nextTagBinding = getelementptr inbounds %struct.binding, ptr %327, i64 0, i32 1
  %328 = load ptr, ptr %nextTagBinding, align 8
  store ptr %328, ptr %bindings412, align 8
  %329 = load ptr, ptr %m_freeBindingList, align 8
  %nextTagBinding425 = getelementptr inbounds %struct.binding, ptr %322, i64 0, i32 1
  store ptr %329, ptr %nextTagBinding425, align 8
  store ptr %322, ptr %m_freeBindingList, align 8
  %prevPrefixBinding = getelementptr inbounds %struct.binding, ptr %322, i64 0, i32 2
  %330 = load ptr, ptr %prevPrefixBinding, align 8
  %331 = load ptr, ptr %322, align 8
  %binding = getelementptr inbounds %struct.prefix, ptr %331, i64 0, i32 1
  store ptr %330, ptr %binding, align 8
  %332 = load ptr, ptr %bindings412, align 8
  %tobool413.not = icmp eq ptr %332, null
  br i1 %tobool413.not, label %while.end428, label %while.body414, !llvm.loop !62

while.end428:                                     ; preds = %if.end422, %if.end410
  %333 = load i32, ptr %m_tagLevel336, align 4
  %cmp430 = icmp eq i32 %333, 0
  br i1 %cmp430, label %land.lhs.true432, label %sw.epilog

land.lhs.true432:                                 ; preds = %while.end428
  %334 = load i32, ptr %m_parsingStatus433, align 8
  switch i32 %334, label %if.else444 [
    i32 2, label %sw.epilog
    i32 3, label %if.then442
  ]

if.then442:                                       ; preds = %land.lhs.true432
  store ptr @epilogProcessor, ptr %m_processor443, align 8
  br label %sw.epilog

if.else444:                                       ; preds = %land.lhs.true432
  %335 = load ptr, ptr %next, align 8
  %call445 = call i32 @epilogProcessor(ptr noundef nonnull %parser, ptr noundef %335, ptr noundef %end, ptr noundef %nextPtr), !range !32
  br label %return

sw.bb449:                                         ; preds = %if.end11
  %336 = load ptr, ptr %charRefNumber, align 8
  %337 = load ptr, ptr %s.addr, align 8
  %call450 = call i32 %336(ptr noundef nonnull %enc, ptr noundef %337) #24
  %cmp451 = icmp slt i32 %call450, 0
  br i1 %cmp451, label %return, label %if.end454

if.end454:                                        ; preds = %sw.bb449
  %338 = load ptr, ptr %m_characterDataHandler548, align 8
  %tobool456.not = icmp eq ptr %338, null
  br i1 %tobool456.not, label %if.else463, label %if.then457

if.then457:                                       ; preds = %if.end454
  %339 = load ptr, ptr %m_handlerArg577, align 8
  %call462 = call i32 @PyExpat_XmlUtf8Encode(i32 noundef %call450, ptr noundef nonnull %buf458) #24
  call void %338(ptr noundef %339, ptr noundef nonnull %buf458, i32 noundef %call462) #24
  br label %sw.epilog

if.else463:                                       ; preds = %if.end454
  %340 = load ptr, ptr %m_defaultHandler584, align 8
  %tobool465.not = icmp eq ptr %340, null
  br i1 %tobool465.not, label %sw.epilog, label %if.then466

if.then466:                                       ; preds = %if.else463
  %341 = load ptr, ptr %s.addr, align 8
  %342 = load ptr, ptr %next, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %s.addr.i565)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %dataPtr.i566)
  store ptr %341, ptr %s.addr.i565, align 8
  %343 = load i8, ptr %isUtf8551, align 4
  %tobool.not.i568 = icmp eq i8 %343, 0
  br i1 %tobool.not.i568, label %if.then.i576, label %if.else9.i569

if.then.i576:                                     ; preds = %if.then466
  %344 = load ptr, ptr %m_encoding, align 8
  %cmp.i578 = icmp eq ptr %344, %enc
  br i1 %cmp.i578, label %if.end.i582, label %if.else.i579

if.else.i579:                                     ; preds = %if.then.i576
  %345 = load ptr, ptr %m_openInternalEntities.i685, align 8
  %internalEventEndPtr.i581 = getelementptr inbounds %struct.open_internal_entity, ptr %345, i64 0, i32 1
  br label %if.end.i582

if.end.i582:                                      ; preds = %if.then.i576, %if.else.i579
  %eventPP.0.i583 = phi ptr [ %345, %if.else.i579 ], [ %m_eventPtr.i702, %if.then.i576 ]
  %eventEndPP.0.i584 = phi ptr [ %internalEventEndPtr.i581, %if.else.i579 ], [ %m_eventEndPtr.i703, %if.then.i576 ]
  br label %do.body.i590

do.body.i590:                                     ; preds = %do.body.i590, %if.end.i582
  %346 = load ptr, ptr %m_dataBuf556, align 8
  store ptr %346, ptr %dataPtr.i566, align 8
  %347 = load ptr, ptr %utf8Convert558, align 8
  %348 = load ptr, ptr %m_dataBufEnd559, align 8
  %call.i591 = call i32 %347(ptr noundef nonnull %enc, ptr noundef nonnull %s.addr.i565, ptr noundef %342, ptr noundef nonnull %dataPtr.i566, ptr noundef %348) #24
  %349 = load ptr, ptr %s.addr.i565, align 8
  store ptr %349, ptr %eventEndPP.0.i584, align 8
  %350 = load ptr, ptr %m_defaultHandler584, align 8
  %351 = load ptr, ptr %m_handlerArg577, align 8
  %352 = load ptr, ptr %m_dataBuf556, align 8
  %353 = load ptr, ptr %dataPtr.i566, align 8
  %sub.ptr.lhs.cast.i592 = ptrtoint ptr %353 to i64
  %sub.ptr.rhs.cast.i593 = ptrtoint ptr %352 to i64
  %sub.ptr.sub.i594 = sub i64 %sub.ptr.lhs.cast.i592, %sub.ptr.rhs.cast.i593
  %conv.i595 = trunc i64 %sub.ptr.sub.i594 to i32
  call void %350(ptr noundef %351, ptr noundef %352, i32 noundef %conv.i595) #24
  %354 = load ptr, ptr %s.addr.i565, align 8
  store ptr %354, ptr %eventPP.0.i583, align 8
  %355 = icmp ugt i32 %call.i591, 1
  br i1 %355, label %do.body.i590, label %reportDefault.exit599, !llvm.loop !28

if.else9.i569:                                    ; preds = %if.then466
  %356 = load ptr, ptr %m_handlerArg577, align 8
  %sub.ptr.lhs.cast12.i572 = ptrtoint ptr %342 to i64
  %sub.ptr.rhs.cast13.i573 = ptrtoint ptr %341 to i64
  %sub.ptr.sub14.i574 = sub i64 %sub.ptr.lhs.cast12.i572, %sub.ptr.rhs.cast13.i573
  %conv15.i575 = trunc i64 %sub.ptr.sub14.i574 to i32
  call void %340(ptr noundef %356, ptr noundef %341, i32 noundef %conv15.i575) #24
  br label %reportDefault.exit599

reportDefault.exit599:                            ; preds = %do.body.i590, %if.else9.i569
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %s.addr.i565)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %dataPtr.i566)
  br label %sw.epilog

sw.bb470:                                         ; preds = %if.end11
  %357 = load ptr, ptr %m_characterDataHandler548, align 8
  %tobool472.not = icmp eq ptr %357, null
  br i1 %tobool472.not, label %if.else477, label %if.then473

if.then473:                                       ; preds = %sw.bb470
  store i8 10, ptr %c474, align 1
  %358 = load ptr, ptr %m_handlerArg577, align 8
  call void %357(ptr noundef %358, ptr noundef nonnull %c474, i32 noundef 1) #24
  br label %sw.epilog

if.else477:                                       ; preds = %sw.bb470
  %359 = load ptr, ptr %m_defaultHandler584, align 8
  %tobool479.not = icmp eq ptr %359, null
  br i1 %tobool479.not, label %sw.epilog, label %if.then480

if.then480:                                       ; preds = %if.else477
  %360 = load ptr, ptr %s.addr, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %s.addr.i600)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %dataPtr.i601)
  store ptr %360, ptr %s.addr.i600, align 8
  %361 = load i8, ptr %isUtf8551, align 4
  %tobool.not.i603 = icmp eq i8 %361, 0
  br i1 %tobool.not.i603, label %if.then.i611, label %if.else9.i604

if.then.i611:                                     ; preds = %if.then480
  %362 = load ptr, ptr %m_encoding, align 8
  %cmp.i613 = icmp eq ptr %362, %enc
  br i1 %cmp.i613, label %if.end.i617, label %if.else.i614

if.else.i614:                                     ; preds = %if.then.i611
  %363 = load ptr, ptr %m_openInternalEntities.i685, align 8
  %internalEventEndPtr.i616 = getelementptr inbounds %struct.open_internal_entity, ptr %363, i64 0, i32 1
  br label %if.end.i617

if.end.i617:                                      ; preds = %if.then.i611, %if.else.i614
  %eventPP.0.i618 = phi ptr [ %363, %if.else.i614 ], [ %m_eventPtr.i702, %if.then.i611 ]
  %eventEndPP.0.i619 = phi ptr [ %internalEventEndPtr.i616, %if.else.i614 ], [ %m_eventEndPtr.i703, %if.then.i611 ]
  br label %do.body.i625

do.body.i625:                                     ; preds = %do.body.i625, %if.end.i617
  %364 = load ptr, ptr %m_dataBuf556, align 8
  store ptr %364, ptr %dataPtr.i601, align 8
  %365 = load ptr, ptr %utf8Convert558, align 8
  %366 = load ptr, ptr %m_dataBufEnd559, align 8
  %call.i626 = call i32 %365(ptr noundef nonnull %enc, ptr noundef nonnull %s.addr.i600, ptr noundef %13, ptr noundef nonnull %dataPtr.i601, ptr noundef %366) #24
  %367 = load ptr, ptr %s.addr.i600, align 8
  store ptr %367, ptr %eventEndPP.0.i619, align 8
  %368 = load ptr, ptr %m_defaultHandler584, align 8
  %369 = load ptr, ptr %m_handlerArg577, align 8
  %370 = load ptr, ptr %m_dataBuf556, align 8
  %371 = load ptr, ptr %dataPtr.i601, align 8
  %sub.ptr.lhs.cast.i627 = ptrtoint ptr %371 to i64
  %sub.ptr.rhs.cast.i628 = ptrtoint ptr %370 to i64
  %sub.ptr.sub.i629 = sub i64 %sub.ptr.lhs.cast.i627, %sub.ptr.rhs.cast.i628
  %conv.i630 = trunc i64 %sub.ptr.sub.i629 to i32
  call void %368(ptr noundef %369, ptr noundef %370, i32 noundef %conv.i630) #24
  %372 = load ptr, ptr %s.addr.i600, align 8
  store ptr %372, ptr %eventPP.0.i618, align 8
  %373 = icmp ugt i32 %call.i626, 1
  br i1 %373, label %do.body.i625, label %reportDefault.exit634, !llvm.loop !28

if.else9.i604:                                    ; preds = %if.then480
  %374 = load ptr, ptr %m_handlerArg577, align 8
  %sub.ptr.lhs.cast12.i607 = ptrtoint ptr %13 to i64
  %sub.ptr.rhs.cast13.i608 = ptrtoint ptr %360 to i64
  %sub.ptr.sub14.i609 = sub i64 %sub.ptr.lhs.cast12.i607, %sub.ptr.rhs.cast13.i608
  %conv15.i610 = trunc i64 %sub.ptr.sub14.i609 to i32
  call void %359(ptr noundef %374, ptr noundef %360, i32 noundef %conv15.i610) #24
  br label %reportDefault.exit634

reportDefault.exit634:                            ; preds = %do.body.i625, %if.else9.i604
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %s.addr.i600)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %dataPtr.i601)
  br label %sw.epilog

sw.bb483:                                         ; preds = %if.end11
  %375 = load ptr, ptr %m_startCdataSectionHandler, align 8
  %tobool485.not = icmp eq ptr %375, null
  br i1 %tobool485.not, label %if.else489, label %if.then486

if.then486:                                       ; preds = %sw.bb483
  %376 = load ptr, ptr %m_handlerArg577, align 8
  call void %375(ptr noundef %376) #24
  br label %if.end494

if.else489:                                       ; preds = %sw.bb483
  %377 = load ptr, ptr %m_defaultHandler584, align 8
  %tobool491.not = icmp eq ptr %377, null
  br i1 %tobool491.not, label %if.end494, label %if.then492

if.then492:                                       ; preds = %if.else489
  %378 = load ptr, ptr %s.addr, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %s.addr.i635)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %dataPtr.i636)
  store ptr %378, ptr %s.addr.i635, align 8
  %379 = load i8, ptr %isUtf8551, align 4
  %tobool.not.i638 = icmp eq i8 %379, 0
  br i1 %tobool.not.i638, label %if.then.i646, label %if.else9.i639

if.then.i646:                                     ; preds = %if.then492
  %380 = load ptr, ptr %m_encoding, align 8
  %cmp.i648 = icmp eq ptr %380, %enc
  br i1 %cmp.i648, label %if.end.i652, label %if.else.i649

if.else.i649:                                     ; preds = %if.then.i646
  %381 = load ptr, ptr %m_openInternalEntities.i685, align 8
  %internalEventEndPtr.i651 = getelementptr inbounds %struct.open_internal_entity, ptr %381, i64 0, i32 1
  br label %if.end.i652

if.end.i652:                                      ; preds = %if.then.i646, %if.else.i649
  %eventPP.0.i653 = phi ptr [ %381, %if.else.i649 ], [ %m_eventPtr.i702, %if.then.i646 ]
  %eventEndPP.0.i654 = phi ptr [ %internalEventEndPtr.i651, %if.else.i649 ], [ %m_eventEndPtr.i703, %if.then.i646 ]
  br label %do.body.i660

do.body.i660:                                     ; preds = %do.body.i660, %if.end.i652
  %382 = load ptr, ptr %m_dataBuf556, align 8
  store ptr %382, ptr %dataPtr.i636, align 8
  %383 = load ptr, ptr %utf8Convert558, align 8
  %384 = load ptr, ptr %m_dataBufEnd559, align 8
  %call.i661 = call i32 %383(ptr noundef nonnull %enc, ptr noundef nonnull %s.addr.i635, ptr noundef %13, ptr noundef nonnull %dataPtr.i636, ptr noundef %384) #24
  %385 = load ptr, ptr %s.addr.i635, align 8
  store ptr %385, ptr %eventEndPP.0.i654, align 8
  %386 = load ptr, ptr %m_defaultHandler584, align 8
  %387 = load ptr, ptr %m_handlerArg577, align 8
  %388 = load ptr, ptr %m_dataBuf556, align 8
  %389 = load ptr, ptr %dataPtr.i636, align 8
  %sub.ptr.lhs.cast.i662 = ptrtoint ptr %389 to i64
  %sub.ptr.rhs.cast.i663 = ptrtoint ptr %388 to i64
  %sub.ptr.sub.i664 = sub i64 %sub.ptr.lhs.cast.i662, %sub.ptr.rhs.cast.i663
  %conv.i665 = trunc i64 %sub.ptr.sub.i664 to i32
  call void %386(ptr noundef %387, ptr noundef %388, i32 noundef %conv.i665) #24
  %390 = load ptr, ptr %s.addr.i635, align 8
  store ptr %390, ptr %eventPP.0.i653, align 8
  %391 = icmp ugt i32 %call.i661, 1
  br i1 %391, label %do.body.i660, label %reportDefault.exit669, !llvm.loop !28

if.else9.i639:                                    ; preds = %if.then492
  %392 = load ptr, ptr %m_handlerArg577, align 8
  %sub.ptr.lhs.cast12.i642 = ptrtoint ptr %13 to i64
  %sub.ptr.rhs.cast13.i643 = ptrtoint ptr %378 to i64
  %sub.ptr.sub14.i644 = sub i64 %sub.ptr.lhs.cast12.i642, %sub.ptr.rhs.cast13.i643
  %conv15.i645 = trunc i64 %sub.ptr.sub14.i644 to i32
  call void %377(ptr noundef %392, ptr noundef %378, i32 noundef %conv15.i645) #24
  br label %reportDefault.exit669

reportDefault.exit669:                            ; preds = %do.body.i660, %if.else9.i639
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %s.addr.i635)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %dataPtr.i636)
  br label %if.end494

if.end494:                                        ; preds = %if.else489, %reportDefault.exit669, %if.then486
  %call495 = call fastcc i32 @doCdataSection(ptr noundef nonnull %parser, ptr noundef nonnull %enc, ptr noundef nonnull %next, ptr noundef %end, ptr noundef %nextPtr, i8 noundef zeroext %haveMore, i32 noundef %account), !range !32
  %cmp496.not = icmp eq i32 %call495, 0
  br i1 %cmp496.not, label %if.else499, label %return

if.else499:                                       ; preds = %if.end494
  %393 = load ptr, ptr %next, align 8
  %tobool500.not = icmp eq ptr %393, null
  br i1 %tobool500.not, label %if.then501, label %sw.epilog

if.then501:                                       ; preds = %if.else499
  store ptr @cdataSectionProcessor, ptr %m_processor443, align 8
  br label %return

sw.bb505:                                         ; preds = %if.end11
  br i1 %tobool.not, label %if.end508, label %if.then507

if.then507:                                       ; preds = %sw.bb505
  %394 = load ptr, ptr %s.addr, align 8
  store ptr %394, ptr %nextPtr, align 8
  br label %return

if.end508:                                        ; preds = %sw.bb505
  %395 = load ptr, ptr %m_characterDataHandler548, align 8
  %tobool510.not = icmp eq ptr %395, null
  br i1 %tobool510.not, label %if.else532, label %if.then511

if.then511:                                       ; preds = %if.end508
  %396 = load i8, ptr %isUtf8551, align 4
  %tobool512.not = icmp eq i8 %396, 0
  br i1 %tobool512.not, label %if.then513, label %if.else524

if.then513:                                       ; preds = %if.then511
  %397 = load ptr, ptr %m_dataBuf556, align 8
  store ptr %397, ptr %dataPtr, align 8
  %398 = load ptr, ptr %utf8Convert558, align 8
  %399 = load ptr, ptr %m_dataBufEnd559, align 8
  %call515 = call i32 %398(ptr noundef nonnull %enc, ptr noundef nonnull %s.addr, ptr noundef %end, ptr noundef nonnull %dataPtr, ptr noundef %399) #24
  %400 = load ptr, ptr %m_characterDataHandler548, align 8
  %401 = load ptr, ptr %m_handlerArg577, align 8
  %402 = load ptr, ptr %m_dataBuf556, align 8
  %403 = load ptr, ptr %dataPtr, align 8
  %sub.ptr.lhs.cast520 = ptrtoint ptr %403 to i64
  %sub.ptr.rhs.cast521 = ptrtoint ptr %402 to i64
  %sub.ptr.sub522 = sub i64 %sub.ptr.lhs.cast520, %sub.ptr.rhs.cast521
  %conv523 = trunc i64 %sub.ptr.sub522 to i32
  call void %400(ptr noundef %401, ptr noundef %402, i32 noundef %conv523) #24
  br label %if.end537

if.else524:                                       ; preds = %if.then511
  %404 = load ptr, ptr %m_handlerArg577, align 8
  %405 = load ptr, ptr %s.addr, align 8
  %sub.ptr.lhs.cast527 = ptrtoint ptr %end to i64
  %sub.ptr.rhs.cast528 = ptrtoint ptr %405 to i64
  %sub.ptr.sub529 = sub i64 %sub.ptr.lhs.cast527, %sub.ptr.rhs.cast528
  %conv530 = trunc i64 %sub.ptr.sub529 to i32
  call void %395(ptr noundef %404, ptr noundef %405, i32 noundef %conv530) #24
  br label %if.end537

if.else532:                                       ; preds = %if.end508
  %406 = load ptr, ptr %m_defaultHandler584, align 8
  %tobool534.not = icmp eq ptr %406, null
  br i1 %tobool534.not, label %if.end537, label %if.then535

if.then535:                                       ; preds = %if.else532
  %407 = load ptr, ptr %s.addr, align 8
  call fastcc void @reportDefault(ptr noundef nonnull %parser, ptr noundef nonnull %enc, ptr noundef %407, ptr noundef %end)
  br label %if.end537

if.end537:                                        ; preds = %if.else532, %if.then535, %if.then513, %if.else524
  %cmp538 = icmp eq i32 %startTagLevel, 0
  br i1 %cmp538, label %if.then540, label %if.end541

if.then540:                                       ; preds = %if.end537
  store ptr %end, ptr %eventPP.0, align 8
  br label %return

if.end541:                                        ; preds = %if.end537
  %408 = load i32, ptr %m_tagLevel336, align 4
  %cmp543.not = icmp eq i32 %408, %startTagLevel
  br i1 %cmp543.not, label %if.end546, label %if.then545

if.then545:                                       ; preds = %if.end541
  store ptr %end, ptr %eventPP.0, align 8
  br label %return

if.end546:                                        ; preds = %if.end541
  store ptr %end, ptr %nextPtr, align 8
  br label %return

sw.bb547:                                         ; preds = %if.end11
  %409 = load ptr, ptr %m_characterDataHandler548, align 8
  %tobool549.not = icmp eq ptr %409, null
  br i1 %tobool549.not, label %if.else583, label %if.then550

if.then550:                                       ; preds = %sw.bb547
  %410 = load i8, ptr %isUtf8551, align 4
  %tobool552.not = icmp eq i8 %410, 0
  br i1 %tobool552.not, label %for.cond554, label %if.else576

for.cond554:                                      ; preds = %if.then550, %if.end574
  %411 = phi ptr [ %.pre876, %if.end574 ], [ %13, %if.then550 ]
  %412 = load ptr, ptr %m_dataBuf556, align 8
  store ptr %412, ptr %dataPtr555, align 8
  %413 = load ptr, ptr %utf8Convert558, align 8
  %414 = load ptr, ptr %m_dataBufEnd559, align 8
  %call560 = call i32 %413(ptr noundef nonnull %enc, ptr noundef nonnull %s.addr, ptr noundef %411, ptr noundef nonnull %dataPtr555, ptr noundef %414) #24
  %415 = load ptr, ptr %s.addr, align 8
  store ptr %415, ptr %eventEndPP.0, align 8
  %416 = load ptr, ptr %m_handlerArg577, align 8
  %417 = load ptr, ptr %m_dataBuf556, align 8
  %418 = load ptr, ptr %dataPtr555, align 8
  %sub.ptr.lhs.cast564 = ptrtoint ptr %418 to i64
  %sub.ptr.rhs.cast565 = ptrtoint ptr %417 to i64
  %sub.ptr.sub566 = sub i64 %sub.ptr.lhs.cast564, %sub.ptr.rhs.cast565
  %conv567 = trunc i64 %sub.ptr.sub566 to i32
  call void %409(ptr noundef %416, ptr noundef %417, i32 noundef %conv567) #24
  %or.cond4 = icmp ult i32 %call560, 2
  br i1 %or.cond4, label %sw.epilog, label %if.end574

if.end574:                                        ; preds = %for.cond554
  %419 = load ptr, ptr %s.addr, align 8
  store ptr %419, ptr %eventPP.0, align 8
  %.pre876 = load ptr, ptr %next, align 8
  br label %for.cond554

if.else576:                                       ; preds = %if.then550
  %420 = load ptr, ptr %m_handlerArg577, align 8
  %421 = load ptr, ptr %s.addr, align 8
  %sub.ptr.lhs.cast578 = ptrtoint ptr %13 to i64
  %sub.ptr.rhs.cast579 = ptrtoint ptr %421 to i64
  %sub.ptr.sub580 = sub i64 %sub.ptr.lhs.cast578, %sub.ptr.rhs.cast579
  %conv581 = trunc i64 %sub.ptr.sub580 to i32
  call void %409(ptr noundef %420, ptr noundef %421, i32 noundef %conv581) #24
  br label %sw.epilog

if.else583:                                       ; preds = %sw.bb547
  %422 = load ptr, ptr %m_defaultHandler584, align 8
  %tobool585.not = icmp eq ptr %422, null
  br i1 %tobool585.not, label %sw.epilog, label %if.then586

if.then586:                                       ; preds = %if.else583
  %423 = load ptr, ptr %s.addr, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %s.addr.i670)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %dataPtr.i671)
  store ptr %423, ptr %s.addr.i670, align 8
  %424 = load i8, ptr %isUtf8551, align 4
  %tobool.not.i673 = icmp eq i8 %424, 0
  br i1 %tobool.not.i673, label %if.then.i681, label %if.else9.i674

if.then.i681:                                     ; preds = %if.then586
  %425 = load ptr, ptr %m_encoding, align 8
  %cmp.i683 = icmp eq ptr %425, %enc
  br i1 %cmp.i683, label %if.end.i687, label %if.else.i684

if.else.i684:                                     ; preds = %if.then.i681
  %426 = load ptr, ptr %m_openInternalEntities.i685, align 8
  %internalEventEndPtr.i686 = getelementptr inbounds %struct.open_internal_entity, ptr %426, i64 0, i32 1
  br label %if.end.i687

if.end.i687:                                      ; preds = %if.then.i681, %if.else.i684
  %eventPP.0.i688 = phi ptr [ %426, %if.else.i684 ], [ %m_eventPtr.i702, %if.then.i681 ]
  %eventEndPP.0.i689 = phi ptr [ %internalEventEndPtr.i686, %if.else.i684 ], [ %m_eventEndPtr.i703, %if.then.i681 ]
  br label %do.body.i695

do.body.i695:                                     ; preds = %do.body.i695, %if.end.i687
  %427 = load ptr, ptr %m_dataBuf556, align 8
  store ptr %427, ptr %dataPtr.i671, align 8
  %428 = load ptr, ptr %utf8Convert558, align 8
  %429 = load ptr, ptr %m_dataBufEnd559, align 8
  %call.i696 = call i32 %428(ptr noundef nonnull %enc, ptr noundef nonnull %s.addr.i670, ptr noundef %13, ptr noundef nonnull %dataPtr.i671, ptr noundef %429) #24
  %430 = load ptr, ptr %s.addr.i670, align 8
  store ptr %430, ptr %eventEndPP.0.i689, align 8
  %431 = load ptr, ptr %m_defaultHandler584, align 8
  %432 = load ptr, ptr %m_handlerArg577, align 8
  %433 = load ptr, ptr %m_dataBuf556, align 8
  %434 = load ptr, ptr %dataPtr.i671, align 8
  %sub.ptr.lhs.cast.i697 = ptrtoint ptr %434 to i64
  %sub.ptr.rhs.cast.i698 = ptrtoint ptr %433 to i64
  %sub.ptr.sub.i699 = sub i64 %sub.ptr.lhs.cast.i697, %sub.ptr.rhs.cast.i698
  %conv.i700 = trunc i64 %sub.ptr.sub.i699 to i32
  call void %431(ptr noundef %432, ptr noundef %433, i32 noundef %conv.i700) #24
  %435 = load ptr, ptr %s.addr.i670, align 8
  store ptr %435, ptr %eventPP.0.i688, align 8
  %436 = icmp ugt i32 %call.i696, 1
  br i1 %436, label %do.body.i695, label %reportDefault.exit704, !llvm.loop !28

if.else9.i674:                                    ; preds = %if.then586
  %437 = load ptr, ptr %m_handlerArg577, align 8
  %sub.ptr.lhs.cast12.i677 = ptrtoint ptr %13 to i64
  %sub.ptr.rhs.cast13.i678 = ptrtoint ptr %423 to i64
  %sub.ptr.sub14.i679 = sub i64 %sub.ptr.lhs.cast12.i677, %sub.ptr.rhs.cast13.i678
  %conv15.i680 = trunc i64 %sub.ptr.sub14.i679 to i32
  call void %422(ptr noundef %437, ptr noundef %423, i32 noundef %conv15.i680) #24
  br label %reportDefault.exit704

reportDefault.exit704:                            ; preds = %do.body.i695, %if.else9.i674
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %s.addr.i670)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %dataPtr.i671)
  br label %sw.epilog

sw.bb589:                                         ; preds = %if.end11
  %438 = load ptr, ptr %s.addr, align 8
  %call590 = call fastcc i32 @reportProcessingInstruction(ptr noundef %parser, ptr noundef nonnull %enc, ptr noundef %438, ptr noundef %13), !range !17
  %tobool591.not = icmp eq i32 %call590, 0
  br i1 %tobool591.not, label %return, label %sw.epilog

sw.bb594:                                         ; preds = %if.end11
  %439 = load ptr, ptr %s.addr, align 8
  %call595 = call fastcc i32 @reportComment(ptr noundef %parser, ptr noundef nonnull %enc, ptr noundef %439, ptr noundef %13), !range !17
  %tobool596.not = icmp eq i32 %call595, 0
  br i1 %tobool596.not, label %return, label %sw.epilog

sw.default:                                       ; preds = %if.end11
  %440 = load ptr, ptr %m_defaultHandler584, align 8
  %tobool600.not = icmp eq ptr %440, null
  br i1 %tobool600.not, label %sw.epilog, label %if.then601

if.then601:                                       ; preds = %sw.default
  %441 = load ptr, ptr %s.addr, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %s.addr.i705)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %dataPtr.i706)
  store ptr %441, ptr %s.addr.i705, align 8
  %442 = load i8, ptr %isUtf8551, align 4
  %tobool.not.i708 = icmp eq i8 %442, 0
  br i1 %tobool.not.i708, label %if.then.i716, label %if.else9.i709

if.then.i716:                                     ; preds = %if.then601
  %443 = load ptr, ptr %m_encoding, align 8
  %cmp.i718 = icmp eq ptr %443, %enc
  br i1 %cmp.i718, label %if.end.i722, label %if.else.i719

if.else.i719:                                     ; preds = %if.then.i716
  %444 = load ptr, ptr %m_openInternalEntities.i685, align 8
  %internalEventEndPtr.i721 = getelementptr inbounds %struct.open_internal_entity, ptr %444, i64 0, i32 1
  br label %if.end.i722

if.end.i722:                                      ; preds = %if.then.i716, %if.else.i719
  %eventPP.0.i723 = phi ptr [ %444, %if.else.i719 ], [ %m_eventPtr.i702, %if.then.i716 ]
  %eventEndPP.0.i724 = phi ptr [ %internalEventEndPtr.i721, %if.else.i719 ], [ %m_eventEndPtr.i703, %if.then.i716 ]
  br label %do.body.i730

do.body.i730:                                     ; preds = %do.body.i730, %if.end.i722
  %445 = load ptr, ptr %m_dataBuf556, align 8
  store ptr %445, ptr %dataPtr.i706, align 8
  %446 = load ptr, ptr %utf8Convert558, align 8
  %447 = load ptr, ptr %m_dataBufEnd559, align 8
  %call.i731 = call i32 %446(ptr noundef nonnull %enc, ptr noundef nonnull %s.addr.i705, ptr noundef %13, ptr noundef nonnull %dataPtr.i706, ptr noundef %447) #24
  %448 = load ptr, ptr %s.addr.i705, align 8
  store ptr %448, ptr %eventEndPP.0.i724, align 8
  %449 = load ptr, ptr %m_defaultHandler584, align 8
  %450 = load ptr, ptr %m_handlerArg577, align 8
  %451 = load ptr, ptr %m_dataBuf556, align 8
  %452 = load ptr, ptr %dataPtr.i706, align 8
  %sub.ptr.lhs.cast.i732 = ptrtoint ptr %452 to i64
  %sub.ptr.rhs.cast.i733 = ptrtoint ptr %451 to i64
  %sub.ptr.sub.i734 = sub i64 %sub.ptr.lhs.cast.i732, %sub.ptr.rhs.cast.i733
  %conv.i735 = trunc i64 %sub.ptr.sub.i734 to i32
  call void %449(ptr noundef %450, ptr noundef %451, i32 noundef %conv.i735) #24
  %453 = load ptr, ptr %s.addr.i705, align 8
  store ptr %453, ptr %eventPP.0.i723, align 8
  %454 = icmp ugt i32 %call.i731, 1
  br i1 %454, label %do.body.i730, label %reportDefault.exit739, !llvm.loop !28

if.else9.i709:                                    ; preds = %if.then601
  %455 = load ptr, ptr %m_handlerArg577, align 8
  %sub.ptr.lhs.cast12.i712 = ptrtoint ptr %13 to i64
  %sub.ptr.rhs.cast13.i713 = ptrtoint ptr %441 to i64
  %sub.ptr.sub14.i714 = sub i64 %sub.ptr.lhs.cast12.i712, %sub.ptr.rhs.cast13.i713
  %conv15.i715 = trunc i64 %sub.ptr.sub14.i714 to i32
  call void %440(ptr noundef %455, ptr noundef %441, i32 noundef %conv15.i715) #24
  br label %reportDefault.exit739

reportDefault.exit739:                            ; preds = %do.body.i730, %if.else9.i709
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %s.addr.i705)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %dataPtr.i706)
  br label %sw.epilog

sw.epilog:                                        ; preds = %for.cond554, %land.lhs.true432, %land.lhs.true322, %sw.default, %reportDefault.exit739, %sw.bb594, %sw.bb589, %if.else576, %reportDefault.exit704, %if.else583, %if.else499, %if.then473, %reportDefault.exit634, %if.else477, %if.then457, %reportDefault.exit599, %if.else463, %if.then442, %while.end428, %freeBindings.exit529, %if.then330, %if.end138, %if.else161, %if.then164, %if.end157, %if.then128, %if.then135, %if.else132, %if.then105, %if.then111, %if.else108, %if.then65, %reportDefault.exit, %if.else68, %poolClear.exit
  %456 = load ptr, ptr %next, align 8
  store ptr %456, ptr %s.addr, align 8
  store ptr %456, ptr %eventPP.0, align 8
  %457 = load i32, ptr %m_parsingStatus433, align 8
  switch i32 %457, label %for.cond [
    i32 3, label %sw.bb605
    i32 2, label %return
  ]

sw.bb605:                                         ; preds = %sw.epilog
  store ptr %456, ptr %nextPtr, align 8
  br label %return

return:                                           ; preds = %land.lhs.true.i, %poolAppend.exit.i, %sw.epilog, %sw.bb594, %sw.bb589, %if.end494, %if.end11, %sw.bb449, %sw.bb335, %poolStoreString.exit459, %if.then218, %if.else175, %if.end152, %getContext.exit, %if.end138, %if.end118, %if.end115, %if.else96, %if.then93, %poolStoreString.exit, %land.lhs.true.i451, %poolAppend.exit.i444, %if.end220, %if.end.i464, %poolAppend.exit.thread.i442, %poolAppend.exit.thread.i, %if.then288, %getContext.exit.thread, %accountingGetCurrentAmplification.exit.i.i, %getRootParserOf.exit.i.i, %sw.bb49, %sw.bb45, %if.end34, %if.then37, %if.end26, %if.end22, %sw.bb605, %if.end546, %if.then545, %if.then540, %if.then507, %if.then501, %if.else444, %if.then358, %if.else331, %if.then185, %if.then51, %if.then47, %sw.bb44, %if.end42, %if.then33, %if.end30, %if.then13
  %retval.0 = phi i32 [ 0, %sw.bb605 ], [ 0, %if.then507 ], [ 3, %if.then540 ], [ 13, %if.then545 ], [ 0, %if.end546 ], [ 0, %if.then501 ], [ 7, %if.then358 ], [ %call445, %if.else444 ], [ %call332, %if.else331 ], [ 1, %if.then185 ], [ 0, %if.then51 ], [ 0, %if.then47 ], [ 4, %sw.bb44 ], [ 0, %if.then33 ], [ 0, %if.end42 ], [ 0, %if.then13 ], [ 0, %if.end30 ], [ 3, %if.end22 ], [ 13, %if.end26 ], [ 13, %if.then37 ], [ 3, %if.end34 ], [ 5, %sw.bb45 ], [ 6, %sw.bb49 ], [ 43, %getRootParserOf.exit.i.i ], [ 43, %accountingGetCurrentAmplification.exit.i.i ], [ 1, %getContext.exit.thread ], [ %call285, %if.then288 ], [ 1, %poolAppend.exit.thread.i ], [ 1, %poolAppend.exit.thread.i442 ], [ %call285, %if.end.i464 ], [ 1, %if.end220 ], [ 1, %poolAppend.exit.i444 ], [ 1, %land.lhs.true.i451 ], [ 1, %land.lhs.true.i ], [ 1, %poolAppend.exit.i ], [ 35, %sw.epilog ], [ 1, %sw.bb594 ], [ 1, %sw.bb589 ], [ %call495, %if.end494 ], [ 17, %if.end11 ], [ 14, %sw.bb449 ], [ 13, %sw.bb335 ], [ 1, %poolStoreString.exit459 ], [ %call245, %if.then218 ], [ 1, %if.else175 ], [ 21, %if.end152 ], [ 1, %getContext.exit ], [ %call139, %if.end138 ], [ 15, %if.end118 ], [ 12, %if.end115 ], [ 24, %if.else96 ], [ 11, %if.then93 ], [ 1, %poolStoreString.exit ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal fastcc zeroext i8 @storeRawNames(ptr nocapture noundef readonly %parser) unnamed_addr #0 {
entry:
  %m_tagStack = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 67
  %realloc_fcn = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 3, i32 1
  %tag.035 = load ptr, ptr %m_tagStack, align 8
  %tobool.not36 = icmp eq ptr %tag.035, null
  br i1 %tobool.not36, label %return, label %while.body

while.body:                                       ; preds = %entry, %if.end50
  %tag.037 = phi ptr [ %tag.0, %if.end50 ], [ %tag.035, %entry ]
  %name = getelementptr inbounds %struct.tag, ptr %tag.037, i64 0, i32 3
  %strLen = getelementptr inbounds %struct.tag, ptr %tag.037, i64 0, i32 3, i32 3
  %0 = load i32, ptr %strLen, align 8
  %add = add i32 %0, 1
  %conv = sext i32 %add to i64
  %buf = getelementptr inbounds %struct.tag, ptr %tag.037, i64 0, i32 4
  %1 = load ptr, ptr %buf, align 8
  %add.ptr = getelementptr i8, ptr %1, i64 %conv
  %rawName = getelementptr inbounds %struct.tag, ptr %tag.037, i64 0, i32 1
  %2 = load ptr, ptr %rawName, align 8
  %cmp = icmp eq ptr %2, %add.ptr
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %while.body
  %rawNameLength = getelementptr inbounds %struct.tag, ptr %tag.037, i64 0, i32 2
  %3 = load i32, ptr %rawNameLength, align 8
  %conv3 = sext i32 %3 to i64
  %sub = sub nsw i64 2147483647, %conv
  %cmp6 = icmp ult i64 %sub, %conv3
  br i1 %cmp6, label %return, label %if.end9

if.end9:                                          ; preds = %if.end
  %add11 = add i32 %3, %add
  %conv12 = sext i32 %add11 to i64
  %bufEnd = getelementptr inbounds %struct.tag, ptr %tag.037, i64 0, i32 5
  %4 = load ptr, ptr %bufEnd, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %4 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp14 = icmp slt i64 %sub.ptr.sub, %conv12
  br i1 %cmp14, label %if.then16, label %if.end50

if.then16:                                        ; preds = %if.end9
  %5 = load ptr, ptr %realloc_fcn, align 8
  %call = tail call ptr %5(ptr noundef %1, i64 noundef %conv12) #24
  %cmp19 = icmp eq ptr %call, null
  br i1 %cmp19, label %return, label %if.end22

if.end22:                                         ; preds = %if.then16
  %6 = load ptr, ptr %name, align 8
  %7 = load ptr, ptr %buf, align 8
  %cmp25 = icmp eq ptr %6, %7
  br i1 %cmp25, label %if.then27, label %if.end30

if.then27:                                        ; preds = %if.end22
  store ptr %call, ptr %name, align 8
  br label %if.end30

if.end30:                                         ; preds = %if.then27, %if.end22
  %localPart = getelementptr inbounds %struct.tag, ptr %tag.037, i64 0, i32 3, i32 1
  %8 = load ptr, ptr %localPart, align 8
  %tobool32.not = icmp eq ptr %8, null
  br i1 %tobool32.not, label %if.end43, label %if.then33

if.then33:                                        ; preds = %if.end30
  %sub.ptr.lhs.cast37 = ptrtoint ptr %8 to i64
  %sub.ptr.rhs.cast38 = ptrtoint ptr %7 to i64
  %sub.ptr.sub39 = sub i64 %sub.ptr.lhs.cast37, %sub.ptr.rhs.cast38
  %add.ptr40 = getelementptr i8, ptr %call, i64 %sub.ptr.sub39
  store ptr %add.ptr40, ptr %localPart, align 8
  br label %if.end43

if.end43:                                         ; preds = %if.then33, %if.end30
  store ptr %call, ptr %buf, align 8
  %add.ptr46 = getelementptr i8, ptr %call, i64 %conv12
  store ptr %add.ptr46, ptr %bufEnd, align 8
  %add.ptr49 = getelementptr i8, ptr %call, i64 %conv
  %.pre = load ptr, ptr %rawName, align 8
  %.pre41 = load i32, ptr %rawNameLength, align 8
  %.pre42 = sext i32 %.pre41 to i64
  br label %if.end50

if.end50:                                         ; preds = %if.end43, %if.end9
  %conv53.pre-phi = phi i64 [ %.pre42, %if.end43 ], [ %conv3, %if.end9 ]
  %9 = phi ptr [ %.pre, %if.end43 ], [ %2, %if.end9 ]
  %rawNameBuf.0 = phi ptr [ %add.ptr49, %if.end43 ], [ %add.ptr, %if.end9 ]
  tail call void @llvm.memcpy.p0.p0.i64(ptr align 1 %rawNameBuf.0, ptr align 1 %9, i64 %conv53.pre-phi, i1 false)
  store ptr %rawNameBuf.0, ptr %rawName, align 8
  %tag.0 = load ptr, ptr %tag.037, align 8
  %tobool.not = icmp eq ptr %tag.0, null
  br i1 %tobool.not, label %return, label %while.body, !llvm.loop !46

return:                                           ; preds = %if.end, %if.then16, %while.body, %if.end50, %entry
  %retval.0 = phi i8 [ 1, %entry ], [ 1, %if.end50 ], [ 1, %while.body ], [ 0, %if.then16 ], [ 0, %if.end ]
  ret i8 %retval.0
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @storeAtts(ptr noundef %parser, ptr noundef %enc, ptr noundef %attStr, ptr nocapture noundef %tagNamePtr, ptr nocapture noundef %bindingsPtr, i32 noundef %account) unnamed_addr #0 {
entry:
  %ptr.addr.i.i = alloca ptr, align 8
  %sip_state = alloca %struct.siphash, align 8
  %m_dtd = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 65
  %0 = load ptr, ptr %m_dtd, align 8
  %elementTypes = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 1
  %1 = load ptr, ptr %tagNamePtr, align 8
  %size.i = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 1, i32 2
  %2 = load i64, ptr %size.i, align 8
  %cmp.i = icmp eq i64 %2, 0
  br i1 %cmp.i, label %if.then, label %if.else.i

if.else.i:                                        ; preds = %entry
  %call12.i = tail call fastcc i64 @hash(ptr noundef nonnull %parser, ptr noundef %1)
  %3 = load i64, ptr %size.i, align 8
  %sub14.i = add i64 %3, -1
  %and15.i = and i64 %sub14.i, %call12.i
  %4 = load ptr, ptr %elementTypes, align 8
  %arrayidx111.i = getelementptr ptr, ptr %4, i64 %and15.i
  %5 = load ptr, ptr %arrayidx111.i, align 8
  %tobool17.not112.i = icmp eq ptr %5, null
  br i1 %tobool17.not112.i, label %if.then, label %while.body.lr.ph.i

while.body.lr.ph.i:                               ; preds = %if.else.i
  %6 = load i8, ptr %1, align 1
  %not.i = sub i64 0, %3
  %and29.i = and i64 %call12.i, %not.i
  %power30.i = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 1, i32 1
  %shr32.i = lshr i64 %sub14.i, 2
  br label %while.body.i

while.body.i:                                     ; preds = %if.end35.i, %while.body.lr.ph.i
  %7 = phi ptr [ %5, %while.body.lr.ph.i ], [ %15, %if.end35.i ]
  %i.0114.i = phi i64 [ %and15.i, %while.body.lr.ph.i ], [ %i.1.i, %if.end35.i ]
  %step.0113.i = phi i8 [ 0, %while.body.lr.ph.i ], [ %step.1.i, %if.end35.i ]
  %8 = load ptr, ptr %7, align 8
  %9 = load i8, ptr %8, align 1
  %cmp5.i.i = icmp eq i8 %6, %9
  br i1 %cmp5.i.i, label %for.body.i.i, label %if.end26.i

for.body.i.i:                                     ; preds = %while.body.i, %for.inc.i.i
  %10 = phi i8 [ %11, %for.inc.i.i ], [ %6, %while.body.i ]
  %s2.addr.07.i.i = phi ptr [ %incdec.ptr6.i.i, %for.inc.i.i ], [ %8, %while.body.i ]
  %s1.addr.06.i.i = phi ptr [ %incdec.ptr.i.i, %for.inc.i.i ], [ %1, %while.body.i ]
  %cmp4.i.i = icmp eq i8 %10, 0
  br i1 %cmp4.i.i, label %if.end15, label %for.inc.i.i

for.inc.i.i:                                      ; preds = %for.body.i.i
  %incdec.ptr.i.i = getelementptr i8, ptr %s1.addr.06.i.i, i64 1
  %incdec.ptr6.i.i = getelementptr i8, ptr %s2.addr.07.i.i, i64 1
  %11 = load i8, ptr %incdec.ptr.i.i, align 1
  %12 = load i8, ptr %incdec.ptr6.i.i, align 1
  %cmp.i.i = icmp eq i8 %11, %12
  br i1 %cmp.i.i, label %for.body.i.i, label %if.end26.i, !llvm.loop !14

if.end26.i:                                       ; preds = %for.inc.i.i, %while.body.i
  %tobool27.not.i = icmp eq i8 %step.0113.i, 0
  br i1 %tobool27.not.i, label %if.then28.i, label %if.end35.i

if.then28.i:                                      ; preds = %if.end26.i
  %13 = load i8, ptr %power30.i, align 8
  %conv.i = zext i8 %13 to i64
  %sub31.i = add nuw nsw i64 %conv.i, 4294967295
  %sh_prom.i = and i64 %sub31.i, 4294967295
  %shr.i = lshr i64 %and29.i, %sh_prom.i
  %and33.i = and i64 %shr.i, %shr32.i
  %14 = trunc i64 %and33.i to i8
  %conv34.i = or i8 %14, 1
  br label %if.end35.i

if.end35.i:                                       ; preds = %if.then28.i, %if.end26.i
  %step.1.i = phi i8 [ %step.0113.i, %if.end26.i ], [ %conv34.i, %if.then28.i ]
  %conv36.i = zext i8 %step.1.i to i64
  %cmp37.i = icmp ult i64 %i.0114.i, %conv36.i
  %i.1.p.v.i = select i1 %cmp37.i, i64 %3, i64 0
  %i.1.p.i = sub i64 %i.0114.i, %conv36.i
  %i.1.i = add i64 %i.1.p.v.i, %i.1.p.i
  %arrayidx.i = getelementptr ptr, ptr %4, i64 %i.1.i
  %15 = load ptr, ptr %arrayidx.i, align 8
  %tobool17.not.i = icmp eq ptr %15, null
  br i1 %tobool17.not.i, label %if.then, label %while.body.i, !llvm.loop !15

if.then:                                          ; preds = %if.end35.i, %if.else.i, %entry
  %pool = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 4
  %16 = load ptr, ptr %tagNamePtr, align 8
  %ptr.i = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 4, i32 3
  %end.i = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 4, i32 2
  br label %do.body.i

do.body.i:                                        ; preds = %cond.false.i, %if.then
  %s.addr.0.i = phi ptr [ %16, %if.then ], [ %incdec.ptr2.i, %cond.false.i ]
  %17 = load ptr, ptr %ptr.i, align 8
  %18 = load ptr, ptr %end.i, align 8
  %cmp.i344 = icmp eq ptr %17, %18
  br i1 %cmp.i344, label %land.lhs.true.i, label %cond.false.i

land.lhs.true.i:                                  ; preds = %do.body.i
  %call.i = tail call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool), !range !13
  %tobool.not.i = icmp eq i8 %call.i, 0
  br i1 %tobool.not.i, label %return, label %land.lhs.true.cond.false_crit_edge.i

land.lhs.true.cond.false_crit_edge.i:             ; preds = %land.lhs.true.i
  %.pre.i = load ptr, ptr %ptr.i, align 8
  br label %cond.false.i

cond.false.i:                                     ; preds = %land.lhs.true.cond.false_crit_edge.i, %do.body.i
  %19 = phi ptr [ %.pre.i, %land.lhs.true.cond.false_crit_edge.i ], [ %17, %do.body.i ]
  %20 = load i8, ptr %s.addr.0.i, align 1
  %incdec.ptr.i = getelementptr i8, ptr %19, i64 1
  store ptr %incdec.ptr.i, ptr %ptr.i, align 8
  store i8 %20, ptr %19, align 1
  %incdec.ptr2.i = getelementptr i8, ptr %s.addr.0.i, i64 1
  %21 = load i8, ptr %s.addr.0.i, align 1
  %tobool3.not.i = icmp eq i8 %21, 0
  br i1 %tobool3.not.i, label %poolCopyString.exit, label %do.body.i, !llvm.loop !12

poolCopyString.exit:                              ; preds = %cond.false.i
  %start.i = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 4, i32 4
  %22 = load ptr, ptr %start.i, align 8
  %23 = load ptr, ptr %ptr.i, align 8
  store ptr %23, ptr %start.i, align 8
  %tobool3.not = icmp eq ptr %22, null
  br i1 %tobool3.not, label %return, label %if.end

if.end:                                           ; preds = %poolCopyString.exit
  %call6 = tail call fastcc ptr @lookup(ptr noundef %parser, ptr noundef nonnull %elementTypes, ptr noundef nonnull %22, i64 noundef 40)
  %tobool7.not = icmp eq ptr %call6, null
  br i1 %tobool7.not, label %return, label %if.end9

if.end9:                                          ; preds = %if.end
  %m_ns = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 38
  %24 = load i8, ptr %m_ns, align 8
  %tobool10.not = icmp eq i8 %24, 0
  br i1 %tobool10.not, label %if.end15, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end9
  %call11 = tail call fastcc i32 @setElementTypePrefix(ptr noundef nonnull %parser, ptr noundef nonnull %call6), !range !17
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %return, label %if.end15

if.end15:                                         ; preds = %for.body.i.i, %if.end9, %land.lhs.true
  %elementType.0 = phi ptr [ %call6, %land.lhs.true ], [ %call6, %if.end9 ], [ %7, %for.body.i.i ]
  %nDefaultAtts16 = getelementptr inbounds %struct.ELEMENT_TYPE, ptr %elementType.0, i64 0, i32 3
  %25 = load i32, ptr %nDefaultAtts16, align 8
  %getAtts = getelementptr inbounds %struct.encoding, ptr %enc, i64 0, i32 5
  %26 = load ptr, ptr %getAtts, align 8
  %m_attsSize = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 71
  %27 = load i32, ptr %m_attsSize, align 8
  %m_atts = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 74
  %28 = load ptr, ptr %m_atts, align 8
  %call17 = tail call i32 %26(ptr noundef %enc, ptr noundef %attStr, i32 noundef %27, ptr noundef %28) #24
  %sub = sub i32 2147483647, %25
  %cmp = icmp sgt i32 %call17, %sub
  br i1 %cmp, label %return, label %if.end20

if.end20:                                         ; preds = %if.end15
  %add = add i32 %call17, %25
  %29 = load i32, ptr %m_attsSize, align 8
  %cmp22 = icmp sgt i32 %add, %29
  br i1 %cmp22, label %if.then24, label %if.end54

if.then24:                                        ; preds = %if.end20
  %cmp26 = icmp sgt i32 %25, 2147483631
  %sub29 = sub i32 2147483631, %25
  %cmp30 = icmp sgt i32 %call17, %sub29
  %or.cond = or i1 %cmp26, %cmp30
  br i1 %or.cond, label %return, label %if.end33

if.end33:                                         ; preds = %if.then24
  %add35 = add i32 %add, 16
  store i32 %add35, ptr %m_attsSize, align 8
  %realloc_fcn = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 3, i32 1
  %30 = load ptr, ptr %realloc_fcn, align 8
  %31 = load ptr, ptr %m_atts, align 8
  %conv39 = sext i32 %add35 to i64
  %mul = shl nsw i64 %conv39, 5
  %call40 = tail call ptr %30(ptr noundef %31, i64 noundef %mul) #24
  %cmp41 = icmp eq ptr %call40, null
  br i1 %cmp41, label %if.then43, label %if.end45

if.then43:                                        ; preds = %if.end33
  store i32 %29, ptr %m_attsSize, align 8
  br label %return

if.end45:                                         ; preds = %if.end33
  store ptr %call40, ptr %m_atts, align 8
  %cmp47 = icmp sgt i32 %call17, %29
  br i1 %cmp47, label %if.then49, label %if.end54

if.then49:                                        ; preds = %if.end45
  %32 = load ptr, ptr %getAtts, align 8
  %call52 = tail call i32 %32(ptr noundef nonnull %enc, ptr noundef %attStr, i32 noundef %call17, ptr noundef nonnull %call40) #24
  br label %if.end54

if.end54:                                         ; preds = %if.end45, %if.then49, %if.end20
  %33 = load ptr, ptr %m_atts, align 8
  %cmp56425 = icmp sgt i32 %call17, 0
  br i1 %cmp56425, label %for.body.lr.ph, label %for.end170

for.body.lr.ph:                                   ; preds = %if.end54
  %nameLength = getelementptr inbounds %struct.encoding, ptr %enc, i64 0, i32 3
  %m_tempPool124 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 79
  %ptr1.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 79, i32 3
  %utf8Convert.i.i = getelementptr inbounds %struct.encoding, ptr %enc, i64 0, i32 10
  %end4.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 79, i32 2
  %start.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 79, i32 4
  %cmp93423 = icmp slt i32 %25, 1
  %defaultAtts = getelementptr inbounds %struct.ELEMENT_TYPE, ptr %elementType.0, i64 0, i32 5
  %wide.trip.count504 = zext nneg i32 %call17 to i64
  %wide.trip.count = zext nneg i32 %25 to i64
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.inc168
  %indvars.iv501 = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next502, %for.inc168 ]
  %attIndex.0428 = phi i32 [ 0, %for.body.lr.ph ], [ %attIndex.1, %for.inc168 ]
  %nPrefixes.0426 = phi i32 [ 0, %for.body.lr.ph ], [ %nPrefixes.1, %for.inc168 ]
  %34 = load ptr, ptr %m_atts, align 8
  %arrayidx = getelementptr %struct.ATTRIBUTE, ptr %34, i64 %indvars.iv501
  %35 = load ptr, ptr %arrayidx, align 8
  %36 = load ptr, ptr %nameLength, align 8
  %call62 = call i32 %36(ptr noundef %enc, ptr noundef %35) #24
  %idx.ext = sext i32 %call62 to i64
  %add.ptr = getelementptr i8, ptr %35, i64 %idx.ext
  %call63 = call fastcc ptr @getAttributeId(ptr noundef nonnull %parser, ptr noundef %enc, ptr noundef %35, ptr noundef %add.ptr)
  %tobool64.not = icmp eq ptr %call63, null
  br i1 %tobool64.not, label %return, label %if.end66

if.end66:                                         ; preds = %for.body
  %37 = load ptr, ptr %call63, align 8
  %arrayidx68 = getelementptr i8, ptr %37, i64 -1
  %38 = load i8, ptr %arrayidx68, align 1
  %tobool69.not = icmp eq i8 %38, 0
  br i1 %tobool69.not, label %if.end79, label %if.then70

if.then70:                                        ; preds = %if.end66
  %m_encoding = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 34
  %39 = load ptr, ptr %m_encoding, align 8
  %cmp71 = icmp eq ptr %39, %enc
  br i1 %cmp71, label %if.then73, label %return

if.then73:                                        ; preds = %if.then70
  %40 = load ptr, ptr %m_atts, align 8
  %arrayidx76 = getelementptr %struct.ATTRIBUTE, ptr %40, i64 %indvars.iv501
  %41 = load ptr, ptr %arrayidx76, align 8
  %m_eventPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 47
  store ptr %41, ptr %m_eventPtr, align 8
  br label %return

if.end79:                                         ; preds = %if.end66
  store i8 1, ptr %arrayidx68, align 1
  %42 = load ptr, ptr %call63, align 8
  %inc = add i32 %attIndex.0428, 1
  %idxprom83 = sext i32 %attIndex.0428 to i64
  %arrayidx84 = getelementptr ptr, ptr %33, i64 %idxprom83
  store ptr %42, ptr %arrayidx84, align 8
  %43 = load ptr, ptr %m_atts, align 8
  %normalized = getelementptr %struct.ATTRIBUTE, ptr %43, i64 %indvars.iv501, i32 3
  %44 = load i8, ptr %normalized, align 8
  %tobool88.not = icmp eq i8 %44, 0
  br i1 %tobool88.not, label %if.then89, label %if.else

if.then89:                                        ; preds = %if.end79
  %maybeTokenized = getelementptr inbounds %struct.attribute_id, ptr %call63, i64 0, i32 2
  %45 = load i8, ptr %maybeTokenized, align 8
  %tobool90.not = icmp eq i8 %45, 0
  %brmerge = select i1 %tobool90.not, i1 true, i1 %cmp93423
  br i1 %brmerge, label %if.end107, label %for.body95.lr.ph

for.body95.lr.ph:                                 ; preds = %if.then89
  %46 = load ptr, ptr %defaultAtts, align 8
  br label %for.body95

for.cond92:                                       ; preds = %for.body95
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %if.end107, label %for.body95, !llvm.loop !63

for.body95:                                       ; preds = %for.body95.lr.ph, %for.cond92
  %indvars.iv = phi i64 [ 0, %for.body95.lr.ph ], [ %indvars.iv.next, %for.cond92 ]
  %arrayidx97 = getelementptr %struct.DEFAULT_ATTRIBUTE, ptr %46, i64 %indvars.iv
  %47 = load ptr, ptr %arrayidx97, align 8
  %cmp98 = icmp eq ptr %call63, %47
  br i1 %cmp98, label %if.then100, label %for.cond92

if.then100:                                       ; preds = %for.body95
  %isCdata104 = getelementptr %struct.DEFAULT_ATTRIBUTE, ptr %46, i64 %indvars.iv, i32 1
  %48 = load i8, ptr %isCdata104, align 8
  br label %if.end107

if.end107:                                        ; preds = %for.cond92, %if.then89, %if.then100
  %isCdata.0 = phi i8 [ %48, %if.then100 ], [ 1, %if.then89 ], [ 1, %for.cond92 ]
  %valuePtr = getelementptr %struct.ATTRIBUTE, ptr %43, i64 %indvars.iv501, i32 1
  %49 = load ptr, ptr %valuePtr, align 8
  %valueEnd = getelementptr %struct.ATTRIBUTE, ptr %43, i64 %indvars.iv501, i32 2
  %50 = load ptr, ptr %valueEnd, align 8
  %call.i346 = call fastcc i32 @appendAttributeValue(ptr noundef %parser, ptr noundef %enc, i8 noundef zeroext %isCdata.0, ptr noundef %49, ptr noundef %50, ptr noundef nonnull %m_tempPool124, i32 noundef %account), !range !32
  %tobool.not.i347 = icmp eq i32 %call.i346, 0
  br i1 %tobool.not.i347, label %if.end.i, label %return

if.end.i:                                         ; preds = %if.end107
  %tobool1.not.i = icmp eq i8 %isCdata.0, 0
  %51 = load ptr, ptr %ptr1.i.i, align 8
  br i1 %tobool1.not.i, label %land.lhs.true.i350, label %if.end9.i

land.lhs.true.i350:                               ; preds = %if.end.i
  %52 = load ptr, ptr %start.i.i, align 8
  %tobool3.not.i352 = icmp eq ptr %51, %52
  br i1 %tobool3.not.i352, label %if.end9.i, label %land.lhs.true4.i

land.lhs.true4.i:                                 ; preds = %land.lhs.true.i350
  %arrayidx.i353 = getelementptr i8, ptr %51, i64 -1
  %53 = load i8, ptr %arrayidx.i353, align 1
  %cmp.i354 = icmp eq i8 %53, 32
  br i1 %cmp.i354, label %if.then7.i, label %if.end9.i

if.then7.i:                                       ; preds = %land.lhs.true4.i
  store ptr %arrayidx.i353, ptr %ptr1.i.i, align 8
  br label %if.end9.i

if.end9.i:                                        ; preds = %if.then7.i, %land.lhs.true4.i, %land.lhs.true.i350, %if.end.i
  %54 = phi ptr [ %arrayidx.i353, %if.then7.i ], [ %51, %land.lhs.true4.i ], [ %51, %land.lhs.true.i350 ], [ %51, %if.end.i ]
  %55 = load ptr, ptr %end4.i.i, align 8
  %cmp12.i = icmp eq ptr %54, %55
  br i1 %cmp12.i, label %land.lhs.true14.i, label %if.end117

land.lhs.true14.i:                                ; preds = %if.end9.i
  %call15.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool124), !range !13
  %tobool16.not.i = icmp eq i8 %call15.i, 0
  br i1 %tobool16.not.i, label %return, label %land.lhs.true14.cond.false_crit_edge.i

land.lhs.true14.cond.false_crit_edge.i:           ; preds = %land.lhs.true14.i
  %.pre11.i = load ptr, ptr %ptr1.i.i, align 8
  br label %if.end117

if.end117:                                        ; preds = %land.lhs.true14.cond.false_crit_edge.i, %if.end9.i
  %56 = phi ptr [ %.pre11.i, %land.lhs.true14.cond.false_crit_edge.i ], [ %54, %if.end9.i ]
  %incdec.ptr18.i = getelementptr i8, ptr %56, i64 1
  store ptr %incdec.ptr18.i, ptr %ptr1.i.i, align 8
  store i8 0, ptr %56, align 1
  %57 = load ptr, ptr %start.i.i, align 8
  %idxprom119 = sext i32 %inc to i64
  %arrayidx120 = getelementptr ptr, ptr %33, i64 %idxprom119
  store ptr %57, ptr %arrayidx120, align 8
  br label %if.end146

if.else:                                          ; preds = %if.end79
  %valuePtr128 = getelementptr %struct.ATTRIBUTE, ptr %43, i64 %indvars.iv501, i32 1
  %58 = load ptr, ptr %valuePtr128, align 8
  %valueEnd132 = getelementptr %struct.ATTRIBUTE, ptr %43, i64 %indvars.iv501, i32 2
  %59 = load ptr, ptr %valueEnd132, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ptr.addr.i.i)
  store ptr %58, ptr %ptr.addr.i.i, align 8
  %60 = load ptr, ptr %ptr1.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %60, null
  br i1 %tobool.not.i.i, label %land.lhs.true.i.i, label %for.cond.i.i.preheader

land.lhs.true.i.i:                                ; preds = %if.else
  %call.i.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool124), !range !13
  %tobool2.not.i.i = icmp eq i8 %call.i.i, 0
  br i1 %tobool2.not.i.i, label %poolAppend.exit.thread.i, label %for.cond.i.i.preheader

for.cond.i.i.preheader:                           ; preds = %land.lhs.true.i.i, %if.else
  br label %for.cond.i.i

for.cond.i.i:                                     ; preds = %for.cond.i.i.preheader, %if.end8.i.i
  %61 = load ptr, ptr %utf8Convert.i.i, align 8
  %62 = load ptr, ptr %end4.i.i, align 8
  %call5.i.i = call i32 %61(ptr noundef %enc, ptr noundef nonnull %ptr.addr.i.i, ptr noundef %59, ptr noundef nonnull %ptr1.i.i, ptr noundef %62) #24
  %or.cond.i.i = icmp ult i32 %call5.i.i, 2
  br i1 %or.cond.i.i, label %poolAppend.exit.i, label %if.end8.i.i

if.end8.i.i:                                      ; preds = %for.cond.i.i
  %call9.i.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool124), !range !13
  %tobool10.not.i.i = icmp eq i8 %call9.i.i, 0
  br i1 %tobool10.not.i.i, label %poolAppend.exit.thread.i, label %for.cond.i.i

poolAppend.exit.thread.i:                         ; preds = %land.lhs.true.i.i, %if.end8.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i)
  br label %poolStoreString.exit.thread

poolAppend.exit.i:                                ; preds = %for.cond.i.i
  %63 = load ptr, ptr %start.i.i, align 8
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i)
  %tobool.not.i356 = icmp eq ptr %63, null
  br i1 %tobool.not.i356, label %poolStoreString.exit.thread, label %if.end.i357

if.end.i357:                                      ; preds = %poolAppend.exit.i
  %64 = load ptr, ptr %ptr1.i.i, align 8
  %65 = load ptr, ptr %end4.i.i, align 8
  %cmp.i358 = icmp eq ptr %64, %65
  br i1 %cmp.i358, label %land.lhs.true.i360, label %poolStoreString.exit

land.lhs.true.i360:                               ; preds = %if.end.i357
  %call3.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool124), !range !13
  %tobool4.not.i = icmp eq i8 %call3.i, 0
  br i1 %tobool4.not.i, label %poolStoreString.exit.thread, label %land.lhs.true.if.end6_crit_edge.i

land.lhs.true.if.end6_crit_edge.i:                ; preds = %land.lhs.true.i360
  %.pre.i361 = load ptr, ptr %ptr1.i.i, align 8
  br label %poolStoreString.exit

poolStoreString.exit.thread:                      ; preds = %poolAppend.exit.i, %land.lhs.true.i360, %poolAppend.exit.thread.i
  %idxprom134374 = sext i32 %inc to i64
  %arrayidx135375 = getelementptr ptr, ptr %33, i64 %idxprom134374
  store ptr null, ptr %arrayidx135375, align 8
  br label %return

poolStoreString.exit:                             ; preds = %if.end.i357, %land.lhs.true.if.end6_crit_edge.i
  %66 = phi ptr [ %.pre.i361, %land.lhs.true.if.end6_crit_edge.i ], [ %64, %if.end.i357 ]
  %incdec.ptr.i359 = getelementptr i8, ptr %66, i64 1
  store ptr %incdec.ptr.i359, ptr %ptr1.i.i, align 8
  store i8 0, ptr %66, align 1
  %67 = load ptr, ptr %start.i.i, align 8
  %idxprom134 = sext i32 %inc to i64
  %arrayidx135 = getelementptr ptr, ptr %33, i64 %idxprom134
  store ptr %67, ptr %arrayidx135, align 8
  %cmp138 = icmp eq ptr %67, null
  br i1 %cmp138, label %return, label %if.end146

if.end146:                                        ; preds = %poolStoreString.exit, %if.end117
  %storemerge = load ptr, ptr %ptr1.i.i, align 8
  store ptr %storemerge, ptr %start.i.i, align 8
  %prefix = getelementptr inbounds %struct.attribute_id, ptr %call63, i64 0, i32 1
  %68 = load ptr, ptr %prefix, align 8
  %tobool147.not = icmp eq ptr %68, null
  br i1 %tobool147.not, label %if.else165, label %if.then148

if.then148:                                       ; preds = %if.end146
  %xmlns = getelementptr inbounds %struct.attribute_id, ptr %call63, i64 0, i32 3
  %69 = load i8, ptr %xmlns, align 1
  %tobool149.not = icmp eq i8 %69, 0
  br i1 %tobool149.not, label %if.else159, label %if.then150

if.then150:                                       ; preds = %if.then148
  %idxprom153 = sext i32 %inc to i64
  %arrayidx154 = getelementptr ptr, ptr %33, i64 %idxprom153
  %70 = load ptr, ptr %arrayidx154, align 8
  %call155 = call fastcc i32 @addBinding(ptr noundef nonnull %parser, ptr noundef nonnull %68, ptr noundef nonnull %call63, ptr noundef %70, ptr noundef %bindingsPtr), !range !19
  %tobool156.not = icmp eq i32 %call155, 0
  br i1 %tobool156.not, label %for.inc168, label %return

if.else159:                                       ; preds = %if.then148
  %inc160 = add i32 %attIndex.0428, 2
  %inc161 = add i32 %nPrefixes.0426, 1
  %71 = load ptr, ptr %call63, align 8
  %arrayidx163 = getelementptr i8, ptr %71, i64 -1
  store i8 2, ptr %arrayidx163, align 1
  br label %for.inc168

if.else165:                                       ; preds = %if.end146
  %inc166 = add i32 %attIndex.0428, 2
  br label %for.inc168

for.inc168:                                       ; preds = %if.then150, %if.else165, %if.else159
  %nPrefixes.1 = phi i32 [ %inc161, %if.else159 ], [ %nPrefixes.0426, %if.else165 ], [ %nPrefixes.0426, %if.then150 ]
  %attIndex.1 = phi i32 [ %inc160, %if.else159 ], [ %inc166, %if.else165 ], [ %attIndex.0428, %if.then150 ]
  %indvars.iv.next502 = add nuw nsw i64 %indvars.iv501, 1
  %exitcond505.not = icmp eq i64 %indvars.iv.next502, %wide.trip.count504
  br i1 %exitcond505.not, label %for.end170, label %for.body, !llvm.loop !64

for.end170:                                       ; preds = %for.inc168, %if.end54
  %nPrefixes.0.lcssa = phi i32 [ 0, %if.end54 ], [ %nPrefixes.1, %for.inc168 ]
  %attIndex.0.lcssa = phi i32 [ 0, %if.end54 ], [ %attIndex.1, %for.inc168 ]
  %m_nSpecifiedAtts = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 72
  store i32 %attIndex.0.lcssa, ptr %m_nSpecifiedAtts, align 4
  %idAtt = getelementptr inbounds %struct.ELEMENT_TYPE, ptr %elementType.0, i64 0, i32 2
  %72 = load ptr, ptr %idAtt, align 8
  %tobool171.not = icmp eq ptr %72, null
  br i1 %tobool171.not, label %if.end196.sink.split, label %land.lhs.true172

land.lhs.true172:                                 ; preds = %for.end170
  %73 = load ptr, ptr %72, align 8
  %arrayidx175 = getelementptr i8, ptr %73, i64 -1
  %74 = load i8, ptr %arrayidx175, align 1
  %tobool177.not = icmp eq i8 %74, 0
  br i1 %tobool177.not, label %if.end196.sink.split, label %for.cond179.preheader

for.cond179.preheader:                            ; preds = %land.lhs.true172
  %cmp180430 = icmp sgt i32 %attIndex.0.lcssa, 0
  br i1 %cmp180430, label %for.body182, label %if.end196

for.body182:                                      ; preds = %for.cond179.preheader, %for.inc191
  %i.1431 = phi i32 [ %add192, %for.inc191 ], [ 0, %for.cond179.preheader ]
  %idxprom183 = sext i32 %i.1431 to i64
  %arrayidx184 = getelementptr ptr, ptr %33, i64 %idxprom183
  %75 = load ptr, ptr %arrayidx184, align 8
  %cmp187 = icmp eq ptr %75, %73
  br i1 %cmp187, label %if.end196.sink.split, label %for.inc191

for.inc191:                                       ; preds = %for.body182
  %add192 = add i32 %i.1431, 2
  %cmp180 = icmp slt i32 %add192, %attIndex.0.lcssa
  br i1 %cmp180, label %for.body182, label %if.end196, !llvm.loop !65

if.end196.sink.split:                             ; preds = %for.body182, %for.end170, %land.lhs.true172
  %i.1431.lcssa.sink = phi i32 [ -1, %land.lhs.true172 ], [ -1, %for.end170 ], [ %i.1431, %for.body182 ]
  %m_idAttIndex = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 73
  store i32 %i.1431.lcssa.sink, ptr %m_idAttIndex, align 8
  br label %if.end196

if.end196:                                        ; preds = %for.inc191, %if.end196.sink.split, %for.cond179.preheader
  %cmp198432 = icmp sgt i32 %25, 0
  br i1 %cmp198432, label %for.body200.lr.ph, label %for.end260

for.body200.lr.ph:                                ; preds = %if.end196
  %defaultAtts201 = getelementptr inbounds %struct.ELEMENT_TYPE, ptr %elementType.0, i64 0, i32 5
  %wide.trip.count509 = zext nneg i32 %25 to i64
  br label %for.body200

for.body200:                                      ; preds = %for.body200.lr.ph, %for.inc258
  %indvars.iv506 = phi i64 [ 0, %for.body200.lr.ph ], [ %indvars.iv.next507, %for.inc258 ]
  %attIndex.2435 = phi i32 [ %attIndex.0.lcssa, %for.body200.lr.ph ], [ %attIndex.3, %for.inc258 ]
  %nPrefixes.2433 = phi i32 [ %nPrefixes.0.lcssa, %for.body200.lr.ph ], [ %nPrefixes.3, %for.inc258 ]
  %76 = load ptr, ptr %defaultAtts201, align 8
  %add.ptr203 = getelementptr %struct.DEFAULT_ATTRIBUTE, ptr %76, i64 %indvars.iv506
  %77 = load ptr, ptr %add.ptr203, align 8
  %78 = load ptr, ptr %77, align 8
  %arrayidx206 = getelementptr i8, ptr %78, i64 -1
  %79 = load i8, ptr %arrayidx206, align 1
  %tobool207.not = icmp eq i8 %79, 0
  br i1 %tobool207.not, label %land.lhs.true208, label %for.inc258

land.lhs.true208:                                 ; preds = %for.body200
  %value = getelementptr %struct.DEFAULT_ATTRIBUTE, ptr %76, i64 %indvars.iv506, i32 2
  %80 = load ptr, ptr %value, align 8
  %tobool209.not = icmp eq ptr %80, null
  br i1 %tobool209.not, label %for.inc258, label %if.then210

if.then210:                                       ; preds = %land.lhs.true208
  %prefix212 = getelementptr inbounds %struct.attribute_id, ptr %77, i64 0, i32 1
  %81 = load ptr, ptr %prefix212, align 8
  %tobool213.not = icmp eq ptr %81, null
  br i1 %tobool213.not, label %if.else243, label %if.then214

if.then214:                                       ; preds = %if.then210
  %xmlns216 = getelementptr inbounds %struct.attribute_id, ptr %77, i64 0, i32 3
  %82 = load i8, ptr %xmlns216, align 1
  %tobool217.not = icmp eq i8 %82, 0
  br i1 %tobool217.not, label %if.else228, label %if.then218

if.then218:                                       ; preds = %if.then214
  %call224 = call fastcc i32 @addBinding(ptr noundef %parser, ptr noundef nonnull %81, ptr noundef nonnull %77, ptr noundef nonnull %80, ptr noundef %bindingsPtr), !range !19
  %tobool225.not = icmp eq i32 %call224, 0
  br i1 %tobool225.not, label %for.inc258, label %return

if.else228:                                       ; preds = %if.then214
  store i8 2, ptr %arrayidx206, align 1
  %inc232 = add i32 %nPrefixes.2433, 1
  br label %for.inc258.sink.split

if.else243:                                       ; preds = %if.then210
  store i8 1, ptr %arrayidx206, align 1
  br label %for.inc258.sink.split

for.inc258.sink.split:                            ; preds = %if.else243, %if.else228
  %nPrefixes.3.ph = phi i32 [ %nPrefixes.2433, %if.else243 ], [ %inc232, %if.else228 ]
  %83 = load ptr, ptr %add.ptr203, align 8
  %84 = load ptr, ptr %83, align 8
  %inc235 = add i32 %attIndex.2435, 1
  %idxprom236 = sext i32 %attIndex.2435 to i64
  %arrayidx237 = getelementptr ptr, ptr %33, i64 %idxprom236
  store ptr %84, ptr %arrayidx237, align 8
  %85 = load ptr, ptr %value, align 8
  %inc239 = add i32 %attIndex.2435, 2
  %idxprom240 = sext i32 %inc235 to i64
  %arrayidx241 = getelementptr ptr, ptr %33, i64 %idxprom240
  store ptr %85, ptr %arrayidx241, align 8
  br label %for.inc258

for.inc258:                                       ; preds = %for.inc258.sink.split, %for.body200, %land.lhs.true208, %if.then218
  %nPrefixes.3 = phi i32 [ %nPrefixes.2433, %for.body200 ], [ %nPrefixes.2433, %if.then218 ], [ %nPrefixes.2433, %land.lhs.true208 ], [ %nPrefixes.3.ph, %for.inc258.sink.split ]
  %attIndex.3 = phi i32 [ %attIndex.2435, %for.body200 ], [ %attIndex.2435, %if.then218 ], [ %attIndex.2435, %land.lhs.true208 ], [ %inc239, %for.inc258.sink.split ]
  %indvars.iv.next507 = add nuw nsw i64 %indvars.iv506, 1
  %exitcond510.not = icmp eq i64 %indvars.iv.next507, %wide.trip.count509
  br i1 %exitcond510.not, label %for.end260, label %for.body200, !llvm.loop !66

for.end260:                                       ; preds = %for.inc258, %if.end196
  %nPrefixes.2.lcssa = phi i32 [ %nPrefixes.0.lcssa, %if.end196 ], [ %nPrefixes.3, %for.inc258 ]
  %attIndex.2.lcssa = phi i32 [ %attIndex.0.lcssa, %if.end196 ], [ %attIndex.3, %for.inc258 ]
  %idxprom261 = sext i32 %attIndex.2.lcssa to i64
  %arrayidx262 = getelementptr ptr, ptr %33, i64 %idxprom261
  store ptr null, ptr %arrayidx262, align 8
  %tobool263.not = icmp eq i32 %nPrefixes.2.lcssa, 0
  br i1 %tobool263.not, label %if.end536, label %if.then264

if.then264:                                       ; preds = %for.end260
  %m_nsAttsVersion = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 76
  %m_nsAttsPower = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 77
  %86 = load i8, ptr %m_nsAttsPower, align 8
  %cmp267 = icmp ugt i8 %86, 31
  br i1 %cmp267, label %return, label %if.end270

if.end270:                                        ; preds = %if.then264
  %conv272 = zext nneg i8 %86 to i32
  %shl274 = shl i32 %nPrefixes.2.lcssa, 1
  %shr = ashr i32 %shl274, %conv272
  %tobool277.not = icmp eq i32 %shr, 0
  br i1 %tobool277.not, label %if.end312, label %while.cond

while.cond:                                       ; preds = %if.end270, %while.cond
  %87 = phi i8 [ %inc281, %while.cond ], [ %86, %if.end270 ]
  %inc281 = add i8 %87, 1
  %conv282 = zext nneg i8 %87 to i32
  %shr283 = ashr i32 %nPrefixes.2.lcssa, %conv282
  %tobool284.not = icmp eq i32 %shr283, 0
  br i1 %tobool284.not, label %while.end, label %while.cond, !llvm.loop !67

while.end:                                        ; preds = %while.cond
  store i8 %inc281, ptr %m_nsAttsPower, align 8
  %cmp287 = icmp ult i8 %inc281, 3
  br i1 %cmp287, label %if.end291.thread, label %if.end291

if.end291.thread:                                 ; preds = %while.end
  store i8 3, ptr %m_nsAttsPower, align 8
  br label %if.end298

if.end291:                                        ; preds = %while.end
  %cmp294 = icmp ugt i8 %inc281, 31
  br i1 %cmp294, label %if.then296, label %if.end298

if.then296:                                       ; preds = %if.end291
  store i8 %86, ptr %m_nsAttsPower, align 8
  br label %return

if.end298:                                        ; preds = %if.end291.thread, %if.end291
  %88 = phi i8 [ 3, %if.end291.thread ], [ %inc281, %if.end291 ]
  %realloc_fcn303 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 3, i32 1
  %89 = load ptr, ptr %realloc_fcn303, align 8
  %m_nsAtts = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 75
  %90 = load ptr, ptr %m_nsAtts, align 8
  %91 = zext nneg i8 %88 to i64
  %mul305 = shl nuw nsw i64 24, %91
  %call306 = call ptr %89(ptr noundef %90, i64 noundef %mul305) #24
  %tobool307.not = icmp eq ptr %call306, null
  br i1 %tobool307.not, label %if.then308, label %if.end312.thread

if.then308:                                       ; preds = %if.end298
  store i8 %86, ptr %m_nsAttsPower, align 8
  br label %return

if.end312.thread:                                 ; preds = %if.end298
  %conv300 = zext nneg i8 %88 to i32
  store ptr %call306, ptr %m_nsAtts, align 8
  %nsAttsSize.0521 = shl nuw i32 1, %conv300
  br label %for.cond315.preheader

if.end312:                                        ; preds = %if.end270
  %92 = load i64, ptr %m_nsAttsVersion, align 8
  %nsAttsSize.0 = shl nuw i32 1, %conv272
  %tobool313.not = icmp eq i64 %92, 0
  br i1 %tobool313.not, label %for.cond315.preheader, label %if.end325

for.cond315.preheader:                            ; preds = %if.end312.thread, %if.end312
  %nsAttsSize.0524 = phi i32 [ %nsAttsSize.0521, %if.end312.thread ], [ %nsAttsSize.0, %if.end312 ]
  %m_nsAtts319 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 75
  br label %for.body318

for.body318:                                      ; preds = %for.cond315.preheader, %for.body318
  %j265.0439 = phi i32 [ %nsAttsSize.0524, %for.cond315.preheader ], [ %dec320, %for.body318 ]
  %93 = load ptr, ptr %m_nsAtts319, align 8
  %dec320 = add i32 %j265.0439, -1
  %idxprom321 = sext i32 %dec320 to i64
  %arrayidx322 = getelementptr %struct.NS_ATT, ptr %93, i64 %idxprom321
  store i64 4294967295, ptr %arrayidx322, align 8
  %cmp316.not = icmp eq i32 %dec320, 0
  br i1 %cmp316.not, label %if.end325, label %for.body318, !llvm.loop !68

if.end325:                                        ; preds = %for.body318, %if.end312
  %nsAttsSize.0523 = phi i32 [ %nsAttsSize.0, %if.end312 ], [ %nsAttsSize.0524, %for.body318 ]
  %version.1 = phi i64 [ %92, %if.end312 ], [ 4294967295, %for.body318 ]
  %dec326 = add i64 %version.1, -1
  store i64 %dec326, ptr %m_nsAttsVersion, align 8
  %cmp329456 = icmp sgt i32 %attIndex.2.lcssa, 0
  br i1 %cmp329456, label %for.body331.lr.ph, label %if.end536

for.body331.lr.ph:                                ; preds = %if.end325
  %v1.i = getelementptr inbounds %struct.siphash, ptr %sip_state, i64 0, i32 1
  %v2.i = getelementptr inbounds %struct.siphash, ptr %sip_state, i64 0, i32 2
  %v3.i = getelementptr inbounds %struct.siphash, ptr %sip_state, i64 0, i32 3
  %buf.i = getelementptr inbounds %struct.siphash, ptr %sip_state, i64 0, i32 4
  %p.i = getelementptr inbounds %struct.siphash, ptr %sip_state, i64 0, i32 5
  %c.i = getelementptr inbounds %struct.siphash, ptr %sip_state, i64 0, i32 6
  %attributeIds = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 2
  %ptr362 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 79, i32 3
  %end = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 79, i32 2
  %m_tempPool361 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 79
  %sub412 = add i32 %nsAttsSize.0523, -1
  %conv413 = zext i32 %sub412 to i64
  %m_nsAtts416 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 75
  %start430 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 79, i32 4
  %not = xor i64 %conv413, -1
  %shr460 = lshr i64 %conv413, 2
  %m_ns_triplets = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 39
  %m_namespaceSeparator = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 83
  br label %for.body331

for.body331:                                      ; preds = %for.body331.lr.ph, %for.inc533
  %i.3458 = phi i32 [ 0, %for.body331.lr.ph ], [ %add534, %for.inc533 ]
  %nPrefixes.4457 = phi i32 [ %nPrefixes.2.lcssa, %for.body331.lr.ph ], [ %nPrefixes.5, %for.inc533 ]
  %idxprom332 = sext i32 %i.3458 to i64
  %arrayidx333 = getelementptr ptr, ptr %33, i64 %idxprom332
  %94 = load ptr, ptr %arrayidx333, align 8
  %arrayidx334 = getelementptr i8, ptr %94, i64 -1
  %95 = load i8, ptr %arrayidx334, align 1
  %cmp336 = icmp eq i8 %95, 2
  br i1 %cmp336, label %tailrecurse.i.i, label %if.else530

tailrecurse.i.i:                                  ; preds = %for.body331, %tailrecurse.i.i
  %parser.tr.i.i = phi ptr [ %96, %tailrecurse.i.i ], [ %parser, %for.body331 ]
  %m_parentParser.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser.tr.i.i, i64 0, i32 84
  %96 = load ptr, ptr %m_parentParser.i.i, align 8
  %cmp.not.i.i = icmp eq ptr %96, null
  br i1 %cmp.not.i.i, label %copy_salt_to_sipkey.exit, label %tailrecurse.i.i

copy_salt_to_sipkey.exit:                         ; preds = %tailrecurse.i.i
  %m_hash_secret_salt.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser.tr.i.i, i64 0, i32 89
  %97 = load i64, ptr %m_hash_secret_salt.i.i, align 8
  store i64 8317987319222330741, ptr %sip_state, align 8
  %xor3.i = xor i64 %97, 7237128888997146477
  store i64 %xor3.i, ptr %v1.i, align 8
  store i64 7816392313619706465, ptr %v2.i, align 8
  %xor9.i = xor i64 %97, 8387220255154660723
  store i64 %xor9.i, ptr %v3.i, align 8
  store ptr %buf.i, ptr %p.i, align 8
  store i64 0, ptr %c.i, align 8
  store i8 0, ptr %arrayidx334, align 1
  %call342 = call fastcc ptr @lookup(ptr noundef %parser, ptr noundef nonnull %attributeIds, ptr noundef %94, i64 noundef 0)
  %tobool343.not = icmp eq ptr %call342, null
  br i1 %tobool343.not, label %return, label %lor.lhs.false344

lor.lhs.false344:                                 ; preds = %copy_salt_to_sipkey.exit
  %prefix345 = getelementptr inbounds %struct.attribute_id, ptr %call342, i64 0, i32 1
  %98 = load ptr, ptr %prefix345, align 8
  %tobool346.not = icmp eq ptr %98, null
  br i1 %tobool346.not, label %return, label %if.end348

if.end348:                                        ; preds = %lor.lhs.false344
  %binding350 = getelementptr inbounds %struct.prefix, ptr %98, i64 0, i32 1
  %99 = load ptr, ptr %binding350, align 8
  %tobool351.not = icmp eq ptr %99, null
  br i1 %tobool351.not, label %return, label %for.cond354.preheader

for.cond354.preheader:                            ; preds = %if.end348
  %uriLen = getelementptr inbounds %struct.binding, ptr %99, i64 0, i32 5
  %100 = load i32, ptr %uriLen, align 8
  %cmp355440 = icmp sgt i32 %100, 0
  br i1 %cmp355440, label %for.body357.lr.ph, label %for.cond354.preheader.for.end376_crit_edge

for.cond354.preheader.for.end376_crit_edge:       ; preds = %for.cond354.preheader
  %.pre518 = sext i32 %100 to i64
  br label %for.end376

for.body357.lr.ph:                                ; preds = %for.cond354.preheader
  %uri358 = getelementptr inbounds %struct.binding, ptr %99, i64 0, i32 4
  br label %for.body357

for.body357:                                      ; preds = %for.body357.lr.ph, %cond.false
  %indvars.iv511 = phi i64 [ 0, %for.body357.lr.ph ], [ %indvars.iv.next512, %cond.false ]
  %101 = load ptr, ptr %uri358, align 8
  %arrayidx360 = getelementptr i8, ptr %101, i64 %indvars.iv511
  %102 = load i8, ptr %arrayidx360, align 1
  %103 = load ptr, ptr %ptr362, align 8
  %104 = load ptr, ptr %end, align 8
  %cmp364 = icmp eq ptr %103, %104
  br i1 %cmp364, label %land.lhs.true366, label %cond.false

land.lhs.true366:                                 ; preds = %for.body357
  %call368 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool361), !range !13
  %tobool369.not = icmp eq i8 %call368, 0
  br i1 %tobool369.not, label %return, label %land.lhs.true366.cond.false_crit_edge

land.lhs.true366.cond.false_crit_edge:            ; preds = %land.lhs.true366
  %.pre = load ptr, ptr %ptr362, align 8
  br label %cond.false

cond.false:                                       ; preds = %land.lhs.true366.cond.false_crit_edge, %for.body357
  %105 = phi ptr [ %.pre, %land.lhs.true366.cond.false_crit_edge ], [ %103, %for.body357 ]
  %incdec.ptr = getelementptr i8, ptr %105, i64 1
  store ptr %incdec.ptr, ptr %ptr362, align 8
  store i8 %102, ptr %105, align 1
  %indvars.iv.next512 = add nuw nsw i64 %indvars.iv511, 1
  %106 = load i32, ptr %uriLen, align 8
  %107 = sext i32 %106 to i64
  %cmp355 = icmp slt i64 %indvars.iv.next512, %107
  br i1 %cmp355, label %for.body357, label %for.end376, !llvm.loop !69

for.end376:                                       ; preds = %cond.false, %for.cond354.preheader.for.end376_crit_edge
  %conv379.pre-phi = phi i64 [ %.pre518, %for.cond354.preheader.for.end376_crit_edge ], [ %107, %cond.false ]
  %uri377 = getelementptr inbounds %struct.binding, ptr %99, i64 0, i32 4
  %108 = load ptr, ptr %uri377, align 8
  %call381 = call fastcc ptr @sip24_update(ptr noundef nonnull %sip_state, ptr noundef %108, i64 noundef %conv379.pre-phi)
  br label %while.cond382

while.cond382:                                    ; preds = %while.cond382, %for.end376
  %s.0 = phi ptr [ %94, %for.end376 ], [ %incdec.ptr383, %while.cond382 ]
  %incdec.ptr383 = getelementptr i8, ptr %s.0, i64 1
  %109 = load i8, ptr %s.0, align 1
  %cmp385.not = icmp eq i8 %109, 58
  br i1 %cmp385.not, label %while.end388, label %while.cond382, !llvm.loop !70

while.end388:                                     ; preds = %while.cond382
  %110 = load i8, ptr %incdec.ptr383, align 1
  %tobool.not3.i = icmp eq i8 %110, 0
  br i1 %tobool.not3.i, label %keylen.exit, label %for.inc.i

for.inc.i:                                        ; preds = %while.end388, %for.inc.i
  %len.05.i = phi i64 [ %inc.i, %for.inc.i ], [ 0, %while.end388 ]
  %s.addr.04.i = phi ptr [ %incdec.ptr.i363, %for.inc.i ], [ %incdec.ptr383, %while.end388 ]
  %incdec.ptr.i363 = getelementptr i8, ptr %s.addr.04.i, i64 1
  %inc.i = add i64 %len.05.i, 1
  %111 = load i8, ptr %incdec.ptr.i363, align 1
  %tobool.not.i364 = icmp eq i8 %111, 0
  br i1 %tobool.not.i364, label %keylen.exit, label %for.inc.i, !llvm.loop !51

keylen.exit:                                      ; preds = %for.inc.i, %while.end388
  %len.0.lcssa.i = phi i64 [ 0, %while.end388 ], [ %inc.i, %for.inc.i ]
  %call391 = call fastcc ptr @sip24_update(ptr noundef nonnull %sip_state, ptr noundef nonnull %incdec.ptr383, i64 noundef %len.0.lcssa.i)
  br label %do.body

do.body:                                          ; preds = %cond.false403, %keylen.exit
  %s.1 = phi ptr [ %incdec.ptr383, %keylen.exit ], [ %incdec.ptr409, %cond.false403 ]
  %112 = load ptr, ptr %ptr362, align 8
  %113 = load ptr, ptr %end, align 8
  %cmp396 = icmp eq ptr %112, %113
  br i1 %cmp396, label %land.lhs.true398, label %cond.false403

land.lhs.true398:                                 ; preds = %do.body
  %call400 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool361), !range !13
  %tobool401.not = icmp eq i8 %call400, 0
  br i1 %tobool401.not, label %return, label %land.lhs.true398.cond.false403_crit_edge

land.lhs.true398.cond.false403_crit_edge:         ; preds = %land.lhs.true398
  %.pre514 = load ptr, ptr %ptr362, align 8
  br label %cond.false403

cond.false403:                                    ; preds = %land.lhs.true398.cond.false403_crit_edge, %do.body
  %114 = phi ptr [ %.pre514, %land.lhs.true398.cond.false403_crit_edge ], [ %112, %do.body ]
  %115 = load i8, ptr %s.1, align 1
  %incdec.ptr406 = getelementptr i8, ptr %114, i64 1
  store ptr %incdec.ptr406, ptr %ptr362, align 8
  store i8 %115, ptr %114, align 1
  %incdec.ptr409 = getelementptr i8, ptr %s.1, i64 1
  %116 = load i8, ptr %s.1, align 1
  %tobool410.not = icmp eq i8 %116, 0
  br i1 %tobool410.not, label %do.end, label %do.body, !llvm.loop !71

do.end:                                           ; preds = %cond.false403
  %call411 = call fastcc i64 @sip24_final(ptr noundef nonnull %sip_state)
  %117 = trunc i64 %call411 to i32
  %conv414 = and i32 %sub412, %117
  %118 = load ptr, ptr %m_nsAtts416, align 8
  %idxprom417449 = sext i32 %conv414 to i64
  %arrayidx418450 = getelementptr %struct.NS_ATT, ptr %118, i64 %idxprom417449
  %119 = load i64, ptr %arrayidx418450, align 8
  %cmp420451 = icmp eq i64 %119, %dec326
  br i1 %cmp420451, label %while.body422.lr.ph, label %while.end474

while.body422.lr.ph:                              ; preds = %do.end
  %and455 = and i64 %call411, %not
  br label %while.body422

while.body422:                                    ; preds = %while.body422.lr.ph, %if.end463
  %idxprom417454 = phi i64 [ %idxprom417449, %while.body422.lr.ph ], [ %idxprom417, %if.end463 ]
  %step.0453 = phi i8 [ 0, %while.body422.lr.ph ], [ %step.1, %if.end463 ]
  %j265.2452 = phi i32 [ %conv414, %while.body422.lr.ph ], [ %j265.3, %if.end463 ]
  %hash = getelementptr %struct.NS_ATT, ptr %118, i64 %idxprom417454, i32 1
  %120 = load i64, ptr %hash, align 8
  %cmp426 = icmp eq i64 %call411, %120
  br i1 %cmp426, label %if.then428, label %if.end452

if.then428:                                       ; preds = %while.body422
  %121 = load ptr, ptr %start430, align 8
  %uriName = getelementptr %struct.NS_ATT, ptr %118, i64 %idxprom417454, i32 2
  %122 = load ptr, ptr %uriName, align 8
  %123 = load i8, ptr %121, align 1
  %124 = load i8, ptr %122, align 1
  %cmp437443 = icmp ne i8 %123, %124
  %cmp440.not444 = icmp eq i8 %123, 0
  %or.cond343445 = or i1 %cmp440.not444, %cmp437443
  br i1 %or.cond343445, label %for.end446, label %for.inc443

for.inc443:                                       ; preds = %if.then428, %for.inc443
  %s2.0447 = phi ptr [ %incdec.ptr445, %for.inc443 ], [ %122, %if.then428 ]
  %s1.0446 = phi ptr [ %incdec.ptr444, %for.inc443 ], [ %121, %if.then428 ]
  %incdec.ptr444 = getelementptr i8, ptr %s1.0446, i64 1
  %incdec.ptr445 = getelementptr i8, ptr %s2.0447, i64 1
  %125 = load i8, ptr %incdec.ptr444, align 1
  %126 = load i8, ptr %incdec.ptr445, align 1
  %cmp437 = icmp ne i8 %125, %126
  %cmp440.not = icmp eq i8 %125, 0
  %or.cond343 = or i1 %cmp440.not, %cmp437
  br i1 %or.cond343, label %for.end446, label %for.inc443, !llvm.loop !72

for.end446:                                       ; preds = %for.inc443, %if.then428
  %cmp440.not.lcssa = phi i1 [ %cmp440.not444, %if.then428 ], [ %cmp440.not, %for.inc443 ]
  br i1 %cmp440.not.lcssa, label %return, label %if.end452

if.end452:                                        ; preds = %for.end446, %while.body422
  %tobool453.not = icmp eq i8 %step.0453, 0
  br i1 %tobool453.not, label %if.then454, label %if.end463

if.then454:                                       ; preds = %if.end452
  %127 = load i8, ptr %m_nsAttsPower, align 8
  %conv457 = zext i8 %127 to i64
  %sub458 = add nuw nsw i64 %conv457, 4294967295
  %sh_prom = and i64 %sub458, 4294967295
  %shr459 = lshr i64 %and455, %sh_prom
  %and461 = and i64 %shr459, %shr460
  %128 = trunc i64 %and461 to i8
  %conv462 = or i8 %128, 1
  br label %if.end463

if.end463:                                        ; preds = %if.then454, %if.end452
  %step.1 = phi i8 [ %step.0453, %if.end452 ], [ %conv462, %if.then454 ]
  %conv464 = zext i8 %step.1 to i32
  %cmp465 = icmp slt i32 %j265.2452, %conv464
  %j265.3.p.v = select i1 %cmp465, i32 %nsAttsSize.0523, i32 0
  %j265.3.p = sub i32 %j265.2452, %conv464
  %j265.3 = add i32 %j265.3.p, %j265.3.p.v
  %idxprom417 = sext i32 %j265.3 to i64
  %arrayidx418 = getelementptr %struct.NS_ATT, ptr %118, i64 %idxprom417
  %129 = load i64, ptr %arrayidx418, align 8
  %cmp420 = icmp eq i64 %129, %dec326
  br i1 %cmp420, label %while.body422, label %while.end474, !llvm.loop !73

while.end474:                                     ; preds = %if.end463, %do.end
  %idxprom417.lcssa = phi i64 [ %idxprom417449, %do.end ], [ %idxprom417, %if.end463 ]
  %130 = load i8, ptr %m_ns_triplets, align 1
  %tobool475.not = icmp eq i8 %130, 0
  br i1 %tobool475.not, label %if.end504, label %if.then476

if.then476:                                       ; preds = %while.end474
  %131 = load i8, ptr %m_namespaceSeparator, align 4
  %132 = load ptr, ptr %ptr362, align 8
  %arrayidx479 = getelementptr i8, ptr %132, i64 -1
  store i8 %131, ptr %arrayidx479, align 1
  %133 = load ptr, ptr %99, align 8
  %134 = load ptr, ptr %133, align 8
  br label %do.body482

do.body482:                                       ; preds = %cond.false494, %if.then476
  %s.2 = phi ptr [ %134, %if.then476 ], [ %incdec.ptr501, %cond.false494 ]
  %135 = load ptr, ptr %ptr362, align 8
  %136 = load ptr, ptr %end, align 8
  %cmp487 = icmp eq ptr %135, %136
  br i1 %cmp487, label %land.lhs.true489, label %cond.false494

land.lhs.true489:                                 ; preds = %do.body482
  %call491 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_tempPool361), !range !13
  %tobool492.not = icmp eq i8 %call491, 0
  br i1 %tobool492.not, label %return, label %land.lhs.true489.cond.false494_crit_edge

land.lhs.true489.cond.false494_crit_edge:         ; preds = %land.lhs.true489
  %.pre515 = load ptr, ptr %ptr362, align 8
  br label %cond.false494

cond.false494:                                    ; preds = %land.lhs.true489.cond.false494_crit_edge, %do.body482
  %137 = phi ptr [ %.pre515, %land.lhs.true489.cond.false494_crit_edge ], [ %135, %do.body482 ]
  %138 = load i8, ptr %s.2, align 1
  %incdec.ptr497 = getelementptr i8, ptr %137, i64 1
  store ptr %incdec.ptr497, ptr %ptr362, align 8
  store i8 %138, ptr %137, align 1
  %incdec.ptr501 = getelementptr i8, ptr %s.2, i64 1
  %139 = load i8, ptr %s.2, align 1
  %tobool502.not = icmp eq i8 %139, 0
  br i1 %tobool502.not, label %if.end504, label %do.body482, !llvm.loop !74

if.end504:                                        ; preds = %cond.false494, %while.end474
  %140 = load ptr, ptr %start430, align 8
  %141 = load ptr, ptr %ptr362, align 8
  store ptr %141, ptr %start430, align 8
  store ptr %140, ptr %arrayidx333, align 8
  %142 = load ptr, ptr %m_nsAtts416, align 8
  %arrayidx515 = getelementptr %struct.NS_ATT, ptr %142, i64 %idxprom417.lcssa
  store i64 %dec326, ptr %arrayidx515, align 8
  %143 = load ptr, ptr %m_nsAtts416, align 8
  %hash520 = getelementptr %struct.NS_ATT, ptr %143, i64 %idxprom417.lcssa, i32 1
  store i64 %call411, ptr %hash520, align 8
  %144 = load ptr, ptr %m_nsAtts416, align 8
  %uriName524 = getelementptr %struct.NS_ATT, ptr %144, i64 %idxprom417.lcssa, i32 2
  store ptr %140, ptr %uriName524, align 8
  %dec525 = add i32 %nPrefixes.4457, -1
  %tobool526.not = icmp eq i32 %dec525, 0
  br i1 %tobool526.not, label %if.then527, label %for.inc533

if.then527:                                       ; preds = %if.end504
  %add528 = add i32 %i.3458, 2
  br label %if.end536

if.else530:                                       ; preds = %for.body331
  store i8 0, ptr %arrayidx334, align 1
  br label %for.inc533

for.inc533:                                       ; preds = %if.else530, %if.end504
  %nPrefixes.5 = phi i32 [ %dec525, %if.end504 ], [ %nPrefixes.4457, %if.else530 ]
  %add534 = add i32 %i.3458, 2
  %cmp329 = icmp slt i32 %add534, %attIndex.2.lcssa
  br i1 %cmp329, label %for.body331, label %if.end536, !llvm.loop !75

if.end536:                                        ; preds = %for.inc533, %if.end325, %if.then527, %for.end260
  %i.4 = phi i32 [ %add528, %if.then527 ], [ 0, %for.end260 ], [ 0, %if.end325 ], [ %add534, %for.inc533 ]
  %cmp538460 = icmp slt i32 %i.4, %attIndex.2.lcssa
  br i1 %cmp538460, label %for.body540, label %for.cond547.preheader

for.cond547.preheader:                            ; preds = %for.body540, %if.end536
  %binding.0462 = load ptr, ptr %bindingsPtr, align 8
  %tobool548.not463 = icmp eq ptr %binding.0462, null
  br i1 %tobool548.not463, label %for.end554, label %for.body549

for.body540:                                      ; preds = %if.end536, %for.body540
  %i.5461 = phi i32 [ %add545, %for.body540 ], [ %i.4, %if.end536 ]
  %idxprom541 = sext i32 %i.5461 to i64
  %arrayidx542 = getelementptr ptr, ptr %33, i64 %idxprom541
  %145 = load ptr, ptr %arrayidx542, align 8
  %arrayidx543 = getelementptr i8, ptr %145, i64 -1
  store i8 0, ptr %arrayidx543, align 1
  %add545 = add i32 %i.5461, 2
  %cmp538 = icmp slt i32 %add545, %attIndex.2.lcssa
  br i1 %cmp538, label %for.body540, label %for.cond547.preheader, !llvm.loop !76

for.body549:                                      ; preds = %for.cond547.preheader, %for.body549
  %binding.0464 = phi ptr [ %binding.0, %for.body549 ], [ %binding.0462, %for.cond547.preheader ]
  %attId550 = getelementptr inbounds %struct.binding, ptr %binding.0464, i64 0, i32 3
  %146 = load ptr, ptr %attId550, align 8
  %147 = load ptr, ptr %146, align 8
  %arrayidx552 = getelementptr i8, ptr %147, i64 -1
  store i8 0, ptr %arrayidx552, align 1
  %nextTagBinding = getelementptr inbounds %struct.binding, ptr %binding.0464, i64 0, i32 1
  %binding.0 = load ptr, ptr %nextTagBinding, align 8
  %tobool548.not = icmp eq ptr %binding.0, null
  br i1 %tobool548.not, label %for.end554, label %for.body549, !llvm.loop !77

for.end554:                                       ; preds = %for.body549, %for.cond547.preheader
  %m_ns555 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 38
  %148 = load i8, ptr %m_ns555, align 8
  %tobool556.not = icmp eq i8 %148, 0
  br i1 %tobool556.not, label %return, label %if.end558

if.end558:                                        ; preds = %for.end554
  %prefix559 = getelementptr inbounds %struct.ELEMENT_TYPE, ptr %elementType.0, i64 0, i32 1
  %149 = load ptr, ptr %prefix559, align 8
  %tobool560.not = icmp eq ptr %149, null
  br i1 %tobool560.not, label %if.else575, label %if.then561

if.then561:                                       ; preds = %if.end558
  %binding563 = getelementptr inbounds %struct.prefix, ptr %149, i64 0, i32 1
  %150 = load ptr, ptr %binding563, align 8
  %tobool564.not = icmp eq ptr %150, null
  br i1 %tobool564.not, label %return, label %if.end566

if.end566:                                        ; preds = %if.then561
  %151 = load ptr, ptr %tagNamePtr, align 8
  br label %while.cond568

while.cond568:                                    ; preds = %while.cond568, %if.end566
  %localPart.0 = phi ptr [ %151, %if.end566 ], [ %incdec.ptr569, %while.cond568 ]
  %incdec.ptr569 = getelementptr i8, ptr %localPart.0, i64 1
  %152 = load i8, ptr %localPart.0, align 1
  %cmp571.not = icmp eq i8 %152, 58
  br i1 %cmp571.not, label %if.end584, label %while.cond568, !llvm.loop !78

if.else575:                                       ; preds = %if.end558
  %binding576 = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 11, i32 1
  %153 = load ptr, ptr %binding576, align 8
  %tobool577.not = icmp eq ptr %153, null
  br i1 %tobool577.not, label %return, label %if.then578

if.then578:                                       ; preds = %if.else575
  %154 = load ptr, ptr %tagNamePtr, align 8
  br label %if.end584

if.end584:                                        ; preds = %while.cond568, %if.then578
  %localPart.1 = phi ptr [ %154, %if.then578 ], [ %incdec.ptr569, %while.cond568 ]
  %binding.1 = phi ptr [ %153, %if.then578 ], [ %150, %while.cond568 ]
  %m_ns_triplets585 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 39
  %155 = load i8, ptr %m_ns_triplets585, align 1
  %tobool587.not = icmp eq i8 %155, 0
  br i1 %tobool587.not, label %if.end602, label %land.lhs.true588

land.lhs.true588:                                 ; preds = %if.end584
  %156 = load ptr, ptr %binding.1, align 8
  %157 = load ptr, ptr %156, align 8
  %tobool591.not = icmp eq ptr %157, null
  br i1 %tobool591.not, label %if.end602, label %for.cond593

for.cond593:                                      ; preds = %land.lhs.true588, %for.cond593
  %prefixLen.0 = phi i32 [ %inc596, %for.cond593 ], [ 0, %land.lhs.true588 ]
  %inc596 = add i32 %prefixLen.0, 1
  %idxprom597 = sext i32 %prefixLen.0 to i64
  %arrayidx598 = getelementptr i8, ptr %157, i64 %idxprom597
  %158 = load i8, ptr %arrayidx598, align 1
  %tobool599.not = icmp eq i8 %158, 0
  br i1 %tobool599.not, label %if.end602, label %for.cond593, !llvm.loop !79

if.end602:                                        ; preds = %for.cond593, %land.lhs.true588, %if.end584
  %prefixLen.1 = phi i32 [ 0, %land.lhs.true588 ], [ 0, %if.end584 ], [ %inc596, %for.cond593 ]
  %localPart603 = getelementptr inbounds %struct.TAG_NAME, ptr %tagNamePtr, i64 0, i32 1
  store ptr %localPart.1, ptr %localPart603, align 8
  %uriLen604 = getelementptr inbounds %struct.binding, ptr %binding.1, i64 0, i32 5
  %159 = load i32, ptr %uriLen604, align 8
  %uriLen605 = getelementptr inbounds %struct.TAG_NAME, ptr %tagNamePtr, i64 0, i32 4
  store i32 %159, ptr %uriLen605, align 4
  %160 = load ptr, ptr %binding.1, align 8
  %161 = load ptr, ptr %160, align 8
  %prefix608 = getelementptr inbounds %struct.TAG_NAME, ptr %tagNamePtr, i64 0, i32 2
  store ptr %161, ptr %prefix608, align 8
  %prefixLen609 = getelementptr inbounds %struct.TAG_NAME, ptr %tagNamePtr, i64 0, i32 5
  store i32 %prefixLen.1, ptr %prefixLen609, align 8
  br label %for.cond610

for.cond610:                                      ; preds = %for.cond610, %if.end602
  %i.6 = phi i32 [ 0, %if.end602 ], [ %inc611, %for.cond610 ]
  %inc611 = add i32 %i.6, 1
  %idxprom612 = sext i32 %i.6 to i64
  %arrayidx613 = getelementptr i8, ptr %localPart.1, i64 %idxprom612
  %162 = load i8, ptr %arrayidx613, align 1
  %tobool614.not = icmp eq i8 %162, 0
  br i1 %tobool614.not, label %for.end616, label %for.cond610, !llvm.loop !80

for.end616:                                       ; preds = %for.cond610
  %163 = load i32, ptr %uriLen604, align 8
  %sub618 = sub i32 2147483647, %prefixLen.1
  %cmp619 = icmp sgt i32 %163, %sub618
  br i1 %cmp619, label %return, label %lor.lhs.false621

lor.lhs.false621:                                 ; preds = %for.end616
  %164 = add i32 %prefixLen.1, %163
  %sub624 = sub i32 2147483647, %164
  %cmp625 = icmp sgt i32 %inc611, %sub624
  br i1 %cmp625, label %return, label %if.end628

if.end628:                                        ; preds = %lor.lhs.false621
  %add630 = add i32 %inc611, %prefixLen.1
  %add631 = add i32 %add630, %163
  %uriAlloc = getelementptr inbounds %struct.binding, ptr %binding.1, i64 0, i32 6
  %165 = load i32, ptr %uriAlloc, align 4
  %cmp632 = icmp sgt i32 %add631, %165
  br i1 %cmp632, label %if.then634, label %if.end628.if.end670_crit_edge

if.end628.if.end670_crit_edge:                    ; preds = %if.end628
  %uri671.phi.trans.insert = getelementptr inbounds %struct.binding, ptr %binding.1, i64 0, i32 4
  %.pre516 = load ptr, ptr %uri671.phi.trans.insert, align 8
  br label %if.end670

if.then634:                                       ; preds = %if.end628
  %cmp635 = icmp sgt i32 %add631, 2147483623
  br i1 %cmp635, label %return, label %if.end638

if.end638:                                        ; preds = %if.then634
  %m_mem639 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 3
  %166 = load ptr, ptr %m_mem639, align 8
  %add640 = add nsw i32 %add631, 24
  %conv641 = sext i32 %add640 to i64
  %call643 = call ptr %166(i64 noundef %conv641) #24
  %tobool644.not = icmp eq ptr %call643, null
  br i1 %tobool644.not, label %return, label %if.end646

if.end646:                                        ; preds = %if.end638
  store i32 %add640, ptr %uriAlloc, align 4
  %uri649 = getelementptr inbounds %struct.binding, ptr %binding.1, i64 0, i32 4
  %167 = load ptr, ptr %uri649, align 8
  %168 = load i32, ptr %uriLen604, align 8
  %conv651 = sext i32 %168 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 1 %call643, ptr align 1 %167, i64 %conv651, i1 false)
  %m_tagStack = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 67
  %p.0465 = load ptr, ptr %m_tagStack, align 8
  %tobool654.not466 = icmp eq ptr %p.0465, null
  br i1 %tobool654.not466, label %for.end666, label %for.body655

for.body655:                                      ; preds = %if.end646, %for.inc665
  %p.0467 = phi ptr [ %p.0, %for.inc665 ], [ %p.0465, %if.end646 ]
  %name656 = getelementptr inbounds %struct.tag, ptr %p.0467, i64 0, i32 3
  %169 = load ptr, ptr %name656, align 8
  %170 = load ptr, ptr %uri649, align 8
  %cmp659 = icmp eq ptr %169, %170
  br i1 %cmp659, label %if.then661, label %for.inc665

if.then661:                                       ; preds = %for.body655
  store ptr %call643, ptr %name656, align 8
  br label %for.inc665

for.inc665:                                       ; preds = %for.body655, %if.then661
  %p.0 = load ptr, ptr %p.0467, align 8
  %tobool654.not = icmp eq ptr %p.0, null
  br i1 %tobool654.not, label %for.end666, label %for.body655, !llvm.loop !81

for.end666:                                       ; preds = %for.inc665, %if.end646
  %free_fcn = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 3, i32 2
  %171 = load ptr, ptr %free_fcn, align 8
  %172 = load ptr, ptr %uri649, align 8
  call void %171(ptr noundef %172) #24
  store ptr %call643, ptr %uri649, align 8
  %.pre517 = load i32, ptr %uriLen604, align 8
  br label %if.end670

if.end670:                                        ; preds = %if.end628.if.end670_crit_edge, %for.end666
  %173 = phi i32 [ %163, %if.end628.if.end670_crit_edge ], [ %.pre517, %for.end666 ]
  %174 = phi ptr [ %.pre516, %if.end628.if.end670_crit_edge ], [ %call643, %for.end666 ]
  %uri671 = getelementptr inbounds %struct.binding, ptr %binding.1, i64 0, i32 4
  %idx.ext673 = sext i32 %173 to i64
  %add.ptr674 = getelementptr i8, ptr %174, i64 %idx.ext673
  %conv675 = sext i32 %inc611 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %add.ptr674, ptr align 1 %localPart.1, i64 %conv675, i1 false)
  %tobool677.not = icmp eq i32 %prefixLen.1, 0
  br i1 %tobool677.not, label %if.end688, label %if.then678

if.then678:                                       ; preds = %if.end670
  %add.ptr681 = getelementptr i8, ptr %add.ptr674, i64 %idxprom612
  %m_namespaceSeparator682 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 83
  %175 = load i8, ptr %m_namespaceSeparator682, align 4
  store i8 %175, ptr %add.ptr681, align 1
  %add.ptr683 = getelementptr i8, ptr %add.ptr681, i64 1
  %176 = load ptr, ptr %binding.1, align 8
  %177 = load ptr, ptr %176, align 8
  %conv686 = sext i32 %prefixLen.1 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %add.ptr683, ptr align 1 %177, i64 %conv686, i1 false)
  br label %if.end688

if.end688:                                        ; preds = %if.then678, %if.end670
  %178 = load ptr, ptr %uri671, align 8
  store ptr %178, ptr %tagNamePtr, align 8
  br label %return

return:                                           ; preds = %land.lhs.true.i, %land.lhs.true14.i, %if.end107, %if.then150, %poolStoreString.exit, %for.body, %if.then218, %if.end348, %copy_salt_to_sipkey.exit, %lor.lhs.false344, %land.lhs.true366, %land.lhs.true398, %for.end446, %land.lhs.true489, %poolStoreString.exit.thread, %if.end638, %if.then634, %for.end616, %lor.lhs.false621, %if.else575, %if.then561, %for.end554, %if.then264, %if.then70, %if.then73, %if.then24, %if.end15, %land.lhs.true, %if.end, %poolCopyString.exit, %if.end688, %if.then308, %if.then296, %if.then43
  %retval.0 = phi i32 [ 1, %if.then43 ], [ 1, %if.then296 ], [ 0, %if.end688 ], [ 1, %if.then308 ], [ 1, %poolCopyString.exit ], [ 1, %if.end ], [ 1, %land.lhs.true ], [ 1, %if.end15 ], [ 1, %if.then24 ], [ 8, %if.then73 ], [ 8, %if.then70 ], [ 1, %if.then264 ], [ 0, %for.end554 ], [ 27, %if.then561 ], [ 0, %if.else575 ], [ 1, %lor.lhs.false621 ], [ 1, %for.end616 ], [ 1, %if.then634 ], [ 1, %if.end638 ], [ 1, %poolStoreString.exit.thread ], [ 1, %land.lhs.true489 ], [ 8, %for.end446 ], [ 1, %land.lhs.true398 ], [ 1, %land.lhs.true366 ], [ 27, %if.end348 ], [ 1, %copy_salt_to_sipkey.exit ], [ 1, %lor.lhs.false344 ], [ %call224, %if.then218 ], [ %call.i346, %if.end107 ], [ 1, %land.lhs.true14.i ], [ %call155, %if.then150 ], [ 1, %poolStoreString.exit ], [ 1, %for.body ], [ 1, %land.lhs.true.i ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @epilogProcessor(ptr noundef %parser, ptr noundef %s, ptr noundef %end, ptr nocapture noundef writeonly %nextPtr) #0 {
entry:
  %s.addr.i37 = alloca ptr, align 8
  %dataPtr.i38 = alloca ptr, align 8
  %s.addr.i = alloca ptr, align 8
  %dataPtr.i = alloca ptr, align 8
  %next = alloca ptr, align 8
  %m_processor = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 45
  store ptr @epilogProcessor, ptr %m_processor, align 8
  %m_eventPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 47
  store ptr %s, ptr %m_eventPtr, align 8
  %m_encoding = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 34
  %m_eventEndPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 48
  %m_defaultHandler11 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 18
  %m_handlerArg11.i43 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 1
  %m_dataBuf.i57 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 9
  %m_dataBufEnd.i59 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 10
  %m_parsingStatus42 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 85
  br label %for.cond

for.cond:                                         ; preds = %sw.epilog, %entry
  %s.addr.0 = phi ptr [ %s, %entry ], [ %43, %sw.epilog ]
  store ptr null, ptr %next, align 8
  %0 = load ptr, ptr %m_encoding, align 8
  %1 = load ptr, ptr %0, align 8
  %call = call i32 %1(ptr noundef nonnull %0, ptr noundef %s.addr.0, ptr noundef %end, ptr noundef nonnull %next) #24
  %2 = load ptr, ptr %next, align 8
  %call2 = call fastcc zeroext i8 @accountingDiffTolerated(ptr noundef nonnull %parser, i32 noundef %call, ptr noundef %s.addr.0, ptr noundef %2, i32 noundef 5652, i32 noundef 0), !range !13
  %tobool.not = icmp eq i8 %call2, 0
  br i1 %tobool.not, label %while.cond.i.i.i, label %if.end

while.cond.i.i.i:                                 ; preds = %for.cond, %while.cond.i.i.i
  %rootParser.0.i.i.i = phi ptr [ %3, %while.cond.i.i.i ], [ %parser, %for.cond ]
  %m_parentParser.i.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i.i, i64 0, i32 84
  %3 = load ptr, ptr %m_parentParser.i.i.i, align 8
  %tobool.not.i.i.i = icmp eq ptr %3, null
  br i1 %tobool.not.i.i.i, label %getRootParserOf.exit.i.i, label %while.cond.i.i.i, !llvm.loop !31

getRootParserOf.exit.i.i:                         ; preds = %while.cond.i.i.i
  %debugLevel.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i.i, i64 0, i32 90, i32 2
  %4 = load i32, ptr %debugLevel.i.i, align 8
  %cmp.i.i = icmp slt i32 %4, 1
  br i1 %cmp.i.i, label %return, label %if.end.i.i

if.end.i.i:                                       ; preds = %getRootParserOf.exit.i.i
  %m_accounting.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i.i, i64 0, i32 90
  %5 = load i64, ptr %m_accounting.i.i, align 8
  %tobool.not.i5.i.i = icmp eq i64 %5, 0
  %countBytesIndirect.phi.trans.insert.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i.i, i64 0, i32 90, i32 1
  %.pre.i.i = load i64, ptr %countBytesIndirect.phi.trans.insert.i.i, align 8
  br i1 %tobool.not.i5.i.i, label %accountingGetCurrentAmplification.exit.i.i, label %cond.true.i.i.i

cond.true.i.i.i:                                  ; preds = %if.end.i.i
  %add.i.i.i = add i64 %.pre.i.i, %5
  %conv.i.i.i = uitofp i64 %add.i.i.i to float
  %conv6.i.i.i = uitofp i64 %5 to float
  %div.i.i.i = fdiv float %conv.i.i.i, %conv6.i.i.i
  %6 = fpext float %div.i.i.i to double
  br label %accountingGetCurrentAmplification.exit.i.i

accountingGetCurrentAmplification.exit.i.i:       ; preds = %cond.true.i.i.i, %if.end.i.i
  %cond.i.i.i = phi double [ %6, %cond.true.i.i.i ], [ 1.000000e+00, %if.end.i.i ]
  %7 = load ptr, ptr @stderr, align 8
  %call4.i.i = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %7, ptr noundef nonnull @.str.311, ptr noundef nonnull %rootParser.0.i.i.i, i64 noundef %5, i64 noundef %.pre.i.i, double noundef %cond.i.i.i, ptr noundef nonnull @.str.317) #27
  br label %return

if.end:                                           ; preds = %for.cond
  %8 = load ptr, ptr %next, align 8
  store ptr %8, ptr %m_eventEndPtr, align 8
  switch i32 %call, label %return [
    i32 -15, label %sw.bb
    i32 -4, label %sw.bb9
    i32 15, label %sw.bb10
    i32 11, label %sw.bb16
    i32 13, label %sw.bb22
    i32 0, label %sw.bb28
    i32 -1, label %sw.bb30
    i32 -2, label %sw.bb35
  ]

sw.bb:                                            ; preds = %if.end
  %9 = load ptr, ptr %m_defaultHandler11, align 8
  %tobool3.not = icmp eq ptr %9, null
  br i1 %tobool3.not, label %if.end8, label %if.then4

if.then4:                                         ; preds = %sw.bb
  %10 = load ptr, ptr %m_encoding, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %s.addr.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %dataPtr.i)
  store ptr %s.addr.0, ptr %s.addr.i, align 8
  %isUtf8.i = getelementptr inbounds %struct.encoding, ptr %10, i64 0, i32 13
  %11 = load i8, ptr %isUtf8.i, align 4
  %tobool.not.i = icmp eq i8 %11, 0
  br i1 %tobool.not.i, label %if.end.i, label %if.else9.i

if.end.i:                                         ; preds = %if.then4
  %utf8Convert.i = getelementptr inbounds %struct.encoding, ptr %10, i64 0, i32 10
  br label %do.body.i

do.body.i:                                        ; preds = %do.body.i, %if.end.i
  %12 = load ptr, ptr %m_dataBuf.i57, align 8
  store ptr %12, ptr %dataPtr.i, align 8
  %13 = load ptr, ptr %utf8Convert.i, align 8
  %14 = load ptr, ptr %m_dataBufEnd.i59, align 8
  %call.i = call i32 %13(ptr noundef nonnull %10, ptr noundef nonnull %s.addr.i, ptr noundef %8, ptr noundef nonnull %dataPtr.i, ptr noundef %14) #24
  %15 = load ptr, ptr %s.addr.i, align 8
  store ptr %15, ptr %m_eventEndPtr, align 8
  %16 = load ptr, ptr %m_defaultHandler11, align 8
  %17 = load ptr, ptr %m_handlerArg11.i43, align 8
  %18 = load ptr, ptr %m_dataBuf.i57, align 8
  %19 = load ptr, ptr %dataPtr.i, align 8
  %sub.ptr.lhs.cast.i = ptrtoint ptr %19 to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %18 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %conv.i = trunc i64 %sub.ptr.sub.i to i32
  call void %16(ptr noundef %17, ptr noundef %18, i32 noundef %conv.i) #24
  %20 = load ptr, ptr %s.addr.i, align 8
  store ptr %20, ptr %m_eventPtr, align 8
  %21 = icmp ugt i32 %call.i, 1
  br i1 %21, label %do.body.i, label %reportDefault.exit, !llvm.loop !28

if.else9.i:                                       ; preds = %if.then4
  %22 = load ptr, ptr %m_handlerArg11.i43, align 8
  %sub.ptr.lhs.cast12.i = ptrtoint ptr %8 to i64
  %sub.ptr.rhs.cast13.i = ptrtoint ptr %s.addr.0 to i64
  %sub.ptr.sub14.i = sub i64 %sub.ptr.lhs.cast12.i, %sub.ptr.rhs.cast13.i
  %conv15.i = trunc i64 %sub.ptr.sub14.i to i32
  call void %9(ptr noundef %22, ptr noundef %s.addr.0, i32 noundef %conv15.i) #24
  br label %reportDefault.exit

reportDefault.exit:                               ; preds = %do.body.i, %if.else9.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %s.addr.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %dataPtr.i)
  %23 = load i32, ptr %m_parsingStatus42, align 8
  %cmp = icmp eq i32 %23, 2
  br i1 %cmp, label %return, label %reportDefault.exit.if.end8_crit_edge

reportDefault.exit.if.end8_crit_edge:             ; preds = %reportDefault.exit
  %.pre = load ptr, ptr %next, align 8
  br label %if.end8

if.end8:                                          ; preds = %reportDefault.exit.if.end8_crit_edge, %sw.bb
  %24 = phi ptr [ %.pre, %reportDefault.exit.if.end8_crit_edge ], [ %8, %sw.bb ]
  store ptr %24, ptr %nextPtr, align 8
  br label %return

sw.bb9:                                           ; preds = %if.end
  store ptr %s.addr.0, ptr %nextPtr, align 8
  br label %return

sw.bb10:                                          ; preds = %if.end
  %25 = load ptr, ptr %m_defaultHandler11, align 8
  %tobool12.not = icmp eq ptr %25, null
  br i1 %tobool12.not, label %sw.epilog, label %if.then13

if.then13:                                        ; preds = %sw.bb10
  %26 = load ptr, ptr %m_encoding, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %s.addr.i37)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %dataPtr.i38)
  store ptr %s.addr.0, ptr %s.addr.i37, align 8
  %isUtf8.i39 = getelementptr inbounds %struct.encoding, ptr %26, i64 0, i32 13
  %27 = load i8, ptr %isUtf8.i39, align 4
  %tobool.not.i40 = icmp eq i8 %27, 0
  br i1 %tobool.not.i40, label %if.end.i54, label %if.else9.i41

if.end.i54:                                       ; preds = %if.then13
  %utf8Convert.i58 = getelementptr inbounds %struct.encoding, ptr %26, i64 0, i32 10
  br label %do.body.i62

do.body.i62:                                      ; preds = %do.body.i62, %if.end.i54
  %28 = load ptr, ptr %m_dataBuf.i57, align 8
  store ptr %28, ptr %dataPtr.i38, align 8
  %29 = load ptr, ptr %utf8Convert.i58, align 8
  %30 = load ptr, ptr %m_dataBufEnd.i59, align 8
  %call.i63 = call i32 %29(ptr noundef nonnull %26, ptr noundef nonnull %s.addr.i37, ptr noundef %8, ptr noundef nonnull %dataPtr.i38, ptr noundef %30) #24
  %31 = load ptr, ptr %s.addr.i37, align 8
  store ptr %31, ptr %m_eventEndPtr, align 8
  %32 = load ptr, ptr %m_defaultHandler11, align 8
  %33 = load ptr, ptr %m_handlerArg11.i43, align 8
  %34 = load ptr, ptr %m_dataBuf.i57, align 8
  %35 = load ptr, ptr %dataPtr.i38, align 8
  %sub.ptr.lhs.cast.i64 = ptrtoint ptr %35 to i64
  %sub.ptr.rhs.cast.i65 = ptrtoint ptr %34 to i64
  %sub.ptr.sub.i66 = sub i64 %sub.ptr.lhs.cast.i64, %sub.ptr.rhs.cast.i65
  %conv.i67 = trunc i64 %sub.ptr.sub.i66 to i32
  call void %32(ptr noundef %33, ptr noundef %34, i32 noundef %conv.i67) #24
  %36 = load ptr, ptr %s.addr.i37, align 8
  store ptr %36, ptr %m_eventPtr, align 8
  %37 = icmp ugt i32 %call.i63, 1
  br i1 %37, label %do.body.i62, label %reportDefault.exit71, !llvm.loop !28

if.else9.i41:                                     ; preds = %if.then13
  %38 = load ptr, ptr %m_handlerArg11.i43, align 8
  %sub.ptr.lhs.cast12.i44 = ptrtoint ptr %8 to i64
  %sub.ptr.rhs.cast13.i45 = ptrtoint ptr %s.addr.0 to i64
  %sub.ptr.sub14.i46 = sub i64 %sub.ptr.lhs.cast12.i44, %sub.ptr.rhs.cast13.i45
  %conv15.i47 = trunc i64 %sub.ptr.sub14.i46 to i32
  call void %25(ptr noundef %38, ptr noundef %s.addr.0, i32 noundef %conv15.i47) #24
  br label %reportDefault.exit71

reportDefault.exit71:                             ; preds = %do.body.i62, %if.else9.i41
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %s.addr.i37)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %dataPtr.i38)
  br label %sw.epilog

sw.bb16:                                          ; preds = %if.end
  %39 = load ptr, ptr %m_encoding, align 8
  %call18 = call fastcc i32 @reportProcessingInstruction(ptr noundef nonnull %parser, ptr noundef %39, ptr noundef %s.addr.0, ptr noundef %8), !range !17
  %tobool19.not = icmp eq i32 %call18, 0
  br i1 %tobool19.not, label %return, label %sw.epilog

sw.bb22:                                          ; preds = %if.end
  %40 = load ptr, ptr %m_encoding, align 8
  %call24 = call fastcc i32 @reportComment(ptr noundef nonnull %parser, ptr noundef %40, ptr noundef %s.addr.0, ptr noundef %8), !range !17
  %tobool25.not = icmp eq i32 %call24, 0
  br i1 %tobool25.not, label %return, label %sw.epilog

sw.bb28:                                          ; preds = %if.end
  store ptr %8, ptr %m_eventPtr, align 8
  br label %return

sw.bb30:                                          ; preds = %if.end
  %finalBuffer = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 85, i32 1
  %41 = load i8, ptr %finalBuffer, align 4
  %tobool32.not = icmp eq i8 %41, 0
  br i1 %tobool32.not, label %if.then33, label %return

if.then33:                                        ; preds = %sw.bb30
  store ptr %s.addr.0, ptr %nextPtr, align 8
  br label %return

sw.bb35:                                          ; preds = %if.end
  %finalBuffer37 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 85, i32 1
  %42 = load i8, ptr %finalBuffer37, align 4
  %tobool38.not = icmp eq i8 %42, 0
  br i1 %tobool38.not, label %if.then39, label %return

if.then39:                                        ; preds = %sw.bb35
  store ptr %s.addr.0, ptr %nextPtr, align 8
  br label %return

sw.epilog:                                        ; preds = %sw.bb22, %sw.bb16, %sw.bb10, %reportDefault.exit71
  %43 = load ptr, ptr %next, align 8
  store ptr %43, ptr %m_eventPtr, align 8
  %44 = load i32, ptr %m_parsingStatus42, align 8
  switch i32 %44, label %for.cond [
    i32 3, label %sw.bb44
    i32 2, label %return
  ]

sw.bb44:                                          ; preds = %sw.epilog
  store ptr %43, ptr %nextPtr, align 8
  br label %return

return:                                           ; preds = %sw.epilog, %if.end, %sw.bb22, %sw.bb16, %accountingGetCurrentAmplification.exit.i.i, %getRootParserOf.exit.i.i, %sw.bb35, %sw.bb30, %reportDefault.exit, %sw.bb44, %if.then39, %if.then33, %sw.bb28, %sw.bb9, %if.end8
  %retval.0 = phi i32 [ 0, %if.then39 ], [ 0, %if.then33 ], [ 4, %sw.bb28 ], [ 0, %sw.bb44 ], [ 0, %sw.bb9 ], [ 0, %if.end8 ], [ 35, %reportDefault.exit ], [ 5, %sw.bb30 ], [ 6, %sw.bb35 ], [ 43, %getRootParserOf.exit.i.i ], [ 43, %accountingGetCurrentAmplification.exit.i.i ], [ 35, %sw.epilog ], [ 9, %if.end ], [ 1, %sw.bb22 ], [ 1, %sw.bb16 ]
  ret i32 %retval.0
}

declare i32 @PyExpat_XmlUtf8Encode(i32 noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define internal fastcc i32 @doCdataSection(ptr noundef %parser, ptr noundef %enc, ptr nocapture noundef %startPtr, ptr noundef %end, ptr nocapture noundef writeonly %nextPtr, i8 noundef zeroext %haveMore, i32 noundef %account) unnamed_addr #0 {
entry:
  %s.addr.i53 = alloca ptr, align 8
  %dataPtr.i54 = alloca ptr, align 8
  %s.addr.i = alloca ptr, align 8
  %dataPtr.i = alloca ptr, align 8
  %s = alloca ptr, align 8
  %next = alloca ptr, align 8
  %c = alloca i8, align 1
  %dataPtr = alloca ptr, align 8
  %0 = load ptr, ptr %startPtr, align 8
  store ptr %0, ptr %s, align 8
  %m_encoding = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 34
  %1 = load ptr, ptr %m_encoding, align 8
  %cmp = icmp eq ptr %1, %enc
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %m_eventPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 47
  store ptr %0, ptr %m_eventPtr, align 8
  %m_eventEndPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 48
  br label %if.end

if.else:                                          ; preds = %entry
  %m_openInternalEntities = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 50
  %2 = load ptr, ptr %m_openInternalEntities, align 8
  %internalEventEndPtr = getelementptr inbounds %struct.open_internal_entity, ptr %2, i64 0, i32 1
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %eventEndPP.0 = phi ptr [ %m_eventEndPtr, %if.then ], [ %internalEventEndPtr, %if.else ]
  %eventPP.0 = phi ptr [ %m_eventPtr, %if.then ], [ %2, %if.else ]
  store ptr %0, ptr %eventPP.0, align 8
  store ptr null, ptr %startPtr, align 8
  %arrayidx = getelementptr [4 x ptr], ptr %enc, i64 0, i64 2
  %m_characterDataHandler28 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 13
  %isUtf8 = getelementptr inbounds %struct.encoding, ptr %enc, i64 0, i32 13
  %m_handlerArg45 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 1
  %m_dataBuf = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 9
  %utf8Convert = getelementptr inbounds %struct.encoding, ptr %enc, i64 0, i32 10
  %m_dataBufEnd = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 10
  %m_defaultHandler52 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 18
  %m_openInternalEntities.i68 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 50
  %m_eventPtr.i85 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 47
  %m_eventEndPtr.i86 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 48
  %m_parsingStatus66 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 85
  br label %for.cond

for.cond:                                         ; preds = %sw.epilog, %if.end
  %3 = load ptr, ptr %s, align 8
  store ptr %3, ptr %next, align 8
  %4 = load ptr, ptr %arrayidx, align 8
  %call = call i32 %4(ptr noundef %enc, ptr noundef %3, ptr noundef %end, ptr noundef nonnull %next) #24
  %5 = load ptr, ptr %s, align 8
  %6 = load ptr, ptr %next, align 8
  %call2 = call fastcc zeroext i8 @accountingDiffTolerated(ptr noundef nonnull %parser, i32 noundef %call, ptr noundef %5, ptr noundef %6, i32 noundef 4044, i32 noundef %account), !range !13
  %tobool.not = icmp eq i8 %call2, 0
  br i1 %tobool.not, label %while.cond.i.i.i, label %if.end4

while.cond.i.i.i:                                 ; preds = %for.cond, %while.cond.i.i.i
  %rootParser.0.i.i.i = phi ptr [ %7, %while.cond.i.i.i ], [ %parser, %for.cond ]
  %m_parentParser.i.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i.i, i64 0, i32 84
  %7 = load ptr, ptr %m_parentParser.i.i.i, align 8
  %tobool.not.i.i.i = icmp eq ptr %7, null
  br i1 %tobool.not.i.i.i, label %getRootParserOf.exit.i.i, label %while.cond.i.i.i, !llvm.loop !31

getRootParserOf.exit.i.i:                         ; preds = %while.cond.i.i.i
  %debugLevel.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i.i, i64 0, i32 90, i32 2
  %8 = load i32, ptr %debugLevel.i.i, align 8
  %cmp.i.i = icmp slt i32 %8, 1
  br i1 %cmp.i.i, label %return, label %if.end.i.i

if.end.i.i:                                       ; preds = %getRootParserOf.exit.i.i
  %m_accounting.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i.i, i64 0, i32 90
  %9 = load i64, ptr %m_accounting.i.i, align 8
  %tobool.not.i5.i.i = icmp eq i64 %9, 0
  %countBytesIndirect.phi.trans.insert.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i.i, i64 0, i32 90, i32 1
  %.pre.i.i = load i64, ptr %countBytesIndirect.phi.trans.insert.i.i, align 8
  br i1 %tobool.not.i5.i.i, label %accountingGetCurrentAmplification.exit.i.i, label %cond.true.i.i.i

cond.true.i.i.i:                                  ; preds = %if.end.i.i
  %add.i.i.i = add i64 %.pre.i.i, %9
  %conv.i.i.i = uitofp i64 %add.i.i.i to float
  %conv6.i.i.i = uitofp i64 %9 to float
  %div.i.i.i = fdiv float %conv.i.i.i, %conv6.i.i.i
  %10 = fpext float %div.i.i.i to double
  br label %accountingGetCurrentAmplification.exit.i.i

accountingGetCurrentAmplification.exit.i.i:       ; preds = %cond.true.i.i.i, %if.end.i.i
  %cond.i.i.i = phi double [ %10, %cond.true.i.i.i ], [ 1.000000e+00, %if.end.i.i ]
  %11 = load ptr, ptr @stderr, align 8
  %call4.i.i = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %11, ptr noundef nonnull @.str.311, ptr noundef nonnull %rootParser.0.i.i.i, i64 noundef %9, i64 noundef %.pre.i.i, double noundef %cond.i.i.i, ptr noundef nonnull @.str.317) #27
  br label %return

if.end4:                                          ; preds = %for.cond
  %12 = load ptr, ptr %next, align 8
  store ptr %12, ptr %eventEndPP.0, align 8
  switch i32 %call, label %sw.default [
    i32 40, label %sw.bb
    i32 7, label %sw.bb16
    i32 6, label %sw.bb27
    i32 0, label %sw.bb57
    i32 -2, label %sw.bb58
    i32 -1, label %sw.bb62
    i32 -4, label %sw.bb62
  ]

sw.bb:                                            ; preds = %if.end4
  %m_endCdataSectionHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 17
  %13 = load ptr, ptr %m_endCdataSectionHandler, align 8
  %tobool5.not = icmp eq ptr %13, null
  br i1 %tobool5.not, label %if.else8, label %if.then6

if.then6:                                         ; preds = %sw.bb
  %14 = load ptr, ptr %m_handlerArg45, align 8
  call void %13(ptr noundef %14) #24
  br label %if.end12

if.else8:                                         ; preds = %sw.bb
  %15 = load ptr, ptr %m_defaultHandler52, align 8
  %tobool9.not = icmp eq ptr %15, null
  br i1 %tobool9.not, label %if.end12, label %if.then10

if.then10:                                        ; preds = %if.else8
  %16 = load ptr, ptr %s, align 8
  call fastcc void @reportDefault(ptr noundef nonnull %parser, ptr noundef nonnull %enc, ptr noundef %16, ptr noundef %12)
  br label %if.end12

if.end12:                                         ; preds = %if.else8, %if.then10, %if.then6
  %17 = load ptr, ptr %next, align 8
  store ptr %17, ptr %startPtr, align 8
  store ptr %17, ptr %nextPtr, align 8
  %18 = load i32, ptr %m_parsingStatus66, align 8
  %cmp13 = icmp eq i32 %18, 2
  %. = select i1 %cmp13, i32 35, i32 0
  br label %return

sw.bb16:                                          ; preds = %if.end4
  %19 = load ptr, ptr %m_characterDataHandler28, align 8
  %tobool17.not = icmp eq ptr %19, null
  br i1 %tobool17.not, label %if.else21, label %if.then18

if.then18:                                        ; preds = %sw.bb16
  store i8 10, ptr %c, align 1
  %20 = load ptr, ptr %m_handlerArg45, align 8
  call void %19(ptr noundef %20, ptr noundef nonnull %c, i32 noundef 1) #24
  br label %sw.epilog

if.else21:                                        ; preds = %sw.bb16
  %21 = load ptr, ptr %m_defaultHandler52, align 8
  %tobool23.not = icmp eq ptr %21, null
  br i1 %tobool23.not, label %sw.epilog, label %if.then24

if.then24:                                        ; preds = %if.else21
  %22 = load ptr, ptr %s, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %s.addr.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %dataPtr.i)
  store ptr %22, ptr %s.addr.i, align 8
  %23 = load i8, ptr %isUtf8, align 4
  %tobool.not.i = icmp eq i8 %23, 0
  br i1 %tobool.not.i, label %if.then.i, label %if.else9.i

if.then.i:                                        ; preds = %if.then24
  %24 = load ptr, ptr %m_encoding, align 8
  %cmp.i = icmp eq ptr %24, %enc
  br i1 %cmp.i, label %if.end.i, label %if.else.i

if.else.i:                                        ; preds = %if.then.i
  %25 = load ptr, ptr %m_openInternalEntities.i68, align 8
  %internalEventEndPtr.i = getelementptr inbounds %struct.open_internal_entity, ptr %25, i64 0, i32 1
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %if.else.i
  %eventPP.0.i = phi ptr [ %25, %if.else.i ], [ %m_eventPtr.i85, %if.then.i ]
  %eventEndPP.0.i = phi ptr [ %internalEventEndPtr.i, %if.else.i ], [ %m_eventEndPtr.i86, %if.then.i ]
  br label %do.body.i

do.body.i:                                        ; preds = %do.body.i, %if.end.i
  %26 = load ptr, ptr %m_dataBuf, align 8
  store ptr %26, ptr %dataPtr.i, align 8
  %27 = load ptr, ptr %utf8Convert, align 8
  %28 = load ptr, ptr %m_dataBufEnd, align 8
  %call.i = call i32 %27(ptr noundef nonnull %enc, ptr noundef nonnull %s.addr.i, ptr noundef %12, ptr noundef nonnull %dataPtr.i, ptr noundef %28) #24
  %29 = load ptr, ptr %s.addr.i, align 8
  store ptr %29, ptr %eventEndPP.0.i, align 8
  %30 = load ptr, ptr %m_defaultHandler52, align 8
  %31 = load ptr, ptr %m_handlerArg45, align 8
  %32 = load ptr, ptr %m_dataBuf, align 8
  %33 = load ptr, ptr %dataPtr.i, align 8
  %sub.ptr.lhs.cast.i = ptrtoint ptr %33 to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %32 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %conv.i = trunc i64 %sub.ptr.sub.i to i32
  call void %30(ptr noundef %31, ptr noundef %32, i32 noundef %conv.i) #24
  %34 = load ptr, ptr %s.addr.i, align 8
  store ptr %34, ptr %eventPP.0.i, align 8
  %35 = icmp ugt i32 %call.i, 1
  br i1 %35, label %do.body.i, label %reportDefault.exit, !llvm.loop !28

if.else9.i:                                       ; preds = %if.then24
  %36 = load ptr, ptr %m_handlerArg45, align 8
  %sub.ptr.lhs.cast12.i = ptrtoint ptr %12 to i64
  %sub.ptr.rhs.cast13.i = ptrtoint ptr %22 to i64
  %sub.ptr.sub14.i = sub i64 %sub.ptr.lhs.cast12.i, %sub.ptr.rhs.cast13.i
  %conv15.i = trunc i64 %sub.ptr.sub14.i to i32
  call void %21(ptr noundef %36, ptr noundef %22, i32 noundef %conv15.i) #24
  br label %reportDefault.exit

reportDefault.exit:                               ; preds = %do.body.i, %if.else9.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %s.addr.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %dataPtr.i)
  br label %sw.epilog

sw.bb27:                                          ; preds = %if.end4
  %37 = load ptr, ptr %m_characterDataHandler28, align 8
  %tobool29.not = icmp eq ptr %37, null
  br i1 %tobool29.not, label %if.else51, label %if.then30

if.then30:                                        ; preds = %sw.bb27
  %38 = load i8, ptr %isUtf8, align 4
  %tobool31.not = icmp eq i8 %38, 0
  br i1 %tobool31.not, label %for.cond33, label %if.else44

for.cond33:                                       ; preds = %if.then30, %if.end43
  %39 = phi ptr [ %.pre, %if.end43 ], [ %12, %if.then30 ]
  %40 = load ptr, ptr %m_dataBuf, align 8
  store ptr %40, ptr %dataPtr, align 8
  %41 = load ptr, ptr %utf8Convert, align 8
  %42 = load ptr, ptr %m_dataBufEnd, align 8
  %call34 = call i32 %41(ptr noundef %enc, ptr noundef nonnull %s, ptr noundef %39, ptr noundef nonnull %dataPtr, ptr noundef %42) #24
  %43 = load ptr, ptr %next, align 8
  store ptr %43, ptr %eventEndPP.0, align 8
  %44 = load ptr, ptr %m_handlerArg45, align 8
  %45 = load ptr, ptr %m_dataBuf, align 8
  %46 = load ptr, ptr %dataPtr, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %46 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %45 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv = trunc i64 %sub.ptr.sub to i32
  call void %37(ptr noundef %44, ptr noundef %45, i32 noundef %conv) #24
  %or.cond = icmp ult i32 %call34, 2
  br i1 %or.cond, label %sw.epilog, label %if.end43

if.end43:                                         ; preds = %for.cond33
  %47 = load ptr, ptr %s, align 8
  store ptr %47, ptr %eventPP.0, align 8
  %.pre = load ptr, ptr %next, align 8
  br label %for.cond33

if.else44:                                        ; preds = %if.then30
  %48 = load ptr, ptr %m_handlerArg45, align 8
  %49 = load ptr, ptr %s, align 8
  %sub.ptr.lhs.cast46 = ptrtoint ptr %12 to i64
  %sub.ptr.rhs.cast47 = ptrtoint ptr %49 to i64
  %sub.ptr.sub48 = sub i64 %sub.ptr.lhs.cast46, %sub.ptr.rhs.cast47
  %conv49 = trunc i64 %sub.ptr.sub48 to i32
  call void %37(ptr noundef %48, ptr noundef %49, i32 noundef %conv49) #24
  br label %sw.epilog

if.else51:                                        ; preds = %sw.bb27
  %50 = load ptr, ptr %m_defaultHandler52, align 8
  %tobool53.not = icmp eq ptr %50, null
  br i1 %tobool53.not, label %sw.epilog, label %if.then54

if.then54:                                        ; preds = %if.else51
  %51 = load ptr, ptr %s, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %s.addr.i53)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %dataPtr.i54)
  store ptr %51, ptr %s.addr.i53, align 8
  %52 = load i8, ptr %isUtf8, align 4
  %tobool.not.i56 = icmp eq i8 %52, 0
  br i1 %tobool.not.i56, label %if.then.i64, label %if.else9.i57

if.then.i64:                                      ; preds = %if.then54
  %53 = load ptr, ptr %m_encoding, align 8
  %cmp.i66 = icmp eq ptr %53, %enc
  br i1 %cmp.i66, label %if.end.i70, label %if.else.i67

if.else.i67:                                      ; preds = %if.then.i64
  %54 = load ptr, ptr %m_openInternalEntities.i68, align 8
  %internalEventEndPtr.i69 = getelementptr inbounds %struct.open_internal_entity, ptr %54, i64 0, i32 1
  br label %if.end.i70

if.end.i70:                                       ; preds = %if.then.i64, %if.else.i67
  %eventPP.0.i71 = phi ptr [ %54, %if.else.i67 ], [ %m_eventPtr.i85, %if.then.i64 ]
  %eventEndPP.0.i72 = phi ptr [ %internalEventEndPtr.i69, %if.else.i67 ], [ %m_eventEndPtr.i86, %if.then.i64 ]
  br label %do.body.i78

do.body.i78:                                      ; preds = %do.body.i78, %if.end.i70
  %55 = load ptr, ptr %m_dataBuf, align 8
  store ptr %55, ptr %dataPtr.i54, align 8
  %56 = load ptr, ptr %utf8Convert, align 8
  %57 = load ptr, ptr %m_dataBufEnd, align 8
  %call.i79 = call i32 %56(ptr noundef nonnull %enc, ptr noundef nonnull %s.addr.i53, ptr noundef %12, ptr noundef nonnull %dataPtr.i54, ptr noundef %57) #24
  %58 = load ptr, ptr %s.addr.i53, align 8
  store ptr %58, ptr %eventEndPP.0.i72, align 8
  %59 = load ptr, ptr %m_defaultHandler52, align 8
  %60 = load ptr, ptr %m_handlerArg45, align 8
  %61 = load ptr, ptr %m_dataBuf, align 8
  %62 = load ptr, ptr %dataPtr.i54, align 8
  %sub.ptr.lhs.cast.i80 = ptrtoint ptr %62 to i64
  %sub.ptr.rhs.cast.i81 = ptrtoint ptr %61 to i64
  %sub.ptr.sub.i82 = sub i64 %sub.ptr.lhs.cast.i80, %sub.ptr.rhs.cast.i81
  %conv.i83 = trunc i64 %sub.ptr.sub.i82 to i32
  call void %59(ptr noundef %60, ptr noundef %61, i32 noundef %conv.i83) #24
  %63 = load ptr, ptr %s.addr.i53, align 8
  store ptr %63, ptr %eventPP.0.i71, align 8
  %64 = icmp ugt i32 %call.i79, 1
  br i1 %64, label %do.body.i78, label %reportDefault.exit87, !llvm.loop !28

if.else9.i57:                                     ; preds = %if.then54
  %65 = load ptr, ptr %m_handlerArg45, align 8
  %sub.ptr.lhs.cast12.i60 = ptrtoint ptr %12 to i64
  %sub.ptr.rhs.cast13.i61 = ptrtoint ptr %51 to i64
  %sub.ptr.sub14.i62 = sub i64 %sub.ptr.lhs.cast12.i60, %sub.ptr.rhs.cast13.i61
  %conv15.i63 = trunc i64 %sub.ptr.sub14.i62 to i32
  call void %50(ptr noundef %65, ptr noundef %51, i32 noundef %conv15.i63) #24
  br label %reportDefault.exit87

reportDefault.exit87:                             ; preds = %do.body.i78, %if.else9.i57
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %s.addr.i53)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %dataPtr.i54)
  br label %sw.epilog

sw.bb57:                                          ; preds = %if.end4
  store ptr %12, ptr %eventPP.0, align 8
  br label %return

sw.bb58:                                          ; preds = %if.end4
  %tobool59.not = icmp eq i8 %haveMore, 0
  br i1 %tobool59.not, label %return, label %if.then60

if.then60:                                        ; preds = %sw.bb58
  %66 = load ptr, ptr %s, align 8
  store ptr %66, ptr %nextPtr, align 8
  br label %return

sw.bb62:                                          ; preds = %if.end4, %if.end4
  %tobool63.not = icmp eq i8 %haveMore, 0
  br i1 %tobool63.not, label %return, label %if.then64

if.then64:                                        ; preds = %sw.bb62
  %67 = load ptr, ptr %s, align 8
  store ptr %67, ptr %nextPtr, align 8
  br label %return

sw.default:                                       ; preds = %if.end4
  store ptr %12, ptr %eventPP.0, align 8
  br label %return

sw.epilog:                                        ; preds = %for.cond33, %if.else44, %reportDefault.exit87, %if.else51, %if.then18, %reportDefault.exit, %if.else21
  %68 = load ptr, ptr %next, align 8
  store ptr %68, ptr %s, align 8
  store ptr %68, ptr %eventPP.0, align 8
  %69 = load i32, ptr %m_parsingStatus66, align 8
  switch i32 %69, label %for.cond [
    i32 3, label %sw.bb68
    i32 2, label %return
  ]

sw.bb68:                                          ; preds = %sw.epilog
  store ptr %68, ptr %nextPtr, align 8
  br label %return

return:                                           ; preds = %sw.epilog, %accountingGetCurrentAmplification.exit.i.i, %getRootParserOf.exit.i.i, %sw.bb62, %sw.bb58, %if.end12, %sw.bb68, %sw.default, %if.then64, %if.then60, %sw.bb57
  %retval.0 = phi i32 [ 23, %sw.default ], [ 0, %if.then64 ], [ 0, %if.then60 ], [ 4, %sw.bb57 ], [ 0, %sw.bb68 ], [ %., %if.end12 ], [ 6, %sw.bb58 ], [ 20, %sw.bb62 ], [ 43, %getRootParserOf.exit.i.i ], [ 43, %accountingGetCurrentAmplification.exit.i.i ], [ 35, %sw.epilog ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @cdataSectionProcessor(ptr noundef %parser, ptr noundef %start, ptr noundef %end, ptr nocapture noundef writeonly %endPtr) #0 {
entry:
  %start.addr = alloca ptr, align 8
  store ptr %start, ptr %start.addr, align 8
  %m_encoding = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 34
  %0 = load ptr, ptr %m_encoding, align 8
  %finalBuffer = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 85, i32 1
  %1 = load i8, ptr %finalBuffer, align 4
  %tobool.not = icmp eq i8 %1, 0
  %conv = zext i1 %tobool.not to i8
  %call = call fastcc i32 @doCdataSection(ptr noundef %parser, ptr noundef %0, ptr noundef nonnull %start.addr, ptr noundef %end, ptr noundef %endPtr, i8 noundef zeroext %conv, i32 noundef 0), !range !32
  %cmp.not = icmp eq i32 %call, 0
  br i1 %cmp.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %start.addr, align 8
  %tobool2.not = icmp eq ptr %2, null
  br i1 %tobool2.not, label %return, label %if.then3

if.then3:                                         ; preds = %if.end
  %m_parentParser = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 84
  %3 = load ptr, ptr %m_parentParser, align 8
  %tobool4.not = icmp eq ptr %3, null
  %m_processor7 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 45
  br i1 %tobool4.not, label %if.else, label %if.then5

if.then5:                                         ; preds = %if.then3
  store ptr @externalEntityContentProcessor, ptr %m_processor7, align 8
  %call6 = tail call i32 @externalEntityContentProcessor(ptr noundef nonnull %parser, ptr noundef nonnull %2, ptr noundef %end, ptr noundef %endPtr)
  br label %return

if.else:                                          ; preds = %if.then3
  store ptr @contentProcessor, ptr %m_processor7, align 8
  %call8 = tail call i32 @contentProcessor(ptr noundef nonnull %parser, ptr noundef nonnull %2, ptr noundef %end, ptr noundef %endPtr)
  br label %return

return:                                           ; preds = %if.end, %entry, %if.else, %if.then5
  %retval.0 = phi i32 [ %call6, %if.then5 ], [ %call8, %if.else ], [ %call, %entry ], [ 0, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @setElementTypePrefix(ptr nocapture noundef readonly %parser, ptr nocapture noundef %elementType) unnamed_addr #0 {
entry:
  %m_dtd = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 65
  %0 = load ptr, ptr %m_dtd, align 8
  %1 = load ptr, ptr %elementType, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc56, %entry
  %name.0 = phi ptr [ %1, %entry ], [ %incdec.ptr57, %for.inc56 ]
  %2 = load i8, ptr %name.0, align 1
  switch i8 %2, label %for.inc56 [
    i8 0, label %return
    i8 58, label %for.cond4.preheader
  ]

for.cond4.preheader:                              ; preds = %for.cond
  %cmp5.not28 = icmp eq ptr %1, %name.0
  br i1 %cmp5.not28, label %for.end, label %for.body7.lr.ph

for.body7.lr.ph:                                  ; preds = %for.cond4.preheader
  %ptr = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 4, i32 3
  %end = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 4, i32 2
  %pool = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 4
  br label %for.body7

for.body7:                                        ; preds = %for.body7.lr.ph, %cond.false
  %s.029 = phi ptr [ %1, %for.body7.lr.ph ], [ %incdec.ptr16, %cond.false ]
  %3 = load ptr, ptr %ptr, align 8
  %4 = load ptr, ptr %end, align 8
  %cmp9 = icmp eq ptr %3, %4
  br i1 %cmp9, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %for.body7
  %call = tail call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool), !range !13
  %tobool12.not = icmp eq i8 %call, 0
  br i1 %tobool12.not, label %return, label %land.lhs.true.cond.false_crit_edge

land.lhs.true.cond.false_crit_edge:               ; preds = %land.lhs.true
  %.pre = load ptr, ptr %ptr, align 8
  br label %cond.false

cond.false:                                       ; preds = %land.lhs.true.cond.false_crit_edge, %for.body7
  %5 = phi ptr [ %.pre, %land.lhs.true.cond.false_crit_edge ], [ %3, %for.body7 ]
  %6 = load i8, ptr %s.029, align 1
  %incdec.ptr = getelementptr i8, ptr %5, i64 1
  store ptr %incdec.ptr, ptr %ptr, align 8
  store i8 %6, ptr %5, align 1
  %incdec.ptr16 = getelementptr i8, ptr %s.029, i64 1
  %cmp5.not = icmp eq ptr %incdec.ptr16, %name.0
  br i1 %cmp5.not, label %for.end, label %for.body7, !llvm.loop !82

for.end:                                          ; preds = %cond.false, %for.cond4.preheader
  %ptr18 = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 4, i32 3
  %7 = load ptr, ptr %ptr18, align 8
  %end20 = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 4, i32 2
  %8 = load ptr, ptr %end20, align 8
  %cmp21 = icmp eq ptr %7, %8
  br i1 %cmp21, label %land.lhs.true23, label %cond.false28

land.lhs.true23:                                  ; preds = %for.end
  %pool17 = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 4
  %call25 = tail call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool17), !range !13
  %tobool26.not = icmp eq i8 %call25, 0
  br i1 %tobool26.not, label %return, label %land.lhs.true23.cond.false28_crit_edge

land.lhs.true23.cond.false28_crit_edge:           ; preds = %land.lhs.true23
  %.pre32 = load ptr, ptr %ptr18, align 8
  br label %cond.false28

cond.false28:                                     ; preds = %land.lhs.true23.cond.false28_crit_edge, %for.end
  %9 = phi ptr [ %.pre32, %land.lhs.true23.cond.false28_crit_edge ], [ %7, %for.end ]
  %incdec.ptr31 = getelementptr i8, ptr %9, i64 1
  store ptr %incdec.ptr31, ptr %ptr18, align 8
  store i8 0, ptr %9, align 1
  %prefixes = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 3
  %start = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 4, i32 4
  %10 = load ptr, ptr %start, align 8
  %call35 = tail call fastcc ptr @lookup(ptr noundef %parser, ptr noundef nonnull %prefixes, ptr noundef %10, i64 noundef 16)
  %tobool36.not = icmp eq ptr %call35, null
  br i1 %tobool36.not, label %return, label %if.end38

if.end38:                                         ; preds = %cond.false28
  %11 = load ptr, ptr %call35, align 8
  %12 = load ptr, ptr %start, align 8
  %cmp42 = icmp eq ptr %11, %12
  br i1 %cmp42, label %if.then44, label %if.else

if.then44:                                        ; preds = %if.end38
  %13 = load ptr, ptr %ptr18, align 8
  store ptr %13, ptr %start, align 8
  br label %if.end53

if.else:                                          ; preds = %if.end38
  store ptr %12, ptr %ptr18, align 8
  br label %if.end53

if.end53:                                         ; preds = %if.else, %if.then44
  %prefix54 = getelementptr inbounds %struct.ELEMENT_TYPE, ptr %elementType, i64 0, i32 1
  store ptr %call35, ptr %prefix54, align 8
  br label %return

for.inc56:                                        ; preds = %for.cond
  %incdec.ptr57 = getelementptr i8, ptr %name.0, i64 1
  br label %for.cond, !llvm.loop !83

return:                                           ; preds = %for.cond, %land.lhs.true, %if.end53, %cond.false28, %land.lhs.true23
  %retval.0 = phi i32 [ 0, %land.lhs.true23 ], [ 0, %cond.false28 ], [ 1, %if.end53 ], [ 0, %land.lhs.true ], [ 1, %for.cond ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @addBinding(ptr nocapture noundef %parser, ptr noundef %prefix, ptr noundef %attId, ptr noundef %uri, ptr nocapture noundef %bindingsPtr) unnamed_addr #0 {
entry:
  %0 = load i8, ptr %uri, align 1
  %cmp = icmp eq i8 %0, 0
  %1 = load ptr, ptr %prefix, align 8
  %tobool.not = icmp eq ptr %1, null
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  br i1 %tobool.not, label %for.end, label %return

if.end:                                           ; preds = %entry
  br i1 %tobool.not, label %for.body.lr.ph.split, label %land.lhs.true4

land.lhs.true4:                                   ; preds = %if.end
  %2 = load i8, ptr %1, align 1
  %cmp7 = icmp eq i8 %2, 120
  br i1 %cmp7, label %land.lhs.true9, label %for.body.lr.ph.split

land.lhs.true9:                                   ; preds = %land.lhs.true4
  %arrayidx11 = getelementptr i8, ptr %1, i64 1
  %3 = load i8, ptr %arrayidx11, align 1
  %cmp13 = icmp eq i8 %3, 109
  br i1 %cmp13, label %land.lhs.true15, label %for.body.lr.ph.split

land.lhs.true15:                                  ; preds = %land.lhs.true9
  %arrayidx17 = getelementptr i8, ptr %1, i64 2
  %4 = load i8, ptr %arrayidx17, align 1
  %cmp19 = icmp eq i8 %4, 108
  br i1 %cmp19, label %if.then21, label %for.body.lr.ph.split

if.then21:                                        ; preds = %land.lhs.true15
  %arrayidx23 = getelementptr i8, ptr %1, i64 3
  %5 = load i8, ptr %arrayidx23, align 1
  switch i8 %5, label %for.body.lr.ph.split [
    i8 110, label %land.lhs.true27
    i8 0, label %for.body.lr.ph.split.us
  ]

land.lhs.true27:                                  ; preds = %if.then21
  %arrayidx29 = getelementptr i8, ptr %1, i64 4
  %6 = load i8, ptr %arrayidx29, align 1
  %cmp31 = icmp eq i8 %6, 115
  br i1 %cmp31, label %land.lhs.true33, label %for.body.lr.ph.split

land.lhs.true33:                                  ; preds = %land.lhs.true27
  %arrayidx35 = getelementptr i8, ptr %1, i64 5
  %7 = load i8, ptr %arrayidx35, align 1
  %cmp37 = icmp eq i8 %7, 0
  br i1 %cmp37, label %return, label %for.body.lr.ph.split

for.body.lr.ph.split.us:                          ; preds = %if.then21
  %m_ns = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 38
  %8 = load i8, ptr %m_ns, align 8
  %tobool85.not = icmp eq i8 %8, 0
  br i1 %tobool85.not, label %for.body.us.us, label %for.body.lr.ph.split.us.split

for.body.us.us:                                   ; preds = %for.body.lr.ph.split.us, %if.end65.us.us
  %9 = phi i8 [ %11, %if.end65.us.us ], [ %0, %for.body.lr.ph.split.us ]
  %idxprom104.us.us = phi i64 [ %idxprom.us.us, %if.end65.us.us ], [ 0, %for.body.lr.ph.split.us ]
  %len.0103.us.us = phi i32 [ %inc.us.us, %if.end65.us.us ], [ 0, %for.body.lr.ph.split.us ]
  %isXML.0101.us.us = phi i8 [ %isXML.1.us.us, %if.end65.us.us ], [ 1, %for.body.lr.ph.split.us ]
  %tobool52.not.us.us = icmp eq i8 %isXML.0101.us.us, 0
  br i1 %tobool52.not.us.us, label %if.end65.us.us, label %land.lhs.true53.us.us

land.lhs.true53.us.us:                            ; preds = %for.body.us.us
  %cmp54.us.us = icmp sgt i32 %len.0103.us.us, 36
  br i1 %cmp54.us.us, label %if.then64.us.us, label %lor.lhs.false.us.us

lor.lhs.false.us.us:                              ; preds = %land.lhs.true53.us.us
  %arrayidx60.us.us = getelementptr [37 x i8], ptr @addBinding.xmlNamespace, i64 0, i64 %idxprom104.us.us
  %10 = load i8, ptr %arrayidx60.us.us, align 1
  %cmp62.not.us.us = icmp eq i8 %9, %10
  br i1 %cmp62.not.us.us, label %if.end65.us.us, label %if.then64.us.us

if.then64.us.us:                                  ; preds = %lor.lhs.false.us.us, %land.lhs.true53.us.us
  br label %if.end65.us.us

if.end65.us.us:                                   ; preds = %if.then64.us.us, %lor.lhs.false.us.us, %for.body.us.us
  %isXML.1.us.us = phi i8 [ 0, %if.then64.us.us ], [ %isXML.0101.us.us, %lor.lhs.false.us.us ], [ 0, %for.body.us.us ]
  %inc.us.us = add i32 %len.0103.us.us, 1
  %idxprom.us.us = sext i32 %inc.us.us to i64
  %arrayidx49.us.us = getelementptr i8, ptr %uri, i64 %idxprom.us.us
  %11 = load i8, ptr %arrayidx49.us.us, align 1
  %tobool50.not.us.us = icmp eq i8 %11, 0
  br i1 %tobool50.not.us.us, label %for.end, label %for.body.us.us, !llvm.loop !84

for.body.lr.ph.split.us.split:                    ; preds = %for.body.lr.ph.split.us
  %m_namespaceSeparator = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 83
  %12 = load i8, ptr %m_namespaceSeparator, align 4
  %conv.i.us = sext i8 %12 to i32
  br label %for.body.us

for.body.us:                                      ; preds = %for.inc.us, %for.body.lr.ph.split.us.split
  %13 = phi i8 [ %0, %for.body.lr.ph.split.us.split ], [ %15, %for.inc.us ]
  %idxprom104.us = phi i64 [ 0, %for.body.lr.ph.split.us.split ], [ %idxprom.us, %for.inc.us ]
  %len.0103.us = phi i32 [ 0, %for.body.lr.ph.split.us.split ], [ %inc.us, %for.inc.us ]
  %isXML.0101.us = phi i8 [ 1, %for.body.lr.ph.split.us.split ], [ %isXML.1.us, %for.inc.us ]
  %tobool52.not.us = icmp eq i8 %isXML.0101.us, 0
  br i1 %tobool52.not.us, label %if.end65.us, label %land.lhs.true53.us

land.lhs.true53.us:                               ; preds = %for.body.us
  %cmp54.us = icmp sgt i32 %len.0103.us, 36
  br i1 %cmp54.us, label %if.then64.us, label %lor.lhs.false.us

lor.lhs.false.us:                                 ; preds = %land.lhs.true53.us
  %arrayidx60.us = getelementptr [37 x i8], ptr @addBinding.xmlNamespace, i64 0, i64 %idxprom104.us
  %14 = load i8, ptr %arrayidx60.us, align 1
  %cmp62.not.us = icmp eq i8 %13, %14
  br i1 %cmp62.not.us, label %if.end65.us, label %if.then64.us

if.then64.us:                                     ; preds = %lor.lhs.false.us, %land.lhs.true53.us
  br label %if.end65.us

if.end65.us:                                      ; preds = %if.then64.us, %lor.lhs.false.us, %for.body.us
  %isXML.1.us = phi i8 [ 0, %if.then64.us ], [ %isXML.0101.us, %lor.lhs.false.us ], [ 0, %for.body.us ]
  %cmp91.us = icmp eq i8 %13, %12
  br i1 %cmp91.us, label %land.lhs.true93.us, label %for.inc.us

land.lhs.true93.us:                               ; preds = %if.end65.us
  switch i32 %conv.i.us, label %return [
    i32 65, label %for.inc.us
    i32 66, label %for.inc.us
    i32 67, label %for.inc.us
    i32 68, label %for.inc.us
    i32 69, label %for.inc.us
    i32 70, label %for.inc.us
    i32 71, label %for.inc.us
    i32 72, label %for.inc.us
    i32 73, label %for.inc.us
    i32 74, label %for.inc.us
    i32 75, label %for.inc.us
    i32 76, label %for.inc.us
    i32 77, label %for.inc.us
    i32 78, label %for.inc.us
    i32 79, label %for.inc.us
    i32 80, label %for.inc.us
    i32 81, label %for.inc.us
    i32 82, label %for.inc.us
    i32 83, label %for.inc.us
    i32 84, label %for.inc.us
    i32 85, label %for.inc.us
    i32 86, label %for.inc.us
    i32 87, label %for.inc.us
    i32 88, label %for.inc.us
    i32 89, label %for.inc.us
    i32 90, label %for.inc.us
    i32 97, label %for.inc.us
    i32 98, label %for.inc.us
    i32 99, label %for.inc.us
    i32 100, label %for.inc.us
    i32 101, label %for.inc.us
    i32 102, label %for.inc.us
    i32 103, label %for.inc.us
    i32 104, label %for.inc.us
    i32 105, label %for.inc.us
    i32 106, label %for.inc.us
    i32 107, label %for.inc.us
    i32 108, label %for.inc.us
    i32 109, label %for.inc.us
    i32 110, label %for.inc.us
    i32 111, label %for.inc.us
    i32 112, label %for.inc.us
    i32 113, label %for.inc.us
    i32 114, label %for.inc.us
    i32 115, label %for.inc.us
    i32 116, label %for.inc.us
    i32 117, label %for.inc.us
    i32 118, label %for.inc.us
    i32 119, label %for.inc.us
    i32 120, label %for.inc.us
    i32 121, label %for.inc.us
    i32 122, label %for.inc.us
    i32 48, label %for.inc.us
    i32 49, label %for.inc.us
    i32 50, label %for.inc.us
    i32 51, label %for.inc.us
    i32 52, label %for.inc.us
    i32 53, label %for.inc.us
    i32 54, label %for.inc.us
    i32 55, label %for.inc.us
    i32 56, label %for.inc.us
    i32 57, label %for.inc.us
    i32 37, label %for.inc.us
    i32 45, label %for.inc.us
    i32 46, label %for.inc.us
    i32 95, label %for.inc.us
    i32 126, label %for.inc.us
    i32 58, label %for.inc.us
    i32 47, label %for.inc.us
    i32 63, label %for.inc.us
    i32 35, label %for.inc.us
    i32 91, label %for.inc.us
    i32 93, label %for.inc.us
    i32 64, label %for.inc.us
    i32 33, label %for.inc.us
    i32 36, label %for.inc.us
    i32 38, label %for.inc.us
    i32 39, label %for.inc.us
    i32 40, label %for.inc.us
    i32 41, label %for.inc.us
    i32 42, label %for.inc.us
    i32 43, label %for.inc.us
    i32 44, label %for.inc.us
    i32 59, label %for.inc.us
    i32 61, label %for.inc.us
  ]

for.inc.us:                                       ; preds = %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %land.lhs.true93.us, %if.end65.us
  %inc.us = add i32 %len.0103.us, 1
  %idxprom.us = sext i32 %inc.us to i64
  %arrayidx49.us = getelementptr i8, ptr %uri, i64 %idxprom.us
  %15 = load i8, ptr %arrayidx49.us, align 1
  %tobool50.not.us = icmp eq i8 %15, 0
  br i1 %tobool50.not.us, label %for.end, label %for.body.us, !llvm.loop !84

for.body.lr.ph.split:                             ; preds = %if.then21, %land.lhs.true27, %land.lhs.true33, %if.end, %land.lhs.true4, %land.lhs.true9, %land.lhs.true15
  %m_ns157 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 38
  %16 = load i8, ptr %m_ns157, align 8
  %tobool85.not158 = icmp eq i8 %16, 0
  br i1 %tobool85.not158, label %for.body.us109, label %for.body.lr.ph.split.split

for.body.us109:                                   ; preds = %for.body.lr.ph.split, %if.end83.us123
  %17 = phi i8 [ %20, %if.end83.us123 ], [ %0, %for.body.lr.ph.split ]
  %idxprom104.us110 = phi i64 [ %idxprom.us127, %if.end83.us123 ], [ 0, %for.body.lr.ph.split ]
  %len.0103.us111 = phi i32 [ %inc.us126, %if.end83.us123 ], [ 0, %for.body.lr.ph.split ]
  %isXMLNS.0102.us112 = phi i8 [ %isXMLNS.1.us124, %if.end83.us123 ], [ 1, %for.body.lr.ph.split ]
  %isXML.0101.us113 = phi i8 [ %isXML.1.us122, %if.end83.us123 ], [ 1, %for.body.lr.ph.split ]
  %tobool52.not.us114 = icmp eq i8 %isXML.0101.us113, 0
  br i1 %tobool52.not.us114, label %if.end65.us121, label %land.lhs.true53.us115

land.lhs.true53.us115:                            ; preds = %for.body.us109
  %cmp54.us116 = icmp sgt i32 %len.0103.us111, 36
  br i1 %cmp54.us116, label %if.then64.us120, label %lor.lhs.false.us117

lor.lhs.false.us117:                              ; preds = %land.lhs.true53.us115
  %arrayidx60.us118 = getelementptr [37 x i8], ptr @addBinding.xmlNamespace, i64 0, i64 %idxprom104.us110
  %18 = load i8, ptr %arrayidx60.us118, align 1
  %cmp62.not.us119 = icmp eq i8 %17, %18
  br i1 %cmp62.not.us119, label %if.end65.us121, label %if.then64.us120

if.then64.us120:                                  ; preds = %lor.lhs.false.us117, %land.lhs.true53.us115
  br label %if.end65.us121

if.end65.us121:                                   ; preds = %if.then64.us120, %lor.lhs.false.us117, %for.body.us109
  %isXML.1.us122 = phi i8 [ 0, %if.then64.us120 ], [ %isXML.0101.us113, %lor.lhs.false.us117 ], [ 0, %for.body.us109 ]
  %tobool69.us.not = icmp eq i8 %isXMLNS.0102.us112, 0
  br i1 %tobool69.us.not, label %if.end83.us123, label %land.lhs.true70.us

land.lhs.true70.us:                               ; preds = %if.end65.us121
  %cmp71.us = icmp sgt i32 %len.0103.us111, 29
  br i1 %cmp71.us, label %if.then82.us, label %lor.lhs.false73.us

lor.lhs.false73.us:                               ; preds = %land.lhs.true70.us
  %arrayidx78.us = getelementptr [30 x i8], ptr @addBinding.xmlnsNamespace, i64 0, i64 %idxprom104.us110
  %19 = load i8, ptr %arrayidx78.us, align 1
  %cmp80.not.us = icmp eq i8 %17, %19
  br i1 %cmp80.not.us, label %if.end83.us123, label %if.then82.us

if.then82.us:                                     ; preds = %lor.lhs.false73.us, %land.lhs.true70.us
  br label %if.end83.us123

if.end83.us123:                                   ; preds = %if.then82.us, %lor.lhs.false73.us, %if.end65.us121
  %isXMLNS.1.us124 = phi i8 [ 0, %if.then82.us ], [ %isXMLNS.0102.us112, %lor.lhs.false73.us ], [ 0, %if.end65.us121 ]
  %inc.us126 = add i32 %len.0103.us111, 1
  %idxprom.us127 = sext i32 %inc.us126 to i64
  %arrayidx49.us128 = getelementptr i8, ptr %uri, i64 %idxprom.us127
  %20 = load i8, ptr %arrayidx49.us128, align 1
  %tobool50.not.us129 = icmp eq i8 %20, 0
  br i1 %tobool50.not.us129, label %for.end, label %for.body.us109, !llvm.loop !84

for.body.lr.ph.split.split:                       ; preds = %for.body.lr.ph.split
  %m_namespaceSeparator159 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 83
  %21 = load i8, ptr %m_namespaceSeparator159, align 4
  %conv.i = sext i8 %21 to i32
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph.split.split, %for.inc
  %22 = phi i8 [ %0, %for.body.lr.ph.split.split ], [ %25, %for.inc ]
  %idxprom104 = phi i64 [ 0, %for.body.lr.ph.split.split ], [ %idxprom, %for.inc ]
  %len.0103 = phi i32 [ 0, %for.body.lr.ph.split.split ], [ %inc, %for.inc ]
  %isXMLNS.0102 = phi i8 [ 1, %for.body.lr.ph.split.split ], [ %isXMLNS.1, %for.inc ]
  %isXML.0101 = phi i8 [ 1, %for.body.lr.ph.split.split ], [ %isXML.1, %for.inc ]
  %tobool52.not = icmp eq i8 %isXML.0101, 0
  br i1 %tobool52.not, label %if.end65, label %land.lhs.true53

land.lhs.true53:                                  ; preds = %for.body
  %cmp54 = icmp sgt i32 %len.0103, 36
  br i1 %cmp54, label %if.then64, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true53
  %arrayidx60 = getelementptr [37 x i8], ptr @addBinding.xmlNamespace, i64 0, i64 %idxprom104
  %23 = load i8, ptr %arrayidx60, align 1
  %cmp62.not = icmp eq i8 %22, %23
  br i1 %cmp62.not, label %if.end65, label %if.then64

if.then64:                                        ; preds = %lor.lhs.false, %land.lhs.true53
  br label %if.end65

if.end65:                                         ; preds = %if.then64, %lor.lhs.false, %for.body
  %isXML.1 = phi i8 [ 0, %if.then64 ], [ %isXML.0101, %lor.lhs.false ], [ 0, %for.body ]
  %tobool69.not = icmp eq i8 %isXMLNS.0102, 0
  br i1 %tobool69.not, label %if.end83, label %land.lhs.true70

land.lhs.true70:                                  ; preds = %if.end65
  %cmp71 = icmp sgt i32 %len.0103, 29
  br i1 %cmp71, label %if.then82, label %lor.lhs.false73

lor.lhs.false73:                                  ; preds = %land.lhs.true70
  %arrayidx78 = getelementptr [30 x i8], ptr @addBinding.xmlnsNamespace, i64 0, i64 %idxprom104
  %24 = load i8, ptr %arrayidx78, align 1
  %cmp80.not = icmp eq i8 %22, %24
  br i1 %cmp80.not, label %if.end83, label %if.then82

if.then82:                                        ; preds = %lor.lhs.false73, %land.lhs.true70
  br label %if.end83

if.end83:                                         ; preds = %if.then82, %lor.lhs.false73, %if.end65
  %isXMLNS.1 = phi i8 [ 0, %if.then82 ], [ %isXMLNS.0102, %lor.lhs.false73 ], [ 0, %if.end65 ]
  %cmp91 = icmp eq i8 %22, %21
  br i1 %cmp91, label %land.lhs.true93, label %for.inc

land.lhs.true93:                                  ; preds = %if.end83
  switch i32 %conv.i, label %return [
    i32 65, label %for.inc
    i32 66, label %for.inc
    i32 67, label %for.inc
    i32 68, label %for.inc
    i32 69, label %for.inc
    i32 70, label %for.inc
    i32 71, label %for.inc
    i32 72, label %for.inc
    i32 73, label %for.inc
    i32 74, label %for.inc
    i32 75, label %for.inc
    i32 76, label %for.inc
    i32 77, label %for.inc
    i32 78, label %for.inc
    i32 79, label %for.inc
    i32 80, label %for.inc
    i32 81, label %for.inc
    i32 82, label %for.inc
    i32 83, label %for.inc
    i32 84, label %for.inc
    i32 85, label %for.inc
    i32 86, label %for.inc
    i32 87, label %for.inc
    i32 88, label %for.inc
    i32 89, label %for.inc
    i32 90, label %for.inc
    i32 97, label %for.inc
    i32 98, label %for.inc
    i32 99, label %for.inc
    i32 100, label %for.inc
    i32 101, label %for.inc
    i32 102, label %for.inc
    i32 103, label %for.inc
    i32 104, label %for.inc
    i32 105, label %for.inc
    i32 106, label %for.inc
    i32 107, label %for.inc
    i32 108, label %for.inc
    i32 109, label %for.inc
    i32 110, label %for.inc
    i32 111, label %for.inc
    i32 112, label %for.inc
    i32 113, label %for.inc
    i32 114, label %for.inc
    i32 115, label %for.inc
    i32 116, label %for.inc
    i32 117, label %for.inc
    i32 118, label %for.inc
    i32 119, label %for.inc
    i32 120, label %for.inc
    i32 121, label %for.inc
    i32 122, label %for.inc
    i32 48, label %for.inc
    i32 49, label %for.inc
    i32 50, label %for.inc
    i32 51, label %for.inc
    i32 52, label %for.inc
    i32 53, label %for.inc
    i32 54, label %for.inc
    i32 55, label %for.inc
    i32 56, label %for.inc
    i32 57, label %for.inc
    i32 37, label %for.inc
    i32 45, label %for.inc
    i32 46, label %for.inc
    i32 95, label %for.inc
    i32 126, label %for.inc
    i32 58, label %for.inc
    i32 47, label %for.inc
    i32 63, label %for.inc
    i32 35, label %for.inc
    i32 91, label %for.inc
    i32 93, label %for.inc
    i32 64, label %for.inc
    i32 33, label %for.inc
    i32 36, label %for.inc
    i32 38, label %for.inc
    i32 39, label %for.inc
    i32 40, label %for.inc
    i32 41, label %for.inc
    i32 42, label %for.inc
    i32 43, label %for.inc
    i32 44, label %for.inc
    i32 59, label %for.inc
    i32 61, label %for.inc
  ]

for.inc:                                          ; preds = %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %land.lhs.true93, %if.end83
  %inc = add i32 %len.0103, 1
  %idxprom = sext i32 %inc to i64
  %arrayidx49 = getelementptr i8, ptr %uri, i64 %idxprom
  %25 = load i8, ptr %arrayidx49, align 1
  %tobool50.not = icmp eq i8 %25, 0
  br i1 %tobool50.not, label %for.end, label %for.body, !llvm.loop !84

for.end:                                          ; preds = %for.inc.us, %if.end65.us.us, %for.inc, %if.end83.us123, %land.lhs.true
  %mustBeXML.0153 = phi i8 [ 0, %land.lhs.true ], [ 0, %if.end83.us123 ], [ 0, %for.inc ], [ 1, %if.end65.us.us ], [ 1, %for.inc.us ]
  %tobool118.not150 = phi i32 [ 40, %land.lhs.true ], [ 40, %if.end83.us123 ], [ 40, %for.inc ], [ 38, %if.end65.us.us ], [ 38, %for.inc.us ]
  %isXML.0.lcssa = phi i8 [ 1, %land.lhs.true ], [ %isXML.1.us122, %if.end83.us123 ], [ %isXML.1, %for.inc ], [ %isXML.1.us.us, %if.end65.us.us ], [ %isXML.1.us, %for.inc.us ]
  %isXMLNS.0.lcssa = phi i8 [ 1, %land.lhs.true ], [ %isXMLNS.1.us124, %if.end83.us123 ], [ %isXMLNS.1, %for.inc ], [ 1, %if.end65.us.us ], [ 1, %for.inc.us ]
  %len.0.lcssa = phi i32 [ 0, %land.lhs.true ], [ %inc.us126, %if.end83.us123 ], [ %inc, %for.inc ], [ %inc.us.us, %if.end65.us.us ], [ %inc.us, %for.inc.us ]
  %tobool100 = icmp ne i8 %isXML.0.lcssa, 0
  %cmp101 = icmp eq i32 %len.0.lcssa, 36
  %26 = and i1 %tobool100, %cmp101
  %27 = zext i1 %26 to i8
  %cmp114.not = icmp eq i8 %mustBeXML.0153, %27
  br i1 %cmp114.not, label %if.end119, label %return

if.end119:                                        ; preds = %for.end
  %tobool105 = icmp ne i8 %isXMLNS.0.lcssa, 0
  %cmp107 = icmp eq i32 %len.0.lcssa, 29
  %28 = and i1 %tobool105, %cmp107
  br i1 %28, label %return, label %if.end122

if.end122:                                        ; preds = %if.end119
  %m_namespaceSeparator123 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 83
  %29 = load i8, ptr %m_namespaceSeparator123, align 4
  %tobool124.not = icmp ne i8 %29, 0
  %inc126 = zext i1 %tobool124.not to i32
  %spec.select = add i32 %len.0.lcssa, %inc126
  %m_freeBindingList = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 70
  %30 = load ptr, ptr %m_freeBindingList, align 8
  %tobool128.not = icmp eq ptr %30, null
  br i1 %tobool128.not, label %if.else, label %if.then129

if.then129:                                       ; preds = %if.end122
  %uriAlloc = getelementptr inbounds %struct.binding, ptr %30, i64 0, i32 6
  %31 = load i32, ptr %uriAlloc, align 4
  %cmp131 = icmp sgt i32 %spec.select, %31
  br i1 %cmp131, label %if.then133, label %if.end148

if.then133:                                       ; preds = %if.then129
  %cmp134 = icmp sgt i32 %spec.select, 2147483623
  br i1 %cmp134, label %return, label %if.end137

if.end137:                                        ; preds = %if.then133
  %realloc_fcn = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 3, i32 1
  %32 = load ptr, ptr %realloc_fcn, align 8
  %uri138 = getelementptr inbounds %struct.binding, ptr %30, i64 0, i32 4
  %33 = load ptr, ptr %uri138, align 8
  %add = add nsw i32 %spec.select, 24
  %conv139 = sext i32 %add to i64
  %call140 = tail call ptr %32(ptr noundef %33, i64 noundef %conv139) #24
  %cmp141 = icmp eq ptr %call140, null
  br i1 %cmp141, label %return, label %if.end144

if.end144:                                        ; preds = %if.end137
  store ptr %call140, ptr %uri138, align 8
  store i32 %add, ptr %uriAlloc, align 4
  br label %if.end148

if.end148:                                        ; preds = %if.end144, %if.then129
  %nextTagBinding = getelementptr inbounds %struct.binding, ptr %30, i64 0, i32 1
  %34 = load ptr, ptr %nextTagBinding, align 8
  store ptr %34, ptr %m_freeBindingList, align 8
  %uri174.phi.trans.insert = getelementptr inbounds %struct.binding, ptr %30, i64 0, i32 4
  %.pre = load ptr, ptr %uri174.phi.trans.insert, align 8
  br label %if.end173

if.else:                                          ; preds = %if.end122
  %m_mem150 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 3
  %35 = load ptr, ptr %m_mem150, align 8
  %call151 = tail call ptr %35(i64 noundef 48) #24
  %tobool152.not = icmp eq ptr %call151, null
  %cmp155 = icmp sgt i32 %spec.select, 2147483623
  %or.cond92 = select i1 %tobool152.not, i1 true, i1 %cmp155
  br i1 %or.cond92, label %return, label %if.end158

if.end158:                                        ; preds = %if.else
  %36 = load ptr, ptr %m_mem150, align 8
  %add161 = add nsw i32 %spec.select, 24
  %conv162 = sext i32 %add161 to i64
  %call164 = tail call ptr %36(i64 noundef %conv162) #24
  %uri165 = getelementptr inbounds %struct.binding, ptr %call151, i64 0, i32 4
  store ptr %call164, ptr %uri165, align 8
  %tobool167.not = icmp eq ptr %call164, null
  br i1 %tobool167.not, label %if.then168, label %if.end170

if.then168:                                       ; preds = %if.end158
  %free_fcn = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 3, i32 2
  %37 = load ptr, ptr %free_fcn, align 8
  tail call void %37(ptr noundef nonnull %call151) #24
  br label %return

if.end170:                                        ; preds = %if.end158
  %uriAlloc172 = getelementptr inbounds %struct.binding, ptr %call151, i64 0, i32 6
  store i32 %add161, ptr %uriAlloc172, align 4
  br label %if.end173

if.end173:                                        ; preds = %if.end170, %if.end148
  %38 = phi ptr [ %.pre, %if.end148 ], [ %call164, %if.end170 ]
  %b.0 = phi ptr [ %30, %if.end148 ], [ %call151, %if.end170 ]
  %uriLen = getelementptr inbounds %struct.binding, ptr %b.0, i64 0, i32 5
  store i32 %spec.select, ptr %uriLen, align 8
  %conv175 = sext i32 %spec.select to i64
  tail call void @llvm.memcpy.p0.p0.i64(ptr align 1 %38, ptr nonnull align 1 %uri, i64 %conv175, i1 false)
  %39 = load i8, ptr %m_namespaceSeparator123, align 4
  %tobool178.not = icmp eq i8 %39, 0
  br i1 %tobool178.not, label %if.end184, label %if.then179

if.then179:                                       ; preds = %if.end173
  %uri174 = getelementptr inbounds %struct.binding, ptr %b.0, i64 0, i32 4
  %40 = load ptr, ptr %uri174, align 8
  %sub = add i32 %spec.select, -1
  %idxprom182 = sext i32 %sub to i64
  %arrayidx183 = getelementptr i8, ptr %40, i64 %idxprom182
  store i8 %39, ptr %arrayidx183, align 1
  br label %if.end184

if.end184:                                        ; preds = %if.then179, %if.end173
  store ptr %prefix, ptr %b.0, align 8
  %attId186 = getelementptr inbounds %struct.binding, ptr %b.0, i64 0, i32 3
  store ptr %attId, ptr %attId186, align 8
  %binding = getelementptr inbounds %struct.prefix, ptr %prefix, i64 0, i32 1
  %41 = load ptr, ptr %binding, align 8
  %prevPrefixBinding = getelementptr inbounds %struct.binding, ptr %b.0, i64 0, i32 2
  store ptr %41, ptr %prevPrefixBinding, align 8
  %42 = load i8, ptr %uri, align 1
  %cmp188 = icmp eq i8 %42, 0
  br i1 %cmp188, label %land.lhs.true190, label %if.else195

land.lhs.true190:                                 ; preds = %if.end184
  %m_dtd = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 65
  %43 = load ptr, ptr %m_dtd, align 8
  %defaultPrefix = getelementptr inbounds %struct.DTD, ptr %43, i64 0, i32 11
  %cmp191 = icmp eq ptr %defaultPrefix, %prefix
  br i1 %cmp191, label %if.end197, label %if.else195

if.else195:                                       ; preds = %land.lhs.true190, %if.end184
  br label %if.end197

if.end197:                                        ; preds = %land.lhs.true190, %if.else195
  %storemerge = phi ptr [ %b.0, %if.else195 ], [ null, %land.lhs.true190 ]
  store ptr %storemerge, ptr %binding, align 8
  %44 = load ptr, ptr %bindingsPtr, align 8
  %nextTagBinding198 = getelementptr inbounds %struct.binding, ptr %b.0, i64 0, i32 1
  store ptr %44, ptr %nextTagBinding198, align 8
  store ptr %b.0, ptr %bindingsPtr, align 8
  %tobool199.not = icmp eq ptr %attId, null
  br i1 %tobool199.not, label %return, label %land.lhs.true200

land.lhs.true200:                                 ; preds = %if.end197
  %m_startNamespaceDeclHandler = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 23
  %45 = load ptr, ptr %m_startNamespaceDeclHandler, align 8
  %tobool201.not = icmp eq ptr %45, null
  br i1 %tobool201.not, label %return, label %if.then202

if.then202:                                       ; preds = %land.lhs.true200
  %m_handlerArg = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 1
  %46 = load ptr, ptr %m_handlerArg, align 8
  %47 = load ptr, ptr %prefix, align 8
  %48 = load ptr, ptr %binding, align 8
  %tobool206.not = icmp eq ptr %48, null
  %cond207 = select i1 %tobool206.not, ptr null, ptr %uri
  tail call void %45(ptr noundef %46, ptr noundef %47, ptr noundef %cond207) #24
  br label %return

return:                                           ; preds = %land.lhs.true93.us, %land.lhs.true93, %if.end197, %land.lhs.true200, %if.then202, %if.else, %if.end137, %if.then133, %if.end119, %for.end, %land.lhs.true33, %land.lhs.true, %if.then168
  %retval.0 = phi i32 [ 1, %if.then168 ], [ 28, %land.lhs.true ], [ 39, %land.lhs.true33 ], [ %tobool118.not150, %for.end ], [ 40, %if.end119 ], [ 1, %if.then133 ], [ 1, %if.end137 ], [ 1, %if.else ], [ 0, %if.then202 ], [ 0, %land.lhs.true200 ], [ 0, %if.end197 ], [ 2, %land.lhs.true93 ], [ 2, %land.lhs.true93.us ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @externalEntityContentProcessor(ptr noundef %parser, ptr noundef %start, ptr noundef %end, ptr nocapture noundef writeonly %endPtr) #0 {
entry:
  %m_encoding = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 34
  %0 = load ptr, ptr %m_encoding, align 8
  %finalBuffer = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 85, i32 1
  %1 = load i8, ptr %finalBuffer, align 4
  %tobool.not = icmp eq i8 %1, 0
  %conv = zext i1 %tobool.not to i8
  %call = tail call fastcc i32 @doContent(ptr noundef %parser, i32 noundef 1, ptr noundef %0, ptr noundef %start, ptr noundef %end, ptr noundef %endPtr, i8 noundef zeroext %conv, i32 noundef 1)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.then, label %return

if.then:                                          ; preds = %entry
  %m_tagStack.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 67
  %realloc_fcn.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 3, i32 1
  %tag.035.i = load ptr, ptr %m_tagStack.i, align 8
  %tobool.not36.i = icmp eq ptr %tag.035.i, null
  br i1 %tobool.not36.i, label %return, label %while.body.i

while.body.i:                                     ; preds = %if.then, %if.end50.i
  %tag.037.i = phi ptr [ %tag.0.i, %if.end50.i ], [ %tag.035.i, %if.then ]
  %name.i = getelementptr inbounds %struct.tag, ptr %tag.037.i, i64 0, i32 3
  %strLen.i = getelementptr inbounds %struct.tag, ptr %tag.037.i, i64 0, i32 3, i32 3
  %2 = load i32, ptr %strLen.i, align 8
  %add.i = add i32 %2, 1
  %conv.i = sext i32 %add.i to i64
  %buf.i = getelementptr inbounds %struct.tag, ptr %tag.037.i, i64 0, i32 4
  %3 = load ptr, ptr %buf.i, align 8
  %add.ptr.i = getelementptr i8, ptr %3, i64 %conv.i
  %rawName.i = getelementptr inbounds %struct.tag, ptr %tag.037.i, i64 0, i32 1
  %4 = load ptr, ptr %rawName.i, align 8
  %cmp.i = icmp eq ptr %4, %add.ptr.i
  br i1 %cmp.i, label %return, label %if.end.i

if.end.i:                                         ; preds = %while.body.i
  %rawNameLength.i = getelementptr inbounds %struct.tag, ptr %tag.037.i, i64 0, i32 2
  %5 = load i32, ptr %rawNameLength.i, align 8
  %conv3.i = sext i32 %5 to i64
  %sub.i = sub nsw i64 2147483647, %conv.i
  %cmp6.i = icmp ult i64 %sub.i, %conv3.i
  br i1 %cmp6.i, label %return, label %if.end9.i

if.end9.i:                                        ; preds = %if.end.i
  %add11.i = add i32 %5, %add.i
  %conv12.i = sext i32 %add11.i to i64
  %bufEnd.i = getelementptr inbounds %struct.tag, ptr %tag.037.i, i64 0, i32 5
  %6 = load ptr, ptr %bufEnd.i, align 8
  %sub.ptr.lhs.cast.i = ptrtoint ptr %6 to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %3 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %cmp14.i = icmp slt i64 %sub.ptr.sub.i, %conv12.i
  br i1 %cmp14.i, label %if.then16.i, label %if.end50.i

if.then16.i:                                      ; preds = %if.end9.i
  %7 = load ptr, ptr %realloc_fcn.i, align 8
  %call.i = tail call ptr %7(ptr noundef %3, i64 noundef %conv12.i) #24
  %cmp19.i = icmp eq ptr %call.i, null
  br i1 %cmp19.i, label %return, label %if.end22.i

if.end22.i:                                       ; preds = %if.then16.i
  %8 = load ptr, ptr %name.i, align 8
  %9 = load ptr, ptr %buf.i, align 8
  %cmp25.i = icmp eq ptr %8, %9
  br i1 %cmp25.i, label %if.then27.i, label %if.end30.i

if.then27.i:                                      ; preds = %if.end22.i
  store ptr %call.i, ptr %name.i, align 8
  br label %if.end30.i

if.end30.i:                                       ; preds = %if.then27.i, %if.end22.i
  %localPart.i = getelementptr inbounds %struct.tag, ptr %tag.037.i, i64 0, i32 3, i32 1
  %10 = load ptr, ptr %localPart.i, align 8
  %tobool32.not.i = icmp eq ptr %10, null
  br i1 %tobool32.not.i, label %if.end43.i, label %if.then33.i

if.then33.i:                                      ; preds = %if.end30.i
  %sub.ptr.lhs.cast37.i = ptrtoint ptr %10 to i64
  %sub.ptr.rhs.cast38.i = ptrtoint ptr %9 to i64
  %sub.ptr.sub39.i = sub i64 %sub.ptr.lhs.cast37.i, %sub.ptr.rhs.cast38.i
  %add.ptr40.i = getelementptr i8, ptr %call.i, i64 %sub.ptr.sub39.i
  store ptr %add.ptr40.i, ptr %localPart.i, align 8
  br label %if.end43.i

if.end43.i:                                       ; preds = %if.then33.i, %if.end30.i
  store ptr %call.i, ptr %buf.i, align 8
  %add.ptr46.i = getelementptr i8, ptr %call.i, i64 %conv12.i
  store ptr %add.ptr46.i, ptr %bufEnd.i, align 8
  %add.ptr49.i = getelementptr i8, ptr %call.i, i64 %conv.i
  %.pre.i = load ptr, ptr %rawName.i, align 8
  %.pre41.i = load i32, ptr %rawNameLength.i, align 8
  %.pre42.i = sext i32 %.pre41.i to i64
  br label %if.end50.i

if.end50.i:                                       ; preds = %if.end43.i, %if.end9.i
  %conv53.pre-phi.i = phi i64 [ %.pre42.i, %if.end43.i ], [ %conv3.i, %if.end9.i ]
  %11 = phi ptr [ %.pre.i, %if.end43.i ], [ %4, %if.end9.i ]
  %rawNameBuf.0.i = phi ptr [ %add.ptr49.i, %if.end43.i ], [ %add.ptr.i, %if.end9.i ]
  tail call void @llvm.memcpy.p0.p0.i64(ptr align 1 %rawNameBuf.0.i, ptr align 1 %11, i64 %conv53.pre-phi.i, i1 false)
  store ptr %rawNameBuf.0.i, ptr %rawName.i, align 8
  %tag.0.i = load ptr, ptr %tag.037.i, align 8
  %tobool.not.i = icmp eq ptr %tag.0.i, null
  br i1 %tobool.not.i, label %return, label %while.body.i, !llvm.loop !46

return:                                           ; preds = %while.body.i, %if.end50.i, %if.then16.i, %if.end.i, %if.then, %entry
  %retval.0 = phi i32 [ %call, %entry ], [ 0, %if.then ], [ 0, %while.body.i ], [ 0, %if.end50.i ], [ 1, %if.then16.i ], [ 1, %if.end.i ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @appendAttributeValue(ptr noundef %parser, ptr noundef %enc, i8 noundef zeroext %isCdata, ptr noundef %ptr, ptr noundef %end, ptr noundef %pool, i32 noundef %account) unnamed_addr #0 {
entry:
  %ptr.addr.i.i = alloca ptr, align 8
  %ptr.addr.i = alloca ptr, align 8
  %next = alloca ptr, align 8
  %buf = alloca [4 x i8], align 1
  %ch = alloca i8, align 1
  %m_dtd = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 65
  %0 = load ptr, ptr %m_dtd, align 8
  %literalScanners = getelementptr inbounds %struct.encoding, ptr %enc, i64 0, i32 1
  %predefinedEntityName = getelementptr inbounds %struct.encoding, ptr %enc, i64 0, i32 7
  %minBytesPerChar85 = getelementptr inbounds %struct.encoding, ptr %enc, i64 0, i32 12
  %add.ptr95 = getelementptr inbounds i8, ptr %ch, i64 1
  %ptr97 = getelementptr inbounds %struct.STRING_POOL, ptr %pool, i64 0, i32 3
  %end98 = getelementptr inbounds %struct.STRING_POOL, ptr %pool, i64 0, i32 2
  %m_temp2Pool = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 80
  %ptr1.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 80, i32 3
  %utf8Convert.i.i = getelementptr inbounds %struct.encoding, ptr %enc, i64 0, i32 10
  %end4.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 80, i32 2
  %start.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 80, i32 4
  %size.i = getelementptr inbounds %struct.HASH_TABLE, ptr %0, i64 0, i32 2
  %power30.i = getelementptr inbounds %struct.HASH_TABLE, ptr %0, i64 0, i32 1
  %pool127 = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 4
  %cmp128 = icmp eq ptr %pool127, %pool
  %hasParamEntityRefs142 = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 7
  %standalone144 = getelementptr inbounds %struct.DTD, ptr %0, i64 0, i32 8
  %documentEntity = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 44, i32 4
  %m_openInternalEntities = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 50
  %m_internalEncoding = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 36
  %tobool54.not = icmp eq i8 %isCdata, 0
  %start57 = getelementptr inbounds %struct.STRING_POOL, ptr %pool, i64 0, i32 4
  %charRefNumber = getelementptr inbounds %struct.encoding, ptr %enc, i64 0, i32 6
  br label %for.cond

for.cond:                                         ; preds = %sw.epilog, %entry
  %ptr.addr.0 = phi ptr [ %ptr, %entry ], [ %99, %sw.epilog ]
  store ptr %ptr.addr.0, ptr %next, align 8
  %1 = load ptr, ptr %literalScanners, align 8
  %call = call i32 %1(ptr noundef %enc, ptr noundef %ptr.addr.0, ptr noundef %end, ptr noundef nonnull %next) #24
  %2 = load ptr, ptr %next, align 8
  %call1 = call fastcc zeroext i8 @accountingDiffTolerated(ptr noundef %parser, i32 noundef %call, ptr noundef %ptr.addr.0, ptr noundef %2, i32 noundef 5896, i32 noundef %account), !range !13
  %tobool.not = icmp eq i8 %call1, 0
  br i1 %tobool.not, label %while.cond.i.i.i, label %if.end

while.cond.i.i.i:                                 ; preds = %for.cond, %while.cond.i.i.i
  %rootParser.0.i.i.i = phi ptr [ %3, %while.cond.i.i.i ], [ %parser, %for.cond ]
  %m_parentParser.i.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i.i, i64 0, i32 84
  %3 = load ptr, ptr %m_parentParser.i.i.i, align 8
  %tobool.not.i.i.i = icmp eq ptr %3, null
  br i1 %tobool.not.i.i.i, label %getRootParserOf.exit.i.i, label %while.cond.i.i.i, !llvm.loop !31

getRootParserOf.exit.i.i:                         ; preds = %while.cond.i.i.i
  %debugLevel.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i.i, i64 0, i32 90, i32 2
  %4 = load i32, ptr %debugLevel.i.i, align 8
  %cmp.i.i = icmp slt i32 %4, 1
  br i1 %cmp.i.i, label %return, label %if.end.i.i

if.end.i.i:                                       ; preds = %getRootParserOf.exit.i.i
  %m_accounting.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i.i, i64 0, i32 90
  %5 = load i64, ptr %m_accounting.i.i, align 8
  %tobool.not.i5.i.i = icmp eq i64 %5, 0
  %countBytesIndirect.phi.trans.insert.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i.i, i64 0, i32 90, i32 1
  %.pre.i.i = load i64, ptr %countBytesIndirect.phi.trans.insert.i.i, align 8
  br i1 %tobool.not.i5.i.i, label %accountingGetCurrentAmplification.exit.i.i, label %cond.true.i.i.i

cond.true.i.i.i:                                  ; preds = %if.end.i.i
  %add.i.i.i = add i64 %.pre.i.i, %5
  %conv.i.i.i = uitofp i64 %add.i.i.i to float
  %conv6.i.i.i = uitofp i64 %5 to float
  %div.i.i.i = fdiv float %conv.i.i.i, %conv6.i.i.i
  %6 = fpext float %div.i.i.i to double
  br label %accountingGetCurrentAmplification.exit.i.i

accountingGetCurrentAmplification.exit.i.i:       ; preds = %cond.true.i.i.i, %if.end.i.i
  %cond.i.i.i = phi double [ %6, %cond.true.i.i.i ], [ 1.000000e+00, %if.end.i.i ]
  %7 = load ptr, ptr @stderr, align 8
  %call4.i.i = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %7, ptr noundef nonnull @.str.311, ptr noundef nonnull %rootParser.0.i.i.i, i64 noundef %5, i64 noundef %.pre.i.i, double noundef %cond.i.i.i, ptr noundef nonnull @.str.317) #27
  br label %return

if.end:                                           ; preds = %for.cond
  switch i32 %call, label %sw.default [
    i32 -4, label %return
    i32 0, label %sw.bb2
    i32 -1, label %sw.bb5
    i32 10, label %sw.bb11
    i32 6, label %sw.bb47
    i32 -3, label %sw.bb52
    i32 39, label %sw.bb53
    i32 7, label %sw.bb53
    i32 9, label %sw.bb84
  ]

sw.bb2:                                           ; preds = %if.end
  %m_encoding = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 34
  %8 = load ptr, ptr %m_encoding, align 8
  %cmp = icmp eq ptr %8, %enc
  br i1 %cmp, label %if.then3, label %return

if.then3:                                         ; preds = %sw.bb2
  %9 = load ptr, ptr %next, align 8
  %m_eventPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 47
  store ptr %9, ptr %m_eventPtr, align 8
  br label %return

sw.bb5:                                           ; preds = %if.end
  %m_encoding6 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 34
  %10 = load ptr, ptr %m_encoding6, align 8
  %cmp7 = icmp eq ptr %10, %enc
  br i1 %cmp7, label %if.then8, label %return

if.then8:                                         ; preds = %sw.bb5
  %m_eventPtr9 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 47
  store ptr %ptr.addr.0, ptr %m_eventPtr9, align 8
  br label %return

sw.bb11:                                          ; preds = %if.end
  %11 = load ptr, ptr %charRefNumber, align 8
  %call12 = call i32 %11(ptr noundef nonnull %enc, ptr noundef %ptr.addr.0) #24
  %cmp13 = icmp slt i32 %call12, 0
  br i1 %cmp13, label %if.then14, label %if.end20

if.then14:                                        ; preds = %sw.bb11
  %m_encoding15 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 34
  %12 = load ptr, ptr %m_encoding15, align 8
  %cmp16 = icmp eq ptr %12, %enc
  br i1 %cmp16, label %if.then17, label %return

if.then17:                                        ; preds = %if.then14
  %m_eventPtr18 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 47
  store ptr %ptr.addr.0, ptr %m_eventPtr18, align 8
  br label %return

if.end20:                                         ; preds = %sw.bb11
  %cmp22 = icmp eq i32 %call12, 32
  %or.cond = and i1 %tobool54.not, %cmp22
  br i1 %or.cond, label %land.lhs.true23, label %if.end31

land.lhs.true23:                                  ; preds = %if.end20
  %13 = load ptr, ptr %ptr97, align 8
  %14 = load ptr, ptr %start57, align 8
  %cmp25 = icmp eq ptr %13, %14
  br i1 %cmp25, label %sw.epilog, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true23
  %arrayidx27 = getelementptr i8, ptr %13, i64 -1
  %15 = load i8, ptr %arrayidx27, align 1
  %cmp28 = icmp eq i8 %15, 32
  br i1 %cmp28, label %sw.epilog, label %if.end31

if.end31:                                         ; preds = %lor.lhs.false, %if.end20
  %call32 = call i32 @PyExpat_XmlUtf8Encode(i32 noundef %call12, ptr noundef nonnull %buf) #24
  %cmp34161 = icmp sgt i32 %call32, 0
  br i1 %cmp34161, label %for.body.preheader, label %sw.epilog

for.body.preheader:                               ; preds = %if.end31
  %wide.trip.count = zext nneg i32 %call32 to i64
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %cond.false
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %cond.false ]
  %16 = load ptr, ptr %ptr97, align 8
  %17 = load ptr, ptr %end98, align 8
  %cmp38 = icmp eq ptr %16, %17
  br i1 %cmp38, label %land.lhs.true40, label %cond.false

land.lhs.true40:                                  ; preds = %for.body
  %call41 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool), !range !13
  %tobool42.not = icmp eq i8 %call41, 0
  br i1 %tobool42.not, label %return, label %land.lhs.true40.cond.false_crit_edge

land.lhs.true40.cond.false_crit_edge:             ; preds = %land.lhs.true40
  %.pre184 = load ptr, ptr %ptr97, align 8
  br label %cond.false

cond.false:                                       ; preds = %land.lhs.true40.cond.false_crit_edge, %for.body
  %18 = phi ptr [ %.pre184, %land.lhs.true40.cond.false_crit_edge ], [ %16, %for.body ]
  %arrayidx43 = getelementptr [4 x i8], ptr %buf, i64 0, i64 %indvars.iv
  %19 = load i8, ptr %arrayidx43, align 1
  %incdec.ptr = getelementptr i8, ptr %18, i64 1
  store ptr %incdec.ptr, ptr %ptr97, align 8
  store i8 %19, ptr %18, align 1
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %sw.epilog, label %for.body, !llvm.loop !85

sw.bb47:                                          ; preds = %if.end
  %20 = load ptr, ptr %next, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ptr.addr.i)
  store ptr %ptr.addr.0, ptr %ptr.addr.i, align 8
  %21 = load ptr, ptr %ptr97, align 8
  %tobool.not.i = icmp eq ptr %21, null
  br i1 %tobool.not.i, label %land.lhs.true.i, label %for.cond.i.preheader

land.lhs.true.i:                                  ; preds = %sw.bb47
  %call.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool), !range !13
  %tobool2.not.i = icmp eq i8 %call.i, 0
  br i1 %tobool2.not.i, label %poolAppend.exit.thread, label %for.cond.i.preheader

for.cond.i.preheader:                             ; preds = %land.lhs.true.i, %sw.bb47
  br label %for.cond.i

for.cond.i:                                       ; preds = %for.cond.i.preheader, %if.end8.i
  %22 = load ptr, ptr %utf8Convert.i.i, align 8
  %23 = load ptr, ptr %end98, align 8
  %call5.i = call i32 %22(ptr noundef nonnull %enc, ptr noundef nonnull %ptr.addr.i, ptr noundef %20, ptr noundef nonnull %ptr97, ptr noundef %23) #24
  %or.cond.i = icmp ult i32 %call5.i, 2
  br i1 %or.cond.i, label %poolAppend.exit, label %if.end8.i

if.end8.i:                                        ; preds = %for.cond.i
  %call9.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool), !range !13
  %tobool10.not.i = icmp eq i8 %call9.i, 0
  br i1 %tobool10.not.i, label %poolAppend.exit.thread, label %for.cond.i

poolAppend.exit.thread:                           ; preds = %land.lhs.true.i, %if.end8.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i)
  br label %return

poolAppend.exit:                                  ; preds = %for.cond.i
  %24 = load ptr, ptr %start57, align 8
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i)
  %tobool49.not = icmp eq ptr %24, null
  br i1 %tobool49.not, label %return, label %sw.epilog

sw.bb52:                                          ; preds = %if.end
  %25 = load i32, ptr %minBytesPerChar85, align 8
  %idx.ext = sext i32 %25 to i64
  %add.ptr = getelementptr i8, ptr %ptr.addr.0, i64 %idx.ext
  store ptr %add.ptr, ptr %next, align 8
  br label %sw.bb53

sw.bb53:                                          ; preds = %sw.bb52, %if.end, %if.end
  %.pre182 = load ptr, ptr %ptr97, align 8
  br i1 %tobool54.not, label %land.lhs.true55, label %if.end70

land.lhs.true55:                                  ; preds = %sw.bb53
  %26 = load ptr, ptr %start57, align 8
  %cmp61 = icmp eq ptr %.pre182, %26
  br i1 %cmp61, label %sw.epilog, label %lor.lhs.false63

lor.lhs.false63:                                  ; preds = %land.lhs.true55
  %arrayidx65 = getelementptr i8, ptr %.pre182, i64 -1
  %27 = load i8, ptr %arrayidx65, align 1
  %cmp67 = icmp eq i8 %27, 32
  br i1 %cmp67, label %sw.epilog, label %if.end70

if.end70:                                         ; preds = %lor.lhs.false63, %sw.bb53
  %28 = load ptr, ptr %end98, align 8
  %cmp73 = icmp eq ptr %.pre182, %28
  br i1 %cmp73, label %land.lhs.true75, label %cond.false79

land.lhs.true75:                                  ; preds = %if.end70
  %call76 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool), !range !13
  %tobool77.not = icmp eq i8 %call76, 0
  br i1 %tobool77.not, label %return, label %land.lhs.true75.cond.false79_crit_edge

land.lhs.true75.cond.false79_crit_edge:           ; preds = %land.lhs.true75
  %.pre183 = load ptr, ptr %ptr97, align 8
  br label %cond.false79

cond.false79:                                     ; preds = %land.lhs.true75.cond.false79_crit_edge, %if.end70
  %29 = phi ptr [ %.pre183, %land.lhs.true75.cond.false79_crit_edge ], [ %.pre182, %if.end70 ]
  %incdec.ptr81 = getelementptr i8, ptr %29, i64 1
  store ptr %incdec.ptr81, ptr %ptr97, align 8
  store i8 32, ptr %29, align 1
  br label %sw.epilog

sw.bb84:                                          ; preds = %if.end
  %30 = load ptr, ptr %predefinedEntityName, align 8
  %31 = load i32, ptr %minBytesPerChar85, align 8
  %idx.ext86 = sext i32 %31 to i64
  %add.ptr87 = getelementptr i8, ptr %ptr.addr.0, i64 %idx.ext86
  %32 = load ptr, ptr %next, align 8
  %idx.neg = sub nsw i64 0, %idx.ext86
  %add.ptr90 = getelementptr i8, ptr %32, i64 %idx.neg
  %call91 = call i32 %30(ptr noundef nonnull %enc, ptr noundef %add.ptr87, ptr noundef %add.ptr90) #24
  %conv92 = trunc i32 %call91 to i8
  store i8 %conv92, ptr %ch, align 1
  %tobool93.not = icmp eq i8 %conv92, 0
  br i1 %tobool93.not, label %if.end110, label %if.then94

if.then94:                                        ; preds = %sw.bb84
  %call96 = call fastcc zeroext i8 @accountingDiffTolerated(ptr noundef %parser, i32 noundef 9, ptr noundef nonnull %ch, ptr noundef nonnull %add.ptr95, i32 noundef 5965, i32 noundef 1), !range !13
  %33 = load ptr, ptr %ptr97, align 8
  %34 = load ptr, ptr %end98, align 8
  %cmp99 = icmp eq ptr %33, %34
  br i1 %cmp99, label %land.lhs.true101, label %cond.false105

land.lhs.true101:                                 ; preds = %if.then94
  %call102 = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %pool), !range !13
  %tobool103.not = icmp eq i8 %call102, 0
  br i1 %tobool103.not, label %return, label %land.lhs.true101.cond.false105_crit_edge

land.lhs.true101.cond.false105_crit_edge:         ; preds = %land.lhs.true101
  %.pre = load ptr, ptr %ptr97, align 8
  br label %cond.false105

cond.false105:                                    ; preds = %land.lhs.true101.cond.false105_crit_edge, %if.then94
  %35 = phi ptr [ %.pre, %land.lhs.true101.cond.false105_crit_edge ], [ %33, %if.then94 ]
  %36 = load i8, ptr %ch, align 1
  %incdec.ptr107 = getelementptr i8, ptr %35, i64 1
  store ptr %incdec.ptr107, ptr %ptr97, align 8
  store i8 %36, ptr %35, align 1
  br label %sw.epilog

if.end110:                                        ; preds = %sw.bb84
  %37 = load i32, ptr %minBytesPerChar85, align 8
  %idx.ext112 = sext i32 %37 to i64
  %add.ptr113 = getelementptr i8, ptr %ptr.addr.0, i64 %idx.ext112
  %38 = load ptr, ptr %next, align 8
  %idx.neg116 = sub nsw i64 0, %idx.ext112
  %add.ptr117 = getelementptr i8, ptr %38, i64 %idx.neg116
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ptr.addr.i.i)
  store ptr %add.ptr113, ptr %ptr.addr.i.i, align 8
  %39 = load ptr, ptr %ptr1.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %39, null
  br i1 %tobool.not.i.i, label %land.lhs.true.i.i, label %for.cond.i.i.preheader

land.lhs.true.i.i:                                ; preds = %if.end110
  %call.i.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_temp2Pool), !range !13
  %tobool2.not.i.i = icmp eq i8 %call.i.i, 0
  br i1 %tobool2.not.i.i, label %poolAppend.exit.thread.i, label %for.cond.i.i.preheader

for.cond.i.i.preheader:                           ; preds = %land.lhs.true.i.i, %if.end110
  br label %for.cond.i.i

for.cond.i.i:                                     ; preds = %for.cond.i.i.preheader, %if.end8.i.i
  %40 = load ptr, ptr %utf8Convert.i.i, align 8
  %41 = load ptr, ptr %end4.i.i, align 8
  %call5.i.i = call i32 %40(ptr noundef nonnull %enc, ptr noundef nonnull %ptr.addr.i.i, ptr noundef %add.ptr117, ptr noundef nonnull %ptr1.i.i, ptr noundef %41) #24
  %or.cond.i.i = icmp ult i32 %call5.i.i, 2
  br i1 %or.cond.i.i, label %poolAppend.exit.i, label %if.end8.i.i

if.end8.i.i:                                      ; preds = %for.cond.i.i
  %call9.i.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_temp2Pool), !range !13
  %tobool10.not.i.i = icmp eq i8 %call9.i.i, 0
  br i1 %tobool10.not.i.i, label %poolAppend.exit.thread.i, label %for.cond.i.i

poolAppend.exit.thread.i:                         ; preds = %land.lhs.true.i.i, %if.end8.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i)
  br label %return

poolAppend.exit.i:                                ; preds = %for.cond.i.i
  %42 = load ptr, ptr %start.i.i, align 8
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.addr.i.i)
  %tobool.not.i110 = icmp eq ptr %42, null
  br i1 %tobool.not.i110, label %return, label %if.end.i111

if.end.i111:                                      ; preds = %poolAppend.exit.i
  %43 = load ptr, ptr %ptr1.i.i, align 8
  %44 = load ptr, ptr %end4.i.i, align 8
  %cmp.i = icmp eq ptr %43, %44
  br i1 %cmp.i, label %land.lhs.true.i112, label %poolStoreString.exit

land.lhs.true.i112:                               ; preds = %if.end.i111
  %call3.i = call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %m_temp2Pool), !range !13
  %tobool4.not.i = icmp eq i8 %call3.i, 0
  br i1 %tobool4.not.i, label %return, label %land.lhs.true.if.end6_crit_edge.i

land.lhs.true.if.end6_crit_edge.i:                ; preds = %land.lhs.true.i112
  %.pre.i = load ptr, ptr %ptr1.i.i, align 8
  br label %poolStoreString.exit

poolStoreString.exit:                             ; preds = %if.end.i111, %land.lhs.true.if.end6_crit_edge.i
  %45 = phi ptr [ %.pre.i, %land.lhs.true.if.end6_crit_edge.i ], [ %43, %if.end.i111 ]
  %incdec.ptr.i = getelementptr i8, ptr %45, i64 1
  store ptr %incdec.ptr.i, ptr %ptr1.i.i, align 8
  store i8 0, ptr %45, align 1
  %46 = load ptr, ptr %start.i.i, align 8
  %tobool119.not = icmp eq ptr %46, null
  br i1 %tobool119.not, label %return, label %if.end121

if.end121:                                        ; preds = %poolStoreString.exit
  %47 = load i64, ptr %size.i, align 8
  %cmp.i113 = icmp eq i64 %47, 0
  br i1 %cmp.i113, label %lookup.exit, label %if.else.i

if.else.i:                                        ; preds = %if.end121
  %call12.i = call fastcc i64 @hash(ptr noundef nonnull %parser, ptr noundef nonnull %46)
  %48 = load i64, ptr %size.i, align 8
  %sub14.i = add i64 %48, -1
  %and15.i = and i64 %sub14.i, %call12.i
  %49 = load ptr, ptr %0, align 8
  %arrayidx111.i = getelementptr ptr, ptr %49, i64 %and15.i
  %50 = load ptr, ptr %arrayidx111.i, align 8
  %tobool17.not112.i = icmp eq ptr %50, null
  br i1 %tobool17.not112.i, label %lookup.exit, label %while.body.lr.ph.i

while.body.lr.ph.i:                               ; preds = %if.else.i
  %51 = load i8, ptr %46, align 1
  %not.i = sub i64 0, %48
  %and29.i = and i64 %call12.i, %not.i
  %shr32.i = lshr i64 %sub14.i, 2
  br label %while.body.i

while.body.i:                                     ; preds = %if.end35.i, %while.body.lr.ph.i
  %52 = phi ptr [ %50, %while.body.lr.ph.i ], [ %60, %if.end35.i ]
  %i.0114.i = phi i64 [ %and15.i, %while.body.lr.ph.i ], [ %i.1.i, %if.end35.i ]
  %step.0113.i = phi i8 [ 0, %while.body.lr.ph.i ], [ %step.1.i, %if.end35.i ]
  %53 = load ptr, ptr %52, align 8
  %54 = load i8, ptr %53, align 1
  %cmp5.i.i = icmp eq i8 %51, %54
  br i1 %cmp5.i.i, label %for.body.i.i, label %if.end26.i

for.body.i.i:                                     ; preds = %while.body.i, %for.inc.i.i
  %55 = phi i8 [ %56, %for.inc.i.i ], [ %51, %while.body.i ]
  %s2.addr.07.i.i = phi ptr [ %incdec.ptr6.i.i, %for.inc.i.i ], [ %53, %while.body.i ]
  %s1.addr.06.i.i = phi ptr [ %incdec.ptr.i.i, %for.inc.i.i ], [ %46, %while.body.i ]
  %cmp4.i.i = icmp eq i8 %55, 0
  br i1 %cmp4.i.i, label %lookup.exit, label %for.inc.i.i

for.inc.i.i:                                      ; preds = %for.body.i.i
  %incdec.ptr.i.i = getelementptr i8, ptr %s1.addr.06.i.i, i64 1
  %incdec.ptr6.i.i = getelementptr i8, ptr %s2.addr.07.i.i, i64 1
  %56 = load i8, ptr %incdec.ptr.i.i, align 1
  %57 = load i8, ptr %incdec.ptr6.i.i, align 1
  %cmp.i.i115 = icmp eq i8 %56, %57
  br i1 %cmp.i.i115, label %for.body.i.i, label %if.end26.i, !llvm.loop !14

if.end26.i:                                       ; preds = %for.inc.i.i, %while.body.i
  %tobool27.not.i = icmp eq i8 %step.0113.i, 0
  br i1 %tobool27.not.i, label %if.then28.i, label %if.end35.i

if.then28.i:                                      ; preds = %if.end26.i
  %58 = load i8, ptr %power30.i, align 8
  %conv.i = zext i8 %58 to i64
  %sub31.i = add nuw nsw i64 %conv.i, 4294967295
  %sh_prom.i = and i64 %sub31.i, 4294967295
  %shr.i = lshr i64 %and29.i, %sh_prom.i
  %and33.i = and i64 %shr.i, %shr32.i
  %59 = trunc i64 %and33.i to i8
  %conv34.i = or i8 %59, 1
  br label %if.end35.i

if.end35.i:                                       ; preds = %if.then28.i, %if.end26.i
  %step.1.i = phi i8 [ %step.0113.i, %if.end26.i ], [ %conv34.i, %if.then28.i ]
  %conv36.i = zext i8 %step.1.i to i64
  %cmp37.i = icmp ult i64 %i.0114.i, %conv36.i
  %i.1.p.v.i = select i1 %cmp37.i, i64 %48, i64 0
  %i.1.p.i = sub i64 %i.0114.i, %conv36.i
  %i.1.i = add i64 %i.1.p.v.i, %i.1.p.i
  %arrayidx.i = getelementptr ptr, ptr %49, i64 %i.1.i
  %60 = load ptr, ptr %arrayidx.i, align 8
  %tobool17.not.i = icmp eq ptr %60, null
  br i1 %tobool17.not.i, label %lookup.exit, label %while.body.i, !llvm.loop !15

lookup.exit:                                      ; preds = %if.end35.i, %for.body.i.i, %if.else.i, %if.end121
  %retval.0.i114 = phi ptr [ null, %if.end121 ], [ null, %if.else.i ], [ %52, %for.body.i.i ], [ null, %if.end35.i ]
  %61 = load ptr, ptr %start.i.i, align 8
  store ptr %61, ptr %ptr1.i.i, align 8
  br i1 %cmp128, label %if.then130, label %if.else

if.then130:                                       ; preds = %lookup.exit
  %62 = load i32, ptr %documentEntity, align 4
  %tobool131.not = icmp eq i32 %62, 0
  br i1 %tobool131.not, label %if.else158, label %land.rhs

land.rhs:                                         ; preds = %if.then130
  %63 = load i8, ptr %standalone144, align 2
  %tobool133.not = icmp eq i8 %63, 0
  br i1 %tobool133.not, label %cond.false136, label %cond.true134

cond.true134:                                     ; preds = %land.rhs
  %64 = load ptr, ptr %m_openInternalEntities, align 8
  %tobool135.not = icmp eq ptr %64, null
  br i1 %tobool135.not, label %if.then150, label %if.else158

cond.false136:                                    ; preds = %land.rhs
  %65 = load i8, ptr %hasParamEntityRefs142, align 1
  %tobool137.not = icmp eq i8 %65, 0
  br i1 %tobool137.not, label %if.then150, label %if.else158

if.else:                                          ; preds = %lookup.exit
  %66 = load i8, ptr %hasParamEntityRefs142, align 1
  %tobool143.not = icmp eq i8 %66, 0
  br i1 %tobool143.not, label %if.then150, label %if.end148

if.end148:                                        ; preds = %if.else
  %67 = load i8, ptr %standalone144, align 2
  %tobool146.not = icmp eq i8 %67, 0
  br i1 %tobool146.not, label %if.else158, label %if.then150

if.then150:                                       ; preds = %cond.false136, %cond.true134, %if.else, %if.end148
  %tobool151.not = icmp eq ptr %retval.0.i114, null
  br i1 %tobool151.not, label %return, label %if.else153

if.else153:                                       ; preds = %if.then150
  %is_internal = getelementptr inbounds %struct.ENTITY, ptr %retval.0.i114, i64 0, i32 10
  %68 = load i8, ptr %is_internal, align 2
  %tobool154.not = icmp eq i8 %68, 0
  br i1 %tobool154.not, label %return, label %if.end162

if.else158:                                       ; preds = %cond.false136, %cond.true134, %if.then130, %if.end148
  %tobool159.not = icmp eq ptr %retval.0.i114, null
  br i1 %tobool159.not, label %sw.epilog, label %if.end162

if.end162:                                        ; preds = %if.else158, %if.else153
  %open = getelementptr inbounds %struct.ENTITY, ptr %retval.0.i114, i64 0, i32 8
  %69 = load i8, ptr %open, align 8
  %tobool163.not = icmp eq i8 %69, 0
  br i1 %tobool163.not, label %if.end171, label %if.then164

if.then164:                                       ; preds = %if.end162
  %m_encoding165 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 34
  %70 = load ptr, ptr %m_encoding165, align 8
  %cmp166 = icmp eq ptr %70, %enc
  br i1 %cmp166, label %if.then168, label %return

if.then168:                                       ; preds = %if.then164
  %m_eventPtr169 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 47
  store ptr %ptr.addr.0, ptr %m_eventPtr169, align 8
  br label %return

if.end171:                                        ; preds = %if.end162
  %notation = getelementptr inbounds %struct.ENTITY, ptr %retval.0.i114, i64 0, i32 7
  %71 = load ptr, ptr %notation, align 8
  %tobool172.not = icmp eq ptr %71, null
  br i1 %tobool172.not, label %if.end180, label %if.then173

if.then173:                                       ; preds = %if.end171
  %m_encoding174 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 34
  %72 = load ptr, ptr %m_encoding174, align 8
  %cmp175 = icmp eq ptr %72, %enc
  br i1 %cmp175, label %if.then177, label %return

if.then177:                                       ; preds = %if.then173
  %m_eventPtr178 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 47
  store ptr %ptr.addr.0, ptr %m_eventPtr178, align 8
  br label %return

if.end180:                                        ; preds = %if.end171
  %textPtr = getelementptr inbounds %struct.ENTITY, ptr %retval.0.i114, i64 0, i32 1
  %73 = load ptr, ptr %textPtr, align 8
  %tobool181.not = icmp eq ptr %73, null
  br i1 %tobool181.not, label %if.then182, label %if.else189

if.then182:                                       ; preds = %if.end180
  %m_encoding183 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 34
  %74 = load ptr, ptr %m_encoding183, align 8
  %cmp184 = icmp eq ptr %74, %enc
  br i1 %cmp184, label %if.then186, label %return

if.then186:                                       ; preds = %if.then182
  %m_eventPtr187 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 47
  store ptr %ptr.addr.0, ptr %m_eventPtr187, align 8
  br label %return

if.else189:                                       ; preds = %if.end180
  %textLen = getelementptr inbounds %struct.ENTITY, ptr %retval.0.i114, i64 0, i32 2
  %75 = load i32, ptr %textLen, align 8
  %idx.ext191 = sext i32 %75 to i64
  store i8 1, ptr %open, align 8
  br label %while.cond.i.i

while.cond.i.i:                                   ; preds = %while.cond.i.i, %if.else189
  %rootParser.0.i.i = phi ptr [ %parser, %if.else189 ], [ %76, %while.cond.i.i ]
  %m_parentParser.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i, i64 0, i32 84
  %76 = load ptr, ptr %m_parentParser.i.i, align 8
  %tobool.not.i.i116 = icmp eq ptr %76, null
  br i1 %tobool.not.i.i116, label %getRootParserOf.exit.i, label %while.cond.i.i, !llvm.loop !31

getRootParserOf.exit.i:                           ; preds = %while.cond.i.i
  %add.ptr192 = getelementptr i8, ptr %73, i64 %idx.ext191
  %m_entity_stats.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i, i64 0, i32 91
  %77 = load i32, ptr %m_entity_stats.i, align 8
  %inc.i = add i32 %77, 1
  store i32 %inc.i, ptr %m_entity_stats.i, align 8
  %currentDepth.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i, i64 0, i32 91, i32 1
  %78 = load i32, ptr %currentDepth.i, align 4
  %inc2.i = add i32 %78, 1
  store i32 %inc2.i, ptr %currentDepth.i, align 4
  %maximumDepthSeen.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i, i64 0, i32 91, i32 2
  %79 = load i32, ptr %maximumDepthSeen.i, align 8
  %cmp.i117 = icmp ugt i32 %inc2.i, %79
  br i1 %cmp.i117, label %if.then.i123, label %if.end.i118

if.then.i123:                                     ; preds = %getRootParserOf.exit.i
  %inc8.i = add nuw i32 %79, 1
  store i32 %inc8.i, ptr %maximumDepthSeen.i, align 8
  br label %if.end.i118

if.end.i118:                                      ; preds = %if.then.i123, %getRootParserOf.exit.i
  %80 = phi i32 [ %inc8.i, %if.then.i123 ], [ %79, %getRootParserOf.exit.i ]
  %debugLevel.i.i119 = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i, i64 0, i32 91, i32 3
  %81 = load i32, ptr %debugLevel.i.i119, align 4
  %cmp.i.i120 = icmp slt i32 %81, 1
  br i1 %cmp.i.i120, label %entityTrackingOnOpen.exit, label %if.end.i.i121

if.end.i.i121:                                    ; preds = %if.end.i118
  %82 = load ptr, ptr %retval.0.i114, align 8
  %83 = load ptr, ptr @stderr, align 8
  %sub.i.i = shl i32 %inc2.i, 1
  %mul.i.i = add i32 %sub.i.i, -2
  %is_param.i.i = getelementptr inbounds %struct.ENTITY, ptr %retval.0.i114, i64 0, i32 9
  %84 = load i8, ptr %is_param.i.i, align 1
  %tobool.not.i6.i = icmp eq i8 %84, 0
  %cond.i.i = select i1 %tobool.not.i6.i, ptr @.str.89, ptr @.str.88
  %85 = load i32, ptr %textLen, align 8
  %call.i.i122 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %83, ptr noundef nonnull @.str.320, ptr noundef nonnull %rootParser.0.i.i, i32 noundef %inc.i, i32 noundef %inc2.i, i32 noundef %80, i32 noundef %mul.i.i, ptr noundef nonnull @.str.310, ptr noundef nonnull %cond.i.i, ptr noundef %82, ptr noundef nonnull @.str.319, i32 noundef %85, i32 noundef 6046) #27
  br label %entityTrackingOnOpen.exit

entityTrackingOnOpen.exit:                        ; preds = %if.end.i118, %if.end.i.i121
  %86 = load ptr, ptr %m_internalEncoding, align 8
  %87 = load ptr, ptr %textPtr, align 8
  %call195 = call fastcc i32 @appendAttributeValue(ptr noundef %parser, ptr noundef %86, i8 noundef zeroext %isCdata, ptr noundef %87, ptr noundef %add.ptr192, ptr noundef %pool, i32 noundef 1), !range !32
  br label %while.cond.i.i124

while.cond.i.i124:                                ; preds = %while.cond.i.i124, %entityTrackingOnOpen.exit
  %rootParser.0.i.i125 = phi ptr [ %parser, %entityTrackingOnOpen.exit ], [ %88, %while.cond.i.i124 ]
  %m_parentParser.i.i126 = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i125, i64 0, i32 84
  %88 = load ptr, ptr %m_parentParser.i.i126, align 8
  %tobool.not.i.i127 = icmp eq ptr %88, null
  br i1 %tobool.not.i.i127, label %getRootParserOf.exit.i128, label %while.cond.i.i124, !llvm.loop !31

getRootParserOf.exit.i128:                        ; preds = %while.cond.i.i124
  %debugLevel.i.i129 = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i125, i64 0, i32 91, i32 3
  %89 = load i32, ptr %debugLevel.i.i129, align 4
  %cmp.i.i130 = icmp slt i32 %89, 1
  br i1 %cmp.i.i130, label %entityTrackingOnClose.exit, label %if.end.i.i131

if.end.i.i131:                                    ; preds = %getRootParserOf.exit.i128
  %m_entity_stats.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i125, i64 0, i32 91
  %90 = load ptr, ptr %retval.0.i114, align 8
  %91 = load ptr, ptr @stderr, align 8
  %92 = load i32, ptr %m_entity_stats.i.i, align 8
  %currentDepth.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i125, i64 0, i32 91, i32 1
  %93 = load i32, ptr %currentDepth.i.i, align 4
  %maximumDepthSeen.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i125, i64 0, i32 91, i32 2
  %94 = load i32, ptr %maximumDepthSeen.i.i, align 8
  %sub.i.i132 = shl i32 %93, 1
  %mul.i.i133 = add i32 %sub.i.i132, -2
  %is_param.i.i134 = getelementptr inbounds %struct.ENTITY, ptr %retval.0.i114, i64 0, i32 9
  %95 = load i8, ptr %is_param.i.i134, align 1
  %tobool.not.i2.i = icmp eq i8 %95, 0
  %cond.i.i135 = select i1 %tobool.not.i2.i, ptr @.str.89, ptr @.str.88
  %96 = load i32, ptr %textLen, align 8
  %call.i.i137 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %91, ptr noundef nonnull @.str.320, ptr noundef nonnull %rootParser.0.i.i125, i32 noundef %92, i32 noundef %93, i32 noundef %94, i32 noundef %mul.i.i133, ptr noundef nonnull @.str.310, ptr noundef nonnull %cond.i.i135, ptr noundef %90, ptr noundef nonnull @.str.321, i32 noundef %96, i32 noundef 6053) #27
  br label %entityTrackingOnClose.exit

entityTrackingOnClose.exit:                       ; preds = %getRootParserOf.exit.i128, %if.end.i.i131
  %currentDepth.i138 = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i125, i64 0, i32 91, i32 1
  %97 = load i32, ptr %currentDepth.i138, align 4
  %dec.i = add i32 %97, -1
  store i32 %dec.i, ptr %currentDepth.i138, align 4
  store i8 0, ptr %open, align 8
  %tobool197.not = icmp eq i32 %call195, 0
  br i1 %tobool197.not, label %sw.epilog, label %return

sw.default:                                       ; preds = %if.end
  %m_encoding201 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 34
  %98 = load ptr, ptr %m_encoding201, align 8
  %cmp202 = icmp eq ptr %98, %enc
  br i1 %cmp202, label %if.then204, label %return

if.then204:                                       ; preds = %sw.default
  %m_eventPtr205 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 47
  store ptr %ptr.addr.0, ptr %m_eventPtr205, align 8
  br label %return

sw.epilog:                                        ; preds = %cond.false, %if.end31, %entityTrackingOnClose.exit, %if.else158, %land.lhs.true55, %lor.lhs.false63, %poolAppend.exit, %land.lhs.true23, %lor.lhs.false, %cond.false105, %cond.false79
  %99 = load ptr, ptr %next, align 8
  br label %for.cond

return:                                           ; preds = %land.lhs.true.i112, %poolAppend.exit.i, %entityTrackingOnClose.exit, %if.else153, %if.then150, %poolStoreString.exit, %land.lhs.true101, %land.lhs.true75, %poolAppend.exit, %if.end, %land.lhs.true40, %poolAppend.exit.thread.i, %poolAppend.exit.thread, %accountingGetCurrentAmplification.exit.i.i, %getRootParserOf.exit.i.i, %sw.default, %if.then204, %if.then182, %if.then186, %if.then173, %if.then177, %if.then164, %if.then168, %if.then14, %if.then17, %sw.bb5, %if.then8, %sw.bb2, %if.then3
  %retval.0 = phi i32 [ 4, %if.then3 ], [ 4, %sw.bb2 ], [ 4, %if.then8 ], [ 4, %sw.bb5 ], [ 14, %if.then17 ], [ 14, %if.then14 ], [ 12, %if.then168 ], [ 12, %if.then164 ], [ 15, %if.then177 ], [ 15, %if.then173 ], [ 16, %if.then186 ], [ 16, %if.then182 ], [ 23, %if.then204 ], [ 23, %sw.default ], [ 43, %getRootParserOf.exit.i.i ], [ 43, %accountingGetCurrentAmplification.exit.i.i ], [ 1, %poolAppend.exit.thread ], [ 1, %poolAppend.exit.thread.i ], [ 1, %land.lhs.true40 ], [ 1, %land.lhs.true.i112 ], [ 1, %poolAppend.exit.i ], [ %call195, %entityTrackingOnClose.exit ], [ 24, %if.else153 ], [ 11, %if.then150 ], [ 1, %poolStoreString.exit ], [ 1, %land.lhs.true101 ], [ 1, %land.lhs.true75 ], [ 1, %poolAppend.exit ], [ 0, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @internalEntityProcessor(ptr noundef %parser, ptr noundef %s, ptr noundef %end, ptr noundef %nextPtr) #0 {
entry:
  %next = alloca ptr, align 8
  %m_openInternalEntities = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 50
  %0 = load ptr, ptr %m_openInternalEntities, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %entity1 = getelementptr inbounds %struct.open_internal_entity, ptr %0, i64 0, i32 3
  %1 = load ptr, ptr %entity1, align 8
  %textPtr = getelementptr inbounds %struct.ENTITY, ptr %1, i64 0, i32 1
  %2 = load ptr, ptr %textPtr, align 8
  %processed = getelementptr inbounds %struct.ENTITY, ptr %1, i64 0, i32 3
  %3 = load i32, ptr %processed, align 4
  %idx.ext = sext i32 %3 to i64
  %add.ptr = getelementptr i8, ptr %2, i64 %idx.ext
  %textLen = getelementptr inbounds %struct.ENTITY, ptr %1, i64 0, i32 2
  %4 = load i32, ptr %textLen, align 8
  %idx.ext3 = sext i32 %4 to i64
  %add.ptr4 = getelementptr i8, ptr %2, i64 %idx.ext3
  store ptr %add.ptr, ptr %next, align 8
  %is_param = getelementptr inbounds %struct.ENTITY, ptr %1, i64 0, i32 9
  %5 = load i8, ptr %is_param, align 1
  %tobool5.not = icmp eq i8 %5, 0
  br i1 %tobool5.not, label %if.else, label %if.then6

if.then6:                                         ; preds = %if.end
  %m_internalEncoding = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 36
  %6 = load ptr, ptr %m_internalEncoding, align 8
  %7 = load ptr, ptr %6, align 8
  %call = call i32 %7(ptr noundef nonnull %6, ptr noundef %add.ptr, ptr noundef %add.ptr4, ptr noundef nonnull %next) #24
  %8 = load ptr, ptr %m_internalEncoding, align 8
  %9 = load ptr, ptr %next, align 8
  %call9 = call fastcc i32 @doProlog(ptr noundef nonnull %parser, ptr noundef %8, ptr noundef %add.ptr, ptr noundef %add.ptr4, i32 noundef %call, ptr noundef %9, ptr noundef nonnull %next, i8 noundef zeroext 0, i8 noundef zeroext 1, i32 noundef 1)
  br label %if.end12

if.else:                                          ; preds = %if.end
  %startTagLevel = getelementptr inbounds %struct.open_internal_entity, ptr %0, i64 0, i32 4
  %10 = load i32, ptr %startTagLevel, align 8
  %m_internalEncoding10 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 36
  %11 = load ptr, ptr %m_internalEncoding10, align 8
  %call11 = call fastcc i32 @doContent(ptr noundef nonnull %parser, i32 noundef %10, ptr noundef %11, ptr noundef %add.ptr, ptr noundef %add.ptr4, ptr noundef nonnull %next, i8 noundef zeroext 0, i32 noundef 1)
  br label %if.end12

if.end12:                                         ; preds = %if.else, %if.then6
  %result.0 = phi i32 [ %call9, %if.then6 ], [ %call11, %if.else ]
  %cmp.not = icmp eq i32 %result.0, 0
  br i1 %cmp.not, label %if.end14, label %return

if.end14:                                         ; preds = %if.end12
  %12 = load ptr, ptr %next, align 8
  %cmp15.not = icmp eq ptr %add.ptr4, %12
  br i1 %cmp15.not, label %while.cond.i.i.preheader, label %land.lhs.true

while.cond.i.i.preheader:                         ; preds = %land.lhs.true, %if.end14
  br label %while.cond.i.i

land.lhs.true:                                    ; preds = %if.end14
  %m_parsingStatus = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 85
  %13 = load i32, ptr %m_parsingStatus, align 8
  %cmp16 = icmp eq i32 %13, 3
  br i1 %cmp16, label %if.then17, label %while.cond.i.i.preheader

if.then17:                                        ; preds = %land.lhs.true
  %14 = load ptr, ptr %textPtr, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %12 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %14 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv = trunc i64 %sub.ptr.sub to i32
  store i32 %conv, ptr %processed, align 4
  br label %return

while.cond.i.i:                                   ; preds = %while.cond.i.i.preheader, %while.cond.i.i
  %rootParser.0.i.i = phi ptr [ %15, %while.cond.i.i ], [ %parser, %while.cond.i.i.preheader ]
  %m_parentParser.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i, i64 0, i32 84
  %15 = load ptr, ptr %m_parentParser.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %15, null
  br i1 %tobool.not.i.i, label %getRootParserOf.exit.i, label %while.cond.i.i, !llvm.loop !31

getRootParserOf.exit.i:                           ; preds = %while.cond.i.i
  %debugLevel.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i, i64 0, i32 91, i32 3
  %16 = load i32, ptr %debugLevel.i.i, align 4
  %cmp.i.i = icmp slt i32 %16, 1
  br i1 %cmp.i.i, label %entityTrackingOnClose.exit, label %if.end.i.i

if.end.i.i:                                       ; preds = %getRootParserOf.exit.i
  %m_entity_stats.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i, i64 0, i32 91
  %17 = load ptr, ptr %1, align 8
  %18 = load ptr, ptr @stderr, align 8
  %19 = load i32, ptr %m_entity_stats.i.i, align 8
  %currentDepth.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i, i64 0, i32 91, i32 1
  %20 = load i32, ptr %currentDepth.i.i, align 4
  %maximumDepthSeen.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i, i64 0, i32 91, i32 2
  %21 = load i32, ptr %maximumDepthSeen.i.i, align 8
  %sub.i.i = shl i32 %20, 1
  %mul.i.i = add i32 %sub.i.i, -2
  %22 = load i8, ptr %is_param, align 1
  %tobool.not.i2.i = icmp eq i8 %22, 0
  %cond.i.i = select i1 %tobool.not.i2.i, ptr @.str.89, ptr @.str.88
  %23 = load i32, ptr %textLen, align 8
  %call.i.i = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %18, ptr noundef nonnull @.str.320, ptr noundef nonnull %rootParser.0.i.i, i32 noundef %19, i32 noundef %20, i32 noundef %21, i32 noundef %mul.i.i, ptr noundef nonnull @.str.310, ptr noundef nonnull %cond.i.i, ptr noundef %17, ptr noundef nonnull @.str.321, i32 noundef %23, i32 noundef 5817) #27
  br label %entityTrackingOnClose.exit

entityTrackingOnClose.exit:                       ; preds = %getRootParserOf.exit.i, %if.end.i.i
  %currentDepth.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i, i64 0, i32 91, i32 1
  %24 = load i32, ptr %currentDepth.i, align 4
  %dec.i = add i32 %24, -1
  store i32 %dec.i, ptr %currentDepth.i, align 4
  %open = getelementptr inbounds %struct.ENTITY, ptr %1, i64 0, i32 8
  store i8 0, ptr %open, align 8
  %next21 = getelementptr inbounds %struct.open_internal_entity, ptr %0, i64 0, i32 2
  %25 = load ptr, ptr %next21, align 8
  store ptr %25, ptr %m_openInternalEntities, align 8
  %m_freeInternalEntities = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 51
  %26 = load ptr, ptr %m_freeInternalEntities, align 8
  store ptr %26, ptr %next21, align 8
  store ptr %0, ptr %m_freeInternalEntities, align 8
  %27 = load ptr, ptr %m_openInternalEntities, align 8
  %cmp26.not = icmp eq ptr %27, null
  br i1 %cmp26.not, label %if.end34, label %land.lhs.true28

land.lhs.true28:                                  ; preds = %entityTrackingOnClose.exit
  %m_parsingStatus29 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 85
  %28 = load i32, ptr %m_parsingStatus29, align 8
  %cmp31 = icmp eq i32 %28, 3
  br i1 %cmp31, label %return, label %if.end34

if.end34:                                         ; preds = %land.lhs.true28, %entityTrackingOnClose.exit
  %29 = load i8, ptr %is_param, align 1
  %tobool36.not = icmp eq i8 %29, 0
  %m_processor49 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 45
  %finalBuffer53 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 85, i32 1
  br i1 %tobool36.not, label %if.else48, label %if.then37

if.then37:                                        ; preds = %if.end34
  store ptr @prologProcessor, ptr %m_processor49, align 8
  %m_encoding = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 34
  %30 = load ptr, ptr %m_encoding, align 8
  %31 = load ptr, ptr %30, align 8
  %call42 = call i32 %31(ptr noundef nonnull %30, ptr noundef %s, ptr noundef %end, ptr noundef nonnull %next) #24
  %32 = load ptr, ptr %m_encoding, align 8
  %33 = load ptr, ptr %next, align 8
  %34 = load i8, ptr %finalBuffer53, align 4
  %tobool45.not = icmp eq i8 %34, 0
  %conv46 = zext i1 %tobool45.not to i8
  %call47 = call fastcc i32 @doProlog(ptr noundef nonnull %parser, ptr noundef %32, ptr noundef %s, ptr noundef %end, i32 noundef %call42, ptr noundef %33, ptr noundef %nextPtr, i8 noundef zeroext %conv46, i8 noundef zeroext 1, i32 noundef 0)
  br label %return

if.else48:                                        ; preds = %if.end34
  store ptr @contentProcessor, ptr %m_processor49, align 8
  %m_parentParser = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 84
  %35 = load ptr, ptr %m_parentParser, align 8
  %tobool50.not = icmp ne ptr %35, null
  %cond = zext i1 %tobool50.not to i32
  %m_encoding51 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 34
  %36 = load ptr, ptr %m_encoding51, align 8
  %37 = load i8, ptr %finalBuffer53, align 4
  %tobool54.not = icmp eq i8 %37, 0
  %conv57 = zext i1 %tobool54.not to i8
  %call58 = call fastcc i32 @doContent(ptr noundef nonnull %parser, i32 noundef %cond, ptr noundef %36, ptr noundef %s, ptr noundef %end, ptr noundef %nextPtr, i8 noundef zeroext %conv57, i32 noundef 0)
  %cmp59 = icmp eq i32 %call58, 0
  br i1 %cmp59, label %if.then61, label %if.end66

if.then61:                                        ; preds = %if.else48
  %call62 = call fastcc zeroext i8 @storeRawNames(ptr noundef nonnull %parser), !range !13
  %tobool63.not = icmp eq i8 %call62, 0
  br i1 %tobool63.not, label %return, label %if.end66

if.end66:                                         ; preds = %if.then61, %if.else48
  br label %return

return:                                           ; preds = %if.then61, %land.lhs.true28, %if.end12, %entry, %if.end66, %if.then37, %if.then17
  %retval.0 = phi i32 [ 0, %if.then17 ], [ %call47, %if.then37 ], [ %call58, %if.end66 ], [ 23, %entry ], [ %result.0, %if.end12 ], [ 0, %land.lhs.true28 ], [ 1, %if.then61 ]
  ret i32 %retval.0
}

; Function Attrs: nofree nounwind memory(read)
declare noundef ptr @getenv(ptr nocapture noundef) local_unnamed_addr #16

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
declare ptr @__errno_location() local_unnamed_addr #17

; Function Attrs: mustprogress nofree nounwind willreturn
declare i64 @strtoul(ptr noundef readonly, ptr nocapture noundef, i32 noundef) local_unnamed_addr #18

; Function Attrs: nounwind
declare i32 @getpid() local_unnamed_addr #19

declare i64 @getrandom(ptr noundef, i64 noundef, i32 noundef) local_unnamed_addr #1

; Function Attrs: nofree nounwind
declare noundef i32 @gettimeofday(ptr nocapture noundef, ptr nocapture noundef) local_unnamed_addr #13

; Function Attrs: nounwind uwtable
define internal i32 @externalEntityInitProcessor2(ptr noundef %parser, ptr noundef %start, ptr noundef %end, ptr nocapture noundef writeonly %endPtr) #0 {
entry:
  %next = alloca ptr, align 8
  store ptr %start, ptr %next, align 8
  %m_encoding = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 34
  %0 = load ptr, ptr %m_encoding, align 8
  %arrayidx = getelementptr [4 x ptr], ptr %0, i64 0, i64 1
  %1 = load ptr, ptr %arrayidx, align 8
  %call = call i32 %1(ptr noundef %0, ptr noundef %start, ptr noundef %end, ptr noundef nonnull %next) #24
  switch i32 %call, label %sw.epilog [
    i32 14, label %sw.bb
    i32 -1, label %sw.bb6
    i32 -2, label %sw.bb12
  ]

sw.bb:                                            ; preds = %entry
  %2 = load ptr, ptr %next, align 8
  %call2 = call fastcc zeroext i8 @accountingDiffTolerated(ptr noundef nonnull %parser, i32 noundef 14, ptr noundef %start, ptr noundef %2, i32 noundef 2649, i32 noundef 0), !range !13
  %tobool.not = icmp eq i8 %call2, 0
  br i1 %tobool.not, label %while.cond.i.i.i, label %if.end

while.cond.i.i.i:                                 ; preds = %sw.bb, %while.cond.i.i.i
  %rootParser.0.i.i.i = phi ptr [ %3, %while.cond.i.i.i ], [ %parser, %sw.bb ]
  %m_parentParser.i.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i.i, i64 0, i32 84
  %3 = load ptr, ptr %m_parentParser.i.i.i, align 8
  %tobool.not.i.i.i = icmp eq ptr %3, null
  br i1 %tobool.not.i.i.i, label %getRootParserOf.exit.i.i, label %while.cond.i.i.i, !llvm.loop !31

getRootParserOf.exit.i.i:                         ; preds = %while.cond.i.i.i
  %debugLevel.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i.i, i64 0, i32 90, i32 2
  %4 = load i32, ptr %debugLevel.i.i, align 8
  %cmp.i.i = icmp slt i32 %4, 1
  br i1 %cmp.i.i, label %return, label %if.end.i.i

if.end.i.i:                                       ; preds = %getRootParserOf.exit.i.i
  %m_accounting.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i.i, i64 0, i32 90
  %5 = load i64, ptr %m_accounting.i.i, align 8
  %tobool.not.i5.i.i = icmp eq i64 %5, 0
  %countBytesIndirect.phi.trans.insert.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i.i, i64 0, i32 90, i32 1
  %.pre.i.i = load i64, ptr %countBytesIndirect.phi.trans.insert.i.i, align 8
  br i1 %tobool.not.i5.i.i, label %accountingGetCurrentAmplification.exit.i.i, label %cond.true.i.i.i

cond.true.i.i.i:                                  ; preds = %if.end.i.i
  %add.i.i.i = add i64 %.pre.i.i, %5
  %conv.i.i.i = uitofp i64 %add.i.i.i to float
  %conv6.i.i.i = uitofp i64 %5 to float
  %div.i.i.i = fdiv float %conv.i.i.i, %conv6.i.i.i
  %6 = fpext float %div.i.i.i to double
  br label %accountingGetCurrentAmplification.exit.i.i

accountingGetCurrentAmplification.exit.i.i:       ; preds = %cond.true.i.i.i, %if.end.i.i
  %cond.i.i.i = phi double [ %6, %cond.true.i.i.i ], [ 1.000000e+00, %if.end.i.i ]
  %7 = load ptr, ptr @stderr, align 8
  %call4.i.i = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %7, ptr noundef nonnull @.str.311, ptr noundef nonnull %rootParser.0.i.i.i, i64 noundef %5, i64 noundef %.pre.i.i, double noundef %cond.i.i.i, ptr noundef nonnull @.str.317) #27
  br label %return

if.end:                                           ; preds = %sw.bb
  %8 = load ptr, ptr %next, align 8
  %cmp = icmp eq ptr %8, %end
  br i1 %cmp, label %land.lhs.true, label %sw.epilog

land.lhs.true:                                    ; preds = %if.end
  %finalBuffer = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 85, i32 1
  %9 = load i8, ptr %finalBuffer, align 4
  %tobool3.not = icmp eq i8 %9, 0
  br i1 %tobool3.not, label %if.then4, label %sw.epilog

if.then4:                                         ; preds = %land.lhs.true
  store ptr %end, ptr %endPtr, align 8
  br label %return

sw.bb6:                                           ; preds = %entry
  %finalBuffer8 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 85, i32 1
  %10 = load i8, ptr %finalBuffer8, align 4
  %tobool9.not = icmp eq i8 %10, 0
  br i1 %tobool9.not, label %if.then10, label %if.end11

if.then10:                                        ; preds = %sw.bb6
  store ptr %start, ptr %endPtr, align 8
  br label %return

if.end11:                                         ; preds = %sw.bb6
  %m_eventPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 47
  store ptr %start, ptr %m_eventPtr, align 8
  br label %return

sw.bb12:                                          ; preds = %entry
  %finalBuffer14 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 85, i32 1
  %11 = load i8, ptr %finalBuffer14, align 4
  %tobool15.not = icmp eq i8 %11, 0
  br i1 %tobool15.not, label %if.then16, label %if.end17

if.then16:                                        ; preds = %sw.bb12
  store ptr %start, ptr %endPtr, align 8
  br label %return

if.end17:                                         ; preds = %sw.bb12
  %m_eventPtr18 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 47
  store ptr %start, ptr %m_eventPtr18, align 8
  br label %return

sw.epilog:                                        ; preds = %if.end, %land.lhs.true, %entry
  %start.addr.0 = phi ptr [ %start, %entry ], [ %end, %land.lhs.true ], [ %8, %if.end ]
  %m_processor = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 45
  store ptr @externalEntityInitProcessor3, ptr %m_processor, align 8
  %call19 = call i32 @externalEntityInitProcessor3(ptr noundef nonnull %parser, ptr noundef %start.addr.0, ptr noundef %end, ptr noundef %endPtr)
  br label %return

return:                                           ; preds = %accountingGetCurrentAmplification.exit.i.i, %getRootParserOf.exit.i.i, %sw.epilog, %if.end17, %if.then16, %if.end11, %if.then10, %if.then4
  %retval.0 = phi i32 [ %call19, %sw.epilog ], [ 6, %if.end17 ], [ 0, %if.then16 ], [ 5, %if.end11 ], [ 0, %if.then10 ], [ 0, %if.then4 ], [ 43, %getRootParserOf.exit.i.i ], [ 43, %accountingGetCurrentAmplification.exit.i.i ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @externalEntityInitProcessor3(ptr noundef %parser, ptr noundef %start, ptr noundef %end, ptr nocapture noundef writeonly %endPtr) #0 {
entry:
  %next = alloca ptr, align 8
  store ptr %start, ptr %next, align 8
  %m_eventPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 47
  store ptr %start, ptr %m_eventPtr, align 8
  %m_encoding = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 34
  %0 = load ptr, ptr %m_encoding, align 8
  %arrayidx = getelementptr [4 x ptr], ptr %0, i64 0, i64 1
  %1 = load ptr, ptr %arrayidx, align 8
  %call = call i32 %1(ptr noundef %0, ptr noundef %start, ptr noundef %end, ptr noundef nonnull %next) #24
  %2 = load ptr, ptr %next, align 8
  %m_eventEndPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 48
  store ptr %2, ptr %m_eventEndPtr, align 8
  switch i32 %call, label %sw.epilog15 [
    i32 12, label %sw.bb
    i32 -1, label %sw.bb5
    i32 -2, label %sw.bb9
  ]

sw.bb:                                            ; preds = %entry
  %call2 = call fastcc i32 @processXmlDecl(ptr noundef nonnull %parser, i32 noundef 1, ptr noundef %start, ptr noundef %2), !range !32
  %cmp.not = icmp eq i32 %call2, 0
  br i1 %cmp.not, label %if.end, label %return

if.end:                                           ; preds = %sw.bb
  %m_parsingStatus = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 85
  %3 = load i32, ptr %m_parsingStatus, align 8
  switch i32 %3, label %sw.default [
    i32 3, label %sw.bb3
    i32 2, label %return
  ]

sw.bb3:                                           ; preds = %if.end
  %4 = load ptr, ptr %next, align 8
  store ptr %4, ptr %endPtr, align 8
  br label %return

sw.default:                                       ; preds = %if.end
  %5 = load ptr, ptr %next, align 8
  br label %sw.epilog15

sw.bb5:                                           ; preds = %entry
  %finalBuffer = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 85, i32 1
  %6 = load i8, ptr %finalBuffer, align 4
  %tobool.not = icmp eq i8 %6, 0
  br i1 %tobool.not, label %if.then7, label %return

if.then7:                                         ; preds = %sw.bb5
  store ptr %start, ptr %endPtr, align 8
  br label %return

sw.bb9:                                           ; preds = %entry
  %finalBuffer11 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 85, i32 1
  %7 = load i8, ptr %finalBuffer11, align 4
  %tobool12.not = icmp eq i8 %7, 0
  br i1 %tobool12.not, label %if.then13, label %return

if.then13:                                        ; preds = %sw.bb9
  store ptr %start, ptr %endPtr, align 8
  br label %return

sw.epilog15:                                      ; preds = %sw.default, %entry
  %start.addr.0 = phi ptr [ %start, %entry ], [ %5, %sw.default ]
  %m_processor = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 45
  store ptr @externalEntityContentProcessor, ptr %m_processor, align 8
  %m_tagLevel = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 53
  store i32 1, ptr %m_tagLevel, align 4
  %call16 = call i32 @externalEntityContentProcessor(ptr noundef nonnull %parser, ptr noundef %start.addr.0, ptr noundef %end, ptr noundef %endPtr)
  br label %return

return:                                           ; preds = %sw.bb9, %sw.bb5, %if.end, %sw.bb, %sw.epilog15, %if.then13, %if.then7, %sw.bb3
  %retval.0 = phi i32 [ %call16, %sw.epilog15 ], [ 0, %if.then13 ], [ 0, %if.then7 ], [ 0, %sw.bb3 ], [ %call2, %sw.bb ], [ 35, %if.end ], [ 5, %sw.bb5 ], [ 6, %sw.bb9 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @entityValueInitProcessor(ptr noundef %parser, ptr noundef %s, ptr noundef %end, ptr nocapture noundef writeonly %nextPtr) #0 {
entry:
  %next.i = alloca ptr, align 8
  %next = alloca ptr, align 8
  store ptr %s, ptr %next, align 8
  %m_eventPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 47
  %m_encoding = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 34
  store ptr %s, ptr %m_eventPtr, align 8
  %0 = load ptr, ptr %m_encoding, align 8
  %1 = load ptr, ptr %0, align 8
  %call49 = call i32 %1(ptr noundef nonnull %0, ptr noundef %s, ptr noundef %end, ptr noundef nonnull %next) #24
  %2 = load ptr, ptr %next, align 8
  %m_eventEndPtr = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 48
  store ptr %2, ptr %m_eventEndPtr, align 8
  %cmp50 = icmp slt i32 %call49, 1
  br i1 %cmp50, label %if.then, label %if.else.lr.ph

if.else.lr.ph:                                    ; preds = %entry
  %finalBuffer26 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 85, i32 1
  br label %if.else

if.then:                                          ; preds = %if.end39, %entry
  %call.lcssa = phi i32 [ %call49, %entry ], [ %call, %if.end39 ]
  %finalBuffer = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 85, i32 1
  %3 = load i8, ptr %finalBuffer, align 4
  %tobool = icmp eq i8 %3, 0
  %cmp2 = icmp ne i32 %call.lcssa, 0
  %or.cond = and i1 %cmp2, %tobool
  br i1 %or.cond, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  store ptr %s, ptr %nextPtr, align 8
  br label %return

if.end:                                           ; preds = %if.then
  %switch.tableidx = add i32 %call.lcssa, 2
  %4 = icmp ult i32 %switch.tableidx, 3
  br i1 %4, label %switch.lookup, label %sw.epilog

sw.epilog:                                        ; preds = %if.end
  %5 = load ptr, ptr %m_encoding, align 8
  %call8 = call fastcc i32 @storeEntityValue(ptr noundef nonnull %parser, ptr noundef %5, ptr noundef %s, ptr noundef %end, i32 noundef 0)
  br label %return

if.else:                                          ; preds = %if.else.lr.ph, %if.end39
  %6 = phi ptr [ %2, %if.else.lr.ph ], [ %24, %if.end39 ]
  %call52 = phi i32 [ %call49, %if.else.lr.ph ], [ %call, %if.end39 ]
  %start.051 = phi ptr [ %s, %if.else.lr.ph ], [ %6, %if.end39 ]
  switch i32 %call52, label %if.end39 [
    i32 12, label %if.then10
    i32 14, label %land.lhs.true22
    i32 29, label %if.then35
  ]

if.then10:                                        ; preds = %if.else
  %call11 = call fastcc i32 @processXmlDecl(ptr noundef nonnull %parser, i32 noundef 0, ptr noundef %start.051, ptr noundef %6), !range !32
  %cmp12.not = icmp eq i32 %call11, 0
  br i1 %cmp12.not, label %if.end14, label %return

if.end14:                                         ; preds = %if.then10
  %m_parsingStatus15 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 85
  %7 = load i32, ptr %m_parsingStatus15, align 8
  %cmp16 = icmp eq i32 %7, 2
  br i1 %cmp16, label %return, label %if.end18

if.end18:                                         ; preds = %if.end14
  %8 = load ptr, ptr %next, align 8
  store ptr %8, ptr %nextPtr, align 8
  %m_processor = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 45
  store ptr @entityValueProcessor, ptr %m_processor, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %next.i)
  store ptr %8, ptr %next.i, align 8
  %9 = load ptr, ptr %m_encoding, align 8
  %10 = load ptr, ptr %9, align 8
  %call11.i = call i32 %10(ptr noundef nonnull %9, ptr noundef %8, ptr noundef %end, ptr noundef nonnull %next.i) #24
  %cmp12.i = icmp slt i32 %call11.i, 1
  br i1 %cmp12.i, label %if.then.i, label %if.end7.i

if.then.i:                                        ; preds = %if.end7.i, %if.end18
  %call.lcssa.i = phi i32 [ %call11.i, %if.end18 ], [ %call.i, %if.end7.i ]
  %11 = load i8, ptr %finalBuffer26, align 4
  %tobool.i = icmp eq i8 %11, 0
  %cmp1.i = icmp ne i32 %call.lcssa.i, 0
  %or.cond.i = and i1 %cmp1.i, %tobool.i
  br i1 %or.cond.i, label %if.then2.i, label %if.end.i

if.then2.i:                                       ; preds = %if.then.i
  store ptr %8, ptr %nextPtr, align 8
  br label %entityValueProcessor.exit

if.end.i:                                         ; preds = %if.then.i
  %switch.tableidx75 = add i32 %call.lcssa.i, 2
  %12 = icmp ult i32 %switch.tableidx75, 3
  br i1 %12, label %switch.lookup74, label %sw.epilog.i

sw.epilog.i:                                      ; preds = %if.end.i
  %call6.i = call fastcc i32 @storeEntityValue(ptr noundef nonnull %parser, ptr noundef nonnull %9, ptr noundef %8, ptr noundef %end, i32 noundef 0)
  br label %entityValueProcessor.exit

if.end7.i:                                        ; preds = %if.end18, %if.end7.i
  %13 = load ptr, ptr %next.i, align 8
  %14 = load ptr, ptr %9, align 8
  %call.i = call i32 %14(ptr noundef nonnull %9, ptr noundef %13, ptr noundef %end, ptr noundef nonnull %next.i) #24
  %cmp.i = icmp slt i32 %call.i, 1
  br i1 %cmp.i, label %if.then.i, label %if.end7.i

switch.lookup74:                                  ; preds = %if.end.i
  %switch.offset77 = sub i32 4, %call.lcssa.i
  br label %entityValueProcessor.exit

entityValueProcessor.exit:                        ; preds = %switch.lookup74, %if.then2.i, %sw.epilog.i
  %retval.0.i = phi i32 [ 0, %if.then2.i ], [ %call6.i, %sw.epilog.i ], [ %switch.offset77, %switch.lookup74 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %next.i)
  br label %return

land.lhs.true22:                                  ; preds = %if.else
  %cmp23 = icmp eq ptr %6, %end
  br i1 %cmp23, label %land.lhs.true24, label %if.end39

land.lhs.true24:                                  ; preds = %land.lhs.true22
  %15 = load i8, ptr %finalBuffer26, align 4
  %tobool27.not = icmp eq i8 %15, 0
  br i1 %tobool27.not, label %if.then28, label %if.end39

if.then28:                                        ; preds = %land.lhs.true24
  %call29 = call fastcc zeroext i8 @accountingDiffTolerated(ptr noundef nonnull %parser, i32 noundef 14, ptr noundef %s, ptr noundef %end, i32 noundef 4495, i32 noundef 0), !range !13
  %tobool30.not = icmp eq i8 %call29, 0
  br i1 %tobool30.not, label %while.cond.i.i.i, label %if.end32

while.cond.i.i.i:                                 ; preds = %if.then28, %while.cond.i.i.i
  %rootParser.0.i.i.i = phi ptr [ %16, %while.cond.i.i.i ], [ %parser, %if.then28 ]
  %m_parentParser.i.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i.i, i64 0, i32 84
  %16 = load ptr, ptr %m_parentParser.i.i.i, align 8
  %tobool.not.i.i.i = icmp eq ptr %16, null
  br i1 %tobool.not.i.i.i, label %getRootParserOf.exit.i.i, label %while.cond.i.i.i, !llvm.loop !31

getRootParserOf.exit.i.i:                         ; preds = %while.cond.i.i.i
  %debugLevel.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i.i, i64 0, i32 90, i32 2
  %17 = load i32, ptr %debugLevel.i.i, align 8
  %cmp.i.i = icmp slt i32 %17, 1
  br i1 %cmp.i.i, label %return, label %if.end.i.i

if.end.i.i:                                       ; preds = %getRootParserOf.exit.i.i
  %m_accounting.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i.i, i64 0, i32 90
  %18 = load i64, ptr %m_accounting.i.i, align 8
  %tobool.not.i5.i.i = icmp eq i64 %18, 0
  %countBytesIndirect.phi.trans.insert.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i.i, i64 0, i32 90, i32 1
  %.pre.i.i = load i64, ptr %countBytesIndirect.phi.trans.insert.i.i, align 8
  br i1 %tobool.not.i5.i.i, label %accountingGetCurrentAmplification.exit.i.i, label %cond.true.i.i.i

cond.true.i.i.i:                                  ; preds = %if.end.i.i
  %add.i.i.i = add i64 %.pre.i.i, %18
  %conv.i.i.i = uitofp i64 %add.i.i.i to float
  %conv6.i.i.i = uitofp i64 %18 to float
  %div.i.i.i = fdiv float %conv.i.i.i, %conv6.i.i.i
  %19 = fpext float %div.i.i.i to double
  br label %accountingGetCurrentAmplification.exit.i.i

accountingGetCurrentAmplification.exit.i.i:       ; preds = %cond.true.i.i.i, %if.end.i.i
  %cond.i.i.i = phi double [ %19, %cond.true.i.i.i ], [ 1.000000e+00, %if.end.i.i ]
  %20 = load ptr, ptr @stderr, align 8
  %call4.i.i = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %20, ptr noundef nonnull @.str.311, ptr noundef nonnull %rootParser.0.i.i.i, i64 noundef %18, i64 noundef %.pre.i.i, double noundef %cond.i.i.i, ptr noundef nonnull @.str.317) #27
  br label %return

if.end32:                                         ; preds = %if.then28
  %21 = load ptr, ptr %next, align 8
  store ptr %21, ptr %nextPtr, align 8
  br label %return

if.then35:                                        ; preds = %if.else
  store ptr %6, ptr %nextPtr, align 8
  br label %return

if.end39:                                         ; preds = %land.lhs.true22, %land.lhs.true24, %if.else
  store ptr %6, ptr %m_eventPtr, align 8
  %22 = load ptr, ptr %m_encoding, align 8
  %23 = load ptr, ptr %22, align 8
  %call = call i32 %23(ptr noundef nonnull %22, ptr noundef %6, ptr noundef %end, ptr noundef nonnull %next) #24
  %24 = load ptr, ptr %next, align 8
  store ptr %24, ptr %m_eventEndPtr, align 8
  %cmp = icmp slt i32 %call, 1
  br i1 %cmp, label %if.then, label %if.else

switch.lookup:                                    ; preds = %if.end
  %switch.offset = sub i32 4, %call.lcssa
  br label %return

return:                                           ; preds = %switch.lookup, %accountingGetCurrentAmplification.exit.i.i, %getRootParserOf.exit.i.i, %if.end14, %if.then10, %if.then35, %if.end32, %entityValueProcessor.exit, %sw.epilog, %if.then3
  %retval.0 = phi i32 [ 0, %if.then3 ], [ %call8, %sw.epilog ], [ %retval.0.i, %entityValueProcessor.exit ], [ 2, %if.then35 ], [ 0, %if.end32 ], [ %call11, %if.then10 ], [ 35, %if.end14 ], [ 43, %getRootParserOf.exit.i.i ], [ 43, %accountingGetCurrentAmplification.exit.i.i ], [ %switch.offset, %switch.lookup ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @externalParEntProcessor(ptr noundef %parser, ptr noundef %s, ptr noundef %end, ptr noundef %nextPtr) #0 {
entry:
  %next = alloca ptr, align 8
  store ptr %s, ptr %next, align 8
  %m_encoding = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 34
  %0 = load ptr, ptr %m_encoding, align 8
  %1 = load ptr, ptr %0, align 8
  %call = call i32 %1(ptr noundef nonnull %0, ptr noundef %s, ptr noundef %end, ptr noundef nonnull %next) #24
  %cmp = icmp slt i32 %call, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %finalBuffer = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 85, i32 1
  %2 = load i8, ptr %finalBuffer, align 4
  %tobool = icmp eq i8 %2, 0
  %cmp2 = icmp ne i32 %call, 0
  %or.cond = and i1 %cmp2, %tobool
  br i1 %or.cond, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  store ptr %s, ptr %nextPtr, align 8
  br label %return

if.end:                                           ; preds = %if.then
  %switch.tableidx = add i32 %call, 2
  %3 = icmp ult i32 %switch.tableidx, 3
  br i1 %3, label %switch.lookup, label %if.end19

if.else:                                          ; preds = %entry
  %cmp7 = icmp eq i32 %call, 14
  br i1 %cmp7, label %if.then8, label %if.end19

if.then8:                                         ; preds = %if.else
  %4 = load ptr, ptr %next, align 8
  %call9 = call fastcc zeroext i8 @accountingDiffTolerated(ptr noundef nonnull %parser, i32 noundef 14, ptr noundef %s, ptr noundef %4, i32 noundef 4548, i32 noundef 0), !range !13
  %tobool10.not = icmp eq i8 %call9, 0
  br i1 %tobool10.not, label %while.cond.i.i.i, label %if.end12

while.cond.i.i.i:                                 ; preds = %if.then8, %while.cond.i.i.i
  %rootParser.0.i.i.i = phi ptr [ %5, %while.cond.i.i.i ], [ %parser, %if.then8 ]
  %m_parentParser.i.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i.i, i64 0, i32 84
  %5 = load ptr, ptr %m_parentParser.i.i.i, align 8
  %tobool.not.i.i.i = icmp eq ptr %5, null
  br i1 %tobool.not.i.i.i, label %getRootParserOf.exit.i.i, label %while.cond.i.i.i, !llvm.loop !31

getRootParserOf.exit.i.i:                         ; preds = %while.cond.i.i.i
  %debugLevel.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i.i, i64 0, i32 90, i32 2
  %6 = load i32, ptr %debugLevel.i.i, align 8
  %cmp.i.i = icmp slt i32 %6, 1
  br i1 %cmp.i.i, label %return, label %if.end.i.i

if.end.i.i:                                       ; preds = %getRootParserOf.exit.i.i
  %m_accounting.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i.i, i64 0, i32 90
  %7 = load i64, ptr %m_accounting.i.i, align 8
  %tobool.not.i5.i.i = icmp eq i64 %7, 0
  %countBytesIndirect.phi.trans.insert.i.i = getelementptr inbounds %struct.XML_ParserStruct, ptr %rootParser.0.i.i.i, i64 0, i32 90, i32 1
  %.pre.i.i = load i64, ptr %countBytesIndirect.phi.trans.insert.i.i, align 8
  br i1 %tobool.not.i5.i.i, label %accountingGetCurrentAmplification.exit.i.i, label %cond.true.i.i.i

cond.true.i.i.i:                                  ; preds = %if.end.i.i
  %add.i.i.i = add i64 %.pre.i.i, %7
  %conv.i.i.i = uitofp i64 %add.i.i.i to float
  %conv6.i.i.i = uitofp i64 %7 to float
  %div.i.i.i = fdiv float %conv.i.i.i, %conv6.i.i.i
  %8 = fpext float %div.i.i.i to double
  br label %accountingGetCurrentAmplification.exit.i.i

accountingGetCurrentAmplification.exit.i.i:       ; preds = %cond.true.i.i.i, %if.end.i.i
  %cond.i.i.i = phi double [ %8, %cond.true.i.i.i ], [ 1.000000e+00, %if.end.i.i ]
  %9 = load ptr, ptr @stderr, align 8
  %call4.i.i = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %9, ptr noundef nonnull @.str.311, ptr noundef nonnull %rootParser.0.i.i.i, i64 noundef %7, i64 noundef %.pre.i.i, double noundef %cond.i.i.i, ptr noundef nonnull @.str.317) #27
  br label %return

if.end12:                                         ; preds = %if.then8
  %10 = load ptr, ptr %next, align 8
  %11 = load ptr, ptr %m_encoding, align 8
  %12 = load ptr, ptr %11, align 8
  %call17 = call i32 %12(ptr noundef nonnull %11, ptr noundef %10, ptr noundef %end, ptr noundef nonnull %next) #24
  br label %if.end19

if.end19:                                         ; preds = %if.end, %if.else, %if.end12
  %s.addr.0 = phi ptr [ %s, %if.end ], [ %10, %if.end12 ], [ %s, %if.else ]
  %tok.0 = phi i32 [ %call, %if.end ], [ %call17, %if.end12 ], [ %call, %if.else ]
  %m_processor = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 45
  store ptr @prologProcessor, ptr %m_processor, align 8
  %13 = load ptr, ptr %m_encoding, align 8
  %14 = load ptr, ptr %next, align 8
  %finalBuffer22 = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 85, i32 1
  %15 = load i8, ptr %finalBuffer22, align 4
  %tobool23.not = icmp eq i8 %15, 0
  %conv = zext i1 %tobool23.not to i8
  %call24 = call fastcc i32 @doProlog(ptr noundef nonnull %parser, ptr noundef %13, ptr noundef %s.addr.0, ptr noundef %end, i32 noundef %tok.0, ptr noundef %14, ptr noundef %nextPtr, i8 noundef zeroext %conv, i8 noundef zeroext 1, i32 noundef 0)
  br label %return

switch.lookup:                                    ; preds = %if.end
  %switch.offset = sub i32 4, %call
  br label %return

return:                                           ; preds = %switch.lookup, %accountingGetCurrentAmplification.exit.i.i, %getRootParserOf.exit.i.i, %if.end19, %if.then3
  %retval.0 = phi i32 [ 0, %if.then3 ], [ %call24, %if.end19 ], [ 43, %getRootParserOf.exit.i.i ], [ 43, %accountingGetCurrentAmplification.exit.i.i ], [ %switch.offset, %switch.lookup ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @entityValueProcessor(ptr noundef %parser, ptr noundef %s, ptr noundef %end, ptr nocapture noundef writeonly %nextPtr) #0 {
entry:
  %next = alloca ptr, align 8
  store ptr %s, ptr %next, align 8
  %m_encoding = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 34
  %0 = load ptr, ptr %m_encoding, align 8
  %1 = load ptr, ptr %0, align 8
  %call11 = call i32 %1(ptr noundef nonnull %0, ptr noundef %s, ptr noundef %end, ptr noundef nonnull %next) #24
  %cmp12 = icmp slt i32 %call11, 1
  br i1 %cmp12, label %if.then, label %if.end7

if.then:                                          ; preds = %if.end7, %entry
  %call.lcssa = phi i32 [ %call11, %entry ], [ %call, %if.end7 ]
  %finalBuffer = getelementptr inbounds %struct.XML_ParserStruct, ptr %parser, i64 0, i32 85, i32 1
  %2 = load i8, ptr %finalBuffer, align 4
  %tobool = icmp eq i8 %2, 0
  %cmp1 = icmp ne i32 %call.lcssa, 0
  %or.cond = and i1 %cmp1, %tobool
  br i1 %or.cond, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  store ptr %s, ptr %nextPtr, align 8
  br label %return

if.end:                                           ; preds = %if.then
  %switch.tableidx = add i32 %call.lcssa, 2
  %3 = icmp ult i32 %switch.tableidx, 3
  br i1 %3, label %switch.lookup, label %sw.epilog

sw.epilog:                                        ; preds = %if.end
  %call6 = call fastcc i32 @storeEntityValue(ptr noundef nonnull %parser, ptr noundef nonnull %0, ptr noundef %s, ptr noundef %end, i32 noundef 0)
  br label %return

if.end7:                                          ; preds = %entry, %if.end7
  %4 = load ptr, ptr %next, align 8
  %5 = load ptr, ptr %0, align 8
  %call = call i32 %5(ptr noundef nonnull %0, ptr noundef %4, ptr noundef %end, ptr noundef nonnull %next) #24
  %cmp = icmp slt i32 %call, 1
  br i1 %cmp, label %if.then, label %if.end7

switch.lookup:                                    ; preds = %if.end
  %switch.offset = sub i32 4, %call.lcssa
  br label %return

return:                                           ; preds = %switch.lookup, %sw.epilog, %if.then2
  %retval.0 = phi i32 [ 0, %if.then2 ], [ %call6, %sw.epilog ], [ %switch.offset, %switch.lookup ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @copyEntityTable(ptr nocapture noundef readonly %oldParser, ptr nocapture noundef %newTable, ptr nocapture noundef %newPool, ptr nocapture noundef readonly %oldTable) unnamed_addr #0 {
entry:
  %0 = load ptr, ptr %oldTable, align 8
  %tobool.not.i = icmp eq ptr %0, null
  br i1 %tobool.not.i, label %hashTableIterInit.exit, label %cond.true.i

cond.true.i:                                      ; preds = %entry
  %size.i = getelementptr inbounds %struct.HASH_TABLE, ptr %oldTable, i64 0, i32 2
  %1 = load i64, ptr %size.i, align 8
  %add.ptr.i = getelementptr ptr, ptr %0, i64 %1
  br label %hashTableIterInit.exit

hashTableIterInit.exit:                           ; preds = %entry, %cond.true.i
  %cond.i = phi ptr [ %add.ptr.i, %cond.true.i ], [ null, %entry ]
  %ptr.i = getelementptr inbounds %struct.STRING_POOL, ptr %newPool, i64 0, i32 3
  %end.i44 = getelementptr inbounds %struct.STRING_POOL, ptr %newPool, i64 0, i32 2
  %start.i = getelementptr inbounds %struct.STRING_POOL, ptr %newPool, i64 0, i32 4
  br label %for.cond

for.cond:                                         ; preds = %if.end59, %hashTableIterInit.exit
  %iter.sroa.0.0 = phi ptr [ %0, %hashTableIterInit.exit ], [ %incdec.ptr.i, %if.end59 ]
  %cachedNewBase.0 = phi ptr [ null, %hashTableIterInit.exit ], [ %cachedNewBase.2, %if.end59 ]
  %cachedOldBase.0 = phi ptr [ null, %hashTableIterInit.exit ], [ %cachedOldBase.2, %if.end59 ]
  br label %while.cond.i

while.cond.i:                                     ; preds = %while.body.i, %for.cond
  %incdec.ptr5.i = phi ptr [ %incdec.ptr.i, %while.body.i ], [ %iter.sroa.0.0, %for.cond ]
  %cmp.not.i = icmp eq ptr %incdec.ptr5.i, %cond.i
  br i1 %cmp.not.i, label %return, label %while.body.i

while.body.i:                                     ; preds = %while.cond.i
  %incdec.ptr.i = getelementptr ptr, ptr %incdec.ptr5.i, i64 1
  %2 = load ptr, ptr %incdec.ptr5.i, align 8
  %tobool.not.i43 = icmp eq ptr %2, null
  br i1 %tobool.not.i43, label %while.cond.i, label %if.end, !llvm.loop !9

if.end:                                           ; preds = %while.body.i
  %3 = load ptr, ptr %2, align 8
  br label %do.body.i

do.body.i:                                        ; preds = %cond.false.i, %if.end
  %s.addr.0.i = phi ptr [ %3, %if.end ], [ %incdec.ptr2.i, %cond.false.i ]
  %4 = load ptr, ptr %ptr.i, align 8
  %5 = load ptr, ptr %end.i44, align 8
  %cmp.i = icmp eq ptr %4, %5
  br i1 %cmp.i, label %land.lhs.true.i, label %cond.false.i

land.lhs.true.i:                                  ; preds = %do.body.i
  %call.i = tail call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %newPool), !range !13
  %tobool.not.i47 = icmp eq i8 %call.i, 0
  br i1 %tobool.not.i47, label %return, label %land.lhs.true.cond.false_crit_edge.i

land.lhs.true.cond.false_crit_edge.i:             ; preds = %land.lhs.true.i
  %.pre.i = load ptr, ptr %ptr.i, align 8
  br label %cond.false.i

cond.false.i:                                     ; preds = %land.lhs.true.cond.false_crit_edge.i, %do.body.i
  %6 = phi ptr [ %.pre.i, %land.lhs.true.cond.false_crit_edge.i ], [ %4, %do.body.i ]
  %7 = load i8, ptr %s.addr.0.i, align 1
  %incdec.ptr.i45 = getelementptr i8, ptr %6, i64 1
  store ptr %incdec.ptr.i45, ptr %ptr.i, align 8
  store i8 %7, ptr %6, align 1
  %incdec.ptr2.i = getelementptr i8, ptr %s.addr.0.i, i64 1
  %8 = load i8, ptr %s.addr.0.i, align 1
  %tobool3.not.i = icmp eq i8 %8, 0
  br i1 %tobool3.not.i, label %poolCopyString.exit, label %do.body.i, !llvm.loop !12

poolCopyString.exit:                              ; preds = %cond.false.i
  %9 = load ptr, ptr %start.i, align 8
  %10 = load ptr, ptr %ptr.i, align 8
  store ptr %10, ptr %start.i, align 8
  %tobool3.not = icmp eq ptr %9, null
  br i1 %tobool3.not, label %return, label %if.end5

if.end5:                                          ; preds = %poolCopyString.exit
  %call6 = tail call fastcc ptr @lookup(ptr noundef %oldParser, ptr noundef %newTable, ptr noundef nonnull %9, i64 noundef 64)
  %tobool7.not = icmp eq ptr %call6, null
  br i1 %tobool7.not, label %return, label %if.end9

if.end9:                                          ; preds = %if.end5
  %systemId = getelementptr inbounds %struct.ENTITY, ptr %2, i64 0, i32 4
  %11 = load ptr, ptr %systemId, align 8
  %tobool10.not = icmp eq ptr %11, null
  br i1 %tobool10.not, label %if.else40, label %do.body.i50

do.body.i50:                                      ; preds = %if.end9, %cond.false.i53
  %s.addr.0.i51 = phi ptr [ %incdec.ptr2.i55, %cond.false.i53 ], [ %11, %if.end9 ]
  %12 = load ptr, ptr %ptr.i, align 8
  %13 = load ptr, ptr %end.i44, align 8
  %cmp.i52 = icmp eq ptr %12, %13
  br i1 %cmp.i52, label %land.lhs.true.i60, label %cond.false.i53

land.lhs.true.i60:                                ; preds = %do.body.i50
  %call.i61 = tail call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %newPool), !range !13
  %tobool.not.i62 = icmp eq i8 %call.i61, 0
  br i1 %tobool.not.i62, label %return, label %land.lhs.true.cond.false_crit_edge.i63

land.lhs.true.cond.false_crit_edge.i63:           ; preds = %land.lhs.true.i60
  %.pre.i64 = load ptr, ptr %ptr.i, align 8
  br label %cond.false.i53

cond.false.i53:                                   ; preds = %land.lhs.true.cond.false_crit_edge.i63, %do.body.i50
  %14 = phi ptr [ %.pre.i64, %land.lhs.true.cond.false_crit_edge.i63 ], [ %12, %do.body.i50 ]
  %15 = load i8, ptr %s.addr.0.i51, align 1
  %incdec.ptr.i54 = getelementptr i8, ptr %14, i64 1
  store ptr %incdec.ptr.i54, ptr %ptr.i, align 8
  store i8 %15, ptr %14, align 1
  %incdec.ptr2.i55 = getelementptr i8, ptr %s.addr.0.i51, i64 1
  %16 = load i8, ptr %s.addr.0.i51, align 1
  %tobool3.not.i56 = icmp eq i8 %16, 0
  br i1 %tobool3.not.i56, label %poolCopyString.exit65, label %do.body.i50, !llvm.loop !12

poolCopyString.exit65:                            ; preds = %cond.false.i53
  %17 = load ptr, ptr %start.i, align 8
  %18 = load ptr, ptr %ptr.i, align 8
  store ptr %18, ptr %start.i, align 8
  %tobool14.not = icmp eq ptr %17, null
  br i1 %tobool14.not, label %return, label %if.end16

if.end16:                                         ; preds = %poolCopyString.exit65
  %systemId17 = getelementptr inbounds %struct.ENTITY, ptr %call6, i64 0, i32 4
  store ptr %17, ptr %systemId17, align 8
  %base = getelementptr inbounds %struct.ENTITY, ptr %2, i64 0, i32 5
  %19 = load ptr, ptr %base, align 8
  %tobool18.not = icmp eq ptr %19, null
  br i1 %tobool18.not, label %if.end30, label %if.then19

if.then19:                                        ; preds = %if.end16
  %cmp = icmp eq ptr %19, %cachedOldBase.0
  br i1 %cmp, label %if.end30.sink.split, label %do.body.i68

do.body.i68:                                      ; preds = %if.then19, %cond.false.i71
  %s.addr.0.i69 = phi ptr [ %incdec.ptr2.i73, %cond.false.i71 ], [ %19, %if.then19 ]
  %20 = load ptr, ptr %ptr.i, align 8
  %21 = load ptr, ptr %end.i44, align 8
  %cmp.i70 = icmp eq ptr %20, %21
  br i1 %cmp.i70, label %land.lhs.true.i78, label %cond.false.i71

land.lhs.true.i78:                                ; preds = %do.body.i68
  %call.i79 = tail call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %newPool), !range !13
  %tobool.not.i80 = icmp eq i8 %call.i79, 0
  br i1 %tobool.not.i80, label %return, label %land.lhs.true.cond.false_crit_edge.i81

land.lhs.true.cond.false_crit_edge.i81:           ; preds = %land.lhs.true.i78
  %.pre.i82 = load ptr, ptr %ptr.i, align 8
  br label %cond.false.i71

cond.false.i71:                                   ; preds = %land.lhs.true.cond.false_crit_edge.i81, %do.body.i68
  %22 = phi ptr [ %.pre.i82, %land.lhs.true.cond.false_crit_edge.i81 ], [ %20, %do.body.i68 ]
  %23 = load i8, ptr %s.addr.0.i69, align 1
  %incdec.ptr.i72 = getelementptr i8, ptr %22, i64 1
  store ptr %incdec.ptr.i72, ptr %ptr.i, align 8
  store i8 %23, ptr %22, align 1
  %incdec.ptr2.i73 = getelementptr i8, ptr %s.addr.0.i69, i64 1
  %24 = load i8, ptr %s.addr.0.i69, align 1
  %tobool3.not.i74 = icmp eq i8 %24, 0
  br i1 %tobool3.not.i74, label %poolCopyString.exit83, label %do.body.i68, !llvm.loop !12

poolCopyString.exit83:                            ; preds = %cond.false.i71
  %25 = load ptr, ptr %start.i, align 8
  %26 = load ptr, ptr %ptr.i, align 8
  store ptr %26, ptr %start.i, align 8
  %tobool25.not = icmp eq ptr %25, null
  br i1 %tobool25.not, label %return, label %if.end30.sink.split

if.end30.sink.split:                              ; preds = %poolCopyString.exit83, %if.then19
  %cachedNewBase.0.sink = phi ptr [ %cachedNewBase.0, %if.then19 ], [ %25, %poolCopyString.exit83 ]
  %cachedOldBase.1.ph = phi ptr [ %cachedOldBase.0, %if.then19 ], [ %19, %poolCopyString.exit83 ]
  %base22 = getelementptr inbounds %struct.ENTITY, ptr %call6, i64 0, i32 5
  store ptr %cachedNewBase.0.sink, ptr %base22, align 8
  br label %if.end30

if.end30:                                         ; preds = %if.end30.sink.split, %if.end16
  %cachedNewBase.1 = phi ptr [ %cachedNewBase.0, %if.end16 ], [ %cachedNewBase.0.sink, %if.end30.sink.split ]
  %cachedOldBase.1 = phi ptr [ %cachedOldBase.0, %if.end16 ], [ %cachedOldBase.1.ph, %if.end30.sink.split ]
  %publicId = getelementptr inbounds %struct.ENTITY, ptr %2, i64 0, i32 6
  %27 = load ptr, ptr %publicId, align 8
  %tobool31.not = icmp eq ptr %27, null
  br i1 %tobool31.not, label %if.end49, label %do.body.i86

do.body.i86:                                      ; preds = %if.end30, %cond.false.i89
  %s.addr.0.i87 = phi ptr [ %incdec.ptr2.i91, %cond.false.i89 ], [ %27, %if.end30 ]
  %28 = load ptr, ptr %ptr.i, align 8
  %29 = load ptr, ptr %end.i44, align 8
  %cmp.i88 = icmp eq ptr %28, %29
  br i1 %cmp.i88, label %land.lhs.true.i96, label %cond.false.i89

land.lhs.true.i96:                                ; preds = %do.body.i86
  %call.i97 = tail call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %newPool), !range !13
  %tobool.not.i98 = icmp eq i8 %call.i97, 0
  br i1 %tobool.not.i98, label %return, label %land.lhs.true.cond.false_crit_edge.i99

land.lhs.true.cond.false_crit_edge.i99:           ; preds = %land.lhs.true.i96
  %.pre.i100 = load ptr, ptr %ptr.i, align 8
  br label %cond.false.i89

cond.false.i89:                                   ; preds = %land.lhs.true.cond.false_crit_edge.i99, %do.body.i86
  %30 = phi ptr [ %.pre.i100, %land.lhs.true.cond.false_crit_edge.i99 ], [ %28, %do.body.i86 ]
  %31 = load i8, ptr %s.addr.0.i87, align 1
  %incdec.ptr.i90 = getelementptr i8, ptr %30, i64 1
  store ptr %incdec.ptr.i90, ptr %ptr.i, align 8
  store i8 %31, ptr %30, align 1
  %incdec.ptr2.i91 = getelementptr i8, ptr %s.addr.0.i87, i64 1
  %32 = load i8, ptr %s.addr.0.i87, align 1
  %tobool3.not.i92 = icmp eq i8 %32, 0
  br i1 %tobool3.not.i92, label %poolCopyString.exit101, label %do.body.i86, !llvm.loop !12

poolCopyString.exit101:                           ; preds = %cond.false.i89
  %33 = load ptr, ptr %start.i, align 8
  %34 = load ptr, ptr %ptr.i, align 8
  store ptr %34, ptr %start.i, align 8
  %tobool35.not = icmp eq ptr %33, null
  br i1 %tobool35.not, label %return, label %if.end37

if.end37:                                         ; preds = %poolCopyString.exit101
  %publicId38 = getelementptr inbounds %struct.ENTITY, ptr %call6, i64 0, i32 6
  store ptr %33, ptr %publicId38, align 8
  br label %if.end49

if.else40:                                        ; preds = %if.end9
  %textPtr = getelementptr inbounds %struct.ENTITY, ptr %2, i64 0, i32 1
  %35 = load ptr, ptr %textPtr, align 8
  %textLen = getelementptr inbounds %struct.ENTITY, ptr %2, i64 0, i32 2
  %36 = load i32, ptr %textLen, align 8
  %37 = load ptr, ptr %ptr.i, align 8
  %tobool.not.i103 = icmp eq ptr %37, null
  br i1 %tobool.not.i103, label %land.lhs.true.i111, label %if.end.i

land.lhs.true.i111:                               ; preds = %if.else40
  %call.i112 = tail call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %newPool), !range !13
  %tobool1.not.i = icmp eq i8 %call.i112, 0
  br i1 %tobool1.not.i, label %return, label %if.end.i

if.end.i:                                         ; preds = %land.lhs.true.i111, %if.else40
  %cmp12.i = icmp sgt i32 %36, 0
  br i1 %cmp12.i, label %for.body.i, label %poolCopyStringN.exit

for.body.i:                                       ; preds = %if.end.i, %cond.false.i107
  %n.addr.014.i = phi i32 [ %dec.i, %cond.false.i107 ], [ %36, %if.end.i ]
  %s.addr.013.i = phi ptr [ %incdec.ptr10.i, %cond.false.i107 ], [ %35, %if.end.i ]
  %38 = load ptr, ptr %ptr.i, align 8
  %39 = load ptr, ptr %end.i44, align 8
  %cmp3.i = icmp eq ptr %38, %39
  br i1 %cmp3.i, label %land.lhs.true4.i, label %cond.false.i107

land.lhs.true4.i:                                 ; preds = %for.body.i
  %call5.i = tail call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %newPool), !range !13
  %tobool6.not.i = icmp eq i8 %call5.i, 0
  br i1 %tobool6.not.i, label %return, label %land.lhs.true4.cond.false_crit_edge.i

land.lhs.true4.cond.false_crit_edge.i:            ; preds = %land.lhs.true4.i
  %.pre.i110 = load ptr, ptr %ptr.i, align 8
  br label %cond.false.i107

cond.false.i107:                                  ; preds = %land.lhs.true4.cond.false_crit_edge.i, %for.body.i
  %40 = phi ptr [ %.pre.i110, %land.lhs.true4.cond.false_crit_edge.i ], [ %38, %for.body.i ]
  %41 = load i8, ptr %s.addr.013.i, align 1
  %incdec.ptr.i108 = getelementptr i8, ptr %40, i64 1
  store ptr %incdec.ptr.i108, ptr %ptr.i, align 8
  store i8 %41, ptr %40, align 1
  %dec.i = add nsw i32 %n.addr.014.i, -1
  %incdec.ptr10.i = getelementptr i8, ptr %s.addr.013.i, i64 1
  %cmp.i109 = icmp sgt i32 %n.addr.014.i, 1
  br i1 %cmp.i109, label %for.body.i, label %poolCopyStringN.exit, !llvm.loop !86

poolCopyStringN.exit:                             ; preds = %cond.false.i107, %if.end.i
  %42 = load ptr, ptr %start.i, align 8
  %43 = load ptr, ptr %ptr.i, align 8
  store ptr %43, ptr %start.i, align 8
  %tobool43.not = icmp eq ptr %42, null
  br i1 %tobool43.not, label %return, label %if.end45

if.end45:                                         ; preds = %poolCopyStringN.exit
  %textPtr46 = getelementptr inbounds %struct.ENTITY, ptr %call6, i64 0, i32 1
  store ptr %42, ptr %textPtr46, align 8
  %44 = load i32, ptr %textLen, align 8
  %textLen48 = getelementptr inbounds %struct.ENTITY, ptr %call6, i64 0, i32 2
  store i32 %44, ptr %textLen48, align 8
  br label %if.end49

if.end49:                                         ; preds = %if.end30, %if.end37, %if.end45
  %cachedNewBase.2 = phi ptr [ %cachedNewBase.1, %if.end37 ], [ %cachedNewBase.1, %if.end30 ], [ %cachedNewBase.0, %if.end45 ]
  %cachedOldBase.2 = phi ptr [ %cachedOldBase.1, %if.end37 ], [ %cachedOldBase.1, %if.end30 ], [ %cachedOldBase.0, %if.end45 ]
  %notation = getelementptr inbounds %struct.ENTITY, ptr %2, i64 0, i32 7
  %45 = load ptr, ptr %notation, align 8
  %tobool50.not = icmp eq ptr %45, null
  br i1 %tobool50.not, label %if.end59, label %do.body.i115

do.body.i115:                                     ; preds = %if.end49, %cond.false.i118
  %s.addr.0.i116 = phi ptr [ %incdec.ptr2.i120, %cond.false.i118 ], [ %45, %if.end49 ]
  %46 = load ptr, ptr %ptr.i, align 8
  %47 = load ptr, ptr %end.i44, align 8
  %cmp.i117 = icmp eq ptr %46, %47
  br i1 %cmp.i117, label %land.lhs.true.i125, label %cond.false.i118

land.lhs.true.i125:                               ; preds = %do.body.i115
  %call.i126 = tail call fastcc zeroext i8 @poolGrow(ptr noundef nonnull %newPool), !range !13
  %tobool.not.i127 = icmp eq i8 %call.i126, 0
  br i1 %tobool.not.i127, label %return, label %land.lhs.true.cond.false_crit_edge.i128

land.lhs.true.cond.false_crit_edge.i128:          ; preds = %land.lhs.true.i125
  %.pre.i129 = load ptr, ptr %ptr.i, align 8
  br label %cond.false.i118

cond.false.i118:                                  ; preds = %land.lhs.true.cond.false_crit_edge.i128, %do.body.i115
  %48 = phi ptr [ %.pre.i129, %land.lhs.true.cond.false_crit_edge.i128 ], [ %46, %do.body.i115 ]
  %49 = load i8, ptr %s.addr.0.i116, align 1
  %incdec.ptr.i119 = getelementptr i8, ptr %48, i64 1
  store ptr %incdec.ptr.i119, ptr %ptr.i, align 8
  store i8 %49, ptr %48, align 1
  %incdec.ptr2.i120 = getelementptr i8, ptr %s.addr.0.i116, i64 1
  %50 = load i8, ptr %s.addr.0.i116, align 1
  %tobool3.not.i121 = icmp eq i8 %50, 0
  br i1 %tobool3.not.i121, label %poolCopyString.exit130, label %do.body.i115, !llvm.loop !12

poolCopyString.exit130:                           ; preds = %cond.false.i118
  %51 = load ptr, ptr %start.i, align 8
  %52 = load ptr, ptr %ptr.i, align 8
  store ptr %52, ptr %start.i, align 8
  %tobool55.not = icmp eq ptr %51, null
  br i1 %tobool55.not, label %return, label %if.end57

if.end57:                                         ; preds = %poolCopyString.exit130
  %notation58 = getelementptr inbounds %struct.ENTITY, ptr %call6, i64 0, i32 7
  store ptr %51, ptr %notation58, align 8
  br label %if.end59

if.end59:                                         ; preds = %if.end57, %if.end49
  %is_param = getelementptr inbounds %struct.ENTITY, ptr %2, i64 0, i32 9
  %53 = load i8, ptr %is_param, align 1
  %is_param60 = getelementptr inbounds %struct.ENTITY, ptr %call6, i64 0, i32 9
  store i8 %53, ptr %is_param60, align 1
  %is_internal = getelementptr inbounds %struct.ENTITY, ptr %2, i64 0, i32 10
  %54 = load i8, ptr %is_internal, align 2
  %is_internal61 = getelementptr inbounds %struct.ENTITY, ptr %call6, i64 0, i32 10
  store i8 %54, ptr %is_internal61, align 2
  br label %for.cond

return:                                           ; preds = %land.lhs.true.i111, %poolCopyString.exit130, %poolCopyStringN.exit, %poolCopyString.exit101, %poolCopyString.exit83, %poolCopyString.exit65, %if.end5, %poolCopyString.exit, %while.cond.i, %land.lhs.true.i, %land.lhs.true.i60, %land.lhs.true.i78, %land.lhs.true.i96, %land.lhs.true4.i, %land.lhs.true.i125
  %retval.0 = phi i32 [ 0, %land.lhs.true.i125 ], [ 0, %land.lhs.true4.i ], [ 0, %land.lhs.true.i96 ], [ 0, %land.lhs.true.i78 ], [ 0, %land.lhs.true.i60 ], [ 0, %land.lhs.true.i ], [ 1, %while.cond.i ], [ 0, %poolCopyString.exit ], [ 0, %if.end5 ], [ 0, %poolCopyString.exit65 ], [ 0, %poolCopyString.exit83 ], [ 0, %poolCopyString.exit101 ], [ 0, %poolCopyStringN.exit ], [ 0, %poolCopyString.exit130 ], [ 0, %land.lhs.true.i111 ]
  ret i32 %retval.0
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smin.i32(i32, i32) #20

; Function Attrs: nofree nounwind
declare noundef i64 @fwrite(ptr nocapture noundef, i64 noundef, i64 noundef, ptr nocapture noundef) local_unnamed_addr #21

; Function Attrs: nofree nounwind
declare noundef i32 @fputs(ptr nocapture noundef readonly, ptr nocapture noundef) local_unnamed_addr #21

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.fshl.i64(i64, i64, i64) #20

; Function Attrs: nofree nounwind willreturn memory(argmem: read)
declare i32 @bcmp(ptr nocapture, ptr nocapture, i64) local_unnamed_addr #22

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #23

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #23

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smax.i32(i32, i32) #20

attributes #0 = { nounwind uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #2 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #4 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #5 = { nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #6 = { mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #7 = { mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #8 = { mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite) "alloc-family"="malloc" "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #9 = { mustprogress nounwind willreturn allockind("realloc") allocsize(1) memory(argmem: readwrite, inaccessiblemem: readwrite) "alloc-family"="malloc" "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #10 = { mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite) "alloc-family"="malloc" "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #11 = { mustprogress nocallback nofree nounwind willreturn memory(argmem: write) }
attributes #12 = { nofree nounwind uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #13 = { nofree nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #14 = { nofree nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #15 = { nofree nosync nounwind memory(argmem: readwrite) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #16 = { nofree nounwind memory(read) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #17 = { mustprogress nofree nosync nounwind willreturn memory(none) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #18 = { mustprogress nofree nounwind willreturn "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #19 = { nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #20 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #21 = { nofree nounwind }
attributes #22 = { nofree nounwind willreturn memory(argmem: read) }
attributes #23 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #24 = { nounwind }
attributes #25 = { nounwind allocsize(0) }
attributes #26 = { nounwind willreturn memory(none) }
attributes #27 = { cold }

!llvm.module.flags = !{!0, !1, !2, !3}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"uwtable", i32 2}
!3 = !{i32 7, !"frame-pointer", i32 2}
!4 = distinct !{!4, !5}
!5 = !{!"llvm.loop.mustprogress"}
!6 = distinct !{!6, !5}
!7 = distinct !{!7, !5}
!8 = distinct !{!8, !5}
!9 = distinct !{!9, !5}
!10 = distinct !{!10, !5}
!11 = distinct !{!11, !5}
!12 = distinct !{!12, !5}
!13 = !{i8 0, i8 2}
!14 = distinct !{!14, !5}
!15 = distinct !{!15, !5}
!16 = distinct !{!16, !5}
!17 = !{i32 0, i32 2}
!18 = distinct !{!18, !5}
!19 = !{i32 0, i32 41}
!20 = distinct !{!20, !5}
!21 = distinct !{!21, !5}
!22 = distinct !{!22, !5}
!23 = distinct !{!23, !5}
!24 = !{i32 0, i32 19}
!25 = !{i32 0, i32 3}
!26 = distinct !{!26, !5}
!27 = distinct !{!27, !5}
!28 = distinct !{!28, !5}
!29 = !{ptr @PyExpat_XmlInitEncoding, ptr @PyExpat_XmlInitEncodingNS}
!30 = !{ptr @PyExpat_XmlInitUnknownEncoding, ptr @PyExpat_XmlInitUnknownEncodingNS}
!31 = distinct !{!31, !5}
!32 = !{i32 0, i32 44}
!33 = distinct !{!33, !5}
!34 = distinct !{!34, !5}
!35 = distinct !{!35, !5}
!36 = distinct !{!36, !5}
!37 = distinct !{!37, !5}
!38 = distinct !{!38, !5}
!39 = distinct !{!39, !5}
!40 = distinct !{!40, !5}
!41 = distinct !{!41, !5}
!42 = !{ptr @PyExpat_XmlParseXmlDecl, ptr @PyExpat_XmlParseXmlDeclNS}
!43 = distinct !{!43, !5}
!44 = distinct !{!44, !5}
!45 = distinct !{!45, !5}
!46 = distinct !{!46, !5}
!47 = distinct !{!47, !5}
!48 = distinct !{!48, !5}
!49 = distinct !{!49, !5}
!50 = distinct !{!50, !5}
!51 = distinct !{!51, !5}
!52 = distinct !{!52, !5}
!53 = distinct !{!53, !5}
!54 = distinct !{!54, !5}
!55 = distinct !{!55, !5}
!56 = distinct !{!56, !5}
!57 = distinct !{!57, !5}
!58 = distinct !{!58, !5}
!59 = distinct !{!59, !5}
!60 = distinct !{!60, !5}
!61 = distinct !{!61, !5}
!62 = distinct !{!62, !5}
!63 = distinct !{!63, !5}
!64 = distinct !{!64, !5}
!65 = distinct !{!65, !5}
!66 = distinct !{!66, !5}
!67 = distinct !{!67, !5}
!68 = distinct !{!68, !5}
!69 = distinct !{!69, !5}
!70 = distinct !{!70, !5}
!71 = distinct !{!71, !5}
!72 = distinct !{!72, !5}
!73 = distinct !{!73, !5}
!74 = distinct !{!74, !5}
!75 = distinct !{!75, !5}
!76 = distinct !{!76, !5}
!77 = distinct !{!77, !5}
!78 = distinct !{!78, !5}
!79 = distinct !{!79, !5}
!80 = distinct !{!80, !5}
!81 = distinct !{!81, !5}
!82 = distinct !{!82, !5}
!83 = distinct !{!83, !5}
!84 = distinct !{!84, !5}
!85 = distinct !{!85, !5}
!86 = distinct !{!86, !5}
